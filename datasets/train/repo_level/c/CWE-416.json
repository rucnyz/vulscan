[
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic zend_always_inline uint32_t zend_gc_refcount(const zend_refcounted_h *p) {\n\treturn p->refcount;\n}\n\nstatic zend_always_inline uint32_t zval_refcount_p(const zval* pz) {\n#if ZEND_DEBUG\n\tZEND_ASSERT(Z_REFCOUNTED_P(pz) || Z_TYPE_P(pz) == IS_ARRAY);\n#endif\n\treturn GC_REFCOUNT(Z_COUNTED_P(pz));\n}\n\nstatic int zval_call_destructor(zval *zv) /* {{{ */\n{\n\tif (Z_TYPE_P(zv) == IS_INDIRECT) {\n\t\tzv = Z_INDIRECT_P(zv);\n\t}\n\tif (Z_TYPE_P(zv) == IS_OBJECT && Z_REFCOUNT_P(zv) == 1) {\n\t\treturn ZEND_HASH_APPLY_REMOVE;\n\t} else {\n\t\treturn ZEND_HASH_APPLY_KEEP;\n\t}\n}\n\nZEND_API void ZEND_FASTCALL zend_hash_reverse_apply(HashTable *ht, apply_func_t apply_func)\n{\n\tuint32_t idx;\n\tint result;\n\n\tIS_CONSISTENT(ht);\n\n\tidx = ht->nNumUsed;\n\tif (HT_IS_PACKED(ht)) {\n\t\tzval *zv;\n\n\t\twhile (idx > 0) {\n\t\t\tidx--;\n\t\t\tzv = ht->arPacked + idx;\n\t\t\tif (UNEXPECTED(Z_TYPE_P(zv) == IS_UNDEF)) continue;\n\n\t\t\tresult = apply_func(zv);\n\n\t\t\tif (result & ZEND_HASH_APPLY_REMOVE) {\n\t\t\t\tHT_ASSERT_RC1(ht);\n\t\t\t\t_zend_hash_packed_del_val(ht, HT_IDX_TO_HASH(idx), zv);\n\t\t\t}\n\t\t\tif (result & ZEND_HASH_APPLY_STOP) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tBucket *p;\n\n\t\twhile (idx > 0) {\n\t\t\tidx--;\n\t\t\tp = ht->arData + idx;\n\t\t\tif (UNEXPECTED(Z_TYPE(p->val) == IS_UNDEF)) continue;\n\n\t\t\tresult = apply_func(&p->val);\n\n\t\t\tif (result & ZEND_HASH_APPLY_REMOVE) {\n\t\t\t\tHT_ASSERT_RC1(ht);\n\t\t\t\t_zend_hash_del_el(ht, HT_IDX_TO_HASH(idx), p);\n\t\t\t}\n\t\t\tif (result & ZEND_HASH_APPLY_STOP) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid shutdown_destructors(void) /* {{{ */\n{\n\tif (CG(unclean_shutdown)) {\n\t\tEG(symbol_table).pDestructor = zend_unclean_zval_ptr_dtor;\n\t}\n\tzend_try {\n\t\tuint32_t symbols;\n\t\tdo {\n\t\t\tsymbols = zend_hash_num_elements(&EG(symbol_table));\n\t\t\tzend_hash_reverse_apply(&EG(symbol_table), (apply_func_t) zval_call_destructor);\n\t\t} while (symbols != zend_hash_num_elements(&EG(symbol_table)));\n\t\tzend_objects_store_call_destructors(&EG(objects_store));\n\t} zend_catch {\n\nvoid zend_call_destructors(void) /* {{{ */\n{\n\tzend_try {\n\t\tshutdown_destructors();\n\t} zend_end_try();\n\nvoid php_request_shutdown(void *dummy)\n{\n\tbool report_memleaks;\n\n\tEG(flags) |= EG_FLAGS_IN_SHUTDOWN;\n\n\treport_memleaks = PG(report_memleaks);\n\n\t/* EG(current_execute_data) points into nirvana and therefore cannot be safely accessed\n\t * inside zend_executor callback functions.\n\t */\n\tEG(current_execute_data) = NULL;\n\n\tphp_deactivate_ticks();\n\n\t/* 0. Call any open observer end handlers that are still open after a zend_bailout */\n\tif (ZEND_OBSERVER_ENABLED) {\n\t\tzend_observer_fcall_end_all();\n\t}\n\n\t/* 1. Call all possible shutdown functions registered with register_shutdown_function() */\n\tif (PG(modules_activated)) {\n\t\tphp_call_shutdown_functions();\n\t}\n\n\t/* 2. Call all possible __destruct() functions */\n\tzend_try {\n\t\tzend_call_destructors();\n\t} zend_end_try();\n\nvoid fuzzer_request_shutdown(void)\n{\n\tzend_try {\n\t\t/* Destroy thrown exceptions. This does not happen as part of request shutdown. */\n\t\tif (EG(exception)) {\n\t\t\tzend_object_release(EG(exception));\n\t\t\tEG(exception) = NULL;\n\t\t}\n\n\t\t/* Some fuzzers (like unserialize) may create circular structures. Make sure we free them.\n\t\t * Two calls are performed to handle objects with destructors. */\n\t\tzend_gc_collect_cycles();\n\t\tzend_gc_collect_cycles();\n\t} zend_end_try();\n\nint fuzzer_do_request_from_buffer(\n\t\tchar *filename, const char *data, size_t data_len, bool execute,\n\t\tvoid (*before_shutdown)(void))\n{\n\tint retval = FAILURE; /* failure by default */\n\n\tSG(options) |= SAPI_OPTION_NO_CHDIR;\n\tSG(request_info).argc=0;\n\tSG(request_info).argv=NULL;\n\n\tif (fuzzer_request_startup() == FAILURE) {\n\t\treturn FAILURE;\n\t}\n\n\t// Commented out to avoid leaking the header callback.\n\t//SG(headers_sent) = 1;\n\t//SG(request_info).no_headers = 1;\n\tphp_register_variable(\"PHP_SELF\", filename, NULL);\n\n\tzend_first_try {\n\t\tzend_file_handle file_handle;\n\t\tzend_stream_init_filename(&file_handle, filename);\n\t\tfile_handle.primary_script = 1;\n\t\tfile_handle.buf = emalloc(data_len + ZEND_MMAP_AHEAD);\n\t\tmemcpy(file_handle.buf, data, data_len);\n\t\tmemset(file_handle.buf + data_len, 0, ZEND_MMAP_AHEAD);\n\t\tfile_handle.len = data_len;\n\t\t/* Avoid ZEND_HANDLE_FILENAME for opcache. */\n\t\tfile_handle.type = ZEND_HANDLE_STREAM;\n\n\t\tzend_op_array *op_array = zend_compile_file(&file_handle, ZEND_REQUIRE);\n\t\tzend_destroy_file_handle(&file_handle);\n\t\tif (op_array) {\n\t\t\tif (execute) {\n\t\t\t\tzend_execute(op_array, NULL);\n\t\t\t}\n\t\t\tzend_destroy_static_vars(op_array);\n\t\t\tdestroy_op_array(op_array);\n\t\t\tefree(op_array);\n\t\t}\n\t} zend_end_try();\n\n\n// target function\nZEND_API zend_result ZEND_FASTCALL concat_function(zval *result, zval *op1, zval *op2) /* {{{ */\n{\n\tzval *orig_op1 = op1;\n\tzend_string *op1_string, *op2_string;\n\tbool free_op1_string = false;\n\tbool free_op2_string = false;\n\n\tdo {\n\t\tif (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {\n\t\t\top1_string = Z_STR_P(op1);\n\t\t} else {\n\t \t\tif (Z_ISREF_P(op1)) {\n\t \t\t\top1 = Z_REFVAL_P(op1);\n\t\t\t\tif (Z_TYPE_P(op1) == IS_STRING) {\n\t\t\t\t\top1_string = Z_STR_P(op1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t \t\t}\n\t\t\tZEND_TRY_BINARY_OBJECT_OPERATION(ZEND_CONCAT);\n\t\t\top1_string = zval_get_string_func(op1);\n\t\t\tif (UNEXPECTED(EG(exception))) {\n\t\t\t\tzend_string_release(op1_string);\n\t\t\t\tif (orig_op1 != result) {\n\t\t\t\t\tZVAL_UNDEF(result);\n\t\t\t\t}\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tfree_op1_string = true;\n\t\t\tif (result == op1) {\n\t\t\t\tif (UNEXPECTED(op1 == op2)) {\n\t\t\t\t\top2_string = op1_string;\n\t\t\t\t\tgoto has_op2_string;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} while (0);\n\tdo {\n\t\tif (EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {\n\t\t\top2_string = Z_STR_P(op2);\n\t\t} else {\n\t\t\tif (Z_ISREF_P(op2)) {\n\t\t\t\top2 = Z_REFVAL_P(op2);\n\t\t\t\tif (Z_TYPE_P(op2) == IS_STRING) {\n\t\t\t\t\top2_string = Z_STR_P(op2);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* hold an additional reference because a userland function could free this */\n\t\t\tif (!free_op1_string) {\n\t\t\t\top1_string = zend_string_copy(op1_string);\n\t\t\t\tfree_op1_string = true;\n\t\t\t}\n\t\t\tZEND_TRY_BINARY_OP2_OBJECT_OPERATION(ZEND_CONCAT);\n\t\t\top2_string = zval_get_string_func(op2);\n\t\t\tif (UNEXPECTED(EG(exception))) {\n\t\t\t\tzend_string_release(op1_string);\n\t\t\t\tzend_string_release(op2_string);\n\t\t\t\tif (orig_op1 != result) {\n\t\t\t\t\tZVAL_UNDEF(result);\n\t\t\t\t}\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tfree_op2_string = true;\n\t\t}\n\t} while (0);\n\nhas_op2_string:;\n\tif (UNEXPECTED(ZSTR_LEN(op1_string) == 0)) {\n\t\tif (EXPECTED(result != op2 || Z_TYPE_P(result) != IS_STRING)) {\n\t\t\tif (result == orig_op1) {\n\t\t\t\ti_zval_ptr_dtor(result);\n\t\t\t}\n\t\t\tif (free_op2_string) {\n\t\t\t\t/* transfer ownership of op2_string */\n\t\t\t\tZVAL_STR(result, op2_string);\n\t\t\t\tfree_op2_string = false;\n\t\t\t} else {\n\t\t\t\tZVAL_STR_COPY(result, op2_string);\n\t\t\t}\n\t\t}\n\t} else if (UNEXPECTED(ZSTR_LEN(op2_string) == 0)) {\n\t\tif (EXPECTED(result != op1 || Z_TYPE_P(result) != IS_STRING)) {\n\t\t\tif (result == orig_op1) {\n\t\t\t\ti_zval_ptr_dtor(result);\n\t\t\t}\n\t\t\tif (free_op1_string) {\n\t\t\t\t/* transfer ownership of op1_string */\n\t\t\t\tZVAL_STR(result, op1_string);\n\t\t\t\tfree_op1_string = false;\n\t\t\t} else {\n\t\t\t\tZVAL_STR_COPY(result, op1_string);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tsize_t op1_len = ZSTR_LEN(op1_string);\n\t\tsize_t op2_len = ZSTR_LEN(op2_string);\n\t\tsize_t result_len = op1_len + op2_len;\n\t\tzend_string *result_str;\n\t\tuint32_t flags = ZSTR_GET_COPYABLE_CONCAT_PROPERTIES_BOTH(op1_string, op2_string);\n\n\t\tif (UNEXPECTED(op1_len > ZSTR_MAX_LEN - op2_len)) {\n\t\t\tif (free_op1_string) zend_string_release(op1_string);\n\t\t\tif (free_op2_string) zend_string_release(op2_string);\n\t\t\tzend_throw_error(NULL, \"String size overflow\");\n\t\t\tif (orig_op1 != result) {\n\t\t\t\tZVAL_UNDEF(result);\n\t\t\t}\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\tif (result == op1) {\n\t\t\tif (free_op1_string) {\n\t\t\t\t/* op1_string will be used as the result, so we should not free it */\n\t\t\t\ti_zval_ptr_dtor(result);\n\t\t\t\tfree_op1_string = false;\n\t\t\t}\n\t\t\t/* special case, perform operations on result */\n\t\t\tresult_str = zend_string_extend(op1_string, result_len, 0);\n\t\t\t/* account for the case where result_str == op1_string == op2_string and the realloc is done */\n\t\t\tif (op1_string == op2_string) {\n\t\t\t\tif (free_op2_string) {\n\t\t\t\t\tzend_string_release(op2_string);\n\t\t\t\t\tfree_op2_string = false;\n\t\t\t\t}\n\t\t\t\top2_string = result_str;\n\t\t\t}\n\t\t} else {\n\t\t\tresult_str = zend_string_alloc(result_len, 0);\n\t\t\tmemcpy(ZSTR_VAL(result_str), ZSTR_VAL(op1_string), op1_len);\n\t\t\tif (result == orig_op1) {\n\t\t\t\ti_zval_ptr_dtor(result);\n\t\t\t}\n\t\t}\n\t\tGC_ADD_FLAGS(result_str, flags);\n\n\t\tZVAL_NEW_STR(result, result_str);\n\t\tmemcpy(ZSTR_VAL(result_str) + op1_len, ZSTR_VAL(op2_string), op2_len);\n\t\tZSTR_VAL(result_str)[result_len] = '\\0';\n\t}\n\n\tif (free_op1_string) zend_string_release(op1_string);\n\tif (free_op2_string) zend_string_release(op2_string);\n\n\treturn SUCCESS;\n}\n",
    "target": 1,
    "idx": 1059072,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic int\nxmlXIncludeIncludeNode(xmlXIncludeCtxtPtr ctxt, xmlXIncludeRefPtr ref) {\n    xmlNodePtr cur, end, list, tmp;\n\n    if ((ctxt == NULL) || (ref == NULL))\n\treturn(-1);\n    cur = ref->elem;\n    if ((cur == NULL) || (cur->type == XML_NAMESPACE_DECL))\n\treturn(-1);\n\n    list = ref->inc;\n    ref->inc = NULL;\n    ref->emptyFb = 0;\n\n    /*\n     * Check against the risk of generating a multi-rooted document\n     */\n    if ((cur->parent != NULL) &&\n\t(cur->parent->type != XML_ELEMENT_NODE)) {\n\tint nb_elem = 0;\n\n\ttmp = list;\n\twhile (tmp != NULL) {\n\t    if (tmp->type == XML_ELEMENT_NODE)\n\t\tnb_elem++;\n\t    tmp = tmp->next;\n\t}\n\tif (nb_elem > 1) {\n\t    xmlXIncludeErr(ctxt, ref->elem, XML_XINCLUDE_MULTIPLE_ROOT,\n\t\t       \"XInclude error: would result in multiple root nodes\\n\",\n\t\t\t   NULL);\n            xmlFreeNodeList(list);\n\t    return(-1);\n\t}\n    }\n\n    if (ctxt->parseFlags & XML_PARSE_NOXINCNODE) {\n\t/*\n\t * Add the list of nodes\n\t */\n\twhile (list != NULL) {\n\t    end = list;\n\t    list = list->next;\n\n\t    xmlAddPrevSibling(cur, end);\n\t}\n        /*\n         * FIXME: xmlUnlinkNode doesn't coalesce text nodes.\n         */\n\txmlUnlinkNode(cur);\n\txmlFreeNode(cur);\n    } else {\n        xmlNodePtr child, next;\n\n\t/*\n\t * Change the current node as an XInclude start one, and add an\n\t * XInclude end one\n\t */\n        if (ref->fallback)\n            xmlUnsetProp(cur, BAD_CAST \"href\");\n\tcur->type = XML_XINCLUDE_START;\n        /* Remove fallback children */\n        for (child = cur->children; child != NULL; child = next) {\n            next = child->next;\n            xmlUnlinkNode(child);\n            xmlFreeNode(child);\n        }\n\tend = xmlNewDocNode(cur->doc, cur->ns, cur->name, NULL);\n\tif (end == NULL) {\n\t    xmlXIncludeErr(ctxt, ref->elem, XML_XINCLUDE_BUILD_FAILED,\n\t\t\t   \"failed to build node\\n\", NULL);\n            xmlFreeNodeList(list);\n\t    return(-1);\n\t}\n\tend->type = XML_XINCLUDE_END;\n\txmlAddNextSibling(cur, end);\n\n\t/*\n\t * Add the list of nodes\n\t */\n\twhile (list != NULL) {\n\t    cur = list;\n\t    list = list->next;\n\n\t    xmlAddPrevSibling(end, cur);\n\t}\n    }\n\n\n    return(0);\n}\n\nstatic int\nxmlXIncludeDoProcess(xmlXIncludeCtxtPtr ctxt, xmlNodePtr tree) {\n    xmlXIncludeRefPtr ref;\n    xmlNodePtr cur;\n    int ret = 0;\n    int i;\n\n    if ((tree == NULL) || (tree->type == XML_NAMESPACE_DECL))\n\treturn(-1);\n    if (ctxt == NULL)\n\treturn(-1);\n\n    /*\n     * First phase: lookup the elements in the document\n     */\n    cur = tree;\n    do {\n\t/* TODO: need to work on entities -> stack */\n        if (xmlXIncludeTestNode(ctxt, cur) == 1) {\n#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n            /*\n             * Avoid superlinear expansion by limiting the total number\n             * of replacements.\n             */\n            if (ctxt->incTotal >= 20)\n                break;\n#endif\n            ctxt->incTotal++;\n            ref = xmlXIncludeExpandNode(ctxt, cur);\n            /*\n             * Mark direct includes.\n             */\n            if (ref != NULL)\n                ref->replace = 1;\n        } else if ((cur->children != NULL) &&\n                   ((cur->type == XML_DOCUMENT_NODE) ||\n                    (cur->type == XML_ELEMENT_NODE))) {\n            cur = cur->children;\n            continue;\n        }\n        do {\n            if (cur == tree)\n                break;\n            if (cur->next != NULL) {\n                cur = cur->next;\n                break;\n            }\n            cur = cur->parent;\n        } while (cur != NULL);\n    } while ((cur != NULL) && (cur != tree));\n\n    /*\n     * Second phase: extend the original document infoset.\n     */\n    for (i = 0; i < ctxt->incNr; i++) {\n\tif (ctxt->incTab[i]->replace != 0) {\n            if ((ctxt->incTab[i]->inc != NULL) ||\n                (ctxt->incTab[i]->emptyFb != 0)) {\t/* (empty fallback) */\n                xmlXIncludeIncludeNode(ctxt, ctxt->incTab[i]);\n                ctxt->incTab[i]->replace = 0;\n            }\n        } else {\n            /*\n             * Ignore includes which were added indirectly, for example\n             * inside xi:fallback elements.\n             */\n            if (ctxt->incTab[i]->inc != NULL) {\n                xmlFreeNodeList(ctxt->incTab[i]->inc);\n                ctxt->incTab[i]->inc = NULL;\n            }\n        }\n\tret++;\n    }\n\n    return(ret);\n}\n\nint\nxmlXIncludeProcessNode(xmlXIncludeCtxtPtr ctxt, xmlNodePtr node) {\n    int ret = 0;\n\n    if ((node == NULL) || (node->type == XML_NAMESPACE_DECL) ||\n        (node->doc == NULL) || (ctxt == NULL))\n\treturn(-1);\n    ret = xmlXIncludeDoProcess(ctxt, node);\n    if ((ret >= 0) && (ctxt->nbErrors > 0))\n\tret = -1;\n    return(ret);\n}\n\nint\nxmlTextReaderRead(xmlTextReaderPtr reader) {\n    int val, olddepth = 0;\n    xmlTextReaderState oldstate = XML_TEXTREADER_START;\n    xmlNodePtr oldnode = NULL;\n\n\n    if (reader == NULL)\n\treturn(-1);\n    reader->curnode = NULL;\n    if (reader->doc != NULL)\n        return(xmlTextReaderReadTree(reader));\n    if (reader->ctxt == NULL)\n\treturn(-1);\n\n#ifdef DEBUG_READER\n    fprintf(stderr, \"\\nREAD \");\n    DUMP_READER\n#endif\n    if (reader->mode == XML_TEXTREADER_MODE_INITIAL) {\n\treader->mode = XML_TEXTREADER_MODE_INTERACTIVE;\n\t/*\n\t * Initial state\n\t */\n\tdo {\n\t    val = xmlTextReaderPushData(reader);\n\t\tif (val < 0){\n\t\t\treader->mode = XML_TEXTREADER_MODE_ERROR;\n\t\t\treader->state = XML_TEXTREADER_ERROR;\n\t\treturn(-1);\n\t\t}\n\t} while ((reader->ctxt->node == NULL) &&\n\t\t ((reader->mode != XML_TEXTREADER_MODE_EOF) &&\n\t\t  (reader->state != XML_TEXTREADER_DONE)));\n\tif (reader->ctxt->node == NULL) {\n\t    if (reader->ctxt->myDoc != NULL) {\n\t\treader->node = reader->ctxt->myDoc->children;\n\t    }\n\t    if (reader->node == NULL){\n\t\t\treader->mode = XML_TEXTREADER_MODE_ERROR;\n\t\t\treader->state = XML_TEXTREADER_ERROR;\n\t\treturn(-1);\n\t\t}\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t} else {\n\t    if (reader->ctxt->myDoc != NULL) {\n\t\treader->node = reader->ctxt->myDoc->children;\n\t    }\n\t    if (reader->node == NULL)\n\t\treader->node = reader->ctxt->nodeTab[0];\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t}\n\treader->depth = 0;\n\treader->ctxt->parseMode = XML_PARSE_READER;\n\tgoto node_found;\n    }\n    oldstate = reader->state;\n    olddepth = reader->ctxt->nodeNr;\n    oldnode = reader->node;\n\nget_next_node:\n    if (reader->node == NULL) {\n\tif (reader->mode == XML_TEXTREADER_MODE_EOF)\n\t    return(0);\n\telse\n\t    return(-1);\n    }\n\n    /*\n     * If we are not backtracking on ancestors or examined nodes,\n     * that the parser didn't finished or that we aren't at the end\n     * of stream, continue processing.\n     */\n    while ((reader->node != NULL) && (reader->node->next == NULL) &&\n\t   (reader->ctxt->nodeNr == olddepth) &&\n           ((oldstate == XML_TEXTREADER_BACKTRACK) ||\n            (reader->node->children == NULL) ||\n\t    (reader->node->type == XML_ENTITY_REF_NODE) ||\n\t    ((reader->node->children != NULL) &&\n\t     (reader->node->children->type == XML_TEXT_NODE) &&\n\t     (reader->node->children->next == NULL)) ||\n\t    (reader->node->type == XML_DTD_NODE) ||\n\t    (reader->node->type == XML_DOCUMENT_NODE) ||\n\t    (reader->node->type == XML_HTML_DOCUMENT_NODE)) &&\n\t   ((reader->ctxt->node == NULL) ||\n\t    (reader->ctxt->node == reader->node) ||\n\t    (reader->ctxt->node == reader->node->parent)) &&\n\t   (reader->ctxt->instate != XML_PARSER_EOF)) {\n\tval = xmlTextReaderPushData(reader);\n\tif (val < 0){\n\t\treader->mode = XML_TEXTREADER_MODE_ERROR;\n\t\treader->state = XML_TEXTREADER_ERROR;\n\t    return(-1);\n\t}\n\tif (reader->node == NULL)\n\t    goto node_end;\n    }\n    if (oldstate != XML_TEXTREADER_BACKTRACK) {\n\tif ((reader->node->children != NULL) &&\n\t    (reader->node->type != XML_ENTITY_REF_NODE) &&\n\t    (reader->node->type != XML_XINCLUDE_START) &&\n\t    (reader->node->type != XML_DTD_NODE)) {\n\t    reader->node = reader->node->children;\n\t    reader->depth++;\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t    goto node_found;\n\t}\n    }\n    if (reader->node->next != NULL) {\n\tif ((oldstate == XML_TEXTREADER_ELEMENT) &&\n            (reader->node->type == XML_ELEMENT_NODE) &&\n\t    (reader->node->children == NULL) &&\n\t    ((reader->node->extra & NODE_IS_EMPTY) == 0)\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    && (reader->in_xinclude <= 0)\n#endif\n\t    ) {\n\t    reader->state = XML_TEXTREADER_END;\n\t    goto node_found;\n\t}\n#ifdef LIBXML_REGEXP_ENABLED\n\tif ((reader->validate) &&\n\t    (reader->node->type == XML_ELEMENT_NODE))\n\t    xmlTextReaderValidatePop(reader);\n#endif /* LIBXML_REGEXP_ENABLED */\n        if ((reader->preserves > 0) &&\n\t    (reader->node->extra & NODE_IS_SPRESERVED))\n\t    reader->preserves--;\n\treader->node = reader->node->next;\n\treader->state = XML_TEXTREADER_ELEMENT;\n\n\t/*\n\t * Cleanup of the old node\n\t */\n\tif ((reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    (reader->in_xinclude == 0) &&\n#endif\n\t    (reader->entNr == 0) &&\n\t    (reader->node->prev != NULL) &&\n            (reader->node->prev->type != XML_DTD_NODE)) {\n\t    xmlNodePtr tmp = reader->node->prev;\n\t    if ((tmp->extra & NODE_IS_PRESERVED) == 0) {\n                if (oldnode == tmp)\n                    oldnode = NULL;\n\t\txmlUnlinkNode(tmp);\n\t\txmlTextReaderFreeNode(reader, tmp);\n\t    }\n\t}\n\n\tgoto node_found;\n    }\n    if ((oldstate == XML_TEXTREADER_ELEMENT) &&\n\t(reader->node->type == XML_ELEMENT_NODE) &&\n\t(reader->node->children == NULL) &&\n\t((reader->node->extra & NODE_IS_EMPTY) == 0)) {;\n\treader->state = XML_TEXTREADER_END;\n\tgoto node_found;\n    }\n#ifdef LIBXML_REGEXP_ENABLED\n    if ((reader->validate != XML_TEXTREADER_NOT_VALIDATE) && (reader->node->type == XML_ELEMENT_NODE))\n\txmlTextReaderValidatePop(reader);\n#endif /* LIBXML_REGEXP_ENABLED */\n    if ((reader->preserves > 0) &&\n\t(reader->node->extra & NODE_IS_SPRESERVED))\n\treader->preserves--;\n    reader->node = reader->node->parent;\n    if ((reader->node == NULL) ||\n\t(reader->node->type == XML_DOCUMENT_NODE) ||\n\t(reader->node->type == XML_HTML_DOCUMENT_NODE)) {\n\tif (reader->mode != XML_TEXTREADER_MODE_EOF) {\n\t    val = xmlParseChunk(reader->ctxt, \"\", 0, 1);\n\t    reader->state = XML_TEXTREADER_DONE;\n\t    if (val != 0)\n\t        return(-1);\n\t}\n\treader->node = NULL;\n\treader->depth = -1;\n\n\t/*\n\t * Cleanup of the old node\n\t */\n\tif ((oldnode != NULL) && (reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    (reader->in_xinclude == 0) &&\n#endif\n\t    (reader->entNr == 0) &&\n\t    (oldnode->type != XML_DTD_NODE) &&\n\t    ((oldnode->extra & NODE_IS_PRESERVED) == 0)) {\n\t    xmlUnlinkNode(oldnode);\n\t    xmlTextReaderFreeNode(reader, oldnode);\n\t}\n\n\tgoto node_end;\n    }\n    if ((reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n        (reader->in_xinclude == 0) &&\n#endif\n\t(reader->entNr == 0) &&\n        (reader->node->last != NULL) &&\n        ((reader->node->last->extra & NODE_IS_PRESERVED) == 0)) {\n\txmlNodePtr tmp = reader->node->last;\n\txmlUnlinkNode(tmp);\n\txmlTextReaderFreeNode(reader, tmp);\n    }\n    reader->depth--;\n    reader->state = XML_TEXTREADER_BACKTRACK;\n\nnode_found:\n    DUMP_READER\n\n    /*\n     * If we are in the middle of a piece of CDATA make sure it's finished\n     */\n    if ((reader->node != NULL) &&\n        (reader->node->next == NULL) &&\n        ((reader->node->type == XML_TEXT_NODE) ||\n\t (reader->node->type == XML_CDATA_SECTION_NODE))) {\n            if (xmlTextReaderExpand(reader) == NULL)\n\t        return -1;\n    }\n\n#ifdef LIBXML_XINCLUDE_ENABLED\n    /*\n     * Handle XInclude if asked for\n     */\n    if ((reader->xinclude) && (reader->in_xinclude == 0) &&\n        (reader->node != NULL) &&\n\t(reader->node->type == XML_ELEMENT_NODE) &&\n\t(reader->node->ns != NULL) &&\n\t((xmlStrEqual(reader->node->ns->href, XINCLUDE_NS)) ||\n\t (xmlStrEqual(reader->node->ns->href, XINCLUDE_OLD_NS)))) {\n\tif (reader->xincctxt == NULL) {\n\t    reader->xincctxt = xmlXIncludeNewContext(reader->ctxt->myDoc);\n\t    xmlXIncludeSetFlags(reader->xincctxt,\n\t                        reader->parserFlags & (~XML_PARSE_NOXINCNODE));\n\t}\n\t/*\n\t * expand that node and process it\n\t */\n\tif (xmlTextReaderExpand(reader) == NULL)\n\t    return -1;\n\txmlXIncludeProcessNode(reader->xincctxt, reader->node);\n    }\n    if ((reader->node != NULL) && (reader->node->type == XML_XINCLUDE_START)) {\n        reader->in_xinclude++;\n\tgoto get_next_node;\n    }\n    if ((reader->node != NULL) && (reader->node->type == XML_XINCLUDE_END)) {\n        reader->in_xinclude--;\n\tgoto get_next_node;\n    }\n#endif\n    /*\n     * Handle entities enter and exit when in entity replacement mode\n     */\n    if ((reader->node != NULL) &&\n\t(reader->node->type == XML_ENTITY_REF_NODE) &&\n\t(reader->ctxt != NULL) && (reader->ctxt->replaceEntities == 1)) {\n\tif ((reader->node->children != NULL) &&\n\t    (reader->node->children->type == XML_ENTITY_DECL) &&\n\t    (reader->node->children->children != NULL)) {\n\t    xmlTextReaderEntPush(reader, reader->node);\n\t    reader->node = reader->node->children->children;\n\t}\n#ifdef LIBXML_REGEXP_ENABLED\n    } else if ((reader->node != NULL) &&\n\t       (reader->node->type == XML_ENTITY_REF_NODE) &&\n\t       (reader->ctxt != NULL) && (reader->validate)) {\n\txmlTextReaderValidateEntity(reader);\n#endif /* LIBXML_REGEXP_ENABLED */\n    }\n    if ((reader->node != NULL) &&\n\t(reader->node->type == XML_ENTITY_DECL) &&\n\t(reader->ent != NULL) && (reader->ent->children == reader->node)) {\n\treader->node = xmlTextReaderEntPop(reader);\n\treader->depth++;\n        goto get_next_node;\n    }\n#ifdef LIBXML_REGEXP_ENABLED\n    if ((reader->validate != XML_TEXTREADER_NOT_VALIDATE) && (reader->node != NULL)) {\n\txmlNodePtr node = reader->node;\n\n\tif ((node->type == XML_ELEMENT_NODE) &&\n            ((reader->state != XML_TEXTREADER_END) &&\n\t     (reader->state != XML_TEXTREADER_BACKTRACK))) {\n\t    xmlTextReaderValidatePush(reader);\n\t} else if ((node->type == XML_TEXT_NODE) ||\n\t\t   (node->type == XML_CDATA_SECTION_NODE)) {\n            xmlTextReaderValidateCData(reader, node->content,\n\t                               xmlStrlen(node->content));\n\t}\n    }\n#endif /* LIBXML_REGEXP_ENABLED */\n#ifdef LIBXML_PATTERN_ENABLED\n    if ((reader->patternNr > 0) && (reader->state != XML_TEXTREADER_END) &&\n        (reader->state != XML_TEXTREADER_BACKTRACK)) {\n        int i;\n\tfor (i = 0;i < reader->patternNr;i++) {\n\t     if (xmlPatternMatch(reader->patternTab[i], reader->node) == 1) {\n\t         xmlTextReaderPreserve(reader);\n\t\t break;\n             }\n\t}\n    }\n#endif /* LIBXML_PATTERN_ENABLED */\n#ifdef LIBXML_SCHEMAS_ENABLED\n    if ((reader->validate == XML_TEXTREADER_VALIDATE_XSD) &&\n        (reader->xsdValidErrors == 0) &&\n\t(reader->xsdValidCtxt != NULL)) {\n\treader->xsdValidErrors = !xmlSchemaIsValid(reader->xsdValidCtxt);\n    }\n#endif /* LIBXML_PATTERN_ENABLED */\n    return(1);\nnode_end:\n    reader->state = XML_TEXTREADER_DONE;\n    return(0);\n}\n\n\n// target function\nstatic int\nxmlXIncludeDoProcess(xmlXIncludeCtxtPtr ctxt, xmlNodePtr tree) {\n    xmlXIncludeRefPtr ref;\n    xmlNodePtr cur;\n    int ret = 0;\n    int i;\n\n    if ((tree == NULL) || (tree->type == XML_NAMESPACE_DECL))\n\treturn(-1);\n    if (ctxt == NULL)\n\treturn(-1);\n\n    /*\n     * First phase: lookup the elements in the document\n     */\n    cur = tree;\n    do {\n\t/* TODO: need to work on entities -> stack */\n        if (xmlXIncludeTestNode(ctxt, cur) == 1) {\n#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n            /*\n             * Avoid superlinear expansion by limiting the total number\n             * of replacements.\n             */\n            if (ctxt->incTotal >= 20)\n                return(-1);\n#endif\n            ctxt->incTotal++;\n            ref = xmlXIncludeExpandNode(ctxt, cur);\n            /*\n             * Mark direct includes.\n             */\n            if (ref != NULL)\n                ref->replace = 1;\n        } else if ((cur->children != NULL) &&\n                   ((cur->type == XML_DOCUMENT_NODE) ||\n                    (cur->type == XML_ELEMENT_NODE))) {\n            cur = cur->children;\n            continue;\n        }\n        do {\n            if (cur == tree)\n                break;\n            if (cur->next != NULL) {\n                cur = cur->next;\n                break;\n            }\n            cur = cur->parent;\n        } while (cur != NULL);\n    } while ((cur != NULL) && (cur != tree));\n\n    /*\n     * Second phase: extend the original document infoset.\n     */\n    for (i = 0; i < ctxt->incNr; i++) {\n\tif (ctxt->incTab[i]->replace != 0) {\n            if ((ctxt->incTab[i]->inc != NULL) ||\n                (ctxt->incTab[i]->emptyFb != 0)) {\t/* (empty fallback) */\n                xmlXIncludeIncludeNode(ctxt, ctxt->incTab[i]);\n                ctxt->incTab[i]->replace = 0;\n            }\n        } else {\n            /*\n             * Ignore includes which were added indirectly, for example\n             * inside xi:fallback elements.\n             */\n            if (ctxt->incTab[i]->inc != NULL) {\n                xmlFreeNodeList(ctxt->incTab[i]->inc);\n                ctxt->incTab[i]->inc = NULL;\n            }\n        }\n\tret++;\n    }\n\n    return(ret);\n}\n",
    "target": 1,
    "idx": 1052869,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\ngboolean\nvips_buf_vappendf( VipsBuf *buf, const char *fmt, va_list ap )\n{\n\tint avail;\n\tchar *p;\n\n\tif( buf->full )\n\t\treturn( FALSE );\n\n\tavail = buf->mx - buf->i - 4;\n\tp = buf->base + buf->i;\n\t(void) vips_vsnprintf( p, avail, fmt, ap ); \n\tbuf->i += strlen( p );\n\n\tif( buf->i >= buf->mx - 4 ) {\n\t\tbuf->full = TRUE;\n\t\tstrcpy( buf->base + buf->mx - 4, \"...\" );\n\t\tbuf->i = buf->mx - 1;\n\t\treturn( FALSE );\n\t}\n\n\treturn( TRUE );\n}\n\nvoid \nvips_verror( const char *domain, const char *fmt, va_list ap )\n{\n#ifdef VIPS_DEBUG\n{\n\tchar txt[256];\n\tVipsBuf buf = VIPS_BUF_STATIC( txt );\n\tva_list ap2;\n\n\tvips_buf_appendf( &buf, \"%s: \", domain );\n\tva_copy( ap2, ap );\n\tvips_buf_vappendf( &buf, fmt, ap2 );\n\tvips_buf_appends( &buf, \"\\n\" );\n\tVIPS_DEBUG_MSG( \"vips_verror: %s\", vips_buf_all( &buf ) );\n}\n#endif /*VIPS_DEBUG*/\n\n\tg_mutex_lock( vips__global_lock );\n\tg_assert( vips_error_freeze_count >= 0 );\n\tif( !vips_error_freeze_count ) {\n\t\tif( domain ) \n\t\t\tvips_buf_appendf( &vips_error_buf, \"%s: \", domain );\n\t\tvips_buf_vappendf( &vips_error_buf, fmt, ap );\n\t\tvips_buf_appends( &vips_error_buf, \"\\n\" );\n\t}\n\tg_mutex_unlock( vips__global_lock );\n\n\tif( vips__fatal )\n\t\tvips_error_exit( \"vips__fatal\" );\n}\n\nvoid \nvips_error( const char *domain, const char *fmt, ... )\n{\t\n\tva_list ap;\n\n\tva_start( ap, fmt );\n\tvips_verror( domain, fmt, ap );\n\tva_end( ap );\n}\n\nstatic int\nvips_foreign_load_matrix_load( VipsForeignLoad *load )\n{\n\tVipsForeignLoadMatrix *matrix = (VipsForeignLoadMatrix *) load;\n\tVipsObjectClass *class = VIPS_OBJECT_GET_CLASS( load );\n\n\tint x, y;\n\n\tvips_image_pipelinev( load->real, VIPS_DEMAND_STYLE_THINSTRIP, NULL );\n\tvips_image_init_fields( load->real,\n\t\tload->out->Xsize, load->out->Ysize, 1, \n\t\tVIPS_FORMAT_DOUBLE, \n\t\tVIPS_CODING_NONE, VIPS_INTERPRETATION_B_W, 1.0, 1.0 );\n\n\tfor( y = 0; y < load->real->Ysize; y++ ) {\n\t\tchar *line;\n\t\tchar *p, *q;\n\n\t\tline = vips_sbuf_get_line_copy( matrix->sbuf );\n\n\t\tfor( x = 0, p = line; \n\t\t\t(q = vips_break_token( p, \" \\t\" )) &&\n\t\t\t\tx < load->out->Xsize;\n\t\t\tx++, p = q )\n\t\t\tif( vips_strtod( p, &matrix->linebuf[x] ) ) {\n\t\t\t\tvips_error( class->nickname, \n\t\t\t\t\t_( \"bad number \\\"%s\\\"\" ), p );\n\t\t\t\tg_free( line );\n\t\t\t\treturn( -1 );\n\t\t\t}\n\n\t\tg_free( line );\n\n\t\tif( x != load->out->Xsize ) {\n\t\t\tvips_error( class->nickname, \n\t\t\t\t_( \"line %d too short\" ), y );\n\t\t\treturn( -1 );\n\t\t}\n\n\t\tif( vips_image_write_line( load->real, y, \n\t\t\t(VipsPel *) matrix->linebuf ) )\n\t\t\treturn( -1 );\n\t}\n\n\treturn( 0 );\n}\n\nint\nvips_foreign_load( const char *name, VipsImage **out, ... )\n{\n\tchar filename[VIPS_PATH_MAX];\n\tchar option_string[VIPS_PATH_MAX];\n\tconst char *operation_name;\n\tva_list ap;\n\tint result;\n\n\tvips__filename_split8( name, filename, option_string );\n\tif( !(operation_name = vips_foreign_find_load( filename )) )\n\t\treturn( -1 );\n\n\tva_start( ap, out );\n\tresult = vips_call_split_option_string( operation_name, option_string, \n\t\tap, filename, out );\n\tva_end( ap );\n\n\treturn( result );\n}\n\nint\nvips__region_start( VipsRegion *region )\n{\n\tVipsImage *image = region->im;\n\n        if( !region->seq && image->start_fn ) {\n\t\tVIPS_GATE_START( \"vips__region_start: wait\" );\n\n                g_mutex_lock( image->sslock );\n\n\t\tVIPS_GATE_STOP( \"vips__region_start: wait\" );\n\n                region->seq = image->start_fn( image, \n\t\t\timage->client1, image->client2 );\n\n                g_mutex_unlock( image->sslock );\n \n                if( !region->seq ) {\n#ifdef DEBUG\n                        printf( \"vips__region_start: \"\n\t\t\t\t\"start function failed for image %s\",\n                                image->filename );\n#endif /*DEBUG*/\n\n                        return( -1 );\n                }\n        }\n\n        return( 0 );\n}\n\nstatic int\nvips_region_generate( VipsRegion *reg )\n{\n\tVipsImage *im = reg->im;\n\n\tgboolean stop;\n\n        /* Start new sequence, if necessary.\n         */\n        if( vips__region_start( reg ) )\n\t\treturn( -1 );\n\n\t/* Ask for evaluation.\n\t */\n\tstop = FALSE;\n\tif( im->generate_fn( reg, reg->seq, im->client1, im->client2, &stop ) )\n\t\treturn( -1 );\n\tif( stop ) {\n\t\tvips_error( \"vips_region_generate\", \n\t\t\t\"%s\", _( \"stop requested\" ) );\n\t\treturn( -1 );\n\t}\n\n\treturn( 0 );\n}\n\nint\nvips_region_fill( VipsRegion *reg, \n\tconst VipsRect *r, VipsRegionFillFn fn, void *a )\n{\n\tg_assert( reg->im->dtype == VIPS_IMAGE_PARTIAL );\n\tg_assert( reg->im->generate_fn );\n\n\t/* You'd think we could check reg and see if it already has some of \n\t * the pixels we need. If it does, we could copy them and only\n\t * generate the new ones. \n\t *\n\t * However, we usually have neighbouring regions on different threads,\n\t * so from the point of view of this thread, we will get no overlaps\n\t * on successive prepare requests. \n\t */\n\n\t/* Should have local memory.\n\t */\n\tif( vips_region_buffer( reg, r ) )\n\t\treturn( -1 );\n\n\t/* Evaluate into or, if we've not got calculated pixels.\n\t */\n\tif( !reg->buffer->done ) {\n\t\tif( fn( reg, a ) )\n\t\t\treturn( -1 );\n\n\t\t/* Publish our results.\n\t\t */\n\t\tif( reg->buffer )\n\t\t\tvips_buffer_done( reg->buffer );\n\t}\n\n\treturn( 0 );\n}\n\nint\nvips_region_prepare_many( VipsRegion **reg, const VipsRect *r )\n{\n\tfor( ; *reg; ++reg )\n\t\tif( vips_region_prepare( *reg, r ) )\n\t\t\treturn( -1 );\n\n\treturn( 0 );\n}\n\nstatic int\nvips_copy_gen( VipsRegion *or, void *seq, void *a, void *b, gboolean *stop )\n{\n\tVipsRegion *ir = (VipsRegion *) seq;\n\tVipsRect *r = &or->valid;\n\n\tif( vips_region_prepare( ir, r ) ||\n\t\tvips_region_region( or, ir, r, r->left, r->top ) )\n\t\treturn( -1 );\n\n\treturn( 0 );\n}\n\nstatic int\nvips_region_generate( VipsRegion *reg )\n{\n\tVipsImage *im = reg->im;\n\n\tgboolean stop;\n\n        /* Start new sequence, if necessary.\n         */\n        if( vips__region_start( reg ) )\n\t\treturn( -1 );\n\n\t/* Ask for evaluation.\n\t */\n\tstop = FALSE;\n\tif( im->generate_fn( reg, reg->seq, im->client1, im->client2, &stop ) )\n\t\treturn( -1 );\n\tif( stop ) {\n\t\tvips_error( \"vips_region_generate\", \n\t\t\t\"%s\", _( \"stop requested\" ) );\n\t\treturn( -1 );\n\t}\n\n\treturn( 0 );\n}\n\nint\nvips_region_fill( VipsRegion *reg, \n\tconst VipsRect *r, VipsRegionFillFn fn, void *a )\n{\n\tg_assert( reg->im->dtype == VIPS_IMAGE_PARTIAL );\n\tg_assert( reg->im->generate_fn );\n\n\t/* You'd think we could check reg and see if it already has some of \n\t * the pixels we need. If it does, we could copy them and only\n\t * generate the new ones. \n\t *\n\t * However, we usually have neighbouring regions on different threads,\n\t * so from the point of view of this thread, we will get no overlaps\n\t * on successive prepare requests. \n\t */\n\n\t/* Should have local memory.\n\t */\n\tif( vips_region_buffer( reg, r ) )\n\t\treturn( -1 );\n\n\t/* Evaluate into or, if we've not got calculated pixels.\n\t */\n\tif( !reg->buffer->done ) {\n\t\tif( fn( reg, a ) )\n\t\t\treturn( -1 );\n\n\t\t/* Publish our results.\n\t\t */\n\t\tif( reg->buffer )\n\t\t\tvips_buffer_done( reg->buffer );\n\t}\n\n\treturn( 0 );\n}\n\nint\nvips_region_prepare_many( VipsRegion **reg, const VipsRect *r )\n{\n\tfor( ; *reg; ++reg )\n\t\tif( vips_region_prepare( *reg, r ) )\n\t\t\treturn( -1 );\n\n\treturn( 0 );\n}\n\nstatic int\nvips_cast_gen( VipsRegion *or, void *vseq, void *a, void *b, gboolean *stop )\n{\n\tVipsRegion *ir = (VipsRegion *) vseq;\n\tVipsCast *cast = (VipsCast *) b;\n\tVipsConversion *conversion = (VipsConversion *) b;\n\tVipsRect *r = &or->valid;\n\tint sz = VIPS_REGION_N_ELEMENTS( or );\n\n\tint x, y;\n\n\tif( vips_region_prepare( ir, r ) )\n\t\treturn( -1 );\n\n\tVIPS_GATE_START( \"vips_cast_gen: work\" );\n\n\tfor( y = 0; y < r->height; y++ ) {\n\t\tVipsPel *in = VIPS_REGION_ADDR( ir, r->left, r->top + y ); \n\t\tVipsPel *out = VIPS_REGION_ADDR( or, r->left, r->top + y ); \n\n\t\tswitch( ir->im->BandFmt ) { \n\t\tcase VIPS_FORMAT_UCHAR: \n\t\t\tBAND_SWITCH_INNER( unsigned char,\n\t\t\t\tINT_INT, \n\t\t\t\tCAST_REAL_FLOAT, \n\t\t\t\tCAST_REAL_COMPLEX );\n\t\t\tbreak; \n\n\t\tcase VIPS_FORMAT_CHAR: \n\t\t\tBAND_SWITCH_INNER( signed char,\n\t\t\t\tINT_INT_SIGNED, \n\t\t\t\tCAST_REAL_FLOAT, \n\t\t\t\tCAST_REAL_COMPLEX );\n\t\t\tbreak; \n\n\t\tcase VIPS_FORMAT_USHORT: \n\t\t\tBAND_SWITCH_INNER( unsigned short,\n\t\t\t\tINT_INT, \n\t\t\t\tCAST_REAL_FLOAT, \n\t\t\t\tCAST_REAL_COMPLEX );\n\t\t\tbreak; \n\n\t\tcase VIPS_FORMAT_SHORT: \n\t\t\tBAND_SWITCH_INNER( signed short,\n\t\t\t\tINT_INT_SIGNED, \n\t\t\t\tCAST_REAL_FLOAT, \n\t\t\t\tCAST_REAL_COMPLEX );\n\t\t\tbreak; \n\n\t\tcase VIPS_FORMAT_UINT: \n\t\t\tBAND_SWITCH_INNER( unsigned int,\n\t\t\t\tINT_INT, \n\t\t\t\tCAST_REAL_FLOAT, \n\t\t\t\tCAST_REAL_COMPLEX );\n\t\t\tbreak; \n\n\t\tcase VIPS_FORMAT_INT: \n\t\t\tBAND_SWITCH_INNER( signed int,\n\t\t\t\tINT_INT_SIGNED, \n\t\t\t\tCAST_REAL_FLOAT, \n\t\t\t\tCAST_REAL_COMPLEX );\n\t\t\tbreak; \n\n\t\tcase VIPS_FORMAT_FLOAT: \n\t\t\tBAND_SWITCH_INNER( float,\n\t\t\t\tCAST_FLOAT_INT, \n\t\t\t\tCAST_REAL_FLOAT, \n\t\t\t\tCAST_REAL_COMPLEX );\n\t\t\tbreak; \n\n\t\tcase VIPS_FORMAT_DOUBLE: \n\t\t\tBAND_SWITCH_INNER( double,\n\t\t\t\tCAST_FLOAT_INT, \n\t\t\t\tCAST_REAL_FLOAT, \n\t\t\t\tCAST_REAL_COMPLEX );\n\t\t\tbreak; \n\n\t\tcase VIPS_FORMAT_COMPLEX: \n\t\t\tBAND_SWITCH_INNER( float,\n\t\t\t\tCAST_COMPLEX_INT, \n\t\t\t\tCAST_COMPLEX_FLOAT, \n\t\t\t\tCAST_COMPLEX_COMPLEX );\n\t\t\tbreak; \n\n\t\tcase VIPS_FORMAT_DPCOMPLEX: \n\t\t\tBAND_SWITCH_INNER( double,\n\t\t\t\tCAST_COMPLEX_INT, \n\t\t\t\tCAST_COMPLEX_FLOAT, \n\t\t\t\tCAST_COMPLEX_COMPLEX );\n\t\t\tbreak; \n\n\t\tdefault: \n\t\t\tg_assert_not_reached(); \n\t\t} \n\t}\n\n\tVIPS_GATE_STOP( \"vips_cast_gen: work\" );\n\n\treturn( 0 );\n}\n\nstatic int\nvips_region_generate( VipsRegion *reg )\n{\n\tVipsImage *im = reg->im;\n\n\tgboolean stop;\n\n        /* Start new sequence, if necessary.\n         */\n        if( vips__region_start( reg ) )\n\t\treturn( -1 );\n\n\t/* Ask for evaluation.\n\t */\n\tstop = FALSE;\n\tif( im->generate_fn( reg, reg->seq, im->client1, im->client2, &stop ) )\n\t\treturn( -1 );\n\tif( stop ) {\n\t\tvips_error( \"vips_region_generate\", \n\t\t\t\"%s\", _( \"stop requested\" ) );\n\t\treturn( -1 );\n\t}\n\n\treturn( 0 );\n}\n\nint\nvips_region_fill( VipsRegion *reg, \n\tconst VipsRect *r, VipsRegionFillFn fn, void *a )\n{\n\tg_assert( reg->im->dtype == VIPS_IMAGE_PARTIAL );\n\tg_assert( reg->im->generate_fn );\n\n\t/* You'd think we could check reg and see if it already has some of \n\t * the pixels we need. If it does, we could copy them and only\n\t * generate the new ones. \n\t *\n\t * However, we usually have neighbouring regions on different threads,\n\t * so from the point of view of this thread, we will get no overlaps\n\t * on successive prepare requests. \n\t */\n\n\t/* Should have local memory.\n\t */\n\tif( vips_region_buffer( reg, r ) )\n\t\treturn( -1 );\n\n\t/* Evaluate into or, if we've not got calculated pixels.\n\t */\n\tif( !reg->buffer->done ) {\n\t\tif( fn( reg, a ) )\n\t\t\treturn( -1 );\n\n\t\t/* Publish our results.\n\t\t */\n\t\tif( reg->buffer )\n\t\t\tvips_buffer_done( reg->buffer );\n\t}\n\n\treturn( 0 );\n}\n\nint\nvips_region_prepare_many( VipsRegion **reg, const VipsRect *r )\n{\n\tfor( ; *reg; ++reg )\n\t\tif( vips_region_prepare( *reg, r ) )\n\t\t\treturn( -1 );\n\n\treturn( 0 );\n}\n\nstatic int\nvips_copy_gen( VipsRegion *or, void *seq, void *a, void *b, gboolean *stop )\n{\n\tVipsRegion *ir = (VipsRegion *) seq;\n\tVipsRect *r = &or->valid;\n\n\tif( vips_region_prepare( ir, r ) ||\n\t\tvips_region_region( or, ir, r, r->left, r->top ) )\n\t\treturn( -1 );\n\n\treturn( 0 );\n}\n\nstatic int\nvips_region_generate( VipsRegion *reg )\n{\n\tVipsImage *im = reg->im;\n\n\tgboolean stop;\n\n        /* Start new sequence, if necessary.\n         */\n        if( vips__region_start( reg ) )\n\t\treturn( -1 );\n\n\t/* Ask for evaluation.\n\t */\n\tstop = FALSE;\n\tif( im->generate_fn( reg, reg->seq, im->client1, im->client2, &stop ) )\n\t\treturn( -1 );\n\tif( stop ) {\n\t\tvips_error( \"vips_region_generate\", \n\t\t\t\"%s\", _( \"stop requested\" ) );\n\t\treturn( -1 );\n\t}\n\n\treturn( 0 );\n}\n\nstatic int\nvips_region_prepare_to_generate( VipsRegion *reg, \n\tVipsRegion *dest, const VipsRect *r, int x, int y )\n{\n\tVipsImage *im = reg->im;\n\tVipsPel *p;\n\n\tif( !im->generate_fn ) {\n\t\tvips_error( \"vips_region_prepare_to\",\n\t\t\t\"%s\", _( \"incomplete header\" ) );\n\t\treturn( -1 );\n\t}\n\n\tif( vips_region_region( reg, dest, r, x, y ) )\n\t\treturn( -1 );\n\n\t/* Remember where reg is pointing now.\n\t */\n\tp = VIPS_REGION_ADDR( reg, reg->valid.left, reg->valid.top );\n\n\t/* Run sequence into reg.\n\t */\n\tif( vips_region_generate( reg ) )\n\t\treturn( -1 );\n\n\t/* The generate function may not have actually made any pixels ... it\n\t * might just have redirected reg to point somewhere else. If it has,\n\t * we need an extra copy operation.\n\t */\n\tif( VIPS_REGION_ADDR( reg, reg->valid.left, reg->valid.top ) != p )\n\t\tvips_region_copy( reg, dest, r, x, y );\n\n\treturn( 0 );\n}\n\nstatic int\nvips_region_prepare_to_generate( VipsRegion *reg, \n\tVipsRegion *dest, const VipsRect *r, int x, int y )\n{\n\tVipsImage *im = reg->im;\n\tVipsPel *p;\n\n\tif( !im->generate_fn ) {\n\t\tvips_error( \"vips_region_prepare_to\",\n\t\t\t\"%s\", _( \"incomplete header\" ) );\n\t\treturn( -1 );\n\t}\n\n\tif( vips_region_region( reg, dest, r, x, y ) )\n\t\treturn( -1 );\n\n\t/* Remember where reg is pointing now.\n\t */\n\tp = VIPS_REGION_ADDR( reg, reg->valid.left, reg->valid.top );\n\n\t/* Run sequence into reg.\n\t */\n\tif( vips_region_generate( reg ) )\n\t\treturn( -1 );\n\n\t/* The generate function may not have actually made any pixels ... it\n\t * might just have redirected reg to point somewhere else. If it has,\n\t * we need an extra copy operation.\n\t */\n\tif( VIPS_REGION_ADDR( reg, reg->valid.left, reg->valid.top ) != p )\n\t\tvips_region_copy( reg, dest, r, x, y );\n\n\treturn( 0 );\n}\n\nstatic int\nwbuffer_work_fn( VipsThreadState *state, void *a )\n{\n\tWriteThreadState *wstate = (WriteThreadState *) state;\n\n\tint result;\n\n\tVIPS_DEBUG_MSG( \"wbuffer_work_fn: thread %p, %d x %d\\n\", \n\t\tg_thread_self(), \n\t\tstate->pos.left, state->pos.top );\n\n\tresult = vips_region_prepare_to( state->reg, wstate->buf->region, \n\t\t&state->pos, state->pos.left, state->pos.top );\n\n\tVIPS_DEBUG_MSG( \"wbuffer_work_fn: thread %p result = %d\\n\", \n\t\tg_thread_self(), result );\n\n\t/* Tell the bg write thread we've left.\n\t */\n\tvips_semaphore_upn( &wstate->buf->nwrite, 1 );\n\n\treturn( result );\n}\n\nstatic void\nvips_thread_work_unit( VipsThread *thr )\n{\n\tVipsThreadpool *pool = thr->pool;\n\n\tif( thr->error )\n\t\treturn;\n\n\tVIPS_GATE_START( \"vips_thread_work_unit: wait\" ); \n\n\tg_mutex_lock( pool->allocate_lock );\n\n\tVIPS_GATE_STOP( \"vips_thread_work_unit: wait\" ); \n\n\t/* Has another worker signaled stop while we've been working?\n\t */\n\tif( pool->stop ) {\n\t\tg_mutex_unlock( pool->allocate_lock );\n\t\treturn;\n\t}\n\n\tif( vips_thread_allocate( thr ) ) {\n\t\tthr->error = TRUE;\n\t\tpool->error = TRUE;\n\t\tg_mutex_unlock( pool->allocate_lock );\n\t\treturn;\n\t}\n\n\t/* Have we just signalled stop?\n\t */\n\tif( pool->stop ) {\n\t\tg_mutex_unlock( pool->allocate_lock );\n\t\treturn;\n\t}\n\n\tg_mutex_unlock( pool->allocate_lock );\n\n\tif( thr->state->stall &&\n\t\tvips__stall ) { \n\t\t/* Sleep for 0.5s. Handy for stressing the seq system. Stall\n\t\t * is set by allocate funcs in various places. \n\t\t */\n\t\tg_usleep( 500000 ); \n\t\tthr->state->stall = FALSE;\n\t\tprintf( \"vips_thread_work_unit: \"\n\t\t\t\"stall done, releasing y = %d ...\\n\", thr->state->y ); \n\t}\n\n\t/* Process a work unit.\n\t */\n\tif( pool->work( thr->state, pool->a ) ) { \n\t\tthr->error = TRUE;\n\t\tpool->error = TRUE;\n\t}\n}\n\n\n\n\n\n\n// target function\nstatic int\nvips_foreign_load_matrix_load( VipsForeignLoad *load )\n{\n\tVipsForeignLoadMatrix *matrix = (VipsForeignLoadMatrix *) load;\n\tVipsObjectClass *class = VIPS_OBJECT_GET_CLASS( load );\n\n\tint x, y;\n\n\tvips_image_pipelinev( load->real, VIPS_DEMAND_STYLE_THINSTRIP, NULL );\n\tvips_image_init_fields( load->real,\n\t\tload->out->Xsize, load->out->Ysize, 1, \n\t\tVIPS_FORMAT_DOUBLE, \n\t\tVIPS_CODING_NONE, VIPS_INTERPRETATION_B_W, 1.0, 1.0 );\n\n\tfor( y = 0; y < load->real->Ysize; y++ ) {\n\t\tchar *line;\n\t\tchar *p, *q;\n\n\t\tline = vips_sbuf_get_line_copy( matrix->sbuf );\n\n\t\tfor( x = 0, p = line; \n\t\t\t(q = vips_break_token( p, \" \\t\" )) &&\n\t\t\t\tx < load->out->Xsize;\n\t\t\tx++, p = q )\n\t\t\tif( vips_strtod( p, &matrix->linebuf[x] ) ) {\n\t\t\t\tg_free( line );\n\t\t\t\tvips_error( class->nickname, \n\t\t\t\t\t_( \"bad number \\\"%s\\\"\" ), p );\n\t\t\t\treturn( -1 );\n\t\t\t}\n\n\t\tg_free( line );\n\n\t\tif( x != load->out->Xsize ) {\n\t\t\tvips_error( class->nickname, \n\t\t\t\t_( \"line %d too short\" ), y );\n\t\t\treturn( -1 );\n\t\t}\n\n\t\tif( vips_image_write_line( load->real, y, \n\t\t\t(VipsPel *) matrix->linebuf ) )\n\t\t\treturn( -1 );\n\t}\n\n\treturn( 0 );\n}\n",
    "target": 1,
    "idx": 1020843,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic zend_always_inline uint32_t zend_gc_delref(zend_refcounted_h *p) {\n\tZEND_ASSERT(p->refcount > 0);\n\tZEND_RC_MOD_CHECK(p);\n\treturn --(p->refcount);\n}\n\nstatic zend_always_inline uint32_t zval_delref_p(zval* pz) {\n\tZEND_ASSERT(Z_REFCOUNTED_P(pz));\n\treturn GC_DELREF(Z_COUNTED_P(pz));\n}\n\nstatic zend_always_inline void zval_ptr_dtor_nogc(zval *zval_ptr)\n{\n\tif (Z_REFCOUNTED_P(zval_ptr) && !Z_DELREF_P(zval_ptr)) {\n\t\trc_dtor_func(Z_COUNTED_P(zval_ptr));\n\t}\n}\n\nZEND_API void destroy_op_array(zend_op_array *op_array)\n{\n\tuint32_t i;\n\n\tif (op_array->static_variables) {\n\t\tHashTable *ht = ZEND_MAP_PTR_GET(op_array->static_variables_ptr);\n\t\tif (ht && !(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE)) {\n\t\t\tif (GC_DELREF(ht) == 0) {\n\t\t\t\tzend_array_destroy(ht);\n\t\t\t}\n\t\t}\n\t}\n\n\tif ((op_array->fn_flags & ZEND_ACC_HEAP_RT_CACHE)\n\t && ZEND_MAP_PTR(op_array->run_time_cache)) {\n\t\tefree(ZEND_MAP_PTR(op_array->run_time_cache));\n\t}\n\n\tif (op_array->function_name) {\n\t\tzend_string_release_ex(op_array->function_name, 0);\n\t}\n\n\tif (!op_array->refcount || --(*op_array->refcount) > 0) {\n\t\treturn;\n\t}\n\n\tefree_size(op_array->refcount, sizeof(*(op_array->refcount)));\n\n\tif (op_array->vars) {\n\t\ti = op_array->last_var;\n\t\twhile (i > 0) {\n\t\t\ti--;\n\t\t\tzend_string_release_ex(op_array->vars[i], 0);\n\t\t}\n\t\tefree(op_array->vars);\n\t}\n\n\tif (op_array->literals) {\n\t\tzval *literal = op_array->literals;\n\t\tzval *end = literal + op_array->last_literal;\n\t \twhile (literal < end) {\n\t\t\tzval_ptr_dtor_nogc(literal);\n\t\t\tliteral++;\n\t\t}\n\t\tif (ZEND_USE_ABS_CONST_ADDR\n\t\t || !(op_array->fn_flags & ZEND_ACC_DONE_PASS_TWO)) {\n\t\t\tefree(op_array->literals);\n\t\t}\n\t}\n\tefree(op_array->opcodes);\n\n\tif (op_array->doc_comment) {\n\t\tzend_string_release_ex(op_array->doc_comment, 0);\n\t}\n\tif (op_array->attributes) {\n\t\tzend_hash_release(op_array->attributes);\n\t}\n\tif (op_array->live_range) {\n\t\tefree(op_array->live_range);\n\t}\n\tif (op_array->try_catch_array) {\n\t\tefree(op_array->try_catch_array);\n\t}\n\tif (zend_extension_flags & ZEND_EXTENSIONS_HAVE_OP_ARRAY_DTOR) {\n\t\tif (op_array->fn_flags & ZEND_ACC_DONE_PASS_TWO) {\n\t\t\tzend_llist_apply_with_argument(&zend_extensions, (llist_apply_with_arg_func_t) zend_extension_op_array_dtor_handler, op_array);\n\t\t}\n\t}\n\tif (op_array->arg_info) {\n\t\tuint32_t num_args = op_array->num_args;\n\t\tzend_arg_info *arg_info = op_array->arg_info;\n\n\t\tif (op_array->fn_flags & ZEND_ACC_HAS_RETURN_TYPE) {\n\t\t\targ_info--;\n\t\t\tnum_args++;\n\t\t}\n\t\tif (op_array->fn_flags & ZEND_ACC_VARIADIC) {\n\t\t\tnum_args++;\n\t\t}\n\t\tfor (i = 0 ; i < num_args; i++) {\n\t\t\tif (arg_info[i].name) {\n\t\t\t\tzend_string_release_ex(arg_info[i].name, 0);\n\t\t\t}\n\t\t\tzend_type_release(arg_info[i].type, /* persistent */ 0);\n\t\t}\n\t\tefree(arg_info);\n\t}\n}\n\nint fuzzer_do_request(zend_file_handle *file_handle, char *filename)\n{\n\tint retval = FAILURE; /* failure by default */\n\n\tSG(options) |= SAPI_OPTION_NO_CHDIR;\n\tSG(request_info).argc=0;\n\tSG(request_info).argv=NULL;\n\n\tif (fuzzer_request_startup() == FAILURE) {\n\t\treturn FAILURE;\n\t}\n\n\tSG(headers_sent) = 1;\n\tSG(request_info).no_headers = 1;\n\tphp_register_variable(\"PHP_SELF\", filename, NULL);\n\n\tzend_first_try {\n\t\tzend_op_array *op_array = zend_compile_file(file_handle, ZEND_REQUIRE);\n\t\tif (op_array) {\n\t\t\tdestroy_op_array(op_array);\n\t\t\tefree(op_array);\n\t\t}\n\t\tif (EG(exception)) {\n\t\t\tzend_object_release(EG(exception));\n\t\t\tEG(exception) = NULL;\n\t\t}\n\t\t/*retval = php_execute_script(file_handle);*/\n\t} zend_end_try();\n\nint fuzzer_do_request_from_buffer(char *filename, char *data, size_t data_len)\n{\n\tzend_file_handle file_handle;\n\tfile_handle.filename = filename;\n\tfile_handle.free_filename = 0;\n\tfile_handle.opened_path = NULL;\n\tfile_handle.handle.stream.handle = NULL;\n\tfile_handle.handle.stream.reader = (zend_stream_reader_t)_php_stream_read;\n\tfile_handle.handle.stream.fsizer = NULL;\n\tfile_handle.handle.stream.isatty = 0;\n\tfile_handle.handle.stream.closer   = NULL;\n\tfile_handle.buf = data;\n\tfile_handle.len = data_len;\n\tfile_handle.type = ZEND_HANDLE_STREAM;\n\n\treturn fuzzer_do_request(&file_handle, filename);\n}\n\n\n// target function\nstatic void zend_emit_jmp_null(znode *obj_node)\n{\n\tuint32_t jmp_null_opnum = get_next_op_number();\n\tzend_emit_op(NULL, ZEND_JMP_NULL, obj_node, NULL);\n\tzend_stack_push(&CG(short_circuiting_opnums), &jmp_null_opnum);\n}\n",
    "target": 1,
    "idx": 1024567,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic OnigLen\nnode_min_byte_len(Node* node, ScanEnv* env)\n{\n  OnigLen len;\n  OnigLen tmin;\n\n  len = 0;\n  switch (NODE_TYPE(node)) {\n  case NODE_BACKREF:\n    if (! NODE_IS_CHECKER(node)) {\n      int i;\n      int* backs;\n      MemEnv* mem_env = SCANENV_MEMENV(env);\n      BackRefNode* br = BACKREF_(node);\n      if (NODE_IS_RECURSION(node)) break;\n\n      backs = BACKREFS_P(br);\n      len = node_min_byte_len(mem_env[backs[0]].mem_node, env);\n      for (i = 1; i < br->back_num; i++) {\n        tmin = node_min_byte_len(mem_env[backs[i]].mem_node, env);\n        if (len > tmin) len = tmin;\n      }\n    }\n    break;\n\n#ifdef USE_CALL\n  case NODE_CALL:\n    {\n      Node* t = NODE_BODY(node);\n      if (NODE_IS_RECURSION(node)) {\n        if (NODE_IS_FIXED_MIN(t))\n          len = BAG_(t)->min_len;\n      }\n      else\n        len = node_min_byte_len(t, env);\n    }\n    break;\n#endif\n\n  case NODE_LIST:\n    do {\n      tmin = node_min_byte_len(NODE_CAR(node), env);\n      len = distance_add(len, tmin);\n    } while (IS_NOT_NULL(node = NODE_CDR(node)));\n    break;\n\n  case NODE_ALT:\n    {\n      Node *x, *y;\n      y = node;\n      do {\n        x = NODE_CAR(y);\n        tmin = node_min_byte_len(x, env);\n        if (y == node) len = tmin;\n        else if (len > tmin) len = tmin;\n      } while (IS_NOT_NULL(y = NODE_CDR(y)));\n    }\n    break;\n\n  case NODE_STRING:\n    {\n      StrNode* sn = STR_(node);\n      len = (int )(sn->end - sn->s);\n    }\n    break;\n\n  case NODE_CTYPE:\n  case NODE_CCLASS:\n    len = ONIGENC_MBC_MINLEN(env->enc);\n    break;\n\n  case NODE_QUANT:\n    {\n      QuantNode* qn = QUANT_(node);\n\n      if (qn->lower > 0) {\n        len = node_min_byte_len(NODE_BODY(node), env);\n        len = distance_multiply(len, qn->lower);\n      }\n    }\n    break;\n\n  case NODE_BAG:\n    {\n      BagNode* en = BAG_(node);\n      switch (en->type) {\n      case BAG_MEMORY:\n        if (NODE_IS_FIXED_MIN(node))\n          len = en->min_len;\n        else {\n          if (NODE_IS_MARK1(node))\n            len = 0;  /* recursive */\n          else {\n            NODE_STATUS_ADD(node, MARK1);\n            len = node_min_byte_len(NODE_BODY(node), env);\n            NODE_STATUS_REMOVE(node, MARK1);\n\n            en->min_len = len;\n            NODE_STATUS_ADD(node, FIXED_MIN);\n          }\n        }\n        break;\n\n      case BAG_OPTION:\n      case BAG_STOP_BACKTRACK:\n        len = node_min_byte_len(NODE_BODY(node), env);\n        break;\n      case BAG_IF_ELSE:\n        {\n          OnigLen elen;\n\n          len = node_min_byte_len(NODE_BODY(node), env);\n          if (IS_NOT_NULL(en->te.Then))\n            len += node_min_byte_len(en->te.Then, env);\n          if (IS_NOT_NULL(en->te.Else))\n            elen = node_min_byte_len(en->te.Else, env);\n          else elen = 0;\n\n          if (elen < len) len = elen;\n        }\n        break;\n      }\n    }\n    break;\n\n  case NODE_GIMMICK:\n    {\n      GimmickNode* g = GIMMICK_(node);\n      if (g->type == GIMMICK_FAIL) {\n        len = INFINITE_LEN;\n        break;\n      }\n    }\n    /* fall */\n  case NODE_ANCHOR:\n  default:\n    break;\n  }\n\n  return len;\n}\n\n__inline\n#endif\nstatic int\ntune_quant(Node* node, regex_t* reg, int state, ScanEnv* env)\n{\n  int r;\n  QuantNode* qn = QUANT_(node);\n  Node* body = NODE_BODY(node);\n\n  if ((state & IN_REAL_REPEAT) != 0) {\n    NODE_STATUS_ADD(node, IN_REAL_REPEAT);\n  }\n  if ((state & IN_MULTI_ENTRY) != 0) {\n    NODE_STATUS_ADD(node, IN_MULTI_ENTRY);\n  }\n\n  if (IS_INFINITE_REPEAT(qn->upper) || qn->upper >= 1) {\n    OnigLen d = node_min_byte_len(body, env);\n    if (d == 0) {\n#ifdef USE_STUBBORN_CHECK_CAPTURES_IN_EMPTY_REPEAT\n      qn->emptiness = quantifiers_memory_node_info(body);\n#else\n      qn->emptiness = BODY_MAY_BE_EMPTY;\n#endif\n    }\n  }\n\n  if (IS_INFINITE_REPEAT(qn->upper) || qn->upper >= 2)\n    state |= IN_REAL_REPEAT;\n  if (qn->lower != qn->upper)\n    state |= IN_VAR_REPEAT;\n\n  r = tune_tree(body, reg, state, env);\n  if (r != 0) return r;\n\n  /* expand string */\n#define EXPAND_STRING_MAX_LENGTH  100\n  if (NODE_TYPE(body) == NODE_STRING) {\n    if (!IS_INFINITE_REPEAT(qn->lower) && qn->lower == qn->upper &&\n        qn->lower > 1 && qn->lower <= EXPAND_STRING_MAX_LENGTH) {\n      int len = NODE_STRING_LEN(body);\n\n      if (len * qn->lower <= EXPAND_STRING_MAX_LENGTH) {\n        int i, n = qn->lower;\n        node_conv_to_str_node(node, body);\n        for (i = 0; i < n; i++) {\n          r = node_str_node_cat(node, body);\n          if (r != 0) return r;\n        }\n        onig_node_free(body);\n        return r;\n      }\n    }\n  }\n\n  if (qn->greedy && (qn->emptiness == BODY_IS_NOT_EMPTY)) {\n    if (NODE_TYPE(body) == NODE_QUANT) {\n      QuantNode* tqn = QUANT_(body);\n      if (IS_NOT_NULL(tqn->head_exact)) {\n        qn->head_exact  = tqn->head_exact;\n        tqn->head_exact = NULL;\n      }\n    }\n    else {\n      qn->head_exact = get_tree_head_literal(NODE_BODY(node), 1, reg);\n    }\n  }\n\n  return r;\n}\n\nstatic int\ntune_tree(Node* node, regex_t* reg, int state, ScanEnv* env)\n{\n  int r = 0;\n\n  switch (NODE_TYPE(node)) {\n  case NODE_LIST:\n    {\n      Node* prev = NULL_NODE;\n      do {\n        r = tune_tree(NODE_CAR(node), reg, state, env);\n        if (IS_NOT_NULL(prev) && r == 0) {\n          r = tune_next(prev, NODE_CAR(node), reg);\n        }\n        prev = NODE_CAR(node);\n      } while (r == 0 && IS_NOT_NULL(node = NODE_CDR(node)));\n    }\n    break;\n\n  case NODE_ALT:\n    do {\n      r = tune_tree(NODE_CAR(node), reg, (state | IN_ALT), env);\n    } while (r == 0 && IS_NOT_NULL(node = NODE_CDR(node)));\n    break;\n\n  case NODE_STRING:\n    if (NODE_IS_IGNORECASE(node) && ! NODE_STRING_IS_CRUDE(node)) {\n      r = unravel_case_fold_string(node, reg, state);\n    }\n    break;\n\n  case NODE_BACKREF:\n    {\n      int i;\n      int* p;\n      BackRefNode* br = BACKREF_(node);\n      p = BACKREFS_P(br);\n      for (i = 0; i < br->back_num; i++) {\n        if (p[i] > env->num_mem)  return ONIGERR_INVALID_BACKREF;\n        MEM_STATUS_ON(env->backrefed_mem, p[i]);\n#if 0\n#ifdef USE_BACKREF_WITH_LEVEL\n        if (NODE_IS_NEST_LEVEL(node)) {\n          MEM_STATUS_ON(env->backtrack_mem, p[i]);\n        }\n#endif\n#else\n        /* More precisely, it should be checked whether alt/repeat exists before\n           the subject capture node, and then this backreference position\n           exists before (or in) the capture node. */\n        MEM_STATUS_ON(env->backtrack_mem, p[i]);\n#endif\n      }\n    }\n    break;\n\n  case NODE_BAG:\n    {\n      BagNode* en = BAG_(node);\n\n      switch (en->type) {\n      case BAG_OPTION:\n        {\n          OnigOptionType options = reg->options;\n          reg->options = BAG_(node)->o.options;\n          r = tune_tree(NODE_BODY(node), reg, state, env);\n          reg->options = options;\n        }\n        break;\n\n      case BAG_MEMORY:\n#ifdef USE_CALL\n        state |= en->m.called_state;\n#endif\n\n        if ((state & (IN_ALT | IN_NOT | IN_VAR_REPEAT | IN_MULTI_ENTRY)) != 0\n            || NODE_IS_RECURSION(node)) {\n          MEM_STATUS_ON(env->backtrack_mem, en->m.regnum);\n        }\n        r = tune_tree(NODE_BODY(node), reg, state, env);\n        break;\n\n      case BAG_STOP_BACKTRACK:\n        {\n          Node* target = NODE_BODY(node);\n          r = tune_tree(target, reg, state, env);\n          if (NODE_TYPE(target) == NODE_QUANT) {\n            QuantNode* tqn = QUANT_(target);\n            if (IS_INFINITE_REPEAT(tqn->upper) && tqn->lower <= 1 &&\n                tqn->greedy != 0) {  /* (?>a*), a*+ etc... */\n              if (is_strict_real_node(NODE_BODY(target)))\n                NODE_STATUS_ADD(node, STRICT_REAL_REPEAT);\n            }\n          }\n        }\n        break;\n\n      case BAG_IF_ELSE:\n        r = tune_tree(NODE_BODY(node), reg, (state | IN_ALT), env);\n        if (r != 0) return r;\n        if (IS_NOT_NULL(en->te.Then)) {\n          r = tune_tree(en->te.Then, reg, (state | IN_ALT), env);\n          if (r != 0) return r;\n        }\n        if (IS_NOT_NULL(en->te.Else))\n          r = tune_tree(en->te.Else, reg, (state | IN_ALT), env);\n        break;\n      }\n    }\n    break;\n\n  case NODE_QUANT:\n    r = tune_quant(node, reg, state, env);\n    break;\n\n  case NODE_ANCHOR:\n    r = tune_anchor(node, reg, state, env);\n    break;\n\n#ifdef USE_CALL\n  case NODE_CALL:\n#endif\n  case NODE_CTYPE:\n  case NODE_CCLASS:\n  case NODE_GIMMICK:\n  default:\n    break;\n  }\n\n  return r;\n}\n\n__inline\n#endif\nstatic int\ntune_quant(Node* node, regex_t* reg, int state, ScanEnv* env)\n{\n  int r;\n  QuantNode* qn = QUANT_(node);\n  Node* body = NODE_BODY(node);\n\n  if ((state & IN_REAL_REPEAT) != 0) {\n    NODE_STATUS_ADD(node, IN_REAL_REPEAT);\n  }\n  if ((state & IN_MULTI_ENTRY) != 0) {\n    NODE_STATUS_ADD(node, IN_MULTI_ENTRY);\n  }\n\n  if (IS_INFINITE_REPEAT(qn->upper) || qn->upper >= 1) {\n    OnigLen d = node_min_byte_len(body, env);\n    if (d == 0) {\n#ifdef USE_STUBBORN_CHECK_CAPTURES_IN_EMPTY_REPEAT\n      qn->emptiness = quantifiers_memory_node_info(body);\n#else\n      qn->emptiness = BODY_MAY_BE_EMPTY;\n#endif\n    }\n  }\n\n  if (IS_INFINITE_REPEAT(qn->upper) || qn->upper >= 2)\n    state |= IN_REAL_REPEAT;\n  if (qn->lower != qn->upper)\n    state |= IN_VAR_REPEAT;\n\n  r = tune_tree(body, reg, state, env);\n  if (r != 0) return r;\n\n  /* expand string */\n#define EXPAND_STRING_MAX_LENGTH  100\n  if (NODE_TYPE(body) == NODE_STRING) {\n    if (!IS_INFINITE_REPEAT(qn->lower) && qn->lower == qn->upper &&\n        qn->lower > 1 && qn->lower <= EXPAND_STRING_MAX_LENGTH) {\n      int len = NODE_STRING_LEN(body);\n\n      if (len * qn->lower <= EXPAND_STRING_MAX_LENGTH) {\n        int i, n = qn->lower;\n        node_conv_to_str_node(node, body);\n        for (i = 0; i < n; i++) {\n          r = node_str_node_cat(node, body);\n          if (r != 0) return r;\n        }\n        onig_node_free(body);\n        return r;\n      }\n    }\n  }\n\n  if (qn->greedy && (qn->emptiness == BODY_IS_NOT_EMPTY)) {\n    if (NODE_TYPE(body) == NODE_QUANT) {\n      QuantNode* tqn = QUANT_(body);\n      if (IS_NOT_NULL(tqn->head_exact)) {\n        qn->head_exact  = tqn->head_exact;\n        tqn->head_exact = NULL;\n      }\n    }\n    else {\n      qn->head_exact = get_tree_head_literal(NODE_BODY(node), 1, reg);\n    }\n  }\n\n  return r;\n}\n\n__inline\n#endif\nstatic int\ntune_quant(Node* node, regex_t* reg, int state, ScanEnv* env)\n{\n  int r;\n  QuantNode* qn = QUANT_(node);\n  Node* body = NODE_BODY(node);\n\n  if ((state & IN_REAL_REPEAT) != 0) {\n    NODE_STATUS_ADD(node, IN_REAL_REPEAT);\n  }\n  if ((state & IN_MULTI_ENTRY) != 0) {\n    NODE_STATUS_ADD(node, IN_MULTI_ENTRY);\n  }\n\n  if (IS_INFINITE_REPEAT(qn->upper) || qn->upper >= 1) {\n    OnigLen d = node_min_byte_len(body, env);\n    if (d == 0) {\n#ifdef USE_STUBBORN_CHECK_CAPTURES_IN_EMPTY_REPEAT\n      qn->emptiness = quantifiers_memory_node_info(body);\n#else\n      qn->emptiness = BODY_MAY_BE_EMPTY;\n#endif\n    }\n  }\n\n  if (IS_INFINITE_REPEAT(qn->upper) || qn->upper >= 2)\n    state |= IN_REAL_REPEAT;\n  if (qn->lower != qn->upper)\n    state |= IN_VAR_REPEAT;\n\n  r = tune_tree(body, reg, state, env);\n  if (r != 0) return r;\n\n  /* expand string */\n#define EXPAND_STRING_MAX_LENGTH  100\n  if (NODE_TYPE(body) == NODE_STRING) {\n    if (!IS_INFINITE_REPEAT(qn->lower) && qn->lower == qn->upper &&\n        qn->lower > 1 && qn->lower <= EXPAND_STRING_MAX_LENGTH) {\n      int len = NODE_STRING_LEN(body);\n\n      if (len * qn->lower <= EXPAND_STRING_MAX_LENGTH) {\n        int i, n = qn->lower;\n        node_conv_to_str_node(node, body);\n        for (i = 0; i < n; i++) {\n          r = node_str_node_cat(node, body);\n          if (r != 0) return r;\n        }\n        onig_node_free(body);\n        return r;\n      }\n    }\n  }\n\n  if (qn->greedy && (qn->emptiness == BODY_IS_NOT_EMPTY)) {\n    if (NODE_TYPE(body) == NODE_QUANT) {\n      QuantNode* tqn = QUANT_(body);\n      if (IS_NOT_NULL(tqn->head_exact)) {\n        qn->head_exact  = tqn->head_exact;\n        tqn->head_exact = NULL;\n      }\n    }\n    else {\n      qn->head_exact = get_tree_head_literal(NODE_BODY(node), 1, reg);\n    }\n  }\n\n  return r;\n}\n\nstatic int\ntune_tree(Node* node, regex_t* reg, int state, ScanEnv* env)\n{\n  int r = 0;\n\n  switch (NODE_TYPE(node)) {\n  case NODE_LIST:\n    {\n      Node* prev = NULL_NODE;\n      do {\n        r = tune_tree(NODE_CAR(node), reg, state, env);\n        if (IS_NOT_NULL(prev) && r == 0) {\n          r = tune_next(prev, NODE_CAR(node), reg);\n        }\n        prev = NODE_CAR(node);\n      } while (r == 0 && IS_NOT_NULL(node = NODE_CDR(node)));\n    }\n    break;\n\n  case NODE_ALT:\n    do {\n      r = tune_tree(NODE_CAR(node), reg, (state | IN_ALT), env);\n    } while (r == 0 && IS_NOT_NULL(node = NODE_CDR(node)));\n    break;\n\n  case NODE_STRING:\n    if (NODE_IS_IGNORECASE(node) && ! NODE_STRING_IS_CRUDE(node)) {\n      r = unravel_case_fold_string(node, reg, state);\n    }\n    break;\n\n  case NODE_BACKREF:\n    {\n      int i;\n      int* p;\n      BackRefNode* br = BACKREF_(node);\n      p = BACKREFS_P(br);\n      for (i = 0; i < br->back_num; i++) {\n        if (p[i] > env->num_mem)  return ONIGERR_INVALID_BACKREF;\n        MEM_STATUS_ON(env->backrefed_mem, p[i]);\n#if 0\n#ifdef USE_BACKREF_WITH_LEVEL\n        if (NODE_IS_NEST_LEVEL(node)) {\n          MEM_STATUS_ON(env->backtrack_mem, p[i]);\n        }\n#endif\n#else\n        /* More precisely, it should be checked whether alt/repeat exists before\n           the subject capture node, and then this backreference position\n           exists before (or in) the capture node. */\n        MEM_STATUS_ON(env->backtrack_mem, p[i]);\n#endif\n      }\n    }\n    break;\n\n  case NODE_BAG:\n    {\n      BagNode* en = BAG_(node);\n\n      switch (en->type) {\n      case BAG_OPTION:\n        {\n          OnigOptionType options = reg->options;\n          reg->options = BAG_(node)->o.options;\n          r = tune_tree(NODE_BODY(node), reg, state, env);\n          reg->options = options;\n        }\n        break;\n\n      case BAG_MEMORY:\n#ifdef USE_CALL\n        state |= en->m.called_state;\n#endif\n\n        if ((state & (IN_ALT | IN_NOT | IN_VAR_REPEAT | IN_MULTI_ENTRY)) != 0\n            || NODE_IS_RECURSION(node)) {\n          MEM_STATUS_ON(env->backtrack_mem, en->m.regnum);\n        }\n        r = tune_tree(NODE_BODY(node), reg, state, env);\n        break;\n\n      case BAG_STOP_BACKTRACK:\n        {\n          Node* target = NODE_BODY(node);\n          r = tune_tree(target, reg, state, env);\n          if (NODE_TYPE(target) == NODE_QUANT) {\n            QuantNode* tqn = QUANT_(target);\n            if (IS_INFINITE_REPEAT(tqn->upper) && tqn->lower <= 1 &&\n                tqn->greedy != 0) {  /* (?>a*), a*+ etc... */\n              if (is_strict_real_node(NODE_BODY(target)))\n                NODE_STATUS_ADD(node, STRICT_REAL_REPEAT);\n            }\n          }\n        }\n        break;\n\n      case BAG_IF_ELSE:\n        r = tune_tree(NODE_BODY(node), reg, (state | IN_ALT), env);\n        if (r != 0) return r;\n        if (IS_NOT_NULL(en->te.Then)) {\n          r = tune_tree(en->te.Then, reg, (state | IN_ALT), env);\n          if (r != 0) return r;\n        }\n        if (IS_NOT_NULL(en->te.Else))\n          r = tune_tree(en->te.Else, reg, (state | IN_ALT), env);\n        break;\n      }\n    }\n    break;\n\n  case NODE_QUANT:\n    r = tune_quant(node, reg, state, env);\n    break;\n\n  case NODE_ANCHOR:\n    r = tune_anchor(node, reg, state, env);\n    break;\n\n#ifdef USE_CALL\n  case NODE_CALL:\n#endif\n  case NODE_CTYPE:\n  case NODE_CCLASS:\n  case NODE_GIMMICK:\n  default:\n    break;\n  }\n\n  return r;\n}\n\nextern int\nonig_compile(regex_t* reg, const UChar* pattern, const UChar* pattern_end,\n             OnigErrorInfo* einfo)\n{\n  int r;\n  Node*  root;\n  ScanEnv  scan_env;\n#ifdef USE_CALL\n  UnsetAddrList  uslist = {0};\n#endif\n\n  root = 0;\n  if (IS_NOT_NULL(einfo)) {\n    einfo->enc = reg->enc;\n    einfo->par = (UChar* )NULL;\n  }\n\n#ifdef ONIG_DEBUG\n  fprintf(DBGFP, \"\\nPATTERN: /\");\n  print_enc_string(DBGFP, reg->enc, pattern, pattern_end);\n#endif\n\n  if (reg->ops_alloc == 0) {\n    r = ops_init(reg, OPS_INIT_SIZE);\n    if (r != 0) goto end;\n  }\n  else\n    reg->ops_used = 0;\n\n  reg->string_pool        = 0;\n  reg->string_pool_end    = 0;\n  reg->num_mem            = 0;\n  reg->num_repeat         = 0;\n  reg->num_empty_check    = 0;\n  reg->repeat_range_alloc = 0;\n  reg->repeat_range       = (RepeatRange* )NULL;\n  reg->empty_status_mem   = 0;\n\n  r = onig_parse_tree(&root, pattern, pattern_end, reg, &scan_env);\n  if (r != 0) goto err;\n\n  r = reduce_string_list(root);\n  if (r != 0) goto err;\n\n  /* mixed use named group and no-named group */\n  if (scan_env.num_named > 0 &&\n      IS_SYNTAX_BV(scan_env.syntax, ONIG_SYN_CAPTURE_ONLY_NAMED_GROUP) &&\n      ! OPTON_CAPTURE_GROUP(reg->options)) {\n    if (scan_env.num_named != scan_env.num_mem)\n      r = disable_noname_group_capture(&root, reg, &scan_env);\n    else\n      r = numbered_ref_check(root);\n\n    if (r != 0) goto err;\n  }\n\n  r = check_backrefs(root, &scan_env);\n  if (r != 0) goto err;\n\n#ifdef USE_CALL\n  if (scan_env.num_call > 0) {\n    r = unset_addr_list_init(&uslist, scan_env.num_call);\n    if (r != 0) goto err;\n    scan_env.unset_addr_list = &uslist;\n    r = tune_call(root, &scan_env, 0);\n    if (r != 0) goto err_unset;\n    r = tune_call2(root);\n    if (r != 0) goto err_unset;\n    r = recursive_call_check_trav(root, &scan_env, 0);\n    if (r  < 0) goto err_unset;\n    r = infinite_recursive_call_check_trav(root, &scan_env);\n    if (r != 0) goto err_unset;\n\n    tune_called_state(root, 0);\n  }\n\n  reg->num_call = scan_env.num_call;\n#endif\n\n#ifdef ONIG_DEBUG_PARSE\n  fprintf(DBGFP, \"MAX PARSE DEPTH: %d\\n\", scan_env.max_parse_depth);\n  fprintf(DBGFP, \"TREE (parsed)\\n\");\n  print_tree(DBGFP, root);\n  fprintf(DBGFP, \"\\n\");\n#endif\n\n  r = tune_tree(root, reg, 0, &scan_env);\n  if (r != 0) goto err_unset;\n\n  if (scan_env.backref_num != 0) {\n    set_parent_node_trav(root, NULL_NODE);\n    r = set_empty_repeat_node_trav(root, NULL_NODE, &scan_env);\n    if (r != 0) goto err_unset;\n    set_empty_status_check_trav(root, &scan_env);\n  }\n\n#ifdef ONIG_DEBUG_PARSE\n  fprintf(DBGFP, \"TREE (after tune)\\n\");\n  print_tree(DBGFP, root);\n  fprintf(DBGFP, \"\\n\");\n#endif\n\n  reg->capture_history = scan_env.cap_history;\n  reg->push_mem_start  = scan_env.backtrack_mem | scan_env.cap_history;\n\n#ifdef USE_CALLOUT\n  if (IS_NOT_NULL(reg->extp) && reg->extp->callout_num != 0) {\n    reg->push_mem_end = reg->push_mem_start;\n  }\n  else {\n    if (MEM_STATUS_IS_ALL_ON(reg->push_mem_start))\n      reg->push_mem_end = scan_env.backrefed_mem | scan_env.cap_history;\n    else\n      reg->push_mem_end = reg->push_mem_start &\n                        (scan_env.backrefed_mem | scan_env.cap_history);\n  }\n#else\n  if (MEM_STATUS_IS_ALL_ON(reg->push_mem_start))\n    reg->push_mem_end = scan_env.backrefed_mem | scan_env.cap_history;\n  else\n    reg->push_mem_end = reg->push_mem_start &\n                      (scan_env.backrefed_mem | scan_env.cap_history);\n#endif\n\n  clear_optimize_info(reg);\n#ifndef ONIG_DONT_OPTIMIZE\n  r = set_optimize_info_from_tree(root, reg, &scan_env);\n  if (r != 0) goto err_unset;\n#endif\n\n  if (IS_NOT_NULL(scan_env.mem_env_dynamic)) {\n    xfree(scan_env.mem_env_dynamic);\n    scan_env.mem_env_dynamic = (MemEnv* )NULL;\n  }\n\n  r = compile_tree(root, reg, &scan_env);\n  if (r == 0) {\n    if (scan_env.keep_num > 0) {\n      r = add_op(reg, OP_UPDATE_VAR);\n      if (r != 0) goto err;\n\n      COP(reg)->update_var.type = UPDATE_VAR_KEEP_FROM_STACK_LAST;\n      COP(reg)->update_var.id   = 0; /* not used */\n      COP(reg)->update_var.clear = FALSE;\n    }\n\n    r = add_op(reg, OP_END);\n    if (r != 0) goto err;\n\n#ifdef USE_CALL\n    if (scan_env.num_call > 0) {\n      r = fix_unset_addr_list(&uslist, reg);\n      unset_addr_list_end(&uslist);\n      if (r != 0) goto err;\n    }\n#endif\n\n    set_addr_in_repeat_range(reg);\n\n    if ((reg->push_mem_end != 0)\n#ifdef USE_REPEAT_AND_EMPTY_CHECK_LOCAL_VAR\n        || (reg->num_repeat      != 0)\n        || (reg->num_empty_check != 0)\n#endif\n#ifdef USE_CALLOUT\n        || (IS_NOT_NULL(reg->extp) && reg->extp->callout_num != 0)\n#endif\n#ifdef USE_CALL\n        || scan_env.num_call > 0\n#endif\n        )\n      reg->stack_pop_level = STACK_POP_LEVEL_ALL;\n    else {\n      if (reg->push_mem_start != 0)\n        reg->stack_pop_level = STACK_POP_LEVEL_MEM_START;\n      else\n        reg->stack_pop_level = STACK_POP_LEVEL_FREE;\n    }\n\n    r = ops_make_string_pool(reg);\n    if (r != 0) goto err;\n  }\n#ifdef USE_CALL\n  else if (scan_env.num_call > 0) {\n    unset_addr_list_end(&uslist);\n  }\n#endif\n  onig_node_free(root);\n\n#ifdef ONIG_DEBUG_COMPILE\n  onig_print_names(DBGFP, reg);\n  onig_print_compiled_byte_code_list(DBGFP, reg);\n#endif\n\n#ifdef USE_DIRECT_THREADED_CODE\n  /* opcode -> opaddr */\n  onig_init_for_match_at(reg);\n#endif\n\n end:\n  return r;\n\n err_unset:\n#ifdef USE_CALL\n  if (scan_env.num_call > 0) {\n    unset_addr_list_end(&uslist);\n  }\n#endif\n err:\n  if (IS_NOT_NULL(scan_env.error)) {\n    if (IS_NOT_NULL(einfo)) {\n      einfo->par     = scan_env.error;\n      einfo->par_end = scan_env.error_end;\n    }\n  }\n\n  onig_node_free(root);\n  if (IS_NOT_NULL(scan_env.mem_env_dynamic))\n      xfree(scan_env.mem_env_dynamic);\n  return r;\n}\n\nextern int\nonig_new(regex_t** reg, const UChar* pattern, const UChar* pattern_end,\n         OnigOptionType option, OnigEncoding enc, OnigSyntaxType* syntax,\n         OnigErrorInfo* einfo)\n{\n  int r;\n\n  *reg = (regex_t* )xmalloc(sizeof(regex_t));\n  if (IS_NULL(*reg)) return ONIGERR_MEMORY;\n\n  r = onig_reg_init(*reg, option, ONIGENC_CASE_FOLD_DEFAULT, enc, syntax);\n  if (r != 0) {\n    xfree(*reg);\n    *reg = NULL;\n    return r;\n  }\n\n  r = onig_compile(*reg, pattern, pattern_end, einfo);\n  if (r != 0) {\n    onig_free(*reg);\n    *reg = NULL;\n  }\n  return r;\n}\n\nstatic int\nexec(OnigEncoding enc, OnigOptionType options, OnigSyntaxType* syntax,\n     char* apattern, char* apattern_end, char* astr, UChar* end, int backward)\n{\n  int r;\n  regex_t* reg;\n  OnigErrorInfo einfo;\n  UChar* pattern = (UChar* )apattern;\n  UChar* str     = (UChar* )astr;\n  UChar* pattern_end = (UChar* )apattern_end;\n\n  EXEC_COUNT++;\n  EXEC_COUNT_INTERVAL++;\n\n  onig_initialize(&enc, 1);\n  onig_set_retry_limit_in_search(RETRY_LIMIT);\n#ifdef PARSE_DEPTH_LIMIT\n  onig_set_parse_depth_limit(PARSE_DEPTH_LIMIT);\n#endif\n  onig_set_subexp_call_max_nest_level(CALL_MAX_NEST_LEVEL);\n\n  r = onig_new(&reg, pattern, pattern_end,\n               options, enc, syntax, &einfo);\n  if (r != ONIG_NORMAL) {\n    char s[ONIG_MAX_ERROR_MESSAGE_LEN];\n    onig_error_code_to_str((UChar* )s, r, &einfo);\n#ifdef STANDALONE\n    fprintf(stdout, \"ERROR: %s\\n\", s);\n#endif\n    onig_end();\n\n    if (r == ONIGERR_PARSER_BUG ||\n        r == ONIGERR_STACK_BUG  ||\n        r == ONIGERR_UNDEFINED_BYTECODE ||\n        r == ONIGERR_UNEXPECTED_BYTECODE) {\n      return -2;\n    }\n    else\n      return -1;\n  }\n  REGEX_SUCCESS_COUNT++;\n\n  r = search(reg, pattern, pattern_end, backward);\n  if (r == -2) return -2;\n\n  if (onigenc_is_valid_mbc_string(enc, str, end) != 0) {\n    VALID_STRING_COUNT++;\n    r = search(reg, str, end, backward);\n    if (r == -2) return -2;\n  }\n\n  onig_free(reg);\n  onig_end();\n  return 0;\n}\n\nstatic int\nalloc_exec(OnigEncoding enc, OnigOptionType options, OnigSyntaxType* syntax,\n           int backward, int pattern_size, size_t remaining_size, unsigned char *data)\n{\n  int r;\n  unsigned char *pattern_end;\n  unsigned char *str_null_end;\n\n  // copy first PATTERN_SIZE bytes off to be the pattern\n  unsigned char *pattern = (unsigned char *)malloc(pattern_size != 0 ? pattern_size : 1);\n  memcpy(pattern, data, pattern_size);\n  pattern_end = pattern + pattern_size;\n  data += pattern_size;\n  remaining_size -= pattern_size;\n\n#if defined(UTF16_BE) || defined(UTF16_LE)\n  if (remaining_size % 2 == 1) remaining_size--;\n#endif\n\n  unsigned char *str = (unsigned char*)malloc(remaining_size != 0 ? remaining_size : 1);\n  memcpy(str, data, remaining_size);\n  str_null_end = str + remaining_size;\n\n  r = exec(enc, options, syntax,\n           (char *)pattern, (char *)pattern_end,\n           (char *)str, str_null_end, backward);\n\n  free(pattern);\n  free(str);\n  return r;\n}\n\n\n// target function\nstatic int\ncheck_node_in_look_behind(Node* node, int not, int* used)\n{\n  static unsigned int\n    bag_mask[2] = { ALLOWED_BAG_IN_LB, ALLOWED_BAG_IN_LB_NOT };\n\n  static unsigned int\n    anchor_mask[2] = { ALLOWED_ANCHOR_IN_LB, ALLOWED_ANCHOR_IN_LB_NOT };\n\n  NodeType type;\n  int r = 0;\n\n  type = NODE_TYPE(node);\n  if ((NODE_TYPE2BIT(type) & ALLOWED_TYPE_IN_LB) == 0)\n    return 1;\n\n  switch (type) {\n  case NODE_LIST:\n  case NODE_ALT:\n    do {\n      r = check_node_in_look_behind(NODE_CAR(node), not, used);\n    } while (r == 0 && IS_NOT_NULL(node = NODE_CDR(node)));\n    break;\n\n  case NODE_QUANT:\n    r = check_node_in_look_behind(NODE_BODY(node), not, used);\n    break;\n\n  case NODE_BAG:\n    {\n      BagNode* en = BAG_(node);\n      if (((1<<en->type) & bag_mask[not]) == 0)\n        return 1;\n\n      r = check_node_in_look_behind(NODE_BODY(node), not, used);\n      if (r != 0) break;\n\n      if (en->type == BAG_MEMORY) {\n        if (NODE_IS_BACKREF(node) || NODE_IS_CALLED(node)) *used = TRUE;\n      }\n      else if (en->type == BAG_IF_ELSE) {\n        if (IS_NOT_NULL(en->te.Then)) {\n          r = check_node_in_look_behind(en->te.Then, not, used);\n          if (r != 0) break;\n        }\n        if (IS_NOT_NULL(en->te.Else)) {\n          r = check_node_in_look_behind(en->te.Else, not, used);\n        }\n      }\n    }\n    break;\n\n  case NODE_ANCHOR:\n    type = ANCHOR_(node)->type;\n    if ((type & anchor_mask[not]) == 0)\n      return 1;\n\n    if (IS_NOT_NULL(NODE_BODY(node)))\n      r = check_node_in_look_behind(NODE_BODY(node), not, used);\n    break;\n\n  case NODE_GIMMICK:\n    if (NODE_IS_ABSENT_WITH_SIDE_EFFECTS(node) != 0)\n      return 1;\n    break;\n\n  case NODE_CALL:\n    r = check_called_node_in_look_behind(NODE_BODY(node), not);\n    break;\n\n  default:\n    break;\n  }\n  return r;\n}\n",
    "target": 1,
    "idx": 1021998,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic void\nVariant_clear(UA_Variant *p, const UA_DataType *_) {\n    if(p->storageType != UA_VARIANT_DATA)\n        return;\n    if(p->type && p->data > UA_EMPTY_ARRAY_SENTINEL) {\n        if(p->arrayLength == 0)\n            p->arrayLength = 1;\n        UA_Array_delete(p->data, p->arrayLength, p->type);\n        p->data = NULL;\n    }\n    if((void*)p->arrayDimensions > UA_EMPTY_ARRAY_SENTINEL)\n        UA_free(p->arrayDimensions);\n}\n\nstatic void\nclear_noInit(void *p, const UA_DataType *type) {\n    uintptr_t ptr = (uintptr_t)p;\n    u8 membersSize = type->membersSize;\n    for(size_t i = 0; i < membersSize; ++i) {\n        const UA_DataTypeMember *m= &type->members[i];\n        const UA_DataType *typelists[2] = { UA_TYPES, &type[-type->typeIndex] };\n        const UA_DataType *mt = &typelists[!m->namespaceZero][m->memberTypeIndex];\n        if(!m->isArray) {\n            ptr += m->padding;\n            size_t fi = mt->builtin ? mt->typeIndex : UA_BUILTIN_TYPES_COUNT;\n            clearJumpTable[fi]((void*)ptr, mt);\n            ptr += mt->memSize;\n        } else {\n            ptr += m->padding;\n            size_t length = *(size_t*)ptr;\n            ptr += sizeof(size_t);\n            UA_Array_delete(*(void**)ptr, length, mt);\n            ptr += sizeof(void*);\n        }\n    }\n}\n\nvoid\nUA_clear(void *p, const UA_DataType *type) {\n    clear_noInit(p, type);\n    memset(p, 0, type->memSize); /* init */\n}\n\nstatic void\nclear_noInit(void *p, const UA_DataType *type) {\n    uintptr_t ptr = (uintptr_t)p;\n    u8 membersSize = type->membersSize;\n    for(size_t i = 0; i < membersSize; ++i) {\n        const UA_DataTypeMember *m= &type->members[i];\n        const UA_DataType *typelists[2] = { UA_TYPES, &type[-type->typeIndex] };\n        const UA_DataType *mt = &typelists[!m->namespaceZero][m->memberTypeIndex];\n        if(!m->isArray) {\n            ptr += m->padding;\n            size_t fi = mt->builtin ? mt->typeIndex : UA_BUILTIN_TYPES_COUNT;\n            clearJumpTable[fi]((void*)ptr, mt);\n            ptr += mt->memSize;\n        } else {\n            ptr += m->padding;\n            size_t length = *(size_t*)ptr;\n            ptr += sizeof(size_t);\n            UA_Array_delete(*(void**)ptr, length, mt);\n            ptr += sizeof(void*);\n        }\n    }\n}\n\nvoid\nUA_clear(void *p, const UA_DataType *type) {\n    clear_noInit(p, type);\n    memset(p, 0, type->memSize); /* init */\n}\n\nstatic UA_StatusCode\nVariant_copy(UA_Variant const *src, UA_Variant *dst, const UA_DataType *_) {\n    size_t length = src->arrayLength;\n    if(UA_Variant_isScalar(src))\n        length = 1;\n    UA_StatusCode retval = UA_Array_copy(src->data, length,\n                                         &dst->data, src->type);\n    if(retval != UA_STATUSCODE_GOOD)\n        return retval;\n    dst->arrayLength = src->arrayLength;\n    dst->type = src->type;\n    if(src->arrayDimensions) {\n        retval = UA_Array_copy(src->arrayDimensions, src->arrayDimensionsSize,\n            (void**)&dst->arrayDimensions, &UA_TYPES[UA_TYPES_INT32]);\n        if(retval != UA_STATUSCODE_GOOD)\n            return retval;\n        dst->arrayDimensionsSize = src->arrayDimensionsSize;\n    }\n    return UA_STATUSCODE_GOOD;\n}\n\nstatic UA_StatusCode\ncopy_noInit(const void *src, void *dst, const UA_DataType *type) {\n    UA_StatusCode retval = UA_STATUSCODE_GOOD;\n    uintptr_t ptrs = (uintptr_t)src;\n    uintptr_t ptrd = (uintptr_t)dst;\n    u8 membersSize = type->membersSize;\n    for(size_t i = 0; i < membersSize; ++i) {\n        const UA_DataTypeMember *m= &type->members[i];\n        const UA_DataType *typelists[2] = { UA_TYPES, &type[-type->typeIndex] };\n        const UA_DataType *mt = &typelists[!m->namespaceZero][m->memberTypeIndex];\n        if(!m->isArray) {\n            ptrs += m->padding;\n            ptrd += m->padding;\n            size_t fi = mt->builtin ? mt->typeIndex : UA_BUILTIN_TYPES_COUNT;\n            retval |= copyJumpTable[fi]((const void*)ptrs, (void*)ptrd, mt);\n            ptrs += mt->memSize;\n            ptrd += mt->memSize;\n        } else {\n            ptrs += m->padding;\n            ptrd += m->padding;\n            size_t *dst_size = (size_t*)ptrd;\n            const size_t size = *((const size_t*)ptrs);\n            ptrs += sizeof(size_t);\n            ptrd += sizeof(size_t);\n            retval |= UA_Array_copy(*(void* const*)ptrs, size, (void**)ptrd, mt);\n            if(retval == UA_STATUSCODE_GOOD)\n                *dst_size = size;\n            else\n                *dst_size = 0;\n            ptrs += sizeof(void*);\n            ptrd += sizeof(void*);\n        }\n    }\n    return retval;\n}\n\nUA_StatusCode\nUA_copy(const void *src, void *dst, const UA_DataType *type) {\n    memset(dst, 0, type->memSize); /* init */\n    UA_StatusCode retval = copy_noInit(src, dst, type);\n    if(retval != UA_STATUSCODE_GOOD)\n        UA_clear(dst, type);\n    return retval;\n}\n\nstatic UA_Boolean tortureEncoding(const uint8_t *data, size_t size, size_t *newOffset) {\n    *newOffset = 0;\n    if (size <= 2)\n        return UA_FALSE;\n\n    // get some random type\n    uint16_t typeIndex = (uint16_t)(data[0] | data[1] << 8);\n    data += 2;\n    size -= 2;\n\n    if (typeIndex >= UA_TYPES_COUNT)\n        return UA_FALSE;\n\n    void *dst = UA_new(&UA_TYPES[typeIndex]);\n\n    if (!dst)\n        return UA_FALSE;\n\n    const UA_ByteString binary = {\n            size, //length\n            (UA_Byte *) (void *) data\n    };\n\n    UA_StatusCode ret = UA_decodeBinary(&binary, newOffset, dst, &UA_TYPES[typeIndex], NULL);\n\n    if (ret == UA_STATUSCODE_GOOD) {\n        // copy the datatype to test\n        void *dstCopy = UA_new(&UA_TYPES[typeIndex]);\n        if (!dstCopy)\n            return UA_FALSE;\n        UA_copy(dst, dstCopy, &UA_TYPES[typeIndex]);\n        UA_delete(dstCopy, &UA_TYPES[typeIndex]);\n\n        // now also test encoding\n        UA_ByteString encoded;\n        UA_ByteString_allocBuffer(&encoded, *newOffset);\n        const UA_Byte *end = &encoded.data[*newOffset];\n        UA_Byte *pos = encoded.data;\n        ret = UA_encodeBinary(dst, &UA_TYPES[typeIndex], &pos, &end, NULL, NULL);\n        if (ret == UA_STATUSCODE_GOOD) {\n            // do nothing\n        }\n        UA_ByteString_deleteMembers(&encoded);\n    }\n    UA_delete(dst, &UA_TYPES[typeIndex]);\n\n    return UA_TRUE;\n}\n\nint ExecuteFilesOnyByOne(int argc, char **argv) {\n  for (int i = 1; i < argc; i++) {\n    std::ifstream in(argv[i], std::ios::binary);\n    in.seekg(0, in.end);\n    size_t length = in.tellg();\n    in.seekg (0, in.beg);\n    std::cout << \"Reading \" << length << \" bytes from \" << argv[i] << std::endl;\n    // Allocate exactly length bytes so that we reliably catch buffer overflows.\n    std::vector<char> bytes(length);\n    in.read(bytes.data(), bytes.size());\n    assert(in);\n    LLVMFuzzerTestOneInput(reinterpret_cast<const uint8_t *>(bytes.data()),\n                           bytes.size());\n    std::cout << \"Execution successful\" << std::endl;\n  }\n  return 0;\n}\n\nint main(int argc, char **argv) {\n  fprintf(stderr,\n      \"======================= INFO =========================\\n\"\n      \"This binary is built for AFL-fuzz.\\n\"\n      \"To run the target function on individual input(s) execute this:\\n\"\n      \"  %s < INPUT_FILE\\n\"\n      \"or\\n\"\n      \"  %s INPUT_FILE1 [INPUT_FILE2 ... ]\\n\"\n      \"To fuzz with afl-fuzz execute this:\\n\"\n      \"  afl-fuzz [afl-flags] %s [-N]\\n\"\n      \"afl-fuzz will run N iterations before \"\n      \"re-spawning the process (default: 1000)\\n\"\n      \"======================================================\\n\",\n          argv[0], argv[0], argv[0]);\n  if (LLVMFuzzerInitialize)\n    LLVMFuzzerInitialize(&argc, &argv);\n  // Do any other expensive one-time initialization here.\n\n  maybe_duplicate_stderr();\n  maybe_initialize_extra_stats();\n\n  if (!getenv(\"AFL_DRIVER_DONT_DEFER\"))\n    __afl_manual_init();\n\n  int N = 1000;\n  if (argc == 2 && argv[1][0] == '-')\n      N = atoi(argv[1] + 1);\n  else if(argc == 2 && (N = atoi(argv[1])) > 0)\n      fprintf(stderr, \"WARNING: using the deprecated call style `%s %d`\\n\",\n              argv[0], N);\n  else if (argc > 1)\n    return ExecuteFilesOnyByOne(argc, argv);\n\n  assert(N > 0);\n\n  // Call LLVMFuzzerTestOneInput here so that coverage caused by initialization\n  // on the first execution of LLVMFuzzerTestOneInput is ignored.\n  uint8_t dummy_input[1] = {0};\n  LLVMFuzzerTestOneInput(dummy_input, 1);\n\n  time_t unit_time_secs;\n  int num_runs = 0;\n  while (__afl_persistent_loop(N)) {\n    ssize_t n_read = read(0, AflInputBuf, kMaxAflInputSize);\n    if (n_read > 0) {\n      // Copy AflInputBuf into a separate buffer to let asan find buffer\n      // overflows. Don't use unique_ptr/etc to avoid extra dependencies.\n      uint8_t *copy = new uint8_t[n_read];\n      memcpy(copy, AflInputBuf, n_read);\n\n      struct timeval unit_start_time;\n      CHECK_ERROR(gettimeofday(&unit_start_time, NULL) == 0,\n                  \"Calling gettimeofday failed\");\n\n      num_runs++;\n      LLVMFuzzerTestOneInput(copy, n_read);\n\n      struct timeval unit_stop_time;\n      CHECK_ERROR(gettimeofday(&unit_stop_time, NULL) == 0,\n                  \"Calling gettimeofday failed\");\n\n      // Update slowest_unit_time_secs if we see a new max.\n      unit_time_secs = unit_stop_time.tv_sec - unit_start_time.tv_sec;\n      if (slowest_unit_time_secs < unit_time_secs)\n        slowest_unit_time_secs = unit_time_secs;\n\n      delete[] copy;\n    }\n  }\n  fprintf(stderr, \"%s: successfully executed %d input(s)\\n\", argv[0], num_runs);\n}\n\n\n// target function\nstatic void\nVariant_clear(UA_Variant *p, const UA_DataType *_) {\n    if(p->storageType != UA_VARIANT_DATA)\n        return;\n    if(p->type && p->data > UA_EMPTY_ARRAY_SENTINEL) {\n        if(p->arrayLength == 0)\n            p->arrayLength = 1;\n        UA_Array_delete(p->data, p->arrayLength, p->type);\n    }\n    if((void*)p->arrayDimensions > UA_EMPTY_ARRAY_SENTINEL)\n        UA_free(p->arrayDimensions);\n}\n",
    "target": 1,
    "idx": 1011484,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "// context\nstatic void set_planes_to_neutral_grey(const SequenceHeader *const seq_params,\n                                       const YV12_BUFFER_CONFIG *const buf,\n                                       int only_chroma) {\n  const int val = 1 << (seq_params->bit_depth - 1);\n  for (int plane = only_chroma; plane < MAX_MB_PLANE; plane++) {\n    const int is_uv = plane > 0;\n    for (int row_idx = 0; row_idx < buf->crop_heights[is_uv]; row_idx++) {\n      if (seq_params->use_highbitdepth) {\n        // TODO(yaowu): replace this with aom_memset16() for speed\n        for (int col_idx = 0; col_idx < buf->crop_widths[is_uv]; col_idx++) {\n          uint16_t *base = CONVERT_TO_SHORTPTR(buf->buffers[plane]);\n          base[row_idx * buf->strides[is_uv] + col_idx] = val;\n        }\n      } else {\n        memset(&buf->buffers[plane][row_idx * buf->uv_stride], 1 << 7,\n               buf->crop_widths[is_uv]);\n      }\n    }\n  }\n}\n\nuint32_t av1_decode_frame_headers_and_setup(AV1Decoder *pbi,\n                                            struct aom_read_bit_buffer *rb,\n                                            const uint8_t *data,\n                                            const uint8_t **p_data_end,\n                                            int trailing_bits_present) {\n  AV1_COMMON *const cm = &pbi->common;\n  const int num_planes = av1_num_planes(cm);\n  MACROBLOCKD *const xd = &pbi->mb;\n\n#if CONFIG_BITSTREAM_DEBUG\n  bitstream_queue_set_frame_read(cm->current_video_frame * 2 + cm->show_frame);\n#endif\n#if CONFIG_MISMATCH_DEBUG\n  mismatch_move_frame_idx_r();\n#endif\n\n  for (int i = LAST_FRAME; i <= ALTREF_FRAME; ++i) {\n    cm->global_motion[i] = default_warp_params;\n    cm->cur_frame->global_motion[i] = default_warp_params;\n  }\n  xd->global_motion = cm->global_motion;\n\n  read_uncompressed_header(pbi, rb);\n\n  if (trailing_bits_present) av1_check_trailing_bits(pbi, rb);\n\n  // If cm->single_tile_decoding = 0, the independent decoding of a single tile\n  // or a section of a frame is not allowed.\n  if (!cm->single_tile_decoding &&\n      (pbi->dec_tile_row >= 0 || pbi->dec_tile_col >= 0)) {\n    pbi->dec_tile_row = -1;\n    pbi->dec_tile_col = -1;\n  }\n\n  const uint32_t uncomp_hdr_size =\n      (uint32_t)aom_rb_bytes_read(rb);  // Size of the uncompressed header\n  YV12_BUFFER_CONFIG *new_fb = get_frame_new_buffer(cm);\n  xd->cur_buf = new_fb;\n  if (av1_allow_intrabc(cm)) {\n    av1_setup_scale_factors_for_frame(\n        &cm->sf_identity, xd->cur_buf->y_crop_width, xd->cur_buf->y_crop_height,\n        xd->cur_buf->y_crop_width, xd->cur_buf->y_crop_height);\n  }\n\n  if (cm->show_existing_frame) {\n    // showing a frame directly\n    *p_data_end = data + uncomp_hdr_size;\n    if (cm->reset_decoder_state) {\n      // Use the default frame context values.\n      *cm->fc = cm->frame_contexts[FRAME_CONTEXT_DEFAULTS];\n      if (!cm->fc->initialized)\n        aom_internal_error(&cm->error, AOM_CODEC_CORRUPT_FRAME,\n                           \"Uninitialized entropy context.\");\n    }\n    return uncomp_hdr_size;\n  }\n\n  cm->setup_mi(cm);\n\n  cm->current_frame_seg_map = cm->cur_frame->seg_map;\n\n  av1_setup_motion_field(cm);\n\n  av1_setup_block_planes(xd, cm->seq_params.subsampling_x,\n                         cm->seq_params.subsampling_y, num_planes);\n  if (cm->primary_ref_frame == PRIMARY_REF_NONE) {\n    // use the default frame context values\n    *cm->fc = cm->frame_contexts[FRAME_CONTEXT_DEFAULTS];\n  } else {\n    *cm->fc = cm->frame_contexts[cm->frame_refs[cm->primary_ref_frame].idx];\n  }\n  if (!cm->fc->initialized)\n    aom_internal_error(&cm->error, AOM_CODEC_CORRUPT_FRAME,\n                       \"Uninitialized entropy context.\");\n\n  xd->corrupted = 0;\n  return uncomp_hdr_size;\n}\n\nstatic uint32_t read_frame_header_obu(AV1Decoder *pbi,\n                                      struct aom_read_bit_buffer *rb,\n                                      const uint8_t *data,\n                                      const uint8_t **p_data_end,\n                                      int trailing_bits_present) {\n  return av1_decode_frame_headers_and_setup(pbi, rb, data, p_data_end,\n                                            trailing_bits_present);\n}\n\nint av1_receive_compressed_data(AV1Decoder *pbi, size_t size,\n                                const uint8_t **psource) {\n  AV1_COMMON *volatile const cm = &pbi->common;\n  BufferPool *volatile const pool = cm->buffer_pool;\n  RefCntBuffer *volatile const frame_bufs = cm->buffer_pool->frame_bufs;\n  const uint8_t *source = *psource;\n  cm->error.error_code = AOM_CODEC_OK;\n\n  if (size == 0) {\n    // This is used to signal that we are missing frames.\n    // We do not know if the missing frame(s) was supposed to update\n    // any of the reference buffers, but we act conservative and\n    // mark only the last buffer as corrupted.\n    //\n    // TODO(jkoleszar): Error concealment is undefined and non-normative\n    // at this point, but if it becomes so, [0] may not always be the correct\n    // thing to do here.\n    if (cm->frame_refs[0].idx > 0) {\n      assert(cm->frame_refs[0].buf != NULL);\n      cm->frame_refs[0].buf->corrupted = 1;\n    }\n  }\n\n  // Find a free buffer for the new frame, releasing the reference previously\n  // held.\n\n  // Find a free frame buffer. Return error if can not find any.\n  cm->new_fb_idx = get_free_fb(cm);\n  if (cm->new_fb_idx == INVALID_IDX) {\n    cm->error.error_code = AOM_CODEC_MEM_ERROR;\n    return 1;\n  }\n\n  // Assign a MV array to the frame buffer.\n  cm->cur_frame = &pool->frame_bufs[cm->new_fb_idx];\n\n  if (!pbi->camera_frame_header_ready) pbi->hold_ref_buf = 0;\n\n  pbi->cur_buf = &frame_bufs[cm->new_fb_idx];\n\n  // The jmp_buf is valid only for the duration of the function that calls\n  // setjmp(). Therefore, this function must reset the 'setjmp' field to 0\n  // before it returns.\n  if (setjmp(cm->error.jmp)) {\n    const AVxWorkerInterface *const winterface = aom_get_worker_interface();\n    int i;\n\n    cm->error.setjmp = 0;\n\n    // Synchronize all threads immediately as a subsequent decode call may\n    // cause a resize invalidating some allocations.\n    winterface->sync(&pbi->lf_worker);\n    for (i = 0; i < pbi->num_workers; ++i) {\n      winterface->sync(&pbi->tile_workers[i]);\n    }\n\n    lock_buffer_pool(pool);\n    // Release all the reference buffers if worker thread is holding them.\n    if (pbi->hold_ref_buf == 1) {\n      int ref_index = 0, mask;\n      for (mask = pbi->refresh_frame_flags; mask; mask >>= 1) {\n        const int old_idx = cm->ref_frame_map[ref_index];\n        // Current thread releases the holding of reference frame.\n        decrease_ref_count(old_idx, frame_bufs, pool);\n\n        // Release the reference frame holding in the reference map for the\n        // decoding of the next frame.\n        if (mask & 1) decrease_ref_count(old_idx, frame_bufs, pool);\n        ++ref_index;\n      }\n\n      // Current thread releases the holding of reference frame.\n      const int check_on_show_existing_frame =\n          !cm->show_existing_frame || cm->reset_decoder_state;\n      for (; ref_index < REF_FRAMES && check_on_show_existing_frame;\n           ++ref_index) {\n        const int old_idx = cm->ref_frame_map[ref_index];\n        decrease_ref_count(old_idx, frame_bufs, pool);\n      }\n      pbi->hold_ref_buf = 0;\n    }\n    // Release current frame.\n    decrease_ref_count(cm->new_fb_idx, frame_bufs, pool);\n    unlock_buffer_pool(pool);\n\n    aom_clear_system_state();\n    return -1;\n  }\n\n  cm->error.setjmp = 1;\n\n  int frame_decoded =\n      aom_decode_frame_from_obus(pbi, source, source + size, psource);\n\n  if (cm->error.error_code != AOM_CODEC_OK) {\n    lock_buffer_pool(pool);\n    decrease_ref_count(cm->new_fb_idx, frame_bufs, pool);\n    unlock_buffer_pool(pool);\n    cm->error.setjmp = 0;\n    return 1;\n  }\n\n#if TXCOEFF_TIMER\n  cm->cum_txcoeff_timer += cm->txcoeff_timer;\n  fprintf(stderr,\n          \"txb coeff block number: %d, frame time: %ld, cum time %ld in us\\n\",\n          cm->txb_count, cm->txcoeff_timer, cm->cum_txcoeff_timer);\n  cm->txcoeff_timer = 0;\n  cm->txb_count = 0;\n#endif\n\n  // Note: At this point, this function holds a reference to cm->new_fb_idx\n  // in the buffer pool. This reference is consumed by swap_frame_buffers().\n  swap_frame_buffers(pbi, frame_decoded);\n\n  if (frame_decoded) {\n    pbi->decoding_first_frame = 0;\n  }\n\n  if (cm->error.error_code != AOM_CODEC_OK) {\n    cm->error.setjmp = 0;\n    return 1;\n  }\n\n  aom_clear_system_state();\n\n  if (!cm->show_existing_frame) {\n    cm->last_show_frame = cm->show_frame;\n\n    if (cm->seg.enabled) {\n      if (cm->prev_frame && (cm->mi_rows == cm->prev_frame->mi_rows) &&\n          (cm->mi_cols == cm->prev_frame->mi_cols)) {\n        cm->last_frame_seg_map = cm->prev_frame->seg_map;\n      } else {\n        cm->last_frame_seg_map = NULL;\n      }\n    }\n  }\n\n  // Update progress in frame parallel decode.\n  cm->last_width = cm->width;\n  cm->last_height = cm->height;\n  cm->last_tile_cols = cm->tile_cols;\n  cm->last_tile_rows = cm->tile_rows;\n  cm->error.setjmp = 0;\n\n  return 0;\n}\n\nstatic int frame_worker_hook(void *arg1, void *arg2) {\n  FrameWorkerData *const frame_worker_data = (FrameWorkerData *)arg1;\n  const uint8_t *data = frame_worker_data->data;\n  (void)arg2;\n\n  int result = av1_receive_compressed_data(frame_worker_data->pbi,\n                                           frame_worker_data->data_size, &data);\n  frame_worker_data->data_end = data;\n\n  if (result != 0) {\n    // Check decode result in serial decode.\n    frame_worker_data->pbi->cur_buf->buf.corrupted = 1;\n    frame_worker_data->pbi->need_resync = 1;\n  }\n  return !result;\n}\n\nstatic void execute(AVxWorker *const worker) {\n  if (worker->hook != NULL) {\n    worker->had_error |= !worker->hook(worker->data1, worker->data2);\n  }\n}\n\nstatic aom_codec_err_t decode_one(aom_codec_alg_priv_t *ctx,\n                                  const uint8_t **data, size_t data_sz,\n                                  void *user_priv) {\n  const AVxWorkerInterface *const winterface = aom_get_worker_interface();\n\n  // Determine the stream parameters. Note that we rely on peek_si to\n  // validate that we have a buffer that does not wrap around the top\n  // of the heap.\n  if (!ctx->si.h) {\n    int is_intra_only = 0;\n    ctx->si.is_annexb = ctx->is_annexb;\n    const aom_codec_err_t res =\n        decoder_peek_si_internal(*data, data_sz, &ctx->si, &is_intra_only);\n    if (res != AOM_CODEC_OK) return res;\n\n    if (!ctx->si.is_kf && !is_intra_only) return AOM_CODEC_ERROR;\n  }\n\n  AVxWorker *const worker = ctx->frame_workers;\n  FrameWorkerData *const frame_worker_data = (FrameWorkerData *)worker->data1;\n  frame_worker_data->data = *data;\n  frame_worker_data->data_size = data_sz;\n  frame_worker_data->user_priv = user_priv;\n  frame_worker_data->received_frame = 1;\n\n#if CONFIG_INSPECTION\n  frame_worker_data->pbi->inspect_cb = ctx->inspect_cb;\n  frame_worker_data->pbi->inspect_ctx = ctx->inspect_ctx;\n#endif\n\n  frame_worker_data->pbi->common.large_scale_tile = ctx->tile_mode;\n  frame_worker_data->pbi->dec_tile_row = ctx->decode_tile_row;\n  frame_worker_data->pbi->dec_tile_col = ctx->decode_tile_col;\n  frame_worker_data->pbi->ext_tile_debug = ctx->ext_tile_debug;\n  frame_worker_data->pbi->row_mt = ctx->row_mt;\n  frame_worker_data->pbi->ext_refs = ctx->ext_refs;\n\n  frame_worker_data->pbi->common.is_annexb = ctx->is_annexb;\n\n  worker->had_error = 0;\n  winterface->execute(worker);\n\n  // Update data pointer after decode.\n  *data = frame_worker_data->data_end;\n\n  if (worker->had_error)\n    return update_error_state(ctx, &frame_worker_data->pbi->common.error);\n\n  check_resync(ctx, frame_worker_data->pbi);\n\n  return AOM_CODEC_OK;\n}\n\naom_codec_err_t aom_codec_decode(aom_codec_ctx_t *ctx, const uint8_t *data,\n                                 size_t data_sz, void *user_priv) {\n  aom_codec_err_t res;\n\n  /* Sanity checks */\n  /* NULL data ptr allowed if data_sz is 0 too */\n  if (!ctx || (!data && data_sz) || (data && !data_sz))\n    res = AOM_CODEC_INVALID_PARAM;\n  else if (!ctx->iface || !ctx->priv)\n    res = AOM_CODEC_ERROR;\n  else {\n    res = ctx->iface->dec.decode(get_alg_priv(ctx), data, data_sz, user_priv);\n  }\n\n  return SAVE_STATUS(ctx, res);\n}\n\n\n// target function\nstatic void set_planes_to_neutral_grey(const SequenceHeader *const seq_params,\n                                       const YV12_BUFFER_CONFIG *const buf,\n                                       int only_chroma) {\n  const int val = 1 << (seq_params->bit_depth - 1);\n\n  for (int plane = only_chroma; plane < MAX_MB_PLANE; plane++) {\n    const int is_uv = plane > 0;\n    for (int row_idx = 0; row_idx < buf->crop_heights[is_uv]; row_idx++) {\n      if (seq_params->use_highbitdepth) {\n        // TODO(yaowu): replace this with aom_memset16() for speed\n        for (int col_idx = 0; col_idx < buf->crop_widths[is_uv]; col_idx++) {\n          uint16_t *base = CONVERT_TO_SHORTPTR(buf->buffers[plane]);\n          base[row_idx * buf->strides[is_uv] + col_idx] = val;\n        }\n      } else {\n        memset(&buf->buffers[plane][row_idx * buf->uv_stride], 1 << 7,\n               buf->crop_widths[is_uv]);\n      }\n    }\n  }\n}\nstatic INLINE void reset_frame_buffers(AV1_COMMON *cm) {\n  RefCntBuffer *const frame_bufs = cm->buffer_pool->frame_bufs;\n  const SequenceHeader *const seq_params = &cm->seq_params;\n  int i;\n\n  memset(&cm->ref_frame_map, -1, sizeof(cm->ref_frame_map));\n  memset(&cm->next_ref_frame_map, -1, sizeof(cm->next_ref_frame_map));\n\n  lock_buffer_pool(cm->buffer_pool);\n  for (i = 0; i < FRAME_BUFFERS; ++i) {\n    if (i != cm->new_fb_idx) {\n      frame_bufs[i].ref_count = 0;\n      cm->buffer_pool->release_fb_cb(cm->buffer_pool->cb_priv,\n                                     &frame_bufs[i].raw_frame_buffer);\n    }\n    frame_bufs[i].cur_frame_offset = 0;\n    // Previous sequence with different bitdepth may have set to a\n    // neutral gray in different bit depth, need reset here.\n    set_planes_to_neutral_grey(seq_params, &frame_bufs[i].buf, 0);\n    av1_zero(frame_bufs[i].ref_frame_offset);\n  }\n  unlock_buffer_pool(cm->buffer_pool);\n}\n",
    "target": 1,
    "idx": 1010200,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nUA_StatusCode\nUA_Array_copy(const void *src, size_t size,\n              void **dst, const UA_DataType *type) {\n    if(size == 0) {\n        if(src == NULL)\n            *dst = NULL;\n        else\n            *dst= UA_EMPTY_ARRAY_SENTINEL;\n        return UA_STATUSCODE_GOOD;\n    }\n\n    if(!type)\n        return UA_STATUSCODE_BADINTERNALERROR;\n\n    /* calloc, so we don't have to check retval in every iteration of copying */\n    *dst = UA_calloc(size, type->memSize);\n    if(!*dst)\n        return UA_STATUSCODE_BADOUTOFMEMORY;\n\n    if(type->pointerFree) {\n        memcpy(*dst, src, type->memSize * size);\n        return UA_STATUSCODE_GOOD;\n    }\n\n    uintptr_t ptrs = (uintptr_t)src;\n    uintptr_t ptrd = (uintptr_t)*dst;\n    UA_StatusCode retval = UA_STATUSCODE_GOOD;\n    for(size_t i = 0; i < size; ++i) {\n        retval |= UA_copy((void*)ptrs, (void*)ptrd, type);\n        ptrs += type->memSize;\n        ptrd += type->memSize;\n    }\n    if(retval != UA_STATUSCODE_GOOD) {\n        UA_Array_delete(*dst, size, type);\n        *dst = NULL;\n    }\n    return retval;\n}\n\nstatic UA_StatusCode\ncopy_noInit(const void *src, void *dst, const UA_DataType *type) {\n    UA_StatusCode retval = UA_STATUSCODE_GOOD;\n    uintptr_t ptrs = (uintptr_t)src;\n    uintptr_t ptrd = (uintptr_t)dst;\n    u8 membersSize = type->membersSize;\n    for(size_t i = 0; i < membersSize; ++i) {\n        const UA_DataTypeMember *m= &type->members[i];\n        const UA_DataType *typelists[2] = { UA_TYPES, &type[-type->typeIndex] };\n        const UA_DataType *mt = &typelists[!m->namespaceZero][m->memberTypeIndex];\n        if(!m->isArray) {\n            ptrs += m->padding;\n            ptrd += m->padding;\n            size_t fi = mt->builtin ? mt->typeIndex : UA_BUILTIN_TYPES_COUNT;\n            retval |= copyJumpTable[fi]((const void*)ptrs, (void*)ptrd, mt);\n            ptrs += mt->memSize;\n            ptrd += mt->memSize;\n        } else {\n            ptrs += m->padding;\n            ptrd += m->padding;\n            size_t *dst_size = (size_t*)ptrd;\n            const size_t size = *((const size_t*)ptrs);\n            ptrs += sizeof(size_t);\n            ptrd += sizeof(size_t);\n            retval |= UA_Array_copy(*(void* const*)ptrs, size, (void**)ptrd, mt);\n            if(retval == UA_STATUSCODE_GOOD)\n                *dst_size = size;\n            else\n                *dst_size = 0;\n            ptrs += sizeof(void*);\n            ptrd += sizeof(void*);\n        }\n    }\n    return retval;\n}\n\nUA_StatusCode\nUA_copy(const void *src, void *dst, const UA_DataType *type) {\n    memset(dst, 0, type->memSize); /* init */\n    UA_StatusCode retval = copy_noInit(src, dst, type);\n    if(retval != UA_STATUSCODE_GOOD)\n        UA_deleteMembers(dst, type);\n    return retval;\n}\n\nstatic UA_StatusCode\nExtensionObject_copy(UA_ExtensionObject const *src, UA_ExtensionObject *dst,\n                     const UA_DataType *_) {\n    UA_StatusCode retval = UA_STATUSCODE_GOOD;\n    switch(src->encoding) {\n    case UA_EXTENSIONOBJECT_ENCODED_NOBODY:\n    case UA_EXTENSIONOBJECT_ENCODED_BYTESTRING:\n    case UA_EXTENSIONOBJECT_ENCODED_XML:\n        dst->encoding = src->encoding;\n        retval = NodeId_copy(&src->content.encoded.typeId,\n                             &dst->content.encoded.typeId, NULL);\n        retval |= UA_ByteString_copy(&src->content.encoded.body,\n                                     &dst->content.encoded.body);\n        break;\n    case UA_EXTENSIONOBJECT_DECODED:\n    case UA_EXTENSIONOBJECT_DECODED_NODELETE:\n        if(!src->content.decoded.type || !src->content.decoded.data)\n            return UA_STATUSCODE_BADINTERNALERROR;\n        dst->encoding = UA_EXTENSIONOBJECT_DECODED;\n        dst->content.decoded.type = src->content.decoded.type;\n        retval = UA_Array_copy(src->content.decoded.data, 1,\n            &dst->content.decoded.data, src->content.decoded.type);\n        break;\n    default:\n        break;\n    }\n    return retval;\n}\n\nstatic UA_StatusCode\ncopy_noInit(const void *src, void *dst, const UA_DataType *type) {\n    UA_StatusCode retval = UA_STATUSCODE_GOOD;\n    uintptr_t ptrs = (uintptr_t)src;\n    uintptr_t ptrd = (uintptr_t)dst;\n    u8 membersSize = type->membersSize;\n    for(size_t i = 0; i < membersSize; ++i) {\n        const UA_DataTypeMember *m= &type->members[i];\n        const UA_DataType *typelists[2] = { UA_TYPES, &type[-type->typeIndex] };\n        const UA_DataType *mt = &typelists[!m->namespaceZero][m->memberTypeIndex];\n        if(!m->isArray) {\n            ptrs += m->padding;\n            ptrd += m->padding;\n            size_t fi = mt->builtin ? mt->typeIndex : UA_BUILTIN_TYPES_COUNT;\n            retval |= copyJumpTable[fi]((const void*)ptrs, (void*)ptrd, mt);\n            ptrs += mt->memSize;\n            ptrd += mt->memSize;\n        } else {\n            ptrs += m->padding;\n            ptrd += m->padding;\n            size_t *dst_size = (size_t*)ptrd;\n            const size_t size = *((const size_t*)ptrs);\n            ptrs += sizeof(size_t);\n            ptrd += sizeof(size_t);\n            retval |= UA_Array_copy(*(void* const*)ptrs, size, (void**)ptrd, mt);\n            if(retval == UA_STATUSCODE_GOOD)\n                *dst_size = size;\n            else\n                *dst_size = 0;\n            ptrs += sizeof(void*);\n            ptrd += sizeof(void*);\n        }\n    }\n    return retval;\n}\n\nUA_StatusCode\nUA_copy(const void *src, void *dst, const UA_DataType *type) {\n    memset(dst, 0, type->memSize); /* init */\n    UA_StatusCode retval = copy_noInit(src, dst, type);\n    if(retval != UA_STATUSCODE_GOOD)\n        UA_deleteMembers(dst, type);\n    return retval;\n}\n\nstatic UA_Boolean tortureEncoding(const uint8_t *data, size_t size, size_t *newOffset) {\n    *newOffset = 0;\n    if (size <= 2)\n        return UA_FALSE;\n\n    // get some random type\n    uint16_t typeIndex = (uint16_t)(data[0] | data[1] << 8);\n    data += 2;\n    size -= 2;\n\n    if (typeIndex >= UA_TYPES_COUNT)\n        return UA_FALSE;\n\n    void *dst = UA_new(&UA_TYPES[typeIndex]);\n\n    const UA_ByteString binary = {\n            size, //length\n            (UA_Byte *) (void *) data\n    };\n\n    UA_StatusCode ret = UA_decodeBinary(&binary, newOffset, dst, &UA_TYPES[typeIndex], 0, nullptr);\n\n    if (ret == UA_STATUSCODE_GOOD) {\n        // copy the datatype to test\n        void *dstCopy = UA_new(&UA_TYPES[typeIndex]);\n        UA_copy(dst, dstCopy, &UA_TYPES[typeIndex]);\n        UA_delete(dstCopy, &UA_TYPES[typeIndex]);\n\n        // now also test encoding\n        UA_ByteString encoded;\n        UA_ByteString_allocBuffer(&encoded, *newOffset);\n        const UA_Byte *end = &encoded.data[*newOffset];\n        UA_Byte *pos = encoded.data;\n        ret = UA_encodeBinary(dst, &UA_TYPES[typeIndex], &pos, &end, NULL, NULL);\n        if (ret == UA_STATUSCODE_GOOD) {\n            // do nothing\n        }\n        UA_ByteString_deleteMembers(&encoded);\n    }\n    UA_delete(dst, &UA_TYPES[typeIndex]);\n\n    return UA_TRUE;\n}\n\nvoid Fuzzer::ExecuteCallback(const uint8_t *Data, size_t Size) {\n  TPC.RecordInitialStack();\n  TotalNumberOfRuns++;\n  assert(InFuzzingThread());\n  if (SMR.IsClient())\n    SMR.WriteByteArray(Data, Size);\n  // We copy the contents of Unit into a separate heap buffer\n  // so that we reliably find buffer overflows in it.\n  uint8_t *DataCopy = new uint8_t[Size];\n  memcpy(DataCopy, Data, Size);\n  if (CurrentUnitData && CurrentUnitData != Data)\n    memcpy(CurrentUnitData, Data, Size);\n  CurrentUnitSize = Size;\n  AllocTracer.Start(Options.TraceMalloc);\n  UnitStartTime = system_clock::now();\n  TPC.ResetMaps();\n  RunningCB = true;\n  int Res = CB(DataCopy, Size);\n  RunningCB = false;\n  UnitStopTime = system_clock::now();\n  (void)Res;\n  assert(Res == 0);\n  HasMoreMallocsThanFrees = AllocTracer.Stop();\n  if (!LooseMemeq(DataCopy, Data, Size))\n    CrashOnOverwrittenData();\n  CurrentUnitSize = 0;\n  delete[] DataCopy;\n}\n\nint RunOneTest(Fuzzer *F, const char *InputFilePath, size_t MaxLen) {\n  Unit U = FileToVector(InputFilePath);\n  if (MaxLen && MaxLen < U.size())\n    U.resize(MaxLen);\n  F->ExecuteCallback(U.data(), U.size());\n  F->TryDetectingAMemoryLeak(U.data(), U.size(), true);\n  return 0;\n}\n\nint FuzzerDriver(int *argc, char ***argv, UserCallback Callback) {\n  using namespace fuzzer;\n  assert(argc && argv && \"Argument pointers cannot be nullptr\");\n  std::string Argv0((*argv)[0]);\n  EF = new ExternalFunctions();\n  if (EF->LLVMFuzzerInitialize)\n    EF->LLVMFuzzerInitialize(argc, argv);\n  const Vector<std::string> Args(*argv, *argv + *argc);\n  assert(!Args.empty());\n  ProgName = new std::string(Args[0]);\n  if (Argv0 != *ProgName) {\n    Printf(\"ERROR: argv[0] has been modified in LLVMFuzzerInitialize\\n\");\n    exit(1);\n  }\n  ParseFlags(Args);\n  if (Flags.help) {\n    PrintHelp();\n    return 0;\n  }\n\n  if (Flags.close_fd_mask & 2)\n    DupAndCloseStderr();\n  if (Flags.close_fd_mask & 1)\n    CloseStdout();\n\n  if (Flags.jobs > 0 && Flags.workers == 0) {\n    Flags.workers = std::min(NumberOfCpuCores() / 2, Flags.jobs);\n    if (Flags.workers > 1)\n      Printf(\"Running %u workers\\n\", Flags.workers);\n  }\n\n  if (Flags.workers > 0 && Flags.jobs > 0)\n    return RunInMultipleProcesses(Args, Flags.workers, Flags.jobs);\n\n  FuzzingOptions Options;\n  Options.Verbosity = Flags.verbosity;\n  Options.MaxLen = Flags.max_len;\n  Options.ExperimentalLenControl = Flags.experimental_len_control;\n  Options.UnitTimeoutSec = Flags.timeout;\n  Options.ErrorExitCode = Flags.error_exitcode;\n  Options.TimeoutExitCode = Flags.timeout_exitcode;\n  Options.MaxTotalTimeSec = Flags.max_total_time;\n  Options.DoCrossOver = Flags.cross_over;\n  Options.MutateDepth = Flags.mutate_depth;\n  Options.UseCounters = Flags.use_counters;\n  Options.UseIndirCalls = Flags.use_indir_calls;\n  Options.UseMemmem = Flags.use_memmem;\n  Options.UseCmp = Flags.use_cmp;\n  Options.UseValueProfile = Flags.use_value_profile;\n  Options.Shrink = Flags.shrink;\n  Options.ReduceInputs = Flags.reduce_inputs;\n  Options.ShuffleAtStartUp = Flags.shuffle;\n  Options.PreferSmall = Flags.prefer_small;\n  Options.ReloadIntervalSec = Flags.reload;\n  Options.OnlyASCII = Flags.only_ascii;\n  Options.DetectLeaks = Flags.detect_leaks;\n  Options.PurgeAllocatorIntervalSec = Flags.purge_allocator_interval;\n  Options.TraceMalloc = Flags.trace_malloc;\n  Options.RssLimitMb = Flags.rss_limit_mb;\n  if (Flags.runs >= 0)\n    Options.MaxNumberOfRuns = Flags.runs;\n  if (!Inputs->empty() && !Flags.minimize_crash_internal_step)\n    Options.OutputCorpus = (*Inputs)[0];\n  Options.ReportSlowUnits = Flags.report_slow_units;\n  if (Flags.artifact_prefix)\n    Options.ArtifactPrefix = Flags.artifact_prefix;\n  if (Flags.exact_artifact_path)\n    Options.ExactArtifactPath = Flags.exact_artifact_path;\n  Vector<Unit> Dictionary;\n  if (Flags.dict)\n    if (!ParseDictionaryFile(FileToString(Flags.dict), &Dictionary))\n      return 1;\n  if (Flags.verbosity > 0 && !Dictionary.empty())\n    Printf(\"Dictionary: %zd entries\\n\", Dictionary.size());\n  bool DoPlainRun = AllInputsAreFiles();\n  Options.SaveArtifacts =\n      !DoPlainRun || Flags.minimize_crash_internal_step;\n  Options.PrintNewCovPcs = Flags.print_pcs;\n  Options.PrintNewCovFuncs = Flags.print_funcs;\n  Options.PrintFinalStats = Flags.print_final_stats;\n  Options.PrintCorpusStats = Flags.print_corpus_stats;\n  Options.PrintCoverage = Flags.print_coverage;\n  Options.DumpCoverage = Flags.dump_coverage;\n  Options.UseClangCoverage = Flags.use_clang_coverage;\n  Options.UseFeatureFrequency = Flags.use_feature_frequency;\n  if (Flags.exit_on_src_pos)\n    Options.ExitOnSrcPos = Flags.exit_on_src_pos;\n  if (Flags.exit_on_item)\n    Options.ExitOnItem = Flags.exit_on_item;\n\n  unsigned Seed = Flags.seed;\n  // Initialize Seed.\n  if (Seed == 0)\n    Seed =\n        std::chrono::system_clock::now().time_since_epoch().count() + GetPid();\n  if (Flags.verbosity)\n    Printf(\"INFO: Seed: %u\\n\", Seed);\n\n  Random Rand(Seed);\n  auto *MD = new MutationDispatcher(Rand, Options);\n  auto *Corpus = new InputCorpus(Options.OutputCorpus);\n  auto *F = new Fuzzer(Callback, *Corpus, *MD, Options);\n\n  for (auto &U: Dictionary)\n    if (U.size() <= Word::GetMaxSize())\n      MD->AddWordToManualDictionary(Word(U.data(), U.size()));\n\n  StartRssThread(F, Flags.rss_limit_mb);\n\n  Options.HandleAbrt = Flags.handle_abrt;\n  Options.HandleBus = Flags.handle_bus;\n  Options.HandleFpe = Flags.handle_fpe;\n  Options.HandleIll = Flags.handle_ill;\n  Options.HandleInt = Flags.handle_int;\n  Options.HandleSegv = Flags.handle_segv;\n  Options.HandleTerm = Flags.handle_term;\n  Options.HandleXfsz = Flags.handle_xfsz;\n  Options.HandleUsr1 = Flags.handle_usr1;\n  Options.HandleUsr2 = Flags.handle_usr2;\n  SetSignalHandler(Options);\n\n  std::atexit(Fuzzer::StaticExitCallback);\n\n  if (Flags.minimize_crash)\n    return MinimizeCrashInput(Args, Options);\n\n  if (Flags.minimize_crash_internal_step)\n    return MinimizeCrashInputInternalStep(F, Corpus);\n\n  if (Flags.cleanse_crash)\n    return CleanseCrashInput(Args, Options);\n\n  if (auto Name = Flags.run_equivalence_server) {\n    SMR.Destroy(Name);\n    if (!SMR.Create(Name)) {\n       Printf(\"ERROR: can't create shared memory region\\n\");\n      return 1;\n    }\n    Printf(\"INFO: EQUIVALENCE SERVER UP\\n\");\n    while (true) {\n      SMR.WaitClient();\n      size_t Size = SMR.ReadByteArraySize();\n      SMR.WriteByteArray(nullptr, 0);\n      const Unit tmp(SMR.GetByteArray(), SMR.GetByteArray() + Size);\n      F->ExecuteCallback(tmp.data(), tmp.size());\n      SMR.PostServer();\n    }\n    return 0;\n  }\n\n  if (auto Name = Flags.use_equivalence_server) {\n    if (!SMR.Open(Name)) {\n      Printf(\"ERROR: can't open shared memory region\\n\");\n      return 1;\n    }\n    Printf(\"INFO: EQUIVALENCE CLIENT UP\\n\");\n  }\n\n  if (DoPlainRun) {\n    Options.SaveArtifacts = false;\n    int Runs = std::max(1, Flags.runs);\n    Printf(\"%s: Running %zd inputs %d time(s) each.\\n\", ProgName->c_str(),\n           Inputs->size(), Runs);\n    for (auto &Path : *Inputs) {\n      auto StartTime = system_clock::now();\n      Printf(\"Running: %s\\n\", Path.c_str());\n      for (int Iter = 0; Iter < Runs; Iter++)\n        RunOneTest(F, Path.c_str(), Options.MaxLen);\n      auto StopTime = system_clock::now();\n      auto MS = duration_cast<milliseconds>(StopTime - StartTime).count();\n      Printf(\"Executed %s in %zd ms\\n\", Path.c_str(), (long)MS);\n    }\n    Printf(\"***\\n\"\n           \"*** NOTE: fuzzing was not performed, you have only\\n\"\n           \"***       executed the target code on a fixed set of inputs.\\n\"\n           \"***\\n\");\n    F->PrintFinalStats();\n    exit(0);\n  }\n\n  if (Flags.merge) {\n    F->CrashResistantMerge(Args, *Inputs,\n                           Flags.load_coverage_summary,\n                           Flags.save_coverage_summary,\n                           Flags.merge_control_file);\n    exit(0);\n  }\n\n  if (Flags.merge_inner) {\n    const size_t kDefaultMaxMergeLen = 1 << 20;\n    if (Options.MaxLen == 0)\n      F->SetMaxInputLen(kDefaultMaxMergeLen);\n    assert(Flags.merge_control_file);\n    F->CrashResistantMergeInternalStep(Flags.merge_control_file);\n    exit(0);\n  }\n\n  if (Flags.analyze_dict) {\n    size_t MaxLen = INT_MAX;  // Large max length.\n    UnitVector InitialCorpus;\n    for (auto &Inp : *Inputs) {\n      Printf(\"Loading corpus dir: %s\\n\", Inp.c_str());\n      ReadDirToVectorOfUnits(Inp.c_str(), &InitialCorpus, nullptr,\n                             MaxLen, /*ExitOnError=*/false);\n    }\n\n    if (Dictionary.empty() || Inputs->empty()) {\n      Printf(\"ERROR: can't analyze dict without dict and corpus provided\\n\");\n      return 1;\n    }\n    if (AnalyzeDictionary(F, Dictionary, InitialCorpus)) {\n      Printf(\"Dictionary analysis failed\\n\");\n      exit(1);\n    }\n    Printf(\"Dictionary analysis suceeded\\n\");\n    exit(0);\n  }\n\n  F->Loop(*Inputs);\n\n  if (Flags.verbosity)\n    Printf(\"Done %zd runs in %zd second(s)\\n\", F->getTotalNumberOfRuns(),\n           F->secondsSinceProcessStartUp());\n  F->PrintFinalStats();\n\n  exit(0);  // Don't let F destroy itself.\n}\n\nint main(int argc, char **argv) {\n  return fuzzer::FuzzerDriver(&argc, &argv, LLVMFuzzerTestOneInput);\n}\n\n\n// target function\nstatic status\nExtensionObject_decodeBinaryContent(UA_ExtensionObject *dst, const UA_NodeId *typeId) {\n    /* Lookup the datatype */\n    const UA_DataType *type = UA_findDataTypeByBinary(typeId);\n\n    /* Unknown type, just take the binary content */\n    if(!type) {\n        dst->encoding = UA_EXTENSIONOBJECT_ENCODED_BYTESTRING;\n        dst->content.encoded.typeId = *typeId;\n        return ByteString_decodeBinary(&dst->content.encoded.body);\n    }\n\n    /* Allocate memory */\n    dst->content.decoded.data = UA_new(type);\n    if(!dst->content.decoded.data)\n        return UA_STATUSCODE_BADOUTOFMEMORY;\n\n    /* Jump over the length field (TODO: check if the decoded length matches) */\n    g_pos += 4;\n        \n    /* Decode */\n    dst->encoding = UA_EXTENSIONOBJECT_DECODED;\n    dst->content.decoded.type = type;\n    size_t decode_index = type->builtin ? type->typeIndex : UA_BUILTIN_TYPES_COUNT;\n    return decodeBinaryJumpTable[decode_index](dst->content.decoded.data, type);\n}\n",
    "target": 1,
    "idx": 1004346,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic inline int32_t sw32_(const void* pa) {\n  int32_t idest;\n\n  bool little_endian = is_little_endian();\n  if (little_endian) {\n    idest = *(int32_t *)pa;\n  }\n  else {\n#if defined (__GNUC__)\n    return __builtin_bswap32(*(unsigned int *)pa);\n#elif defined (_MSC_VER) /* Visual Studio */\n    return _byteswap_ulong(*(unsigned int *)pa);\n#else\n    uint8_t *dest = (uint8_t *)&idest;\n    dest[0] = pa_[3];\n    dest[1] = pa_[2];\n    dest[2] = pa_[1];\n    dest[3] = pa_[0];\n#endif\n  }\n  return idest;\n}\n\nint frame_get_lazychunk(blosc2_frame_s *frame, int nchunk, uint8_t **chunk, bool *needs_free) {\n  int32_t header_len;\n  int64_t frame_len;\n  int64_t nbytes;\n  int64_t cbytes;\n  int32_t chunksize;\n  int32_t nchunks;\n  int32_t typesize;\n  size_t lazychunk_cbytes;\n  int64_t offset;\n\n  *chunk = NULL;\n  *needs_free = false;\n  int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes, &chunksize, &nchunks,\n                            &typesize, NULL, NULL, NULL, NULL);\n  if (ret < 0) {\n    BLOSC_TRACE_ERROR(\"Unable to get meta info from frame.\");\n    return ret;\n  }\n\n  if (nchunk >= nchunks) {\n    BLOSC_TRACE_ERROR(\"nchunk ('%d') exceeds the number of chunks \"\n                      \"('%d') in frame.\", nchunk, nchunks);\n    return BLOSC2_ERROR_INVALID_PARAM;\n  }\n\n  // Get the offset to nchunk\n  ret = get_coffset(frame, header_len, cbytes, nchunk, &offset);\n  if (ret < 0) {\n    BLOSC_TRACE_ERROR(\"Unable to get offset to chunk %d.\", nchunk);\n    return ret;\n  }\n\n  if (offset < 0) {\n    // Special value\n    lazychunk_cbytes = BLOSC_EXTENDED_HEADER_LENGTH;\n    int rc = frame_special_chunk(offset, chunksize, typesize, chunk,\n                                 (int32_t)lazychunk_cbytes, needs_free);\n    if (rc < 0) {\n      return rc;\n    }\n    goto end;\n  }\n\n  if (frame->cframe == NULL) {\n    // TODO: make this portable across different endianness\n    // Get info for building a lazy chunk\n    size_t chunk_nbytes;\n    size_t chunk_cbytes;\n    size_t chunk_blocksize;\n    uint8_t header[BLOSC_MIN_HEADER_LENGTH];\n    FILE* fp = NULL;\n    if (frame->sframe) {\n      // The chunk is not in the frame\n      fp = sframe_open_chunk(frame->urlpath, offset, \"rb\");\n    }\n    else {\n      fp = fopen(frame->urlpath, \"rb\");\n      fseek(fp, header_len + offset, SEEK_SET);\n    }\n    size_t rbytes = fread(header, 1, BLOSC_MIN_HEADER_LENGTH, fp);\n    if (rbytes != BLOSC_MIN_HEADER_LENGTH) {\n      BLOSC_TRACE_ERROR(\"Cannot read the header for chunk in the frame.\");\n      fclose(fp);\n      return BLOSC2_ERROR_FILE_READ;\n    }\n    blosc_cbuffer_sizes(header, &chunk_nbytes, &chunk_cbytes, &chunk_blocksize);\n    size_t nblocks = chunk_nbytes / chunk_blocksize;\n    size_t leftover_block = chunk_nbytes % chunk_blocksize;\n    nblocks = leftover_block ? nblocks + 1 : nblocks;\n    // Allocate space for the lazy chunk\n    size_t trailer_len = sizeof(int32_t) + sizeof(int64_t) + nblocks * sizeof(int32_t);\n    size_t trailer_offset = BLOSC_EXTENDED_HEADER_LENGTH + nblocks * sizeof(int32_t);\n    lazychunk_cbytes = trailer_offset + trailer_len;\n    *chunk = malloc(lazychunk_cbytes);\n    *needs_free = true;\n    // Read just the full header and bstarts section too (lazy partial length)\n    if (frame->sframe) {\n      fseek(fp, 0, SEEK_SET);\n    }\n    else {\n      fseek(fp, header_len + offset, SEEK_SET);\n    }\n    rbytes = fread(*chunk, 1, trailer_offset, fp);\n    fclose(fp);\n    if (rbytes != trailer_offset) {\n      BLOSC_TRACE_ERROR(\"Cannot read the (lazy) chunk out of the frame.\");\n      return BLOSC2_ERROR_FILE_READ;\n    }\n\n    // Mark chunk as lazy\n    uint8_t* blosc2_flags = *chunk + BLOSC2_CHUNK_BLOSC2_FLAGS;\n    *blosc2_flags |= 0x08U;\n\n    // Add the trailer (currently, nchunk + offset + block_csizes)\n    *(int32_t*)(*chunk + trailer_offset) = nchunk;\n    *(int64_t*)(*chunk + trailer_offset + sizeof(int32_t)) = header_len + offset;\n\n    int32_t* block_csizes = malloc(nblocks * sizeof(int32_t));\n\n    int memcpyed = *(*chunk + BLOSC2_CHUNK_FLAGS) & (uint8_t)BLOSC_MEMCPYED;\n    if (memcpyed) {\n      // When memcpyed the blocksizes are trivial to compute\n      for (int i = 0; i < (int)nblocks; i++) {\n        block_csizes[i] = (int)chunk_blocksize;\n      }\n    }\n    else {\n      // In regular, compressed chunks, we need to sort the bstarts (they can be out\n      // of order because of multi-threading), and get a reverse index too.\n      memcpy(block_csizes, *chunk + BLOSC_EXTENDED_HEADER_LENGTH, nblocks * sizeof(int32_t));\n      // Helper structure to keep track of original indexes\n      struct csize_idx *csize_idx = malloc(nblocks * sizeof(struct csize_idx));\n      for (int n = 0; n < (int)nblocks; n++) {\n        csize_idx[n].val = block_csizes[n];\n        csize_idx[n].idx = n;\n      }\n      qsort(csize_idx, nblocks, sizeof(struct csize_idx), &sort_offset);\n      // Compute the actual csizes\n      int idx;\n      for (int n = 0; n < (int)nblocks - 1; n++) {\n        idx = csize_idx[n].idx;\n        block_csizes[idx] = csize_idx[n + 1].val - csize_idx[n].val;\n      }\n      idx = csize_idx[nblocks - 1].idx;\n      block_csizes[idx] = (int)chunk_cbytes - csize_idx[nblocks - 1].val;\n      free(csize_idx);\n    }\n    // Copy the csizes at the end of the trailer\n    void *trailer_csizes = *chunk + lazychunk_cbytes - nblocks * sizeof(int32_t);\n    memcpy(trailer_csizes, block_csizes, nblocks * sizeof(int32_t));\n    free(block_csizes);\n  } else {\n    // The chunk is in memory and just one pointer away\n    *chunk = frame->cframe + header_len + offset;\n    lazychunk_cbytes = sw32_(*chunk + BLOSC2_CHUNK_CBYTES);\n  }\n\n  end:\n  return (int)lazychunk_cbytes;\n}\n\nint frame_decompress_chunk(blosc2_context *dctx, blosc2_frame_s* frame, int nchunk, void *dest, int32_t nbytes) {\n  uint8_t* src;\n  bool needs_free;\n  int chunk_cbytes;\n  if (frame->sframe) {\n    chunk_cbytes = frame_get_chunk(frame, nchunk, &src, &needs_free);\n  }\n  else {\n    // Use a lazychunk here in order to do a potential parallel read.\n    chunk_cbytes = frame_get_lazychunk(frame, nchunk, &src, &needs_free);\n  }\n  if (chunk_cbytes < 0) {\n    BLOSC_TRACE_ERROR(\"Cannot get the chunk in position %d.\", nchunk);\n    return BLOSC2_ERROR_DATA;\n  }\n  if (chunk_cbytes < (signed)sizeof(int32_t)) {\n    /* Not enough input to read `nbytes` */\n    return BLOSC2_ERROR_READ_BUFFER;\n  }\n\n  /* Create a buffer for destination */\n  int32_t nbytes_ = sw32_(src + BLOSC2_CHUNK_NBYTES);\n  if (nbytes_ > (int32_t)nbytes) {\n    BLOSC_TRACE_ERROR(\"Not enough space for decompressing in dest.\");\n    return BLOSC2_ERROR_WRITE_BUFFER;\n  }\n  /* And decompress it */\n  dctx->header_overhead = BLOSC_EXTENDED_HEADER_LENGTH;\n  int32_t chunksize = blosc2_decompress_ctx(dctx, src, chunk_cbytes, dest, nbytes);\n  if (chunksize < 0 || chunksize != nbytes_) {\n    BLOSC_TRACE_ERROR(\"Error in decompressing chunk.\");\n    if (chunksize < 0)\n      return chunksize;\n    return BLOSC2_ERROR_FAILURE;\n  }\n\n  if (needs_free) {\n    free(src);\n  }\n  return (int)chunksize;\n}\n\nint blosc2_schunk_decompress_chunk(blosc2_schunk *schunk, int nchunk,\n                                   void *dest, int32_t nbytes) {\n  int chunksize;\n  blosc2_frame_s* frame = (blosc2_frame_s*)schunk->frame;\n\n  if (frame == NULL) {\n    if (nchunk >= schunk->nchunks) {\n      BLOSC_TRACE_ERROR(\"nchunk ('%d') exceeds the number of chunks \"\n                        \"('%d') in super-chunk.\", nchunk, schunk->nchunks);\n      return BLOSC2_ERROR_INVALID_PARAM;\n    }\n    uint8_t* src = schunk->data[nchunk];\n    if (src == 0) {\n      return 0;\n    }\n\n    int nbytes_ = sw32_(src + BLOSC2_CHUNK_NBYTES);\n    if (nbytes < nbytes_) {\n      BLOSC_TRACE_ERROR(\"Buffer size is too small for the decompressed buffer \"\n                        \"('%d' bytes, but '%d' are needed).\", nbytes, nbytes_);\n      return BLOSC2_ERROR_INVALID_PARAM;\n    }\n    int cbytes = sw32_(src + BLOSC2_CHUNK_CBYTES);\n    chunksize = blosc2_decompress_ctx(schunk->dctx, src, cbytes, dest, nbytes);\n    if (chunksize < 0 || chunksize != nbytes_) {\n      BLOSC_TRACE_ERROR(\"Error in decompressing chunk.\");\n      if (chunksize < 0)\n        return chunksize;\n      return BLOSC2_ERROR_FAILURE;\n    }\n  } else {\n    chunksize = frame_decompress_chunk(schunk->dctx, frame, nchunk, dest, nbytes);\n    if (chunksize < 0) {\n      return chunksize;\n    }\n  }\n  return chunksize;\n}\n\n\n// target function\nint get_coffset(blosc2_frame_s* frame, int32_t header_len, int64_t cbytes, int32_t nchunk, int64_t *offset) {\n  // Get the offset to nchunk\n  uint8_t *coffsets = get_coffsets(frame, header_len, cbytes, NULL);\n  if (coffsets == NULL) {\n    BLOSC_TRACE_ERROR(\"Cannot get the offset for chunk %d for the frame.\", nchunk);\n    return BLOSC2_ERROR_DATA;\n  }\n\n  // Get the 64-bit offset\n  int rc = blosc_getitem(coffsets, nchunk, 1, offset);\n  if (rc < 0) {\n    BLOSC_TRACE_ERROR(\"Problems retrieving a chunk offset.\");\n  }\n  return rc;\n}\n",
    "target": 1,
    "idx": 1031120,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "// context\nstatic xmlNodePtr\nxmlStaticCopyNode(xmlNodePtr node, xmlDocPtr doc, xmlNodePtr parent,\n                  int extended) {\n    xmlNodePtr ret;\n\n    if (node == NULL) return(NULL);\n    switch (node->type) {\n        case XML_TEXT_NODE:\n        case XML_CDATA_SECTION_NODE:\n        case XML_ELEMENT_NODE:\n        case XML_DOCUMENT_FRAG_NODE:\n        case XML_ENTITY_REF_NODE:\n        case XML_ENTITY_NODE:\n        case XML_PI_NODE:\n        case XML_COMMENT_NODE:\n        case XML_XINCLUDE_START:\n        case XML_XINCLUDE_END:\n\t    break;\n        case XML_ATTRIBUTE_NODE:\n\t\treturn((xmlNodePtr) xmlCopyPropInternal(doc, parent, (xmlAttrPtr) node));\n        case XML_NAMESPACE_DECL:\n\t    return((xmlNodePtr) xmlCopyNamespaceList((xmlNsPtr) node));\n\n        case XML_DOCUMENT_NODE:\n        case XML_HTML_DOCUMENT_NODE:\n#ifdef LIBXML_DOCB_ENABLED\n        case XML_DOCB_DOCUMENT_NODE:\n#endif\n#ifdef LIBXML_TREE_ENABLED\n\t    return((xmlNodePtr) xmlCopyDoc((xmlDocPtr) node, extended));\n#endif /* LIBXML_TREE_ENABLED */\n        case XML_DOCUMENT_TYPE_NODE:\n        case XML_NOTATION_NODE:\n        case XML_DTD_NODE:\n        case XML_ELEMENT_DECL:\n        case XML_ATTRIBUTE_DECL:\n        case XML_ENTITY_DECL:\n            return(NULL);\n    }\n\n    /*\n     * Allocate a new node and fill the fields.\n     */\n    ret = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));\n    if (ret == NULL) {\n\txmlTreeErrMemory(\"copying node\");\n\treturn(NULL);\n    }\n    memset(ret, 0, sizeof(xmlNode));\n    ret->type = node->type;\n\n    ret->doc = doc;\n    ret->parent = parent;\n    if (node->name == xmlStringText)\n\tret->name = xmlStringText;\n    else if (node->name == xmlStringTextNoenc)\n\tret->name = xmlStringTextNoenc;\n    else if (node->name == xmlStringComment)\n\tret->name = xmlStringComment;\n    else if (node->name != NULL) {\n        if ((doc != NULL) && (doc->dict != NULL))\n\t    ret->name = xmlDictLookup(doc->dict, node->name, -1);\n\telse\n\t    ret->name = xmlStrdup(node->name);\n    }\n    if ((node->type != XML_ELEMENT_NODE) &&\n\t(node->content != NULL) &&\n\t(node->type != XML_ENTITY_REF_NODE) &&\n\t(node->type != XML_XINCLUDE_END) &&\n\t(node->type != XML_XINCLUDE_START)) {\n\tret->content = xmlStrdup(node->content);\n    }else{\n      if (node->type == XML_ELEMENT_NODE)\n        ret->line = node->line;\n    }\n    if (parent != NULL) {\n\txmlNodePtr tmp;\n\n\t/*\n\t * this is a tricky part for the node register thing:\n\t * in case ret does get coalesced in xmlAddChild\n\t * the deregister-node callback is called; so we register ret now already\n\t */\n\tif ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))\n\t    xmlRegisterNodeDefaultValue((xmlNodePtr)ret);\n\n        tmp = xmlAddChild(parent, ret);\n\t/* node could have coalesced */\n\tif (tmp != ret)\n\t    return(tmp);\n    }\n\n    if (!extended)\n\tgoto out;\n    if (((node->type == XML_ELEMENT_NODE) ||\n         (node->type == XML_XINCLUDE_START)) && (node->nsDef != NULL))\n        ret->nsDef = xmlCopyNamespaceList(node->nsDef);\n\n    if (node->ns != NULL) {\n        xmlNsPtr ns;\n\n\tns = xmlSearchNs(doc, ret, node->ns->prefix);\n\tif (ns == NULL) {\n\t    /*\n\t     * Humm, we are copying an element whose namespace is defined\n\t     * out of the new tree scope. Search it in the original tree\n\t     * and add it at the top of the new tree\n\t     */\n\t    ns = xmlSearchNs(node->doc, node, node->ns->prefix);\n\t    if (ns != NULL) {\n\t        xmlNodePtr root = ret;\n\n\t\twhile (root->parent != NULL) root = root->parent;\n\t\tret->ns = xmlNewNs(root, ns->href, ns->prefix);\n\t\t} else {\n\t\t\tret->ns = xmlNewReconciledNs(doc, ret, node->ns);\n\t    }\n\t} else {\n\t    /*\n\t     * reference the existing namespace definition in our own tree.\n\t     */\n\t    ret->ns = ns;\n\t}\n    }\n    if (((node->type == XML_ELEMENT_NODE) ||\n         (node->type == XML_XINCLUDE_START)) && (node->properties != NULL))\n        ret->properties = xmlCopyPropList(ret, node->properties);\n    if (node->type == XML_ENTITY_REF_NODE) {\n\tif ((doc == NULL) || (node->doc != doc)) {\n\t    /*\n\t     * The copied node will go into a separate document, so\n\t     * to avoid dangling references to the ENTITY_DECL node\n\t     * we cannot keep the reference. Try to find it in the\n\t     * target document.\n\t     */\n\t    ret->children = (xmlNodePtr) xmlGetDocEntity(doc, ret->name);\n\t} else {\n            ret->children = node->children;\n\t}\n\tret->last = ret->children;\n    } else if ((node->children != NULL) && (extended != 2)) {\n        ret->children = xmlStaticCopyNodeList(node->children, doc, ret);\n\tUPDATE_LAST_CHILD_AND_PARENT(ret)\n    }\n\nout:\n    /* if parent != NULL we already registered the node above */\n    if ((parent == NULL) &&\n        ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue)))\n\txmlRegisterNodeDefaultValue((xmlNodePtr)ret);\n    return(ret);\n}\n\nxmlNodePtr\nxmlCopyNode(xmlNodePtr node, int extended) {\n    xmlNodePtr ret;\n\n    ret = xmlStaticCopyNode(node, NULL, NULL, extended);\n    return(ret);\n}\n\nstatic int\nxmlXIncludeLoadTxt(xmlXIncludeCtxtPtr ctxt, const xmlChar *url, int nr) {\n    xmlParserInputBufferPtr buf;\n    xmlNodePtr node;\n    xmlURIPtr uri;\n    xmlChar *URL;\n    int i;\n    xmlChar *encoding = NULL;\n    xmlCharEncoding enc = (xmlCharEncoding) 0;\n    xmlParserCtxtPtr pctxt;\n    xmlParserInputPtr inputStream;\n    int xinclude_multibyte_fallback_used = 0;\n\n    /* Don't read from stdin. */\n    if (xmlStrcmp(url, BAD_CAST \"-\") == 0)\n        url = BAD_CAST \"./-\";\n\n    /*\n     * Check the URL and remove any fragment identifier\n     */\n    uri = xmlParseURI((const char *)url);\n    if (uri == NULL) {\n\txmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref, XML_XINCLUDE_HREF_URI,\n\t               \"invalid value URI %s\\n\", url);\n\treturn(-1);\n    }\n    if (uri->fragment != NULL) {\n\txmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref, XML_XINCLUDE_TEXT_FRAGMENT,\n\t               \"fragment identifier forbidden for text: %s\\n\",\n\t\t       (const xmlChar *) uri->fragment);\n\txmlFreeURI(uri);\n\treturn(-1);\n    }\n    URL = xmlSaveUri(uri);\n    xmlFreeURI(uri);\n    if (URL == NULL) {\n\txmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref, XML_XINCLUDE_HREF_URI,\n\t               \"invalid value URI %s\\n\", url);\n\treturn(-1);\n    }\n\n    /*\n     * Handling of references to the local document are done\n     * directly through ctxt->doc.\n     */\n    if (URL[0] == 0) {\n\txmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t               XML_XINCLUDE_TEXT_DOCUMENT,\n\t\t       \"text serialization of document not available\\n\", NULL);\n\txmlFree(URL);\n\treturn(-1);\n    }\n\n    /*\n     * Prevent reloading twice the document.\n     */\n    for (i = 0; i < ctxt->txtNr; i++) {\n\tif (xmlStrEqual(URL, ctxt->txturlTab[i])) {\n            node = xmlNewText(ctxt->txtTab[i]);\n\t    goto loaded;\n\t}\n    }\n    /*\n     * Try to get the encoding if available\n     */\n    if ((ctxt->incTab[nr] != NULL) && (ctxt->incTab[nr]->ref != NULL)) {\n\tencoding = xmlGetProp(ctxt->incTab[nr]->ref, XINCLUDE_PARSE_ENCODING);\n    }\n    if (encoding != NULL) {\n\t/*\n\t * TODO: we should not have to remap to the xmlCharEncoding\n\t *       predefined set, a better interface than\n\t *       xmlParserInputBufferCreateFilename should allow any\n\t *       encoding supported by iconv\n\t */\n        enc = xmlParseCharEncoding((const char *) encoding);\n\tif (enc == XML_CHAR_ENCODING_ERROR) {\n\t    xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t                   XML_XINCLUDE_UNKNOWN_ENCODING,\n\t\t\t   \"encoding %s not supported\\n\", encoding);\n\t    xmlFree(encoding);\n\t    xmlFree(URL);\n\t    return(-1);\n\t}\n\txmlFree(encoding);\n    }\n\n    /*\n     * Load it.\n     */\n    pctxt = xmlNewParserCtxt();\n    inputStream = xmlLoadExternalEntity((const char*)URL, NULL, pctxt);\n    if(inputStream == NULL) {\n\txmlFreeParserCtxt(pctxt);\n\txmlFree(URL);\n\treturn(-1);\n    }\n    buf = inputStream->buf;\n    if (buf == NULL) {\n\txmlFreeInputStream (inputStream);\n\txmlFreeParserCtxt(pctxt);\n\txmlFree(URL);\n\treturn(-1);\n    }\n    if (buf->encoder)\n\txmlCharEncCloseFunc(buf->encoder);\n    buf->encoder = xmlGetCharEncodingHandler(enc);\n    node = xmlNewText(NULL);\n\n    /*\n     * Scan all chars from the resource and add the to the node\n     */\nxinclude_multibyte_fallback:\n    while (xmlParserInputBufferRead(buf, 128) > 0) {\n\tint len;\n\tconst xmlChar *content;\n\n\tcontent = xmlBufContent(buf->buffer);\n\tlen = xmlBufLength(buf->buffer);\n\tfor (i = 0;i < len;) {\n\t    int cur;\n\t    int l;\n\n\t    cur = xmlStringCurrentChar(NULL, &content[i], &l);\n\t    if (!IS_CHAR(cur)) {\n\t\t/* Handle split multibyte char at buffer boundary */\n\t\tif (((len - i) < 4) && (!xinclude_multibyte_fallback_used)) {\n\t\t    xinclude_multibyte_fallback_used = 1;\n\t\t    xmlBufShrink(buf->buffer, i);\n\t\t    goto xinclude_multibyte_fallback;\n\t\t} else {\n\t\t    xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t\t\t\t   XML_XINCLUDE_INVALID_CHAR,\n\t\t\t\t   \"%s contains invalid char\\n\", URL);\n\t\t    xmlFreeParserCtxt(pctxt);\n\t\t    xmlFreeParserInputBuffer(buf);\n\t\t    xmlFree(URL);\n\t\t    return(-1);\n\t\t}\n\t    } else {\n\t\txinclude_multibyte_fallback_used = 0;\n\t\txmlNodeAddContentLen(node, &content[i], l);\n\t    }\n\t    i += l;\n\t}\n\txmlBufShrink(buf->buffer, len);\n    }\n    xmlFreeParserCtxt(pctxt);\n    xmlXIncludeAddTxt(ctxt, node->content, URL);\n    xmlFreeInputStream(inputStream);\n\nloaded:\n    /*\n     * Add the element as the replacement copy.\n     */\n    ctxt->incTab[nr]->inc = node;\n    xmlFree(URL);\n    return(0);\n}\n\nstatic int\nxmlXIncludeLoadNode(xmlXIncludeCtxtPtr ctxt, int nr) {\n    xmlNodePtr cur;\n    xmlChar *href;\n    xmlChar *parse;\n    xmlChar *base;\n    xmlChar *oldBase;\n    xmlChar *URI;\n    int xml = 1; /* default Issue 64 */\n    int ret;\n\n    if (ctxt == NULL)\n\treturn(-1);\n    if ((nr < 0) || (nr >= ctxt->incNr))\n\treturn(-1);\n    cur = ctxt->incTab[nr]->ref;\n    if (cur == NULL)\n\treturn(-1);\n\n    /*\n     * read the attributes\n     */\n    href = xmlXIncludeGetProp(ctxt, cur, XINCLUDE_HREF);\n    if (href == NULL) {\n\thref = xmlStrdup(BAD_CAST \"\"); /* @@@@ href is now optional */\n\tif (href == NULL)\n\t    return(-1);\n    }\n    parse = xmlXIncludeGetProp(ctxt, cur, XINCLUDE_PARSE);\n    if (parse != NULL) {\n\tif (xmlStrEqual(parse, XINCLUDE_PARSE_XML))\n\t    xml = 1;\n\telse if (xmlStrEqual(parse, XINCLUDE_PARSE_TEXT))\n\t    xml = 0;\n\telse {\n\t    xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t                   XML_XINCLUDE_PARSE_VALUE,\n\t\t\t   \"invalid value %s for 'parse'\\n\", parse);\n\t    if (href != NULL)\n\t\txmlFree(href);\n\t    if (parse != NULL)\n\t\txmlFree(parse);\n\t    return(-1);\n\t}\n    }\n\n    /*\n     * compute the URI\n     */\n    base = xmlNodeGetBase(ctxt->doc, cur);\n    if (base == NULL) {\n\tURI = xmlBuildURI(href, ctxt->doc->URL);\n    } else {\n\tURI = xmlBuildURI(href, base);\n    }\n    if (URI == NULL) {\n\txmlChar *escbase;\n\txmlChar *eschref;\n\t/*\n\t * Some escaping may be needed\n\t */\n\tescbase = xmlURIEscape(base);\n\teschref = xmlURIEscape(href);\n\tURI = xmlBuildURI(eschref, escbase);\n\tif (escbase != NULL)\n\t    xmlFree(escbase);\n\tif (eschref != NULL)\n\t    xmlFree(eschref);\n    }\n    if (URI == NULL) {\n\txmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t               XML_XINCLUDE_HREF_URI, \"failed build URL\\n\", NULL);\n\tif (parse != NULL)\n\t    xmlFree(parse);\n\tif (href != NULL)\n\t    xmlFree(href);\n\tif (base != NULL)\n\t    xmlFree(base);\n\treturn(-1);\n    }\n#ifdef DEBUG_XINCLUDE\n    xmlGenericError(xmlGenericErrorContext, \"parse: %s\\n\",\n\t    xml ? \"xml\": \"text\");\n    xmlGenericError(xmlGenericErrorContext, \"URI: %s\\n\", URI);\n#endif\n\n    /*\n     * Save the base for this include (saving the current one)\n     */\n    oldBase = ctxt->base;\n    ctxt->base = base;\n\n    if (xml) {\n\tret = xmlXIncludeLoadDoc(ctxt, URI, nr);\n\t/* xmlXIncludeGetFragment(ctxt, cur, URI); */\n    } else {\n\tret = xmlXIncludeLoadTxt(ctxt, URI, nr);\n    }\n\n    /*\n     * Restore the original base before checking for fallback\n     */\n    ctxt->base = oldBase;\n\n    if (ret < 0) {\n\txmlNodePtr children;\n\n\t/*\n\t * Time to try a fallback if available\n\t */\n#ifdef DEBUG_XINCLUDE\n\txmlGenericError(xmlGenericErrorContext, \"error looking for fallback\\n\");\n#endif\n\tchildren = cur->children;\n\twhile (children != NULL) {\n\t    if ((children->type == XML_ELEMENT_NODE) &&\n\t\t(children->ns != NULL) &&\n\t\t(xmlStrEqual(children->name, XINCLUDE_FALLBACK)) &&\n\t\t((xmlStrEqual(children->ns->href, XINCLUDE_NS)) ||\n\t\t (xmlStrEqual(children->ns->href, XINCLUDE_OLD_NS)))) {\n\t\tret = xmlXIncludeLoadFallback(ctxt, children, nr);\n\t\tbreak;\n\t    }\n\t    children = children->next;\n\t}\n    }\n    if (ret < 0) {\n\txmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t               XML_XINCLUDE_NO_FALLBACK,\n\t\t       \"could not load %s, and no fallback was found\\n\",\n\t\t       URI);\n    }\n\n    /*\n     * Cleanup\n     */\n    if (URI != NULL)\n\txmlFree(URI);\n    if (parse != NULL)\n\txmlFree(parse);\n    if (href != NULL)\n\txmlFree(href);\n    if (base != NULL)\n\txmlFree(base);\n    return(0);\n}\n\nstatic int\nxmlXIncludeDoProcess(xmlXIncludeCtxtPtr ctxt, xmlDocPtr doc, xmlNodePtr tree,\n                     int skipRoot) {\n    xmlNodePtr cur;\n    int ret = 0;\n    int i, start;\n\n    if ((doc == NULL) || (tree == NULL) || (tree->type == XML_NAMESPACE_DECL))\n\treturn(-1);\n    if ((skipRoot) && (tree->children == NULL))\n        return(-1);\n    if (ctxt == NULL)\n\treturn(-1);\n\n    if (doc->URL != NULL) {\n\tret = xmlXIncludeURLPush(ctxt, doc->URL);\n\tif (ret < 0)\n\t    return(-1);\n    }\n    start = ctxt->incNr;\n\n    /*\n     * TODO: The phases must run separately for recursive inclusions.\n     *\n     * - Phase 1 should start with top-level XInclude nodes, load documents,\n     *   execute XPointer expressions, then process only the result nodes\n     *   (not whole document, see bug #324081) and only for phase 1\n     *   recursively. We will need a backreference from xmlNodes to\n     *   xmlIncludeRefs to detect references that were already visited.\n     *   This can also be used for proper cycle detection, see bug #344240.\n     *\n     * - Phase 2 should visit all top-level XInclude nodes and expand\n     *   possible subreferences in the replacement recursively.\n     *\n     * - Phase 3 should finally replace the top-level XInclude nodes.\n     *   It could also be run together with phase 2.\n     */\n\n    /*\n     * First phase: lookup the elements in the document\n     */\n    if (skipRoot)\n        cur = tree->children;\n    else\n        cur = tree;\n    do {\n\t/* TODO: need to work on entities -> stack */\n        if (xmlXIncludeTestNode(ctxt, cur) == 1) {\n#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n            /*\n             * Avoid superlinear expansion by limiting the total number\n             * of replacements.\n             */\n            if (ctxt->incTotal >= 20)\n                return(-1);\n#endif\n            ctxt->incTotal++;\n            xmlXIncludePreProcessNode(ctxt, cur);\n        } else if ((cur->children != NULL) &&\n                   (cur->children->type != XML_ENTITY_DECL) &&\n                   (cur->children->type != XML_XINCLUDE_START) &&\n                   (cur->children->type != XML_XINCLUDE_END)) {\n            cur = cur->children;\n            continue;\n        }\n        do {\n            if (cur == tree)\n                break;\n            if (cur->next != NULL) {\n                cur = cur->next;\n                break;\n            }\n            cur = cur->parent;\n        } while (cur != NULL);\n    } while ((cur != NULL) && (cur != tree));\n\n    /*\n     * Second Phase : collect the infosets fragments\n     */\n    for (i = start;i < ctxt->incNr; i++) {\n        xmlXIncludeLoadNode(ctxt, i);\n\tret++;\n    }\n\n    /*\n     * Third phase: extend the original document infoset.\n     *\n     * Originally we bypassed the inclusion if there were any errors\n     * encountered on any of the XIncludes.  A bug was raised (bug\n     * 132588) requesting that we output the XIncludes without error,\n     * so the check for inc!=NULL || xptr!=NULL was put in.  This may\n     * give some other problems in the future, but for now it seems to\n     * work ok.\n     *\n     */\n    for (i = ctxt->incBase;i < ctxt->incNr; i++) {\n\tif ((ctxt->incTab[i]->inc != NULL) ||\n\t    (ctxt->incTab[i]->emptyFb != 0))\t/* (empty fallback) */\n\t    xmlXIncludeIncludeNode(ctxt, i);\n    }\n\n    if (doc->URL != NULL)\n\txmlXIncludeURLPop(ctxt);\n    return(ret);\n}\n\nint\nxmlXIncludeProcessNode(xmlXIncludeCtxtPtr ctxt, xmlNodePtr node) {\n    int ret = 0;\n\n    if ((node == NULL) || (node->type == XML_NAMESPACE_DECL) ||\n        (node->doc == NULL) || (ctxt == NULL))\n\treturn(-1);\n    ret = xmlXIncludeDoProcess(ctxt, node->doc, node, 0);\n    if ((ret >= 0) && (ctxt->nbErrors > 0))\n\tret = -1;\n    return(ret);\n}\n\nint\nxmlTextReaderRead(xmlTextReaderPtr reader) {\n    int val, olddepth = 0;\n    xmlTextReaderState oldstate = XML_TEXTREADER_START;\n    xmlNodePtr oldnode = NULL;\n\n\n    if (reader == NULL)\n\treturn(-1);\n    reader->curnode = NULL;\n    if (reader->doc != NULL)\n        return(xmlTextReaderReadTree(reader));\n    if (reader->ctxt == NULL)\n\treturn(-1);\n\n#ifdef DEBUG_READER\n    fprintf(stderr, \"\\nREAD \");\n    DUMP_READER\n#endif\n    if (reader->mode == XML_TEXTREADER_MODE_INITIAL) {\n\treader->mode = XML_TEXTREADER_MODE_INTERACTIVE;\n\t/*\n\t * Initial state\n\t */\n\tdo {\n\t    val = xmlTextReaderPushData(reader);\n\t\tif (val < 0){\n\t\t\treader->mode = XML_TEXTREADER_MODE_ERROR;\n\t\t\treader->state = XML_TEXTREADER_ERROR;\n\t\treturn(-1);\n\t\t}\n\t} while ((reader->ctxt->node == NULL) &&\n\t\t ((reader->mode != XML_TEXTREADER_MODE_EOF) &&\n\t\t  (reader->state != XML_TEXTREADER_DONE)));\n\tif (reader->ctxt->node == NULL) {\n\t    if (reader->ctxt->myDoc != NULL) {\n\t\treader->node = reader->ctxt->myDoc->children;\n\t    }\n\t    if (reader->node == NULL){\n\t\t\treader->mode = XML_TEXTREADER_MODE_ERROR;\n\t\t\treader->state = XML_TEXTREADER_ERROR;\n\t\treturn(-1);\n\t\t}\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t} else {\n\t    if (reader->ctxt->myDoc != NULL) {\n\t\treader->node = reader->ctxt->myDoc->children;\n\t    }\n\t    if (reader->node == NULL)\n\t\treader->node = reader->ctxt->nodeTab[0];\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t}\n\treader->depth = 0;\n\treader->ctxt->parseMode = XML_PARSE_READER;\n\tgoto node_found;\n    }\n    oldstate = reader->state;\n    olddepth = reader->ctxt->nodeNr;\n    oldnode = reader->node;\n\nget_next_node:\n    if (reader->node == NULL) {\n\tif (reader->mode == XML_TEXTREADER_MODE_EOF)\n\t    return(0);\n\telse\n\t    return(-1);\n    }\n\n    /*\n     * If we are not backtracking on ancestors or examined nodes,\n     * that the parser didn't finished or that we aren't at the end\n     * of stream, continue processing.\n     */\n    while ((reader->node != NULL) && (reader->node->next == NULL) &&\n\t   (reader->ctxt->nodeNr == olddepth) &&\n           ((oldstate == XML_TEXTREADER_BACKTRACK) ||\n            (reader->node->children == NULL) ||\n\t    (reader->node->type == XML_ENTITY_REF_NODE) ||\n\t    ((reader->node->children != NULL) &&\n\t     (reader->node->children->type == XML_TEXT_NODE) &&\n\t     (reader->node->children->next == NULL)) ||\n\t    (reader->node->type == XML_DTD_NODE) ||\n\t    (reader->node->type == XML_DOCUMENT_NODE) ||\n\t    (reader->node->type == XML_HTML_DOCUMENT_NODE)) &&\n\t   ((reader->ctxt->node == NULL) ||\n\t    (reader->ctxt->node == reader->node) ||\n\t    (reader->ctxt->node == reader->node->parent)) &&\n\t   (reader->ctxt->instate != XML_PARSER_EOF)) {\n\tval = xmlTextReaderPushData(reader);\n\tif (val < 0){\n\t\treader->mode = XML_TEXTREADER_MODE_ERROR;\n\t\treader->state = XML_TEXTREADER_ERROR;\n\t    return(-1);\n\t}\n\tif (reader->node == NULL)\n\t    goto node_end;\n    }\n    if (oldstate != XML_TEXTREADER_BACKTRACK) {\n\tif ((reader->node->children != NULL) &&\n\t    (reader->node->type != XML_ENTITY_REF_NODE) &&\n\t    (reader->node->type != XML_XINCLUDE_START) &&\n\t    (reader->node->type != XML_DTD_NODE)) {\n\t    reader->node = reader->node->children;\n\t    reader->depth++;\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t    goto node_found;\n\t}\n    }\n    if (reader->node->next != NULL) {\n\tif ((oldstate == XML_TEXTREADER_ELEMENT) &&\n            (reader->node->type == XML_ELEMENT_NODE) &&\n\t    (reader->node->children == NULL) &&\n\t    ((reader->node->extra & NODE_IS_EMPTY) == 0)\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    && (reader->in_xinclude <= 0)\n#endif\n\t    ) {\n\t    reader->state = XML_TEXTREADER_END;\n\t    goto node_found;\n\t}\n#ifdef LIBXML_REGEXP_ENABLED\n\tif ((reader->validate) &&\n\t    (reader->node->type == XML_ELEMENT_NODE))\n\t    xmlTextReaderValidatePop(reader);\n#endif /* LIBXML_REGEXP_ENABLED */\n        if ((reader->preserves > 0) &&\n\t    (reader->node->extra & NODE_IS_SPRESERVED))\n\t    reader->preserves--;\n\treader->node = reader->node->next;\n\treader->state = XML_TEXTREADER_ELEMENT;\n\n\t/*\n\t * Cleanup of the old node\n\t */\n\tif ((reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    (reader->in_xinclude == 0) &&\n#endif\n\t    (reader->entNr == 0) &&\n\t    (reader->node->prev != NULL) &&\n            (reader->node->prev->type != XML_DTD_NODE)) {\n\t    xmlNodePtr tmp = reader->node->prev;\n\t    if ((tmp->extra & NODE_IS_PRESERVED) == 0) {\n                if (oldnode == tmp)\n                    oldnode = NULL;\n\t\txmlUnlinkNode(tmp);\n\t\txmlTextReaderFreeNode(reader, tmp);\n\t    }\n\t}\n\n\tgoto node_found;\n    }\n    if ((oldstate == XML_TEXTREADER_ELEMENT) &&\n\t(reader->node->type == XML_ELEMENT_NODE) &&\n\t(reader->node->children == NULL) &&\n\t((reader->node->extra & NODE_IS_EMPTY) == 0)) {;\n\treader->state = XML_TEXTREADER_END;\n\tgoto node_found;\n    }\n#ifdef LIBXML_REGEXP_ENABLED\n    if ((reader->validate != XML_TEXTREADER_NOT_VALIDATE) && (reader->node->type == XML_ELEMENT_NODE))\n\txmlTextReaderValidatePop(reader);\n#endif /* LIBXML_REGEXP_ENABLED */\n    if ((reader->preserves > 0) &&\n\t(reader->node->extra & NODE_IS_SPRESERVED))\n\treader->preserves--;\n    reader->node = reader->node->parent;\n    if ((reader->node == NULL) ||\n\t(reader->node->type == XML_DOCUMENT_NODE) ||\n#ifdef LIBXML_DOCB_ENABLED\n\t(reader->node->type == XML_DOCB_DOCUMENT_NODE) ||\n#endif\n\t(reader->node->type == XML_HTML_DOCUMENT_NODE)) {\n\tif (reader->mode != XML_TEXTREADER_MODE_EOF) {\n\t    val = xmlParseChunk(reader->ctxt, \"\", 0, 1);\n\t    reader->state = XML_TEXTREADER_DONE;\n\t    if (val != 0)\n\t        return(-1);\n\t}\n\treader->node = NULL;\n\treader->depth = -1;\n\n\t/*\n\t * Cleanup of the old node\n\t */\n\tif ((oldnode != NULL) && (reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    (reader->in_xinclude == 0) &&\n#endif\n\t    (reader->entNr == 0) &&\n\t    (oldnode->type != XML_DTD_NODE) &&\n\t    ((oldnode->extra & NODE_IS_PRESERVED) == 0)) {\n\t    xmlUnlinkNode(oldnode);\n\t    xmlTextReaderFreeNode(reader, oldnode);\n\t}\n\n\tgoto node_end;\n    }\n    if ((reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n        (reader->in_xinclude == 0) &&\n#endif\n\t(reader->entNr == 0) &&\n        (reader->node->last != NULL) &&\n        ((reader->node->last->extra & NODE_IS_PRESERVED) == 0)) {\n\txmlNodePtr tmp = reader->node->last;\n\txmlUnlinkNode(tmp);\n\txmlTextReaderFreeNode(reader, tmp);\n    }\n    reader->depth--;\n    reader->state = XML_TEXTREADER_BACKTRACK;\n\nnode_found:\n    DUMP_READER\n\n    /*\n     * If we are in the middle of a piece of CDATA make sure it's finished\n     */\n    if ((reader->node != NULL) &&\n        (reader->node->next == NULL) &&\n        ((reader->node->type == XML_TEXT_NODE) ||\n\t (reader->node->type == XML_CDATA_SECTION_NODE))) {\n            if (xmlTextReaderExpand(reader) == NULL)\n\t        return -1;\n    }\n\n#ifdef LIBXML_XINCLUDE_ENABLED\n    /*\n     * Handle XInclude if asked for\n     */\n    if ((reader->xinclude) && (reader->node != NULL) &&\n\t(reader->node->type == XML_ELEMENT_NODE) &&\n\t(reader->node->ns != NULL) &&\n\t((xmlStrEqual(reader->node->ns->href, XINCLUDE_NS)) ||\n\t (xmlStrEqual(reader->node->ns->href, XINCLUDE_OLD_NS)))) {\n\tif (reader->xincctxt == NULL) {\n\t    reader->xincctxt = xmlXIncludeNewContext(reader->ctxt->myDoc);\n\t    xmlXIncludeSetFlags(reader->xincctxt,\n\t                        reader->parserFlags & (~XML_PARSE_NOXINCNODE));\n\t}\n\t/*\n\t * expand that node and process it\n\t */\n\tif (xmlTextReaderExpand(reader) == NULL)\n\t    return -1;\n\txmlXIncludeProcessNode(reader->xincctxt, reader->node);\n    }\n    if ((reader->node != NULL) && (reader->node->type == XML_XINCLUDE_START)) {\n        reader->in_xinclude++;\n\tgoto get_next_node;\n    }\n    if ((reader->node != NULL) && (reader->node->type == XML_XINCLUDE_END)) {\n        reader->in_xinclude--;\n\tgoto get_next_node;\n    }\n#endif\n    /*\n     * Handle entities enter and exit when in entity replacement mode\n     */\n    if ((reader->node != NULL) &&\n\t(reader->node->type == XML_ENTITY_REF_NODE) &&\n\t(reader->ctxt != NULL) && (reader->ctxt->replaceEntities == 1)) {\n\tif ((reader->node->children != NULL) &&\n\t    (reader->node->children->type == XML_ENTITY_DECL) &&\n\t    (reader->node->children->children != NULL)) {\n\t    xmlTextReaderEntPush(reader, reader->node);\n\t    reader->node = reader->node->children->children;\n\t}\n#ifdef LIBXML_REGEXP_ENABLED\n    } else if ((reader->node != NULL) &&\n\t       (reader->node->type == XML_ENTITY_REF_NODE) &&\n\t       (reader->ctxt != NULL) && (reader->validate)) {\n\txmlTextReaderValidateEntity(reader);\n#endif /* LIBXML_REGEXP_ENABLED */\n    }\n    if ((reader->node != NULL) &&\n\t(reader->node->type == XML_ENTITY_DECL) &&\n\t(reader->ent != NULL) && (reader->ent->children == reader->node)) {\n\treader->node = xmlTextReaderEntPop(reader);\n\treader->depth++;\n        goto get_next_node;\n    }\n#ifdef LIBXML_REGEXP_ENABLED\n    if ((reader->validate != XML_TEXTREADER_NOT_VALIDATE) && (reader->node != NULL)) {\n\txmlNodePtr node = reader->node;\n\n\tif ((node->type == XML_ELEMENT_NODE) &&\n            ((reader->state != XML_TEXTREADER_END) &&\n\t     (reader->state != XML_TEXTREADER_BACKTRACK))) {\n\t    xmlTextReaderValidatePush(reader);\n\t} else if ((node->type == XML_TEXT_NODE) ||\n\t\t   (node->type == XML_CDATA_SECTION_NODE)) {\n            xmlTextReaderValidateCData(reader, node->content,\n\t                               xmlStrlen(node->content));\n\t}\n    }\n#endif /* LIBXML_REGEXP_ENABLED */\n#ifdef LIBXML_PATTERN_ENABLED\n    if ((reader->patternNr > 0) && (reader->state != XML_TEXTREADER_END) &&\n        (reader->state != XML_TEXTREADER_BACKTRACK)) {\n        int i;\n\tfor (i = 0;i < reader->patternNr;i++) {\n\t     if (xmlPatternMatch(reader->patternTab[i], reader->node) == 1) {\n\t         xmlTextReaderPreserve(reader);\n\t\t break;\n             }\n\t}\n    }\n#endif /* LIBXML_PATTERN_ENABLED */\n#ifdef LIBXML_SCHEMAS_ENABLED\n    if ((reader->validate == XML_TEXTREADER_VALIDATE_XSD) &&\n        (reader->xsdValidErrors == 0) &&\n\t(reader->xsdValidCtxt != NULL)) {\n\treader->xsdValidErrors = !xmlSchemaIsValid(reader->xsdValidCtxt);\n    }\n#endif /* LIBXML_PATTERN_ENABLED */\n    return(1);\nnode_end:\n    reader->state = XML_TEXTREADER_DONE;\n    return(0);\n}\n\n\n// target function\nvoid\nxmlXIncludeFreeContext(xmlXIncludeCtxtPtr ctxt) {\n    int i;\n\n#ifdef DEBUG_XINCLUDE\n    xmlGenericError(xmlGenericErrorContext, \"Freeing context\\n\");\n#endif\n    if (ctxt == NULL)\n\treturn;\n    while (ctxt->urlNr > 0)\n\txmlXIncludeURLPop(ctxt);\n    if (ctxt->urlTab != NULL)\n\txmlFree(ctxt->urlTab);\n    for (i = 0;i < ctxt->incNr;i++) {\n\tif (ctxt->incTab[i] != NULL)\n\t    xmlXIncludeFreeRef(ctxt->incTab[i]);\n    }\n    if (ctxt->txturlTab != NULL) {\n\tfor (i = 0;i < ctxt->txtNr;i++) {\n\t    if (ctxt->txturlTab[i] != NULL)\n\t\txmlFree(ctxt->txturlTab[i]);\n\t}\n    }\n    if (ctxt->incTab != NULL)\n\txmlFree(ctxt->incTab);\n    if (ctxt->txtTab != NULL)\n\txmlFree(ctxt->txtTab);\n    if (ctxt->txturlTab != NULL)\n\txmlFree(ctxt->txturlTab);\n    if (ctxt->base != NULL) {\n        xmlFree(ctxt->base);\n    }\n    xmlFree(ctxt);\n}\nstatic void\nxmlXIncludeAddTxt(xmlXIncludeCtxtPtr ctxt, xmlNodePtr txt, const xmlURL url) {\n#ifdef DEBUG_XINCLUDE\n    xmlGenericError(xmlGenericErrorContext, \"Adding text %s\\n\", url);\n#endif\n    if (ctxt->txtMax == 0) {\n\tctxt->txtMax = 4;\n        ctxt->txtTab = (xmlNodePtr *) xmlMalloc(ctxt->txtMax *\n\t\t                          sizeof(ctxt->txtTab[0]));\n        if (ctxt->txtTab == NULL) {\n\t    xmlXIncludeErrMemory(ctxt, NULL, \"processing text\");\n\t    return;\n\t}\n        ctxt->txturlTab = (xmlURL *) xmlMalloc(ctxt->txtMax *\n\t\t                          sizeof(ctxt->txturlTab[0]));\n        if (ctxt->txturlTab == NULL) {\n\t    xmlXIncludeErrMemory(ctxt, NULL, \"processing text\");\n\t    return;\n\t}\n    }\n    if (ctxt->txtNr >= ctxt->txtMax) {\n\tctxt->txtMax *= 2;\n        ctxt->txtTab = (xmlNodePtr *) xmlRealloc(ctxt->txtTab,\n\t             ctxt->txtMax * sizeof(ctxt->txtTab[0]));\n        if (ctxt->txtTab == NULL) {\n\t    xmlXIncludeErrMemory(ctxt, NULL, \"processing text\");\n\t    return;\n\t}\n        ctxt->txturlTab = (xmlURL *) xmlRealloc(ctxt->txturlTab,\n\t             ctxt->txtMax * sizeof(ctxt->txturlTab[0]));\n        if (ctxt->txturlTab == NULL) {\n\t    xmlXIncludeErrMemory(ctxt, NULL, \"processing text\");\n\t    return;\n\t}\n    }\n    ctxt->txtTab[ctxt->txtNr] = txt;\n    ctxt->txturlTab[ctxt->txtNr] = xmlStrdup(url);\n    ctxt->txtNr++;\n}\nstatic int\nxmlXIncludeLoadTxt(xmlXIncludeCtxtPtr ctxt, const xmlChar *url, int nr) {\n    xmlParserInputBufferPtr buf;\n    xmlNodePtr node;\n    xmlURIPtr uri;\n    xmlChar *URL;\n    int i;\n    xmlChar *encoding = NULL;\n    xmlCharEncoding enc = (xmlCharEncoding) 0;\n    xmlParserCtxtPtr pctxt;\n    xmlParserInputPtr inputStream;\n    int xinclude_multibyte_fallback_used = 0;\n\n    /* Don't read from stdin. */\n    if (xmlStrcmp(url, BAD_CAST \"-\") == 0)\n        url = BAD_CAST \"./-\";\n\n    /*\n     * Check the URL and remove any fragment identifier\n     */\n    uri = xmlParseURI((const char *)url);\n    if (uri == NULL) {\n\txmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref, XML_XINCLUDE_HREF_URI,\n\t               \"invalid value URI %s\\n\", url);\n\treturn(-1);\n    }\n    if (uri->fragment != NULL) {\n\txmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref, XML_XINCLUDE_TEXT_FRAGMENT,\n\t               \"fragment identifier forbidden for text: %s\\n\",\n\t\t       (const xmlChar *) uri->fragment);\n\txmlFreeURI(uri);\n\treturn(-1);\n    }\n    URL = xmlSaveUri(uri);\n    xmlFreeURI(uri);\n    if (URL == NULL) {\n\txmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref, XML_XINCLUDE_HREF_URI,\n\t               \"invalid value URI %s\\n\", url);\n\treturn(-1);\n    }\n\n    /*\n     * Handling of references to the local document are done\n     * directly through ctxt->doc.\n     */\n    if (URL[0] == 0) {\n\txmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t               XML_XINCLUDE_TEXT_DOCUMENT,\n\t\t       \"text serialization of document not available\\n\", NULL);\n\txmlFree(URL);\n\treturn(-1);\n    }\n\n    /*\n     * Prevent reloading twice the document.\n     */\n    for (i = 0; i < ctxt->txtNr; i++) {\n\tif (xmlStrEqual(URL, ctxt->txturlTab[i])) {\n\t    node = xmlCopyNode(ctxt->txtTab[i], 1);\n\t    goto loaded;\n\t}\n    }\n    /*\n     * Try to get the encoding if available\n     */\n    if ((ctxt->incTab[nr] != NULL) && (ctxt->incTab[nr]->ref != NULL)) {\n\tencoding = xmlGetProp(ctxt->incTab[nr]->ref, XINCLUDE_PARSE_ENCODING);\n    }\n    if (encoding != NULL) {\n\t/*\n\t * TODO: we should not have to remap to the xmlCharEncoding\n\t *       predefined set, a better interface than\n\t *       xmlParserInputBufferCreateFilename should allow any\n\t *       encoding supported by iconv\n\t */\n        enc = xmlParseCharEncoding((const char *) encoding);\n\tif (enc == XML_CHAR_ENCODING_ERROR) {\n\t    xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t                   XML_XINCLUDE_UNKNOWN_ENCODING,\n\t\t\t   \"encoding %s not supported\\n\", encoding);\n\t    xmlFree(encoding);\n\t    xmlFree(URL);\n\t    return(-1);\n\t}\n\txmlFree(encoding);\n    }\n\n    /*\n     * Load it.\n     */\n    pctxt = xmlNewParserCtxt();\n    inputStream = xmlLoadExternalEntity((const char*)URL, NULL, pctxt);\n    if(inputStream == NULL) {\n\txmlFreeParserCtxt(pctxt);\n\txmlFree(URL);\n\treturn(-1);\n    }\n    buf = inputStream->buf;\n    if (buf == NULL) {\n\txmlFreeInputStream (inputStream);\n\txmlFreeParserCtxt(pctxt);\n\txmlFree(URL);\n\treturn(-1);\n    }\n    if (buf->encoder)\n\txmlCharEncCloseFunc(buf->encoder);\n    buf->encoder = xmlGetCharEncodingHandler(enc);\n    node = xmlNewText(NULL);\n\n    /*\n     * Scan all chars from the resource and add the to the node\n     */\nxinclude_multibyte_fallback:\n    while (xmlParserInputBufferRead(buf, 128) > 0) {\n\tint len;\n\tconst xmlChar *content;\n\n\tcontent = xmlBufContent(buf->buffer);\n\tlen = xmlBufLength(buf->buffer);\n\tfor (i = 0;i < len;) {\n\t    int cur;\n\t    int l;\n\n\t    cur = xmlStringCurrentChar(NULL, &content[i], &l);\n\t    if (!IS_CHAR(cur)) {\n\t\t/* Handle split multibyte char at buffer boundary */\n\t\tif (((len - i) < 4) && (!xinclude_multibyte_fallback_used)) {\n\t\t    xinclude_multibyte_fallback_used = 1;\n\t\t    xmlBufShrink(buf->buffer, i);\n\t\t    goto xinclude_multibyte_fallback;\n\t\t} else {\n\t\t    xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t\t\t\t   XML_XINCLUDE_INVALID_CHAR,\n\t\t\t\t   \"%s contains invalid char\\n\", URL);\n\t\t    xmlFreeParserCtxt(pctxt);\n\t\t    xmlFreeParserInputBuffer(buf);\n\t\t    xmlFree(URL);\n\t\t    return(-1);\n\t\t}\n\t    } else {\n\t\txinclude_multibyte_fallback_used = 0;\n\t\txmlNodeAddContentLen(node, &content[i], l);\n\t    }\n\t    i += l;\n\t}\n\txmlBufShrink(buf->buffer, len);\n    }\n    xmlFreeParserCtxt(pctxt);\n    xmlXIncludeAddTxt(ctxt, node, URL);\n    xmlFreeInputStream(inputStream);\n\nloaded:\n    /*\n     * Add the element as the replacement copy.\n     */\n    ctxt->incTab[nr]->inc = node;\n    xmlFree(URL);\n    return(0);\n}\n",
    "target": 1,
    "idx": 1026022,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nvoid SvxMSDffManager::SolveSolver( const SvxMSDffSolverContainer& rSolver )\n{\n    size_t i, nCnt;\n    for ( i = 0, nCnt = rSolver.aCList.size(); i < nCnt; i++ )\n    {\n        SvxMSDffConnectorRule* pPtr = rSolver.aCList[ i ];\n        if ( pPtr->pCObj )\n        {\n            for ( int nN = 0; nN < 2; nN++ )\n            {\n                SdrObject*  pO;\n                sal_uInt32  nC, nSpFlags;\n                if ( !nN )\n                {\n                    pO = pPtr->pAObj;\n                    nC = pPtr->ncptiA;\n                    nSpFlags = pPtr->nSpFlagsA;\n                }\n                else\n                {\n                    pO = pPtr->pBObj;\n                    nC = pPtr->ncptiB;\n                    nSpFlags = pPtr->nSpFlagsB;\n                }\n                if ( pO )\n                {\n                    SdrGluePoint aGluePoint;\n                    Reference< XShape > aXShape( pO->getUnoShape(), UNO_QUERY );\n                    Reference< XShape > aXConnector( pPtr->pCObj->getUnoShape(), UNO_QUERY );\n                    SdrGluePointList* pList = pO->ForceGluePointList();\n\n                    sal_Int32 nId = nC;\n                    SdrInventor nInventor = pO->GetObjInventor();\n\n                    if( nInventor == SdrInventor::Default )\n                    {\n                        bool bValidGluePoint = false;\n                        sal_uInt32 nObjId = pO->GetObjIdentifier();\n                        switch( nObjId )\n                        {\n                            case OBJ_GRUP :\n                            case OBJ_GRAF :\n                            case OBJ_RECT :\n                            case OBJ_TEXT :\n                            case OBJ_PAGE :\n                            case OBJ_TEXTEXT :\n                            case OBJ_TITLETEXT :\n                            case OBJ_OUTLINETEXT :\n                            {\n                                if ( nC & 1 )\n                                {\n                                    if ( nSpFlags & SP_FFLIPH )\n                                        nC ^= 2;    // 1 <-> 3\n                                }\n                                else\n                                {\n                                    if ( nSpFlags & SP_FFLIPV )\n                                        nC ^= 1;    // 0 <-> 2\n                                }\n                                switch( nC )\n                                {\n                                    case 0 :\n                                        nId = 0;    // SdrAlign::VERT_TOP;\n                                    break;\n                                    case 1 :\n                                        nId = 3;    // SdrAlign::HORZ_RIGHT;\n                                    break;\n                                    case 2 :\n                                        nId = 2;    // SdrAlign::VERT_BOTTOM;\n                                    break;\n                                    case 3 :\n                                        nId = 1; // SdrAlign::HORZ_LEFT;\n                                    break;\n                                }\n                                if ( nId <= 3 )\n                                    bValidGluePoint = true;\n                            }\n                            break;\n                            case OBJ_POLY :\n                            case OBJ_PLIN :\n                            case OBJ_LINE :\n                            case OBJ_PATHLINE :\n                            case OBJ_PATHFILL :\n                            case OBJ_FREELINE :\n                            case OBJ_FREEFILL :\n                            case OBJ_SPLNLINE :\n                            case OBJ_SPLNFILL :\n                            case OBJ_PATHPOLY :\n                            case OBJ_PATHPLIN :\n                            {\n                                if (pList)\n                                {\n                                    if (pList->GetCount() > nC )\n                                    {\n                                        bValidGluePoint = true;\n                                        nId = (sal_Int32)((*pList)[ (sal_uInt16)nC].GetId() + 3 );\n                                    }\n                                    else\n                                    {\n                                        bool bNotFound = true;\n\n                                        tools::PolyPolygon aPolyPoly( EscherPropertyContainer::GetPolyPolygon( aXShape ) );\n                                        sal_uInt16 k, j, nPolySize = aPolyPoly.Count();\n                                        if ( nPolySize )\n                                        {\n                                            tools::Rectangle aBoundRect( aPolyPoly.GetBoundRect() );\n                                            if ( aBoundRect.GetWidth() && aBoundRect.GetHeight() )\n                                            {\n                                                sal_uInt32  nPointCount = 0;\n                                                for ( k = 0; bNotFound && ( k < nPolySize ); k++ )\n                                                {\n                                                    const tools::Polygon& rPolygon = aPolyPoly.GetObject( k );\n                                                    for ( j = 0; bNotFound && ( j < rPolygon.GetSize() ); j++ )\n                                                    {\n                                                        PolyFlags eFlags = rPolygon.GetFlags( j );\n                                                        if ( eFlags == PolyFlags::Normal )\n                                                        {\n                                                            if ( nC == nPointCount )\n                                                            {\n                                                                const Point& rPoint = rPolygon.GetPoint( j );\n                                                                double fXRel = rPoint.X() - aBoundRect.Left();\n                                                                double fYRel = rPoint.Y() - aBoundRect.Top();\n                                                                sal_Int32 nWidth = aBoundRect.GetWidth();\n                                                                if ( !nWidth )\n                                                                    nWidth = 1;\n                                                                sal_Int32 nHeight= aBoundRect.GetHeight();\n                                                                if ( !nHeight )\n                                                                    nHeight = 1;\n                                                                fXRel /= (double)nWidth;\n                                                                fXRel *= 10000;\n                                                                fYRel /= (double)nHeight;\n                                                                fYRel *= 10000;\n                                                                aGluePoint.SetPos( Point( (sal_Int32)fXRel, (sal_Int32)fYRel ) );\n                                                                aGluePoint.SetPercent( true );\n                                                                aGluePoint.SetAlign( SdrAlign::VERT_TOP | SdrAlign::HORZ_LEFT );\n                                                                aGluePoint.SetEscDir( SdrEscapeDirection::SMART );\n                                                                nId = (sal_Int32)((*pList)[ pList->Insert( aGluePoint ) ].GetId() + 3 );\n                                                                bNotFound = false;\n                                                            }\n                                                            nPointCount++;\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                        if ( !bNotFound )\n                                        {\n                                            bValidGluePoint = true;\n                                        }\n                                    }\n                                }\n                            }\n                            break;\n\n                            case OBJ_CUSTOMSHAPE :\n                            {\n                                const SfxPoolItem& aCustomShape =  static_cast<SdrObjCustomShape*>(pO)->GetMergedItem( SDRATTR_CUSTOMSHAPE_GEOMETRY );\n                                SdrCustomShapeGeometryItem aGeometryItem( static_cast<const SdrCustomShapeGeometryItem&>(aCustomShape) );\n                                const OUString sPath( \"Path\" );\n                                const OUString sGluePointType( \"GluePointType\" );\n                                sal_Int16 nGluePointType = EnhancedCustomShapeGluePointType::SEGMENTS;\n                                css::uno::Any* pAny = aGeometryItem.GetPropertyValueByName( sPath, sGluePointType );\n                                if ( pAny )\n                                    *pAny >>= nGluePointType;\n                                else\n                                {\n                                    const OUString sType( \"Type\" );\n                                    OUString sShapeType;\n                                    pAny = aGeometryItem.GetPropertyValueByName( sType );\n                                    if ( pAny )\n                                        *pAny >>= sShapeType;\n                                    MSO_SPT eSpType = EnhancedCustomShapeTypeNames::Get( sShapeType );\n                                    nGluePointType = GetCustomShapeConnectionTypeDefault( eSpType );\n                                }\n                                if ( nGluePointType == EnhancedCustomShapeGluePointType::CUSTOM )\n                                {\n                                    if ( pList && ( pList->GetCount() > nC ) )\n                                    {\n                                        bValidGluePoint = true;\n                                        nId = (sal_Int32)((*pList)[ (sal_uInt16)nC].GetId() + 3 );\n                                    }\n                                }\n                                else if ( nGluePointType == EnhancedCustomShapeGluePointType::RECT )\n                                {\n                                    if ( nC & 1 )\n                                    {\n                                        if ( nSpFlags & SP_FFLIPH )\n                                            nC ^= 2;    // 1 <-> 3\n                                    }\n                                    else\n                                    {\n                                        if ( nSpFlags & SP_FFLIPV )\n                                            nC ^= 1;    // 0 <-> 2\n                                    }\n                                    switch( nC )\n                                    {\n                                        case 0 :\n                                            nId = 0;    // SdrAlign::VERT_TOP;\n                                        break;\n                                        case 1 :\n                                            nId = 3;    // SdrAlign::HORZ_RIGHT;\n                                        break;\n                                        case 2 :\n                                            nId = 2;    // SdrAlign::VERT_BOTTOM;\n                                        break;\n                                        case 3 :\n                                            nId = 1; // SdrAlign::HORZ_LEFT;\n                                        break;\n                                    }\n                                    if ( nId <= 3 )\n                                        bValidGluePoint = true;\n                                }\n                                else if ( nGluePointType == EnhancedCustomShapeGluePointType::SEGMENTS )\n                                {\n                                    const OUString sSegments( \"Segments\" );\n                                    const OUString sCoordinates( \"Coordinates\" );\n\n                                    sal_uInt32 k, nPt = nC;\n                                    css::uno::Sequence< css::drawing::EnhancedCustomShapeSegment > aSegments;\n                                    pAny = aGeometryItem.GetPropertyValueByName( sPath, sSegments );\n                                    if ( pAny )\n                                    {\n                                        if ( *pAny >>= aSegments )\n                                        {\n                                            for ( nPt = 0, k = 1; nC && ( k < (sal_uInt32)aSegments.getLength() ); k++ )\n                                            {\n                                                sal_Int16 j, nCnt2 = aSegments[ k ].Count;\n                                                if ( aSegments[ k ].Command != EnhancedCustomShapeSegmentCommand::UNKNOWN )\n                                                {\n                                                    for ( j = 0; nC && ( j < nCnt2 ); j++ )\n                                                    {\n                                                        switch( aSegments[ k ].Command )\n                                                        {\n                                                            case EnhancedCustomShapeSegmentCommand::ENDSUBPATH :\n                                                            case EnhancedCustomShapeSegmentCommand::CLOSESUBPATH :\n                                                            case EnhancedCustomShapeSegmentCommand::LINETO :\n                                                            case EnhancedCustomShapeSegmentCommand::MOVETO :\n                                                            {\n                                                                nC--;\n                                                                nPt++;\n                                                            }\n                                                            break;\n                                                            case EnhancedCustomShapeSegmentCommand::ELLIPTICALQUADRANTX :\n                                                            case EnhancedCustomShapeSegmentCommand::ELLIPTICALQUADRANTY :\n                                                            break;\n\n                                                            case EnhancedCustomShapeSegmentCommand::CURVETO :\n                                                            {\n                                                                nC--;\n                                                                nPt += 3;\n                                                            }\n                                                            break;\n\n                                                            case EnhancedCustomShapeSegmentCommand::ANGLEELLIPSETO :\n                                                            case EnhancedCustomShapeSegmentCommand::ANGLEELLIPSE :\n                                                            {\n                                                                nC--;\n                                                                nPt += 3;\n                                                            }\n                                                            break;\n                                                            case EnhancedCustomShapeSegmentCommand::ARCTO :\n                                                            case EnhancedCustomShapeSegmentCommand::ARC :\n                                                            case EnhancedCustomShapeSegmentCommand::CLOCKWISEARCTO :\n                                                            case EnhancedCustomShapeSegmentCommand::CLOCKWISEARC :\n                                                            {\n                                                                nC--;\n                                                                nPt += 4;\n                                                            }\n                                                            break;\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                    pAny = aGeometryItem.GetPropertyValueByName( sPath, sCoordinates );\n                                    if ( pAny )\n                                    {\n                                        css::uno::Sequence< css::drawing::EnhancedCustomShapeParameterPair > aCoordinates;\n                                        *pAny >>= aCoordinates;\n                                        if ( nPt < (sal_uInt32)aCoordinates.getLength() )\n                                        {\n                                            nId = 4;\n                                            css::drawing::EnhancedCustomShapeParameterPair& rPara = aCoordinates[ nPt ];\n                                            sal_Int32 nX = 0, nY = 0;\n                                            if ( ( rPara.First.Value >>= nX ) && ( rPara.Second.Value >>= nY ) )\n                                            {\n                                                const OUString sGluePoints( \"GluePoints\" );\n                                                css::uno::Sequence< css::drawing::EnhancedCustomShapeParameterPair > aGluePoints;\n                                                pAny = aGeometryItem.GetPropertyValueByName( sPath, sGluePoints );\n                                                if ( pAny )\n                                                    *pAny >>= aGluePoints;\n                                                sal_Int32 nGluePoints = aGluePoints.getLength();\n                                                aGluePoints.realloc( nGluePoints + 1 );\n                                                EnhancedCustomShape2d::SetEnhancedCustomShapeParameter( aGluePoints[ nGluePoints ].First, nX );\n                                                EnhancedCustomShape2d::SetEnhancedCustomShapeParameter( aGluePoints[ nGluePoints ].Second, nY );\n                                                PropertyValue aProp;\n                                                aProp.Name = sGluePoints;\n                                                aProp.Value <<= aGluePoints;\n                                                aGeometryItem.SetPropertyValue( sPath, aProp );\n                                                bValidGluePoint = true;\n                                                static_cast<SdrObjCustomShape*>(pO)->SetMergedItem( aGeometryItem );\n                                                SdrGluePointList* pLst = pO->ForceGluePointList();\n                                                if ( pLst->GetCount() > nGluePoints )\n                                                    nId = (sal_Int32)((*pLst)[ (sal_uInt16)nGluePoints ].GetId() + 3 );\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                            break;\n                        }\n                        if ( bValidGluePoint )\n                        {\n                            Reference< XPropertySet > xPropSet( aXConnector, UNO_QUERY );\n                            if ( xPropSet.is() )\n                            {\n                                if ( nN )\n                                {\n                                    OUString aPropName( \"EndShape\" );\n                                    SetPropValue( Any(aXShape), xPropSet, aPropName, true );\n                                    aPropName = \"EndGluePointIndex\";\n                                    SetPropValue( Any(nId), xPropSet, aPropName, true );\n                                }\n                                else\n                                {\n                                    OUString aPropName( \"StartShape\" );\n                                    SetPropValue( Any(aXShape), xPropSet, aPropName, true );\n                                    aPropName = \"StartGluePointIndex\";\n                                    SetPropValue( Any(nId), xPropSet, aPropName, true );\n                                }\n\n                                // Not sure what this is good for, repaint or broadcast of object change.\n                                //( Thus I am adding repaint here\n                                pO->SetChanged();\n                                pO->BroadcastObjectChange();\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nvoid SdrPowerPointImport::ImportPage( SdrPage* pRet, const PptSlidePersistEntry* pMasterPersist )\n{\n    sal_uInt32 nMerk = rStCtrl.Tell();\n    PptSlidePersistList* pList = GetPageList( eAktPageKind );\n    if ( ( !pList ) || ( pList->size() <= nAktPageNum ) )\n        return;\n    PptSlidePersistEntry& rSlidePersist = (*pList)[ nAktPageNum ];\n    if ( rSlidePersist.bStarDrawFiller )\n        return;\n\n    DffRecordHeader aPageHd;\n    if ( SeekToAktPage( &aPageHd ) )\n    {\n        rSlidePersist.pHeaderFooterEntry = new HeaderFooterEntry( pMasterPersist );\n        ProcessData aProcessData( rSlidePersist, SdPageCapsule(pRet) );\n        auto nEndRecPos = SanitizeEndPos(rStCtrl, aPageHd.GetRecEndFilePos());\n        while ( ( rStCtrl.GetError() == 0 ) && ( rStCtrl.Tell() < nEndRecPos ) )\n        {\n            DffRecordHeader aHd;\n            ReadDffRecordHeader( rStCtrl, aHd );\n            switch ( aHd.nRecType )\n            {\n                case PPT_PST_HeadersFooters :\n                {\n                    ImportHeaderFooterContainer( aHd, *rSlidePersist.pHeaderFooterEntry );\n                }\n                break;\n\n                case PPT_PST_ProgTags :\n                {\n                    DffRecordHeader aContentDataHd;\n                    if ( SeekToContentOfProgTag( 10, rStCtrl, aHd, aContentDataHd ) )\n                    {\n                        DffRecordHeader aComment10Hd;\n                        while( ( rStCtrl.GetError() == 0 ) && SeekToRec( rStCtrl, PPT_PST_Comment10, aContentDataHd.GetRecEndFilePos(), &aComment10Hd ) )\n                        {\n                            ImportComment10( *this, rStCtrl, pRet, aComment10Hd );\n                            if (!aComment10Hd.SeekToEndOfRecord(rStCtrl))\n                                break;\n                        }\n                    }\n                }\n                break;\n\n                case PPT_PST_PPDrawing :\n                {\n                    DffRecordHeader aPPDrawHd;\n                    if ( SeekToRec( rStCtrl, DFF_msofbtDgContainer, aHd.GetRecEndFilePos(), &aPPDrawHd ) )\n                    {\n                        sal_uInt32 nPPDrawOfs = rStCtrl.Tell();\n\n                        // importing the background object before importing the page\n                        auto nPPEndRecPos = SanitizeEndPos(rStCtrl, aPPDrawHd.GetRecEndFilePos());\n                        while ( ( rStCtrl.GetError() == 0 ) && ( rStCtrl.Tell() < nPPEndRecPos ) )\n                        {\n                            DffRecordHeader aEscherObjListHd;\n                            ReadDffRecordHeader( rStCtrl, aEscherObjListHd );\n                            switch ( aEscherObjListHd.nRecType )\n                            {\n                                case DFF_msofbtSpContainer :\n                                {\n                                    tools::Rectangle aPageSize( Point(), pRet->GetSize() );\n                                    if ( rSlidePersist.aSlideAtom.nFlags & 4 )          // follow master background?\n                                    {\n                                        if ( HasMasterPage( nAktPageNum, eAktPageKind ) )\n                                        {\n                                            sal_uInt16 nMasterNum = GetMasterPageIndex( nAktPageNum, eAktPageKind );\n                                            PptSlidePersistList* pPageList = GetPageList( PPT_MASTERPAGE );\n                                            PptSlidePersistEntry* pE = &(*pPageList)[ nMasterNum ];\n                                            while( ( pE->aSlideAtom.nFlags & 4 ) && pE->aSlideAtom.nMasterId )\n                                            {\n                                                auto nOrigMasterId = pE->aSlideAtom.nMasterId;\n                                                sal_uInt16 nNextMaster = m_pMasterPages->FindPage(nOrigMasterId);\n                                                if ( nNextMaster == PPTSLIDEPERSIST_ENTRY_NOTFOUND )\n                                                    break;\n                                                else\n                                                    pE = &(*pPageList)[ nNextMaster ];\n                                                if (pE->aSlideAtom.nMasterId == nOrigMasterId)\n                                                {\n                                                    SAL_WARN(\"filter.ms\", \"loop in atom chain\");\n                                                    break;\n                                                }\n                                            }\n                                            if ( pE->nBackgroundOffset )\n                                            {\n                                                // do not follow master colorscheme?\n                                                bool bTemporary = ( rSlidePersist.aSlideAtom.nFlags & 2 ) != 0;\n                                                sal_uInt32 nPos = rStCtrl.Tell();\n                                                rStCtrl.Seek( pE->nBackgroundOffset );\n                                                rSlidePersist.pBObj = ImportObj( rStCtrl, static_cast<void*>(&aProcessData), aPageSize, aPageSize );\n                                                rSlidePersist.bBObjIsTemporary = bTemporary;\n                                                rStCtrl.Seek( nPos );\n                                            }\n                                        }\n                                    }\n                                    else\n                                    {\n                                        DffRecordHeader aShapeHd;\n                                        ReadDffRecordHeader( rStCtrl, aShapeHd );\n                                        if ( aShapeHd.nRecType == DFF_msofbtSp )\n                                        {\n                                            sal_uInt32 nSpFlags;\n                                            rStCtrl.ReadUInt32( nSpFlags ).ReadUInt32( nSpFlags );\n                                            if ( nSpFlags & SP_FBACKGROUND )\n                                            {\n                                                aEscherObjListHd.SeekToBegOfRecord( rStCtrl );\n                                                rSlidePersist.pBObj = ImportObj( rStCtrl, static_cast<void*>(&aProcessData), aPageSize, aPageSize );\n                                                rSlidePersist.bBObjIsTemporary = false;\n                                            }\n                                        }\n                                    }\n                                }\n                                break;\n                            }\n                            if ( aEscherObjListHd.nRecType == DFF_msofbtSpContainer )\n                                break;\n                            if (!aEscherObjListHd.SeekToEndOfRecord(rStCtrl))\n                                break;\n                        }\n\n                        // now importing page\n                        rStCtrl.Seek( nPPDrawOfs );\n                        auto nHdEndRecPos = SanitizeEndPos(rStCtrl, aPPDrawHd.GetRecEndFilePos());\n                        while ( ( rStCtrl.GetError() == 0 ) && ( rStCtrl.Tell() < nHdEndRecPos ) )\n                        {\n                            DffRecordHeader aEscherObjListHd;\n                            ReadDffRecordHeader( rStCtrl, aEscherObjListHd );\n                            switch ( aEscherObjListHd.nRecType )\n                            {\n                                case DFF_msofbtSpgrContainer :\n                                {\n                                    DffRecordHeader aShapeHd;\n                                    if ( SeekToRec( rStCtrl, DFF_msofbtSpContainer, aEscherObjListHd.GetRecEndFilePos(), &aShapeHd ) )\n                                    {\n                                        aShapeHd.SeekToEndOfRecord( rStCtrl );\n                                        auto nListEndRecPos = SanitizeEndPos(rStCtrl, aEscherObjListHd.GetRecEndFilePos());\n                                        while ( ( rStCtrl.GetError() == 0 ) && ( rStCtrl.Tell() < nListEndRecPos ) )\n                                        {\n                                            ReadDffRecordHeader( rStCtrl, aShapeHd );\n                                            if ( ( aShapeHd.nRecType == DFF_msofbtSpContainer ) || ( aShapeHd.nRecType == DFF_msofbtSpgrContainer ) )\n                                            {\n                                                tools::Rectangle aEmpty;\n                                                aShapeHd.SeekToBegOfRecord( rStCtrl );\n                                                sal_Int32 nShapeId;\n                                                aProcessData.pTableRowProperties.reset();\n                                                SdrObject* pObj = ImportObj( rStCtrl, static_cast<void*>(&aProcessData), aEmpty, aEmpty, 0, &nShapeId );\n                                                if ( pObj )\n                                                {\n                                                    if ( aProcessData.pTableRowProperties )\n                                                        pObj = CreateTable( pObj, aProcessData.pTableRowProperties.get(), aProcessData.rPersistEntry.pSolverContainer );\n\n                                                    pRet->NbcInsertObject( pObj );\n\n                                                    if( nShapeId )\n                                                        insertShapeId( nShapeId, pObj );\n                                                }\n                                            }\n                                            bool bSuccess = aShapeHd.SeekToEndOfRecord(rStCtrl);\n                                            if (!bSuccess)\n                                                break;\n                                        }\n                                    }\n                                }\n                                break;\n                            }\n                            if ( aEscherObjListHd.nRecType == DFF_msofbtSpgrContainer )\n                                break;\n                            if (!aEscherObjListHd.SeekToEndOfRecord(rStCtrl))\n                                break;\n                        }\n\n                        // Handle shapes where the fill matches the background\n                        // fill (mso_fillBackground).\n                        if (rSlidePersist.ePageKind == PPT_SLIDEPAGE)\n                        {\n                            if (!aProcessData.aBackgroundColoredObjects.empty())\n                            {\n                                if (!rSlidePersist.pBObj)\n                                {\n                                    for (auto pObject : aProcessData.aBackgroundColoredObjects)\n                                    {\n                                        // The shape wants a background, but the slide doesn't have\n                                        // one: default to white.\n                                        SfxItemSet aNewSet(*pObject->GetMergedItemSet().GetPool());\n                                        aNewSet.Put(XFillStyleItem(css::drawing::FillStyle_SOLID));\n                                        aNewSet.Put(XFillColorItem(OUString(), Color(COL_WHITE)));\n                                        pObject->SetMergedItemSet(aNewSet);\n                                    }\n                                }\n                            }\n                        }\n\n                        if ( rSlidePersist.pBObj )\n                        {\n                            // #i99386# transfer the attributes from the temporary BackgroundObject\n                            // to the Page and delete it. Maybe rSlidePersist.bBObjIsTemporary is\n                            // obsolete here, too.\n                            pRet->getSdrPageProperties().ClearItem();\n                            pRet->getSdrPageProperties().PutItemSet(rSlidePersist.pBObj->GetMergedItemSet());\n                            if (rSlidePersist.pSolverContainer)\n                            {\n                                for (SvxMSDffConnectorRule* pPtr : rSlidePersist.pSolverContainer->aCList)\n                                {\n                                    // check connections to the group object\n                                    if (pPtr->pAObj == rSlidePersist.pBObj)\n                                        pPtr->pAObj = nullptr;\n                                    if (pPtr->pBObj == rSlidePersist.pBObj)\n                                        pPtr->pBObj = nullptr;\n                                }\n                            }\n                            SdrObject::Free(rSlidePersist.pBObj);\n                        }\n                    }\n                }\n                break;\n            }\n            if (!aHd.SeekToEndOfRecord(rStCtrl))\n                break;\n        }\n        if ( rSlidePersist.pSolverContainer )\n            SolveSolver( *rSlidePersist.pSolverContainer );\n    }\n    rStCtrl.Seek( nMerk );\n}\n\nextern \"C\" SAL_DLLPUBLIC_EXPORT sal_Bool SAL_CALL ImportPPT(\n        SdDrawDocument* pDocument, SvStream& rDocStream, SotStorage& rStorage, SfxMedium& rMedium )\n{\n    std::unique_ptr<SdPPTImport> pImport( new SdPPTImport( pDocument, rDocStream, rStorage, rMedium ));\n    bool bRet = pImport->Import();\n    return bRet;\n}\n\nextern \"C\" SAL_DLLPUBLIC_EXPORT sal_Bool SAL_CALL ImportPPT(\n        SdDrawDocument* pDocument, SvStream& rDocStream, SotStorage& rStorage, SfxMedium& rMedium )\n{\n    std::unique_ptr<SdPPTImport> pImport( new SdPPTImport( pDocument, rDocStream, rStorage, rMedium ));\n    bool bRet = pImport->Import();\n    return bRet;\n}\n\nextern \"C\" SAL_DLLPUBLIC_EXPORT bool SAL_CALL TestImportPPT(SvStream &rStream)\n{\n    tools::SvRef<SotStorage> xStorage;\n    try\n    {\n        xStorage = tools::SvRef<SotStorage>(new SotStorage(rStream));\n        if (xStorage->GetError())\n            return false;\n    }\n    catch (...)\n    {\n        return false;\n    }\n\n    tools::SvRef<SotStorageStream> xDocStream(xStorage->OpenSotStream( \"PowerPoint Document\", StreamMode::STD_READ));\n    if ( !xDocStream.is() )\n        return false;\n\n    SdDLL::Init();\n\n    SfxMedium aSrcMed(\"\", StreamMode::STD_READ);\n\n    xDocStream->SetVersion(xStorage->GetVersion());\n    xDocStream->SetCryptMaskKey(xStorage->GetKey());\n\n    ::sd::DrawDocShellRef xDocShRef = new ::sd::DrawDocShell(SfxObjectCreateMode::EMBEDDED, false);\n    SdDrawDocument *pDoc = xDocShRef->GetDoc();\n\n    bool bRet = ImportPPT(pDoc, *xDocStream, *xStorage, aSrcMed);\n\n    xDocShRef->DoClose();\n\n    return bRet;\n}\n\n\n// target function\nvoid SdrPowerPointImport::ImportPage( SdrPage* pRet, const PptSlidePersistEntry* pMasterPersist )\n{\n    sal_uInt32 nMerk = rStCtrl.Tell();\n    PptSlidePersistList* pList = GetPageList( eAktPageKind );\n    if ( ( !pList ) || ( pList->size() <= nAktPageNum ) )\n        return;\n    PptSlidePersistEntry& rSlidePersist = (*pList)[ nAktPageNum ];\n    if ( rSlidePersist.bStarDrawFiller )\n        return;\n\n    DffRecordHeader aPageHd;\n    if ( SeekToAktPage( &aPageHd ) )\n    {\n        rSlidePersist.pHeaderFooterEntry = new HeaderFooterEntry( pMasterPersist );\n        ProcessData aProcessData( rSlidePersist, SdPageCapsule(pRet) );\n        auto nEndRecPos = SanitizeEndPos(rStCtrl, aPageHd.GetRecEndFilePos());\n        while ( ( rStCtrl.GetError() == 0 ) && ( rStCtrl.Tell() < nEndRecPos ) )\n        {\n            DffRecordHeader aHd;\n            ReadDffRecordHeader( rStCtrl, aHd );\n            switch ( aHd.nRecType )\n            {\n                case PPT_PST_HeadersFooters :\n                {\n                    ImportHeaderFooterContainer( aHd, *rSlidePersist.pHeaderFooterEntry );\n                }\n                break;\n\n                case PPT_PST_ProgTags :\n                {\n                    DffRecordHeader aContentDataHd;\n                    if ( SeekToContentOfProgTag( 10, rStCtrl, aHd, aContentDataHd ) )\n                    {\n                        DffRecordHeader aComment10Hd;\n                        while( ( rStCtrl.GetError() == 0 ) && SeekToRec( rStCtrl, PPT_PST_Comment10, aContentDataHd.GetRecEndFilePos(), &aComment10Hd ) )\n                        {\n                            ImportComment10( *this, rStCtrl, pRet, aComment10Hd );\n                            if (!aComment10Hd.SeekToEndOfRecord(rStCtrl))\n                                break;\n                        }\n                    }\n                }\n                break;\n\n                case PPT_PST_PPDrawing :\n                {\n                    DffRecordHeader aPPDrawHd;\n                    if ( SeekToRec( rStCtrl, DFF_msofbtDgContainer, aHd.GetRecEndFilePos(), &aPPDrawHd ) )\n                    {\n                        sal_uInt32 nPPDrawOfs = rStCtrl.Tell();\n\n                        // importing the background object before importing the page\n                        auto nPPEndRecPos = SanitizeEndPos(rStCtrl, aPPDrawHd.GetRecEndFilePos());\n                        while ( ( rStCtrl.GetError() == 0 ) && ( rStCtrl.Tell() < nPPEndRecPos ) )\n                        {\n                            DffRecordHeader aEscherObjListHd;\n                            ReadDffRecordHeader( rStCtrl, aEscherObjListHd );\n                            switch ( aEscherObjListHd.nRecType )\n                            {\n                                case DFF_msofbtSpContainer :\n                                {\n                                    tools::Rectangle aPageSize( Point(), pRet->GetSize() );\n                                    if ( rSlidePersist.aSlideAtom.nFlags & 4 )          // follow master background?\n                                    {\n                                        if ( HasMasterPage( nAktPageNum, eAktPageKind ) )\n                                        {\n                                            sal_uInt16 nMasterNum = GetMasterPageIndex( nAktPageNum, eAktPageKind );\n                                            PptSlidePersistList* pPageList = GetPageList( PPT_MASTERPAGE );\n                                            PptSlidePersistEntry* pE = &(*pPageList)[ nMasterNum ];\n                                            while( ( pE->aSlideAtom.nFlags & 4 ) && pE->aSlideAtom.nMasterId )\n                                            {\n                                                auto nOrigMasterId = pE->aSlideAtom.nMasterId;\n                                                sal_uInt16 nNextMaster = m_pMasterPages->FindPage(nOrigMasterId);\n                                                if ( nNextMaster == PPTSLIDEPERSIST_ENTRY_NOTFOUND )\n                                                    break;\n                                                else\n                                                    pE = &(*pPageList)[ nNextMaster ];\n                                                if (pE->aSlideAtom.nMasterId == nOrigMasterId)\n                                                {\n                                                    SAL_WARN(\"filter.ms\", \"loop in atom chain\");\n                                                    break;\n                                                }\n                                            }\n                                            if ( pE->nBackgroundOffset )\n                                            {\n                                                // do not follow master colorscheme?\n                                                bool bTemporary = ( rSlidePersist.aSlideAtom.nFlags & 2 ) != 0;\n                                                sal_uInt32 nPos = rStCtrl.Tell();\n                                                rStCtrl.Seek( pE->nBackgroundOffset );\n                                                rSlidePersist.pBObj = ImportObj( rStCtrl, static_cast<void*>(&aProcessData), aPageSize, aPageSize );\n                                                rSlidePersist.bBObjIsTemporary = bTemporary;\n                                                rStCtrl.Seek( nPos );\n                                            }\n                                        }\n                                    }\n                                    else\n                                    {\n                                        DffRecordHeader aShapeHd;\n                                        ReadDffRecordHeader( rStCtrl, aShapeHd );\n                                        if ( aShapeHd.nRecType == DFF_msofbtSp )\n                                        {\n                                            sal_uInt32 nSpFlags;\n                                            rStCtrl.ReadUInt32( nSpFlags ).ReadUInt32( nSpFlags );\n                                            if ( nSpFlags & SP_FBACKGROUND )\n                                            {\n                                                aEscherObjListHd.SeekToBegOfRecord( rStCtrl );\n                                                rSlidePersist.pBObj = ImportObj( rStCtrl, static_cast<void*>(&aProcessData), aPageSize, aPageSize );\n                                                rSlidePersist.bBObjIsTemporary = false;\n                                            }\n                                        }\n                                    }\n                                }\n                                break;\n                            }\n                            if ( aEscherObjListHd.nRecType == DFF_msofbtSpContainer )\n                                break;\n                            if (!aEscherObjListHd.SeekToEndOfRecord(rStCtrl))\n                                break;\n                        }\n\n                        // now importing page\n                        rStCtrl.Seek( nPPDrawOfs );\n                        auto nHdEndRecPos = SanitizeEndPos(rStCtrl, aPPDrawHd.GetRecEndFilePos());\n                        while ( ( rStCtrl.GetError() == 0 ) && ( rStCtrl.Tell() < nHdEndRecPos ) )\n                        {\n                            DffRecordHeader aEscherObjListHd;\n                            ReadDffRecordHeader( rStCtrl, aEscherObjListHd );\n                            switch ( aEscherObjListHd.nRecType )\n                            {\n                                case DFF_msofbtSpgrContainer :\n                                {\n                                    DffRecordHeader aShapeHd;\n                                    if ( SeekToRec( rStCtrl, DFF_msofbtSpContainer, aEscherObjListHd.GetRecEndFilePos(), &aShapeHd ) )\n                                    {\n                                        aShapeHd.SeekToEndOfRecord( rStCtrl );\n                                        auto nListEndRecPos = SanitizeEndPos(rStCtrl, aEscherObjListHd.GetRecEndFilePos());\n                                        while ( ( rStCtrl.GetError() == 0 ) && ( rStCtrl.Tell() < nListEndRecPos ) )\n                                        {\n                                            ReadDffRecordHeader( rStCtrl, aShapeHd );\n                                            if ( ( aShapeHd.nRecType == DFF_msofbtSpContainer ) || ( aShapeHd.nRecType == DFF_msofbtSpgrContainer ) )\n                                            {\n                                                tools::Rectangle aEmpty;\n                                                aShapeHd.SeekToBegOfRecord( rStCtrl );\n                                                sal_Int32 nShapeId;\n                                                aProcessData.pTableRowProperties.reset();\n                                                SdrObject* pObj = ImportObj( rStCtrl, static_cast<void*>(&aProcessData), aEmpty, aEmpty, 0, &nShapeId );\n                                                if ( pObj )\n                                                {\n                                                    if ( aProcessData.pTableRowProperties )\n                                                        pObj = CreateTable( pObj, aProcessData.pTableRowProperties.get(), aProcessData.rPersistEntry.pSolverContainer );\n\n                                                    pRet->NbcInsertObject( pObj );\n\n                                                    if( nShapeId )\n                                                        insertShapeId( nShapeId, pObj );\n                                                }\n                                            }\n                                            bool bSuccess = aShapeHd.SeekToEndOfRecord(rStCtrl);\n                                            if (!bSuccess)\n                                                break;\n                                        }\n                                    }\n                                }\n                                break;\n                            }\n                            if ( aEscherObjListHd.nRecType == DFF_msofbtSpgrContainer )\n                                break;\n                            if (!aEscherObjListHd.SeekToEndOfRecord(rStCtrl))\n                                break;\n                        }\n\n                        // Handle shapes where the fill matches the background\n                        // fill (mso_fillBackground).\n                        if (rSlidePersist.ePageKind == PPT_SLIDEPAGE)\n                        {\n                            if (!aProcessData.aBackgroundColoredObjects.empty())\n                            {\n                                if (!rSlidePersist.pBObj)\n                                {\n                                    for (auto pObject : aProcessData.aBackgroundColoredObjects)\n                                    {\n                                        // The shape wants a background, but the slide doesn't have\n                                        // one: default to white.\n                                        SfxItemSet aNewSet(*pObject->GetMergedItemSet().GetPool());\n                                        aNewSet.Put(XFillStyleItem(css::drawing::FillStyle_SOLID));\n                                        aNewSet.Put(XFillColorItem(OUString(), Color(COL_WHITE)));\n                                        pObject->SetMergedItemSet(aNewSet);\n                                    }\n                                }\n                            }\n                        }\n\n                        if ( rSlidePersist.pBObj )\n                        {\n                            // #i99386# transfer the attributes from the temporary BackgroundObject\n                            // to the Page and delete it. Maybe rSlidePersist.bBObjIsTemporary is\n                            // obsolete here, too.\n                            pRet->getSdrPageProperties().ClearItem();\n                            pRet->getSdrPageProperties().PutItemSet(rSlidePersist.pBObj->GetMergedItemSet());\n                            SdrObject::Free( rSlidePersist.pBObj );\n                        }\n                    }\n                }\n                break;\n            }\n            if (!aHd.SeekToEndOfRecord(rStCtrl))\n                break;\n        }\n        if ( rSlidePersist.pSolverContainer )\n            SolveSolver( *rSlidePersist.pSolverContainer );\n    }\n    rStCtrl.Seek( nMerk );\n}\n",
    "target": 1,
    "idx": 1000888,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nint cil_symtab_get_datum(symtab_t *symtab, char *key, struct cil_symtab_datum **datum)\n{\n\t*datum = (struct cil_symtab_datum*)hashtab_search(symtab->table, (hashtab_key_t)key);\n\tif (*datum == NULL) {\n\t\treturn SEPOL_ENOENT;\n\t}\n\n\treturn SEPOL_OK;\n}\n\n\n\nint cil_resolve_classperms(struct cil_tree_node *current, struct cil_classperms *cp, void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_symtab_datum *datum = NULL;\n\tsymtab_t *common_symtab = NULL;\n\tstruct cil_class *class;\n\n\tif (cp->class) {\n\t\treturn SEPOL_OK;\n\t}\n\n\trc = cil_resolve_name(current, cp->class_str, CIL_SYM_CLASSES, extra_args, &datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tclass = (struct cil_class *)datum;\n\n\tif (class->common != NULL) {\n\t\tcommon_symtab = &class->common->perms;\n\t}\n\n\tcp->class = class;\n\n\trc = __cil_resolve_perms(&class->perms, common_symtab, cp->perm_strs, &cp->perms, FLAVOR(datum));\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_classperms_list(struct cil_tree_node *current, struct cil_list *cp_list, void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_list_item *curr;\n\n\tcil_list_for_each(curr, cp_list) {\n\t\tif (curr->flavor == CIL_CLASSPERMS) {\n\t\t\trc = cil_resolve_classperms(current, curr->data, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t} else {\n\t\t\trc = cil_resolve_classperms_set(current, curr->data, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_constrain(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_constrain *cons = current->data;\n\tint rc = SEPOL_ERR;\n\n\trc = cil_resolve_classperms_list(current, cons->classperms, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\trc = cil_resolve_expr(CIL_CONSTRAIN, cons->str_expr, &cons->datum_expr, current, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\n\n\nint cil_tree_walk_core(struct cil_tree_node *node,\n\t\t\t\t\t   int (*process_node)(struct cil_tree_node *node, uint32_t *finished, void *extra_args),\n\t\t\t\t\t   int (*first_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t\t   int (*last_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t\t   void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\twhile (node) {\n\t\tuint32_t finished = CIL_TREE_SKIP_NOTHING;\n\n\t\tif (process_node != NULL) {\n\t\t\trc = (*process_node)(node, &finished, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tif (finished & CIL_TREE_SKIP_NEXT) {\n\t\t\treturn SEPOL_OK;\n\t\t}\n\n\t\tif (node->cl_head != NULL && !(finished & CIL_TREE_SKIP_HEAD)) {\n\t\t\trc = cil_tree_walk(node, process_node, first_child, last_child, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tnode = node->next;\n\t}\n\n\treturn SEPOL_OK;\n}\n\nint cil_tree_walk(struct cil_tree_node *node, \n\t\t\t\t  int (*process_node)(struct cil_tree_node *node, uint32_t *finished, void *extra_args), \n\t\t\t\t  int (*first_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t  int (*last_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t  void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\tif (!node || !node->cl_head) {\n\t\treturn SEPOL_OK;\n\t}\n\n\tif (first_child != NULL) {\n\t\trc = (*first_child)(node->cl_head, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = cil_tree_walk_core(node->cl_head, process_node, first_child, last_child, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\treturn rc;\n\t}\n\n\tif (last_child != NULL) {\n\t\trc = (*last_child)(node->cl_tail, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n}\n\nint cil_tree_walk_core(struct cil_tree_node *node,\n\t\t\t\t\t   int (*process_node)(struct cil_tree_node *node, uint32_t *finished, void *extra_args),\n\t\t\t\t\t   int (*first_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t\t   int (*last_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t\t   void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\twhile (node) {\n\t\tuint32_t finished = CIL_TREE_SKIP_NOTHING;\n\n\t\tif (process_node != NULL) {\n\t\t\trc = (*process_node)(node, &finished, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tif (finished & CIL_TREE_SKIP_NEXT) {\n\t\t\treturn SEPOL_OK;\n\t\t}\n\n\t\tif (node->cl_head != NULL && !(finished & CIL_TREE_SKIP_HEAD)) {\n\t\t\trc = cil_tree_walk(node, process_node, first_child, last_child, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tnode = node->next;\n\t}\n\n\treturn SEPOL_OK;\n}\n\nint cil_tree_walk(struct cil_tree_node *node, \n\t\t\t\t  int (*process_node)(struct cil_tree_node *node, uint32_t *finished, void *extra_args), \n\t\t\t\t  int (*first_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t  int (*last_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t  void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\tif (!node || !node->cl_head) {\n\t\treturn SEPOL_OK;\n\t}\n\n\tif (first_child != NULL) {\n\t\trc = (*first_child)(node->cl_head, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = cil_tree_walk_core(node->cl_head, process_node, first_child, last_child, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\treturn rc;\n\t}\n\n\tif (last_child != NULL) {\n\t\trc = (*last_child)(node->cl_tail, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n}\n\nint cil_tree_walk_core(struct cil_tree_node *node,\n\t\t\t\t\t   int (*process_node)(struct cil_tree_node *node, uint32_t *finished, void *extra_args),\n\t\t\t\t\t   int (*first_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t\t   int (*last_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t\t   void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\twhile (node) {\n\t\tuint32_t finished = CIL_TREE_SKIP_NOTHING;\n\n\t\tif (process_node != NULL) {\n\t\t\trc = (*process_node)(node, &finished, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tif (finished & CIL_TREE_SKIP_NEXT) {\n\t\t\treturn SEPOL_OK;\n\t\t}\n\n\t\tif (node->cl_head != NULL && !(finished & CIL_TREE_SKIP_HEAD)) {\n\t\t\trc = cil_tree_walk(node, process_node, first_child, last_child, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tnode = node->next;\n\t}\n\n\treturn SEPOL_OK;\n}\n\nint cil_tree_walk(struct cil_tree_node *node, \n\t\t\t\t  int (*process_node)(struct cil_tree_node *node, uint32_t *finished, void *extra_args), \n\t\t\t\t  int (*first_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t  int (*last_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t  void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\tif (!node || !node->cl_head) {\n\t\treturn SEPOL_OK;\n\t}\n\n\tif (first_child != NULL) {\n\t\trc = (*first_child)(node->cl_head, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = cil_tree_walk_core(node->cl_head, process_node, first_child, last_child, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\treturn rc;\n\t}\n\n\tif (last_child != NULL) {\n\t\trc = (*last_child)(node->cl_tail, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n}\n\nint __cil_resolve_ast_last_child_helper(struct cil_tree_node *current, void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_args_resolve *args = extra_args;\n\tstruct cil_tree_node *parent = NULL;\n\n\tif (current == NULL ||  extra_args == NULL) {\n\t\tgoto exit;\n\t}\n\n\tparent = current->parent;\n\n\tif (parent->flavor == CIL_BLOCK) {\n\t\tstruct cil_tree_node *n = parent->parent;\n\t\targs->block = NULL;\n\t\twhile (n && n->flavor != CIL_ROOT) {\n\t\t\tif (n->flavor == CIL_BLOCK) {\n\t\t\t\targs->block = n;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tn = n->parent;\n\t\t}\n\t} else if (parent->flavor == CIL_MACRO) {\n\t\targs->macro = NULL;\n\t} else if (parent->flavor == CIL_OPTIONAL) {\n\t\tstruct cil_tree_node *n = parent->parent;\n\t\tif (args->disabled_optional == parent) {\n\t\t\t*(args->changed) = CIL_TRUE;\n\t\t\tcil_list_append(args->to_destroy, CIL_NODE, parent);\n\t\t\targs->disabled_optional = NULL;\n\t\t}\n\t\targs->optional = NULL;\n\t\twhile (n && n->flavor != CIL_ROOT) {\n\t\t\tif (n->flavor == CIL_OPTIONAL) {\n\t\t\t\targs->optional = n;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tn = n->parent;\n\t\t}\n\t} else if (parent->flavor == CIL_BOOLEANIF) {\n\t\targs->boolif = NULL;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_compile(struct cil_db *db)\n{\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL) {\n\t\tgoto exit;\n\t}\n\n\tcil_log(CIL_INFO, \"Building AST from Parse Tree\\n\");\n\trc = cil_build_ast(db, db->parse->root, db->ast->root);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_ERR, \"Failed to build AST\\n\");\n\t\tgoto exit;\n\t}\n\n\tcil_log(CIL_INFO, \"Destroying Parse Tree\\n\");\n\tcil_tree_destroy(&db->parse);\n\n\tcil_log(CIL_INFO, \"Resolving AST\\n\");\n\trc = cil_resolve_ast(db, db->ast->root);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_ERR, \"Failed to resolve AST\\n\");\n\t\tgoto exit;\n\t}\n\n\tcil_log(CIL_INFO, \"Qualifying Names\\n\");\n\trc = cil_fqn_qualify(db->ast->root);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_ERR, \"Failed to qualify names\\n\");\n\t\tgoto exit;\n\t}\n\n\tcil_log(CIL_INFO, \"Compile post process\\n\");\n\trc = cil_post_process(db);\n\tif (rc != SEPOL_OK ) {\n\t\tcil_log(CIL_ERR, \"Post process failed\\n\");\n\t\tgoto exit;\n\t}\n\nexit:\n\n\treturn rc;\n}\n\n\n// target function\nint cil_resolve_classcommon(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_class *class = NULL;\n\tstruct cil_class *common = NULL;\n\tstruct cil_classcommon *clscom = current->data;\n\tstruct cil_symtab_datum *class_datum = NULL;\n\tstruct cil_symtab_datum *common_datum = NULL;\n\tint rc = SEPOL_ERR;\n\n\trc = cil_resolve_name(current, clscom->class_str, CIL_SYM_CLASSES, extra_args, &class_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\trc = cil_resolve_name(current, clscom->common_str, CIL_SYM_COMMONS, extra_args, &common_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tclass = (struct cil_class *)class_datum;\n\tcommon = (struct cil_class *)common_datum;\n\tif (class->common != NULL) {\n\t\tcil_log(CIL_ERR, \"class cannot be associeated with more than one common\\n\");\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\tclass->common = common;\n\n\tcil_symtab_map(&class->perms, __class_update_perm_values, &common->num_perms);\n\n\tclass->num_perms += common->num_perms;\n\tif (class->num_perms > CIL_PERMS_PER_CLASS) {\n\t\tcil_tree_log(current, CIL_ERR, \"Too many permissions in class '%s' when including common permissions\", class->datum.name);\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n",
    "target": 1,
    "idx": 1043209,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nsize_t sk_num(const _STACK *sk) {\n  if (sk == NULL) {\n    return 0;\n  }\n  return sk->num;\n}\n\n\n\nvoid ASN1_template_free(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt) {\n  size_t i;\n  if (tt->flags & ASN1_TFLG_SK_MASK) {\n    STACK_OF(ASN1_VALUE) *sk = (STACK_OF(ASN1_VALUE) *)*pval;\n    for (i = 0; i < sk_ASN1_VALUE_num(sk); i++) {\n      ASN1_VALUE *vtmp;\n      vtmp = sk_ASN1_VALUE_value(sk, i);\n      asn1_item_combine_free(&vtmp, ASN1_ITEM_ptr(tt->item), 0);\n    }\n    sk_ASN1_VALUE_free(sk);\n    *pval = NULL;\n  } else {\n    asn1_item_combine_free(pval, ASN1_ITEM_ptr(tt->item),\n                           tt->flags & ASN1_TFLG_COMBINE);\n  }\n}\n\nvoid asn1_item_combine_free(ASN1_VALUE **pval, const ASN1_ITEM *it,\n                            int combine) {\n  const ASN1_TEMPLATE *tt = NULL, *seqtt;\n  const ASN1_EXTERN_FUNCS *ef;\n  int i;\n  if (!pval) {\n    return;\n  }\n  if ((it->itype != ASN1_ITYPE_PRIMITIVE) && !*pval) {\n    return;\n  }\n\n  switch (it->itype) {\n    case ASN1_ITYPE_PRIMITIVE:\n      if (it->templates) {\n        ASN1_template_free(pval, it->templates);\n      } else {\n        ASN1_primitive_free(pval, it);\n      }\n      break;\n\n    case ASN1_ITYPE_MSTRING:\n      ASN1_primitive_free(pval, it);\n      break;\n\n    case ASN1_ITYPE_CHOICE: {\n      const ASN1_AUX *aux = it->funcs;\n      ASN1_aux_cb *asn1_cb = aux != NULL ? aux->asn1_cb : NULL;\n      if (asn1_cb) {\n        i = asn1_cb(ASN1_OP_FREE_PRE, pval, it, NULL);\n        if (i == 2) {\n          return;\n        }\n      }\n      i = asn1_get_choice_selector(pval, it);\n      if ((i >= 0) && (i < it->tcount)) {\n        ASN1_VALUE **pchval;\n        tt = it->templates + i;\n        pchval = asn1_get_field_ptr(pval, tt);\n        ASN1_template_free(pchval, tt);\n      }\n      if (asn1_cb) {\n        asn1_cb(ASN1_OP_FREE_POST, pval, it, NULL);\n      }\n      if (!combine) {\n        OPENSSL_free(*pval);\n        *pval = NULL;\n      }\n      break;\n    }\n\n    case ASN1_ITYPE_EXTERN:\n      ef = it->funcs;\n      if (ef && ef->asn1_ex_free) {\n        ef->asn1_ex_free(pval, it);\n      }\n      break;\n\n    case ASN1_ITYPE_SEQUENCE: {\n      if (!asn1_refcount_dec_and_test_zero(pval, it)) {\n        return;\n      }\n      const ASN1_AUX *aux = it->funcs;\n      ASN1_aux_cb *asn1_cb = aux != NULL ? aux->asn1_cb : NULL;\n      if (asn1_cb) {\n        i = asn1_cb(ASN1_OP_FREE_PRE, pval, it, NULL);\n        if (i == 2) {\n          return;\n        }\n      }\n      asn1_enc_free(pval, it);\n      // If we free up as normal we will invalidate any ANY DEFINED BY\n      // field and we wont be able to determine the type of the field it\n      // defines. So free up in reverse order.\n      tt = it->templates + it->tcount - 1;\n      for (i = 0; i < it->tcount; tt--, i++) {\n        ASN1_VALUE **pseqval;\n        seqtt = asn1_do_adb(pval, tt, 0);\n        if (!seqtt) {\n          continue;\n        }\n        pseqval = asn1_get_field_ptr(pval, seqtt);\n        ASN1_template_free(pseqval, seqtt);\n      }\n      if (asn1_cb) {\n        asn1_cb(ASN1_OP_FREE_POST, pval, it, NULL);\n      }\n      if (!combine) {\n        OPENSSL_free(*pval);\n        *pval = NULL;\n      }\n      break;\n    }\n  }\n}\n\nvoid ASN1_template_free(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt) {\n  size_t i;\n  if (tt->flags & ASN1_TFLG_SK_MASK) {\n    STACK_OF(ASN1_VALUE) *sk = (STACK_OF(ASN1_VALUE) *)*pval;\n    for (i = 0; i < sk_ASN1_VALUE_num(sk); i++) {\n      ASN1_VALUE *vtmp;\n      vtmp = sk_ASN1_VALUE_value(sk, i);\n      asn1_item_combine_free(&vtmp, ASN1_ITEM_ptr(tt->item), 0);\n    }\n    sk_ASN1_VALUE_free(sk);\n    *pval = NULL;\n  } else {\n    asn1_item_combine_free(pval, ASN1_ITEM_ptr(tt->item),\n                           tt->flags & ASN1_TFLG_COMBINE);\n  }\n}\n\nvoid asn1_item_combine_free(ASN1_VALUE **pval, const ASN1_ITEM *it,\n                            int combine) {\n  const ASN1_TEMPLATE *tt = NULL, *seqtt;\n  const ASN1_EXTERN_FUNCS *ef;\n  int i;\n  if (!pval) {\n    return;\n  }\n  if ((it->itype != ASN1_ITYPE_PRIMITIVE) && !*pval) {\n    return;\n  }\n\n  switch (it->itype) {\n    case ASN1_ITYPE_PRIMITIVE:\n      if (it->templates) {\n        ASN1_template_free(pval, it->templates);\n      } else {\n        ASN1_primitive_free(pval, it);\n      }\n      break;\n\n    case ASN1_ITYPE_MSTRING:\n      ASN1_primitive_free(pval, it);\n      break;\n\n    case ASN1_ITYPE_CHOICE: {\n      const ASN1_AUX *aux = it->funcs;\n      ASN1_aux_cb *asn1_cb = aux != NULL ? aux->asn1_cb : NULL;\n      if (asn1_cb) {\n        i = asn1_cb(ASN1_OP_FREE_PRE, pval, it, NULL);\n        if (i == 2) {\n          return;\n        }\n      }\n      i = asn1_get_choice_selector(pval, it);\n      if ((i >= 0) && (i < it->tcount)) {\n        ASN1_VALUE **pchval;\n        tt = it->templates + i;\n        pchval = asn1_get_field_ptr(pval, tt);\n        ASN1_template_free(pchval, tt);\n      }\n      if (asn1_cb) {\n        asn1_cb(ASN1_OP_FREE_POST, pval, it, NULL);\n      }\n      if (!combine) {\n        OPENSSL_free(*pval);\n        *pval = NULL;\n      }\n      break;\n    }\n\n    case ASN1_ITYPE_EXTERN:\n      ef = it->funcs;\n      if (ef && ef->asn1_ex_free) {\n        ef->asn1_ex_free(pval, it);\n      }\n      break;\n\n    case ASN1_ITYPE_SEQUENCE: {\n      if (!asn1_refcount_dec_and_test_zero(pval, it)) {\n        return;\n      }\n      const ASN1_AUX *aux = it->funcs;\n      ASN1_aux_cb *asn1_cb = aux != NULL ? aux->asn1_cb : NULL;\n      if (asn1_cb) {\n        i = asn1_cb(ASN1_OP_FREE_PRE, pval, it, NULL);\n        if (i == 2) {\n          return;\n        }\n      }\n      asn1_enc_free(pval, it);\n      // If we free up as normal we will invalidate any ANY DEFINED BY\n      // field and we wont be able to determine the type of the field it\n      // defines. So free up in reverse order.\n      tt = it->templates + it->tcount - 1;\n      for (i = 0; i < it->tcount; tt--, i++) {\n        ASN1_VALUE **pseqval;\n        seqtt = asn1_do_adb(pval, tt, 0);\n        if (!seqtt) {\n          continue;\n        }\n        pseqval = asn1_get_field_ptr(pval, seqtt);\n        ASN1_template_free(pseqval, seqtt);\n      }\n      if (asn1_cb) {\n        asn1_cb(ASN1_OP_FREE_POST, pval, it, NULL);\n      }\n      if (!combine) {\n        OPENSSL_free(*pval);\n        *pval = NULL;\n      }\n      break;\n    }\n  }\n}\n\nvoid ASN1_item_free(ASN1_VALUE *val, const ASN1_ITEM *it) {\n  asn1_item_combine_free(&val, it, 0);\n}\n\n\n\n\n\n  void operator()(T *ptr) {\n    // Rather than specialize Deleter for each type, we specialize\n    // DeleterImpl. This allows bssl::UniquePtr<T> to be used while only\n    // including base.h as long as the destructor is not emitted. This matches\n    // std::unique_ptr's behavior on forward-declared types.\n    //\n    // DeleterImpl itself is specialized in the corresponding module's header\n    // and must be included to release an object. If not included, the compiler\n    // will error that DeleterImpl<T> does not have a method Free.\n    DeleterImpl<T>::Free(ptr);\n  }\n\n\n\n\n// target function\nint X509V3_EXT_add_nconf_sk(const CONF *conf, const X509V3_CTX *ctx,\n                            const char *section,\n                            STACK_OF(X509_EXTENSION) **sk) {\n  const STACK_OF(CONF_VALUE) *nval = NCONF_get_section(conf, section);\n  if (nval == NULL) {\n    return 0;\n  }\n  for (size_t i = 0; i < sk_CONF_VALUE_num(nval); i++) {\n    const CONF_VALUE *val = sk_CONF_VALUE_value(nval, i);\n    X509_EXTENSION *ext = X509V3_EXT_nconf(conf, ctx, val->name, val->value);\n    if (ext == NULL) {\n      return 0;\n    }\n    if (sk) {\n      X509v3_add_ext(sk, ext, -1);\n    }\n    X509_EXTENSION_free(ext);\n  }\n  return 1;\n}\n",
    "target": 1,
    "idx": 1055556,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "// context\n\n// target function\n   take a maximum length as an additional parameter.  Also - just to save space,\n   we omit the endptr return parameter, since we know that it is never used.  */\n\nstatic long\n_bfd_strntol (const char * nptr, int base, unsigned int maxlen)\n{\n  char buf[24]; /* Should be enough.  */\n\n  BFD_ASSERT (maxlen < (sizeof (buf) - 1));\n\n  memcpy (buf, nptr, maxlen);\n  return strtol (buf, NULL, base);\n}\n\nstatic long long\n_bfd_strntoll (const char * nptr, int base, unsigned int maxlen)\n{\n  char buf[32]; /* Should be enough.  */\n\n  BFD_ASSERT (maxlen < (sizeof (buf) - 1));\n\n  memcpy (buf, nptr, maxlen);\n\n/* Read in the armap of an XCOFF archive.  */\n\nbool\n_bfd_xcoff_slurp_armap (bfd *abfd)\n{\n  file_ptr off;\n  size_t namlen;\n  bfd_size_type sz;\n  bfd_byte *contents, *cend;\n  bfd_vma c, i;\n  carsym *arsym;\n  bfd_byte *p;\n\n  if (x_artdata (abfd) == NULL)\n    {\n      abfd->has_armap = false;\n      return true;\n    }\n\n  if (! xcoff_big_format_p (abfd))\n    {\n      /* This is for the old format.  */\n      struct xcoff_ar_hdr hdr;\n\n      GET_VALUE_IN_FIELD (off, x_artdata (abfd)->u.hdr.symoff, 10);\n      if (off == 0)\n\t{\n\t  abfd->has_armap = false;\n\t  return true;\n\t}\n\n      if (bfd_seek (abfd, off, SEEK_SET) != 0)\n\treturn false;\n\n      /* The symbol table starts with a normal archive header.  */\n      if (bfd_bread (&hdr, (bfd_size_type) SIZEOF_AR_HDR, abfd)\n\t  != SIZEOF_AR_HDR)\n\treturn false;\n\n      /* Skip the name (normally empty).  */\n      GET_VALUE_IN_FIELD (namlen, hdr.namlen, 10);\n      off = ((namlen + 1) & ~ (size_t) 1) + SXCOFFARFMAG;\n      if (bfd_seek (abfd, off, SEEK_CUR) != 0)\n\treturn false;\n\n      GET_VALUE_IN_FIELD (sz, hdr.size, 10);\n      if (sz + 1 < 5)\n\t{\n\t  bfd_set_error (bfd_error_bad_value);\n\t  return false;\n\t}\n\n      /* Read in the entire symbol table.  */\n      contents = (bfd_byte *) _bfd_alloc_and_read (abfd, sz + 1, sz);\n      if (contents == NULL)\n\treturn false;\n\n      /* Ensure strings are NULL terminated so we don't wander off the\n\t end of the buffer.  */\n      contents[sz] = 0;\n\n      /* The symbol table starts with a four byte count.  */\n      c = H_GET_32 (abfd, contents);\n\n      if (c >= sz / 4)\n\t{\n\t  bfd_set_error (bfd_error_bad_value);\n\t  return false;\n\t}\n\n      bfd_ardata (abfd)->symdefs =\n\t((carsym *) bfd_alloc (abfd, c * sizeof (carsym)));\n      if (bfd_ardata (abfd)->symdefs == NULL)\n\treturn false;\n\n      /* After the count comes a list of four byte file offsets.  */\n      for (i = 0, arsym = bfd_ardata (abfd)->symdefs, p = contents + 4;\n\t   i < c;\n\t   ++i, ++arsym, p += 4)\n\tarsym->file_offset = H_GET_32 (abfd, p);\n    }\n  else\n    {\n      /* This is for the new format.  */\n      struct xcoff_ar_hdr_big hdr;\n\n      GET_VALUE_IN_FIELD (off, x_artdata (abfd)->u.bhdr.symoff, 10);\n      if (off == 0)\n\t{\n\t  abfd->has_armap = false;\n\t  return true;\n\t}\n\n      if (bfd_seek (abfd, off, SEEK_SET) != 0)\n\treturn false;\n\n      /* The symbol table starts with a normal archive header.  */\n      if (bfd_bread (&hdr, (bfd_size_type) SIZEOF_AR_HDR_BIG, abfd)\n\t  != SIZEOF_AR_HDR_BIG)\n\treturn false;\n\n      /* Skip the name (normally empty).  */\n      GET_VALUE_IN_FIELD (namlen, hdr.namlen, 10);\n      off = ((namlen + 1) & ~ (size_t) 1) + SXCOFFARFMAG;\n      if (bfd_seek (abfd, off, SEEK_CUR) != 0)\n\treturn false;\n\n      GET_VALUE_IN_FIELD (sz, hdr.size, 10);\n      if (sz + 1 < 9)\n\t{\n\t  bfd_set_error (bfd_error_bad_value);\n\t  return false;\n\t}\n\n      /* Read in the entire symbol table.  */\n      contents = (bfd_byte *) _bfd_alloc_and_read (abfd, sz + 1, sz);\n      if (contents == NULL)\n\treturn false;\n\n      /* Ensure strings are NULL terminated so we don't wander off the\n\t end of the buffer.  */\n      contents[sz] = 0;\n\n      /* The symbol table starts with an eight byte count.  */\n      c = H_GET_64 (abfd, contents);\n\n      if (c >= sz / 8)\n\t{\n\t  bfd_set_error (bfd_error_bad_value);\n\t  return false;\n\t}\n\n      bfd_ardata (abfd)->symdefs =\n\t((carsym *) bfd_alloc (abfd, c * sizeof (carsym)));\n      if (bfd_ardata (abfd)->symdefs == NULL)\n\treturn false;\n\n      /* After the count comes a list of eight byte file offsets.  */\n      for (i = 0, arsym = bfd_ardata (abfd)->symdefs, p = contents + 8;\n\t   i < c;\n\t   ++i, ++arsym, p += 8)\n\tarsym->file_offset = H_GET_64 (abfd, p);\n    }\n\n  /* After the file offsets come null terminated symbol names.  */\n  cend = contents + sz;\n  for (i = 0, arsym = bfd_ardata (abfd)->symdefs;\n       i < c;\n       ++i, ++arsym, p += strlen ((char *) p) + 1)\n    {\n      if (p >= cend)\n\t{\n\t  bfd_set_error (bfd_error_bad_value);\n\t  return false;\n\t}\n      arsym->name = (char *) p;\n    }\n\n  bfd_ardata (abfd)->symdef_count = c;\n  abfd->has_armap = true;\n   need to use extended name tables.  So those other routines in\n   archive.c that call _bfd_read_ar_hdr are unused.  */\n\nstatic bool\nadd_range (bfd *abfd, ufile_ptr start, ufile_ptr end)\n{\n  if (end <= start)\n    {\n    err:\n      bfd_set_error (bfd_error_malformed_archive);\n      return false;\n    }\n\n  /* This list is kept sorted by address.  Find the highest address\n     range on the list that ends before the new range starts.  Exit\n     the loop with that range in LO, and the mext higher range in HI.  */\n  struct ar_ranges *hi = &x_artdata (abfd)->ranges;\n  struct ar_ranges *lo = NULL;\n  while (hi && hi->end <= start)\n    {\n      lo = hi;\n      hi = hi->next;\n    }\n\n  if (lo == NULL)\n    /* Start overlaps the file header or elements adjacent to it.  */\n    goto err;\n\n  if (hi && hi->start < end)\n    /* Overlap with another element.  */\n    goto err;\n\n  unsigned min_elt = x_artdata (abfd)->min_elt;\n  if (start - lo->end < min_elt)\n    {\n      /* Merge into an existing range.  */\n      lo->end = end;\n      if (hi && hi->start - end < min_elt)\n\t{\n\t  /* In fact, we can merge two ranges.  */\n\t  lo->end = hi->end;\n\t  lo->next = hi->next;\n\t  /* The list uses bfd_alloc so don't free HI.  */\n\t}\n      return true;\n    }\n\n  if (hi && hi->start - end < min_elt)\n    {\n      /* Merge into an existing range.  */\n      hi->start = start;\n      return true;\n    }\n\n  struct ar_ranges *newr = bfd_alloc (abfd, sizeof (*newr));\n  if (newr == NULL)\n    return false;\n  newr->start = start;\n  newr->end = end;\n  newr->next = hi;\n\n/* Stat an element in an XCOFF archive.  */\n\nint\n_bfd_xcoff_stat_arch_elt (bfd *abfd, struct stat *s)\n{\n  if (abfd->arelt_data == NULL)\n    {\n      bfd_set_error (bfd_error_invalid_operation);\n      return -1;\n    }\n\n  if (! xcoff_big_format_p (abfd->my_archive))\n    {\n      struct xcoff_ar_hdr *hdrp = arch_xhdr (abfd);\n\n      GET_VALUE_IN_FIELD (s->st_mtime, hdrp->date, 10);\n      GET_VALUE_IN_FIELD (s->st_uid, hdrp->uid, 10);\n      GET_VALUE_IN_FIELD (s->st_gid, hdrp->gid, 10);\n      GET_VALUE_IN_FIELD (s->st_mode, hdrp->mode, 8);\n      s->st_size = arch_eltdata (abfd)->parsed_size;\n    }\n  else\n    {\n      struct xcoff_ar_hdr_big *hdrp = arch_xhdr_big (abfd);\n\n      GET_VALUE_IN_FIELD (s->st_mtime, hdrp->date, 10);\n      GET_VALUE_IN_FIELD (s->st_uid, hdrp->uid, 10);\n      GET_VALUE_IN_FIELD (s->st_gid, hdrp->gid, 10);\n      GET_VALUE_IN_FIELD (s->st_mode, hdrp->mode, 8);\n      s->st_size = arch_eltdata (abfd)->parsed_size;\n    }\n",
    "target": 1,
    "idx": 1058378,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "// context\nstatic void\ninsert (bfd *abfd)\n{\n  if (bfd_last_cache == NULL)\n    {\n      abfd->lru_next = abfd;\n      abfd->lru_prev = abfd;\n    }\n  else\n    {\n      abfd->lru_next = bfd_last_cache;\n      abfd->lru_prev = bfd_last_cache->lru_prev;\n      abfd->lru_prev->lru_next = abfd;\n      abfd->lru_next->lru_prev = abfd;\n    }\n  bfd_last_cache = abfd;\n}\n\nbool\nbfd_cache_init (bfd *abfd)\n{\n  BFD_ASSERT (abfd->iostream != NULL);\n  if (open_files >= bfd_cache_max_open ())\n    {\n      if (! close_one ())\n\treturn false;\n    }\n  abfd->iovec = &cache_iovec;\n  insert (abfd);\n  abfd->flags &= ~BFD_CLOSED_BY_CACHE;\n  ++open_files;\n  return true;\n}\n\n\n\n\n\n\n// target function\nstatic bool\nelf64_vms_close_and_cleanup (bfd *abfd)\n{\n  bool ret = true;\n  if (bfd_get_format (abfd) == bfd_object)\n    {\n      long isize;\n\n      /* Pad to 8 byte boundary for IPF/VMS.  */\n      isize = bfd_get_size (abfd);\n      if ((isize & 7) != 0)\n\t{\n\t  unsigned int ishort = 8 - (isize & 7);\n\t  uint64_t pad = 0;\n\n\t  if (bfd_seek (abfd, isize, SEEK_SET) != 0\n\t      || bfd_write (&pad, ishort, abfd) != ishort)\n\t    ret = false;\n\t}\n    }\n\n  return _bfd_generic_close_and_cleanup (abfd) && ret;\n}\n\nbool\nbfd_close_all_done (bfd *abfd)\n{\n  bool ret = BFD_SEND (abfd, _close_and_cleanup, (abfd));\n\n  if (ret && abfd->iovec != NULL)\n    {\n      ret = abfd->iovec->bclose (abfd) == 0;\n\n      if (ret)\n\t_maybe_make_executable (abfd);\n    }\n\n  _bfd_delete_bfd (abfd);\n  free (_bfd_error_buf);\n  _bfd_error_buf = NULL;\n\n  return ret;\n",
    "target": 1,
    "idx": 1061433,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "// context\nstatic int\nmpz_init_set_str(mrb_state *mrb, mpz_t *x, const char *s, mrb_int len, mrb_int base)\n{\n  int i;\n  int retval = 0;\n  mpz_t t,m,bb;\n  short sn;\n  unsigned int k;\n  mpz_init(mrb,x);\n  mpz_init_set_int(mrb,&m,1);\n  mpz_init(mrb,&t);\n  zero(x);\n  if (*s == '-') {\n    sn = -1; s++;\n  }\n  else if (base < 0) {          /* trick: negative if base < 0 */\n    sn = -1; base = -base;\n  }\n  else\n    sn = 1;\n  mpz_init_set_int(mrb,&bb, base);\n  for (i = len-1; i>=0; i--) {\n    if (s[i]=='_') continue;\n    if (s[i] >= '0' && s[i] <= '9')\n      k = (unsigned int)s[i] - (unsigned int)'0';\n    else if (s[i] >= 'A' && s[i] <= 'Z')\n      k = (unsigned int)s[i] - (unsigned int)'A'+10;\n    else if (s[i] >= 'a' && s[i] <= 'z')\n      k = (unsigned int)s[i] - (unsigned int)'a'+10;\n    else {\n      retval = (-1);\n      break;\n    }\n    if (k >= base) {\n      retval = (-1);\n      break;\n    }\n    mpz_mul_int(mrb,&t,&m,(mrb_int)k);\n    mpz_add(mrb,x,x,&t);\n    mpz_mul(mrb,&m,&m,&bb);\n    if (i == 0) break;\n  }\n  if (x->sn)\n    x->sn = sn;\n  mpz_clear(mrb,&m);\n  mpz_clear(mrb,&bb);\n  mpz_clear(mrb,&t);\n  return retval;\n}\n\nmrb_value\nmrb_bint_new_str(mrb_state *mrb, const char *x, mrb_int len, mrb_int base)\n{\n  struct RBigint *b = MRB_OBJ_ALLOC(mrb, MRB_TT_BIGINT, mrb->integer_class);\n  mrb_assert(2 <= iabs(base) && iabs(base) <= 36);\n  mpz_init_set_str(mrb, &b->mp, x, len, base);\n  return mrb_obj_value(b);\n}\n\nMRB_API mrb_value\nmrb_vm_exec(mrb_state *mrb, const struct RProc *proc, const mrb_code *pc)\n{\n  /* mrb_assert(MRB_PROC_CFUNC_P(proc)) */\n  const mrb_irep *irep = proc->body.irep;\n  const mrb_pool_value *pool = irep->pool;\n  const mrb_sym *syms = irep->syms;\n  mrb_code insn;\n  int ai = mrb_gc_arena_save(mrb);\n  struct mrb_jmpbuf *prev_jmp = mrb->jmp;\n  struct mrb_jmpbuf c_jmp;\n  uint32_t a;\n  uint16_t b;\n  uint16_t c;\n  mrb_sym mid;\n  const struct mrb_irep_catch_handler *ch;\n\n#ifdef DIRECT_THREADED\n  static const void * const optable[] = {\n#define OPCODE(x,_) &&L_OP_ ## x,\n#include \"mruby/ops.h\"\n#undef OPCODE\n  };\n#endif\n\n  mrb_bool exc_catched = FALSE;\nRETRY_TRY_BLOCK:\n\n  MRB_TRY(&c_jmp) {\n\n  if (exc_catched) {\n    exc_catched = FALSE;\n    mrb_gc_arena_restore(mrb, ai);\n    if (mrb->exc && mrb->exc->tt == MRB_TT_BREAK)\n      goto L_BREAK;\n    goto L_RAISE;\n  }\n  mrb->jmp = &c_jmp;\n  CI_PROC_SET(mrb->c->ci, proc);\n\n  INIT_DISPATCH {\n    CASE(OP_NOP, Z) {\n      /* do nothing */\n      NEXT;\n    }\n\n    CASE(OP_MOVE, BB) {\n      regs[a] = regs[b];\n      NEXT;\n    }\n\n    CASE(OP_LOADL, BB) {\n      switch (pool[b].tt) {   /* number */\n      case IREP_TT_INT32:\n        regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i32);\n        break;\n      case IREP_TT_INT64:\n#if defined(MRB_INT64)\n        regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i64);\n        break;\n#else\n#if defined(MRB_64BIT)\n        if (INT32_MIN <= pool[b].u.i64 && pool[b].u.i64 <= INT32_MAX) {\n          regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i64);\n          break;\n        }\n#endif\n        goto L_INT_OVERFLOW;\n#endif\n      case IREP_TT_BIGINT:\n#ifdef MRB_USE_BIGINT\n        {\n          const char *s = pool[b].u.str;\n          regs[a] = mrb_bint_new_str(mrb, s+2, (mrb_int)s[0], (mrb_int)s[1]);\n        }\n        break;\n#else\n        goto L_INT_OVERFLOW;\n#endif\n#ifndef MRB_NO_FLOAT\n      case IREP_TT_FLOAT:\n        regs[a] = mrb_float_value(mrb, pool[b].u.f);\n        break;\n#endif\n      default:\n        /* should not happen (tt:string) */\n        regs[a] = mrb_nil_value();\n        break;\n      }\n      NEXT;\n    }\n\n    CASE(OP_LOADI, BB) {\n      SET_FIXNUM_VALUE(regs[a], b);\n      NEXT;\n    }\n\n    CASE(OP_LOADINEG, BB) {\n      SET_FIXNUM_VALUE(regs[a], -b);\n      NEXT;\n    }\n\n    CASE(OP_LOADI__1,B) goto L_LOADI;\n    CASE(OP_LOADI_0,B) goto L_LOADI;\n    CASE(OP_LOADI_1,B) goto L_LOADI;\n    CASE(OP_LOADI_2,B) goto L_LOADI;\n    CASE(OP_LOADI_3,B) goto L_LOADI;\n    CASE(OP_LOADI_4,B) goto L_LOADI;\n    CASE(OP_LOADI_5,B) goto L_LOADI;\n    CASE(OP_LOADI_6,B) goto L_LOADI;\n    CASE(OP_LOADI_7, B) {\n    L_LOADI:\n      SET_FIXNUM_VALUE(regs[a], (mrb_int)insn - (mrb_int)OP_LOADI_0);\n      NEXT;\n    }\n\n    CASE(OP_LOADI16, BS) {\n      SET_FIXNUM_VALUE(regs[a], (mrb_int)(int16_t)b);\n      NEXT;\n    }\n\n    CASE(OP_LOADI32, BSS) {\n      SET_INT_VALUE(mrb, regs[a], (int32_t)(((uint32_t)b<<16)+c));\n      NEXT;\n    }\n\n    CASE(OP_LOADSYM, BB) {\n      SET_SYM_VALUE(regs[a], syms[b]);\n      NEXT;\n    }\n\n    CASE(OP_LOADNIL, B) {\n      SET_NIL_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_LOADSELF, B) {\n      regs[a] = regs[0];\n      NEXT;\n    }\n\n    CASE(OP_LOADT, B) {\n      SET_TRUE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_LOADF, B) {\n      SET_FALSE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETGV, BB) {\n      mrb_value val = mrb_gv_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETGV, BB) {\n      mrb_gv_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETSV, BB) {\n      mrb_value val = mrb_vm_special_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETSV, BB) {\n      mrb_vm_special_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETIV, BB) {\n      regs[a] = mrb_iv_get(mrb, regs[0], syms[b]);\n      NEXT;\n    }\n\n    CASE(OP_SETIV, BB) {\n      mrb_iv_set(mrb, regs[0], syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETCV, BB) {\n      mrb_value val;\n      val = mrb_vm_cv_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETCV, BB) {\n      mrb_vm_cv_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETIDX, B) {\n      mrb_value va = regs[a], vb = regs[a+1];\n      switch (mrb_type(va)) {\n      case MRB_TT_ARRAY:\n        if (!mrb_integer_p(vb)) goto getidx_fallback;\n        regs[a] = mrb_ary_entry(va, mrb_integer(vb));\n        break;\n      case MRB_TT_HASH:\n        va = mrb_hash_get(mrb, va, vb);\n        regs[a] = va;\n        break;\n      case MRB_TT_STRING:\n        switch (mrb_type(vb)) {\n        case MRB_TT_INTEGER:\n        case MRB_TT_STRING:\n        case MRB_TT_RANGE:\n          va = mrb_str_aref(mrb, va, vb, mrb_undef_value());\n          regs[a] = va;\n          break;\n        default:\n          goto getidx_fallback;\n        }\n        break;\n      default:\n      getidx_fallback:\n        mid = MRB_OPSYM(aref);\n        goto L_SEND_SYM;\n      }\n      NEXT;\n    }\n\n    CASE(OP_SETIDX, B) {\n      c = 2;\n      mid = MRB_OPSYM(aset);\n      SET_NIL_VALUE(regs[a+3]);\n      goto L_SENDB_SYM;\n    }\n\n    CASE(OP_GETCONST, BB) {\n      mrb_value v = mrb_vm_const_get(mrb, syms[b]);\n      regs[a] = v;\n      NEXT;\n    }\n\n    CASE(OP_SETCONST, BB) {\n      mrb_vm_const_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETMCNST, BB) {\n      mrb_value v = mrb_const_get(mrb, regs[a], syms[b]);\n      regs[a] = v;\n      NEXT;\n    }\n\n    CASE(OP_SETMCNST, BB) {\n      mrb_const_set(mrb, regs[a+1], syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETUPVAR, BBB) {\n      mrb_value *regs_a = regs + a;\n      struct REnv *e = uvenv(mrb, c);\n\n      if (e && b < MRB_ENV_LEN(e)) {\n        *regs_a = e->stack[b];\n      }\n      else {\n        *regs_a = mrb_nil_value();\n      }\n      NEXT;\n    }\n\n    CASE(OP_SETUPVAR, BBB) {\n      struct REnv *e = uvenv(mrb, c);\n\n      if (e) {\n        mrb_value *regs_a = regs + a;\n\n        if (b < MRB_ENV_LEN(e)) {\n          e->stack[b] = *regs_a;\n          mrb_write_barrier(mrb, (struct RBasic*)e);\n        }\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMP, S) {\n      pc += (int16_t)a;\n      JUMP;\n    }\n    CASE(OP_JMPIF, BS) {\n      if (mrb_test(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n    CASE(OP_JMPNOT, BS) {\n      if (!mrb_test(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n    CASE(OP_JMPNIL, BS) {\n      if (mrb_nil_p(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMPUW, S) {\n      a = (uint32_t)((pc - irep->iseq) + (int16_t)a);\n      CHECKPOINT_RESTORE(RBREAK_TAG_JUMP) {\n        struct RBreak *brk = (struct RBreak*)mrb->exc;\n        mrb_value target = mrb_break_value_get(brk);\n        mrb_assert(mrb_integer_p(target));\n        a = (uint32_t)mrb_integer(target);\n        mrb_assert(a >= 0 && a < irep->ilen);\n      }\n      CHECKPOINT_MAIN(RBREAK_TAG_JUMP) {\n        ch = catch_handler_find(mrb, mrb->c->ci, pc, MRB_CATCH_FILTER_ENSURE);\n        if (ch) {\n          /* avoiding a jump from a catch handler into the same handler */\n          if (a < mrb_irep_catch_handler_unpack(ch->begin) || a >= mrb_irep_catch_handler_unpack(ch->end)) {\n            THROW_TAGGED_BREAK(mrb, RBREAK_TAG_JUMP, proc, mrb_fixnum_value(a));\n          }\n        }\n      }\n      CHECKPOINT_END(RBREAK_TAG_JUMP);\n\n      mrb->exc = NULL; /* clear break object */\n      pc = irep->iseq + a;\n      JUMP;\n    }\n\n    CASE(OP_EXCEPT, B) {\n      mrb_value exc;\n\n      if (mrb->exc == NULL) {\n        exc = mrb_nil_value();\n      }\n      else {\n        switch (mrb->exc->tt) {\n        case MRB_TT_BREAK:\n        case MRB_TT_EXCEPTION:\n          exc = mrb_obj_value(mrb->exc);\n          break;\n        default:\n          mrb_assert(!\"bad mrb_type\");\n          exc = mrb_nil_value();\n          break;\n        }\n        mrb->exc = NULL;\n      }\n      regs[a] = exc;\n      NEXT;\n    }\n    CASE(OP_RESCUE, BB) {\n      mrb_value exc = regs[a];  /* exc on stack */\n      mrb_value e = regs[b];\n      struct RClass *ec;\n\n      switch (mrb_type(e)) {\n      case MRB_TT_CLASS:\n      case MRB_TT_MODULE:\n        break;\n      default:\n        {\n          mrb_value exc;\n\n          exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR,\n                                    \"class or module required for rescue clause\");\n          mrb_exc_set(mrb, exc);\n          goto L_RAISE;\n        }\n      }\n      ec = mrb_class_ptr(e);\n      regs[b] = mrb_bool_value(mrb_obj_is_kind_of(mrb, exc, ec));\n      NEXT;\n    }\n\n    CASE(OP_RAISEIF, B) {\n      mrb_value exc = regs[a];\n      if (mrb_break_p(exc)) {\n        mrb->exc = mrb_obj_ptr(exc);\n        goto L_BREAK;\n      }\n      mrb_exc_set(mrb, exc);\n      if (mrb->exc) {\n        goto L_RAISE;\n      }\n      NEXT;\n    }\n\n    CASE(OP_SSEND, BBB) {\n      regs[a] = regs[0];\n      insn = OP_SEND;\n    }\n    goto L_SENDB;\n\n    CASE(OP_SSENDB, BBB) {\n      regs[a] = regs[0];\n    }\n    goto L_SENDB;\n\n    CASE(OP_SEND, BBB)\n    goto L_SENDB;\n\n    L_SEND_SYM:\n    c = 1;\n    /* push nil after arguments */\n    SET_NIL_VALUE(regs[a+2]);\n    goto L_SENDB_SYM;\n\n    CASE(OP_SENDB, BBB)\n    L_SENDB:\n    mid = syms[b];\n    L_SENDB_SYM:\n    {\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_method_t m;\n      struct RClass *cls;\n      mrb_value recv, blk;\n\n      ARGUMENT_NORMALIZE(a, &c, insn);\n\n      recv = regs[a];\n      cls = mrb_class(mrb, recv);\n      m = mrb_method_search_vm(mrb, &cls, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        m = prepare_missing(mrb, recv, mid, &cls, a, &c, blk, 0);\n        mid = MRB_SYM(method_missing);\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb, a, 0, cls, NULL, mid, c);\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        if (MRB_METHOD_PROC_P(m)) {\n          struct RProc *p = MRB_METHOD_PROC(m);\n          CI_PROC_SET(ci, p);\n          recv = p->body.func(mrb, recv);\n        }\n        else {\n          if (MRB_METHOD_NOARG_P(m)) {\n            check_method_noarg(mrb, ci);\n          }\n          recv = MRB_METHOD_FUNC(m)(mrb, recv);\n        }\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        if (mrb_proc_p(blk)) {\n          struct RProc *p = mrb_proc_ptr(blk);\n          if (p && !MRB_PROC_STRICT_P(p) && MRB_PROC_ENV(p) == CI_ENV(&ci[-1])) {\n            p->flags |= MRB_PROC_ORPHAN;\n          }\n        }\n        if (!ci->u.target_class) { /* return from context modifying method (resume/yield) */\n          if (ci->cci == CINFO_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return recv;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        ci->stack[0] = recv;\n        /* pop stackpos */\n        ci = cipop(mrb);\n        pc = ci->pc;\n      }\n      else {\n        /* setup environment for calling method */\n        proc = MRB_METHOD_PROC(m);\n        CI_PROC_SET(ci, proc);\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, (irep->nregs < 4) ? 4 : irep->nregs);\n        pc = irep->iseq;\n      }\n    }\n    JUMP;\n\n    CASE(OP_CALL, Z) {\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv = ci->stack[0];\n      struct RProc *m = mrb_proc_ptr(recv);\n\n      /* replace callinfo */\n      ci->u.target_class = MRB_PROC_TARGET_CLASS(m);\n      CI_PROC_SET(ci, m);\n      if (MRB_PROC_ENV_P(m)) {\n        ci->mid = MRB_PROC_ENV(m)->mid;\n      }\n\n      /* prepare stack */\n      if (MRB_PROC_CFUNC_P(m)) {\n        recv = MRB_PROC_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        /* pop stackpos */\n        ci = cipop(mrb);\n        pc = ci->pc;\n        ci[1].stack[0] = recv;\n        irep = mrb->c->ci->proc->body.irep;\n      }\n      else {\n        /* setup environment for calling method */\n        proc = m;\n        irep = m->body.irep;\n        if (!irep) {\n          mrb->c->ci->stack[0] = mrb_nil_value();\n          a = 0;\n          c = OP_R_NORMAL;\n          goto L_OP_RETURN_BODY;\n        }\n        mrb_int nargs = mrb_ci_bidx(ci)+1;\n        if (nargs < irep->nregs) {\n          mrb_stack_extend(mrb, irep->nregs);\n          stack_clear(regs+nargs, irep->nregs-nargs);\n        }\n        if (MRB_PROC_ENV_P(m)) {\n          regs[0] = MRB_PROC_ENV(m)->stack[0];\n        }\n        pc = irep->iseq;\n      }\n      pool = irep->pool;\n      syms = irep->syms;\n      JUMP;\n    }\n\n    CASE(OP_SUPER, BB) {\n      mrb_method_t m;\n      struct RClass *cls;\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv, blk;\n      const struct RProc *p = ci->proc;\n      mrb_sym mid = ci->mid;\n      struct RClass* target_class = CI_TARGET_CLASS(ci);\n\n      if (MRB_PROC_ENV_P(p) && p->e.env->mid && p->e.env->mid != mid) { /* alias support */\n        mid = p->e.env->mid;    /* restore old mid */\n      }\n\n      if (mid == 0 || !target_class) {\n        mrb_value exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if ((target_class->flags & MRB_FL_CLASS_IS_PREPENDED) || target_class->tt == MRB_TT_MODULE) {\n        goto super_typeerror;\n      }\n      recv = regs[0];\n      if (!mrb_obj_is_kind_of(mrb, recv, target_class)) {\n      super_typeerror: ;\n        mrb_value exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR,\n                                            \"self has wrong type to call super in this context\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n\n      ARGUMENT_NORMALIZE(a, &b, OP_SUPER);\n\n      cls = target_class->super;\n      m = mrb_method_search_vm(mrb, &cls, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        m = prepare_missing(mrb, recv, mid, &cls, a, &b, blk, 1);\n        mid = MRB_SYM(method_missing);\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb, a, 0, cls, NULL, mid, b);\n\n      /* prepare stack */\n      ci->stack[0] = recv;\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        mrb_value v;\n\n        if (MRB_METHOD_PROC_P(m)) {\n          const struct RProc *p = MRB_METHOD_PROC(m);\n          CI_PROC_SET(ci, p);\n        }\n        v = MRB_METHOD_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_restore(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        mrb_assert(!mrb_break_p(v));\n        if (!CI_TARGET_CLASS(ci)) { /* return from context modifying method (resume/yield) */\n          if (ci->cci == CINFO_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return v;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        mrb->c->ci->stack[0] = v;\n        ci = cipop(mrb);\n        pc = ci->pc;\n      }\n      else {\n        /* setup environment for calling method */\n        proc = MRB_METHOD_PROC(m);\n        CI_PROC_SET(ci, proc);\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, (irep->nregs < 4) ? 4 : irep->nregs);\n        pc = irep->iseq;\n      }\n      JUMP;\n    }\n\n    CASE(OP_ARGARY, BS) {\n      mrb_int m1 = (b>>11)&0x3f;\n      mrb_int r  = (b>>10)&0x1;\n      mrb_int m2 = (b>>5)&0x1f;\n      mrb_int kd = (b>>4)&0x1;\n      mrb_int lv = (b>>0)&0xf;\n      mrb_value *stack;\n\n      if (mrb->c->ci->mid == 0 || CI_TARGET_CLASS(mrb->c->ci) == NULL) {\n        mrb_value exc;\n\n      L_NOSUPER:\n        exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (lv == 0) stack = regs + 1;\n      else {\n        struct REnv *e = uvenv(mrb, lv-1);\n        if (!e) goto L_NOSUPER;\n        if (MRB_ENV_LEN(e) <= m1+r+m2+1)\n          goto L_NOSUPER;\n        stack = e->stack + 1;\n      }\n      if (r == 0) {\n        regs[a] = mrb_ary_new_from_values(mrb, m1+m2, stack);\n      }\n      else {\n        mrb_value *pp = NULL;\n        struct RArray *rest;\n        mrb_int len = 0;\n\n        if (mrb_array_p(stack[m1])) {\n          struct RArray *ary = mrb_ary_ptr(stack[m1]);\n\n          pp = ARY_PTR(ary);\n          len = ARY_LEN(ary);\n        }\n        regs[a] = mrb_ary_new_capa(mrb, m1+len+m2);\n        rest = mrb_ary_ptr(regs[a]);\n        if (m1 > 0) {\n          stack_copy(ARY_PTR(rest), stack, m1);\n        }\n        if (len > 0) {\n          stack_copy(ARY_PTR(rest)+m1, pp, len);\n        }\n        if (m2 > 0) {\n          stack_copy(ARY_PTR(rest)+m1+len, stack+m1+1, m2);\n        }\n        ARY_SET_LEN(rest, m1+len+m2);\n      }\n      if (kd) {\n        regs[a+1] = stack[m1+r+m2];\n        regs[a+2] = stack[m1+r+m2+1];\n      }\n      else {\n        regs[a+1] = stack[m1+r+m2];\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ENTER, W) {\n      mrb_int m1 = MRB_ASPEC_REQ(a);\n      mrb_int o  = MRB_ASPEC_OPT(a);\n      mrb_int r  = MRB_ASPEC_REST(a);\n      mrb_int m2 = MRB_ASPEC_POST(a);\n      mrb_int kd = (MRB_ASPEC_KEY(a) > 0 || MRB_ASPEC_KDICT(a))? 1 : 0;\n      /* unused\n      int b  = MRB_ASPEC_BLOCK(a);\n      */\n      mrb_int const len = m1 + o + r + m2;\n\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_int argc = ci->n;\n      mrb_value *argv = regs+1;\n      mrb_value * const argv0 = argv;\n      mrb_value blk = regs[mrb_ci_bidx(ci)];\n      mrb_value kdict = mrb_nil_value();\n\n      /* keyword arguments */\n      if (ci->nk == 15) {\n        kdict = regs[mrb_ci_kidx(ci)];\n      }\n      if (!kd) {\n        if (!mrb_nil_p(kdict) && mrb_hash_size(mrb, kdict) > 0) {\n          if (argc < 14) {\n            ci->n++;\n            argc++;    /* include kdict in normal arguments */\n          }\n          else if (argc == 14) {\n            /* pack arguments and kdict */\n            regs[1] = ary_new_from_regs(mrb, argc+1, 1);\n            argc = ci->n = 15;\n          }\n          else {/* argc == 15 */\n            /* push kdict to packed arguments */\n            mrb_ary_push(mrb, regs[1], kdict);\n          }\n        }\n        kdict = mrb_nil_value();\n        ci->nk = 0;\n      }\n      else if (MRB_ASPEC_KEY(a) > 0 && !mrb_nil_p(kdict)) {\n        kdict = mrb_hash_dup(mrb, kdict);\n      }\n\n      /* arguments is passed with Array */\n      if (argc == 15) {\n        struct RArray *ary = mrb_ary_ptr(regs[1]);\n        argv = ARY_PTR(ary);\n        argc = (int)ARY_LEN(ary);\n        mrb_gc_protect(mrb, regs[1]);\n        if (kd && !mrb_nil_p(kdict)) mrb_gc_protect(mrb, kdict);\n      }\n\n      /* strict argument check */\n      if (ci->proc && MRB_PROC_STRICT_P(ci->proc)) {\n        if (argc < m1 + m2 || (r == 0 && argc > len)) {\n          argnum_error(mrb, m1+m2);\n          goto L_RAISE;\n        }\n      }\n      /* extract first argument array to arguments */\n      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {\n        mrb_gc_protect(mrb, argv[0]);\n        argc = (int)RARRAY_LEN(argv[0]);\n        argv = RARRAY_PTR(argv[0]);\n      }\n\n      /* rest arguments */\n      mrb_value rest = mrb_nil_value();\n      if (argc < len) {\n        mrb_int mlen = m2;\n        if (argc < m1+m2) {\n          mlen = m1 < argc ? argc - m1 : 0;\n        }\n\n        /* copy mandatory and optional arguments */\n        if (argv0 != argv && argv) {\n          value_move(&regs[1], argv, argc-mlen); /* m1 + o */\n        }\n        if (argc < m1) {\n          stack_clear(&regs[argc+1], m1-argc);\n        }\n        /* copy post mandatory arguments */\n        if (mlen) {\n          value_move(&regs[len-m2+1], &argv[argc-mlen], mlen);\n        }\n        if (mlen < m2) {\n          stack_clear(&regs[len-m2+mlen+1], m2-mlen);\n        }\n        /* initialize rest arguments with empty Array */\n        if (r) {\n          rest = mrb_ary_new_capa(mrb, 0);\n          regs[m1+o+1] = rest;\n        }\n        /* skip initializer of passed arguments */\n        if (o > 0 && argc > m1+m2)\n          pc += (argc - m1 - m2)*3;\n      }\n      else {\n        mrb_int rnum = 0;\n        if (argv0 != argv) {\n          value_move(&regs[1], argv, m1+o);\n        }\n        if (r) {\n          rnum = argc-m1-o-m2;\n          rest = mrb_ary_new_from_values(mrb, rnum, argv+m1+o);\n          regs[m1+o+1] = rest;\n        }\n        if (m2 > 0 && argc-m2 > m1) {\n          value_move(&regs[m1+o+r+1], &argv[m1+o+rnum], m2);\n        }\n        pc += o*3;\n      }\n\n      /* need to be update blk first to protect blk from GC */\n      mrb_int const kw_pos = len + kd;    /* where kwhash should be */\n      mrb_int const blk_pos = kw_pos + 1; /* where block should be */\n      regs[blk_pos] = blk;              /* move block */\n      if (kd) {\n        if (mrb_nil_p(kdict))\n          kdict = mrb_hash_new_capa(mrb, 0);\n        regs[kw_pos] = kdict;           /* set kwhash */\n        ci->nk = 15;\n      }\n\n      /* format arguments for generated code */\n      mrb->c->ci->n = (uint8_t)len;\n\n      /* clear local (but non-argument) variables */\n      if (irep->nlocals-blk_pos-1 > 0) {\n        stack_clear(&regs[blk_pos+1], irep->nlocals-blk_pos-1);\n      }\n      JUMP;\n    }\n\n    CASE(OP_KARG, BB) {\n      mrb_value k = mrb_symbol_value(syms[b]);\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict, v;\n\n      if (kidx < 0 || !mrb_hash_p(kdict=regs[kidx]) || !mrb_hash_key_p(mrb, kdict, k)) {\n        mrb_value str = mrb_format(mrb, \"missing keyword: %v\", k);\n        mrb_exc_set(mrb, mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str));\n        goto L_RAISE;\n      }\n      v = mrb_hash_get(mrb, kdict, k);\n      regs[a] = v;\n      mrb_hash_delete_key(mrb, kdict, k);\n      NEXT;\n    }\n\n    CASE(OP_KEY_P, BB) {\n      mrb_value k = mrb_symbol_value(syms[b]);\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict;\n      mrb_bool key_p = FALSE;\n\n      if (kidx >= 0 && mrb_hash_p(kdict=regs[kidx])) {\n        key_p = mrb_hash_key_p(mrb, kdict, k);\n      }\n      regs[a] = mrb_bool_value(key_p);\n      NEXT;\n    }\n\n    CASE(OP_KEYEND, Z) {\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict;\n\n      if (kidx >= 0 && mrb_hash_p(kdict=regs[kidx]) && !mrb_hash_empty_p(mrb, kdict)) {\n        mrb_value keys = mrb_hash_keys(mrb, kdict);\n        mrb_value key1 = RARRAY_PTR(keys)[0];\n        mrb_value str = mrb_format(mrb, \"unknown keyword: %v\", key1);\n        mrb_exc_set(mrb, mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str));\n        goto L_RAISE;\n      }\n      NEXT;\n    }\n\n    CASE(OP_BREAK, B) {\n      c = OP_R_BREAK;\n      goto L_RETURN;\n    }\n    CASE(OP_RETURN_BLK, B) {\n      c = OP_R_RETURN;\n      goto L_RETURN;\n    }\n    CASE(OP_RETURN, B)\n    c = OP_R_NORMAL;\n    L_RETURN:\n    {\n      mrb_callinfo *ci;\n\n      ci = mrb->c->ci;\n      if (ci->mid) {\n        mrb_value blk = regs[mrb_ci_bidx(ci)];\n\n        if (mrb_proc_p(blk)) {\n          struct RProc *p = mrb_proc_ptr(blk);\n\n          if (!MRB_PROC_STRICT_P(p) &&\n              ci > mrb->c->cibase && MRB_PROC_ENV(p) == CI_ENV(&ci[-1])) {\n            p->flags |= MRB_PROC_ORPHAN;\n          }\n        }\n      }\n\n      if (mrb->exc) {\n      L_RAISE:\n        ci = mrb->c->ci;\n        if (ci == mrb->c->cibase) {\n          ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL);\n          if (ch == NULL) goto L_FTOP;\n          goto L_CATCH;\n        }\n        while ((ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL)) == NULL) {\n          ci = cipop(mrb);\n          if (ci[1].cci == CINFO_SKIP && prev_jmp) {\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          pc = ci[0].pc;\n          if (ci == mrb->c->cibase) {\n            ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL);\n            if (ch == NULL) {\n            L_FTOP:             /* fiber top */\n              if (mrb->c == mrb->root_c) {\n                mrb->c->ci->stack = mrb->c->stbase;\n                goto L_STOP;\n              }\n              else {\n                struct mrb_context *c = mrb->c;\n\n                c->status = MRB_FIBER_TERMINATED;\n                mrb->c = c->prev;\n                c->prev = NULL;\n                goto L_RAISE;\n              }\n            }\n            break;\n          }\n        }\n      L_CATCH:\n        if (ch == NULL) goto L_STOP;\n        if (FALSE) {\n        L_CATCH_TAGGED_BREAK: /* from THROW_TAGGED_BREAK() or UNWIND_ENSURE() */\n          ci = mrb->c->ci;\n        }\n        proc = ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, irep->nregs);\n        pc = irep->iseq + mrb_irep_catch_handler_unpack(ch->target);\n      }\n      else {\n        mrb_int acc;\n        mrb_value v;\n\n        ci = mrb->c->ci;\n        v = regs[a];\n        mrb_gc_protect(mrb, v);\n        switch (c) {\n        case OP_R_RETURN:\n          /* Fall through to OP_R_NORMAL otherwise */\n          if (ci->cci == CINFO_NONE && MRB_PROC_ENV_P(proc) && !MRB_PROC_STRICT_P(proc)) {\n            const struct RProc *dst;\n            mrb_callinfo *cibase;\n            cibase = mrb->c->cibase;\n            dst = top_proc(mrb, proc);\n\n            if (MRB_PROC_ENV_P(dst)) {\n              struct REnv *e = MRB_PROC_ENV(dst);\n\n              if (!MRB_ENV_ONSTACK_P(e) || (e->cxt && e->cxt != mrb->c)) {\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n            }\n            /* check jump destination */\n            while (cibase <= ci && ci->proc != dst) {\n              if (ci->cci > CINFO_NONE) { /* jump cross C boundary */\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n              ci--;\n            }\n            if (ci <= cibase) { /* no jump destination */\n              localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n              goto L_RAISE;\n            }\n            ci = mrb->c->ci;\n            while (cibase <= ci && ci->proc != dst) {\n              CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_BLOCK) {\n                cibase = mrb->c->cibase;\n                dst = top_proc(mrb, proc);\n              }\n              CHECKPOINT_MAIN(RBREAK_TAG_RETURN_BLOCK) {\n                UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN_BLOCK, proc, v);\n              }\n              CHECKPOINT_END(RBREAK_TAG_RETURN_BLOCK);\n              ci = cipop(mrb);\n              pc = ci->pc;\n            }\n            proc = ci->proc;\n            mrb->exc = NULL; /* clear break object */\n            break;\n          }\n          /* fallthrough */\n        case OP_R_NORMAL:\n        NORMAL_RETURN:\n          if (ci == mrb->c->cibase) {\n            struct mrb_context *c;\n            c = mrb->c;\n\n            if (!c->prev) { /* toplevel return */\n              regs[irep->nlocals] = v;\n              goto CHECKPOINT_LABEL_MAKE(RBREAK_TAG_STOP);\n            }\n            if (!c->vmexec && c->prev->ci == c->prev->cibase) {\n              mrb_value exc = mrb_exc_new_lit(mrb, E_FIBER_ERROR, \"double resume\");\n              mrb_exc_set(mrb, exc);\n              goto L_RAISE;\n            }\n            CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_TOPLEVEL) {\n              c = mrb->c;\n            }\n            CHECKPOINT_MAIN(RBREAK_TAG_RETURN_TOPLEVEL) {\n              UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN_TOPLEVEL, proc, v);\n            }\n            CHECKPOINT_END(RBREAK_TAG_RETURN_TOPLEVEL);\n            /* automatic yield at the end */\n            c->status = MRB_FIBER_TERMINATED;\n            mrb->c = c->prev;\n            mrb->c->status = MRB_FIBER_RUNNING;\n            c->prev = NULL;\n            if (c->vmexec) {\n              mrb_gc_arena_restore(mrb, ai);\n              c->vmexec = FALSE;\n              mrb->jmp = prev_jmp;\n              return v;\n            }\n            ci = mrb->c->ci;\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_RETURN) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_RETURN) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_RETURN);\n          mrb->exc = NULL; /* clear break object */\n          break;\n        case OP_R_BREAK:\n          if (MRB_PROC_STRICT_P(proc)) goto NORMAL_RETURN;\n          if (MRB_PROC_ORPHAN_P(proc)) {\n            mrb_value exc;\n\n          L_BREAK_ERROR:\n            exc = mrb_exc_new_lit(mrb, E_LOCALJUMP_ERROR,\n                                      \"break from proc-closure\");\n            mrb_exc_set(mrb, exc);\n            goto L_RAISE;\n          }\n          if (!MRB_PROC_ENV_P(proc) || !MRB_ENV_ONSTACK_P(MRB_PROC_ENV(proc))) {\n            goto L_BREAK_ERROR;\n          }\n          else {\n            struct REnv *e = MRB_PROC_ENV(proc);\n\n            if (e->cxt != mrb->c) {\n              goto L_BREAK_ERROR;\n            }\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_BREAK) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_BREAK) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_BREAK);\n          /* break from fiber block */\n          if (ci == mrb->c->cibase && ci->pc) {\n            struct mrb_context *c = mrb->c;\n\n            mrb->c = c->prev;\n            c->prev = NULL;\n            ci = mrb->c->ci;\n          }\n          if (ci->cci > CINFO_NONE) {\n            ci = cipop(mrb);\n            mrb->exc = (struct RObject*)break_new(mrb, RBREAK_TAG_BREAK, proc, v);\n            mrb_gc_arena_restore(mrb, ai);\n            mrb->c->vmexec = FALSE;\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          if (FALSE) {\n            struct RBreak *brk;\n\n          L_BREAK:\n            brk = (struct RBreak*)mrb->exc;\n            proc = mrb_break_proc_get(brk);\n            v = mrb_break_value_get(brk);\n            ci = mrb->c->ci;\n\n            switch (mrb_break_tag_get(brk)) {\n#define DISPATCH_CHECKPOINTS(n, i) case n: goto CHECKPOINT_LABEL_MAKE(n);\n              RBREAK_TAG_FOREACH(DISPATCH_CHECKPOINTS)\n#undef DISPATCH_CHECKPOINTS\n              default:\n                mrb_assert(!\"wrong break tag\");\n            }\n          }\n          while (mrb->c->cibase < ci && ci[-1].proc != proc->upper) {\n            if (ci[-1].cci == CINFO_SKIP) {\n              goto L_BREAK_ERROR;\n            }\n            CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_UPPER) {\n              /* do nothing */\n            }\n            CHECKPOINT_MAIN(RBREAK_TAG_BREAK_UPPER) {\n              UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK_UPPER, proc, v);\n            }\n            CHECKPOINT_END(RBREAK_TAG_BREAK_UPPER);\n            ci = cipop(mrb);\n            pc = ci->pc;\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_INTARGET) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_BREAK_INTARGET) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK_INTARGET, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_BREAK_INTARGET);\n          if (ci == mrb->c->cibase) {\n            goto L_BREAK_ERROR;\n          }\n          mrb->exc = NULL; /* clear break object */\n          break;\n        default:\n          /* cannot happen */\n          break;\n        }\n        mrb_assert(ci == mrb->c->ci);\n        mrb_assert(mrb->exc == NULL);\n\n        if (mrb->c->vmexec && !CI_TARGET_CLASS(ci)) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->c->vmexec = FALSE;\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        acc = ci->cci;\n        ci = cipop(mrb);\n        if (acc == CINFO_SKIP || acc == CINFO_DIRECT) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        pc = ci->pc;\n        DEBUG(fprintf(stderr, \"from :%s\\n\", mrb_sym_name(mrb, ci->mid)));\n        proc = ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n\n        ci[1].stack[0] = v;\n        mrb_gc_arena_restore(mrb, ai);\n      }\n      JUMP;\n    }\n\nMRB_API mrb_value\nmrb_vm_run(mrb_state *mrb, const struct RProc *proc, mrb_value self, mrb_int stack_keep)\n{\n  const mrb_irep *irep = proc->body.irep;\n  mrb_value result;\n  struct mrb_context *c = mrb->c;\n  ptrdiff_t cioff = c->ci - c->cibase;\n  mrb_int nregs = irep->nregs;\n\n  if (!c->stbase) {\n    stack_init(mrb);\n  }\n  if (stack_keep > nregs)\n    nregs = stack_keep;\n  mrb_stack_extend(mrb, nregs);\n  stack_clear(c->ci->stack + stack_keep, nregs - stack_keep);\n  c->ci->stack[0] = self;\n  result = mrb_vm_exec(mrb, proc, irep->iseq);\n  if (mrb->c != c) {\n    if (mrb->c->fib) {\n      mrb_write_barrier(mrb, (struct RBasic*)mrb->c->fib);\n    }\n    mrb->c = c;\n  }\n  else if (c->ci - c->cibase > cioff) {\n    c->ci = c->cibase + cioff;\n  }\n  return result;\n}\n\n\n// target function\nstatic void\nudiv(mrb_state *mrb, mpz_t *qq, mpz_t *rr, mpz_t *xx, mpz_t *yy)\n{\n  mpz_t q, x, y, r;\n  int ns,f,ccc=0;\n  size_t xd,yd,i,j;\n  mp_limb zz,z,qhat,b,u,m;\n\n  if (uzero(yy))\n    return;\n  mpz_init(mrb,&q); mpz_init(mrb,&x);mpz_init(mrb,&y);mpz_init(mrb,&r);\n  mpz_realloc(mrb,&x,(size_t)((xx->sz)+1));\n  yd = digits(yy);\n  ns = lzb(yy->p[yd-1]);\n  ulshift(mrb,&x,xx,ns);\n  ulshift(mrb,&y,yy,ns);\n  xd = digits(&x);\n  mpz_realloc(mrb,&q,(size_t)xd);\n  xd*=2; yd*=2;\n  z = hd(&y,yd-1);\n  for (j=(xd-yd);;j--) {\n    if (z == LMAX)\n      qhat = hd(&x,j+yd);\n    else {\n      qhat = ((hd(&x,j+yd)<< HALFDIGITBITS) + hd(&x,j+yd-1)) / (z+1);\n    }\n    b = 0; zz=0;\n    if (qhat) {\n      for (i=0; i<yd; i++) {\n        zz = qhat * hd(&y,i);\n        u = hd(&x,i+j);\n        u-=b;\n        if (u<0) {\n          b=1; u+=HLMAX+1;\n        }\n        else\n          b=0;\n        u-=LOW(zz);\n        if (u < 0) {\n          b++;\n          u+=HLMAX+1;\n        }\n        b+=HIGH(zz);\n        if ((i+j)%2)\n          x.p[(i+j)/2] = LOW(x.p[(i+j)/2]) | (u << HALFDIGITBITS);\n        else\n          x.p[(i+j)/2] = (HIGH(x.p[(i+j)/2]) << HALFDIGITBITS) | u;\n      }\n      if (b) {\n        if ((j+i)%2)\n          x.p[(i+j)/2] -= b << HALFDIGITBITS;\n        else\n          x.p[(i+j)/2] -= b;\n      }\n    }\n    for (;;zz++) {\n      f=1;\n      if (!hd(&x,j+yd)) {\n        for (i=yd-1; ; i--) {\n          if (hd(&x,j+i) > hd(&y,i)) {\n            f=1;\n            break;\n          }\n          if (hd(&x,j+i) < hd(&y,i)) {\n            f=0;\n            break;\n          }\n          if (i == 0) break;\n        }\n      }\n      if (!f)\n        break;\n      qhat++;\n      ccc++;\n      b=0;\n      for (i=0;i<yd;i++) {\n        m = hd(&x,i+j)-hd(&y,i)-b;\n        if (m < 0) {\n          b = 1;\n          m = HLMAX + 1 + m;\n        }\n        else\n          b = 0;\n        if ((i+j)%2)\n          x.p[(i+j)/2] = LOW(x.p[(i+j)/2]) | (m << HALFDIGITBITS);\n        else\n          x.p[(i+j)/2] = (HIGH(x.p[(i+j)/2]) << HALFDIGITBITS) | m;\n      }\n      if (b) {\n        if ((j+i)%2)\n          x.p[(i+j)/2] -= b << HALFDIGITBITS;\n        else\n          x.p[(i+j)/2] -= b;\n      }\n    }\n    if (j%2)\n      q.p[j/2] |= qhat << HALFDIGITBITS;\n    else\n      q.p[j/2] |= qhat;\n    if (j == 0) break;\n  }\n  mpz_realloc(mrb,&r,(size_t)(yy->sz));\n  zero(&r);\n  urshift(mrb,&r,&x,ns);\n  mpz_set(mrb,rr,&r);\n  mpz_set(mrb,qq,&q);\n  mpz_clear(mrb,&x); mpz_clear(mrb,&y);\n  mpz_clear(mrb,&q); mpz_clear(mrb,&r);\n}\nstatic int\nmpz_init_set_str(mrb_state *mrb, mpz_t *x, const char *s, mrb_int len, mrb_int base)\n{\n  size_t i;\n  int retval = 0;\n  mpz_t t,m,bb;\n  short sn;\n  unsigned int k;\n  mpz_init(mrb,x);\n  mpz_init_set_int(mrb,&m,1);\n  mpz_init(mrb,&t);\n  zero(x);\n  if (*s == '-') {\n    sn = -1; s++;\n  }\n  else if (base < 0) {          /* trick: negative if base < 0 */\n    sn = -1; base = -base;\n  }\n  else\n    sn = 1;\n  mpz_init_set_int(mrb,&bb, base);\n  for (i = len-1;; i--) {\n    if (s[i]=='_') continue;\n    if (s[i] >= '0' && s[i] <= '9')\n      k = (unsigned int)s[i] - (unsigned int)'0';\n    else if (s[i] >= 'A' && s[i] <= 'Z')\n      k = (unsigned int)s[i] - (unsigned int)'A'+10;\n    else if (s[i] >= 'a' && s[i] <= 'z')\n      k = (unsigned int)s[i] - (unsigned int)'a'+10;\n    else {\n      retval = (-1);\n      break;\n    }\n    if (k >= base) {\n      retval = (-1);\n      break;\n    }\n    mpz_mul_int(mrb,&t,&m,(mrb_int)k);\n    mpz_add(mrb,x,x,&t);\n    mpz_mul(mrb,&m,&m,&bb);\n    if (i == 0) break;\n  }\n  if (x->sn)\n    x->sn = sn;\n  mpz_clear(mrb,&m);\n  mpz_clear(mrb,&bb);\n  mpz_clear(mrb,&t);\n  return retval;\n}\n",
    "target": 1,
    "idx": 1048873,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic void\nxmlParserPrintFileContextInternal(xmlParserInputPtr input ,\n\t\txmlGenericErrorFunc channel, void *data ) {\n    const xmlChar *cur, *base;\n    unsigned int n, col;\t/* GCC warns if signed, because compared with sizeof() */\n    xmlChar  content[81]; /* space for 80 chars + line terminator */\n    xmlChar *ctnt;\n\n    if ((input == NULL) || (input->cur == NULL))\n        return;\n\n    cur = input->cur;\n    base = input->base;\n    /* skip backwards over any end-of-lines */\n    while ((cur > base) && ((*(cur) == '\\n') || (*(cur) == '\\r'))) {\n\tcur--;\n    }\n    n = 0;\n    /* search backwards for beginning-of-line (to max buff size) */\n    while ((n++ < (sizeof(content)-1)) && (cur > base) &&\n\t   (*(cur) != '\\n') && (*(cur) != '\\r'))\n        cur--;\n    if ((*(cur) == '\\n') || (*(cur) == '\\r')) cur++;\n    /* calculate the error position in terms of the current position */\n    col = input->cur - cur;\n    /* search forward for end-of-line (to max buff size) */\n    n = 0;\n    ctnt = content;\n    /* copy selected text to our buffer */\n    while ((*cur != 0) && (*(cur) != '\\n') &&\n\t   (*(cur) != '\\r') && (n < sizeof(content)-1)) {\n\t\t*ctnt++ = *cur++;\n\tn++;\n    }\n    *ctnt = 0;\n    /* print out the selected text */\n    channel(data ,\"%s\\n\", content);\n    /* create blank line with problem pointer */\n    n = 0;\n    ctnt = content;\n    /* (leave buffer space for pointer + line terminator) */\n    while ((n<col) && (n++ < sizeof(content)-2) && (*ctnt != 0)) {\n\tif (*(ctnt) != '\\t')\n\t    *(ctnt) = ' ';\n\tctnt++;\n    }\n    *ctnt++ = '^';\n    *ctnt = 0;\n    channel(data ,\"%s\\n\", content);\n}\n\nstatic void\nxmlReportError(xmlErrorPtr err, xmlParserCtxtPtr ctxt, const char *str,\n               xmlGenericErrorFunc channel, void *data)\n{\n    char *file = NULL;\n    int line = 0;\n    int code = -1;\n    int domain;\n    const xmlChar *name = NULL;\n    xmlNodePtr node;\n    xmlErrorLevel level;\n    xmlParserInputPtr input = NULL;\n    xmlParserInputPtr cur = NULL;\n\n    if (err == NULL)\n        return;\n\n    if (channel == NULL) {\n\tchannel = xmlGenericError;\n\tdata = xmlGenericErrorContext;\n    }\n    file = err->file;\n    line = err->line;\n    code = err->code;\n    domain = err->domain;\n    level = err->level;\n    node = err->node;\n\n    if (code == XML_ERR_OK)\n        return;\n\n    if ((node != NULL) && (node->type == XML_ELEMENT_NODE))\n        name = node->name;\n\n    /*\n     * Maintain the compatibility with the legacy error handling\n     */\n    if (ctxt != NULL) {\n        input = ctxt->input;\n        if ((input != NULL) && (input->filename == NULL) &&\n            (ctxt->inputNr > 1)) {\n            cur = input;\n            input = ctxt->inputTab[ctxt->inputNr - 2];\n        }\n        if (input != NULL) {\n            if (input->filename)\n                channel(data, \"%s:%d: \", input->filename, input->line);\n            else if ((line != 0) && (domain == XML_FROM_PARSER))\n                channel(data, \"Entity: line %d: \", input->line);\n        }\n    } else {\n        if (file != NULL)\n            channel(data, \"%s:%d: \", file, line);\n        else if ((line != 0) &&\n\t         ((domain == XML_FROM_PARSER) || (domain == XML_FROM_SCHEMASV)||\n\t\t  (domain == XML_FROM_SCHEMASP)||(domain == XML_FROM_DTD) ||\n\t\t  (domain == XML_FROM_RELAXNGP)||(domain == XML_FROM_RELAXNGV)))\n            channel(data, \"Entity: line %d: \", line);\n    }\n    if (name != NULL) {\n        channel(data, \"element %s: \", name);\n    }\n    switch (domain) {\n        case XML_FROM_PARSER:\n            channel(data, \"parser \");\n            break;\n        case XML_FROM_NAMESPACE:\n            channel(data, \"namespace \");\n            break;\n        case XML_FROM_DTD:\n        case XML_FROM_VALID:\n            channel(data, \"validity \");\n            break;\n        case XML_FROM_HTML:\n            channel(data, \"HTML parser \");\n            break;\n        case XML_FROM_MEMORY:\n            channel(data, \"memory \");\n            break;\n        case XML_FROM_OUTPUT:\n            channel(data, \"output \");\n            break;\n        case XML_FROM_IO:\n            channel(data, \"I/O \");\n            break;\n        case XML_FROM_XINCLUDE:\n            channel(data, \"XInclude \");\n            break;\n        case XML_FROM_XPATH:\n            channel(data, \"XPath \");\n            break;\n        case XML_FROM_XPOINTER:\n            channel(data, \"parser \");\n            break;\n        case XML_FROM_REGEXP:\n            channel(data, \"regexp \");\n            break;\n        case XML_FROM_MODULE:\n            channel(data, \"module \");\n            break;\n        case XML_FROM_SCHEMASV:\n            channel(data, \"Schemas validity \");\n            break;\n        case XML_FROM_SCHEMASP:\n            channel(data, \"Schemas parser \");\n            break;\n        case XML_FROM_RELAXNGP:\n            channel(data, \"Relax-NG parser \");\n            break;\n        case XML_FROM_RELAXNGV:\n            channel(data, \"Relax-NG validity \");\n            break;\n        case XML_FROM_CATALOG:\n            channel(data, \"Catalog \");\n            break;\n        case XML_FROM_C14N:\n            channel(data, \"C14N \");\n            break;\n        case XML_FROM_XSLT:\n            channel(data, \"XSLT \");\n            break;\n        case XML_FROM_I18N:\n            channel(data, \"encoding \");\n            break;\n        case XML_FROM_SCHEMATRONV:\n            channel(data, \"schematron \");\n            break;\n        case XML_FROM_BUFFER:\n            channel(data, \"internal buffer \");\n            break;\n        case XML_FROM_URI:\n            channel(data, \"URI \");\n            break;\n        default:\n            break;\n    }\n    switch (level) {\n        case XML_ERR_NONE:\n            channel(data, \": \");\n            break;\n        case XML_ERR_WARNING:\n            channel(data, \"warning : \");\n            break;\n        case XML_ERR_ERROR:\n            channel(data, \"error : \");\n            break;\n        case XML_ERR_FATAL:\n            channel(data, \"error : \");\n            break;\n    }\n    if (str != NULL) {\n        int len;\n\tlen = xmlStrlen((const xmlChar *)str);\n\tif ((len > 0) && (str[len - 1] != '\\n'))\n\t    channel(data, \"%s\\n\", str);\n\telse\n\t    channel(data, \"%s\", str);\n    } else {\n        channel(data, \"%s\\n\", \"out of memory error\");\n    }\n\n    if (ctxt != NULL) {\n        xmlParserPrintFileContextInternal(input, channel, data);\n        if (cur != NULL) {\n            if (cur->filename)\n                channel(data, \"%s:%d: \\n\", cur->filename, cur->line);\n            else if ((line != 0) && (domain == XML_FROM_PARSER))\n                channel(data, \"Entity: line %d: \\n\", cur->line);\n            xmlParserPrintFileContextInternal(cur, channel, data);\n        }\n    }\n    if ((domain == XML_FROM_XPATH) && (err->str1 != NULL) &&\n        (err->int1 < 100) &&\n\t(err->int1 < xmlStrlen((const xmlChar *)err->str1))) {\n\txmlChar buf[150];\n\tint i;\n\n\tchannel(data, \"%s\\n\", err->str1);\n\tfor (i=0;i < err->int1;i++)\n\t     buf[i] = ' ';\n\tbuf[i++] = '^';\n\tbuf[i] = 0;\n\tchannel(data, \"%s\\n\", buf);\n    }\n}\n\nvoid XMLCDECL\n__xmlRaiseError(xmlStructuredErrorFunc schannel,\n              xmlGenericErrorFunc channel, void *data, void *ctx,\n              void *nod, int domain, int code, xmlErrorLevel level,\n              const char *file, int line, const char *str1,\n              const char *str2, const char *str3, int int1, int col,\n\t      const char *msg, ...)\n{\n    xmlParserCtxtPtr ctxt = NULL;\n    xmlNodePtr node = (xmlNodePtr) nod;\n    char *str = NULL;\n    xmlParserInputPtr input = NULL;\n    xmlErrorPtr to = &xmlLastError;\n    xmlNodePtr baseptr = NULL;\n\n    if (code == XML_ERR_OK)\n        return;\n    if ((xmlGetWarningsDefaultValue == 0) && (level == XML_ERR_WARNING))\n        return;\n    if ((domain == XML_FROM_PARSER) || (domain == XML_FROM_HTML) ||\n        (domain == XML_FROM_DTD) || (domain == XML_FROM_NAMESPACE) ||\n\t(domain == XML_FROM_IO) || (domain == XML_FROM_VALID)) {\n\tctxt = (xmlParserCtxtPtr) ctx;\n\tif ((schannel == NULL) && (ctxt != NULL) && (ctxt->sax != NULL) &&\n\t    (ctxt->sax->initialized == XML_SAX2_MAGIC) &&\n\t    (ctxt->sax->serror != NULL)) {\n\t    schannel = ctxt->sax->serror;\n\t    data = ctxt->userData;\n\t}\n    }\n    /*\n     * Check if structured error handler set\n     */\n    if (schannel == NULL) {\n\tschannel = xmlStructuredError;\n\t/*\n\t * if user has defined handler, change data ptr to user's choice\n\t */\n\tif (schannel != NULL)\n\t    data = xmlStructuredErrorContext;\n    }\n    /*\n     * Formatting the message\n     */\n    if (msg == NULL) {\n        str = (char *) xmlStrdup(BAD_CAST \"No error message provided\");\n    } else {\n        XML_GET_VAR_STR(msg, str);\n    }\n\n    /*\n     * specific processing if a parser context is provided\n     */\n    if (ctxt != NULL) {\n        if (file == NULL) {\n            input = ctxt->input;\n            if ((input != NULL) && (input->filename == NULL) &&\n                (ctxt->inputNr > 1)) {\n                input = ctxt->inputTab[ctxt->inputNr - 2];\n            }\n            if (input != NULL) {\n                file = input->filename;\n                line = input->line;\n                col = input->col;\n            }\n        }\n        to = &ctxt->lastError;\n    } else if ((node != NULL) && (file == NULL)) {\n\tint i;\n\n\tif ((node->doc != NULL) && (node->doc->URL != NULL)) {\n\t    baseptr = node;\n/*\t    file = (const char *) node->doc->URL; */\n\t}\n\tfor (i = 0;\n\t     ((i < 10) && (node != NULL) && (node->type != XML_ELEMENT_NODE));\n\t     i++)\n\t     node = node->parent;\n        if ((baseptr == NULL) && (node != NULL) &&\n\t    (node->doc != NULL) && (node->doc->URL != NULL))\n\t    baseptr = node;\n\n\tif ((node != NULL) && (node->type == XML_ELEMENT_NODE))\n\t    line = node->line;\n\tif ((line == 0) || (line == 65535))\n\t    line = xmlGetLineNo(node);\n    }\n\n    /*\n     * Save the information about the error\n     */\n    xmlResetError(to);\n    to->domain = domain;\n    to->code = code;\n    to->message = str;\n    to->level = level;\n    if (file != NULL)\n        to->file = (char *) xmlStrdup((const xmlChar *) file);\n    else if (baseptr != NULL) {\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t/*\n\t * We check if the error is within an XInclude section and,\n\t * if so, attempt to print out the href of the XInclude instead\n\t * of the usual \"base\" (doc->URL) for the node (bug 152623).\n\t */\n        xmlNodePtr prev = baseptr;\n\tint inclcount = 0;\n\twhile (prev != NULL) {\n\t    if (prev->prev == NULL)\n\t        prev = prev->parent;\n\t    else {\n\t        prev = prev->prev;\n\t\tif (prev->type == XML_XINCLUDE_START) {\n\t\t    if (--inclcount < 0)\n\t\t        break;\n\t\t} else if (prev->type == XML_XINCLUDE_END)\n\t\t    inclcount++;\n\t    }\n\t}\n\tif (prev != NULL) {\n\t    if (prev->type == XML_XINCLUDE_START) {\n\t\tprev->type = XML_ELEMENT_NODE;\n\t\tto->file = (char *) xmlGetProp(prev, BAD_CAST \"href\");\n\t\tprev->type = XML_XINCLUDE_START;\n\t    } else {\n\t\tto->file = (char *) xmlGetProp(prev, BAD_CAST \"href\");\n\t    }\n\t} else\n#endif\n\t    to->file = (char *) xmlStrdup(baseptr->doc->URL);\n\tif ((to->file == NULL) && (node != NULL) && (node->doc != NULL)) {\n\t    to->file = (char *) xmlStrdup(node->doc->URL);\n\t}\n    }\n    to->line = line;\n    if (str1 != NULL)\n        to->str1 = (char *) xmlStrdup((const xmlChar *) str1);\n    if (str2 != NULL)\n        to->str2 = (char *) xmlStrdup((const xmlChar *) str2);\n    if (str3 != NULL)\n        to->str3 = (char *) xmlStrdup((const xmlChar *) str3);\n    to->int1 = int1;\n    to->int2 = col;\n    to->node = node;\n    to->ctxt = ctx;\n\n    if (to != &xmlLastError)\n        xmlCopyError(to,&xmlLastError);\n\n    if (schannel != NULL) {\n\tschannel(data, to);\n\treturn;\n    }\n\n    /*\n     * Find the callback channel if channel param is NULL\n     */\n    if ((ctxt != NULL) && (channel == NULL) &&\n        (xmlStructuredError == NULL) && (ctxt->sax != NULL)) {\n        if (level == XML_ERR_WARNING)\n\t    channel = ctxt->sax->warning;\n        else\n\t    channel = ctxt->sax->error;\n\tdata = ctxt->userData;\n    } else if (channel == NULL) {\n\tchannel = xmlGenericError;\n\tif (ctxt != NULL) {\n\t    data = ctxt;\n\t} else {\n\t    data = xmlGenericErrorContext;\n\t}\n    }\n    if (channel == NULL)\n        return;\n\n    if ((channel == xmlParserError) ||\n        (channel == xmlParserWarning) ||\n\t(channel == xmlParserValidityError) ||\n\t(channel == xmlParserValidityWarning))\n\txmlReportError(to, ctxt, str, NULL, NULL);\n    else if (((void(*)(void)) channel == (void(*)(void)) fprintf) ||\n             (channel == xmlGenericErrorDefaultFunc))\n\txmlReportError(to, ctxt, str, channel, data);\n    else\n\tchannel(data, \"%s\", str);\n}\n\n\n\n\n// target function\nstatic int\nhtmlParseLookupSequence(htmlParserCtxtPtr ctxt, xmlChar first,\n                        xmlChar next, xmlChar third, int iscomment,\n                        int ignoreattrval)\n{\n    int base, len;\n    htmlParserInputPtr in;\n    const xmlChar *buf;\n    int incomment = 0;\n    int invalue = 0;\n    char valdellim = 0x0;\n\n    in = ctxt->input;\n    if (in == NULL)\n        return (-1);\n\n    base = in->cur - in->base;\n    if (base < 0)\n        return (-1);\n\n    if (ctxt->checkIndex > base)\n        base = ctxt->checkIndex;\n\n    if (in->buf == NULL) {\n        buf = in->base;\n        len = in->length;\n    } else {\n        buf = xmlBufContent(in->buf->buffer);\n        len = xmlBufUse(in->buf->buffer);\n    }\n\n    /* take into account the sequence length */\n    if (third)\n        len -= 2;\n    else if (next)\n        len--;\n    for (; base < len; base++) {\n        if ((!incomment) && (base + 4 < len) && (!iscomment)) {\n            if ((buf[base] == '<') && (buf[base + 1] == '!') &&\n                (buf[base + 2] == '-') && (buf[base + 3] == '-')) {\n                incomment = 1;\n                /* do not increment past <! - some people use <!--> */\n                base += 2;\n            }\n        }\n        if (ignoreattrval) {\n            if (buf[base] == '\"' || buf[base] == '\\'') {\n                if (invalue) {\n                    if (buf[base] == valdellim) {\n                        invalue = 0;\n                        continue;\n                    }\n                } else {\n                    valdellim = buf[base];\n                    invalue = 1;\n                    continue;\n                }\n            } else if (invalue) {\n                continue;\n            }\n        }\n        if (incomment) {\n            if (base + 3 > len)\n                return (-1);\n            if ((buf[base] == '-') && (buf[base + 1] == '-') &&\n                (buf[base + 2] == '>')) {\n                incomment = 0;\n                base += 2;\n            }\n            continue;\n        }\n        if (buf[base] == first) {\n            if (third != 0) {\n                if ((buf[base + 1] != next) || (buf[base + 2] != third))\n                    continue;\n            } else if (next != 0) {\n                if (buf[base + 1] != next)\n                    continue;\n            }\n            ctxt->checkIndex = 0;\n#ifdef DEBUG_PUSH\n            if (next == 0)\n                xmlGenericError(xmlGenericErrorContext,\n                                \"HPP: lookup '%c' found at %d\\n\",\n                                first, base);\n            else if (third == 0)\n                xmlGenericError(xmlGenericErrorContext,\n                                \"HPP: lookup '%c%c' found at %d\\n\",\n                                first, next, base);\n            else\n                xmlGenericError(xmlGenericErrorContext,\n                                \"HPP: lookup '%c%c%c' found at %d\\n\",\n                                first, next, third, base);\n#endif\n            return (base - (in->cur - in->base));\n        }\n    }\n    if ((!incomment) && (!invalue))\n        ctxt->checkIndex = base;\n#ifdef DEBUG_PUSH\n    if (next == 0)\n        xmlGenericError(xmlGenericErrorContext,\n                        \"HPP: lookup '%c' failed\\n\", first);\n    else if (third == 0)\n        xmlGenericError(xmlGenericErrorContext,\n                        \"HPP: lookup '%c%c' failed\\n\", first, next);\n    else\n        xmlGenericError(xmlGenericErrorContext,\n                        \"HPP: lookup '%c%c%c' failed\\n\", first, next,\n                        third);\n#endif\n    return (-1);\n}\n",
    "target": 1,
    "idx": 1023765,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\ndig_t bn_rshb_low(dig_t *c, const dig_t *a, int size, int bits) {\n\tint i;\n\tdig_t r, carry, shift, mask;\n\n\tc += size - 1;\n\ta += size - 1;\n\t/* Prepare the bit mask. */\n\tshift = (RLC_DIG - bits) % RLC_DIG;\n\tcarry = 0;\n\tmask = RLC_MASK(bits);\n\tfor (i = size - 1; i >= 0; i--, a--, c--) {\n\t\t/* Get the needed least significant bits. */\n\t\tr = (*a) & mask;\n\t\t/* Shift left the operand. */\n\t\t*c = ((*a) >> bits) | (carry << shift);\n\t\t/* Update the carry. */\n\t\tcarry = r;\n\t}\n\treturn carry;\n}\n\nbool Add::Run(Datasource& ds, Bignum& res, std::vector<Bignum>& bn) const {\n    (void)ds;\n\n    RLC_TRY {\n        /* noret */ bn_add(res.Get(), bn[0].Get(), bn[1].Get());\n    } RLC_CATCH_ANY {\n\nstd::optional<component::Bignum> relic::OpBignumCalc(operation::BignumCalc& op) {\n    std::optional<component::Bignum> ret = std::nullopt;\n    Datasource ds(op.modifier.GetPtr(), op.modifier.GetSize());\n\n    relic_bignum::Bignum res(ds);\n    std::vector<relic_bignum::Bignum> bn = {\n        std::move(relic_bignum::Bignum(ds)),\n        std::move(relic_bignum::Bignum(ds)),\n        std::move(relic_bignum::Bignum(ds)),\n        std::move(relic_bignum::Bignum(ds)),\n    };\n\n    std::unique_ptr<relic_bignum::Operation> opRunner = nullptr;\n\n    CF_CHECK_TRUE(res.Set(\"0\"));\n    CF_CHECK_TRUE(bn[0].Set(op.bn0.ToString(ds)));\n    CF_CHECK_TRUE(bn[1].Set(op.bn1.ToString(ds)));\n    CF_CHECK_TRUE(bn[2].Set(op.bn2.ToString(ds)));\n    CF_CHECK_TRUE(bn[3].Set(op.bn3.ToString(ds)));\n\n    switch ( op.calcOp.Get() ) {\n        case    CF_CALCOP(\"Add(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::Add>();\n            break;\n        case    CF_CALCOP(\"Sub(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::Sub>();\n            break;\n        case    CF_CALCOP(\"Mul(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::Mul>();\n            break;\n        case    CF_CALCOP(\"Sqr(A)\"):\n            opRunner = std::make_unique<relic_bignum::Sqr>();\n            break;\n        case    CF_CALCOP(\"Div(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::Div>();\n            break;\n        case    CF_CALCOP(\"GCD(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::GCD>();\n            break;\n        case    CF_CALCOP(\"LCM(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::LCM>();\n            break;\n        case    CF_CALCOP(\"InvMod(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::InvMod>();\n            break;\n        case    CF_CALCOP(\"LShift1(A)\"):\n            opRunner = std::make_unique<relic_bignum::LShift1>();\n            break;\n        case    CF_CALCOP(\"Jacobi(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::Jacobi>();\n            break;\n        case    CF_CALCOP(\"Cmp(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::Cmp>();\n            break;\n        case    CF_CALCOP(\"Mod(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::Mod>();\n            break;\n        case    CF_CALCOP(\"IsEven(A)\"):\n            opRunner = std::make_unique<relic_bignum::IsEven>();\n            break;\n        case    CF_CALCOP(\"IsOdd(A)\"):\n            opRunner = std::make_unique<relic_bignum::IsOdd>();\n            break;\n        case    CF_CALCOP(\"IsZero(A)\"):\n            opRunner = std::make_unique<relic_bignum::IsZero>();\n            break;\n        case    CF_CALCOP(\"Neg(A)\"):\n            opRunner = std::make_unique<relic_bignum::Neg>();\n            break;\n        case    CF_CALCOP(\"Sqrt(A)\"):\n            opRunner = std::make_unique<relic_bignum::Sqrt>();\n            break;\n        case    CF_CALCOP(\"Abs(A)\"):\n            opRunner = std::make_unique<relic_bignum::Abs>();\n            break;\n        case    CF_CALCOP(\"ExpMod(A,B,C)\"):\n            opRunner = std::make_unique<relic_bignum::ExpMod>();\n            break;\n        case    CF_CALCOP(\"NumBits(A)\"):\n            opRunner = std::make_unique<relic_bignum::NumBits>();\n            break;\n        case    CF_CALCOP(\"CmpAbs(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::CmpAbs>();\n            break;\n        case    CF_CALCOP(\"RShift(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::RShift>();\n            break;\n        case    CF_CALCOP(\"Bit(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::Bit>();\n            break;\n        case    CF_CALCOP(\"SetBit(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::SetBit>();\n            break;\n        case    CF_CALCOP(\"ClearBit(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::ClearBit>();\n            break;\n    }\n\n    CF_CHECK_NE(opRunner, nullptr);\n    CF_CHECK_EQ(opRunner->Run(ds, res, bn), true);\n\n    ret = res.ToComponentBignum();\n\nend:\n    return ret;\n}\n\ntemplate<> std::optional<bool> ExecutorBase<bool, operation::Verify>::callModule(std::shared_ptr<Module> module, operation::Verify& op) const {\n    return module->OpVerify(op);\n}\n\nvoid ExecutorBase<ResultType, OperationType>::Run(Datasource& parentDs, const uint8_t* data, const size_t size) const {\n    typename ExecutorBase<ResultType, OperationType>::ResultSet results;\n\n    std::vector< std::pair<std::shared_ptr<Module>, OperationType> > operations;\n\n    do {\n        auto op = getOp(&parentDs, data, size);\n        auto module = getModule(parentDs);\n        if ( module == nullptr ) {\n            continue;\n        }\n\n        operations.push_back( {module, op} );\n\n        /* Limit number of operations per run to prevent time-outs */\n        if ( operations.size() == OperationType::MaxOperations() ) {\n            break;\n        }\n    } while ( parentDs.Get<bool>() == true );\n\n    if ( operations.empty() == true ) {\n        return;\n    }\n\n    /* Enable this to run every operation on every loaded module */\n#if 1\n    {\n        std::set<uint64_t> moduleIDs;\n        for (const auto& m : modules ) {\n            const auto moduleID = m.first;\n\n            /* Skip if this is a disabled module */\n            if ( options.disableModules != std::nullopt ) {\n                if ( std::find(\n                            options.disableModules->begin(),\n                            options.disableModules->end(),\n                            moduleID) != options.disableModules->end() ) {\n                    continue;\n                }\n            }\n            moduleIDs.insert(moduleID);\n        }\n\n        std::set<uint64_t> operationModuleIDs;\n        for (const auto& op : operations) {\n            operationModuleIDs.insert(op.first->ID);\n        }\n\n        std::vector<uint64_t> addModuleIDs(moduleIDs.size());\n        auto it = std::set_difference(moduleIDs.begin(), moduleIDs.end(), operationModuleIDs.begin(), operationModuleIDs.end(), addModuleIDs.begin());\n        addModuleIDs.resize(it - addModuleIDs.begin());\n\n        for (const auto& id : addModuleIDs) {\n            operations.push_back({ modules.at(id), operations[0].second});\n        }\n    }\n#endif\n\n    if ( operations.size() < options.minModules ) {\n        return;\n    }\n\n    if ( options.debug == true && !operations.empty() ) {\n        printf(\"Running:\\n%s\\n\", operations[0].second.ToString().c_str());\n    }\n    for (size_t i = 0; i < operations.size(); i++) {\n        auto& operation = operations[i];\n\n        auto& module = operation.first;\n        auto& op = operation.second;\n\n        if ( i > 0 ) {\n            auto& prevModule = operations[i-1].first;\n            auto& prevOp = operations[i].second;\n\n            if ( prevModule == module && prevOp.modifier == op.modifier ) {\n                auto& curModifier = op.modifier.GetVectorPtr();\n                if ( curModifier.size() == 0 ) {\n                    for (size_t j = 0; j < 512; j++) {\n                        curModifier.push_back(1);\n                    }\n                } else {\n                    for (auto& c : curModifier) {\n                        c++;\n                    }\n                }\n            }\n        }\n\n        results.push_back( {module, std::move(callModule(module, op))} );\n\n        const auto& result = results.back();\n\n        if ( result.second != std::nullopt ) {\n            updateExtraCounters(module->ID, op);\n\n            if ( options.jsonDumpFP != std::nullopt ) {\n                nlohmann::json j;\n                j[\"operation\"] = op.ToJSON();\n                j[\"result\"] = util::ToJSON(*result.second);\n                fprintf(*options.jsonDumpFP, \"%s\\n\", j.dump().c_str());\n            }\n        }\n\n        if ( options.debug == true ) {\n            printf(\"Module %s result:\\n\\n%s\\n\\n\",\n                    result.first->name.c_str(),\n                    result.second == std::nullopt ?\n                        \"(empty)\" :\n                        util::ToString(*result.second).c_str());\n        }\n\n        if ( options.disableTests == false ) {\n            tests::test(op, result.second);\n        }\n\n        postprocess(module, op, result);\n    }\n\n    if ( options.noCompare == false ) {\n        compare(operations, results, data, size);\n    }\n}\n\nvoid Driver::Run(const uint8_t* data, const size_t size) const {\n    using fuzzing::datasource::ID;\n\n    static ExecutorDigest executorDigest(CF_OPERATION(\"Digest\"), modules, options);\n    static ExecutorHMAC executorHMAC(CF_OPERATION(\"HMAC\"), modules, options);\n    static ExecutorCMAC executorCMAC(CF_OPERATION(\"CMAC\"), modules, options);\n    static ExecutorSymmetricEncrypt executorSymmetricEncrypt(CF_OPERATION(\"SymmetricEncrypt\"), modules, options);\n    static ExecutorSymmetricDecrypt executorSymmetricDecrypt(CF_OPERATION(\"SymmetricDecrypt\"), modules, options);\n    static ExecutorKDF_SCRYPT executorKDF_SCRYPT(CF_OPERATION(\"KDF_SCRYPT\"), modules, options);\n    static ExecutorKDF_HKDF executorKDF_HKDF(CF_OPERATION(\"KDF_HKDF\"), modules, options);\n    static ExecutorKDF_TLS1_PRF executorKDF_TLS1_PRF(CF_OPERATION(\"KDF_TLS1_PRF\"), modules, options);\n    static ExecutorKDF_PBKDF executorKDF_PBKDF(CF_OPERATION(\"KDF_PBKDF\"), modules, options);\n    static ExecutorKDF_PBKDF1 executorKDF_PBKDF1(CF_OPERATION(\"KDF_PBKDF1\"), modules, options);\n    static ExecutorKDF_PBKDF2 executorKDF_PBKDF2(CF_OPERATION(\"KDF_PBKDF2\"), modules, options);\n    static ExecutorKDF_ARGON2 executorKDF_ARGON2(CF_OPERATION(\"KDF_ARGON2\"), modules, options);\n    static ExecutorKDF_SSH executorKDF_SSH(ID(\"Cryptofuzz/Operation/KDF_SSH\"), modules, options);\n    static ExecutorKDF_X963 executorKDF_X963(CF_OPERATION(\"KDF_X963\"), modules, options);\n    static ExecutorKDF_BCRYPT executorKDF_BCRYPT(CF_OPERATION(\"KDF_BCRYPT\"), modules, options);\n    static ExecutorKDF_SP_800_108 executorKDF_SP_800_108(CF_OPERATION(\"KDF_SP_800_108\"), modules, options);\n    static ExecutorECC_PrivateToPublic executorECC_PrivateToPublic(CF_OPERATION(\"ECC_PrivateToPublic\"), modules, options);\n    static ExecutorECC_ValidatePubkey executorECC_ValidatePubkey(CF_OPERATION(\"ECC_ValidatePubkey\"), modules, options);\n    static ExecutorECC_GenerateKeyPair executorECC_GenerateKeyPair(CF_OPERATION(\"ECC_GenerateKeyPair\"), modules, options);\n    static ExecutorECDSA_Sign executorECDSA_Sign(CF_OPERATION(\"ECDSA_Sign\"), modules, options);\n    static ExecutorECDSA_Verify executorECDSA_Verify(CF_OPERATION(\"ECDSA_Verify\"), modules, options);\n    static ExecutorECDH_Derive executorECDH_Derive(CF_OPERATION(\"ECDH_Derive\"), modules, options);\n    static ExecutorECIES_Encrypt executorECIES_Encrypt(CF_OPERATION(\"ECIES_Encrypt\"), modules, options);\n    static ExecutorDH_GenerateKeyPair executorDH_GenerateKeyPair(CF_OPERATION(\"DH_GenerateKeyPair\"), modules, options);\n    static ExecutorDH_Derive executorDH_Derive(CF_OPERATION(\"DH_Derive\"), modules, options);\n    static ExecutorBignumCalc executorBignumCalc(CF_OPERATION(\"BignumCalc\"), modules, options);\n\n    try {\n\n        Datasource ds(data, size);\n\n        const auto operation = ds.Get<uint64_t>();\n\n        /* Only run whitelisted operations, if specified */\n        if ( options.operations != std::nullopt ) {\n            if ( std::find(\n                    options.operations->begin(),\n                    options.operations->end(),\n                    operation) == options.operations->end() ) {\n                return;\n            }\n        }\n        const auto payload = ds.GetData(0, 1);\n\n        switch ( operation ) {\n            case CF_OPERATION(\"Digest\"):\n                executorDigest.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"HMAC\"):\n                executorHMAC.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"CMAC\"):\n                executorCMAC.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"SymmetricEncrypt\"):\n                executorSymmetricEncrypt.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"SymmetricDecrypt\"):\n                executorSymmetricDecrypt.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"KDF_SCRYPT\"):\n                executorKDF_SCRYPT.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"KDF_HKDF\"):\n                executorKDF_HKDF.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"KDF_TLS1_PRF\"):\n                executorKDF_TLS1_PRF.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"KDF_PBKDF\"):\n                executorKDF_PBKDF.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"KDF_PBKDF1\"):\n                executorKDF_PBKDF1.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"KDF_PBKDF2\"):\n                executorKDF_PBKDF2.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"KDF_ARGON2\"):\n                executorKDF_ARGON2.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"KDF_SSH\"):\n                executorKDF_SSH.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"KDF_X963\"):\n                executorKDF_X963.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"KDF_BCRYPT\"):\n                executorKDF_BCRYPT.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"KDF_SP_800_108\"):\n                executorKDF_SP_800_108.Run(ds, payload.data(), payload.size());\n                break;\n#if 0\n            case    ID(\"Cryptofuzz/Operation/Sign\"):\n                executorSign.Run(ds, payload.data(), payload.size());\n                break;\n            case    ID(\"Cryptofuzz/Operation/Verify\"):\n                executorVerify.Run(ds, payload.data(), payload.size());\n                break;\n#endif\n            case CF_OPERATION(\"ECC_PrivateToPublic\"):\n                executorECC_PrivateToPublic.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"ECC_ValidatePubkey\"):\n                executorECC_ValidatePubkey.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"ECC_GenerateKeyPair\"):\n                executorECC_GenerateKeyPair.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"ECDSA_Sign\"):\n                executorECDSA_Sign.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"ECDSA_Verify\"):\n                executorECDSA_Verify.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"ECDH_Derive\"):\n                executorECDH_Derive.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"ECIES_Encrypt\"):\n                executorECIES_Encrypt.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"DH_GenerateKeyPair\"):\n                executorDH_GenerateKeyPair.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"DH_Derive\"):\n                executorDH_Derive.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"BignumCalc\"):\n                executorBignumCalc.Run(ds, payload.data(), payload.size());\n                break;\n        }\n    } catch ( Datasource::OutOfData ) {\n    }\n};\n\n\n// target function\nvoid bn_rsh(bn_t c, const bn_t a, int bits) {\n\tint digits = 0;\n\n\tif (bits <= 0) {\n\t\tbn_copy(c, a);\n\t\treturn;\n\t}\n\n\tRLC_RIP(bits, digits, bits);\n\n\tif (digits > 0) {\n\t\tbn_rshd_low(c->dp, a->dp, a->used, digits);\n\t}\n\tc->used = a->used - digits;\n\tc->sign = a->sign;\n\n\tif (c->used > 0 && bits > 0) {\n\t\tif (digits == 0 && c != a) {\n\t\t\tbn_rshb_low(c->dp, a->dp + digits, a->used - digits, bits);\n\t\t} else {\n\t\t\tbn_rshb_low(c->dp, c->dp, c->used, bits);\n\t\t}\n\t}\n\tbn_trim(c);\n}\n",
    "target": 1,
    "idx": 1030340,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nint cil_symtab_get_datum(symtab_t *symtab, char *key, struct cil_symtab_datum **datum)\n{\n\t*datum = (struct cil_symtab_datum*)hashtab_search(symtab->table, (hashtab_key_t)key);\n\tif (*datum == NULL) {\n\t\treturn SEPOL_ENOENT;\n\t}\n\n\treturn SEPOL_OK;\n}\n\n\n\nint cil_resolve_classperms(struct cil_tree_node *current, struct cil_classperms *cp, void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_symtab_datum *datum = NULL;\n\tsymtab_t *common_symtab = NULL;\n\tstruct cil_class *class;\n\n\trc = cil_resolve_name(current, cp->class_str, CIL_SYM_CLASSES, extra_args, &datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tclass = (struct cil_class *)datum;\n\n\tif (class->common != NULL) {\n\t\tcommon_symtab = &class->common->perms;\n\t}\n\n\tcp->class = class;\n\n\trc = __cil_resolve_perms(&class->perms, common_symtab, cp->perm_strs, &cp->perms, FLAVOR(datum));\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_classperms_list(struct cil_tree_node *current, struct cil_list *cp_list, void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_list_item *curr;\n\n\tcil_list_for_each(curr, cp_list) {\n\t\tif (curr->flavor == CIL_CLASSPERMS) {\n\t\t\trc = cil_resolve_classperms(current, curr->data, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t} else {\n\t\t\trc = cil_resolve_classperms_set(current, curr->data, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_classpermissionset(struct cil_tree_node *current, struct cil_classpermissionset *cps, void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_args_resolve *args = extra_args;\n\tstruct cil_list_item *curr;\n\tstruct cil_symtab_datum *datum;\n\tstruct cil_classpermission *cp;\n\n\trc = cil_resolve_name(current, cps->set_str, CIL_SYM_CLASSPERMSETS, args, &datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\trc = cil_resolve_classperms_list(current, cps->classperms, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcp = (struct cil_classpermission *)datum;\n\n\tif (cp->classperms == NULL) {\n\t\tcil_list_init(&cp->classperms, CIL_CLASSPERMS);\n\t}\n\n\tcil_list_for_each(curr, cps->classperms) {\n\t\tcil_list_append(cp->classperms, curr->flavor, curr->data);\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\n\n\n\n\nint cil_tree_walk_core(struct cil_tree_node *node,\n\t\t\t\t\t   int (*process_node)(struct cil_tree_node *node, uint32_t *finished, void *extra_args),\n\t\t\t\t\t   int (*first_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t\t   int (*last_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t\t   void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\twhile (node) {\n\t\tuint32_t finished = CIL_TREE_SKIP_NOTHING;\n\n\t\tif (process_node != NULL) {\n\t\t\trc = (*process_node)(node, &finished, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tif (finished & CIL_TREE_SKIP_NEXT) {\n\t\t\treturn SEPOL_OK;\n\t\t}\n\n\t\tif (node->cl_head != NULL && !(finished & CIL_TREE_SKIP_HEAD)) {\n\t\t\trc = cil_tree_walk(node, process_node, first_child, last_child, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tnode = node->next;\n\t}\n\n\treturn SEPOL_OK;\n}\n\nint cil_tree_walk(struct cil_tree_node *node, \n\t\t\t\t  int (*process_node)(struct cil_tree_node *node, uint32_t *finished, void *extra_args), \n\t\t\t\t  int (*first_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t  int (*last_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t  void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\tif (!node || !node->cl_head) {\n\t\treturn SEPOL_OK;\n\t}\n\n\tif (first_child != NULL) {\n\t\trc = (*first_child)(node->cl_head, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = cil_tree_walk_core(node->cl_head, process_node, first_child, last_child, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\treturn rc;\n\t}\n\n\tif (last_child != NULL) {\n\t\trc = (*last_child)(node->cl_tail, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n}\n\nint cil_tree_walk_core(struct cil_tree_node *node,\n\t\t\t\t\t   int (*process_node)(struct cil_tree_node *node, uint32_t *finished, void *extra_args),\n\t\t\t\t\t   int (*first_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t\t   int (*last_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t\t   void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\twhile (node) {\n\t\tuint32_t finished = CIL_TREE_SKIP_NOTHING;\n\n\t\tif (process_node != NULL) {\n\t\t\trc = (*process_node)(node, &finished, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tif (finished & CIL_TREE_SKIP_NEXT) {\n\t\t\treturn SEPOL_OK;\n\t\t}\n\n\t\tif (node->cl_head != NULL && !(finished & CIL_TREE_SKIP_HEAD)) {\n\t\t\trc = cil_tree_walk(node, process_node, first_child, last_child, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tnode = node->next;\n\t}\n\n\treturn SEPOL_OK;\n}\n\nint cil_tree_walk(struct cil_tree_node *node, \n\t\t\t\t  int (*process_node)(struct cil_tree_node *node, uint32_t *finished, void *extra_args), \n\t\t\t\t  int (*first_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t  int (*last_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t  void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\tif (!node || !node->cl_head) {\n\t\treturn SEPOL_OK;\n\t}\n\n\tif (first_child != NULL) {\n\t\trc = (*first_child)(node->cl_head, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = cil_tree_walk_core(node->cl_head, process_node, first_child, last_child, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\treturn rc;\n\t}\n\n\tif (last_child != NULL) {\n\t\trc = (*last_child)(node->cl_tail, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n}\n\nint cil_tree_walk_core(struct cil_tree_node *node,\n\t\t\t\t\t   int (*process_node)(struct cil_tree_node *node, uint32_t *finished, void *extra_args),\n\t\t\t\t\t   int (*first_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t\t   int (*last_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t\t   void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\twhile (node) {\n\t\tuint32_t finished = CIL_TREE_SKIP_NOTHING;\n\n\t\tif (process_node != NULL) {\n\t\t\trc = (*process_node)(node, &finished, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tif (finished & CIL_TREE_SKIP_NEXT) {\n\t\t\treturn SEPOL_OK;\n\t\t}\n\n\t\tif (node->cl_head != NULL && !(finished & CIL_TREE_SKIP_HEAD)) {\n\t\t\trc = cil_tree_walk(node, process_node, first_child, last_child, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tnode = node->next;\n\t}\n\n\treturn SEPOL_OK;\n}\n\nint cil_tree_walk(struct cil_tree_node *node, \n\t\t\t\t  int (*process_node)(struct cil_tree_node *node, uint32_t *finished, void *extra_args), \n\t\t\t\t  int (*first_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t  int (*last_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t  void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\tif (!node || !node->cl_head) {\n\t\treturn SEPOL_OK;\n\t}\n\n\tif (first_child != NULL) {\n\t\trc = (*first_child)(node->cl_head, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = cil_tree_walk_core(node->cl_head, process_node, first_child, last_child, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\treturn rc;\n\t}\n\n\tif (last_child != NULL) {\n\t\trc = (*last_child)(node->cl_tail, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n}\n\nint __cil_resolve_ast_last_child_helper(struct cil_tree_node *current, void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_args_resolve *args = extra_args;\n\tstruct cil_tree_node *parent = NULL;\n\tstruct cil_tree_node *blockstack = NULL;\n\n\tif (current == NULL ||  extra_args == NULL) {\n\t\tgoto exit;\n\t}\n\n\tparent = current->parent;\n\n\tif (parent->flavor == CIL_MACRO) {\n\t\targs->macro = NULL;\n\t} else if (parent->flavor == CIL_OPTIONAL) {\n\t\tstruct cil_tree_node *optstack;\n\n\t\tif (((struct cil_optional *)parent->data)->enabled == CIL_FALSE) {\n\t\t\t*(args->changed) = CIL_TRUE;\n\t\t\tcil_list_append(args->disabled_optionals, CIL_NODE, parent);\n\t\t}\n\n\t\t/* pop off the stack */\n\t\toptstack = args->optstack;\n\t\targs->optstack = optstack->cl_head;\n\t\tif (optstack->cl_head) {\n\t\t\toptstack->cl_head->parent = NULL;\n\t\t}\n\t\tfree(optstack);\n\t} else if (parent->flavor == CIL_BOOLEANIF) {\n\t\targs->boolif = NULL;\n\t} else if (parent->flavor == CIL_BLOCK) {\n\t\t/* pop off the stack */\n\t\tblockstack = args->blockstack;\n\t\targs->blockstack = blockstack->cl_head;\n\t\tif (blockstack->cl_head) {\n\t\t\tblockstack->cl_head->parent = NULL;\n\t\t}\n\t\tfree(blockstack);\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_compile(struct cil_db *db)\n{\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL) {\n\t\tgoto exit;\n\t}\n\n\tcil_log(CIL_INFO, \"Building AST from Parse Tree\\n\");\n\trc = cil_build_ast(db, db->parse->root, db->ast->root);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_INFO, \"Failed to build ast\\n\");\n\t\tgoto exit;\n\t}\n\n\tcil_log(CIL_INFO, \"Destroying Parse Tree\\n\");\n\tcil_tree_destroy(&db->parse);\n\n\tcil_log(CIL_INFO, \"Resolving AST\\n\");\n\trc = cil_resolve_ast(db, db->ast->root);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_INFO, \"Failed to resolve ast\\n\");\n\t\tgoto exit;\n\t}\n\n\tcil_log(CIL_INFO, \"Qualifying Names\\n\");\n\trc = cil_fqn_qualify(db->ast->root);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_INFO, \"Failed to qualify names\\n\");\n\t\tgoto exit;\n\t}\n\n\tcil_log(CIL_INFO, \"Compile post process\\n\");\n\trc = cil_post_process(db);\n\tif (rc != SEPOL_OK ) {\n\t\tcil_log(CIL_INFO, \"Post process failed\\n\");\n\t\tgoto exit;\n\t}\n\nexit:\n\n\treturn rc;\n}\n\n\n// target function\nint __cil_resolve_ast_last_child_helper(struct cil_tree_node *current, void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_args_resolve *args = extra_args;\n\tstruct cil_tree_node *parent = NULL;\n\tstruct cil_tree_node *blockstack = NULL;\n\n\tif (current == NULL ||  extra_args == NULL) {\n\t\tgoto exit;\n\t}\n\n\tparent = current->parent;\n\n\tif (parent->flavor == CIL_MACRO) {\n\t\targs->macro = NULL;\n\t} else if (parent->flavor == CIL_OPTIONAL) {\n\t\tstruct cil_tree_node *optstack;\n\n\t\tif (((struct cil_optional *)parent->data)->enabled == CIL_FALSE) {\n\t\t\t*(args->changed) = CIL_TRUE;\n\t\t\tcil_tree_children_destroy(parent);\n\t\t}\n\n\t\t/* pop off the stack */\n\t\toptstack = args->optstack;\n\t\targs->optstack = optstack->cl_head;\n\t\tif (optstack->cl_head) {\n\t\t\toptstack->cl_head->parent = NULL;\n\t\t}\n\t\tfree(optstack);\n\t} else if (parent->flavor == CIL_BOOLEANIF) {\n\t\targs->boolif = NULL;\n\t} else if (parent->flavor == CIL_BLOCK) {\n\t\t/* pop off the stack */\n\t\tblockstack = args->blockstack;\n\t\targs->blockstack = blockstack->cl_head;\n\t\tif (blockstack->cl_head) {\n\t\t\tblockstack->cl_head->parent = NULL;\n\t\t}\n\t\tfree(blockstack);\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n",
    "target": 1,
    "idx": 1029002,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n\n\n\n\n\n\n\n_LIBCPP_NODISCARD_EXT inline\n_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\nbool\nbinary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::binary_search(__first, __last, __value_,\n                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());\n}\n\nvoid HashMgr::free_flag(unsigned short* astr, int alen) {\n  if (astr && (aliasf.empty() || TESTAFF(astr, ONLYUPCASEFLAG, alen)))\n    delete[] astr;\n}\n\nint HashMgr::add_word(const std::string& in_word,\n                      int wcl,\n                      unsigned short* aff,\n                      int al,\n                      const std::string* in_desc,\n                      bool onlyupcase,\n                      int captype) {\n\n  if (al > std::numeric_limits<short>::max()) {\n    HUNSPELL_WARNING(stderr, \"error: affix len %d is over max limit\\n\", al);\n    free_flag(aff, al);\n    return 1;\n  }\n\n  const std::string* word = &in_word;\n  const std::string* desc = in_desc;\n\n  std::string *word_copy = NULL;\n  std::string *desc_copy = NULL;\n  if ((!ignorechars.empty() && !has_no_ignored_chars(in_word, ignorechars)) || complexprefixes) {\n    word_copy = new std::string(in_word);\n\n    if (!ignorechars.empty()) {\n      if (utf8) {\n        wcl = remove_ignored_chars_utf(*word_copy, ignorechars_utf16);\n      } else {\n        remove_ignored_chars(*word_copy, ignorechars);\n      }\n    }\n\n    if (complexprefixes) {\n      if (utf8)\n        wcl = reverseword_utf(*word_copy);\n      else\n        reverseword(*word_copy);\n\n      if (in_desc && aliasm.empty()) {\n        desc_copy = new std::string(*in_desc);\n\n        if (complexprefixes) {\n          if (utf8)\n            reverseword_utf(*desc_copy);\n          else\n            reverseword(*desc_copy);\n        }\n        desc = desc_copy;\n      }\n    }\n\n    word = word_copy;\n  }\n\n  // limit of hp->blen\n  if (word->size() > std::numeric_limits<unsigned short>::max()) {\n    HUNSPELL_WARNING(stderr, \"error: word len %ld is over max limit\\n\", word->size());\n    delete desc_copy;\n    delete word_copy;\n    free_flag(aff, al);\n    return 1;\n  }\n\n  bool upcasehomonym = false;\n  int descl = desc ? (!aliasm.empty() ? sizeof(char*) : desc->size() + 1) : 0;\n  // variable-length hash record with word and optional fields\n  auto hp =\n      (struct hentry*)malloc(sizeof(struct hentry) + word->size() + descl);\n  if (!hp) {\n    delete desc_copy;\n    delete word_copy;\n    free_flag(aff, al);\n    return 1;\n  }\n\n  char* hpw = hp->word;\n  memcpy(hpw, word->data(), word->size());\n  hpw[word->size()] = 0;\n\n  int i = hash(hpw, word->size());\n\n  hp->blen = (unsigned short)word->size();\n  hp->clen = (unsigned short)wcl;\n  hp->alen = (short)al;\n  hp->astr = aff;\n  hp->next = NULL;\n  hp->next_homonym = NULL;\n  hp->var = (captype == INITCAP) ? H_OPT_INITCAP : 0;\n\n  // store the description string or its pointer\n  if (desc) {\n    hp->var |= H_OPT;\n    if (!aliasm.empty()) {\n      hp->var |= H_OPT_ALIASM;\n      store_pointer(hpw + word->size() + 1, get_aliasm(atoi(desc->c_str())));\n    } else {\n      strcpy(hpw + word->size() + 1, desc->c_str());\n    }\n    if (HENTRY_FIND(hp, MORPH_PHON)) {\n      hp->var |= H_OPT_PHON;\n      // store ph: fields (pronounciation, misspellings, old orthography etc.)\n      // of a morphological description in reptable to use in REP replacements.\n      size_t predicted = tableptr.size() / MORPH_PHON_RATIO;\n      if (reptable.capacity() < predicted)\n          reptable.reserve(predicted);\n      std::string fields = HENTRY_DATA(hp);\n      std::string::const_iterator iter = fields.begin(), start_piece = mystrsep(fields, iter);\n      while (start_piece != fields.end()) {\n        if (std::string(start_piece, iter).find(MORPH_PHON) == 0) {\n          std::string ph = std::string(start_piece, iter).substr(sizeof MORPH_PHON - 1);\n          if (!ph.empty()) {\n            std::vector<w_char> w;\n            size_t strippatt;\n            std::string wordpart;\n            // dictionary based REP replacement, separated by \"->\"\n            // for example \"pretty ph:prity ph:priti->pretti\" to handle\n            // both prity -> pretty and pritier -> prettiest suggestions.\n            if (((strippatt = ph.find(\"->\")) != std::string::npos) &&\n                    (strippatt > 0) && (strippatt < ph.size() - 2)) {\n                wordpart = ph.substr(strippatt + 2);\n                ph.erase(ph.begin() + strippatt, ph.end());\n            } else\n                wordpart = in_word;\n            // when the ph: field ends with the character *,\n            // strip last character of the pattern and the replacement\n            // to match in REP suggestions also at character changes,\n            // for example, \"pretty ph:prity*\" results \"prit->prett\"\n            // REP replacement instead of \"prity->pretty\", to get\n            // prity->pretty and pritiest->prettiest suggestions.\n            if (ph.at(ph.size()-1) == '*') {\n              strippatt = 1;\n              size_t stripword = 0;\n              if (utf8) {\n                while ((strippatt < ph.size()) &&\n                  ((ph.at(ph.size()-strippatt-1) & 0xc0) == 0x80))\n                     ++strippatt;\n                while ((stripword < wordpart.size()) &&\n                  ((wordpart.at(wordpart.size()-stripword-1) & 0xc0) == 0x80))\n                     ++stripword;\n              }\n              ++strippatt;\n              ++stripword;\n              if ((ph.size() > strippatt) && (wordpart.size() > stripword)) {\n                ph.erase(ph.size()-strippatt, strippatt);\n                wordpart.erase(wordpart.size()-stripword, stripword);\n              }\n            }\n            // capitalize lowercase pattern for capitalized words to support\n            // good suggestions also for capitalized misspellings, eg.\n            // Wednesday ph:wendsay\n            // results wendsay -> Wednesday and Wendsay -> Wednesday, too.\n            if (captype == INITCAP) {\n              std::string ph_capitalized;\n              if (utf8) {\n                u8_u16(w, ph);\n                if (get_captype_utf8(w, langnum) == NOCAP) {\n                  mkinitcap_utf(w, langnum);\n                  u16_u8(ph_capitalized, w);\n                }\n              } else if (get_captype(ph, csconv) == NOCAP)\n                  mkinitcap(ph_capitalized, csconv);\n\n              if (!ph_capitalized.empty()) {\n                // add also lowercase word in the case of German or\n                // Hungarian to support lowercase suggestions lowercased by\n                // compound word generation or derivational suffixes\n                // (for example by adjectival suffix \"-i\" of geographical\n                // names in Hungarian:\n                // Massachusetts ph:messzecsuzec\n                // messzecsuzeci -> massachusettsi (adjective)\n                // For lowercasing by conditional PFX rules, see\n                // tests/germancompounding test example or the\n                // Hungarian dictionary.)\n                if (langnum == LANG_de || langnum == LANG_hu) {\n                  std::string wordpart_lower(wordpart);\n                  if (utf8) {\n                    u8_u16(w, wordpart_lower);\n                    mkallsmall_utf(w, langnum);\n                    u16_u8(wordpart_lower, w);\n                  } else {\n                    mkallsmall(wordpart_lower, csconv);\n                  }\n                  reptable.emplace_back();\n                  reptable.back().pattern.assign(ph);\n                  reptable.back().outstrings[0].assign(wordpart_lower);\n                }\n                reptable.emplace_back();\n                reptable.back().pattern.assign(ph_capitalized);\n                reptable.back().outstrings[0].assign(wordpart);\n              }\n            }\n            reptable.emplace_back();\n            reptable.back().pattern.assign(ph);\n            reptable.back().outstrings[0].assign(wordpart);\n          }\n        }\n        start_piece = mystrsep(fields, iter);\n      }\n    }\n  }\n\n  struct hentry* dp = tableptr[i];\n  if (!dp) {\n    tableptr[i] = hp;\n    delete desc_copy;\n    delete word_copy;\n    return 0;\n  }\n  while (dp->next != NULL) {\n    if ((!dp->next_homonym) && (strcmp(hp->word, dp->word) == 0)) {\n      // remove hidden onlyupcase homonym\n      if (!onlyupcase) {\n        if ((dp->astr) && TESTAFF(dp->astr, ONLYUPCASEFLAG, dp->alen)) {\n          delete[] dp->astr;\n          dp->astr = hp->astr;\n          dp->alen = hp->alen;\n          free(hp);\n          delete desc_copy;\n          delete word_copy;\n          return 0;\n        } else {\n          dp->next_homonym = hp;\n        }\n      } else {\n        upcasehomonym = true;\n      }\n    }\n    dp = dp->next;\n  }\n  if (strcmp(hp->word, dp->word) == 0) {\n    // remove hidden onlyupcase homonym\n    if (!onlyupcase) {\n      if ((dp->astr) && TESTAFF(dp->astr, ONLYUPCASEFLAG, dp->alen)) {\n        delete[] dp->astr;\n        dp->astr = hp->astr;\n        dp->alen = hp->alen;\n        free(hp);\n        delete desc_copy;\n        delete word_copy;\n        return 0;\n      } else {\n        dp->next_homonym = hp;\n      }\n    } else {\n      upcasehomonym = true;\n    }\n  }\n  if (!upcasehomonym) {\n    dp->next = hp;\n  } else {\n    // remove hidden onlyupcase homonym\n    delete[] hp->astr;\n    free(hp);\n  }\n\n  delete desc_copy;\n  delete word_copy;\n  return 0;\n}\n\n\n\nint HashMgr::add(const std::string& word) {\n  if (remove_forbidden_flag(word)) {\n    int captype, al = 0;\n    unsigned short* flags = NULL;\n    int wcl = get_clen_and_captype(word, &captype);\n    add_word(word, wcl, flags, al, NULL, false, captype);\n    return add_hidden_capitalized_word(word, wcl, flags, al, NULL,\n                                       captype);\n  }\n  return 0;\n}\n\n  HunspellImpl(const HunspellImpl&) = delete;\n\n  HunspellImpl(const HunspellImpl&) = delete;\n\n\n// target function\nvoid HashMgr::free_flag(unsigned short* astr, short alen) {\n  if (astr && (aliasf.empty() || TESTAFF(astr, ONLYUPCASEFLAG, alen)))\n    delete[] astr;\n}\n",
    "target": 1,
    "idx": 1056737,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "// context\nvoid dav1d_picture_copy_props(Dav1dPicture *const p,\n                              Dav1dContentLightLevel *const content_light, Dav1dRef *const content_light_ref,\n                              Dav1dMasteringDisplay *const mastering_display, Dav1dRef *const mastering_display_ref,\n                              Dav1dITUTT35 *const itut_t35, Dav1dRef *const itut_t35_ref,\n                              const Dav1dDataProps *const props)\n{\n    dav1d_data_props_copy(&p->m, props);\n\n    dav1d_ref_dec(&p->content_light_ref);\n    p->content_light_ref = content_light_ref;\n    p->content_light = content_light;\n    if (content_light_ref) dav1d_ref_inc(content_light_ref);\n\n    dav1d_ref_dec(&p->mastering_display_ref);\n    p->mastering_display_ref = mastering_display_ref;\n    p->mastering_display = mastering_display;\n    if (mastering_display_ref) dav1d_ref_inc(mastering_display_ref);\n\n    dav1d_ref_dec(&p->itut_t35_ref);\n    p->itut_t35_ref = itut_t35_ref;\n    p->itut_t35 = itut_t35;\n    if (itut_t35_ref) dav1d_ref_inc(itut_t35_ref);\n}\n\nint dav1d_picture_alloc_copy(Dav1dContext *const c, Dav1dPicture *const dst, const int w,\n                             const Dav1dPicture *const src)\n{\n    struct pic_ctx_context *const pic_ctx = src->ref->user_data;\n    struct plane_ctx_context *const plane_ctx = pic_ctx->plane_ref[0]->user_data;\n    const int res = picture_alloc_with_edges(c, dst, w, src->p.h,\n                                             src->seq_hdr, src->seq_hdr_ref,\n                                             src->frame_hdr, src->frame_hdr_ref,\n                                             src->content_light, src->content_light_ref,\n                                             src->mastering_display, src->mastering_display_ref,\n                                             src->itut_t35, src->itut_t35_ref,\n                                             src->p.bpc, &src->m, &plane_ctx->allocator,\n                                             0, NULL);\n    return res;\n}\n\nint dav1d_apply_grain(Dav1dContext *const c, Dav1dPicture *const out,\n                      const Dav1dPicture *const in)\n{\n    validate_input_or_ret(c != NULL, DAV1D_ERR(EINVAL));\n    validate_input_or_ret(out != NULL, DAV1D_ERR(EINVAL));\n    validate_input_or_ret(in != NULL, DAV1D_ERR(EINVAL));\n\n    if (!has_grain(in)) {\n        dav1d_picture_ref(out, in);\n        return 0;\n    }\n\n    int res = dav1d_picture_alloc_copy(c, out, in->p.w, in);\n    if (res < 0) goto error;\n\n    if (c->n_tc > 1) {\n        dav1d_task_delayed_fg(c, out, in);\n    } else {\n        switch (out->p.bpc) {\n#if CONFIG_8BPC\n        case 8:\n            dav1d_apply_grain_8bpc(&c->dsp[0].fg, out, in);\n            break;\n#endif\n#if CONFIG_16BPC\n        case 10:\n        case 12:\n            dav1d_apply_grain_16bpc(&c->dsp[(out->p.bpc >> 1) - 4].fg, out, in);\n            break;\n#endif\n        default: abort();\n        }\n    }\n\n    return 0;\n\nerror:\n    dav1d_picture_unref_internal(out);\n    return res;\n}\n\nstatic int output_image(Dav1dContext *const c, Dav1dPicture *const out)\n{\n    int res = 0;\n\n    Dav1dThreadPicture *const in = (c->all_layers || !c->max_spatial_id)\n                                   ? &c->out : &c->cache;\n    if (!c->apply_grain || !has_grain(&in->p)) {\n        dav1d_picture_move_ref(out, &in->p);\n        dav1d_thread_picture_unref(in);\n        goto end;\n    }\n\n    res = dav1d_apply_grain(c, out, &in->p);\n    dav1d_thread_picture_unref(in);\nend:\n    if (!c->all_layers && c->max_spatial_id && c->out.p.data[0]) {\n        dav1d_thread_picture_move_ref(in, &c->out);\n    }\n    return res;\n}\n\nstatic int drain_picture(Dav1dContext *const c, Dav1dPicture *const out) {\n    unsigned drain_count = 0;\n    int drained = 0;\n    do {\n        const unsigned next = c->frame_thread.next;\n        Dav1dFrameContext *const f = &c->fc[next];\n        pthread_mutex_lock(&c->task_thread.lock);\n        while (f->n_tile_data > 0)\n            pthread_cond_wait(&f->task_thread.cond,\n                              &f->task_thread.ttd->lock);\n        Dav1dThreadPicture *const out_delayed =\n            &c->frame_thread.out_delayed[next];\n        if (out_delayed->p.data[0] || atomic_load(&f->task_thread.error)) {\n            unsigned first = atomic_load(&c->task_thread.first);\n            if (first + 1U < c->n_fc)\n                atomic_fetch_add(&c->task_thread.first, 1U);\n            else\n                atomic_store(&c->task_thread.first, 0);\n            atomic_compare_exchange_strong(&c->task_thread.reset_task_cur,\n                                           &first, UINT_MAX);\n            if (c->task_thread.cur && c->task_thread.cur < c->n_fc)\n                c->task_thread.cur--;\n            drained = 1;\n        } else if (drained) {\n            pthread_mutex_unlock(&c->task_thread.lock);\n            break;\n        }\n        if (++c->frame_thread.next == c->n_fc)\n            c->frame_thread.next = 0;\n        pthread_mutex_unlock(&c->task_thread.lock);\n        const int error = f->task_thread.retval;\n        if (error) {\n            f->task_thread.retval = 0;\n            dav1d_data_props_copy(&c->cached_error_props, &out_delayed->p.m);\n            dav1d_thread_picture_unref(out_delayed);\n            return error;\n        }\n        if (out_delayed->p.data[0]) {\n            const unsigned progress =\n                atomic_load_explicit(&out_delayed->progress[1],\n                                     memory_order_relaxed);\n            if ((out_delayed->visible || c->output_invisible_frames) &&\n                progress != FRAME_ERROR)\n            {\n                dav1d_thread_picture_ref(&c->out, out_delayed);\n                c->event_flags |= dav1d_picture_get_event_flags(out_delayed);\n            }\n            dav1d_thread_picture_unref(out_delayed);\n            if (output_picture_ready(c, 0))\n                return output_image(c, out);\n        }\n    } while (++drain_count < c->n_fc);\n\n    if (output_picture_ready(c, 1))\n        return output_image(c, out);\n\n    return DAV1D_ERR(EAGAIN);\n}\n\nint dav1d_get_picture(Dav1dContext *const c, Dav1dPicture *const out)\n{\n    validate_input_or_ret(c != NULL, DAV1D_ERR(EINVAL));\n    validate_input_or_ret(out != NULL, DAV1D_ERR(EINVAL));\n\n    const int drain = c->drain;\n    c->drain = 1;\n\n    int res = gen_picture(c);\n    if (res < 0)\n        return res;\n\n    if (c->cached_error) {\n        const int res = c->cached_error;\n        c->cached_error = 0;\n        return res;\n    }\n\n    if (output_picture_ready(c, c->n_fc == 1))\n        return output_image(c, out);\n\n    if (c->n_fc > 1 && drain)\n        return drain_picture(c, out);\n\n    return DAV1D_ERR(EAGAIN);\n}\n\n\n// target function\nvoid dav1d_flush(Dav1dContext *const c) {\n    dav1d_data_unref_internal(&c->in);\n    if (c->out.p.frame_hdr)\n        dav1d_thread_picture_unref(&c->out);\n    if (c->cache.p.frame_hdr)\n        dav1d_thread_picture_unref(&c->cache);\n\n    c->drain = 0;\n    c->cached_error = 0;\n\n    for (int i = 0; i < 8; i++) {\n        if (c->refs[i].p.p.frame_hdr)\n            dav1d_thread_picture_unref(&c->refs[i].p);\n        dav1d_ref_dec(&c->refs[i].segmap);\n        dav1d_ref_dec(&c->refs[i].refmvs);\n        dav1d_cdf_thread_unref(&c->cdf[i]);\n    }\n    c->frame_hdr = NULL;\n    c->seq_hdr = NULL;\n    dav1d_ref_dec(&c->seq_hdr_ref);\n\n    c->mastering_display = NULL;\n    c->content_light = NULL;\n    dav1d_ref_dec(&c->mastering_display_ref);\n    dav1d_ref_dec(&c->content_light_ref);\n    for (int n = 0; n < c->n_itut_t35; n++)\n        dav1d_ref_dec(&c->itut_t35[n].ref);\n    c->n_itut_t35 = 0;\n\n    dav1d_data_props_unref_internal(&c->cached_error_props);\n\n    if (c->n_fc == 1 && c->n_tc == 1) return;\n    atomic_store(c->flush, 1);\n\n    // stop running tasks in worker threads\n    if (c->n_tc > 1) {\n        pthread_mutex_lock(&c->task_thread.lock);\n        for (unsigned i = 0; i < c->n_tc; i++) {\n            Dav1dTaskContext *const tc = &c->tc[i];\n            while (!tc->task_thread.flushed) {\n                pthread_cond_wait(&tc->task_thread.td.cond, &c->task_thread.lock);\n            }\n        }\n        for (unsigned i = 0; i < c->n_fc; i++) {\n            c->fc[i].task_thread.task_head = NULL;\n            c->fc[i].task_thread.task_tail = NULL;\n            c->fc[i].task_thread.task_cur_prev = NULL;\n            c->fc[i].task_thread.pending_tasks.head = NULL;\n            c->fc[i].task_thread.pending_tasks.tail = NULL;\n            atomic_init(&c->fc[i].task_thread.pending_tasks.merge, 0);\n        }\n        atomic_init(&c->task_thread.first, 0);\n        c->task_thread.cur = c->n_fc;\n        atomic_store(&c->task_thread.reset_task_cur, UINT_MAX);\n        atomic_store(&c->task_thread.cond_signaled, 0);\n        pthread_mutex_unlock(&c->task_thread.lock);\n    }\n\n    // wait for threads to complete flushing\n    if (c->n_fc > 1) {\n        for (unsigned n = 0, next = c->frame_thread.next; n < c->n_fc; n++, next++) {\n            if (next == c->n_fc) next = 0;\n            Dav1dFrameContext *const f = &c->fc[next];\n            dav1d_decode_frame_exit(f, -1);\n            f->n_tile_data = 0;\n            f->task_thread.retval = 0;\n            Dav1dThreadPicture *out_delayed = &c->frame_thread.out_delayed[next];\n            if (out_delayed->p.frame_hdr) {\n                dav1d_thread_picture_unref(out_delayed);\n            }\n        }\n        c->frame_thread.next = 0;\n    }\n    atomic_store(c->flush, 0);\n}\nstatic COLD void close_internal(Dav1dContext **const c_out, int flush) {\n    Dav1dContext *const c = *c_out;\n    if (!c) return;\n\n    if (flush) dav1d_flush(c);\n\n    if (c->tc) {\n        struct TaskThreadData *ttd = &c->task_thread;\n        if (ttd->inited) {\n            pthread_mutex_lock(&ttd->lock);\n            for (unsigned n = 0; n < c->n_tc && c->tc[n].task_thread.td.inited; n++)\n                c->tc[n].task_thread.die = 1;\n            pthread_cond_broadcast(&ttd->cond);\n            pthread_mutex_unlock(&ttd->lock);\n            for (unsigned n = 0; n < c->n_tc; n++) {\n                Dav1dTaskContext *const pf = &c->tc[n];\n                if (!pf->task_thread.td.inited) break;\n                pthread_join(pf->task_thread.td.thread, NULL);\n                pthread_cond_destroy(&pf->task_thread.td.cond);\n                pthread_mutex_destroy(&pf->task_thread.td.lock);\n            }\n            pthread_cond_destroy(&ttd->delayed_fg.cond);\n            pthread_cond_destroy(&ttd->cond);\n            pthread_mutex_destroy(&ttd->lock);\n        }\n        dav1d_free_aligned(c->tc);\n    }\n\n    for (unsigned n = 0; c->fc && n < c->n_fc; n++) {\n        Dav1dFrameContext *const f = &c->fc[n];\n\n        // clean-up threading stuff\n        if (c->n_fc > 1) {\n            freep(&f->tile_thread.lowest_pixel_mem);\n            freep(&f->frame_thread.b);\n            dav1d_freep_aligned(&f->frame_thread.pal_idx);\n            dav1d_freep_aligned(&f->frame_thread.cf);\n            freep(&f->frame_thread.tile_start_off);\n            dav1d_freep_aligned(&f->frame_thread.pal);\n            freep(&f->frame_thread.cbi);\n        }\n        if (c->n_tc > 1) {\n            pthread_mutex_destroy(&f->task_thread.pending_tasks.lock);\n            pthread_cond_destroy(&f->task_thread.cond);\n            pthread_mutex_destroy(&f->task_thread.lock);\n        }\n        freep(&f->frame_thread.frame_progress);\n        freep(&f->task_thread.tasks);\n        freep(&f->task_thread.tile_tasks[0]);\n        dav1d_free_aligned(f->ts);\n        dav1d_free_aligned(f->ipred_edge[0]);\n        free(f->a);\n        free(f->tile);\n        free(f->lf.mask);\n        free(f->lf.lr_mask);\n        free(f->lf.level);\n        free(f->lf.tx_lpf_right_edge[0]);\n        free(f->lf.start_of_tile_row);\n        dav1d_refmvs_clear(&f->rf);\n        dav1d_free_aligned(f->lf.cdef_line_buf);\n        dav1d_free_aligned(f->lf.lr_line_buf);\n    }\n    dav1d_free_aligned(c->fc);\n    if (c->n_fc > 1 && c->frame_thread.out_delayed) {\n        for (unsigned n = 0; n < c->n_fc; n++)\n            if (c->frame_thread.out_delayed[n].p.frame_hdr)\n                dav1d_thread_picture_unref(&c->frame_thread.out_delayed[n]);\n        free(c->frame_thread.out_delayed);\n    }\n    for (int n = 0; n < c->n_tile_data; n++)\n        dav1d_data_unref_internal(&c->tile[n].data);\n    free(c->tile);\n    for (int n = 0; n < 8; n++) {\n        dav1d_cdf_thread_unref(&c->cdf[n]);\n        if (c->refs[n].p.p.frame_hdr)\n            dav1d_thread_picture_unref(&c->refs[n].p);\n        dav1d_ref_dec(&c->refs[n].refmvs);\n        dav1d_ref_dec(&c->refs[n].segmap);\n    }\n    dav1d_ref_dec(&c->seq_hdr_ref);\n    dav1d_ref_dec(&c->frame_hdr_ref);\n\n    dav1d_ref_dec(&c->mastering_display_ref);\n    dav1d_ref_dec(&c->content_light_ref);\n    for (int n = 0; n < c->n_itut_t35; n++)\n        dav1d_ref_dec(&c->itut_t35[n].ref);\n    free(c->itut_t35);\n\n    dav1d_mem_pool_end(c->seq_hdr_pool);\n    dav1d_mem_pool_end(c->frame_hdr_pool);\n    dav1d_mem_pool_end(c->segmap_pool);\n    dav1d_mem_pool_end(c->refmvs_pool);\n    dav1d_mem_pool_end(c->cdf_pool);\n    dav1d_mem_pool_end(c->picture_pool);\n\n    dav1d_freep_aligned(c_out);\n}\nstatic void free_buffer(const uint8_t *const data, void *const user_data) {\n    struct pic_ctx_context *pic_ctx = user_data;\n    const int planes = pic_ctx->layout != DAV1D_PIXEL_LAYOUT_I400 ? 3 : 1;\n\n    for (int i = 0; i < planes; i++)\n        dav1d_ref_dec(&pic_ctx->plane_ref[i]);\n    dav1d_ref_dec(&pic_ctx->content_light_ref);\n    dav1d_ref_dec(&pic_ctx->mastering_display_ref);\n    dav1d_ref_dec(&pic_ctx->itut_t35_ref);\n    free(pic_ctx);\n}\nstatic void free_plane_buffer(const uint8_t *const data, void *const user_data) {\n    struct plane_ctx_context *plane_ctx = user_data;\n\n    plane_ctx->allocator.release_picture_callback(&plane_ctx->pic,\n                                                  plane_ctx->allocator.cookie);\n    free(plane_ctx);\n}\nstatic int picture_alloc_with_edges(Dav1dContext *const c,\n                                    Dav1dPicture *const p,\n                                    const int w, const int h,\n                                    Dav1dSequenceHeader *const seq_hdr, Dav1dRef *const seq_hdr_ref,\n                                    Dav1dFrameHeader *const frame_hdr, Dav1dRef *const frame_hdr_ref,\n                                    const int bpc,\n                                    const Dav1dDataProps *const props,\n                                    Dav1dPicAllocator *const p_allocator,\n                                    const size_t extra, void **const extra_ptr)\n{\n    if (p->data[0]) {\n        dav1d_log(c, \"Picture already allocated!\\n\");\n        return -1;\n    }\n    assert(bpc > 0 && bpc <= 16);\n\n    struct pic_ctx_context *pic_ctx = malloc(extra + sizeof(struct pic_ctx_context));\n    if (pic_ctx == NULL)\n        return DAV1D_ERR(ENOMEM);\n    memset(pic_ctx, 0, sizeof(struct pic_ctx_context));\n\n    p->p.w = w;\n    p->p.h = h;\n    p->seq_hdr = seq_hdr;\n    p->frame_hdr = frame_hdr;\n    p->p.layout = seq_hdr->layout;\n    p->p.bpc = bpc;\n    dav1d_data_props_set_defaults(&p->m);\n    const int res = p_allocator->alloc_picture_callback(p, p_allocator->cookie);\n    if (res < 0) {\n        free(pic_ctx);\n        return res;\n    }\n\n    pic_ctx->layout = p->p.layout;\n\n    if (!(p->ref = dav1d_ref_wrap(p->data[0], free_buffer, pic_ctx))) {\n        p_allocator->release_picture_callback(p, p_allocator->cookie);\n        free(pic_ctx);\n        dav1d_log(c, \"Failed to wrap picture: %s\\n\", strerror(errno));\n        return DAV1D_ERR(ENOMEM);\n    }\n\n    struct plane_ctx_context *plane_ctx = malloc(sizeof(struct plane_ctx_context));\n    if (plane_ctx == NULL){\n        dav1d_ref_dec(&p->ref);\n        p_allocator->release_picture_callback(p, p_allocator->cookie);\n        return DAV1D_ERR(ENOMEM);\n    }\n\n    plane_ctx->allocator = *p_allocator;\n    plane_ctx->pic = *p;\n\n    pic_ctx->plane_ref[0] = dav1d_ref_wrap(p->data[0], free_plane_buffer, plane_ctx);\n    if (!pic_ctx->plane_ref[0]) {\n        dav1d_ref_dec(&p->ref);\n        p_allocator->release_picture_callback(p, p_allocator->cookie);\n        free(plane_ctx);\n        dav1d_log(c, \"Failed to wrap picture plane: %s\\n\", strerror(errno));\n        return DAV1D_ERR(ENOMEM);\n    }\n\n    const int planes = p->p.layout != DAV1D_PIXEL_LAYOUT_I400 ? 3 : 1;\n    for (int i = 1; i < planes; i++) {\n        pic_ctx->plane_ref[i] = pic_ctx->plane_ref[0];\n        dav1d_ref_inc(pic_ctx->plane_ref[i]);\n    }\n\n    p->seq_hdr_ref = seq_hdr_ref;\n    if (seq_hdr_ref) dav1d_ref_inc(seq_hdr_ref);\n\n    p->frame_hdr_ref = frame_hdr_ref;\n    if (frame_hdr_ref) dav1d_ref_inc(frame_hdr_ref);\n\n    if (extra && extra_ptr)\n        *extra_ptr = &pic_ctx->extra_ptr;\n\n    return 0;\n}\nstatic int picture_copy_props(Dav1dPicture *const p,\n                              Dav1dContentLightLevel *const content_light, Dav1dRef *const content_light_ref,\n                              Dav1dMasteringDisplay *const mastering_display, Dav1dRef *const mastering_display_ref,\n                              Dav1dITUTT35 **const p_itut_t35, int *const pn_itut_t35,\n                              const Dav1dDataProps *const props, int copy)\n{\n    struct pic_ctx_context *const pic_ctx = p->ref->user_data;\n    Dav1dITUTT35 *const itut_t35 = *p_itut_t35;\n    int res = 0, n_itut_t35 = *pn_itut_t35;\n    dav1d_data_props_copy(&p->m, props);\n\n    dav1d_ref_dec(&pic_ctx->content_light_ref);\n    pic_ctx->content_light_ref = content_light_ref;\n    p->content_light = content_light;\n    if (content_light_ref) dav1d_ref_inc(content_light_ref);\n\n    dav1d_ref_dec(&pic_ctx->mastering_display_ref);\n    pic_ctx->mastering_display_ref = mastering_display_ref;\n    p->mastering_display = mastering_display;\n    if (mastering_display_ref) dav1d_ref_inc(mastering_display_ref);\n\n    if (n_itut_t35) {\n        struct itut_t35_ctx_context *itut_t35_ctx = malloc(sizeof(struct itut_t35_ctx_context));\n        if (itut_t35_ctx == NULL) {\n            res = DAV1D_ERR(ENOMEM);\n            goto end;\n        }\n\n        if (copy) {\n            assert(n_itut_t35 < INT_MAX / (int)sizeof(*itut_t35));\n            itut_t35_ctx->itut_t35 = malloc(n_itut_t35 * sizeof(*itut_t35));\n            if (itut_t35_ctx->itut_t35 == NULL) {\n                free(itut_t35_ctx);\n                res = DAV1D_ERR(ENOMEM);\n                goto end;\n            }\n        } else\n            itut_t35_ctx->itut_t35 = itut_t35;\n\n        dav1d_ref_dec(&pic_ctx->itut_t35_ref);\n        pic_ctx->itut_t35_ref = dav1d_ref_wrap((uint8_t *)itut_t35_ctx->itut_t35,\n                                               free_itut_t35, itut_t35_ctx);\n        if (pic_ctx->itut_t35_ref == NULL) {\n            if (copy)\n                freep(&itut_t35_ctx->itut_t35);\n            freep(&itut_t35_ctx);\n            res = DAV1D_ERR(ENOMEM);\n            goto end;\n        }\n        p->itut_t35 = itut_t35_ctx->itut_t35;\n        if (copy) {\n            memcpy(p->itut_t35, itut_t35, n_itut_t35 * sizeof(*itut_t35));\n            for (int i = 0; i < n_itut_t35; i++)\n                dav1d_ref_inc(p->itut_t35[i].ref);\n        }\n        itut_t35_ctx->n_itut_t35 = n_itut_t35;\n    }\n    p->n_itut_t35 = n_itut_t35;\n\nend:\n    if (!copy) {\n        // Must be removed from the source after being attached to the picture\n        if (res < 0)\n            free(itut_t35);\n        *p_itut_t35 = NULL;\n        *pn_itut_t35 = 0;\n    }\n\n    return res;\n}\nint dav1d_picture_move_props(Dav1dPicture *const p,\n                             Dav1dContentLightLevel *const content_light, Dav1dRef *const content_light_ref,\n                             Dav1dMasteringDisplay *const mastering_display, Dav1dRef *const mastering_display_ref,\n                             Dav1dITUTT35 **const itut_t35, int *const n_itut_t35,\n                             const Dav1dDataProps *const props)\n{\n    return picture_copy_props(p, content_light, content_light_ref,\n                              mastering_display, mastering_display_ref,\n                              itut_t35, n_itut_t35, props, 0);\n}\nint dav1d_picture_alloc_copy(Dav1dContext *const c, Dav1dPicture *const dst, const int w,\n                             const Dav1dPicture *const src)\n{\n    struct pic_ctx_context *const pic_ctx = src->ref->user_data;\n    struct plane_ctx_context *const plane_ctx = pic_ctx->plane_ref[0]->user_data;\n    const int res = picture_alloc_with_edges(c, dst, w, src->p.h,\n                                             src->seq_hdr, src->seq_hdr_ref,\n                                             src->frame_hdr, src->frame_hdr_ref,\n                                             src->p.bpc, &src->m, &plane_ctx->allocator,\n                                             0, NULL);\n    if (res) return res;\n\n    return picture_copy_props(dst, src->content_light, pic_ctx->content_light_ref,\n                              src->mastering_display, pic_ctx->mastering_display_ref,\n                              (Dav1dITUTT35 **)&src->itut_t35,\n                              (int *)&src->n_itut_t35, &src->m, 1);\n}\n",
    "target": 1,
    "idx": 1057927,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "// context\nsize_t ZSTD_freeDDict(ZSTD_DDict* ddict)\n{\n    if (ddict==NULL) return 0;   /* support free on NULL */\n    {   ZSTD_customMem const cMem = ddict->cMem;\n        ZSTD_customFree(ddict->dictBuffer, cMem);\n        ZSTD_customFree(ddict, cMem);\n        return 0;\n    }\n}\n\nvoid blosc2_free_ctx(blosc2_context* context) {\n  release_threadpool(context);\n  if (context->serial_context != NULL) {\n    free_thread_context(context->serial_context);\n  }\n  if (context->dict_cdict != NULL) {\n#ifdef HAVE_ZSTD\n    ZSTD_freeCDict(context->dict_cdict);\n#endif\n  }\n  if (context->dict_ddict != NULL) {\n#ifdef HAVE_ZSTD\n    ZSTD_freeDDict(context->dict_ddict);\n#endif\n  }\n  if (context->btune != NULL) {\n    context->udbtune->btune_free(context);\n  }\n  if (context->prefilter != NULL) {\n    my_free(context->preparams);\n  }\n  if (context->postfilter != NULL) {\n    my_free(context->postparams);\n  }\n\n  if (context->block_maskout != NULL) {\n    free(context->block_maskout);\n  }\n  my_free(context);\n}\n\nint blosc2_schunk_free(blosc2_schunk *schunk) {\n  if (schunk->data != NULL) {\n    for (int i = 0; i < schunk->nchunks; i++) {\n      free(schunk->data[i]);\n    }\n    free(schunk->data);\n  }\n  if (schunk->cctx != NULL)\n    blosc2_free_ctx(schunk->cctx);\n  if (schunk->dctx != NULL)\n    blosc2_free_ctx(schunk->dctx);\n\n  if (schunk->nmetalayers > 0) {\n    for (int i = 0; i < schunk->nmetalayers; i++) {\n      if (schunk->metalayers[i] != NULL) {\n        if (schunk->metalayers[i]->name != NULL)\n          free(schunk->metalayers[i]->name);\n        if (schunk->metalayers[i]->content != NULL)\n          free(schunk->metalayers[i]->content);\n        free(schunk->metalayers[i]);\n      }\n    }\n    schunk->nmetalayers = 0;\n  }\n\n  if (schunk->storage != NULL) {\n    if (schunk->storage->urlpath != NULL) {\n      free(schunk->storage->urlpath);\n    }\n    free(schunk->storage->cparams);\n    free(schunk->storage->dparams);\n    free(schunk->storage);\n  }\n\n  if (schunk->frame != NULL) {\n    frame_free((blosc2_frame_s *) schunk->frame);\n  }\n\n  if (schunk->nvlmetalayers > 0) {\n    for (int i = 0; i < schunk->nvlmetalayers; ++i) {\n      if (schunk->vlmetalayers[i] != NULL) {\n        if (schunk->vlmetalayers[i]->name != NULL)\n          free(schunk->vlmetalayers[i]->name);\n        if (schunk->vlmetalayers[i]->content != NULL)\n          free(schunk->vlmetalayers[i]->content);\n        free(schunk->vlmetalayers[i]);\n      }\n    }\n  }\n\n  if (schunk->udbtune != NULL) {\n    free(schunk->udbtune);\n  }\n  free(schunk);\n\n  return 0;\n}\n\nstatic int ExecuteFilesOnyByOne(int argc, char **argv) {\n\n  unsigned char *buf = (unsigned char *)malloc(MAX_FILE);\n  for (int i = 1; i < argc; i++) {\n\n    int fd = open(argv[i], O_RDONLY);\n    if (fd == -1) continue;\n    ssize_t length = read(fd, buf, MAX_FILE);\n    if (length > 0) {\n\n      printf(\"Reading %zu bytes from %s\\n\", length, argv[i]);\n      LLVMFuzzerTestOneInput(buf, length);\n      printf(\"Execution successful.\\n\");\n\n    }\n\n  }\n\n  free(buf);\n  return 0;\n\n}\n\nint main(int argc, char **argv) {\n\n  printf(\n      \"======================= INFO =========================\\n\"\n      \"This binary is built for afl++.\\n\"\n      \"To run the target function on individual input(s) execute this:\\n\"\n      \"  %s INPUT_FILE1 [INPUT_FILE2 ... ]\\n\"\n      \"To fuzz with afl-fuzz execute this:\\n\"\n      \"  afl-fuzz [afl-flags] -- %s [-N]\\n\"\n      \"afl-fuzz will run N iterations before re-spawning the process (default: \"\n      \"1000)\\n\"\n      \"======================================================\\n\",\n      argv[0], argv[0]);\n\n  output_file = stderr;\n  maybe_duplicate_stderr();\n  maybe_close_fd_mask();\n  if (LLVMFuzzerInitialize) {\n\n    fprintf(stderr, \"Running LLVMFuzzerInitialize ...\\n\");\n    LLVMFuzzerInitialize(&argc, &argv);\n    fprintf(stderr, \"continue...\\n\");\n\n  }\n\n  // Do any other expensive one-time initialization here.\n\n  uint8_t dummy_input[64] = {0};\n  memcpy(dummy_input, (void *)AFL_PERSISTENT, sizeof(AFL_PERSISTENT));\n  memcpy(dummy_input + 32, (void *)AFL_DEFER_FORKSVR,\n         sizeof(AFL_DEFER_FORKSVR));\n  int N = INT_MAX;\n  if (argc == 2 && argv[1][0] == '-')\n    N = atoi(argv[1] + 1);\n  else if (argc == 2 && (N = atoi(argv[1])) > 0)\n    printf(\"WARNING: using the deprecated call style `%s %d`\\n\", argv[0], N);\n  else if (argc > 1) {\n\n    __afl_sharedmem_fuzzing = 0;\n    __afl_manual_init();\n    return ExecuteFilesOnyByOne(argc, argv);\n\n  }\n\n  assert(N > 0);\n\n  //  if (!getenv(\"AFL_DRIVER_DONT_DEFER\"))\n  __afl_manual_init();\n\n  // Call LLVMFuzzerTestOneInput here so that coverage caused by initialization\n  // on the first execution of LLVMFuzzerTestOneInput is ignored.\n  LLVMFuzzerTestOneInput(dummy_input, 1);\n\n  int num_runs = 0;\n  while (__afl_persistent_loop(N)) {\n\n#ifdef _DEBUG\n    fprintf(stderr, \"CLIENT crc: %016llx len: %u\\n\",\n            hash64(__afl_fuzz_ptr, *__afl_fuzz_len, 0xa5b35705),\n            *__afl_fuzz_len);\n    fprintf(stderr, \"RECV:\");\n    for (int i = 0; i < *__afl_fuzz_len; i++)\n      fprintf(stderr, \"%02x\", __afl_fuzz_ptr[i]);\n    fprintf(stderr, \"\\n\");\n#endif\n    if (*__afl_fuzz_len) {\n\n      num_runs++;\n      LLVMFuzzerTestOneInput(__afl_fuzz_ptr, *__afl_fuzz_len);\n\n    }\n\n  }\n\n  printf(\"%s: successfully executed %d input(s)\\n\", argv[0], num_runs);\n\n}\n\n\n// target function\nint get_coffset(blosc2_frame_s* frame, int32_t header_len, int64_t cbytes, int32_t nchunk, int64_t *offset) {\n  int32_t off_cbytes;\n  // Get the offset to nchunk\n  uint8_t *coffsets = get_coffsets(frame, header_len, cbytes, &off_cbytes);\n  if (coffsets == NULL) {\n    BLOSC_TRACE_ERROR(\"Cannot get the offset for chunk %d for the frame.\", nchunk);\n    return BLOSC2_ERROR_DATA;\n  }\n\n  // Get the 64-bit offset\n  int rc = blosc2_getitem(coffsets, off_cbytes, nchunk, 1, offset, (int32_t)sizeof(int64_t));\n  if (rc < 0) {\n    BLOSC_TRACE_ERROR(\"Problems retrieving a chunk offset.\");\n  } else if (*offset > frame->len) {\n    BLOSC_TRACE_ERROR(\"Cannot read chunk %d outside of frame boundary.\", nchunk);\n    rc = BLOSC2_ERROR_READ_BUFFER;\n  }\n\n  return rc;\n}\nint frame_get_chunk(blosc2_frame_s *frame, int nchunk, uint8_t **chunk, bool *needs_free) {\n  int32_t header_len;\n  int64_t frame_len;\n  int64_t nbytes;\n  int64_t cbytes;\n  int32_t blocksize;\n  int32_t chunksize;\n  int32_t nchunks;\n  int32_t typesize;\n  int64_t offset;\n  int32_t chunk_cbytes;\n  int rc;\n\n  *chunk = NULL;\n  *needs_free = false;\n  rc = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes,\n                       &blocksize, &chunksize, &nchunks,\n                       &typesize, NULL, NULL, NULL, NULL);\n  if (rc < 0) {\n    BLOSC_TRACE_ERROR(\"Unable to get meta info from frame.\");\n    return rc;\n  }\n\n  if (nchunk >= nchunks) {\n    BLOSC_TRACE_ERROR(\"nchunk ('%d') exceeds the number of chunks \"\n                    \"('%d') in frame.\", nchunk, nchunks);\n    return BLOSC2_ERROR_INVALID_PARAM;\n  }\n\n  // Get the offset to nchunk\n  rc = get_coffset(frame, header_len, cbytes, nchunk, &offset);\n  if (rc < 0) {\n    BLOSC_TRACE_ERROR(\"Unable to get offset to chunk %d.\", nchunk);\n    return rc;\n  }\n\n  if (offset < 0) {\n    // Special value\n    chunk_cbytes = BLOSC_EXTENDED_HEADER_LENGTH;\n    rc = frame_special_chunk(offset, chunksize, typesize, blocksize, chunk, chunk_cbytes, needs_free);\n    if (rc < 0) {\n      return rc;\n    }\n    goto end;\n  }\n\n  if (frame->sframe) {\n    // Sparse on-disk\n    nchunk = offset;\n    return sframe_get_chunk(frame, nchunk, chunk, needs_free);\n  }\n\n  if (frame->cframe == NULL) {\n    uint8_t header[BLOSC_EXTENDED_HEADER_LENGTH];\n    FILE* fp = fopen(frame->urlpath, \"rb\");\n    fseek(fp, header_len + offset, SEEK_SET);\n    size_t rbytes = fread(header, 1, sizeof(header), fp);\n    if (rbytes != sizeof(header)) {\n      BLOSC_TRACE_ERROR(\"Cannot read the cbytes for chunk in the frame.\");\n      fclose(fp);\n      return BLOSC2_ERROR_FILE_READ;\n    }\n    rc = blosc2_cbuffer_sizes(header, NULL, &chunk_cbytes, NULL);\n    if (rc < 0) {\n      BLOSC_TRACE_ERROR(\"Cannot read the cbytes for chunk in the frame.\");\n      fclose(fp);\n      return rc;\n    }\n    *chunk = malloc(chunk_cbytes);\n    fseek(fp, header_len + offset, SEEK_SET);\n    rbytes = fread(*chunk, 1, chunk_cbytes, fp);\n    fclose(fp);\n    if (rbytes != chunk_cbytes) {\n      BLOSC_TRACE_ERROR(\"Cannot read the chunk out of the frame.\");\n      return BLOSC2_ERROR_FILE_READ;\n    }\n    *needs_free = true;\n  } else {\n    // The chunk is in memory and just one pointer away\n    *chunk = frame->cframe + header_len + offset;\n    rc = blosc2_cbuffer_sizes(*chunk, NULL, &chunk_cbytes, NULL);\n    if (rc < 0) {\n      return rc;\n    }\n  }\n\n  end:\n  return (int32_t)chunk_cbytes;\n}\nint frame_get_lazychunk(blosc2_frame_s *frame, int nchunk, uint8_t **chunk, bool *needs_free) {\n  int32_t header_len;\n  int64_t frame_len;\n  int64_t nbytes;\n  int64_t cbytes;\n  int32_t blocksize;\n  int32_t chunksize;\n  int32_t nchunks;\n  int32_t typesize;\n  int32_t lazychunk_cbytes;\n  int64_t offset;\n  FILE* fp = NULL;\n\n  *chunk = NULL;\n  *needs_free = false;\n  int rc = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes,\n                           &blocksize, &chunksize, &nchunks,\n                           &typesize, NULL, NULL, NULL, NULL);\n  if (rc < 0) {\n    BLOSC_TRACE_ERROR(\"Unable to get meta info from frame.\");\n    return rc;\n  }\n\n  if (nchunk >= nchunks) {\n    BLOSC_TRACE_ERROR(\"nchunk ('%d') exceeds the number of chunks \"\n                      \"('%d') in frame.\", nchunk, nchunks);\n    return BLOSC2_ERROR_INVALID_PARAM;\n  }\n\n  // Get the offset to nchunk\n  rc = get_coffset(frame, header_len, cbytes, nchunk, &offset);\n  if (rc < 0) {\n    BLOSC_TRACE_ERROR(\"Unable to get offset to chunk %d.\", nchunk);\n    return rc;\n  }\n\n  if (offset < 0) {\n    // Special value\n    lazychunk_cbytes = BLOSC_EXTENDED_HEADER_LENGTH;\n    rc = frame_special_chunk(offset, chunksize, typesize, blocksize, chunk,\n                             (int32_t)lazychunk_cbytes, needs_free);\n    goto end;\n  }\n\n  if (frame->cframe == NULL) {\n    // TODO: make this portable across different endianness\n    // Get info for building a lazy chunk\n    int32_t chunk_nbytes;\n    int32_t chunk_cbytes;\n    int32_t chunk_blocksize;\n    uint8_t header[BLOSC_EXTENDED_HEADER_LENGTH];\n    if (frame->sframe) {\n      // The chunk is not in the frame\n      fp = sframe_open_chunk(frame->urlpath, offset, \"rb\");\n    }\n    else {\n      fp = fopen(frame->urlpath, \"rb\");\n      fseek(fp, header_len + offset, SEEK_SET);\n    }\n    size_t rbytes = fread(header, 1, BLOSC_EXTENDED_HEADER_LENGTH, fp);\n    if (rbytes != BLOSC_EXTENDED_HEADER_LENGTH) {\n      BLOSC_TRACE_ERROR(\"Cannot read the header for chunk in the frame.\");\n      rc = BLOSC2_ERROR_FILE_READ;\n      goto end;\n    }\n    rc = blosc2_cbuffer_sizes(header, &chunk_nbytes, &chunk_cbytes, &chunk_blocksize);\n    if (rc < 0) {\n      goto end;\n    }\n    size_t nblocks = chunk_nbytes / chunk_blocksize;\n    size_t leftover_block = chunk_nbytes % chunk_blocksize;\n    nblocks = leftover_block ? nblocks + 1 : nblocks;\n    // Allocate space for the lazy chunk\n    size_t trailer_len;\n    int32_t special_type = (header[BLOSC2_CHUNK_BLOSC2_FLAGS] >> 4) & BLOSC2_SPECIAL_MASK;\n    size_t trailer_offset = BLOSC_EXTENDED_HEADER_LENGTH;\n    if (special_type == 0) {\n      // Regular values have offsets for blocks\n      trailer_offset += nblocks * sizeof(int32_t);\n      trailer_len = sizeof(int32_t) + sizeof(int64_t) + nblocks * sizeof(int32_t);\n      lazychunk_cbytes = trailer_offset + trailer_len;\n    }\n    else if (special_type == BLOSC2_VALUE_RUNLEN) {\n      trailer_offset += typesize;\n      trailer_len = 0;\n      lazychunk_cbytes = trailer_offset + trailer_len;\n    }\n    else {\n      rc = BLOSC2_ERROR_INVALID_HEADER;\n      goto end;\n    }\n    *chunk = malloc(lazychunk_cbytes);\n    *needs_free = true;\n\n    // Read just the full header and bstarts section too (lazy partial length)\n    if (frame->sframe) {\n      fseek(fp, 0, SEEK_SET);\n    }\n    else {\n      fseek(fp, header_len + offset, SEEK_SET);\n    }\n\n    rbytes = fread(*chunk, 1, trailer_offset, fp);\n    if (rbytes != trailer_offset) {\n      BLOSC_TRACE_ERROR(\"Cannot read the (lazy) chunk out of the frame.\");\n      rc = BLOSC2_ERROR_FILE_READ;\n      goto end;\n    }\n    if (special_type == BLOSC2_VALUE_RUNLEN) {\n      // Value runlen is not returning a lazy chunk.  We are done.\n      goto end;\n    }\n\n    // Mark chunk as lazy\n    uint8_t* blosc2_flags = *chunk + BLOSC2_CHUNK_BLOSC2_FLAGS;\n    *blosc2_flags |= 0x08U;\n\n    // Add the trailer (currently, nchunk + offset + block_csizes)\n    if (frame->sframe) {\n      *(int32_t*)(*chunk + trailer_offset) = (int32_t)offset;   // offset is nchunk for sframes\n      *(int64_t*)(*chunk + trailer_offset + sizeof(int32_t)) = offset;\n    }\n    else {\n      *(int32_t*)(*chunk + trailer_offset) = nchunk;\n      *(int64_t*)(*chunk + trailer_offset + sizeof(int32_t)) = header_len + offset;\n    }\n\n    int32_t* block_csizes = malloc(nblocks * sizeof(int32_t));\n\n    int memcpyed = *(*chunk + BLOSC2_CHUNK_FLAGS) & (uint8_t)BLOSC_MEMCPYED;\n    if (memcpyed) {\n      // When memcpyed the blocksizes are trivial to compute\n      for (int i = 0; i < (int)nblocks; i++) {\n        block_csizes[i] = (int)chunk_blocksize;\n      }\n    }\n    else {\n      // In regular, compressed chunks, we need to sort the bstarts (they can be out\n      // of order because of multi-threading), and get a reverse index too.\n      memcpy(block_csizes, *chunk + BLOSC_EXTENDED_HEADER_LENGTH, nblocks * sizeof(int32_t));\n      // Helper structure to keep track of original indexes\n      struct csize_idx *csize_idx = malloc(nblocks * sizeof(struct csize_idx));\n      for (int n = 0; n < (int)nblocks; n++) {\n        csize_idx[n].val = block_csizes[n];\n        csize_idx[n].idx = n;\n      }\n      qsort(csize_idx, nblocks, sizeof(struct csize_idx), &sort_offset);\n      // Compute the actual csizes\n      int idx;\n      for (int n = 0; n < (int)nblocks - 1; n++) {\n        idx = csize_idx[n].idx;\n        block_csizes[idx] = csize_idx[n + 1].val - csize_idx[n].val;\n      }\n      idx = csize_idx[nblocks - 1].idx;\n      block_csizes[idx] = (int)chunk_cbytes - csize_idx[nblocks - 1].val;\n      free(csize_idx);\n    }\n    // Copy the csizes at the end of the trailer\n    void *trailer_csizes = *chunk + lazychunk_cbytes - nblocks * sizeof(int32_t);\n    memcpy(trailer_csizes, block_csizes, nblocks * sizeof(int32_t));\n    free(block_csizes);\n  } else {\n    // The chunk is in memory and just one pointer away\n    int64_t chunk_header_offset = header_len + offset;\n    int64_t chunk_cbytes_offset = chunk_header_offset + BLOSC_MIN_HEADER_LENGTH;\n\n    *chunk = frame->cframe + chunk_header_offset;\n\n    if (chunk_cbytes_offset > frame->len) {\n      BLOSC_TRACE_ERROR(\"Cannot read the header for chunk in the (contiguous) frame.\");\n      rc = BLOSC2_ERROR_READ_BUFFER;\n    } else {\n      rc = blosc2_cbuffer_sizes(*chunk, NULL, &lazychunk_cbytes, NULL);\n      if (rc && chunk_cbytes_offset + lazychunk_cbytes > frame_len) {\n        BLOSC_TRACE_ERROR(\"Compressed bytes exceed beyond frame length.\");\n        rc = BLOSC2_ERROR_READ_BUFFER;\n      }\n    }\n  }\n\n  end:\n  if (fp != NULL) {\n    fclose(fp);\n  }\n  if (rc < 0) {\n    if (*needs_free) {\n      free(*chunk);\n      *chunk = NULL;\n    }\n    return rc;\n  }\n\n  return (int)lazychunk_cbytes;\n}\nint frame_reorder_offsets(blosc2_frame_s* frame, const int* offsets_order, blosc2_schunk* schunk) {\n  // Get header info\n  int32_t header_len;\n  int64_t frame_len;\n  int64_t nbytes;\n  int64_t cbytes;\n  int32_t blocksize;\n  int32_t chunksize;\n  int32_t nchunks;\n  int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes,\n                            &blocksize, &chunksize,  &nchunks,\n                            NULL, NULL, NULL, NULL, NULL);\n  if (ret < 0) {\n      BLOSC_TRACE_ERROR(\"Cannot get the header info for the frame.\");\n      return ret;\n  }\n\n  // Get the current offsets and add one more\n  int32_t off_nbytes = nchunks * sizeof(int64_t);\n  int64_t* offsets = (int64_t *) malloc((size_t)off_nbytes);\n\n  int32_t coffsets_cbytes = 0;\n  uint8_t *coffsets = get_coffsets(frame, header_len, cbytes, &coffsets_cbytes);\n  if (coffsets == NULL) {\n    BLOSC_TRACE_ERROR(\"Cannot get the offsets for the frame.\");\n    free(offsets);\n    return BLOSC2_ERROR_DATA;\n  }\n\n  // Decompress offsets\n  blosc2_dparams off_dparams = BLOSC2_DPARAMS_DEFAULTS;\n  blosc2_context *dctx = blosc2_create_dctx(off_dparams);\n  int32_t prev_nbytes = blosc2_decompress_ctx(dctx, coffsets, coffsets_cbytes,\n                                              offsets, off_nbytes);\n  blosc2_free_ctx(dctx);\n  if (prev_nbytes < 0) {\n    free(offsets);\n    BLOSC_TRACE_ERROR(\"Cannot decompress the offsets chunk.\");\n    return prev_nbytes;\n  }\n\n  // Make a copy of the chunk offsets and reorder it\n  int64_t *offsets_copy = malloc(prev_nbytes);\n  memcpy(offsets_copy, offsets, prev_nbytes);\n\n  for (int i = 0; i < nchunks; ++i) {\n    offsets[i] = offsets_copy[offsets_order[i]];\n  }\n  free(offsets_copy);\n\n  // Re-compress the offsets again\n  blosc2_context* cctx = blosc2_create_cctx(BLOSC2_CPARAMS_DEFAULTS);\n  cctx->typesize = sizeof(int64_t);\n  void* off_chunk = malloc((size_t)off_nbytes + BLOSC_MAX_OVERHEAD);\n  int32_t new_off_cbytes = blosc2_compress_ctx(cctx, offsets, off_nbytes,\n                                               off_chunk, off_nbytes + BLOSC_MAX_OVERHEAD);\n  blosc2_free_ctx(cctx);\n\n  if (new_off_cbytes < 0) {\n    free(offsets);\n    free(off_chunk);\n    return new_off_cbytes;\n  }\n  free(offsets);\n  int64_t new_frame_len;\n  if (frame->sframe) {\n    // The chunks are not in the frame\n    new_frame_len = header_len + 0 + new_off_cbytes + frame->trailer_len;\n  }\n  else {\n    new_frame_len = header_len + cbytes + new_off_cbytes + frame->trailer_len;\n  }\n\n  if (frame->cframe != NULL) {\n    uint8_t* framep = frame->cframe;\n    /* Make space for the new chunk and copy it */\n    frame->cframe = framep = realloc(framep, (size_t)new_frame_len);\n    if (framep == NULL) {\n      BLOSC_TRACE_ERROR(\"Cannot realloc space for the frame.\");\n      return BLOSC2_ERROR_MEMORY_ALLOC;\n    }\n    /* Copy the offsets */\n    memcpy(framep + header_len + cbytes, off_chunk, (size_t)new_off_cbytes);\n  }\n  else {\n    FILE* fp = NULL;\n    if (frame->sframe) {\n      // Update the offsets chunk in the chunks frame\n      fp = sframe_open_index(frame->urlpath, \"rb+\");\n      fseek(fp, header_len + 0, SEEK_SET);\n    }\n    else {\n      // Regular frame\n      fp = fopen(frame->urlpath, \"rb+\");\n      fseek(fp, header_len + cbytes, SEEK_SET);\n    }\n    size_t wbytes = fwrite(off_chunk, 1, (size_t)new_off_cbytes, fp);  // the new offsets\n    fclose(fp);\n    if (wbytes != (size_t)new_off_cbytes) {\n      BLOSC_TRACE_ERROR(\"Cannot write the offsets to frame.\");\n      return BLOSC2_ERROR_FILE_WRITE;\n    }\n  }\n\n  // Invalidate the cache for chunk offsets\n  if (frame->coffsets != NULL) {\n    free(frame->coffsets);\n    frame->coffsets = NULL;\n  }\n  free(off_chunk);\n\n  frame->len = new_frame_len;\n  int rc = frame_update_header(frame, schunk, false);\n  if (rc < 0) {\n    return rc;\n  }\n\n  rc = frame_update_trailer(frame, schunk);\n  if (rc < 0) {\n    return rc;\n  }\n\n  return 0;\n}\n",
    "target": 1,
    "idx": 1032076,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic void\nfz_draw_clip_image_mask(fz_context *ctx, fz_device *devp, fz_image *image, fz_matrix in_ctm, fz_rect scissor)\n{\n\tfz_draw_device *dev = (fz_draw_device*)devp;\n\tfz_matrix local_ctm = fz_concat(in_ctm, dev->transform);\n\tfz_irect bbox;\n\tfz_pixmap *scaled = NULL;\n\tfz_pixmap *pixmap = NULL;\n\tint dx, dy;\n\tfz_draw_state *state = push_stack(ctx, dev, \"clip image mask\");\n\tfz_colorspace *model = state->dest->colorspace;\n\tfz_irect clip;\n\tfz_irect src_area;\n\n\tfz_var(pixmap);\n\n\tif (dev->top == 0 && dev->resolve_spots)\n\t\tstate = push_group_for_separations(ctx, dev, fz_default_color_params /* FIXME */, dev->default_cs);\n\n\tclip = fz_pixmap_bbox(ctx, state->dest);\n\tclip = fz_intersect_irect(clip, state->scissor);\n\n\tif (image->w == 0 || image->h == 0)\n\t{\n#ifdef DUMP_GROUP_BLENDS\n\t\tdump_spaces(dev->top-1, \"Clip (image mask) (empty) begin\\n\");\n#endif\n\t\tstate[1].scissor = fz_empty_irect;\n\t\tstate[1].mask = NULL;\n\t\treturn;\n\t}\n\n\tlocal_ctm = fz_gridfit_matrix(devp->flags & FZ_DEVFLAG_GRIDFIT_AS_TILED, local_ctm);\n\n\tsrc_area = find_src_area_required(local_ctm, image, clip);\n\tif (fz_is_empty_irect(src_area))\n\t{\n#ifdef DUMP_GROUP_BLENDS\n\t\tdump_spaces(dev->top-1, \"Clip (image mask) (empty source area) begin\\n\");\n#endif\n\t\tstate[1].scissor = fz_empty_irect;\n\t\tstate[1].mask = NULL;\n\t\treturn;\n\t}\n\n\tbbox = fz_irect_from_rect(fz_transform_rect(fz_unit_rect, local_ctm));\n\tbbox = fz_intersect_irect(bbox, state->scissor);\n\tif (!fz_is_infinite_rect(scissor))\n\t{\n\t\tfz_rect tscissor = fz_transform_rect(scissor, dev->transform);\n\t\tbbox = fz_intersect_irect(bbox, fz_irect_from_rect(tscissor));\n\t}\n\tif (!fz_is_valid_irect(bbox))\n\t{\n#ifdef DUMP_GROUP_BLENDS\n\t\tdump_spaces(dev->top-1, \"Clip (image mask) (invalid) begin\\n\");\n#endif\n\t\tstate[1].scissor = fz_empty_irect;\n\t\tstate[1].mask = NULL;\n\t\treturn;\n\t}\n\n#ifdef DUMP_GROUP_BLENDS\n\tdump_spaces(dev->top-1, \"Clip (image mask) begin\\n\");\n#endif\n\n\tfz_try(ctx)\n\t{\n\t\tpixmap = fz_get_pixmap_from_image(ctx, image, &src_area, &local_ctm, &dx, &dy);\n\n\t\tstate[1].mask = fz_new_pixmap_with_bbox(ctx, NULL, bbox, NULL, 1);\n\t\tfz_clear_pixmap(ctx, state[1].mask);\n\n\t\tstate[1].dest = fz_new_pixmap_with_bbox(ctx, model, bbox, state[0].dest->seps, state[0].dest->alpha);\n\t\tfz_copy_pixmap_rect(ctx, state[1].dest, state[0].dest, bbox, dev->default_cs);\n\t\tif (state[0].shape)\n\t\t{\n\t\t\tstate[1].shape = fz_new_pixmap_with_bbox(ctx, NULL, bbox, NULL, 1);\n\t\t\tfz_clear_pixmap(ctx, state[1].shape);\n\t\t}\n\t\tif (state[0].group_alpha)\n\t\t{\n\t\t\tstate[1].group_alpha = fz_new_pixmap_with_bbox(ctx, NULL, bbox, NULL, 1);\n\t\t\tfz_clear_pixmap(ctx, state[1].group_alpha);\n\t\t}\n\n\t\tstate[1].blendmode |= FZ_BLEND_ISOLATED;\n\t\tstate[1].scissor = bbox;\n\n\t\tif (!(devp->hints & FZ_DONT_INTERPOLATE_IMAGES) && ctx->tuning->image_scale(ctx->tuning->image_scale_arg, dx, dy, pixmap->w, pixmap->h))\n\t\t{\n\t\t\tint gridfit = !(dev->flags & FZ_DRAWDEV_FLAGS_TYPE3);\n\t\t\tscaled = fz_transform_pixmap(ctx, dev, pixmap, &local_ctm, state->dest->x, state->dest->y, dx, dy, gridfit, &clip);\n\t\t\tif (!scaled)\n\t\t\t{\n\t\t\t\tif (dx < 1)\n\t\t\t\t\tdx = 1;\n\t\t\t\tif (dy < 1)\n\t\t\t\t\tdy = 1;\n\t\t\t\tscaled = fz_scale_pixmap_cached(ctx, pixmap, pixmap->x, pixmap->y, dx, dy, NULL, dev->cache_x, dev->cache_y);\n\t\t\t}\n\t\t\tif (scaled)\n\t\t\t{\n\t\t\t\tfz_drop_pixmap(ctx, pixmap);\n\t\t\t\tpixmap = scaled;\n\t\t\t}\n\t\t}\n\n#ifdef DUMP_GROUP_BLENDS\n\t\tdump_spaces(dev->top, \"\");\n\t\tfz_dump_blend(ctx, \"Creating imagemask: plotting \", pixmap);\n\t\tfz_dump_blend(ctx, \" onto \", state[1].mask);\n\t\tif (state[1].shape)\n\t\t\tfz_dump_blend(ctx, \"/S=\", state[1].shape);\n\t\tif (state[1].group_alpha)\n\t\t\tfz_dump_blend(ctx, \"/GA=\", state[1].group_alpha);\n#endif\n\n\t\tfz_paint_image(ctx, state[1].mask, &bbox, state[1].shape, state[1].group_alpha, pixmap, local_ctm, 255, !(devp->hints & FZ_DONT_INTERPOLATE_IMAGES), 0);\n\n#ifdef DUMP_GROUP_BLENDS\n\t\tfz_dump_blend(ctx, \" to get \", state[1].mask);\n\t\tif (state[1].shape)\n\t\t\tfz_dump_blend(ctx, \"/S=\", state[1].shape);\n\t\tif (state[1].group_alpha)\n\t\t\tfz_dump_blend(ctx, \"/GA=\", state[1].group_alpha);\n\t\tprintf(\"\\n\");\n#endif\n\t}\n\tfz_always(ctx)\n\t\tfz_drop_pixmap(ctx, pixmap);\n\tfz_catch(ctx)\n\t\tfz_rethrow(ctx);\n}\n\nvoid\nfz_clip_image_mask(fz_context *ctx, fz_device *dev, fz_image *image, fz_matrix ctm, fz_rect scissor)\n{\n\tfz_rect bbox = fz_transform_rect(fz_unit_rect, ctm);\n\tbbox = fz_intersect_rect(bbox, scissor);\n\tpush_clip_stack(ctx, dev, bbox, fz_device_container_stack_is_clip);\n\n\tif (dev->clip_image_mask)\n\t{\n\t\tfz_try(ctx)\n\t\t\tdev->clip_image_mask(ctx, dev, image, ctm, scissor);\n\t\tfz_catch(ctx)\n\t\t{\n\t\t\tfz_disable_device(ctx, dev);\n\t\t\tfz_rethrow(ctx);\n\t\t}\n\t}\n}\n\nstatic void\npdf_show_image(fz_context *ctx, pdf_run_processor *pr, fz_image *image)\n{\n\tpdf_gstate *gstate = pr->gstate + pr->gtop;\n\tfz_matrix image_ctm;\n\tfz_rect bbox;\n\n\tif (pr->super.hidden)\n\t\treturn;\n\n\t/* PDF has images bottom-up, so flip them right side up here */\n\timage_ctm = fz_pre_scale(fz_pre_translate(gstate->ctm, 0, 1), 1, -1);\n\n\tbbox = fz_transform_rect(fz_unit_rect, image_ctm);\n\n\tif (image->mask && gstate->blendmode)\n\t{\n\t\t/* apply blend group even though we skip the soft mask */\n\t\tfz_begin_group(ctx, pr->dev, bbox, NULL, 0, 0, gstate->blendmode, 1);\n\t\tfz_clip_image_mask(ctx, pr->dev, image->mask, image_ctm, bbox);\n\t\tpdf_show_image_imp(ctx, pr, image, image_ctm, bbox);\n\t\tfz_pop_clip(ctx, pr->dev);\n\t\tfz_end_group(ctx, pr->dev);\n\t}\n\telse if (image->mask)\n\t{\n\t\tfz_clip_image_mask(ctx, pr->dev, image->mask, image_ctm, bbox);\n\t\tpdf_show_image_imp(ctx, pr, image, image_ctm, bbox);\n\t\tfz_pop_clip(ctx, pr->dev);\n\t}\n\telse\n\t{\n\t\tsoftmask_save softmask = { NULL };\n\t\tfz_try(ctx)\n\t\t{\n\t\t\tgstate = pdf_begin_group(ctx, pr, bbox, &softmask);\n\t\t\tpdf_show_image_imp(ctx, pr, image, image_ctm, bbox);\n\t\t\tpdf_end_group(ctx, pr, &softmask);\n\t\t}\n\t\tfz_catch(ctx)\n\t\t{\n\t\t\tpdf_drop_obj(ctx, softmask.softmask);\n\t\t\tpdf_drop_obj(ctx, softmask.page_resources);\n\t\t\tfz_rethrow(ctx);\n\t\t}\n\t}\n}\n\nstatic void pdf_run_Do_image(fz_context *ctx, pdf_processor *proc, const char *name, fz_image *image)\n{\n\tpdf_run_processor *pr = (pdf_run_processor *)proc;\n\tpdf_show_image(ctx, pr, image);\n}\n\nstatic void\npdf_process_Do(fz_context *ctx, pdf_processor *proc, pdf_csi *csi)\n{\n\tpdf_obj *xres, *xobj, *subtype;\n\n\txres = pdf_dict_get(ctx, csi->rdb, PDF_NAME(XObject));\n\txobj = pdf_dict_gets(ctx, xres, csi->name);\n\tif (!xobj)\n\t\tfz_throw(ctx, FZ_ERROR_MINOR, \"cannot find XObject resource '%s'\", csi->name);\n\tsubtype = pdf_dict_get(ctx, xobj, PDF_NAME(Subtype));\n\tif (pdf_name_eq(ctx, subtype, PDF_NAME(Form)))\n\t{\n\t\tpdf_obj *st = pdf_dict_get(ctx, xobj, PDF_NAME(Subtype2));\n\t\tif (st)\n\t\t\tsubtype = st;\n\t}\n\tif (!pdf_is_name(ctx, subtype))\n\t\tfz_throw(ctx, FZ_ERROR_MINOR, \"no XObject subtype specified\");\n\n\tif (pdf_is_ocg_hidden(ctx, csi->doc, csi->rdb, proc->usage, pdf_dict_get(ctx, xobj, PDF_NAME(OC))))\n\t\treturn;\n\n\tif (pdf_name_eq(ctx, subtype, PDF_NAME(Form)))\n\t{\n\t\tif (proc->op_Do_form)\n\t\t\tproc->op_Do_form(ctx, proc, csi->name, xobj, csi->rdb);\n\t}\n\n\telse if (pdf_name_eq(ctx, subtype, PDF_NAME(Image)))\n\t{\n\t\tif (proc->op_Do_image)\n\t\t{\n\t\t\tfz_image *image = pdf_load_image(ctx, csi->doc, xobj);\n\t\t\tfz_try(ctx)\n\t\t\t\tproc->op_Do_image(ctx, proc, csi->name, image);\n\t\t\tfz_always(ctx)\n\t\t\t\tfz_drop_image(ctx, image);\n\t\t\tfz_catch(ctx)\n\t\t\t\tfz_rethrow(ctx);\n\t\t}\n\t}\n\n\telse if (!strcmp(pdf_to_name(ctx, subtype), \"PS\"))\n\t\tfz_warn(ctx, \"ignoring XObject with subtype PS\");\n\telse\n\t\tfz_warn(ctx, \"ignoring XObject with unknown subtype: '%s'\", pdf_to_name(ctx, subtype));\n}\n\nstatic void\npdf_process_keyword(fz_context *ctx, pdf_processor *proc, pdf_csi *csi, fz_stream *stm, char *word)\n{\n\tfloat *s = csi->stack;\n\tchar csname[40];\n\tint key;\n\n\tkey = word[0];\n\tif (word[1])\n\t{\n\t\tkey |= word[1] << 8;\n\t\tif (word[2])\n\t\t{\n\t\t\tkey |= word[2] << 16;\n\t\t\tif (word[3])\n\t\t\t\tkey = 0;\n\t\t}\n\t}\n\n\tswitch (key)\n\t{\n\tdefault:\n\t\tif (!csi->xbalance)\n\t\t{\n\t\t\tif (is_known_bad_word(word))\n\t\t\t\tfz_throw(ctx, FZ_ERROR_MINOR, \"unknown keyword: '%s'\", word);\n\t\t\telse\n\t\t\t\tfz_throw(ctx, FZ_ERROR_SYNTAX, \"unknown keyword: '%s'\", word);\n\t\t}\n\t\tbreak;\n\n\t/* general graphics state */\n\tcase A('w'): if (proc->op_w) proc->op_w(ctx, proc, s[0]); break;\n\tcase A('j'): if (proc->op_j) proc->op_j(ctx, proc, fz_clampi(s[0], 0, 2)); break;\n\tcase A('J'): if (proc->op_J) proc->op_J(ctx, proc, fz_clampi(s[0], 0, 2)); break;\n\tcase A('M'): if (proc->op_M) proc->op_M(ctx, proc, s[0]); break;\n\tcase A('d'): if (proc->op_d) proc->op_d(ctx, proc, csi->obj, s[0]); break;\n\tcase B('r','i'): if (proc->op_ri) proc->op_ri(ctx, proc, csi->name); break;\n\tcase A('i'): if (proc->op_i) proc->op_i(ctx, proc, s[0]); break;\n\n\tcase B('g','s'):\n\t\t{\n\t\t\tpdf_obj *gsres, *gsobj;\n\t\t\tgsres = pdf_dict_get(ctx, csi->rdb, PDF_NAME(ExtGState));\n\t\t\tgsobj = pdf_dict_gets(ctx, gsres, csi->name);\n\t\t\tif (!gsobj)\n\t\t\t\tfz_throw(ctx, FZ_ERROR_MINOR, \"cannot find ExtGState resource '%s'\", csi->name);\n\t\t\tif (proc->op_gs_begin)\n\t\t\t\tproc->op_gs_begin(ctx, proc, csi->name, gsobj);\n\t\t\tpdf_process_extgstate(ctx, proc, csi, gsobj);\n\t\t\tif (proc->op_gs_end)\n\t\t\t\tproc->op_gs_end(ctx, proc);\n\t\t}\n\t\tbreak;\n\n\t/* special graphics state */\n\tcase A('q'): pdf_process_gsave(ctx, proc, csi); break;\n\tcase A('Q'): pdf_process_grestore(ctx, proc, csi); break;\n\tcase B('c','m'): if (proc->op_cm) proc->op_cm(ctx, proc, s[0], s[1], s[2], s[3], s[4], s[5]); break;\n\n\t/* path construction */\n\tcase A('m'): if (proc->op_m) proc->op_m(ctx, proc, s[0], s[1]); break;\n\tcase A('l'): if (proc->op_l) proc->op_l(ctx, proc, s[0], s[1]); break;\n\tcase A('c'): if (proc->op_c) proc->op_c(ctx, proc, s[0], s[1], s[2], s[3], s[4], s[5]); break;\n\tcase A('v'): if (proc->op_v) proc->op_v(ctx, proc, s[0], s[1], s[2], s[3]); break;\n\tcase A('y'): if (proc->op_y) proc->op_y(ctx, proc, s[0], s[1], s[2], s[3]); break;\n\tcase A('h'): if (proc->op_h) proc->op_h(ctx, proc); break;\n\tcase B('r','e'): if (proc->op_re) proc->op_re(ctx, proc, s[0], s[1], s[2], s[3]); break;\n\n\t/* path painting */\n\tcase A('S'): if (proc->op_S) proc->op_S(ctx, proc); break;\n\tcase A('s'): if (proc->op_s) proc->op_s(ctx, proc); break;\n\tcase A('F'): if (proc->op_F) proc->op_F(ctx, proc); break;\n\tcase A('f'): if (proc->op_f) proc->op_f(ctx, proc); break;\n\tcase B('f','*'): if (proc->op_fstar) proc->op_fstar(ctx, proc); break;\n\tcase A('B'): if (proc->op_B) proc->op_B(ctx, proc); break;\n\tcase B('B','*'): if (proc->op_Bstar) proc->op_Bstar(ctx, proc); break;\n\tcase A('b'): if (proc->op_b) proc->op_b(ctx, proc); break;\n\tcase B('b','*'): if (proc->op_bstar) proc->op_bstar(ctx, proc); break;\n\tcase A('n'): if (proc->op_n) proc->op_n(ctx, proc); break;\n\n\t/* path clipping */\n\tcase A('W'): if (proc->op_W) proc->op_W(ctx, proc); break;\n\tcase B('W','*'): if (proc->op_Wstar) proc->op_Wstar(ctx, proc); break;\n\n\t/* text objects */\n\tcase B('B','T'): csi->in_text = 1; if (proc->op_BT) proc->op_BT(ctx, proc); break;\n\tcase B('E','T'): csi->in_text = 0; if (proc->op_ET) proc->op_ET(ctx, proc); break;\n\n\t/* text state */\n\tcase B('T','c'): if (proc->op_Tc) proc->op_Tc(ctx, proc, s[0]); break;\n\tcase B('T','w'): if (proc->op_Tw) proc->op_Tw(ctx, proc, s[0]); break;\n\tcase B('T','z'): if (proc->op_Tz) proc->op_Tz(ctx, proc, s[0]); break;\n\tcase B('T','L'): if (proc->op_TL) proc->op_TL(ctx, proc, s[0]); break;\n\tcase B('T','r'): if (proc->op_Tr) proc->op_Tr(ctx, proc, s[0]); break;\n\tcase B('T','s'): if (proc->op_Ts) proc->op_Ts(ctx, proc, s[0]); break;\n\n\tcase B('T','f'):\n\t\tif (proc->op_Tf)\n\t\t{\n\t\t\tpdf_obj *fontres, *fontobj;\n\t\t\tpdf_font_desc *font;\n\t\t\tfontres = pdf_dict_get(ctx, csi->rdb, PDF_NAME(Font));\n\t\t\tfontobj = pdf_dict_gets(ctx, fontres, csi->name);\n\t\t\tif (pdf_is_dict(ctx, fontobj))\n\t\t\t\tfont = pdf_try_load_font(ctx, csi->doc, csi->rdb, fontobj, csi->cookie);\n\t\t\telse\n\t\t\t\tfont = pdf_load_hail_mary_font(ctx, csi->doc);\n\t\t\tfz_try(ctx)\n\t\t\t\tproc->op_Tf(ctx, proc, csi->name, font, s[0]);\n\t\t\tfz_always(ctx)\n\t\t\t\tpdf_drop_font(ctx, font);\n\t\t\tfz_catch(ctx)\n\t\t\t\tfz_rethrow(ctx);\n\t\t}\n\t\tbreak;\n\n\t/* text positioning */\n\tcase B('T','d'): if (proc->op_Td) proc->op_Td(ctx, proc, s[0], s[1]); break;\n\tcase B('T','D'): if (proc->op_TD) proc->op_TD(ctx, proc, s[0], s[1]); break;\n\tcase B('T','m'): if (proc->op_Tm) proc->op_Tm(ctx, proc, s[0], s[1], s[2], s[3], s[4], s[5]); break;\n\tcase B('T','*'): if (proc->op_Tstar) proc->op_Tstar(ctx, proc); break;\n\n\t/* text showing */\n\tcase B('T','J'): if (proc->op_TJ) proc->op_TJ(ctx, proc, csi->obj); break;\n\tcase B('T','j'):\n\t\tif (proc->op_Tj)\n\t\t{\n\t\t\tif (csi->string_len > 0)\n\t\t\t\tproc->op_Tj(ctx, proc, csi->string, csi->string_len);\n\t\t\telse\n\t\t\t\tproc->op_Tj(ctx, proc, pdf_to_str_buf(ctx, csi->obj), pdf_to_str_len(ctx, csi->obj));\n\t\t}\n\t\tbreak;\n\tcase A('\\''):\n\t\tif (proc->op_squote)\n\t\t{\n\t\t\tif (csi->string_len > 0)\n\t\t\t\tproc->op_squote(ctx, proc, csi->string, csi->string_len);\n\t\t\telse\n\t\t\t\tproc->op_squote(ctx, proc, pdf_to_str_buf(ctx, csi->obj), pdf_to_str_len(ctx, csi->obj));\n\t\t}\n\t\tbreak;\n\tcase A('\"'):\n\t\tif (proc->op_dquote)\n\t\t{\n\t\t\tif (csi->string_len > 0)\n\t\t\t\tproc->op_dquote(ctx, proc, s[0], s[1], csi->string, csi->string_len);\n\t\t\telse\n\t\t\t\tproc->op_dquote(ctx, proc, s[0], s[1], pdf_to_str_buf(ctx, csi->obj), pdf_to_str_len(ctx, csi->obj));\n\t\t}\n\t\tbreak;\n\n\t/* type 3 fonts */\n\tcase B('d','0'): if (proc->op_d0) proc->op_d0(ctx, proc, s[0], s[1]); break;\n\tcase B('d','1'): if (proc->op_d1) proc->op_d1(ctx, proc, s[0], s[1], s[2], s[3], s[4], s[5]); break;\n\n\t/* color */\n\tcase B('C','S'): pdf_process_CS(ctx, proc, csi, 1); break;\n\tcase B('c','s'): pdf_process_CS(ctx, proc, csi, 0); break;\n\tcase B('S','C'): pdf_process_SC(ctx, proc, csi, 1); break;\n\tcase B('s','c'): pdf_process_SC(ctx, proc, csi, 0); break;\n\tcase C('S','C','N'): pdf_process_SC(ctx, proc, csi, 1); break;\n\tcase C('s','c','n'): pdf_process_SC(ctx, proc, csi, 0); break;\n\n\tcase A('G'): if (proc->op_G) proc->op_G(ctx, proc, s[0]); break;\n\tcase A('g'): if (proc->op_g) proc->op_g(ctx, proc, s[0]); break;\n\tcase B('R','G'): if (proc->op_RG) proc->op_RG(ctx, proc, s[0], s[1], s[2]); break;\n\tcase B('r','g'): if (proc->op_rg) proc->op_rg(ctx, proc, s[0], s[1], s[2]); break;\n\tcase A('K'): if (proc->op_K) proc->op_K(ctx, proc, s[0], s[1], s[2], s[3]); break;\n\tcase A('k'): if (proc->op_k) proc->op_k(ctx, proc, s[0], s[1], s[2], s[3]); break;\n\n\t/* shadings, images, xobjects */\n\tcase B('B','I'):\n\t\t{\n\t\t\tfz_image *img = parse_inline_image(ctx, csi, stm, csname, sizeof csname);\n\t\t\tfz_try(ctx)\n\t\t\t{\n\t\t\t\tif (proc->op_BI)\n\t\t\t\t\tproc->op_BI(ctx, proc, img, csname[0] ? csname : NULL);\n\t\t\t}\n\t\t\tfz_always(ctx)\n\t\t\t\tfz_drop_image(ctx, img);\n\t\t\tfz_catch(ctx)\n\t\t\t\tfz_rethrow(ctx);\n\t\t}\n\t\tbreak;\n\n\tcase B('s','h'):\n\t\tif (proc->op_sh)\n\t\t{\n\t\t\tpdf_obj *shaderes, *shadeobj;\n\t\t\tfz_shade *shade;\n\t\t\tshaderes = pdf_dict_get(ctx, csi->rdb, PDF_NAME(Shading));\n\t\t\tshadeobj = pdf_dict_gets(ctx, shaderes, csi->name);\n\t\t\tif (!shadeobj)\n\t\t\t\tfz_throw(ctx, FZ_ERROR_MINOR, \"cannot find Shading resource '%s'\", csi->name);\n\t\t\tshade = pdf_load_shading(ctx, csi->doc, shadeobj);\n\t\t\tfz_try(ctx)\n\t\t\t\tproc->op_sh(ctx, proc, csi->name, shade);\n\t\t\tfz_always(ctx)\n\t\t\t\tfz_drop_shade(ctx, shade);\n\t\t\tfz_catch(ctx)\n\t\t\t\tfz_rethrow(ctx);\n\t\t}\n\t\tbreak;\n\n\tcase B('D','o'): pdf_process_Do(ctx, proc, csi); break;\n\n\t/* marked content */\n\tcase B('M','P'): if (proc->op_MP) proc->op_MP(ctx, proc, csi->name); break;\n\tcase B('D','P'): if (proc->op_DP) proc->op_DP(ctx, proc, csi->name, csi->obj, resolve_properties(ctx, csi, csi->obj)); break;\n\tcase C('B','M','C'): pdf_process_BMC(ctx, proc, csi, csi->name); break;\n\tcase C('B','D','C'): pdf_process_BDC(ctx, proc, csi); break;\n\tcase C('E','M','C'): pdf_process_EMC(ctx, proc, csi); break;\n\n\t/* compatibility */\n\tcase B('B','X'): ++csi->xbalance; if (proc->op_BX) proc->op_BX(ctx, proc); break;\n\tcase B('E','X'): --csi->xbalance; if (proc->op_EX) proc->op_EX(ctx, proc); break;\n\t}\n}\n\nstatic void\npdf_process_stream(fz_context *ctx, pdf_processor *proc, pdf_csi *csi, fz_stream *stm)\n{\n\tpdf_document *doc = csi->doc;\n\tpdf_lexbuf *buf = csi->buf;\n\tfz_cookie *cookie = csi->cookie;\n\n\tpdf_token tok = PDF_TOK_ERROR;\n\tint in_text_array = 0;\n\tint syntax_errors = 0;\n\n\t/* make sure we have a clean slate if we come here from flush_text */\n\tpdf_clear_stack(ctx, csi);\n\n\tfz_var(in_text_array);\n\tfz_var(tok);\n\n\tif (cookie)\n\t{\n\t\tcookie->progress_max = -1;\n\t\tcookie->progress = 0;\n\t}\n\n\tdo\n\t{\n\t\tfz_try(ctx)\n\t\t{\n\t\t\tdo\n\t\t\t{\n\t\t\t\t/* Check the cookie */\n\t\t\t\tif (cookie)\n\t\t\t\t{\n\t\t\t\t\tif (cookie->abort)\n\t\t\t\t\t{\n\t\t\t\t\t\ttok = PDF_TOK_EOF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcookie->progress++;\n\t\t\t\t}\n\n\t\t\t\ttok = pdf_lex(ctx, stm, buf);\n\n\t\t\t\tif (in_text_array)\n\t\t\t\t{\n\t\t\t\t\tswitch(tok)\n\t\t\t\t\t{\n\t\t\t\t\tcase PDF_TOK_CLOSE_ARRAY:\n\t\t\t\t\t\tin_text_array = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PDF_TOK_REAL:\n\t\t\t\t\t\tpdf_array_push_real(ctx, csi->obj, buf->f);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PDF_TOK_INT:\n\t\t\t\t\t\tpdf_array_push_int(ctx, csi->obj, buf->i);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PDF_TOK_STRING:\n\t\t\t\t\t\tpdf_array_push_string(ctx, csi->obj, buf->scratch, buf->len);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PDF_TOK_EOF:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PDF_TOK_KEYWORD:\n\t\t\t\t\t\tif (buf->scratch[0] == 'T' && (buf->scratch[1] == 'w' || buf->scratch[1] == 'c') && buf->scratch[2] == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint n = pdf_array_len(ctx, csi->obj);\n\t\t\t\t\t\t\tif (n > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpdf_obj *o = pdf_array_get(ctx, csi->obj, n-1);\n\t\t\t\t\t\t\t\tif (pdf_is_number(ctx, o))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tcsi->stack[0] = pdf_to_real(ctx, o);\n\t\t\t\t\t\t\t\t\tpdf_array_delete(ctx, csi->obj, n-1);\n\t\t\t\t\t\t\t\t\tpdf_process_keyword(ctx, proc, csi, stm, buf->scratch);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* Deliberate Fallthrough! */\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tfz_throw(ctx, FZ_ERROR_SYNTAX, \"syntax error in array\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse switch (tok)\n\t\t\t\t{\n\t\t\t\tcase PDF_TOK_ENDSTREAM:\n\t\t\t\tcase PDF_TOK_EOF:\n\t\t\t\t\ttok = PDF_TOK_EOF;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDF_TOK_OPEN_ARRAY:\n\t\t\t\t\tif (csi->obj)\n\t\t\t\t\t{\n\t\t\t\t\t\tpdf_drop_obj(ctx, csi->obj);\n\t\t\t\t\t\tcsi->obj = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif (csi->in_text)\n\t\t\t\t\t{\n\t\t\t\t\t\tin_text_array = 1;\n\t\t\t\t\t\tcsi->obj = pdf_new_array(ctx, doc, 4);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tcsi->obj = pdf_parse_array(ctx, doc, stm, buf);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDF_TOK_OPEN_DICT:\n\t\t\t\t\tif (csi->obj)\n\t\t\t\t\t{\n\t\t\t\t\t\tpdf_drop_obj(ctx, csi->obj);\n\t\t\t\t\t\tcsi->obj = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tcsi->obj = pdf_parse_dict(ctx, doc, stm, buf);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDF_TOK_NAME:\n\t\t\t\t\tif (csi->name[0])\n\t\t\t\t\t{\n\t\t\t\t\t\tpdf_drop_obj(ctx, csi->obj);\n\t\t\t\t\t\tcsi->obj = NULL;\n\t\t\t\t\t\tcsi->obj = pdf_new_name(ctx, buf->scratch);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tfz_strlcpy(csi->name, buf->scratch, sizeof(csi->name));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDF_TOK_INT:\n\t\t\t\t\tif (csi->top < (int)nelem(csi->stack)) {\n\t\t\t\t\t\tcsi->stack[csi->top] = buf->i;\n\t\t\t\t\t\tcsi->top ++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tfz_throw(ctx, FZ_ERROR_SYNTAX, \"stack overflow\");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDF_TOK_REAL:\n\t\t\t\t\tif (csi->top < (int)nelem(csi->stack)) {\n\t\t\t\t\t\tcsi->stack[csi->top] = buf->f;\n\t\t\t\t\t\tcsi->top ++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tfz_throw(ctx, FZ_ERROR_SYNTAX, \"stack overflow\");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDF_TOK_STRING:\n\t\t\t\t\tif (buf->len <= sizeof(csi->string))\n\t\t\t\t\t{\n\t\t\t\t\t\tmemcpy(csi->string, buf->scratch, buf->len);\n\t\t\t\t\t\tcsi->string_len = buf->len;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (csi->obj)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpdf_drop_obj(ctx, csi->obj);\n\t\t\t\t\t\t\tcsi->obj = NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcsi->obj = pdf_new_string(ctx, buf->scratch, buf->len);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDF_TOK_KEYWORD:\n\t\t\t\t\tpdf_process_keyword(ctx, proc, csi, stm, buf->scratch);\n\t\t\t\t\tpdf_clear_stack(ctx, csi);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tfz_throw(ctx, FZ_ERROR_SYNTAX, \"syntax error in content stream\");\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (tok != PDF_TOK_EOF);\n\t\t}\n\t\tfz_always(ctx)\n\t\t{\n\t\t\tpdf_clear_stack(ctx, csi);\n\t\t}\n\t\tfz_catch(ctx)\n\t\t{\n\t\t\tint caught = fz_caught(ctx);\n\t\t\tif (cookie)\n\t\t\t{\n\t\t\t\tif (caught == FZ_ERROR_TRYLATER)\n\t\t\t\t{\n\t\t\t\t\tcookie->incomplete++;\n\t\t\t\t\ttok = PDF_TOK_EOF;\n\t\t\t\t}\n\t\t\t\telse if (caught == FZ_ERROR_ABORT)\n\t\t\t\t{\n\t\t\t\t\tfz_rethrow(ctx);\n\t\t\t\t}\n\t\t\t\telse if (caught == FZ_ERROR_MINOR)\n\t\t\t\t{\n\t\t\t\t\tcookie->errors++;\n\t\t\t\t}\n\t\t\t\telse if (caught == FZ_ERROR_SYNTAX)\n\t\t\t\t{\n\t\t\t\t\tcookie->errors++;\n\t\t\t\t\tif (++syntax_errors >= MAX_SYNTAX_ERRORS)\n\t\t\t\t\t{\n\t\t\t\t\t\tfz_warn(ctx, \"too many syntax errors; ignoring rest of page\");\n\t\t\t\t\t\ttok = PDF_TOK_EOF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfz_rethrow(ctx);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (caught == FZ_ERROR_TRYLATER)\n\t\t\t\t\ttok = PDF_TOK_EOF;\n\t\t\t\telse if (caught == FZ_ERROR_ABORT)\n\t\t\t\t\tfz_rethrow(ctx);\n\t\t\t\telse if (caught == FZ_ERROR_MINOR)\n\t\t\t\t\t/* ignore minor errors */ ;\n\t\t\t\telse if (caught == FZ_ERROR_SYNTAX)\n\t\t\t\t{\n\t\t\t\t\tif (++syntax_errors >= MAX_SYNTAX_ERRORS)\n\t\t\t\t\t{\n\t\t\t\t\t\tfz_warn(ctx, \"too many syntax errors; ignoring rest of page\");\n\t\t\t\t\t\ttok = PDF_TOK_EOF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfz_rethrow(ctx);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* If we do catch an error, then reset ourselves to a base lexing state */\n\t\t\tin_text_array = 0;\n\t\t}\n\t}\n\twhile (tok != PDF_TOK_EOF);\n}\n\nvoid\npdf_process_contents(fz_context *ctx, pdf_processor *proc, pdf_document *doc, pdf_obj *rdb, pdf_obj *stmobj, fz_cookie *cookie)\n{\n\tpdf_csi csi;\n\tpdf_lexbuf buf;\n\tfz_stream *stm = NULL;\n\n\tif (!stmobj)\n\t\treturn;\n\n\tfz_var(stm);\n\n\tpdf_lexbuf_init(ctx, &buf, PDF_LEXBUF_SMALL);\n\tpdf_init_csi(ctx, &csi, doc, rdb, &buf, cookie);\n\n\tfz_try(ctx)\n\t{\n\t\tfz_defer_reap_start(ctx);\n\t\tstm = pdf_open_contents_stream(ctx, doc, stmobj);\n\t\tpdf_process_stream(ctx, proc, &csi, stm);\n\t\tpdf_process_end(ctx, proc, &csi);\n\t}\n\tfz_always(ctx)\n\t{\n\t\tfz_defer_reap_end(ctx);\n\t\tfz_drop_stream(ctx, stm);\n\t\tpdf_clear_stack(ctx, &csi);\n\t\tpdf_lexbuf_fin(ctx, &buf);\n\t}\n\tfz_catch(ctx)\n\t{\n\t\tproc->close_processor = NULL; /* aborted run, don't warn about unclosed processor */\n\t\tfz_rethrow(ctx);\n\t}\n}\n\nstatic void\npdf_run_page_contents_with_usage_imp(fz_context *ctx, pdf_document *doc, pdf_page *page, fz_device *dev, fz_matrix ctm, const char *usage, fz_cookie *cookie)\n{\n\tfz_matrix page_ctm;\n\tpdf_obj *resources;\n\tpdf_obj *contents;\n\tfz_rect mediabox;\n\tpdf_processor *proc = NULL;\n\tfz_default_colorspaces *default_cs = NULL;\n\tfz_colorspace *colorspace = NULL;\n\n\tfz_var(proc);\n\tfz_var(colorspace);\n\tfz_var(default_cs);\n\n\tif (cookie && page->super.incomplete)\n\t\tcookie->incomplete = 1;\n\n\tfz_try(ctx)\n\t{\n\t\tdefault_cs = pdf_load_default_colorspaces(ctx, doc, page);\n\t\tif (default_cs)\n\t\t\tfz_set_default_colorspaces(ctx, dev, default_cs);\n\n\t\tpdf_page_transform(ctx, page, &mediabox, &page_ctm);\n\t\tctm = fz_concat(page_ctm, ctm);\n\t\tmediabox = fz_transform_rect(mediabox, ctm);\n\n\t\tresources = pdf_page_resources(ctx, page);\n\t\tcontents = pdf_page_contents(ctx, page);\n\n\t\tif (page->transparency)\n\t\t{\n\t\t\tpdf_obj *group = pdf_page_group(ctx, page);\n\n\t\t\tif (group)\n\t\t\t{\n\t\t\t\tpdf_obj *cs = pdf_dict_get(ctx, group, PDF_NAME(CS));\n\t\t\t\tif (cs)\n\t\t\t\t{\n\t\t\t\t\tfz_try(ctx)\n\t\t\t\t\t\tcolorspace = pdf_load_colorspace(ctx, cs);\n\t\t\t\t\tfz_catch(ctx)\n\t\t\t\t\t{\n\t\t\t\t\t\tfz_rethrow_if(ctx, FZ_ERROR_TRYLATER);\n\t\t\t\t\t\tfz_warn(ctx, \"Ignoring Page blending colorspace.\");\n\t\t\t\t\t}\n\t\t\t\t\tif (!fz_is_valid_blend_colorspace(ctx, colorspace))\n\t\t\t\t\t{\n\t\t\t\t\t\tfz_warn(ctx, \"Ignoring invalid Page blending colorspace: %s.\", colorspace->name);\n\t\t\t\t\t\tfz_drop_colorspace(ctx, colorspace);\n\t\t\t\t\t\tcolorspace = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tcolorspace = fz_keep_colorspace(ctx, fz_default_output_intent(ctx, default_cs));\n\n\t\t\tfz_begin_group(ctx, dev, mediabox, colorspace, 1, 0, 0, 1);\n\t\t}\n\n\t\tproc = pdf_new_run_processor(ctx, dev, ctm, usage, NULL, default_cs, cookie);\n\t\tpdf_process_contents(ctx, proc, doc, resources, contents, cookie);\n\t\tpdf_close_processor(ctx, proc);\n\n\t\tif (page->transparency)\n\t\t{\n\t\t\tfz_end_group(ctx, dev);\n\t\t}\n\t}\n\tfz_always(ctx)\n\t{\n\t\tpdf_drop_processor(ctx, proc);\n\t\tfz_drop_colorspace(ctx, colorspace);\n\t\tfz_drop_default_colorspaces(ctx, default_cs);\n\t}\n\tfz_catch(ctx)\n\t{\n\t\tfz_rethrow(ctx);\n\t}\n}\n\nvoid pdf_run_page_contents_with_usage(fz_context *ctx, pdf_page *page, fz_device *dev, fz_matrix ctm, const char *usage, fz_cookie *cookie)\n{\n\tpdf_document *doc = page->doc;\n\tint nocache;\n\n\tnocache = !!(dev->hints & FZ_NO_CACHE);\n\tif (nocache)\n\t\tpdf_mark_xref(ctx, doc);\n\n\tfz_try(ctx)\n\t{\n\t\tpdf_run_page_contents_with_usage_imp(ctx, doc, page, dev, ctm, usage, cookie);\n\t}\n\tfz_always(ctx)\n\t{\n\t\tif (nocache)\n\t\t\tpdf_clear_xref_to_mark(ctx, doc);\n\t}\n\tfz_catch(ctx)\n\t{\n\t\tfz_rethrow(ctx);\n\t}\n}\n\nvoid pdf_run_page_contents(fz_context *ctx, pdf_page *page, fz_device *dev, fz_matrix ctm, fz_cookie *cookie)\n{\n\tpdf_run_page_contents_with_usage(ctx, page, dev, ctm, \"View\", cookie);\n}\n\nvoid\nfz_run_page_contents(fz_context *ctx, fz_page *page, fz_device *dev, fz_matrix transform, fz_cookie *cookie)\n{\n\tif (page && page->run_page_contents)\n\t{\n\t\tfz_try(ctx)\n\t\t{\n\t\t\tpage->run_page_contents(ctx, page, dev, transform, cookie);\n\t\t}\n\t\tfz_catch(ctx)\n\t\t{\n\t\t\tdev->close_device = NULL; /* aborted run, don't warn about unclosed device */\n\t\t\tif (fz_caught(ctx) != FZ_ERROR_ABORT)\n\t\t\t\tfz_rethrow(ctx);\n\t\t}\n\t}\n}\n\nvoid\nfz_run_page(fz_context *ctx, fz_page *page, fz_device *dev, fz_matrix transform, fz_cookie *cookie)\n{\n\tfz_run_page_contents(ctx, page, dev, transform, cookie);\n\tfz_run_page_annots(ctx, page, dev, transform, cookie);\n\tfz_run_page_widgets(ctx, page, dev, transform, cookie);\n}\n\n\n\n\n\n\n\n\n// target function\nstatic void\nfz_draw_clip_image_mask(fz_context *ctx, fz_device *devp, fz_image *image, fz_matrix in_ctm, fz_rect scissor)\n{\n\tfz_draw_device *dev = (fz_draw_device*)devp;\n\tfz_matrix local_ctm = fz_concat(in_ctm, dev->transform);\n\tfz_irect bbox;\n\tfz_pixmap *scaled = NULL;\n\tfz_pixmap *pixmap = NULL;\n\tint dx, dy;\n\tfz_draw_state *state = push_stack(ctx, dev, \"clip image mask\");\n\tfz_colorspace *model = state->dest->colorspace;\n\tfz_irect clip;\n\tfz_irect src_area;\n\n\tfz_var(pixmap);\n\n\tif (dev->top == 0 && dev->resolve_spots)\n\t\tstate = push_group_for_separations(ctx, dev, fz_default_color_params /* FIXME */, dev->default_cs);\n\n\tclip = fz_pixmap_bbox(ctx, state->dest);\n\tclip = fz_intersect_irect(clip, state->scissor);\n\n\tif (image->w == 0 || image->h == 0)\n\t{\n#ifdef DUMP_GROUP_BLENDS\n\t\tdump_spaces(dev->top-1, \"Clip (image mask) (empty) begin\\n\");\n#endif\n\t\tstate[1].scissor = fz_empty_irect;\n\t\tstate[1].mask = NULL;\n\t\treturn;\n\t}\n\n\tlocal_ctm = fz_gridfit_matrix(devp->flags & FZ_DEVFLAG_GRIDFIT_AS_TILED, local_ctm);\n\n\tsrc_area = find_src_area_required(local_ctm, image, clip);\n\tif (fz_is_empty_irect(src_area))\n\t\treturn;\n\n\tbbox = fz_irect_from_rect(fz_transform_rect(fz_unit_rect, local_ctm));\n\tbbox = fz_intersect_irect(bbox, state->scissor);\n\tif (!fz_is_infinite_rect(scissor))\n\t{\n\t\tfz_rect tscissor = fz_transform_rect(scissor, dev->transform);\n\t\tbbox = fz_intersect_irect(bbox, fz_irect_from_rect(tscissor));\n\t}\n\tif (!fz_is_valid_irect(bbox))\n\t{\n#ifdef DUMP_GROUP_BLENDS\n\t\tdump_spaces(dev->top-1, \"Clip (image mask) (invalid) begin\\n\");\n#endif\n\t\tstate[1].scissor = fz_empty_irect;\n\t\tstate[1].mask = NULL;\n\t\treturn;\n\t}\n\n#ifdef DUMP_GROUP_BLENDS\n\tdump_spaces(dev->top-1, \"Clip (image mask) begin\\n\");\n#endif\n\n\tfz_try(ctx)\n\t{\n\t\tpixmap = fz_get_pixmap_from_image(ctx, image, &src_area, &local_ctm, &dx, &dy);\n\n\t\tstate[1].mask = fz_new_pixmap_with_bbox(ctx, NULL, bbox, NULL, 1);\n\t\tfz_clear_pixmap(ctx, state[1].mask);\n\n\t\tstate[1].dest = fz_new_pixmap_with_bbox(ctx, model, bbox, state[0].dest->seps, state[0].dest->alpha);\n\t\tfz_copy_pixmap_rect(ctx, state[1].dest, state[0].dest, bbox, dev->default_cs);\n\t\tif (state[0].shape)\n\t\t{\n\t\t\tstate[1].shape = fz_new_pixmap_with_bbox(ctx, NULL, bbox, NULL, 1);\n\t\t\tfz_clear_pixmap(ctx, state[1].shape);\n\t\t}\n\t\tif (state[0].group_alpha)\n\t\t{\n\t\t\tstate[1].group_alpha = fz_new_pixmap_with_bbox(ctx, NULL, bbox, NULL, 1);\n\t\t\tfz_clear_pixmap(ctx, state[1].group_alpha);\n\t\t}\n\n\t\tstate[1].blendmode |= FZ_BLEND_ISOLATED;\n\t\tstate[1].scissor = bbox;\n\n\t\tif (!(devp->hints & FZ_DONT_INTERPOLATE_IMAGES) && ctx->tuning->image_scale(ctx->tuning->image_scale_arg, dx, dy, pixmap->w, pixmap->h))\n\t\t{\n\t\t\tint gridfit = !(dev->flags & FZ_DRAWDEV_FLAGS_TYPE3);\n\t\t\tscaled = fz_transform_pixmap(ctx, dev, pixmap, &local_ctm, state->dest->x, state->dest->y, dx, dy, gridfit, &clip);\n\t\t\tif (!scaled)\n\t\t\t{\n\t\t\t\tif (dx < 1)\n\t\t\t\t\tdx = 1;\n\t\t\t\tif (dy < 1)\n\t\t\t\t\tdy = 1;\n\t\t\t\tscaled = fz_scale_pixmap_cached(ctx, pixmap, pixmap->x, pixmap->y, dx, dy, NULL, dev->cache_x, dev->cache_y);\n\t\t\t}\n\t\t\tif (scaled)\n\t\t\t{\n\t\t\t\tfz_drop_pixmap(ctx, pixmap);\n\t\t\t\tpixmap = scaled;\n\t\t\t}\n\t\t}\n\n#ifdef DUMP_GROUP_BLENDS\n\t\tdump_spaces(dev->top, \"\");\n\t\tfz_dump_blend(ctx, \"Creating imagemask: plotting \", pixmap);\n\t\tfz_dump_blend(ctx, \" onto \", state[1].mask);\n\t\tif (state[1].shape)\n\t\t\tfz_dump_blend(ctx, \"/S=\", state[1].shape);\n\t\tif (state[1].group_alpha)\n\t\t\tfz_dump_blend(ctx, \"/GA=\", state[1].group_alpha);\n#endif\n\n\t\tfz_paint_image(ctx, state[1].mask, &bbox, state[1].shape, state[1].group_alpha, pixmap, local_ctm, 255, !(devp->hints & FZ_DONT_INTERPOLATE_IMAGES), 0);\n\n#ifdef DUMP_GROUP_BLENDS\n\t\tfz_dump_blend(ctx, \" to get \", state[1].mask);\n\t\tif (state[1].shape)\n\t\t\tfz_dump_blend(ctx, \"/S=\", state[1].shape);\n\t\tif (state[1].group_alpha)\n\t\t\tfz_dump_blend(ctx, \"/GA=\", state[1].group_alpha);\n\t\tprintf(\"\\n\");\n#endif\n\t}\n\tfz_always(ctx)\n\t\tfz_drop_pixmap(ctx, pixmap);\n\tfz_catch(ctx)\n\t\tfz_rethrow(ctx);\n}\n",
    "target": 1,
    "idx": 1036519,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nvoid\n__xmlRaiseError(xmlStructuredErrorFunc schannel,\n              xmlGenericErrorFunc channel, void *data, void *ctx,\n              void *nod, int domain, int code, xmlErrorLevel level,\n              const char *file, int line, const char *str1,\n              const char *str2, const char *str3, int int1, int col,\n\t      const char *msg, ...)\n{\n    xmlParserCtxtPtr ctxt = NULL;\n    xmlNodePtr node = (xmlNodePtr) nod;\n    char *str = NULL;\n    xmlParserInputPtr input = NULL;\n    xmlErrorPtr to = &xmlLastError;\n    xmlNodePtr baseptr = NULL;\n\n    if (code == XML_ERR_OK)\n        return;\n    if ((xmlGetWarningsDefaultValue == 0) && (level == XML_ERR_WARNING))\n        return;\n    if ((domain == XML_FROM_PARSER) || (domain == XML_FROM_HTML) ||\n        (domain == XML_FROM_DTD) || (domain == XML_FROM_NAMESPACE) ||\n\t(domain == XML_FROM_IO) || (domain == XML_FROM_VALID)) {\n\tctxt = (xmlParserCtxtPtr) ctx;\n\n        if (ctxt != NULL) {\n            if (level == XML_ERR_WARNING) {\n                if (ctxt->nbWarnings >= XML_MAX_ERRORS)\n                    return;\n                ctxt->nbWarnings += 1;\n            } else {\n                if (ctxt->nbErrors >= XML_MAX_ERRORS)\n                    return;\n                ctxt->nbErrors += 1;\n            }\n\n            if ((schannel == NULL) && (ctxt->sax != NULL) &&\n                (ctxt->sax->initialized == XML_SAX2_MAGIC) &&\n                (ctxt->sax->serror != NULL)) {\n                schannel = ctxt->sax->serror;\n                data = ctxt->userData;\n            }\n        }\n    }\n    /*\n     * Check if structured error handler set\n     */\n    if (schannel == NULL) {\n\tschannel = xmlStructuredError;\n\t/*\n\t * if user has defined handler, change data ptr to user's choice\n\t */\n\tif (schannel != NULL)\n\t    data = xmlStructuredErrorContext;\n    }\n    /*\n     * Formatting the message\n     */\n    if (msg == NULL) {\n        str = (char *) xmlStrdup(BAD_CAST \"No error message provided\");\n    } else {\n        XML_GET_VAR_STR(msg, str);\n    }\n\n    /*\n     * specific processing if a parser context is provided\n     */\n    if (ctxt != NULL) {\n        if (file == NULL) {\n            input = ctxt->input;\n            if ((input != NULL) && (input->filename == NULL) &&\n                (ctxt->inputNr > 1)) {\n                input = ctxt->inputTab[ctxt->inputNr - 2];\n            }\n            if (input != NULL) {\n                file = input->filename;\n                line = input->line;\n                col = input->col;\n            }\n        }\n        to = &ctxt->lastError;\n    } else if ((node != NULL) && (file == NULL)) {\n\tint i;\n\n\tif ((node->doc != NULL) && (node->doc->URL != NULL)) {\n\t    baseptr = node;\n/*\t    file = (const char *) node->doc->URL; */\n\t}\n\tfor (i = 0;\n\t     ((i < 10) && (node != NULL) && (node->type != XML_ELEMENT_NODE));\n\t     i++)\n\t     node = node->parent;\n        if ((baseptr == NULL) && (node != NULL) &&\n\t    (node->doc != NULL) && (node->doc->URL != NULL))\n\t    baseptr = node;\n\n\tif ((node != NULL) && (node->type == XML_ELEMENT_NODE))\n\t    line = node->line;\n\tif ((line == 0) || (line == 65535))\n\t    line = xmlGetLineNo(node);\n    }\n\n    /*\n     * Save the information about the error\n     */\n    xmlResetError(to);\n    to->domain = domain;\n    to->code = code;\n    to->message = str;\n    to->level = level;\n    if (file != NULL)\n        to->file = (char *) xmlStrdup((const xmlChar *) file);\n    else if (baseptr != NULL) {\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t/*\n\t * We check if the error is within an XInclude section and,\n\t * if so, attempt to print out the href of the XInclude instead\n\t * of the usual \"base\" (doc->URL) for the node (bug 152623).\n\t */\n        xmlNodePtr prev = baseptr;\n        char *href = NULL;\n\tint inclcount = 0;\n\twhile (prev != NULL) {\n\t    if (prev->prev == NULL)\n\t        prev = prev->parent;\n\t    else {\n\t        prev = prev->prev;\n\t\tif (prev->type == XML_XINCLUDE_START) {\n\t\t    if (inclcount > 0) {\n                        --inclcount;\n                    } else {\n                        href = (char *) xmlGetProp(prev, BAD_CAST \"href\");\n                        if (href != NULL)\n\t\t            break;\n                    }\n\t\t} else if (prev->type == XML_XINCLUDE_END)\n\t\t    inclcount++;\n\t    }\n\t}\n        if (href != NULL)\n            to->file = href;\n\telse\n#endif\n\t    to->file = (char *) xmlStrdup(baseptr->doc->URL);\n\tif ((to->file == NULL) && (node != NULL) && (node->doc != NULL)) {\n\t    to->file = (char *) xmlStrdup(node->doc->URL);\n\t}\n    }\n    to->line = line;\n    if (str1 != NULL)\n        to->str1 = (char *) xmlStrdup((const xmlChar *) str1);\n    if (str2 != NULL)\n        to->str2 = (char *) xmlStrdup((const xmlChar *) str2);\n    if (str3 != NULL)\n        to->str3 = (char *) xmlStrdup((const xmlChar *) str3);\n    to->int1 = int1;\n    to->int2 = col;\n    to->node = node;\n    to->ctxt = ctx;\n\n    if (to != &xmlLastError)\n        xmlCopyError(to,&xmlLastError);\n\n    if (schannel != NULL) {\n\tschannel(data, to);\n\treturn;\n    }\n\n    /*\n     * Find the callback channel if channel param is NULL\n     */\n    if ((ctxt != NULL) && (channel == NULL) &&\n        (xmlStructuredError == NULL) && (ctxt->sax != NULL)) {\n        if (level == XML_ERR_WARNING)\n\t    channel = ctxt->sax->warning;\n        else\n\t    channel = ctxt->sax->error;\n\tdata = ctxt->userData;\n    } else if (channel == NULL) {\n\tchannel = xmlGenericError;\n\tif (ctxt != NULL) {\n\t    data = ctxt;\n\t} else {\n\t    data = xmlGenericErrorContext;\n\t}\n    }\n    if (channel == NULL)\n        return;\n\n    if ((channel == xmlParserError) ||\n        (channel == xmlParserWarning) ||\n\t(channel == xmlParserValidityError) ||\n\t(channel == xmlParserValidityWarning))\n\txmlReportError(to, ctxt, str, NULL, NULL);\n    else if (((void(*)(void)) channel == (void(*)(void)) fprintf) ||\n             (channel == xmlGenericErrorDefaultFunc))\n\txmlReportError(to, ctxt, str, channel, data);\n    else\n\tchannel(data, \"%s\", str);\n}\n\n\n\nstatic int\nhtmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n    const unsigned char *cur;\n    unsigned char c;\n    unsigned int val;\n\n    if (ctxt->instate == XML_PARSER_EOF)\n\treturn(0);\n\n    if (ctxt->token != 0) {\n\t*len = 0;\n\treturn(ctxt->token);\n    }\n\n    if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK) {\n        xmlParserGrow(ctxt);\n        if (ctxt->instate == XML_PARSER_EOF)\n            return(0);\n    }\n\n    if ((ctxt->input->flags & XML_INPUT_HAS_ENCODING) == 0) {\n        xmlChar * guess;\n        xmlCharEncodingHandlerPtr handler;\n\n        /*\n         * Assume it's a fixed length encoding (1) with\n         * a compatible encoding for the ASCII set, since\n         * HTML constructs only use < 128 chars\n         */\n        if (*ctxt->input->cur < 0x80) {\n            *len = 1;\n            if ((*ctxt->input->cur == 0) &&\n                (ctxt->input->cur < ctxt->input->end)) {\n                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n                                \"Char 0x%X out of allowed range\\n\", 0);\n                return(' ');\n            }\n            return(*ctxt->input->cur);\n        }\n\n        /*\n         * Humm this is bad, do an automatic flow conversion\n         */\n        guess = htmlFindEncoding(ctxt);\n        if (guess == NULL) {\n            xmlSwitchEncoding(ctxt, XML_CHAR_ENCODING_8859_1);\n        } else {\n            handler = xmlFindCharEncodingHandler((const char *) guess);\n            if (handler != NULL) {\n                /*\n                 * Don't use UTF-8 encoder which isn't required and\n                 * can produce invalid UTF-8.\n                 */\n                if (!xmlStrEqual(BAD_CAST handler->name, BAD_CAST \"UTF-8\"))\n                    xmlSwitchToEncoding(ctxt, handler);\n            } else {\n                htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n                             \"Unsupported encoding %s\", guess, NULL);\n            }\n            xmlFree(guess);\n        }\n        ctxt->input->flags |= XML_INPUT_HAS_ENCODING;\n    }\n\n    /*\n     * We are supposed to handle UTF8, check it's valid\n     * From rfc2044: encoding of the Unicode values on UTF-8:\n     *\n     * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n     * 0000 0000-0000 007F   0xxxxxxx\n     * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n     * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n     *\n     * Check for the 0x110000 limit too\n     */\n    cur = ctxt->input->cur;\n    c = *cur;\n    if (c & 0x80) {\n        size_t avail;\n\n        if ((c & 0x40) == 0)\n            goto encoding_error;\n\n        avail = ctxt->input->end - ctxt->input->cur;\n\n        if ((avail < 2) || ((cur[1] & 0xc0) != 0x80))\n            goto encoding_error;\n        if ((c & 0xe0) == 0xe0) {\n            if ((avail < 3) || ((cur[2] & 0xc0) != 0x80))\n                goto encoding_error;\n            if ((c & 0xf0) == 0xf0) {\n                if (((c & 0xf8) != 0xf0) ||\n                    (avail < 4) || ((cur[3] & 0xc0) != 0x80))\n                    goto encoding_error;\n                /* 4-byte code */\n                *len = 4;\n                val = (cur[0] & 0x7) << 18;\n                val |= (cur[1] & 0x3f) << 12;\n                val |= (cur[2] & 0x3f) << 6;\n                val |= cur[3] & 0x3f;\n                if (val < 0x10000)\n                    goto encoding_error;\n            } else {\n              /* 3-byte code */\n                *len = 3;\n                val = (cur[0] & 0xf) << 12;\n                val |= (cur[1] & 0x3f) << 6;\n                val |= cur[2] & 0x3f;\n                if (val < 0x800)\n                    goto encoding_error;\n            }\n        } else {\n          /* 2-byte code */\n            *len = 2;\n            val = (cur[0] & 0x1f) << 6;\n            val |= cur[1] & 0x3f;\n            if (val < 0x80)\n                goto encoding_error;\n        }\n        if (!IS_CHAR(val)) {\n            htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n                            \"Char 0x%X out of allowed range\\n\", val);\n        }\n        return(val);\n    } else {\n        if ((*ctxt->input->cur == 0) &&\n            (ctxt->input->cur < ctxt->input->end)) {\n            htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n                            \"Char 0x%X out of allowed range\\n\", 0);\n            *len = 1;\n            return(' ');\n        }\n        /* 1-byte code */\n        *len = 1;\n        return(*ctxt->input->cur);\n    }\n\nencoding_error:\n    {\n        char buffer[150];\n\n\tif (ctxt->input->end - ctxt->input->cur >= 4) {\n\t    snprintf(buffer, 149, \"Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n\",\n\t\t\t    ctxt->input->cur[0], ctxt->input->cur[1],\n\t\t\t    ctxt->input->cur[2], ctxt->input->cur[3]);\n\t} else {\n\t    snprintf(buffer, 149, \"Bytes: 0x%02X\\n\", ctxt->input->cur[0]);\n\t}\n\thtmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n\t\t     \"Input is not proper UTF-8, indicate encoding !\\n\",\n\t\t     BAD_CAST buffer, NULL);\n    }\n\n    if ((ctxt->input->flags & XML_INPUT_HAS_ENCODING) == 0)\n        xmlSwitchEncoding(ctxt, XML_CHAR_ENCODING_8859_1);\n    *len = 1;\n    return(*ctxt->input->cur);\n}\n\nstatic void\nhtmlParseCharDataInternal(htmlParserCtxtPtr ctxt, int readahead) {\n    xmlChar buf[HTML_PARSER_BIG_BUFFER_SIZE + 6];\n    int nbchar = 0;\n    int cur, l;\n\n    if (readahead)\n        buf[nbchar++] = readahead;\n\n    cur = CUR_CHAR(l);\n    while (((cur != '<') || (ctxt->token == '<')) &&\n           ((cur != '&') || (ctxt->token == '&')) &&\n\t   (cur != 0)) {\n\tif (!(IS_CHAR(cur))) {\n\t    htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n\t                \"Invalid char in CDATA 0x%X\\n\", cur);\n\t} else {\n\t    COPY_BUF(l,buf,nbchar,cur);\n\t}\n\tNEXTL(l);\n\tif (nbchar >= HTML_PARSER_BIG_BUFFER_SIZE) {\n            buf[nbchar] = 0;\n\n\t    /*\n\t     * Ok the segment is to be consumed as chars.\n\t     */\n\t    if ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {\n\t\tif (areBlanks(ctxt, buf, nbchar)) {\n\t\t    if (ctxt->keepBlanks) {\n\t\t\tif (ctxt->sax->characters != NULL)\n\t\t\t    ctxt->sax->characters(ctxt->userData, buf, nbchar);\n\t\t    } else {\n\t\t\tif (ctxt->sax->ignorableWhitespace != NULL)\n\t\t\t    ctxt->sax->ignorableWhitespace(ctxt->userData,\n\t\t\t                                   buf, nbchar);\n\t\t    }\n\t\t} else {\n\t\t    htmlCheckParagraph(ctxt);\n\t\t    if (ctxt->sax->characters != NULL)\n\t\t\tctxt->sax->characters(ctxt->userData, buf, nbchar);\n\t\t}\n\t    }\n\t    nbchar = 0;\n            SHRINK;\n\t}\n\tcur = CUR_CHAR(l);\n    }\n    if (ctxt->instate == XML_PARSER_EOF)\n        return;\n    if (nbchar != 0) {\n        buf[nbchar] = 0;\n\n\t/*\n\t * Ok the segment is to be consumed as chars.\n\t */\n\tif ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {\n\t    if (areBlanks(ctxt, buf, nbchar)) {\n\t\tif (ctxt->keepBlanks) {\n\t\t    if (ctxt->sax->characters != NULL)\n\t\t\tctxt->sax->characters(ctxt->userData, buf, nbchar);\n\t\t} else {\n\t\t    if (ctxt->sax->ignorableWhitespace != NULL)\n\t\t\tctxt->sax->ignorableWhitespace(ctxt->userData,\n\t\t\t                               buf, nbchar);\n\t\t}\n\t    } else {\n\t\thtmlCheckParagraph(ctxt);\n\t\tif (ctxt->sax->characters != NULL)\n\t\t    ctxt->sax->characters(ctxt->userData, buf, nbchar);\n\t    }\n\t}\n    }\n}\n\nstatic void\nhtmlParseCharData(htmlParserCtxtPtr ctxt) {\n    htmlParseCharDataInternal(ctxt, 0);\n}\n\nstatic void\nhtmlParseContentInternal(htmlParserCtxtPtr ctxt) {\n    xmlChar *currentNode;\n    int depth;\n    const xmlChar *name;\n\n    depth = ctxt->nameNr;\n    if (depth <= 0) {\n        currentNode = NULL;\n    } else {\n        currentNode = xmlStrdup(ctxt->name);\n        if (currentNode == NULL) {\n            htmlErrMemory(ctxt, NULL);\n            return;\n        }\n    }\n    while (1) {\n        GROW;\n\n        if (ctxt->instate == XML_PARSER_EOF)\n            break;\n\n\t/*\n\t * Our tag or one of it's parent or children is ending.\n\t */\n        if ((CUR == '<') && (NXT(1) == '/')) {\n\t    if (htmlParseEndTag(ctxt) &&\n\t\t((currentNode != NULL) || (ctxt->nameNr == 0))) {\n\t\tif (currentNode != NULL)\n\t\t    xmlFree(currentNode);\n\n\t        depth = ctxt->nameNr;\n                if (depth <= 0) {\n                    currentNode = NULL;\n                } else {\n                    currentNode = xmlStrdup(ctxt->name);\n                    if (currentNode == NULL) {\n                        htmlErrMemory(ctxt, NULL);\n                        break;\n                    }\n                }\n\t    }\n\t    continue; /* while */\n        }\n\n\telse if ((CUR == '<') &&\n\t         ((IS_ASCII_LETTER(NXT(1))) ||\n\t\t  (NXT(1) == '_') || (NXT(1) == ':'))) {\n\t    name = htmlParseHTMLName_nonInvasive(ctxt);\n\t    if (name == NULL) {\n\t        htmlParseErr(ctxt, XML_ERR_NAME_REQUIRED,\n\t\t\t \"htmlParseStartTag: invalid element name\\n\",\n\t\t\t NULL, NULL);\n\t        /* Dump the bogus tag like browsers do */\n\t        while ((CUR == 0) && (CUR != '>'))\n\t            NEXT;\n\n\t        htmlParserFinishElementParsing(ctxt);\n\t        if (currentNode != NULL)\n\t            xmlFree(currentNode);\n\n\t        currentNode = xmlStrdup(ctxt->name);\n                if (currentNode == NULL) {\n                    htmlErrMemory(ctxt, NULL);\n                    break;\n                }\n\t        depth = ctxt->nameNr;\n\t        continue;\n\t    }\n\n\t    if (ctxt->name != NULL) {\n\t        if (htmlCheckAutoClose(name, ctxt->name) == 1) {\n\t            htmlAutoClose(ctxt, name);\n\t            continue;\n\t        }\n\t    }\n\t}\n\n\t/*\n\t * Has this node been popped out during parsing of\n\t * the next element\n\t */\n        if ((ctxt->nameNr > 0) && (depth >= ctxt->nameNr) &&\n\t    (!xmlStrEqual(currentNode, ctxt->name)))\n\t     {\n\t    htmlParserFinishElementParsing(ctxt);\n\t    if (currentNode != NULL) xmlFree(currentNode);\n\n\t    currentNode = xmlStrdup(ctxt->name);\n            if (currentNode == NULL) {\n                htmlErrMemory(ctxt, NULL);\n                break;\n            }\n\t    depth = ctxt->nameNr;\n\t    continue;\n\t}\n\n\tif ((CUR != 0) && ((xmlStrEqual(currentNode, BAD_CAST\"script\")) ||\n\t    (xmlStrEqual(currentNode, BAD_CAST\"style\")))) {\n\t    /*\n\t     * Handle SCRIPT/STYLE separately\n\t     */\n\t    htmlParseScript(ctxt);\n\t}\n\n        else if ((CUR == '<') && (NXT(1) == '!')) {\n            /*\n             * Sometimes DOCTYPE arrives in the middle of the document\n             */\n            if ((UPP(2) == 'D') && (UPP(3) == 'O') &&\n                (UPP(4) == 'C') && (UPP(5) == 'T') &&\n                (UPP(6) == 'Y') && (UPP(7) == 'P') &&\n                (UPP(8) == 'E')) {\n                htmlParseErr(ctxt, XML_HTML_STRUCURE_ERROR,\n                             \"Misplaced DOCTYPE declaration\\n\",\n                             BAD_CAST \"DOCTYPE\" , NULL);\n                htmlParseDocTypeDecl(ctxt);\n            }\n            /*\n             * First case :  a comment\n             */\n            else if ((NXT(2) == '-') && (NXT(3) == '-')) {\n                htmlParseComment(ctxt);\n            }\n            else {\n                htmlSkipBogusComment(ctxt);\n            }\n        }\n\n        /*\n         * Second case : a Processing Instruction.\n         */\n        else if ((CUR == '<') && (NXT(1) == '?')) {\n            htmlParsePI(ctxt);\n        }\n\n        /*\n         * Third case :  a sub-element.\n         */\n        else if ((CUR == '<') && IS_ASCII_LETTER(NXT(1))) {\n            htmlParseElementInternal(ctxt);\n            if (currentNode != NULL) xmlFree(currentNode);\n\n            currentNode = xmlStrdup(ctxt->name);\n            if (currentNode == NULL) {\n                htmlErrMemory(ctxt, NULL);\n                break;\n            }\n            depth = ctxt->nameNr;\n        }\n        else if (CUR == '<') {\n            if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&\n                (ctxt->sax->characters != NULL))\n                ctxt->sax->characters(ctxt->userData, BAD_CAST \"<\", 1);\n            NEXT;\n        }\n\n        /*\n         * Fourth case : a reference. If if has not been resolved,\n         *    parsing returns it's Name, create the node\n         */\n        else if (CUR == '&') {\n            htmlParseReference(ctxt);\n        }\n\n        /*\n         * Fifth case : end of the resource\n         */\n        else if (CUR == 0) {\n            htmlAutoCloseOnEnd(ctxt);\n            break;\n        }\n\n        /*\n         * Last case, text. Note that References are handled directly.\n         */\n        else {\n            htmlParseCharData(ctxt);\n        }\n\n        SHRINK;\n        GROW;\n    }\n    if (currentNode != NULL) xmlFree(currentNode);\n}\n\nint\nhtmlParseDocument(htmlParserCtxtPtr ctxt) {\n    xmlDtdPtr dtd;\n\n    xmlInitParser();\n\n    if ((ctxt == NULL) || (ctxt->input == NULL)) {\n\thtmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\n\t\t     \"htmlParseDocument: context error\\n\", NULL, NULL);\n\treturn(XML_ERR_INTERNAL_ERROR);\n    }\n\n    /*\n     * SAX: beginning of the document processing.\n     */\n    if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))\n        ctxt->sax->setDocumentLocator(ctxt->userData, &xmlDefaultSAXLocator);\n\n    xmlDetectEncoding(ctxt);\n\n    /*\n     * Wipe out everything which is before the first '<'\n     */\n    SKIP_BLANKS;\n    if (CUR == 0) {\n\thtmlParseErr(ctxt, XML_ERR_DOCUMENT_EMPTY,\n\t             \"Document is empty\\n\", NULL, NULL);\n    }\n\n    if ((ctxt->sax) && (ctxt->sax->startDocument) && (!ctxt->disableSAX))\n\tctxt->sax->startDocument(ctxt->userData);\n\n\n    /*\n     * Parse possible comments and PIs before any content\n     */\n    while (((CUR == '<') && (NXT(1) == '!') &&\n            (NXT(2) == '-') && (NXT(3) == '-')) ||\n\t   ((CUR == '<') && (NXT(1) == '?'))) {\n        htmlParseComment(ctxt);\n        htmlParsePI(ctxt);\n\tSKIP_BLANKS;\n    }\n\n\n    /*\n     * Then possibly doc type declaration(s) and more Misc\n     * (doctypedecl Misc*)?\n     */\n    if ((CUR == '<') && (NXT(1) == '!') &&\n\t(UPP(2) == 'D') && (UPP(3) == 'O') &&\n\t(UPP(4) == 'C') && (UPP(5) == 'T') &&\n\t(UPP(6) == 'Y') && (UPP(7) == 'P') &&\n\t(UPP(8) == 'E')) {\n\thtmlParseDocTypeDecl(ctxt);\n    }\n    SKIP_BLANKS;\n\n    /*\n     * Parse possible comments and PIs before any content\n     */\n    while (((CUR == '<') && (NXT(1) == '!') &&\n            (NXT(2) == '-') && (NXT(3) == '-')) ||\n\t   ((CUR == '<') && (NXT(1) == '?'))) {\n        htmlParseComment(ctxt);\n        htmlParsePI(ctxt);\n\tSKIP_BLANKS;\n    }\n\n    /*\n     * Time to start parsing the tree itself\n     */\n    htmlParseContentInternal(ctxt);\n\n    /*\n     * autoclose\n     */\n    if (CUR == 0)\n\thtmlAutoCloseOnEnd(ctxt);\n\n\n    /*\n     * SAX: end of the document processing.\n     */\n    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n        ctxt->sax->endDocument(ctxt->userData);\n\n    if ((!(ctxt->options & HTML_PARSE_NODEFDTD)) && (ctxt->myDoc != NULL)) {\n\tdtd = xmlGetIntSubset(ctxt->myDoc);\n\tif (dtd == NULL)\n\t    ctxt->myDoc->intSubset =\n\t\txmlCreateIntSubset(ctxt->myDoc, BAD_CAST \"html\",\n\t\t    BAD_CAST \"-//W3C//DTD HTML 4.0 Transitional//EN\",\n\t\t    BAD_CAST \"http://www.w3.org/TR/REC-html40/loose.dtd\");\n    }\n    if (! ctxt->wellFormed) return(-1);\n    return(0);\n}\n\nstatic htmlDocPtr\nhtmlDoRead(htmlParserCtxtPtr ctxt, const char *URL, const char *encoding,\n          int options, int reuse)\n{\n    htmlDocPtr ret;\n\n    htmlCtxtUseOptions(ctxt, options);\n    ctxt->html = 1;\n    if (encoding != NULL) {\n        xmlCharEncodingHandlerPtr hdlr;\n\n\thdlr = xmlFindCharEncodingHandler(encoding);\n\tif (hdlr != NULL) {\n\t    xmlSwitchToEncoding(ctxt, hdlr);\n        }\n    }\n    if ((URL != NULL) && (ctxt->input != NULL) &&\n        (ctxt->input->filename == NULL))\n        ctxt->input->filename = (char *) xmlStrdup((const xmlChar *) URL);\n    htmlParseDocument(ctxt);\n    ret = ctxt->myDoc;\n    ctxt->myDoc = NULL;\n    if (!reuse) {\n        if ((ctxt->dictNames) &&\n\t    (ret != NULL) &&\n\t    (ret->dict == ctxt->dict))\n\t    ctxt->dict = NULL;\n\txmlFreeParserCtxt(ctxt);\n    }\n    return (ret);\n}\n\nhtmlDocPtr\nhtmlReadMemory(const char *buffer, int size, const char *URL, const char *encoding, int options)\n{\n    htmlParserCtxtPtr ctxt;\n\n    xmlInitParser();\n    ctxt = htmlCreateMemoryParserCtxt(buffer, size);\n    if (ctxt == NULL)\n        return (NULL);\n    return (htmlDoRead(ctxt, URL, encoding, options, 0));\n}\n\n\n// target function\nstatic int\nhtmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n    const unsigned char *cur;\n    unsigned char c;\n    unsigned int val;\n\n    if (ctxt->instate == XML_PARSER_EOF)\n\treturn(0);\n\n    if (ctxt->token != 0) {\n\t*len = 0;\n\treturn(ctxt->token);\n    }\n\n    if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK) {\n        xmlParserGrow(ctxt);\n        if (ctxt->instate == XML_PARSER_EOF)\n            return(0);\n    }\n\n    if ((ctxt->input->flags & XML_INPUT_HAS_ENCODING) == 0) {\n        xmlChar * guess;\n        xmlCharEncodingHandlerPtr handler;\n\n        /*\n         * Assume it's a fixed length encoding (1) with\n         * a compatible encoding for the ASCII set, since\n         * HTML constructs only use < 128 chars\n         */\n        if (*ctxt->input->cur < 0x80) {\n            *len = 1;\n            if ((*ctxt->input->cur == 0) &&\n                (ctxt->input->cur < ctxt->input->end)) {\n                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n                                \"Char 0x%X out of allowed range\\n\", 0);\n                return(' ');\n            }\n            return(*ctxt->input->cur);\n        }\n\n        /*\n         * Humm this is bad, do an automatic flow conversion\n         */\n        guess = htmlFindEncoding(ctxt);\n        if (guess == NULL) {\n            xmlSwitchEncoding(ctxt, XML_CHAR_ENCODING_8859_1);\n        } else {\n            handler = xmlFindCharEncodingHandler((const char *) guess);\n            xmlFree(guess);\n            if (handler != NULL) {\n                /*\n                 * Don't use UTF-8 encoder which isn't required and\n                 * can produce invalid UTF-8.\n                 */\n                if (!xmlStrEqual(BAD_CAST handler->name, BAD_CAST \"UTF-8\"))\n                    xmlSwitchToEncoding(ctxt, handler);\n            } else {\n                htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n                             \"Unsupported encoding %s\", guess, NULL);\n            }\n        }\n        ctxt->input->flags |= XML_INPUT_HAS_ENCODING;\n    }\n\n    /*\n     * We are supposed to handle UTF8, check it's valid\n     * From rfc2044: encoding of the Unicode values on UTF-8:\n     *\n     * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n     * 0000 0000-0000 007F   0xxxxxxx\n     * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n     * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n     *\n     * Check for the 0x110000 limit too\n     */\n    cur = ctxt->input->cur;\n    c = *cur;\n    if (c & 0x80) {\n        size_t avail;\n\n        if ((c & 0x40) == 0)\n            goto encoding_error;\n\n        avail = ctxt->input->end - ctxt->input->cur;\n\n        if ((avail < 2) || ((cur[1] & 0xc0) != 0x80))\n            goto encoding_error;\n        if ((c & 0xe0) == 0xe0) {\n            if ((avail < 3) || ((cur[2] & 0xc0) != 0x80))\n                goto encoding_error;\n            if ((c & 0xf0) == 0xf0) {\n                if (((c & 0xf8) != 0xf0) ||\n                    (avail < 4) || ((cur[3] & 0xc0) != 0x80))\n                    goto encoding_error;\n                /* 4-byte code */\n                *len = 4;\n                val = (cur[0] & 0x7) << 18;\n                val |= (cur[1] & 0x3f) << 12;\n                val |= (cur[2] & 0x3f) << 6;\n                val |= cur[3] & 0x3f;\n                if (val < 0x10000)\n                    goto encoding_error;\n            } else {\n              /* 3-byte code */\n                *len = 3;\n                val = (cur[0] & 0xf) << 12;\n                val |= (cur[1] & 0x3f) << 6;\n                val |= cur[2] & 0x3f;\n                if (val < 0x800)\n                    goto encoding_error;\n            }\n        } else {\n          /* 2-byte code */\n            *len = 2;\n            val = (cur[0] & 0x1f) << 6;\n            val |= cur[1] & 0x3f;\n            if (val < 0x80)\n                goto encoding_error;\n        }\n        if (!IS_CHAR(val)) {\n            htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n                            \"Char 0x%X out of allowed range\\n\", val);\n        }\n        return(val);\n    } else {\n        if ((*ctxt->input->cur == 0) &&\n            (ctxt->input->cur < ctxt->input->end)) {\n            htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n                            \"Char 0x%X out of allowed range\\n\", 0);\n            *len = 1;\n            return(' ');\n        }\n        /* 1-byte code */\n        *len = 1;\n        return(*ctxt->input->cur);\n    }\n\nencoding_error:\n    {\n        char buffer[150];\n\n\tif (ctxt->input->end - ctxt->input->cur >= 4) {\n\t    snprintf(buffer, 149, \"Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n\",\n\t\t\t    ctxt->input->cur[0], ctxt->input->cur[1],\n\t\t\t    ctxt->input->cur[2], ctxt->input->cur[3]);\n\t} else {\n\t    snprintf(buffer, 149, \"Bytes: 0x%02X\\n\", ctxt->input->cur[0]);\n\t}\n\thtmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n\t\t     \"Input is not proper UTF-8, indicate encoding !\\n\",\n\t\t     BAD_CAST buffer, NULL);\n    }\n\n    if ((ctxt->input->flags & XML_INPUT_HAS_ENCODING) == 0)\n        xmlSwitchEncoding(ctxt, XML_CHAR_ENCODING_8859_1);\n    *len = 1;\n    return(*ctxt->input->cur);\n}\n",
    "target": 1,
    "idx": 1061337,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "// context\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  LocaleCompare() performs a case-insensitive comparison of two strings\n%  byte-by-byte, according to the ordering of the current locale encoding.\n%  LocaleCompare returns an integer greater than, equal to, or less than 0,\n%  if the string pointed to by p is greater than, equal to, or less than the\n%  string pointed to by q respectively.  The sign of a non-zero return value\n%  is determined by the sign of the difference between the values of the first\n%  pair of bytes that differ in the strings being compared.\n%\n%  The format of the LocaleCompare method is:\n%\n%      int LocaleCompare(const char *p,const char *q)\n%\n%  A description of each parameter follows:\n%\n%    o p: A pointer to a character string.\n%\n%    o q: A pointer to a character string to compare to p.\n%\n\n%\n%  A description of each parameter follows:\n%\n%    o target: the target string.\n%\n%    o source: the source string.\n%\n*/\nMagickExport int CompareSplayTreeString(const void *target,const void *source)\n{\n\n      (*grandparent)->right=p->left;\n      p->left=(*grandparent);\n      p->right=n->left;\n      n->left=p;\n      *grandparent=n;\n      return(n);\n    }\n  if (n == (*parent)->left)\n    {\n      (*parent)->left=n->right;\n      n->right=(*parent);\n      (*grandparent)->right=n->left;\n      n->left=(*grandparent);\n      *grandparent=n;\n      return(n);\n    }\n  (*parent)->right=n->left;\n  n->left=(*parent);\n  (*grandparent)->left=n->right;\n  n->right=(*grandparent);\n  *grandparent=n;\n  return(n);\n}\n\nstatic void SplaySplayTree(SplayTreeInfo *splay_tree,const void *key)\n{\n  if (splay_tree->root == (NodeInfo *) NULL)\n    return;\n  if (splay_tree->key != (void *) NULL)\n\n\n\n\n\n        }\n      break;\n    }\n  }\n  *pixels++=(unsigned char) length;\n  return(pixels);\n}\n\nstatic MagickBooleanType WriteMIFFImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n  bz_stream\n    bzip_info;\n#endif\n\n  char\n    buffer[MagickPathExtent];\n\n  CompressionType\n    compression;\n\n  const char\n    *property,\n    *value;\n\n#if defined(MAGICKCORE_LZMA_DELEGATE)\n  lzma_allocator\n    allocator;\n\n  lzma_stream\n    initialize_lzma = LZMA_STREAM_INIT,\n    lzma_info;\n#endif\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  PixelInfo\n    pixel,\n    target;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  ssize_t\n    i;\n\n  size_t\n    imageListLength,\n    length,\n    packet_size;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *compress_pixels,\n    *pixels,\n    *q;\n\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n  z_stream\n    zip_info;\n#endif\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  scene=0;\n  imageListLength=GetImageListLength(image);\n  do\n  {\n    /*\n      Allocate image pixels.\n    */\n    if ((image->storage_class == PseudoClass) &&\n        (image->colors > (size_t) (GetQuantumRange(image->depth)+1)))\n      (void) SetImageStorageClass(image,DirectClass,exception);\n    image->depth=image->depth <= 8 ? 8UL : image->depth <= 16 ? 16UL : 32UL;\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if ((image->storage_class != PseudoClass) && (image->depth >= 16) &&\n        (quantum_info->format == UndefinedQuantumFormat) &&\n        (IsHighDynamicRangeImage(image,exception) != MagickFalse))\n      {\n        status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\n        if (status == MagickFalse)\n          {\n            quantum_info=DestroyQuantumInfo(quantum_info);\n            ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n      }\n    else\n      if (image->depth < 16)\n        (void) DeleteImageProperty(image,\"quantum:format\");\n    compression=UndefinedCompression;\n    if (image_info->compression != UndefinedCompression)\n      compression=image_info->compression;\n    switch (compression)\n    {\n#if !defined(MAGICKCORE_LZMA_DELEGATE)\n      case LZMACompression: compression=NoCompression; break;\n#endif\n#if !defined(MAGICKCORE_ZLIB_DELEGATE)\n      case LZWCompression:\n      case ZipCompression: compression=NoCompression; break;\n#endif\n#if !defined(MAGICKCORE_BZLIB_DELEGATE)\n      case BZipCompression: compression=NoCompression; break;\n#endif\n      case RLECompression:\n      {\n        if (quantum_info->format == FloatingPointQuantumFormat)\n          compression=NoCompression;\n        GetPixelInfo(image,&target);\n        break;\n      }\n      default:\n        break;\n    }\n    packet_size=(size_t) (quantum_info->depth/8);\n    if (image->storage_class == DirectClass)\n      packet_size=(size_t) (3*quantum_info->depth/8);\n    if (IsGrayColorspace(image->colorspace) != MagickFalse)\n      packet_size=(size_t) (quantum_info->depth/8);\n    if (image->alpha_trait != UndefinedPixelTrait)\n      packet_size+=quantum_info->depth/8;\n    if (image->colorspace == CMYKColorspace)\n      packet_size+=quantum_info->depth/8;\n    if (compression == RLECompression)\n      packet_size++;\n    length=MagickMax(BZipMaxExtent(packet_size*image->columns),ZipMaxExtent(\n      packet_size*image->columns));\n    if ((compression == BZipCompression) || (compression == ZipCompression))\n      if (length != (size_t) ((unsigned int) length))\n        compression=NoCompression;\n    compress_pixels=(unsigned char *) AcquireQuantumMemory(length,\n      sizeof(*compress_pixels));\n    if (compress_pixels == (unsigned char *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    /*\n      Write MIFF header.\n    */\n    (void) WriteBlobString(image,\"id=ImageMagick  version=1.0\\n\");\n    (void) FormatLocaleString(buffer,MagickPathExtent,\n      \"class=%s  colors=%.20g  alpha-trait=%s\\n\",CommandOptionToMnemonic(\n      MagickClassOptions,image->storage_class),(double) image->colors,\n      CommandOptionToMnemonic(MagickPixelTraitOptions,(ssize_t)\n      image->alpha_trait));\n    (void) WriteBlobString(image,buffer);\n    if (image->alpha_trait != UndefinedPixelTrait)\n      (void) WriteBlobString(image,\"matte=True\\n\");\n    (void) FormatLocaleString(buffer,MagickPathExtent,\n      \"columns=%.20g  rows=%.20g  depth=%.20g\\n\",(double) image->columns,\n      (double) image->rows,(double) image->depth);\n    (void) WriteBlobString(image,buffer);\n    if (image->type != UndefinedType)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"type=%s\\n\",\n          CommandOptionToMnemonic(MagickTypeOptions,image->type));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->colorspace != UndefinedColorspace)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"colorspace=%s\\n\",\n          CommandOptionToMnemonic(MagickColorspaceOptions,image->colorspace));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->intensity != UndefinedPixelIntensityMethod)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"pixel-intensity=%s\\n\",CommandOptionToMnemonic(\n          MagickPixelIntensityOptions,image->intensity));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->endian != UndefinedEndian)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"endian=%s\\n\",\n          CommandOptionToMnemonic(MagickEndianOptions,image->endian));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (compression != UndefinedCompression)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"compression=%s  \"\n          \"quality=%.20g\\n\",CommandOptionToMnemonic(MagickCompressOptions,\n          compression),(double) image->quality);\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->units != UndefinedResolution)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"units=%s\\n\",\n          CommandOptionToMnemonic(MagickResolutionOptions,image->units));\n        (void) WriteBlobString(image,buffer);\n      }\n    if ((image->resolution.x != 0) || (image->resolution.y != 0))\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"resolution=%gx%g\\n\",image->resolution.x,image->resolution.y);\n        (void) WriteBlobString(image,buffer);\n      }\n    if ((image->page.width != 0) || (image->page.height != 0))\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"page=%.20gx%.20g%+.20g%+.20g\\n\",(double) image->page.width,(double)\n          image->page.height,(double) image->page.x,(double) image->page.y);\n        (void) WriteBlobString(image,buffer);\n      }\n    else\n      if ((image->page.x != 0) || (image->page.y != 0))\n        {\n          (void) FormatLocaleString(buffer,MagickPathExtent,\"page=%+ld%+ld\\n\",\n            (long) image->page.x,(long) image->page.y);\n          (void) WriteBlobString(image,buffer);\n        }\n    if ((image->tile_offset.x != 0) || (image->tile_offset.y != 0))\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"tile-offset=%+ld%+ld\\n\",(long) image->tile_offset.x,(long)\n          image->tile_offset.y);\n        (void) WriteBlobString(image,buffer);\n      }\n    if ((GetNextImageInList(image) != (Image *) NULL) ||\n        (GetPreviousImageInList(image) != (Image *) NULL))\n      {\n        if (image->scene == 0)\n          (void) FormatLocaleString(buffer,MagickPathExtent,\"iterations=%.20g  \"\n            \"delay=%.20g  ticks-per-second=%.20g\\n\",(double) image->iterations,\n            (double) image->delay,(double) image->ticks_per_second);\n        else\n          (void) FormatLocaleString(buffer,MagickPathExtent,\"scene=%.20g  \"\n            \"iterations=%.20g  delay=%.20g  ticks-per-second=%.20g\\n\",(double)\n            image->scene,(double) image->iterations,(double) image->delay,\n            (double) image->ticks_per_second);\n        (void) WriteBlobString(image,buffer);\n      }\n    else\n      {\n        if (image->scene != 0)\n          {\n            (void) FormatLocaleString(buffer,MagickPathExtent,\"scene=%.20g\\n\",\n              (double) image->scene);\n            (void) WriteBlobString(image,buffer);\n          }\n        if (image->iterations != 0)\n          {\n            (void) FormatLocaleString(buffer,MagickPathExtent,\n              \"iterations=%.20g\\n\",(double) image->iterations);\n            (void) WriteBlobString(image,buffer);\n          }\n        if (image->delay != 0)\n          {\n            (void) FormatLocaleString(buffer,MagickPathExtent,\"delay=%.20g\\n\",\n              (double) image->delay);\n            (void) WriteBlobString(image,buffer);\n          }\n        if (image->ticks_per_second != UndefinedTicksPerSecond)\n          {\n            (void) FormatLocaleString(buffer,MagickPathExtent,\n              \"ticks-per-second=%.20g\\n\",(double) image->ticks_per_second);\n            (void) WriteBlobString(image,buffer);\n          }\n      }\n    if (image->gravity != UndefinedGravity)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"gravity=%s\\n\",\n          CommandOptionToMnemonic(MagickGravityOptions,image->gravity));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->dispose != UndefinedDispose)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"dispose=%s\\n\",\n          CommandOptionToMnemonic(MagickDisposeOptions,image->dispose));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->rendering_intent != UndefinedIntent)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"rendering-intent=%s\\n\",CommandOptionToMnemonic(MagickIntentOptions,\n          image->rendering_intent));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->gamma != 0.0)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"gamma=%g\\n\",\n          image->gamma);\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->chromaticity.white_point.x != 0.0)\n      {\n        /*\n          Note chomaticity points.\n        */\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"red-primary=%g,\"\n          \"%g  green-primary=%g,%g  blue-primary=%g,%g\\n\",\n          image->chromaticity.red_primary.x,image->chromaticity.red_primary.y,\n          image->chromaticity.green_primary.x,\n          image->chromaticity.green_primary.y,\n          image->chromaticity.blue_primary.x,\n          image->chromaticity.blue_primary.y);\n        (void) WriteBlobString(image,buffer);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"white-point=%g,%g\\n\",image->chromaticity.white_point.x,\n          image->chromaticity.white_point.y);\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->orientation != UndefinedOrientation)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"orientation=%s\\n\",\n          CommandOptionToMnemonic(MagickOrientationOptions,image->orientation));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->profiles != (void *) NULL)\n      {\n        const char\n          *name;\n\n        const StringInfo\n          *profile;\n\n        /*\n          Write image profile names.\n        */\n        ResetImageProfileIterator(image);\n        for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n        {\n          profile=GetImageProfile(image,name);\n          if (profile != (StringInfo *) NULL)\n            {\n              (void) FormatLocaleString(buffer,MagickPathExtent,\"profile=%s\\n\",\n                name);\n              (void) WriteBlobString(image,buffer);\n            }\n          name=GetNextImageProfile(image);\n        }\n      }\n    if (image->montage != (char *) NULL)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"montage=%s\\n\",\n          image->montage);\n        (void) WriteBlobString(image,buffer);\n      }\n    if (quantum_info->format == FloatingPointQuantumFormat)\n      (void) SetImageProperty(image,\"quantum:format\",\"floating-point\",\n        exception);\n    ResetImagePropertyIterator(image);\n    property=GetNextImageProperty(image);\n    while (property != (const char *) NULL)\n    {\n      (void) FormatLocaleString(buffer,MagickPathExtent,\"%s=\",property);\n      (void) WriteBlobString(image,buffer);\n      value=GetImageProperty(image,property,exception);\n      if (value != (const char *) NULL)\n        {\n          length=strlen(value);\n          for (i=0; i < (ssize_t) length; i++)\n            if ((isspace((int) ((unsigned char) value[i])) != 0) ||\n                (value[i] == '}'))\n              break;\n          if ((i == (ssize_t) length) && (i != 0))\n            (void) WriteBlob(image,length,(const unsigned char *) value);\n          else\n            {\n              (void) WriteBlobByte(image,'{');\n              if (strchr(value,'}') == (char *) NULL)\n                (void) WriteBlob(image,length,(const unsigned char *) value);\n              else\n                for (i=0; i < (ssize_t) length; i++)\n                {\n                  if (value[i] == (int) '}')\n                    (void) WriteBlobByte(image,'\\\\');\n                  (void) WriteBlobByte(image,(unsigned char) value[i]);\n                }\n              (void) WriteBlobByte(image,'}');\n            }\n        }\n      (void) WriteBlobByte(image,'\\n');\n      property=GetNextImageProperty(image);\n    }\n    (void) WriteBlobString(image,\"\\f\\n:\\032\");\n    if (image->montage != (char *) NULL)\n      {\n        /*\n          Write montage tile directory.\n        */\n        if (image->directory != (char *) NULL)\n          (void) WriteBlob(image,strlen(image->directory),(unsigned char *)\n            image->directory);\n        (void) WriteBlobByte(image,'\\0');\n      }\n    if (image->profiles != 0)\n      {\n        const char\n          *name;\n\n        const StringInfo\n          *profile;\n\n        /*\n          Write image profile blob.\n        */\n        ResetImageProfileIterator(image);\n        name=GetNextImageProfile(image);\n        while (name != (const char *) NULL)\n        {\n          profile=GetImageProfile(image,name);\n          (void) WriteBlobMSBLong(image,(unsigned int)\n            GetStringInfoLength(profile));\n          (void) WriteBlob(image,GetStringInfoLength(profile),\n            GetStringInfoDatum(profile));\n          name=GetNextImageProfile(image);\n        }\n      }\n    if (image->storage_class == PseudoClass)\n      {\n        size_t\n          colormap_size;\n\n        unsigned char\n          *colormap;\n\n        /*\n          Allocate colormap.\n        */\n        colormap_size=(size_t) (3*quantum_info->depth/8);\n        colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\n          colormap_size*sizeof(*colormap));\n        if (colormap == (unsigned char *) NULL)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        /*\n          Write colormap to file.\n        */\n        q=colormap;\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          switch (quantum_info->depth)\n          {\n            case 32:\n            default:\n            {\n              unsigned int\n                long_pixel;\n\n              long_pixel=ScaleQuantumToLong((Quantum)\n                image->colormap[i].red);\n              q=PopLongPixel(MSBEndian,long_pixel,q);\n              long_pixel=ScaleQuantumToLong((Quantum)\n                image->colormap[i].green);\n              q=PopLongPixel(MSBEndian,long_pixel,q);\n              long_pixel=ScaleQuantumToLong((Quantum)\n                image->colormap[i].blue);\n              q=PopLongPixel(MSBEndian,long_pixel,q);\n              break;\n            }\n            case 16:\n            {\n              unsigned short\n                short_pixel;\n\n              short_pixel=ScaleQuantumToShort((Quantum)\n                image->colormap[i].red);\n              q=PopShortPixel(MSBEndian,short_pixel,q);\n              short_pixel=ScaleQuantumToShort((Quantum)\n                image->colormap[i].green);\n              q=PopShortPixel(MSBEndian,short_pixel,q);\n              short_pixel=ScaleQuantumToShort((Quantum)\n                image->colormap[i].blue);\n              q=PopShortPixel(MSBEndian,short_pixel,q);\n              break;\n            }\n            case 8:\n            {\n              unsigned char\n                char_pixel;\n\n              char_pixel=(unsigned char) ScaleQuantumToChar((Quantum)\n                image->colormap[i].red);\n              q=PopCharPixel(char_pixel,q);\n              char_pixel=(unsigned char) ScaleQuantumToChar((Quantum)\n                image->colormap[i].green);\n              q=PopCharPixel(char_pixel,q);\n              char_pixel=(unsigned char) ScaleQuantumToChar((Quantum)\n                image->colormap[i].blue);\n              q=PopCharPixel(char_pixel,q);\n              break;\n            }\n          }\n        }\n        (void) WriteBlob(image,colormap_size*image->colors,colormap);\n        colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n      }\n    /*\n      Write image pixels to file.\n    */\n    status=MagickTrue;\n    switch (compression)\n    {\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n      case BZipCompression:\n      {\n        int\n          code;\n\n        (void) memset(&bzip_info,0,sizeof(bzip_info));\n        bzip_info.bzalloc=AcquireBZIPMemory;\n        bzip_info.bzfree=RelinquishBZIPMemory;\n        bzip_info.opaque=(void *) NULL;\n        code=BZ2_bzCompressInit(&bzip_info,(int) (image->quality ==\n          UndefinedCompressionQuality ? 7 : MagickMin(image->quality/10,9)),\n          (int) image_info->verbose,0);\n        if (code != BZ_OK)\n          status=MagickFalse;\n        break;\n      }\n#endif\n#if defined(MAGICKCORE_LZMA_DELEGATE)\n      case LZMACompression:\n      {\n        int\n          code;\n\n        allocator.alloc=AcquireLZMAMemory;\n        allocator.free=RelinquishLZMAMemory;\n        allocator.opaque=(void *) NULL;\n        lzma_info=initialize_lzma;\n        lzma_info.allocator=&allocator;\n        code=lzma_easy_encoder(&lzma_info,(uint32_t) (image->quality/10),\n          LZMA_CHECK_SHA256);\n        if (code != LZMA_OK)\n          status=MagickTrue;\n        break;\n      }\n#endif\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n      case LZWCompression:\n      case ZipCompression:\n      {\n        int\n          code;\n\n        zip_info.zalloc=AcquireZIPMemory;\n        zip_info.zfree=RelinquishZIPMemory;\n        zip_info.opaque=(void *) NULL;\n        code=deflateInit(&zip_info,(int) (image->quality ==\n          UndefinedCompressionQuality ? 7 : MagickMin(image->quality/10,9)));\n        if (code != Z_OK)\n          status=MagickFalse;\n        break;\n      }\n#endif\n      default:\n        break;\n    }\n    quantum_type=GetQuantumType(image,exception);\n    pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      const Quantum\n        *magick_restrict p;\n\n      ssize_t\n        x;\n\n      if (status == MagickFalse)\n        break;\n      p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n      if (p == (const Quantum *) NULL)\n        break;\n      q=pixels;\n      switch (compression)\n      {\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n        case BZipCompression:\n        {\n          bzip_info.next_in=(char *) pixels;\n          bzip_info.avail_in=(unsigned int) (packet_size*image->columns);\n          (void) ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            quantum_type,pixels,exception);\n          do\n          {\n            int\n              code;\n\n            bzip_info.next_out=(char *) compress_pixels;\n            bzip_info.avail_out=(unsigned int) BZipMaxExtent(packet_size*\n              image->columns);\n            code=BZ2_bzCompress(&bzip_info,BZ_FLUSH);\n            if (code < 0)\n              status=MagickFalse;\n            length=(size_t) (bzip_info.next_out-(char *) compress_pixels);\n            if (length != 0)\n              {\n                (void) WriteBlobMSBLong(image,(unsigned int) length);\n                (void) WriteBlob(image,length,compress_pixels);\n              }\n          } while (bzip_info.avail_in != 0);\n          break;\n        }\n#endif\n#if defined(MAGICKCORE_LZMA_DELEGATE)\n        case LZMACompression:\n        {\n          lzma_info.next_in=pixels;\n          lzma_info.avail_in=packet_size*image->columns;\n          (void) ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            quantum_type,pixels,exception);\n          do\n          {\n            int\n              code;\n\n            lzma_info.next_out=compress_pixels;\n            lzma_info.avail_out=LZMAMaxExtent(packet_size*image->columns);\n            code=lzma_code(&lzma_info,LZMA_RUN);\n            if (code != LZMA_OK)\n              status=MagickFalse;\n            length=(size_t) (lzma_info.next_out-compress_pixels);\n            if (length != 0)\n              {\n                (void) WriteBlobMSBLong(image,(unsigned int) length);\n                (void) WriteBlob(image,length,compress_pixels);\n              }\n          } while (lzma_info.avail_in != 0);\n          break;\n        }\n#endif\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n        case LZWCompression:\n        case ZipCompression:\n        {\n          zip_info.next_in=pixels;\n          zip_info.avail_in=(uInt) (packet_size*image->columns);\n          (void) ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            quantum_type,pixels,exception);\n          do\n          {\n            int\n              code;\n\n            zip_info.next_out=compress_pixels;\n            zip_info.avail_out=(uInt) ZipMaxExtent(packet_size*image->columns);\n            code=deflate(&zip_info,Z_SYNC_FLUSH);\n            if (code != Z_OK)\n              status=MagickFalse;\n            length=(size_t) (zip_info.next_out-compress_pixels);\n            if (length != 0)\n              {\n                (void) WriteBlobMSBLong(image,(unsigned int) length);\n                (void) WriteBlob(image,length,compress_pixels);\n              }\n          } while (zip_info.avail_in != 0);\n          break;\n        }\n#endif\n        case RLECompression:\n        {\n          length=0;\n          GetPixelInfoPixel(image,p,&pixel);\n          p+=GetPixelChannels(image);\n          for (x=1; x < (ssize_t) image->columns; x++)\n          {\n            GetPixelInfoPixel(image,p,&target);\n            if ((length < 255) &&\n                (IsPixelInfoEquivalent(&pixel,&target) != MagickFalse))\n              length++;\n            else\n              {\n                q=PopRunlengthPacket(image,q,length,&pixel);\n                length=0;\n              }\n            GetPixelInfoPixel(image,p,&pixel);\n            p+=GetPixelChannels(image);\n          }\n          q=PopRunlengthPacket(image,q,length,&pixel);\n          (void) WriteBlob(image,(size_t) (q-pixels),pixels);\n          break;\n        }\n        default:\n        {\n          (void) ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            quantum_type,pixels,exception);\n          (void) WriteBlob(image,packet_size*image->columns,pixels);\n          break;\n        }\n      }\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    switch (compression)\n    {\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n      case BZipCompression:\n      {\n        int\n          code;\n\n        for ( ; ; )\n        {\n          if (status == MagickFalse)\n            break;\n          bzip_info.next_out=(char *) compress_pixels;\n          bzip_info.avail_out=(unsigned int) BZipMaxExtent(packet_size*\n            image->columns);\n          code=BZ2_bzCompress(&bzip_info,BZ_FINISH);\n          length=(size_t) (bzip_info.next_out-(char *) compress_pixels);\n          if (length != 0)\n            {\n              (void) WriteBlobMSBLong(image,(unsigned int) length);\n              (void) WriteBlob(image,length,compress_pixels);\n            }\n          if (code == BZ_STREAM_END)\n            break;\n        }\n        code=BZ2_bzCompressEnd(&bzip_info);\n        if (code != BZ_OK)\n          status=MagickFalse;\n        break;\n      }\n#endif\n#if defined(MAGICKCORE_LZMA_DELEGATE)\n      case LZMACompression:\n      {\n        int\n          code;\n\n        for ( ; ; )\n        {\n          if (status == MagickFalse)\n            break;\n          lzma_info.next_out=compress_pixels;\n          lzma_info.avail_out=packet_size*image->columns;\n          code=lzma_code(&lzma_info,LZMA_FINISH);\n          length=(size_t) (lzma_info.next_out-compress_pixels);\n          if (length > 6)\n            {\n              (void) WriteBlobMSBLong(image,(unsigned int) length);\n              (void) WriteBlob(image,length,compress_pixels);\n            }\n          if (code == LZMA_STREAM_END)\n            break;\n        }\n        lzma_end(&lzma_info);\n        break;\n      }\n#endif\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n      case LZWCompression:\n      case ZipCompression:\n      {\n        int\n          code;\n\n        for ( ; ; )\n        {\n          if (status == MagickFalse)\n            break;\n          zip_info.next_out=compress_pixels;\n          zip_info.avail_out=(uInt) ZipMaxExtent(packet_size*image->columns);\n          code=deflate(&zip_info,Z_FINISH);\n          length=(size_t) (zip_info.next_out-compress_pixels);\n          if (length > 6)\n            {\n              (void) WriteBlobMSBLong(image,(unsigned int) length);\n              (void) WriteBlob(image,length,compress_pixels);\n            }\n          if (code == Z_STREAM_END)\n            break;\n        }\n        code=deflateEnd(&zip_info);\n        if (code != Z_OK)\n          status=MagickFalse;\n        break;\n      }\n#endif\n      default:\n        break;\n    }\n    quantum_info=DestroyQuantumInfo(quantum_info);\n    compress_pixels=(unsigned char *) RelinquishMagickMemory(compress_pixels);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType WriteImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent];\n\n  const char\n    *option;\n\n  const DelegateInfo\n    *delegate_info;\n\n  const MagickInfo\n    *magick_info;\n\n  EncodeImageHandler\n    *encoder;\n\n  ExceptionInfo\n    *sans_exception;\n\n  ImageInfo\n    *write_info;\n\n  MagickBooleanType\n    status,\n    temporary;\n\n  /*\n    Determine image type from filename prefix or suffix (e.g. image.jpg).\n  */\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(image->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  sans_exception=AcquireExceptionInfo();\n  write_info=CloneImageInfo(image_info);\n  (void) CopyMagickString(write_info->filename,image->filename,\n    MagickPathExtent);\n  (void) SetImageInfo(write_info,1,sans_exception);\n  if (*write_info->magick == '\\0')\n    (void) CopyMagickString(write_info->magick,image->magick,MagickPathExtent);\n  (void) CopyMagickString(filename,image->filename,MagickPathExtent);\n  (void) CopyMagickString(image->filename,write_info->filename,\n    MagickPathExtent);\n  /*\n    Call appropriate image writer based on image type.\n  */\n  magick_info=GetMagickInfo(write_info->magick,sans_exception);\n  if (sans_exception->severity == PolicyError)\n    magick_info=GetMagickInfo(write_info->magick,exception);\n  sans_exception=DestroyExceptionInfo(sans_exception);\n  if (magick_info != (const MagickInfo *) NULL)\n    {\n      if (GetMagickEndianSupport(magick_info) == MagickFalse)\n        image->endian=UndefinedEndian;\n      else\n        if ((image_info->endian == UndefinedEndian) &&\n            (GetMagickRawSupport(magick_info) != MagickFalse))\n          {\n            unsigned long\n              lsb_first;\n\n            lsb_first=1;\n            image->endian=(*(char *) &lsb_first) == 1 ? LSBEndian : MSBEndian;\n         }\n    }\n  (void) SyncImageProfiles(image);\n  DisassociateImageStream(image);\n  option=GetImageOption(image_info,\"delegate:bimodal\");\n  if ((IsStringTrue(option) != MagickFalse) &&\n      (write_info->page == (char *) NULL) &&\n      (GetPreviousImageInList(image) == (Image *) NULL) &&\n      (GetNextImageInList(image) == (Image *) NULL) &&\n      (IsTaintImage(image) == MagickFalse) )\n    {\n      delegate_info=GetDelegateInfo(image->magick,write_info->magick,exception);\n      if ((delegate_info != (const DelegateInfo *) NULL) &&\n          (GetDelegateMode(delegate_info) == 0) &&\n          (IsPathAccessible(image->magick_filename) != MagickFalse))\n        {\n          /*\n            Process image with bi-modal delegate.\n          */\n          (void) CopyMagickString(image->filename,image->magick_filename,\n            MagickPathExtent);\n          status=InvokeDelegate(write_info,image,image->magick,\n            write_info->magick,exception);\n          write_info=DestroyImageInfo(write_info);\n          (void) CopyMagickString(image->filename,filename,MagickPathExtent);\n          return(status);\n        }\n    }\n  status=MagickFalse;\n  temporary=MagickFalse;\n  if ((magick_info != (const MagickInfo *) NULL) &&\n      (GetMagickEncoderSeekableStream(magick_info) != MagickFalse))\n    {\n      char\n        image_filename[MagickPathExtent];\n\n      (void) CopyMagickString(image_filename,image->filename,MagickPathExtent);\n      status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n      (void) CopyMagickString(image->filename, image_filename,MagickPathExtent);\n      if (status != MagickFalse)\n        {\n          if (IsBlobSeekable(image) == MagickFalse)\n            {\n              /*\n                A seekable stream is required by the encoder.\n              */\n              write_info->adjoin=MagickTrue;\n              (void) CopyMagickString(write_info->filename,image->filename,\n                MagickPathExtent);\n              (void) AcquireUniqueFilename(image->filename);\n              temporary=MagickTrue;\n            }\n          (void) CloseBlob(image);\n        }\n    }\n  encoder=GetImageEncoder(magick_info);\n  if (encoder != (EncodeImageHandler *) NULL)\n    {\n      /*\n        Call appropriate image writer based on image type.\n      */\n      if (GetMagickEncoderThreadSupport(magick_info) == MagickFalse)\n        LockSemaphoreInfo(magick_info->semaphore);\n      status=IsCoderAuthorized(write_info->magick,WritePolicyRights,exception);\n      if (status != MagickFalse)\n        status=encoder(write_info,image,exception);\n      if (GetMagickEncoderThreadSupport(magick_info) == MagickFalse)\n        UnlockSemaphoreInfo(magick_info->semaphore);\n    }\n  else\n    {\n      delegate_info=GetDelegateInfo((char *) NULL,write_info->magick,exception);\n      if (delegate_info != (DelegateInfo *) NULL)\n        {\n          /*\n            Process the image with delegate.\n          */\n          *write_info->filename='\\0';\n          if (GetDelegateThreadSupport(delegate_info) == MagickFalse)\n            LockSemaphoreInfo(delegate_info->semaphore);\n          status=InvokeDelegate(write_info,image,(char *) NULL,\n            write_info->magick,exception);\n          if (GetDelegateThreadSupport(delegate_info) == MagickFalse)\n            UnlockSemaphoreInfo(delegate_info->semaphore);\n          (void) CopyMagickString(image->filename,filename,MagickPathExtent);\n        }\n      else\n        {\n          sans_exception=AcquireExceptionInfo();\n          magick_info=GetMagickInfo(write_info->magick,sans_exception);\n          if (sans_exception->severity == PolicyError)\n            magick_info=GetMagickInfo(write_info->magick,exception);\n          sans_exception=DestroyExceptionInfo(sans_exception);\n          if ((write_info->affirm == MagickFalse) &&\n              (magick_info == (const MagickInfo *) NULL))\n            {\n              (void) CopyMagickString(write_info->magick,image->magick,\n                MagickPathExtent);\n              magick_info=GetMagickInfo(write_info->magick,exception);\n            }\n          encoder=GetImageEncoder(magick_info);\n          if (encoder == (EncodeImageHandler *) NULL)\n            {\n              char\n                extension[MagickPathExtent];\n\n              GetPathComponent(image->filename,ExtensionPath,extension);\n              if (*extension != '\\0')\n                magick_info=GetMagickInfo(extension,exception);\n              else\n                magick_info=GetMagickInfo(image->magick,exception);\n              (void) CopyMagickString(image->filename,filename,\n                MagickPathExtent);\n              encoder=GetImageEncoder(magick_info);\n            }\n          if (encoder == (EncodeImageHandler *) NULL)\n            {\n              magick_info=GetMagickInfo(image->magick,exception);\n              encoder=GetImageEncoder(magick_info);\n              if (encoder == (EncodeImageHandler *) NULL)\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  MissingDelegateError,\"NoEncodeDelegateForThisImageFormat\",\n                  \"`%s'\",write_info->magick);\n            }\n          if (encoder != (EncodeImageHandler *) NULL)\n            {\n              /*\n                Call appropriate image writer based on image type.\n              */\n              if (GetMagickEncoderThreadSupport(magick_info) == MagickFalse)\n                LockSemaphoreInfo(magick_info->semaphore);\n              status=IsCoderAuthorized(write_info->magick,WritePolicyRights,\n                exception);\n              if (status != MagickFalse)\n                status=encoder(write_info,image,exception);\n              if (GetMagickEncoderThreadSupport(magick_info) == MagickFalse)\n                UnlockSemaphoreInfo(magick_info->semaphore);\n            }\n        }\n    }\n  if (temporary != MagickFalse)\n    {\n      /*\n        Copy temporary image file to permanent.\n      */\n      status=OpenBlob(write_info,image,ReadBinaryBlobMode,exception);\n      if (status != MagickFalse)\n        {\n          (void) RelinquishUniqueFileResource(write_info->filename);\n          status=ImageToFile(image,write_info->filename,exception);\n        }\n      (void) CloseBlob(image);\n      (void) RelinquishUniqueFileResource(image->filename);\n      (void) CopyMagickString(image->filename,write_info->filename,\n        MagickPathExtent);\n\n%\n%    o image_info: the image info.\n%\n%    o images: the image list.\n%\n%    o filename: the image filename.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType WriteImages(const ImageInfo *image_info,\n  Image *images,const char *filename,ExceptionInfo *exception)\n{\n#define WriteImageTag  \"Write/Image\"\n\n  ExceptionInfo\n    *sans_exception;\n\n  ImageInfo\n    *write_info;\n\n  MagickBooleanType\n    proceed;\n\n  MagickOffsetType\n    progress;\n\n  MagickProgressMonitor\n    progress_monitor;\n\n  MagickSizeType\n    number_images;\n\n  MagickStatusType\n    status;\n\n  Image\n    *p;\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(images != (Image *) NULL);\n  assert(images->signature == MagickCoreSignature);\n  if (images->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",images->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  write_info=CloneImageInfo(image_info);\n  *write_info->magick='\\0';\n  images=GetFirstImageInList(images);\n  if (filename != (const char *) NULL)\n    for (p=images; p != (Image *) NULL; p=GetNextImageInList(p))\n      (void) CopyMagickString(p->filename,filename,MagickPathExtent);\n  (void) CopyMagickString(write_info->filename,images->filename,\n    MagickPathExtent);\n  sans_exception=AcquireExceptionInfo();\n  (void) SetImageInfo(write_info,(unsigned int) GetImageListLength(images),\n    sans_exception);\n  sans_exception=DestroyExceptionInfo(sans_exception);\n  if (*write_info->magick == '\\0')\n    (void) CopyMagickString(write_info->magick,images->magick,MagickPathExtent);\n  p=images;\n  for ( ; GetNextImageInList(p) != (Image *) NULL; p=GetNextImageInList(p))\n  {\n    Image\n      *next;\n\n    next=GetNextImageInList(p);\n    if (next == (Image *) NULL)\n      break;\n    if (p->scene >= next->scene)\n      {\n        ssize_t\n          i;\n\n        /*\n          Generate consistent scene numbers.\n        */\n        i=(ssize_t) images->scene;\n        for (p=images; p != (Image *) NULL; p=GetNextImageInList(p))\n          p->scene=(size_t) i++;\n        break;\n      }\n  }\n  /*\n    Write images.\n  */\n  status=MagickTrue;\n  progress_monitor=(MagickProgressMonitor) NULL;\n  progress=0;\n  number_images=GetImageListLength(images);\n  for (p=images; p != (Image *) NULL; p=GetNextImageInList(p))\n  {\n    if (number_images != 1)\n      progress_monitor=SetImageProgressMonitor(p,(MagickProgressMonitor) NULL,\n        p->client_data);\n    status&=WriteImage(write_info,p,exception);\n    if (number_images != 1)\n      (void) SetImageProgressMonitor(p,progress_monitor,p->client_data);\n    if (write_info->adjoin != MagickFalse)\n      break;\n    if (number_images != 1)\n      {\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n\n\n\nvoid Magick::Image::write(const std::string &imageSpec_)\n{\n  modifyImage();\n  fileName(imageSpec_);\n  GetPPException;\n  WriteImage(constImageInfo(),image(),exceptionInfo);\n  ThrowImageException;\n}\n\n\n// target function\n          }\n    }\n  } while (level > 0);\n  exif_resources=DestroySplayTree(exif_resources);\n  return(status);\n}\n\nstatic MagickBooleanType GetICCProperty(const Image *image,const char *property,\n  ExceptionInfo *exception)\n{\n  const StringInfo\n    *profile;\n\n  magick_unreferenced(property);\n  profile=GetImageProfile(image,\"icc\");\n  if (profile == (StringInfo *) NULL)\n    profile=GetImageProfile(image,\"icm\");\n  if (profile == (StringInfo *) NULL)\n    return(MagickFalse);\n  if (GetStringInfoLength(profile) < 128)\n    return(MagickFalse);  /* minimum ICC profile length */\n#if defined(MAGICKCORE_LCMS_DELEGATE)\n  {\n    cmsHPROFILE\n      icc_profile;\n\n    icc_profile=cmsOpenProfileFromMem(GetStringInfoDatum(profile),\n      (cmsUInt32Number) GetStringInfoLength(profile));\n    if (icc_profile != (cmsHPROFILE *) NULL)\n      {\n#if defined(LCMS_VERSION) && (LCMS_VERSION < 2000)\n        const char\n          *name;\n\n        name=cmsTakeProductName(icc_profile);\n        if (name != (const char *) NULL)\n          (void) SetImageProperty((Image *) image,\"icc:name\",name,exception);\n#else\n        StringInfo\n          *info;\n\n        unsigned int\n          extent;\n\n        info=AcquireStringInfo(0);\n        extent=cmsGetProfileInfoASCII(icc_profile,cmsInfoDescription,\"en\",\"US\",\n          NULL,0);\n        if (extent != 0)\n          {\n            SetStringInfoLength(info,extent+1);\n            extent=cmsGetProfileInfoASCII(icc_profile,cmsInfoDescription,\"en\",\n              \"US\",(char *) GetStringInfoDatum(info),extent);\n            if (extent != 0)\n              (void) SetImageProperty((Image *) image,\"icc:description\",\n                (char *) GetStringInfoDatum(info),exception);\n         }\n        extent=cmsGetProfileInfoASCII(icc_profile,cmsInfoManufacturer,\"en\",\"US\",\n          NULL,0);\n        if (extent != 0)\n          {\n            SetStringInfoLength(info,extent+1);\n            extent=cmsGetProfileInfoASCII(icc_profile,cmsInfoManufacturer,\"en\",\n              \"US\",(char *) GetStringInfoDatum(info),extent);\n            if (extent != 0)\n              (void) SetImageProperty((Image *) image,\"icc:manufacturer\",\n                (char *) GetStringInfoDatum(info),exception);\n          }\n        extent=cmsGetProfileInfoASCII(icc_profile,cmsInfoModel,\"en\",\"US\",\n          NULL,0);\n        if (extent != 0)\n          {\n            SetStringInfoLength(info,extent+1);\n            extent=cmsGetProfileInfoASCII(icc_profile,cmsInfoModel,\"en\",\"US\",\n              (char *) GetStringInfoDatum(info),extent);\n            if (extent != 0)\n              (void) SetImageProperty((Image *) image,\"icc:model\",\n                (char *) GetStringInfoDatum(info),exception);\n          }\n        extent=cmsGetProfileInfoASCII(icc_profile,cmsInfoCopyright,\"en\",\"US\",\n          NULL,0);\n        if (extent != 0)\n          {\n            SetStringInfoLength(info,extent+1);\n            extent=cmsGetProfileInfoASCII(icc_profile,cmsInfoCopyright,\"en\",\n              \"US\",(char *) GetStringInfoDatum(info),extent);\n            if (extent != 0)\n              (void) SetImageProperty((Image *) image,\"icc:copyright\",\n                (char *) GetStringInfoDatum(info),exception);\n          }\n        info=DestroyStringInfo(info);\n        (void) cmsCloseProfile(icc_profile);\n      }\n  }\n#endif\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType SkipXMPValue(const char *value)\n{\n  if (value == (const char*) NULL)\n    return(MagickTrue);\n  while (*value != '\\0')\n    if (isspace((int) ((unsigned char) *value)) == 0)\n      return(MagickFalse);\n    value++;\n  }\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType GetXMPProperty(const Image *image,const char *property)\n{\n  char\n    *xmp_profile;\n\n  const char\n    *content;\n\n  const StringInfo\n    *profile;\n\n  ExceptionInfo\n    *exception;\n\n  MagickBooleanType\n    status;\n\n  const char\n    *p;\n\n  XMLTreeInfo\n    *child,\n    *description,\n    *node,\n    *rdf,\n    *xmp;\n\n  profile=GetImageProfile(image,\"xmp\");\n  if (profile == (StringInfo *) NULL)\n    return(MagickFalse);\n  if (GetStringInfoLength(profile) < 17)\n    return(MagickFalse);\n  if ((property == (const char *) NULL) || (*property == '\\0'))\n    return(MagickFalse);\n  xmp_profile=StringInfoToString(profile);\n  if (xmp_profile == (char *) NULL)\n    return(MagickFalse);\n  for (p=xmp_profile; *p != '\\0'; p++)\n    if ((*p == '<') && (*(p+1) == 'x'))\n      break;\n  exception=AcquireExceptionInfo();\n  xmp=NewXMLTree((char *) p,exception);\n  xmp_profile=DestroyString(xmp_profile);\n  exception=DestroyExceptionInfo(exception);\n  if (xmp == (XMLTreeInfo *) NULL)\n    return(MagickFalse);\n  status=MagickFalse;\n  rdf=GetXMLTreeChild(xmp,\"rdf:RDF\");\n  if (rdf != (XMLTreeInfo *) NULL)\n    {\n      if (image->properties == (void *) NULL)\n        ((Image *) image)->properties=NewSplayTree(CompareSplayTreeString,\n          RelinquishMagickMemory,RelinquishMagickMemory);\n      description=GetXMLTreeChild(rdf,\"rdf:Description\");\n      while (description != (XMLTreeInfo *) NULL)\n      {\n        char\n          *xmp_namespace;\n\n        node=GetXMLTreeChild(description,(const char *) NULL);\n        while (node != (XMLTreeInfo *) NULL)\n        {\n          child=GetXMLTreeChild(node,(const char *) NULL);\n          content=GetXMLTreeContent(node);\n          if ((child == (XMLTreeInfo *) NULL) &&\n              (SkipXMPValue(content) == MagickFalse))\n            {\n              xmp_namespace=ConstantString(GetXMLTreeTag(node));\n              (void) SubstituteString(&xmp_namespace,\"exif:\",\"xmp:\");\n              (void) AddValueToSplayTree((SplayTreeInfo *) image->properties,\n                xmp_namespace,ConstantString(content));\n            }\n          while (child != (XMLTreeInfo *) NULL)\n          {\n            content=GetXMLTreeContent(child);\n            if (SkipXMPValue(content) == MagickFalse)\n              {\n                xmp_namespace=ConstantString(GetXMLTreeTag(node));\n                (void) SubstituteString(&xmp_namespace,\"exif:\",\"xmp:\");\n                (void) AddValueToSplayTree((SplayTreeInfo *) image->properties,\n                  xmp_namespace,ConstantString(content));\n              }\n            child=GetXMLTreeSibling(child);\n          }\n          node=GetXMLTreeSibling(node);\n",
    "target": 1,
    "idx": 1046219,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "// context\n\n\nstatic int _yr_parser_write_string(\n    const char* identifier,\n    int flags,\n    YR_COMPILER* compiler,\n    SIZED_STRING* str,\n    RE_AST* re_ast,\n    YR_STRING** string,\n    int* min_atom_quality,\n    int* num_atom)\n{\n  SIZED_STRING* literal_string;\n  YR_ATOM_LIST_ITEM* atom;\n  YR_ATOM_LIST_ITEM* atom_list = NULL;\n\n  int c, result;\n  int max_string_len;\n  bool free_literal = false;\n\n  *string = NULL;\n\n  result = yr_arena_allocate_struct(\n      compiler->strings_arena,\n      sizeof(YR_STRING),\n      (void**) string,\n      offsetof(YR_STRING, identifier),\n      offsetof(YR_STRING, string),\n      offsetof(YR_STRING, chained_to),\n      offsetof(YR_STRING, rule),\n      EOL);\n\n  if (result != ERROR_SUCCESS)\n    return result;\n\n  result = yr_arena_write_string(\n      compiler->sz_arena,\n      identifier,\n      &(*string)->identifier);\n\n  if (result != ERROR_SUCCESS)\n    return result;\n\n  if (flags & STRING_GFLAGS_HEXADECIMAL ||\n      flags & STRING_GFLAGS_REGEXP)\n  {\n    literal_string = yr_re_ast_extract_literal(re_ast);\n\n    if (literal_string != NULL)\n    {\n      flags |= STRING_GFLAGS_LITERAL;\n      free_literal = true;\n    }\n    else\n    {\n      // Non-literal strings can't be marked as fixed offset because once we\n      // find a string atom in the scanned data we don't know the offset where\n      // the string should start, as the non-literal strings can contain\n      // variable-length portions.\n\n      flags &= ~STRING_GFLAGS_FIXED_OFFSET;\n    }\n  }\n  else\n  {\n    literal_string = str;\n    flags |= STRING_GFLAGS_LITERAL;\n  }\n\n  (*string)->g_flags = flags;\n  (*string)->chained_to = NULL;\n  (*string)->fixed_offset = UNDEFINED;\n  (*string)->rule = compiler->current_rule;\n\n  memset((*string)->matches, 0,\n         sizeof((*string)->matches));\n\n  memset((*string)->unconfirmed_matches, 0,\n         sizeof((*string)->unconfirmed_matches));\n\n  if (flags & STRING_GFLAGS_LITERAL)\n  {\n    (*string)->length = (uint32_t) literal_string->length;\n\n    result = yr_arena_write_data(\n        compiler->sz_arena,\n        literal_string->c_string,\n        literal_string->length + 1,   // +1 to include terminating NULL\n        (void**) &(*string)->string);\n\n    if (result == ERROR_SUCCESS)\n    {\n      result = yr_atoms_extract_from_string(\n          &compiler->atoms_config,\n          (uint8_t*) literal_string->c_string,\n          (int32_t) literal_string->length,\n          flags,\n          &atom_list,\n          min_atom_quality);\n    }\n  }\n  else\n  {\n    // Emit forwards code\n    result = yr_re_ast_emit_code(re_ast, compiler->re_code_arena, false);\n\n    // Emit backwards code\n    if (result == ERROR_SUCCESS)\n      result = yr_re_ast_emit_code(re_ast, compiler->re_code_arena, true);\n\n    if (result == ERROR_SUCCESS)\n      result = yr_atoms_extract_from_re(\n          &compiler->atoms_config,\n          re_ast,\n          flags,\n          &atom_list,\n          min_atom_quality);\n  }\n\n  if (result == ERROR_SUCCESS)\n  {\n    // Add the string to Aho-Corasick automaton.\n    result = yr_ac_add_string(\n        compiler->automaton,\n        *string,\n        atom_list,\n        compiler->matches_arena);\n  }\n\n  if (flags & STRING_GFLAGS_LITERAL)\n  {\n    if (flags & STRING_GFLAGS_WIDE)\n      max_string_len = (*string)->length * 2;\n    else\n      max_string_len = (*string)->length;\n\n    if (max_string_len <= YR_MAX_ATOM_LENGTH)\n      (*string)->g_flags |= STRING_GFLAGS_FITS_IN_ATOM;\n  }\n\n  atom = atom_list;\n  c = 0;\n\n  while (atom != NULL)\n  {\n    atom = atom->next;\n    c++;\n  }\n\n  (*num_atom) += c;\n\n  if (free_literal)\n    yr_free(literal_string);\n\n  if (atom_list != NULL)\n    yr_atoms_list_destroy(atom_list);\n\n  return result;\n}\n\nint yr_parser_reduce_string_declaration(\n    yyscan_t yyscanner,\n    int32_t string_flags,\n    const char* identifier,\n    SIZED_STRING* str,\n    YR_STRING** string)\n{\n  int min_atom_quality = YR_MIN_ATOM_QUALITY;\n  int min_atom_quality_aux = YR_MIN_ATOM_QUALITY;\n\n  int32_t min_gap;\n  int32_t max_gap;\n\n  char message[512];\n\n  YR_COMPILER* compiler = yyget_extra(yyscanner);\n  YR_STRING* aux_string;\n  YR_STRING* prev_string;\n\n  RE_AST* re_ast = NULL;\n  RE_AST* remainder_re_ast = NULL;\n\n  RE_ERROR re_error;\n\n  int result = ERROR_SUCCESS;\n\n  // Determine if a string with the same identifier was already defined\n  // by searching for the identifier in string_table.\n\n  *string = (YR_STRING*) yr_hash_table_lookup(\n      compiler->strings_table,\n      identifier,\n      NULL);\n\n  if (*string != NULL)\n  {\n    result = ERROR_DUPLICATED_STRING_IDENTIFIER;\n    yr_compiler_set_error_extra_info(compiler, identifier);\n    goto _exit;\n  }\n\n  // Empty strings are not allowed\n\n  if (str->length == 0)\n  {\n    result = ERROR_EMPTY_STRING;\n    yr_compiler_set_error_extra_info(compiler, identifier);\n    goto _exit;\n  }\n\n  if (str->flags & SIZED_STRING_FLAGS_NO_CASE)\n    string_flags |= STRING_GFLAGS_NO_CASE;\n\n  if (str->flags & SIZED_STRING_FLAGS_DOT_ALL)\n    string_flags |= STRING_GFLAGS_DOT_ALL;\n\n  if (strcmp(identifier,\"$\") == 0)\n    string_flags |= STRING_GFLAGS_ANONYMOUS;\n\n  if (!(string_flags & STRING_GFLAGS_WIDE) &&\n      !(string_flags & STRING_GFLAGS_XOR))\n    string_flags |= STRING_GFLAGS_ASCII;\n\n  // Hex strings are always handled as DOT_ALL regexps.\n\n  if (string_flags & STRING_GFLAGS_HEXADECIMAL)\n    string_flags |= STRING_GFLAGS_DOT_ALL;\n\n  // The STRING_GFLAGS_SINGLE_MATCH flag indicates that finding\n  // a single match for the string is enough. This is true in\n  // most cases, except when the string count (#) and string offset (@)\n  // operators are used. All strings are marked STRING_FLAGS_SINGLE_MATCH\n  // initially, and unmarked later if required.\n\n  string_flags |= STRING_GFLAGS_SINGLE_MATCH;\n\n  // The STRING_GFLAGS_FIXED_OFFSET indicates that the string doesn't\n  // need to be searched all over the file because the user is using the\n  // \"at\" operator. The string must be searched at a fixed offset in the\n  // file. All strings are marked STRING_GFLAGS_FIXED_OFFSET initially,\n  // and unmarked later if required.\n\n  string_flags |= STRING_GFLAGS_FIXED_OFFSET;\n\n  if (string_flags & STRING_GFLAGS_HEXADECIMAL ||\n      string_flags & STRING_GFLAGS_REGEXP)\n  {\n    if (string_flags & STRING_GFLAGS_HEXADECIMAL)\n      result = yr_re_parse_hex(str->c_string, &re_ast, &re_error);\n    else\n      result = yr_re_parse(str->c_string, &re_ast, &re_error);\n\n    if (result != ERROR_SUCCESS)\n    {\n      snprintf(\n          message,\n          sizeof(message),\n          \"invalid %s \\\"%s\\\": %s\",\n          (string_flags & STRING_GFLAGS_HEXADECIMAL) ?\n              \"hex string\" : \"regular expression\",\n          identifier,\n          re_error.message);\n\n      yr_compiler_set_error_extra_info(\n          compiler, message);\n\n      goto _exit;\n    }\n\n    if (re_ast->flags & RE_FLAGS_FAST_REGEXP)\n      string_flags |= STRING_GFLAGS_FAST_REGEXP;\n\n    // Regular expressions in the strings section can't mix greedy and ungreedy\n    // quantifiers like .* and .*?. That's because these regular expressions can\n    // be matched forwards and/or backwards depending on the atom found, and we\n    // need the regexp to be all-greedy or all-ungreedy to be able to properly\n    // calculate the length of the match.\n\n    if ((re_ast->flags & RE_FLAGS_GREEDY) &&\n        (re_ast->flags & RE_FLAGS_UNGREEDY))\n    {\n      result = ERROR_INVALID_REGULAR_EXPRESSION;\n\n      yr_compiler_set_error_extra_info(compiler,\n          \"greedy and ungreedy quantifiers can't be mixed in a regular \"\n          \"expression\");\n\n      goto _exit;\n    }\n\n    if (re_ast->flags & RE_FLAGS_GREEDY)\n      string_flags |= STRING_GFLAGS_GREEDY_REGEXP;\n\n    if (yr_re_ast_contains_dot_star(re_ast))\n    {\n      yywarning(\n          yyscanner,\n          \"%s contains .* or .+, consider using .{N} or .{1,N} with a reasonable value for N\",\n          identifier);\n    }\n\n    if (compiler->re_ast_callback != NULL)\n    {\n      compiler->re_ast_callback(\n          compiler->current_rule,\n          identifier,\n          re_ast,\n          compiler->re_ast_clbk_user_data);\n    }\n\n    result = yr_re_ast_split_at_chaining_point(\n        re_ast, &re_ast, &remainder_re_ast, &min_gap, &max_gap);\n\n    if (result != ERROR_SUCCESS)\n      goto _exit;\n\n    result = _yr_parser_write_string(\n        identifier,\n        string_flags,\n        compiler,\n        NULL,\n        re_ast,\n        string,\n        &min_atom_quality,\n        &compiler->current_rule->num_atoms);\n\n    if (result != ERROR_SUCCESS)\n      goto _exit;\n\n    if (remainder_re_ast != NULL)\n    {\n      (*string)->g_flags |= STRING_GFLAGS_CHAIN_TAIL | STRING_GFLAGS_CHAIN_PART;\n      (*string)->chain_gap_min = min_gap;\n      (*string)->chain_gap_max = max_gap;\n    }\n\n    // Use \"aux_string\" from now on, we want to keep the value of \"string\"\n    // because it will returned.\n\n    aux_string = *string;\n\n    while (remainder_re_ast != NULL)\n    {\n      // Destroy regexp pointed by 're_ast' before yr_re_split_at_chaining_point\n      // overwrites 're_ast' with another value.\n\n      yr_re_ast_destroy(re_ast);\n\n      result = yr_re_ast_split_at_chaining_point(\n          remainder_re_ast, &re_ast, &remainder_re_ast, &min_gap, &max_gap);\n\n      if (result != ERROR_SUCCESS)\n        goto _exit;\n\n      prev_string = aux_string;\n\n      result = _yr_parser_write_string(\n          identifier,\n          string_flags,\n          compiler,\n          NULL,\n          re_ast,\n          &aux_string,\n          &min_atom_quality_aux,\n          &compiler->current_rule->num_atoms);\n\n      if (result != ERROR_SUCCESS)\n        goto _exit;\n\n      if (min_atom_quality_aux < min_atom_quality)\n        min_atom_quality = min_atom_quality_aux;\n\n      aux_string->g_flags |= STRING_GFLAGS_CHAIN_PART;\n      aux_string->chain_gap_min = min_gap;\n      aux_string->chain_gap_max = max_gap;\n\n      prev_string->chained_to = aux_string;\n\n      // prev_string is now chained to aux_string, an string chained\n      // to another one can't have a fixed offset, only the head of the\n      // string chain can have a fixed offset.\n\n      prev_string->g_flags &= ~STRING_GFLAGS_FIXED_OFFSET;\n    }\n  }\n  else\n  {\n    result = _yr_parser_write_string(\n        identifier,\n        string_flags,\n        compiler,\n        str,\n        NULL,\n        string,\n        &min_atom_quality,\n        &compiler->current_rule->num_atoms);\n\n    if (result != ERROR_SUCCESS)\n      goto _exit;\n  }\n\n  if (!STRING_IS_ANONYMOUS(*string))\n  {\n    result = yr_hash_table_add(\n      compiler->strings_table,\n      identifier,\n      NULL,\n      *string);\n\n    if (result != ERROR_SUCCESS)\n      goto _exit;\n  }\n\n  if (min_atom_quality < compiler->atoms_config.quality_warning_threshold)\n  {\n    yywarning(\n        yyscanner,\n        \"%s in rule %s is slowing down scanning\",\n        (*string)->identifier,\n        compiler->current_rule->identifier);\n  }\n\n_exit:\n\n  if (re_ast != NULL)\n    yr_re_ast_destroy(re_ast);\n\n  if (remainder_re_ast != NULL)\n    yr_re_ast_destroy(remainder_re_ast);\n\n  return result;\n}\n\n\n// target function\nint yr_re_ast_split_at_chaining_point(\n    RE_AST* re_ast,\n    RE_AST** result_re_ast,\n    RE_AST** remainder_re_ast,\n    int32_t* min_gap,\n    int32_t* max_gap)\n{\n  RE_NODE* child;\n  RE_NODE* concat;\n\n  int result;\n\n  *result_re_ast = re_ast;\n  *remainder_re_ast = NULL;\n  *min_gap = 0;\n  *max_gap = 0;\n\n  if (re_ast->root_node->type != RE_NODE_CONCAT)\n    return ERROR_SUCCESS;\n\n  child = re_ast->root_node->children_head;\n\n  while (child != NULL)\n  {\n    if (!child->greedy &&\n         child->type == RE_NODE_RANGE_ANY &&\n        (child->start > YR_STRING_CHAINING_THRESHOLD ||\n         child->end > YR_STRING_CHAINING_THRESHOLD))\n    {\n      result = yr_re_ast_create(remainder_re_ast);\n\n      if (result != ERROR_SUCCESS)\n        return result;\n\n      concat = yr_re_node_create(RE_NODE_CONCAT);\n\n      if (concat == NULL)\n        return ERROR_INSUFFICIENT_MEMORY;\n\n      concat->children_head = re_ast->root_node->children_head;\n      concat->children_tail = child->prev_sibling;\n\n      re_ast->root_node->children_head = child->next_sibling;\n\n      if (child->prev_sibling != NULL)\n        child->prev_sibling->next_sibling = NULL;\n\n      if (child->next_sibling != NULL)\n        child->next_sibling->prev_sibling = NULL;\n\n      *min_gap = child->start;\n      *max_gap = child->end;\n\n      (*result_re_ast)->root_node = re_ast->root_node;\n      (*result_re_ast)->flags = re_ast->flags;\n      (*remainder_re_ast)->root_node = concat;\n      (*remainder_re_ast)->flags = re_ast->flags;\n\n      yr_re_node_destroy(child);\n\n      return ERROR_SUCCESS;\n    }\n\n    child = child->next_sibling;\n  }\n\n  return ERROR_SUCCESS;\n}\nvoid test_re()\n{\n  assert_true_rule(\n      \"rule test { strings: $a = /ssi/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ssi(s|p)/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ssim*/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ssa?/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /Miss/ nocase condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /(M|N)iss/ nocase condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /[M-N]iss/ nocase condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /(Mi|ssi)ssippi/ nocase condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ppi\\\\tmi/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ppi\\\\.mi/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /^mississippi/ fullword condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /mississippi.*mississippi$/s condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /^ssi/ condition: $a }\",\n      \"mississippi\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /ssi$/ condition: $a }\",\n      \"mississippi\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /ssissi/ fullword condition: $a }\",\n      \"mississippi\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /^[isp]+/ condition: $a }\",\n      \"mississippi\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /a.{1,2}b/ wide condition: !a == 6 }\",\n      \"a\\0x\\0b\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /a.{1,2}b/ wide condition: !a == 8 }\",\n      \"a\\0x\\0x\\0b\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n      \"a\\0b\\0c\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n      \"\\0a\\0b\\0c\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n      \"\\ta\\0b\\0c\\0\");\n\n  assert_false_rule_blob(\n      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n      \"x\\0a\\0b\\0c\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n      \"x\\ta\\0b\\0c\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n      \"a\\0b\\0c\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n      \"a\\0b\\0c\\0\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n      \"a\\0b\\0c\\0\\t\");\n\n  assert_false_rule_blob(\n      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n      \"a\\0b\\0c\\0x\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n      \"a\\0b\\0c\\0b\\t\");\n\n  assert_false_rule_blob(\n      \"rule test { strings: $a = /\\\\b/ wide condition: $a }\",\n      \"abc\");\n\n  assert_regexp_syntax_error(\")\");\n  assert_true_regexp(\"abc\", \"abc\", \"abc\");\n  assert_false_regexp(\"abc\", \"xbc\");\n  assert_false_regexp(\"abc\", \"axc\");\n  assert_false_regexp(\"abc\", \"abx\");\n  assert_true_regexp(\"abc\", \"xabcx\", \"abc\");\n  assert_true_regexp(\"abc\", \"ababc\", \"abc\");\n  assert_true_regexp(\"a.c\", \"abc\", \"abc\");\n  assert_false_regexp(\"a.b\", \"a\\nb\");\n  assert_false_regexp(\"a.*b\", \"acc\\nccb\");\n  assert_false_regexp(\"a.{4,5}b\", \"acc\\nccb\");\n  assert_true_regexp(\"a.b\", \"a\\rb\", \"a\\rb\");\n  assert_true_regexp(\"ab*c\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab*c\", \"ac\", \"ac\");\n  assert_true_regexp(\"ab*bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab*bc\", \"abbc\", \"abbc\");\n  assert_true_regexp(\"a.*bb\", \"abbbb\", \"abbbb\");\n  assert_true_regexp(\"a.*?bbb\", \"abbbbbb\", \"abbb\");\n  assert_true_regexp(\"a.*c\", \"ac\", \"ac\");\n  assert_true_regexp(\"a.*c\", \"axyzc\", \"axyzc\");\n  assert_true_regexp(\"ab+c\", \"abbc\", \"abbc\");\n  assert_false_regexp(\"ab+c\", \"ac\");\n  assert_true_regexp(\"ab+\", \"abbbb\", \"abbbb\");\n  assert_true_regexp(\"ab+?\", \"abbbb\", \"ab\");\n  assert_false_regexp(\"ab+bc\", \"abc\");\n  assert_false_regexp(\"ab+bc\", \"abq\");\n  assert_true_regexp(\"a+b+c\", \"aabbabc\", \"abc\");\n  assert_false_regexp(\"ab?bc\", \"abbbbc\");\n  assert_true_regexp(\"ab?c\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab*?\", \"abbb\", \"a\");\n  assert_true_regexp(\"ab?c\", \"ac\", \"ac\");\n  assert_true_regexp(\"ab??\", \"ab\", \"a\");\n  assert_true_regexp(\"a(b|x)c\", \"abc\", \"abc\");\n  assert_true_regexp(\"a(b|x)c\", \"axc\", \"axc\");\n  assert_true_regexp(\"a(b|.)c\", \"axc\", \"axc\");\n  assert_true_regexp(\"a(b|x|y)c\", \"ayc\", \"ayc\");\n  assert_true_regexp(\"(a+|b)*\", \"ab\", \"ab\");\n  assert_true_regexp(\"a|b|c|d|e\", \"e\", \"e\");\n  assert_true_regexp(\"(a|b|c|d|e)f\", \"ef\", \"ef\");\n  assert_true_regexp(\"a|b\", \"a\", \"a\");\n  assert_true_regexp(\".b{2}\", \"abb\", \"abb\");\n  assert_true_regexp(\".b{2,3}\", \"abbb\", \"abbb\");\n  assert_true_regexp(\".b{2,3}?\", \"abbb\", \"abb\");\n  assert_true_regexp(\"ab{2,3}c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\"ab{2,3}?c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\".b{2,3}cccc\", \"abbbcccc\", \"abbbcccc\");\n  assert_true_regexp(\".b{2,3}?cccc\", \"abbbcccc\", \"bbbcccc\");\n  assert_true_regexp(\"a.b{2,3}cccc\", \"aabbbcccc\", \"aabbbcccc\");\n  assert_true_regexp(\"ab{2,3}c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\"ab{2,3}?c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\"ab{0,1}?c\", \"abc\", \"abc\");\n  assert_true_regexp(\"a{0,1}?bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"a{0,1}bc\", \"bbc\", \"bc\");\n  assert_true_regexp(\"a{0,1}?bc\", \"abc\", \"bc\");\n  assert_true_regexp(\"aa{0,1}?bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"aa{0,1}?bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"aa{0,1}bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab{1}c\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab{1,2}c\", \"abbc\", \"abbc\");\n  assert_false_regexp(\"ab{1,2}c\", \"abbbc\");\n  assert_true_regexp(\"ab{1,}c\", \"abbbc\", \"abbbc\");\n  assert_false_regexp(\"ab{1,}b\", \"ab\");\n  assert_false_regexp(\"ab{1}c\", \"abbc\");\n  assert_false_regexp(\"ab{1}c\", \"ac\");\n  assert_true_regexp(\"ab{0,}c\", \"ac\", \"ac\");\n  assert_true_regexp(\"ab{1,1}c\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab{0,}c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\"ab{,3}c\", \"abbbc\", \"abbbc\");\n  assert_false_regexp(\"ab{,2}c\", \"abbbc\");\n  assert_false_regexp(\"ab{4,5}bc\", \"abbbbc\");\n  assert_false_regexp(\"ab{3}c\", \"abbbbc\");  // Issue #817\n  assert_false_regexp(\"ab{4}c\", \"abbbbbc\");\n  assert_false_regexp(\"ab{5}c\", \"abbbbbbc\");\n  assert_true_regexp(\"ab{0,1}\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{0,2}\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\"ab{0,3}\", \"abbbbb\", \"abbb\");\n  assert_true_regexp(\"ab{0,4}\", \"abbbbb\", \"abbbb\");\n  assert_true_regexp(\"ab{1,1}\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{1,2}\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\"ab{1,3}\", \"abbbbb\", \"abbb\");\n  assert_true_regexp(\"ab{2,2}\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\"ab{2,3}\", \"abbbbb\", \"abbb\");\n  assert_true_regexp(\"ab{2,4}\", \"abbbbc\", \"abbbb\");\n  assert_true_regexp(\"ab{3,4}\", \"abbb\", \"abbb\");\n  assert_true_regexp(\"ab{3,5}\", \"abbbbb\", \"abbbbb\");\n  assert_false_regexp(\"ab{3,4}c\", \"abbbbbc\");\n  assert_false_regexp(\"ab{3,4}c\", \"abbc\");\n  assert_false_regexp(\"ab{3,5}c\", \"abbbbbbc\");\n  assert_true_regexp(\"ab{1,3}?\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{0,1}?\", \"abbbbb\", \"a\");\n  assert_true_regexp(\"ab{0,2}?\", \"abbbbb\", \"a\");\n  assert_true_regexp(\"ab{0,3}?\", \"abbbbb\", \"a\");\n  assert_true_regexp(\"ab{0,4}?\", \"abbbbb\", \"a\");\n  assert_true_regexp(\"ab{1,1}?\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{1,2}?\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{1,3}?\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{2,2}?\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\"ab{2,3}?\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\".(abc){0,1}\", \"xabcabcabcabc\", \"xabc\");\n  assert_true_regexp(\".(abc){0,2}\", \"xabcabcabcabc\", \"xabcabc\");\n  assert_true_regexp(\"x{1,2}abcd\", \"xxxxabcd\", \"xxabcd\");\n  assert_true_regexp(\"x{1,2}abcd\", \"xxxxabcd\", \"xxabcd\");\n  assert_true_regexp(\"ab{.*}\", \"ab{c}\", \"ab{c}\");\n  assert_true_regexp(\".(aa){1,2}\", \"aaaaaaaaaa\", \"aaaaa\");\n  assert_true_regexp(\"a.(bc.){2}\", \"aabcabca\", \"aabcabca\");\n  assert_true_regexp(\"(ab{1,2}c){1,3}\", \"abbcabc\", \"abbcabc\");\n  assert_true_regexp(\"ab(c|cc){1,3}d\", \"abccccccd\", \"abccccccd\");\n  assert_true_regexp(\"a[bx]c\", \"abc\", \"abc\");\n  assert_true_regexp(\"a[bx]c\", \"axc\", \"axc\");\n  assert_true_regexp(\"a[0-9]*b\", \"ab\", \"ab\");\n  assert_true_regexp(\"a[0-9]*b\", \"a0123456789b\", \"a0123456789b\");\n  assert_true_regexp(\"[0-9a-f]+\", \"0123456789abcdef\", \"0123456789abcdef\");\n  assert_true_regexp(\"[0-9a-f]+\", \"xyz0123456789xyz\", \"0123456789\");\n  assert_true_regexp(\"a[\\\\s\\\\S]b\", \"a b\", \"a b\");\n  assert_true_regexp(\"a[\\\\d\\\\D]b\", \"a1b\", \"a1b\");\n  assert_false_regexp(\"[x-z]+\", \"abc\");\n  assert_true_regexp(\"a[-]?c\", \"ac\", \"ac\");\n  assert_true_regexp(\"a[-b]\", \"a-\", \"a-\");\n  assert_true_regexp(\"a[-b]\", \"ab\", \"ab\");\n  assert_true_regexp(\"a[b-]\", \"a-\", \"a-\");\n  assert_true_regexp(\"a[b-]\", \"ab\", \"ab\");\n  assert_true_regexp(\"[a-c-e]\", \"b\", \"b\");\n  assert_true_regexp(\"[a-c-e]\", \"-\", \"-\");\n  assert_false_regexp(\"[a-c-e]\", \"d\");\n  assert_regexp_syntax_error(\"[b-a]\");\n  assert_regexp_syntax_error(\"(abc\");\n  assert_regexp_syntax_error(\"abc)\");\n  assert_regexp_syntax_error(\"a[]b\");\n  assert_true_regexp(\"a[\\\\-b]\", \"a-\", \"a-\");\n  assert_true_regexp(\"a[\\\\-b]\", \"ab\", \"ab\");\n  assert_true_regexp(\"a]\", \"a]\", \"a]\");\n  assert_true_regexp(\"a[]]b\", \"a]b\", \"a]b\");\n  assert_true_regexp(\"a[\\\\]]b\", \"a]b\", \"a]b\");\n  assert_true_regexp(\"a[^bc]d\", \"aed\", \"aed\");\n  assert_false_regexp(\"a[^bc]d\", \"abd\");\n  assert_true_regexp(\"a[^-b]c\", \"adc\", \"adc\");\n  assert_false_regexp(\"a[^-b]c\", \"a-c\");\n  assert_false_regexp(\"a[^]b]c\", \"a]c\");\n  assert_true_regexp(\"a[^]b]c\", \"adc\", \"adc\");\n  assert_true_regexp(\"[^ab]*\", \"cde\", \"cde\");\n  assert_regexp_syntax_error(\")(\");\n  assert_true_regexp(\"a\\\\sb\", \"a b\", \"a b\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\tb\", \"a\\tb\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\rb\", \"a\\rb\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\nb\", \"a\\nb\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\vb\", \"a\\vb\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\fb\", \"a\\fb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a b\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\tb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\rb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\nb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\vb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\fb\");\n  assert_true_regexp(\"\\\\n\\\\r\\\\t\\\\f\\\\a\", \"\\n\\r\\t\\f\\a\", \"\\n\\r\\t\\f\\a\");\n  assert_true_regexp(\"[\\\\n][\\\\r][\\\\t][\\\\f][\\\\a]\", \"\\n\\r\\t\\f\\a\", \"\\n\\r\\t\\f\\a\");\n  assert_true_regexp(\"\\\\x01\\\\x02\\\\x03\", \"\\x01\\x02\\x03\", \"\\x01\\x02\\x03\");\n  assert_true_regexp(\"[\\\\x01-\\\\x03]+\", \"\\x01\\x02\\x03\", \"\\x01\\x02\\x03\");\n  assert_false_regexp(\"[\\\\x00-\\\\x02]+\", \"\\x03\\x04\\x05\");\n  assert_true_regexp(\"[\\\\x5D]\", \"]\", \"]\");\n  assert_true_regexp(\"[\\\\0x5A-\\\\x5D]\", \"\\x5B\", \"\\x5B\");\n  assert_true_regexp(\"[\\\\x5D-\\\\x5F]\", \"\\x5E\", \"\\x5E\");\n  assert_true_regexp(\"[\\\\x5C-\\\\x5F]\", \"\\x5E\", \"\\x5E\");\n  assert_true_regexp(\"[\\\\x5D-\\\\x5F]\", \"\\x5E\", \"\\x5E\");\n  assert_true_regexp(\"a\\\\wc\", \"abc\", \"abc\");\n  assert_true_regexp(\"a\\\\wc\", \"a_c\", \"a_c\");\n  assert_true_regexp(\"a\\\\wc\", \"a0c\", \"a0c\");\n  assert_false_regexp(\"a\\\\wc\", \"a*c\");\n  assert_true_regexp(\"\\\\w+\", \"--ab_cd0123--\", \"ab_cd0123\");\n  assert_true_regexp(\"[\\\\w]+\", \"--ab_cd0123--\", \"ab_cd0123\");\n  assert_true_regexp(\"\\\\D+\", \"1234abc5678\", \"abc\");\n  assert_true_regexp(\"[\\\\d]+\", \"0123456789\", \"0123456789\");\n  assert_true_regexp(\"[\\\\D]+\", \"1234abc5678\", \"abc\");\n  assert_true_regexp(\"[\\\\da-fA-F]+\", \"123abc\", \"123abc\");\n  assert_false_regexp(\"^(ab|cd)e\", \"abcde\");\n  assert_true_regexp(\"(abc|)ef\", \"abcdef\", \"ef\");\n  assert_true_regexp(\"(abc|)ef\", \"abcef\", \"abcef\");\n  assert_true_regexp(\"\\\\babc\", \"abc\", \"abc\");\n  assert_true_regexp(\"abc\\\\b\", \"abc\", \"abc\");\n  assert_false_regexp(\"\\\\babc\", \"1abc\");\n  assert_false_regexp(\"abc\\\\b\", \"abc1\");\n  assert_true_regexp(\"abc\\\\s\\\\b\", \"abc x\", \"abc \");\n  assert_false_regexp(\"abc\\\\s\\\\b\", \"abc  \");\n  assert_true_regexp(\"\\\\babc\\\\b\", \" abc \", \"abc\");\n  assert_true_regexp(\"\\\\b\\\\w\\\\w\\\\w\\\\b\", \" abc \", \"abc\");\n  assert_true_regexp(\"\\\\w\\\\w\\\\w\\\\b\", \"abcd\", \"bcd\");\n  assert_true_regexp(\"\\\\b\\\\w\\\\w\\\\w\", \"abcd\", \"abc\");\n  assert_false_regexp(\"\\\\b\\\\w\\\\w\\\\w\\\\b\", \"abcd\");\n  assert_false_regexp(\"\\\\Babc\", \"abc\");\n  assert_false_regexp(\"abc\\\\B\", \"abc\");\n  assert_true_regexp(\"\\\\Babc\", \"1abc\", \"abc\");\n  assert_true_regexp(\"abc\\\\B\", \"abc1\", \"abc\");\n  assert_false_regexp(\"abc\\\\s\\\\B\", \"abc x\");\n  assert_true_regexp(\"abc\\\\s\\\\B\", \"abc  \", \"abc \");\n  assert_true_regexp(\"\\\\w\\\\w\\\\w\\\\B\", \"abcd\", \"abc\");\n  assert_true_regexp(\"\\\\B\\\\w\\\\w\\\\w\", \"abcd\", \"bcd\");\n  assert_false_regexp(\"\\\\B\\\\w\\\\w\\\\w\\\\B\", \"abcd\");\n\n  // This is allowed in most regexp engines but in order to keep the\n  // grammar free of shift/reduce conflicts I've decided not supporting\n  // it. Users can use the (abc|) form instead.\n  assert_regexp_syntax_error(\"(|abc)ef\");\n\n  assert_true_regexp(\"((a)(b)c)(d)\", \"abcd\", \"abcd\");\n  assert_true_regexp(\"(a|b)c*d\", \"abcd\", \"bcd\");\n  assert_true_regexp(\"(ab|ab*)bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"a([bc]*)c*\", \"abc\", \"abc\");\n  assert_true_regexp(\"a([bc]*)c*\", \"ac\", \"ac\");\n  assert_true_regexp(\"a([bc]*)c*\", \"a\", \"a\");\n  assert_true_regexp(\"a([bc]*)(c*d)\", \"abcd\", \"abcd\");\n  assert_true_regexp(\"a([bc]+)(c*d)\", \"abcd\", \"abcd\");\n  assert_true_regexp(\"a([bc]*)(c+d)\", \"abcd\", \"abcd\");\n  assert_true_regexp(\"a[bcd]*dcdcde\", \"adcdcde\", \"adcdcde\");\n  assert_false_regexp(\"a[bcd]+dcdcde\", \"adcdcde\");\n  assert_true_regexp(\"\\\\((.*), (.*)\\\\)\", \"(a, b)\", \"(a, b)\");\n  assert_true_regexp(\"abc|123$\", \"abcx\", \"abc\");\n  assert_false_regexp(\"abc|123$\", \"123x\");\n  assert_true_regexp(\"abc|^123\", \"123\", \"123\");\n  assert_false_regexp(\"abc|^123\", \"x123\");\n  assert_true_regexp(\"^abc$\", \"abc\", \"abc\");\n  assert_false_regexp(\"^abc$\", \"abcc\");\n  assert_true_regexp(\"^abc\", \"abcc\", \"abc\");\n  assert_false_regexp(\"^abc$\", \"aabc\");\n  assert_false_regexp(\"abc^\", \"abc\");\n  assert_false_regexp(\"ab^c\", \"abc\");\n  assert_false_regexp(\"a^bcdef\", \"abcdef\")\n  assert_true_regexp(\"abc$\", \"aabc\", \"abc\");\n  assert_false_regexp(\"$abc\", \"abc\");\n  assert_true_regexp(\"(a|a$)bcd\", \"abcd\", \"abcd\");\n  assert_false_regexp(\"(a$|a$)bcd\", \"abcd\");\n  assert_false_regexp(\"(abc$|ab$)\", \"abcd\");\n  assert_true_regexp(\"^a(bc+|b[eh])g|.h$\", \"abhg\", \"abhg\");\n  assert_true_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"effgz\", \"effgz\");\n  assert_true_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"ij\", \"ij\");\n  assert_false_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"effg\");\n  assert_false_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"bcdd\");\n  assert_true_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"reffgz\", \"effgz\");\n\n  // Test case for issue #324\n  assert_true_regexp(\"whatever|   x.   x\", \"   xy   x\", \"   xy   x\");\n\n  // test case for issue #503, \\x without two following hex-digits\n  assert_regexp_syntax_error(\"\\\\x0\");\n  assert_regexp_syntax_error(\"\\\\x\");\n\n  assert_regexp_syntax_error(\"x{0,0}\");\n  assert_regexp_syntax_error(\"x{0}\");\n\n  assert_regexp_syntax_error(\"\\\\xxy\");\n\n  // Test case for issue #682\n  assert_true_regexp(\"(a|\\\\b)[a]{1,}\", \"aaaa\", \"aaaa\");\n\n  // Test for integer overflow in repeat interval\n  assert_regexp_syntax_error(\"a{2977952116}\");\n\n  assert_error(\n      \"rule test { strings: $a = /a\\\\/ condition: $a }\",\n      ERROR_SYNTAX_ERROR);\n\n  assert_error(\n      \"rule test { strings: $a = /[a\\\\/ condition: $a }\",\n      ERROR_SYNTAX_ERROR);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = /MZ.{300,}t/ \\\n        condition: !a == 317 }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = /MZ.{300,}?t/ \\\n        condition: !a == 314 }\",\n      PE32_FILE);\n\n  assert_false_rule(\n      \"rule test { strings: $a = /abc[^d]/ nocase condition: $a }\",\n      \"abcd\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /abc[^d]/ condition: $a }\",\n      \"abcd\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /abc[^D]/ nocase condition: $a }\",\n      \"abcd\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /abc[^D]/ condition: $a }\",\n      \"abcd\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /abc[^f]/ nocase condition: $a }\",\n      \"abcd\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /abc[^f]/ condition: $a }\",\n      \"abcd\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /abc[^F]/ nocase condition: $a }\",\n      \"abcd\");\n\n  assert_true_rule(\n       \"rule test { strings: $a = /abc[^F]/ condition: $a }\",\n       \"abcd\");\n}\n",
    "target": 1,
    "idx": 1011753,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic void\nproc_plaintext( CTX c, PACKET *pkt )\n{\n  PKT_plaintext *pt = pkt->pkt.plaintext;\n  int any, clearsig, rc;\n  kbnode_t n;\n  unsigned char *extrahash;\n  size_t extrahashlen;\n\n  /* This is a literal data packet.  Bump a counter for later checks.  */\n  literals_seen++;\n\n  if (pt->namelen == 8 && !memcmp( pt->name, \"_CONSOLE\", 8))\n    log_info (_(\"Note: sender requested \\\"for-your-eyes-only\\\"\\n\"));\n  else if (opt.verbose)\n    {\n      /* We don't use print_utf8_buffer because that would require a\n       * string change which we don't want in 2.2.  It is also not\n       * clear whether the filename is always utf-8 encoded.  */\n      char *tmp = make_printable_string (pt->name, pt->namelen, 0);\n      log_info (_(\"original file name='%.*s'\\n\"), (int)strlen (tmp), tmp);\n      xfree (tmp);\n    }\n\n  free_md_filter_context (&c->mfx);\n  if (gcry_md_open (&c->mfx.md, 0, 0))\n    BUG ();\n  /* fixme: we may need to push the textfilter if we have sigclass 1\n   * and no armoring - Not yet tested\n   * Hmmm, why don't we need it at all if we have sigclass 1\n   * Should we assume that plaintext in mode 't' has always sigclass 1??\n   * See: Russ Allbery's mail 1999-02-09\n   */\n  any = clearsig = 0;\n  for (n=c->list; n; n = n->next )\n    {\n      if (n->pkt->pkttype == PKT_ONEPASS_SIG)\n        {\n          /* The onepass signature case. */\n          if (n->pkt->pkt.onepass_sig->digest_algo)\n            {\n              if (!opt.skip_verify)\n                gcry_md_enable (c->mfx.md,\n                                n->pkt->pkt.onepass_sig->digest_algo);\n\n              any = 1;\n            }\n        }\n      else if (n->pkt->pkttype == PKT_GPG_CONTROL\n               && n->pkt->pkt.gpg_control->control == CTRLPKT_CLEARSIGN_START)\n        {\n          /* The clearsigned message case. */\n          size_t datalen = n->pkt->pkt.gpg_control->datalen;\n          const byte *data = n->pkt->pkt.gpg_control->data;\n\n          /* Check that we have at least the sigclass and one hash.  */\n          if  (datalen < 2)\n            log_fatal (\"invalid control packet CTRLPKT_CLEARSIGN_START\\n\");\n          /* Note that we don't set the clearsig flag for not-dash-escaped\n           * documents.  */\n          clearsig = (*data == 0x01);\n          for (data++, datalen--; datalen; datalen--, data++)\n            if (!opt.skip_verify)\n              gcry_md_enable (c->mfx.md, *data);\n          any = 1;\n          break;  /* Stop here as one-pass signature packets are not\n                     expected.  */\n        }\n      else if (n->pkt->pkttype == PKT_SIGNATURE)\n        {\n          /* The SIG+LITERAL case that PGP used to use.  */\n          if (!opt.skip_verify)\n            gcry_md_enable (c->mfx.md, n->pkt->pkt.signature->digest_algo);\n          any = 1;\n        }\n    }\n\n  if (!any && !opt.skip_verify && !have_seen_pkt_encrypted_aead(c))\n    {\n      /* This is for the old GPG LITERAL+SIG case.  It's not legal\n         according to 2440, so hopefully it won't come up that often.\n         There is no good way to specify what algorithms to use in\n         that case, so these there are the historical answer. */\n\tgcry_md_enable (c->mfx.md, DIGEST_ALGO_RMD160);\n\tgcry_md_enable (c->mfx.md, DIGEST_ALGO_SHA1);\n    }\n  if (DBG_HASHING)\n    {\n      gcry_md_debug (c->mfx.md, \"verify\");\n      if (c->mfx.md2)\n        gcry_md_debug (c->mfx.md2, \"verify2\");\n    }\n\n  rc=0;\n\n  if (literals_seen > 1)\n    {\n      log_info (_(\"WARNING: multiple plaintexts seen\\n\"));\n\n      write_status_text (STATUS_ERROR, \"proc_pkt.plaintext 89_BAD_DATA\");\n      log_inc_errorcount ();\n      rc = gpg_error (GPG_ERR_UNEXPECTED);\n    }\n\n  if (!rc)\n    {\n      /* It we are in --verify mode, we do not want to output the\n       * signed text.  However, if --output is also used we do what\n       * has been requested and write out the signed data.  */\n      rc = handle_plaintext (pt, &c->mfx,\n                             (opt.outfp || opt.outfile)? 0 :  c->sigs_only,\n                             clearsig);\n      if (gpg_err_code (rc) == GPG_ERR_EACCES && !c->sigs_only)\n        {\n          /* Can't write output but we hash it anyway to check the\n             signature. */\n          rc = handle_plaintext( pt, &c->mfx, 1, clearsig );\n        }\n    }\n\n  if (rc)\n    log_error (\"handle plaintext failed: %s\\n\", gpg_strerror (rc));\n\n  /* We add a marker control packet instead of the plaintext packet.\n   * This is so that we can later detect invalid packet sequences.\n   * The apcket is further used to convey extra data from the\n   * plaintext packet to the signature verification. */\n  extrahash = xtrymalloc (6 + pt->namelen);\n  if (!extrahash)\n    {\n      /* No way to return an error.  */\n      rc = gpg_error_from_syserror ();\n      log_error (\"malloc failed in %s: %s\\n\", __func__, gpg_strerror (rc));\n      extrahashlen = 0;\n    }\n  else\n    {\n      extrahash[0] = pt->mode;\n      extrahash[1] = pt->namelen;\n      if (pt->namelen)\n        memcpy (extrahash+2, pt->name, pt->namelen);\n      extrahashlen = 2 + pt->namelen;\n      extrahash[extrahashlen++] = pt->timestamp >> 24;\n      extrahash[extrahashlen++] = pt->timestamp >> 16;\n      extrahash[extrahashlen++] = pt->timestamp >>  8;\n      extrahash[extrahashlen++] = pt->timestamp      ;\n    }\n\n  free_packet (pkt, NULL);\n  c->last_was_session_key = 0;\n\n  n = new_kbnode (create_gpg_control (CTRLPKT_PLAINTEXT_MARK,\n                                      extrahash, extrahashlen));\n  xfree (extrahash);\n  if (c->list)\n    add_kbnode (c->list, n);\n  else\n    c->list = n;\n}\n\nint\nproc_signature_packets (ctrl_t ctrl, void *anchor, iobuf_t a,\n\t\t\tstrlist_t signedfiles, const char *sigfilename )\n{\n  CTX c = xmalloc_clear (sizeof *c);\n  int rc;\n\n  c->ctrl = ctrl;\n  c->anchor = anchor;\n  c->sigs_only = 1;\n\n  c->signed_data.data_fd = -1;\n  c->signed_data.data_names = signedfiles;\n  c->signed_data.used = !!signedfiles;\n\n  c->sigfilename = sigfilename;\n  rc = do_proc_packets (c, a);\n\n  /* If we have not encountered any signature we print an error\n     messages, send a NODATA status back and return an error code.\n     Using log_error is required because verify_files does not check\n     error codes for each file but we want to terminate the process\n     with an error. */\n  if (!rc && !c->any.sig_seen)\n    {\n      write_status_text (STATUS_NODATA, \"4\");\n      log_error (_(\"no signature found\\n\"));\n      rc = GPG_ERR_NO_DATA;\n    }\n\n  /* Propagate the signature seen flag upward. Do this only on success\n     so that we won't issue the nodata status several times.  */\n  if (!rc && c->anchor && c->any.sig_seen)\n    c->anchor->any.sig_seen = 1;\n\n  xfree (c);\n  return rc;\n}\n\nint\nverify_signatures (ctrl_t ctrl, int nfiles, char **files )\n{\n    IOBUF fp;\n    armor_filter_context_t *afx = NULL;\n    progress_filter_context_t *pfx = new_progress_context ();\n    const char *sigfile;\n    int i, rc;\n    strlist_t sl;\n\n    /* Decide whether we should handle a detached or a normal signature,\n     * which is needed so that the code later can hash the correct data and\n     * not have a normal signature act as detached signature and ignoring the\n     * intended signed material from the 2nd file or stdin.\n     * 1. gpg <file        - normal\n     * 2. gpg file         - normal (or detached)\n     * 3. gpg file <file2  - detached\n     * 4. gpg file file2   - detached\n     * The question is how decide between case 2 and 3?  The only way\n     * we can do it is by reading one byte from stdin and then unget\n     * it; the problem here is that we may be reading from the\n     * terminal (which could be detected using isatty() but won't work\n     * when under control of a pty using program (e.g. expect)) and\n     * might get us in trouble when stdin is used for another purpose\n     * (--passphrase-fd 0).  So we have to break with the behaviour\n     * prior to gpg 1.0.4 by assuming that case 3 is a normal\n     * signature (where file2 is ignored and require for a detached\n     * signature to indicate signed material comes from stdin by using\n     * case 4 with a file2 of \"-\".\n     *\n     * Actually we don't have to change anything here but can handle\n     * that all quite easily in mainproc.c\n     */\n\n    sigfile = nfiles? *files : NULL;\n\n    /* open the signature file */\n    fp = iobuf_open(sigfile);\n    if (fp && is_secured_file (iobuf_get_fd (fp)))\n      {\n        iobuf_close (fp);\n        fp = NULL;\n        gpg_err_set_errno (EPERM);\n      }\n    if( !fp ) {\n        rc = gpg_error_from_syserror ();\n\tlog_error(_(\"can't open '%s': %s\\n\"),\n                  print_fname_stdin(sigfile), gpg_strerror (rc));\n        goto leave;\n    }\n    handle_progress (pfx, fp, sigfile);\n\n    if ( !opt.no_armor && use_armor_filter( fp ) )\n      {\n        afx = new_armor_context ();\n\tpush_armor_filter (afx, fp);\n      }\n\n    sl = NULL;\n    for(i=nfiles-1 ; i > 0 ; i-- )\n\tadd_to_strlist( &sl, files[i] );\n    rc = proc_signature_packets (ctrl, NULL, fp, sl, sigfile );\n    free_strlist(sl);\n    iobuf_close(fp);\n    if( (afx && afx->no_openpgp_data && rc == -1)\n        || gpg_err_code (rc) == GPG_ERR_NO_DATA ) {\n\tlog_error(_(\"the signature could not be verified.\\n\"\n\t\t   \"Please remember that the signature file (.sig or .asc)\\n\"\n\t\t   \"should be the first file given on the command line.\\n\") );\n\trc = 0;\n    }\n\n leave:\n    release_armor_context (afx);\n    release_progress_context (pfx);\n    return rc;\n}\n\nvoid Fuzzer::ExecuteCallback(const uint8_t *Data, size_t Size) {\n  TPC.RecordInitialStack();\n  TotalNumberOfRuns++;\n  assert(InFuzzingThread());\n  // We copy the contents of Unit into a separate heap buffer\n  // so that we reliably find buffer overflows in it.\n  uint8_t *DataCopy = new uint8_t[Size];\n  memcpy(DataCopy, Data, Size);\n  if (EF->__msan_unpoison)\n    EF->__msan_unpoison(DataCopy, Size);\n  if (CurrentUnitData && CurrentUnitData != Data)\n    memcpy(CurrentUnitData, Data, Size);\n  CurrentUnitSize = Size;\n  {\n    ScopedEnableMsanInterceptorChecks S;\n    AllocTracer.Start(Options.TraceMalloc);\n    UnitStartTime = system_clock::now();\n    TPC.ResetMaps();\n    RunningUserCallback = true;\n    int Res = CB(DataCopy, Size);\n    RunningUserCallback = false;\n    UnitStopTime = system_clock::now();\n    (void)Res;\n    assert(Res == 0);\n    HasMoreMallocsThanFrees = AllocTracer.Stop();\n  }\n  if (!LooseMemeq(DataCopy, Data, Size))\n    CrashOnOverwrittenData();\n  CurrentUnitSize = 0;\n  delete[] DataCopy;\n}\n\nint RunOneTest(Fuzzer *F, const char *InputFilePath, size_t MaxLen) {\n  Unit U = FileToVector(InputFilePath);\n  if (MaxLen && MaxLen < U.size())\n    U.resize(MaxLen);\n  F->ExecuteCallback(U.data(), U.size());\n  F->TryDetectingAMemoryLeak(U.data(), U.size(), true);\n  return 0;\n}\n\nint FuzzerDriver(int *argc, char ***argv, UserCallback Callback) {\n  using namespace fuzzer;\n  assert(argc && argv && \"Argument pointers cannot be nullptr\");\n  std::string Argv0((*argv)[0]);\n  EF = new ExternalFunctions();\n  if (EF->LLVMFuzzerInitialize)\n    EF->LLVMFuzzerInitialize(argc, argv);\n  if (EF->__msan_scoped_disable_interceptor_checks)\n    EF->__msan_scoped_disable_interceptor_checks();\n  const Vector<std::string> Args(*argv, *argv + *argc);\n  assert(!Args.empty());\n  ProgName = new std::string(Args[0]);\n  if (Argv0 != *ProgName) {\n    Printf(\"ERROR: argv[0] has been modified in LLVMFuzzerInitialize\\n\");\n    exit(1);\n  }\n  ParseFlags(Args);\n  if (Flags.help) {\n    PrintHelp();\n    return 0;\n  }\n\n  if (Flags.close_fd_mask & 2)\n    DupAndCloseStderr();\n  if (Flags.close_fd_mask & 1)\n    CloseStdout();\n\n  if (Flags.jobs > 0 && Flags.workers == 0) {\n    Flags.workers = std::min(NumberOfCpuCores() / 2, Flags.jobs);\n    if (Flags.workers > 1)\n      Printf(\"Running %u workers\\n\", Flags.workers);\n  }\n\n  if (Flags.workers > 0 && Flags.jobs > 0)\n    return RunInMultipleProcesses(Args, Flags.workers, Flags.jobs);\n\n  FuzzingOptions Options;\n  Options.Verbosity = Flags.verbosity;\n  Options.MaxLen = Flags.max_len;\n  Options.LenControl = Flags.len_control;\n  Options.UnitTimeoutSec = Flags.timeout;\n  Options.ErrorExitCode = Flags.error_exitcode;\n  Options.TimeoutExitCode = Flags.timeout_exitcode;\n  Options.IgnoreTimeouts = Flags.ignore_timeouts;\n  Options.IgnoreOOMs = Flags.ignore_ooms;\n  Options.IgnoreCrashes = Flags.ignore_crashes;\n  Options.MaxTotalTimeSec = Flags.max_total_time;\n  Options.DoCrossOver = Flags.cross_over;\n  Options.MutateDepth = Flags.mutate_depth;\n  Options.ReduceDepth = Flags.reduce_depth;\n  Options.UseCounters = Flags.use_counters;\n  Options.UseMemmem = Flags.use_memmem;\n  Options.UseCmp = Flags.use_cmp;\n  Options.UseValueProfile = Flags.use_value_profile;\n  Options.Shrink = Flags.shrink;\n  Options.ReduceInputs = Flags.reduce_inputs;\n  Options.ShuffleAtStartUp = Flags.shuffle;\n  Options.PreferSmall = Flags.prefer_small;\n  Options.ReloadIntervalSec = Flags.reload;\n  Options.OnlyASCII = Flags.only_ascii;\n  Options.DetectLeaks = Flags.detect_leaks;\n  Options.PurgeAllocatorIntervalSec = Flags.purge_allocator_interval;\n  Options.TraceMalloc = Flags.trace_malloc;\n  Options.RssLimitMb = Flags.rss_limit_mb;\n  Options.MallocLimitMb = Flags.malloc_limit_mb;\n  if (!Options.MallocLimitMb)\n    Options.MallocLimitMb = Options.RssLimitMb;\n  if (Flags.runs >= 0)\n    Options.MaxNumberOfRuns = Flags.runs;\n  if (!Inputs->empty() && !Flags.minimize_crash_internal_step)\n    Options.OutputCorpus = (*Inputs)[0];\n  Options.ReportSlowUnits = Flags.report_slow_units;\n  if (Flags.artifact_prefix)\n    Options.ArtifactPrefix = Flags.artifact_prefix;\n  if (Flags.exact_artifact_path)\n    Options.ExactArtifactPath = Flags.exact_artifact_path;\n  Vector<Unit> Dictionary;\n  if (Flags.dict)\n    if (!ParseDictionaryFile(FileToString(Flags.dict), &Dictionary))\n      return 1;\n  if (Flags.verbosity > 0 && !Dictionary.empty())\n    Printf(\"Dictionary: %zd entries\\n\", Dictionary.size());\n  bool DoPlainRun = AllInputsAreFiles();\n  Options.SaveArtifacts =\n      !DoPlainRun || Flags.minimize_crash_internal_step;\n  Options.PrintNewCovPcs = Flags.print_pcs;\n  Options.PrintNewCovFuncs = Flags.print_funcs;\n  Options.PrintFinalStats = Flags.print_final_stats;\n  Options.PrintCorpusStats = Flags.print_corpus_stats;\n  Options.PrintCoverage = Flags.print_coverage;\n  if (Flags.exit_on_src_pos)\n    Options.ExitOnSrcPos = Flags.exit_on_src_pos;\n  if (Flags.exit_on_item)\n    Options.ExitOnItem = Flags.exit_on_item;\n  if (Flags.focus_function)\n    Options.FocusFunction = Flags.focus_function;\n  if (Flags.data_flow_trace)\n    Options.DataFlowTrace = Flags.data_flow_trace;\n  Options.LazyCounters = Flags.lazy_counters;\n\n  unsigned Seed = Flags.seed;\n  // Initialize Seed.\n  if (Seed == 0)\n    Seed =\n        std::chrono::system_clock::now().time_since_epoch().count() + GetPid();\n  if (Flags.verbosity)\n    Printf(\"INFO: Seed: %u\\n\", Seed);\n\n  Random Rand(Seed);\n  auto *MD = new MutationDispatcher(Rand, Options);\n  auto *Corpus = new InputCorpus(Options.OutputCorpus);\n  auto *F = new Fuzzer(Callback, *Corpus, *MD, Options);\n\n  for (auto &U: Dictionary)\n    if (U.size() <= Word::GetMaxSize())\n      MD->AddWordToManualDictionary(Word(U.data(), U.size()));\n\n  StartRssThread(F, Flags.rss_limit_mb);\n\n  Options.HandleAbrt = Flags.handle_abrt;\n  Options.HandleBus = Flags.handle_bus;\n  Options.HandleFpe = Flags.handle_fpe;\n  Options.HandleIll = Flags.handle_ill;\n  Options.HandleInt = Flags.handle_int;\n  Options.HandleSegv = Flags.handle_segv;\n  Options.HandleTerm = Flags.handle_term;\n  Options.HandleXfsz = Flags.handle_xfsz;\n  Options.HandleUsr1 = Flags.handle_usr1;\n  Options.HandleUsr2 = Flags.handle_usr2;\n  SetSignalHandler(Options);\n\n  std::atexit(Fuzzer::StaticExitCallback);\n\n  if (Flags.minimize_crash)\n    return MinimizeCrashInput(Args, Options);\n\n  if (Flags.minimize_crash_internal_step)\n    return MinimizeCrashInputInternalStep(F, Corpus);\n\n  if (Flags.cleanse_crash)\n    return CleanseCrashInput(Args, Options);\n\n  if (DoPlainRun) {\n    Options.SaveArtifacts = false;\n    int Runs = std::max(1, Flags.runs);\n    Printf(\"%s: Running %zd inputs %d time(s) each.\\n\", ProgName->c_str(),\n           Inputs->size(), Runs);\n    for (auto &Path : *Inputs) {\n      auto StartTime = system_clock::now();\n      Printf(\"Running: %s\\n\", Path.c_str());\n      for (int Iter = 0; Iter < Runs; Iter++)\n        RunOneTest(F, Path.c_str(), Options.MaxLen);\n      auto StopTime = system_clock::now();\n      auto MS = duration_cast<milliseconds>(StopTime - StartTime).count();\n      Printf(\"Executed %s in %zd ms\\n\", Path.c_str(), (long)MS);\n    }\n    Printf(\"***\\n\"\n           \"*** NOTE: fuzzing was not performed, you have only\\n\"\n           \"***       executed the target code on a fixed set of inputs.\\n\"\n           \"***\\n\");\n    F->PrintFinalStats();\n    exit(0);\n  }\n\n  if (Flags.fork)\n    FuzzWithFork(F->GetMD().GetRand(), Options, Args, *Inputs, Flags.fork);\n\n  if (Flags.merge)\n    Merge(F, Options, Args, *Inputs, Flags.merge_control_file);\n\n  if (Flags.merge_inner) {\n    const size_t kDefaultMaxMergeLen = 1 << 20;\n    if (Options.MaxLen == 0)\n      F->SetMaxInputLen(kDefaultMaxMergeLen);\n    assert(Flags.merge_control_file);\n    F->CrashResistantMergeInternalStep(Flags.merge_control_file);\n    exit(0);\n  }\n\n  if (Flags.analyze_dict) {\n    size_t MaxLen = INT_MAX;  // Large max length.\n    UnitVector InitialCorpus;\n    for (auto &Inp : *Inputs) {\n      Printf(\"Loading corpus dir: %s\\n\", Inp.c_str());\n      ReadDirToVectorOfUnits(Inp.c_str(), &InitialCorpus, nullptr,\n                             MaxLen, /*ExitOnError=*/false);\n    }\n\n    if (Dictionary.empty() || Inputs->empty()) {\n      Printf(\"ERROR: can't analyze dict without dict and corpus provided\\n\");\n      return 1;\n    }\n    if (AnalyzeDictionary(F, Dictionary, InitialCorpus)) {\n      Printf(\"Dictionary analysis failed\\n\");\n      exit(1);\n    }\n    Printf(\"Dictionary analysis succeeded\\n\");\n    exit(0);\n  }\n\n  // Parse -seed_inputs=file1,file2,...\n  Vector<std::string> ExtraSeedFiles;\n  if (Flags.seed_inputs) {\n    std::string s = Flags.seed_inputs;\n    size_t comma_pos;\n    while ((comma_pos = s.find_last_of(',')) != std::string::npos) {\n      ExtraSeedFiles.push_back(s.substr(comma_pos + 1));\n      s = s.substr(0, comma_pos);\n    }\n    ExtraSeedFiles.push_back(s);\n  }\n\n  F->Loop(*Inputs, ExtraSeedFiles);\n\n  if (Flags.verbosity)\n    Printf(\"Done %zd runs in %zd second(s)\\n\", F->getTotalNumberOfRuns(),\n           F->secondsSinceProcessStartUp());\n  F->PrintFinalStats();\n\n  exit(0);  // Don't let F destroy itself.\n}\n\nATTRIBUTE_INTERFACE int main(int argc, char **argv) {\n  return fuzzer::FuzzerDriver(&argc, &argv, LLVMFuzzerTestOneInput);\n}\n\n\n// target function\nstatic void\nproc_plaintext( CTX c, PACKET *pkt )\n{\n  PKT_plaintext *pt = pkt->pkt.plaintext;\n  int any, clearsig, rc;\n  kbnode_t n;\n  unsigned char *extrahash;\n  size_t extrahashlen;\n\n  /* This is a literal data packet.  Bump a counter for later checks.  */\n  literals_seen++;\n\n  if (pt->namelen == 8 && !memcmp( pt->name, \"_CONSOLE\", 8))\n    log_info (_(\"Note: sender requested \\\"for-your-eyes-only\\\"\\n\"));\n  else if (opt.verbose)\n    {\n      /* We don't use print_utf8_buffer because that would require a\n       * string change which we don't want in 2.2.  It is also not\n       * clear whether the filename is always utf-8 encoded.  */\n      char *tmp = make_printable_string (pt->name, pt->namelen, 0);\n      log_info (_(\"original file name='%.*s'\\n\"), (int)strlen (tmp), tmp);\n      xfree (tmp);\n    }\n\n  free_md_filter_context (&c->mfx);\n  if (gcry_md_open (&c->mfx.md, 0, 0))\n    BUG ();\n  /* fixme: we may need to push the textfilter if we have sigclass 1\n   * and no armoring - Not yet tested\n   * Hmmm, why don't we need it at all if we have sigclass 1\n   * Should we assume that plaintext in mode 't' has always sigclass 1??\n   * See: Russ Allbery's mail 1999-02-09\n   */\n  any = clearsig = 0;\n  for (n=c->list; n; n = n->next )\n    {\n      if (n->pkt->pkttype == PKT_ONEPASS_SIG)\n        {\n          /* The onepass signature case. */\n          if (n->pkt->pkt.onepass_sig->digest_algo)\n            {\n              if (!opt.skip_verify)\n                gcry_md_enable (c->mfx.md,\n                                n->pkt->pkt.onepass_sig->digest_algo);\n\n              any = 1;\n            }\n        }\n      else if (n->pkt->pkttype == PKT_GPG_CONTROL\n               && n->pkt->pkt.gpg_control->control == CTRLPKT_CLEARSIGN_START)\n        {\n          /* The clearsigned message case. */\n          size_t datalen = n->pkt->pkt.gpg_control->datalen;\n          const byte *data = n->pkt->pkt.gpg_control->data;\n\n          /* Check that we have at least the sigclass and one hash.  */\n          if  (datalen < 2)\n            log_fatal (\"invalid control packet CTRLPKT_CLEARSIGN_START\\n\");\n          /* Note that we don't set the clearsig flag for not-dash-escaped\n           * documents.  */\n          clearsig = (*data == 0x01);\n          for (data++, datalen--; datalen; datalen--, data++)\n            if (!opt.skip_verify)\n              gcry_md_enable (c->mfx.md, *data);\n          any = 1;\n          break;  /* Stop here as one-pass signature packets are not\n                     expected.  */\n        }\n      else if (n->pkt->pkttype == PKT_SIGNATURE)\n        {\n          /* The SIG+LITERAL case that PGP used to use.  */\n          if (!opt.skip_verify)\n            gcry_md_enable (c->mfx.md, n->pkt->pkt.signature->digest_algo);\n          any = 1;\n        }\n    }\n\n  if (!any && !opt.skip_verify && !have_seen_pkt_encrypted_aead(c))\n    {\n      /* This is for the old GPG LITERAL+SIG case.  It's not legal\n         according to 2440, so hopefully it won't come up that often.\n         There is no good way to specify what algorithms to use in\n         that case, so these there are the historical answer. */\n\tgcry_md_enable (c->mfx.md, DIGEST_ALGO_RMD160);\n\tgcry_md_enable (c->mfx.md, DIGEST_ALGO_SHA1);\n    }\n  if (DBG_HASHING)\n    {\n      gcry_md_debug (c->mfx.md, \"verify\");\n      if (c->mfx.md2)\n        gcry_md_debug (c->mfx.md2, \"verify2\");\n    }\n\n  rc=0;\n\n  if (literals_seen > 1)\n    {\n      log_info (_(\"WARNING: multiple plaintexts seen\\n\"));\n\n      write_status_text (STATUS_ERROR, \"proc_pkt.plaintext 89_BAD_DATA\");\n      log_inc_errorcount ();\n      rc = gpg_error (GPG_ERR_UNEXPECTED);\n    }\n\n  if (!rc)\n    {\n      /* It we are in --verify mode, we do not want to output the\n       * signed text.  However, if --output is also used we do what\n       * has been requested and write out the signed data.  */\n      rc = handle_plaintext (pt, &c->mfx,\n                             (opt.outfp || opt.outfile)? 0 :  c->sigs_only,\n                             clearsig);\n      if (gpg_err_code (rc) == GPG_ERR_EACCES && !c->sigs_only)\n        {\n          /* Can't write output but we hash it anyway to check the\n             signature. */\n          rc = handle_plaintext( pt, &c->mfx, 1, clearsig );\n        }\n    }\n\n  if (rc)\n    log_error (\"handle plaintext failed: %s\\n\", gpg_strerror (rc));\n\n  free_packet (pkt, NULL);\n  c->last_was_session_key = 0;\n\n  /* We add a marker control packet instead of the plaintext packet.\n   * This is so that we can later detect invalid packet sequences.\n   * The apcket is further used to convey extra data from the\n   * plaintext packet to the signature verification. */\n  extrahash = xtrymalloc (6 + pt->namelen);\n  if (!extrahash)\n    {\n      /* No way to return an error.  */\n      rc = gpg_error_from_syserror ();\n      log_error (\"malloc failed in %s: %s\\n\", __func__, gpg_strerror (rc));\n      extrahashlen = 0;\n    }\n  else\n    {\n      extrahash[0] = pt->mode;\n      extrahash[1] = pt->namelen;\n      if (pt->namelen)\n        memcpy (extrahash+2, pt->name, pt->namelen);\n      extrahashlen = 2 + pt->namelen;\n      extrahash[extrahashlen++] = pt->timestamp >> 24;\n      extrahash[extrahashlen++] = pt->timestamp >> 16;\n      extrahash[extrahashlen++] = pt->timestamp >>  8;\n      extrahash[extrahashlen++] = pt->timestamp      ;\n    }\n\n  n = new_kbnode (create_gpg_control (CTRLPKT_PLAINTEXT_MARK,\n                                      extrahash, extrahashlen));\n  xfree (extrahash);\n  if (c->list)\n    add_kbnode (c->list, n);\n  else\n    c->list = n;\n}\n",
    "target": 1,
    "idx": 1013730,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nvoid cil_list_destroy(struct cil_list **list, unsigned destroy_data)\n{\n\tstruct cil_list_item *item;\n\n\tif (*list == NULL) {\n\t\treturn;\n\t}\n\n\titem = (*list)->head;\n\twhile (item != NULL)\n\t{\n\t\tstruct cil_list_item *next = item->next;\n\t\tif (item->flavor == CIL_LIST) {\n\t\t\tcil_list_destroy((struct cil_list**)&(item->data), destroy_data);\n\t\t\tfree(item);\n\t\t} else {\n\t\t\tcil_list_item_destroy(&item, destroy_data);\n\t\t}\n\t\titem = next;\n\t}\n\tfree(*list);\n\t*list = NULL;\n}\n\nvoid cil_destroy_classperms(struct cil_classperms *cp)\n{\n\tif (cp == NULL) {\n\t\treturn;\n\t}\n\n\tcil_list_destroy(&cp->perm_strs, CIL_TRUE);\n\tcil_list_destroy(&cp->perms, CIL_FALSE);\n\n\tfree(cp);\n}\n\nvoid cil_destroy_classperms_list(struct cil_list **cp_list)\n{\n\tstruct cil_list_item *curr;\n\n\tif (cp_list == NULL || *cp_list == NULL) {\n\t\treturn;\n\t}\n\n\tcil_list_for_each(curr, *cp_list) {\n\t\tif (curr->flavor == CIL_CLASSPERMS) {\n\t\t\tcil_destroy_classperms(curr->data);\n\t\t} else {\n\t\t\tcil_destroy_classperms_set(curr->data);\n\t\t}\n\t}\n\n\tcil_list_destroy(cp_list, CIL_FALSE);\n}\n\nvoid cil_destroy_classpermission(struct cil_classpermission *cp)\n{\n\tif (cp == NULL) {\n\t\treturn;\n\t}\n\n\tif (cp->datum.name != NULL) {\n\t\tcil_list_destroy(&cp->classperms, CIL_FALSE);\n\t} else {\n\t\t/* anonymous classpermission from call */\n\t\tcil_destroy_classperms_list(&cp->classperms);\n\t}\n\n\tcil_symtab_datum_destroy(&cp->datum);\n\n\n\tfree(cp);\n}\n\nvoid cil_destroy_args(struct cil_args *args)\n{\n\tif (args == NULL) {\n\t\treturn;\n\t}\n\n\tif (args->arg_str != NULL) {\n\t\targs->arg_str = NULL;\n\t} else if (args->arg != NULL) {\n\t\tstruct cil_tree_node *node = args->arg->nodes->head->data;\n\t\tswitch (args->flavor) {\n\t\tcase CIL_DECLARED_STRING:\n\t\t\tbreak;\n\t\tcase CIL_CATSET:\n\t\t\tcil_destroy_catset((struct cil_catset *)args->arg);\n\t\t\tfree(node);\n\t\t\tbreak;\n\t\tcase CIL_LEVEL:\n\t\t\tcil_destroy_level((struct cil_level *)args->arg);\n\t\t\tfree(node);\n\t\t\tbreak;\n\t\tcase CIL_LEVELRANGE:\n\t\t\tcil_destroy_levelrange((struct cil_levelrange *)args->arg);\n\t\t\tfree(node);\n\t\t\tbreak;\n\t\tcase CIL_IPADDR:\n\t\t\tcil_destroy_ipaddr((struct cil_ipaddr *)args->arg);\n\t\t\tfree(node);\n\t\t\tbreak;\n\t\tcase CIL_CLASSPERMISSION:\n\t\t\tcil_destroy_classpermission((struct cil_classpermission *)args->arg);\n\t\t\tfree(node);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcil_log(CIL_ERR, \"Destroying arg with the unexpected flavor=%d\\n\",args->flavor);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\targs->param_str = NULL;\n\targs->arg = NULL;\n\n\tfree(args);\n}\n\n\n\nvoid cil_list_item_destroy(struct cil_list_item **item, unsigned destroy_data)\n{\n\tif (destroy_data) {\n\t\tcil_destroy_data(&(*item)->data, (*item)->flavor);\n\t}\n\tfree(*item);\n\t*item = NULL;\n}\n\nvoid cil_list_destroy(struct cil_list **list, unsigned destroy_data)\n{\n\tstruct cil_list_item *item;\n\n\tif (*list == NULL) {\n\t\treturn;\n\t}\n\n\titem = (*list)->head;\n\twhile (item != NULL)\n\t{\n\t\tstruct cil_list_item *next = item->next;\n\t\tif (item->flavor == CIL_LIST) {\n\t\t\tcil_list_destroy((struct cil_list**)&(item->data), destroy_data);\n\t\t\tfree(item);\n\t\t} else {\n\t\t\tcil_list_item_destroy(&item, destroy_data);\n\t\t}\n\t\titem = next;\n\t}\n\tfree(*list);\n\t*list = NULL;\n}\n\nvoid cil_destroy_call(struct cil_call *call)\n{\n\tif (call == NULL) {\n\t\treturn;\n\t}\n\n\tcall->macro = NULL;\n\n\tif (call->args_tree != NULL) {\n\t\tcil_tree_destroy(&call->args_tree);\n\t}\n\n\tif (call->args != NULL) {\n\t\tcil_list_destroy(&call->args, 1);\n\t}\n\n\tfree(call);\n}\n\n\n\nvoid cil_tree_children_destroy(struct cil_tree_node *node)\n{\n\tstruct cil_tree_node *curr, *next;\n\n\tif (!node) {\n\t\treturn;\n\t}\n\n\tcurr = node->cl_head;\n\twhile (curr) {\n\t\tnext = curr->next;\n\t\tcil_tree_children_destroy(curr);\n\t\tcil_tree_node_destroy(&curr);\n\t\tcurr = next;\n\t}\n\tnode->cl_head = NULL;\n\tnode->cl_tail = NULL;\n}\n\nvoid cil_tree_children_destroy(struct cil_tree_node *node)\n{\n\tstruct cil_tree_node *curr, *next;\n\n\tif (!node) {\n\t\treturn;\n\t}\n\n\tcurr = node->cl_head;\n\twhile (curr) {\n\t\tnext = curr->next;\n\t\tcil_tree_children_destroy(curr);\n\t\tcil_tree_node_destroy(&curr);\n\t\tcurr = next;\n\t}\n\tnode->cl_head = NULL;\n\tnode->cl_tail = NULL;\n}\n\nvoid cil_tree_subtree_destroy(struct cil_tree_node *node)\n{\n\tcil_tree_children_destroy(node);\n\tcil_tree_node_destroy(&node);\n}\n\nvoid cil_tree_destroy(struct cil_tree **tree)\n{\n\tif (tree == NULL || *tree == NULL) {\n\t\treturn;\n\t}\n\n\tcil_tree_subtree_destroy((*tree)->root);\n\tfree(*tree);\n\t*tree = NULL;\n}\n\nvoid cil_db_destroy(struct cil_db **db)\n{\n\tif (db == NULL || *db == NULL) {\n\t\treturn;\n\t}\n\n\tcil_tree_destroy(&(*db)->parse);\n\tcil_tree_destroy(&(*db)->ast);\n\tcil_list_destroy(&(*db)->sidorder, CIL_FALSE);\n\tcil_list_destroy(&(*db)->classorder, CIL_FALSE);\n\tcil_list_destroy(&(*db)->catorder, CIL_FALSE);\n\tcil_list_destroy(&(*db)->sensitivityorder, CIL_FALSE);\n\tcil_sort_destroy(&(*db)->netifcon);\n\tcil_sort_destroy(&(*db)->genfscon);\n\tcil_sort_destroy(&(*db)->filecon);\n\tcil_sort_destroy(&(*db)->nodecon);\n\tcil_sort_destroy(&(*db)->ibpkeycon);\n\tcil_sort_destroy(&(*db)->ibendportcon);\n\tcil_sort_destroy(&(*db)->portcon);\n\tcil_sort_destroy(&(*db)->pirqcon);\n\tcil_sort_destroy(&(*db)->iomemcon);\n\tcil_sort_destroy(&(*db)->ioportcon);\n\tcil_sort_destroy(&(*db)->pcidevicecon);\n\tcil_sort_destroy(&(*db)->devicetreecon);\n\tcil_sort_destroy(&(*db)->fsuse);\n\tcil_list_destroy(&(*db)->userprefixes, CIL_FALSE);\n\tcil_list_destroy(&(*db)->selinuxusers, CIL_FALSE);\n\n\tcil_declared_strings_list_destroy(&(*db)->declared_strings);\n\n\tcil_destroy_type((*db)->selftype);\n\tcil_destroy_type((*db)->notselftype);\n\tcil_destroy_type((*db)->othertype);\n\n\tcil_strpool_destroy();\n\tfree((*db)->val_to_type);\n\tfree((*db)->val_to_role);\n\tfree((*db)->val_to_user);\n\n\tfree(*db);\n\t*db = NULL;\t\n}\n\n\n// target function\nint cil_resolve_classpermissionset(struct cil_tree_node *current, struct cil_classpermissionset *cps, struct cil_db *db)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_list_item *curr;\n\tstruct cil_symtab_datum *datum;\n\tstruct cil_classpermission *cp;\n\n\trc = cil_resolve_name(current, cps->set_str, CIL_SYM_CLASSPERMSETS, db, &datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\trc = cil_resolve_classperms_list(current, cps->classperms, db);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tcp = (struct cil_classpermission *)datum;\n\tcps->set = cp;\n\n\tif (cp->classperms == NULL) {\n\t\tcil_list_init(&cp->classperms, CIL_CLASSPERMS);\n\t}\n\n\tcil_list_for_each(curr, cps->classperms) {\n\t\tcil_list_append(cp->classperms, curr->flavor, curr->data);\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n",
    "target": 1,
    "idx": 1060670,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n\n\n\n\n\n\n\n_LIBCPP_NODISCARD_EXT inline\n_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17\nbool\nbinary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::binary_search(__first, __last, __value_,\n                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());\n}\n\nstd::string AffixMgr::prefix_check_morph(const std::string& word,\n                                         int start,\n                                         int len,\n                                         char in_compound,\n                                         const FLAG needflag) {\n\n  std::string result;\n\n  pfx = NULL;\n  sfxappnd = NULL;\n  sfxextra = 0;\n\n  // first handle the special case of 0 length prefixes\n  PfxEntry* pe = pStart[0];\n  while (pe) {\n    std::string st = pe->check_morph(word, start, len, in_compound, needflag);\n    if (!st.empty()) {\n      result.append(st);\n    }\n    pe = pe->getNext();\n  }\n\n  // now handle the general case\n  unsigned char sp = word[start];\n  PfxEntry* pptr = pStart[sp];\n\n  while (pptr) {\n    if (isSubset(pptr->getKey(), word.c_str() + start)) {\n      std::string st = pptr->check_morph(word, start, len, in_compound, needflag);\n      if (!st.empty()) {\n        // fogemorpheme\n        if ((in_compound != IN_CPD_NOT) ||\n            !((pptr->getCont() && (TESTAFF(pptr->getCont(), onlyincompound,\n                                           pptr->getContLen()))))) {\n          result.append(st);\n          pfx = pptr;\n        }\n      }\n      pptr = pptr->getNextEQ();\n    } else {\n      pptr = pptr->getNextNE();\n    }\n  }\n\n  return result;\n}\n\nstd::string AffixMgr::affix_check_morph(const std::string& word,\n                                  int start,\n                                  int len,\n                                  const FLAG needflag,\n                                  char in_compound) {\n  std::string result;\n\n  // check all prefixes (also crossed with suffixes if allowed)\n  std::string st = prefix_check_morph(word, start, len, in_compound);\n  if (!st.empty()) {\n    result.append(st);\n  }\n\n  // if still not found check all suffixes\n  st = suffix_check_morph(word, start, len, 0, NULL, '\\0', needflag, in_compound);\n  if (!st.empty()) {\n    result.append(st);\n  }\n\n  if (havecontclass) {\n    sfx = NULL;\n    pfx = NULL;\n    // if still not found check all two-level suffixes\n    st = suffix_check_twosfx_morph(word, start, len, 0, NULL, needflag);\n    if (!st.empty()) {\n      result.append(st);\n    }\n\n    // if still not found check all two-level suffixes\n    st = prefix_check_twosfx_morph(word, start, len, IN_CPD_NOT, needflag);\n    if (!st.empty()) {\n      result.append(st);\n    }\n  }\n\n  return result;\n}\n\n\n\n\n\nint Hunspell_add(Hunhandle* pHunspell, const char* word) {\n  return reinterpret_cast<HunspellImpl*>(pHunspell)->add(word);\n}\n\nint Hunspell_add(Hunhandle* pHunspell, const char* word) {\n  return reinterpret_cast<HunspellImpl*>(pHunspell)->add(word);\n}\n\n\n// target function\n  inline short getContLen() { return contclasslen; }\n",
    "target": 1,
    "idx": 1051277,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "// context\n/* Cleanup function, returned from check_format hook.  */\n\nstatic void\npe_ILF_cleanup (bfd *abfd)\n{\n  coff_object_cleanup (abfd);\n\n  struct bfd_in_memory *bim = abfd->iostream;\n  free (bim->buffer);\n  free (bim);\n\nbool\nbfd_check_format_matches (bfd *abfd, bfd_format format, char ***matching)\n{\n  extern const bfd_target binary_vec;\n#if BFD_SUPPORTS_PLUGINS\n  extern const bfd_target plugin_vec;\n#endif\n  const bfd_target * const *target;\n  const bfd_target **matching_vector = NULL;\n  const bfd_target *save_targ, *right_targ, *ar_right_targ, *match_targ;\n  int match_count, best_count, best_match;\n  int ar_match_index;\n  unsigned int initial_section_id = _bfd_section_id;\n  struct bfd_preserve preserve, preserve_match;\n  bfd_cleanup cleanup = NULL;\n  bfd_error_handler_type orig_error_handler;\n  static int in_check_format;\n\n  if (matching != NULL)\n    *matching = NULL;\n\n  if (!bfd_read_p (abfd)\n      || (unsigned int) abfd->format >= (unsigned int) bfd_type_end)\n    {\n      bfd_set_error (bfd_error_invalid_operation);\n      return false;\n    }\n\n  if (abfd->format != bfd_unknown)\n    return abfd->format == format;\n\n  if (matching != NULL || *bfd_associated_vector != NULL)\n    {\n      size_t amt;\n\n      amt = sizeof (*matching_vector) * 2 * _bfd_target_vector_entries;\n      matching_vector = (const bfd_target **) bfd_malloc (amt);\n      if (!matching_vector)\n\treturn false;\n    }\n\n  /* Presume the answer is yes.  */\n  abfd->format = format;\n  save_targ = abfd->xvec;\n\n  /* Don't report errors on recursive calls checking the first element\n     of an archive.  */\n  if (in_check_format)\n    orig_error_handler = bfd_set_error_handler (null_error_handler);\n  else\n    orig_error_handler = _bfd_set_error_handler_caching (abfd);\n  ++in_check_format;\n\n  preserve_match.marker = NULL;\n  if (!bfd_preserve_save (abfd, &preserve, NULL))\n    goto err_ret;\n\n  /* If the target type was explicitly specified, just check that target.  */\n  if (!abfd->target_defaulted)\n    {\n      if (bfd_seek (abfd, 0, SEEK_SET) != 0)\t/* rewind! */\n\tgoto err_ret;\n\n      cleanup = BFD_SEND_FMT (abfd, _bfd_check_format, (abfd));\n\n      if (cleanup)\n\tgoto ok_ret;\n\n      /* For a long time the code has dropped through to check all\n\t targets if the specified target was wrong.  I don't know why,\n\t and I'm reluctant to change it.  However, in the case of an\n\t archive, it can cause problems.  If the specified target does\n\t not permit archives (e.g., the binary target), then we should\n\t not allow some other target to recognize it as an archive, but\n\t should instead allow the specified target to recognize it as an\n\t object.  When I first made this change, it broke the PE target,\n\t because the specified pei-i386 target did not recognize the\n\t actual pe-i386 archive.  Since there may be other problems of\n\t this sort, I changed this test to check only for the binary\n\t target.  */\n      if (format == bfd_archive && save_targ == &binary_vec)\n\tgoto err_unrecog;\n    }\n\n  /* Since the target type was defaulted, check them all in the hope\n     that one will be uniquely recognized.  */\n  right_targ = NULL;\n  ar_right_targ = NULL;\n  match_targ = NULL;\n  best_match = 256;\n  best_count = 0;\n  match_count = 0;\n  ar_match_index = _bfd_target_vector_entries;\n\n  for (target = bfd_target_vector; *target != NULL; target++)\n    {\n      void **high_water;\n\n      /* The binary target matches anything, so don't return it when\n\t searching.  Don't match the plugin target if we have another\n\t alternative since we want to properly set the input format\n\t before allowing a plugin to claim the file.  Also, don't\n\t check the default target twice.  */\n      if (*target == &binary_vec\n#if BFD_SUPPORTS_PLUGINS\n\t  || (match_count != 0 && *target == &plugin_vec)\n#endif\n\t  || (!abfd->target_defaulted && *target == save_targ))\n\tcontinue;\n\n      /* If we already tried a match, the bfd is modified and may\n\t have sections attached, which will confuse the next\n\t _bfd_check_format call.  */\n      bfd_reinit (abfd, initial_section_id, &preserve, cleanup);\n      /* Free bfd_alloc memory too.  If we have matched and preserved\n\t a target then the high water mark is that much higher.  */\n      if (preserve_match.marker)\n\thigh_water = &preserve_match.marker;\n      else\n\thigh_water = &preserve.marker;\n      bfd_release (abfd, *high_water);\n      *high_water = bfd_alloc (abfd, 1);\n\n      /* Change BFD's target temporarily.  */\n      abfd->xvec = *target;\n\n      if (bfd_seek (abfd, 0, SEEK_SET) != 0)\n\tgoto err_ret;\n\n      cleanup = BFD_SEND_FMT (abfd, _bfd_check_format, (abfd));\n      if (cleanup)\n\t{\n\t  int match_priority = abfd->xvec->match_priority;\n#if BFD_SUPPORTS_PLUGINS\n\t  /* If this object can be handled by a plugin, give that the\n\t     lowest priority; objects both handled by a plugin and\n\t     with an underlying object format will be claimed\n\t     separately by the plugin.  */\n\t  if (*target == &plugin_vec)\n\t    match_priority = (*target)->match_priority;\n#endif\n\n\t  if (abfd->format != bfd_archive\n\t      || (bfd_has_map (abfd)\n\t\t  && bfd_get_error () != bfd_error_wrong_object_format))\n\t    {\n\t      /* If this is the default target, accept it, even if\n\t\t other targets might match.  People who want those\n\t\t other targets have to set the GNUTARGET variable.  */\n\t      if (abfd->xvec == bfd_default_vector[0])\n\t\tgoto ok_ret;\n\n\t      if (matching_vector)\n\t\tmatching_vector[match_count] = abfd->xvec;\n\t      match_count++;\n\n\t      if (match_priority < best_match)\n\t\t{\n\t\t  best_match = match_priority;\n\t\t  best_count = 0;\n\t\t}\n\t      if (match_priority <= best_match)\n\t\t{\n\t\t  /* This format checks out as ok!  */\n\t\t  right_targ = abfd->xvec;\n\t\t  best_count++;\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      /* An archive with no armap or objects of the wrong\n\t\t type.  We want this target to match if we get no\n\t\t better matches.  */\n\t      if (ar_right_targ != bfd_default_vector[0])\n\t\tar_right_targ = *target;\n\t      if (matching_vector)\n\t\tmatching_vector[ar_match_index] = *target;\n\t      ar_match_index++;\n\t    }\n\n\t  if (preserve_match.marker == NULL)\n\t    {\n\t      match_targ = abfd->xvec;\n\t      if (!bfd_preserve_save (abfd, &preserve_match, cleanup))\n\t\tgoto err_ret;\n\t      cleanup = NULL;\n\t    }\n\t}\n    }\n\n  if (best_count == 1)\n    match_count = 1;\n\n  if (match_count == 0)\n    {\n      /* Try partial matches.  */\n      right_targ = ar_right_targ;\n\n      if (right_targ == bfd_default_vector[0])\n\t{\n\t  match_count = 1;\n\t}\n      else\n\t{\n\t  match_count = ar_match_index - _bfd_target_vector_entries;\n\n\t  if (matching_vector && match_count > 1)\n\t    memcpy (matching_vector,\n\t\t    matching_vector + _bfd_target_vector_entries,\n\t\t    sizeof (*matching_vector) * match_count);\n\t}\n    }\n\n  /* We have more than one equally good match.  If any of the best\n     matches is a target in config.bfd targ_defvec or targ_selvecs,\n     choose it.  */\n  if (match_count > 1)\n    {\n      const bfd_target * const *assoc = bfd_associated_vector;\n\n      while ((right_targ = *assoc++) != NULL)\n\t{\n\t  int i = match_count;\n\n\t  while (--i >= 0)\n\t    if (matching_vector[i] == right_targ\n\t\t&& right_targ->match_priority <= best_match)\n\t      break;\n\n\t  if (i >= 0)\n\t    {\n\t      match_count = 1;\n\t      break;\n\t    }\n\t}\n    }\n\n  /* We still have more than one equally good match, and at least some\n     of the targets support match priority.  Choose the first of the\n     best matches.  */\n  if (matching_vector && match_count > 1 && best_count != match_count)\n    {\n      int i;\n\n      for (i = 0; i < match_count; i++)\n\t{\n\t  right_targ = matching_vector[i];\n\t  if (right_targ->match_priority <= best_match)\n\t    break;\n\t}\n      match_count = 1;\n    }\n\n  /* There is way too much undoing of half-known state here.  We\n     really shouldn't iterate on live bfd's.  Note that saving the\n     whole bfd and restoring it would be even worse; the first thing\n     you notice is that the cached bfd file position gets out of sync.  */\n  if (preserve_match.marker != NULL)\n    cleanup = bfd_preserve_restore (abfd, &preserve_match);\n\n  if (match_count == 1)\n    {\n      abfd->xvec = right_targ;\n      /* If we come out of the loop knowing that the last target that\n\t matched is the one we want, then ABFD should still be in a usable\n\t state (except possibly for XVEC).  This is not just an\n\t optimisation.  In the case of plugins a match against the\n\t plugin target can result in the bfd being changed such that\n\t it no longer matches the plugin target, nor will it match\n\t RIGHT_TARG again.  */\n      if (match_targ != right_targ)\n\t{\n\t  bfd_reinit (abfd, initial_section_id, &preserve, cleanup);\n\t  bfd_release (abfd, preserve.marker);\n\t  if (bfd_seek (abfd, 0, SEEK_SET) != 0)\n\t    goto err_ret;\n\t  cleanup = BFD_SEND_FMT (abfd, _bfd_check_format, (abfd));\n\t  BFD_ASSERT (cleanup != NULL);\n\t}\n\n    ok_ret:\n      /* If the file was opened for update, then `output_has_begun'\n\t some time ago when the file was created.  Do not recompute\n\t sections sizes or alignments in _bfd_set_section_contents.\n\t We can not set this flag until after checking the format,\n\t because it will interfere with creation of BFD sections.  */\n      if (abfd->direction == both_direction)\n\tabfd->output_has_begun = true;\n\n      free (matching_vector);\n      if (preserve_match.marker != NULL)\n\tbfd_preserve_finish (abfd, &preserve_match);\n      bfd_preserve_finish (abfd, &preserve);\n      bfd_set_error_handler (orig_error_handler);\n\n      struct per_xvec_message **list = _bfd_per_xvec_warn (abfd->xvec, 0);\n      if (*list)\n\tprint_warnmsg (list);\n      list = _bfd_per_xvec_warn (NULL, 0);\n      for (size_t i = 0; i < _bfd_target_vector_entries + 1; i++)\n\tclear_warnmsg (list++);\n      --in_check_format;\n\n      /* File position has moved, BTW.  */\n      return true;\n    }\n\n  if (match_count == 0)\n    {\n    err_unrecog:\n      bfd_set_error (bfd_error_file_not_recognized);\n    err_ret:\n      if (cleanup)\n\tcleanup (abfd);\n      abfd->xvec = save_targ;\n      abfd->format = bfd_unknown;\n      free (matching_vector);\n      goto out;\n    }\n\n  /* Restore original target type and format.  */\n  abfd->xvec = save_targ;\n  abfd->format = bfd_unknown;\n  bfd_set_error (bfd_error_file_ambiguously_recognized);\n\n  if (matching)\n    {\n      *matching = (char **) matching_vector;\n      matching_vector[match_count] = NULL;\n      /* Return target names.  This is a little nasty.  Maybe we\n\t should do another bfd_malloc?  */\n      while (--match_count >= 0)\n\t{\n\t  const char *name = matching_vector[match_count]->name;\n\t  *(const char **) &matching_vector[match_count] = name;\n\t}\n    }\n  else\n    free (matching_vector);\n  if (cleanup)\n    cleanup (abfd);\n out:\n  if (preserve_match.marker != NULL)\n    bfd_preserve_finish (abfd, &preserve_match);\n  bfd_preserve_restore (abfd, &preserve);\n  bfd_set_error_handler (orig_error_handler);\n  struct per_xvec_message **list = _bfd_per_xvec_warn (NULL, 0);\n  struct per_xvec_message **one = NULL;\n  for (size_t i = 0; i < _bfd_target_vector_entries + 1; i++)\n    {\n      if (list[i])\n\t{\n\t  if (!one)\n\t    one = list + i;\n\t  else\n\t    {\n\t      one = NULL;\n\t      break;\n\t    }\n\t}\n    }\n  if (one)\n    print_warnmsg (one);\n  for (size_t i = 0; i < _bfd_target_vector_entries + 1; i++)\n    clear_warnmsg (list++);\n  --in_check_format;\n  return false;\n}\n\n\n// target function\nstatic void\nio_reinit (bfd *abfd, struct bfd_preserve *preserve)\n{\n  if (abfd->iovec != preserve->iovec)\n    {\n      /* Handle file backed to in-memory transition.  bfd_cache_close\n\t won't do anything unless abfd->iovec is the cache_iovec.  */\n      bfd_cache_close (abfd);\n      abfd->iovec = preserve->iovec;\n\n      if (abfd->iostream != preserve->iostream)\n\t{\n\t  if ((abfd->flags & BFD_IN_MEMORY) != 0)\n\t    free (abfd->iostream);\n\t  abfd->iostream = preserve->iostream;\n\t}\n\n      /* Handle in-memory to file backed transition.  */\n      if ((abfd->flags & BFD_CLOSED_BY_CACHE) != 0\n\t  && (abfd->flags & BFD_IN_MEMORY) != 0\n\t  && (preserve->flags & BFD_CLOSED_BY_CACHE) == 0\n\t  && (preserve->flags & BFD_IN_MEMORY) == 0)\n\tbfd_open_file (abfd);\n    }\n  abfd->flags = preserve->flags;\n}\nstatic void\n_bfd_delete_bfd (bfd *abfd)\n{\n  /* Give the target _bfd_free_cached_info a chance to free memory.  */\n  if (abfd->memory && abfd->xvec)\n    bfd_free_cached_info (abfd);\n\n  /* The target _bfd_free_cached_info may not have done anything..  */\n  if (abfd->memory)\n    {\n      bfd_hash_table_free (&abfd->section_htab);\n      objalloc_free ((struct objalloc *) abfd->memory);\n    }\n  else\n    free ((char *) bfd_get_filename (abfd));\n\n  if ((abfd->flags & BFD_IN_MEMORY) != 0)\n    free (abfd->iostream);\n  free (abfd->arelt_data);\n  free (abfd);\n}\n",
    "target": 1,
    "idx": 1065105,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "// context\nstatic int\nxmlXIncludeIncludeNode(xmlXIncludeCtxtPtr ctxt, int nr) {\n    xmlNodePtr cur, end, list, tmp;\n\n    if (ctxt == NULL)\n\treturn(-1);\n    if ((nr < 0) || (nr >= ctxt->incNr))\n\treturn(-1);\n    cur = ctxt->incTab[nr]->ref;\n    if ((cur == NULL) || (cur->type == XML_NAMESPACE_DECL))\n\treturn(-1);\n\n    /*\n     * If we stored an XPointer a late computation may be needed\n     */\n    if ((ctxt->incTab[nr]->inc == NULL) &&\n\t(ctxt->incTab[nr]->xptr != NULL)) {\n\tctxt->incTab[nr]->inc =\n\t    xmlXIncludeCopyXPointer(ctxt, ctxt->doc, ctxt->doc,\n\t\t                    ctxt->incTab[nr]->xptr);\n\txmlXPathFreeObject(ctxt->incTab[nr]->xptr);\n\tctxt->incTab[nr]->xptr = NULL;\n    }\n    list = ctxt->incTab[nr]->inc;\n    ctxt->incTab[nr]->inc = NULL;\n\n    /*\n     * Check against the risk of generating a multi-rooted document\n     */\n    if ((cur->parent != NULL) &&\n\t(cur->parent->type != XML_ELEMENT_NODE)) {\n\tint nb_elem = 0;\n\n\ttmp = list;\n\twhile (tmp != NULL) {\n\t    if (tmp->type == XML_ELEMENT_NODE)\n\t\tnb_elem++;\n\t    tmp = tmp->next;\n\t}\n\tif (nb_elem > 1) {\n\t    xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t                   XML_XINCLUDE_MULTIPLE_ROOT,\n\t\t       \"XInclude error: would result in multiple root nodes\\n\",\n\t\t\t   NULL);\n            xmlFreeNodeList(list);\n\t    return(-1);\n\t}\n    }\n\n    if (ctxt->parseFlags & XML_PARSE_NOXINCNODE) {\n\t/*\n\t * Add the list of nodes\n\t */\n\twhile (list != NULL) {\n\t    end = list;\n\t    list = list->next;\n\n\t    xmlAddPrevSibling(cur, end);\n\t}\n\txmlUnlinkNode(cur);\n\txmlFreeNode(cur);\n    } else {\n        xmlNodePtr child, next;\n\n\t/*\n\t * Change the current node as an XInclude start one, and add an\n\t * XInclude end one\n\t */\n\tcur->type = XML_XINCLUDE_START;\n        /* Remove fallback children */\n        for (child = cur->children; child != NULL; child = next) {\n            next = child->next;\n            xmlUnlinkNode(child);\n            xmlFreeNode(child);\n        }\n\tend = xmlNewDocNode(cur->doc, cur->ns, cur->name, NULL);\n\tif (end == NULL) {\n\t    xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t                   XML_XINCLUDE_BUILD_FAILED,\n\t\t\t   \"failed to build node\\n\", NULL);\n            xmlFreeNodeList(list);\n\t    return(-1);\n\t}\n\tend->type = XML_XINCLUDE_END;\n\txmlAddNextSibling(cur, end);\n\n\t/*\n\t * Add the list of nodes\n\t */\n\twhile (list != NULL) {\n\t    cur = list;\n\t    list = list->next;\n\n\t    xmlAddPrevSibling(end, cur);\n\t}\n    }\n\n\n    return(0);\n}\n\nstatic int\nxmlXIncludeDoProcess(xmlXIncludeCtxtPtr ctxt, xmlDocPtr doc, xmlNodePtr tree,\n                     int skipRoot) {\n    xmlNodePtr cur;\n    int ret = 0;\n    int i, start;\n\n    if ((doc == NULL) || (tree == NULL) || (tree->type == XML_NAMESPACE_DECL))\n\treturn(-1);\n    if ((skipRoot) && (tree->children == NULL))\n        return(-1);\n    if (ctxt == NULL)\n\treturn(-1);\n\n    if (doc->URL != NULL) {\n\tret = xmlXIncludeURLPush(ctxt, doc->URL);\n\tif (ret < 0)\n\t    return(-1);\n    }\n    start = ctxt->incNr;\n\n    /*\n     * First phase: lookup the elements in the document\n     */\n    if (skipRoot)\n        cur = tree->children;\n    else\n        cur = tree;\n    do {\n\t/* TODO: need to work on entities -> stack */\n        if (xmlXIncludeTestNode(ctxt, cur) == 1) {\n#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n            /*\n             * Avoid superlinear expansion by limiting the total number\n             * of replacements.\n             */\n            if (ctxt->incTotal >= 20)\n                return(-1);\n#endif\n            ctxt->incTotal++;\n            xmlXIncludePreProcessNode(ctxt, cur);\n        } else if ((cur->children != NULL) &&\n                   (cur->children->type != XML_ENTITY_DECL) &&\n                   (cur->children->type != XML_XINCLUDE_START) &&\n                   (cur->children->type != XML_XINCLUDE_END)) {\n            cur = cur->children;\n            continue;\n        }\n        do {\n            if (cur == tree)\n                break;\n            if (cur->next != NULL) {\n                cur = cur->next;\n                break;\n            }\n            cur = cur->parent;\n        } while (cur != NULL);\n    } while ((cur != NULL) && (cur != tree));\n\n    /*\n     * Second Phase : collect the infosets fragments\n     */\n    for (i = start;i < ctxt->incNr; i++) {\n        xmlXIncludeLoadNode(ctxt, i);\n\tret++;\n    }\n\n    /*\n     * Third phase: extend the original document infoset.\n     *\n     * Originally we bypassed the inclusion if there were any errors\n     * encountered on any of the XIncludes.  A bug was raised (bug\n     * 132588) requesting that we output the XIncludes without error,\n     * so the check for inc!=NULL || xptr!=NULL was put in.  This may\n     * give some other problems in the future, but for now it seems to\n     * work ok.\n     *\n     */\n    for (i = ctxt->incBase;i < ctxt->incNr; i++) {\n\tif ((ctxt->incTab[i]->inc != NULL) ||\n\t\t(ctxt->incTab[i]->xptr != NULL) ||\n\t\t(ctxt->incTab[i]->emptyFb != 0))\t/* (empty fallback) */\n\t    xmlXIncludeIncludeNode(ctxt, i);\n    }\n\n    if (doc->URL != NULL)\n\txmlXIncludeURLPop(ctxt);\n    return(ret);\n}\n\nstatic int\nxmlXIncludeLoadFallback(xmlXIncludeCtxtPtr ctxt, xmlNodePtr fallback, int nr) {\n    xmlXIncludeCtxtPtr newctxt;\n    int ret = 0;\n    int oldNbErrors = ctxt->nbErrors;\n\n    if ((fallback == NULL) || (fallback->type == XML_NAMESPACE_DECL) ||\n        (ctxt == NULL))\n\treturn(-1);\n    if (fallback->children != NULL) {\n\t/*\n\t * It's possible that the fallback also has 'includes'\n\t * (Bug 129969), so we re-process the fallback just in case\n\t */\n\tnewctxt = xmlXIncludeNewContext(ctxt->doc);\n\tif (newctxt == NULL)\n\t    return (-1);\n\tnewctxt->_private = ctxt->_private;\n\tnewctxt->base = xmlStrdup(ctxt->base);\t/* Inherit the base from the existing context */\n\txmlXIncludeSetFlags(newctxt, ctxt->parseFlags);\n        newctxt->incTotal = ctxt->incTotal;\n        if (xmlXIncludeDoProcess(newctxt, ctxt->doc, fallback, 1) < 0)\n            ret = -1;\n        ctxt->incTotal = newctxt->incTotal;\n\tif (ctxt->nbErrors > oldNbErrors)\n\t    ret = -1;\n\txmlXIncludeFreeContext(newctxt);\n\n\tctxt->incTab[nr]->inc = xmlDocCopyNodeList(ctxt->doc,\n\t                                           fallback->children);\n    } else {\n        ctxt->incTab[nr]->inc = NULL;\n\tctxt->incTab[nr]->emptyFb = 1;\t/* flag empty callback */\n    }\n    return(ret);\n}\n\nstatic int\nxmlXIncludeLoadNode(xmlXIncludeCtxtPtr ctxt, int nr) {\n    xmlNodePtr cur;\n    xmlChar *href;\n    xmlChar *parse;\n    xmlChar *base;\n    xmlChar *oldBase;\n    xmlChar *URI;\n    int xml = 1; /* default Issue 64 */\n    int ret;\n\n    if (ctxt == NULL)\n\treturn(-1);\n    if ((nr < 0) || (nr >= ctxt->incNr))\n\treturn(-1);\n    cur = ctxt->incTab[nr]->ref;\n    if (cur == NULL)\n\treturn(-1);\n\n    /*\n     * read the attributes\n     */\n    href = xmlXIncludeGetProp(ctxt, cur, XINCLUDE_HREF);\n    if (href == NULL) {\n\thref = xmlStrdup(BAD_CAST \"\"); /* @@@@ href is now optional */\n\tif (href == NULL)\n\t    return(-1);\n    }\n    parse = xmlXIncludeGetProp(ctxt, cur, XINCLUDE_PARSE);\n    if (parse != NULL) {\n\tif (xmlStrEqual(parse, XINCLUDE_PARSE_XML))\n\t    xml = 1;\n\telse if (xmlStrEqual(parse, XINCLUDE_PARSE_TEXT))\n\t    xml = 0;\n\telse {\n\t    xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t                   XML_XINCLUDE_PARSE_VALUE,\n\t\t\t   \"invalid value %s for 'parse'\\n\", parse);\n\t    if (href != NULL)\n\t\txmlFree(href);\n\t    if (parse != NULL)\n\t\txmlFree(parse);\n\t    return(-1);\n\t}\n    }\n\n    /*\n     * compute the URI\n     */\n    base = xmlNodeGetBase(ctxt->doc, cur);\n    if (base == NULL) {\n\tURI = xmlBuildURI(href, ctxt->doc->URL);\n    } else {\n\tURI = xmlBuildURI(href, base);\n    }\n    if (URI == NULL) {\n\txmlChar *escbase;\n\txmlChar *eschref;\n\t/*\n\t * Some escaping may be needed\n\t */\n\tescbase = xmlURIEscape(base);\n\teschref = xmlURIEscape(href);\n\tURI = xmlBuildURI(eschref, escbase);\n\tif (escbase != NULL)\n\t    xmlFree(escbase);\n\tif (eschref != NULL)\n\t    xmlFree(eschref);\n    }\n    if (URI == NULL) {\n\txmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t               XML_XINCLUDE_HREF_URI, \"failed build URL\\n\", NULL);\n\tif (parse != NULL)\n\t    xmlFree(parse);\n\tif (href != NULL)\n\t    xmlFree(href);\n\tif (base != NULL)\n\t    xmlFree(base);\n\treturn(-1);\n    }\n#ifdef DEBUG_XINCLUDE\n    xmlGenericError(xmlGenericErrorContext, \"parse: %s\\n\",\n\t    xml ? \"xml\": \"text\");\n    xmlGenericError(xmlGenericErrorContext, \"URI: %s\\n\", URI);\n#endif\n\n    /*\n     * Save the base for this include (saving the current one)\n     */\n    oldBase = ctxt->base;\n    ctxt->base = base;\n\n    if (xml) {\n\tret = xmlXIncludeLoadDoc(ctxt, URI, nr);\n\t/* xmlXIncludeGetFragment(ctxt, cur, URI); */\n    } else {\n\tret = xmlXIncludeLoadTxt(ctxt, URI, nr);\n    }\n\n    /*\n     * Restore the original base before checking for fallback\n     */\n    ctxt->base = oldBase;\n\n    if (ret < 0) {\n\txmlNodePtr children;\n\n\t/*\n\t * Time to try a fallback if available\n\t */\n#ifdef DEBUG_XINCLUDE\n\txmlGenericError(xmlGenericErrorContext, \"error looking for fallback\\n\");\n#endif\n\tchildren = cur->children;\n\twhile (children != NULL) {\n\t    if ((children->type == XML_ELEMENT_NODE) &&\n\t\t(children->ns != NULL) &&\n\t\t(xmlStrEqual(children->name, XINCLUDE_FALLBACK)) &&\n\t\t((xmlStrEqual(children->ns->href, XINCLUDE_NS)) ||\n\t\t (xmlStrEqual(children->ns->href, XINCLUDE_OLD_NS)))) {\n\t\tret = xmlXIncludeLoadFallback(ctxt, children, nr);\n\t\tif (ret == 0)\n\t\t    break;\n\t    }\n\t    children = children->next;\n\t}\n    }\n    if (ret < 0) {\n\txmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t               XML_XINCLUDE_NO_FALLBACK,\n\t\t       \"could not load %s, and no fallback was found\\n\",\n\t\t       URI);\n    }\n\n    /*\n     * Cleanup\n     */\n    if (URI != NULL)\n\txmlFree(URI);\n    if (parse != NULL)\n\txmlFree(parse);\n    if (href != NULL)\n\txmlFree(href);\n    if (base != NULL)\n\txmlFree(base);\n    return(0);\n}\n\nstatic int\nxmlXIncludeDoProcess(xmlXIncludeCtxtPtr ctxt, xmlDocPtr doc, xmlNodePtr tree,\n                     int skipRoot) {\n    xmlNodePtr cur;\n    int ret = 0;\n    int i, start;\n\n    if ((doc == NULL) || (tree == NULL) || (tree->type == XML_NAMESPACE_DECL))\n\treturn(-1);\n    if ((skipRoot) && (tree->children == NULL))\n        return(-1);\n    if (ctxt == NULL)\n\treturn(-1);\n\n    if (doc->URL != NULL) {\n\tret = xmlXIncludeURLPush(ctxt, doc->URL);\n\tif (ret < 0)\n\t    return(-1);\n    }\n    start = ctxt->incNr;\n\n    /*\n     * First phase: lookup the elements in the document\n     */\n    if (skipRoot)\n        cur = tree->children;\n    else\n        cur = tree;\n    do {\n\t/* TODO: need to work on entities -> stack */\n        if (xmlXIncludeTestNode(ctxt, cur) == 1) {\n#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n            /*\n             * Avoid superlinear expansion by limiting the total number\n             * of replacements.\n             */\n            if (ctxt->incTotal >= 20)\n                return(-1);\n#endif\n            ctxt->incTotal++;\n            xmlXIncludePreProcessNode(ctxt, cur);\n        } else if ((cur->children != NULL) &&\n                   (cur->children->type != XML_ENTITY_DECL) &&\n                   (cur->children->type != XML_XINCLUDE_START) &&\n                   (cur->children->type != XML_XINCLUDE_END)) {\n            cur = cur->children;\n            continue;\n        }\n        do {\n            if (cur == tree)\n                break;\n            if (cur->next != NULL) {\n                cur = cur->next;\n                break;\n            }\n            cur = cur->parent;\n        } while (cur != NULL);\n    } while ((cur != NULL) && (cur != tree));\n\n    /*\n     * Second Phase : collect the infosets fragments\n     */\n    for (i = start;i < ctxt->incNr; i++) {\n        xmlXIncludeLoadNode(ctxt, i);\n\tret++;\n    }\n\n    /*\n     * Third phase: extend the original document infoset.\n     *\n     * Originally we bypassed the inclusion if there were any errors\n     * encountered on any of the XIncludes.  A bug was raised (bug\n     * 132588) requesting that we output the XIncludes without error,\n     * so the check for inc!=NULL || xptr!=NULL was put in.  This may\n     * give some other problems in the future, but for now it seems to\n     * work ok.\n     *\n     */\n    for (i = ctxt->incBase;i < ctxt->incNr; i++) {\n\tif ((ctxt->incTab[i]->inc != NULL) ||\n\t\t(ctxt->incTab[i]->xptr != NULL) ||\n\t\t(ctxt->incTab[i]->emptyFb != 0))\t/* (empty fallback) */\n\t    xmlXIncludeIncludeNode(ctxt, i);\n    }\n\n    if (doc->URL != NULL)\n\txmlXIncludeURLPop(ctxt);\n    return(ret);\n}\n\nint\nxmlXIncludeProcessTreeFlagsData(xmlNodePtr tree, int flags, void *data) {\n    xmlXIncludeCtxtPtr ctxt;\n    int ret = 0;\n\n    if ((tree == NULL) || (tree->type == XML_NAMESPACE_DECL) ||\n        (tree->doc == NULL))\n        return(-1);\n\n    ctxt = xmlXIncludeNewContext(tree->doc);\n    if (ctxt == NULL)\n        return(-1);\n    ctxt->_private = data;\n    ctxt->base = xmlStrdup((xmlChar *)tree->doc->URL);\n    xmlXIncludeSetFlags(ctxt, flags);\n    ret = xmlXIncludeDoProcess(ctxt, tree->doc, tree, 0);\n    if ((ret >= 0) && (ctxt->nbErrors > 0))\n        ret = -1;\n\n    xmlXIncludeFreeContext(ctxt);\n    return(ret);\n}\n\nint\nxmlXIncludeProcessFlagsData(xmlDocPtr doc, int flags, void *data) {\n    xmlNodePtr tree;\n\n    if (doc == NULL)\n\treturn(-1);\n    tree = xmlDocGetRootElement(doc);\n    if (tree == NULL)\n\treturn(-1);\n    return(xmlXIncludeProcessTreeFlagsData(tree, flags, data));\n}\n\nint\nxmlXIncludeProcessFlags(xmlDocPtr doc, int flags) {\n    return xmlXIncludeProcessFlagsData(doc, flags, NULL);\n}\n\n\n// target function\nstatic void\nxmlXIncludeRecurseDoc(xmlXIncludeCtxtPtr ctxt, xmlDocPtr doc,\n\t              const xmlURL url ATTRIBUTE_UNUSED) {\n    xmlXIncludeCtxtPtr newctxt;\n    int i;\n\n    /*\n     * Avoid recursion in already substituted resources\n    for (i = 0;i < ctxt->urlNr;i++) {\n\tif (xmlStrEqual(doc->URL, ctxt->urlTab[i]))\n\t    return;\n    }\n     */\n\n#ifdef DEBUG_XINCLUDE\n    xmlGenericError(xmlGenericErrorContext, \"Recursing in doc %s\\n\", doc->URL);\n#endif\n    /*\n     * Handle recursion here.\n     */\n\n    newctxt = xmlXIncludeNewContext(doc);\n    if (newctxt != NULL) {\n\t/*\n\t * Copy the private user data\n\t */\n\tnewctxt->_private = ctxt->_private;\n\t/*\n\t * Copy the existing document set\n\t */\n\tnewctxt->incMax = ctxt->incMax;\n\tnewctxt->incNr = ctxt->incNr;\n        newctxt->incTab = (xmlXIncludeRefPtr *) xmlMalloc(newctxt->incMax *\n\t\t                          sizeof(newctxt->incTab[0]));\n        if (newctxt->incTab == NULL) {\n\t    xmlXIncludeErrMemory(ctxt, (xmlNodePtr) doc, \"processing doc\");\n\t    xmlFree(newctxt);\n\t    return;\n\t}\n\t/*\n\t * copy the urlTab\n\t */\n\tnewctxt->urlMax = ctxt->urlMax;\n\tnewctxt->urlNr = ctxt->urlNr;\n\tnewctxt->urlTab = ctxt->urlTab;\n\n\t/*\n\t * Inherit the existing base\n\t */\n\tnewctxt->base = xmlStrdup(ctxt->base);\n\n\t/*\n\t * Inherit the documents already in use by other includes\n\t */\n\tnewctxt->incBase = ctxt->incNr;\n\tfor (i = 0;i < ctxt->incNr;i++) {\n\t    newctxt->incTab[i] = ctxt->incTab[i];\n\t    newctxt->incTab[i]->count++; /* prevent the recursion from\n\t\t\t\t\t    freeing it */\n\t}\n\t/*\n\t * The new context should also inherit the Parse Flags\n\t * (bug 132597)\n\t */\n\tnewctxt->parseFlags = ctxt->parseFlags;\n        newctxt->incTotal = ctxt->incTotal;\n\txmlXIncludeDoProcess(newctxt, doc, xmlDocGetRootElement(doc));\n        ctxt->incTotal = newctxt->incTotal;\n\tfor (i = 0;i < ctxt->incNr;i++) {\n\t    newctxt->incTab[i]->count--;\n\t    newctxt->incTab[i] = NULL;\n\t}\n\n\t/* urlTab may have been reallocated */\n\tctxt->urlTab = newctxt->urlTab;\n\tctxt->urlMax = newctxt->urlMax;\n\n\tnewctxt->urlMax = 0;\n\tnewctxt->urlNr = 0;\n\tnewctxt->urlTab = NULL;\n\n\txmlXIncludeFreeContext(newctxt);\n    }\n#ifdef DEBUG_XINCLUDE\n    xmlGenericError(xmlGenericErrorContext, \"Done recursing in doc %s\\n\", url);\n#endif\n}\nstatic int\nxmlXIncludeLoadFallback(xmlXIncludeCtxtPtr ctxt, xmlNodePtr fallback, int nr) {\n    xmlXIncludeCtxtPtr newctxt;\n    int ret = 0;\n    int oldNbErrors = ctxt->nbErrors;\n\n    if ((fallback == NULL) || (fallback->type == XML_NAMESPACE_DECL) ||\n        (ctxt == NULL))\n\treturn(-1);\n    if (fallback->children != NULL) {\n        xmlNodePtr child, next;\n\n\t/*\n\t * It's possible that the fallback also has 'includes'\n\t * (Bug 129969), so we re-process the fallback just in case\n\t */\n\tnewctxt = xmlXIncludeNewContext(ctxt->doc);\n\tif (newctxt == NULL)\n\t    return (-1);\n\tnewctxt->_private = ctxt->_private;\n\tnewctxt->base = xmlStrdup(ctxt->base);\t/* Inherit the base from the existing context */\n\txmlXIncludeSetFlags(newctxt, ctxt->parseFlags);\n        newctxt->incTotal = ctxt->incTotal;\n        for (child = fallback->children; child != NULL; child = next) {\n            next = child->next;\n\t    if (xmlXIncludeDoProcess(newctxt, ctxt->doc, child) < 0)\n                ret = -1;\n        }\n        ctxt->incTotal = newctxt->incTotal;\n\tif (ctxt->nbErrors > oldNbErrors)\n\t    ret = -1;\n\txmlXIncludeFreeContext(newctxt);\n\n\tctxt->incTab[nr]->inc = xmlDocCopyNodeList(ctxt->doc,\n\t                                           fallback->children);\n    } else {\n        ctxt->incTab[nr]->inc = NULL;\n\tctxt->incTab[nr]->emptyFb = 1;\t/* flag empty callback */\n    }\n    return(ret);\n}\nstatic int\nxmlXIncludeDoProcess(xmlXIncludeCtxtPtr ctxt, xmlDocPtr doc, xmlNodePtr tree) {\n    xmlNodePtr cur;\n    int ret = 0;\n    int i, start;\n\n    if ((doc == NULL) || (tree == NULL) || (tree->type == XML_NAMESPACE_DECL))\n\treturn(-1);\n    if (ctxt == NULL)\n\treturn(-1);\n\n    if (doc->URL != NULL) {\n\tret = xmlXIncludeURLPush(ctxt, doc->URL);\n\tif (ret < 0)\n\t    return(-1);\n    }\n    start = ctxt->incNr;\n\n    /*\n     * First phase: lookup the elements in the document\n     */\n    cur = tree;\n    do {\n\t/* TODO: need to work on entities -> stack */\n        if (xmlXIncludeTestNode(ctxt, cur) == 1) {\n#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n            /*\n             * Avoid superlinear expansion by limiting the total number\n             * of replacements.\n             */\n            if (ctxt->incTotal >= 20)\n                return(-1);\n#endif\n            ctxt->incTotal++;\n            xmlXIncludePreProcessNode(ctxt, cur);\n        } else if ((cur->children != NULL) &&\n                   (cur->children->type != XML_ENTITY_DECL) &&\n                   (cur->children->type != XML_XINCLUDE_START) &&\n                   (cur->children->type != XML_XINCLUDE_END)) {\n            cur = cur->children;\n            continue;\n        }\n        do {\n            if (cur == tree)\n                break;\n            if (cur->next != NULL) {\n                cur = cur->next;\n                break;\n            }\n            cur = cur->parent;\n        } while (cur != NULL);\n    } while ((cur != NULL) && (cur != tree));\n\n    /*\n     * Second Phase : collect the infosets fragments\n     */\n    for (i = start;i < ctxt->incNr; i++) {\n        xmlXIncludeLoadNode(ctxt, i);\n\tret++;\n    }\n\n    /*\n     * Third phase: extend the original document infoset.\n     *\n     * Originally we bypassed the inclusion if there were any errors\n     * encountered on any of the XIncludes.  A bug was raised (bug\n     * 132588) requesting that we output the XIncludes without error,\n     * so the check for inc!=NULL || xptr!=NULL was put in.  This may\n     * give some other problems in the future, but for now it seems to\n     * work ok.\n     *\n     */\n    for (i = ctxt->incBase;i < ctxt->incNr; i++) {\n\tif ((ctxt->incTab[i]->inc != NULL) ||\n\t\t(ctxt->incTab[i]->xptr != NULL) ||\n\t\t(ctxt->incTab[i]->emptyFb != 0))\t/* (empty fallback) */\n\t    xmlXIncludeIncludeNode(ctxt, i);\n    }\n\n    if (doc->URL != NULL)\n\txmlXIncludeURLPop(ctxt);\n    return(ret);\n}\nint\nxmlXIncludeProcessTreeFlagsData(xmlNodePtr tree, int flags, void *data) {\n    xmlXIncludeCtxtPtr ctxt;\n    int ret = 0;\n\n    if ((tree == NULL) || (tree->type == XML_NAMESPACE_DECL) ||\n        (tree->doc == NULL))\n        return(-1);\n\n    ctxt = xmlXIncludeNewContext(tree->doc);\n    if (ctxt == NULL)\n        return(-1);\n    ctxt->_private = data;\n    ctxt->base = xmlStrdup((xmlChar *)tree->doc->URL);\n    xmlXIncludeSetFlags(ctxt, flags);\n    ret = xmlXIncludeDoProcess(ctxt, tree->doc, tree);\n    if ((ret >= 0) && (ctxt->nbErrors > 0))\n        ret = -1;\n\n    xmlXIncludeFreeContext(ctxt);\n    return(ret);\n}\nint\nxmlXIncludeProcessTreeFlags(xmlNodePtr tree, int flags) {\n    xmlXIncludeCtxtPtr ctxt;\n    int ret = 0;\n\n    if ((tree == NULL) || (tree->type == XML_NAMESPACE_DECL) ||\n        (tree->doc == NULL))\n\treturn(-1);\n    ctxt = xmlXIncludeNewContext(tree->doc);\n    if (ctxt == NULL)\n\treturn(-1);\n    ctxt->base = xmlNodeGetBase(tree->doc, tree);\n    xmlXIncludeSetFlags(ctxt, flags);\n    ret = xmlXIncludeDoProcess(ctxt, tree->doc, tree);\n    if ((ret >= 0) && (ctxt->nbErrors > 0))\n\tret = -1;\n\n    xmlXIncludeFreeContext(ctxt);\n    return(ret);\n}\nint\nxmlXIncludeProcessNode(xmlXIncludeCtxtPtr ctxt, xmlNodePtr node) {\n    int ret = 0;\n\n    if ((node == NULL) || (node->type == XML_NAMESPACE_DECL) ||\n        (node->doc == NULL) || (ctxt == NULL))\n\treturn(-1);\n    ret = xmlXIncludeDoProcess(ctxt, node->doc, node);\n    if ((ret >= 0) && (ctxt->nbErrors > 0))\n\tret = -1;\n    return(ret);\n}\n",
    "target": 1,
    "idx": 1024925,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nvoid cil_destroy_block(struct cil_block *block)\n{\n\tstruct cil_list_item *item;\n\tstruct cil_tree_node *bi_node;\n\tstruct cil_blockinherit *inherit;\n\n\tif (block == NULL) {\n\t\treturn;\n\t}\n\n\tcil_symtab_datum_destroy(&block->datum);\n\tcil_symtab_array_destroy(block->symtab);\n\tif (block->bi_nodes != NULL) {\n\t\t/* unlink blockinherit->block */\n\t\tcil_list_for_each(item, block->bi_nodes) {\n\t\t\tbi_node = item->data;\n\t\t\t/* the conditions should always be true, but better be sure */\n\t\t\tif (bi_node->flavor == CIL_BLOCKINHERIT) {\n\t\t\t\tinherit = bi_node->data;\n\t\t\t\tif (inherit->block == block) {\n\t\t\t\t\tinherit->block = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcil_list_destroy(&block->bi_nodes, CIL_FALSE);\n\t}\n\n\tfree(block);\n}\n\n\n\nvoid cil_tree_subtree_destroy(struct cil_tree_node *node)\n{\n\tcil_tree_children_destroy(node);\n\tcil_tree_node_destroy(&node);\n}\n\nvoid cil_tree_destroy(struct cil_tree **tree)\n{\n\tif (tree == NULL || *tree == NULL) {\n\t\treturn;\n\t}\n\n\tcil_tree_subtree_destroy((*tree)->root);\n\tfree(*tree);\n\t*tree = NULL;\n}\n\nvoid cil_db_destroy(struct cil_db **db)\n{\n\tif (db == NULL || *db == NULL) {\n\t\treturn;\n\t}\n\n\tcil_tree_destroy(&(*db)->parse);\n\tcil_tree_destroy(&(*db)->ast);\n\tcil_list_destroy(&(*db)->sidorder, CIL_FALSE);\n\tcil_list_destroy(&(*db)->classorder, CIL_FALSE);\n\tcil_list_destroy(&(*db)->catorder, CIL_FALSE);\n\tcil_list_destroy(&(*db)->sensitivityorder, CIL_FALSE);\n\tcil_sort_destroy(&(*db)->netifcon);\n\tcil_sort_destroy(&(*db)->genfscon);\n\tcil_sort_destroy(&(*db)->filecon);\n\tcil_sort_destroy(&(*db)->nodecon);\n\tcil_sort_destroy(&(*db)->ibpkeycon);\n\tcil_sort_destroy(&(*db)->ibendportcon);\n\tcil_sort_destroy(&(*db)->portcon);\n\tcil_sort_destroy(&(*db)->pirqcon);\n\tcil_sort_destroy(&(*db)->iomemcon);\n\tcil_sort_destroy(&(*db)->ioportcon);\n\tcil_sort_destroy(&(*db)->pcidevicecon);\n\tcil_sort_destroy(&(*db)->devicetreecon);\n\tcil_sort_destroy(&(*db)->fsuse);\n\tcil_list_destroy(&(*db)->userprefixes, CIL_FALSE);\n\tcil_list_destroy(&(*db)->selinuxusers, CIL_FALSE);\n\tcil_list_destroy(&(*db)->names, CIL_TRUE);\n\n\tcil_destroy_type((*db)->selftype);\n\n\tcil_strpool_destroy();\n\tfree((*db)->val_to_type);\n\tfree((*db)->val_to_role);\n\tfree((*db)->val_to_user);\n\n\tfree(*db);\n\t*db = NULL;\t\n}\n\n\n// target function\nvoid cil_destroy_blockinherit(struct cil_blockinherit *inherit)\n{\n\tif (inherit == NULL) {\n\t\treturn;\n\t}\n\n\tfree(inherit);\n}\n",
    "target": 1,
    "idx": 1030234,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nvoid timelib_error_container_dtor(timelib_error_container *errors)\n{\n\tint i;\n\n\tfor (i = 0; i < errors->warning_count; i++) {\n\t\ttimelib_free(errors->warning_messages[i].message);\n\t}\n\ttimelib_free(errors->warning_messages);\n\tfor (i = 0; i < errors->error_count; i++) {\n\t\ttimelib_free(errors->error_messages[i].message);\n\t}\n\ttimelib_free(errors->error_messages);\n\ttimelib_free(errors);\n}\n\nstatic void update_errors_warnings(timelib_error_container **last_errors) /* {{{ */\n{\n\tif (DATEG(last_errors)) {\n\t\ttimelib_error_container_dtor(DATEG(last_errors));\n\t\tDATEG(last_errors) = NULL;\n\t}\n\n\tif (last_errors == NULL || (*last_errors) == NULL) {\n\t\treturn;\n\t}\n\n\tif ((*last_errors)->warning_count || (*last_errors)->error_count) {\n\t\tDATEG(last_errors) = *last_errors;\n\t\treturn;\n\t}\n\n\ttimelib_error_container_dtor(*last_errors);\n\t*last_errors = NULL;\n} /* }}} */\n\nPHPAPI bool php_date_initialize(php_date_obj *dateobj, const char *time_str, size_t time_str_len, const char *format, zval *timezone_object, int flags) /* {{{ */\n{\n\ttimelib_time   *now;\n\ttimelib_tzinfo *tzi = NULL;\n\ttimelib_error_container *err = NULL;\n\tint type = TIMELIB_ZONETYPE_ID, new_dst = 0;\n\tchar *new_abbr = NULL;\n\ttimelib_sll new_offset = 0;\n\ttime_t sec;\n\tsuseconds_t usec;\n\tint options = 0;\n\n\tif (dateobj->time) {\n\t\ttimelib_time_dtor(dateobj->time);\n\t}\n\tif (format) {\n\t\tif (time_str_len == 0) {\n\t\t\ttime_str = \"\";\n\t\t}\n\t\tdateobj->time = timelib_parse_from_format(format, time_str, time_str_len, &err, DATE_TIMEZONEDB, php_date_parse_tzfile_wrapper);\n\t} else {\n\t\tif (time_str_len == 0) {\n\t\t\ttime_str = \"now\";\n\t\t\ttime_str_len = sizeof(\"now\") - 1;\n\t\t}\n\t\tdateobj->time = timelib_strtotime(time_str, time_str_len, &err, DATE_TIMEZONEDB, php_date_parse_tzfile_wrapper);\n\t}\n\n\t/* update last errors and warnings */\n\tupdate_errors_warnings(&err);\n\n\t/* If called from a constructor throw an exception */\n\tif ((flags & PHP_DATE_INIT_CTOR) && err && err->error_count) {\n\t\t/* spit out the first library error message, at least */\n\t\tzend_throw_exception_ex(NULL, 0, \"Failed to parse time string (%s) at position %d (%c): %s\", time_str,\n\t\t\terr->error_messages[0].position, err->error_messages[0].character, err->error_messages[0].message);\n\t}\n\tif (err && err->error_count) {\n\t\ttimelib_time_dtor(dateobj->time);\n\t\tdateobj->time = 0;\n\t\treturn 0;\n\t}\n\n\tif (timezone_object) {\n\t\tphp_timezone_obj *tzobj;\n\n\t\ttzobj = Z_PHPTIMEZONE_P(timezone_object);\n\t\tswitch (tzobj->type) {\n\t\t\tcase TIMELIB_ZONETYPE_ID:\n\t\t\t\ttzi = tzobj->tzi.tz;\n\t\t\t\tbreak;\n\t\t\tcase TIMELIB_ZONETYPE_OFFSET:\n\t\t\t\tnew_offset = tzobj->tzi.utc_offset;\n\t\t\t\tbreak;\n\t\t\tcase TIMELIB_ZONETYPE_ABBR:\n\t\t\t\tnew_offset = tzobj->tzi.z.utc_offset;\n\t\t\t\tnew_dst    = tzobj->tzi.z.dst;\n\t\t\t\tnew_abbr   = timelib_strdup(tzobj->tzi.z.abbr);\n\t\t\t\tbreak;\n\t\t}\n\t\ttype = tzobj->type;\n\t} else if (dateobj->time->tz_info) {\n\t\ttzi = dateobj->time->tz_info;\n\t} else {\n\t\ttzi = get_timezone_info();\n\t\tif (!tzi) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tnow = timelib_time_ctor();\n\tnow->zone_type = type;\n\tswitch (type) {\n\t\tcase TIMELIB_ZONETYPE_ID:\n\t\t\tnow->tz_info = tzi;\n\t\t\tbreak;\n\t\tcase TIMELIB_ZONETYPE_OFFSET:\n\t\t\tnow->z = new_offset;\n\t\t\tbreak;\n\t\tcase TIMELIB_ZONETYPE_ABBR:\n\t\t\tnow->z = new_offset;\n\t\t\tnow->dst = new_dst;\n\t\t\tnow->tz_abbr = new_abbr;\n\t\t\tbreak;\n\t}\n\tphp_date_get_current_time_with_fraction(&sec, &usec);\n\ttimelib_unixtime2local(now, (timelib_sll) sec);\n\tphp_date_set_time_fraction(now, usec);\n\n\tif (!format\n\t && time_str_len == sizeof(\"now\") - 1\n\t && memcmp(time_str, \"now\", sizeof(\"now\") - 1) == 0) {\n\t\ttimelib_time_dtor(dateobj->time);\n\t\tdateobj->time = now;\n\t\treturn 1;\n\t}\n\n\toptions = TIMELIB_NO_CLONE;\n\tif (flags & PHP_DATE_INIT_FORMAT) {\n\t\toptions |= TIMELIB_OVERRIDE_TIME;\n\t}\n\ttimelib_fill_holes(dateobj->time, now, options);\n\n\ttimelib_update_ts(dateobj->time, tzi);\n\ttimelib_update_from_sse(dateobj->time);\n\n\tdateobj->time->have_relative = 0;\n\n\ttimelib_time_dtor(now);\n\n\treturn 1;\n} /* }}} */\n\n\n\nZEND_API void execute_internal(zend_execute_data *execute_data, zval *return_value)\n{\n\texecute_data->func->internal_function.handler(execute_data, return_value);\n}\n\nstatic void fuzzer_execute_internal(zend_execute_data *execute_data, zval *return_value) {\n\tfuzzer_step();\n\n\tuint32_t num_args = ZEND_CALL_NUM_ARGS(execute_data);\n\tfor (uint32_t i = 0; i < num_args; i++) {\n\t\t/* Some internal functions like preg_replace() may be slow on large inputs.\n\t\t * Limit the maximum size of string inputs. */\n\t\tzval *arg = ZEND_CALL_VAR_NUM(execute_data, i);\n\t\tif (Z_TYPE_P(arg) == IS_STRING && Z_STRLEN_P(arg) > MAX_SIZE) {\n\t\t\tfuzzer_bailout();\n\t\t}\n\t}\n\n\torig_execute_internal(execute_data, return_value);\n}\n\nstatic void fuzzer_execute_ex(zend_execute_data *execute_data) {\n\twhile (1) {\n\t\tint ret;\n\t\tfuzzer_step();\n\t\tif ((ret = ((opcode_handler_t) EX(opline)->handler)(execute_data)) != 0) {\n\t\t\tif (ret > 0) {\n\t\t\t\texecute_data = EG(current_execute_data);\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\nzend_result zend_call_function(zend_fcall_info *fci, zend_fcall_info_cache *fci_cache) /* {{{ */\n{\n\tuint32_t i;\n\tzend_execute_data *call;\n\tzend_fcall_info_cache fci_cache_local;\n\tzend_function *func;\n\tuint32_t call_info;\n\tvoid *object_or_called_scope;\n\tzend_class_entry *orig_fake_scope;\n\n\tZVAL_UNDEF(fci->retval);\n\n\tif (!EG(active)) {\n\t\treturn FAILURE; /* executor is already inactive */\n\t}\n\n\tif (EG(exception)) {\n\t\tif (fci_cache) {\n\t\t\tzend_release_fcall_info_cache(fci_cache);\n\t\t}\n\t\treturn SUCCESS; /* we would result in an instable executor otherwise */\n\t}\n\n\tZEND_ASSERT(fci->size == sizeof(zend_fcall_info));\n\n\tif (!fci_cache || !fci_cache->function_handler) {\n\t\tchar *error = NULL;\n\n\t\tif (!fci_cache) {\n\t\t\tfci_cache = &fci_cache_local;\n\t\t}\n\n\t\tif (!zend_is_callable_ex(&fci->function_name, fci->object, 0, NULL, fci_cache, &error)) {\n\t\t\tZEND_ASSERT(error && \"Should have error if not callable\");\n\t\t\tzend_string *callable_name\n\t\t\t\t= zend_get_callable_name_ex(&fci->function_name, fci->object);\n\t\t\tzend_throw_error(NULL, \"Invalid callback %s, %s\", ZSTR_VAL(callable_name), error);\n\t\t\tefree(error);\n\t\t\tzend_string_release_ex(callable_name, 0);\n\t\t\treturn SUCCESS;\n\t\t}\n\n\t\tZEND_ASSERT(!error);\n\t}\n\n\tfunc = fci_cache->function_handler;\n\tif ((func->common.fn_flags & ZEND_ACC_STATIC) || !fci_cache->object) {\n\t\tobject_or_called_scope = fci_cache->called_scope;\n\t\tcall_info = ZEND_CALL_TOP_FUNCTION | ZEND_CALL_DYNAMIC;\n\t} else {\n\t\tobject_or_called_scope = fci_cache->object;\n\t\tcall_info = ZEND_CALL_TOP_FUNCTION | ZEND_CALL_DYNAMIC | ZEND_CALL_HAS_THIS;\n\t}\n\n\tcall = zend_vm_stack_push_call_frame(call_info,\n\t\tfunc, fci->param_count, object_or_called_scope);\n\n\tif (UNEXPECTED(func->common.fn_flags & ZEND_ACC_DEPRECATED)) {\n\t\tzend_deprecated_function(func);\n\n\t\tif (UNEXPECTED(EG(exception))) {\n\t\t\tzend_vm_stack_free_call_frame(call);\n\t\t\treturn SUCCESS;\n\t\t}\n\t}\n\n\tfor (i=0; i<fci->param_count; i++) {\n\t\tzval *param = ZEND_CALL_ARG(call, i+1);\n\t\tzval *arg = &fci->params[i];\n\t\tbool must_wrap = 0;\n\t\tif (UNEXPECTED(Z_ISUNDEF_P(arg))) {\n\t\t\t/* Allow forwarding undef slots. This is only used by Closure::__invoke(). */\n\t\t\tZVAL_UNDEF(param);\n\t\t\tZEND_ADD_CALL_FLAG(call, ZEND_CALL_MAY_HAVE_UNDEF);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ARG_SHOULD_BE_SENT_BY_REF(func, i + 1)) {\n\t\t\tif (UNEXPECTED(!Z_ISREF_P(arg))) {\n\t\t\t\tif (!ARG_MAY_BE_SENT_BY_REF(func, i + 1)) {\n\t\t\t\t\t/* By-value send is not allowed -- emit a warning,\n\t\t\t\t\t * and perform the call with the value wrapped in a reference. */\n\t\t\t\t\tzend_param_must_be_ref(func, i + 1);\n\t\t\t\t\tmust_wrap = 1;\n\t\t\t\t\tif (UNEXPECTED(EG(exception))) {\n\t\t\t\t\t\tZEND_CALL_NUM_ARGS(call) = i;\ncleanup_args:\n\t\t\t\t\t\tzend_vm_stack_free_args(call);\n\t\t\t\t\t\tzend_vm_stack_free_call_frame(call);\n\t\t\t\t\t\treturn SUCCESS;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (Z_ISREF_P(arg) &&\n\t\t\t    !(func->common.fn_flags & ZEND_ACC_CALL_VIA_TRAMPOLINE)) {\n\t\t\t\t/* don't separate references for __call */\n\t\t\t\targ = Z_REFVAL_P(arg);\n\t\t\t}\n\t\t}\n\n\t\tif (EXPECTED(!must_wrap)) {\n\t\t\tZVAL_COPY(param, arg);\n\t\t} else {\n\t\t\tZ_TRY_ADDREF_P(arg);\n\t\t\tZVAL_NEW_REF(param, arg);\n\t\t}\n\t}\n\n\tif (fci->named_params) {\n\t\tzend_string *name;\n\t\tzval *arg;\n\t\tuint32_t arg_num = ZEND_CALL_NUM_ARGS(call) + 1;\n\t\tbool have_named_params = 0;\n\t\tZEND_HASH_FOREACH_STR_KEY_VAL(fci->named_params, name, arg) {\n\t\t\tbool must_wrap = 0;\n\t\t\tzval *target;\n\t\t\tif (name) {\n\t\t\t\tvoid *cache_slot[2] = {NULL, NULL};\n\t\t\t\thave_named_params = 1;\n\t\t\t\ttarget = zend_handle_named_arg(&call, name, &arg_num, cache_slot);\n\t\t\t\tif (!target) {\n\t\t\t\t\tgoto cleanup_args;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (have_named_params) {\n\t\t\t\t\tzend_throw_error(NULL,\n\t\t\t\t\t\t\"Cannot use positional argument after named argument\");\n\t\t\t\t\tgoto cleanup_args;\n\t\t\t\t}\n\n\t\t\t\tzend_vm_stack_extend_call_frame(&call, arg_num - 1, 1);\n\t\t\t\ttarget = ZEND_CALL_ARG(call, arg_num);\n\t\t\t}\n\n\t\t\tif (ARG_SHOULD_BE_SENT_BY_REF(func, arg_num)) {\n\t\t\t\tif (UNEXPECTED(!Z_ISREF_P(arg))) {\n\t\t\t\t\tif (!ARG_MAY_BE_SENT_BY_REF(func, arg_num)) {\n\t\t\t\t\t\t/* By-value send is not allowed -- emit a warning,\n\t\t\t\t\t\t * and perform the call with the value wrapped in a reference. */\n\t\t\t\t\t\tzend_param_must_be_ref(func, arg_num);\n\t\t\t\t\t\tmust_wrap = 1;\n\t\t\t\t\t\tif (UNEXPECTED(EG(exception))) {\n\t\t\t\t\t\t\tgoto cleanup_args;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (Z_ISREF_P(arg) &&\n\t\t\t\t\t!(func->common.fn_flags & ZEND_ACC_CALL_VIA_TRAMPOLINE)) {\n\t\t\t\t\t/* don't separate references for __call */\n\t\t\t\t\targ = Z_REFVAL_P(arg);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (EXPECTED(!must_wrap)) {\n\t\t\t\tZVAL_COPY(target, arg);\n\t\t\t} else {\n\t\t\t\tZ_TRY_ADDREF_P(arg);\n\t\t\t\tZVAL_NEW_REF(target, arg);\n\t\t\t}\n\t\t\tif (!name) {\n\t\t\t\tZEND_CALL_NUM_ARGS(call)++;\n\t\t\t\targ_num++;\n\t\t\t}\n\t\t} ZEND_HASH_FOREACH_END();\n\t}\n\n\tif (UNEXPECTED(ZEND_CALL_INFO(call) & ZEND_CALL_MAY_HAVE_UNDEF)) {\n\t\tif (zend_handle_undef_args(call) == FAILURE) {\n\t\t\tzend_vm_stack_free_args(call);\n\t\t\tzend_vm_stack_free_call_frame(call);\n\t\t\treturn SUCCESS;\n\t\t}\n\t}\n\n\tif (UNEXPECTED(func->op_array.fn_flags & ZEND_ACC_CLOSURE)) {\n\t\tuint32_t call_info;\n\n\t\tGC_ADDREF(ZEND_CLOSURE_OBJECT(func));\n\t\tcall_info = ZEND_CALL_CLOSURE;\n\t\tif (func->common.fn_flags & ZEND_ACC_FAKE_CLOSURE) {\n\t\t\tcall_info |= ZEND_CALL_FAKE_CLOSURE;\n\t\t}\n\t\tZEND_ADD_CALL_FLAG(call, call_info);\n\t}\n\n\tif (func->common.fn_flags & ZEND_ACC_CALL_VIA_TRAMPOLINE) {\n\t\tfci_cache->function_handler = NULL;\n\t}\n\n\torig_fake_scope = EG(fake_scope);\n\tEG(fake_scope) = NULL;\n\tif (func->type == ZEND_USER_FUNCTION) {\n\t\tuint32_t orig_jit_trace_num = EG(jit_trace_num);\n\n\t\tzend_init_func_execute_data(call, &func->op_array, fci->retval);\n\t\tZEND_OBSERVER_FCALL_BEGIN(call);\n\t\tzend_execute_ex(call);\n\t\tEG(jit_trace_num) = orig_jit_trace_num;\n\t} else {\n\t\tZEND_ASSERT(func->type == ZEND_INTERNAL_FUNCTION);\n\t\tZVAL_NULL(fci->retval);\n\t\tcall->prev_execute_data = EG(current_execute_data);\n\t\tEG(current_execute_data) = call;\n#if ZEND_DEBUG\n\t\tbool should_throw = zend_internal_call_should_throw(func, call);\n#endif\n\t\tZEND_OBSERVER_FCALL_BEGIN(call);\n\t\tif (EXPECTED(zend_execute_internal == NULL)) {\n\t\t\t/* saves one function call if zend_execute_internal is not used */\n\t\t\tfunc->internal_function.handler(call, fci->retval);\n\t\t} else {\n\t\t\tzend_execute_internal(call, fci->retval);\n\t\t}\n\n#if ZEND_DEBUG\n\t\tif (!EG(exception) && call->func) {\n\t\t\tif (should_throw) {\n\t\t\t\tzend_internal_call_arginfo_violation(call->func);\n\t\t\t}\n\t\t\tZEND_ASSERT(!(call->func->common.fn_flags & ZEND_ACC_HAS_RETURN_TYPE) ||\n\t\t\t\tzend_verify_internal_return_type(call->func, fci->retval));\n\t\t\tZEND_ASSERT((call->func->common.fn_flags & ZEND_ACC_RETURN_REFERENCE)\n\t\t\t\t? Z_ISREF_P(fci->retval) : !Z_ISREF_P(fci->retval));\n\t\t}\n#endif\n\t\tZEND_OBSERVER_FCALL_END(call, fci->retval);\n\t\tEG(current_execute_data) = call->prev_execute_data;\n\t\tzend_vm_stack_free_args(call);\n\t\tif (UNEXPECTED(ZEND_CALL_INFO(call) & ZEND_CALL_HAS_EXTRA_NAMED_PARAMS)) {\n\t\t\tzend_array_release(call->extra_named_params);\n\t\t}\n\n\t\tif (EG(exception)) {\n\t\t\tzval_ptr_dtor(fci->retval);\n\t\t\tZVAL_UNDEF(fci->retval);\n\t\t}\n\n\t\t/* This flag is regularly checked while running user functions, but not internal\n\t\t * So see whether interrupt flag was set while the function was running... */\n\t\tif (zend_atomic_bool_exchange_ex(&EG(vm_interrupt), false)) {\n\t\t\tif (zend_atomic_bool_load_ex(&EG(timed_out))) {\n\t\t\t\tzend_timeout();\n\t\t\t} else if (zend_interrupt_function) {\n\t\t\t\tzend_interrupt_function(EG(current_execute_data));\n\t\t\t}\n\t\t}\n\t}\n\tEG(fake_scope) = orig_fake_scope;\n\n\tzend_vm_stack_free_call_frame(call);\n\n\tif (UNEXPECTED(EG(exception))) {\n\t\tif (UNEXPECTED(!EG(current_execute_data))) {\n\t\t\tzend_throw_exception_internal(NULL);\n\t\t} else if (EG(current_execute_data)->func &&\n\t\t           ZEND_USER_CODE(EG(current_execute_data)->func->common.type)) {\n\t\t\tzend_rethrow_exception(EG(current_execute_data));\n\t\t}\n\t}\n\n\treturn SUCCESS;\n}\n\nZEND_API void zend_call_known_function(\n\t\tzend_function *fn, zend_object *object, zend_class_entry *called_scope, zval *retval_ptr,\n\t\tuint32_t param_count, zval *params, HashTable *named_params)\n{\n\tzval retval;\n\tzend_fcall_info fci;\n\tzend_fcall_info_cache fcic;\n\n\tZEND_ASSERT(fn && \"zend_function must be passed!\");\n\n\tfci.size = sizeof(fci);\n\tfci.object = object;\n\tfci.retval = retval_ptr ? retval_ptr : &retval;\n\tfci.param_count = param_count;\n\tfci.params = params;\n\tfci.named_params = named_params;\n\tZVAL_UNDEF(&fci.function_name); /* Unused */\n\n\tfcic.function_handler = fn;\n\tfcic.object = object;\n\tfcic.called_scope = called_scope;\n\n\tzend_result result = zend_call_function(&fci, &fcic);\n\tif (UNEXPECTED(result == FAILURE)) {\n\t\tif (!EG(exception)) {\n\t\t\tzend_error_noreturn(E_CORE_ERROR, \"Couldn't execute method %s%s%s\",\n\t\t\t\tfn->common.scope ? ZSTR_VAL(fn->common.scope->name) : \"\",\n\t\t\t\tfn->common.scope ? \"::\" : \"\", ZSTR_VAL(fn->common.function_name));\n\t\t}\n\t}\n\n\tif (!retval_ptr) {\n\t\tzval_ptr_dtor(&retval);\n\t}\n}\n\nstatic zend_always_inline void zend_call_known_instance_method(\n\t\tzend_function *fn, zend_object *object, zval *retval_ptr,\n\t\tuint32_t param_count, zval *params)\n{\n\tzend_call_known_function(fn, object, object->ce, retval_ptr, param_count, params, NULL);\n}\n\nstatic zend_always_inline void zend_call_known_instance_method_with_0_params(\n\t\tzend_function *fn, zend_object *object, zval *retval_ptr)\n{\n\tzend_call_known_instance_method(fn, object, retval_ptr, 0, NULL);\n}\n\nZEND_API void zend_objects_destroy_object(zend_object *object)\n{\n\tzend_function *destructor = object->ce->destructor;\n\n\tif (destructor) {\n\t\tzend_object *old_exception;\n\t\tconst zend_op *old_opline_before_exception;\n\n\t\tif (destructor->op_array.fn_flags & (ZEND_ACC_PRIVATE|ZEND_ACC_PROTECTED)) {\n\t\t\tif (destructor->op_array.fn_flags & ZEND_ACC_PRIVATE) {\n\t\t\t\t/* Ensure that if we're calling a private function, we're allowed to do so.\n\t\t\t\t */\n\t\t\t\tif (EG(current_execute_data)) {\n\t\t\t\t\tzend_class_entry *scope = zend_get_executed_scope();\n\n\t\t\t\t\tif (object->ce != scope) {\n\t\t\t\t\t\tzend_throw_error(NULL,\n\t\t\t\t\t\t\t\"Call to private %s::__destruct() from %s%s\",\n\t\t\t\t\t\t\tZSTR_VAL(object->ce->name),\n\t\t\t\t\t\t\tscope ? \"scope \" : \"global scope\",\n\t\t\t\t\t\t\tscope ? ZSTR_VAL(scope->name) : \"\"\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tzend_error(E_WARNING,\n\t\t\t\t\t\t\"Call to private %s::__destruct() from global scope during shutdown ignored\",\n\t\t\t\t\t\tZSTR_VAL(object->ce->name));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* Ensure that if we're calling a protected function, we're allowed to do so.\n\t\t\t\t */\n\t\t\t\tif (EG(current_execute_data)) {\n\t\t\t\t\tzend_class_entry *scope = zend_get_executed_scope();\n\n\t\t\t\t\tif (!zend_check_protected(zend_get_function_root_class(destructor), scope)) {\n\t\t\t\t\t\tzend_throw_error(NULL,\n\t\t\t\t\t\t\t\"Call to protected %s::__destruct() from %s%s\",\n\t\t\t\t\t\t\tZSTR_VAL(object->ce->name),\n\t\t\t\t\t\t\tscope ? \"scope \" : \"global scope\",\n\t\t\t\t\t\t\tscope ? ZSTR_VAL(scope->name) : \"\"\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tzend_error(E_WARNING,\n\t\t\t\t\t\t\"Call to protected %s::__destruct() from global scope during shutdown ignored\",\n\t\t\t\t\t\tZSTR_VAL(object->ce->name));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tGC_ADDREF(object);\n\n\t\t/* Make sure that destructors are protected from previously thrown exceptions.\n\t\t * For example, if an exception was thrown in a function and when the function's\n\t\t * local variable destruction results in a destructor being called.\n\t\t */\n\t\told_exception = NULL;\n\t\tif (EG(exception)) {\n\t\t\tif (EG(exception) == object) {\n\t\t\t\tzend_error_noreturn(E_CORE_ERROR, \"Attempt to destruct pending exception\");\n\t\t\t} else {\n\t\t\t\tif (EG(current_execute_data)\n\t\t\t\t && EG(current_execute_data)->func\n\t\t\t\t && ZEND_USER_CODE(EG(current_execute_data)->func->common.type)) {\n\t\t\t\t\tzend_rethrow_exception(EG(current_execute_data));\n\t\t\t\t}\n\t\t\t\told_exception = EG(exception);\n\t\t\t\told_opline_before_exception = EG(opline_before_exception);\n\t\t\t\tEG(exception) = NULL;\n\t\t\t}\n\t\t}\n\n\t\tzend_call_known_instance_method_with_0_params(destructor, object, NULL);\n\n\t\tif (old_exception) {\n\t\t\tEG(opline_before_exception) = old_opline_before_exception;\n\t\t\tif (EG(exception)) {\n\t\t\t\tzend_exception_set_previous(EG(exception), old_exception);\n\t\t\t} else {\n\t\t\t\tEG(exception) = old_exception;\n\t\t\t}\n\t\t}\n\t\tOBJ_RELEASE(object);\n\t}\n}\n\nZEND_API void ZEND_FASTCALL zend_objects_store_del(zend_object *object) /* {{{ */\n{\n\tZEND_ASSERT(GC_REFCOUNT(object) == 0);\n\n\t/* GC might have released this object already. */\n\tif (UNEXPECTED(GC_TYPE(object) == IS_NULL)) {\n\t\treturn;\n\t}\n\n\t/*\tMake sure we hold a reference count during the destructor call\n\t\totherwise, when the destructor ends the storage might be freed\n\t\twhen the refcount reaches 0 a second time\n\t */\n\tif (!(OBJ_FLAGS(object) & IS_OBJ_DESTRUCTOR_CALLED)) {\n\t\tGC_ADD_FLAGS(object, IS_OBJ_DESTRUCTOR_CALLED);\n\n\t\tif (object->handlers->dtor_obj != zend_objects_destroy_object\n\t\t\t\t|| object->ce->destructor) {\n\t\t\tzend_fiber_switch_block();\n\t\t\tGC_SET_REFCOUNT(object, 1);\n\t\t\tobject->handlers->dtor_obj(object);\n\t\t\tGC_DELREF(object);\n\t\t\tzend_fiber_switch_unblock();\n\t\t}\n\t}\n\n\tif (GC_REFCOUNT(object) == 0) {\n\t\tuint32_t handle = object->handle;\n\t\tvoid *ptr;\n\n\t\tZEND_ASSERT(EG(objects_store).object_buckets != NULL);\n\t\tZEND_ASSERT(IS_OBJ_VALID(EG(objects_store).object_buckets[handle]));\n\t\tEG(objects_store).object_buckets[handle] = SET_OBJ_INVALID(object);\n\t\tif (!(OBJ_FLAGS(object) & IS_OBJ_FREE_CALLED)) {\n\t\t\tGC_ADD_FLAGS(object, IS_OBJ_FREE_CALLED);\n\t\t\tGC_SET_REFCOUNT(object, 1);\n\t\t\tobject->handlers->free_obj(object);\n\t\t}\n\t\tptr = ((char*)object) - object->handlers->offset;\n\t\tGC_REMOVE_FROM_BUFFER(object);\n\t\tefree(ptr);\n\t\tZEND_OBJECTS_STORE_ADD_TO_FREE_LIST(handle);\n\t}\n}\n\nZEND_API void ZEND_FASTCALL rc_dtor_func(zend_refcounted *p)\n{\n\tZEND_ASSERT(GC_TYPE(p) <= IS_CONSTANT_AST);\n\tzend_rc_dtor_func[GC_TYPE(p)](p);\n}\n\n\n\nstatic ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_SPEC_CV_VAR_RETVAL_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)\n{\n\tUSE_OPLINE\n\tzval *value;\n\tzval *variable_ptr;\n\n\tSAVE_OPLINE();\n\tvalue = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);\n\tvariable_ptr = EX_VAR(opline->op1.var);\n\n\tvalue = zend_assign_to_variable(variable_ptr, value, IS_VAR, EX_USES_STRICT_TYPES());\n\tif (0) {\n\t\tZVAL_COPY(EX_VAR(opline->result.var), value);\n\t}\n\n\t/* zend_assign_to_variable() always takes care of op2, never free it! */\n\n\tZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();\n}\n\nstatic void fuzzer_execute_ex(zend_execute_data *execute_data) {\n\twhile (1) {\n\t\tint ret;\n\t\tfuzzer_step();\n\t\tif ((ret = ((opcode_handler_t) EX(opline)->handler)(execute_data)) != 0) {\n\t\t\tif (ret > 0) {\n\t\t\t\texecute_data = EG(current_execute_data);\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\nzend_result zend_call_function(zend_fcall_info *fci, zend_fcall_info_cache *fci_cache) /* {{{ */\n{\n\tuint32_t i;\n\tzend_execute_data *call;\n\tzend_fcall_info_cache fci_cache_local;\n\tzend_function *func;\n\tuint32_t call_info;\n\tvoid *object_or_called_scope;\n\tzend_class_entry *orig_fake_scope;\n\n\tZVAL_UNDEF(fci->retval);\n\n\tif (!EG(active)) {\n\t\treturn FAILURE; /* executor is already inactive */\n\t}\n\n\tif (EG(exception)) {\n\t\tif (fci_cache) {\n\t\t\tzend_release_fcall_info_cache(fci_cache);\n\t\t}\n\t\treturn SUCCESS; /* we would result in an instable executor otherwise */\n\t}\n\n\tZEND_ASSERT(fci->size == sizeof(zend_fcall_info));\n\n\tif (!fci_cache || !fci_cache->function_handler) {\n\t\tchar *error = NULL;\n\n\t\tif (!fci_cache) {\n\t\t\tfci_cache = &fci_cache_local;\n\t\t}\n\n\t\tif (!zend_is_callable_ex(&fci->function_name, fci->object, 0, NULL, fci_cache, &error)) {\n\t\t\tZEND_ASSERT(error && \"Should have error if not callable\");\n\t\t\tzend_string *callable_name\n\t\t\t\t= zend_get_callable_name_ex(&fci->function_name, fci->object);\n\t\t\tzend_throw_error(NULL, \"Invalid callback %s, %s\", ZSTR_VAL(callable_name), error);\n\t\t\tefree(error);\n\t\t\tzend_string_release_ex(callable_name, 0);\n\t\t\treturn SUCCESS;\n\t\t}\n\n\t\tZEND_ASSERT(!error);\n\t}\n\n\tfunc = fci_cache->function_handler;\n\tif ((func->common.fn_flags & ZEND_ACC_STATIC) || !fci_cache->object) {\n\t\tobject_or_called_scope = fci_cache->called_scope;\n\t\tcall_info = ZEND_CALL_TOP_FUNCTION | ZEND_CALL_DYNAMIC;\n\t} else {\n\t\tobject_or_called_scope = fci_cache->object;\n\t\tcall_info = ZEND_CALL_TOP_FUNCTION | ZEND_CALL_DYNAMIC | ZEND_CALL_HAS_THIS;\n\t}\n\n\tcall = zend_vm_stack_push_call_frame(call_info,\n\t\tfunc, fci->param_count, object_or_called_scope);\n\n\tif (UNEXPECTED(func->common.fn_flags & ZEND_ACC_DEPRECATED)) {\n\t\tzend_deprecated_function(func);\n\n\t\tif (UNEXPECTED(EG(exception))) {\n\t\t\tzend_vm_stack_free_call_frame(call);\n\t\t\treturn SUCCESS;\n\t\t}\n\t}\n\n\tfor (i=0; i<fci->param_count; i++) {\n\t\tzval *param = ZEND_CALL_ARG(call, i+1);\n\t\tzval *arg = &fci->params[i];\n\t\tbool must_wrap = 0;\n\t\tif (UNEXPECTED(Z_ISUNDEF_P(arg))) {\n\t\t\t/* Allow forwarding undef slots. This is only used by Closure::__invoke(). */\n\t\t\tZVAL_UNDEF(param);\n\t\t\tZEND_ADD_CALL_FLAG(call, ZEND_CALL_MAY_HAVE_UNDEF);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ARG_SHOULD_BE_SENT_BY_REF(func, i + 1)) {\n\t\t\tif (UNEXPECTED(!Z_ISREF_P(arg))) {\n\t\t\t\tif (!ARG_MAY_BE_SENT_BY_REF(func, i + 1)) {\n\t\t\t\t\t/* By-value send is not allowed -- emit a warning,\n\t\t\t\t\t * and perform the call with the value wrapped in a reference. */\n\t\t\t\t\tzend_param_must_be_ref(func, i + 1);\n\t\t\t\t\tmust_wrap = 1;\n\t\t\t\t\tif (UNEXPECTED(EG(exception))) {\n\t\t\t\t\t\tZEND_CALL_NUM_ARGS(call) = i;\ncleanup_args:\n\t\t\t\t\t\tzend_vm_stack_free_args(call);\n\t\t\t\t\t\tzend_vm_stack_free_call_frame(call);\n\t\t\t\t\t\treturn SUCCESS;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (Z_ISREF_P(arg) &&\n\t\t\t    !(func->common.fn_flags & ZEND_ACC_CALL_VIA_TRAMPOLINE)) {\n\t\t\t\t/* don't separate references for __call */\n\t\t\t\targ = Z_REFVAL_P(arg);\n\t\t\t}\n\t\t}\n\n\t\tif (EXPECTED(!must_wrap)) {\n\t\t\tZVAL_COPY(param, arg);\n\t\t} else {\n\t\t\tZ_TRY_ADDREF_P(arg);\n\t\t\tZVAL_NEW_REF(param, arg);\n\t\t}\n\t}\n\n\tif (fci->named_params) {\n\t\tzend_string *name;\n\t\tzval *arg;\n\t\tuint32_t arg_num = ZEND_CALL_NUM_ARGS(call) + 1;\n\t\tbool have_named_params = 0;\n\t\tZEND_HASH_FOREACH_STR_KEY_VAL(fci->named_params, name, arg) {\n\t\t\tbool must_wrap = 0;\n\t\t\tzval *target;\n\t\t\tif (name) {\n\t\t\t\tvoid *cache_slot[2] = {NULL, NULL};\n\t\t\t\thave_named_params = 1;\n\t\t\t\ttarget = zend_handle_named_arg(&call, name, &arg_num, cache_slot);\n\t\t\t\tif (!target) {\n\t\t\t\t\tgoto cleanup_args;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (have_named_params) {\n\t\t\t\t\tzend_throw_error(NULL,\n\t\t\t\t\t\t\"Cannot use positional argument after named argument\");\n\t\t\t\t\tgoto cleanup_args;\n\t\t\t\t}\n\n\t\t\t\tzend_vm_stack_extend_call_frame(&call, arg_num - 1, 1);\n\t\t\t\ttarget = ZEND_CALL_ARG(call, arg_num);\n\t\t\t}\n\n\t\t\tif (ARG_SHOULD_BE_SENT_BY_REF(func, arg_num)) {\n\t\t\t\tif (UNEXPECTED(!Z_ISREF_P(arg))) {\n\t\t\t\t\tif (!ARG_MAY_BE_SENT_BY_REF(func, arg_num)) {\n\t\t\t\t\t\t/* By-value send is not allowed -- emit a warning,\n\t\t\t\t\t\t * and perform the call with the value wrapped in a reference. */\n\t\t\t\t\t\tzend_param_must_be_ref(func, arg_num);\n\t\t\t\t\t\tmust_wrap = 1;\n\t\t\t\t\t\tif (UNEXPECTED(EG(exception))) {\n\t\t\t\t\t\t\tgoto cleanup_args;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (Z_ISREF_P(arg) &&\n\t\t\t\t\t!(func->common.fn_flags & ZEND_ACC_CALL_VIA_TRAMPOLINE)) {\n\t\t\t\t\t/* don't separate references for __call */\n\t\t\t\t\targ = Z_REFVAL_P(arg);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (EXPECTED(!must_wrap)) {\n\t\t\t\tZVAL_COPY(target, arg);\n\t\t\t} else {\n\t\t\t\tZ_TRY_ADDREF_P(arg);\n\t\t\t\tZVAL_NEW_REF(target, arg);\n\t\t\t}\n\t\t\tif (!name) {\n\t\t\t\tZEND_CALL_NUM_ARGS(call)++;\n\t\t\t\targ_num++;\n\t\t\t}\n\t\t} ZEND_HASH_FOREACH_END();\n\t}\n\n\tif (UNEXPECTED(ZEND_CALL_INFO(call) & ZEND_CALL_MAY_HAVE_UNDEF)) {\n\t\tif (zend_handle_undef_args(call) == FAILURE) {\n\t\t\tzend_vm_stack_free_args(call);\n\t\t\tzend_vm_stack_free_call_frame(call);\n\t\t\treturn SUCCESS;\n\t\t}\n\t}\n\n\tif (UNEXPECTED(func->op_array.fn_flags & ZEND_ACC_CLOSURE)) {\n\t\tuint32_t call_info;\n\n\t\tGC_ADDREF(ZEND_CLOSURE_OBJECT(func));\n\t\tcall_info = ZEND_CALL_CLOSURE;\n\t\tif (func->common.fn_flags & ZEND_ACC_FAKE_CLOSURE) {\n\t\t\tcall_info |= ZEND_CALL_FAKE_CLOSURE;\n\t\t}\n\t\tZEND_ADD_CALL_FLAG(call, call_info);\n\t}\n\n\tif (func->common.fn_flags & ZEND_ACC_CALL_VIA_TRAMPOLINE) {\n\t\tfci_cache->function_handler = NULL;\n\t}\n\n\torig_fake_scope = EG(fake_scope);\n\tEG(fake_scope) = NULL;\n\tif (func->type == ZEND_USER_FUNCTION) {\n\t\tuint32_t orig_jit_trace_num = EG(jit_trace_num);\n\n\t\tzend_init_func_execute_data(call, &func->op_array, fci->retval);\n\t\tZEND_OBSERVER_FCALL_BEGIN(call);\n\t\tzend_execute_ex(call);\n\t\tEG(jit_trace_num) = orig_jit_trace_num;\n\t} else {\n\t\tZEND_ASSERT(func->type == ZEND_INTERNAL_FUNCTION);\n\t\tZVAL_NULL(fci->retval);\n\t\tcall->prev_execute_data = EG(current_execute_data);\n\t\tEG(current_execute_data) = call;\n#if ZEND_DEBUG\n\t\tbool should_throw = zend_internal_call_should_throw(func, call);\n#endif\n\t\tZEND_OBSERVER_FCALL_BEGIN(call);\n\t\tif (EXPECTED(zend_execute_internal == NULL)) {\n\t\t\t/* saves one function call if zend_execute_internal is not used */\n\t\t\tfunc->internal_function.handler(call, fci->retval);\n\t\t} else {\n\t\t\tzend_execute_internal(call, fci->retval);\n\t\t}\n\n#if ZEND_DEBUG\n\t\tif (!EG(exception) && call->func) {\n\t\t\tif (should_throw) {\n\t\t\t\tzend_internal_call_arginfo_violation(call->func);\n\t\t\t}\n\t\t\tZEND_ASSERT(!(call->func->common.fn_flags & ZEND_ACC_HAS_RETURN_TYPE) ||\n\t\t\t\tzend_verify_internal_return_type(call->func, fci->retval));\n\t\t\tZEND_ASSERT((call->func->common.fn_flags & ZEND_ACC_RETURN_REFERENCE)\n\t\t\t\t? Z_ISREF_P(fci->retval) : !Z_ISREF_P(fci->retval));\n\t\t}\n#endif\n\t\tZEND_OBSERVER_FCALL_END(call, fci->retval);\n\t\tEG(current_execute_data) = call->prev_execute_data;\n\t\tzend_vm_stack_free_args(call);\n\t\tif (UNEXPECTED(ZEND_CALL_INFO(call) & ZEND_CALL_HAS_EXTRA_NAMED_PARAMS)) {\n\t\t\tzend_array_release(call->extra_named_params);\n\t\t}\n\n\t\tif (EG(exception)) {\n\t\t\tzval_ptr_dtor(fci->retval);\n\t\t\tZVAL_UNDEF(fci->retval);\n\t\t}\n\n\t\t/* This flag is regularly checked while running user functions, but not internal\n\t\t * So see whether interrupt flag was set while the function was running... */\n\t\tif (zend_atomic_bool_exchange_ex(&EG(vm_interrupt), false)) {\n\t\t\tif (zend_atomic_bool_load_ex(&EG(timed_out))) {\n\t\t\t\tzend_timeout();\n\t\t\t} else if (zend_interrupt_function) {\n\t\t\t\tzend_interrupt_function(EG(current_execute_data));\n\t\t\t}\n\t\t}\n\t}\n\tEG(fake_scope) = orig_fake_scope;\n\n\tzend_vm_stack_free_call_frame(call);\n\n\tif (UNEXPECTED(EG(exception))) {\n\t\tif (UNEXPECTED(!EG(current_execute_data))) {\n\t\t\tzend_throw_exception_internal(NULL);\n\t\t} else if (EG(current_execute_data)->func &&\n\t\t           ZEND_USER_CODE(EG(current_execute_data)->func->common.type)) {\n\t\t\tzend_rethrow_exception(EG(current_execute_data));\n\t\t}\n\t}\n\n\treturn SUCCESS;\n}\n\nZEND_API void zend_call_known_function(\n\t\tzend_function *fn, zend_object *object, zend_class_entry *called_scope, zval *retval_ptr,\n\t\tuint32_t param_count, zval *params, HashTable *named_params)\n{\n\tzval retval;\n\tzend_fcall_info fci;\n\tzend_fcall_info_cache fcic;\n\n\tZEND_ASSERT(fn && \"zend_function must be passed!\");\n\n\tfci.size = sizeof(fci);\n\tfci.object = object;\n\tfci.retval = retval_ptr ? retval_ptr : &retval;\n\tfci.param_count = param_count;\n\tfci.params = params;\n\tfci.named_params = named_params;\n\tZVAL_UNDEF(&fci.function_name); /* Unused */\n\n\tfcic.function_handler = fn;\n\tfcic.object = object;\n\tfcic.called_scope = called_scope;\n\n\tzend_result result = zend_call_function(&fci, &fcic);\n\tif (UNEXPECTED(result == FAILURE)) {\n\t\tif (!EG(exception)) {\n\t\t\tzend_error_noreturn(E_CORE_ERROR, \"Couldn't execute method %s%s%s\",\n\t\t\t\tfn->common.scope ? ZSTR_VAL(fn->common.scope->name) : \"\",\n\t\t\t\tfn->common.scope ? \"::\" : \"\", ZSTR_VAL(fn->common.function_name));\n\t\t}\n\t}\n\n\tif (!retval_ptr) {\n\t\tzval_ptr_dtor(&retval);\n\t}\n}\n\nstatic zend_always_inline void zend_call_known_instance_method(\n\t\tzend_function *fn, zend_object *object, zval *retval_ptr,\n\t\tuint32_t param_count, zval *params)\n{\n\tzend_call_known_function(fn, object, object->ce, retval_ptr, param_count, params, NULL);\n}\n\nstatic zend_always_inline void zend_call_known_instance_method_with_0_params(\n\t\tzend_function *fn, zend_object *object, zval *retval_ptr)\n{\n\tzend_call_known_instance_method(fn, object, retval_ptr, 0, NULL);\n}\n\nZEND_API void zend_objects_destroy_object(zend_object *object)\n{\n\tzend_function *destructor = object->ce->destructor;\n\n\tif (destructor) {\n\t\tzend_object *old_exception;\n\t\tconst zend_op *old_opline_before_exception;\n\n\t\tif (destructor->op_array.fn_flags & (ZEND_ACC_PRIVATE|ZEND_ACC_PROTECTED)) {\n\t\t\tif (destructor->op_array.fn_flags & ZEND_ACC_PRIVATE) {\n\t\t\t\t/* Ensure that if we're calling a private function, we're allowed to do so.\n\t\t\t\t */\n\t\t\t\tif (EG(current_execute_data)) {\n\t\t\t\t\tzend_class_entry *scope = zend_get_executed_scope();\n\n\t\t\t\t\tif (object->ce != scope) {\n\t\t\t\t\t\tzend_throw_error(NULL,\n\t\t\t\t\t\t\t\"Call to private %s::__destruct() from %s%s\",\n\t\t\t\t\t\t\tZSTR_VAL(object->ce->name),\n\t\t\t\t\t\t\tscope ? \"scope \" : \"global scope\",\n\t\t\t\t\t\t\tscope ? ZSTR_VAL(scope->name) : \"\"\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tzend_error(E_WARNING,\n\t\t\t\t\t\t\"Call to private %s::__destruct() from global scope during shutdown ignored\",\n\t\t\t\t\t\tZSTR_VAL(object->ce->name));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* Ensure that if we're calling a protected function, we're allowed to do so.\n\t\t\t\t */\n\t\t\t\tif (EG(current_execute_data)) {\n\t\t\t\t\tzend_class_entry *scope = zend_get_executed_scope();\n\n\t\t\t\t\tif (!zend_check_protected(zend_get_function_root_class(destructor), scope)) {\n\t\t\t\t\t\tzend_throw_error(NULL,\n\t\t\t\t\t\t\t\"Call to protected %s::__destruct() from %s%s\",\n\t\t\t\t\t\t\tZSTR_VAL(object->ce->name),\n\t\t\t\t\t\t\tscope ? \"scope \" : \"global scope\",\n\t\t\t\t\t\t\tscope ? ZSTR_VAL(scope->name) : \"\"\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tzend_error(E_WARNING,\n\t\t\t\t\t\t\"Call to protected %s::__destruct() from global scope during shutdown ignored\",\n\t\t\t\t\t\tZSTR_VAL(object->ce->name));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tGC_ADDREF(object);\n\n\t\t/* Make sure that destructors are protected from previously thrown exceptions.\n\t\t * For example, if an exception was thrown in a function and when the function's\n\t\t * local variable destruction results in a destructor being called.\n\t\t */\n\t\told_exception = NULL;\n\t\tif (EG(exception)) {\n\t\t\tif (EG(exception) == object) {\n\t\t\t\tzend_error_noreturn(E_CORE_ERROR, \"Attempt to destruct pending exception\");\n\t\t\t} else {\n\t\t\t\tif (EG(current_execute_data)\n\t\t\t\t && EG(current_execute_data)->func\n\t\t\t\t && ZEND_USER_CODE(EG(current_execute_data)->func->common.type)) {\n\t\t\t\t\tzend_rethrow_exception(EG(current_execute_data));\n\t\t\t\t}\n\t\t\t\told_exception = EG(exception);\n\t\t\t\told_opline_before_exception = EG(opline_before_exception);\n\t\t\t\tEG(exception) = NULL;\n\t\t\t}\n\t\t}\n\n\t\tzend_call_known_instance_method_with_0_params(destructor, object, NULL);\n\n\t\tif (old_exception) {\n\t\t\tEG(opline_before_exception) = old_opline_before_exception;\n\t\t\tif (EG(exception)) {\n\t\t\t\tzend_exception_set_previous(EG(exception), old_exception);\n\t\t\t} else {\n\t\t\t\tEG(exception) = old_exception;\n\t\t\t}\n\t\t}\n\t\tOBJ_RELEASE(object);\n\t}\n}\n\nZEND_API void ZEND_FASTCALL zend_objects_store_del(zend_object *object) /* {{{ */\n{\n\tZEND_ASSERT(GC_REFCOUNT(object) == 0);\n\n\t/* GC might have released this object already. */\n\tif (UNEXPECTED(GC_TYPE(object) == IS_NULL)) {\n\t\treturn;\n\t}\n\n\t/*\tMake sure we hold a reference count during the destructor call\n\t\totherwise, when the destructor ends the storage might be freed\n\t\twhen the refcount reaches 0 a second time\n\t */\n\tif (!(OBJ_FLAGS(object) & IS_OBJ_DESTRUCTOR_CALLED)) {\n\t\tGC_ADD_FLAGS(object, IS_OBJ_DESTRUCTOR_CALLED);\n\n\t\tif (object->handlers->dtor_obj != zend_objects_destroy_object\n\t\t\t\t|| object->ce->destructor) {\n\t\t\tzend_fiber_switch_block();\n\t\t\tGC_SET_REFCOUNT(object, 1);\n\t\t\tobject->handlers->dtor_obj(object);\n\t\t\tGC_DELREF(object);\n\t\t\tzend_fiber_switch_unblock();\n\t\t}\n\t}\n\n\tif (GC_REFCOUNT(object) == 0) {\n\t\tuint32_t handle = object->handle;\n\t\tvoid *ptr;\n\n\t\tZEND_ASSERT(EG(objects_store).object_buckets != NULL);\n\t\tZEND_ASSERT(IS_OBJ_VALID(EG(objects_store).object_buckets[handle]));\n\t\tEG(objects_store).object_buckets[handle] = SET_OBJ_INVALID(object);\n\t\tif (!(OBJ_FLAGS(object) & IS_OBJ_FREE_CALLED)) {\n\t\t\tGC_ADD_FLAGS(object, IS_OBJ_FREE_CALLED);\n\t\t\tGC_SET_REFCOUNT(object, 1);\n\t\t\tobject->handlers->free_obj(object);\n\t\t}\n\t\tptr = ((char*)object) - object->handlers->offset;\n\t\tGC_REMOVE_FROM_BUFFER(object);\n\t\tefree(ptr);\n\t\tZEND_OBJECTS_STORE_ADD_TO_FREE_LIST(handle);\n\t}\n}\n\nZEND_API void ZEND_FASTCALL rc_dtor_func(zend_refcounted *p)\n{\n\tZEND_ASSERT(GC_TYPE(p) <= IS_CONSTANT_AST);\n\tzend_rc_dtor_func[GC_TYPE(p)](p);\n}\n\nstatic zend_always_inline void i_zval_ptr_dtor(zval *zval_ptr)\n{\n\tif (Z_REFCOUNTED_P(zval_ptr)) {\n\t\tzend_refcounted *ref = Z_COUNTED_P(zval_ptr);\n\t\tif (!GC_DELREF(ref)) {\n\t\t\trc_dtor_func(ref);\n\t\t} else {\n\t\t\tgc_check_possible_root(ref);\n\t\t}\n\t}\n}\n\nZEND_API void zval_ptr_dtor(zval *zval_ptr) /* {{{ */\n{\n\ti_zval_ptr_dtor(zval_ptr);\n}\n\nstatic zend_always_inline void _zend_hash_del_el_ex(HashTable *ht, uint32_t idx, Bucket *p, Bucket *prev)\n{\n\tif (prev) {\n\t\tZ_NEXT(prev->val) = Z_NEXT(p->val);\n\t} else {\n\t\tHT_HASH(ht, p->h | ht->nTableMask) = Z_NEXT(p->val);\n\t}\n\tidx = HT_HASH_TO_IDX(idx);\n\tht->nNumOfElements--;\n\tif (ht->nInternalPointer == idx || UNEXPECTED(HT_HAS_ITERATORS(ht))) {\n\t\tuint32_t new_idx;\n\n\t\tnew_idx = idx;\n\t\twhile (1) {\n\t\t\tnew_idx++;\n\t\t\tif (new_idx >= ht->nNumUsed) {\n\t\t\t\tbreak;\n\t\t\t} else if (Z_TYPE(ht->arData[new_idx].val) != IS_UNDEF) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ht->nInternalPointer == idx) {\n\t\t\tht->nInternalPointer = new_idx;\n\t\t}\n\t\tzend_hash_iterators_update(ht, idx, new_idx);\n\t}\n\tif (ht->nNumUsed - 1 == idx) {\n\t\tdo {\n\t\t\tht->nNumUsed--;\n\t\t} while (ht->nNumUsed > 0 && (UNEXPECTED(Z_TYPE(ht->arData[ht->nNumUsed-1].val) == IS_UNDEF)));\n\t\tht->nInternalPointer = MIN(ht->nInternalPointer, ht->nNumUsed);\n\t}\n\tif (ht->pDestructor) {\n\t\tzval tmp;\n\t\tZVAL_COPY_VALUE(&tmp, &p->val);\n\t\tZVAL_UNDEF(&p->val);\n\t\tht->pDestructor(&tmp);\n\t} else {\n\t\tZVAL_UNDEF(&p->val);\n\t}\n}\n\nstatic zend_always_inline void _zend_hash_del_el(HashTable *ht, uint32_t idx, Bucket *p)\n{\n\tBucket *prev = NULL;\n\tuint32_t nIndex;\n\tuint32_t i;\n\n\tnIndex = p->h | ht->nTableMask;\n\ti = HT_HASH(ht, nIndex);\n\n\tif (i != idx) {\n\t\tprev = HT_HASH_TO_BUCKET(ht, i);\n\t\twhile (Z_NEXT(prev->val) != idx) {\n\t\t\ti = Z_NEXT(prev->val);\n\t\t\tprev = HT_HASH_TO_BUCKET(ht, i);\n\t\t}\n\t}\n\n\tif (p->key) {\n\t\tzend_string_release(p->key);\n\t\tp->key = NULL;\n\t}\n\t_zend_hash_del_el_ex(ht, idx, p, prev);\n}\n\nZEND_API void ZEND_FASTCALL zend_hash_reverse_apply(HashTable *ht, apply_func_t apply_func)\n{\n\tuint32_t idx;\n\tint result;\n\n\tIS_CONSISTENT(ht);\n\n\tidx = ht->nNumUsed;\n\tif (HT_IS_PACKED(ht)) {\n\t\tzval *zv;\n\n\t\twhile (idx > 0) {\n\t\t\tidx--;\n\t\t\tzv = ht->arPacked + idx;\n\t\t\tif (UNEXPECTED(Z_TYPE_P(zv) == IS_UNDEF)) continue;\n\n\t\t\tresult = apply_func(zv);\n\n\t\t\tif (result & ZEND_HASH_APPLY_REMOVE) {\n\t\t\t\tHT_ASSERT_RC1(ht);\n\t\t\t\t_zend_hash_packed_del_val(ht, HT_IDX_TO_HASH(idx), zv);\n\t\t\t}\n\t\t\tif (result & ZEND_HASH_APPLY_STOP) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tBucket *p;\n\n\t\twhile (idx > 0) {\n\t\t\tidx--;\n\t\t\tp = ht->arData + idx;\n\t\t\tif (UNEXPECTED(Z_TYPE(p->val) == IS_UNDEF)) continue;\n\n\t\t\tresult = apply_func(&p->val);\n\n\t\t\tif (result & ZEND_HASH_APPLY_REMOVE) {\n\t\t\t\tHT_ASSERT_RC1(ht);\n\t\t\t\t_zend_hash_del_el(ht, HT_IDX_TO_HASH(idx), p);\n\t\t\t}\n\t\t\tif (result & ZEND_HASH_APPLY_STOP) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid shutdown_destructors(void) /* {{{ */\n{\n\tif (CG(unclean_shutdown)) {\n\t\tEG(symbol_table).pDestructor = zend_unclean_zval_ptr_dtor;\n\t}\n\tzend_try {\n\t\tuint32_t symbols;\n\t\tdo {\n\t\t\tsymbols = zend_hash_num_elements(&EG(symbol_table));\n\t\t\tzend_hash_reverse_apply(&EG(symbol_table), (apply_func_t) zval_call_destructor);\n\t\t} while (symbols != zend_hash_num_elements(&EG(symbol_table)));\n\t\tzend_objects_store_call_destructors(&EG(objects_store));\n\t} zend_catch {\n\nvoid zend_call_destructors(void) /* {{{ */\n{\n\tzend_try {\n\t\tshutdown_destructors();\n\t} zend_end_try();\n\nvoid php_request_shutdown(void *dummy)\n{\n\tbool report_memleaks;\n\n\tEG(flags) |= EG_FLAGS_IN_SHUTDOWN;\n\n\treport_memleaks = PG(report_memleaks);\n\n\t/* EG(current_execute_data) points into nirvana and therefore cannot be safely accessed\n\t * inside zend_executor callback functions.\n\t */\n\tEG(current_execute_data) = NULL;\n\n\tphp_deactivate_ticks();\n\n\t/* 0. Call any open observer end handlers that are still open after a zend_bailout */\n\tif (ZEND_OBSERVER_ENABLED) {\n\t\tzend_observer_fcall_end_all();\n\t}\n\n\t/* 1. Call all possible shutdown functions registered with register_shutdown_function() */\n\tif (PG(modules_activated)) {\n\t\tphp_call_shutdown_functions();\n\t}\n\n\t/* 2. Call all possible __destruct() functions */\n\tzend_try {\n\t\tzend_call_destructors();\n\t} zend_end_try();\n\nvoid fuzzer_request_shutdown()\n{\n\tzend_try {\n\t\t/* Destroy thrown exceptions. This does not happen as part of request shutdown. */\n\t\tif (EG(exception)) {\n\t\t\tzend_object_release(EG(exception));\n\t\t\tEG(exception) = NULL;\n\t\t}\n\n\t\t/* Some fuzzers (like unserialize) may create circular structures. Make sure we free them.\n\t\t * Two calls are performed to handle objects with destructors. */\n\t\tzend_gc_collect_cycles();\n\t\tzend_gc_collect_cycles();\n\t} zend_end_try();\n\nint fuzzer_do_request_from_buffer(\n\t\tchar *filename, const char *data, size_t data_len, bool execute,\n\t\tvoid (*before_shutdown)(void))\n{\n\tint retval = FAILURE; /* failure by default */\n\n\tSG(options) |= SAPI_OPTION_NO_CHDIR;\n\tSG(request_info).argc=0;\n\tSG(request_info).argv=NULL;\n\n\tif (fuzzer_request_startup() == FAILURE) {\n\t\treturn FAILURE;\n\t}\n\n\t// Commented out to avoid leaking the header callback.\n\t//SG(headers_sent) = 1;\n\t//SG(request_info).no_headers = 1;\n\tphp_register_variable(\"PHP_SELF\", filename, NULL);\n\n\tzend_first_try {\n\t\tzend_file_handle file_handle;\n\t\tzend_stream_init_filename(&file_handle, filename);\n\t\tfile_handle.primary_script = 1;\n\t\tfile_handle.buf = estrndup(data, data_len);\n\t\tfile_handle.len = data_len;\n\t\t/* Avoid ZEND_HANDLE_FILENAME for opcache. */\n\t\tfile_handle.type = ZEND_HANDLE_STREAM;\n\n\t\tzend_op_array *op_array = zend_compile_file(&file_handle, ZEND_REQUIRE);\n\t\tzend_destroy_file_handle(&file_handle);\n\t\tif (op_array) {\n\t\t\tif (execute) {\n\t\t\t\tzend_execute(op_array, NULL);\n\t\t\t}\n\t\t\tzend_destroy_static_vars(op_array);\n\t\t\tdestroy_op_array(op_array);\n\t\t\tefree(op_array);\n\t\t}\n\t} zend_end_try();\n\n\n// target function\nstatic void update_errors_warnings(timelib_error_container **last_errors) /* {{{ */\n{\n\tif (DATEG(last_errors)) {\n\t\ttimelib_error_container_dtor(DATEG(last_errors));\n\t\tDATEG(last_errors) = NULL;\n\t}\n\n\tif (last_errors == NULL || (*last_errors) == NULL) {\n\t\treturn;\n\t}\n\n\tif ((*last_errors)->warning_count || (*last_errors)->error_count) {\n\t\tDATEG(last_errors) = *last_errors;\n\t}\n\n\ttimelib_error_container_dtor(*last_errors);\n\t*last_errors = NULL;\n} /* }}} */\n",
    "target": 1,
    "idx": 1051180,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\n    (void) printf(\" Found a generic profile, type %s\\n\",&text[ii].key[17]);\n\n  return MagickTrue;\n}\n\n#if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)\n\nstatic int read_user_chunk_callback(png_struct *ping, png_unknown_chunkp chunk)\n{\n  Image\n    *image;\n\n\n  /* The unknown chunk structure contains the chunk data:\n     png_byte name[5];\n     png_byte *data;\n     png_size_t size;\n\n     Note that libpng has already taken care of the CRC handling.\n\n     Returns one of the following:\n         return(-n);  chunk had an error\n         return(0);  did not recognize\n         return(n);  success\n  */\n\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n     \"    read_user_chunk: found %c%c%c%c chunk\",\n       chunk->name[0],chunk->name[1],chunk->name[2],chunk->name[3]);\n\n  if (chunk->name[0]  == 101 &&\n      (chunk->name[1] ==  88 || chunk->name[1] == 120 ) &&\n      chunk->name[2] ==   73 &&\n      chunk-> name[3] == 102)\n    {\n      /* process eXIf or exIf chunk */\n\n      PNGErrorInfo\n        *error_info;\n\n      StringInfo\n        *profile;\n\n      unsigned char\n        *p;\n\n      png_byte\n        *s;\n\n      size_t\n        i;\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \" recognized eXIf chunk\");\n\n      image=(Image *) png_get_user_chunk_ptr(ping);\n\n      error_info=(PNGErrorInfo *) png_get_error_ptr(ping);\n\n      profile=BlobToStringInfo((const void *) NULL,chunk->size+6);\n\n      if (profile == (StringInfo *) NULL)\n        {\n          (void) ThrowMagickException(error_info->exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\n            image->filename);\n          return(-1);\n        }\n      p=GetStringInfoDatum(profile);\n\n      /* Initialize profile with \"Exif\\0\\0\" */\n      *p++ ='E';\n      *p++ ='x';\n      *p++ ='i';\n      *p++ ='f';\n      *p++ ='\\0';\n      *p++ ='\\0';\n\n      s=chunk->data;\n      i=0;\n      if (chunk->size > 6)\n        {\n          /* Skip first 6 bytes if \"Exif\\0\\0\" is\n             already present by accident\n          */\n          if (s[0] == 'E' && s[1] == 'x'  && s[2] == 'i' &&\n              s[3] == 'f' && s[4] == '\\0' && s[5] == '\\0')\n          {\n            s+=6;\n            i=6;\n            SetStringInfoLength(profile,chunk->size);\n            p=GetStringInfoDatum(profile);\n          }\n        }\n\n      /* copy chunk->data to profile */\n      for (; i<chunk->size; i++)\n        *p++ = *s++;\n\n      error_info=(PNGErrorInfo *) png_get_error_ptr(ping);\n      (void) SetImageProfile(image,\"exif\",profile,\n        error_info->exception);\n\n      profile=DestroyStringInfo(profile);\n\n      return(1);\n    }\n\n  /* orNT */\n  if (chunk->name[0] == 111 &&\n      chunk->name[1] == 114 &&\n      chunk->name[2] ==  78 &&\n      chunk->name[3] ==  84)\n    {\n     /* recognized orNT */\n     if (chunk->size != 1)\n       return(-1); /* Error return */\n\n     image=(Image *) png_get_user_chunk_ptr(ping);\n\n     image->orientation=\n       Magick_Orientation_from_Exif_Orientation((int) chunk->data[0]);\n\n     return(1);\n    }\n\n  /* vpAg (deprecated, replaced by caNv) */\n  if (chunk->name[0] == 118 &&\n      chunk->name[1] == 112 &&\n      chunk->name[2] ==  65 &&\n      chunk->name[3] == 103)\n    {\n      /* recognized vpAg */\n\n      if (chunk->size != 9)\n        return(-1); /* Error return */\n\n      if (chunk->data[8] != 0)\n        return(0);  /* ImageMagick requires pixel units */\n\n      image=(Image *) png_get_user_chunk_ptr(ping);\n\n      image->page.width=(size_t)mng_get_long(chunk->data);\n      image->page.height=(size_t)mng_get_long(&chunk->data[4]);\n\n      return(1);\n    }\n\n  /* caNv */\n  if (chunk->name[0] ==  99 &&\n      chunk->name[1] ==  97 &&\n      chunk->name[2] ==  78 &&\n      chunk->name[3] == 118)\n    {\n      /* recognized caNv */\n\n      if (chunk->size != 16)\n        return(-1); /* Error return */\n\n      image=(Image *) png_get_user_chunk_ptr(ping);\n\n      image->page.width=(size_t)mng_get_long(chunk->data);\n      image->page.height=(size_t)mng_get_long(&chunk->data[4]);\n      image->page.x=(size_t)mng_get_long(&chunk->data[8]);\n\n\n\nvoid PNGAPI\npng_read_info(png_structrp png_ptr, png_inforp info_ptr)\n{\n#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED\n   int keep;\n#endif\n\n   png_debug(1, \"in png_read_info\");\n\n   if (png_ptr == NULL || info_ptr == NULL)\n      return;\n\n   /* Read and check the PNG file signature. */\n   png_read_sig(png_ptr, info_ptr);\n\n   for (;;)\n   {\n      png_uint_32 length = png_read_chunk_header(png_ptr);\n      png_uint_32 chunk_name = png_ptr->chunk_name;\n\n      /* IDAT logic needs to happen here to simplify getting the two flags\n       * right.\n       */\n      if (chunk_name == png_IDAT)\n      {\n         if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n            png_chunk_error(png_ptr, \"Missing IHDR before IDAT\");\n\n         else if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE &&\n             (png_ptr->mode & PNG_HAVE_PLTE) == 0)\n            png_chunk_error(png_ptr, \"Missing PLTE before IDAT\");\n\n         else if ((png_ptr->mode & PNG_AFTER_IDAT) != 0)\n            png_chunk_benign_error(png_ptr, \"Too many IDATs found\");\n\n         png_ptr->mode |= PNG_HAVE_IDAT;\n      }\n\n      else if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)\n      {\n         png_ptr->mode |= PNG_HAVE_CHUNK_AFTER_IDAT;\n         png_ptr->mode |= PNG_AFTER_IDAT;\n      }\n\n      /* This should be a binary subdivision search or a hash for\n       * matching the chunk name rather than a linear search.\n       */\n      if (chunk_name == png_IHDR)\n         png_handle_IHDR(png_ptr, info_ptr, length);\n\n      else if (chunk_name == png_IEND)\n         png_handle_IEND(png_ptr, info_ptr, length);\n\n#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED\n      else if ((keep = png_chunk_unknown_handling(png_ptr, chunk_name)) != 0)\n      {\n         png_handle_unknown(png_ptr, info_ptr, length, keep);\n\n         if (chunk_name == png_PLTE)\n            png_ptr->mode |= PNG_HAVE_PLTE;\n\n         else if (chunk_name == png_IDAT)\n         {\n            png_ptr->idat_size = 0; /* It has been consumed */\n            break;\n         }\n      }\n#endif\n      else if (chunk_name == png_PLTE)\n         png_handle_PLTE(png_ptr, info_ptr, length);\n\n      else if (chunk_name == png_IDAT)\n      {\n         png_ptr->idat_size = length;\n         break;\n      }\n\n#ifdef PNG_READ_bKGD_SUPPORTED\n      else if (chunk_name == png_bKGD)\n         png_handle_bKGD(png_ptr, info_ptr, length);\n#endif\n\n#ifdef PNG_READ_cHRM_SUPPORTED\n      else if (chunk_name == png_cHRM)\n         png_handle_cHRM(png_ptr, info_ptr, length);\n#endif\n\n#ifdef PNG_READ_eXIf_SUPPORTED\n      else if (chunk_name == png_eXIf)\n         png_handle_eXIf(png_ptr, info_ptr, length);\n#endif\n\n#ifdef PNG_READ_gAMA_SUPPORTED\n      else if (chunk_name == png_gAMA)\n         png_handle_gAMA(png_ptr, info_ptr, length);\n#endif\n\n#ifdef PNG_READ_hIST_SUPPORTED\n      else if (chunk_name == png_hIST)\n         png_handle_hIST(png_ptr, info_ptr, length);\n#endif\n\n#ifdef PNG_READ_oFFs_SUPPORTED\n      else if (chunk_name == png_oFFs)\n         png_handle_oFFs(png_ptr, info_ptr, length);\n#endif\n\n#ifdef PNG_READ_pCAL_SUPPORTED\n      else if (chunk_name == png_pCAL)\n         png_handle_pCAL(png_ptr, info_ptr, length);\n#endif\n\n#ifdef PNG_READ_sCAL_SUPPORTED\n      else if (chunk_name == png_sCAL)\n         png_handle_sCAL(png_ptr, info_ptr, length);\n#endif\n\n#ifdef PNG_READ_pHYs_SUPPORTED\n      else if (chunk_name == png_pHYs)\n         png_handle_pHYs(png_ptr, info_ptr, length);\n#endif\n\n#ifdef PNG_READ_sBIT_SUPPORTED\n      else if (chunk_name == png_sBIT)\n         png_handle_sBIT(png_ptr, info_ptr, length);\n#endif\n\n#ifdef PNG_READ_sRGB_SUPPORTED\n      else if (chunk_name == png_sRGB)\n         png_handle_sRGB(png_ptr, info_ptr, length);\n#endif\n\n#ifdef PNG_READ_iCCP_SUPPORTED\n      else if (chunk_name == png_iCCP)\n         png_handle_iCCP(png_ptr, info_ptr, length);\n#endif\n\n#ifdef PNG_READ_sPLT_SUPPORTED\n      else if (chunk_name == png_sPLT)\n         png_handle_sPLT(png_ptr, info_ptr, length);\n#endif\n\n#ifdef PNG_READ_tEXt_SUPPORTED\n      else if (chunk_name == png_tEXt)\n         png_handle_tEXt(png_ptr, info_ptr, length);\n#endif\n\n#ifdef PNG_READ_tIME_SUPPORTED\n      else if (chunk_name == png_tIME)\n         png_handle_tIME(png_ptr, info_ptr, length);\n#endif\n\n#ifdef PNG_READ_tRNS_SUPPORTED\n      else if (chunk_name == png_tRNS)\n         png_handle_tRNS(png_ptr, info_ptr, length);\n#endif\n\n#ifdef PNG_READ_zTXt_SUPPORTED\n      else if (chunk_name == png_zTXt)\n         png_handle_zTXt(png_ptr, info_ptr, length);\n#endif\n\n#ifdef PNG_READ_iTXt_SUPPORTED\n      else if (chunk_name == png_iTXt)\n         png_handle_iTXt(png_ptr, info_ptr, length);\n#endif\n\n      else\n         png_handle_unknown(png_ptr, info_ptr, length,\n             PNG_HANDLE_CHUNK_AS_DEFAULT);\n   }\n}\n\n\n\n\n\n\n\n\n\n\n\nvoid Magick::Image::ping(const Blob& blob_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=PingBlob(imageInfo(),blob_.data(),blob_.length(),exceptionInfo);\n  read(newImage,exceptionInfo);\n}\n\n\n// target function\n    (void) printf(\" Found a generic profile, type %s\\n\",&text[ii].key[17]);\n\n  return MagickTrue;\n}\n\n#if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)\n\nstatic int read_user_chunk_callback(png_struct *ping, png_unknown_chunkp chunk)\n{\n  Image\n    *image;\n\n\n  /* The unknown chunk structure contains the chunk data:\n     png_byte name[5];\n     png_byte *data;\n     png_size_t size;\n\n     Note that libpng has already taken care of the CRC handling.\n\n     Returns one of the following:\n         return(-n);  chunk had an error\n         return(0);  did not recognize\n         return(n);  success\n  */\n\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n     \"    read_user_chunk: found %c%c%c%c chunk\",\n       chunk->name[0],chunk->name[1],chunk->name[2],chunk->name[3]);\n\n  if (chunk->name[0]  == 101 &&\n      (chunk->name[1] ==  88 || chunk->name[1] == 120 ) &&\n      chunk->name[2] ==   73 &&\n      chunk-> name[3] == 102)\n    {\n      /* process eXIf or exIf chunk */\n\n      PNGErrorInfo\n        *error_info;\n\n      StringInfo\n        *profile;\n\n      unsigned char\n        *p;\n\n      png_byte\n        *s;\n\n      size_t\n        i;\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \" recognized eXIf chunk\");\n\n      image=(Image *) png_get_user_chunk_ptr(ping);\n\n      error_info=(PNGErrorInfo *) png_get_error_ptr(ping);\n\n      profile=BlobToStringInfo((const void *) NULL,chunk->size+6);\n\n      if (profile == (StringInfo *) NULL)\n        {\n          (void) ThrowMagickException(error_info->exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\n            image->filename);\n          return(-1);\n        }\n      p=GetStringInfoDatum(profile);\n\n      /* Initialize profile with \"Exif\\0\\0\" */\n      *p++ ='E';\n      *p++ ='x';\n      *p++ ='i';\n      *p++ ='f';\n      *p++ ='\\0';\n      *p++ ='\\0';\n\n      s=chunk->data;\n      i=0;\n      if (chunk->size > 6)\n        {\n          /* Skip first 6 bytes if \"Exif\\0\\0\" is\n             already present by accident\n          */\n          if (s[0] == 'E' && s[1] == 'x'  && s[2] == 'i' &&\n              s[3] == 'f' && s[4] == '\\0' && s[5] == '\\0')\n          {\n            s+=6;\n            i=6;\n            SetStringInfoLength(profile,chunk->size);\n          }\n        }\n\n      /* copy chunk->data to profile */\n      for (; i<chunk->size; i++)\n        *p++ = *s++;\n\n      error_info=(PNGErrorInfo *) png_get_error_ptr(ping);\n      (void) SetImageProfile(image,\"exif\",profile,\n        error_info->exception);\n\n      profile=DestroyStringInfo(profile);\n\n      return(1);\n    }\n\n  /* orNT */\n  if (chunk->name[0] == 111 &&\n      chunk->name[1] == 114 &&\n      chunk->name[2] ==  78 &&\n      chunk->name[3] ==  84)\n    {\n     /* recognized orNT */\n     if (chunk->size != 1)\n       return(-1); /* Error return */\n\n     image=(Image *) png_get_user_chunk_ptr(ping);\n\n     image->orientation=\n       Magick_Orientation_from_Exif_Orientation((int) chunk->data[0]);\n\n     return(1);\n    }\n\n  /* vpAg (deprecated, replaced by caNv) */\n  if (chunk->name[0] == 118 &&\n      chunk->name[1] == 112 &&\n      chunk->name[2] ==  65 &&\n      chunk->name[3] == 103)\n    {\n      /* recognized vpAg */\n\n      if (chunk->size != 9)\n        return(-1); /* Error return */\n\n      if (chunk->data[8] != 0)\n        return(0);  /* ImageMagick requires pixel units */\n\n      image=(Image *) png_get_user_chunk_ptr(ping);\n\n      image->page.width=(size_t)mng_get_long(chunk->data);\n      image->page.height=(size_t)mng_get_long(&chunk->data[4]);\n\n      return(1);\n    }\n\n  /* caNv */\n  if (chunk->name[0] ==  99 &&\n      chunk->name[1] ==  97 &&\n      chunk->name[2] ==  78 &&\n      chunk->name[3] == 118)\n    {\n      /* recognized caNv */\n\n      if (chunk->size != 16)\n        return(-1); /* Error return */\n\n      image=(Image *) png_get_user_chunk_ptr(ping);\n\n      image->page.width=(size_t)mng_get_long(chunk->data);\n      image->page.height=(size_t)mng_get_long(&chunk->data[4]);\n      image->page.x=(size_t)mng_get_long(&chunk->data[8]);\n",
    "target": 1,
    "idx": 1007534,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nbool\nTunnelIPv6Interface::remove_address(const struct in6_addr *addr, int prefixlen)\n{\n\tbool ret = false;\n\n\trequire_action(!IN6_IS_ADDR_UNSPECIFIED(addr), bail, mLastError = EINVAL);\n\n\tif (mUnicastAddresses.count(*addr)) {\n\t\tmUnicastAddresses.erase(*addr);\n\t}\n\n\tif (netif_mgmt_remove_ipv6_address(mNetifMgmtFD, mInterfaceName.c_str(), addr->s6_addr) != 0) {\n\t\tmLastError = errno;\n\t\tgoto bail;\n\t}\n\n\tsyslog(LOG_INFO,\"Removing address \\\"%s\\\" from interface \\\"%s\\\"\",\n\t       in6_addr_to_string(*addr).c_str(), mInterfaceName.c_str());\n\tret = true;\n\nbail:\n\treturn ret;\n}\n\nvoid\nNCPInstanceBase::unicast_address_was_removed(Origin origin, const struct in6_addr &address)\n{\n\tif (mUnicastAddresses.count(address)) {\n\t\tUnicastAddressEntry entry = mUnicastAddresses[address];\n\n\t\t// Allow address remove if origin is user, or if it matches the\n\t\t// originator of the entry (when it was previously added).\n\n\t\tif ((origin == kOriginUser) || (origin == entry.get_origin())) {\n\t\t\tsyslog(LOG_INFO, \"UnicastAddresses: Removing %s\", entry.get_description(address).c_str());\n\t\t\tmUnicastAddresses.erase(address);\n\n\t\t\tif ((origin == kOriginThreadNCP) || (origin == kOriginUser)) {\n\t\t\t\tmPrimaryInterface->remove_address(&address, entry.get_prefix_len());\n\t\t\t}\n\n\t\t\tif ((origin == kOriginPrimaryInterface) || (origin == kOriginUser)) {\n\t\t\t\tremove_address_on_ncp_and_update_prefixes(address, entry);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid\nNCPInstanceBase::on_mesh_prefix_was_removed(Origin origin, const struct in6_addr &prefix_address, uint8_t prefix_len,\n\tuint8_t flags, bool stable, uint16_t rloc16, CallbackWithStatus cb)\n{\n\tIPv6Prefix prefix(prefix_address, prefix_len);\n\tOnMeshPrefixEntry entry(origin, flags, stable, rloc16);\n\tstd::multimap<IPv6Prefix, OnMeshPrefixEntry>::iterator iter;\n\n\titer = find_prefix_entry(prefix, entry);\n\n\tif (iter != mOnMeshPrefixes.end()) {\n\t\tsyslog(LOG_INFO, \"OnMeshPrefixes: Removing %s\", entry.get_description(prefix).c_str());\n\t\tmOnMeshPrefixes.erase(iter);\n\n\t\tif (origin != kOriginThreadNCP) {\n\t\t\tremove_on_mesh_prefix_on_ncp(prefix.get_prefix(), prefix.get_length(),\n\t\t\t\tentry.get_flags(), entry.is_stable(),\n\t\t\t\tboost::bind(&NCPInstanceBase::check_ncp_entry_update_status, this, _1, \"removing on-mesh prefix\", cb));\n\t\t} else {\n\t\t\tcb(kWPANTUNDStatus_Ok);\n\t\t}\n\n\t\tif (entry.is_on_mesh() && entry.is_slaac() && prefix.get_length() == kSLAACPrefixLength\n\t\t\t&& !has_slaac_on_mesh_prefix(prefix)\n\t\t) {\n\t\t\tstd::map<struct in6_addr, UnicastAddressEntry>::iterator addr_iter;\n\n\t\t\t// Note that SLAAC addresses are added with origin NCP.\n\t\t\taddr_iter = find_address_with_prefix(prefix, kOriginThreadNCP);\n\n\t\t\tif (addr_iter != mUnicastAddresses.end()) {\n\t\t\t\tstruct in6_addr address = addr_iter->first;\n\t\t\t\tsyslog(LOG_NOTICE, \"Removing SLAAC address %s/%d from NCP\", in6_addr_to_string(address).c_str(), prefix_len);\n\t\t\t\tremove_unicast_address_on_ncp(address, prefix_len,\n\t\t\t\t\tboost::bind(&NCPInstanceBase::check_ncp_entry_update_status, this, _1, \"removing SLAAC address\", NilReturn()));\n\t\t\t\tunicast_address_was_removed(kOriginThreadNCP, address);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tcb(kWPANTUNDStatus_Ok);\n\t}\n}\n\nvoid\nSpinelNCPInstance::handle_ncp_spinel_value_is_ON_MESH_NETS(const uint8_t *value_data_ptr, spinel_size_t value_data_len)\n{\n\tstd::multimap<IPv6Prefix, OnMeshPrefixEntry>::iterator iter;\n\tstd::multimap<IPv6Prefix, OnMeshPrefixEntry> on_mesh_prefixes(mOnMeshPrefixes);\n\tint num_prefix = 0;\n\n\twhile (value_data_len > 0) {\n\t\tspinel_ssize_t len = 0;\n\t\tstruct in6_addr *prefix_addr = NULL;\n\t\tuint8_t prefix_len = 0;\n\t\tbool stable = false;\n\t\tuint8_t flags = 0;\n\t\tbool is_local = false;\n\t\tuint16_t rloc16 = 0;\n\n\t\tlen = spinel_datatype_unpack(\n\t\t\tvalue_data_ptr,\n\t\t\tvalue_data_len,\n\t\t\tSPINEL_DATATYPE_STRUCT_S(\n\t\t\t\tSPINEL_DATATYPE_IPv6ADDR_S // Prefix\n\t\t\t\tSPINEL_DATATYPE_UINT8_S    // Prefix length (in bits)\n\t\t\t\tSPINEL_DATATYPE_BOOL_S     // stable\n\t\t\t\tSPINEL_DATATYPE_UINT8_S    // flags\n\t\t\t\tSPINEL_DATATYPE_BOOL_S     // is_local\n\t\t\t\tSPINEL_DATATYPE_UINT16_S   // RLOC16\n\t\t\t),\n\t\t\t&prefix_addr,\n\t\t\t&prefix_len,\n\t\t\t&stable,\n\t\t\t&flags,\n\t\t\t&is_local,\n\t\t\t&rloc16\n\t\t);\n\n\t\tif (len <= 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tsyslog(\n\t\t\tLOG_INFO,\n\t\t\t\"[-NCP-]: On-mesh net [%d] \\\"%s/%d\\\" stable:%s local:%s flags:%s, rloc16:0x%04x\",\n\t\t\tnum_prefix,\n\t\t\tin6_addr_to_string(*prefix_addr).c_str(),\n\t\t\tprefix_len,\n\t\t\tstable ? \"yes\" : \"no\",\n\t\t\tis_local ? \"yes\" : \"no\",\n\t\t\ton_mesh_prefix_flags_to_string(flags).c_str(),\n\t\t\trloc16\n\t\t);\n\n\t\tnum_prefix++;\n\n\t\tif (!is_local) {\n\n\t\t\t// Go through the `on_mesh_prefixes` list (which is the copy of mOnMeshPrefixes)\n\t\t\t// and check if this entry is already on the list, if so remove it.\n\n\t\t\tIPv6Prefix prefix(*prefix_addr, prefix_len);\n\t\t\tOnMeshPrefixEntry entry(kOriginThreadNCP, flags, stable, rloc16);\n\n\t\t\titer = on_mesh_prefixes.lower_bound(prefix);\n\n\t\t\tif (iter != on_mesh_prefixes.end()) {\n\t\t\t\tstd::multimap<IPv6Prefix, OnMeshPrefixEntry>::iterator upper_iter = on_mesh_prefixes.upper_bound(prefix);\n\n\t\t\t\tfor (; iter != upper_iter; ++iter) {\n\t\t\t\t\tif (iter->second == entry) {\n\t\t\t\t\t\ton_mesh_prefixes.erase(iter);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ton_mesh_prefix_was_added(kOriginThreadNCP, *prefix_addr, prefix_len, flags, stable, rloc16);\n\t\t}\n\n\t\tvalue_data_ptr += len;\n\t\tvalue_data_len -= len;\n\t}\n\n\t// Since this was the whole list, we need to remove any prefixes\n\t// which originated from NCP that that weren't in the new list.\n\n\tfor (iter = on_mesh_prefixes.begin(); iter != on_mesh_prefixes.end(); ++iter) {\n\t\tif (iter->second.is_from_ncp()) {\n\t\t\ton_mesh_prefix_was_removed(\n\t\t\t\tkOriginThreadNCP,\n\t\t\t\titer->first.get_prefix(),\n\t\t\t\titer->first.get_length(),\n\t\t\t\titer->second.get_flags(),\n\t\t\t\titer->second.is_stable(),\n\t\t\t\titer->second.get_rloc()\n\t\t\t);\n\t\t}\n\t}\n}\n\nvoid\nSpinelNCPInstance::handle_ncp_spinel_value_is(spinel_prop_key_t key, const uint8_t* value_data_ptr, spinel_size_t value_data_len)\n{\n\tconst uint8_t *original_value_data_ptr = value_data_ptr;\n\tspinel_size_t original_value_data_len = value_data_len;\n\n\tif (key == SPINEL_PROP_LAST_STATUS) {\n\t\tspinel_status_t status = SPINEL_STATUS_OK;\n\t\tspinel_datatype_unpack(value_data_ptr, value_data_len, \"i\", &status);\n\t\tsyslog(LOG_INFO, \"[-NCP-]: Last status (%s, %d)\", spinel_status_to_cstr(status), status);\n\t\tif ((status >= SPINEL_STATUS_RESET__BEGIN) && (status <= SPINEL_STATUS_RESET__END)) {\n\t\t\tsyslog(LOG_NOTICE, \"[-NCP-]: NCP was reset (%s, %d)\", spinel_status_to_cstr(status), status);\n\t\t\tprocess_event(EVENT_NCP_RESET, status);\n\t\t\tif (!mResetIsExpected && (mDriverState == NORMAL_OPERATION)) {\n\t\t\t\twpantund_status_t wstatus = kWPANTUNDStatus_NCP_Reset;\n\t\t\t\tswitch(status) {\n\t\t\t\tcase SPINEL_STATUS_RESET_CRASH:\n\t\t\t\tcase SPINEL_STATUS_RESET_FAULT:\n\t\t\t\tcase SPINEL_STATUS_RESET_ASSERT:\n\t\t\t\tcase SPINEL_STATUS_RESET_WATCHDOG:\n\t\t\t\tcase SPINEL_STATUS_RESET_OTHER:\n\t\t\t\t\twstatus = kWPANTUNDStatus_NCP_Crashed;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treset_tasks(wstatus);\n\t\t\t}\n\n\t\t\tif (mDriverState == NORMAL_OPERATION) {\n\t\t\t\treinitialize_ncp();\n\t\t\t}\n\t\t\tmResetIsExpected = false;\n\t\t\treturn;\n\t\t} else if ((status >= SPINEL_STATUS_JOIN__BEGIN) && (status <= SPINEL_STATUS_JOIN__END)) {\n\t\t\tif (status == SPINEL_STATUS_JOIN_SUCCESS) {\n\t\t\t\tchange_ncp_state(COMMISSIONED);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tchange_ncp_state(CREDENTIALS_NEEDED);\n\t\t\t}\n\t\t} else if (status == SPINEL_STATUS_INVALID_COMMAND) {\n\t\t\tsyslog(LOG_NOTICE, \"[-NCP-]: COMMAND NOT RECOGNIZED\");\n\t\t}\n\t} else if (key == SPINEL_PROP_NCP_VERSION) {\n\t\tconst char* ncp_version = NULL;\n\t\tspinel_ssize_t len = spinel_datatype_unpack(value_data_ptr, value_data_len, \"U\", &ncp_version);\n\t\tif ((len <= 0) || (ncp_version == NULL)) {\n\t\t\tsyslog(LOG_CRIT, \"[-NCP-]: Got a corrupted NCP version\");\n\t\t\t// TODO: Properly handle NCP Misbehavior\n\t\t\tchange_ncp_state(FAULT);\n\t\t} else {\n\t\t\tset_ncp_version_string(ncp_version);\n\t\t}\n\n\t} else if (key == SPINEL_PROP_INTERFACE_TYPE) {\n\t\tunsigned int interface_type = 0;\n\t\tspinel_datatype_unpack(value_data_ptr, value_data_len, \"i\", &interface_type);\n\n\t\tif (interface_type != SPINEL_PROTOCOL_TYPE_THREAD) {\n\t\t\tsyslog(LOG_CRIT, \"[-NCP-]: NCP is using unsupported protocol type (%d)\", interface_type);\n\t\t\tchange_ncp_state(FAULT);\n\t\t}\n\n\t} else if (key == SPINEL_PROP_PROTOCOL_VERSION) {\n\t\tunsigned int protocol_version_major = 0;\n\t\tunsigned int protocol_version_minor = 0;\n\t\tspinel_datatype_unpack(value_data_ptr, value_data_len, \"ii\", &protocol_version_major, &protocol_version_minor);\n\n\t\tif (protocol_version_major != SPINEL_PROTOCOL_VERSION_THREAD_MAJOR) {\n\t\t\tsyslog(LOG_CRIT, \"[-NCP-]: NCP is using unsupported protocol version (NCP:%d, wpantund:%d)\", protocol_version_major, SPINEL_PROTOCOL_VERSION_THREAD_MAJOR);\n\t\t\tchange_ncp_state(FAULT);\n\t\t}\n\n\t\tif (protocol_version_minor != SPINEL_PROTOCOL_VERSION_THREAD_MINOR) {\n\t\t\tsyslog(LOG_WARNING, \"[-NCP-]: NCP is using different protocol minor version (NCP:%d, wpantund:%d)\", protocol_version_minor, SPINEL_PROTOCOL_VERSION_THREAD_MINOR);\n\t\t}\n\n\t} else if (key == SPINEL_PROP_CAPS) {\n\t\tconst uint8_t* data_ptr = value_data_ptr;\n\t\tspinel_size_t data_len = value_data_len;\n\t\tstd::set<unsigned int> capabilities;\n\n\t\twhile(data_len != 0) {\n\t\t\tunsigned int value = 0;\n\t\t\tspinel_ssize_t parse_len = spinel_datatype_unpack(data_ptr, data_len, SPINEL_DATATYPE_UINT_PACKED_S, &value);\n\t\t\tif (parse_len <= 0) {\n\t\t\t\tsyslog(LOG_WARNING, \"[-NCP-]: Capability Parse failure\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcapabilities.insert(value);\n\t\t\tsyslog(LOG_INFO, \"[-NCP-]: Capability (%s, %d)\", spinel_capability_to_cstr(value), value);\n\n\t\t\tdata_ptr += parse_len;\n\t\t\tdata_len -= parse_len;\n\t\t}\n\n\t\tif (capabilities != mCapabilities) {\n\t\t\tmCapabilities = capabilities;\n\t\t}\n\n\t} else if (key == SPINEL_PROP_NET_NETWORK_NAME) {\n\t\tconst char* value = NULL;\n\t\tspinel_ssize_t len = spinel_datatype_unpack(value_data_ptr, value_data_len, \"U\", &value);\n\n\t\tif ((len <= 0) || (value == NULL)) {\n\t\t\tsyslog(LOG_CRIT, \"[-NCP-]: Got a corrupted NCP version\");\n\t\t\t// TODO: Properly handle NCP Misbehavior\n\t\t\tchange_ncp_state(FAULT);\n\t\t} else {\n\t\t\tsyslog(LOG_INFO, \"[-NCP-]: Network name \\\"%s\\\"\", value);\n\t\t\tif (mCurrentNetworkInstance.name != value) {\n\t\t\t\tmCurrentNetworkInstance.name = value;\n\t\t\t\tsignal_property_changed(kWPANTUNDProperty_NetworkName, mCurrentNetworkInstance.name);\n\t\t\t}\n\t\t}\n\n\t} else if (key == SPINEL_PROP_MCU_POWER_STATE) {\n\t\tuint8_t power_state = 0;\n\t\tspinel_ssize_t len = 0;\n\n\t\tlen  = spinel_datatype_unpack(value_data_ptr, value_data_len, SPINEL_DATATYPE_UINT8_S, &power_state);\n\n\t\tif (len > 0) {\n\t\t\tsyslog(LOG_INFO, \"[-NCP-]: MCU power state \\\"%s\\\" (%d)\",\n\t\t\t\tspinel_mcu_power_state_to_cstr(static_cast<spinel_mcu_power_state_t>(power_state)), power_state);\n\n\t\t\tswitch (get_ncp_state()) {\n\t\t\tcase OFFLINE:\n\t\t\tcase COMMISSIONED:\n\t\t\t\tif (power_state == SPINEL_MCU_POWER_STATE_LOW_POWER) {\n\t\t\t\t\tchange_ncp_state(DEEP_SLEEP);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DEEP_SLEEP:\n\t\t\t\tif (power_state == SPINEL_MCU_POWER_STATE_ON) {\n\t\t\t\t\tchange_ncp_state(mIsCommissioned ? COMMISSIONED : OFFLINE);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t} else if (key == SPINEL_PROP_IPV6_LL_ADDR) {\n\t\tstruct in6_addr *addr = NULL;\n\n\t\tspinel_datatype_unpack(value_data_ptr, value_data_len, \"6\", &addr);\n\t\tif (addr != NULL) {\n\t\t\tsyslog(LOG_INFO, \"[-NCP-]: Link-local IPv6 address \\\"%s\\\"\", in6_addr_to_string(*addr).c_str());\n\t\t}\n\t\tupdate_link_local_address(addr);\n\n\t} else if (key == SPINEL_PROP_IPV6_ML_ADDR) {\n\t\tstruct in6_addr *addr = NULL;\n\t\tspinel_datatype_unpack(value_data_ptr, value_data_len, \"6\", &addr);\n\t\tif (addr != NULL) {\n\t\t\tsyslog(LOG_INFO, \"[-NCP-]: Mesh-local IPv6 address \\\"%s\\\"\", in6_addr_to_string(*addr).c_str());\n\t\t}\n\t\tupdate_mesh_local_address(addr);\n\n\t} else if (key == SPINEL_PROP_IPV6_ML_PREFIX) {\n\t\tstruct in6_addr *addr = NULL;\n\t\tspinel_datatype_unpack(value_data_ptr, value_data_len, \"6\", &addr);\n\t\tif (addr != NULL) {\n\t\t\tsyslog(LOG_INFO, \"[-NCP-]: Mesh-local prefix \\\"%s\\\"\", (in6_addr_to_string(*addr) + \"/64\").c_str());\n\t\t}\n\t\tupdate_mesh_local_prefix(addr);\n\n\t} else if (key == SPINEL_PROP_IPV6_ADDRESS_TABLE) {\n\t\tstd::map<struct in6_addr, UnicastAddressEntry>::const_iterator iter;\n\t\tstd::map<struct in6_addr, UnicastAddressEntry> unicast_addresses(mUnicastAddresses);\n\t\tconst struct in6_addr *addr = NULL;\n\t\tint num_address = 0;\n\n\t\twhile (value_data_len > 0) {\n\t\t\tconst uint8_t *entry_ptr = NULL;\n\t\t\tspinel_size_t entry_len = 0;\n\t\t\tspinel_ssize_t len = 0;\n\t\t\tlen = spinel_datatype_unpack(value_data_ptr, value_data_len, \"D.\", &entry_ptr, &entry_len);\n\t\t\tif (len < 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\taddr = reinterpret_cast<const struct in6_addr*>(entry_ptr);\n\t\t\tsyslog(LOG_INFO, \"[-NCP-]: IPv6 address [%d] \\\"%s\\\"\", num_address, in6_addr_to_string(*addr).c_str());\n\t\t\tnum_address++;\n\t\t\tunicast_addresses.erase(*addr);\n\t\t\thandle_ncp_spinel_value_inserted(key, entry_ptr, entry_len);\n\n\t\t\tvalue_data_ptr += len;\n\t\t\tvalue_data_len -= len;\n\t\t}\n\n\t\tsyslog(LOG_INFO, \"[-NCP-]: IPv6 address: Total %d address%s\", num_address, (num_address > 1) ? \"es\" : \"\");\n\n\t\t// Since this was the whole list, we need to remove the addresses\n\t\t// which originated from NCP that that weren't in the list.\n\t\tfor (iter = unicast_addresses.begin(); iter != unicast_addresses.end(); ++iter) {\n\t\t\tif (iter->second.is_from_ncp()) {\n\t\t\t\tunicast_address_was_removed(kOriginThreadNCP, iter->first);\n\t\t\t}\n\t\t}\n\n\t} else if (key == SPINEL_PROP_IPV6_MULTICAST_ADDRESS_TABLE) {\n\t\tstd::map<struct in6_addr, MulticastAddressEntry>::const_iterator iter;\n\t\tstd::map<struct in6_addr, MulticastAddressEntry> multicast_addresses(mMulticastAddresses);\n\t\tconst struct in6_addr *addr = NULL;\n\t\tint num_address = 0;\n\n\t\twhile (value_data_len > 0) {\n\t\t\tconst uint8_t *entry_ptr = NULL;\n\t\t\tspinel_size_t entry_len = 0;\n\t\t\tspinel_ssize_t len = 0;\n\t\t\tlen = spinel_datatype_unpack(value_data_ptr, value_data_len, \"D.\", &entry_ptr, &entry_len);\n\t\t\tif (len < 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\taddr = reinterpret_cast<const struct in6_addr*>(entry_ptr);\n\t\t\tsyslog(LOG_INFO, \"[-NCP-]: Multicast IPv6 address [%d] \\\"%s\\\"\", num_address, in6_addr_to_string(*addr).c_str());\n\t\t\tnum_address++;\n\t\t\tmulticast_addresses.erase(*addr);\n\t\t\thandle_ncp_spinel_value_inserted(key, entry_ptr, entry_len);\n\n\t\t\tvalue_data_ptr += len;\n\t\t\tvalue_data_len -= len;\n\t\t}\n\n\t\t// Since this was the whole list, we need to remove the addresses\n\t\t// which originated from NCP that that weren't in the list.\n\t\tfor (iter = multicast_addresses.begin(); iter != multicast_addresses.end(); ++iter) {\n\t\t\tif (iter->second.is_from_ncp()) {\n\t\t\t\tmulticast_address_was_left(kOriginThreadNCP, iter->first);\n\t\t\t}\n\t\t}\n\n\t} else if (key == SPINEL_PROP_HWADDR) {\n\t\tnl::Data hwaddr(value_data_ptr, value_data_len);\n\t\tif (value_data_len == sizeof(mMACHardwareAddress)) {\n\t\t\tset_mac_hardware_address(value_data_ptr);\n\t\t}\n\n\t} else if (key == SPINEL_PROP_MAC_15_4_LADDR) {\n\t\tnl::Data hwaddr(value_data_ptr, value_data_len);\n\t\tif (value_data_len == sizeof(mMACAddress)) {\n\t\t\tset_mac_address(value_data_ptr);\n\t\t}\n\n\t} else if (key == SPINEL_PROP_MAC_15_4_PANID) {\n\t\tuint16_t panid;\n\t\tspinel_datatype_unpack(value_data_ptr, value_data_len, SPINEL_DATATYPE_UINT16_S, &panid);\n\t\tsyslog(LOG_INFO, \"[-NCP-]: PANID 0x%04X\", panid);\n\t\tif (panid != mCurrentNetworkInstance.panid) {\n\t\t\tmCurrentNetworkInstance.panid = panid;\n\t\t\tsignal_property_changed(kWPANTUNDProperty_NetworkPANID, panid);\n\t\t}\n\n\t} else if (key == SPINEL_PROP_NET_XPANID) {\n\t\tnl::Data xpanid(value_data_ptr, value_data_len);\n\t\tchar cstr_buf[200];\n\t\tencode_data_into_string(value_data_ptr, value_data_len, cstr_buf, sizeof(cstr_buf), 0);\n\t\tsyslog(LOG_INFO, \"[-NCP-] XPANID 0x%s\", cstr_buf);\n\n\t\tif ((value_data_len == 8) && 0 != memcmp(xpanid.data(), mCurrentNetworkInstance.xpanid, 8)) {\n\t\t\tmemcpy(mCurrentNetworkInstance.xpanid, xpanid.data(), 8);\n\t\t\tsignal_property_changed(kWPANTUNDProperty_NetworkXPANID, xpanid);\n\t\t}\n\n\t} else if (key == SPINEL_PROP_NET_PSKC) {\n\t\tnl::Data network_pskc(value_data_ptr, value_data_len);\n\t\tif (network_pskc != mNetworkPSKc) {\n\t\t\tmNetworkPSKc = network_pskc;\n\t\t\tsignal_property_changed(kWPANTUNDProperty_NetworkPSKc, mNetworkPSKc);\n\t\t}\n\n\t} else if (key == SPINEL_PROP_NET_MASTER_KEY) {\n\t\tnl::Data network_key(value_data_ptr, value_data_len);\n\t\tif (ncp_state_is_joining_or_joined(get_ncp_state())) {\n\t\t\tif (network_key != mNetworkKey) {\n\t\t\t\tmNetworkKey = network_key;\n\t\t\t\tsignal_property_changed(kWPANTUNDProperty_NetworkKey, mNetworkKey);\n\t\t\t}\n\t\t}\n\n\t} else if (key == SPINEL_PROP_NET_KEY_SEQUENCE_COUNTER) {\n\t\tuint32_t network_key_index = 0;\n\t\tspinel_ssize_t ret;\n\n\t\tret = spinel_datatype_unpack(value_data_ptr, value_data_len, SPINEL_DATATYPE_UINT32_S, &network_key_index);\n\n\t\t__ASSERT_MACROS_check(ret > 0);\n\n\t\tif ((ret > 0) && (network_key_index != mNetworkKeyIndex)) {\n\t\t\tmNetworkKeyIndex = network_key_index;\n\t\t\tsignal_property_changed(kWPANTUNDProperty_NetworkKeyIndex, mNetworkKeyIndex);\n\t\t}\n\n\t} else if (key == SPINEL_PROP_PHY_CHAN) {\n\t\tunsigned int value = 0;\n\t\tspinel_ssize_t ret;\n\n\t\tret = spinel_datatype_unpack(value_data_ptr, value_data_len, SPINEL_DATATYPE_UINT_PACKED_S, &value);\n\n\t\t__ASSERT_MACROS_check(ret > 0);\n\n\t\tif (ret > 0) {\n\t\t\tsyslog(LOG_INFO, \"[-NCP-]: Channel %d\", value);\n\t\t\tif (value != mCurrentNetworkInstance.channel) {\n\t\t\t\tmCurrentNetworkInstance.channel = value;\n\t\t\t\tsignal_property_changed(kWPANTUNDProperty_NCPChannel, mCurrentNetworkInstance.channel);\n\t\t\t}\n\t\t}\n\n\t} else if (key == SPINEL_PROP_PHY_CHAN_SUPPORTED) {\n\t\tboost::any mask_value;\n\t\tint ret = unpack_channel_mask(value_data_ptr, value_data_len, mask_value);\n\n\t\tif (ret == kWPANTUNDStatus_Ok) {\n\t\t\tmSupportedChannelMask = any_to_int(mask_value);\n\t\t\tsyslog(LOG_INFO, \"[-NCP-]: Supported Channel Mask 0x%x\", mSupportedChannelMask);\n\t\t}\n\n\t} else if (key == SPINEL_PROP_PHY_TX_POWER) {\n\t\tint8_t value = 0;\n\t\tspinel_ssize_t ret;\n\n\t\tret = spinel_datatype_unpack(value_data_ptr, value_data_len, SPINEL_DATATYPE_INT8_S, &value);\n\n\t\t__ASSERT_MACROS_check(ret > 0);\n\n\t\tif (ret > 0) {\n\t\t\tsyslog(LOG_INFO, \"[-NCP-]: Tx power %d\", value);\n\t\t\tif (value != mTXPower) {\n\t\t\t\tmTXPower = value;\n\t\t\t\tsignal_property_changed(kWPANTUNDProperty_NCPTXPower, mTXPower);\n\t\t\t}\n\t\t}\n\n\t} else if (key == SPINEL_PROP_STREAM_DEBUG) {\n\t\thandle_ncp_debug_stream(value_data_ptr, value_data_len);\n\n\t} else if (key == SPINEL_PROP_STREAM_LOG) {\n\t\thandle_ncp_log_stream(value_data_ptr, value_data_len);\n\n\t} else if (key == SPINEL_PROP_NET_ROLE) {\n\t\tuint8_t value = 0;\n\t\tspinel_ssize_t ret;\n\n\t\tret = spinel_datatype_unpack(value_data_ptr, value_data_len, SPINEL_DATATYPE_UINT8_S, &value);\n\n\t\t__ASSERT_MACROS_check(ret > 0);\n\n\t\tif (ret > 0) {\n\t\t\tsyslog(LOG_INFO, \"[-NCP-]: Net Role \\\"%s\\\" (%d)\", spinel_net_role_to_cstr(value), value);\n\n\t\t\tif (ncp_state_is_joining_or_joined(get_ncp_state())\n\t\t\t  && (value != SPINEL_NET_ROLE_DETACHED)\n\t\t\t) {\n\t\t\t\tchange_ncp_state(ASSOCIATED);\n\t\t\t}\n\n\t\t\tif (value == SPINEL_NET_ROLE_CHILD) {\n\t\t\t\tif ((mThreadMode & SPINEL_THREAD_MODE_RX_ON_WHEN_IDLE) != 0) {\n\t\t\t\t\tupdate_node_type(END_DEVICE);\n\t\t\t\t} else {\n\t\t\t\t\tupdate_node_type(SLEEPY_END_DEVICE);\n\t\t\t\t}\n\n\t\t\t} else if (value == SPINEL_NET_ROLE_ROUTER) {\n\t\t\t\tupdate_node_type(ROUTER);\n\n\t\t\t} else if (value == SPINEL_NET_ROLE_LEADER) {\n\t\t\t\tupdate_node_type(LEADER);\n\n\t\t\t} else if (value == SPINEL_NET_ROLE_DETACHED) {\n\t\t\t\tupdate_node_type(UNKNOWN);\n\t\t\t\tif (ncp_state_is_associated(get_ncp_state())) {\n\t\t\t\t\tchange_ncp_state(ISOLATED);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t} else if (key == SPINEL_PROP_THREAD_MODE) {\n\t\tuint8_t value = mThreadMode;\n\t\tspinel_ssize_t ret;\n\n\t\tret = spinel_datatype_unpack(value_data_ptr, value_data_len, SPINEL_DATATYPE_UINT8_S, &value);\n\n\t\t__ASSERT_MACROS_check(ret > 0);\n\n\t\tif (ret > 0) {\n\t\t\tsyslog(LOG_INFO, \"[-NCP-]: Thread Mode \\\"%s\\\" (0x%02x)\", thread_mode_to_string(value).c_str(), value);\n\t\t\tmThreadMode = value;\n\n\t\t\tswitch (get_ncp_state())\n\t\t\t{\n\t\t\tcase ISOLATED:\n\t\t\t\tif ((mThreadMode & SPINEL_THREAD_MODE_RX_ON_WHEN_IDLE) != 0) {\n\t\t\t\t\tchange_ncp_state(ASSOCIATING);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase ASSOCIATING:\n\t\t\t\tif (mIsCommissioned && ((mThreadMode & SPINEL_THREAD_MODE_RX_ON_WHEN_IDLE) == 0)) {\n\t\t\t\t\tchange_ncp_state(ISOLATED);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch (mNodeType)\n\t\t\t{\n\t\t\tcase END_DEVICE:\n\t\t\tcase SLEEPY_END_DEVICE:\n\t\t\t\tif ((mThreadMode & SPINEL_THREAD_MODE_RX_ON_WHEN_IDLE) != 0) {\n\t\t\t\t\tupdate_node_type(END_DEVICE);\n\t\t\t\t} else {\n\t\t\t\t\tupdate_node_type(SLEEPY_END_DEVICE);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t} else if (key == SPINEL_PROP_NET_SAVED) {\n\t\tbool is_commissioned = false;\n\t\tspinel_datatype_unpack(value_data_ptr, value_data_len, SPINEL_DATATYPE_BOOL_S, &is_commissioned);\n\t\tsyslog(LOG_INFO, \"[-NCP-]: NetSaved (NCP is commissioned?) \\\"%s\\\" \", is_commissioned ? \"yes\" : \"no\");\n\t\tmIsCommissioned = is_commissioned;\n\t\tif (mIsCommissioned && (get_ncp_state() == OFFLINE)) {\n\t\t\tchange_ncp_state(COMMISSIONED);\n\t\t} else if (!mIsCommissioned && (get_ncp_state() == COMMISSIONED)) {\n\t\t\tchange_ncp_state(OFFLINE);\n\t\t}\n\n\t} else if (key == SPINEL_PROP_NET_STACK_UP) {\n\t\tbool is_stack_up = false;\n\t\tspinel_datatype_unpack(value_data_ptr, value_data_len, SPINEL_DATATYPE_BOOL_S, &is_stack_up);\n\t\tsyslog(LOG_INFO, \"[-NCP-]: Stack is %sup\", is_stack_up ? \"\" : \"not \");\n\n\t\tif (is_stack_up) {\n\t\t\tif (!ncp_state_is_joining_or_joined(get_ncp_state())) {\n\t\t\t\tif (mIsCommissioned && ((mThreadMode & SPINEL_THREAD_MODE_RX_ON_WHEN_IDLE) == 0)) {\n\t\t\t\t\tchange_ncp_state(ISOLATED);\n\t\t\t\t} else {\n\t\t\t\t\tchange_ncp_state(ASSOCIATING);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (!ncp_state_is_joining(get_ncp_state())) {\n\t\t\t\tchange_ncp_state(mIsCommissioned ? COMMISSIONED : OFFLINE);\n\t\t\t}\n\t\t}\n\n\t} else if (key == SPINEL_PROP_NET_IF_UP) {\n\t\tbool is_if_up = false;\n\t\tspinel_datatype_unpack(value_data_ptr, value_data_len, SPINEL_DATATYPE_BOOL_S, &is_if_up);\n\t\tsyslog(LOG_INFO, \"[-NCP-]: Interface is %sup\", is_if_up ? \"\" : \"not \");\n\n\t\tif (ncp_state_is_interface_up(get_ncp_state()) && !is_if_up) {\n\t\t\tchange_ncp_state(mIsCommissioned ? COMMISSIONED : OFFLINE);\n\t\t}\n\n\t} else if (key == SPINEL_PROP_MESHCOP_COMMISSIONER_STATE) {\n\t\tboost::any value;\n\t\tint status;\n\t\tstatus = unpack_commissioner_state(value_data_ptr, value_data_len, value);\n\t\tif (status == kWPANTUNDStatus_Ok) {\n\t\t\tsyslog(LOG_INFO, \"[-NCP-]: Thread Commissioner state is \\\"%s\\\"\", any_to_string(value).c_str());\n\t\t}\n\n\t} else if (key == SPINEL_PROP_THREAD_ON_MESH_NETS) {\n\t\thandle_ncp_spinel_value_is_ON_MESH_NETS(value_data_ptr, value_data_len);\n\n\t} else if (key == SPINEL_PROP_THREAD_OFF_MESH_ROUTES) {\n\t\thandle_ncp_spinel_value_is_OFF_MESH_ROUTES(value_data_ptr, value_data_len);\n\n\t} else if (key == SPINEL_PROP_THREAD_ASSISTING_PORTS) {\n\t\tbool is_assisting = (value_data_len != 0);\n\t\tuint16_t assisting_port(0);\n\n\t\tif (is_assisting != get_current_network_instance().joinable) {\n\t\t\tmCurrentNetworkInstance.joinable = is_assisting;\n\t\t\tsignal_property_changed(kWPANTUNDProperty_NestLabs_NetworkAllowingJoin, is_assisting);\n\t\t}\n\n\t\tif (is_assisting) {\n\t\t\tint i;\n\t\t\tsyslog(LOG_NOTICE, \"Network is joinable\");\n\t\t\twhile (value_data_len > 0) {\n\t\t\t\ti = spinel_datatype_unpack(value_data_ptr, value_data_len, SPINEL_DATATYPE_UINT16_S, &assisting_port);\n\t\t\t\tif (i <= 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsyslog(LOG_NOTICE, \"Assisting on port %d\", assisting_port);\n\t\t\t\tvalue_data_ptr += i;\n\t\t\t\tvalue_data_len -= i;\n\t\t\t}\n\t\t} else {\n\t\t\tsyslog(LOG_NOTICE, \"Network is not joinable\");\n\t\t}\n\n\t} else if (key == SPINEL_PROP_JAM_DETECTED) {\n\t\tbool jamDetected = false;\n\n\t\tspinel_datatype_unpack(value_data_ptr, value_data_len, SPINEL_DATATYPE_BOOL_S, &jamDetected);\n\t\tsignal_property_changed(kWPANTUNDProperty_JamDetectionStatus, jamDetected);\n\n\t\tif (jamDetected) {\n\t\t\tsyslog(LOG_NOTICE, \"Signal jamming is detected\");\n\t\t} else {\n\t\t\tsyslog(LOG_NOTICE, \"Signal jamming cleared\");\n\t\t}\n\n\t} else if (key == SPINEL_PROP_CHANNEL_MANAGER_NEW_CHANNEL) {\n\t\tuint8_t new_channel = 0;\n\t\tspinel_ssize_t len;\n\n\t\tlen = spinel_datatype_unpack(value_data_ptr, value_data_len, SPINEL_DATATYPE_UINT8_S, &new_channel);\n\n\t\tif ((len >= 0) && (new_channel != mChannelManagerNewChannel)) {\n\t\t\tmChannelManagerNewChannel = new_channel;\n\t\t\tsignal_property_changed(kWPANTUNDProperty_ChannelManagerNewChannel, new_channel);\n\t\t\tsyslog(LOG_INFO, \"[-NCP-]: ChannelManager about to switch to new channel %d\", new_channel);\n\t\t}\n\n\t} else if (key == SPINEL_PROP_STREAM_RAW) {\n\t\tif (mPcapManager.is_enabled()) {\n\t\t\tconst uint8_t* frame_ptr(NULL);\n\t\t\tunsigned int frame_len(0);\n\t\t\tconst uint8_t* meta_ptr(NULL);\n\t\t\tunsigned int meta_len(0);\n\t\t\tspinel_ssize_t ret;\n\t\t\tPcapPacket packet;\n\t\t\tuint16_t flags = 0;\n\n\t\t\tpacket.set_timestamp().set_dlt(PCAP_DLT_IEEE802_15_4);\n\n\t\t\t// Unpack the packet.\n\t\t\tret = spinel_datatype_unpack(\n\t\t\t\tvalue_data_ptr,\n\t\t\t\tvalue_data_len,\n\t\t\t\tSPINEL_DATATYPE_DATA_WLEN_S SPINEL_DATATYPE_DATA_S,\n\t\t\t\t&frame_ptr,\n\t\t\t\t&frame_len,\n\t\t\t\t&meta_ptr,\n\t\t\t\t&meta_len\n\t\t\t);\n\n\t\t\trequire(ret > 0, bail);\n\n\t\t\t// Unpack the metadata.\n\t\t\tret = spinel_datatype_unpack(\n\t\t\t\tmeta_ptr,\n\t\t\t\tmeta_len,\n\t\t\t\tSPINEL_DATATYPE_INT8_S     // RSSI/TXPower\n\t\t\t\tSPINEL_DATATYPE_INT8_S     // Noise Floor\n\t\t\t\tSPINEL_DATATYPE_UINT16_S,  // Flags\n\t\t\t\tNULL,   // Ignore RSSI/TXPower\n\t\t\t\tNULL,\t// Ignore Noise Floor\n\t\t\t\t&flags\n\t\t\t);\n\n\t\t\t__ASSERT_MACROS_check(ret > 0);\n\n\t\t\tif ((flags & SPINEL_MD_FLAG_TX) == SPINEL_MD_FLAG_TX)\n\t\t\t{\n\t\t\t\t// Ignore FCS for transmitted packets\n\t\t\t\tframe_len -= 2;\n\t\t\t\tpacket.set_dlt(PCAP_DLT_IEEE802_15_4_NOFCS);\n\t\t\t}\n\n\t\t\tmPcapManager.push_packet(\n\t\t\t\tpacket\n\t\t\t\t\t.append_ppi_field(PCAP_PPI_TYPE_SPINEL, meta_ptr, meta_len)\n\t\t\t\t\t.append_payload(frame_ptr, frame_len)\n\t\t\t);\n\t\t}\n\n\t} else if (key == SPINEL_PROP_THREAD_TMF_PROXY_STREAM) {\n\t\tconst uint8_t* frame_ptr(NULL);\n\t\tunsigned int frame_len(0);\n\t\tuint16_t locator = 0;\n\t\tuint16_t port = 0;\n\t\tspinel_ssize_t ret;\n\t\tData data;\n\n\t\tret = spinel_datatype_unpack(\n\t\t\tvalue_data_ptr,\n\t\t\tvalue_data_len,\n\t\t\tSPINEL_DATATYPE_DATA_S SPINEL_DATATYPE_UINT16_S SPINEL_DATATYPE_UINT16_S,\n\t\t\t&frame_ptr,\n\t\t\t&frame_len,\n\t\t\t&locator,\n\t\t\t&port\n\t\t);\n\n\t\t__ASSERT_MACROS_check(ret > 0);\n\n\t\t// Analyze the packet to determine if it should be dropped.\n\t\tif ((ret > 0)) {\n\t\t\t// append frame\n\t\t\tdata.append(frame_ptr, frame_len);\n\t\t\t// pack the locator in big endian.\n\t\t\tdata.push_back(locator >> 8);\n\t\t\tdata.push_back(locator & 0xff);\n\t\t\t// pack the port in big endian.\n\t\t\tdata.push_back(port >> 8);\n\t\t\tdata.push_back(port & 0xff);\n\t\t\tsignal_property_changed(kWPANTUNDProperty_TmfProxyStream, data);\n\t\t}\n\n\t} else if (key == SPINEL_PROP_THREAD_UDP_PROXY_STREAM) {\n\t\tconst uint8_t* frame_ptr(NULL);\n\t\tunsigned int frame_len(0);\n\t\tuint16_t peer_port = 0;\n\t\tin6_addr *peer_addr;\n\t\tuint16_t sock_port = 0;\n\t\tspinel_ssize_t ret;\n\t\tData data;\n\n\t\tret = spinel_datatype_unpack(\n\t\t\tvalue_data_ptr,\n\t\t\tvalue_data_len,\n\t\t\tSPINEL_DATATYPE_DATA_S\n\t\t\tSPINEL_DATATYPE_UINT16_S    // Peer port\n\t\t\tSPINEL_DATATYPE_IPv6ADDR_S  // Peer address\n\t\t\tSPINEL_DATATYPE_UINT16_S,   // Sock port\n\t\t\t&frame_ptr,\n\t\t\t&frame_len,\n\t\t\t&peer_port,\n\t\t\t&peer_addr,\n\t\t\t&sock_port\n\t\t);\n\n\t\t__ASSERT_MACROS_check(ret > 0);\n\n\t\t// Analyze the packet to determine if it should be dropped.\n\t\tif (ret > 0) {\n\t\t\t// append frame\n\t\t\tdata.append(frame_ptr, frame_len);\n\t\t\t// pack the locator in big endian.\n\t\t\tdata.push_back(peer_port >> 8);\n\t\t\tdata.push_back(peer_port & 0xff);\n\t\t\tdata.append(peer_addr->s6_addr, sizeof(*peer_addr));\n\t\t\t// pack the port in big endian.\n\t\t\tdata.push_back(sock_port >> 8);\n\t\t\tdata.push_back(sock_port & 0xff);\n\t\t\tsignal_property_changed(kWPANTUNDProperty_UdpProxyStream, data);\n\t\t}\n\n\t} else if ((key == SPINEL_PROP_STREAM_NET) || (key == SPINEL_PROP_STREAM_NET_INSECURE)) {\n\t\tconst uint8_t* frame_ptr(NULL);\n\t\tunsigned int frame_len(0);\n\t\tspinel_ssize_t ret;\n\t\tuint8_t frame_data_type = FRAME_TYPE_DATA;\n\n\t\tif (SPINEL_PROP_STREAM_NET_INSECURE == key) {\n\t\t\tframe_data_type = FRAME_TYPE_INSECURE_DATA;\n\t\t}\n\n\t\tret = spinel_datatype_unpack(\n\t\t\tvalue_data_ptr,\n\t\t\tvalue_data_len,\n\t\t\tSPINEL_DATATYPE_DATA_S SPINEL_DATATYPE_DATA_S,\n\t\t\t&frame_ptr,\n\t\t\t&frame_len,\n\t\t\tNULL,\n\t\t\tNULL\n\t\t);\n\n\t\t__ASSERT_MACROS_check(ret > 0);\n\n\t\t// Analyze the packet to determine if it should be dropped.\n\t\tif ((ret > 0) && should_forward_hostbound_frame(&frame_data_type, frame_ptr, frame_len)) {\n\t\t\tif (static_cast<bool>(mLegacyInterface) && (frame_data_type == FRAME_TYPE_LEGACY_DATA)) {\n\t\t\t\thandle_alt_ipv6_from_ncp(frame_ptr, frame_len);\n\t\t\t} else {\n\t\t\t\thandle_normal_ipv6_from_ncp(frame_ptr, frame_len);\n\t\t\t}\n\t\t}\n\t} else if (key == SPINEL_PROP_THREAD_CHILD_TABLE) {\n\t\tSpinelNCPTaskGetNetworkTopology::Table child_table;\n\t\tSpinelNCPTaskGetNetworkTopology::Table::iterator it;\n\t\tint num_children = 0;\n\n\t\tSpinelNCPTaskGetNetworkTopology::parse_child_table(value_data_ptr, value_data_len, child_table);\n\n\t\tfor (it = child_table.begin(); it != child_table.end(); it++)\n\t\t{\n\t\t\tnum_children++;\n\t\t\tsyslog(LOG_INFO, \"[-NCP-] Child: %02d %s\", num_children, it->get_as_string().c_str());\n\t\t}\n\t\tsyslog(LOG_INFO, \"[-NCP-] Child: Total %d child%s\", num_children, (num_children > 1) ? \"ren\" : \"\");\n\n\t} else if (key == SPINEL_PROP_THREAD_NEIGHBOR_TABLE) {\n\t\tSpinelNCPTaskGetNetworkTopology::Table neigh_table;\n\t\tSpinelNCPTaskGetNetworkTopology::Table::iterator it;\n\t\tint num_neighbor = 0;\n\n\t\tSpinelNCPTaskGetNetworkTopology::parse_neighbor_table(value_data_ptr, value_data_len, neigh_table);\n\n\t\tfor (it = neigh_table.begin(); it != neigh_table.end(); it++)\n\t\t{\n\t\t\tnum_neighbor++;\n\t\t\tsyslog(LOG_INFO, \"[-NCP-] Neighbor: %02d %s\", num_neighbor, it->get_as_string().c_str());\n\t\t}\n\t\tsyslog(LOG_INFO, \"[-NCP-] Neighbor: Total %d neighbor%s\", num_neighbor, (num_neighbor > 1) ? \"s\" : \"\");\n\n\t} else if (key == SPINEL_PROP_THREAD_NEIGHBOR_TABLE_ERROR_RATES) {\n\t\tSpinelNCPTaskGetNetworkTopology::Table neigh_table;\n\t\tSpinelNCPTaskGetNetworkTopology::Table::iterator it;\n\t\tint num_neighbor = 0;\n\n\t\tSpinelNCPTaskGetNetworkTopology::prase_neighbor_error_rates_table(value_data_ptr, value_data_len, neigh_table);\n\n\t\tfor (it = neigh_table.begin(); it != neigh_table.end(); it++)\n\t\t{\n\t\t\tnum_neighbor++;\n\t\t\tsyslog(LOG_INFO, \"[-NCP-] Neighbor: %02d %s\", num_neighbor, it->get_as_string().c_str());\n\t\t}\n\t\tsyslog(LOG_INFO, \"[-NCP-] Neighbor: Total %d neighbor%s\", num_neighbor, (num_neighbor > 1) ? \"s\" : \"\");\n\n\t} else if (key == SPINEL_PROP_THREAD_ROUTER_TABLE) {\n\t\tSpinelNCPTaskGetNetworkTopology::Table router_table;\n\t\tSpinelNCPTaskGetNetworkTopology::Table::iterator it;\n\t\tint num_router = 0;\n\n\t\tSpinelNCPTaskGetNetworkTopology::parse_router_table(value_data_ptr, value_data_len, router_table);\n\n\t\tfor (it = router_table.begin(); it != router_table.end(); it++)\n\t\t{\n\t\t\tnum_router++;\n\t\t\tsyslog(LOG_INFO, \"[-NCP-] Router: %02d %s\", num_router, it->get_as_string().c_str());\n\t\t}\n\t\tsyslog(LOG_INFO, \"[-NCP-] Router: Total %d router%s\", num_router, (num_router > 1) ? \"s\" : \"\");\n\n\n\t} else if (key == SPINEL_PROP_THREAD_ADDRESS_CACHE_TABLE) {\n\t\tboost::any value;\n\t\tif ((unpack_address_cache_table(value_data_ptr, value_data_len, value, false) == kWPANTUNDStatus_Ok)\n\t\t\t&& (value.type() == typeid(std::list<std::string>))\n\t\t) {\n\t\t\tstd::list<std::string> list = boost::any_cast<std::list<std::string> >(value);\n\t\t\tint num_entries = 0;\n\n\t\t\tfor (std::list<std::string>::iterator it = list.begin(); it != list.end(); it++) {\n\t\t\t\tnum_entries++;\n\t\t\t\tsyslog(LOG_INFO, \"[-NCP-] AddressCache: %02d %s\", num_entries, it->c_str());\n\t\t\t}\n\t\t\tsyslog(LOG_INFO, \"[-NCP-] AddressCache: Total %d entr%s\", num_entries, (num_entries > 1) ? \"ies\" : \"y\");\n\t\t}\n\n\t} else if (key == SPINEL_PROP_NET_PARTITION_ID) {\n\t\tuint32_t paritition_id = 0;\n\t\tspinel_datatype_unpack(value_data_ptr, value_data_len, SPINEL_DATATYPE_UINT32_S, &paritition_id);\n\t\tsyslog(LOG_INFO, \"[-NCP-] Partition id: %u (0x%x)\", paritition_id, paritition_id);\n\n\t} else if (key == SPINEL_PROP_THREAD_LEADER_NETWORK_DATA) {\n\t\tchar net_data_cstr_buf[540];\n\t\tencode_data_into_string(value_data_ptr, value_data_len, net_data_cstr_buf, sizeof(net_data_cstr_buf), 0);\n\t\tsyslog(LOG_INFO, \"[-NCP-] Leader network data: [%s]\", net_data_cstr_buf);\n\t}\n\nbail:\n\tprocess_event(EVENT_NCP_PROP_VALUE_IS, key, original_value_data_ptr, original_value_data_len);\n}\n\nvoid\nSpinelNCPInstance::handle_ncp_spinel_callback(unsigned int command, const uint8_t* cmd_data_ptr, spinel_size_t cmd_data_len)\n{\n\tswitch (command) {\n\tcase SPINEL_CMD_PROP_VALUE_IS:\n\tcase SPINEL_CMD_PROP_VALUE_INSERTED:\n\tcase SPINEL_CMD_PROP_VALUE_REMOVED:\n\t\t{\n\t\t\tspinel_prop_key_t key = SPINEL_PROP_LAST_STATUS;\n\t\t\tuint8_t* value_data_ptr = NULL;\n\t\t\tspinel_size_t value_data_len = 0;\n\t\t\tspinel_ssize_t ret;\n\n\t\t\tret = spinel_datatype_unpack(cmd_data_ptr, cmd_data_len, \"CiiD\", NULL, NULL, &key, &value_data_ptr, &value_data_len);\n\n\t\t\t__ASSERT_MACROS_check(ret != -1);\n\n\t\t\tif (ret == -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch (command) {\n\t\t\tcase SPINEL_CMD_PROP_VALUE_IS:\n\t\t\t\thandle_ncp_spinel_value_is(key, value_data_ptr, value_data_len);\n\t\t\t\tbreak;\n\t\t\tcase SPINEL_CMD_PROP_VALUE_INSERTED:\n\t\t\t\thandle_ncp_spinel_value_inserted(key, value_data_ptr, value_data_len);\n\t\t\t\tbreak;\n\t\t\tcase SPINEL_CMD_PROP_VALUE_REMOVED:\n\t\t\t\thandle_ncp_spinel_value_removed(key, value_data_ptr, value_data_len);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tprocess_event(EVENT_NCP(command), cmd_data_ptr[0], cmd_data_ptr, cmd_data_len);\n\t}\n}\n\nchar\nSpinelNCPInstance::ncp_to_driver_pump()\n{\n\tstruct nlpt*const pt = &mNCPToDriverPumpPT;\n//\tunsigned int prop_key = 0;\n\tunsigned int command_value = 0;\n\tuint8_t byte;\n\n\t// Automatically detect socket resets and behave accordingly.\n\tif (mSerialAdapter->did_reset()) {\n\t\tsyslog(LOG_NOTICE, \"[-NCP-]: Socket Reset\");\n\t\tNLPT_INIT(&mNCPToDriverPumpPT);\n\t\tNLPT_INIT(&mDriverToNCPPumpPT);\n\n\t\tprocess_event(EVENT_NCP_CONN_RESET);\n\t}\n\n\tNLPT_BEGIN(pt);\n\n\t// This macro abstracts the logic to read a single character into\n\t// `data`, in a protothreads-friendly way.\n#define READ_CHARACTER(pt, data, on_fail) \\\n\twhile(1) {                                  \\\n\t\tNLPT_WAIT_UNTIL_READABLE_OR_COND(pt, mSerialAdapter->get_read_fd(), mSerialAdapter->can_read()); \\\n\t\tssize_t retlen = mSerialAdapter->read(data, 1); \\\n\t\tif (retlen < 0) { \\\n\t\t\tsyslog(LOG_ERR, \"[-NCP-]: Socket error on read: %s %d\", \\\n\t\t\t       strerror((int)-retlen), (int)(-retlen)); \\\n\t\t\tsignal_fatal_error(ERRORCODE_ERRNO); \\\n\t\t\tgoto on_fail; \\\n\t\t} else if (retlen == 0) { \\\n\t\t\tcontinue; \\\n\t\t} \\\n\t\tbreak ; \\\n\t};\n\n\twhile (!ncp_state_is_detached_from_ncp(get_ncp_state())) {\n\t\tmInboundHeader = 0;\n\t\tmInboundFrameSize = 0;\n\n\t\t// Yield until the socket is readable. We do a\n\t\t// yield here instead of a wait because we want to\n\t\t// only handle one packet per run through the main loop.\n\t\t// Using `YIELD` instead of `WAIT` guarantees that we\n\t\t// will yield control of the protothread at least once,\n\t\t// even if the socket is already readable.\n\t\tNLPT_YIELD_UNTIL_READABLE_OR_COND(pt, mSerialAdapter->get_read_fd(), mSerialAdapter->can_read());\n\n#if WPANTUND_SPINEL_USE_FLEN\n\t\tdo {\n\t\t\tREAD_CHARACTER(pt, (void*)&mInboundFrame[0], on_error);\n\n\t\t\tif (HDLC_BYTE_FLAG != mInboundFrame[0]) {\n\t\t\t\t// The dreaded extraneous character error.\n\n\t\t\t\t// Log the error.\n\t\t\t\t{\n\t\t\t\t\tchar printable = mInboundFrame[0];\n\t\t\t\t\tif(iscntrl(printable) || printable<0)\n\t\t\t\t\t\tprintable = '.';\n\n\t\t\t\t\tsyslog(LOG_WARNING,\n\t\t\t\t\t\t   \"[NCP->] Extraneous Character: 0x%02X [%c] (%d)\\n\",\n\t\t\t\t\t\t   (uint8_t)mInboundFrame[0],\n\t\t\t\t\t\t   printable,\n\t\t\t\t\t\t   (uint8_t)mInboundFrame[0]);\n\t\t\t\t}\n\n\t\t\t\t// Flush out all remaining data since this is a strong\n\t\t\t\t// indication that something has gone horribly wrong.\n\t\t\t\twhile (mSerialAdapter->can_read()) {\n\t\t\t\t\tREAD_CHARACTER(pt, (void*)&mInboundFrame[0], on_error);\n\t\t\t\t}\n\n\t\t\t\tncp_is_misbehaving();\n\t\t\t\tgoto on_error;\n\t\t\t}\n\t\t} while (UART_STREAM_FLAG != mInboundFrame[0]);\n\n\t\t// Read the frame length\n\t\tREAD_CHARACTER(pt, (void*)((char*)&mInboundFrame+0), on_error);\n\t\tREAD_CHARACTER(pt, (void*)((char*)&mInboundFrame+1), on_error);\n\n\t\tmInboundFrameSize = (mInboundFrame[0] << 8) + mInboundFrame[1];\n\n\t\trequire(mInboundFrameSize > 1, on_error);\n\t\trequire(mInboundFrameSize <= SPINEL_FRAME_MAX_SIZE, on_error);\n\n\t\t// Read the rest of the packet.\n\t\tNLPT_ASYNC_READ_STREAM(\n\t\t\tpt,\n\t\t\tmSerialAdapter.get(),\n\t\t\tmInboundFrame,\n\t\t\tmInboundFrameSize\n\t\t);\n#else // if WPANTUND_SPINEL_USE_FLEN\n\n\t\tmInboundFrameSize = 0;\n\t\tmInboundFrameHDLCCRC = 0xffff;\n\n\t\tdo {\n\t\t\tREAD_CHARACTER(pt, &byte, on_error);\n\n\t\t\tif (byte == HDLC_BYTE_FLAG) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (byte == HDLC_BYTE_ESC) {\n\t\t\t\tREAD_CHARACTER(pt, &byte, on_error);\n\t\t\t\tif (byte == HDLC_BYTE_FLAG) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tbyte ^= HDLC_ESCAPE_XFORM;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (mInboundFrameSize >= 2) {\n\t\t\t\tmInboundFrameHDLCCRC = hdlc_crc16(mInboundFrameHDLCCRC, mInboundFrame[mInboundFrameSize-2]);\n\t\t\t}\n\n\t\t\trequire(mInboundFrameSize < sizeof(mInboundFrame), on_error);\n\n\t\t\tmInboundFrame[mInboundFrameSize++] = byte;\n\n\t\t} while(true);\n\n\t\tif (mInboundFrameSize <= 2) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tmInboundFrameSize -= 2;\n\t\tmInboundFrameHDLCCRC ^= 0xFFFF;\n\n#if !FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION // Don't do CRC checks when in fuzzing mode\n\t\t{\n\t\t\tuint16_t frame_crc = (mInboundFrame[mInboundFrameSize]|(mInboundFrame[mInboundFrameSize+1]<<8));\n\t\t\tif (mInboundFrameHDLCCRC != frame_crc) {\n\n\t\t\t\tint i;\n\t\t\t\tstatic const uint8_t kAsciiCR = 13;\n\t\t\t\tstatic const uint8_t kAsciiBEL = 7;\n\n\t\t\t\tsyslog(LOG_ERR, \"[NCP->]: Frame CRC Mismatch: Calc:0x%04X != Frame:0x%04X, Garbage on line?\", mInboundFrameHDLCCRC, frame_crc);\n\n\t\t\t\t// This frame might be an ASCII backtrace, so we check to\n\t\t\t\t// see if all of the characters are ascii characters, and if\n\t\t\t\t// so we dump out this packet directly to syslog.\n\n\t\t\t\tmInboundFrameSize += 2;\n\n\t\t\t\tfor (i = 0; i < mInboundFrameSize; i++) {\n\t\t\t\t\t// Acceptable control codes\n\t\t\t\t\tif (mInboundFrame[i] >= kAsciiBEL && mInboundFrame[i] <= kAsciiCR) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t// NUL characters are OK.\n\t\t\t\t\tif (mInboundFrame[i] == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t// Acceptable characters\n\t\t\t\t\tif (mInboundFrame[i] >= 32 && mInboundFrame[i] <= 127) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tsyslog(LOG_ERR, \"[NCP->]: Garbage is not ASCII ([%d]=%d)\", i, mInboundFrame[i]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (i == mInboundFrameSize) {\n\t\t\t\t\thandle_ncp_debug_stream(mInboundFrame, mInboundFrameSize);\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n#endif // !FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n\n#endif // else WPANTUND_SPINEL_USE_FLEN\n\n\t\tif (pt->last_errno) {\n\t\t\tsyslog(LOG_ERR, \"[-NCP-]: Socket error on read: %s\", strerror(pt->last_errno));\n\t\t\terrno = pt->last_errno;\n\t\t\tsignal_fatal_error(ERRORCODE_ERRNO);\n\t\t\tgoto on_error;\n\t\t}\n\n#if OPENTHREAD_ENABLE_NCP_SPINEL_ENCRYPTER\n\t\tsize_t dataLen = mInboundFrameSize;\n\t\tif (!SpinelEncrypter::DecryptInbound(mInboundFrame, sizeof(mInboundFrame), &dataLen))\n\t\t{\n\t\t\tsyslog(LOG_ERR, \"[-NCP-]: Unable to transform inbound data\");\n\t\t\tbreak;\n\t\t}\n\t\tmInboundFrameSize = dataLen;\n#endif // OPENTHREAD_ENABLE_NCP_SPINEL_ENCRYPTER\n\n\t\tif (spinel_datatype_unpack(mInboundFrame, mInboundFrameSize, \"Ci\", &mInboundHeader, &command_value) > 0) {\n\t\t\tif ((mInboundHeader&SPINEL_HEADER_FLAG) != SPINEL_HEADER_FLAG) {\n\t\t\t\t// Unrecognized frame.\n\t\t\t\tsyslog(LOG_ERR, \"[-NCP-]: Unrecognized frame (0x%02X)\", mInboundHeader);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (SPINEL_HEADER_GET_IID(mInboundHeader) != 0) {\n\t\t\t\t// We only support IID zero for now.\n#if DEBUG\n\t\t\t\tsyslog(LOG_INFO, \"[-NCP-]: Unsupported IID: %d\", SPINEL_HEADER_GET_IID(mInboundHeader));\n#endif\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlog_spinel_frame(kNCPToDriver, mInboundFrame, mInboundFrameSize);\n\n\t\t\thandle_ncp_spinel_callback(command_value, mInboundFrame, mInboundFrameSize);\n\t\t}\n\t} // while (!ncp_state_is_detached_from_ncp(get_ncp_state()))\n\non_error:;\n\t// If we get here, we will restart the protothread at the next iteration.\n\n\tNLPT_END(pt);\n}\n\nvoid\nNCPInstanceBase::process(void)\n{\n\tint ret = 0;\n\n\tif (mNCPIsMisbehaving) {\n\t\tmFailureCount++;\n\t\thard_reset_ncp();\n\t\treset_tasks();\n\t\treinitialize_ncp();\n\n\t\tif (mFailureCount >= mFailureThreshold) {\n\t\t\tchange_ncp_state(FAULT);\n\t\t}\n\n\t\tmNCPIsMisbehaving = false;\n\t\tgoto socket_failure;\n\t}\n\n\tmRunawayResetBackoffManager.update();\n\n\tmFirmwareUpgrade.process();\n\n\tmPcapManager.process();\n\n\tif (get_upgrade_status() != EINPROGRESS) {\n\t\trefresh_address_route_prefix_entries();\n\n\t\trequire_noerr(ret = mPrimaryInterface->process(), socket_failure);\n\n\t\tif (is_legacy_interface_enabled()) {\n\t\t\tmLegacyInterface->process();\n\t\t}\n\n\t\trequire_noerr(ret = mSerialAdapter->process(), socket_failure);\n\n\t\tncp_to_driver_pump();\n\t}\n\n\tEventHandler::process_event(EVENT_IDLE);\n\n\tif (get_upgrade_status() != EINPROGRESS) {\n\t\tdriver_to_ncp_pump();\n\t}\n\n    update_busy_indication();\n\n\treturn;\n\nsocket_failure:\n\tsignal_fatal_error(ret);\n\treturn;\n}\n\nvoid\nSpinelNCPInstance::process(void)\n{\n\tNCPInstanceBase::process();\n\n\tmVendorCustom.process();\n\n\tif (!is_initializing_ncp() && mTaskQueue.empty()) {\n\t\tbool x = mPcapManager.is_enabled();\n\n\t\tif (mIsPcapInProgress != x) {\n\t\t\tSpinelNCPTaskSendCommand::Factory factory(this);\n\n\t\t\tmIsPcapInProgress = x;\n\n\t\t\tfactory.add_command(SpinelPackData(\n\t\t\t\tSPINEL_FRAME_PACK_CMD_PROP_VALUE_SET(SPINEL_DATATYPE_BOOL_S),\n\t\t\t\tSPINEL_PROP_MAC_RAW_STREAM_ENABLED,\n\t\t\t\tmIsPcapInProgress\n\t\t\t));\n\n\t\t\tif (mIsPcapInProgress) {\n\t\t\t\tfactory.add_command(SpinelPackData(\n\t\t\t\t\tSPINEL_FRAME_PACK_CMD_PROP_VALUE_SET(SPINEL_DATATYPE_BOOL_S),\n\t\t\t\t\tSPINEL_PROP_NET_IF_UP,\n\t\t\t\t\ttrue\n\t\t\t\t));\n\t\t\t\tif (!ncp_state_is_joining_or_joined(get_ncp_state())) {\n\t\t\t\t\tfactory.add_command(SpinelPackData(\n\t\t\t\t\t\tSPINEL_FRAME_PACK_CMD_PROP_VALUE_SET(SPINEL_DATATYPE_UINT8_S),\n\t\t\t\t\t\tSPINEL_PROP_MAC_PROMISCUOUS_MODE,\n\t\t\t\t\t\tSPINEL_MAC_PROMISCUOUS_MODE_FULL\n\t\t\t\t\t));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfactory.add_command(SpinelPackData(\n\t\t\t\t\tSPINEL_FRAME_PACK_CMD_PROP_VALUE_SET(SPINEL_DATATYPE_UINT8_S),\n\t\t\t\t\tSPINEL_PROP_MAC_PROMISCUOUS_MODE,\n\t\t\t\t\tSPINEL_MAC_PROMISCUOUS_MODE_OFF\n\t\t\t\t));\n\t\t\t}\n\n\t\t\tstart_new_task(factory.finish());\n\t\t\tNCPInstanceBase::process();\n\t\t}\n\t}\n}\n\n\tvoid process() {\n\t\tstd::list<shared_ptr<nl::wpantund::IPCServer> >::iterator ipc_iter;\n\n\t\t// Process callback timers.\n\t\tTimer::process();\n\n\t\t// Process any necessary IPC actions.\n\t\tfor (ipc_iter = mIpcServerList.begin(); ipc_iter != mIpcServerList.end(); ++ipc_iter) {\n\t\t\t(*ipc_iter)->process();\n\t\t}\n\n\t\t// Process the NCP instance.\n\t\tmNcpInstance->process();\n\n\t\t// We only expose the interface via IPC after it is\n\t\t// successfully initialized for the first time.\n\t\tif (!mInterfaceAdded) {\n\t\t\tconst boost::any value = mNcpInstance->get_control_interface().property_get_value(kWPANTUNDProperty_NCPState);\n\t\t\tif ((value.type() == boost::any(std::string()).type())\n\t\t\t && (boost::any_cast<std::string>(value) != kWPANTUNDStateUninitialized)\n\t\t\t) {\n\t\t\t\tfor (ipc_iter = mIpcServerList.begin(); ipc_iter != mIpcServerList.end(); ++ipc_iter) {\n\t\t\t\t\t(*ipc_iter)->add_interface(&mNcpInstance->get_control_interface());\n\t\t\t\t}\n\t\t\t\tmInterfaceAdded = true;\n\t\t\t}\n\t\t}\n\t}\n\nint\nNCPInputFuzzTarget(const uint8_t *data, size_t size) {\n\tstd::map<std::string, std::string> settings;\n\n\tint fd[2] = { -1, -1 };\n\tuint8_t data_out[100];\n\tuint32_t i = 0;\n\tconst uint32_t max_iterations = 10000000;\n\tstatic const uint8_t hdlc_flag = HDLC_BYTE_FLAG;\n\n\tgRet = 0;\n\n\tif (socketpair(PF_UNIX, SOCK_STREAM, 0, fd) < 0) {\n\t\tsyslog(LOG_ALERT, \"Call to socketpair() failed: %s (%d)\", strerror(errno), errno);\n\t\tfuzz_trap();\n\t}\n\n\t{\n\t\tchar *fd_string = NULL;\n\n\t\tif (0 >= asprintf(&fd_string, \"fd:%d\", fd[1])) {\n\t\t\tsyslog(LOG_ALERT, \"Call to asprintf() failed: %s (%d)\", strerror(errno), errno);\n\t\t\tfuzz_trap();\n\t\t}\n\n\t\tassert(fd_string != NULL);\n\n\t\tsettings[kWPANTUNDProperty_ConfigNCPSocketPath] = fd_string;\n\n\t\tfree(fd_string);\n\t}\n\n\ttry {\n\n\tMainLoop main_loop(settings);\n\n\t// wpantund dup'd the file descriptor we gave it,\n\t// so we should close this one here.\n\tclose(fd[1]);\n\tfd[1] = -1;\n\n\tfor (i = 0; (i < 10) && main_loop.block_until_ready(); i++) {\n\t\tmain_loop.process();\n\t}\n\tmain_loop.process();\n\n\twhile (size > 0 && gRet == 0) {\n\t\tuint8_t c = *data++;\n\t\tsize--;\n\n\t\t// Special command.\n\t\tif ((size > 0) && (c == HDLC_BYTE_SPECIAL)) {\n\t\t\tc = *data++;\n\t\t\tsize--;\n\n\t\t\tif (c == FUZZ_SPECIAL_WAIT_FOR_FRAME) {\n\t\t\t\tfor (i = 0; i < 5 && checkpoll(fd[0], POLLIN|POLLERR|POLLHUP) == 0; i++) {\n\t\t\t\t\tif (main_loop.block_until_ready()) {\n\t\t\t\t\t\tmain_loop.process();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\twhile (checkpoll(fd[0], POLLIN|POLLERR|POLLHUP) != 0 && gRet == 0) {\n\t\t\t\t\tssize_t bytesread = read(fd[0], data_out, sizeof(data_out));\n\t\t\t\t\tif (bytesread <= 0) {\n\t\t\t\t\t\tsyslog(LOG_WARNING, \"Call to read() failed: %s (%d)\", strerror(errno), errno);\n\t\t\t\t\t\tgoto bail;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (main_loop.block_until_ready()) {\n\t\t\t\t\t\tmain_loop.process();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n#if DEBUG\n\t\t\t\t\tfprintf(stderr, \"NCPInputFuzzTarget: Got %lu bytes from wpantund\\n\", bytesread);\n#endif\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else if ((c == FUZZ_SPECIAL_FF_DECISECONDS) && (size > 0)) {\n\t\t\t\tc = *data++;\n\t\t\t\tsize--;\n\t\t\t\t// Fast forward the given number of deciseconds\n\t\t\t\tfuzz_ff_cms(c * (MSEC_PER_SEC/10));\n\t\t\t}\n\t\t}\n\n\t\twhile (checkpoll(fd[0], POLLOUT|POLLERR|POLLHUP) == 0 && gRet == 0) {\n\t\t\tmain_loop.block_until_ready();\n\t\t\tmain_loop.process();\n\t\t}\n\n\t\tssize_t byteswritten = write(fd[0], &c, 1);\n\t\tif (byteswritten <= 0) {\n\t\t\tsyslog(LOG_WARNING, \"Call to write() failed: %s (%d)\", strerror(errno), errno);\n\t\t\tgoto bail;;\n\t\t}\n\n\t\tmain_loop.block_until_ready();\n\t\tmain_loop.process();\n\t}\n\n\tfor (i = 0; (i < 10) && main_loop.block_until_ready(); i++) {\n\t\tmain_loop.process();\n\t}\n\tmain_loop.process();\n\n\tif (size != 0) {\n\t\tsyslog(LOG_ALERT, \"Did not consume all data\");\n\t\tfuzz_trap();\n\t}\n\n\tif (gRet != 0) {\n\t\tsyslog(LOG_ALERT, \"gRet = %d\", gRet);\n\t\tfuzz_trap();\n\t}\n\n\t} catch (nl::SocketError x) {\n\t\t// Ignore socket wrapper errors\n\t}\n\nbail:\n\tclose(fd[0]);\n\tclose(fd[1]);\n\n\treturn 0;\n}\n\n\n// target function\nvoid\nNCPInstanceBase::on_mesh_prefix_was_removed(Origin origin, const struct in6_addr &prefix_address, uint8_t prefix_len,\n\tuint8_t flags, bool stable, uint16_t rloc16, CallbackWithStatus cb)\n{\n\tIPv6Prefix prefix(prefix_address, prefix_len);\n\tOnMeshPrefixEntry entry(origin, flags, stable, rloc16);\n\tstd::multimap<IPv6Prefix, OnMeshPrefixEntry>::iterator iter;\n\n\titer = find_prefix_entry(prefix, entry);\n\n\tif (iter != mOnMeshPrefixes.end()) {\n\t\tsyslog(LOG_INFO, \"OnMeshPrefixes: Removing %s\", entry.get_description(prefix).c_str());\n\t\tmOnMeshPrefixes.erase(iter);\n\n\t\tif (origin != kOriginThreadNCP) {\n\t\t\tremove_on_mesh_prefix_on_ncp(prefix.get_prefix(), prefix.get_length(),\n\t\t\t\tentry.get_flags(), entry.is_stable(),\n\t\t\t\tboost::bind(&NCPInstanceBase::check_ncp_entry_update_status, this, _1, \"removing on-mesh prefix\", cb));\n\t\t} else {\n\t\t\tcb(kWPANTUNDStatus_Ok);\n\t\t}\n\n\t\tif (entry.is_on_mesh() && entry.is_slaac() && prefix.get_length() == kSLAACPrefixLength\n\t\t\t&& !has_slaac_on_mesh_prefix(prefix)\n\t\t) {\n\t\t\tstd::map<struct in6_addr, UnicastAddressEntry>::iterator addr_iter;\n\n\t\t\t// Note that SLAAC addresses are added with origin NCP.\n\t\t\taddr_iter = find_address_with_prefix(prefix, kOriginThreadNCP);\n\n\t\t\tif (addr_iter != mUnicastAddresses.end()) {\n\t\t\t\tconst struct in6_addr &address = addr_iter->first;\n\t\t\t\tsyslog(LOG_NOTICE, \"Removing SLAAC address %s/%d from NCP\", in6_addr_to_string(address).c_str(), prefix_len);\n\t\t\t\tremove_unicast_address_on_ncp(address, prefix_len,\n\t\t\t\t\tboost::bind(&NCPInstanceBase::check_ncp_entry_update_status, this, _1, \"removing SLAAC address\", NilReturn()));\n\t\t\t\tunicast_address_was_removed(kOriginThreadNCP, address);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tcb(kWPANTUNDStatus_Ok);\n\t}\n}\n",
    "target": 1,
    "idx": 1010864,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "// context\nMRB_API void\nmrb_gc_mark(mrb_state *mrb, struct RBasic *obj)\n{\n  if (obj == 0) return;\n  if (!is_white(obj)) return;\n  if (is_red(obj)) return;\n  mrb_assert((obj)->tt != MRB_TT_FREE);\n  add_gray_list(mrb, &mrb->gc, obj);\n}\n\nstatic int\niv_mark_i(mrb_state *mrb, mrb_sym sym, mrb_value v, void *p)\n{\n  mrb_gc_mark_value(mrb, v);\n  return 0;\n}\n\nstatic void\niv_foreach(mrb_state *mrb, iv_tbl *t, mrb_iv_foreach_func *func, void *p)\n{\n  int i;\n\n  if (t == NULL) return;\n  if (t->alloc == 0) return;\n  if (t->size == 0) return;\n\n  mrb_sym *keys = (mrb_sym*)&t->ptr[t->alloc];\n  mrb_value *vals = t->ptr;\n  for (i=0; i<t->alloc; i++) {\n    if (IV_KEY_P(keys[i])) {\n      if ((*func)(mrb, keys[i], vals[i], p) != 0) {\n        return;\n      }\n    }\n  }\n  return;\n}\n\nstatic void\nmark_tbl(mrb_state *mrb, iv_tbl *t)\n{\n  iv_foreach(mrb, t, iv_mark_i, 0);\n}\n\nvoid\nmrb_gc_mark_iv(mrb_state *mrb, struct RObject *obj)\n{\n  mark_tbl(mrb, obj->iv);\n}\n\nstatic void\ngc_mark_children(mrb_state *mrb, mrb_gc *gc, struct RBasic *obj)\n{\n  mrb_assert(is_gray(obj));\n  paint_black(obj);\n  mrb_gc_mark(mrb, (struct RBasic*)obj->c);\n  switch (obj->tt) {\n  case MRB_TT_ICLASS:\n    {\n      struct RClass *c = (struct RClass*)obj;\n      if (MRB_FLAG_TEST(c, MRB_FL_CLASS_IS_ORIGIN))\n        mrb_gc_mark_mt(mrb, c);\n      mrb_gc_mark(mrb, (struct RBasic*)((struct RClass*)obj)->super);\n    }\n    break;\n\n  case MRB_TT_CLASS:\n  case MRB_TT_MODULE:\n  case MRB_TT_SCLASS:\n    {\n      struct RClass *c = (struct RClass*)obj;\n\n      mrb_gc_mark_mt(mrb, c);\n      mrb_gc_mark(mrb, (struct RBasic*)c->super);\n    }\n    /* fall through */\n\n  case MRB_TT_OBJECT:\n  case MRB_TT_CDATA:\n    mrb_gc_mark_iv(mrb, (struct RObject*)obj);\n    break;\n\n  case MRB_TT_PROC:\n    {\n      struct RProc *p = (struct RProc*)obj;\n\n      mrb_gc_mark(mrb, (struct RBasic*)p->upper);\n      mrb_gc_mark(mrb, (struct RBasic*)p->e.env);\n    }\n    break;\n\n  case MRB_TT_ENV:\n    {\n      struct REnv *e = (struct REnv*)obj;\n      mrb_int i, len;\n\n      if (MRB_ENV_ONSTACK_P(e) && e->cxt && e->cxt->fib) {\n        mrb_gc_mark(mrb, (struct RBasic*)e->cxt->fib);\n      }\n      len = MRB_ENV_LEN(e);\n      for (i=0; i<len; i++) {\n        mrb_gc_mark_value(mrb, e->stack[i]);\n      }\n    }\n    break;\n\n  case MRB_TT_FIBER:\n    {\n      struct mrb_context *c = ((struct RFiber*)obj)->cxt;\n\n      if (c) mark_context(mrb, c);\n    }\n    break;\n\n  case MRB_TT_STRUCT:\n  case MRB_TT_ARRAY:\n    {\n      struct RArray *a = (struct RArray*)obj;\n      size_t i, e=ARY_LEN(a);\n      mrb_value *p = ARY_PTR(a);\n\n      for (i=0; i<e; i++) {\n        mrb_gc_mark_value(mrb, p[i]);\n      }\n    }\n    break;\n\n  case MRB_TT_HASH:\n    mrb_gc_mark_iv(mrb, (struct RObject*)obj);\n    mrb_gc_mark_hash(mrb, (struct RHash*)obj);\n    break;\n\n  case MRB_TT_STRING:\n    if (RSTR_FSHARED_P(obj)) {\n      struct RString *s = (struct RString*)obj;\n      mrb_gc_mark(mrb, (struct RBasic*)s->as.heap.aux.fshared);\n    }\n    break;\n\n  case MRB_TT_RANGE:\n    mrb_gc_mark_range(mrb, (struct RRange*)obj);\n    break;\n\n  case MRB_TT_BREAK:\n    {\n      struct RBreak *brk = (struct RBreak*)obj;\n      mrb_gc_mark(mrb, (struct RBasic*)mrb_break_proc_get(brk));\n      mrb_gc_mark_value(mrb, mrb_break_value_get(brk));\n    }\n    break;\n\n  case MRB_TT_EXCEPTION:\n    mrb_gc_mark_iv(mrb, (struct RObject*)obj);\n    if (((struct RException*)obj)->mesg) {\n      mrb_gc_mark(mrb, (struct RBasic*)((struct RException*)obj)->mesg);\n    }\n    mrb_gc_mark(mrb, (struct RBasic*)((struct RException*)obj)->backtrace);\n    break;\n\n  default:\n    break;\n  }\n}\n\nstatic size_t\nincremental_marking_phase(mrb_state *mrb, mrb_gc *gc, size_t limit)\n{\n  size_t tried_marks = 0;\n\n  while (gc->gray_list && tried_marks < limit) {\n    struct RBasic *obj = gc->gray_list;\n    gc->gray_list = obj->gcnext;\n    gc_mark_children(mrb, gc, obj);\n    tried_marks += gc_gray_counts(mrb, gc, obj);\n  }\n\n  return tried_marks;\n}\n\nstatic size_t\nincremental_gc(mrb_state *mrb, mrb_gc *gc, size_t limit)\n{\n  switch (gc->state) {\n  case MRB_GC_STATE_ROOT:\n    root_scan_phase(mrb, gc);\n    gc->state = MRB_GC_STATE_MARK;\n    flip_white_part(gc);\n    return 0;\n  case MRB_GC_STATE_MARK:\n    if (gc->gray_list) {\n      return incremental_marking_phase(mrb, gc, limit);\n    }\n    else {\n      final_marking_phase(mrb, gc);\n      prepare_incremental_sweep(mrb, gc);\n      return 0;\n    }\n  case MRB_GC_STATE_SWEEP: {\n     size_t tried_sweep = 0;\n     tried_sweep = incremental_sweep_phase(mrb, gc, limit);\n     if (tried_sweep == 0)\n       gc->state = MRB_GC_STATE_ROOT;\n     return tried_sweep;\n  }\n  default:\n    /* unknown state */\n    mrb_assert(0);\n    return 0;\n  }\n}\n\nstatic void\nincremental_gc_finish(mrb_state *mrb, mrb_gc *gc)\n{\n  do {\n    incremental_gc(mrb, gc, SIZE_MAX);\n  } while (gc->state != MRB_GC_STATE_ROOT);\n}\n\nMRB_API void\nmrb_full_gc(mrb_state *mrb)\n{\n  mrb_gc *gc = &mrb->gc;\n\n  if (!mrb->c) return;\n  if (gc->disabled || gc->iterating) return;\n\n  GC_INVOKE_TIME_REPORT(\"mrb_full_gc()\");\n  GC_TIME_START;\n\n  if (is_generational(gc)) {\n    /* clear all the old objects back to young */\n    clear_all_old(mrb, gc);\n    gc->full = TRUE;\n  }\n  else if (gc->state != MRB_GC_STATE_ROOT) {\n    /* finish half baked GC cycle */\n    incremental_gc_finish(mrb, gc);\n  }\n\n  incremental_gc_finish(mrb, gc);\n  gc->threshold = (gc->live_after_mark/100) * gc->interval_ratio;\n\n  if (is_generational(gc)) {\n    gc->majorgc_old_threshold = gc->live_after_mark/100 * MAJOR_GC_INC_RATIO;\n    gc->full = FALSE;\n  }\n\n#ifdef MRB_USE_MALLOC_TRIM\n  malloc_trim(0);\n#endif\n  GC_TIME_STOP_AND_REPORT;\n}\n\nvoid\nmrb_objspace_each_objects(mrb_state *mrb, mrb_each_object_callback *callback, void *data)\n{\n  mrb_bool iterating = mrb->gc.iterating;\n\n  mrb_full_gc(mrb);\n  mrb->gc.iterating = TRUE;\n  if (iterating) {\n    gc_each_objects(mrb, &mrb->gc, callback, data);\n  }\n  else {\n    struct mrb_jmpbuf *prev_jmp = mrb->jmp;\n    struct mrb_jmpbuf c_jmp;\n\n    MRB_TRY(&c_jmp) {\n      mrb->jmp = &c_jmp;\n      gc_each_objects(mrb, &mrb->gc, callback, data);\n      mrb->jmp = prev_jmp;\n      mrb->gc.iterating = iterating;\n   } MRB_CATCH(&c_jmp) {\n      mrb->gc.iterating = iterating;\n      mrb->jmp = prev_jmp;\n      MRB_THROW(prev_jmp);\n    } MRB_END_EXC(&c_jmp);\n  }\n}\n\nstatic mrb_value\nos_count_objects(mrb_state *mrb, mrb_value self)\n{\n  struct os_count_struct obj_count = { 0 };\n  mrb_int i;\n  mrb_value hash;\n\n  if (mrb_get_args(mrb, \"|H\", &hash) == 0) {\n    hash = mrb_hash_new(mrb);\n  }\n\n  if (!mrb_hash_empty_p(mrb, hash)) {\n    mrb_hash_clear(mrb, hash);\n  }\n\n  mrb_objspace_each_objects(mrb, os_count_object_type, &obj_count);\n\n  mrb_hash_set(mrb, hash, mrb_symbol_value(MRB_SYM(TOTAL)), mrb_fixnum_value(obj_count.total));\n  mrb_hash_set(mrb, hash, mrb_symbol_value(MRB_SYM(FREE)), mrb_fixnum_value(obj_count.freed));\n\n  for (i = MRB_TT_FALSE; i < MRB_TT_MAXDEFINE; i++) {\n    mrb_value type;\n    switch (i) {\n#define COUNT_TYPE(t) case (MRB_T ## t): type = mrb_symbol_value(MRB_SYM(t)); break;\n      COUNT_TYPE(T_INTEGER);\n      COUNT_TYPE(T_FLOAT);\n      COUNT_TYPE(T_CPTR);\n      COUNT_TYPE(T_OBJECT);\n      COUNT_TYPE(T_CLASS);\n      COUNT_TYPE(T_MODULE);\n      COUNT_TYPE(T_ICLASS);\n      COUNT_TYPE(T_SCLASS);\n      COUNT_TYPE(T_PROC);\n      COUNT_TYPE(T_ARRAY);\n      COUNT_TYPE(T_HASH);\n      COUNT_TYPE(T_STRING);\n      COUNT_TYPE(T_RANGE);\n      COUNT_TYPE(T_EXCEPTION);\n      COUNT_TYPE(T_ENV);\n      COUNT_TYPE(T_DATA);\n      COUNT_TYPE(T_FIBER);\n      COUNT_TYPE(T_STRUCT);\n      COUNT_TYPE(T_ISTRUCT);\n      COUNT_TYPE(T_BREAK);\n      COUNT_TYPE(T_COMPLEX);\n      COUNT_TYPE(T_RATIONAL);\n      COUNT_TYPE(T_BIGINT);\n#undef COUNT_TYPE\n    default:\n      type = mrb_fixnum_value(i); break;\n    }\n    if (obj_count.counts[i])\n      mrb_hash_set(mrb, hash, type, mrb_fixnum_value(obj_count.counts[i]));\n  }\n\n  return hash;\n}\n\nMRB_API mrb_value\nmrb_vm_run(mrb_state *mrb, const struct RProc *proc, mrb_value self, mrb_int stack_keep)\n{\n  const mrb_irep *irep = proc->body.irep;\n  mrb_value result;\n  struct mrb_context *c = mrb->c;\n  ptrdiff_t cioff = c->ci - c->cibase;\n  mrb_int nregs = irep->nregs;\n\n  if (!c->stbase) {\n    stack_init(mrb);\n  }\n  if (stack_keep > nregs)\n    nregs = stack_keep;\n  else {\n    struct REnv *e = CI_ENV(mrb->c->ci);\n    if (stack_keep == 0 || (e && irep->nlocals < MRB_ENV_LEN(e))) {\n      ci_env_set(mrb->c->ci, NULL);\n      mrb_env_unshare(mrb, e, FALSE);\n    }\n  }\n  stack_extend(mrb, nregs);\n  stack_clear(c->ci->stack + stack_keep, nregs - stack_keep);\n  c->ci->stack[0] = self;\n  result = mrb_vm_exec(mrb, proc, irep->iseq);\n  if (mrb->c != c) {\n    if (mrb->c->fib) {\n      mrb_write_barrier(mrb, (struct RBasic*)mrb->c->fib);\n    }\n    mrb->c = c;\n  }\n  else if (c->ci - c->cibase > cioff) {\n    c->ci = c->cibase + cioff;\n  }\n  return result;\n}\n\nint FuzzRB(const uint8_t *Data, size_t size) {\n  mrb_value v;\n  mrb_state *mrb = mrb_open();\n  if (!mrb)\n    return 0;\n\n  char *code = (char *)malloc(size+1);\n  if (!code)\n    return 0;\n  memcpy(code, Data, size);\n  code[size] = '\\0';\n\n  if (const char *dump_path = getenv(\"PROTO_FUZZER_DUMP_PATH\")) {\n    // With libFuzzer binary run this to generate an RB file x.rb:\n    // PROTO_FUZZER_DUMP_PATH=x.rb ./a.out proto-input\n    std::ofstream of(dump_path);\n    of.write(code, size);\n  }\n  std::cout << \"\\n\\n############\\n\" << code << \"\\n############\\n\\n\";\n  v = mrb_load_string(mrb, code);\n  mrb_close(mrb);\n\n  free(code);\n  return 0;\n}\n\n\n\n\n// target function\nstatic mrb_value\nmrb_file_mtime(mrb_state *mrb, mrb_value self)\n{\n  int fd = mrb_io_fileno(mrb, self);\n  mrb_stat st;\n\n  if (mrb_fstat(fd, &st) == -1)\n    return mrb_nil_value();\n  return mrb_int_value(mrb, (mrb_int)st.st_mtime);\n}\nstatic mrb_value\nmrb_file_flock(mrb_state *mrb, mrb_value self)\n{\n#if defined(sun)\n  mrb_raise(mrb, E_NOTIMP_ERROR, \"flock is not supported on Illumos/Solaris/Windows\");\n#else\n  mrb_int operation;\n  int fd;\n\n  mrb_get_args(mrb, \"i\", &operation);\n  fd = mrb_io_fileno(mrb, self);\n\n  while (flock(fd, (int)operation) == -1) {\n    switch (errno) {\n      case EINTR:\n        /* retry */\n        break;\n      case EAGAIN:      /* NetBSD */\n#if defined(EWOULDBLOCK) && EWOULDBLOCK != EAGAIN\n      case EWOULDBLOCK: /* FreeBSD OpenBSD Linux */\n#endif\n        if (operation & LOCK_NB) {\n          return mrb_false_value();\n        }\n        /* FALLTHRU - should not happen */\n      default:\n        mrb_sys_fail(mrb, \"flock failed\");\n        break;\n    }\n  }\n#endif\n  return mrb_fixnum_value(0);\n}\nvoid\nmrb_init_file(mrb_state *mrb)\n{\n  struct RClass *io, *file, *cnst;\n\n  io   = mrb_class_get_id(mrb, MRB_SYM(IO));\n  file = mrb_define_class(mrb, \"File\", io);\n  MRB_SET_INSTANCE_TT(file, MRB_TT_CDATA);\n  mrb_define_class_method(mrb, file, \"umask\",  mrb_file_s_umask, MRB_ARGS_OPT(1));\n  mrb_define_class_method(mrb, file, \"delete\", mrb_file_s_unlink, MRB_ARGS_ANY());\n  mrb_define_class_method(mrb, file, \"unlink\", mrb_file_s_unlink, MRB_ARGS_ANY());\n  mrb_define_class_method(mrb, file, \"rename\", mrb_file_s_rename, MRB_ARGS_REQ(2));\n  mrb_define_class_method(mrb, file, \"symlink\", mrb_file_s_symlink, MRB_ARGS_REQ(2));\n  mrb_define_class_method(mrb, file, \"chmod\", mrb_file_s_chmod, MRB_ARGS_REQ(1) | MRB_ARGS_REST());\n  mrb_define_class_method(mrb, file, \"readlink\", mrb_file_s_readlink, MRB_ARGS_REQ(1));\n\n  mrb_define_class_method(mrb, file, \"dirname\",   mrb_file_dirname,    MRB_ARGS_REQ(1));\n  mrb_define_class_method(mrb, file, \"basename\",  mrb_file_basename,   MRB_ARGS_REQ(1));\n  mrb_define_class_method(mrb, file, \"realpath\",  mrb_file_realpath,   MRB_ARGS_REQ(1)|MRB_ARGS_OPT(1));\n  mrb_define_class_method(mrb, file, \"_getwd\",    mrb_file__getwd,     MRB_ARGS_NONE());\n  mrb_define_class_method(mrb, file, \"_gethome\",  mrb_file__gethome,   MRB_ARGS_OPT(1));\n\n  mrb_define_method(mrb, file, \"flock\", mrb_file_flock, MRB_ARGS_REQ(1));\n  mrb_define_method(mrb, file, \"_mtime\", mrb_file_mtime, MRB_ARGS_NONE());\n  mrb_define_method(mrb, file, \"size\", mrb_file_size, MRB_ARGS_NONE());\n  mrb_define_method(mrb, file, \"truncate\", mrb_file_truncate, MRB_ARGS_REQ(1));\n\n  cnst = mrb_define_module_under_id(mrb, file, MRB_SYM(Constants));\n  mrb_define_const_id(mrb, cnst, MRB_SYM(LOCK_SH), mrb_fixnum_value(LOCK_SH));\n  mrb_define_const_id(mrb, cnst, MRB_SYM(LOCK_EX), mrb_fixnum_value(LOCK_EX));\n  mrb_define_const_id(mrb, cnst, MRB_SYM(LOCK_UN), mrb_fixnum_value(LOCK_UN));\n  mrb_define_const_id(mrb, cnst, MRB_SYM(LOCK_NB), mrb_fixnum_value(LOCK_NB));\n  mrb_define_const_id(mrb, cnst, MRB_SYM(SEPARATOR), mrb_str_new_cstr(mrb, FILE_SEPARATOR));\n  mrb_define_const_id(mrb, cnst, MRB_SYM(PATH_SEPARATOR), mrb_str_new_cstr(mrb, PATH_SEPARATOR));\n#if defined(_WIN32) || defined(_WIN64)\n  mrb_define_const_id(mrb, cnst, MRB_SYM(ALT_SEPARATOR), mrb_str_new_cstr(mrb, FILE_ALT_SEPARATOR));\n#else\n  mrb_define_const_id(mrb, cnst, MRB_SYM(ALT_SEPARATOR), mrb_nil_value());\n#endif\n  mrb_define_const_id(mrb, cnst, MRB_SYM(NULL), mrb_str_new_cstr(mrb, NULL_FILE));\n\n  mrb_define_const_id(mrb, cnst, MRB_SYM(RDONLY), mrb_fixnum_value(MRB_O_RDONLY));\n  mrb_define_const_id(mrb, cnst, MRB_SYM(WRONLY), mrb_fixnum_value(MRB_O_WRONLY));\n  mrb_define_const_id(mrb, cnst, MRB_SYM(RDWR), mrb_fixnum_value(MRB_O_RDWR));\n  mrb_define_const_id(mrb, cnst, MRB_SYM(APPEND), mrb_fixnum_value(MRB_O_APPEND));\n  mrb_define_const_id(mrb, cnst, MRB_SYM(CREAT), mrb_fixnum_value(MRB_O_CREAT));\n  mrb_define_const_id(mrb, cnst, MRB_SYM(EXCL), mrb_fixnum_value(MRB_O_EXCL));\n  mrb_define_const_id(mrb, cnst, MRB_SYM(TRUNC), mrb_fixnum_value(MRB_O_TRUNC));\n  mrb_define_const_id(mrb, cnst, MRB_SYM(NONBLOCK), mrb_fixnum_value(MRB_O_NONBLOCK));\n  mrb_define_const_id(mrb, cnst, MRB_SYM(NOCTTY), mrb_fixnum_value(MRB_O_NOCTTY));\n  mrb_define_const_id(mrb, cnst, MRB_SYM(BINARY), mrb_fixnum_value(MRB_O_BINARY));\n  mrb_define_const_id(mrb, cnst, MRB_SYM(SHARE_DELETE), mrb_fixnum_value(MRB_O_SHARE_DELETE));\n  mrb_define_const_id(mrb, cnst, MRB_SYM(SYNC), mrb_fixnum_value(MRB_O_SYNC));\n  mrb_define_const_id(mrb, cnst, MRB_SYM(DSYNC), mrb_fixnum_value(MRB_O_DSYNC));\n  mrb_define_const_id(mrb, cnst, MRB_SYM(RSYNC), mrb_fixnum_value(MRB_O_RSYNC));\n  mrb_define_const_id(mrb, cnst, MRB_SYM(NOFOLLOW), mrb_fixnum_value(MRB_O_NOFOLLOW));\n  mrb_define_const_id(mrb, cnst, MRB_SYM(NOATIME), mrb_fixnum_value(MRB_O_NOATIME));\n  mrb_define_const_id(mrb, cnst, MRB_SYM(DIRECT), mrb_fixnum_value(MRB_O_DIRECT));\n  mrb_define_const_id(mrb, cnst, MRB_SYM(TMPFILE), mrb_fixnum_value(MRB_O_TMPFILE));\n}\n",
    "target": 1,
    "idx": 1056406,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "// context\nvoid XMLCDECL\n__xmlRaiseError(xmlStructuredErrorFunc schannel,\n              xmlGenericErrorFunc channel, void *data, void *ctx,\n              void *nod, int domain, int code, xmlErrorLevel level,\n              const char *file, int line, const char *str1,\n              const char *str2, const char *str3, int int1, int col,\n\t      const char *msg, ...)\n{\n    xmlParserCtxtPtr ctxt = NULL;\n    xmlNodePtr node = (xmlNodePtr) nod;\n    char *str = NULL;\n    xmlParserInputPtr input = NULL;\n    xmlErrorPtr to = &xmlLastError;\n    xmlNodePtr baseptr = NULL;\n\n    if (code == XML_ERR_OK)\n        return;\n    if ((xmlGetWarningsDefaultValue == 0) && (level == XML_ERR_WARNING))\n        return;\n    if ((domain == XML_FROM_PARSER) || (domain == XML_FROM_HTML) ||\n        (domain == XML_FROM_DTD) || (domain == XML_FROM_NAMESPACE) ||\n\t(domain == XML_FROM_IO) || (domain == XML_FROM_VALID)) {\n\tctxt = (xmlParserCtxtPtr) ctx;\n\tif ((schannel == NULL) && (ctxt != NULL) && (ctxt->sax != NULL) &&\n\t    (ctxt->sax->initialized == XML_SAX2_MAGIC) &&\n\t    (ctxt->sax->serror != NULL)) {\n\t    schannel = ctxt->sax->serror;\n\t    data = ctxt->userData;\n\t}\n    }\n    /*\n     * Check if structured error handler set\n     */\n    if (schannel == NULL) {\n\tschannel = xmlStructuredError;\n\t/*\n\t * if user has defined handler, change data ptr to user's choice\n\t */\n\tif (schannel != NULL)\n\t    data = xmlStructuredErrorContext;\n    }\n    /*\n     * Formatting the message\n     */\n    if (msg == NULL) {\n        str = (char *) xmlStrdup(BAD_CAST \"No error message provided\");\n    } else {\n        XML_GET_VAR_STR(msg, str);\n    }\n\n    /*\n     * specific processing if a parser context is provided\n     */\n    if (ctxt != NULL) {\n        if (file == NULL) {\n            input = ctxt->input;\n            if ((input != NULL) && (input->filename == NULL) &&\n                (ctxt->inputNr > 1)) {\n                input = ctxt->inputTab[ctxt->inputNr - 2];\n            }\n            if (input != NULL) {\n                file = input->filename;\n                line = input->line;\n                col = input->col;\n            }\n        }\n        to = &ctxt->lastError;\n    } else if ((node != NULL) && (file == NULL)) {\n\tint i;\n\n\tif ((node->doc != NULL) && (node->doc->URL != NULL)) {\n\t    baseptr = node;\n/*\t    file = (const char *) node->doc->URL; */\n\t}\n\tfor (i = 0;\n\t     ((i < 10) && (node != NULL) && (node->type != XML_ELEMENT_NODE));\n\t     i++)\n\t     node = node->parent;\n        if ((baseptr == NULL) && (node != NULL) &&\n\t    (node->doc != NULL) && (node->doc->URL != NULL))\n\t    baseptr = node;\n\n\tif ((node != NULL) && (node->type == XML_ELEMENT_NODE))\n\t    line = node->line;\n\tif ((line == 0) || (line == 65535))\n\t    line = xmlGetLineNo(node);\n    }\n\n    /*\n     * Save the information about the error\n     */\n    xmlResetError(to);\n    to->domain = domain;\n    to->code = code;\n    to->message = str;\n    to->level = level;\n    if (file != NULL)\n        to->file = (char *) xmlStrdup((const xmlChar *) file);\n    else if (baseptr != NULL) {\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t/*\n\t * We check if the error is within an XInclude section and,\n\t * if so, attempt to print out the href of the XInclude instead\n\t * of the usual \"base\" (doc->URL) for the node (bug 152623).\n\t */\n        xmlNodePtr prev = baseptr;\n\tint inclcount = 0;\n\twhile (prev != NULL) {\n\t    if (prev->prev == NULL)\n\t        prev = prev->parent;\n\t    else {\n\t        prev = prev->prev;\n\t\tif (prev->type == XML_XINCLUDE_START) {\n\t\t    if (--inclcount < 0)\n\t\t        break;\n\t\t} else if (prev->type == XML_XINCLUDE_END)\n\t\t    inclcount++;\n\t    }\n\t}\n\tif (prev != NULL) {\n\t    if (prev->type == XML_XINCLUDE_START) {\n\t\tprev->type = XML_ELEMENT_NODE;\n\t\tto->file = (char *) xmlGetProp(prev, BAD_CAST \"href\");\n\t\tprev->type = XML_XINCLUDE_START;\n\t    } else {\n\t\tto->file = (char *) xmlGetProp(prev, BAD_CAST \"href\");\n\t    }\n\t} else\n#endif\n\t    to->file = (char *) xmlStrdup(baseptr->doc->URL);\n\tif ((to->file == NULL) && (node != NULL) && (node->doc != NULL)) {\n\t    to->file = (char *) xmlStrdup(node->doc->URL);\n\t}\n    }\n    to->line = line;\n    if (str1 != NULL)\n        to->str1 = (char *) xmlStrdup((const xmlChar *) str1);\n    if (str2 != NULL)\n        to->str2 = (char *) xmlStrdup((const xmlChar *) str2);\n    if (str3 != NULL)\n        to->str3 = (char *) xmlStrdup((const xmlChar *) str3);\n    to->int1 = int1;\n    to->int2 = col;\n    to->node = node;\n    to->ctxt = ctx;\n\n    if (to != &xmlLastError)\n        xmlCopyError(to,&xmlLastError);\n\n    if (schannel != NULL) {\n\tschannel(data, to);\n\treturn;\n    }\n\n    /*\n     * Find the callback channel if channel param is NULL\n     */\n    if ((ctxt != NULL) && (channel == NULL) &&\n        (xmlStructuredError == NULL) && (ctxt->sax != NULL)) {\n        if (level == XML_ERR_WARNING)\n\t    channel = ctxt->sax->warning;\n        else\n\t    channel = ctxt->sax->error;\n\tdata = ctxt->userData;\n    } else if (channel == NULL) {\n\tchannel = xmlGenericError;\n\tif (ctxt != NULL) {\n\t    data = ctxt;\n\t} else {\n\t    data = xmlGenericErrorContext;\n\t}\n    }\n    if (channel == NULL)\n        return;\n\n    if ((channel == xmlParserError) ||\n        (channel == xmlParserWarning) ||\n\t(channel == xmlParserValidityError) ||\n\t(channel == xmlParserValidityWarning))\n\txmlReportError(to, ctxt, str, NULL, NULL);\n    else if (((void(*)(void)) channel == (void(*)(void)) fprintf) ||\n             (channel == xmlGenericErrorDefaultFunc))\n\txmlReportError(to, ctxt, str, channel, data);\n    else\n\tchannel(data, \"%s\", str);\n}\n\n\n\nstatic void\nxmlValidateRef(xmlRefPtr ref, xmlValidCtxtPtr ctxt,\n\t                   const xmlChar *name) {\n    xmlAttrPtr id;\n    xmlAttrPtr attr;\n\n    if (ref == NULL)\n\treturn;\n    if ((ref->attr == NULL) && (ref->name == NULL))\n\treturn;\n    attr = ref->attr;\n    if (attr == NULL) {\n\txmlChar *dup, *str = NULL, *cur, save;\n\n\tdup = xmlStrdup(name);\n\tif (dup == NULL) {\n\t    ctxt->valid = 0;\n\t    return;\n\t}\n\tcur = dup;\n\twhile (*cur != 0) {\n\t    str = cur;\n\t    while ((*cur != 0) && (!IS_BLANK_CH(*cur))) cur++;\n\t    save = *cur;\n\t    *cur = 0;\n\t    id = xmlGetID(ctxt->doc, str);\n\t    if (id == NULL) {\n\t\txmlErrValidNodeNr(ctxt, NULL, XML_DTD_UNKNOWN_ID,\n\t   \"attribute %s line %d references an unknown ID \\\"%s\\\"\\n\",\n\t\t       ref->name, ref->lineno, str);\n\t\tctxt->valid = 0;\n\t    }\n\t    if (save == 0)\n\t\tbreak;\n\t    *cur = save;\n\t    while (IS_BLANK_CH(*cur)) cur++;\n\t}\n\txmlFree(dup);\n    } else if (attr->atype == XML_ATTRIBUTE_IDREF) {\n\tid = xmlGetID(ctxt->doc, name);\n\tif (id == NULL) {\n\t    xmlErrValidNode(ctxt, attr->parent, XML_DTD_UNKNOWN_ID,\n\t   \"IDREF attribute %s references an unknown ID \\\"%s\\\"\\n\",\n\t\t   attr->name, name, NULL);\n\t    ctxt->valid = 0;\n\t}\n    } else if (attr->atype == XML_ATTRIBUTE_IDREFS) {\n\txmlChar *dup, *str = NULL, *cur, save;\n\n\tdup = xmlStrdup(name);\n\tif (dup == NULL) {\n\t    xmlVErrMemory(ctxt, \"IDREFS split\");\n\t    ctxt->valid = 0;\n\t    return;\n\t}\n\tcur = dup;\n\twhile (*cur != 0) {\n\t    str = cur;\n\t    while ((*cur != 0) && (!IS_BLANK_CH(*cur))) cur++;\n\t    save = *cur;\n\t    *cur = 0;\n\t    id = xmlGetID(ctxt->doc, str);\n\t    if (id == NULL) {\n\t\txmlErrValidNode(ctxt, attr->parent, XML_DTD_UNKNOWN_ID,\n\t   \"IDREFS attribute %s references an unknown ID \\\"%s\\\"\\n\",\n\t\t\t     attr->name, str, NULL);\n\t\tctxt->valid = 0;\n\t    }\n\t    if (save == 0)\n\t\tbreak;\n\t    *cur = save;\n\t    while (IS_BLANK_CH(*cur)) cur++;\n\t}\n\txmlFree(dup);\n    }\n}\n\nstatic int\nxmlWalkValidateList(const void *data, void *user)\n{\n\txmlValidateMemoPtr memo = (xmlValidateMemoPtr)user;\n\txmlValidateRef((xmlRefPtr)data, memo->ctxt, memo->name);\n\treturn 1;\n}\n\nvoid\nxmlListWalk(xmlListPtr l, xmlListWalker walker, void *user) {\n    xmlLinkPtr lk;\n\n    if ((l == NULL) || (walker == NULL))\n        return;\n    for(lk = l->sentinel->next; lk != l->sentinel; lk = lk->next) {\n        if((walker(lk->data, user)) == 0)\n                break;\n    }\n}\n\nstatic void\nxmlValidateCheckRefCallback(void *payload, void *data, const xmlChar *name) {\n    xmlListPtr ref_list = (xmlListPtr) payload;\n    xmlValidCtxtPtr ctxt = (xmlValidCtxtPtr) data;\n    xmlValidateMemo memo;\n\n    if (ref_list == NULL)\n\treturn;\n    memo.ctxt = ctxt;\n    memo.name = name;\n\n    xmlListWalk(ref_list, xmlWalkValidateList, &memo);\n\n}\n\nstatic void\nstubHashScannerFull (void *payload, void *data, const xmlChar *name,\n                     const xmlChar *name2 ATTRIBUTE_UNUSED,\n\t\t     const xmlChar *name3 ATTRIBUTE_UNUSED) {\n    stubData *stubdata = (stubData *) data;\n    stubdata->hashscanner (payload, stubdata->data, (xmlChar *) name);\n}\n\nvoid\nxmlHashScanFull(xmlHashTablePtr table, xmlHashScannerFull f, void *data) {\n    int i, nb;\n    xmlHashEntryPtr iter;\n    xmlHashEntryPtr next;\n\n    if (table == NULL)\n\treturn;\n    if (f == NULL)\n\treturn;\n\n    if (table->table) {\n\tfor(i = 0; i < table->size; i++) {\n\t    if (table->table[i].valid == 0)\n\t\tcontinue;\n\t    iter = &(table->table[i]);\n\t    while (iter) {\n\t\tnext = iter->next;\n                nb = table->nbElems;\n\t\tif ((f != NULL) && (iter->payload != NULL))\n\t\t    f(iter->payload, data, iter->name,\n\t\t      iter->name2, iter->name3);\n                if (nb != table->nbElems) {\n                    /* table was modified by the callback, be careful */\n                    if (iter == &(table->table[i])) {\n                        if (table->table[i].valid == 0)\n                            iter = NULL;\n                        if (table->table[i].next != next)\n\t\t\t    iter = &(table->table[i]);\n                    } else\n\t\t        iter = next;\n                } else\n\t\t    iter = next;\n\t    }\n\t}\n    }\n}\n\nvoid\nxmlHashScan(xmlHashTablePtr table, xmlHashScanner f, void *data) {\n    stubData stubdata;\n    stubdata.data = data;\n    stubdata.hashscanner = f;\n    xmlHashScanFull (table, stubHashScannerFull, &stubdata);\n}\n\nint\nxmlValidateDocumentFinal(xmlValidCtxtPtr ctxt, xmlDocPtr doc) {\n    xmlRefTablePtr table;\n    unsigned int save;\n\n    if (ctxt == NULL)\n        return(0);\n    if (doc == NULL) {\n        xmlErrValid(ctxt, XML_DTD_NO_DOC,\n\t\t\"xmlValidateDocumentFinal: doc == NULL\\n\", NULL);\n\treturn(0);\n    }\n\n    /* trick to get correct line id report */\n    save = ctxt->finishDtd;\n    ctxt->finishDtd = 0;\n\n    /*\n     * Check all the NOTATION/NOTATIONS attributes\n     */\n    /*\n     * Check all the ENTITY/ENTITIES attributes definition for validity\n     */\n    /*\n     * Check all the IDREF/IDREFS attributes definition for validity\n     */\n    table = (xmlRefTablePtr) doc->refs;\n    ctxt->doc = doc;\n    ctxt->valid = 1;\n    xmlHashScan(table, xmlValidateCheckRefCallback, ctxt);\n\n    ctxt->finishDtd = save;\n    return(ctxt->valid);\n}\n\nvoid\nxmlSAX2EndDocument(void *ctx)\n{\n    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;\n#ifdef DEBUG_SAX\n    xmlGenericError(xmlGenericErrorContext,\n\t    \"SAX.xmlSAX2EndDocument()\\n\");\n#endif\n    if (ctx == NULL) return;\n#ifdef LIBXML_VALID_ENABLED\n    if (ctxt->validate && ctxt->wellFormed &&\n        ctxt->myDoc && ctxt->myDoc->intSubset)\n\tctxt->valid &= xmlValidateDocumentFinal(&ctxt->vctxt, ctxt->myDoc);\n#endif /* LIBXML_VALID_ENABLED */\n\n    /*\n     * Grab the encoding if it was added on-the-fly\n     */\n    if ((ctxt->encoding != NULL) && (ctxt->myDoc != NULL) &&\n\t(ctxt->myDoc->encoding == NULL)) {\n\tctxt->myDoc->encoding = ctxt->encoding;\n\tctxt->encoding = NULL;\n    }\n    if ((ctxt->inputTab != NULL) &&\n        (ctxt->inputNr > 0) && (ctxt->inputTab[0] != NULL) &&\n        (ctxt->inputTab[0]->encoding != NULL) && (ctxt->myDoc != NULL) &&\n\t(ctxt->myDoc->encoding == NULL)) {\n\tctxt->myDoc->encoding = xmlStrdup(ctxt->inputTab[0]->encoding);\n    }\n    if ((ctxt->charset != XML_CHAR_ENCODING_NONE) && (ctxt->myDoc != NULL) &&\n\t(ctxt->myDoc->charset == XML_CHAR_ENCODING_NONE)) {\n\tctxt->myDoc->charset = ctxt->charset;\n    }\n}\n\nint\nxmlParseChunk(xmlParserCtxtPtr ctxt, const char *chunk, int size,\n              int terminate) {\n    int end_in_lf = 0;\n    int remain = 0;\n    size_t old_avail = 0;\n    size_t avail = 0;\n\n    if (ctxt == NULL)\n        return(XML_ERR_INTERNAL_ERROR);\n    if ((ctxt->errNo != XML_ERR_OK) && (ctxt->disableSAX == 1))\n        return(ctxt->errNo);\n    if (ctxt->instate == XML_PARSER_EOF)\n        return(-1);\n    if (ctxt->instate == XML_PARSER_START)\n        xmlDetectSAX2(ctxt);\n    if ((size > 0) && (chunk != NULL) && (!terminate) &&\n        (chunk[size - 1] == '\\r')) {\n\tend_in_lf = 1;\n\tsize--;\n    }\n\nxmldecl_done:\n\n    if ((size > 0) && (chunk != NULL) && (ctxt->input != NULL) &&\n        (ctxt->input->buf != NULL) && (ctxt->instate != XML_PARSER_EOF))  {\n\tsize_t base = xmlBufGetInputBase(ctxt->input->buf->buffer, ctxt->input);\n\tsize_t cur = ctxt->input->cur - ctxt->input->base;\n\tint res;\n\n        old_avail = xmlBufUse(ctxt->input->buf->buffer);\n        /*\n         * Specific handling if we autodetected an encoding, we should not\n         * push more than the first line ... which depend on the encoding\n         * And only push the rest once the final encoding was detected\n         */\n        if ((ctxt->instate == XML_PARSER_START) && (ctxt->input != NULL) &&\n            (ctxt->input->buf != NULL) && (ctxt->input->buf->encoder != NULL)) {\n            unsigned int len = 45;\n\n            if ((xmlStrcasestr(BAD_CAST ctxt->input->buf->encoder->name,\n                               BAD_CAST \"UTF-16\")) ||\n                (xmlStrcasestr(BAD_CAST ctxt->input->buf->encoder->name,\n                               BAD_CAST \"UTF16\")))\n                len = 90;\n            else if ((xmlStrcasestr(BAD_CAST ctxt->input->buf->encoder->name,\n                                    BAD_CAST \"UCS-4\")) ||\n                     (xmlStrcasestr(BAD_CAST ctxt->input->buf->encoder->name,\n                                    BAD_CAST \"UCS4\")))\n                len = 180;\n\n            if (ctxt->input->buf->rawconsumed < len)\n                len -= ctxt->input->buf->rawconsumed;\n\n            /*\n             * Change size for reading the initial declaration only\n             * if size is greater than len. Otherwise, memmove in xmlBufferAdd\n             * will blindly copy extra bytes from memory.\n             */\n            if ((unsigned int) size > len) {\n                remain = size - len;\n                size = len;\n            } else {\n                remain = 0;\n            }\n        }\n\tres = xmlParserInputBufferPush(ctxt->input->buf, size, chunk);\n\tif (res < 0) {\n\t    ctxt->errNo = XML_PARSER_EOF;\n\t    xmlHaltParser(ctxt);\n\t    return (XML_PARSER_EOF);\n\t}\n        xmlBufSetInputBaseCur(ctxt->input->buf->buffer, ctxt->input, base, cur);\n#ifdef DEBUG_PUSH\n\txmlGenericError(xmlGenericErrorContext, \"PP: pushed %d\\n\", size);\n#endif\n\n    } else if (ctxt->instate != XML_PARSER_EOF) {\n\tif ((ctxt->input != NULL) && ctxt->input->buf != NULL) {\n\t    xmlParserInputBufferPtr in = ctxt->input->buf;\n\t    if ((in->encoder != NULL) && (in->buffer != NULL) &&\n\t\t    (in->raw != NULL)) {\n\t\tint nbchars;\n\t\tsize_t base = xmlBufGetInputBase(in->buffer, ctxt->input);\n\t\tsize_t current = ctxt->input->cur - ctxt->input->base;\n\n\t\tnbchars = xmlCharEncInput(in, terminate);\n\t\tif (nbchars < 0) {\n\t\t    /* TODO 2.6.0 */\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t\t    \"xmlParseChunk: encoder error\\n\");\n                    xmlHaltParser(ctxt);\n\t\t    return(XML_ERR_INVALID_ENCODING);\n\t\t}\n\t\txmlBufSetInputBaseCur(in->buffer, ctxt->input, base, current);\n\t    }\n\t}\n    }\n    if (remain != 0) {\n        xmlParseTryOrFinish(ctxt, 0);\n    } else {\n        if ((ctxt->input != NULL) && (ctxt->input->buf != NULL))\n            avail = xmlBufUse(ctxt->input->buf->buffer);\n        /*\n         * Depending on the current state it may not be such\n         * a good idea to try parsing if there is nothing in the chunk\n         * which would be worth doing a parser state transition and we\n         * need to wait for more data\n         */\n        if ((terminate) || (avail > XML_MAX_TEXT_LENGTH) ||\n            (old_avail == 0) || (avail == 0) ||\n            (xmlParseCheckTransition(ctxt,\n                       (const char *)&ctxt->input->base[old_avail],\n                                     avail - old_avail)))\n            xmlParseTryOrFinish(ctxt, terminate);\n    }\n    if (ctxt->instate == XML_PARSER_EOF)\n        return(ctxt->errNo);\n\n    if ((ctxt->input != NULL) &&\n         (((ctxt->input->end - ctxt->input->cur) > XML_MAX_LOOKUP_LIMIT) ||\n         ((ctxt->input->cur - ctxt->input->base) > XML_MAX_LOOKUP_LIMIT)) &&\n        ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n        xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, \"Huge input lookup\");\n        xmlHaltParser(ctxt);\n    }\n    if ((ctxt->errNo != XML_ERR_OK) && (ctxt->disableSAX == 1))\n        return(ctxt->errNo);\n\n    if (remain != 0) {\n        chunk += size;\n        size = remain;\n        remain = 0;\n        goto xmldecl_done;\n    }\n    if ((end_in_lf == 1) && (ctxt->input != NULL) &&\n        (ctxt->input->buf != NULL)) {\n\tsize_t base = xmlBufGetInputBase(ctxt->input->buf->buffer,\n\t\t\t\t\t ctxt->input);\n\tsize_t current = ctxt->input->cur - ctxt->input->base;\n\n\txmlParserInputBufferPush(ctxt->input->buf, 1, \"\\r\");\n\n\txmlBufSetInputBaseCur(ctxt->input->buf->buffer, ctxt->input,\n\t\t\t      base, current);\n    }\n    if (terminate) {\n\t/*\n\t * Check for termination\n\t */\n\tint cur_avail = 0;\n\n\tif (ctxt->input != NULL) {\n\t    if (ctxt->input->buf == NULL)\n\t\tcur_avail = ctxt->input->length -\n\t\t\t    (ctxt->input->cur - ctxt->input->base);\n\t    else\n\t\tcur_avail = xmlBufUse(ctxt->input->buf->buffer) -\n\t\t\t              (ctxt->input->cur - ctxt->input->base);\n\t}\n\n\tif ((ctxt->instate != XML_PARSER_EOF) &&\n\t    (ctxt->instate != XML_PARSER_EPILOG)) {\n\t    xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);\n\t}\n\tif ((ctxt->instate == XML_PARSER_EPILOG) && (cur_avail > 0)) {\n\t    xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);\n\t}\n\tif (ctxt->instate != XML_PARSER_EOF) {\n\t    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n\t\tctxt->sax->endDocument(ctxt->userData);\n\t}\n\tctxt->instate = XML_PARSER_EOF;\n    }\n    if (ctxt->wellFormed == 0)\n\treturn((xmlParserErrors) ctxt->errNo);\n    else\n        return(0);\n}\n\nstatic int\nxmlTextReaderPushData(xmlTextReaderPtr reader) {\n    xmlBufPtr inbuf;\n    int val, s;\n    xmlTextReaderState oldstate;\n    int alloc;\n\n    if ((reader->input == NULL) || (reader->input->buffer == NULL))\n\treturn(-1);\n\n    oldstate = reader->state;\n    reader->state = XML_TEXTREADER_NONE;\n    inbuf = reader->input->buffer;\n    alloc = xmlBufGetAllocationScheme(inbuf);\n\n    while (reader->state == XML_TEXTREADER_NONE) {\n\tif (xmlBufUse(inbuf) < reader->cur + CHUNK_SIZE) {\n\t    /*\n\t     * Refill the buffer unless we are at the end of the stream\n\t     */\n\t    if (reader->mode != XML_TEXTREADER_MODE_EOF) {\n\t\tval = xmlParserInputBufferRead(reader->input, 4096);\n\t\tif ((val == 0) &&\n\t\t    (alloc == XML_BUFFER_ALLOC_IMMUTABLE)) {\n\t\t    if (xmlBufUse(inbuf) == reader->cur) {\n\t\t\treader->mode = XML_TEXTREADER_MODE_EOF;\n\t\t\treader->state = oldstate;\n\t\t    }\n\t\t} else if (val < 0) {\n\t\t    reader->mode = XML_TEXTREADER_MODE_EOF;\n\t\t    reader->state = oldstate;\n\t\t    if ((oldstate != XML_TEXTREADER_START) ||\n\t\t\t(reader->ctxt->myDoc != NULL))\n\t\t\treturn(val);\n\t\t} else if (val == 0) {\n\t\t    /* mark the end of the stream and process the remains */\n\t\t    reader->mode = XML_TEXTREADER_MODE_EOF;\n\t\t    break;\n\t\t}\n\n\t    } else\n\t\tbreak;\n\t}\n\t/*\n\t * parse by block of CHUNK_SIZE bytes, various tests show that\n\t * it's the best tradeoff at least on a 1.2GH Duron\n\t */\n\tif (xmlBufUse(inbuf) >= reader->cur + CHUNK_SIZE) {\n\t    val = xmlParseChunk(reader->ctxt,\n                 (const char *) xmlBufContent(inbuf) + reader->cur,\n                                CHUNK_SIZE, 0);\n\t    reader->cur += CHUNK_SIZE;\n\t    if (val != 0)\n\t\treader->ctxt->wellFormed = 0;\n\t    if (reader->ctxt->wellFormed == 0)\n\t\tbreak;\n\t} else {\n\t    s = xmlBufUse(inbuf) - reader->cur;\n\t    val = xmlParseChunk(reader->ctxt,\n\t\t (const char *) xmlBufContent(inbuf) + reader->cur,\n\t\t\t        s, 0);\n\t    reader->cur += s;\n\t    if (val != 0)\n\t\treader->ctxt->wellFormed = 0;\n\t    break;\n\t}\n    }\n\n    /*\n     * Discard the consumed input when needed and possible\n     */\n    if (reader->mode == XML_TEXTREADER_MODE_INTERACTIVE) {\n        if (alloc != XML_BUFFER_ALLOC_IMMUTABLE) {\n\t    if ((reader->cur >= 4096) &&\n\t\t(xmlBufUse(inbuf) - reader->cur <= CHUNK_SIZE)) {\n\t\tval = xmlBufShrink(inbuf, reader->cur);\n\t\tif (val >= 0) {\n\t\t    reader->cur -= val;\n\t\t}\n\t    }\n\t}\n    }\n\n    /*\n     * At the end of the stream signal that the work is done to the Push\n     * parser.\n     */\n    else if (reader->mode == XML_TEXTREADER_MODE_EOF) {\n\tif (reader->state != XML_TEXTREADER_DONE) {\n\t    s = xmlBufUse(inbuf) - reader->cur;\n\t    val = xmlParseChunk(reader->ctxt,\n\t\t (const char *) xmlBufContent(inbuf) + reader->cur,\n\t\t\t        s, 1);\n\t    reader->cur = xmlBufUse(inbuf);\n\t    reader->state  = XML_TEXTREADER_DONE;\n\t    if (val != 0) {\n\t        if (reader->ctxt->wellFormed)\n\t\t    reader->ctxt->wellFormed = 0;\n\t\telse\n\t\t    return(-1);\n\t    }\n\t}\n    }\n    reader->state = oldstate;\n    if (reader->ctxt->wellFormed == 0) {\n\treader->mode = XML_TEXTREADER_MODE_EOF;\n        return(-1);\n    }\n\n    return(0);\n}\n\nint\nxmlTextReaderRead(xmlTextReaderPtr reader) {\n    int val, olddepth = 0;\n    xmlTextReaderState oldstate = XML_TEXTREADER_START;\n    xmlNodePtr oldnode = NULL;\n\n\n    if (reader == NULL)\n\treturn(-1);\n    reader->curnode = NULL;\n    if (reader->doc != NULL)\n        return(xmlTextReaderReadTree(reader));\n    if (reader->ctxt == NULL)\n\treturn(-1);\n\n#ifdef DEBUG_READER\n    fprintf(stderr, \"\\nREAD \");\n    DUMP_READER\n#endif\n    if (reader->mode == XML_TEXTREADER_MODE_INITIAL) {\n\treader->mode = XML_TEXTREADER_MODE_INTERACTIVE;\n\t/*\n\t * Initial state\n\t */\n\tdo {\n\t    val = xmlTextReaderPushData(reader);\n\t\tif (val < 0){\n\t\t\treader->mode = XML_TEXTREADER_MODE_ERROR;\n\t\t\treader->state = XML_TEXTREADER_ERROR;\n\t\treturn(-1);\n\t\t}\n\t} while ((reader->ctxt->node == NULL) &&\n\t\t ((reader->mode != XML_TEXTREADER_MODE_EOF) &&\n\t\t  (reader->state != XML_TEXTREADER_DONE)));\n\tif (reader->ctxt->node == NULL) {\n\t    if (reader->ctxt->myDoc != NULL) {\n\t\treader->node = reader->ctxt->myDoc->children;\n\t    }\n\t    if (reader->node == NULL){\n\t\t\treader->mode = XML_TEXTREADER_MODE_ERROR;\n\t\t\treader->state = XML_TEXTREADER_ERROR;\n\t\treturn(-1);\n\t\t}\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t} else {\n\t    if (reader->ctxt->myDoc != NULL) {\n\t\treader->node = reader->ctxt->myDoc->children;\n\t    }\n\t    if (reader->node == NULL)\n\t\treader->node = reader->ctxt->nodeTab[0];\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t}\n\treader->depth = 0;\n\treader->ctxt->parseMode = XML_PARSE_READER;\n\tgoto node_found;\n    }\n    oldstate = reader->state;\n    olddepth = reader->ctxt->nodeNr;\n    oldnode = reader->node;\n\nget_next_node:\n    if (reader->node == NULL) {\n\tif (reader->mode == XML_TEXTREADER_MODE_EOF)\n\t    return(0);\n\telse\n\t    return(-1);\n    }\n\n    /*\n     * If we are not backtracking on ancestors or examined nodes,\n     * that the parser didn't finished or that we aren't at the end\n     * of stream, continue processing.\n     */\n    while ((reader->node != NULL) && (reader->node->next == NULL) &&\n\t   (reader->ctxt->nodeNr == olddepth) &&\n           ((oldstate == XML_TEXTREADER_BACKTRACK) ||\n            (reader->node->children == NULL) ||\n\t    (reader->node->type == XML_ENTITY_REF_NODE) ||\n\t    ((reader->node->children != NULL) &&\n\t     (reader->node->children->type == XML_TEXT_NODE) &&\n\t     (reader->node->children->next == NULL)) ||\n\t    (reader->node->type == XML_DTD_NODE) ||\n\t    (reader->node->type == XML_DOCUMENT_NODE) ||\n\t    (reader->node->type == XML_HTML_DOCUMENT_NODE)) &&\n\t   ((reader->ctxt->node == NULL) ||\n\t    (reader->ctxt->node == reader->node) ||\n\t    (reader->ctxt->node == reader->node->parent)) &&\n\t   (reader->ctxt->instate != XML_PARSER_EOF)) {\n\tval = xmlTextReaderPushData(reader);\n\tif (val < 0){\n\t\treader->mode = XML_TEXTREADER_MODE_ERROR;\n\t\treader->state = XML_TEXTREADER_ERROR;\n\t    return(-1);\n\t}\n\tif (reader->node == NULL)\n\t    goto node_end;\n    }\n    if (oldstate != XML_TEXTREADER_BACKTRACK) {\n\tif ((reader->node->children != NULL) &&\n\t    (reader->node->type != XML_ENTITY_REF_NODE) &&\n\t    (reader->node->type != XML_XINCLUDE_START) &&\n\t    (reader->node->type != XML_DTD_NODE)) {\n\t    reader->node = reader->node->children;\n\t    reader->depth++;\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t    goto node_found;\n\t}\n    }\n    if (reader->node->next != NULL) {\n\tif ((oldstate == XML_TEXTREADER_ELEMENT) &&\n            (reader->node->type == XML_ELEMENT_NODE) &&\n\t    (reader->node->children == NULL) &&\n\t    ((reader->node->extra & NODE_IS_EMPTY) == 0)\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    && (reader->in_xinclude <= 0)\n#endif\n\t    ) {\n\t    reader->state = XML_TEXTREADER_END;\n\t    goto node_found;\n\t}\n#ifdef LIBXML_REGEXP_ENABLED\n\tif ((reader->validate) &&\n\t    (reader->node->type == XML_ELEMENT_NODE))\n\t    xmlTextReaderValidatePop(reader);\n#endif /* LIBXML_REGEXP_ENABLED */\n        if ((reader->preserves > 0) &&\n\t    (reader->node->extra & NODE_IS_SPRESERVED))\n\t    reader->preserves--;\n\treader->node = reader->node->next;\n\treader->state = XML_TEXTREADER_ELEMENT;\n\n\t/*\n\t * Cleanup of the old node\n\t */\n\tif ((reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    (reader->in_xinclude == 0) &&\n#endif\n\t    (reader->entNr == 0) &&\n\t    (reader->node->prev != NULL) &&\n            (reader->node->prev->type != XML_DTD_NODE)) {\n\t    xmlNodePtr tmp = reader->node->prev;\n\t    if ((tmp->extra & NODE_IS_PRESERVED) == 0) {\n\t\txmlUnlinkNode(tmp);\n\t\txmlTextReaderFreeNode(reader, tmp);\n\t    }\n\t}\n\n\tgoto node_found;\n    }\n    if ((oldstate == XML_TEXTREADER_ELEMENT) &&\n\t(reader->node->type == XML_ELEMENT_NODE) &&\n\t(reader->node->children == NULL) &&\n\t((reader->node->extra & NODE_IS_EMPTY) == 0)) {;\n\treader->state = XML_TEXTREADER_END;\n\tgoto node_found;\n    }\n#ifdef LIBXML_REGEXP_ENABLED\n    if ((reader->validate != XML_TEXTREADER_NOT_VALIDATE) && (reader->node->type == XML_ELEMENT_NODE))\n\txmlTextReaderValidatePop(reader);\n#endif /* LIBXML_REGEXP_ENABLED */\n    if ((reader->preserves > 0) &&\n\t(reader->node->extra & NODE_IS_SPRESERVED))\n\treader->preserves--;\n    reader->node = reader->node->parent;\n    if ((reader->node == NULL) ||\n\t(reader->node->type == XML_DOCUMENT_NODE) ||\n#ifdef LIBXML_DOCB_ENABLED\n\t(reader->node->type == XML_DOCB_DOCUMENT_NODE) ||\n#endif\n\t(reader->node->type == XML_HTML_DOCUMENT_NODE)) {\n\tif (reader->mode != XML_TEXTREADER_MODE_EOF) {\n\t    val = xmlParseChunk(reader->ctxt, \"\", 0, 1);\n\t    reader->state = XML_TEXTREADER_DONE;\n\t    if (val != 0)\n\t        return(-1);\n\t}\n\treader->node = NULL;\n\treader->depth = -1;\n\n\t/*\n\t * Cleanup of the old node\n\t */\n\tif ((oldnode != NULL) && (reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    (reader->in_xinclude == 0) &&\n#endif\n\t    (reader->entNr == 0) &&\n\t    (oldnode->type != XML_DTD_NODE) &&\n\t    ((oldnode->extra & NODE_IS_PRESERVED) == 0)) {\n\t    xmlUnlinkNode(oldnode);\n\t    xmlTextReaderFreeNode(reader, oldnode);\n\t}\n\n\tgoto node_end;\n    }\n    if ((reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n        (reader->in_xinclude == 0) &&\n#endif\n\t(reader->entNr == 0) &&\n        (reader->node->last != NULL) &&\n        ((reader->node->last->extra & NODE_IS_PRESERVED) == 0)) {\n\txmlNodePtr tmp = reader->node->last;\n\txmlUnlinkNode(tmp);\n\txmlTextReaderFreeNode(reader, tmp);\n    }\n    reader->depth--;\n    reader->state = XML_TEXTREADER_BACKTRACK;\n\nnode_found:\n    DUMP_READER\n\n    /*\n     * If we are in the middle of a piece of CDATA make sure it's finished\n     */\n    if ((reader->node != NULL) &&\n        (reader->node->next == NULL) &&\n        ((reader->node->type == XML_TEXT_NODE) ||\n\t (reader->node->type == XML_CDATA_SECTION_NODE))) {\n            if (xmlTextReaderExpand(reader) == NULL)\n\t        return -1;\n    }\n\n#ifdef LIBXML_XINCLUDE_ENABLED\n    /*\n     * Handle XInclude if asked for\n     */\n    if ((reader->xinclude) && (reader->node != NULL) &&\n\t(reader->node->type == XML_ELEMENT_NODE) &&\n\t(reader->node->ns != NULL) &&\n\t((xmlStrEqual(reader->node->ns->href, XINCLUDE_NS)) ||\n\t (xmlStrEqual(reader->node->ns->href, XINCLUDE_OLD_NS)))) {\n\tif (reader->xincctxt == NULL) {\n\t    reader->xincctxt = xmlXIncludeNewContext(reader->ctxt->myDoc);\n\t    xmlXIncludeSetFlags(reader->xincctxt,\n\t                        reader->parserFlags & (~XML_PARSE_NOXINCNODE));\n\t}\n\t/*\n\t * expand that node and process it\n\t */\n\tif (xmlTextReaderExpand(reader) == NULL)\n\t    return -1;\n\txmlXIncludeProcessNode(reader->xincctxt, reader->node);\n    }\n    if ((reader->node != NULL) && (reader->node->type == XML_XINCLUDE_START)) {\n        reader->in_xinclude++;\n\tgoto get_next_node;\n    }\n    if ((reader->node != NULL) && (reader->node->type == XML_XINCLUDE_END)) {\n        reader->in_xinclude--;\n\tgoto get_next_node;\n    }\n#endif\n    /*\n     * Handle entities enter and exit when in entity replacement mode\n     */\n    if ((reader->node != NULL) &&\n\t(reader->node->type == XML_ENTITY_REF_NODE) &&\n\t(reader->ctxt != NULL) && (reader->ctxt->replaceEntities == 1)) {\n\tif ((reader->node->children != NULL) &&\n\t    (reader->node->children->type == XML_ENTITY_DECL) &&\n\t    (reader->node->children->children != NULL)) {\n\t    xmlTextReaderEntPush(reader, reader->node);\n\t    reader->node = reader->node->children->children;\n\t}\n#ifdef LIBXML_REGEXP_ENABLED\n    } else if ((reader->node != NULL) &&\n\t       (reader->node->type == XML_ENTITY_REF_NODE) &&\n\t       (reader->ctxt != NULL) && (reader->validate)) {\n\txmlTextReaderValidateEntity(reader);\n#endif /* LIBXML_REGEXP_ENABLED */\n    }\n    if ((reader->node != NULL) &&\n\t(reader->node->type == XML_ENTITY_DECL) &&\n\t(reader->ent != NULL) && (reader->ent->children == reader->node)) {\n\treader->node = xmlTextReaderEntPop(reader);\n\treader->depth++;\n        goto get_next_node;\n    }\n#ifdef LIBXML_REGEXP_ENABLED\n    if ((reader->validate != XML_TEXTREADER_NOT_VALIDATE) && (reader->node != NULL)) {\n\txmlNodePtr node = reader->node;\n\n\tif ((node->type == XML_ELEMENT_NODE) &&\n            ((reader->state != XML_TEXTREADER_END) &&\n\t     (reader->state != XML_TEXTREADER_BACKTRACK))) {\n\t    xmlTextReaderValidatePush(reader);\n\t} else if ((node->type == XML_TEXT_NODE) ||\n\t\t   (node->type == XML_CDATA_SECTION_NODE)) {\n            xmlTextReaderValidateCData(reader, node->content,\n\t                               xmlStrlen(node->content));\n\t}\n    }\n#endif /* LIBXML_REGEXP_ENABLED */\n#ifdef LIBXML_PATTERN_ENABLED\n    if ((reader->patternNr > 0) && (reader->state != XML_TEXTREADER_END) &&\n        (reader->state != XML_TEXTREADER_BACKTRACK)) {\n        int i;\n\tfor (i = 0;i < reader->patternNr;i++) {\n\t     if (xmlPatternMatch(reader->patternTab[i], reader->node) == 1) {\n\t         xmlTextReaderPreserve(reader);\n\t\t break;\n             }\n\t}\n    }\n#endif /* LIBXML_PATTERN_ENABLED */\n#ifdef LIBXML_SCHEMAS_ENABLED\n    if ((reader->validate == XML_TEXTREADER_VALIDATE_XSD) &&\n        (reader->xsdValidErrors == 0) &&\n\t(reader->xsdValidCtxt != NULL)) {\n\treader->xsdValidErrors = !xmlSchemaIsValid(reader->xsdValidCtxt);\n    }\n#endif /* LIBXML_PATTERN_ENABLED */\n    return(1);\nnode_end:\n    reader->state = XML_TEXTREADER_DONE;\n    return(0);\n}\n\n\n// target function\nstatic void\nxmlTextReaderFreeProp(xmlTextReaderPtr reader, xmlAttrPtr cur) {\n    xmlDictPtr dict;\n\n    if ((reader != NULL) && (reader->ctxt != NULL))\n\tdict = reader->ctxt->dict;\n    else\n        dict = NULL;\n    if (cur == NULL) return;\n\n    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n\txmlDeregisterNodeDefaultValue((xmlNodePtr) cur);\n\n    /* Check for ID removal -> leading to invalid references ! */\n    if ((cur->parent != NULL) && (cur->parent->doc != NULL) &&\n\t((cur->parent->doc->intSubset != NULL) ||\n\t (cur->parent->doc->extSubset != NULL))) {\n        if (xmlIsID(cur->parent->doc, cur->parent, cur))\n\t    xmlTextReaderRemoveID(cur->parent->doc, cur);\n    }\n    if (cur->children != NULL)\n        xmlTextReaderFreeNodeList(reader, cur->children);\n\n    DICT_FREE(cur->name);\n    if ((reader != NULL) && (reader->ctxt != NULL) &&\n        (reader->ctxt->freeAttrsNr < 100)) {\n        cur->next = reader->ctxt->freeAttrs;\n\treader->ctxt->freeAttrs = cur;\n\treader->ctxt->freeAttrsNr++;\n    } else {\n\txmlFree(cur);\n    }\n}\nstatic void\nxmlTextReaderFreePropList(xmlTextReaderPtr reader, xmlAttrPtr cur) {\n    xmlAttrPtr next;\n\n    while (cur != NULL) {\n        next = cur->next;\n        xmlTextReaderFreeProp(reader, cur);\n\tcur = next;\n    }\n}\nstatic void\nxmlTextReaderFreeNodeList(xmlTextReaderPtr reader, xmlNodePtr cur) {\n    xmlNodePtr next;\n    xmlNodePtr parent;\n    xmlDictPtr dict;\n    size_t depth = 0;\n\n    if ((reader != NULL) && (reader->ctxt != NULL))\n\tdict = reader->ctxt->dict;\n    else\n        dict = NULL;\n    if (cur == NULL) return;\n    if (cur->type == XML_NAMESPACE_DECL) {\n\txmlFreeNsList((xmlNsPtr) cur);\n\treturn;\n    }\n    if ((cur->type == XML_DOCUMENT_NODE) ||\n\t(cur->type == XML_HTML_DOCUMENT_NODE)) {\n\txmlFreeDoc((xmlDocPtr) cur);\n\treturn;\n    }\n    while (1) {\n        while ((cur->type != XML_DTD_NODE) &&\n               (cur->type != XML_ENTITY_REF_NODE) &&\n               (cur->children != NULL) &&\n               (cur->children->parent == cur)) {\n            cur = cur->children;\n            depth += 1;\n        }\n\n        next = cur->next;\n        parent = cur->parent;\n\n\t/* unroll to speed up freeing the document */\n\tif (cur->type != XML_DTD_NODE) {\n\n\t    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n\t\txmlDeregisterNodeDefaultValue(cur);\n\n\t    if (((cur->type == XML_ELEMENT_NODE) ||\n\t\t (cur->type == XML_XINCLUDE_START) ||\n\t\t (cur->type == XML_XINCLUDE_END)) &&\n\t\t(cur->properties != NULL))\n\t\txmlTextReaderFreePropList(reader, cur->properties);\n\t    if ((cur->content != (xmlChar *) &(cur->properties)) &&\n\t        (cur->type != XML_ELEMENT_NODE) &&\n\t\t(cur->type != XML_XINCLUDE_START) &&\n\t\t(cur->type != XML_XINCLUDE_END) &&\n\t\t(cur->type != XML_ENTITY_REF_NODE)) {\n\t\tDICT_FREE(cur->content);\n\t    }\n\t    if (((cur->type == XML_ELEMENT_NODE) ||\n\t         (cur->type == XML_XINCLUDE_START) ||\n\t\t (cur->type == XML_XINCLUDE_END)) &&\n\t\t(cur->nsDef != NULL))\n\t\txmlFreeNsList(cur->nsDef);\n\n\t    /*\n\t     * we don't free element names here they are interned now\n\t     */\n\t    if ((cur->type != XML_TEXT_NODE) &&\n\t\t(cur->type != XML_COMMENT_NODE))\n\t\tDICT_FREE(cur->name);\n\t    if (((cur->type == XML_ELEMENT_NODE) ||\n\t\t (cur->type == XML_TEXT_NODE)) &&\n\t        (reader != NULL) && (reader->ctxt != NULL) &&\n\t\t(reader->ctxt->freeElemsNr < 100)) {\n\t        cur->next = reader->ctxt->freeElems;\n\t\treader->ctxt->freeElems = cur;\n\t\treader->ctxt->freeElemsNr++;\n\t    } else {\n\t\txmlFree(cur);\n\t    }\n\t}\n\n        if (next != NULL) {\n\t    cur = next;\n        } else {\n            if ((depth == 0) || (parent == NULL))\n                break;\n            depth -= 1;\n            cur = parent;\n            cur->children = NULL;\n        }\n    }\n}\n",
    "target": 1,
    "idx": 1023120,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\n\n\nUSBREDIR_VISIBLE\nint usbredirparser_serialize(struct usbredirparser *parser_pub,\n                             uint8_t **state_dest, int *state_len)\n{\n    struct usbredirparser_priv *parser =\n        (struct usbredirparser_priv *)parser_pub;\n    struct usbredirparser_buf *wbuf;\n    uint8_t *state = NULL, *pos = NULL;\n    uint32_t write_buf_count = 0, len, remain = 0;\n    ptrdiff_t write_buf_count_pos;\n\n    *state_dest = NULL;\n    *state_len = 0;\n\n    if (serialize_int(parser, &state, &pos, &remain,\n                                   USBREDIRPARSER_SERIALIZE_MAGIC, \"magic\"))\n        return -1;\n\n    /* To be replaced with length later */\n    if (serialize_int(parser, &state, &pos, &remain, 0, \"length\"))\n        return -1;\n\n    if (serialize_data(parser, &state, &pos, &remain,\n                       (uint8_t *)parser->our_caps,\n                       USB_REDIR_CAPS_SIZE * sizeof(int32_t), \"our_caps\"))\n        return -1;\n\n    if (parser->have_peer_caps) {\n        if (serialize_data(parser, &state, &pos, &remain,\n                           (uint8_t *)parser->peer_caps,\n                           USB_REDIR_CAPS_SIZE * sizeof(int32_t), \"peer_caps\"))\n            return -1;\n    } else {\n        if (serialize_int(parser, &state, &pos, &remain, 0, \"peer_caps_len\"))\n            return -1;\n    }\n\n    if (serialize_int(parser, &state, &pos, &remain, parser->to_skip, \"skip\"))\n        return -1;\n\n    if (serialize_data(parser, &state, &pos, &remain,\n                       (uint8_t *)&parser->header, parser->header_read,\n                       \"header\"))\n        return -1;\n\n    if (serialize_data(parser, &state, &pos, &remain,\n                       parser->type_header, parser->type_header_read,\n                       \"type_header\"))\n        return -1;\n\n    if (serialize_data(parser, &state, &pos, &remain,\n                       parser->data, parser->data_read, \"packet-data\"))\n        return -1;\n\n    write_buf_count_pos = pos - state;\n    /* To be replaced with write_buf_count later */\n    if (serialize_int(parser, &state, &pos, &remain, 0, \"write_buf_count\"))\n        return -1;\n\n    wbuf = parser->write_buf;\n    while (wbuf) {\n        if (serialize_data(parser, &state, &pos, &remain,\n                           wbuf->buf + wbuf->pos, wbuf->len - wbuf->pos,\n                           \"write-buf\"))\n            return -1;\n        write_buf_count++;\n        wbuf = wbuf->next;\n    }\n    /* Patch in write_buf_count */\n    memcpy(state + write_buf_count_pos, &write_buf_count, sizeof(int32_t));\n\n    /* Patch in length */\n    len = pos - state;\n    memcpy(state + sizeof(int32_t), &len, sizeof(int32_t));\n\n    *state_dest = state;\n    *state_len = len;\n\n    return 0;\n}\n\nint try_serialize(struct usbredirparser *parser)\n{\n    uint8_t *state = nullptr;\n    int len = 0;\n    int ret;\n\n    ret = usbredirparser_serialize(parser, &state, &len);\n\n    if (ret == 0) {\n        free(state);\n    }\n\n    return ret;\n}\n\n\n// target function\nUSBREDIR_VISIBLE\nint usbredirparser_serialize(struct usbredirparser *parser_pub,\n                             uint8_t **state_dest, int *state_len)\n{\n    struct usbredirparser_priv *parser =\n        (struct usbredirparser_priv *)parser_pub;\n    struct usbredirparser_buf *wbuf;\n    uint8_t *write_buf_count_pos, *state = NULL, *pos = NULL;\n    uint32_t write_buf_count = 0, len, remain = 0;\n\n    *state_dest = NULL;\n    *state_len = 0;\n\n    if (serialize_int(parser, &state, &pos, &remain,\n                                   USBREDIRPARSER_SERIALIZE_MAGIC, \"magic\"))\n        return -1;\n\n    /* To be replaced with length later */\n    if (serialize_int(parser, &state, &pos, &remain, 0, \"length\"))\n        return -1;\n\n    if (serialize_data(parser, &state, &pos, &remain,\n                       (uint8_t *)parser->our_caps,\n                       USB_REDIR_CAPS_SIZE * sizeof(int32_t), \"our_caps\"))\n        return -1;\n\n    if (parser->have_peer_caps) {\n        if (serialize_data(parser, &state, &pos, &remain,\n                           (uint8_t *)parser->peer_caps,\n                           USB_REDIR_CAPS_SIZE * sizeof(int32_t), \"peer_caps\"))\n            return -1;\n    } else {\n        if (serialize_int(parser, &state, &pos, &remain, 0, \"peer_caps_len\"))\n            return -1;\n    }\n\n    if (serialize_int(parser, &state, &pos, &remain, parser->to_skip, \"skip\"))\n        return -1;\n\n    if (serialize_data(parser, &state, &pos, &remain,\n                       (uint8_t *)&parser->header, parser->header_read,\n                       \"header\"))\n        return -1;\n\n    if (serialize_data(parser, &state, &pos, &remain,\n                       parser->type_header, parser->type_header_read,\n                       \"type_header\"))\n        return -1;\n\n    if (serialize_data(parser, &state, &pos, &remain,\n                       parser->data, parser->data_read, \"packet-data\"))\n        return -1;\n\n    write_buf_count_pos = pos;\n    /* To be replaced with write_buf_count later */\n    if (serialize_int(parser, &state, &pos, &remain, 0, \"write_buf_count\"))\n        return -1;\n\n    wbuf = parser->write_buf;\n    while (wbuf) {\n        if (serialize_data(parser, &state, &pos, &remain,\n                           wbuf->buf + wbuf->pos, wbuf->len - wbuf->pos,\n                           \"write-buf\"))\n            return -1;\n        write_buf_count++;\n        wbuf = wbuf->next;\n    }\n    /* Patch in write_buf_count */\n    memcpy(write_buf_count_pos, &write_buf_count, sizeof(int32_t));\n\n    /* Patch in length */\n    len = pos - state;\n    memcpy(state + sizeof(int32_t), &len, sizeof(int32_t));\n\n    *state_dest = state;\n    *state_len = len;\n\n    return 0;\n}\n",
    "target": 1,
    "idx": 1036861,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "// context\n\n\n_PUBLIC_ int _talloc_free(void *ptr, const char *location)\n{\n\tstruct talloc_chunk *tc;\n\n\tif (unlikely(ptr == NULL)) {\n\t\treturn -1;\n\t}\n\n\ttc = talloc_chunk_from_ptr(ptr);\n\n\tif (unlikely(tc->refs != NULL)) {\n\t\tstruct talloc_reference_handle *h;\n\n\t\tif (talloc_parent(ptr) == null_context && tc->refs->next == NULL) {\n\t\t\t/* in this case we do know which parent should\n\t\t\t   get this pointer, as there is really only\n\t\t\t   one parent */\n\t\t\treturn talloc_unlink(null_context, ptr);\n\t\t}\n\n\t\ttalloc_log(\"ERROR: talloc_free with references at %s\\n\",\n\t\t\t   location);\n\n\t\tfor (h=tc->refs; h; h=h->next) {\n\t\t\ttalloc_log(\"\\treference at %s\\n\",\n\t\t\t\t   h->location);\n\t\t}\n\t\treturn -1;\n\t}\n\n\treturn _talloc_free_internal(ptr, location);\n}\n\n\n\n\n\nstatic inline int _tc_free_internal(struct talloc_chunk *tc,\n\t\t\t\tconst char *location)\n{\n\tvoid *ptr_to_free;\n\tvoid *ptr = TC_PTR_FROM_CHUNK(tc);\n\n\tif (unlikely(tc->refs)) {\n\t\tint is_child;\n\t\t/* check if this is a reference from a child or\n\t\t * grandchild back to it's parent or grandparent\n\t\t *\n\t\t * in that case we need to remove the reference and\n\t\t * call another instance of talloc_free() on the current\n\t\t * pointer.\n\t\t */\n\t\tis_child = talloc_is_parent(tc->refs, ptr);\n\t\t_talloc_free_internal(tc->refs, location);\n\t\tif (is_child) {\n\t\t\treturn _talloc_free_internal(ptr, location);\n\t\t}\n\t\treturn -1;\n\t}\n\n\tif (unlikely(tc->flags & TALLOC_FLAG_LOOP)) {\n\t\t/* we have a free loop - stop looping */\n\t\treturn 0;\n\t}\n\n\tif (unlikely(tc->destructor)) {\n\t\ttalloc_destructor_t d = tc->destructor;\n\n\t\t/*\n\t\t * Protect the destructor against some overwrite\n\t\t * attacks, by explicitly checking it has the right\n\t\t * magic here.\n\t\t */\n\t\tif (talloc_chunk_from_ptr(ptr) != tc) {\n\t\t\t/*\n\t\t\t * This can't actually happen, the\n\t\t\t * call itself will panic.\n\t\t\t */\n\t\t\tTALLOC_ABORT(\"talloc_chunk_from_ptr failed!\");\n\t\t}\n\n\t\tif (d == (talloc_destructor_t)-1) {\n\t\t\treturn -1;\n\t\t}\n\t\ttc->destructor = (talloc_destructor_t)-1;\n\t\tif (d(ptr) == -1) {\n\t\t\t/*\n\t\t\t * Only replace the destructor pointer if\n\t\t\t * calling the destructor didn't modify it.\n\t\t\t */\n\t\t\tif (tc->destructor == (talloc_destructor_t)-1) {\n\t\t\t\ttc->destructor = d;\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\ttc->destructor = NULL;\n\t}\n\n\tif (tc->parent) {\n\t\t_TLIST_REMOVE(tc->parent->child, tc);\n\t\tif (tc->parent->child) {\n\t\t\ttc->parent->child->parent = tc->parent;\n\t\t}\n\t} else {\n\t\tif (tc->prev) tc->prev->next = tc->next;\n\t\tif (tc->next) tc->next->prev = tc->prev;\n\t\ttc->prev = tc->next = NULL;\n\t}\n\n\ttc->flags |= TALLOC_FLAG_LOOP;\n\n\t_tc_free_children_internal(tc, ptr, location);\n\n\t_talloc_chunk_set_free(tc, location);\n\n\tif (tc->flags & TALLOC_FLAG_POOL) {\n\t\tstruct talloc_pool_hdr *pool;\n\n\t\tpool = talloc_pool_from_chunk(tc);\n\n\t\tif (unlikely(pool->object_count == 0)) {\n\t\t\ttalloc_abort(\"Pool object count zero!\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tpool->object_count--;\n\n\t\tif (likely(pool->object_count != 0)) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * With object_count==0, a pool becomes a normal piece of\n\t\t * memory to free. If it's allocated inside a pool, it needs\n\t\t * to be freed as poolmem, else it needs to be just freed.\n\t\t*/\n\t\tptr_to_free = pool;\n\t} else {\n\t\tptr_to_free = tc;\n\t}\n\n\tif (tc->flags & TALLOC_FLAG_POOLMEM) {\n\t\t_tc_free_poolmem(tc, location);\n\t\treturn 0;\n\t}\n\n\ttc_memlimit_update_on_free(tc);\n\n\tTC_INVALIDATE_FULL_CHUNK(tc);\n\tfree(ptr_to_free);\n\treturn 0;\n}\n\nstatic inline void _tc_free_children_internal(struct talloc_chunk *tc,\n\t\t\t\t\t\t  void *ptr,\n\t\t\t\t\t\t  const char *location)\n{\n\twhile (tc->child) {\n\t\t/* we need to work out who will own an abandoned child\n\t\t   if it cannot be freed. In priority order, the first\n\t\t   choice is owner of any remaining reference to this\n\t\t   pointer, the second choice is our parent, and the\n\t\t   final choice is the null context. */\n\t\tvoid *child = TC_PTR_FROM_CHUNK(tc->child);\n\t\tconst void *new_parent = null_context;\n\t\tif (unlikely(tc->child->refs)) {\n\t\t\tstruct talloc_chunk *p = talloc_parent_chunk(tc->child->refs);\n\t\t\tif (p) new_parent = TC_PTR_FROM_CHUNK(p);\n\t\t}\n\t\tif (unlikely(_tc_free_internal(tc->child, location) == -1)) {\n\t\t\tif (talloc_parent_chunk(child) != tc) {\n\t\t\t\t/*\n\t\t\t\t * Destructor already reparented this child.\n\t\t\t\t * No further reparenting needed.\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (new_parent == null_context) {\n\t\t\t\tstruct talloc_chunk *p = talloc_parent_chunk(ptr);\n\t\t\t\tif (p) new_parent = TC_PTR_FROM_CHUNK(p);\n\t\t\t}\n\t\t\t_talloc_steal_internal(new_parent, child);\n\t\t}\n\t}\n}\n\nstatic inline int _tc_free_internal(struct talloc_chunk *tc,\n\t\t\t\tconst char *location)\n{\n\tvoid *ptr_to_free;\n\tvoid *ptr = TC_PTR_FROM_CHUNK(tc);\n\n\tif (unlikely(tc->refs)) {\n\t\tint is_child;\n\t\t/* check if this is a reference from a child or\n\t\t * grandchild back to it's parent or grandparent\n\t\t *\n\t\t * in that case we need to remove the reference and\n\t\t * call another instance of talloc_free() on the current\n\t\t * pointer.\n\t\t */\n\t\tis_child = talloc_is_parent(tc->refs, ptr);\n\t\t_talloc_free_internal(tc->refs, location);\n\t\tif (is_child) {\n\t\t\treturn _talloc_free_internal(ptr, location);\n\t\t}\n\t\treturn -1;\n\t}\n\n\tif (unlikely(tc->flags & TALLOC_FLAG_LOOP)) {\n\t\t/* we have a free loop - stop looping */\n\t\treturn 0;\n\t}\n\n\tif (unlikely(tc->destructor)) {\n\t\ttalloc_destructor_t d = tc->destructor;\n\n\t\t/*\n\t\t * Protect the destructor against some overwrite\n\t\t * attacks, by explicitly checking it has the right\n\t\t * magic here.\n\t\t */\n\t\tif (talloc_chunk_from_ptr(ptr) != tc) {\n\t\t\t/*\n\t\t\t * This can't actually happen, the\n\t\t\t * call itself will panic.\n\t\t\t */\n\t\t\tTALLOC_ABORT(\"talloc_chunk_from_ptr failed!\");\n\t\t}\n\n\t\tif (d == (talloc_destructor_t)-1) {\n\t\t\treturn -1;\n\t\t}\n\t\ttc->destructor = (talloc_destructor_t)-1;\n\t\tif (d(ptr) == -1) {\n\t\t\t/*\n\t\t\t * Only replace the destructor pointer if\n\t\t\t * calling the destructor didn't modify it.\n\t\t\t */\n\t\t\tif (tc->destructor == (talloc_destructor_t)-1) {\n\t\t\t\ttc->destructor = d;\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\ttc->destructor = NULL;\n\t}\n\n\tif (tc->parent) {\n\t\t_TLIST_REMOVE(tc->parent->child, tc);\n\t\tif (tc->parent->child) {\n\t\t\ttc->parent->child->parent = tc->parent;\n\t\t}\n\t} else {\n\t\tif (tc->prev) tc->prev->next = tc->next;\n\t\tif (tc->next) tc->next->prev = tc->prev;\n\t\ttc->prev = tc->next = NULL;\n\t}\n\n\ttc->flags |= TALLOC_FLAG_LOOP;\n\n\t_tc_free_children_internal(tc, ptr, location);\n\n\t_talloc_chunk_set_free(tc, location);\n\n\tif (tc->flags & TALLOC_FLAG_POOL) {\n\t\tstruct talloc_pool_hdr *pool;\n\n\t\tpool = talloc_pool_from_chunk(tc);\n\n\t\tif (unlikely(pool->object_count == 0)) {\n\t\t\ttalloc_abort(\"Pool object count zero!\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tpool->object_count--;\n\n\t\tif (likely(pool->object_count != 0)) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * With object_count==0, a pool becomes a normal piece of\n\t\t * memory to free. If it's allocated inside a pool, it needs\n\t\t * to be freed as poolmem, else it needs to be just freed.\n\t\t*/\n\t\tptr_to_free = pool;\n\t} else {\n\t\tptr_to_free = tc;\n\t}\n\n\tif (tc->flags & TALLOC_FLAG_POOLMEM) {\n\t\t_tc_free_poolmem(tc, location);\n\t\treturn 0;\n\t}\n\n\ttc_memlimit_update_on_free(tc);\n\n\tTC_INVALIDATE_FULL_CHUNK(tc);\n\tfree(ptr_to_free);\n\treturn 0;\n}\n\nstatic inline void _tc_free_children_internal(struct talloc_chunk *tc,\n\t\t\t\t\t\t  void *ptr,\n\t\t\t\t\t\t  const char *location)\n{\n\twhile (tc->child) {\n\t\t/* we need to work out who will own an abandoned child\n\t\t   if it cannot be freed. In priority order, the first\n\t\t   choice is owner of any remaining reference to this\n\t\t   pointer, the second choice is our parent, and the\n\t\t   final choice is the null context. */\n\t\tvoid *child = TC_PTR_FROM_CHUNK(tc->child);\n\t\tconst void *new_parent = null_context;\n\t\tif (unlikely(tc->child->refs)) {\n\t\t\tstruct talloc_chunk *p = talloc_parent_chunk(tc->child->refs);\n\t\t\tif (p) new_parent = TC_PTR_FROM_CHUNK(p);\n\t\t}\n\t\tif (unlikely(_tc_free_internal(tc->child, location) == -1)) {\n\t\t\tif (talloc_parent_chunk(child) != tc) {\n\t\t\t\t/*\n\t\t\t\t * Destructor already reparented this child.\n\t\t\t\t * No further reparenting needed.\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (new_parent == null_context) {\n\t\t\t\tstruct talloc_chunk *p = talloc_parent_chunk(ptr);\n\t\t\t\tif (p) new_parent = TC_PTR_FROM_CHUNK(p);\n\t\t\t}\n\t\t\t_talloc_steal_internal(new_parent, child);\n\t\t}\n\t}\n}\n\nstatic inline int _tc_free_internal(struct talloc_chunk *tc,\n\t\t\t\tconst char *location)\n{\n\tvoid *ptr_to_free;\n\tvoid *ptr = TC_PTR_FROM_CHUNK(tc);\n\n\tif (unlikely(tc->refs)) {\n\t\tint is_child;\n\t\t/* check if this is a reference from a child or\n\t\t * grandchild back to it's parent or grandparent\n\t\t *\n\t\t * in that case we need to remove the reference and\n\t\t * call another instance of talloc_free() on the current\n\t\t * pointer.\n\t\t */\n\t\tis_child = talloc_is_parent(tc->refs, ptr);\n\t\t_talloc_free_internal(tc->refs, location);\n\t\tif (is_child) {\n\t\t\treturn _talloc_free_internal(ptr, location);\n\t\t}\n\t\treturn -1;\n\t}\n\n\tif (unlikely(tc->flags & TALLOC_FLAG_LOOP)) {\n\t\t/* we have a free loop - stop looping */\n\t\treturn 0;\n\t}\n\n\tif (unlikely(tc->destructor)) {\n\t\ttalloc_destructor_t d = tc->destructor;\n\n\t\t/*\n\t\t * Protect the destructor against some overwrite\n\t\t * attacks, by explicitly checking it has the right\n\t\t * magic here.\n\t\t */\n\t\tif (talloc_chunk_from_ptr(ptr) != tc) {\n\t\t\t/*\n\t\t\t * This can't actually happen, the\n\t\t\t * call itself will panic.\n\t\t\t */\n\t\t\tTALLOC_ABORT(\"talloc_chunk_from_ptr failed!\");\n\t\t}\n\n\t\tif (d == (talloc_destructor_t)-1) {\n\t\t\treturn -1;\n\t\t}\n\t\ttc->destructor = (talloc_destructor_t)-1;\n\t\tif (d(ptr) == -1) {\n\t\t\t/*\n\t\t\t * Only replace the destructor pointer if\n\t\t\t * calling the destructor didn't modify it.\n\t\t\t */\n\t\t\tif (tc->destructor == (talloc_destructor_t)-1) {\n\t\t\t\ttc->destructor = d;\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\ttc->destructor = NULL;\n\t}\n\n\tif (tc->parent) {\n\t\t_TLIST_REMOVE(tc->parent->child, tc);\n\t\tif (tc->parent->child) {\n\t\t\ttc->parent->child->parent = tc->parent;\n\t\t}\n\t} else {\n\t\tif (tc->prev) tc->prev->next = tc->next;\n\t\tif (tc->next) tc->next->prev = tc->prev;\n\t\ttc->prev = tc->next = NULL;\n\t}\n\n\ttc->flags |= TALLOC_FLAG_LOOP;\n\n\t_tc_free_children_internal(tc, ptr, location);\n\n\t_talloc_chunk_set_free(tc, location);\n\n\tif (tc->flags & TALLOC_FLAG_POOL) {\n\t\tstruct talloc_pool_hdr *pool;\n\n\t\tpool = talloc_pool_from_chunk(tc);\n\n\t\tif (unlikely(pool->object_count == 0)) {\n\t\t\ttalloc_abort(\"Pool object count zero!\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tpool->object_count--;\n\n\t\tif (likely(pool->object_count != 0)) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * With object_count==0, a pool becomes a normal piece of\n\t\t * memory to free. If it's allocated inside a pool, it needs\n\t\t * to be freed as poolmem, else it needs to be just freed.\n\t\t*/\n\t\tptr_to_free = pool;\n\t} else {\n\t\tptr_to_free = tc;\n\t}\n\n\tif (tc->flags & TALLOC_FLAG_POOLMEM) {\n\t\t_tc_free_poolmem(tc, location);\n\t\treturn 0;\n\t}\n\n\ttc_memlimit_update_on_free(tc);\n\n\tTC_INVALIDATE_FULL_CHUNK(tc);\n\tfree(ptr_to_free);\n\treturn 0;\n}\n\nstatic inline int _talloc_free_internal(void *ptr, const char *location)\n{\n\tstruct talloc_chunk *tc;\n\n\tif (unlikely(ptr == NULL)) {\n\t\treturn -1;\n\t}\n\n\t/* possibly initialised the talloc fill value */\n\tif (unlikely(!talloc_fill.initialised)) {\n\t\tconst char *fill = getenv(TALLOC_FILL_ENV);\n\t\tif (fill != NULL) {\n\t\t\ttalloc_fill.enabled = true;\n\t\t\ttalloc_fill.fill_value = strtoul(fill, NULL, 0);\n\t\t}\n\t\ttalloc_fill.initialised = true;\n\t}\n\n\ttc = talloc_chunk_from_ptr(ptr);\n\treturn _tc_free_internal(tc, location);\n}\n\n_PUBLIC_ int _talloc_free(void *ptr, const char *location)\n{\n\tstruct talloc_chunk *tc;\n\n\tif (unlikely(ptr == NULL)) {\n\t\treturn -1;\n\t}\n\n\ttc = talloc_chunk_from_ptr(ptr);\n\n\tif (unlikely(tc->refs != NULL)) {\n\t\tstruct talloc_reference_handle *h;\n\n\t\tif (talloc_parent(ptr) == null_context && tc->refs->next == NULL) {\n\t\t\t/* in this case we do know which parent should\n\t\t\t   get this pointer, as there is really only\n\t\t\t   one parent */\n\t\t\treturn talloc_unlink(null_context, ptr);\n\t\t}\n\n\t\ttalloc_log(\"ERROR: talloc_free with references at %s\\n\",\n\t\t\t   location);\n\n\t\tfor (h=tc->refs; h; h=h->next) {\n\t\t\ttalloc_log(\"\\treference at %s\\n\",\n\t\t\t\t   h->location);\n\t\t}\n\t\treturn -1;\n\t}\n\n\treturn _talloc_free_internal(ptr, location);\n}\n\n\n// target function\nvoid ndr_pull_compression_state_free(struct ndr_compression_state *state)\n{\n\tif (state == NULL) {\n\t\treturn;\n\t}\n\n\tswitch (state->type) {\n\tcase NDR_COMPRESSION_NONE:\n\tcase NDR_COMPRESSION_MSZIP:\n\tcase NDR_COMPRESSION_XPRESS:\n\tcase NDR_COMPRESSION_XPRESS_HUFF_RAW:\n\t\tbreak;\n\tcase NDR_COMPRESSION_MSZIP_CAB:\n\t\tgeneric_mszip_free(state);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tTALLOC_FREE(state);\n}\nstatic int ndr_push_compression_state_free(struct ndr_compression_state *state)\n{\n\tswitch (state->type) {\n\tcase NDR_COMPRESSION_NONE:\n\tcase NDR_COMPRESSION_MSZIP:\n\tcase NDR_COMPRESSION_XPRESS:\n\tcase NDR_COMPRESSION_XPRESS_HUFF_RAW:\n\t\tbreak;\n\tcase NDR_COMPRESSION_MSZIP_CAB:\n\t\tgeneric_mszip_free(state);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n",
    "target": 1,
    "idx": 1057608,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "// context\n\n\nstatic ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_OBJ_SPEC_CV_CONST_OP_DATA_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)\n{\n\tUSE_OPLINE\n\tzval *object, *value, tmp;\n\tzend_object *zobj;\n\tzend_string *name, *tmp_name;\n\n\tSAVE_OPLINE();\n\tobject = EX_VAR(opline->op1.var);\n\tvalue = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);\n\n\tif (IS_CV != IS_UNUSED && UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {\n\t\tif (Z_ISREF_P(object) && Z_TYPE_P(Z_REFVAL_P(object)) == IS_OBJECT) {\n\t\t\tobject = Z_REFVAL_P(object);\n\t\t\tgoto assign_object;\n\t\t}\n\t\tzend_throw_non_object_error(object, RT_CONSTANT(opline, opline->op2) OPLINE_CC EXECUTE_DATA_CC);\n\t\tvalue = &EG(uninitialized_zval);\n\t\tgoto free_and_exit_assign_obj;\n\t}\n\nassign_object:\n\tzobj = Z_OBJ_P(object);\n\tif (IS_CONST == IS_CONST) {\n\t\tif (EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {\n\t\t\tvoid **cache_slot = CACHE_ADDR(opline->extended_value);\n\t\t\tuintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);\n\t\t\tzend_object *zobj = Z_OBJ_P(object);\n\t\t\tzval *property_val;\n\n\t\t\tif (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {\n\t\t\t\tproperty_val = OBJ_PROP(zobj, prop_offset);\n\t\t\t\tif (Z_TYPE_P(property_val) != IS_UNDEF) {\n\t\t\t\t\tzend_property_info *prop_info = (zend_property_info*) CACHED_PTR_EX(cache_slot + 2);\n\n\t\t\t\t\tif (UNEXPECTED(prop_info != NULL)) {\n\t\t\t\t\t\tzend_uchar orig_type = IS_UNDEF;\n\n\t\t\t\t\t\tif (IS_VAR == IS_CONST) {\n\t\t\t\t\t\t\torig_type = Z_TYPE_P(value);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvalue = zend_assign_to_typed_prop(prop_info, property_val, value EXECUTE_DATA_CC);\n\n\t\t\t\t\t\t/* will remain valid, thus no need to check prop_info in future here */\n\t\t\t\t\t\tif (IS_VAR == IS_CONST && Z_TYPE_P(value) == orig_type) {\n\t\t\t\t\t\t\tCACHE_PTR_EX(cache_slot + 2, NULL);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgoto free_and_exit_assign_obj;\n\t\t\t\t\t} else {\nfast_assign_obj:\n\t\t\t\t\t\tvalue = zend_assign_to_variable(property_val, value, IS_VAR, EX_USES_STRICT_TYPES());\n\t\t\t\t\t\tif (UNEXPECTED(RETURN_VALUE_USED(opline))) {\n\t\t\t\t\t\t\tZVAL_COPY(EX_VAR(opline->result.var), value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgoto exit_assign_obj;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tname = Z_STR_P(RT_CONSTANT(opline, opline->op2));\n\t\t\t\tif (EXPECTED(zobj->properties != NULL)) {\n\t\t\t\t\tif (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {\n\t\t\t\t\t\tif (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {\n\t\t\t\t\t\t\tGC_DELREF(zobj->properties);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tzobj->properties = zend_array_dup(zobj->properties);\n\t\t\t\t\t}\n\t\t\t\t\tproperty_val = zend_hash_find_ex(zobj->properties, name, 1);\n\t\t\t\t\tif (property_val) {\n\t\t\t\t\t\tgoto fast_assign_obj;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!zobj->ce->__set) {\n\t\t\t\t\tif (EXPECTED(zobj->properties == NULL)) {\n\t\t\t\t\t\trebuild_object_properties(zobj);\n\t\t\t\t\t}\n\t\t\t\t\tif (IS_VAR == IS_CONST) {\n\t\t\t\t\t\tif (UNEXPECTED(Z_OPT_REFCOUNTED_P(value))) {\n\t\t\t\t\t\t\tZ_ADDREF_P(value);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (IS_VAR != IS_TMP_VAR) {\n\t\t\t\t\t\tif (Z_ISREF_P(value)) {\n\t\t\t\t\t\t\tif (IS_VAR == IS_VAR) {\n\t\t\t\t\t\t\t\tzend_reference *ref = Z_REF_P(value);\n\t\t\t\t\t\t\t\tif (GC_DELREF(ref) == 0) {\n\t\t\t\t\t\t\t\t\tZVAL_COPY_VALUE(&tmp, Z_REFVAL_P(value));\n\t\t\t\t\t\t\t\t\tefree_size(ref, sizeof(zend_reference));\n\t\t\t\t\t\t\t\t\tvalue = &tmp;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tvalue = Z_REFVAL_P(value);\n\t\t\t\t\t\t\t\t\tZ_TRY_ADDREF_P(value);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tvalue = Z_REFVAL_P(value);\n\t\t\t\t\t\t\t\tZ_TRY_ADDREF_P(value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (IS_VAR == IS_CV) {\n\t\t\t\t\t\t\tZ_TRY_ADDREF_P(value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\tzend_hash_add_new(zobj->properties, name, value);\n\t\t\t\t\tif (UNEXPECTED(RETURN_VALUE_USED(opline))) {\n\t\t\t\t\t\tZVAL_COPY(EX_VAR(opline->result.var), value);\n\t\t\t\t\t}\n\t\t\t\t\tgoto exit_assign_obj;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tname = Z_STR_P(RT_CONSTANT(opline, opline->op2));\n\t} else {\n\t\tname = zval_try_get_tmp_string(RT_CONSTANT(opline, opline->op2), &tmp_name);\n\t\tif (UNEXPECTED(!name)) {\n\t\t\tzval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));\n\t\t\tUNDEF_RESULT();\n\t\t\tgoto exit_assign_obj;\n\t\t}\n\t}\n\n\tif (IS_VAR == IS_CV || IS_VAR == IS_VAR) {\n\t\tZVAL_DEREF(value);\n\t}\n\n\tvalue = zobj->handlers->write_property(zobj, name, value, (IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);\n\n\tif (IS_CONST != IS_CONST) {\n\t\tzend_tmp_string_release(tmp_name);\n\t}\n\nfree_and_exit_assign_obj:\n\tif (UNEXPECTED(RETURN_VALUE_USED(opline))) {\n\t\tZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);\n\t}\n\tzval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));\nexit_assign_obj:\n\n\n\t/* assign_obj has two opcodes! */\n\tZEND_VM_NEXT_OPCODE_EX(1, 2);\n}\n\nstatic void fuzzer_execute_ex(zend_execute_data *execute_data) {\n\twhile (1) {\n\t\tint ret;\n\t\tif (--steps_left == 0) {\n\t\t\t/* Reset steps before bailing out, so code running after bailout (e.g. in\n\t\t\t * destructors) will get another MAX_STEPS, rather than UINT32_MAX steps. */\n\t\t\tsteps_left = MAX_STEPS;\n\t\t\tzend_bailout();\n\t\t}\n\n\t\tif ((ret = ((opcode_handler_t) EX(opline)->handler)(execute_data)) != 0) {\n\t\t\tif (ret > 0) {\n\t\t\t\texecute_data = EG(current_execute_data);\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\nZEND_API void zend_execute(zend_op_array *op_array, zval *return_value)\n{\n\tzend_execute_data *execute_data;\n\tvoid *object_or_called_scope;\n\tuint32_t call_info;\n\n\tif (EG(exception) != NULL) {\n\t\treturn;\n\t}\n\n\tobject_or_called_scope = zend_get_this_object(EG(current_execute_data));\n\tif (EXPECTED(!object_or_called_scope)) {\n\t\tobject_or_called_scope = zend_get_called_scope(EG(current_execute_data));\n\t\tcall_info = ZEND_CALL_TOP_CODE | ZEND_CALL_HAS_SYMBOL_TABLE;\n\t} else {\n\t\tcall_info = ZEND_CALL_TOP_CODE | ZEND_CALL_HAS_SYMBOL_TABLE | ZEND_CALL_HAS_THIS;\n\t}\n\texecute_data = zend_vm_stack_push_call_frame(call_info,\n\t\t(zend_function*)op_array, 0, object_or_called_scope);\n\tif (EG(current_execute_data)) {\n\t\texecute_data->symbol_table = zend_rebuild_symbol_table();\n\t} else {\n\t\texecute_data->symbol_table = &EG(symbol_table);\n\t}\n\tEX(prev_execute_data) = EG(current_execute_data);\n\ti_init_code_execute_data(execute_data, op_array, return_value);\n\tZEND_OBSERVER_FCALL_BEGIN(execute_data);\n\tzend_execute_ex(execute_data);\n\t/* Observer end handlers are called from ZEND_RETURN */\n\tzend_vm_stack_free_call_frame(execute_data);\n}\n\nint fuzzer_do_request_from_buffer(\n\t\tchar *filename, const char *data, size_t data_len, bool execute)\n{\n\tint retval = FAILURE; /* failure by default */\n\n\tSG(options) |= SAPI_OPTION_NO_CHDIR;\n\tSG(request_info).argc=0;\n\tSG(request_info).argv=NULL;\n\n\tif (fuzzer_request_startup() == FAILURE) {\n\t\treturn FAILURE;\n\t}\n\n\t// Commented out to avoid leaking the header callback.\n\t//SG(headers_sent) = 1;\n\t//SG(request_info).no_headers = 1;\n\tphp_register_variable(\"PHP_SELF\", filename, NULL);\n\n\tzend_first_try {\n\t\tzend_file_handle file_handle;\n\t\tzend_stream_init_filename(&file_handle, filename);\n\t\tfile_handle.primary_script = 1;\n\t\tfile_handle.buf = estrndup(data, data_len);\n\t\tfile_handle.len = data_len;\n\n\t\tzend_op_array *op_array = zend_compile_file(&file_handle, ZEND_REQUIRE);\n\t\tzend_destroy_file_handle(&file_handle);\n\t\tif (op_array) {\n\t\t\tif (execute) {\n\t\t\t\tzend_execute(op_array, NULL);\n\t\t\t}\n\t\t\tzend_destroy_static_vars(op_array);\n\t\t\tdestroy_op_array(op_array);\n\t\t\tefree(op_array);\n\t\t}\n\t} zend_end_try();\n\n\n// target function\nvoid zend_startup(zend_utility_functions *utility_functions) /* {{{ */\n{\n#ifdef ZTS\n\tzend_compiler_globals *compiler_globals;\n\tzend_executor_globals *executor_globals;\n\textern ZEND_API ts_rsrc_id ini_scanner_globals_id;\n\textern ZEND_API ts_rsrc_id language_scanner_globals_id;\n#else\n\textern zend_ini_scanner_globals ini_scanner_globals;\n\textern zend_php_scanner_globals language_scanner_globals;\n#endif\n\n\tzend_cpu_startup();\n\n#ifdef ZEND_WIN32\n\tphp_win32_cp_set_by_id(65001);\n#endif\n\n\tstart_memory_manager();\n\n\tvirtual_cwd_startup(); /* Could use shutdown to free the main cwd but it would just slow it down for CGI */\n\n#if defined(__FreeBSD__) || defined(__DragonFly__)\n\t/* FreeBSD and DragonFly floating point precision fix */\n\tfpsetmask(0);\n#endif\n\n\tzend_startup_strtod();\n\tzend_startup_extensions_mechanism();\n\n\t/* Set up utility functions and values */\n\tzend_error_cb = utility_functions->error_function;\n\tzend_printf = utility_functions->printf_function;\n\tzend_write = utility_functions->write_function;\n\tzend_fopen = utility_functions->fopen_function;\n\tif (!zend_fopen) {\n\t\tzend_fopen = zend_fopen_wrapper;\n\t}\n\tzend_stream_open_function = utility_functions->stream_open_function;\n\tzend_message_dispatcher_p = utility_functions->message_handler;\n\tzend_get_configuration_directive_p = utility_functions->get_configuration_directive;\n\tzend_ticks_function = utility_functions->ticks_function;\n\tzend_on_timeout = utility_functions->on_timeout;\n\tzend_printf_to_smart_string = utility_functions->printf_to_smart_string_function;\n\tzend_printf_to_smart_str = utility_functions->printf_to_smart_str_function;\n\tzend_getenv = utility_functions->getenv_function;\n\tzend_resolve_path = utility_functions->resolve_path_function;\n\n\tzend_interrupt_function = NULL;\n\n#ifdef HAVE_DTRACE\n/* build with dtrace support */\n\t{\n\t\tchar *tmp = getenv(\"USE_ZEND_DTRACE\");\n\n\t\tif (tmp && zend_atoi(tmp, 0)) {\n\t\t\tzend_dtrace_enabled = 1;\n\t\t\tzend_compile_file = dtrace_compile_file;\n\t\t\tzend_execute_ex = dtrace_execute_ex;\n\t\t\tzend_execute_internal = dtrace_execute_internal;\n\n\t\t\tzend_observer_error_register(dtrace_error_notify_cb);\n\t\t} else {\n\t\t\tzend_compile_file = compile_file;\n\t\t\tzend_execute_ex = execute_ex;\n\t\t\tzend_execute_internal = NULL;\n\t\t}\n\t}\n#else\n\tzend_compile_file = compile_file;\n\tzend_execute_ex = execute_ex;\n\tzend_execute_internal = NULL;\n#endif /* HAVE_DTRACE */\n\tzend_compile_string = compile_string;\n\tzend_throw_exception_hook = NULL;\n\n\t/* Set up the default garbage collection implementation. */\n\tgc_collect_cycles = zend_gc_collect_cycles;\n\n\tzend_vm_init();\n\n\t/* set up version */\n\tzend_version_info = strdup(ZEND_CORE_VERSION_INFO);\n\tzend_version_info_length = sizeof(ZEND_CORE_VERSION_INFO) - 1;\n\n\tGLOBAL_FUNCTION_TABLE = (HashTable *) malloc(sizeof(HashTable));\n\tGLOBAL_CLASS_TABLE = (HashTable *) malloc(sizeof(HashTable));\n\tGLOBAL_AUTO_GLOBALS_TABLE = (HashTable *) malloc(sizeof(HashTable));\n\tGLOBAL_CONSTANTS_TABLE = (HashTable *) malloc(sizeof(HashTable));\n\n\tzend_hash_init(GLOBAL_FUNCTION_TABLE, 1024, NULL, ZEND_FUNCTION_DTOR, 1);\n\tzend_hash_init(GLOBAL_CLASS_TABLE, 64, NULL, ZEND_CLASS_DTOR, 1);\n\tzend_hash_init(GLOBAL_AUTO_GLOBALS_TABLE, 8, NULL, auto_global_dtor, 1);\n\tzend_hash_init(GLOBAL_CONSTANTS_TABLE, 128, NULL, ZEND_CONSTANT_DTOR, 1);\n\n\tzend_hash_init(&module_registry, 32, NULL, module_destructor_zval, 1);\n\tzend_init_rsrc_list_dtors();\n\n#ifdef ZTS\n\tts_allocate_fast_id(&compiler_globals_id, &compiler_globals_offset, sizeof(zend_compiler_globals), (ts_allocate_ctor) compiler_globals_ctor, (ts_allocate_dtor) compiler_globals_dtor);\n\tts_allocate_fast_id(&executor_globals_id, &executor_globals_offset, sizeof(zend_executor_globals), (ts_allocate_ctor) executor_globals_ctor, (ts_allocate_dtor) executor_globals_dtor);\n\tts_allocate_fast_id(&language_scanner_globals_id, &language_scanner_globals_offset, sizeof(zend_php_scanner_globals), (ts_allocate_ctor) php_scanner_globals_ctor, NULL);\n\tts_allocate_fast_id(&ini_scanner_globals_id, &ini_scanner_globals_offset, sizeof(zend_ini_scanner_globals), (ts_allocate_ctor) ini_scanner_globals_ctor, NULL);\n\tcompiler_globals = ts_resource(compiler_globals_id);\n\texecutor_globals = ts_resource(executor_globals_id);\n\n\tcompiler_globals_dtor(compiler_globals);\n\tcompiler_globals->in_compilation = 0;\n\tcompiler_globals->function_table = (HashTable *) malloc(sizeof(HashTable));\n\tcompiler_globals->class_table = (HashTable *) malloc(sizeof(HashTable));\n\n\t*compiler_globals->function_table = *GLOBAL_FUNCTION_TABLE;\n\t*compiler_globals->class_table = *GLOBAL_CLASS_TABLE;\n\tcompiler_globals->auto_globals = GLOBAL_AUTO_GLOBALS_TABLE;\n\n\tzend_hash_destroy(executor_globals->zend_constants);\n\t*executor_globals->zend_constants = *GLOBAL_CONSTANTS_TABLE;\n#else\n\tini_scanner_globals_ctor(&ini_scanner_globals);\n\tphp_scanner_globals_ctor(&language_scanner_globals);\n\tzend_set_default_compile_time_values();\n#ifdef ZEND_WIN32\n\tzend_get_windows_version_info(&EG(windows_version_info));\n#endif\n# if ZEND_MAP_PTR_KIND == ZEND_MAP_PTR_KIND_PTR\n\t\t/* Create a map region, used for indirect pointers from shared to\n\t\t * process memory. It's allocated once and never resized.\n\t\t * All processes must map it into the same address space.\n\t\t */\n\t\tCG(map_ptr_size) = 1024 * 1024; // TODO: initial size ???\n\t\tCG(map_ptr_last) = 0;\n\t\tZEND_MAP_PTR_SET_REAL_BASE(CG(map_ptr_base), pemalloc(CG(map_ptr_size) * sizeof(void*), 1));\n# elif ZEND_MAP_PTR_KIND == ZEND_MAP_PTR_KIND_PTR_OR_OFFSET\n\t\t/* Map region is going to be created and resized at run-time. */\n\t\tZEND_MAP_PTR_SET_REAL_BASE(CG(map_ptr_base), NULL);\n\t\tCG(map_ptr_size) = 0;\n\t\tCG(map_ptr_last) = 0;\n# else\n#  error \"Unknown ZEND_MAP_PTR_KIND\"\n# endif\n#endif\n\tEG(error_reporting) = E_ALL & ~E_NOTICE;\n\n\tzend_interned_strings_init();\n\tzend_startup_builtin_functions();\n\tzend_register_standard_constants();\n\tzend_register_auto_global(zend_string_init_interned(\"GLOBALS\", sizeof(\"GLOBALS\") - 1, 1), 1, php_auto_globals_create_globals);\n\n#ifndef ZTS\n\tzend_init_rsrc_plist();\n\tzend_init_exception_op();\n\tzend_init_call_trampoline_op();\n#endif\n\n\tzend_ini_startup();\n\n#ifdef ZEND_WIN32\n\t/* Uses INI settings, so needs to be run after it. */\n\tphp_win32_cp_setup();\n#endif\n\n\tzend_optimizer_startup();\n\n#ifdef ZTS\n\ttsrm_set_new_thread_end_handler(zend_new_thread_end_handler);\n\ttsrm_set_shutdown_handler(zend_interned_strings_dtor);\n#endif\n}\nstatic void alloc_globals_ctor(zend_alloc_globals *alloc_globals)\n{\n\tchar *tmp;\n\n#if ZEND_MM_CUSTOM\n\ttmp = getenv(\"USE_ZEND_ALLOC\");\n\tif (tmp && !zend_atoi(tmp, 0)) {\n\t\tbool tracked = (tmp = getenv(\"USE_TRACKED_ALLOC\")) && zend_atoi(tmp, 0);\n\t\tzend_mm_heap *mm_heap = alloc_globals->mm_heap = malloc(sizeof(zend_mm_heap));\n\t\tmemset(mm_heap, 0, sizeof(zend_mm_heap));\n\t\tmm_heap->use_custom_heap = ZEND_MM_CUSTOM_HEAP_STD;\n\t\tmm_heap->limit = ((size_t)Z_L(-1) >> (size_t)Z_L(1));\n\t\tmm_heap->overflow = 0;\n\n\t\tif (!tracked) {\n\t\t\t/* Use system allocator. */\n\t\t\tmm_heap->custom_heap.std._malloc = __zend_malloc;\n\t\t\tmm_heap->custom_heap.std._free = free;\n\t\t\tmm_heap->custom_heap.std._realloc = __zend_realloc;\n\t\t} else {\n\t\t\t/* Use system allocator and track allocations for auto-free. */\n\t\t\tmm_heap->custom_heap.std._malloc = tracked_malloc;\n\t\t\tmm_heap->custom_heap.std._free = tracked_free;\n\t\t\tmm_heap->custom_heap.std._realloc = tracked_realloc;\n\t\t\tmm_heap->tracked_allocs = malloc(sizeof(HashTable));\n\t\t\tzend_hash_init(mm_heap->tracked_allocs, 1024, NULL, NULL, 1);\n\t\t}\n\t\treturn;\n\t}\n#endif\n\n\ttmp = getenv(\"USE_ZEND_ALLOC_HUGE_PAGES\");\n\tif (tmp && zend_atoi(tmp, 0)) {\n\t\tzend_mm_use_huge_pages = 1;\n\t}\n\talloc_globals->mm_heap = zend_mm_init();\n}\nint main(int argc, char *argv[])\n#endif\n{\n#if defined(PHP_WIN32)\n# ifdef PHP_CLI_WIN32_NO_CONSOLE\n\tint argc = __argc;\n\tchar **argv = __argv;\n# endif\n\tint num_args;\n\twchar_t **argv_wide;\n\tchar **argv_save = argv;\n\tBOOL using_wide_argv = 0;\n#endif\n\n\tint c;\n\tint exit_status = SUCCESS;\n\tint module_started = 0, sapi_started = 0;\n\tchar *php_optarg = NULL;\n\tint php_optind = 1, use_extended_info = 0;\n\tchar *ini_path_override = NULL;\n\tchar *ini_entries = NULL;\n\tsize_t ini_entries_len = 0;\n\tint ini_ignore = 0;\n\tsapi_module_struct *sapi_module = &cli_sapi_module;\n\n\t/*\n\t * Do not move this initialization. It needs to happen before argv is used\n\t * in any way.\n\t */\n\targv = save_ps_args(argc, argv);\n\n#if defined(PHP_WIN32) && !defined(PHP_CLI_WIN32_NO_CONSOLE)\n\tphp_win32_console_fileno_set_vt100(STDOUT_FILENO, TRUE);\n\tphp_win32_console_fileno_set_vt100(STDERR_FILENO, TRUE);\n#endif\n\n\tcli_sapi_module.additional_functions = additional_functions;\n\n#if defined(PHP_WIN32) && defined(_DEBUG)\n\t{\n\t\tchar *tmp = getenv(\"PHP_WIN32_DEBUG_HEAP\");\n\t\tif (tmp && zend_atoi(tmp, 0)) {\n\t\t\tint tmp_flag;\n\t\t\t_CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE);\n\t\t\t_CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDERR);\n\t\t\t_CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_FILE);\n\t\t\t_CrtSetReportFile(_CRT_ERROR, _CRTDBG_FILE_STDERR);\n\t\t\t_CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_FILE);\n\t\t\t_CrtSetReportFile(_CRT_ASSERT, _CRTDBG_FILE_STDERR);\n\t\t\ttmp_flag = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);\n\t\t\ttmp_flag |= _CRTDBG_DELAY_FREE_MEM_DF;\n\t\t\ttmp_flag |= _CRTDBG_LEAK_CHECK_DF;\n\n\t\t\t_CrtSetDbgFlag(tmp_flag);\n\t\t}\n\t}\n#endif\n\n#if defined(SIGPIPE) && defined(SIG_IGN)\n\tsignal(SIGPIPE, SIG_IGN); /* ignore SIGPIPE in standalone mode so\n\t\t\t\t\t\t\t\tthat sockets created via fsockopen()\n\t\t\t\t\t\t\t\tdon't kill PHP if the remote site\n\t\t\t\t\t\t\t\tcloses it.  in apache|apxs mode apache\n\t\t\t\t\t\t\t\tdoes that for us!  thies@thieso.net\n\t\t\t\t\t\t\t\t20000419 */\n#endif\n\n#ifdef ZTS\n\tphp_tsrm_startup();\n# ifdef PHP_WIN32\n\tZEND_TSRMLS_CACHE_UPDATE();\n# endif\n#endif\n\n\tzend_signal_startup();\n\n#ifdef PHP_WIN32\n\t_fmode = _O_BINARY;\t\t\t/*sets default for file streams to binary */\n\tsetmode(_fileno(stdin), O_BINARY);\t\t/* make the stdio mode be binary */\n\tsetmode(_fileno(stdout), O_BINARY);\t\t/* make the stdio mode be binary */\n\tsetmode(_fileno(stderr), O_BINARY);\t\t/* make the stdio mode be binary */\n#endif\n\n\twhile ((c = php_getopt(argc, argv, OPTIONS, &php_optarg, &php_optind, 1, 2))!=-1) {\n\t\tswitch (c) {\n\t\t\tcase 'c':\n\t\t\t\tif (ini_path_override) {\n\t\t\t\t\tfree(ini_path_override);\n\t\t\t\t}\n\t\t\t\tini_path_override = strdup(php_optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\tini_ignore = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'd': {\n\t\t\t\t/* define ini entries on command line */\n\t\t\t\tsize_t len = strlen(php_optarg);\n\t\t\t\tchar *val;\n\n\t\t\t\tif ((val = strchr(php_optarg, '='))) {\n\t\t\t\t\tval++;\n\t\t\t\t\tif (!isalnum(*val) && *val != '\"' && *val != '\\'' && *val != '\\0') {\n\t\t\t\t\t\tini_entries = realloc(ini_entries, ini_entries_len + len + sizeof(\"\\\"\\\"\\n\\0\"));\n\t\t\t\t\t\tmemcpy(ini_entries + ini_entries_len, php_optarg, (val - php_optarg));\n\t\t\t\t\t\tini_entries_len += (val - php_optarg);\n\t\t\t\t\t\tmemcpy(ini_entries + ini_entries_len, \"\\\"\", 1);\n\t\t\t\t\t\tini_entries_len++;\n\t\t\t\t\t\tmemcpy(ini_entries + ini_entries_len, val, len - (val - php_optarg));\n\t\t\t\t\t\tini_entries_len += len - (val - php_optarg);\n\t\t\t\t\t\tmemcpy(ini_entries + ini_entries_len, \"\\\"\\n\\0\", sizeof(\"\\\"\\n\\0\"));\n\t\t\t\t\t\tini_entries_len += sizeof(\"\\n\\0\\\"\") - 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tini_entries = realloc(ini_entries, ini_entries_len + len + sizeof(\"\\n\\0\"));\n\t\t\t\t\t\tmemcpy(ini_entries + ini_entries_len, php_optarg, len);\n\t\t\t\t\t\tmemcpy(ini_entries + ini_entries_len + len, \"\\n\\0\", sizeof(\"\\n\\0\"));\n\t\t\t\t\t\tini_entries_len += len + sizeof(\"\\n\\0\") - 2;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tini_entries = realloc(ini_entries, ini_entries_len + len + sizeof(\"=1\\n\\0\"));\n\t\t\t\t\tmemcpy(ini_entries + ini_entries_len, php_optarg, len);\n\t\t\t\t\tmemcpy(ini_entries + ini_entries_len + len, \"=1\\n\\0\", sizeof(\"=1\\n\\0\"));\n\t\t\t\t\tini_entries_len += len + sizeof(\"=1\\n\\0\") - 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n#ifndef PHP_CLI_WIN32_NO_CONSOLE\n\t\t\tcase 'S':\n\t\t\t\tsapi_module = &cli_server_sapi_module;\n\t\t\t\tcli_server_sapi_module.additional_functions = server_additional_functions;\n\t\t\t\tbreak;\n#endif\n\t\t\tcase 'h': /* help & quit */\n\t\t\tcase '?':\n\t\t\t\tphp_cli_usage(argv[0]);\n\t\t\t\tgoto out;\n\t\t\tcase PHP_GETOPT_INVALID_ARG: /* print usage on bad options, exit 1 */\n\t\t\t\tphp_cli_usage(argv[0]);\n\t\t\t\texit_status = 1;\n\t\t\t\tgoto out;\n\t\t\tcase 'i': case 'v': case 'm':\n\t\t\t\tsapi_module = &cli_sapi_module;\n\t\t\t\tgoto exit_loop;\n\t\t\tcase 'e': /* enable extended info output */\n\t\t\t\tuse_extended_info = 1;\n\t\t\t\tbreak;\n\t\t}\n\t}\nexit_loop:\n\n\tsapi_module->ini_defaults = sapi_cli_ini_defaults;\n\tsapi_module->php_ini_path_override = ini_path_override;\n\tsapi_module->phpinfo_as_text = 1;\n\tsapi_module->php_ini_ignore_cwd = 1;\n\tsapi_startup(sapi_module);\n\tsapi_started = 1;\n\n\tsapi_module->php_ini_ignore = ini_ignore;\n\n\tsapi_module->executable_location = argv[0];\n\n\tif (sapi_module == &cli_sapi_module) {\n\t\tif (ini_entries) {\n\t\t\tini_entries = realloc(ini_entries, ini_entries_len + sizeof(HARDCODED_INI));\n\t\t\tmemmove(ini_entries + sizeof(HARDCODED_INI) - 2, ini_entries, ini_entries_len + 1);\n\t\t\tmemcpy(ini_entries, HARDCODED_INI, sizeof(HARDCODED_INI) - 2);\n\t\t} else {\n\t\t\tini_entries = malloc(sizeof(HARDCODED_INI));\n\t\t\tmemcpy(ini_entries, HARDCODED_INI, sizeof(HARDCODED_INI));\n\t\t}\n\t\tini_entries_len += sizeof(HARDCODED_INI) - 2;\n\t}\n\n\tsapi_module->ini_entries = ini_entries;\n\n\t/* startup after we get the above ini override se we get things right */\n\tif (sapi_module->startup(sapi_module) == FAILURE) {\n\t\t/* there is no way to see if we must call zend_ini_deactivate()\n\t\t * since we cannot check if EG(ini_directives) has been initialized\n\t\t * because the executor's constructor does not set initialize it.\n\t\t * Apart from that there seems no need for zend_ini_deactivate() yet.\n\t\t * So we goto out_err.*/\n\t\texit_status = 1;\n\t\tgoto out;\n\t}\n\tmodule_started = 1;\n\n#if defined(PHP_WIN32)\n\tphp_win32_cp_cli_setup();\n\torig_cp = (php_win32_cp_get_orig())->id;\n\t/* Ignore the delivered argv and argc, read from W API. This place\n\t\tmight be too late though, but this is the earliest place ATW\n\t\twe can access the internal charset information from PHP. */\n\targv_wide = CommandLineToArgvW(GetCommandLineW(), &num_args);\n\tPHP_WIN32_CP_W_TO_ANY_ARRAY(argv_wide, num_args, argv, argc)\n\tusing_wide_argv = 1;\n\n\tSetConsoleCtrlHandler(php_cli_win32_ctrl_handler, TRUE);\n#endif\n\n\t/* -e option */\n\tif (use_extended_info) {\n\t\tCG(compiler_options) |= ZEND_COMPILE_EXTENDED_INFO;\n\t}\n\n\tzend_first_try {\n#ifndef PHP_CLI_WIN32_NO_CONSOLE\n\t\tif (sapi_module == &cli_sapi_module) {\n#endif\n\t\t\texit_status = do_cli(argc, argv);\n#ifndef PHP_CLI_WIN32_NO_CONSOLE\n\t\t} else {\n\t\t\texit_status = do_cli_server(argc, argv);\n\t\t}\n#endif\n\t} zend_end_try();\n",
    "target": 1,
    "idx": 1025601,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic int\nhtmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n    const unsigned char *cur;\n    unsigned char c;\n    unsigned int val;\n\n    if (ctxt->token != 0) {\n\t*len = 0;\n\treturn(ctxt->token);\n    }\n\n    if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)\n        xmlParserGrow(ctxt);\n\n    if ((ctxt->input->flags & XML_INPUT_HAS_ENCODING) == 0) {\n        xmlChar * guess;\n\n        /*\n         * Assume it's a fixed length encoding (1) with\n         * a compatible encoding for the ASCII set, since\n         * HTML constructs only use < 128 chars\n         */\n        if (*ctxt->input->cur < 0x80) {\n            if (*ctxt->input->cur == 0) {\n                if (ctxt->input->cur < ctxt->input->end) {\n                    htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n                                    \"Char 0x%X out of allowed range\\n\", 0);\n                    *len = 1;\n                    return(' ');\n                } else {\n                    *len = 0;\n                    return(0);\n                }\n            }\n            *len = 1;\n            return(*ctxt->input->cur);\n        }\n\n        /*\n         * Humm this is bad, do an automatic flow conversion\n         */\n        guess = htmlFindEncoding(ctxt);\n        if (guess == NULL) {\n            xmlSwitchEncoding(ctxt, XML_CHAR_ENCODING_8859_1);\n        } else {\n            xmlSwitchEncodingName(ctxt, (const char *) guess);\n            xmlFree(guess);\n        }\n        ctxt->input->flags |= XML_INPUT_HAS_ENCODING;\n    }\n\n    /*\n     * We are supposed to handle UTF8, check it's valid\n     * From rfc2044: encoding of the Unicode values on UTF-8:\n     *\n     * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n     * 0000 0000-0000 007F   0xxxxxxx\n     * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n     * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n     *\n     * Check for the 0x110000 limit too\n     */\n    cur = ctxt->input->cur;\n    c = *cur;\n    if (c & 0x80) {\n        size_t avail;\n\n        if ((c & 0x40) == 0)\n            goto encoding_error;\n\n        avail = ctxt->input->end - ctxt->input->cur;\n\n        if ((avail < 2) || ((cur[1] & 0xc0) != 0x80))\n            goto encoding_error;\n        if ((c & 0xe0) == 0xe0) {\n            if ((avail < 3) || ((cur[2] & 0xc0) != 0x80))\n                goto encoding_error;\n            if ((c & 0xf0) == 0xf0) {\n                if (((c & 0xf8) != 0xf0) ||\n                    (avail < 4) || ((cur[3] & 0xc0) != 0x80))\n                    goto encoding_error;\n                /* 4-byte code */\n                *len = 4;\n                val = (cur[0] & 0x7) << 18;\n                val |= (cur[1] & 0x3f) << 12;\n                val |= (cur[2] & 0x3f) << 6;\n                val |= cur[3] & 0x3f;\n                if (val < 0x10000)\n                    goto encoding_error;\n            } else {\n              /* 3-byte code */\n                *len = 3;\n                val = (cur[0] & 0xf) << 12;\n                val |= (cur[1] & 0x3f) << 6;\n                val |= cur[2] & 0x3f;\n                if (val < 0x800)\n                    goto encoding_error;\n            }\n        } else {\n          /* 2-byte code */\n            *len = 2;\n            val = (cur[0] & 0x1f) << 6;\n            val |= cur[1] & 0x3f;\n            if (val < 0x80)\n                goto encoding_error;\n        }\n        if (!IS_CHAR(val)) {\n            htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n                            \"Char 0x%X out of allowed range\\n\", val);\n        }\n        return(val);\n    } else {\n        if (*ctxt->input->cur == 0) {\n            if (ctxt->input->cur < ctxt->input->end) {\n                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n                                \"Char 0x%X out of allowed range\\n\", 0);\n                *len = 1;\n                return(' ');\n            } else {\n                *len = 0;\n                return(0);\n            }\n        }\n        /* 1-byte code */\n        *len = 1;\n        return(*ctxt->input->cur);\n    }\n\nencoding_error:\n    {\n        char buffer[150];\n\n\tif (ctxt->input->end - ctxt->input->cur >= 4) {\n\t    snprintf(buffer, 149, \"Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n\",\n\t\t\t    ctxt->input->cur[0], ctxt->input->cur[1],\n\t\t\t    ctxt->input->cur[2], ctxt->input->cur[3]);\n\t} else {\n\t    snprintf(buffer, 149, \"Bytes: 0x%02X\\n\", ctxt->input->cur[0]);\n\t}\n\thtmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n\t\t     \"Input is not proper UTF-8, indicate encoding !\\n\",\n\t\t     BAD_CAST buffer, NULL);\n    }\n\n    if ((ctxt->input->flags & XML_INPUT_HAS_ENCODING) == 0)\n        xmlSwitchEncoding(ctxt, XML_CHAR_ENCODING_8859_1);\n    *len = 1;\n    return(*ctxt->input->cur);\n}\n\nstatic void\nhtmlParseComment(htmlParserCtxtPtr ctxt) {\n    xmlChar *buf = NULL;\n    int len;\n    int size = HTML_PARSER_BUFFER_SIZE;\n    int q, ql;\n    int r, rl;\n    int cur, l;\n    int next, nl;\n    int maxLength = (ctxt->options & XML_PARSE_HUGE) ?\n                    XML_MAX_HUGE_LENGTH :\n                    XML_MAX_TEXT_LENGTH;\n    xmlParserInputState state;\n\n    /*\n     * Check that there is a comment right here.\n     */\n    if ((RAW != '<') || (NXT(1) != '!') ||\n        (NXT(2) != '-') || (NXT(3) != '-')) return;\n\n    state = ctxt->instate;\n    ctxt->instate = XML_PARSER_COMMENT;\n    SKIP(4);\n    buf = (xmlChar *) xmlMallocAtomic(size);\n    if (buf == NULL) {\n        htmlErrMemory(ctxt, \"buffer allocation failed\\n\");\n\treturn;\n    }\n    len = 0;\n    buf[len] = 0;\n    q = CUR_CHAR(ql);\n    if (q == 0)\n        goto unfinished;\n    if (q == '>') {\n        htmlParseErr(ctxt, XML_ERR_COMMENT_ABRUPTLY_ENDED, \"Comment abruptly ended\", NULL, NULL);\n        cur = '>';\n        goto finished;\n    }\n    NEXTL(ql);\n    r = CUR_CHAR(rl);\n    if (r == 0)\n        goto unfinished;\n    if (q == '-' && r == '>') {\n        htmlParseErr(ctxt, XML_ERR_COMMENT_ABRUPTLY_ENDED, \"Comment abruptly ended\", NULL, NULL);\n        cur = '>';\n        goto finished;\n    }\n    NEXTL(rl);\n    cur = CUR_CHAR(l);\n    while ((cur != 0) &&\n           ((cur != '>') ||\n\t    (r != '-') || (q != '-'))) {\n\tNEXTL(l);\n\tnext = CUR_CHAR(nl);\n\n\tif ((q == '-') && (r == '-') && (cur == '!') && (next == '>')) {\n\t  htmlParseErr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,\n\t\t       \"Comment incorrectly closed by '--!>'\", NULL, NULL);\n\t  cur = '>';\n\t  break;\n\t}\n\n\tif (len + 5 >= size) {\n\t    xmlChar *tmp;\n\n\t    size *= 2;\n\t    tmp = (xmlChar *) xmlRealloc(buf, size);\n\t    if (tmp == NULL) {\n\t        xmlFree(buf);\n\t        htmlErrMemory(ctxt, \"growing buffer failed\\n\");\n\t\treturn;\n\t    }\n\t    buf = tmp;\n\t}\n        if (IS_CHAR(q)) {\n\t    COPY_BUF(ql,buf,len,q);\n        } else {\n            htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n                            \"Invalid char in comment 0x%X\\n\", q);\n        }\n        if (len > maxLength) {\n            htmlParseErr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,\n                         \"comment too long\", NULL, NULL);\n            xmlFree(buf);\n            ctxt->instate = state;\n            return;\n        }\n\n\tq = r;\n\tql = rl;\n\tr = cur;\n\trl = l;\n\tcur = next;\n\tl = nl;\n    }\nfinished:\n    buf[len] = 0;\n    if (cur == '>') {\n        NEXT;\n\tif ((ctxt->sax != NULL) && (ctxt->sax->comment != NULL) &&\n\t    (!ctxt->disableSAX))\n\t    ctxt->sax->comment(ctxt->userData, buf);\n\txmlFree(buf);\n\tctxt->instate = state;\n\treturn;\n    }\n\nunfinished:\n    htmlParseErr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,\n\t\t \"Comment not terminated \\n<!--%.50s\\n\", buf, NULL);\n    xmlFree(buf);\n}\n\nint\nhtmlParseDocument(htmlParserCtxtPtr ctxt) {\n    xmlDtdPtr dtd;\n\n    xmlInitParser();\n\n    if ((ctxt == NULL) || (ctxt->input == NULL))\n\treturn(-1);\n\n    /*\n     * Document locator is unused. Only for backward compatibility.\n     */\n    if ((ctxt->sax) && (ctxt->sax->setDocumentLocator)) {\n        xmlSAXLocator copy = xmlDefaultSAXLocator;\n        ctxt->sax->setDocumentLocator(ctxt->userData, &copy);\n    }\n\n    xmlDetectEncoding(ctxt);\n\n    /*\n     * This is wrong but matches long-standing behavior. In most cases,\n     * a document starting with an XML declaration will specify UTF-8.\n     */\n    if (((ctxt->input->flags & XML_INPUT_HAS_ENCODING) == 0) &&\n        (xmlStrncmp(ctxt->input->cur, BAD_CAST \"<?xm\", 4) == 0))\n        xmlSwitchEncoding(ctxt, XML_CHAR_ENCODING_UTF8);\n\n    /*\n     * Wipe out everything which is before the first '<'\n     */\n    SKIP_BLANKS;\n    if (CUR == 0) {\n\thtmlParseErr(ctxt, XML_ERR_DOCUMENT_EMPTY,\n\t             \"Document is empty\\n\", NULL, NULL);\n    }\n\n    if ((ctxt->sax) && (ctxt->sax->startDocument) && (!ctxt->disableSAX))\n\tctxt->sax->startDocument(ctxt->userData);\n\n    /*\n     * Parse possible comments and PIs before any content\n     */\n    while (((CUR == '<') && (NXT(1) == '!') &&\n            (NXT(2) == '-') && (NXT(3) == '-')) ||\n\t   ((CUR == '<') && (NXT(1) == '?'))) {\n        htmlParseComment(ctxt);\n        htmlParsePI(ctxt);\n\tSKIP_BLANKS;\n    }\n\n\n    /*\n     * Then possibly doc type declaration(s) and more Misc\n     * (doctypedecl Misc*)?\n     */\n    if ((CUR == '<') && (NXT(1) == '!') &&\n\t(UPP(2) == 'D') && (UPP(3) == 'O') &&\n\t(UPP(4) == 'C') && (UPP(5) == 'T') &&\n\t(UPP(6) == 'Y') && (UPP(7) == 'P') &&\n\t(UPP(8) == 'E')) {\n\thtmlParseDocTypeDecl(ctxt);\n    }\n    SKIP_BLANKS;\n\n    /*\n     * Parse possible comments and PIs before any content\n     */\n    while ((PARSER_STOPPED(ctxt) == 0) &&\n           (((CUR == '<') && (NXT(1) == '!') &&\n             (NXT(2) == '-') && (NXT(3) == '-')) ||\n\t    ((CUR == '<') && (NXT(1) == '?')))) {\n        htmlParseComment(ctxt);\n        htmlParsePI(ctxt);\n\tSKIP_BLANKS;\n    }\n\n    /*\n     * Time to start parsing the tree itself\n     */\n    htmlParseContentInternal(ctxt);\n\n    /*\n     * autoclose\n     */\n    if (CUR == 0)\n\thtmlAutoCloseOnEnd(ctxt);\n\n\n    /*\n     * SAX: end of the document processing.\n     */\n    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n        ctxt->sax->endDocument(ctxt->userData);\n\n    if ((!(ctxt->options & HTML_PARSE_NODEFDTD)) && (ctxt->myDoc != NULL)) {\n\tdtd = xmlGetIntSubset(ctxt->myDoc);\n\tif (dtd == NULL) {\n\t    ctxt->myDoc->intSubset =\n\t\txmlCreateIntSubset(ctxt->myDoc, BAD_CAST \"html\",\n\t\t    BAD_CAST \"-//W3C//DTD HTML 4.0 Transitional//EN\",\n\t\t    BAD_CAST \"http://www.w3.org/TR/REC-html40/loose.dtd\");\n            if (ctxt->myDoc->intSubset == NULL)\n                htmlErrMemory(ctxt, NULL);\n        }\n    }\n    if (! ctxt->wellFormed) return(-1);\n    return(0);\n}\n\nstatic htmlDocPtr\nhtmlDoRead(htmlParserCtxtPtr ctxt, const char *URL, const char *encoding,\n          int options, int reuse)\n{\n    htmlDocPtr ret;\n\n    htmlCtxtUseOptions(ctxt, options);\n    ctxt->html = 1;\n    if (encoding != NULL)\n        xmlSwitchEncodingName(ctxt, encoding);\n    if ((URL != NULL) && (ctxt->input != NULL) &&\n        (ctxt->input->filename == NULL))\n        ctxt->input->filename = (char *) xmlStrdup((const xmlChar *) URL);\n    htmlParseDocument(ctxt);\n    if (ctxt->errNo == XML_ERR_NO_MEMORY) {\n        xmlFreeDoc(ctxt->myDoc);\n        ctxt->myDoc = NULL;\n    }\n    ret = ctxt->myDoc;\n    ctxt->myDoc = NULL;\n    if (!reuse) {\n        if ((ctxt->dictNames) &&\n\t    (ret != NULL) &&\n\t    (ret->dict == ctxt->dict))\n\t    ctxt->dict = NULL;\n\txmlFreeParserCtxt(ctxt);\n    }\n    return (ret);\n}\n\nhtmlDocPtr\nhtmlCtxtReadMemory(htmlParserCtxtPtr ctxt, const char *buffer, int size,\n                  const char *URL, const char *encoding, int options)\n{\n    xmlParserInputBufferPtr input;\n    xmlParserInputPtr stream;\n\n    if (ctxt == NULL)\n        return (NULL);\n    if (buffer == NULL)\n        return (NULL);\n    xmlInitParser();\n\n    htmlCtxtReset(ctxt);\n\n    input = xmlParserInputBufferCreateStatic(buffer, size,\n                                             XML_CHAR_ENCODING_NONE);\n    if (input == NULL) {\n        htmlErrMemory(ctxt, NULL);\n\treturn(NULL);\n    }\n\n    stream = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);\n    if (stream == NULL) {\n\txmlFreeParserInputBuffer(input);\n\treturn(NULL);\n    }\n\n    inputPush(ctxt, stream);\n    return (htmlDoRead(ctxt, URL, encoding, options, 1));\n}\n\n\n// target function\nint\nxmlSwitchInputEncoding(xmlParserCtxtPtr ctxt, xmlParserInputPtr input,\n                       xmlCharEncodingHandlerPtr handler)\n{\n    int nbchars;\n    xmlParserInputBufferPtr in;\n\n    if ((input == NULL) || (input->buf == NULL)) {\n        xmlCharEncCloseFunc(handler);\n\treturn (-1);\n    }\n    in = input->buf;\n\n    input->flags |= XML_INPUT_HAS_ENCODING;\n\n    /*\n     * UTF-8 requires no encoding handler.\n     */\n    if ((handler != NULL) &&\n        (xmlStrcasecmp(BAD_CAST handler->name, BAD_CAST \"UTF-8\") == 0)) {\n        xmlCharEncCloseFunc(handler);\n        handler = NULL;\n    }\n\n    if (in->encoder == handler)\n        return (0);\n\n    if (in->encoder != NULL) {\n        /*\n         * Switching encodings during parsing is a really bad idea,\n         * but Chromium can switch between ISO-8859-1 and UTF-16 before\n         * separate calls to xmlParseChunk.\n         *\n         * TODO: We should check whether the \"raw\" input buffer is empty and\n         * convert the old content using the old encoder.\n         */\n\n        xmlCharEncCloseFunc(in->encoder);\n        in->encoder = handler;\n        return (0);\n    }\n\n    in->encoder = handler;\n\n    /*\n     * Is there already some content down the pipe to convert ?\n     */\n    if (xmlBufIsEmpty(in->buffer) == 0) {\n        size_t processed;\n\n        /*\n         * Shrink the current input buffer.\n         * Move it as the raw buffer and create a new input buffer\n         */\n        processed = input->cur - input->base;\n        xmlBufShrink(in->buffer, processed);\n        input->consumed += processed;\n        in->raw = in->buffer;\n        in->buffer = xmlBufCreate();\n        if (in->buffer == NULL) {\n            xmlErrMemory(ctxt, NULL);\n            return(-1);\n        }\n        in->rawconsumed = processed;\n\n        nbchars = xmlCharEncInput(in);\n        xmlBufResetInput(in->buffer, input);\n        if (nbchars == XML_ENC_ERR_MEMORY) {\n            xmlErrMemory(ctxt, NULL);\n        } else if (nbchars < 0) {\n            xmlErrInternal(ctxt,\n                           \"switching encoding: encoder error\\n\",\n                           NULL);\n            xmlHaltParser(ctxt);\n            return (-1);\n        }\n    }\n    return (0);\n}\n",
    "target": 1,
    "idx": 1065043,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "// context\n\n\nstatic void\ngc_objects_set_reloc(gc_state_t * gcst, clump_t * cp)\n{\n    size_t reloc = 0;\n    clump_head_t *chead = cp->chead;\n    byte *pfree = (byte *) & chead->free;\t/* most recent free object */\n\n    if_debug_clump('6', gcst->heap, \"[6]setting reloc for clump\", cp);\n    gc_init_reloc(cp);\n    SCAN_CLUMP_OBJECTS(cp)\n        DO_ALL\n        struct_proc_finalize((*finalize));\n    const struct_shared_procs_t *procs =\n    pre->o_type->shared;\n\n    if ((procs == 0 ? o_is_unmarked(pre) :\n         !(*procs->set_reloc) (pre, reloc, size))\n        ) {\t\t\t/* Free object */\n        reloc += sizeof(obj_header_t) + obj_align_round(size);\n        if ((finalize = pre->o_type->finalize) != 0) {\n            if_debug2m('u', gcst->heap, \"[u]GC finalizing %s \"PRI_INTPTR\"\\n\",\n                       struct_type_name_string(pre->o_type),\n                       (intptr_t)(pre + 1));\n            (*finalize) (gcst->cur_mem, pre + 1);\n        }\n        pfree = (byte *) pre;\n        pre->o_back = (pfree - (byte *) chead) >> obj_back_shift;\n        pre->o_nreloc = reloc;\n        if_debug3m('7', gcst->heap, \" [7]at \"PRI_INTPTR\", unmarked %lu, new reloc = %u\\n\",\n                   (intptr_t)pre, (ulong) size, (unsigned int)reloc);\n    } else {\t\t\t/* Useful object */\n        debug_check_object(pre, cp, gcst);\n        pre->o_back = ((byte *) pre - pfree) >> obj_back_shift;\n    }\n    END_OBJECTS_SCAN\n#ifdef DEBUG\n    if (reloc != 0) {\n        if_debug1m('6', gcst->heap, \"[6]freed %u\", (unsigned int)reloc);\n        if_debug_clump('6', gcst->heap, \" in\", cp);\n    }\n#endif\n}\n\n\n\nstatic int\ngs_vmreclaim(gs_dual_memory_t *dmem, bool global)\n{\n    /* HACK: we know the gs_dual_memory_t is embedded in a context state. */\n    i_ctx_t *i_ctx_p =\n        (i_ctx_t *)((char *)dmem - offset_of(i_ctx_t, memory));\n    gs_ref_memory_t *lmem = dmem->space_local;\n    int code = context_state_store(i_ctx_p);\n    gs_ref_memory_t *memories[5];\n    gs_ref_memory_t *mem;\n    int nmem, i;\n\n    if (code < 0)\n        return code;\n\n    memories[0] = dmem->space_system;\n    memories[1] = mem = dmem->space_global;\n    nmem = 2;\n    if (lmem != dmem->space_global)\n        memories[nmem++] = lmem;\n    for (i = nmem; --i >= 0;) {\n        mem = memories[i];\n        if (mem->stable_memory != (gs_memory_t *)mem)\n            memories[nmem++] = (gs_ref_memory_t *)mem->stable_memory;\n    }\n\n    /****** ABORT IF code < 0 ******/\n    for (i = nmem; --i >= 0; )\n        alloc_close_clump(memories[i]);\n\n    /* Prune the file list so it won't retain potentially collectible */\n    /* files. */\n\n    for (i = (global ? i_vm_system : i_vm_local);\n         i < countof(dmem->spaces_indexed);\n         ++i\n         ) {\n        gs_ref_memory_t *mem = dmem->spaces_indexed[i];\n\n        /* Always safe to substract 1 from i here, as i is always at\n         * least i_vm_system (1) or i_vm_local (2). */\n        if (mem == 0 || (mem == dmem->spaces_indexed[i - 1]))\n            continue;\n        if (mem->stable_memory != (gs_memory_t *)mem)\n            ialloc_gc_prepare((gs_ref_memory_t *)mem->stable_memory);\n        for (;; mem = &mem->saved->state) {\n            ialloc_gc_prepare(mem);\n            if (mem->saved == 0)\n                break;\n        }\n    }\n\n    /* Do the actual collection. */\n\n    {\n        void *ctxp = i_ctx_p;\n        gs_gc_root_t context_root, *r = &context_root;\n\n        gs_register_struct_root((gs_memory_t *)lmem, &r,\n                                &ctxp, \"i_ctx_p root\");\n        GS_RECLAIM(&dmem->spaces, global);\n        gs_unregister_root((gs_memory_t *)lmem, r, \"i_ctx_p root\");\n        i_ctx_p = ctxp;\n        dmem = &i_ctx_p->memory;\n    }\n\n    /* Update caches not handled by context_state_load. */\n\n    *systemdict = *ref_stack_index(&d_stack, ref_stack_count(&d_stack) - 1);\n\n    /* Update the cached value pointers in names. */\n\n    dicts_gc_cleanup();\n\n    /* Reopen the active clumps. */\n\n    for (i = 0; i < nmem; ++i)\n        alloc_open_clump(memories[i]);\n\n    /* Reload the context state.  Note this should be done\n       AFTER the clumps are reopened, since the context state\n       load could do allocations that must remain.\n       If it were done while the clumps were still closed,\n       we would lose those allocations when the clumps were opened */\n\n    code = context_state_load(i_ctx_p);\n    return code;\n}\n\nstatic int\nireclaim(gs_dual_memory_t * dmem, int space)\n{\n    bool global;\n    gs_ref_memory_t *mem = NULL;\n    int code;\n\n    if (space < 0) {\n        /* Determine which allocator exceeded the limit. */\n        int i;\n\n        for (i = 0; i < countof(dmem->spaces_indexed); i++) {\n            mem = dmem->spaces_indexed[i];\n            if (mem == 0)\n                continue;\n            if (mem->gc_status.requested > 0 ||\n                ((gs_ref_memory_t *)mem->stable_memory)->gc_status.requested > 0\n                )\n                break;\n        }\n        if (!mem) {\n            mem = dmem->space_global; /* just in case */\n        }\n    } else {\n        mem = dmem->spaces_indexed[space >> r_space_shift];\n    }\n    if_debug3m('0', (gs_memory_t *)mem, \"[0]GC called, space=%d, requestor=%d, requested=%ld\\n\",\n               space, mem->space, (long)mem->gc_status.requested);\n    global = mem->space != avm_local;\n    /* Since dmem may move, reset the request now. */\n    ialloc_reset_requested(dmem);\n    code = gs_vmreclaim(dmem, global);\n    if (code < 0)\n        return code;\n    ialloc_set_limit(mem);\n    if (space < 0) {\n        gs_memory_status_t stats;\n        size_t allocated;\n\n        /* If the ammount still allocated after the GC is complete */\n        /* exceeds the max_vm setting, then return a VMerror       */\n        gs_memory_status((gs_memory_t *) mem, &stats);\n        allocated = stats.allocated;\n        if (mem->stable_memory != (gs_memory_t *)mem) {\n            gs_memory_status(mem->stable_memory, &stats);\n            allocated += stats.allocated;\n        }\n        if (allocated >= mem->gc_status.max_vm) {\n            /* We can't satisfy this request within max_vm. */\n            return_error(gs_error_VMerror);\n        }\n    }\n    return 0;\n}\n\nint\ninterp_reclaim(i_ctx_t **pi_ctx_p, int space)\n{\n    i_ctx_t *i_ctx_p = *pi_ctx_p;\n    gs_gc_root_t ctx_root, *r = &ctx_root;\n    int code;\n\n#ifdef DEBUG\n    if (gs_debug_c(gs_debug_flag_gc_disable))\n        return 0;\n#endif\n\n    gs_register_struct_root(imemory_system, &r,\n                            (void **)pi_ctx_p, \"interp_reclaim(pi_ctx_p)\");\n    code = (*idmemory->reclaim)(idmemory, space);\n    i_ctx_p = *pi_ctx_p;        /* may have moved */\n    gs_unregister_root(imemory_system, r, \"interp_reclaim(pi_ctx_p)\");\n    return code;\n}\n\nint\ngs_main_finit(gs_main_instance * minst, int exit_status, int env_code)\n{\n    i_ctx_t *i_ctx_p = minst->i_ctx_p;\n    gs_dual_memory_t dmem = {0};\n    int exit_code;\n    ref error_object;\n    char *tempnames = NULL;\n    gs_lib_ctx_core_t *core;\n\n    /* NB: need to free gs_name_table\n     */\n\n    /*\n     * Previous versions of this code closed the devices in the\n     * device list here.  Since these devices are now prototypes,\n     * they cannot be opened, so they do not need to be closed;\n     * alloc_restore_all will close dynamically allocated devices.\n     */\n    tempnames = gs_main_tempnames(minst);\n\n    /* by the time we get here, we *must* avoid any random redefinitions of\n     * operators etc, so we push systemdict onto the top of the dict stack.\n     * We do this in C to avoid running into any other re-defininitions in the\n     * Postscript world.\n     */\n    gs_finit_push_systemdict(i_ctx_p);\n\n    /* We have to disable BGPrint before we call interp_reclaim() to prevent the\n     * parent rendering thread initialising for the next page, whilst we are\n     * removing objects it may want to access - for example, the I/O device table.\n     * We also have to mess with the BeginPage/EndPage procs so that we don't\n     * trigger a spurious extra page to be emitted.\n     */\n    if (minst->init_done >= 2) {\n        gs_main_run_string(minst,\n            \"/BGPrint /GetDeviceParam .special_op \\\n            {{ <</BeginPage {pop} /EndPage {pop pop //false } \\\n              /BGPrint false /NumRenderingThreads 0>> setpagedevice} if} if \\\n              serverdict /.jobsavelevel get 0 eq {/quit} {/stop} ifelse \\\n              .systemvar exec\",\n            0 , &exit_code, &error_object);\n    }\n\n    /*\n     * Close the \"main\" device, because it may need to write out\n     * data before destruction. pdfwrite needs so.\n     */\n    if (minst->init_done >= 2) {\n        int code = 0;\n\n        if (idmemory->reclaim != 0) {\n            code = interp_reclaim(&minst->i_ctx_p, avm_global);\n\n            /* We ignore gs_error_VMerror because it comes from gs_vmreclaim()\n            calling context_state_load(), and we don't seem to depend on the\n            missing fields. */\n            if (code == gs_error_VMerror) {\n                if (exit_status == 0 || exit_status == gs_error_Quit) {\n                    exit_status = gs_error_VMerror;\n                }\n            }\n            else if (code < 0) {\n                ref error_name;\n                if (tempnames)\n                    free(tempnames);\n\n                if (gs_errorname(i_ctx_p, code, &error_name) >= 0) {\n                    char err_str[32] = {0};\n                    name_string_ref(imemory, &error_name, &error_name);\n                    memcpy(err_str, error_name.value.const_bytes, r_size(&error_name));\n                    emprintf2(imemory, \"ERROR: %s (%d) reclaiming the memory while the interpreter finalization.\\n\", err_str, code);\n                }\n                else {\n                    emprintf1(imemory, \"UNKNOWN ERROR %d reclaiming the memory while the interpreter finalization.\\n\", code);\n                }\n#ifdef MEMENTO\n                if (Memento_squeezing() && code != gs_error_VMerror ) return gs_error_Fatal;\n#endif\n                return gs_error_Fatal;\n            }\n            i_ctx_p = minst->i_ctx_p; /* interp_reclaim could change it. */\n        }\n\n        if (i_ctx_p->pgs != NULL && i_ctx_p->pgs->device != NULL &&\n            gx_device_is_null(i_ctx_p->pgs->device)) {\n            /* if the job replaced the device with the nulldevice, we we need to grestore\n               away that device, so the block below can properly dispense\n               with the default device.\n             */\n            int code = gs_grestoreall(i_ctx_p->pgs);\n            if (code < 0) {\n                free(tempnames);\n                return_error(gs_error_Fatal);\n            }\n        }\n\n        if (i_ctx_p->pgs != NULL && i_ctx_p->pgs->device != NULL) {\n            gx_device *pdev = i_ctx_p->pgs->device;\n            const char * dname = pdev->dname;\n            gs_gc_root_t dev_root;\n            gs_gc_root_t *dev_root_ptr = &dev_root;\n            /* There is a chance that, during the call to gs_main_run_string(), the interpreter may\n             * decide to call the garbager - the device is in gc memory, and the only reference to it\n             * (in the gstate) has been removed, thus it can be destroyed by the garbager.\n             * Counter-intuitively, adjusting the reference count makes not difference to that.\n             * Register the device as a gc 'root' so it will be implicitely marked by garbager, and\n             * and thus surive until control returns here.\n             */\n            if (gs_register_struct_root(pdev->memory, &dev_root_ptr, (void **)&pdev, \"gs_main_finit\") < 0) {\n                free(tempnames);\n                return_error(gs_error_Fatal);\n            }\n\n            /* make sure device doesn't isn't freed by .uninstalldevice */\n            rc_adjust(pdev, 1, \"gs_main_finit\");\n            /* deactivate the device just before we close it for the last time */\n            gs_main_run_string(minst,\n                /* we need to do the 'quit' so we don't loop for input (double quit) */\n                \".uninstallpagedevice serverdict \\\n                /.jobsavelevel get 0 eq {/quit} {/stop} ifelse .systemvar exec\",\n                0 , &exit_code, &error_object);\n            code = gs_closedevice(pdev);\n            if (code < 0) {\n                ref error_name;\n                if (gs_errorname(i_ctx_p, code, &error_name) >= 0) {\n                    char err_str[32] = {0};\n                    name_string_ref(imemory, &error_name, &error_name);\n                    memcpy(err_str, error_name.value.const_bytes, r_size(&error_name));\n                    emprintf3(imemory, \"ERROR: %s (%d) on closing %s device.\\n\", err_str, code, dname);\n                }\n                else {\n                    emprintf2(imemory, \"UNKNOWN ERROR %d closing %s device.\\n\", code, dname);\n               }\n            }\n            gs_unregister_root(pdev->memory, dev_root_ptr, \"gs_main_finit\");\n            rc_decrement(pdev, \"gs_main_finit\");                /* device might be freed */\n            if (exit_status == 0 || exit_status == gs_error_Quit)\n                exit_status = code;\n        }\n\n      /* Flush stdout and stderr */\n      gs_main_run_string(minst,\n        \"(%stdout) (w) file closefile (%stderr) (w) file closefile \\\n        serverdict /.jobsavelevel get 0 eq {/quit} {/stop} ifelse .systemexec \\\n          systemdict /savedinitialgstate .forceundef\",\n        0 , &exit_code, &error_object);\n    }\n    gp_readline_finit(minst->readline_data);\n    gs_free_object(minst->heap, minst->saved_pages_initial_arg, \"gs_main_finit\");\n    i_ctx_p = minst->i_ctx_p;\t\t/* get current interp context */\n    if (gs_debug_c(':')) {\n        print_resource_usage(minst, &gs_imemory, \"Final\");\n        dmprintf1(minst->heap, \"%% Exiting instance \"PRI_INTPTR\"\\n\", (intptr_t)minst);\n    }\n    /* Do the equivalent of a restore \"past the bottom\". */\n    /* This will release all memory, close all open files, etc. */\n    if (minst->init_done >= 1) {\n        gs_memory_t *mem_raw = i_ctx_p->memory.current->non_gc_memory;\n        i_plugin_holder *h = i_ctx_p->plugin_list;\n\n        dmem = *idmemory;\n        env_code = alloc_restore_all(i_ctx_p);\n        if (env_code < 0)\n            emprintf1(mem_raw,\n                      \"ERROR %d while the final restore. See gs/psi/ierrors.h for code explanation.\\n\",\n                      env_code);\n        i_iodev_finit(&dmem);\n        i_plugin_finit(mem_raw, h);\n    }\n\n    /* clean up redirected stdout */\n    core = minst->heap->gs_lib_ctx->core;\n    if (core->fstdout2\n        && (gp_get_file(core->fstdout2) != core->fstdout)\n        && (gp_get_file(core->fstdout2) != core->fstderr)) {\n        gp_fclose(core->fstdout2);\n        core->fstdout2 = NULL;\n    }\n\n    minst->heap->gs_lib_ctx->core->stdout_is_redirected = 0;\n    minst->heap->gs_lib_ctx->core->stdout_to_stderr = 0;\n    /* remove any temporary files, after ghostscript has closed files */\n    if (tempnames) {\n        char *p = tempnames;\n        while (*p) {\n            gp_unlink(minst->heap, p);\n            p += strlen(p) + 1;\n        }\n        free(tempnames);\n    }\n    gs_lib_finit(exit_status, env_code, minst->heap);\n\n    set_lib_path_length(minst, 0);\n    gs_free_object(minst->heap, minst->lib_path.container.value.refs, \"lib_path array\");\n    if (minst->init_done == 0 && i_ctx_p) {\n        /* This fixes leak if memento forces failure in gs_main_init1(). */\n        dmem = *idmemory;\n    }\n    ialloc_finit(&dmem);\n    return exit_status;\n}\n\nint\ngs_to_exit_with_code(const gs_memory_t *mem, int exit_status, int code)\n{\n    return gs_main_finit(get_minst_from_memory(mem), exit_status, code);\n}\n\nint\ngs_to_exit(const gs_memory_t *mem, int exit_status)\n{\n    return gs_to_exit_with_code(mem, exit_status, 0);\n}\n\nint\npsapi_exit(gs_lib_ctx_t *ctx)\n{\n    if (ctx == NULL)\n        return gs_error_Fatal;\n\n    gs_to_exit(ctx->memory, 0);\n    return 0;\n}\n\nGSDLLEXPORT int GSDLLAPI\ngsapi_exit(void *instance)\n{\n    gs_lib_ctx_t *ctx = (gs_lib_ctx_t *)instance;\n    if (instance == NULL)\n        return gs_error_Fatal;\n    gp_set_debug_mem_ptr(ctx->memory);\n    return psapi_exit(ctx);\n}\n\nint gs_to_raster_fuzz(const unsigned char *buf, size_t size, int color_scheme)\n{\n\tint ret;\n\tvoid *gs = NULL;\n\tchar color_space[50];\n\t/*\n\t * We are expecting color_scheme to be in the [0:62] interval.\n\t * This corresponds to the color schemes defined here:\n\t * https://github.com/ArtifexSoftware/ghostpdl/blob/8c97d5adce0040ac38a1fb4d7954499c65f582ff/cups/libs/cups/raster.h#L102\n\t */\n\tsprintf(color_space, \"-dcupsColorSpace=%d\", color_scheme);\n\t/* Mostly stolen from cups-filters gstoraster. */\n\tchar *args[] = {\n\t\t\"gs\",\n\t\t\"-K1048576\",\n\t\t\"-r200x200\",\n\t\t\"-sBandListStorage=memory\",\n\t\t\"-dMaxBitmap=0\",\n\t\t\"-dBufferSpace=450k\",\n\t\t\"-dMediaPosition=1\",\n\t\tcolor_space,\n\t\t\"-dQUIET\",\n\t\t\"-dSAFER\",\n\t\t\"-dNOPAUSE\",\n\t\t\"-dBATCH\",\n\t\t\"-dNOINTERPOLATE\",\n\t\t\"-dNOMEDIAATTRS\",\n\t\t\"-sstdout=%%stderr\",\n\t\t\"-sOutputFile=/dev/null\",\n\t\t\"-sDEVICE=cups\",\n\t\t\"-_\",\n\t};\n\tint argc = sizeof(args) / sizeof(args[0]);\n\n\t/* Stash buffers globally, for gs_stdin(). */\n\tg_data = buf;\n\tg_size = size;\n\n\tret = gsapi_new_instance(&gs, NULL);\n\tif (ret < 0) {\n\t\tfprintf(stderr, \"gsapi_new_instance: error %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tgsapi_set_stdio(gs, gs_stdin, gs_stdnull, gs_stdnull);\n\tret = gsapi_set_arg_encoding(gs, GS_ARG_ENCODING_UTF8);\n\tif (ret < 0) {\n\t\tfprintf(stderr, \"gsapi_set_arg_encoding: error %d\\n\", ret);\n\t\tgsapi_delete_instance(gs);\n\t\treturn ret;\n\t}\n\n\tret = gsapi_init_with_args(gs, argc, args);\n\tif (ret && ret != gs_error_Quit)\n\t\t/* Just keep going, to cleanup. */\n\t\tfprintf(stderr, \"gsapi_init_with_args: error %d\\n\", ret);\n\n\tret = gsapi_exit(gs);\n\tif (ret < 0 && ret != gs_error_Quit) {\n\t\tfprintf(stderr, \"gsapi_exit: error %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tgsapi_delete_instance(gs);\n\n\treturn 0;\n}\n\n\n// target function\nint gx_device_subclass(gx_device *dev_to_subclass, gx_device *new_prototype, unsigned int private_data_size)\n{\n    gx_device *child_dev;\n    void *psubclass_data;\n    gs_memory_struct_type_t *a_std, *b_std = NULL;\n    int dynamic = dev_to_subclass->stype_is_dynamic;\n    char *ptr, *ptr1;\n\n    /* If this happens we are stuffed, as there is no way to get hold\n     * of the original device's stype structure, which means we cannot\n     * allocate a replacement structure. Abort if so.\n     * Also abort if the new_prototype device struct is too large.\n     */\n    if (!dev_to_subclass->stype ||\n        dev_to_subclass->stype->ssize < new_prototype->params_size)\n        return_error(gs_error_VMerror);\n\n    /* We make a 'stype' structure for our new device, and copy the old stype into it\n     * This means our new device will always have the 'stype_is_dynamic' flag set\n     */\n    a_std = (gs_memory_struct_type_t *)\n        gs_alloc_bytes_immovable(dev_to_subclass->memory->non_gc_memory, sizeof(*a_std),\n                                 \"gs_device_subclass(stype)\");\n    if (!a_std)\n        return_error(gs_error_VMerror);\n    *a_std = *dev_to_subclass->stype;\n    a_std->ssize = dev_to_subclass->params_size;\n\n    if (!dynamic) {\n        b_std = (gs_memory_struct_type_t *)\n            gs_alloc_bytes_immovable(dev_to_subclass->memory->non_gc_memory, sizeof(*b_std),\n                                     \"gs_device_subclass(stype)\");\n        if (!b_std)\n            return_error(gs_error_VMerror);\n    }\n\n    /* Allocate a device structure for the new child device */\n    child_dev = gs_alloc_struct_immovable(dev_to_subclass->memory->stable_memory, gx_device, a_std,\n                                        \"gs_device_subclass(device)\");\n    if (child_dev == 0) {\n        gs_free_const_object(dev_to_subclass->memory->non_gc_memory, a_std, \"gs_device_subclass(stype)\");\n        gs_free_const_object(dev_to_subclass->memory->non_gc_memory, b_std, \"gs_device_subclass(stype)\");\n        return_error(gs_error_VMerror);\n    }\n\n    /* Make sure all methods are filled in, note this won't work for a forwarding device\n     * so forwarding devices will have to be filled in before being subclassed. This doesn't fill\n     * in the fill_rectangle proc, that gets done in the ultimate device's open proc.\n     */\n    gx_device_fill_in_procs(dev_to_subclass);\n    memcpy(child_dev, dev_to_subclass, dev_to_subclass->stype->ssize);\n    child_dev->stype = a_std;\n    child_dev->stype_is_dynamic = 1;\n\n    psubclass_data = (void *)gs_alloc_bytes(dev_to_subclass->memory->non_gc_memory, private_data_size, \"subclass memory for subclassing device\");\n    if (psubclass_data == 0){\n        gs_free_const_object(dev_to_subclass->memory->non_gc_memory, b_std, \"gs_device_subclass(stype)\");\n        /* We *don't* want to run the finalize routine. This would free the stype and\n         * properly handle the icc_struct and PageList, but for devices with a custom\n         * finalize (eg psdcmyk) it might also free memory it had allocated, and we're\n         * still pointing at that memory in the parent.\n         */\n        a_std->finalize = NULL;\n        gs_set_object_type(dev_to_subclass->memory->stable_memory, child_dev, a_std);\n        gs_free_object(dev_to_subclass->memory->stable_memory, child_dev, \"free subclass memory for subclassing device\");\n        gs_free_const_object(dev_to_subclass->memory->non_gc_memory, a_std, \"gs_device_subclass(stype)\");\n        return_error(gs_error_VMerror);\n    }\n    memset(psubclass_data, 0x00, private_data_size);\n\n    gx_copy_device_procs(dev_to_subclass, child_dev, new_prototype);\n    dev_to_subclass->finalize = new_prototype->finalize;\n    dev_to_subclass->dname = new_prototype->dname;\n    if (dev_to_subclass->icc_struct)\n        rc_increment(dev_to_subclass->icc_struct);\n    if (dev_to_subclass->PageList)\n        rc_increment(dev_to_subclass->PageList);\n    if (dev_to_subclass->NupControl)\n        rc_increment(dev_to_subclass->NupControl);\n\n    dev_to_subclass->page_procs = new_prototype->page_procs;\n    gx_subclass_fill_in_page_procs(dev_to_subclass);\n\n    /* In case the new device we're creating has already been initialised, copy\n     * its additional data.\n     */\n    ptr = ((char *)dev_to_subclass) + sizeof(gx_device);\n    ptr1 = ((char *)new_prototype) + sizeof(gx_device);\n    memcpy(ptr, ptr1, new_prototype->params_size - sizeof(gx_device));\n\n    /* If the original device's stype structure was dynamically allocated, we need\n     * to 'fixup' the contents, it's procs need to point to the new device's procs\n     * for instance.\n     */\n    if (dynamic) {\n        if (new_prototype->stype) {\n            b_std = (gs_memory_struct_type_t *)dev_to_subclass->stype;\n            *b_std = *new_prototype->stype;\n            b_std->ssize = a_std->ssize;\n            dev_to_subclass->stype_is_dynamic = 1;\n        } else {\n            gs_free_const_object(child_dev->memory->non_gc_memory, dev_to_subclass->stype,\n                             \"unsubclass\");\n            dev_to_subclass->stype = NULL;\n            b_std = (gs_memory_struct_type_t *)new_prototype->stype;\n            dev_to_subclass->stype_is_dynamic = 0;\n        }\n    }\n    else {\n        *b_std = *new_prototype->stype;\n        b_std->ssize = a_std->ssize;\n        dev_to_subclass->stype_is_dynamic = 1;\n    }\n    dev_to_subclass->stype = b_std;\n    /* We have to patch up the \"type\" parameters that the memory manage/garbage\n     * collector will use, as well.\n     */\n    gs_set_object_type(child_dev->memory, dev_to_subclass, b_std);\n\n    dev_to_subclass->subclass_data = psubclass_data;\n    dev_to_subclass->child = child_dev;\n    if (child_dev->parent) {\n        dev_to_subclass->parent = child_dev->parent;\n        child_dev->parent->child = dev_to_subclass;\n    }\n    if (child_dev->child) {\n        child_dev->child->parent = child_dev;\n    }\n    child_dev->parent = dev_to_subclass;\n\n    return 0;\n}\nvoid gx_device_unsubclass(gx_device *dev)\n{\n    generic_subclass_data *psubclass_data;\n    gx_device *parent, *child;\n    gs_memory_struct_type_t *a_std = 0, *b_std = 0;\n    int dynamic, ref_count;\n\n    /* This should not happen... */\n    if (!dev)\n        return;\n\n    ref_count = dev->rc.ref_count;\n    child = dev->child;\n    psubclass_data = (generic_subclass_data *)dev->subclass_data;\n    parent = dev->parent;\n    dynamic = dev->stype_is_dynamic;\n\n    /* We need to account for the fact that we are removing ourselves from\n     * the device chain after a clist device has been pushed, due to a\n     * compositor action. Since we patched the clist 'composite'\n     * method (and target device) when it was pushed.\n     * A point to note; we *don't* want to change the forwarding device's\n     * 'target', because when we copy the child up to replace 'this' device\n     * we do still want the forwarding device to point here. NB its the *child*\n     * device that goes away.\n     */\n    if (psubclass_data != NULL && psubclass_data->forwarding_dev != NULL && psubclass_data->saved_compositor_method)\n        psubclass_data->forwarding_dev->procs.composite = psubclass_data->saved_compositor_method;\n\n    /* If ths device's stype is dynamically allocated, keep a copy of it\n     * in case we might need it.\n     */\n    if (dynamic) {\n        a_std = (gs_memory_struct_type_t *)dev->stype;\n        if (child)\n            *a_std = *child->stype;\n    }\n\n    /* If ths device has any private storage, free it now */\n    if (psubclass_data)\n        gs_free_object(dev->memory->non_gc_memory, psubclass_data, \"gx_device_unsubclass\");\n\n    /* Copy the child device into ths device's memory */\n    if (child) {\n        b_std = (gs_memory_struct_type_t *)dev->stype;\n        rc_decrement(dev->icc_struct, \"unsubclass device\");\n        rc_increment(child->icc_struct);\n        memcpy(dev, child, child->stype->ssize);\n        /* Patch back the 'stype' in the memory manager */\n        gs_set_object_type(child->memory, dev, b_std);\n\n        dev->stype = b_std;\n        /* The reference count of the subclassing device may have been\n         * changed (eg graphics states pointing to it) after we subclassed\n         * the device. We need to ensure that we do not overwrite this\n         * when we copy back the subclassed device.\n         */\n        dev->rc.ref_count = ref_count;\n\n        /* If we have a chain of devices, make sure the chain beyond the\n         * device we're unsubclassing doesn't get broken, we need to\n         * detach the lower chain and reattach it at the new highest level.\n         */\n        if (child->child)\n            child->child->parent = dev;\n        child->parent->child = child->child;\n    }\n\n    /* How can we have a subclass device with no child ? Simples; when we\n     * hit the end of job restore, the devices are not freed in device\n     * chain order. To make sure we don't end up following stale pointers,\n     * when a device is freed we remove it from the chain and update\n     * any dangling pointers to NULL. When we later free the remaining\n     * devices it's possible that their child pointer can then be NULL.\n     */\n    if (child) {\n        if (child->icc_struct)\n            rc_decrement(child->icc_struct, \"gx_device_unsubclass, icc_struct\");\n        if (child->PageList)\n            rc_decrement(child->PageList, \"gx_device_unsubclass, PageList\");\n        if (child->NupControl)\n            rc_decrement(child->NupControl, \"gx_device_unsubclass, NupControl\");\n        /* We cannot afford to free the child device if its stype is not\n         * dynamic because we can't 'null' the finalise routine, and we\n         * cannot permit the device to be finalised because we have copied\n         * it up one level, not discarded it. (This shouldn't happen! Child\n         * devices are always created with a dynamic stype.) If this ever\n         * happens garbage collecton will eventually clean up the memory.\n         */\n        if (child->stype_is_dynamic) {\n            /* Make sure that nothing will try to follow the device chain,\n             * just security here. */\n            child->parent = NULL;\n            child->child = NULL;\n            /* Make certain the memory will be freed, zap the reference count */\n            child->rc.ref_count = 0;\n            /* We *don't* want to run the finalize routine. This would free\n             * the stype and properly handle the icc_struct and PageList,\n             * but for devices with a custom finalize (eg psdcmyk) it might\n             * also free memory it had allocated, and we're still pointing\n             * at that memory in the parent. The indirection through a\n             * variable is just to get rid of const warnings.\n             */\n            b_std = (gs_memory_struct_type_t *)child->stype;\n            b_std->finalize = NULL;\n            /* Having patched the stype, we need to make sure the memory\n             * manager uses it. It keeps a copy in its own data structure,\n             * and would use that copy, which would mean it would call the\n             * finalize routine that we just patched out.\n             */\n            gs_set_object_type(dev->memory->stable_memory, child, b_std);\n            /* Now (finally) free the child memory */\n            gs_free_object(dev->memory->stable_memory, child, \"gx_device_unsubclass(device)\");\n            /* And the stype for it */\n            gs_free_const_object(dev->memory->non_gc_memory, b_std, \"gs_device_unsubclass(stype)\");\n            child = 0;\n        }\n    }\n    if(child)\n        child->parent = dev;\n    dev->parent = parent;\n\n    /* If this device has a dynamic stype, we wnt to keep using it, but we copied\n     * the stype pointer from the child when we copied the rest of the device. So\n     * we update the stype pointer with the saved pointer to this device's stype.\n     */\n    if (dynamic) {\n        dev->stype = a_std;\n        dev->stype_is_dynamic = 1;\n    } else {\n        dev->stype_is_dynamic = 0;\n    }\n}\nvoid default_subclass_finalize(const gs_memory_t *cmem, void *vptr)\n{\n    gx_device * const dev = (gx_device *)vptr;\n    generic_subclass_data *psubclass_data = (generic_subclass_data *)dev->subclass_data;\n    (void)cmem; /* unused */\n\n    discard(gs_closedevice(dev));\n\n    if (dev->finalize)\n        dev->finalize(dev);\n\n    if (dev->child) {\n        gs_free_object(dev->memory->stable_memory, dev->child, \"free child device memory for subclassing device\");\n    }\n    if (psubclass_data) {\n        gs_free_object(dev->memory->non_gc_memory, psubclass_data, \"gx_epo_finalize(suclass data)\");\n        dev->subclass_data = NULL;\n    }\n    if (dev->stype_is_dynamic)\n        gs_free_const_object(dev->memory->non_gc_memory, dev->stype,\n                             \"default_subclass_finalize\");\n    if (dev->parent)\n        dev->parent->child = dev->child;\n    if (dev->child)\n        dev->child->parent = dev->parent;\n    if (dev->icc_struct)\n        rc_decrement(dev->icc_struct, \"finalize subclass device\");\n    if (dev->PageList)\n        rc_decrement(dev->PageList, \"finalize subclass device\");\n    if (dev->NupControl)\n        rc_decrement(dev->NupControl, \"finalize subclass device\");\n}\n",
    "target": 1,
    "idx": 1048305,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic inline void\ngp_fflush(gp_file *f) {\n    if (f->ops.fflush)\n        (f->ops.fflush)(f);\n}\n\nstatic int\ns_file_write_flush(register stream * s)\n{\n    int result = s_process_write_buf(s, false);\n\n    gp_fflush(s->file);\n    return result;\n}\n\n\n\n\n\nstatic void\nrestore_finalize(gs_ref_memory_t * mem)\n{\n    clump_t *cp;\n    clump_splay_walker sw;\n\n    alloc_close_clump(mem);\n    gs_enable_free((gs_memory_t *) mem, false);\n    for (cp = clump_splay_walk_bwd_init(&sw, mem); cp != 0; cp = clump_splay_walk_bwd(&sw)) {\n        SCAN_CLUMP_OBJECTS(cp)\n            DO_ALL\n            struct_proc_finalize((*finalize)) =\n            pre->o_type->finalize;\n        if (finalize != 0) {\n            if_debug2m('u', (gs_memory_t *)mem, \"[u]restore finalizing %s \"PRI_INTPTR\"\\n\",\n                       struct_type_name_string(pre->o_type),\n                       (intptr_t) (pre + 1));\n            (*finalize) ((gs_memory_t *) mem, pre + 1);\n        }\n        END_OBJECTS_SCAN\n    }\n    gs_enable_free((gs_memory_t *) mem, true);\n}\n\nint\nalloc_restore_all(i_ctx_t *i_ctx_p)\n{\n    /*\n     * Save the memory pointers, since freeing space_local will also\n     * free dmem itself.\n     */\n    gs_ref_memory_t *lmem = idmemory->space_local;\n    gs_ref_memory_t *gmem = idmemory->space_global;\n    gs_ref_memory_t *smem = idmemory->space_system;\n\n    gs_ref_memory_t *mem;\n    int code;\n\n    /* Restore to a state outside any saves. */\n    while (lmem->save_level != 0) {\n        vm_save_t *vmsave = alloc_save_client_data(alloc_save_current(idmemory));\n        if (vmsave->gsave) {\n            gs_grestoreall_for_restore(i_ctx_p->pgs, vmsave->gsave);\n        }\n        vmsave->gsave = 0;\n        code = alloc_restore_step_in(idmemory, lmem->saved);\n\n        if (code < 0)\n            return code;\n    }\n\n    /* Finalize memory. */\n    restore_finalize(lmem);\n    if ((mem = (gs_ref_memory_t *)lmem->stable_memory) != lmem)\n        restore_finalize(mem);\n    if (gmem != lmem && gmem->num_contexts == 1) {\n        restore_finalize(gmem);\n        if ((mem = (gs_ref_memory_t *)gmem->stable_memory) != gmem)\n            restore_finalize(mem);\n    }\n    restore_finalize(smem);\n\n    /* Release resources other than memory, using fake */\n    /* save and memory objects. */\n    {\n        alloc_save_t empty_save;\n\n        empty_save.spaces = idmemory->spaces;\n        empty_save.restore_names = false;\t/* don't bother to release */\n        code = restore_resources(&empty_save, NULL);\n        if (code < 0)\n            return code;\n    }\n\n    /* Finally, release memory. */\n    restore_free(lmem);\n    if ((mem = (gs_ref_memory_t *)lmem->stable_memory) != lmem)\n        restore_free(mem);\n    if (gmem != lmem) {\n        if (!--(gmem->num_contexts)) {\n            restore_free(gmem);\n            if ((mem = (gs_ref_memory_t *)gmem->stable_memory) != gmem)\n                restore_free(mem);\n        }\n    }\n    restore_free(smem);\n    return 0;\n}\n\nint\ngs_main_finit(gs_main_instance * minst, int exit_status, int env_code)\n{\n    i_ctx_t *i_ctx_p = minst->i_ctx_p;\n    gs_dual_memory_t dmem = {0};\n    int exit_code;\n    ref error_object;\n    char *tempnames = NULL;\n    gs_lib_ctx_core_t *core;\n\n    /* NB: need to free gs_name_table\n     */\n\n    /*\n     * Previous versions of this code closed the devices in the\n     * device list here.  Since these devices are now prototypes,\n     * they cannot be opened, so they do not need to be closed;\n     * alloc_restore_all will close dynamically allocated devices.\n     */\n    tempnames = gs_main_tempnames(minst);\n\n    /* by the time we get here, we *must* avoid any random redefinitions of\n     * operators etc, so we push systemdict onto the top of the dict stack.\n     * We do this in C to avoid running into any other re-defininitions in the\n     * Postscript world.\n     */\n    gs_finit_push_systemdict(i_ctx_p);\n\n    /* We have to disable BGPrint before we call interp_reclaim() to prevent the\n     * parent rendering thread initialising for the next page, whilst we are\n     * removing objects it may want to access - for example, the I/O device table.\n     * We also have to mess with the BeginPage/EndPage procs so that we don't\n     * trigger a spurious extra page to be emitted.\n     */\n    if (minst->init_done >= 2) {\n        gs_main_run_string(minst,\n            \"/BGPrint /GetDeviceParam .special_op \\\n            {{ <</BeginPage {pop} /EndPage {pop pop //false } \\\n              /BGPrint false /NumRenderingThreads 0>> setpagedevice} if} if \\\n              serverdict /.jobsavelevel get 0 eq {/quit} {/stop} ifelse \\\n              .systemvar exec\",\n            0 , &exit_code, &error_object);\n    }\n\n    /*\n     * Close the \"main\" device, because it may need to write out\n     * data before destruction. pdfwrite needs so.\n     */\n    if (minst->init_done >= 2) {\n        int code = 0;\n\n        if (idmemory->reclaim != 0) {\n            code = interp_reclaim(&minst->i_ctx_p, avm_global);\n\n            /* We ignore gs_error_VMerror because it comes from gs_vmreclaim()\n            calling context_state_load(), and we don't seem to depend on the\n            missing fields. */\n            if (code == gs_error_VMerror) {\n                if (exit_status == 0 || exit_status == gs_error_Quit) {\n                    exit_status = gs_error_VMerror;\n                }\n            }\n            else if (code < 0) {\n                ref error_name;\n                if (tempnames)\n                    free(tempnames);\n\n                if (gs_errorname(i_ctx_p, code, &error_name) >= 0) {\n                    char err_str[32] = {0};\n                    name_string_ref(imemory, &error_name, &error_name);\n                    memcpy(err_str, error_name.value.const_bytes, r_size(&error_name));\n                    emprintf2(imemory, \"ERROR: %s (%d) reclaiming the memory while the interpreter finalization.\\n\", err_str, code);\n                }\n                else {\n                    emprintf1(imemory, \"UNKNOWN ERROR %d reclaiming the memory while the interpreter finalization.\\n\", code);\n                }\n#ifdef MEMENTO\n                if (Memento_squeezing() && code != gs_error_VMerror ) return gs_error_Fatal;\n#endif\n                return gs_error_Fatal;\n            }\n            i_ctx_p = minst->i_ctx_p; /* interp_reclaim could change it. */\n        }\n\n        if (i_ctx_p->pgs != NULL && i_ctx_p->pgs->device != NULL &&\n            gx_device_is_null(i_ctx_p->pgs->device)) {\n            /* if the job replaced the device with the nulldevice, we we need to grestore\n               away that device, so the block below can properly dispense\n               with the default device.\n             */\n            int code = gs_grestoreall(i_ctx_p->pgs);\n            if (code < 0) {\n                free(tempnames);\n                return_error(gs_error_Fatal);\n            }\n        }\n\n        if (i_ctx_p->pgs != NULL && i_ctx_p->pgs->device != NULL) {\n            gx_device *pdev = i_ctx_p->pgs->device;\n            const char * dname = pdev->dname;\n            gs_gc_root_t dev_root;\n            gs_gc_root_t *dev_root_ptr = &dev_root;\n            /* There is a chance that, during the call to gs_main_run_string(), the interpreter may\n             * decide to call the garbager - the device is in gc memory, and the only reference to it\n             * (in the gstate) has been removed, thus it can be destroyed by the garbager.\n             * Counter-intuitively, adjusting the reference count makes not difference to that.\n             * Register the device as a gc 'root' so it will be implicitely marked by garbager, and\n             * and thus surive until control returns here.\n             */\n            if (gs_register_struct_root(pdev->memory, &dev_root_ptr, (void **)&pdev, \"gs_main_finit\") < 0) {\n                free(tempnames);\n                return_error(gs_error_Fatal);\n            }\n\n            /* make sure device doesn't isn't freed by .uninstalldevice */\n            rc_adjust(pdev, 1, \"gs_main_finit\");\n            /* deactivate the device just before we close it for the last time */\n            gs_main_run_string(minst,\n                /* we need to do the 'quit' so we don't loop for input (double quit) */\n                \".uninstallpagedevice serverdict \\\n                /.jobsavelevel get 0 eq {/quit} {/stop} ifelse .systemvar exec\",\n                0 , &exit_code, &error_object);\n            code = gs_closedevice(pdev);\n            if (code < 0) {\n                ref error_name;\n                if (gs_errorname(i_ctx_p, code, &error_name) >= 0) {\n                    char err_str[32] = {0};\n                    name_string_ref(imemory, &error_name, &error_name);\n                    memcpy(err_str, error_name.value.const_bytes, r_size(&error_name));\n                    emprintf3(imemory, \"ERROR: %s (%d) on closing %s device.\\n\", err_str, code, dname);\n                }\n                else {\n                    emprintf2(imemory, \"UNKNOWN ERROR %d closing %s device.\\n\", code, dname);\n               }\n            }\n            gs_unregister_root(pdev->memory, dev_root_ptr, \"gs_main_finit\");\n            rc_decrement(pdev, \"gs_main_finit\");                /* device might be freed */\n            if (exit_status == 0 || exit_status == gs_error_Quit)\n                exit_status = code;\n        }\n\n      /* Flush stdout and stderr */\n      gs_main_run_string(minst,\n        \"(%stdout) (w) file closefile (%stderr) (w) file closefile \\\n        serverdict /.jobsavelevel get 0 eq {/quit} {/stop} ifelse .systemexec \\\n          systemdict /savedinitialgstate .forceundef\",\n        0 , &exit_code, &error_object);\n    }\n    gp_readline_finit(minst->readline_data);\n    gs_free_object(minst->heap, minst->saved_pages_initial_arg, \"gs_main_finit\");\n    i_ctx_p = minst->i_ctx_p;\t\t/* get current interp context */\n    if (gs_debug_c(':')) {\n        print_resource_usage(minst, &gs_imemory, \"Final\");\n        dmprintf1(minst->heap, \"%% Exiting instance \"PRI_INTPTR\"\\n\", (intptr_t)minst);\n    }\n    /* Do the equivalent of a restore \"past the bottom\". */\n    /* This will release all memory, close all open files, etc. */\n    if (minst->init_done >= 1) {\n        gs_memory_t *mem_raw = i_ctx_p->memory.current->non_gc_memory;\n        i_plugin_holder *h = i_ctx_p->plugin_list;\n\n        dmem = *idmemory;\n        env_code = alloc_restore_all(i_ctx_p);\n        if (env_code < 0)\n            emprintf1(mem_raw,\n                      \"ERROR %d while the final restore. See gs/psi/ierrors.h for code explanation.\\n\",\n                      env_code);\n        i_iodev_finit(&dmem);\n        i_plugin_finit(mem_raw, h);\n    }\n\n    /* clean up redirected stdout */\n    core = minst->heap->gs_lib_ctx->core;\n    if (core->fstdout2\n        && (gp_get_file(core->fstdout2) != core->fstdout)\n        && (gp_get_file(core->fstdout2) != core->fstderr)) {\n        gp_fclose(core->fstdout2);\n        core->fstdout2 = NULL;\n    }\n\n    minst->heap->gs_lib_ctx->core->stdout_is_redirected = 0;\n    minst->heap->gs_lib_ctx->core->stdout_to_stderr = 0;\n    /* remove any temporary files, after ghostscript has closed files */\n    if (tempnames) {\n        char *p = tempnames;\n        while (*p) {\n            gp_unlink(minst->heap, p);\n            p += strlen(p) + 1;\n        }\n        free(tempnames);\n    }\n    gs_lib_finit(exit_status, env_code, minst->heap);\n\n    set_lib_path_length(minst, 0);\n    gs_free_object(minst->heap, minst->lib_path.container.value.refs, \"lib_path array\");\n    if (minst->init_done == 0 && i_ctx_p) {\n        /* This fixes leak if memento forces failure in gs_main_init1(). */\n        dmem = *idmemory;\n    }\n    ialloc_finit(&dmem);\n    return exit_status;\n}\n\nint\ngs_to_exit_with_code(const gs_memory_t *mem, int exit_status, int code)\n{\n    return gs_main_finit(get_minst_from_memory(mem), exit_status, code);\n}\n\nint\ngs_to_exit(const gs_memory_t *mem, int exit_status)\n{\n    return gs_to_exit_with_code(mem, exit_status, 0);\n}\n\nint\npsapi_exit(gs_lib_ctx_t *ctx)\n{\n    if (ctx == NULL)\n        return gs_error_Fatal;\n\n    gs_to_exit(ctx->memory, 0);\n    return 0;\n}\n\nGSDLLEXPORT int GSDLLAPI\ngsapi_exit(void *instance)\n{\n    gs_lib_ctx_t *ctx = (gs_lib_ctx_t *)instance;\n    if (instance == NULL)\n        return gs_error_Fatal;\n    gp_set_debug_mem_ptr(ctx->memory);\n    return psapi_exit(ctx);\n}\n\nint fuzz_gs_device(\n\tconst unsigned char *buf,\n\tsize_t size,\n\tint color_scheme,\n\tconst char *device_target\n)\n{\n\tint ret;\n\tvoid *gs = NULL;\n\tchar color_space[50];\n\tchar gs_device[50];\n\t/*\n\t * We are expecting color_scheme to be in the [0:62] interval.\n\t * This corresponds to the color schemes defined here:\n\t * https://github.com/ArtifexSoftware/ghostpdl/blob/8c97d5adce0040ac38a1fb4d7954499c65f582ff/cups/libs/cups/raster.h#L102\n\t */\n\tsprintf(color_space, \"-dcupsColorSpace=%d\", color_scheme);\n\n\tsprintf(gs_device, \"-sDEVICE=%s\", device_target);\n\t/* Mostly stolen from cups-filters gstoraster. */\n\tchar *args[] = {\n\t\t\"gs\",\n\t\t\"-K1048576\",\n\t\t\"-r200x200\",\n\t\t\"-sBandListStorage=memory\",\n\t\t\"-dMaxBitmap=0\",\n\t\t\"-dBufferSpace=450k\",\n\t\t\"-dMediaPosition=1\",\n\t\tcolor_space,\n\t\t\"-dQUIET\",\n\t\t\"-dSAFER\",\n\t\t\"-dNOPAUSE\",\n\t\t\"-dBATCH\",\n\t\t\"-dNOINTERPOLATE\",\n\t\t\"-dNOMEDIAATTRS\",\n\t\t\"-sstdout=%%stderr\",\n\t\t\"-sOutputFile=/dev/null\",\n\t\tgs_device,\n\t\t\"-_\",\n\t};\n\tint argc = sizeof(args) / sizeof(args[0]);\n\n\t/* Stash buffers globally, for gs_stdin(). */\n\tg_data = buf;\n\tg_size = size;\n\n\tret = gsapi_new_instance(&gs, NULL);\n\tif (ret < 0) {\n\t\tfprintf(stderr, \"gsapi_new_instance: error %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tgsapi_set_stdio(gs, gs_stdin, gs_stdnull, gs_stdnull);\n\tret = gsapi_set_arg_encoding(gs, GS_ARG_ENCODING_UTF8);\n\tif (ret < 0) {\n\t\tfprintf(stderr, \"gsapi_set_arg_encoding: error %d\\n\", ret);\n\t\tgsapi_delete_instance(gs);\n\t\treturn ret;\n\t}\n\n\tret = gsapi_init_with_args(gs, argc, args);\n\tif (ret && ret != gs_error_Quit)\n\t\t/* Just keep going, to cleanup. */\n\t\tfprintf(stderr, \"gsapi_init_with_args: error %d\\n\", ret);\n\n\tret = gsapi_exit(gs);\n\tif (ret < 0 && ret != gs_error_Quit) {\n\t\tfprintf(stderr, \"gsapi_exit: error %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tgsapi_delete_instance(gs);\n\n\treturn 0;\n}\n\n\n// target function\nint\npdf_write_embedded_font(gx_device_pdf *pdev, pdf_base_font_t *pbfont, font_type FontType,\n                        gs_int_rect *FontBBox, gs_id rid, cos_dict_t **ppcd)\n{\n    bool do_subset = pdf_do_subset_font(pdev, pbfont, rid);\n    gs_font_base *out_font =\n        (do_subset || pbfont->complete == NULL ? pbfont->copied : pbfont->complete);\n    gs_const_string fnstr;\n    pdf_data_writer_t writer;\n    byte digest[6] = {0,0,0,0,0,0};\n    int code = 0;\n    int options=0;\n\n    if (pbfont->written)\n        return 0;\t\t/* already written */\n    code = copied_order_font((gs_font *)out_font);\n    if (code < 0)\n        return code;\n    /* Since we now always ASCIIHex encode the eexec encrypted portion of a\n     * Type 1 font, such a font cannot contain any binary data, if its not being\n     * compressed then there is no reason to ASCII encode it (which will happen\n     * we set DATA_STREAM_BINARY and the device does not permit binary output)\n     * NB if HaveCFF is true then we convert type 1 to CFF which is a binary\n     * format, so we still need to set DATA_STREAM_BINARY.\n     */\n    if (pdev->CompressFonts)\n        options = DATA_STREAM_BINARY | DATA_STREAM_COMPRESS;\n    else\n         if (FontType != ft_encrypted || pdev->HaveCFF)\n            options = DATA_STREAM_BINARY;\n    /* Don't set DATA_STREAM_ENCRYPT since we write to a temporary file.\n     * See comment in pdf_begin_encrypt.\n     */\n    code = pdf_begin_data_stream(pdev, &writer, options, 0);\n    if (code < 0)\n        return code;\n    if (pdev->PDFA != 0) {\n        stream *s = s_MD5C_make_stream(pdev->pdf_memory, writer.binary.strm);\n\n        if (s == NULL)\n            return_error(gs_error_VMerror);\n        writer.binary.strm = s;\n    }\n    if (pdev->CompatibilityLevel == 1.2 &&\n        !do_subset && !pbfont->is_standard ) {\n        /*\n         * Due to a bug in Acrobat Reader 3, we need to generate\n         * unique font names, except base 14 fonts being not embedded.\n         * To recognize base 14 fonts here we used the knowledge\n         * that pbfont->is_standard is true for base 14 fonts only.\n         * Note that subsetted fonts already have an unique name\n         * due to subset prefix.\n         */\n         int code = pdf_adjust_font_name(pdev, writer.pres->object->id, pbfont);\n         if (code < 0)\n            return code;\n    }\n    fnstr.data = pbfont->font_name.data;\n    fnstr.size = pbfont->font_name.size;\n    /* Now write the font (or subset). */\n    switch (FontType) {\n\n    case ft_composite:\n        /* Nothing to embed -- the descendant fonts do it all. */\n        code = 0;\n        break;\n\n    case ft_encrypted2:\n        if (!pdev->HaveCFF) {\n            /* Must convert to Type 1 charstrings. */\n            return_error(gs_error_unregistered); /* Not implemented yet. */\n        }\n    case ft_encrypted:\n        if (pdev->HavePDFWidths) {\n            code = copied_drop_extension_glyphs((gs_font *)out_font);\n            if (code < 0)\n                return code;\n        }\n        if (!pdev->HaveCFF) {\n            /* Write the type 1 font with no converting to CFF. */\n            int lengths[3];\n\n            if (pbfont->do_subset != DO_SUBSET_NO)\n                code = psf_write_type1_font(writer.binary.strm,\n                                (gs_font_type1 *)out_font,\n                                WRITE_TYPE1_WITH_LENIV | WRITE_TYPE1_EEXEC |\n                                WRITE_TYPE1_EEXEC_PAD | WRITE_TYPE1_ASCIIHEX,\n                                NULL, 0, &fnstr, lengths);\n            else\n                code = psf_write_type1_font(writer.binary.strm,\n                                (gs_font_type1 *)out_font,\n                                WRITE_TYPE1_WITH_LENIV | WRITE_TYPE1_EEXEC |\n                                WRITE_TYPE1_EEXEC_PAD | WRITE_TYPE1_ASCIIHEX | WRITE_TYPE1_XUID,\n                                NULL, 0, &fnstr, lengths);\n            if (lengths[0] > 0) {\n                if (code < 0)\n                    goto finish;\n                code = cos_dict_put_c_key_int((cos_dict_t *)writer.pres->object,\n                            \"/Length1\", lengths[0]);\n            }\n            if (lengths[1] > 0) {\n                if (code < 0)\n                    goto finish;\n                code = cos_dict_put_c_key_int((cos_dict_t *)writer.pres->object,\n                            \"/Length2\", lengths[1]);\n                if (code < 0)\n                    return code;\n                code = cos_dict_put_c_key_int((cos_dict_t *)writer.pres->object,\n                            \"/Length3\", lengths[2]);\n            }\n        } else {\n            /*\n             * Since we only support PDF 1.2 and later, always write Type 1\n             * fonts as Type1C (Type 2).  Acrobat Reader apparently doesn't\n             * accept CFF fonts with Type 1 CharStrings, so we need to convert\n             * them.  Also remove lenIV, so Type 2 fonts will compress better.\n             */\n#define TYPE2_OPTIONS (WRITE_TYPE2_NO_LENIV | WRITE_TYPE2_CHARSTRINGS)\n            code = cos_dict_put_string_copy((cos_dict_t *)writer.pres->object, \"/Subtype\", \"/Type1C\");\n            if (code < 0)\n                return code;\n            code = psf_write_type2_font(writer.binary.strm,\n                                        (gs_font_type1 *)out_font,\n                                        TYPE2_OPTIONS |\n                            (pdev->CompatibilityLevel < 1.3 ? WRITE_TYPE2_AR3 : 0) |\n                            (pbfont->do_subset == DO_SUBSET_NO ? WRITE_TYPE2_XUID : 0),\n                                        NULL, 0, &fnstr, FontBBox);\n        }\n        goto finish;\n\n    case ft_TrueType: {\n        gs_font_type42 *const pfont = (gs_font_type42 *)out_font;\n#define TRUETYPE_OPTIONS (WRITE_TRUETYPE_NAME | WRITE_TRUETYPE_HVMTX)\n        /* Acrobat Reader 3 doesn't handle cmap format 6 correctly. */\n        const int options = TRUETYPE_OPTIONS |\n            (pdev->PDFA != 0 ? WRITE_TRUETYPE_UNICODE_CMAP : 0) |\n            (pdev->CompatibilityLevel <= 1.2 ?\n             WRITE_TRUETYPE_NO_TRIMMED_TABLE : 0) |\n            /* Generate a cmap only for incrementally downloaded fonts\n               and for subsetted fonts. */\n            (pfont->data.numGlyphs != pfont->data.trueNumGlyphs ||\n             pbfont->do_subset == DO_SUBSET_YES ?\n             WRITE_TRUETYPE_CMAP : 0);\n        stream poss;\n\n        if (pdev->HavePDFWidths) {\n            code = copied_drop_extension_glyphs((gs_font *)out_font);\n            if (code < 0)\n                return code;\n        }\n        s_init(&poss, pdev->memory);\n        swrite_position_only(&poss);\n        code = psf_write_truetype_font(&poss, pfont, options, NULL, 0, &fnstr);\n        if (code < 0)\n            return code;\n        code = cos_dict_put_c_key_int((cos_dict_t *)writer.pres->object, \"/Length1\", stell(&poss));\n        if (code < 0)\n            return code;\n        code = psf_write_truetype_font(writer.binary.strm, pfont,\n                                       options, NULL, 0, &fnstr);\n        goto finish;\n    }\n\n    case ft_CID_encrypted:\n        code = cos_dict_put_string_copy((cos_dict_t *)writer.pres->object, \"/Subtype\", \"/CIDFontType0C\");\n        if (code < 0)\n            return code;\n        code = psf_write_cid0_font(writer.binary.strm,\n                                   (gs_font_cid0 *)out_font, TYPE2_OPTIONS,\n                                   NULL, 0, &fnstr);\n        goto finish;\n\n    case ft_CID_TrueType:\n        /* CIDFontType 2 fonts don't use cmap, name, OS/2, or post. */\n#define CID2_OPTIONS WRITE_TRUETYPE_HVMTX\n        code = psf_write_cid2_font(writer.binary.strm,\n                                   (gs_font_cid2 *)out_font,\n                                   CID2_OPTIONS, NULL, 0, &fnstr);\n    finish:\n        if (pdev->PDFA != 0) {\n            sflush(writer.binary.strm);\n            s_MD5C_get_digest(writer.binary.strm, digest, sizeof(digest));\n        }\n        *ppcd = (cos_dict_t *)writer.pres->object;\n        if (code < 0) {\n            pdf_end_fontfile(pdev, &writer);\n            pdf_obj_mark_unused(pdev, writer.pres->object->id);\n            return code;\n        }\n        code = pdf_end_fontfile(pdev, &writer);\n        break;\n\n    default:\n        code = gs_note_error(gs_error_rangecheck);\n    }\n\n    pbfont->written = true;\n    return code;\n}\n",
    "target": 1,
    "idx": 1051745,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic int\ndxf_objects_read (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  char name[80];\n  Dxf_Pair *pair = dxf_read_pair (dat);\n  while (pair != NULL)\n    {\n      while (pair != NULL && pair->code == 0 && pair->value.s)\n        {\n          strncpy (name, pair->value.s, 79);\n          name[79] = '\\0';\n          object_alias (name);\n          if (is_dwg_object (name))\n            {\n              char *dxfname = strdup (pair->value.s);\n              dxf_free_pair (pair);\n              pair = new_object (name, dxfname, dat, dwg, 0, NULL);\n              if (!pair)\n                return DWG_ERR_INVALIDDWG;\n            }\n          else\n            {\n              DXF_RETURN_ENDSEC (0);\n              LOG_WARN (\"Unhandled 0 %s (%s)\", name, \"objects\");\n              dxf_free_pair (pair);\n              pair = dxf_read_pair (dat);\n              DXF_CHECK_EOF;\n            }\n        }\n      dxf_free_pair (pair);\n      pair = dxf_read_pair (dat);\n      DXF_CHECK_EOF;\n    }\n  dxf_free_pair (pair);\n  return 0;\n}\n\nEXPORT int\ndwg_read_dxf (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  // const int minimal = dwg->opts & DWG_OPTS_MINIMAL;\n  Dxf_Pair *pair = NULL;\n  int error = 0;\n\n  loglevel = dwg->opts & DWG_OPTS_LOGLEVEL;\n  if (!dat->chain && dat->fh)\n    {\n      error = dat_read_stream (dat, dat->fh);\n      if (error >= DWG_ERR_CRITICAL)\n        return error;\n      if (dat->size >= 22 &&\n          !memcmp (dat->chain, \"AutoCAD Binary DXF\",\n                   sizeof (\"AutoCAD Binary DXF\") - 1))\n        {\n          dat->opts |= DWG_OPTS_DXFB;\n          dat->byte = 22;\n        }\n    }\n  if (dat->size < 256)\n    {\n      LOG_ERROR (\"DXF input too small, %lu byte.\\n\", dat->size);\n      return DWG_ERR_IOERROR;\n    }\n  /* Fail early on DWG */\n  if (!memcmp (dat->chain, \"AC10\", 4) ||\n      !memcmp (dat->chain, \"AC1.\", 4) ||\n      !memcmp (dat->chain, \"AC2.10\", 4) ||\n      !memcmp (dat->chain, \"MC0.0\", 4))\n    {\n      LOG_ERROR (\"This is a DWG, not a DXF\\n\");\n      return DWG_ERR_INVALIDDWG;\n    }\n  dat->opts |= DWG_OPTS_INDXF;\n  dwg->opts |= DWG_OPTS_INDXF;\n  //num_dxf_objs = 0;\n  //size_dxf_objs = 1000;\n  //dxf_objs = (Dxf_Objs *)malloc (1000 * sizeof (Dxf_Objs));\n  if (!dwg->object_map)\n    dwg->object_map = hash_new (dat->size / 1000);\n  // cannot rely on ref->obj during realloc's\n  dwg->dirty_refs = 1;\n\n  header_hdls = new_array_hdls (16);\n  eed_hdls = new_array_hdls (16);\n  obj_hdls = new_array_hdls (16);\n\n  // start with the BLOCK_HEADER at objid 0\n  if (!dwg->num_objects)\n    {\n      Dwg_Object *obj;\n      Dwg_Object_BLOCK_HEADER *_obj;\n      char *dxfname = strdup ((char *)\"BLOCK_HEADER\");\n      NEW_OBJECT (dwg, obj);\n      ADD_OBJECT (BLOCK_HEADER);\n      // dwg->header.version probably here still unknown. <r2000: 0x17\n      // later fixed up when reading $ACADVER and the BLOCK_HEADER.name\n      _obj->name = dwg_add_u8_input (dwg, \"*Model_Space\");\n      _obj->is_xref_ref = 1;\n      obj->tio.object->is_xdic_missing = 1;\n      dwg_add_handle (&obj->handle, 0, 0x1F, obj);\n      obj->tio.object->ownerhandle = dwg_add_handleref (dwg, 4, 1, NULL);\n    }\n\n  while (dat->byte < dat->size)\n    {\n      pair = dxf_read_pair (dat);\n      DXF_BREAK_EOF;\n      pair = dxf_expect_code (dat, pair, 0);\n      DXF_BREAK_EOF;\n      if (pair->type == DWG_VT_STRING && strEQc (pair->value.s, \"SECTION\"))\n        {\n          dxf_free_pair (pair);\n          pair = dxf_read_pair (dat);\n          DXF_BREAK_EOF;\n          pair = dxf_expect_code (dat, pair, 2);\n          DXF_BREAK_EOF;\n          if (!pair->value.s)\n            {\n              LOG_ERROR (\"Expected SECTION string code 2, got code %d\",\n                         pair->code);\n              dxf_free_pair (pair);\n              pair = NULL;\n              break;\n            }\n          else if (strEQc (pair->value.s, \"HEADER\"))\n            {\n              dxf_free_pair (pair);\n              pair = NULL;\n              error = dxf_header_read (dat, dwg);\n              if (error > DWG_ERR_CRITICAL)\n                goto error;\n              dxf_fixup_header (dwg);\n              // skip minimal DXF\n              /*\n              if (!dwg->header_vars.DIMPOST) // T in all versions\n                {\n                  LOG_ERROR (\"Unsupported minimal DXF\");\n                  return DWG_ERR_INVALIDDWG;\n                }\n              */\n            }\n          else if (strEQc (pair->value.s, \"CLASSES\"))\n            {\n              dxf_free_pair (pair);\n              pair = NULL;\n              error = dxf_classes_read (dat, dwg);\n              if (error > DWG_ERR_CRITICAL)\n                return error;\n            }\n          else if (strEQc (pair->value.s, \"TABLES\"))\n            {\n              BITCODE_H hdl;\n              dxf_free_pair (pair);\n              pair = NULL;\n              error = dxf_tables_read (dat, dwg);\n              if (error > DWG_ERR_CRITICAL)\n                goto error;\n\n              resolve_postponed_header_refs (dwg);\n              resolve_postponed_eed_refs (dwg);\n\n              // should not happen\n              if (!dwg->header_vars.LTYPE_BYLAYER\n                  && (hdl = dwg_find_tablehandle_silent (\n                          dwg, (char *)\"ByLayer\", \"LTYPE\")))\n                dwg->header_vars.LTYPE_BYLAYER\n                    = dwg_add_handleref (dwg, 5, hdl->handleref.value, NULL);\n              // should not happen\n              if (!dwg->header_vars.LTYPE_BYBLOCK\n                  && (hdl = dwg_find_tablehandle_silent (\n                          dwg, (char *)\"ByBlock\", \"LTYPE\")))\n                dwg->header_vars.LTYPE_BYBLOCK\n                    = dwg_add_handleref (dwg, 5, hdl->handleref.value, NULL);\n              // but this is needed\n              if (!dwg->header_vars.LTYPE_CONTINUOUS\n                  && (hdl = dwg_find_tablehandle_silent (\n                          dwg, (char *)\"Continuous\", \"LTYPE\")))\n                dwg->header_vars.LTYPE_CONTINUOUS\n                    = dwg_add_handleref (dwg, 5, hdl->handleref.value, NULL);\n            }\n          else if (strEQc (pair->value.s, \"BLOCKS\"))\n            {\n              BITCODE_H hdl;\n              dxf_free_pair (pair);\n              pair = NULL;\n              error = dxf_blocks_read (dat, dwg);\n              if (error > DWG_ERR_CRITICAL)\n                goto error;\n\n              // resolve_postponed_header_refs (dwg);\n              if (!dwg->header_vars.BLOCK_RECORD_PSPACE\n                  && (hdl = dwg_find_tablehandle_silent (\n                          dwg, (char *)\"*Paper_Space\", \"BLOCK\")))\n                dwg->header_vars.BLOCK_RECORD_PSPACE\n                    = dwg_add_handleref (dwg, 5, hdl->handleref.value, NULL);\n              if (!dwg->header_vars.BLOCK_RECORD_MSPACE\n                  && (hdl = dwg_find_tablehandle_silent (\n                          dwg, (char *)\"*Model_Space\", \"BLOCK\")))\n                dwg->header_vars.BLOCK_RECORD_MSPACE\n                    = dwg_add_handleref (dwg, 5, hdl->handleref.value, NULL);\n            }\n          else if (strEQc (pair->value.s, \"ENTITIES\"))\n            {\n              dxf_free_pair (pair);\n              pair = NULL;\n              error = dxf_entities_read (dat, dwg);\n              if (error > DWG_ERR_CRITICAL)\n                goto error;\n            }\n          else if (strEQc (pair->value.s, \"OBJECTS\"))\n            {\n              dxf_free_pair (pair);\n              pair = NULL;\n              error = dxf_objects_read (dat, dwg);\n              if (error > DWG_ERR_CRITICAL)\n                goto error;\n              resolve_header_dicts (dwg);\n            }\n          else if (strEQc (pair->value.s, \"THUMBNAILIMAGE\"))\n            {\n              dxf_free_pair (pair);\n              pair = NULL;\n              error = dxf_thumbnail_read (dat, dwg);\n            }\n          else if (strEQc (pair->value.s, \"ACDSDATA\"))\n            {\n              dxf_free_pair (pair);\n              pair = NULL;\n              error = dxf_acds_read (dat, dwg);\n            }\n          else // if (strEQc (pair->value.s, \"\"))\n            {\n              LOG_WARN (\"SECTION %s ignored for now\", pair->value.s);\n              dxf_free_pair (pair);\n              pair = NULL;\n              error = dxf_unknownsection_read (dat, dwg);\n            }\n        }\n      else\n        {\n          LOG_ERROR (\"Expected string SECTION\");\n          dxf_free_pair (pair);\n        }\n    }\n  if (pair != NULL && pair->code == 0 &&\n      pair->value.s != NULL && strEQc (pair->value.s, \"EOF\"))\n    ;\n  else if (dat->byte >= dat->size || (pair == NULL))\n    error |= DWG_ERR_IOERROR;\n  resolve_postponed_header_refs (dwg);\n  resolve_postponed_object_refs (dwg);\n  LOG_HANDLE (\"Resolving pointers from ObjectRef vector:\\n\");\n  dwg_resolve_objectrefs_silent (dwg);\n  free_array_hdls (header_hdls);\n  free_array_hdls (eed_hdls);\n  free_array_hdls (obj_hdls);\n  if (dwg->header.version <= R_2000 && dwg->header.from_version > R_2000)\n    dwg_fixup_BLOCKS_entities (dwg);\n  LOG_TRACE (\"import from DXF\\n\");\n  if (error > DWG_ERR_CRITICAL)\n    return error;\n  else\n    return dwg->num_objects ? 1 : 0;\n\nerror:\n  dwg->dirty_refs = 0;\n  free_array_hdls (header_hdls);\n  free_array_hdls (eed_hdls);\n  free_array_hdls (obj_hdls);\n  return error;\n}\n\n\n// target function\nstatic int\ndxf_objects_read (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  char name[80];\n  Dxf_Pair *pair = dxf_read_pair (dat);\n  while (pair != NULL)\n    {\n      while (pair != NULL && pair->code == 0 && pair->value.s)\n        {\n          strncpy (name, pair->value.s, 79);\n          name[79] = '\\0';\n          object_alias (name);\n          if (is_dwg_object (name))\n            {\n              char *dxfname = strdup (pair->value.s);\n              dxf_free_pair (pair);\n              pair = new_object (name, dxfname, dat, dwg, 0, NULL);\n              if (!pair)\n                return DWG_ERR_INVALIDDWG;\n            }\n          else\n            {\n              DXF_RETURN_ENDSEC (0);\n              LOG_WARN (\"Unhandled 0 %s (%s)\", name, \"objects\");\n              dxf_free_pair (pair);\n            }\n        }\n      dxf_free_pair (pair);\n      pair = dxf_read_pair (dat);\n      DXF_CHECK_EOF;\n    }\n  dxf_free_pair (pair);\n  return 0;\n}\n",
    "target": 1,
    "idx": 1032275,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nuint32_t\nmrb_byte_hash_step(const uint8_t *s, mrb_int len, uint32_t hval)\n{\n  const uint8_t *send = s + len;\n\n  /*\n   * FNV-1 hash each octet in the buffer\n   */\n  while (s < send) {\n    /* multiply by the 32 bit FNV magic prime mod 2^32 */\n#if defined(NO_FNV_GCC_OPTIMIZATION)\n    hval *= FNV_32_PRIME;\n#else\n    hval += (hval<<1) + (hval<<4) + (hval<<7) + (hval<<8) + (hval<<24);\n#endif\n\n    /* xor the bottom with the current octet */\n    hval ^= (uint32_t)*s++;\n  }\n\n  /* return our new hash value */\n  return hval;\n}\n\nuint32_t\nmrb_byte_hash(const uint8_t *s, mrb_int len)\n{\n  return mrb_byte_hash_step(s, len, FNV1_32_INIT);\n}\n\nuint32_t\nmrb_str_hash(mrb_state *mrb, mrb_value str)\n{\n  struct RString *s = mrb_str_ptr(str);\n  return mrb_byte_hash((uint8_t*)RSTR_PTR(s), RSTR_LEN(s));\n}\n\nstatic mrb_value\nmrb_str_hash_m(mrb_state *mrb, mrb_value self)\n{\n  mrb_int key = mrb_str_hash(mrb, self);\n  return mrb_int_value(mrb, key);\n}\n\nMRB_API mrb_value\nmrb_vm_run(mrb_state *mrb, const struct RProc *proc, mrb_value self, mrb_int stack_keep)\n{\n  const mrb_irep *irep = proc->body.irep;\n  mrb_value result;\n  struct mrb_context *c = mrb->c;\n  ptrdiff_t cioff = c->ci - c->cibase;\n  mrb_int nregs = irep->nregs;\n\n  if (!c->stbase) {\n    stack_init(mrb);\n  }\n  if (stack_keep > nregs)\n    nregs = stack_keep;\n  else {\n    struct REnv *e = CI_ENV(mrb->c->ci);\n    if (stack_keep == 0 || (e && irep->nlocals < MRB_ENV_LEN(e))) {\n      ci_env_set(mrb->c->ci, NULL);\n      mrb_env_unshare(mrb, e, FALSE);\n    }\n  }\n  stack_extend(mrb, nregs);\n  stack_clear(c->ci->stack + stack_keep, nregs - stack_keep);\n  c->ci->stack[0] = self;\n  result = mrb_vm_exec(mrb, proc, irep->iseq);\n  if (mrb->c != c) {\n    if (mrb->c->fib) {\n      mrb_write_barrier(mrb, (struct RBasic*)mrb->c->fib);\n    }\n    mrb->c = c;\n  }\n  else if (c->ci - c->cibase > cioff) {\n    c->ci = c->cibase + cioff;\n  }\n  return result;\n}\n\nstatic mrb_value\nmrb_run(mrb_state *mrb, const struct RProc *proc, mrb_value self)\n{\n  return mrb_vm_run(mrb, proc, self, ci_bidx(mrb->c->ci) + 1);\n}\n\nMRB_API mrb_value\nmrb_funcall_with_block(mrb_state *mrb, mrb_value self, mrb_sym mid, mrb_int argc, const mrb_value *argv, mrb_value blk)\n{\n  mrb_value val;\n  int ai = mrb_gc_arena_save(mrb);\n\n  if (!mrb->jmp) {\n    struct mrb_jmpbuf c_jmp;\n    ptrdiff_t nth_ci = mrb->c->ci - mrb->c->cibase;\n\n    MRB_TRY(&c_jmp) {\n      mrb->jmp = &c_jmp;\n      /* recursive call */\n      val = mrb_funcall_with_block(mrb, self, mid, argc, argv, blk);\n      mrb->jmp = NULL;\n    }\n    MRB_CATCH(&c_jmp) { /* error */\n      while (nth_ci < (mrb->c->ci - mrb->c->cibase)) {\n        cipop(mrb);\n      }\n      mrb->jmp = 0;\n      val = mrb_obj_value(mrb->exc);\n    }\n    MRB_END_EXC(&c_jmp);\n    mrb->jmp = NULL;\n  }\n  else {\n    mrb_method_t m;\n    mrb_callinfo *ci = mrb->c->ci;\n    mrb_int n = mrb_ci_nregs(ci);\n\n    if (!mrb->c->stbase) {\n      stack_init(mrb);\n    }\n    if (ci - mrb->c->cibase > MRB_CALL_LEVEL_MAX) {\n      mrb_exc_raise(mrb, mrb_obj_value(mrb->stack_err));\n    }\n    blk = ensure_block(mrb, blk);\n    ci = cipush(mrb, n, CINFO_DIRECT, NULL, NULL, BLK_PTR(blk), 0, 0);\n    funcall_args_capture(mrb, 0, argc, argv, blk, ci);\n    ci->u.target_class = mrb_class(mrb, self);\n    m = mrb_vm_find_method(mrb, ci->u.target_class, &ci->u.target_class, mid);\n    if (MRB_METHOD_UNDEF_P(m)) {\n      m = prepare_missing(mrb, ci, self, mid, mrb_nil_value(), FALSE);\n    }\n    else {\n      ci->mid = mid;\n    }\n    ci->proc = MRB_METHOD_PROC_P(m) ? MRB_METHOD_PROC(m) : NULL;\n\n    if (MRB_METHOD_CFUNC_P(m)) {\n      ci->stack[0] = self;\n      val = MRB_METHOD_CFUNC(m)(mrb, self);\n      cipop(mrb);\n    }\n    else {\n      ci->cci = CINFO_SKIP;\n      val = mrb_run(mrb, ci->proc, self);\n    }\n  }\n  mrb_gc_arena_restore(mrb, ai);\n  mrb_gc_protect(mrb, val);\n  return val;\n}\n\nMRB_API mrb_value\nmrb_funcall_argv(mrb_state *mrb, mrb_value self, mrb_sym mid, mrb_int argc, const mrb_value *argv)\n{\n  return mrb_funcall_with_block(mrb, self, mid, argc, argv, mrb_nil_value());\n}\n\n\n\nstatic void\nib_it_init(mrb_state *mrb, index_buckets_iter *it, struct RHash *h, mrb_value key)\n{\n  it->h = h;\n  it->bit = ib_bit(h);\n  it->mask = ib_bit_to_capa(it->bit) - 1;\n  it->pos = ib_it_pos_for(it, obj_hash_code(mrb, key, h));\n  it->step = 0;\n}\n\nstatic void\nht_set_without_ib_adjustment(mrb_state *mrb, struct RHash *h,\n                             mrb_value key, mrb_value val)\n{\n  mrb_assert(ht_size(h) < ib_bit_to_capa(ib_bit(h)));\n  ib_cycle_by_key(mrb, h, key, it, {\n    if (ib_it_active_p(it)) {\n      if (!obj_eql(mrb, key, ib_it_entry(it)->key, h)) continue;\n      ib_it_entry(it)->val = val;\n    }\n    else {\n      uint32_t ea_n_used = ht_ea_n_used(h);\n      if (ea_n_used == H_MAX_SIZE) {\n        mrb_assert(ht_size(h) == ea_n_used);\n        mrb_raise(mrb, E_ARGUMENT_ERROR, \"hash too big\");\n      }\n      if (ea_n_used == ht_ea_capa(h)) ht_adjust_ea(mrb, h, ea_n_used, EA_MAX_CAPA);\n      ib_it_set(it, ea_n_used);\n      ea_set(ht_ea(h), ea_n_used, key, val);\n      ht_inc_size(h);\n      ht_set_ea_n_used(h, ++ea_n_used);\n    }\n    return;\n  });\n}\n\nstatic void\nht_set(mrb_state *mrb, struct RHash *h, mrb_value key, mrb_value val)\n{\n  uint32_t size = ht_size(h);\n  uint32_t ib_bit_width = ib_bit(h), ib_capa = ib_bit_to_capa(ib_bit_width);\n  if (ib_upper_bound_for(ib_capa) <= size) {\n    if (size != ht_ea_n_used(h)) ea_compress(ht_ea(h), ht_ea_n_used(h));\n    ht_init(mrb, h, size, ht_ea(h), ht_ea_capa(h), h_ht(h), ++ib_bit_width);\n  }\n  else if (size != ht_ea_n_used(h)) {\n    if (ib_capa - EA_N_RESERVED_INDICES <= ht_ea_n_used(h)) goto compress;\n    if (ht_ea_capa(h) == ht_ea_n_used(h)) {\n      if (size <= AR_MAX_SIZE) {ht_set_as_ar(mrb, h, key, val); return;}\n      if (ea_next_capa_for(size, EA_MAX_CAPA) <= ht_ea_capa(h)) {\n       compress:\n        ea_compress(ht_ea(h), ht_ea_n_used(h));\n        ht_adjust_ea(mrb, h, size, ht_ea_capa(h));\n        ht_init(mrb, h, size, ht_ea(h), ht_ea_capa(h), h_ht(h), ib_bit_width);\n      }\n    }\n  }\n  ht_set_without_ib_adjustment(mrb, h, key, val);\n}\n\nstatic void\nar_set(mrb_state *mrb, struct RHash *h, mrb_value key, mrb_value val)\n{\n  uint32_t size = ar_size(h);\n  hash_entry *entry;\n  if ((entry = ea_get_by_key(mrb, ar_ea(h), size, key, h))) {\n    entry->val = val;\n  }\n  else {\n    uint32_t ea_capa = ar_ea_capa(h), ea_n_used = ar_ea_n_used(h);\n    if (ea_capa == ea_n_used) {\n      if (size == ea_n_used) {\n        if (size == AR_MAX_SIZE) {\n          ht_init(mrb, h, size, ar_ea(h), ea_capa, NULL, IB_INIT_BIT);\n          ht_set(mrb, h, key, val);\n          return;\n        }\n        else {\n          ar_adjust_ea(mrb, h, size, AR_MAX_SIZE);\n        }\n      }\n      else {\n        ar_compress(mrb, h);\n        ea_n_used = size;\n      }\n    }\n    ea_set(ar_ea(h), ea_n_used, key, val);\n    ar_set_size(h, ++size);\n    ar_set_ea_n_used(h, ++ea_n_used);\n  }\n}\n\nstatic void\nh_set(mrb_state *mrb, struct RHash *h, mrb_value key, mrb_value val)\n{\n  (h_ar_p(h) ? ar_set : ht_set)(mrb, h, key, val);\n}\n\nMRB_API void\nmrb_hash_set(mrb_state *mrb, mrb_value hash, mrb_value key, mrb_value val)\n{\n  hash_modify(mrb, hash);\n  key = h_key_for(mrb, key);\n  h_set(mrb, mrb_hash_ptr(hash), key, val);\n  mrb_field_write_barrier_value(mrb, mrb_basic_ptr(hash), key);\n  mrb_field_write_barrier_value(mrb, mrb_basic_ptr(hash), val);\n}\n\nstatic mrb_value\nmrb_hash_aset(mrb_state *mrb, mrb_value self)\n{\n  mrb_value key, val;\n\n  mrb_get_args(mrb, \"oo\", &key, &val);\n  mrb_hash_set(mrb, self, key, val);\n  return val;\n}\n\nMRB_API mrb_value\nmrb_vm_run(mrb_state *mrb, const struct RProc *proc, mrb_value self, mrb_int stack_keep)\n{\n  const mrb_irep *irep = proc->body.irep;\n  mrb_value result;\n  struct mrb_context *c = mrb->c;\n  ptrdiff_t cioff = c->ci - c->cibase;\n  mrb_int nregs = irep->nregs;\n\n  if (!c->stbase) {\n    stack_init(mrb);\n  }\n  if (stack_keep > nregs)\n    nregs = stack_keep;\n  else {\n    struct REnv *e = CI_ENV(mrb->c->ci);\n    if (stack_keep == 0 || (e && irep->nlocals < MRB_ENV_LEN(e))) {\n      ci_env_set(mrb->c->ci, NULL);\n      mrb_env_unshare(mrb, e, FALSE);\n    }\n  }\n  stack_extend(mrb, nregs);\n  stack_clear(c->ci->stack + stack_keep, nregs - stack_keep);\n  c->ci->stack[0] = self;\n  result = mrb_vm_exec(mrb, proc, irep->iseq);\n  if (mrb->c != c) {\n    if (mrb->c->fib) {\n      mrb_write_barrier(mrb, (struct RBasic*)mrb->c->fib);\n    }\n    mrb->c = c;\n  }\n  else if (c->ci - c->cibase > cioff) {\n    c->ci = c->cibase + cioff;\n  }\n  return result;\n}\n\nMRB_API mrb_value\nmrb_top_run(mrb_state *mrb, const struct RProc *proc, mrb_value self, mrb_int stack_keep)\n{\n  if (mrb->c->cibase && mrb->c->ci > mrb->c->cibase) {\n    cipush(mrb, 0, CINFO_SKIP, mrb->object_class, NULL, NULL, 0, 0);\n  }\n  return mrb_vm_run(mrb, proc, self, stack_keep);\n}\n\n\n// target function\nmrb_bool\nmrb_env_unshare(mrb_state *mrb, struct REnv *e, mrb_bool noraise)\n{\n  if (e == NULL) return TRUE;\n  if (!MRB_ENV_ONSTACK_P(e)) return TRUE;\n  if (e->cxt != mrb->c) return TRUE;\n  if (e == CI_ENV(mrb->c->cibase)) return TRUE; /* for mirb */\n\n  size_t len = (size_t)MRB_ENV_LEN(e);\n  if (len == 0) {\n    e->stack = NULL;\n    MRB_ENV_CLOSE(e);\n    return TRUE;\n  }\n\n  size_t live = mrb->gc.live;\n  mrb_value *p = (mrb_value*)mrb_malloc_simple(mrb, sizeof(mrb_value)*len);\n  if (live != mrb->gc.live && mrb_object_dead_p(mrb, (struct RBasic*)e)) {\n    // The e object is now subject to GC inside mrb_malloc_simple().\n    // Moreover, if NULL is returned due to mrb_malloc_simple() failure, simply ignore it.\n    mrb_free(mrb, p);\n    return TRUE;\n  }\n  else if (p) {\n    stack_copy(p, e->stack, len);\n    e->stack = p;\n    MRB_ENV_CLOSE(e);\n    return TRUE;\n  }\n  else {\n    e->stack = NULL;\n    MRB_ENV_CLOSE(e);\n    MRB_ENV_SET_LEN(e, 0);\n    MRB_ENV_SET_BIDX(e, 0);\n    if (!noraise) {\n      mrb_exc_raise(mrb, mrb_obj_value(mrb->nomem_err));\n    }\n    return FALSE;\n  }\n}\n",
    "target": 1,
    "idx": 1057672,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic void\nsctp_notify_peer_addr_change(struct sctp_tcb *stcb, uint32_t state,\n    struct sockaddr *sa, uint32_t error, int so_locked\n#if !defined(__APPLE__) && !defined(SCTP_SO_LOCK_TESTING)\n    SCTP_UNUSED\n#endif\n)\n{\n\tstruct mbuf *m_notify;\n\tstruct sctp_paddr_change *spc;\n\tstruct sctp_queued_to_read *control;\n\n\tif ((stcb == NULL) ||\n\t    sctp_stcb_is_feature_off(stcb->sctp_ep, stcb, SCTP_PCB_FLAGS_RECVPADDREVNT)) {\n\t\t/* event not enabled */\n\t\treturn;\n\t}\n\tm_notify = sctp_get_mbuf_for_msg(sizeof(struct sctp_paddr_change), 0, M_NOWAIT, 1, MT_DATA);\n\tif (m_notify == NULL)\n\t\treturn;\n\tSCTP_BUF_LEN(m_notify) = 0;\n\tspc = mtod(m_notify, struct sctp_paddr_change *);\n\tmemset(spc, 0, sizeof(struct sctp_paddr_change));\n\tspc->spc_type = SCTP_PEER_ADDR_CHANGE;\n\tspc->spc_flags = 0;\n\tspc->spc_length = sizeof(struct sctp_paddr_change);\n\tswitch (sa->sa_family) {\n#ifdef INET\n\tcase AF_INET:\n#ifdef INET6\n\t\tif (sctp_is_feature_on(stcb->sctp_ep, SCTP_PCB_FLAGS_NEEDS_MAPPED_V4)) {\n\t\t\tin6_sin_2_v4mapsin6((struct sockaddr_in *)sa,\n\t\t\t                    (struct sockaddr_in6 *)&spc->spc_aaddr);\n\t\t} else {\n\t\t\tmemcpy(&spc->spc_aaddr, sa, sizeof(struct sockaddr_in));\n\t\t}\n#else\n\t\tmemcpy(&spc->spc_aaddr, sa, sizeof(struct sockaddr_in));\n#endif\n\t\tbreak;\n#endif\n#ifdef INET6\n\tcase AF_INET6:\n\t{\n#ifdef SCTP_EMBEDDED_V6_SCOPE\n\t\tstruct sockaddr_in6 *sin6;\n#endif /* SCTP_EMBEDDED_V6_SCOPE */\n\t\tmemcpy(&spc->spc_aaddr, sa, sizeof(struct sockaddr_in6));\n\n#ifdef SCTP_EMBEDDED_V6_SCOPE\n\t\tsin6 = (struct sockaddr_in6 *)&spc->spc_aaddr;\n\t\tif (IN6_IS_SCOPE_LINKLOCAL(&sin6->sin6_addr)) {\n\t\t\tif (sin6->sin6_scope_id == 0) {\n\t\t\t\t/* recover scope_id for user */\n#ifdef SCTP_KAME\n\t\t\t\t(void)sa6_recoverscope(sin6);\n#else\n\t\t\t\t(void)in6_recoverscope(sin6, &sin6->sin6_addr,\n\t\t\t\t\t\t       NULL);\n#endif\n\t\t\t} else {\n\t\t\t\t/* clear embedded scope_id for user */\n\t\t\t\tin6_clearscope(&sin6->sin6_addr);\n\t\t\t}\n\t\t}\n#endif /* SCTP_EMBEDDED_V6_SCOPE */\n\t\tbreak;\n\t}\n#endif\n#if defined(__Userspace__)\n\tcase AF_CONN:\n\t\tmemcpy(&spc->spc_aaddr, sa, sizeof(struct sockaddr_conn));\n\t\tbreak;\n#endif\n\tdefault:\n\t\t/* TSNH */\n\t\tbreak;\n\t}\n\tspc->spc_state = state;\n\tspc->spc_error = error;\n\tspc->spc_assoc_id = sctp_get_associd(stcb);\n\n\tSCTP_BUF_LEN(m_notify) = sizeof(struct sctp_paddr_change);\n\tSCTP_BUF_NEXT(m_notify) = NULL;\n\n\t/* append to socket */\n\tcontrol = sctp_build_readq_entry(stcb, stcb->asoc.primary_destination,\n\t                                 0, 0, stcb->asoc.context, 0, 0, 0,\n\t                                 m_notify);\n\tif (control == NULL) {\n\t\t/* no memory */\n\t\tsctp_m_freem(m_notify);\n\t\treturn;\n\t}\n\tcontrol->length = SCTP_BUF_LEN(m_notify);\n\tcontrol->spec_flags = M_NOTIFICATION;\n\t/* not that we need this */\n\tcontrol->tail_mbuf = m_notify;\n\tsctp_add_to_readq(stcb->sctp_ep, stcb,\n\t                  control,\n\t                  &stcb->sctp_socket->so_rcv, 1,\n\t                  SCTP_READ_LOCK_NOT_HELD,\n\t                  so_locked);\n}\n\nstatic int\nsctp_asconf_del_remote_addrs_except(struct sctp_tcb *stcb, struct sockaddr *src)\n{\n\tstruct sctp_nets *src_net, *net;\n\n\t/* make sure the source address exists as a destination net */\n\tsrc_net = sctp_findnet(stcb, src);\n\tif (src_net == NULL) {\n\t\t/* not found */\n\t\treturn (-1);\n\t}\n\n\t/* delete all destination addresses except the source */\n\tTAILQ_FOREACH(net, &stcb->asoc.nets, sctp_next) {\n\t\tif (net != src_net) {\n\t\t\t/* delete this address */\n\t\t\tsctp_remove_net(stcb, net);\n\t\t\tSCTPDBG(SCTP_DEBUG_ASCONF1,\n\t\t\t\t\"asconf_del_remote_addrs_except: deleting \");\n\t\t\tSCTPDBG_ADDR(SCTP_DEBUG_ASCONF1,\n\t\t\t\t     (struct sockaddr *)&net->ro._l_addr);\n\t\t\t/* notify upper layer */\n\t\t\tsctp_ulp_notify(SCTP_NOTIFY_ASCONF_DELETE_IP, stcb, 0,\n\t\t\t    (struct sockaddr *)&net->ro._l_addr, SCTP_SO_NOT_LOCKED);\n\t\t}\n\t}\n\treturn (0);\n}\n\n\n\nvoid\nsctp_handle_asconf(struct mbuf *m, unsigned int offset,\n                   struct sockaddr *src,\n\t\t   struct sctp_asconf_chunk *cp, struct sctp_tcb *stcb,\n\t\t   int first)\n{\n\tstruct sctp_association *asoc;\n\tuint32_t serial_num;\n\tstruct mbuf *n, *m_ack, *m_result, *m_tail;\n\tstruct sctp_asconf_ack_chunk *ack_cp;\n\tstruct sctp_asconf_paramhdr *aph;\n\tstruct sctp_ipv6addr_param *p_addr;\n\tunsigned int asconf_limit, cnt;\n\tint error = 0;\t\t/* did an error occur? */\n\n\t/* asconf param buffer */\n\tuint8_t aparam_buf[SCTP_PARAM_BUFFER_SIZE];\n\tstruct sctp_asconf_ack *ack, *ack_next;\n\n\t/* verify minimum length */\n\tif (ntohs(cp->ch.chunk_length) < sizeof(struct sctp_asconf_chunk)) {\n\t\tSCTPDBG(SCTP_DEBUG_ASCONF1,\n\t\t\t\"handle_asconf: chunk too small = %xh\\n\",\n\t\t\tntohs(cp->ch.chunk_length));\n\t\treturn;\n\t}\n\tasoc = &stcb->asoc;\n\tserial_num = ntohl(cp->serial_number);\n\n\tif (SCTP_TSN_GE(asoc->asconf_seq_in, serial_num)) {\n\t\t/* got a duplicate ASCONF */\n\t\tSCTPDBG(SCTP_DEBUG_ASCONF1,\n\t\t\t\"handle_asconf: got duplicate serial number = %xh\\n\",\n\t\t\tserial_num);\n\t\treturn;\n\t} else if (serial_num != (asoc->asconf_seq_in + 1)) {\n\t\tSCTPDBG(SCTP_DEBUG_ASCONF1, \"handle_asconf: incorrect serial number = %xh (expected next = %xh)\\n\",\n\t\t\tserial_num, asoc->asconf_seq_in + 1);\n\t\treturn;\n\t}\n\n\t/* it's the expected \"next\" sequence number, so process it */\n\tasoc->asconf_seq_in = serial_num;\t/* update sequence */\n\t/* get length of all the param's in the ASCONF */\n\tasconf_limit = offset + ntohs(cp->ch.chunk_length);\n\tSCTPDBG(SCTP_DEBUG_ASCONF1,\n\t\t\"handle_asconf: asconf_limit=%u, sequence=%xh\\n\",\n\t\tasconf_limit, serial_num);\n\n\tif (first) {\n\t\t/* delete old cache */\n\t\tSCTPDBG(SCTP_DEBUG_ASCONF1,\"handle_asconf: Now processing first ASCONF. Try to delete old cache\\n\");\n\n\t\tTAILQ_FOREACH_SAFE(ack, &asoc->asconf_ack_sent, next, ack_next) {\n\t\t\tif (ack->serial_number == serial_num)\n\t\t\t\tbreak;\n\t\t\tSCTPDBG(SCTP_DEBUG_ASCONF1,\"handle_asconf: delete old(%u) < first(%u)\\n\",\n\t\t\t    ack->serial_number, serial_num);\n\t\t\tTAILQ_REMOVE(&asoc->asconf_ack_sent, ack, next);\n\t\t\tif (ack->data != NULL) {\n\t\t\t\tsctp_m_freem(ack->data);\n\t\t\t}\n\t\t\tSCTP_ZONE_FREE(SCTP_BASE_INFO(ipi_zone_asconf_ack), ack);\n\t\t}\n\t}\n\n\tm_ack = sctp_get_mbuf_for_msg(sizeof(struct sctp_asconf_ack_chunk), 0,\n\t\t\t\t      M_NOWAIT, 1, MT_DATA);\n\tif (m_ack == NULL) {\n\t\tSCTPDBG(SCTP_DEBUG_ASCONF1,\n\t\t\t\"handle_asconf: couldn't get mbuf!\\n\");\n\t\treturn;\n\t}\n\tm_tail = m_ack;\t\t/* current reply chain's tail */\n\n\t/* fill in ASCONF-ACK header */\n\tack_cp = mtod(m_ack, struct sctp_asconf_ack_chunk *);\n\tack_cp->ch.chunk_type = SCTP_ASCONF_ACK;\n\tack_cp->ch.chunk_flags = 0;\n\tack_cp->serial_number = htonl(serial_num);\n\t/* set initial lengths (eg. just an ASCONF-ACK), ntohx at the end! */\n\tSCTP_BUF_LEN(m_ack) = sizeof(struct sctp_asconf_ack_chunk);\n\tack_cp->ch.chunk_length = sizeof(struct sctp_asconf_ack_chunk);\n\n\t/* skip the lookup address parameter */\n\toffset += sizeof(struct sctp_asconf_chunk);\n\tp_addr = (struct sctp_ipv6addr_param *)sctp_m_getptr(m, offset, sizeof(struct sctp_paramhdr), (uint8_t *)&aparam_buf);\n\tif (p_addr == NULL) {\n\t\tSCTPDBG(SCTP_DEBUG_ASCONF1,\n\t\t\t\"handle_asconf: couldn't get lookup addr!\\n\");\n\t\t/* respond with a missing/invalid mandatory parameter error */\n\t\tsctp_m_freem(m_ack);\n\t\treturn;\n\t}\n\t/* param_length is already validated in process_control... */\n\toffset += ntohs(p_addr->ph.param_length);\t/* skip lookup addr */\n\t/* get pointer to first asconf param in ASCONF */\n\taph = (struct sctp_asconf_paramhdr *)sctp_m_getptr(m, offset, sizeof(struct sctp_asconf_paramhdr), (uint8_t *)&aparam_buf);\n\tif (aph == NULL) {\n\t\tSCTPDBG(SCTP_DEBUG_ASCONF1, \"Empty ASCONF received?\\n\");\n\t\tgoto send_reply;\n\t}\n\t/* process through all parameters */\n\tcnt = 0;\n\twhile (aph != NULL) {\n\t\tunsigned int param_length, param_type;\n\n\t\tparam_type = ntohs(aph->ph.param_type);\n\t\tparam_length = ntohs(aph->ph.param_length);\n\t\tif (offset + param_length > asconf_limit) {\n\t\t\t/* parameter goes beyond end of chunk! */\n\t\t\tsctp_m_freem(m_ack);\n\t\t\treturn;\n\t\t}\n\t\tm_result = NULL;\n\n\t\tif (param_length > sizeof(aparam_buf)) {\n\t\t\tSCTPDBG(SCTP_DEBUG_ASCONF1, \"handle_asconf: param length (%u) larger than buffer size!\\n\", param_length);\n\t\t\tsctp_m_freem(m_ack);\n\t\t\treturn;\n\t\t}\n\t\tif (param_length <= sizeof(struct sctp_paramhdr)) {\n\t\t\tSCTPDBG(SCTP_DEBUG_ASCONF1, \"handle_asconf: param length (%u) too short\\n\", param_length);\n\t\t\tsctp_m_freem(m_ack);\n\t\t\treturn;\n\t\t}\n\t\t/* get the entire parameter */\n\t\taph = (struct sctp_asconf_paramhdr *)sctp_m_getptr(m, offset, param_length, aparam_buf);\n\t\tif (aph == NULL) {\n\t\t\tSCTPDBG(SCTP_DEBUG_ASCONF1, \"handle_asconf: couldn't get entire param\\n\");\n\t\t\tsctp_m_freem(m_ack);\n\t\t\treturn;\n\t\t}\n\t\tswitch (param_type) {\n\t\tcase SCTP_ADD_IP_ADDRESS:\n\t\t\tm_result = sctp_process_asconf_add_ip(src, aph, stcb,\n\t\t\t    (cnt < SCTP_BASE_SYSCTL(sctp_hb_maxburst)), error);\n\t\t\tcnt++;\n\t\t\tbreak;\n\t\tcase SCTP_DEL_IP_ADDRESS:\n\t\t\tm_result = sctp_process_asconf_delete_ip(src, aph, stcb,\n\t\t\t    error);\n\t\t\tbreak;\n\t\tcase SCTP_ERROR_CAUSE_IND:\n\t\t\t/* not valid in an ASCONF chunk */\n\t\t\tbreak;\n\t\tcase SCTP_SET_PRIM_ADDR:\n\t\t\tm_result = sctp_process_asconf_set_primary(src, aph,\n\t\t\t    stcb, error);\n\t\t\tbreak;\n\t\tcase SCTP_NAT_VTAGS:\n\t\t        SCTPDBG(SCTP_DEBUG_ASCONF1, \"handle_asconf: sees a NAT VTAG state parameter\\n\");\n\t\t        break;\n\t\tcase SCTP_SUCCESS_REPORT:\n\t\t\t/* not valid in an ASCONF chunk */\n\t\t\tbreak;\n\t\tcase SCTP_ULP_ADAPTATION:\n\t\t\t/* FIX */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif ((param_type & 0x8000) == 0) {\n\t\t\t\t/* Been told to STOP at this param */\n\t\t\t\tasconf_limit = offset;\n\t\t\t\t/*\n\t\t\t\t * FIX FIX - We need to call\n\t\t\t\t * sctp_arethere_unrecognized_parameters()\n\t\t\t\t * to get a operr and send it for any\n\t\t\t\t * param's with the 0x4000 bit set OR do it\n\t\t\t\t * here ourselves... note we still must STOP\n\t\t\t\t * if the 0x8000 bit is clear.\n\t\t\t\t */\n\t\t\t}\n\t\t\t/* unknown/invalid param type */\n\t\t\tbreak;\n\t\t} /* switch */\n\n\t\t/* add any (error) result to the reply mbuf chain */\n\t\tif (m_result != NULL) {\n\t\t\tSCTP_BUF_NEXT(m_tail) = m_result;\n\t\t\tm_tail = m_result;\n\t\t\t/* update lengths, make sure it's aligned too */\n\t\t\tSCTP_BUF_LEN(m_result) = SCTP_SIZE32(SCTP_BUF_LEN(m_result));\n\t\t\tack_cp->ch.chunk_length += SCTP_BUF_LEN(m_result);\n\t\t\t/* set flag to force success reports */\n\t\t\terror = 1;\n\t\t}\n\t\toffset += SCTP_SIZE32(param_length);\n\t\t/* update remaining ASCONF message length to process */\n\t\tif (offset >= asconf_limit) {\n\t\t\t/* no more data in the mbuf chain */\n\t\t\tbreak;\n\t\t}\n\t\t/* get pointer to next asconf param */\n\t\taph = (struct sctp_asconf_paramhdr *)sctp_m_getptr(m, offset,\n\t\t    sizeof(struct sctp_asconf_paramhdr),\n\t\t    (uint8_t *)&aparam_buf);\n\t\tif (aph == NULL) {\n\t\t\t/* can't get an asconf paramhdr */\n\t\t\tSCTPDBG(SCTP_DEBUG_ASCONF1, \"handle_asconf: can't get asconf param hdr!\\n\");\n\t\t\t/* FIX ME - add error here... */\n\t\t}\n\t}\n\n send_reply:\n\tack_cp->ch.chunk_length = htons(ack_cp->ch.chunk_length);\n\t/* save the ASCONF-ACK reply */\n\tack = SCTP_ZONE_GET(SCTP_BASE_INFO(ipi_zone_asconf_ack),\n\t    struct sctp_asconf_ack);\n\tif (ack == NULL) {\n\t\tsctp_m_freem(m_ack);\n\t\treturn;\n\t}\n\tack->serial_number = serial_num;\n\tack->last_sent_to = NULL;\n\tack->data = m_ack;\n\tack->len = 0;\n\tfor (n = m_ack; n != NULL; n = SCTP_BUF_NEXT(n)) {\n\t\tack->len += SCTP_BUF_LEN(n);\n\t}\n\tTAILQ_INSERT_TAIL(&stcb->asoc.asconf_ack_sent, ack, next);\n\n\t/* see if last_control_chunk_from is set properly (use IP src addr) */\n\tif (stcb->asoc.last_control_chunk_from == NULL) {\n\t\t/*\n\t\t * this could happen if the source address was just newly\n\t\t * added\n\t\t */\n\t\tSCTPDBG(SCTP_DEBUG_ASCONF1, \"handle_asconf: looking up net for IP source address\\n\");\n\t\tSCTPDBG(SCTP_DEBUG_ASCONF1, \"Looking for IP source: \");\n\t\tSCTPDBG_ADDR(SCTP_DEBUG_ASCONF1, src);\n\t\t/* look up the from address */\n\t\tstcb->asoc.last_control_chunk_from = sctp_findnet(stcb, src);\n#ifdef SCTP_DEBUG\n\t\tif (stcb->asoc.last_control_chunk_from == NULL) {\n\t\t\tSCTPDBG(SCTP_DEBUG_ASCONF1, \"handle_asconf: IP source address not found?!\\n\");\n\t\t}\n#endif\n\t}\n}\n\n\n\n\n\nvoid\nusrsctp_conninput(void *addr, const void *buffer, size_t length, uint8_t ecn_bits)\n{\n\tstruct sockaddr_conn src, dst;\n\tstruct mbuf *m;\n\tstruct sctphdr *sh;\n\tstruct sctp_chunkhdr *ch;\n\n\tSCTP_STAT_INCR(sctps_recvpackets);\n\tSCTP_STAT_INCR_COUNTER64(sctps_inpackets);\n\tmemset(&src, 0, sizeof(struct sockaddr_conn));\n\tsrc.sconn_family = AF_CONN;\n#ifdef HAVE_SCONN_LEN\n\tsrc.sconn_len = sizeof(struct sockaddr_conn);\n#endif\n\tsrc.sconn_addr = addr;\n\tmemset(&dst, 0, sizeof(struct sockaddr_conn));\n\tdst.sconn_family = AF_CONN;\n#ifdef HAVE_SCONN_LEN\n\tdst.sconn_len = sizeof(struct sockaddr_conn);\n#endif\n\tdst.sconn_addr = addr;\n\tif ((m = sctp_get_mbuf_for_msg((unsigned int)length, 1, M_NOWAIT, 0, MT_DATA)) == NULL) {\n\t\treturn;\n\t}\n\tm_copyback(m, 0, (int)length, (caddr_t)buffer);\n\tif (SCTP_BUF_LEN(m) < (int)(sizeof(struct sctphdr) + sizeof(struct sctp_chunkhdr))) {\n\t\tif ((m = m_pullup(m, sizeof(struct sctphdr) + sizeof(struct sctp_chunkhdr))) == NULL) {\n\t\t\tSCTP_STAT_INCR(sctps_hdrops);\n\t\t\treturn;\n\t\t}\n\t}\n\tsh = mtod(m, struct sctphdr *);;\n\tch = (struct sctp_chunkhdr *)((caddr_t)sh + sizeof(struct sctphdr));\n\tsrc.sconn_port = sh->src_port;\n\tdst.sconn_port = sh->dest_port;\n\tsctp_common_input_processing(&m, 0, sizeof(struct sctphdr), (int)length,\n\t                             (struct sockaddr *)&src,\n\t                             (struct sockaddr *)&dst,\n\t                             sh, ch,\n\t                             SCTP_BASE_VAR(crc32c_offloaded) == 1 ? 0 : 1,\n\t                             ecn_bits,\n\t                             SCTP_DEFAULT_VRFID, 0);\n\tif (m) {\n\t\tsctp_m_freem(m);\n\t}\n\treturn;\n}\n\n\n// target function\nint\ninitialize_fuzzer(void) {\n#ifdef FUZZ_VERBOSE\n\tusrsctp_init(0, conn_output, debug_printf_stack);\n#else\n\tusrsctp_init(0, conn_output, NULL);\n#endif\n\n\tusrsctp_enable_crc32c_offload();\n\t/* set up a connected UDP socket */\n#ifdef SCTP_DEBUG\n\tusrsctp_sysctl_set_sctp_debug_on(SCTP_DEBUG_ALL);\n#endif\n\tusrsctp_register_address((void *)1);\n\n\tfuzzer_printf(\"usrsctp initialized\\n\");\n\treturn (1);\n}\n",
    "target": 1,
    "idx": 1018004,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "// context\nvoid\nUA_SecureChannel_deleteMembersCleanup(UA_SecureChannel *channel) {\n    /* Delete members */\n    UA_ByteString_deleteMembers(&channel->remoteCertificate);\n    UA_ByteString_deleteMembers(&channel->localNonce);\n    UA_ByteString_deleteMembers(&channel->remoteNonce);\n    UA_ChannelSecurityToken_deleteMembers(&channel->securityToken);\n    UA_ChannelSecurityToken_deleteMembers(&channel->nextSecurityToken);\n\n    /* Delete the channel context for the security policy */\n    if(channel->securityPolicy)\n        channel->securityPolicy->channelModule.deleteContext(channel->channelContext);\n\n    /* Detach from the connection and close the connection */\n    if(channel->connection) {\n        if(channel->connection->state != UA_CONNECTION_CLOSED)\n            channel->connection->close(channel->connection);\n        UA_Connection_detachSecureChannel(channel->connection);\n    }\n\n    /* Remove session pointers (not the sessions) and NULL the pointers back to\n     * the SecureChannel in the Session */\n    UA_SessionHeader *sh, *temp;\n    LIST_FOREACH_SAFE(sh, &channel->sessions, pointers, temp) {\n        sh->channel = NULL;\n        LIST_REMOVE(sh, pointers);\n    }\n\n    /* Remove the buffered chunks */\n    struct ChunkEntry *ch, *temp_ch;\n    LIST_FOREACH_SAFE(ch, &channel->chunks, pointers, temp_ch) {\n        UA_ByteString_deleteMembers(&ch->bytes);\n        LIST_REMOVE(ch, pointers);\n        UA_free(ch);\n    }\n}\n\nvoid UA_SecureChannelManager_deleteMembers(UA_SecureChannelManager* cm) {\n    channel_list_entry *entry, *temp;\n    LIST_FOREACH_SAFE(entry, &cm->channels, pointers, temp) {\n        LIST_REMOVE(entry, pointers);\n        UA_SecureChannel_deleteMembersCleanup(&entry->channel);\n        UA_free(entry);\n    }\n}\n\nvoid UA_Server_delete(UA_Server *server) {\n    /* Delete all internal data */\n    UA_SecureChannelManager_deleteMembers(&server->secureChannelManager);\n    UA_SessionManager_deleteMembers(&server->sessionManager);\n    UA_Array_delete(server->namespaces, server->namespacesSize, &UA_TYPES[UA_TYPES_STRING]);\n\n#ifdef UA_ENABLE_DISCOVERY\n    registeredServer_list_entry *rs, *rs_tmp;\n    LIST_FOREACH_SAFE(rs, &server->registeredServers, pointers, rs_tmp) {\n        LIST_REMOVE(rs, pointers);\n        UA_RegisteredServer_deleteMembers(&rs->registeredServer);\n        UA_free(rs);\n    }\n    periodicServerRegisterCallback_entry *ps, *ps_tmp;\n    LIST_FOREACH_SAFE(ps, &server->periodicServerRegisterCallbacks, pointers, ps_tmp) {\n        LIST_REMOVE(ps, pointers);\n        UA_free(ps->callback);\n        UA_free(ps);\n    }\n\n# ifdef UA_ENABLE_DISCOVERY_MULTICAST\n    if(server->config.applicationDescription.applicationType == UA_APPLICATIONTYPE_DISCOVERYSERVER)\n        destroyMulticastDiscoveryServer(server);\n\n    serverOnNetwork_list_entry *son, *son_tmp;\n    LIST_FOREACH_SAFE(son, &server->serverOnNetwork, pointers, son_tmp) {\n        LIST_REMOVE(son, pointers);\n        UA_ServerOnNetwork_deleteMembers(&son->serverOnNetwork);\n        if(son->pathTmp)\n            UA_free(son->pathTmp);\n        UA_free(son);\n    }\n\n    for(size_t i = 0; i < SERVER_ON_NETWORK_HASH_PRIME; i++) {\n        serverOnNetwork_hash_entry* currHash = server->serverOnNetworkHash[i];\n        while(currHash) {\n            serverOnNetwork_hash_entry* nextHash = currHash->next;\n            UA_free(currHash);\n            currHash = nextHash;\n        }\n    }\n# endif\n\n#endif\n\n#ifdef UA_ENABLE_MULTITHREADING\n    pthread_cond_destroy(&server->dispatchQueue_condition);\n    pthread_mutex_destroy(&server->dispatchQueue_mutex);\n#endif\n\n    /* Delete the timed work */\n    UA_Timer_deleteMembers(&server->timer);\n\n    /* Delete the server itself */\n    UA_free(server);\n}\n\n\n// target function\nvoid\nService_ActivateSession(UA_Server *server, UA_SecureChannel *channel,\n                        UA_Session *session, const UA_ActivateSessionRequest *request,\n                        UA_ActivateSessionResponse *response) {\n    if(session->validTill < UA_DateTime_nowMonotonic()) {\n        UA_LOG_INFO_SESSION(server->config.logger, session,\n                            \"ActivateSession: SecureChannel %i wants \"\n                            \"to activate, but the session has timed out\",\n                            channel->securityToken.channelId);\n        response->responseHeader.serviceResult =\n            UA_STATUSCODE_BADSESSIONIDINVALID;\n        return;\n    }\n\n    checkSignature(server, channel, session, request, response);\n    if(response->responseHeader.serviceResult != UA_STATUSCODE_GOOD)\n        return;\n\n    /* Callback into userland access control */\n    response->responseHeader.serviceResult =\n        server->config.accessControl.activateSession(&session->sessionId,\n                                                     &request->userIdentityToken,\n                                                     &session->sessionHandle);\n    if(response->responseHeader.serviceResult != UA_STATUSCODE_GOOD)\n        return;\n\n    /* Detach the old SecureChannel */\n    if(session->header.channel && session->header.channel != channel) {\n        UA_LOG_INFO_SESSION(server->config.logger, session,\n                            \"ActivateSession: Detach from old channel\");\n        UA_Session_detachFromSecureChannel(session);\n    }\n\n    /* Attach to the SecureChannel and activate */\n    UA_Session_attachToSecureChannel(session, channel);\n    session->activated = true;\n    UA_Session_updateLifetime(session);\n    UA_LOG_INFO_SESSION(server->config.logger, session,\n                        \"ActivateSession: Session activated\");\n}\nvoid\nService_CloseSession(UA_Server *server, UA_Session *session,\n                     const UA_CloseSessionRequest *request,\n                     UA_CloseSessionResponse *response) {\n    UA_LOG_INFO_SESSION(server->config.logger, session, \"CloseSession\");\n\n    /* Callback into userland access control */\n    server->config.accessControl.closeSession(&session->sessionId,\n                                              session->sessionHandle);\n    response->responseHeader.serviceResult =\n        UA_SessionManager_removeSession(&server->sessionManager,\n                                        &session->header.authenticationToken);\n}\n",
    "target": 1,
    "idx": 1005652,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "// context\nvoid cil_list_destroy(struct cil_list **list, unsigned destroy_data)\n{\n\tif (*list == NULL) {\n\t\treturn;\n\t}\n\n\tstruct cil_list_item *item = (*list)->head;\n\tstruct cil_list_item *next = NULL;\n\twhile (item != NULL)\n\t{\n\t\tnext = item->next;\n\t\tif (item->flavor == CIL_LIST) {\n\t\t\tcil_list_destroy((struct cil_list**)&(item->data), destroy_data);\n\t\t\tfree(item);\n\t\t} else {\n\t\t\tcil_list_item_destroy(&item, destroy_data);\n\t\t}\n\t\titem = next;\n\t}\n\tfree(*list);\n\t*list = NULL;\n}\n\nstatic void cil_reset_classpermission(struct cil_classpermission *cp)\n{\n\tif (cp == NULL) {\n\t\treturn;\n\t}\n\n\tcil_list_destroy(&cp->classperms, CIL_FALSE);\n}\n\nstatic void cil_reset_classperms_set(struct cil_classperms_set *cp_set)\n{\n\tif (cp_set == NULL) {\n\t\treturn;\n\t}\n\n\tcp_set->set = NULL;\n}\n\nstatic inline void cil_reset_classperms_list(struct cil_list *cp_list)\n{\n\tstruct cil_list_item *curr;\n\n\tif (cp_list == NULL) {\n\t\treturn;\n\t}\n\n\tcil_list_for_each(curr, cp_list) {\n\t\tif (curr->flavor == CIL_CLASSPERMS) { /* KERNEL or MAP */\n\t\t\tcil_reset_classperms(curr->data);\n\t\t} else if (curr->flavor == CIL_CLASSPERMS_SET) { /* SET */\n\t\t\tcil_reset_classperms_set(curr->data);\n\t\t}\n\t}\n}\n\nstatic void cil_reset_classmapping(struct cil_classmapping *cm)\n{\n\tcil_reset_classperms_list(cm->classperms);\n}\n\nint __cil_reset_node(struct cil_tree_node *node,  __attribute__((unused)) uint32_t *finished, __attribute__((unused)) void *extra_args)\n{\n\tswitch (node->flavor) {\n\tcase CIL_CLASS:\n\t\tcil_reset_class(node->data);\n\t\tbreak;\n\tcase CIL_PERM:\n\tcase CIL_MAP_PERM:\n\t\tcil_reset_perm(node->data);\n\t\tbreak;\n\tcase CIL_CLASSPERMISSION:\n\t\tcil_reset_classpermission(node->data);\n\t\tbreak;\n\tcase CIL_CLASSPERMISSIONSET:\n\t\tcil_reset_classpermissionset(node->data);\n\t\tbreak;\n\tcase CIL_CLASSMAPPING:\n\t\tcil_reset_classmapping(node->data);\n\t\tbreak;\n\tcase CIL_TYPEALIAS:\n\tcase CIL_SENSALIAS:\n\tcase CIL_CATALIAS:\n\t\tcil_reset_alias(node->data);\n\t\tbreak;\n\tcase CIL_USERRANGE:\n\t\tcil_reset_userrange(node->data);\n\t\tbreak;\n\tcase CIL_USERLEVEL:\n\t\tcil_reset_userlevel(node->data);\n\t\tbreak;\n\tcase CIL_USER:\n\t\tcil_reset_user(node->data);\n\t\tbreak;\n\tcase CIL_USERATTRIBUTE:\n\t\tcil_reset_userattr(node->data);\n\t\tbreak;\n\tcase CIL_USERATTRIBUTESET:\n\t\tcil_reset_userattributeset(node->data);\n\t\tbreak;\n\tcase CIL_SELINUXUSERDEFAULT:\n\tcase CIL_SELINUXUSER:\n\t\tcil_reset_selinuxuser(node->data);\n\t\tbreak;\n\tcase CIL_ROLE:\n\t\tcil_reset_role(node->data);\n\t\tbreak;\n\tcase CIL_ROLEATTRIBUTE:\n\t\tcil_reset_roleattr(node->data);\n\t\tbreak;\n\tcase CIL_ROLEATTRIBUTESET:\n\t\tcil_reset_roleattributeset(node->data);\n\t\tbreak;\n\tcase CIL_TYPE:\n\t\tcil_reset_type(node->data);\n\t\tbreak;\n\tcase CIL_TYPEATTRIBUTE:\n\t\tcil_reset_typeattr(node->data);\n\t\tbreak;\n\tcase CIL_TYPEATTRIBUTESET:\n\t\tcil_reset_typeattributeset(node->data);\n\t\tbreak;\n\tcase CIL_RANGETRANSITION:\n\t\tcil_reset_rangetransition(node->data);\n\t\tbreak;\n\tcase CIL_AVRULE:\n\t\tcil_reset_avrule(node->data);\n\t\tbreak;\n\tcase CIL_SENS:\n\t\tcil_reset_sens(node->data);\n\t\tbreak;\n\tcase CIL_CAT:\n\t\tcil_reset_cat(node->data);\n\t\tbreak;\n\tcase CIL_SENSCAT:\n\t\tcil_reset_senscat(node->data);\n\t\tbreak;\n\tcase CIL_CATSET:\n\t\tcil_reset_catset(node->data);\n\t\tbreak;\n\tcase CIL_LEVEL:\n\t\tcil_reset_level(node->data);\n\t\tbreak;\n\tcase CIL_LEVELRANGE:\n\t\tcil_reset_levelrange(node->data);\n\t\tbreak;\n\tcase CIL_CONTEXT:\n\t\tcil_reset_context(node->data);\n\t\tbreak;\n\tcase CIL_SIDCONTEXT:\n\t\tcil_reset_sidcontext(node->data);\n\t\tbreak;\n\tcase CIL_FILECON:\n\t\tcil_reset_filecon(node->data);\n\t\tbreak;\n\tcase CIL_IBPKEYCON:\n\t\tcil_reset_ibpkeycon(node->data);\n\t\tbreak;\n\tcase CIL_IBENDPORTCON:\n\t\tcil_reset_ibendportcon(node->data);\n\t\tbreak;\n\tcase CIL_PORTCON:\n\t\tcil_reset_portcon(node->data);\n\t\tbreak;\n\tcase CIL_NODECON:\n\t\tcil_reset_nodecon(node->data);\n\t\tbreak;\n\tcase CIL_GENFSCON:\n\t\tcil_reset_genfscon(node->data);\n\t\tbreak;\n\tcase CIL_NETIFCON:\n\t\tcil_reset_netifcon(node->data);\n\t\tbreak;\n\tcase CIL_PIRQCON:\n\t\tcil_reset_pirqcon(node->data);\n\t\tbreak;\n\tcase CIL_IOMEMCON:\n\t\tcil_reset_iomemcon(node->data);\n\t\tbreak;\n\tcase CIL_IOPORTCON:\n\t\tcil_reset_ioportcon(node->data);\n\t\tbreak;\n\tcase CIL_PCIDEVICECON:\n\t\tcil_reset_pcidevicecon(node->data);\n\t\tbreak;\n\tcase CIL_DEVICETREECON:\n\t\tcil_reset_devicetreecon(node->data);\n\t\tbreak;\n\tcase CIL_FSUSE:\n\t\tcil_reset_fsuse(node->data);\n\t\tbreak;\n\tcase CIL_SID:\n\t\tcil_reset_sid(node->data);\n\t\tbreak;\n\tcase CIL_CONSTRAIN:\n\tcase CIL_MLSCONSTRAIN:\n\t\tcil_reset_constrain(node->data);\n\t\tbreak;\n\tcase CIL_VALIDATETRANS:\n\tcase CIL_MLSVALIDATETRANS:\n\t\tcil_reset_validatetrans(node->data);\n\t\tbreak;\n\tcase CIL_DEFAULTUSER:\n\tcase CIL_DEFAULTROLE:\n\tcase CIL_DEFAULTTYPE:\n\t\tcil_reset_default(node->data);\n\t\tbreak;\n\tcase CIL_DEFAULTRANGE:\n\t\tcil_reset_defaultrange(node->data);\n\t\tbreak;\n\tcase CIL_BOOLEANIF:\n\t\tcil_reset_booleanif(node->data);\n\t\tbreak;\n\tcase CIL_TUNABLEIF:\n\tcase CIL_CALL:\n\t\tbreak; /* Not effected by optional block disabling */\n\tcase CIL_MACRO:\n\tcase CIL_SIDORDER:\n\tcase CIL_CLASSORDER:\n\tcase CIL_CATORDER:\n\tcase CIL_SENSITIVITYORDER:\n\tcase CIL_EXPANDTYPEATTRIBUTE:\n\t\tbreak; /* Nothing to reset */\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn SEPOL_OK;\n}\n\nint cil_tree_walk_core(struct cil_tree_node *node,\n\t\t\t\t\t   int (*process_node)(struct cil_tree_node *node, uint32_t *finished, void *extra_args),\n\t\t\t\t\t   int (*first_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t\t   int (*last_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t\t   void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\twhile (node) {\n\t\tuint32_t finished = CIL_TREE_SKIP_NOTHING;\n\n\t\tif (process_node != NULL) {\n\t\t\trc = (*process_node)(node, &finished, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tif (finished & CIL_TREE_SKIP_NEXT) {\n\t\t\treturn SEPOL_OK;\n\t\t}\n\n\t\tif (node->cl_head != NULL && !(finished & CIL_TREE_SKIP_HEAD)) {\n\t\t\trc = cil_tree_walk(node, process_node, first_child, last_child, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tnode = node->next;\n\t}\n\n\treturn SEPOL_OK;\n}\n\nint cil_tree_walk(struct cil_tree_node *node, \n\t\t\t\t  int (*process_node)(struct cil_tree_node *node, uint32_t *finished, void *extra_args), \n\t\t\t\t  int (*first_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t  int (*last_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t  void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\tif (!node || !node->cl_head) {\n\t\treturn SEPOL_OK;\n\t}\n\n\tif (first_child != NULL) {\n\t\trc = (*first_child)(node->cl_head, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = cil_tree_walk_core(node->cl_head, process_node, first_child, last_child, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\treturn rc;\n\t}\n\n\tif (last_child != NULL) {\n\t\trc = (*last_child)(node->cl_tail, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n}\n\nint cil_tree_walk_core(struct cil_tree_node *node,\n\t\t\t\t\t   int (*process_node)(struct cil_tree_node *node, uint32_t *finished, void *extra_args),\n\t\t\t\t\t   int (*first_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t\t   int (*last_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t\t   void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\twhile (node) {\n\t\tuint32_t finished = CIL_TREE_SKIP_NOTHING;\n\n\t\tif (process_node != NULL) {\n\t\t\trc = (*process_node)(node, &finished, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tif (finished & CIL_TREE_SKIP_NEXT) {\n\t\t\treturn SEPOL_OK;\n\t\t}\n\n\t\tif (node->cl_head != NULL && !(finished & CIL_TREE_SKIP_HEAD)) {\n\t\t\trc = cil_tree_walk(node, process_node, first_child, last_child, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tnode = node->next;\n\t}\n\n\treturn SEPOL_OK;\n}\n\nint cil_tree_walk(struct cil_tree_node *node, \n\t\t\t\t  int (*process_node)(struct cil_tree_node *node, uint32_t *finished, void *extra_args), \n\t\t\t\t  int (*first_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t  int (*last_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t  void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\tif (!node || !node->cl_head) {\n\t\treturn SEPOL_OK;\n\t}\n\n\tif (first_child != NULL) {\n\t\trc = (*first_child)(node->cl_head, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = cil_tree_walk_core(node->cl_head, process_node, first_child, last_child, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\treturn rc;\n\t}\n\n\tif (last_child != NULL) {\n\t\trc = (*last_child)(node->cl_tail, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n}\n\nint cil_tree_walk_core(struct cil_tree_node *node,\n\t\t\t\t\t   int (*process_node)(struct cil_tree_node *node, uint32_t *finished, void *extra_args),\n\t\t\t\t\t   int (*first_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t\t   int (*last_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t\t   void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\twhile (node) {\n\t\tuint32_t finished = CIL_TREE_SKIP_NOTHING;\n\n\t\tif (process_node != NULL) {\n\t\t\trc = (*process_node)(node, &finished, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tif (finished & CIL_TREE_SKIP_NEXT) {\n\t\t\treturn SEPOL_OK;\n\t\t}\n\n\t\tif (node->cl_head != NULL && !(finished & CIL_TREE_SKIP_HEAD)) {\n\t\t\trc = cil_tree_walk(node, process_node, first_child, last_child, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tnode = node->next;\n\t}\n\n\treturn SEPOL_OK;\n}\n\nint cil_tree_walk(struct cil_tree_node *node, \n\t\t\t\t  int (*process_node)(struct cil_tree_node *node, uint32_t *finished, void *extra_args), \n\t\t\t\t  int (*first_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t  int (*last_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t  void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\tif (!node || !node->cl_head) {\n\t\treturn SEPOL_OK;\n\t}\n\n\tif (first_child != NULL) {\n\t\trc = (*first_child)(node->cl_head, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = cil_tree_walk_core(node->cl_head, process_node, first_child, last_child, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\treturn rc;\n\t}\n\n\tif (last_child != NULL) {\n\t\trc = (*last_child)(node->cl_tail, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n}\n\nint cil_reset_ast(struct cil_tree_node *current)\n{\n\tint rc = SEPOL_ERR;\n\n\trc = cil_tree_walk(current, __cil_reset_node, NULL, NULL, NULL);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_ERR, \"Failed to reset AST\\n\");\n\t\treturn SEPOL_ERR;\n\t}\n\n\treturn SEPOL_OK;\n}\n\nint __cil_resolve_ast_last_child_helper(struct cil_tree_node *current, void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_args_resolve *args = extra_args;\n\tstruct cil_tree_node *parent = NULL;\n\tstruct cil_tree_node *blockstack = NULL;\n\n\tif (current == NULL ||  extra_args == NULL) {\n\t\tgoto exit;\n\t}\n\n\tparent = current->parent;\n\n\tif (parent->flavor == CIL_MACRO) {\n\t\targs->macro = NULL;\n\t} else if (parent->flavor == CIL_OPTIONAL) {\n\t\tstruct cil_tree_node *optstack;\n\n\t\tif (((struct cil_optional *)parent->data)->enabled == CIL_FALSE) {\n\t\t\t*(args->changed) = CIL_TRUE;\n\t\t\tcil_list_append(args->disabled_optionals, CIL_NODE, parent);\n\t\t}\n\n\t\t/* pop off the stack */\n\t\toptstack = args->optstack;\n\t\targs->optstack = optstack->cl_head;\n\t\tif (optstack->cl_head) {\n\t\t\toptstack->cl_head->parent = NULL;\n\t\t}\n\t\tfree(optstack);\n\t} else if (parent->flavor == CIL_BOOLEANIF) {\n\t\targs->boolif = NULL;\n\t} else if (parent->flavor == CIL_BLOCK) {\n\t\t/* pop off the stack */\n\t\tblockstack = args->blockstack;\n\t\targs->blockstack = blockstack->cl_head;\n\t\tif (blockstack->cl_head) {\n\t\t\tblockstack->cl_head->parent = NULL;\n\t\t}\n\t\tfree(blockstack);\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_compile(struct cil_db *db)\n{\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL) {\n\t\tgoto exit;\n\t}\n\n\tcil_log(CIL_INFO, \"Building AST from Parse Tree\\n\");\n\trc = cil_build_ast(db, db->parse->root, db->ast->root);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_INFO, \"Failed to build ast\\n\");\n\t\tgoto exit;\n\t}\n\n\tcil_log(CIL_INFO, \"Destroying Parse Tree\\n\");\n\tcil_tree_destroy(&db->parse);\n\n\tcil_log(CIL_INFO, \"Resolving AST\\n\");\n\trc = cil_resolve_ast(db, db->ast->root);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_INFO, \"Failed to resolve ast\\n\");\n\t\tgoto exit;\n\t}\n\n\tcil_log(CIL_INFO, \"Qualifying Names\\n\");\n\trc = cil_fqn_qualify(db->ast->root);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_INFO, \"Failed to qualify names\\n\");\n\t\tgoto exit;\n\t}\n\n\tcil_log(CIL_INFO, \"Compile post process\\n\");\n\trc = cil_post_process(db);\n\tif (rc != SEPOL_OK ) {\n\t\tcil_log(CIL_INFO, \"Post process failed\\n\");\n\t\tgoto exit;\n\t}\n\nexit:\n\n\treturn rc;\n}\n\n\n// target function\nstatic void cil_reset_classperms_set(struct cil_classperms_set *cp_set)\n{\n\tcil_reset_classpermission(cp_set->set);\n}\nstatic inline void cil_reset_classperms_list(struct cil_list *cp_list)\n{\n\tstruct cil_list_item *curr;\n\n\tif (cp_list == NULL) {\n\t\treturn;\n\t}\n\n\tcil_list_for_each(curr, cp_list) {\n\t\tif (curr->flavor == CIL_CLASSPERMS) { /* KERNEL or MAP */\n\t\t\tcil_reset_classperms(curr->data);\n\t\t} else if (curr->flavor == CIL_CLASSPERMS_SET) { /* SET */\n\t\t\tcil_reset_classperms_set(curr->data);\n\t\t}\n\t}\n}\n",
    "target": 1,
    "idx": 1032177,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nflb_sds_t flb_pack_msgpack_to_json_format(const char *data, uint64_t bytes,\n                                          int json_format, int date_format,\n                                          flb_sds_t date_key)\n{\n    int i;\n    int len;\n    int ok = MSGPACK_UNPACK_SUCCESS;\n    int records = 0;\n    int map_size;\n    size_t off = 0;\n    char time_formatted[32];\n    size_t s;\n    flb_sds_t out_tmp;\n    flb_sds_t out_js;\n    flb_sds_t out_buf = NULL;\n    msgpack_unpacked result;\n    msgpack_object root;\n    msgpack_object map;\n    msgpack_sbuffer tmp_sbuf;\n    msgpack_packer tmp_pck;\n    msgpack_object *obj;\n    msgpack_object *k;\n    msgpack_object *v;\n    struct tm tm;\n    struct flb_time tms;\n\n    /* Iterate the original buffer and perform adjustments */\n    records = flb_mp_count(data, bytes);\n    if (records <= 0) {\n        return NULL;\n    }\n\n    /* For json lines and streams mode we need a pre-allocated buffer */\n    if (json_format == FLB_PACK_JSON_FORMAT_LINES ||\n        json_format == FLB_PACK_JSON_FORMAT_STREAM) {\n        out_buf = flb_sds_create_size(bytes + bytes / 4);\n        if (!out_buf) {\n            flb_errno();\n            return NULL;\n        }\n    }\n\n    /* Create temporary msgpack buffer */\n    msgpack_sbuffer_init(&tmp_sbuf);\n    msgpack_packer_init(&tmp_pck, &tmp_sbuf, msgpack_sbuffer_write);\n\n    /*\n     * If the format is the original msgpack style of one big array,\n     * registrate the array, otherwise is not necessary. FYI, original format:\n     *\n     * [\n     *   [timestamp, map],\n     *   [timestamp, map],\n     *   [T, M]...\n     * ]\n     */\n    if (json_format == FLB_PACK_JSON_FORMAT_JSON) {\n        msgpack_pack_array(&tmp_pck, records);\n    }\n\n    msgpack_unpacked_init(&result);\n    while (msgpack_unpack_next(&result, data, bytes, &off) == ok) {\n        /* Each array must have two entries: time and record */\n        root = result.data;\n        if (root.type != MSGPACK_OBJECT_ARRAY) {\n            continue;\n        }\n        if (root.via.array.size != 2) {\n            continue;\n        }\n\n        /* Unpack time */\n        flb_time_pop_from_msgpack(&tms, &result, &obj);\n\n        /* Get the record/map */\n        map = root.via.array.ptr[1];\n        if (map.type != MSGPACK_OBJECT_MAP) {\n            continue;\n        }\n        map_size = map.via.map.size;\n\n        if (date_key != NULL) {\n            msgpack_pack_map(&tmp_pck, map_size + 1);\n        }\n        else {\n            msgpack_pack_map(&tmp_pck, map_size);\n        }\n\n        if (date_key != NULL) {\n            /* Append date key */\n            msgpack_pack_str(&tmp_pck, flb_sds_len(date_key));\n            msgpack_pack_str_body(&tmp_pck, date_key, flb_sds_len(date_key));\n\n            /* Append date value */\n            switch (date_format) {\n            case FLB_PACK_JSON_DATE_DOUBLE:\n                msgpack_pack_double(&tmp_pck, flb_time_to_double(&tms));\n                break;\n            case FLB_PACK_JSON_DATE_ISO8601:\n            /* Format the time, use microsecond precision not nanoseconds */\n                gmtime_r(&tms.tm.tv_sec, &tm);\n                s = strftime(time_formatted, sizeof(time_formatted) - 1,\n                             FLB_PACK_JSON_DATE_ISO8601_FMT, &tm);\n\n                len = snprintf(time_formatted + s,\n                               sizeof(time_formatted) - 1 - s,\n                               \".%06\" PRIu64 \"Z\",\n                               (uint64_t) tms.tm.tv_nsec / 1000);\n                s += len;\n                msgpack_pack_str(&tmp_pck, s);\n                msgpack_pack_str_body(&tmp_pck, time_formatted, s);\n                break;\n            case FLB_PACK_JSON_DATE_EPOCH:\n                msgpack_pack_uint64(&tmp_pck, (long long unsigned)(tms.tm.tv_sec));\n                break;\n            }\n        }\n\n        /* Append remaining keys/values */\n        for (i = 0; i < map_size; i++) {\n            k = &map.via.map.ptr[i].key;\n            v = &map.via.map.ptr[i].val;\n            msgpack_pack_object(&tmp_pck, *k);\n            msgpack_pack_object(&tmp_pck, *v);\n        }\n\n        /*\n         * If the format is the original msgpack style, just continue since\n         * we don't care about separator or JSON convertion at this point.\n         */\n        if (json_format == FLB_PACK_JSON_FORMAT_JSON) {\n            continue;\n        }\n\n        /*\n         * Here we handle two types of records concatenation:\n         *\n         * FLB_PACK_JSON_FORMAT_LINES: add  breakline (\\n) after each record\n         *\n         *\n         *     {'ts':abc,'k1':1}\n         *     {'ts':abc,'k1':2}\n         *     {N}\n         *\n         * FLB_PACK_JSON_FORMAT_STREAM: no separators, e.g:\n         *\n         *     {'ts':abc,'k1':1}{'ts':abc,'k1':2}{N}\n         */\n        if (json_format == FLB_PACK_JSON_FORMAT_LINES ||\n            json_format == FLB_PACK_JSON_FORMAT_STREAM) {\n\n            /* Encode current record into JSON in a temporary variable */\n            out_js = flb_msgpack_raw_to_json_sds(tmp_sbuf.data, tmp_sbuf.size);\n            if (!out_js) {\n                msgpack_sbuffer_destroy(&tmp_sbuf);\n                flb_sds_destroy(out_buf);\n                return NULL;\n            }\n\n            /*\n             * One map record has been converted, now append it to the\n             * outgoing out_buf sds variable.\n             */\n            out_tmp = flb_sds_cat(out_buf, out_js, flb_sds_len(out_js));\n            if (!out_tmp) {\n                msgpack_sbuffer_destroy(&tmp_sbuf);\n                flb_sds_destroy(out_js);\n                flb_sds_destroy(out_buf);\n                return NULL;\n            }\n\n            /* Release temporary json sds buffer */\n            flb_sds_destroy(out_js);\n\n            /* If a realloc happened, check the returned address */\n            if (out_tmp != out_buf) {\n                out_buf = out_tmp;\n            }\n\n            /* Append the breakline only for json lines mode */\n            if (json_format == FLB_PACK_JSON_FORMAT_LINES) {\n                out_tmp = flb_sds_cat(out_buf, \"\\n\", 1);\n                if (!out_tmp) {\n                    msgpack_sbuffer_destroy(&tmp_sbuf);\n                    flb_sds_destroy(out_buf);\n                    return NULL;\n                }\n                if (out_tmp != out_buf) {\n                    out_buf = out_tmp;\n                }\n            }\n            msgpack_sbuffer_clear(&tmp_sbuf);\n        }\n    }\n\n    /* Release the unpacker */\n    msgpack_unpacked_destroy(&result);\n\n    /* Format to JSON */\n    if (json_format == FLB_PACK_JSON_FORMAT_JSON) {\n        out_buf = flb_msgpack_raw_to_json_sds(tmp_sbuf.data, tmp_sbuf.size);\n        msgpack_sbuffer_destroy(&tmp_sbuf);\n\n        if (!out_buf) {\n            return NULL;\n        }\n    }\n    else {\n        msgpack_sbuffer_destroy(&tmp_sbuf);\n    }\n\n    if (out_buf && flb_sds_len(out_buf) == 0) {\n        flb_sds_destroy(out_buf);\n        return NULL;\n    }\n\n    return out_buf;\n}\n\n\n// target function\nflb_sds_t flb_pack_msgpack_to_json_format(const char *data, uint64_t bytes,\n                                          int json_format, int date_format,\n                                          flb_sds_t date_key)\n{\n    int i;\n    int len;\n    int ok = MSGPACK_UNPACK_SUCCESS;\n    int records = 0;\n    int map_size;\n    size_t off = 0;\n    char time_formatted[32];\n    size_t s;\n    flb_sds_t out_tmp;\n    flb_sds_t out_js;\n    flb_sds_t out_buf = NULL;\n    msgpack_unpacked result;\n    msgpack_object root;\n    msgpack_object map;\n    msgpack_sbuffer tmp_sbuf;\n    msgpack_packer tmp_pck;\n    msgpack_object *obj;\n    msgpack_object *k;\n    msgpack_object *v;\n    struct tm tm;\n    struct flb_time tms;\n\n    /* Iterate the original buffer and perform adjustments */\n    records = flb_mp_count(data, bytes);\n    if (records <= 0) {\n        return NULL;\n    }\n\n    /* For json lines and streams mode we need a pre-allocated buffer */\n    if (json_format == FLB_PACK_JSON_FORMAT_LINES ||\n        json_format == FLB_PACK_JSON_FORMAT_STREAM) {\n        out_buf = flb_sds_create_size(bytes + bytes / 4);\n        if (!out_buf) {\n            flb_errno();\n            return NULL;\n        }\n    }\n\n    /* Create temporary msgpack buffer */\n    msgpack_sbuffer_init(&tmp_sbuf);\n    msgpack_packer_init(&tmp_pck, &tmp_sbuf, msgpack_sbuffer_write);\n\n    /*\n     * If the format is the original msgpack style of one big array,\n     * registrate the array, otherwise is not necessary. FYI, original format:\n     *\n     * [\n     *   [timestamp, map],\n     *   [timestamp, map],\n     *   [T, M]...\n     * ]\n     */\n    if (json_format == FLB_PACK_JSON_FORMAT_JSON) {\n        msgpack_pack_array(&tmp_pck, records);\n    }\n\n    msgpack_unpacked_init(&result);\n    while (msgpack_unpack_next(&result, data, bytes, &off) == ok) {\n        /* Each array must have two entries: time and record */\n        root = result.data;\n        if (root.via.array.size != 2) {\n            continue;\n        }\n\n        /* Unpack time */\n        flb_time_pop_from_msgpack(&tms, &result, &obj);\n\n        /* Get the record/map */\n        map = root.via.array.ptr[1];\n        map_size = map.via.map.size;\n\n        if (date_key != NULL) {\n            msgpack_pack_map(&tmp_pck, map_size + 1);\n        }\n        else {\n            msgpack_pack_map(&tmp_pck, map_size);\n        }\n\n        if (date_key != NULL) {\n            /* Append date key */\n            msgpack_pack_str(&tmp_pck, flb_sds_len(date_key));\n            msgpack_pack_str_body(&tmp_pck, date_key, flb_sds_len(date_key));\n\n            /* Append date value */\n            switch (date_format) {\n            case FLB_PACK_JSON_DATE_DOUBLE:\n                msgpack_pack_double(&tmp_pck, flb_time_to_double(&tms));\n                break;\n            case FLB_PACK_JSON_DATE_ISO8601:\n            /* Format the time, use microsecond precision not nanoseconds */\n                gmtime_r(&tms.tm.tv_sec, &tm);\n                s = strftime(time_formatted, sizeof(time_formatted) - 1,\n                             FLB_PACK_JSON_DATE_ISO8601_FMT, &tm);\n\n                len = snprintf(time_formatted + s,\n                               sizeof(time_formatted) - 1 - s,\n                               \".%06\" PRIu64 \"Z\",\n                               (uint64_t) tms.tm.tv_nsec / 1000);\n                s += len;\n                msgpack_pack_str(&tmp_pck, s);\n                msgpack_pack_str_body(&tmp_pck, time_formatted, s);\n                break;\n            case FLB_PACK_JSON_DATE_EPOCH:\n                msgpack_pack_uint64(&tmp_pck, (long long unsigned)(tms.tm.tv_sec));\n                break;\n            }\n        }\n\n        /* Append remaining keys/values */\n        for (i = 0; i < map_size; i++) {\n            k = &map.via.map.ptr[i].key;\n            v = &map.via.map.ptr[i].val;\n            msgpack_pack_object(&tmp_pck, *k);\n            msgpack_pack_object(&tmp_pck, *v);\n        }\n\n        /*\n         * If the format is the original msgpack style, just continue since\n         * we don't care about separator or JSON convertion at this point.\n         */\n        if (json_format == FLB_PACK_JSON_FORMAT_JSON) {\n            continue;\n        }\n\n        /*\n         * Here we handle two types of records concatenation:\n         *\n         * FLB_PACK_JSON_FORMAT_LINES: add  breakline (\\n) after each record\n         *\n         *\n         *     {'ts':abc,'k1':1}\n         *     {'ts':abc,'k1':2}\n         *     {N}\n         *\n         * FLB_PACK_JSON_FORMAT_STREAM: no separators, e.g:\n         *\n         *     {'ts':abc,'k1':1}{'ts':abc,'k1':2}{N}\n         */\n        if (json_format == FLB_PACK_JSON_FORMAT_LINES ||\n            json_format == FLB_PACK_JSON_FORMAT_STREAM) {\n\n            /* Encode current record into JSON in a temporary variable */\n            out_js = flb_msgpack_raw_to_json_sds(tmp_sbuf.data, tmp_sbuf.size);\n            if (!out_js) {\n                msgpack_sbuffer_destroy(&tmp_sbuf);\n                flb_sds_destroy(out_buf);\n                return NULL;\n            }\n\n            /*\n             * One map record has been converted, now append it to the\n             * outgoing out_buf sds variable.\n             */\n            out_tmp = flb_sds_cat(out_buf, out_js, flb_sds_len(out_js));\n            if (!out_tmp) {\n                msgpack_sbuffer_destroy(&tmp_sbuf);\n                flb_sds_destroy(out_js);\n                flb_sds_destroy(out_buf);\n                return NULL;\n            }\n\n            /* Release temporary json sds buffer */\n            flb_sds_destroy(out_js);\n\n            /* If a realloc happened, check the returned address */\n            if (out_tmp != out_buf) {\n                out_buf = out_tmp;\n            }\n\n            /* Append the breakline only for json lines mode */\n            if (json_format == FLB_PACK_JSON_FORMAT_LINES) {\n                out_tmp = flb_sds_cat(out_buf, \"\\n\", 1);\n                if (!out_tmp) {\n                    msgpack_sbuffer_destroy(&tmp_sbuf);\n                    flb_sds_destroy(out_buf);\n                    return NULL;\n                }\n                if (out_tmp != out_buf) {\n                    out_buf = out_tmp;\n                }\n            }\n            msgpack_sbuffer_clear(&tmp_sbuf);\n        }\n    }\n\n    /* Release the unpacker */\n    msgpack_unpacked_destroy(&result);\n\n    /* Format to JSON */\n    if (json_format == FLB_PACK_JSON_FORMAT_JSON) {\n        out_buf = flb_msgpack_raw_to_json_sds(tmp_sbuf.data, tmp_sbuf.size);\n        msgpack_sbuffer_destroy(&tmp_sbuf);\n\n        if (!out_buf) {\n            return NULL;\n        }\n    }\n    else {\n        msgpack_sbuffer_destroy(&tmp_sbuf);\n    }\n\n    if (out_buf && flb_sds_len(out_buf) == 0) {\n        flb_sds_destroy(out_buf);\n        return NULL;\n    }\n\n    return out_buf;\n}\n",
    "target": 1,
    "idx": 1027742,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "// context\nint config__read_file(struct mosquitto__config *config, bool reload, const char *file, struct config_recurse *cr, int level, int *lineno)\n{\n\tint rc;\n\tFILE *fptr = NULL;\n\tchar *buf;\n\tint buflen;\n#ifndef WIN32\n\tDIR *dir;\n#endif\n\n#ifndef WIN32\n\tdir = opendir(file);\n\tif(dir){\n\t\tclosedir(dir);\n\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Config file '%s' is a directory.\", file);\n\t\treturn 1;\n\t}\n#endif\n\n\tfptr = mosquitto__fopen(file, \"rt\", false);\n\tif(!fptr){\n\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Unable to open config file '%s'.\", file);\n\t\treturn 1;\n\t}\n\n\tbuflen = 1000;\n\tbuf = mosquitto__malloc((size_t)buflen);\n\tif(!buf){\n\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\tfclose(fptr);\n\t\treturn MOSQ_ERR_NOMEM;\n\t}\n\n\trc = config__read_file_core(config, reload, cr, level, lineno, fptr, &buf, &buflen);\n\tmosquitto__FREE(buf);\n\tfclose(fptr);\n\n\treturn rc;\n}\n\nint config__read_file(struct mosquitto__config *config, bool reload, const char *file, struct config_recurse *cr, int level, int *lineno)\n{\n\tint rc;\n\tFILE *fptr = NULL;\n\tchar *buf;\n\tint buflen;\n#ifndef WIN32\n\tDIR *dir;\n#endif\n\n#ifndef WIN32\n\tdir = opendir(file);\n\tif(dir){\n\t\tclosedir(dir);\n\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Config file '%s' is a directory.\", file);\n\t\treturn 1;\n\t}\n#endif\n\n\tfptr = mosquitto__fopen(file, \"rt\", false);\n\tif(!fptr){\n\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Unable to open config file '%s'.\", file);\n\t\treturn 1;\n\t}\n\n\tbuflen = 1000;\n\tbuf = mosquitto__malloc((size_t)buflen);\n\tif(!buf){\n\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\tfclose(fptr);\n\t\treturn MOSQ_ERR_NOMEM;\n\t}\n\n\trc = config__read_file_core(config, reload, cr, level, lineno, fptr, &buf, &buflen);\n\tmosquitto__FREE(buf);\n\tfclose(fptr);\n\n\treturn rc;\n}\n\nint config__parse_args(struct mosquitto__config *config, int argc, char *argv[])\n{\n\tint i;\n\tint port_tmp;\n\n\tfor(i=1; i<argc; i++){\n\t\tif(!strcmp(argv[i], \"-c\") || !strcmp(argv[i], \"--config-file\")){\n\t\t\tif(i<argc-1){\n\t\t\t\tdb.config_file = argv[i+1];\n\n\t\t\t\tif(config__read(config, false)){\n\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: -c argument given, but no config file specified.\");\n\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t}\n\t\t\ti++;\n\t\t}else if(!strcmp(argv[i], \"-d\") || !strcmp(argv[i], \"--daemon\")){\n\t\t\tconfig->daemon = true;\n\t\t}else if(!strcmp(argv[i], \"-h\") || !strcmp(argv[i], \"--help\")){\n\t\t\tprint_usage();\n\t\t\treturn MOSQ_ERR_INVAL;\n\t\t}else if(!strcmp(argv[i], \"-p\") || !strcmp(argv[i], \"--port\")){\n\t\t\tif(i<argc-1){\n\t\t\t\tport_tmp = atoi(argv[i+1]);\n\t\t\t\tif(port_tmp<1 || port_tmp>UINT16_MAX){\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid port specified (%d).\", port_tmp);\n\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t}else{\n\t\t\t\t\tif(config->cmd_port_count == CMD_PORT_LIMIT){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Only %d ports can be specified on the command line.\", CMD_PORT_LIMIT);\n\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t\t}\n\t\t\t\t\tconfig->cmd_port[config->cmd_port_count] = (uint16_t)port_tmp;\n\t\t\t\t\tconfig->cmd_port_count++;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: -p argument given, but no port specified.\");\n\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t}\n\t\t\ti++;\n\t\t}else if(!strcmp(argv[i], \"--tls-keylog\")){\n#ifdef WITH_TLS\n\t\t\tif(i<argc-1){\n\t\t\t\tdb.tls_keylog = mosquitto_strdup(argv[i+1]);\n\t\t\t\tif(db.tls_keylog == NULL){\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: --tls-keylog argument given, but no file specified.\");\n\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t}\n\t\t\ti++;\n#else\n\t\t\tfprintf(stderr, \"Error: TLS support not available so --tls-keylog is not available.\\n\");\n\t\t\treturn MOSQ_ERR_INVAL;\n#endif\n\t\t}else if(!strcmp(argv[i], \"-q\") || !strcmp(argv[i], \"--quiet\")){\n\t\t\tdb.quiet = true;\n\t\t}else if(!strcmp(argv[i], \"-v\") || !strcmp(argv[i], \"--verbose\")){\n\t\t\tdb.verbose = true;\n\t\t}else if(!strcmp(argv[i], \"--test-config\")){\n\t\t\tconfig->test_configuration = true;\n\t\t}else{\n\t\t\tfprintf(stderr, \"Error: Unknown option '%s'.\\n\",argv[i]);\n\t\t\tprint_usage();\n\t\t\treturn MOSQ_ERR_INVAL;\n\t\t}\n\t}\n\n\t/* Default to drop to mosquitto user if we are privileged and no user specified. */\n\tif(!config->user){\n\t\tconfig->user = mosquitto__strdup(\"mosquitto\");\n\t\tif(config->user == NULL){\n\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t}\n\t}\n\tif(db.quiet){\n\t\tconfig->log_type = 0;\n\t}else if(db.verbose){\n\t\tconfig->log_type = UINT_MAX;\n\t}\n\n\tif(getenv(\"MOSQUITTO_PERSISTENCE_LOCATION\")){\n\t\tmosquitto__FREE(config->persistence_location);\n\t\tconfig->persistence_location = mosquitto_strdup(getenv(\"MOSQUITTO_PERSISTENCE_LOCATION\"));\n\t\tif(!config->persistence_location){\n\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t}\n\t}\n\treturn config__check(config);\n}\n\nint main(int argc, char *argv[])\n#endif\n{\n\tstruct mosquitto__config config;\n\tint rc;\n#ifdef WIN32\n\tSYSTEMTIME st;\n#else\n\tstruct timeval tv;\n#endif\n\tstruct mosquitto *ctxt, *ctxt_tmp;\n\n#if defined(WIN32) || defined(__CYGWIN__)\n\tif(argc == 2){\n\t\tif(!strcmp(argv[1], \"run\")){\n\t\t\tservice_run(argv[0]);\n\t\t\treturn 0;\n\t\t}else if(!strcmp(argv[1], \"install\")){\n\t\t\tservice_install(argv[0]);\n\t\t\treturn 0;\n\t\t}else if(!strcmp(argv[1], \"uninstall\")){\n\t\t\tservice_uninstall(argv[0]);\n\t\t\treturn 0;\n\t\t}\n\t}\n#endif\n\n\n#ifdef WIN32\n\tGetSystemTime(&st);\n\tsrand(st.wSecond + st.wMilliseconds);\n#else\n\tgettimeofday(&tv, NULL);\n\tsrand((unsigned int)(tv.tv_sec + tv.tv_usec));\n#endif\n\n#ifdef WIN32\n\tif(_setmaxstdio(8192) != 8192){\n\t\t/* Old limit was 2048 */\n\t\tif(_setmaxstdio(2048) != 2048){\n\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Unable to increase maximum allowed connections. This session may be limited to 512 connections.\");\n\t\t}\n\t}\n\n#endif\n\n\tmemset(&db, 0, sizeof(struct mosquitto_db));\n\tdb.now_s = mosquitto_time();\n\tdb.now_real_s = time(NULL);\n\tmosquitto_broker_node_id_set(0);\n\n\tnet__broker_init();\n\n\tdb.config = &config;\n\tconfig__init(&config);\n\trc = config__parse_args(&config, argc, argv);\n\tif(rc != MOSQ_ERR_SUCCESS){\n\t\tconfig__cleanup(&config);\n\t\treturn rc;\n\t}\n\n\tif(config.test_configuration){\n\t\tif(!db.config_file){\n\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Please provide a configuration file to test.\");\n\t\t\tconfig__cleanup(&config);\n\t\t\treturn MOSQ_ERR_INVAL;\n\t\t}else{\n\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Configuration file is OK.\");\n\t\t\tconfig__cleanup(&config);\n\t\t\treturn MOSQ_ERR_SUCCESS;\n\t\t}\n\t}\n\n\trc = keepalive__init();\n\tif(rc != MOSQ_ERR_SUCCESS) return rc;\n\n\t/* Drop privileges permanently immediately after the config is loaded.\n\t * This requires the user to ensure that all certificates, log locations,\n\t * etc. are accessible my the `mosquitto` or other unprivileged user.\n\t */\n\trc = drop_privileges(&config);\n\tif(rc != MOSQ_ERR_SUCCESS) return rc;\n\t/* Set umask based on environment variable */\n\trc = set_umask();\n\tif(rc != MOSQ_ERR_SUCCESS) return rc;\n\n\n\tif(config.daemon){\n\t\tmosquitto__daemonise();\n\t}\n\n\tif(pid__write()) return 1;\n\n\trc = db__open(&config);\n\tif(rc != MOSQ_ERR_SUCCESS){\n\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Couldn't open database.\");\n\t\treturn rc;\n\t}\n\n\t/* Initialise logging only after initialising the database in case we're\n\t * logging to topics */\n\tif(log__init(&config)){\n\t\trc = 1;\n\t\treturn rc;\n\t}\n\tlog__printf(NULL, MOSQ_LOG_INFO, \"mosquitto version %s starting\", VERSION);\n\tif(db.config_file){\n\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Config loaded from %s.\", db.config_file);\n\t}else{\n\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Using default config.\");\n\t}\n\treport_features();\n\n\trc = plugin__load_all();\n\tif(rc) return rc;\n\trc = mosquitto_security_init(false);\n\tif(rc) return rc;\n\n\tplugin_persist__handle_restore();\n\tdb__msg_store_compact();\n\n\t/* After loading persisted clients and ACLs, try to associate them,\n\t * so persisted subscriptions can start storing messages */\n\tHASH_ITER(hh_id, db.contexts_by_id, ctxt, ctxt_tmp){\n\t\tif(ctxt && !ctxt->clean_start && ctxt->username){\n\t\t\trc = acl__find_acls(ctxt);\n\t\t\tif(rc){\n\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Failed to associate persisted user %s with ACLs, \"\n\t\t\t\t\t\"likely due to changed ports while using a per_listener_settings configuration.\", ctxt->username);\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef WITH_SYS_TREE\n\tsys_tree__init();\n#endif\n\n\trc = mux__init();\n\tif(rc) return rc;\n\n\tif(listeners__start()) return 1;\n\n\tsignal__setup();\n\n#ifdef WITH_BRIDGE\n\tbridge__start_all();\n#endif\n\n#ifdef WITH_CJSON\n\tbroker_control__init();\n#endif\n\n\tlog__printf(NULL, MOSQ_LOG_INFO, \"mosquitto version %s running\", VERSION);\n#ifdef WITH_SYSTEMD\n\tsd_notify(0, \"READY=1\");\n#endif\n\n\tg_run = 1;\n\trc = mosquitto_main_loop(g_listensock, g_listensock_count);\n\n\t/* FIXME - this isn't quite right, all wills with will delay zero should be\n\t * sent now, but those with positive will delay should be persisted and\n\t * restored, pending the client reconnecting in time. */\n\tHASH_ITER(hh_id, db.contexts_by_id, ctxt, ctxt_tmp){\n\t\tcontext__send_will(ctxt);\n\t}\n\twill_delay__send_all();\n\n\t/* Set to true only after persistence events have been processed */\n\tdb.shutdown = true;\n\tlog__printf(NULL, MOSQ_LOG_INFO, \"mosquitto version %s terminating\", VERSION);\n\n#ifdef WITH_CJSON\n\tbroker_control__cleanup();\n#endif\n\n#ifdef WITH_PERSISTENCE\n\tpersist__backup(true);\n#endif\n\tsession_expiry__remove_all();\n\n\tlisteners__stop();\n\n\tHASH_ITER(hh_id, db.contexts_by_id, ctxt, ctxt_tmp){\n#if defined(WITH_WEBSOCKETS) && WITH_WEBSOCKETS == WS_IS_LWS\n\t\tif(!ctxt->wsi)\n#endif\n\t\t{\n\t\t\tctxt->is_persisted = false; /* prevent persistence removal */\n\t\t\tcontext__cleanup(ctxt, true);\n\t\t}\n\t}\n\tHASH_ITER(hh_sock, db.contexts_by_sock, ctxt, ctxt_tmp){\n\t\tctxt->is_persisted = false; /* prevent persistence removal */\n\t\tcontext__cleanup(ctxt, true);\n\t}\n#ifdef WITH_BRIDGE\n\tbridge__db_cleanup();\n#endif\n\tcontext__free_disused();\n\tkeepalive__cleanup();\n\n#ifdef WITH_TLS\n\tmosquitto__FREE(db.tls_keylog);\n#endif\n\tdb__close();\n\n\tplugin__unload_all();\n\tmosquitto_security_cleanup(false);\n\n\tif(config.pid_file){\n\t\t(void)remove(config.pid_file);\n\t}\n\n\tlog__close(&config);\n\tconfig__cleanup(db.config);\n\tnet__broker_cleanup();\n\n\treturn rc;\n}\n\nvoid run_broker(char *filename)\n{\n\tchar *argv[4];\n\tint argc = 4;\n\n\targv[0] = strdup(\"mosquitto\");\n\targv[1] = strdup(\"--test-config\");\n\targv[2] = strdup(\"-c\");\n\targv[3] = strdup(filename);\n\n\tmosquitto_fuzz_main(argc, argv);\n\n\tfor(int i=0; i<argc; i++){\n\t\tfree(argv[i]);\n\t}\n}\n\n\n// target function\nstatic int config__add_listener(struct mosquitto__config *config)\n{\n\tstruct mosquitto__listener *listener;\n\n\tconfig->listener_count++;\n\tconfig->listeners = mosquitto__realloc(config->listeners, sizeof(struct mosquitto__listener)*(size_t)config->listener_count);\n\tif(!config->listeners){\n\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\treturn MOSQ_ERR_NOMEM;\n\t}\n\tlistener = &config->listeners[config->listener_count-1];\n\tmemset(listener, 0, sizeof(struct mosquitto__listener));\n\tlistener->security_options = mosquitto_calloc(1, sizeof(struct mosquitto__security_options));\n\tif(!listener->security_options){\n\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\treturn MOSQ_ERR_NOMEM;\n\t}\n\n\treturn MOSQ_ERR_SUCCESS;\n}\nstatic int config__create_default_listener(struct mosquitto__config *config, const char *option_name)\n{\n\tif(config->default_listener) return MOSQ_ERR_SUCCESS;\n\tlog__printf(NULL, MOSQ_LOG_INFO, \"Creating default listener due to '%s' option.\", option_name);\n\tlog__printf(NULL, MOSQ_LOG_INFO, \"It is best practice to define a 'listener' first. Using the '%s' option without a listener will be disabled in the future.\", option_name);\n\tif(config__add_listener(config)){\n\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\treturn MOSQ_ERR_NOMEM;\n\t}\n\n\tconfig->default_listener = &config->listeners[config->listener_count-1];\n\tlistener__set_defaults(config->default_listener);\n\tconfig->default_listener->port = 1883;\n\n\treturn MOSQ_ERR_SUCCESS;\n}\n",
    "target": 1,
    "idx": 1055886,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "// context\nstatic int\nmemory_bclose (struct bfd *abfd)\n{\n  struct bfd_in_memory *bim = (struct bfd_in_memory *) abfd->iostream;\n\n  free (bim->buffer);\n  free (bim);\n  abfd->iostream = NULL;\n\n  return 0;\n}\n\n\nbool\nbfd_close_all_done (bfd *abfd)\n{\n  bool ret = BFD_SEND (abfd, _close_and_cleanup, (abfd));\n\n  if (abfd->iovec != NULL)\n    ret &= abfd->iovec->bclose (abfd) == 0;\n\n  if (ret)\n    _maybe_make_executable (abfd);\n\n  _bfd_delete_bfd (abfd);\n  _bfd_clear_error_data ();\n\n  return ret;\n\n\n// target function\nstatic void\nio_reinit (bfd *abfd, struct bfd_preserve *preserve)\n{\n  if (abfd->iovec != preserve->iovec)\n    {\n      /* Handle file backed to in-memory transition.  bfd_cache_close\n\t won't do anything unless abfd->iovec is the cache_iovec.  */\n      bfd_cache_close (abfd);\n      abfd->iovec = preserve->iovec;\n\n      if (abfd->iostream != preserve->iostream)\n\t{\n\t  if ((abfd->flags & BFD_IN_MEMORY) != 0)\n\t    free (abfd->iostream);\n\t  abfd->iostream = preserve->iostream;\n\t}\n\n      /* Handle in-memory to file backed transition.  */\n      if ((abfd->flags & BFD_CLOSED_BY_CACHE) != 0\n\t  && (abfd->flags & BFD_IN_MEMORY) != 0\n\t  && (preserve->flags & BFD_CLOSED_BY_CACHE) == 0\n\t  && (preserve->flags & BFD_IN_MEMORY) == 0)\n\tbfd_open_file (abfd);\n    }\n  abfd->flags = preserve->flags;\n}\nstatic void\n_bfd_delete_bfd (bfd *abfd)\n{\n  /* Give the target _bfd_free_cached_info a chance to free memory.  */\n  if (abfd->memory && abfd->xvec)\n    bfd_free_cached_info (abfd);\n\n  /* The target _bfd_free_cached_info may not have done anything..  */\n  if (abfd->memory)\n    {\n      bfd_hash_table_free (&abfd->section_htab);\n      objalloc_free ((struct objalloc *) abfd->memory);\n    }\n  else\n    free ((char *) bfd_get_filename (abfd));\n\n  if ((abfd->flags & BFD_IN_MEMORY) != 0)\n    free (abfd->iostream);\n  free (abfd->arelt_data);\n  free (abfd);\n}\n",
    "target": 1,
    "idx": 1065104,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nMRB_API void\nmrb_gc_mark(mrb_state *mrb, struct RBasic *obj)\n{\n  if (obj == 0) return;\n  if (!is_white(obj)) return;\n  if (is_red(obj)) return;\n  mrb_assert((obj)->tt != MRB_TT_FREE);\n  add_gray_list(mrb, &mrb->gc, obj);\n}\n\nstatic void\ngc_mark_children(mrb_state *mrb, mrb_gc *gc, struct RBasic *obj)\n{\n  mrb_assert(is_gray(obj));\n  paint_black(obj);\n  mrb_gc_mark(mrb, (struct RBasic*)obj->c);\n  switch (obj->tt) {\n  case MRB_TT_ICLASS:\n    {\n      struct RClass *c = (struct RClass*)obj;\n      if (MRB_FLAG_TEST(c, MRB_FL_CLASS_IS_ORIGIN))\n        mrb_gc_mark_mt(mrb, c);\n      mrb_gc_mark(mrb, (struct RBasic*)((struct RClass*)obj)->super);\n    }\n    break;\n\n  case MRB_TT_CLASS:\n  case MRB_TT_MODULE:\n  case MRB_TT_SCLASS:\n    {\n      struct RClass *c = (struct RClass*)obj;\n\n      mrb_gc_mark_mt(mrb, c);\n      mrb_gc_mark(mrb, (struct RBasic*)c->super);\n    }\n    /* fall through */\n\n  case MRB_TT_OBJECT:\n  case MRB_TT_CDATA:\n    mrb_gc_mark_iv(mrb, (struct RObject*)obj);\n    break;\n\n  case MRB_TT_PROC:\n    {\n      struct RProc *p = (struct RProc*)obj;\n\n      mrb_gc_mark(mrb, (struct RBasic*)p->upper);\n      mrb_gc_mark(mrb, (struct RBasic*)p->e.env);\n    }\n    break;\n\n  case MRB_TT_ENV:\n    {\n      struct REnv *e = (struct REnv*)obj;\n      mrb_int i, len;\n\n      if (MRB_ENV_ONSTACK_P(e) && e->cxt && e->cxt->fib) {\n        mrb_gc_mark(mrb, (struct RBasic*)e->cxt->fib);\n      }\n      len = MRB_ENV_LEN(e);\n      for (i=0; i<len; i++) {\n        mrb_gc_mark_value(mrb, e->stack[i]);\n      }\n    }\n    break;\n\n  case MRB_TT_FIBER:\n    {\n      struct mrb_context *c = ((struct RFiber*)obj)->cxt;\n\n      if (c) mark_context(mrb, c);\n    }\n    break;\n\n  case MRB_TT_STRUCT:\n  case MRB_TT_ARRAY:\n    {\n      struct RArray *a = (struct RArray*)obj;\n      size_t e=ARY_LEN(a);\n      mrb_value *p = ARY_PTR(a);\n\n      for (size_t i=0; i<e; i++) {\n        mrb_gc_mark_value(mrb, p[i]);\n      }\n    }\n    break;\n\n  case MRB_TT_HASH:\n    mrb_gc_mark_iv(mrb, (struct RObject*)obj);\n    mrb_gc_mark_hash(mrb, (struct RHash*)obj);\n    break;\n\n  case MRB_TT_STRING:\n    if (RSTR_FSHARED_P(obj)) {\n      struct RString *s = (struct RString*)obj;\n      mrb_gc_mark(mrb, (struct RBasic*)s->as.heap.aux.fshared);\n    }\n    break;\n\n  case MRB_TT_RANGE:\n    mrb_gc_mark_range(mrb, (struct RRange*)obj);\n    break;\n\n  case MRB_TT_BREAK:\n    {\n      struct RBreak *brk = (struct RBreak*)obj;\n      mrb_gc_mark(mrb, (struct RBasic*)mrb_break_proc_get(brk));\n      mrb_gc_mark_value(mrb, mrb_break_value_get(brk));\n    }\n    break;\n\n  case MRB_TT_EXCEPTION:\n    mrb_gc_mark_iv(mrb, (struct RObject*)obj);\n    if (((struct RException*)obj)->mesg) {\n      mrb_gc_mark(mrb, (struct RBasic*)((struct RException*)obj)->mesg);\n    }\n    mrb_gc_mark(mrb, (struct RBasic*)((struct RException*)obj)->backtrace);\n    break;\n\n  default:\n    break;\n  }\n}\n\nstatic size_t\nincremental_marking_phase(mrb_state *mrb, mrb_gc *gc, size_t limit)\n{\n  size_t tried_marks = 0;\n\n  while (gc->gray_list && tried_marks < limit) {\n    struct RBasic *obj = gc->gray_list;\n    gc->gray_list = obj->gcnext;\n    obj->gcnext = NULL;\n    gc_mark_children(mrb, gc, obj);\n    tried_marks += gc_gray_counts(mrb, gc, obj);\n  }\n\n  return tried_marks;\n}\n\nstatic size_t\nincremental_gc(mrb_state *mrb, mrb_gc *gc, size_t limit)\n{\n  switch (gc->state) {\n  case MRB_GC_STATE_ROOT:\n    root_scan_phase(mrb, gc);\n    gc->state = MRB_GC_STATE_MARK;\n    flip_white_part(gc);\n    return 0;\n  case MRB_GC_STATE_MARK:\n    if (gc->gray_list) {\n      return incremental_marking_phase(mrb, gc, limit);\n    }\n    else {\n      final_marking_phase(mrb, gc);\n      prepare_incremental_sweep(mrb, gc);\n      return 0;\n    }\n  case MRB_GC_STATE_SWEEP: {\n     size_t tried_sweep = 0;\n     tried_sweep = incremental_sweep_phase(mrb, gc, limit);\n     if (tried_sweep == 0)\n       gc->state = MRB_GC_STATE_ROOT;\n     return tried_sweep;\n  }\n  default:\n    /* unknown state */\n    mrb_assert(0);\n    return 0;\n  }\n}\n\nstatic void\nincremental_gc_finish(mrb_state *mrb, mrb_gc *gc)\n{\n  do {\n    incremental_gc(mrb, gc, SIZE_MAX);\n  } while (gc->state != MRB_GC_STATE_ROOT);\n}\n\nMRB_API void\nmrb_full_gc(mrb_state *mrb)\n{\n  mrb_gc *gc = &mrb->gc;\n\n  if (!mrb->c) return;\n  if (gc->disabled || gc->iterating) return;\n\n  if (is_generational(gc)) {\n    /* clear all the old objects back to young */\n    clear_all_old(mrb, gc);\n    gc->full = TRUE;\n  }\n  else if (gc->state != MRB_GC_STATE_ROOT) {\n    /* finish half baked GC cycle */\n    incremental_gc_finish(mrb, gc);\n  }\n\n  incremental_gc_finish(mrb, gc);\n  gc->threshold = (gc->live_after_mark/100) * gc->interval_ratio;\n\n  if (is_generational(gc)) {\n    gc->majorgc_old_threshold = gc->live_after_mark/100 * MAJOR_GC_INC_RATIO;\n    gc->full = FALSE;\n  }\n\n#ifdef MRB_USE_MALLOC_TRIM\n  malloc_trim(0);\n#endif\n}\n\nstatic mrb_value\ngc_start(mrb_state *mrb, mrb_value obj)\n{\n  mrb_full_gc(mrb);\n  return mrb_nil_value();\n}\n\nMRB_API mrb_value\nmrb_vm_run(mrb_state *mrb, const struct RProc *proc, mrb_value self, mrb_int stack_keep)\n{\n  const mrb_irep *irep = proc->body.irep;\n  mrb_value result;\n  struct mrb_context *c = mrb->c;\n  ptrdiff_t cioff = c->ci - c->cibase;\n  mrb_int nregs = irep->nregs;\n\n  if (!c->stbase) {\n    stack_init(mrb);\n  }\n  if (stack_keep > nregs)\n    nregs = stack_keep;\n  else {\n    struct REnv *e = CI_ENV(mrb->c->ci);\n    if (stack_keep == 0 || (e && irep->nlocals < MRB_ENV_LEN(e))) {\n      ci_env_set(mrb->c->ci, NULL);\n      mrb_env_unshare(mrb, e, FALSE);\n    }\n  }\n  stack_extend(mrb, nregs);\n  stack_clear(c->ci->stack + stack_keep, nregs - stack_keep);\n  c->ci->stack[0] = self;\n  result = mrb_vm_exec(mrb, proc, irep->iseq);\n  if (mrb->c != c) {\n    if (mrb->c->fib) {\n      mrb_write_barrier(mrb, (struct RBasic*)mrb->c->fib);\n    }\n    mrb->c = c;\n  }\n  else if (c->ci - c->cibase > cioff) {\n    c->ci = c->cibase + cioff;\n  }\n  return result;\n}\n\nMRB_API mrb_value\nmrb_top_run(mrb_state *mrb, const struct RProc *proc, mrb_value self, mrb_int stack_keep)\n{\n  if (mrb->c->cibase && mrb->c->ci > mrb->c->cibase) {\n    cipush(mrb, 0, CINFO_SKIP, mrb->object_class, NULL, NULL, 0, 0);\n  }\n  return mrb_vm_run(mrb, proc, self, stack_keep);\n}\n\n\n// target function\nstatic void\nclear_all_old(mrb_state *mrb, mrb_gc *gc)\n{\n  mrb_assert(is_generational(gc));\n  if (gc->full) {\n    /* finish the half baked GC */\n    incremental_gc_finish(mrb, gc);\n  }\n  else {\n    /* Sweep the dead objects, then reset all the live objects\n     * (including all the old objects, of course) to white. */\n    gc->generational = FALSE;\n    prepare_incremental_sweep(mrb, gc);\n    incremental_gc_finish(mrb, gc);\n    gc->generational = TRUE;\n  }\n  /* The gray objects have already been painted as white */\n  gc->atomic_gray_list = gc->gray_list = NULL;\n}\n",
    "target": 1,
    "idx": 1058577,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic int plist_free_node(node_t* node)\n{\n    plist_data_t data = NULL;\n    int node_index = node_detach(node->parent, node);\n    data = plist_get_data(node);\n    plist_free_data(data);\n    node->data = NULL;\n\n    node_t *ch;\n    for (ch = node_first_child(node); ch; ) {\n        node_t *next = node_next_sibling(ch);\n        plist_free_node(ch);\n        ch = next;\n    }\n\n    node_destroy(node);\n\n    return node_index;\n}\n\nPLIST_API void plist_free(plist_t plist)\n{\n    if (plist)\n    {\n        plist_free_node(plist);\n    }\n}\n\n\n// target function\nPLIST_API int plist_from_openstep(const char *plist_ostep, uint32_t length, plist_t * plist)\n{\n    if (!plist) {\n        return PLIST_ERR_INVALID_ARG;\n    }\n    *plist = NULL;\n    if (!plist_ostep || (length == 0)) {\n        return PLIST_ERR_INVALID_ARG;\n    }\n\n    struct _parse_ctx ctx = { plist_ostep, plist_ostep, plist_ostep + length, 0 };\n\n    int err = node_from_openstep(&ctx, plist);\n    if (err == 0) {\n        if (!*plist) {\n            /* whitespace only file is considered an empty dictionary */\n            *plist = plist_new_dict();\n        } else if (ctx.pos < ctx.end && *ctx.pos == '=') {\n            /* attempt to parse this as 'strings' data */\n            plist_free(*plist);\n            plist_t pl = plist_new_dict();\n            ctx.pos = plist_ostep;\n            parse_dict_data(&ctx, pl);\n            if (ctx.err > 0) {\n                plist_free(pl);\n                PLIST_OSTEP_ERR(\"Failed to parse strings data\\n\");\n                err = PLIST_ERR_PARSE;\n            } else {\n                *plist = pl;\n            }\n        }\n    }\n\n    return err;\n}\n",
    "target": 1,
    "idx": 1054949,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "// context\nstatic void\nxmlNodeDumpOutputInternal(xmlSaveCtxtPtr ctxt, xmlNodePtr cur) {\n    int format = ctxt->format;\n    xmlNodePtr tmp, root, unformattedNode = NULL;\n    xmlAttrPtr attr;\n    xmlChar *start, *end;\n    xmlOutputBufferPtr buf;\n\n    if (cur == NULL) return;\n    buf = ctxt->buf;\n\n    root = cur;\n    while (1) {\n        switch (cur->type) {\n        case XML_DOCUMENT_NODE:\n        case XML_HTML_DOCUMENT_NODE:\n\t    xmlDocContentDumpOutput(ctxt, (xmlDocPtr) cur);\n\t    break;\n\n        case XML_DTD_NODE:\n            xmlDtdDumpOutput(ctxt, (xmlDtdPtr) cur);\n            break;\n\n        case XML_DOCUMENT_FRAG_NODE:\n            if (cur->children != NULL) {\n                cur = cur->children;\n                continue;\n            }\n\t    break;\n\n        case XML_ELEMENT_DECL:\n            xmlBufDumpElementDecl(buf->buffer, (xmlElementPtr) cur);\n            break;\n\n        case XML_ATTRIBUTE_DECL:\n            xmlBufDumpAttributeDecl(buf->buffer, (xmlAttributePtr) cur);\n            break;\n\n        case XML_ENTITY_DECL:\n            xmlBufDumpEntityDecl(buf->buffer, (xmlEntityPtr) cur);\n            break;\n\n        case XML_ELEMENT_NODE:\n\t    if ((cur != root) && (ctxt->format == 1) && (xmlIndentTreeOutput))\n\t\txmlOutputBufferWrite(buf, ctxt->indent_size *\n\t\t\t\t     (ctxt->level > ctxt->indent_nr ?\n\t\t\t\t      ctxt->indent_nr : ctxt->level),\n\t\t\t\t     ctxt->indent);\n\n            xmlOutputBufferWrite(buf, 1, \"<\");\n            if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {\n                xmlOutputBufferWriteString(buf, (const char *)cur->ns->prefix);\n                xmlOutputBufferWrite(buf, 1, \":\");\n            }\n            xmlOutputBufferWriteString(buf, (const char *)cur->name);\n            if (cur->nsDef)\n                xmlNsListDumpOutputCtxt(ctxt, cur->nsDef);\n            for (attr = cur->properties; attr != NULL; attr = attr->next)\n                xmlAttrDumpOutput(ctxt, attr);\n\n            if (cur->children == NULL) {\n                if ((ctxt->options & XML_SAVE_NO_EMPTY) == 0) {\n                    if (ctxt->format == 2)\n                        xmlOutputBufferWriteWSNonSig(ctxt, 0);\n                    xmlOutputBufferWrite(buf, 2, \"/>\");\n                } else {\n                    if (ctxt->format == 2)\n                        xmlOutputBufferWriteWSNonSig(ctxt, 1);\n                    xmlOutputBufferWrite(buf, 3, \"></\");\n                    if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {\n                        xmlOutputBufferWriteString(buf,\n                                (const char *)cur->ns->prefix);\n                        xmlOutputBufferWrite(buf, 1, \":\");\n                    }\n                    xmlOutputBufferWriteString(buf, (const char *)cur->name);\n                    if (ctxt->format == 2)\n                        xmlOutputBufferWriteWSNonSig(ctxt, 0);\n                    xmlOutputBufferWrite(buf, 1, \">\");\n                }\n            } else {\n                if (ctxt->format == 1) {\n                    tmp = cur->children;\n                    while (tmp != NULL) {\n                        if ((tmp->type == XML_TEXT_NODE) ||\n                            (tmp->type == XML_CDATA_SECTION_NODE) ||\n                            (tmp->type == XML_ENTITY_REF_NODE)) {\n                            ctxt->format = 0;\n                            unformattedNode = cur;\n                            break;\n                        }\n                        tmp = tmp->next;\n                    }\n                }\n                if (ctxt->format == 2)\n                    xmlOutputBufferWriteWSNonSig(ctxt, 1);\n                xmlOutputBufferWrite(buf, 1, \">\");\n                if (ctxt->format == 1) xmlOutputBufferWrite(buf, 1, \"\\n\");\n                if (ctxt->level >= 0) ctxt->level++;\n                cur = cur->children;\n                continue;\n            }\n\n            break;\n\n        case XML_TEXT_NODE:\n\t    if (cur->content == NULL)\n                break;\n\t    if (cur->name != xmlStringTextNoenc) {\n                xmlOutputBufferWriteEscape(buf, cur->content, ctxt->escape);\n\t    } else {\n\t\t/*\n\t\t * Disable escaping, needed for XSLT\n\t\t */\n\t\txmlOutputBufferWriteString(buf, (const char *) cur->content);\n\t    }\n\t    break;\n\n        case XML_PI_NODE:\n\t    if ((cur != root) && (ctxt->format == 1) && (xmlIndentTreeOutput))\n\t\txmlOutputBufferWrite(buf, ctxt->indent_size *\n\t\t\t\t     (ctxt->level > ctxt->indent_nr ?\n\t\t\t\t      ctxt->indent_nr : ctxt->level),\n\t\t\t\t     ctxt->indent);\n\n            if (cur->content != NULL) {\n                xmlOutputBufferWrite(buf, 2, \"<?\");\n                xmlOutputBufferWriteString(buf, (const char *)cur->name);\n                if (cur->content != NULL) {\n                    if (ctxt->format == 2)\n                        xmlOutputBufferWriteWSNonSig(ctxt, 0);\n                    else\n                        xmlOutputBufferWrite(buf, 1, \" \");\n                    xmlOutputBufferWriteString(buf,\n                            (const char *)cur->content);\n                }\n                xmlOutputBufferWrite(buf, 2, \"?>\");\n            } else {\n                xmlOutputBufferWrite(buf, 2, \"<?\");\n                xmlOutputBufferWriteString(buf, (const char *)cur->name);\n                if (ctxt->format == 2)\n                    xmlOutputBufferWriteWSNonSig(ctxt, 0);\n                xmlOutputBufferWrite(buf, 2, \"?>\");\n            }\n            break;\n\n        case XML_COMMENT_NODE:\n\t    if ((cur != root) && (ctxt->format == 1) && (xmlIndentTreeOutput))\n\t\txmlOutputBufferWrite(buf, ctxt->indent_size *\n\t\t\t\t     (ctxt->level > ctxt->indent_nr ?\n\t\t\t\t      ctxt->indent_nr : ctxt->level),\n\t\t\t\t     ctxt->indent);\n\n            if (cur->content != NULL) {\n                xmlOutputBufferWrite(buf, 4, \"<!--\");\n                xmlOutputBufferWriteString(buf, (const char *)cur->content);\n                xmlOutputBufferWrite(buf, 3, \"-->\");\n            }\n            break;\n\n        case XML_ENTITY_REF_NODE:\n            xmlOutputBufferWrite(buf, 1, \"&\");\n            xmlOutputBufferWriteString(buf, (const char *)cur->name);\n            xmlOutputBufferWrite(buf, 1, \";\");\n            break;\n\n        case XML_CDATA_SECTION_NODE:\n            if (cur->content == NULL || *cur->content == '\\0') {\n                xmlOutputBufferWrite(buf, 12, \"<![CDATA[]]>\");\n            } else {\n                start = end = cur->content;\n                while (*end != '\\0') {\n                    if ((*end == ']') && (*(end + 1) == ']') &&\n                        (*(end + 2) == '>')) {\n                        end = end + 2;\n                        xmlOutputBufferWrite(buf, 9, \"<![CDATA[\");\n                        xmlOutputBufferWrite(buf, end - start,\n                                (const char *)start);\n                        xmlOutputBufferWrite(buf, 3, \"]]>\");\n                        start = end;\n                    }\n                    end++;\n                }\n                if (start != end) {\n                    xmlOutputBufferWrite(buf, 9, \"<![CDATA[\");\n                    xmlOutputBufferWriteString(buf, (const char *)start);\n                    xmlOutputBufferWrite(buf, 3, \"]]>\");\n                }\n            }\n            break;\n\n        case XML_ATTRIBUTE_NODE:\n            xmlAttrDumpOutput(ctxt, (xmlAttrPtr) cur);\n            break;\n\n        case XML_NAMESPACE_DECL:\n            xmlNsDumpOutputCtxt(ctxt, (xmlNsPtr) cur);\n            break;\n\n        default:\n            break;\n        }\n\n        while (1) {\n            if (cur == root)\n                return;\n            if ((ctxt->format == 1) &&\n                (cur->type != XML_XINCLUDE_START) &&\n                (cur->type != XML_XINCLUDE_END))\n                xmlOutputBufferWrite(buf, 1, \"\\n\");\n            if (cur->next != NULL) {\n                cur = cur->next;\n                break;\n            }\n\n            cur = cur->parent;\n\n            if (cur->type == XML_ELEMENT_NODE) {\n                if (ctxt->level > 0) ctxt->level--;\n                if ((xmlIndentTreeOutput) && (ctxt->format == 1))\n                    xmlOutputBufferWrite(buf, ctxt->indent_size *\n                                         (ctxt->level > ctxt->indent_nr ?\n                                          ctxt->indent_nr : ctxt->level),\n                                         ctxt->indent);\n\n                xmlOutputBufferWrite(buf, 2, \"</\");\n                if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {\n                    xmlOutputBufferWriteString(buf,\n                            (const char *)cur->ns->prefix);\n                    xmlOutputBufferWrite(buf, 1, \":\");\n                }\n\n                xmlOutputBufferWriteString(buf, (const char *)cur->name);\n                if (ctxt->format == 2)\n                    xmlOutputBufferWriteWSNonSig(ctxt, 0);\n                xmlOutputBufferWrite(buf, 1, \">\");\n\n                if (cur == unformattedNode) {\n                    ctxt->format = format;\n                    unformattedNode = NULL;\n                }\n            }\n        }\n    }\n}\n\nstatic int\nxmlDocContentDumpOutput(xmlSaveCtxtPtr ctxt, xmlDocPtr cur) {\n#ifdef LIBXML_HTML_ENABLED\n    xmlDtdPtr dtd;\n    int is_xhtml = 0;\n#endif\n    const xmlChar *oldenc = cur->encoding;\n    const xmlChar *oldctxtenc = ctxt->encoding;\n    const xmlChar *encoding = ctxt->encoding;\n    xmlCharEncodingOutputFunc oldescape = ctxt->escape;\n    xmlCharEncodingOutputFunc oldescapeAttr = ctxt->escapeAttr;\n    xmlOutputBufferPtr buf = ctxt->buf;\n    xmlCharEncoding enc;\n    int switched_encoding = 0;\n\n    xmlInitParser();\n\n    if ((cur->type != XML_HTML_DOCUMENT_NODE) &&\n        (cur->type != XML_DOCUMENT_NODE))\n\t return(-1);\n\n    if (ctxt->encoding != NULL) {\n        cur->encoding = BAD_CAST ctxt->encoding;\n    } else if (cur->encoding != NULL) {\n\tencoding = cur->encoding;\n    }\n\n    if (((cur->type == XML_HTML_DOCUMENT_NODE) &&\n         ((ctxt->options & XML_SAVE_AS_XML) == 0) &&\n         ((ctxt->options & XML_SAVE_XHTML) == 0)) ||\n        (ctxt->options & XML_SAVE_AS_HTML)) {\n#ifdef LIBXML_HTML_ENABLED\n        if (encoding != NULL)\n\t    htmlSetMetaEncoding(cur, (const xmlChar *) encoding);\n        if (encoding == NULL)\n\t    encoding = htmlGetMetaEncoding(cur);\n        if (encoding == NULL)\n\t    encoding = BAD_CAST \"HTML\";\n\tif ((encoding != NULL) && (oldctxtenc == NULL) &&\n\t    (buf->encoder == NULL) && (buf->conv == NULL)) {\n\t    if (xmlSaveSwitchEncoding(ctxt, (const char*) encoding) < 0) {\n\t\tcur->encoding = oldenc;\n\t\treturn(-1);\n\t    }\n\t}\n        if (ctxt->options & XML_SAVE_FORMAT)\n\t    htmlDocContentDumpFormatOutput(buf, cur,\n\t                                   (const char *)encoding, 1);\n\telse\n\t    htmlDocContentDumpFormatOutput(buf, cur,\n\t                                   (const char *)encoding, 0);\n\tif (ctxt->encoding != NULL)\n\t    cur->encoding = oldenc;\n\treturn(0);\n#else\n        return(-1);\n#endif\n    } else if ((cur->type == XML_DOCUMENT_NODE) ||\n               (ctxt->options & XML_SAVE_AS_XML) ||\n               (ctxt->options & XML_SAVE_XHTML)) {\n\tenc = xmlParseCharEncoding((const char*) encoding);\n\tif ((encoding != NULL) && (oldctxtenc == NULL) &&\n\t    (buf->encoder == NULL) && (buf->conv == NULL) &&\n\t    ((ctxt->options & XML_SAVE_NO_DECL) == 0)) {\n\t    if ((enc != XML_CHAR_ENCODING_UTF8) &&\n\t\t(enc != XML_CHAR_ENCODING_NONE) &&\n\t\t(enc != XML_CHAR_ENCODING_ASCII)) {\n\t\t/*\n\t\t * we need to switch to this encoding but just for this\n\t\t * document since we output the XMLDecl the conversion\n\t\t * must be done to not generate not well formed documents.\n\t\t */\n\t\tif (xmlSaveSwitchEncoding(ctxt, (const char*) encoding) < 0) {\n\t\t    cur->encoding = oldenc;\n\t\t    return(-1);\n\t\t}\n\t\tswitched_encoding = 1;\n\t    }\n\t    if (ctxt->escape == xmlEscapeEntities)\n\t\tctxt->escape = NULL;\n\t    if (ctxt->escapeAttr == xmlEscapeEntities)\n\t\tctxt->escapeAttr = NULL;\n\t}\n\n\n\t/*\n\t * Save the XML declaration\n\t */\n\tif ((ctxt->options & XML_SAVE_NO_DECL) == 0) {\n\t    xmlOutputBufferWrite(buf, 14, \"<?xml version=\");\n\t    if (cur->version != NULL)\n\t\txmlBufWriteQuotedString(buf->buffer, cur->version);\n\t    else\n\t\txmlOutputBufferWrite(buf, 5, \"\\\"1.0\\\"\");\n\t    if (encoding != NULL) {\n\t\txmlOutputBufferWrite(buf, 10, \" encoding=\");\n\t\txmlBufWriteQuotedString(buf->buffer, (xmlChar *) encoding);\n\t    }\n\t    switch (cur->standalone) {\n\t\tcase 0:\n\t\t    xmlOutputBufferWrite(buf, 16, \" standalone=\\\"no\\\"\");\n\t\t    break;\n\t\tcase 1:\n\t\t    xmlOutputBufferWrite(buf, 17, \" standalone=\\\"yes\\\"\");\n\t\t    break;\n\t    }\n\t    xmlOutputBufferWrite(buf, 3, \"?>\\n\");\n\t}\n\n#ifdef LIBXML_HTML_ENABLED\n        if (ctxt->options & XML_SAVE_XHTML)\n            is_xhtml = 1;\n\tif ((ctxt->options & XML_SAVE_NO_XHTML) == 0) {\n\t    dtd = xmlGetIntSubset(cur);\n\t    if (dtd != NULL) {\n\t\tis_xhtml = xmlIsXHTML(dtd->SystemID, dtd->ExternalID);\n\t\tif (is_xhtml < 0) is_xhtml = 0;\n\t    }\n\t}\n#endif\n\tif (cur->children != NULL) {\n\t    xmlNodePtr child = cur->children;\n\n\t    while (child != NULL) {\n\t\tctxt->level = 0;\n#ifdef LIBXML_HTML_ENABLED\n\t\tif (is_xhtml)\n\t\t    xhtmlNodeDumpOutput(ctxt, child);\n\t\telse\n#endif\n\t\t    xmlNodeDumpOutputInternal(ctxt, child);\n                if ((child->type != XML_XINCLUDE_START) &&\n                    (child->type != XML_XINCLUDE_END))\n                    xmlOutputBufferWrite(buf, 1, \"\\n\");\n\t\tchild = child->next;\n\t    }\n\t}\n    }\n\n    /*\n     * Restore the state of the saving context at the end of the document\n     */\n    if ((switched_encoding) && (oldctxtenc == NULL)) {\n\txmlSaveClearEncoding(ctxt);\n\tctxt->escape = oldescape;\n\tctxt->escapeAttr = oldescapeAttr;\n    }\n    cur->encoding = oldenc;\n    return(0);\n}\n\nvoid\nxmlDocDumpFormatMemoryEnc(xmlDocPtr out_doc, xmlChar **doc_txt_ptr,\n\t\tint * doc_txt_len, const char * txt_encoding,\n\t\tint format) {\n    xmlSaveCtxt ctxt;\n    int                         dummy = 0;\n    xmlOutputBufferPtr          out_buff = NULL;\n    xmlCharEncodingHandlerPtr   conv_hdlr = NULL;\n\n    if (doc_txt_len == NULL) {\n        doc_txt_len = &dummy;   /*  Continue, caller just won't get length */\n    }\n\n    if (doc_txt_ptr == NULL) {\n        *doc_txt_len = 0;\n        return;\n    }\n\n    *doc_txt_ptr = NULL;\n    *doc_txt_len = 0;\n\n    if (out_doc == NULL) {\n        /*  No document, no output  */\n        return;\n    }\n\n    /*\n     *  Validate the encoding value, if provided.\n     *  This logic is copied from xmlSaveFileEnc.\n     */\n\n    if (txt_encoding == NULL)\n\ttxt_encoding = (const char *) out_doc->encoding;\n    if (txt_encoding != NULL) {\n\tconv_hdlr = xmlFindCharEncodingHandler(txt_encoding);\n\tif ( conv_hdlr == NULL ) {\n\t    xmlSaveErr(XML_SAVE_UNKNOWN_ENCODING, (xmlNodePtr) out_doc,\n\t\t       txt_encoding);\n\t    return;\n\t}\n    }\n\n    if ((out_buff = xmlAllocOutputBuffer(conv_hdlr)) == NULL ) {\n        xmlSaveErrMemory(\"creating buffer\");\n        return;\n    }\n\n    memset(&ctxt, 0, sizeof(ctxt));\n    ctxt.buf = out_buff;\n    ctxt.level = 0;\n    ctxt.format = format ? 1 : 0;\n    ctxt.encoding = (const xmlChar *) txt_encoding;\n    xmlSaveCtxtInit(&ctxt);\n    ctxt.options |= XML_SAVE_AS_XML;\n    xmlDocContentDumpOutput(&ctxt, out_doc);\n    xmlOutputBufferFlush(out_buff);\n    if (out_buff->conv != NULL) {\n\t*doc_txt_len = xmlBufUse(out_buff->conv);\n\t*doc_txt_ptr = xmlStrndup(xmlBufContent(out_buff->conv), *doc_txt_len);\n    } else {\n\t*doc_txt_len = xmlBufUse(out_buff->buffer);\n\t*doc_txt_ptr = xmlStrndup(xmlBufContent(out_buff->buffer),*doc_txt_len);\n    }\n    (void)xmlOutputBufferClose(out_buff);\n\n    if ((*doc_txt_ptr == NULL) && (*doc_txt_len > 0)) {\n        *doc_txt_len = 0;\n        xmlSaveErrMemory(\"creating output\");\n    }\n\n    return;\n}\n\nvoid\nxmlDocDumpMemory(xmlDocPtr cur, xmlChar**mem, int *size) {\n    xmlDocDumpFormatMemoryEnc(cur, mem, size, NULL, 0);\n}\n\n\n// target function\nstatic int\nxmlXIncludeLoadFallback(xmlXIncludeCtxtPtr ctxt, xmlNodePtr fallback, int nr) {\n    xmlXIncludeCtxtPtr newctxt;\n    int ret = 0;\n    int oldNbErrors = ctxt->nbErrors;\n\n    if ((fallback == NULL) || (fallback->type == XML_NAMESPACE_DECL) ||\n        (ctxt == NULL))\n\treturn(-1);\n    if (fallback->children != NULL) {\n\t/*\n\t * It's possible that the fallback also has 'includes'\n\t * (Bug 129969), so we re-process the fallback just in case\n\t */\n\tnewctxt = xmlXIncludeNewContext(ctxt->doc);\n\tif (newctxt == NULL)\n\t    return (-1);\n\tnewctxt->_private = ctxt->_private;\n\tnewctxt->base = xmlStrdup(ctxt->base);\t/* Inherit the base from the existing context */\n\txmlXIncludeSetFlags(newctxt, ctxt->parseFlags);\n        newctxt->incTotal = ctxt->incTotal;\n        if (xmlXIncludeDoProcess(newctxt, ctxt->doc, fallback, 1) < 0)\n            ret = -1;\n        ctxt->incTotal = newctxt->incTotal;\n\tif (ctxt->nbErrors > oldNbErrors)\n\t    ret = -1;\n\txmlXIncludeFreeContext(newctxt);\n\n\tctxt->incTab[nr]->inc = fallback->children;\n    } else {\n        ctxt->incTab[nr]->inc = NULL;\n    }\n    ctxt->incTab[nr]->fallback = 1;\n    return(ret);\n}\nstatic int\nxmlXIncludeIncludeNode(xmlXIncludeCtxtPtr ctxt, int nr) {\n    xmlNodePtr cur, end, list, tmp;\n\n    if (ctxt == NULL)\n\treturn(-1);\n    if ((nr < 0) || (nr >= ctxt->incNr))\n\treturn(-1);\n    cur = ctxt->incTab[nr]->ref;\n    if ((cur == NULL) || (cur->type == XML_NAMESPACE_DECL))\n\treturn(-1);\n\n    list = ctxt->incTab[nr]->inc;\n    ctxt->incTab[nr]->inc = NULL;\n\n    /*\n     * Check against the risk of generating a multi-rooted document\n     */\n    if ((cur->parent != NULL) &&\n\t(cur->parent->type != XML_ELEMENT_NODE)) {\n\tint nb_elem = 0;\n\n\ttmp = list;\n\twhile (tmp != NULL) {\n\t    if (tmp->type == XML_ELEMENT_NODE)\n\t\tnb_elem++;\n\t    tmp = tmp->next;\n\t}\n\tif (nb_elem > 1) {\n\t    xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t                   XML_XINCLUDE_MULTIPLE_ROOT,\n\t\t       \"XInclude error: would result in multiple root nodes\\n\",\n\t\t\t   NULL);\n            xmlFreeNodeList(list);\n\t    return(-1);\n\t}\n    }\n\n    if (ctxt->parseFlags & XML_PARSE_NOXINCNODE) {\n\t/*\n\t * Add the list of nodes\n\t */\n\twhile (list != NULL) {\n\t    end = list;\n\t    list = list->next;\n\n\t    xmlAddPrevSibling(cur, end);\n\t}\n\txmlUnlinkNode(cur);\n\txmlFreeNode(cur);\n    } else {\n        xmlNodePtr child, next;\n\n\t/*\n\t * Change the current node as an XInclude start one, and add an\n\t * XInclude end one\n\t */\n        if (ctxt->incTab[nr]->fallback)\n            xmlUnsetProp(cur, BAD_CAST \"href\");\n\tcur->type = XML_XINCLUDE_START;\n\tend = xmlNewDocNode(cur->doc, cur->ns, cur->name, NULL);\n\tif (end == NULL) {\n\t    xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t                   XML_XINCLUDE_BUILD_FAILED,\n\t\t\t   \"failed to build node\\n\", NULL);\n            xmlFreeNodeList(list);\n\t    return(-1);\n\t}\n\tend->type = XML_XINCLUDE_END;\n\txmlAddNextSibling(cur, end);\n\n\t/*\n\t * Add the list of nodes\n\t */\n\twhile (list != NULL) {\n\t    next = list->next;\n\t    xmlAddPrevSibling(end, list);\n\t    list = next;\n\t}\n\n        /* Remove fallback node */\n        for (child = cur->children; child != NULL; child = next) {\n            next = child->next;\n            xmlUnlinkNode(child);\n            xmlFreeNode(child);\n        }\n    }\n\n\n    return(0);\n}\n",
    "target": 1,
    "idx": 1025014,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "// context\n    SymbolTable(std::shared_ptr<SymbolTable> parent, bool builtin)\n    : fParent(parent)\n    , fBuiltin(builtin)\n    , fErrorReporter(parent->fErrorReporter) {}\n\n\n\nCompiler::~Compiler() {\n    Pool::FreeRecycledPool();\n}\n\nbool FuzzSKSL2Metal(sk_sp<SkData> bytes) {\n    SkSL::Compiler compiler;\n    SkSL::String output;\n    SkSL::Program::Settings settings;\n    sk_sp<GrShaderCaps> caps = SkSL::ShaderCapsFactory::Default();\n    settings.fCaps = caps.get();\n    std::unique_ptr<SkSL::Program> program = compiler.convertProgram(\n                                                    SkSL::Program::kFragment_Kind,\n                                                    SkSL::String((const char*) bytes->data(),\n                                                                 bytes->size()),\n                                                    settings);\n    if (!program || !compiler.toMetal(*program, &output)) {\n        return false;\n    }\n    return true;\n}\n\n\n// target function\n    Enum(int offset, StringFragment typeName, std::shared_ptr<SymbolTable> symbols,\n         bool isSharedWithCpp, bool isBuiltin = true)\n    : INHERITED(offset, EnumData{typeName, std::move(symbols), isSharedWithCpp, isBuiltin}) {}\n    std::unique_ptr<ProgramElement> clone() const override {\n        return std::make_unique<Enum>(fOffset, this->typeName(),\n                                      SymbolTable::WrapIfBuiltin(this->symbols()),\n                                      this->isSharedWithCpp(), /*isBuiltin=*/false);\n    }\n    Field(int offset, const Variable* owner, int fieldIndex)\n    : INHERITED(offset, FieldData{owner->type().fields()[fieldIndex].fName,\n                                  owner->type().fields()[fieldIndex].fType,\n                                  owner,\n                                  fieldIndex}) {}\n    StringFragment name() const override {\n        return this->fieldData().fName;\n    }\n    FunctionDeclaration(int offset, ModifiersPool::Handle modifiers, StringFragment name,\n                        std::vector<const Variable*> parameters, const Type* returnType,\n                        bool builtin)\n    : INHERITED(offset, FunctionDeclarationData{name, /*fDefiniition=*/nullptr, modifiers,\n                                                std::move(parameters), returnType, builtin}) {}\n    StringFragment name() const override {\n        return this->functionDeclarationData().fName;\n    }\n    void setDefinition(const FunctionDefinition* definition) const {\n        this->functionDeclarationData().fDefinition = definition;\n    }\n    bool isBuiltin() const {\n        return this->functionDeclarationData().fBuiltin;\n    }\n    FunctionDefinition(int offset,\n                       const FunctionDeclaration* declaration, bool builtin,\n                       std::unique_ptr<Statement> body,\n                       std::unordered_set<const FunctionDeclaration*> referencedIntrinsics = {})\n        : INHERITED(offset,\n                    FunctionDefinitionData{declaration, builtin, std::move(referencedIntrinsics),\n                                           /*fSource=*/nullptr}) {\n        fStatementChildren.push_back(std::move(body));\n    }\n    bool isBuiltin() const {\n        return this->functionDefinitionData().fBuiltin;\n    }\n    void setSource(const ASTNode* source) {\n        this->functionDefinitionData().fSource = source;\n    }\n    std::unique_ptr<ProgramElement> clone() const override {\n        return std::make_unique<FunctionDefinition>(fOffset, &this->declaration(),\n                                                    /*builtin=*/false, this->body()->clone(),\n                                                    this->referencedIntrinsics());\n    }\n        void cleanup() {\n            switch (fKind) {\n                case Kind::kBlock:\n                    fContents.fBlock.~BlockData();\n                    break;\n                case Kind::kBoolLiteral:\n                    fContents.fBoolLiteral.~BoolLiteralData();\n                    break;\n                case Kind::kEnum:\n                    fContents.fEnum.~EnumData();\n                    break;\n                case Kind::kExternalValue:\n                    fContents.fExternalValue.~ExternalValueData();\n                    break;\n                case Kind::kField:\n                    fContents.fField.~FieldData();\n                    break;\n                case Kind::kFieldAccess:\n                    fContents.fFieldAccess.~FieldAccessData();\n                    break;\n                case Kind::kFloatLiteral:\n                    fContents.fFloatLiteral.~FloatLiteralData();\n                    break;\n                case Kind::kForStatement:\n                    fContents.fForStatement.~ForStatementData();\n                    break;\n                case Kind::kFunctionCall:\n                    fContents.fFunctionCall.~FunctionCallData();\n                    break;\n                case Kind::kFunctionDeclaration:\n                    fContents.fFunctionDeclaration.~FunctionDeclarationData();\n                    break;\n                case Kind::kFunctionDefinition:\n                    fContents.fFunctionDefinition.~FunctionDefinitionData();\n                    break;\n                case Kind::kFunctionReference:\n                    fContents.fFunctionReference.~FunctionReferenceData();\n                    break;\n                case Kind::kIfStatement:\n                    fContents.fIfStatement.~IfStatementData();\n                    break;\n                case Kind::kInlineMarker:\n                    fContents.fInlineMarker.~InlineMarkerData();\n                    break;\n                case Kind::kInterfaceBlock:\n                    fContents.fInterfaceBlock.~InterfaceBlockData();\n                    break;\n                case Kind::kIntLiteral:\n                    fContents.fIntLiteral.~IntLiteralData();\n                    break;\n                case Kind::kModifiersDeclaration:\n                    fContents.fModifiersDeclaration.~ModifiersDeclarationData();\n                    break;\n                case Kind::kSection:\n                    fContents.fSection.~SectionData();\n                    break;\n                case Kind::kSetting:\n                    fContents.fSetting.~SettingData();\n                    break;\n                case Kind::kString:\n                    fContents.fString.~String();\n                    break;\n                case Kind::kSwitchStatement:\n                    fContents.fSwitchStatement.~SwitchStatementData();\n                    break;\n                case Kind::kSwizzle:\n                    fContents.fSwizzle.~SwizzleData();\n                    break;\n                case Kind::kSymbol:\n                    fContents.fSymbol.~SymbolData();\n                    break;\n                case Kind::kSymbolAlias:\n                    fContents.fSymbolAlias.~SymbolAliasData();\n                    break;\n                case Kind::kType:\n                    break;\n                case Kind::kTypeReference:\n                    fContents.fTypeReference.~TypeReferenceData();\n                    break;\n                case Kind::kTypeToken:\n                    fContents.fTypeToken.~TypeTokenData();\n                    break;\n                case Kind::kUnresolvedFunction:\n                    fContents.fUnresolvedFunction.~UnresolvedFunctionData();\n                    break;\n                case Kind::kVarDeclaration:\n                    fContents.fVarDeclaration.~VarDeclarationData();\n                    break;\n                case Kind::kVariable:\n                    fContents.fVariable.~VariableData();\n                    break;\n                case Kind::kVariableReference:\n                    fContents.fVariableReference.~VariableReferenceData();\n                    break;\n            }\n        }\n    InterfaceBlock(int offset, const Variable* var, String typeName, String instanceName,\n                   ExpressionArray sizes, std::shared_ptr<SymbolTable> typeOwner)\n    : INHERITED(offset, InterfaceBlockData{var, std::move(typeName), std::move(instanceName),\n                                           std::move(typeOwner)}) {\n        fExpressionChildren.move_back_n(sizes.size(), sizes.data());\n    }\n    void setVariable(const Variable* var) {\n        this->interfaceBlockData().fVariable = var;\n    }\n    std::unique_ptr<ProgramElement> clone() const override {\n        return std::unique_ptr<ProgramElement>(new Section(fOffset, this->name(), this->argument(),\n                                                           this->text()));\n    }\n    Variable(int offset, ModifiersPool::Handle modifiers, StringFragment name, const Type* type,\n             bool builtin, Storage storage, const Expression* initialValue = nullptr)\n    : INHERITED(offset, VariableData{name, type, initialValue, modifiers, storage, builtin}) {}\n    bool isBuiltin() const {\n        return this->variableData().fBuiltin;\n    }\n    Storage storage() const {\n        return (Storage) this->variableData().fStorage;\n    }\n    void setInitialValue(const Expression* initialValue) {\n        SkASSERT(!this->initialValue());\n        this->variableData().fInitialValue = initialValue;\n    }\n    String description() const override {\n        return this->modifiers().description() + this->type().name() + \" \" + this->name();\n    }\n",
    "target": 1,
    "idx": 1026585,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\n\n\n\n\n\n\n\n\n\n\n\n\n\n// target function\nl_ok\nnumaSelectCrossingThreshold(NUMA       *nax,\n                            NUMA       *nay,\n                            l_float32   estthresh,\n                            l_float32  *pbestthresh)\n{\nl_int32    i, inrun, istart, iend, maxstart, maxend, runlen, maxrunlen;\nl_int32    val, maxval, nmax, count;\nl_float32  thresh, fmaxval, fmodeval;\nNUMA      *nat, *nac;\n\n    PROCNAME(\"numaSelectCrossingThreshold\");\n\n    if (!pbestthresh)\n        return ERROR_INT(\"&bestthresh not defined\", procName, 1);\n    *pbestthresh = 0.0;\n    if (!nay)\n        return ERROR_INT(\"nay not defined\", procName, 1);\n\n        /* Compute the number of crossings for different thresholds */\n    nat = numaCreate(41);\n    for (i = 0; i < 41; i++) {\n        thresh = estthresh - 80.0 + 4.0 * i;\n        nac = numaCrossingsByThreshold(nax, nay, thresh);\n        numaAddNumber(nat, numaGetCount(nac));\n        numaDestroy(&nac);\n    }\n\n        /* Find the center of the plateau of max crossings, which\n         * extends from thresh[istart] to thresh[iend]. */\n    numaGetMax(nat, &fmaxval, NULL);\n    maxval = (l_int32)fmaxval;\n    nmax = 0;\n    for (i = 0; i < 41; i++) {\n        numaGetIValue(nat, i, &val);\n        if (val == maxval)\n            nmax++;\n    }\n    if (nmax < 3) {  /* likely accidental max; try the mode */\n        numaGetMode(nat, &fmodeval, &count);\n        if (count > nmax && fmodeval > 0.5 * fmaxval)\n            maxval = (l_int32)fmodeval;  /* use the mode */\n    }\n\n    inrun = FALSE;\n    iend = 40;\n    maxrunlen = 0, maxstart = 0, maxend = 0;\n    for (i = 0; i < 41; i++) {\n        numaGetIValue(nat, i, &val);\n        if (val == maxval) {\n            if (!inrun) {\n                istart = i;\n                inrun = TRUE;\n            }\n            continue;\n        }\n        if (inrun && (val != maxval)) {\n            iend = i - 1;\n            runlen = iend - istart + 1;\n            inrun = FALSE;\n            if (runlen > maxrunlen) {\n                maxstart = istart;\n                maxend = iend;\n                maxrunlen = runlen;\n            }\n        }\n    }\n    if (inrun) {\n        runlen = i - istart;\n        if (runlen > maxrunlen) {\n            maxstart = istart;\n            maxend = i - 1;\n            maxrunlen = runlen;\n        }\n    }\n\n    *pbestthresh = estthresh - 80.0 + 2.0 * (l_float32)(maxstart + maxend);\n\n#if  DEBUG_CROSSINGS\n    lept_stderr(\"\\nCrossings attain a maximum at %d thresholds, between:\\n\"\n                \"  thresh[%d] = %5.1f and thresh[%d] = %5.1f\\n\",\n                nmax, maxstart, estthresh - 80.0 + 4.0 * maxstart,\n                maxend, estthresh - 80.0 + 4.0 * maxend);\n    lept_stderr(\"The best choice: %5.1f\\n\", *pbestthresh);\n    lept_stderr(\"Number of crossings at the 41 thresholds:\");\n    numaWriteStderr(nat);\n#endif  /* DEBUG_CROSSINGS */\n\n    numaDestroy(&nat);\n    return 0;\n}\n",
    "target": 1,
    "idx": 1022760,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nvoid GrGpuResource::release() {\n    SkASSERT(fGpu);\n    this->onRelease();\n    get_resource_cache(fGpu)->resourceAccess().removeResource(this);\n    fGpu = nullptr;\n    fGpuMemorySize = 0;\n}\n\n    void release() {\n        fResource->release();\n        if (!fResource->hasRef() && fResource->hasNoCommandBufferUsages()) {\n            delete fResource;\n        }\n    }\n\nvoid GrResourceCache::releaseAll() {\n    AutoValidate av(this);\n\n    fThreadSafeCache->dropAllRefs();\n\n    this->processFreedGpuResources();\n\n    // We need to make sure to free any resources that were waiting on a free message but never\n    // received one.\n    fTexturesAwaitingUnref.reset();\n\n    SkASSERT(fProxyProvider); // better have called setProxyProvider\n    SkASSERT(fThreadSafeCache); // better have called setThreadSafeCache too\n\n    // We must remove the uniqueKeys from the proxies here. While they possess a uniqueKey\n    // they also have a raw pointer back to this class (which is presumably going away)!\n    fProxyProvider->removeAllUniqueKeys();\n\n    while (fNonpurgeableResources.count()) {\n        GrGpuResource* back = *(fNonpurgeableResources.end() - 1);\n        SkASSERT(!back->wasDestroyed());\n        back->cacheAccess().release();\n    }\n\n    while (fPurgeableQueue.count()) {\n        GrGpuResource* top = fPurgeableQueue.peek();\n        SkASSERT(!top->wasDestroyed());\n        top->cacheAccess().release();\n    }\n\n    SkASSERT(!fScratchMap.count());\n    SkASSERT(!fUniqueHash.count());\n    SkASSERT(!fCount);\n    SkASSERT(!this->getResourceCount());\n    SkASSERT(!fBytes);\n    SkASSERT(!fBudgetedCount);\n    SkASSERT(!fBudgetedBytes);\n    SkASSERT(!fPurgeableBytes);\n    SkASSERT(!fTexturesAwaitingUnref.count());\n}\n\nGrDirectContext::~GrDirectContext() {\n    ASSERT_SINGLE_OWNER\n    // this if-test protects against the case where the context is being destroyed\n    // before having been fully created\n    if (fGpu) {\n        this->flushAndSubmit();\n    }\n\n    // We need to make sure all work is finished on the gpu before we start releasing resources.\n    this->syncAllOutstandingGpuWork(/*shouldExecuteWhileAbandoned=*/false);\n\n    this->destroyDrawingManager();\n\n    // Ideally we could just let the ptr drop, but resource cache queries this ptr in releaseAll.\n    if (fResourceCache) {\n        fResourceCache->releaseAll();\n    }\n    // This has to be after GrResourceCache::releaseAll so that other threads that are holding\n    // async pixel result don't try to destroy buffers off thread.\n    fMappedBufferManager.reset();\n}\n\nGrDirectContext::~GrDirectContext() {\n    ASSERT_SINGLE_OWNER\n    // this if-test protects against the case where the context is being destroyed\n    // before having been fully created\n    if (fGpu) {\n        this->flushAndSubmit();\n    }\n\n    // We need to make sure all work is finished on the gpu before we start releasing resources.\n    this->syncAllOutstandingGpuWork(/*shouldExecuteWhileAbandoned=*/false);\n\n    this->destroyDrawingManager();\n\n    // Ideally we could just let the ptr drop, but resource cache queries this ptr in releaseAll.\n    if (fResourceCache) {\n        fResourceCache->releaseAll();\n    }\n    // This has to be after GrResourceCache::releaseAll so that other threads that are holding\n    // async pixel result don't try to destroy buffers off thread.\n    fMappedBufferManager.reset();\n}\n\n    virtual void internal_dispose() const {\n    #ifdef SK_DEBUG\n        SkASSERT(0 == this->getRefCnt());\n        fRefCnt.store(1, std::memory_order_relaxed);\n    #endif\n        delete this;\n    }\n\n    void  unref() const {\n        if (1 == fRefCnt.fetch_add(-1, std::memory_order_acq_rel)) {\n            // restore the 1 for our destructor's assert\n            SkDEBUGCODE(fRefCnt.store(1, std::memory_order_relaxed));\n            delete (const Derived*)this;\n        }\n    }\n\nvoid GrContextFactory::destroyContexts() {\n    // We must delete the test contexts in reverse order so that any child context is finished and\n    // deleted before a parent context. This relies on the fact that when we make a new context we\n    // append it to the end of fContexts array.\n    // TODO: Look into keeping a dependency dag for contexts and deletion order\n    for (int i = fContexts.count() - 1; i >= 0; --i) {\n        Context& context = fContexts[i];\n        SkScopeExit restore(nullptr);\n        if (context.fTestContext) {\n            restore = context.fTestContext->makeCurrentAndAutoRestore();\n        }\n        if (!context.fGrContext->unique()) {\n            context.fGrContext->releaseResourcesAndAbandonContext();\n            context.fAbandoned = true;\n        }\n        context.fGrContext->unref();\n        delete context.fTestContext;\n    }\n    fContexts.reset();\n}\n\nGrContextFactory::~GrContextFactory() {\n    this->destroyContexts();\n}\n\n\n\n\n// target function\nstd::unique_ptr<GrFragmentProcessor> SkPictureShader::asFragmentProcessor(\n        const GrFPArgs& args) const {\n\n    auto ctx = args.fContext;\n    auto lm = this->totalLocalMatrix(args.fPreLocalMatrix);\n    SkColorType dstColorType = GrColorTypeToSkColorType(args.fDstColorInfo->colorType());\n    if (dstColorType == kUnknown_SkColorType) {\n        dstColorType = kRGBA_8888_SkColorType;\n    }\n\n    auto dstCS = ref_or_srgb(args.fDstColorInfo->colorSpace());\n    auto info = CachedImageInfo::Make(fTile, args.fMatrixProvider.localToDevice(), &lm,\n                                      dstColorType, dstCS.get(),\n                                      ctx->priv().caps()->maxTextureSize());\n    SkMatrix inv;\n    if (!info.success || !(*lm).invert(&inv)) {\n        return nullptr;\n    }\n\n    // Gotta be sure the GPU can support our requested colortype (might be FP16)\n    if (!ctx->colorTypeSupportedAsSurface(info.imageInfo.colorType())) {\n        info.imageInfo = info.imageInfo.makeColorType(kRGBA_8888_SkColorType);\n    }\n\n    static const GrUniqueKey::Domain kDomain = GrUniqueKey::GenerateDomain();\n    GrUniqueKey key;\n    GrUniqueKey::Builder builder(&key, kDomain, 10, \"Picture Shader Image\");\n    builder[0] = dstCS->toXYZD50Hash();\n    builder[1] = dstCS->transferFnHash();\n    builder[2] = static_cast<uint32_t>(dstColorType);\n    builder[3] = fPicture->uniqueID();\n    memcpy(&builder[4], &fTile, sizeof(fTile));                     // 4,5,6,7\n    memcpy(&builder[8], &info.tileScale, sizeof(info.tileScale));   // 8,9\n    builder.finish();\n\n    GrProxyProvider* provider = ctx->priv().proxyProvider();\n    GrSurfaceProxyView view;\n    if (auto proxy = provider->findProxyByUniqueKey(key)) {\n        view = GrSurfaceProxyView(proxy, kTopLeft_GrSurfaceOrigin, GrSwizzle());\n    } else {\n        const int msaaSampleCount = 0;\n        const SkSurfaceProps* props = nullptr;\n        const bool createWithMips = false;\n        auto image = info.makeImage(SkSurface::MakeRenderTarget(ctx,\n                                                                SkBudgeted::kYes,\n                                                                info.imageInfo,\n                                                                msaaSampleCount,\n                                                                kTopLeft_GrSurfaceOrigin,\n                                                                props,\n                                                                createWithMips),\n                                    fPicture.get());\n        if (!image) {\n            return nullptr;\n        }\n        auto [v, ct] = as_IB(image)->asView(ctx, GrMipmapped::kNo);\n        view = std::move(v);\n        provider->assignUniqueKeyToProxy(key, view.asTextureProxy());\n    }\n\n    const GrSamplerState sampler(static_cast<GrSamplerState::WrapMode>(fTmx),\n                                 static_cast<GrSamplerState::WrapMode>(fTmy),\n                                 sampling_to_filter(args.fSampling));\n    return GrTextureEffect::Make(std::move(view), kPremul_SkAlphaType, inv, sampler,\n                                 *ctx->priv().caps());\n}\n",
    "target": 1,
    "idx": 1031754,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "// context\nstatic int\nmemory_bstat (bfd *abfd, struct stat *statbuf)\n{\n  struct bfd_in_memory *bim = (struct bfd_in_memory *) abfd->iostream;\n\n  memset (statbuf, 0, sizeof (*statbuf));\n  statbuf->st_size = bim->size;\n\n  return 0;\n}\n\nint\nbfd_stat (bfd *abfd, struct stat *statbuf)\n{\n  int result;\n\n  while (abfd->my_archive != NULL\n\t && !bfd_is_thin_archive (abfd->my_archive))\n    abfd = abfd->my_archive;\n\n  if (abfd->iovec == NULL)\n    {\n      bfd_set_error (bfd_error_invalid_operation);\n      return -1;\n    }\n\n  result = abfd->iovec->bstat (abfd, statbuf);\n  if (result < 0)\n    bfd_set_error (bfd_error_system_call);\n  return result;\n}\n\nufile_ptr\nbfd_get_size (bfd *abfd)\n{\n  /* A size of 0 means we haven't yet called bfd_stat.  A size of 1\n     means we have a cached value of 0, ie. unknown.  */\n  if (abfd->size <= 1 || bfd_write_p (abfd))\n    {\n      struct stat buf;\n\n      if (abfd->size == 1 && !bfd_write_p (abfd))\n\treturn 0;\n\n      if (bfd_stat (abfd, &buf) != 0\n\t  || buf.st_size == 0\n\t  || buf.st_size - (ufile_ptr) buf.st_size != 0)\n\t{\n\t  abfd->size = 1;\n\t  return 0;\n\t}\n      abfd->size = buf.st_size;\n    }\n  return abfd->size;\n}\n\nufile_ptr\nbfd_get_file_size (bfd *abfd)\n{\n  ufile_ptr file_size, archive_size = (ufile_ptr) -1;\n  unsigned int compression_p2 = 0;\n\n  if (abfd->my_archive != NULL\n      && !bfd_is_thin_archive (abfd->my_archive))\n    {\n      struct areltdata *adata = (struct areltdata *) abfd->arelt_data;\n      if (adata != NULL)\n\t{\n\t  archive_size = adata->parsed_size;\n\t  /* If the archive is compressed, assume an element won't\n\t     expand more than eight times file size.  */\n\t  if (adata->arch_header != NULL\n\t      && memcmp (((struct ar_hdr *) adata->arch_header)->ar_fmag,\n\t\t\t \"Z\\012\", 2) == 0)\n\t    compression_p2 = 3;\n\t  abfd = abfd->my_archive;\n\t}\n    }\n\n  file_size = bfd_get_size (abfd) << compression_p2;\n  if (archive_size < file_size)\n    return archive_size;\n  return file_size;\n}\n\nlong\ncoff_get_reloc_upper_bound (bfd *abfd, sec_ptr asect)\n{\n  size_t count, raw;\n\n  count = asect->reloc_count;\n  if (count >= LONG_MAX / sizeof (arelent *)\n      || _bfd_mul_overflow (count, bfd_coff_relsz (abfd), &raw))\n    {\n      bfd_set_error (bfd_error_file_too_big);\n      return -1;\n    }\n  if (!bfd_write_p (abfd))\n    {\n      ufile_ptr filesize = bfd_get_file_size (abfd);\n      if (filesize != 0 && raw > filesize)\n\t{\n\t  bfd_set_error (bfd_error_file_truncated);\n\t  return -1;\n\t}\n    }\n  return (count + 1) * sizeof (arelent *);\n}\n\n\n*/\n\nlong\nbfd_get_reloc_upper_bound (bfd *abfd, sec_ptr asect)\n{\n  if (abfd->format != bfd_object)\n    {\n      bfd_set_error (bfd_error_invalid_operation);\n      return -1;\n    }\n\nvoid\nbfd_map_over_sections (bfd *abfd,\n\t\t       void (*operation) (bfd *, asection *, void *),\n\t\t       void *user_storage)\n{\n  asection *sect;\n  unsigned int i = 0;\n\n  for (sect = abfd->sections; sect != NULL; i++, sect = sect->next)\n    (*operation) (abfd, sect, user_storage);\n\n  if (i != abfd->section_count)\t/* Debugging */\n    abort ();\n}\n\n\n// target function\nstatic void\nio_reinit (bfd *abfd, struct bfd_preserve *preserve)\n{\n  if (abfd->iovec != preserve->iovec)\n    {\n      /* Handle file backed to in-memory transition.  bfd_cache_close\n\t won't do anything unless abfd->iovec is the cache_iovec.  */\n      bfd_cache_close (abfd);\n      abfd->iovec = preserve->iovec;\n\n      if (abfd->iostream != preserve->iostream)\n\t{\n\t  if ((abfd->flags & BFD_IN_MEMORY) != 0)\n\t    free (abfd->iostream);\n\t  abfd->iostream = preserve->iostream;\n\t}\n\n      /* Handle in-memory to file backed transition.  */\n      if ((abfd->flags & BFD_CLOSED_BY_CACHE) != 0\n\t  && (abfd->flags & BFD_IN_MEMORY) != 0\n\t  && (preserve->flags & BFD_CLOSED_BY_CACHE) == 0\n\t  && (preserve->flags & BFD_IN_MEMORY) == 0)\n\tbfd_open_file (abfd);\n    }\n  abfd->flags = preserve->flags;\n}\nstatic void\n_bfd_delete_bfd (bfd *abfd)\n{\n  /* Give the target _bfd_free_cached_info a chance to free memory.  */\n  if (abfd->memory && abfd->xvec)\n    bfd_free_cached_info (abfd);\n\n  /* The target _bfd_free_cached_info may not have done anything..  */\n  if (abfd->memory)\n    {\n      bfd_hash_table_free (&abfd->section_htab);\n      objalloc_free ((struct objalloc *) abfd->memory);\n    }\n  else\n    free ((char *) bfd_get_filename (abfd));\n\n  if ((abfd->flags & BFD_IN_MEMORY) != 0)\n    free (abfd->iostream);\n  free (abfd->arelt_data);\n  free (abfd);\n}\n",
    "target": 1,
    "idx": 1065108,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\n\n\nint __cil_ordered_lists_merge(struct cil_list *old, struct cil_list *new)\n{\n\tstruct cil_list_item *omatch = NULL;\n\tstruct cil_list_item *ofirst = old->head;\n\tstruct cil_list_item *ocurr = NULL;\n\tstruct cil_list_item *oprev = NULL;\n\tstruct cil_list_item *nmatch = NULL;\n\tstruct cil_list_item *nfirst = new->head;\n\tstruct cil_list_item *ncurr = NULL;\n\tint rc = SEPOL_ERR;\n\n\tif (nfirst == NULL) {\n\t\treturn SEPOL_OK;\n\t}\n\n\tif (ofirst == NULL) {\n\t\t/* First list added */\n\t\trc = __cil_ordered_list_insert(old, NULL, nfirst, NULL);\n\t\treturn rc;\n\t}\n\n\t/* Find a match between the new list and the old one */\n\tfor (nmatch = nfirst; nmatch; nmatch = nmatch->next) {\n\t\tomatch = __cil_ordered_find_match(nmatch, ofirst);\n\t\tif (omatch) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!nmatch) {\n\t\t/* List cannot be merged yet */\n\t\treturn SEPOL_ERR;\n\t}\n\n\tif (nmatch != nfirst && omatch != ofirst) {\n\t\t/* Potential ordering conflict--try again later */\n\t\treturn SEPOL_ERR;\n\t}\n\n\tif (nmatch != nfirst) {\n\t\t/* Prepend the beginning of the new list up to the first match to the old list */\n\t\trc = __cil_ordered_list_insert(old, NULL, nfirst, nmatch);\n\t\tif (rc != SEPOL_OK) {\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\t/* In the overlapping protion, add items from the new list not in the old list */\n\tncurr = nmatch->next;\n\tocurr = omatch->next;\n\toprev = omatch;\n\twhile (ncurr && ocurr) {\n\t\tif (ncurr->data == ocurr->data) {\n\t\t\toprev = ocurr;\n\t\t\tocurr = ocurr->next;\n\t\t\tncurr = ncurr->next;\n\t\t} else {\n\t\t\t/* Handle gap in old: old = (A C)  new = (A B C) */\n\t\t\tnmatch = __cil_ordered_find_match(ocurr, ncurr->next);\n\t\t\tif (nmatch) {\n\t\t\t\trc = __cil_ordered_list_insert(old, oprev, ncurr, nmatch);\n\t\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\t\treturn rc;\n\t\t\t\t}\n\t\t\t\toprev = ocurr;\n\t\t\t\tocurr = ocurr->next;\n\t\t\t\tncurr = nmatch->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Handle gap in new: old = (A B C)  new = (A C) */\n\t\t\tomatch = __cil_ordered_find_match(ncurr, ocurr->next);\n\t\t\tif (omatch) {\n\t\t\t\t/* Nothing to insert, just skip */\n\t\t\t\toprev = omatch;\n\t\t\t\tocurr = omatch->next;\n\t\t\t\tncurr = ncurr->next;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\treturn SEPOL_ERR;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ncurr) {\n\t\t/* Add the rest of the items from the new list */\n\t\trc = __cil_ordered_list_insert(old, old->tail, ncurr, NULL);\n\t\tif (rc != SEPOL_OK) {\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n}\n\nint __cil_resolve_ast_last_child_helper(struct cil_tree_node *current, void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_args_resolve *args = extra_args;\n\tstruct cil_tree_node *parent = NULL;\n\tstruct cil_tree_node *blockstack = NULL;\n\n\tif (current == NULL ||  extra_args == NULL) {\n\t\tgoto exit;\n\t}\n\n\tparent = current->parent;\n\n\tif (parent->flavor == CIL_MACRO) {\n\t\targs->macro = NULL;\n\t} else if (parent->flavor == CIL_OPTIONAL) {\n\t\tstruct cil_tree_node *optstack;\n\n\t\tif (((struct cil_optional *)parent->data)->enabled == CIL_FALSE) {\n\t\t\t*(args->changed) = CIL_TRUE;\n\t\t\tcil_list_append(args->disabled_optionals, CIL_NODE, parent);\n\t\t}\n\n\t\t/* pop off the stack */\n\t\toptstack = args->optstack;\n\t\targs->optstack = optstack->cl_head;\n\t\tif (optstack->cl_head) {\n\t\t\toptstack->cl_head->parent = NULL;\n\t\t}\n\t\tfree(optstack);\n\t} else if (parent->flavor == CIL_BOOLEANIF) {\n\t\targs->boolif = NULL;\n\t} else if (parent->flavor == CIL_BLOCK) {\n\t\t/* pop off the stack */\n\t\tblockstack = args->blockstack;\n\t\targs->blockstack = blockstack->cl_head;\n\t\tif (blockstack->cl_head) {\n\t\t\tblockstack->cl_head->parent = NULL;\n\t\t}\n\t\tfree(blockstack);\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_compile(struct cil_db *db)\n{\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL) {\n\t\tgoto exit;\n\t}\n\n\tcil_log(CIL_INFO, \"Building AST from Parse Tree\\n\");\n\trc = cil_build_ast(db, db->parse->root, db->ast->root);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_INFO, \"Failed to build ast\\n\");\n\t\tgoto exit;\n\t}\n\n\tcil_log(CIL_INFO, \"Destroying Parse Tree\\n\");\n\tcil_tree_destroy(&db->parse);\n\n\tcil_log(CIL_INFO, \"Resolving AST\\n\");\n\trc = cil_resolve_ast(db, db->ast->root);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_INFO, \"Failed to resolve ast\\n\");\n\t\tgoto exit;\n\t}\n\n\tcil_log(CIL_INFO, \"Qualifying Names\\n\");\n\trc = cil_fqn_qualify(db->ast->root);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_INFO, \"Failed to qualify names\\n\");\n\t\tgoto exit;\n\t}\n\n\tcil_log(CIL_INFO, \"Compile post process\\n\");\n\trc = cil_post_process(db);\n\tif (rc != SEPOL_OK ) {\n\t\tcil_log(CIL_INFO, \"Post process failed\\n\");\n\t\tgoto exit;\n\t}\n\nexit:\n\n\treturn rc;\n}\n\n\n// target function\nint __cil_resolve_ast_last_child_helper(struct cil_tree_node *current, void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_args_resolve *args = extra_args;\n\tstruct cil_tree_node *parent = NULL;\n\tstruct cil_tree_node *blockstack = NULL;\n\n\tif (current == NULL ||  extra_args == NULL) {\n\t\tgoto exit;\n\t}\n\n\tparent = current->parent;\n\n\tif (parent->flavor == CIL_MACRO) {\n\t\targs->macro = NULL;\n\t} else if (parent->flavor == CIL_OPTIONAL) {\n\t\tstruct cil_tree_node *optstack;\n\n\t\tif (((struct cil_optional *)parent->data)->enabled == CIL_FALSE) {\n\t\t\t*(args->changed) = CIL_TRUE;\n\t\t\tcil_tree_children_destroy(parent);\n\t\t}\n\n\t\t/* pop off the stack */\n\t\toptstack = args->optstack;\n\t\targs->optstack = optstack->cl_head;\n\t\tif (optstack->cl_head) {\n\t\t\toptstack->cl_head->parent = NULL;\n\t\t}\n\t\tfree(optstack);\n\t} else if (parent->flavor == CIL_BOOLEANIF) {\n\t\targs->boolif = NULL;\n\t} else if (parent->flavor == CIL_BLOCK) {\n\t\t/* pop off the stack */\n\t\tblockstack = args->blockstack;\n\t\targs->blockstack = blockstack->cl_head;\n\t\tif (blockstack->cl_head) {\n\t\t\tblockstack->cl_head->parent = NULL;\n\t\t}\n\t\tfree(blockstack);\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n",
    "target": 1,
    "idx": 1028478,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nvoid\nUA_SecureChannel_deleteMembersCleanup(UA_SecureChannel *channel) {\n    /* Delete members */\n    UA_ByteString_deleteMembers(&channel->remoteCertificate);\n    UA_ByteString_deleteMembers(&channel->localNonce);\n    UA_ByteString_deleteMembers(&channel->remoteNonce);\n    UA_ChannelSecurityToken_deleteMembers(&channel->securityToken);\n    UA_ChannelSecurityToken_deleteMembers(&channel->nextSecurityToken);\n\n    /* Delete the channel context for the security policy */\n    if(channel->securityPolicy)\n        channel->securityPolicy->channelModule.deleteContext(channel->channelContext);\n\n    /* Detach from the connection and close the connection */\n    if(channel->connection) {\n        if(channel->connection->state != UA_CONNECTION_CLOSED)\n            channel->connection->close(channel->connection);\n        UA_Connection_detachSecureChannel(channel->connection);\n    }\n\n    /* Remove session pointers (not the sessions) and NULL the pointers back to\n     * the SecureChannel in the Session */\n    UA_SessionHeader *sh, *temp;\n    LIST_FOREACH_SAFE(sh, &channel->sessions, pointers, temp) {\n        sh->channel = NULL;\n        LIST_REMOVE(sh, pointers);\n    }\n\n    /* Remove the buffered chunks */\n    struct ChunkEntry *ch, *temp_ch;\n    LIST_FOREACH_SAFE(ch, &channel->chunks, pointers, temp_ch) {\n        UA_ByteString_deleteMembers(&ch->bytes);\n        LIST_REMOVE(ch, pointers);\n        UA_free(ch);\n    }\n}\n\nvoid UA_SecureChannelManager_deleteMembers(UA_SecureChannelManager* cm) {\n    channel_list_entry *entry, *temp;\n    LIST_FOREACH_SAFE(entry, &cm->channels, pointers, temp) {\n        LIST_REMOVE(entry, pointers);\n        UA_SecureChannel_deleteMembersCleanup(&entry->channel);\n        UA_free(entry);\n    }\n}\n\nvoid UA_Server_delete(UA_Server *server) {\n    /* Delete all internal data */\n    UA_SecureChannelManager_deleteMembers(&server->secureChannelManager);\n    UA_SessionManager_deleteMembers(&server->sessionManager);\n    UA_Array_delete(server->namespaces, server->namespacesSize, &UA_TYPES[UA_TYPES_STRING]);\n\n#ifdef UA_ENABLE_DISCOVERY\n    registeredServer_list_entry *rs, *rs_tmp;\n    LIST_FOREACH_SAFE(rs, &server->registeredServers, pointers, rs_tmp) {\n        LIST_REMOVE(rs, pointers);\n        UA_RegisteredServer_deleteMembers(&rs->registeredServer);\n        UA_free(rs);\n    }\n    periodicServerRegisterCallback_entry *ps, *ps_tmp;\n    LIST_FOREACH_SAFE(ps, &server->periodicServerRegisterCallbacks, pointers, ps_tmp) {\n        LIST_REMOVE(ps, pointers);\n        UA_free(ps->callback);\n        UA_free(ps);\n    }\n\n# ifdef UA_ENABLE_DISCOVERY_MULTICAST\n    if(server->config.applicationDescription.applicationType == UA_APPLICATIONTYPE_DISCOVERYSERVER)\n        destroyMulticastDiscoveryServer(server);\n\n    serverOnNetwork_list_entry *son, *son_tmp;\n    LIST_FOREACH_SAFE(son, &server->serverOnNetwork, pointers, son_tmp) {\n        LIST_REMOVE(son, pointers);\n        UA_ServerOnNetwork_deleteMembers(&son->serverOnNetwork);\n        if(son->pathTmp)\n            UA_free(son->pathTmp);\n        UA_free(son);\n    }\n\n    for(size_t i = 0; i < SERVER_ON_NETWORK_HASH_PRIME; i++) {\n        serverOnNetwork_hash_entry* currHash = server->serverOnNetworkHash[i];\n        while(currHash) {\n            serverOnNetwork_hash_entry* nextHash = currHash->next;\n            UA_free(currHash);\n            currHash = nextHash;\n        }\n    }\n# endif\n\n#endif\n\n#ifdef UA_ENABLE_MULTITHREADING\n    pthread_cond_destroy(&server->dispatchQueue_condition);\n    pthread_mutex_destroy(&server->dispatchQueue_mutex);\n#endif\n\n    /* Delete the timed work */\n    UA_Timer_deleteMembers(&server->timer);\n\n    /* Delete the server itself */\n    UA_free(server);\n}\n\n\n// target function\nstatic UA_StatusCode\nremoveSession(UA_SessionManager *sm, session_list_entry *sentry) {\n    /* Deactivate the session */\n    sentry->session.activated = false;\n\n    /* Add a delayed callback to remove the session when the currently\n     * scheduled jobs have completed */\n    UA_StatusCode retval = UA_Server_delayedCallback(sm->server, removeSessionCallback, sentry);\n    if(retval != UA_STATUSCODE_GOOD) {\n        UA_LOG_WARNING_SESSION(sm->server->config.logger, &sentry->session,\n                       \"Could not remove session with error code %s\",\n                       UA_StatusCode_name(retval));\n        return retval; /* Try again next time */\n    }\n\n    /* Detach the session and make the capacity available */\n    LIST_REMOVE(sentry, pointers);\n    UA_atomic_add(&sm->currentSessionCount, (UA_UInt32)-1);\n    return UA_STATUSCODE_GOOD;\n}\n",
    "target": 1,
    "idx": 1005504,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nvoid\nUA_Subscription_answerPublishRequestsNoSubscription(UA_Server *server,\n                                                    UA_Session *session) {\n    /* No session or there are remaining subscriptions */\n    if(!session || LIST_FIRST(&session->serverSubscriptions))\n        return;\n\n    /* Send a response for every queued request */\n    UA_PublishResponseEntry *pre;\n    while((pre = SIMPLEQ_FIRST(&session->responseQueue))) {\n        SIMPLEQ_REMOVE_HEAD(&session->responseQueue, listEntry);\n        UA_PublishResponse *response = &pre->response;\n        response->responseHeader.serviceResult = UA_STATUSCODE_BADNOSUBSCRIPTION;\n        response->responseHeader.timestamp = UA_DateTime_now();\n        UA_SecureChannel_sendSymmetricMessage(session->channel, pre->requestId,\n                                              UA_MESSAGETYPE_MSG, response,\n                                              &UA_TYPES[UA_TYPES_PUBLISHRESPONSE]);\n        UA_PublishResponse_deleteMembers(response);\n        UA_free(pre);\n    }\n}\n\nstatic void\nprocessDelayedCallbacks(UA_Server *server) {\n    UA_DelayedCallback *dc, *dc_tmp;\n    SLIST_FOREACH_SAFE(dc, &server->delayedCallbacks, next, dc_tmp) {\n        SLIST_REMOVE(&server->delayedCallbacks, dc, UA_DelayedCallback, next);\n        dc->callback(server, dc->data);\n        UA_free(dc);\n    }\n}\n\n\n// target function\nvoid\nService_DeleteSubscriptions(UA_Server *server, UA_Session *session,\n                            const UA_DeleteSubscriptionsRequest *request,\n                            UA_DeleteSubscriptionsResponse *response) {\n    UA_LOG_DEBUG_SESSION(server->config.logger, session,\n                         \"Processing DeleteSubscriptionsRequest\");\n\n    response->responseHeader.serviceResult = \n        UA_Server_processServiceOperations(server, session,\n                  (UA_ServiceOperation)Operation_DeleteSubscription,\n                  &request->subscriptionIdsSize, &UA_TYPES[UA_TYPES_UINT32],\n                  &response->resultsSize, &UA_TYPES[UA_TYPES_STATUSCODE]);\n\n    /* The session has at least one subscription */\n    if(LIST_FIRST(&session->serverSubscriptions))\n        return;\n\n    /* Send remaining publish responses in a delayed callback if the last\n     * subscription was removed */\n    UA_Server_delayedCallback(server, (UA_ServerCallback)\n                              UA_Subscription_answerPublishRequestsNoSubscription,\n                              session);\n}\n",
    "target": 1,
    "idx": 1004097,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nRefPtr<StringImpl> StringImpl::create(ReadonlyBytes bytes, ShouldChomp shouldChomp)\n{\n    return StringImpl::create(reinterpret_cast<const char*>(bytes.data()), bytes.size(), shouldChomp);\n}\n\n    String(NonnullRefPtr<StringImpl>&& impl)\n        : m_impl(move(impl))\n    {\n    }\n\nOptional<URL> URLParser::parse_data_url(StringView const& raw_input)\n{\n    dbgln_if(URL_PARSER_DEBUG, \"URLParser::parse_data_url: Parsing '{}'.\", raw_input);\n    VERIFY(raw_input.starts_with(\"data:\"));\n    auto input = raw_input.substring_view(5);\n    auto comma_offset = input.find(',');\n    if (!comma_offset.has_value())\n        return {};\n    auto mime_type = StringUtils::trim(input.substring_view(0, comma_offset.value()), \"\\t\\n\\f\\r \", TrimMode::Both);\n    auto encoded_body = input.substring_view(comma_offset.value() + 1);\n    auto body = URL::percent_decode(encoded_body);\n    bool is_base64_encoded = false;\n    if (mime_type.ends_with(\"base64\", CaseSensitivity::CaseInsensitive)) {\n        auto substring_view = mime_type.substring_view(0, mime_type.length() - 6);\n        auto trimmed_substring_view = StringUtils::trim(substring_view, \" \", TrimMode::Right);\n        if (trimmed_substring_view.ends_with(';')) {\n            is_base64_encoded = true;\n            mime_type = trimmed_substring_view.substring_view(0, trimmed_substring_view.length() - 1);\n        }\n    }\n\n    StringBuilder builder;\n    if (mime_type.starts_with(\";\") || mime_type.is_empty()) {\n        builder.append(\"text/plain\");\n        builder.append(mime_type);\n        mime_type = builder.string_view();\n    }\n\n    // FIXME: Parse the MIME type's components according to https://mimesniff.spec.whatwg.org/#parse-a-mime-type\n    URL url { StringUtils::trim(mime_type, \"\\n\\r\\t \", TrimMode::Both), move(body), is_base64_encoded };\n    dbgln_if(URL_PARSER_DEBUG, \"URLParser::parse_data_url: Parsed data URL to be '{}'.\", url.serialize());\n    return url;\n}\n\nstatic Optional<String> parse_host(StringView const& input, bool is_not_special = false)\n{\n    if (input.starts_with('[')) {\n        if (!input.ends_with(']')) {\n            report_validation_error();\n            return {};\n        }\n        // FIXME: Return the result of IPv6 parsing input with its leading U+005B ([) and trailing U+005D (]) removed.\n        TODO();\n    }\n\n    if (is_not_special)\n        return parse_opaque_host(input);\n    VERIFY(!input.is_empty());\n\n    // FIXME: Let domain be the result of running UTF-8 decode without BOM on the percent-decoding of input.\n    auto domain = URL::percent_decode(input);\n    // FIXME: Let asciiDomain be the result of running domain to ASCII on domain.\n    auto& ascii_domain = domain;\n\n    auto forbidden_host_code_points = \"\\0\\t\\n\\r #%/:<>?@[\\\\]^|\"sv;\n    for (auto code_point : forbidden_host_code_points) {\n        if (ascii_domain.view().contains(code_point)) {\n            report_validation_error();\n            return {};\n        }\n    }\n\n    auto ipv4_host = parse_ipv4_address(ascii_domain);\n    return ipv4_host;\n}\n\nURL::URL(StringView const& string)\n    : URL(URLParser::parse({}, string))\n{\n    if constexpr (URL_PARSER_DEBUG) {\n        if (m_valid)\n            dbgln(\"URL constructor: Parsed URL to be '{}'.\", serialize());\n        else\n            dbgln(\"URL constructor: Parsed URL to be invalid.\");\n    }\n}\n\n\n// target function\nOptional<URL> URLParser::parse_data_url(StringView const& raw_input)\n{\n    dbgln_if(URL_PARSER_DEBUG, \"URLParser::parse_data_url: Parsing '{}'.\", raw_input);\n    VERIFY(raw_input.starts_with(\"data:\"));\n    auto input = raw_input.substring_view(5);\n    auto comma_offset = input.find(',');\n    if (!comma_offset.has_value())\n        return {};\n    auto mime_type = input.substring_view(0, comma_offset.value());\n    // FIXME: Strip leading and trailing ASCII whitespace from mimeType\n    auto encoded_body = input.substring_view(comma_offset.value() + 1);\n    auto body = URL::percent_decode(encoded_body);\n    bool is_base_64_encoded = false;\n    if (mime_type.ends_with(\";base64\", CaseSensitivity::CaseInsensitive)) {\n        is_base_64_encoded = true;\n        mime_type = mime_type.substring_view(0, mime_type.length() - 7);\n    }\n\n    if (mime_type.starts_with(\";\")) {\n        StringBuilder builder;\n        builder.append(\"text/plain\");\n        builder.append(mime_type);\n        mime_type = builder.to_string();\n    }\n\n    URL url { mime_type, move(body), is_base_64_encoded };\n    dbgln_if(URL_PARSER_DEBUG, \"URLParser::parse_data_url: Parsed data URL to be '{}'.\", url.serialize());\n    return url;\n}\n",
    "target": 1,
    "idx": 1034973,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "// context\n  bool Write(const void *data, size_t length) {\n    if (!length) return false;\n\n    const size_t orig_length = length;\n    size_t offset = 0;\n\n    size_t chksum_offset = Tell() & 3;\n    if (chksum_offset) {\n      const size_t l = std::min(length, static_cast<size_t>(4) - chksum_offset);\n      uint32_t tmp = 0;\n      std::memcpy(reinterpret_cast<uint8_t *>(&tmp) + chksum_offset, data, l);\n      chksum_ += ntohl(tmp);\n      length -= l;\n      offset += l;\n    }\n\n    while (length >= 4) {\n      uint32_t tmp;\n      std::memcpy(&tmp, reinterpret_cast<const uint8_t *>(data) + offset,\n        sizeof(uint32_t));\n      chksum_ += ntohl(tmp);\n      length -= 4;\n      offset += 4;\n    }\n\n    if (length) {\n      if (length > 4) return false;  // not reached\n      uint32_t tmp = 0;\n      std::memcpy(&tmp,\n                  reinterpret_cast<const uint8_t*>(data) + offset, length);\n      chksum_ += ntohl(tmp);\n    }\n\n    return WriteRaw(data, orig_length);\n  }\n\nbool OpenTypeCMAP::Serialize(OTSStream *out) {\n  const bool have_034 = this->subtable_0_3_4_data != NULL;\n  const bool have_0514 = this->subtable_0_5_14.size() != 0;\n  const bool have_100 = this->subtable_1_0_0.size() != 0;\n  const bool have_304 = this->subtable_3_0_4_data != NULL;\n  // MS Symbol and MS Unicode tables should not co-exist.\n  // See the comment above in 0-0-4 parser.\n  const bool have_314 = (!have_304) && this->subtable_3_1_4_data;\n  const bool have_31012 = this->subtable_3_10_12.size() != 0;\n  const bool have_31013 = this->subtable_3_10_13.size() != 0;\n  const uint16_t num_subtables = static_cast<uint16_t>(have_034) +\n                                 static_cast<uint16_t>(have_0514) +\n                                 static_cast<uint16_t>(have_100) +\n                                 static_cast<uint16_t>(have_304) +\n                                 static_cast<uint16_t>(have_314) +\n                                 static_cast<uint16_t>(have_31012) +\n                                 static_cast<uint16_t>(have_31013);\n  const off_t table_start = out->Tell();\n\n  // Some fonts don't have 3-0-4 MS Symbol nor 3-1-4 Unicode BMP tables\n  // (e.g., old fonts for Mac). We don't support them.\n  if (!have_304 && !have_314 && !have_034 && !have_31012 && !have_31013) {\n    return Error(\"no supported subtables were found\");\n  }\n\n  if (!out->WriteU16(0) ||\n      !out->WriteU16(num_subtables)) {\n    return OTS_FAILURE();\n  }\n\n  const off_t record_offset = out->Tell();\n  if (!out->Pad(num_subtables * 8)) {\n    return OTS_FAILURE();\n  }\n\n  const off_t offset_034 = out->Tell();\n  if (have_034) {\n    if (!out->Write(this->subtable_0_3_4_data,\n                    this->subtable_0_3_4_length)) {\n      return OTS_FAILURE();\n    }\n  }\n\n  const off_t offset_0514 = out->Tell();\n  if (have_0514) {\n    const std::vector<ots::OpenTypeCMAPSubtableVSRecord> &records\n        = this->subtable_0_5_14;\n    const unsigned num_records = records.size();\n    if (!out->WriteU16(14) ||\n        !out->WriteU32(this->subtable_0_5_14_length) ||\n        !out->WriteU32(num_records)) {\n      return OTS_FAILURE();\n    }\n    for (unsigned i = 0; i < num_records; ++i) {\n      if (!out->WriteU24(records[i].var_selector) ||\n          !out->WriteU32(records[i].default_offset) ||\n          !out->WriteU32(records[i].non_default_offset)) {\n        return OTS_FAILURE();\n      }\n    }\n    for (unsigned i = 0; i < num_records; ++i) {\n      if (records[i].default_offset) {\n        const std::vector<ots::OpenTypeCMAPSubtableVSRange> &ranges\n            = records[i].ranges;\n        const unsigned num_ranges = ranges.size();\n        if (!out->Seek(records[i].default_offset + offset_0514) ||\n            !out->WriteU32(num_ranges)) {\n          return OTS_FAILURE();\n        }\n        for (unsigned j = 0; j < num_ranges; ++j) {\n          if (!out->WriteU24(ranges[j].unicode_value) ||\n              !out->WriteU8(ranges[j].additional_count)) {\n            return OTS_FAILURE();\n          }\n        }\n      }\n      if (records[i].non_default_offset) {\n        const std::vector<ots::OpenTypeCMAPSubtableVSMapping> &mappings\n            = records[i].mappings;\n        const unsigned num_mappings = mappings.size();\n        if (!out->Seek(records[i].non_default_offset + offset_0514) ||\n            !out->WriteU32(num_mappings)) {\n          return OTS_FAILURE();\n        }\n        for (unsigned j = 0; j < num_mappings; ++j) {\n          if (!out->WriteU24(mappings[j].unicode_value) ||\n              !out->WriteU16(mappings[j].glyph_id)) {\n            return OTS_FAILURE();\n          }\n        }\n      }\n    }\n  }\n\n  const off_t offset_100 = out->Tell();\n  if (have_100) {\n    if (!out->WriteU16(0) ||  // format\n        !out->WriteU16(6 + kFormat0ArraySize) ||  // length\n        !out->WriteU16(0)) {  // language\n      return OTS_FAILURE();\n    }\n    if (!out->Write(&(this->subtable_1_0_0[0]), kFormat0ArraySize)) {\n      return OTS_FAILURE();\n    }\n  }\n\n  const off_t offset_304 = out->Tell();\n  if (have_304) {\n    if (!out->Write(this->subtable_3_0_4_data,\n                    this->subtable_3_0_4_length)) {\n      return OTS_FAILURE();\n    }\n  }\n\n  const off_t offset_314 = out->Tell();\n  if (have_314) {\n    if (!out->Write(this->subtable_3_1_4_data,\n                    this->subtable_3_1_4_length)) {\n      return OTS_FAILURE();\n    }\n  }\n\n  const off_t offset_31012 = out->Tell();\n  if (have_31012) {\n    std::vector<OpenTypeCMAPSubtableRange> &groups\n        = this->subtable_3_10_12;\n    const unsigned num_groups = groups.size();\n    if (!out->WriteU16(12) ||\n        !out->WriteU16(0) ||\n        !out->WriteU32(num_groups * 12 + 16) ||\n        !out->WriteU32(0) ||\n        !out->WriteU32(num_groups)) {\n      return OTS_FAILURE();\n    }\n\n    for (unsigned i = 0; i < num_groups; ++i) {\n      if (!out->WriteU32(groups[i].start_range) ||\n          !out->WriteU32(groups[i].end_range) ||\n          !out->WriteU32(groups[i].start_glyph_id)) {\n        return OTS_FAILURE();\n      }\n    }\n  }\n\n  const off_t offset_31013 = out->Tell();\n  if (have_31013) {\n    std::vector<OpenTypeCMAPSubtableRange> &groups\n        = this->subtable_3_10_13;\n    const unsigned num_groups = groups.size();\n    if (!out->WriteU16(13) ||\n        !out->WriteU16(0) ||\n        !out->WriteU32(num_groups * 12 + 16) ||\n        !out->WriteU32(0) ||\n        !out->WriteU32(num_groups)) {\n      return OTS_FAILURE();\n    }\n\n    for (unsigned i = 0; i < num_groups; ++i) {\n      if (!out->WriteU32(groups[i].start_range) ||\n          !out->WriteU32(groups[i].end_range) ||\n          !out->WriteU32(groups[i].start_glyph_id)) {\n        return OTS_FAILURE();\n      }\n    }\n  }\n\n  const off_t table_end = out->Tell();\n\n  // Now seek back and write the table of offsets\n  if (!out->Seek(record_offset)) {\n    return OTS_FAILURE();\n  }\n\n  if (have_034) {\n    if (!out->WriteU16(0) ||\n        !out->WriteU16(3) ||\n        !out->WriteU32(offset_034 - table_start)) {\n      return OTS_FAILURE();\n    }\n  }\n\n  if (have_0514) {\n    if (!out->WriteU16(0) ||\n        !out->WriteU16(5) ||\n        !out->WriteU32(offset_0514 - table_start)) {\n      return OTS_FAILURE();\n    }\n  }\n\n  if (have_100) {\n    if (!out->WriteU16(1) ||\n        !out->WriteU16(0) ||\n        !out->WriteU32(offset_100 - table_start)) {\n      return OTS_FAILURE();\n    }\n  }\n\n  if (have_304) {\n    if (!out->WriteU16(3) ||\n        !out->WriteU16(0) ||\n        !out->WriteU32(offset_304 - table_start)) {\n      return OTS_FAILURE();\n    }\n  }\n\n  if (have_314) {\n    if (!out->WriteU16(3) ||\n        !out->WriteU16(1) ||\n        !out->WriteU32(offset_314 - table_start)) {\n      return OTS_FAILURE();\n    }\n  }\n\n  if (have_31012) {\n    if (!out->WriteU16(3) ||\n        !out->WriteU16(10) ||\n        !out->WriteU32(offset_31012 - table_start)) {\n      return OTS_FAILURE();\n    }\n  }\n\n  if (have_31013) {\n    if (!out->WriteU16(3) ||\n        !out->WriteU16(10) ||\n        !out->WriteU32(offset_31013 - table_start)) {\n      return OTS_FAILURE();\n    }\n  }\n\n  if (!out->Seek(table_end)) {\n    return OTS_FAILURE();\n  }\n\n  return true;\n}\n\nbool ProcessGeneric(ots::FontFile *header,\n                    ots::Font *font,\n                    uint32_t signature,\n                    ots::OTSStream *output,\n                    const uint8_t *data, size_t length,\n                    const std::vector<ots::TableEntry>& tables,\n                    ots::Buffer& file) {\n  const size_t data_offset = file.offset();\n\n  uint32_t uncompressed_sum = 0;\n\n  for (unsigned i = 0; i < font->num_tables; ++i) {\n    // the tables must be sorted by tag (when taken as big-endian numbers).\n    // This also remove the possibility of duplicate tables.\n    if (i) {\n      const uint32_t this_tag = tables[i].tag;\n      const uint32_t prev_tag = tables[i - 1].tag;\n      if (this_tag <= prev_tag) {\n        OTS_WARNING_MSG_HDR(\"Table directory is not correctly ordered\");\n      }\n    }\n\n    // all tag names must be built from printable ASCII characters\n    if (!CheckTag(tables[i].tag)) {\n      return OTS_FAILURE_MSG_TAG(\"invalid table tag\", tables[i].tag);\n    }\n\n    // tables must be 4-byte aligned\n    if (tables[i].offset & 3) {\n      return OTS_FAILURE_MSG_TAG(\"misaligned table\", tables[i].tag);\n    }\n\n    // and must be within the file\n    if (tables[i].offset < data_offset || tables[i].offset >= length) {\n      return OTS_FAILURE_MSG_TAG(\"invalid table offset\", tables[i].tag);\n    }\n    // disallow all tables with a zero length\n    if (tables[i].length < 1) {\n      // Note: malayalam.ttf has zero length CVT table...\n      return OTS_FAILURE_MSG_TAG(\"zero-length table\", tables[i].tag);\n    }\n    // disallow all tables with a length > 1GB\n    if (tables[i].length > 1024 * 1024 * 1024) {\n      return OTS_FAILURE_MSG_TAG(\"table length exceeds 1GB\", tables[i].tag);\n    }\n    // disallow tables where the uncompressed size is < the compressed size.\n    if (tables[i].uncompressed_length < tables[i].length) {\n      return OTS_FAILURE_MSG_TAG(\"invalid compressed table\", tables[i].tag);\n    }\n    if (tables[i].uncompressed_length > tables[i].length) {\n      // We'll probably be decompressing this table.\n\n      // disallow all tables which uncompress to > 30 MB\n      if (tables[i].uncompressed_length > 30 * 1024 * 1024) {\n        return OTS_FAILURE_MSG_TAG(\"uncompressed length exceeds 30MB\", tables[i].tag);\n      }\n      if (uncompressed_sum + tables[i].uncompressed_length < uncompressed_sum) {\n        return OTS_FAILURE_MSG_TAG(\"overflow of uncompressed sum\", tables[i].tag);\n      }\n\n      uncompressed_sum += tables[i].uncompressed_length;\n    }\n    // since we required that the file be < 1GB in length, and that the table\n    // length is < 1GB, the following addtion doesn't overflow\n    uint32_t end_byte = tables[i].offset + tables[i].length;\n    // Tables in the WOFF file must be aligned 4-byte boundary.\n    if (signature == OTS_TAG('w','O','F','F')) {\n        end_byte = ots::Round4(end_byte);\n    }\n    if (!end_byte || end_byte > length) {\n      return OTS_FAILURE_MSG_TAG(\"table overruns end of file\", tables[i].tag);\n    }\n  }\n\n  // All decompressed tables uncompressed must be <= 30MB.\n  if (uncompressed_sum > 30 * 1024 * 1024) {\n    return OTS_FAILURE_MSG_HDR(\"uncompressed sum exceeds 30MB\");\n  }\n\n  // check that the tables are not overlapping.\n  std::vector<std::pair<uint32_t, uint8_t> > overlap_checker;\n  for (unsigned i = 0; i < font->num_tables; ++i) {\n    overlap_checker.push_back(\n        std::make_pair(tables[i].offset, static_cast<uint8_t>(1) /* start */));\n    overlap_checker.push_back(\n        std::make_pair(tables[i].offset + tables[i].length,\n                       static_cast<uint8_t>(0) /* end */));\n  }\n  std::sort(overlap_checker.begin(), overlap_checker.end());\n  int overlap_count = 0;\n  for (unsigned i = 0; i < overlap_checker.size(); ++i) {\n    overlap_count += (overlap_checker[i].second ? 1 : -1);\n    if (overlap_count > 1) {\n      return OTS_FAILURE_MSG_HDR(\"overlapping tables\");\n    }\n  }\n\n  std::map<uint32_t, ots::TableEntry> table_map;\n  for (unsigned i = 0; i < font->num_tables; ++i) {\n    table_map[tables[i].tag] = tables[i];\n  }\n\n  ots::Arena arena;\n  // Parse known tables first as we need to parse them in specific order.\n  for (unsigned i = 0; ; ++i) {\n    if (supported_tables[i].tag == 0) break;\n\n    uint32_t tag = supported_tables[i].tag;\n    const auto &it = table_map.find(tag);\n    if (it == table_map.cend()) {\n      if (supported_tables[i].required) {\n        return OTS_FAILURE_MSG_TAG(\"missing required table\", tag);\n      }\n    } else {\n      if (!font->ParseTable(it->second, data, arena)) {\n        return OTS_FAILURE_MSG_TAG(\"Failed to parse table\", tag);\n      }\n    }\n  }\n\n  // Then parse any tables left.\n  for (const auto &table_entry : tables) {\n    if (!font->GetTable(table_entry.tag)) {\n      if (!font->ParseTable(table_entry, data, arena)) {\n        return OTS_FAILURE_MSG_TAG(\"Failed to parse table\", table_entry.tag);\n      }\n    }\n  }\n\n  if (font->GetTable(OTS_TAG_CFF)) {\n    // font with PostScript glyph\n    if (font->version != OTS_TAG('O','T','T','O')) {\n      return OTS_FAILURE_MSG_HDR(\"wrong font version for PostScript glyph data\");\n    }\n    if (font->GetTable(OTS_TAG_GLYF) || font->GetTable(OTS_TAG_LOCA)) {\n      // mixing outline formats is not recommended\n      return OTS_FAILURE_MSG_HDR(\"font contains both PS and TT glyphs\");\n    }\n  } else {\n    if (!font->GetTable(OTS_TAG_GLYF) || !font->GetTable(OTS_TAG_LOCA)) {\n      // No TrueType glyph found.\n      //\n      // We don't sanitize bitmap tables, but don\u2019t reject bitmap-only fonts if\n      // we are asked to pass them thru.\n      // Also don\u2019t reject if we are asked to pass glyf/loca thru.\n      if (!font->GetTable(OTS_TAG('C','B','D','T')) &&\n          !font->GetTable(OTS_TAG('C','B','L','C'))) {\n        return OTS_FAILURE_MSG_HDR(\"no supported glyph shapes table(s) present\");\n      }\n    }\n  }\n\n  uint16_t num_output_tables = 0;\n  for (const auto &it : table_map) {\n    ots::Table *table = font->GetTable(it.first);\n    if (table != NULL && table->ShouldSerialize())\n      num_output_tables++;\n  }\n\n  uint16_t max_pow2 = 0;\n  while (1u << (max_pow2 + 1) <= num_output_tables) {\n    max_pow2++;\n  }\n  const uint16_t output_search_range = (1u << max_pow2) << 4;\n\n  // most of the errors here are highly unlikely - they'd only occur if the\n  // output stream returns a failure, e.g. lack of space to write\n  output->ResetChecksum();\n  if (!output->WriteU32(font->version) ||\n      !output->WriteU16(num_output_tables) ||\n      !output->WriteU16(output_search_range) ||\n      !output->WriteU16(max_pow2) ||\n      !output->WriteU16((num_output_tables << 4) - output_search_range)) {\n    return OTS_FAILURE_MSG_HDR(\"error writing output\");\n  }\n  const uint32_t offset_table_chksum = output->chksum();\n\n  const size_t table_record_offset = output->Tell();\n  if (!output->Pad(16 * num_output_tables)) {\n    return OTS_FAILURE_MSG_HDR(\"error writing output\");\n  }\n\n  std::vector<ots::TableEntry> out_tables;\n\n  size_t head_table_offset = 0;\n  for (const auto &it : table_map) {\n    uint32_t input_offset = it.second.offset;\n    const auto &ot = header->table_entries.find(input_offset);\n    if (ot != header->table_entries.end()) {\n      ots::TableEntry out = ot->second;\n      if (out.tag == OTS_TAG('h','e','a','d')) {\n        head_table_offset = out.offset;\n      }\n      out_tables.push_back(out);\n    } else {\n      ots::TableEntry out;\n      out.tag = it.first;\n      out.offset = output->Tell();\n\n      if (out.tag == OTS_TAG('h','e','a','d')) {\n        head_table_offset = out.offset;\n      }\n\n      ots::Table *table = font->GetTable(out.tag);\n      if (table != NULL && table->ShouldSerialize()) {\n        output->ResetChecksum();\n        if (!table->Serialize(output)) {\n          return OTS_FAILURE_MSG_TAG(\"failed to serialize table\", out.tag);\n        }\n\n        const size_t end_offset = output->Tell();\n        if (end_offset <= out.offset) {\n          // paranoid check. |end_offset| is supposed to be greater than the offset,\n          // as long as the Tell() interface is implemented correctly.\n          return OTS_FAILURE_MSG_HDR(\"error writing output\");\n        }\n        out.length = end_offset - out.offset;\n\n        // align tables to four bytes\n        if (!output->Pad((4 - (end_offset & 3)) % 4)) {\n          return OTS_FAILURE_MSG_HDR(\"error writing output\");\n        }\n        out.chksum = output->chksum();\n        out_tables.push_back(out);\n        header->table_entries[input_offset] = out;\n      }\n    }\n  }\n\n  const size_t end_of_file = output->Tell();\n\n  // Need to sort the output tables for inclusion in the file\n  std::sort(out_tables.begin(), out_tables.end());\n  if (!output->Seek(table_record_offset)) {\n    return OTS_FAILURE_MSG_HDR(\"error writing output\");\n  }\n\n  output->ResetChecksum();\n  uint32_t tables_chksum = 0;\n  for (unsigned i = 0; i < out_tables.size(); ++i) {\n    if (!output->WriteU32(out_tables[i].tag) ||\n        !output->WriteU32(out_tables[i].chksum) ||\n        !output->WriteU32(out_tables[i].offset) ||\n        !output->WriteU32(out_tables[i].length)) {\n      return OTS_FAILURE_MSG_HDR(\"error writing output\");\n    }\n    tables_chksum += out_tables[i].chksum;\n  }\n  const uint32_t table_record_chksum = output->chksum();\n\n  // http://www.microsoft.com/typography/otspec/otff.htm\n  const uint32_t file_chksum\n      = offset_table_chksum + tables_chksum + table_record_chksum;\n  const uint32_t chksum_magic = static_cast<uint32_t>(0xb1b0afba) - file_chksum;\n\n  // seek into the 'head' table and write in the checksum magic value\n  if (!head_table_offset) {\n    return OTS_FAILURE_MSG_HDR(\"internal error!\");\n  }\n  if (!output->Seek(head_table_offset + 8)) {\n    return OTS_FAILURE_MSG_HDR(\"error writing output\");\n  }\n  if (!output->WriteU32(chksum_magic)) {\n    return OTS_FAILURE_MSG_HDR(\"error writing output\");\n  }\n\n  if (!output->Seek(end_of_file)) {\n    return OTS_FAILURE_MSG_HDR(\"error writing output\");\n  }\n\n  return true;\n}\n\nbool ProcessWOFF(ots::FontFile *header,\n                 ots::Font *font,\n                 ots::OTSStream *output, const uint8_t *data, size_t length) {\n  ots::Buffer file(data, length);\n\n  // we disallow all files > 1GB in size for sanity.\n  if (length > 1024 * 1024 * 1024) {\n    return OTS_FAILURE_MSG_HDR(\"file exceeds 1GB\");\n  }\n\n  uint32_t woff_tag;\n  if (!file.ReadU32(&woff_tag)) {\n    return OTS_FAILURE_MSG_HDR(\"error reading WOFF marker\");\n  }\n\n  if (woff_tag != OTS_TAG('w','O','F','F')) {\n    return OTS_FAILURE_MSG_HDR(\"invalid WOFF marker\");\n  }\n\n  if (!file.ReadU32(&font->version)) {\n    return OTS_FAILURE_MSG_HDR(\"error reading version tag\");\n  }\n  if (!ots::IsValidVersionTag(font->version)) {\n    return OTS_FAILURE_MSG_HDR(\"invalid version tag\");\n  }\n\n  uint32_t reported_length;\n  if (!file.ReadU32(&reported_length) || length != reported_length) {\n    return OTS_FAILURE_MSG_HDR(\"incorrect file size in WOFF header\");\n  }\n\n  if (!file.ReadU16(&font->num_tables) || !font->num_tables) {\n    return OTS_FAILURE_MSG_HDR(\"error reading number of tables\");\n  }\n\n  uint16_t reserved_value;\n  if (!file.ReadU16(&reserved_value) || reserved_value) {\n    return OTS_FAILURE_MSG_HDR(\"error in reserved field of WOFF header\");\n  }\n\n  uint32_t reported_total_sfnt_size;\n  if (!file.ReadU32(&reported_total_sfnt_size)) {\n    return OTS_FAILURE_MSG_HDR(\"error reading total sfnt size\");\n  }\n\n  // We don't care about these fields of the header:\n  //   uint16_t major_version, minor_version\n  if (!file.Skip(2 * 2)) {\n    return OTS_FAILURE_MSG_HDR(\"Failed to read 'majorVersion' or 'minorVersion'\");\n  }\n\n  // Checks metadata block size.\n  uint32_t meta_offset;\n  uint32_t meta_length;\n  uint32_t meta_length_orig;\n  if (!file.ReadU32(&meta_offset) ||\n      !file.ReadU32(&meta_length) ||\n      !file.ReadU32(&meta_length_orig)) {\n    return OTS_FAILURE_MSG_HDR(\"Failed to read header metadata block fields\");\n  }\n  if (meta_offset) {\n    if (meta_offset >= length || length - meta_offset < meta_length) {\n      return OTS_FAILURE_MSG_HDR(\"Invalid metadata block offset or length\");\n    }\n  }\n\n  // Checks private data block size.\n  uint32_t priv_offset;\n  uint32_t priv_length;\n  if (!file.ReadU32(&priv_offset) ||\n      !file.ReadU32(&priv_length)) {\n    return OTS_FAILURE_MSG_HDR(\"Failed to read header private block fields\");\n  }\n  if (priv_offset) {\n    if (priv_offset >= length || length - priv_offset < priv_length) {\n      return OTS_FAILURE_MSG_HDR(\"Invalid private block offset or length\");\n    }\n  }\n\n  // Next up is the list of tables.\n  std::vector<ots::TableEntry> tables;\n\n  uint32_t first_index = 0;\n  uint32_t last_index = 0;\n  // Size of sfnt header plus size of table records.\n  uint64_t total_sfnt_size = 12 + 16 * font->num_tables;\n  for (unsigned i = 0; i < font->num_tables; ++i) {\n    ots::TableEntry table;\n    if (!file.ReadU32(&table.tag) ||\n        !file.ReadU32(&table.offset) ||\n        !file.ReadU32(&table.length) ||\n        !file.ReadU32(&table.uncompressed_length) ||\n        !file.ReadU32(&table.chksum)) {\n      return OTS_FAILURE_MSG_HDR(\"error reading table directory\");\n    }\n\n    total_sfnt_size += ots::Round4(table.uncompressed_length);\n    if (total_sfnt_size > std::numeric_limits<uint32_t>::max()) {\n      return OTS_FAILURE_MSG_HDR(\"sfnt size overflow\");\n    }\n    tables.push_back(table);\n    if (i == 0 || tables[first_index].offset > table.offset)\n      first_index = i;\n    if (i == 0 || tables[last_index].offset < table.offset)\n      last_index = i;\n  }\n\n  if (reported_total_sfnt_size != total_sfnt_size) {\n    return OTS_FAILURE_MSG_HDR(\"uncompressed sfnt size mismatch\");\n  }\n\n  // Table data must follow immediately after the header.\n  if (tables[first_index].offset != ots::Round4(file.offset())) {\n    return OTS_FAILURE_MSG_HDR(\"junk before tables in WOFF file\");\n  }\n\n  if (tables[last_index].offset >= length ||\n      length - tables[last_index].offset < tables[last_index].length) {\n    return OTS_FAILURE_MSG_HDR(\"invalid table location/size\");\n  }\n  // Blocks must follow immediately after the previous block.\n  // (Except for padding with a maximum of three null bytes)\n  uint64_t block_end = ots::Round4(\n      static_cast<uint64_t>(tables[last_index].offset) +\n      static_cast<uint64_t>(tables[last_index].length));\n  if (block_end > std::numeric_limits<uint32_t>::max()) {\n    return OTS_FAILURE_MSG_HDR(\"invalid table location/size\");\n  }\n  if (meta_offset) {\n    if (block_end != meta_offset) {\n      return OTS_FAILURE_MSG_HDR(\"Invalid metadata block offset\");\n    }\n    block_end = ots::Round4(static_cast<uint64_t>(meta_offset) +\n                            static_cast<uint64_t>(meta_length));\n    if (block_end > std::numeric_limits<uint32_t>::max()) {\n      return OTS_FAILURE_MSG_HDR(\"Invalid metadata block length\");\n    }\n  }\n  if (priv_offset) {\n    if (block_end != priv_offset) {\n      return OTS_FAILURE_MSG_HDR(\"Invalid private block offset\");\n    }\n    block_end = ots::Round4(static_cast<uint64_t>(priv_offset) +\n                            static_cast<uint64_t>(priv_length));\n    if (block_end > std::numeric_limits<uint32_t>::max()) {\n      return OTS_FAILURE_MSG_HDR(\"Invalid private block length\");\n    }\n  }\n  if (block_end != ots::Round4(length)) {\n    return OTS_FAILURE_MSG_HDR(\"File length mismatch (trailing junk?)\");\n  }\n\n  return ProcessGeneric(header, font, woff_tag, output, data, length, tables, file);\n}\n\nbool ProcessTTF(ots::FontFile *header,\n                ots::Font *font,\n                ots::OTSStream *output, const uint8_t *data, size_t length,\n                uint32_t offset = 0) {\n  ots::Buffer file(data + offset, length - offset);\n\n  if (offset > length) {\n    return OTS_FAILURE_MSG_HDR(\"offset beyond end of file\");\n  }\n\n  // we disallow all files > 1GB in size for sanity.\n  if (length > 1024 * 1024 * 1024) {\n    return OTS_FAILURE_MSG_HDR(\"file exceeds 1GB\");\n  }\n\n  if (!file.ReadU32(&font->version)) {\n    return OTS_FAILURE_MSG_HDR(\"error reading version tag\");\n  }\n  if (!ots::IsValidVersionTag(font->version)) {\n      return OTS_FAILURE_MSG_HDR(\"invalid version tag\");\n  }\n\n  if (!file.ReadU16(&font->num_tables) ||\n      !file.ReadU16(&font->search_range) ||\n      !file.ReadU16(&font->entry_selector) ||\n      !file.ReadU16(&font->range_shift)) {\n    return OTS_FAILURE_MSG_HDR(\"error reading table directory search header\");\n  }\n\n  // search_range is (Maximum power of 2 <= numTables) x 16. Thus, to avoid\n  // overflow num_tables is, at most, 2^16 / 16 = 2^12\n  if (font->num_tables >= 4096 || font->num_tables < 1) {\n    return OTS_FAILURE_MSG_HDR(\"excessive (or zero) number of tables\");\n  }\n\n  unsigned max_pow2 = 0;\n  while (1u << (max_pow2 + 1) <= font->num_tables) {\n    max_pow2++;\n  }\n  const uint16_t expected_search_range = (1u << max_pow2) << 4;\n\n  // Don't call ots_failure() here since ~25% of fonts (250+ fonts) in\n  // http://www.princexml.com/fonts/ have unexpected search_range value.\n  if (font->search_range != expected_search_range) {\n    OTS_WARNING_MSG_HDR(\"bad search range\");\n    font->search_range = expected_search_range;  // Fix the value.\n  }\n\n  // entry_selector is Log2(maximum power of 2 <= numTables)\n  if (font->entry_selector != max_pow2) {\n    return OTS_FAILURE_MSG_HDR(\"incorrect entrySelector for table directory\");\n  }\n\n  // range_shift is NumTables x 16-searchRange. We know that 16*num_tables\n  // doesn't over flow because we range checked it above. Also, we know that\n  // it's > font->search_range by construction of search_range.\n  const uint16_t expected_range_shift =\n      16 * font->num_tables - font->search_range;\n  if (font->range_shift != expected_range_shift) {\n    OTS_WARNING_MSG_HDR(\"bad range shift\");\n    font->range_shift = expected_range_shift;  // the same as above.\n  }\n\n  // Next up is the list of tables.\n  std::vector<ots::TableEntry> tables;\n\n  for (unsigned i = 0; i < font->num_tables; ++i) {\n    ots::TableEntry table;\n    if (!file.ReadU32(&table.tag) ||\n        !file.ReadU32(&table.chksum) ||\n        !file.ReadU32(&table.offset) ||\n        !file.ReadU32(&table.length)) {\n      return OTS_FAILURE_MSG_HDR(\"error reading table directory\");\n    }\n\n    table.uncompressed_length = table.length;\n    tables.push_back(table);\n  }\n\n  return ProcessGeneric(header, font, font->version, output, data, length,\n                        tables, file);\n}\n\n\n// target function\n  ~Arena() {\n    for (std::vector<uint8_t*>::iterator\n         i = hunks_.begin(); i != hunks_.end(); ++i) {\n      delete[] *i;\n    }\n  }\nbool GetTableData(const uint8_t *data,\n                  const ots::TableEntry& table,\n                  Arena *arena,\n                  size_t *table_length,\n                  const uint8_t **table_data) {\n  if (table.uncompressed_length != table.length) {\n    // Compressed table. Need to uncompress into memory first.\n    *table_length = table.uncompressed_length;\n    *table_data = (*arena).Allocate(*table_length);\n    uLongf dest_len = *table_length;\n    int r = uncompress((Bytef*) *table_data, &dest_len,\n                       data + table.offset, table.length);\n    if (r != Z_OK || dest_len != *table_length) {\n      return false;\n    }\n  } else {\n    // Uncompressed table. We can process directly from memory.\n    *table_data = data + table.offset;\n    *table_length = table.length;\n  }\n\n  return true;\n}\nbool ProcessGeneric(ots::FontFile *header,\n                    ots::Font *font,\n                    uint32_t signature,\n                    ots::OTSStream *output,\n                    const uint8_t *data, size_t length,\n                    const std::vector<ots::TableEntry>& tables,\n                    ots::Buffer& file) {\n  const size_t data_offset = file.offset();\n\n  uint32_t uncompressed_sum = 0;\n\n  for (unsigned i = 0; i < font->num_tables; ++i) {\n    // the tables must be sorted by tag (when taken as big-endian numbers).\n    // This also remove the possibility of duplicate tables.\n    if (i) {\n      const uint32_t this_tag = tables[i].tag;\n      const uint32_t prev_tag = tables[i - 1].tag;\n      if (this_tag <= prev_tag) {\n        OTS_WARNING_MSG_HDR(\"Table directory is not correctly ordered\");\n      }\n    }\n\n    // all tag names must be built from printable ASCII characters\n    if (!CheckTag(tables[i].tag)) {\n      return OTS_FAILURE_MSG_TAG(\"invalid table tag\", tables[i].tag);\n    }\n\n    // tables must be 4-byte aligned\n    if (tables[i].offset & 3) {\n      return OTS_FAILURE_MSG_TAG(\"misaligned table\", tables[i].tag);\n    }\n\n    // and must be within the file\n    if (tables[i].offset < data_offset || tables[i].offset >= length) {\n      return OTS_FAILURE_MSG_TAG(\"invalid table offset\", tables[i].tag);\n    }\n    // disallow all tables with a zero length\n    if (tables[i].length < 1) {\n      // Note: malayalam.ttf has zero length CVT table...\n      return OTS_FAILURE_MSG_TAG(\"zero-length table\", tables[i].tag);\n    }\n    // disallow all tables with a length > 1GB\n    if (tables[i].length > 1024 * 1024 * 1024) {\n      return OTS_FAILURE_MSG_TAG(\"table length exceeds 1GB\", tables[i].tag);\n    }\n    // disallow tables where the uncompressed size is < the compressed size.\n    if (tables[i].uncompressed_length < tables[i].length) {\n      return OTS_FAILURE_MSG_TAG(\"invalid compressed table\", tables[i].tag);\n    }\n    if (tables[i].uncompressed_length > tables[i].length) {\n      // We'll probably be decompressing this table.\n\n      // disallow all tables which uncompress to > 30 MB\n      if (tables[i].uncompressed_length > 30 * 1024 * 1024) {\n        return OTS_FAILURE_MSG_TAG(\"uncompressed length exceeds 30MB\", tables[i].tag);\n      }\n      if (uncompressed_sum + tables[i].uncompressed_length < uncompressed_sum) {\n        return OTS_FAILURE_MSG_TAG(\"overflow of uncompressed sum\", tables[i].tag);\n      }\n\n      uncompressed_sum += tables[i].uncompressed_length;\n    }\n    // since we required that the file be < 1GB in length, and that the table\n    // length is < 1GB, the following addtion doesn't overflow\n    uint32_t end_byte = tables[i].offset + tables[i].length;\n    // Tables in the WOFF file must be aligned 4-byte boundary.\n    if (signature == OTS_TAG('w','O','F','F')) {\n        end_byte = ots::Round4(end_byte);\n    }\n    if (!end_byte || end_byte > length) {\n      return OTS_FAILURE_MSG_TAG(\"table overruns end of file\", tables[i].tag);\n    }\n  }\n\n  // All decompressed tables uncompressed must be <= 30MB.\n  if (uncompressed_sum > 30 * 1024 * 1024) {\n    return OTS_FAILURE_MSG_HDR(\"uncompressed sum exceeds 30MB\");\n  }\n\n  // check that the tables are not overlapping.\n  std::vector<std::pair<uint32_t, uint8_t> > overlap_checker;\n  for (unsigned i = 0; i < font->num_tables; ++i) {\n    overlap_checker.push_back(\n        std::make_pair(tables[i].offset, static_cast<uint8_t>(1) /* start */));\n    overlap_checker.push_back(\n        std::make_pair(tables[i].offset + tables[i].length,\n                       static_cast<uint8_t>(0) /* end */));\n  }\n  std::sort(overlap_checker.begin(), overlap_checker.end());\n  int overlap_count = 0;\n  for (unsigned i = 0; i < overlap_checker.size(); ++i) {\n    overlap_count += (overlap_checker[i].second ? 1 : -1);\n    if (overlap_count > 1) {\n      return OTS_FAILURE_MSG_HDR(\"overlapping tables\");\n    }\n  }\n\n  std::map<uint32_t, ots::TableEntry> table_map;\n  for (unsigned i = 0; i < font->num_tables; ++i) {\n    table_map[tables[i].tag] = tables[i];\n  }\n\n  // Parse known tables first as we need to parse them in specific order.\n  for (unsigned i = 0; ; ++i) {\n    if (supported_tables[i].tag == 0) break;\n\n    uint32_t tag = supported_tables[i].tag;\n    const auto &it = table_map.find(tag);\n    if (it == table_map.cend()) {\n      if (supported_tables[i].required) {\n        return OTS_FAILURE_MSG_TAG(\"missing required table\", tag);\n      }\n    } else {\n      if (!font->ParseTable(it->second, data)) {\n        return OTS_FAILURE_MSG_TAG(\"Failed to parse table\", tag);\n      }\n    }\n  }\n\n  // Then parse any tables left.\n  for (const auto &table_entry : tables) {\n    if (!font->GetTable(table_entry.tag)) {\n      if (!font->ParseTable(table_entry, data)) {\n        return OTS_FAILURE_MSG_TAG(\"Failed to parse table\", table_entry.tag);\n      }\n    }\n  }\n\n  if (font->GetTable(OTS_TAG_CFF)) {\n    // font with PostScript glyph\n    if (font->version != OTS_TAG('O','T','T','O')) {\n      return OTS_FAILURE_MSG_HDR(\"wrong font version for PostScript glyph data\");\n    }\n    if (font->GetTable(OTS_TAG_GLYF) || font->GetTable(OTS_TAG_LOCA)) {\n      // mixing outline formats is not recommended\n      return OTS_FAILURE_MSG_HDR(\"font contains both PS and TT glyphs\");\n    }\n  } else {\n    if (!font->GetTable(OTS_TAG_GLYF) || !font->GetTable(OTS_TAG_LOCA)) {\n      // No TrueType glyph found.\n      //\n      // We don't sanitize bitmap tables, but don\u2019t reject bitmap-only fonts if\n      // we are asked to pass them thru.\n      // Also don\u2019t reject if we are asked to pass glyf/loca thru.\n      if (!font->GetTable(OTS_TAG('C','B','D','T')) &&\n          !font->GetTable(OTS_TAG('C','B','L','C'))) {\n        return OTS_FAILURE_MSG_HDR(\"no supported glyph shapes table(s) present\");\n      }\n    }\n  }\n\n  uint16_t num_output_tables = 0;\n  for (const auto &it : table_map) {\n    ots::Table *table = font->GetTable(it.first);\n    if (table != NULL && table->ShouldSerialize())\n      num_output_tables++;\n  }\n\n  uint16_t max_pow2 = 0;\n  while (1u << (max_pow2 + 1) <= num_output_tables) {\n    max_pow2++;\n  }\n  const uint16_t output_search_range = (1u << max_pow2) << 4;\n\n  // most of the errors here are highly unlikely - they'd only occur if the\n  // output stream returns a failure, e.g. lack of space to write\n  output->ResetChecksum();\n  if (!output->WriteU32(font->version) ||\n      !output->WriteU16(num_output_tables) ||\n      !output->WriteU16(output_search_range) ||\n      !output->WriteU16(max_pow2) ||\n      !output->WriteU16((num_output_tables << 4) - output_search_range)) {\n    return OTS_FAILURE_MSG_HDR(\"error writing output\");\n  }\n  const uint32_t offset_table_chksum = output->chksum();\n\n  const size_t table_record_offset = output->Tell();\n  if (!output->Pad(16 * num_output_tables)) {\n    return OTS_FAILURE_MSG_HDR(\"error writing output\");\n  }\n\n  std::vector<ots::TableEntry> out_tables;\n\n  size_t head_table_offset = 0;\n  for (const auto &it : table_map) {\n    uint32_t input_offset = it.second.offset;\n    const auto &ot = header->table_entries.find(input_offset);\n    if (ot != header->table_entries.end()) {\n      ots::TableEntry out = ot->second;\n      if (out.tag == OTS_TAG('h','e','a','d')) {\n        head_table_offset = out.offset;\n      }\n      out_tables.push_back(out);\n    } else {\n      ots::TableEntry out;\n      out.tag = it.first;\n      out.offset = output->Tell();\n\n      if (out.tag == OTS_TAG('h','e','a','d')) {\n        head_table_offset = out.offset;\n      }\n\n      ots::Table *table = font->GetTable(out.tag);\n      if (table != NULL && table->ShouldSerialize()) {\n        output->ResetChecksum();\n        if (!table->Serialize(output)) {\n          return OTS_FAILURE_MSG_TAG(\"failed to serialize table\", out.tag);\n        }\n\n        const size_t end_offset = output->Tell();\n        if (end_offset <= out.offset) {\n          // paranoid check. |end_offset| is supposed to be greater than the offset,\n          // as long as the Tell() interface is implemented correctly.\n          return OTS_FAILURE_MSG_HDR(\"error writing output\");\n        }\n        out.length = end_offset - out.offset;\n\n        // align tables to four bytes\n        if (!output->Pad((4 - (end_offset & 3)) % 4)) {\n          return OTS_FAILURE_MSG_HDR(\"error writing output\");\n        }\n        out.chksum = output->chksum();\n        out_tables.push_back(out);\n        header->table_entries[input_offset] = out;\n      }\n    }\n  }\n\n  const size_t end_of_file = output->Tell();\n\n  // Need to sort the output tables for inclusion in the file\n  std::sort(out_tables.begin(), out_tables.end());\n  if (!output->Seek(table_record_offset)) {\n    return OTS_FAILURE_MSG_HDR(\"error writing output\");\n  }\n\n  output->ResetChecksum();\n  uint32_t tables_chksum = 0;\n  for (unsigned i = 0; i < out_tables.size(); ++i) {\n    if (!output->WriteU32(out_tables[i].tag) ||\n        !output->WriteU32(out_tables[i].chksum) ||\n        !output->WriteU32(out_tables[i].offset) ||\n        !output->WriteU32(out_tables[i].length)) {\n      return OTS_FAILURE_MSG_HDR(\"error writing output\");\n    }\n    tables_chksum += out_tables[i].chksum;\n  }\n  const uint32_t table_record_chksum = output->chksum();\n\n  // http://www.microsoft.com/typography/otspec/otff.htm\n  const uint32_t file_chksum\n      = offset_table_chksum + tables_chksum + table_record_chksum;\n  const uint32_t chksum_magic = static_cast<uint32_t>(0xb1b0afba) - file_chksum;\n\n  // seek into the 'head' table and write in the checksum magic value\n  if (!head_table_offset) {\n    return OTS_FAILURE_MSG_HDR(\"internal error!\");\n  }\n  if (!output->Seek(head_table_offset + 8)) {\n    return OTS_FAILURE_MSG_HDR(\"error writing output\");\n  }\n  if (!output->WriteU32(chksum_magic)) {\n    return OTS_FAILURE_MSG_HDR(\"error writing output\");\n  }\n\n  if (!output->Seek(end_of_file)) {\n    return OTS_FAILURE_MSG_HDR(\"error writing output\");\n  }\n\n  return true;\n}\nbool Font::ParseTable(const TableEntry& table_entry, const uint8_t* data) {\n  uint32_t tag = table_entry.tag;\n  TableAction action = GetTableAction(file, tag);\n  if (action == TABLE_ACTION_DROP) {\n    return true;\n  }\n\n  const auto &it = file->tables.find(table_entry);\n  if (it != file->tables.end()) {\n    m_tables[tag] = it->second;\n    return true;\n  }\n\n  Table *table = NULL;\n  bool ret = false;\n\n  if (action == TABLE_ACTION_PASSTHRU) {\n    table = new TablePassthru(this, tag);\n  } else {\n    switch (tag) {\n      case OTS_TAG_CFF:  table = new OpenTypeCFF(this,  tag); break;\n      case OTS_TAG_CMAP: table = new OpenTypeCMAP(this, tag); break;\n      case OTS_TAG_CVT:  table = new OpenTypeCVT(this,  tag); break;\n      case OTS_TAG_FPGM: table = new OpenTypeFPGM(this, tag); break;\n      case OTS_TAG_GASP: table = new OpenTypeGASP(this, tag); break;\n      case OTS_TAG_GDEF: table = new OpenTypeGDEF(this, tag); break;\n      case OTS_TAG_GLYF: table = new OpenTypeGLYF(this, tag); break;\n      case OTS_TAG_GPOS: table = new OpenTypeGPOS(this, tag); break;\n      case OTS_TAG_GSUB: table = new OpenTypeGSUB(this, tag); break;\n      case OTS_TAG_HDMX: table = new OpenTypeHDMX(this, tag); break;\n      case OTS_TAG_HEAD: table = new OpenTypeHEAD(this, tag); break;\n      case OTS_TAG_HHEA: table = new OpenTypeHHEA(this, tag); break;\n      case OTS_TAG_HMTX: table = new OpenTypeHMTX(this, tag); break;\n      case OTS_TAG_KERN: table = new OpenTypeKERN(this, tag); break;\n      case OTS_TAG_LOCA: table = new OpenTypeLOCA(this, tag); break;\n      case OTS_TAG_LTSH: table = new OpenTypeLTSH(this, tag); break;\n      case OTS_TAG_MATH: table = new OpenTypeMATH(this, tag); break;\n      case OTS_TAG_MAXP: table = new OpenTypeMAXP(this, tag); break;\n      case OTS_TAG_NAME: table = new OpenTypeNAME(this, tag); break;\n      case OTS_TAG_OS2:  table = new OpenTypeOS2(this,  tag); break;\n      case OTS_TAG_POST: table = new OpenTypePOST(this, tag); break;\n      case OTS_TAG_PREP: table = new OpenTypePREP(this, tag); break;\n      case OTS_TAG_VDMX: table = new OpenTypeVDMX(this, tag); break;\n      case OTS_TAG_VORG: table = new OpenTypeVORG(this, tag); break;\n      case OTS_TAG_VHEA: table = new OpenTypeVHEA(this, tag); break;\n      case OTS_TAG_VMTX: table = new OpenTypeVMTX(this, tag); break;\n      default: break;\n    }\n  }\n\n  if (table) {\n    Arena arena;\n    const uint8_t* table_data;\n    size_t table_length;\n\n    if (GetTableData(data, table_entry, &arena, &table_length, &table_data)) {\n      // FIXME: Parsing some tables will fail if the table is not added to\n      // m_tables first.\n      m_tables[tag] = table;\n      ret = table->Parse(table_data, table_length);\n      if (!ret) {\n        m_tables.erase(tag);\n        delete table;\n      } else {\n        file->tables[table_entry] = table;\n      }\n    }\n  }\n\n  return ret;\n}\n",
    "target": 1,
    "idx": 1000919,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nASSIMP_API aiScene::~aiScene() {\n    // delete all sub-objects recursively\n    delete mRootNode;\n\n    // To make sure we won't crash if the data is invalid it's\n    // much better to check whether both mNumXXX and mXXX are\n    // valid instead of relying on just one of them.\n    if (mNumMeshes && mMeshes) {\n        for (unsigned int a = 0; a < mNumMeshes; ++a) {\n            delete mMeshes[a];\n        }\n    }\n    delete[] mMeshes;\n\n    if (mNumMaterials && mMaterials) {\n        for (unsigned int a = 0; a < mNumMaterials; ++a) {\n            delete mMaterials[a];\n        }\n    }\n    delete[] mMaterials;\n\n    if (mNumAnimations && mAnimations) {\n        for (unsigned int a = 0; a < mNumAnimations; ++a) {\n            delete mAnimations[a];\n        }\n    }\n    delete[] mAnimations;\n\n    if (mNumTextures && mTextures) {\n        for (unsigned int a = 0; a < mNumTextures; ++a) {\n            delete mTextures[a];\n        }\n    }\n    delete[] mTextures;\n\n    if (mNumLights && mLights) {\n        for (unsigned int a = 0; a < mNumLights; ++a) {\n            delete mLights[a];\n        }\n    }\n    delete[] mLights;\n\n    if (mNumCameras && mCameras) {\n        for (unsigned int a = 0; a < mNumCameras; ++a) {\n            delete mCameras[a];\n        }\n    }\n    delete[] mCameras;\n\n    aiMetadata::Dealloc(mMetaData);\n\n    delete[] mSkeletons;\n\n    delete static_cast<Assimp::ScenePrivateData *>(mPrivate);\n}\n\nBatchLoader::~BatchLoader() {\n    // delete all scenes what have not been polled by the user\n    for (LoadReqIt it = m_data->requests.begin(); it != m_data->requests.end(); ++it) {\n        delete (*it).scene;\n    }\n    delete m_data;\n}\n\nvoid LWSImporter::InternReadFile(const std::string &pFile, aiScene *pScene, IOSystem *pIOHandler) {\n    io = pIOHandler;\n    std::unique_ptr<IOStream> file(pIOHandler->Open(pFile, \"rb\"));\n\n    // Check whether we can read from the file\n    if (file == nullptr) {\n        throw DeadlyImportError(\"Failed to open LWS file \", pFile, \".\");\n    }\n\n    // Allocate storage and copy the contents of the file to a memory buffer\n    std::vector<char> mBuffer;\n    TextFileToBuffer(file.get(), mBuffer);\n\n    // Parse the file structure\n    LWS::Element root;\n    const char *dummy = &mBuffer[0];\n    root.Parse(dummy);\n\n    // Construct a Batch-importer to read more files recursively\n    BatchLoader batch(pIOHandler);\n\n    // Construct an array to receive the flat output graph\n    std::list<LWS::NodeDesc> nodes;\n\n    unsigned int cur_light = 0, cur_camera = 0, cur_object = 0;\n    unsigned int num_light = 0, num_camera = 0;\n\n    // check magic identifier, 'LWSC'\n    bool motion_file = false;\n    std::list<LWS::Element>::const_iterator it = root.children.begin();\n\n    if ((*it).tokens[0] == \"LWMO\") {\n        motion_file = true;\n    }\n\n    if ((*it).tokens[0] != \"LWSC\" && !motion_file) {\n        throw DeadlyImportError(\"LWS: Not a LightWave scene, magic tag LWSC not found\");\n    }\n\n    // get file format version and print to log\n    ++it;\n\n    if (it == root.children.end() || (*it).tokens[0].empty()) {\n        ASSIMP_LOG_ERROR(\"Invalid LWS file detectedm abort import.\");\n        return;\n    }\n    unsigned int version = strtoul10((*it).tokens[0].c_str());\n    ASSIMP_LOG_INFO(\"LWS file format version is \", (*it).tokens[0]);\n    first = 0.;\n    last = 60.;\n    fps = 25.; // seems to be a good default frame rate\n\n    // Now read all elements in a very straightforward manner\n    for (; it != root.children.end(); ++it) {\n        const char *c = (*it).tokens[1].c_str();\n\n        // 'FirstFrame': begin of animation slice\n        if ((*it).tokens[0] == \"FirstFrame\") {\n            // see SetupProperties()\n            if (150392. != first ) {\n                first = strtoul10(c, &c) - 1.; // we're zero-based\n            }\n        } else if ((*it).tokens[0] == \"LastFrame\") { // 'LastFrame': end of animation slice\n            // see SetupProperties()\n            if (150392. != last ) {\n                last = strtoul10(c, &c) - 1.; // we're zero-based\n            }\n        } else if ((*it).tokens[0] == \"FramesPerSecond\") { // 'FramesPerSecond': frames per second\n            fps = strtoul10(c, &c);\n        } else if ((*it).tokens[0] == \"LoadObjectLayer\") { // 'LoadObjectLayer': load a layer of a specific LWO file\n\n            // get layer index\n            const int layer = strtoul10(c, &c);\n\n            // setup the layer to be loaded\n            BatchLoader::PropertyMap props;\n            SetGenericProperty(props.ints, AI_CONFIG_IMPORT_LWO_ONE_LAYER_ONLY, layer);\n\n            // add node to list\n            LWS::NodeDesc d;\n            d.type = LWS::NodeDesc::OBJECT;\n            if (version >= 4) { // handle LWSC 4 explicit ID\n                SkipSpaces(&c);\n                d.number = strtoul16(c, &c) & AI_LWS_MASK;\n            } else {\n                d.number = cur_object++;\n            }\n\n            // and add the file to the import list\n            SkipSpaces(&c);\n            std::string path = FindLWOFile(c);\n            d.path = path;\n            d.id = batch.AddLoadRequest(path, 0, &props);\n\n            nodes.push_back(d);\n        } else if ((*it).tokens[0] == \"LoadObject\") { // 'LoadObject': load a LWO file into the scene-graph\n\n            // add node to list\n            LWS::NodeDesc d;\n            d.type = LWS::NodeDesc::OBJECT;\n\n            if (version >= 4) { // handle LWSC 4 explicit ID\n                d.number = strtoul16(c, &c) & AI_LWS_MASK;\n                SkipSpaces(&c);\n            } else {\n                d.number = cur_object++;\n            }\n            std::string path = FindLWOFile(c);\n            d.id = batch.AddLoadRequest(path, 0, nullptr);\n\n            d.path = path;\n            nodes.push_back(d);\n        } else if ((*it).tokens[0] == \"AddNullObject\") { // 'AddNullObject': add a dummy node to the hierarchy\n\n            // add node to list\n            LWS::NodeDesc d;\n            d.type = LWS::NodeDesc::OBJECT;\n            if (version >= 4) { // handle LWSC 4 explicit ID\n                d.number = strtoul16(c, &c) & AI_LWS_MASK;\n                SkipSpaces(&c);\n            } else {\n                d.number = cur_object++;\n            }\n            d.name = c;\n            nodes.push_back(d);\n        }\n        // 'NumChannels': Number of envelope channels assigned to last layer\n        else if ((*it).tokens[0] == \"NumChannels\") {\n            // ignore for now\n        }\n        // 'Channel': preceedes any envelope description\n        else if ((*it).tokens[0] == \"Channel\") {\n            if (nodes.empty()) {\n                if (motion_file) {\n\n                    // LightWave motion file. Add dummy node\n                    LWS::NodeDesc d;\n                    d.type = LWS::NodeDesc::OBJECT;\n                    d.name = c;\n                    d.number = cur_object++;\n                    nodes.push_back(d);\n                }\n                ASSIMP_LOG_ERROR(\"LWS: Unexpected keyword: \\'Channel\\'\");\n            } else {\n                // important: index of channel\n                nodes.back().channels.emplace_back();\n                LWO::Envelope &env = nodes.back().channels.back();\n\n                env.index = strtoul10(c);\n\n                // currently we can just interpret the standard channels 0...9\n                // (hack) assume that index-i yields the binary channel type from LWO\n                env.type = (LWO::EnvelopeType)(env.index + 1);\n            }\n        }\n        // 'Envelope': a single animation channel\n        else if ((*it).tokens[0] == \"Envelope\") {\n            if (nodes.empty() || nodes.back().channels.empty())\n                ASSIMP_LOG_ERROR(\"LWS: Unexpected keyword: \\'Envelope\\'\");\n            else {\n                ReadEnvelope((*it), nodes.back().channels.back());\n            }\n        }\n        // 'ObjectMotion': animation information for older lightwave formats\n        else if (version < 3 && ((*it).tokens[0] == \"ObjectMotion\" ||\n                                        (*it).tokens[0] == \"CameraMotion\" ||\n                                        (*it).tokens[0] == \"LightMotion\")) {\n\n            if (nodes.empty())\n                ASSIMP_LOG_ERROR(\"LWS: Unexpected keyword: \\'<Light|Object|Camera>Motion\\'\");\n            else {\n                ReadEnvelope_Old(it, root.children.end(), nodes.back(), version);\n            }\n        }\n        // 'Pre/PostBehavior': pre/post animation behaviour for LWSC 2\n        else if (version == 2 && (*it).tokens[0] == \"Pre/PostBehavior\") {\n            if (nodes.empty())\n                ASSIMP_LOG_ERROR(\"LWS: Unexpected keyword: \\'Pre/PostBehavior'\");\n            else {\n                for (std::list<LWO::Envelope>::iterator envelopeIt = nodes.back().channels.begin(); envelopeIt != nodes.back().channels.end(); ++envelopeIt) {\n                    // two ints per envelope\n                    LWO::Envelope &env = *envelopeIt;\n                    env.pre = (LWO::PrePostBehaviour)strtoul10(c, &c);\n                    SkipSpaces(&c);\n                    env.post = (LWO::PrePostBehaviour)strtoul10(c, &c);\n                    SkipSpaces(&c);\n                }\n            }\n        }\n        // 'ParentItem': specifies the parent of the current element\n        else if ((*it).tokens[0] == \"ParentItem\") {\n            if (nodes.empty())\n                ASSIMP_LOG_ERROR(\"LWS: Unexpected keyword: \\'ParentItem\\'\");\n\n            else\n                nodes.back().parent = strtoul16(c, &c);\n        }\n        // 'ParentObject': deprecated one for older formats\n        else if (version < 3 && (*it).tokens[0] == \"ParentObject\") {\n            if (nodes.empty())\n                ASSIMP_LOG_ERROR(\"LWS: Unexpected keyword: \\'ParentObject\\'\");\n\n            else {\n                nodes.back().parent = strtoul10(c, &c) | (1u << 28u);\n            }\n        }\n        // 'AddCamera': add a camera to the scenegraph\n        else if ((*it).tokens[0] == \"AddCamera\") {\n\n            // add node to list\n            LWS::NodeDesc d;\n            d.type = LWS::NodeDesc::CAMERA;\n\n            if (version >= 4) { // handle LWSC 4 explicit ID\n                d.number = strtoul16(c, &c) & AI_LWS_MASK;\n            } else\n                d.number = cur_camera++;\n            nodes.push_back(d);\n\n            num_camera++;\n        }\n        // 'CameraName': set name of currently active camera\n        else if ((*it).tokens[0] == \"CameraName\") {\n            if (nodes.empty() || nodes.back().type != LWS::NodeDesc::CAMERA)\n                ASSIMP_LOG_ERROR(\"LWS: Unexpected keyword: \\'CameraName\\'\");\n\n            else\n                nodes.back().name = c;\n        }\n        // 'AddLight': add a light to the scenegraph\n        else if ((*it).tokens[0] == \"AddLight\") {\n\n            // add node to list\n            LWS::NodeDesc d;\n            d.type = LWS::NodeDesc::LIGHT;\n\n            if (version >= 4) { // handle LWSC 4 explicit ID\n                d.number = strtoul16(c, &c) & AI_LWS_MASK;\n            } else\n                d.number = cur_light++;\n            nodes.push_back(d);\n\n            num_light++;\n        }\n        // 'LightName': set name of currently active light\n        else if ((*it).tokens[0] == \"LightName\") {\n            if (nodes.empty() || nodes.back().type != LWS::NodeDesc::LIGHT)\n                ASSIMP_LOG_ERROR(\"LWS: Unexpected keyword: \\'LightName\\'\");\n\n            else\n                nodes.back().name = c;\n        }\n        // 'LightIntensity': set intensity of currently active light\n        else if ((*it).tokens[0] == \"LightIntensity\" || (*it).tokens[0] == \"LgtIntensity\") {\n            if (nodes.empty() || nodes.back().type != LWS::NodeDesc::LIGHT) {\n                ASSIMP_LOG_ERROR(\"LWS: Unexpected keyword: \\'LightIntensity\\'\");\n            } else {\n                const std::string env = \"(envelope)\";\n                if (0 == strncmp(c, env.c_str(), env.size())) {\n                    ASSIMP_LOG_ERROR(\"LWS: envelopes for  LightIntensity not supported, set to 1.0\");\n                    nodes.back().lightIntensity = (ai_real)1.0;\n                } else {\n                    fast_atoreal_move<float>(c, nodes.back().lightIntensity);\n                }\n            }\n        }\n        // 'LightType': set type of currently active light\n        else if ((*it).tokens[0] == \"LightType\") {\n            if (nodes.empty() || nodes.back().type != LWS::NodeDesc::LIGHT)\n                ASSIMP_LOG_ERROR(\"LWS: Unexpected keyword: \\'LightType\\'\");\n\n            else\n                nodes.back().lightType = strtoul10(c);\n\n        }\n        // 'LightFalloffType': set falloff type of currently active light\n        else if ((*it).tokens[0] == \"LightFalloffType\") {\n            if (nodes.empty() || nodes.back().type != LWS::NodeDesc::LIGHT)\n                ASSIMP_LOG_ERROR(\"LWS: Unexpected keyword: \\'LightFalloffType\\'\");\n            else\n                nodes.back().lightFalloffType = strtoul10(c);\n\n        }\n        // 'LightConeAngle': set cone angle of currently active light\n        else if ((*it).tokens[0] == \"LightConeAngle\") {\n            if (nodes.empty() || nodes.back().type != LWS::NodeDesc::LIGHT)\n                ASSIMP_LOG_ERROR(\"LWS: Unexpected keyword: \\'LightConeAngle\\'\");\n\n            else\n                nodes.back().lightConeAngle = fast_atof(c);\n\n        }\n        // 'LightEdgeAngle': set area where we're smoothing from min to max intensity\n        else if ((*it).tokens[0] == \"LightEdgeAngle\") {\n            if (nodes.empty() || nodes.back().type != LWS::NodeDesc::LIGHT)\n                ASSIMP_LOG_ERROR(\"LWS: Unexpected keyword: \\'LightEdgeAngle\\'\");\n\n            else\n                nodes.back().lightEdgeAngle = fast_atof(c);\n\n        }\n        // 'LightColor': set color of currently active light\n        else if ((*it).tokens[0] == \"LightColor\") {\n            if (nodes.empty() || nodes.back().type != LWS::NodeDesc::LIGHT)\n                ASSIMP_LOG_ERROR(\"LWS: Unexpected keyword: \\'LightColor\\'\");\n\n            else {\n                c = fast_atoreal_move<float>(c, (float &)nodes.back().lightColor.r);\n                SkipSpaces(&c);\n                c = fast_atoreal_move<float>(c, (float &)nodes.back().lightColor.g);\n                SkipSpaces(&c);\n                c = fast_atoreal_move<float>(c, (float &)nodes.back().lightColor.b);\n            }\n        }\n\n        // 'PivotPosition': position of local transformation origin\n        else if ((*it).tokens[0] == \"PivotPosition\" || (*it).tokens[0] == \"PivotPoint\") {\n            if (nodes.empty())\n                ASSIMP_LOG_ERROR(\"LWS: Unexpected keyword: \\'PivotPosition\\'\");\n            else {\n                c = fast_atoreal_move<float>(c, (float &)nodes.back().pivotPos.x);\n                SkipSpaces(&c);\n                c = fast_atoreal_move<float>(c, (float &)nodes.back().pivotPos.y);\n                SkipSpaces(&c);\n                c = fast_atoreal_move<float>(c, (float &)nodes.back().pivotPos.z);\n                // Mark pivotPos as set\n                nodes.back().isPivotSet = true;\n            }\n        }\n    }\n\n    // resolve parenting\n    for (std::list<LWS::NodeDesc>::iterator ndIt = nodes.begin(); ndIt != nodes.end(); ++ndIt) {\n\n        // check whether there is another node which calls us a parent\n        for (std::list<LWS::NodeDesc>::iterator dit = nodes.begin(); dit != nodes.end(); ++dit) {\n            if (dit != ndIt && *ndIt == (*dit).parent) {\n                if ((*dit).parent_resolved) {\n                    // fixme: it's still possible to produce an overflow due to cross references ..\n                    ASSIMP_LOG_ERROR(\"LWS: Found cross reference in scene-graph\");\n                    continue;\n                }\n\n                ndIt->children.push_back(&*dit);\n                (*dit).parent_resolved = &*ndIt;\n            }\n        }\n    }\n\n    // find out how many nodes have no parent yet\n    unsigned int no_parent = 0;\n    for (std::list<LWS::NodeDesc>::iterator ndIt = nodes.begin(); ndIt != nodes.end(); ++ndIt) {\n        if (!ndIt->parent_resolved) {\n            ++no_parent;\n        }\n    }\n    if (!no_parent) {\n        throw DeadlyImportError(\"LWS: Unable to find scene root node\");\n    }\n\n    // Load all subsequent files\n    batch.LoadAll();\n\n    // and build the final output graph by attaching the loaded external\n    // files to ourselves. first build a master graph\n    aiScene *master = new aiScene();\n    aiNode *nd = master->mRootNode = new aiNode();\n\n    // allocate storage for cameras&lights\n    if (num_camera) {\n        master->mCameras = new aiCamera *[master->mNumCameras = num_camera];\n    }\n    aiCamera **cams = master->mCameras;\n    if (num_light) {\n        master->mLights = new aiLight *[master->mNumLights = num_light];\n    }\n    aiLight **lights = master->mLights;\n\n    std::vector<AttachmentInfo> attach;\n    std::vector<aiNodeAnim *> anims;\n\n    nd->mName.Set(\"<LWSRoot>\");\n    nd->mChildren = new aiNode *[no_parent];\n    for (std::list<LWS::NodeDesc>::iterator ndIt = nodes.begin(); ndIt != nodes.end(); ++ndIt) {\n        if (!ndIt->parent_resolved) {\n            aiNode *ro = nd->mChildren[nd->mNumChildren++] = new aiNode();\n            ro->mParent = nd;\n\n            // ... and build the scene graph. If we encounter object nodes,\n            // add then to our attachment table.\n            BuildGraph(ro, *ndIt, attach, batch, cams, lights, anims);\n        }\n    }\n\n    // create a master animation channel for us\n    if (anims.size()) {\n        master->mAnimations = new aiAnimation *[master->mNumAnimations = 1];\n        aiAnimation *anim = master->mAnimations[0] = new aiAnimation();\n        anim->mName.Set(\"LWSMasterAnim\");\n\n        // LWS uses seconds as time units, but we convert to frames\n        anim->mTicksPerSecond = fps;\n        anim->mDuration = last - (first - 1); /* fixme ... zero or one-based?*/\n\n        anim->mChannels = new aiNodeAnim *[anim->mNumChannels = static_cast<unsigned int>(anims.size())];\n        std::copy(anims.begin(), anims.end(), anim->mChannels);\n    }\n\n    // convert the master scene to RH\n    MakeLeftHandedProcess monster_cheat;\n    monster_cheat.Execute(master);\n\n    // .. ccw\n    FlipWindingOrderProcess flipper;\n    flipper.Execute(master);\n\n    // OK ... finally build the output graph\n    SceneCombiner::MergeScenes(&pScene, master, attach,\n            AI_INT_MERGE_SCENE_GEN_UNIQUE_NAMES | (!configSpeedFlag ? (\n                                                                              AI_INT_MERGE_SCENE_GEN_UNIQUE_NAMES_IF_NECESSARY | AI_INT_MERGE_SCENE_GEN_UNIQUE_MATNAMES) :\n                                                                      0));\n\n    // Check flags\n    if (!pScene->mNumMeshes || !pScene->mNumMaterials) {\n        pScene->mFlags |= AI_SCENE_FLAGS_INCOMPLETE;\n\n        if (pScene->mNumAnimations && !noSkeletonMesh) {\n            // construct skeleton mesh\n            SkeletonMeshBuilder builder(pScene);\n        }\n    }\n}\n\n\n\n\n\n\n\n\n// target function\nbool DefaultIOSystem::Exists(const char *pFile) const {\n#ifdef _WIN32\n    struct __stat64 filestat;\n    if (_wstat64(Utf8ToWide(pFile).c_str(), &filestat) != 0) {\n        return false;\n    }\n#else\n    FILE *file = ::fopen(pFile, \"rb\");\n    if (!file) {\n        return false;\n    }\n\n    ::fclose(file);\n#endif\n\n    return true;\n}\n",
    "target": 1,
    "idx": 1057656,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "// context\nxmlNodePtr\nxmlAddNextSibling(xmlNodePtr cur, xmlNodePtr elem) {\n    if ((cur == NULL) || (cur->type == XML_NAMESPACE_DECL)) {\n#ifdef DEBUG_TREE\n        xmlGenericError(xmlGenericErrorContext,\n\t\t\"xmlAddNextSibling : cur == NULL\\n\");\n#endif\n\treturn(NULL);\n    }\n    if ((elem == NULL) || (elem->type == XML_NAMESPACE_DECL)) {\n#ifdef DEBUG_TREE\n        xmlGenericError(xmlGenericErrorContext,\n\t\t\"xmlAddNextSibling : elem == NULL\\n\");\n#endif\n\treturn(NULL);\n    }\n\n    if (cur == elem) {\n#ifdef DEBUG_TREE\n        xmlGenericError(xmlGenericErrorContext,\n\t\t\"xmlAddNextSibling : cur == elem\\n\");\n#endif\n\treturn(NULL);\n    }\n\n    xmlUnlinkNode(elem);\n\n    if (elem->type == XML_TEXT_NODE) {\n\tif (cur->type == XML_TEXT_NODE) {\n\t    xmlNodeAddContent(cur, elem->content);\n\t    xmlFreeNode(elem);\n\t    return(cur);\n\t}\n\tif ((cur->next != NULL) && (cur->next->type == XML_TEXT_NODE) &&\n            (cur->name == cur->next->name)) {\n\t    xmlChar *tmp;\n\n\t    tmp = xmlStrdup(elem->content);\n\t    tmp = xmlStrcat(tmp, cur->next->content);\n\t    xmlNodeSetContent(cur->next, tmp);\n\t    xmlFree(tmp);\n\t    xmlFreeNode(elem);\n\t    return(cur->next);\n\t}\n    } else if (elem->type == XML_ATTRIBUTE_NODE) {\n\t\treturn xmlAddPropSibling(cur, cur, elem);\n    }\n\n    if (elem->doc != cur->doc) {\n\txmlSetTreeDoc(elem, cur->doc);\n    }\n    elem->parent = cur->parent;\n    elem->prev = cur;\n    elem->next = cur->next;\n    cur->next = elem;\n    if (elem->next != NULL)\n\telem->next->prev = elem;\n    if ((elem->parent != NULL) && (elem->parent->last == cur))\n\telem->parent->last = elem;\n    return(elem);\n}\n\nstatic xmlNodePtr\nxmlXIncludeCopyRange(xmlXIncludeCtxtPtr ctxt, xmlDocPtr target,\n\t                xmlDocPtr source, xmlXPathObjectPtr range) {\n    /* pointers to generated nodes */\n    xmlNodePtr list = NULL, last = NULL, listParent = NULL;\n    xmlNodePtr tmp, tmp2;\n    /* pointers to traversal nodes */\n    xmlNodePtr start, cur, end;\n    int index1, index2;\n    int level = 0, lastLevel = 0, endLevel = 0, endFlag = 0;\n\n    if ((ctxt == NULL) || (target == NULL) || (source == NULL) ||\n\t(range == NULL))\n\treturn(NULL);\n    if (range->type != XPATH_RANGE)\n\treturn(NULL);\n    start = (xmlNodePtr) range->user;\n\n    if ((start == NULL) || (start->type == XML_NAMESPACE_DECL))\n\treturn(NULL);\n    end = range->user2;\n    if (end == NULL)\n\treturn(xmlDocCopyNode(start, target, 1));\n    if (end->type == XML_NAMESPACE_DECL)\n        return(NULL);\n\n    cur = start;\n    index1 = range->index;\n    index2 = range->index2;\n    /*\n     * level is depth of the current node under consideration\n     * list is the pointer to the root of the output tree\n     * listParent is a pointer to the parent of output tree (within\n       the included file) in case we need to add another level\n     * last is a pointer to the last node added to the output tree\n     * lastLevel is the depth of last (relative to the root)\n     */\n    while (cur != NULL) {\n\t/*\n\t * Check if our output tree needs a parent\n\t */\n\tif (level < 0) {\n\t    while (level < 0) {\n\t        /* copy must include namespaces and properties */\n\t        tmp2 = xmlDocCopyNode(listParent, target, 2);\n\t        xmlAddChild(tmp2, list);\n\t        list = tmp2;\n\t        listParent = listParent->parent;\n\t        level++;\n\t    }\n\t    last = list;\n\t    lastLevel = 0;\n\t}\n\t/*\n\t * Check whether we need to change our insertion point\n\t */\n\twhile (level < lastLevel) {\n\t    last = last->parent;\n\t    lastLevel --;\n\t}\n\tif (cur == end) {\t/* Are we at the end of the range? */\n\t    if (cur->type == XML_TEXT_NODE) {\n\t\tconst xmlChar *content = cur->content;\n\t\tint len;\n\n\t\tif (content == NULL) {\n\t\t    tmp = xmlNewTextLen(NULL, 0);\n\t\t} else {\n\t\t    len = index2;\n\t\t    if ((cur == start) && (index1 > 1)) {\n\t\t\tcontent += (index1 - 1);\n\t\t\tlen -= (index1 - 1);\n\t\t    } else {\n\t\t\tlen = index2;\n\t\t    }\n\t\t    tmp = xmlNewTextLen(content, len);\n\t\t}\n\t\t/* single sub text node selection */\n\t\tif (list == NULL)\n\t\t    return(tmp);\n\t\t/* prune and return full set */\n\t\tif (level == lastLevel)\n\t\t    xmlAddNextSibling(last, tmp);\n\t\telse\n\t\t    xmlAddChild(last, tmp);\n\t\treturn(list);\n\t    } else {\t/* ending node not a text node */\n\t        endLevel = level;\t/* remember the level of the end node */\n\t\tendFlag = 1;\n\t\t/* last node - need to take care of properties + namespaces */\n\t\ttmp = xmlDocCopyNode(cur, target, 2);\n\t\tif (list == NULL) {\n\t\t    list = tmp;\n\t\t    listParent = cur->parent;\n\t\t    last = tmp;\n\t\t} else {\n\t\t    if (level == lastLevel)\n\t\t\tlast = xmlAddNextSibling(last, tmp);\n\t\t    else {\n\t\t\tlast = xmlAddChild(last, tmp);\n\t\t\tlastLevel = level;\n\t\t    }\n\t\t}\n\n\t\tif (index2 > 1) {\n\t\t    end = xmlXIncludeGetNthChild(cur, index2 - 1);\n\t\t    index2 = 0;\n\t\t}\n\t\tif ((cur == start) && (index1 > 1)) {\n\t\t    cur = xmlXIncludeGetNthChild(cur, index1 - 1);\n\t\t    index1 = 0;\n\t\t}  else {\n\t\t    cur = cur->children;\n\t\t}\n\t\tlevel++;\t/* increment level to show change */\n\t\t/*\n\t\t * Now gather the remaining nodes from cur to end\n\t\t */\n\t\tcontinue;\t/* while */\n\t    }\n\t} else if (cur == start) {\t/* Not at the end, are we at start? */\n\t    if ((cur->type == XML_TEXT_NODE) ||\n\t\t(cur->type == XML_CDATA_SECTION_NODE)) {\n\t\tconst xmlChar *content = cur->content;\n\n\t\tif (content == NULL) {\n\t\t    tmp = xmlNewTextLen(NULL, 0);\n\t\t} else {\n\t\t    if (index1 > 1) {\n\t\t\tcontent += (index1 - 1);\n\t\t\tindex1 = 0;\n\t\t    }\n\t\t    tmp = xmlNewText(content);\n\t\t}\n\t\tlast = list = tmp;\n\t\tlistParent = cur->parent;\n\t    } else {\t\t/* Not text node */\n\t        /*\n\t\t * start of the range - need to take care of\n\t\t * properties and namespaces\n\t\t */\n\t\ttmp = xmlDocCopyNode(cur, target, 2);\n\t\tlist = last = tmp;\n\t\tlistParent = cur->parent;\n\t\tif (index1 > 1) {\t/* Do we need to position? */\n\t\t    cur = xmlXIncludeGetNthChild(cur, index1 - 1);\n\t\t    level = lastLevel = 1;\n\t\t    index1 = 0;\n\t\t    /*\n\t\t     * Now gather the remaining nodes from cur to end\n\t\t     */\n\t\t    continue; /* while */\n\t\t}\n\t    }\n\t} else {\n\t    tmp = NULL;\n\t    switch (cur->type) {\n\t\tcase XML_DTD_NODE:\n\t\tcase XML_ELEMENT_DECL:\n\t\tcase XML_ATTRIBUTE_DECL:\n\t\tcase XML_ENTITY_NODE:\n\t\t    /* Do not copy DTD information */\n\t\t    break;\n\t\tcase XML_ENTITY_DECL:\n\t\t    /* handle crossing entities -> stack needed */\n\t\t    break;\n\t\tcase XML_XINCLUDE_START:\n\t\tcase XML_XINCLUDE_END:\n\t\t    /* don't consider it part of the tree content */\n\t\t    break;\n\t\tcase XML_ATTRIBUTE_NODE:\n\t\t    /* Humm, should not happen ! */\n\t\t    break;\n\t\tdefault:\n\t\t    /*\n\t\t     * Middle of the range - need to take care of\n\t\t     * properties and namespaces\n\t\t     */\n\t\t    tmp = xmlDocCopyNode(cur, target, 2);\n\t\t    break;\n\t    }\n\t    if (tmp != NULL) {\n\t\tif (level == lastLevel)\n\t\t    last = xmlAddNextSibling(last, tmp);\n\t\telse {\n\t\t    last = xmlAddChild(last, tmp);\n\t\t    lastLevel = level;\n\t\t}\n\t    }\n\t}\n\t/*\n\t * Skip to next node in document order\n\t */\n\tcur = xmlXPtrAdvanceNode(cur, &level);\n\tif (endFlag && (level >= endLevel))\n\t    break;\n    }\n    return(list);\n}\n\nstatic xmlNodePtr\nxmlXIncludeCopyXPointer(xmlXIncludeCtxtPtr ctxt, xmlDocPtr target,\n\t                xmlDocPtr source, xmlXPathObjectPtr obj) {\n    xmlNodePtr list = NULL, last = NULL;\n    int i;\n\n    if (source == NULL)\n\tsource = ctxt->doc;\n    if ((ctxt == NULL) || (target == NULL) || (source == NULL) ||\n\t(obj == NULL))\n\treturn(NULL);\n    switch (obj->type) {\n        case XPATH_NODESET: {\n\t    xmlNodeSetPtr set = obj->nodesetval;\n\t    if (set == NULL)\n\t\treturn(NULL);\n\t    for (i = 0;i < set->nodeNr;i++) {\n\t\tif (set->nodeTab[i] == NULL)\n\t\t    continue;\n\t\tswitch (set->nodeTab[i]->type) {\n\t\t    case XML_TEXT_NODE:\n\t\t    case XML_CDATA_SECTION_NODE:\n\t\t    case XML_ELEMENT_NODE:\n\t\t    case XML_ENTITY_REF_NODE:\n\t\t    case XML_ENTITY_NODE:\n\t\t    case XML_PI_NODE:\n\t\t    case XML_COMMENT_NODE:\n\t\t    case XML_DOCUMENT_NODE:\n\t\t    case XML_HTML_DOCUMENT_NODE:\n#ifdef LIBXML_DOCB_ENABLED\n\t\t    case XML_DOCB_DOCUMENT_NODE:\n#endif\n\t\t    case XML_XINCLUDE_END:\n\t\t\tbreak;\n\t\t    case XML_XINCLUDE_START: {\n\t                xmlNodePtr tmp, cur = set->nodeTab[i];\n\n\t\t\tcur = cur->next;\n\t\t\twhile (cur != NULL) {\n\t\t\t    switch(cur->type) {\n\t\t\t\tcase XML_TEXT_NODE:\n\t\t\t\tcase XML_CDATA_SECTION_NODE:\n\t\t\t\tcase XML_ELEMENT_NODE:\n\t\t\t\tcase XML_ENTITY_REF_NODE:\n\t\t\t\tcase XML_ENTITY_NODE:\n\t\t\t\tcase XML_PI_NODE:\n\t\t\t\tcase XML_COMMENT_NODE:\n\t\t\t\t    tmp = xmlXIncludeCopyNode(ctxt, target,\n\t\t\t\t\t\t\t      source, cur);\n\t\t\t\t    if (last == NULL) {\n\t\t\t\t\tlist = last = tmp;\n\t\t\t\t    } else {\n\t\t\t\t\tlast = xmlAddNextSibling(last, tmp);\n\t\t\t\t    }\n\t\t\t\t    cur = cur->next;\n\t\t\t\t    continue;\n\t\t\t\tdefault:\n\t\t\t\t    break;\n\t\t\t    }\n\t\t\t    break;\n\t\t\t}\n\t\t\tcontinue;\n\t\t    }\n\t\t    case XML_ATTRIBUTE_NODE:\n\t\t    case XML_NAMESPACE_DECL:\n\t\t    case XML_DOCUMENT_TYPE_NODE:\n\t\t    case XML_DOCUMENT_FRAG_NODE:\n\t\t    case XML_NOTATION_NODE:\n\t\t    case XML_DTD_NODE:\n\t\t    case XML_ELEMENT_DECL:\n\t\t    case XML_ATTRIBUTE_DECL:\n\t\t    case XML_ENTITY_DECL:\n\t\t\tcontinue; /* for */\n\t\t}\n\t\tif (last == NULL)\n\t\t    list = last = xmlXIncludeCopyNode(ctxt, target, source,\n\t\t\t                              set->nodeTab[i]);\n\t\telse {\n\t\t    xmlAddNextSibling(last,\n\t\t\t    xmlXIncludeCopyNode(ctxt, target, source,\n\t\t\t\t                set->nodeTab[i]));\n\t\t    if (last->next != NULL)\n\t\t\tlast = last->next;\n\t\t}\n\t    }\n\t    break;\n\t}\n#ifdef LIBXML_XPTR_ENABLED\n\tcase XPATH_LOCATIONSET: {\n\t    xmlLocationSetPtr set = (xmlLocationSetPtr) obj->user;\n\t    if (set == NULL)\n\t\treturn(NULL);\n\t    for (i = 0;i < set->locNr;i++) {\n\t\tif (last == NULL)\n\t\t    list = last = xmlXIncludeCopyXPointer(ctxt, target, source,\n\t\t\t                                  set->locTab[i]);\n\t\telse\n\t\t    xmlAddNextSibling(last,\n\t\t\t    xmlXIncludeCopyXPointer(ctxt, target, source,\n\t\t\t\t                    set->locTab[i]));\n\t\tif (last != NULL) {\n\t\t    while (last->next != NULL)\n\t\t\tlast = last->next;\n\t\t}\n\t    }\n\t    break;\n\t}\n\tcase XPATH_RANGE:\n\t    return(xmlXIncludeCopyRange(ctxt, target, source, obj));\n#endif\n\tcase XPATH_POINT:\n\t    /* points are ignored in XInclude */\n\t    break;\n\tdefault:\n\t    break;\n    }\n    return(list);\n}\n\nstatic xmlNodePtr\nxmlXIncludeCopyXPointer(xmlXIncludeCtxtPtr ctxt, xmlDocPtr target,\n\t                xmlDocPtr source, xmlXPathObjectPtr obj) {\n    xmlNodePtr list = NULL, last = NULL;\n    int i;\n\n    if (source == NULL)\n\tsource = ctxt->doc;\n    if ((ctxt == NULL) || (target == NULL) || (source == NULL) ||\n\t(obj == NULL))\n\treturn(NULL);\n    switch (obj->type) {\n        case XPATH_NODESET: {\n\t    xmlNodeSetPtr set = obj->nodesetval;\n\t    if (set == NULL)\n\t\treturn(NULL);\n\t    for (i = 0;i < set->nodeNr;i++) {\n\t\tif (set->nodeTab[i] == NULL)\n\t\t    continue;\n\t\tswitch (set->nodeTab[i]->type) {\n\t\t    case XML_TEXT_NODE:\n\t\t    case XML_CDATA_SECTION_NODE:\n\t\t    case XML_ELEMENT_NODE:\n\t\t    case XML_ENTITY_REF_NODE:\n\t\t    case XML_ENTITY_NODE:\n\t\t    case XML_PI_NODE:\n\t\t    case XML_COMMENT_NODE:\n\t\t    case XML_DOCUMENT_NODE:\n\t\t    case XML_HTML_DOCUMENT_NODE:\n#ifdef LIBXML_DOCB_ENABLED\n\t\t    case XML_DOCB_DOCUMENT_NODE:\n#endif\n\t\t    case XML_XINCLUDE_END:\n\t\t\tbreak;\n\t\t    case XML_XINCLUDE_START: {\n\t                xmlNodePtr tmp, cur = set->nodeTab[i];\n\n\t\t\tcur = cur->next;\n\t\t\twhile (cur != NULL) {\n\t\t\t    switch(cur->type) {\n\t\t\t\tcase XML_TEXT_NODE:\n\t\t\t\tcase XML_CDATA_SECTION_NODE:\n\t\t\t\tcase XML_ELEMENT_NODE:\n\t\t\t\tcase XML_ENTITY_REF_NODE:\n\t\t\t\tcase XML_ENTITY_NODE:\n\t\t\t\tcase XML_PI_NODE:\n\t\t\t\tcase XML_COMMENT_NODE:\n\t\t\t\t    tmp = xmlXIncludeCopyNode(ctxt, target,\n\t\t\t\t\t\t\t      source, cur);\n\t\t\t\t    if (last == NULL) {\n\t\t\t\t\tlist = last = tmp;\n\t\t\t\t    } else {\n\t\t\t\t\tlast = xmlAddNextSibling(last, tmp);\n\t\t\t\t    }\n\t\t\t\t    cur = cur->next;\n\t\t\t\t    continue;\n\t\t\t\tdefault:\n\t\t\t\t    break;\n\t\t\t    }\n\t\t\t    break;\n\t\t\t}\n\t\t\tcontinue;\n\t\t    }\n\t\t    case XML_ATTRIBUTE_NODE:\n\t\t    case XML_NAMESPACE_DECL:\n\t\t    case XML_DOCUMENT_TYPE_NODE:\n\t\t    case XML_DOCUMENT_FRAG_NODE:\n\t\t    case XML_NOTATION_NODE:\n\t\t    case XML_DTD_NODE:\n\t\t    case XML_ELEMENT_DECL:\n\t\t    case XML_ATTRIBUTE_DECL:\n\t\t    case XML_ENTITY_DECL:\n\t\t\tcontinue; /* for */\n\t\t}\n\t\tif (last == NULL)\n\t\t    list = last = xmlXIncludeCopyNode(ctxt, target, source,\n\t\t\t                              set->nodeTab[i]);\n\t\telse {\n\t\t    xmlAddNextSibling(last,\n\t\t\t    xmlXIncludeCopyNode(ctxt, target, source,\n\t\t\t\t                set->nodeTab[i]));\n\t\t    if (last->next != NULL)\n\t\t\tlast = last->next;\n\t\t}\n\t    }\n\t    break;\n\t}\n#ifdef LIBXML_XPTR_ENABLED\n\tcase XPATH_LOCATIONSET: {\n\t    xmlLocationSetPtr set = (xmlLocationSetPtr) obj->user;\n\t    if (set == NULL)\n\t\treturn(NULL);\n\t    for (i = 0;i < set->locNr;i++) {\n\t\tif (last == NULL)\n\t\t    list = last = xmlXIncludeCopyXPointer(ctxt, target, source,\n\t\t\t                                  set->locTab[i]);\n\t\telse\n\t\t    xmlAddNextSibling(last,\n\t\t\t    xmlXIncludeCopyXPointer(ctxt, target, source,\n\t\t\t\t                    set->locTab[i]));\n\t\tif (last != NULL) {\n\t\t    while (last->next != NULL)\n\t\t\tlast = last->next;\n\t\t}\n\t    }\n\t    break;\n\t}\n\tcase XPATH_RANGE:\n\t    return(xmlXIncludeCopyRange(ctxt, target, source, obj));\n#endif\n\tcase XPATH_POINT:\n\t    /* points are ignored in XInclude */\n\t    break;\n\tdefault:\n\t    break;\n    }\n    return(list);\n}\n\nstatic int\nxmlXIncludeLoadDoc(xmlXIncludeCtxtPtr ctxt, const xmlChar *url, int nr) {\n    xmlDocPtr doc;\n    xmlURIPtr uri;\n    xmlChar *URL;\n    xmlChar *fragment = NULL;\n    int i = 0;\n#ifdef LIBXML_XPTR_ENABLED\n    int saveFlags;\n#endif\n\n#ifdef DEBUG_XINCLUDE\n    xmlGenericError(xmlGenericErrorContext, \"Loading doc %s:%d\\n\", url, nr);\n#endif\n    /*\n     * Check the URL and remove any fragment identifier\n     */\n    uri = xmlParseURI((const char *)url);\n    if (uri == NULL) {\n\txmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t               XML_XINCLUDE_HREF_URI,\n\t\t       \"invalid value URI %s\\n\", url);\n\treturn(-1);\n    }\n    if (uri->fragment != NULL) {\n\tfragment = (xmlChar *) uri->fragment;\n\turi->fragment = NULL;\n    }\n    if ((ctxt->incTab != NULL) && (ctxt->incTab[nr] != NULL) &&\n        (ctxt->incTab[nr]->fragment != NULL)) {\n\tif (fragment != NULL) xmlFree(fragment);\n\tfragment = xmlStrdup(ctxt->incTab[nr]->fragment);\n    }\n    URL = xmlSaveUri(uri);\n    xmlFreeURI(uri);\n    if (URL == NULL) {\n        if (ctxt->incTab != NULL)\n\t    xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t\t\t   XML_XINCLUDE_HREF_URI,\n\t\t\t   \"invalid value URI %s\\n\", url);\n\telse\n\t    xmlXIncludeErr(ctxt, NULL,\n\t\t\t   XML_XINCLUDE_HREF_URI,\n\t\t\t   \"invalid value URI %s\\n\", url);\n\tif (fragment != NULL)\n\t    xmlFree(fragment);\n\treturn(-1);\n    }\n\n    /*\n     * Handling of references to the local document are done\n     * directly through ctxt->doc.\n     */\n    if ((URL[0] == 0) || (URL[0] == '#') ||\n\t((ctxt->doc != NULL) && (xmlStrEqual(URL, ctxt->doc->URL)))) {\n\tdoc = ctxt->doc;\n        goto loaded;\n    }\n\n    /*\n     * Prevent reloading twice the document.\n     */\n    for (i = 0; i < ctxt->incNr; i++) {\n\tif ((xmlStrEqual(URL, ctxt->incTab[i]->URI)) &&\n\t    (ctxt->incTab[i]->doc != NULL)) {\n\t    doc = ctxt->incTab[i]->doc;\n#ifdef DEBUG_XINCLUDE\n\t    printf(\"Already loaded %s\\n\", URL);\n#endif\n\t    goto loaded;\n\t}\n    }\n\n    /*\n     * Load it.\n     */\n#ifdef DEBUG_XINCLUDE\n    printf(\"loading %s\\n\", URL);\n#endif\n#ifdef LIBXML_XPTR_ENABLED\n    /*\n     * If this is an XPointer evaluation, we want to assure that\n     * all entities have been resolved prior to processing the\n     * referenced document\n     */\n    saveFlags = ctxt->parseFlags;\n    if (fragment != NULL) {\t/* if this is an XPointer eval */\n\tctxt->parseFlags |= XML_PARSE_NOENT;\n    }\n#endif\n\n    doc = xmlXIncludeParseFile(ctxt, (const char *)URL);\n#ifdef LIBXML_XPTR_ENABLED\n    ctxt->parseFlags = saveFlags;\n#endif\n    if (doc == NULL) {\n\txmlFree(URL);\n\tif (fragment != NULL)\n\t    xmlFree(fragment);\n\treturn(-1);\n    }\n    ctxt->incTab[nr]->doc = doc;\n    /*\n     * It's possible that the requested URL has been mapped to a\n     * completely different location (e.g. through a catalog entry).\n     * To check for this, we compare the URL with that of the doc\n     * and change it if they disagree (bug 146988).\n     */\n   if (!xmlStrEqual(URL, doc->URL)) {\n       xmlFree(URL);\n       URL = xmlStrdup(doc->URL);\n   }\n    for (i = nr + 1; i < ctxt->incNr; i++) {\n\tif (xmlStrEqual(URL, ctxt->incTab[i]->URI)) {\n\t    ctxt->incTab[nr]->count++;\n#ifdef DEBUG_XINCLUDE\n\t    printf(\"Increasing %s count since reused\\n\", URL);\n#endif\n            break;\n\t}\n    }\n\n    /*\n     * Make sure we have all entities fixed up\n     */\n    xmlXIncludeMergeEntities(ctxt, ctxt->doc, doc);\n\n    /*\n     * We don't need the DTD anymore, free up space\n    if (doc->intSubset != NULL) {\n\txmlUnlinkNode((xmlNodePtr) doc->intSubset);\n\txmlFreeNode((xmlNodePtr) doc->intSubset);\n\tdoc->intSubset = NULL;\n    }\n    if (doc->extSubset != NULL) {\n\txmlUnlinkNode((xmlNodePtr) doc->extSubset);\n\txmlFreeNode((xmlNodePtr) doc->extSubset);\n\tdoc->extSubset = NULL;\n    }\n     */\n    xmlXIncludeRecurseDoc(ctxt, doc, URL);\n\nloaded:\n    if (fragment == NULL) {\n\t/*\n\t * Add the top children list as the replacement copy.\n\t */\n\tctxt->incTab[nr]->inc = xmlXIncludeCopyNodeList(ctxt, ctxt->doc,\n\t\t                                        doc, doc->children);\n    }\n#ifdef LIBXML_XPTR_ENABLED\n    else {\n\t/*\n\t * Computes the XPointer expression and make a copy used\n\t * as the replacement copy.\n\t */\n\txmlXPathObjectPtr xptr;\n\txmlXPathContextPtr xptrctxt;\n\txmlNodeSetPtr set;\n\n\txptrctxt = xmlXPtrNewContext(doc, NULL, NULL);\n\tif (xptrctxt == NULL) {\n\t    xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t                   XML_XINCLUDE_XPTR_FAILED,\n\t\t\t   \"could not create XPointer context\\n\", NULL);\n\t    xmlFree(URL);\n\t    xmlFree(fragment);\n\t    return(-1);\n\t}\n\txptr = xmlXPtrEval(fragment, xptrctxt);\n\tif (xptr == NULL) {\n\t    xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t                   XML_XINCLUDE_XPTR_FAILED,\n\t\t\t   \"XPointer evaluation failed: #%s\\n\",\n\t\t\t   fragment);\n\t    xmlXPathFreeContext(xptrctxt);\n\t    xmlFree(URL);\n\t    xmlFree(fragment);\n\t    return(-1);\n\t}\n\tswitch (xptr->type) {\n\t    case XPATH_UNDEFINED:\n\t    case XPATH_BOOLEAN:\n\t    case XPATH_NUMBER:\n\t    case XPATH_STRING:\n\t    case XPATH_POINT:\n\t    case XPATH_USERS:\n\t    case XPATH_XSLT_TREE:\n\t\txmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t\t               XML_XINCLUDE_XPTR_RESULT,\n\t\t\t       \"XPointer is not a range: #%s\\n\",\n\t\t\t       fragment);\n                xmlXPathFreeObject(xptr);\n\t\txmlXPathFreeContext(xptrctxt);\n\t\txmlFree(URL);\n\t\txmlFree(fragment);\n\t\treturn(-1);\n\t    case XPATH_NODESET:\n\t        if ((xptr->nodesetval == NULL) ||\n\t\t    (xptr->nodesetval->nodeNr <= 0)) {\n                    xmlXPathFreeObject(xptr);\n\t\t    xmlXPathFreeContext(xptrctxt);\n\t\t    xmlFree(URL);\n\t\t    xmlFree(fragment);\n\t\t    return(-1);\n\t\t}\n\n\t    case XPATH_RANGE:\n\t    case XPATH_LOCATIONSET:\n\t\tbreak;\n\t}\n\tset = xptr->nodesetval;\n\tif (set != NULL) {\n\t    for (i = 0;i < set->nodeNr;i++) {\n\t\tif (set->nodeTab[i] == NULL)\n\t\t    continue;\n\t\tswitch (set->nodeTab[i]->type) {\n\t\t    case XML_ELEMENT_NODE:\n\t\t    case XML_TEXT_NODE:\n\t\t    case XML_CDATA_SECTION_NODE:\n\t\t    case XML_ENTITY_REF_NODE:\n\t\t    case XML_ENTITY_NODE:\n\t\t    case XML_PI_NODE:\n\t\t    case XML_COMMENT_NODE:\n\t\t    case XML_DOCUMENT_NODE:\n\t\t    case XML_HTML_DOCUMENT_NODE:\n#ifdef LIBXML_DOCB_ENABLED\n\t\t    case XML_DOCB_DOCUMENT_NODE:\n#endif\n\t\t\tcontinue;\n\n\t\t    case XML_ATTRIBUTE_NODE:\n\t\t\txmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t\t\t               XML_XINCLUDE_XPTR_RESULT,\n\t\t\t\t       \"XPointer selects an attribute: #%s\\n\",\n\t\t\t\t       fragment);\n\t\t\tset->nodeTab[i] = NULL;\n\t\t\tcontinue;\n\t\t    case XML_NAMESPACE_DECL:\n\t\t\txmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t\t\t               XML_XINCLUDE_XPTR_RESULT,\n\t\t\t\t       \"XPointer selects a namespace: #%s\\n\",\n\t\t\t\t       fragment);\n\t\t\tset->nodeTab[i] = NULL;\n\t\t\tcontinue;\n\t\t    case XML_DOCUMENT_TYPE_NODE:\n\t\t    case XML_DOCUMENT_FRAG_NODE:\n\t\t    case XML_NOTATION_NODE:\n\t\t    case XML_DTD_NODE:\n\t\t    case XML_ELEMENT_DECL:\n\t\t    case XML_ATTRIBUTE_DECL:\n\t\t    case XML_ENTITY_DECL:\n\t\t    case XML_XINCLUDE_START:\n\t\t    case XML_XINCLUDE_END:\n\t\t\txmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t\t\t               XML_XINCLUDE_XPTR_RESULT,\n\t\t\t\t   \"XPointer selects unexpected nodes: #%s\\n\",\n\t\t\t\t       fragment);\n\t\t\tset->nodeTab[i] = NULL;\n\t\t\tset->nodeTab[i] = NULL;\n\t\t\tcontinue; /* for */\n\t\t}\n\t    }\n\t}\n        ctxt->incTab[nr]->inc =\n            xmlXIncludeCopyXPointer(ctxt, ctxt->doc, doc, xptr);\n        xmlXPathFreeObject(xptr);\n\txmlXPathFreeContext(xptrctxt);\n\txmlFree(fragment);\n    }\n#endif\n\n    /*\n     * Do the xml:base fixup if needed\n     */\n    if ((doc != NULL) && (URL != NULL) &&\n        (!(ctxt->parseFlags & XML_PARSE_NOBASEFIX)) &&\n\t(!(doc->parseFlags & XML_PARSE_NOBASEFIX))) {\n\txmlNodePtr node;\n\txmlChar *base;\n\txmlChar *curBase;\n\n\t/*\n\t * The base is only adjusted if \"necessary\", i.e. if the xinclude node\n\t * has a base specified, or the URL is relative\n\t */\n\tbase = xmlGetNsProp(ctxt->incTab[nr]->ref, BAD_CAST \"base\",\n\t\t\tXML_XML_NAMESPACE);\n\tif (base == NULL) {\n\t    /*\n\t     * No xml:base on the xinclude node, so we check whether the\n\t     * URI base is different than (relative to) the context base\n\t     */\n\t    curBase = xmlBuildRelativeURI(URL, ctxt->base);\n\t    if (curBase == NULL) {\t/* Error return */\n\t        xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t               XML_XINCLUDE_HREF_URI,\n\t\t       \"trying to build relative URI from %s\\n\", URL);\n\t    } else {\n\t\t/* If the URI doesn't contain a slash, it's not relative */\n\t        if (!xmlStrchr(curBase, (xmlChar) '/'))\n\t\t    xmlFree(curBase);\n\t\telse\n\t\t    base = curBase;\n\t    }\n\t}\n\tif (base != NULL) {\t/* Adjustment may be needed */\n\t    node = ctxt->incTab[nr]->inc;\n\t    while (node != NULL) {\n\t\t/* Only work on element nodes */\n\t\tif (node->type == XML_ELEMENT_NODE) {\n\t\t    curBase = xmlNodeGetBase(node->doc, node);\n\t\t    /* If no current base, set it */\n\t\t    if (curBase == NULL) {\n\t\t\txmlNodeSetBase(node, base);\n\t\t    } else {\n\t\t\t/*\n\t\t\t * If the current base is the same as the\n\t\t\t * URL of the document, then reset it to be\n\t\t\t * the specified xml:base or the relative URI\n\t\t\t */\n\t\t\tif (xmlStrEqual(curBase, node->doc->URL)) {\n\t\t\t    xmlNodeSetBase(node, base);\n\t\t\t} else {\n\t\t\t    /*\n\t\t\t     * If the element already has an xml:base\n\t\t\t     * set, then relativise it if necessary\n\t\t\t     */\n\t\t\t    xmlChar *xmlBase;\n\t\t\t    xmlBase = xmlGetNsProp(node,\n\t\t\t\t\t    BAD_CAST \"base\",\n\t\t\t\t\t    XML_XML_NAMESPACE);\n\t\t\t    if (xmlBase != NULL) {\n\t\t\t\txmlChar *relBase;\n\t\t\t\trelBase = xmlBuildURI(xmlBase, base);\n\t\t\t\tif (relBase == NULL) { /* error */\n\t\t\t\t    xmlXIncludeErr(ctxt,\n\t\t\t\t\t\tctxt->incTab[nr]->ref,\n\t\t\t\t\t\tXML_XINCLUDE_HREF_URI,\n\t\t\t\t\t\"trying to rebuild base from %s\\n\",\n\t\t\t\t\t\txmlBase);\n\t\t\t\t} else {\n\t\t\t\t    xmlNodeSetBase(node, relBase);\n\t\t\t\t    xmlFree(relBase);\n\t\t\t\t}\n\t\t\t\txmlFree(xmlBase);\n\t\t\t    }\n\t\t\t}\n\t\t\txmlFree(curBase);\n\t\t    }\n\t\t}\n\t        node = node->next;\n\t    }\n\t    xmlFree(base);\n\t}\n    }\n    if ((nr < ctxt->incNr) && (ctxt->incTab[nr]->doc != NULL) &&\n\t(ctxt->incTab[nr]->count <= 1)) {\n#ifdef DEBUG_XINCLUDE\n        printf(\"freeing %s\\n\", ctxt->incTab[nr]->doc->URL);\n#endif\n\txmlFreeDoc(ctxt->incTab[nr]->doc);\n\tctxt->incTab[nr]->doc = NULL;\n    }\n    xmlFree(URL);\n    return(0);\n}\n\nstatic int\nxmlXIncludeLoadNode(xmlXIncludeCtxtPtr ctxt, int nr) {\n    xmlNodePtr cur;\n    xmlChar *href;\n    xmlChar *parse;\n    xmlChar *base;\n    xmlChar *oldBase;\n    xmlChar *URI;\n    int xml = 1; /* default Issue 64 */\n    int ret;\n\n    if (ctxt == NULL)\n\treturn(-1);\n    if ((nr < 0) || (nr >= ctxt->incNr))\n\treturn(-1);\n    cur = ctxt->incTab[nr]->ref;\n    if (cur == NULL)\n\treturn(-1);\n\n    /*\n     * read the attributes\n     */\n    href = xmlXIncludeGetProp(ctxt, cur, XINCLUDE_HREF);\n    if (href == NULL) {\n\thref = xmlStrdup(BAD_CAST \"\"); /* @@@@ href is now optional */\n\tif (href == NULL)\n\t    return(-1);\n    }\n    parse = xmlXIncludeGetProp(ctxt, cur, XINCLUDE_PARSE);\n    if (parse != NULL) {\n\tif (xmlStrEqual(parse, XINCLUDE_PARSE_XML))\n\t    xml = 1;\n\telse if (xmlStrEqual(parse, XINCLUDE_PARSE_TEXT))\n\t    xml = 0;\n\telse {\n\t    xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t                   XML_XINCLUDE_PARSE_VALUE,\n\t\t\t   \"invalid value %s for 'parse'\\n\", parse);\n\t    if (href != NULL)\n\t\txmlFree(href);\n\t    if (parse != NULL)\n\t\txmlFree(parse);\n\t    return(-1);\n\t}\n    }\n\n    /*\n     * compute the URI\n     */\n    base = xmlNodeGetBase(ctxt->doc, cur);\n    if (base == NULL) {\n\tURI = xmlBuildURI(href, ctxt->doc->URL);\n    } else {\n\tURI = xmlBuildURI(href, base);\n    }\n    if (URI == NULL) {\n\txmlChar *escbase;\n\txmlChar *eschref;\n\t/*\n\t * Some escaping may be needed\n\t */\n\tescbase = xmlURIEscape(base);\n\teschref = xmlURIEscape(href);\n\tURI = xmlBuildURI(eschref, escbase);\n\tif (escbase != NULL)\n\t    xmlFree(escbase);\n\tif (eschref != NULL)\n\t    xmlFree(eschref);\n    }\n    if (URI == NULL) {\n\txmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t               XML_XINCLUDE_HREF_URI, \"failed build URL\\n\", NULL);\n\tif (parse != NULL)\n\t    xmlFree(parse);\n\tif (href != NULL)\n\t    xmlFree(href);\n\tif (base != NULL)\n\t    xmlFree(base);\n\treturn(-1);\n    }\n#ifdef DEBUG_XINCLUDE\n    xmlGenericError(xmlGenericErrorContext, \"parse: %s\\n\",\n\t    xml ? \"xml\": \"text\");\n    xmlGenericError(xmlGenericErrorContext, \"URI: %s\\n\", URI);\n#endif\n\n    /*\n     * Save the base for this include (saving the current one)\n     */\n    oldBase = ctxt->base;\n    ctxt->base = base;\n\n    if (xml) {\n\tret = xmlXIncludeLoadDoc(ctxt, URI, nr);\n\t/* xmlXIncludeGetFragment(ctxt, cur, URI); */\n    } else {\n\tret = xmlXIncludeLoadTxt(ctxt, URI, nr);\n    }\n\n    /*\n     * Restore the original base before checking for fallback\n     */\n    ctxt->base = oldBase;\n\n    if (ret < 0) {\n\txmlNodePtr children;\n\n\t/*\n\t * Time to try a fallback if available\n\t */\n#ifdef DEBUG_XINCLUDE\n\txmlGenericError(xmlGenericErrorContext, \"error looking for fallback\\n\");\n#endif\n\tchildren = cur->children;\n\twhile (children != NULL) {\n\t    if ((children->type == XML_ELEMENT_NODE) &&\n\t\t(children->ns != NULL) &&\n\t\t(xmlStrEqual(children->name, XINCLUDE_FALLBACK)) &&\n\t\t((xmlStrEqual(children->ns->href, XINCLUDE_NS)) ||\n\t\t (xmlStrEqual(children->ns->href, XINCLUDE_OLD_NS)))) {\n\t\tret = xmlXIncludeLoadFallback(ctxt, children, nr);\n\t\tbreak;\n\t    }\n\t    children = children->next;\n\t}\n    }\n    if (ret < 0) {\n\txmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t               XML_XINCLUDE_NO_FALLBACK,\n\t\t       \"could not load %s, and no fallback was found\\n\",\n\t\t       URI);\n    }\n\n    /*\n     * Cleanup\n     */\n    if (URI != NULL)\n\txmlFree(URI);\n    if (parse != NULL)\n\txmlFree(parse);\n    if (href != NULL)\n\txmlFree(href);\n    if (base != NULL)\n\txmlFree(base);\n    return(0);\n}\n\nstatic int\nxmlXIncludeDoProcess(xmlXIncludeCtxtPtr ctxt, xmlDocPtr doc, xmlNodePtr tree,\n                     int skipRoot) {\n    xmlNodePtr cur;\n    int ret = 0;\n    int i, start;\n\n    if ((doc == NULL) || (tree == NULL) || (tree->type == XML_NAMESPACE_DECL))\n\treturn(-1);\n    if ((skipRoot) && (tree->children == NULL))\n        return(-1);\n    if (ctxt == NULL)\n\treturn(-1);\n\n    if (doc->URL != NULL) {\n\tret = xmlXIncludeURLPush(ctxt, doc->URL);\n\tif (ret < 0)\n\t    return(-1);\n    }\n    start = ctxt->incNr;\n\n    /*\n     * TODO: The phases must run separately for recursive inclusions.\n     *\n     * - Phase 1 should start with top-level XInclude nodes, load documents,\n     *   execute XPointer expressions, then process only the result nodes\n     *   (not whole document, see bug #324081) and only for phase 1\n     *   recursively. We will need a backreference from xmlNodes to\n     *   xmlIncludeRefs to detect references that were already visited.\n     *   This can also be used for proper cycle detection, see bug #344240.\n     *\n     * - Phase 2 should visit all top-level XInclude nodes and expand\n     *   possible subreferences in the replacement recursively.\n     *\n     * - Phase 3 should finally replace the top-level XInclude nodes.\n     *   It could also be run together with phase 2.\n     */\n\n    /*\n     * First phase: lookup the elements in the document\n     */\n    if (skipRoot)\n        cur = tree->children;\n    else\n        cur = tree;\n    do {\n\t/* TODO: need to work on entities -> stack */\n        if (xmlXIncludeTestNode(ctxt, cur) == 1) {\n#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n            /*\n             * Avoid superlinear expansion by limiting the total number\n             * of replacements.\n             */\n            if (ctxt->incTotal >= 20)\n                return(-1);\n#endif\n            ctxt->incTotal++;\n            xmlXIncludePreProcessNode(ctxt, cur);\n        } else if ((cur->children != NULL) &&\n                   ((cur->type == XML_DOCUMENT_NODE) ||\n                    (cur->type == XML_ELEMENT_NODE))) {\n            cur = cur->children;\n            continue;\n        }\n        do {\n            if (cur == tree)\n                break;\n            if (cur->next != NULL) {\n                cur = cur->next;\n                break;\n            }\n            cur = cur->parent;\n        } while (cur != NULL);\n    } while ((cur != NULL) && (cur != tree));\n\n    /*\n     * Second Phase : collect the infosets fragments\n     */\n    for (i = start;i < ctxt->incNr; i++) {\n        xmlXIncludeLoadNode(ctxt, i);\n\tret++;\n    }\n\n    /*\n     * Third phase: extend the original document infoset.\n     *\n     * Originally we bypassed the inclusion if there were any errors\n     * encountered on any of the XIncludes.  A bug was raised (bug\n     * 132588) requesting that we output the XIncludes without error,\n     * so the check for inc!=NULL || xptr!=NULL was put in.  This may\n     * give some other problems in the future, but for now it seems to\n     * work ok.\n     *\n     */\n    for (i = ctxt->incBase;i < ctxt->incNr; i++) {\n\tif ((ctxt->incTab[i]->inc != NULL) ||\n\t    (ctxt->incTab[i]->emptyFb != 0))\t/* (empty fallback) */\n\t    xmlXIncludeIncludeNode(ctxt, i);\n    }\n\n    if (doc->URL != NULL)\n\txmlXIncludeURLPop(ctxt);\n    return(ret);\n}\n\nint\nxmlXIncludeProcessTreeFlagsData(xmlNodePtr tree, int flags, void *data) {\n    xmlXIncludeCtxtPtr ctxt;\n    int ret = 0;\n\n    if ((tree == NULL) || (tree->type == XML_NAMESPACE_DECL) ||\n        (tree->doc == NULL))\n        return(-1);\n\n    ctxt = xmlXIncludeNewContext(tree->doc);\n    if (ctxt == NULL)\n        return(-1);\n    ctxt->_private = data;\n    ctxt->base = xmlStrdup((xmlChar *)tree->doc->URL);\n    xmlXIncludeSetFlags(ctxt, flags);\n    ret = xmlXIncludeDoProcess(ctxt, tree->doc, tree, 0);\n    if ((ret >= 0) && (ctxt->nbErrors > 0))\n        ret = -1;\n\n    xmlXIncludeFreeContext(ctxt);\n    return(ret);\n}\n\nint\nxmlXIncludeProcessFlagsData(xmlDocPtr doc, int flags, void *data) {\n    xmlNodePtr tree;\n\n    if (doc == NULL)\n\treturn(-1);\n    tree = xmlDocGetRootElement(doc);\n    if (tree == NULL)\n\treturn(-1);\n    return(xmlXIncludeProcessTreeFlagsData(tree, flags, data));\n}\n\nint\nxmlXIncludeProcessFlags(xmlDocPtr doc, int flags) {\n    return xmlXIncludeProcessFlagsData(doc, flags, NULL);\n}\n\n\n// target function\nstatic xmlNodePtr\nxmlXIncludeCopyRange(xmlXIncludeCtxtPtr ctxt, xmlDocPtr target,\n\t                xmlDocPtr source, xmlXPathObjectPtr range) {\n    /* pointers to generated nodes */\n    xmlNodePtr list = NULL, last = NULL, listParent = NULL;\n    xmlNodePtr tmp, tmp2;\n    /* pointers to traversal nodes */\n    xmlNodePtr start, cur, end;\n    int index1, index2;\n    int level = 0, lastLevel = 0, endLevel = 0, endFlag = 0;\n\n    if ((ctxt == NULL) || (target == NULL) || (source == NULL) ||\n\t(range == NULL))\n\treturn(NULL);\n    if (range->type != XPATH_RANGE)\n\treturn(NULL);\n    start = (xmlNodePtr) range->user;\n\n    if ((start == NULL) || (start->type == XML_NAMESPACE_DECL))\n\treturn(NULL);\n    end = range->user2;\n    if (end == NULL)\n\treturn(xmlDocCopyNode(start, target, 1));\n    if (end->type == XML_NAMESPACE_DECL)\n        return(NULL);\n\n    cur = start;\n    index1 = range->index;\n    index2 = range->index2;\n    /*\n     * level is depth of the current node under consideration\n     * list is the pointer to the root of the output tree\n     * listParent is a pointer to the parent of output tree (within\n       the included file) in case we need to add another level\n     * last is a pointer to the last node added to the output tree\n     * lastLevel is the depth of last (relative to the root)\n     */\n    while (cur != NULL) {\n\t/*\n\t * Check if our output tree needs a parent\n\t */\n\tif (level < 0) {\n\t    while (level < 0) {\n\t        /* copy must include namespaces and properties */\n\t        tmp2 = xmlDocCopyNode(listParent, target, 2);\n\t        xmlAddChild(tmp2, list);\n\t        list = tmp2;\n\t        listParent = listParent->parent;\n\t        level++;\n\t    }\n\t    last = list;\n\t    lastLevel = 0;\n\t}\n\t/*\n\t * Check whether we need to change our insertion point\n\t */\n\twhile (level < lastLevel) {\n\t    last = last->parent;\n\t    lastLevel --;\n\t}\n\tif (cur == end) {\t/* Are we at the end of the range? */\n\t    if (cur->type == XML_TEXT_NODE) {\n\t\tconst xmlChar *content = cur->content;\n\t\tint len;\n\n\t\tif (content == NULL) {\n\t\t    tmp = xmlNewTextLen(NULL, 0);\n\t\t} else {\n\t\t    len = index2;\n\t\t    if ((cur == start) && (index1 > 1)) {\n\t\t\tcontent += (index1 - 1);\n\t\t\tlen -= (index1 - 1);\n\t\t    } else {\n\t\t\tlen = index2;\n\t\t    }\n\t\t    tmp = xmlNewTextLen(content, len);\n\t\t}\n\t\t/* single sub text node selection */\n\t\tif (list == NULL)\n\t\t    return(tmp);\n\t\t/* prune and return full set */\n\t\tif (level == lastLevel)\n\t\t    xmlAddNextSibling(last, tmp);\n\t\telse\n\t\t    xmlAddChild(last, tmp);\n\t\treturn(list);\n\t    } else {\t/* ending node not a text node */\n\t        endLevel = level;\t/* remember the level of the end node */\n\t\tendFlag = 1;\n\t\t/* last node - need to take care of properties + namespaces */\n\t\ttmp = xmlDocCopyNode(cur, target, 2);\n\t\tif (list == NULL) {\n\t\t    list = tmp;\n\t\t    listParent = cur->parent;\n\t\t} else {\n\t\t    if (level == lastLevel)\n\t\t\txmlAddNextSibling(last, tmp);\n\t\t    else {\n\t\t\txmlAddChild(last, tmp);\n\t\t\tlastLevel = level;\n\t\t    }\n\t\t}\n\t\tlast = tmp;\n\n\t\tif (index2 > 1) {\n\t\t    end = xmlXIncludeGetNthChild(cur, index2 - 1);\n\t\t    index2 = 0;\n\t\t}\n\t\tif ((cur == start) && (index1 > 1)) {\n\t\t    cur = xmlXIncludeGetNthChild(cur, index1 - 1);\n\t\t    index1 = 0;\n\t\t}  else {\n\t\t    cur = cur->children;\n\t\t}\n\t\tlevel++;\t/* increment level to show change */\n\t\t/*\n\t\t * Now gather the remaining nodes from cur to end\n\t\t */\n\t\tcontinue;\t/* while */\n\t    }\n\t} else if (cur == start) {\t/* Not at the end, are we at start? */\n\t    if ((cur->type == XML_TEXT_NODE) ||\n\t\t(cur->type == XML_CDATA_SECTION_NODE)) {\n\t\tconst xmlChar *content = cur->content;\n\n\t\tif (content == NULL) {\n\t\t    tmp = xmlNewTextLen(NULL, 0);\n\t\t} else {\n\t\t    if (index1 > 1) {\n\t\t\tcontent += (index1 - 1);\n\t\t\tindex1 = 0;\n\t\t    }\n\t\t    tmp = xmlNewText(content);\n\t\t}\n\t\tlast = list = tmp;\n\t\tlistParent = cur->parent;\n\t    } else {\t\t/* Not text node */\n\t        /*\n\t\t * start of the range - need to take care of\n\t\t * properties and namespaces\n\t\t */\n\t\ttmp = xmlDocCopyNode(cur, target, 2);\n\t\tlist = last = tmp;\n\t\tlistParent = cur->parent;\n\t\tif (index1 > 1) {\t/* Do we need to position? */\n\t\t    cur = xmlXIncludeGetNthChild(cur, index1 - 1);\n\t\t    level = lastLevel = 1;\n\t\t    index1 = 0;\n\t\t    /*\n\t\t     * Now gather the remaining nodes from cur to end\n\t\t     */\n\t\t    continue; /* while */\n\t\t}\n\t    }\n\t} else {\n\t    tmp = NULL;\n\t    switch (cur->type) {\n\t\tcase XML_DTD_NODE:\n\t\tcase XML_ELEMENT_DECL:\n\t\tcase XML_ATTRIBUTE_DECL:\n\t\tcase XML_ENTITY_NODE:\n\t\t    /* Do not copy DTD information */\n\t\t    break;\n\t\tcase XML_ENTITY_DECL:\n\t\t    /* handle crossing entities -> stack needed */\n\t\t    break;\n\t\tcase XML_XINCLUDE_START:\n\t\tcase XML_XINCLUDE_END:\n\t\t    /* don't consider it part of the tree content */\n\t\t    break;\n\t\tcase XML_ATTRIBUTE_NODE:\n\t\t    /* Humm, should not happen ! */\n\t\t    break;\n\t\tdefault:\n\t\t    /*\n\t\t     * Middle of the range - need to take care of\n\t\t     * properties and namespaces\n\t\t     */\n\t\t    tmp = xmlDocCopyNode(cur, target, 2);\n\t\t    break;\n\t    }\n\t    if (tmp != NULL) {\n\t\tif (level == lastLevel)\n\t\t    xmlAddNextSibling(last, tmp);\n\t\telse {\n\t\t    xmlAddChild(last, tmp);\n\t\t    lastLevel = level;\n\t\t}\n\t\tlast = tmp;\n\t    }\n\t}\n\t/*\n\t * Skip to next node in document order\n\t */\n\tcur = xmlXPtrAdvanceNode(cur, &level);\n\tif (endFlag && (level >= endLevel))\n\t    break;\n    }\n    return(list);\n}\nstatic xmlNodePtr\nxmlXIncludeCopyXPointer(xmlXIncludeCtxtPtr ctxt, xmlDocPtr target,\n\t                xmlDocPtr source, xmlXPathObjectPtr obj) {\n    xmlNodePtr list = NULL, last = NULL;\n    int i;\n\n    if (source == NULL)\n\tsource = ctxt->doc;\n    if ((ctxt == NULL) || (target == NULL) || (source == NULL) ||\n\t(obj == NULL))\n\treturn(NULL);\n    switch (obj->type) {\n        case XPATH_NODESET: {\n\t    xmlNodeSetPtr set = obj->nodesetval;\n\t    if (set == NULL)\n\t\treturn(NULL);\n\t    for (i = 0;i < set->nodeNr;i++) {\n\t\tif (set->nodeTab[i] == NULL)\n\t\t    continue;\n\t\tswitch (set->nodeTab[i]->type) {\n\t\t    case XML_TEXT_NODE:\n\t\t    case XML_CDATA_SECTION_NODE:\n\t\t    case XML_ELEMENT_NODE:\n\t\t    case XML_ENTITY_REF_NODE:\n\t\t    case XML_ENTITY_NODE:\n\t\t    case XML_PI_NODE:\n\t\t    case XML_COMMENT_NODE:\n\t\t    case XML_DOCUMENT_NODE:\n\t\t    case XML_HTML_DOCUMENT_NODE:\n#ifdef LIBXML_DOCB_ENABLED\n\t\t    case XML_DOCB_DOCUMENT_NODE:\n#endif\n\t\t    case XML_XINCLUDE_END:\n\t\t\tbreak;\n\t\t    case XML_XINCLUDE_START: {\n\t                xmlNodePtr tmp, cur = set->nodeTab[i];\n\n\t\t\tcur = cur->next;\n\t\t\twhile (cur != NULL) {\n\t\t\t    switch(cur->type) {\n\t\t\t\tcase XML_TEXT_NODE:\n\t\t\t\tcase XML_CDATA_SECTION_NODE:\n\t\t\t\tcase XML_ELEMENT_NODE:\n\t\t\t\tcase XML_ENTITY_REF_NODE:\n\t\t\t\tcase XML_ENTITY_NODE:\n\t\t\t\tcase XML_PI_NODE:\n\t\t\t\tcase XML_COMMENT_NODE:\n\t\t\t\t    tmp = xmlXIncludeCopyNode(ctxt, target,\n\t\t\t\t\t\t\t      source, cur);\n\t\t\t\t    if (last == NULL) {\n\t\t\t\t\tlist = last = tmp;\n\t\t\t\t    } else {\n\t\t\t\t\txmlAddNextSibling(last, tmp);\n\t\t\t\t\tlast = tmp;\n\t\t\t\t    }\n\t\t\t\t    cur = cur->next;\n\t\t\t\t    continue;\n\t\t\t\tdefault:\n\t\t\t\t    break;\n\t\t\t    }\n\t\t\t    break;\n\t\t\t}\n\t\t\tcontinue;\n\t\t    }\n\t\t    case XML_ATTRIBUTE_NODE:\n\t\t    case XML_NAMESPACE_DECL:\n\t\t    case XML_DOCUMENT_TYPE_NODE:\n\t\t    case XML_DOCUMENT_FRAG_NODE:\n\t\t    case XML_NOTATION_NODE:\n\t\t    case XML_DTD_NODE:\n\t\t    case XML_ELEMENT_DECL:\n\t\t    case XML_ATTRIBUTE_DECL:\n\t\t    case XML_ENTITY_DECL:\n\t\t\tcontinue; /* for */\n\t\t}\n\t\tif (last == NULL)\n\t\t    list = last = xmlXIncludeCopyNode(ctxt, target, source,\n\t\t\t                              set->nodeTab[i]);\n\t\telse {\n\t\t    xmlAddNextSibling(last,\n\t\t\t    xmlXIncludeCopyNode(ctxt, target, source,\n\t\t\t\t                set->nodeTab[i]));\n\t\t    if (last->next != NULL)\n\t\t\tlast = last->next;\n\t\t}\n\t    }\n\t    break;\n\t}\n#ifdef LIBXML_XPTR_ENABLED\n\tcase XPATH_LOCATIONSET: {\n\t    xmlLocationSetPtr set = (xmlLocationSetPtr) obj->user;\n\t    if (set == NULL)\n\t\treturn(NULL);\n\t    for (i = 0;i < set->locNr;i++) {\n\t\tif (last == NULL)\n\t\t    list = last = xmlXIncludeCopyXPointer(ctxt, target, source,\n\t\t\t                                  set->locTab[i]);\n\t\telse\n\t\t    xmlAddNextSibling(last,\n\t\t\t    xmlXIncludeCopyXPointer(ctxt, target, source,\n\t\t\t\t                    set->locTab[i]));\n\t\tif (last != NULL) {\n\t\t    while (last->next != NULL)\n\t\t\tlast = last->next;\n\t\t}\n\t    }\n\t    break;\n\t}\n\tcase XPATH_RANGE:\n\t    return(xmlXIncludeCopyRange(ctxt, target, source, obj));\n#endif\n\tcase XPATH_POINT:\n\t    /* points are ignored in XInclude */\n\t    break;\n\tdefault:\n\t    break;\n    }\n    return(list);\n}\nstatic xmlNodePtr\nxmlXPtrBuildRangeNodeList(xmlXPathObjectPtr range) {\n    /* pointers to generated nodes */\n    xmlNodePtr list = NULL, last = NULL, parent = NULL, tmp;\n    /* pointers to traversal nodes */\n    xmlNodePtr start, cur, end;\n    int index1, index2;\n\n    if (range == NULL)\n\treturn(NULL);\n    if (range->type != XPATH_RANGE)\n\treturn(NULL);\n    start = (xmlNodePtr) range->user;\n\n    if ((start == NULL) || (start->type == XML_NAMESPACE_DECL))\n\treturn(NULL);\n    end = range->user2;\n    if (end == NULL)\n\treturn(xmlCopyNode(start, 1));\n    if (end->type == XML_NAMESPACE_DECL)\n        return(NULL);\n\n    cur = start;\n    index1 = range->index;\n    index2 = range->index2;\n    while (cur != NULL) {\n\tif (cur == end) {\n\t    if (cur->type == XML_TEXT_NODE) {\n\t\tconst xmlChar *content = cur->content;\n\t\tint len;\n\n\t\tif (content == NULL) {\n\t\t    tmp = xmlNewTextLen(NULL, 0);\n\t\t} else {\n\t\t    len = index2;\n\t\t    if ((cur == start) && (index1 > 1)) {\n\t\t\tcontent += (index1 - 1);\n\t\t\tlen -= (index1 - 1);\n\t\t\tindex1 = 0;\n\t\t    } else {\n\t\t\tlen = index2;\n\t\t    }\n\t\t    tmp = xmlNewTextLen(content, len);\n\t\t}\n\t\t/* single sub text node selection */\n\t\tif (list == NULL)\n\t\t    return(tmp);\n\t\t/* prune and return full set */\n\t\tif (last != NULL)\n\t\t    xmlAddNextSibling(last, tmp);\n\t\telse\n\t\t    xmlAddChild(parent, tmp);\n\t\treturn(list);\n\t    } else {\n\t\ttmp = xmlCopyNode(cur, 0);\n\t\tif (list == NULL)\n\t\t    list = tmp;\n\t\telse {\n\t\t    if (last != NULL)\n\t\t\txmlAddNextSibling(last, tmp);\n\t\t    else\n\t\t\txmlAddChild(parent, tmp);\n\t\t}\n\t\tlast = NULL;\n\t\tparent = tmp;\n\n\t\tif (index2 > 1) {\n\t\t    end = xmlXPtrGetNthChild(cur, index2 - 1);\n\t\t    index2 = 0;\n\t\t}\n\t\tif ((cur == start) && (index1 > 1)) {\n\t\t    cur = xmlXPtrGetNthChild(cur, index1 - 1);\n\t\t    index1 = 0;\n\t\t} else {\n\t\t    cur = cur->children;\n\t\t}\n\t\t/*\n\t\t * Now gather the remaining nodes from cur to end\n\t\t */\n\t\tcontinue; /* while */\n\t    }\n\t} else if ((cur == start) &&\n\t\t   (list == NULL) /* looks superfluous but ... */ ) {\n\t    if ((cur->type == XML_TEXT_NODE) ||\n\t\t(cur->type == XML_CDATA_SECTION_NODE)) {\n\t\tconst xmlChar *content = cur->content;\n\n\t\tif (content == NULL) {\n\t\t    tmp = xmlNewTextLen(NULL, 0);\n\t\t} else {\n\t\t    if (index1 > 1) {\n\t\t\tcontent += (index1 - 1);\n\t\t    }\n\t\t    tmp = xmlNewText(content);\n\t\t}\n\t\tlast = list = tmp;\n\t    } else {\n\t\tif ((cur == start) && (index1 > 1)) {\n\t\t    tmp = xmlCopyNode(cur, 0);\n\t\t    list = tmp;\n\t\t    parent = tmp;\n\t\t    last = NULL;\n\t\t    cur = xmlXPtrGetNthChild(cur, index1 - 1);\n\t\t    index1 = 0;\n\t\t    /*\n\t\t     * Now gather the remaining nodes from cur to end\n\t\t     */\n\t\t    continue; /* while */\n\t\t}\n\t\ttmp = xmlCopyNode(cur, 1);\n\t\tlist = tmp;\n\t\tparent = NULL;\n\t\tlast = tmp;\n\t    }\n\t} else {\n\t    tmp = NULL;\n\t    switch (cur->type) {\n\t\tcase XML_DTD_NODE:\n\t\tcase XML_ELEMENT_DECL:\n\t\tcase XML_ATTRIBUTE_DECL:\n\t\tcase XML_ENTITY_NODE:\n\t\t    /* Do not copy DTD information */\n\t\t    break;\n\t\tcase XML_ENTITY_DECL:\n\t\t    TODO /* handle crossing entities -> stack needed */\n\t\t    break;\n\t\tcase XML_XINCLUDE_START:\n\t\tcase XML_XINCLUDE_END:\n\t\t    /* don't consider it part of the tree content */\n\t\t    break;\n\t\tcase XML_ATTRIBUTE_NODE:\n\t\t    /* Humm, should not happen ! */\n\t\t    STRANGE\n\t\t    break;\n\t\tdefault:\n\t\t    tmp = xmlCopyNode(cur, 1);\n\t\t    break;\n\t    }\n\t    if (tmp != NULL) {\n\t\tif ((list == NULL) || ((last == NULL) && (parent == NULL)))  {\n\t\t    STRANGE\n\t\t    return(NULL);\n\t\t}\n\t\tif (last != NULL)\n\t\t    xmlAddNextSibling(last, tmp);\n\t\telse {\n\t\t    xmlAddChild(parent, tmp);\n\t\t    last = tmp;\n\t\t}\n\t    }\n\t}\n\t/*\n\t * Skip to next node in document order\n\t */\n\tif ((list == NULL) || ((last == NULL) && (parent == NULL)))  {\n\t    STRANGE\n\t    return(NULL);\n\t}\n\tcur = xmlXPtrAdvanceNode(cur, NULL);\n    }\n    return(list);\n}\n",
    "target": 1,
    "idx": 1034461,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic void\nxmlTextReaderFreeNodeList(xmlTextReaderPtr reader, xmlNodePtr cur) {\n    xmlNodePtr next;\n    xmlNodePtr parent;\n    xmlDictPtr dict;\n    size_t depth = 0;\n\n    if ((reader != NULL) && (reader->ctxt != NULL))\n\tdict = reader->ctxt->dict;\n    else\n        dict = NULL;\n    if (cur == NULL) return;\n    if (cur->type == XML_NAMESPACE_DECL) {\n\txmlFreeNsList((xmlNsPtr) cur);\n\treturn;\n    }\n    if ((cur->type == XML_DOCUMENT_NODE) ||\n\t(cur->type == XML_HTML_DOCUMENT_NODE)) {\n\txmlFreeDoc((xmlDocPtr) cur);\n\treturn;\n    }\n    while (1) {\n        while ((cur->type != XML_DTD_NODE) &&\n               (cur->type != XML_ENTITY_REF_NODE) &&\n               (cur->children != NULL) &&\n               (cur->children->parent == cur)) {\n            cur = cur->children;\n            depth += 1;\n        }\n\n        next = cur->next;\n        parent = cur->parent;\n\n\t/* unroll to speed up freeing the document */\n\tif (cur->type != XML_DTD_NODE) {\n\n\t    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n\t\txmlDeregisterNodeDefaultValue(cur);\n\n\t    if (((cur->type == XML_ELEMENT_NODE) ||\n\t\t (cur->type == XML_XINCLUDE_START) ||\n\t\t (cur->type == XML_XINCLUDE_END)) &&\n\t\t(cur->properties != NULL))\n\t\txmlTextReaderFreePropList(reader, cur->properties);\n\t    if ((cur->content != (xmlChar *) &(cur->properties)) &&\n\t        (cur->type != XML_ELEMENT_NODE) &&\n\t\t(cur->type != XML_XINCLUDE_START) &&\n\t\t(cur->type != XML_XINCLUDE_END) &&\n\t\t(cur->type != XML_ENTITY_REF_NODE)) {\n\t\tDICT_FREE(cur->content);\n\t    }\n\t    if (((cur->type == XML_ELEMENT_NODE) ||\n\t         (cur->type == XML_XINCLUDE_START) ||\n\t\t (cur->type == XML_XINCLUDE_END)) &&\n\t\t(cur->nsDef != NULL))\n\t\txmlFreeNsList(cur->nsDef);\n\n\t    /*\n\t     * we don't free element names here they are interned now\n\t     */\n\t    if ((cur->type != XML_TEXT_NODE) &&\n\t\t(cur->type != XML_COMMENT_NODE))\n\t\tDICT_FREE(cur->name);\n\t    if (((cur->type == XML_ELEMENT_NODE) ||\n\t\t (cur->type == XML_TEXT_NODE)) &&\n\t        (reader != NULL) && (reader->ctxt != NULL) &&\n\t\t(reader->ctxt->freeElemsNr < 100)) {\n\t        cur->next = reader->ctxt->freeElems;\n\t\treader->ctxt->freeElems = cur;\n\t\treader->ctxt->freeElemsNr++;\n\t    } else {\n\t\txmlFree(cur);\n\t    }\n\t}\n\n        if (next != NULL) {\n\t    cur = next;\n        } else {\n            if ((depth == 0) || (parent == NULL))\n                break;\n            depth -= 1;\n            cur = parent;\n            cur->children = NULL;\n        }\n    }\n}\n\nstatic void\nxmlTextReaderFreeDoc(xmlTextReaderPtr reader, xmlDocPtr cur) {\n    xmlDtdPtr extSubset, intSubset;\n\n    if (cur == NULL) return;\n\n    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n\txmlDeregisterNodeDefaultValue((xmlNodePtr) cur);\n\n    /*\n     * Do this before freeing the children list to avoid ID lookups\n     */\n    if (cur->ids != NULL) xmlTextReaderFreeIDTable((xmlIDTablePtr) cur->ids);\n    cur->ids = NULL;\n    if (cur->refs != NULL) xmlFreeRefTable((xmlRefTablePtr) cur->refs);\n    cur->refs = NULL;\n    extSubset = cur->extSubset;\n    intSubset = cur->intSubset;\n    if (intSubset == extSubset)\n\textSubset = NULL;\n    if (extSubset != NULL) {\n\txmlUnlinkNode((xmlNodePtr) cur->extSubset);\n\tcur->extSubset = NULL;\n\txmlFreeDtd(extSubset);\n    }\n    if (intSubset != NULL) {\n\txmlUnlinkNode((xmlNodePtr) cur->intSubset);\n\tcur->intSubset = NULL;\n\txmlFreeDtd(intSubset);\n    }\n\n    if (cur->children != NULL) xmlTextReaderFreeNodeList(reader, cur->children);\n\n    if (cur->version != NULL) xmlFree((char *) cur->version);\n    if (cur->name != NULL) xmlFree((char *) cur->name);\n    if (cur->encoding != NULL) xmlFree((char *) cur->encoding);\n    if (cur->oldNs != NULL) xmlFreeNsList(cur->oldNs);\n    if (cur->URL != NULL) xmlFree((char *) cur->URL);\n    if (cur->dict != NULL) xmlDictFree(cur->dict);\n\n    xmlFree(cur);\n}\n\nvoid\nxmlFreeTextReader(xmlTextReaderPtr reader) {\n    if (reader == NULL)\n\treturn;\n#ifdef LIBXML_SCHEMAS_ENABLED\n    if (reader->rngSchemas != NULL) {\n\txmlRelaxNGFree(reader->rngSchemas);\n\treader->rngSchemas = NULL;\n    }\n    if (reader->rngValidCtxt != NULL) {\n\tif (! reader->rngPreserveCtxt)\n\t    xmlRelaxNGFreeValidCtxt(reader->rngValidCtxt);\n\treader->rngValidCtxt = NULL;\n    }\n    if (reader->xsdPlug != NULL) {\n\txmlSchemaSAXUnplug(reader->xsdPlug);\n\treader->xsdPlug = NULL;\n    }\n    if (reader->xsdValidCtxt != NULL) {\n\tif (! reader->xsdPreserveCtxt)\n\t    xmlSchemaFreeValidCtxt(reader->xsdValidCtxt);\n\treader->xsdValidCtxt = NULL;\n    }\n    if (reader->xsdSchemas != NULL) {\n\txmlSchemaFree(reader->xsdSchemas);\n\treader->xsdSchemas = NULL;\n    }\n#endif\n#ifdef LIBXML_XINCLUDE_ENABLED\n    if (reader->xincctxt != NULL)\n\txmlXIncludeFreeContext(reader->xincctxt);\n#endif\n#ifdef LIBXML_PATTERN_ENABLED\n    if (reader->patternTab != NULL) {\n        int i;\n\tfor (i = 0;i < reader->patternNr;i++) {\n\t    if (reader->patternTab[i] != NULL)\n\t        xmlFreePattern(reader->patternTab[i]);\n\t}\n\txmlFree(reader->patternTab);\n    }\n#endif\n    if (reader->faketext != NULL) {\n\txmlFreeNode(reader->faketext);\n    }\n    if (reader->ctxt != NULL) {\n        if (reader->dict == reader->ctxt->dict)\n\t    reader->dict = NULL;\n\tif ((reader->ctxt->vctxt.vstateTab != NULL) &&\n\t    (reader->ctxt->vctxt.vstateMax > 0)){\n            while (reader->ctxt->vctxt.vstateNr > 0)\n                xmlValidatePopElement(&reader->ctxt->vctxt, NULL, NULL, NULL);\n\t    xmlFree(reader->ctxt->vctxt.vstateTab);\n\t    reader->ctxt->vctxt.vstateTab = NULL;\n\t    reader->ctxt->vctxt.vstateMax = 0;\n\t}\n\tif (reader->ctxt->myDoc != NULL) {\n\t    if (reader->preserve == 0)\n\t\txmlTextReaderFreeDoc(reader, reader->ctxt->myDoc);\n\t    reader->ctxt->myDoc = NULL;\n\t}\n\tif (reader->allocs & XML_TEXTREADER_CTXT)\n\t    xmlFreeParserCtxt(reader->ctxt);\n    }\n    if (reader->sax != NULL)\n\txmlFree(reader->sax);\n    if ((reader->input != NULL)  && (reader->allocs & XML_TEXTREADER_INPUT))\n\txmlFreeParserInputBuffer(reader->input);\n    if (reader->buffer != NULL)\n        xmlBufFree(reader->buffer);\n    if (reader->entTab != NULL)\n\txmlFree(reader->entTab);\n    if (reader->dict != NULL)\n        xmlDictFree(reader->dict);\n    xmlFree(reader);\n}\n\n\n// target function\nstatic void\nxmlTextReaderFreeNodeList(xmlTextReaderPtr reader, xmlNodePtr cur) {\n    xmlNodePtr next;\n    xmlNodePtr parent;\n    xmlDictPtr dict;\n    size_t depth = 0;\n\n    if ((reader != NULL) && (reader->ctxt != NULL))\n\tdict = reader->ctxt->dict;\n    else\n        dict = NULL;\n    if (cur == NULL) return;\n    if (cur->type == XML_NAMESPACE_DECL) {\n\txmlFreeNsList((xmlNsPtr) cur);\n\treturn;\n    }\n    if ((cur->type == XML_DOCUMENT_NODE) ||\n\t(cur->type == XML_HTML_DOCUMENT_NODE)) {\n\txmlFreeDoc((xmlDocPtr) cur);\n\treturn;\n    }\n    while (1) {\n        while ((cur->children != NULL) &&\n               (cur->children->parent == cur) &&\n               (cur->type != XML_DTD_NODE) &&\n               (cur->type != XML_ENTITY_REF_NODE)) {\n            cur = cur->children;\n            depth += 1;\n        }\n\n        next = cur->next;\n        parent = cur->parent;\n\n\t/* unroll to speed up freeing the document */\n\tif (cur->type != XML_DTD_NODE) {\n\n\t    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n\t\txmlDeregisterNodeDefaultValue(cur);\n\n\t    if (((cur->type == XML_ELEMENT_NODE) ||\n\t\t (cur->type == XML_XINCLUDE_START) ||\n\t\t (cur->type == XML_XINCLUDE_END)) &&\n\t\t(cur->properties != NULL))\n\t\txmlTextReaderFreePropList(reader, cur->properties);\n\t    if ((cur->content != (xmlChar *) &(cur->properties)) &&\n\t        (cur->type != XML_ELEMENT_NODE) &&\n\t\t(cur->type != XML_XINCLUDE_START) &&\n\t\t(cur->type != XML_XINCLUDE_END) &&\n\t\t(cur->type != XML_ENTITY_REF_NODE)) {\n\t\tDICT_FREE(cur->content);\n\t    }\n\t    if (((cur->type == XML_ELEMENT_NODE) ||\n\t         (cur->type == XML_XINCLUDE_START) ||\n\t\t (cur->type == XML_XINCLUDE_END)) &&\n\t\t(cur->nsDef != NULL))\n\t\txmlFreeNsList(cur->nsDef);\n\n\t    /*\n\t     * we don't free element names here they are interned now\n\t     */\n\t    if ((cur->type != XML_TEXT_NODE) &&\n\t\t(cur->type != XML_COMMENT_NODE))\n\t\tDICT_FREE(cur->name);\n\t    if (((cur->type == XML_ELEMENT_NODE) ||\n\t\t (cur->type == XML_TEXT_NODE)) &&\n\t        (reader != NULL) && (reader->ctxt != NULL) &&\n\t\t(reader->ctxt->freeElemsNr < 100)) {\n\t        cur->next = reader->ctxt->freeElems;\n\t\treader->ctxt->freeElems = cur;\n\t\treader->ctxt->freeElemsNr++;\n\t    } else {\n\t\txmlFree(cur);\n\t    }\n\t}\n\n        if (next != NULL) {\n\t    cur = next;\n        } else {\n            if ((depth == 0) || (parent == NULL))\n                break;\n            depth -= 1;\n            cur = parent;\n            cur->children = NULL;\n        }\n    }\n}\n",
    "target": 1,
    "idx": 1017737,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "// context\nint MqttDecode_Vbi(byte *buf, word32 *value, word32 buf_len)\n{\n    word32 rc = 0;\n    int multiplier = 1;\n    byte encodedByte;\n\n    *value = 0;\n    do {\n        if (buf_len < rc + 1)\n            return MQTT_CODE_ERROR_OUT_OF_BUFFER;\n       encodedByte = *(buf++);\n       *value += (encodedByte & ~MQTT_PACKET_LEN_ENCODE_MASK) * multiplier;\n       multiplier *= MQTT_PACKET_LEN_ENCODE_MASK;\n       if (multiplier > (MQTT_PACKET_LEN_ENCODE_MASK *\n                         MQTT_PACKET_LEN_ENCODE_MASK *\n                         MQTT_PACKET_LEN_ENCODE_MASK))\n       {\n          return MQTT_CODE_ERROR_MALFORMED_DATA;\n       }\n       rc++;\n    } while ((encodedByte & MQTT_PACKET_LEN_ENCODE_MASK) != 0);\n\n    return (int)rc;\n}\n\nint MqttDecode_Props(MqttPacketType packet, MqttProp** props, byte* pbuf,\n        word32 buf_len, word32 prop_len)\n{\n    /* TODO: Validate property type is allowed for packet type */\n\n    int rc = 0;\n    int tmp;\n    MqttProp* cur_prop;\n    byte* buf = pbuf;\n\n    *props = NULL;\n\n    while (prop_len > 0)\n    {\n        /* Allocate a structure and add to head. */\n        cur_prop = MqttProps_Add(props);\n        if (cur_prop == NULL)\n            return MQTT_CODE_ERROR_MEMORY;\n\n        /* Decode the Identifier */\n        tmp = MqttDecode_Vbi(buf, (word32*)&cur_prop->type,\n                (word32)(buf_len - (buf - pbuf)));\n        if (tmp < 0) {\n            return tmp;\n        }\n        buf += tmp;\n        rc += (int)tmp;\n        prop_len -= tmp;\n\n        /* TODO: validate packet type */\n        (void)packet;\n\n        if (cur_prop->type >= sizeof(gPropMatrix) / sizeof(gPropMatrix[0])) {\n            return MQTT_CODE_ERROR_PROPERTY;\n        }\n\n        switch (gPropMatrix[cur_prop->type].data)\n        {\n            case MQTT_DATA_TYPE_BYTE:\n            {\n                cur_prop->data_byte = *buf++;\n                tmp++;\n                rc++;\n                prop_len--;\n                break;\n            }\n            case MQTT_DATA_TYPE_SHORT:\n            {\n                tmp = MqttDecode_Num(buf, &cur_prop->data_short);\n                buf += tmp;\n                rc += (int)tmp;\n                prop_len -= tmp;\n                break;\n            }\n            case MQTT_DATA_TYPE_INT:\n            {\n                tmp = MqttDecode_Int(buf, &cur_prop->data_int);\n                buf += tmp;\n                rc += (int)tmp;\n                prop_len -= tmp;\n                break;\n            }\n            case MQTT_DATA_TYPE_STRING:\n            {\n                tmp = MqttDecode_String(buf,\n                        (const char**)&cur_prop->data_str.str,\n                        &cur_prop->data_str.len);\n                buf += tmp;\n                rc += (int)tmp;\n                prop_len -= tmp;\n                break;\n            }\n            case MQTT_DATA_TYPE_VAR_INT:\n            {\n                tmp = MqttDecode_Vbi(buf, &cur_prop->data_int,\n                        (word32)(buf_len -(buf - pbuf)));\n                if (tmp < 0) {\n                    return tmp;\n                }\n                buf += tmp;\n                rc += (int)tmp;\n                prop_len -= tmp;\n                break;\n            }\n            case MQTT_DATA_TYPE_BINARY:\n            {\n                /* Binary type is a two byte integer \"length\"\n                   followed by that number of bytes */\n                tmp = MqttDecode_Num(buf, &cur_prop->data_bin.len);\n                buf += tmp;\n                rc += (int)tmp;\n                prop_len -= tmp;\n\n                cur_prop->data_bin.data = buf;\n                buf += cur_prop->data_bin.len;\n                rc += (int)cur_prop->data_bin.len;\n                prop_len -= cur_prop->data_bin.len;\n                break;\n            }\n            case MQTT_DATA_TYPE_STRING_PAIR:\n            {\n                /* String is prefixed with a Two Byte Integer length\n                   field that gives the number of bytes */\n                tmp = MqttDecode_String(buf,\n                        (const char**)&cur_prop->data_str.str,\n                        &cur_prop->data_str.len);\n                buf += tmp;\n                rc += (int)tmp;\n                prop_len -= tmp;\n\n                tmp = MqttDecode_String(buf,\n                        (const char**)&cur_prop->data_str2.str,\n                        &cur_prop->data_str2.len);\n                buf += tmp;\n                rc += (int)tmp;\n                prop_len -= tmp;\n                break;\n            }\n            case MQTT_DATA_TYPE_NONE:\n            default:\n            {\n                /* Do nothing */\n                break;\n            }\n        }\n    };\n\n    return rc;\n}\n\nint MqttDecode_Disconnect(byte *rx_buf, int rx_buf_len, MqttDisconnect *disc)\n{\n    int header_len, remain_len, tmp;\n    byte *rx_payload;\n    word32 props_len = 0;\n\n    /* Validate required arguments */\n    if ((rx_buf == NULL) || (rx_buf_len <= 0) || (disc == NULL)) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    /* Decode fixed header */\n    header_len = MqttDecode_FixedHeader(rx_buf, rx_buf_len, &remain_len,\n        MQTT_PACKET_TYPE_DISCONNECT, NULL, NULL, NULL);\n    if (header_len < 0) {\n        return header_len;\n    }\n    rx_payload = &rx_buf[header_len];\n\n    if (remain_len > 0) {\n        /* Decode variable header */\n        disc->reason_code = *rx_payload++;\n\n        if (remain_len > 1) {\n            /* Decode Length of Properties */\n            tmp = MqttDecode_Vbi(rx_payload, &props_len,\n                    (word32)(rx_buf_len - (rx_payload - rx_buf)));\n            if (tmp < 0)\n                return tmp;\n\n            if (props_len <= (word32)(rx_buf_len - (rx_payload - rx_buf))) {\n                rx_payload += tmp;\n                if (props_len > 0) {\n                    /* Decode the Properties */\n                    tmp = MqttDecode_Props(MQTT_PACKET_TYPE_DISCONNECT,\n                            &disc->props, rx_payload,\n                            (word32)(rx_buf_len - (rx_payload - rx_buf)),\n                            props_len);\n                    if (tmp < 0)\n                        return tmp;\n                    rx_payload += tmp;\n                }\n            }\n            else\n                return MQTT_CODE_ERROR_OUT_OF_BUFFER;\n        }\n    }\n\n    (void)rx_payload;\n\n    /* Return total length of packet */\n    return header_len + remain_len;\n}\n\nstatic int MqttClient_DecodePacket(MqttClient* client, byte* rx_buf,\n    word32 rx_len, void *packet_obj, MqttPacketType* ppacket_type,\n    MqttQoS* ppacket_qos, word16* ppacket_id)\n{\n    int rc = MQTT_CODE_SUCCESS;\n    MqttPacket* header;\n    MqttPacketType packet_type;\n    MqttQoS packet_qos;\n    word16 packet_id = 0;\n\n    /* must have rx buffer with at least 2 byes for header */\n    if (rx_buf == NULL || rx_len < MQTT_PACKET_HEADER_MIN_SIZE) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    /* Decode header */\n    header = (MqttPacket*)rx_buf;\n    packet_type = (MqttPacketType)MQTT_PACKET_TYPE_GET(header->type_flags);\n    if (ppacket_type) {\n        *ppacket_type = packet_type;\n    }\n    packet_qos = (MqttQoS)MQTT_PACKET_FLAGS_GET_QOS(header->type_flags);\n    if (ppacket_qos) {\n        *ppacket_qos = packet_qos;\n    }\n\n    /* Decode packet specific data (if requested) */\n    if (ppacket_id || packet_obj) {\n        switch (packet_type) {\n        case MQTT_PACKET_TYPE_CONNECT_ACK:\n        {\n            MqttConnectAck connect_ack, *p_connect_ack = &connect_ack;\n            if (packet_obj) {\n                p_connect_ack = (MqttConnectAck*)packet_obj;\n            }\n            else {\n                XMEMSET(p_connect_ack, 0, sizeof(MqttConnectAck));\n            }\n        #ifdef WOLFMQTT_V5\n            p_connect_ack->protocol_level = client->protocol_level;\n        #endif\n            rc = MqttDecode_ConnectAck(rx_buf, rx_len, p_connect_ack);\n        #ifdef WOLFMQTT_V5\n            if (rc >= 0) {\n                rc = Handle_Props(p_connect_ack->props);\n            }\n        #endif\n            break;\n        }\n        case MQTT_PACKET_TYPE_PUBLISH:\n        {\n            MqttPublish publish, *p_publish = &publish;\n            if (packet_obj) {\n                p_publish = (MqttPublish*)packet_obj;\n            }\n            else {\n                XMEMSET(p_publish, 0, sizeof(MqttPublish));\n            }\n        #ifdef WOLFMQTT_V5\n            p_publish->protocol_level = client->protocol_level;\n        #endif\n            rc = MqttDecode_Publish(rx_buf, rx_len, p_publish);\n            if (rc >= 0) {\n                packet_id = p_publish->packet_id;\n            #ifdef WOLFMQTT_V5\n                rc = Handle_Props(p_publish->props);\n            #endif\n            }\n            break;\n        }\n        case MQTT_PACKET_TYPE_PUBLISH_ACK:\n        case MQTT_PACKET_TYPE_PUBLISH_REC:\n        case MQTT_PACKET_TYPE_PUBLISH_REL:\n        case MQTT_PACKET_TYPE_PUBLISH_COMP:\n        {\n            MqttPublishResp publish_resp, *p_publish_resp = &publish_resp;\n            if (packet_obj) {\n                p_publish_resp = (MqttPublishResp*)packet_obj;\n            }\n            else {\n                XMEMSET(p_publish_resp, 0, sizeof(MqttPublishResp));\n            }\n        #ifdef WOLFMQTT_V5\n                p_publish_resp->protocol_level = client->protocol_level;\n        #endif\n                rc = MqttDecode_PublishResp(rx_buf, rx_len, packet_type,\n                p_publish_resp);\n            if (rc >= 0) {\n                packet_id = p_publish_resp->packet_id;\n            #ifdef WOLFMQTT_V5\n                rc = Handle_Props(p_publish_resp->props);\n            #endif\n            }\n            break;\n        }\n        case MQTT_PACKET_TYPE_SUBSCRIBE_ACK:\n        {\n            MqttSubscribeAck subscribe_ack, *p_subscribe_ack = &subscribe_ack;\n            if (packet_obj) {\n                p_subscribe_ack = (MqttSubscribeAck*)packet_obj;\n            }\n            else {\n                XMEMSET(p_subscribe_ack, 0, sizeof(MqttSubscribeAck));\n            }\n        #ifdef WOLFMQTT_V5\n            p_subscribe_ack->protocol_level = client->protocol_level;\n        #endif\n            rc = MqttDecode_SubscribeAck(rx_buf, rx_len, p_subscribe_ack);\n            if (rc >= 0) {\n                packet_id = p_subscribe_ack->packet_id;\n            #ifdef WOLFMQTT_V5\n                rc = Handle_Props(p_subscribe_ack->props);\n            #endif\n            }\n            break;\n        }\n        case MQTT_PACKET_TYPE_UNSUBSCRIBE_ACK:\n        {\n            MqttUnsubscribeAck unsubscribe_ack,\n                               *p_unsubscribe_ack = &unsubscribe_ack;\n            if (packet_obj) {\n                p_unsubscribe_ack = (MqttUnsubscribeAck*)packet_obj;\n            }\n            else {\n                XMEMSET(p_unsubscribe_ack, 0, sizeof(MqttUnsubscribeAck));\n            }\n        #ifdef WOLFMQTT_V5\n            p_unsubscribe_ack->protocol_level = client->protocol_level;\n        #endif\n            rc = MqttDecode_UnsubscribeAck(rx_buf, rx_len, p_unsubscribe_ack);\n            if (rc >= 0) {\n                packet_id = p_unsubscribe_ack->packet_id;\n            #ifdef WOLFMQTT_V5\n                rc = Handle_Props(p_unsubscribe_ack->props);\n            #endif\n            }\n            break;\n        }\n        case MQTT_PACKET_TYPE_PING_RESP:\n        {\n            MqttPing ping, *p_ping = &ping;\n            if (packet_obj) {\n                p_ping = (MqttPing*)packet_obj;\n            }\n            else {\n                XMEMSET(p_ping, 0, sizeof(MqttPing));\n            }\n            rc = MqttDecode_Ping(rx_buf, rx_len, p_ping);\n            break;\n        }\n        case MQTT_PACKET_TYPE_AUTH:\n        {\n        #ifdef WOLFMQTT_V5\n            MqttAuth auth, *p_auth = &auth;\n            if (packet_obj) {\n                p_auth = (MqttAuth*)packet_obj;\n            }\n            else {\n                XMEMSET(p_auth, 0, sizeof(MqttAuth));\n            }\n            rc = MqttDecode_Auth(rx_buf, rx_len, p_auth);\n            if (rc >= 0) {\n                rc = Handle_Props(p_auth->props);\n            }\n        #else\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n        #endif /* WOLFMQTT_V5 */\n            break;\n        }\n        case MQTT_PACKET_TYPE_DISCONNECT:\n        {\n        #ifdef WOLFMQTT_V5\n            MqttDisconnect disc, *p_disc = &disc;\n            if (packet_obj) {\n                p_disc = (MqttDisconnect*)packet_obj;\n            }\n            else {\n                XMEMSET(p_disc, 0, sizeof(MqttDisconnect));\n            }\n            rc = MqttDecode_Disconnect(rx_buf, rx_len, p_disc);\n            if (rc >= 0) {\n                rc = Handle_Props(p_disc->props);\n            }\n        #else\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n        #endif /* WOLFMQTT_V5 */\n            break;\n        }\n        case MQTT_PACKET_TYPE_CONNECT:\n        case MQTT_PACKET_TYPE_SUBSCRIBE:\n        case MQTT_PACKET_TYPE_UNSUBSCRIBE:\n        case MQTT_PACKET_TYPE_PING_REQ:\n        case MQTT_PACKET_TYPE_ANY:\n        case MQTT_PACKET_TYPE_RESERVED:\n        default:\n            /* these type are only encoded by client */\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n            break;\n        } /* switch (packet_type) */\n    }\n\n    if (ppacket_id) {\n        *ppacket_id = packet_id;\n    }\n\n    (void)client;\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"MqttClient_DecodePacket: Rc %d, Len %d, Type %s (%d), ID %d,\"\n            \" QoS %d\",\n        rc, rx_len, MqttPacket_TypeDesc(packet_type), packet_type, packet_id,\n        packet_qos);\n#endif\n\n    return rc;\n}\n\nstatic int MqttClient_WaitType(MqttClient *client, void *packet_obj,\n    byte wait_type, word16 wait_packet_id, int timeout_ms)\n{\n    int rc;\n    word16 packet_id;\n    MqttPacketType packet_type;\n#ifdef WOLFMQTT_MULTITHREAD\n    MqttPendResp *pendResp;\n    int readLocked;\n#endif\n    MqttMsgStat* mms_stat;\n    int waitMatchFound;\n\n    if (client == NULL || packet_obj == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    /* all packet type structures must have MqttMsgStat at top */\n    mms_stat = (MqttMsgStat*)packet_obj;\n\nwait_again:\n\n    /* initialize variables */\n    packet_id = 0;\n    packet_type = MQTT_PACKET_TYPE_RESERVED;\n#ifdef WOLFMQTT_MULTITHREAD\n    pendResp = NULL;\n    readLocked = 0;\n#endif\n    waitMatchFound = 0;\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"MqttClient_WaitType: Type %s (%d), ID %d\",\n        MqttPacket_TypeDesc((MqttPacketType)wait_type),\n            wait_type, wait_packet_id);\n#endif\n\n    switch ((int)*mms_stat)\n    {\n        case MQTT_MSG_BEGIN:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Lock recv socket mutex */\n            rc = wm_SemLock(&client->lockRecv);\n            if (rc != 0) {\n                PRINTF(\"MqttClient_WaitType: recv lock error!\");\n                return rc;\n            }\n            readLocked = 1;\n        #endif\n\n            /* reset the packet state */\n            client->packet.stat = MQTT_PK_BEGIN;\n        }\n        FALL_THROUGH;\n\n    #ifdef WOLFMQTT_V5\n        case MQTT_MSG_AUTH:\n    #endif\n        case MQTT_MSG_WAIT:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if packet type and id have already completed */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, (MqttPacketType)wait_type, \n                    wait_packet_id, &pendResp)) {\n                    if (pendResp->packetDone) {\n                        /* pending response is already done, so return */\n                        rc = pendResp->packet_ret;\n                    #ifdef WOLFMQTT_DEBUG_CLIENT\n                        PRINTF(\"PendResp already Done %p: Rc %d\", pendResp, rc);\n                    #endif\n                        MqttClient_RespList_Remove(client, pendResp);\n                        wm_SemUnlock(&client->lockClient);\n                        wm_SemUnlock(&client->lockRecv);\n                        return rc;\n                    }\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            *mms_stat = MQTT_MSG_WAIT;\n\n            /* Wait for packet */\n            rc = MqttPacket_Read(client, client->rx_buf, client->rx_buf_len,\n                    timeout_ms);\n            /* handle failure */\n            if (rc <= 0) {\n                break;\n            }\n\n            /* capture length read */\n            client->packet.buf_len = rc;\n\n            /* Decode Packet - get type and id */\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, NULL, &packet_type, NULL, &packet_id);\n            if (rc < 0) {\n                break;\n            }\n\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"Read Packet: Len %d, Type %d, ID %d\",\n                client->packet.buf_len, packet_type, packet_id);\n        #endif\n\n            *mms_stat = MQTT_MSG_READ;\n        }\n        FALL_THROUGH;\n\n        case MQTT_MSG_READ:\n        case MQTT_MSG_READ_PAYLOAD:\n        {\n            MqttPacketType use_packet_type;\n            void* use_packet_obj;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            readLocked = 1; /* if in this state read is locked */\n        #endif\n\n            /* read payload state only happens for publish messages */\n            if (*mms_stat == MQTT_MSG_READ_PAYLOAD) {\n                packet_type = MQTT_PACKET_TYPE_PUBLISH;\n            }\n\n            /* Determine if we received data for this request */\n            if ((wait_type == MQTT_PACKET_TYPE_ANY ||\n                 wait_type == packet_type ||\n                 (MqttIsPubRespPacket(packet_type) &&\n                  MqttIsPubRespPacket(wait_type))) &&\n                (wait_packet_id == 0 || wait_packet_id == packet_id))\n            {\n                use_packet_obj = packet_obj;\n                waitMatchFound = 1;\n            }\n            else {\n                /* use generic packet object */\n                use_packet_obj = &client->msg;\n            }\n            use_packet_type = packet_type;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if we have a pending response for this packet */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, packet_type, packet_id,\n                                                               &pendResp)) {\n                    /* we found packet match this incoming read packet */\n                    pendResp->packetProcessing = 1;\n                    use_packet_obj = pendResp->packet_obj;\n                    use_packet_type = pendResp->packet_type;\n                    /* req from another thread... not a match */\n                    waitMatchFound = 0;\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            /* Perform packet handling for publish callback and QoS */\n            rc = MqttClient_HandlePacket(client, use_packet_type,\n                use_packet_obj, timeout_ms);\n\n        #ifdef WOLFMQTT_NONBLOCK\n            if (rc == MQTT_CODE_CONTINUE) {\n                /* we have received some data, so keep the recv\n                    mutex lock active and return */\n                return rc;\n            }\n        #endif\n\n            /* handle success case */\n            if (rc >= 0) {\n                rc = MQTT_CODE_SUCCESS;\n            }\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (pendResp) {\n                /* Mark pending response entry done */\n                if (wm_SemLock(&client->lockClient) == 0) {\n                    pendResp->packetDone = 1;\n                    pendResp->packet_ret = rc;\n                #ifdef WOLFMQTT_DEBUG_CLIENT\n                    PRINTF(\"PendResp Done %p\", pendResp);\n                #endif\n                    pendResp = NULL;\n                    wm_SemUnlock(&client->lockClient);\n                }\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n            break;\n        }\n\n        case MQTT_MSG_WRITE:\n        case MQTT_MSG_WRITE_PAYLOAD:\n        default:\n        {\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"MqttClient_WaitType: Invalid state %d!\", *mms_stat);\n        #endif\n            rc = MQTT_CODE_ERROR_STAT;\n            break;\n        }\n    } /* switch (*mms_stat) */\n\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc != MQTT_CODE_CONTINUE)\n#endif\n    {\n        /* reset state */\n        *mms_stat = MQTT_MSG_BEGIN;\n    }\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (readLocked) {\n        wm_SemUnlock(&client->lockRecv);\n    }\n#endif\n    if (rc < 0) {\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_WaitType: Failure: %s (%d)\",\n            MqttClient_ReturnCodeToString(rc), rc);\n    #endif\n        return rc;\n    }\n\n    if (!waitMatchFound) {\n        /* if we get here, then the we are still waiting for a packet */\n        goto wait_again;\n    }\n\n    return rc;\n}\n\nint MqttClient_WaitMessage_ex(MqttClient *client, MqttObject* msg,\n        int timeout_ms)\n{\n    return MqttClient_WaitType(client, msg, MQTT_PACKET_TYPE_ANY, 0,\n        timeout_ms);\n}\n\nint MqttClient_WaitMessage(MqttClient *client, int timeout_ms)\n{\n    int rc = MQTT_CODE_ERROR_BAD_ARG;\n    if (client != NULL) {\n        rc = MqttClient_WaitMessage_ex(client, &client->msg, timeout_ms);\n        if (rc != MQTT_CODE_CONTINUE) {\n            /* Clear the union for the next call to MqttClient_WaitMessage */\n            XMEMSET(&client->msg, 0, sizeof(MqttObject));\n        }\n    }\n\n    return rc;\n}\n\nbool wolfMQTTFuzzer::wait(void) {\n    bool ret = false;\n\n    CHECK_EQ(MqttClient_WaitMessage(&client, 1000), MQTT_CODE_SUCCESS);\n\n    ret = true;\n\nend:\n    return ret;\n}\n\nvoid wolfMQTTFuzzer::Run(void) {\n    try {\n        const auto numActions = ds.Get<uint8_t>() % 20;\n\n        for (size_t i = 0; i < numActions; i++) {\n            switch ( ds.Get<uint8_t>() ) {\n                case    0:\n                    subscribe();\n                    break;\n                case    1:\n                    unsubscribe();\n                    break;\n                case    2:\n                    publish();\n                    break;\n                case    3:\n                    ping();\n                    break;\n                case    4:\n                    wait();\n                    break;\n            }\n        }\n\n        MqttClient_NetDisconnect(&client);\n    } catch ( ... ) { }\n}\n\n\n// target function\nstatic int MqttClient_DecodePacket(MqttClient* client, byte* rx_buf,\n    word32 rx_len, void *packet_obj, MqttPacketType* ppacket_type,\n    MqttQoS* ppacket_qos, word16* ppacket_id)\n{\n    int rc = MQTT_CODE_SUCCESS;\n    MqttPacket* header;\n    MqttPacketType packet_type;\n    MqttQoS packet_qos;\n    word16 packet_id = 0;\n#ifdef WOLFMQTT_V5\n    MqttProp* props = NULL;\n#endif\n\n    /* must have rx buffer with at least 2 byes for header */\n    if (rx_buf == NULL || rx_len < MQTT_PACKET_HEADER_MIN_SIZE) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    /* Decode header */\n    header = (MqttPacket*)rx_buf;\n    packet_type = (MqttPacketType)MQTT_PACKET_TYPE_GET(header->type_flags);\n    if (ppacket_type) {\n        *ppacket_type = packet_type;\n    }\n    packet_qos = (MqttQoS)MQTT_PACKET_FLAGS_GET_QOS(header->type_flags);\n    if (ppacket_qos) {\n        *ppacket_qos = packet_qos;\n    }\n\n    /* Decode packet specific data (if requested) */\n    if (ppacket_id || packet_obj) {\n        switch (packet_type) {\n        case MQTT_PACKET_TYPE_CONNECT_ACK:\n        {\n            MqttConnectAck connect_ack, *p_connect_ack = &connect_ack;\n            if (packet_obj) {\n                p_connect_ack = (MqttConnectAck*)packet_obj;\n            }\n            else {\n                XMEMSET(p_connect_ack, 0, sizeof(MqttConnectAck));\n            }\n        #ifdef WOLFMQTT_V5\n            p_connect_ack->protocol_level = client->protocol_level;\n        #endif\n            rc = MqttDecode_ConnectAck(rx_buf, rx_len, p_connect_ack);\n        #ifdef WOLFMQTT_V5\n            if (rc >= 0) {\n                props = p_connect_ack->props;\n            }\n        #endif\n            break;\n        }\n        case MQTT_PACKET_TYPE_PUBLISH:\n        {\n            MqttPublish publish, *p_publish = &publish;\n            if (packet_obj) {\n                p_publish = (MqttPublish*)packet_obj;\n            }\n            else {\n                XMEMSET(p_publish, 0, sizeof(MqttPublish));\n            }\n        #ifdef WOLFMQTT_V5\n            p_publish->protocol_level = client->protocol_level;\n        #endif\n            rc = MqttDecode_Publish(rx_buf, rx_len, p_publish);\n            if (rc >= 0) {\n                packet_id = p_publish->packet_id;\n            #ifdef WOLFMQTT_V5\n                props = p_publish->props;\n            #endif\n            }\n            break;\n        }\n        case MQTT_PACKET_TYPE_PUBLISH_ACK:\n        case MQTT_PACKET_TYPE_PUBLISH_REC:\n        case MQTT_PACKET_TYPE_PUBLISH_REL:\n        case MQTT_PACKET_TYPE_PUBLISH_COMP:\n        {\n            MqttPublishResp publish_resp, *p_publish_resp = &publish_resp;\n            if (packet_obj) {\n                p_publish_resp = (MqttPublishResp*)packet_obj;\n            }\n            else {\n                XMEMSET(p_publish_resp, 0, sizeof(MqttPublishResp));\n            }\n        #ifdef WOLFMQTT_V5\n                p_publish_resp->protocol_level = client->protocol_level;\n        #endif\n                rc = MqttDecode_PublishResp(rx_buf, rx_len, packet_type,\n                p_publish_resp);\n            if (rc >= 0) {\n                packet_id = p_publish_resp->packet_id;\n            #ifdef WOLFMQTT_V5\n                props = p_publish_resp->props;\n            #endif\n            }\n            break;\n        }\n        case MQTT_PACKET_TYPE_SUBSCRIBE_ACK:\n        {\n            MqttSubscribeAck subscribe_ack, *p_subscribe_ack = &subscribe_ack;\n            if (packet_obj) {\n                p_subscribe_ack = (MqttSubscribeAck*)packet_obj;\n            }\n            else {\n                XMEMSET(p_subscribe_ack, 0, sizeof(MqttSubscribeAck));\n            }\n        #ifdef WOLFMQTT_V5\n            p_subscribe_ack->protocol_level = client->protocol_level;\n        #endif\n            rc = MqttDecode_SubscribeAck(rx_buf, rx_len, p_subscribe_ack);\n            if (rc >= 0) {\n                packet_id = p_subscribe_ack->packet_id;\n            #ifdef WOLFMQTT_V5\n                props = p_subscribe_ack->props;\n            #endif\n            }\n            break;\n        }\n        case MQTT_PACKET_TYPE_UNSUBSCRIBE_ACK:\n        {\n            MqttUnsubscribeAck unsubscribe_ack,\n                               *p_unsubscribe_ack = &unsubscribe_ack;\n            if (packet_obj) {\n                p_unsubscribe_ack = (MqttUnsubscribeAck*)packet_obj;\n            }\n            else {\n                XMEMSET(p_unsubscribe_ack, 0, sizeof(MqttUnsubscribeAck));\n            }\n        #ifdef WOLFMQTT_V5\n            p_unsubscribe_ack->protocol_level = client->protocol_level;\n        #endif\n            rc = MqttDecode_UnsubscribeAck(rx_buf, rx_len, p_unsubscribe_ack);\n            if (rc >= 0) {\n                packet_id = p_unsubscribe_ack->packet_id;\n            #ifdef WOLFMQTT_V5\n                props = p_unsubscribe_ack->props;\n            #endif\n            }\n            break;\n        }\n        case MQTT_PACKET_TYPE_PING_RESP:\n        {\n            MqttPing ping, *p_ping = &ping;\n            if (packet_obj) {\n                p_ping = (MqttPing*)packet_obj;\n            }\n            else {\n                XMEMSET(p_ping, 0, sizeof(MqttPing));\n            }\n            rc = MqttDecode_Ping(rx_buf, rx_len, p_ping);\n            break;\n        }\n        case MQTT_PACKET_TYPE_AUTH:\n        {\n        #ifdef WOLFMQTT_V5\n            MqttAuth auth, *p_auth = &auth;\n            if (packet_obj) {\n                p_auth = (MqttAuth*)packet_obj;\n            }\n            else {\n                XMEMSET(p_auth, 0, sizeof(MqttAuth));\n            }\n            rc = MqttDecode_Auth(rx_buf, rx_len, p_auth);\n            if (rc >= 0) {\n                props = p_auth->props;\n            }\n        #else\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n        #endif /* WOLFMQTT_V5 */\n            break;\n        }\n        case MQTT_PACKET_TYPE_DISCONNECT:\n        {\n        #ifdef WOLFMQTT_V5\n            MqttDisconnect disc, *p_disc = &disc;\n            if (packet_obj) {\n                p_disc = (MqttDisconnect*)packet_obj;\n            }\n            else {\n                XMEMSET(p_disc, 0, sizeof(MqttDisconnect));\n            }\n            rc = MqttDecode_Disconnect(rx_buf, rx_len, p_disc);\n            if (rc >= 0) {\n                props = p_disc->props;\n            }\n        #else\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n        #endif /* WOLFMQTT_V5 */\n            break;\n        }\n        case MQTT_PACKET_TYPE_CONNECT:\n        case MQTT_PACKET_TYPE_SUBSCRIBE:\n        case MQTT_PACKET_TYPE_UNSUBSCRIBE:\n        case MQTT_PACKET_TYPE_PING_REQ:\n        case MQTT_PACKET_TYPE_ANY:\n        case MQTT_PACKET_TYPE_RESERVED:\n        default:\n            /* these type are only encoded by client */\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n            break;\n        } /* switch (packet_type) */\n    }\n\n    if (ppacket_id) {\n        *ppacket_id = packet_id;\n    }\n\n#ifdef WOLFMQTT_V5\n    if (props) {\n    #ifdef WOLFMQTT_PROPERTY_CB\n        /* Check for properties set by the server */\n        if (packet_obj && client->property_cb) {\n            /* capture error if returned */\n            int rc_err = client->property_cb(client, props,\n                    client->property_ctx);\n            if (rc_err < 0) {\n                rc = rc_err;\n            }\n        }\n    #endif\n        /* Free the properties */\n        MqttProps_Free(props);\n    }\n#endif\n\n    (void)client;\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"MqttClient_DecodePacket: Rc %d, Len %d, Type %s (%d), ID %d,\"\n            \" QoS %d\",\n        rc, rx_len, MqttPacket_TypeDesc(packet_type), packet_type, packet_id,\n        packet_qos);\n#endif\n\n    return rc;\n}\nint MqttClient_WaitMessage(MqttClient *client, int timeout_ms)\n{\n    if (client == NULL)\n        return MQTT_CODE_ERROR_BAD_ARG;\n    return MqttClient_WaitMessage_ex(client, &client->msg, timeout_ms);\n}\nint MqttClient_NetConnect(MqttClient *client, const char* host,\n    word16 port, int timeout_ms, int use_tls, MqttTlsCb cb)\n{\n    return MqttSocket_Connect(client, host, port, timeout_ms, use_tls, cb);\n}\nint MqttClient_NetDisconnect(MqttClient *client)\n{\n    return MqttSocket_Disconnect(client);\n}\n",
    "target": 1,
    "idx": 1030592,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "// context\nstatic zend_always_inline void _zend_hash_del_el(HashTable *ht, uint32_t idx, Bucket *p)\n{\n\tBucket *prev = NULL;\n\tuint32_t nIndex;\n\tuint32_t i;\n\n\tnIndex = p->h | ht->nTableMask;\n\ti = HT_HASH(ht, nIndex);\n\n\tif (i != idx) {\n\t\tprev = HT_HASH_TO_BUCKET(ht, i);\n\t\twhile (Z_NEXT(prev->val) != idx) {\n\t\t\ti = Z_NEXT(prev->val);\n\t\t\tprev = HT_HASH_TO_BUCKET(ht, i);\n\t\t}\n\t}\n\n\tif (p->key) {\n\t\tzend_string_release(p->key);\n\t\tp->key = NULL;\n\t}\n\t_zend_hash_del_el_ex(ht, idx, p, prev);\n}\n\nZEND_API void ZEND_FASTCALL zend_hash_reverse_apply(HashTable *ht, apply_func_t apply_func)\n{\n\tuint32_t idx;\n\tint result;\n\n\tIS_CONSISTENT(ht);\n\n\tidx = ht->nNumUsed;\n\tif (HT_IS_PACKED(ht)) {\n\t\tzval *zv;\n\n\t\twhile (idx > 0) {\n\t\t\tidx--;\n\t\t\tzv = ht->arPacked + idx;\n\t\t\tif (UNEXPECTED(Z_TYPE_P(zv) == IS_UNDEF)) continue;\n\n\t\t\tresult = apply_func(zv);\n\n\t\t\tif (result & ZEND_HASH_APPLY_REMOVE) {\n\t\t\t\tHT_ASSERT_RC1(ht);\n\t\t\t\t_zend_hash_packed_del_val(ht, HT_IDX_TO_HASH(idx), zv);\n\t\t\t}\n\t\t\tif (result & ZEND_HASH_APPLY_STOP) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tBucket *p;\n\n\t\twhile (idx > 0) {\n\t\t\tidx--;\n\t\t\tp = ht->arData + idx;\n\t\t\tif (UNEXPECTED(Z_TYPE(p->val) == IS_UNDEF)) continue;\n\n\t\t\tresult = apply_func(&p->val);\n\n\t\t\tif (result & ZEND_HASH_APPLY_REMOVE) {\n\t\t\t\tHT_ASSERT_RC1(ht);\n\t\t\t\t_zend_hash_del_el(ht, HT_IDX_TO_HASH(idx), p);\n\t\t\t}\n\t\t\tif (result & ZEND_HASH_APPLY_STOP) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid shutdown_destructors(void) /* {{{ */\n{\n\tif (CG(unclean_shutdown)) {\n\t\tEG(symbol_table).pDestructor = zend_unclean_zval_ptr_dtor;\n\t}\n\tzend_try {\n\t\tuint32_t symbols;\n\t\tdo {\n\t\t\tsymbols = zend_hash_num_elements(&EG(symbol_table));\n\t\t\tzend_hash_reverse_apply(&EG(symbol_table), (apply_func_t) zval_call_destructor);\n\t\t} while (symbols != zend_hash_num_elements(&EG(symbol_table)));\n\t\tzend_objects_store_call_destructors(&EG(objects_store));\n\t} zend_catch {\n\t\t/* if we couldn't destruct cleanly, mark all objects as destructed anyway */\n\t\tzend_objects_store_mark_destructed(&EG(objects_store));\n\t} zend_end_try();\n}\n\nvoid zend_call_destructors(void) /* {{{ */\n{\n\tzend_try {\n\t\tshutdown_destructors();\n\t} zend_end_try();\n}\n\nvoid php_request_shutdown(void *dummy)\n{\n\tbool report_memleaks;\n\n\tEG(flags) |= EG_FLAGS_IN_SHUTDOWN;\n\n\treport_memleaks = PG(report_memleaks);\n\n\t/* EG(current_execute_data) points into nirvana and therefore cannot be safely accessed\n\t * inside zend_executor callback functions.\n\t */\n\tEG(current_execute_data) = NULL;\n\n\tphp_deactivate_ticks();\n\n\t/* 0. Call any open observer end handlers that are still open after a zend_bailout */\n\tif (ZEND_OBSERVER_ENABLED) {\n\t\tzend_observer_fcall_end_all();\n\t}\n\n\t/* 1. Call all possible shutdown functions registered with register_shutdown_function() */\n\tif (PG(modules_activated)) {\n\t\tphp_call_shutdown_functions();\n\t}\n\n\t/* 2. Call all possible __destruct() functions */\n\tzend_try {\n\t\tzend_call_destructors();\n\t} zend_end_try();\n\nvoid fuzzer_request_shutdown()\n{\n\tzend_try {\n\t\t/* Destroy thrown exceptions. This does not happen as part of request shutdown. */\n\t\tif (EG(exception)) {\n\t\t\tzend_object_release(EG(exception));\n\t\t\tEG(exception) = NULL;\n\t\t}\n\n\t\t/* Some fuzzers (like unserialize) may create circular structures. Make sure we free them.\n\t\t * Two calls are performed to handle objects with destructors. */\n\t\tzend_gc_collect_cycles();\n\t\tzend_gc_collect_cycles();\n\t} zend_end_try();\n\n\tphp_request_shutdown(NULL);\n}\n\nint fuzzer_do_request_from_buffer(\n\t\tchar *filename, const char *data, size_t data_len, bool execute,\n\t\tvoid (*before_shutdown)(void))\n{\n\tint retval = FAILURE; /* failure by default */\n\n\tSG(options) |= SAPI_OPTION_NO_CHDIR;\n\tSG(request_info).argc=0;\n\tSG(request_info).argv=NULL;\n\n\tif (fuzzer_request_startup() == FAILURE) {\n\t\treturn FAILURE;\n\t}\n\n\t// Commented out to avoid leaking the header callback.\n\t//SG(headers_sent) = 1;\n\t//SG(request_info).no_headers = 1;\n\tphp_register_variable(\"PHP_SELF\", filename, NULL);\n\n\tzend_first_try {\n\t\tzend_file_handle file_handle;\n\t\tzend_stream_init_filename(&file_handle, filename);\n\t\tfile_handle.primary_script = 1;\n\t\tfile_handle.buf = estrndup(data, data_len);\n\t\tfile_handle.len = data_len;\n\t\t/* Avoid ZEND_HANDLE_FILENAME for opcache. */\n\t\tfile_handle.type = ZEND_HANDLE_STREAM;\n\n\t\tzend_op_array *op_array = zend_compile_file(&file_handle, ZEND_REQUIRE);\n\t\tzend_destroy_file_handle(&file_handle);\n\t\tif (op_array) {\n\t\t\tif (execute) {\n\t\t\t\tzend_execute(op_array, NULL);\n\t\t\t}\n\t\t\tzend_destroy_static_vars(op_array);\n\t\t\tdestroy_op_array(op_array);\n\t\t\tefree(op_array);\n\t\t}\n\t} zend_end_try();\n\n\tCG(compiled_filename) = NULL; /* ??? */\n\tif (before_shutdown) {\n\t\tbefore_shutdown();\n\t}\n\tfuzzer_request_shutdown();\n\n\treturn (retval == SUCCESS) ? SUCCESS : FAILURE;\n}\n\n\n// target function\nstatic zend_always_inline void _zend_hash_del_el(HashTable *ht, uint32_t idx, Bucket *p)\n{\n\tBucket *prev = NULL;\n\tuint32_t nIndex;\n\tuint32_t i;\n\n\tnIndex = p->h | ht->nTableMask;\n\ti = HT_HASH(ht, nIndex);\n\n\tif (i != idx) {\n\t\tprev = HT_HASH_TO_BUCKET(ht, i);\n\t\twhile (Z_NEXT(prev->val) != idx) {\n\t\t\ti = Z_NEXT(prev->val);\n\t\t\tprev = HT_HASH_TO_BUCKET(ht, i);\n\t\t}\n\t}\n\n\t_zend_hash_del_el_ex(ht, idx, p, prev);\n\tif (p->key) {\n\t\tzend_string_release(p->key);\n\t\tp->key = NULL;\n\t}\n}\nZEND_API zend_result ZEND_FASTCALL zend_hash_del(HashTable *ht, zend_string *key)\n{\n\tzend_ulong h;\n\tuint32_t nIndex;\n\tuint32_t idx;\n\tBucket *p;\n\tBucket *prev = NULL;\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT_RC1(ht);\n\n\th = zend_string_hash_val(key);\n\tnIndex = h | ht->nTableMask;\n\n\tidx = HT_HASH(ht, nIndex);\n\twhile (idx != HT_INVALID_IDX) {\n\t\tp = HT_HASH_TO_BUCKET(ht, idx);\n\t\tif ((p->key == key) ||\n\t\t\t(p->h == h &&\n\t\t     p->key &&\n\t\t     zend_string_equal_content(p->key, key))) {\n\t\t\t_zend_hash_del_el_ex(ht, idx, p, prev);\n\t\t\tzend_string_release(p->key);\n\t\t\tp->key = NULL;\n\t\t\treturn SUCCESS;\n\t\t}\n\t\tprev = p;\n\t\tidx = Z_NEXT(p->val);\n\t}\n\treturn FAILURE;\n}\nZEND_API zend_result ZEND_FASTCALL zend_hash_del_ind(HashTable *ht, zend_string *key)\n{\n\tzend_ulong h;\n\tuint32_t nIndex;\n\tuint32_t idx;\n\tBucket *p;\n\tBucket *prev = NULL;\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT_RC1(ht);\n\n\th = zend_string_hash_val(key);\n\tnIndex = h | ht->nTableMask;\n\n\tidx = HT_HASH(ht, nIndex);\n\twhile (idx != HT_INVALID_IDX) {\n\t\tp = HT_HASH_TO_BUCKET(ht, idx);\n\t\tif ((p->key == key) ||\n\t\t\t(p->h == h &&\n\t\t     p->key &&\n\t\t     zend_string_equal_content(p->key, key))) {\n\t\t\tif (Z_TYPE(p->val) == IS_INDIRECT) {\n\t\t\t\tzval *data = Z_INDIRECT(p->val);\n\n\t\t\t\tif (UNEXPECTED(Z_TYPE_P(data) == IS_UNDEF)) {\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t} else {\n\t\t\t\t\tif (ht->pDestructor) {\n\t\t\t\t\t\tzval tmp;\n\t\t\t\t\t\tZVAL_COPY_VALUE(&tmp, data);\n\t\t\t\t\t\tZVAL_UNDEF(data);\n\t\t\t\t\t\tht->pDestructor(&tmp);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tZVAL_UNDEF(data);\n\t\t\t\t\t}\n\t\t\t\t\tHT_FLAGS(ht) |= HASH_FLAG_HAS_EMPTY_IND;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t_zend_hash_del_el_ex(ht, idx, p, prev);\n\t\t\t\tzend_string_release(p->key);\n\t\t\t\tp->key = NULL;\n\t\t\t}\n\t\t\treturn SUCCESS;\n\t\t}\n\t\tprev = p;\n\t\tidx = Z_NEXT(p->val);\n\t}\n\treturn FAILURE;\n}\nZEND_API zend_result ZEND_FASTCALL zend_hash_str_del_ind(HashTable *ht, const char *str, size_t len)\n{\n\tzend_ulong h;\n\tuint32_t nIndex;\n\tuint32_t idx;\n\tBucket *p;\n\tBucket *prev = NULL;\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT_RC1(ht);\n\n\th = zend_inline_hash_func(str, len);\n\tnIndex = h | ht->nTableMask;\n\n\tidx = HT_HASH(ht, nIndex);\n\twhile (idx != HT_INVALID_IDX) {\n\t\tp = HT_HASH_TO_BUCKET(ht, idx);\n\t\tif ((p->h == h)\n\t\t\t && p->key\n\t\t\t && (ZSTR_LEN(p->key) == len)\n\t\t\t && !memcmp(ZSTR_VAL(p->key), str, len)) {\n\t\t\tif (Z_TYPE(p->val) == IS_INDIRECT) {\n\t\t\t\tzval *data = Z_INDIRECT(p->val);\n\n\t\t\t\tif (UNEXPECTED(Z_TYPE_P(data) == IS_UNDEF)) {\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t} else {\n\t\t\t\t\tif (ht->pDestructor) {\n\t\t\t\t\t\tht->pDestructor(data);\n\t\t\t\t\t}\n\t\t\t\t\tZVAL_UNDEF(data);\n\t\t\t\t\tHT_FLAGS(ht) |= HASH_FLAG_HAS_EMPTY_IND;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t_zend_hash_del_el_ex(ht, idx, p, prev);\n\t\t\t\tzend_string_release(p->key);\n\t\t\t\tp->key = NULL;\n\t\t\t}\n\t\t\treturn SUCCESS;\n\t\t}\n\t\tprev = p;\n\t\tidx = Z_NEXT(p->val);\n\t}\n\treturn FAILURE;\n}\nZEND_API zend_result ZEND_FASTCALL zend_hash_str_del(HashTable *ht, const char *str, size_t len)\n{\n\tzend_ulong h;\n\tuint32_t nIndex;\n\tuint32_t idx;\n\tBucket *p;\n\tBucket *prev = NULL;\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT_RC1(ht);\n\n\th = zend_inline_hash_func(str, len);\n\tnIndex = h | ht->nTableMask;\n\n\tidx = HT_HASH(ht, nIndex);\n\twhile (idx != HT_INVALID_IDX) {\n\t\tp = HT_HASH_TO_BUCKET(ht, idx);\n\t\tif ((p->h == h)\n\t\t\t && p->key\n\t\t\t && (ZSTR_LEN(p->key) == len)\n\t\t\t && !memcmp(ZSTR_VAL(p->key), str, len)) {\n\t\t\t_zend_hash_del_el_ex(ht, idx, p, prev);\n\t\t\tzend_string_release(p->key);\n\t\t\tp->key = NULL;\n\t\t\treturn SUCCESS;\n\t\t}\n\t\tprev = p;\n\t\tidx = Z_NEXT(p->val);\n\t}\n\treturn FAILURE;\n}\n",
    "target": 1,
    "idx": 1042894,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic avifBool avifFileTypeIsCompatible(avifFileType * ftyp)\n{\n    avifBool avifCompatible = (!memcmp(ftyp->majorBrand, \"avif\", 4) || !memcmp(ftyp->majorBrand, \"avis\", 4));\n    if (!avifCompatible) {\n        for (int compatibleBrandIndex = 0; compatibleBrandIndex < ftyp->compatibleBrandsCount; ++compatibleBrandIndex) {\n            const uint8_t * compatibleBrand = &ftyp->compatibleBrands[4 * compatibleBrandIndex];\n            if (!memcmp(compatibleBrand, \"avif\", 4) || !memcmp(compatibleBrand, \"avis\", 4)) {\n                avifCompatible = AVIF_TRUE;\n                break;\n            }\n        }\n    }\n    return avifCompatible;\n}\n\navifResult avifDecoderParse(avifDecoder * decoder)\n{\n    if (!decoder->io || !decoder->io->read) {\n        return AVIF_RESULT_NO_IO;\n    }\n\n    // Cleanup anything lingering in the decoder\n    avifDecoderCleanup(decoder);\n\n    // -----------------------------------------------------------------------\n    // Parse BMFF boxes\n\n    decoder->data = avifDecoderDataCreate();\n\n    avifResult parseResult = avifParse(decoder);\n    if (parseResult != AVIF_RESULT_OK) {\n        return parseResult;\n    }\n\n    avifBool avifCompatible = avifFileTypeIsCompatible(&decoder->data->ftyp);\n    if (!avifCompatible) {\n        return AVIF_RESULT_INVALID_FTYP;\n    }\n\n    // Sanity check items\n    for (uint32_t itemIndex = 0; itemIndex < decoder->data->meta->items.count; ++itemIndex) {\n        avifDecoderItem * item = &decoder->data->meta->items.item[itemIndex];\n        if (item->hasUnsupportedEssentialProperty) {\n            // An essential property isn't supported by libavif; ignore the item.\n            continue;\n        }\n    }\n    return avifDecoderReset(decoder);\n}\n\n\n// target function\nstatic avifResult avifParse(avifDecoder * decoder)\n{\n    avifResult readResult;\n    size_t parseOffset = 0;\n    avifDecoderData * data = decoder->data;\n\n    for (;;) {\n        // Read just enough to get the next box header (a max of 32 bytes)\n        avifROData headerContents;\n        readResult = decoder->io->read(decoder->io, 0, parseOffset, 32, &headerContents);\n        if (readResult != AVIF_RESULT_OK) {\n            return readResult;\n        }\n        if (!headerContents.size) {\n            // If we got AVIF_RESULT_OK from the reader but received 0 bytes,\n            // This we've reached the end of the file with no errors. Hooray!\n            break;\n        }\n\n        // Parse the header, and find out how many bytes it actually was\n        BEGIN_STREAM(headerStream, headerContents.data, headerContents.size);\n        avifBoxHeader header;\n        CHECK(avifROStreamReadBoxHeaderPartial(&headerStream, &header));\n        parseOffset += headerStream.offset;\n\n        // Try to get the remainder of the box, if necessary\n        avifROData boxContents = AVIF_DATA_EMPTY;\n\n        // TODO: reorg this code to only do these memcmps once each\n        if (!memcmp(header.type, \"ftyp\", 4) || (!memcmp(header.type, \"meta\", 4) || !memcmp(header.type, \"moov\", 4))) {\n            readResult = decoder->io->read(decoder->io, 0, parseOffset, header.size, &boxContents);\n            if (readResult != AVIF_RESULT_OK) {\n                return readResult;\n            }\n            if (boxContents.size != header.size) {\n                // A truncated box, bail out\n                return AVIF_RESULT_BMFF_PARSE_FAILED;\n            }\n        }\n\n        if (!memcmp(header.type, \"ftyp\", 4)) {\n            avifRWDataSet(&data->ftypData, boxContents.data, boxContents.size);\n            CHECK(avifParseFileTypeBox(&data->ftyp, data->ftypData.data, data->ftypData.size));\n        } else if (!memcmp(header.type, \"meta\", 4)) {\n            CHECK(avifParseMetaBox(data->meta, boxContents.data, boxContents.size));\n        } else if (!memcmp(header.type, \"moov\", 4)) {\n            CHECK(avifParseMoovBox(data, boxContents.data, boxContents.size));\n        }\n\n        parseOffset += header.size;\n    }\n    return AVIF_RESULT_OK;\n}\n",
    "target": 1,
    "idx": 1025910,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nint us_socket_is_closed(int ssl, struct us_socket_t *s) {\n    return s->prev == (struct us_socket_t *) s->context;\n}\n\n\n\nvoid teardown() {\n\t/* If we are called twice there's a bug (it potentially could if\n\t * all open sockets cannot be error-closed in one epoll_wait call).\n\t * But we only allow 1k FDs and we have a buffer of 1024 from epoll_wait */\n\tif (!listen_socket && !client) {\n\t\texit(-1);\n\t}\n\n    if (client) {\n        us_socket_close(0, client, 0, 0);\n        client = NULL;\n    }\n\n\t/* We might have open sockets still, and these will be error-closed by epoll_wait */\n\t// us_socket_context_close - close all open sockets created with this socket context\n    if (listen_socket) {\n        us_listen_socket_close(0, listen_socket);\n        listen_socket = NULL;\n    }\n}\n\nint __wrap_epoll_wait(int epfd, struct epoll_event *events,\n               int maxevents, int timeout) {\n\t//printf(\"epoll_wait: %d\\n\", 0);\n\n#ifdef PRINTF_DEBUG\n\tprintf(\"Calling epoll_wait\\n\");\n#endif\n\n\tstruct epoll_file *ef = (struct epoll_file *)map_fd(epfd);\n\tif (!ef) {\n\t\treturn -1;\n\t}\n\n\tif (consumable_data_length) {\n\n\t\tint ready_events = 0;\n\n\t\tfor (struct file *f = ef->poll_set_head; f; f = f->next) {\n\n\n\t\t\t/* Consume one fuzz byte, AND it with the event */\n\t\t\tif (!consumable_data_length) {\n\t\t\t\t// break if we have no data\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// here we have the main condition that drives everything\n\t\t\tint ready_event = consumable_data[0] & f->epev.events;\n\n\t\t\t// consume the byte\n\t\t\tconsumable_data_length--;\n\t\t\tconsumable_data++;\n\n\t\t\tif (ready_event) {\n\t\t\t\tif (ready_events < maxevents) {\n\t\t\t\t\tevents[ready_events] = f->epev;\n\n\t\t\t\t\t// todo: the event should be masked by the byte, not everything it wants shold be given all the time!\n\t\t\t\t\tevents[ready_events++].events = ready_event;\n\t\t\t\t} else {\n\t\t\t\t\t// we are full, break\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\treturn ready_events;\n\n\t} else {\n\n#ifdef PRINTF_DEBUG\n\t\tprintf(\"Calling teardown\\n\");\n#endif\n\t\tteardown();\n\n\t\t// after shutting down the listen socket we clear the whole list (the bug in epoll_ctl remove)\n\t\t// so the below loop doesn't work - we never close anything more than the listen socket!\n\n\t\t/* You don't really need to emit teardown, you could simply emit error on every poll */\n\n\t\tint ready_events = 0;\n\n#ifdef PRINTF_DEBUG\n\t\tprintf(\"Emitting error on every remaining FD\\n\");\n#endif\n\t\tfor (struct file *f = ef->poll_set_head; f; f = f->next) {\n\n\t\t\tif (f->type == FD_TYPE_SOCKET) {\n\n\t\t\t\tif (ready_events < maxevents) {\n\t\t\t\t\tevents[ready_events] = f->epev;\n\n\t\t\t\t\t// todo: the event should be masked by the byte, not everything it wants shold be given all the time!\n\t\t\t\t\tevents[ready_events++].events = EPOLLERR | EPOLLHUP;\n\t\t\t\t} else {\n\t\t\t\t\t// we are full, break\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n#ifdef PRINTF_DEBUG\n\t\tprintf(\"Ready events: %d\\n\", ready_events);\n#endif\n\n\t\treturn ready_events;\n\t}\n}\n\nvoid us_loop_run(struct us_loop_t *loop) {\n    us_loop_integrate(loop);\n\n    /* While we have non-fallthrough polls we shouldn't fall through */\n    while (loop->num_polls) {\n        /* Emit pre callback */\n        us_internal_loop_pre(loop);\n\n        /* Fetch ready polls */\n#ifdef LIBUS_USE_EPOLL\n        loop->num_ready_polls = epoll_wait(loop->fd, loop->ready_polls, 1024, -1);\n#else\n        loop->num_ready_polls = kevent(loop->fd, NULL, 0, loop->ready_polls, 1024, NULL);\n#endif\n\n        /* Iterate ready polls, dispatching them by type */\n        for (loop->current_ready_poll = 0; loop->current_ready_poll < loop->num_ready_polls; loop->current_ready_poll++) {\n            struct us_poll_t *poll = GET_READY_POLL(loop, loop->current_ready_poll);\n            /* Any ready poll marked with nullptr will be ignored */\n            if (poll) {\n#ifdef LIBUS_USE_EPOLL\n                int events = loop->ready_polls[loop->current_ready_poll].events;\n                int error = loop->ready_polls[loop->current_ready_poll].events & (EPOLLERR | EPOLLHUP);\n#else\n                /* EVFILT_READ, EVFILT_TIME, EVFILT_USER are all mapped to LIBUS_SOCKET_READABLE */\n                int events = LIBUS_SOCKET_READABLE;\n                if (loop->ready_polls[loop->current_ready_poll].filter == EVFILT_WRITE) {\n                    events = LIBUS_SOCKET_WRITABLE;\n                }\n                int error = loop->ready_polls[loop->current_ready_poll].flags & (EV_ERROR | EV_EOF);\n#endif\n                /* Always filter all polls by what they actually poll for (callback polls always poll for readable) */\n                events &= us_poll_events(poll);\n                if (events || error) {\n                    us_internal_dispatch_ready_poll(poll, error, events);\n                }\n            }\n        }\n        /* Emit post callback */\n        us_internal_loop_post(loop);\n    }\n}\n\ninline void run() {\n    Loop::get()->run();\n}\n\ninline void run() {\n    Loop::get()->run();\n}\n\n\n\nvoid test() {\n\t/* ws->getUserData returns one of these */\n    struct PerSocketData {\n        /* Fill with user data */\n    };\n\n    {\n        /* Keep in mind that uWS::SSLApp({options}) is the same as uWS::App() when compiled without SSL support.\n        * You may swap to using uWS:App() if you don't need SSL */\n        auto app = uWS::App({\n            /* There are example certificates in uWebSockets.js repo */\n            .key_file_name = \"../misc/key.pem\",\n            .cert_file_name = \"../misc/cert.pem\",\n            .passphrase = \"1234\"\n        }).ws<PerSocketData>(\"/*\", {\n            /* Settings */\n            .compression = uWS::SHARED_COMPRESSOR,\n            .maxPayloadLength = 16 * 1024,\n            .idleTimeout = 10,\n            .maxBackpressure = 1 * 1024 * 1024,\n            /* Handlers */\n            .open = [](auto *ws) {\n                /* Open event here, you may access ws->getUserData() which points to a PerSocketData struct */\n                ws->getNativeHandle();\n                ws->getRemoteAddressAsText();\n                us_poll_ext((struct us_poll_t *) ws);\n            },\n            .message = [](auto *ws, std::string_view message, uWS::OpCode opCode) {\n                ws->send(message, opCode, true);\n            },\n            .drain = [](auto *ws) {\n                /* Check ws->getBufferedAmount() here */\n            },\n            .ping = [](auto *ws) {\n                /* We use this to trigger the async/wakeup feature */\n\t\tuWS::Loop::get()->defer([]() {\n\t\t    /* Do nothing */\n                });\n            },\n            .pong = [](auto *ws) {\n                /* Not implemented yet */\n            },\n            .close = [](auto *ws, int code, std::string_view message) {\n                /* You may access ws->getUserData() here */\n            }\n        }).listen(9001, [](auto *listenSocket) {\n            listen_socket = listenSocket;\n        });\n\n        /* Here we want to stress the connect feature, since nothing else stresses it */\n        struct us_loop_t *loop = (struct us_loop_t *) uWS::Loop::get();\n        /* This function is stupid */\n        us_loop_iteration_number(loop);\n        struct us_socket_context_t *client_context = us_create_socket_context(0, loop, 0, {});\n        client = us_socket_context_connect(0, client_context, \"hostname\", 5000, \"localhost\", 0, 0);\n\n        us_socket_context_on_connect_error(0, client_context, [](struct us_socket_t *s, int code) {\n\t    client = nullptr;\n            return s;\n        });\n\n        us_socket_context_on_open(0, client_context, [](struct us_socket_t *s, int is_client, char *ip, int ip_length) {\n            us_socket_flush(0, s);\n            return s;\n        });\n\n        us_socket_context_on_end(0, client_context, [](struct us_socket_t *s) {\n            return s;\n        });\n\n        us_socket_context_on_data(0, client_context, [](struct us_socket_t *s, char *data, int length) {\n            return s;\n        });\n\n        us_socket_context_on_writable(0, client_context, [](struct us_socket_t *s) {\n            return s;\n        });\n\n        us_socket_context_on_close(0, client_context, [](struct us_socket_t *s, int code, void *reason) {\n            client = NULL;\n            return s;\n        });\n\n        /* Trigger some context functions */\n        app.addServerName(\"\", {});\n        app.removeServerName(\"\");\n        app.missingServerName(nullptr);\n        app.getNativeHandle();\n\n        app.run();\n\n        /* After done we also free the client context */\n        us_socket_context_free(0, client_context);\n    }\n    uWS::Loop::get()->free();\n}\n\n\n// target function\nvoid test() {\n\t/* ws->getUserData returns one of these */\n    struct PerSocketData {\n        /* Fill with user data */\n    };\n\n    {\n        /* Keep in mind that uWS::SSLApp({options}) is the same as uWS::App() when compiled without SSL support.\n        * You may swap to using uWS:App() if you don't need SSL */\n        auto app = uWS::App({\n            /* There are example certificates in uWebSockets.js repo */\n            .key_file_name = \"../misc/key.pem\",\n            .cert_file_name = \"../misc/cert.pem\",\n            .passphrase = \"1234\"\n        }).ws<PerSocketData>(\"/*\", {\n            /* Settings */\n            .compression = uWS::SHARED_COMPRESSOR,\n            .maxPayloadLength = 16 * 1024,\n            .idleTimeout = 10,\n            .maxBackpressure = 1 * 1024 * 1024,\n            /* Handlers */\n            .open = [](auto *ws) {\n                /* Open event here, you may access ws->getUserData() which points to a PerSocketData struct */\n                ws->getNativeHandle();\n                ws->getRemoteAddressAsText();\n                us_poll_ext((struct us_poll_t *) ws);\n            },\n            .message = [](auto *ws, std::string_view message, uWS::OpCode opCode) {\n                ws->send(message, opCode, true);\n            },\n            .drain = [](auto *ws) {\n                /* Check ws->getBufferedAmount() here */\n            },\n            .ping = [](auto *ws) {\n                /* We use this to trigger the async/wakeup feature */\n\t\tuWS::Loop::get()->defer([]() {\n\t\t    /* Do nothing */\n                });\n            },\n            .pong = [](auto *ws) {\n                /* Not implemented yet */\n            },\n            .close = [](auto *ws, int code, std::string_view message) {\n                /* You may access ws->getUserData() here */\n            }\n        }).listen(9001, [](auto *listenSocket) {\n            listen_socket = listenSocket;\n        });\n\n        /* Here we want to stress the connect feature, since nothing else stresses it */\n        struct us_loop_t *loop = (struct us_loop_t *) uWS::Loop::get();\n        /* This function is stupid */\n        us_loop_iteration_number(loop);\n        struct us_socket_context_t *client_context = us_create_socket_context(0, loop, 0, {});\n        client = us_socket_context_connect(0, client_context, \"hostname\", 5000, \"localhost\", 0, 0);\n\n        us_socket_context_on_connect_error(0, client_context, [](struct us_socket_t *s, int code) {\n            return s;\n        });\n\n        us_socket_context_on_open(0, client_context, [](struct us_socket_t *s, int is_client, char *ip, int ip_length) {\n            us_socket_flush(0, s);\n            return s;\n        });\n\n        us_socket_context_on_end(0, client_context, [](struct us_socket_t *s) {\n            return s;\n        });\n\n        us_socket_context_on_data(0, client_context, [](struct us_socket_t *s, char *data, int length) {\n            return s;\n        });\n\n        us_socket_context_on_writable(0, client_context, [](struct us_socket_t *s) {\n            return s;\n        });\n\n        us_socket_context_on_close(0, client_context, [](struct us_socket_t *s, int code, void *reason) {\n            client = NULL;\n            return s;\n        });\n\n        /* Trigger some context functions */\n        app.addServerName(\"\", {});\n        app.removeServerName(\"\");\n        app.missingServerName(nullptr);\n        app.getNativeHandle();\n\n        app.run();\n\n        /* After done we also free the client context */\n        us_socket_context_free(0, client_context);\n    }\n    uWS::Loop::get()->free();\n}\n",
    "target": 1,
    "idx": 1031047,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "// context\nstatic void\nxmlParserPrintFileContextInternal(xmlParserInputPtr input ,\n\t\txmlGenericErrorFunc channel, void *data ) {\n    const xmlChar *cur, *base;\n    unsigned int n, col;\t/* GCC warns if signed, because compared with sizeof() */\n    xmlChar  content[81]; /* space for 80 chars + line terminator */\n    xmlChar *ctnt;\n\n    if ((input == NULL) || (input->cur == NULL))\n        return;\n\n    cur = input->cur;\n    base = input->base;\n    /* skip backwards over any end-of-lines */\n    while ((cur > base) && ((*(cur) == '\\n') || (*(cur) == '\\r'))) {\n\tcur--;\n    }\n    n = 0;\n    /* search backwards for beginning-of-line (to max buff size) */\n    while ((n++ < (sizeof(content)-1)) && (cur > base) &&\n\t   (*(cur) != '\\n') && (*(cur) != '\\r'))\n        cur--;\n    if ((*(cur) == '\\n') || (*(cur) == '\\r')) cur++;\n    /* calculate the error position in terms of the current position */\n    col = input->cur - cur;\n    /* search forward for end-of-line (to max buff size) */\n    n = 0;\n    ctnt = content;\n    /* copy selected text to our buffer */\n    while ((*cur != 0) && (*(cur) != '\\n') &&\n\t   (*(cur) != '\\r') && (n < sizeof(content)-1)) {\n\t\t*ctnt++ = *cur++;\n\tn++;\n    }\n    *ctnt = 0;\n    /* print out the selected text */\n    channel(data ,\"%s\\n\", content);\n    /* create blank line with problem pointer */\n    n = 0;\n    ctnt = content;\n    /* (leave buffer space for pointer + line terminator) */\n    while ((n<col) && (n++ < sizeof(content)-2) && (*ctnt != 0)) {\n\tif (*(ctnt) != '\\t')\n\t    *(ctnt) = ' ';\n\tctnt++;\n    }\n    *ctnt++ = '^';\n    *ctnt = 0;\n    channel(data ,\"%s\\n\", content);\n}\n\nstatic void\nxmlReportError(xmlErrorPtr err, xmlParserCtxtPtr ctxt, const char *str,\n               xmlGenericErrorFunc channel, void *data)\n{\n    char *file = NULL;\n    int line = 0;\n    int code = -1;\n    int domain;\n    const xmlChar *name = NULL;\n    xmlNodePtr node;\n    xmlErrorLevel level;\n    xmlParserInputPtr input = NULL;\n    xmlParserInputPtr cur = NULL;\n\n    if (err == NULL)\n        return;\n\n    if (channel == NULL) {\n\tchannel = xmlGenericError;\n\tdata = xmlGenericErrorContext;\n    }\n    file = err->file;\n    line = err->line;\n    code = err->code;\n    domain = err->domain;\n    level = err->level;\n    node = err->node;\n\n    if (code == XML_ERR_OK)\n        return;\n\n    if ((node != NULL) && (node->type == XML_ELEMENT_NODE))\n        name = node->name;\n\n    /*\n     * Maintain the compatibility with the legacy error handling\n     */\n    if (ctxt != NULL) {\n        input = ctxt->input;\n        if ((input != NULL) && (input->filename == NULL) &&\n            (ctxt->inputNr > 1)) {\n            cur = input;\n            input = ctxt->inputTab[ctxt->inputNr - 2];\n        }\n        if (input != NULL) {\n            if (input->filename)\n                channel(data, \"%s:%d: \", input->filename, input->line);\n            else if ((line != 0) && (domain == XML_FROM_PARSER))\n                channel(data, \"Entity: line %d: \", input->line);\n        }\n    } else {\n        if (file != NULL)\n            channel(data, \"%s:%d: \", file, line);\n        else if ((line != 0) &&\n\t         ((domain == XML_FROM_PARSER) || (domain == XML_FROM_SCHEMASV)||\n\t\t  (domain == XML_FROM_SCHEMASP)||(domain == XML_FROM_DTD) ||\n\t\t  (domain == XML_FROM_RELAXNGP)||(domain == XML_FROM_RELAXNGV)))\n            channel(data, \"Entity: line %d: \", line);\n    }\n    if (name != NULL) {\n        channel(data, \"element %s: \", name);\n    }\n    switch (domain) {\n        case XML_FROM_PARSER:\n            channel(data, \"parser \");\n            break;\n        case XML_FROM_NAMESPACE:\n            channel(data, \"namespace \");\n            break;\n        case XML_FROM_DTD:\n        case XML_FROM_VALID:\n            channel(data, \"validity \");\n            break;\n        case XML_FROM_HTML:\n            channel(data, \"HTML parser \");\n            break;\n        case XML_FROM_MEMORY:\n            channel(data, \"memory \");\n            break;\n        case XML_FROM_OUTPUT:\n            channel(data, \"output \");\n            break;\n        case XML_FROM_IO:\n            channel(data, \"I/O \");\n            break;\n        case XML_FROM_XINCLUDE:\n            channel(data, \"XInclude \");\n            break;\n        case XML_FROM_XPATH:\n            channel(data, \"XPath \");\n            break;\n        case XML_FROM_XPOINTER:\n            channel(data, \"parser \");\n            break;\n        case XML_FROM_REGEXP:\n            channel(data, \"regexp \");\n            break;\n        case XML_FROM_MODULE:\n            channel(data, \"module \");\n            break;\n        case XML_FROM_SCHEMASV:\n            channel(data, \"Schemas validity \");\n            break;\n        case XML_FROM_SCHEMASP:\n            channel(data, \"Schemas parser \");\n            break;\n        case XML_FROM_RELAXNGP:\n            channel(data, \"Relax-NG parser \");\n            break;\n        case XML_FROM_RELAXNGV:\n            channel(data, \"Relax-NG validity \");\n            break;\n        case XML_FROM_CATALOG:\n            channel(data, \"Catalog \");\n            break;\n        case XML_FROM_C14N:\n            channel(data, \"C14N \");\n            break;\n        case XML_FROM_XSLT:\n            channel(data, \"XSLT \");\n            break;\n        case XML_FROM_I18N:\n            channel(data, \"encoding \");\n            break;\n        case XML_FROM_SCHEMATRONV:\n            channel(data, \"schematron \");\n            break;\n        case XML_FROM_BUFFER:\n            channel(data, \"internal buffer \");\n            break;\n        case XML_FROM_URI:\n            channel(data, \"URI \");\n            break;\n        default:\n            break;\n    }\n    switch (level) {\n        case XML_ERR_NONE:\n            channel(data, \": \");\n            break;\n        case XML_ERR_WARNING:\n            channel(data, \"warning : \");\n            break;\n        case XML_ERR_ERROR:\n            channel(data, \"error : \");\n            break;\n        case XML_ERR_FATAL:\n            channel(data, \"error : \");\n            break;\n    }\n    if (str != NULL) {\n        int len;\n\tlen = xmlStrlen((const xmlChar *)str);\n\tif ((len > 0) && (str[len - 1] != '\\n'))\n\t    channel(data, \"%s\\n\", str);\n\telse\n\t    channel(data, \"%s\", str);\n    } else {\n        channel(data, \"%s\\n\", \"out of memory error\");\n    }\n\n    if (ctxt != NULL) {\n        xmlParserPrintFileContextInternal(input, channel, data);\n        if (cur != NULL) {\n            if (cur->filename)\n                channel(data, \"%s:%d: \\n\", cur->filename, cur->line);\n            else if ((line != 0) && (domain == XML_FROM_PARSER))\n                channel(data, \"Entity: line %d: \\n\", cur->line);\n            xmlParserPrintFileContextInternal(cur, channel, data);\n        }\n    }\n    if ((domain == XML_FROM_XPATH) && (err->str1 != NULL) &&\n        (err->int1 < 100) &&\n\t(err->int1 < xmlStrlen((const xmlChar *)err->str1))) {\n\txmlChar buf[150];\n\tint i;\n\n\tchannel(data, \"%s\\n\", err->str1);\n\tfor (i=0;i < err->int1;i++)\n\t     buf[i] = ' ';\n\tbuf[i++] = '^';\n\tbuf[i] = 0;\n\tchannel(data, \"%s\\n\", buf);\n    }\n}\n\nvoid XMLCDECL\n__xmlRaiseError(xmlStructuredErrorFunc schannel,\n              xmlGenericErrorFunc channel, void *data, void *ctx,\n              void *nod, int domain, int code, xmlErrorLevel level,\n              const char *file, int line, const char *str1,\n              const char *str2, const char *str3, int int1, int col,\n\t      const char *msg, ...)\n{\n    xmlParserCtxtPtr ctxt = NULL;\n    xmlNodePtr node = (xmlNodePtr) nod;\n    char *str = NULL;\n    xmlParserInputPtr input = NULL;\n    xmlErrorPtr to = &xmlLastError;\n    xmlNodePtr baseptr = NULL;\n\n    if (code == XML_ERR_OK)\n        return;\n    if ((xmlGetWarningsDefaultValue == 0) && (level == XML_ERR_WARNING))\n        return;\n    if ((domain == XML_FROM_PARSER) || (domain == XML_FROM_HTML) ||\n        (domain == XML_FROM_DTD) || (domain == XML_FROM_NAMESPACE) ||\n\t(domain == XML_FROM_IO) || (domain == XML_FROM_VALID)) {\n\tctxt = (xmlParserCtxtPtr) ctx;\n\tif ((schannel == NULL) && (ctxt != NULL) && (ctxt->sax != NULL) &&\n\t    (ctxt->sax->initialized == XML_SAX2_MAGIC) &&\n\t    (ctxt->sax->serror != NULL)) {\n\t    schannel = ctxt->sax->serror;\n\t    data = ctxt->userData;\n\t}\n    }\n    /*\n     * Check if structured error handler set\n     */\n    if (schannel == NULL) {\n\tschannel = xmlStructuredError;\n\t/*\n\t * if user has defined handler, change data ptr to user's choice\n\t */\n\tif (schannel != NULL)\n\t    data = xmlStructuredErrorContext;\n    }\n    /*\n     * Formatting the message\n     */\n    if (msg == NULL) {\n        str = (char *) xmlStrdup(BAD_CAST \"No error message provided\");\n    } else {\n        XML_GET_VAR_STR(msg, str);\n    }\n\n    /*\n     * specific processing if a parser context is provided\n     */\n    if (ctxt != NULL) {\n        if (file == NULL) {\n            input = ctxt->input;\n            if ((input != NULL) && (input->filename == NULL) &&\n                (ctxt->inputNr > 1)) {\n                input = ctxt->inputTab[ctxt->inputNr - 2];\n            }\n            if (input != NULL) {\n                file = input->filename;\n                line = input->line;\n                col = input->col;\n            }\n        }\n        to = &ctxt->lastError;\n    } else if ((node != NULL) && (file == NULL)) {\n\tint i;\n\n\tif ((node->doc != NULL) && (node->doc->URL != NULL)) {\n\t    baseptr = node;\n/*\t    file = (const char *) node->doc->URL; */\n\t}\n\tfor (i = 0;\n\t     ((i < 10) && (node != NULL) && (node->type != XML_ELEMENT_NODE));\n\t     i++)\n\t     node = node->parent;\n        if ((baseptr == NULL) && (node != NULL) &&\n\t    (node->doc != NULL) && (node->doc->URL != NULL))\n\t    baseptr = node;\n\n\tif ((node != NULL) && (node->type == XML_ELEMENT_NODE))\n\t    line = node->line;\n\tif ((line == 0) || (line == 65535))\n\t    line = xmlGetLineNo(node);\n    }\n\n    /*\n     * Save the information about the error\n     */\n    xmlResetError(to);\n    to->domain = domain;\n    to->code = code;\n    to->message = str;\n    to->level = level;\n    if (file != NULL)\n        to->file = (char *) xmlStrdup((const xmlChar *) file);\n    else if (baseptr != NULL) {\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t/*\n\t * We check if the error is within an XInclude section and,\n\t * if so, attempt to print out the href of the XInclude instead\n\t * of the usual \"base\" (doc->URL) for the node (bug 152623).\n\t */\n        xmlNodePtr prev = baseptr;\n\tint inclcount = 0;\n\twhile (prev != NULL) {\n\t    if (prev->prev == NULL)\n\t        prev = prev->parent;\n\t    else {\n\t        prev = prev->prev;\n\t\tif (prev->type == XML_XINCLUDE_START) {\n\t\t    if (--inclcount < 0)\n\t\t        break;\n\t\t} else if (prev->type == XML_XINCLUDE_END)\n\t\t    inclcount++;\n\t    }\n\t}\n\tif (prev != NULL) {\n\t    if (prev->type == XML_XINCLUDE_START) {\n\t\tprev->type = XML_ELEMENT_NODE;\n\t\tto->file = (char *) xmlGetProp(prev, BAD_CAST \"href\");\n\t\tprev->type = XML_XINCLUDE_START;\n\t    } else {\n\t\tto->file = (char *) xmlGetProp(prev, BAD_CAST \"href\");\n\t    }\n\t} else\n#endif\n\t    to->file = (char *) xmlStrdup(baseptr->doc->URL);\n\tif ((to->file == NULL) && (node != NULL) && (node->doc != NULL)) {\n\t    to->file = (char *) xmlStrdup(node->doc->URL);\n\t}\n    }\n    to->line = line;\n    if (str1 != NULL)\n        to->str1 = (char *) xmlStrdup((const xmlChar *) str1);\n    if (str2 != NULL)\n        to->str2 = (char *) xmlStrdup((const xmlChar *) str2);\n    if (str3 != NULL)\n        to->str3 = (char *) xmlStrdup((const xmlChar *) str3);\n    to->int1 = int1;\n    to->int2 = col;\n    to->node = node;\n    to->ctxt = ctx;\n\n    if (to != &xmlLastError)\n        xmlCopyError(to,&xmlLastError);\n\n    if (schannel != NULL) {\n\tschannel(data, to);\n\treturn;\n    }\n\n    /*\n     * Find the callback channel if channel param is NULL\n     */\n    if ((ctxt != NULL) && (channel == NULL) &&\n        (xmlStructuredError == NULL) && (ctxt->sax != NULL)) {\n        if (level == XML_ERR_WARNING)\n\t    channel = ctxt->sax->warning;\n        else\n\t    channel = ctxt->sax->error;\n\tdata = ctxt->userData;\n    } else if (channel == NULL) {\n\tchannel = xmlGenericError;\n\tif (ctxt != NULL) {\n\t    data = ctxt;\n\t} else {\n\t    data = xmlGenericErrorContext;\n\t}\n    }\n    if (channel == NULL)\n        return;\n\n    if ((channel == xmlParserError) ||\n        (channel == xmlParserWarning) ||\n\t(channel == xmlParserValidityError) ||\n\t(channel == xmlParserValidityWarning))\n\txmlReportError(to, ctxt, str, NULL, NULL);\n    else if (((void(*)(void)) channel == (void(*)(void)) fprintf) ||\n             (channel == xmlGenericErrorDefaultFunc))\n\txmlReportError(to, ctxt, str, channel, data);\n    else\n\tchannel(data, \"%s\", str);\n}\n\nhtmlParseErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,\n             const char *msg, const xmlChar *str1, const xmlChar *str2)\n{\n    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&\n        (ctxt->instate == XML_PARSER_EOF))\n\treturn;\n    if (ctxt != NULL)\n\tctxt->errNo = error;\n    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_HTML, error,\n                    XML_ERR_ERROR, NULL, 0,\n\t\t    (const char *) str1, (const char *) str2,\n\t\t    NULL, 0, 0,\n\t\t    msg, str1, str2);\n    if (ctxt != NULL)\n\tctxt->wellFormed = 0;\n}\n\n\n// target function\nint\nhtmlParseChunk(htmlParserCtxtPtr ctxt, const char *chunk, int size,\n              int terminate) {\n    if ((ctxt == NULL) || (ctxt->input == NULL)) {\n\thtmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\n\t\t     \"htmlParseChunk: context error\\n\", NULL, NULL);\n\treturn(XML_ERR_INTERNAL_ERROR);\n    }\n    if ((size > 0) && (chunk != NULL) && (ctxt->input != NULL) &&\n        (ctxt->input->buf != NULL) && (ctxt->instate != XML_PARSER_EOF))  {\n\tsize_t base = xmlBufGetInputBase(ctxt->input->buf->buffer, ctxt->input);\n\tsize_t cur = ctxt->input->cur - ctxt->input->base;\n\tint res;\n\n\tres = xmlParserInputBufferPush(ctxt->input->buf, size, chunk);\n\tif (res < 0) {\n\t    ctxt->errNo = XML_PARSER_EOF;\n\t    ctxt->disableSAX = 1;\n\t    return (XML_PARSER_EOF);\n\t}\n        xmlBufSetInputBaseCur(ctxt->input->buf->buffer, ctxt->input, base, cur);\n#ifdef DEBUG_PUSH\n\txmlGenericError(xmlGenericErrorContext, \"HPP: pushed %d\\n\", size);\n#endif\n\n#if 0\n\tif ((terminate) || (ctxt->input->buf->buffer->use > 80))\n\t    htmlParseTryOrFinish(ctxt, terminate);\n#endif\n    } else if (ctxt->instate != XML_PARSER_EOF) {\n\tif ((ctxt->input != NULL) && ctxt->input->buf != NULL) {\n\t    xmlParserInputBufferPtr in = ctxt->input->buf;\n\t    if ((in->encoder != NULL) && (in->buffer != NULL) &&\n\t\t    (in->raw != NULL)) {\n\t\tint nbchars;\n\t\tsize_t base = xmlBufGetInputBase(in->buffer, ctxt->input);\n\t\tsize_t current = ctxt->input->cur - ctxt->input->base;\n\n\t\tnbchars = xmlCharEncInput(in, terminate);\n\t\txmlBufSetInputBaseCur(in->buffer, ctxt->input, base, current);\n\t\tif (nbchars < 0) {\n\t\t    htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n\t\t\t         \"encoder error\\n\", NULL, NULL);\n\t\t    return(XML_ERR_INVALID_ENCODING);\n\t\t}\n\t    }\n\t}\n    }\n    htmlParseTryOrFinish(ctxt, terminate);\n    if (terminate) {\n\tif ((ctxt->instate != XML_PARSER_EOF) &&\n\t    (ctxt->instate != XML_PARSER_EPILOG) &&\n\t    (ctxt->instate != XML_PARSER_MISC)) {\n\t    ctxt->errNo = XML_ERR_DOCUMENT_END;\n\t    ctxt->wellFormed = 0;\n\t}\n\tif (ctxt->instate != XML_PARSER_EOF) {\n\t    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n\t\tctxt->sax->endDocument(ctxt->userData);\n\t}\n\tctxt->instate = XML_PARSER_EOF;\n    }\n    return((xmlParserErrors) ctxt->errNo);\n}\nsize_t\nxmlBufDump(FILE *file, xmlBufPtr buf) {\n    size_t ret;\n\n    if ((buf == NULL) || (buf->error != 0)) {\n#ifdef DEBUG_BUFFER\n        xmlGenericError(xmlGenericErrorContext,\n\t\t\"xmlBufDump: buf == NULL or in error\\n\");\n#endif\n\treturn(0);\n    }\n    if (buf->content == NULL) {\n#ifdef DEBUG_BUFFER\n        xmlGenericError(xmlGenericErrorContext,\n\t\t\"xmlBufDump: buf->content == NULL\\n\");\n#endif\n\treturn(0);\n    }\n    CHECK_COMPAT(buf)\n    if (file == NULL)\n\tfile = stdout;\n    ret = fwrite(buf->content, sizeof(xmlChar), buf->use, file);\n    return(ret);\n}\nint\nxmlBufSetInputBaseCur(xmlBufPtr buf, xmlParserInputPtr input,\n                      size_t base, size_t cur) {\n    if ((input == NULL) || (buf == NULL) || (buf->error))\n        return(-1);\n    CHECK_COMPAT(buf)\n    input->base = &buf->content[base];\n    input->cur = input->base + cur;\n    input->end = &buf->content[buf->use];\n    return(0);\n}\n",
    "target": 1,
    "idx": 1024055,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nvoid Object::free() {\n  switch (type) {\n  case objString:\n    delete string;\n    break;\n  case objName:\n  case objCmd:\n    gfree(cString);\n    break;\n  case objArray:\n    if (!array->decRef()) {\n      delete array;\n    }\n    break;\n  case objDict:\n    if (!dict->decRef()) {\n      delete dict;\n    }\n    break;\n  case objStream:\n    if (!stream->decRef()) {\n      delete stream;\n    }\n    break;\n  default:\n    break;\n  }\n  type = objNone;\n}\n\n  ObjectStream(const ObjectStream &) = delete;\n\nXRef::~XRef() {\n  for(int i=0; i<size; i++) {\n      entries[i].obj.~Object();\n  }\n  gfree(entries);\n\n  if (streamEnds) {\n    gfree(streamEnds);\n  }\n  if (strOwner) {\n    delete str;\n  }\n}\n\nPDFDoc::~PDFDoc() {\n  if (pageCache) {\n    for (int i = 0; i < getNumPages(); i++) {\n      if (pageCache[i]) {\n        delete pageCache[i];\n      }\n    }\n    gfree(pageCache);\n  }\n  delete secHdlr;\n  if (outline) {\n    delete outline;\n  }\n  if (catalog) {\n    delete catalog;\n  }\n  if (xref) {\n    delete xref;\n  }\n  if (hints) {\n    delete hints;\n  }\n  if (linearization) {\n    delete linearization;\n  }\n  if (str) {\n    delete str;\n  }\n  if (file) {\n    delete file;\n  }\n  if (fileName) {\n    delete fileName;\n  }\n#ifdef _WIN32\n  if (fileNameU) {\n    gfree(fileNameU);\n  }\n#endif\n}\n\ndocument_private::~document_private()\n{\n    delete_all(embedded_files);\n\n    delete doc;\n}\n\ndocument::~document()\n{\n    delete d;\n}\n\n\n// target function\nvoid Page::loadStandaloneFields(Annots *annotations, Form *form) {\n  const int numAnnots = annotations ? annotations->getNumAnnots() : 0;\n  if (numAnnots < 1)\n    return;\n\n  /* Look for standalone annots, identified by being: 1) of type Widget\n   * 2) of subtype Button 3) not referenced from the Catalog's Form Field array */\n  for (int i = 0; i < numAnnots; ++i) {\n    Annot *annot = annotations->getAnnot(i);\n\n    if (annot->getType() != Annot::typeWidget || !annot->getHasRef())\n      continue;\n\n    const Ref r = annot->getRef();\n    if (form && form->findWidgetByRef(r))\n      continue; // this annot is referenced inside Form, skip it\n\n    std::set<int> parents;\n    FormField *field = Form::createFieldFromDict (Object(annot->getDict()),\n                                                  annot->getDoc(), r, nullptr, &parents);\n\n    if (field && field->getType() == formButton && field->getNumWidgets() == 1) {\n\n      field->setStandAlone(true);\n      FormWidget *formWidget = field->getWidget(0);\n\n      if (!formWidget->getWidgetAnnotation())\n        formWidget->createWidgetAnnotation();\n\n      standaloneFields.push_back(field);\n\n    } else if (field) {\n      delete field;\n    }\n  }\n}\n",
    "target": 1,
    "idx": 1021604,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nint cil_resolve_nametypetransition(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_args_resolve *args = extra_args;\n\tstruct cil_nametypetransition *nametypetrans = current->data;\n\tstruct cil_symtab_datum *src_datum = NULL;\n\tstruct cil_symtab_datum *tgt_datum = NULL;\n\tstruct cil_symtab_datum *obj_datum = NULL;\n\tstruct cil_symtab_datum *name_datum = NULL;\n\tstruct cil_symtab_datum *result_datum = NULL;\n\tstruct cil_tree_node *result_node = NULL;\n\tint rc = SEPOL_ERR;\n\n\trc = cil_resolve_name(current, nametypetrans->src_str, CIL_SYM_TYPES, extra_args, &src_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\tnametypetrans->src = src_datum;\n\n\trc = cil_resolve_name(current, nametypetrans->tgt_str, CIL_SYM_TYPES, extra_args, &tgt_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\tnametypetrans->tgt = tgt_datum;\n\n\trc = cil_resolve_name(current, nametypetrans->obj_str, CIL_SYM_CLASSES, extra_args, &obj_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\tnametypetrans->obj = (struct cil_class*)obj_datum;\n\n\tnametypetrans->name = __cil_insert_name(args->db, nametypetrans->name_str, current);\n\tif (nametypetrans->name == NULL) {\n\t\trc = cil_resolve_name(current, nametypetrans->name_str, CIL_SYM_NAMES, extra_args, &name_datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\tnametypetrans->name = (struct cil_name *)name_datum;\n\t}\n\n\trc = cil_resolve_name(current, nametypetrans->result_str, CIL_SYM_TYPES, extra_args, &result_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\tresult_node = NODE(result_datum);\n\n\tif (result_node->flavor != CIL_TYPE && result_node->flavor != CIL_TYPEALIAS) {\n\t\tcil_log(CIL_ERR, \"typetransition result is not a type or type alias\\n\");\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\tnametypetrans->result = result_datum;\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_resolve_avrule(struct cil_tree_node *current, void *extra_args)\n{\n\tstruct cil_args_resolve *args = extra_args;\n\tstruct cil_db *db = NULL;\n\n\tstruct cil_avrule *rule = current->data;\n\tstruct cil_symtab_datum *src_datum = NULL;\n\tstruct cil_symtab_datum *tgt_datum = NULL;\n\tstruct cil_symtab_datum *permx_datum = NULL;\n\tint used;\n\tint rc = SEPOL_ERR;\n\n\tif (args != NULL) {\n\t\tdb = args->db;\n\t}\n\n\trc = cil_resolve_name(current, rule->src_str, CIL_SYM_TYPES, args, &src_datum);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\trule->src = src_datum;\n\t\t\n\tif (rule->tgt_str == CIL_KEY_SELF) {\n\t\trule->tgt = db->selftype;\n\t} else {\n\t\trc = cil_resolve_name(current, rule->tgt_str, CIL_SYM_TYPES, args, &tgt_datum);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t\trule->tgt = tgt_datum;\n\t\tused = (rule->rule_kind == CIL_AVRULE_NEVERALLOW) ?\n\t\t\tCIL_ATTR_NEVERALLOW : CIL_ATTR_AVRULE;\n\t\tcil_type_used(src_datum, used); /* src not used if tgt is self */\n\t\tcil_type_used(tgt_datum, used);\n\t}\n\n\tif (!rule->is_extended) {\n\t\trc = cil_resolve_classperms_list(current, rule->perms.classperms, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tgoto exit;\n\t\t}\n\t} else {\n\t\tif (rule->perms.x.permx_str != NULL) {\n\t\t\trc = cil_resolve_name(current, rule->perms.x.permx_str, CIL_SYM_PERMX, args, &permx_datum);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\trule->perms.x.permx = (struct cil_permissionx*)permx_datum;\n\t\t} else {\n\t\t\trc = cil_resolve_permissionx(current, rule->perms.x.permx, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\n\n\n\n\nint cil_tree_walk_core(struct cil_tree_node *node,\n\t\t\t\t\t   int (*process_node)(struct cil_tree_node *node, uint32_t *finished, void *extra_args),\n\t\t\t\t\t   int (*first_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t\t   int (*last_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t\t   void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\twhile (node) {\n\t\tuint32_t finished = CIL_TREE_SKIP_NOTHING;\n\n\t\tif (process_node != NULL) {\n\t\t\trc = (*process_node)(node, &finished, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tif (finished & CIL_TREE_SKIP_NEXT) {\n\t\t\treturn SEPOL_OK;\n\t\t}\n\n\t\tif (node->cl_head != NULL && !(finished & CIL_TREE_SKIP_HEAD)) {\n\t\t\trc = cil_tree_walk(node, process_node, first_child, last_child, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tnode = node->next;\n\t}\n\n\treturn SEPOL_OK;\n}\n\nint cil_tree_walk(struct cil_tree_node *node, \n\t\t\t\t  int (*process_node)(struct cil_tree_node *node, uint32_t *finished, void *extra_args), \n\t\t\t\t  int (*first_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t  int (*last_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t  void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\tif (!node || !node->cl_head) {\n\t\treturn SEPOL_OK;\n\t}\n\n\tif (first_child != NULL) {\n\t\trc = (*first_child)(node->cl_head, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = cil_tree_walk_core(node->cl_head, process_node, first_child, last_child, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\treturn rc;\n\t}\n\n\tif (last_child != NULL) {\n\t\trc = (*last_child)(node->cl_tail, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n}\n\nint cil_tree_walk_core(struct cil_tree_node *node,\n\t\t\t\t\t   int (*process_node)(struct cil_tree_node *node, uint32_t *finished, void *extra_args),\n\t\t\t\t\t   int (*first_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t\t   int (*last_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t\t   void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\twhile (node) {\n\t\tuint32_t finished = CIL_TREE_SKIP_NOTHING;\n\n\t\tif (process_node != NULL) {\n\t\t\trc = (*process_node)(node, &finished, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tif (finished & CIL_TREE_SKIP_NEXT) {\n\t\t\treturn SEPOL_OK;\n\t\t}\n\n\t\tif (node->cl_head != NULL && !(finished & CIL_TREE_SKIP_HEAD)) {\n\t\t\trc = cil_tree_walk(node, process_node, first_child, last_child, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tnode = node->next;\n\t}\n\n\treturn SEPOL_OK;\n}\n\nint cil_tree_walk(struct cil_tree_node *node, \n\t\t\t\t  int (*process_node)(struct cil_tree_node *node, uint32_t *finished, void *extra_args), \n\t\t\t\t  int (*first_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t  int (*last_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t  void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\tif (!node || !node->cl_head) {\n\t\treturn SEPOL_OK;\n\t}\n\n\tif (first_child != NULL) {\n\t\trc = (*first_child)(node->cl_head, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = cil_tree_walk_core(node->cl_head, process_node, first_child, last_child, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\treturn rc;\n\t}\n\n\tif (last_child != NULL) {\n\t\trc = (*last_child)(node->cl_tail, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n}\n\nint cil_tree_walk_core(struct cil_tree_node *node,\n\t\t\t\t\t   int (*process_node)(struct cil_tree_node *node, uint32_t *finished, void *extra_args),\n\t\t\t\t\t   int (*first_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t\t   int (*last_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t\t   void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\twhile (node) {\n\t\tuint32_t finished = CIL_TREE_SKIP_NOTHING;\n\n\t\tif (process_node != NULL) {\n\t\t\trc = (*process_node)(node, &finished, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tif (finished & CIL_TREE_SKIP_NEXT) {\n\t\t\treturn SEPOL_OK;\n\t\t}\n\n\t\tif (node->cl_head != NULL && !(finished & CIL_TREE_SKIP_HEAD)) {\n\t\t\trc = cil_tree_walk(node, process_node, first_child, last_child, extra_args);\n\t\t\tif (rc != SEPOL_OK) {\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tnode = node->next;\n\t}\n\n\treturn SEPOL_OK;\n}\n\nint cil_tree_walk(struct cil_tree_node *node, \n\t\t\t\t  int (*process_node)(struct cil_tree_node *node, uint32_t *finished, void *extra_args), \n\t\t\t\t  int (*first_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t  int (*last_child)(struct cil_tree_node *node, void *extra_args), \n\t\t\t\t  void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\n\tif (!node || !node->cl_head) {\n\t\treturn SEPOL_OK;\n\t}\n\n\tif (first_child != NULL) {\n\t\trc = (*first_child)(node->cl_head, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = cil_tree_walk_core(node->cl_head, process_node, first_child, last_child, extra_args);\n\tif (rc != SEPOL_OK) {\n\t\treturn rc;\n\t}\n\n\tif (last_child != NULL) {\n\t\trc = (*last_child)(node->cl_tail, extra_args);\n\t\tif (rc != SEPOL_OK) {\n\t\t\tcil_tree_log(node, CIL_INFO, \"Problem\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn SEPOL_OK;\n}\n\nint __cil_resolve_ast_last_child_helper(struct cil_tree_node *current, void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_args_resolve *args = extra_args;\n\tstruct cil_tree_node *parent = NULL;\n\tstruct cil_tree_node *blockstack = NULL;\n\n\tif (current == NULL ||  extra_args == NULL) {\n\t\tgoto exit;\n\t}\n\n\tparent = current->parent;\n\n\tif (parent->flavor == CIL_MACRO) {\n\t\targs->macro = NULL;\n\t} else if (parent->flavor == CIL_OPTIONAL) {\n\t\tstruct cil_tree_node *optstack;\n\n\t\tif (((struct cil_optional *)parent->data)->enabled == CIL_FALSE) {\n\t\t\t*(args->changed) = CIL_TRUE;\n\t\t\tcil_list_append(args->disabled_optionals, CIL_NODE, parent);\n\t\t}\n\n\t\t/* pop off the stack */\n\t\toptstack = args->optstack;\n\t\targs->optstack = optstack->cl_head;\n\t\tif (optstack->cl_head) {\n\t\t\toptstack->cl_head->parent = NULL;\n\t\t}\n\t\tfree(optstack);\n\t} else if (parent->flavor == CIL_BOOLEANIF) {\n\t\targs->boolif = NULL;\n\t} else if (parent->flavor == CIL_BLOCK) {\n\t\t/* pop off the stack */\n\t\tblockstack = args->blockstack;\n\t\targs->blockstack = blockstack->cl_head;\n\t\tif (blockstack->cl_head) {\n\t\t\tblockstack->cl_head->parent = NULL;\n\t\t}\n\t\tfree(blockstack);\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n\nint cil_compile(struct cil_db *db)\n{\n\tint rc = SEPOL_ERR;\n\n\tif (db == NULL) {\n\t\tgoto exit;\n\t}\n\n\tcil_log(CIL_INFO, \"Building AST from Parse Tree\\n\");\n\trc = cil_build_ast(db, db->parse->root, db->ast->root);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_INFO, \"Failed to build ast\\n\");\n\t\tgoto exit;\n\t}\n\n\tcil_log(CIL_INFO, \"Destroying Parse Tree\\n\");\n\tcil_tree_destroy(&db->parse);\n\n\tcil_log(CIL_INFO, \"Resolving AST\\n\");\n\trc = cil_resolve_ast(db, db->ast->root);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_INFO, \"Failed to resolve ast\\n\");\n\t\tgoto exit;\n\t}\n\n\tcil_log(CIL_INFO, \"Qualifying Names\\n\");\n\trc = cil_fqn_qualify(db->ast->root);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_INFO, \"Failed to qualify names\\n\");\n\t\tgoto exit;\n\t}\n\n\tcil_log(CIL_INFO, \"Compile post process\\n\");\n\trc = cil_post_process(db);\n\tif (rc != SEPOL_OK ) {\n\t\tcil_log(CIL_INFO, \"Post process failed\\n\");\n\t\tgoto exit;\n\t}\n\nexit:\n\n\treturn rc;\n}\n\n\n// target function\nint __cil_resolve_ast_last_child_helper(struct cil_tree_node *current, void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_args_resolve *args = extra_args;\n\tstruct cil_tree_node *parent = NULL;\n\tstruct cil_tree_node *blockstack = NULL;\n\n\tif (current == NULL ||  extra_args == NULL) {\n\t\tgoto exit;\n\t}\n\n\tparent = current->parent;\n\n\tif (parent->flavor == CIL_MACRO) {\n\t\targs->macro = NULL;\n\t} else if (parent->flavor == CIL_OPTIONAL) {\n\t\tstruct cil_tree_node *optstack;\n\n\t\tif (((struct cil_optional *)parent->data)->enabled == CIL_FALSE) {\n\t\t\t*(args->changed) = CIL_TRUE;\n\t\t\tcil_tree_children_destroy(parent);\n\t\t}\n\n\t\t/* pop off the stack */\n\t\toptstack = args->optstack;\n\t\targs->optstack = optstack->cl_head;\n\t\tif (optstack->cl_head) {\n\t\t\toptstack->cl_head->parent = NULL;\n\t\t}\n\t\tfree(optstack);\n\t} else if (parent->flavor == CIL_BOOLEANIF) {\n\t\targs->boolif = NULL;\n\t} else if (parent->flavor == CIL_BLOCK) {\n\t\t/* pop off the stack */\n\t\tblockstack = args->blockstack;\n\t\targs->blockstack = blockstack->cl_head;\n\t\tif (blockstack->cl_head) {\n\t\t\tblockstack->cl_head->parent = NULL;\n\t\t}\n\t\tfree(blockstack);\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n",
    "target": 1,
    "idx": 1028470,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "// context\nint64_t SliceTracker::GetStackHash(const SlicesStack& stack) {\n  PERFETTO_DCHECK(!stack.empty());\n\n  const auto& slices = context_->storage->slice_table();\n\n  base::Hash hash;\n  for (size_t i = 0; i < stack.size(); i++) {\n    uint32_t slice_idx = stack[i].row;\n    hash.Update(slices.category()[slice_idx].value_or(kNullStringId).raw_id());\n    hash.Update(slices.name()[slice_idx].value_or(kNullStringId).raw_id());\n  }\n\n  // For clients which don't have an integer type (i.e. Javascript), returning\n  // hashes which have the top 11 bits set leads to numbers which are\n  // unrepresenatble. This means that clients cannot filter using this number as\n  // it will be meaningless when passed back to us. For this reason, make sure\n  // that the hash is always less than 2^53 - 1.\n  constexpr uint64_t kSafeBitmask = (1ull << 53) - 1;\n  return static_cast<int64_t>(hash.digest() & kSafeBitmask);\n}\n\nbase::Optional<SliceId> SliceTracker::StartSlice(\n    int64_t timestamp,\n    TrackId track_id,\n    SetArgsCallback args_callback,\n    std::function<SliceId()> inserter) {\n  // At this stage all events should be globally timestamp ordered.\n  if (timestamp < prev_timestamp_) {\n    context_->storage->IncrementStats(stats::slice_out_of_order);\n    return base::nullopt;\n  }\n  prev_timestamp_ = timestamp;\n\n  auto* track_info = &stacks_[track_id];\n  auto* stack = &track_info->slice_stack;\n\n  if (track_info->is_legacy_unnestable) {\n    PERFETTO_DCHECK(stack->size() <= 1);\n\n    track_info->legacy_unnestable_begin_count++;\n    track_info->legacy_unnestable_last_begin_ts = timestamp;\n\n    // If this is an unnestable track, don't start a new slice if one already\n    // exists.\n    if (!stack->empty()) {\n      return base::nullopt;\n    }\n  }\n\n  auto* slices = context_->storage->mutable_slice_table();\n  MaybeCloseStack(timestamp, stack, track_id);\n\n  const uint8_t depth = static_cast<uint8_t>(stack->size());\n  if (depth >= std::numeric_limits<uint8_t>::max()) {\n    PERFETTO_DFATAL(\"Slices with too large depth found.\");\n    return base::nullopt;\n  }\n  int64_t parent_stack_id =\n      depth == 0 ? 0 : slices->stack_id()[stack->back().row];\n  base::Optional<tables::SliceTable::Id> parent_id =\n      depth == 0 ? base::nullopt\n                 : base::make_optional(slices->id()[stack->back().row]);\n\n  SliceId id = inserter();\n  uint32_t slice_idx = *slices->id().IndexOf(id);\n  StackPush(track_id, slice_idx);\n\n  // Post fill all the relevant columns. All the other columns should have\n  // been filled by the inserter.\n  slices->mutable_depth()->Set(slice_idx, depth);\n  slices->mutable_parent_stack_id()->Set(slice_idx, parent_stack_id);\n  slices->mutable_stack_id()->Set(slice_idx, GetStackHash(*stack));\n  if (parent_id)\n    slices->mutable_parent_id()->Set(slice_idx, *parent_id);\n\n  if (args_callback) {\n    ArgsTracker* tracker = &stack->back().args_tracker;\n    auto bound_inserter = tracker->AddArgsTo(id);\n    args_callback(&bound_inserter);\n  }\n  return id;\n}\n\nbase::Optional<SliceId> SliceTracker::Scoped(int64_t timestamp,\n                                             TrackId track_id,\n                                             StringId category,\n                                             StringId name,\n                                             int64_t duration,\n                                             SetArgsCallback args_callback) {\n  PERFETTO_DCHECK(duration >= 0);\n\n  tables::SliceTable::Row row(timestamp, duration, track_id, category, name);\n  return StartSlice(timestamp, track_id, args_callback, [this, &row]() {\n    return context_->storage->mutable_slice_table()->Insert(row).id;\n  });\n}\n\nvoid NinjaLogParser::NotifyEndOfFile() {\n  std::sort(jobs_.begin(), jobs_.end(),\n            [](const Job& x, const Job& y) { return x.start_ms < y.start_ms; });\n\n  // Now we need to work out the job parallelism. There's no direct indication\n  // of that in the ninja logs, so it must be inferred by observing overlapping\n  // of timestamps. In this context a \"Worker\" is an inferred sequence of jobs\n  // that happened concurrently with other sequences.\n  // Here we pack jobs according the following heuristic, for the sake of making\n  // the graph nicer to read to humans. Consider the initial situation:\n  // 1: [  job 1 ]\n  // 2:   [   job 2   ]\n  // 3: [   job 3   ]\n  //    T=0              | T=6\n  // Assume that a new job starts at T=6. It's very likely that job4 was started\n  // as a consequence of job2 completion (othewise it could have been started\n  // earlier, soon after job 1 or Job 3). It seems to make more sense to draw\n  // it next in the 2nd worker, i.e. next to job 2.\n  struct Worker {\n    int64_t busy_until;\n    TrackId track_id;\n  };\n  std::map<uint32_t /*build_id*/, std::vector<Worker>> workers_by_build;\n\n  // Assign thread ids to worker without conflicting with builds' process ids\n  // (to avoid main-thread auto-mapping).s\n  uint32_t last_worker_id = cur_build_id_;\n\n  for (const auto& job : jobs_) {\n    Worker* worker = nullptr;\n    auto& workers = workers_by_build[job.build_id];\n    for (Worker& cur : workers) {\n      // Pick the worker which has the greatest end time (busy_until) <= the\n      // job's start time.\n      if (cur.busy_until <= job.start_ms) {\n        if (!worker || cur.busy_until > worker->busy_until)\n          worker = &cur;\n      }\n    }\n    if (worker) {\n      // Update the worker's end time with the newly assigned job.\n      worker->busy_until = job.end_ms;\n    } else {\n      // All workers are busy, allocate a new one.\n      uint32_t worker_id = ++last_worker_id;\n      base::StackString<32> name(\"Worker %zu\", workers.size() + 1);\n      StringId name_id = ctx_->storage->InternString(name.string_view());\n      auto utid = ctx_->process_tracker->UpdateThread(worker_id, job.build_id);\n      ctx_->process_tracker->UpdateThreadNameByUtid(utid, name_id,\n                                                    ThreadNamePriority::kOther);\n      TrackId track_id = ctx_->track_tracker->InternThreadTrack(utid);\n      workers.emplace_back(Worker{/*busy_until=*/job.end_ms, track_id});\n      worker = &workers.back();\n    }\n\n    static constexpr int64_t kMsToNs = 1000 * 1000;\n    const int64_t start_ns = job.start_ms * kMsToNs;\n    const int64_t dur_ns = (job.end_ms - job.start_ms) * kMsToNs;\n    StringId name_id = ctx_->storage->InternString(base::StringView(job.names));\n    ctx_->slice_tracker->Scoped(start_ns, worker->track_id, StringId::Null(),\n                                name_id, dur_ns);\n  }\n}\n\nvoid ForwardingTraceParser::NotifyEndOfFile() {\n  reader_->NotifyEndOfFile();\n}\n\nvoid TraceProcessorStorageImpl::NotifyEndOfFile() {\n  if (unrecoverable_parse_error_ || !context_.chunk_reader)\n    return;\n\n  context_.chunk_reader->NotifyEndOfFile();\n  if (context_.sorter)\n    context_.sorter->ExtractEventsForced();\n  context_.event_tracker->FlushPendingEvents();\n  context_.slice_tracker->FlushPendingSlices();\n  context_.heap_profile_tracker->NotifyEndOfFile();\n  context_.process_tracker->NotifyEndOfFile();\n  for (std::unique_ptr<ProtoImporterModule>& module : context_.modules) {\n    module->NotifyEndOfFile();\n  }\n  context_.args_tracker->Flush();\n}\n\nvoid FuzzTraceProcessor(const uint8_t* data, size_t size) {\n  std::unique_ptr<TraceProcessorStorage> processor =\n      TraceProcessorStorage::CreateInstance(Config());\n  std::unique_ptr<uint8_t[]> buf(new uint8_t[size]);\n  memcpy(buf.get(), data, size);\n  util::Status status = processor->Parse(std::move(buf), size);\n  if (!status.ok())\n    return;\n  processor->NotifyEndOfFile();\n}\n\n\n// target function\n  std::pair<Value*, bool> Insert(Key key, Value value) {\n    if (PERFETTO_UNLIKELY(size_plus_tombstones_ >= load_limit_))\n      GrowAndRehash();\n    PERFETTO_DCHECK((capacity_ & (capacity_ - 1)) == 0);  // Must be a pow2.\n    const size_t key_hash = Hasher{}(key);\n    const uint8_t tag = HashToTag(key_hash);\n    const size_t kSlotNotFound = std::numeric_limits<size_t>::max();\n    size_t insertion_slot = kSlotNotFound;\n    size_t probe_len = 0;\n\n    // Start the iteration at the desired slot (key_hash % capacity_) searching\n    // either for a free slot or a tombstone. In the worst case we might end up\n    // scanning the whole array of slots. The Probe functions are guaranteed to\n    // visit all the slots within |capacity_| steps.\n    // If we find a free slot, we can stop the search immediately (a free slot\n    // acts as an \"end of chain for entries having the same hash\".\n    // If we find a tombstones (a deleted slot) we remember its position, but\n    // have to keep searching until a free slot to make sure we don't insert a\n    // duplicate key.\n    for (; probe_len < capacity_; ++probe_len) {\n      const size_t idx = Probe::Calc(key_hash, probe_len, capacity_);\n      PERFETTO_DCHECK(idx < capacity_);\n      const uint8_t tag_idx = tags_[idx];\n      if (tag_idx == kFreeSlot) {\n        // Rationale for \"insertion_slot == kSlotNotFound\": if we encountered\n        // a tombstone while iterating we should much rather reuse that,\n        // rather then expanding the probing length and taking another slot.\n        if (AppendOnly || insertion_slot == kSlotNotFound)\n          insertion_slot = idx;\n        break;\n      }\n      // We should never encounter tombstones in AppendOnly mode.\n      PERFETTO_DCHECK(!(tag_idx == kTombstone && AppendOnly));\n      if (!AppendOnly && tag_idx == kTombstone) {\n        insertion_slot = idx;\n        continue;\n      }\n      if (tag_idx == tag && keys_[idx] == key) {\n        // The key is already in the map.\n        return std::make_pair(&values_[idx], false);\n      }\n    }  // for (idx)\n\n    // We should never run out of slots.\n    PERFETTO_CHECK(insertion_slot < capacity_);\n\n    // We found a free slot (or a tombstone). Proceed with the insertion.\n    Value* value_idx = &values_[insertion_slot];\n    new (&keys_[insertion_slot]) Key(std::move(key));\n    new (value_idx) Value(std::move(value));\n    tags_[insertion_slot] = tag;\n    max_probe_length_ = std::max(max_probe_length_, probe_len + 1);\n    size_++;\n    size_plus_tombstones_++;\n    return std::make_pair(value_idx, true);\n  }\n  bool Erase(const Key& key) {\n    if (AppendOnly)\n      PERFETTO_FATAL(\"Erase() not supported because AppendOnly=true\");\n    size_t idx = FindInternal(key);\n    if (idx == kNotFound)\n      return false;\n    EraseInternal(idx);\n    return true;\n  }\n  void Clear() {\n    for (size_t i = 0; i < capacity_; ++i) {\n      const uint8_t tag = tags_[i];\n      if (tag != kFreeSlot && tag != kTombstone)\n        EraseInternal(i);\n    }\n    // Clear all tombstones. We really need to do this for AppendOnly.\n    GrowAndRehash();\n  }\n  void set_load_limit_pct(int percent) {\n    PERFETTO_CHECK(percent > 0 && percent <= 100);\n    load_limit_percent_ = percent;\n  }\n  size_t FindInternal(const Key& key) const {\n    const size_t key_hash = Hasher{}(key);\n    const uint8_t tag = HashToTag(key_hash);\n    PERFETTO_DCHECK((capacity_ & (capacity_ - 1)) == 0);  // Must be a pow2.\n    PERFETTO_DCHECK(max_probe_length_ <= capacity_);\n    for (size_t i = 0; i < max_probe_length_; ++i) {\n      const size_t idx = Probe::Calc(key_hash, i, capacity_);\n      const uint8_t tag_idx = tags_[idx];\n\n      if (tag_idx == kFreeSlot)\n        return kNotFound;\n      // HashToTag() never returns kTombstone, so the tag-check below cannot\n      // possibly match. Also we just want to skip tombstones.\n      if (tag_idx == tag && keys_[idx] == key) {\n        PERFETTO_DCHECK(tag_idx > kTombstone);\n        return idx;\n      }\n    }  // for (idx)\n    return kNotFound;\n  }\n  PERFETTO_NO_INLINE void GrowAndRehash() {\n    PERFETTO_DCHECK(size_ <= size_plus_tombstones_);\n    PERFETTO_DCHECK(size_plus_tombstones_ <= capacity_);\n    const size_t old_capacity = capacity_;\n    size_t new_capacity = std::max(old_capacity, size_t(1024));\n    size_t old_size_mb = old_capacity * (sizeof(Key) + sizeof(Value));\n\n    // Grow quickly up to 1MB, then chill.\n    if (size_ < load_limit_) {\n      // If we have a lot of tombstones, don't grow at all, just rehash. The\n      // re-hasing loop will remove the tombstones and repack the slots.\n    } else if (old_size_mb < 1 * 1024 * 1024) {\n      new_capacity *= 8;\n    } else {\n      new_capacity *= 2;\n    }\n    auto old_tags(std::move(tags_));\n    auto old_keys(std::move(keys_));\n    auto old_values(std::move(values_));\n    size_t old_size = size_;\n\n    // This must be a CHECK (i.e. not just a DCHECK) to prevent UAF attacks on\n    // 32-bit archs that try to double the size of the table until wrapping.\n    PERFETTO_CHECK(new_capacity >= old_capacity);\n    Reset(new_capacity);\n\n    size_t new_size = 0;  // Recompute the size.\n    for (size_t i = 0; i < old_capacity; ++i) {\n      const uint8_t old_tag = old_tags[i];\n      if (old_tag != kFreeSlot && old_tag != kTombstone) {\n        Insert(std::move(old_keys[i]), std::move(old_values[i]));\n        old_keys[i].~Key();  // Destroy the old objects.\n        old_values[i].~Value();\n        new_size++;\n      }\n    }\n    PERFETTO_DCHECK(new_size == old_size);\n    size_ = size_plus_tombstones_ = new_size;\n  }\n  PERFETTO_NO_INLINE void Reset(size_t n) {\n    PERFETTO_DCHECK((n & (n - 1)) == 0);  // Must be a pow2.\n\n    capacity_ = n;\n    max_probe_length_ = 0;\n    size_ = 0;\n    size_plus_tombstones_ = 0;\n    load_limit_ = n * static_cast<size_t>(load_limit_percent_) / 100;\n    load_limit_ = std::min(load_limit_, n);\n\n    tags_.reset(new uint8_t[n]);\n    memset(&tags_[0], 0, n);                  // Clear all tags.\n    keys_ = AlignedAllocTyped<Key[]>(n);      // Deliberately not 0-initialized.\n    values_ = AlignedAllocTyped<Value[]>(n);  // Deliberately not 0-initialized.\n  }\n  static inline uint8_t HashToTag(size_t full_hash) {\n    uint8_t tag = full_hash >> (sizeof(full_hash) * 8 - 8);\n    // Ensure the hash is always >= 2. We use 0, 1 for kFreeSlot and kTombstone.\n    tag += (tag <= kTombstone) << 1;\n    PERFETTO_DCHECK(tag > kTombstone);\n    return tag;\n  }\nTYPED_TEST(FlatHashMapTest, VsUnorderedMap) {\n  std::unordered_map<int, int, CollidingHasher> umap;\n  FlatHashMap<int, int, CollidingHasher, typename TestFixture::Probe> fmap;\n  std::minstd_rand0 rng(0);\n\n  for (int rep = 0; rep < 2; rep++) {\n    std::set<int> keys_copy;\n    const int kRange = 1024;\n\n    // Insert some random elements.\n    for (int i = 0; i < kRange; i++) {\n      int key = static_cast<int>(rng());\n      keys_copy.insert(key);\n      int value = key * 2;\n      auto it_and_inserted_u = umap.insert({key, value});\n      auto it_and_inserted_f = fmap.Insert(key, value);\n      ASSERT_EQ(it_and_inserted_u.second, it_and_inserted_f.second);\n      ASSERT_EQ(*it_and_inserted_f.first, value);\n      ASSERT_EQ(umap.size(), fmap.size());\n      int* res = fmap.Find(key);\n      ASSERT_NE(res, nullptr);\n      ASSERT_EQ(*res, value);\n      ASSERT_EQ(fmap[key], value);  // Test that operator[] behaves like Find().\n    }\n    // Look them up.\n    for (int key : keys_copy) {\n      int* res = fmap.Find(key);\n      ASSERT_NE(res, nullptr);\n      ASSERT_EQ(*res, key * 2);\n      ASSERT_EQ(umap.size(), fmap.size());\n    }\n\n    // Some further deletions / insertions / reinsertions.\n    for (int key : keys_copy) {\n      auto op = rng() % 4;\n\n      if (op < 2) {\n        // With a 50% chance, erase the key.\n        bool erased_u = umap.erase(key) > 0;\n        bool erased_f = fmap.Erase(key);\n        ASSERT_EQ(erased_u, erased_f);\n      } else if (op == 3) {\n        // With a 25% chance, re-insert the same key (should fail).\n        umap.insert({key, 0});\n        ASSERT_FALSE(fmap.Insert(key, 0).second);\n      } else {\n        // With a 25% chance, insert a new key.\n        umap.insert({key + kRange, (key + kRange) * 2});\n        ASSERT_TRUE(fmap.Insert(key + kRange, (key + kRange) * 2).second);\n      }\n\n      ASSERT_EQ(umap.size(), fmap.size());\n    }\n\n    // Re-look up keys. Note some of them might be deleted by the loop above.\n    for (int k : keys_copy) {\n      for (int i = 0; i < 2; i++) {\n        const int key = k + kRange * i;\n        int* res = fmap.Find(key);\n        if (umap.count(key)) {\n          ASSERT_NE(res, nullptr);\n          ASSERT_EQ(*res, key * 2);\n        } else {\n          ASSERT_EQ(res, nullptr);\n        }\n      }\n    }\n\n    fmap.Clear();\n    umap.clear();\n    ASSERT_EQ(fmap.size(), 0u);\n\n    for (int key : keys_copy)\n      ASSERT_EQ(fmap.Find(key), nullptr);\n  }\n}\n",
    "target": 1,
    "idx": 1041226,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "// context\nPHPAPI bool php_date_initialize(php_date_obj *dateobj, const char *time_str, size_t time_str_len, const char *format, zval *timezone_object, int flags) /* {{{ */\n{\n\ttimelib_time   *now;\n\ttimelib_tzinfo *tzi = NULL;\n\ttimelib_error_container *err = NULL;\n\tint type = TIMELIB_ZONETYPE_ID, new_dst = 0;\n\tchar *new_abbr = NULL;\n\ttimelib_sll new_offset = 0;\n\ttime_t sec;\n\tsuseconds_t usec;\n\tint options = 0;\n\n\tif (dateobj->time) {\n\t\ttimelib_time_dtor(dateobj->time);\n\t}\n\tif (format) {\n\t\tif (time_str_len == 0) {\n\t\t\ttime_str = \"\";\n\t\t}\n\t\tdateobj->time = timelib_parse_from_format(format, time_str, time_str_len, &err, DATE_TIMEZONEDB, php_date_parse_tzfile_wrapper);\n\t} else {\n\t\tif (time_str_len == 0) {\n\t\t\ttime_str = \"now\";\n\t\t\ttime_str_len = sizeof(\"now\") - 1;\n\t\t}\n\t\tdateobj->time = timelib_strtotime(time_str, time_str_len, &err, DATE_TIMEZONEDB, php_date_parse_tzfile_wrapper);\n\t}\n\n\t/* update last errors and warnings */\n\terr = update_errors_warnings(&err);\n\n\t/* If called from a constructor throw an exception */\n\tif ((flags & PHP_DATE_INIT_CTOR) && err && err->error_count) {\n\t\t/* spit out the first library error message, at least */\n\t\tzend_throw_exception_ex(NULL, 0, \"Failed to parse time string (%s) at position %d (%c): %s\", time_str,\n\t\t\terr->error_messages[0].position, err->error_messages[0].character, err->error_messages[0].message);\n\t}\n\tif (err && err->error_count) {\n\t\ttimelib_time_dtor(dateobj->time);\n\t\tdateobj->time = 0;\n\t\treturn 0;\n\t}\n\n\tif (timezone_object) {\n\t\tphp_timezone_obj *tzobj;\n\n\t\ttzobj = Z_PHPTIMEZONE_P(timezone_object);\n\t\tswitch (tzobj->type) {\n\t\t\tcase TIMELIB_ZONETYPE_ID:\n\t\t\t\ttzi = tzobj->tzi.tz;\n\t\t\t\tbreak;\n\t\t\tcase TIMELIB_ZONETYPE_OFFSET:\n\t\t\t\tnew_offset = tzobj->tzi.utc_offset;\n\t\t\t\tbreak;\n\t\t\tcase TIMELIB_ZONETYPE_ABBR:\n\t\t\t\tnew_offset = tzobj->tzi.z.utc_offset;\n\t\t\t\tnew_dst    = tzobj->tzi.z.dst;\n\t\t\t\tnew_abbr   = timelib_strdup(tzobj->tzi.z.abbr);\n\t\t\t\tbreak;\n\t\t}\n\t\ttype = tzobj->type;\n\t} else if (dateobj->time->tz_info) {\n\t\ttzi = dateobj->time->tz_info;\n\t} else {\n\t\ttzi = get_timezone_info();\n\t\tif (!tzi) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tnow = timelib_time_ctor();\n\tnow->zone_type = type;\n\tswitch (type) {\n\t\tcase TIMELIB_ZONETYPE_ID:\n\t\t\tnow->tz_info = tzi;\n\t\t\tbreak;\n\t\tcase TIMELIB_ZONETYPE_OFFSET:\n\t\t\tnow->z = new_offset;\n\t\t\tbreak;\n\t\tcase TIMELIB_ZONETYPE_ABBR:\n\t\t\tnow->z = new_offset;\n\t\t\tnow->dst = new_dst;\n\t\t\tnow->tz_abbr = new_abbr;\n\t\t\tbreak;\n\t}\n\tphp_date_get_current_time_with_fraction(&sec, &usec);\n\ttimelib_unixtime2local(now, (timelib_sll) sec);\n\tphp_date_set_time_fraction(now, usec);\n\n\tif (!format\n\t && time_str_len == sizeof(\"now\") - 1\n\t && memcmp(time_str, \"now\", sizeof(\"now\") - 1) == 0) {\n\t\ttimelib_time_dtor(dateobj->time);\n\t\tdateobj->time = now;\n\t\treturn 1;\n\t}\n\n\toptions = TIMELIB_NO_CLONE;\n\tif (flags & PHP_DATE_INIT_FORMAT) {\n\t\toptions |= TIMELIB_OVERRIDE_TIME;\n\t}\n\ttimelib_fill_holes(dateobj->time, now, options);\n\n\ttimelib_update_ts(dateobj->time, tzi);\n\ttimelib_update_from_sse(dateobj->time);\n\n\tdateobj->time->have_relative = 0;\n\n\ttimelib_time_dtor(now);\n\n\treturn 1;\n} /* }}} */\n\n\n\nZEND_API void execute_internal(zend_execute_data *execute_data, zval *return_value)\n{\n\texecute_data->func->internal_function.handler(execute_data, return_value);\n}\n\nstatic void fuzzer_execute_internal(zend_execute_data *execute_data, zval *return_value) {\n\tfuzzer_step();\n\n\tuint32_t num_args = ZEND_CALL_NUM_ARGS(execute_data);\n\tfor (uint32_t i = 0; i < num_args; i++) {\n\t\t/* Some internal functions like preg_replace() may be slow on large inputs.\n\t\t * Limit the maximum size of string inputs. */\n\t\tzval *arg = ZEND_CALL_VAR_NUM(execute_data, i);\n\t\tif (Z_TYPE_P(arg) == IS_STRING && Z_STRLEN_P(arg) > MAX_SIZE) {\n\t\t\tfuzzer_bailout();\n\t\t}\n\t}\n\n\torig_execute_internal(execute_data, return_value);\n}\n\nstatic void fuzzer_execute_ex(zend_execute_data *execute_data) {\n\twhile (1) {\n\t\tint ret;\n\t\tfuzzer_step();\n\t\tif ((ret = ((opcode_handler_t) EX(opline)->handler)(execute_data)) != 0) {\n\t\t\tif (ret > 0) {\n\t\t\t\texecute_data = EG(current_execute_data);\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\nZEND_API void zend_execute(zend_op_array *op_array, zval *return_value)\n{\n\tzend_execute_data *execute_data;\n\tvoid *object_or_called_scope;\n\tuint32_t call_info;\n\n\tif (EG(exception) != NULL) {\n\t\treturn;\n\t}\n\n\tobject_or_called_scope = zend_get_this_object(EG(current_execute_data));\n\tif (EXPECTED(!object_or_called_scope)) {\n\t\tobject_or_called_scope = zend_get_called_scope(EG(current_execute_data));\n\t\tcall_info = ZEND_CALL_TOP_CODE | ZEND_CALL_HAS_SYMBOL_TABLE;\n\t} else {\n\t\tcall_info = ZEND_CALL_TOP_CODE | ZEND_CALL_HAS_SYMBOL_TABLE | ZEND_CALL_HAS_THIS;\n\t}\n\texecute_data = zend_vm_stack_push_call_frame(call_info,\n\t\t(zend_function*)op_array, 0, object_or_called_scope);\n\tif (EG(current_execute_data)) {\n\t\texecute_data->symbol_table = zend_rebuild_symbol_table();\n\t} else {\n\t\texecute_data->symbol_table = &EG(symbol_table);\n\t}\n\tEX(prev_execute_data) = EG(current_execute_data);\n\ti_init_code_execute_data(execute_data, op_array, return_value);\n\tZEND_OBSERVER_FCALL_BEGIN(execute_data);\n\tzend_execute_ex(execute_data);\n\t/* Observer end handlers are called from ZEND_RETURN */\n\tzend_vm_stack_free_call_frame(execute_data);\n}\n\nint fuzzer_do_request_from_buffer(\n\t\tchar *filename, const char *data, size_t data_len, bool execute,\n\t\tvoid (*before_shutdown)(void))\n{\n\tint retval = FAILURE; /* failure by default */\n\n\tSG(options) |= SAPI_OPTION_NO_CHDIR;\n\tSG(request_info).argc=0;\n\tSG(request_info).argv=NULL;\n\n\tif (fuzzer_request_startup() == FAILURE) {\n\t\treturn FAILURE;\n\t}\n\n\t// Commented out to avoid leaking the header callback.\n\t//SG(headers_sent) = 1;\n\t//SG(request_info).no_headers = 1;\n\tphp_register_variable(\"PHP_SELF\", filename, NULL);\n\n\tzend_first_try {\n\t\tzend_file_handle file_handle;\n\t\tzend_stream_init_filename(&file_handle, filename);\n\t\tfile_handle.primary_script = 1;\n\t\tfile_handle.buf = estrndup(data, data_len);\n\t\tfile_handle.len = data_len;\n\t\t/* Avoid ZEND_HANDLE_FILENAME for opcache. */\n\t\tfile_handle.type = ZEND_HANDLE_STREAM;\n\n\t\tzend_op_array *op_array = zend_compile_file(&file_handle, ZEND_REQUIRE);\n\t\tzend_destroy_file_handle(&file_handle);\n\t\tif (op_array) {\n\t\t\tif (execute) {\n\t\t\t\tzend_execute(op_array, NULL);\n\t\t\t}\n\t\t\tzend_destroy_static_vars(op_array);\n\t\t\tdestroy_op_array(op_array);\n\t\t\tefree(op_array);\n\t\t}\n\t} zend_end_try();\n\n\n// target function\nstatic void update_errors_warnings(timelib_error_container *last_errors) /* {{{ */\n{\n\tif (DATEG(last_errors)) {\n\t\ttimelib_error_container_dtor(DATEG(last_errors));\n\t\tDATEG(last_errors) = NULL;\n\t}\n\tif (last_errors->warning_count || last_errors->error_count) {\n\t\tDATEG(last_errors) = last_errors;\n\t} else {\n\t\ttimelib_error_container_dtor(last_errors);\n\t}\n} /* }}} */\nstatic void php_date_set_time_fraction(timelib_time *time, int microseconds)\n{\n\ttime->us = microseconds;\n}\nPHPAPI bool php_date_initialize(php_date_obj *dateobj, const char *time_str, size_t time_str_len, const char *format, zval *timezone_object, int flags) /* {{{ */\n{\n\ttimelib_time   *now;\n\ttimelib_tzinfo *tzi = NULL;\n\ttimelib_error_container *err = NULL;\n\tint type = TIMELIB_ZONETYPE_ID, new_dst = 0;\n\tchar *new_abbr = NULL;\n\ttimelib_sll new_offset = 0;\n\ttime_t sec;\n\tsuseconds_t usec;\n\tint options = 0;\n\n\tif (dateobj->time) {\n\t\ttimelib_time_dtor(dateobj->time);\n\t}\n\tif (format) {\n\t\tif (time_str_len == 0) {\n\t\t\ttime_str = \"\";\n\t\t}\n\t\tdateobj->time = timelib_parse_from_format(format, time_str, time_str_len, &err, DATE_TIMEZONEDB, php_date_parse_tzfile_wrapper);\n\t} else {\n\t\tif (time_str_len == 0) {\n\t\t\ttime_str = \"now\";\n\t\t\ttime_str_len = sizeof(\"now\") - 1;\n\t\t}\n\t\tdateobj->time = timelib_strtotime(time_str, time_str_len, &err, DATE_TIMEZONEDB, php_date_parse_tzfile_wrapper);\n\t}\n\n\t/* update last errors and warnings */\n\tupdate_errors_warnings(err);\n\n\t/* If called from a constructor throw an exception */\n\tif ((flags & PHP_DATE_INIT_CTOR) && err && err->error_count) {\n\t\t/* spit out the first library error message, at least */\n\t\tzend_throw_exception_ex(NULL, 0, \"Failed to parse time string (%s) at position %d (%c): %s\", time_str,\n\t\t\terr->error_messages[0].position, err->error_messages[0].character, err->error_messages[0].message);\n\t}\n\tif (err && err->error_count) {\n\t\ttimelib_time_dtor(dateobj->time);\n\t\tdateobj->time = 0;\n\t\treturn 0;\n\t}\n\n\tif (timezone_object) {\n\t\tphp_timezone_obj *tzobj;\n\n\t\ttzobj = Z_PHPTIMEZONE_P(timezone_object);\n\t\tswitch (tzobj->type) {\n\t\t\tcase TIMELIB_ZONETYPE_ID:\n\t\t\t\ttzi = tzobj->tzi.tz;\n\t\t\t\tbreak;\n\t\t\tcase TIMELIB_ZONETYPE_OFFSET:\n\t\t\t\tnew_offset = tzobj->tzi.utc_offset;\n\t\t\t\tbreak;\n\t\t\tcase TIMELIB_ZONETYPE_ABBR:\n\t\t\t\tnew_offset = tzobj->tzi.z.utc_offset;\n\t\t\t\tnew_dst    = tzobj->tzi.z.dst;\n\t\t\t\tnew_abbr   = timelib_strdup(tzobj->tzi.z.abbr);\n\t\t\t\tbreak;\n\t\t}\n\t\ttype = tzobj->type;\n\t} else if (dateobj->time->tz_info) {\n\t\ttzi = dateobj->time->tz_info;\n\t} else {\n\t\ttzi = get_timezone_info();\n\t\tif (!tzi) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tnow = timelib_time_ctor();\n\tnow->zone_type = type;\n\tswitch (type) {\n\t\tcase TIMELIB_ZONETYPE_ID:\n\t\t\tnow->tz_info = tzi;\n\t\t\tbreak;\n\t\tcase TIMELIB_ZONETYPE_OFFSET:\n\t\t\tnow->z = new_offset;\n\t\t\tbreak;\n\t\tcase TIMELIB_ZONETYPE_ABBR:\n\t\t\tnow->z = new_offset;\n\t\t\tnow->dst = new_dst;\n\t\t\tnow->tz_abbr = new_abbr;\n\t\t\tbreak;\n\t}\n\tphp_date_get_current_time_with_fraction(&sec, &usec);\n\ttimelib_unixtime2local(now, (timelib_sll) sec);\n\tphp_date_set_time_fraction(now, usec);\n\n\tif (!format\n\t && time_str_len == sizeof(\"now\") - 1\n\t && memcmp(time_str, \"now\", sizeof(\"now\") - 1) == 0) {\n\t\ttimelib_time_dtor(dateobj->time);\n\t\tdateobj->time = now;\n\t\treturn 1;\n\t}\n\n\toptions = TIMELIB_NO_CLONE;\n\tif (flags & PHP_DATE_INIT_FORMAT) {\n\t\toptions |= TIMELIB_OVERRIDE_TIME;\n\t}\n\ttimelib_fill_holes(dateobj->time, now, options);\n\n\ttimelib_update_ts(dateobj->time, tzi);\n\ttimelib_update_from_sse(dateobj->time);\n\n\tdateobj->time->have_relative = 0;\n\n\ttimelib_time_dtor(now);\n\n\treturn 1;\n} /* }}} */\nstatic bool php_date_modify(zval *object, char *modify, size_t modify_len) /* {{{ */\n{\n\tphp_date_obj *dateobj;\n\ttimelib_time *tmp_time;\n\ttimelib_error_container *err = NULL;\n\n\tdateobj = Z_PHPDATE_P(object);\n\n\tif (!(dateobj->time)) {\n\t\tzend_throw_error(NULL, \"The DateTime object has not been correctly initialized by its constructor\");\n\t\treturn 0;\n\t}\n\n\ttmp_time = timelib_strtotime(modify, modify_len, &err, DATE_TIMEZONEDB, php_date_parse_tzfile_wrapper);\n\n\t/* update last errors and warnings */\n\tupdate_errors_warnings(err);\n\tif (err && err->error_count) {\n\t\t/* spit out the first library error message, at least */\n\t\tphp_error_docref(NULL, E_WARNING, \"Failed to parse time string (%s) at position %d (%c): %s\", modify,\n\t\t\terr->error_messages[0].position, err->error_messages[0].character, err->error_messages[0].message);\n\t\ttimelib_time_dtor(tmp_time);\n\t\treturn 0;\n\t}\n\n\tmemcpy(&dateobj->time->relative, &tmp_time->relative, sizeof(timelib_rel_time));\n\tdateobj->time->have_relative = tmp_time->have_relative;\n\tdateobj->time->sse_uptodate = 0;\n\n\tif (tmp_time->y != -99999) {\n\t\tdateobj->time->y = tmp_time->y;\n\t}\n\tif (tmp_time->m != -99999) {\n\t\tdateobj->time->m = tmp_time->m;\n\t}\n\tif (tmp_time->d != -99999) {\n\t\tdateobj->time->d = tmp_time->d;\n\t}\n\n\tif (tmp_time->h != -99999) {\n\t\tdateobj->time->h = tmp_time->h;\n\t\tif (tmp_time->i != -99999) {\n\t\t\tdateobj->time->i = tmp_time->i;\n\t\t\tif (tmp_time->s != -99999) {\n\t\t\t\tdateobj->time->s = tmp_time->s;\n\t\t\t} else {\n\t\t\t\tdateobj->time->s = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tdateobj->time->i = 0;\n\t\t\tdateobj->time->s = 0;\n\t\t}\n\t}\n\n\tif (tmp_time->us != -99999) {\n\t\tdateobj->time->us = tmp_time->us;\n\t}\n\n\ttimelib_time_dtor(tmp_time);\n\n\ttimelib_update_ts(dateobj->time, NULL);\n\ttimelib_update_from_sse(dateobj->time);\n\tdateobj->time->have_relative = 0;\n\tmemset(&dateobj->time->relative, 0, sizeof(dateobj->time->relative));\n\n\treturn 1;\n} /* }}} */\n",
    "target": 1,
    "idx": 1050773,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic int\nparse_odp_action(const char *s, const struct simap *port_names,\n                 struct ofpbuf *actions)\n{\n    {\n        uint32_t port;\n        int n;\n\n        if (ovs_scan(s, \"%\"SCNi32\"%n\", &port, &n)) {\n            nl_msg_put_u32(actions, OVS_ACTION_ATTR_OUTPUT, port);\n            return n;\n        }\n    }\n\n    {\n        uint32_t max_len;\n        int n;\n\n        if (ovs_scan(s, \"trunc(%\"SCNi32\")%n\", &max_len, &n)) {\n            struct ovs_action_trunc *trunc;\n\n            trunc = nl_msg_put_unspec_uninit(actions,\n                     OVS_ACTION_ATTR_TRUNC, sizeof *trunc);\n            trunc->max_len = max_len;\n            return n;\n        }\n    }\n\n    if (port_names) {\n        int len = strcspn(s, delimiters);\n        struct simap_node *node;\n\n        node = simap_find_len(port_names, s, len);\n        if (node) {\n            nl_msg_put_u32(actions, OVS_ACTION_ATTR_OUTPUT, node->data);\n            return len;\n        }\n    }\n\n    {\n        uint32_t recirc_id;\n        int n = -1;\n\n        if (ovs_scan(s, \"recirc(%\"PRIu32\")%n\", &recirc_id, &n)) {\n            nl_msg_put_u32(actions, OVS_ACTION_ATTR_RECIRC, recirc_id);\n            return n;\n        }\n    }\n\n    if (!strncmp(s, \"userspace(\", 10)) {\n        return parse_odp_userspace_action(s, actions);\n    }\n\n    if (!strncmp(s, \"set(\", 4)) {\n        size_t start_ofs;\n        int retval;\n        struct nlattr mask[1024 / sizeof(struct nlattr)];\n        struct ofpbuf maskbuf = OFPBUF_STUB_INITIALIZER(mask);\n        struct nlattr *nested, *key;\n        size_t size;\n\n        start_ofs = nl_msg_start_nested(actions, OVS_ACTION_ATTR_SET);\n        retval = parse_odp_key_mask_attr(s + 4, port_names, actions, &maskbuf);\n        if (retval < 0) {\n            ofpbuf_uninit(&maskbuf);\n            return retval;\n        }\n        if (s[retval + 4] != ')') {\n            ofpbuf_uninit(&maskbuf);\n            return -EINVAL;\n        }\n\n        nested = ofpbuf_at_assert(actions, start_ofs, sizeof *nested);\n        key = nested + 1;\n\n        size = nl_attr_get_size(mask);\n        if (size == nl_attr_get_size(key)) {\n            /* Change to masked set action if not fully masked. */\n            if (!is_all_ones(mask + 1, size)) {\n                /* Remove padding of eariler key payload  */\n                actions->size -= NLA_ALIGN(key->nla_len) - key->nla_len;\n\n                /* Put mask payload right after key payload */\n                key->nla_len += size;\n                ofpbuf_put(actions, mask + 1, size);\n\n                /* 'actions' may have been reallocated by ofpbuf_put(). */\n                nested = ofpbuf_at_assert(actions, start_ofs, sizeof *nested);\n                nested->nla_type = OVS_ACTION_ATTR_SET_MASKED;\n\n                key = nested + 1;\n                /* Add new padding as needed */\n                ofpbuf_put_zeros(actions, NLA_ALIGN(key->nla_len) -\n                                          key->nla_len);\n            }\n        }\n        ofpbuf_uninit(&maskbuf);\n\n        nl_msg_end_nested(actions, start_ofs);\n        return retval + 5;\n    }\n\n    {\n        struct ovs_action_push_vlan push;\n        int tpid = ETH_TYPE_VLAN;\n        int vid, pcp;\n        int cfi = 1;\n        int n = -1;\n\n        if (ovs_scan(s, \"push_vlan(vid=%i,pcp=%i)%n\", &vid, &pcp, &n)\n            || ovs_scan(s, \"push_vlan(vid=%i,pcp=%i,cfi=%i)%n\",\n                        &vid, &pcp, &cfi, &n)\n            || ovs_scan(s, \"push_vlan(tpid=%i,vid=%i,pcp=%i)%n\",\n                        &tpid, &vid, &pcp, &n)\n            || ovs_scan(s, \"push_vlan(tpid=%i,vid=%i,pcp=%i,cfi=%i)%n\",\n                        &tpid, &vid, &pcp, &cfi, &n)) {\n            push.vlan_tpid = htons(tpid);\n            push.vlan_tci = htons((vid << VLAN_VID_SHIFT)\n                                  | (pcp << VLAN_PCP_SHIFT)\n                                  | (cfi ? VLAN_CFI : 0));\n            nl_msg_put_unspec(actions, OVS_ACTION_ATTR_PUSH_VLAN,\n                              &push, sizeof push);\n\n            return n;\n        }\n    }\n\n    if (!strncmp(s, \"pop_vlan\", 8)) {\n        nl_msg_put_flag(actions, OVS_ACTION_ATTR_POP_VLAN);\n        return 8;\n    }\n\n    {\n        unsigned long long int meter_id;\n        int n = -1;\n\n        if (sscanf(s, \"meter(%lli)%n\", &meter_id, &n) > 0 && n > 0) {\n            nl_msg_put_u32(actions, OVS_ACTION_ATTR_METER, meter_id);\n            return n;\n        }\n    }\n\n    {\n        double percentage;\n        int n = -1;\n\n        if (ovs_scan(s, \"sample(sample=%lf%%,actions(%n\", &percentage, &n)\n            && percentage >= 0. && percentage <= 100.0) {\n            size_t sample_ofs, actions_ofs;\n            double probability;\n\n            probability = floor(UINT32_MAX * (percentage / 100.0) + .5);\n            sample_ofs = nl_msg_start_nested(actions, OVS_ACTION_ATTR_SAMPLE);\n            nl_msg_put_u32(actions, OVS_SAMPLE_ATTR_PROBABILITY,\n                           (probability <= 0 ? 0\n                            : probability >= UINT32_MAX ? UINT32_MAX\n                            : probability));\n\n            actions_ofs = nl_msg_start_nested(actions,\n                                              OVS_SAMPLE_ATTR_ACTIONS);\n            int retval = parse_action_list(s + n, port_names, actions);\n            if (retval < 0)\n                return retval;\n\n            n += retval;\n            nl_msg_end_nested(actions, actions_ofs);\n            nl_msg_end_nested(actions, sample_ofs);\n\n            return s[n + 1] == ')' ? n + 2 : -EINVAL;\n        }\n    }\n\n    {\n        if (!strncmp(s, \"clone(\", 6)) {\n            size_t actions_ofs;\n            int n = 6;\n\n            actions_ofs = nl_msg_start_nested(actions, OVS_ACTION_ATTR_CLONE);\n            int retval = parse_action_list(s + n, port_names, actions);\n            if (retval < 0) {\n                return retval;\n            }\n            n += retval;\n            nl_msg_end_nested(actions, actions_ofs);\n            return n + 1;\n        }\n    }\n\n    {\n        if (!strncmp(s, \"push_nsh(\", 9)) {\n            int retval = parse_odp_push_nsh_action(s, actions);\n            if (retval < 0) {\n                return retval;\n            }\n            return retval + 1;\n        }\n    }\n\n    {\n        int n;\n        if (ovs_scan(s, \"pop_nsh()%n\", &n)) {\n            nl_msg_put_flag(actions, OVS_ACTION_ATTR_POP_NSH);\n            return n;\n        }\n    }\n\n    {\n        uint32_t port;\n        int n;\n\n        if (ovs_scan(s, \"tnl_pop(%\"SCNi32\")%n\", &port, &n)) {\n            nl_msg_put_u32(actions, OVS_ACTION_ATTR_TUNNEL_POP, port);\n            return n;\n        }\n    }\n\n    {\n        if (!strncmp(s, \"ct_clear\", 8)) {\n            nl_msg_put_flag(actions, OVS_ACTION_ATTR_CT_CLEAR);\n            return 8;\n        }\n    }\n\n    {\n        int retval;\n\n        retval = parse_conntrack_action(s, actions);\n        if (retval) {\n            return retval;\n        }\n    }\n\n    {\n        struct ovs_action_push_tnl data;\n        int n;\n\n        n = ovs_parse_tnl_push(s, &data);\n        if (n > 0) {\n            odp_put_tnl_push_action(actions, &data);\n            return n;\n        } else if (n < 0) {\n            return n;\n        }\n    }\n    return -EINVAL;\n}\n\nint\nodp_actions_from_string(const char *s, const struct simap *port_names,\n                        struct ofpbuf *actions)\n{\n    size_t old_size;\n\n    if (!strcasecmp(s, \"drop\")) {\n        return 0;\n    }\n\n    old_size = actions->size;\n    for (;;) {\n        int retval;\n\n        s += strspn(s, delimiters);\n        if (!*s) {\n            return 0;\n        }\n\n        retval = parse_odp_action(s, port_names, actions);\n        if (retval < 0 || !strchr(delimiters, s[retval])) {\n            actions->size = old_size;\n            return -retval;\n        }\n        s += retval;\n    }\n\n    return 0;\n}\n\nstatic int\nparse_actions(const char *in)\n{\n    struct ofpbuf odp_actions;\n    struct ds out;\n    int error;\n\n    /* Convert string to OVS DP actions. */\n    ofpbuf_init(&odp_actions, 0);\n    error = odp_actions_from_string(in, NULL, &odp_actions);\n    if (error) {\n        printf(\"odp_actions_from_string: error\\n\");\n        goto next;\n    }\n\n    /* Convert odp_actions back to string. */\n    ds_init(&out);\n    format_odp_actions(&out, odp_actions.data, odp_actions.size, NULL);\n    puts(ds_cstr(&out));\n    ds_destroy(&out);\n\nnext:\n    ofpbuf_uninit(&odp_actions);\n    return 0;\n}\n\n\n// target function\nstatic int\nparse_odp_action(const char *s, const struct simap *port_names,\n                 struct ofpbuf *actions)\n{\n    {\n        uint32_t port;\n        int n;\n\n        if (ovs_scan(s, \"%\"SCNi32\"%n\", &port, &n)) {\n            nl_msg_put_u32(actions, OVS_ACTION_ATTR_OUTPUT, port);\n            return n;\n        }\n    }\n\n    {\n        uint32_t max_len;\n        int n;\n\n        if (ovs_scan(s, \"trunc(%\"SCNi32\")%n\", &max_len, &n)) {\n            struct ovs_action_trunc *trunc;\n\n            trunc = nl_msg_put_unspec_uninit(actions,\n                     OVS_ACTION_ATTR_TRUNC, sizeof *trunc);\n            trunc->max_len = max_len;\n            return n;\n        }\n    }\n\n    if (port_names) {\n        int len = strcspn(s, delimiters);\n        struct simap_node *node;\n\n        node = simap_find_len(port_names, s, len);\n        if (node) {\n            nl_msg_put_u32(actions, OVS_ACTION_ATTR_OUTPUT, node->data);\n            return len;\n        }\n    }\n\n    {\n        uint32_t recirc_id;\n        int n = -1;\n\n        if (ovs_scan(s, \"recirc(%\"PRIu32\")%n\", &recirc_id, &n)) {\n            nl_msg_put_u32(actions, OVS_ACTION_ATTR_RECIRC, recirc_id);\n            return n;\n        }\n    }\n\n    if (!strncmp(s, \"userspace(\", 10)) {\n        return parse_odp_userspace_action(s, actions);\n    }\n\n    if (!strncmp(s, \"set(\", 4)) {\n        size_t start_ofs;\n        int retval;\n        struct nlattr mask[1024 / sizeof(struct nlattr)];\n        struct ofpbuf maskbuf = OFPBUF_STUB_INITIALIZER(mask);\n        struct nlattr *nested, *key;\n        size_t size;\n\n        start_ofs = nl_msg_start_nested(actions, OVS_ACTION_ATTR_SET);\n        retval = parse_odp_key_mask_attr(s + 4, port_names, actions, &maskbuf);\n        if (retval < 0) {\n            ofpbuf_uninit(&maskbuf);\n            return retval;\n        }\n        if (s[retval + 4] != ')') {\n            ofpbuf_uninit(&maskbuf);\n            return -EINVAL;\n        }\n\n        nested = ofpbuf_at_assert(actions, start_ofs, sizeof *nested);\n        key = nested + 1;\n\n        size = nl_attr_get_size(mask);\n        if (size == nl_attr_get_size(key)) {\n            /* Change to masked set action if not fully masked. */\n            if (!is_all_ones(mask + 1, size)) {\n                /* Remove padding of eariler key payload  */\n                actions->size -= NLA_ALIGN(key->nla_len) - key->nla_len;\n\n                /* Put mask payload right after key payload */\n                key->nla_len += size;\n                ofpbuf_put(actions, mask + 1, size);\n\n                /* Add new padding as needed */\n                ofpbuf_put_zeros(actions, NLA_ALIGN(key->nla_len) -\n                                          key->nla_len);\n\n                /* 'actions' may have been reallocated by ofpbuf_put(). */\n                nested = ofpbuf_at_assert(actions, start_ofs, sizeof *nested);\n                nested->nla_type = OVS_ACTION_ATTR_SET_MASKED;\n            }\n        }\n        ofpbuf_uninit(&maskbuf);\n\n        nl_msg_end_nested(actions, start_ofs);\n        return retval + 5;\n    }\n\n    {\n        struct ovs_action_push_vlan push;\n        int tpid = ETH_TYPE_VLAN;\n        int vid, pcp;\n        int cfi = 1;\n        int n = -1;\n\n        if (ovs_scan(s, \"push_vlan(vid=%i,pcp=%i)%n\", &vid, &pcp, &n)\n            || ovs_scan(s, \"push_vlan(vid=%i,pcp=%i,cfi=%i)%n\",\n                        &vid, &pcp, &cfi, &n)\n            || ovs_scan(s, \"push_vlan(tpid=%i,vid=%i,pcp=%i)%n\",\n                        &tpid, &vid, &pcp, &n)\n            || ovs_scan(s, \"push_vlan(tpid=%i,vid=%i,pcp=%i,cfi=%i)%n\",\n                        &tpid, &vid, &pcp, &cfi, &n)) {\n            push.vlan_tpid = htons(tpid);\n            push.vlan_tci = htons((vid << VLAN_VID_SHIFT)\n                                  | (pcp << VLAN_PCP_SHIFT)\n                                  | (cfi ? VLAN_CFI : 0));\n            nl_msg_put_unspec(actions, OVS_ACTION_ATTR_PUSH_VLAN,\n                              &push, sizeof push);\n\n            return n;\n        }\n    }\n\n    if (!strncmp(s, \"pop_vlan\", 8)) {\n        nl_msg_put_flag(actions, OVS_ACTION_ATTR_POP_VLAN);\n        return 8;\n    }\n\n    {\n        unsigned long long int meter_id;\n        int n = -1;\n\n        if (sscanf(s, \"meter(%lli)%n\", &meter_id, &n) > 0 && n > 0) {\n            nl_msg_put_u32(actions, OVS_ACTION_ATTR_METER, meter_id);\n            return n;\n        }\n    }\n\n    {\n        double percentage;\n        int n = -1;\n\n        if (ovs_scan(s, \"sample(sample=%lf%%,actions(%n\", &percentage, &n)\n            && percentage >= 0. && percentage <= 100.0) {\n            size_t sample_ofs, actions_ofs;\n            double probability;\n\n            probability = floor(UINT32_MAX * (percentage / 100.0) + .5);\n            sample_ofs = nl_msg_start_nested(actions, OVS_ACTION_ATTR_SAMPLE);\n            nl_msg_put_u32(actions, OVS_SAMPLE_ATTR_PROBABILITY,\n                           (probability <= 0 ? 0\n                            : probability >= UINT32_MAX ? UINT32_MAX\n                            : probability));\n\n            actions_ofs = nl_msg_start_nested(actions,\n                                              OVS_SAMPLE_ATTR_ACTIONS);\n            int retval = parse_action_list(s + n, port_names, actions);\n            if (retval < 0)\n                return retval;\n\n            n += retval;\n            nl_msg_end_nested(actions, actions_ofs);\n            nl_msg_end_nested(actions, sample_ofs);\n\n            return s[n + 1] == ')' ? n + 2 : -EINVAL;\n        }\n    }\n\n    {\n        if (!strncmp(s, \"clone(\", 6)) {\n            size_t actions_ofs;\n            int n = 6;\n\n            actions_ofs = nl_msg_start_nested(actions, OVS_ACTION_ATTR_CLONE);\n            int retval = parse_action_list(s + n, port_names, actions);\n            if (retval < 0) {\n                return retval;\n            }\n            n += retval;\n            nl_msg_end_nested(actions, actions_ofs);\n            return n + 1;\n        }\n    }\n\n    {\n        if (!strncmp(s, \"push_nsh(\", 9)) {\n            int retval = parse_odp_push_nsh_action(s, actions);\n            if (retval < 0) {\n                return retval;\n            }\n            return retval + 1;\n        }\n    }\n\n    {\n        int n;\n        if (ovs_scan(s, \"pop_nsh()%n\", &n)) {\n            nl_msg_put_flag(actions, OVS_ACTION_ATTR_POP_NSH);\n            return n;\n        }\n    }\n\n    {\n        uint32_t port;\n        int n;\n\n        if (ovs_scan(s, \"tnl_pop(%\"SCNi32\")%n\", &port, &n)) {\n            nl_msg_put_u32(actions, OVS_ACTION_ATTR_TUNNEL_POP, port);\n            return n;\n        }\n    }\n\n    {\n        if (!strncmp(s, \"ct_clear\", 8)) {\n            nl_msg_put_flag(actions, OVS_ACTION_ATTR_CT_CLEAR);\n            return 8;\n        }\n    }\n\n    {\n        int retval;\n\n        retval = parse_conntrack_action(s, actions);\n        if (retval) {\n            return retval;\n        }\n    }\n\n    {\n        struct ovs_action_push_tnl data;\n        int n;\n\n        n = ovs_parse_tnl_push(s, &data);\n        if (n > 0) {\n            odp_put_tnl_push_action(actions, &data);\n            return n;\n        } else if (n < 0) {\n            return n;\n        }\n    }\n    return -EINVAL;\n}\n",
    "target": 1,
    "idx": 1010796,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nUA_StatusCode\nUA_Array_copy(const void *src, size_t size,\n              void **dst, const UA_DataType *type) {\n    if(size == 0) {\n        if(src == NULL)\n            *dst = NULL;\n        else\n            *dst= UA_EMPTY_ARRAY_SENTINEL;\n        return UA_STATUSCODE_GOOD;\n    }\n\n    if(!type)\n        return UA_STATUSCODE_BADINTERNALERROR;\n\n    /* calloc, so we don't have to check retval in every iteration of copying */\n    *dst = UA_calloc(size, type->memSize);\n    if(!*dst)\n        return UA_STATUSCODE_BADOUTOFMEMORY;\n\n    if(type->pointerFree) {\n        memcpy(*dst, src, type->memSize * size);\n        return UA_STATUSCODE_GOOD;\n    }\n\n    uintptr_t ptrs = (uintptr_t)src;\n    uintptr_t ptrd = (uintptr_t)*dst;\n    UA_StatusCode retval = UA_STATUSCODE_GOOD;\n    for(size_t i = 0; i < size; ++i) {\n        retval |= UA_copy((void*)ptrs, (void*)ptrd, type);\n        ptrs += type->memSize;\n        ptrd += type->memSize;\n    }\n    if(retval != UA_STATUSCODE_GOOD) {\n        UA_Array_delete(*dst, size, type);\n        *dst = NULL;\n    }\n    return retval;\n}\n\nstatic UA_StatusCode\ncopy_noInit(const void *src, void *dst, const UA_DataType *type) {\n    UA_StatusCode retval = UA_STATUSCODE_GOOD;\n    uintptr_t ptrs = (uintptr_t)src;\n    uintptr_t ptrd = (uintptr_t)dst;\n    u8 membersSize = type->membersSize;\n    for(size_t i = 0; i < membersSize; ++i) {\n        const UA_DataTypeMember *m= &type->members[i];\n        const UA_DataType *typelists[2] = { UA_TYPES, &type[-type->typeIndex] };\n        const UA_DataType *mt = &typelists[!m->namespaceZero][m->memberTypeIndex];\n        if(!m->isArray) {\n            ptrs += m->padding;\n            ptrd += m->padding;\n            size_t fi = mt->builtin ? mt->typeIndex : UA_BUILTIN_TYPES_COUNT;\n            retval |= copyJumpTable[fi]((const void*)ptrs, (void*)ptrd, mt);\n            ptrs += mt->memSize;\n            ptrd += mt->memSize;\n        } else {\n            ptrs += m->padding;\n            ptrd += m->padding;\n            size_t *dst_size = (size_t*)ptrd;\n            const size_t size = *((const size_t*)ptrs);\n            ptrs += sizeof(size_t);\n            ptrd += sizeof(size_t);\n            retval |= UA_Array_copy(*(void* const*)ptrs, size, (void**)ptrd, mt);\n            if(retval == UA_STATUSCODE_GOOD)\n                *dst_size = size;\n            else\n                *dst_size = 0;\n            ptrs += sizeof(void*);\n            ptrd += sizeof(void*);\n        }\n    }\n    return retval;\n}\n\nUA_StatusCode\nUA_copy(const void *src, void *dst, const UA_DataType *type) {\n    memset(dst, 0, type->memSize); /* init */\n    UA_StatusCode retval = copy_noInit(src, dst, type);\n    if(retval != UA_STATUSCODE_GOOD)\n        UA_deleteMembers(dst, type);\n    return retval;\n}\n\nstatic UA_StatusCode\nExtensionObject_copy(UA_ExtensionObject const *src, UA_ExtensionObject *dst,\n                     const UA_DataType *_) {\n    UA_StatusCode retval = UA_STATUSCODE_GOOD;\n    switch(src->encoding) {\n    case UA_EXTENSIONOBJECT_ENCODED_NOBODY:\n    case UA_EXTENSIONOBJECT_ENCODED_BYTESTRING:\n    case UA_EXTENSIONOBJECT_ENCODED_XML:\n        dst->encoding = src->encoding;\n        retval = NodeId_copy(&src->content.encoded.typeId,\n                             &dst->content.encoded.typeId, NULL);\n        retval |= UA_ByteString_copy(&src->content.encoded.body,\n                                     &dst->content.encoded.body);\n        break;\n    case UA_EXTENSIONOBJECT_DECODED:\n    case UA_EXTENSIONOBJECT_DECODED_NODELETE:\n        if(!src->content.decoded.type || !src->content.decoded.data)\n            return UA_STATUSCODE_BADINTERNALERROR;\n        dst->encoding = UA_EXTENSIONOBJECT_DECODED;\n        dst->content.decoded.type = src->content.decoded.type;\n        retval = UA_Array_copy(src->content.decoded.data, 1,\n            &dst->content.decoded.data, src->content.decoded.type);\n        break;\n    default:\n        break;\n    }\n    return retval;\n}\n\nstatic UA_StatusCode\ncopy_noInit(const void *src, void *dst, const UA_DataType *type) {\n    UA_StatusCode retval = UA_STATUSCODE_GOOD;\n    uintptr_t ptrs = (uintptr_t)src;\n    uintptr_t ptrd = (uintptr_t)dst;\n    u8 membersSize = type->membersSize;\n    for(size_t i = 0; i < membersSize; ++i) {\n        const UA_DataTypeMember *m= &type->members[i];\n        const UA_DataType *typelists[2] = { UA_TYPES, &type[-type->typeIndex] };\n        const UA_DataType *mt = &typelists[!m->namespaceZero][m->memberTypeIndex];\n        if(!m->isArray) {\n            ptrs += m->padding;\n            ptrd += m->padding;\n            size_t fi = mt->builtin ? mt->typeIndex : UA_BUILTIN_TYPES_COUNT;\n            retval |= copyJumpTable[fi]((const void*)ptrs, (void*)ptrd, mt);\n            ptrs += mt->memSize;\n            ptrd += mt->memSize;\n        } else {\n            ptrs += m->padding;\n            ptrd += m->padding;\n            size_t *dst_size = (size_t*)ptrd;\n            const size_t size = *((const size_t*)ptrs);\n            ptrs += sizeof(size_t);\n            ptrd += sizeof(size_t);\n            retval |= UA_Array_copy(*(void* const*)ptrs, size, (void**)ptrd, mt);\n            if(retval == UA_STATUSCODE_GOOD)\n                *dst_size = size;\n            else\n                *dst_size = 0;\n            ptrs += sizeof(void*);\n            ptrd += sizeof(void*);\n        }\n    }\n    return retval;\n}\n\nUA_StatusCode\nUA_copy(const void *src, void *dst, const UA_DataType *type) {\n    memset(dst, 0, type->memSize); /* init */\n    UA_StatusCode retval = copy_noInit(src, dst, type);\n    if(retval != UA_STATUSCODE_GOOD)\n        UA_deleteMembers(dst, type);\n    return retval;\n}\n\nstatic UA_StatusCode\nVariant_copy(UA_Variant const *src, UA_Variant *dst, const UA_DataType *_) {\n    size_t length = src->arrayLength;\n    if(UA_Variant_isScalar(src))\n        length = 1;\n    UA_StatusCode retval = UA_Array_copy(src->data, length,\n                                         &dst->data, src->type);\n    if(retval != UA_STATUSCODE_GOOD)\n        return retval;\n    dst->arrayLength = src->arrayLength;\n    dst->type = src->type;\n    if(src->arrayDimensions) {\n        retval = UA_Array_copy(src->arrayDimensions, src->arrayDimensionsSize,\n            (void**)&dst->arrayDimensions, &UA_TYPES[UA_TYPES_INT32]);\n        if(retval != UA_STATUSCODE_GOOD)\n            return retval;\n        dst->arrayDimensionsSize = src->arrayDimensionsSize;\n    }\n    return UA_STATUSCODE_GOOD;\n}\n\nstatic UA_StatusCode\ncopy_noInit(const void *src, void *dst, const UA_DataType *type) {\n    UA_StatusCode retval = UA_STATUSCODE_GOOD;\n    uintptr_t ptrs = (uintptr_t)src;\n    uintptr_t ptrd = (uintptr_t)dst;\n    u8 membersSize = type->membersSize;\n    for(size_t i = 0; i < membersSize; ++i) {\n        const UA_DataTypeMember *m= &type->members[i];\n        const UA_DataType *typelists[2] = { UA_TYPES, &type[-type->typeIndex] };\n        const UA_DataType *mt = &typelists[!m->namespaceZero][m->memberTypeIndex];\n        if(!m->isArray) {\n            ptrs += m->padding;\n            ptrd += m->padding;\n            size_t fi = mt->builtin ? mt->typeIndex : UA_BUILTIN_TYPES_COUNT;\n            retval |= copyJumpTable[fi]((const void*)ptrs, (void*)ptrd, mt);\n            ptrs += mt->memSize;\n            ptrd += mt->memSize;\n        } else {\n            ptrs += m->padding;\n            ptrd += m->padding;\n            size_t *dst_size = (size_t*)ptrd;\n            const size_t size = *((const size_t*)ptrs);\n            ptrs += sizeof(size_t);\n            ptrd += sizeof(size_t);\n            retval |= UA_Array_copy(*(void* const*)ptrs, size, (void**)ptrd, mt);\n            if(retval == UA_STATUSCODE_GOOD)\n                *dst_size = size;\n            else\n                *dst_size = 0;\n            ptrs += sizeof(void*);\n            ptrd += sizeof(void*);\n        }\n    }\n    return retval;\n}\n\nUA_StatusCode\nUA_copy(const void *src, void *dst, const UA_DataType *type) {\n    memset(dst, 0, type->memSize); /* init */\n    UA_StatusCode retval = copy_noInit(src, dst, type);\n    if(retval != UA_STATUSCODE_GOOD)\n        UA_deleteMembers(dst, type);\n    return retval;\n}\n\nstatic UA_StatusCode\ncopy_noInit(const void *src, void *dst, const UA_DataType *type) {\n    UA_StatusCode retval = UA_STATUSCODE_GOOD;\n    uintptr_t ptrs = (uintptr_t)src;\n    uintptr_t ptrd = (uintptr_t)dst;\n    u8 membersSize = type->membersSize;\n    for(size_t i = 0; i < membersSize; ++i) {\n        const UA_DataTypeMember *m= &type->members[i];\n        const UA_DataType *typelists[2] = { UA_TYPES, &type[-type->typeIndex] };\n        const UA_DataType *mt = &typelists[!m->namespaceZero][m->memberTypeIndex];\n        if(!m->isArray) {\n            ptrs += m->padding;\n            ptrd += m->padding;\n            size_t fi = mt->builtin ? mt->typeIndex : UA_BUILTIN_TYPES_COUNT;\n            retval |= copyJumpTable[fi]((const void*)ptrs, (void*)ptrd, mt);\n            ptrs += mt->memSize;\n            ptrd += mt->memSize;\n        } else {\n            ptrs += m->padding;\n            ptrd += m->padding;\n            size_t *dst_size = (size_t*)ptrd;\n            const size_t size = *((const size_t*)ptrs);\n            ptrs += sizeof(size_t);\n            ptrd += sizeof(size_t);\n            retval |= UA_Array_copy(*(void* const*)ptrs, size, (void**)ptrd, mt);\n            if(retval == UA_STATUSCODE_GOOD)\n                *dst_size = size;\n            else\n                *dst_size = 0;\n            ptrs += sizeof(void*);\n            ptrd += sizeof(void*);\n        }\n    }\n    return retval;\n}\n\nUA_StatusCode\nUA_copy(const void *src, void *dst, const UA_DataType *type) {\n    memset(dst, 0, type->memSize); /* init */\n    UA_StatusCode retval = copy_noInit(src, dst, type);\n    if(retval != UA_STATUSCODE_GOOD)\n        UA_deleteMembers(dst, type);\n    return retval;\n}\n\nstatic UA_StatusCode\ncopy_noInit(const void *src, void *dst, const UA_DataType *type) {\n    UA_StatusCode retval = UA_STATUSCODE_GOOD;\n    uintptr_t ptrs = (uintptr_t)src;\n    uintptr_t ptrd = (uintptr_t)dst;\n    u8 membersSize = type->membersSize;\n    for(size_t i = 0; i < membersSize; ++i) {\n        const UA_DataTypeMember *m= &type->members[i];\n        const UA_DataType *typelists[2] = { UA_TYPES, &type[-type->typeIndex] };\n        const UA_DataType *mt = &typelists[!m->namespaceZero][m->memberTypeIndex];\n        if(!m->isArray) {\n            ptrs += m->padding;\n            ptrd += m->padding;\n            size_t fi = mt->builtin ? mt->typeIndex : UA_BUILTIN_TYPES_COUNT;\n            retval |= copyJumpTable[fi]((const void*)ptrs, (void*)ptrd, mt);\n            ptrs += mt->memSize;\n            ptrd += mt->memSize;\n        } else {\n            ptrs += m->padding;\n            ptrd += m->padding;\n            size_t *dst_size = (size_t*)ptrd;\n            const size_t size = *((const size_t*)ptrs);\n            ptrs += sizeof(size_t);\n            ptrd += sizeof(size_t);\n            retval |= UA_Array_copy(*(void* const*)ptrs, size, (void**)ptrd, mt);\n            if(retval == UA_STATUSCODE_GOOD)\n                *dst_size = size;\n            else\n                *dst_size = 0;\n            ptrs += sizeof(void*);\n            ptrd += sizeof(void*);\n        }\n    }\n    return retval;\n}\n\nUA_StatusCode\nUA_copy(const void *src, void *dst, const UA_DataType *type) {\n    memset(dst, 0, type->memSize); /* init */\n    UA_StatusCode retval = copy_noInit(src, dst, type);\n    if(retval != UA_STATUSCODE_GOOD)\n        UA_deleteMembers(dst, type);\n    return retval;\n}\n\nstatic UA_Boolean tortureEncoding(const uint8_t *data, size_t size, size_t *newOffset) {\n    *newOffset = 0;\n    if (size <= 2)\n        return UA_FALSE;\n\n    // get some random type\n    uint16_t typeIndex = (uint16_t)(data[0] | data[1] << 8);\n    data += 2;\n    size -= 2;\n\n    if (typeIndex >= UA_TYPES_COUNT)\n        return UA_FALSE;\n\n    void *dst = UA_new(&UA_TYPES[typeIndex]);\n\n    const UA_ByteString binary = {\n            size, //length\n            (UA_Byte *) (void *) data\n    };\n\n    UA_StatusCode ret = UA_decodeBinary(&binary, newOffset, dst, &UA_TYPES[typeIndex], 0, nullptr);\n\n    if (ret == UA_STATUSCODE_GOOD) {\n        // copy the datatype to test\n        void *dstCopy = UA_new(&UA_TYPES[typeIndex]);\n        UA_copy(dst, dstCopy, &UA_TYPES[typeIndex]);\n        UA_delete(dstCopy, &UA_TYPES[typeIndex]);\n\n        // now also test encoding\n        UA_ByteString encoded;\n        UA_ByteString_allocBuffer(&encoded, *newOffset);\n        const UA_Byte *end = &encoded.data[*newOffset];\n        UA_Byte *pos = encoded.data;\n        ret = UA_encodeBinary(dst, &UA_TYPES[typeIndex], &pos, &end, NULL, NULL);\n        if (ret == UA_STATUSCODE_GOOD) {\n            // do nothing\n        }\n        UA_ByteString_deleteMembers(&encoded);\n    }\n    UA_delete(dst, &UA_TYPES[typeIndex]);\n\n    return UA_TRUE;\n}\n\nvoid Fuzzer::ExecuteCallback(const uint8_t *Data, size_t Size) {\n  TPC.RecordInitialStack();\n  TotalNumberOfRuns++;\n  assert(InFuzzingThread());\n  if (SMR.IsClient())\n    SMR.WriteByteArray(Data, Size);\n  // We copy the contents of Unit into a separate heap buffer\n  // so that we reliably find buffer overflows in it.\n  uint8_t *DataCopy = new uint8_t[Size];\n  memcpy(DataCopy, Data, Size);\n  if (CurrentUnitData && CurrentUnitData != Data)\n    memcpy(CurrentUnitData, Data, Size);\n  CurrentUnitSize = Size;\n  AllocTracer.Start(Options.TraceMalloc);\n  UnitStartTime = system_clock::now();\n  TPC.ResetMaps();\n  RunningCB = true;\n  int Res = CB(DataCopy, Size);\n  RunningCB = false;\n  UnitStopTime = system_clock::now();\n  (void)Res;\n  assert(Res == 0);\n  HasMoreMallocsThanFrees = AllocTracer.Stop();\n  if (!LooseMemeq(DataCopy, Data, Size))\n    CrashOnOverwrittenData();\n  CurrentUnitSize = 0;\n  delete[] DataCopy;\n}\n\nint RunOneTest(Fuzzer *F, const char *InputFilePath, size_t MaxLen) {\n  Unit U = FileToVector(InputFilePath);\n  if (MaxLen && MaxLen < U.size())\n    U.resize(MaxLen);\n  F->ExecuteCallback(U.data(), U.size());\n  F->TryDetectingAMemoryLeak(U.data(), U.size(), true);\n  return 0;\n}\n\nint FuzzerDriver(int *argc, char ***argv, UserCallback Callback) {\n  using namespace fuzzer;\n  assert(argc && argv && \"Argument pointers cannot be nullptr\");\n  std::string Argv0((*argv)[0]);\n  EF = new ExternalFunctions();\n  if (EF->LLVMFuzzerInitialize)\n    EF->LLVMFuzzerInitialize(argc, argv);\n  const Vector<std::string> Args(*argv, *argv + *argc);\n  assert(!Args.empty());\n  ProgName = new std::string(Args[0]);\n  if (Argv0 != *ProgName) {\n    Printf(\"ERROR: argv[0] has been modified in LLVMFuzzerInitialize\\n\");\n    exit(1);\n  }\n  ParseFlags(Args);\n  if (Flags.help) {\n    PrintHelp();\n    return 0;\n  }\n\n  if (Flags.close_fd_mask & 2)\n    DupAndCloseStderr();\n  if (Flags.close_fd_mask & 1)\n    CloseStdout();\n\n  if (Flags.jobs > 0 && Flags.workers == 0) {\n    Flags.workers = std::min(NumberOfCpuCores() / 2, Flags.jobs);\n    if (Flags.workers > 1)\n      Printf(\"Running %u workers\\n\", Flags.workers);\n  }\n\n  if (Flags.workers > 0 && Flags.jobs > 0)\n    return RunInMultipleProcesses(Args, Flags.workers, Flags.jobs);\n\n  FuzzingOptions Options;\n  Options.Verbosity = Flags.verbosity;\n  Options.MaxLen = Flags.max_len;\n  Options.ExperimentalLenControl = Flags.experimental_len_control;\n  Options.UnitTimeoutSec = Flags.timeout;\n  Options.ErrorExitCode = Flags.error_exitcode;\n  Options.TimeoutExitCode = Flags.timeout_exitcode;\n  Options.MaxTotalTimeSec = Flags.max_total_time;\n  Options.DoCrossOver = Flags.cross_over;\n  Options.MutateDepth = Flags.mutate_depth;\n  Options.UseCounters = Flags.use_counters;\n  Options.UseIndirCalls = Flags.use_indir_calls;\n  Options.UseMemmem = Flags.use_memmem;\n  Options.UseCmp = Flags.use_cmp;\n  Options.UseValueProfile = Flags.use_value_profile;\n  Options.Shrink = Flags.shrink;\n  Options.ReduceInputs = Flags.reduce_inputs;\n  Options.ShuffleAtStartUp = Flags.shuffle;\n  Options.PreferSmall = Flags.prefer_small;\n  Options.ReloadIntervalSec = Flags.reload;\n  Options.OnlyASCII = Flags.only_ascii;\n  Options.DetectLeaks = Flags.detect_leaks;\n  Options.PurgeAllocatorIntervalSec = Flags.purge_allocator_interval;\n  Options.TraceMalloc = Flags.trace_malloc;\n  Options.RssLimitMb = Flags.rss_limit_mb;\n  if (Flags.runs >= 0)\n    Options.MaxNumberOfRuns = Flags.runs;\n  if (!Inputs->empty() && !Flags.minimize_crash_internal_step)\n    Options.OutputCorpus = (*Inputs)[0];\n  Options.ReportSlowUnits = Flags.report_slow_units;\n  if (Flags.artifact_prefix)\n    Options.ArtifactPrefix = Flags.artifact_prefix;\n  if (Flags.exact_artifact_path)\n    Options.ExactArtifactPath = Flags.exact_artifact_path;\n  Vector<Unit> Dictionary;\n  if (Flags.dict)\n    if (!ParseDictionaryFile(FileToString(Flags.dict), &Dictionary))\n      return 1;\n  if (Flags.verbosity > 0 && !Dictionary.empty())\n    Printf(\"Dictionary: %zd entries\\n\", Dictionary.size());\n  bool DoPlainRun = AllInputsAreFiles();\n  Options.SaveArtifacts =\n      !DoPlainRun || Flags.minimize_crash_internal_step;\n  Options.PrintNewCovPcs = Flags.print_pcs;\n  Options.PrintNewCovFuncs = Flags.print_funcs;\n  Options.PrintFinalStats = Flags.print_final_stats;\n  Options.PrintCorpusStats = Flags.print_corpus_stats;\n  Options.PrintCoverage = Flags.print_coverage;\n  Options.DumpCoverage = Flags.dump_coverage;\n  Options.UseClangCoverage = Flags.use_clang_coverage;\n  Options.UseFeatureFrequency = Flags.use_feature_frequency;\n  if (Flags.exit_on_src_pos)\n    Options.ExitOnSrcPos = Flags.exit_on_src_pos;\n  if (Flags.exit_on_item)\n    Options.ExitOnItem = Flags.exit_on_item;\n\n  unsigned Seed = Flags.seed;\n  // Initialize Seed.\n  if (Seed == 0)\n    Seed =\n        std::chrono::system_clock::now().time_since_epoch().count() + GetPid();\n  if (Flags.verbosity)\n    Printf(\"INFO: Seed: %u\\n\", Seed);\n\n  Random Rand(Seed);\n  auto *MD = new MutationDispatcher(Rand, Options);\n  auto *Corpus = new InputCorpus(Options.OutputCorpus);\n  auto *F = new Fuzzer(Callback, *Corpus, *MD, Options);\n\n  for (auto &U: Dictionary)\n    if (U.size() <= Word::GetMaxSize())\n      MD->AddWordToManualDictionary(Word(U.data(), U.size()));\n\n  StartRssThread(F, Flags.rss_limit_mb);\n\n  Options.HandleAbrt = Flags.handle_abrt;\n  Options.HandleBus = Flags.handle_bus;\n  Options.HandleFpe = Flags.handle_fpe;\n  Options.HandleIll = Flags.handle_ill;\n  Options.HandleInt = Flags.handle_int;\n  Options.HandleSegv = Flags.handle_segv;\n  Options.HandleTerm = Flags.handle_term;\n  Options.HandleXfsz = Flags.handle_xfsz;\n  Options.HandleUsr1 = Flags.handle_usr1;\n  Options.HandleUsr2 = Flags.handle_usr2;\n  SetSignalHandler(Options);\n\n  std::atexit(Fuzzer::StaticExitCallback);\n\n  if (Flags.minimize_crash)\n    return MinimizeCrashInput(Args, Options);\n\n  if (Flags.minimize_crash_internal_step)\n    return MinimizeCrashInputInternalStep(F, Corpus);\n\n  if (Flags.cleanse_crash)\n    return CleanseCrashInput(Args, Options);\n\n  if (auto Name = Flags.run_equivalence_server) {\n    SMR.Destroy(Name);\n    if (!SMR.Create(Name)) {\n       Printf(\"ERROR: can't create shared memory region\\n\");\n      return 1;\n    }\n    Printf(\"INFO: EQUIVALENCE SERVER UP\\n\");\n    while (true) {\n      SMR.WaitClient();\n      size_t Size = SMR.ReadByteArraySize();\n      SMR.WriteByteArray(nullptr, 0);\n      const Unit tmp(SMR.GetByteArray(), SMR.GetByteArray() + Size);\n      F->ExecuteCallback(tmp.data(), tmp.size());\n      SMR.PostServer();\n    }\n    return 0;\n  }\n\n  if (auto Name = Flags.use_equivalence_server) {\n    if (!SMR.Open(Name)) {\n      Printf(\"ERROR: can't open shared memory region\\n\");\n      return 1;\n    }\n    Printf(\"INFO: EQUIVALENCE CLIENT UP\\n\");\n  }\n\n  if (DoPlainRun) {\n    Options.SaveArtifacts = false;\n    int Runs = std::max(1, Flags.runs);\n    Printf(\"%s: Running %zd inputs %d time(s) each.\\n\", ProgName->c_str(),\n           Inputs->size(), Runs);\n    for (auto &Path : *Inputs) {\n      auto StartTime = system_clock::now();\n      Printf(\"Running: %s\\n\", Path.c_str());\n      for (int Iter = 0; Iter < Runs; Iter++)\n        RunOneTest(F, Path.c_str(), Options.MaxLen);\n      auto StopTime = system_clock::now();\n      auto MS = duration_cast<milliseconds>(StopTime - StartTime).count();\n      Printf(\"Executed %s in %zd ms\\n\", Path.c_str(), (long)MS);\n    }\n    Printf(\"***\\n\"\n           \"*** NOTE: fuzzing was not performed, you have only\\n\"\n           \"***       executed the target code on a fixed set of inputs.\\n\"\n           \"***\\n\");\n    F->PrintFinalStats();\n    exit(0);\n  }\n\n  if (Flags.merge) {\n    F->CrashResistantMerge(Args, *Inputs,\n                           Flags.load_coverage_summary,\n                           Flags.save_coverage_summary,\n                           Flags.merge_control_file);\n    exit(0);\n  }\n\n  if (Flags.merge_inner) {\n    const size_t kDefaultMaxMergeLen = 1 << 20;\n    if (Options.MaxLen == 0)\n      F->SetMaxInputLen(kDefaultMaxMergeLen);\n    assert(Flags.merge_control_file);\n    F->CrashResistantMergeInternalStep(Flags.merge_control_file);\n    exit(0);\n  }\n\n  if (Flags.analyze_dict) {\n    size_t MaxLen = INT_MAX;  // Large max length.\n    UnitVector InitialCorpus;\n    for (auto &Inp : *Inputs) {\n      Printf(\"Loading corpus dir: %s\\n\", Inp.c_str());\n      ReadDirToVectorOfUnits(Inp.c_str(), &InitialCorpus, nullptr,\n                             MaxLen, /*ExitOnError=*/false);\n    }\n\n    if (Dictionary.empty() || Inputs->empty()) {\n      Printf(\"ERROR: can't analyze dict without dict and corpus provided\\n\");\n      return 1;\n    }\n    if (AnalyzeDictionary(F, Dictionary, InitialCorpus)) {\n      Printf(\"Dictionary analysis failed\\n\");\n      exit(1);\n    }\n    Printf(\"Dictionary analysis suceeded\\n\");\n    exit(0);\n  }\n\n  F->Loop(*Inputs);\n\n  if (Flags.verbosity)\n    Printf(\"Done %zd runs in %zd second(s)\\n\", F->getTotalNumberOfRuns(),\n           F->secondsSinceProcessStartUp());\n  F->PrintFinalStats();\n\n  exit(0);  // Don't let F destroy itself.\n}\n\nint main(int argc, char **argv) {\n  return fuzzer::FuzzerDriver(&argc, &argv, LLVMFuzzerTestOneInput);\n}\n\n\n// target function\nstatic status\nExtensionObject_decodeBinaryContent(UA_ExtensionObject *dst, const UA_NodeId *typeId) {\n    /* Lookup the datatype */\n    const UA_DataType *type = UA_findDataTypeByBinary(typeId);\n\n    /* Unknown type, just take the binary content */\n    if(!type) {\n        dst->encoding = UA_EXTENSIONOBJECT_ENCODED_BYTESTRING;\n        dst->content.encoded.typeId = *typeId;\n        return ByteString_decodeBinary(&dst->content.encoded.body);\n    }\n\n    /* Allocate memory */\n    dst->content.decoded.data = UA_new(type);\n    if(!dst->content.decoded.data)\n        return UA_STATUSCODE_BADOUTOFMEMORY;\n\n    /* Jump over the length field (TODO: check if the decoded length matches) */\n    g_pos += 4;\n        \n    /* Decode */\n    dst->encoding = UA_EXTENSIONOBJECT_DECODED;\n    dst->content.decoded.type = type;\n    size_t decode_index = type->builtin ? type->typeIndex : UA_BUILTIN_TYPES_COUNT;\n    return decodeBinaryJumpTable[decode_index](dst->content.decoded.data, type);\n}\n",
    "target": 1,
    "idx": 1004300,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic int\nauthentic_emu_update_tokeninfo(struct sc_profile *profile, struct sc_pkcs15_card *p15card,\n\t\tstruct sc_pkcs15_tokeninfo *tinfo)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_file *file = NULL;\n\tstruct sc_path path;\n\tunsigned char buffer[8];\n\tint rv,len;\n\n\tsc_format_path(AUTHENTIC_CACHE_TIMESTAMP_PATH, &path);\n\trv = sc_select_file(p15card->card, &path, &file);\n\tif (!rv) {\n\t\trv = sc_get_challenge(p15card->card, buffer, sizeof(buffer));\n\t\tif (rv < 0) {\n\t\t\tsc_file_free(file);\n\t\t\tLOG_TEST_RET(ctx, rv, \"Get challenge error\");\n\t\t}\n\n\t\tlen = file->size > sizeof(buffer) ? sizeof(buffer) : file->size;\n\t\trv = sc_update_binary(p15card->card, 0, buffer, len, 0);\n\t\tsc_file_free(file);\n\t\tLOG_TEST_RET(ctx, rv, \"Update binary error\");\n\t}\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n\nstatic int\nsc_pkcs15init_update_tokeninfo(struct sc_pkcs15_card *p15card, struct sc_profile *profile)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tunsigned char\t*buf = NULL;\n\tsize_t\t\tsize;\n\tint\t\trv;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\t/* set lastUpdate field */\n\tif (p15card->tokeninfo->last_update.gtime != NULL)   {\n\t\tfree(p15card->tokeninfo->last_update.gtime);\n\t\tp15card->tokeninfo->last_update.gtime = NULL;\n\t}\n\trv = sc_pkcs15_get_generalized_time(ctx, &p15card->tokeninfo->last_update.gtime);\n\tLOG_TEST_RET(ctx, rv, \"Cannot allocate generalized time string\");\n\n\tif (profile->ops->emu_update_tokeninfo)\n\t\treturn profile->ops->emu_update_tokeninfo(profile, p15card, p15card->tokeninfo);\n\n\tif (!p15card->file_tokeninfo)   {\n\t\tsc_log(ctx, \"No TokenInfo to update\");\n\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\t}\n\n\trv = sc_pkcs15_encode_tokeninfo(ctx, p15card->tokeninfo, &buf, &size);\n\tif (rv >= 0)\n\t\trv = sc_pkcs15init_update_file(profile, p15card, p15card->file_tokeninfo, buf, size);\n\tif (buf)\n\t\tfree(buf);\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\nstatic int\nsc_pkcs15init_update_lastupdate(struct sc_pkcs15_card *p15card, struct sc_profile *profile)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tint\t\tr;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (p15card->tokeninfo->last_update.path.len)    {\n\t\tstatic const struct sc_asn1_entry c_asn1_last_update[2] = {\n\t\t        { \"generalizedTime\",    SC_ASN1_GENERALIZEDTIME, SC_ASN1_TAG_GENERALIZEDTIME,   SC_ASN1_OPTIONAL, NULL, NULL },\n\t\t\t{ NULL, 0, 0, 0, NULL, NULL }\n\t\t};\n\t\tstruct sc_asn1_entry asn1_last_update[2];\n\t\tsize_t lupdate_len;\n\t\tstruct sc_file *file = NULL;\n\t\tstruct sc_pkcs15_last_update *last_update = &p15card->tokeninfo->last_update;\n\t\tunsigned char *buf = NULL;\n\t\tsize_t buflen;\n\n\t\t/* update 'lastUpdate' file */\n\t\tif (last_update->gtime != NULL)\n\t\t\tfree(last_update->gtime);\n\t\tr = sc_pkcs15_get_generalized_time(ctx, &last_update->gtime);\n\t\tLOG_TEST_RET(ctx, r, \"Cannot allocate generalized time string\");\n\n\t\tsc_copy_asn1_entry(c_asn1_last_update, asn1_last_update);\n\t\tlupdate_len = strlen(last_update->gtime);\n\t\tsc_format_asn1_entry(asn1_last_update + 0, last_update->gtime, &lupdate_len, 1);\n\n\t\tr = sc_asn1_encode(ctx, asn1_last_update, &buf, &buflen);\n\t\tLOG_TEST_RET(ctx, r, \"select object path failed\");\n\n\t\tr = sc_select_file(p15card->card, &last_update->path, &file);\n\t\tif (r < 0)\n\t\t\tfree(buf);\n\t\tLOG_TEST_RET(ctx, r, \"select object path failed\");\n\n\t\tr = sc_pkcs15init_update_file(profile, p15card, file, buf, buflen);\n\t\tsc_file_free(file);\n\t\tif (buf)\n\t\t\tfree(buf);\n\t\tLOG_TEST_RET(ctx, r, \"Cannot update 'LastUpdate' file\");\n\t\tLOG_FUNC_RETURN(ctx, r);\n\t}\n\n\tr = sc_pkcs15init_update_tokeninfo(p15card, profile);\n\tLOG_FUNC_RETURN(ctx, r);\n}\n\nvoid\nsc_pkcs15init_unbind(struct sc_profile *profile)\n{\n\tint r;\n\tstruct sc_context *ctx = profile->card->ctx;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"Pksc15init Unbind: %i:%p:%i\", profile->dirty, profile->p15_data, profile->pkcs15.do_last_update);\n\tif (profile->dirty != 0 && profile->p15_data != NULL && profile->pkcs15.do_last_update) {\n\t\tr = sc_pkcs15init_update_lastupdate(profile->p15_data, profile);\n\t\tif (r < 0)\n\t\t\tsc_log(ctx, \"Failed to update TokenInfo: %s\", sc_strerror(r));\n\t}\n\tif (profile->dll)\n\t\tsc_dlclose(profile->dll);\n\tsc_profile_free(profile);\n}\n\n\n// target function\nstatic int\nauthentic_emu_update_tokeninfo(struct sc_profile *profile, struct sc_pkcs15_card *p15card,\n\t\tstruct sc_pkcs15_tokeninfo *tinfo)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_file *file = NULL;\n\tstruct sc_path path;\n\tunsigned char buffer[8];\n\tint rv,len;\n\n\tsc_format_path(AUTHENTIC_CACHE_TIMESTAMP_PATH, &path);\n\trv = sc_select_file(p15card->card, &path, &file);\n\tif (!rv) {\n\t\trv = sc_get_challenge(p15card->card, buffer, sizeof(buffer));\n\t\tif (!rv) {\n\t\t\tsc_file_free(file);\n\t\t\tLOG_TEST_RET(ctx, rv, \"Get challenge error\");\n\t\t}\n\n\t\tlen = file->size > sizeof(buffer) ? sizeof(buffer) : file->size;\n\t\trv = sc_update_binary(p15card->card, 0, buffer, len, 0);\n\t\tsc_file_free(file);\n\t\tLOG_TEST_RET(ctx, rv, \"Update binary error\");\n\t}\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n",
    "target": 1,
    "idx": 1064898,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic int\niasecc_delete_file(struct sc_card *card, const struct sc_path *path)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tconst struct sc_acl_entry *entry = NULL;\n\tstruct sc_apdu apdu;\n\tstruct sc_file *file = NULL;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_print_cache(card);\n\n\trv = iasecc_select_file(card, path, &file);\n\tif (rv == SC_ERROR_FILE_NOT_FOUND)\n\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\tLOG_TEST_RET(ctx, rv, \"Cannot select file to delete\");\n\n\tentry = sc_file_get_acl_entry(file, SC_AC_OP_DELETE);\n\tif (!entry)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_OBJECT_NOT_FOUND, \"Cannot delete file: no 'DELETE' acl\");\n\n\tsc_log(ctx, \"DELETE method/reference %X/%X\", entry->method, entry->key_ref);\n\tif (entry->method == SC_AC_SCB && (entry->key_ref & IASECC_SCB_METHOD_SM))   {\n\t\tunsigned char se_num = entry->key_ref & IASECC_SCB_METHOD_MASK_REF;\n\t\trv = iasecc_sm_delete_file(card, se_num, file->id);\n\t\tsc_file_free(file);\n\t}\n\telse   {\n\t\tsc_file_free(file);\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_1, 0xE4, 0x00, 0x00);\n\n\t\trv = sc_transmit_apdu(card, &apdu);\n\t\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\t\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\tLOG_TEST_RET(ctx, rv, \"Delete file failed\");\n\n\t\tif (card->cache.valid) {\n\t\t\tsc_file_free(card->cache.current_ef);\n\t\t}\n\t\tcard->cache.current_ef = NULL;\n\t}\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\nint sc_delete_file(sc_card_t *card, const sc_path_t *path)\n{\n\tint r;\n\tchar pbuf[SC_MAX_PATH_STRING_SIZE];\n\n\tif (card == NULL) {\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\n\tr = sc_path_print(pbuf, sizeof(pbuf), path);\n\tif (r != SC_SUCCESS)\n\t\tpbuf[0] = '\\0';\n\n\tsc_log(card->ctx, \"called; type=%d, path=%s\", path->type, pbuf);\n\tif (card->ops->delete_file == NULL)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_NOT_SUPPORTED);\n\tr = card->ops->delete_file(card, path);\n\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\nint\niasecc_pkcs15_delete_file(struct sc_pkcs15_card *p15card, struct sc_profile *profile,\n\t\tstruct sc_file *df)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_card *card = p15card->card;\n\tstruct sc_path  path;\n\tunsigned long caps = card->caps;\n\tint rv = 0;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tsc_log(ctx, \"iasecc_pkcs15_delete_file() id %04X\\n\", df->id);\n\n\tcard->caps |= SC_CARD_CAP_USE_FCI_AC;\n\trv = sc_pkcs15init_authenticate(profile, p15card, df, SC_AC_OP_DELETE);\n\tcard->caps = caps;\n\n\tLOG_TEST_RET(ctx, rv, \"Cannot authenticate SC_AC_OP_DELETE\");\n\n\tmemset(&path, 0, sizeof(path));\n\tpath.type = SC_PATH_TYPE_FILE_ID;\n\tpath.value[0] = df->id >> 8;\n\tpath.value[1] = df->id & 0xFF;\n\tpath.len = 2;\n\n\trv = sc_delete_file(card, &path);\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\nstatic int\niasecc_store_data_object(struct sc_pkcs15_card *p15card, struct sc_profile *profile,\n\t\tstruct sc_pkcs15_object *object,\n\t\tstruct sc_pkcs15_der *data, struct sc_path *path)\n{\n#define MAX_DATA_OBJS 32\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_card *card = p15card->card;\n\tstruct sc_pkcs15_object *p15objects[MAX_DATA_OBJS];\n\tstruct sc_file *cfile = NULL, *file = NULL, *parent = NULL;\n\tint rv, nn_objs, indx, ii;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"iasecc_store_data_object() authID '%s'\", sc_pkcs15_print_id(&object->auth_id));\n\tnn_objs = sc_pkcs15_get_objects(p15card, SC_PKCS15_TYPE_DATA_OBJECT, p15objects, MAX_DATA_OBJS);\n\tLOG_TEST_RET(ctx, nn_objs, \"IasEcc get pkcs15 DATA objects error\");\n\n\tfor(indx = 1; indx < MAX_DATA_OBJS; indx++)   {\n\t\trv = iasecc_pkcs15_new_file(profile, card, SC_PKCS15_TYPE_DATA_OBJECT, indx, &file);\n\t\tLOG_TEST_RET(ctx, rv, \"iasecc_store_data_object() pkcs15 new DATA file error\");\n\n\t\tfor (ii=0; ii<nn_objs; ii++)   {\n\t\t\tstruct sc_pkcs15_data_info *info = (struct sc_pkcs15_data_info *)p15objects[ii]->data;\n\t\t\tint file_id = info->path.value[info->path.len - 2] * 0x100 + info->path.value[info->path.len - 1];\n\n\t\t\tsc_log(ctx, \"iasecc_store_data_object() %i: file_id 0x%X, pfile->id 0x%X\\n\", ii, file_id, file->id);\n\t\t\tif (file->id == file_id)\n\t\t\t   break;\n\t\t}\n\n\t\tif (ii == nn_objs)\n\t\t\tbreak;\n\t\tsc_file_free(file);\n\t\tfile = NULL;\n\t}\n\n\tif (indx == MAX_DATA_OBJS)\n\t\tLOG_TEST_GOTO_ERR(ctx, SC_ERROR_TOO_MANY_OBJECTS, \"iasecc_store_data_object() too many DATA objects.\");\n\n\tdo  {\n\t\tconst struct sc_acl_entry *acl;\n\n\t\tmemset(object->access_rules, 0, sizeof(object->access_rules));\n\n\t\tobject->access_rules[0].access_mode = SC_PKCS15_ACCESS_RULE_MODE_READ;\n\t\tacl = sc_file_get_acl_entry(file, SC_AC_OP_READ);\n\t\tsc_log(ctx, \"iasecc_store_data_object() READ method %i\", acl->method);\n\t\tif (acl->method == SC_AC_IDA)\n\t\t\tiasecc_reference_to_pkcs15_id (acl->key_ref, &object->access_rules[0].auth_id);\n\n\t\tobject->access_rules[1].access_mode = SC_PKCS15_ACCESS_RULE_MODE_UPDATE;\n\t\tacl = sc_file_get_acl_entry(file, SC_AC_OP_UPDATE);\n\t\tsc_log(ctx, \"iasecc_store_data_object() UPDATE method %i\", acl->method);\n\t\tif (acl->method == SC_AC_IDA)\n\t\t\tiasecc_reference_to_pkcs15_id (acl->key_ref, &object->access_rules[1].auth_id);\n\n\t\tobject->access_rules[2].access_mode = SC_PKCS15_ACCESS_RULE_MODE_DELETE;\n\t\tacl = sc_file_get_acl_entry(file, SC_AC_OP_DELETE);\n\t\tsc_log(ctx, \"iasecc_store_data_object() UPDATE method %i\", acl->method);\n\t\tif (acl->method == SC_AC_IDA)\n\t\t\tiasecc_reference_to_pkcs15_id (acl->key_ref, &object->access_rules[2].auth_id);\n\n\t} while(0);\n\n\trv = iasecc_file_convert_acls(ctx, profile, file);\n\tLOG_TEST_GOTO_ERR(ctx, rv, \"iasecc_store_data_object() cannot convert profile ACLs\");\n\n\trv = sc_profile_get_parent(profile, \"public-data\", &parent);\n\tLOG_TEST_GOTO_ERR(ctx, rv, \"iasecc_store_data_object() cannot get object parent\");\n\tsc_log(ctx, \"iasecc_store_data_object() parent path '%s'\\n\", sc_print_path(&parent->path));\n\n\trv = sc_select_file(card, &parent->path, NULL);\n\tLOG_TEST_GOTO_ERR(ctx, rv, \"iasecc_store_data_object() cannot select parent\");\n\n\trv = sc_select_file(card, &file->path, &cfile);\n\tif (!rv)   {\n\t\trv = sc_pkcs15init_authenticate(profile, p15card, cfile, SC_AC_OP_DELETE);\n\t\tLOG_TEST_GOTO_ERR(ctx, rv, \"iasecc_store_data_object() DELETE authentication failed\");\n\n\t\trv = iasecc_pkcs15_delete_file(p15card, profile, cfile);\n\t\tLOG_TEST_GOTO_ERR(ctx, rv, \"s_pkcs15init_store_data_object() delete pkcs15 file error\");\n\t}\n\telse if (rv != SC_ERROR_FILE_NOT_FOUND)   {\n\t\tLOG_TEST_GOTO_ERR(ctx, rv, \"iasecc_store_data_object() select file error\");\n\t}\n\n\trv = sc_pkcs15init_authenticate(profile, p15card, parent, SC_AC_OP_CREATE);\n\tLOG_TEST_GOTO_ERR(ctx, rv, \"iasecc_store_data_object() parent CREATE authentication failed\");\n\n\tfile->size = data->len;\n\trv = sc_create_file(card, file);\n\tLOG_TEST_GOTO_ERR(ctx, rv, \"iasecc_store_data_object() cannot create DATA file\");\n\n\trv = sc_pkcs15init_authenticate(profile, p15card, file, SC_AC_OP_UPDATE);\n\tLOG_TEST_GOTO_ERR(ctx, rv, \"iasecc_store_data_object() data file UPDATE authentication failed\");\n\n\trv = sc_update_binary(card, 0, data->value, data->len, 0);\n\tLOG_TEST_GOTO_ERR(ctx, rv, \"iasecc_store_data_object() update DATA file failed\");\n\n\tif (path)\n\t\t*path = file->path;\nerr:\n\tsc_file_free(parent);\n\tsc_file_free(file);\n\tsc_file_free(cfile);\n\n\tLOG_FUNC_RETURN(ctx, rv);\n#undef MAX_DATA_OBJS\n}\n\nstatic int\niasecc_emu_store_data(struct sc_pkcs15_card *p15card, struct sc_profile *profile,\n\t\tstruct sc_pkcs15_object *object,\n\t\tstruct sc_pkcs15_der *data, struct sc_path *path)\n\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tint rv = SC_ERROR_NOT_IMPLEMENTED;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tswitch (object->type & SC_PKCS15_TYPE_CLASS_MASK) {\n\tcase SC_PKCS15_TYPE_PRKEY:\n\t\trv = iasecc_store_prvkey(p15card, profile, object, data, path);\n\t\tbreak;\n\tcase SC_PKCS15_TYPE_PUBKEY:\n\t\trv = iasecc_store_pubkey(p15card, profile, object, data, path);\n\t\tbreak;\n\tcase SC_PKCS15_TYPE_CERT:\n\t\trv = iasecc_store_cert(p15card, profile, object, data, path);\n\t\tbreak;\n\tcase SC_PKCS15_TYPE_DATA_OBJECT:\n\t\trv = iasecc_store_data_object(p15card, profile, object, data, path);\n\t\tbreak;\n\tdefault:\n\t\trv = SC_ERROR_NOT_IMPLEMENTED;\n\t\tbreak;\n\t}\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\nstatic int\nsc_pkcs15init_store_data(struct sc_pkcs15_card *p15card, struct sc_profile *profile,\n\t\tstruct sc_pkcs15_object *object, struct sc_pkcs15_der *data,\n\t\tstruct sc_path *path)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_file\t*file = NULL;\n\tint\t\tr;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tif (profile->ops->emu_store_data)   {\n\t\tr = profile->ops->emu_store_data(p15card, profile, object, data, path);\n\t\tif (r == SC_SUCCESS || r != SC_ERROR_NOT_IMPLEMENTED)\n\t\t\tLOG_FUNC_RETURN(ctx, r);\n\t}\n\n\tr = select_object_path(p15card, profile, object, path);\n\tLOG_TEST_RET(ctx, r, \"Failed to select object path\");\n\n\tr = sc_profile_get_file_by_path(profile, path, &file);\n\tLOG_TEST_RET(ctx, r, \"Failed to get file by path\");\n\n\tif (file->path.count == 0) {\n\t\tfile->path.index = 0;\n\t\tfile->path.count = -1;\n\t}\n\n\tr = sc_pkcs15init_delete_by_path(profile, p15card, &file->path);\n\tif (r && r != SC_ERROR_FILE_NOT_FOUND) {\n\t\tsc_file_free(file);\n\t\tLOG_TEST_RET(ctx, r, \"Cannot delete file\");\n\t}\n\n\tr = sc_pkcs15init_update_file(profile, p15card, file, data->value, data->len);\n\n\t*path = file->path;\n\n\tsc_file_free(file);\n\tLOG_FUNC_RETURN(ctx, r);\n}\n\nint\nsc_pkcs15init_store_data_object(struct sc_pkcs15_card *p15card,\n\t\tstruct sc_profile *profile,\n\t\tstruct sc_pkcs15init_dataargs *args,\n\t\tstruct sc_pkcs15_object **res_obj)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_pkcs15_data_info *data_object_info;\n\tstruct sc_pkcs15_object *object;\n\tstruct sc_pkcs15_object *objs[32];\n\tconst char\t*label;\n\tint\t\tr, i;\n\tunsigned int    tid = 0x01;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (!profile)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, \"Missing profile\");\n\tlabel = args->label;\n\n\tif (!args->id.len) {\n\t\t/* Select an ID if the user didn't specify one, otherwise\n\t\t * make sure it's unique (even though data objects doesn't\n\t\t * have a pkcs15 id we need one here to create a unique\n\t\t * file id from the data file template */\n\t\tr = sc_pkcs15_get_objects(p15card, SC_PKCS15_TYPE_DATA_OBJECT, objs, 32);\n\t\tLOG_TEST_RET(ctx, r, \"Get 'DATA' objects error\");\n\n\t\tfor (i = 0; i < r; i++) {\n\t\t\tunsigned char cid;\n\t\t\tstruct sc_pkcs15_data_info *cinfo = (struct sc_pkcs15_data_info *) objs[i]->data;\n\t\t\tif (!cinfo->path.len)\n\t\t\t\tcontinue;\n\t\t\tcid = cinfo->path.value[cinfo->path.len - 1];\n\t\t\tif (cid >= tid)\n\t\t\t\ttid = cid + 1;\n\t\t}\n\t\tif (tid > 0xff)\n\t\t\t/* too many data objects ... */\n\t\t\treturn SC_ERROR_TOO_MANY_OBJECTS;\n\t\targs->id.len = 1;\n\t\targs->id.value[0] = tid;\n\t}\n\telse   {\n\t\t/* in case the user specifies an id it should be at most\n\t\t * one byte long */\n\t\tif (args->id.len > 1)\n\t\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\n\tobject = sc_pkcs15init_new_object(SC_PKCS15_TYPE_DATA_OBJECT, label, &args->auth_id, NULL);\n\tif (object == NULL)\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\n\tdata_object_info = (struct sc_pkcs15_data_info *) object->data;\n\tif (args->app_label != NULL)\n\t\tstrlcpy(data_object_info->app_label, args->app_label, sizeof(data_object_info->app_label));\n\telse if (label != NULL)\n\t\tstrlcpy(data_object_info->app_label, label, sizeof(data_object_info->app_label));\n\n\tdata_object_info->app_oid = args->app_oid;\n\tsc_der_copy(&data_object_info->data, &args->der_encoded);\n\n\tr = sc_pkcs15init_store_data(p15card, profile, object, &args->der_encoded, &data_object_info->path);\n\tLOG_TEST_GOTO_ERR(ctx, r, \"Store 'DATA' object error\");\n\n\t/* Now update the DDF */\n\tr = sc_pkcs15init_add_object(p15card, profile, SC_PKCS15_DODF, object);\n\tLOG_TEST_GOTO_ERR(ctx, r, \"'DODF' update error\");\n\n\tif (r >= 0 && res_obj)\n\t\t*res_obj = object;\n\tobject = NULL;\n\n\tprofile->dirty = 1;\n\nerr:\n\tsc_pkcs15_free_object(object);\n\tLOG_FUNC_RETURN(ctx, r);\n}\n\nvoid do_store_data_object(struct sc_profile *profile, struct sc_pkcs15_card *p15card, sc_card_t *card,\n                          uint8_t *buf, size_t len)\n{\n    struct sc_pkcs15init_dataargs args;\n    char value[SC_MAX_OBJECT_ID_OCTETS];\n\n    memcpy(value, buf, SC_MAX_OBJECT_ID_OCTETS);\n    value[len < SC_MAX_OBJECT_ID_OCTETS ? len : SC_MAX_OBJECT_ID_OCTETS - 1] = '\\0';\n\n    memset(&args, 0, sizeof(args));\n    sc_init_oid(&args.app_oid);\n    args.label = \"label\";\n    args.app_label = \"pkcs15-init\";\n\n    sc_format_oid(&args.app_oid, value);\n\n    args.der_encoded.value = buf;\n    args.der_encoded.len = len;\n    sc_pkcs15init_store_data_object(p15card, profile, &args, NULL);\n}\n\n\n// target function\nstatic int\niasecc_delete_file(struct sc_card *card, const struct sc_path *path)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tconst struct sc_acl_entry *entry = NULL;\n\tstruct sc_apdu apdu;\n\tstruct sc_file *file = NULL;\n\tint rv;\n\tunsigned int file_id;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_print_cache(card);\n\n\trv = iasecc_select_file(card, path, &file);\n\tif (rv == SC_ERROR_FILE_NOT_FOUND)\n\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\tLOG_TEST_RET(ctx, rv, \"Cannot select file to delete\");\n\n\tentry = sc_file_get_acl_entry(file, SC_AC_OP_DELETE);\n\n\tfile_id = file->id;\n\tsc_file_free(file);\n\n\tif (!entry)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_OBJECT_NOT_FOUND, \"Cannot delete file: no 'DELETE' acl\");\n\n\tsc_log(ctx, \"DELETE method/reference %X/%X\", entry->method, entry->key_ref);\n\tif (entry->method == SC_AC_SCB && (entry->key_ref & IASECC_SCB_METHOD_SM))   {\n\t\tunsigned char se_num = entry->key_ref & IASECC_SCB_METHOD_MASK_REF;\n\t\trv = iasecc_sm_delete_file(card, se_num, file_id);\n\t}\n\telse   {\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_1, 0xE4, 0x00, 0x00);\n\n\t\trv = sc_transmit_apdu(card, &apdu);\n\t\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\t\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\tLOG_TEST_RET(ctx, rv, \"Delete file failed\");\n\n\t\tif (card->cache.valid) {\n\t\t\tsc_file_free(card->cache.current_ef);\n\t\t}\n\t\tcard->cache.current_ef = NULL;\n\t}\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n",
    "target": 1,
    "idx": 1065684,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "// context\nstatic zend_always_inline uint32_t zend_gc_addref(zend_refcounted_h *p) {\n\tZEND_RC_MOD_CHECK(p);\n\treturn ++(p->refcount);\n}\n\n\n\nstatic void zend_generator_dtor_storage(zend_object *object) /* {{{ */\n{\n\tzend_generator *generator = (zend_generator*) object;\n\tzend_execute_data *ex = generator->execute_data;\n\tuint32_t op_num, try_catch_offset;\n\tint i;\n\n\t/* leave yield from mode to properly allow finally execution */\n\tif (UNEXPECTED(Z_TYPE(generator->values) != IS_UNDEF)) {\n\t\tzval_ptr_dtor(&generator->values);\n\t\tZVAL_UNDEF(&generator->values);\n\t}\n\n\tzend_generator *parent = generator->node.parent;\n\tif (parent) {\n\t\tzend_generator_remove_child(&parent->node, generator);\n\t\tclear_link_to_root(generator);\n\t\tgenerator->node.parent = NULL;\n\t\tOBJ_RELEASE(&parent->std);\n\t} else {\n\t\tclear_link_to_leaf(generator);\n\t}\n\n\tif (EXPECTED(!ex) || EXPECTED(!(ex->func->op_array.fn_flags & ZEND_ACC_HAS_FINALLY_BLOCK))\n\t\t\t|| CG(unclean_shutdown)) {\n\t\treturn;\n\t}\n\n\t/* -1 required because we want the last run opcode, not the\n\t * next to-be-run one. */\n\top_num = ex->opline - ex->func->op_array.opcodes - 1;\n\ttry_catch_offset = -1;\n\n\t/* Find the innermost try/catch that we are inside of. */\n\tfor (i = 0; i < ex->func->op_array.last_try_catch; i++) {\n\t\tzend_try_catch_element *try_catch = &ex->func->op_array.try_catch_array[i];\n\t\tif (op_num < try_catch->try_op) {\n\t\t\tbreak;\n\t\t}\n\t\tif (op_num < try_catch->catch_op || op_num < try_catch->finally_end) {\n\t\t\ttry_catch_offset = i;\n\t\t}\n\t}\n\n\t/* Walk try/catch/finally structures upwards, performing the necessary actions. */\n\twhile (try_catch_offset != (uint32_t) -1) {\n\t\tzend_try_catch_element *try_catch = &ex->func->op_array.try_catch_array[try_catch_offset];\n\n\t\tif (op_num < try_catch->finally_op) {\n\t\t\t/* Go to finally block */\n\t\t\tzval *fast_call =\n\t\t\t\tZEND_CALL_VAR(ex, ex->func->op_array.opcodes[try_catch->finally_end].op1.var);\n\n\t\t\tzend_generator_cleanup_unfinished_execution(generator, ex, try_catch->finally_op);\n\t\t\tZ_OBJ_P(fast_call) = EG(exception);\n\t\t\tEG(exception) = NULL;\n\t\t\tZ_OPLINE_NUM_P(fast_call) = (uint32_t)-1;\n\n\t\t\tex->opline = &ex->func->op_array.opcodes[try_catch->finally_op];\n\t\t\tgenerator->flags |= ZEND_GENERATOR_FORCED_CLOSE;\n\t\t\tzend_generator_resume(generator);\n\n\t\t\t/* TODO: If we hit another yield inside try/finally,\n\t\t\t * should we also jump to the next finally block? */\n\t\t\treturn;\n\t\t} else if (op_num < try_catch->finally_end) {\n\t\t\tzval *fast_call =\n\t\t\t\tZEND_CALL_VAR(ex, ex->func->op_array.opcodes[try_catch->finally_end].op1.var);\n\t\t\t/* Clean up incomplete return statement */\n\t\t\tif (Z_OPLINE_NUM_P(fast_call) != (uint32_t) -1) {\n\t\t\t\tzend_op *retval_op = &ex->func->op_array.opcodes[Z_OPLINE_NUM_P(fast_call)];\n\t\t\t\tif (retval_op->op2_type & (IS_TMP_VAR | IS_VAR)) {\n\t\t\t\t\tzval_ptr_dtor(ZEND_CALL_VAR(ex, retval_op->op2.var));\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Clean up backed-up exception */\n\t\t\tif (Z_OBJ_P(fast_call)) {\n\t\t\t\tOBJ_RELEASE(Z_OBJ_P(fast_call));\n\t\t\t}\n\t\t}\n\n\t\ttry_catch_offset--;\n\t}\n}\n\nstatic void zend_generator_dtor_storage(zend_object *object) /* {{{ */\n{\n\tzend_generator *generator = (zend_generator*) object;\n\tzend_execute_data *ex = generator->execute_data;\n\tuint32_t op_num, try_catch_offset;\n\tint i;\n\n\t/* leave yield from mode to properly allow finally execution */\n\tif (UNEXPECTED(Z_TYPE(generator->values) != IS_UNDEF)) {\n\t\tzval_ptr_dtor(&generator->values);\n\t\tZVAL_UNDEF(&generator->values);\n\t}\n\n\tzend_generator *parent = generator->node.parent;\n\tif (parent) {\n\t\tzend_generator_remove_child(&parent->node, generator);\n\t\tclear_link_to_root(generator);\n\t\tgenerator->node.parent = NULL;\n\t\tOBJ_RELEASE(&parent->std);\n\t} else {\n\t\tclear_link_to_leaf(generator);\n\t}\n\n\tif (EXPECTED(!ex) || EXPECTED(!(ex->func->op_array.fn_flags & ZEND_ACC_HAS_FINALLY_BLOCK))\n\t\t\t|| CG(unclean_shutdown)) {\n\t\treturn;\n\t}\n\n\t/* -1 required because we want the last run opcode, not the\n\t * next to-be-run one. */\n\top_num = ex->opline - ex->func->op_array.opcodes - 1;\n\ttry_catch_offset = -1;\n\n\t/* Find the innermost try/catch that we are inside of. */\n\tfor (i = 0; i < ex->func->op_array.last_try_catch; i++) {\n\t\tzend_try_catch_element *try_catch = &ex->func->op_array.try_catch_array[i];\n\t\tif (op_num < try_catch->try_op) {\n\t\t\tbreak;\n\t\t}\n\t\tif (op_num < try_catch->catch_op || op_num < try_catch->finally_end) {\n\t\t\ttry_catch_offset = i;\n\t\t}\n\t}\n\n\t/* Walk try/catch/finally structures upwards, performing the necessary actions. */\n\twhile (try_catch_offset != (uint32_t) -1) {\n\t\tzend_try_catch_element *try_catch = &ex->func->op_array.try_catch_array[try_catch_offset];\n\n\t\tif (op_num < try_catch->finally_op) {\n\t\t\t/* Go to finally block */\n\t\t\tzval *fast_call =\n\t\t\t\tZEND_CALL_VAR(ex, ex->func->op_array.opcodes[try_catch->finally_end].op1.var);\n\n\t\t\tzend_generator_cleanup_unfinished_execution(generator, ex, try_catch->finally_op);\n\t\t\tZ_OBJ_P(fast_call) = EG(exception);\n\t\t\tEG(exception) = NULL;\n\t\t\tZ_OPLINE_NUM_P(fast_call) = (uint32_t)-1;\n\n\t\t\tex->opline = &ex->func->op_array.opcodes[try_catch->finally_op];\n\t\t\tgenerator->flags |= ZEND_GENERATOR_FORCED_CLOSE;\n\t\t\tzend_generator_resume(generator);\n\n\t\t\t/* TODO: If we hit another yield inside try/finally,\n\t\t\t * should we also jump to the next finally block? */\n\t\t\treturn;\n\t\t} else if (op_num < try_catch->finally_end) {\n\t\t\tzval *fast_call =\n\t\t\t\tZEND_CALL_VAR(ex, ex->func->op_array.opcodes[try_catch->finally_end].op1.var);\n\t\t\t/* Clean up incomplete return statement */\n\t\t\tif (Z_OPLINE_NUM_P(fast_call) != (uint32_t) -1) {\n\t\t\t\tzend_op *retval_op = &ex->func->op_array.opcodes[Z_OPLINE_NUM_P(fast_call)];\n\t\t\t\tif (retval_op->op2_type & (IS_TMP_VAR | IS_VAR)) {\n\t\t\t\t\tzval_ptr_dtor(ZEND_CALL_VAR(ex, retval_op->op2.var));\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Clean up backed-up exception */\n\t\t\tif (Z_OBJ_P(fast_call)) {\n\t\t\t\tOBJ_RELEASE(Z_OBJ_P(fast_call));\n\t\t\t}\n\t\t}\n\n\t\ttry_catch_offset--;\n\t}\n}\n\nZEND_API void ZEND_FASTCALL zend_objects_store_call_destructors(zend_objects_store *objects)\n{\n\tEG(flags) |= EG_FLAGS_OBJECT_STORE_NO_REUSE;\n\tif (objects->top > 1) {\n\t\tuint32_t i;\n\t\tfor (i = 1; i < objects->top; i++) {\n\t\t\tzend_object *obj = objects->object_buckets[i];\n\t\t\tif (IS_OBJ_VALID(obj)) {\n\t\t\t\tif (!(OBJ_FLAGS(obj) & IS_OBJ_DESTRUCTOR_CALLED)) {\n\t\t\t\t\tGC_ADD_FLAGS(obj, IS_OBJ_DESTRUCTOR_CALLED);\n\n\t\t\t\t\tif (obj->handlers->dtor_obj != zend_objects_destroy_object\n\t\t\t\t\t\t\t|| obj->ce->destructor) {\n\t\t\t\t\t\tGC_ADDREF(obj);\n\t\t\t\t\t\tobj->handlers->dtor_obj(obj);\n\t\t\t\t\t\tGC_DELREF(obj);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid shutdown_destructors(void) /* {{{ */\n{\n\tif (CG(unclean_shutdown)) {\n\t\tEG(symbol_table).pDestructor = zend_unclean_zval_ptr_dtor;\n\t}\n\tzend_try {\n\t\tuint32_t symbols;\n\t\tdo {\n\t\t\tsymbols = zend_hash_num_elements(&EG(symbol_table));\n\t\t\tzend_hash_reverse_apply(&EG(symbol_table), (apply_func_t) zval_call_destructor);\n\t\t} while (symbols != zend_hash_num_elements(&EG(symbol_table)));\n\t\tzend_objects_store_call_destructors(&EG(objects_store));\n\t} zend_catch {\n\nvoid zend_call_destructors(void) /* {{{ */\n{\n\tzend_try {\n\t\tshutdown_destructors();\n\t} zend_end_try();\n\nvoid php_request_shutdown(void *dummy)\n{\n\tzend_bool report_memleaks;\n\n\tEG(flags) |= EG_FLAGS_IN_SHUTDOWN;\n\n\treport_memleaks = PG(report_memleaks);\n\n\t/* EG(current_execute_data) points into nirvana and therefore cannot be safely accessed\n\t * inside zend_executor callback functions.\n\t */\n\tEG(current_execute_data) = NULL;\n\n\tphp_deactivate_ticks();\n\n\t/* 1. Call all possible shutdown functions registered with register_shutdown_function() */\n\tif (PG(modules_activated)) {\n\t\tphp_call_shutdown_functions();\n\t}\n\n\t/* 2. Call all possible __destruct() functions */\n\tzend_try {\n\t\tzend_call_destructors();\n\t} zend_end_try();\n\nvoid fuzzer_request_shutdown()\n{\n\tzend_try {\n\t\t/* Destroy thrown exceptions. This does not happen as part of request shutdown. */\n\t\tif (EG(exception)) {\n\t\t\tzend_object_release(EG(exception));\n\t\t\tEG(exception) = NULL;\n\t\t}\n\n\t\t/* Some fuzzers (like unserialize) may create circular structures. Make sure we free them.\n\t\t * Two calls are performed to handle objects with destructors. */\n\t\tzend_gc_collect_cycles();\n\t\tzend_gc_collect_cycles();\n\t} zend_end_try();\n\nint fuzzer_do_request_from_buffer(\n\t\tchar *filename, const char *data, size_t data_len, zend_bool execute)\n{\n\tint retval = FAILURE; /* failure by default */\n\n\tSG(options) |= SAPI_OPTION_NO_CHDIR;\n\tSG(request_info).argc=0;\n\tSG(request_info).argv=NULL;\n\n\tif (fuzzer_request_startup() == FAILURE) {\n\t\treturn FAILURE;\n\t}\n\n\t// Commented out to avoid leaking the header callback.\n\t//SG(headers_sent) = 1;\n\t//SG(request_info).no_headers = 1;\n\tphp_register_variable(\"PHP_SELF\", filename, NULL);\n\n\tzend_first_try {\n\t\tzend_file_handle file_handle;\n\t\tzend_stream_init_filename(&file_handle, filename);\n\t\tfile_handle.buf = estrndup(data, data_len);\n\t\tfile_handle.len = data_len;\n\n\t\tzend_op_array *op_array = zend_compile_file(&file_handle, ZEND_REQUIRE);\n\t\tif (op_array) {\n\t\t\tif (execute) {\n\t\t\t\tzend_execute(op_array, NULL);\n\t\t\t}\n\t\t\tdestroy_op_array(op_array);\n\t\t\tefree(op_array);\n\t\t}\n\t} zend_end_try();\n\n\n// target function\nstatic void zend_generator_update_leaf_of_child(zend_generator_node *node, zend_generator *from_leaf, zend_generator *to_leaf)\n{\n\tZEND_ASSERT(node->children >= 1);\n\tif (node->ptr.leaf == from_leaf) {\n\t\tnode->ptr.leaf = to_leaf;\n\t}\n\tif (node->children == 1) {\n\t\tnode->child.single.leaf = to_leaf;\n\t} else {\n\t\tHashTable *ht = node->child.ht;\n\t\tzend_generator *child = zend_hash_index_find_ptr(ht, (zend_ulong) from_leaf);\n\t\tZEND_ASSERT(child != NULL);\n\t\tzend_hash_index_del(ht, (zend_ulong) from_leaf);\n\t\tzend_hash_index_add_ptr(ht, (zend_ulong) to_leaf, child);\n\t}\n}\nstatic void zend_generator_remove_leaf_child(zend_generator_node *node, zend_generator *leaf, zend_generator *replace_leaf) {\n\tif (node->children > 1) {\n\t\tHashTable *ht = node->child.ht;\n\t\tzend_ulong child_leaf;\n\t\tzend_generator *child_generator;\n\t\tzend_hash_index_del(ht, (zend_ulong) leaf);\n\t\tif (--node->children == 1) {\n\t\t\tZEND_HASH_FOREACH_NUM_KEY_PTR(ht, child_leaf, child_generator) {\n\t\t\t\tnode->child.single.leaf = (zend_generator *) child_leaf;\n\t\t\t\tnode->child.single.child = child_generator;\n\t\t\t\tif (node->ptr.leaf == leaf) {\n\t\t\t\t\tnode->ptr.leaf = (zend_generator *) child_leaf;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t} ZEND_HASH_FOREACH_END();\n\t\t\tzend_hash_destroy(ht);\n\t\t\tefree(ht);\n\t\t} else if (node->ptr.leaf == leaf) {\n\t\t\tZEND_HASH_FOREACH_NUM_KEY_PTR(ht, child_leaf, child_generator) {\n\t\t\t\tnode->ptr.leaf = (zend_generator *) child_leaf;\n\t\t\t\tbreak;\n\t\t\t} ZEND_HASH_FOREACH_END();\n\t\t}\n\t} else if (node->ptr.leaf == leaf) {\n\t\tZEND_ASSERT(replace_leaf != leaf);\n\t\tnode->ptr.leaf = replace_leaf;\n\t}\n}\nstatic void zend_generator_dtor_storage(zend_object *object) /* {{{ */\n{\n\tzend_generator *generator = (zend_generator*) object;\n\tzend_execute_data *ex = generator->execute_data;\n\tuint32_t op_num, try_catch_offset;\n\tint i;\n\n\t/* leave yield from mode to properly allow finally execution */\n\tif (UNEXPECTED(Z_TYPE(generator->values) != IS_UNDEF)) {\n\t\tzval_ptr_dtor(&generator->values);\n\t\tZVAL_UNDEF(&generator->values);\n\t}\n\n\tif (UNEXPECTED(generator->node.children != 0) && generator->node.parent) {\n\t\t/* we're called out of order - this must only happen during shutdown sequence: we call our (direct) child nodes destructors first, to clean it from the bottom up */\n\t\twhile (generator->node.children != 0) {\n\t\t\tzend_generator *child;\n\t\t\tif (generator->node.children == 1) {\n\t\t\t\tchild = generator->node.child.single.child;\n\t\t\t} else {\n\t\t\t\tchild = (zend_generator *) Z_PTR_P(zend_hash_get_current_data(generator->node.child.ht));\n\t\t\t}\n\t\t\tGC_ADD_FLAGS(&child->std, IS_OBJ_DESTRUCTOR_CALLED);\n\t\t\tGC_ADDREF(&child->std); /* must not be released during destructor */\n\t\t\tzend_generator_dtor_storage(&child->std);\n\t\t\tOBJ_RELEASE(&child->std);\n\t\t}\n\t}\n\tif (EXPECTED(generator->node.children == 0)) {\n\t\tzend_generator_update_current(generator, generator); /* ensure we remove it from a *live* root */\n\t\tzend_generator *root = generator->node.ptr.root, *parent = generator->node.parent, *next, *toproot = root;\n\t\tif (parent) {\n\t\t\tzend_bool parent_becomes_leaf = parent->node.children == 1;\n\t\t\tif (parent_becomes_leaf) {\n\t\t\t\twhile (UNEXPECTED(root != generator)) {\n\t\t\t\t\tnext = zend_generator_get_child(&root->node, generator);\n\t\t\t\t\tzend_generator_update_leaf_of_child(&root->node, generator, parent);\n\t\t\t\t\troot = next;\n\t\t\t\t}\n\t\t\t\tparent->node.ptr.root = toproot;\n\t\t\t\tparent->node.children = 0;\n\t\t\t} else {\n\t\t\t\tzend_generator_remove_leaf_child(&parent->node, generator, NULL);\n\t\t\t\twhile (UNEXPECTED(root != parent)) {\n\t\t\t\t\tnext = zend_generator_get_child(&root->node, generator);\n\t\t\t\t\tzend_generator_remove_leaf_child(&root->node, generator, parent->node.ptr.leaf);\n\t\t\t\t\tOBJ_RELEASE(&root->std);\n\t\t\t\t\troot = next;\n\t\t\t\t}\n\t\t\t}\n\t\t\tOBJ_RELEASE(&parent->std);\n\t\t\t/* Reset for resuming in finally */\n\t\t\tgenerator->node.parent = NULL;\n\t\t\tgenerator->node.ptr.root = generator;\n\t\t}\n\t}\n\n\tif (EXPECTED(!ex) || EXPECTED(!(ex->func->op_array.fn_flags & ZEND_ACC_HAS_FINALLY_BLOCK))\n\t\t\t|| CG(unclean_shutdown)) {\n\t\treturn;\n\t}\n\n\t/* -1 required because we want the last run opcode, not the\n\t * next to-be-run one. */\n\top_num = ex->opline - ex->func->op_array.opcodes - 1;\n\ttry_catch_offset = -1;\n\n\t/* Find the innermost try/catch that we are inside of. */\n\tfor (i = 0; i < ex->func->op_array.last_try_catch; i++) {\n\t\tzend_try_catch_element *try_catch = &ex->func->op_array.try_catch_array[i];\n\t\tif (op_num < try_catch->try_op) {\n\t\t\tbreak;\n\t\t}\n\t\tif (op_num < try_catch->catch_op || op_num < try_catch->finally_end) {\n\t\t\ttry_catch_offset = i;\n\t\t}\n\t}\n\n\t/* Walk try/catch/finally structures upwards, performing the necessary actions. */\n\twhile (try_catch_offset != (uint32_t) -1) {\n\t\tzend_try_catch_element *try_catch = &ex->func->op_array.try_catch_array[try_catch_offset];\n\n\t\tif (op_num < try_catch->finally_op) {\n\t\t\t/* Go to finally block */\n\t\t\tzval *fast_call =\n\t\t\t\tZEND_CALL_VAR(ex, ex->func->op_array.opcodes[try_catch->finally_end].op1.var);\n\n\t\t\tzend_generator_cleanup_unfinished_execution(generator, ex, try_catch->finally_op);\n\t\t\tZ_OBJ_P(fast_call) = EG(exception);\n\t\t\tEG(exception) = NULL;\n\t\t\tZ_OPLINE_NUM_P(fast_call) = (uint32_t)-1;\n\n\t\t\tex->opline = &ex->func->op_array.opcodes[try_catch->finally_op];\n\t\t\tgenerator->flags |= ZEND_GENERATOR_FORCED_CLOSE;\n\t\t\tzend_generator_resume(generator);\n\n\t\t\t/* TODO: If we hit another yield inside try/finally,\n\t\t\t * should we also jump to the next finally block? */\n\t\t\treturn;\n\t\t} else if (op_num < try_catch->finally_end) {\n\t\t\tzval *fast_call =\n\t\t\t\tZEND_CALL_VAR(ex, ex->func->op_array.opcodes[try_catch->finally_end].op1.var);\n\t\t\t/* Clean up incomplete return statement */\n\t\t\tif (Z_OPLINE_NUM_P(fast_call) != (uint32_t) -1) {\n\t\t\t\tzend_op *retval_op = &ex->func->op_array.opcodes[Z_OPLINE_NUM_P(fast_call)];\n\t\t\t\tif (retval_op->op2_type & (IS_TMP_VAR | IS_VAR)) {\n\t\t\t\t\tzval_ptr_dtor(ZEND_CALL_VAR(ex, retval_op->op2.var));\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Clean up backed-up exception */\n\t\t\tif (Z_OBJ_P(fast_call)) {\n\t\t\t\tOBJ_RELEASE(Z_OBJ_P(fast_call));\n\t\t\t}\n\t\t}\n\n\t\ttry_catch_offset--;\n\t}\n}\nstatic void zend_generator_throw_exception(zend_generator *generator, zval *exception)\n{\n\tzend_execute_data *original_execute_data = EG(current_execute_data);\n\n\t/* if we don't stop an array/iterator yield from, the exception will only reach the generator after the values were all iterated over */\n\tif (UNEXPECTED(Z_TYPE(generator->values) != IS_UNDEF)) {\n\t\tzval_ptr_dtor(&generator->values);\n\t\tZVAL_UNDEF(&generator->values);\n\t}\n\n\t/* Throw the exception in the context of the generator. Decrementing the opline\n\t * to pretend the exception happened during the YIELD opcode. */\n\tEG(current_execute_data) = generator->execute_data;\n\tgenerator->execute_data->opline--;\n\tif (exception) {\n\t\tzend_throw_exception_object(exception);\n\t} else {\n\t\tzend_rethrow_exception(EG(current_execute_data));\n\t}\n\tgenerator->execute_data->opline++;\n\tEG(current_execute_data) = original_execute_data;\n}\nstatic void zend_generator_add_single_child(zend_generator_node *node, zend_generator *child, zend_generator *leaf)\n{\n\tif (node->children == 0) {\n\t\tnode->child.single.leaf = leaf;\n\t\tnode->child.single.child = child;\n\t} else {\n\t\tif (node->children == 1) {\n\t\t\tHashTable *ht = emalloc(sizeof(HashTable));\n\t\t\tzend_hash_init(ht, 0, NULL, NULL, 0);\n\t\t\tzend_hash_index_add_ptr(ht,\n\t\t\t\t(zend_ulong) node->child.single.leaf, node->child.single.child);\n\t\t\tnode->child.ht = ht;\n\t\t}\n\n\t\tif (zend_hash_index_add_ptr(node->child.ht, (zend_ulong) leaf, child) == NULL) {\n\t\t\tZEND_ASSERT(node->children > 1);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t++node->children;\n}\nstatic void zend_generator_merge_child_nodes(zend_generator_node *dest, zend_generator_node *src, zend_generator *child)\n{\n\tzend_ulong leaf;\n\tZEND_ASSERT(src->children > 1);\n\tZEND_HASH_FOREACH_NUM_KEY(src->child.ht, leaf) {\n\t\tzend_generator_add_single_child(dest, child, (zend_generator *) leaf);\n\t} ZEND_HASH_FOREACH_END();\n}\nstatic void zend_generator_add_child(zend_generator *generator, zend_generator *child)\n{\n\tzend_generator *leaf = child->node.children ? child->node.ptr.leaf : child;\n\tzend_generator_node *multi_children_node;\n\tzend_bool was_leaf = generator->node.children == 0;\n\n\tif (was_leaf) {\n\t\tzend_generator *next = generator->node.parent;\n\t\tleaf->node.ptr.root = generator->node.ptr.root;\n\t\tGC_ADDREF(&generator->std); /* we need to increment the generator refcount here as it became integrated into the tree (no leaf), but we must not increment the refcount of the *whole* path in tree */\n\t\tgenerator->node.ptr.leaf = leaf;\n\n\t\twhile (next) {\n\t\t\tif (next->node.children > 1) {\n\t\t\t\tzend_generator *child = zend_hash_index_find_ptr(next->node.child.ht, (zend_ulong) generator);\n\t\t\t\tzend_hash_index_del(next->node.child.ht, (zend_ulong) generator);\n\t\t\t\tzend_hash_index_add_ptr(next->node.child.ht, (zend_ulong) leaf, child);\n\t\t\t}\n\n\t\t\tnext->node.ptr.leaf = leaf;\n\t\t\tnext = next->node.parent;\n\t\t}\n\t} else if (generator->node.children == 1) {\n\t\tmulti_children_node = zend_generator_search_multi_children_node(&generator->node);\n\t\tif (multi_children_node) {\n\t\t\tzend_generator_merge_child_nodes(&generator->node, multi_children_node, generator->node.child.single.child);\n\t\t}\n\t}\n\n\tif (!was_leaf) {\n\t\tmulti_children_node = zend_generator_search_multi_children_node(&child->node);\n\t} else {\n\t\tmulti_children_node = (zend_generator_node *) 0x1;\n\t}\n\n\t/* for allowing zend_generator_get_child() to work, we need every multi children node to have ALL its leaf descendents present, linking to their respective child */\n\t{\n\t\tzend_generator *parent = generator->node.parent, *cur = generator;\n\n\t\tif (multi_children_node > (zend_generator_node *) 0x1) {\n\t\t\tzend_generator_merge_child_nodes(&generator->node, multi_children_node, child);\n\t\t} else {\n\t\t\tzend_generator_add_single_child(&generator->node, child, leaf);\n\t\t}\n\t\twhile (parent) {\n\t\t\tif (parent->node.children > 1) {\n\t\t\t\tif (multi_children_node == (zend_generator_node *) 0x1) {\n\t\t\t\t\tmulti_children_node = zend_generator_search_multi_children_node(&child->node);\n\t\t\t\t}\n\t\t\t\tif (multi_children_node) {\n\t\t\t\t\tzend_generator_merge_child_nodes(&parent->node, multi_children_node, cur);\n\t\t\t\t} else {\n\t\t\t\t\tzend_generator_add_single_child(&parent->node, cur, leaf);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur = parent;\n\t\t\tparent = parent->node.parent;\n\t\t}\n\t}\n}\n",
    "target": 1,
    "idx": 1025697,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic int read_chunks_before_idat(spng_ctx *ctx)\n{\n    if(ctx == NULL) return 1;\n    if(ctx->data == NULL) return 1;\n    if(!ctx->valid_state) return SPNG_EBADSTATE;\n\n    int ret, discard = 0;\n    const unsigned char *data;\n    struct spng_chunk chunk;\n\n    chunk.offset = 8;\n    chunk.length = 13;\n    size_t sizeof_sig_ihdr = 29;\n\n    ret = read_data(ctx, sizeof_sig_ihdr);\n    if(ret) return ret;\n\n    data = ctx->data;\n\n    uint8_t signature[8] = { 137, 80, 78, 71, 13, 10, 26, 10 };\n    if(memcmp(data, signature, sizeof(signature))) return SPNG_ESIGNATURE;\n\n    chunk.length = read_u32(data + 8);\n    memcpy(&chunk.type, data + 12, 4);\n\n    if(chunk.length != 13) return SPNG_EIHDR_SIZE;\n    if(memcmp(chunk.type, type_ihdr, 4)) return SPNG_ENOIHDR;\n\n    ctx->cur_actual_crc = crc32(0, NULL, 0);\n    ctx->cur_actual_crc = crc32(ctx->cur_actual_crc, data + 12, 17);\n\n    ctx->ihdr.width = read_u32(data + 16);\n    ctx->ihdr.height = read_u32(data + 20);\n    memcpy(&ctx->ihdr.bit_depth, data + 24, 1);\n    memcpy(&ctx->ihdr.color_type, data + 25, 1);\n    memcpy(&ctx->ihdr.compression_method, data + 26, 1);\n    memcpy(&ctx->ihdr.filter_method, data + 27, 1);\n    memcpy(&ctx->ihdr.interlace_method, data + 28, 1);\n\n    if(!ctx->max_width) ctx->max_width = png_u32max;\n    if(!ctx->max_height) ctx->max_height = png_u32max;\n\n    ret = check_ihdr(&ctx->ihdr, ctx->max_width, ctx->max_height);\n    if(ret) return ret;\n\n    ctx->file.ihdr = 1;\n    ctx->stored.ihdr = 1;\n\n    struct spng_chunk_bitfield stored;\n    memcpy(&stored, &ctx->stored, sizeof(struct spng_chunk_bitfield));\n\n    while( !(ret = read_header(ctx, &discard)))\n    {\n        if(discard)\n        {\n            memcpy(&ctx->stored, &stored, sizeof(struct spng_chunk_bitfield));\n        }\n\n        memcpy(&stored, &ctx->stored, sizeof(struct spng_chunk_bitfield));\n\n        memcpy(&chunk, &ctx->current_chunk, sizeof(struct spng_chunk));\n\n        if(!memcmp(chunk.type, type_idat, 4))\n        {\n            memcpy(&ctx->first_idat, &chunk, sizeof(struct spng_chunk));\n            return 0;\n        }\n\n        if(!chunk_fits_in_cache(ctx, &ctx->chunk_cache_usage))\n        {\n            ret = discard_chunk_bytes(ctx, chunk.length);\n            if(ret) return ret;\n            continue;\n        }\n\n        ret = read_chunk_bytes(ctx, chunk.length);\n        if(ret) return ret;\n\n        data = ctx->data;\n\n        if(is_critical_chunk(&chunk))\n        {\n            if(!memcmp(chunk.type, type_plte, 4))\n            {\n                if(chunk.length % 3 != 0) return SPNG_ECHUNK_SIZE;\n\n                ctx->plte.n_entries = chunk.length / 3;\n\n                if(check_plte(&ctx->plte, &ctx->ihdr)) return SPNG_ECHUNK_SIZE; /* XXX: EPLTE? */\n\n                size_t i;\n                for(i=0; i < ctx->plte.n_entries; i++)\n                {\n                    memcpy(&ctx->plte.entries[i].red,   data + i * 3, 1);\n                    memcpy(&ctx->plte.entries[i].green, data + i * 3 + 1, 1);\n                    memcpy(&ctx->plte.entries[i].blue,  data + i * 3 + 2, 1);\n                }\n\n                ctx->plte_offset = chunk.offset;\n\n                ctx->file.plte = 1;\n            }\n            else if(!memcmp(chunk.type, type_iend, 4)) return SPNG_ECHUNK_POS;\n            else if(!memcmp(chunk.type, type_ihdr, 4)) return SPNG_ECHUNK_POS;\n            else return SPNG_ECHUNK_UNKNOWN_CRITICAL;\n        }\n        else if(!memcmp(chunk.type, type_chrm, 4)) /* Ancillary chunks */\n        {\n            if(ctx->file.plte && chunk.offset > ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.chrm) return SPNG_EDUP_CHRM;\n\n            if(chunk.length != 32) return SPNG_ECHUNK_SIZE;\n\n            ctx->chrm_int.white_point_x = read_u32(data);\n            ctx->chrm_int.white_point_y = read_u32(data + 4);\n            ctx->chrm_int.red_x = read_u32(data + 8);\n            ctx->chrm_int.red_y = read_u32(data + 12);\n            ctx->chrm_int.green_x = read_u32(data + 16);\n            ctx->chrm_int.green_y = read_u32(data + 20);\n            ctx->chrm_int.blue_x = read_u32(data + 24);\n            ctx->chrm_int.blue_y = read_u32(data + 28);\n\n            if(check_chrm_int(&ctx->chrm_int)) return SPNG_ECHRM;\n\n            ctx->file.chrm = 1;\n            ctx->stored.chrm = 1;\n        }\n        else if(!memcmp(chunk.type, type_gama, 4))\n        {\n            if(ctx->file.plte && chunk.offset > ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.gama) return SPNG_EDUP_GAMA;\n\n            if(chunk.length != 4) return SPNG_ECHUNK_SIZE;\n\n            ctx->gama = read_u32(data);\n\n            if(!ctx->gama) return SPNG_EGAMA;\n            if(ctx->gama > png_u32max) return SPNG_EGAMA;\n\n            ctx->file.gama = 1;\n            ctx->stored.gama = 1;\n        }\n        else if(!memcmp(chunk.type, type_iccp, 4))\n        {\n            if(ctx->file.plte && chunk.offset > ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.iccp) return SPNG_EDUP_ICCP;\n            if(!chunk.length) return SPNG_ECHUNK_SIZE;\n\n            continue; /* XXX: https://gitlab.com/randy408/libspng/issues/31 */\n        }\n        else if(!memcmp(chunk.type, type_sbit, 4))\n        {\n            if(ctx->file.plte && chunk.offset > ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.sbit) return SPNG_EDUP_SBIT;\n\n            if(ctx->ihdr.color_type == 0)\n            {\n                if(chunk.length != 1) return SPNG_ECHUNK_SIZE;\n\n                memcpy(&ctx->sbit.grayscale_bits, data, 1);\n            }\n            else if(ctx->ihdr.color_type == 2 || ctx->ihdr.color_type == 3)\n            {\n                if(chunk.length != 3) return SPNG_ECHUNK_SIZE;\n\n                memcpy(&ctx->sbit.red_bits, data, 1);\n                memcpy(&ctx->sbit.green_bits, data + 1 , 1);\n                memcpy(&ctx->sbit.blue_bits, data + 2, 1);\n            }\n            else if(ctx->ihdr.color_type == 4)\n            {\n                if(chunk.length != 2) return SPNG_ECHUNK_SIZE;\n\n                memcpy(&ctx->sbit.grayscale_bits, data, 1);\n                memcpy(&ctx->sbit.alpha_bits, data + 1, 1);\n            }\n            else if(ctx->ihdr.color_type == 6)\n            {\n                if(chunk.length != 4) return SPNG_ECHUNK_SIZE;\n\n                memcpy(&ctx->sbit.red_bits, data, 1);\n                memcpy(&ctx->sbit.green_bits, data + 1, 1);\n                memcpy(&ctx->sbit.blue_bits, data + 2, 1);\n                memcpy(&ctx->sbit.alpha_bits, data + 3, 1);\n            }\n\n            if(check_sbit(&ctx->sbit, &ctx->ihdr)) return SPNG_ESBIT;\n\n            ctx->file.sbit = 1;\n            ctx->stored.sbit = 1;\n        }\n        else if(!memcmp(chunk.type, type_srgb, 4))\n        {\n            if(ctx->file.plte && chunk.offset > ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.srgb) return SPNG_EDUP_SRGB;\n\n            if(chunk.length != 1) return SPNG_ECHUNK_SIZE;\n\n            memcpy(&ctx->srgb_rendering_intent, data, 1);\n\n            if(ctx->srgb_rendering_intent > 3) return SPNG_ESRGB;\n\n            ctx->file.srgb = 1;\n            ctx->stored.srgb = 1;\n        }\n        else if(!memcmp(chunk.type, type_bkgd, 4))\n        {\n            if(ctx->file.plte && chunk.offset < ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.bkgd) return SPNG_EDUP_BKGD;\n\n            uint16_t mask = ~0;\n            if(ctx->ihdr.bit_depth < 16) mask = (1 << ctx->ihdr.bit_depth) - 1;\n\n            if(ctx->ihdr.color_type == 0 || ctx->ihdr.color_type == 4)\n            {\n                if(chunk.length != 2) return SPNG_ECHUNK_SIZE;\n\n                ctx->bkgd.gray = read_u16(data) & mask;\n            }\n            else if(ctx->ihdr.color_type == 2 || ctx->ihdr.color_type == 6)\n            {\n                if(chunk.length != 6) return SPNG_ECHUNK_SIZE;\n\n                ctx->bkgd.red = read_u16(data) & mask;\n                ctx->bkgd.green = read_u16(data + 2) & mask;\n                ctx->bkgd.blue = read_u16(data + 4) & mask;\n            }\n            else if(ctx->ihdr.color_type == 3)\n            {\n                if(chunk.length != 1) return SPNG_ECHUNK_SIZE;\n                if(!ctx->file.plte) return SPNG_EBKGD_NO_PLTE;\n\n                memcpy(&ctx->bkgd.plte_index, data, 1);\n                if(ctx->bkgd.plte_index >= ctx->plte.n_entries) return SPNG_EBKGD_PLTE_IDX;\n            }\n\n            ctx->file.bkgd = 1;\n            ctx->stored.bkgd = 1;\n        }\n        else if(!memcmp(chunk.type, type_trns, 4))\n        {\n            if(ctx->file.plte && chunk.offset < ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.trns) return SPNG_EDUP_TRNS;\n            if(!chunk.length) return SPNG_ECHUNK_SIZE;\n\n            uint16_t mask = ~0;\n            if(ctx->ihdr.bit_depth < 16) mask = (1 << ctx->ihdr.bit_depth) - 1;\n\n            if(ctx->ihdr.color_type == 0)\n            {\n                if(chunk.length != 2) return SPNG_ECHUNK_SIZE;\n\n                ctx->trns.gray = read_u16(data) & mask;\n            }\n            else if(ctx->ihdr.color_type == 2)\n            {\n                if(chunk.length != 6) return SPNG_ECHUNK_SIZE;\n\n                ctx->trns.red = read_u16(data) & mask;\n                ctx->trns.green = read_u16(data + 2) & mask;\n                ctx->trns.blue = read_u16(data + 4) & mask;\n            }\n            else if(ctx->ihdr.color_type == 3)\n            {\n                if(chunk.length > ctx->plte.n_entries) return SPNG_ECHUNK_SIZE;\n                if(!ctx->file.plte) return SPNG_ETRNS_NO_PLTE;\n\n                size_t k;\n                for(k=0; k < chunk.length; k++)\n                {\n                    memcpy(&ctx->trns.type3_alpha[k], data + k, 1);\n                }\n                ctx->trns.n_type3_entries = chunk.length;\n            }\n            else return SPNG_ETRNS_COLOR_TYPE;\n\n            ctx->file.trns = 1;\n            ctx->stored.trns = 1;\n        }\n        else if(!memcmp(chunk.type, type_hist, 4))\n        {\n            if(!ctx->file.plte) return SPNG_EHIST_NO_PLTE;\n            if(chunk.offset < ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.hist) return SPNG_EDUP_HIST;\n\n            if( (chunk.length / 2) != (ctx->plte.n_entries) ) return SPNG_ECHUNK_SIZE;\n\n            size_t k;\n            for(k=0; k < (chunk.length / 2); k++)\n            {\n                ctx->hist.frequency[k] = read_u16(data + k*2);\n            }\n\n            ctx->file.hist = 1;\n            ctx->stored.hist = 1;\n        }\n        else if(!memcmp(chunk.type, type_phys, 4))\n        {\n            if(ctx->file.phys) return SPNG_EDUP_PHYS;\n\n            if(chunk.length != 9) return SPNG_ECHUNK_SIZE;\n\n            ctx->phys.ppu_x = read_u32(data);\n            ctx->phys.ppu_y = read_u32(data + 4);\n            memcpy(&ctx->phys.unit_specifier, data + 8, 1);\n\n            if(check_phys(&ctx->phys)) return SPNG_EPHYS;\n\n            ctx->file.phys = 1;\n            ctx->stored.phys = 1;\n        }\n        else if(!memcmp(chunk.type, type_time, 4))\n        {\n            if(ctx->file.time) return SPNG_EDUP_TIME;\n\n            if(chunk.length != 7) return SPNG_ECHUNK_SIZE;\n\n            struct spng_time time;\n\n            time.year = read_u16(data);\n            memcpy(&time.month, data + 2, 1);\n            memcpy(&time.day, data + 3, 1);\n            memcpy(&time.hour, data + 4, 1);\n            memcpy(&time.minute, data + 5, 1);\n            memcpy(&time.second, data + 6, 1);\n\n            if(check_time(&time)) return SPNG_ETIME;\n\n            ctx->file.time = 1;\n\n            if(!ctx->user.time) memcpy(&ctx->time, &time, sizeof(struct spng_time));\n\n            ctx->stored.time = 1;\n        }\n        else if(!memcmp(chunk.type, type_offs, 4))\n        {\n            if(ctx->file.offs) return SPNG_EDUP_OFFS;\n\n            if(chunk.length != 9) return SPNG_ECHUNK_SIZE;\n\n            ctx->offs.x = read_s32(data);\n            ctx->offs.y = read_s32(data + 4);\n            memcpy(&ctx->offs.unit_specifier, data + 8, 1);\n\n            if(check_offs(&ctx->offs)) return SPNG_EOFFS;\n\n            ctx->file.offs = 1;\n            ctx->stored.offs = 1;\n        }\n        else if(!memcmp(chunk.type, type_splt, 4))\n        {\n            if(ctx->user.splt) continue; /* XXX: should check profile names for uniqueness */\n            if(!chunk.length) return SPNG_ECHUNK_SIZE;\n\n            ctx->file.splt = 1;\n\n            if(!ctx->stored.splt)\n            {\n                ctx->n_splt = 1;\n                ctx->splt_list = spng__calloc(ctx, 1, sizeof(struct spng_splt));\n                if(ctx->splt_list == NULL) return SPNG_EMEM;\n            }\n            else\n            {\n                ctx->n_splt++;\n                if(ctx->n_splt < 1) return SPNG_EOVERFLOW;\n                if(sizeof(struct spng_splt) > SIZE_MAX / ctx->n_splt) return SPNG_EOVERFLOW;\n\n                void *buf = spng__realloc(ctx, ctx->splt_list, ctx->n_splt * sizeof(struct spng_splt));\n                if(buf == NULL) return SPNG_EMEM;\n                ctx->splt_list = buf;\n                memset(&ctx->splt_list[ctx->n_splt - 1], 0, sizeof(struct spng_splt));\n            }\n\n            uint32_t i = ctx->n_splt - 1;\n\n            size_t keyword_len = chunk.length > 80 ? 80 : chunk.length;\n            char *keyword_nul = memchr(data, '\\0', keyword_len);\n            if(keyword_nul == NULL) return SPNG_ESPLT_NAME;\n\n            memcpy(&ctx->splt_list[i].name, data, keyword_len);\n\n            if(check_png_keyword(ctx->splt_list[i].name)) return SPNG_ESPLT_NAME;\n\n            keyword_len = strlen(ctx->splt_list[i].name);\n\n            if( (chunk.length - keyword_len - 1) ==  0) return SPNG_ECHUNK_SIZE;\n\n            memcpy(&ctx->splt_list[i].sample_depth, data + keyword_len + 1, 1);\n\n            if(ctx->n_splt > 1)\n            {\n                uint32_t j;\n                for(j=0; j < i; j++)\n                {\n                    if(!strcmp(ctx->splt_list[j].name, ctx->splt_list[i].name)) return SPNG_ESPLT_DUP_NAME;\n                }\n            }\n\n            if(ctx->splt_list[i].sample_depth == 16)\n            {\n                if( (chunk.length - keyword_len - 2) % 10 != 0) return SPNG_ECHUNK_SIZE;\n                ctx->splt_list[i].n_entries = (chunk.length - keyword_len - 2) / 10;\n            }\n            else if(ctx->splt_list[i].sample_depth == 8)\n            {\n                if( (chunk.length - keyword_len - 2) % 6 != 0) return SPNG_ECHUNK_SIZE;\n                ctx->splt_list[i].n_entries = (chunk.length - keyword_len - 2) / 6;\n            }\n            else return SPNG_ESPLT_DEPTH;\n\n            if(ctx->splt_list[i].n_entries == 0) return SPNG_ECHUNK_SIZE;\n            if(sizeof(struct spng_splt_entry) > SIZE_MAX / ctx->splt_list[i].n_entries) return SPNG_EOVERFLOW;\n\n            ctx->splt_list[i].entries = spng__malloc(ctx, sizeof(struct spng_splt_entry) * ctx->splt_list[i].n_entries);\n            if(ctx->splt_list[i].entries == NULL) return SPNG_EMEM;\n\n            const unsigned char *splt = data + keyword_len + 2;\n\n            size_t k;\n            if(ctx->splt_list[i].sample_depth == 16)\n            {\n                for(k=0; k < ctx->splt_list[i].n_entries; k++)\n                {\n                    ctx->splt_list[i].entries[k].red = read_u16(splt + k * 10);\n                    ctx->splt_list[i].entries[k].green = read_u16(splt + k * 10 + 2);\n                    ctx->splt_list[i].entries[k].blue = read_u16(splt + k * 10 + 4);\n                    ctx->splt_list[i].entries[k].alpha = read_u16(splt + k * 10 + 6);\n                    ctx->splt_list[i].entries[k].frequency = read_u16(splt + k * 10 + 8);\n                }\n            }\n            else if(ctx->splt_list[i].sample_depth == 8)\n            {\n                for(k=0; k < ctx->splt_list[i].n_entries; k++)\n                {\n                    uint8_t red, green, blue, alpha;\n                    memcpy(&red,   splt + k * 6, 1);\n                    memcpy(&green, splt + k * 6 + 1, 1);\n                    memcpy(&blue,  splt + k * 6 + 2, 1);\n                    memcpy(&alpha, splt + k * 6 + 3, 1);\n                    ctx->splt_list[i].entries[k].frequency = read_u16(splt + k * 6 + 4);\n\n                    ctx->splt_list[i].entries[k].red = red;\n                    ctx->splt_list[i].entries[k].green = green;\n                    ctx->splt_list[i].entries[k].blue = blue;\n                    ctx->splt_list[i].entries[k].alpha = alpha;\n                }\n            }\n\n            ctx->stored.splt = 1;\n        }\n        else if(!memcmp(chunk.type, type_text, 4) ||\n                !memcmp(chunk.type, type_ztxt, 4) ||\n                !memcmp(chunk.type, type_itxt, 4))\n        {\n            ctx->file.text = 1;\n\n            continue; /* XXX: https://gitlab.com/randy408/libspng/issues/31 */\n        }\n        else if(!memcmp(chunk.type, type_exif, 4))\n        {\n            if(ctx->file.exif) return SPNG_EDUP_EXIF;\n\n            ctx->file.exif = 1;\n\n            if(!chunk.length) return SPNG_EEXIF;\n\n            struct spng_exif exif;\n\n            exif.data = spng__malloc(ctx, chunk.length);\n            if(exif.data == NULL) return SPNG_EMEM;\n\n            memcpy(exif.data, data, chunk.length);\n            exif.length = chunk.length;\n\n            if(check_exif(&exif))\n            {\n                spng__free(ctx, exif.data);\n                return SPNG_EEXIF;\n            }\n\n            if(!ctx->user.exif) memcpy(&ctx->exif, &exif, sizeof(struct spng_exif));\n            else spng__free(ctx, exif.data);\n\n            ctx->stored.exif = 1;\n        }\n    }\n\n    return ret;\n}\n\nstatic int get_ancillary(spng_ctx *ctx)\n{\n    if(ctx == NULL) return 1;\n    if(ctx->data == NULL) return 1;\n    if(!ctx->valid_state) return SPNG_EBADSTATE;\n\n    int ret;\n    if(!ctx->first_idat.offset)\n    {\n        ret = read_chunks_before_idat(ctx);\n        if(ret)\n        {\n            ctx->valid_state = 0;\n            return ret;\n        }\n    }\n\n    return 0;\n}\n\nint spng_decoded_image_size(spng_ctx *ctx, int fmt, size_t *out)\n{\n    if(ctx == NULL || out == NULL) return 1;\n\n    int ret = get_ancillary(ctx);\n    if(ret) return ret;\n\n    size_t res;\n    if(fmt == SPNG_FMT_RGBA8)\n    {\n        if(4 > SIZE_MAX / ctx->ihdr.width) return SPNG_EOVERFLOW;\n        res = 4 * ctx->ihdr.width;\n\n        if(res > SIZE_MAX / ctx->ihdr.height) return SPNG_EOVERFLOW;\n        res = res * ctx->ihdr.height;\n    }\n    else if(fmt == SPNG_FMT_RGBA16)\n    {\n        if(8 > SIZE_MAX / ctx->ihdr.width) return SPNG_EOVERFLOW;\n        res = 8 * ctx->ihdr.width;\n\n        if(res > SIZE_MAX / ctx->ihdr.height) return SPNG_EOVERFLOW;\n        res = res * ctx->ihdr.height;\n    }\n    else return SPNG_EFMT;\n\n    *out = res;\n\n    return 0;\n}\n\n\n// target function\nstatic int read_chunks_before_idat(spng_ctx *ctx)\n{\n    if(ctx == NULL) return 1;\n    if(ctx->data == NULL) return 1;\n    if(!ctx->valid_state) return SPNG_EBADSTATE;\n\n    int ret, discard = 0;\n    const unsigned char *data;\n    struct spng_chunk chunk;\n\n    chunk.offset = 8;\n    chunk.length = 13;\n    size_t sizeof_sig_ihdr = 29;\n\n    ret = read_data(ctx, sizeof_sig_ihdr);\n    if(ret) return ret;\n\n    data = ctx->data;\n\n    uint8_t signature[8] = { 137, 80, 78, 71, 13, 10, 26, 10 };\n    if(memcmp(data, signature, sizeof(signature))) return SPNG_ESIGNATURE;\n\n    chunk.length = read_u32(data + 8);\n    memcpy(&chunk.type, data + 12, 4);\n\n    if(chunk.length != 13) return SPNG_EIHDR_SIZE;\n    if(memcmp(chunk.type, type_ihdr, 4)) return SPNG_ENOIHDR;\n\n    ctx->cur_actual_crc = crc32(0, NULL, 0);\n    ctx->cur_actual_crc = crc32(ctx->cur_actual_crc, data + 12, 17);\n\n    ctx->ihdr.width = read_u32(data + 16);\n    ctx->ihdr.height = read_u32(data + 20);\n    memcpy(&ctx->ihdr.bit_depth, data + 24, 1);\n    memcpy(&ctx->ihdr.color_type, data + 25, 1);\n    memcpy(&ctx->ihdr.compression_method, data + 26, 1);\n    memcpy(&ctx->ihdr.filter_method, data + 27, 1);\n    memcpy(&ctx->ihdr.interlace_method, data + 28, 1);\n\n    if(!ctx->max_width) ctx->max_width = png_u32max;\n    if(!ctx->max_height) ctx->max_height = png_u32max;\n\n    ret = check_ihdr(&ctx->ihdr, ctx->max_width, ctx->max_height);\n    if(ret) return ret;\n\n    ctx->file.ihdr = 1;\n    ctx->stored.ihdr = 1;\n\n    struct spng_chunk_bitfield stored;\n    memcpy(&stored, &ctx->stored, sizeof(struct spng_chunk_bitfield));\n\n    while( !(ret = read_header(ctx, &discard)))\n    {\n        if(discard)\n        {\n            memcpy(&ctx->stored, &stored, sizeof(struct spng_chunk_bitfield));\n        }\n\n        memcpy(&stored, &ctx->stored, sizeof(struct spng_chunk_bitfield));\n\n        memcpy(&chunk, &ctx->current_chunk, sizeof(struct spng_chunk));\n\n        if(!memcmp(chunk.type, type_idat, 4))\n        {\n            memcpy(&ctx->first_idat, &chunk, sizeof(struct spng_chunk));\n            return 0;\n        }\n\n        if(!chunk_fits_in_cache(ctx, &ctx->chunk_cache_usage))\n        {\n            ret = discard_chunk_bytes(ctx, chunk.length);\n            if(ret) return ret;\n            continue;\n        }\n\n        data = ctx->data;\n\n        ret = read_chunk_bytes(ctx, chunk.length);\n        if(ret) return ret;\n\n        if(is_critical_chunk(&chunk))\n        {\n            if(!memcmp(chunk.type, type_plte, 4))\n            {\n                if(chunk.length % 3 != 0) return SPNG_ECHUNK_SIZE;\n\n                ctx->plte.n_entries = chunk.length / 3;\n\n                if(check_plte(&ctx->plte, &ctx->ihdr)) return SPNG_ECHUNK_SIZE; /* XXX: EPLTE? */\n\n                size_t i;\n                for(i=0; i < ctx->plte.n_entries; i++)\n                {\n                    memcpy(&ctx->plte.entries[i].red,   data + i * 3, 1);\n                    memcpy(&ctx->plte.entries[i].green, data + i * 3 + 1, 1);\n                    memcpy(&ctx->plte.entries[i].blue,  data + i * 3 + 2, 1);\n                }\n\n                ctx->plte_offset = chunk.offset;\n\n                ctx->file.plte = 1;\n            }\n            else if(!memcmp(chunk.type, type_iend, 4)) return SPNG_ECHUNK_POS;\n            else if(!memcmp(chunk.type, type_ihdr, 4)) return SPNG_ECHUNK_POS;\n            else return SPNG_ECHUNK_UNKNOWN_CRITICAL;\n        }\n        else if(!memcmp(chunk.type, type_chrm, 4)) /* Ancillary chunks */\n        {\n            if(ctx->file.plte && chunk.offset > ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.chrm) return SPNG_EDUP_CHRM;\n\n            if(chunk.length != 32) return SPNG_ECHUNK_SIZE;\n\n            ctx->chrm_int.white_point_x = read_u32(data);\n            ctx->chrm_int.white_point_y = read_u32(data + 4);\n            ctx->chrm_int.red_x = read_u32(data + 8);\n            ctx->chrm_int.red_y = read_u32(data + 12);\n            ctx->chrm_int.green_x = read_u32(data + 16);\n            ctx->chrm_int.green_y = read_u32(data + 20);\n            ctx->chrm_int.blue_x = read_u32(data + 24);\n            ctx->chrm_int.blue_y = read_u32(data + 28);\n\n            if(check_chrm_int(&ctx->chrm_int)) return SPNG_ECHRM;\n\n            ctx->file.chrm = 1;\n            ctx->stored.chrm = 1;\n        }\n        else if(!memcmp(chunk.type, type_gama, 4))\n        {\n            if(ctx->file.plte && chunk.offset > ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.gama) return SPNG_EDUP_GAMA;\n\n            if(chunk.length != 4) return SPNG_ECHUNK_SIZE;\n\n            ctx->gama = read_u32(data);\n\n            if(!ctx->gama) return SPNG_EGAMA;\n            if(ctx->gama > png_u32max) return SPNG_EGAMA;\n\n            ctx->file.gama = 1;\n            ctx->stored.gama = 1;\n        }\n        else if(!memcmp(chunk.type, type_iccp, 4))\n        {\n            if(ctx->file.plte && chunk.offset > ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.iccp) return SPNG_EDUP_ICCP;\n            if(!chunk.length) return SPNG_ECHUNK_SIZE;\n\n            continue; /* XXX: https://gitlab.com/randy408/libspng/issues/31 */\n        }\n        else if(!memcmp(chunk.type, type_sbit, 4))\n        {\n            if(ctx->file.plte && chunk.offset > ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.sbit) return SPNG_EDUP_SBIT;\n\n            if(ctx->ihdr.color_type == 0)\n            {\n                if(chunk.length != 1) return SPNG_ECHUNK_SIZE;\n\n                memcpy(&ctx->sbit.grayscale_bits, data, 1);\n            }\n            else if(ctx->ihdr.color_type == 2 || ctx->ihdr.color_type == 3)\n            {\n                if(chunk.length != 3) return SPNG_ECHUNK_SIZE;\n\n                memcpy(&ctx->sbit.red_bits, data, 1);\n                memcpy(&ctx->sbit.green_bits, data + 1 , 1);\n                memcpy(&ctx->sbit.blue_bits, data + 2, 1);\n            }\n            else if(ctx->ihdr.color_type == 4)\n            {\n                if(chunk.length != 2) return SPNG_ECHUNK_SIZE;\n\n                memcpy(&ctx->sbit.grayscale_bits, data, 1);\n                memcpy(&ctx->sbit.alpha_bits, data + 1, 1);\n            }\n            else if(ctx->ihdr.color_type == 6)\n            {\n                if(chunk.length != 4) return SPNG_ECHUNK_SIZE;\n\n                memcpy(&ctx->sbit.red_bits, data, 1);\n                memcpy(&ctx->sbit.green_bits, data + 1, 1);\n                memcpy(&ctx->sbit.blue_bits, data + 2, 1);\n                memcpy(&ctx->sbit.alpha_bits, data + 3, 1);\n            }\n\n            if(check_sbit(&ctx->sbit, &ctx->ihdr)) return SPNG_ESBIT;\n\n            ctx->file.sbit = 1;\n            ctx->stored.sbit = 1;\n        }\n        else if(!memcmp(chunk.type, type_srgb, 4))\n        {\n            if(ctx->file.plte && chunk.offset > ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.srgb) return SPNG_EDUP_SRGB;\n\n            if(chunk.length != 1) return SPNG_ECHUNK_SIZE;\n\n            memcpy(&ctx->srgb_rendering_intent, data, 1);\n\n            if(ctx->srgb_rendering_intent > 3) return SPNG_ESRGB;\n\n            ctx->file.srgb = 1;\n            ctx->stored.srgb = 1;\n        }\n        else if(!memcmp(chunk.type, type_bkgd, 4))\n        {\n            if(ctx->file.plte && chunk.offset < ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.bkgd) return SPNG_EDUP_BKGD;\n\n            uint16_t mask = ~0;\n            if(ctx->ihdr.bit_depth < 16) mask = (1 << ctx->ihdr.bit_depth) - 1;\n\n            if(ctx->ihdr.color_type == 0 || ctx->ihdr.color_type == 4)\n            {\n                if(chunk.length != 2) return SPNG_ECHUNK_SIZE;\n\n                ctx->bkgd.gray = read_u16(data) & mask;\n            }\n            else if(ctx->ihdr.color_type == 2 || ctx->ihdr.color_type == 6)\n            {\n                if(chunk.length != 6) return SPNG_ECHUNK_SIZE;\n\n                ctx->bkgd.red = read_u16(data) & mask;\n                ctx->bkgd.green = read_u16(data + 2) & mask;\n                ctx->bkgd.blue = read_u16(data + 4) & mask;\n            }\n            else if(ctx->ihdr.color_type == 3)\n            {\n                if(chunk.length != 1) return SPNG_ECHUNK_SIZE;\n                if(!ctx->file.plte) return SPNG_EBKGD_NO_PLTE;\n\n                memcpy(&ctx->bkgd.plte_index, data, 1);\n                if(ctx->bkgd.plte_index >= ctx->plte.n_entries) return SPNG_EBKGD_PLTE_IDX;\n            }\n\n            ctx->file.bkgd = 1;\n            ctx->stored.bkgd = 1;\n        }\n        else if(!memcmp(chunk.type, type_trns, 4))\n        {\n            if(ctx->file.plte && chunk.offset < ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.trns) return SPNG_EDUP_TRNS;\n            if(!chunk.length) return SPNG_ECHUNK_SIZE;\n\n            uint16_t mask = ~0;\n            if(ctx->ihdr.bit_depth < 16) mask = (1 << ctx->ihdr.bit_depth) - 1;\n\n            if(ctx->ihdr.color_type == 0)\n            {\n                if(chunk.length != 2) return SPNG_ECHUNK_SIZE;\n\n                ctx->trns.gray = read_u16(data) & mask;\n            }\n            else if(ctx->ihdr.color_type == 2)\n            {\n                if(chunk.length != 6) return SPNG_ECHUNK_SIZE;\n\n                ctx->trns.red = read_u16(data) & mask;\n                ctx->trns.green = read_u16(data + 2) & mask;\n                ctx->trns.blue = read_u16(data + 4) & mask;\n            }\n            else if(ctx->ihdr.color_type == 3)\n            {\n                if(chunk.length > ctx->plte.n_entries) return SPNG_ECHUNK_SIZE;\n                if(!ctx->file.plte) return SPNG_ETRNS_NO_PLTE;\n\n                size_t k;\n                for(k=0; k < chunk.length; k++)\n                {\n                    memcpy(&ctx->trns.type3_alpha[k], data + k, 1);\n                }\n                ctx->trns.n_type3_entries = chunk.length;\n            }\n            else return SPNG_ETRNS_COLOR_TYPE;\n\n            ctx->file.trns = 1;\n            ctx->stored.trns = 1;\n        }\n        else if(!memcmp(chunk.type, type_hist, 4))\n        {\n            if(!ctx->file.plte) return SPNG_EHIST_NO_PLTE;\n            if(chunk.offset < ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.hist) return SPNG_EDUP_HIST;\n\n            if( (chunk.length / 2) != (ctx->plte.n_entries) ) return SPNG_ECHUNK_SIZE;\n\n            size_t k;\n            for(k=0; k < (chunk.length / 2); k++)\n            {\n                ctx->hist.frequency[k] = read_u16(data + k*2);\n            }\n\n            ctx->file.hist = 1;\n            ctx->stored.hist = 1;\n        }\n        else if(!memcmp(chunk.type, type_phys, 4))\n        {\n            if(ctx->file.phys) return SPNG_EDUP_PHYS;\n\n            if(chunk.length != 9) return SPNG_ECHUNK_SIZE;\n\n            ctx->phys.ppu_x = read_u32(data);\n            ctx->phys.ppu_y = read_u32(data + 4);\n            memcpy(&ctx->phys.unit_specifier, data + 8, 1);\n\n            if(check_phys(&ctx->phys)) return SPNG_EPHYS;\n\n            ctx->file.phys = 1;\n            ctx->stored.phys = 1;\n        }\n        else if(!memcmp(chunk.type, type_splt, 4))\n        {\n            if(ctx->user.splt) continue; /* XXX: should check profile names for uniqueness */\n            if(!chunk.length) return SPNG_ECHUNK_SIZE;\n\n            ctx->file.splt = 1;\n\n            if(!ctx->stored.splt)\n            {\n                ctx->n_splt = 1;\n                ctx->splt_list = spng__calloc(ctx, 1, sizeof(struct spng_splt));\n                if(ctx->splt_list == NULL) return SPNG_EMEM;\n            }\n            else\n            {\n                ctx->n_splt++;\n                if(ctx->n_splt < 1) return SPNG_EOVERFLOW;\n                if(sizeof(struct spng_splt) > SIZE_MAX / ctx->n_splt) return SPNG_EOVERFLOW;\n\n                void *buf = spng__realloc(ctx, ctx->splt_list, ctx->n_splt * sizeof(struct spng_splt));\n                if(buf == NULL) return SPNG_EMEM;\n                ctx->splt_list = buf;\n                memset(&ctx->splt_list[ctx->n_splt - 1], 0, sizeof(struct spng_splt));\n            }\n\n            uint32_t i = ctx->n_splt - 1;\n\n            size_t keyword_len = chunk.length > 80 ? 80 : chunk.length;\n            char *keyword_nul = memchr(data, '\\0', keyword_len);\n            if(keyword_nul == NULL) return SPNG_ESPLT_NAME;\n\n            memcpy(&ctx->splt_list[i].name, data, keyword_len);\n\n            if(check_png_keyword(ctx->splt_list[i].name)) return SPNG_ESPLT_NAME;\n\n            keyword_len = strlen(ctx->splt_list[i].name);\n\n            if( (chunk.length - keyword_len - 1) ==  0) return SPNG_ECHUNK_SIZE;\n\n            memcpy(&ctx->splt_list[i].sample_depth, data + keyword_len + 1, 1);\n\n            if(ctx->n_splt > 1)\n            {\n                uint32_t j;\n                for(j=0; j < i; j++)\n                {\n                    if(!strcmp(ctx->splt_list[j].name, ctx->splt_list[i].name)) return SPNG_ESPLT_DUP_NAME;\n                }\n            }\n\n            if(ctx->splt_list[i].sample_depth == 16)\n            {\n                if( (chunk.length - keyword_len - 2) % 10 != 0) return SPNG_ECHUNK_SIZE;\n                ctx->splt_list[i].n_entries = (chunk.length - keyword_len - 2) / 10;\n            }\n            else if(ctx->splt_list[i].sample_depth == 8)\n            {\n                if( (chunk.length - keyword_len - 2) % 6 != 0) return SPNG_ECHUNK_SIZE;\n                ctx->splt_list[i].n_entries = (chunk.length - keyword_len - 2) / 6;\n            }\n            else return SPNG_ESPLT_DEPTH;\n\n            if(ctx->splt_list[i].n_entries == 0) return SPNG_ECHUNK_SIZE;\n            if(sizeof(struct spng_splt_entry) > SIZE_MAX / ctx->splt_list[i].n_entries) return SPNG_EOVERFLOW;\n\n            ctx->splt_list[i].entries = spng__malloc(ctx, sizeof(struct spng_splt_entry) * ctx->splt_list[i].n_entries);\n            if(ctx->splt_list[i].entries == NULL) return SPNG_EMEM;\n\n            const unsigned char *splt = data + keyword_len + 2;\n\n            size_t k;\n            if(ctx->splt_list[i].sample_depth == 16)\n            {\n                for(k=0; k < ctx->splt_list[i].n_entries; k++)\n                {\n                    ctx->splt_list[i].entries[k].red = read_u16(splt + k * 10);\n                    ctx->splt_list[i].entries[k].green = read_u16(splt + k * 10 + 2);\n                    ctx->splt_list[i].entries[k].blue = read_u16(splt + k * 10 + 4);\n                    ctx->splt_list[i].entries[k].alpha = read_u16(splt + k * 10 + 6);\n                    ctx->splt_list[i].entries[k].frequency = read_u16(splt + k * 10 + 8);\n                }\n            }\n            else if(ctx->splt_list[i].sample_depth == 8)\n            {\n                for(k=0; k < ctx->splt_list[i].n_entries; k++)\n                {\n                    uint8_t red, green, blue, alpha;\n                    memcpy(&red,   splt + k * 6, 1);\n                    memcpy(&green, splt + k * 6 + 1, 1);\n                    memcpy(&blue,  splt + k * 6 + 2, 1);\n                    memcpy(&alpha, splt + k * 6 + 3, 1);\n                    ctx->splt_list[i].entries[k].frequency = read_u16(splt + k * 6 + 4);\n\n                    ctx->splt_list[i].entries[k].red = red;\n                    ctx->splt_list[i].entries[k].green = green;\n                    ctx->splt_list[i].entries[k].blue = blue;\n                    ctx->splt_list[i].entries[k].alpha = alpha;\n                }\n            }\n\n            ctx->stored.splt = 1;\n        }\n        else if(!memcmp(chunk.type, type_time, 4))\n        {\n            if(ctx->file.time) return SPNG_EDUP_TIME;\n\n            if(chunk.length != 7) return SPNG_ECHUNK_SIZE;\n\n            struct spng_time time;\n\n            time.year = read_u16(data);\n            memcpy(&time.month, data + 2, 1);\n            memcpy(&time.day, data + 3, 1);\n            memcpy(&time.hour, data + 4, 1);\n            memcpy(&time.minute, data + 5, 1);\n            memcpy(&time.second, data + 6, 1);\n\n            if(check_time(&time)) return SPNG_ETIME;\n\n            ctx->file.time = 1;\n\n            if(!ctx->user.time) memcpy(&ctx->time, &time, sizeof(struct spng_time));\n\n            ctx->stored.time = 1;\n        }\n        else if(!memcmp(chunk.type, type_text, 4) ||\n                !memcmp(chunk.type, type_ztxt, 4) ||\n                !memcmp(chunk.type, type_itxt, 4))\n        {\n            ctx->file.text = 1;\n\n            continue; /* XXX: https://gitlab.com/randy408/libspng/issues/31 */\n        }\n        else if(!memcmp(chunk.type, type_offs, 4))\n        {\n            if(ctx->file.offs) return SPNG_EDUP_OFFS;\n\n            if(chunk.length != 9) return SPNG_ECHUNK_SIZE;\n\n            ctx->offs.x = read_s32(data);\n            ctx->offs.y = read_s32(data + 4);\n            memcpy(&ctx->offs.unit_specifier, data + 8, 1);\n\n            if(check_offs(&ctx->offs)) return SPNG_EOFFS;\n\n            ctx->file.offs = 1;\n            ctx->stored.offs = 1;\n        }\n        else if(!memcmp(chunk.type, type_exif, 4))\n        {\n            if(ctx->file.exif) return SPNG_EDUP_EXIF;\n\n            ctx->file.exif = 1;\n\n            if(!chunk.length) return SPNG_EEXIF;\n\n            struct spng_exif exif;\n\n            exif.data = spng__malloc(ctx, chunk.length);\n            if(exif.data == NULL) return SPNG_EMEM;\n\n            memcpy(exif.data, data, chunk.length);\n            exif.length = chunk.length;\n\n            if(check_exif(&exif))\n            {\n                spng__free(ctx, exif.data);\n                return SPNG_EEXIF;\n            }\n\n            if(!ctx->user.exif) memcpy(&ctx->exif, &exif, sizeof(struct spng_exif));\n            else spng__free(ctx, exif.data);\n\n            ctx->stored.exif = 1;\n        }\n    }\n\n    return ret;\n}\n",
    "target": 1,
    "idx": 1016051,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic int read_chunks_before_idat(spng_ctx *ctx)\n{\n    if(ctx == NULL) return 1;\n    if(ctx->data == NULL) return 1;\n    if(!ctx->valid_state) return SPNG_EBADSTATE;\n\n    int ret, discard = 0;\n    const unsigned char *data;\n    struct spng_chunk chunk;\n\n    chunk.offset = 8;\n    chunk.length = 13;\n    size_t sizeof_sig_ihdr = 29;\n\n    ret = read_data(ctx, sizeof_sig_ihdr);\n    if(ret) return ret;\n\n    data = ctx->data;\n\n    uint8_t signature[8] = { 137, 80, 78, 71, 13, 10, 26, 10 };\n    if(memcmp(data, signature, sizeof(signature))) return SPNG_ESIGNATURE;\n\n    chunk.length = read_u32(data + 8);\n    memcpy(&chunk.type, data + 12, 4);\n\n    if(chunk.length != 13) return SPNG_EIHDR_SIZE;\n    if(memcmp(chunk.type, type_ihdr, 4)) return SPNG_ENOIHDR;\n\n    ctx->cur_actual_crc = crc32(0, NULL, 0);\n    ctx->cur_actual_crc = crc32(ctx->cur_actual_crc, data + 12, 17);\n\n    ctx->ihdr.width = read_u32(data + 16);\n    ctx->ihdr.height = read_u32(data + 20);\n    memcpy(&ctx->ihdr.bit_depth, data + 24, 1);\n    memcpy(&ctx->ihdr.color_type, data + 25, 1);\n    memcpy(&ctx->ihdr.compression_method, data + 26, 1);\n    memcpy(&ctx->ihdr.filter_method, data + 27, 1);\n    memcpy(&ctx->ihdr.interlace_method, data + 28, 1);\n\n    if(!ctx->max_width) ctx->max_width = png_u32max;\n    if(!ctx->max_height) ctx->max_height = png_u32max;\n\n    ret = check_ihdr(&ctx->ihdr, ctx->max_width, ctx->max_height);\n    if(ret) return ret;\n\n    ctx->file.ihdr = 1;\n    ctx->stored.ihdr = 1;\n\n    struct spng_chunk_bitfield stored;\n    memcpy(&stored, &ctx->stored, sizeof(struct spng_chunk_bitfield));\n\n    while( !(ret = read_header(ctx, &discard)))\n    {\n        if(discard)\n        {\n            memcpy(&ctx->stored, &stored, sizeof(struct spng_chunk_bitfield));\n        }\n\n        memcpy(&stored, &ctx->stored, sizeof(struct spng_chunk_bitfield));\n\n        memcpy(&chunk, &ctx->current_chunk, sizeof(struct spng_chunk));\n\n        if(!memcmp(chunk.type, type_idat, 4))\n        {\n            memcpy(&ctx->first_idat, &chunk, sizeof(struct spng_chunk));\n            return 0;\n        }\n\n        if(!chunk_fits_in_cache(ctx, &ctx->chunk_cache_usage))\n        {\n            ret = discard_chunk_bytes(ctx, chunk.length);\n            if(ret) return ret;\n            continue;\n        }\n\n        ret = read_chunk_bytes(ctx, chunk.length);\n        if(ret) return ret;\n\n        data = ctx->data;\n\n        if(is_critical_chunk(&chunk))\n        {\n            if(!memcmp(chunk.type, type_plte, 4))\n            {\n                if(chunk.length % 3 != 0) return SPNG_ECHUNK_SIZE;\n\n                ctx->plte.n_entries = chunk.length / 3;\n\n                if(check_plte(&ctx->plte, &ctx->ihdr)) return SPNG_ECHUNK_SIZE; /* XXX: EPLTE? */\n\n                size_t i;\n                for(i=0; i < ctx->plte.n_entries; i++)\n                {\n                    memcpy(&ctx->plte.entries[i].red,   data + i * 3, 1);\n                    memcpy(&ctx->plte.entries[i].green, data + i * 3 + 1, 1);\n                    memcpy(&ctx->plte.entries[i].blue,  data + i * 3 + 2, 1);\n                }\n\n                ctx->plte_offset = chunk.offset;\n\n                ctx->file.plte = 1;\n            }\n            else if(!memcmp(chunk.type, type_iend, 4)) return SPNG_ECHUNK_POS;\n            else if(!memcmp(chunk.type, type_ihdr, 4)) return SPNG_ECHUNK_POS;\n            else return SPNG_ECHUNK_UNKNOWN_CRITICAL;\n        }\n        else if(!memcmp(chunk.type, type_chrm, 4)) /* Ancillary chunks */\n        {\n            if(ctx->file.plte && chunk.offset > ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.chrm) return SPNG_EDUP_CHRM;\n\n            if(chunk.length != 32) return SPNG_ECHUNK_SIZE;\n\n            ctx->chrm_int.white_point_x = read_u32(data);\n            ctx->chrm_int.white_point_y = read_u32(data + 4);\n            ctx->chrm_int.red_x = read_u32(data + 8);\n            ctx->chrm_int.red_y = read_u32(data + 12);\n            ctx->chrm_int.green_x = read_u32(data + 16);\n            ctx->chrm_int.green_y = read_u32(data + 20);\n            ctx->chrm_int.blue_x = read_u32(data + 24);\n            ctx->chrm_int.blue_y = read_u32(data + 28);\n\n            if(check_chrm_int(&ctx->chrm_int)) return SPNG_ECHRM;\n\n            ctx->file.chrm = 1;\n            ctx->stored.chrm = 1;\n        }\n        else if(!memcmp(chunk.type, type_gama, 4))\n        {\n            if(ctx->file.plte && chunk.offset > ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.gama) return SPNG_EDUP_GAMA;\n\n            if(chunk.length != 4) return SPNG_ECHUNK_SIZE;\n\n            ctx->gama = read_u32(data);\n\n            if(!ctx->gama) return SPNG_EGAMA;\n            if(ctx->gama > png_u32max) return SPNG_EGAMA;\n\n            ctx->file.gama = 1;\n            ctx->stored.gama = 1;\n        }\n        else if(!memcmp(chunk.type, type_iccp, 4))\n        {\n            if(ctx->file.plte && chunk.offset > ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.iccp) return SPNG_EDUP_ICCP;\n            if(!chunk.length) return SPNG_ECHUNK_SIZE;\n\n            continue; /* XXX: https://gitlab.com/randy408/libspng/issues/31 */\n        }\n        else if(!memcmp(chunk.type, type_sbit, 4))\n        {\n            if(ctx->file.plte && chunk.offset > ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.sbit) return SPNG_EDUP_SBIT;\n\n            if(ctx->ihdr.color_type == 0)\n            {\n                if(chunk.length != 1) return SPNG_ECHUNK_SIZE;\n\n                memcpy(&ctx->sbit.grayscale_bits, data, 1);\n            }\n            else if(ctx->ihdr.color_type == 2 || ctx->ihdr.color_type == 3)\n            {\n                if(chunk.length != 3) return SPNG_ECHUNK_SIZE;\n\n                memcpy(&ctx->sbit.red_bits, data, 1);\n                memcpy(&ctx->sbit.green_bits, data + 1 , 1);\n                memcpy(&ctx->sbit.blue_bits, data + 2, 1);\n            }\n            else if(ctx->ihdr.color_type == 4)\n            {\n                if(chunk.length != 2) return SPNG_ECHUNK_SIZE;\n\n                memcpy(&ctx->sbit.grayscale_bits, data, 1);\n                memcpy(&ctx->sbit.alpha_bits, data + 1, 1);\n            }\n            else if(ctx->ihdr.color_type == 6)\n            {\n                if(chunk.length != 4) return SPNG_ECHUNK_SIZE;\n\n                memcpy(&ctx->sbit.red_bits, data, 1);\n                memcpy(&ctx->sbit.green_bits, data + 1, 1);\n                memcpy(&ctx->sbit.blue_bits, data + 2, 1);\n                memcpy(&ctx->sbit.alpha_bits, data + 3, 1);\n            }\n\n            if(check_sbit(&ctx->sbit, &ctx->ihdr)) return SPNG_ESBIT;\n\n            ctx->file.sbit = 1;\n            ctx->stored.sbit = 1;\n        }\n        else if(!memcmp(chunk.type, type_srgb, 4))\n        {\n            if(ctx->file.plte && chunk.offset > ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.srgb) return SPNG_EDUP_SRGB;\n\n            if(chunk.length != 1) return SPNG_ECHUNK_SIZE;\n\n            memcpy(&ctx->srgb_rendering_intent, data, 1);\n\n            if(ctx->srgb_rendering_intent > 3) return SPNG_ESRGB;\n\n            ctx->file.srgb = 1;\n            ctx->stored.srgb = 1;\n        }\n        else if(!memcmp(chunk.type, type_bkgd, 4))\n        {\n            if(ctx->file.plte && chunk.offset < ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.bkgd) return SPNG_EDUP_BKGD;\n\n            uint16_t mask = ~0;\n            if(ctx->ihdr.bit_depth < 16) mask = (1 << ctx->ihdr.bit_depth) - 1;\n\n            if(ctx->ihdr.color_type == 0 || ctx->ihdr.color_type == 4)\n            {\n                if(chunk.length != 2) return SPNG_ECHUNK_SIZE;\n\n                ctx->bkgd.gray = read_u16(data) & mask;\n            }\n            else if(ctx->ihdr.color_type == 2 || ctx->ihdr.color_type == 6)\n            {\n                if(chunk.length != 6) return SPNG_ECHUNK_SIZE;\n\n                ctx->bkgd.red = read_u16(data) & mask;\n                ctx->bkgd.green = read_u16(data + 2) & mask;\n                ctx->bkgd.blue = read_u16(data + 4) & mask;\n            }\n            else if(ctx->ihdr.color_type == 3)\n            {\n                if(chunk.length != 1) return SPNG_ECHUNK_SIZE;\n                if(!ctx->file.plte) return SPNG_EBKGD_NO_PLTE;\n\n                memcpy(&ctx->bkgd.plte_index, data, 1);\n                if(ctx->bkgd.plte_index >= ctx->plte.n_entries) return SPNG_EBKGD_PLTE_IDX;\n            }\n\n            ctx->file.bkgd = 1;\n            ctx->stored.bkgd = 1;\n        }\n        else if(!memcmp(chunk.type, type_trns, 4))\n        {\n            if(ctx->file.plte && chunk.offset < ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.trns) return SPNG_EDUP_TRNS;\n            if(!chunk.length) return SPNG_ECHUNK_SIZE;\n\n            uint16_t mask = ~0;\n            if(ctx->ihdr.bit_depth < 16) mask = (1 << ctx->ihdr.bit_depth) - 1;\n\n            if(ctx->ihdr.color_type == 0)\n            {\n                if(chunk.length != 2) return SPNG_ECHUNK_SIZE;\n\n                ctx->trns.gray = read_u16(data) & mask;\n            }\n            else if(ctx->ihdr.color_type == 2)\n            {\n                if(chunk.length != 6) return SPNG_ECHUNK_SIZE;\n\n                ctx->trns.red = read_u16(data) & mask;\n                ctx->trns.green = read_u16(data + 2) & mask;\n                ctx->trns.blue = read_u16(data + 4) & mask;\n            }\n            else if(ctx->ihdr.color_type == 3)\n            {\n                if(chunk.length > ctx->plte.n_entries) return SPNG_ECHUNK_SIZE;\n                if(!ctx->file.plte) return SPNG_ETRNS_NO_PLTE;\n\n                size_t k;\n                for(k=0; k < chunk.length; k++)\n                {\n                    memcpy(&ctx->trns.type3_alpha[k], data + k, 1);\n                }\n                ctx->trns.n_type3_entries = chunk.length;\n            }\n            else return SPNG_ETRNS_COLOR_TYPE;\n\n            ctx->file.trns = 1;\n            ctx->stored.trns = 1;\n        }\n        else if(!memcmp(chunk.type, type_hist, 4))\n        {\n            if(!ctx->file.plte) return SPNG_EHIST_NO_PLTE;\n            if(chunk.offset < ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.hist) return SPNG_EDUP_HIST;\n\n            if( (chunk.length / 2) != (ctx->plte.n_entries) ) return SPNG_ECHUNK_SIZE;\n\n            size_t k;\n            for(k=0; k < (chunk.length / 2); k++)\n            {\n                ctx->hist.frequency[k] = read_u16(data + k*2);\n            }\n\n            ctx->file.hist = 1;\n            ctx->stored.hist = 1;\n        }\n        else if(!memcmp(chunk.type, type_phys, 4))\n        {\n            if(ctx->file.phys) return SPNG_EDUP_PHYS;\n\n            if(chunk.length != 9) return SPNG_ECHUNK_SIZE;\n\n            ctx->phys.ppu_x = read_u32(data);\n            ctx->phys.ppu_y = read_u32(data + 4);\n            memcpy(&ctx->phys.unit_specifier, data + 8, 1);\n\n            if(check_phys(&ctx->phys)) return SPNG_EPHYS;\n\n            ctx->file.phys = 1;\n            ctx->stored.phys = 1;\n        }\n        else if(!memcmp(chunk.type, type_time, 4))\n        {\n            if(ctx->file.time) return SPNG_EDUP_TIME;\n\n            if(chunk.length != 7) return SPNG_ECHUNK_SIZE;\n\n            struct spng_time time;\n\n            time.year = read_u16(data);\n            memcpy(&time.month, data + 2, 1);\n            memcpy(&time.day, data + 3, 1);\n            memcpy(&time.hour, data + 4, 1);\n            memcpy(&time.minute, data + 5, 1);\n            memcpy(&time.second, data + 6, 1);\n\n            if(check_time(&time)) return SPNG_ETIME;\n\n            ctx->file.time = 1;\n\n            if(!ctx->user.time) memcpy(&ctx->time, &time, sizeof(struct spng_time));\n\n            ctx->stored.time = 1;\n        }\n        else if(!memcmp(chunk.type, type_offs, 4))\n        {\n            if(ctx->file.offs) return SPNG_EDUP_OFFS;\n\n            if(chunk.length != 9) return SPNG_ECHUNK_SIZE;\n\n            ctx->offs.x = read_s32(data);\n            ctx->offs.y = read_s32(data + 4);\n            memcpy(&ctx->offs.unit_specifier, data + 8, 1);\n\n            if(check_offs(&ctx->offs)) return SPNG_EOFFS;\n\n            ctx->file.offs = 1;\n            ctx->stored.offs = 1;\n        }\n        else if(!memcmp(chunk.type, type_splt, 4))\n        {\n            if(ctx->user.splt) continue; /* XXX: should check profile names for uniqueness */\n            if(!chunk.length) return SPNG_ECHUNK_SIZE;\n\n            ctx->file.splt = 1;\n\n            if(!ctx->stored.splt)\n            {\n                ctx->n_splt = 1;\n                ctx->splt_list = spng__calloc(ctx, 1, sizeof(struct spng_splt));\n                if(ctx->splt_list == NULL) return SPNG_EMEM;\n            }\n            else\n            {\n                ctx->n_splt++;\n                if(ctx->n_splt < 1) return SPNG_EOVERFLOW;\n                if(sizeof(struct spng_splt) > SIZE_MAX / ctx->n_splt) return SPNG_EOVERFLOW;\n\n                void *buf = spng__realloc(ctx, ctx->splt_list, ctx->n_splt * sizeof(struct spng_splt));\n                if(buf == NULL) return SPNG_EMEM;\n                ctx->splt_list = buf;\n                memset(&ctx->splt_list[ctx->n_splt - 1], 0, sizeof(struct spng_splt));\n            }\n\n            uint32_t i = ctx->n_splt - 1;\n\n            size_t keyword_len = chunk.length > 80 ? 80 : chunk.length;\n            char *keyword_nul = memchr(data, '\\0', keyword_len);\n            if(keyword_nul == NULL) return SPNG_ESPLT_NAME;\n\n            memcpy(&ctx->splt_list[i].name, data, keyword_len);\n\n            if(check_png_keyword(ctx->splt_list[i].name)) return SPNG_ESPLT_NAME;\n\n            keyword_len = strlen(ctx->splt_list[i].name);\n\n            if( (chunk.length - keyword_len - 1) ==  0) return SPNG_ECHUNK_SIZE;\n\n            memcpy(&ctx->splt_list[i].sample_depth, data + keyword_len + 1, 1);\n\n            if(ctx->n_splt > 1)\n            {\n                uint32_t j;\n                for(j=0; j < i; j++)\n                {\n                    if(!strcmp(ctx->splt_list[j].name, ctx->splt_list[i].name)) return SPNG_ESPLT_DUP_NAME;\n                }\n            }\n\n            if(ctx->splt_list[i].sample_depth == 16)\n            {\n                if( (chunk.length - keyword_len - 2) % 10 != 0) return SPNG_ECHUNK_SIZE;\n                ctx->splt_list[i].n_entries = (chunk.length - keyword_len - 2) / 10;\n            }\n            else if(ctx->splt_list[i].sample_depth == 8)\n            {\n                if( (chunk.length - keyword_len - 2) % 6 != 0) return SPNG_ECHUNK_SIZE;\n                ctx->splt_list[i].n_entries = (chunk.length - keyword_len - 2) / 6;\n            }\n            else return SPNG_ESPLT_DEPTH;\n\n            if(ctx->splt_list[i].n_entries == 0) return SPNG_ECHUNK_SIZE;\n            if(sizeof(struct spng_splt_entry) > SIZE_MAX / ctx->splt_list[i].n_entries) return SPNG_EOVERFLOW;\n\n            ctx->splt_list[i].entries = spng__malloc(ctx, sizeof(struct spng_splt_entry) * ctx->splt_list[i].n_entries);\n            if(ctx->splt_list[i].entries == NULL) return SPNG_EMEM;\n\n            const unsigned char *splt = data + keyword_len + 2;\n\n            size_t k;\n            if(ctx->splt_list[i].sample_depth == 16)\n            {\n                for(k=0; k < ctx->splt_list[i].n_entries; k++)\n                {\n                    ctx->splt_list[i].entries[k].red = read_u16(splt + k * 10);\n                    ctx->splt_list[i].entries[k].green = read_u16(splt + k * 10 + 2);\n                    ctx->splt_list[i].entries[k].blue = read_u16(splt + k * 10 + 4);\n                    ctx->splt_list[i].entries[k].alpha = read_u16(splt + k * 10 + 6);\n                    ctx->splt_list[i].entries[k].frequency = read_u16(splt + k * 10 + 8);\n                }\n            }\n            else if(ctx->splt_list[i].sample_depth == 8)\n            {\n                for(k=0; k < ctx->splt_list[i].n_entries; k++)\n                {\n                    uint8_t red, green, blue, alpha;\n                    memcpy(&red,   splt + k * 6, 1);\n                    memcpy(&green, splt + k * 6 + 1, 1);\n                    memcpy(&blue,  splt + k * 6 + 2, 1);\n                    memcpy(&alpha, splt + k * 6 + 3, 1);\n                    ctx->splt_list[i].entries[k].frequency = read_u16(splt + k * 6 + 4);\n\n                    ctx->splt_list[i].entries[k].red = red;\n                    ctx->splt_list[i].entries[k].green = green;\n                    ctx->splt_list[i].entries[k].blue = blue;\n                    ctx->splt_list[i].entries[k].alpha = alpha;\n                }\n            }\n\n            ctx->stored.splt = 1;\n        }\n        else if(!memcmp(chunk.type, type_text, 4) ||\n                !memcmp(chunk.type, type_ztxt, 4) ||\n                !memcmp(chunk.type, type_itxt, 4))\n        {\n            ctx->file.text = 1;\n\n            continue; /* XXX: https://gitlab.com/randy408/libspng/issues/31 */\n        }\n        else if(!memcmp(chunk.type, type_exif, 4))\n        {\n            if(ctx->file.exif) return SPNG_EDUP_EXIF;\n\n            ctx->file.exif = 1;\n\n            if(!chunk.length) return SPNG_EEXIF;\n\n            struct spng_exif exif;\n\n            exif.data = spng__malloc(ctx, chunk.length);\n            if(exif.data == NULL) return SPNG_EMEM;\n\n            memcpy(exif.data, data, chunk.length);\n            exif.length = chunk.length;\n\n            if(check_exif(&exif))\n            {\n                spng__free(ctx, exif.data);\n                return SPNG_EEXIF;\n            }\n\n            if(!ctx->user.exif) memcpy(&ctx->exif, &exif, sizeof(struct spng_exif));\n            else spng__free(ctx, exif.data);\n\n            ctx->stored.exif = 1;\n        }\n    }\n\n    return ret;\n}\n\nstatic int get_ancillary(spng_ctx *ctx)\n{\n    if(ctx == NULL) return 1;\n    if(ctx->data == NULL) return 1;\n    if(!ctx->valid_state) return SPNG_EBADSTATE;\n\n    int ret;\n    if(!ctx->first_idat.offset)\n    {\n        ret = read_chunks_before_idat(ctx);\n        if(ret)\n        {\n            ctx->valid_state = 0;\n            return ret;\n        }\n    }\n\n    return 0;\n}\n\nint spng_decoded_image_size(spng_ctx *ctx, int fmt, size_t *out)\n{\n    if(ctx == NULL || out == NULL) return 1;\n\n    int ret = get_ancillary(ctx);\n    if(ret) return ret;\n\n    size_t res;\n    if(fmt == SPNG_FMT_RGBA8)\n    {\n        if(4 > SIZE_MAX / ctx->ihdr.width) return SPNG_EOVERFLOW;\n        res = 4 * ctx->ihdr.width;\n\n        if(res > SIZE_MAX / ctx->ihdr.height) return SPNG_EOVERFLOW;\n        res = res * ctx->ihdr.height;\n    }\n    else if(fmt == SPNG_FMT_RGBA16)\n    {\n        if(8 > SIZE_MAX / ctx->ihdr.width) return SPNG_EOVERFLOW;\n        res = 8 * ctx->ihdr.width;\n\n        if(res > SIZE_MAX / ctx->ihdr.height) return SPNG_EOVERFLOW;\n        res = res * ctx->ihdr.height;\n    }\n    else return SPNG_EFMT;\n\n    *out = res;\n\n    return 0;\n}\n\n\n// target function\nstatic int read_chunks_before_idat(spng_ctx *ctx)\n{\n    if(ctx == NULL) return 1;\n    if(ctx->data == NULL) return 1;\n    if(!ctx->valid_state) return SPNG_EBADSTATE;\n\n    int ret, discard = 0;\n    const unsigned char *data;\n    struct spng_chunk chunk;\n\n    chunk.offset = 8;\n    chunk.length = 13;\n    size_t sizeof_sig_ihdr = 29;\n\n    ret = read_data(ctx, sizeof_sig_ihdr);\n    if(ret) return ret;\n\n    data = ctx->data;\n\n    uint8_t signature[8] = { 137, 80, 78, 71, 13, 10, 26, 10 };\n    if(memcmp(data, signature, sizeof(signature))) return SPNG_ESIGNATURE;\n\n    chunk.length = read_u32(data + 8);\n    memcpy(&chunk.type, data + 12, 4);\n\n    if(chunk.length != 13) return SPNG_EIHDR_SIZE;\n    if(memcmp(chunk.type, type_ihdr, 4)) return SPNG_ENOIHDR;\n\n    ctx->cur_actual_crc = crc32(0, NULL, 0);\n    ctx->cur_actual_crc = crc32(ctx->cur_actual_crc, data + 12, 17);\n\n    ctx->ihdr.width = read_u32(data + 16);\n    ctx->ihdr.height = read_u32(data + 20);\n    memcpy(&ctx->ihdr.bit_depth, data + 24, 1);\n    memcpy(&ctx->ihdr.color_type, data + 25, 1);\n    memcpy(&ctx->ihdr.compression_method, data + 26, 1);\n    memcpy(&ctx->ihdr.filter_method, data + 27, 1);\n    memcpy(&ctx->ihdr.interlace_method, data + 28, 1);\n\n    if(!ctx->max_width) ctx->max_width = png_u32max;\n    if(!ctx->max_height) ctx->max_height = png_u32max;\n\n    ret = check_ihdr(&ctx->ihdr, ctx->max_width, ctx->max_height);\n    if(ret) return ret;\n\n    ctx->file.ihdr = 1;\n    ctx->stored.ihdr = 1;\n\n    struct spng_chunk_bitfield stored;\n    memcpy(&stored, &ctx->stored, sizeof(struct spng_chunk_bitfield));\n\n    while( !(ret = read_header(ctx, &discard)))\n    {\n        if(discard)\n        {\n            memcpy(&ctx->stored, &stored, sizeof(struct spng_chunk_bitfield));\n        }\n\n        memcpy(&stored, &ctx->stored, sizeof(struct spng_chunk_bitfield));\n\n        memcpy(&chunk, &ctx->current_chunk, sizeof(struct spng_chunk));\n\n        if(!memcmp(chunk.type, type_idat, 4))\n        {\n            memcpy(&ctx->first_idat, &chunk, sizeof(struct spng_chunk));\n            return 0;\n        }\n\n        if(!chunk_fits_in_cache(ctx, &ctx->chunk_cache_usage))\n        {\n            ret = discard_chunk_bytes(ctx, chunk.length);\n            if(ret) return ret;\n            continue;\n        }\n\n        data = ctx->data;\n\n        ret = read_chunk_bytes(ctx, chunk.length);\n        if(ret) return ret;\n\n        if(is_critical_chunk(&chunk))\n        {\n            if(!memcmp(chunk.type, type_plte, 4))\n            {\n                if(chunk.length % 3 != 0) return SPNG_ECHUNK_SIZE;\n\n                ctx->plte.n_entries = chunk.length / 3;\n\n                if(check_plte(&ctx->plte, &ctx->ihdr)) return SPNG_ECHUNK_SIZE; /* XXX: EPLTE? */\n\n                size_t i;\n                for(i=0; i < ctx->plte.n_entries; i++)\n                {\n                    memcpy(&ctx->plte.entries[i].red,   data + i * 3, 1);\n                    memcpy(&ctx->plte.entries[i].green, data + i * 3 + 1, 1);\n                    memcpy(&ctx->plte.entries[i].blue,  data + i * 3 + 2, 1);\n                }\n\n                ctx->plte_offset = chunk.offset;\n\n                ctx->file.plte = 1;\n            }\n            else if(!memcmp(chunk.type, type_iend, 4)) return SPNG_ECHUNK_POS;\n            else if(!memcmp(chunk.type, type_ihdr, 4)) return SPNG_ECHUNK_POS;\n            else return SPNG_ECHUNK_UNKNOWN_CRITICAL;\n        }\n        else if(!memcmp(chunk.type, type_chrm, 4)) /* Ancillary chunks */\n        {\n            if(ctx->file.plte && chunk.offset > ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.chrm) return SPNG_EDUP_CHRM;\n\n            if(chunk.length != 32) return SPNG_ECHUNK_SIZE;\n\n            ctx->chrm_int.white_point_x = read_u32(data);\n            ctx->chrm_int.white_point_y = read_u32(data + 4);\n            ctx->chrm_int.red_x = read_u32(data + 8);\n            ctx->chrm_int.red_y = read_u32(data + 12);\n            ctx->chrm_int.green_x = read_u32(data + 16);\n            ctx->chrm_int.green_y = read_u32(data + 20);\n            ctx->chrm_int.blue_x = read_u32(data + 24);\n            ctx->chrm_int.blue_y = read_u32(data + 28);\n\n            if(check_chrm_int(&ctx->chrm_int)) return SPNG_ECHRM;\n\n            ctx->file.chrm = 1;\n            ctx->stored.chrm = 1;\n        }\n        else if(!memcmp(chunk.type, type_gama, 4))\n        {\n            if(ctx->file.plte && chunk.offset > ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.gama) return SPNG_EDUP_GAMA;\n\n            if(chunk.length != 4) return SPNG_ECHUNK_SIZE;\n\n            ctx->gama = read_u32(data);\n\n            if(!ctx->gama) return SPNG_EGAMA;\n            if(ctx->gama > png_u32max) return SPNG_EGAMA;\n\n            ctx->file.gama = 1;\n            ctx->stored.gama = 1;\n        }\n        else if(!memcmp(chunk.type, type_iccp, 4))\n        {\n            if(ctx->file.plte && chunk.offset > ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.iccp) return SPNG_EDUP_ICCP;\n            if(!chunk.length) return SPNG_ECHUNK_SIZE;\n\n            continue; /* XXX: https://gitlab.com/randy408/libspng/issues/31 */\n        }\n        else if(!memcmp(chunk.type, type_sbit, 4))\n        {\n            if(ctx->file.plte && chunk.offset > ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.sbit) return SPNG_EDUP_SBIT;\n\n            if(ctx->ihdr.color_type == 0)\n            {\n                if(chunk.length != 1) return SPNG_ECHUNK_SIZE;\n\n                memcpy(&ctx->sbit.grayscale_bits, data, 1);\n            }\n            else if(ctx->ihdr.color_type == 2 || ctx->ihdr.color_type == 3)\n            {\n                if(chunk.length != 3) return SPNG_ECHUNK_SIZE;\n\n                memcpy(&ctx->sbit.red_bits, data, 1);\n                memcpy(&ctx->sbit.green_bits, data + 1 , 1);\n                memcpy(&ctx->sbit.blue_bits, data + 2, 1);\n            }\n            else if(ctx->ihdr.color_type == 4)\n            {\n                if(chunk.length != 2) return SPNG_ECHUNK_SIZE;\n\n                memcpy(&ctx->sbit.grayscale_bits, data, 1);\n                memcpy(&ctx->sbit.alpha_bits, data + 1, 1);\n            }\n            else if(ctx->ihdr.color_type == 6)\n            {\n                if(chunk.length != 4) return SPNG_ECHUNK_SIZE;\n\n                memcpy(&ctx->sbit.red_bits, data, 1);\n                memcpy(&ctx->sbit.green_bits, data + 1, 1);\n                memcpy(&ctx->sbit.blue_bits, data + 2, 1);\n                memcpy(&ctx->sbit.alpha_bits, data + 3, 1);\n            }\n\n            if(check_sbit(&ctx->sbit, &ctx->ihdr)) return SPNG_ESBIT;\n\n            ctx->file.sbit = 1;\n            ctx->stored.sbit = 1;\n        }\n        else if(!memcmp(chunk.type, type_srgb, 4))\n        {\n            if(ctx->file.plte && chunk.offset > ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.srgb) return SPNG_EDUP_SRGB;\n\n            if(chunk.length != 1) return SPNG_ECHUNK_SIZE;\n\n            memcpy(&ctx->srgb_rendering_intent, data, 1);\n\n            if(ctx->srgb_rendering_intent > 3) return SPNG_ESRGB;\n\n            ctx->file.srgb = 1;\n            ctx->stored.srgb = 1;\n        }\n        else if(!memcmp(chunk.type, type_bkgd, 4))\n        {\n            if(ctx->file.plte && chunk.offset < ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.bkgd) return SPNG_EDUP_BKGD;\n\n            uint16_t mask = ~0;\n            if(ctx->ihdr.bit_depth < 16) mask = (1 << ctx->ihdr.bit_depth) - 1;\n\n            if(ctx->ihdr.color_type == 0 || ctx->ihdr.color_type == 4)\n            {\n                if(chunk.length != 2) return SPNG_ECHUNK_SIZE;\n\n                ctx->bkgd.gray = read_u16(data) & mask;\n            }\n            else if(ctx->ihdr.color_type == 2 || ctx->ihdr.color_type == 6)\n            {\n                if(chunk.length != 6) return SPNG_ECHUNK_SIZE;\n\n                ctx->bkgd.red = read_u16(data) & mask;\n                ctx->bkgd.green = read_u16(data + 2) & mask;\n                ctx->bkgd.blue = read_u16(data + 4) & mask;\n            }\n            else if(ctx->ihdr.color_type == 3)\n            {\n                if(chunk.length != 1) return SPNG_ECHUNK_SIZE;\n                if(!ctx->file.plte) return SPNG_EBKGD_NO_PLTE;\n\n                memcpy(&ctx->bkgd.plte_index, data, 1);\n                if(ctx->bkgd.plte_index >= ctx->plte.n_entries) return SPNG_EBKGD_PLTE_IDX;\n            }\n\n            ctx->file.bkgd = 1;\n            ctx->stored.bkgd = 1;\n        }\n        else if(!memcmp(chunk.type, type_trns, 4))\n        {\n            if(ctx->file.plte && chunk.offset < ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.trns) return SPNG_EDUP_TRNS;\n            if(!chunk.length) return SPNG_ECHUNK_SIZE;\n\n            uint16_t mask = ~0;\n            if(ctx->ihdr.bit_depth < 16) mask = (1 << ctx->ihdr.bit_depth) - 1;\n\n            if(ctx->ihdr.color_type == 0)\n            {\n                if(chunk.length != 2) return SPNG_ECHUNK_SIZE;\n\n                ctx->trns.gray = read_u16(data) & mask;\n            }\n            else if(ctx->ihdr.color_type == 2)\n            {\n                if(chunk.length != 6) return SPNG_ECHUNK_SIZE;\n\n                ctx->trns.red = read_u16(data) & mask;\n                ctx->trns.green = read_u16(data + 2) & mask;\n                ctx->trns.blue = read_u16(data + 4) & mask;\n            }\n            else if(ctx->ihdr.color_type == 3)\n            {\n                if(chunk.length > ctx->plte.n_entries) return SPNG_ECHUNK_SIZE;\n                if(!ctx->file.plte) return SPNG_ETRNS_NO_PLTE;\n\n                size_t k;\n                for(k=0; k < chunk.length; k++)\n                {\n                    memcpy(&ctx->trns.type3_alpha[k], data + k, 1);\n                }\n                ctx->trns.n_type3_entries = chunk.length;\n            }\n            else return SPNG_ETRNS_COLOR_TYPE;\n\n            ctx->file.trns = 1;\n            ctx->stored.trns = 1;\n        }\n        else if(!memcmp(chunk.type, type_hist, 4))\n        {\n            if(!ctx->file.plte) return SPNG_EHIST_NO_PLTE;\n            if(chunk.offset < ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.hist) return SPNG_EDUP_HIST;\n\n            if( (chunk.length / 2) != (ctx->plte.n_entries) ) return SPNG_ECHUNK_SIZE;\n\n            size_t k;\n            for(k=0; k < (chunk.length / 2); k++)\n            {\n                ctx->hist.frequency[k] = read_u16(data + k*2);\n            }\n\n            ctx->file.hist = 1;\n            ctx->stored.hist = 1;\n        }\n        else if(!memcmp(chunk.type, type_phys, 4))\n        {\n            if(ctx->file.phys) return SPNG_EDUP_PHYS;\n\n            if(chunk.length != 9) return SPNG_ECHUNK_SIZE;\n\n            ctx->phys.ppu_x = read_u32(data);\n            ctx->phys.ppu_y = read_u32(data + 4);\n            memcpy(&ctx->phys.unit_specifier, data + 8, 1);\n\n            if(check_phys(&ctx->phys)) return SPNG_EPHYS;\n\n            ctx->file.phys = 1;\n            ctx->stored.phys = 1;\n        }\n        else if(!memcmp(chunk.type, type_splt, 4))\n        {\n            if(ctx->user.splt) continue; /* XXX: should check profile names for uniqueness */\n            if(!chunk.length) return SPNG_ECHUNK_SIZE;\n\n            ctx->file.splt = 1;\n\n            if(!ctx->stored.splt)\n            {\n                ctx->n_splt = 1;\n                ctx->splt_list = spng__calloc(ctx, 1, sizeof(struct spng_splt));\n                if(ctx->splt_list == NULL) return SPNG_EMEM;\n            }\n            else\n            {\n                ctx->n_splt++;\n                if(ctx->n_splt < 1) return SPNG_EOVERFLOW;\n                if(sizeof(struct spng_splt) > SIZE_MAX / ctx->n_splt) return SPNG_EOVERFLOW;\n\n                void *buf = spng__realloc(ctx, ctx->splt_list, ctx->n_splt * sizeof(struct spng_splt));\n                if(buf == NULL) return SPNG_EMEM;\n                ctx->splt_list = buf;\n                memset(&ctx->splt_list[ctx->n_splt - 1], 0, sizeof(struct spng_splt));\n            }\n\n            uint32_t i = ctx->n_splt - 1;\n\n            size_t keyword_len = chunk.length > 80 ? 80 : chunk.length;\n            char *keyword_nul = memchr(data, '\\0', keyword_len);\n            if(keyword_nul == NULL) return SPNG_ESPLT_NAME;\n\n            memcpy(&ctx->splt_list[i].name, data, keyword_len);\n\n            if(check_png_keyword(ctx->splt_list[i].name)) return SPNG_ESPLT_NAME;\n\n            keyword_len = strlen(ctx->splt_list[i].name);\n\n            if( (chunk.length - keyword_len - 1) ==  0) return SPNG_ECHUNK_SIZE;\n\n            memcpy(&ctx->splt_list[i].sample_depth, data + keyword_len + 1, 1);\n\n            if(ctx->n_splt > 1)\n            {\n                uint32_t j;\n                for(j=0; j < i; j++)\n                {\n                    if(!strcmp(ctx->splt_list[j].name, ctx->splt_list[i].name)) return SPNG_ESPLT_DUP_NAME;\n                }\n            }\n\n            if(ctx->splt_list[i].sample_depth == 16)\n            {\n                if( (chunk.length - keyword_len - 2) % 10 != 0) return SPNG_ECHUNK_SIZE;\n                ctx->splt_list[i].n_entries = (chunk.length - keyword_len - 2) / 10;\n            }\n            else if(ctx->splt_list[i].sample_depth == 8)\n            {\n                if( (chunk.length - keyword_len - 2) % 6 != 0) return SPNG_ECHUNK_SIZE;\n                ctx->splt_list[i].n_entries = (chunk.length - keyword_len - 2) / 6;\n            }\n            else return SPNG_ESPLT_DEPTH;\n\n            if(ctx->splt_list[i].n_entries == 0) return SPNG_ECHUNK_SIZE;\n            if(sizeof(struct spng_splt_entry) > SIZE_MAX / ctx->splt_list[i].n_entries) return SPNG_EOVERFLOW;\n\n            ctx->splt_list[i].entries = spng__malloc(ctx, sizeof(struct spng_splt_entry) * ctx->splt_list[i].n_entries);\n            if(ctx->splt_list[i].entries == NULL) return SPNG_EMEM;\n\n            const unsigned char *splt = data + keyword_len + 2;\n\n            size_t k;\n            if(ctx->splt_list[i].sample_depth == 16)\n            {\n                for(k=0; k < ctx->splt_list[i].n_entries; k++)\n                {\n                    ctx->splt_list[i].entries[k].red = read_u16(splt + k * 10);\n                    ctx->splt_list[i].entries[k].green = read_u16(splt + k * 10 + 2);\n                    ctx->splt_list[i].entries[k].blue = read_u16(splt + k * 10 + 4);\n                    ctx->splt_list[i].entries[k].alpha = read_u16(splt + k * 10 + 6);\n                    ctx->splt_list[i].entries[k].frequency = read_u16(splt + k * 10 + 8);\n                }\n            }\n            else if(ctx->splt_list[i].sample_depth == 8)\n            {\n                for(k=0; k < ctx->splt_list[i].n_entries; k++)\n                {\n                    uint8_t red, green, blue, alpha;\n                    memcpy(&red,   splt + k * 6, 1);\n                    memcpy(&green, splt + k * 6 + 1, 1);\n                    memcpy(&blue,  splt + k * 6 + 2, 1);\n                    memcpy(&alpha, splt + k * 6 + 3, 1);\n                    ctx->splt_list[i].entries[k].frequency = read_u16(splt + k * 6 + 4);\n\n                    ctx->splt_list[i].entries[k].red = red;\n                    ctx->splt_list[i].entries[k].green = green;\n                    ctx->splt_list[i].entries[k].blue = blue;\n                    ctx->splt_list[i].entries[k].alpha = alpha;\n                }\n            }\n\n            ctx->stored.splt = 1;\n        }\n        else if(!memcmp(chunk.type, type_time, 4))\n        {\n            if(ctx->file.time) return SPNG_EDUP_TIME;\n\n            if(chunk.length != 7) return SPNG_ECHUNK_SIZE;\n\n            struct spng_time time;\n\n            time.year = read_u16(data);\n            memcpy(&time.month, data + 2, 1);\n            memcpy(&time.day, data + 3, 1);\n            memcpy(&time.hour, data + 4, 1);\n            memcpy(&time.minute, data + 5, 1);\n            memcpy(&time.second, data + 6, 1);\n\n            if(check_time(&time)) return SPNG_ETIME;\n\n            ctx->file.time = 1;\n\n            if(!ctx->user.time) memcpy(&ctx->time, &time, sizeof(struct spng_time));\n\n            ctx->stored.time = 1;\n        }\n        else if(!memcmp(chunk.type, type_text, 4) ||\n                !memcmp(chunk.type, type_ztxt, 4) ||\n                !memcmp(chunk.type, type_itxt, 4))\n        {\n            ctx->file.text = 1;\n\n            continue; /* XXX: https://gitlab.com/randy408/libspng/issues/31 */\n        }\n        else if(!memcmp(chunk.type, type_offs, 4))\n        {\n            if(ctx->file.offs) return SPNG_EDUP_OFFS;\n\n            if(chunk.length != 9) return SPNG_ECHUNK_SIZE;\n\n            ctx->offs.x = read_s32(data);\n            ctx->offs.y = read_s32(data + 4);\n            memcpy(&ctx->offs.unit_specifier, data + 8, 1);\n\n            if(check_offs(&ctx->offs)) return SPNG_EOFFS;\n\n            ctx->file.offs = 1;\n            ctx->stored.offs = 1;\n        }\n        else if(!memcmp(chunk.type, type_exif, 4))\n        {\n            if(ctx->file.exif) return SPNG_EDUP_EXIF;\n\n            ctx->file.exif = 1;\n\n            if(!chunk.length) return SPNG_EEXIF;\n\n            struct spng_exif exif;\n\n            exif.data = spng__malloc(ctx, chunk.length);\n            if(exif.data == NULL) return SPNG_EMEM;\n\n            memcpy(exif.data, data, chunk.length);\n            exif.length = chunk.length;\n\n            if(check_exif(&exif))\n            {\n                spng__free(ctx, exif.data);\n                return SPNG_EEXIF;\n            }\n\n            if(!ctx->user.exif) memcpy(&ctx->exif, &exif, sizeof(struct spng_exif));\n            else spng__free(ctx, exif.data);\n\n            ctx->stored.exif = 1;\n        }\n    }\n\n    return ret;\n}\n",
    "target": 1,
    "idx": 1016266,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\n\nbool\nbfd_close_all_done (bfd *abfd)\n{\n  bool ret;\n\n  if (! BFD_SEND (abfd, _close_and_cleanup, (abfd)))\n    return false;\n\n  ret = abfd->iovec->bclose (abfd) == 0;\n\n  if (ret)\n    _maybe_make_executable (abfd);\n\n  _bfd_delete_bfd (abfd);\n\n  return ret;\n\n_bfd_noarchive_write_armap\n    (bfd *arch ATTRIBUTE_UNUSED,\n     unsigned int elength ATTRIBUTE_UNUSED,\n     struct orl *map ATTRIBUTE_UNUSED,\n     unsigned int orl_count ATTRIBUTE_UNUSED,\n     int stridx ATTRIBUTE_UNUSED)\n{\n  return true;\n\nvoid\nhtab_traverse_noresize (htab_t htab, htab_trav callback, void *info)\n{\n  void **slot;\n  void **limit;\n  \n  slot = htab->entries;\n  limit = slot + htab_size (htab);\n\n  do\n    {\n      void *x = *slot;\n\n      if (x != HTAB_EMPTY_ENTRY && x != HTAB_DELETED_ENTRY)\n\tif (!(*callback) (slot, info))\n\t  break;\n    }\n  while (++slot < limit);\n}\n\n\t  slot = htab_find_slot (htab, &ent, NO_INSERT);\n\t  if (slot != NULL)\n\t    {\n\t      BFD_ASSERT (((struct ar_cache *) *slot)->arbfd == abfd);\n\t      htab_clear_slot (htab, slot);\n\t    }\n\t}\n    }\n}\n\nbool\n_bfd_archive_close_and_cleanup (bfd *abfd)\n{\n  if (bfd_read_p (abfd) && abfd->format == bfd_archive)\n    {\n      bfd *nbfd;\n      bfd *next;\n      htab_t htab;\n\n      /* Close nested archives (if this bfd is a thin archive).  */\n      for (nbfd = abfd->nested_archives; nbfd; nbfd = next)\n\t{\n\t  next = nbfd->archive_next;\n\t  bfd_close (nbfd);\n\t}\n\n      htab = bfd_ardata (abfd)->cache;\n      if (htab)\n\t{\n\t  htab_traverse_noresize (htab, archive_close_worker, NULL);\n\t  htab_delete (htab);\n\t  bfd_ardata (abfd)->cache = NULL;\n\t}\n\n      /* Close the archive plugin file descriptor if needed.  */\n      if (abfd->archive_plugin_fd > 0)\n\n  bfd_set_error (bfd_error_sorry);\n  return false;\n}\n\nbool\n_bfd_elf_close_and_cleanup (bfd *abfd)\n{\n  struct elf_obj_tdata *tdata = elf_tdata (abfd);\n  if (tdata != NULL\n      && (bfd_get_format (abfd) == bfd_object\n\t  || bfd_get_format (abfd) == bfd_core))\n    {\n      if (elf_tdata (abfd)->o != NULL && elf_shstrtab (abfd) != NULL)\n\t_bfd_elf_strtab_free (elf_shstrtab (abfd));\n      _bfd_dwarf2_cleanup_debug_info (abfd, &tdata->dwarf2_find_line_info);\n\n\nbool\nbfd_close_all_done (bfd *abfd)\n{\n  bool ret;\n\n  if (! BFD_SEND (abfd, _close_and_cleanup, (abfd)))\n    return false;\n\n  ret = abfd->iovec->bclose (abfd) == 0;\n\n  if (ret)\n    _maybe_make_executable (abfd);\n\n  _bfd_delete_bfd (abfd);\n\n  return ret;\n\n\n// target function\nstatic bfd_cleanup\npdb_archive_p (bfd *abfd)\n{\n  int ret;\n  char magic[sizeof (pdb_magic)];\n\n  ret = bfd_bread (magic, sizeof (magic), abfd);\n  if (ret != sizeof (magic))\n    {\n      bfd_set_error (bfd_error_wrong_format);\n      return NULL;\n    }\n\n  if (memcmp (magic, pdb_magic, sizeof (magic)))\n    {\n      bfd_set_error (bfd_error_wrong_format);\n      return NULL;\n    }\n\n  return _bfd_no_cleanup;\n}\n",
    "target": 1,
    "idx": 1051661,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nSDB_API bool sdb_free(Sdb* s) {\n\tif (s && s->ht && s->refs) {\n\t\ts->refs--;\n\t\tif (s->refs < 1) {\n\t\t\ts->refs = 0;\n\t\t\tsdb_fini (s, 0);\n\t\t\ts->ht = NULL;\n\t\t\tfree (s);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic void ns_free(Sdb *s, SdbList *list) {\n\tSdbListIter next;\n\tSdbListIter *it;\n\tint deleted;\n\tSdbNs *ns;\n\tif (!list || !s) {\n\t\treturn;\n\t}\n\t// TODO: Implement and use ls_foreach_safe\n\tif (in_list (list, s)) {\n\t\treturn;\n\t}\n\tls_append (list, s);\n\tls_foreach (s->ns, it, ns) {\n\t\tdeleted = 0;\n\t\tnext.n = it->n;\n\t\tif (!in_list (list, ns)) {\n\t\t\tls_delete (s->ns, it); // free (it)\n\t\t\tfree (ns->name);\n\t\t\tns->name = NULL;\n\t\t\tdeleted = 1;\n\t\t\tif (ns->sdb) {\n\t\t\t\tif (sdb_free (ns->sdb)) {\n\t\t\t\t\tns->sdb = NULL;\n\t\t\t\t\tfree (ns->name);\n\t\t\t\t\tns->name = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tls_append (list, ns);\n\t\t\tls_append (list, ns->sdb);\n\t\t\tns_free (ns->sdb, list);\n\t\t\tsdb_free (ns->sdb);\n\t\t}\n\t\tif (!deleted) {\n\t\t\tsdb_free (ns->sdb);\n\t\t\ts->ns->free = NULL;\n\t\t\tls_delete (s->ns, it); // free (it)\n\t\t}\n\t\tfree (ns);\n\t\tit = &next;\n\t}\n\tls_free (s->ns);\n\ts->ns = NULL;\n}\n\nSDB_API void sdb_ns_free(Sdb *s) {\n\tSdbList *list;\n\tif (!s) {\n\t\treturn;\n\t}\n\tlist = ls_new ();\n\tlist->free = NULL;\n\tns_free (s, list);\n\tls_free (list);\n\tls_free (s->ns);\n\ts->ns = NULL;\n}\n\nstatic void sdb_fini(Sdb* s, int donull) {\n\tif (!s) {\n\t\treturn;\n\t}\n\tsdb_hook_free (s);\n\tcdb_free (&s->db);\n\tif (s->lock) {\n\t\tsdb_unlock (sdb_lock_file (s->dir));\n\t}\n\tsdb_ns_free (s);\n\ts->refs = 0;\n\tfree (s->name);\n\tfree (s->path);\n\tls_free (s->ns);\n\tsdb_ht_free (s->ht);\n\tsdb_journal_close (s);\n\tif (s->fd != -1) {\n\t\tclose (s->fd);\n\t\ts->fd = -1;\n\t}\n\tfree (s->ndump);\n\tfree (s->dir);\n\tfree (sdbkv_value (&s->tmpkv));\n\ts->tmpkv.base.value_len = 0;\n\tif (donull) {\n\t\tmemset (s, 0, sizeof (Sdb));\n\t}\n}\n\nSDB_API bool sdb_free(Sdb* s) {\n\tif (s && s->ht && s->refs) {\n\t\ts->refs--;\n\t\tif (s->refs < 1) {\n\t\t\ts->refs = 0;\n\t\t\tsdb_fini (s, 0);\n\t\t\ts->ht = NULL;\n\t\t\tfree (s);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic void ns_free(Sdb *s, SdbList *list) {\n\tSdbListIter next;\n\tSdbListIter *it;\n\tint deleted;\n\tSdbNs *ns;\n\tif (!list || !s) {\n\t\treturn;\n\t}\n\t// TODO: Implement and use ls_foreach_safe\n\tif (in_list (list, s)) {\n\t\treturn;\n\t}\n\tls_append (list, s);\n\tls_foreach (s->ns, it, ns) {\n\t\tdeleted = 0;\n\t\tnext.n = it->n;\n\t\tif (!in_list (list, ns)) {\n\t\t\tls_delete (s->ns, it); // free (it)\n\t\t\tfree (ns->name);\n\t\t\tns->name = NULL;\n\t\t\tdeleted = 1;\n\t\t\tif (ns->sdb) {\n\t\t\t\tif (sdb_free (ns->sdb)) {\n\t\t\t\t\tns->sdb = NULL;\n\t\t\t\t\tfree (ns->name);\n\t\t\t\t\tns->name = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tls_append (list, ns);\n\t\t\tls_append (list, ns->sdb);\n\t\t\tns_free (ns->sdb, list);\n\t\t\tsdb_free (ns->sdb);\n\t\t}\n\t\tif (!deleted) {\n\t\t\tsdb_free (ns->sdb);\n\t\t\ts->ns->free = NULL;\n\t\t\tls_delete (s->ns, it); // free (it)\n\t\t}\n\t\tfree (ns);\n\t\tit = &next;\n\t}\n\tls_free (s->ns);\n\ts->ns = NULL;\n}\n\nSDB_API void sdb_ns_free(Sdb *s) {\n\tSdbList *list;\n\tif (!s) {\n\t\treturn;\n\t}\n\tlist = ls_new ();\n\tlist->free = NULL;\n\tns_free (s, list);\n\tls_free (list);\n\tls_free (s->ns);\n\ts->ns = NULL;\n}\n\nstatic void sdb_fini(Sdb* s, int donull) {\n\tif (!s) {\n\t\treturn;\n\t}\n\tsdb_hook_free (s);\n\tcdb_free (&s->db);\n\tif (s->lock) {\n\t\tsdb_unlock (sdb_lock_file (s->dir));\n\t}\n\tsdb_ns_free (s);\n\ts->refs = 0;\n\tfree (s->name);\n\tfree (s->path);\n\tls_free (s->ns);\n\tsdb_ht_free (s->ht);\n\tsdb_journal_close (s);\n\tif (s->fd != -1) {\n\t\tclose (s->fd);\n\t\ts->fd = -1;\n\t}\n\tfree (s->ndump);\n\tfree (s->dir);\n\tfree (sdbkv_value (&s->tmpkv));\n\ts->tmpkv.base.value_len = 0;\n\tif (donull) {\n\t\tmemset (s, 0, sizeof (Sdb));\n\t}\n}\n\nSDB_API bool sdb_free(Sdb* s) {\n\tif (s && s->ht && s->refs) {\n\t\ts->refs--;\n\t\tif (s->refs < 1) {\n\t\t\ts->refs = 0;\n\t\t\tsdb_fini (s, 0);\n\t\t\ts->ht = NULL;\n\t\t\tfree (s);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic void ns_free(Sdb *s, SdbList *list) {\n\tSdbListIter next;\n\tSdbListIter *it;\n\tint deleted;\n\tSdbNs *ns;\n\tif (!list || !s) {\n\t\treturn;\n\t}\n\t// TODO: Implement and use ls_foreach_safe\n\tif (in_list (list, s)) {\n\t\treturn;\n\t}\n\tls_append (list, s);\n\tls_foreach (s->ns, it, ns) {\n\t\tdeleted = 0;\n\t\tnext.n = it->n;\n\t\tif (!in_list (list, ns)) {\n\t\t\tls_delete (s->ns, it); // free (it)\n\t\t\tfree (ns->name);\n\t\t\tns->name = NULL;\n\t\t\tdeleted = 1;\n\t\t\tif (ns->sdb) {\n\t\t\t\tif (sdb_free (ns->sdb)) {\n\t\t\t\t\tns->sdb = NULL;\n\t\t\t\t\tfree (ns->name);\n\t\t\t\t\tns->name = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tls_append (list, ns);\n\t\t\tls_append (list, ns->sdb);\n\t\t\tns_free (ns->sdb, list);\n\t\t\tsdb_free (ns->sdb);\n\t\t}\n\t\tif (!deleted) {\n\t\t\tsdb_free (ns->sdb);\n\t\t\ts->ns->free = NULL;\n\t\t\tls_delete (s->ns, it); // free (it)\n\t\t}\n\t\tfree (ns);\n\t\tit = &next;\n\t}\n\tls_free (s->ns);\n\ts->ns = NULL;\n}\n\nSDB_API void sdb_ns_free(Sdb *s) {\n\tSdbList *list;\n\tif (!s) {\n\t\treturn;\n\t}\n\tlist = ls_new ();\n\tlist->free = NULL;\n\tns_free (s, list);\n\tls_free (list);\n\tls_free (s->ns);\n\ts->ns = NULL;\n}\n\nstatic void sdb_fini(Sdb* s, int donull) {\n\tif (!s) {\n\t\treturn;\n\t}\n\tsdb_hook_free (s);\n\tcdb_free (&s->db);\n\tif (s->lock) {\n\t\tsdb_unlock (sdb_lock_file (s->dir));\n\t}\n\tsdb_ns_free (s);\n\ts->refs = 0;\n\tfree (s->name);\n\tfree (s->path);\n\tls_free (s->ns);\n\tsdb_ht_free (s->ht);\n\tsdb_journal_close (s);\n\tif (s->fd != -1) {\n\t\tclose (s->fd);\n\t\ts->fd = -1;\n\t}\n\tfree (s->ndump);\n\tfree (s->dir);\n\tfree (sdbkv_value (&s->tmpkv));\n\ts->tmpkv.base.value_len = 0;\n\tif (donull) {\n\t\tmemset (s, 0, sizeof (Sdb));\n\t}\n}\n\nSDB_API bool sdb_free(Sdb* s) {\n\tif (s && s->ht && s->refs) {\n\t\ts->refs--;\n\t\tif (s->refs < 1) {\n\t\t\ts->refs = 0;\n\t\t\tsdb_fini (s, 0);\n\t\t\ts->ht = NULL;\n\t\t\tfree (s);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n\n\nstatic void r_core_free_autocomplete(RCore *core) {\n\tif (!core || !core->cons || !core->cons->line) {\n\t\treturn;\n\t}\n\tr_line_free_autocomplete (core->cons->line);\n}\n\nvoid Fuzzer::ExecuteCallback(const uint8_t *Data, size_t Size) {\n  TPC.RecordInitialStack();\n  TotalNumberOfRuns++;\n  assert(InFuzzingThread());\n  // We copy the contents of Unit into a separate heap buffer\n  // so that we reliably find buffer overflows in it.\n  uint8_t *DataCopy = new uint8_t[Size];\n  memcpy(DataCopy, Data, Size);\n  if (EF->__msan_unpoison)\n    EF->__msan_unpoison(DataCopy, Size);\n  if (CurrentUnitData && CurrentUnitData != Data)\n    memcpy(CurrentUnitData, Data, Size);\n  CurrentUnitSize = Size;\n  {\n    ScopedEnableMsanInterceptorChecks S;\n    AllocTracer.Start(Options.TraceMalloc);\n    UnitStartTime = system_clock::now();\n    TPC.ResetMaps();\n    RunningUserCallback = true;\n    int Res = CB(DataCopy, Size);\n    RunningUserCallback = false;\n    UnitStopTime = system_clock::now();\n    (void)Res;\n    assert(Res == 0);\n    HasMoreMallocsThanFrees = AllocTracer.Stop();\n  }\n  if (!LooseMemeq(DataCopy, Data, Size))\n    CrashOnOverwrittenData();\n  CurrentUnitSize = 0;\n  delete[] DataCopy;\n}\n\nint RunOneTest(Fuzzer *F, const char *InputFilePath, size_t MaxLen) {\n  Unit U = FileToVector(InputFilePath);\n  if (MaxLen && MaxLen < U.size())\n    U.resize(MaxLen);\n  F->ExecuteCallback(U.data(), U.size());\n  F->TryDetectingAMemoryLeak(U.data(), U.size(), true);\n  return 0;\n}\n\nint FuzzerDriver(int *argc, char ***argv, UserCallback Callback) {\n  using namespace fuzzer;\n  assert(argc && argv && \"Argument pointers cannot be nullptr\");\n  std::string Argv0((*argv)[0]);\n  EF = new ExternalFunctions();\n  if (EF->LLVMFuzzerInitialize)\n    EF->LLVMFuzzerInitialize(argc, argv);\n  if (EF->__msan_scoped_disable_interceptor_checks)\n    EF->__msan_scoped_disable_interceptor_checks();\n  const Vector<std::string> Args(*argv, *argv + *argc);\n  assert(!Args.empty());\n  ProgName = new std::string(Args[0]);\n  if (Argv0 != *ProgName) {\n    Printf(\"ERROR: argv[0] has been modified in LLVMFuzzerInitialize\\n\");\n    exit(1);\n  }\n  ParseFlags(Args);\n  if (Flags.help) {\n    PrintHelp();\n    return 0;\n  }\n\n  if (Flags.close_fd_mask & 2)\n    DupAndCloseStderr();\n  if (Flags.close_fd_mask & 1)\n    CloseStdout();\n\n  if (Flags.jobs > 0 && Flags.workers == 0) {\n    Flags.workers = std::min(NumberOfCpuCores() / 2, Flags.jobs);\n    if (Flags.workers > 1)\n      Printf(\"Running %u workers\\n\", Flags.workers);\n  }\n\n  if (Flags.workers > 0 && Flags.jobs > 0)\n    return RunInMultipleProcesses(Args, Flags.workers, Flags.jobs);\n\n  FuzzingOptions Options;\n  Options.Verbosity = Flags.verbosity;\n  Options.MaxLen = Flags.max_len;\n  Options.LenControl = Flags.len_control;\n  Options.UnitTimeoutSec = Flags.timeout;\n  Options.ErrorExitCode = Flags.error_exitcode;\n  Options.TimeoutExitCode = Flags.timeout_exitcode;\n  Options.IgnoreTimeouts = Flags.ignore_timeouts;\n  Options.IgnoreOOMs = Flags.ignore_ooms;\n  Options.IgnoreCrashes = Flags.ignore_crashes;\n  Options.MaxTotalTimeSec = Flags.max_total_time;\n  Options.DoCrossOver = Flags.cross_over;\n  Options.MutateDepth = Flags.mutate_depth;\n  Options.ReduceDepth = Flags.reduce_depth;\n  Options.UseCounters = Flags.use_counters;\n  Options.UseMemmem = Flags.use_memmem;\n  Options.UseCmp = Flags.use_cmp;\n  Options.UseValueProfile = Flags.use_value_profile;\n  Options.Shrink = Flags.shrink;\n  Options.ReduceInputs = Flags.reduce_inputs;\n  Options.ShuffleAtStartUp = Flags.shuffle;\n  Options.PreferSmall = Flags.prefer_small;\n  Options.ReloadIntervalSec = Flags.reload;\n  Options.OnlyASCII = Flags.only_ascii;\n  Options.DetectLeaks = Flags.detect_leaks;\n  Options.PurgeAllocatorIntervalSec = Flags.purge_allocator_interval;\n  Options.TraceMalloc = Flags.trace_malloc;\n  Options.RssLimitMb = Flags.rss_limit_mb;\n  Options.MallocLimitMb = Flags.malloc_limit_mb;\n  if (!Options.MallocLimitMb)\n    Options.MallocLimitMb = Options.RssLimitMb;\n  if (Flags.runs >= 0)\n    Options.MaxNumberOfRuns = Flags.runs;\n  if (!Inputs->empty() && !Flags.minimize_crash_internal_step)\n    Options.OutputCorpus = (*Inputs)[0];\n  Options.ReportSlowUnits = Flags.report_slow_units;\n  if (Flags.artifact_prefix)\n    Options.ArtifactPrefix = Flags.artifact_prefix;\n  if (Flags.exact_artifact_path)\n    Options.ExactArtifactPath = Flags.exact_artifact_path;\n  Vector<Unit> Dictionary;\n  if (Flags.dict)\n    if (!ParseDictionaryFile(FileToString(Flags.dict), &Dictionary))\n      return 1;\n  if (Flags.verbosity > 0 && !Dictionary.empty())\n    Printf(\"Dictionary: %zd entries\\n\", Dictionary.size());\n  bool DoPlainRun = AllInputsAreFiles();\n  Options.SaveArtifacts =\n      !DoPlainRun || Flags.minimize_crash_internal_step;\n  Options.PrintNewCovPcs = Flags.print_pcs;\n  Options.PrintNewCovFuncs = Flags.print_funcs;\n  Options.PrintFinalStats = Flags.print_final_stats;\n  Options.PrintCorpusStats = Flags.print_corpus_stats;\n  Options.PrintCoverage = Flags.print_coverage;\n  if (Flags.exit_on_src_pos)\n    Options.ExitOnSrcPos = Flags.exit_on_src_pos;\n  if (Flags.exit_on_item)\n    Options.ExitOnItem = Flags.exit_on_item;\n  if (Flags.focus_function)\n    Options.FocusFunction = Flags.focus_function;\n  if (Flags.data_flow_trace)\n    Options.DataFlowTrace = Flags.data_flow_trace;\n  Options.LazyCounters = Flags.lazy_counters;\n\n  unsigned Seed = Flags.seed;\n  // Initialize Seed.\n  if (Seed == 0)\n    Seed =\n        std::chrono::system_clock::now().time_since_epoch().count() + GetPid();\n  if (Flags.verbosity)\n    Printf(\"INFO: Seed: %u\\n\", Seed);\n\n  Random Rand(Seed);\n  auto *MD = new MutationDispatcher(Rand, Options);\n  auto *Corpus = new InputCorpus(Options.OutputCorpus);\n  auto *F = new Fuzzer(Callback, *Corpus, *MD, Options);\n\n  for (auto &U: Dictionary)\n    if (U.size() <= Word::GetMaxSize())\n      MD->AddWordToManualDictionary(Word(U.data(), U.size()));\n\n  StartRssThread(F, Flags.rss_limit_mb);\n\n  Options.HandleAbrt = Flags.handle_abrt;\n  Options.HandleBus = Flags.handle_bus;\n  Options.HandleFpe = Flags.handle_fpe;\n  Options.HandleIll = Flags.handle_ill;\n  Options.HandleInt = Flags.handle_int;\n  Options.HandleSegv = Flags.handle_segv;\n  Options.HandleTerm = Flags.handle_term;\n  Options.HandleXfsz = Flags.handle_xfsz;\n  Options.HandleUsr1 = Flags.handle_usr1;\n  Options.HandleUsr2 = Flags.handle_usr2;\n  SetSignalHandler(Options);\n\n  std::atexit(Fuzzer::StaticExitCallback);\n\n  if (Flags.minimize_crash)\n    return MinimizeCrashInput(Args, Options);\n\n  if (Flags.minimize_crash_internal_step)\n    return MinimizeCrashInputInternalStep(F, Corpus);\n\n  if (Flags.cleanse_crash)\n    return CleanseCrashInput(Args, Options);\n\n  if (DoPlainRun) {\n    Options.SaveArtifacts = false;\n    int Runs = std::max(1, Flags.runs);\n    Printf(\"%s: Running %zd inputs %d time(s) each.\\n\", ProgName->c_str(),\n           Inputs->size(), Runs);\n    for (auto &Path : *Inputs) {\n      auto StartTime = system_clock::now();\n      Printf(\"Running: %s\\n\", Path.c_str());\n      for (int Iter = 0; Iter < Runs; Iter++)\n        RunOneTest(F, Path.c_str(), Options.MaxLen);\n      auto StopTime = system_clock::now();\n      auto MS = duration_cast<milliseconds>(StopTime - StartTime).count();\n      Printf(\"Executed %s in %zd ms\\n\", Path.c_str(), (long)MS);\n    }\n    Printf(\"***\\n\"\n           \"*** NOTE: fuzzing was not performed, you have only\\n\"\n           \"***       executed the target code on a fixed set of inputs.\\n\"\n           \"***\\n\");\n    F->PrintFinalStats();\n    exit(0);\n  }\n\n  if (Flags.fork)\n    FuzzWithFork(F->GetMD().GetRand(), Options, Args, *Inputs, Flags.fork);\n\n  if (Flags.merge)\n    Merge(F, Options, Args, *Inputs, Flags.merge_control_file);\n\n  if (Flags.merge_inner) {\n    const size_t kDefaultMaxMergeLen = 1 << 20;\n    if (Options.MaxLen == 0)\n      F->SetMaxInputLen(kDefaultMaxMergeLen);\n    assert(Flags.merge_control_file);\n    F->CrashResistantMergeInternalStep(Flags.merge_control_file);\n    exit(0);\n  }\n\n  if (Flags.analyze_dict) {\n    size_t MaxLen = INT_MAX;  // Large max length.\n    UnitVector InitialCorpus;\n    for (auto &Inp : *Inputs) {\n      Printf(\"Loading corpus dir: %s\\n\", Inp.c_str());\n      ReadDirToVectorOfUnits(Inp.c_str(), &InitialCorpus, nullptr,\n                             MaxLen, /*ExitOnError=*/false);\n    }\n\n    if (Dictionary.empty() || Inputs->empty()) {\n      Printf(\"ERROR: can't analyze dict without dict and corpus provided\\n\");\n      return 1;\n    }\n    if (AnalyzeDictionary(F, Dictionary, InitialCorpus)) {\n      Printf(\"Dictionary analysis failed\\n\");\n      exit(1);\n    }\n    Printf(\"Dictionary analysis succeeded\\n\");\n    exit(0);\n  }\n\n  // Parse -seed_inputs=file1,file2,...\n  Vector<std::string> ExtraSeedFiles;\n  if (Flags.seed_inputs) {\n    std::string s = Flags.seed_inputs;\n    size_t comma_pos;\n    while ((comma_pos = s.find_last_of(',')) != std::string::npos) {\n      ExtraSeedFiles.push_back(s.substr(comma_pos + 1));\n      s = s.substr(0, comma_pos);\n    }\n    ExtraSeedFiles.push_back(s);\n  }\n\n  F->Loop(*Inputs, ExtraSeedFiles);\n\n  if (Flags.verbosity)\n    Printf(\"Done %zd runs in %zd second(s)\\n\", F->getTotalNumberOfRuns(),\n           F->secondsSinceProcessStartUp());\n  F->PrintFinalStats();\n\n  exit(0);  // Don't let F destroy itself.\n}\n\nATTRIBUTE_INTERFACE int main(int argc, char **argv) {\n  return fuzzer::FuzzerDriver(&argc, &argv, LLVMFuzzerTestOneInput);\n}\n\n\n// target function\nstatic int destroy(RBinFile *bf) {\n\tArtObj *obj = bf->o->bin_obj;\n\tsdb_free (obj->kv);\n\tr_buf_free (obj->buf);\n\tfree (obj);\n\treturn true;\n}\n",
    "target": 1,
    "idx": 1013704,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nint\nhtmlParseDocument(htmlParserCtxtPtr ctxt) {\n    xmlDtdPtr dtd;\n\n    xmlInitParser();\n\n    if ((ctxt == NULL) || (ctxt->input == NULL))\n\treturn(-1);\n\n    /*\n     * Document locator is unused. Only for backward compatibility.\n     */\n    if ((ctxt->sax) && (ctxt->sax->setDocumentLocator)) {\n        xmlSAXLocator copy = xmlDefaultSAXLocator;\n        ctxt->sax->setDocumentLocator(ctxt->userData, &copy);\n    }\n\n    xmlDetectEncoding(ctxt);\n\n    /*\n     * This is wrong but matches long-standing behavior. In most cases,\n     * a document starting with an XML declaration will specify UTF-8.\n     */\n    if (((ctxt->input->flags & XML_INPUT_HAS_ENCODING) == 0) &&\n        (xmlStrncmp(ctxt->input->cur, BAD_CAST \"<?xm\", 4) == 0))\n        xmlSwitchEncoding(ctxt, XML_CHAR_ENCODING_UTF8);\n\n    /*\n     * Wipe out everything which is before the first '<'\n     */\n    SKIP_BLANKS;\n    if (CUR == 0) {\n\thtmlParseErr(ctxt, XML_ERR_DOCUMENT_EMPTY,\n\t             \"Document is empty\\n\", NULL, NULL);\n    }\n\n    if ((ctxt->sax) && (ctxt->sax->startDocument) && (!ctxt->disableSAX))\n\tctxt->sax->startDocument(ctxt->userData);\n\n    /*\n     * Parse possible comments and PIs before any content\n     */\n    while (((CUR == '<') && (NXT(1) == '!') &&\n            (NXT(2) == '-') && (NXT(3) == '-')) ||\n\t   ((CUR == '<') && (NXT(1) == '?'))) {\n        htmlParseComment(ctxt);\n        htmlParsePI(ctxt);\n\tSKIP_BLANKS;\n    }\n\n\n    /*\n     * Then possibly doc type declaration(s) and more Misc\n     * (doctypedecl Misc*)?\n     */\n    if ((CUR == '<') && (NXT(1) == '!') &&\n\t(UPP(2) == 'D') && (UPP(3) == 'O') &&\n\t(UPP(4) == 'C') && (UPP(5) == 'T') &&\n\t(UPP(6) == 'Y') && (UPP(7) == 'P') &&\n\t(UPP(8) == 'E')) {\n\thtmlParseDocTypeDecl(ctxt);\n    }\n    SKIP_BLANKS;\n\n    /*\n     * Parse possible comments and PIs before any content\n     */\n    while ((PARSER_STOPPED(ctxt) == 0) &&\n           (((CUR == '<') && (NXT(1) == '!') &&\n             (NXT(2) == '-') && (NXT(3) == '-')) ||\n\t    ((CUR == '<') && (NXT(1) == '?')))) {\n        htmlParseComment(ctxt);\n        htmlParsePI(ctxt);\n\tSKIP_BLANKS;\n    }\n\n    /*\n     * Time to start parsing the tree itself\n     */\n    htmlParseContentInternal(ctxt);\n\n    /*\n     * autoclose\n     */\n    if (CUR == 0)\n\thtmlAutoCloseOnEnd(ctxt);\n\n\n    /*\n     * SAX: end of the document processing.\n     */\n    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n        ctxt->sax->endDocument(ctxt->userData);\n\n    if ((!(ctxt->options & HTML_PARSE_NODEFDTD)) && (ctxt->myDoc != NULL)) {\n\tdtd = xmlGetIntSubset(ctxt->myDoc);\n\tif (dtd == NULL) {\n\t    ctxt->myDoc->intSubset =\n\t\txmlCreateIntSubset(ctxt->myDoc, BAD_CAST \"html\",\n\t\t    BAD_CAST \"-//W3C//DTD HTML 4.0 Transitional//EN\",\n\t\t    BAD_CAST \"http://www.w3.org/TR/REC-html40/loose.dtd\");\n            if (ctxt->myDoc->intSubset == NULL)\n                htmlErrMemory(ctxt, NULL);\n        }\n    }\n    if (! ctxt->wellFormed) return(-1);\n    return(0);\n}\n\nstatic htmlDocPtr\nhtmlDoRead(htmlParserCtxtPtr ctxt, const char *URL, const char *encoding,\n          int options, int reuse)\n{\n    htmlDocPtr ret;\n\n    htmlCtxtUseOptions(ctxt, options);\n    ctxt->html = 1;\n    if (encoding != NULL)\n        xmlSwitchEncodingName(ctxt, encoding);\n    if ((URL != NULL) && (ctxt->input != NULL) &&\n        (ctxt->input->filename == NULL))\n        ctxt->input->filename = (char *) xmlStrdup((const xmlChar *) URL);\n    htmlParseDocument(ctxt);\n    if (ctxt->errNo == XML_ERR_NO_MEMORY) {\n        xmlFreeDoc(ctxt->myDoc);\n        ctxt->myDoc = NULL;\n    }\n    ret = ctxt->myDoc;\n    ctxt->myDoc = NULL;\n    if (!reuse) {\n        if ((ctxt->dictNames) &&\n\t    (ret != NULL) &&\n\t    (ret->dict == ctxt->dict))\n\t    ctxt->dict = NULL;\n\txmlFreeParserCtxt(ctxt);\n    }\n    return (ret);\n}\n\nhtmlDocPtr\nhtmlCtxtReadMemory(htmlParserCtxtPtr ctxt, const char *buffer, int size,\n                  const char *URL, const char *encoding, int options)\n{\n    xmlParserInputBufferPtr input;\n    xmlParserInputPtr stream;\n\n    if (ctxt == NULL)\n        return (NULL);\n    if (buffer == NULL)\n        return (NULL);\n    xmlInitParser();\n\n    htmlCtxtReset(ctxt);\n\n    input = xmlParserInputBufferCreateStatic(buffer, size,\n                                             XML_CHAR_ENCODING_NONE);\n    if (input == NULL) {\n        htmlErrMemory(ctxt, NULL);\n\treturn(NULL);\n    }\n\n    stream = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);\n    if (stream == NULL) {\n\txmlFreeParserInputBuffer(input);\n\treturn(NULL);\n    }\n\n    inputPush(ctxt, stream);\n    return (htmlDoRead(ctxt, URL, encoding, options, 1));\n}\n\n\n// target function\nint\nxmlSwitchInputEncoding(xmlParserCtxtPtr ctxt, xmlParserInputPtr input,\n                       xmlCharEncodingHandlerPtr handler)\n{\n    int nbchars;\n    xmlParserInputBufferPtr in;\n\n    if ((input == NULL) || (input->buf == NULL)) {\n        xmlCharEncCloseFunc(handler);\n\treturn (-1);\n    }\n    in = input->buf;\n\n    input->flags |= XML_INPUT_HAS_ENCODING;\n\n    /*\n     * UTF-8 requires no encoding handler.\n     */\n    if ((handler != NULL) &&\n        (xmlStrcasecmp(BAD_CAST handler->name, BAD_CAST \"UTF-8\") == 0)) {\n        xmlCharEncCloseFunc(handler);\n        handler = NULL;\n    }\n\n    if (in->encoder == handler)\n        return (0);\n\n    if (in->encoder != NULL) {\n        /*\n         * Switching encodings during parsing is a really bad idea,\n         * but Chromium can switch between ISO-8859-1 and UTF-16 before\n         * separate calls to xmlParseChunk.\n         *\n         * TODO: We should check whether the \"raw\" input buffer is empty and\n         * convert the old content using the old encoder.\n         */\n\n        xmlCharEncCloseFunc(in->encoder);\n        in->encoder = handler;\n        return (0);\n    }\n\n    in->encoder = handler;\n\n    /*\n     * Is there already some content down the pipe to convert ?\n     */\n    if (xmlBufIsEmpty(in->buffer) == 0) {\n        size_t processed;\n\n        /*\n         * Shrink the current input buffer.\n         * Move it as the raw buffer and create a new input buffer\n         */\n        processed = input->cur - input->base;\n        xmlBufShrink(in->buffer, processed);\n        input->consumed += processed;\n        in->raw = in->buffer;\n        in->buffer = xmlBufCreate();\n        if (in->buffer == NULL) {\n            xmlErrMemory(ctxt, NULL);\n            return(-1);\n        }\n        in->rawconsumed = processed;\n\n        nbchars = xmlCharEncInput(in);\n        xmlBufResetInput(in->buffer, input);\n        if (nbchars == XML_ENC_ERR_MEMORY) {\n            xmlErrMemory(ctxt, NULL);\n        } else if (nbchars < 0) {\n            xmlErrInternal(ctxt,\n                           \"switching encoding: encoder error\\n\",\n                           NULL);\n            xmlHaltParser(ctxt);\n            return (-1);\n        }\n    }\n    return (0);\n}\n",
    "target": 1,
    "idx": 1065112,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\n\n\n  void destroy() noexcept {\n    if (handle_) {\n      handle_(action::destroy, &storage_, nullptr);\n      handle_ = nullptr;\n    }\n  }\n\n    static void handle(action act, storage* current, storage* other = nullptr) {\n      switch (act) {\n        case (action::destroy):\n          Derived::destroy(*current);\n          break;\n        case (action::move):\n          Derived::move(*current, *other);\n          break;\n      }\n    }\n\n  void destroy() noexcept {\n    if (handle_) {\n      handle_(action::destroy, &storage_, nullptr);\n      handle_ = nullptr;\n    }\n  }\n\n  ~any_invocable_impl() { destroy(); }\n\n\n\n    static void wakeupCb(us_loop_t *loop) {\n        LoopData *loopData = (LoopData *) us_loop_ext(loop);\n\n        /* Swap current deferQueue */\n        loopData->deferMutex.lock();\n        int oldDeferQueue = loopData->currentDeferQueue;\n        loopData->currentDeferQueue = (loopData->currentDeferQueue + 1) % 2;\n        loopData->deferMutex.unlock();\n\n        /* Drain the queue */\n        for (auto &x : loopData->deferQueues[oldDeferQueue]) {\n            x();\n        }\n        loopData->deferQueues[oldDeferQueue].clear();\n    }\n\nvoid us_internal_dispatch_ready_poll(struct us_poll_t *p, int error, int events) {\n    switch (us_internal_poll_type(p)) {\n    case POLL_TYPE_CALLBACK: {\n            /* Let's just do this to clear the CodeQL alert */\n        #ifndef LIBUS_USE_LIBUV\n            us_internal_accept_poll_event(p);\n        #endif\n            struct us_internal_callback_t *cb = (struct us_internal_callback_t *) p;\n            cb->cb(cb->cb_expects_the_loop ? (struct us_internal_callback_t *) cb->loop : (struct us_internal_callback_t *) &cb->p);\n        }\n        break;\n    case POLL_TYPE_SEMI_SOCKET: {\n            /* Both connect and listen sockets are semi-sockets\n             * but they poll for different events */\n            if (us_poll_events(p) == LIBUS_SOCKET_WRITABLE) {\n                struct us_socket_t *s = (struct us_socket_t *) p;\n\n                /* It is perfectly possible to come here with an error */\n                if (error) {\n                    /* Emit error, close without emitting on_close */\n                    s->context->on_connect_error(s, 0);\n                    us_socket_close_connecting(0, s);\n                } else {\n                    /* All sockets poll for readable */\n                    us_poll_change(p, s->context->loop, LIBUS_SOCKET_READABLE);\n\n                    /* We always use nodelay */\n                    bsd_socket_nodelay(us_poll_fd(p), 1);\n\n                    /* We are now a proper socket */\n                    us_internal_poll_set_type(p, POLL_TYPE_SOCKET);\n\n                    /* If we used a connection timeout we have to reset it here */\n                    us_socket_timeout(0, s, 0);\n\n                    s->context->on_open(s, 1, 0, 0);\n                }\n            } else {\n                struct us_listen_socket_t *listen_socket = (struct us_listen_socket_t *) p;\n                struct bsd_addr_t addr;\n\n                LIBUS_SOCKET_DESCRIPTOR client_fd = bsd_accept_socket(us_poll_fd(p), &addr);\n                if (client_fd == LIBUS_SOCKET_ERROR) {\n                    /* Todo: start timer here */\n\n                } else {\n\n                    /* Todo: stop timer if any */\n\n                    do {\n                        struct us_poll_t *accepted_p = us_create_poll(us_socket_context(0, &listen_socket->s)->loop, 0, sizeof(struct us_socket_t) - sizeof(struct us_poll_t) + listen_socket->socket_ext_size);\n                        us_poll_init(accepted_p, client_fd, POLL_TYPE_SOCKET);\n                        us_poll_start(accepted_p, listen_socket->s.context->loop, LIBUS_SOCKET_READABLE);\n\n                        struct us_socket_t *s = (struct us_socket_t *) accepted_p;\n\n                        s->context = listen_socket->s.context;\n\n                        /* We always use nodelay */\n                        bsd_socket_nodelay(client_fd, 1);\n\n                        us_internal_socket_context_link(listen_socket->s.context, s);\n\n                        listen_socket->s.context->on_open(s, 0, bsd_addr_get_ip(&addr), bsd_addr_get_ip_length(&addr));\n\n                        /* Exit accept loop if listen socket was closed in on_open handler */\n                        if (us_socket_is_closed(0, &listen_socket->s)) {\n                            break;\n                        }\n\n                    } while ((client_fd = bsd_accept_socket(us_poll_fd(p), &addr)) != LIBUS_SOCKET_ERROR);\n                }\n            }\n        }\n        break;\n    case POLL_TYPE_SOCKET_SHUT_DOWN:\n    case POLL_TYPE_SOCKET: {\n            /* We should only use s, no p after this point */\n            struct us_socket_t *s = (struct us_socket_t *) p;\n\n            /* Such as epollerr epollhup */\n            if (error) {\n                /* Todo: decide what code we give here */\n                s = us_socket_close(0, s, 0, NULL);\n                return;\n            }\n\n            if (events & LIBUS_SOCKET_WRITABLE) {\n                /* Note: if we failed a write as a socket of one loop then adopted\n                 * to another loop, this will be wrong. Absurd case though */\n                s->context->loop->data.last_write_failed = 0;\n\n                s = s->context->on_writable(s);\n\n                if (us_socket_is_closed(0, s)) {\n                    return;\n                }\n\n                /* If we have no failed write or if we shut down, then stop polling for more writable */\n                if (!s->context->loop->data.last_write_failed || us_socket_is_shut_down(0, s)) {\n                    us_poll_change(&s->p, us_socket_context(0, s)->loop, us_poll_events(&s->p) & LIBUS_SOCKET_READABLE);\n                }\n            }\n\n            if (events & LIBUS_SOCKET_READABLE) {\n                /* Contexts may ignore data and postpone it to next iteration, for balancing purposes such as\n                 * when SSL handshakes take too long to finish and we only want a few of them per iteration */\n                if (s->context->ignore_data(s)) {\n                    break;\n                }\n\n                int length = bsd_recv(us_poll_fd(&s->p), s->context->loop->data.recv_buf + LIBUS_RECV_BUFFER_PADDING, LIBUS_RECV_BUFFER_LENGTH, 0);\n                if (length > 0) {\n                    s = s->context->on_data(s, s->context->loop->data.recv_buf + LIBUS_RECV_BUFFER_PADDING, length);\n                } else if (!length) {\n                    if (us_socket_is_shut_down(0, s)) {\n                        /* We got FIN back after sending it */\n                        /* Todo: We should give \"CLEAN SHUTDOWN\" as reason here */\n                        s = us_socket_close(0, s, 0, NULL);\n                    } else {\n                        /* We got FIN, so stop polling for readable */\n                        us_poll_change(&s->p, us_socket_context(0, s)->loop, us_poll_events(&s->p) & LIBUS_SOCKET_WRITABLE);\n                        s = s->context->on_end(s);\n                    }\n                } else if (length == LIBUS_SOCKET_ERROR && !bsd_would_block()) {\n                    /* Todo: decide also here what kind of reason we should give */\n                    s = us_socket_close(0, s, 0, NULL);\n                }\n            }\n        }\n        break;\n    }\n}\n\nvoid us_loop_run(struct us_loop_t *loop) {\n    us_loop_integrate(loop);\n\n    /* While we have non-fallthrough polls we shouldn't fall through */\n    while (loop->num_polls) {\n        /* Emit pre callback */\n        us_internal_loop_pre(loop);\n\n        /* Fetch ready polls */\n#ifdef LIBUS_USE_EPOLL\n        loop->num_ready_polls = epoll_wait(loop->fd, loop->ready_polls, 1024, -1);\n#else\n        loop->num_ready_polls = kevent(loop->fd, NULL, 0, loop->ready_polls, 1024, NULL);\n#endif\n\n        /* Iterate ready polls, dispatching them by type */\n        for (loop->current_ready_poll = 0; loop->current_ready_poll < loop->num_ready_polls; loop->current_ready_poll++) {\n            struct us_poll_t *poll = GET_READY_POLL(loop, loop->current_ready_poll);\n            /* Any ready poll marked with nullptr will be ignored */\n            if (poll) {\n#ifdef LIBUS_USE_EPOLL\n                int events = loop->ready_polls[loop->current_ready_poll].events;\n                int error = loop->ready_polls[loop->current_ready_poll].events & (EPOLLERR | EPOLLHUP);\n#else\n                /* EVFILT_READ, EVFILT_TIME, EVFILT_USER are all mapped to LIBUS_SOCKET_READABLE */\n                int events = LIBUS_SOCKET_READABLE;\n                if (loop->ready_polls[loop->current_ready_poll].filter == EVFILT_WRITE) {\n                    events = LIBUS_SOCKET_WRITABLE;\n                }\n                int error = loop->ready_polls[loop->current_ready_poll].flags & (EV_ERROR | EV_EOF);\n#endif\n                /* Always filter all polls by what they actually poll for (callback polls always poll for readable) */\n                events &= us_poll_events(poll);\n                if (events || error) {\n                    us_internal_dispatch_ready_poll(poll, error, events);\n                }\n            }\n        }\n        /* Emit post callback */\n        us_internal_loop_post(loop);\n    }\n}\n\ninline void run() {\n    Loop::get()->run();\n}\n\ninline void run() {\n    Loop::get()->run();\n}\n\n\n\nvoid test() {\n\n    struct PerSocketData {\n        int nothing;\n        std::shared_ptr<bool> valid;\n    };\n\n    /* First byte determines what compressor to use */\n    unsigned char compressorByte;\n    if (consume_byte(&compressorByte)) {\n        //uWS::Loop::get()->free();\n        return;\n    }\n\n    uWS::CompressOptions compressors[] = {\n        uWS::DISABLED,\n        uWS::SHARED_COMPRESSOR,\n        uWS::DEDICATED_COMPRESSOR_3KB,\n        uWS::DEDICATED_COMPRESSOR_4KB,\n        uWS::DEDICATED_COMPRESSOR_8KB,\n        uWS::DEDICATED_COMPRESSOR_16KB,\n        uWS::DEDICATED_COMPRESSOR_32KB,\n        uWS::DEDICATED_COMPRESSOR_64KB,\n        uWS::DEDICATED_COMPRESSOR_128KB,\n        uWS::DEDICATED_COMPRESSOR_256KB\n    };\n\n    uWS::CompressOptions compressor = compressors[compressorByte % 10];\n\n    {\n        auto app = uWS::App().ws<PerSocketData>(\"/broadcast\", {\n            /* Settings */\n            .compression = compressor,\n            /* We want this to be low so that we can hit it, yet bigger than 256 */\n            .maxPayloadLength = 300,\n            .idleTimeout = 12,\n            /* Handlers */\n            .open = [](auto *ws) {\n                /* Subscribe to anything */\n                ws->subscribe(/*req->getHeader(*/\"topic\"/*)*/);\n            },\n            .message = [](auto *ws, std::string_view message, uWS::OpCode opCode) {\n                if (message.length() && message[0] == 'C') {\n                    ws->close();\n                } else if (message.length() && message[0] == 'E') {\n                    ws->end(1006);\n                } else {\n                    /* Publish to topic sent by message */\n                    ws->publish(message, message, opCode, true);\n\n                    if (message.length() && message[0] == 'U') {\n                        ws->unsubscribe(message);\n                    }\n                }\n            },\n            .drain = [](auto *ws) {\n                /* Check getBufferedAmount here */\n            },\n            .ping = [](auto *ws) {\n\n            },\n            .pong = [](auto *ws) {\n\n            },\n            .close = [](auto *ws, int code, std::string_view message) {\n\n            }\n        }).ws<PerSocketData>(\"/*\", {\n            /* Settings */\n            .compression = compressor,\n            /* We want this to be low so that we can hit it, yet bigger than 256 */\n            .maxPayloadLength = 300,\n            .idleTimeout = 12,\n            /* Handlers */\n            .open = [](auto *ws) {\n\n                ws->getUserData()->valid.reset(new bool{true});\n\n                //if (req->getHeader(\"close_me\").length()) {\n                //    ws->close();\n                //} else if (req->getHeader(\"end_me\").length()) {\n                //    ws->end(1006);\n                //}\n            },\n            .message = [](auto *ws, std::string_view message, uWS::OpCode opCode) {\n                if (message.length() > 300) {\n                    /* Inform the sanitizer of the fault */\n                    fprintf(stderr, \"Too long message passed\\n\");\n                    free((void *) -1);\n                }\n\n                if (message.length() && message[0] == 'C') {\n                    ws->close();\n                } else if (message.length() && message[0] == 'E') {\n                    ws->end(1006);\n                } else {\n                    ws->send(message, opCode, true);\n                }\n            },\n            .drain = [](auto *ws) {\n                /* Check getBufferedAmount here */\n            },\n            .ping = [](auto *ws) {\n                /* Here we test send and end while uncorked, by having them send from deferred */\n                PerSocketData *psd = (PerSocketData *) ws->getUserData();\n\n                uWS::Loop::get()->defer([ws, valid = psd->valid]() {\n                    if (*valid.get()) {\n                        /* We haven't been closed */\n                        ws->send(\"Hello!\", uWS::TEXT, false);\n                        ws->end(1000);\n                    }\n                });\n            },\n            .pong = [](auto *ws) {\n\n            },\n            .close = [](auto *ws, int code, std::string_view message) {\n                (*ws->getUserData()->valid.get()) = false;\n            }\n        }).listen(9001, [](us_listen_socket_t *listenSocket) {\n            listen_socket = listenSocket;\n        });\n\n        app.run();\n    }\n\n    uWS::Loop::get()->free();\n}\n\n\n// target function\nvoid test() {\n\n    struct PerSocketData {\n        int nothing;\n        std::shared_ptr<bool> valid;\n    };\n\n    /* First byte determines what compressor to use */\n    unsigned char compressorByte;\n    if (consume_byte(&compressorByte)) {\n        //uWS::Loop::get()->free();\n        return;\n    }\n\n    uWS::CompressOptions compressors[] = {\n        uWS::DISABLED,\n        uWS::SHARED_COMPRESSOR,\n        uWS::DEDICATED_COMPRESSOR_3KB,\n        uWS::DEDICATED_COMPRESSOR_4KB,\n        uWS::DEDICATED_COMPRESSOR_8KB,\n        uWS::DEDICATED_COMPRESSOR_16KB,\n        uWS::DEDICATED_COMPRESSOR_32KB,\n        uWS::DEDICATED_COMPRESSOR_64KB,\n        uWS::DEDICATED_COMPRESSOR_128KB,\n        uWS::DEDICATED_COMPRESSOR_256KB\n    };\n\n    uWS::CompressOptions compressor = compressors[compressorByte % 10];\n\n    {\n        auto app = uWS::App().ws<PerSocketData>(\"/broadcast\", {\n            /* Settings */\n            .compression = compressor,\n            /* We want this to be low so that we can hit it, yet bigger than 256 */\n            .maxPayloadLength = 300,\n            .idleTimeout = 12,\n            /* Handlers */\n            .open = [](auto *ws) {\n                    /* Subscribe to anything */\n                    ws->subscribe(/*req->getHeader(*/\"topic\"/*)*/);\n            },\n            .message = [](auto *ws, std::string_view message, uWS::OpCode opCode) {\n                if (message.length() && message[0] == 'C') {\n                    ws->close();\n                } else if (message.length() && message[0] == 'E') {\n                    ws->end(1006);\n                } else {\n                    /* Publish to topic sent by message */\n                    ws->publish(message, message, opCode, true);\n\n                    if (message.length() && message[0] == 'U') {\n                    ws->unsubscribe(message);\n                    }\n                }\n            },\n            .drain = [](auto *ws) {\n                /* Check getBufferedAmount here */\n            },\n            .ping = [](auto *ws) {\n\n            },\n            .pong = [](auto *ws) {\n\n            },\n            .close = [](auto *ws, int code, std::string_view message) {\n\n            }\n        }).ws<PerSocketData>(\"/*\", {\n            /* Settings */\n            .compression = compressor,\n            /* We want this to be low so that we can hit it, yet bigger than 256 */\n            .maxPayloadLength = 300,\n            .idleTimeout = 12,\n            /* Handlers */\n            .open = [](auto *ws) {\n\n                PerSocketData *psd = (PerSocketData *) ws->getUserData();\n                psd->valid.reset(new bool{true});\n\n                //if (req->getHeader(\"close_me\").length()) {\n                //    ws->close();\n                //} else if (req->getHeader(\"end_me\").length()) {\n                //    ws->end(1006);\n                //}\n            },\n            .message = [](auto *ws, std::string_view message, uWS::OpCode opCode) {\n                if (message.length() > 300) {\n                    /* Inform the sanitizer of the fault */\n                    fprintf(stderr, \"Too long message passed\\n\");\n                    free((void *) -1);\n                }\n\n                if (message.length() && message[0] == 'C') {\n                    ws->close();\n                } else if (message.length() && message[0] == 'E') {\n                    ws->end(1006);\n                } else {\n                    ws->send(message, opCode, true);\n                }\n            },\n            .drain = [](auto *ws) {\n                /* Check getBufferedAmount here */\n            },\n            .ping = [](auto *ws) {\n                /* Here we test send and end while uncorked, by having them send from deferred */\n                PerSocketData *psd = (PerSocketData *) ws->getUserData();\n\n                uWS::Loop::get()->defer([ws, valid = psd->valid]() {\n                    if (valid.get()) {\n                        /* We haven't been closed */\n                        ws->send(\"Hello!\", uWS::TEXT, false);\n                        ws->end(1000);\n                    }\n                });\n            },\n            .pong = [](auto *ws) {\n\n            },\n            .close = [](auto *ws, int code, std::string_view message) {\n\n            }\n        }).listen(9001, [](us_listen_socket_t *listenSocket) {\n            listen_socket = listenSocket;\n        });\n\n        app.run();\n    }\n\n    uWS::Loop::get()->free();\n}\n",
    "target": 1,
    "idx": 1031209,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nuint32_t\nmrb_byte_hash_step(const uint8_t *s, mrb_int len, uint32_t hval)\n{\n  const uint8_t *send = s + len;\n\n  /*\n   * FNV-1 hash each octet in the buffer\n   */\n  while (s < send) {\n    /* multiply by the 32 bit FNV magic prime mod 2^32 */\n#if defined(NO_FNV_GCC_OPTIMIZATION)\n    hval *= FNV_32_PRIME;\n#else\n    hval += (hval<<1) + (hval<<4) + (hval<<7) + (hval<<8) + (hval<<24);\n#endif\n\n    /* xor the bottom with the current octet */\n    hval ^= (uint32_t)*s++;\n  }\n\n  /* return our new hash value */\n  return hval;\n}\n\nuint32_t\nmrb_byte_hash(const uint8_t *s, mrb_int len)\n{\n  return mrb_byte_hash_step(s, len, FNV1_32_INIT);\n}\n\nuint32_t\nmrb_str_hash(mrb_state *mrb, mrb_value str)\n{\n  struct RString *s = mrb_str_ptr(str);\n  return mrb_byte_hash((uint8_t*)RSTR_PTR(s), RSTR_LEN(s));\n}\n\nstatic mrb_value\nmrb_str_hash_m(mrb_state *mrb, mrb_value self)\n{\n  mrb_int key = mrb_str_hash(mrb, self);\n  return mrb_int_value(mrb, key);\n}\n\nMRB_API mrb_value\nmrb_funcall_with_block(mrb_state *mrb, mrb_value self, mrb_sym mid, mrb_int argc, const mrb_value *argv, mrb_value blk)\n{\n  mrb_value val;\n  int ai = mrb_gc_arena_save(mrb);\n\n  if (!mrb->jmp) {\n    struct mrb_jmpbuf c_jmp;\n    ptrdiff_t nth_ci = mrb->c->ci - mrb->c->cibase;\n\n    MRB_TRY(&c_jmp) {\n      mrb->jmp = &c_jmp;\n      /* recursive call */\n      val = mrb_funcall_with_block(mrb, self, mid, argc, argv, blk);\n      mrb->jmp = NULL;\n    }\n    MRB_CATCH(&c_jmp) { /* error */\n      while (nth_ci < (mrb->c->ci - mrb->c->cibase)) {\n        cipop(mrb);\n      }\n      mrb->jmp = 0;\n      val = mrb_obj_value(mrb->exc);\n    }\n    MRB_END_EXC(&c_jmp);\n    mrb->jmp = NULL;\n  }\n  else {\n    mrb_method_t m;\n    mrb_callinfo *ci = mrb->c->ci;\n    mrb_int n = mrb_ci_nregs(ci);\n\n    if (!mrb->c->stbase) {\n      stack_init(mrb);\n    }\n    if (ci - mrb->c->cibase > MRB_CALL_LEVEL_MAX) {\n      mrb_exc_raise(mrb, mrb_obj_value(mrb->stack_err));\n    }\n    blk = ensure_block(mrb, blk);\n    ci = cipush(mrb, n, CINFO_DIRECT, NULL, NULL, BLK_PTR(blk), 0, 0);\n    funcall_args_capture(mrb, 0, argc, argv, blk, ci);\n    ci->u.target_class = mrb_class(mrb, self);\n    m = mrb_vm_find_method(mrb, ci->u.target_class, &ci->u.target_class, mid);\n    if (MRB_METHOD_UNDEF_P(m)) {\n      m = prepare_missing(mrb, ci, self, mid, mrb_nil_value(), FALSE);\n    }\n    else {\n      ci->mid = mid;\n    }\n    ci->proc = MRB_METHOD_PROC_P(m) ? MRB_METHOD_PROC(m) : NULL;\n\n    if (MRB_METHOD_CFUNC_P(m)) {\n      ci->stack[0] = self;\n      val = MRB_METHOD_CFUNC(m)(mrb, self);\n      cipop(mrb);\n    }\n    else {\n      ci->cci = CINFO_SKIP;\n      val = mrb_run(mrb, ci->proc, self);\n    }\n  }\n  mrb_gc_arena_restore(mrb, ai);\n  mrb_gc_protect(mrb, val);\n  return val;\n}\n\nMRB_API mrb_value\nmrb_funcall_argv(mrb_state *mrb, mrb_value self, mrb_sym mid, mrb_int argc, const mrb_value *argv)\n{\n  return mrb_funcall_with_block(mrb, self, mid, argc, argv, mrb_nil_value());\n}\n\n\n\nstatic void\nib_it_init(mrb_state *mrb, index_buckets_iter *it, struct RHash *h, mrb_value key)\n{\n  it->h = h;\n  it->bit = ib_bit(h);\n  it->mask = ib_bit_to_capa(it->bit) - 1;\n  it->pos = ib_it_pos_for(it, obj_hash_code(mrb, key, h));\n  it->step = 0;\n}\n\nstatic void\nib_init(mrb_state *mrb, struct RHash *h, uint32_t ib_bit, size_t ib_byte_size)\n{\n  hash_entry *ea = ht_ea(h);\n  memset(ht_ib(h), 0xff, ib_byte_size);\n  ib_set_bit(h, ib_bit);\n  ea_each_used(ea, ht_ea_n_used(h), entry, {\n    ib_cycle_by_key(mrb, h, entry->key, it, {\n      if (!ib_it_empty_p(it)) continue;\n      ib_it_set(it, U32(entry - ea));\n      break;\n    });\n  });\n}\n\nstatic void\nht_init(mrb_state *mrb, struct RHash *h, uint32_t size,\n        hash_entry *ea, uint32_t ea_capa, hash_table *ht, uint32_t ib_bit)\n{\n  size_t ib_byte_size = ib_byte_size_for(ib_bit);\n  size_t ht_byte_size = sizeof(hash_table) + ib_byte_size;\n  ht = (hash_table*)mrb_realloc(mrb, ht, ht_byte_size);\n  h_ht_on(h);\n  h_set_ht(h, ht);\n  ht_set_size(h, size);\n  ht_set_ea(h, ea);\n  ht_set_ea_capa(h, ea_capa);\n  ht_set_ea_n_used(h, size);\n  ib_init(mrb, h, ib_bit, ib_byte_size);\n}\n\nstatic void\nar_set(mrb_state *mrb, struct RHash *h, mrb_value key, mrb_value val)\n{\n  uint32_t size = ar_size(h);\n  hash_entry *entry;\n  if ((entry = ea_get_by_key(mrb, ar_ea(h), size, key, h))) {\n    entry->val = val;\n  }\n  else {\n    uint32_t ea_capa = ar_ea_capa(h), ea_n_used = ar_ea_n_used(h);\n    if (ea_capa == ea_n_used) {\n      if (size == ea_n_used) {\n        if (size == AR_MAX_SIZE) {\n          ht_init(mrb, h, size, ar_ea(h), ea_capa, NULL, IB_INIT_BIT);\n          ht_set(mrb, h, key, val);\n          return;\n        }\n        else {\n          ar_adjust_ea(mrb, h, size, AR_MAX_SIZE);\n        }\n      }\n      else {\n        ar_compress(mrb, h);\n        ea_n_used = size;\n      }\n    }\n    ea_set(ar_ea(h), ea_n_used, key, val);\n    ar_set_size(h, ++size);\n    ar_set_ea_n_used(h, ++ea_n_used);\n  }\n}\n\nstatic void\nh_set(mrb_state *mrb, struct RHash *h, mrb_value key, mrb_value val)\n{\n  (h_ar_p(h) ? ar_set : ht_set)(mrb, h, key, val);\n}\n\nMRB_API void\nmrb_hash_set(mrb_state *mrb, mrb_value hash, mrb_value key, mrb_value val)\n{\n  hash_modify(mrb, hash);\n  key = h_key_for(mrb, key);\n  h_set(mrb, mrb_hash_ptr(hash), key, val);\n  mrb_field_write_barrier_value(mrb, mrb_basic_ptr(hash), key);\n  mrb_field_write_barrier_value(mrb, mrb_basic_ptr(hash), val);\n}\n\nstatic mrb_value\nmrb_hash_aset(mrb_state *mrb, mrb_value self)\n{\n  mrb_value key, val;\n\n  mrb_get_args(mrb, \"oo\", &key, &val);\n  mrb_hash_set(mrb, self, key, val);\n  return val;\n}\n\nMRB_API mrb_value\nmrb_vm_run(mrb_state *mrb, const struct RProc *proc, mrb_value self, mrb_int stack_keep)\n{\n  const mrb_irep *irep = proc->body.irep;\n  mrb_value result;\n  struct mrb_context *c = mrb->c;\n  ptrdiff_t cioff = c->ci - c->cibase;\n  mrb_int nregs = irep->nregs;\n\n  if (!c->stbase) {\n    stack_init(mrb);\n  }\n  if (stack_keep > nregs)\n    nregs = stack_keep;\n  else {\n    struct REnv *e = CI_ENV(mrb->c->ci);\n    if (stack_keep == 0 || (e && irep->nlocals < MRB_ENV_LEN(e))) {\n      ci_env_set(mrb->c->ci, NULL);\n      mrb_env_unshare(mrb, e, FALSE);\n    }\n  }\n  stack_extend(mrb, nregs);\n  stack_clear(c->ci->stack + stack_keep, nregs - stack_keep);\n  c->ci->stack[0] = self;\n  result = mrb_vm_exec(mrb, proc, irep->iseq);\n  if (mrb->c != c) {\n    if (mrb->c->fib) {\n      mrb_write_barrier(mrb, (struct RBasic*)mrb->c->fib);\n    }\n    mrb->c = c;\n  }\n  else if (c->ci - c->cibase > cioff) {\n    c->ci = c->cibase + cioff;\n  }\n  return result;\n}\n\nMRB_API mrb_value\nmrb_top_run(mrb_state *mrb, const struct RProc *proc, mrb_value self, mrb_int stack_keep)\n{\n  if (mrb->c->cibase && mrb->c->ci > mrb->c->cibase) {\n    cipush(mrb, 0, CINFO_SKIP, mrb->object_class, NULL, NULL, 0, 0);\n  }\n  return mrb_vm_run(mrb, proc, self, stack_keep);\n}\n\n\n// target function\nstatic void\nclear_all_old(mrb_state *mrb, mrb_gc *gc)\n{\n  mrb_assert(is_generational(gc));\n  if (gc->full) {\n    /* finish the half baked GC */\n    incremental_gc_finish(mrb, gc);\n  }\n  else {\n    /* Sweep the dead objects, then reset all the live objects\n     * (including all the old objects, of course) to white. */\n    gc->generational = FALSE;\n    prepare_incremental_sweep(mrb, gc);\n    incremental_gc_finish(mrb, gc);\n    gc->generational = TRUE;\n  }\n  /* The gray objects have already been painted as white */\n  gc->atomic_gray_list = gc->gray_list = NULL;\n}\n",
    "target": 1,
    "idx": 1058723,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nl_int32\npixChangeRefcount(PIX     *pix,\n                  l_int32  delta)\n{\n    PROCNAME(\"pixChangeRefcount\");\n\n    if (!pix)\n        return ERROR_INT(\"pix not defined\", procName, 1);\n\n    pix->refcount += delta;\n    return 0;\n}\n\nstatic void\npixFree(PIX  *pix)\n{\nl_uint32  *data;\nchar      *text;\n\n    if (!pix) return;\n\n    pixChangeRefcount(pix, -1);\n    if (pixGetRefcount(pix) <= 0) {\n        if ((data = pixGetData(pix)) != NULL)\n            pixdata_free(data);\n        if ((text = pixGetText(pix)) != NULL)\n            LEPT_FREE(text);\n        pixDestroyColormap(pix);\n        LEPT_FREE(pix);\n    }\n    return;\n}\n\nvoid\npixDestroy(PIX  **ppix)\n{\nPIX  *pix;\n\n    PROCNAME(\"pixDestroy\");\n\n    if (!ppix) {\n        L_WARNING(\"ptr address is null!\\n\", procName);\n        return;\n    }\n\n    if ((pix = *ppix) == NULL)\n        return;\n    pixFree(pix);\n    *ppix = NULL;\n}\n\n\n// target function\nextern \"C\" int\nLLVMFuzzerTestOneInput(const uint8_t* data, size_t size) { \n\tif(size<3) return 0;\n\n\tleptSetStdNullHandler();\n\n\n\tPIX *pixs_payload = pixReadMemSpix(data, size);\n\tif(pixs_payload == NULL) return 0;\n\n\tPIX *pix1, *pix2, *pix3, *pix4, *pix5, *return_pix1, *payload_copy;\n\n\tpix1 = pixRead(\"../test8.jpg\");\n\tpayload_copy = pixCopy(NULL, pixs_payload);\n\tpixBackgroundNormGrayArray(payload_copy, pix1, 10, 10, 10, 10, 256, 10, 10, &pix2);\n\tpixDestroy(&pix1);\n\tpixDestroy(&pix2);\n\tpixDestroy(&payload_copy);\n\n\n\n\tpix1 = pixRead(\"../test8.jpg\");\n\tpayload_copy = pixCopy(NULL, pixs_payload);\n\tpixBackgroundNormGrayArrayMorph(payload_copy, pix1, 6, 5, 256, &pix2);\n\tpixDestroy(&pix1);\n\tpixDestroy(&pix2);\n\tpixDestroy(&payload_copy);\n\n\n\tpix1 = pixRead(\"../test8.jpg\");\n\tpayload_copy = pixCopy(NULL, pixs_payload);\n\treturn_pix1 = pixBackgroundNormMorph(payload_copy, pix1, 6, 5, 256);\n\tpixDestroy(&pix1);\n\tpixDestroy(&payload_copy);\n\tif(return_pix1!=NULL){\n\t\tpixDestroy(&return_pix1);\n\t}\n\n\n\tpix1 = pixRead(\"../test8.jpg\");\n\tpix2 = pixRead(\"../test8.jpg\");\n\tpayload_copy = pixCopy(NULL, pixs_payload);\n\tpixBackgroundNormRGBArrays(payload_copy, pix1, pix2, 10, 10, 10, 10, 130, 10, 10, &pix3, &pix4, &pix5);\n\tpixDestroy(&pix1);\n\tpixDestroy(&pix2);\n\tpixDestroy(&pix3);\n\tpixDestroy(&pix4);\n\tpixDestroy(&pix5);\n\tpixDestroy(&payload_copy);\n\n\n\tpix1 = pixRead(\"../test8.jpg\");\n\tpayload_copy = pixCopy(NULL, pixs_payload);\n\tpixBackgroundNormRGBArraysMorph(payload_copy, pix1, 6, 33, 130, &pix2, &pix3, &pix4);\n\tpixDestroy(&pix1);\n\tpixDestroy(&pix2);\n\tpixDestroy(&pix3);\n\tpixDestroy(&pix4);\n\tpixDestroy(&payload_copy);\n\n\n\tpix1 = pixRead(\"../test8.jpg\");\n\tpayload_copy = pixCopy(NULL, pixs_payload);\n\treturn_pix1 = pixContrastNorm(payload_copy, pix1, 10, 10, 3, 0, 0);\n\tpixDestroy(&pix1);\n\tpixDestroy(&payload_copy);\n\tif(return_pix1!=NULL){\n\t\tpixDestroy(&return_pix1);\n\t}\n\n\n\tpix1 = pixRead(\"../test8.jpg\");\n\tpayload_copy = pixCopy(NULL, pixs_payload);\n\treturn_pix1 = pixGlobalNormNoSatRGB(payload_copy, pix1, 3, 3, 3, 2, 0.9);\n\tpixDestroy(&pix1);\n\tpixDestroy(&payload_copy);\n\tif(return_pix1!=NULL){\n\t\tpixDestroy(&return_pix1);\n\t}\n\n\n\tpayload_copy = pixCopy(NULL, pixs_payload);\n\tpixThresholdSpreadNorm(payload_copy, L_SOBEL_EDGE, 10, 0, 0, 0.7, -25, 255, 10, &pix1, &pix2, &pix3);\n\tpixDestroy(&pix1);\n\tpixDestroy(&pix2);\n\tpixDestroy(&pix3);\n\tpixDestroy(&payload_copy);\n\n\tpixDestroy(&pixs_payload);\n\n\n\treturn 0;\n}\n",
    "target": 1,
    "idx": 1026967,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "// context\nstatic int\ndxf_tables_read (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  char table[80];\n  Dxf_Pair *pair;\n\n  pair = dxf_read_pair (dat);\n  table[0] = '\\0'; // init\n  while (pair)     // read next 0 TABLE\n    {\n      if (pair->code == 0 && pair->value.s) // TABLE or ENDTAB\n        {\n          if (strEQc (pair->value.s, \"TABLE\"))\n            table[0] = '\\0'; // new table coming up\n          else if (strEQc (pair->value.s, \"BLOCK_RECORD\"))\n            {\n              strncpy (table, pair->value.s, 79);\n              table[79] = '\\0';\n            }\n          else if (strEQc (pair->value.s, \"ENDTAB\"))\n            {\n              table[0] = '\\0'; // close table\n            }\n          else if (strEQc (pair->value.s, \"ENDSEC\"))\n            {\n              dxf_free_pair (pair);\n              return 0;\n            }\n          else\n            {\n              LOG_ERROR (\"Unknown 0 %s (%s)\", pair->value.s, \"tables\");\n              dxf_free_pair (pair);\n              return 1;\n            }\n        }\n      else if (pair->code == 2 && pair->value.s && strlen (pair->value.s) < 80\n               && is_table_name (pair->value.s)) // new table NAME\n        {\n          long i = 0;\n          BITCODE_BL ctrl_id;\n          strncpy (table, pair->value.s, 79);\n          table[79] = '\\0';\n          pair = new_table_control (table, dat, dwg); // until 0 table\n          ctrl_id = dwg->num_objects - 1;             // dwg->object might move\n          while (pair && pair->code == 0 && pair->value.s\n                 && strEQ (pair->value.s, table))\n            {\n              Dwg_Object *obj;\n              Dwg_Object *ctrl = &dwg->object[ctrl_id];\n              char *dxfname = strdup (pair->value.s);\n              BITCODE_BL idx = dwg->num_objects;\n              BITCODE_H ref;\n              dxf_free_pair (pair);\n              // until 0 table or 0 ENDTAB\n              pair = new_object (table, dxfname, dat, dwg, ctrl_id,\n                                 (BITCODE_BL *)&i);\n              obj = &dwg->object[idx];\n              if (!pair)\n                {\n                  free (dxfname);\n                  if (idx != dwg->num_objects)\n                    obj->dxfname = NULL;\n                  return DWG_ERR_INVALIDDWG;\n                }\n              // A minimal DXF will have no handle values\n              if (!obj->handle.value)\n                {\n                  BITCODE_RLL next_handle = dwg_next_handle (dwg);\n                  dwg_add_handle (&obj->handle, 0, next_handle, NULL);\n                  // ref = dwg_add_handleref (dwg, 3, next_handle, ctrl);\n                  LOG_TRACE (\"%s.handle = (0.%d.\" FORMAT_RLLx \")\\n\", obj->name,\n                             obj->handle.size, obj->handle.value);\n                }\n              {\n                Dwg_Object_BLOCK_CONTROL *_ctrl\n                    = ctrl->tio.object->tio.BLOCK_CONTROL;\n                ref = dwg_add_handleref (dwg, 2, obj->handle.value, NULL);\n                PUSH_HV (_ctrl, num_entries, entries, ref);\n              }\n              // undo BLOCK_CONTROL.entries and LTYPE_CONTROL.entries\n              if (strEQc (table, \"BLOCK_RECORD\"))\n                {\n                  Dwg_Object_BLOCK_CONTROL *_ctrl\n                      = ctrl->tio.object->tio.BLOCK_CONTROL;\n                  if (_ctrl->model_space\n                      && obj->handle.value == _ctrl->model_space->absolute_ref)\n                    i--;\n                  else if (_ctrl->paper_space\n                           && obj->handle.value\n                                  == _ctrl->paper_space->absolute_ref)\n                    i--;\n                }\n              else if (strEQc (table, \"LTYPE\"))\n                {\n                  Dwg_Object_LTYPE *_obj = obj->tio.object->tio.LTYPE;\n                  Dwg_Object_LTYPE_CONTROL *_ctrl\n                      = ctrl->tio.object->tio.LTYPE_CONTROL;\n                  int j = _ctrl->num_entries;\n                  if (_ctrl->bylayer\n                      && obj->handle.value == _ctrl->bylayer->absolute_ref)\n                    i--;\n                  else if (_ctrl->byblock\n                           && obj->handle.value\n                                  == _ctrl->byblock->absolute_ref)\n                    i--;\n                  else\n                    {\n                      if (dwg->header.from_version > R_2004 && _obj->name\n                          && _obj->has_strings_area)\n                        {\n                          _obj->strings_area = (BITCODE_TF)xcalloc (512, 1);\n                          if (!_obj->strings_area)\n                            {\n                              free (dxfname);\n                              goto outofmem;\n                            }\n                        }\n                      if (dwg->header.from_version <= R_2004)\n                        {\n                          _obj->strings_area = (BITCODE_TF)xcalloc (256, 1);\n                          if (!_obj->strings_area)\n                            {\n                              free (dxfname);\n                              goto outofmem;\n                            }\n                        }\n                    }\n                }\n            }\n          // next table\n          // fixup entries vs num_entries (no NULL entries)\n          {\n            Dwg_Object *ctrl = &dwg->object[ctrl_id];\n            Dwg_Object_BLOCK_CONTROL *_ctrl\n                = ctrl->tio.object->tio.BLOCK_CONTROL;\n            int at_end = 1;\n            unsigned num_entries = 0;\n            if (!dwg_obj_is_control (ctrl))\n              {\n                LOG_ERROR (\"Missing CONTROL object\");\n                dxf_free_pair (pair);\n                return 1;\n              }\n            // A minimal DXF will have no handle values, assign them then\n            if (!ctrl->handle.value)\n              {\n                BITCODE_RLL next_handle = dwg_next_handle (dwg);\n                dwg_add_handle (&ctrl->handle, 0, next_handle, NULL);\n                // adds header_vars->CONTROL ref\n                (void)dwg_ctrl_table (dwg, table);\n                // ref = dwg_add_handleref (dwg, 3, next_handle, ctrl);\n                LOG_TRACE (\"%s.handle = (0.%d.\" FORMAT_RLLx \")\\n\", ctrl->name,\n                           ctrl->handle.size, ctrl->handle.value);\n              }\n            num_entries = _ctrl->num_entries;\n            if (_ctrl && ctrl->fixedtype == DWG_TYPE_BLOCK_CONTROL)\n              {\n                for (int j = num_entries - 1; j >= 0; j--)\n                  {\n                    BITCODE_H ref = _ctrl->entries ? _ctrl->entries[j] : NULL;\n                    if (!ref)\n                      {\n                        if (at_end)\n                          {\n                            num_entries--;\n                          }\n                        else\n                          {\n                            _ctrl->entries[j]\n                                = dwg_add_handleref (dwg, 2, 0, NULL);\n                            LOG_TRACE (\"%s.entries[%d] = (2.0.0)\\n\",\n                                       ctrl->name, j);\n                          }\n                      }\n                    else\n                      at_end = 0;\n                  }\n                // remove many empty entries at the end at once (avoids DDOS)\n                if (num_entries != _ctrl->num_entries)\n                  {\n                    _ctrl->entries = (BITCODE_H *)realloc (\n                        _ctrl->entries, num_entries * sizeof (BITCODE_H));\n                    if (num_entries && !_ctrl->entries)\n                      goto outofmem;\n                    _ctrl->num_entries = num_entries;\n                    LOG_TRACE (\"%s.num_entries => %d\\n\", ctrl->name,\n                               _ctrl->num_entries);\n                  }\n                // leave room for one active entry\n                if (_ctrl->num_entries == 1 && !_ctrl->entries[0])\n                  {\n                    _ctrl->entries[0] = dwg_add_handleref (dwg, 2, 0, NULL);\n                    LOG_TRACE (\"%s.entries[0] = (2.0.0)\\n\", ctrl->name);\n                  }\n              }\n          }\n        }\n      DXF_RETURN_ENDSEC (0) // next TABLE or ENDSEC\n      dxf_free_pair (pair);\n      pair = dxf_read_pair (dat);\n      DXF_CHECK_EOF;\n    } // while (pair)\n  dxf_free_pair (pair);\n  return 0;\n\noutofmem:\n  dxf_free_pair (pair);\n  return DWG_ERR_OUTOFMEM;\n}\n\nEXPORT int\ndwg_read_dxf (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  // const int minimal = dwg->opts & DWG_OPTS_MINIMAL;\n  Dxf_Pair *pair = NULL;\n  int error = 0;\n\n  loglevel = dwg->opts & DWG_OPTS_LOGLEVEL;\n  if (!dat->chain && dat->fh)\n    {\n      error = dat_read_stream (dat, dat->fh);\n      if (error >= DWG_ERR_CRITICAL)\n        return error;\n      if (dat->size >= 22\n          && !memcmp (dat->chain, \"AutoCAD Binary DXF\",\n                      sizeof (\"AutoCAD Binary DXF\") - 1))\n        {\n          dat->opts |= DWG_OPTS_DXFB;\n          dat->byte = 22;\n        }\n    }\n  if (dat->size < 256)\n    {\n      LOG_ERROR (\"DXF input too small, %\" PRIuSIZE \" byte.\\n\", dat->size);\n      return DWG_ERR_IOERROR;\n    }\n  /* Fail early on DWG */\n  if (!memcmp (dat->chain, \"AC10\", 4) || !memcmp (dat->chain, \"AC1.\", 4)\n      || !memcmp (dat->chain, \"AC2.10\", 4) || !memcmp (dat->chain, \"MC0.0\", 4))\n    {\n      LOG_ERROR (\"This is a DWG, not a DXF\\n\");\n      return DWG_ERR_INVALIDDWG;\n    }\n  dat->opts |= DWG_OPTS_INDXF;\n  dwg->opts |= DWG_OPTS_INDXF;\n  // num_dxf_objs = 0;\n  // size_dxf_objs = 1000;\n  // dxf_objs = (Dxf_Objs *)malloc (1000 * sizeof (Dxf_Objs));\n  if (!dwg->object_map)\n    dwg->object_map = hash_new (dat->size / 1000);\n  // cannot rely on ref->obj during realloc's\n  dwg->dirty_refs = 1;\n\n  header_hdls = new_array_hdls (16);\n  eed_hdls = new_array_hdls (16);\n  obj_hdls = new_array_hdls (16);\n\n  // start with the BLOCK_HEADER at objid 0\n  if (!dwg->num_objects)\n    {\n      Dwg_Object *obj;\n      Dwg_Object_BLOCK_HEADER *_obj;\n      char *dxfname = strdup ((char *)\"BLOCK_HEADER\");\n      NEW_OBJECT (dwg, obj);\n      ADD_OBJECT1 (BLOCK_HEADER, BLOCK_HEADER);\n      // dwg->header.version probably here still unknown. <r2000: 0x17\n      // later fixed up when reading $ACADVER and the BLOCK_HEADER.name\n      _obj->name = dwg_add_u8_input (dwg, \"*Model_Space\");\n      _obj->is_xref_ref = 1;\n      obj->tio.object->is_xdic_missing = 1;\n      dwg_add_handle (&obj->handle, 0, 0x1F, obj);\n      obj->tio.object->ownerhandle = dwg_add_handleref (dwg, 4, 1, NULL);\n    }\n\n  while (dat->byte < dat->size)\n    {\n      pair = dxf_read_pair (dat);\n      DXF_BREAK_EOF;\n      pair = dxf_expect_code (dat, pair, 0);\n      DXF_BREAK_EOF;\n      if (pair->type == DWG_VT_STRING && strEQc (pair->value.s, \"SECTION\"))\n        {\n          dxf_free_pair (pair);\n          pair = dxf_read_pair (dat);\n          DXF_BREAK_EOF;\n          pair = dxf_expect_code (dat, pair, 2);\n          DXF_BREAK_EOF;\n          if (!pair->value.s)\n            {\n              LOG_ERROR (\"Expected SECTION string code 2, got code %d\",\n                         pair->code);\n              dxf_free_pair (pair);\n              pair = NULL;\n              break;\n            }\n          else if (strEQc (pair->value.s, \"HEADER\"))\n            {\n              dxf_free_pair (pair);\n              pair = NULL;\n              error = dxf_header_read (dat, dwg);\n              if (error > DWG_ERR_CRITICAL)\n                goto error;\n              dxf_fixup_header (dat, dwg);\n              // skip minimal DXF\n              /*\n              if (!dwg->header_vars.DIMPOST) // T in all versions\n                {\n                  LOG_ERROR (\"Unsupported minimal DXF\");\n                  return DWG_ERR_INVALIDDWG;\n                }\n              */\n            }\n          else if (strEQc (pair->value.s, \"CLASSES\"))\n            {\n              dxf_free_pair (pair);\n              pair = NULL;\n              if (dwg->header.from_version == R_INVALID)\n                dxf_fixup_header (dat, dwg);\n              error = dxf_classes_read (dat, dwg);\n              if (error > DWG_ERR_CRITICAL)\n                return error;\n            }\n          else if (strEQc (pair->value.s, \"TABLES\"))\n            {\n              BITCODE_H hdl;\n              dxf_free_pair (pair);\n              pair = NULL;\n              error = dxf_tables_read (dat, dwg);\n              if (error > DWG_ERR_CRITICAL)\n                goto error;\n\n              resolve_postponed_header_refs (dwg);\n              resolve_postponed_eed_refs (dwg);\n              if (dwg->header.from_version == R_INVALID)\n                dxf_fixup_header (dat, dwg);\n\n              // should not happen\n              if (!dwg->header_vars.LTYPE_BYLAYER\n                  && (hdl = dwg_find_tablehandle_silent (\n                          dwg, (char *)\"ByLayer\", \"LTYPE\")))\n                dwg->header_vars.LTYPE_BYLAYER\n                    = dwg_add_handleref (dwg, 5, hdl->handleref.value, NULL);\n              // should not happen\n              if (!dwg->header_vars.LTYPE_BYBLOCK\n                  && (hdl = dwg_find_tablehandle_silent (\n                          dwg, (char *)\"ByBlock\", \"LTYPE\")))\n                dwg->header_vars.LTYPE_BYBLOCK\n                    = dwg_add_handleref (dwg, 5, hdl->handleref.value, NULL);\n              // but this is needed\n              if (!dwg->header_vars.LTYPE_CONTINUOUS\n                  && (hdl = dwg_find_tablehandle_silent (\n                          dwg, (char *)\"Continuous\", \"LTYPE\")))\n                dwg->header_vars.LTYPE_CONTINUOUS\n                    = dwg_add_handleref (dwg, 5, hdl->handleref.value, NULL);\n            }\n          else if (strEQc (pair->value.s, \"BLOCKS\"))\n            {\n              BITCODE_H hdl;\n              dxf_free_pair (pair);\n              pair = NULL;\n              if (dwg->header.from_version == R_INVALID)\n                dxf_fixup_header (dat, dwg);\n              error = dxf_blocks_read (dat, dwg);\n              if (error > DWG_ERR_CRITICAL)\n                goto error;\n\n              // resolve_postponed_header_refs (dwg);\n              if (!dwg->header_vars.BLOCK_RECORD_PSPACE\n                  && (hdl = dwg_find_tablehandle_silent (\n                          dwg, (char *)\"*Paper_Space\", \"BLOCK\")))\n                dwg->header_vars.BLOCK_RECORD_PSPACE\n                    = dwg_add_handleref (dwg, 5, hdl->handleref.value, NULL);\n              if (!dwg->header_vars.BLOCK_RECORD_MSPACE\n                  && (hdl = dwg_find_tablehandle_silent (\n                          dwg, (char *)\"*Model_Space\", \"BLOCK\")))\n                dwg->header_vars.BLOCK_RECORD_MSPACE\n                    = dwg_add_handleref (dwg, 5, hdl->handleref.value, NULL);\n            }\n          else if (strEQc (pair->value.s, \"ENTITIES\"))\n            {\n              dxf_free_pair (pair);\n              pair = NULL;\n              resolve_postponed_object_refs (dwg);\n              error = dxf_entities_read (dat, dwg);\n              if (error > DWG_ERR_CRITICAL)\n                goto error;\n            }\n          else if (strEQc (pair->value.s, \"OBJECTS\"))\n            {\n              dxf_free_pair (pair);\n              pair = NULL;\n              error = dxf_objects_read (dat, dwg);\n              if (error > DWG_ERR_CRITICAL)\n                goto error;\n              resolve_header_dicts (dwg);\n            }\n          else if (strEQc (pair->value.s, \"THUMBNAILIMAGE\"))\n            {\n              dxf_free_pair (pair);\n              pair = NULL;\n              error = dxf_thumbnail_read (dat, dwg);\n            }\n          else if (strEQc (pair->value.s, \"ACDSDATA\"))\n            {\n              dxf_free_pair (pair);\n              pair = NULL;\n              error = dxf_acds_read (dat, dwg);\n            }\n          else // if (strEQc (pair->value.s, \"\"))\n            {\n              LOG_WARN (\"SECTION %s ignored for now\", pair->value.s);\n              dxf_free_pair (pair);\n              pair = NULL;\n              error = dxf_unknownsection_read (dat, dwg);\n            }\n        }\n      else\n        {\n          LOG_ERROR (\"Expected string SECTION\");\n          dxf_free_pair (pair);\n        }\n    }\n  if (pair != NULL && pair->code == 0 && pair->value.s != NULL\n      && strEQc (pair->value.s, \"EOF\"))\n    ;\n  else if (dat->byte >= dat->size || (pair == NULL))\n    error |= DWG_ERR_IOERROR;\n  dxf_free_pair (pair);\n  resolve_postponed_header_refs (dwg);\n  resolve_postponed_object_refs (dwg);\n  LOG_HANDLE (\"Resolving pointers from ObjectRef vector:\\n\");\n  dwg_resolve_objectrefs_silent (dwg);\n  free_array_hdls (header_hdls);\n  free_array_hdls (eed_hdls);\n  free_array_hdls (obj_hdls);\n  if (dwg->header.version <= R_2000 && dwg->header.from_version > R_2000)\n    dwg_fixup_BLOCKS_entities (dwg);\n  LOG_TRACE (\"import from DXF\\n\");\n  if (error > DWG_ERR_CRITICAL)\n    return error;\n  else\n    return dwg->num_objects ? 1 : 0;\n\nerror:\n  dwg->dirty_refs = 0;\n  free_array_hdls (header_hdls);\n  free_array_hdls (eed_hdls);\n  free_array_hdls (obj_hdls);\n  return error;\n}\n\n\n// target function\nstatic BITCODE_RC\ndxf_read_rc (Bit_Chain *dat)\n{\n  const int is_binary = dat->opts & DWG_OPTS_DXFB;\n  if (is_binary)\n    {\n      return bit_read_RC (dat);\n    }\n  else\n    {\n      char *endptr;\n      long num;\n      // avoid overflow over dat->size\n      SAFER_STRTOL (num, BITCODE_RC, 0);\n      if (dat->chain[dat->byte] == '\\r')\n        dat->byte++;\n      if (dat->chain[dat->byte] == '\\n')\n        dat->byte++;\n      if (num > UINT8_MAX)\n        LOG_ERROR (\"%s: RC overflow %ld (at %\" PRIuSIZE \")\", __FUNCTION__, num,\n                   dat->byte);\n      return (BITCODE_RC)num;\n    }\n}\nstatic BITCODE_RS\ndxf_read_rs (Bit_Chain *dat)\n{\n  const int is_binary = dat->opts & DWG_OPTS_DXFB;\n  if (is_binary)\n    {\n      return bit_read_RS (dat);\n    }\n  else\n    {\n      char *endptr;\n      long num;\n      SAFER_STRTOL (num, BITCODE_RS, 0);\n      if (dat->chain[dat->byte] == '\\r')\n        dat->byte++;\n      if (dat->chain[dat->byte] == '\\n')\n        dat->byte++;\n      if (num > UINT16_MAX)\n        LOG_ERROR (\"%s: RS overflow %ld (at %\" PRIuSIZE \")\", __FUNCTION__, num,\n                   dat->byte);\n      return (BITCODE_RS)num;\n    }\n}\nstatic BITCODE_RL\ndxf_read_rl (Bit_Chain *dat)\n{\n  const int is_binary = dat->opts & DWG_OPTS_DXFB;\n  if (is_binary)\n    {\n      return bit_read_RL (dat);\n    }\n  else\n    {\n      char *endptr;\n      long num;\n      // avoid overflow over dat->size\n      SAFER_STRTOL (num, BITCODE_RL, 0);\n      if (dat->chain[dat->byte] == '\\r')\n        dat->byte++;\n      if (dat->chain[dat->byte] == '\\n')\n        dat->byte++;\n      /*\n      if (num > (long)0xffffffff)\n        LOG_ERROR (\"%s: RL overflow %ld (at %\" PRIuSIZE \")\", __FUNCTION__, num,\n                   dat->byte);\n      */\n      return (BITCODE_RL)num;\n    }\n}\nstatic BITCODE_RLL\ndxf_read_rll (Bit_Chain *dat)\n{\n  const int is_binary = dat->opts & DWG_OPTS_DXFB;\n  if (is_binary)\n    {\n      return bit_read_RLL (dat);\n    }\n  else\n    {\n      char *endptr;\n      BITCODE_RLL num;\n      // avoid overflow over dat->size (need final \"  0\\nEOF\")\n      SAFER_STRTOL (num, BITCODE_RLL, 0UL);\n      if (dat->chain[dat->byte] == '\\r')\n        dat->byte++;\n      if (dat->chain[dat->byte] == '\\n')\n        dat->byte++;\n      return num;\n    }\n}\nstatic BITCODE_RD\ndxf_read_rd (Bit_Chain *dat)\n{\n  const int is_binary = dat->opts & DWG_OPTS_DXFB;\n  if (is_binary)\n    {\n      return bit_read_RD (dat);\n    }\n  else\n    {\n      char *str, *endptr;\n      BITCODE_RD num;\n      dxf_skip_ws (dat);\n      str = (char *)&dat->chain[dat->byte];\n      // avoid overflow over dat->size\n      if (dat->byte + 6 >= dat->size\n          || !memchr (str, '\\n', dat->size - dat->byte - 6))\n        {\n          LOG_ERROR (\"Premature DXF end\");\n          dat->byte = dat->size;\n          return (double)NAN;\n        }\n      else\n        num = strtod (str, &endptr);\n      if (endptr)\n        dat->byte += endptr - str;\n      if (errno == ERANGE)\n        return (double)NAN;\n      return num;\n    }\n}\n",
    "target": 1,
    "idx": 1064318,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "// context\nvoid\nxmlFreeNodeList(xmlNodePtr cur) {\n    xmlNodePtr next;\n    xmlNodePtr parent;\n    xmlDictPtr dict = NULL;\n    size_t depth = 0;\n\n    if (cur == NULL) return;\n    if (cur->type == XML_NAMESPACE_DECL) {\n\txmlFreeNsList((xmlNsPtr) cur);\n\treturn;\n    }\n    if (cur->doc != NULL) dict = cur->doc->dict;\n    while (1) {\n        while ((cur->children != NULL) &&\n               (cur->type != XML_DOCUMENT_NODE) &&\n               (cur->type != XML_HTML_DOCUMENT_NODE) &&\n               (cur->type != XML_DTD_NODE) &&\n               (cur->type != XML_ENTITY_REF_NODE)) {\n            cur = cur->children;\n            depth += 1;\n        }\n\n        next = cur->next;\n        parent = cur->parent;\n\tif ((cur->type == XML_DOCUMENT_NODE) ||\n            (cur->type == XML_HTML_DOCUMENT_NODE)) {\n            xmlFreeDoc((xmlDocPtr) cur);\n        } else if (cur->type != XML_DTD_NODE) {\n\n\t    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n\t\txmlDeregisterNodeDefaultValue(cur);\n\n\t    if (((cur->type == XML_ELEMENT_NODE) ||\n\t\t (cur->type == XML_XINCLUDE_START) ||\n\t\t (cur->type == XML_XINCLUDE_END)) &&\n\t\t(cur->properties != NULL))\n\t\txmlFreePropList(cur->properties);\n\t    if ((cur->type != XML_ELEMENT_NODE) &&\n\t\t(cur->type != XML_XINCLUDE_START) &&\n\t\t(cur->type != XML_XINCLUDE_END) &&\n\t\t(cur->type != XML_ENTITY_REF_NODE) &&\n\t\t(cur->content != (xmlChar *) &(cur->properties))) {\n\t\tDICT_FREE(cur->content)\n\t    }\n\t    if (((cur->type == XML_ELEMENT_NODE) ||\n\t         (cur->type == XML_XINCLUDE_START) ||\n\t\t (cur->type == XML_XINCLUDE_END)) &&\n\t\t(cur->nsDef != NULL))\n\t\txmlFreeNsList(cur->nsDef);\n\n\t    /*\n\t     * When a node is a text node or a comment, it uses a global static\n\t     * variable for the name of the node.\n\t     * Otherwise the node name might come from the document's\n\t     * dictionary\n\t     */\n\t    if ((cur->name != NULL) &&\n\t\t(cur->type != XML_TEXT_NODE) &&\n\t\t(cur->type != XML_COMMENT_NODE))\n\t\tDICT_FREE(cur->name)\n\t    xmlFree(cur);\n\t}\n\n        if (next != NULL) {\n\t    cur = next;\n        } else {\n            if ((depth == 0) || (parent == NULL))\n                break;\n            depth -= 1;\n            cur = parent;\n            cur->children = NULL;\n        }\n    }\n}\n\nstatic int\nxmlXIncludeDoProcess(xmlXIncludeCtxtPtr ctxt, xmlDocPtr doc, xmlNodePtr tree,\n                     int skipRoot) {\n    xmlNodePtr cur;\n    int ret = 0;\n    int i, start;\n\n    if ((doc == NULL) || (tree == NULL) || (tree->type == XML_NAMESPACE_DECL))\n\treturn(-1);\n    if ((skipRoot) && (tree->children == NULL))\n        return(-1);\n    if (ctxt == NULL)\n\treturn(-1);\n\n    if (doc->URL != NULL) {\n\tret = xmlXIncludeURLPush(ctxt, doc->URL);\n\tif (ret < 0)\n\t    return(-1);\n    }\n    start = ctxt->incNr;\n\n    /*\n     * TODO: The phases must run separately for recursive inclusions.\n     *\n     * - Phase 1 should start with top-level XInclude nodes, load documents,\n     *   execute XPointer expressions, then process only the result nodes\n     *   (not whole document, see bug #324081) and only for phase 1\n     *   recursively. We will need a backreference from xmlNodes to\n     *   xmlIncludeRefs to detect references that were already visited.\n     *   This can also be used for proper cycle detection, see bug #344240.\n     *\n     * - Phase 2 should visit all top-level XInclude nodes and expand\n     *   possible subreferences in the replacement recursively.\n     *\n     * - Phase 3 should finally replace the top-level XInclude nodes.\n     *   It could also be run together with phase 2.\n     */\n\n    /*\n     * First phase: lookup the elements in the document\n     */\n    if (skipRoot)\n        cur = tree->children;\n    else\n        cur = tree;\n    do {\n\t/* TODO: need to work on entities -> stack */\n        if (xmlXIncludeTestNode(ctxt, cur) == 1) {\n#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n            /*\n             * Avoid superlinear expansion by limiting the total number\n             * of replacements.\n             */\n            if (ctxt->incTotal >= 20)\n                return(-1);\n#endif\n            ctxt->incTotal++;\n            xmlXIncludePreProcessNode(ctxt, cur);\n        } else if ((cur->children != NULL) &&\n                   ((cur->type == XML_DOCUMENT_NODE) ||\n                    (cur->type == XML_ELEMENT_NODE))) {\n            cur = cur->children;\n            continue;\n        }\n        do {\n            if (cur == tree)\n                break;\n            if (cur->next != NULL) {\n                cur = cur->next;\n                break;\n            }\n            cur = cur->parent;\n        } while (cur != NULL);\n    } while ((cur != NULL) && (cur != tree));\n\n    /*\n     * Second Phase : collect the infosets fragments\n     */\n    for (i = start;i < ctxt->incNr; i++) {\n        xmlXIncludeLoadNode(ctxt, i);\n\tret++;\n    }\n\n    /*\n     * Third phase: extend the original document infoset.\n     *\n     * Originally we bypassed the inclusion if there were any errors\n     * encountered on any of the XIncludes.  A bug was raised (bug\n     * 132588) requesting that we output the XIncludes without error,\n     * so the check for inc!=NULL || xptr!=NULL was put in.  This may\n     * give some other problems in the future, but for now it seems to\n     * work ok.\n     *\n     */\n    for (i = ctxt->incBase;i < ctxt->incNr; i++) {\n\tif ((ctxt->incTab[i]->inc != NULL) ||\n\t    (ctxt->incTab[i]->emptyFb != 0))\t/* (empty fallback) */\n\t    xmlXIncludeIncludeNode(ctxt, i);\n    }\n\n    if (doc->URL != NULL)\n\txmlXIncludeURLPop(ctxt);\n    return(ret);\n}\n\nint\nxmlXIncludeProcessTreeFlagsData(xmlNodePtr tree, int flags, void *data) {\n    xmlXIncludeCtxtPtr ctxt;\n    int ret = 0;\n\n    if ((tree == NULL) || (tree->type == XML_NAMESPACE_DECL) ||\n        (tree->doc == NULL))\n        return(-1);\n\n    ctxt = xmlXIncludeNewContext(tree->doc);\n    if (ctxt == NULL)\n        return(-1);\n    ctxt->_private = data;\n    ctxt->base = xmlStrdup((xmlChar *)tree->doc->URL);\n    xmlXIncludeSetFlags(ctxt, flags);\n    ret = xmlXIncludeDoProcess(ctxt, tree->doc, tree, 0);\n    if ((ret >= 0) && (ctxt->nbErrors > 0))\n        ret = -1;\n\n    xmlXIncludeFreeContext(ctxt);\n    return(ret);\n}\n\nint\nxmlXIncludeProcessFlagsData(xmlDocPtr doc, int flags, void *data) {\n    xmlNodePtr tree;\n\n    if (doc == NULL)\n\treturn(-1);\n    tree = xmlDocGetRootElement(doc);\n    if (tree == NULL)\n\treturn(-1);\n    return(xmlXIncludeProcessTreeFlagsData(tree, flags, data));\n}\n\nint\nxmlXIncludeProcessFlags(xmlDocPtr doc, int flags) {\n    return xmlXIncludeProcessFlagsData(doc, flags, NULL);\n}\n\n\n// target function\nstatic xmlNodePtr\nxmlStaticCopyNode(xmlNodePtr node, xmlDocPtr doc, xmlNodePtr parent,\n                  int extended) {\n    xmlNodePtr ret;\n\n    if (node == NULL) return(NULL);\n    switch (node->type) {\n        case XML_TEXT_NODE:\n        case XML_CDATA_SECTION_NODE:\n        case XML_ELEMENT_NODE:\n        case XML_DOCUMENT_FRAG_NODE:\n        case XML_ENTITY_REF_NODE:\n        case XML_ENTITY_NODE:\n        case XML_PI_NODE:\n        case XML_COMMENT_NODE:\n        case XML_XINCLUDE_START:\n        case XML_XINCLUDE_END:\n\t    break;\n        case XML_ATTRIBUTE_NODE:\n\t\treturn((xmlNodePtr) xmlCopyPropInternal(doc, parent, (xmlAttrPtr) node));\n        case XML_NAMESPACE_DECL:\n\t    return((xmlNodePtr) xmlCopyNamespaceList((xmlNsPtr) node));\n\n        case XML_DOCUMENT_NODE:\n        case XML_HTML_DOCUMENT_NODE:\n#ifdef LIBXML_TREE_ENABLED\n\t    return((xmlNodePtr) xmlCopyDoc((xmlDocPtr) node, extended));\n#endif /* LIBXML_TREE_ENABLED */\n        case XML_DOCUMENT_TYPE_NODE:\n        case XML_NOTATION_NODE:\n        case XML_DTD_NODE:\n        case XML_ELEMENT_DECL:\n        case XML_ATTRIBUTE_DECL:\n        case XML_ENTITY_DECL:\n            return(NULL);\n    }\n\n    /*\n     * Allocate a new node and fill the fields.\n     */\n    ret = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));\n    if (ret == NULL) {\n\txmlTreeErrMemory(\"copying node\");\n\treturn(NULL);\n    }\n    memset(ret, 0, sizeof(xmlNode));\n    ret->type = node->type;\n\n    ret->doc = doc;\n    ret->parent = parent;\n    if (node->name == xmlStringText)\n\tret->name = xmlStringText;\n    else if (node->name == xmlStringTextNoenc)\n\tret->name = xmlStringTextNoenc;\n    else if (node->name == xmlStringComment)\n\tret->name = xmlStringComment;\n    else if (node->name != NULL) {\n        if ((doc != NULL) && (doc->dict != NULL))\n\t    ret->name = xmlDictLookup(doc->dict, node->name, -1);\n\telse\n\t    ret->name = xmlStrdup(node->name);\n    }\n    if ((node->type != XML_ELEMENT_NODE) &&\n\t(node->content != NULL) &&\n\t(node->type != XML_ENTITY_REF_NODE) &&\n\t(node->type != XML_XINCLUDE_END) &&\n\t(node->type != XML_XINCLUDE_START)) {\n\tret->content = xmlStrdup(node->content);\n    }else{\n      if (node->type == XML_ELEMENT_NODE)\n        ret->line = node->line;\n    }\n    if (parent != NULL) {\n\txmlNodePtr tmp;\n\n\t/*\n\t * this is a tricky part for the node register thing:\n\t * in case ret does get coalesced in xmlAddChild\n\t * the deregister-node callback is called; so we register ret now already\n\t */\n\tif ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))\n\t    xmlRegisterNodeDefaultValue((xmlNodePtr)ret);\n\n        tmp = xmlAddChild(parent, ret);\n\t/* node could have coalesced */\n\tif (tmp != ret)\n\t    return(tmp);\n    }\n\n    if (!extended)\n\tgoto out;\n    if (((node->type == XML_ELEMENT_NODE) ||\n         (node->type == XML_XINCLUDE_START)) && (node->nsDef != NULL))\n        ret->nsDef = xmlCopyNamespaceList(node->nsDef);\n\n    if (node->ns != NULL) {\n        xmlNsPtr ns;\n\n\tns = xmlSearchNs(doc, ret, node->ns->prefix);\n\tif (ns == NULL) {\n\t    /*\n\t     * Humm, we are copying an element whose namespace is defined\n\t     * out of the new tree scope. Search it in the original tree\n\t     * and add it at the top of the new tree\n\t     */\n\t    ns = xmlSearchNs(node->doc, node, node->ns->prefix);\n\t    if (ns != NULL) {\n\t        xmlNodePtr root = ret;\n\n\t\twhile (root->parent != NULL) root = root->parent;\n\t\tret->ns = xmlNewNs(root, ns->href, ns->prefix);\n\t\t} else {\n\t\t\tret->ns = xmlNewReconciledNs(doc, ret, node->ns);\n\t    }\n\t} else {\n\t    /*\n\t     * reference the existing namespace definition in our own tree.\n\t     */\n\t    ret->ns = ns;\n\t}\n    }\n    if (((node->type == XML_ELEMENT_NODE) ||\n         (node->type == XML_XINCLUDE_START)) && (node->properties != NULL))\n        ret->properties = xmlCopyPropList(ret, node->properties);\n    if (node->type == XML_ENTITY_REF_NODE) {\n\tif ((doc == NULL) || (node->doc != doc)) {\n\t    /*\n\t     * The copied node will go into a separate document, so\n\t     * to avoid dangling references to the ENTITY_DECL node\n\t     * we cannot keep the reference. Try to find it in the\n\t     * target document.\n\t     */\n\t    ret->children = (xmlNodePtr) xmlGetDocEntity(doc, ret->name);\n\t} else {\n            ret->children = node->children;\n\t}\n\tret->last = ret->children;\n    } else if ((node->children != NULL) && (extended != 2)) {\n        xmlNodePtr cur, insert;\n\n        cur = node->children;\n        insert = ret;\n        while (cur != NULL) {\n            xmlNodePtr copy = xmlStaticCopyNode(cur, doc, insert, 2);\n            if (copy == NULL) {\n                xmlFreeNode(ret);\n                return(NULL);\n            }\n\n            if (insert->last == NULL) {\n                insert->children = copy;\n            } else {\n                copy->prev = insert->last;\n                insert->last->next = copy;\n            }\n            insert->last = copy;\n\n            if (cur->children != NULL) {\n                cur = cur->children;\n                insert = copy;\n                continue;\n            }\n\n            while (1) {\n                if (cur->next != NULL) {\n                    cur = cur->next;\n                    break;\n                }\n\n                cur = cur->parent;\n                insert = insert->parent;\n                if (cur == node) {\n                    cur = NULL;\n                    break;\n                }\n            }\n        }\n    }\n\nout:\n    /* if parent != NULL we already registered the node above */\n    if ((parent == NULL) &&\n        ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue)))\n\txmlRegisterNodeDefaultValue((xmlNodePtr)ret);\n    return(ret);\n}\nstatic int\nxmlXIncludeIncludeNode(xmlXIncludeCtxtPtr ctxt, int nr) {\n    xmlNodePtr cur, end, list, tmp;\n\n    if (ctxt == NULL)\n\treturn(-1);\n    if ((nr < 0) || (nr >= ctxt->incNr))\n\treturn(-1);\n    cur = ctxt->incTab[nr]->ref;\n    if ((cur == NULL) || (cur->type == XML_NAMESPACE_DECL))\n\treturn(-1);\n\n    list = ctxt->incTab[nr]->inc;\n    ctxt->incTab[nr]->inc = NULL;\n    ctxt->incTab[nr]->emptyFb = 0;\n\n    /*\n     * Check against the risk of generating a multi-rooted document\n     */\n    if ((cur->parent != NULL) &&\n\t(cur->parent->type != XML_ELEMENT_NODE)) {\n\tint nb_elem = 0;\n\n\ttmp = list;\n\twhile (tmp != NULL) {\n\t    if (tmp->type == XML_ELEMENT_NODE)\n\t\tnb_elem++;\n\t    tmp = tmp->next;\n\t}\n\tif (nb_elem > 1) {\n\t    xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t                   XML_XINCLUDE_MULTIPLE_ROOT,\n\t\t       \"XInclude error: would result in multiple root nodes\\n\",\n\t\t\t   NULL);\n            xmlFreeNodeList(list);\n\t    return(-1);\n\t}\n    }\n\n    if (ctxt->parseFlags & XML_PARSE_NOXINCNODE) {\n\t/*\n\t * Add the list of nodes\n\t */\n\twhile (list != NULL) {\n\t    end = list;\n\t    list = list->next;\n\n\t    xmlAddPrevSibling(cur, end);\n\t}\n\txmlUnlinkNode(cur);\n\txmlFreeNode(cur);\n    } else {\n        xmlNodePtr child, next;\n\n\t/*\n\t * Change the current node as an XInclude start one, and add an\n\t * XInclude end one\n\t */\n        if (ctxt->incTab[nr]->fallback)\n            xmlUnsetProp(cur, BAD_CAST \"href\");\n\tcur->type = XML_XINCLUDE_START;\n        /* Remove fallback children */\n        for (child = cur->children; child != NULL; child = next) {\n            next = child->next;\n            xmlUnlinkNode(child);\n            xmlFreeNode(child);\n        }\n\tend = xmlNewDocNode(cur->doc, cur->ns, cur->name, NULL);\n\tif (end == NULL) {\n\t    xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t                   XML_XINCLUDE_BUILD_FAILED,\n\t\t\t   \"failed to build node\\n\", NULL);\n            xmlFreeNodeList(list);\n\t    return(-1);\n\t}\n\tend->type = XML_XINCLUDE_END;\n\txmlAddNextSibling(cur, end);\n\n\t/*\n\t * Add the list of nodes\n\t */\n\twhile (list != NULL) {\n\t    cur = list;\n\t    list = list->next;\n\n\t    xmlAddPrevSibling(end, cur);\n\t}\n    }\n\n\n    return(0);\n}\n",
    "target": 1,
    "idx": 1046323,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "// context\nvoid shutdown_executor(void) /* {{{ */\n{\n\tzend_string *key;\n\tzval *zv;\n#if ZEND_DEBUG\n\tzend_bool fast_shutdown = 0;\n#else\n\tzend_bool fast_shutdown = is_zend_mm() && !EG(full_tables_cleanup);\n#endif\n\n\tzend_try {\n\t\tzend_llist_destroy(&CG(open_files));\n\t} zend_end_try();\n\n\tEG(flags) |= EG_FLAGS_IN_RESOURCE_SHUTDOWN;\n\tzend_try {\n\t\tzend_close_rsrc_list(&EG(regular_list));\n\t} zend_end_try();\n\n\t/* No PHP callback functions should be called after this point. */\n\tEG(active) = 0;\n\n\tif (!fast_shutdown) {\n\t\tzend_hash_graceful_reverse_destroy(&EG(symbol_table));\n\n\t\t/* Release static properties and static variables prior to the final GC run,\n\t\t * as they may hold GC roots. */\n\t\tZEND_HASH_REVERSE_FOREACH_VAL(EG(function_table), zv) {\n\t\t\tzend_op_array *op_array = Z_PTR_P(zv);\n\t\t\tif (op_array->type == ZEND_INTERNAL_FUNCTION) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (op_array->static_variables) {\n\t\t\t\tHashTable *ht = ZEND_MAP_PTR_GET(op_array->static_variables_ptr);\n\t\t\t\tif (ht) {\n\t\t\t\t\tzend_array_release(ht);\n\t\t\t\t\tZEND_MAP_PTR_SET(op_array->static_variables_ptr, NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t} ZEND_HASH_FOREACH_END();\n\t\tZEND_HASH_REVERSE_FOREACH_VAL(EG(class_table), zv) {\n\t\t\tzend_class_entry *ce = Z_PTR_P(zv);\n\t\t\tif (ce->default_static_members_count) {\n\t\t\t\tzend_cleanup_internal_class_data(ce);\n\t\t\t}\n\t\t\tif (ce->ce_flags & ZEND_HAS_STATIC_IN_METHODS) {\n\t\t\t\tzend_op_array *op_array;\n\t\t\t\tZEND_HASH_FOREACH_PTR(&ce->function_table, op_array) {\n\t\t\t\t\tif (op_array->type == ZEND_USER_FUNCTION) {\n\t\t\t\t\t\tif (op_array->static_variables) {\n\t\t\t\t\t\t\tHashTable *ht = ZEND_MAP_PTR_GET(op_array->static_variables_ptr);\n\t\t\t\t\t\t\tif (ht) {\n\t\t\t\t\t\t\t\tzend_array_release(ht);\n\t\t\t\t\t\t\t\tZEND_MAP_PTR_SET(op_array->static_variables_ptr, NULL);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} ZEND_HASH_FOREACH_END();\n\t\t\t}\n\t\t} ZEND_HASH_FOREACH_END();\n\n\t\t/* Also release error and exception handlers, which may hold objects. */\n\t\tif (Z_TYPE(EG(user_error_handler)) != IS_UNDEF) {\n\t\t\tzval_ptr_dtor(&EG(user_error_handler));\n\t\t\tZVAL_UNDEF(&EG(user_error_handler));\n\t\t}\n\n\t\tif (Z_TYPE(EG(user_exception_handler)) != IS_UNDEF) {\n\t\t\tzval_ptr_dtor(&EG(user_exception_handler));\n\t\t\tZVAL_UNDEF(&EG(user_exception_handler));\n\t\t}\n\n\t\tzend_stack_clean(&EG(user_error_handlers_error_reporting), NULL, 1);\n\t\tzend_stack_clean(&EG(user_error_handlers), (void (*)(void *))ZVAL_PTR_DTOR, 1);\n\t\tzend_stack_clean(&EG(user_exception_handlers), (void (*)(void *))ZVAL_PTR_DTOR, 1);\n\n#if ZEND_DEBUG\n\t\tif (!CG(unclean_shutdown)) {\n\t\t\tgc_collect_cycles();\n\t\t}\n#endif\n\t}\n\n\tzend_objects_store_free_object_storage(&EG(objects_store), fast_shutdown);\n\n\tzend_weakrefs_shutdown();\n\n\tzend_try {\n\t\tzend_llist_apply(&zend_extensions, (llist_apply_func_t) zend_extension_deactivator);\n\t} zend_end_try();\n\n\tif (fast_shutdown) {\n\t\t/* Fast Request Shutdown\n\t\t * =====================\n\t\t * Zend Memory Manager frees memory by its own. We don't have to free\n\t\t * each allocated block separately.\n\t\t */\n\t\tzend_hash_discard(EG(zend_constants), EG(persistent_constants_count));\n\t\tzend_hash_discard(EG(function_table), EG(persistent_functions_count));\n\t\tzend_hash_discard(EG(class_table), EG(persistent_classes_count));\n\t\tzend_cleanup_internal_classes();\n\t} else {\n\t\tzend_vm_stack_destroy();\n\n\t\tif (EG(full_tables_cleanup)) {\n\t\t\tzend_hash_reverse_apply(EG(zend_constants), clean_non_persistent_constant_full);\n\t\t\tzend_hash_reverse_apply(EG(function_table), clean_non_persistent_function_full);\n\t\t\tzend_hash_reverse_apply(EG(class_table), clean_non_persistent_class_full);\n\t\t} else {\n\t\t\tZEND_HASH_REVERSE_FOREACH_STR_KEY_VAL(EG(zend_constants), key, zv) {\n\t\t\t\tzend_constant *c = Z_PTR_P(zv);\n\t\t\t\tif (_idx == EG(persistent_constants_count)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tzval_ptr_dtor_nogc(&c->value);\n\t\t\t\tif (c->name) {\n\t\t\t\t\tzend_string_release_ex(c->name, 0);\n\t\t\t\t}\n\t\t\t\tefree(c);\n\t\t\t\tzend_string_release_ex(key, 0);\n\t\t\t} ZEND_HASH_FOREACH_END_DEL();\n\n\t\t\tZEND_HASH_REVERSE_FOREACH_STR_KEY_VAL(EG(function_table), key, zv) {\n\t\t\t\tzend_function *func = Z_PTR_P(zv);\n\t\t\t\tif (_idx == EG(persistent_functions_count)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdestroy_op_array(&func->op_array);\n\t\t\t\tzend_string_release_ex(key, 0);\n\t\t\t} ZEND_HASH_FOREACH_END_DEL();\n\n\t\t\tZEND_HASH_REVERSE_FOREACH_STR_KEY_VAL(EG(class_table), key, zv) {\n\t\t\t\tif (_idx == EG(persistent_classes_count)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdestroy_zend_class(zv);\n\t\t\t\tzend_string_release_ex(key, 0);\n\t\t\t} ZEND_HASH_FOREACH_END_DEL();\n\t\t}\n\n\t\twhile (EG(symtable_cache_ptr) > EG(symtable_cache)) {\n\t\t\tEG(symtable_cache_ptr)--;\n\t\t\tzend_hash_destroy(*EG(symtable_cache_ptr));\n\t\t\tFREE_HASHTABLE(*EG(symtable_cache_ptr));\n\t\t}\n\n\t\tzend_hash_destroy(&EG(included_files));\n\n\t\tzend_stack_destroy(&EG(user_error_handlers_error_reporting));\n\t\tzend_stack_destroy(&EG(user_error_handlers));\n\t\tzend_stack_destroy(&EG(user_exception_handlers));\n\t\tzend_objects_store_destroy(&EG(objects_store));\n\t\tif (EG(in_autoload)) {\n\t\t\tzend_hash_destroy(EG(in_autoload));\n\t\t\tFREE_HASHTABLE(EG(in_autoload));\n\t\t}\n\n\t\tif (EG(ht_iterators) != EG(ht_iterators_slots)) {\n\t\t\tefree(EG(ht_iterators));\n\t\t}\n\t}\n\n#if ZEND_DEBUG\n\tif (EG(ht_iterators_used) && !CG(unclean_shutdown)) {\n\t\tzend_error(E_WARNING, \"Leaked %\" PRIu32 \" hashtable iterators\", EG(ht_iterators_used));\n\t}\n#endif\n\n\tEG(ht_iterators_used) = 0;\n\n\tzend_shutdown_fpu();\n}\n\nZEND_API void zend_deactivate(void) /* {{{ */\n{\n\t/* we're no longer executing anything */\n\tEG(current_execute_data) = NULL;\n\n\tzend_try {\n\t\tshutdown_scanner();\n\t} zend_end_try();\n\nvoid php_request_shutdown(void *dummy)\n{\n\tzend_bool report_memleaks;\n\n\tEG(flags) |= EG_FLAGS_IN_SHUTDOWN;\n\n\treport_memleaks = PG(report_memleaks);\n\n\t/* EG(current_execute_data) points into nirvana and therefore cannot be safely accessed\n\t * inside zend_executor callback functions.\n\t */\n\tEG(current_execute_data) = NULL;\n\n\tphp_deactivate_ticks();\n\n\t/* 1. Call all possible shutdown functions registered with register_shutdown_function() */\n\tif (PG(modules_activated)) {\n\t\tphp_call_shutdown_functions();\n\t}\n\n\t/* 2. Call all possible __destruct() functions */\n\tzend_try {\n\t\tzend_call_destructors();\n\t} zend_end_try();\n\nvoid fuzzer_request_shutdown()\n{\n\tzend_try {\n\t\t/* Destroy thrown exceptions. This does not happen as part of request shutdown. */\n\t\tif (EG(exception)) {\n\t\t\tzend_object_release(EG(exception));\n\t\t\tEG(exception) = NULL;\n\t\t}\n\n\t\t/* Some fuzzers (like unserialize) may create circular structures. Make sure we free them.\n\t\t * Two calls are performed to handle objects with destructors. */\n\t\tzend_gc_collect_cycles();\n\t\tzend_gc_collect_cycles();\n\t} zend_end_try();\n\n\tphp_request_shutdown(NULL);\n}\n\nint fuzzer_do_request_from_buffer(\n\t\tchar *filename, const char *data, size_t data_len, zend_bool execute)\n{\n\tint retval = FAILURE; /* failure by default */\n\n\tSG(options) |= SAPI_OPTION_NO_CHDIR;\n\tSG(request_info).argc=0;\n\tSG(request_info).argv=NULL;\n\n\tif (fuzzer_request_startup() == FAILURE) {\n\t\treturn FAILURE;\n\t}\n\n\t// Commented out to avoid leaking the header callback.\n\t//SG(headers_sent) = 1;\n\t//SG(request_info).no_headers = 1;\n\tphp_register_variable(\"PHP_SELF\", filename, NULL);\n\n\tzend_first_try {\n\t\tzend_file_handle file_handle;\n\t\tzend_stream_init_filename(&file_handle, filename);\n\t\tfile_handle.buf = estrndup(data, data_len);\n\t\tfile_handle.len = data_len;\n\n\t\tzend_op_array *op_array = zend_compile_file(&file_handle, ZEND_REQUIRE);\n\t\tif (op_array) {\n\t\t\tif (execute) {\n\t\t\t\tzend_execute(op_array, NULL);\n\t\t\t}\n\t\t\tdestroy_op_array(op_array);\n\t\t\tefree(op_array);\n\t\t}\n\t} zend_end_try();\n\n\tCG(compiled_filename) = NULL; /* ??? */\n\tfuzzer_request_shutdown();\n\n\treturn (retval == SUCCESS) ? SUCCESS : FAILURE;\n}\n\n\n// target function\nZEND_API zend_result zend_disable_function(const char *function_name, size_t function_name_length) /* {{{ */\n{\n\treturn zend_hash_str_del(CG(function_table), function_name, function_name_length);\n}\nint php_module_startup(sapi_module_struct *sf, zend_module_entry *additional_modules, uint32_t num_additional_modules)\n{\n\tzend_utility_functions zuf;\n\tzend_utility_values zuv;\n\tint retval = SUCCESS, module_number=0;\t/* for REGISTER_INI_ENTRIES() */\n\tchar *php_os;\n\tzend_module_entry *module;\n\n#ifdef PHP_WIN32\n\tWORD wVersionRequested = MAKEWORD(2, 0);\n\tWSADATA wsaData;\n\n\tphp_os = \"WINNT\";\n\n\told_invalid_parameter_handler =\n\t\t_set_invalid_parameter_handler(dummy_invalid_parameter_handler);\n\tif (old_invalid_parameter_handler != NULL) {\n\t\t_set_invalid_parameter_handler(old_invalid_parameter_handler);\n\t}\n\n\t/* Disable the message box for assertions.*/\n\t_CrtSetReportMode(_CRT_ASSERT, 0);\n#else\n\tphp_os = PHP_OS;\n#endif\n\n#ifdef ZTS\n\t(void)ts_resource(0);\n#endif\n\n#ifdef PHP_WIN32\n\tif (!php_win32_init_random_bytes()) {\n\t\tfprintf(stderr, \"\\ncrypt algorithm provider initialization failed\\n\");\n\t\treturn FAILURE;\n\t}\n#endif\n\n\tmodule_shutdown = 0;\n\tmodule_startup = 1;\n\tsapi_initialize_empty_request();\n\tsapi_activate();\n\n\tif (module_initialized) {\n\t\treturn SUCCESS;\n\t}\n\n\tsapi_module = *sf;\n\n\tphp_output_startup();\n\n#ifdef ZTS\n\tts_allocate_fast_id(&core_globals_id, &core_globals_offset, sizeof(php_core_globals), (ts_allocate_ctor) core_globals_ctor, (ts_allocate_dtor) core_globals_dtor);\n#ifdef PHP_WIN32\n\tts_allocate_id(&php_win32_core_globals_id, sizeof(php_win32_core_globals), (ts_allocate_ctor) php_win32_core_globals_ctor, (ts_allocate_dtor) php_win32_core_globals_dtor);\n#endif\n#else\n\tmemset(&core_globals, 0, sizeof(core_globals));\n\tphp_startup_ticks();\n#endif\n\tgc_globals_ctor();\n\n\tzuf.error_function = php_error_cb;\n\tzuf.printf_function = php_printf;\n\tzuf.write_function = php_output_write;\n\tzuf.fopen_function = php_fopen_wrapper_for_zend;\n\tzuf.message_handler = php_message_handler_for_zend;\n\tzuf.get_configuration_directive = php_get_configuration_directive_for_zend;\n\tzuf.ticks_function = php_run_ticks;\n\tzuf.on_timeout = php_on_timeout;\n\tzuf.stream_open_function = php_stream_open_for_zend;\n\tzuf.printf_to_smart_string_function = php_printf_to_smart_string;\n\tzuf.printf_to_smart_str_function = php_printf_to_smart_str;\n\tzuf.getenv_function = sapi_getenv;\n\tzuf.resolve_path_function = php_resolve_path_for_zend;\n\tzend_startup(&zuf);\n\tzend_update_current_locale();\n\n#if ZEND_DEBUG\n\tzend_register_error_notify_callback(report_zend_debug_error_notify_cb);\n#endif\n\n#if HAVE_TZSET\n\ttzset();\n#endif\n\n#ifdef PHP_WIN32\n# if PHP_LINKER_MAJOR == 14\n\t/* Extend for other CRT if needed. */\n#  if PHP_DEBUG\n#   define PHP_VCRUNTIME \"vcruntime140d.dll\"\n#  else\n#   define PHP_VCRUNTIME \"vcruntime140.dll\"\n#  endif\n\tchar *img_err;\n\tif (!php_win32_crt_compatible(PHP_VCRUNTIME, &img_err)) {\n\t\tphp_error(E_CORE_WARNING, img_err);\n\t\tefree(img_err);\n\t\treturn FAILURE;\n\t}\n#  undef PHP_VCRUNTIME\n# endif\n\n\t/* start up winsock services */\n\tif (WSAStartup(wVersionRequested, &wsaData) != 0) {\n\t\tphp_printf(\"\\nwinsock.dll unusable. %d\\n\", WSAGetLastError());\n\t\treturn FAILURE;\n\t}\n\tphp_win32_signal_ctrl_handler_init();\n#endif\n\n\tle_index_ptr = zend_register_list_destructors_ex(NULL, NULL, \"index pointer\", 0);\n\n\t/* Register constants */\n\tREGISTER_MAIN_STRINGL_CONSTANT(\"PHP_VERSION\", PHP_VERSION, sizeof(PHP_VERSION)-1, CONST_PERSISTENT | CONST_CS);\n\tREGISTER_MAIN_LONG_CONSTANT(\"PHP_MAJOR_VERSION\", PHP_MAJOR_VERSION, CONST_PERSISTENT | CONST_CS);\n\tREGISTER_MAIN_LONG_CONSTANT(\"PHP_MINOR_VERSION\", PHP_MINOR_VERSION, CONST_PERSISTENT | CONST_CS);\n\tREGISTER_MAIN_LONG_CONSTANT(\"PHP_RELEASE_VERSION\", PHP_RELEASE_VERSION, CONST_PERSISTENT | CONST_CS);\n\tREGISTER_MAIN_STRINGL_CONSTANT(\"PHP_EXTRA_VERSION\", PHP_EXTRA_VERSION, sizeof(PHP_EXTRA_VERSION) - 1, CONST_PERSISTENT | CONST_CS);\n\tREGISTER_MAIN_LONG_CONSTANT(\"PHP_VERSION_ID\", PHP_VERSION_ID, CONST_PERSISTENT | CONST_CS);\n#ifdef ZTS\n\tREGISTER_MAIN_LONG_CONSTANT(\"PHP_ZTS\", 1, CONST_PERSISTENT | CONST_CS);\n#else\n\tREGISTER_MAIN_LONG_CONSTANT(\"PHP_ZTS\", 0, CONST_PERSISTENT | CONST_CS);\n#endif\n\tREGISTER_MAIN_LONG_CONSTANT(\"PHP_DEBUG\", PHP_DEBUG, CONST_PERSISTENT | CONST_CS);\n\tREGISTER_MAIN_STRINGL_CONSTANT(\"PHP_OS\", php_os, strlen(php_os), CONST_PERSISTENT | CONST_CS);\n\tREGISTER_MAIN_STRINGL_CONSTANT(\"PHP_OS_FAMILY\", PHP_OS_FAMILY, sizeof(PHP_OS_FAMILY)-1, CONST_PERSISTENT | CONST_CS);\n\tREGISTER_MAIN_STRINGL_CONSTANT(\"PHP_SAPI\", sapi_module.name, strlen(sapi_module.name), CONST_PERSISTENT | CONST_CS | CONST_NO_FILE_CACHE);\n\tREGISTER_MAIN_STRINGL_CONSTANT(\"DEFAULT_INCLUDE_PATH\", PHP_INCLUDE_PATH, sizeof(PHP_INCLUDE_PATH)-1, CONST_PERSISTENT | CONST_CS);\n\tREGISTER_MAIN_STRINGL_CONSTANT(\"PEAR_INSTALL_DIR\", PEAR_INSTALLDIR, sizeof(PEAR_INSTALLDIR)-1, CONST_PERSISTENT | CONST_CS);\n\tREGISTER_MAIN_STRINGL_CONSTANT(\"PEAR_EXTENSION_DIR\", PHP_EXTENSION_DIR, sizeof(PHP_EXTENSION_DIR)-1, CONST_PERSISTENT | CONST_CS);\n\tREGISTER_MAIN_STRINGL_CONSTANT(\"PHP_EXTENSION_DIR\", PHP_EXTENSION_DIR, sizeof(PHP_EXTENSION_DIR)-1, CONST_PERSISTENT | CONST_CS);\n\tREGISTER_MAIN_STRINGL_CONSTANT(\"PHP_PREFIX\", PHP_PREFIX, sizeof(PHP_PREFIX)-1, CONST_PERSISTENT | CONST_CS);\n\tREGISTER_MAIN_STRINGL_CONSTANT(\"PHP_BINDIR\", PHP_BINDIR, sizeof(PHP_BINDIR)-1, CONST_PERSISTENT | CONST_CS);\n#ifndef PHP_WIN32\n\tREGISTER_MAIN_STRINGL_CONSTANT(\"PHP_MANDIR\", PHP_MANDIR, sizeof(PHP_MANDIR)-1, CONST_PERSISTENT | CONST_CS);\n#endif\n\tREGISTER_MAIN_STRINGL_CONSTANT(\"PHP_LIBDIR\", PHP_LIBDIR, sizeof(PHP_LIBDIR)-1, CONST_PERSISTENT | CONST_CS);\n\tREGISTER_MAIN_STRINGL_CONSTANT(\"PHP_DATADIR\", PHP_DATADIR, sizeof(PHP_DATADIR)-1, CONST_PERSISTENT | CONST_CS);\n\tREGISTER_MAIN_STRINGL_CONSTANT(\"PHP_SYSCONFDIR\", PHP_SYSCONFDIR, sizeof(PHP_SYSCONFDIR)-1, CONST_PERSISTENT | CONST_CS);\n\tREGISTER_MAIN_STRINGL_CONSTANT(\"PHP_LOCALSTATEDIR\", PHP_LOCALSTATEDIR, sizeof(PHP_LOCALSTATEDIR)-1, CONST_PERSISTENT | CONST_CS);\n\tREGISTER_MAIN_STRINGL_CONSTANT(\"PHP_CONFIG_FILE_PATH\", PHP_CONFIG_FILE_PATH, strlen(PHP_CONFIG_FILE_PATH), CONST_PERSISTENT | CONST_CS);\n\tREGISTER_MAIN_STRINGL_CONSTANT(\"PHP_CONFIG_FILE_SCAN_DIR\", PHP_CONFIG_FILE_SCAN_DIR, sizeof(PHP_CONFIG_FILE_SCAN_DIR)-1, CONST_PERSISTENT | CONST_CS);\n\tREGISTER_MAIN_STRINGL_CONSTANT(\"PHP_SHLIB_SUFFIX\", PHP_SHLIB_SUFFIX, sizeof(PHP_SHLIB_SUFFIX)-1, CONST_PERSISTENT | CONST_CS);\n\tREGISTER_MAIN_STRINGL_CONSTANT(\"PHP_EOL\", PHP_EOL, sizeof(PHP_EOL)-1, CONST_PERSISTENT | CONST_CS);\n\tREGISTER_MAIN_LONG_CONSTANT(\"PHP_MAXPATHLEN\", MAXPATHLEN, CONST_PERSISTENT | CONST_CS);\n\tREGISTER_MAIN_LONG_CONSTANT(\"PHP_INT_MAX\", ZEND_LONG_MAX, CONST_PERSISTENT | CONST_CS);\n\tREGISTER_MAIN_LONG_CONSTANT(\"PHP_INT_MIN\", ZEND_LONG_MIN, CONST_PERSISTENT | CONST_CS);\n\tREGISTER_MAIN_LONG_CONSTANT(\"PHP_INT_SIZE\", SIZEOF_ZEND_LONG, CONST_PERSISTENT | CONST_CS);\n\tREGISTER_MAIN_LONG_CONSTANT(\"PHP_FD_SETSIZE\", FD_SETSIZE, CONST_PERSISTENT | CONST_CS);\n\tREGISTER_MAIN_LONG_CONSTANT(\"PHP_FLOAT_DIG\", DBL_DIG, CONST_PERSISTENT | CONST_CS);\n\tREGISTER_MAIN_DOUBLE_CONSTANT(\"PHP_FLOAT_EPSILON\", DBL_EPSILON, CONST_PERSISTENT | CONST_CS);\n\tREGISTER_MAIN_DOUBLE_CONSTANT(\"PHP_FLOAT_MAX\", DBL_MAX, CONST_PERSISTENT | CONST_CS);\n\tREGISTER_MAIN_DOUBLE_CONSTANT(\"PHP_FLOAT_MIN\", DBL_MIN, CONST_PERSISTENT | CONST_CS);\n\n#ifdef PHP_WIN32\n\tREGISTER_MAIN_LONG_CONSTANT(\"PHP_WINDOWS_VERSION_MAJOR\",      EG(windows_version_info).dwMajorVersion, CONST_PERSISTENT | CONST_CS);\n\tREGISTER_MAIN_LONG_CONSTANT(\"PHP_WINDOWS_VERSION_MINOR\",      EG(windows_version_info).dwMinorVersion, CONST_PERSISTENT | CONST_CS);\n\tREGISTER_MAIN_LONG_CONSTANT(\"PHP_WINDOWS_VERSION_BUILD\",      EG(windows_version_info).dwBuildNumber, CONST_PERSISTENT | CONST_CS);\n\tREGISTER_MAIN_LONG_CONSTANT(\"PHP_WINDOWS_VERSION_PLATFORM\",   EG(windows_version_info).dwPlatformId, CONST_PERSISTENT | CONST_CS);\n\tREGISTER_MAIN_LONG_CONSTANT(\"PHP_WINDOWS_VERSION_SP_MAJOR\",   EG(windows_version_info).wServicePackMajor, CONST_PERSISTENT | CONST_CS);\n\tREGISTER_MAIN_LONG_CONSTANT(\"PHP_WINDOWS_VERSION_SP_MINOR\",   EG(windows_version_info).wServicePackMinor, CONST_PERSISTENT | CONST_CS);\n\tREGISTER_MAIN_LONG_CONSTANT(\"PHP_WINDOWS_VERSION_SUITEMASK\",  EG(windows_version_info).wSuiteMask, CONST_PERSISTENT | CONST_CS);\n\tREGISTER_MAIN_LONG_CONSTANT(\"PHP_WINDOWS_VERSION_PRODUCTTYPE\", EG(windows_version_info).wProductType, CONST_PERSISTENT | CONST_CS);\n\tREGISTER_MAIN_LONG_CONSTANT(\"PHP_WINDOWS_NT_DOMAIN_CONTROLLER\", VER_NT_DOMAIN_CONTROLLER, CONST_PERSISTENT | CONST_CS);\n\tREGISTER_MAIN_LONG_CONSTANT(\"PHP_WINDOWS_NT_SERVER\", VER_NT_SERVER, CONST_PERSISTENT | CONST_CS);\n\tREGISTER_MAIN_LONG_CONSTANT(\"PHP_WINDOWS_NT_WORKSTATION\", VER_NT_WORKSTATION, CONST_PERSISTENT | CONST_CS);\n#endif\n\n\tphp_binary_init();\n\tif (PG(php_binary)) {\n\t\tREGISTER_MAIN_STRINGL_CONSTANT(\"PHP_BINARY\", PG(php_binary), strlen(PG(php_binary)), CONST_PERSISTENT | CONST_CS | CONST_NO_FILE_CACHE);\n\t} else {\n\t\tREGISTER_MAIN_STRINGL_CONSTANT(\"PHP_BINARY\", \"\", 0, CONST_PERSISTENT | CONST_CS | CONST_NO_FILE_CACHE);\n\t}\n\n\tphp_output_register_constants();\n\tphp_rfc1867_register_constants();\n\n\t/* this will read in php.ini, set up the configuration parameters,\n\t   load zend extensions and register php function extensions\n\t   to be loaded later */\n\tif (php_init_config() == FAILURE) {\n\t\treturn FAILURE;\n\t}\n\n\t/* Register PHP core ini entries */\n\tREGISTER_INI_ENTRIES();\n\n\t/* Register Zend ini entries */\n\tzend_register_standard_ini_entries();\n\n#ifdef ZEND_WIN32\n\t/* Until the current ini values was setup, the current cp is 65001.\n\t\tIf the actual ini values are different, some stuff needs to be updated.\n\t\tIt concerns at least main_cwd_state and there might be more. As we're\n\t\tstill in the startup phase, lets use the chance and reinit the relevant\n\t\titem according to the current codepage. Still, if ini_set() is used\n\t\tlater on, a more intelligent way to update such stuff is needed.\n\t\tStartup/shutdown routines could involve touching globals and thus\n\t\tcan't always be used on demand. */\n\tif (!php_win32_cp_use_unicode()) {\n\t\tvirtual_cwd_main_cwd_init(1);\n\t}\n#endif\n\n\t/* Disable realpath cache if an open_basedir is set */\n\tif (PG(open_basedir) && *PG(open_basedir)) {\n\t\tCWDG(realpath_cache_size_limit) = 0;\n\t}\n\n\tPG(have_called_openlog) = 0;\n\n\t/* initialize stream wrappers registry\n\t * (this uses configuration parameters from php.ini)\n\t */\n\tif (php_init_stream_wrappers(module_number) == FAILURE)\t{\n\t\tphp_printf(\"PHP:  Unable to initialize stream url wrappers.\\n\");\n\t\treturn FAILURE;\n\t}\n\n\tzuv.html_errors = 1;\n\tphp_startup_auto_globals();\n\tzend_set_utility_values(&zuv);\n\tphp_startup_sapi_content_types();\n\n\t/* startup extensions statically compiled in */\n\tif (php_register_internal_extensions_func() == FAILURE) {\n\t\tphp_printf(\"Unable to start builtin modules\\n\");\n\t\treturn FAILURE;\n\t}\n\n\t/* start additional PHP extensions */\n\tphp_register_extensions_bc(additional_modules, num_additional_modules);\n\n\t/* load and startup extensions compiled as shared objects (aka DLLs)\n\t   as requested by php.ini entries\n\t   these are loaded after initialization of internal extensions\n\t   as extensions *might* rely on things from ext/standard\n\t   which is always an internal extension and to be initialized\n\t   ahead of all other internals\n\t */\n\tphp_ini_register_extensions();\n\tzend_startup_modules();\n\n\t/* start Zend extensions */\n\tzend_startup_extensions();\n\n\tzend_collect_module_handlers();\n\n\t/* register additional functions */\n\tif (sapi_module.additional_functions) {\n\t\tif ((module = zend_hash_str_find_ptr(&module_registry, \"standard\", sizeof(\"standard\")-1)) != NULL) {\n\t\t\tEG(current_module) = module;\n\t\t\tzend_register_functions(NULL, sapi_module.additional_functions, NULL, MODULE_PERSISTENT);\n\t\t\tEG(current_module) = NULL;\n\t\t}\n\t}\n\n\t/* disable certain classes and functions as requested by php.ini */\n\tphp_disable_functions();\n\tphp_disable_classes();\n\n\t/* make core report what it should */\n\tif ((module = zend_hash_str_find_ptr(&module_registry, \"core\", sizeof(\"core\")-1)) != NULL) {\n\t\tmodule->version = PHP_VERSION;\n\t\tmodule->info_func = PHP_MINFO(php_core);\n\t}\n\n\tmodule_initialized = 1;\n\n\tif (zend_post_startup() != SUCCESS) {\n\t\treturn FAILURE;\n\t}\n\n\t/* Check for deprecated directives */\n\t/* NOTE: If you add anything here, remember to add it to build/Makefile.global! */\n\t{\n\t\tstruct {\n\t\t\tconst long error_level;\n\t\t\tconst char *phrase;\n\t\t\tconst char *directives[18]; /* Remember to change this if the number of directives change */\n\t\t} directives[2] = {\n\t\t\t{\n\t\t\t\tE_DEPRECATED,\n\t\t\t\t\"Directive '%s' is deprecated\",\n\t\t\t\t{\n\t\t\t\t\t\"allow_url_include\",\n\t\t\t\t\tNULL\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tE_CORE_ERROR,\n\t\t\t\t\"Directive '%s' is no longer available in PHP\",\n\t\t\t\t{\n\t\t\t\t\t\"allow_call_time_pass_reference\",\n\t\t\t\t\t\"asp_tags\",\n\t\t\t\t\t\"define_syslog_variables\",\n\t\t\t\t\t\"highlight.bg\",\n\t\t\t\t\t\"magic_quotes_gpc\",\n\t\t\t\t\t\"magic_quotes_runtime\",\n\t\t\t\t\t\"magic_quotes_sybase\",\n\t\t\t\t\t\"register_globals\",\n\t\t\t\t\t\"register_long_arrays\",\n\t\t\t\t\t\"safe_mode\",\n\t\t\t\t\t\"safe_mode_gid\",\n\t\t\t\t\t\"safe_mode_include_dir\",\n\t\t\t\t\t\"safe_mode_exec_dir\",\n\t\t\t\t\t\"safe_mode_allowed_env_vars\",\n\t\t\t\t\t\"safe_mode_protected_env_vars\",\n\t\t\t\t\t\"zend.ze1_compatibility_mode\",\n\t\t\t\t\t\"track_errors\",\n\t\t\t\t\tNULL\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tunsigned int i;\n\n\t\tzend_try {\n\t\t\t/* 2 = Count of deprecation structs */\n\t\t\tfor (i = 0; i < 2; i++) {\n\t\t\t\tconst char **p = directives[i].directives;\n\n\t\t\t\twhile(*p) {\n\t\t\t\t\tzend_long value;\n\n\t\t\t\t\tif (cfg_get_long((char*)*p, &value) == SUCCESS && value) {\n\t\t\t\t\t\tzend_error(directives[i].error_level, directives[i].phrase, *p);\n\t\t\t\t\t}\n\n\t\t\t\t\t++p;\n\t\t\t\t}\n\t\t\t}\n\t\t} zend_catch {\n\t\t\tretval = FAILURE;\n\t\t} zend_end_try();\n\t}\n\n\tvirtual_cwd_deactivate();\n\n\tsapi_deactivate();\n\tmodule_startup = 0;\n\n\t/* Don't leak errors from startup into the per-request phase. */\n\tclear_last_error();\n\tshutdown_memory_manager(1, 0);\n \tvirtual_cwd_activate();\n\n\tzend_interned_strings_switch_storage(1);\n\n#if ZEND_RC_DEBUG\n\tzend_rc_debug = 1;\n#endif\n\n\t/* we're done */\n\treturn retval;\n}\nint fpm_php_apply_defines_ex(struct key_value_s *kv, int mode) /* {{{ */\n{\n\n\tchar *name = kv->key;\n\tchar *value = kv->value;\n\tint name_len = strlen(name);\n\tint value_len = strlen(value);\n\n\tif (!strcmp(name, \"extension\") && *value) {\n\t\tzval zv;\n\t\tphp_dl(value, MODULE_PERSISTENT, &zv, 1);\n\t\treturn Z_TYPE(zv) == IS_TRUE;\n\t}\n\n\tif (fpm_php_zend_ini_alter_master(name, name_len, value, value_len, mode, PHP_INI_STAGE_ACTIVATE) == FAILURE) {\n\t\treturn -1;\n\t}\n\n\tif (!strcmp(name, \"disable_functions\") && *value) {\n\t\tchar *v = strdup(value);\n\t\tPG(disable_functions) = v;\n\t\tfpm_php_disable(v, zend_disable_function);\n\t\treturn 1;\n\t}\n\n\tif (!strcmp(name, \"disable_classes\") && *value) {\n\t\tchar *v = strdup(value);\n\t\tPG(disable_classes) = v;\n\t\tfpm_php_disable(v, zend_disable_class);\n\t\treturn 1;\n\t}\n\n\treturn 1;\n}\n",
    "target": 1,
    "idx": 1025257,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\n    Atomic(T* val) noexcept\n        : m_value(val)\n    {\n    }\n\n\n\n\n\n\n\nunsigned StringView::hash() const\n{\n    if (is_empty())\n        return 0;\n    return string_hash(characters_without_null_termination(), length());\n}\n\n\n\nvoid vout(FILE* file, StringView fmtstr, TypeErasedFormatParams params, bool newline)\n{\n    StringBuilder builder;\n    vformat(builder, fmtstr, params);\n\n    if (newline)\n        builder.append('\\n');\n\n    const auto string = builder.string_view();\n    const auto retval = ::fwrite(string.characters_without_null_termination(), 1, string.length(), file);\n    VERIFY(static_cast<size_t>(retval) == string.length());\n}\n\nvoid vformat(StringBuilder& builder, StringView fmtstr, TypeErasedFormatParams params)\n{\n    FormatBuilder fmtbuilder { builder };\n    FormatParser parser { fmtstr };\n\n    vformat_impl(params, fmtbuilder, parser);\n}\n\nString String::vformatted(StringView fmtstr, TypeErasedFormatParams params)\n{\n    StringBuilder builder;\n    vformat(builder, fmtstr, params);\n    return builder.to_string();\n}\n\n    String(NonnullRefPtr<StringImpl>&& impl)\n        : m_impl(move(impl))\n    {\n    }\n\nbool Parser::parse_heredoc_entries()\n{\n    auto heredocs = move(m_heredoc_initiations);\n    m_heredoc_initiations.clear();\n    // Try to parse heredoc entries, as reverse recorded in the initiation records\n    for (auto& record : heredocs) {\n        auto rule_start = push_start();\n        if (m_rule_start_offsets.size() > max_allowed_nested_rule_depth) {\n            record.node->set_is_syntax_error(*create<AST::SyntaxError>(String::formatted(\"Expression nested too deep (max allowed is {})\", max_allowed_nested_rule_depth)));\n            continue;\n        }\n        bool found_key = false;\n        if (!record.interpolate) {\n            // Since no interpolation is allowed, just read lines until we hit the key\n            Optional<Offset> last_line_offset;\n            for (;;) {\n                if (at_end())\n                    break;\n                if (peek() == '\\n')\n                    consume();\n                last_line_offset = current_position();\n                auto line = consume_while(is_not('\\n'));\n                if (peek() == '\\n')\n                    consume();\n                if (line.trim_whitespace() == record.end) {\n                    found_key = true;\n                    break;\n                }\n            }\n\n            if (!last_line_offset.has_value())\n                last_line_offset = current_position();\n            // Now just wrap it in a StringLiteral and set it as the node's contents\n            auto node = create<AST::StringLiteral>(m_input.substring_view(rule_start->offset, last_line_offset->offset - rule_start->offset));\n            if (!found_key)\n                node->set_is_syntax_error(*create<AST::SyntaxError>(String::formatted(\"Expected to find the heredoc key '{}', but found Eof\", record.end), true));\n            record.node->set_contents(move(node));\n        } else {\n            // Interpolation is allowed, so we're going to read doublequoted string innards\n            // until we find a line that contains the key\n            auto end_condition = move(m_end_condition);\n            found_key = false;\n            set_end_condition([this, end = record.end, &found_key] {\n                if (found_key)\n                    return true;\n                auto offset = current_position();\n                auto cond = move(m_end_condition);\n                ScopeGuard guard {\n                    [&] {\n                        m_end_condition = move(cond);\n                    }\n                };\n                if (peek() == '\\n') {\n                    consume();\n                    auto line = consume_while(is_not('\\n'));\n                    if (peek() == '\\n')\n                        consume();\n                    if (line.trim_whitespace() == end) {\n                        restore_to(offset.offset, offset.line);\n                        found_key = true;\n                        return true;\n                    }\n                }\n                restore_to(offset.offset, offset.line);\n                return false;\n            });\n\n            auto expr = parse_doublequoted_string_inner();\n            set_end_condition(move(end_condition));\n\n            if (found_key) {\n                auto offset = current_position();\n                if (peek() == '\\n')\n                    consume();\n                auto line = consume_while(is_not('\\n'));\n                if (peek() == '\\n')\n                    consume();\n                if (line.trim_whitespace() != record.end)\n                    restore_to(offset.offset, offset.line);\n            }\n\n            if (!expr && found_key) {\n                expr = create<AST::StringLiteral>(\"\");\n            } else if (!expr) {\n                expr = create<AST::SyntaxError>(String::formatted(\"Expected to find a valid string inside a heredoc (with end key '{}')\", record.end), true);\n            } else if (!found_key) {\n                expr->set_is_syntax_error(*create<AST::SyntaxError>(String::formatted(\"Expected to find the heredoc key '{}'\", record.end), true));\n            }\n\n            record.node->set_contents(create<AST::DoubleQuotedString>(move(expr)));\n        }\n    }\n    return true;\n}\n\nParser::SequenceParseResult Parser::parse_sequence()\n{\n    NonnullRefPtrVector<AST::Node> left;\n    auto read_terminators = [&](bool consider_tabs_and_spaces) {\n        if (m_heredoc_initiations.is_empty()) {\n        discard_terminators:;\n            consume_while(is_any_of(consider_tabs_and_spaces ? \" \\t\\n;\" : \"\\n;\"));\n        } else {\n            for (;;) {\n                if (consider_tabs_and_spaces && (peek() == '\\t' || peek() == ' ')) {\n                    consume();\n                    continue;\n                }\n                if (peek() == ';') {\n                    consume();\n                    continue;\n                }\n                if (peek() == '\\n') {\n                    auto rule_start = push_start();\n                    consume();\n                    if (!parse_heredoc_entries()) {\n                        StringBuilder error_builder;\n                        error_builder.append(\"Expected to find heredoc entries for \");\n                        bool first = true;\n                        for (auto& entry : m_heredoc_initiations) {\n                            if (first)\n                                error_builder.appendff(\"{} (at {}:{})\", entry.end, entry.node->position().start_line.line_column, entry.node->position().start_line.line_number);\n                            else\n                                error_builder.appendff(\", {} (at {}:{})\", entry.end, entry.node->position().start_line.line_column, entry.node->position().start_line.line_number);\n                            first = false;\n                        }\n                        left.append(create<AST::SyntaxError>(error_builder.build(), true));\n                        // Just read the rest of the newlines\n                        goto discard_terminators;\n                    }\n                    continue;\n                }\n                break;\n            }\n        }\n    };\n\n    read_terminators(true);\n\n    auto rule_start = push_start();\n    {\n        auto var_decls = parse_variable_decls();\n        if (var_decls)\n            left.append(var_decls.release_nonnull());\n    }\n\n    auto pos_before_seps = save_offset();\n\n    switch (peek()) {\n    case '}':\n        return { move(left), {}, ShouldReadMoreSequences::No };\n    case '\\n':\n        read_terminators(false);\n        [[fallthrough]];\n    case ';': {\n        if (left.is_empty())\n            break;\n\n        consume_while(is_any_of(\"\\n;\"));\n        auto pos_after_seps = save_offset();\n        AST::Position separator_position { pos_before_seps.offset, pos_after_seps.offset, pos_before_seps.line, pos_after_seps.line };\n\n        return { move(left), { move(separator_position) }, ShouldReadMoreSequences::Yes };\n    }\n    default:\n        break;\n    }\n\n    auto first_entry = parse_function_decl();\n\n    Vector<AST::Position> separator_positions;\n\n    if (!first_entry)\n        first_entry = parse_or_logical_sequence();\n\n    if (!first_entry)\n        return { move(left), {}, ShouldReadMoreSequences::No };\n\n    left.append(first_entry.release_nonnull());\n    separator_positions.empend(pos_before_seps.offset, pos_before_seps.offset, pos_before_seps.line, pos_before_seps.line);\n\n    consume_while(is_whitespace);\n\n    pos_before_seps = save_offset();\n    switch (peek()) {\n    case '\\n':\n        read_terminators(false);\n        [[fallthrough]];\n    case ';': {\n        consume_while(is_any_of(\"\\n;\"));\n        auto pos_after_seps = save_offset();\n        separator_positions.empend(pos_before_seps.offset, pos_after_seps.offset, pos_before_seps.line, pos_after_seps.line);\n        return { move(left), move(separator_positions), ShouldReadMoreSequences::Yes };\n    }\n    case '&': {\n        consume();\n        auto pos_after_seps = save_offset();\n        auto bg = create<AST::Background>(left.take_last()); // Execute Background\n        left.append(move(bg));\n        separator_positions.empend(pos_before_seps.offset, pos_after_seps.offset, pos_before_seps.line, pos_after_seps.line);\n        return { move(left), move(separator_positions), ShouldReadMoreSequences::Yes };\n    }\n    default:\n        return { move(left), move(separator_positions), ShouldReadMoreSequences::No };\n    }\n}\n\nParser::SequenceParseResult Parser::parse_sequence()\n{\n    NonnullRefPtrVector<AST::Node> left;\n    auto read_terminators = [&](bool consider_tabs_and_spaces) {\n        if (m_heredoc_initiations.is_empty()) {\n        discard_terminators:;\n            consume_while(is_any_of(consider_tabs_and_spaces ? \" \\t\\n;\" : \"\\n;\"));\n        } else {\n            for (;;) {\n                if (consider_tabs_and_spaces && (peek() == '\\t' || peek() == ' ')) {\n                    consume();\n                    continue;\n                }\n                if (peek() == ';') {\n                    consume();\n                    continue;\n                }\n                if (peek() == '\\n') {\n                    auto rule_start = push_start();\n                    consume();\n                    if (!parse_heredoc_entries()) {\n                        StringBuilder error_builder;\n                        error_builder.append(\"Expected to find heredoc entries for \");\n                        bool first = true;\n                        for (auto& entry : m_heredoc_initiations) {\n                            if (first)\n                                error_builder.appendff(\"{} (at {}:{})\", entry.end, entry.node->position().start_line.line_column, entry.node->position().start_line.line_number);\n                            else\n                                error_builder.appendff(\", {} (at {}:{})\", entry.end, entry.node->position().start_line.line_column, entry.node->position().start_line.line_number);\n                            first = false;\n                        }\n                        left.append(create<AST::SyntaxError>(error_builder.build(), true));\n                        // Just read the rest of the newlines\n                        goto discard_terminators;\n                    }\n                    continue;\n                }\n                break;\n            }\n        }\n    };\n\n    read_terminators(true);\n\n    auto rule_start = push_start();\n    {\n        auto var_decls = parse_variable_decls();\n        if (var_decls)\n            left.append(var_decls.release_nonnull());\n    }\n\n    auto pos_before_seps = save_offset();\n\n    switch (peek()) {\n    case '}':\n        return { move(left), {}, ShouldReadMoreSequences::No };\n    case '\\n':\n        read_terminators(false);\n        [[fallthrough]];\n    case ';': {\n        if (left.is_empty())\n            break;\n\n        consume_while(is_any_of(\"\\n;\"));\n        auto pos_after_seps = save_offset();\n        AST::Position separator_position { pos_before_seps.offset, pos_after_seps.offset, pos_before_seps.line, pos_after_seps.line };\n\n        return { move(left), { move(separator_position) }, ShouldReadMoreSequences::Yes };\n    }\n    default:\n        break;\n    }\n\n    auto first_entry = parse_function_decl();\n\n    Vector<AST::Position> separator_positions;\n\n    if (!first_entry)\n        first_entry = parse_or_logical_sequence();\n\n    if (!first_entry)\n        return { move(left), {}, ShouldReadMoreSequences::No };\n\n    left.append(first_entry.release_nonnull());\n    separator_positions.empend(pos_before_seps.offset, pos_before_seps.offset, pos_before_seps.line, pos_before_seps.line);\n\n    consume_while(is_whitespace);\n\n    pos_before_seps = save_offset();\n    switch (peek()) {\n    case '\\n':\n        read_terminators(false);\n        [[fallthrough]];\n    case ';': {\n        consume_while(is_any_of(\"\\n;\"));\n        auto pos_after_seps = save_offset();\n        separator_positions.empend(pos_before_seps.offset, pos_after_seps.offset, pos_before_seps.line, pos_after_seps.line);\n        return { move(left), move(separator_positions), ShouldReadMoreSequences::Yes };\n    }\n    case '&': {\n        consume();\n        auto pos_after_seps = save_offset();\n        auto bg = create<AST::Background>(left.take_last()); // Execute Background\n        left.append(move(bg));\n        separator_positions.empend(pos_before_seps.offset, pos_after_seps.offset, pos_before_seps.line, pos_after_seps.line);\n        return { move(left), move(separator_positions), ShouldReadMoreSequences::Yes };\n    }\n    default:\n        return { move(left), move(separator_positions), ShouldReadMoreSequences::No };\n    }\n}\n\nRefPtr<AST::Node> Parser::parse_toplevel()\n{\n    auto rule_start = push_start();\n\n    SequenceParseResult result;\n    NonnullRefPtrVector<AST::Node> sequence;\n    Vector<AST::Position> positions;\n    do {\n        result = parse_sequence();\n        if (result.entries.is_empty())\n            break;\n\n        sequence.append(move(result.entries));\n        positions.append(move(result.separator_positions));\n    } while (result.decision == ShouldReadMoreSequences::Yes);\n\n    if (sequence.is_empty())\n        return nullptr;\n\n    return create<AST::Execute>(\n        create<AST::Sequence>(move(sequence), move(positions)));\n}\n\nRefPtr<AST::Node> Parser::parse()\n{\n    m_offset = 0;\n    m_line = { 0, 0 };\n\n    auto toplevel = parse_toplevel();\n\n    if (m_offset < m_input.length()) {\n        // Parsing stopped midway, this is a syntax error.\n        auto error_start = push_start();\n        while (!at_end())\n            consume();\n        auto syntax_error_node = create<AST::SyntaxError>(\"Unexpected tokens past the end\");\n        if (!toplevel)\n            toplevel = move(syntax_error_node);\n        else if (!toplevel->is_syntax_error())\n            toplevel->set_is_syntax_error(*syntax_error_node);\n    }\n\n    return toplevel;\n}\n\n\n// target function\nbool Parser::parse_heredoc_entries()\n{\n    // Try to parse heredoc entries, as reverse recorded in the initiation records\n    for (auto& record : m_heredoc_initiations) {\n        auto rule_start = push_start();\n        if (m_rule_start_offsets.size() > max_allowed_nested_rule_depth) {\n            record.node->set_is_syntax_error(*create<AST::SyntaxError>(String::formatted(\"Expression nested too deep (max allowed is {})\", max_allowed_nested_rule_depth)));\n            continue;\n        }\n        bool found_key = false;\n        if (!record.interpolate) {\n            // Since no interpolation is allowed, just read lines until we hit the key\n            Optional<Offset> last_line_offset;\n            for (;;) {\n                if (at_end())\n                    break;\n                if (peek() == '\\n')\n                    consume();\n                last_line_offset = current_position();\n                auto line = consume_while(is_not('\\n'));\n                if (peek() == '\\n')\n                    consume();\n                if (line.trim_whitespace() == record.end) {\n                    found_key = true;\n                    break;\n                }\n            }\n\n            if (!last_line_offset.has_value())\n                last_line_offset = current_position();\n            // Now just wrap it in a StringLiteral and set it as the node's contents\n            auto node = create<AST::StringLiteral>(m_input.substring_view(rule_start->offset, last_line_offset->offset - rule_start->offset));\n            if (!found_key)\n                node->set_is_syntax_error(*create<AST::SyntaxError>(String::formatted(\"Expected to find the heredoc key '{}', but found Eof\", record.end), true));\n            record.node->set_contents(move(node));\n        } else {\n            // Interpolation is allowed, so we're going to read doublequoted string innards\n            // until we find a line that contains the key\n            auto end_condition = move(m_end_condition);\n            found_key = false;\n            set_end_condition([this, end = record.end, &found_key] {\n                if (found_key)\n                    return true;\n                auto offset = current_position();\n                auto cond = move(m_end_condition);\n                ScopeGuard guard {\n                    [&] {\n                        m_end_condition = move(cond);\n                    }\n                };\n                if (peek() == '\\n') {\n                    consume();\n                    auto line = consume_while(is_not('\\n'));\n                    if (peek() == '\\n')\n                        consume();\n                    if (line.trim_whitespace() == end) {\n                        restore_to(offset.offset, offset.line);\n                        found_key = true;\n                        return true;\n                    }\n                }\n                restore_to(offset.offset, offset.line);\n                return false;\n            });\n\n            auto expr = parse_doublequoted_string_inner();\n            set_end_condition(move(end_condition));\n\n            if (found_key) {\n                auto offset = current_position();\n                if (peek() == '\\n')\n                    consume();\n                auto line = consume_while(is_not('\\n'));\n                if (peek() == '\\n')\n                    consume();\n                if (line.trim_whitespace() != record.end)\n                    restore_to(offset.offset, offset.line);\n            }\n\n            if (!expr && found_key) {\n                expr = create<AST::StringLiteral>(\"\");\n            } else if (!expr) {\n                expr = create<AST::SyntaxError>(String::formatted(\"Expected to find a valid string inside a heredoc (with end key '{}')\", record.end), true);\n            } else if (!found_key) {\n                expr->set_is_syntax_error(*create<AST::SyntaxError>(String::formatted(\"Expected to find the heredoc key '{}'\", record.end), true));\n            }\n\n            record.node->set_contents(create<AST::DoubleQuotedString>(move(expr)));\n        }\n    }\n\n    m_heredoc_initiations.clear();\n    return true;\n}\n",
    "target": 1,
    "idx": 1033852,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nvoid\npixcmapDestroy(PIXCMAP  **pcmap)\n{\nPIXCMAP  *cmap;\n\n    PROCNAME(\"pixcmapDestroy\");\n\n    if (pcmap == NULL) {\n        L_WARNING(\"ptr address is null!\\n\", procName);\n        return;\n    }\n\n    if ((cmap = *pcmap) == NULL)\n        return;\n\n    LEPT_FREE(cmap->array);\n    LEPT_FREE(cmap);\n    *pcmap = NULL;\n}\n\n\n// target function\nextern \"C\" int\nLLVMFuzzerTestOneInput(const uint8_t *data, size_t size)\n{\n    BOX *box;\n    PIX *pixs, *pixd;\n    PIX *pix1, *pix2, *pix3, *pix4, *pix5, *pix6, *pix7, *pix8;\n    PIXCMAP *cmap;\n\n    leptSetStdNullHandler();\n    pixs = pixReadMemSpix(data, size);\n    if(pixs==NULL) return 0;\n\n    pix1 = pixThresholdTo4bpp(pixs, 6, 1);\n    box = boxCreate(120, 30, 200, 200);\n    pixColorGray(pix1, box, L_PAINT_DARK, 220, 0, 0, 255);\n    boxDestroy(&box);\n\n    pix2 = pixScale(pix1, 1.5, 1.5);\n\n    cmap = pixGetColormap(pix1);\n    pix3 = pixOctcubeQuantFromCmap(pix2, cmap, 4,\n                                   3, L_EUCLIDEAN_DISTANCE);\n\n    pix4 = pixConvertTo32(pix3);\n    pix5 = pixMedianCutQuant(pix4, 0);\n    pix6 = pixFewColorsMedianCutQuantMixed(pix4, 30, 30, 100, 0, 0, 0);\n\n    pixd = pixDeskew(pixs, 0);\n    pixWriteImpliedFormat(\"/tmp/lept/deskew/result1\", pixd, 0, 0);\n\n    pixOctreeQuantByPopulation(pixs, 0, 0);\n    pix7 = pixFewColorsOctcubeQuantMixed(pix4, 3, 20, 244, 20, 0.05, 15);\n    pix8 = pixColorSegment(pixs, 50, 6, 6, 6, 0);\n    \n    pixDestroy(&pix1);\n    pixDestroy(&pix2);\n    pixDestroy(&pix3);\n    pixDestroy(&pix4);\n    pixDestroy(&pix5);\n    pixDestroy(&pix6);\n    pixDestroy(&pix7);\n    pixDestroy(&pix8);\n\n    pixDestroy(&pixd);\n    pixDestroy(&pixs);\n    pixcmapDestroy(&cmap);\n    \n    return 0;\n}\n",
    "target": 1,
    "idx": 1022110,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "// context\nvoid UA_WorkQueue_manuallyProcessDelayed(UA_WorkQueue *wq) {\n    UA_DelayedCallback *dc, *dc_tmp;\n    SIMPLEQ_FOREACH_SAFE(dc, &wq->delayedCallbacks, next, dc_tmp) {\n        SIMPLEQ_REMOVE_HEAD(&wq->delayedCallbacks, next);\n        if(dc->callback)\n            dc->callback(dc->application, dc->data);\n        UA_free(dc);\n    }\n#ifdef UA_ENABLE_MULTITHREADING\n    wq->delayedCallbacks_checkpoint = NULL;\n#endif\n}\n\nvoid UA_Server_delete(UA_Server *server) {\n    /* Delete all internal data */\n    UA_SecureChannelManager_deleteMembers(&server->secureChannelManager);\n    UA_SessionManager_deleteMembers(&server->sessionManager);\n    UA_Array_delete(server->namespaces, server->namespacesSize, &UA_TYPES[UA_TYPES_STRING]);\n\n#ifdef UA_ENABLE_SUBSCRIPTIONS\n    UA_MonitoredItem *mon, *mon_tmp;\n    LIST_FOREACH_SAFE(mon, &server->localMonitoredItems, listEntry, mon_tmp) {\n        LIST_REMOVE(mon, listEntry);\n        UA_MonitoredItem_delete(server, mon);\n    }\n#endif\n\n#ifdef UA_ENABLE_PUBSUB\n    UA_PubSubManager_delete(server, &server->pubSubManager);\n#endif\n\n#ifdef UA_ENABLE_DISCOVERY\n    registeredServer_list_entry *rs, *rs_tmp;\n    LIST_FOREACH_SAFE(rs, &server->registeredServers, pointers, rs_tmp) {\n        LIST_REMOVE(rs, pointers);\n        UA_RegisteredServer_deleteMembers(&rs->registeredServer);\n        UA_free(rs);\n    }\n    periodicServerRegisterCallback_entry *ps, *ps_tmp;\n    LIST_FOREACH_SAFE(ps, &server->periodicServerRegisterCallbacks, pointers, ps_tmp) {\n        LIST_REMOVE(ps, pointers);\n        UA_free(ps->callback);\n        UA_free(ps);\n    }\n\n# ifdef UA_ENABLE_DISCOVERY_MULTICAST\n    if(server->config.applicationDescription.applicationType == UA_APPLICATIONTYPE_DISCOVERYSERVER)\n        destroyMulticastDiscoveryServer(server);\n\n    serverOnNetwork_list_entry *son, *son_tmp;\n    LIST_FOREACH_SAFE(son, &server->serverOnNetwork, pointers, son_tmp) {\n        LIST_REMOVE(son, pointers);\n        UA_ServerOnNetwork_deleteMembers(&son->serverOnNetwork);\n        if(son->pathTmp)\n            UA_free(son->pathTmp);\n        UA_free(son);\n    }\n\n    for(size_t i = 0; i < SERVER_ON_NETWORK_HASH_PRIME; i++) {\n        serverOnNetwork_hash_entry* currHash = server->serverOnNetworkHash[i];\n        while(currHash) {\n            serverOnNetwork_hash_entry* nextHash = currHash->next;\n            UA_free(currHash);\n            currHash = nextHash;\n        }\n    }\n\n    mdnsHostnameToIp_list_entry *mhi, *mhi_tmp;\n    LIST_FOREACH_SAFE(mhi, &server->mdnsHostnameToIp, pointers, mhi_tmp) {\n        LIST_REMOVE(mhi, pointers);\n        UA_String_deleteMembers(&mhi->mdnsHostname);\n        UA_free(mhi);\n    }\n\n    for(size_t i = 0; i < MDNS_HOSTNAME_TO_IP_HASH_PRIME; i++) {\n        mdnsHostnameToIp_hash_entry* currHash = server->mdnsHostnameToIpHash[i];\n        while(currHash) {\n            mdnsHostnameToIp_hash_entry* nextHash = currHash->next;\n            UA_free(currHash);\n            currHash = nextHash;\n        }\n    }\n# endif\n\n#endif\n\n    /* Clean up the Admin Session */\n    UA_Session_deleteMembersCleanup(&server->adminSession, server);\n\n    /* Clean up the work queue */\n    UA_WorkQueue_cleanup(&server->workQueue);\n\n    /* Delete the timed work */\n    UA_Timer_deleteMembers(&server->timer);\n\n    /* Delete the server itself */\n    UA_free(server);\n}\n\n\n// target function\nvoid UA_Session_deleteMembersCleanup(UA_Session *session, UA_Server* server) {\n    UA_Session_detachFromSecureChannel(session);\n    UA_ApplicationDescription_deleteMembers(&session->clientDescription);\n    UA_NodeId_deleteMembers(&session->header.authenticationToken);\n    UA_NodeId_deleteMembers(&session->sessionId);\n    UA_String_deleteMembers(&session->sessionName);\n    UA_ByteString_deleteMembers(&session->serverNonce);\n    struct ContinuationPointEntry *cp, *temp;\n    LIST_FOREACH_SAFE(cp, &session->continuationPoints, pointers, temp) {\n        LIST_REMOVE(cp, pointers);\n        UA_ByteString_deleteMembers(&cp->identifier);\n        UA_BrowseDescription_deleteMembers(&cp->browseDescription);\n        UA_free(cp);\n    }\n\n#ifdef UA_ENABLE_SUBSCRIPTIONS\n    UA_Subscription *sub, *tempsub;\n    LIST_FOREACH_SAFE(sub, &session->serverSubscriptions, listEntry, tempsub) {\n        UA_Session_deleteSubscription(server, session, sub->subscriptionId);\n    }\n\n    UA_PublishResponseEntry *entry;\n    while((entry = UA_Session_dequeuePublishReq(session))) {\n        UA_PublishResponse_deleteMembers(&entry->response);\n        UA_free(entry);\n    }\n#endif\n}\nvoid UA_SessionManager_deleteMembers(UA_SessionManager *sm) {\n    session_list_entry *current, *temp;\n    LIST_FOREACH_SAFE(current, &sm->sessions, pointers, temp) {\n        LIST_REMOVE(current, pointers);\n        UA_Session_deleteMembersCleanup(&current->session, sm->server);\n        UA_free(current);\n    }\n}\nstatic void\nremoveSessionCallback(UA_Server *server, session_list_entry *entry) {\n    UA_Session_deleteMembersCleanup(&entry->session, server);\n}\nstatic void\nremoveSession(UA_SessionManager *sm, session_list_entry *sentry) {\n    /* Detach the Session from the SecureChannel */\n    UA_Session_detachFromSecureChannel(&sentry->session);\n\n    /* Deactivate the session */\n    sentry->session.activated = false;\n\n    /* Detach the session from the session manager and make the capacity\n     * available */\n    LIST_REMOVE(sentry, pointers);\n    UA_atomic_subUInt32(&sm->currentSessionCount, 1);\n\n    /* Add a delayed callback to remove the session when the currently\n     * scheduled jobs have completed */\n    sentry->cleanupCallback.callback = (UA_ApplicationCallback)removeSessionCallback;\n    sentry->cleanupCallback.application = sm->server;\n    sentry->cleanupCallback.data = sentry;\n    UA_WorkQueue_enqueueDelayed(&sm->server->workQueue, &sentry->cleanupCallback);\n}\nvoid\nUA_SessionManager_cleanupTimedOut(UA_SessionManager *sm,\n                                  UA_DateTime nowMonotonic) {\n    session_list_entry *sentry, *temp;\n    LIST_FOREACH_SAFE(sentry, &sm->sessions, pointers, temp) {\n        /* Session has timed out? */\n        if(sentry->session.validTill >= nowMonotonic)\n            continue;\n        UA_LOG_INFO_SESSION(sm->server->config.logger, &sentry->session,\n                            \"Session has timed out\");\n        sm->server->config.accessControl.closeSession(sm->server,\n                                                      &sm->server->config.accessControl,\n                                                      &sentry->session.sessionId,\n                                                      sentry->session.sessionHandle);\n        removeSession(sm, sentry);\n    }\n}\n",
    "target": 1,
    "idx": 1010676,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic status\nUInt32_encodeBinary(u32 const *src, const UA_DataType *_) {\n    if(g_pos + sizeof(u32) > g_end)\n        return UA_STATUSCODE_BADENCODINGLIMITSEXCEEDED;\n#if UA_BINARY_OVERLAYABLE_INTEGER\n    memcpy(g_pos, src, sizeof(u32));\n#else\n    UA_encode32(*src, g_pos);\n#endif\n    g_pos += 4;\n    return UA_STATUSCODE_GOOD;\n}\n\nstatic status\nUA_encodeBinaryInternal(const void *src, const UA_DataType *type) {\n    uintptr_t ptr = (uintptr_t)src;\n    status ret = UA_STATUSCODE_GOOD;\n    u8 membersSize = type->membersSize;\n    const UA_DataType *typelists[2] = { UA_TYPES, &type[-type->typeIndex] };\n    for(size_t i = 0; i < membersSize && ret == UA_STATUSCODE_GOOD; ++i) {\n        const UA_DataTypeMember *member = &type->members[i];\n        const UA_DataType *membertype = &typelists[!member->namespaceZero][member->memberTypeIndex];\n        if(!member->isArray) {\n            ptr += member->padding;\n            size_t encode_index = membertype->builtin ? membertype->typeIndex : UA_BUILTIN_TYPES_COUNT;\n            size_t memSize = membertype->memSize;\n            u8 *oldpos = g_pos;\n            ret = encodeBinaryJumpTable[encode_index]((const void*)ptr, membertype);\n            ptr += memSize;\n            if(ret == UA_STATUSCODE_BADENCODINGLIMITSEXCEEDED) {\n                g_pos = oldpos; /* exchange/send the buffer */\n                ret = exchangeBuffer();\n                ptr -= member->padding + memSize; /* encode the same member in the next iteration */\n                if(ret == UA_STATUSCODE_BADENCODINGLIMITSEXCEEDED || g_pos + memSize > g_end) {\n                    /* the send buffer is too small to encode the member, even after exchangeBuffer */\n                    return UA_STATUSCODE_BADRESPONSETOOLARGE;\n                }\n                --i;\n            }\n        } else {\n            ptr += member->padding;\n            const size_t length = *((const size_t*)ptr);\n            ptr += sizeof(size_t);\n            ret = Array_encodeBinary(*(void *UA_RESTRICT const *)ptr, length, membertype);\n            ptr += sizeof(void*);\n        }\n    }\n    UA_assert(ret != UA_STATUSCODE_BADENCODINGLIMITSEXCEEDED);\n    return ret;\n}\n\nstatus\nUA_encodeBinary(const void *src, const UA_DataType *type,\n                u8 **bufPos, const u8 **bufEnd,\n                UA_exchangeEncodeBuffer exchangeCallback, void *exchangeHandle) {\n    /* Save global (thread-local) values to make UA_encodeBinary reentrant */\n    u8 *save_pos = g_pos;\n    const u8 *save_end = g_end;\n    UA_exchangeEncodeBuffer save_exchangeBufferCallback = g_exchangeBufferCallback;\n    void *save_exchangeBufferCallbackHandle = g_exchangeBufferCallbackHandle;\n\n    /* Set the (thread-local) pointers to save function arguments */\n    g_pos = *bufPos;\n    g_end = *bufEnd;\n    g_exchangeBufferCallback = exchangeCallback;\n    g_exchangeBufferCallbackHandle = exchangeHandle;\n\n    /* Encode */\n    status ret = UA_encodeBinaryInternal(src, type);\n\n    /* Set the new buffer position for the output. Beware that the buffer might\n     * have been exchanged internally. */\n    *bufPos = g_pos;\n    *bufEnd = g_end;\n\n    /* Restore global (thread-local) values */\n    g_pos = save_pos;\n    g_end = save_end;\n    g_exchangeBufferCallback = save_exchangeBufferCallback;\n    g_exchangeBufferCallbackHandle = save_exchangeBufferCallbackHandle;\n    return ret;\n}\n\nstatic UA_INLINE UA_StatusCode\nUA_TcpMessageHeader_encodeBinary(const UA_TcpMessageHeader *src, UA_Byte **bufPos, const UA_Byte **bufEnd) {\n    return UA_encodeBinary(src, &UA_TRANSPORT[UA_TRANSPORT_TCPMESSAGEHEADER], bufPos, bufEnd, NULL, NULL);\n}\n\nstatic void\nprocessBinaryMessage(UA_Server *server, UA_Connection *connection,\n                     UA_ByteString *message) {\n    UA_LOG_TRACE(server->config.logger, UA_LOGCATEGORY_NETWORK,\n                 \"Connection %i | Received a packet.\", connection->sockfd);\n#ifdef UA_DEBUG_DUMP_PKGS\n    UA_dump_hex_pkg(message->data, message->length);\n#endif\n\n    UA_StatusCode retval = UA_Connection_processChunks(connection, server,\n                                                       processCompleteChunk, message);\n    if(retval != UA_STATUSCODE_GOOD) {\n        UA_LOG_INFO(server->config.logger, UA_LOGCATEGORY_NETWORK,\n                    \"Connection %i | Processing the message failed with \"\n                    \"error %s\", connection->sockfd, UA_StatusCode_name(retval));\n        /* Send an ERR message and close the connection */\n        UA_TcpErrorMessage error;\n        error.error = retval;\n        error.reason = UA_STRING_NULL;\n        UA_Connection_sendError(connection, &error);\n        connection->close(connection);\n    }\n}\n\n\n// target function\nvoid\nUA_MessageContext_abort(UA_MessageContext *mc) {\n    UA_ByteString_deleteMembers(&mc->messageBuffer);\n}\n",
    "target": 1,
    "idx": 1004764,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "// context\nvoid CMSEXPORT cmsFreeNamedColorList(cmsNAMEDCOLORLIST* v)\n{\n    if (v == NULL) return;\n    if (v ->List) _cmsFree(v ->ContextID, v ->List);\n    _cmsFree(v ->ContextID, v);\n}\n\nstatic\nvoid Type_NamedColor_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    cmsFreeNamedColorList((cmsNAMEDCOLORLIST*) Ptr);\n    return;\n\n    cmsUNUSED_PARAMETER(self);\n}\n\nstatic\nvoid freeOneTag(_cmsICCPROFILE* Icc, cmsUInt32Number i)\n{\n    if (Icc->TagPtrs[i]) {\n\n        cmsTagTypeHandler* TypeHandler = Icc->TagTypeHandlers[i];\n\n        if (TypeHandler != NULL) {\n            cmsTagTypeHandler LocalTypeHandler = *TypeHandler;\n\n            LocalTypeHandler.ContextID = Icc->ContextID;             \n            LocalTypeHandler.ICCVersion = Icc->Version;\n            LocalTypeHandler.FreePtr(&LocalTypeHandler, Icc->TagPtrs[i]);\n        }\n        else\n            _cmsFree(Icc->ContextID, Icc->TagPtrs[i]);\n    }\n}\n\ncmsBool  CMSEXPORT cmsCloseProfile(cmsHPROFILE hProfile)\n{\n    _cmsICCPROFILE* Icc = (_cmsICCPROFILE*) hProfile;\n    cmsBool  rc = TRUE;\n    cmsUInt32Number i;\n\n    if (!Icc) return FALSE;\n\n    // Was open in write mode?\n    if (Icc ->IsWrite) {\n\n        Icc ->IsWrite = FALSE;      // Assure no further writing\n        rc &= cmsSaveProfileToFile(hProfile, Icc ->IOhandler->PhysicalFile);\n    }\n\n    for (i=0; i < Icc -> TagCount; i++) {\n\n        freeOneTag(Icc, i);        \n    }\n\n    if (Icc ->IOhandler != NULL) {\n        rc &= cmsCloseIOhandler(Icc->IOhandler);\n    }\n\n    _cmsDestroyMutex(Icc->ContextID, Icc->UsrMutex);\n\n    _cmsFree(Icc ->ContextID, Icc);   // Free placeholder memory\n\n    return rc;\n}\n\nvoid\nrun_test(const uint8_t *data,\n         size_t size,\n         uint32_t intent_id,\n         uint32_t input_format,\n         uint32_t output_format,\n         uint32_t flags) {\n if (size < 2) {\n   return;\n }\n\n size_t mid = size / 2;\n\n cmsHPROFILE hInProfile, hOutProfile;\n cmsHTRANSFORM hTransform;\n\n hInProfile = cmsOpenProfileFromMem(data, mid);\n hOutProfile = cmsOpenProfileFromMem(data + mid, size - mid);\n hTransform = cmsCreateTransform(hInProfile, input_format, hOutProfile,\n                                 output_format, intent_id, flags);\n cmsCloseProfile(hInProfile);\n cmsCloseProfile(hOutProfile);\n\n if (hTransform) {\n   cmsDeleteTransform(hTransform);\n }\n}\n\n\n// target function\nstatic \ncmsBool validDeviceClass(cmsProfileClassSignature cl)\n{\n    switch (cl)\n    {\n    case 0: // We allow zero because older lcms versions defaulted to that.\n    case cmsSigInputClass:\n    case cmsSigDisplayClass:\n    case cmsSigOutputClass:\n    case cmsSigLinkClass:\n    case cmsSigAbstractClass:\n    case cmsSigColorSpaceClass:\n    case cmsSigNamedColorClass:\n        return TRUE;\n\n    default:\n        return FALSE;\n    }\n\n}\n",
    "target": 1,
    "idx": 1050665,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "// context\nint\nxmlValidatePopElement(xmlValidCtxtPtr ctxt, xmlDocPtr doc ATTRIBUTE_UNUSED,\n                      xmlNodePtr elem ATTRIBUTE_UNUSED,\n\t\t      const xmlChar *qname ATTRIBUTE_UNUSED) {\n    int ret = 1;\n\n    if (ctxt == NULL)\n        return(0);\n/* printf(\"PopElem %s\\n\", qname); */\n    if ((ctxt->vstateNr > 0) && (ctxt->vstate != NULL)) {\n\txmlValidStatePtr state = ctxt->vstate;\n\txmlElementPtr elemDecl;\n\n\t/*\n\t * Check the new element against the content model of the new elem.\n\t */\n\tif (state->elemDecl != NULL) {\n\t    elemDecl = state->elemDecl;\n\n\t    if (elemDecl->etype == XML_ELEMENT_TYPE_ELEMENT) {\n\t\tif (state->exec != NULL) {\n\t\t    ret = xmlRegExecPushString(state->exec, NULL, NULL);\n\t\t    if (ret <= 0) {\n\t\t\txmlErrValidNode(ctxt, state->node,\n\t\t\t                XML_DTD_CONTENT_MODEL,\n\t   \"Element %s content does not follow the DTD, Expecting more children\\n\",\n\t\t\t       state->node->name, NULL,NULL);\n\t\t\tret = 0;\n\t\t    } else {\n\t\t\t/*\n\t\t\t * previous validation errors should not generate\n\t\t\t * a new one here\n\t\t\t */\n\t\t\tret = 1;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tvstateVPop(ctxt);\n    }\n    return(ret);\n}\n\nstatic int\nxmlTextReaderValidatePop(xmlTextReaderPtr reader) {\n    xmlNodePtr node = reader->node;\n\n#ifdef LIBXML_VALID_ENABLED\n    if ((reader->validate == XML_TEXTREADER_VALIDATE_DTD) &&\n        (reader->ctxt != NULL) && (reader->ctxt->validate == 1)) {\n\tif ((node->ns == NULL) || (node->ns->prefix == NULL)) {\n\t    reader->ctxt->valid &= xmlValidatePopElement(&reader->ctxt->vctxt,\n\t\t\t\t    reader->ctxt->myDoc, node, node->name);\n\t} else {\n\t    /* TODO use the BuildQName interface */\n\t    xmlChar *qname;\n\n\t    qname = xmlStrdup(node->ns->prefix);\n            if (qname == NULL) {\n                xmlTextReaderErrMemory(reader);\n                return(-1);\n            }\n\t    qname = xmlStrcat(qname, BAD_CAST \":\");\n            if (qname == NULL) {\n                xmlTextReaderErrMemory(reader);\n                return(-1);\n            }\n\t    qname = xmlStrcat(qname, node->name);\n            if (qname == NULL) {\n                xmlTextReaderErrMemory(reader);\n                return(-1);\n            }\n\t    reader->ctxt->valid &= xmlValidatePopElement(&reader->ctxt->vctxt,\n\t\t\t\t    reader->ctxt->myDoc, node, qname);\n\t    xmlFree(qname);\n\t}\n        /*if (reader->ctxt->errNo == XML_ERR_NO_MEMORY) {\n            reader->mode = XML_TEXTREADER_MODE_ERROR;\n            reader->state = XML_TEXTREADER_ERROR;\n            return(-1);\n        }*/\n    }\n#endif /* LIBXML_VALID_ENABLED */\n#ifdef LIBXML_SCHEMAS_ENABLED\n    if ((reader->validate == XML_TEXTREADER_VALIDATE_RNG) &&\n               (reader->rngValidCtxt != NULL)) {\n\tint ret;\n\n\tif (reader->rngFullNode != NULL) {\n\t    if (node == reader->rngFullNode)\n\t        reader->rngFullNode = NULL;\n\t    return(0);\n\t}\n\tret = xmlRelaxNGValidatePopElement(reader->rngValidCtxt,\n\t                                   reader->ctxt->myDoc,\n\t\t\t\t\t   node);\n\tif (ret != 1)\n\t    reader->rngValidErrors++;\n    }\n#endif\n\n    return(0);\n}\n\nint\nxmlTextReaderRead(xmlTextReaderPtr reader) {\n    int val, olddepth = 0;\n    xmlTextReaderState oldstate = XML_TEXTREADER_START;\n    xmlNodePtr oldnode = NULL;\n\n\n    if (reader == NULL)\n\treturn(-1);\n    reader->curnode = NULL;\n    if (reader->doc != NULL)\n        return(xmlTextReaderReadTree(reader));\n    if (reader->ctxt == NULL)\n\treturn(-1);\n\n    if (reader->mode == XML_TEXTREADER_MODE_INITIAL) {\n\treader->mode = XML_TEXTREADER_MODE_INTERACTIVE;\n\t/*\n\t * Initial state\n\t */\n\tdo {\n\t    val = xmlTextReaderPushData(reader);\n\t\tif (val < 0){\n\t\t\treader->mode = XML_TEXTREADER_MODE_ERROR;\n\t\t\treader->state = XML_TEXTREADER_ERROR;\n\t\treturn(-1);\n\t\t}\n\t} while ((reader->ctxt->node == NULL) &&\n\t\t ((reader->mode != XML_TEXTREADER_MODE_EOF) &&\n\t\t  (reader->state != XML_TEXTREADER_DONE)));\n\tif (reader->ctxt->node == NULL) {\n\t    if (reader->ctxt->myDoc != NULL) {\n\t\treader->node = reader->ctxt->myDoc->children;\n\t    }\n\t    if (reader->node == NULL){\n\t\t\treader->mode = XML_TEXTREADER_MODE_ERROR;\n\t\t\treader->state = XML_TEXTREADER_ERROR;\n\t\treturn(-1);\n\t\t}\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t} else {\n\t    if (reader->ctxt->myDoc != NULL) {\n\t\treader->node = reader->ctxt->myDoc->children;\n\t    }\n\t    if (reader->node == NULL)\n\t\treader->node = reader->ctxt->nodeTab[0];\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t}\n\treader->depth = 0;\n\treader->ctxt->parseMode = XML_PARSE_READER;\n\tgoto node_found;\n    }\n    oldstate = reader->state;\n    olddepth = reader->ctxt->nodeNr;\n    oldnode = reader->node;\n\nget_next_node:\n    if (reader->node == NULL) {\n\tif (reader->mode == XML_TEXTREADER_MODE_EOF)\n\t    return(0);\n\telse\n\t    return(-1);\n    }\n\n    /*\n     * If we are not backtracking on ancestors or examined nodes,\n     * that the parser didn't finished or that we aren't at the end\n     * of stream, continue processing.\n     */\n    while ((reader->node != NULL) && (reader->node->next == NULL) &&\n\t   (reader->ctxt->nodeNr == olddepth) &&\n           ((oldstate == XML_TEXTREADER_BACKTRACK) ||\n            (reader->node->children == NULL) ||\n\t    (reader->node->type == XML_ENTITY_REF_NODE) ||\n\t    ((reader->node->children != NULL) &&\n\t     (reader->node->children->type == XML_TEXT_NODE) &&\n\t     (reader->node->children->next == NULL)) ||\n\t    (reader->node->type == XML_DTD_NODE) ||\n\t    (reader->node->type == XML_DOCUMENT_NODE) ||\n\t    (reader->node->type == XML_HTML_DOCUMENT_NODE)) &&\n\t   ((reader->ctxt->node == NULL) ||\n\t    (reader->ctxt->node == reader->node) ||\n\t    (reader->ctxt->node == reader->node->parent)) &&\n\t   (reader->ctxt->instate != XML_PARSER_EOF) &&\n\t   (PARSER_STOPPED(reader->ctxt) == 0)) {\n\tval = xmlTextReaderPushData(reader);\n\tif (val < 0)\n\t    return(-1);\n\tif (reader->node == NULL)\n\t    goto node_end;\n    }\n    if (oldstate != XML_TEXTREADER_BACKTRACK) {\n\tif ((reader->node->children != NULL) &&\n\t    (reader->node->type != XML_ENTITY_REF_NODE) &&\n\t    (reader->node->type != XML_XINCLUDE_START) &&\n\t    (reader->node->type != XML_DTD_NODE)) {\n\t    reader->node = reader->node->children;\n\t    reader->depth++;\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t    goto node_found;\n\t}\n    }\n    if (reader->node->next != NULL) {\n\tif ((oldstate == XML_TEXTREADER_ELEMENT) &&\n            (reader->node->type == XML_ELEMENT_NODE) &&\n\t    (reader->node->children == NULL) &&\n\t    ((reader->node->extra & NODE_IS_EMPTY) == 0)\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    && (reader->in_xinclude <= 0)\n#endif\n\t    ) {\n\t    reader->state = XML_TEXTREADER_END;\n\t    goto node_found;\n\t}\n#ifdef LIBXML_REGEXP_ENABLED\n\tif ((reader->validate) &&\n\t    (reader->node->type == XML_ELEMENT_NODE))\n\t    if (xmlTextReaderValidatePop(reader) < 0)\n                return(-1);\n#endif /* LIBXML_REGEXP_ENABLED */\n        if ((reader->preserves > 0) &&\n\t    (reader->node->extra & NODE_IS_SPRESERVED))\n\t    reader->preserves--;\n\treader->node = reader->node->next;\n\treader->state = XML_TEXTREADER_ELEMENT;\n\n\t/*\n\t * Cleanup of the old node\n\t */\n\tif ((reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    (reader->in_xinclude == 0) &&\n#endif\n\t    (reader->entNr == 0) &&\n\t    (reader->node->prev != NULL) &&\n            (reader->node->prev->type != XML_DTD_NODE)) {\n\t    xmlNodePtr tmp = reader->node->prev;\n\t    if ((tmp->extra & NODE_IS_PRESERVED) == 0) {\n                if (oldnode == tmp)\n                    oldnode = NULL;\n\t\txmlUnlinkNode(tmp);\n\t\txmlTextReaderFreeNode(reader, tmp);\n\t    }\n\t}\n\n\tgoto node_found;\n    }\n    if ((oldstate == XML_TEXTREADER_ELEMENT) &&\n\t(reader->node->type == XML_ELEMENT_NODE) &&\n\t(reader->node->children == NULL) &&\n\t((reader->node->extra & NODE_IS_EMPTY) == 0)) {;\n\treader->state = XML_TEXTREADER_END;\n\tgoto node_found;\n    }\n#ifdef LIBXML_REGEXP_ENABLED\n    if ((reader->validate != XML_TEXTREADER_NOT_VALIDATE) &&\n        (reader->node->type == XML_ELEMENT_NODE)) {\n        if (xmlTextReaderValidatePop(reader) < 0)\n            return(-1);\n    }\n#endif /* LIBXML_REGEXP_ENABLED */\n    if ((reader->preserves > 0) &&\n\t(reader->node->extra & NODE_IS_SPRESERVED))\n\treader->preserves--;\n    reader->node = reader->node->parent;\n    if ((reader->node == NULL) ||\n\t(reader->node->type == XML_DOCUMENT_NODE) ||\n\t(reader->node->type == XML_HTML_DOCUMENT_NODE)) {\n\tif (reader->mode != XML_TEXTREADER_MODE_EOF) {\n\t    val = xmlParseChunk(reader->ctxt, \"\", 0, 1);\n\t    reader->state = XML_TEXTREADER_DONE;\n\t    if (val != 0)\n\t        return(-1);\n\t}\n\treader->node = NULL;\n\treader->depth = -1;\n\n\t/*\n\t * Cleanup of the old node\n\t */\n\tif ((oldnode != NULL) && (reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    (reader->in_xinclude == 0) &&\n#endif\n\t    (reader->entNr == 0) &&\n\t    (oldnode->type != XML_DTD_NODE) &&\n\t    ((oldnode->extra & NODE_IS_PRESERVED) == 0)) {\n\t    xmlUnlinkNode(oldnode);\n\t    xmlTextReaderFreeNode(reader, oldnode);\n\t}\n\n\tgoto node_end;\n    }\n    if ((reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n        (reader->in_xinclude == 0) &&\n#endif\n\t(reader->entNr == 0) &&\n        (reader->node->last != NULL) &&\n        ((reader->node->last->extra & NODE_IS_PRESERVED) == 0)) {\n\txmlNodePtr tmp = reader->node->last;\n\txmlUnlinkNode(tmp);\n\txmlTextReaderFreeNode(reader, tmp);\n    }\n    reader->depth--;\n    reader->state = XML_TEXTREADER_BACKTRACK;\n\nnode_found:\n    /*\n     * If we are in the middle of a piece of CDATA make sure it's finished\n     */\n    if ((reader->node != NULL) &&\n        (reader->node->next == NULL) &&\n        ((reader->node->type == XML_TEXT_NODE) ||\n\t (reader->node->type == XML_CDATA_SECTION_NODE))) {\n            if (xmlTextReaderExpand(reader) == NULL)\n\t        return -1;\n    }\n\n#ifdef LIBXML_XINCLUDE_ENABLED\n    /*\n     * Handle XInclude if asked for\n     */\n    if ((reader->xinclude) && (reader->in_xinclude == 0) &&\n        (reader->state != XML_TEXTREADER_BACKTRACK) &&\n        (reader->node != NULL) &&\n\t(reader->node->type == XML_ELEMENT_NODE) &&\n\t(reader->node->ns != NULL) &&\n\t((xmlStrEqual(reader->node->ns->href, XINCLUDE_NS)) ||\n\t (xmlStrEqual(reader->node->ns->href, XINCLUDE_OLD_NS)))) {\n\tif (reader->xincctxt == NULL) {\n\t    reader->xincctxt = xmlXIncludeNewContext(reader->ctxt->myDoc);\n            if (reader->xincctxt == NULL) {\n                xmlTextReaderErrMemory(reader);\n                return(-1);\n            }\n\t    xmlXIncludeSetFlags(reader->xincctxt,\n\t                        reader->parserFlags & (~XML_PARSE_NOXINCNODE));\n            xmlXIncludeSetStreamingMode(reader->xincctxt, 1);\n            if ((reader->errorFunc != NULL) || (reader->sErrorFunc != NULL))\n                xmlXIncludeSetErrorHandler(reader->xincctxt,\n                        xmlTextReaderStructuredRelay, reader);\n\t}\n\t/*\n\t * expand that node and process it\n\t */\n\tif (xmlTextReaderExpand(reader) == NULL)\n\t    return(-1);\n        if (xmlXIncludeProcessNode(reader->xincctxt, reader->node) < 0) {\n            int err = xmlXIncludeGetLastError(reader->xincctxt);\n\n            if (err == XML_ERR_NO_MEMORY)\n                xmlTextReaderErrMemory(reader);\n            return(-1);\n        }\n    }\n    if ((reader->node != NULL) && (reader->node->type == XML_XINCLUDE_START)) {\n        reader->in_xinclude++;\n\tgoto get_next_node;\n    }\n    if ((reader->node != NULL) && (reader->node->type == XML_XINCLUDE_END)) {\n        reader->in_xinclude--;\n\tgoto get_next_node;\n    }\n#endif\n    /*\n     * Handle entities enter and exit when in entity replacement mode\n     */\n    if ((reader->node != NULL) &&\n\t(reader->node->type == XML_ENTITY_REF_NODE) &&\n\t(reader->ctxt != NULL) && (reader->ctxt->replaceEntities == 1)) {\n\tif ((reader->node->children != NULL) &&\n\t    (reader->node->children->type == XML_ENTITY_DECL) &&\n\t    (reader->node->children->children != NULL)) {\n\t    if (xmlTextReaderEntPush(reader, reader->node) < 0)\n                goto get_next_node;\n\t    reader->node = reader->node->children->children;\n\t}\n#ifdef LIBXML_REGEXP_ENABLED\n    } else if ((reader->node != NULL) &&\n\t       (reader->node->type == XML_ENTITY_REF_NODE) &&\n\t       (reader->ctxt != NULL) && (reader->validate)) {\n\tif (xmlTextReaderValidateEntity(reader) < 0)\n            return(-1);\n#endif /* LIBXML_REGEXP_ENABLED */\n    }\n    if ((reader->node != NULL) &&\n\t(reader->node->type == XML_ENTITY_DECL) &&\n\t(reader->ent != NULL) && (reader->ent->children == reader->node)) {\n\treader->node = xmlTextReaderEntPop(reader);\n\treader->depth++;\n        goto get_next_node;\n    }\n#ifdef LIBXML_REGEXP_ENABLED\n    if ((reader->validate != XML_TEXTREADER_NOT_VALIDATE) && (reader->node != NULL)) {\n\txmlNodePtr node = reader->node;\n\n\tif ((node->type == XML_ELEMENT_NODE) &&\n            ((reader->state != XML_TEXTREADER_END) &&\n\t     (reader->state != XML_TEXTREADER_BACKTRACK))) {\n\t    if (xmlTextReaderValidatePush(reader) < 0)\n                return(-1);\n\t} else if ((node->type == XML_TEXT_NODE) ||\n\t\t   (node->type == XML_CDATA_SECTION_NODE)) {\n            xmlTextReaderValidateCData(reader, node->content,\n\t                               xmlStrlen(node->content));\n\t}\n    }\n#endif /* LIBXML_REGEXP_ENABLED */\n#ifdef LIBXML_PATTERN_ENABLED\n    if ((reader->patternNr > 0) && (reader->state != XML_TEXTREADER_END) &&\n        (reader->state != XML_TEXTREADER_BACKTRACK)) {\n        int i;\n\tfor (i = 0;i < reader->patternNr;i++) {\n\t     if (xmlPatternMatch(reader->patternTab[i], reader->node) == 1) {\n\t         xmlTextReaderPreserve(reader);\n\t\t break;\n             }\n\t}\n    }\n#endif /* LIBXML_PATTERN_ENABLED */\n#ifdef LIBXML_SCHEMAS_ENABLED\n    if ((reader->validate == XML_TEXTREADER_VALIDATE_XSD) &&\n        (reader->xsdValidErrors == 0) &&\n\t(reader->xsdValidCtxt != NULL)) {\n\treader->xsdValidErrors = !xmlSchemaIsValid(reader->xsdValidCtxt);\n    }\n#endif /* LIBXML_PATTERN_ENABLED */\n    return(1);\nnode_end:\n    reader->state = XML_TEXTREADER_DONE;\n    return(0);\n}\n\n\n// target function\nstatic void\nxmlTextReaderValidateEntity(xmlTextReaderPtr reader) {\n    xmlNodePtr oldnode = reader->node;\n    xmlNodePtr node = reader->node;\n\n    do {\n\tif (node->type == XML_ENTITY_REF_NODE) {\n\t    if ((node->children != NULL) &&\n\t\t(node->children->type == XML_ENTITY_DECL) &&\n\t\t(node->children->children != NULL)) {\n\t\tif (xmlTextReaderEntPush(reader, node) < 0) {\n                    if (node == oldnode)\n                        break;\n                    goto skip_children;\n                }\n\t\tnode = node->children->children;\n\t\tcontinue;\n\t    } else {\n\t\t/*\n\t\t * The error has probably been raised already.\n\t\t */\n\t\tif (node == oldnode)\n\t\t    break;\n                goto skip_children;\n\t    }\n#ifdef LIBXML_REGEXP_ENABLED\n\t} else if (node->type == XML_ELEMENT_NODE) {\n\t    reader->node = node;\n\t    if (xmlTextReaderValidatePush(reader) < 0)\n                return;\n\t} else if ((node->type == XML_TEXT_NODE) ||\n\t\t   (node->type == XML_CDATA_SECTION_NODE)) {\n            xmlTextReaderValidateCData(reader, node->content,\n\t                               xmlStrlen(node->content));\n#endif\n\t}\n\n\t/*\n\t * go to next node\n\t */\n\tif (node->children != NULL) {\n\t    node = node->children;\n\t    continue;\n\t} else if (node->type == XML_ELEMENT_NODE) {\n\t    if (xmlTextReaderValidatePop(reader) < 0)\n                return;\n\t}\nskip_children:\n\tif (node->next != NULL) {\n\t    node = node->next;\n\t    continue;\n\t}\n\tdo {\n\t    node = node->parent;\n\t    if (node->type == XML_ELEMENT_NODE) {\n\t        xmlNodePtr tmp;\n\t\tif (reader->entNr == 0) {\n\t\t    while ((tmp = node->last) != NULL) {\n\t\t\tif ((tmp->extra & NODE_IS_PRESERVED) == 0) {\n\t\t\t    xmlUnlinkNode(tmp);\n\t\t\t    xmlTextReaderFreeNode(reader, tmp);\n\t\t\t} else\n\t\t\t    break;\n\t\t    }\n\t\t}\n\t\treader->node = node;\n\t\tif (xmlTextReaderValidatePop(reader) < 0)\n                    return;\n\t    }\n\t    if ((node->type == XML_ENTITY_DECL) &&\n\t\t(reader->ent != NULL) && (reader->ent->children == node)) {\n\t\tnode = xmlTextReaderEntPop(reader);\n\t    }\n\t    if (node == oldnode)\n\t\tbreak;\n\t    if (node->next != NULL) {\n\t\tnode = node->next;\n\t\tbreak;\n\t    }\n\t} while ((node != NULL) && (node != oldnode));\n    } while ((node != NULL) && (node != oldnode));\n    reader->node = oldnode;\n}\nint\nxmlTextReaderRead(xmlTextReaderPtr reader) {\n    int val, olddepth = 0;\n    xmlTextReaderState oldstate = XML_TEXTREADER_START;\n    xmlNodePtr oldnode = NULL;\n\n\n    if (reader == NULL)\n\treturn(-1);\n    reader->curnode = NULL;\n    if (reader->doc != NULL)\n        return(xmlTextReaderReadTree(reader));\n    if (reader->ctxt == NULL)\n\treturn(-1);\n\n    if (reader->mode == XML_TEXTREADER_MODE_INITIAL) {\n\treader->mode = XML_TEXTREADER_MODE_INTERACTIVE;\n\t/*\n\t * Initial state\n\t */\n\tdo {\n\t    val = xmlTextReaderPushData(reader);\n\t\tif (val < 0){\n\t\t\treader->mode = XML_TEXTREADER_MODE_ERROR;\n\t\t\treader->state = XML_TEXTREADER_ERROR;\n\t\treturn(-1);\n\t\t}\n\t} while ((reader->ctxt->node == NULL) &&\n\t\t ((reader->mode != XML_TEXTREADER_MODE_EOF) &&\n\t\t  (reader->state != XML_TEXTREADER_DONE)));\n\tif (reader->ctxt->node == NULL) {\n\t    if (reader->ctxt->myDoc != NULL) {\n\t\treader->node = reader->ctxt->myDoc->children;\n\t    }\n\t    if (reader->node == NULL){\n\t\t\treader->mode = XML_TEXTREADER_MODE_ERROR;\n\t\t\treader->state = XML_TEXTREADER_ERROR;\n\t\treturn(-1);\n\t\t}\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t} else {\n\t    if (reader->ctxt->myDoc != NULL) {\n\t\treader->node = reader->ctxt->myDoc->children;\n\t    }\n\t    if (reader->node == NULL)\n\t\treader->node = reader->ctxt->nodeTab[0];\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t}\n\treader->depth = 0;\n\treader->ctxt->parseMode = XML_PARSE_READER;\n\tgoto node_found;\n    }\n    oldstate = reader->state;\n    olddepth = reader->ctxt->nodeNr;\n    oldnode = reader->node;\n\nget_next_node:\n    if (reader->node == NULL) {\n\tif (reader->mode == XML_TEXTREADER_MODE_EOF)\n\t    return(0);\n\telse\n\t    return(-1);\n    }\n\n    /*\n     * If we are not backtracking on ancestors or examined nodes,\n     * that the parser didn't finished or that we aren't at the end\n     * of stream, continue processing.\n     */\n    while ((reader->node != NULL) && (reader->node->next == NULL) &&\n\t   (reader->ctxt->nodeNr == olddepth) &&\n           ((oldstate == XML_TEXTREADER_BACKTRACK) ||\n            (reader->node->children == NULL) ||\n\t    (reader->node->type == XML_ENTITY_REF_NODE) ||\n\t    ((reader->node->children != NULL) &&\n\t     (reader->node->children->type == XML_TEXT_NODE) &&\n\t     (reader->node->children->next == NULL)) ||\n\t    (reader->node->type == XML_DTD_NODE) ||\n\t    (reader->node->type == XML_DOCUMENT_NODE) ||\n\t    (reader->node->type == XML_HTML_DOCUMENT_NODE)) &&\n\t   ((reader->ctxt->node == NULL) ||\n\t    (reader->ctxt->node == reader->node) ||\n\t    (reader->ctxt->node == reader->node->parent)) &&\n\t   (reader->ctxt->instate != XML_PARSER_EOF) &&\n\t   (PARSER_STOPPED(reader->ctxt) == 0)) {\n\tval = xmlTextReaderPushData(reader);\n\tif (val < 0)\n\t    return(-1);\n\tif (reader->node == NULL)\n\t    goto node_end;\n    }\n    if (oldstate != XML_TEXTREADER_BACKTRACK) {\n\tif ((reader->node->children != NULL) &&\n\t    (reader->node->type != XML_ENTITY_REF_NODE) &&\n\t    (reader->node->type != XML_XINCLUDE_START) &&\n\t    (reader->node->type != XML_DTD_NODE)) {\n\t    reader->node = reader->node->children;\n\t    reader->depth++;\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t    goto node_found;\n\t}\n    }\n    if (reader->node->next != NULL) {\n\tif ((oldstate == XML_TEXTREADER_ELEMENT) &&\n            (reader->node->type == XML_ELEMENT_NODE) &&\n\t    (reader->node->children == NULL) &&\n\t    ((reader->node->extra & NODE_IS_EMPTY) == 0)\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    && (reader->in_xinclude <= 0)\n#endif\n\t    ) {\n\t    reader->state = XML_TEXTREADER_END;\n\t    goto node_found;\n\t}\n#ifdef LIBXML_REGEXP_ENABLED\n\tif ((reader->validate) &&\n\t    (reader->node->type == XML_ELEMENT_NODE))\n\t    if (xmlTextReaderValidatePop(reader) < 0)\n                return(-1);\n#endif /* LIBXML_REGEXP_ENABLED */\n        if ((reader->preserves > 0) &&\n\t    (reader->node->extra & NODE_IS_SPRESERVED))\n\t    reader->preserves--;\n\treader->node = reader->node->next;\n\treader->state = XML_TEXTREADER_ELEMENT;\n\n\t/*\n\t * Cleanup of the old node\n\t */\n\tif ((reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    (reader->in_xinclude == 0) &&\n#endif\n\t    (reader->entNr == 0) &&\n\t    (reader->node->prev != NULL) &&\n            (reader->node->prev->type != XML_DTD_NODE)) {\n\t    xmlNodePtr tmp = reader->node->prev;\n\t    if ((tmp->extra & NODE_IS_PRESERVED) == 0) {\n                if (oldnode == tmp)\n                    oldnode = NULL;\n\t\txmlUnlinkNode(tmp);\n\t\txmlTextReaderFreeNode(reader, tmp);\n\t    }\n\t}\n\n\tgoto node_found;\n    }\n    if ((oldstate == XML_TEXTREADER_ELEMENT) &&\n\t(reader->node->type == XML_ELEMENT_NODE) &&\n\t(reader->node->children == NULL) &&\n\t((reader->node->extra & NODE_IS_EMPTY) == 0)) {;\n\treader->state = XML_TEXTREADER_END;\n\tgoto node_found;\n    }\n#ifdef LIBXML_REGEXP_ENABLED\n    if ((reader->validate != XML_TEXTREADER_NOT_VALIDATE) &&\n        (reader->node->type == XML_ELEMENT_NODE)) {\n        if (xmlTextReaderValidatePop(reader) < 0)\n            return(-1);\n    }\n#endif /* LIBXML_REGEXP_ENABLED */\n    if ((reader->preserves > 0) &&\n\t(reader->node->extra & NODE_IS_SPRESERVED))\n\treader->preserves--;\n    reader->node = reader->node->parent;\n    if ((reader->node == NULL) ||\n\t(reader->node->type == XML_DOCUMENT_NODE) ||\n\t(reader->node->type == XML_HTML_DOCUMENT_NODE)) {\n\tif (reader->mode != XML_TEXTREADER_MODE_EOF) {\n\t    val = xmlParseChunk(reader->ctxt, \"\", 0, 1);\n\t    reader->state = XML_TEXTREADER_DONE;\n\t    if (val != 0)\n\t        return(-1);\n\t}\n\treader->node = NULL;\n\treader->depth = -1;\n\n\t/*\n\t * Cleanup of the old node\n\t */\n\tif ((oldnode != NULL) && (reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    (reader->in_xinclude == 0) &&\n#endif\n\t    (reader->entNr == 0) &&\n\t    (oldnode->type != XML_DTD_NODE) &&\n\t    ((oldnode->extra & NODE_IS_PRESERVED) == 0)) {\n\t    xmlUnlinkNode(oldnode);\n\t    xmlTextReaderFreeNode(reader, oldnode);\n\t}\n\n\tgoto node_end;\n    }\n    if ((reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n        (reader->in_xinclude == 0) &&\n#endif\n\t(reader->entNr == 0) &&\n        (reader->node->last != NULL) &&\n        ((reader->node->last->extra & NODE_IS_PRESERVED) == 0)) {\n\txmlNodePtr tmp = reader->node->last;\n\txmlUnlinkNode(tmp);\n\txmlTextReaderFreeNode(reader, tmp);\n    }\n    reader->depth--;\n    reader->state = XML_TEXTREADER_BACKTRACK;\n\nnode_found:\n    /*\n     * If we are in the middle of a piece of CDATA make sure it's finished\n     */\n    if ((reader->node != NULL) &&\n        (reader->node->next == NULL) &&\n        ((reader->node->type == XML_TEXT_NODE) ||\n\t (reader->node->type == XML_CDATA_SECTION_NODE))) {\n            if (xmlTextReaderExpand(reader) == NULL)\n\t        return -1;\n    }\n\n#ifdef LIBXML_XINCLUDE_ENABLED\n    /*\n     * Handle XInclude if asked for\n     */\n    if ((reader->xinclude) && (reader->in_xinclude == 0) &&\n        (reader->state != XML_TEXTREADER_BACKTRACK) &&\n        (reader->node != NULL) &&\n\t(reader->node->type == XML_ELEMENT_NODE) &&\n\t(reader->node->ns != NULL) &&\n\t((xmlStrEqual(reader->node->ns->href, XINCLUDE_NS)) ||\n\t (xmlStrEqual(reader->node->ns->href, XINCLUDE_OLD_NS)))) {\n\tif (reader->xincctxt == NULL) {\n\t    reader->xincctxt = xmlXIncludeNewContext(reader->ctxt->myDoc);\n            if (reader->xincctxt == NULL) {\n                xmlTextReaderErrMemory(reader);\n                return(-1);\n            }\n\t    xmlXIncludeSetFlags(reader->xincctxt,\n\t                        reader->parserFlags & (~XML_PARSE_NOXINCNODE));\n            xmlXIncludeSetStreamingMode(reader->xincctxt, 1);\n            if ((reader->errorFunc != NULL) || (reader->sErrorFunc != NULL))\n                xmlXIncludeSetErrorHandler(reader->xincctxt,\n                        xmlTextReaderStructuredRelay, reader);\n\t}\n\t/*\n\t * expand that node and process it\n\t */\n\tif (xmlTextReaderExpand(reader) == NULL)\n\t    return(-1);\n        if (xmlXIncludeProcessNode(reader->xincctxt, reader->node) < 0) {\n            int err = xmlXIncludeGetLastError(reader->xincctxt);\n\n            if (err == XML_ERR_NO_MEMORY)\n                xmlTextReaderErrMemory(reader);\n            return(-1);\n        }\n    }\n    if ((reader->node != NULL) && (reader->node->type == XML_XINCLUDE_START)) {\n        reader->in_xinclude++;\n\tgoto get_next_node;\n    }\n    if ((reader->node != NULL) && (reader->node->type == XML_XINCLUDE_END)) {\n        reader->in_xinclude--;\n\tgoto get_next_node;\n    }\n#endif\n    /*\n     * Handle entities enter and exit when in entity replacement mode\n     */\n    if ((reader->node != NULL) &&\n\t(reader->node->type == XML_ENTITY_REF_NODE) &&\n\t(reader->ctxt != NULL) && (reader->ctxt->replaceEntities == 1)) {\n\tif ((reader->node->children != NULL) &&\n\t    (reader->node->children->type == XML_ENTITY_DECL) &&\n\t    (reader->node->children->children != NULL)) {\n\t    if (xmlTextReaderEntPush(reader, reader->node) < 0)\n                goto get_next_node;\n\t    reader->node = reader->node->children->children;\n\t}\n#ifdef LIBXML_REGEXP_ENABLED\n    } else if ((reader->node != NULL) &&\n\t       (reader->node->type == XML_ENTITY_REF_NODE) &&\n\t       (reader->ctxt != NULL) && (reader->validate)) {\n\txmlTextReaderValidateEntity(reader);\n#endif /* LIBXML_REGEXP_ENABLED */\n    }\n    if ((reader->node != NULL) &&\n\t(reader->node->type == XML_ENTITY_DECL) &&\n\t(reader->ent != NULL) && (reader->ent->children == reader->node)) {\n\treader->node = xmlTextReaderEntPop(reader);\n\treader->depth++;\n        goto get_next_node;\n    }\n#ifdef LIBXML_REGEXP_ENABLED\n    if ((reader->validate != XML_TEXTREADER_NOT_VALIDATE) && (reader->node != NULL)) {\n\txmlNodePtr node = reader->node;\n\n\tif ((node->type == XML_ELEMENT_NODE) &&\n            ((reader->state != XML_TEXTREADER_END) &&\n\t     (reader->state != XML_TEXTREADER_BACKTRACK))) {\n\t    if (xmlTextReaderValidatePush(reader) < 0)\n                return(-1);\n\t} else if ((node->type == XML_TEXT_NODE) ||\n\t\t   (node->type == XML_CDATA_SECTION_NODE)) {\n            xmlTextReaderValidateCData(reader, node->content,\n\t                               xmlStrlen(node->content));\n\t}\n    }\n#endif /* LIBXML_REGEXP_ENABLED */\n#ifdef LIBXML_PATTERN_ENABLED\n    if ((reader->patternNr > 0) && (reader->state != XML_TEXTREADER_END) &&\n        (reader->state != XML_TEXTREADER_BACKTRACK)) {\n        int i;\n\tfor (i = 0;i < reader->patternNr;i++) {\n\t     if (xmlPatternMatch(reader->patternTab[i], reader->node) == 1) {\n\t         xmlTextReaderPreserve(reader);\n\t\t break;\n             }\n\t}\n    }\n#endif /* LIBXML_PATTERN_ENABLED */\n#ifdef LIBXML_SCHEMAS_ENABLED\n    if ((reader->validate == XML_TEXTREADER_VALIDATE_XSD) &&\n        (reader->xsdValidErrors == 0) &&\n\t(reader->xsdValidCtxt != NULL)) {\n\treader->xsdValidErrors = !xmlSchemaIsValid(reader->xsdValidCtxt);\n    }\n#endif /* LIBXML_PATTERN_ENABLED */\n    return(1);\nnode_end:\n    reader->state = XML_TEXTREADER_DONE;\n    return(0);\n}\n",
    "target": 1,
    "idx": 1066154,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "// context\nstatic void ddsi_type_unref_impl_locked (struct ddsi_domaingv *gv, struct ddsi_type *type)\n{\n  assert (type->refc > 0);\n  if (--type->refc == 0)\n  {\n    GVTRACE (\" refc 0 remove type \");\n    ddsrt_avl_delete (&ddsi_typelib_treedef, &gv->typelib, type);\n    ddsi_type_free (gv, type);\n  }\n  else\n    GVTRACE (\" refc %\" PRIu32 \" \", type->refc);\n}\n\nvoid ddsi_type_unref_locked (struct ddsi_domaingv *gv, struct ddsi_type *type)\n{\n  if (type == NULL)\n    return;\n  struct ddsi_typeid_str tistr;\n  GVTRACE (\"unref ddsi_type id %s\", ddsi_make_typeid_str (&tistr, &type->xt.id));\n  ddsi_type_unref_impl_locked (gv, type);\n  GVTRACE (\"\\n\");\n}\n\n\n\n\n\nstatic dds_return_t ddsi_type_new (struct ddsi_domaingv *gv, struct ddsi_type **type, const struct DDS_XTypes_TypeIdentifier *type_id, const struct DDS_XTypes_TypeObject *type_obj)\n{\n  dds_return_t ret;\n  struct ddsi_typeid_str tistr;\n  assert (type);\n  assert (!ddsi_typeid_is_none_impl (type_id));\n  assert (!ddsi_type_lookup_locked_impl (gv, type_id));\n\n  ddsi_typeid_t type_obj_id;\n  if (type_obj && ((ret = ddsi_typeobj_get_hash_id (type_obj, &type_obj_id))\n      || (ret = (ddsi_typeid_compare_impl (&type_obj_id.x, type_id) ? DDS_RETCODE_BAD_PARAMETER : DDS_RETCODE_OK))))\n  {\n    GVWARNING (\"non-matching type identifier (%s) and type object (%s)\\n\", ddsi_make_typeid_str_impl (&tistr, type_id), ddsi_make_typeid_str (&tistr, &type_obj_id));\n    *type = NULL;\n    return ret;\n  }\n\n  if ((*type = ddsrt_calloc (1, sizeof (**type))) == NULL)\n    return DDS_RETCODE_OUT_OF_RESOURCES;\n\n  GVTRACE (\" new %p\", *type);\n  if ((ret = ddsi_xt_type_init_impl (gv, &(*type)->xt, type_id, type_obj)) != DDS_RETCODE_OK)\n  {\n    ddsi_type_free (gv, *type);\n    *type = NULL;\n    return ret;\n  }\n  if (!ddsi_typeid_is_hash (&(*type)->xt.id))\n    (*type)->state = DDSI_TYPE_RESOLVED;\n  /* inserted with refc 0 (set by calloc), refc is increased in\n     ddsi_type_ref_* functions */\n  ddsrt_avl_insert (&ddsi_typelib_treedef, &gv->typelib, *type);\n  return DDS_RETCODE_OK;\n}\n\ndds_return_t ddsi_type_ref_proxy (struct ddsi_domaingv *gv, struct ddsi_type **type, const ddsi_typeinfo_t *type_info, ddsi_typeid_kind_t kind, const ddsi_guid_t *proxy_guid)\n{\n  dds_return_t ret = DDS_RETCODE_OK;\n  struct ddsi_typeid_str tistr;\n  assert (type_info);\n  assert (kind == DDSI_TYPEID_KIND_MINIMAL || kind == DDSI_TYPEID_KIND_COMPLETE);\n  const struct DDS_XTypes_TypeIdentifier *type_id = (kind == DDSI_TYPEID_KIND_MINIMAL) ? &type_info->x.minimal.typeid_with_size.type_id : &type_info->x.complete.typeid_with_size.type_id;\n\n  ddsrt_mutex_lock (&gv->typelib_lock);\n\n  GVTRACE (\"ref ddsi_type proxy id %s\", ddsi_make_typeid_str_impl (&tistr, type_id));\n  struct ddsi_type *t = ddsi_type_lookup_locked_impl (gv, type_id);\n  if (!t && (ret = ddsi_type_new (gv, &t, type_id, NULL)) != DDS_RETCODE_OK)\n    goto err;\n  t->refc++;\n  GVTRACE(\" refc %\"PRIu32\"\\n\", t->refc);\n  if (!valid_top_level_type (t))\n  {\n    ret = DDS_RETCODE_BAD_PARAMETER;\n    ddsi_type_unref_locked (gv, t);\n    GVTRACE (\" invalid top-level type\\n\");\n    goto err;\n  }\n\n  if ((ret = type_add_deps (gv, t, type_info, NULL, kind, NULL, NULL))\n      || (ret = ddsi_xt_validate (gv, &t->xt)))\n  {\n    ddsi_type_unref_locked (gv, t);\n    goto err;\n  }\n\n  if (proxy_guid != NULL && !ddsi_type_proxy_guid_exists (t, proxy_guid))\n  {\n    ddsi_type_proxy_guid_list_insert (&t->proxy_guids, *proxy_guid);\n    GVTRACE (\"type %s add ep \"PGUIDFMT\"\\n\", ddsi_make_typeid_str_impl (&tistr, type_id), PGUID (*proxy_guid));\n  }\n  if (type)\n    *type = t;\nerr:\n  ddsrt_mutex_unlock (&gv->typelib_lock);\n  return ret;\n}\n\n\n// target function\nstatic void ddsi_type_fini (struct ddsi_domaingv *gv, struct ddsi_type *type)\n{\n  struct ddsi_type_dep key;\n  memset (&key, 0, sizeof (key));\n  ddsi_typeid_copy (&key.src_type_id, &type->xt.id);\n  ddsi_xt_type_fini (gv, &type->xt, true);\n\n  struct ddsi_type_dep *dep;\n  while ((dep = ddsrt_avl_lookup_succ_eq (&ddsi_typedeps_treedef, &gv->typedeps, &key)) != NULL && !ddsi_typeid_compare (&dep->src_type_id, &key.src_type_id))\n  {\n    type_dep_trace (gv, \"ddsi_type_fini \", dep);\n    ddsrt_avl_delete (&ddsi_typedeps_treedef, &gv->typedeps, dep);\n    ddsrt_avl_delete (&ddsi_typedeps_reverse_treedef, &gv->typedeps_reverse, dep);\n    if (dep->from_type_info)\n    {\n      /* This dependency record was added based on dependencies from a type-info object,\n         and the dep-type was ref-counted when creating the dependency. Therefore, an\n         unref is required at this point when the from_type_info flag is set. */\n      struct ddsi_type *dep_type = ddsi_type_lookup_locked (gv, &dep->dep_type_id);\n      ddsi_type_unref_locked (gv, dep_type);\n    }\n    ddsi_typeid_fini (&dep->src_type_id);\n    ddsi_typeid_fini (&dep->dep_type_id);\n    ddsrt_free (dep);\n  }\n#ifndef NDEBUG\n  assert (!ddsi_type_proxy_guid_list_count (&type->proxy_guids));\n#endif\n  ddsi_typeid_fini (&key.src_type_id);\n  ddsrt_free (type);\n}\nstatic dds_return_t ddsi_type_new (struct ddsi_domaingv *gv, struct ddsi_type **type, const struct DDS_XTypes_TypeIdentifier *type_id, const struct DDS_XTypes_TypeObject *type_obj)\n{\n  dds_return_t ret;\n  struct ddsi_typeid_str tistr;\n  assert (type);\n  assert (!ddsi_typeid_is_none_impl (type_id));\n  assert (!ddsi_type_lookup_locked_impl (gv, type_id));\n\n  ddsi_typeid_t type_obj_id;\n  if (type_obj && ((ret = ddsi_typeobj_get_hash_id (type_obj, &type_obj_id))\n      || (ret = (ddsi_typeid_compare_impl (&type_obj_id.x, type_id) ? DDS_RETCODE_BAD_PARAMETER : DDS_RETCODE_OK))))\n  {\n    GVWARNING (\"non-matching type identifier (%s) and type object (%s)\\n\", ddsi_make_typeid_str_impl (&tistr, type_id), ddsi_make_typeid_str (&tistr, &type_obj_id));\n    *type = NULL;\n    return ret;\n  }\n\n  if ((*type = ddsrt_calloc (1, sizeof (**type))) == NULL)\n    return DDS_RETCODE_OUT_OF_RESOURCES;\n\n  GVTRACE (\" new %p\", *type);\n  if ((ret = ddsi_xt_type_init_impl (gv, &(*type)->xt, type_id, type_obj)) != DDS_RETCODE_OK)\n  {\n    ddsi_type_fini (gv, *type);\n    *type = NULL;\n    return ret;\n  }\n  if (!ddsi_typeid_is_hash (&(*type)->xt.id))\n    (*type)->state = DDSI_TYPE_RESOLVED;\n  /* inserted with refc 0 (set by calloc), refc is increased in\n     ddsi_type_ref_* functions */\n  ddsrt_avl_insert (&ddsi_typelib_treedef, &gv->typelib, *type);\n  return DDS_RETCODE_OK;\n}\nstatic dds_return_t ddsi_type_register_dep_impl (struct ddsi_domaingv *gv, const ddsi_typeid_t *src_type_id, struct ddsi_type **dst_dep_type, const struct DDS_XTypes_TypeIdentifier *dep_tid, bool from_type_info)\n{\n  dds_return_t ret = DDS_RETCODE_OK;\n  struct ddsi_typeid dep_type_id;\n  dep_type_id.x = *dep_tid;\n  struct ddsi_type_dep *dep = ddsrt_calloc (1, sizeof (*dep));\n  ddsi_typeid_copy (&dep->src_type_id, src_type_id);\n  ddsi_typeid_copy (&dep->dep_type_id, &dep_type_id);\n  bool existing = ddsrt_avl_lookup (&ddsi_typedeps_treedef, &gv->typedeps, dep) != NULL;\n  type_dep_trace (gv, existing ? \"has \" : \"add \", dep);\n  if (!existing)\n  {\n    dep->from_type_info = from_type_info;\n    ddsrt_avl_insert (&ddsi_typedeps_treedef, &gv->typedeps, dep);\n    ddsrt_avl_insert (&ddsi_typedeps_reverse_treedef, &gv->typedeps_reverse, dep);\n    if ((ret = ddsi_type_ref_id_locked (gv, dst_dep_type, &dep_type_id)) != DDS_RETCODE_OK)\n    {\n      ddsrt_avl_delete (&ddsi_typedeps_treedef, &gv->typedeps, dep);\n      ddsrt_avl_delete (&ddsi_typedeps_reverse_treedef, &gv->typedeps_reverse, dep);\n    }\n  }\n  else\n  {\n    ddsi_typeid_fini (&dep->src_type_id);\n    ddsi_typeid_fini (&dep->dep_type_id);\n    ddsrt_free (dep);\n    if (!from_type_info)\n      ret = ddsi_type_ref_id_locked (gv, dst_dep_type, &dep_type_id);\n    else\n    {\n      *dst_dep_type = ddsi_type_lookup_locked (gv, &dep_type_id);\n      if (*dst_dep_type == NULL)\n        ret = DDS_RETCODE_ERROR;\n    }\n  }\n  return ret;\n}\ndds_return_t ddsi_type_ref_id_locked_impl (struct ddsi_domaingv *gv, struct ddsi_type **type, const struct DDS_XTypes_TypeIdentifier *type_id)\n{\n  struct ddsi_typeid_str tistr;\n  dds_return_t ret = DDS_RETCODE_OK;\n  assert (!ddsi_typeid_is_none_impl (type_id));\n  GVTRACE (\"ref ddsi_type type-id %s\", ddsi_make_typeid_str_impl (&tistr, type_id));\n  struct ddsi_type *t = ddsi_type_lookup_locked_impl (gv, type_id);\n  if (!t && (ret = ddsi_type_new (gv, &t, type_id, NULL)) != DDS_RETCODE_OK)\n  {\n    if (type)\n      *type = NULL;\n    return ret;\n  }\n  t->refc++;\n  GVTRACE (\" refc %\"PRIu32\"\\n\", t->refc);\n  if (type)\n    *type = t;\n  return ret;\n}\nvoid ddsi_type_unreg_proxy (struct ddsi_domaingv *gv, struct ddsi_type *type, const ddsi_guid_t *proxy_guid)\n{\n  struct ddsi_typeid_str tistr;\n  assert (proxy_guid);\n  if (!type)\n    return;\n  ddsrt_mutex_lock (&gv->typelib_lock);\n  GVTRACE (\"unreg proxy guid \" PGUIDFMT \" ddsi_type id %s\\n\", PGUID (*proxy_guid), ddsi_make_typeid_str (&tistr, &type->xt.id));\n  ddsi_type_proxy_guid_list_remove (&type->proxy_guids, *proxy_guid, ddsi_type_proxy_guids_eq);\n  ddsrt_mutex_unlock (&gv->typelib_lock);\n}\nvoid ddsi_type_unref (struct ddsi_domaingv *gv, struct ddsi_type *type)\n{\n  struct ddsi_typeid_str tistr;\n  if (!type)\n    return;\n  ddsrt_mutex_lock (&gv->typelib_lock);\n  GVTRACE (\"unref ddsi_type id %s\", ddsi_make_typeid_str (&tistr, &type->xt.id));\n  ddsi_type_unref_impl_locked (gv, type);\n  ddsrt_mutex_unlock (&gv->typelib_lock);\n  GVTRACE (\"\\n\");\n}\nvoid ddsi_type_unref_sertype (struct ddsi_domaingv *gv, const struct ddsi_sertype *sertype)\n{\n  assert (sertype);\n  ddsrt_mutex_lock (&gv->typelib_lock);\n\n  ddsi_typeid_kind_t kinds[2] = { DDSI_TYPEID_KIND_MINIMAL, DDSI_TYPEID_KIND_COMPLETE };\n  for (uint32_t n = 0; n < sizeof (kinds) / sizeof (kinds[0]); n++)\n  {\n    struct ddsi_type *type;\n    ddsi_typeid_t *type_id = ddsi_sertype_typeid (sertype, kinds[n]);\n    if (!ddsi_typeid_is_none (type_id) && ((type = ddsi_type_lookup_locked (gv, type_id))))\n    {\n      struct ddsi_typeid_str tistr;\n      GVTRACE (\"unref ddsi_type id %s\", ddsi_make_typeid_str (&tistr, &type->xt.id));\n      ddsi_type_unref_impl_locked (gv, type);\n    }\n    if (type_id)\n    {\n      ddsi_typeid_fini (type_id);\n      ddsrt_free (type_id);\n    }\n  }\n\n  ddsrt_mutex_unlock (&gv->typelib_lock);\n}\nstatic void ddsi_type_get_gpe_matches_impl (struct ddsi_domaingv *gv, const struct ddsi_type *type, struct ddsi_generic_proxy_endpoint ***gpe_match_upd, uint32_t *n_match_upd)\n{\n  if (!ddsi_type_proxy_guid_list_count (&type->proxy_guids))\n    return;\n\n  uint32_t n = 0;\n  ddsi_thread_state_awake (ddsi_lookup_thread_state (), gv);\n  *gpe_match_upd = ddsrt_realloc (*gpe_match_upd, (*n_match_upd + ddsi_type_proxy_guid_list_count (&type->proxy_guids)) * sizeof (**gpe_match_upd));\n  struct ddsi_type_proxy_guid_list_iter it;\n  for (ddsi_guid_t guid = ddsi_type_proxy_guid_list_iter_first (&type->proxy_guids, &it); !ddsi_is_null_guid (&guid); guid = ddsi_type_proxy_guid_list_iter_next (&it))\n  {\n    if (!ddsi_is_topic_entityid (guid.entityid))\n    {\n      struct ddsi_entity_common *ec = ddsi_entidx_lookup_guid_untyped (gv->entity_index, &guid);\n      if (ec != NULL)\n      {\n        assert (ec->kind == DDSI_EK_PROXY_READER || ec->kind == DDSI_EK_PROXY_WRITER);\n        (*gpe_match_upd)[*n_match_upd + n++] = (struct ddsi_generic_proxy_endpoint *) ec;\n      }\n    }\n  }\n  *n_match_upd += n;\n  ddsi_thread_state_asleep (ddsi_lookup_thread_state ());\n}\ndds_return_t ddsi_xt_type_init_impl (struct ddsi_domaingv *gv, struct xt_type *xt, const struct DDS_XTypes_TypeIdentifier *ti, const struct DDS_XTypes_TypeObject *to)\n{\n  assert (xt);\n  assert (ti);\n  dds_return_t ret = DDS_RETCODE_OK, ret_validate = DDS_RETCODE_OK;\n\n  ddsi_typeid_copy_impl (&xt->id.x, ti);\n  xt->kind = ddsi_typeid_kind_impl (ti);\n  if (ti->_d <= DDS_XTypes_TK_STRING16)\n  {\n    if (to != NULL)\n      return DDS_RETCODE_BAD_PARAMETER;\n    xt->_d = ti->_d;\n  }\n  else\n  {\n    switch (ti->_d)\n    {\n      case DDS_XTypes_TI_STRING8_SMALL:\n        xt->_d = DDS_XTypes_TK_STRING8;\n        xt->_u.str8.bound = (DDS_XTypes_LBound) ti->_u.string_sdefn.bound;\n        break;\n      case DDS_XTypes_TI_STRING8_LARGE:\n        xt->_d = DDS_XTypes_TK_STRING8;\n        xt->_u.str8.bound = ti->_u.string_ldefn.bound;\n        break;\n      case DDS_XTypes_TI_STRING16_SMALL:\n        xt->_d = DDS_XTypes_TK_STRING16;\n        xt->_u.str16.bound = (DDS_XTypes_LBound) ti->_u.string_sdefn.bound;\n        break;\n      case DDS_XTypes_TI_STRING16_LARGE:\n        xt->_d = DDS_XTypes_TK_STRING16;\n        xt->_u.str16.bound = ti->_u.string_ldefn.bound;\n        break;\n      case DDS_XTypes_TI_PLAIN_SEQUENCE_SMALL:\n        xt->_d = DDS_XTypes_TK_SEQUENCE;\n        if ((ret = ddsi_type_register_dep (gv, &xt->id, &xt->_u.seq.c.element_type, ti->_u.seq_sdefn.element_identifier)) != DDS_RETCODE_OK)\n          goto err;\n        xt->_u.seq.bound = (DDS_XTypes_LBound) ti->_u.seq_sdefn.bound;\n        xt_collection_common_init (&xt->_u.seq.c, &ti->_u.seq_sdefn.header);\n        break;\n      case DDS_XTypes_TI_PLAIN_SEQUENCE_LARGE:\n        xt->_d = DDS_XTypes_TK_SEQUENCE;\n        if ((ret = ddsi_type_register_dep (gv, &xt->id, &xt->_u.seq.c.element_type, ti->_u.seq_ldefn.element_identifier)) != DDS_RETCODE_OK)\n          goto err;\n        xt->_u.seq.bound = ti->_u.seq_ldefn.bound;\n        xt_collection_common_init (&xt->_u.seq.c, &ti->_u.seq_ldefn.header);\n        break;\n      case DDS_XTypes_TI_PLAIN_ARRAY_SMALL:\n        xt->_d = DDS_XTypes_TK_ARRAY;\n        if ((ret = ddsi_type_register_dep (gv, &xt->id, &xt->_u.array.c.element_type, ti->_u.array_sdefn.element_identifier)) != DDS_RETCODE_OK)\n          goto err;\n        xt_collection_common_init (&xt->_u.array.c, &ti->_u.array_sdefn.header);\n        xt_sbounds_to_lbounds (&xt->_u.array.bounds, &ti->_u.array_sdefn.array_bound_seq);\n        break;\n      case DDS_XTypes_TI_PLAIN_ARRAY_LARGE:\n        xt->_d = DDS_XTypes_TK_ARRAY;\n        if ((ret = ddsi_type_register_dep (gv, &xt->id, &xt->_u.array.c.element_type, ti->_u.array_ldefn.element_identifier)) != DDS_RETCODE_OK)\n          goto err;\n        xt_collection_common_init (&xt->_u.array.c, &ti->_u.array_ldefn.header);\n        xt_lbounds_dup (&xt->_u.array.bounds, &ti->_u.array_ldefn.array_bound_seq);\n        break;\n      case DDS_XTypes_TI_PLAIN_MAP_SMALL:\n        xt->_d = DDS_XTypes_TK_MAP;\n        if ((ret = ddsi_type_register_dep (gv, &xt->id, &xt->_u.map.c.element_type, ti->_u.map_sdefn.element_identifier)) != DDS_RETCODE_OK)\n          goto err;\n        xt->_u.map.bound = (DDS_XTypes_LBound) ti->_u.map_sdefn.bound;\n        xt_collection_common_init (&xt->_u.map.c, &ti->_u.map_sdefn.header);\n        if ((ret = ddsi_type_register_dep (gv, &xt->id, &xt->_u.map.key_type, ti->_u.map_sdefn.key_identifier)) != DDS_RETCODE_OK)\n        {\n          ddsi_type_unref_locked (gv, xt->_u.map.c.element_type);\n          goto err;\n        }\n        break;\n      case DDS_XTypes_TI_PLAIN_MAP_LARGE:\n        xt->_d = DDS_XTypes_TK_MAP;\n        if ((ret = ddsi_type_register_dep (gv, &xt->id, &xt->_u.map.c.element_type, ti->_u.map_ldefn.element_identifier)) != DDS_RETCODE_OK)\n          goto err;\n        xt->_u.map.bound = (DDS_XTypes_LBound) ti->_u.map_ldefn.bound;\n        xt_collection_common_init (&xt->_u.map.c, &ti->_u.map_ldefn.header);\n        if ((ret = ddsi_type_register_dep (gv, &xt->id, &xt->_u.map.key_type, ti->_u.map_ldefn.key_identifier)) != DDS_RETCODE_OK)\n        {\n          ddsi_type_unref_locked (gv, xt->_u.map.c.element_type);\n          goto err;\n        }\n        break;\n      case DDS_XTypes_EK_MINIMAL:\n        if (to != NULL)\n          ret = add_minimal_typeobj (gv, xt, to);\n        break;\n      case DDS_XTypes_EK_COMPLETE:\n        if (to != NULL)\n          ret = add_complete_typeobj (gv, xt, to);\n        break;\n      case DDS_XTypes_TI_STRONGLY_CONNECTED_COMPONENT:\n        xt->_d = DDS_XTypes_TI_STRONGLY_CONNECTED_COMPONENT;\n        xt->sc_component_id = ti->_u.sc_component_id;\n        break;\n      default:\n        ddsi_typeid_fini (&xt->id);\n        ret = DDS_RETCODE_UNSUPPORTED; /* not supported */\n        break;\n    }\n  }\n  if (ret != DDS_RETCODE_OK || (ret_validate = ddsi_xt_validate (gv, xt)) != DDS_RETCODE_OK)\n  {\n    if (ret == DDS_RETCODE_OK)\n    {\n      ddsi_xt_type_fini (gv, xt, true);\n      ret = ret_validate;\n    }\n    GVWARNING (\"type \" PTYPEIDFMT \": ddsi_xt_type_init_impl with invalid type object\\n\", PTYPEID (xt->id.x));\n  }\nerr:\n  return ret;\n}\n",
    "target": 1,
    "idx": 1056837,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "// context\nint igraph_read_graph_gml(igraph_t *graph, FILE *instream) {\n\n    long int i, p;\n    long int no_of_nodes = 0, no_of_edges = 0;\n    igraph_trie_t trie;\n    igraph_vector_t edges;\n    igraph_bool_t directed = IGRAPH_UNDIRECTED;\n    igraph_gml_tree_t *gtree;\n    long int gidx;\n    igraph_trie_t vattrnames;\n    igraph_trie_t eattrnames;\n    igraph_trie_t gattrnames;\n    igraph_vector_ptr_t gattrs = IGRAPH_VECTOR_PTR_NULL,\n                        vattrs = IGRAPH_VECTOR_PTR_NULL, eattrs = IGRAPH_VECTOR_PTR_NULL;\n    igraph_vector_ptr_t *attrs[3];\n    long int edgeptr = 0;\n    igraph_i_gml_parsedata_t context;\n\n    attrs[0] = &gattrs; attrs[1] = &vattrs; attrs[2] = &eattrs;\n\n    IGRAPH_CHECK(igraph_i_gml_parsedata_init(&context));\n    IGRAPH_FINALLY(igraph_i_gml_parsedata_destroy, &context);\n\n    igraph_gml_yylex_init_extra(&context, &context.scanner);\n\n    igraph_gml_yyset_in(instream, context.scanner);\n\n    i = igraph_gml_yyparse(&context);\n    if (i != 0) {\n        if (context.errmsg[0] != 0) {\n            IGRAPH_ERROR(context.errmsg, IGRAPH_PARSEERROR);\n        } else {\n            IGRAPH_ERROR(\"Cannot read GML file\", IGRAPH_PARSEERROR);\n        }\n    }\n\n    IGRAPH_VECTOR_INIT_FINALLY(&edges, 0);\n\n    /* Check version, if present, integer and not '1' then ignored */\n    i = igraph_gml_tree_find(context.tree, \"Version\", 0);\n    if (i >= 0 &&\n        igraph_gml_tree_type(context.tree, i) == IGRAPH_I_GML_TREE_INTEGER &&\n        igraph_gml_tree_get_integer(context.tree, i) != 1) {\n        igraph_gml_tree_destroy(context.tree);\n        IGRAPH_ERROR(\"Unknown GML version\", IGRAPH_UNIMPLEMENTED);\n        /* RETURN HERE!!!! */\n    }\n\n    /* get the graph */\n    gidx = igraph_gml_tree_find(context.tree, \"graph\", 0);\n    if (gidx == -1) {\n        IGRAPH_ERROR(\"No 'graph' object in GML file\", IGRAPH_PARSEERROR);\n    }\n    if (igraph_gml_tree_type(context.tree, gidx) !=\n        IGRAPH_I_GML_TREE_TREE) {\n        IGRAPH_ERROR(\"Invalid type for 'graph' object in GML file\", IGRAPH_PARSEERROR);\n    }\n    gtree = igraph_gml_tree_get_tree(context.tree, gidx);\n\n    IGRAPH_FINALLY(igraph_i_gml_destroy_attrs, attrs);\n    igraph_vector_ptr_init(&gattrs, 0);\n    igraph_vector_ptr_init(&vattrs, 0);\n    igraph_vector_ptr_init(&eattrs, 0);\n\n    IGRAPH_TRIE_INIT_FINALLY(&trie, 0);\n    IGRAPH_TRIE_INIT_FINALLY(&vattrnames, 0);\n    IGRAPH_TRIE_INIT_FINALLY(&eattrnames, 0);\n    IGRAPH_TRIE_INIT_FINALLY(&gattrnames, 0);\n\n    /* Is is directed? */\n    i = igraph_gml_tree_find(gtree, \"directed\", 0);\n    if (i >= 0 && igraph_gml_tree_type(gtree, i) == IGRAPH_I_GML_TREE_INTEGER) {\n        if (igraph_gml_tree_get_integer(gtree, i) == 1) {\n            directed = IGRAPH_DIRECTED;\n        }\n    }\n\n    /* Now we go over all objects in the graph and collect the attribute names and\n       types. Plus we collect node ids. We also do some checks. */\n    for (i = 0; i < igraph_gml_tree_length(gtree); i++) {\n        long int j;\n        char cname[100];\n        const char *name = igraph_gml_tree_name(gtree, i);\n        if (!strcmp(name, \"node\")) {\n            igraph_gml_tree_t *node;\n            igraph_bool_t hasid;\n            no_of_nodes++;\n            if (igraph_gml_tree_type(gtree, i) != IGRAPH_I_GML_TREE_TREE) {\n                IGRAPH_ERROR(\"'node' is not a list\", IGRAPH_PARSEERROR);\n            }\n            node = igraph_gml_tree_get_tree(gtree, i);\n            hasid = 0;\n            for (j = 0; j < igraph_gml_tree_length(node); j++) {\n                const char *name = igraph_gml_tree_name(node, j);\n                long int trieid, triesize = igraph_trie_size(&vattrnames);\n                IGRAPH_CHECK(igraph_trie_get(&vattrnames, name, &trieid));\n                if (trieid == triesize) {\n                    /* new attribute */\n                    igraph_attribute_record_t *atrec = igraph_Calloc(1, igraph_attribute_record_t);\n                    int type = igraph_gml_tree_type(node, j);\n                    if (!atrec) {\n                        IGRAPH_ERROR(\"Cannot read GML file\", IGRAPH_ENOMEM);\n                    }\n                    IGRAPH_CHECK(igraph_vector_ptr_push_back(&vattrs, atrec));\n                    atrec->name = strdup(name);\n                    if (type == IGRAPH_I_GML_TREE_INTEGER || type == IGRAPH_I_GML_TREE_REAL) {\n                        atrec->type = IGRAPH_ATTRIBUTE_NUMERIC;\n                    } else {\n                        atrec->type = IGRAPH_ATTRIBUTE_STRING;\n                    }\n                } else {\n                    /* already seen, should we update type? */\n                    igraph_attribute_record_t *atrec = VECTOR(vattrs)[trieid];\n                    int type1 = atrec->type;\n                    int type2 = igraph_gml_tree_type(node, j);\n                    if (type1 == IGRAPH_ATTRIBUTE_NUMERIC && type2 == IGRAPH_I_GML_TREE_STRING) {\n                        atrec->type = IGRAPH_ATTRIBUTE_STRING;\n                    }\n                }\n                /* check id */\n                if (!hasid && !strcmp(name, \"id\")) {\n                    long int id;\n                    if (igraph_gml_tree_type(node, j) != IGRAPH_I_GML_TREE_INTEGER) {\n                        IGRAPH_ERROR(\"Non-integer node id in GML file\", IGRAPH_PARSEERROR);\n                    }\n                    id = igraph_gml_tree_get_integer(node, j);\n                    snprintf(cname, sizeof(cname) / sizeof(char) -1, \"%li\", id);\n                    IGRAPH_CHECK(igraph_trie_get(&trie, cname, &id));\n                    hasid = 1;\n                }\n            }\n            if (!hasid) {\n                IGRAPH_ERROR(\"Node without 'id' while parsing GML file\", IGRAPH_PARSEERROR);\n            }\n        } else if (!strcmp(name, \"edge\")) {\n            igraph_gml_tree_t *edge;\n            igraph_bool_t has_source = 0, has_target = 0;\n            no_of_edges++;\n            if (igraph_gml_tree_type(gtree, i) != IGRAPH_I_GML_TREE_TREE) {\n                IGRAPH_ERROR(\"'edge' is not a list\", IGRAPH_PARSEERROR);\n            }\n            edge = igraph_gml_tree_get_tree(gtree, i);\n            has_source = has_target = 0;\n            for (j = 0; j < igraph_gml_tree_length(edge); j++) {\n                const char *name = igraph_gml_tree_name(edge, j);\n                if (!strcmp(name, \"source\")) {\n                    has_source = 1;\n                    if (igraph_gml_tree_type(edge, j) != IGRAPH_I_GML_TREE_INTEGER) {\n                        IGRAPH_ERROR(\"Non-integer 'source' for an edge in GML file\",\n                                     IGRAPH_PARSEERROR);\n                    }\n                } else if (!strcmp(name, \"target\")) {\n                    has_target = 1;\n                    if (igraph_gml_tree_type(edge, j) != IGRAPH_I_GML_TREE_INTEGER) {\n                        IGRAPH_ERROR(\"Non-integer 'source' for an edge in GML file\",\n                                     IGRAPH_PARSEERROR);\n                    }\n                } else {\n                    long int trieid, triesize = igraph_trie_size(&eattrnames);\n                    IGRAPH_CHECK(igraph_trie_get(&eattrnames, name, &trieid));\n                    if (trieid == triesize) {\n                        /* new attribute */\n                        igraph_attribute_record_t *atrec = igraph_Calloc(1, igraph_attribute_record_t);\n                        int type = igraph_gml_tree_type(edge, j);\n                        if (!atrec) {\n                            IGRAPH_ERROR(\"Cannot read GML file\", IGRAPH_ENOMEM);\n                        }\n                        IGRAPH_CHECK(igraph_vector_ptr_push_back(&eattrs, atrec));\n                        atrec->name = strdup(name);\n                        if (type == IGRAPH_I_GML_TREE_INTEGER || type == IGRAPH_I_GML_TREE_REAL) {\n                            atrec->type = IGRAPH_ATTRIBUTE_NUMERIC;\n                        } else {\n                            atrec->type = IGRAPH_ATTRIBUTE_STRING;\n                        }\n                    } else {\n                        /* already seen, should we update type? */\n                        igraph_attribute_record_t *atrec = VECTOR(eattrs)[trieid];\n                        int type1 = atrec->type;\n                        int type2 = igraph_gml_tree_type(edge, j);\n                        if (type1 == IGRAPH_ATTRIBUTE_NUMERIC && type2 == IGRAPH_I_GML_TREE_STRING) {\n                            atrec->type = IGRAPH_ATTRIBUTE_STRING;\n                        }\n                    }\n                }\n            } /* for */\n            if (!has_source) {\n                IGRAPH_ERROR(\"No 'source' for edge in GML file\", IGRAPH_PARSEERROR);\n            }\n            if (!has_target) {\n                IGRAPH_ERROR(\"No 'target' for edge in GML file\", IGRAPH_PARSEERROR);\n            }\n        } else {\n            /* anything to do? Maybe add as graph attribute.... */\n        }\n    }\n\n    /* check vertex id uniqueness */\n    if (igraph_trie_size(&trie) != no_of_nodes) {\n        IGRAPH_ERROR(\"Node 'id' not unique\", IGRAPH_PARSEERROR);\n    }\n\n    /* now we allocate the vectors and strvectors for the attributes */\n    for (i = 0; i < igraph_vector_ptr_size(&vattrs); i++) {\n        igraph_attribute_record_t *atrec = VECTOR(vattrs)[i];\n        int type = atrec->type;\n        if (type == IGRAPH_ATTRIBUTE_NUMERIC) {\n            igraph_vector_t *p = igraph_Calloc(1, igraph_vector_t);\n            atrec->value = p;\n            IGRAPH_CHECK(igraph_vector_init(p, no_of_nodes));\n        } else if (type == IGRAPH_ATTRIBUTE_STRING) {\n            igraph_strvector_t *p = igraph_Calloc(1, igraph_strvector_t);\n            atrec->value = p;\n            IGRAPH_CHECK(igraph_strvector_init(p, no_of_nodes));\n        } else {\n            IGRAPH_WARNING(\"A composite attribute ignored\");\n        }\n    }\n\n    for (i = 0; i < igraph_vector_ptr_size(&eattrs); i++) {\n        igraph_attribute_record_t *atrec = VECTOR(eattrs)[i];\n        int type = atrec->type;\n        if (type == IGRAPH_ATTRIBUTE_NUMERIC) {\n            igraph_vector_t *p = igraph_Calloc(1, igraph_vector_t);\n            atrec->value = p;\n            IGRAPH_CHECK(igraph_vector_init(p, no_of_edges));\n        } else if (type == IGRAPH_ATTRIBUTE_STRING) {\n            igraph_strvector_t *p = igraph_Calloc(1, igraph_strvector_t);\n            atrec->value = p;\n            IGRAPH_CHECK(igraph_strvector_init(p, no_of_edges));\n        } else {\n            IGRAPH_WARNING(\"A composite attribute ignored\");\n        }\n    }\n\n    /* Ok, now the edges, attributes too */\n    IGRAPH_CHECK(igraph_vector_resize(&edges, no_of_edges * 2));\n    p = -1;\n    while ( (p = igraph_gml_tree_find(gtree, \"edge\", p + 1)) != -1) {\n        igraph_gml_tree_t *edge;\n        long int from, to, fromidx = 0, toidx = 0;\n        char name[100];\n        long int j;\n        edge = igraph_gml_tree_get_tree(gtree, p);\n        for (j = 0; j < igraph_gml_tree_length(edge); j++) {\n            const char *n = igraph_gml_tree_name(edge, j);\n            if (!strcmp(n, \"source\")) {\n                fromidx = igraph_gml_tree_find(edge, \"source\", 0);\n            } else if (!strcmp(n, \"target\")) {\n                toidx = igraph_gml_tree_find(edge, \"target\", 0);\n            } else {\n                long int edgeid = edgeptr / 2;\n                long int trieidx;\n                igraph_attribute_record_t *atrec;\n                int type;\n                igraph_trie_get(&eattrnames, n, &trieidx);\n                atrec = VECTOR(eattrs)[trieidx];\n                type = atrec->type;\n                if (type == IGRAPH_ATTRIBUTE_NUMERIC) {\n                    igraph_vector_t *v = (igraph_vector_t *)atrec->value;\n                    IGRAPH_CHECK(igraph_i_gml_toreal(edge, j, VECTOR(*v) + edgeid));\n                } else if (type == IGRAPH_ATTRIBUTE_STRING) {\n                    igraph_strvector_t *v = (igraph_strvector_t *)atrec->value;\n                    const char *value = igraph_i_gml_tostring(edge, j);\n                    IGRAPH_CHECK(igraph_strvector_set(v, edgeid, value));\n                }\n            }\n        }\n        from = igraph_gml_tree_get_integer(edge, fromidx);\n        to = igraph_gml_tree_get_integer(edge, toidx);\n        snprintf(name, sizeof(name) / sizeof(char) -1, \"%li\", from);\n        IGRAPH_CHECK(igraph_trie_get(&trie, name, &from));\n        snprintf(name, sizeof(name) / sizeof(char) -1, \"%li\", to);\n        IGRAPH_CHECK(igraph_trie_get(&trie, name, &to));\n        if (igraph_trie_size(&trie) != no_of_nodes) {\n            IGRAPH_ERROR(\"Unknown node id found at an edge\", IGRAPH_PARSEERROR);\n        }\n        VECTOR(edges)[edgeptr++] = from;\n        VECTOR(edges)[edgeptr++] = to;\n    }\n\n    /* and add vertex attributes */\n    for (i = 0; i < igraph_gml_tree_length(gtree); i++) {\n        const char *n;\n        char name[100];\n        long int j, k;\n        n = igraph_gml_tree_name(gtree, i);\n        if (!strcmp(n, \"node\")) {\n            igraph_gml_tree_t *node = igraph_gml_tree_get_tree(gtree, i);\n            long int iidx = igraph_gml_tree_find(node, \"id\", 0);\n            long int id = igraph_gml_tree_get_integer(node, iidx);\n            snprintf(name, sizeof(name) / sizeof(char) -1, \"%li\", id);\n            igraph_trie_get(&trie, name, &id);\n            for (j = 0; j < igraph_gml_tree_length(node); j++) {\n                const char *aname = igraph_gml_tree_name(node, j);\n                igraph_attribute_record_t *atrec;\n                int type;\n                igraph_trie_get(&vattrnames, aname, &k);\n                atrec = VECTOR(vattrs)[k];\n                type = atrec->type;\n                if (type == IGRAPH_ATTRIBUTE_NUMERIC) {\n                    igraph_vector_t *v = (igraph_vector_t *)atrec->value;\n                    IGRAPH_CHECK(igraph_i_gml_toreal(node, j, VECTOR(*v) + id));\n                } else if (type == IGRAPH_ATTRIBUTE_STRING) {\n                    igraph_strvector_t *v = (igraph_strvector_t *)atrec->value;\n                    const char *value = igraph_i_gml_tostring(node, j);\n                    IGRAPH_CHECK(igraph_strvector_set(v, id, value));\n                }\n            }\n        }\n    }\n\n    igraph_trie_destroy(&trie);\n    igraph_trie_destroy(&gattrnames);\n    igraph_trie_destroy(&vattrnames);\n    igraph_trie_destroy(&eattrnames);\n    IGRAPH_FINALLY_CLEAN(4);\n\n    IGRAPH_CHECK(igraph_empty_attrs(graph, 0, directed, 0)); /* TODO */\n    IGRAPH_CHECK(igraph_add_vertices(graph, (igraph_integer_t) no_of_nodes,\n                                     &vattrs));\n    IGRAPH_CHECK(igraph_add_edges(graph, &edges, &eattrs));\n\n    igraph_i_gml_destroy_attrs(attrs);\n    igraph_vector_destroy(&edges);\n    igraph_i_gml_parsedata_destroy(&context);\n    IGRAPH_FINALLY_CLEAN(3);\n\n    return 0;\n}\n\n\n// target function\nstatic igraph_real_t igraph_i_gml_toreal(igraph_gml_tree_t *node, long int pos) {\n\n    igraph_real_t value = 0.0;\n    int type = igraph_gml_tree_type(node, pos);\n\n    switch (type) {\n    case IGRAPH_I_GML_TREE_INTEGER:\n        value = igraph_gml_tree_get_integer(node, pos);\n        break;\n    case IGRAPH_I_GML_TREE_REAL:\n        value = igraph_gml_tree_get_real(node, pos);\n        break;\n    default:\n        IGRAPH_ERROR(\"Internal error while parsing GML file\", IGRAPH_FAILURE);\n        break;\n    }\n\n    return value;\n}\nint igraph_read_graph_gml(igraph_t *graph, FILE *instream) {\n\n    long int i, p;\n    long int no_of_nodes = 0, no_of_edges = 0;\n    igraph_trie_t trie;\n    igraph_vector_t edges;\n    igraph_bool_t directed = IGRAPH_UNDIRECTED;\n    igraph_gml_tree_t *gtree;\n    long int gidx;\n    igraph_trie_t vattrnames;\n    igraph_trie_t eattrnames;\n    igraph_trie_t gattrnames;\n    igraph_vector_ptr_t gattrs = IGRAPH_VECTOR_PTR_NULL,\n                        vattrs = IGRAPH_VECTOR_PTR_NULL, eattrs = IGRAPH_VECTOR_PTR_NULL;\n    igraph_vector_ptr_t *attrs[3];\n    long int edgeptr = 0;\n    igraph_i_gml_parsedata_t context;\n\n    attrs[0] = &gattrs; attrs[1] = &vattrs; attrs[2] = &eattrs;\n\n    IGRAPH_CHECK(igraph_i_gml_parsedata_init(&context));\n    IGRAPH_FINALLY(igraph_i_gml_parsedata_destroy, &context);\n\n    igraph_gml_yylex_init_extra(&context, &context.scanner);\n\n    igraph_gml_yyset_in(instream, context.scanner);\n\n    i = igraph_gml_yyparse(&context);\n    if (i != 0) {\n        if (context.errmsg[0] != 0) {\n            IGRAPH_ERROR(context.errmsg, IGRAPH_PARSEERROR);\n        } else {\n            IGRAPH_ERROR(\"Cannot read GML file\", IGRAPH_PARSEERROR);\n        }\n    }\n\n    IGRAPH_VECTOR_INIT_FINALLY(&edges, 0);\n\n    /* Check version, if present, integer and not '1' then ignored */\n    i = igraph_gml_tree_find(context.tree, \"Version\", 0);\n    if (i >= 0 &&\n        igraph_gml_tree_type(context.tree, i) == IGRAPH_I_GML_TREE_INTEGER &&\n        igraph_gml_tree_get_integer(context.tree, i) != 1) {\n        igraph_gml_tree_destroy(context.tree);\n        IGRAPH_ERROR(\"Unknown GML version\", IGRAPH_UNIMPLEMENTED);\n        /* RETURN HERE!!!! */\n    }\n\n    /* get the graph */\n    gidx = igraph_gml_tree_find(context.tree, \"graph\", 0);\n    if (gidx == -1) {\n        IGRAPH_ERROR(\"No 'graph' object in GML file\", IGRAPH_PARSEERROR);\n    }\n    if (igraph_gml_tree_type(context.tree, gidx) !=\n        IGRAPH_I_GML_TREE_TREE) {\n        IGRAPH_ERROR(\"Invalid type for 'graph' object in GML file\", IGRAPH_PARSEERROR);\n    }\n    gtree = igraph_gml_tree_get_tree(context.tree, gidx);\n\n    IGRAPH_FINALLY(igraph_i_gml_destroy_attrs, attrs);\n    igraph_vector_ptr_init(&gattrs, 0);\n    igraph_vector_ptr_init(&vattrs, 0);\n    igraph_vector_ptr_init(&eattrs, 0);\n\n    IGRAPH_TRIE_INIT_FINALLY(&trie, 0);\n    IGRAPH_TRIE_INIT_FINALLY(&vattrnames, 0);\n    IGRAPH_TRIE_INIT_FINALLY(&eattrnames, 0);\n    IGRAPH_TRIE_INIT_FINALLY(&gattrnames, 0);\n\n    /* Is is directed? */\n    i = igraph_gml_tree_find(gtree, \"directed\", 0);\n    if (i >= 0 && igraph_gml_tree_type(gtree, i) == IGRAPH_I_GML_TREE_INTEGER) {\n        if (igraph_gml_tree_get_integer(gtree, i) == 1) {\n            directed = IGRAPH_DIRECTED;\n        }\n    }\n\n    /* Now we go over all objects in the graph and collect the attribute names and\n       types. Plus we collect node ids. We also do some checks. */\n    for (i = 0; i < igraph_gml_tree_length(gtree); i++) {\n        long int j;\n        char cname[100];\n        const char *name = igraph_gml_tree_name(gtree, i);\n        if (!strcmp(name, \"node\")) {\n            igraph_gml_tree_t *node;\n            igraph_bool_t hasid;\n            no_of_nodes++;\n            if (igraph_gml_tree_type(gtree, i) != IGRAPH_I_GML_TREE_TREE) {\n                IGRAPH_ERROR(\"'node' is not a list\", IGRAPH_PARSEERROR);\n            }\n            node = igraph_gml_tree_get_tree(gtree, i);\n            hasid = 0;\n            for (j = 0; j < igraph_gml_tree_length(node); j++) {\n                const char *name = igraph_gml_tree_name(node, j);\n                long int trieid, triesize = igraph_trie_size(&vattrnames);\n                IGRAPH_CHECK(igraph_trie_get(&vattrnames, name, &trieid));\n                if (trieid == triesize) {\n                    /* new attribute */\n                    igraph_attribute_record_t *atrec = igraph_Calloc(1, igraph_attribute_record_t);\n                    int type = igraph_gml_tree_type(node, j);\n                    if (!atrec) {\n                        IGRAPH_ERROR(\"Cannot read GML file\", IGRAPH_ENOMEM);\n                    }\n                    IGRAPH_CHECK(igraph_vector_ptr_push_back(&vattrs, atrec));\n                    atrec->name = strdup(name);\n                    if (type == IGRAPH_I_GML_TREE_INTEGER || type == IGRAPH_I_GML_TREE_REAL) {\n                        atrec->type = IGRAPH_ATTRIBUTE_NUMERIC;\n                    } else {\n                        atrec->type = IGRAPH_ATTRIBUTE_STRING;\n                    }\n                } else {\n                    /* already seen, should we update type? */\n                    igraph_attribute_record_t *atrec = VECTOR(vattrs)[trieid];\n                    int type1 = atrec->type;\n                    int type2 = igraph_gml_tree_type(node, j);\n                    if (type1 == IGRAPH_ATTRIBUTE_NUMERIC && type2 == IGRAPH_I_GML_TREE_STRING) {\n                        atrec->type = IGRAPH_ATTRIBUTE_STRING;\n                    }\n                }\n                /* check id */\n                if (!hasid && !strcmp(name, \"id\")) {\n                    long int id;\n                    if (igraph_gml_tree_type(node, j) != IGRAPH_I_GML_TREE_INTEGER) {\n                        IGRAPH_ERROR(\"Non-integer node id in GML file\", IGRAPH_PARSEERROR);\n                    }\n                    id = igraph_gml_tree_get_integer(node, j);\n                    snprintf(cname, sizeof(cname) / sizeof(char) -1, \"%li\", id);\n                    IGRAPH_CHECK(igraph_trie_get(&trie, cname, &id));\n                    hasid = 1;\n                }\n            }\n            if (!hasid) {\n                IGRAPH_ERROR(\"Node without 'id' while parsing GML file\", IGRAPH_PARSEERROR);\n            }\n        } else if (!strcmp(name, \"edge\")) {\n            igraph_gml_tree_t *edge;\n            igraph_bool_t has_source = 0, has_target = 0;\n            no_of_edges++;\n            if (igraph_gml_tree_type(gtree, i) != IGRAPH_I_GML_TREE_TREE) {\n                IGRAPH_ERROR(\"'edge' is not a list\", IGRAPH_PARSEERROR);\n            }\n            edge = igraph_gml_tree_get_tree(gtree, i);\n            has_source = has_target = 0;\n            for (j = 0; j < igraph_gml_tree_length(edge); j++) {\n                const char *name = igraph_gml_tree_name(edge, j);\n                if (!strcmp(name, \"source\")) {\n                    has_source = 1;\n                    if (igraph_gml_tree_type(edge, j) != IGRAPH_I_GML_TREE_INTEGER) {\n                        IGRAPH_ERROR(\"Non-integer 'source' for an edge in GML file\",\n                                     IGRAPH_PARSEERROR);\n                    }\n                } else if (!strcmp(name, \"target\")) {\n                    has_target = 1;\n                    if (igraph_gml_tree_type(edge, j) != IGRAPH_I_GML_TREE_INTEGER) {\n                        IGRAPH_ERROR(\"Non-integer 'source' for an edge in GML file\",\n                                     IGRAPH_PARSEERROR);\n                    }\n                } else {\n                    long int trieid, triesize = igraph_trie_size(&eattrnames);\n                    IGRAPH_CHECK(igraph_trie_get(&eattrnames, name, &trieid));\n                    if (trieid == triesize) {\n                        /* new attribute */\n                        igraph_attribute_record_t *atrec = igraph_Calloc(1, igraph_attribute_record_t);\n                        int type = igraph_gml_tree_type(edge, j);\n                        if (!atrec) {\n                            IGRAPH_ERROR(\"Cannot read GML file\", IGRAPH_ENOMEM);\n                        }\n                        IGRAPH_CHECK(igraph_vector_ptr_push_back(&eattrs, atrec));\n                        atrec->name = strdup(name);\n                        if (type == IGRAPH_I_GML_TREE_INTEGER || type == IGRAPH_I_GML_TREE_REAL) {\n                            atrec->type = IGRAPH_ATTRIBUTE_NUMERIC;\n                        } else {\n                            atrec->type = IGRAPH_ATTRIBUTE_STRING;\n                        }\n                    } else {\n                        /* already seen, should we update type? */\n                        igraph_attribute_record_t *atrec = VECTOR(eattrs)[trieid];\n                        int type1 = atrec->type;\n                        int type2 = igraph_gml_tree_type(edge, j);\n                        if (type1 == IGRAPH_ATTRIBUTE_NUMERIC && type2 == IGRAPH_I_GML_TREE_STRING) {\n                            atrec->type = IGRAPH_ATTRIBUTE_STRING;\n                        }\n                    }\n                }\n            } /* for */\n            if (!has_source) {\n                IGRAPH_ERROR(\"No 'source' for edge in GML file\", IGRAPH_PARSEERROR);\n            }\n            if (!has_target) {\n                IGRAPH_ERROR(\"No 'target' for edge in GML file\", IGRAPH_PARSEERROR);\n            }\n        } else {\n            /* anything to do? Maybe add as graph attribute.... */\n        }\n    }\n\n    /* check vertex id uniqueness */\n    if (igraph_trie_size(&trie) != no_of_nodes) {\n        IGRAPH_ERROR(\"Node 'id' not unique\", IGRAPH_PARSEERROR);\n    }\n\n    /* now we allocate the vectors and strvectors for the attributes */\n    for (i = 0; i < igraph_vector_ptr_size(&vattrs); i++) {\n        igraph_attribute_record_t *atrec = VECTOR(vattrs)[i];\n        int type = atrec->type;\n        if (type == IGRAPH_ATTRIBUTE_NUMERIC) {\n            igraph_vector_t *p = igraph_Calloc(1, igraph_vector_t);\n            atrec->value = p;\n            IGRAPH_CHECK(igraph_vector_init(p, no_of_nodes));\n        } else if (type == IGRAPH_ATTRIBUTE_STRING) {\n            igraph_strvector_t *p = igraph_Calloc(1, igraph_strvector_t);\n            atrec->value = p;\n            IGRAPH_CHECK(igraph_strvector_init(p, no_of_nodes));\n        } else {\n            IGRAPH_WARNING(\"A composite attribute ignored\");\n        }\n    }\n\n    for (i = 0; i < igraph_vector_ptr_size(&eattrs); i++) {\n        igraph_attribute_record_t *atrec = VECTOR(eattrs)[i];\n        int type = atrec->type;\n        if (type == IGRAPH_ATTRIBUTE_NUMERIC) {\n            igraph_vector_t *p = igraph_Calloc(1, igraph_vector_t);\n            atrec->value = p;\n            IGRAPH_CHECK(igraph_vector_init(p, no_of_edges));\n        } else if (type == IGRAPH_ATTRIBUTE_STRING) {\n            igraph_strvector_t *p = igraph_Calloc(1, igraph_strvector_t);\n            atrec->value = p;\n            IGRAPH_CHECK(igraph_strvector_init(p, no_of_edges));\n        } else {\n            IGRAPH_WARNING(\"A composite attribute ignored\");\n        }\n    }\n\n    /* Ok, now the edges, attributes too */\n    IGRAPH_CHECK(igraph_vector_resize(&edges, no_of_edges * 2));\n    p = -1;\n    while ( (p = igraph_gml_tree_find(gtree, \"edge\", p + 1)) != -1) {\n        igraph_gml_tree_t *edge;\n        long int from, to, fromidx = 0, toidx = 0;\n        char name[100];\n        long int j;\n        edge = igraph_gml_tree_get_tree(gtree, p);\n        for (j = 0; j < igraph_gml_tree_length(edge); j++) {\n            const char *n = igraph_gml_tree_name(edge, j);\n            if (!strcmp(n, \"source\")) {\n                fromidx = igraph_gml_tree_find(edge, \"source\", 0);\n            } else if (!strcmp(n, \"target\")) {\n                toidx = igraph_gml_tree_find(edge, \"target\", 0);\n            } else {\n                long int edgeid = edgeptr / 2;\n                long int trieidx;\n                igraph_attribute_record_t *atrec;\n                int type;\n                igraph_trie_get(&eattrnames, n, &trieidx);\n                atrec = VECTOR(eattrs)[trieidx];\n                type = atrec->type;\n                if (type == IGRAPH_ATTRIBUTE_NUMERIC) {\n                    igraph_vector_t *v = (igraph_vector_t *)atrec->value;\n                    VECTOR(*v)[edgeid] = igraph_i_gml_toreal(edge, j);\n                } else if (type == IGRAPH_ATTRIBUTE_STRING) {\n                    igraph_strvector_t *v = (igraph_strvector_t *)atrec->value;\n                    const char *value = igraph_i_gml_tostring(edge, j);\n                    IGRAPH_CHECK(igraph_strvector_set(v, edgeid, value));\n                }\n            }\n        }\n        from = igraph_gml_tree_get_integer(edge, fromidx);\n        to = igraph_gml_tree_get_integer(edge, toidx);\n        snprintf(name, sizeof(name) / sizeof(char) -1, \"%li\", from);\n        IGRAPH_CHECK(igraph_trie_get(&trie, name, &from));\n        snprintf(name, sizeof(name) / sizeof(char) -1, \"%li\", to);\n        IGRAPH_CHECK(igraph_trie_get(&trie, name, &to));\n        if (igraph_trie_size(&trie) != no_of_nodes) {\n            IGRAPH_ERROR(\"Unknown node id found at an edge\", IGRAPH_PARSEERROR);\n        }\n        VECTOR(edges)[edgeptr++] = from;\n        VECTOR(edges)[edgeptr++] = to;\n    }\n\n    /* and add vertex attributes */\n    for (i = 0; i < igraph_gml_tree_length(gtree); i++) {\n        const char *n;\n        char name[100];\n        long int j, k;\n        n = igraph_gml_tree_name(gtree, i);\n        if (!strcmp(n, \"node\")) {\n            igraph_gml_tree_t *node = igraph_gml_tree_get_tree(gtree, i);\n            long int iidx = igraph_gml_tree_find(node, \"id\", 0);\n            long int id = igraph_gml_tree_get_integer(node, iidx);\n            snprintf(name, sizeof(name) / sizeof(char) -1, \"%li\", id);\n            igraph_trie_get(&trie, name, &id);\n            for (j = 0; j < igraph_gml_tree_length(node); j++) {\n                const char *aname = igraph_gml_tree_name(node, j);\n                igraph_attribute_record_t *atrec;\n                int type;\n                igraph_trie_get(&vattrnames, aname, &k);\n                atrec = VECTOR(vattrs)[k];\n                type = atrec->type;\n                if (type == IGRAPH_ATTRIBUTE_NUMERIC) {\n                    igraph_vector_t *v = (igraph_vector_t *)atrec->value;\n                    VECTOR(*v)[id] = igraph_i_gml_toreal(node, j);\n                } else if (type == IGRAPH_ATTRIBUTE_STRING) {\n                    igraph_strvector_t *v = (igraph_strvector_t *)atrec->value;\n                    const char *value = igraph_i_gml_tostring(node, j);\n                    IGRAPH_CHECK(igraph_strvector_set(v, id, value));\n                }\n            }\n        }\n    }\n\n    igraph_trie_destroy(&trie);\n    igraph_trie_destroy(&gattrnames);\n    igraph_trie_destroy(&vattrnames);\n    igraph_trie_destroy(&eattrnames);\n    IGRAPH_FINALLY_CLEAN(4);\n\n    IGRAPH_CHECK(igraph_empty_attrs(graph, 0, directed, 0)); /* TODO */\n    IGRAPH_CHECK(igraph_add_vertices(graph, (igraph_integer_t) no_of_nodes,\n                                     &vattrs));\n    IGRAPH_CHECK(igraph_add_edges(graph, &edges, &eattrs));\n\n    igraph_i_gml_destroy_attrs(attrs);\n    igraph_vector_destroy(&edges);\n    igraph_i_gml_parsedata_destroy(&context);\n    IGRAPH_FINALLY_CLEAN(3);\n\n    return 0;\n}\nint main(int argc, char* argv[]) {\n    int index = 0;\n\n    /* We do not care about errors; all we care about is that the library\n     * should not segfault and should not accept invalid input either */\n    igraph_set_error_handler(igraph_error_handler_ignore);\n\n    RUN_TEST(\"invalid1.gml\");\n    RUN_TEST(\"invalid2.gml\");\n\n    return 0;\n}\n",
    "target": 1,
    "idx": 1029377,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "void SdrPowerPointImport::ImportPage( SdrPage* pRet, const PptSlidePersistEntry* pMasterPersist )\n{\n    sal_uInt32 nMerk = rStCtrl.Tell();\n    PptSlidePersistList* pList = GetPageList( eAktPageKind );\n    if ( ( !pList ) || ( pList->size() <= nAktPageNum ) )\n        return;\n    PptSlidePersistEntry& rSlidePersist = (*pList)[ nAktPageNum ];\n    if ( rSlidePersist.bStarDrawFiller )\n        return;\n\n    DffRecordHeader aPageHd;\n    if ( SeekToAktPage( &aPageHd ) )\n    {\n        rSlidePersist.pHeaderFooterEntry = new HeaderFooterEntry( pMasterPersist );\n        ProcessData aProcessData( rSlidePersist, SdPageCapsule(pRet) );\n        auto nEndRecPos = SanitizeEndPos(rStCtrl, aPageHd.GetRecEndFilePos());\n        while ( ( rStCtrl.GetError() == 0 ) && ( rStCtrl.Tell() < nEndRecPos ) )\n        {\n            DffRecordHeader aHd;\n            ReadDffRecordHeader( rStCtrl, aHd );\n            switch ( aHd.nRecType )\n            {\n                case PPT_PST_HeadersFooters :\n                {\n                    ImportHeaderFooterContainer( aHd, *rSlidePersist.pHeaderFooterEntry );\n                }\n                break;\n\n                case PPT_PST_ProgTags :\n                {\n                    DffRecordHeader aContentDataHd;\n                    if ( SeekToContentOfProgTag( 10, rStCtrl, aHd, aContentDataHd ) )\n                    {\n                        DffRecordHeader aComment10Hd;\n                        while( ( rStCtrl.GetError() == 0 ) && SeekToRec( rStCtrl, PPT_PST_Comment10, aContentDataHd.GetRecEndFilePos(), &aComment10Hd ) )\n                        {\n                            ImportComment10( *this, rStCtrl, pRet, aComment10Hd );\n                            if (!aComment10Hd.SeekToEndOfRecord(rStCtrl))\n                                break;\n                        }\n                    }\n                }\n                break;\n\n                case PPT_PST_PPDrawing :\n                {\n                    DffRecordHeader aPPDrawHd;\n                    if ( SeekToRec( rStCtrl, DFF_msofbtDgContainer, aHd.GetRecEndFilePos(), &aPPDrawHd ) )\n                    {\n                        sal_uInt32 nPPDrawOfs = rStCtrl.Tell();\n\n                        // importing the background object before importing the page\n                        auto nPPEndRecPos = SanitizeEndPos(rStCtrl, aPPDrawHd.GetRecEndFilePos());\n                        while ( ( rStCtrl.GetError() == 0 ) && ( rStCtrl.Tell() < nPPEndRecPos ) )\n                        {\n                            DffRecordHeader aEscherObjListHd;\n                            ReadDffRecordHeader( rStCtrl, aEscherObjListHd );\n                            switch ( aEscherObjListHd.nRecType )\n                            {\n                                case DFF_msofbtSpContainer :\n                                {\n                                    tools::Rectangle aPageSize( Point(), pRet->GetSize() );\n                                    if ( rSlidePersist.aSlideAtom.nFlags & 4 )          // follow master background?\n                                    {\n                                        if ( HasMasterPage( nAktPageNum, eAktPageKind ) )\n                                        {\n                                            sal_uInt16 nMasterNum = GetMasterPageIndex( nAktPageNum, eAktPageKind );\n                                            PptSlidePersistList* pPageList = GetPageList( PPT_MASTERPAGE );\n                                            PptSlidePersistEntry* pE = &(*pPageList)[ nMasterNum ];\n                                            while( ( pE->aSlideAtom.nFlags & 4 ) && pE->aSlideAtom.nMasterId )\n                                            {\n                                                auto nOrigMasterId = pE->aSlideAtom.nMasterId;\n                                                sal_uInt16 nNextMaster = m_pMasterPages->FindPage(nOrigMasterId);\n                                                if ( nNextMaster == PPTSLIDEPERSIST_ENTRY_NOTFOUND )\n                                                    break;\n                                                else\n                                                    pE = &(*pPageList)[ nNextMaster ];\n                                                if (pE->aSlideAtom.nMasterId == nOrigMasterId)\n                                                {\n                                                    SAL_WARN(\"filter.ms\", \"loop in atom chain\");\n                                                    break;\n                                                }\n                                            }\n                                            if ( pE->nBackgroundOffset )\n                                            {\n                                                // do not follow master colorscheme?\n                                                bool bTemporary = ( rSlidePersist.aSlideAtom.nFlags & 2 ) != 0;\n                                                sal_uInt32 nPos = rStCtrl.Tell();\n                                                rStCtrl.Seek( pE->nBackgroundOffset );\n                                                rSlidePersist.pBObj = ImportObj( rStCtrl, static_cast<void*>(&aProcessData), aPageSize, aPageSize );\n                                                rSlidePersist.bBObjIsTemporary = bTemporary;\n                                                rStCtrl.Seek( nPos );\n                                            }\n                                        }\n                                    }\n                                    else\n                                    {\n                                        DffRecordHeader aShapeHd;\n                                        ReadDffRecordHeader( rStCtrl, aShapeHd );\n                                        if ( aShapeHd.nRecType == DFF_msofbtSp )\n                                        {\n                                            sal_uInt32 nSpFlags;\n                                            rStCtrl.ReadUInt32( nSpFlags ).ReadUInt32( nSpFlags );\n                                            if ( nSpFlags & SP_FBACKGROUND )\n                                            {\n                                                aEscherObjListHd.SeekToBegOfRecord( rStCtrl );\n                                                rSlidePersist.pBObj = ImportObj( rStCtrl, static_cast<void*>(&aProcessData), aPageSize, aPageSize );\n                                                rSlidePersist.bBObjIsTemporary = false;\n                                            }\n                                        }\n                                    }\n                                }\n                                break;\n                            }\n                            if ( aEscherObjListHd.nRecType == DFF_msofbtSpContainer )\n                                break;\n                            if (!aEscherObjListHd.SeekToEndOfRecord(rStCtrl))\n                                break;\n                        }\n\n                        // now importing page\n                        rStCtrl.Seek( nPPDrawOfs );\n                        auto nHdEndRecPos = SanitizeEndPos(rStCtrl, aPPDrawHd.GetRecEndFilePos());\n                        while ( ( rStCtrl.GetError() == 0 ) && ( rStCtrl.Tell() < nHdEndRecPos ) )\n                        {\n                            DffRecordHeader aEscherObjListHd;\n                            ReadDffRecordHeader( rStCtrl, aEscherObjListHd );\n                            switch ( aEscherObjListHd.nRecType )\n                            {\n                                case DFF_msofbtSpgrContainer :\n                                {\n                                    DffRecordHeader aShapeHd;\n                                    if ( SeekToRec( rStCtrl, DFF_msofbtSpContainer, aEscherObjListHd.GetRecEndFilePos(), &aShapeHd ) )\n                                    {\n                                        aShapeHd.SeekToEndOfRecord( rStCtrl );\n                                        auto nListEndRecPos = SanitizeEndPos(rStCtrl, aEscherObjListHd.GetRecEndFilePos());\n                                        while ( ( rStCtrl.GetError() == 0 ) && ( rStCtrl.Tell() < nListEndRecPos ) )\n                                        {\n                                            ReadDffRecordHeader( rStCtrl, aShapeHd );\n                                            if ( ( aShapeHd.nRecType == DFF_msofbtSpContainer ) || ( aShapeHd.nRecType == DFF_msofbtSpgrContainer ) )\n                                            {\n                                                tools::Rectangle aEmpty;\n                                                aShapeHd.SeekToBegOfRecord( rStCtrl );\n                                                sal_Int32 nShapeId;\n                                                aProcessData.pTableRowProperties.reset();\n                                                SdrObject* pObj = ImportObj( rStCtrl, static_cast<void*>(&aProcessData), aEmpty, aEmpty, 0, &nShapeId );\n                                                if ( pObj )\n                                                {\n                                                    if ( aProcessData.pTableRowProperties )\n                                                        pObj = CreateTable( pObj, aProcessData.pTableRowProperties.get(), aProcessData.rPersistEntry.pSolverContainer );\n\n                                                    pRet->NbcInsertObject( pObj );\n\n                                                    if( nShapeId )\n                                                        insertShapeId( nShapeId, pObj );\n                                                }\n                                            }\n                                            bool bSuccess = aShapeHd.SeekToEndOfRecord(rStCtrl);\n                                            if (!bSuccess)\n                                                break;\n                                        }\n                                    }\n                                }\n                                break;\n                            }\n                            if ( aEscherObjListHd.nRecType == DFF_msofbtSpgrContainer )\n                                break;\n                            if (!aEscherObjListHd.SeekToEndOfRecord(rStCtrl))\n                                break;\n                        }\n\n                        // Handle shapes where the fill matches the background\n                        // fill (mso_fillBackground).\n                        if (rSlidePersist.ePageKind == PPT_SLIDEPAGE)\n                        {\n                            if (!aProcessData.aBackgroundColoredObjects.empty())\n                            {\n                                if (!rSlidePersist.pBObj)\n                                {\n                                    for (auto pObject : aProcessData.aBackgroundColoredObjects)\n                                    {\n                                        // The shape wants a background, but the slide doesn't have\n                                        // one: default to white.\n                                        SfxItemSet aNewSet(*pObject->GetMergedItemSet().GetPool());\n                                        aNewSet.Put(XFillStyleItem(css::drawing::FillStyle_SOLID));\n                                        aNewSet.Put(XFillColorItem(OUString(), Color(COL_WHITE)));\n                                        pObject->SetMergedItemSet(aNewSet);\n                                    }\n                                }\n                            }\n                        }\n\n                        if ( rSlidePersist.pBObj )\n                        {\n                            // #i99386# transfer the attributes from the temporary BackgroundObject\n                            // to the Page and delete it. Maybe rSlidePersist.bBObjIsTemporary is\n                            // obsolete here, too.\n                            pRet->getSdrPageProperties().ClearItem();\n                            pRet->getSdrPageProperties().PutItemSet(rSlidePersist.pBObj->GetMergedItemSet());\n                            if (rSlidePersist.pSolverContainer)\n                            {\n                                for (SvxMSDffConnectorRule* pPtr : rSlidePersist.pSolverContainer->aCList)\n                                {\n                                    // check connections to the group object\n                                    if (pPtr->pAObj == rSlidePersist.pBObj)\n                                        pPtr->pAObj = nullptr;\n                                    if (pPtr->pBObj == rSlidePersist.pBObj)\n                                        pPtr->pBObj = nullptr;\n                                }\n                            }\n                            SdrObject::Free(rSlidePersist.pBObj);\n                        }\n                    }\n                }\n                break;\n            }\n            if (!aHd.SeekToEndOfRecord(rStCtrl))\n                break;\n        }\n        if ( rSlidePersist.pSolverContainer )\n            SolveSolver( *rSlidePersist.pSolverContainer );\n    }\n    rStCtrl.Seek( nMerk );\n}\n",
    "target": 0,
    "idx": 2000888
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "  ~Arena() {\n    for (std::vector<uint8_t*>::iterator\n         i = hunks_.begin(); i != hunks_.end(); ++i) {\n      delete[] *i;\n    }\n  }\nbool GetTableData(const uint8_t *data,\n                  const ots::TableEntry& table,\n                  ots::Arena &arena,\n                  size_t *table_length,\n                  const uint8_t **table_data) {\n  if (table.uncompressed_length != table.length) {\n    // Compressed table. Need to uncompress into memory first.\n    *table_length = table.uncompressed_length;\n    *table_data = arena.Allocate(*table_length);\n    uLongf dest_len = *table_length;\n    int r = uncompress((Bytef*) *table_data, &dest_len,\n                       data + table.offset, table.length);\n    if (r != Z_OK || dest_len != *table_length) {\n      return false;\n    }\n  } else {\n    // Uncompressed table. We can process directly from memory.\n    *table_data = data + table.offset;\n    *table_length = table.length;\n  }\n\n  return true;\n}\nbool ProcessGeneric(ots::FontFile *header,\n                    ots::Font *font,\n                    uint32_t signature,\n                    ots::OTSStream *output,\n                    const uint8_t *data, size_t length,\n                    const std::vector<ots::TableEntry>& tables,\n                    ots::Buffer& file) {\n  const size_t data_offset = file.offset();\n\n  uint32_t uncompressed_sum = 0;\n\n  for (unsigned i = 0; i < font->num_tables; ++i) {\n    // the tables must be sorted by tag (when taken as big-endian numbers).\n    // This also remove the possibility of duplicate tables.\n    if (i) {\n      const uint32_t this_tag = tables[i].tag;\n      const uint32_t prev_tag = tables[i - 1].tag;\n      if (this_tag <= prev_tag) {\n        OTS_WARNING_MSG_HDR(\"Table directory is not correctly ordered\");\n      }\n    }\n\n    // all tag names must be built from printable ASCII characters\n    if (!CheckTag(tables[i].tag)) {\n      return OTS_FAILURE_MSG_TAG(\"invalid table tag\", tables[i].tag);\n    }\n\n    // tables must be 4-byte aligned\n    if (tables[i].offset & 3) {\n      return OTS_FAILURE_MSG_TAG(\"misaligned table\", tables[i].tag);\n    }\n\n    // and must be within the file\n    if (tables[i].offset < data_offset || tables[i].offset >= length) {\n      return OTS_FAILURE_MSG_TAG(\"invalid table offset\", tables[i].tag);\n    }\n    // disallow all tables with a zero length\n    if (tables[i].length < 1) {\n      // Note: malayalam.ttf has zero length CVT table...\n      return OTS_FAILURE_MSG_TAG(\"zero-length table\", tables[i].tag);\n    }\n    // disallow all tables with a length > 1GB\n    if (tables[i].length > 1024 * 1024 * 1024) {\n      return OTS_FAILURE_MSG_TAG(\"table length exceeds 1GB\", tables[i].tag);\n    }\n    // disallow tables where the uncompressed size is < the compressed size.\n    if (tables[i].uncompressed_length < tables[i].length) {\n      return OTS_FAILURE_MSG_TAG(\"invalid compressed table\", tables[i].tag);\n    }\n    if (tables[i].uncompressed_length > tables[i].length) {\n      // We'll probably be decompressing this table.\n\n      // disallow all tables which uncompress to > 30 MB\n      if (tables[i].uncompressed_length > 30 * 1024 * 1024) {\n        return OTS_FAILURE_MSG_TAG(\"uncompressed length exceeds 30MB\", tables[i].tag);\n      }\n      if (uncompressed_sum + tables[i].uncompressed_length < uncompressed_sum) {\n        return OTS_FAILURE_MSG_TAG(\"overflow of uncompressed sum\", tables[i].tag);\n      }\n\n      uncompressed_sum += tables[i].uncompressed_length;\n    }\n    // since we required that the file be < 1GB in length, and that the table\n    // length is < 1GB, the following addtion doesn't overflow\n    uint32_t end_byte = tables[i].offset + tables[i].length;\n    // Tables in the WOFF file must be aligned 4-byte boundary.\n    if (signature == OTS_TAG('w','O','F','F')) {\n        end_byte = ots::Round4(end_byte);\n    }\n    if (!end_byte || end_byte > length) {\n      return OTS_FAILURE_MSG_TAG(\"table overruns end of file\", tables[i].tag);\n    }\n  }\n\n  // All decompressed tables uncompressed must be <= 30MB.\n  if (uncompressed_sum > 30 * 1024 * 1024) {\n    return OTS_FAILURE_MSG_HDR(\"uncompressed sum exceeds 30MB\");\n  }\n\n  // check that the tables are not overlapping.\n  std::vector<std::pair<uint32_t, uint8_t> > overlap_checker;\n  for (unsigned i = 0; i < font->num_tables; ++i) {\n    overlap_checker.push_back(\n        std::make_pair(tables[i].offset, static_cast<uint8_t>(1) /* start */));\n    overlap_checker.push_back(\n        std::make_pair(tables[i].offset + tables[i].length,\n                       static_cast<uint8_t>(0) /* end */));\n  }\n  std::sort(overlap_checker.begin(), overlap_checker.end());\n  int overlap_count = 0;\n  for (unsigned i = 0; i < overlap_checker.size(); ++i) {\n    overlap_count += (overlap_checker[i].second ? 1 : -1);\n    if (overlap_count > 1) {\n      return OTS_FAILURE_MSG_HDR(\"overlapping tables\");\n    }\n  }\n\n  std::map<uint32_t, ots::TableEntry> table_map;\n  for (unsigned i = 0; i < font->num_tables; ++i) {\n    table_map[tables[i].tag] = tables[i];\n  }\n\n  ots::Arena arena;\n  // Parse known tables first as we need to parse them in specific order.\n  for (unsigned i = 0; ; ++i) {\n    if (supported_tables[i].tag == 0) break;\n\n    uint32_t tag = supported_tables[i].tag;\n    const auto &it = table_map.find(tag);\n    if (it == table_map.cend()) {\n      if (supported_tables[i].required) {\n        return OTS_FAILURE_MSG_TAG(\"missing required table\", tag);\n      }\n    } else {\n      if (!font->ParseTable(it->second, data, arena)) {\n        return OTS_FAILURE_MSG_TAG(\"Failed to parse table\", tag);\n      }\n    }\n  }\n\n  // Then parse any tables left.\n  for (const auto &table_entry : tables) {\n    if (!font->GetTable(table_entry.tag)) {\n      if (!font->ParseTable(table_entry, data, arena)) {\n        return OTS_FAILURE_MSG_TAG(\"Failed to parse table\", table_entry.tag);\n      }\n    }\n  }\n\n  if (font->GetTable(OTS_TAG_CFF)) {\n    // font with PostScript glyph\n    if (font->version != OTS_TAG('O','T','T','O')) {\n      return OTS_FAILURE_MSG_HDR(\"wrong font version for PostScript glyph data\");\n    }\n    if (font->GetTable(OTS_TAG_GLYF) || font->GetTable(OTS_TAG_LOCA)) {\n      // mixing outline formats is not recommended\n      return OTS_FAILURE_MSG_HDR(\"font contains both PS and TT glyphs\");\n    }\n  } else {\n    if (!font->GetTable(OTS_TAG_GLYF) || !font->GetTable(OTS_TAG_LOCA)) {\n      // No TrueType glyph found.\n      //\n      // We don't sanitize bitmap tables, but don\u2019t reject bitmap-only fonts if\n      // we are asked to pass them thru.\n      // Also don\u2019t reject if we are asked to pass glyf/loca thru.\n      if (!font->GetTable(OTS_TAG('C','B','D','T')) &&\n          !font->GetTable(OTS_TAG('C','B','L','C'))) {\n        return OTS_FAILURE_MSG_HDR(\"no supported glyph shapes table(s) present\");\n      }\n    }\n  }\n\n  uint16_t num_output_tables = 0;\n  for (const auto &it : table_map) {\n    ots::Table *table = font->GetTable(it.first);\n    if (table != NULL && table->ShouldSerialize())\n      num_output_tables++;\n  }\n\n  uint16_t max_pow2 = 0;\n  while (1u << (max_pow2 + 1) <= num_output_tables) {\n    max_pow2++;\n  }\n  const uint16_t output_search_range = (1u << max_pow2) << 4;\n\n  // most of the errors here are highly unlikely - they'd only occur if the\n  // output stream returns a failure, e.g. lack of space to write\n  output->ResetChecksum();\n  if (!output->WriteU32(font->version) ||\n      !output->WriteU16(num_output_tables) ||\n      !output->WriteU16(output_search_range) ||\n      !output->WriteU16(max_pow2) ||\n      !output->WriteU16((num_output_tables << 4) - output_search_range)) {\n    return OTS_FAILURE_MSG_HDR(\"error writing output\");\n  }\n  const uint32_t offset_table_chksum = output->chksum();\n\n  const size_t table_record_offset = output->Tell();\n  if (!output->Pad(16 * num_output_tables)) {\n    return OTS_FAILURE_MSG_HDR(\"error writing output\");\n  }\n\n  std::vector<ots::TableEntry> out_tables;\n\n  size_t head_table_offset = 0;\n  for (const auto &it : table_map) {\n    uint32_t input_offset = it.second.offset;\n    const auto &ot = header->table_entries.find(input_offset);\n    if (ot != header->table_entries.end()) {\n      ots::TableEntry out = ot->second;\n      if (out.tag == OTS_TAG('h','e','a','d')) {\n        head_table_offset = out.offset;\n      }\n      out_tables.push_back(out);\n    } else {\n      ots::TableEntry out;\n      out.tag = it.first;\n      out.offset = output->Tell();\n\n      if (out.tag == OTS_TAG('h','e','a','d')) {\n        head_table_offset = out.offset;\n      }\n\n      ots::Table *table = font->GetTable(out.tag);\n      if (table != NULL && table->ShouldSerialize()) {\n        output->ResetChecksum();\n        if (!table->Serialize(output)) {\n          return OTS_FAILURE_MSG_TAG(\"failed to serialize table\", out.tag);\n        }\n\n        const size_t end_offset = output->Tell();\n        if (end_offset <= out.offset) {\n          // paranoid check. |end_offset| is supposed to be greater than the offset,\n          // as long as the Tell() interface is implemented correctly.\n          return OTS_FAILURE_MSG_HDR(\"error writing output\");\n        }\n        out.length = end_offset - out.offset;\n\n        // align tables to four bytes\n        if (!output->Pad((4 - (end_offset & 3)) % 4)) {\n          return OTS_FAILURE_MSG_HDR(\"error writing output\");\n        }\n        out.chksum = output->chksum();\n        out_tables.push_back(out);\n        header->table_entries[input_offset] = out;\n      }\n    }\n  }\n\n  const size_t end_of_file = output->Tell();\n\n  // Need to sort the output tables for inclusion in the file\n  std::sort(out_tables.begin(), out_tables.end());\n  if (!output->Seek(table_record_offset)) {\n    return OTS_FAILURE_MSG_HDR(\"error writing output\");\n  }\n\n  output->ResetChecksum();\n  uint32_t tables_chksum = 0;\n  for (unsigned i = 0; i < out_tables.size(); ++i) {\n    if (!output->WriteU32(out_tables[i].tag) ||\n        !output->WriteU32(out_tables[i].chksum) ||\n        !output->WriteU32(out_tables[i].offset) ||\n        !output->WriteU32(out_tables[i].length)) {\n      return OTS_FAILURE_MSG_HDR(\"error writing output\");\n    }\n    tables_chksum += out_tables[i].chksum;\n  }\n  const uint32_t table_record_chksum = output->chksum();\n\n  // http://www.microsoft.com/typography/otspec/otff.htm\n  const uint32_t file_chksum\n      = offset_table_chksum + tables_chksum + table_record_chksum;\n  const uint32_t chksum_magic = static_cast<uint32_t>(0xb1b0afba) - file_chksum;\n\n  // seek into the 'head' table and write in the checksum magic value\n  if (!head_table_offset) {\n    return OTS_FAILURE_MSG_HDR(\"internal error!\");\n  }\n  if (!output->Seek(head_table_offset + 8)) {\n    return OTS_FAILURE_MSG_HDR(\"error writing output\");\n  }\n  if (!output->WriteU32(chksum_magic)) {\n    return OTS_FAILURE_MSG_HDR(\"error writing output\");\n  }\n\n  if (!output->Seek(end_of_file)) {\n    return OTS_FAILURE_MSG_HDR(\"error writing output\");\n  }\n\n  return true;\n}\nbool Font::ParseTable(const TableEntry& table_entry, const uint8_t* data,\n                      Arena &arena) {\n  uint32_t tag = table_entry.tag;\n  TableAction action = GetTableAction(file, tag);\n  if (action == TABLE_ACTION_DROP) {\n    return true;\n  }\n\n  const auto &it = file->tables.find(table_entry);\n  if (it != file->tables.end()) {\n    m_tables[tag] = it->second;\n    return true;\n  }\n\n  Table *table = NULL;\n  bool ret = false;\n\n  if (action == TABLE_ACTION_PASSTHRU) {\n    table = new TablePassthru(this, tag);\n  } else {\n    switch (tag) {\n      case OTS_TAG_CFF:  table = new OpenTypeCFF(this,  tag); break;\n      case OTS_TAG_CMAP: table = new OpenTypeCMAP(this, tag); break;\n      case OTS_TAG_CVT:  table = new OpenTypeCVT(this,  tag); break;\n      case OTS_TAG_FPGM: table = new OpenTypeFPGM(this, tag); break;\n      case OTS_TAG_GASP: table = new OpenTypeGASP(this, tag); break;\n      case OTS_TAG_GDEF: table = new OpenTypeGDEF(this, tag); break;\n      case OTS_TAG_GLYF: table = new OpenTypeGLYF(this, tag); break;\n      case OTS_TAG_GPOS: table = new OpenTypeGPOS(this, tag); break;\n      case OTS_TAG_GSUB: table = new OpenTypeGSUB(this, tag); break;\n      case OTS_TAG_HDMX: table = new OpenTypeHDMX(this, tag); break;\n      case OTS_TAG_HEAD: table = new OpenTypeHEAD(this, tag); break;\n      case OTS_TAG_HHEA: table = new OpenTypeHHEA(this, tag); break;\n      case OTS_TAG_HMTX: table = new OpenTypeHMTX(this, tag); break;\n      case OTS_TAG_KERN: table = new OpenTypeKERN(this, tag); break;\n      case OTS_TAG_LOCA: table = new OpenTypeLOCA(this, tag); break;\n      case OTS_TAG_LTSH: table = new OpenTypeLTSH(this, tag); break;\n      case OTS_TAG_MATH: table = new OpenTypeMATH(this, tag); break;\n      case OTS_TAG_MAXP: table = new OpenTypeMAXP(this, tag); break;\n      case OTS_TAG_NAME: table = new OpenTypeNAME(this, tag); break;\n      case OTS_TAG_OS2:  table = new OpenTypeOS2(this,  tag); break;\n      case OTS_TAG_POST: table = new OpenTypePOST(this, tag); break;\n      case OTS_TAG_PREP: table = new OpenTypePREP(this, tag); break;\n      case OTS_TAG_VDMX: table = new OpenTypeVDMX(this, tag); break;\n      case OTS_TAG_VORG: table = new OpenTypeVORG(this, tag); break;\n      case OTS_TAG_VHEA: table = new OpenTypeVHEA(this, tag); break;\n      case OTS_TAG_VMTX: table = new OpenTypeVMTX(this, tag); break;\n      default: break;\n    }\n  }\n\n  if (table) {\n    const uint8_t* table_data;\n    size_t table_length;\n\n    if (GetTableData(data, table_entry, arena, &table_length, &table_data)) {\n      // FIXME: Parsing some tables will fail if the table is not added to\n      // m_tables first.\n      m_tables[tag] = table;\n      ret = table->Parse(table_data, table_length);\n      if (!ret) {\n        m_tables.erase(tag);\n        delete table;\n      } else {\n        file->tables[table_entry] = table;\n      }\n    }\n  }\n\n  return ret;\n}\n",
    "target": 0,
    "idx": 2000919
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "static status\nExtensionObject_decodeBinaryContent(UA_ExtensionObject *dst, const UA_NodeId *typeId) {\n    /* Lookup the datatype */\n    const UA_DataType *type = UA_findDataTypeByBinary(typeId);\n\n    /* Unknown type, just take the binary content */\n    if(!type) {\n        dst->encoding = UA_EXTENSIONOBJECT_ENCODED_BYTESTRING;\n        UA_NodeId_copy(typeId, &dst->content.encoded.typeId);\n        return ByteString_decodeBinary(&dst->content.encoded.body);\n    }\n\n    /* Allocate memory */\n    dst->content.decoded.data = UA_new(type);\n    if(!dst->content.decoded.data)\n        return UA_STATUSCODE_BADOUTOFMEMORY;\n\n    /* Jump over the length field (TODO: check if the decoded length matches) */\n    g_pos += 4;\n        \n    /* Decode */\n    dst->encoding = UA_EXTENSIONOBJECT_DECODED;\n    dst->content.decoded.type = type;\n    size_t decode_index = type->builtin ? type->typeIndex : UA_BUILTIN_TYPES_COUNT;\n    return decodeBinaryJumpTable[decode_index](dst->content.decoded.data, type);\n}\n",
    "target": 0,
    "idx": 2004300
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "    (void) printf(\" Found a generic profile, type %s\\n\",&text[ii].key[17]);\n\n  return MagickTrue;\n}\n\n#if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)\n\nstatic int read_user_chunk_callback(png_struct *ping, png_unknown_chunkp chunk)\n{\n  Image\n    *image;\n\n\n  /* The unknown chunk structure contains the chunk data:\n     png_byte name[5];\n     png_byte *data;\n     png_size_t size;\n\n     Note that libpng has already taken care of the CRC handling.\n\n     Returns one of the following:\n         return(-n);  chunk had an error\n         return(0);  did not recognize\n         return(n);  success\n  */\n\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n     \"    read_user_chunk: found %c%c%c%c chunk\",\n       chunk->name[0],chunk->name[1],chunk->name[2],chunk->name[3]);\n\n  if (chunk->name[0]  == 101 &&\n      (chunk->name[1] ==  88 || chunk->name[1] == 120 ) &&\n      chunk->name[2] ==   73 &&\n      chunk-> name[3] == 102)\n    {\n      /* process eXIf or exIf chunk */\n\n      PNGErrorInfo\n        *error_info;\n\n      StringInfo\n        *profile;\n\n      unsigned char\n        *p;\n\n      png_byte\n        *s;\n\n      size_t\n        i;\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \" recognized eXIf chunk\");\n\n      image=(Image *) png_get_user_chunk_ptr(ping);\n\n      error_info=(PNGErrorInfo *) png_get_error_ptr(ping);\n\n      profile=BlobToStringInfo((const void *) NULL,chunk->size+6);\n\n      if (profile == (StringInfo *) NULL)\n        {\n          (void) ThrowMagickException(error_info->exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\n            image->filename);\n          return(-1);\n        }\n      p=GetStringInfoDatum(profile);\n\n      /* Initialize profile with \"Exif\\0\\0\" */\n      *p++ ='E';\n      *p++ ='x';\n      *p++ ='i';\n      *p++ ='f';\n      *p++ ='\\0';\n      *p++ ='\\0';\n\n      s=chunk->data;\n      i=0;\n      if (chunk->size > 6)\n        {\n          /* Skip first 6 bytes if \"Exif\\0\\0\" is\n             already present by accident\n          */\n          if (s[0] == 'E' && s[1] == 'x'  && s[2] == 'i' &&\n              s[3] == 'f' && s[4] == '\\0' && s[5] == '\\0')\n          {\n            s+=6;\n            i=6;\n            SetStringInfoLength(profile,chunk->size);\n            p=GetStringInfoDatum(profile);\n          }\n        }\n\n      /* copy chunk->data to profile */\n      for (; i<chunk->size; i++)\n        *p++ = *s++;\n\n      error_info=(PNGErrorInfo *) png_get_error_ptr(ping);\n      (void) SetImageProfile(image,\"exif\",profile,\n        error_info->exception);\n\n      profile=DestroyStringInfo(profile);\n\n      return(1);\n    }\n\n  /* orNT */\n  if (chunk->name[0] == 111 &&\n      chunk->name[1] == 114 &&\n      chunk->name[2] ==  78 &&\n      chunk->name[3] ==  84)\n    {\n     /* recognized orNT */\n     if (chunk->size != 1)\n       return(-1); /* Error return */\n\n     image=(Image *) png_get_user_chunk_ptr(ping);\n\n     image->orientation=\n       Magick_Orientation_from_Exif_Orientation((int) chunk->data[0]);\n\n     return(1);\n    }\n\n  /* vpAg (deprecated, replaced by caNv) */\n  if (chunk->name[0] == 118 &&\n      chunk->name[1] == 112 &&\n      chunk->name[2] ==  65 &&\n      chunk->name[3] == 103)\n    {\n      /* recognized vpAg */\n\n      if (chunk->size != 9)\n        return(-1); /* Error return */\n\n      if (chunk->data[8] != 0)\n        return(0);  /* ImageMagick requires pixel units */\n\n      image=(Image *) png_get_user_chunk_ptr(ping);\n\n      image->page.width=(size_t)mng_get_long(chunk->data);\n      image->page.height=(size_t)mng_get_long(&chunk->data[4]);\n\n      return(1);\n    }\n\n  /* caNv */\n  if (chunk->name[0] ==  99 &&\n      chunk->name[1] ==  97 &&\n      chunk->name[2] ==  78 &&\n      chunk->name[3] == 118)\n    {\n      /* recognized caNv */\n\n      if (chunk->size != 16)\n        return(-1); /* Error return */\n\n      image=(Image *) png_get_user_chunk_ptr(ping);\n\n      image->page.width=(size_t)mng_get_long(chunk->data);\n      image->page.height=(size_t)mng_get_long(&chunk->data[4]);\n      image->page.x=(size_t)mng_get_long(&chunk->data[8]);\n",
    "target": 0,
    "idx": 2007534
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "static void set_planes_to_neutral_grey(const SequenceHeader *const seq_params,\n                                       const YV12_BUFFER_CONFIG *const buf,\n                                       int only_chroma) {\n  const int val = 1 << (seq_params->bit_depth - 1);\n  for (int plane = only_chroma; plane < MAX_MB_PLANE; plane++) {\n    const int is_uv = plane > 0;\n    for (int row_idx = 0; row_idx < buf->crop_heights[is_uv]; row_idx++) {\n      if (seq_params->use_highbitdepth) {\n        // TODO(yaowu): replace this with aom_memset16() for speed\n        for (int col_idx = 0; col_idx < buf->crop_widths[is_uv]; col_idx++) {\n          uint16_t *base = CONVERT_TO_SHORTPTR(buf->buffers[plane]);\n          base[row_idx * buf->strides[is_uv] + col_idx] = val;\n        }\n      } else {\n        memset(&buf->buffers[plane][row_idx * buf->uv_stride], 1 << 7,\n               buf->crop_widths[is_uv]);\n      }\n    }\n  }\n}\nstatic INLINE void reset_frame_buffers(AV1_COMMON *cm) {\n  RefCntBuffer *const frame_bufs = cm->buffer_pool->frame_bufs;\n  const SequenceHeader *const seq_params = &cm->seq_params;\n  int i;\n\n  memset(&cm->ref_frame_map, -1, sizeof(cm->ref_frame_map));\n  memset(&cm->next_ref_frame_map, -1, sizeof(cm->next_ref_frame_map));\n\n  lock_buffer_pool(cm->buffer_pool);\n  for (i = 0; i < FRAME_BUFFERS; ++i) {\n    if (i != cm->new_fb_idx) {\n      frame_bufs[i].ref_count = 0;\n      cm->buffer_pool->release_fb_cb(cm->buffer_pool->cb_priv,\n                                     &frame_bufs[i].raw_frame_buffer);\n    } else {\n      // Previous sequence with different bitdepth may have set to a\n      // neutral gray in different bit depth, need reset here.\n      YV12_BUFFER_CONFIG *cur_buf = &frame_bufs[i].buf;\n      if (cur_buf->buffer_alloc_sz >= cur_buf->frame_size)\n        set_planes_to_neutral_grey(seq_params, cur_buf, 0);\n    }\n    frame_bufs[i].cur_frame_offset = 0;\n    av1_zero(frame_bufs[i].ref_frame_offset);\n  }\n  unlock_buffer_pool(cm->buffer_pool);\n}\n",
    "target": 0,
    "idx": 2010200
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "static int\nparse_odp_action(const char *s, const struct simap *port_names,\n                 struct ofpbuf *actions)\n{\n    {\n        uint32_t port;\n        int n;\n\n        if (ovs_scan(s, \"%\"SCNi32\"%n\", &port, &n)) {\n            nl_msg_put_u32(actions, OVS_ACTION_ATTR_OUTPUT, port);\n            return n;\n        }\n    }\n\n    {\n        uint32_t max_len;\n        int n;\n\n        if (ovs_scan(s, \"trunc(%\"SCNi32\")%n\", &max_len, &n)) {\n            struct ovs_action_trunc *trunc;\n\n            trunc = nl_msg_put_unspec_uninit(actions,\n                     OVS_ACTION_ATTR_TRUNC, sizeof *trunc);\n            trunc->max_len = max_len;\n            return n;\n        }\n    }\n\n    if (port_names) {\n        int len = strcspn(s, delimiters);\n        struct simap_node *node;\n\n        node = simap_find_len(port_names, s, len);\n        if (node) {\n            nl_msg_put_u32(actions, OVS_ACTION_ATTR_OUTPUT, node->data);\n            return len;\n        }\n    }\n\n    {\n        uint32_t recirc_id;\n        int n = -1;\n\n        if (ovs_scan(s, \"recirc(%\"PRIu32\")%n\", &recirc_id, &n)) {\n            nl_msg_put_u32(actions, OVS_ACTION_ATTR_RECIRC, recirc_id);\n            return n;\n        }\n    }\n\n    if (!strncmp(s, \"userspace(\", 10)) {\n        return parse_odp_userspace_action(s, actions);\n    }\n\n    if (!strncmp(s, \"set(\", 4)) {\n        size_t start_ofs;\n        int retval;\n        struct nlattr mask[1024 / sizeof(struct nlattr)];\n        struct ofpbuf maskbuf = OFPBUF_STUB_INITIALIZER(mask);\n        struct nlattr *nested, *key;\n        size_t size;\n\n        start_ofs = nl_msg_start_nested(actions, OVS_ACTION_ATTR_SET);\n        retval = parse_odp_key_mask_attr(s + 4, port_names, actions, &maskbuf);\n        if (retval < 0) {\n            ofpbuf_uninit(&maskbuf);\n            return retval;\n        }\n        if (s[retval + 4] != ')') {\n            ofpbuf_uninit(&maskbuf);\n            return -EINVAL;\n        }\n\n        nested = ofpbuf_at_assert(actions, start_ofs, sizeof *nested);\n        key = nested + 1;\n\n        size = nl_attr_get_size(mask);\n        if (size == nl_attr_get_size(key)) {\n            /* Change to masked set action if not fully masked. */\n            if (!is_all_ones(mask + 1, size)) {\n                /* Remove padding of eariler key payload  */\n                actions->size -= NLA_ALIGN(key->nla_len) - key->nla_len;\n\n                /* Put mask payload right after key payload */\n                key->nla_len += size;\n                ofpbuf_put(actions, mask + 1, size);\n\n                /* 'actions' may have been reallocated by ofpbuf_put(). */\n                nested = ofpbuf_at_assert(actions, start_ofs, sizeof *nested);\n                nested->nla_type = OVS_ACTION_ATTR_SET_MASKED;\n\n                key = nested + 1;\n                /* Add new padding as needed */\n                ofpbuf_put_zeros(actions, NLA_ALIGN(key->nla_len) -\n                                          key->nla_len);\n            }\n        }\n        ofpbuf_uninit(&maskbuf);\n\n        nl_msg_end_nested(actions, start_ofs);\n        return retval + 5;\n    }\n\n    {\n        struct ovs_action_push_vlan push;\n        int tpid = ETH_TYPE_VLAN;\n        int vid, pcp;\n        int cfi = 1;\n        int n = -1;\n\n        if (ovs_scan(s, \"push_vlan(vid=%i,pcp=%i)%n\", &vid, &pcp, &n)\n            || ovs_scan(s, \"push_vlan(vid=%i,pcp=%i,cfi=%i)%n\",\n                        &vid, &pcp, &cfi, &n)\n            || ovs_scan(s, \"push_vlan(tpid=%i,vid=%i,pcp=%i)%n\",\n                        &tpid, &vid, &pcp, &n)\n            || ovs_scan(s, \"push_vlan(tpid=%i,vid=%i,pcp=%i,cfi=%i)%n\",\n                        &tpid, &vid, &pcp, &cfi, &n)) {\n            push.vlan_tpid = htons(tpid);\n            push.vlan_tci = htons((vid << VLAN_VID_SHIFT)\n                                  | (pcp << VLAN_PCP_SHIFT)\n                                  | (cfi ? VLAN_CFI : 0));\n            nl_msg_put_unspec(actions, OVS_ACTION_ATTR_PUSH_VLAN,\n                              &push, sizeof push);\n\n            return n;\n        }\n    }\n\n    if (!strncmp(s, \"pop_vlan\", 8)) {\n        nl_msg_put_flag(actions, OVS_ACTION_ATTR_POP_VLAN);\n        return 8;\n    }\n\n    {\n        unsigned long long int meter_id;\n        int n = -1;\n\n        if (sscanf(s, \"meter(%lli)%n\", &meter_id, &n) > 0 && n > 0) {\n            nl_msg_put_u32(actions, OVS_ACTION_ATTR_METER, meter_id);\n            return n;\n        }\n    }\n\n    {\n        double percentage;\n        int n = -1;\n\n        if (ovs_scan(s, \"sample(sample=%lf%%,actions(%n\", &percentage, &n)\n            && percentage >= 0. && percentage <= 100.0) {\n            size_t sample_ofs, actions_ofs;\n            double probability;\n\n            probability = floor(UINT32_MAX * (percentage / 100.0) + .5);\n            sample_ofs = nl_msg_start_nested(actions, OVS_ACTION_ATTR_SAMPLE);\n            nl_msg_put_u32(actions, OVS_SAMPLE_ATTR_PROBABILITY,\n                           (probability <= 0 ? 0\n                            : probability >= UINT32_MAX ? UINT32_MAX\n                            : probability));\n\n            actions_ofs = nl_msg_start_nested(actions,\n                                              OVS_SAMPLE_ATTR_ACTIONS);\n            int retval = parse_action_list(s + n, port_names, actions);\n            if (retval < 0)\n                return retval;\n\n            n += retval;\n            nl_msg_end_nested(actions, actions_ofs);\n            nl_msg_end_nested(actions, sample_ofs);\n\n            return s[n + 1] == ')' ? n + 2 : -EINVAL;\n        }\n    }\n\n    {\n        if (!strncmp(s, \"clone(\", 6)) {\n            size_t actions_ofs;\n            int n = 6;\n\n            actions_ofs = nl_msg_start_nested(actions, OVS_ACTION_ATTR_CLONE);\n            int retval = parse_action_list(s + n, port_names, actions);\n            if (retval < 0) {\n                return retval;\n            }\n            n += retval;\n            nl_msg_end_nested(actions, actions_ofs);\n            return n + 1;\n        }\n    }\n\n    {\n        if (!strncmp(s, \"push_nsh(\", 9)) {\n            int retval = parse_odp_push_nsh_action(s, actions);\n            if (retval < 0) {\n                return retval;\n            }\n            return retval + 1;\n        }\n    }\n\n    {\n        int n;\n        if (ovs_scan(s, \"pop_nsh()%n\", &n)) {\n            nl_msg_put_flag(actions, OVS_ACTION_ATTR_POP_NSH);\n            return n;\n        }\n    }\n\n    {\n        uint32_t port;\n        int n;\n\n        if (ovs_scan(s, \"tnl_pop(%\"SCNi32\")%n\", &port, &n)) {\n            nl_msg_put_u32(actions, OVS_ACTION_ATTR_TUNNEL_POP, port);\n            return n;\n        }\n    }\n\n    {\n        if (!strncmp(s, \"ct_clear\", 8)) {\n            nl_msg_put_flag(actions, OVS_ACTION_ATTR_CT_CLEAR);\n            return 8;\n        }\n    }\n\n    {\n        int retval;\n\n        retval = parse_conntrack_action(s, actions);\n        if (retval) {\n            return retval;\n        }\n    }\n\n    {\n        struct ovs_action_push_tnl data;\n        int n;\n\n        n = ovs_parse_tnl_push(s, &data);\n        if (n > 0) {\n            odp_put_tnl_push_action(actions, &data);\n            return n;\n        } else if (n < 0) {\n            return n;\n        }\n    }\n    return -EINVAL;\n}\n",
    "target": 0,
    "idx": 2010796
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "void\nNCPInstanceBase::on_mesh_prefix_was_removed(Origin origin, const struct in6_addr &prefix_address, uint8_t prefix_len,\n\tuint8_t flags, bool stable, uint16_t rloc16, CallbackWithStatus cb)\n{\n\tIPv6Prefix prefix(prefix_address, prefix_len);\n\tOnMeshPrefixEntry entry(origin, flags, stable, rloc16);\n\tstd::multimap<IPv6Prefix, OnMeshPrefixEntry>::iterator iter;\n\n\titer = find_prefix_entry(prefix, entry);\n\n\tif (iter != mOnMeshPrefixes.end()) {\n\t\tsyslog(LOG_INFO, \"OnMeshPrefixes: Removing %s\", entry.get_description(prefix).c_str());\n\t\tmOnMeshPrefixes.erase(iter);\n\n\t\tif (origin != kOriginThreadNCP) {\n\t\t\tremove_on_mesh_prefix_on_ncp(prefix.get_prefix(), prefix.get_length(),\n\t\t\t\tentry.get_flags(), entry.is_stable(),\n\t\t\t\tboost::bind(&NCPInstanceBase::check_ncp_entry_update_status, this, _1, \"removing on-mesh prefix\", cb));\n\t\t} else {\n\t\t\tcb(kWPANTUNDStatus_Ok);\n\t\t}\n\n\t\tif (entry.is_on_mesh() && entry.is_slaac() && prefix.get_length() == kSLAACPrefixLength\n\t\t\t&& !has_slaac_on_mesh_prefix(prefix)\n\t\t) {\n\t\t\tstd::map<struct in6_addr, UnicastAddressEntry>::iterator addr_iter;\n\n\t\t\t// Note that SLAAC addresses are added with origin NCP.\n\t\t\taddr_iter = find_address_with_prefix(prefix, kOriginThreadNCP);\n\n\t\t\tif (addr_iter != mUnicastAddresses.end()) {\n\t\t\t\tstruct in6_addr address = addr_iter->first;\n\t\t\t\tsyslog(LOG_NOTICE, \"Removing SLAAC address %s/%d from NCP\", in6_addr_to_string(address).c_str(), prefix_len);\n\t\t\t\tremove_unicast_address_on_ncp(address, prefix_len,\n\t\t\t\t\tboost::bind(&NCPInstanceBase::check_ncp_entry_update_status, this, _1, \"removing SLAAC address\", NilReturn()));\n\t\t\t\tunicast_address_was_removed(kOriginThreadNCP, address);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tcb(kWPANTUNDStatus_Ok);\n\t}\n}\n",
    "target": 0,
    "idx": 2010864
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "static void\nVariant_clear(UA_Variant *p, const UA_DataType *_) {\n    if(p->storageType != UA_VARIANT_DATA)\n        return;\n    if(p->type && p->data > UA_EMPTY_ARRAY_SENTINEL) {\n        if(p->arrayLength == 0)\n            p->arrayLength = 1;\n        UA_Array_delete(p->data, p->arrayLength, p->type);\n        p->data = NULL;\n    }\n    if((void*)p->arrayDimensions > UA_EMPTY_ARRAY_SENTINEL)\n        UA_free(p->arrayDimensions);\n}\n",
    "target": 0,
    "idx": 2011484
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "int yr_re_ast_split_at_chaining_point(\n    RE_AST* re_ast,\n    RE_AST** result_re_ast,\n    RE_AST** remainder_re_ast,\n    int32_t* min_gap,\n    int32_t* max_gap)\n{\n  RE_NODE* child;\n  RE_NODE* concat;\n\n  int result;\n\n  *result_re_ast = re_ast;\n  *remainder_re_ast = NULL;\n  *min_gap = 0;\n  *max_gap = 0;\n\n  if (re_ast->root_node->type != RE_NODE_CONCAT)\n    return ERROR_SUCCESS;\n\n  child = re_ast->root_node->children_head;\n\n  while (child != NULL)\n  {\n    if (!child->greedy &&\n         child->type == RE_NODE_RANGE_ANY &&\n         child->prev_sibling != NULL &&\n         child->next_sibling != NULL &&\n        (child->start > YR_STRING_CHAINING_THRESHOLD ||\n         child->end > YR_STRING_CHAINING_THRESHOLD))\n    {\n      result = yr_re_ast_create(remainder_re_ast);\n\n      if (result != ERROR_SUCCESS)\n        return result;\n\n      concat = yr_re_node_create(RE_NODE_CONCAT);\n\n      if (concat == NULL)\n        return ERROR_INSUFFICIENT_MEMORY;\n\n      concat->children_head = re_ast->root_node->children_head;\n      concat->children_tail = child->prev_sibling;\n\n      re_ast->root_node->children_head = child->next_sibling;\n\n      child->prev_sibling->next_sibling = NULL;\n      child->next_sibling->prev_sibling = NULL;\n\n      *min_gap = child->start;\n      *max_gap = child->end;\n\n      (*result_re_ast)->root_node = re_ast->root_node;\n      (*result_re_ast)->flags = re_ast->flags;\n      (*remainder_re_ast)->root_node = concat;\n      (*remainder_re_ast)->flags = re_ast->flags;\n\n      yr_re_node_destroy(child);\n\n      return ERROR_SUCCESS;\n    }\n\n    child = child->next_sibling;\n  }\n\n  return ERROR_SUCCESS;\n}\nvoid test_re()\n{\n  assert_true_rule(\n      \"rule test { strings: $a = /ssi/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ssi(s|p)/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ssim*/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ssa?/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /Miss/ nocase condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /(M|N)iss/ nocase condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /[M-N]iss/ nocase condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /(Mi|ssi)ssippi/ nocase condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ppi\\\\tmi/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ppi\\\\.mi/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /^mississippi/ fullword condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /mississippi.*mississippi$/s condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /^ssi/ condition: $a }\",\n      \"mississippi\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /ssi$/ condition: $a }\",\n      \"mississippi\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /ssissi/ fullword condition: $a }\",\n      \"mississippi\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /^[isp]+/ condition: $a }\",\n      \"mississippi\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /a.{1,2}b/ wide condition: !a == 6 }\",\n      \"a\\0x\\0b\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /a.{1,2}b/ wide condition: !a == 8 }\",\n      \"a\\0x\\0x\\0b\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n      \"a\\0b\\0c\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n      \"\\0a\\0b\\0c\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n      \"\\ta\\0b\\0c\\0\");\n\n  assert_false_rule_blob(\n      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n      \"x\\0a\\0b\\0c\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n      \"x\\ta\\0b\\0c\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n      \"a\\0b\\0c\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n      \"a\\0b\\0c\\0\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n      \"a\\0b\\0c\\0\\t\");\n\n  assert_false_rule_blob(\n      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n      \"a\\0b\\0c\\0x\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n      \"a\\0b\\0c\\0b\\t\");\n\n  assert_false_rule_blob(\n      \"rule test { strings: $a = /\\\\b/ wide condition: $a }\",\n      \"abc\");\n\n  assert_regexp_syntax_error(\")\");\n  assert_true_regexp(\"abc\", \"abc\", \"abc\");\n  assert_false_regexp(\"abc\", \"xbc\");\n  assert_false_regexp(\"abc\", \"axc\");\n  assert_false_regexp(\"abc\", \"abx\");\n  assert_true_regexp(\"abc\", \"xabcx\", \"abc\");\n  assert_true_regexp(\"abc\", \"ababc\", \"abc\");\n  assert_true_regexp(\"a.c\", \"abc\", \"abc\");\n  assert_false_regexp(\"a.b\", \"a\\nb\");\n  assert_false_regexp(\"a.*b\", \"acc\\nccb\");\n  assert_false_regexp(\"a.{4,5}b\", \"acc\\nccb\");\n  assert_true_regexp(\"a.b\", \"a\\rb\", \"a\\rb\");\n  assert_true_regexp(\"ab*c\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab*c\", \"ac\", \"ac\");\n  assert_true_regexp(\"ab*bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab*bc\", \"abbc\", \"abbc\");\n  assert_true_regexp(\"a.*bb\", \"abbbb\", \"abbbb\");\n  assert_true_regexp(\"a.*?bbb\", \"abbbbbb\", \"abbb\");\n  assert_true_regexp(\"a.*c\", \"ac\", \"ac\");\n  assert_true_regexp(\"a.*c\", \"axyzc\", \"axyzc\");\n  assert_true_regexp(\"ab+c\", \"abbc\", \"abbc\");\n  assert_false_regexp(\"ab+c\", \"ac\");\n  assert_true_regexp(\"ab+\", \"abbbb\", \"abbbb\");\n  assert_true_regexp(\"ab+?\", \"abbbb\", \"ab\");\n  assert_false_regexp(\"ab+bc\", \"abc\");\n  assert_false_regexp(\"ab+bc\", \"abq\");\n  assert_true_regexp(\"a+b+c\", \"aabbabc\", \"abc\");\n  assert_false_regexp(\"ab?bc\", \"abbbbc\");\n  assert_true_regexp(\"ab?c\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab*?\", \"abbb\", \"a\");\n  assert_true_regexp(\"ab?c\", \"ac\", \"ac\");\n  assert_true_regexp(\"ab??\", \"ab\", \"a\");\n  assert_true_regexp(\"a(b|x)c\", \"abc\", \"abc\");\n  assert_true_regexp(\"a(b|x)c\", \"axc\", \"axc\");\n  assert_true_regexp(\"a(b|.)c\", \"axc\", \"axc\");\n  assert_true_regexp(\"a(b|x|y)c\", \"ayc\", \"ayc\");\n  assert_true_regexp(\"(a+|b)*\", \"ab\", \"ab\");\n  assert_true_regexp(\"a|b|c|d|e\", \"e\", \"e\");\n  assert_true_regexp(\"(a|b|c|d|e)f\", \"ef\", \"ef\");\n  assert_true_regexp(\"a|b\", \"a\", \"a\");\n  assert_true_regexp(\".b{2}\", \"abb\", \"abb\");\n  assert_true_regexp(\".b{2,3}\", \"abbb\", \"abbb\");\n  assert_true_regexp(\".b{2,3}?\", \"abbb\", \"abb\");\n  assert_true_regexp(\"ab{2,3}c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\"ab{2,3}?c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\".b{2,3}cccc\", \"abbbcccc\", \"abbbcccc\");\n  assert_true_regexp(\".b{2,3}?cccc\", \"abbbcccc\", \"bbbcccc\");\n  assert_true_regexp(\"a.b{2,3}cccc\", \"aabbbcccc\", \"aabbbcccc\");\n  assert_true_regexp(\"ab{2,3}c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\"ab{2,3}?c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\"ab{0,1}?c\", \"abc\", \"abc\");\n  assert_true_regexp(\"a{0,1}?bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"a{0,1}bc\", \"bbc\", \"bc\");\n  assert_true_regexp(\"a{0,1}?bc\", \"abc\", \"bc\");\n  assert_true_regexp(\"aa{0,1}?bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"aa{0,1}?bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"aa{0,1}bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab{1}c\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab{1,2}c\", \"abbc\", \"abbc\");\n  assert_false_regexp(\"ab{1,2}c\", \"abbbc\");\n  assert_true_regexp(\"ab{1,}c\", \"abbbc\", \"abbbc\");\n  assert_false_regexp(\"ab{1,}b\", \"ab\");\n  assert_false_regexp(\"ab{1}c\", \"abbc\");\n  assert_false_regexp(\"ab{1}c\", \"ac\");\n  assert_true_regexp(\"ab{0,}c\", \"ac\", \"ac\");\n  assert_true_regexp(\"ab{1,1}c\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab{0,}c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\"ab{,3}c\", \"abbbc\", \"abbbc\");\n  assert_false_regexp(\"ab{,2}c\", \"abbbc\");\n  assert_false_regexp(\"ab{4,5}bc\", \"abbbbc\");\n  assert_false_regexp(\"ab{3}c\", \"abbbbc\");  // Issue #817\n  assert_false_regexp(\"ab{4}c\", \"abbbbbc\");\n  assert_false_regexp(\"ab{5}c\", \"abbbbbbc\");\n  assert_true_regexp(\"ab{0,1}\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{0,2}\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\"ab{0,3}\", \"abbbbb\", \"abbb\");\n  assert_true_regexp(\"ab{0,4}\", \"abbbbb\", \"abbbb\");\n  assert_true_regexp(\"ab{1,1}\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{1,2}\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\"ab{1,3}\", \"abbbbb\", \"abbb\");\n  assert_true_regexp(\"ab{2,2}\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\"ab{2,3}\", \"abbbbb\", \"abbb\");\n  assert_true_regexp(\"ab{2,4}\", \"abbbbc\", \"abbbb\");\n  assert_true_regexp(\"ab{3,4}\", \"abbb\", \"abbb\");\n  assert_true_regexp(\"ab{3,5}\", \"abbbbb\", \"abbbbb\");\n  assert_false_regexp(\"ab{3,4}c\", \"abbbbbc\");\n  assert_false_regexp(\"ab{3,4}c\", \"abbc\");\n  assert_false_regexp(\"ab{3,5}c\", \"abbbbbbc\");\n  assert_true_regexp(\"ab{1,3}?\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{0,1}?\", \"abbbbb\", \"a\");\n  assert_true_regexp(\"ab{0,2}?\", \"abbbbb\", \"a\");\n  assert_true_regexp(\"ab{0,3}?\", \"abbbbb\", \"a\");\n  assert_true_regexp(\"ab{0,4}?\", \"abbbbb\", \"a\");\n  assert_true_regexp(\"ab{1,1}?\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{1,2}?\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{1,3}?\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{2,2}?\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\"ab{2,3}?\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\".(abc){0,1}\", \"xabcabcabcabc\", \"xabc\");\n  assert_true_regexp(\".(abc){0,2}\", \"xabcabcabcabc\", \"xabcabc\");\n  assert_true_regexp(\"x{1,2}abcd\", \"xxxxabcd\", \"xxabcd\");\n  assert_true_regexp(\"x{1,2}abcd\", \"xxxxabcd\", \"xxabcd\");\n  assert_true_regexp(\"ab{.*}\", \"ab{c}\", \"ab{c}\");\n  assert_true_regexp(\".(aa){1,2}\", \"aaaaaaaaaa\", \"aaaaa\");\n  assert_true_regexp(\"a.(bc.){2}\", \"aabcabca\", \"aabcabca\");\n  assert_true_regexp(\"(ab{1,2}c){1,3}\", \"abbcabc\", \"abbcabc\");\n  assert_true_regexp(\"ab(c|cc){1,3}d\", \"abccccccd\", \"abccccccd\");\n  assert_true_regexp(\"a[bx]c\", \"abc\", \"abc\");\n  assert_true_regexp(\"a[bx]c\", \"axc\", \"axc\");\n  assert_true_regexp(\"a[0-9]*b\", \"ab\", \"ab\");\n  assert_true_regexp(\"a[0-9]*b\", \"a0123456789b\", \"a0123456789b\");\n  assert_true_regexp(\"[0-9a-f]+\", \"0123456789abcdef\", \"0123456789abcdef\");\n  assert_true_regexp(\"[0-9a-f]+\", \"xyz0123456789xyz\", \"0123456789\");\n  assert_true_regexp(\"a[\\\\s\\\\S]b\", \"a b\", \"a b\");\n  assert_true_regexp(\"a[\\\\d\\\\D]b\", \"a1b\", \"a1b\");\n  assert_false_regexp(\"[x-z]+\", \"abc\");\n  assert_true_regexp(\"a[-]?c\", \"ac\", \"ac\");\n  assert_true_regexp(\"a[-b]\", \"a-\", \"a-\");\n  assert_true_regexp(\"a[-b]\", \"ab\", \"ab\");\n  assert_true_regexp(\"a[b-]\", \"a-\", \"a-\");\n  assert_true_regexp(\"a[b-]\", \"ab\", \"ab\");\n  assert_true_regexp(\"[a-c-e]\", \"b\", \"b\");\n  assert_true_regexp(\"[a-c-e]\", \"-\", \"-\");\n  assert_false_regexp(\"[a-c-e]\", \"d\");\n  assert_regexp_syntax_error(\"[b-a]\");\n  assert_regexp_syntax_error(\"(abc\");\n  assert_regexp_syntax_error(\"abc)\");\n  assert_regexp_syntax_error(\"a[]b\");\n  assert_true_regexp(\"a[\\\\-b]\", \"a-\", \"a-\");\n  assert_true_regexp(\"a[\\\\-b]\", \"ab\", \"ab\");\n  assert_true_regexp(\"a]\", \"a]\", \"a]\");\n  assert_true_regexp(\"a[]]b\", \"a]b\", \"a]b\");\n  assert_true_regexp(\"a[\\\\]]b\", \"a]b\", \"a]b\");\n  assert_true_regexp(\"a[^bc]d\", \"aed\", \"aed\");\n  assert_false_regexp(\"a[^bc]d\", \"abd\");\n  assert_true_regexp(\"a[^-b]c\", \"adc\", \"adc\");\n  assert_false_regexp(\"a[^-b]c\", \"a-c\");\n  assert_false_regexp(\"a[^]b]c\", \"a]c\");\n  assert_true_regexp(\"a[^]b]c\", \"adc\", \"adc\");\n  assert_true_regexp(\"[^ab]*\", \"cde\", \"cde\");\n  assert_regexp_syntax_error(\")(\");\n  assert_true_regexp(\"a\\\\sb\", \"a b\", \"a b\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\tb\", \"a\\tb\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\rb\", \"a\\rb\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\nb\", \"a\\nb\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\vb\", \"a\\vb\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\fb\", \"a\\fb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a b\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\tb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\rb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\nb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\vb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\fb\");\n  assert_true_regexp(\"\\\\n\\\\r\\\\t\\\\f\\\\a\", \"\\n\\r\\t\\f\\a\", \"\\n\\r\\t\\f\\a\");\n  assert_true_regexp(\"[\\\\n][\\\\r][\\\\t][\\\\f][\\\\a]\", \"\\n\\r\\t\\f\\a\", \"\\n\\r\\t\\f\\a\");\n  assert_true_regexp(\"\\\\x01\\\\x02\\\\x03\", \"\\x01\\x02\\x03\", \"\\x01\\x02\\x03\");\n  assert_true_regexp(\"[\\\\x01-\\\\x03]+\", \"\\x01\\x02\\x03\", \"\\x01\\x02\\x03\");\n  assert_false_regexp(\"[\\\\x00-\\\\x02]+\", \"\\x03\\x04\\x05\");\n  assert_true_regexp(\"[\\\\x5D]\", \"]\", \"]\");\n  assert_true_regexp(\"[\\\\0x5A-\\\\x5D]\", \"\\x5B\", \"\\x5B\");\n  assert_true_regexp(\"[\\\\x5D-\\\\x5F]\", \"\\x5E\", \"\\x5E\");\n  assert_true_regexp(\"[\\\\x5C-\\\\x5F]\", \"\\x5E\", \"\\x5E\");\n  assert_true_regexp(\"[\\\\x5D-\\\\x5F]\", \"\\x5E\", \"\\x5E\");\n  assert_true_regexp(\"a\\\\wc\", \"abc\", \"abc\");\n  assert_true_regexp(\"a\\\\wc\", \"a_c\", \"a_c\");\n  assert_true_regexp(\"a\\\\wc\", \"a0c\", \"a0c\");\n  assert_false_regexp(\"a\\\\wc\", \"a*c\");\n  assert_true_regexp(\"\\\\w+\", \"--ab_cd0123--\", \"ab_cd0123\");\n  assert_true_regexp(\"[\\\\w]+\", \"--ab_cd0123--\", \"ab_cd0123\");\n  assert_true_regexp(\"\\\\D+\", \"1234abc5678\", \"abc\");\n  assert_true_regexp(\"[\\\\d]+\", \"0123456789\", \"0123456789\");\n  assert_true_regexp(\"[\\\\D]+\", \"1234abc5678\", \"abc\");\n  assert_true_regexp(\"[\\\\da-fA-F]+\", \"123abc\", \"123abc\");\n  assert_false_regexp(\"^(ab|cd)e\", \"abcde\");\n  assert_true_regexp(\"(abc|)ef\", \"abcdef\", \"ef\");\n  assert_true_regexp(\"(abc|)ef\", \"abcef\", \"abcef\");\n  assert_true_regexp(\"\\\\babc\", \"abc\", \"abc\");\n  assert_true_regexp(\"abc\\\\b\", \"abc\", \"abc\");\n  assert_false_regexp(\"\\\\babc\", \"1abc\");\n  assert_false_regexp(\"abc\\\\b\", \"abc1\");\n  assert_true_regexp(\"abc\\\\s\\\\b\", \"abc x\", \"abc \");\n  assert_false_regexp(\"abc\\\\s\\\\b\", \"abc  \");\n  assert_true_regexp(\"\\\\babc\\\\b\", \" abc \", \"abc\");\n  assert_true_regexp(\"\\\\b\\\\w\\\\w\\\\w\\\\b\", \" abc \", \"abc\");\n  assert_true_regexp(\"\\\\w\\\\w\\\\w\\\\b\", \"abcd\", \"bcd\");\n  assert_true_regexp(\"\\\\b\\\\w\\\\w\\\\w\", \"abcd\", \"abc\");\n  assert_false_regexp(\"\\\\b\\\\w\\\\w\\\\w\\\\b\", \"abcd\");\n  assert_false_regexp(\"\\\\Babc\", \"abc\");\n  assert_false_regexp(\"abc\\\\B\", \"abc\");\n  assert_true_regexp(\"\\\\Babc\", \"1abc\", \"abc\");\n  assert_true_regexp(\"abc\\\\B\", \"abc1\", \"abc\");\n  assert_false_regexp(\"abc\\\\s\\\\B\", \"abc x\");\n  assert_true_regexp(\"abc\\\\s\\\\B\", \"abc  \", \"abc \");\n  assert_true_regexp(\"\\\\w\\\\w\\\\w\\\\B\", \"abcd\", \"abc\");\n  assert_true_regexp(\"\\\\B\\\\w\\\\w\\\\w\", \"abcd\", \"bcd\");\n  assert_false_regexp(\"\\\\B\\\\w\\\\w\\\\w\\\\B\", \"abcd\");\n\n  // This is allowed in most regexp engines but in order to keep the\n  // grammar free of shift/reduce conflicts I've decided not supporting\n  // it. Users can use the (abc|) form instead.\n  assert_regexp_syntax_error(\"(|abc)ef\");\n\n  assert_true_regexp(\"((a)(b)c)(d)\", \"abcd\", \"abcd\");\n  assert_true_regexp(\"(a|b)c*d\", \"abcd\", \"bcd\");\n  assert_true_regexp(\"(ab|ab*)bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"a([bc]*)c*\", \"abc\", \"abc\");\n  assert_true_regexp(\"a([bc]*)c*\", \"ac\", \"ac\");\n  assert_true_regexp(\"a([bc]*)c*\", \"a\", \"a\");\n  assert_true_regexp(\"a([bc]*)(c*d)\", \"abcd\", \"abcd\");\n  assert_true_regexp(\"a([bc]+)(c*d)\", \"abcd\", \"abcd\");\n  assert_true_regexp(\"a([bc]*)(c+d)\", \"abcd\", \"abcd\");\n  assert_true_regexp(\"a[bcd]*dcdcde\", \"adcdcde\", \"adcdcde\");\n  assert_false_regexp(\"a[bcd]+dcdcde\", \"adcdcde\");\n  assert_true_regexp(\"\\\\((.*), (.*)\\\\)\", \"(a, b)\", \"(a, b)\");\n  assert_true_regexp(\"abc|123$\", \"abcx\", \"abc\");\n  assert_false_regexp(\"abc|123$\", \"123x\");\n  assert_true_regexp(\"abc|^123\", \"123\", \"123\");\n  assert_false_regexp(\"abc|^123\", \"x123\");\n  assert_true_regexp(\"^abc$\", \"abc\", \"abc\");\n  assert_false_regexp(\"^abc$\", \"abcc\");\n  assert_true_regexp(\"^abc\", \"abcc\", \"abc\");\n  assert_false_regexp(\"^abc$\", \"aabc\");\n  assert_false_regexp(\"abc^\", \"abc\");\n  assert_false_regexp(\"ab^c\", \"abc\");\n  assert_false_regexp(\"a^bcdef\", \"abcdef\")\n  assert_true_regexp(\"abc$\", \"aabc\", \"abc\");\n  assert_false_regexp(\"$abc\", \"abc\");\n  assert_true_regexp(\"(a|a$)bcd\", \"abcd\", \"abcd\");\n  assert_false_regexp(\"(a$|a$)bcd\", \"abcd\");\n  assert_false_regexp(\"(abc$|ab$)\", \"abcd\");\n  assert_true_regexp(\"^a(bc+|b[eh])g|.h$\", \"abhg\", \"abhg\");\n  assert_true_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"effgz\", \"effgz\");\n  assert_true_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"ij\", \"ij\");\n  assert_false_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"effg\");\n  assert_false_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"bcdd\");\n  assert_true_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"reffgz\", \"effgz\");\n\n  // Test case for issue #324\n  assert_true_regexp(\"whatever|   x.   x\", \"   xy   x\", \"   xy   x\");\n\n  // Test case for issue #503, \\x without two following hex-digits\n  assert_regexp_syntax_error(\"\\\\x0\");\n  assert_regexp_syntax_error(\"\\\\x\");\n\n  assert_regexp_syntax_error(\"x{0,0}\");\n  assert_regexp_syntax_error(\"x{0}\");\n\n  assert_regexp_syntax_error(\"\\\\xxy\");\n\n  // Test case for issue #682\n  assert_true_regexp(\"(a|\\\\b)[a]{1,}\", \"aaaa\", \"aaaa\");\n\n  // Test for integer overflow in repeat interval\n  assert_regexp_syntax_error(\"a{2977952116}\");\n\n  assert_error(\n      \"rule test { strings: $a = /a\\\\/ condition: $a }\",\n      ERROR_SYNTAX_ERROR);\n\n  assert_error(\n      \"rule test { strings: $a = /[a\\\\/ condition: $a }\",\n      ERROR_SYNTAX_ERROR);\n\n  // Test case for issue #996\n  assert_error(\n      \"rule test {strings:$=/.{,}? /\",\n      ERROR_SYNTAX_ERROR);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = /MZ.{300,}t/ \\\n        condition: !a == 317 }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = /MZ.{300,}?t/ \\\n        condition: !a == 314 }\",\n      PE32_FILE);\n\n  assert_false_rule(\n      \"rule test { strings: $a = /abc[^d]/ nocase condition: $a }\",\n      \"abcd\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /abc[^d]/ condition: $a }\",\n      \"abcd\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /abc[^D]/ nocase condition: $a }\",\n      \"abcd\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /abc[^D]/ condition: $a }\",\n      \"abcd\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /abc[^f]/ nocase condition: $a }\",\n      \"abcd\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /abc[^f]/ condition: $a }\",\n      \"abcd\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /abc[^F]/ nocase condition: $a }\",\n      \"abcd\");\n\n  assert_true_rule(\n       \"rule test { strings: $a = /abc[^F]/ condition: $a }\",\n       \"abcd\");\n}\n",
    "target": 0,
    "idx": 2011753
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "static void\nproc_plaintext( CTX c, PACKET *pkt )\n{\n  PKT_plaintext *pt = pkt->pkt.plaintext;\n  int any, clearsig, rc;\n  kbnode_t n;\n  unsigned char *extrahash;\n  size_t extrahashlen;\n\n  /* This is a literal data packet.  Bump a counter for later checks.  */\n  literals_seen++;\n\n  if (pt->namelen == 8 && !memcmp( pt->name, \"_CONSOLE\", 8))\n    log_info (_(\"Note: sender requested \\\"for-your-eyes-only\\\"\\n\"));\n  else if (opt.verbose)\n    {\n      /* We don't use print_utf8_buffer because that would require a\n       * string change which we don't want in 2.2.  It is also not\n       * clear whether the filename is always utf-8 encoded.  */\n      char *tmp = make_printable_string (pt->name, pt->namelen, 0);\n      log_info (_(\"original file name='%.*s'\\n\"), (int)strlen (tmp), tmp);\n      xfree (tmp);\n    }\n\n  free_md_filter_context (&c->mfx);\n  if (gcry_md_open (&c->mfx.md, 0, 0))\n    BUG ();\n  /* fixme: we may need to push the textfilter if we have sigclass 1\n   * and no armoring - Not yet tested\n   * Hmmm, why don't we need it at all if we have sigclass 1\n   * Should we assume that plaintext in mode 't' has always sigclass 1??\n   * See: Russ Allbery's mail 1999-02-09\n   */\n  any = clearsig = 0;\n  for (n=c->list; n; n = n->next )\n    {\n      if (n->pkt->pkttype == PKT_ONEPASS_SIG)\n        {\n          /* The onepass signature case. */\n          if (n->pkt->pkt.onepass_sig->digest_algo)\n            {\n              if (!opt.skip_verify)\n                gcry_md_enable (c->mfx.md,\n                                n->pkt->pkt.onepass_sig->digest_algo);\n\n              any = 1;\n            }\n        }\n      else if (n->pkt->pkttype == PKT_GPG_CONTROL\n               && n->pkt->pkt.gpg_control->control == CTRLPKT_CLEARSIGN_START)\n        {\n          /* The clearsigned message case. */\n          size_t datalen = n->pkt->pkt.gpg_control->datalen;\n          const byte *data = n->pkt->pkt.gpg_control->data;\n\n          /* Check that we have at least the sigclass and one hash.  */\n          if  (datalen < 2)\n            log_fatal (\"invalid control packet CTRLPKT_CLEARSIGN_START\\n\");\n          /* Note that we don't set the clearsig flag for not-dash-escaped\n           * documents.  */\n          clearsig = (*data == 0x01);\n          for (data++, datalen--; datalen; datalen--, data++)\n            if (!opt.skip_verify)\n              gcry_md_enable (c->mfx.md, *data);\n          any = 1;\n          break;  /* Stop here as one-pass signature packets are not\n                     expected.  */\n        }\n      else if (n->pkt->pkttype == PKT_SIGNATURE)\n        {\n          /* The SIG+LITERAL case that PGP used to use.  */\n          if (!opt.skip_verify)\n            gcry_md_enable (c->mfx.md, n->pkt->pkt.signature->digest_algo);\n          any = 1;\n        }\n    }\n\n  if (!any && !opt.skip_verify && !have_seen_pkt_encrypted_aead(c))\n    {\n      /* This is for the old GPG LITERAL+SIG case.  It's not legal\n         according to 2440, so hopefully it won't come up that often.\n         There is no good way to specify what algorithms to use in\n         that case, so these there are the historical answer. */\n\tgcry_md_enable (c->mfx.md, DIGEST_ALGO_RMD160);\n\tgcry_md_enable (c->mfx.md, DIGEST_ALGO_SHA1);\n    }\n  if (DBG_HASHING)\n    {\n      gcry_md_debug (c->mfx.md, \"verify\");\n      if (c->mfx.md2)\n        gcry_md_debug (c->mfx.md2, \"verify2\");\n    }\n\n  rc=0;\n\n  if (literals_seen > 1)\n    {\n      log_info (_(\"WARNING: multiple plaintexts seen\\n\"));\n\n      write_status_text (STATUS_ERROR, \"proc_pkt.plaintext 89_BAD_DATA\");\n      log_inc_errorcount ();\n      rc = gpg_error (GPG_ERR_UNEXPECTED);\n    }\n\n  if (!rc)\n    {\n      /* It we are in --verify mode, we do not want to output the\n       * signed text.  However, if --output is also used we do what\n       * has been requested and write out the signed data.  */\n      rc = handle_plaintext (pt, &c->mfx,\n                             (opt.outfp || opt.outfile)? 0 :  c->sigs_only,\n                             clearsig);\n      if (gpg_err_code (rc) == GPG_ERR_EACCES && !c->sigs_only)\n        {\n          /* Can't write output but we hash it anyway to check the\n             signature. */\n          rc = handle_plaintext( pt, &c->mfx, 1, clearsig );\n        }\n    }\n\n  if (rc)\n    log_error (\"handle plaintext failed: %s\\n\", gpg_strerror (rc));\n\n  /* We add a marker control packet instead of the plaintext packet.\n   * This is so that we can later detect invalid packet sequences.\n   * The apcket is further used to convey extra data from the\n   * plaintext packet to the signature verification. */\n  extrahash = xtrymalloc (6 + pt->namelen);\n  if (!extrahash)\n    {\n      /* No way to return an error.  */\n      rc = gpg_error_from_syserror ();\n      log_error (\"malloc failed in %s: %s\\n\", __func__, gpg_strerror (rc));\n      extrahashlen = 0;\n    }\n  else\n    {\n      extrahash[0] = pt->mode;\n      extrahash[1] = pt->namelen;\n      if (pt->namelen)\n        memcpy (extrahash+2, pt->name, pt->namelen);\n      extrahashlen = 2 + pt->namelen;\n      extrahash[extrahashlen++] = pt->timestamp >> 24;\n      extrahash[extrahashlen++] = pt->timestamp >> 16;\n      extrahash[extrahashlen++] = pt->timestamp >>  8;\n      extrahash[extrahashlen++] = pt->timestamp      ;\n    }\n\n  free_packet (pkt, NULL);\n  c->last_was_session_key = 0;\n\n  n = new_kbnode (create_gpg_control (CTRLPKT_PLAINTEXT_MARK,\n                                      extrahash, extrahashlen));\n  xfree (extrahash);\n  if (c->list)\n    add_kbnode (c->list, n);\n  else\n    c->list = n;\n}\n",
    "target": 0,
    "idx": 2013730
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "static int read_chunks_before_idat(spng_ctx *ctx)\n{\n    if(ctx == NULL) return 1;\n    if(ctx->data == NULL) return 1;\n    if(!ctx->valid_state) return SPNG_EBADSTATE;\n\n    int ret, discard = 0;\n    const unsigned char *data;\n    struct spng_chunk chunk;\n\n    chunk.offset = 8;\n    chunk.length = 13;\n    size_t sizeof_sig_ihdr = 29;\n\n    ret = read_data(ctx, sizeof_sig_ihdr);\n    if(ret) return ret;\n\n    data = ctx->data;\n\n    uint8_t signature[8] = { 137, 80, 78, 71, 13, 10, 26, 10 };\n    if(memcmp(data, signature, sizeof(signature))) return SPNG_ESIGNATURE;\n\n    chunk.length = read_u32(data + 8);\n    memcpy(&chunk.type, data + 12, 4);\n\n    if(chunk.length != 13) return SPNG_EIHDR_SIZE;\n    if(memcmp(chunk.type, type_ihdr, 4)) return SPNG_ENOIHDR;\n\n    ctx->cur_actual_crc = crc32(0, NULL, 0);\n    ctx->cur_actual_crc = crc32(ctx->cur_actual_crc, data + 12, 17);\n\n    ctx->ihdr.width = read_u32(data + 16);\n    ctx->ihdr.height = read_u32(data + 20);\n    memcpy(&ctx->ihdr.bit_depth, data + 24, 1);\n    memcpy(&ctx->ihdr.color_type, data + 25, 1);\n    memcpy(&ctx->ihdr.compression_method, data + 26, 1);\n    memcpy(&ctx->ihdr.filter_method, data + 27, 1);\n    memcpy(&ctx->ihdr.interlace_method, data + 28, 1);\n\n    if(!ctx->max_width) ctx->max_width = png_u32max;\n    if(!ctx->max_height) ctx->max_height = png_u32max;\n\n    ret = check_ihdr(&ctx->ihdr, ctx->max_width, ctx->max_height);\n    if(ret) return ret;\n\n    ctx->file.ihdr = 1;\n    ctx->stored.ihdr = 1;\n\n    struct spng_chunk_bitfield stored;\n    memcpy(&stored, &ctx->stored, sizeof(struct spng_chunk_bitfield));\n\n    while( !(ret = read_header(ctx, &discard)))\n    {\n        if(discard)\n        {\n            memcpy(&ctx->stored, &stored, sizeof(struct spng_chunk_bitfield));\n        }\n\n        memcpy(&stored, &ctx->stored, sizeof(struct spng_chunk_bitfield));\n\n        memcpy(&chunk, &ctx->current_chunk, sizeof(struct spng_chunk));\n\n        if(!memcmp(chunk.type, type_idat, 4))\n        {\n            memcpy(&ctx->first_idat, &chunk, sizeof(struct spng_chunk));\n            return 0;\n        }\n\n        if(!chunk_fits_in_cache(ctx, &ctx->chunk_cache_usage))\n        {\n            ret = discard_chunk_bytes(ctx, chunk.length);\n            if(ret) return ret;\n            continue;\n        }\n\n        ret = read_chunk_bytes(ctx, chunk.length);\n        if(ret) return ret;\n\n        data = ctx->data;\n\n        if(is_critical_chunk(&chunk))\n        {\n            if(!memcmp(chunk.type, type_plte, 4))\n            {\n                if(chunk.length % 3 != 0) return SPNG_ECHUNK_SIZE;\n\n                ctx->plte.n_entries = chunk.length / 3;\n\n                if(check_plte(&ctx->plte, &ctx->ihdr)) return SPNG_ECHUNK_SIZE; /* XXX: EPLTE? */\n\n                size_t i;\n                for(i=0; i < ctx->plte.n_entries; i++)\n                {\n                    memcpy(&ctx->plte.entries[i].red,   data + i * 3, 1);\n                    memcpy(&ctx->plte.entries[i].green, data + i * 3 + 1, 1);\n                    memcpy(&ctx->plte.entries[i].blue,  data + i * 3 + 2, 1);\n                }\n\n                ctx->plte_offset = chunk.offset;\n\n                ctx->file.plte = 1;\n            }\n            else if(!memcmp(chunk.type, type_iend, 4)) return SPNG_ECHUNK_POS;\n            else if(!memcmp(chunk.type, type_ihdr, 4)) return SPNG_ECHUNK_POS;\n            else return SPNG_ECHUNK_UNKNOWN_CRITICAL;\n        }\n        else if(!memcmp(chunk.type, type_chrm, 4)) /* Ancillary chunks */\n        {\n            if(ctx->file.plte && chunk.offset > ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.chrm) return SPNG_EDUP_CHRM;\n\n            if(chunk.length != 32) return SPNG_ECHUNK_SIZE;\n\n            ctx->chrm_int.white_point_x = read_u32(data);\n            ctx->chrm_int.white_point_y = read_u32(data + 4);\n            ctx->chrm_int.red_x = read_u32(data + 8);\n            ctx->chrm_int.red_y = read_u32(data + 12);\n            ctx->chrm_int.green_x = read_u32(data + 16);\n            ctx->chrm_int.green_y = read_u32(data + 20);\n            ctx->chrm_int.blue_x = read_u32(data + 24);\n            ctx->chrm_int.blue_y = read_u32(data + 28);\n\n            if(check_chrm_int(&ctx->chrm_int)) return SPNG_ECHRM;\n\n            ctx->file.chrm = 1;\n            ctx->stored.chrm = 1;\n        }\n        else if(!memcmp(chunk.type, type_gama, 4))\n        {\n            if(ctx->file.plte && chunk.offset > ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.gama) return SPNG_EDUP_GAMA;\n\n            if(chunk.length != 4) return SPNG_ECHUNK_SIZE;\n\n            ctx->gama = read_u32(data);\n\n            if(!ctx->gama) return SPNG_EGAMA;\n            if(ctx->gama > png_u32max) return SPNG_EGAMA;\n\n            ctx->file.gama = 1;\n            ctx->stored.gama = 1;\n        }\n        else if(!memcmp(chunk.type, type_iccp, 4))\n        {\n            if(ctx->file.plte && chunk.offset > ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.iccp) return SPNG_EDUP_ICCP;\n            if(!chunk.length) return SPNG_ECHUNK_SIZE;\n\n            continue; /* XXX: https://gitlab.com/randy408/libspng/issues/31 */\n        }\n        else if(!memcmp(chunk.type, type_sbit, 4))\n        {\n            if(ctx->file.plte && chunk.offset > ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.sbit) return SPNG_EDUP_SBIT;\n\n            if(ctx->ihdr.color_type == 0)\n            {\n                if(chunk.length != 1) return SPNG_ECHUNK_SIZE;\n\n                memcpy(&ctx->sbit.grayscale_bits, data, 1);\n            }\n            else if(ctx->ihdr.color_type == 2 || ctx->ihdr.color_type == 3)\n            {\n                if(chunk.length != 3) return SPNG_ECHUNK_SIZE;\n\n                memcpy(&ctx->sbit.red_bits, data, 1);\n                memcpy(&ctx->sbit.green_bits, data + 1 , 1);\n                memcpy(&ctx->sbit.blue_bits, data + 2, 1);\n            }\n            else if(ctx->ihdr.color_type == 4)\n            {\n                if(chunk.length != 2) return SPNG_ECHUNK_SIZE;\n\n                memcpy(&ctx->sbit.grayscale_bits, data, 1);\n                memcpy(&ctx->sbit.alpha_bits, data + 1, 1);\n            }\n            else if(ctx->ihdr.color_type == 6)\n            {\n                if(chunk.length != 4) return SPNG_ECHUNK_SIZE;\n\n                memcpy(&ctx->sbit.red_bits, data, 1);\n                memcpy(&ctx->sbit.green_bits, data + 1, 1);\n                memcpy(&ctx->sbit.blue_bits, data + 2, 1);\n                memcpy(&ctx->sbit.alpha_bits, data + 3, 1);\n            }\n\n            if(check_sbit(&ctx->sbit, &ctx->ihdr)) return SPNG_ESBIT;\n\n            ctx->file.sbit = 1;\n            ctx->stored.sbit = 1;\n        }\n        else if(!memcmp(chunk.type, type_srgb, 4))\n        {\n            if(ctx->file.plte && chunk.offset > ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.srgb) return SPNG_EDUP_SRGB;\n\n            if(chunk.length != 1) return SPNG_ECHUNK_SIZE;\n\n            memcpy(&ctx->srgb_rendering_intent, data, 1);\n\n            if(ctx->srgb_rendering_intent > 3) return SPNG_ESRGB;\n\n            ctx->file.srgb = 1;\n            ctx->stored.srgb = 1;\n        }\n        else if(!memcmp(chunk.type, type_bkgd, 4))\n        {\n            if(ctx->file.plte && chunk.offset < ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.bkgd) return SPNG_EDUP_BKGD;\n\n            uint16_t mask = ~0;\n            if(ctx->ihdr.bit_depth < 16) mask = (1 << ctx->ihdr.bit_depth) - 1;\n\n            if(ctx->ihdr.color_type == 0 || ctx->ihdr.color_type == 4)\n            {\n                if(chunk.length != 2) return SPNG_ECHUNK_SIZE;\n\n                ctx->bkgd.gray = read_u16(data) & mask;\n            }\n            else if(ctx->ihdr.color_type == 2 || ctx->ihdr.color_type == 6)\n            {\n                if(chunk.length != 6) return SPNG_ECHUNK_SIZE;\n\n                ctx->bkgd.red = read_u16(data) & mask;\n                ctx->bkgd.green = read_u16(data + 2) & mask;\n                ctx->bkgd.blue = read_u16(data + 4) & mask;\n            }\n            else if(ctx->ihdr.color_type == 3)\n            {\n                if(chunk.length != 1) return SPNG_ECHUNK_SIZE;\n                if(!ctx->file.plte) return SPNG_EBKGD_NO_PLTE;\n\n                memcpy(&ctx->bkgd.plte_index, data, 1);\n                if(ctx->bkgd.plte_index >= ctx->plte.n_entries) return SPNG_EBKGD_PLTE_IDX;\n            }\n\n            ctx->file.bkgd = 1;\n            ctx->stored.bkgd = 1;\n        }\n        else if(!memcmp(chunk.type, type_trns, 4))\n        {\n            if(ctx->file.plte && chunk.offset < ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.trns) return SPNG_EDUP_TRNS;\n            if(!chunk.length) return SPNG_ECHUNK_SIZE;\n\n            uint16_t mask = ~0;\n            if(ctx->ihdr.bit_depth < 16) mask = (1 << ctx->ihdr.bit_depth) - 1;\n\n            if(ctx->ihdr.color_type == 0)\n            {\n                if(chunk.length != 2) return SPNG_ECHUNK_SIZE;\n\n                ctx->trns.gray = read_u16(data) & mask;\n            }\n            else if(ctx->ihdr.color_type == 2)\n            {\n                if(chunk.length != 6) return SPNG_ECHUNK_SIZE;\n\n                ctx->trns.red = read_u16(data) & mask;\n                ctx->trns.green = read_u16(data + 2) & mask;\n                ctx->trns.blue = read_u16(data + 4) & mask;\n            }\n            else if(ctx->ihdr.color_type == 3)\n            {\n                if(chunk.length > ctx->plte.n_entries) return SPNG_ECHUNK_SIZE;\n                if(!ctx->file.plte) return SPNG_ETRNS_NO_PLTE;\n\n                size_t k;\n                for(k=0; k < chunk.length; k++)\n                {\n                    memcpy(&ctx->trns.type3_alpha[k], data + k, 1);\n                }\n                ctx->trns.n_type3_entries = chunk.length;\n            }\n            else return SPNG_ETRNS_COLOR_TYPE;\n\n            ctx->file.trns = 1;\n            ctx->stored.trns = 1;\n        }\n        else if(!memcmp(chunk.type, type_hist, 4))\n        {\n            if(!ctx->file.plte) return SPNG_EHIST_NO_PLTE;\n            if(chunk.offset < ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.hist) return SPNG_EDUP_HIST;\n\n            if( (chunk.length / 2) != (ctx->plte.n_entries) ) return SPNG_ECHUNK_SIZE;\n\n            size_t k;\n            for(k=0; k < (chunk.length / 2); k++)\n            {\n                ctx->hist.frequency[k] = read_u16(data + k*2);\n            }\n\n            ctx->file.hist = 1;\n            ctx->stored.hist = 1;\n        }\n        else if(!memcmp(chunk.type, type_phys, 4))\n        {\n            if(ctx->file.phys) return SPNG_EDUP_PHYS;\n\n            if(chunk.length != 9) return SPNG_ECHUNK_SIZE;\n\n            ctx->phys.ppu_x = read_u32(data);\n            ctx->phys.ppu_y = read_u32(data + 4);\n            memcpy(&ctx->phys.unit_specifier, data + 8, 1);\n\n            if(check_phys(&ctx->phys)) return SPNG_EPHYS;\n\n            ctx->file.phys = 1;\n            ctx->stored.phys = 1;\n        }\n        else if(!memcmp(chunk.type, type_time, 4))\n        {\n            if(ctx->file.time) return SPNG_EDUP_TIME;\n\n            if(chunk.length != 7) return SPNG_ECHUNK_SIZE;\n\n            struct spng_time time;\n\n            time.year = read_u16(data);\n            memcpy(&time.month, data + 2, 1);\n            memcpy(&time.day, data + 3, 1);\n            memcpy(&time.hour, data + 4, 1);\n            memcpy(&time.minute, data + 5, 1);\n            memcpy(&time.second, data + 6, 1);\n\n            if(check_time(&time)) return SPNG_ETIME;\n\n            ctx->file.time = 1;\n\n            if(!ctx->user.time) memcpy(&ctx->time, &time, sizeof(struct spng_time));\n\n            ctx->stored.time = 1;\n        }\n        else if(!memcmp(chunk.type, type_offs, 4))\n        {\n            if(ctx->file.offs) return SPNG_EDUP_OFFS;\n\n            if(chunk.length != 9) return SPNG_ECHUNK_SIZE;\n\n            ctx->offs.x = read_s32(data);\n            ctx->offs.y = read_s32(data + 4);\n            memcpy(&ctx->offs.unit_specifier, data + 8, 1);\n\n            if(check_offs(&ctx->offs)) return SPNG_EOFFS;\n\n            ctx->file.offs = 1;\n            ctx->stored.offs = 1;\n        }\n        else if(!memcmp(chunk.type, type_splt, 4))\n        {\n            if(ctx->user.splt) continue; /* XXX: should check profile names for uniqueness */\n            if(!chunk.length) return SPNG_ECHUNK_SIZE;\n\n            ctx->file.splt = 1;\n\n            if(!ctx->stored.splt)\n            {\n                ctx->n_splt = 1;\n                ctx->splt_list = spng__calloc(ctx, 1, sizeof(struct spng_splt));\n                if(ctx->splt_list == NULL) return SPNG_EMEM;\n            }\n            else\n            {\n                ctx->n_splt++;\n                if(ctx->n_splt < 1) return SPNG_EOVERFLOW;\n                if(sizeof(struct spng_splt) > SIZE_MAX / ctx->n_splt) return SPNG_EOVERFLOW;\n\n                void *buf = spng__realloc(ctx, ctx->splt_list, ctx->n_splt * sizeof(struct spng_splt));\n                if(buf == NULL) return SPNG_EMEM;\n                ctx->splt_list = buf;\n                memset(&ctx->splt_list[ctx->n_splt - 1], 0, sizeof(struct spng_splt));\n            }\n\n            uint32_t i = ctx->n_splt - 1;\n\n            size_t keyword_len = chunk.length > 80 ? 80 : chunk.length;\n            char *keyword_nul = memchr(data, '\\0', keyword_len);\n            if(keyword_nul == NULL) return SPNG_ESPLT_NAME;\n\n            memcpy(&ctx->splt_list[i].name, data, keyword_len);\n\n            if(check_png_keyword(ctx->splt_list[i].name)) return SPNG_ESPLT_NAME;\n\n            keyword_len = strlen(ctx->splt_list[i].name);\n\n            if( (chunk.length - keyword_len - 1) ==  0) return SPNG_ECHUNK_SIZE;\n\n            memcpy(&ctx->splt_list[i].sample_depth, data + keyword_len + 1, 1);\n\n            if(ctx->n_splt > 1)\n            {\n                uint32_t j;\n                for(j=0; j < i; j++)\n                {\n                    if(!strcmp(ctx->splt_list[j].name, ctx->splt_list[i].name)) return SPNG_ESPLT_DUP_NAME;\n                }\n            }\n\n            if(ctx->splt_list[i].sample_depth == 16)\n            {\n                if( (chunk.length - keyword_len - 2) % 10 != 0) return SPNG_ECHUNK_SIZE;\n                ctx->splt_list[i].n_entries = (chunk.length - keyword_len - 2) / 10;\n            }\n            else if(ctx->splt_list[i].sample_depth == 8)\n            {\n                if( (chunk.length - keyword_len - 2) % 6 != 0) return SPNG_ECHUNK_SIZE;\n                ctx->splt_list[i].n_entries = (chunk.length - keyword_len - 2) / 6;\n            }\n            else return SPNG_ESPLT_DEPTH;\n\n            if(ctx->splt_list[i].n_entries == 0) return SPNG_ECHUNK_SIZE;\n            if(sizeof(struct spng_splt_entry) > SIZE_MAX / ctx->splt_list[i].n_entries) return SPNG_EOVERFLOW;\n\n            ctx->splt_list[i].entries = spng__malloc(ctx, sizeof(struct spng_splt_entry) * ctx->splt_list[i].n_entries);\n            if(ctx->splt_list[i].entries == NULL) return SPNG_EMEM;\n\n            const unsigned char *splt = data + keyword_len + 2;\n\n            size_t k;\n            if(ctx->splt_list[i].sample_depth == 16)\n            {\n                for(k=0; k < ctx->splt_list[i].n_entries; k++)\n                {\n                    ctx->splt_list[i].entries[k].red = read_u16(splt + k * 10);\n                    ctx->splt_list[i].entries[k].green = read_u16(splt + k * 10 + 2);\n                    ctx->splt_list[i].entries[k].blue = read_u16(splt + k * 10 + 4);\n                    ctx->splt_list[i].entries[k].alpha = read_u16(splt + k * 10 + 6);\n                    ctx->splt_list[i].entries[k].frequency = read_u16(splt + k * 10 + 8);\n                }\n            }\n            else if(ctx->splt_list[i].sample_depth == 8)\n            {\n                for(k=0; k < ctx->splt_list[i].n_entries; k++)\n                {\n                    uint8_t red, green, blue, alpha;\n                    memcpy(&red,   splt + k * 6, 1);\n                    memcpy(&green, splt + k * 6 + 1, 1);\n                    memcpy(&blue,  splt + k * 6 + 2, 1);\n                    memcpy(&alpha, splt + k * 6 + 3, 1);\n                    ctx->splt_list[i].entries[k].frequency = read_u16(splt + k * 6 + 4);\n\n                    ctx->splt_list[i].entries[k].red = red;\n                    ctx->splt_list[i].entries[k].green = green;\n                    ctx->splt_list[i].entries[k].blue = blue;\n                    ctx->splt_list[i].entries[k].alpha = alpha;\n                }\n            }\n\n            ctx->stored.splt = 1;\n        }\n        else if(!memcmp(chunk.type, type_text, 4) ||\n                !memcmp(chunk.type, type_ztxt, 4) ||\n                !memcmp(chunk.type, type_itxt, 4))\n        {\n            ctx->file.text = 1;\n\n            continue; /* XXX: https://gitlab.com/randy408/libspng/issues/31 */\n        }\n        else if(!memcmp(chunk.type, type_exif, 4))\n        {\n            if(ctx->file.exif) return SPNG_EDUP_EXIF;\n\n            ctx->file.exif = 1;\n\n            if(!chunk.length) return SPNG_EEXIF;\n\n            struct spng_exif exif;\n\n            exif.data = spng__malloc(ctx, chunk.length);\n            if(exif.data == NULL) return SPNG_EMEM;\n\n            memcpy(exif.data, data, chunk.length);\n            exif.length = chunk.length;\n\n            if(check_exif(&exif))\n            {\n                spng__free(ctx, exif.data);\n                return SPNG_EEXIF;\n            }\n\n            if(!ctx->user.exif) memcpy(&ctx->exif, &exif, sizeof(struct spng_exif));\n            else spng__free(ctx, exif.data);\n\n            ctx->stored.exif = 1;\n        }\n    }\n\n    return ret;\n}\n",
    "target": 0,
    "idx": 2016051
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "static int read_chunks_before_idat(spng_ctx *ctx)\n{\n    if(ctx == NULL) return 1;\n    if(ctx->data == NULL) return 1;\n    if(!ctx->valid_state) return SPNG_EBADSTATE;\n\n    int ret, discard = 0;\n    const unsigned char *data;\n    struct spng_chunk chunk;\n\n    chunk.offset = 8;\n    chunk.length = 13;\n    size_t sizeof_sig_ihdr = 29;\n\n    ret = read_data(ctx, sizeof_sig_ihdr);\n    if(ret) return ret;\n\n    data = ctx->data;\n\n    uint8_t signature[8] = { 137, 80, 78, 71, 13, 10, 26, 10 };\n    if(memcmp(data, signature, sizeof(signature))) return SPNG_ESIGNATURE;\n\n    chunk.length = read_u32(data + 8);\n    memcpy(&chunk.type, data + 12, 4);\n\n    if(chunk.length != 13) return SPNG_EIHDR_SIZE;\n    if(memcmp(chunk.type, type_ihdr, 4)) return SPNG_ENOIHDR;\n\n    ctx->cur_actual_crc = crc32(0, NULL, 0);\n    ctx->cur_actual_crc = crc32(ctx->cur_actual_crc, data + 12, 17);\n\n    ctx->ihdr.width = read_u32(data + 16);\n    ctx->ihdr.height = read_u32(data + 20);\n    memcpy(&ctx->ihdr.bit_depth, data + 24, 1);\n    memcpy(&ctx->ihdr.color_type, data + 25, 1);\n    memcpy(&ctx->ihdr.compression_method, data + 26, 1);\n    memcpy(&ctx->ihdr.filter_method, data + 27, 1);\n    memcpy(&ctx->ihdr.interlace_method, data + 28, 1);\n\n    if(!ctx->max_width) ctx->max_width = png_u32max;\n    if(!ctx->max_height) ctx->max_height = png_u32max;\n\n    ret = check_ihdr(&ctx->ihdr, ctx->max_width, ctx->max_height);\n    if(ret) return ret;\n\n    ctx->file.ihdr = 1;\n    ctx->stored.ihdr = 1;\n\n    struct spng_chunk_bitfield stored;\n    memcpy(&stored, &ctx->stored, sizeof(struct spng_chunk_bitfield));\n\n    while( !(ret = read_header(ctx, &discard)))\n    {\n        if(discard)\n        {\n            memcpy(&ctx->stored, &stored, sizeof(struct spng_chunk_bitfield));\n        }\n\n        memcpy(&stored, &ctx->stored, sizeof(struct spng_chunk_bitfield));\n\n        memcpy(&chunk, &ctx->current_chunk, sizeof(struct spng_chunk));\n\n        if(!memcmp(chunk.type, type_idat, 4))\n        {\n            memcpy(&ctx->first_idat, &chunk, sizeof(struct spng_chunk));\n            return 0;\n        }\n\n        if(!chunk_fits_in_cache(ctx, &ctx->chunk_cache_usage))\n        {\n            ret = discard_chunk_bytes(ctx, chunk.length);\n            if(ret) return ret;\n            continue;\n        }\n\n        ret = read_chunk_bytes(ctx, chunk.length);\n        if(ret) return ret;\n\n        data = ctx->data;\n\n        if(is_critical_chunk(&chunk))\n        {\n            if(!memcmp(chunk.type, type_plte, 4))\n            {\n                if(chunk.length % 3 != 0) return SPNG_ECHUNK_SIZE;\n\n                ctx->plte.n_entries = chunk.length / 3;\n\n                if(check_plte(&ctx->plte, &ctx->ihdr)) return SPNG_ECHUNK_SIZE; /* XXX: EPLTE? */\n\n                size_t i;\n                for(i=0; i < ctx->plte.n_entries; i++)\n                {\n                    memcpy(&ctx->plte.entries[i].red,   data + i * 3, 1);\n                    memcpy(&ctx->plte.entries[i].green, data + i * 3 + 1, 1);\n                    memcpy(&ctx->plte.entries[i].blue,  data + i * 3 + 2, 1);\n                }\n\n                ctx->plte_offset = chunk.offset;\n\n                ctx->file.plte = 1;\n            }\n            else if(!memcmp(chunk.type, type_iend, 4)) return SPNG_ECHUNK_POS;\n            else if(!memcmp(chunk.type, type_ihdr, 4)) return SPNG_ECHUNK_POS;\n            else return SPNG_ECHUNK_UNKNOWN_CRITICAL;\n        }\n        else if(!memcmp(chunk.type, type_chrm, 4)) /* Ancillary chunks */\n        {\n            if(ctx->file.plte && chunk.offset > ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.chrm) return SPNG_EDUP_CHRM;\n\n            if(chunk.length != 32) return SPNG_ECHUNK_SIZE;\n\n            ctx->chrm_int.white_point_x = read_u32(data);\n            ctx->chrm_int.white_point_y = read_u32(data + 4);\n            ctx->chrm_int.red_x = read_u32(data + 8);\n            ctx->chrm_int.red_y = read_u32(data + 12);\n            ctx->chrm_int.green_x = read_u32(data + 16);\n            ctx->chrm_int.green_y = read_u32(data + 20);\n            ctx->chrm_int.blue_x = read_u32(data + 24);\n            ctx->chrm_int.blue_y = read_u32(data + 28);\n\n            if(check_chrm_int(&ctx->chrm_int)) return SPNG_ECHRM;\n\n            ctx->file.chrm = 1;\n            ctx->stored.chrm = 1;\n        }\n        else if(!memcmp(chunk.type, type_gama, 4))\n        {\n            if(ctx->file.plte && chunk.offset > ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.gama) return SPNG_EDUP_GAMA;\n\n            if(chunk.length != 4) return SPNG_ECHUNK_SIZE;\n\n            ctx->gama = read_u32(data);\n\n            if(!ctx->gama) return SPNG_EGAMA;\n            if(ctx->gama > png_u32max) return SPNG_EGAMA;\n\n            ctx->file.gama = 1;\n            ctx->stored.gama = 1;\n        }\n        else if(!memcmp(chunk.type, type_iccp, 4))\n        {\n            if(ctx->file.plte && chunk.offset > ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.iccp) return SPNG_EDUP_ICCP;\n            if(!chunk.length) return SPNG_ECHUNK_SIZE;\n\n            continue; /* XXX: https://gitlab.com/randy408/libspng/issues/31 */\n        }\n        else if(!memcmp(chunk.type, type_sbit, 4))\n        {\n            if(ctx->file.plte && chunk.offset > ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.sbit) return SPNG_EDUP_SBIT;\n\n            if(ctx->ihdr.color_type == 0)\n            {\n                if(chunk.length != 1) return SPNG_ECHUNK_SIZE;\n\n                memcpy(&ctx->sbit.grayscale_bits, data, 1);\n            }\n            else if(ctx->ihdr.color_type == 2 || ctx->ihdr.color_type == 3)\n            {\n                if(chunk.length != 3) return SPNG_ECHUNK_SIZE;\n\n                memcpy(&ctx->sbit.red_bits, data, 1);\n                memcpy(&ctx->sbit.green_bits, data + 1 , 1);\n                memcpy(&ctx->sbit.blue_bits, data + 2, 1);\n            }\n            else if(ctx->ihdr.color_type == 4)\n            {\n                if(chunk.length != 2) return SPNG_ECHUNK_SIZE;\n\n                memcpy(&ctx->sbit.grayscale_bits, data, 1);\n                memcpy(&ctx->sbit.alpha_bits, data + 1, 1);\n            }\n            else if(ctx->ihdr.color_type == 6)\n            {\n                if(chunk.length != 4) return SPNG_ECHUNK_SIZE;\n\n                memcpy(&ctx->sbit.red_bits, data, 1);\n                memcpy(&ctx->sbit.green_bits, data + 1, 1);\n                memcpy(&ctx->sbit.blue_bits, data + 2, 1);\n                memcpy(&ctx->sbit.alpha_bits, data + 3, 1);\n            }\n\n            if(check_sbit(&ctx->sbit, &ctx->ihdr)) return SPNG_ESBIT;\n\n            ctx->file.sbit = 1;\n            ctx->stored.sbit = 1;\n        }\n        else if(!memcmp(chunk.type, type_srgb, 4))\n        {\n            if(ctx->file.plte && chunk.offset > ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.srgb) return SPNG_EDUP_SRGB;\n\n            if(chunk.length != 1) return SPNG_ECHUNK_SIZE;\n\n            memcpy(&ctx->srgb_rendering_intent, data, 1);\n\n            if(ctx->srgb_rendering_intent > 3) return SPNG_ESRGB;\n\n            ctx->file.srgb = 1;\n            ctx->stored.srgb = 1;\n        }\n        else if(!memcmp(chunk.type, type_bkgd, 4))\n        {\n            if(ctx->file.plte && chunk.offset < ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.bkgd) return SPNG_EDUP_BKGD;\n\n            uint16_t mask = ~0;\n            if(ctx->ihdr.bit_depth < 16) mask = (1 << ctx->ihdr.bit_depth) - 1;\n\n            if(ctx->ihdr.color_type == 0 || ctx->ihdr.color_type == 4)\n            {\n                if(chunk.length != 2) return SPNG_ECHUNK_SIZE;\n\n                ctx->bkgd.gray = read_u16(data) & mask;\n            }\n            else if(ctx->ihdr.color_type == 2 || ctx->ihdr.color_type == 6)\n            {\n                if(chunk.length != 6) return SPNG_ECHUNK_SIZE;\n\n                ctx->bkgd.red = read_u16(data) & mask;\n                ctx->bkgd.green = read_u16(data + 2) & mask;\n                ctx->bkgd.blue = read_u16(data + 4) & mask;\n            }\n            else if(ctx->ihdr.color_type == 3)\n            {\n                if(chunk.length != 1) return SPNG_ECHUNK_SIZE;\n                if(!ctx->file.plte) return SPNG_EBKGD_NO_PLTE;\n\n                memcpy(&ctx->bkgd.plte_index, data, 1);\n                if(ctx->bkgd.plte_index >= ctx->plte.n_entries) return SPNG_EBKGD_PLTE_IDX;\n            }\n\n            ctx->file.bkgd = 1;\n            ctx->stored.bkgd = 1;\n        }\n        else if(!memcmp(chunk.type, type_trns, 4))\n        {\n            if(ctx->file.plte && chunk.offset < ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.trns) return SPNG_EDUP_TRNS;\n            if(!chunk.length) return SPNG_ECHUNK_SIZE;\n\n            uint16_t mask = ~0;\n            if(ctx->ihdr.bit_depth < 16) mask = (1 << ctx->ihdr.bit_depth) - 1;\n\n            if(ctx->ihdr.color_type == 0)\n            {\n                if(chunk.length != 2) return SPNG_ECHUNK_SIZE;\n\n                ctx->trns.gray = read_u16(data) & mask;\n            }\n            else if(ctx->ihdr.color_type == 2)\n            {\n                if(chunk.length != 6) return SPNG_ECHUNK_SIZE;\n\n                ctx->trns.red = read_u16(data) & mask;\n                ctx->trns.green = read_u16(data + 2) & mask;\n                ctx->trns.blue = read_u16(data + 4) & mask;\n            }\n            else if(ctx->ihdr.color_type == 3)\n            {\n                if(chunk.length > ctx->plte.n_entries) return SPNG_ECHUNK_SIZE;\n                if(!ctx->file.plte) return SPNG_ETRNS_NO_PLTE;\n\n                size_t k;\n                for(k=0; k < chunk.length; k++)\n                {\n                    memcpy(&ctx->trns.type3_alpha[k], data + k, 1);\n                }\n                ctx->trns.n_type3_entries = chunk.length;\n            }\n            else return SPNG_ETRNS_COLOR_TYPE;\n\n            ctx->file.trns = 1;\n            ctx->stored.trns = 1;\n        }\n        else if(!memcmp(chunk.type, type_hist, 4))\n        {\n            if(!ctx->file.plte) return SPNG_EHIST_NO_PLTE;\n            if(chunk.offset < ctx->plte_offset) return SPNG_ECHUNK_POS;\n            if(ctx->file.hist) return SPNG_EDUP_HIST;\n\n            if( (chunk.length / 2) != (ctx->plte.n_entries) ) return SPNG_ECHUNK_SIZE;\n\n            size_t k;\n            for(k=0; k < (chunk.length / 2); k++)\n            {\n                ctx->hist.frequency[k] = read_u16(data + k*2);\n            }\n\n            ctx->file.hist = 1;\n            ctx->stored.hist = 1;\n        }\n        else if(!memcmp(chunk.type, type_phys, 4))\n        {\n            if(ctx->file.phys) return SPNG_EDUP_PHYS;\n\n            if(chunk.length != 9) return SPNG_ECHUNK_SIZE;\n\n            ctx->phys.ppu_x = read_u32(data);\n            ctx->phys.ppu_y = read_u32(data + 4);\n            memcpy(&ctx->phys.unit_specifier, data + 8, 1);\n\n            if(check_phys(&ctx->phys)) return SPNG_EPHYS;\n\n            ctx->file.phys = 1;\n            ctx->stored.phys = 1;\n        }\n        else if(!memcmp(chunk.type, type_time, 4))\n        {\n            if(ctx->file.time) return SPNG_EDUP_TIME;\n\n            if(chunk.length != 7) return SPNG_ECHUNK_SIZE;\n\n            struct spng_time time;\n\n            time.year = read_u16(data);\n            memcpy(&time.month, data + 2, 1);\n            memcpy(&time.day, data + 3, 1);\n            memcpy(&time.hour, data + 4, 1);\n            memcpy(&time.minute, data + 5, 1);\n            memcpy(&time.second, data + 6, 1);\n\n            if(check_time(&time)) return SPNG_ETIME;\n\n            ctx->file.time = 1;\n\n            if(!ctx->user.time) memcpy(&ctx->time, &time, sizeof(struct spng_time));\n\n            ctx->stored.time = 1;\n        }\n        else if(!memcmp(chunk.type, type_offs, 4))\n        {\n            if(ctx->file.offs) return SPNG_EDUP_OFFS;\n\n            if(chunk.length != 9) return SPNG_ECHUNK_SIZE;\n\n            ctx->offs.x = read_s32(data);\n            ctx->offs.y = read_s32(data + 4);\n            memcpy(&ctx->offs.unit_specifier, data + 8, 1);\n\n            if(check_offs(&ctx->offs)) return SPNG_EOFFS;\n\n            ctx->file.offs = 1;\n            ctx->stored.offs = 1;\n        }\n        else if(!memcmp(chunk.type, type_splt, 4))\n        {\n            if(ctx->user.splt) continue; /* XXX: should check profile names for uniqueness */\n            if(!chunk.length) return SPNG_ECHUNK_SIZE;\n\n            ctx->file.splt = 1;\n\n            if(!ctx->stored.splt)\n            {\n                ctx->n_splt = 1;\n                ctx->splt_list = spng__calloc(ctx, 1, sizeof(struct spng_splt));\n                if(ctx->splt_list == NULL) return SPNG_EMEM;\n            }\n            else\n            {\n                ctx->n_splt++;\n                if(ctx->n_splt < 1) return SPNG_EOVERFLOW;\n                if(sizeof(struct spng_splt) > SIZE_MAX / ctx->n_splt) return SPNG_EOVERFLOW;\n\n                void *buf = spng__realloc(ctx, ctx->splt_list, ctx->n_splt * sizeof(struct spng_splt));\n                if(buf == NULL) return SPNG_EMEM;\n                ctx->splt_list = buf;\n                memset(&ctx->splt_list[ctx->n_splt - 1], 0, sizeof(struct spng_splt));\n            }\n\n            uint32_t i = ctx->n_splt - 1;\n\n            size_t keyword_len = chunk.length > 80 ? 80 : chunk.length;\n            char *keyword_nul = memchr(data, '\\0', keyword_len);\n            if(keyword_nul == NULL) return SPNG_ESPLT_NAME;\n\n            memcpy(&ctx->splt_list[i].name, data, keyword_len);\n\n            if(check_png_keyword(ctx->splt_list[i].name)) return SPNG_ESPLT_NAME;\n\n            keyword_len = strlen(ctx->splt_list[i].name);\n\n            if( (chunk.length - keyword_len - 1) ==  0) return SPNG_ECHUNK_SIZE;\n\n            memcpy(&ctx->splt_list[i].sample_depth, data + keyword_len + 1, 1);\n\n            if(ctx->n_splt > 1)\n            {\n                uint32_t j;\n                for(j=0; j < i; j++)\n                {\n                    if(!strcmp(ctx->splt_list[j].name, ctx->splt_list[i].name)) return SPNG_ESPLT_DUP_NAME;\n                }\n            }\n\n            if(ctx->splt_list[i].sample_depth == 16)\n            {\n                if( (chunk.length - keyword_len - 2) % 10 != 0) return SPNG_ECHUNK_SIZE;\n                ctx->splt_list[i].n_entries = (chunk.length - keyword_len - 2) / 10;\n            }\n            else if(ctx->splt_list[i].sample_depth == 8)\n            {\n                if( (chunk.length - keyword_len - 2) % 6 != 0) return SPNG_ECHUNK_SIZE;\n                ctx->splt_list[i].n_entries = (chunk.length - keyword_len - 2) / 6;\n            }\n            else return SPNG_ESPLT_DEPTH;\n\n            if(ctx->splt_list[i].n_entries == 0) return SPNG_ECHUNK_SIZE;\n            if(sizeof(struct spng_splt_entry) > SIZE_MAX / ctx->splt_list[i].n_entries) return SPNG_EOVERFLOW;\n\n            ctx->splt_list[i].entries = spng__malloc(ctx, sizeof(struct spng_splt_entry) * ctx->splt_list[i].n_entries);\n            if(ctx->splt_list[i].entries == NULL) return SPNG_EMEM;\n\n            const unsigned char *splt = data + keyword_len + 2;\n\n            size_t k;\n            if(ctx->splt_list[i].sample_depth == 16)\n            {\n                for(k=0; k < ctx->splt_list[i].n_entries; k++)\n                {\n                    ctx->splt_list[i].entries[k].red = read_u16(splt + k * 10);\n                    ctx->splt_list[i].entries[k].green = read_u16(splt + k * 10 + 2);\n                    ctx->splt_list[i].entries[k].blue = read_u16(splt + k * 10 + 4);\n                    ctx->splt_list[i].entries[k].alpha = read_u16(splt + k * 10 + 6);\n                    ctx->splt_list[i].entries[k].frequency = read_u16(splt + k * 10 + 8);\n                }\n            }\n            else if(ctx->splt_list[i].sample_depth == 8)\n            {\n                for(k=0; k < ctx->splt_list[i].n_entries; k++)\n                {\n                    uint8_t red, green, blue, alpha;\n                    memcpy(&red,   splt + k * 6, 1);\n                    memcpy(&green, splt + k * 6 + 1, 1);\n                    memcpy(&blue,  splt + k * 6 + 2, 1);\n                    memcpy(&alpha, splt + k * 6 + 3, 1);\n                    ctx->splt_list[i].entries[k].frequency = read_u16(splt + k * 6 + 4);\n\n                    ctx->splt_list[i].entries[k].red = red;\n                    ctx->splt_list[i].entries[k].green = green;\n                    ctx->splt_list[i].entries[k].blue = blue;\n                    ctx->splt_list[i].entries[k].alpha = alpha;\n                }\n            }\n\n            ctx->stored.splt = 1;\n        }\n        else if(!memcmp(chunk.type, type_text, 4) ||\n                !memcmp(chunk.type, type_ztxt, 4) ||\n                !memcmp(chunk.type, type_itxt, 4))\n        {\n            ctx->file.text = 1;\n\n            continue; /* XXX: https://gitlab.com/randy408/libspng/issues/31 */\n        }\n        else if(!memcmp(chunk.type, type_exif, 4))\n        {\n            if(ctx->file.exif) return SPNG_EDUP_EXIF;\n\n            ctx->file.exif = 1;\n\n            if(!chunk.length) return SPNG_EEXIF;\n\n            struct spng_exif exif;\n\n            exif.data = spng__malloc(ctx, chunk.length);\n            if(exif.data == NULL) return SPNG_EMEM;\n\n            memcpy(exif.data, data, chunk.length);\n            exif.length = chunk.length;\n\n            if(check_exif(&exif))\n            {\n                spng__free(ctx, exif.data);\n                return SPNG_EEXIF;\n            }\n\n            if(!ctx->user.exif) memcpy(&ctx->exif, &exif, sizeof(struct spng_exif));\n            else spng__free(ctx, exif.data);\n\n            ctx->stored.exif = 1;\n        }\n    }\n\n    return ret;\n}\n",
    "target": 0,
    "idx": 2016266
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "static void\nxmlTextReaderFreeNodeList(xmlTextReaderPtr reader, xmlNodePtr cur) {\n    xmlNodePtr next;\n    xmlNodePtr parent;\n    xmlDictPtr dict;\n    size_t depth = 0;\n\n    if ((reader != NULL) && (reader->ctxt != NULL))\n\tdict = reader->ctxt->dict;\n    else\n        dict = NULL;\n    if (cur == NULL) return;\n    if (cur->type == XML_NAMESPACE_DECL) {\n\txmlFreeNsList((xmlNsPtr) cur);\n\treturn;\n    }\n    if ((cur->type == XML_DOCUMENT_NODE) ||\n\t(cur->type == XML_HTML_DOCUMENT_NODE)) {\n\txmlFreeDoc((xmlDocPtr) cur);\n\treturn;\n    }\n    while (1) {\n        while ((cur->type != XML_DTD_NODE) &&\n               (cur->type != XML_ENTITY_REF_NODE) &&\n               (cur->children != NULL) &&\n               (cur->children->parent == cur)) {\n            cur = cur->children;\n            depth += 1;\n        }\n\n        next = cur->next;\n        parent = cur->parent;\n\n\t/* unroll to speed up freeing the document */\n\tif (cur->type != XML_DTD_NODE) {\n\n\t    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n\t\txmlDeregisterNodeDefaultValue(cur);\n\n\t    if (((cur->type == XML_ELEMENT_NODE) ||\n\t\t (cur->type == XML_XINCLUDE_START) ||\n\t\t (cur->type == XML_XINCLUDE_END)) &&\n\t\t(cur->properties != NULL))\n\t\txmlTextReaderFreePropList(reader, cur->properties);\n\t    if ((cur->content != (xmlChar *) &(cur->properties)) &&\n\t        (cur->type != XML_ELEMENT_NODE) &&\n\t\t(cur->type != XML_XINCLUDE_START) &&\n\t\t(cur->type != XML_XINCLUDE_END) &&\n\t\t(cur->type != XML_ENTITY_REF_NODE)) {\n\t\tDICT_FREE(cur->content);\n\t    }\n\t    if (((cur->type == XML_ELEMENT_NODE) ||\n\t         (cur->type == XML_XINCLUDE_START) ||\n\t\t (cur->type == XML_XINCLUDE_END)) &&\n\t\t(cur->nsDef != NULL))\n\t\txmlFreeNsList(cur->nsDef);\n\n\t    /*\n\t     * we don't free element names here they are interned now\n\t     */\n\t    if ((cur->type != XML_TEXT_NODE) &&\n\t\t(cur->type != XML_COMMENT_NODE))\n\t\tDICT_FREE(cur->name);\n\t    if (((cur->type == XML_ELEMENT_NODE) ||\n\t\t (cur->type == XML_TEXT_NODE)) &&\n\t        (reader != NULL) && (reader->ctxt != NULL) &&\n\t\t(reader->ctxt->freeElemsNr < 100)) {\n\t        cur->next = reader->ctxt->freeElems;\n\t\treader->ctxt->freeElems = cur;\n\t\treader->ctxt->freeElemsNr++;\n\t    } else {\n\t\txmlFree(cur);\n\t    }\n\t}\n\n        if (next != NULL) {\n\t    cur = next;\n        } else {\n            if ((depth == 0) || (parent == NULL))\n                break;\n            depth -= 1;\n            cur = parent;\n            cur->children = NULL;\n        }\n    }\n}\n",
    "target": 0,
    "idx": 2017737
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "static int\nvips_foreign_load_matrix_load( VipsForeignLoad *load )\n{\n\tVipsForeignLoadMatrix *matrix = (VipsForeignLoadMatrix *) load;\n\tVipsObjectClass *class = VIPS_OBJECT_GET_CLASS( load );\n\n\tint x, y;\n\n\tvips_image_pipelinev( load->real, VIPS_DEMAND_STYLE_THINSTRIP, NULL );\n\tvips_image_init_fields( load->real,\n\t\tload->out->Xsize, load->out->Ysize, 1, \n\t\tVIPS_FORMAT_DOUBLE, \n\t\tVIPS_CODING_NONE, VIPS_INTERPRETATION_B_W, 1.0, 1.0 );\n\n\tfor( y = 0; y < load->real->Ysize; y++ ) {\n\t\tchar *line;\n\t\tchar *p, *q;\n\n\t\tline = vips_sbuf_get_line_copy( matrix->sbuf );\n\n\t\tfor( x = 0, p = line; \n\t\t\t(q = vips_break_token( p, \" \\t\" )) &&\n\t\t\t\tx < load->out->Xsize;\n\t\t\tx++, p = q )\n\t\t\tif( vips_strtod( p, &matrix->linebuf[x] ) ) {\n\t\t\t\tvips_error( class->nickname, \n\t\t\t\t\t_( \"bad number \\\"%s\\\"\" ), p );\n\t\t\t\tg_free( line );\n\t\t\t\treturn( -1 );\n\t\t\t}\n\n\t\tg_free( line );\n\n\t\tif( x != load->out->Xsize ) {\n\t\t\tvips_error( class->nickname, \n\t\t\t\t_( \"line %d too short\" ), y );\n\t\t\treturn( -1 );\n\t\t}\n\n\t\tif( vips_image_write_line( load->real, y, \n\t\t\t(VipsPel *) matrix->linebuf ) )\n\t\t\treturn( -1 );\n\t}\n\n\treturn( 0 );\n}\n",
    "target": 0,
    "idx": 2020843
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "extern \"C\" int\nLLVMFuzzerTestOneInput(const uint8_t *data, size_t size)\n{\n    BOX *box;\n    PIX *pixs, *pixd;\n    PIX *pix1, *pix2, *pix3, *pix4, *pix5, *pix6, *pix7, *pix8;\n    PIXCMAP *cmap;\n\n    leptSetStdNullHandler();\n    pixs = pixReadMemSpix(data, size);\n    if(pixs==NULL) return 0;\n\n    pix1 = pixThresholdTo4bpp(pixs, 6, 1);\n    box = boxCreate(120, 30, 200, 200);\n    pixColorGray(pix1, box, L_PAINT_DARK, 220, 0, 0, 255);\n    boxDestroy(&box);\n\n    pix2 = pixScale(pix1, 1.5, 1.5);\n\n    cmap = pixGetColormap(pix1);\n    pix3 = pixOctcubeQuantFromCmap(pix2, cmap, 4,\n                                   3, L_EUCLIDEAN_DISTANCE);\n\n    pix4 = pixConvertTo32(pix3);\n    pix5 = pixMedianCutQuant(pix4, 0);\n    pix6 = pixFewColorsMedianCutQuantMixed(pix4, 30, 30, 100, 0, 0, 0);\n\n    pixd = pixDeskew(pixs, 0);\n    pixWriteImpliedFormat(\"/tmp/lept/deskew/result1\", pixd, 0, 0);\n\n    pixOctreeQuantByPopulation(pixs, 0, 0);\n    pix7 = pixFewColorsOctcubeQuantMixed(pix4, 3, 20, 244, 20, 0.05, 15);\n    pix8 = pixColorSegment(pixs, 50, 6, 6, 6, 0);\n    \n    pixDestroy(&pix1);\n    pixDestroy(&pix2);\n    pixDestroy(&pix3);\n    pixDestroy(&pix4);\n    pixDestroy(&pix5);\n    pixDestroy(&pix6);\n    pixDestroy(&pix7);\n    pixDestroy(&pix8);\n\n    pixDestroy(&pixd);\n    pixDestroy(&pixs);\n    \n    return 0;\n}\n",
    "target": 0,
    "idx": 2022110
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "static void\nxmlTextReaderFreeProp(xmlTextReaderPtr reader, xmlAttrPtr cur) {\n    xmlDictPtr dict;\n\n    if ((reader != NULL) && (reader->ctxt != NULL))\n\tdict = reader->ctxt->dict;\n    else\n        dict = NULL;\n    if (cur == NULL) return;\n\n    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n\txmlDeregisterNodeDefaultValue((xmlNodePtr) cur);\n\n    /* Check for ID removal -> leading to invalid references ! */\n    if ((cur->parent != NULL) && (cur->parent->doc != NULL) &&\n\t((cur->parent->doc->intSubset != NULL) ||\n\t (cur->parent->doc->extSubset != NULL))) {\n        if (xmlIsID(cur->parent->doc, cur->parent, cur))\n\t    xmlTextReaderRemoveID(cur->parent->doc, cur);\n        if (xmlIsRef(cur->parent->doc, cur->parent, cur))\n            xmlTextReaderRemoveRef(cur->parent->doc, cur);\n    }\n    if (cur->children != NULL)\n        xmlTextReaderFreeNodeList(reader, cur->children);\n\n    DICT_FREE(cur->name);\n    if ((reader != NULL) && (reader->ctxt != NULL) &&\n        (reader->ctxt->freeAttrsNr < 100)) {\n        cur->next = reader->ctxt->freeAttrs;\n\treader->ctxt->freeAttrs = cur;\n\treader->ctxt->freeAttrsNr++;\n    } else {\n\txmlFree(cur);\n    }\n}\nstatic void\nxmlTextReaderFreePropList(xmlTextReaderPtr reader, xmlAttrPtr cur) {\n    xmlAttrPtr next;\n\n    while (cur != NULL) {\n        next = cur->next;\n        xmlTextReaderFreeProp(reader, cur);\n\tcur = next;\n    }\n}\nstatic void\nxmlTextReaderFreeNodeList(xmlTextReaderPtr reader, xmlNodePtr cur) {\n    xmlNodePtr next;\n    xmlNodePtr parent;\n    xmlDictPtr dict;\n    size_t depth = 0;\n\n    if ((reader != NULL) && (reader->ctxt != NULL))\n\tdict = reader->ctxt->dict;\n    else\n        dict = NULL;\n    if (cur == NULL) return;\n    if (cur->type == XML_NAMESPACE_DECL) {\n\txmlFreeNsList((xmlNsPtr) cur);\n\treturn;\n    }\n    if ((cur->type == XML_DOCUMENT_NODE) ||\n\t(cur->type == XML_HTML_DOCUMENT_NODE)) {\n\txmlFreeDoc((xmlDocPtr) cur);\n\treturn;\n    }\n    while (1) {\n        while ((cur->type != XML_DTD_NODE) &&\n               (cur->type != XML_ENTITY_REF_NODE) &&\n               (cur->children != NULL) &&\n               (cur->children->parent == cur)) {\n            cur = cur->children;\n            depth += 1;\n        }\n\n        next = cur->next;\n        parent = cur->parent;\n\n\t/* unroll to speed up freeing the document */\n\tif (cur->type != XML_DTD_NODE) {\n\n\t    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n\t\txmlDeregisterNodeDefaultValue(cur);\n\n\t    if (((cur->type == XML_ELEMENT_NODE) ||\n\t\t (cur->type == XML_XINCLUDE_START) ||\n\t\t (cur->type == XML_XINCLUDE_END)) &&\n\t\t(cur->properties != NULL))\n\t\txmlTextReaderFreePropList(reader, cur->properties);\n\t    if ((cur->content != (xmlChar *) &(cur->properties)) &&\n\t        (cur->type != XML_ELEMENT_NODE) &&\n\t\t(cur->type != XML_XINCLUDE_START) &&\n\t\t(cur->type != XML_XINCLUDE_END) &&\n\t\t(cur->type != XML_ENTITY_REF_NODE)) {\n\t\tDICT_FREE(cur->content);\n\t    }\n\t    if (((cur->type == XML_ELEMENT_NODE) ||\n\t         (cur->type == XML_XINCLUDE_START) ||\n\t\t (cur->type == XML_XINCLUDE_END)) &&\n\t\t(cur->nsDef != NULL))\n\t\txmlFreeNsList(cur->nsDef);\n\n\t    /*\n\t     * we don't free element names here they are interned now\n\t     */\n\t    if ((cur->type != XML_TEXT_NODE) &&\n\t\t(cur->type != XML_COMMENT_NODE))\n\t\tDICT_FREE(cur->name);\n\t    if (((cur->type == XML_ELEMENT_NODE) ||\n\t\t (cur->type == XML_TEXT_NODE)) &&\n\t        (reader != NULL) && (reader->ctxt != NULL) &&\n\t\t(reader->ctxt->freeElemsNr < 100)) {\n\t        cur->next = reader->ctxt->freeElems;\n\t\treader->ctxt->freeElems = cur;\n\t\treader->ctxt->freeElemsNr++;\n\t    } else {\n\t\txmlFree(cur);\n\t    }\n\t}\n\n        if (next != NULL) {\n\t    cur = next;\n        } else {\n            if ((depth == 0) || (parent == NULL))\n                break;\n            depth -= 1;\n            cur = parent;\n            cur->children = NULL;\n        }\n    }\n}\n",
    "target": 0,
    "idx": 2023120
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "int\nhtmlParseChunk(htmlParserCtxtPtr ctxt, const char *chunk, int size,\n              int terminate) {\n    if ((ctxt == NULL) || (ctxt->input == NULL)) {\n\thtmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\n\t\t     \"htmlParseChunk: context error\\n\", NULL, NULL);\n\treturn(XML_ERR_INTERNAL_ERROR);\n    }\n    if ((size > 0) && (chunk != NULL) && (ctxt->input != NULL) &&\n        (ctxt->input->buf != NULL) && (ctxt->instate != XML_PARSER_EOF))  {\n\tsize_t base = xmlBufGetInputBase(ctxt->input->buf->buffer, ctxt->input);\n\tsize_t cur = ctxt->input->cur - ctxt->input->base;\n\tint res;\n\n\tres = xmlParserInputBufferPush(ctxt->input->buf, size, chunk);\n        xmlBufSetInputBaseCur(ctxt->input->buf->buffer, ctxt->input, base, cur);\n\tif (res < 0) {\n\t    ctxt->errNo = XML_PARSER_EOF;\n\t    ctxt->disableSAX = 1;\n\t    return (XML_PARSER_EOF);\n\t}\n#ifdef DEBUG_PUSH\n\txmlGenericError(xmlGenericErrorContext, \"HPP: pushed %d\\n\", size);\n#endif\n\n#if 0\n\tif ((terminate) || (ctxt->input->buf->buffer->use > 80))\n\t    htmlParseTryOrFinish(ctxt, terminate);\n#endif\n    } else if (ctxt->instate != XML_PARSER_EOF) {\n\tif ((ctxt->input != NULL) && ctxt->input->buf != NULL) {\n\t    xmlParserInputBufferPtr in = ctxt->input->buf;\n\t    if ((in->encoder != NULL) && (in->buffer != NULL) &&\n\t\t    (in->raw != NULL)) {\n\t\tint nbchars;\n\t\tsize_t base = xmlBufGetInputBase(in->buffer, ctxt->input);\n\t\tsize_t current = ctxt->input->cur - ctxt->input->base;\n\n\t\tnbchars = xmlCharEncInput(in, terminate);\n\t\txmlBufSetInputBaseCur(in->buffer, ctxt->input, base, current);\n\t\tif (nbchars < 0) {\n\t\t    htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n\t\t\t         \"encoder error\\n\", NULL, NULL);\n\t\t    return(XML_ERR_INVALID_ENCODING);\n\t\t}\n\t    }\n\t}\n    }\n    htmlParseTryOrFinish(ctxt, terminate);\n    if (terminate) {\n\tif ((ctxt->instate != XML_PARSER_EOF) &&\n\t    (ctxt->instate != XML_PARSER_EPILOG) &&\n\t    (ctxt->instate != XML_PARSER_MISC)) {\n\t    ctxt->errNo = XML_ERR_DOCUMENT_END;\n\t    ctxt->wellFormed = 0;\n\t}\n\tif (ctxt->instate != XML_PARSER_EOF) {\n\t    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n\t\tctxt->sax->endDocument(ctxt->userData);\n\t}\n\tctxt->instate = XML_PARSER_EOF;\n    }\n    return((xmlParserErrors) ctxt->errNo);\n}\nsize_t\nxmlBufDump(FILE *file, xmlBufPtr buf) {\n    size_t ret;\n\n    if ((buf == NULL) || (buf->error != 0)) {\n#ifdef DEBUG_BUFFER\n        xmlGenericError(xmlGenericErrorContext,\n\t\t\"xmlBufDump: buf == NULL or in error\\n\");\n#endif\n\treturn(0);\n    }\n    if (buf->content == NULL) {\n#ifdef DEBUG_BUFFER\n        xmlGenericError(xmlGenericErrorContext,\n\t\t\"xmlBufDump: buf->content == NULL\\n\");\n#endif\n\treturn(0);\n    }\n    CHECK_COMPAT(buf)\n    if (file == NULL)\n\tfile = stdout;\n    ret = fwrite(buf->content, sizeof(xmlChar), buf->use, file);\n    return(ret);\n}\nint\nxmlBufSetInputBaseCur(xmlBufPtr buf, xmlParserInputPtr input,\n                      size_t base, size_t cur) {\n    if (input == NULL)\n        return(-1);\n    if ((buf == NULL) || (buf->error)) {\n        input->base = input->cur = input->end = BAD_CAST \"\";\n        return(-1);\n    }\n    CHECK_COMPAT(buf)\n    input->base = &buf->content[base];\n    input->cur = input->base + cur;\n    input->end = &buf->content[buf->use];\n    return(0);\n}\n",
    "target": 0,
    "idx": 2024055
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "static void\nxmlXIncludeRecurseDoc(xmlXIncludeCtxtPtr ctxt, xmlDocPtr doc,\n\t              const xmlURL url ATTRIBUTE_UNUSED) {\n    xmlXIncludeCtxtPtr newctxt;\n    int i;\n\n    /*\n     * Avoid recursion in already substituted resources\n    for (i = 0;i < ctxt->urlNr;i++) {\n\tif (xmlStrEqual(doc->URL, ctxt->urlTab[i]))\n\t    return;\n    }\n     */\n\n#ifdef DEBUG_XINCLUDE\n    xmlGenericError(xmlGenericErrorContext, \"Recursing in doc %s\\n\", doc->URL);\n#endif\n    /*\n     * Handle recursion here.\n     */\n\n    newctxt = xmlXIncludeNewContext(doc);\n    if (newctxt != NULL) {\n\t/*\n\t * Copy the private user data\n\t */\n\tnewctxt->_private = ctxt->_private;\n\t/*\n\t * Copy the existing document set\n\t */\n\tnewctxt->incMax = ctxt->incMax;\n\tnewctxt->incNr = ctxt->incNr;\n        newctxt->incTab = (xmlXIncludeRefPtr *) xmlMalloc(newctxt->incMax *\n\t\t                          sizeof(newctxt->incTab[0]));\n        if (newctxt->incTab == NULL) {\n\t    xmlXIncludeErrMemory(ctxt, (xmlNodePtr) doc, \"processing doc\");\n\t    xmlFree(newctxt);\n\t    return;\n\t}\n\t/*\n\t * copy the urlTab\n\t */\n\tnewctxt->urlMax = ctxt->urlMax;\n\tnewctxt->urlNr = ctxt->urlNr;\n\tnewctxt->urlTab = ctxt->urlTab;\n\n\t/*\n\t * Inherit the existing base\n\t */\n\tnewctxt->base = xmlStrdup(ctxt->base);\n\n\t/*\n\t * Inherit the documents already in use by other includes\n\t */\n\tnewctxt->incBase = ctxt->incNr;\n\tfor (i = 0;i < ctxt->incNr;i++) {\n\t    newctxt->incTab[i] = ctxt->incTab[i];\n\t    newctxt->incTab[i]->count++; /* prevent the recursion from\n\t\t\t\t\t    freeing it */\n\t}\n\t/*\n\t * The new context should also inherit the Parse Flags\n\t * (bug 132597)\n\t */\n\tnewctxt->parseFlags = ctxt->parseFlags;\n        newctxt->incTotal = ctxt->incTotal;\n\txmlXIncludeDoProcess(newctxt, doc, xmlDocGetRootElement(doc), 0);\n        ctxt->incTotal = newctxt->incTotal;\n\tfor (i = 0;i < ctxt->incNr;i++) {\n\t    newctxt->incTab[i]->count--;\n\t    newctxt->incTab[i] = NULL;\n\t}\n\n\t/* urlTab may have been reallocated */\n\tctxt->urlTab = newctxt->urlTab;\n\tctxt->urlMax = newctxt->urlMax;\n\n\tnewctxt->urlMax = 0;\n\tnewctxt->urlNr = 0;\n\tnewctxt->urlTab = NULL;\n\n\txmlXIncludeFreeContext(newctxt);\n    }\n#ifdef DEBUG_XINCLUDE\n    xmlGenericError(xmlGenericErrorContext, \"Done recursing in doc %s\\n\", url);\n#endif\n}\nstatic int\nxmlXIncludeLoadFallback(xmlXIncludeCtxtPtr ctxt, xmlNodePtr fallback, int nr) {\n    xmlXIncludeCtxtPtr newctxt;\n    int ret = 0;\n    int oldNbErrors = ctxt->nbErrors;\n\n    if ((fallback == NULL) || (fallback->type == XML_NAMESPACE_DECL) ||\n        (ctxt == NULL))\n\treturn(-1);\n    if (fallback->children != NULL) {\n\t/*\n\t * It's possible that the fallback also has 'includes'\n\t * (Bug 129969), so we re-process the fallback just in case\n\t */\n\tnewctxt = xmlXIncludeNewContext(ctxt->doc);\n\tif (newctxt == NULL)\n\t    return (-1);\n\tnewctxt->_private = ctxt->_private;\n\tnewctxt->base = xmlStrdup(ctxt->base);\t/* Inherit the base from the existing context */\n\txmlXIncludeSetFlags(newctxt, ctxt->parseFlags);\n        newctxt->incTotal = ctxt->incTotal;\n        if (xmlXIncludeDoProcess(newctxt, ctxt->doc, fallback, 1) < 0)\n            ret = -1;\n        ctxt->incTotal = newctxt->incTotal;\n\tif (ctxt->nbErrors > oldNbErrors)\n\t    ret = -1;\n\txmlXIncludeFreeContext(newctxt);\n\n\tctxt->incTab[nr]->inc = xmlDocCopyNodeList(ctxt->doc,\n\t                                           fallback->children);\n    } else {\n        ctxt->incTab[nr]->inc = NULL;\n\tctxt->incTab[nr]->emptyFb = 1;\t/* flag empty callback */\n    }\n    return(ret);\n}\nstatic int\nxmlXIncludeDoProcess(xmlXIncludeCtxtPtr ctxt, xmlDocPtr doc, xmlNodePtr tree,\n                     int skipRoot) {\n    xmlNodePtr cur;\n    int ret = 0;\n    int i, start;\n\n    if ((doc == NULL) || (tree == NULL) || (tree->type == XML_NAMESPACE_DECL))\n\treturn(-1);\n    if ((skipRoot) && (tree->children == NULL))\n        return(-1);\n    if (ctxt == NULL)\n\treturn(-1);\n\n    if (doc->URL != NULL) {\n\tret = xmlXIncludeURLPush(ctxt, doc->URL);\n\tif (ret < 0)\n\t    return(-1);\n    }\n    start = ctxt->incNr;\n\n    /*\n     * First phase: lookup the elements in the document\n     */\n    if (skipRoot)\n        cur = tree->children;\n    else\n        cur = tree;\n    do {\n\t/* TODO: need to work on entities -> stack */\n        if (xmlXIncludeTestNode(ctxt, cur) == 1) {\n#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n            /*\n             * Avoid superlinear expansion by limiting the total number\n             * of replacements.\n             */\n            if (ctxt->incTotal >= 20)\n                return(-1);\n#endif\n            ctxt->incTotal++;\n            xmlXIncludePreProcessNode(ctxt, cur);\n        } else if ((cur->children != NULL) &&\n                   (cur->children->type != XML_ENTITY_DECL) &&\n                   (cur->children->type != XML_XINCLUDE_START) &&\n                   (cur->children->type != XML_XINCLUDE_END)) {\n            cur = cur->children;\n            continue;\n        }\n        do {\n            if (cur == tree)\n                break;\n            if (cur->next != NULL) {\n                cur = cur->next;\n                break;\n            }\n            cur = cur->parent;\n        } while (cur != NULL);\n    } while ((cur != NULL) && (cur != tree));\n\n    /*\n     * Second Phase : collect the infosets fragments\n     */\n    for (i = start;i < ctxt->incNr; i++) {\n        xmlXIncludeLoadNode(ctxt, i);\n\tret++;\n    }\n\n    /*\n     * Third phase: extend the original document infoset.\n     *\n     * Originally we bypassed the inclusion if there were any errors\n     * encountered on any of the XIncludes.  A bug was raised (bug\n     * 132588) requesting that we output the XIncludes without error,\n     * so the check for inc!=NULL || xptr!=NULL was put in.  This may\n     * give some other problems in the future, but for now it seems to\n     * work ok.\n     *\n     */\n    for (i = ctxt->incBase;i < ctxt->incNr; i++) {\n\tif ((ctxt->incTab[i]->inc != NULL) ||\n\t\t(ctxt->incTab[i]->xptr != NULL) ||\n\t\t(ctxt->incTab[i]->emptyFb != 0))\t/* (empty fallback) */\n\t    xmlXIncludeIncludeNode(ctxt, i);\n    }\n\n    if (doc->URL != NULL)\n\txmlXIncludeURLPop(ctxt);\n    return(ret);\n}\nint\nxmlXIncludeProcessTreeFlagsData(xmlNodePtr tree, int flags, void *data) {\n    xmlXIncludeCtxtPtr ctxt;\n    int ret = 0;\n\n    if ((tree == NULL) || (tree->type == XML_NAMESPACE_DECL) ||\n        (tree->doc == NULL))\n        return(-1);\n\n    ctxt = xmlXIncludeNewContext(tree->doc);\n    if (ctxt == NULL)\n        return(-1);\n    ctxt->_private = data;\n    ctxt->base = xmlStrdup((xmlChar *)tree->doc->URL);\n    xmlXIncludeSetFlags(ctxt, flags);\n    ret = xmlXIncludeDoProcess(ctxt, tree->doc, tree, 0);\n    if ((ret >= 0) && (ctxt->nbErrors > 0))\n        ret = -1;\n\n    xmlXIncludeFreeContext(ctxt);\n    return(ret);\n}\nint\nxmlXIncludeProcessTreeFlags(xmlNodePtr tree, int flags) {\n    xmlXIncludeCtxtPtr ctxt;\n    int ret = 0;\n\n    if ((tree == NULL) || (tree->type == XML_NAMESPACE_DECL) ||\n        (tree->doc == NULL))\n\treturn(-1);\n    ctxt = xmlXIncludeNewContext(tree->doc);\n    if (ctxt == NULL)\n\treturn(-1);\n    ctxt->base = xmlNodeGetBase(tree->doc, tree);\n    xmlXIncludeSetFlags(ctxt, flags);\n    ret = xmlXIncludeDoProcess(ctxt, tree->doc, tree, 0);\n    if ((ret >= 0) && (ctxt->nbErrors > 0))\n\tret = -1;\n\n    xmlXIncludeFreeContext(ctxt);\n    return(ret);\n}\nint\nxmlXIncludeProcessNode(xmlXIncludeCtxtPtr ctxt, xmlNodePtr node) {\n    int ret = 0;\n\n    if ((node == NULL) || (node->type == XML_NAMESPACE_DECL) ||\n        (node->doc == NULL) || (ctxt == NULL))\n\treturn(-1);\n    ret = xmlXIncludeDoProcess(ctxt, node->doc, node, 0);\n    if ((ret >= 0) && (ctxt->nbErrors > 0))\n\tret = -1;\n    return(ret);\n}\n",
    "target": 0,
    "idx": 2024925
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "static int\nxmlXIncludeLoadFallback(xmlXIncludeCtxtPtr ctxt, xmlNodePtr fallback, int nr) {\n    xmlXIncludeCtxtPtr newctxt;\n    int ret = 0;\n    int oldNbErrors = ctxt->nbErrors;\n\n    if ((fallback == NULL) || (fallback->type == XML_NAMESPACE_DECL) ||\n        (ctxt == NULL))\n\treturn(-1);\n    if (fallback->children != NULL) {\n\t/*\n\t * It's possible that the fallback also has 'includes'\n\t * (Bug 129969), so we re-process the fallback just in case\n\t */\n\tnewctxt = xmlXIncludeNewContext(ctxt->doc);\n\tif (newctxt == NULL)\n\t    return (-1);\n\tnewctxt->_private = ctxt->_private;\n\tnewctxt->base = xmlStrdup(ctxt->base);\t/* Inherit the base from the existing context */\n\txmlXIncludeSetFlags(newctxt, ctxt->parseFlags);\n        newctxt->incTotal = ctxt->incTotal;\n        if (xmlXIncludeDoProcess(newctxt, ctxt->doc, fallback, 1) < 0)\n            ret = -1;\n        ctxt->incTotal = newctxt->incTotal;\n\tif (ctxt->nbErrors > oldNbErrors)\n\t    ret = -1;\n\txmlXIncludeFreeContext(newctxt);\n\n\tctxt->incTab[nr]->inc = xmlDocCopyNodeList(ctxt->doc,\n\t                                           fallback->children);\n    } else {\n        ctxt->incTab[nr]->inc = NULL;\n    }\n    ctxt->incTab[nr]->fallback = 1;\n    return(ret);\n}\nstatic int\nxmlXIncludeIncludeNode(xmlXIncludeCtxtPtr ctxt, int nr) {\n    xmlNodePtr cur, end, list, tmp;\n\n    if (ctxt == NULL)\n\treturn(-1);\n    if ((nr < 0) || (nr >= ctxt->incNr))\n\treturn(-1);\n    cur = ctxt->incTab[nr]->ref;\n    if ((cur == NULL) || (cur->type == XML_NAMESPACE_DECL))\n\treturn(-1);\n\n    list = ctxt->incTab[nr]->inc;\n    ctxt->incTab[nr]->inc = NULL;\n\n    /*\n     * Check against the risk of generating a multi-rooted document\n     */\n    if ((cur->parent != NULL) &&\n\t(cur->parent->type != XML_ELEMENT_NODE)) {\n\tint nb_elem = 0;\n\n\ttmp = list;\n\twhile (tmp != NULL) {\n\t    if (tmp->type == XML_ELEMENT_NODE)\n\t\tnb_elem++;\n\t    tmp = tmp->next;\n\t}\n\tif (nb_elem > 1) {\n\t    xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t                   XML_XINCLUDE_MULTIPLE_ROOT,\n\t\t       \"XInclude error: would result in multiple root nodes\\n\",\n\t\t\t   NULL);\n            xmlFreeNodeList(list);\n\t    return(-1);\n\t}\n    }\n\n    if (ctxt->parseFlags & XML_PARSE_NOXINCNODE) {\n\t/*\n\t * Add the list of nodes\n\t */\n\twhile (list != NULL) {\n\t    end = list;\n\t    list = list->next;\n\n\t    xmlAddPrevSibling(cur, end);\n\t}\n\txmlUnlinkNode(cur);\n\txmlFreeNode(cur);\n    } else {\n        xmlNodePtr child, next;\n\n\t/*\n\t * Change the current node as an XInclude start one, and add an\n\t * XInclude end one\n\t */\n        if (ctxt->incTab[nr]->fallback)\n            xmlUnsetProp(cur, BAD_CAST \"href\");\n\tcur->type = XML_XINCLUDE_START;\n        /* Remove fallback children */\n        for (child = cur->children; child != NULL; child = next) {\n            next = child->next;\n            xmlUnlinkNode(child);\n            xmlFreeNode(child);\n        }\n\tend = xmlNewDocNode(cur->doc, cur->ns, cur->name, NULL);\n\tif (end == NULL) {\n\t    xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t                   XML_XINCLUDE_BUILD_FAILED,\n\t\t\t   \"failed to build node\\n\", NULL);\n            xmlFreeNodeList(list);\n\t    return(-1);\n\t}\n\tend->type = XML_XINCLUDE_END;\n\txmlAddNextSibling(cur, end);\n\n\t/*\n\t * Add the list of nodes\n\t */\n\twhile (list != NULL) {\n\t    cur = list;\n\t    list = list->next;\n\n\t    xmlAddPrevSibling(end, cur);\n\t}\n    }\n\n\n    return(0);\n}\n",
    "target": 0,
    "idx": 2025014
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "void zend_startup(zend_utility_functions *utility_functions) /* {{{ */\n{\n#ifdef ZTS\n\tzend_compiler_globals *compiler_globals;\n\tzend_executor_globals *executor_globals;\n\textern ZEND_API ts_rsrc_id ini_scanner_globals_id;\n\textern ZEND_API ts_rsrc_id language_scanner_globals_id;\n#else\n\textern zend_ini_scanner_globals ini_scanner_globals;\n\textern zend_php_scanner_globals language_scanner_globals;\n#endif\n\n\tzend_cpu_startup();\n\n#ifdef ZEND_WIN32\n\tphp_win32_cp_set_by_id(65001);\n#endif\n\n\tstart_memory_manager();\n\n\tvirtual_cwd_startup(); /* Could use shutdown to free the main cwd but it would just slow it down for CGI */\n\n#if defined(__FreeBSD__) || defined(__DragonFly__)\n\t/* FreeBSD and DragonFly floating point precision fix */\n\tfpsetmask(0);\n#endif\n\n\tzend_startup_strtod();\n\tzend_startup_extensions_mechanism();\n\n\t/* Set up utility functions and values */\n\tzend_error_cb = utility_functions->error_function;\n\tzend_printf = utility_functions->printf_function;\n\tzend_write = utility_functions->write_function;\n\tzend_fopen = utility_functions->fopen_function;\n\tif (!zend_fopen) {\n\t\tzend_fopen = zend_fopen_wrapper;\n\t}\n\tzend_stream_open_function = utility_functions->stream_open_function;\n\tzend_message_dispatcher_p = utility_functions->message_handler;\n\tzend_get_configuration_directive_p = utility_functions->get_configuration_directive;\n\tzend_ticks_function = utility_functions->ticks_function;\n\tzend_on_timeout = utility_functions->on_timeout;\n\tzend_printf_to_smart_string = utility_functions->printf_to_smart_string_function;\n\tzend_printf_to_smart_str = utility_functions->printf_to_smart_str_function;\n\tzend_getenv = utility_functions->getenv_function;\n\tzend_resolve_path = utility_functions->resolve_path_function;\n\n\tzend_interrupt_function = NULL;\n\n#ifdef HAVE_DTRACE\n/* build with dtrace support */\n\t{\n\t\tchar *tmp = getenv(\"USE_ZEND_DTRACE\");\n\n\t\tif (tmp && ZEND_ATOL(tmp)) {\n\t\t\tzend_dtrace_enabled = 1;\n\t\t\tzend_compile_file = dtrace_compile_file;\n\t\t\tzend_execute_ex = dtrace_execute_ex;\n\t\t\tzend_execute_internal = dtrace_execute_internal;\n\n\t\t\tzend_observer_error_register(dtrace_error_notify_cb);\n\t\t} else {\n\t\t\tzend_compile_file = compile_file;\n\t\t\tzend_execute_ex = execute_ex;\n\t\t\tzend_execute_internal = NULL;\n\t\t}\n\t}\n#else\n\tzend_compile_file = compile_file;\n\tzend_execute_ex = execute_ex;\n\tzend_execute_internal = NULL;\n#endif /* HAVE_DTRACE */\n\tzend_compile_string = compile_string;\n\tzend_throw_exception_hook = NULL;\n\n\t/* Set up the default garbage collection implementation. */\n\tgc_collect_cycles = zend_gc_collect_cycles;\n\n\tzend_vm_init();\n\n\t/* set up version */\n\tzend_version_info = strdup(ZEND_CORE_VERSION_INFO);\n\tzend_version_info_length = sizeof(ZEND_CORE_VERSION_INFO) - 1;\n\n\tGLOBAL_FUNCTION_TABLE = (HashTable *) malloc(sizeof(HashTable));\n\tGLOBAL_CLASS_TABLE = (HashTable *) malloc(sizeof(HashTable));\n\tGLOBAL_AUTO_GLOBALS_TABLE = (HashTable *) malloc(sizeof(HashTable));\n\tGLOBAL_CONSTANTS_TABLE = (HashTable *) malloc(sizeof(HashTable));\n\n\tzend_hash_init(GLOBAL_FUNCTION_TABLE, 1024, NULL, ZEND_FUNCTION_DTOR, 1);\n\tzend_hash_init(GLOBAL_CLASS_TABLE, 64, NULL, ZEND_CLASS_DTOR, 1);\n\tzend_hash_init(GLOBAL_AUTO_GLOBALS_TABLE, 8, NULL, auto_global_dtor, 1);\n\tzend_hash_init(GLOBAL_CONSTANTS_TABLE, 128, NULL, ZEND_CONSTANT_DTOR, 1);\n\n\tzend_hash_init(&module_registry, 32, NULL, module_destructor_zval, 1);\n\tzend_init_rsrc_list_dtors();\n\n#ifdef ZTS\n\tts_allocate_fast_id(&compiler_globals_id, &compiler_globals_offset, sizeof(zend_compiler_globals), (ts_allocate_ctor) compiler_globals_ctor, (ts_allocate_dtor) compiler_globals_dtor);\n\tts_allocate_fast_id(&executor_globals_id, &executor_globals_offset, sizeof(zend_executor_globals), (ts_allocate_ctor) executor_globals_ctor, (ts_allocate_dtor) executor_globals_dtor);\n\tts_allocate_fast_id(&language_scanner_globals_id, &language_scanner_globals_offset, sizeof(zend_php_scanner_globals), (ts_allocate_ctor) php_scanner_globals_ctor, NULL);\n\tts_allocate_fast_id(&ini_scanner_globals_id, &ini_scanner_globals_offset, sizeof(zend_ini_scanner_globals), (ts_allocate_ctor) ini_scanner_globals_ctor, NULL);\n\tcompiler_globals = ts_resource(compiler_globals_id);\n\texecutor_globals = ts_resource(executor_globals_id);\n\n\tcompiler_globals_dtor(compiler_globals);\n\tcompiler_globals->in_compilation = 0;\n\tcompiler_globals->function_table = (HashTable *) malloc(sizeof(HashTable));\n\tcompiler_globals->class_table = (HashTable *) malloc(sizeof(HashTable));\n\n\t*compiler_globals->function_table = *GLOBAL_FUNCTION_TABLE;\n\t*compiler_globals->class_table = *GLOBAL_CLASS_TABLE;\n\tcompiler_globals->auto_globals = GLOBAL_AUTO_GLOBALS_TABLE;\n\n\tzend_hash_destroy(executor_globals->zend_constants);\n\t*executor_globals->zend_constants = *GLOBAL_CONSTANTS_TABLE;\n#else\n\tini_scanner_globals_ctor(&ini_scanner_globals);\n\tphp_scanner_globals_ctor(&language_scanner_globals);\n\tzend_set_default_compile_time_values();\n#ifdef ZEND_WIN32\n\tzend_get_windows_version_info(&EG(windows_version_info));\n#endif\n# if ZEND_MAP_PTR_KIND == ZEND_MAP_PTR_KIND_PTR\n\t\t/* Create a map region, used for indirect pointers from shared to\n\t\t * process memory. It's allocated once and never resized.\n\t\t * All processes must map it into the same address space.\n\t\t */\n\t\tCG(map_ptr_size) = 1024 * 1024; // TODO: initial size ???\n\t\tCG(map_ptr_last) = 0;\n\t\tZEND_MAP_PTR_SET_REAL_BASE(CG(map_ptr_base), pemalloc(CG(map_ptr_size) * sizeof(void*), 1));\n# elif ZEND_MAP_PTR_KIND == ZEND_MAP_PTR_KIND_PTR_OR_OFFSET\n\t\t/* Map region is going to be created and resized at run-time. */\n\t\tZEND_MAP_PTR_SET_REAL_BASE(CG(map_ptr_base), NULL);\n\t\tCG(map_ptr_size) = 0;\n\t\tCG(map_ptr_last) = 0;\n# else\n#  error \"Unknown ZEND_MAP_PTR_KIND\"\n# endif\n#endif\n\tEG(error_reporting) = E_ALL & ~E_NOTICE;\n\n\tzend_interned_strings_init();\n\tzend_startup_builtin_functions();\n\tzend_register_standard_constants();\n\tzend_register_auto_global(zend_string_init_interned(\"GLOBALS\", sizeof(\"GLOBALS\") - 1, 1), 1, php_auto_globals_create_globals);\n\n#ifndef ZTS\n\tzend_init_rsrc_plist();\n\tzend_init_exception_op();\n\tzend_init_call_trampoline_op();\n#endif\n\n\tzend_ini_startup();\n\n#ifdef ZEND_WIN32\n\t/* Uses INI settings, so needs to be run after it. */\n\tphp_win32_cp_setup();\n#endif\n\n\tzend_optimizer_startup();\n\n#ifdef ZTS\n\ttsrm_set_new_thread_end_handler(zend_new_thread_end_handler);\n\ttsrm_set_shutdown_handler(zend_interned_strings_dtor);\n#endif\n}\nstatic void alloc_globals_ctor(zend_alloc_globals *alloc_globals)\n{\n\tchar *tmp;\n\n#if ZEND_MM_CUSTOM\n\ttmp = getenv(\"USE_ZEND_ALLOC\");\n\tif (tmp && ZEND_ATOL(tmp)) {\n\t\tbool tracked = (tmp = getenv(\"USE_TRACKED_ALLOC\")) && ZEND_ATOL(tmp);\n\t\tzend_mm_heap *mm_heap = alloc_globals->mm_heap = malloc(sizeof(zend_mm_heap));\n\t\tmemset(mm_heap, 0, sizeof(zend_mm_heap));\n\t\tmm_heap->use_custom_heap = ZEND_MM_CUSTOM_HEAP_STD;\n\t\tmm_heap->limit = ((size_t)Z_L(-1) >> (size_t)Z_L(1));\n\t\tmm_heap->overflow = 0;\n\n\t\tif (!tracked) {\n\t\t\t/* Use system allocator. */\n\t\t\tmm_heap->custom_heap.std._malloc = __zend_malloc;\n\t\t\tmm_heap->custom_heap.std._free = free;\n\t\t\tmm_heap->custom_heap.std._realloc = __zend_realloc;\n\t\t} else {\n\t\t\t/* Use system allocator and track allocations for auto-free. */\n\t\t\tmm_heap->custom_heap.std._malloc = tracked_malloc;\n\t\t\tmm_heap->custom_heap.std._free = tracked_free;\n\t\t\tmm_heap->custom_heap.std._realloc = tracked_realloc;\n\t\t\tmm_heap->tracked_allocs = malloc(sizeof(HashTable));\n\t\t\tzend_hash_init(mm_heap->tracked_allocs, 1024, NULL, NULL, 1);\n\t\t}\n\t\treturn;\n\t}\n#endif\n\n\ttmp = getenv(\"USE_ZEND_ALLOC_HUGE_PAGES\");\n\tif (tmp && ZEND_ATOL(tmp)) {\n\t\tzend_mm_use_huge_pages = 1;\n\t}\n\talloc_globals->mm_heap = zend_mm_init();\n}\nint main(int argc, char *argv[])\n#endif\n{\n#if defined(PHP_WIN32)\n# ifdef PHP_CLI_WIN32_NO_CONSOLE\n\tint argc = __argc;\n\tchar **argv = __argv;\n# endif\n\tint num_args;\n\twchar_t **argv_wide;\n\tchar **argv_save = argv;\n\tBOOL using_wide_argv = 0;\n#endif\n\n\tint c;\n\tint exit_status = SUCCESS;\n\tint module_started = 0, sapi_started = 0;\n\tchar *php_optarg = NULL;\n\tint php_optind = 1, use_extended_info = 0;\n\tchar *ini_path_override = NULL;\n\tchar *ini_entries = NULL;\n\tsize_t ini_entries_len = 0;\n\tint ini_ignore = 0;\n\tsapi_module_struct *sapi_module = &cli_sapi_module;\n\n\t/*\n\t * Do not move this initialization. It needs to happen before argv is used\n\t * in any way.\n\t */\n\targv = save_ps_args(argc, argv);\n\n#if defined(PHP_WIN32) && !defined(PHP_CLI_WIN32_NO_CONSOLE)\n\tphp_win32_console_fileno_set_vt100(STDOUT_FILENO, TRUE);\n\tphp_win32_console_fileno_set_vt100(STDERR_FILENO, TRUE);\n#endif\n\n\tcli_sapi_module.additional_functions = additional_functions;\n\n#if defined(PHP_WIN32) && defined(_DEBUG)\n\t{\n\t\tchar *tmp = getenv(\"PHP_WIN32_DEBUG_HEAP\");\n\t\tif (tmp && ZEND_ATOL(tmp, 0)) {\n\t\t\tint tmp_flag;\n\t\t\t_CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE);\n\t\t\t_CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDERR);\n\t\t\t_CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_FILE);\n\t\t\t_CrtSetReportFile(_CRT_ERROR, _CRTDBG_FILE_STDERR);\n\t\t\t_CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_FILE);\n\t\t\t_CrtSetReportFile(_CRT_ASSERT, _CRTDBG_FILE_STDERR);\n\t\t\ttmp_flag = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);\n\t\t\ttmp_flag |= _CRTDBG_DELAY_FREE_MEM_DF;\n\t\t\ttmp_flag |= _CRTDBG_LEAK_CHECK_DF;\n\n\t\t\t_CrtSetDbgFlag(tmp_flag);\n\t\t}\n\t}\n#endif\n\n#if defined(SIGPIPE) && defined(SIG_IGN)\n\tsignal(SIGPIPE, SIG_IGN); /* ignore SIGPIPE in standalone mode so\n\t\t\t\t\t\t\t\tthat sockets created via fsockopen()\n\t\t\t\t\t\t\t\tdon't kill PHP if the remote site\n\t\t\t\t\t\t\t\tcloses it.  in apache|apxs mode apache\n\t\t\t\t\t\t\t\tdoes that for us!  thies@thieso.net\n\t\t\t\t\t\t\t\t20000419 */\n#endif\n\n#ifdef ZTS\n\tphp_tsrm_startup();\n# ifdef PHP_WIN32\n\tZEND_TSRMLS_CACHE_UPDATE();\n# endif\n#endif\n\n\tzend_signal_startup();\n\n#ifdef PHP_WIN32\n\t_fmode = _O_BINARY;\t\t\t/*sets default for file streams to binary */\n\tsetmode(_fileno(stdin), O_BINARY);\t\t/* make the stdio mode be binary */\n\tsetmode(_fileno(stdout), O_BINARY);\t\t/* make the stdio mode be binary */\n\tsetmode(_fileno(stderr), O_BINARY);\t\t/* make the stdio mode be binary */\n#endif\n\n\twhile ((c = php_getopt(argc, argv, OPTIONS, &php_optarg, &php_optind, 1, 2))!=-1) {\n\t\tswitch (c) {\n\t\t\tcase 'c':\n\t\t\t\tif (ini_path_override) {\n\t\t\t\t\tfree(ini_path_override);\n\t\t\t\t}\n\t\t\t\tini_path_override = strdup(php_optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\tini_ignore = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'd': {\n\t\t\t\t/* define ini entries on command line */\n\t\t\t\tsize_t len = strlen(php_optarg);\n\t\t\t\tchar *val;\n\n\t\t\t\tif ((val = strchr(php_optarg, '='))) {\n\t\t\t\t\tval++;\n\t\t\t\t\tif (!isalnum(*val) && *val != '\"' && *val != '\\'' && *val != '\\0') {\n\t\t\t\t\t\tini_entries = realloc(ini_entries, ini_entries_len + len + sizeof(\"\\\"\\\"\\n\\0\"));\n\t\t\t\t\t\tmemcpy(ini_entries + ini_entries_len, php_optarg, (val - php_optarg));\n\t\t\t\t\t\tini_entries_len += (val - php_optarg);\n\t\t\t\t\t\tmemcpy(ini_entries + ini_entries_len, \"\\\"\", 1);\n\t\t\t\t\t\tini_entries_len++;\n\t\t\t\t\t\tmemcpy(ini_entries + ini_entries_len, val, len - (val - php_optarg));\n\t\t\t\t\t\tini_entries_len += len - (val - php_optarg);\n\t\t\t\t\t\tmemcpy(ini_entries + ini_entries_len, \"\\\"\\n\\0\", sizeof(\"\\\"\\n\\0\"));\n\t\t\t\t\t\tini_entries_len += sizeof(\"\\n\\0\\\"\") - 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tini_entries = realloc(ini_entries, ini_entries_len + len + sizeof(\"\\n\\0\"));\n\t\t\t\t\t\tmemcpy(ini_entries + ini_entries_len, php_optarg, len);\n\t\t\t\t\t\tmemcpy(ini_entries + ini_entries_len + len, \"\\n\\0\", sizeof(\"\\n\\0\"));\n\t\t\t\t\t\tini_entries_len += len + sizeof(\"\\n\\0\") - 2;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tini_entries = realloc(ini_entries, ini_entries_len + len + sizeof(\"=1\\n\\0\"));\n\t\t\t\t\tmemcpy(ini_entries + ini_entries_len, php_optarg, len);\n\t\t\t\t\tmemcpy(ini_entries + ini_entries_len + len, \"=1\\n\\0\", sizeof(\"=1\\n\\0\"));\n\t\t\t\t\tini_entries_len += len + sizeof(\"=1\\n\\0\") - 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n#ifndef PHP_CLI_WIN32_NO_CONSOLE\n\t\t\tcase 'S':\n\t\t\t\tsapi_module = &cli_server_sapi_module;\n\t\t\t\tcli_server_sapi_module.additional_functions = server_additional_functions;\n\t\t\t\tbreak;\n#endif\n\t\t\tcase 'h': /* help & quit */\n\t\t\tcase '?':\n\t\t\t\tphp_cli_usage(argv[0]);\n\t\t\t\tgoto out;\n\t\t\tcase PHP_GETOPT_INVALID_ARG: /* print usage on bad options, exit 1 */\n\t\t\t\tphp_cli_usage(argv[0]);\n\t\t\t\texit_status = 1;\n\t\t\t\tgoto out;\n\t\t\tcase 'i': case 'v': case 'm':\n\t\t\t\tsapi_module = &cli_sapi_module;\n\t\t\t\tgoto exit_loop;\n\t\t\tcase 'e': /* enable extended info output */\n\t\t\t\tuse_extended_info = 1;\n\t\t\t\tbreak;\n\t\t}\n\t}\nexit_loop:\n\n\tsapi_module->ini_defaults = sapi_cli_ini_defaults;\n\tsapi_module->php_ini_path_override = ini_path_override;\n\tsapi_module->phpinfo_as_text = 1;\n\tsapi_module->php_ini_ignore_cwd = 1;\n\tsapi_startup(sapi_module);\n\tsapi_started = 1;\n\n\tsapi_module->php_ini_ignore = ini_ignore;\n\n\tsapi_module->executable_location = argv[0];\n\n\tif (sapi_module == &cli_sapi_module) {\n\t\tif (ini_entries) {\n\t\t\tini_entries = realloc(ini_entries, ini_entries_len + sizeof(HARDCODED_INI));\n\t\t\tmemmove(ini_entries + sizeof(HARDCODED_INI) - 2, ini_entries, ini_entries_len + 1);\n\t\t\tmemcpy(ini_entries, HARDCODED_INI, sizeof(HARDCODED_INI) - 2);\n\t\t} else {\n\t\t\tini_entries = malloc(sizeof(HARDCODED_INI));\n\t\t\tmemcpy(ini_entries, HARDCODED_INI, sizeof(HARDCODED_INI));\n\t\t}\n\t\tini_entries_len += sizeof(HARDCODED_INI) - 2;\n\t}\n\n\tsapi_module->ini_entries = ini_entries;\n\n\t/* startup after we get the above ini override se we get things right */\n\tif (sapi_module->startup(sapi_module) == FAILURE) {\n\t\t/* there is no way to see if we must call zend_ini_deactivate()\n\t\t * since we cannot check if EG(ini_directives) has been initialized\n\t\t * because the executor's constructor does not set initialize it.\n\t\t * Apart from that there seems no need for zend_ini_deactivate() yet.\n\t\t * So we goto out_err.*/\n\t\texit_status = 1;\n\t\tgoto out;\n\t}\n\tmodule_started = 1;\n\n#if defined(PHP_WIN32)\n\tphp_win32_cp_cli_setup();\n\torig_cp = (php_win32_cp_get_orig())->id;\n\t/* Ignore the delivered argv and argc, read from W API. This place\n\t\tmight be too late though, but this is the earliest place ATW\n\t\twe can access the internal charset information from PHP. */\n\targv_wide = CommandLineToArgvW(GetCommandLineW(), &num_args);\n\tPHP_WIN32_CP_W_TO_ANY_ARRAY(argv_wide, num_args, argv, argc)\n\tusing_wide_argv = 1;\n\n\tSetConsoleCtrlHandler(php_cli_win32_ctrl_handler, TRUE);\n#endif\n\n\t/* -e option */\n\tif (use_extended_info) {\n\t\tCG(compiler_options) |= ZEND_COMPILE_EXTENDED_INFO;\n\t}\n\n\tzend_first_try {\n#ifndef PHP_CLI_WIN32_NO_CONSOLE\n\t\tif (sapi_module == &cli_sapi_module) {\n#endif\n\t\t\texit_status = do_cli(argc, argv);\n#ifndef PHP_CLI_WIN32_NO_CONSOLE\n\t\t} else {\n\t\t\texit_status = do_cli_server(argc, argv);\n\t\t}\n#endif\n\t} zend_end_try();\n",
    "target": 0,
    "idx": 2025601
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "\n\nstatic void zend_generator_dtor_storage(zend_object *object) /* {{{ */\n{\n\tzend_generator *generator = (zend_generator*) object;\n\tzend_execute_data *ex = generator->execute_data;\n\tuint32_t op_num, try_catch_offset;\n\tint i;\n\n\t/* leave yield from mode to properly allow finally execution */\n\tif (UNEXPECTED(Z_TYPE(generator->values) != IS_UNDEF)) {\n\t\tzval_ptr_dtor(&generator->values);\n\t\tZVAL_UNDEF(&generator->values);\n\t}\n\n\tzend_generator *parent = generator->node.parent;\n\tif (parent) {\n\t\tzend_generator_remove_child(&parent->node, generator);\n\t\tclear_link_to_root(generator);\n\t\tgenerator->node.parent = NULL;\n\t\tOBJ_RELEASE(&parent->std);\n\t} else {\n\t\tclear_link_to_leaf(generator);\n\t}\n\n\tif (EXPECTED(!ex) || EXPECTED(!(ex->func->op_array.fn_flags & ZEND_ACC_HAS_FINALLY_BLOCK))\n\t\t\t|| CG(unclean_shutdown)) {\n\t\treturn;\n\t}\n\n\t/* -1 required because we want the last run opcode, not the\n\t * next to-be-run one. */\n\top_num = ex->opline - ex->func->op_array.opcodes - 1;\n\ttry_catch_offset = -1;\n\n\t/* Find the innermost try/catch that we are inside of. */\n\tfor (i = 0; i < ex->func->op_array.last_try_catch; i++) {\n\t\tzend_try_catch_element *try_catch = &ex->func->op_array.try_catch_array[i];\n\t\tif (op_num < try_catch->try_op) {\n\t\t\tbreak;\n\t\t}\n\t\tif (op_num < try_catch->catch_op || op_num < try_catch->finally_end) {\n\t\t\ttry_catch_offset = i;\n\t\t}\n\t}\n\n\t/* Walk try/catch/finally structures upwards, performing the necessary actions. */\n\twhile (try_catch_offset != (uint32_t) -1) {\n\t\tzend_try_catch_element *try_catch = &ex->func->op_array.try_catch_array[try_catch_offset];\n\n\t\tif (op_num < try_catch->finally_op) {\n\t\t\t/* Go to finally block */\n\t\t\tzval *fast_call =\n\t\t\t\tZEND_CALL_VAR(ex, ex->func->op_array.opcodes[try_catch->finally_end].op1.var);\n\n\t\t\tzend_generator_cleanup_unfinished_execution(generator, ex, try_catch->finally_op);\n\t\t\tZ_OBJ_P(fast_call) = EG(exception);\n\t\t\tEG(exception) = NULL;\n\t\t\tZ_OPLINE_NUM_P(fast_call) = (uint32_t)-1;\n\n\t\t\tex->opline = &ex->func->op_array.opcodes[try_catch->finally_op];\n\t\t\tgenerator->flags |= ZEND_GENERATOR_FORCED_CLOSE;\n\t\t\tzend_generator_resume(generator);\n\n\t\t\t/* TODO: If we hit another yield inside try/finally,\n\t\t\t * should we also jump to the next finally block? */\n\t\t\treturn;\n\t\t} else if (op_num < try_catch->finally_end) {\n\t\t\tzval *fast_call =\n\t\t\t\tZEND_CALL_VAR(ex, ex->func->op_array.opcodes[try_catch->finally_end].op1.var);\n\t\t\t/* Clean up incomplete return statement */\n\t\t\tif (Z_OPLINE_NUM_P(fast_call) != (uint32_t) -1) {\n\t\t\t\tzend_op *retval_op = &ex->func->op_array.opcodes[Z_OPLINE_NUM_P(fast_call)];\n\t\t\t\tif (retval_op->op2_type & (IS_TMP_VAR | IS_VAR)) {\n\t\t\t\t\tzval_ptr_dtor(ZEND_CALL_VAR(ex, retval_op->op2.var));\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Clean up backed-up exception */\n\t\t\tif (Z_OBJ_P(fast_call)) {\n\t\t\t\tOBJ_RELEASE(Z_OBJ_P(fast_call));\n\t\t\t}\n\t\t}\n\n\t\ttry_catch_offset--;\n\t}\n}\nstatic void zend_generator_throw_exception(zend_generator *generator, zval *exception)\n{\n\tzend_execute_data *original_execute_data = EG(current_execute_data);\n\n\t/* if we don't stop an array/iterator yield from, the exception will only reach the generator after the values were all iterated over */\n\tif (UNEXPECTED(Z_TYPE(generator->values) != IS_UNDEF)) {\n\t\tzval_ptr_dtor(&generator->values);\n\t\tZVAL_UNDEF(&generator->values);\n\t}\n\n\t/* Throw the exception in the context of the generator. Decrementing the opline\n\t * to pretend the exception happened during the YIELD opcode. */\n\tEG(current_execute_data) = generator->execute_data;\n\tgenerator->execute_data->opline--;\n\tif (exception) {\n\t\tzend_throw_exception_object(exception);\n\t} else {\n\t\tzend_rethrow_exception(EG(current_execute_data));\n\t}\n\tgenerator->execute_data->opline++;\n\tEG(current_execute_data) = original_execute_data;\n}\n\n\nstatic void zend_generator_add_child(zend_generator *generator, zend_generator *child)\n{\n\tzend_generator_node *node = &generator->node;\n\n\tif (node->children == 0) {\n\t\tnode->child.single.child = child;\n\t} else {\n\t\tif (node->children == 1) {\n\t\t\tHashTable *ht = emalloc(sizeof(HashTable));\n\t\t\tzend_hash_init(ht, 0, NULL, NULL, 0);\n\t\t\tzend_hash_index_add_new_ptr(ht,\n\t\t\t\t(zend_ulong) node->child.single.child, node->child.single.child);\n\t\t\tnode->child.ht = ht;\n\t\t}\n\n\t\tzend_hash_index_add_new_ptr(node->child.ht, (zend_ulong) child, child);\n\t}\n\n\t++node->children;\n}\n",
    "target": 0,
    "idx": 2025697
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "static avifResult avifParse(avifDecoder * decoder)\n{\n    avifResult readResult;\n    size_t parseOffset = 0;\n    avifDecoderData * data = decoder->data;\n    uint32_t uniqueBoxFlags = 0;\n\n    for (;;) {\n        // Read just enough to get the next box header (a max of 32 bytes)\n        avifROData headerContents;\n        readResult = decoder->io->read(decoder->io, 0, parseOffset, 32, &headerContents);\n        if (readResult != AVIF_RESULT_OK) {\n            return readResult;\n        }\n        if (!headerContents.size) {\n            // If we got AVIF_RESULT_OK from the reader but received 0 bytes,\n            // This we've reached the end of the file with no errors. Hooray!\n            break;\n        }\n\n        // Parse the header, and find out how many bytes it actually was\n        BEGIN_STREAM(headerStream, headerContents.data, headerContents.size);\n        avifBoxHeader header;\n        CHECKERR(avifROStreamReadBoxHeaderPartial(&headerStream, &header), AVIF_RESULT_BMFF_PARSE_FAILED);\n        parseOffset += headerStream.offset;\n\n        // Try to get the remainder of the box, if necessary\n        avifROData boxContents = AVIF_DATA_EMPTY;\n\n        // TODO: reorg this code to only do these memcmps once each\n        if (!memcmp(header.type, \"ftyp\", 4) || (!memcmp(header.type, \"meta\", 4) || !memcmp(header.type, \"moov\", 4))) {\n            readResult = decoder->io->read(decoder->io, 0, parseOffset, header.size, &boxContents);\n            if (readResult != AVIF_RESULT_OK) {\n                return readResult;\n            }\n            if (boxContents.size != header.size) {\n                // A truncated box, bail out\n                return AVIF_RESULT_BMFF_PARSE_FAILED;\n            }\n        }\n\n        if (!memcmp(header.type, \"ftyp\", 4)) {\n            CHECKERR(uniqueBoxSeen(&uniqueBoxFlags, 0), AVIF_RESULT_BMFF_PARSE_FAILED);\n            avifRWDataSet(&data->ftypData, boxContents.data, boxContents.size);\n            CHECKERR(avifParseFileTypeBox(&data->ftyp, data->ftypData.data, data->ftypData.size), AVIF_RESULT_BMFF_PARSE_FAILED);\n        } else if (!memcmp(header.type, \"meta\", 4)) {\n            CHECKERR(uniqueBoxSeen(&uniqueBoxFlags, 1), AVIF_RESULT_BMFF_PARSE_FAILED);\n            CHECKERR(avifParseMetaBox(data->meta, boxContents.data, boxContents.size), AVIF_RESULT_BMFF_PARSE_FAILED);\n        } else if (!memcmp(header.type, \"moov\", 4)) {\n            CHECKERR(uniqueBoxSeen(&uniqueBoxFlags, 2), AVIF_RESULT_BMFF_PARSE_FAILED);\n            CHECKERR(avifParseMoovBox(data, boxContents.data, boxContents.size), AVIF_RESULT_BMFF_PARSE_FAILED);\n        }\n\n        parseOffset += header.size;\n    }\n    return AVIF_RESULT_OK;\n}\n",
    "target": 0,
    "idx": 2025910
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "void\nxmlXIncludeFreeContext(xmlXIncludeCtxtPtr ctxt) {\n    int i;\n\n#ifdef DEBUG_XINCLUDE\n    xmlGenericError(xmlGenericErrorContext, \"Freeing context\\n\");\n#endif\n    if (ctxt == NULL)\n\treturn;\n    while (ctxt->urlNr > 0)\n\txmlXIncludeURLPop(ctxt);\n    if (ctxt->urlTab != NULL)\n\txmlFree(ctxt->urlTab);\n    for (i = 0;i < ctxt->incNr;i++) {\n\tif (ctxt->incTab[i] != NULL)\n\t    xmlXIncludeFreeRef(ctxt->incTab[i]);\n    }\n    if (ctxt->incTab != NULL)\n\txmlFree(ctxt->incTab);\n    if (ctxt->txtTab != NULL) {\n\tfor (i = 0;i < ctxt->txtNr;i++) {\n\t    if (ctxt->txtTab[i] != NULL)\n\t\txmlFree(ctxt->txtTab[i]);\n\t}\n\txmlFree(ctxt->txtTab);\n    }\n    if (ctxt->txturlTab != NULL) {\n\tfor (i = 0;i < ctxt->txtNr;i++) {\n\t    if (ctxt->txturlTab[i] != NULL)\n\t\txmlFree(ctxt->txturlTab[i]);\n\t}\n\txmlFree(ctxt->txturlTab);\n    }\n    if (ctxt->base != NULL) {\n        xmlFree(ctxt->base);\n    }\n    xmlFree(ctxt);\n}\nstatic void\nxmlXIncludeAddTxt(xmlXIncludeCtxtPtr ctxt, const xmlChar *txt,\n                  const xmlURL url) {\n#ifdef DEBUG_XINCLUDE\n    xmlGenericError(xmlGenericErrorContext, \"Adding text %s\\n\", url);\n#endif\n    if (ctxt->txtMax == 0) {\n\tctxt->txtMax = 4;\n        ctxt->txtTab = (xmlChar **) xmlMalloc(ctxt->txtMax *\n\t\t                          sizeof(ctxt->txtTab[0]));\n        if (ctxt->txtTab == NULL) {\n\t    xmlXIncludeErrMemory(ctxt, NULL, \"processing text\");\n\t    return;\n\t}\n        ctxt->txturlTab = (xmlURL *) xmlMalloc(ctxt->txtMax *\n\t\t                          sizeof(ctxt->txturlTab[0]));\n        if (ctxt->txturlTab == NULL) {\n\t    xmlXIncludeErrMemory(ctxt, NULL, \"processing text\");\n\t    return;\n\t}\n    }\n    if (ctxt->txtNr >= ctxt->txtMax) {\n\tctxt->txtMax *= 2;\n        ctxt->txtTab = (xmlChar **) xmlRealloc(ctxt->txtTab,\n\t             ctxt->txtMax * sizeof(ctxt->txtTab[0]));\n        if (ctxt->txtTab == NULL) {\n\t    xmlXIncludeErrMemory(ctxt, NULL, \"processing text\");\n\t    return;\n\t}\n        ctxt->txturlTab = (xmlURL *) xmlRealloc(ctxt->txturlTab,\n\t             ctxt->txtMax * sizeof(ctxt->txturlTab[0]));\n        if (ctxt->txturlTab == NULL) {\n\t    xmlXIncludeErrMemory(ctxt, NULL, \"processing text\");\n\t    return;\n\t}\n    }\n    ctxt->txtTab[ctxt->txtNr] = xmlStrdup(txt);\n    ctxt->txturlTab[ctxt->txtNr] = xmlStrdup(url);\n    ctxt->txtNr++;\n}\nstatic int\nxmlXIncludeLoadTxt(xmlXIncludeCtxtPtr ctxt, const xmlChar *url, int nr) {\n    xmlParserInputBufferPtr buf;\n    xmlNodePtr node;\n    xmlURIPtr uri;\n    xmlChar *URL;\n    int i;\n    xmlChar *encoding = NULL;\n    xmlCharEncoding enc = (xmlCharEncoding) 0;\n    xmlParserCtxtPtr pctxt;\n    xmlParserInputPtr inputStream;\n    int xinclude_multibyte_fallback_used = 0;\n\n    /* Don't read from stdin. */\n    if (xmlStrcmp(url, BAD_CAST \"-\") == 0)\n        url = BAD_CAST \"./-\";\n\n    /*\n     * Check the URL and remove any fragment identifier\n     */\n    uri = xmlParseURI((const char *)url);\n    if (uri == NULL) {\n\txmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref, XML_XINCLUDE_HREF_URI,\n\t               \"invalid value URI %s\\n\", url);\n\treturn(-1);\n    }\n    if (uri->fragment != NULL) {\n\txmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref, XML_XINCLUDE_TEXT_FRAGMENT,\n\t               \"fragment identifier forbidden for text: %s\\n\",\n\t\t       (const xmlChar *) uri->fragment);\n\txmlFreeURI(uri);\n\treturn(-1);\n    }\n    URL = xmlSaveUri(uri);\n    xmlFreeURI(uri);\n    if (URL == NULL) {\n\txmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref, XML_XINCLUDE_HREF_URI,\n\t               \"invalid value URI %s\\n\", url);\n\treturn(-1);\n    }\n\n    /*\n     * Handling of references to the local document are done\n     * directly through ctxt->doc.\n     */\n    if (URL[0] == 0) {\n\txmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t               XML_XINCLUDE_TEXT_DOCUMENT,\n\t\t       \"text serialization of document not available\\n\", NULL);\n\txmlFree(URL);\n\treturn(-1);\n    }\n\n    /*\n     * Prevent reloading twice the document.\n     */\n    for (i = 0; i < ctxt->txtNr; i++) {\n\tif (xmlStrEqual(URL, ctxt->txturlTab[i])) {\n            node = xmlNewText(ctxt->txtTab[i]);\n\t    goto loaded;\n\t}\n    }\n    /*\n     * Try to get the encoding if available\n     */\n    if ((ctxt->incTab[nr] != NULL) && (ctxt->incTab[nr]->ref != NULL)) {\n\tencoding = xmlGetProp(ctxt->incTab[nr]->ref, XINCLUDE_PARSE_ENCODING);\n    }\n    if (encoding != NULL) {\n\t/*\n\t * TODO: we should not have to remap to the xmlCharEncoding\n\t *       predefined set, a better interface than\n\t *       xmlParserInputBufferCreateFilename should allow any\n\t *       encoding supported by iconv\n\t */\n        enc = xmlParseCharEncoding((const char *) encoding);\n\tif (enc == XML_CHAR_ENCODING_ERROR) {\n\t    xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t                   XML_XINCLUDE_UNKNOWN_ENCODING,\n\t\t\t   \"encoding %s not supported\\n\", encoding);\n\t    xmlFree(encoding);\n\t    xmlFree(URL);\n\t    return(-1);\n\t}\n\txmlFree(encoding);\n    }\n\n    /*\n     * Load it.\n     */\n    pctxt = xmlNewParserCtxt();\n    inputStream = xmlLoadExternalEntity((const char*)URL, NULL, pctxt);\n    if(inputStream == NULL) {\n\txmlFreeParserCtxt(pctxt);\n\txmlFree(URL);\n\treturn(-1);\n    }\n    buf = inputStream->buf;\n    if (buf == NULL) {\n\txmlFreeInputStream (inputStream);\n\txmlFreeParserCtxt(pctxt);\n\txmlFree(URL);\n\treturn(-1);\n    }\n    if (buf->encoder)\n\txmlCharEncCloseFunc(buf->encoder);\n    buf->encoder = xmlGetCharEncodingHandler(enc);\n    node = xmlNewText(NULL);\n\n    /*\n     * Scan all chars from the resource and add the to the node\n     */\nxinclude_multibyte_fallback:\n    while (xmlParserInputBufferRead(buf, 128) > 0) {\n\tint len;\n\tconst xmlChar *content;\n\n\tcontent = xmlBufContent(buf->buffer);\n\tlen = xmlBufLength(buf->buffer);\n\tfor (i = 0;i < len;) {\n\t    int cur;\n\t    int l;\n\n\t    cur = xmlStringCurrentChar(NULL, &content[i], &l);\n\t    if (!IS_CHAR(cur)) {\n\t\t/* Handle split multibyte char at buffer boundary */\n\t\tif (((len - i) < 4) && (!xinclude_multibyte_fallback_used)) {\n\t\t    xinclude_multibyte_fallback_used = 1;\n\t\t    xmlBufShrink(buf->buffer, i);\n\t\t    goto xinclude_multibyte_fallback;\n\t\t} else {\n\t\t    xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t\t\t\t   XML_XINCLUDE_INVALID_CHAR,\n\t\t\t\t   \"%s contains invalid char\\n\", URL);\n\t\t    xmlFreeParserCtxt(pctxt);\n\t\t    xmlFreeParserInputBuffer(buf);\n\t\t    xmlFree(URL);\n\t\t    return(-1);\n\t\t}\n\t    } else {\n\t\txinclude_multibyte_fallback_used = 0;\n\t\txmlNodeAddContentLen(node, &content[i], l);\n\t    }\n\t    i += l;\n\t}\n\txmlBufShrink(buf->buffer, len);\n    }\n    xmlFreeParserCtxt(pctxt);\n    xmlXIncludeAddTxt(ctxt, node->content, URL);\n    xmlFreeInputStream(inputStream);\n\nloaded:\n    /*\n     * Add the element as the replacement copy.\n     */\n    ctxt->incTab[nr]->inc = node;\n    xmlFree(URL);\n    return(0);\n}\n",
    "target": 0,
    "idx": 2026022
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "extern \"C\" int\nLLVMFuzzerTestOneInput(const uint8_t* data, size_t size) { \n\tif(size<3) return 0;\n\n\tleptSetStdNullHandler();\n\n\n\tPIX *pixs_payload = pixReadMemSpix(data, size);\n\tif(pixs_payload == NULL) return 0;\n\n\tPIX *pix1, *pix2, *pix3, *pix4, *pix5, *return_pix1, *payload_copy;\n\n\tpix1 = pixRead(\"../test8.jpg\");\n\tpayload_copy = pixCopy(NULL, pixs_payload);\n\tpixBackgroundNormGrayArray(payload_copy, pix1, 10, 10, 10, 10, 256, 10, 10, &pix2);\n\tpixDestroy(&pix1);\n\tpixDestroy(&pix2);\n\tpixDestroy(&payload_copy);\n\n\n\n\tpix1 = pixRead(\"../test8.jpg\");\n\tpayload_copy = pixCopy(NULL, pixs_payload);\n\tpixBackgroundNormGrayArrayMorph(payload_copy, pix1, 6, 5, 256, &pix2);\n\tpixDestroy(&pix1);\n\tpixDestroy(&pix2);\n\tpixDestroy(&payload_copy);\n\n\n\tpix1 = pixRead(\"../test8.jpg\");\n\tpayload_copy = pixCopy(NULL, pixs_payload);\n\treturn_pix1 = pixBackgroundNormMorph(payload_copy, pix1, 6, 5, 256);\n\tpixDestroy(&pix1);\n\tpixDestroy(&payload_copy);\n\tif(return_pix1!=NULL){\n\t\tpixDestroy(&return_pix1);\n\t}\n\n\n\tpix1 = pixRead(\"../test8.jpg\");\n\tpix2 = pixRead(\"../test8.jpg\");\n\tpayload_copy = pixCopy(NULL, pixs_payload);\n\tpixBackgroundNormRGBArrays(payload_copy, pix1, pix2, 10, 10, 10, 10, 130, 10, 10, &pix3, &pix4, &pix5);\n\tpixDestroy(&pix1);\n\tpixDestroy(&pix2);\n\tpixDestroy(&pix3);\n\tpixDestroy(&pix4);\n\tpixDestroy(&pix5);\n\tpixDestroy(&payload_copy);\n\n\n\tpix1 = pixRead(\"../test8.jpg\");\n\tpayload_copy = pixCopy(NULL, pixs_payload);\n\tpixBackgroundNormRGBArraysMorph(payload_copy, pix1, 6, 33, 130, &pix2, &pix3, &pix4);\n\tpixDestroy(&pix1);\n\tpixDestroy(&pix2);\n\tpixDestroy(&pix3);\n\tpixDestroy(&pix4);\n\tpixDestroy(&payload_copy);\n\n\n\tpix1 = pixRead(\"../test8.jpg\");\n\tpayload_copy = pixCopy(NULL, pixs_payload);\n\tpixContrastNorm(payload_copy, pix1, 10, 10, 3, 0, 0);\n\tpixDestroy(&pix1);\n\tpixDestroy(&payload_copy);\n\n\n\tpix1 = pixRead(\"../test8.jpg\");\n\tpayload_copy = pixCopy(NULL, pixs_payload);\n\treturn_pix1 = pixGlobalNormNoSatRGB(payload_copy, pix1, 3, 3, 3, 2, 0.9);\n\tpixDestroy(&pix1);\n\tpixDestroy(&payload_copy);\n\tif(return_pix1!=NULL){\n\t\tpixDestroy(&return_pix1);\n\t}\n\n\n\tpayload_copy = pixCopy(NULL, pixs_payload);\n\tpixThresholdSpreadNorm(payload_copy, L_SOBEL_EDGE, 10, 0, 0, 0.7, -25, 255, 10, &pix1, &pix2, &pix3);\n\tpixDestroy(&pix1);\n\tpixDestroy(&pix2);\n\tpixDestroy(&pix3);\n\tpixDestroy(&payload_copy);\n\n\tpixDestroy(&pixs_payload);\n\n\n\treturn 0;\n}\n",
    "target": 0,
    "idx": 2026967
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "flb_sds_t flb_pack_msgpack_to_json_format(const char *data, uint64_t bytes,\n                                          int json_format, int date_format,\n                                          flb_sds_t date_key)\n{\n    int i;\n    int len;\n    int ok = MSGPACK_UNPACK_SUCCESS;\n    int records = 0;\n    int map_size;\n    size_t off = 0;\n    char time_formatted[32];\n    size_t s;\n    flb_sds_t out_tmp;\n    flb_sds_t out_js;\n    flb_sds_t out_buf = NULL;\n    msgpack_unpacked result;\n    msgpack_object root;\n    msgpack_object map;\n    msgpack_sbuffer tmp_sbuf;\n    msgpack_packer tmp_pck;\n    msgpack_object *obj;\n    msgpack_object *k;\n    msgpack_object *v;\n    struct tm tm;\n    struct flb_time tms;\n\n    /* Iterate the original buffer and perform adjustments */\n    records = flb_mp_count(data, bytes);\n    if (records <= 0) {\n        return NULL;\n    }\n\n    /* For json lines and streams mode we need a pre-allocated buffer */\n    if (json_format == FLB_PACK_JSON_FORMAT_LINES ||\n        json_format == FLB_PACK_JSON_FORMAT_STREAM) {\n        out_buf = flb_sds_create_size(bytes + bytes / 4);\n        if (!out_buf) {\n            flb_errno();\n            return NULL;\n        }\n    }\n\n    /* Create temporary msgpack buffer */\n    msgpack_sbuffer_init(&tmp_sbuf);\n    msgpack_packer_init(&tmp_pck, &tmp_sbuf, msgpack_sbuffer_write);\n\n    /*\n     * If the format is the original msgpack style of one big array,\n     * registrate the array, otherwise is not necessary. FYI, original format:\n     *\n     * [\n     *   [timestamp, map],\n     *   [timestamp, map],\n     *   [T, M]...\n     * ]\n     */\n    if (json_format == FLB_PACK_JSON_FORMAT_JSON) {\n        msgpack_pack_array(&tmp_pck, records);\n    }\n\n    msgpack_unpacked_init(&result);\n    while (msgpack_unpack_next(&result, data, bytes, &off) == ok) {\n        /* Each array must have two entries: time and record */\n        root = result.data;\n        if (root.type != MSGPACK_OBJECT_ARRAY) {\n            continue;\n        }\n        if (root.via.array.size != 2) {\n            continue;\n        }\n\n        /* Unpack time */\n        flb_time_pop_from_msgpack(&tms, &result, &obj);\n\n        /* Get the record/map */\n        map = root.via.array.ptr[1];\n        if (map.type != MSGPACK_OBJECT_MAP) {\n            continue;\n        }\n        map_size = map.via.map.size;\n\n        if (date_key != NULL) {\n            msgpack_pack_map(&tmp_pck, map_size + 1);\n        }\n        else {\n            msgpack_pack_map(&tmp_pck, map_size);\n        }\n\n        if (date_key != NULL) {\n            /* Append date key */\n            msgpack_pack_str(&tmp_pck, flb_sds_len(date_key));\n            msgpack_pack_str_body(&tmp_pck, date_key, flb_sds_len(date_key));\n\n            /* Append date value */\n            switch (date_format) {\n            case FLB_PACK_JSON_DATE_DOUBLE:\n                msgpack_pack_double(&tmp_pck, flb_time_to_double(&tms));\n                break;\n            case FLB_PACK_JSON_DATE_ISO8601:\n            /* Format the time, use microsecond precision not nanoseconds */\n                gmtime_r(&tms.tm.tv_sec, &tm);\n                s = strftime(time_formatted, sizeof(time_formatted) - 1,\n                             FLB_PACK_JSON_DATE_ISO8601_FMT, &tm);\n\n                len = snprintf(time_formatted + s,\n                               sizeof(time_formatted) - 1 - s,\n                               \".%06\" PRIu64 \"Z\",\n                               (uint64_t) tms.tm.tv_nsec / 1000);\n                s += len;\n                msgpack_pack_str(&tmp_pck, s);\n                msgpack_pack_str_body(&tmp_pck, time_formatted, s);\n                break;\n            case FLB_PACK_JSON_DATE_EPOCH:\n                msgpack_pack_uint64(&tmp_pck, (long long unsigned)(tms.tm.tv_sec));\n                break;\n            }\n        }\n\n        /* Append remaining keys/values */\n        for (i = 0; i < map_size; i++) {\n            k = &map.via.map.ptr[i].key;\n            v = &map.via.map.ptr[i].val;\n            msgpack_pack_object(&tmp_pck, *k);\n            msgpack_pack_object(&tmp_pck, *v);\n        }\n\n        /*\n         * If the format is the original msgpack style, just continue since\n         * we don't care about separator or JSON convertion at this point.\n         */\n        if (json_format == FLB_PACK_JSON_FORMAT_JSON) {\n            continue;\n        }\n\n        /*\n         * Here we handle two types of records concatenation:\n         *\n         * FLB_PACK_JSON_FORMAT_LINES: add  breakline (\\n) after each record\n         *\n         *\n         *     {'ts':abc,'k1':1}\n         *     {'ts':abc,'k1':2}\n         *     {N}\n         *\n         * FLB_PACK_JSON_FORMAT_STREAM: no separators, e.g:\n         *\n         *     {'ts':abc,'k1':1}{'ts':abc,'k1':2}{N}\n         */\n        if (json_format == FLB_PACK_JSON_FORMAT_LINES ||\n            json_format == FLB_PACK_JSON_FORMAT_STREAM) {\n\n            /* Encode current record into JSON in a temporary variable */\n            out_js = flb_msgpack_raw_to_json_sds(tmp_sbuf.data, tmp_sbuf.size);\n            if (!out_js) {\n                msgpack_sbuffer_destroy(&tmp_sbuf);\n                flb_sds_destroy(out_buf);\n                return NULL;\n            }\n\n            /*\n             * One map record has been converted, now append it to the\n             * outgoing out_buf sds variable.\n             */\n            out_tmp = flb_sds_cat(out_buf, out_js, flb_sds_len(out_js));\n            if (!out_tmp) {\n                msgpack_sbuffer_destroy(&tmp_sbuf);\n                flb_sds_destroy(out_js);\n                flb_sds_destroy(out_buf);\n                return NULL;\n            }\n\n            /* Release temporary json sds buffer */\n            flb_sds_destroy(out_js);\n\n            /* If a realloc happened, check the returned address */\n            if (out_tmp != out_buf) {\n                out_buf = out_tmp;\n            }\n\n            /* Append the breakline only for json lines mode */\n            if (json_format == FLB_PACK_JSON_FORMAT_LINES) {\n                out_tmp = flb_sds_cat(out_buf, \"\\n\", 1);\n                if (!out_tmp) {\n                    msgpack_sbuffer_destroy(&tmp_sbuf);\n                    flb_sds_destroy(out_buf);\n                    return NULL;\n                }\n                if (out_tmp != out_buf) {\n                    out_buf = out_tmp;\n                }\n            }\n            msgpack_sbuffer_clear(&tmp_sbuf);\n        }\n    }\n\n    /* Release the unpacker */\n    msgpack_unpacked_destroy(&result);\n\n    /* Format to JSON */\n    if (json_format == FLB_PACK_JSON_FORMAT_JSON) {\n        out_buf = flb_msgpack_raw_to_json_sds(tmp_sbuf.data, tmp_sbuf.size);\n        msgpack_sbuffer_destroy(&tmp_sbuf);\n\n        if (!out_buf) {\n            return NULL;\n        }\n    }\n    else {\n        msgpack_sbuffer_destroy(&tmp_sbuf);\n    }\n\n    if (out_buf && flb_sds_len(out_buf) == 0) {\n        flb_sds_destroy(out_buf);\n        return NULL;\n    }\n\n    return out_buf;\n}\n",
    "target": 0,
    "idx": 2027742
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "int __cil_resolve_ast_last_child_helper(struct cil_tree_node *current, void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_args_resolve *args = extra_args;\n\tstruct cil_tree_node *parent = NULL;\n\tstruct cil_tree_node *blockstack = NULL;\n\n\tif (current == NULL ||  extra_args == NULL) {\n\t\tgoto exit;\n\t}\n\n\tparent = current->parent;\n\n\tif (parent->flavor == CIL_MACRO) {\n\t\targs->macro = NULL;\n\t} else if (parent->flavor == CIL_OPTIONAL) {\n\t\tstruct cil_tree_node *optstack;\n\n\t\tif (((struct cil_optional *)parent->data)->enabled == CIL_FALSE) {\n\t\t\t*(args->changed) = CIL_TRUE;\n\t\t\tcil_list_append(args->disabled_optionals, CIL_NODE, parent);\n\t\t}\n\n\t\t/* pop off the stack */\n\t\toptstack = args->optstack;\n\t\targs->optstack = optstack->cl_head;\n\t\tif (optstack->cl_head) {\n\t\t\toptstack->cl_head->parent = NULL;\n\t\t}\n\t\tfree(optstack);\n\t} else if (parent->flavor == CIL_BOOLEANIF) {\n\t\targs->boolif = NULL;\n\t} else if (parent->flavor == CIL_BLOCK) {\n\t\t/* pop off the stack */\n\t\tblockstack = args->blockstack;\n\t\targs->blockstack = blockstack->cl_head;\n\t\tif (blockstack->cl_head) {\n\t\t\tblockstack->cl_head->parent = NULL;\n\t\t}\n\t\tfree(blockstack);\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n",
    "target": 0,
    "idx": 2028470
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "int __cil_resolve_ast_last_child_helper(struct cil_tree_node *current, void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_args_resolve *args = extra_args;\n\tstruct cil_tree_node *parent = NULL;\n\tstruct cil_tree_node *blockstack = NULL;\n\n\tif (current == NULL ||  extra_args == NULL) {\n\t\tgoto exit;\n\t}\n\n\tparent = current->parent;\n\n\tif (parent->flavor == CIL_MACRO) {\n\t\targs->macro = NULL;\n\t} else if (parent->flavor == CIL_OPTIONAL) {\n\t\tstruct cil_tree_node *optstack;\n\n\t\tif (((struct cil_optional *)parent->data)->enabled == CIL_FALSE) {\n\t\t\t*(args->changed) = CIL_TRUE;\n\t\t\tcil_list_append(args->disabled_optionals, CIL_NODE, parent);\n\t\t}\n\n\t\t/* pop off the stack */\n\t\toptstack = args->optstack;\n\t\targs->optstack = optstack->cl_head;\n\t\tif (optstack->cl_head) {\n\t\t\toptstack->cl_head->parent = NULL;\n\t\t}\n\t\tfree(optstack);\n\t} else if (parent->flavor == CIL_BOOLEANIF) {\n\t\targs->boolif = NULL;\n\t} else if (parent->flavor == CIL_BLOCK) {\n\t\t/* pop off the stack */\n\t\tblockstack = args->blockstack;\n\t\targs->blockstack = blockstack->cl_head;\n\t\tif (blockstack->cl_head) {\n\t\t\tblockstack->cl_head->parent = NULL;\n\t\t}\n\t\tfree(blockstack);\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n",
    "target": 0,
    "idx": 2028478
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "int __cil_resolve_ast_last_child_helper(struct cil_tree_node *current, void *extra_args)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_args_resolve *args = extra_args;\n\tstruct cil_tree_node *parent = NULL;\n\tstruct cil_tree_node *blockstack = NULL;\n\n\tif (current == NULL ||  extra_args == NULL) {\n\t\tgoto exit;\n\t}\n\n\tparent = current->parent;\n\n\tif (parent->flavor == CIL_MACRO) {\n\t\targs->macro = NULL;\n\t} else if (parent->flavor == CIL_OPTIONAL) {\n\t\tstruct cil_tree_node *optstack;\n\n\t\tif (((struct cil_optional *)parent->data)->enabled == CIL_FALSE) {\n\t\t\t*(args->changed) = CIL_TRUE;\n\t\t\tcil_list_append(args->disabled_optionals, CIL_NODE, parent);\n\t\t}\n\n\t\t/* pop off the stack */\n\t\toptstack = args->optstack;\n\t\targs->optstack = optstack->cl_head;\n\t\tif (optstack->cl_head) {\n\t\t\toptstack->cl_head->parent = NULL;\n\t\t}\n\t\tfree(optstack);\n\t} else if (parent->flavor == CIL_BOOLEANIF) {\n\t\targs->boolif = NULL;\n\t} else if (parent->flavor == CIL_BLOCK) {\n\t\t/* pop off the stack */\n\t\tblockstack = args->blockstack;\n\t\targs->blockstack = blockstack->cl_head;\n\t\tif (blockstack->cl_head) {\n\t\t\tblockstack->cl_head->parent = NULL;\n\t\t}\n\t\tfree(blockstack);\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}\n",
    "target": 0,
    "idx": 2029002
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "static int igraph_i_gml_toreal(igraph_gml_tree_t *node, long int pos, igraph_real_t *result) {\n\n    igraph_real_t value = 0.0;\n    int type = igraph_gml_tree_type(node, pos);\n\n    switch (type) {\n    case IGRAPH_I_GML_TREE_INTEGER:\n        value = igraph_gml_tree_get_integer(node, pos);\n        break;\n    case IGRAPH_I_GML_TREE_REAL:\n        value = igraph_gml_tree_get_real(node, pos);\n        break;\n    default:\n        IGRAPH_ERROR(\"Internal error while parsing GML file\", IGRAPH_FAILURE);\n        break;\n    }\n\n    *result = value;\n\treturn IGRAPH_SUCCESS;\n}\nint igraph_read_graph_gml(igraph_t *graph, FILE *instream) {\n\n    long int i, p;\n    long int no_of_nodes = 0, no_of_edges = 0;\n    igraph_trie_t trie;\n    igraph_vector_t edges;\n    igraph_bool_t directed = IGRAPH_UNDIRECTED;\n    igraph_gml_tree_t *gtree;\n    long int gidx;\n    igraph_trie_t vattrnames;\n    igraph_trie_t eattrnames;\n    igraph_trie_t gattrnames;\n    igraph_vector_ptr_t gattrs = IGRAPH_VECTOR_PTR_NULL,\n                        vattrs = IGRAPH_VECTOR_PTR_NULL, eattrs = IGRAPH_VECTOR_PTR_NULL;\n    igraph_vector_ptr_t *attrs[3];\n    long int edgeptr = 0;\n    igraph_i_gml_parsedata_t context;\n\n    attrs[0] = &gattrs; attrs[1] = &vattrs; attrs[2] = &eattrs;\n\n    IGRAPH_CHECK(igraph_i_gml_parsedata_init(&context));\n    IGRAPH_FINALLY(igraph_i_gml_parsedata_destroy, &context);\n\n    igraph_gml_yylex_init_extra(&context, &context.scanner);\n\n    igraph_gml_yyset_in(instream, context.scanner);\n\n    i = igraph_gml_yyparse(&context);\n    if (i != 0) {\n        if (context.errmsg[0] != 0) {\n            IGRAPH_ERROR(context.errmsg, IGRAPH_PARSEERROR);\n        } else {\n            IGRAPH_ERROR(\"Cannot read GML file\", IGRAPH_PARSEERROR);\n        }\n    }\n\n    IGRAPH_VECTOR_INIT_FINALLY(&edges, 0);\n\n    /* Check version, if present, integer and not '1' then ignored */\n    i = igraph_gml_tree_find(context.tree, \"Version\", 0);\n    if (i >= 0 &&\n        igraph_gml_tree_type(context.tree, i) == IGRAPH_I_GML_TREE_INTEGER &&\n        igraph_gml_tree_get_integer(context.tree, i) != 1) {\n        igraph_gml_tree_destroy(context.tree);\n        IGRAPH_ERROR(\"Unknown GML version\", IGRAPH_UNIMPLEMENTED);\n        /* RETURN HERE!!!! */\n    }\n\n    /* get the graph */\n    gidx = igraph_gml_tree_find(context.tree, \"graph\", 0);\n    if (gidx == -1) {\n        IGRAPH_ERROR(\"No 'graph' object in GML file\", IGRAPH_PARSEERROR);\n    }\n    if (igraph_gml_tree_type(context.tree, gidx) !=\n        IGRAPH_I_GML_TREE_TREE) {\n        IGRAPH_ERROR(\"Invalid type for 'graph' object in GML file\", IGRAPH_PARSEERROR);\n    }\n    gtree = igraph_gml_tree_get_tree(context.tree, gidx);\n\n    IGRAPH_FINALLY(igraph_i_gml_destroy_attrs, attrs);\n    igraph_vector_ptr_init(&gattrs, 0);\n    igraph_vector_ptr_init(&vattrs, 0);\n    igraph_vector_ptr_init(&eattrs, 0);\n\n    IGRAPH_TRIE_INIT_FINALLY(&trie, 0);\n    IGRAPH_TRIE_INIT_FINALLY(&vattrnames, 0);\n    IGRAPH_TRIE_INIT_FINALLY(&eattrnames, 0);\n    IGRAPH_TRIE_INIT_FINALLY(&gattrnames, 0);\n\n    /* Is is directed? */\n    i = igraph_gml_tree_find(gtree, \"directed\", 0);\n    if (i >= 0 && igraph_gml_tree_type(gtree, i) == IGRAPH_I_GML_TREE_INTEGER) {\n        if (igraph_gml_tree_get_integer(gtree, i) == 1) {\n            directed = IGRAPH_DIRECTED;\n        }\n    }\n\n    /* Now we go over all objects in the graph and collect the attribute names and\n       types. Plus we collect node ids. We also do some checks. */\n    for (i = 0; i < igraph_gml_tree_length(gtree); i++) {\n        long int j;\n        char cname[100];\n        const char *name = igraph_gml_tree_name(gtree, i);\n        if (!strcmp(name, \"node\")) {\n            igraph_gml_tree_t *node;\n            igraph_bool_t hasid;\n            no_of_nodes++;\n            if (igraph_gml_tree_type(gtree, i) != IGRAPH_I_GML_TREE_TREE) {\n                IGRAPH_ERROR(\"'node' is not a list\", IGRAPH_PARSEERROR);\n            }\n            node = igraph_gml_tree_get_tree(gtree, i);\n            hasid = 0;\n            for (j = 0; j < igraph_gml_tree_length(node); j++) {\n                const char *name = igraph_gml_tree_name(node, j);\n                long int trieid, triesize = igraph_trie_size(&vattrnames);\n                IGRAPH_CHECK(igraph_trie_get(&vattrnames, name, &trieid));\n                if (trieid == triesize) {\n                    /* new attribute */\n                    igraph_attribute_record_t *atrec = igraph_Calloc(1, igraph_attribute_record_t);\n                    int type = igraph_gml_tree_type(node, j);\n                    if (!atrec) {\n                        IGRAPH_ERROR(\"Cannot read GML file\", IGRAPH_ENOMEM);\n                    }\n                    IGRAPH_CHECK(igraph_vector_ptr_push_back(&vattrs, atrec));\n                    atrec->name = strdup(name);\n                    if (type == IGRAPH_I_GML_TREE_INTEGER || type == IGRAPH_I_GML_TREE_REAL) {\n                        atrec->type = IGRAPH_ATTRIBUTE_NUMERIC;\n                    } else {\n                        atrec->type = IGRAPH_ATTRIBUTE_STRING;\n                    }\n                } else {\n                    /* already seen, should we update type? */\n                    igraph_attribute_record_t *atrec = VECTOR(vattrs)[trieid];\n                    int type1 = atrec->type;\n                    int type2 = igraph_gml_tree_type(node, j);\n                    if (type1 == IGRAPH_ATTRIBUTE_NUMERIC && type2 == IGRAPH_I_GML_TREE_STRING) {\n                        atrec->type = IGRAPH_ATTRIBUTE_STRING;\n                    }\n                }\n                /* check id */\n                if (!hasid && !strcmp(name, \"id\")) {\n                    long int id;\n                    if (igraph_gml_tree_type(node, j) != IGRAPH_I_GML_TREE_INTEGER) {\n                        IGRAPH_ERROR(\"Non-integer node id in GML file\", IGRAPH_PARSEERROR);\n                    }\n                    id = igraph_gml_tree_get_integer(node, j);\n                    snprintf(cname, sizeof(cname) / sizeof(char) -1, \"%li\", id);\n                    IGRAPH_CHECK(igraph_trie_get(&trie, cname, &id));\n                    hasid = 1;\n                }\n            }\n            if (!hasid) {\n                IGRAPH_ERROR(\"Node without 'id' while parsing GML file\", IGRAPH_PARSEERROR);\n            }\n        } else if (!strcmp(name, \"edge\")) {\n            igraph_gml_tree_t *edge;\n            igraph_bool_t has_source = 0, has_target = 0;\n            no_of_edges++;\n            if (igraph_gml_tree_type(gtree, i) != IGRAPH_I_GML_TREE_TREE) {\n                IGRAPH_ERROR(\"'edge' is not a list\", IGRAPH_PARSEERROR);\n            }\n            edge = igraph_gml_tree_get_tree(gtree, i);\n            has_source = has_target = 0;\n            for (j = 0; j < igraph_gml_tree_length(edge); j++) {\n                const char *name = igraph_gml_tree_name(edge, j);\n                if (!strcmp(name, \"source\")) {\n                    has_source = 1;\n                    if (igraph_gml_tree_type(edge, j) != IGRAPH_I_GML_TREE_INTEGER) {\n                        IGRAPH_ERROR(\"Non-integer 'source' for an edge in GML file\",\n                                     IGRAPH_PARSEERROR);\n                    }\n                } else if (!strcmp(name, \"target\")) {\n                    has_target = 1;\n                    if (igraph_gml_tree_type(edge, j) != IGRAPH_I_GML_TREE_INTEGER) {\n                        IGRAPH_ERROR(\"Non-integer 'source' for an edge in GML file\",\n                                     IGRAPH_PARSEERROR);\n                    }\n                } else {\n                    long int trieid, triesize = igraph_trie_size(&eattrnames);\n                    IGRAPH_CHECK(igraph_trie_get(&eattrnames, name, &trieid));\n                    if (trieid == triesize) {\n                        /* new attribute */\n                        igraph_attribute_record_t *atrec = igraph_Calloc(1, igraph_attribute_record_t);\n                        int type = igraph_gml_tree_type(edge, j);\n                        if (!atrec) {\n                            IGRAPH_ERROR(\"Cannot read GML file\", IGRAPH_ENOMEM);\n                        }\n                        IGRAPH_CHECK(igraph_vector_ptr_push_back(&eattrs, atrec));\n                        atrec->name = strdup(name);\n                        if (type == IGRAPH_I_GML_TREE_INTEGER || type == IGRAPH_I_GML_TREE_REAL) {\n                            atrec->type = IGRAPH_ATTRIBUTE_NUMERIC;\n                        } else {\n                            atrec->type = IGRAPH_ATTRIBUTE_STRING;\n                        }\n                    } else {\n                        /* already seen, should we update type? */\n                        igraph_attribute_record_t *atrec = VECTOR(eattrs)[trieid];\n                        int type1 = atrec->type;\n                        int type2 = igraph_gml_tree_type(edge, j);\n                        if (type1 == IGRAPH_ATTRIBUTE_NUMERIC && type2 == IGRAPH_I_GML_TREE_STRING) {\n                            atrec->type = IGRAPH_ATTRIBUTE_STRING;\n                        }\n                    }\n                }\n            } /* for */\n            if (!has_source) {\n                IGRAPH_ERROR(\"No 'source' for edge in GML file\", IGRAPH_PARSEERROR);\n            }\n            if (!has_target) {\n                IGRAPH_ERROR(\"No 'target' for edge in GML file\", IGRAPH_PARSEERROR);\n            }\n        } else {\n            /* anything to do? Maybe add as graph attribute.... */\n        }\n    }\n\n    /* check vertex id uniqueness */\n    if (igraph_trie_size(&trie) != no_of_nodes) {\n        IGRAPH_ERROR(\"Node 'id' not unique\", IGRAPH_PARSEERROR);\n    }\n\n    /* now we allocate the vectors and strvectors for the attributes */\n    for (i = 0; i < igraph_vector_ptr_size(&vattrs); i++) {\n        igraph_attribute_record_t *atrec = VECTOR(vattrs)[i];\n        int type = atrec->type;\n        if (type == IGRAPH_ATTRIBUTE_NUMERIC) {\n            igraph_vector_t *p = igraph_Calloc(1, igraph_vector_t);\n            atrec->value = p;\n            IGRAPH_CHECK(igraph_vector_init(p, no_of_nodes));\n        } else if (type == IGRAPH_ATTRIBUTE_STRING) {\n            igraph_strvector_t *p = igraph_Calloc(1, igraph_strvector_t);\n            atrec->value = p;\n            IGRAPH_CHECK(igraph_strvector_init(p, no_of_nodes));\n        } else {\n            IGRAPH_WARNING(\"A composite attribute ignored\");\n        }\n    }\n\n    for (i = 0; i < igraph_vector_ptr_size(&eattrs); i++) {\n        igraph_attribute_record_t *atrec = VECTOR(eattrs)[i];\n        int type = atrec->type;\n        if (type == IGRAPH_ATTRIBUTE_NUMERIC) {\n            igraph_vector_t *p = igraph_Calloc(1, igraph_vector_t);\n            atrec->value = p;\n            IGRAPH_CHECK(igraph_vector_init(p, no_of_edges));\n        } else if (type == IGRAPH_ATTRIBUTE_STRING) {\n            igraph_strvector_t *p = igraph_Calloc(1, igraph_strvector_t);\n            atrec->value = p;\n            IGRAPH_CHECK(igraph_strvector_init(p, no_of_edges));\n        } else {\n            IGRAPH_WARNING(\"A composite attribute ignored\");\n        }\n    }\n\n    /* Ok, now the edges, attributes too */\n    IGRAPH_CHECK(igraph_vector_resize(&edges, no_of_edges * 2));\n    p = -1;\n    while ( (p = igraph_gml_tree_find(gtree, \"edge\", p + 1)) != -1) {\n        igraph_gml_tree_t *edge;\n        long int from, to, fromidx = 0, toidx = 0;\n        char name[100];\n        long int j;\n        edge = igraph_gml_tree_get_tree(gtree, p);\n        for (j = 0; j < igraph_gml_tree_length(edge); j++) {\n            const char *n = igraph_gml_tree_name(edge, j);\n            if (!strcmp(n, \"source\")) {\n                fromidx = igraph_gml_tree_find(edge, \"source\", 0);\n            } else if (!strcmp(n, \"target\")) {\n                toidx = igraph_gml_tree_find(edge, \"target\", 0);\n            } else {\n                long int edgeid = edgeptr / 2;\n                long int trieidx;\n                igraph_attribute_record_t *atrec;\n                int type;\n                igraph_trie_get(&eattrnames, n, &trieidx);\n                atrec = VECTOR(eattrs)[trieidx];\n                type = atrec->type;\n                if (type == IGRAPH_ATTRIBUTE_NUMERIC) {\n                    igraph_vector_t *v = (igraph_vector_t *)atrec->value;\n                    IGRAPH_CHECK(igraph_i_gml_toreal(edge, j, VECTOR(*v) + edgeid));\n                } else if (type == IGRAPH_ATTRIBUTE_STRING) {\n                    igraph_strvector_t *v = (igraph_strvector_t *)atrec->value;\n                    const char *value = igraph_i_gml_tostring(edge, j);\n                    IGRAPH_CHECK(igraph_strvector_set(v, edgeid, value));\n                }\n            }\n        }\n        from = igraph_gml_tree_get_integer(edge, fromidx);\n        to = igraph_gml_tree_get_integer(edge, toidx);\n        snprintf(name, sizeof(name) / sizeof(char) -1, \"%li\", from);\n        IGRAPH_CHECK(igraph_trie_get(&trie, name, &from));\n        snprintf(name, sizeof(name) / sizeof(char) -1, \"%li\", to);\n        IGRAPH_CHECK(igraph_trie_get(&trie, name, &to));\n        if (igraph_trie_size(&trie) != no_of_nodes) {\n            IGRAPH_ERROR(\"Unknown node id found at an edge\", IGRAPH_PARSEERROR);\n        }\n        VECTOR(edges)[edgeptr++] = from;\n        VECTOR(edges)[edgeptr++] = to;\n    }\n\n    /* and add vertex attributes */\n    for (i = 0; i < igraph_gml_tree_length(gtree); i++) {\n        const char *n;\n        char name[100];\n        long int j, k;\n        n = igraph_gml_tree_name(gtree, i);\n        if (!strcmp(n, \"node\")) {\n            igraph_gml_tree_t *node = igraph_gml_tree_get_tree(gtree, i);\n            long int iidx = igraph_gml_tree_find(node, \"id\", 0);\n            long int id = igraph_gml_tree_get_integer(node, iidx);\n            snprintf(name, sizeof(name) / sizeof(char) -1, \"%li\", id);\n            igraph_trie_get(&trie, name, &id);\n            for (j = 0; j < igraph_gml_tree_length(node); j++) {\n                const char *aname = igraph_gml_tree_name(node, j);\n                igraph_attribute_record_t *atrec;\n                int type;\n                igraph_trie_get(&vattrnames, aname, &k);\n                atrec = VECTOR(vattrs)[k];\n                type = atrec->type;\n                if (type == IGRAPH_ATTRIBUTE_NUMERIC) {\n                    igraph_vector_t *v = (igraph_vector_t *)atrec->value;\n                    IGRAPH_CHECK(igraph_i_gml_toreal(node, j, VECTOR(*v) + id));\n                } else if (type == IGRAPH_ATTRIBUTE_STRING) {\n                    igraph_strvector_t *v = (igraph_strvector_t *)atrec->value;\n                    const char *value = igraph_i_gml_tostring(node, j);\n                    IGRAPH_CHECK(igraph_strvector_set(v, id, value));\n                }\n            }\n        }\n    }\n\n    igraph_trie_destroy(&trie);\n    igraph_trie_destroy(&gattrnames);\n    igraph_trie_destroy(&vattrnames);\n    igraph_trie_destroy(&eattrnames);\n    IGRAPH_FINALLY_CLEAN(4);\n\n    IGRAPH_CHECK(igraph_empty_attrs(graph, 0, directed, 0)); /* TODO */\n    IGRAPH_CHECK(igraph_add_vertices(graph, (igraph_integer_t) no_of_nodes,\n                                     &vattrs));\n    IGRAPH_CHECK(igraph_add_edges(graph, &edges, &eattrs));\n\n    igraph_i_gml_destroy_attrs(attrs);\n    igraph_vector_destroy(&edges);\n    igraph_i_gml_parsedata_destroy(&context);\n    IGRAPH_FINALLY_CLEAN(3);\n\n    return 0;\n}\nint main(int argc, char* argv[]) {\n    int index = 0;\n\n    /* We do not care about errors; all we care about is that the library\n     * should not segfault and should not accept invalid input either */\n    igraph_set_error_handler(igraph_error_handler_ignore);\n\n    RUN_TEST(\"invalid1.gml\");\n    RUN_TEST(\"invalid2.gml\");\n    RUN_TEST(\"invalid3.gml\");\n\n    return 0;\n}\n",
    "target": 0,
    "idx": 2029377
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "void bn_rsh(bn_t c, const bn_t a, int bits) {\n\tint digits = 0;\n\n\tif (bits <= 0) {\n\t\tbn_copy(c, a);\n\t\treturn;\n\t}\n\n\tRLC_RIP(bits, digits, bits);\n\n\tbn_grow(c, a->used - digits);\n\n\tif (digits > 0) {\n\t\tbn_rshd_low(c->dp, a->dp, a->used, digits);\n\t}\n\tc->used = a->used - digits;\n\tc->sign = a->sign;\n\n\tif (c->used > 0 && bits > 0) {\n\t\tif (digits == 0 && c != a) {\n\t\t\tbn_rshb_low(c->dp, a->dp + digits, a->used - digits, bits);\n\t\t} else {\n\t\t\tbn_rshb_low(c->dp, c->dp, c->used, bits);\n\t\t}\n\t}\n\tbn_trim(c);\n}\n",
    "target": 0,
    "idx": 2030340
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "static int MqttClient_DecodePacket(MqttClient* client, byte* rx_buf,\n    word32 rx_len, void *packet_obj, MqttPacketType* ppacket_type,\n    MqttQoS* ppacket_qos, word16* ppacket_id)\n{\n    int rc = MQTT_CODE_SUCCESS;\n    MqttPacket* header;\n    MqttPacketType packet_type;\n    MqttQoS packet_qos;\n    word16 packet_id = 0;\n\n    /* must have rx buffer with at least 2 byes for header */\n    if (rx_buf == NULL || rx_len < MQTT_PACKET_HEADER_MIN_SIZE) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    /* Decode header */\n    header = (MqttPacket*)rx_buf;\n    packet_type = (MqttPacketType)MQTT_PACKET_TYPE_GET(header->type_flags);\n    if (ppacket_type) {\n        *ppacket_type = packet_type;\n    }\n    packet_qos = (MqttQoS)MQTT_PACKET_FLAGS_GET_QOS(header->type_flags);\n    if (ppacket_qos) {\n        *ppacket_qos = packet_qos;\n    }\n\n    /* Decode packet specific data (if requested) */\n    if (ppacket_id || packet_obj) {\n        switch (packet_type) {\n        case MQTT_PACKET_TYPE_CONNECT_ACK:\n        {\n            MqttConnectAck connect_ack, *p_connect_ack = &connect_ack;\n            if (packet_obj) {\n                p_connect_ack = (MqttConnectAck*)packet_obj;\n            }\n            else {\n                XMEMSET(p_connect_ack, 0, sizeof(MqttConnectAck));\n            }\n        #ifdef WOLFMQTT_V5\n            p_connect_ack->protocol_level = client->protocol_level;\n        #endif\n            rc = MqttDecode_ConnectAck(rx_buf, rx_len, p_connect_ack);\n        #ifdef WOLFMQTT_V5\n            if (rc >= 0) {\n                rc = Handle_Props(p_connect_ack->props);\n            }\n        #endif\n            break;\n        }\n        case MQTT_PACKET_TYPE_PUBLISH:\n        {\n            MqttPublish publish, *p_publish = &publish;\n            if (packet_obj) {\n                p_publish = (MqttPublish*)packet_obj;\n            }\n            else {\n                XMEMSET(p_publish, 0, sizeof(MqttPublish));\n            }\n        #ifdef WOLFMQTT_V5\n            p_publish->protocol_level = client->protocol_level;\n        #endif\n            rc = MqttDecode_Publish(rx_buf, rx_len, p_publish);\n            if (rc >= 0) {\n                packet_id = p_publish->packet_id;\n            #ifdef WOLFMQTT_V5\n                rc = Handle_Props(p_publish->props);\n            #endif\n            }\n            break;\n        }\n        case MQTT_PACKET_TYPE_PUBLISH_ACK:\n        case MQTT_PACKET_TYPE_PUBLISH_REC:\n        case MQTT_PACKET_TYPE_PUBLISH_REL:\n        case MQTT_PACKET_TYPE_PUBLISH_COMP:\n        {\n            MqttPublishResp publish_resp, *p_publish_resp = &publish_resp;\n            if (packet_obj) {\n                p_publish_resp = (MqttPublishResp*)packet_obj;\n            }\n            else {\n                XMEMSET(p_publish_resp, 0, sizeof(MqttPublishResp));\n            }\n        #ifdef WOLFMQTT_V5\n                p_publish_resp->protocol_level = client->protocol_level;\n        #endif\n                rc = MqttDecode_PublishResp(rx_buf, rx_len, packet_type,\n                p_publish_resp);\n            if (rc >= 0) {\n                packet_id = p_publish_resp->packet_id;\n            #ifdef WOLFMQTT_V5\n                rc = Handle_Props(p_publish_resp->props);\n            #endif\n            }\n            break;\n        }\n        case MQTT_PACKET_TYPE_SUBSCRIBE_ACK:\n        {\n            MqttSubscribeAck subscribe_ack, *p_subscribe_ack = &subscribe_ack;\n            if (packet_obj) {\n                p_subscribe_ack = (MqttSubscribeAck*)packet_obj;\n            }\n            else {\n                XMEMSET(p_subscribe_ack, 0, sizeof(MqttSubscribeAck));\n            }\n        #ifdef WOLFMQTT_V5\n            p_subscribe_ack->protocol_level = client->protocol_level;\n        #endif\n            rc = MqttDecode_SubscribeAck(rx_buf, rx_len, p_subscribe_ack);\n            if (rc >= 0) {\n                packet_id = p_subscribe_ack->packet_id;\n            #ifdef WOLFMQTT_V5\n                rc = Handle_Props(p_subscribe_ack->props);\n            #endif\n            }\n            break;\n        }\n        case MQTT_PACKET_TYPE_UNSUBSCRIBE_ACK:\n        {\n            MqttUnsubscribeAck unsubscribe_ack,\n                               *p_unsubscribe_ack = &unsubscribe_ack;\n            if (packet_obj) {\n                p_unsubscribe_ack = (MqttUnsubscribeAck*)packet_obj;\n            }\n            else {\n                XMEMSET(p_unsubscribe_ack, 0, sizeof(MqttUnsubscribeAck));\n            }\n        #ifdef WOLFMQTT_V5\n            p_unsubscribe_ack->protocol_level = client->protocol_level;\n        #endif\n            rc = MqttDecode_UnsubscribeAck(rx_buf, rx_len, p_unsubscribe_ack);\n            if (rc >= 0) {\n                packet_id = p_unsubscribe_ack->packet_id;\n            #ifdef WOLFMQTT_V5\n                rc = Handle_Props(p_unsubscribe_ack->props);\n            #endif\n            }\n            break;\n        }\n        case MQTT_PACKET_TYPE_PING_RESP:\n        {\n            MqttPing ping, *p_ping = &ping;\n            if (packet_obj) {\n                p_ping = (MqttPing*)packet_obj;\n            }\n            else {\n                XMEMSET(p_ping, 0, sizeof(MqttPing));\n            }\n            rc = MqttDecode_Ping(rx_buf, rx_len, p_ping);\n            break;\n        }\n        case MQTT_PACKET_TYPE_AUTH:\n        {\n        #ifdef WOLFMQTT_V5\n            MqttAuth auth, *p_auth = &auth;\n            if (packet_obj) {\n                p_auth = (MqttAuth*)packet_obj;\n            }\n            else {\n                XMEMSET(p_auth, 0, sizeof(MqttAuth));\n            }\n            rc = MqttDecode_Auth(rx_buf, rx_len, p_auth);\n            if (rc >= 0) {\n                rc = Handle_Props(p_auth->props);\n            }\n        #else\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n        #endif /* WOLFMQTT_V5 */\n            break;\n        }\n        case MQTT_PACKET_TYPE_DISCONNECT:\n        {\n        #ifdef WOLFMQTT_V5\n            MqttDisconnect disc, *p_disc = &disc;\n            if (packet_obj) {\n                p_disc = (MqttDisconnect*)packet_obj;\n            }\n            else {\n                XMEMSET(p_disc, 0, sizeof(MqttDisconnect));\n            }\n            rc = MqttDecode_Disconnect(rx_buf, rx_len, p_disc);\n            if (rc >= 0) {\n                rc = Handle_Props(p_disc->props);\n            }\n        #else\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n        #endif /* WOLFMQTT_V5 */\n            break;\n        }\n        case MQTT_PACKET_TYPE_CONNECT:\n        case MQTT_PACKET_TYPE_SUBSCRIBE:\n        case MQTT_PACKET_TYPE_UNSUBSCRIBE:\n        case MQTT_PACKET_TYPE_PING_REQ:\n        case MQTT_PACKET_TYPE_ANY:\n        case MQTT_PACKET_TYPE_RESERVED:\n        default:\n            /* these type are only encoded by client */\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n            break;\n        } /* switch (packet_type) */\n    }\n\n    if (ppacket_id) {\n        *ppacket_id = packet_id;\n    }\n\n    (void)client;\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"MqttClient_DecodePacket: Rc %d, Len %d, Type %s (%d), ID %d,\"\n            \" QoS %d\",\n        rc, rx_len, MqttPacket_TypeDesc(packet_type), packet_type, packet_id,\n        packet_qos);\n#endif\n\n    return rc;\n}\nint MqttClient_WaitMessage(MqttClient *client, int timeout_ms)\n{\n    int rc = MQTT_CODE_ERROR_BAD_ARG;\n    if (client != NULL) {\n        rc = MqttClient_WaitMessage_ex(client, &client->msg, timeout_ms);\n        if (rc != MQTT_CODE_CONTINUE) {\n            /* Clear the union for the next call to MqttClient_WaitMessage */\n            XMEMSET(&client->msg, 0, sizeof(MqttObject));\n        }\n    }\n\n    return rc;\n}\nint MqttClient_NetConnect(MqttClient *client, const char* host,\n    word16 port, int timeout_ms, int use_tls, MqttTlsCb cb)\n{\n    return MqttSocket_Connect(client, host, port, timeout_ms, use_tls, cb);\n}\nint MqttClient_NetDisconnect(MqttClient *client)\n{\n    return MqttSocket_Disconnect(client);\n}\n",
    "target": 0,
    "idx": 2030592
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "void test() {\n\t/* ws->getUserData returns one of these */\n    struct PerSocketData {\n        /* Fill with user data */\n    };\n\n    {\n        /* Keep in mind that uWS::SSLApp({options}) is the same as uWS::App() when compiled without SSL support.\n        * You may swap to using uWS:App() if you don't need SSL */\n        auto app = uWS::App({\n            /* There are example certificates in uWebSockets.js repo */\n            .key_file_name = \"../misc/key.pem\",\n            .cert_file_name = \"../misc/cert.pem\",\n            .passphrase = \"1234\"\n        }).ws<PerSocketData>(\"/*\", {\n            /* Settings */\n            .compression = uWS::SHARED_COMPRESSOR,\n            .maxPayloadLength = 16 * 1024,\n            .idleTimeout = 10,\n            .maxBackpressure = 1 * 1024 * 1024,\n            /* Handlers */\n            .open = [](auto *ws) {\n                /* Open event here, you may access ws->getUserData() which points to a PerSocketData struct */\n                ws->getNativeHandle();\n                ws->getRemoteAddressAsText();\n                us_poll_ext((struct us_poll_t *) ws);\n            },\n            .message = [](auto *ws, std::string_view message, uWS::OpCode opCode) {\n                ws->send(message, opCode, true);\n            },\n            .drain = [](auto *ws) {\n                /* Check ws->getBufferedAmount() here */\n            },\n            .ping = [](auto *ws) {\n                /* We use this to trigger the async/wakeup feature */\n\t\tuWS::Loop::get()->defer([]() {\n\t\t    /* Do nothing */\n                });\n            },\n            .pong = [](auto *ws) {\n                /* Not implemented yet */\n            },\n            .close = [](auto *ws, int code, std::string_view message) {\n                /* You may access ws->getUserData() here */\n            }\n        }).listen(9001, [](auto *listenSocket) {\n            listen_socket = listenSocket;\n        });\n\n        /* Here we want to stress the connect feature, since nothing else stresses it */\n        struct us_loop_t *loop = (struct us_loop_t *) uWS::Loop::get();\n        /* This function is stupid */\n        us_loop_iteration_number(loop);\n        struct us_socket_context_t *client_context = us_create_socket_context(0, loop, 0, {});\n        client = us_socket_context_connect(0, client_context, \"hostname\", 5000, \"localhost\", 0, 0);\n\n        us_socket_context_on_connect_error(0, client_context, [](struct us_socket_t *s, int code) {\n\t    client = nullptr;\n            return s;\n        });\n\n        us_socket_context_on_open(0, client_context, [](struct us_socket_t *s, int is_client, char *ip, int ip_length) {\n            us_socket_flush(0, s);\n            return s;\n        });\n\n        us_socket_context_on_end(0, client_context, [](struct us_socket_t *s) {\n            return s;\n        });\n\n        us_socket_context_on_data(0, client_context, [](struct us_socket_t *s, char *data, int length) {\n            return s;\n        });\n\n        us_socket_context_on_writable(0, client_context, [](struct us_socket_t *s) {\n            return s;\n        });\n\n        us_socket_context_on_close(0, client_context, [](struct us_socket_t *s, int code, void *reason) {\n            client = NULL;\n            return s;\n        });\n\n        /* Trigger some context functions */\n        app.addServerName(\"\", {});\n        app.removeServerName(\"\");\n        app.missingServerName(nullptr);\n        app.getNativeHandle();\n\n        app.run();\n\n        /* After done we also free the client context */\n        us_socket_context_free(0, client_context);\n    }\n    uWS::Loop::get()->free();\n}\n",
    "target": 0,
    "idx": 2031047
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "void test() {\n\n    struct PerSocketData {\n        int nothing;\n        std::shared_ptr<bool> valid;\n    };\n\n    /* First byte determines what compressor to use */\n    unsigned char compressorByte;\n    if (consume_byte(&compressorByte)) {\n        //uWS::Loop::get()->free();\n        return;\n    }\n\n    uWS::CompressOptions compressors[] = {\n        uWS::DISABLED,\n        uWS::SHARED_COMPRESSOR,\n        uWS::DEDICATED_COMPRESSOR_3KB,\n        uWS::DEDICATED_COMPRESSOR_4KB,\n        uWS::DEDICATED_COMPRESSOR_8KB,\n        uWS::DEDICATED_COMPRESSOR_16KB,\n        uWS::DEDICATED_COMPRESSOR_32KB,\n        uWS::DEDICATED_COMPRESSOR_64KB,\n        uWS::DEDICATED_COMPRESSOR_128KB,\n        uWS::DEDICATED_COMPRESSOR_256KB\n    };\n\n    uWS::CompressOptions compressor = compressors[compressorByte % 10];\n\n    {\n        auto app = uWS::App().ws<PerSocketData>(\"/broadcast\", {\n            /* Settings */\n            .compression = compressor,\n            /* We want this to be low so that we can hit it, yet bigger than 256 */\n            .maxPayloadLength = 300,\n            .idleTimeout = 12,\n            /* Handlers */\n            .open = [](auto *ws) {\n                /* Subscribe to anything */\n                ws->subscribe(/*req->getHeader(*/\"topic\"/*)*/);\n            },\n            .message = [](auto *ws, std::string_view message, uWS::OpCode opCode) {\n                if (message.length() && message[0] == 'C') {\n                    ws->close();\n                } else if (message.length() && message[0] == 'E') {\n                    ws->end(1006);\n                } else {\n                    /* Publish to topic sent by message */\n                    ws->publish(message, message, opCode, true);\n\n                    if (message.length() && message[0] == 'U') {\n                        ws->unsubscribe(message);\n                    }\n                }\n            },\n            .drain = [](auto *ws) {\n                /* Check getBufferedAmount here */\n            },\n            .ping = [](auto *ws) {\n\n            },\n            .pong = [](auto *ws) {\n\n            },\n            .close = [](auto *ws, int code, std::string_view message) {\n\n            }\n        }).ws<PerSocketData>(\"/*\", {\n            /* Settings */\n            .compression = compressor,\n            /* We want this to be low so that we can hit it, yet bigger than 256 */\n            .maxPayloadLength = 300,\n            .idleTimeout = 12,\n            /* Handlers */\n            .open = [](auto *ws) {\n\n                ws->getUserData()->valid.reset(new bool{true});\n\n                //if (req->getHeader(\"close_me\").length()) {\n                //    ws->close();\n                //} else if (req->getHeader(\"end_me\").length()) {\n                //    ws->end(1006);\n                //}\n            },\n            .message = [](auto *ws, std::string_view message, uWS::OpCode opCode) {\n                if (message.length() > 300) {\n                    /* Inform the sanitizer of the fault */\n                    fprintf(stderr, \"Too long message passed\\n\");\n                    free((void *) -1);\n                }\n\n                if (message.length() && message[0] == 'C') {\n                    ws->close();\n                } else if (message.length() && message[0] == 'E') {\n                    ws->end(1006);\n                } else {\n                    ws->send(message, opCode, true);\n                }\n            },\n            .drain = [](auto *ws) {\n                /* Check getBufferedAmount here */\n            },\n            .ping = [](auto *ws) {\n                /* Here we test send and end while uncorked, by having them send from deferred */\n                PerSocketData *psd = (PerSocketData *) ws->getUserData();\n\n                uWS::Loop::get()->defer([ws, valid = psd->valid]() {\n                    if (*valid.get()) {\n                        /* We haven't been closed */\n                        ws->send(\"Hello!\", uWS::TEXT, false);\n                        ws->end(1000);\n                    }\n                });\n            },\n            .pong = [](auto *ws) {\n\n            },\n            .close = [](auto *ws, int code, std::string_view message) {\n                (*ws->getUserData()->valid.get()) = false;\n            }\n        }).listen(9001, [](us_listen_socket_t *listenSocket) {\n            listen_socket = listenSocket;\n        });\n\n        app.run();\n    }\n\n    uWS::Loop::get()->free();\n}\n",
    "target": 0,
    "idx": 2031209
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "std::unique_ptr<GrFragmentProcessor> SkPictureShader::asFragmentProcessor(\n        const GrFPArgs& args) const {\n\n    auto ctx = args.fContext;\n    auto lm = this->totalLocalMatrix(args.fPreLocalMatrix);\n    SkColorType dstColorType = GrColorTypeToSkColorType(args.fDstColorInfo->colorType());\n    if (dstColorType == kUnknown_SkColorType) {\n        dstColorType = kRGBA_8888_SkColorType;\n    }\n\n    auto dstCS = ref_or_srgb(args.fDstColorInfo->colorSpace());\n    auto info = CachedImageInfo::Make(fTile, args.fMatrixProvider.localToDevice(), &lm,\n                                      dstColorType, dstCS.get(),\n                                      ctx->priv().caps()->maxTextureSize());\n    SkMatrix inv;\n    if (!info.success || !(*lm).invert(&inv)) {\n        return nullptr;\n    }\n\n    // Gotta be sure the GPU can support our requested colortype (might be FP16)\n    if (!ctx->colorTypeSupportedAsSurface(info.imageInfo.colorType())) {\n        info.imageInfo = info.imageInfo.makeColorType(kRGBA_8888_SkColorType);\n    }\n\n    static const GrUniqueKey::Domain kDomain = GrUniqueKey::GenerateDomain();\n    GrUniqueKey key;\n    GrUniqueKey::Builder builder(&key, kDomain, 10, \"Picture Shader Image\");\n    builder[0] = dstCS->toXYZD50Hash();\n    builder[1] = dstCS->transferFnHash();\n    builder[2] = static_cast<uint32_t>(dstColorType);\n    builder[3] = fPicture->uniqueID();\n    memcpy(&builder[4], &fTile, sizeof(fTile));                     // 4,5,6,7\n    memcpy(&builder[8], &info.tileScale, sizeof(info.tileScale));   // 8,9\n    builder.finish();\n\n    GrProxyProvider* provider = ctx->priv().proxyProvider();\n    GrSurfaceProxyView view;\n    if (auto proxy = provider->findOrCreateProxyByUniqueKey(key)) {\n        view = GrSurfaceProxyView(proxy, kTopLeft_GrSurfaceOrigin, GrSwizzle());\n    } else {\n        const int msaaSampleCount = 0;\n        const SkSurfaceProps* props = nullptr;\n        const bool createWithMips = false;\n        auto image = info.makeImage(SkSurface::MakeRenderTarget(ctx,\n                                                                SkBudgeted::kYes,\n                                                                info.imageInfo,\n                                                                msaaSampleCount,\n                                                                kTopLeft_GrSurfaceOrigin,\n                                                                props,\n                                                                createWithMips),\n                                    fPicture.get());\n        if (!image) {\n            return nullptr;\n        }\n        auto [v, ct] = as_IB(image)->asView(ctx, GrMipmapped::kNo);\n        view = std::move(v);\n        provider->assignUniqueKeyToProxy(key, view.asTextureProxy());\n    }\n\n    const GrSamplerState sampler(static_cast<GrSamplerState::WrapMode>(fTmx),\n                                 static_cast<GrSamplerState::WrapMode>(fTmy),\n                                 sampling_to_filter(args.fSampling));\n    return GrTextureEffect::Make(std::move(view), kPremul_SkAlphaType, inv, sampler,\n                                 *ctx->priv().caps());\n}\n",
    "target": 0,
    "idx": 2031754
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "static void cil_reset_classperms_set(struct cil_classperms_set *cp_set)\n{\n\tif (cp_set == NULL) {\n\t\treturn;\n\t}\n\n\tcp_set->set = NULL;\n}\nstatic inline void cil_reset_classperms_list(struct cil_list *cp_list)\n{\n\tstruct cil_list_item *curr;\n\n\tif (cp_list == NULL) {\n\t\treturn;\n\t}\n\n\tcil_list_for_each(curr, cp_list) {\n\t\tif (curr->flavor == CIL_CLASSPERMS) { /* KERNEL or MAP */\n\t\t\tcil_reset_classperms(curr->data);\n\t\t} else if (curr->flavor == CIL_CLASSPERMS_SET) { /* SET */\n\t\t\tcil_reset_classperms_set(curr->data);\n\t\t}\n\t}\n}\n",
    "target": 0,
    "idx": 2032177
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "static int\ndxf_objects_read (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  char name[80];\n  Dxf_Pair *pair = dxf_read_pair (dat);\n  while (pair != NULL)\n    {\n      while (pair != NULL && pair->code == 0 && pair->value.s)\n        {\n          strncpy (name, pair->value.s, 79);\n          name[79] = '\\0';\n          object_alias (name);\n          if (is_dwg_object (name))\n            {\n              char *dxfname = strdup (pair->value.s);\n              dxf_free_pair (pair);\n              pair = new_object (name, dxfname, dat, dwg, 0, NULL);\n              if (!pair)\n                return DWG_ERR_INVALIDDWG;\n            }\n          else\n            {\n              DXF_RETURN_ENDSEC (0);\n              LOG_WARN (\"Unhandled 0 %s (%s)\", name, \"objects\");\n              dxf_free_pair (pair);\n              pair = dxf_read_pair (dat);\n              DXF_CHECK_EOF;\n            }\n        }\n      dxf_free_pair (pair);\n      pair = dxf_read_pair (dat);\n      DXF_CHECK_EOF;\n    }\n  dxf_free_pair (pair);\n  return 0;\n}\n",
    "target": 0,
    "idx": 2032275
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "bool Parser::parse_heredoc_entries()\n{\n    auto heredocs = move(m_heredoc_initiations);\n    m_heredoc_initiations.clear();\n    // Try to parse heredoc entries, as reverse recorded in the initiation records\n    for (auto& record : heredocs) {\n        auto rule_start = push_start();\n        if (m_rule_start_offsets.size() > max_allowed_nested_rule_depth) {\n            record.node->set_is_syntax_error(*create<AST::SyntaxError>(String::formatted(\"Expression nested too deep (max allowed is {})\", max_allowed_nested_rule_depth)));\n            continue;\n        }\n        bool found_key = false;\n        if (!record.interpolate) {\n            // Since no interpolation is allowed, just read lines until we hit the key\n            Optional<Offset> last_line_offset;\n            for (;;) {\n                if (at_end())\n                    break;\n                if (peek() == '\\n')\n                    consume();\n                last_line_offset = current_position();\n                auto line = consume_while(is_not('\\n'));\n                if (peek() == '\\n')\n                    consume();\n                if (line.trim_whitespace() == record.end) {\n                    found_key = true;\n                    break;\n                }\n            }\n\n            if (!last_line_offset.has_value())\n                last_line_offset = current_position();\n            // Now just wrap it in a StringLiteral and set it as the node's contents\n            auto node = create<AST::StringLiteral>(m_input.substring_view(rule_start->offset, last_line_offset->offset - rule_start->offset));\n            if (!found_key)\n                node->set_is_syntax_error(*create<AST::SyntaxError>(String::formatted(\"Expected to find the heredoc key '{}', but found Eof\", record.end), true));\n            record.node->set_contents(move(node));\n        } else {\n            // Interpolation is allowed, so we're going to read doublequoted string innards\n            // until we find a line that contains the key\n            auto end_condition = move(m_end_condition);\n            found_key = false;\n            set_end_condition([this, end = record.end, &found_key] {\n                if (found_key)\n                    return true;\n                auto offset = current_position();\n                auto cond = move(m_end_condition);\n                ScopeGuard guard {\n                    [&] {\n                        m_end_condition = move(cond);\n                    }\n                };\n                if (peek() == '\\n') {\n                    consume();\n                    auto line = consume_while(is_not('\\n'));\n                    if (peek() == '\\n')\n                        consume();\n                    if (line.trim_whitespace() == end) {\n                        restore_to(offset.offset, offset.line);\n                        found_key = true;\n                        return true;\n                    }\n                }\n                restore_to(offset.offset, offset.line);\n                return false;\n            });\n\n            auto expr = parse_doublequoted_string_inner();\n            set_end_condition(move(end_condition));\n\n            if (found_key) {\n                auto offset = current_position();\n                if (peek() == '\\n')\n                    consume();\n                auto line = consume_while(is_not('\\n'));\n                if (peek() == '\\n')\n                    consume();\n                if (line.trim_whitespace() != record.end)\n                    restore_to(offset.offset, offset.line);\n            }\n\n            if (!expr && found_key) {\n                expr = create<AST::StringLiteral>(\"\");\n            } else if (!expr) {\n                expr = create<AST::SyntaxError>(String::formatted(\"Expected to find a valid string inside a heredoc (with end key '{}')\", record.end), true);\n            } else if (!found_key) {\n                expr->set_is_syntax_error(*create<AST::SyntaxError>(String::formatted(\"Expected to find the heredoc key '{}'\", record.end), true));\n            }\n\n            record.node->set_contents(create<AST::DoubleQuotedString>(move(expr)));\n        }\n    }\n    return true;\n}\n",
    "target": 0,
    "idx": 2033852
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "static xmlNodePtr\nxmlXIncludeCopyRange(xmlXIncludeCtxtPtr ctxt, xmlDocPtr target,\n\t                xmlDocPtr source, xmlXPathObjectPtr range) {\n    /* pointers to generated nodes */\n    xmlNodePtr list = NULL, last = NULL, listParent = NULL;\n    xmlNodePtr tmp, tmp2;\n    /* pointers to traversal nodes */\n    xmlNodePtr start, cur, end;\n    int index1, index2;\n    int level = 0, lastLevel = 0, endLevel = 0, endFlag = 0;\n\n    if ((ctxt == NULL) || (target == NULL) || (source == NULL) ||\n\t(range == NULL))\n\treturn(NULL);\n    if (range->type != XPATH_RANGE)\n\treturn(NULL);\n    start = (xmlNodePtr) range->user;\n\n    if ((start == NULL) || (start->type == XML_NAMESPACE_DECL))\n\treturn(NULL);\n    end = range->user2;\n    if (end == NULL)\n\treturn(xmlDocCopyNode(start, target, 1));\n    if (end->type == XML_NAMESPACE_DECL)\n        return(NULL);\n\n    cur = start;\n    index1 = range->index;\n    index2 = range->index2;\n    /*\n     * level is depth of the current node under consideration\n     * list is the pointer to the root of the output tree\n     * listParent is a pointer to the parent of output tree (within\n       the included file) in case we need to add another level\n     * last is a pointer to the last node added to the output tree\n     * lastLevel is the depth of last (relative to the root)\n     */\n    while (cur != NULL) {\n\t/*\n\t * Check if our output tree needs a parent\n\t */\n\tif (level < 0) {\n\t    while (level < 0) {\n\t        /* copy must include namespaces and properties */\n\t        tmp2 = xmlDocCopyNode(listParent, target, 2);\n\t        xmlAddChild(tmp2, list);\n\t        list = tmp2;\n\t        listParent = listParent->parent;\n\t        level++;\n\t    }\n\t    last = list;\n\t    lastLevel = 0;\n\t}\n\t/*\n\t * Check whether we need to change our insertion point\n\t */\n\twhile (level < lastLevel) {\n\t    last = last->parent;\n\t    lastLevel --;\n\t}\n\tif (cur == end) {\t/* Are we at the end of the range? */\n\t    if (cur->type == XML_TEXT_NODE) {\n\t\tconst xmlChar *content = cur->content;\n\t\tint len;\n\n\t\tif (content == NULL) {\n\t\t    tmp = xmlNewTextLen(NULL, 0);\n\t\t} else {\n\t\t    len = index2;\n\t\t    if ((cur == start) && (index1 > 1)) {\n\t\t\tcontent += (index1 - 1);\n\t\t\tlen -= (index1 - 1);\n\t\t    } else {\n\t\t\tlen = index2;\n\t\t    }\n\t\t    tmp = xmlNewTextLen(content, len);\n\t\t}\n\t\t/* single sub text node selection */\n\t\tif (list == NULL)\n\t\t    return(tmp);\n\t\t/* prune and return full set */\n\t\tif (level == lastLevel)\n\t\t    xmlAddNextSibling(last, tmp);\n\t\telse\n\t\t    xmlAddChild(last, tmp);\n\t\treturn(list);\n\t    } else {\t/* ending node not a text node */\n\t        endLevel = level;\t/* remember the level of the end node */\n\t\tendFlag = 1;\n\t\t/* last node - need to take care of properties + namespaces */\n\t\ttmp = xmlDocCopyNode(cur, target, 2);\n\t\tif (list == NULL) {\n\t\t    list = tmp;\n\t\t    listParent = cur->parent;\n\t\t    last = tmp;\n\t\t} else {\n\t\t    if (level == lastLevel)\n\t\t\tlast = xmlAddNextSibling(last, tmp);\n\t\t    else {\n\t\t\tlast = xmlAddChild(last, tmp);\n\t\t\tlastLevel = level;\n\t\t    }\n\t\t}\n\n\t\tif (index2 > 1) {\n\t\t    end = xmlXIncludeGetNthChild(cur, index2 - 1);\n\t\t    index2 = 0;\n\t\t}\n\t\tif ((cur == start) && (index1 > 1)) {\n\t\t    cur = xmlXIncludeGetNthChild(cur, index1 - 1);\n\t\t    index1 = 0;\n\t\t}  else {\n\t\t    cur = cur->children;\n\t\t}\n\t\tlevel++;\t/* increment level to show change */\n\t\t/*\n\t\t * Now gather the remaining nodes from cur to end\n\t\t */\n\t\tcontinue;\t/* while */\n\t    }\n\t} else if (cur == start) {\t/* Not at the end, are we at start? */\n\t    if ((cur->type == XML_TEXT_NODE) ||\n\t\t(cur->type == XML_CDATA_SECTION_NODE)) {\n\t\tconst xmlChar *content = cur->content;\n\n\t\tif (content == NULL) {\n\t\t    tmp = xmlNewTextLen(NULL, 0);\n\t\t} else {\n\t\t    if (index1 > 1) {\n\t\t\tcontent += (index1 - 1);\n\t\t\tindex1 = 0;\n\t\t    }\n\t\t    tmp = xmlNewText(content);\n\t\t}\n\t\tlast = list = tmp;\n\t\tlistParent = cur->parent;\n\t    } else {\t\t/* Not text node */\n\t        /*\n\t\t * start of the range - need to take care of\n\t\t * properties and namespaces\n\t\t */\n\t\ttmp = xmlDocCopyNode(cur, target, 2);\n\t\tlist = last = tmp;\n\t\tlistParent = cur->parent;\n\t\tif (index1 > 1) {\t/* Do we need to position? */\n\t\t    cur = xmlXIncludeGetNthChild(cur, index1 - 1);\n\t\t    level = lastLevel = 1;\n\t\t    index1 = 0;\n\t\t    /*\n\t\t     * Now gather the remaining nodes from cur to end\n\t\t     */\n\t\t    continue; /* while */\n\t\t}\n\t    }\n\t} else {\n\t    tmp = NULL;\n\t    switch (cur->type) {\n\t\tcase XML_DTD_NODE:\n\t\tcase XML_ELEMENT_DECL:\n\t\tcase XML_ATTRIBUTE_DECL:\n\t\tcase XML_ENTITY_NODE:\n\t\t    /* Do not copy DTD information */\n\t\t    break;\n\t\tcase XML_ENTITY_DECL:\n\t\t    /* handle crossing entities -> stack needed */\n\t\t    break;\n\t\tcase XML_XINCLUDE_START:\n\t\tcase XML_XINCLUDE_END:\n\t\t    /* don't consider it part of the tree content */\n\t\t    break;\n\t\tcase XML_ATTRIBUTE_NODE:\n\t\t    /* Humm, should not happen ! */\n\t\t    break;\n\t\tdefault:\n\t\t    /*\n\t\t     * Middle of the range - need to take care of\n\t\t     * properties and namespaces\n\t\t     */\n\t\t    tmp = xmlDocCopyNode(cur, target, 2);\n\t\t    break;\n\t    }\n\t    if (tmp != NULL) {\n\t\tif (level == lastLevel)\n\t\t    last = xmlAddNextSibling(last, tmp);\n\t\telse {\n\t\t    last = xmlAddChild(last, tmp);\n\t\t    lastLevel = level;\n\t\t}\n\t    }\n\t}\n\t/*\n\t * Skip to next node in document order\n\t */\n\tcur = xmlXPtrAdvanceNode(cur, &level);\n\tif (endFlag && (level >= endLevel))\n\t    break;\n    }\n    return(list);\n}\nstatic xmlNodePtr\nxmlXIncludeCopyXPointer(xmlXIncludeCtxtPtr ctxt, xmlDocPtr target,\n\t                xmlDocPtr source, xmlXPathObjectPtr obj) {\n    xmlNodePtr list = NULL, last = NULL;\n    int i;\n\n    if (source == NULL)\n\tsource = ctxt->doc;\n    if ((ctxt == NULL) || (target == NULL) || (source == NULL) ||\n\t(obj == NULL))\n\treturn(NULL);\n    switch (obj->type) {\n        case XPATH_NODESET: {\n\t    xmlNodeSetPtr set = obj->nodesetval;\n\t    if (set == NULL)\n\t\treturn(NULL);\n\t    for (i = 0;i < set->nodeNr;i++) {\n\t\tif (set->nodeTab[i] == NULL)\n\t\t    continue;\n\t\tswitch (set->nodeTab[i]->type) {\n\t\t    case XML_TEXT_NODE:\n\t\t    case XML_CDATA_SECTION_NODE:\n\t\t    case XML_ELEMENT_NODE:\n\t\t    case XML_ENTITY_REF_NODE:\n\t\t    case XML_ENTITY_NODE:\n\t\t    case XML_PI_NODE:\n\t\t    case XML_COMMENT_NODE:\n\t\t    case XML_DOCUMENT_NODE:\n\t\t    case XML_HTML_DOCUMENT_NODE:\n#ifdef LIBXML_DOCB_ENABLED\n\t\t    case XML_DOCB_DOCUMENT_NODE:\n#endif\n\t\t    case XML_XINCLUDE_END:\n\t\t\tbreak;\n\t\t    case XML_XINCLUDE_START: {\n\t                xmlNodePtr tmp, cur = set->nodeTab[i];\n\n\t\t\tcur = cur->next;\n\t\t\twhile (cur != NULL) {\n\t\t\t    switch(cur->type) {\n\t\t\t\tcase XML_TEXT_NODE:\n\t\t\t\tcase XML_CDATA_SECTION_NODE:\n\t\t\t\tcase XML_ELEMENT_NODE:\n\t\t\t\tcase XML_ENTITY_REF_NODE:\n\t\t\t\tcase XML_ENTITY_NODE:\n\t\t\t\tcase XML_PI_NODE:\n\t\t\t\tcase XML_COMMENT_NODE:\n\t\t\t\t    tmp = xmlXIncludeCopyNode(ctxt, target,\n\t\t\t\t\t\t\t      source, cur);\n\t\t\t\t    if (last == NULL) {\n\t\t\t\t\tlist = last = tmp;\n\t\t\t\t    } else {\n\t\t\t\t\tlast = xmlAddNextSibling(last, tmp);\n\t\t\t\t    }\n\t\t\t\t    cur = cur->next;\n\t\t\t\t    continue;\n\t\t\t\tdefault:\n\t\t\t\t    break;\n\t\t\t    }\n\t\t\t    break;\n\t\t\t}\n\t\t\tcontinue;\n\t\t    }\n\t\t    case XML_ATTRIBUTE_NODE:\n\t\t    case XML_NAMESPACE_DECL:\n\t\t    case XML_DOCUMENT_TYPE_NODE:\n\t\t    case XML_DOCUMENT_FRAG_NODE:\n\t\t    case XML_NOTATION_NODE:\n\t\t    case XML_DTD_NODE:\n\t\t    case XML_ELEMENT_DECL:\n\t\t    case XML_ATTRIBUTE_DECL:\n\t\t    case XML_ENTITY_DECL:\n\t\t\tcontinue; /* for */\n\t\t}\n\t\tif (last == NULL)\n\t\t    list = last = xmlXIncludeCopyNode(ctxt, target, source,\n\t\t\t                              set->nodeTab[i]);\n\t\telse {\n\t\t    xmlAddNextSibling(last,\n\t\t\t    xmlXIncludeCopyNode(ctxt, target, source,\n\t\t\t\t                set->nodeTab[i]));\n\t\t    if (last->next != NULL)\n\t\t\tlast = last->next;\n\t\t}\n\t    }\n\t    break;\n\t}\n#ifdef LIBXML_XPTR_ENABLED\n\tcase XPATH_LOCATIONSET: {\n\t    xmlLocationSetPtr set = (xmlLocationSetPtr) obj->user;\n\t    if (set == NULL)\n\t\treturn(NULL);\n\t    for (i = 0;i < set->locNr;i++) {\n\t\tif (last == NULL)\n\t\t    list = last = xmlXIncludeCopyXPointer(ctxt, target, source,\n\t\t\t                                  set->locTab[i]);\n\t\telse\n\t\t    xmlAddNextSibling(last,\n\t\t\t    xmlXIncludeCopyXPointer(ctxt, target, source,\n\t\t\t\t                    set->locTab[i]));\n\t\tif (last != NULL) {\n\t\t    while (last->next != NULL)\n\t\t\tlast = last->next;\n\t\t}\n\t    }\n\t    break;\n\t}\n\tcase XPATH_RANGE:\n\t    return(xmlXIncludeCopyRange(ctxt, target, source, obj));\n#endif\n\tcase XPATH_POINT:\n\t    /* points are ignored in XInclude */\n\t    break;\n\tdefault:\n\t    break;\n    }\n    return(list);\n}\nstatic xmlNodePtr\nxmlXPtrBuildRangeNodeList(xmlXPathObjectPtr range) {\n    /* pointers to generated nodes */\n    xmlNodePtr list = NULL, last = NULL, parent = NULL, tmp;\n    /* pointers to traversal nodes */\n    xmlNodePtr start, cur, end;\n    int index1, index2;\n\n    if (range == NULL)\n\treturn(NULL);\n    if (range->type != XPATH_RANGE)\n\treturn(NULL);\n    start = (xmlNodePtr) range->user;\n\n    if ((start == NULL) || (start->type == XML_NAMESPACE_DECL))\n\treturn(NULL);\n    end = range->user2;\n    if (end == NULL)\n\treturn(xmlCopyNode(start, 1));\n    if (end->type == XML_NAMESPACE_DECL)\n        return(NULL);\n\n    cur = start;\n    index1 = range->index;\n    index2 = range->index2;\n    while (cur != NULL) {\n\tif (cur == end) {\n\t    if (cur->type == XML_TEXT_NODE) {\n\t\tconst xmlChar *content = cur->content;\n\t\tint len;\n\n\t\tif (content == NULL) {\n\t\t    tmp = xmlNewTextLen(NULL, 0);\n\t\t} else {\n\t\t    len = index2;\n\t\t    if ((cur == start) && (index1 > 1)) {\n\t\t\tcontent += (index1 - 1);\n\t\t\tlen -= (index1 - 1);\n\t\t\tindex1 = 0;\n\t\t    } else {\n\t\t\tlen = index2;\n\t\t    }\n\t\t    tmp = xmlNewTextLen(content, len);\n\t\t}\n\t\t/* single sub text node selection */\n\t\tif (list == NULL)\n\t\t    return(tmp);\n\t\t/* prune and return full set */\n\t\tif (last != NULL)\n\t\t    xmlAddNextSibling(last, tmp);\n\t\telse\n\t\t    xmlAddChild(parent, tmp);\n\t\treturn(list);\n\t    } else {\n\t\ttmp = xmlCopyNode(cur, 0);\n\t\tif (list == NULL) {\n\t\t    list = tmp;\n\t\t    parent = tmp;\n\t\t} else {\n\t\t    if (last != NULL)\n\t\t\tparent = xmlAddNextSibling(last, tmp);\n\t\t    else\n\t\t\tparent = xmlAddChild(parent, tmp);\n\t\t}\n\t\tlast = NULL;\n\n\t\tif (index2 > 1) {\n\t\t    end = xmlXPtrGetNthChild(cur, index2 - 1);\n\t\t    index2 = 0;\n\t\t}\n\t\tif ((cur == start) && (index1 > 1)) {\n\t\t    cur = xmlXPtrGetNthChild(cur, index1 - 1);\n\t\t    index1 = 0;\n\t\t} else {\n\t\t    cur = cur->children;\n\t\t}\n\t\t/*\n\t\t * Now gather the remaining nodes from cur to end\n\t\t */\n\t\tcontinue; /* while */\n\t    }\n\t} else if ((cur == start) &&\n\t\t   (list == NULL) /* looks superfluous but ... */ ) {\n\t    if ((cur->type == XML_TEXT_NODE) ||\n\t\t(cur->type == XML_CDATA_SECTION_NODE)) {\n\t\tconst xmlChar *content = cur->content;\n\n\t\tif (content == NULL) {\n\t\t    tmp = xmlNewTextLen(NULL, 0);\n\t\t} else {\n\t\t    if (index1 > 1) {\n\t\t\tcontent += (index1 - 1);\n\t\t    }\n\t\t    tmp = xmlNewText(content);\n\t\t}\n\t\tlast = list = tmp;\n\t    } else {\n\t\tif ((cur == start) && (index1 > 1)) {\n\t\t    tmp = xmlCopyNode(cur, 0);\n\t\t    list = tmp;\n\t\t    parent = tmp;\n\t\t    last = NULL;\n\t\t    cur = xmlXPtrGetNthChild(cur, index1 - 1);\n\t\t    index1 = 0;\n\t\t    /*\n\t\t     * Now gather the remaining nodes from cur to end\n\t\t     */\n\t\t    continue; /* while */\n\t\t}\n\t\ttmp = xmlCopyNode(cur, 1);\n\t\tlist = tmp;\n\t\tparent = NULL;\n\t\tlast = tmp;\n\t    }\n\t} else {\n\t    tmp = NULL;\n\t    switch (cur->type) {\n\t\tcase XML_DTD_NODE:\n\t\tcase XML_ELEMENT_DECL:\n\t\tcase XML_ATTRIBUTE_DECL:\n\t\tcase XML_ENTITY_NODE:\n\t\t    /* Do not copy DTD information */\n\t\t    break;\n\t\tcase XML_ENTITY_DECL:\n\t\t    TODO /* handle crossing entities -> stack needed */\n\t\t    break;\n\t\tcase XML_XINCLUDE_START:\n\t\tcase XML_XINCLUDE_END:\n\t\t    /* don't consider it part of the tree content */\n\t\t    break;\n\t\tcase XML_ATTRIBUTE_NODE:\n\t\t    /* Humm, should not happen ! */\n\t\t    STRANGE\n\t\t    break;\n\t\tdefault:\n\t\t    tmp = xmlCopyNode(cur, 1);\n\t\t    break;\n\t    }\n\t    if (tmp != NULL) {\n\t\tif ((list == NULL) || ((last == NULL) && (parent == NULL)))  {\n\t\t    STRANGE\n\t\t    return(NULL);\n\t\t}\n\t\tif (last != NULL)\n\t\t    xmlAddNextSibling(last, tmp);\n\t\telse {\n\t\t    last = xmlAddChild(parent, tmp);\n\t\t}\n\t    }\n\t}\n\t/*\n\t * Skip to next node in document order\n\t */\n\tif ((list == NULL) || ((last == NULL) && (parent == NULL)))  {\n\t    STRANGE\n\t    return(NULL);\n\t}\n\tcur = xmlXPtrAdvanceNode(cur, NULL);\n    }\n    return(list);\n}\n",
    "target": 0,
    "idx": 2034461
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "Optional<URL> URLParser::parse_data_url(StringView const& raw_input)\n{\n    dbgln_if(URL_PARSER_DEBUG, \"URLParser::parse_data_url: Parsing '{}'.\", raw_input);\n    VERIFY(raw_input.starts_with(\"data:\"));\n    auto input = raw_input.substring_view(5);\n    auto comma_offset = input.find(',');\n    if (!comma_offset.has_value())\n        return {};\n    auto mime_type = StringUtils::trim(input.substring_view(0, comma_offset.value()), \"\\t\\n\\f\\r \", TrimMode::Both);\n    auto encoded_body = input.substring_view(comma_offset.value() + 1);\n    auto body = URL::percent_decode(encoded_body);\n    bool is_base64_encoded = false;\n    if (mime_type.ends_with(\"base64\", CaseSensitivity::CaseInsensitive)) {\n        auto substring_view = mime_type.substring_view(0, mime_type.length() - 6);\n        auto trimmed_substring_view = StringUtils::trim(substring_view, \" \", TrimMode::Right);\n        if (trimmed_substring_view.ends_with(';')) {\n            is_base64_encoded = true;\n            mime_type = trimmed_substring_view.substring_view(0, trimmed_substring_view.length() - 1);\n        }\n    }\n\n    StringBuilder builder;\n    if (mime_type.starts_with(\";\") || mime_type.is_empty()) {\n        builder.append(\"text/plain\");\n        builder.append(mime_type);\n        mime_type = builder.string_view();\n    }\n\n    // FIXME: Parse the MIME type's components according to https://mimesniff.spec.whatwg.org/#parse-a-mime-type\n    URL url { StringUtils::trim(mime_type, \"\\n\\r\\t \", TrimMode::Both), move(body), is_base64_encoded };\n    dbgln_if(URL_PARSER_DEBUG, \"URLParser::parse_data_url: Parsed data URL to be '{}'.\", url.serialize());\n    return url;\n}\n",
    "target": 0,
    "idx": 2034973
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "static void\nfz_draw_clip_image_mask(fz_context *ctx, fz_device *devp, fz_image *image, fz_matrix in_ctm, fz_rect scissor)\n{\n\tfz_draw_device *dev = (fz_draw_device*)devp;\n\tfz_matrix local_ctm = fz_concat(in_ctm, dev->transform);\n\tfz_irect bbox;\n\tfz_pixmap *scaled = NULL;\n\tfz_pixmap *pixmap = NULL;\n\tint dx, dy;\n\tfz_draw_state *state = push_stack(ctx, dev, \"clip image mask\");\n\tfz_colorspace *model = state->dest->colorspace;\n\tfz_irect clip;\n\tfz_irect src_area;\n\n\tfz_var(pixmap);\n\n\tif (dev->top == 0 && dev->resolve_spots)\n\t\tstate = push_group_for_separations(ctx, dev, fz_default_color_params /* FIXME */, dev->default_cs);\n\n\tclip = fz_pixmap_bbox(ctx, state->dest);\n\tclip = fz_intersect_irect(clip, state->scissor);\n\n\tif (image->w == 0 || image->h == 0)\n\t{\n#ifdef DUMP_GROUP_BLENDS\n\t\tdump_spaces(dev->top-1, \"Clip (image mask) (empty) begin\\n\");\n#endif\n\t\tstate[1].scissor = fz_empty_irect;\n\t\tstate[1].mask = NULL;\n\t\treturn;\n\t}\n\n\tlocal_ctm = fz_gridfit_matrix(devp->flags & FZ_DEVFLAG_GRIDFIT_AS_TILED, local_ctm);\n\n\tsrc_area = find_src_area_required(local_ctm, image, clip);\n\tif (fz_is_empty_irect(src_area))\n\t{\n#ifdef DUMP_GROUP_BLENDS\n\t\tdump_spaces(dev->top-1, \"Clip (image mask) (empty source area) begin\\n\");\n#endif\n\t\tstate[1].scissor = fz_empty_irect;\n\t\tstate[1].mask = NULL;\n\t\treturn;\n\t}\n\n\tbbox = fz_irect_from_rect(fz_transform_rect(fz_unit_rect, local_ctm));\n\tbbox = fz_intersect_irect(bbox, state->scissor);\n\tif (!fz_is_infinite_rect(scissor))\n\t{\n\t\tfz_rect tscissor = fz_transform_rect(scissor, dev->transform);\n\t\tbbox = fz_intersect_irect(bbox, fz_irect_from_rect(tscissor));\n\t}\n\tif (!fz_is_valid_irect(bbox))\n\t{\n#ifdef DUMP_GROUP_BLENDS\n\t\tdump_spaces(dev->top-1, \"Clip (image mask) (invalid) begin\\n\");\n#endif\n\t\tstate[1].scissor = fz_empty_irect;\n\t\tstate[1].mask = NULL;\n\t\treturn;\n\t}\n\n#ifdef DUMP_GROUP_BLENDS\n\tdump_spaces(dev->top-1, \"Clip (image mask) begin\\n\");\n#endif\n\n\tfz_try(ctx)\n\t{\n\t\tpixmap = fz_get_pixmap_from_image(ctx, image, &src_area, &local_ctm, &dx, &dy);\n\n\t\tstate[1].mask = fz_new_pixmap_with_bbox(ctx, NULL, bbox, NULL, 1);\n\t\tfz_clear_pixmap(ctx, state[1].mask);\n\n\t\tstate[1].dest = fz_new_pixmap_with_bbox(ctx, model, bbox, state[0].dest->seps, state[0].dest->alpha);\n\t\tfz_copy_pixmap_rect(ctx, state[1].dest, state[0].dest, bbox, dev->default_cs);\n\t\tif (state[0].shape)\n\t\t{\n\t\t\tstate[1].shape = fz_new_pixmap_with_bbox(ctx, NULL, bbox, NULL, 1);\n\t\t\tfz_clear_pixmap(ctx, state[1].shape);\n\t\t}\n\t\tif (state[0].group_alpha)\n\t\t{\n\t\t\tstate[1].group_alpha = fz_new_pixmap_with_bbox(ctx, NULL, bbox, NULL, 1);\n\t\t\tfz_clear_pixmap(ctx, state[1].group_alpha);\n\t\t}\n\n\t\tstate[1].blendmode |= FZ_BLEND_ISOLATED;\n\t\tstate[1].scissor = bbox;\n\n\t\tif (!(devp->hints & FZ_DONT_INTERPOLATE_IMAGES) && ctx->tuning->image_scale(ctx->tuning->image_scale_arg, dx, dy, pixmap->w, pixmap->h))\n\t\t{\n\t\t\tint gridfit = !(dev->flags & FZ_DRAWDEV_FLAGS_TYPE3);\n\t\t\tscaled = fz_transform_pixmap(ctx, dev, pixmap, &local_ctm, state->dest->x, state->dest->y, dx, dy, gridfit, &clip);\n\t\t\tif (!scaled)\n\t\t\t{\n\t\t\t\tif (dx < 1)\n\t\t\t\t\tdx = 1;\n\t\t\t\tif (dy < 1)\n\t\t\t\t\tdy = 1;\n\t\t\t\tscaled = fz_scale_pixmap_cached(ctx, pixmap, pixmap->x, pixmap->y, dx, dy, NULL, dev->cache_x, dev->cache_y);\n\t\t\t}\n\t\t\tif (scaled)\n\t\t\t{\n\t\t\t\tfz_drop_pixmap(ctx, pixmap);\n\t\t\t\tpixmap = scaled;\n\t\t\t}\n\t\t}\n\n#ifdef DUMP_GROUP_BLENDS\n\t\tdump_spaces(dev->top, \"\");\n\t\tfz_dump_blend(ctx, \"Creating imagemask: plotting \", pixmap);\n\t\tfz_dump_blend(ctx, \" onto \", state[1].mask);\n\t\tif (state[1].shape)\n\t\t\tfz_dump_blend(ctx, \"/S=\", state[1].shape);\n\t\tif (state[1].group_alpha)\n\t\t\tfz_dump_blend(ctx, \"/GA=\", state[1].group_alpha);\n#endif\n\n\t\tfz_paint_image(ctx, state[1].mask, &bbox, state[1].shape, state[1].group_alpha, pixmap, local_ctm, 255, !(devp->hints & FZ_DONT_INTERPOLATE_IMAGES), 0);\n\n#ifdef DUMP_GROUP_BLENDS\n\t\tfz_dump_blend(ctx, \" to get \", state[1].mask);\n\t\tif (state[1].shape)\n\t\t\tfz_dump_blend(ctx, \"/S=\", state[1].shape);\n\t\tif (state[1].group_alpha)\n\t\t\tfz_dump_blend(ctx, \"/GA=\", state[1].group_alpha);\n\t\tprintf(\"\\n\");\n#endif\n\t}\n\tfz_always(ctx)\n\t\tfz_drop_pixmap(ctx, pixmap);\n\tfz_catch(ctx)\n\t\tfz_rethrow(ctx);\n}\n",
    "target": 0,
    "idx": 2036519
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "USBREDIR_VISIBLE\nint usbredirparser_serialize(struct usbredirparser *parser_pub,\n                             uint8_t **state_dest, int *state_len)\n{\n    struct usbredirparser_priv *parser =\n        (struct usbredirparser_priv *)parser_pub;\n    struct usbredirparser_buf *wbuf;\n    uint8_t *state = NULL, *pos = NULL;\n    uint32_t write_buf_count = 0, len, remain = 0;\n    ptrdiff_t write_buf_count_pos;\n\n    *state_dest = NULL;\n    *state_len = 0;\n\n    if (serialize_int(parser, &state, &pos, &remain,\n                                   USBREDIRPARSER_SERIALIZE_MAGIC, \"magic\"))\n        return -1;\n\n    /* To be replaced with length later */\n    if (serialize_int(parser, &state, &pos, &remain, 0, \"length\"))\n        return -1;\n\n    if (serialize_data(parser, &state, &pos, &remain,\n                       (uint8_t *)parser->our_caps,\n                       USB_REDIR_CAPS_SIZE * sizeof(int32_t), \"our_caps\"))\n        return -1;\n\n    if (parser->have_peer_caps) {\n        if (serialize_data(parser, &state, &pos, &remain,\n                           (uint8_t *)parser->peer_caps,\n                           USB_REDIR_CAPS_SIZE * sizeof(int32_t), \"peer_caps\"))\n            return -1;\n    } else {\n        if (serialize_int(parser, &state, &pos, &remain, 0, \"peer_caps_len\"))\n            return -1;\n    }\n\n    if (serialize_int(parser, &state, &pos, &remain, parser->to_skip, \"skip\"))\n        return -1;\n\n    if (serialize_data(parser, &state, &pos, &remain,\n                       (uint8_t *)&parser->header, parser->header_read,\n                       \"header\"))\n        return -1;\n\n    if (serialize_data(parser, &state, &pos, &remain,\n                       parser->type_header, parser->type_header_read,\n                       \"type_header\"))\n        return -1;\n\n    if (serialize_data(parser, &state, &pos, &remain,\n                       parser->data, parser->data_read, \"packet-data\"))\n        return -1;\n\n    write_buf_count_pos = pos - state;\n    /* To be replaced with write_buf_count later */\n    if (serialize_int(parser, &state, &pos, &remain, 0, \"write_buf_count\"))\n        return -1;\n\n    wbuf = parser->write_buf;\n    while (wbuf) {\n        if (serialize_data(parser, &state, &pos, &remain,\n                           wbuf->buf + wbuf->pos, wbuf->len - wbuf->pos,\n                           \"write-buf\"))\n            return -1;\n        write_buf_count++;\n        wbuf = wbuf->next;\n    }\n    /* Patch in write_buf_count */\n    memcpy(state + write_buf_count_pos, &write_buf_count, sizeof(int32_t));\n\n    /* Patch in length */\n    len = pos - state;\n    memcpy(state + sizeof(int32_t), &len, sizeof(int32_t));\n\n    *state_dest = state;\n    *state_len = len;\n\n    return 0;\n}\n",
    "target": 0,
    "idx": 2036861
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "  std::pair<Value*, bool> Insert(Key key, Value value) {\n    const size_t key_hash = Hasher{}(key);\n    const uint8_t tag = HashToTag(key_hash);\n    static constexpr size_t kSlotNotFound = std::numeric_limits<size_t>::max();\n\n    // This for loop does in reality at most two attempts:\n    // The first iteration either:\n    //  - Early-returns, because the key exists already,\n    //  - Finds an insertion slot and proceeds because the load is < limit.\n    // The second iteration is only hit in the unlikely case of this insertion\n    // bringing the table beyond the target |load_limit_| (or the edge case\n    // of the HT being full, if |load_limit_pct_| = 100).\n    // We cannot simply pre-grow the table before insertion, because we must\n    // guarantee that calling Insert() with a key that already exists doesn't\n    // invalidate iterators.\n    size_t insertion_slot;\n    size_t probe_len;\n    for (;;) {\n      PERFETTO_DCHECK((capacity_ & (capacity_ - 1)) == 0);  // Must be a pow2.\n      insertion_slot = kSlotNotFound;\n      // Start the iteration at the desired slot (key_hash % capacity_)\n      // searching either for a free slot or a tombstone. In the worst case we\n      // might end up scanning the whole array of slots. The Probe functions are\n      // guaranteed to visit all the slots within |capacity_| steps. If we find\n      // a free slot, we can stop the search immediately (a free slot acts as an\n      // \"end of chain for entries having the same hash\". If we find a\n      // tombstones (a deleted slot) we remember its position, but have to keep\n      // searching until a free slot to make sure we don't insert a duplicate\n      // key.\n      for (probe_len = 0; probe_len < capacity_;) {\n        const size_t idx = Probe::Calc(key_hash, probe_len, capacity_);\n        PERFETTO_DCHECK(idx < capacity_);\n        const uint8_t tag_idx = tags_[idx];\n        ++probe_len;\n        if (tag_idx == kFreeSlot) {\n          // Rationale for \"insertion_slot == kSlotNotFound\": if we encountered\n          // a tombstone while iterating we should reuse that rather than\n          // taking another slot.\n          if (AppendOnly || insertion_slot == kSlotNotFound)\n            insertion_slot = idx;\n          break;\n        }\n        // We should never encounter tombstones in AppendOnly mode.\n        PERFETTO_DCHECK(!(tag_idx == kTombstone && AppendOnly));\n        if (!AppendOnly && tag_idx == kTombstone) {\n          insertion_slot = idx;\n          continue;\n        }\n        if (tag_idx == tag && keys_[idx] == key) {\n          // The key is already in the map.\n          return std::make_pair(&values_[idx], false);\n        }\n      }  // for (idx)\n\n      // If we got to this point the key does not exist (otherwise we would have\n      // hit the the return above) and we are going to insert a new entry.\n      // Before doing so, ensure we stay under the target load limit.\n      if (PERFETTO_UNLIKELY(size_ >= load_limit_)) {\n        MaybeGrowAndRehash(/*grow=*/true);\n        continue;\n      }\n      PERFETTO_DCHECK(insertion_slot != kSlotNotFound);\n      break;\n    }  // for (attempt)\n\n    PERFETTO_CHECK(insertion_slot < capacity_);\n\n    // We found a free slot (or a tombstone). Proceed with the insertion.\n    Value* value_idx = &values_[insertion_slot];\n    new (&keys_[insertion_slot]) Key(std::move(key));\n    new (value_idx) Value(std::move(value));\n    tags_[insertion_slot] = tag;\n    PERFETTO_DCHECK(probe_len > 0 && probe_len <= capacity_);\n    max_probe_length_ = std::max(max_probe_length_, probe_len);\n    size_++;\n\n    return std::make_pair(value_idx, true);\n  }\n  bool Erase(const Key& key) {\n    if (AppendOnly)\n      PERFETTO_FATAL(\"Erase() not supported because AppendOnly=true\");\n    size_t idx = FindInternal(key);\n    if (idx == kNotFound)\n      return false;\n    EraseInternal(idx);\n    return true;\n  }\n  void Clear() {\n    // Avoid trivial heap operations on zero-capacity std::move()-d objects.\n    if (PERFETTO_UNLIKELY(capacity_ == 0))\n      return;\n\n    for (size_t i = 0; i < capacity_; ++i) {\n      const uint8_t tag = tags_[i];\n      if (tag != kFreeSlot && tag != kTombstone)\n        EraseInternal(i);\n    }\n    // Clear all tombstones. We really need to do this for AppendOnly.\n    MaybeGrowAndRehash(/*grow=*/false);\n  }\n\n  size_t FindInternal(const Key& key) const {\n    const size_t key_hash = Hasher{}(key);\n    const uint8_t tag = HashToTag(key_hash);\n    PERFETTO_DCHECK((capacity_ & (capacity_ - 1)) == 0);  // Must be a pow2.\n    PERFETTO_DCHECK(max_probe_length_ <= capacity_);\n    for (size_t i = 0; i < max_probe_length_; ++i) {\n      const size_t idx = Probe::Calc(key_hash, i, capacity_);\n      const uint8_t tag_idx = tags_[idx];\n\n      if (tag_idx == kFreeSlot)\n        return kNotFound;\n      // HashToTag() never returns kTombstone, so the tag-check below cannot\n      // possibly match. Also we just want to skip tombstones.\n      if (tag_idx == tag && keys_[idx] == key) {\n        PERFETTO_DCHECK(tag_idx > kTombstone);\n        return idx;\n      }\n    }  // for (idx)\n    return kNotFound;\n  }\n  PERFETTO_NO_INLINE void MaybeGrowAndRehash(bool grow) {\n    PERFETTO_DCHECK(size_ <= capacity_);\n    const size_t old_capacity = capacity_;\n\n    // Grow quickly up to 1MB, then chill.\n    const size_t old_size_bytes = old_capacity * (sizeof(Key) + sizeof(Value));\n    const size_t grow_factor = old_size_bytes < (1024u * 1024u) ? 8 : 2;\n    const size_t new_capacity =\n        grow ? std::max(old_capacity * grow_factor, size_t(1024))\n             : old_capacity;\n\n    auto old_tags(std::move(tags_));\n    auto old_keys(std::move(keys_));\n    auto old_values(std::move(values_));\n    size_t old_size = size_;\n\n    // This must be a CHECK (i.e. not just a DCHECK) to prevent UAF attacks on\n    // 32-bit archs that try to double the size of the table until wrapping.\n    PERFETTO_CHECK(new_capacity >= old_capacity);\n    Reset(new_capacity);\n\n    size_t new_size = 0;  // Recompute the size.\n    for (size_t i = 0; i < old_capacity; ++i) {\n      const uint8_t old_tag = old_tags[i];\n      if (old_tag != kFreeSlot && old_tag != kTombstone) {\n        Insert(std::move(old_keys[i]), std::move(old_values[i]));\n        old_keys[i].~Key();  // Destroy the old objects.\n        old_values[i].~Value();\n        new_size++;\n      }\n    }\n    PERFETTO_DCHECK(new_size == old_size);\n    size_ = new_size;\n  }\n  PERFETTO_NO_INLINE void Reset(size_t n) {\n    PERFETTO_DCHECK((n & (n - 1)) == 0);  // Must be a pow2.\n\n    capacity_ = n;\n    max_probe_length_ = 0;\n    size_ = 0;\n    load_limit_ = n * static_cast<size_t>(load_limit_percent_) / 100;\n    load_limit_ = std::min(load_limit_, n);\n\n    tags_.reset(new uint8_t[n]);\n    memset(&tags_[0], 0, n);                  // Clear all tags.\n    keys_ = AlignedAllocTyped<Key[]>(n);      // Deliberately not 0-initialized.\n    values_ = AlignedAllocTyped<Value[]>(n);  // Deliberately not 0-initialized.\n  }\n  static inline uint8_t HashToTag(size_t full_hash) {\n    uint8_t tag = full_hash >> (sizeof(full_hash) * 8 - 8);\n    // Ensure the hash is always >= 2. We use 0, 1 for kFreeSlot and kTombstone.\n    tag += (tag <= kTombstone) << 1;\n    PERFETTO_DCHECK(tag > kTombstone);\n    return tag;\n  }\nTYPED_TEST(FlatHashMapTest, VsUnorderedMap) {\n  std::unordered_map<int, int, CollidingHasher> umap;\n  FlatHashMap<int, int, CollidingHasher, typename TestFixture::Probe> fmap;\n  std::minstd_rand0 rng(0);\n\n  for (int rep = 0; rep < 2; rep++) {\n    std::set<int> keys_copy;\n    const int kRange = 1024;\n\n    // Insert some random elements.\n    for (int i = 0; i < kRange; i++) {\n      int key = static_cast<int>(rng());\n      keys_copy.insert(key);\n      int value = key * 2;\n      auto it_and_inserted_u = umap.insert({key, value});\n      auto it_and_inserted_f = fmap.Insert(key, value);\n      ASSERT_EQ(it_and_inserted_u.second, it_and_inserted_f.second);\n      ASSERT_EQ(*it_and_inserted_f.first, value);\n      ASSERT_EQ(umap.size(), fmap.size());\n      int* res = fmap.Find(key);\n      ASSERT_NE(res, nullptr);\n      ASSERT_EQ(*res, value);\n      ASSERT_EQ(fmap[key], value);  // Test that operator[] behaves like Find().\n    }\n    // Look them up.\n    for (int key : keys_copy) {\n      int* res = fmap.Find(key);\n      ASSERT_NE(res, nullptr);\n      ASSERT_EQ(*res, key * 2);\n      ASSERT_EQ(umap.size(), fmap.size());\n    }\n\n    // Some further deletions / insertions / reinsertions.\n    for (int key : keys_copy) {\n      auto op = rng() % 4;\n\n      if (op < 2) {\n        // With a 50% chance, erase the key.\n        bool erased_u = umap.erase(key) > 0;\n        bool erased_f = fmap.Erase(key);\n        ASSERT_EQ(erased_u, erased_f);\n      } else if (op == 3) {\n        // With a 25% chance, re-insert the same key (should fail).\n        umap.insert({key, 0});\n        ASSERT_FALSE(fmap.Insert(key, 0).second);\n      } else {\n        // With a 25% chance, insert a new key.\n        umap.insert({key + kRange, (key + kRange) * 2});\n        ASSERT_TRUE(fmap.Insert(key + kRange, (key + kRange) * 2).second);\n      }\n\n      ASSERT_EQ(umap.size(), fmap.size());\n    }\n\n    // Re-look up keys. Note some of them might be deleted by the loop above.\n    for (int k : keys_copy) {\n      for (int i = 0; i < 2; i++) {\n        const int key = k + kRange * i;\n        int* res = fmap.Find(key);\n        if (umap.count(key)) {\n          ASSERT_NE(res, nullptr);\n          ASSERT_EQ(*res, key * 2);\n        } else {\n          ASSERT_EQ(res, nullptr);\n        }\n      }\n    }\n\n    fmap.Clear();\n    umap.clear();\n    ASSERT_EQ(fmap.size(), 0u);\n\n    for (int key : keys_copy)\n      ASSERT_EQ(fmap.Find(key), nullptr);\n  }\n}\n",
    "target": 0,
    "idx": 2041226
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "static zend_always_inline void _zend_hash_del_el(HashTable *ht, uint32_t idx, Bucket *p)\n{\n\tBucket *prev = NULL;\n\tuint32_t nIndex;\n\tuint32_t i;\n\n\tnIndex = p->h | ht->nTableMask;\n\ti = HT_HASH(ht, nIndex);\n\n\tif (i != idx) {\n\t\tprev = HT_HASH_TO_BUCKET(ht, i);\n\t\twhile (Z_NEXT(prev->val) != idx) {\n\t\t\ti = Z_NEXT(prev->val);\n\t\t\tprev = HT_HASH_TO_BUCKET(ht, i);\n\t\t}\n\t}\n\n\tif (p->key) {\n\t\tzend_string_release(p->key);\n\t\tp->key = NULL;\n\t}\n\t_zend_hash_del_el_ex(ht, idx, p, prev);\n}\nZEND_API zend_result ZEND_FASTCALL zend_hash_del(HashTable *ht, zend_string *key)\n{\n\tzend_ulong h;\n\tuint32_t nIndex;\n\tuint32_t idx;\n\tBucket *p;\n\tBucket *prev = NULL;\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT_RC1(ht);\n\n\th = zend_string_hash_val(key);\n\tnIndex = h | ht->nTableMask;\n\n\tidx = HT_HASH(ht, nIndex);\n\twhile (idx != HT_INVALID_IDX) {\n\t\tp = HT_HASH_TO_BUCKET(ht, idx);\n\t\tif ((p->key == key) ||\n\t\t\t(p->h == h &&\n\t\t     p->key &&\n\t\t     zend_string_equal_content(p->key, key))) {\n\t\t\tzend_string_release(p->key);\n\t\t\tp->key = NULL;\n\t\t\t_zend_hash_del_el_ex(ht, idx, p, prev);\n\t\t\treturn SUCCESS;\n\t\t}\n\t\tprev = p;\n\t\tidx = Z_NEXT(p->val);\n\t}\n\treturn FAILURE;\n}\nZEND_API zend_result ZEND_FASTCALL zend_hash_del_ind(HashTable *ht, zend_string *key)\n{\n\tzend_ulong h;\n\tuint32_t nIndex;\n\tuint32_t idx;\n\tBucket *p;\n\tBucket *prev = NULL;\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT_RC1(ht);\n\n\th = zend_string_hash_val(key);\n\tnIndex = h | ht->nTableMask;\n\n\tidx = HT_HASH(ht, nIndex);\n\twhile (idx != HT_INVALID_IDX) {\n\t\tp = HT_HASH_TO_BUCKET(ht, idx);\n\t\tif ((p->key == key) ||\n\t\t\t(p->h == h &&\n\t\t     p->key &&\n\t\t     zend_string_equal_content(p->key, key))) {\n\t\t\tif (Z_TYPE(p->val) == IS_INDIRECT) {\n\t\t\t\tzval *data = Z_INDIRECT(p->val);\n\n\t\t\t\tif (UNEXPECTED(Z_TYPE_P(data) == IS_UNDEF)) {\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t} else {\n\t\t\t\t\tif (ht->pDestructor) {\n\t\t\t\t\t\tzval tmp;\n\t\t\t\t\t\tZVAL_COPY_VALUE(&tmp, data);\n\t\t\t\t\t\tZVAL_UNDEF(data);\n\t\t\t\t\t\tht->pDestructor(&tmp);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tZVAL_UNDEF(data);\n\t\t\t\t\t}\n\t\t\t\t\tHT_FLAGS(ht) |= HASH_FLAG_HAS_EMPTY_IND;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tzend_string_release(p->key);\n\t\t\t\tp->key = NULL;\n\t\t\t\t_zend_hash_del_el_ex(ht, idx, p, prev);\n\t\t\t}\n\t\t\treturn SUCCESS;\n\t\t}\n\t\tprev = p;\n\t\tidx = Z_NEXT(p->val);\n\t}\n\treturn FAILURE;\n}\nZEND_API zend_result ZEND_FASTCALL zend_hash_str_del_ind(HashTable *ht, const char *str, size_t len)\n{\n\tzend_ulong h;\n\tuint32_t nIndex;\n\tuint32_t idx;\n\tBucket *p;\n\tBucket *prev = NULL;\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT_RC1(ht);\n\n\th = zend_inline_hash_func(str, len);\n\tnIndex = h | ht->nTableMask;\n\n\tidx = HT_HASH(ht, nIndex);\n\twhile (idx != HT_INVALID_IDX) {\n\t\tp = HT_HASH_TO_BUCKET(ht, idx);\n\t\tif ((p->h == h)\n\t\t\t && p->key\n\t\t\t && (ZSTR_LEN(p->key) == len)\n\t\t\t && !memcmp(ZSTR_VAL(p->key), str, len)) {\n\t\t\tif (Z_TYPE(p->val) == IS_INDIRECT) {\n\t\t\t\tzval *data = Z_INDIRECT(p->val);\n\n\t\t\t\tif (UNEXPECTED(Z_TYPE_P(data) == IS_UNDEF)) {\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t} else {\n\t\t\t\t\tif (ht->pDestructor) {\n\t\t\t\t\t\tht->pDestructor(data);\n\t\t\t\t\t}\n\t\t\t\t\tZVAL_UNDEF(data);\n\t\t\t\t\tHT_FLAGS(ht) |= HASH_FLAG_HAS_EMPTY_IND;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tzend_string_release(p->key);\n\t\t\t\tp->key = NULL;\n\t\t\t\t_zend_hash_del_el_ex(ht, idx, p, prev);\n\t\t\t}\n\t\t\treturn SUCCESS;\n\t\t}\n\t\tprev = p;\n\t\tidx = Z_NEXT(p->val);\n\t}\n\treturn FAILURE;\n}\nZEND_API zend_result ZEND_FASTCALL zend_hash_str_del(HashTable *ht, const char *str, size_t len)\n{\n\tzend_ulong h;\n\tuint32_t nIndex;\n\tuint32_t idx;\n\tBucket *p;\n\tBucket *prev = NULL;\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT_RC1(ht);\n\n\th = zend_inline_hash_func(str, len);\n\tnIndex = h | ht->nTableMask;\n\n\tidx = HT_HASH(ht, nIndex);\n\twhile (idx != HT_INVALID_IDX) {\n\t\tp = HT_HASH_TO_BUCKET(ht, idx);\n\t\tif ((p->h == h)\n\t\t\t && p->key\n\t\t\t && (ZSTR_LEN(p->key) == len)\n\t\t\t && !memcmp(ZSTR_VAL(p->key), str, len)) {\n\t\t\tzend_string_release(p->key);\n\t\t\tp->key = NULL;\n\t\t\t_zend_hash_del_el_ex(ht, idx, p, prev);\n\t\t\treturn SUCCESS;\n\t\t}\n\t\tprev = p;\n\t\tidx = Z_NEXT(p->val);\n\t}\n\treturn FAILURE;\n}\n",
    "target": 0,
    "idx": 2042894
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "\n        image->properties,key);\n      if (value != (const char *) NULL)\n        return(value);\n    }\n  return((const char *) NULL);\n}\n\nstatic MagickBooleanType SkipXMPValue(const char *value)\n{\n  if (value == (const char*) NULL)\n    return(MagickTrue);\n  while (*value != '\\0')\n    if (isspace((int) ((unsigned char) *value)) == 0)\n      return(MagickFalse);\n    value++;\n  }\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType GetXMPProperty(const Image *image,const char *property)\n{\n  char\n    *xmp_profile;\n\n  const char\n    *content;\n\n  const StringInfo\n    *profile;\n\n  ExceptionInfo\n    *exception;\n\n  MagickBooleanType\n    status;\n\n  const char\n    *p;\n\n  XMLTreeInfo\n    *child,\n    *description,\n    *node,\n    *rdf,\n    *xmp;\n\n  profile=GetImageProfile(image,\"xmp\");\n  if (profile == (StringInfo *) NULL)\n    return(MagickFalse);\n  if (GetStringInfoLength(profile) < 17)\n    return(MagickFalse);\n  if ((property == (const char *) NULL) || (*property == '\\0'))\n    return(MagickFalse);\n  xmp_profile=StringInfoToString(profile);\n  if (xmp_profile == (char *) NULL)\n    return(MagickFalse);\n  for (p=xmp_profile; *p != '\\0'; p++)\n    if ((*p == '<') && (*(p+1) == 'x'))\n      break;\n  exception=AcquireExceptionInfo();\n  xmp=NewXMLTree((char *) p,exception);\n  xmp_profile=DestroyString(xmp_profile);\n  exception=DestroyExceptionInfo(exception);\n  if (xmp == (XMLTreeInfo *) NULL)\n    return(MagickFalse);\n  status=MagickFalse;\n  rdf=GetXMLTreeChild(xmp,\"rdf:RDF\");\n  if (rdf != (XMLTreeInfo *) NULL)\n    {\n      if (image->properties == (void *) NULL)\n        ((Image *) image)->properties=NewSplayTree(CompareSplayTreeString,\n          RelinquishMagickMemory,RelinquishMagickMemory);\n      description=GetXMLTreeChild(rdf,\"rdf:Description\");\n      while (description != (XMLTreeInfo *) NULL)\n      {\n        char\n          *xmp_namespace;\n\n        node=GetXMLTreeChild(description,(const char *) NULL);\n        while (node != (XMLTreeInfo *) NULL)\n        {\n          child=GetXMLTreeChild(node,(const char *) NULL);\n          content=GetXMLTreeContent(node);\n          if ((child == (XMLTreeInfo *) NULL) &&\n              (SkipXMPValue(content) == MagickFalse))\n            {\n              xmp_namespace=ConstantString(GetXMLTreeTag(node));\n              (void) SubstituteString(&xmp_namespace,\"exif:\",\"xmp:\");\n              (void) AddValueToSplayTree((SplayTreeInfo *) image->properties,\n                xmp_namespace,ConstantString(content));\n            }\n          while (child != (XMLTreeInfo *) NULL)\n          {\n            content=GetXMLTreeContent(child);\n            if (SkipXMPValue(content) == MagickFalse)\n              {\n                xmp_namespace=ConstantString(GetXMLTreeTag(node));\n                (void) SubstituteString(&xmp_namespace,\"exif:\",\"xmp:\");\n                (void) AddValueToSplayTree((SplayTreeInfo *) image->properties,\n                  xmp_namespace,ConstantString(content));\n              }\n            child=GetXMLTreeSibling(child);\n          }\n          node=GetXMLTreeSibling(node);\n",
    "target": 0,
    "idx": 2046219
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "static xmlNodePtr\nxmlStaticCopyNode(xmlNodePtr node, xmlDocPtr doc, xmlNodePtr parent,\n                  int extended) {\n    xmlNodePtr ret;\n\n    if (node == NULL) return(NULL);\n    switch (node->type) {\n        case XML_TEXT_NODE:\n        case XML_CDATA_SECTION_NODE:\n        case XML_ELEMENT_NODE:\n        case XML_DOCUMENT_FRAG_NODE:\n        case XML_ENTITY_REF_NODE:\n        case XML_ENTITY_NODE:\n        case XML_PI_NODE:\n        case XML_COMMENT_NODE:\n        case XML_XINCLUDE_START:\n        case XML_XINCLUDE_END:\n\t    break;\n        case XML_ATTRIBUTE_NODE:\n\t\treturn((xmlNodePtr) xmlCopyPropInternal(doc, parent, (xmlAttrPtr) node));\n        case XML_NAMESPACE_DECL:\n\t    return((xmlNodePtr) xmlCopyNamespaceList((xmlNsPtr) node));\n\n        case XML_DOCUMENT_NODE:\n        case XML_HTML_DOCUMENT_NODE:\n#ifdef LIBXML_TREE_ENABLED\n\t    return((xmlNodePtr) xmlCopyDoc((xmlDocPtr) node, extended));\n#endif /* LIBXML_TREE_ENABLED */\n        case XML_DOCUMENT_TYPE_NODE:\n        case XML_NOTATION_NODE:\n        case XML_DTD_NODE:\n        case XML_ELEMENT_DECL:\n        case XML_ATTRIBUTE_DECL:\n        case XML_ENTITY_DECL:\n            return(NULL);\n    }\n\n    /*\n     * Allocate a new node and fill the fields.\n     */\n    ret = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));\n    if (ret == NULL) {\n\txmlTreeErrMemory(\"copying node\");\n\treturn(NULL);\n    }\n    memset(ret, 0, sizeof(xmlNode));\n    ret->type = node->type;\n\n    ret->doc = doc;\n    ret->parent = parent;\n    if (node->name == xmlStringText)\n\tret->name = xmlStringText;\n    else if (node->name == xmlStringTextNoenc)\n\tret->name = xmlStringTextNoenc;\n    else if (node->name == xmlStringComment)\n\tret->name = xmlStringComment;\n    else if (node->name != NULL) {\n        if ((doc != NULL) && (doc->dict != NULL))\n\t    ret->name = xmlDictLookup(doc->dict, node->name, -1);\n\telse\n\t    ret->name = xmlStrdup(node->name);\n    }\n    if ((node->type != XML_ELEMENT_NODE) &&\n\t(node->content != NULL) &&\n\t(node->type != XML_ENTITY_REF_NODE) &&\n\t(node->type != XML_XINCLUDE_END) &&\n\t(node->type != XML_XINCLUDE_START)) {\n\tret->content = xmlStrdup(node->content);\n    }else{\n      if (node->type == XML_ELEMENT_NODE)\n        ret->line = node->line;\n    }\n    if (parent != NULL) {\n\txmlNodePtr tmp;\n\n\t/*\n\t * this is a tricky part for the node register thing:\n\t * in case ret does get coalesced in xmlAddChild\n\t * the deregister-node callback is called; so we register ret now already\n\t */\n\tif ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))\n\t    xmlRegisterNodeDefaultValue((xmlNodePtr)ret);\n\n        /*\n         * Note that since ret->parent is already set, xmlAddChild will\n         * return early and not actually insert the node. It will only\n         * coalesce text nodes and unnecessarily call xmlSetTreeDoc.\n         * Assuming that the subtree to be copied always has its text\n         * nodes coalesced, the somewhat confusing call to xmlAddChild\n         * could be removed.\n         */\n        tmp = xmlAddChild(parent, ret);\n\t/* node could have coalesced */\n\tif (tmp != ret)\n\t    return(tmp);\n    }\n\n    if (!extended)\n\tgoto out;\n    if (((node->type == XML_ELEMENT_NODE) ||\n         (node->type == XML_XINCLUDE_START)) && (node->nsDef != NULL))\n        ret->nsDef = xmlCopyNamespaceList(node->nsDef);\n\n    if (node->ns != NULL) {\n        xmlNsPtr ns;\n\n\tns = xmlSearchNs(doc, ret, node->ns->prefix);\n\tif (ns == NULL) {\n\t    /*\n\t     * Humm, we are copying an element whose namespace is defined\n\t     * out of the new tree scope. Search it in the original tree\n\t     * and add it at the top of the new tree\n\t     */\n\t    ns = xmlSearchNs(node->doc, node, node->ns->prefix);\n\t    if (ns != NULL) {\n\t        xmlNodePtr root = ret;\n\n\t\twhile (root->parent != NULL) root = root->parent;\n\t\tret->ns = xmlNewNs(root, ns->href, ns->prefix);\n\t\t} else {\n\t\t\tret->ns = xmlNewReconciledNs(doc, ret, node->ns);\n\t    }\n\t} else {\n\t    /*\n\t     * reference the existing namespace definition in our own tree.\n\t     */\n\t    ret->ns = ns;\n\t}\n    }\n    if (((node->type == XML_ELEMENT_NODE) ||\n         (node->type == XML_XINCLUDE_START)) && (node->properties != NULL))\n        ret->properties = xmlCopyPropList(ret, node->properties);\n    if (node->type == XML_ENTITY_REF_NODE) {\n\tif ((doc == NULL) || (node->doc != doc)) {\n\t    /*\n\t     * The copied node will go into a separate document, so\n\t     * to avoid dangling references to the ENTITY_DECL node\n\t     * we cannot keep the reference. Try to find it in the\n\t     * target document.\n\t     */\n\t    ret->children = (xmlNodePtr) xmlGetDocEntity(doc, ret->name);\n\t} else {\n            ret->children = node->children;\n\t}\n\tret->last = ret->children;\n    } else if ((node->children != NULL) && (extended != 2)) {\n        xmlNodePtr cur, insert;\n\n        cur = node->children;\n        insert = ret;\n        while (cur != NULL) {\n            xmlNodePtr copy = xmlStaticCopyNode(cur, doc, insert, 2);\n            if (copy == NULL) {\n                xmlFreeNode(ret);\n                return(NULL);\n            }\n\n            /* Check for coalesced text nodes */\n            if (insert->last != copy) {\n                if (insert->last == NULL) {\n                    insert->children = copy;\n                } else {\n                    copy->prev = insert->last;\n                    insert->last->next = copy;\n                }\n                insert->last = copy;\n            }\n\n            if (cur->children != NULL) {\n                cur = cur->children;\n                insert = copy;\n                continue;\n            }\n\n            while (1) {\n                if (cur->next != NULL) {\n                    cur = cur->next;\n                    break;\n                }\n\n                cur = cur->parent;\n                insert = insert->parent;\n                if (cur == node) {\n                    cur = NULL;\n                    break;\n                }\n            }\n        }\n    }\n\nout:\n    /* if parent != NULL we already registered the node above */\n    if ((parent == NULL) &&\n        ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue)))\n\txmlRegisterNodeDefaultValue((xmlNodePtr)ret);\n    return(ret);\n}\nstatic int\nxmlXIncludeIncludeNode(xmlXIncludeCtxtPtr ctxt, int nr) {\n    xmlNodePtr cur, end, list, tmp;\n\n    if (ctxt == NULL)\n\treturn(-1);\n    if ((nr < 0) || (nr >= ctxt->incNr))\n\treturn(-1);\n    cur = ctxt->incTab[nr]->ref;\n    if ((cur == NULL) || (cur->type == XML_NAMESPACE_DECL))\n\treturn(-1);\n\n    list = ctxt->incTab[nr]->inc;\n    ctxt->incTab[nr]->inc = NULL;\n    ctxt->incTab[nr]->emptyFb = 0;\n\n    /*\n     * Check against the risk of generating a multi-rooted document\n     */\n    if ((cur->parent != NULL) &&\n\t(cur->parent->type != XML_ELEMENT_NODE)) {\n\tint nb_elem = 0;\n\n\ttmp = list;\n\twhile (tmp != NULL) {\n\t    if (tmp->type == XML_ELEMENT_NODE)\n\t\tnb_elem++;\n\t    tmp = tmp->next;\n\t}\n\tif (nb_elem > 1) {\n\t    xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t                   XML_XINCLUDE_MULTIPLE_ROOT,\n\t\t       \"XInclude error: would result in multiple root nodes\\n\",\n\t\t\t   NULL);\n            xmlFreeNodeList(list);\n\t    return(-1);\n\t}\n    }\n\n    if (ctxt->parseFlags & XML_PARSE_NOXINCNODE) {\n\t/*\n\t * Add the list of nodes\n\t */\n\twhile (list != NULL) {\n\t    end = list;\n\t    list = list->next;\n\n\t    xmlAddPrevSibling(cur, end);\n\t}\n        /*\n         * FIXME: xmlUnlinkNode doesn't coalesce text nodes.\n         */\n\txmlUnlinkNode(cur);\n\txmlFreeNode(cur);\n    } else {\n        xmlNodePtr child, next;\n\n\t/*\n\t * Change the current node as an XInclude start one, and add an\n\t * XInclude end one\n\t */\n        if (ctxt->incTab[nr]->fallback)\n            xmlUnsetProp(cur, BAD_CAST \"href\");\n\tcur->type = XML_XINCLUDE_START;\n        /* Remove fallback children */\n        for (child = cur->children; child != NULL; child = next) {\n            next = child->next;\n            xmlUnlinkNode(child);\n            xmlFreeNode(child);\n        }\n\tend = xmlNewDocNode(cur->doc, cur->ns, cur->name, NULL);\n\tif (end == NULL) {\n\t    xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,\n\t                   XML_XINCLUDE_BUILD_FAILED,\n\t\t\t   \"failed to build node\\n\", NULL);\n            xmlFreeNodeList(list);\n\t    return(-1);\n\t}\n\tend->type = XML_XINCLUDE_END;\n\txmlAddNextSibling(cur, end);\n\n\t/*\n\t * Add the list of nodes\n\t */\n\twhile (list != NULL) {\n\t    cur = list;\n\t    list = list->next;\n\n\t    xmlAddPrevSibling(end, cur);\n\t}\n    }\n\n\n    return(0);\n}\n",
    "target": 0,
    "idx": 2046323
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "int gx_device_subclass(gx_device *dev_to_subclass, gx_device *new_prototype, unsigned int private_data_size)\n{\n    gx_device *child_dev;\n    void *psubclass_data;\n    gs_memory_struct_type_t *a_std, *b_std = NULL;\n    int dynamic = dev_to_subclass->stype_is_dynamic;\n    char *ptr, *ptr1;\n\n    /* If this happens we are stuffed, as there is no way to get hold\n     * of the original device's stype structure, which means we cannot\n     * allocate a replacement structure. Abort if so.\n     * Also abort if the new_prototype device struct is too large.\n     */\n    if (!dev_to_subclass->stype ||\n        dev_to_subclass->stype->ssize < new_prototype->params_size)\n        return_error(gs_error_VMerror);\n\n    /* We make a 'stype' structure for our new device, and copy the old stype into it\n     * This means our new device will always have the 'stype_is_dynamic' flag set\n     */\n    a_std = (gs_memory_struct_type_t *)\n        gs_alloc_bytes_immovable(dev_to_subclass->memory->non_gc_memory, sizeof(*a_std),\n                                 \"gs_device_subclass(stype)\");\n    if (!a_std)\n        return_error(gs_error_VMerror);\n    *a_std = *dev_to_subclass->stype;\n    a_std->ssize = dev_to_subclass->params_size;\n\n    if (!dynamic) {\n        b_std = (gs_memory_struct_type_t *)\n            gs_alloc_bytes_immovable(dev_to_subclass->memory->non_gc_memory, sizeof(*b_std),\n                                     \"gs_device_subclass(stype)\");\n        if (!b_std)\n            return_error(gs_error_VMerror);\n    }\n\n    /* Allocate a device structure for the new child device */\n    child_dev = gs_alloc_struct_immovable(dev_to_subclass->memory->stable_memory, gx_device, a_std,\n                                        \"gs_device_subclass(device)\");\n    if (child_dev == 0) {\n        gs_free_const_object(dev_to_subclass->memory->non_gc_memory, a_std, \"gs_device_subclass(stype)\");\n        gs_free_const_object(dev_to_subclass->memory->non_gc_memory, b_std, \"gs_device_subclass(stype)\");\n        return_error(gs_error_VMerror);\n    }\n\n    /* Make sure all methods are filled in, note this won't work for a forwarding device\n     * so forwarding devices will have to be filled in before being subclassed. This doesn't fill\n     * in the fill_rectangle proc, that gets done in the ultimate device's open proc.\n     */\n    gx_device_fill_in_procs(dev_to_subclass);\n    memcpy(child_dev, dev_to_subclass, dev_to_subclass->stype->ssize);\n    child_dev->stype = a_std;\n    child_dev->stype_is_dynamic = 1;\n\n    /* At this point, the only counted reference to the child is from its parent, and we need it to use the right allocator */\n    rc_init(child_dev, dev_to_subclass->memory->stable_memory, 1);\n\n    psubclass_data = (void *)gs_alloc_bytes(dev_to_subclass->memory->non_gc_memory, private_data_size, \"subclass memory for subclassing device\");\n    if (psubclass_data == 0){\n        gs_free_const_object(dev_to_subclass->memory->non_gc_memory, b_std, \"gs_device_subclass(stype)\");\n        /* We *don't* want to run the finalize routine. This would free the stype and\n         * properly handle the icc_struct and PageList, but for devices with a custom\n         * finalize (eg psdcmyk) it might also free memory it had allocated, and we're\n         * still pointing at that memory in the parent.\n         */\n        a_std->finalize = NULL;\n        gs_set_object_type(dev_to_subclass->memory->stable_memory, child_dev, a_std);\n        gs_free_object(dev_to_subclass->memory->stable_memory, child_dev, \"free subclass memory for subclassing device\");\n        gs_free_const_object(dev_to_subclass->memory->non_gc_memory, a_std, \"gs_device_subclass(stype)\");\n        return_error(gs_error_VMerror);\n    }\n    memset(psubclass_data, 0x00, private_data_size);\n\n    gx_copy_device_procs(dev_to_subclass, child_dev, new_prototype);\n    dev_to_subclass->finalize = new_prototype->finalize;\n    dev_to_subclass->dname = new_prototype->dname;\n    if (dev_to_subclass->icc_struct)\n        rc_increment(dev_to_subclass->icc_struct);\n    if (dev_to_subclass->PageList)\n        rc_increment(dev_to_subclass->PageList);\n    if (dev_to_subclass->NupControl)\n        rc_increment(dev_to_subclass->NupControl);\n\n    dev_to_subclass->page_procs = new_prototype->page_procs;\n    gx_subclass_fill_in_page_procs(dev_to_subclass);\n\n    /* In case the new device we're creating has already been initialised, copy\n     * its additional data.\n     */\n    ptr = ((char *)dev_to_subclass) + sizeof(gx_device);\n    ptr1 = ((char *)new_prototype) + sizeof(gx_device);\n    memcpy(ptr, ptr1, new_prototype->params_size - sizeof(gx_device));\n\n    /* If the original device's stype structure was dynamically allocated, we need\n     * to 'fixup' the contents, it's procs need to point to the new device's procs\n     * for instance.\n     */\n    if (dynamic) {\n        if (new_prototype->stype) {\n            b_std = (gs_memory_struct_type_t *)dev_to_subclass->stype;\n            *b_std = *new_prototype->stype;\n            b_std->ssize = a_std->ssize;\n            dev_to_subclass->stype_is_dynamic = 1;\n        } else {\n            gs_free_const_object(child_dev->memory->non_gc_memory, dev_to_subclass->stype,\n                             \"unsubclass\");\n            dev_to_subclass->stype = NULL;\n            b_std = (gs_memory_struct_type_t *)new_prototype->stype;\n            dev_to_subclass->stype_is_dynamic = 0;\n        }\n    }\n    else {\n        *b_std = *new_prototype->stype;\n        b_std->ssize = a_std->ssize;\n        dev_to_subclass->stype_is_dynamic = 1;\n    }\n    dev_to_subclass->stype = b_std;\n    /* We have to patch up the \"type\" parameters that the memory manage/garbage\n     * collector will use, as well.\n     */\n    gs_set_object_type(child_dev->memory, dev_to_subclass, b_std);\n\n    dev_to_subclass->subclass_data = psubclass_data;\n    dev_to_subclass->child = child_dev;\n    if (child_dev->parent) {\n        dev_to_subclass->parent = child_dev->parent;\n        child_dev->parent->child = dev_to_subclass;\n    }\n    if (child_dev->child) {\n        child_dev->child->parent = child_dev;\n    }\n    child_dev->parent = dev_to_subclass;\n\n    return 0;\n}\nvoid gx_device_unsubclass(gx_device *dev)\n{\n    generic_subclass_data *psubclass_data;\n    gx_device *parent, *child;\n    gs_memory_struct_type_t *a_std = 0, *b_std = 0;\n    int dynamic, ref_count;\n    gs_memory_t *rcmem;\n\n    /* This should not happen... */\n    if (!dev)\n        return;\n\n    ref_count = dev->rc.ref_count;\n    rcmem = dev->rc.memory;\n\n    child = dev->child;\n    psubclass_data = (generic_subclass_data *)dev->subclass_data;\n    parent = dev->parent;\n    dynamic = dev->stype_is_dynamic;\n\n    /* We need to account for the fact that we are removing ourselves from\n     * the device chain after a clist device has been pushed, due to a\n     * compositor action. Since we patched the clist 'composite'\n     * method (and target device) when it was pushed.\n     * A point to note; we *don't* want to change the forwarding device's\n     * 'target', because when we copy the child up to replace 'this' device\n     * we do still want the forwarding device to point here. NB its the *child*\n     * device that goes away.\n     */\n    if (psubclass_data != NULL && psubclass_data->forwarding_dev != NULL && psubclass_data->saved_compositor_method)\n        psubclass_data->forwarding_dev->procs.composite = psubclass_data->saved_compositor_method;\n\n    /* If ths device's stype is dynamically allocated, keep a copy of it\n     * in case we might need it.\n     */\n    if (dynamic) {\n        a_std = (gs_memory_struct_type_t *)dev->stype;\n        if (child)\n            *a_std = *child->stype;\n    }\n\n    /* If ths device has any private storage, free it now */\n    if (psubclass_data)\n        gs_free_object(dev->memory->non_gc_memory, psubclass_data, \"gx_device_unsubclass\");\n\n    /* Copy the child device into ths device's memory */\n    if (child) {\n        b_std = (gs_memory_struct_type_t *)dev->stype;\n        rc_decrement(dev->icc_struct, \"unsubclass device\");\n        rc_increment(child->icc_struct);\n        memcpy(dev, child, child->stype->ssize);\n        /* Patch back the 'stype' in the memory manager */\n        gs_set_object_type(child->memory, dev, b_std);\n\n        dev->stype = b_std;\n        /* The reference count of the subclassing device may have been\n         * changed (eg graphics states pointing to it) after we subclassed\n         * the device. We need to ensure that we do not overwrite this\n         * when we copy back the subclassed device.\n         */\n        dev->rc.ref_count = ref_count;\n        dev->rc.memory = rcmem;\n\n        /* If we have a chain of devices, make sure the chain beyond the\n         * device we're unsubclassing doesn't get broken, we need to\n         * detach the lower chain and reattach it at the new highest level.\n         */\n        if (child->child)\n            child->child->parent = dev;\n        child->parent->child = child->child;\n    }\n\n    /* How can we have a subclass device with no child ? Simples; when we\n     * hit the end of job restore, the devices are not freed in device\n     * chain order. To make sure we don't end up following stale pointers,\n     * when a device is freed we remove it from the chain and update\n     * any dangling pointers to NULL. When we later free the remaining\n     * devices it's possible that their child pointer can then be NULL.\n     */\n    if (child) {\n        /* We cannot afford to free the child device if its stype is not\n         * dynamic because we can't 'null' the finalise routine, and we\n         * cannot permit the device to be finalised because we have copied\n         * it up one level, not discarded it. (This shouldn't happen! Child\n         * devices are always created with a dynamic stype.) If this ever\n         * happens garbage collecton will eventually clean up the memory.\n         */\n        if (child->stype_is_dynamic) {\n            /* Make sure that nothing will try to follow the device chain,\n             * just security here. */\n            child->parent = NULL;\n            child->child = NULL;\n\n            /* We *don't* want to run the finalize routine. This would free\n             * the stype and properly handle the icc_struct and PageList,\n             * but for devices with a custom finalize (eg psdcmyk) it might\n             * also free memory it had allocated, and we're still pointing\n             * at that memory in the parent. The indirection through a\n             * variable is just to get rid of const warnings.\n             */\n            b_std = (gs_memory_struct_type_t *)child->stype;\n            gs_free_const_object(dev->memory->non_gc_memory, b_std, \"gs_device_unsubclass(stype)\");\n            /* Make this into a generic device */\n            child->stype = &st_device;\n            child->stype_is_dynamic = false;\n\n            /* We can't simply discard the child device, because there may be references to it elsewhere,\n               but equally, we really don't want it doing anything, so set the procs so actions are just discarded.\n             */\n            gx_copy_device_procs(child, (gx_device *)&gs_null_device, (gx_device *)&gs_null_device);\n\n            /* Having changed the stype, we need to make sure the memory\n             * manager uses it. It keeps a copy in its own data structure,\n             * and would use that copy, which would mean it would call the\n             * finalize routine that we just patched out.\n             */\n            gs_set_object_type(dev->memory->stable_memory, child, child->stype);\n            child->finalize = NULL;\n            /* Now (finally) free the child memory */\n            rc_decrement(child, \"gx_device_unsubclass(device)\");\n        }\n    }\n    dev->parent = parent;\n\n    /* If this device has a dynamic stype, we wnt to keep using it, but we copied\n     * the stype pointer from the child when we copied the rest of the device. So\n     * we update the stype pointer with the saved pointer to this device's stype.\n     */\n    if (dynamic) {\n        dev->stype = a_std;\n        dev->stype_is_dynamic = 1;\n    } else {\n        dev->stype_is_dynamic = 0;\n    }\n}\nvoid default_subclass_finalize(const gs_memory_t *cmem, void *vptr)\n{\n    gx_device * const dev = (gx_device *)vptr;\n    generic_subclass_data *psubclass_data = (generic_subclass_data *)dev->subclass_data;\n    (void)cmem; /* unused */\n\n    discard(gs_closedevice(dev));\n\n    if (dev->finalize)\n        dev->finalize(dev);\n\n    rc_decrement(dev->child, \"de-reference child device\");\n\n    if (psubclass_data) {\n        gs_free_object(dev->memory->non_gc_memory, psubclass_data, \"gx_epo_finalize(suclass data)\");\n        dev->subclass_data = NULL;\n    }\n    if (dev->stype_is_dynamic)\n        gs_free_const_object(dev->memory->non_gc_memory, dev->stype,\n                             \"default_subclass_finalize\");\n    if (dev->parent)\n        dev->parent->child = dev->child;\n    if (dev->child)\n        dev->child->parent = dev->parent;\n    if (dev->icc_struct)\n        rc_decrement(dev->icc_struct, \"finalize subclass device\");\n    if (dev->PageList)\n        rc_decrement(dev->PageList, \"finalize subclass device\");\n    if (dev->NupControl)\n        rc_decrement(dev->NupControl, \"finalize subclass device\");\n}\n",
    "target": 0,
    "idx": 2048305
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "static void\nudiv(mrb_state *mrb, mpz_t *qq, mpz_t *rr, mpz_t *xx, mpz_t *yy)\n{\n  mpz_t q, x, y, r;\n  int ns,f,ccc=0;\n  int xd,yd,i,j;\n  mp_limb zz,z,qhat,b,u,m;\n\n  if (uzero(yy))\n    return;\n  mpz_init(mrb,&q); mpz_init(mrb,&x);mpz_init(mrb,&y);mpz_init(mrb,&r);\n  mpz_realloc(mrb,&x,(size_t)((xx->sz)+1));\n  yd = digits(yy);\n  ns = lzb(yy->p[yd-1]);\n  ulshift(mrb,&x,xx,ns);\n  ulshift(mrb,&y,yy,ns);\n  xd = digits(&x);\n  mpz_realloc(mrb,&q,(size_t)xd);\n  xd*=2; yd*=2;\n  z = hd(&y,yd-1);\n  for (j=(xd-yd);j>=0;j--) {\n    if (z == LMAX)\n      qhat = hd(&x,j+yd);\n    else {\n      qhat = ((hd(&x,j+yd)<< HALFDIGITBITS) + hd(&x,j+yd-1)) / (z+1);\n    }\n    b = 0; zz=0;\n    if (qhat) {\n      for (i=0; i<yd; i++) {\n        zz = qhat * hd(&y,i);\n        u = hd(&x,i+j);\n        u-=b;\n        if (u<0) {\n          b=1; u+=HLMAX+1;\n        }\n        else\n          b=0;\n        u-=LOW(zz);\n        if (u < 0) {\n          b++;\n          u+=HLMAX+1;\n        }\n        b+=HIGH(zz);\n        if ((i+j)%2)\n          x.p[(i+j)/2] = LOW(x.p[(i+j)/2]) | (u << HALFDIGITBITS);\n        else\n          x.p[(i+j)/2] = (HIGH(x.p[(i+j)/2]) << HALFDIGITBITS) | u;\n      }\n      if (b) {\n        if ((j+i)%2)\n          x.p[(i+j)/2] -= b << HALFDIGITBITS;\n        else\n          x.p[(i+j)/2] -= b;\n      }\n    }\n    for (;;zz++) {\n      f=1;\n      if (!hd(&x,j+yd)) {\n        for (i=yd-1; i>=0; i--) {\n          if (hd(&x,j+i) > hd(&y,i)) {\n            f=1;\n            break;\n          }\n          if (hd(&x,j+i) < hd(&y,i)) {\n            f=0;\n            break;\n          }\n          if (i == 0) break;\n        }\n      }\n      if (!f)\n        break;\n      qhat++;\n      ccc++;\n      b=0;\n      for (i=0;i<yd;i++) {\n        m = hd(&x,i+j)-hd(&y,i)-b;\n        if (m < 0) {\n          b = 1;\n          m = HLMAX + 1 + m;\n        }\n        else\n          b = 0;\n        if ((i+j)%2)\n          x.p[(i+j)/2] = LOW(x.p[(i+j)/2]) | (m << HALFDIGITBITS);\n        else\n          x.p[(i+j)/2] = (HIGH(x.p[(i+j)/2]) << HALFDIGITBITS) | m;\n      }\n      if (b) {\n        if ((j+i)%2)\n          x.p[(i+j)/2] -= b << HALFDIGITBITS;\n        else\n          x.p[(i+j)/2] -= b;\n      }\n    }\n    if (j%2)\n      q.p[j/2] |= qhat << HALFDIGITBITS;\n    else\n      q.p[j/2] |= qhat;\n    if (j == 0) break;\n  }\n  mpz_realloc(mrb,&r,(size_t)(yy->sz));\n  zero(&r);\n  urshift(mrb,&r,&x,ns);\n  mpz_set(mrb,rr,&r);\n  mpz_set(mrb,qq,&q);\n  mpz_clear(mrb,&x); mpz_clear(mrb,&y);\n  mpz_clear(mrb,&q); mpz_clear(mrb,&r);\n}\nstatic int\nmpz_init_set_str(mrb_state *mrb, mpz_t *x, const char *s, mrb_int len, mrb_int base)\n{\n  int i;\n  int retval = 0;\n  mpz_t t,m,bb;\n  short sn;\n  unsigned int k;\n  mpz_init(mrb,x);\n  mpz_init_set_int(mrb,&m,1);\n  mpz_init(mrb,&t);\n  zero(x);\n  if (*s == '-') {\n    sn = -1; s++;\n  }\n  else if (base < 0) {          /* trick: negative if base < 0 */\n    sn = -1; base = -base;\n  }\n  else\n    sn = 1;\n  mpz_init_set_int(mrb,&bb, base);\n  for (i = len-1; i>=0; i--) {\n    if (s[i]=='_') continue;\n    if (s[i] >= '0' && s[i] <= '9')\n      k = (unsigned int)s[i] - (unsigned int)'0';\n    else if (s[i] >= 'A' && s[i] <= 'Z')\n      k = (unsigned int)s[i] - (unsigned int)'A'+10;\n    else if (s[i] >= 'a' && s[i] <= 'z')\n      k = (unsigned int)s[i] - (unsigned int)'a'+10;\n    else {\n      retval = (-1);\n      break;\n    }\n    if (k >= base) {\n      retval = (-1);\n      break;\n    }\n    mpz_mul_int(mrb,&t,&m,(mrb_int)k);\n    mpz_add(mrb,x,x,&t);\n    mpz_mul(mrb,&m,&m,&bb);\n    if (i == 0) break;\n  }\n  if (x->sn)\n    x->sn = sn;\n  mpz_clear(mrb,&m);\n  mpz_clear(mrb,&bb);\n  mpz_clear(mrb,&t);\n  return retval;\n}\n",
    "target": 0,
    "idx": 2048873
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "\nstatic void php_date_set_time_fraction(timelib_time *time, int microseconds)\n{\n\ttime->us = microseconds;\n}\nPHPAPI bool php_date_initialize(php_date_obj *dateobj, const char *time_str, size_t time_str_len, const char *format, zval *timezone_object, int flags) /* {{{ */\n{\n\ttimelib_time   *now;\n\ttimelib_tzinfo *tzi = NULL;\n\ttimelib_error_container *err = NULL;\n\tint type = TIMELIB_ZONETYPE_ID, new_dst = 0;\n\tchar *new_abbr = NULL;\n\ttimelib_sll new_offset = 0;\n\ttime_t sec;\n\tsuseconds_t usec;\n\tint options = 0;\n\n\tif (dateobj->time) {\n\t\ttimelib_time_dtor(dateobj->time);\n\t}\n\tif (format) {\n\t\tif (time_str_len == 0) {\n\t\t\ttime_str = \"\";\n\t\t}\n\t\tdateobj->time = timelib_parse_from_format(format, time_str, time_str_len, &err, DATE_TIMEZONEDB, php_date_parse_tzfile_wrapper);\n\t} else {\n\t\tif (time_str_len == 0) {\n\t\t\ttime_str = \"now\";\n\t\t\ttime_str_len = sizeof(\"now\") - 1;\n\t\t}\n\t\tdateobj->time = timelib_strtotime(time_str, time_str_len, &err, DATE_TIMEZONEDB, php_date_parse_tzfile_wrapper);\n\t}\n\n\t/* update last errors and warnings */\n\terr = update_errors_warnings(&err);\n\n\t/* If called from a constructor throw an exception */\n\tif ((flags & PHP_DATE_INIT_CTOR) && err && err->error_count) {\n\t\t/* spit out the first library error message, at least */\n\t\tzend_throw_exception_ex(NULL, 0, \"Failed to parse time string (%s) at position %d (%c): %s\", time_str,\n\t\t\terr->error_messages[0].position, err->error_messages[0].character, err->error_messages[0].message);\n\t}\n\tif (err && err->error_count) {\n\t\ttimelib_time_dtor(dateobj->time);\n\t\tdateobj->time = 0;\n\t\treturn 0;\n\t}\n\n\tif (timezone_object) {\n\t\tphp_timezone_obj *tzobj;\n\n\t\ttzobj = Z_PHPTIMEZONE_P(timezone_object);\n\t\tswitch (tzobj->type) {\n\t\t\tcase TIMELIB_ZONETYPE_ID:\n\t\t\t\ttzi = tzobj->tzi.tz;\n\t\t\t\tbreak;\n\t\t\tcase TIMELIB_ZONETYPE_OFFSET:\n\t\t\t\tnew_offset = tzobj->tzi.utc_offset;\n\t\t\t\tbreak;\n\t\t\tcase TIMELIB_ZONETYPE_ABBR:\n\t\t\t\tnew_offset = tzobj->tzi.z.utc_offset;\n\t\t\t\tnew_dst    = tzobj->tzi.z.dst;\n\t\t\t\tnew_abbr   = timelib_strdup(tzobj->tzi.z.abbr);\n\t\t\t\tbreak;\n\t\t}\n\t\ttype = tzobj->type;\n\t} else if (dateobj->time->tz_info) {\n\t\ttzi = dateobj->time->tz_info;\n\t} else {\n\t\ttzi = get_timezone_info();\n\t\tif (!tzi) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tnow = timelib_time_ctor();\n\tnow->zone_type = type;\n\tswitch (type) {\n\t\tcase TIMELIB_ZONETYPE_ID:\n\t\t\tnow->tz_info = tzi;\n\t\t\tbreak;\n\t\tcase TIMELIB_ZONETYPE_OFFSET:\n\t\t\tnow->z = new_offset;\n\t\t\tbreak;\n\t\tcase TIMELIB_ZONETYPE_ABBR:\n\t\t\tnow->z = new_offset;\n\t\t\tnow->dst = new_dst;\n\t\t\tnow->tz_abbr = new_abbr;\n\t\t\tbreak;\n\t}\n\tphp_date_get_current_time_with_fraction(&sec, &usec);\n\ttimelib_unixtime2local(now, (timelib_sll) sec);\n\tphp_date_set_time_fraction(now, usec);\n\n\tif (!format\n\t && time_str_len == sizeof(\"now\") - 1\n\t && memcmp(time_str, \"now\", sizeof(\"now\") - 1) == 0) {\n\t\ttimelib_time_dtor(dateobj->time);\n\t\tdateobj->time = now;\n\t\treturn 1;\n\t}\n\n\toptions = TIMELIB_NO_CLONE;\n\tif (flags & PHP_DATE_INIT_FORMAT) {\n\t\toptions |= TIMELIB_OVERRIDE_TIME;\n\t}\n\ttimelib_fill_holes(dateobj->time, now, options);\n\n\ttimelib_update_ts(dateobj->time, tzi);\n\ttimelib_update_from_sse(dateobj->time);\n\n\tdateobj->time->have_relative = 0;\n\n\ttimelib_time_dtor(now);\n\n\treturn 1;\n} /* }}} */\nstatic bool php_date_modify(zval *object, char *modify, size_t modify_len) /* {{{ */\n{\n\tphp_date_obj *dateobj;\n\ttimelib_time *tmp_time;\n\ttimelib_error_container *err = NULL;\n\n\tdateobj = Z_PHPDATE_P(object);\n\n\tif (!(dateobj->time)) {\n\t\tzend_throw_error(NULL, \"The DateTime object has not been correctly initialized by its constructor\");\n\t\treturn 0;\n\t}\n\n\ttmp_time = timelib_strtotime(modify, modify_len, &err, DATE_TIMEZONEDB, php_date_parse_tzfile_wrapper);\n\n\t/* update last errors and warnings */\n\terr = update_errors_warnings(&err);\n\n\tif (err && err->error_count) {\n\t\t/* spit out the first library error message, at least */\n\t\tphp_error_docref(NULL, E_WARNING, \"Failed to parse time string (%s) at position %d (%c): %s\", modify,\n\t\t\terr->error_messages[0].position, err->error_messages[0].character, err->error_messages[0].message);\n\t\ttimelib_time_dtor(tmp_time);\n\t\treturn 0;\n\t}\n\n\tmemcpy(&dateobj->time->relative, &tmp_time->relative, sizeof(timelib_rel_time));\n\tdateobj->time->have_relative = tmp_time->have_relative;\n\tdateobj->time->sse_uptodate = 0;\n\n\tif (tmp_time->y != -99999) {\n\t\tdateobj->time->y = tmp_time->y;\n\t}\n\tif (tmp_time->m != -99999) {\n\t\tdateobj->time->m = tmp_time->m;\n\t}\n\tif (tmp_time->d != -99999) {\n\t\tdateobj->time->d = tmp_time->d;\n\t}\n\n\tif (tmp_time->h != -99999) {\n\t\tdateobj->time->h = tmp_time->h;\n\t\tif (tmp_time->i != -99999) {\n\t\t\tdateobj->time->i = tmp_time->i;\n\t\t\tif (tmp_time->s != -99999) {\n\t\t\t\tdateobj->time->s = tmp_time->s;\n\t\t\t} else {\n\t\t\t\tdateobj->time->s = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tdateobj->time->i = 0;\n\t\t\tdateobj->time->s = 0;\n\t\t}\n\t}\n\n\tif (tmp_time->us != -99999) {\n\t\tdateobj->time->us = tmp_time->us;\n\t}\n\n\ttimelib_time_dtor(tmp_time);\n\n\ttimelib_update_ts(dateobj->time, NULL);\n\ttimelib_update_from_sse(dateobj->time);\n\tdateobj->time->have_relative = 0;\n\tmemset(&dateobj->time->relative, 0, sizeof(dateobj->time->relative));\n\n\treturn 1;\n} /* }}} */\n",
    "target": 0,
    "idx": 2050773
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "static void update_errors_warnings(timelib_error_container **last_errors) /* {{{ */\n{\n\tif (DATEG(last_errors)) {\n\t\ttimelib_error_container_dtor(DATEG(last_errors));\n\t\tDATEG(last_errors) = NULL;\n\t}\n\n\tif (last_errors == NULL || (*last_errors) == NULL) {\n\t\treturn;\n\t}\n\n\tif ((*last_errors)->warning_count || (*last_errors)->error_count) {\n\t\tDATEG(last_errors) = *last_errors;\n\t\treturn;\n\t}\n\n\ttimelib_error_container_dtor(*last_errors);\n\t*last_errors = NULL;\n} /* }}} */\n",
    "target": 0,
    "idx": 2051180
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "static int\nxmlXIncludeDoProcess(xmlXIncludeCtxtPtr ctxt, xmlNodePtr tree) {\n    xmlXIncludeRefPtr ref;\n    xmlNodePtr cur;\n    int ret = 0;\n    int i;\n\n    if ((tree == NULL) || (tree->type == XML_NAMESPACE_DECL))\n\treturn(-1);\n    if (ctxt == NULL)\n\treturn(-1);\n\n    /*\n     * First phase: lookup the elements in the document\n     */\n    cur = tree;\n    do {\n\t/* TODO: need to work on entities -> stack */\n        if (xmlXIncludeTestNode(ctxt, cur) == 1) {\n#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n            /*\n             * Avoid superlinear expansion by limiting the total number\n             * of replacements.\n             */\n            if (ctxt->incTotal >= 20)\n                break;\n#endif\n            ctxt->incTotal++;\n            ref = xmlXIncludeExpandNode(ctxt, cur);\n            /*\n             * Mark direct includes.\n             */\n            if (ref != NULL)\n                ref->replace = 1;\n        } else if ((cur->children != NULL) &&\n                   ((cur->type == XML_DOCUMENT_NODE) ||\n                    (cur->type == XML_ELEMENT_NODE))) {\n            cur = cur->children;\n            continue;\n        }\n        do {\n            if (cur == tree)\n                break;\n            if (cur->next != NULL) {\n                cur = cur->next;\n                break;\n            }\n            cur = cur->parent;\n        } while (cur != NULL);\n    } while ((cur != NULL) && (cur != tree));\n\n    /*\n     * Second phase: extend the original document infoset.\n     */\n    for (i = 0; i < ctxt->incNr; i++) {\n\tif (ctxt->incTab[i]->replace != 0) {\n            if ((ctxt->incTab[i]->inc != NULL) ||\n                (ctxt->incTab[i]->emptyFb != 0)) {\t/* (empty fallback) */\n                xmlXIncludeIncludeNode(ctxt, ctxt->incTab[i]);\n                ctxt->incTab[i]->replace = 0;\n            }\n        } else {\n            /*\n             * Ignore includes which were added indirectly, for example\n             * inside xi:fallback elements.\n             */\n            if (ctxt->incTab[i]->inc != NULL) {\n                xmlFreeNodeList(ctxt->incTab[i]->inc);\n                ctxt->incTab[i]->inc = NULL;\n            }\n        }\n\tret++;\n    }\n\n    return(ret);\n}\n",
    "target": 0,
    "idx": 2052869
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "PLIST_API int plist_from_openstep(const char *plist_ostep, uint32_t length, plist_t * plist)\n{\n    if (!plist) {\n        return PLIST_ERR_INVALID_ARG;\n    }\n    *plist = NULL;\n    if (!plist_ostep || (length == 0)) {\n        return PLIST_ERR_INVALID_ARG;\n    }\n\n    struct _parse_ctx ctx = { plist_ostep, plist_ostep, plist_ostep + length, 0 };\n\n    int err = node_from_openstep(&ctx, plist);\n    if (err == 0) {\n        if (!*plist) {\n            /* whitespace only file is considered an empty dictionary */\n            *plist = plist_new_dict();\n        } else if (ctx.pos < ctx.end && *ctx.pos == '=') {\n            /* attempt to parse this as 'strings' data */\n            plist_free(*plist);\n            *plist = NULL;\n            plist_t pl = plist_new_dict();\n            ctx.pos = plist_ostep;\n            parse_dict_data(&ctx, pl);\n            if (ctx.err > 0) {\n                plist_free(pl);\n                PLIST_OSTEP_ERR(\"Failed to parse strings data\\n\");\n                err = PLIST_ERR_PARSE;\n            } else {\n                *plist = pl;\n            }\n        }\n    }\n\n    return err;\n}\n",
    "target": 0,
    "idx": 2054949
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "int X509V3_EXT_add_nconf_sk(const CONF *conf, const X509V3_CTX *ctx,\n                            const char *section,\n                            STACK_OF(X509_EXTENSION) **sk) {\n  const STACK_OF(CONF_VALUE) *nval = NCONF_get_section(conf, section);\n  if (nval == NULL) {\n    return 0;\n  }\n  for (size_t i = 0; i < sk_CONF_VALUE_num(nval); i++) {\n    const CONF_VALUE *val = sk_CONF_VALUE_value(nval, i);\n    X509_EXTENSION *ext = X509V3_EXT_nconf(conf, ctx, val->name, val->value);\n    int ok = ext != NULL &&  //\n             (sk == NULL || X509v3_add_ext(sk, ext, -1) != NULL);\n    X509_EXTENSION_free(ext);\n    if (!ok) {\n      return 0;\n    }\n  }\n  return 1;\n}\n",
    "target": 0,
    "idx": 2055556
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "static int config__add_listener(struct mosquitto__config *config)\n{\n\tstruct mosquitto__listener *listener;\n\tint def_listener = -1;\n\n\tif(config->default_listener){\n\t\tfor(int i=0; i<config->listener_count; i++){\n\t\t\tif(&config->listeners[i] == config->default_listener){\n\t\t\t\tdef_listener = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tconfig->listener_count++;\n\tconfig->listeners = mosquitto__realloc(config->listeners, sizeof(struct mosquitto__listener)*(size_t)config->listener_count);\n\tif(!config->listeners){\n\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\treturn MOSQ_ERR_NOMEM;\n\t}\n\tlistener = &config->listeners[config->listener_count-1];\n\tmemset(listener, 0, sizeof(struct mosquitto__listener));\n\tlistener->security_options = mosquitto_calloc(1, sizeof(struct mosquitto__security_options));\n\tif(!listener->security_options){\n\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\treturn MOSQ_ERR_NOMEM;\n\t}\n\tif(def_listener != -1){\n\t\tconfig->default_listener = &config->listeners[def_listener];\n\t}\n\n\treturn MOSQ_ERR_SUCCESS;\n}\nstatic int config__create_default_listener(struct mosquitto__config *config, const char *option_name)\n{\n\tif(config->default_listener) return MOSQ_ERR_SUCCESS;\n\tlog__printf(NULL, MOSQ_LOG_INFO, \"Creating default listener due to '%s' option.\", option_name);\n\tlog__printf(NULL, MOSQ_LOG_INFO, \"It is best practice to define a 'listener' first. Using the '%s' option without a listener will be disabled in the future.\", option_name);\n\tif(config__add_listener(config)){\n\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\treturn MOSQ_ERR_NOMEM;\n\t}\n\n\tconfig->default_listener = &config->listeners[config->listener_count-1];\n\tlistener__set_defaults(config->default_listener);\n\tconfig->default_listener->port = 1883;\n\n\treturn MOSQ_ERR_SUCCESS;\n}\n",
    "target": 0,
    "idx": 2055886
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "\nstatic dds_return_t ddsi_type_new (struct ddsi_domaingv *gv, struct ddsi_type **type, const struct DDS_XTypes_TypeIdentifier *type_id, const struct DDS_XTypes_TypeObject *type_obj)\n{\n  dds_return_t ret;\n  struct ddsi_typeid_str tistr;\n  assert (type);\n  assert (!ddsi_typeid_is_none_impl (type_id));\n  assert (!ddsi_type_lookup_locked_impl (gv, type_id));\n\n  ddsi_typeid_t type_obj_id;\n  if (type_obj && ((ret = ddsi_typeobj_get_hash_id (type_obj, &type_obj_id))\n      || (ret = (ddsi_typeid_compare_impl (&type_obj_id.x, type_id) ? DDS_RETCODE_BAD_PARAMETER : DDS_RETCODE_OK))))\n  {\n    GVWARNING (\"non-matching type identifier (%s) and type object (%s)\\n\", ddsi_make_typeid_str_impl (&tistr, type_id), ddsi_make_typeid_str (&tistr, &type_obj_id));\n    *type = NULL;\n    return ret;\n  }\n\n  if ((*type = ddsrt_calloc (1, sizeof (**type))) == NULL)\n    return DDS_RETCODE_OUT_OF_RESOURCES;\n\n  GVTRACE (\" new %p\", *type);\n  if ((ret = ddsi_xt_type_init_impl (gv, &(*type)->xt, type_id, type_obj)) != DDS_RETCODE_OK)\n  {\n    ddsi_type_free (gv, *type);\n    *type = NULL;\n    return ret;\n  }\n  if (!ddsi_typeid_is_hash (&(*type)->xt.id))\n    (*type)->state = DDSI_TYPE_RESOLVED;\n  /* inserted with refc 0 (set by calloc), refc is increased in\n     ddsi_type_ref_* functions */\n  ddsrt_avl_insert (&ddsi_typelib_treedef, &gv->typelib, *type);\n  return DDS_RETCODE_OK;\n}\nstatic dds_return_t ddsi_type_register_dep_impl (struct ddsi_domaingv *gv, const ddsi_typeid_t *src_type_id, struct ddsi_type **dst_dep_type, const struct DDS_XTypes_TypeIdentifier *dep_tid, bool from_type_info)\n{\n  dds_return_t ret = DDS_RETCODE_OK;\n  struct ddsi_typeid dep_type_id;\n\n  if (ddsi_typeid_is_none_impl (dep_tid))\n    return DDS_RETCODE_BAD_PARAMETER;\n\n  dep_type_id.x = *dep_tid;\n  struct ddsi_type_dep *dep = ddsrt_calloc (1, sizeof (*dep));\n  ddsi_typeid_copy (&dep->src_type_id, src_type_id);\n  ddsi_typeid_copy (&dep->dep_type_id, &dep_type_id);\n  bool existing = ddsrt_avl_lookup (&ddsi_typedeps_treedef, &gv->typedeps, dep) != NULL;\n  type_dep_trace (gv, existing ? \"has \" : \"add \", dep);\n  if (!existing)\n  {\n    dep->from_type_info = from_type_info;\n    ddsrt_avl_insert (&ddsi_typedeps_treedef, &gv->typedeps, dep);\n    ddsrt_avl_insert (&ddsi_typedeps_reverse_treedef, &gv->typedeps_reverse, dep);\n    if ((ret = ddsi_type_ref_id_locked (gv, dst_dep_type, &dep_type_id)) != DDS_RETCODE_OK)\n    {\n      ddsrt_avl_delete (&ddsi_typedeps_treedef, &gv->typedeps, dep);\n      ddsrt_avl_delete (&ddsi_typedeps_reverse_treedef, &gv->typedeps_reverse, dep);\n      ddsi_typeid_fini (&dep->src_type_id);\n      ddsi_typeid_fini (&dep->dep_type_id);\n      ddsrt_free (dep);\n    }\n  }\n  else\n  {\n    ddsi_typeid_fini (&dep->src_type_id);\n    ddsi_typeid_fini (&dep->dep_type_id);\n    ddsrt_free (dep);\n    if (!from_type_info)\n      ret = ddsi_type_ref_id_locked (gv, dst_dep_type, &dep_type_id);\n    else\n    {\n      *dst_dep_type = ddsi_type_lookup_locked (gv, &dep_type_id);\n      if (*dst_dep_type == NULL)\n        ret = DDS_RETCODE_ERROR;\n    }\n  }\n  return ret;\n}\ndds_return_t ddsi_type_ref_id_locked_impl (struct ddsi_domaingv *gv, struct ddsi_type **type, const struct DDS_XTypes_TypeIdentifier *type_id)\n{\n  struct ddsi_typeid_str tistr;\n  dds_return_t ret = DDS_RETCODE_OK;\n  if (ddsi_typeid_is_none_impl (type_id))\n    return DDS_RETCODE_BAD_PARAMETER;\n\n  GVTRACE (\"ref ddsi_type type-id %s\", ddsi_make_typeid_str_impl (&tistr, type_id));\n  struct ddsi_type *t = ddsi_type_lookup_locked_impl (gv, type_id);\n  if (!t && (ret = ddsi_type_new (gv, &t, type_id, NULL)) != DDS_RETCODE_OK)\n  {\n    if (type)\n      *type = NULL;\n    return ret;\n  }\n  t->refc++;\n  GVTRACE (\" refc %\"PRIu32\"\\n\", t->refc);\n  if (type)\n    *type = t;\n  return ret;\n}\nvoid ddsi_type_unreg_proxy (struct ddsi_domaingv *gv, struct ddsi_type *type, const ddsi_guid_t *proxy_guid)\n{\n  struct ddsi_typeid_str tistr;\n  assert (proxy_guid);\n  if (!type)\n    return;\n  ddsrt_mutex_lock (&gv->typelib_lock);\n  GVTRACE (\"unreg proxy guid \" PGUIDFMT \" ddsi_type id %s\\n\", PGUID (*proxy_guid), ddsi_make_typeid_str (&tistr, &type->xt.id));\n  ddsi_type_proxy_guid_list_remove (&type->proxy_guids, *proxy_guid, ddsi_type_proxy_guids_eq);\n  ddsrt_mutex_unlock (&gv->typelib_lock);\n}\nvoid ddsi_type_unref (struct ddsi_domaingv *gv, struct ddsi_type *type)\n{\n  ddsrt_mutex_lock (&gv->typelib_lock);\n  ddsi_type_unref_locked (gv, type);\n  ddsrt_mutex_unlock (&gv->typelib_lock);\n}\nvoid ddsi_type_unref_sertype (struct ddsi_domaingv *gv, const struct ddsi_sertype *sertype)\n{\n  assert (sertype);\n  ddsrt_mutex_lock (&gv->typelib_lock);\n\n  ddsi_typeid_kind_t kinds[2] = { DDSI_TYPEID_KIND_MINIMAL, DDSI_TYPEID_KIND_COMPLETE };\n  for (uint32_t n = 0; n < sizeof (kinds) / sizeof (kinds[0]); n++)\n  {\n    struct ddsi_type *type;\n    ddsi_typeid_t *type_id = ddsi_sertype_typeid (sertype, kinds[n]);\n    if (!ddsi_typeid_is_none (type_id) && ((type = ddsi_type_lookup_locked (gv, type_id))))\n    {\n      struct ddsi_typeid_str tistr;\n      GVTRACE (\"unref ddsi_type id %s\", ddsi_make_typeid_str (&tistr, &type->xt.id));\n      ddsi_type_unref_impl_locked (gv, type);\n    }\n    if (type_id)\n    {\n      ddsi_typeid_fini (type_id);\n      ddsrt_free (type_id);\n    }\n  }\n\n  ddsrt_mutex_unlock (&gv->typelib_lock);\n}\nstatic void ddsi_type_get_gpe_matches_impl (struct ddsi_domaingv *gv, const struct ddsi_type *type, struct ddsi_generic_proxy_endpoint ***gpe_match_upd, uint32_t *n_match_upd)\n{\n  if (!ddsi_type_proxy_guid_list_count (&type->proxy_guids))\n    return;\n\n  uint32_t n = 0;\n  ddsi_thread_state_awake (ddsi_lookup_thread_state (), gv);\n  *gpe_match_upd = ddsrt_realloc (*gpe_match_upd, (*n_match_upd + ddsi_type_proxy_guid_list_count (&type->proxy_guids)) * sizeof (**gpe_match_upd));\n  struct ddsi_type_proxy_guid_list_iter it;\n  for (ddsi_guid_t guid = ddsi_type_proxy_guid_list_iter_first (&type->proxy_guids, &it); !ddsi_is_null_guid (&guid); guid = ddsi_type_proxy_guid_list_iter_next (&it))\n  {\n    if (!ddsi_is_topic_entityid (guid.entityid))\n    {\n      struct ddsi_entity_common *ec = ddsi_entidx_lookup_guid_untyped (gv->entity_index, &guid);\n      if (ec != NULL)\n      {\n        assert (ec->kind == DDSI_EK_PROXY_READER || ec->kind == DDSI_EK_PROXY_WRITER);\n        (*gpe_match_upd)[*n_match_upd + n++] = (struct ddsi_generic_proxy_endpoint *) ec;\n      }\n    }\n  }\n  *n_match_upd += n;\n  ddsi_thread_state_asleep (ddsi_lookup_thread_state ());\n}\ndds_return_t ddsi_xt_type_init_impl (struct ddsi_domaingv *gv, struct xt_type *xt, const struct DDS_XTypes_TypeIdentifier *ti, const struct DDS_XTypes_TypeObject *to)\n{\n  assert (xt);\n  assert (ti);\n  dds_return_t ret = DDS_RETCODE_OK;\n\n  ddsi_typeid_copy_impl (&xt->id.x, ti);\n  if (ti->_d <= DDS_XTypes_TK_STRING16)\n  {\n    if (to != NULL)\n      return DDS_RETCODE_BAD_PARAMETER;\n    xt->_d = ti->_d;\n  }\n  else\n  {\n    switch (ti->_d)\n    {\n      case DDS_XTypes_TI_STRING8_SMALL:\n        xt->_d = DDS_XTypes_TK_STRING8;\n        xt->_u.str8.bound = (DDS_XTypes_LBound) ti->_u.string_sdefn.bound;\n        break;\n      case DDS_XTypes_TI_STRING8_LARGE:\n        xt->_d = DDS_XTypes_TK_STRING8;\n        xt->_u.str8.bound = ti->_u.string_ldefn.bound;\n        break;\n      case DDS_XTypes_TI_STRING16_SMALL:\n        xt->_d = DDS_XTypes_TK_STRING16;\n        xt->_u.str16.bound = (DDS_XTypes_LBound) ti->_u.string_sdefn.bound;\n        break;\n      case DDS_XTypes_TI_STRING16_LARGE:\n        xt->_d = DDS_XTypes_TK_STRING16;\n        xt->_u.str16.bound = ti->_u.string_ldefn.bound;\n        break;\n      case DDS_XTypes_TI_PLAIN_SEQUENCE_SMALL:\n        xt->_d = DDS_XTypes_TK_SEQUENCE;\n        if ((ret = ddsi_type_register_dep (gv, &xt->id, &xt->_u.seq.c.element_type, ti->_u.seq_sdefn.element_identifier)) != DDS_RETCODE_OK)\n          goto err;\n        xt->_u.seq.bound = (DDS_XTypes_LBound) ti->_u.seq_sdefn.bound;\n        xt_collection_common_init (&xt->_u.seq.c, &ti->_u.seq_sdefn.header);\n        break;\n      case DDS_XTypes_TI_PLAIN_SEQUENCE_LARGE:\n        xt->_d = DDS_XTypes_TK_SEQUENCE;\n        if ((ret = ddsi_type_register_dep (gv, &xt->id, &xt->_u.seq.c.element_type, ti->_u.seq_ldefn.element_identifier)) != DDS_RETCODE_OK)\n          goto err;\n        xt->_u.seq.bound = ti->_u.seq_ldefn.bound;\n        xt_collection_common_init (&xt->_u.seq.c, &ti->_u.seq_ldefn.header);\n        break;\n      case DDS_XTypes_TI_PLAIN_ARRAY_SMALL:\n        xt->_d = DDS_XTypes_TK_ARRAY;\n        if ((ret = ddsi_type_register_dep (gv, &xt->id, &xt->_u.array.c.element_type, ti->_u.array_sdefn.element_identifier)) != DDS_RETCODE_OK)\n          goto err;\n        xt_collection_common_init (&xt->_u.array.c, &ti->_u.array_sdefn.header);\n        xt_sbounds_to_lbounds (&xt->_u.array.bounds, &ti->_u.array_sdefn.array_bound_seq);\n        break;\n      case DDS_XTypes_TI_PLAIN_ARRAY_LARGE:\n        xt->_d = DDS_XTypes_TK_ARRAY;\n        if ((ret = ddsi_type_register_dep (gv, &xt->id, &xt->_u.array.c.element_type, ti->_u.array_ldefn.element_identifier)) != DDS_RETCODE_OK)\n          goto err;\n        xt_collection_common_init (&xt->_u.array.c, &ti->_u.array_ldefn.header);\n        xt_lbounds_dup (&xt->_u.array.bounds, &ti->_u.array_ldefn.array_bound_seq);\n        break;\n      case DDS_XTypes_TI_PLAIN_MAP_SMALL:\n        xt->_d = DDS_XTypes_TK_MAP;\n        if ((ret = ddsi_type_register_dep (gv, &xt->id, &xt->_u.map.c.element_type, ti->_u.map_sdefn.element_identifier)) != DDS_RETCODE_OK)\n          goto err;\n        xt->_u.map.bound = (DDS_XTypes_LBound) ti->_u.map_sdefn.bound;\n        xt_collection_common_init (&xt->_u.map.c, &ti->_u.map_sdefn.header);\n        if ((ret = ddsi_type_register_dep (gv, &xt->id, &xt->_u.map.key_type, ti->_u.map_sdefn.key_identifier)) != DDS_RETCODE_OK)\n        {\n          ddsi_type_unref_locked (gv, xt->_u.map.c.element_type);\n          xt->_u.map.c.element_type = NULL;\n          goto err;\n        }\n        break;\n      case DDS_XTypes_TI_PLAIN_MAP_LARGE:\n        xt->_d = DDS_XTypes_TK_MAP;\n        if ((ret = ddsi_type_register_dep (gv, &xt->id, &xt->_u.map.c.element_type, ti->_u.map_ldefn.element_identifier)) != DDS_RETCODE_OK)\n          goto err;\n        xt->_u.map.bound = (DDS_XTypes_LBound) ti->_u.map_ldefn.bound;\n        xt_collection_common_init (&xt->_u.map.c, &ti->_u.map_ldefn.header);\n        if ((ret = ddsi_type_register_dep (gv, &xt->id, &xt->_u.map.key_type, ti->_u.map_ldefn.key_identifier)) != DDS_RETCODE_OK)\n        {\n          ddsi_type_unref_locked (gv, xt->_u.map.c.element_type);\n          xt->_u.map.c.element_type = NULL;\n          goto err;\n        }\n        break;\n      case DDS_XTypes_EK_MINIMAL:\n        if (to != NULL)\n          ret = add_minimal_typeobj (gv, xt, to);\n        break;\n      case DDS_XTypes_EK_COMPLETE:\n        if (to != NULL)\n          ret = add_complete_typeobj (gv, xt, to);\n        break;\n      case DDS_XTypes_TI_STRONGLY_CONNECTED_COMPONENT:\n        xt->_d = DDS_XTypes_TI_STRONGLY_CONNECTED_COMPONENT;\n        xt->sc_component_id = ti->_u.sc_component_id;\n        break;\n      default:\n        ddsi_typeid_fini (&xt->id);\n        ret = DDS_RETCODE_UNSUPPORTED; /* not supported */\n        break;\n    }\n  }\n  if (ret != DDS_RETCODE_OK || (ret = ddsi_xt_validate (gv, xt)) != DDS_RETCODE_OK)\n  {\n    GVWARNING (\"type \" PTYPEIDFMT \": ddsi_xt_type_init_impl with invalid type object\\n\", PTYPEID (xt->id.x));\n    goto err;\n  }\n  xt->kind = ddsi_typeid_kind_impl (ti);\n\nerr:\n  return ret;\n}\n",
    "target": 0,
    "idx": 2056837
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "\n\n",
    "target": 0,
    "idx": 2057608
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "void dav1d_flush(Dav1dContext *const c) {\n    dav1d_data_unref_internal(&c->in);\n    if (c->out.p.frame_hdr)\n        dav1d_thread_picture_unref(&c->out);\n    if (c->cache.p.frame_hdr)\n        dav1d_thread_picture_unref(&c->cache);\n\n    c->drain = 0;\n    c->cached_error = 0;\n\n    for (int i = 0; i < 8; i++) {\n        if (c->refs[i].p.p.frame_hdr)\n            dav1d_thread_picture_unref(&c->refs[i].p);\n        dav1d_ref_dec(&c->refs[i].segmap);\n        dav1d_ref_dec(&c->refs[i].refmvs);\n        dav1d_cdf_thread_unref(&c->cdf[i]);\n    }\n    c->frame_hdr = NULL;\n    c->seq_hdr = NULL;\n    dav1d_ref_dec(&c->seq_hdr_ref);\n\n    c->mastering_display = NULL;\n    c->content_light = NULL;\n    c->itut_t35 = NULL;\n    dav1d_ref_dec(&c->mastering_display_ref);\n    dav1d_ref_dec(&c->content_light_ref);\n    dav1d_ref_dec(&c->itut_t35_ref);\n\n    dav1d_data_props_unref_internal(&c->cached_error_props);\n\n    if (c->n_fc == 1 && c->n_tc == 1) return;\n    atomic_store(c->flush, 1);\n\n    // stop running tasks in worker threads\n    if (c->n_tc > 1) {\n        pthread_mutex_lock(&c->task_thread.lock);\n        for (unsigned i = 0; i < c->n_tc; i++) {\n            Dav1dTaskContext *const tc = &c->tc[i];\n            while (!tc->task_thread.flushed) {\n                pthread_cond_wait(&tc->task_thread.td.cond, &c->task_thread.lock);\n            }\n        }\n        for (unsigned i = 0; i < c->n_fc; i++) {\n            c->fc[i].task_thread.task_head = NULL;\n            c->fc[i].task_thread.task_tail = NULL;\n            c->fc[i].task_thread.task_cur_prev = NULL;\n            c->fc[i].task_thread.pending_tasks.head = NULL;\n            c->fc[i].task_thread.pending_tasks.tail = NULL;\n            atomic_init(&c->fc[i].task_thread.pending_tasks.merge, 0);\n        }\n        atomic_init(&c->task_thread.first, 0);\n        c->task_thread.cur = c->n_fc;\n        atomic_store(&c->task_thread.reset_task_cur, UINT_MAX);\n        atomic_store(&c->task_thread.cond_signaled, 0);\n        pthread_mutex_unlock(&c->task_thread.lock);\n    }\n\n    // wait for threads to complete flushing\n    if (c->n_fc > 1) {\n        for (unsigned n = 0, next = c->frame_thread.next; n < c->n_fc; n++, next++) {\n            if (next == c->n_fc) next = 0;\n            Dav1dFrameContext *const f = &c->fc[next];\n            dav1d_decode_frame_exit(f, -1);\n            f->n_tile_data = 0;\n            f->task_thread.retval = 0;\n            Dav1dThreadPicture *out_delayed = &c->frame_thread.out_delayed[next];\n            if (out_delayed->p.frame_hdr) {\n                dav1d_thread_picture_unref(out_delayed);\n            }\n        }\n        c->frame_thread.next = 0;\n    }\n    atomic_store(c->flush, 0);\n}\nstatic COLD void close_internal(Dav1dContext **const c_out, int flush) {\n    Dav1dContext *const c = *c_out;\n    if (!c) return;\n\n    if (flush) dav1d_flush(c);\n\n    if (c->tc) {\n        struct TaskThreadData *ttd = &c->task_thread;\n        if (ttd->inited) {\n            pthread_mutex_lock(&ttd->lock);\n            for (unsigned n = 0; n < c->n_tc && c->tc[n].task_thread.td.inited; n++)\n                c->tc[n].task_thread.die = 1;\n            pthread_cond_broadcast(&ttd->cond);\n            pthread_mutex_unlock(&ttd->lock);\n            for (unsigned n = 0; n < c->n_tc; n++) {\n                Dav1dTaskContext *const pf = &c->tc[n];\n                if (!pf->task_thread.td.inited) break;\n                pthread_join(pf->task_thread.td.thread, NULL);\n                pthread_cond_destroy(&pf->task_thread.td.cond);\n                pthread_mutex_destroy(&pf->task_thread.td.lock);\n            }\n            pthread_cond_destroy(&ttd->delayed_fg.cond);\n            pthread_cond_destroy(&ttd->cond);\n            pthread_mutex_destroy(&ttd->lock);\n        }\n        dav1d_free_aligned(c->tc);\n    }\n\n    for (unsigned n = 0; c->fc && n < c->n_fc; n++) {\n        Dav1dFrameContext *const f = &c->fc[n];\n\n        // clean-up threading stuff\n        if (c->n_fc > 1) {\n            freep(&f->tile_thread.lowest_pixel_mem);\n            freep(&f->frame_thread.b);\n            dav1d_freep_aligned(&f->frame_thread.pal_idx);\n            dav1d_freep_aligned(&f->frame_thread.cf);\n            freep(&f->frame_thread.tile_start_off);\n            dav1d_freep_aligned(&f->frame_thread.pal);\n            freep(&f->frame_thread.cbi);\n        }\n        if (c->n_tc > 1) {\n            pthread_mutex_destroy(&f->task_thread.pending_tasks.lock);\n            pthread_cond_destroy(&f->task_thread.cond);\n            pthread_mutex_destroy(&f->task_thread.lock);\n        }\n        freep(&f->frame_thread.frame_progress);\n        freep(&f->task_thread.tasks);\n        freep(&f->task_thread.tile_tasks[0]);\n        dav1d_free_aligned(f->ts);\n        dav1d_free_aligned(f->ipred_edge[0]);\n        free(f->a);\n        free(f->tile);\n        free(f->lf.mask);\n        free(f->lf.lr_mask);\n        free(f->lf.level);\n        free(f->lf.tx_lpf_right_edge[0]);\n        free(f->lf.start_of_tile_row);\n        dav1d_refmvs_clear(&f->rf);\n        dav1d_free_aligned(f->lf.cdef_line_buf);\n        dav1d_free_aligned(f->lf.lr_line_buf);\n    }\n    dav1d_free_aligned(c->fc);\n    if (c->n_fc > 1 && c->frame_thread.out_delayed) {\n        for (unsigned n = 0; n < c->n_fc; n++)\n            if (c->frame_thread.out_delayed[n].p.frame_hdr)\n                dav1d_thread_picture_unref(&c->frame_thread.out_delayed[n]);\n        free(c->frame_thread.out_delayed);\n    }\n    for (int n = 0; n < c->n_tile_data; n++)\n        dav1d_data_unref_internal(&c->tile[n].data);\n    free(c->tile);\n    for (int n = 0; n < 8; n++) {\n        dav1d_cdf_thread_unref(&c->cdf[n]);\n        if (c->refs[n].p.p.frame_hdr)\n            dav1d_thread_picture_unref(&c->refs[n].p);\n        dav1d_ref_dec(&c->refs[n].refmvs);\n        dav1d_ref_dec(&c->refs[n].segmap);\n    }\n    dav1d_ref_dec(&c->seq_hdr_ref);\n    dav1d_ref_dec(&c->frame_hdr_ref);\n\n    dav1d_ref_dec(&c->mastering_display_ref);\n    dav1d_ref_dec(&c->content_light_ref);\n    dav1d_ref_dec(&c->itut_t35_ref);\n\n    dav1d_mem_pool_end(c->seq_hdr_pool);\n    dav1d_mem_pool_end(c->frame_hdr_pool);\n    dav1d_mem_pool_end(c->segmap_pool);\n    dav1d_mem_pool_end(c->refmvs_pool);\n    dav1d_mem_pool_end(c->cdf_pool);\n    dav1d_mem_pool_end(c->picture_pool);\n\n    dav1d_freep_aligned(c_out);\n}\nstatic void free_buffer(const uint8_t *const data, void *const user_data) {\n    struct pic_ctx_context *pic_ctx = user_data;\n    const int planes = pic_ctx->layout != DAV1D_PIXEL_LAYOUT_I400 ? 3 : 1;\n\n    for (int i = 0; i < planes; i++)\n        dav1d_ref_dec(&pic_ctx->plane_ref[i]);\n    free(pic_ctx);\n}\nstatic void free_plane_buffer(const uint8_t *const data, void *const user_data) {\n    struct plane_ctx_context *plane_ctx = user_data;\n\n    plane_ctx->allocator.release_picture_callback(&plane_ctx->pic,\n                                                  plane_ctx->allocator.cookie);\n    free(plane_ctx);\n}\nstatic int picture_alloc_with_edges(Dav1dContext *const c,\n                                    Dav1dPicture *const p,\n                                    const int w, const int h,\n                                    Dav1dSequenceHeader *const seq_hdr, Dav1dRef *const seq_hdr_ref,\n                                    Dav1dFrameHeader *const frame_hdr, Dav1dRef *const frame_hdr_ref,\n                                    Dav1dContentLightLevel *const content_light, Dav1dRef *const content_light_ref,\n                                    Dav1dMasteringDisplay *const mastering_display, Dav1dRef *const mastering_display_ref,\n                                    Dav1dITUTT35 *const itut_t35, Dav1dRef *const itut_t35_ref,\n                                    const int bpc,\n                                    const Dav1dDataProps *const props,\n                                    Dav1dPicAllocator *const p_allocator,\n                                    const size_t extra, void **const extra_ptr)\n{\n    if (p->data[0]) {\n        dav1d_log(c, \"Picture already allocated!\\n\");\n        return -1;\n    }\n    assert(bpc > 0 && bpc <= 16);\n\n    struct pic_ctx_context *pic_ctx = malloc(extra + sizeof(struct pic_ctx_context));\n    if (pic_ctx == NULL)\n        return DAV1D_ERR(ENOMEM);\n    memset(pic_ctx, 0, sizeof(struct pic_ctx_context));\n\n    p->p.w = w;\n    p->p.h = h;\n    p->seq_hdr = seq_hdr;\n    p->frame_hdr = frame_hdr;\n    p->p.layout = seq_hdr->layout;\n    p->p.bpc = bpc;\n    dav1d_data_props_set_defaults(&p->m);\n    const int res = p_allocator->alloc_picture_callback(p, p_allocator->cookie);\n    if (res < 0) {\n        free(pic_ctx);\n        return res;\n    }\n\n    pic_ctx->layout = p->p.layout;\n\n    if (!(p->ref = dav1d_ref_wrap(p->data[0], free_buffer, pic_ctx))) {\n        p_allocator->release_picture_callback(p, p_allocator->cookie);\n        free(pic_ctx);\n        dav1d_log(c, \"Failed to wrap picture: %s\\n\", strerror(errno));\n        return DAV1D_ERR(ENOMEM);\n    }\n\n    struct plane_ctx_context *plane_ctx = malloc(sizeof(struct plane_ctx_context));\n    if (plane_ctx == NULL){\n        dav1d_ref_dec(&p->ref);\n        p_allocator->release_picture_callback(p, p_allocator->cookie);\n        return DAV1D_ERR(ENOMEM);\n    }\n\n    plane_ctx->allocator = *p_allocator;\n    plane_ctx->pic = *p;\n\n    pic_ctx->plane_ref[0] = dav1d_ref_wrap(p->data[0], free_plane_buffer, plane_ctx);\n    if (!pic_ctx->plane_ref[0]) {\n        dav1d_ref_dec(&p->ref);\n        p_allocator->release_picture_callback(p, p_allocator->cookie);\n        free(plane_ctx);\n        dav1d_log(c, \"Failed to wrap picture plane: %s\\n\", strerror(errno));\n        return DAV1D_ERR(ENOMEM);\n    }\n\n    const int planes = p->p.layout != DAV1D_PIXEL_LAYOUT_I400 ? 3 : 1;\n    for (int i = 1; i < planes; i++) {\n        pic_ctx->plane_ref[i] = pic_ctx->plane_ref[0];\n        dav1d_ref_inc(pic_ctx->plane_ref[i]);\n    }\n\n    p->seq_hdr_ref = seq_hdr_ref;\n    if (seq_hdr_ref) dav1d_ref_inc(seq_hdr_ref);\n\n    p->frame_hdr_ref = frame_hdr_ref;\n    if (frame_hdr_ref) dav1d_ref_inc(frame_hdr_ref);\n\n    dav1d_picture_copy_props(p, content_light, content_light_ref,\n                             mastering_display, mastering_display_ref,\n                             itut_t35, itut_t35_ref, props);\n\n    if (extra && extra_ptr)\n        *extra_ptr = &pic_ctx->extra_ptr;\n\n    return 0;\n}\nvoid dav1d_picture_copy_props(Dav1dPicture *const p,\n                              Dav1dContentLightLevel *const content_light, Dav1dRef *const content_light_ref,\n                              Dav1dMasteringDisplay *const mastering_display, Dav1dRef *const mastering_display_ref,\n                              Dav1dITUTT35 *const itut_t35, Dav1dRef *const itut_t35_ref,\n                              const Dav1dDataProps *const props)\n{\n    dav1d_data_props_copy(&p->m, props);\n\n    dav1d_ref_dec(&p->content_light_ref);\n    p->content_light_ref = content_light_ref;\n    p->content_light = content_light;\n    if (content_light_ref) dav1d_ref_inc(content_light_ref);\n\n    dav1d_ref_dec(&p->mastering_display_ref);\n    p->mastering_display_ref = mastering_display_ref;\n    p->mastering_display = mastering_display;\n    if (mastering_display_ref) dav1d_ref_inc(mastering_display_ref);\n\n    dav1d_ref_dec(&p->itut_t35_ref);\n    p->itut_t35_ref = itut_t35_ref;\n    p->itut_t35 = itut_t35;\n    if (itut_t35_ref) dav1d_ref_inc(itut_t35_ref);\n}\n\nint dav1d_picture_alloc_copy(Dav1dContext *const c, Dav1dPicture *const dst, const int w,\n                             const Dav1dPicture *const src)\n{\n    struct pic_ctx_context *const pic_ctx = src->ref->user_data;\n    struct plane_ctx_context *const plane_ctx = pic_ctx->plane_ref[0]->user_data;\n    const int res = picture_alloc_with_edges(c, dst, w, src->p.h,\n                                             src->seq_hdr, src->seq_hdr_ref,\n                                             src->frame_hdr, src->frame_hdr_ref,\n                                             src->content_light, src->content_light_ref,\n                                             src->mastering_display, src->mastering_display_ref,\n                                             src->itut_t35, src->itut_t35_ref,\n                                             src->p.bpc, &src->m, &plane_ctx->allocator,\n                                             0, NULL);\n    return res;\n}\n",
    "target": 0,
    "idx": 2057927
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "ZEND_API zend_result ZEND_FASTCALL concat_function(zval *result, zval *op1, zval *op2) /* {{{ */\n{\n\tzval *orig_op1 = op1;\n\tzend_string *op1_string, *op2_string;\n\tbool free_op1_string = false;\n\tbool free_op2_string = false;\n\n\tdo {\n\t\tif (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {\n\t\t\top1_string = Z_STR_P(op1);\n\t\t} else {\n\t \t\tif (Z_ISREF_P(op1)) {\n\t \t\t\top1 = Z_REFVAL_P(op1);\n\t\t\t\tif (Z_TYPE_P(op1) == IS_STRING) {\n\t\t\t\t\top1_string = Z_STR_P(op1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t \t\t}\n\t\t\tZEND_TRY_BINARY_OBJECT_OPERATION(ZEND_CONCAT);\n\t\t\top1_string = zval_get_string_func(op1);\n\t\t\tif (UNEXPECTED(EG(exception))) {\n\t\t\t\tzend_string_release(op1_string);\n\t\t\t\tif (orig_op1 != result) {\n\t\t\t\t\tZVAL_UNDEF(result);\n\t\t\t\t}\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tfree_op1_string = true;\n\t\t\tif (result == op1) {\n\t\t\t\tif (UNEXPECTED(op1 == op2)) {\n\t\t\t\t\top2_string = op1_string;\n\t\t\t\t\tgoto has_op2_string;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} while (0);\n\tdo {\n\t\tif (EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {\n\t\t\top2_string = Z_STR_P(op2);\n\t\t} else {\n\t\t\tif (Z_ISREF_P(op2)) {\n\t\t\t\top2 = Z_REFVAL_P(op2);\n\t\t\t\tif (Z_TYPE_P(op2) == IS_STRING) {\n\t\t\t\t\top2_string = Z_STR_P(op2);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* hold an additional reference because a userland function could free this */\n\t\t\tif (!free_op1_string) {\n\t\t\t\top1_string = zend_string_copy(op1_string);\n\t\t\t\tfree_op1_string = true;\n\t\t\t}\n\t\t\tZEND_TRY_BINARY_OP2_OBJECT_OPERATION(ZEND_CONCAT);\n\t\t\top2_string = zval_get_string_func(op2);\n\t\t\tif (UNEXPECTED(EG(exception))) {\n\t\t\t\tzend_string_release(op1_string);\n\t\t\t\tzend_string_release(op2_string);\n\t\t\t\tif (orig_op1 != result) {\n\t\t\t\t\tZVAL_UNDEF(result);\n\t\t\t\t}\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tfree_op2_string = true;\n\t\t}\n\t} while (0);\n\nhas_op2_string:;\n\tif (UNEXPECTED(ZSTR_LEN(op1_string) == 0)) {\n\t\tif (EXPECTED(result != op2 || Z_TYPE_P(result) != IS_STRING)) {\n\t\t\tif (result == orig_op1) {\n\t\t\t\ti_zval_ptr_dtor(result);\n\t\t\t}\n\t\t\tif (free_op2_string) {\n\t\t\t\t/* transfer ownership of op2_string */\n\t\t\t\tZVAL_STR(result, op2_string);\n\t\t\t\tfree_op2_string = false;\n\t\t\t} else {\n\t\t\t\tZVAL_STR_COPY(result, op2_string);\n\t\t\t}\n\t\t}\n\t} else if (UNEXPECTED(ZSTR_LEN(op2_string) == 0)) {\n\t\tif (EXPECTED(result != op1 || Z_TYPE_P(result) != IS_STRING)) {\n\t\t\tif (result == orig_op1) {\n\t\t\t\ti_zval_ptr_dtor(result);\n\t\t\t}\n\t\t\tif (free_op1_string) {\n\t\t\t\t/* transfer ownership of op1_string */\n\t\t\t\tZVAL_STR(result, op1_string);\n\t\t\t\tfree_op1_string = false;\n\t\t\t} else {\n\t\t\t\tZVAL_STR_COPY(result, op1_string);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tsize_t op1_len = ZSTR_LEN(op1_string);\n\t\tsize_t op2_len = ZSTR_LEN(op2_string);\n\t\tsize_t result_len = op1_len + op2_len;\n\t\tzend_string *result_str;\n\t\tuint32_t flags = ZSTR_GET_COPYABLE_CONCAT_PROPERTIES_BOTH(op1_string, op2_string);\n\n\t\tif (UNEXPECTED(op1_len > ZSTR_MAX_LEN - op2_len)) {\n\t\t\tif (free_op1_string) zend_string_release(op1_string);\n\t\t\tif (free_op2_string) zend_string_release(op2_string);\n\t\t\tzend_throw_error(NULL, \"String size overflow\");\n\t\t\tif (orig_op1 != result) {\n\t\t\t\tZVAL_UNDEF(result);\n\t\t\t}\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\tif (result == op1) {\n\t\t\t/* special case, perform operations on result */\n\t\t\tresult_str = zend_string_extend(op1_string, result_len, 0);\n\t\t\t/* Free result after zend_string_extend(), as it may throw an out-of-memory error. If we\n\t\t\t * free it before we would leave the released variable on the stack with shutdown trying\n\t\t\t * to free it again. */\n\t\t\tif (free_op1_string) {\n\t\t\t\t/* op1_string will be used as the result, so we should not free it */\n\t\t\t\ti_zval_ptr_dtor(result);\n\t\t\t\tfree_op1_string = false;\n\t\t\t}\n\t\t\t/* account for the case where result_str == op1_string == op2_string and the realloc is done */\n\t\t\tif (op1_string == op2_string) {\n\t\t\t\tif (free_op2_string) {\n\t\t\t\t\tzend_string_release(op2_string);\n\t\t\t\t\tfree_op2_string = false;\n\t\t\t\t}\n\t\t\t\top2_string = result_str;\n\t\t\t}\n\t\t} else {\n\t\t\tresult_str = zend_string_alloc(result_len, 0);\n\t\t\tmemcpy(ZSTR_VAL(result_str), ZSTR_VAL(op1_string), op1_len);\n\t\t\tif (result == orig_op1) {\n\t\t\t\ti_zval_ptr_dtor(result);\n\t\t\t}\n\t\t}\n\t\tGC_ADD_FLAGS(result_str, flags);\n\n\t\tZVAL_NEW_STR(result, result_str);\n\t\tmemcpy(ZSTR_VAL(result_str) + op1_len, ZSTR_VAL(op2_string), op2_len);\n\t\tZSTR_VAL(result_str)[result_len] = '\\0';\n\t}\n\n\tif (free_op1_string) zend_string_release(op1_string);\n\tif (free_op2_string) zend_string_release(op2_string);\n\n\treturn SUCCESS;\n}\n",
    "target": 0,
    "idx": 2059072
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "static int\nhtmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n    const unsigned char *cur;\n    unsigned char c;\n    unsigned int val;\n\n    if (ctxt->instate == XML_PARSER_EOF)\n\treturn(0);\n\n    if (ctxt->token != 0) {\n\t*len = 0;\n\treturn(ctxt->token);\n    }\n\n    if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK) {\n        xmlParserGrow(ctxt);\n        if (ctxt->instate == XML_PARSER_EOF)\n            return(0);\n    }\n\n    if ((ctxt->input->flags & XML_INPUT_HAS_ENCODING) == 0) {\n        xmlChar * guess;\n        xmlCharEncodingHandlerPtr handler;\n\n        /*\n         * Assume it's a fixed length encoding (1) with\n         * a compatible encoding for the ASCII set, since\n         * HTML constructs only use < 128 chars\n         */\n        if (*ctxt->input->cur < 0x80) {\n            *len = 1;\n            if ((*ctxt->input->cur == 0) &&\n                (ctxt->input->cur < ctxt->input->end)) {\n                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n                                \"Char 0x%X out of allowed range\\n\", 0);\n                return(' ');\n            }\n            return(*ctxt->input->cur);\n        }\n\n        /*\n         * Humm this is bad, do an automatic flow conversion\n         */\n        guess = htmlFindEncoding(ctxt);\n        if (guess == NULL) {\n            xmlSwitchEncoding(ctxt, XML_CHAR_ENCODING_8859_1);\n        } else {\n            handler = xmlFindCharEncodingHandler((const char *) guess);\n            if (handler != NULL) {\n                /*\n                 * Don't use UTF-8 encoder which isn't required and\n                 * can produce invalid UTF-8.\n                 */\n                if (!xmlStrEqual(BAD_CAST handler->name, BAD_CAST \"UTF-8\"))\n                    xmlSwitchToEncoding(ctxt, handler);\n            } else {\n                htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n                             \"Unsupported encoding %s\", guess, NULL);\n            }\n            xmlFree(guess);\n        }\n        ctxt->input->flags |= XML_INPUT_HAS_ENCODING;\n    }\n\n    /*\n     * We are supposed to handle UTF8, check it's valid\n     * From rfc2044: encoding of the Unicode values on UTF-8:\n     *\n     * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n     * 0000 0000-0000 007F   0xxxxxxx\n     * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n     * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n     *\n     * Check for the 0x110000 limit too\n     */\n    cur = ctxt->input->cur;\n    c = *cur;\n    if (c & 0x80) {\n        size_t avail;\n\n        if ((c & 0x40) == 0)\n            goto encoding_error;\n\n        avail = ctxt->input->end - ctxt->input->cur;\n\n        if ((avail < 2) || ((cur[1] & 0xc0) != 0x80))\n            goto encoding_error;\n        if ((c & 0xe0) == 0xe0) {\n            if ((avail < 3) || ((cur[2] & 0xc0) != 0x80))\n                goto encoding_error;\n            if ((c & 0xf0) == 0xf0) {\n                if (((c & 0xf8) != 0xf0) ||\n                    (avail < 4) || ((cur[3] & 0xc0) != 0x80))\n                    goto encoding_error;\n                /* 4-byte code */\n                *len = 4;\n                val = (cur[0] & 0x7) << 18;\n                val |= (cur[1] & 0x3f) << 12;\n                val |= (cur[2] & 0x3f) << 6;\n                val |= cur[3] & 0x3f;\n                if (val < 0x10000)\n                    goto encoding_error;\n            } else {\n              /* 3-byte code */\n                *len = 3;\n                val = (cur[0] & 0xf) << 12;\n                val |= (cur[1] & 0x3f) << 6;\n                val |= cur[2] & 0x3f;\n                if (val < 0x800)\n                    goto encoding_error;\n            }\n        } else {\n          /* 2-byte code */\n            *len = 2;\n            val = (cur[0] & 0x1f) << 6;\n            val |= cur[1] & 0x3f;\n            if (val < 0x80)\n                goto encoding_error;\n        }\n        if (!IS_CHAR(val)) {\n            htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n                            \"Char 0x%X out of allowed range\\n\", val);\n        }\n        return(val);\n    } else {\n        if ((*ctxt->input->cur == 0) &&\n            (ctxt->input->cur < ctxt->input->end)) {\n            htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n                            \"Char 0x%X out of allowed range\\n\", 0);\n            *len = 1;\n            return(' ');\n        }\n        /* 1-byte code */\n        *len = 1;\n        return(*ctxt->input->cur);\n    }\n\nencoding_error:\n    {\n        char buffer[150];\n\n\tif (ctxt->input->end - ctxt->input->cur >= 4) {\n\t    snprintf(buffer, 149, \"Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n\",\n\t\t\t    ctxt->input->cur[0], ctxt->input->cur[1],\n\t\t\t    ctxt->input->cur[2], ctxt->input->cur[3]);\n\t} else {\n\t    snprintf(buffer, 149, \"Bytes: 0x%02X\\n\", ctxt->input->cur[0]);\n\t}\n\thtmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n\t\t     \"Input is not proper UTF-8, indicate encoding !\\n\",\n\t\t     BAD_CAST buffer, NULL);\n    }\n\n    if ((ctxt->input->flags & XML_INPUT_HAS_ENCODING) == 0)\n        xmlSwitchEncoding(ctxt, XML_CHAR_ENCODING_8859_1);\n    *len = 1;\n    return(*ctxt->input->cur);\n}\n",
    "target": 0,
    "idx": 2061337
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "static bool\nelf64_vms_close_and_cleanup (bfd *abfd)\n{\n  bool ret = true;\n  if (bfd_get_format (abfd) == bfd_object\n      && bfd_write_p (abfd))\n    {\n      long isize;\n\n      /* Pad to 8 byte boundary for IPF/VMS.  */\n      isize = bfd_get_size (abfd);\n      if ((isize & 7) != 0)\n\t{\n\t  unsigned int ishort = 8 - (isize & 7);\n\t  uint64_t pad = 0;\n\n\t  if (bfd_seek (abfd, isize, SEEK_SET) != 0\n\t      || bfd_write (&pad, ishort, abfd) != ishort)\n\t    ret = false;\n\t}\n    }\n\n  return _bfd_generic_close_and_cleanup (abfd) && ret;\n}\n\nbool\nbfd_close_all_done (bfd *abfd)\n{\n  bool ret = BFD_SEND (abfd, _close_and_cleanup, (abfd));\n\n  if (abfd->iovec != NULL)\n    ret &= abfd->iovec->bclose (abfd) == 0;\n\n  if (ret)\n    _maybe_make_executable (abfd);\n\n  _bfd_delete_bfd (abfd);\n  free (_bfd_error_buf);\n  _bfd_error_buf = NULL;\n\n  return ret;\n",
    "target": 0,
    "idx": 2061433
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "static int\nauthentic_emu_update_tokeninfo(struct sc_profile *profile, struct sc_pkcs15_card *p15card,\n\t\tstruct sc_pkcs15_tokeninfo *tinfo)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_file *file = NULL;\n\tstruct sc_path path;\n\tunsigned char buffer[8];\n\tint rv,len;\n\n\tsc_format_path(AUTHENTIC_CACHE_TIMESTAMP_PATH, &path);\n\trv = sc_select_file(p15card->card, &path, &file);\n\tif (!rv) {\n\t\trv = sc_get_challenge(p15card->card, buffer, sizeof(buffer));\n\t\tif (rv < 0) {\n\t\t\tsc_file_free(file);\n\t\t\tLOG_TEST_RET(ctx, rv, \"Get challenge error\");\n\t\t}\n\n\t\tlen = file->size > sizeof(buffer) ? sizeof(buffer) : file->size;\n\t\trv = sc_update_binary(p15card->card, 0, buffer, len, 0);\n\t\tsc_file_free(file);\n\t\tLOG_TEST_RET(ctx, rv, \"Update binary error\");\n\t}\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n",
    "target": 0,
    "idx": 2064898
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "static void\nio_reinit (bfd *abfd, struct bfd_preserve *preserve)\n{\n  if (abfd->iovec != preserve->iovec)\n    {\n      /* Handle file backed to in-memory transition.  bfd_cache_close\n\t won't do anything unless abfd->iovec is the cache_iovec.\n\t Don't be tempted to call iovec->bclose here.  We don't want\n\t to call memory_bclose, which would free the bim.  The bim\n\t must be kept if bfd_check_format_matches is going to decide\n\t later that the PE format needing it is in fact the correct\n\t target match.  */\n      bfd_cache_close (abfd);\n      abfd->iovec = preserve->iovec;\n      abfd->iostream = preserve->iostream;\n\n      /* Handle in-memory to file backed transition.  */\n      if ((abfd->flags & BFD_CLOSED_BY_CACHE) != 0\n\t  && (abfd->flags & BFD_IN_MEMORY) != 0\n\t  && (preserve->flags & BFD_CLOSED_BY_CACHE) == 0\n\t  && (preserve->flags & BFD_IN_MEMORY) == 0)\n\tbfd_open_file (abfd);\n    }\n  abfd->flags = preserve->flags;\n}\nstatic void\n_bfd_delete_bfd (bfd *abfd)\n{\n  /* Give the target _bfd_free_cached_info a chance to free memory.  */\n  if (abfd->memory && abfd->xvec)\n    bfd_free_cached_info (abfd);\n\n  /* The target _bfd_free_cached_info may not have done anything..  */\n  if (abfd->memory)\n    {\n      bfd_hash_table_free (&abfd->section_htab);\n      objalloc_free ((struct objalloc *) abfd->memory);\n    }\n  else\n    free ((char *) bfd_get_filename (abfd));\n\n  free (abfd->arelt_data);\n  free (abfd);\n}\n",
    "target": 0,
    "idx": 2065104
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "static void\nio_reinit (bfd *abfd, struct bfd_preserve *preserve)\n{\n  if (abfd->iovec != preserve->iovec)\n    {\n      /* Handle file backed to in-memory transition.  bfd_cache_close\n\t won't do anything unless abfd->iovec is the cache_iovec.\n\t Don't be tempted to call iovec->bclose here.  We don't want\n\t to call memory_bclose, which would free the bim.  The bim\n\t must be kept if bfd_check_format_matches is going to decide\n\t later that the PE format needing it is in fact the correct\n\t target match.  */\n      bfd_cache_close (abfd);\n      abfd->iovec = preserve->iovec;\n      abfd->iostream = preserve->iostream;\n\n      /* Handle in-memory to file backed transition.  */\n      if ((abfd->flags & BFD_CLOSED_BY_CACHE) != 0\n\t  && (abfd->flags & BFD_IN_MEMORY) != 0\n\t  && (preserve->flags & BFD_CLOSED_BY_CACHE) == 0\n\t  && (preserve->flags & BFD_IN_MEMORY) == 0)\n\tbfd_open_file (abfd);\n    }\n  abfd->flags = preserve->flags;\n}\nstatic void\n_bfd_delete_bfd (bfd *abfd)\n{\n  /* Give the target _bfd_free_cached_info a chance to free memory.  */\n  if (abfd->memory && abfd->xvec)\n    bfd_free_cached_info (abfd);\n\n  /* The target _bfd_free_cached_info may not have done anything..  */\n  if (abfd->memory)\n    {\n      bfd_hash_table_free (&abfd->section_htab);\n      objalloc_free ((struct objalloc *) abfd->memory);\n    }\n  else\n    free ((char *) bfd_get_filename (abfd));\n\n  free (abfd->arelt_data);\n  free (abfd);\n}\n",
    "target": 0,
    "idx": 2065105
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "static void\nio_reinit (bfd *abfd, struct bfd_preserve *preserve)\n{\n  if (abfd->iovec != preserve->iovec)\n    {\n      /* Handle file backed to in-memory transition.  bfd_cache_close\n\t won't do anything unless abfd->iovec is the cache_iovec.\n\t Don't be tempted to call iovec->bclose here.  We don't want\n\t to call memory_bclose, which would free the bim.  The bim\n\t must be kept if bfd_check_format_matches is going to decide\n\t later that the PE format needing it is in fact the correct\n\t target match.  */\n      bfd_cache_close (abfd);\n      abfd->iovec = preserve->iovec;\n      abfd->iostream = preserve->iostream;\n\n      /* Handle in-memory to file backed transition.  */\n      if ((abfd->flags & BFD_CLOSED_BY_CACHE) != 0\n\t  && (abfd->flags & BFD_IN_MEMORY) != 0\n\t  && (preserve->flags & BFD_CLOSED_BY_CACHE) == 0\n\t  && (preserve->flags & BFD_IN_MEMORY) == 0)\n\tbfd_open_file (abfd);\n    }\n  abfd->flags = preserve->flags;\n}\nstatic void\n_bfd_delete_bfd (bfd *abfd)\n{\n  /* Give the target _bfd_free_cached_info a chance to free memory.  */\n  if (abfd->memory && abfd->xvec)\n    bfd_free_cached_info (abfd);\n\n  /* The target _bfd_free_cached_info may not have done anything..  */\n  if (abfd->memory)\n    {\n      bfd_hash_table_free (&abfd->section_htab);\n      objalloc_free ((struct objalloc *) abfd->memory);\n    }\n  else\n    free ((char *) bfd_get_filename (abfd));\n\n  free (abfd->arelt_data);\n  free (abfd);\n}\n",
    "target": 0,
    "idx": 2065108
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "static int\niasecc_delete_file(struct sc_card *card, const struct sc_path *path)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tconst struct sc_acl_entry *entry = NULL;\n\tstruct sc_apdu apdu;\n\tstruct sc_file *file = NULL;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_print_cache(card);\n\n\trv = iasecc_select_file(card, path, &file);\n\tif (rv == SC_ERROR_FILE_NOT_FOUND)\n\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\tLOG_TEST_RET(ctx, rv, \"Cannot select file to delete\");\n\n\tentry = sc_file_get_acl_entry(file, SC_AC_OP_DELETE);\n\tif (!entry)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_OBJECT_NOT_FOUND, \"Cannot delete file: no 'DELETE' acl\");\n\n\tsc_log(ctx, \"DELETE method/reference %X/%X\", entry->method, entry->key_ref);\n\tif (entry->method == SC_AC_SCB && (entry->key_ref & IASECC_SCB_METHOD_SM))   {\n\t\tunsigned char se_num = entry->key_ref & IASECC_SCB_METHOD_MASK_REF;\n\t\trv = iasecc_sm_delete_file(card, se_num, file->id);\n\t\tsc_file_free(file);\n\t}\n\telse   {\n\t\tsc_file_free(file);\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_1, 0xE4, 0x00, 0x00);\n\n\t\trv = sc_transmit_apdu(card, &apdu);\n\t\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\t\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\tLOG_TEST_RET(ctx, rv, \"Delete file failed\");\n\n\t\tif (card->cache.valid) {\n\t\t\tsc_file_free(card->cache.current_ef);\n\t\t}\n\t\tcard->cache.current_ef = NULL;\n\t}\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n",
    "target": 0,
    "idx": 2065684
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "static int\nxmlTextReaderValidateEntity(xmlTextReaderPtr reader) {\n    xmlNodePtr oldnode = reader->node;\n    xmlNodePtr node = reader->node;\n\n    do {\n\tif (node->type == XML_ENTITY_REF_NODE) {\n\t    if ((node->children != NULL) &&\n\t\t(node->children->type == XML_ENTITY_DECL) &&\n\t\t(node->children->children != NULL)) {\n\t\tif (xmlTextReaderEntPush(reader, node) < 0) {\n                    if (node == oldnode)\n                        break;\n                    goto skip_children;\n                }\n\t\tnode = node->children->children;\n\t\tcontinue;\n\t    } else {\n\t\t/*\n\t\t * The error has probably been raised already.\n\t\t */\n\t\tif (node == oldnode)\n\t\t    break;\n                goto skip_children;\n\t    }\n#ifdef LIBXML_REGEXP_ENABLED\n\t} else if (node->type == XML_ELEMENT_NODE) {\n\t    reader->node = node;\n\t    if (xmlTextReaderValidatePush(reader) < 0)\n                return(-1);\n\t} else if ((node->type == XML_TEXT_NODE) ||\n\t\t   (node->type == XML_CDATA_SECTION_NODE)) {\n            xmlTextReaderValidateCData(reader, node->content,\n\t                               xmlStrlen(node->content));\n#endif\n\t}\n\n\t/*\n\t * go to next node\n\t */\n\tif (node->children != NULL) {\n\t    node = node->children;\n\t    continue;\n\t} else if (node->type == XML_ELEMENT_NODE) {\n\t    if (xmlTextReaderValidatePop(reader) < 0)\n                return(-1);\n\t}\nskip_children:\n\tif (node->next != NULL) {\n\t    node = node->next;\n\t    continue;\n\t}\n\tdo {\n\t    node = node->parent;\n\t    if (node->type == XML_ELEMENT_NODE) {\n\t        xmlNodePtr tmp;\n\t\tif (reader->entNr == 0) {\n\t\t    while ((tmp = node->last) != NULL) {\n\t\t\tif ((tmp->extra & NODE_IS_PRESERVED) == 0) {\n\t\t\t    xmlUnlinkNode(tmp);\n\t\t\t    xmlTextReaderFreeNode(reader, tmp);\n\t\t\t} else\n\t\t\t    break;\n\t\t    }\n\t\t}\n\t\treader->node = node;\n\t\tif (xmlTextReaderValidatePop(reader) < 0)\n                    return(-1);\n\t    }\n\t    if ((node->type == XML_ENTITY_DECL) &&\n\t\t(reader->ent != NULL) && (reader->ent->children == node)) {\n\t\tnode = xmlTextReaderEntPop(reader);\n\t    }\n\t    if (node == oldnode)\n\t\tbreak;\n\t    if (node->next != NULL) {\n\t\tnode = node->next;\n\t\tbreak;\n\t    }\n\t} while ((node != NULL) && (node != oldnode));\n    } while ((node != NULL) && (node != oldnode));\n    reader->node = oldnode;\n\n    return(0);\n}\nint\nxmlTextReaderRead(xmlTextReaderPtr reader) {\n    int val, olddepth = 0;\n    xmlTextReaderState oldstate = XML_TEXTREADER_START;\n    xmlNodePtr oldnode = NULL;\n\n\n    if (reader == NULL)\n\treturn(-1);\n    reader->curnode = NULL;\n    if (reader->doc != NULL)\n        return(xmlTextReaderReadTree(reader));\n    if (reader->ctxt == NULL)\n\treturn(-1);\n\n    if (reader->mode == XML_TEXTREADER_MODE_INITIAL) {\n\treader->mode = XML_TEXTREADER_MODE_INTERACTIVE;\n\t/*\n\t * Initial state\n\t */\n\tdo {\n\t    val = xmlTextReaderPushData(reader);\n\t\tif (val < 0){\n\t\t\treader->mode = XML_TEXTREADER_MODE_ERROR;\n\t\t\treader->state = XML_TEXTREADER_ERROR;\n\t\treturn(-1);\n\t\t}\n\t} while ((reader->ctxt->node == NULL) &&\n\t\t ((reader->mode != XML_TEXTREADER_MODE_EOF) &&\n\t\t  (reader->state != XML_TEXTREADER_DONE)));\n\tif (reader->ctxt->node == NULL) {\n\t    if (reader->ctxt->myDoc != NULL) {\n\t\treader->node = reader->ctxt->myDoc->children;\n\t    }\n\t    if (reader->node == NULL){\n\t\t\treader->mode = XML_TEXTREADER_MODE_ERROR;\n\t\t\treader->state = XML_TEXTREADER_ERROR;\n\t\treturn(-1);\n\t\t}\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t} else {\n\t    if (reader->ctxt->myDoc != NULL) {\n\t\treader->node = reader->ctxt->myDoc->children;\n\t    }\n\t    if (reader->node == NULL)\n\t\treader->node = reader->ctxt->nodeTab[0];\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t}\n\treader->depth = 0;\n\treader->ctxt->parseMode = XML_PARSE_READER;\n\tgoto node_found;\n    }\n    oldstate = reader->state;\n    olddepth = reader->ctxt->nodeNr;\n    oldnode = reader->node;\n\nget_next_node:\n    if (reader->node == NULL) {\n\tif (reader->mode == XML_TEXTREADER_MODE_EOF)\n\t    return(0);\n\telse\n\t    return(-1);\n    }\n\n    /*\n     * If we are not backtracking on ancestors or examined nodes,\n     * that the parser didn't finished or that we aren't at the end\n     * of stream, continue processing.\n     */\n    while ((reader->node != NULL) && (reader->node->next == NULL) &&\n\t   (reader->ctxt->nodeNr == olddepth) &&\n           ((oldstate == XML_TEXTREADER_BACKTRACK) ||\n            (reader->node->children == NULL) ||\n\t    (reader->node->type == XML_ENTITY_REF_NODE) ||\n\t    ((reader->node->children != NULL) &&\n\t     (reader->node->children->type == XML_TEXT_NODE) &&\n\t     (reader->node->children->next == NULL)) ||\n\t    (reader->node->type == XML_DTD_NODE) ||\n\t    (reader->node->type == XML_DOCUMENT_NODE) ||\n\t    (reader->node->type == XML_HTML_DOCUMENT_NODE)) &&\n\t   ((reader->ctxt->node == NULL) ||\n\t    (reader->ctxt->node == reader->node) ||\n\t    (reader->ctxt->node == reader->node->parent)) &&\n\t   (reader->ctxt->instate != XML_PARSER_EOF) &&\n\t   (PARSER_STOPPED(reader->ctxt) == 0)) {\n\tval = xmlTextReaderPushData(reader);\n\tif (val < 0)\n\t    return(-1);\n\tif (reader->node == NULL)\n\t    goto node_end;\n    }\n    if (oldstate != XML_TEXTREADER_BACKTRACK) {\n\tif ((reader->node->children != NULL) &&\n\t    (reader->node->type != XML_ENTITY_REF_NODE) &&\n\t    (reader->node->type != XML_XINCLUDE_START) &&\n\t    (reader->node->type != XML_DTD_NODE)) {\n\t    reader->node = reader->node->children;\n\t    reader->depth++;\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t    goto node_found;\n\t}\n    }\n    if (reader->node->next != NULL) {\n\tif ((oldstate == XML_TEXTREADER_ELEMENT) &&\n            (reader->node->type == XML_ELEMENT_NODE) &&\n\t    (reader->node->children == NULL) &&\n\t    ((reader->node->extra & NODE_IS_EMPTY) == 0)\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    && (reader->in_xinclude <= 0)\n#endif\n\t    ) {\n\t    reader->state = XML_TEXTREADER_END;\n\t    goto node_found;\n\t}\n#ifdef LIBXML_REGEXP_ENABLED\n\tif ((reader->validate) &&\n\t    (reader->node->type == XML_ELEMENT_NODE))\n\t    if (xmlTextReaderValidatePop(reader) < 0)\n                return(-1);\n#endif /* LIBXML_REGEXP_ENABLED */\n        if ((reader->preserves > 0) &&\n\t    (reader->node->extra & NODE_IS_SPRESERVED))\n\t    reader->preserves--;\n\treader->node = reader->node->next;\n\treader->state = XML_TEXTREADER_ELEMENT;\n\n\t/*\n\t * Cleanup of the old node\n\t */\n\tif ((reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    (reader->in_xinclude == 0) &&\n#endif\n\t    (reader->entNr == 0) &&\n\t    (reader->node->prev != NULL) &&\n            (reader->node->prev->type != XML_DTD_NODE)) {\n\t    xmlNodePtr tmp = reader->node->prev;\n\t    if ((tmp->extra & NODE_IS_PRESERVED) == 0) {\n                if (oldnode == tmp)\n                    oldnode = NULL;\n\t\txmlUnlinkNode(tmp);\n\t\txmlTextReaderFreeNode(reader, tmp);\n\t    }\n\t}\n\n\tgoto node_found;\n    }\n    if ((oldstate == XML_TEXTREADER_ELEMENT) &&\n\t(reader->node->type == XML_ELEMENT_NODE) &&\n\t(reader->node->children == NULL) &&\n\t((reader->node->extra & NODE_IS_EMPTY) == 0)) {;\n\treader->state = XML_TEXTREADER_END;\n\tgoto node_found;\n    }\n#ifdef LIBXML_REGEXP_ENABLED\n    if ((reader->validate != XML_TEXTREADER_NOT_VALIDATE) &&\n        (reader->node->type == XML_ELEMENT_NODE)) {\n        if (xmlTextReaderValidatePop(reader) < 0)\n            return(-1);\n    }\n#endif /* LIBXML_REGEXP_ENABLED */\n    if ((reader->preserves > 0) &&\n\t(reader->node->extra & NODE_IS_SPRESERVED))\n\treader->preserves--;\n    reader->node = reader->node->parent;\n    if ((reader->node == NULL) ||\n\t(reader->node->type == XML_DOCUMENT_NODE) ||\n\t(reader->node->type == XML_HTML_DOCUMENT_NODE)) {\n\tif (reader->mode != XML_TEXTREADER_MODE_EOF) {\n\t    val = xmlParseChunk(reader->ctxt, \"\", 0, 1);\n\t    reader->state = XML_TEXTREADER_DONE;\n\t    if (val != 0)\n\t        return(-1);\n\t}\n\treader->node = NULL;\n\treader->depth = -1;\n\n\t/*\n\t * Cleanup of the old node\n\t */\n\tif ((oldnode != NULL) && (reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    (reader->in_xinclude == 0) &&\n#endif\n\t    (reader->entNr == 0) &&\n\t    (oldnode->type != XML_DTD_NODE) &&\n\t    ((oldnode->extra & NODE_IS_PRESERVED) == 0)) {\n\t    xmlUnlinkNode(oldnode);\n\t    xmlTextReaderFreeNode(reader, oldnode);\n\t}\n\n\tgoto node_end;\n    }\n    if ((reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n        (reader->in_xinclude == 0) &&\n#endif\n\t(reader->entNr == 0) &&\n        (reader->node->last != NULL) &&\n        ((reader->node->last->extra & NODE_IS_PRESERVED) == 0)) {\n\txmlNodePtr tmp = reader->node->last;\n\txmlUnlinkNode(tmp);\n\txmlTextReaderFreeNode(reader, tmp);\n    }\n    reader->depth--;\n    reader->state = XML_TEXTREADER_BACKTRACK;\n\nnode_found:\n    /*\n     * If we are in the middle of a piece of CDATA make sure it's finished\n     */\n    if ((reader->node != NULL) &&\n        (reader->node->next == NULL) &&\n        ((reader->node->type == XML_TEXT_NODE) ||\n\t (reader->node->type == XML_CDATA_SECTION_NODE))) {\n            if (xmlTextReaderExpand(reader) == NULL)\n\t        return -1;\n    }\n\n#ifdef LIBXML_XINCLUDE_ENABLED\n    /*\n     * Handle XInclude if asked for\n     */\n    if ((reader->xinclude) && (reader->in_xinclude == 0) &&\n        (reader->state != XML_TEXTREADER_BACKTRACK) &&\n        (reader->node != NULL) &&\n\t(reader->node->type == XML_ELEMENT_NODE) &&\n\t(reader->node->ns != NULL) &&\n\t((xmlStrEqual(reader->node->ns->href, XINCLUDE_NS)) ||\n\t (xmlStrEqual(reader->node->ns->href, XINCLUDE_OLD_NS)))) {\n\tif (reader->xincctxt == NULL) {\n\t    reader->xincctxt = xmlXIncludeNewContext(reader->ctxt->myDoc);\n            if (reader->xincctxt == NULL) {\n                xmlTextReaderErrMemory(reader);\n                return(-1);\n            }\n\t    xmlXIncludeSetFlags(reader->xincctxt,\n\t                        reader->parserFlags & (~XML_PARSE_NOXINCNODE));\n            xmlXIncludeSetStreamingMode(reader->xincctxt, 1);\n            if ((reader->errorFunc != NULL) || (reader->sErrorFunc != NULL))\n                xmlXIncludeSetErrorHandler(reader->xincctxt,\n                        xmlTextReaderStructuredRelay, reader);\n\t}\n\t/*\n\t * expand that node and process it\n\t */\n\tif (xmlTextReaderExpand(reader) == NULL)\n\t    return(-1);\n        if (xmlXIncludeProcessNode(reader->xincctxt, reader->node) < 0) {\n            int err = xmlXIncludeGetLastError(reader->xincctxt);\n\n            if (err == XML_ERR_NO_MEMORY)\n                xmlTextReaderErrMemory(reader);\n            return(-1);\n        }\n    }\n    if ((reader->node != NULL) && (reader->node->type == XML_XINCLUDE_START)) {\n        reader->in_xinclude++;\n\tgoto get_next_node;\n    }\n    if ((reader->node != NULL) && (reader->node->type == XML_XINCLUDE_END)) {\n        reader->in_xinclude--;\n\tgoto get_next_node;\n    }\n#endif\n    /*\n     * Handle entities enter and exit when in entity replacement mode\n     */\n    if ((reader->node != NULL) &&\n\t(reader->node->type == XML_ENTITY_REF_NODE) &&\n\t(reader->ctxt != NULL) && (reader->ctxt->replaceEntities == 1)) {\n\tif ((reader->node->children != NULL) &&\n\t    (reader->node->children->type == XML_ENTITY_DECL) &&\n\t    (reader->node->children->children != NULL)) {\n\t    if (xmlTextReaderEntPush(reader, reader->node) < 0)\n                goto get_next_node;\n\t    reader->node = reader->node->children->children;\n\t}\n#ifdef LIBXML_REGEXP_ENABLED\n    } else if ((reader->node != NULL) &&\n\t       (reader->node->type == XML_ENTITY_REF_NODE) &&\n\t       (reader->ctxt != NULL) && (reader->validate)) {\n\tif (xmlTextReaderValidateEntity(reader) < 0)\n            return(-1);\n#endif /* LIBXML_REGEXP_ENABLED */\n    }\n    if ((reader->node != NULL) &&\n\t(reader->node->type == XML_ENTITY_DECL) &&\n\t(reader->ent != NULL) && (reader->ent->children == reader->node)) {\n\treader->node = xmlTextReaderEntPop(reader);\n\treader->depth++;\n        goto get_next_node;\n    }\n#ifdef LIBXML_REGEXP_ENABLED\n    if ((reader->validate != XML_TEXTREADER_NOT_VALIDATE) && (reader->node != NULL)) {\n\txmlNodePtr node = reader->node;\n\n\tif ((node->type == XML_ELEMENT_NODE) &&\n            ((reader->state != XML_TEXTREADER_END) &&\n\t     (reader->state != XML_TEXTREADER_BACKTRACK))) {\n\t    if (xmlTextReaderValidatePush(reader) < 0)\n                return(-1);\n\t} else if ((node->type == XML_TEXT_NODE) ||\n\t\t   (node->type == XML_CDATA_SECTION_NODE)) {\n            xmlTextReaderValidateCData(reader, node->content,\n\t                               xmlStrlen(node->content));\n\t}\n    }\n#endif /* LIBXML_REGEXP_ENABLED */\n#ifdef LIBXML_PATTERN_ENABLED\n    if ((reader->patternNr > 0) && (reader->state != XML_TEXTREADER_END) &&\n        (reader->state != XML_TEXTREADER_BACKTRACK)) {\n        int i;\n\tfor (i = 0;i < reader->patternNr;i++) {\n\t     if (xmlPatternMatch(reader->patternTab[i], reader->node) == 1) {\n\t         xmlTextReaderPreserve(reader);\n\t\t break;\n             }\n\t}\n    }\n#endif /* LIBXML_PATTERN_ENABLED */\n#ifdef LIBXML_SCHEMAS_ENABLED\n    if ((reader->validate == XML_TEXTREADER_VALIDATE_XSD) &&\n        (reader->xsdValidErrors == 0) &&\n\t(reader->xsdValidCtxt != NULL)) {\n\treader->xsdValidErrors = !xmlSchemaIsValid(reader->xsdValidCtxt);\n    }\n#endif /* LIBXML_PATTERN_ENABLED */\n    return(1);\nnode_end:\n    reader->state = XML_TEXTREADER_DONE;\n    return(0);\n}\n",
    "target": 0,
    "idx": 2066154
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "static zend_never_inline ZEND_COLD zval *zend_wrong_assign_to_variable_reference(zval *variable_ptr, zval *value_ptr OPLINE_DC EXECUTE_DATA_DC)\n{\n\tzend_error(E_NOTICE, \"Only variables should be assigned by reference\");\n\tif (UNEXPECTED(EG(exception) != NULL)) {\n\t\treturn &EG(uninitialized_zval);\n\t}\n\n\t/* Use IS_TMP_VAR instead of IS_VAR to avoid ISREF check */\n\tZ_TRY_ADDREF_P(value_ptr);\n\treturn zend_assign_to_variable(variable_ptr, value_ptr, IS_TMP_VAR, EX_USES_STRICT_TYPES());\n}\nstatic zend_always_inline void zend_assign_to_property_reference(zval *container, uint32_t container_op_type, zval *prop_ptr, uint32_t prop_op_type, zval *value_ptr OPLINE_DC EXECUTE_DATA_DC)\n{\n\tzval variable, *variable_ptr = &variable;\n\tvoid **cache_addr = (prop_op_type == IS_CONST) ? CACHE_ADDR(opline->extended_value & ~ZEND_RETURNS_FUNCTION) : NULL;\n\n\tzend_fetch_property_address(variable_ptr, container, container_op_type, prop_ptr, prop_op_type,\n\t\tcache_addr, BP_VAR_W, 0, 0 OPLINE_CC EXECUTE_DATA_CC);\n\n\tif (EXPECTED(Z_TYPE_P(variable_ptr) == IS_INDIRECT)) {\n\t\tvariable_ptr = Z_INDIRECT_P(variable_ptr);\n\t\tif (/*OP_DATA_TYPE == IS_VAR &&*/\n\t\t\t\t   (opline->extended_value & ZEND_RETURNS_FUNCTION) &&\n\t\t\t\t   UNEXPECTED(!Z_ISREF_P(value_ptr))) {\n\n\t\t\tvariable_ptr = zend_wrong_assign_to_variable_reference(\n\t\t\t\tvariable_ptr, value_ptr OPLINE_CC EXECUTE_DATA_CC);\n\t\t} else {\n\t\t\tzend_property_info *prop_info = NULL;\n\n\t\t\tif (prop_op_type == IS_CONST) {\n\t\t\t\tprop_info = (zend_property_info *) CACHED_PTR_EX(cache_addr + 2);\n\t\t\t} else {\n\t\t\t\tZVAL_DEREF(container);\n\t\t\t\tprop_info = zend_object_fetch_property_type_info(Z_OBJ_P(container), variable_ptr);\n\t\t\t}\n\n\t\t\tif (UNEXPECTED(prop_info)) {\n\t\t\t\tvariable_ptr = zend_assign_to_typed_property_reference(prop_info, variable_ptr, value_ptr EXECUTE_DATA_CC);\n\t\t\t} else {\n\t\t\t\tzend_assign_to_variable_reference(variable_ptr, value_ptr);\n\t\t\t}\n\t\t}\n\t} else if (Z_ISERROR_P(variable_ptr)) {\n\t\tvariable_ptr = &EG(uninitialized_zval);\n\t} else {\n\t\tzend_throw_error(NULL, \"Cannot assign by reference to overloaded object\");\n\t\tzval_ptr_dtor(&variable);\n\t\tvariable_ptr = &EG(uninitialized_zval);\n\t}\n\n\tif (UNEXPECTED(RETURN_VALUE_USED(opline))) {\n\t\tZVAL_COPY(EX_VAR(opline->result.var), variable_ptr);\n\t}\n}\nstatic void fuzzer_execute_ex(zend_execute_data *execute_data) {\n\twhile (1) {\n\t\tint ret;\n\t\tif (--steps_left == 0) {\n\t\t\t/* Reset steps before bailing out, so code running after bailout (e.g. in\n\t\t\t * destructors) will get another MAX_STEPS, rather than UINT32_MAX steps. */\n\t\t\tsteps_left = MAX_STEPS;\n\t\t\tzend_bailout();\n\t\t}\n\n\t\tif ((ret = ((opcode_handler_t) EX(opline)->handler)(execute_data)) != 0) {\n\t\t\tif (ret > 0) {\n\t\t\t\texecute_data = EG(current_execute_data);\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\nint fuzzer_do_request_from_buffer(\n\t\tchar *filename, const char *data, size_t data_len, zend_bool execute)\n{\n\tint retval = FAILURE; /* failure by default */\n\n\tSG(options) |= SAPI_OPTION_NO_CHDIR;\n\tSG(request_info).argc=0;\n\tSG(request_info).argv=NULL;\n\n\tif (fuzzer_request_startup() == FAILURE) {\n\t\treturn FAILURE;\n\t}\n\n\t// Commented out to avoid leaking the header callback.\n\t//SG(headers_sent) = 1;\n\t//SG(request_info).no_headers = 1;\n\tphp_register_variable(\"PHP_SELF\", filename, NULL);\n\n\tzend_first_try {\n\t\tzend_file_handle file_handle;\n\t\tzend_stream_init_filename(&file_handle, filename);\n\t\tfile_handle.buf = estrndup(data, data_len);\n\t\tfile_handle.len = data_len;\n\n\t\tzend_op_array *op_array = zend_compile_file(&file_handle, ZEND_REQUIRE);\n\t\tif (op_array) {\n\t\t\tif (execute) {\n\t\t\t\tzend_execute(op_array, NULL);\n\t\t\t}\n\t\t\tdestroy_op_array(op_array);\n\t\t\tefree(op_array);\n\t\t}\n\t} zend_end_try();\n\n\tCG(compiled_filename) = NULL; /* ??? */\n\tfuzzer_request_shutdown();\n\n\treturn (retval == SUCCESS) ? SUCCESS : FAILURE;\n}\nint LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {\n\tif (Size > MAX_SIZE) {\n\t\t/* Large inputs have a large impact on fuzzer performance,\n\t\t * but are unlikely to be necessary to reach new codepaths. */\n\t\treturn 0;\n\t}\n\n\tsteps_left = MAX_STEPS;\n\tfuzzer_do_request_from_buffer(\"/fuzzer.php\", (const char *) Data, Size, /* execute */ 1);\n\n\treturn 0;\n}",
    "target": 0,
    "idx": 2029899
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "void\nQPDF::read_xref(qpdf_offset_t xref_offset)\n{\n    std::map<int, int> free_table;\n    std::set<qpdf_offset_t> visited;\n    while (xref_offset) {\n        visited.insert(xref_offset);\n        char buf[7];\n        memset(buf, 0, sizeof(buf));\n        m->file->seek(xref_offset, SEEK_SET);\n        // Some files miss the mark a little with startxref. We could do a better job of searching\n        // in the neighborhood for something that looks like either an xref table or stream, but the\n        // simple heuristic of skipping whitespace can help with the xref table case and is harmless\n        // with the stream case.\n        bool done = false;\n        bool skipped_space = false;\n        while (!done) {\n            char ch;\n            if (1 == m->file->read(&ch, 1)) {\n                if (QUtil::is_space(ch)) {\n                    skipped_space = true;\n                } else {\n                    m->file->unreadCh(ch);\n                    done = true;\n                }\n            } else {\n                QTC::TC(\"qpdf\", \"QPDF eof skipping spaces before xref\", skipped_space ? 0 : 1);\n                done = true;\n            }\n        }\n\n        m->file->read(buf, sizeof(buf) - 1);\n        // The PDF spec says xref must be followed by a line terminator, but files exist in the wild\n        // where it is terminated by arbitrary whitespace.\n        if ((strncmp(buf, \"xref\", 4) == 0) && QUtil::is_space(buf[4])) {\n            if (skipped_space) {\n                QTC::TC(\"qpdf\", \"QPDF xref skipped space\");\n                warn(damagedPDF(\"\", 0, \"extraneous whitespace seen before xref\"));\n            }\n            QTC::TC(\n                \"qpdf\",\n                \"QPDF xref space\",\n                ((buf[4] == '\\n')       ? 0\n                     : (buf[4] == '\\r') ? 1\n                     : (buf[4] == ' ')  ? 2\n                                        : 9999));\n            int skip = 4;\n            // buf is null-terminated, and QUtil::is_space('\\0') is false, so this won't overrun.\n            while (QUtil::is_space(buf[skip])) {\n                ++skip;\n            }\n            xref_offset = read_xrefTable(xref_offset + skip);\n        } else {\n            xref_offset = read_xrefStream(xref_offset);\n        }\n        if (visited.count(xref_offset) != 0) {\n            QTC::TC(\"qpdf\", \"QPDF xref loop\");\n            throw damagedPDF(\"\", 0, \"loop detected following xref tables\");\n        }\n    }\n\n    if (!m->trailer.isInitialized()) {\n        throw damagedPDF(\"\", 0, \"unable to find trailer while reading xref\");\n    }\n    int size = m->trailer.getKey(\"/Size\").getIntValueAsInt();\n    int max_obj = 0;\n    if (!m->xref_table.empty()) {\n        max_obj = (*(m->xref_table.rbegin())).first.getObj();\n    }\n    if (!m->deleted_objects.empty()) {\n        max_obj = std::max(max_obj, *(m->deleted_objects.rbegin()));\n    }\n    if ((size < 1) || (size - 1 != max_obj)) {\n        QTC::TC(\"qpdf\", \"QPDF xref size mismatch\");\n        warn(damagedPDF(\n            \"\",\n            0,\n            (\"reported number of objects (\" + std::to_string(size) +\n             \") is not one plus the highest object number (\" + std::to_string(max_obj) + \")\")));\n    }\n\n    // We no longer need the deleted_objects table, so go ahead and clear it out to make sure we\n    // never depend on its being set.\n    m->deleted_objects.clear();\n\n    // Make sure we keep only the highest generation for any object.\n    QPDFObjGen last_og{-1, 0};\n    for (auto const& item: m->xref_table) {\n        auto id = item.first.getObj();\n        if (id == last_og.getObj() && id > 0)\n            removeObject(last_og);\n        last_og = item.first;\n    }\n}\nstd::vector<QPDFObjGen>\nQPDF::getCompressibleObjGens()\n{\n    // Return a list of objects that are allowed to be in object streams.  Walk through the objects\n    // by traversing the document from the root, including a traversal of the pages tree.  This\n    // makes that objects that are on the same page are more likely to be in the same object stream,\n    // which is slightly more efficient, particularly with linearized files.  This is better than\n    // iterating through the xref table since it avoids preserving orphaned items.\n\n    // Exclude encryption dictionary, if any\n    QPDFObjectHandle encryption_dict = m->trailer.getKey(\"/Encrypt\");\n    QPDFObjGen encryption_dict_og = encryption_dict.getObjGen();\n\n    const size_t max_obj = getObjectCount();\n    std::vector<bool> visited(max_obj, false);\n    std::vector<QPDFObjectHandle> queue;\n    queue.reserve(512);\n    queue.push_back(m->trailer);\n    std::vector<QPDFObjGen> result;\n    while (!queue.empty()) {\n        auto obj = queue.back();\n        queue.pop_back();\n        if (obj.getObjectID() > 0) {\n            QPDFObjGen og = obj.getObjGen();\n            const size_t id = toS(og.getObj() - 1);\n            if (id >= max_obj)\n                throw std::logic_error(\n                    \"unexpected object id encountered in getCompressibleObjGens\");\n            if (visited[id]) {\n                QTC::TC(\"qpdf\", \"QPDF loop detected traversing objects\");\n                continue;\n            }\n\n            // Check whether this is the current object. If not, remove it (which changes it into a\n            // direct null and therefore stops us from revisiting it) and move on to the next object\n            // in the queue.\n            auto upper = m->obj_cache.upper_bound(og);\n            if (upper != m->obj_cache.end() && upper->first.getObj() == og.getObj()) {\n                removeObject(og);\n                continue;\n            }\n\n            visited[id] = true;\n\n            if (og == encryption_dict_og) {\n                QTC::TC(\"qpdf\", \"QPDF exclude encryption dictionary\");\n            } else if (!(obj.isStream() ||\n                         (obj.isDictionaryOfType(\"/Sig\") && obj.hasKey(\"/ByteRange\") &&\n                          obj.hasKey(\"/Contents\")))) {\n                result.push_back(og);\n            }\n        }\n        if (obj.isStream()) {\n            QPDFObjectHandle dict = obj.getDict();\n            std::set<std::string> keys = dict.getKeys();\n            for (auto iter = keys.rbegin(); iter != keys.rend(); ++iter) {\n                std::string const& key = *iter;\n                QPDFObjectHandle value = dict.getKey(key);\n                if (key == \"/Length\") {\n                    // omit stream lengths\n                    if (value.isIndirect()) {\n                        QTC::TC(\"qpdf\", \"QPDF exclude indirect length\");\n                    }\n                } else {\n                    queue.push_back(value);\n                }\n            }\n        } else if (obj.isDictionary()) {\n            std::set<std::string> keys = obj.getKeys();\n            for (auto iter = keys.rbegin(); iter != keys.rend(); ++iter) {\n                queue.push_back(obj.getKey(*iter));\n            }\n        } else if (obj.isArray()) {\n            int n = obj.getArrayNItems();\n            for (int i = 1; i <= n; ++i) {\n                queue.push_back(obj.getArrayItem(n - i));\n            }\n        }\n    }\n\n    return result;\n}\nvoid\nQPDF::reconstruct_xref(QPDFExc& e)\n{\n    if (m->reconstructed_xref) {\n        // Avoid xref reconstruction infinite loops. This is getting very hard to reproduce because\n        // qpdf is throwing many fewer exceptions while parsing. Most situations are warnings now.\n        throw e;\n    }\n\n    m->reconstructed_xref = true;\n    // We may find more objects, which may contain dangling references.\n    m->fixed_dangling_refs = false;\n\n    warn(damagedPDF(\"\", 0, \"file is damaged\"));\n    warn(e);\n    warn(damagedPDF(\"\", 0, \"Attempting to reconstruct cross-reference table\"));\n\n    // Delete all references to type 1 (uncompressed) objects\n    std::set<QPDFObjGen> to_delete;\n    for (auto const& iter: m->xref_table) {\n        if (iter.second.getType() == 1) {\n            to_delete.insert(iter.first);\n        }\n    }\n    for (auto const& iter: to_delete) {\n        m->xref_table.erase(iter);\n    }\n\n    m->file->seek(0, SEEK_END);\n    qpdf_offset_t eof = m->file->tell();\n    m->file->seek(0, SEEK_SET);\n    qpdf_offset_t line_start = 0;\n    // Don't allow very long tokens here during recovery.\n    static size_t const MAX_LEN = 100;\n    while (m->file->tell() < eof) {\n        m->file->findAndSkipNextEOL();\n        qpdf_offset_t next_line_start = m->file->tell();\n        m->file->seek(line_start, SEEK_SET);\n        QPDFTokenizer::Token t1 = readToken(m->file, MAX_LEN);\n        qpdf_offset_t token_start = m->file->tell() - toO(t1.getValue().length());\n        if (token_start >= next_line_start) {\n            // don't process yet -- wait until we get to the line containing this token\n        } else if (t1.isInteger()) {\n            QPDFTokenizer::Token t2 = readToken(m->file, MAX_LEN);\n            if ((t2.isInteger()) && (readToken(m->file, MAX_LEN).isWord(\"obj\"))) {\n                int obj = QUtil::string_to_int(t1.getValue().c_str());\n                int gen = QUtil::string_to_int(t2.getValue().c_str());\n                insertReconstructedXrefEntry(obj, token_start, gen);\n            }\n        } else if (!m->trailer.isInitialized() && t1.isWord(\"trailer\")) {\n            QPDFObjectHandle t = readTrailer();\n            if (!t.isDictionary()) {\n                // Oh well.  It was worth a try.\n            } else {\n                setTrailer(t);\n            }\n        }\n        m->file->seek(next_line_start, SEEK_SET);\n        line_start = next_line_start;\n    }\n    m->deleted_objects.clear();\n\n    if (!m->trailer.isInitialized()) {\n        qpdf_offset_t max_offset{0};\n        // If there are any xref streams, take the last one to appear.\n        for (auto const& iter: m->xref_table) {\n            auto entry = iter.second;\n            if (entry.getType() != 1) {\n                continue;\n            }\n            auto oh = getObjectByObjGen(iter.first);\n            try {\n                if (!oh.isStreamOfType(\"/XRef\")) {\n                    continue;\n                }\n            } catch (std::exception&) {\n                continue;\n            }\n            auto offset = entry.getOffset();\n            if (offset > max_offset) {\n                max_offset = offset;\n                setTrailer(oh.getDict());\n            }\n        }\n        if (max_offset > 0) {\n            try {\n                read_xref(max_offset);\n            } catch (std::exception&) {\n                throw damagedPDF(\n                    \"\", 0, \"error decoding candidate xref stream while recovering damaged file\");\n            }\n            QTC::TC(\"qpdf\", \"QPDF recover xref stream\");\n        }\n    }\n\n    if (!m->trailer.isInitialized()) {\n        // We could check the last encountered object to see if it was an xref stream.  If so, we\n        // could try to get the trailer from there.  This may make it possible to recover files with\n        // bad startxref pointers even when they have object streams.\n\n        throw damagedPDF(\"\", 0, \"unable to find trailer dictionary while recovering damaged file\");\n    }\n\n    // We could iterate through the objects looking for streams and try to find objects inside of\n    // them, but it's probably not worth the trouble.  Acrobat can't recover files with any errors\n    // in an xref stream, and this would be a real long shot anyway.  If we wanted to do anything\n    // that involved looking at stream contents, we'd also have to call initializeEncryption() here.\n    // It's safe to call it more than once.\n}\nvoid\nQPDF::parse(char const* password)\n{\n    if (password) {\n        m->encp->provided_password = password;\n    }\n\n    // Find the header anywhere in the first 1024 bytes of the file.\n    PatternFinder hf(*this, &QPDF::findHeader);\n    if (!m->file->findFirst(\"%PDF-\", 0, 1024, hf)) {\n        QTC::TC(\"qpdf\", \"QPDF not a pdf file\");\n        warn(damagedPDF(\"\", 0, \"can't find PDF header\"));\n        // QPDFWriter writes files that usually require at least version 1.2 for /FlateDecode\n        m->pdf_version = \"1.2\";\n    }\n\n    // PDF spec says %%EOF must be found within the last 1024 bytes of/ the file.  We add an extra\n    // 30 characters to leave room for the startxref stuff.\n    m->file->seek(0, SEEK_END);\n    qpdf_offset_t end_offset = m->file->tell();\n    qpdf_offset_t start_offset = (end_offset > 1054 ? end_offset - 1054 : 0);\n    PatternFinder sf(*this, &QPDF::findStartxref);\n    qpdf_offset_t xref_offset = 0;\n    if (m->file->findLast(\"startxref\", start_offset, 0, sf)) {\n        xref_offset = QUtil::string_to_ll(readToken(m->file).getValue().c_str());\n    }\n\n    try {\n        if (xref_offset == 0) {\n            QTC::TC(\"qpdf\", \"QPDF can't find startxref\");\n            throw damagedPDF(\"\", 0, \"can't find startxref\");\n        }\n        try {\n            read_xref(xref_offset);\n        } catch (QPDFExc&) {\n            throw;\n        } catch (std::exception& e) {\n            throw damagedPDF(\"\", 0, std::string(\"error reading xref: \") + e.what());\n        }\n    } catch (QPDFExc& e) {\n        if (m->attempt_recovery) {\n            reconstruct_xref(e);\n            QTC::TC(\"qpdf\", \"QPDF reconstructed xref table\");\n        } else {\n            throw;\n        }\n    }\n\n    initializeEncryption();\n    m->parsed = true;\n}\nvoid\nQPDF::processInputSource(std::shared_ptr<InputSource> source, char const* password)\n{\n    m->file = source;\n    parse(password);\n}\nstd::shared_ptr<QPDF>\nFuzzHelper::getQpdf()\n{\n    auto is =\n        std::shared_ptr<InputSource>(new BufferInputSource(\"fuzz input\", &this->input_buffer));\n    auto qpdf = QPDF::create();\n    qpdf->processInputSource(is);\n    return qpdf;\n}\nvoid\nFuzzHelper::testWrite()\n{\n    // Write in various ways to exercise QPDFWriter\n\n    std::shared_ptr<QPDF> q;\n    std::shared_ptr<QPDFWriter> w;\n\n    q = getQpdf();\n    w = getWriter(q);\n    w->setDeterministicID(true);\n    w->setQDFMode(true);\n    doWrite(w);\n\n    q = getQpdf();\n    w = getWriter(q);\n    w->setStaticID(true);\n    w->setLinearization(true);\n    w->setR6EncryptionParameters(\"u\", \"o\", true, true, true, true, true, true, qpdf_r3p_full, true);\n    doWrite(w);\n\n    q = getQpdf();\n    w = getWriter(q);\n    w->setStaticID(true);\n    w->setObjectStreamMode(qpdf_o_disable);\n    w->setR3EncryptionParametersInsecure(\n        \"u\", \"o\", true, true, true, true, true, true, qpdf_r3p_full);\n    doWrite(w);\n\n    q = getQpdf();\n    w = getWriter(q);\n    w->setDeterministicID(true);\n    w->setObjectStreamMode(qpdf_o_generate);\n    w->setLinearization(true);\n    doWrite(w);\n}\nvoid\nFuzzHelper::doChecks()\n{\n    // Get as much coverage as possible in parts of the library that\n    // might benefit from fuzzing.\n    testWrite();\n    testPages();\n    testOutlines();\n}\nvoid\nFuzzHelper::run()\n{\n    // The goal here is that you should be able to throw anything at\n    // libqpdf and it will respond without any memory errors and never\n    // do anything worse than throwing a QPDFExc or\n    // std::runtime_error. Throwing any other kind of exception,\n    // segfaulting, or having a memory error (when built with\n    // appropriate sanitizers) will all cause abnormal exit.\n    try {\n        doChecks();\n    } catch (QPDFExc const& e) {\n        std::cerr << \"QPDFExc: \" << e.what() << std::endl;\n    } catch (std::runtime_error const& e) {\n        std::cerr << \"runtime_error: \" << e.what() << std::endl;\n    }\n}\nextern \"C\" int\nLLVMFuzzerTestOneInput(unsigned char const* data, size_t size)\n{\n#ifndef _WIN32\n    // Used by jpeg library to work around false positives in memory\n    // sanitizer.\n    setenv(\"JSIMD_FORCENONE\", \"1\", 1);\n#endif\n    FuzzHelper f(data, size);\n    f.run();\n    return 0;\n}",
    "target": 0,
    "idx": 2065777
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "UA_Server *\nUA_Server_new() {\n    UA_ServerConfig config;\n    memset(&config, 0, sizeof(UA_ServerConfig));\n    /* Set a default logger and NodeStore for the initialization */\n    config.logger = UA_Log_Stdout_;\n    if(UA_STATUSCODE_GOOD != UA_Nodestore_HashMap(&config.nodestore)) {\n        return NULL;\n    }\n\n    return UA_Server_newWithConfig(&config);\n}\nUA_Server *\nUA_Server_newWithConfig(UA_ServerConfig *config) {\n    if(!config)\n        return NULL;\n    UA_Server *server = (UA_Server *)UA_calloc(1, sizeof(UA_Server));\n    if(!server) {\n        UA_ServerConfig_clean(config);\n        return NULL;\n    }\n    server->config = *config;\n    memset(config, 0, sizeof(UA_ServerConfig));\n    return UA_Server_init(server);\n}\nstatic void\nUA_NodeMap_delete(void *context) {\n    UA_NodeMap *ns = (UA_NodeMap*)context;\n    UA_UInt32 size = ns->size;\n    UA_NodeMapSlot *slots = ns->slots;\n    for(UA_UInt32 i = 0; i < size; ++i) {\n        if(slots[i].entry > UA_NODEMAP_TOMBSTONE) {\n            /* On debugging builds, check that all nodes were release */\n            UA_assert(slots[i].entry->refCount == 0);\n            /* Delete the node */\n            deleteNodeMapEntry(slots[i].entry);\n        }\n    }\n    UA_free(ns->slots);\n\n    /* Clean up the ReferenceTypes index array */\n    for(size_t i = 0; i < ns->referenceTypeCounter; i++)\n        UA_NodeId_clear(&ns->referenceTypeIds[i]);\n\n    UA_free(ns);\n}\nextern \"C\" int\nLLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n    if(size <= 4)\n        return 0;\n\n    if(!UA_memoryManager_setLimitFromLast4Bytes(data, size))\n        return 0;\n    size -= 4;\n\n    UA_Connection c = createDummyConnection(RECEIVE_BUFFER_SIZE, NULL);\n    UA_Server *server = UA_Server_new();\n    if(!server) {\n        UA_LOG_ERROR(UA_Log_Stdout, UA_LOGCATEGORY_SERVER,\n                     \"Could not create server instance using UA_Server_new\");\n        return 0;\n    }\n\n    UA_StatusCode retval = UA_ServerConfig_setDefault(UA_Server_getConfig(server));\n    if(retval != UA_STATUSCODE_GOOD) {\n        UA_Server_delete(server);\n        UA_LOG_ERROR(UA_Log_Stdout, UA_LOGCATEGORY_SERVER,\n                     \"Could not set the server config\");\n        return 0;\n    }\n\n    // we need to copy the message because it will be freed in the processing function\n    UA_ByteString msg = UA_ByteString();\n    retval = UA_ByteString_allocBuffer(&msg, size);\n    if(retval != UA_STATUSCODE_GOOD) {\n        UA_Server_delete(server);\n        UA_LOG_ERROR(UA_Log_Stdout, UA_LOGCATEGORY_SERVER,\n                     \"Could not allocate message buffer\");\n        return 0;\n    }\n    memcpy(msg.data, data, size);\n\n    UA_Server_processBinaryMessage(server, &c, &msg);\n    // if we got an invalid chunk, the message is not deleted, so delete it here\n    UA_ByteString_deleteMembers(&msg);\n    UA_Server_run_shutdown(server);\n    UA_Server_delete(server);\n    c.close(&c);\n    return 0;\n}",
    "target": 0,
    "idx": 2025068
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "ATTRIBUTE_MALLOC\nBITCODE_TV\nbit_read_TV (Bit_Chain *restrict dat)\n{\n  unsigned int i;\n  unsigned int length;\n  unsigned char *chain;\n\n  CHK_OVERFLOW_PLUS (1,__FUNCTION__,NULL)\n  if (dat->from_version < R_13)\n    length = bit_read_RS (dat);\n  else\n    length = bit_read_BS (dat);\n  CHK_OVERFLOW_PLUS (length,__FUNCTION__,NULL)\n  chain = (unsigned char *)malloc (length + 1);\n  if (!chain)\n    {\n      loglevel = dat->opts & DWG_OPTS_LOGLEVEL;\n      LOG_ERROR (\"Out of memory\");\n      return NULL;\n    }\n  for (i = 0; i < length; i++)\n    chain[i] = bit_read_RC (dat);\n  // check if the string is already zero-terminated or not.\n  // only observed >=r2004 as writer app\n  if (length > 0 && dat->from_version > R_2000 && chain[length - 1] != '\\0')\n    LOG_HANDLE (\"TV-not-ZERO %u\\n \", length)\n  else if (length > 0 && dat->from_version <= R_2000 && chain[length - 1] == '\\0')\n    LOG_HANDLE (\"TV-ZERO %u\\n\", length)\n  // normally not needed, as the DWG since r2004 itself contains the ending \\0 as last char\n  chain[i] = '\\0';\n  return (char *)chain;\n}\nvoid\nbit_write_TV (Bit_Chain *restrict dat, BITCODE_TV restrict chain)\n{\n  int i;\n  int length = (chain && *chain) ? strlen ((const char *)chain) : 0;\n  if (dat->version <= R_2000 && length)\n    length++;\n  if (dat->from_version < R_13)\n    bit_write_RS (dat, length);\n  else\n    bit_write_BS (dat, length);\n  for (i = 0; i < length; i++)\n    bit_write_RC (dat, (unsigned char)chain[i]);\n}\nstatic int ishex (int c)\n{\n  return ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'f')\n          || (c >= 'A' && c <= 'F'));\n}\nEXPORT void\ndwg_free_object (Dwg_Object *obj)\n{\n  int error = 0;\n  long unsigned int j;\n  Dwg_Data *dwg;\n  Bit_Chain *dat = &pdat;\n\n  if (obj && obj->parent)\n    {\n      dwg = obj->parent;\n      dat->version = dwg->header.version;\n      dat->from_version = dwg->header.from_version;\n    }\n  else\n    return;\n  if (obj->type == DWG_TYPE_FREED || obj->tio.object == NULL)\n    return;\n\n  PRE (R_13) {\n    free_preR13_object (obj);\n    return;\n  }\n\n  switch (obj->type)\n    {\n    case DWG_TYPE_TEXT:\n      dwg_free_TEXT (dat, obj);\n      break;\n    case DWG_TYPE_ATTRIB:\n      dwg_free_ATTRIB (dat, obj);\n      break;\n    case DWG_TYPE_ATTDEF:\n      dwg_free_ATTDEF (dat, obj);\n      break;\n    case DWG_TYPE_BLOCK:\n      dwg_free_BLOCK (dat, obj);\n      break;\n    case DWG_TYPE_ENDBLK:\n      dwg_free_ENDBLK (dat, obj);\n      break;\n    case DWG_TYPE_SEQEND:\n      dwg_free_SEQEND (dat, obj);\n      break;\n    case DWG_TYPE_INSERT:\n      dwg_free_INSERT (dat, obj);\n      break;\n    case DWG_TYPE_MINSERT:\n      dwg_free_MINSERT (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_2D:\n      dwg_free_VERTEX_2D (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_3D:\n      dwg_free_VERTEX_3D (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_MESH:\n      dwg_free_VERTEX_MESH (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_PFACE:\n      dwg_free_VERTEX_PFACE (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_PFACE_FACE:\n      dwg_free_VERTEX_PFACE_FACE (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_2D:\n      dwg_free_POLYLINE_2D (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_3D:\n      dwg_free_POLYLINE_3D (dat, obj);\n      break;\n    case DWG_TYPE_ARC:\n      dwg_free_ARC (dat, obj);\n      break;\n    case DWG_TYPE_CIRCLE:\n      dwg_free_CIRCLE (dat, obj);\n      break;\n    case DWG_TYPE_LINE:\n      dwg_free_LINE (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ORDINATE:\n      dwg_free_DIMENSION_ORDINATE (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_LINEAR:\n      dwg_free_DIMENSION_LINEAR (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ALIGNED:\n      dwg_free_DIMENSION_ALIGNED (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ANG3PT:\n      dwg_free_DIMENSION_ANG3PT (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ANG2LN:\n      dwg_free_DIMENSION_ANG2LN (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_RADIUS:\n      dwg_free_DIMENSION_RADIUS (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_DIAMETER:\n      dwg_free_DIMENSION_DIAMETER (dat, obj);\n      break;\n    case DWG_TYPE_POINT:\n      dwg_free_POINT (dat, obj);\n      break;\n    case DWG_TYPE__3DFACE:\n      dwg_free__3DFACE (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_PFACE:\n      dwg_free_POLYLINE_PFACE (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_MESH:\n      dwg_free_POLYLINE_MESH (dat, obj);\n      break;\n    case DWG_TYPE_SOLID:\n      dwg_free_SOLID (dat, obj);\n      break;\n    case DWG_TYPE_TRACE:\n      dwg_free_TRACE (dat, obj);\n      break;\n    case DWG_TYPE_SHAPE:\n      dwg_free_SHAPE (dat, obj);\n      break;\n    case DWG_TYPE_VIEWPORT:\n      dwg_free_VIEWPORT (dat, obj);\n      break;\n    case DWG_TYPE_ELLIPSE:\n      dwg_free_ELLIPSE (dat, obj);\n      break;\n    case DWG_TYPE_SPLINE:\n      dwg_free_SPLINE (dat, obj);\n      break;\n    case DWG_TYPE_REGION:\n      dwg_free_REGION (dat, obj);\n      break;\n    case DWG_TYPE__3DSOLID:\n      dwg_free__3DSOLID (dat, obj);\n      break; /* Check the type of the object */\n    case DWG_TYPE_BODY:\n      dwg_free_BODY (dat, obj);\n      break;\n    case DWG_TYPE_RAY:\n      dwg_free_RAY (dat, obj);\n      break;\n    case DWG_TYPE_XLINE:\n      dwg_free_XLINE (dat, obj);\n      break;\n    case DWG_TYPE_DICTIONARY:\n      dwg_free_DICTIONARY (dat, obj);\n      break;\n    case DWG_TYPE_MTEXT:\n      dwg_free_MTEXT (dat, obj);\n      break;\n    case DWG_TYPE_LEADER:\n      dwg_free_LEADER (dat, obj);\n      break;\n    case DWG_TYPE_TOLERANCE:\n      dwg_free_TOLERANCE (dat, obj);\n      break;\n    case DWG_TYPE_MLINE:\n      dwg_free_MLINE (dat, obj);\n      break;\n    case DWG_TYPE_BLOCK_CONTROL:\n      dwg_free_BLOCK_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_BLOCK_HEADER:\n      dwg_free_BLOCK_HEADER (dat, obj);\n      break;\n    case DWG_TYPE_LAYER_CONTROL:\n      dwg_free_LAYER_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_LAYER:\n      dwg_free_LAYER (dat, obj);\n      break;\n    case DWG_TYPE_STYLE_CONTROL:\n      dwg_free_STYLE_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_STYLE:\n      dwg_free_STYLE (dat, obj);\n      break;\n    case DWG_TYPE_LTYPE_CONTROL:\n      dwg_free_LTYPE_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_LTYPE:\n      dwg_free_LTYPE (dat, obj);\n      break;\n    case DWG_TYPE_VIEW_CONTROL:\n      dwg_free_VIEW_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_VIEW:\n      dwg_free_VIEW (dat, obj);\n      break;\n    case DWG_TYPE_UCS_CONTROL:\n      dwg_free_UCS_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_UCS:\n      dwg_free_UCS (dat, obj);\n      break;\n    case DWG_TYPE_VPORT_CONTROL:\n      dwg_free_VPORT_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_VPORT:\n      dwg_free_VPORT (dat, obj);\n      break;\n    case DWG_TYPE_APPID_CONTROL:\n      dwg_free_APPID_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_APPID:\n      dwg_free_APPID (dat, obj);\n      break;\n    case DWG_TYPE_DIMSTYLE_CONTROL:\n      dwg_free_DIMSTYLE_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_DIMSTYLE:\n      dwg_free_DIMSTYLE (dat, obj);\n      break;\n    case DWG_TYPE_VX_CONTROL:\n      dwg_free_VX_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_VX_TABLE_RECORD:\n      dwg_free_VX_TABLE_RECORD (dat, obj);\n      break;\n    case DWG_TYPE_GROUP:\n      dwg_free_GROUP (dat, obj);\n      break;\n    case DWG_TYPE_MLINESTYLE:\n      dwg_free_MLINESTYLE (dat, obj);\n      break;\n    case DWG_TYPE_OLE2FRAME:\n      dwg_free_OLE2FRAME (dat, obj);\n      break;\n    case DWG_TYPE_DUMMY:\n      dwg_free_DUMMY (dat, obj);\n      break;\n    case DWG_TYPE_LONG_TRANSACTION:\n      dwg_free_LONG_TRANSACTION (dat, obj);\n      break;\n    case DWG_TYPE_LWPOLYLINE:\n      dwg_free_LWPOLYLINE (dat, obj);\n      break;\n    case DWG_TYPE_HATCH:\n      dwg_free_HATCH (dat, obj);\n      break;\n    case DWG_TYPE_XRECORD:\n      dwg_free_XRECORD (dat, obj);\n      break;\n    case DWG_TYPE_PLACEHOLDER:\n      dwg_free_PLACEHOLDER (dat, obj);\n      break;\n    case DWG_TYPE_OLEFRAME:\n      dwg_free_OLEFRAME (dat, obj);\n      break;\n#ifdef DEBUG_VBA_PROJECT\n    case DWG_TYPE_VBA_PROJECT:\n      dwg_free_VBA_PROJECT (dat, obj);\n      break;\n#endif\n    case DWG_TYPE_LAYOUT:\n      dwg_free_LAYOUT (dat, obj);\n      break;\n    case DWG_TYPE_PROXY_ENTITY:\n      dwg_free_PROXY_ENTITY (dat, obj);\n      break;\n    case DWG_TYPE_PROXY_OBJECT:\n      dwg_free_PROXY_OBJECT (dat, obj);\n      break;\n    default:\n      if (obj->type == obj->parent->layout_type\n          && obj->fixedtype == DWG_TYPE_LAYOUT)\n        {\n          SINCE (R_13)\n          {\n            dwg_free_LAYOUT (dat, obj); // XXX avoid double-free, esp. in eed\n          }\n        }\n      else if ((error = dwg_free_variable_type (obj->parent, obj))\n               & DWG_ERR_UNHANDLEDCLASS)\n        {\n          if (obj->fixedtype == DWG_TYPE_UNKNOWN_ENT)\n              dwg_free_UNKNOWN_ENT (dat, obj);\n          else if (obj->fixedtype == DWG_TYPE_UNKNOWN_OBJ)\n              dwg_free_UNKNOWN_OBJ (dat, obj);\n        }\n    }\n  /* With indxf the dxfname is dynamic, just the name is const */\n  if (dwg->opts & DWG_OPTS_IN)\n    FREE_IF (obj->dxfname);\n  /* With injson even the name is dynamic */\n  if (dwg->opts & DWG_OPTS_INJSON)\n    FREE_IF (obj->name);\n  obj->type = DWG_TYPE_FREED;\n}\nvoid\ndwg_free (Dwg_Data *dwg)\n{\n  BITCODE_BL i;\n  if (dwg)\n    {\n      pdat.version = dwg->header.version;\n      pdat.from_version = dwg->header.from_version;\n      if (dwg->opts)\n        {\n          loglevel = dwg->opts & DWG_OPTS_LOGLEVEL;\n          pdat.opts = dwg->opts;\n        }\n#ifdef USE_TRACING\n      /* Before starting, set the logging level, but only do so once.  */\n      if (!env_var_checked_p)\n        {\n          char *probe = getenv (\"LIBREDWG_TRACE\");\n          if (probe)\n            loglevel = atoi (probe);\n          env_var_checked_p = 1;\n        }\n#endif /* USE_TRACING */\n      LOG_INFO (\"\\n============\\ndwg_free\\n\")\n      // copied table fields have duplicate pointers, but are freed only once\n      for (i = 0; i < dwg->num_objects; ++i)\n        {\n          if (!dwg_obj_is_control (&dwg->object[i]))\n            dwg_free_object (&dwg->object[i]);\n        }\n      dwg_free_header_vars (dwg);\n      dwg_free_summaryinfo (dwg);\n      FREE_IF (dwg->thumbnail.chain);\n      if (dwg->header.section_infohdr.num_desc)\n        {\n          for (i = 0; i < dwg->header.section_infohdr.num_desc; ++i)\n            FREE_IF (dwg->header.section_info[i].sections);\n          FREE_IF (dwg->header.section_info);\n        }\n      dwg_free_appinfo (dwg);\n      dwg_free_filedeplist (dwg);\n      dwg_free_security (dwg);\n      dwg_free_acds (dwg);\n\n      FREE_IF (dwg->vbaproject.unknown_bits);\n      FREE_IF (dwg->revhistory.histories);\n      FREE_IF (dwg->appinfohistory.unknown_bits);\n      //FREE_IF (dwg->objfreespace...);\n      FREE_IF (dwg->Template.description);\n      FREE_IF (dwg->header.section);\n      for (i = 0; i < dwg->second_header.num_handlers; i++)\n        FREE_IF (dwg->second_header.handlers[i].data);\n      // auxheader has no strings\n      for (i = 0; i < dwg->num_objects; ++i)\n        {\n          if (dwg_obj_is_control (&dwg->object[i]))\n            dwg_free_object (&dwg->object[i]);\n        }\n      if (dwg->num_classes && dwg->dwg_class)\n        {\n          for (i = 0; i < dwg->num_classes; ++i)\n            {\n              FREE_IF (dwg->dwg_class[i].appname);\n              FREE_IF (dwg->dwg_class[i].cppname);\n              FREE_IF (dwg->dwg_class[i].dxfname);\n              if (dwg->header.from_version >= R_2007)\n                FREE_IF (dwg->dwg_class[i].dxfname_u);\n            }\n        }\n      FREE_IF (dwg->dwg_class);\n      if (dwg->object_ref)\n        {\n          LOG_HANDLE (\"free %d global refs\\n\", dwg->num_object_refs)\n          for (i = 0; i < dwg->num_object_refs; ++i)\n            {\n              //LOG_HANDLE (\"free ref %d\\n\", i)\n              FREE_IF (dwg->object_ref[i]);\n            }\n        }\n      FREE_IF (dwg->object_ref);\n      for (i = 0; i < dwg->num_acis_sab_hdl; ++i)\n        {\n          FREE_IF (dwg->acis_sab_hdl[i]);\n        }\n      FREE_IF (dwg->acis_sab_hdl);\n      FREE_IF (dwg->object);\n      if (dwg->object_map)\n        hash_free (dwg->object_map);\n      dwg->num_objects = dwg->num_classes = dwg->num_object_refs = 0;\n#undef FREE_IF\n    }\n}",
    "target": 0,
    "idx": 2034377
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "void\nxmlParseReference(xmlParserCtxtPtr ctxt) {\n    xmlEntityPtr ent;\n    xmlChar *val;\n    int was_checked;\n    xmlNodePtr list = NULL;\n    xmlParserErrors ret = XML_ERR_OK;\n\n\n    if (RAW != '&')\n        return;\n\n    /*\n     * Simple case of a CharRef\n     */\n    if (NXT(1) == '#') {\n\tint i = 0;\n\txmlChar out[16];\n\tint value = xmlParseCharRef(ctxt);\n\n\tif (value == 0)\n\t    return;\n\n        /*\n         * Just encode the value in UTF-8\n         */\n        COPY_BUF(0, out, i, value);\n        out[i] = 0;\n        if ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL) &&\n            (!ctxt->disableSAX))\n            ctxt->sax->characters(ctxt->userData, out, i);\n\treturn;\n    }\n\n    /*\n     * We are seeing an entity reference\n     */\n    ent = xmlParseEntityRef(ctxt);\n    if (ent == NULL) return;\n    if (!ctxt->wellFormed)\n\treturn;\n    was_checked = ent->flags & XML_ENT_PARSED;\n\n    /* special case of predefined entities */\n    if ((ent->name == NULL) ||\n        (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n\tval = ent->content;\n\tif (val == NULL) return;\n\t/*\n\t * inline the entity.\n\t */\n\tif ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL) &&\n\t    (!ctxt->disableSAX))\n\t    ctxt->sax->characters(ctxt->userData, val, xmlStrlen(val));\n\treturn;\n    }\n\n    /*\n     * The first reference to the entity trigger a parsing phase\n     * where the ent->children is filled with the result from\n     * the parsing.\n     * Note: external parsed entities will not be loaded, it is not\n     * required for a non-validating parser, unless the parsing option\n     * of validating, or substituting entities were given. Doing so is\n     * far more secure as the parser will only process data coming from\n     * the document entity by default.\n     *\n     * FIXME: This doesn't work correctly since entities can be\n     * expanded with different namespace declarations in scope.\n     * For example:\n     *\n     * <!DOCTYPE doc [\n     *   <!ENTITY ent \"<ns:elem/>\">\n     * ]>\n     * <doc>\n     *   <decl1 xmlns:ns=\"urn:ns1\">\n     *     &ent;\n     *   </decl1>\n     *   <decl2 xmlns:ns=\"urn:ns2\">\n     *     &ent;\n     *   </decl2>\n     * </doc>\n     *\n     * Proposed fix:\n     *\n     * - Remove the ent->owner optimization which tries to avoid the\n     *   initial copy of the entity. Always make entities own the\n     *   subtree.\n     * - Ignore current namespace declarations when parsing the\n     *   entity. If a prefix can't be resolved, don't report an error\n     *   but mark it as unresolved.\n     * - Try to resolve these prefixes when expanding the entity.\n     *   This will require a specialized version of xmlStaticCopyNode\n     *   which can also make use of the namespace hash table to avoid\n     *   quadratic behavior.\n     *\n     * Alternatively, we could simply reparse the entity on each\n     * expansion like we already do with custom SAX callbacks.\n     * External entity content should be cached in this case.\n     */\n    if (((ent->flags & XML_ENT_PARSED) == 0) &&\n        ((ent->etype != XML_EXTERNAL_GENERAL_PARSED_ENTITY) ||\n         (ctxt->options & (XML_PARSE_NOENT | XML_PARSE_DTDVALID)))) {\n\tunsigned long oldsizeentcopy = ctxt->sizeentcopy;\n\n\t/*\n\t * This is a bit hackish but this seems the best\n\t * way to make sure both SAX and DOM entity support\n\t * behaves okay.\n\t */\n\tvoid *user_data;\n\tif (ctxt->userData == ctxt)\n\t    user_data = NULL;\n\telse\n\t    user_data = ctxt->userData;\n\n        /* Avoid overflow as much as possible */\n        ctxt->sizeentcopy = 0;\n\n        if (ent->flags & XML_ENT_EXPANDING) {\n            xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);\n            xmlHaltParser(ctxt);\n            return;\n        }\n\n        ent->flags |= XML_ENT_EXPANDING;\n\n\t/*\n\t * Check that this entity is well formed\n\t * 4.3.2: An internal general parsed entity is well-formed\n\t * if its replacement text matches the production labeled\n\t * content.\n\t */\n\tif (ent->etype == XML_INTERNAL_GENERAL_ENTITY) {\n\t    ctxt->depth++;\n\t    ret = xmlParseBalancedChunkMemoryInternal(ctxt, ent->content,\n\t                                              user_data, &list);\n\t    ctxt->depth--;\n\n\t} else if (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY) {\n\t    ctxt->depth++;\n\t    ret = xmlParseExternalEntityPrivate(ctxt->myDoc, ctxt, ctxt->sax,\n\t                                   user_data, ctxt->depth, ent->URI,\n\t\t\t\t\t   ent->ExternalID, &list);\n\t    ctxt->depth--;\n\t} else {\n\t    ret = XML_ERR_ENTITY_PE_INTERNAL;\n\t    xmlErrMsgStr(ctxt, XML_ERR_INTERNAL_ERROR,\n\t\t\t \"invalid entity type found\\n\", NULL);\n\t}\n\n        ent->flags &= ~XML_ENT_EXPANDING;\n        ent->flags |= XML_ENT_PARSED | XML_ENT_CHECKED;\n        ent->expandedSize = ctxt->sizeentcopy;\n\tif (ret == XML_ERR_ENTITY_LOOP) {\n            xmlHaltParser(ctxt);\n\t    xmlFreeNodeList(list);\n\t    return;\n\t}\n\tif (xmlParserEntityCheck(ctxt, oldsizeentcopy)) {\n\t    xmlFreeNodeList(list);\n\t    return;\n\t}\n\n\tif ((ret == XML_ERR_OK) && (list != NULL)) {\n            ent->children = list;\n            /*\n             * Prune it directly in the generated document\n             * except for single text nodes.\n             */\n            if ((ctxt->replaceEntities == 0) ||\n                (ctxt->parseMode == XML_PARSE_READER) ||\n                ((list->type == XML_TEXT_NODE) &&\n                 (list->next == NULL))) {\n                ent->owner = 1;\n                while (list != NULL) {\n                    list->parent = (xmlNodePtr) ent;\n                    if (list->doc != ent->doc)\n                        xmlSetTreeDoc(list, ent->doc);\n                    if (list->next == NULL)\n                        ent->last = list;\n                    list = list->next;\n                }\n                list = NULL;\n            } else {\n                ent->owner = 0;\n                while (list != NULL) {\n                    list->parent = (xmlNodePtr) ctxt->node;\n                    list->doc = ctxt->myDoc;\n                    if (list->next == NULL)\n                        ent->last = list;\n                    list = list->next;\n                }\n                list = ent->children;\n#ifdef LIBXML_LEGACY_ENABLED\n                if (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)\n                    xmlAddEntityReference(ent, list, NULL);\n#endif /* LIBXML_LEGACY_ENABLED */\n            }\n\t} else if ((ret != XML_ERR_OK) &&\n\t\t   (ret != XML_WAR_UNDECLARED_ENTITY)) {\n\t    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,\n\t\t     \"Entity '%s' failed to parse\\n\", ent->name);\n            if (ent->content != NULL)\n                ent->content[0] = 0;\n\t} else if (list != NULL) {\n\t    xmlFreeNodeList(list);\n\t    list = NULL;\n\t}\n\n        /* Prevent entity from being parsed and expanded twice (Bug 760367). */\n        was_checked = 0;\n    }\n\n    /*\n     * Now that the entity content has been gathered\n     * provide it to the application, this can take different forms based\n     * on the parsing modes.\n     */\n    if (ent->children == NULL) {\n\t/*\n\t * Probably running in SAX mode and the callbacks don't\n\t * build the entity content. So unless we already went\n\t * though parsing for first checking go though the entity\n\t * content to generate callbacks associated to the entity\n\t */\n\tif (was_checked != 0) {\n\t    void *user_data;\n\t    /*\n\t     * This is a bit hackish but this seems the best\n\t     * way to make sure both SAX and DOM entity support\n\t     * behaves okay.\n\t     */\n\t    if (ctxt->userData == ctxt)\n\t\tuser_data = NULL;\n\t    else\n\t\tuser_data = ctxt->userData;\n\n\t    if (ent->etype == XML_INTERNAL_GENERAL_ENTITY) {\n\t\tctxt->depth++;\n\t\tret = xmlParseBalancedChunkMemoryInternal(ctxt,\n\t\t\t\t   ent->content, user_data, NULL);\n\t\tctxt->depth--;\n\t    } else if (ent->etype ==\n\t\t       XML_EXTERNAL_GENERAL_PARSED_ENTITY) {\n\t        unsigned long oldsizeentities = ctxt->sizeentities;\n\n\t\tctxt->depth++;\n\t\tret = xmlParseExternalEntityPrivate(ctxt->myDoc, ctxt,\n\t\t\t   ctxt->sax, user_data, ctxt->depth,\n\t\t\t   ent->URI, ent->ExternalID, NULL);\n\t\tctxt->depth--;\n\n                /* Undo the change to sizeentities */\n                ctxt->sizeentities = oldsizeentities;\n\t    } else {\n\t\tret = XML_ERR_ENTITY_PE_INTERNAL;\n\t\txmlErrMsgStr(ctxt, XML_ERR_INTERNAL_ERROR,\n\t\t\t     \"invalid entity type found\\n\", NULL);\n\t    }\n\t    if (ret == XML_ERR_ENTITY_LOOP) {\n\t\txmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);\n\t\treturn;\n\t    }\n            if (xmlParserEntityCheck(ctxt, 0))\n                return;\n\t}\n\tif ((ctxt->sax != NULL) && (ctxt->sax->reference != NULL) &&\n\t    (ctxt->replaceEntities == 0) && (!ctxt->disableSAX)) {\n\t    /*\n\t     * Entity reference callback comes second, it's somewhat\n\t     * superfluous but a compatibility to historical behaviour\n\t     */\n\t    ctxt->sax->reference(ctxt->userData, ent->name);\n\t}\n\treturn;\n    }\n\n    /*\n     * We also check for amplification if entities aren't substituted.\n     * They might be expanded later.\n     */\n    if ((was_checked != 0) &&\n        (xmlParserEntityCheck(ctxt, ent->expandedSize)))\n        return;\n\n    /*\n     * If we didn't get any children for the entity being built\n     */\n    if ((ctxt->sax != NULL) && (ctxt->sax->reference != NULL) &&\n\t(ctxt->replaceEntities == 0) && (!ctxt->disableSAX)) {\n\t/*\n\t * Create a node.\n\t */\n\tctxt->sax->reference(ctxt->userData, ent->name);\n\treturn;\n    }\n\n    if (ctxt->replaceEntities)  {\n\t/*\n\t * There is a problem on the handling of _private for entities\n\t * (bug 155816): Should we copy the content of the field from\n\t * the entity (possibly overwriting some value set by the user\n\t * when a copy is created), should we leave it alone, or should\n\t * we try to take care of different situations?  The problem\n\t * is exacerbated by the usage of this field by the xmlReader.\n\t * To fix this bug, we look at _private on the created node\n\t * and, if it's NULL, we copy in whatever was in the entity.\n\t * If it's not NULL we leave it alone.  This is somewhat of a\n\t * hack - maybe we should have further tests to determine\n\t * what to do.\n\t */\n\tif (ctxt->node != NULL) {\n\t    /*\n\t     * Seems we are generating the DOM content, do\n\t     * a simple tree copy for all references except the first\n\t     * In the first occurrence list contains the replacement.\n\t     */\n\t    if (((list == NULL) && (ent->owner == 0)) ||\n\t\t(ctxt->parseMode == XML_PARSE_READER)) {\n\t\txmlNodePtr nw = NULL, cur, firstChild = NULL;\n\n\t\t/*\n\t\t * when operating on a reader, the entities definitions\n\t\t * are always owning the entities subtree.\n\t\tif (ctxt->parseMode == XML_PARSE_READER)\n\t\t    ent->owner = 1;\n\t\t */\n\n\t\tcur = ent->children;\n\t\twhile (cur != NULL) {\n\t\t    nw = xmlDocCopyNode(cur, ctxt->myDoc, 1);\n\t\t    if (nw != NULL) {\n\t\t\tif (nw->_private == NULL)\n\t\t\t    nw->_private = cur->_private;\n\t\t\tif (firstChild == NULL){\n\t\t\t    firstChild = nw;\n\t\t\t}\n\t\t\tnw = xmlAddChild(ctxt->node, nw);\n\t\t    }\n\t\t    if (cur == ent->last) {\n\t\t\t/*\n\t\t\t * needed to detect some strange empty\n\t\t\t * node cases in the reader tests\n\t\t\t */\n\t\t\tif ((ctxt->parseMode == XML_PARSE_READER) &&\n\t\t\t    (nw != NULL) &&\n\t\t\t    (nw->type == XML_ELEMENT_NODE) &&\n\t\t\t    (nw->children == NULL))\n\t\t\t    nw->extra = 1;\n\n\t\t\tbreak;\n\t\t    }\n\t\t    cur = cur->next;\n\t\t}\n#ifdef LIBXML_LEGACY_ENABLED\n\t\tif (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)\n\t\t  xmlAddEntityReference(ent, firstChild, nw);\n#endif /* LIBXML_LEGACY_ENABLED */\n\t    } else if ((list == NULL) || (ctxt->inputNr > 0)) {\n\t\txmlNodePtr nw = NULL, cur, next, last,\n\t\t\t   firstChild = NULL;\n\n\t\t/*\n\t\t * Copy the entity child list and make it the new\n\t\t * entity child list. The goal is to make sure any\n\t\t * ID or REF referenced will be the one from the\n\t\t * document content and not the entity copy.\n\t\t */\n\t\tcur = ent->children;\n\t\tent->children = NULL;\n\t\tlast = ent->last;\n\t\tent->last = NULL;\n\t\twhile (cur != NULL) {\n\t\t    next = cur->next;\n\t\t    cur->next = NULL;\n\t\t    cur->parent = NULL;\n\t\t    nw = xmlDocCopyNode(cur, ctxt->myDoc, 1);\n\t\t    if (nw != NULL) {\n\t\t\tif (nw->_private == NULL)\n\t\t\t    nw->_private = cur->_private;\n\t\t\tif (firstChild == NULL){\n\t\t\t    firstChild = cur;\n\t\t\t}\n\t\t\txmlAddChild((xmlNodePtr) ent, nw);\n\t\t    }\n\t\t    xmlAddChild(ctxt->node, cur);\n\t\t    if (cur == last)\n\t\t\tbreak;\n\t\t    cur = next;\n\t\t}\n\t\tif (ent->owner == 0)\n\t\t    ent->owner = 1;\n#ifdef LIBXML_LEGACY_ENABLED\n\t\tif (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)\n\t\t  xmlAddEntityReference(ent, firstChild, nw);\n#endif /* LIBXML_LEGACY_ENABLED */\n\t    } else {\n\t\tconst xmlChar *nbktext;\n\n\t\t/*\n\t\t * the name change is to avoid coalescing of the\n\t\t * node with a possible previous text one which\n\t\t * would make ent->children a dangling pointer\n\t\t */\n\t\tnbktext = xmlDictLookup(ctxt->dict, BAD_CAST \"nbktext\",\n\t\t\t\t\t-1);\n\t\tif (ent->children->type == XML_TEXT_NODE)\n\t\t    ent->children->name = nbktext;\n\t\tif ((ent->last != ent->children) &&\n\t\t    (ent->last->type == XML_TEXT_NODE))\n\t\t    ent->last->name = nbktext;\n\t\txmlAddChildList(ctxt->node, ent->children);\n\t    }\n\n\t    /*\n\t     * This is to avoid a nasty side effect, see\n\t     * characters() in SAX.c\n\t     */\n\t    ctxt->nodemem = 0;\n\t    ctxt->nodelen = 0;\n\t    return;\n\t}\n    }\n}\nstatic xmlParserErrors\nxmlParseBalancedChunkMemoryInternal(xmlParserCtxtPtr oldctxt,\n\tconst xmlChar *string, void *user_data, xmlNodePtr *lst) {\n    xmlParserCtxtPtr ctxt;\n    xmlDocPtr newDoc = NULL;\n    xmlNodePtr newRoot;\n    xmlSAXHandlerPtr oldsax = NULL;\n    xmlNodePtr content = NULL;\n    xmlNodePtr last = NULL;\n    xmlParserErrors ret = XML_ERR_OK;\n#if 0\n    unsigned i;\n#endif\n\n    if (((oldctxt->depth > 40) && ((oldctxt->options & XML_PARSE_HUGE) == 0)) ||\n        (oldctxt->depth >  100)) {\n\txmlFatalErrMsg(oldctxt, XML_ERR_ENTITY_LOOP,\n                       \"Maximum entity nesting depth exceeded\");\n\treturn(XML_ERR_ENTITY_LOOP);\n    }\n\n\n    if (lst != NULL)\n        *lst = NULL;\n    if (string == NULL)\n        return(XML_ERR_INTERNAL_ERROR);\n\n    ctxt = xmlCreateDocParserCtxt(string);\n    if (ctxt == NULL) return(XML_WAR_UNDECLARED_ENTITY);\n    ctxt->nbErrors = oldctxt->nbErrors;\n    ctxt->nbWarnings = oldctxt->nbWarnings;\n    if (user_data != NULL)\n\tctxt->userData = user_data;\n    else\n\tctxt->userData = ctxt;\n    if (ctxt->dict != NULL) xmlDictFree(ctxt->dict);\n    ctxt->dict = oldctxt->dict;\n    ctxt->input_id = oldctxt->input_id;\n    ctxt->str_xml = xmlDictLookup(ctxt->dict, BAD_CAST \"xml\", 3);\n    ctxt->str_xmlns = xmlDictLookup(ctxt->dict, BAD_CAST \"xmlns\", 5);\n    ctxt->str_xml_ns = xmlDictLookup(ctxt->dict, XML_XML_NAMESPACE, 36);\n\n    /*\n     * Propagate namespaces down the entity\n     *\n     * This is disabled for now. The pre-2.12 code was already broken\n     * since the SAX handler was using xmlSearchNs which didn't see the\n     * namespaces added here.\n     *\n     * Making entities and namespaces work correctly requires additional\n     * changes, see xmlParseReference.\n     */\n#if 0\n    for (i = 0; i < oldctxt->nsdb->hashSize; i++) {\n        xmlParserNsBucket *bucket = &oldctxt->nsdb->hash[i];\n        xmlHashedString hprefix, huri;\n        const xmlChar **ns;\n        xmlParserNsExtra *extra;\n        unsigned nsIndex;\n\n        if ((bucket->hashValue != 0) &&\n            (bucket->index != INT_MAX)) {\n            nsIndex = bucket->index;\n            ns = &oldctxt->nsTab[nsIndex * 2];\n            extra = &oldctxt->nsdb->extra[nsIndex];\n\n            hprefix.name = ns[0];\n            hprefix.hashValue = bucket->hashValue;\n            huri.name = ns[1];\n            huri.hashValue = extra->uriHashValue;\n            xmlParserNsPush(ctxt, &hprefix, &huri, extra->saxData, 0);\n        }\n    }\n#endif\n\n    oldsax = ctxt->sax;\n    ctxt->sax = oldctxt->sax;\n    xmlDetectSAX2(ctxt);\n    ctxt->replaceEntities = oldctxt->replaceEntities;\n    ctxt->options = oldctxt->options;\n\n    ctxt->_private = oldctxt->_private;\n    if (oldctxt->myDoc == NULL) {\n\tnewDoc = xmlNewDoc(BAD_CAST \"1.0\");\n\tif (newDoc == NULL) {\n            ret = XML_ERR_INTERNAL_ERROR;\n            goto error;\n\t}\n\tnewDoc->properties = XML_DOC_INTERNAL;\n\tnewDoc->dict = ctxt->dict;\n\txmlDictReference(newDoc->dict);\n\tctxt->myDoc = newDoc;\n    } else {\n\tctxt->myDoc = oldctxt->myDoc;\n        content = ctxt->myDoc->children;\n\tlast = ctxt->myDoc->last;\n    }\n    newRoot = xmlNewDocNode(ctxt->myDoc, NULL, BAD_CAST \"pseudoroot\", NULL);\n    if (newRoot == NULL) {\n        ret = XML_ERR_INTERNAL_ERROR;\n        goto error;\n    }\n    ctxt->myDoc->children = NULL;\n    ctxt->myDoc->last = NULL;\n    xmlAddChild((xmlNodePtr) ctxt->myDoc, newRoot);\n    nodePush(ctxt, ctxt->myDoc->children);\n    ctxt->instate = XML_PARSER_CONTENT;\n    ctxt->depth = oldctxt->depth;\n\n    ctxt->validate = 0;\n    ctxt->loadsubset = oldctxt->loadsubset;\n    if ((oldctxt->validate) || (oldctxt->replaceEntities != 0)) {\n\t/*\n\t * ID/IDREF registration will be done in xmlValidateElement below\n\t */\n\tctxt->loadsubset |= XML_SKIP_IDS;\n    }\n    ctxt->dictNames = oldctxt->dictNames;\n    ctxt->attsDefault = oldctxt->attsDefault;\n    ctxt->attsSpecial = oldctxt->attsSpecial;\n\n    xmlParseContent(ctxt);\n    if ((RAW == '<') && (NXT(1) == '/')) {\n\txmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);\n    } else if (RAW != 0) {\n\txmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, NULL);\n    }\n    if (ctxt->node != ctxt->myDoc->children) {\n\txmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);\n    }\n\n    if (!ctxt->wellFormed) {\n\tret = (xmlParserErrors)ctxt->errNo;\n        oldctxt->errNo = ctxt->errNo;\n        oldctxt->wellFormed = 0;\n        xmlCopyError(&ctxt->lastError, &oldctxt->lastError);\n    } else {\n        ret = XML_ERR_OK;\n    }\n\n    if ((lst != NULL) && (ret == XML_ERR_OK)) {\n\txmlNodePtr cur;\n\n\t/*\n\t * Return the newly created nodeset after unlinking it from\n\t * they pseudo parent.\n\t */\n\tcur = ctxt->myDoc->children->children;\n\t*lst = cur;\n\twhile (cur != NULL) {\n#ifdef LIBXML_VALID_ENABLED\n\t    if ((oldctxt->validate) && (oldctxt->wellFormed) &&\n\t\t(oldctxt->myDoc) && (oldctxt->myDoc->intSubset) &&\n\t\t(cur->type == XML_ELEMENT_NODE)) {\n\t\toldctxt->valid &= xmlValidateElement(&oldctxt->vctxt,\n\t\t\toldctxt->myDoc, cur);\n\t    }\n#endif /* LIBXML_VALID_ENABLED */\n\t    cur->parent = NULL;\n\t    cur = cur->next;\n\t}\n\tctxt->myDoc->children->children = NULL;\n    }\n    if (ctxt->myDoc != NULL) {\n\txmlFreeNode(ctxt->myDoc->children);\n        ctxt->myDoc->children = content;\n        ctxt->myDoc->last = last;\n    }\n\n    /*\n     * Also record the size of the entity parsed\n     */\n    if (ctxt->input != NULL && oldctxt != NULL) {\n        unsigned long consumed = ctxt->input->consumed;\n\n        xmlSaturatedAddSizeT(&consumed, ctxt->input->cur - ctxt->input->base);\n\n        xmlSaturatedAdd(&oldctxt->sizeentcopy, consumed);\n        xmlSaturatedAdd(&oldctxt->sizeentcopy, ctxt->sizeentcopy);\n    }\n\n    oldctxt->nbErrors = ctxt->nbErrors;\n    oldctxt->nbWarnings = ctxt->nbWarnings;\n\nerror:\n    ctxt->sax = oldsax;\n    ctxt->dict = NULL;\n    ctxt->attsDefault = NULL;\n    ctxt->attsSpecial = NULL;\n    xmlFreeParserCtxt(ctxt);\n    if (newDoc != NULL) {\n\txmlFreeDoc(newDoc);\n    }\n\n    return(ret);\n}\nxmlNodePtr\nxmlStaticCopyNode(xmlNodePtr node, xmlDocPtr doc, xmlNodePtr parent,\n                  int extended) {\n    xmlNodePtr ret;\n\n    if (node == NULL) return(NULL);\n    switch (node->type) {\n        case XML_TEXT_NODE:\n        case XML_CDATA_SECTION_NODE:\n        case XML_ELEMENT_NODE:\n        case XML_DOCUMENT_FRAG_NODE:\n        case XML_ENTITY_REF_NODE:\n        case XML_ENTITY_NODE:\n        case XML_PI_NODE:\n        case XML_COMMENT_NODE:\n        case XML_XINCLUDE_START:\n        case XML_XINCLUDE_END:\n\t    break;\n        case XML_ATTRIBUTE_NODE:\n\t\treturn((xmlNodePtr) xmlCopyPropInternal(doc, parent, (xmlAttrPtr) node));\n        case XML_NAMESPACE_DECL:\n\t    return((xmlNodePtr) xmlCopyNamespaceList((xmlNsPtr) node));\n\n        case XML_DOCUMENT_NODE:\n        case XML_HTML_DOCUMENT_NODE:\n#ifdef LIBXML_TREE_ENABLED\n\t    return((xmlNodePtr) xmlCopyDoc((xmlDocPtr) node, extended));\n#endif /* LIBXML_TREE_ENABLED */\n        case XML_DOCUMENT_TYPE_NODE:\n        case XML_NOTATION_NODE:\n        case XML_DTD_NODE:\n        case XML_ELEMENT_DECL:\n        case XML_ATTRIBUTE_DECL:\n        case XML_ENTITY_DECL:\n            return(NULL);\n    }\n\n    /*\n     * Allocate a new node and fill the fields.\n     */\n    ret = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));\n    if (ret == NULL) {\n\txmlTreeErrMemory(\"copying node\");\n\treturn(NULL);\n    }\n    memset(ret, 0, sizeof(xmlNode));\n    ret->type = node->type;\n\n    ret->doc = doc;\n    ret->parent = parent;\n    if (node->name == xmlStringText)\n\tret->name = xmlStringText;\n    else if (node->name == xmlStringTextNoenc)\n\tret->name = xmlStringTextNoenc;\n    else if (node->name == xmlStringComment)\n\tret->name = xmlStringComment;\n    else if (node->name != NULL) {\n        if ((doc != NULL) && (doc->dict != NULL))\n\t    ret->name = xmlDictLookup(doc->dict, node->name, -1);\n\telse\n\t    ret->name = xmlStrdup(node->name);\n    }\n    if ((node->type != XML_ELEMENT_NODE) &&\n\t(node->content != NULL) &&\n\t(node->type != XML_ENTITY_REF_NODE) &&\n\t(node->type != XML_XINCLUDE_END) &&\n\t(node->type != XML_XINCLUDE_START)) {\n\tret->content = xmlStrdup(node->content);\n    }else{\n      if (node->type == XML_ELEMENT_NODE)\n        ret->line = node->line;\n    }\n    if (parent != NULL) {\n\txmlNodePtr tmp;\n\n\t/*\n\t * this is a tricky part for the node register thing:\n\t * in case ret does get coalesced in xmlAddChild\n\t * the deregister-node callback is called; so we register ret now already\n\t */\n\tif ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))\n\t    xmlRegisterNodeDefaultValue((xmlNodePtr)ret);\n\n        /*\n         * Note that since ret->parent is already set, xmlAddChild will\n         * return early and not actually insert the node. It will only\n         * coalesce text nodes and unnecessarily call xmlSetTreeDoc.\n         * Assuming that the subtree to be copied always has its text\n         * nodes coalesced, the somewhat confusing call to xmlAddChild\n         * could be removed.\n         */\n        tmp = xmlAddChild(parent, ret);\n\t/* node could have coalesced */\n\tif (tmp != ret)\n\t    return(tmp);\n    }\n\n    if (!extended)\n\tgoto out;\n    if (((node->type == XML_ELEMENT_NODE) ||\n         (node->type == XML_XINCLUDE_START)) && (node->nsDef != NULL))\n        ret->nsDef = xmlCopyNamespaceList(node->nsDef);\n\n    if (node->ns != NULL) {\n        xmlNsPtr ns;\n\n\tns = xmlSearchNs(doc, ret, node->ns->prefix);\n\tif (ns == NULL) {\n\t    /*\n\t     * Humm, we are copying an element whose namespace is defined\n\t     * out of the new tree scope. Search it in the original tree\n\t     * and add it at the top of the new tree.\n             *\n             * TODO: Searching the original tree seems unnecessary. We\n             * already have a namespace URI.\n\t     */\n\t    ns = xmlSearchNs(node->doc, node, node->ns->prefix);\n\t    if (ns != NULL) {\n\t        xmlNodePtr root = ret;\n\n\t\twhile (root->parent != NULL) root = root->parent;\n\t\tret->ns = xmlNewNs(root, ns->href, ns->prefix);\n            } else {\n                ret->ns = xmlNewReconciledNs(doc, ret, node->ns);\n\t    }\n\t} else {\n\t    /*\n\t     * reference the existing namespace definition in our own tree.\n\t     */\n\t    ret->ns = ns;\n\t}\n    }\n    if (((node->type == XML_ELEMENT_NODE) ||\n         (node->type == XML_XINCLUDE_START)) && (node->properties != NULL))\n        ret->properties = xmlCopyPropList(ret, node->properties);\n    if (node->type == XML_ENTITY_REF_NODE) {\n\tif ((doc == NULL) || (node->doc != doc)) {\n\t    /*\n\t     * The copied node will go into a separate document, so\n\t     * to avoid dangling references to the ENTITY_DECL node\n\t     * we cannot keep the reference. Try to find it in the\n\t     * target document.\n\t     */\n\t    ret->children = (xmlNodePtr) xmlGetDocEntity(doc, ret->name);\n\t} else {\n            ret->children = node->children;\n\t}\n\tret->last = ret->children;\n    } else if ((node->children != NULL) && (extended != 2)) {\n        xmlNodePtr cur, insert;\n\n        cur = node->children;\n        insert = ret;\n        while (cur != NULL) {\n            xmlNodePtr copy = xmlStaticCopyNode(cur, doc, insert, 2);\n            if (copy == NULL) {\n                xmlFreeNode(ret);\n                return(NULL);\n            }\n\n            /* Check for coalesced text nodes */\n            if (insert->last != copy) {\n                if (insert->last == NULL) {\n                    insert->children = copy;\n                } else {\n                    copy->prev = insert->last;\n                    insert->last->next = copy;\n                }\n                insert->last = copy;\n            }\n\n            if ((cur->type != XML_ENTITY_REF_NODE) &&\n                (cur->children != NULL)) {\n                cur = cur->children;\n                insert = copy;\n                continue;\n            }\n\n            while (1) {\n                if (cur->next != NULL) {\n                    cur = cur->next;\n                    break;\n                }\n\n                cur = cur->parent;\n                insert = insert->parent;\n                if (cur == node) {\n                    cur = NULL;\n                    break;\n                }\n            }\n        }\n    }\n\nout:\n    /* if parent != NULL we already registered the node above */\n    if ((parent == NULL) &&\n        ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue)))\n\txmlRegisterNodeDefaultValue((xmlNodePtr)ret);\n    return(ret);\n}\nxmlNodePtr\nxmlDocCopyNode(xmlNodePtr node, xmlDocPtr doc, int extended) {\n    xmlNodePtr ret;\n\n    ret = xmlStaticCopyNode(node, doc, NULL, extended);\n    return(ret);\n}\nint\nxmlParseChunk(xmlParserCtxtPtr ctxt, const char *chunk, int size,\n              int terminate) {\n    int end_in_lf = 0;\n\n    if (ctxt == NULL)\n        return(XML_ERR_INTERNAL_ERROR);\n    if ((ctxt->errNo != XML_ERR_OK) && (ctxt->disableSAX == 1))\n        return(ctxt->errNo);\n    if (ctxt->instate == XML_PARSER_EOF)\n        return(-1);\n    if (ctxt->input == NULL)\n        return(-1);\n\n    ctxt->progressive = 1;\n    if (ctxt->instate == XML_PARSER_START)\n        xmlDetectSAX2(ctxt);\n    if ((size > 0) && (chunk != NULL) && (!terminate) &&\n        (chunk[size - 1] == '\\r')) {\n\tend_in_lf = 1;\n\tsize--;\n    }\n\n    if ((size > 0) && (chunk != NULL) && (ctxt->input != NULL) &&\n        (ctxt->input->buf != NULL) && (ctxt->instate != XML_PARSER_EOF))  {\n\tsize_t pos = ctxt->input->cur - ctxt->input->base;\n\tint res;\n\n\tres = xmlParserInputBufferPush(ctxt->input->buf, size, chunk);\n        xmlBufUpdateInput(ctxt->input->buf->buffer, ctxt->input, pos);\n\tif (res < 0) {\n            xmlFatalErr(ctxt, ctxt->input->buf->error, NULL);\n\t    xmlHaltParser(ctxt);\n\t    return(ctxt->errNo);\n\t}\n    }\n\n    xmlParseTryOrFinish(ctxt, terminate);\n    if (ctxt->instate == XML_PARSER_EOF)\n        return(ctxt->errNo);\n\n    if ((ctxt->input != NULL) &&\n         (((ctxt->input->end - ctxt->input->cur) > XML_MAX_LOOKUP_LIMIT) ||\n         ((ctxt->input->cur - ctxt->input->base) > XML_MAX_LOOKUP_LIMIT)) &&\n        ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n        xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, \"Huge input lookup\");\n        xmlHaltParser(ctxt);\n    }\n    if ((ctxt->errNo != XML_ERR_OK) && (ctxt->disableSAX == 1))\n        return(ctxt->errNo);\n\n    if ((end_in_lf == 1) && (ctxt->input != NULL) &&\n        (ctxt->input->buf != NULL)) {\n\tsize_t pos = ctxt->input->cur - ctxt->input->base;\n        int res;\n\n\tres = xmlParserInputBufferPush(ctxt->input->buf, 1, \"\\r\");\n\txmlBufUpdateInput(ctxt->input->buf->buffer, ctxt->input, pos);\n        if (res < 0) {\n            xmlFatalErr(ctxt, ctxt->input->buf->error, NULL);\n            xmlHaltParser(ctxt);\n            return(ctxt->errNo);\n        }\n    }\n    if (terminate) {\n\t/*\n\t * Check for termination\n\t */\n        if ((ctxt->instate != XML_PARSER_EOF) &&\n            (ctxt->instate != XML_PARSER_EPILOG)) {\n            if (ctxt->nameNr > 0) {\n                const xmlChar *name = ctxt->nameTab[ctxt->nameNr - 1];\n                int line = ctxt->pushTab[ctxt->nameNr - 1].line;\n                xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NOT_FINISHED,\n                        \"Premature end of data in tag %s line %d\\n\",\n                        name, line, NULL);\n            } else if (ctxt->instate == XML_PARSER_START) {\n                xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);\n            } else {\n                xmlFatalErrMsg(ctxt, XML_ERR_DOCUMENT_EMPTY,\n                               \"Start tag expected, '<' not found\\n\");\n            }\n        } else if ((ctxt->input->buf != NULL) &&\n                   (ctxt->input->buf->encoder != NULL) &&\n                   (!xmlBufIsEmpty(ctxt->input->buf->raw))) {\n            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n                           \"Truncated multi-byte sequence at EOF\\n\");\n        }\n\tif (ctxt->instate != XML_PARSER_EOF) {\n\t    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n\t\tctxt->sax->endDocument(ctxt->userData);\n\t}\n\tctxt->instate = XML_PARSER_EOF;\n    }\n    if (ctxt->wellFormed == 0)\n\treturn((xmlParserErrors) ctxt->errNo);\n    else\n        return(0);\n}\nstatic int\nxmlTextReaderPushData(xmlTextReaderPtr reader) {\n    xmlBufPtr inbuf;\n    int val, s;\n    xmlTextReaderState oldstate;\n\n    if ((reader->input == NULL) || (reader->input->buffer == NULL))\n\treturn(-1);\n\n    oldstate = reader->state;\n    reader->state = XML_TEXTREADER_NONE;\n    inbuf = reader->input->buffer;\n\n    while (reader->state == XML_TEXTREADER_NONE) {\n\tif (xmlBufUse(inbuf) < reader->cur + CHUNK_SIZE) {\n\t    /*\n\t     * Refill the buffer unless we are at the end of the stream\n\t     */\n\t    if (reader->mode != XML_TEXTREADER_MODE_EOF) {\n\t\tval = xmlParserInputBufferRead(reader->input, 4096);\n\t\tif (val == 0) {\n\t\t    if (xmlBufUse(inbuf) == reader->cur) {\n\t\t\treader->mode = XML_TEXTREADER_MODE_EOF;\n                        break;\n\t\t    }\n\t\t} else if (val < 0) {\n                    xmlGenericError(xmlGenericErrorContext,\n                                    \"xmlParserInputBufferRead failed\\n\");\n\t\t    reader->mode = XML_TEXTREADER_MODE_EOF;\n\t\t    reader->state = oldstate;\n\t\t    return(val);\n\t\t}\n\n\t    } else\n\t\tbreak;\n\t}\n\t/*\n\t * parse by block of CHUNK_SIZE bytes, various tests show that\n\t * it's the best tradeoff at least on a 1.2GH Duron\n\t */\n\tif (xmlBufUse(inbuf) >= reader->cur + CHUNK_SIZE) {\n\t    val = xmlParseChunk(reader->ctxt,\n                 (const char *) xmlBufContent(inbuf) + reader->cur,\n                                CHUNK_SIZE, 0);\n\t    reader->cur += CHUNK_SIZE;\n\t    if (val != 0)\n\t\treader->ctxt->wellFormed = 0;\n\t    if (reader->ctxt->wellFormed == 0)\n\t\tbreak;\n\t} else {\n\t    s = xmlBufUse(inbuf) - reader->cur;\n\t    val = xmlParseChunk(reader->ctxt,\n\t\t (const char *) xmlBufContent(inbuf) + reader->cur,\n\t\t\t        s, 0);\n\t    reader->cur += s;\n\t    if (val != 0)\n\t\treader->ctxt->wellFormed = 0;\n\t    break;\n\t}\n    }\n    reader->state = oldstate;\n\n    /*\n     * Discard the consumed input when needed and possible\n     */\n    if (reader->mode == XML_TEXTREADER_MODE_INTERACTIVE) {\n        if (reader->input->readcallback != NULL) {\n\t    if ((reader->cur >= 4096) &&\n\t\t(xmlBufUse(inbuf) - reader->cur <= CHUNK_SIZE)) {\n\t\tval = xmlBufShrink(inbuf, reader->cur);\n\t\tif (val >= 0) {\n\t\t    reader->cur -= val;\n\t\t}\n\t    }\n\t}\n    }\n\n    /*\n     * At the end of the stream signal that the work is done to the Push\n     * parser.\n     */\n    else if (reader->mode == XML_TEXTREADER_MODE_EOF) {\n\tif (reader->state != XML_TEXTREADER_DONE) {\n\t    s = xmlBufUse(inbuf) - reader->cur;\n\t    val = xmlParseChunk(reader->ctxt,\n\t\t (const char *) xmlBufContent(inbuf) + reader->cur,\n\t\t\t        s, 1);\n\t    reader->cur = xmlBufUse(inbuf);\n\t    reader->state  = XML_TEXTREADER_DONE;\n\t    if (val != 0) {\n\t        if (reader->ctxt->wellFormed)\n\t\t    reader->ctxt->wellFormed = 0;\n\t\telse\n\t\t    return(-1);\n\t    }\n\t}\n    }\n    if (reader->ctxt->wellFormed == 0) {\n\treader->mode = XML_TEXTREADER_MODE_EOF;\n        return(-1);\n    }\n\n    return(0);\n}\nstatic int\nxmlTextReaderDoExpand(xmlTextReaderPtr reader) {\n    int val;\n\n    if ((reader == NULL) || (reader->node == NULL) || (reader->ctxt == NULL))\n        return(-1);\n    do {\n\tif (reader->ctxt->instate == XML_PARSER_EOF) return(1);\n\n        if (xmlTextReaderGetSuccessor(reader->node) != NULL)\n\t    return(1);\n\tif (reader->ctxt->nodeNr < reader->depth)\n\t    return(1);\n\tif (reader->mode == XML_TEXTREADER_MODE_EOF)\n\t    return(1);\n\tval = xmlTextReaderPushData(reader);\n\tif (val < 0){\n\t    reader->mode = XML_TEXTREADER_MODE_ERROR;\n\t    return(-1);\n\t}\n    } while(reader->mode != XML_TEXTREADER_MODE_EOF);\n    return(1);\n}\nxmlNodePtr\nxmlTextReaderExpand(xmlTextReaderPtr reader) {\n    if ((reader == NULL) || (reader->node == NULL))\n        return(NULL);\n    if (reader->doc != NULL)\n        return(reader->node);\n    if (reader->ctxt == NULL)\n        return(NULL);\n    if (xmlTextReaderDoExpand(reader) < 0)\n        return(NULL);\n    return(reader->node);\n}\nint\nxmlTextReaderRead(xmlTextReaderPtr reader) {\n    int val, olddepth = 0;\n    xmlTextReaderState oldstate = XML_TEXTREADER_START;\n    xmlNodePtr oldnode = NULL;\n\n\n    if (reader == NULL)\n\treturn(-1);\n    reader->curnode = NULL;\n    if (reader->doc != NULL)\n        return(xmlTextReaderReadTree(reader));\n    if (reader->ctxt == NULL)\n\treturn(-1);\n\n    if (reader->mode == XML_TEXTREADER_MODE_INITIAL) {\n\treader->mode = XML_TEXTREADER_MODE_INTERACTIVE;\n\t/*\n\t * Initial state\n\t */\n\tdo {\n\t    val = xmlTextReaderPushData(reader);\n\t\tif (val < 0){\n\t\t\treader->mode = XML_TEXTREADER_MODE_ERROR;\n\t\t\treader->state = XML_TEXTREADER_ERROR;\n\t\treturn(-1);\n\t\t}\n\t} while ((reader->ctxt->node == NULL) &&\n\t\t ((reader->mode != XML_TEXTREADER_MODE_EOF) &&\n\t\t  (reader->state != XML_TEXTREADER_DONE)));\n\tif (reader->ctxt->node == NULL) {\n\t    if (reader->ctxt->myDoc != NULL) {\n\t\treader->node = reader->ctxt->myDoc->children;\n\t    }\n\t    if (reader->node == NULL){\n\t\t\treader->mode = XML_TEXTREADER_MODE_ERROR;\n\t\t\treader->state = XML_TEXTREADER_ERROR;\n\t\treturn(-1);\n\t\t}\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t} else {\n\t    if (reader->ctxt->myDoc != NULL) {\n\t\treader->node = reader->ctxt->myDoc->children;\n\t    }\n\t    if (reader->node == NULL)\n\t\treader->node = reader->ctxt->nodeTab[0];\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t}\n\treader->depth = 0;\n\treader->ctxt->parseMode = XML_PARSE_READER;\n\tgoto node_found;\n    }\n    oldstate = reader->state;\n    olddepth = reader->ctxt->nodeNr;\n    oldnode = reader->node;\n\nget_next_node:\n    if (reader->node == NULL) {\n\tif (reader->mode == XML_TEXTREADER_MODE_EOF)\n\t    return(0);\n\telse\n\t    return(-1);\n    }\n\n    /*\n     * If we are not backtracking on ancestors or examined nodes,\n     * that the parser didn't finished or that we aren't at the end\n     * of stream, continue processing.\n     */\n    while ((reader->node != NULL) && (reader->node->next == NULL) &&\n\t   (reader->ctxt->nodeNr == olddepth) &&\n           ((oldstate == XML_TEXTREADER_BACKTRACK) ||\n            (reader->node->children == NULL) ||\n\t    (reader->node->type == XML_ENTITY_REF_NODE) ||\n\t    ((reader->node->children != NULL) &&\n\t     (reader->node->children->type == XML_TEXT_NODE) &&\n\t     (reader->node->children->next == NULL)) ||\n\t    (reader->node->type == XML_DTD_NODE) ||\n\t    (reader->node->type == XML_DOCUMENT_NODE) ||\n\t    (reader->node->type == XML_HTML_DOCUMENT_NODE)) &&\n\t   ((reader->ctxt->node == NULL) ||\n\t    (reader->ctxt->node == reader->node) ||\n\t    (reader->ctxt->node == reader->node->parent)) &&\n\t   (reader->ctxt->instate != XML_PARSER_EOF)) {\n\tval = xmlTextReaderPushData(reader);\n\tif (val < 0){\n\t\treader->mode = XML_TEXTREADER_MODE_ERROR;\n\t\treader->state = XML_TEXTREADER_ERROR;\n\t    return(-1);\n\t}\n\tif (reader->node == NULL)\n\t    goto node_end;\n    }\n    if (oldstate != XML_TEXTREADER_BACKTRACK) {\n\tif ((reader->node->children != NULL) &&\n\t    (reader->node->type != XML_ENTITY_REF_NODE) &&\n\t    (reader->node->type != XML_XINCLUDE_START) &&\n\t    (reader->node->type != XML_DTD_NODE)) {\n\t    reader->node = reader->node->children;\n\t    reader->depth++;\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t    goto node_found;\n\t}\n    }\n    if (reader->node->next != NULL) {\n\tif ((oldstate == XML_TEXTREADER_ELEMENT) &&\n            (reader->node->type == XML_ELEMENT_NODE) &&\n\t    (reader->node->children == NULL) &&\n\t    ((reader->node->extra & NODE_IS_EMPTY) == 0)\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    && (reader->in_xinclude <= 0)\n#endif\n\t    ) {\n\t    reader->state = XML_TEXTREADER_END;\n\t    goto node_found;\n\t}\n#ifdef LIBXML_REGEXP_ENABLED\n\tif ((reader->validate) &&\n\t    (reader->node->type == XML_ELEMENT_NODE))\n\t    xmlTextReaderValidatePop(reader);\n#endif /* LIBXML_REGEXP_ENABLED */\n        if ((reader->preserves > 0) &&\n\t    (reader->node->extra & NODE_IS_SPRESERVED))\n\t    reader->preserves--;\n\treader->node = reader->node->next;\n\treader->state = XML_TEXTREADER_ELEMENT;\n\n\t/*\n\t * Cleanup of the old node\n\t */\n\tif ((reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    (reader->in_xinclude == 0) &&\n#endif\n\t    (reader->entNr == 0) &&\n\t    (reader->node->prev != NULL) &&\n            (reader->node->prev->type != XML_DTD_NODE)) {\n\t    xmlNodePtr tmp = reader->node->prev;\n\t    if ((tmp->extra & NODE_IS_PRESERVED) == 0) {\n                if (oldnode == tmp)\n                    oldnode = NULL;\n\t\txmlUnlinkNode(tmp);\n\t\txmlTextReaderFreeNode(reader, tmp);\n\t    }\n\t}\n\n\tgoto node_found;\n    }\n    if ((oldstate == XML_TEXTREADER_ELEMENT) &&\n\t(reader->node->type == XML_ELEMENT_NODE) &&\n\t(reader->node->children == NULL) &&\n\t((reader->node->extra & NODE_IS_EMPTY) == 0)) {;\n\treader->state = XML_TEXTREADER_END;\n\tgoto node_found;\n    }\n#ifdef LIBXML_REGEXP_ENABLED\n    if ((reader->validate != XML_TEXTREADER_NOT_VALIDATE) && (reader->node->type == XML_ELEMENT_NODE))\n\txmlTextReaderValidatePop(reader);\n#endif /* LIBXML_REGEXP_ENABLED */\n    if ((reader->preserves > 0) &&\n\t(reader->node->extra & NODE_IS_SPRESERVED))\n\treader->preserves--;\n    reader->node = reader->node->parent;\n    if ((reader->node == NULL) ||\n\t(reader->node->type == XML_DOCUMENT_NODE) ||\n\t(reader->node->type == XML_HTML_DOCUMENT_NODE)) {\n\tif (reader->mode != XML_TEXTREADER_MODE_EOF) {\n\t    val = xmlParseChunk(reader->ctxt, \"\", 0, 1);\n\t    reader->state = XML_TEXTREADER_DONE;\n\t    if (val != 0)\n\t        return(-1);\n\t}\n\treader->node = NULL;\n\treader->depth = -1;\n\n\t/*\n\t * Cleanup of the old node\n\t */\n\tif ((oldnode != NULL) && (reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    (reader->in_xinclude == 0) &&\n#endif\n\t    (reader->entNr == 0) &&\n\t    (oldnode->type != XML_DTD_NODE) &&\n\t    ((oldnode->extra & NODE_IS_PRESERVED) == 0)) {\n\t    xmlUnlinkNode(oldnode);\n\t    xmlTextReaderFreeNode(reader, oldnode);\n\t}\n\n\tgoto node_end;\n    }\n    if ((reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n        (reader->in_xinclude == 0) &&\n#endif\n\t(reader->entNr == 0) &&\n        (reader->node->last != NULL) &&\n        ((reader->node->last->extra & NODE_IS_PRESERVED) == 0)) {\n\txmlNodePtr tmp = reader->node->last;\n\txmlUnlinkNode(tmp);\n\txmlTextReaderFreeNode(reader, tmp);\n    }\n    reader->depth--;\n    reader->state = XML_TEXTREADER_BACKTRACK;\n\nnode_found:\n    /*\n     * If we are in the middle of a piece of CDATA make sure it's finished\n     */\n    if ((reader->node != NULL) &&\n        (reader->node->next == NULL) &&\n        ((reader->node->type == XML_TEXT_NODE) ||\n\t (reader->node->type == XML_CDATA_SECTION_NODE))) {\n            if (xmlTextReaderExpand(reader) == NULL)\n\t        return -1;\n    }\n\n#ifdef LIBXML_XINCLUDE_ENABLED\n    /*\n     * Handle XInclude if asked for\n     */\n    if ((reader->xinclude) && (reader->in_xinclude == 0) &&\n        (reader->node != NULL) &&\n\t(reader->node->type == XML_ELEMENT_NODE) &&\n\t(reader->node->ns != NULL) &&\n\t((xmlStrEqual(reader->node->ns->href, XINCLUDE_NS)) ||\n\t (xmlStrEqual(reader->node->ns->href, XINCLUDE_OLD_NS)))) {\n\tif (reader->xincctxt == NULL) {\n\t    reader->xincctxt = xmlXIncludeNewContext(reader->ctxt->myDoc);\n\t    xmlXIncludeSetFlags(reader->xincctxt,\n\t                        reader->parserFlags & (~XML_PARSE_NOXINCNODE));\n            xmlXIncludeSetStreamingMode(reader->xincctxt, 1);\n\t}\n\t/*\n\t * expand that node and process it\n\t */\n\tif (xmlTextReaderExpand(reader) == NULL)\n\t    return -1;\n\txmlXIncludeProcessNode(reader->xincctxt, reader->node);\n    }\n    if ((reader->node != NULL) && (reader->node->type == XML_XINCLUDE_START)) {\n        reader->in_xinclude++;\n\tgoto get_next_node;\n    }\n    if ((reader->node != NULL) && (reader->node->type == XML_XINCLUDE_END)) {\n        reader->in_xinclude--;\n\tgoto get_next_node;\n    }\n#endif\n    /*\n     * Handle entities enter and exit when in entity replacement mode\n     */\n    if ((reader->node != NULL) &&\n\t(reader->node->type == XML_ENTITY_REF_NODE) &&\n\t(reader->ctxt != NULL) && (reader->ctxt->replaceEntities == 1)) {\n\tif ((reader->node->children != NULL) &&\n\t    (reader->node->children->type == XML_ENTITY_DECL) &&\n\t    (reader->node->children->children != NULL)) {\n\t    if (xmlTextReaderEntPush(reader, reader->node) < 0)\n                goto get_next_node;\n\t    reader->node = reader->node->children->children;\n\t}\n#ifdef LIBXML_REGEXP_ENABLED\n    } else if ((reader->node != NULL) &&\n\t       (reader->node->type == XML_ENTITY_REF_NODE) &&\n\t       (reader->ctxt != NULL) && (reader->validate)) {\n\txmlTextReaderValidateEntity(reader);\n#endif /* LIBXML_REGEXP_ENABLED */\n    }\n    if ((reader->node != NULL) &&\n\t(reader->node->type == XML_ENTITY_DECL) &&\n\t(reader->ent != NULL) && (reader->ent->children == reader->node)) {\n\treader->node = xmlTextReaderEntPop(reader);\n\treader->depth++;\n        goto get_next_node;\n    }\n#ifdef LIBXML_REGEXP_ENABLED\n    if ((reader->validate != XML_TEXTREADER_NOT_VALIDATE) && (reader->node != NULL)) {\n\txmlNodePtr node = reader->node;\n\n\tif ((node->type == XML_ELEMENT_NODE) &&\n            ((reader->state != XML_TEXTREADER_END) &&\n\t     (reader->state != XML_TEXTREADER_BACKTRACK))) {\n\t    xmlTextReaderValidatePush(reader);\n\t} else if ((node->type == XML_TEXT_NODE) ||\n\t\t   (node->type == XML_CDATA_SECTION_NODE)) {\n            xmlTextReaderValidateCData(reader, node->content,\n\t                               xmlStrlen(node->content));\n\t}\n    }\n#endif /* LIBXML_REGEXP_ENABLED */\n#ifdef LIBXML_PATTERN_ENABLED\n    if ((reader->patternNr > 0) && (reader->state != XML_TEXTREADER_END) &&\n        (reader->state != XML_TEXTREADER_BACKTRACK)) {\n        int i;\n\tfor (i = 0;i < reader->patternNr;i++) {\n\t     if (xmlPatternMatch(reader->patternTab[i], reader->node) == 1) {\n\t         xmlTextReaderPreserve(reader);\n\t\t break;\n             }\n\t}\n    }\n#endif /* LIBXML_PATTERN_ENABLED */\n#ifdef LIBXML_SCHEMAS_ENABLED\n    if ((reader->validate == XML_TEXTREADER_VALIDATE_XSD) &&\n        (reader->xsdValidErrors == 0) &&\n\t(reader->xsdValidCtxt != NULL)) {\n\treader->xsdValidErrors = !xmlSchemaIsValid(reader->xsdValidCtxt);\n    }\n#endif /* LIBXML_PATTERN_ENABLED */\n    return(1);\nnode_end:\n    reader->state = XML_TEXTREADER_DONE;\n    return(0);\n}\nint\nLLVMFuzzerTestOneInput(const char *data, size_t size) {\n    xmlDocPtr doc;\n    const char *docBuffer, *docUrl;\n    size_t maxAlloc, docSize;\n    int opts;\n\n    xmlFuzzDataInit(data, size);\n    opts = (int) xmlFuzzReadInt(4);\n    /*\n     * Disable options that are known to cause timeouts\n     */\n    opts &= ~XML_PARSE_XINCLUDE &\n            ~XML_PARSE_DTDVALID &\n            ~XML_PARSE_SAX1;\n    maxAlloc = xmlFuzzReadInt(4) % (size + 1);\n\n    xmlFuzzReadEntities();\n    docBuffer = xmlFuzzMainEntity(&docSize);\n    docUrl = xmlFuzzMainUrl();\n    if (docBuffer == NULL)\n        goto exit;\n\n    /* Pull parser */\n\n    xmlFuzzMemSetLimit(maxAlloc);\n    doc = xmlReadMemory(docBuffer, docSize, docUrl, NULL, opts);\n\n#ifdef LIBXML_OUTPUT_ENABLED\n    {\n        xmlChar *out;\n        int outSize;\n\n        /* Also test the serializer. */\n        xmlDocDumpMemory(doc, &out, &outSize);\n        xmlFree(out);\n    }\n#endif\n\n    xmlFreeDoc(doc);\n\n    /* Push parser */\n\n#ifdef LIBXML_PUSH_ENABLED\n    {\n        static const size_t maxChunkSize = 128;\n        xmlParserCtxtPtr ctxt;\n        size_t consumed, chunkSize;\n\n        xmlFuzzMemSetLimit(maxAlloc);\n        ctxt = xmlCreatePushParserCtxt(NULL, NULL, NULL, 0, docUrl);\n        if (ctxt == NULL)\n            goto exit;\n        xmlCtxtUseOptions(ctxt, opts);\n\n        for (consumed = 0; consumed < docSize; consumed += chunkSize) {\n            chunkSize = docSize - consumed;\n            if (chunkSize > maxChunkSize)\n                chunkSize = maxChunkSize;\n            xmlParseChunk(ctxt, docBuffer + consumed, chunkSize, 0);\n        }\n\n        xmlParseChunk(ctxt, NULL, 0, 1);\n        xmlFreeDoc(ctxt->myDoc);\n        xmlFreeParserCtxt(ctxt);\n    }\n#endif\n\n    /* Reader */\n\n#ifdef LIBXML_READER_ENABLED\n    {\n        xmlTextReaderPtr reader;\n\n        xmlFuzzMemSetLimit(maxAlloc);\n        reader = xmlReaderForMemory(docBuffer, docSize, NULL, NULL, opts);\n        if (reader == NULL)\n            goto exit;\n        while (xmlTextReaderRead(reader) == 1) {\n            if (xmlTextReaderNodeType(reader) == XML_ELEMENT_NODE) {\n                int i, n = xmlTextReaderAttributeCount(reader);\n                for (i=0; i<n; i++) {\n                    xmlTextReaderMoveToAttributeNo(reader, i);\n                    while (xmlTextReaderReadAttributeValue(reader) == 1);\n                }\n            }\n        }\n        xmlFreeTextReader(reader);\n    }\n#endif\n\nexit:\n    xmlFuzzMemSetLimit(0);\n    xmlFuzzDataCleanup();\n    xmlResetLastError();\n    return(0);\n}",
    "target": 0,
    "idx": 2062996
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "PIX *\npixReadMemBmp(const l_uint8  *cdata,\n              size_t          size)\n{\nl_uint8    pel[4];\nl_uint8   *cmapBuf, *fdata, *data;\nl_int16    bftype, depth, d;\nl_int32    offset, ihbytes, width, height, height_neg, xres, yres;\nl_int32    compression, imagebytes, fdatabytes, cmapbytes, ncolors, maxcolors;\nl_int32    fdatabpl, extrabytes, pixWpl, pixBpl, i, j, k;\nl_uint32  *line, *pixdata, *pword;\nl_int64    npixels;\nBMP_FH    *bmpfh;\n#if defined(__GNUC__)\nBMP_HEADER *bmph;\n#define bmpih (&bmph->bmpih)\n#else\nBMP_IH    *bmpih;\n#endif\nPIX       *pix, *pix1;\nPIXCMAP   *cmap;\n\n    PROCNAME(\"pixReadMemBmp\");\n\n    if (!cdata)\n        return (PIX *)ERROR_PTR(\"cdata not defined\", procName, NULL);\n    if (size < sizeof(BMP_FH) + sizeof(BMP_IH))\n        return (PIX *)ERROR_PTR(\"bmf size error\", procName, NULL);\n\n        /* Verify this is an uncompressed bmp */\n    bmpfh = (BMP_FH *)cdata;\n    bftype = bmpfh->bfType[0] + ((l_int32)bmpfh->bfType[1] << 8);\n    if (bftype != BMP_ID)\n        return (PIX *)ERROR_PTR(\"not bmf format\", procName, NULL);\n#if defined(__GNUC__)\n    bmph = (BMP_HEADER *)bmpfh;\n#else\n    bmpih = (BMP_IH *)(cdata + BMP_FHBYTES);\n#endif\n    compression = convertOnBigEnd32(bmpih->biCompression);\n    if (compression != 0)\n        return (PIX *)ERROR_PTR(\"cannot read compressed BMP files\",\n                                procName, NULL);\n\n        /* Find the offset from the beginning of the file to the image data */\n    offset = bmpfh->bfOffBits[0];\n    offset += (l_int32)bmpfh->bfOffBits[1] << 8;\n    offset += (l_int32)bmpfh->bfOffBits[2] << 16;\n    offset += (l_uint32)bmpfh->bfOffBits[3] << 24;\n\n        /* Read the remaining useful data in the infoheader.\n         * Note that the first 4 bytes give the infoheader size. */\n    ihbytes = convertOnBigEnd32(*(l_uint32 *)(bmpih));\n    width = convertOnBigEnd32(bmpih->biWidth);\n    height = convertOnBigEnd32(bmpih->biHeight);\n    depth = convertOnBigEnd16(bmpih->biBitCount);\n    imagebytes = convertOnBigEnd32(bmpih->biSizeImage);\n    xres = convertOnBigEnd32(bmpih->biXPelsPerMeter);\n    yres = convertOnBigEnd32(bmpih->biYPelsPerMeter);\n\n        /* Some sanity checking.  We impose limits on the image\n         * dimensions, resolution and number of pixels.  We make sure the\n         * file is the correct size to hold the amount of uncompressed data\n         * that is specified in the header.  The number of colormap\n         * entries is checked: it can be either 0 (no cmap) or some\n         * number between 2 and 256.\n         * Note that the imagebytes for uncompressed images is either\n         * 0 or the size of the file data.  (The fact that it can\n         * be 0 is perhaps some legacy glitch). */\n    if (width < 1)\n        return (PIX *)ERROR_PTR(\"width < 1\", procName, NULL);\n    if (width > L_MAX_ALLOWED_WIDTH)\n        return (PIX *)ERROR_PTR(\"width too large\", procName, NULL);\n    if (height == 0 || height < -L_MAX_ALLOWED_HEIGHT ||\n        height > L_MAX_ALLOWED_HEIGHT)\n        return (PIX *)ERROR_PTR(\"invalid height\", procName, NULL);\n    if (xres < 0 || xres > L_MAX_ALLOWED_RES ||\n        yres < 0 || yres > L_MAX_ALLOWED_RES)\n        return (PIX *)ERROR_PTR(\"invalid resolution\", procName, NULL);\n    height_neg = 0;\n    if (height < 0) {\n        height_neg = 1;\n        height = -height;\n    }\n    if (ihbytes != 40 && ihbytes != 108 && ihbytes != 124) {\n        L_ERROR(\"invalid ihbytes = %d; not in {40, 108, 124}\\n\",\n                procName, ihbytes);\n        return NULL;\n    }\n    npixels = 1LL * width * height;\n    if (npixels > L_MAX_ALLOWED_PIXELS)\n        return (PIX *)ERROR_PTR(\"npixels too large\", procName, NULL);\n    if (depth != 1 && depth != 2 && depth != 4 && depth != 8 &&\n        depth != 16 && depth != 24 && depth != 32) {\n        L_ERROR(\"invalid depth = %d; not in {1, 2, 4, 8, 16, 24, 32}\\n\",\n                procName, depth);\n        return NULL;\n    }\n    fdatabpl = 4 * ((1LL * width * depth + 31)/32);\n    fdatabytes = fdatabpl * height;\n    if (imagebytes != 0 && imagebytes != fdatabytes) {\n        L_ERROR(\"invalid imagebytes = %d; not equal to fdatabytes = %d\\n\",\n                procName, imagebytes, fdatabytes);\n        return NULL;\n    }\n\n        /* In the original spec, BITMAPINFOHEADER is 40 bytes.\n         * There have been a number of revisions, to capture more information.\n         * For example, the fifth version, BITMAPV5HEADER, adds 84 bytes\n         * of ICC color profiles.  We use the size of the infoheader\n         * to accommodate these newer formats. */\n    cmapbytes = offset - BMP_FHBYTES - ihbytes;\n    ncolors = cmapbytes / sizeof(RGBA_QUAD);\n    if (ncolors < 0 || ncolors == 1)\n        return (PIX *)ERROR_PTR(\"invalid: cmap size < 0 or 1\", procName, NULL);\n    if (ncolors > 0 && depth > 8)\n        return (PIX *)ERROR_PTR(\"can't have cmap for d > 8\", procName, NULL);\n    maxcolors = (depth <= 8) ? 1 << depth : 256;\n    if (ncolors > maxcolors) {\n        L_ERROR(\"cmap too large for depth %d: ncolors = %d > maxcolors = %d\\n\",\n                procName, depth, ncolors, maxcolors);\n        return NULL;\n    }\n    if (size != 1LL * offset + 1LL * fdatabytes)\n        return (PIX *)ERROR_PTR(\"size incommensurate with image data\",\n                                procName,NULL);\n\n        /* Handle the colormap */\n    cmapBuf = NULL;\n    if (ncolors > 0) {\n        if ((cmapBuf = (l_uint8 *)LEPT_CALLOC(ncolors, sizeof(RGBA_QUAD)))\n                 == NULL)\n            return (PIX *)ERROR_PTR(\"cmapBuf alloc fail\", procName, NULL );\n\n            /* Read the colormap entry data from bmp. The RGBA_QUAD colormap\n             * entries are used for both bmp and leptonica colormaps. */\n        memcpy(cmapBuf, cdata + BMP_FHBYTES + ihbytes,\n               ncolors * sizeof(RGBA_QUAD));\n    }\n\n        /* Make a 32 bpp pix if depth is 24 bpp */\n    d = (depth == 24) ? 32 : depth;\n    if ((pix = pixCreate(width, height, d)) == NULL) {\n        LEPT_FREE(cmapBuf);\n        return (PIX *)ERROR_PTR( \"pix not made\", procName, NULL);\n    }\n    pixSetXRes(pix, (l_int32)((l_float32)xres / 39.37 + 0.5));  /* to ppi */\n    pixSetYRes(pix, (l_int32)((l_float32)yres / 39.37 + 0.5));  /* to ppi */\n    pixSetInputFormat(pix, IFF_BMP);\n    pixWpl = pixGetWpl(pix);\n    pixBpl = 4 * pixWpl;\n\n        /* Convert the bmp colormap to a pixcmap */\n    cmap = NULL;\n    if (ncolors > 0) {  /* import the colormap to the pix cmap */\n        cmap = pixcmapCreate(L_MIN(d, 8));\n        LEPT_FREE(cmap->array);  /* remove generated cmap array */\n        cmap->array  = (void *)cmapBuf;  /* and replace */\n        cmap->n = L_MIN(ncolors, 256);\n        for (i = 0; i < cmap->n; i++)   /* set all colors opaque */\n            pixcmapSetAlpha (cmap, i, 255);\n    }\n    pixSetColormap(pix, cmap);\n\n        /* Acquire the image data.  Image origin for bmp is at lower right. */\n    fdata = (l_uint8 *)cdata + offset;  /* start of the bmp image data */\n    pixdata = pixGetData(pix);\n    if (depth != 24) {  /* typ. 1 or 8 bpp */\n        data = (l_uint8 *)pixdata + pixBpl * (height - 1);\n        for (i = 0; i < height; i++) {\n            memcpy(data, fdata, fdatabpl);\n            fdata += fdatabpl;\n            data -= pixBpl;\n        }\n    } else {  /*  24 bpp file; 32 bpp pix\n             *  Note: for bmp files, pel[0] is blue, pel[1] is green,\n             *  and pel[2] is red.  This is opposite to the storage\n             *  in the pix, which puts the red pixel in the 0 byte,\n             *  the green in the 1 byte and the blue in the 2 byte.\n             *  Note also that all words are endian flipped after\n             *  assignment on L_LITTLE_ENDIAN platforms.\n             *\n             *  We can then make these assignments for little endians:\n             *      SET_DATA_BYTE(pword, 1, pel[0]);      blue\n             *      SET_DATA_BYTE(pword, 2, pel[1]);      green\n             *      SET_DATA_BYTE(pword, 3, pel[2]);      red\n             *  This looks like:\n             *          3  (R)     2  (G)        1  (B)        0\n             *      |-----------|------------|-----------|-----------|\n             *  and after byte flipping:\n             *           3          2  (B)     1  (G)        0  (R)\n             *      |-----------|------------|-----------|-----------|\n             *\n             *  For big endians we set:\n             *      SET_DATA_BYTE(pword, 2, pel[0]);      blue\n             *      SET_DATA_BYTE(pword, 1, pel[1]);      green\n             *      SET_DATA_BYTE(pword, 0, pel[2]);      red\n             *  This looks like:\n             *          0  (R)     1  (G)        2  (B)        3\n             *      |-----------|------------|-----------|-----------|\n             *  so in both cases we get the correct assignment in the PIX.\n             *\n             *  Can we do a platform-independent assignment?\n             *  Yes, set the bytes without using macros:\n             *      *((l_uint8 *)pword) = pel[2];           red\n             *      *((l_uint8 *)pword + 1) = pel[1];       green\n             *      *((l_uint8 *)pword + 2) = pel[0];       blue\n             *  For little endians, before flipping, this looks again like:\n             *          3  (R)     2  (G)        1  (B)        0\n             *      |-----------|------------|-----------|-----------|\n             */\n        extrabytes = fdatabpl - 3 * width;\n        line = pixdata + pixWpl * (height - 1);\n        for (i = 0; i < height; i++) {\n            for (j = 0; j < width; j++) {\n                pword = line + j;\n                memcpy(&pel, fdata, 3);\n                fdata += 3;\n                *((l_uint8 *)pword + COLOR_RED) = pel[2];\n                *((l_uint8 *)pword + COLOR_GREEN) = pel[1];\n                *((l_uint8 *)pword + COLOR_BLUE) = pel[0];\n                    /* should not use alpha byte, but for buggy readers,\n                     * set it to opaque  */\n                *((l_uint8 *)pword + L_ALPHA_CHANNEL) = 255;\n            }\n            if (extrabytes) {\n                for (k = 0; k < extrabytes; k++) {\n                    memcpy(&pel, fdata, 1);\n                    fdata++;\n                }\n            }\n            line -= pixWpl;\n        }\n    }\n\n    pixEndianByteSwap(pix);\n    if (height_neg)\n        pixFlipTB(pix, pix);\n\n        /* ----------------------------------------------\n         * The bmp colormap determines the values of black\n         * and white pixels for binary in the following way:\n         * (a) white = 0 [255], black = 1 [0]\n         *      255, 255, 255, 255, 0, 0, 0, 255\n         * (b) black = 0 [0], white = 1 [255]\n         *      0, 0, 0, 255, 255, 255, 255, 255\n         * We have no need for a 1 bpp pix with a colormap!\n         * Note: the alpha component here is 255 (opaque)\n         * ---------------------------------------------- */\n    if (depth == 1 && cmap) {\n        pix1 = pixRemoveColormap(pix, REMOVE_CMAP_TO_BINARY);\n        pixDestroy(&pix);\n        pix = pix1;  /* rename */\n    }\n\n    return pix;\n}\nPIX *\npixReadMem(const l_uint8  *data,\n           size_t          size)\n{\nl_int32   format, valid;\nPIX      *pix;\nPIXCMAP  *cmap;\n\n    PROCNAME(\"pixReadMem\");\n\n    if (!data)\n        return (PIX *)ERROR_PTR(\"data not defined\", procName, NULL);\n    if (size < 12)\n        return (PIX *)ERROR_PTR(\"size < 12\", procName, NULL);\n    pix = NULL;\n\n    findFileFormatBuffer(data, &format);\n    switch (format)\n    {\n    case IFF_BMP:\n        if ((pix = pixReadMemBmp(data, size)) == NULL )\n            return (PIX *)ERROR_PTR( \"bmp: no pix returned\", procName, NULL);\n        break;\n\n    case IFF_JFIF_JPEG:\n        if ((pix = pixReadMemJpeg(data, size, 0, 1, NULL, 0)) == NULL)\n            return (PIX *)ERROR_PTR( \"jpeg: no pix returned\", procName, NULL);\n        break;\n\n    case IFF_PNG:\n        if ((pix = pixReadMemPng(data, size)) == NULL)\n            return (PIX *)ERROR_PTR(\"png: no pix returned\", procName, NULL);\n        break;\n\n    case IFF_TIFF:\n    case IFF_TIFF_PACKBITS:\n    case IFF_TIFF_RLE:\n    case IFF_TIFF_G3:\n    case IFF_TIFF_G4:\n    case IFF_TIFF_LZW:\n    case IFF_TIFF_ZIP:\n            /* Reading page 0 by default */\n        if ((pix = pixReadMemTiff(data, size, 0)) == NULL)\n            return (PIX *)ERROR_PTR(\"tiff: no pix returned\", procName, NULL);\n        break;\n\n    case IFF_PNM:\n        if ((pix = pixReadMemPnm(data, size)) == NULL)\n            return (PIX *)ERROR_PTR(\"pnm: no pix returned\", procName, NULL);\n        break;\n\n    case IFF_GIF:\n        if ((pix = pixReadMemGif(data, size)) == NULL)\n            return (PIX *)ERROR_PTR(\"gif: no pix returned\", procName, NULL);\n        break;\n\n    case IFF_JP2:\n        if ((pix = pixReadMemJp2k(data, size, 1, NULL, 0, 0)) == NULL)\n            return (PIX *)ERROR_PTR(\"jp2k: no pix returned\", procName, NULL);\n        break;\n\n    case IFF_WEBP:\n        if ((pix = pixReadMemWebP(data, size)) == NULL)\n            return (PIX *)ERROR_PTR(\"webp: no pix returned\", procName, NULL);\n        break;\n\n    case IFF_PS:\n        L_ERROR(\"PostScript reading is not supported\\n\", procName);\n        return NULL;\n\n    case IFF_LPDF:\n        L_ERROR(\"Pdf reading is not supported\\n\", procName);\n        return NULL;\n\n    case IFF_SPIX:\n        if ((pix = pixReadMemSpix(data, size)) == NULL)\n            return (PIX *)ERROR_PTR(\"spix: no pix returned\", procName, NULL);\n        break;\n\n    case IFF_UNKNOWN:\n        return (PIX *)ERROR_PTR(\"Unknown format: no pix returned\",\n                procName, NULL);\n        break;\n    }\n\n        /* Set the input format.  For tiff reading from memory we lose\n         * the actual input format; for 1 bpp, default to G4.  Also\n         * verify that the colormap is valid.  */\n    if (pix) {\n        if (format == IFF_TIFF && pixGetDepth(pix) == 1)\n            format = IFF_TIFF_G4;\n        pixSetInputFormat(pix, format);\n        if ((cmap = pixGetColormap(pix))) {\n            pixcmapIsValid(cmap, &valid);\n            if (!valid) {\n                pixDestroy(&pix);\n                return (PIX *)ERROR_PTR(\"invalid colormap\", procName, NULL);\n            }\n        }\n        pixSetPadBits(pix, 0);\n    }\n    return pix;\n}\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {\n  const int16_t angle = ReadInt16(&data, &size);\n  const int16_t x_center = ReadInt16(&data, &size);\n  const int16_t y_center = ReadInt16(&data, &size);\n\n  // Check for pnm format; this can cause timeouts.\n  // The format checker requires at least 12 bytes.\n  if (size < 12) return EXIT_SUCCESS;\n  int format;\n  findFileFormatBuffer(data, &format);\n  if (format == IFF_PNM) return EXIT_SUCCESS;\n\n  Pix* pix = pixReadMem(reinterpret_cast<const unsigned char*>(data), size);\n  if (pix == nullptr) {\n    return EXIT_SUCCESS;\n  }\n\n  // Never in production\n  if (DebugOutput) {\n    L_INFO(\"w = %d, h = %d, d = %d\\n\", \"fuzzer\",\n           pixGetWidth(pix), pixGetHeight(pix), pixGetDepth(pix));\n  }\n\n  constexpr float deg2rad = M_PI / 180.;\n  Pix* pix_rotated = pixRotateShear(pix, x_center, y_center, deg2rad * angle,\n                                    L_BRING_IN_WHITE);\n  if (pix_rotated) {\n    pixDestroy(&pix_rotated);\n  }\n\n  pixDestroy(&pix);\n  return EXIT_SUCCESS;\n}",
    "target": 0,
    "idx": 2019723
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "R_API void r_core_task_decref (RCoreTask *task) {\n\tif (!task) {\n\t\treturn;\n\t}\n\tTASK_SIGSET_T old_sigset;\n\tRCore *core = task->core;\n\ttasks_lock_enter (core, &old_sigset);\n\ttask->refcount--;\n\tif (task->refcount <= 0) {\n\t\ttask_free (task);\n\t}\n\ttasks_lock_leave (core, &old_sigset);\n}\nR_API void r_list_delete(RList *list, RListIter *iter) {\n\tr_return_if_fail (list && iter);\n\tr_list_split_iter (list, iter);\n\tif (list->free && iter->data) {\n\t\tlist->free (iter->data);\n\t}\n\titer->data = NULL;\n\tR_FREE (iter);\n}\nR_API void r_list_purge(RList *list) {\n\tRListIter *it;\n\n\tr_return_if_fail (list);\n\n\tit = list->head;\n\twhile (it) {\n\t\tRListIter *next = it->n;\n\t\tr_list_delete (list, it);\n\t\tit = next;\n\t}\n\tlist->head = list->tail = NULL;\n}\nR_API void r_list_free(RList *list) {\n\tif (list) {\n\t\tr_list_purge (list);\n\t\tR_FREE (list);\n\t}\n}\nR_API RCore *r_core_fini(RCore *c) {\n\tif (!c) {\n\t\treturn NULL;\n\t}\n\tr_core_task_break_all (c);\n\tr_core_task_join (c, NULL, -1);\n\tr_core_wait (c);\n\t/* TODO: it leaks as shit */\n\t//update_sdb (c);\n\t// avoid double free\n\tr_core_free_autocomplete (c);\n\tr_event_free (c->ev);\n\tR_FREE (c->cmdlog);\n\tr_th_lock_free (c->lock);\n\tR_FREE (c->lastsearch);\n\tR_FREE (c->cons->pager);\n\tR_FREE (c->panels_tmpcfg);\n\tR_FREE (c->cmdqueue);\n\tR_FREE (c->lastcmd);\n\tr_list_free (c->visual.tabs);\n\tR_FREE (c->block);\n\tr_core_autocomplete_free (c->autocomplete);\n\n\tr_list_free (c->undos);\n\tr_num_free (c->num);\n\t// TODO: sync or not? sdb_sync (c->sdb);\n\t// TODO: sync all dbs?\n\t//r_core_file_free (c->file);\n\t//c->file = NULL;\n\tr_list_free (c->files);\n\tr_list_free (c->watchers);\n\tr_list_free (c->scriptstack);\n\tr_list_free (c->tasks);\n\tr_list_free (c->tasks_queue);\n\tr_list_free (c->oneshot_queue);\n\tr_th_lock_free (c->tasks_lock);\n\tc->rcmd = r_cmd_free (c->rcmd);\n\tr_list_free (c->cmd_descriptors);\n\tc->anal = r_anal_free (c->anal);\n\tc->assembler = r_asm_free (c->assembler);\n\tc->print = r_print_free (c->print);\n\tc->bin = r_bin_free (c->bin); // XXX segfaults rabin2 -c\n\tc->lang = r_lang_free (c->lang); // XXX segfaults\n\tc->dbg = r_debug_free (c->dbg);\n\tr_io_free (c->io);\n\tr_config_free (c->config);\n\t/* after r_config_free, the value of I.teefile is trashed */\n\t/* rconfig doesnt knows how to deinitialize vars, so we\n\tshould probably need to add a r_config_free_payload callback */\n\tr_cons_free ();\n\tr_cons_singleton ()->teefile = NULL; // HACK\n\tr_search_free (c->search);\n\tr_flag_free (c->flags);\n\tr_fs_free (c->fs);\n\tr_egg_free (c->egg);\n\tr_lib_free (c->lib);\n\tr_buf_free (c->yank_buf);\n\tr_agraph_free (c->graph);\n\tR_FREE (c->asmqjmps);\n\tsdb_free (c->sdb);\n\tr_core_log_free (c->log);\n\tr_parse_free (c->parser);\n\tR_FREE (c->times);\n\treturn NULL;\n}\nR_API RCore *r_core_free(RCore *c) {\n\t// must wait all threads first\n\tif (c) {\n\t\tr_core_fini (c);\n\t\tfree (c);\n\t}\n\treturn NULL;\n}\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {\n\tRCore *r;\n\tchar path[128];\n\n\tr = r_core_new();\n\n\tr_core_cmdf(r, \"o malloc://%d\", Size);\n\tr_io_write_at(r->io, 0, Data, Size);\n\n\tr_core_cmd0(r, \"oba 0\");\n\tr_core_cmd0(r, \"ia\");\n\n\tr_core_free(r);\n\treturn 0;\n}\nvoid Fuzzer::ExecuteCallback(const uint8_t *Data, size_t Size) {\n  TPC.RecordInitialStack();\n  TotalNumberOfRuns++;\n  assert(InFuzzingThread());\n  if (SMR.IsClient())\n    SMR.WriteByteArray(Data, Size);\n  // We copy the contents of Unit into a separate heap buffer\n  // so that we reliably find buffer overflows in it.\n  uint8_t *DataCopy = new uint8_t[Size];\n  memcpy(DataCopy, Data, Size);\n  if (EF->__msan_unpoison)\n    EF->__msan_unpoison(DataCopy, Size);\n  if (CurrentUnitData && CurrentUnitData != Data)\n    memcpy(CurrentUnitData, Data, Size);\n  CurrentUnitSize = Size;\n  {\n    ScopedEnableMsanInterceptorChecks S;\n    AllocTracer.Start(Options.TraceMalloc);\n    UnitStartTime = system_clock::now();\n    TPC.ResetMaps();\n    RunningUserCallback = true;\n    int Res = CB(DataCopy, Size);\n    RunningUserCallback = false;\n    UnitStopTime = system_clock::now();\n    (void)Res;\n    assert(Res == 0);\n    HasMoreMallocsThanFrees = AllocTracer.Stop();\n  }\n  if (!LooseMemeq(DataCopy, Data, Size))\n    CrashOnOverwrittenData();\n  CurrentUnitSize = 0;\n  delete[] DataCopy;\n}\nint RunOneTest(Fuzzer *F, const char *InputFilePath, size_t MaxLen) {\n  Unit U = FileToVector(InputFilePath);\n  if (MaxLen && MaxLen < U.size())\n    U.resize(MaxLen);\n  F->ExecuteCallback(U.data(), U.size());\n  F->TryDetectingAMemoryLeak(U.data(), U.size(), true);\n  return 0;\n}\nint FuzzerDriver(int *argc, char ***argv, UserCallback Callback) {\n  using namespace fuzzer;\n  assert(argc && argv && \"Argument pointers cannot be nullptr\");\n  std::string Argv0((*argv)[0]);\n  EF = new ExternalFunctions();\n  if (EF->LLVMFuzzerInitialize)\n    EF->LLVMFuzzerInitialize(argc, argv);\n  if (EF->__msan_scoped_disable_interceptor_checks)\n    EF->__msan_scoped_disable_interceptor_checks();\n  const Vector<std::string> Args(*argv, *argv + *argc);\n  assert(!Args.empty());\n  ProgName = new std::string(Args[0]);\n  if (Argv0 != *ProgName) {\n    Printf(\"ERROR: argv[0] has been modified in LLVMFuzzerInitialize\\n\");\n    exit(1);\n  }\n  ParseFlags(Args);\n  if (Flags.help) {\n    PrintHelp();\n    return 0;\n  }\n\n  if (Flags.close_fd_mask & 2)\n    DupAndCloseStderr();\n  if (Flags.close_fd_mask & 1)\n    CloseStdout();\n\n  if (Flags.jobs > 0 && Flags.workers == 0) {\n    Flags.workers = std::min(NumberOfCpuCores() / 2, Flags.jobs);\n    if (Flags.workers > 1)\n      Printf(\"Running %u workers\\n\", Flags.workers);\n  }\n\n  if (Flags.workers > 0 && Flags.jobs > 0)\n    return RunInMultipleProcesses(Args, Flags.workers, Flags.jobs);\n\n  FuzzingOptions Options;\n  Options.Verbosity = Flags.verbosity;\n  Options.MaxLen = Flags.max_len;\n  Options.LenControl = Flags.len_control;\n  Options.UnitTimeoutSec = Flags.timeout;\n  Options.ErrorExitCode = Flags.error_exitcode;\n  Options.TimeoutExitCode = Flags.timeout_exitcode;\n  Options.MaxTotalTimeSec = Flags.max_total_time;\n  Options.DoCrossOver = Flags.cross_over;\n  Options.MutateDepth = Flags.mutate_depth;\n  Options.ReduceDepth = Flags.reduce_depth;\n  Options.UseCounters = Flags.use_counters;\n  Options.UseMemmem = Flags.use_memmem;\n  Options.UseCmp = Flags.use_cmp;\n  Options.UseValueProfile = Flags.use_value_profile;\n  Options.Shrink = Flags.shrink;\n  Options.ReduceInputs = Flags.reduce_inputs;\n  Options.ShuffleAtStartUp = Flags.shuffle;\n  Options.PreferSmall = Flags.prefer_small;\n  Options.ReloadIntervalSec = Flags.reload;\n  Options.OnlyASCII = Flags.only_ascii;\n  Options.DetectLeaks = Flags.detect_leaks;\n  Options.PurgeAllocatorIntervalSec = Flags.purge_allocator_interval;\n  Options.TraceMalloc = Flags.trace_malloc;\n  Options.RssLimitMb = Flags.rss_limit_mb;\n  Options.MallocLimitMb = Flags.malloc_limit_mb;\n  if (!Options.MallocLimitMb)\n    Options.MallocLimitMb = Options.RssLimitMb;\n  if (Flags.runs >= 0)\n    Options.MaxNumberOfRuns = Flags.runs;\n  if (!Inputs->empty() && !Flags.minimize_crash_internal_step)\n    Options.OutputCorpus = (*Inputs)[0];\n  Options.ReportSlowUnits = Flags.report_slow_units;\n  if (Flags.artifact_prefix)\n    Options.ArtifactPrefix = Flags.artifact_prefix;\n  if (Flags.exact_artifact_path)\n    Options.ExactArtifactPath = Flags.exact_artifact_path;\n  Vector<Unit> Dictionary;\n  if (Flags.dict)\n    if (!ParseDictionaryFile(FileToString(Flags.dict), &Dictionary))\n      return 1;\n  if (Flags.verbosity > 0 && !Dictionary.empty())\n    Printf(\"Dictionary: %zd entries\\n\", Dictionary.size());\n  bool DoPlainRun = AllInputsAreFiles();\n  Options.SaveArtifacts =\n      !DoPlainRun || Flags.minimize_crash_internal_step;\n  Options.PrintNewCovPcs = Flags.print_pcs;\n  Options.PrintNewCovFuncs = Flags.print_funcs;\n  Options.PrintFinalStats = Flags.print_final_stats;\n  Options.PrintCorpusStats = Flags.print_corpus_stats;\n  Options.PrintCoverage = Flags.print_coverage;\n  Options.PrintUnstableStats = Flags.print_unstable_stats;\n  if (Flags.handle_unstable == TracePC::MinUnstable ||\n      Flags.handle_unstable == TracePC::ZeroUnstable)\n    Options.HandleUnstable = Flags.handle_unstable;\n  Options.DumpCoverage = Flags.dump_coverage;\n  if (Flags.exit_on_src_pos)\n    Options.ExitOnSrcPos = Flags.exit_on_src_pos;\n  if (Flags.exit_on_item)\n    Options.ExitOnItem = Flags.exit_on_item;\n  if (Flags.focus_function)\n    Options.FocusFunction = Flags.focus_function;\n  if (Flags.data_flow_trace)\n    Options.DataFlowTrace = Flags.data_flow_trace;\n\n  unsigned Seed = Flags.seed;\n  // Initialize Seed.\n  if (Seed == 0)\n    Seed =\n        std::chrono::system_clock::now().time_since_epoch().count() + GetPid();\n  if (Flags.verbosity)\n    Printf(\"INFO: Seed: %u\\n\", Seed);\n\n  Random Rand(Seed);\n  auto *MD = new MutationDispatcher(Rand, Options);\n  auto *Corpus = new InputCorpus(Options.OutputCorpus);\n  auto *F = new Fuzzer(Callback, *Corpus, *MD, Options);\n\n  for (auto &U: Dictionary)\n    if (U.size() <= Word::GetMaxSize())\n      MD->AddWordToManualDictionary(Word(U.data(), U.size()));\n\n  StartRssThread(F, Flags.rss_limit_mb);\n\n  Options.HandleAbrt = Flags.handle_abrt;\n  Options.HandleBus = Flags.handle_bus;\n  Options.HandleFpe = Flags.handle_fpe;\n  Options.HandleIll = Flags.handle_ill;\n  Options.HandleInt = Flags.handle_int;\n  Options.HandleSegv = Flags.handle_segv;\n  Options.HandleTerm = Flags.handle_term;\n  Options.HandleXfsz = Flags.handle_xfsz;\n  Options.HandleUsr1 = Flags.handle_usr1;\n  Options.HandleUsr2 = Flags.handle_usr2;\n  SetSignalHandler(Options);\n\n  std::atexit(Fuzzer::StaticExitCallback);\n\n  if (Flags.minimize_crash)\n    return MinimizeCrashInput(Args, Options);\n\n  if (Flags.minimize_crash_internal_step)\n    return MinimizeCrashInputInternalStep(F, Corpus);\n\n  if (Flags.cleanse_crash)\n    return CleanseCrashInput(Args, Options);\n\n#if 0  // deprecated, to be removed.\n  if (auto Name = Flags.run_equivalence_server) {\n    SMR.Destroy(Name);\n    if (!SMR.Create(Name)) {\n       Printf(\"ERROR: can't create shared memory region\\n\");\n      return 1;\n    }\n    Printf(\"INFO: EQUIVALENCE SERVER UP\\n\");\n    while (true) {\n      SMR.WaitClient();\n      size_t Size = SMR.ReadByteArraySize();\n      SMR.WriteByteArray(nullptr, 0);\n      const Unit tmp(SMR.GetByteArray(), SMR.GetByteArray() + Size);\n      F->ExecuteCallback(tmp.data(), tmp.size());\n      SMR.PostServer();\n    }\n    return 0;\n  }\n\n  if (auto Name = Flags.use_equivalence_server) {\n    if (!SMR.Open(Name)) {\n      Printf(\"ERROR: can't open shared memory region\\n\");\n      return 1;\n    }\n    Printf(\"INFO: EQUIVALENCE CLIENT UP\\n\");\n  }\n#endif\n\n  if (DoPlainRun) {\n    Options.SaveArtifacts = false;\n    int Runs = std::max(1, Flags.runs);\n    Printf(\"%s: Running %zd inputs %d time(s) each.\\n\", ProgName->c_str(),\n           Inputs->size(), Runs);\n    for (auto &Path : *Inputs) {\n      auto StartTime = system_clock::now();\n      Printf(\"Running: %s\\n\", Path.c_str());\n      for (int Iter = 0; Iter < Runs; Iter++)\n        RunOneTest(F, Path.c_str(), Options.MaxLen);\n      auto StopTime = system_clock::now();\n      auto MS = duration_cast<milliseconds>(StopTime - StartTime).count();\n      Printf(\"Executed %s in %zd ms\\n\", Path.c_str(), (long)MS);\n    }\n    Printf(\"***\\n\"\n           \"*** NOTE: fuzzing was not performed, you have only\\n\"\n           \"***       executed the target code on a fixed set of inputs.\\n\"\n           \"***\\n\");\n    F->PrintFinalStats();\n    exit(0);\n  }\n\n  if (Flags.merge) {\n    F->CrashResistantMerge(Args, *Inputs,\n                           Flags.load_coverage_summary,\n                           Flags.save_coverage_summary,\n                           Flags.merge_control_file);\n    exit(0);\n  }\n\n  if (Flags.merge_inner) {\n    const size_t kDefaultMaxMergeLen = 1 << 20;\n    if (Options.MaxLen == 0)\n      F->SetMaxInputLen(kDefaultMaxMergeLen);\n    assert(Flags.merge_control_file);\n    F->CrashResistantMergeInternalStep(Flags.merge_control_file);\n    exit(0);\n  }\n\n  if (Flags.analyze_dict) {\n    size_t MaxLen = INT_MAX;  // Large max length.\n    UnitVector InitialCorpus;\n    for (auto &Inp : *Inputs) {\n      Printf(\"Loading corpus dir: %s\\n\", Inp.c_str());\n      ReadDirToVectorOfUnits(Inp.c_str(), &InitialCorpus, nullptr,\n                             MaxLen, /*ExitOnError=*/false);\n    }\n\n    if (Dictionary.empty() || Inputs->empty()) {\n      Printf(\"ERROR: can't analyze dict without dict and corpus provided\\n\");\n      return 1;\n    }\n    if (AnalyzeDictionary(F, Dictionary, InitialCorpus)) {\n      Printf(\"Dictionary analysis failed\\n\");\n      exit(1);\n    }\n    Printf(\"Dictionary analysis succeeded\\n\");\n    exit(0);\n  }\n\n  F->Loop(*Inputs);\n\n  if (Flags.verbosity)\n    Printf(\"Done %zd runs in %zd second(s)\\n\", F->getTotalNumberOfRuns(),\n           F->secondsSinceProcessStartUp());\n  F->PrintFinalStats();\n\n  exit(0);  // Don't let F destroy itself.\n}\n__attribute__((visibility(\"default\"))) int main(int argc, char **argv) {\n  return fuzzer::FuzzerDriver(&argc, &argv, LLVMFuzzerTestOneInput);\n}",
    "target": 0,
    "idx": 2011359
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": true,
    "code": "static int parser_conf_file(const char *cfg, struct mk_rconf *fconf,\n                            struct flb_config *config)\n{\n    flb_sds_t name;\n    flb_sds_t format;\n    flb_sds_t regex;\n    flb_sds_t time_fmt;\n    flb_sds_t time_key;\n    flb_sds_t time_offset;\n    flb_sds_t types_str;\n    flb_sds_t tmp_str;\n    int time_keep;\n    int time_strict;\n    int types_len;\n    struct mk_list *head;\n    struct mk_list *decoders = NULL;\n    struct mk_rconf_section *section;\n    struct flb_parser_types *types = NULL;\n\n    /* Read all [PARSER] sections */\n    mk_list_foreach(head, &fconf->sections) {\n        name = NULL;\n        format = NULL;\n        regex = NULL;\n        time_fmt = NULL;\n        time_key = NULL;\n        time_offset = NULL;\n        types_str = NULL;\n        tmp_str = NULL;\n\n        section = mk_list_entry(head, struct mk_rconf_section, _head);\n        if (strcasecmp(section->name, \"PARSER\") != 0) {\n            continue;\n        }\n\n        /* Name */\n        name = get_parser_key(\"Name\", config, section);\n        if (!name) {\n            flb_error(\"[parser] no parser 'name' found in file '%s'\", cfg);\n            goto fconf_error;\n        }\n\n        /* Format */\n        format = get_parser_key(\"Format\", config, section);\n        if (!format) {\n            flb_error(\"[parser] no parser 'format' found for '%s' in file '%s'\",\n                      name, cfg);\n            goto fconf_error;\n        }\n\n        /* Regex (if 'format' == 'regex') */\n        regex = get_parser_key(\"Regex\", config, section);\n        if (!regex && strcmp(format, \"regex\") == 0) {\n            flb_error(\"[parser] no parser 'regex' found for '%s' in file '%s\", name, cfg);\n            goto fconf_error;\n        }\n\n        /* Time_Format */\n        time_fmt = get_parser_key(\"Time_Format\", config, section);\n\n        /* Time_Key */\n        time_key = get_parser_key(\"Time_Key\", config, section);\n\n        /* Time_Keep */\n        time_keep = FLB_FALSE;\n        tmp_str = get_parser_key(\"Time_Keep\", config, section);\n        if (tmp_str) {\n            time_keep = flb_utils_bool(tmp_str);\n            flb_sds_destroy(tmp_str);\n        }\n\n        /* Time_Strict */\n        time_strict = FLB_TRUE;\n        tmp_str = get_parser_key(\"Time_Strict\", config, section);\n        if (tmp_str) {\n            time_strict = flb_utils_bool(tmp_str);\n            flb_sds_destroy(tmp_str);\n        }\n\n        /* Time_Offset (UTC offset) */\n        time_offset = get_parser_key(\"Time_Offset\", config, section);\n\n        /* Types */\n        types_str = get_parser_key(\"Types\", config, section);\n        if (types_str) {\n            types_len = proc_types_str(types_str, &types);\n        }\n        else {\n            types_len = 0;\n        }\n\n        /* Decoders */\n        decoders = flb_parser_decoder_list_create(section);\n\n        /* Create the parser context */\n        if (!flb_parser_create(name, format, regex,\n                               time_fmt, time_key, time_offset, time_keep, time_strict,\n                               types, types_len, decoders, config)) {\n            goto fconf_error;\n        }\n\n        flb_debug(\"[parser] new parser registered: %s\", name);\n\n        flb_sds_destroy(name);\n        flb_sds_destroy(format);\n\n        if (regex) {\n            flb_sds_destroy(regex);\n        }\n        if (time_fmt) {\n            flb_sds_destroy(time_fmt);\n        }\n        if (time_key) {\n            flb_sds_destroy(time_key);\n        }\n        if (time_offset) {\n            flb_sds_destroy(time_offset);\n        }\n        if (types_str) {\n            flb_sds_destroy(types_str);\n        }\n        decoders = NULL;\n    }\n\n    return 0;\n\n fconf_error:\n    flb_sds_destroy(name);\n    flb_sds_destroy(format);\n    if (regex) {\n        flb_sds_destroy(regex);\n    }\n    if (time_fmt) {\n        flb_sds_destroy(time_fmt);\n    }\n    if (time_key) {\n        flb_sds_destroy(time_key);\n    }\n    if (time_offset) {\n        flb_sds_destroy(time_offset);\n    }\n    if (types_str) {\n        flb_sds_destroy(types_str);\n    }\n    if (decoders) {\n        flb_parser_decoder_list_destroy(decoders);\n    }\n    return -1;\n}\nstatic int multiline_parser_conf_file(const char *cfg, struct mk_rconf *fconf,\n                                      struct flb_config *config)\n{\n    flb_sds_t name;\n    int type;\n    flb_sds_t match_string;\n    int negate;\n    flb_sds_t key_content;\n    flb_sds_t key_pattern;\n    flb_sds_t key_group;\n    flb_sds_t parser;\n    flb_sds_t tmp;\n    int flush_timeout;\n    struct mk_list *head;\n    struct mk_rconf_section *section;\n    struct flb_ml *ml;\n\n    /* Read all [PARSER] sections */\n    mk_list_foreach(head, &fconf->sections) {\n        name = NULL;\n        type = -1;\n        match_string = NULL;\n        negate = FLB_FALSE;\n        key_content = NULL;\n        key_pattern = NULL;\n        key_group = NULL;\n        parser = NULL;\n        flush_timeout = -1;\n\n        section = mk_list_entry(head, struct mk_rconf_section, _head);\n        if (strcasecmp(section->name, \"MULTILINE_PARSER\") != 0) {\n            continue;\n        }\n\n        /* name */\n        name = get_parser_key(\"name\", config, section);\n        if (!name) {\n            flb_error(\"[multiline_parser] no 'name' defined in file '%s'\", cfg);\n            goto fconf_error;\n        }\n\n        /* type */\n        tmp = get_parser_key(\"type\", config, section);\n        if (!tmp) {\n            flb_error(\"[multiline_parser] no 'type' defined in file '%s'\", cfg);\n            goto fconf_error;\n        }\n        else {\n            type = flb_ml_type_lookup(tmp);\n            if (type == -1) {\n                flb_error(\"[multiline_parser] invalid type '%s'\", tmp);\n                flb_sds_destroy(tmp);\n                goto fconf_error;\n            }\n            flb_sds_destroy(tmp);\n        }\n\n        /* match_string */\n        match_string = get_parser_key(\"match_string\", config, section);\n\n        /* negate */\n        tmp = get_parser_key(\"negate\", config, section);\n        if (tmp) {\n            negate = flb_utils_bool(tmp);\n            flb_sds_destroy(tmp);\n        }\n\n        /* key_content */\n        key_content = get_parser_key(\"key_content\", config, section);\n\n        /* key_pattern */\n        key_pattern = get_parser_key(\"key_pattern\", config, section);\n\n        /* key_group */\n        key_group = get_parser_key(\"key_group\", config, section);\n\n        /* parser */\n        parser = get_parser_key(\"parser\", config, section);\n\n        /* flush_timeout */\n        tmp = get_parser_key(\"flush_timeout\", config, section);\n        if (tmp) {\n            flush_timeout = atoi(tmp);\n        }\n\n        ml = flb_ml_create(config, name, type, match_string, negate,\n                           flush_timeout, key_content, key_group, key_pattern,\n                           NULL, parser);\n\n        flb_sds_destroy(name);\n        flb_sds_destroy(match_string);\n        flb_sds_destroy(key_content);\n        flb_sds_destroy(key_pattern);\n        flb_sds_destroy(key_group);\n    }\n\n    return 0;\n\n fconf_error:\n    flb_sds_destroy(name);\n    flb_sds_destroy(match_string);\n    flb_sds_destroy(key_content);\n    flb_sds_destroy(key_pattern);\n    flb_sds_destroy(key_group);\n\n    return -1;\n}\nint flb_parser_conf_file(const char *file, struct flb_config *config)\n{\n    int ret;\n    char tmp[PATH_MAX + 1];\n    const char *cfg = NULL;\n    struct mk_rconf *fconf;\n    struct stat st;\n\n#ifndef FLB_HAVE_STATIC_CONF\n    ret = stat(file, &st);\n    if (ret == -1 && errno == ENOENT) {\n        /* Try to resolve the real path (if exists) */\n        if (file[0] == '/') {\n            flb_utils_error(FLB_ERR_CFG_PARSER_FILE);\n            return -1;\n        }\n\n        if (config->conf_path) {\n            snprintf(tmp, PATH_MAX, \"%s%s\", config->conf_path, file);\n            cfg = tmp;\n        }\n    }\n    else {\n        cfg = file;\n    }\n\n    fconf = mk_rconf_open(cfg);\n#else\n    fconf = flb_config_static_open(file);\n#endif\n\n    if (!fconf) {\n        return -1;\n    }\n\n    /* process [PARSER]'s sections */\n    ret = parser_conf_file(cfg, fconf, config);\n    if (ret == -1) {\n        mk_rconf_free(fconf);\n        return -1;\n    }\n\n    ret = multiline_parser_conf_file(cfg, fconf, config);\n    if (ret == -1) {\n        mk_rconf_free(fconf);\n        return -1;\n    }\n\n    mk_rconf_free(fconf);\n    return 0;\n}\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)\n{\n    /* Limit the size of the config files to 32KB. */\n    if (size > 32768) {\n        return 0;\n    }\n\n    /* Write the config file to a location we know OSS-Fuzz has */\n    char filename[256];\n    sprintf(filename, \"/tmp/libfuzzer.%d\", getpid());\n    FILE *fp = fopen(filename, \"wb\");\n    if (!fp) {\n        return 0;\n    }\n    fwrite(conf_file, strlen(conf_file), 1, fp);\n    fclose(fp);\n\n\n    /* Now parse random data based on the config files */\n    struct flb_config *config = NULL;\n    config = flb_config_init();\n    int ret = flb_parser_conf_file(filename, config);\n    if (ret == 0) {\n        struct mk_list *head = NULL;\n        mk_list_foreach(head, &config->parsers) {\n            size_t out_size;\n            char *out_buf = NULL;\n            struct flb_parser *parser = NULL;\n            struct flb_time out_time;\n            parser = mk_list_entry(head, struct flb_parser, _head);\n            flb_parser_do(parser, data, size, &out_buf,\n                          &out_size, &out_time);\n            if (out_buf != NULL) {\n                free(out_buf);\n            }\n        }\n    }\n    flb_parser_exit(config);\n    flb_config_exit(config);\n\n    if (size > 100) {\n        /* Now let's do a second run where we also call flb_config_set_property */\n        config = flb_config_init();\n        ret = flb_parser_conf_file(filename, config);\n        char *key_1 = get_null_terminated(15, &data, &size);\n        char *val_1 = get_null_terminated(15, &data, &size);\n        char *key_2 = get_null_terminated(15, &data, &size);\n        char *val_2 = get_null_terminated(15, &data, &size);\n        char *progname = get_null_terminated(15, &data, &size);\n\n        flb_config_set_property(config, key_1, val_1);\n        flb_config_set_property(config, key_2, val_2);\n        flb_config_set_program_name(config, progname);\n        set_log_level_from_env(config);\n\n        struct mk_list prop;\n        flb_kv_init(&prop);\n        flb_kv_item_create(&prop, key_1, val_1);\n        flb_config_prop_get(progname, &prop);\n        flb_slist_entry_get(&prop, (int)data[0]);\n        flb_slist_dump(&prop);\n        \n        if (ret == 0) {\n            struct mk_list *head = NULL;\n            mk_list_foreach(head, &config->parsers) {\n                size_t out_size;\n                char *out_buf = NULL;\n                struct flb_parser *parser = NULL;\n                struct flb_time out_time;\n                \n                parser = mk_list_entry(head, struct flb_parser, _head);\n                flb_parser_do(parser, data, size, &out_buf,\n                              &out_size, &out_time);\n                if (out_buf != NULL) {\n                    free(out_buf);\n                }\n            }\n        }\n        flb_parser_exit(config);\n        flb_config_exit(config);\n        flb_free(key_1);\n        flb_free(val_1);\n        flb_free(key_2);\n        flb_free(val_2);\n        flb_free(progname);\n        flb_kv_release(&prop);\n    }\n\n    /* clean up the file */\n    unlink(filename);\n\n    /* finally try to parser a random file */\n    fp = fopen(filename, \"wb\");\n    if (!fp) {\n        return 0;\n    }\n    fwrite(data, size, 1, fp);\n    fclose(fp);\n\n    config = NULL;\n    config = flb_config_init();\n    flb_parser_conf_file(filename, config);\n    flb_parser_exit(config);\n    flb_config_exit(config);\n\n    /* Cleanup written config file */\n    unlink(filename);\n\n    return 0;\n}",
    "target": 0,
    "idx": 2034960
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "int\nxmlAddIDSafe(xmlDocPtr doc, const xmlChar *value, xmlAttrPtr attr,\n             int streaming, xmlIDPtr *id) {\n    xmlIDPtr ret;\n    xmlIDTablePtr table;\n\n    if (id != NULL)\n        *id = NULL;\n\n    if (doc == NULL) {\n\treturn(-1);\n    }\n    if ((value == NULL) || (value[0] == 0)) {\n\treturn(0);\n    }\n    if (attr == NULL) {\n\treturn(-1);\n    }\n\n    /*\n     * Create the ID table if needed.\n     */\n    table = (xmlIDTablePtr) doc->ids;\n    if (table == NULL)  {\n        doc->ids = table = xmlHashCreateDict(0, doc->dict);\n        if (table == NULL)\n            return(-1);\n    } else {\n        ret = xmlHashLookup(table, value);\n        if (ret != NULL) {\n            /*\n             * Update the attribute to make entities work.\n             */\n            if (ret->attr != NULL) {\n                ret->attr->id = NULL;\n                ret->attr = attr;\n            }\n\t    attr->atype = XML_ATTRIBUTE_ID;\n            attr->id = ret;\n            return(0);\n        }\n    }\n\n    ret = (xmlIDPtr) xmlMalloc(sizeof(xmlID));\n    if (ret == NULL)\n\treturn(-1);\n    memset(ret, 0, sizeof(*ret));\n\n    /*\n     * fill the structure.\n     */\n    ret->doc = doc;\n    ret->value = xmlStrdup(value);\n    if (ret->value == NULL) {\n        xmlFreeID(ret);\n        return(-1);\n    }\n    if (streaming) {\n\t/*\n\t * Operating in streaming mode, attr is gonna disappear\n\t */\n\tif (doc->dict != NULL)\n\t    ret->name = xmlDictLookup(doc->dict, attr->name, -1);\n\telse\n\t    ret->name = xmlStrdup(attr->name);\n        if (ret->name == NULL) {\n            xmlFreeID(ret);\n            return(-1);\n        }\n\tret->attr = NULL;\n    } else {\n\tret->attr = attr;\n\tret->name = NULL;\n    }\n    ret->lineno = xmlGetLineNo(attr->parent);\n\n    if (xmlHashAddEntry(table, value, ret) < 0) {\n\txmlFreeID(ret);\n\treturn(-1);\n    }\n\n    attr->atype = XML_ATTRIBUTE_ID;\n    if (!streaming)\n        attr->id = ret;\n\n    if (id != NULL)\n        *id = ret;\n    return(1);\n}\nint\nxmlRemoveID(xmlDocPtr doc, xmlAttrPtr attr) {\n    xmlIDTablePtr table;\n\n    if (doc == NULL) return(-1);\n    if ((attr == NULL) || (attr->id == NULL)) return(-1);\n\n    table = (xmlIDTablePtr) doc->ids;\n    if (table == NULL)\n        return(-1);\n\n    if (xmlHashRemoveEntry(table, attr->id->value, xmlFreeIDTableEntry) < 0)\n        return(-1);\n\n    attr->atype = 0;\n    attr->id = NULL;\n\n    return(0);\n}\nvoid\nxmlFreeProp(xmlAttrPtr cur) {\n    xmlDictPtr dict = NULL;\n    if (cur == NULL) return;\n\n    if (cur->doc != NULL) dict = cur->doc->dict;\n\n    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n\txmlDeregisterNodeDefaultValue((xmlNodePtr)cur);\n\n    /* Check for ID removal -> leading to invalid references ! */\n    if ((cur->doc != NULL) && (cur->atype == XML_ATTRIBUTE_ID)) {\n\t    xmlRemoveID(cur->doc, cur);\n    }\n    if (cur->children != NULL) xmlFreeNodeList(cur->children);\n    DICT_FREE(cur->name)\n    xmlFree(cur);\n}\nvoid\nxmlFreePropList(xmlAttrPtr cur) {\n    xmlAttrPtr next;\n    if (cur == NULL) return;\n    while (cur != NULL) {\n        next = cur->next;\n        xmlFreeProp(cur);\n\tcur = next;\n    }\n}\nvoid\nxmlFreeNodeList(xmlNodePtr cur) {\n    xmlNodePtr next;\n    xmlNodePtr parent;\n    xmlDictPtr dict = NULL;\n    size_t depth = 0;\n\n    if (cur == NULL) return;\n    if (cur->type == XML_NAMESPACE_DECL) {\n\txmlFreeNsList((xmlNsPtr) cur);\n\treturn;\n    }\n    if (cur->doc != NULL) dict = cur->doc->dict;\n    while (1) {\n        while ((cur->children != NULL) &&\n               (cur->type != XML_DOCUMENT_NODE) &&\n               (cur->type != XML_HTML_DOCUMENT_NODE) &&\n               (cur->type != XML_DTD_NODE) &&\n               (cur->type != XML_ENTITY_REF_NODE)) {\n            cur = cur->children;\n            depth += 1;\n        }\n\n        next = cur->next;\n        parent = cur->parent;\n\tif ((cur->type == XML_DOCUMENT_NODE) ||\n            (cur->type == XML_HTML_DOCUMENT_NODE)) {\n            xmlFreeDoc((xmlDocPtr) cur);\n        } else if (cur->type != XML_DTD_NODE) {\n\n\t    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n\t\txmlDeregisterNodeDefaultValue(cur);\n\n\t    if (((cur->type == XML_ELEMENT_NODE) ||\n\t\t (cur->type == XML_XINCLUDE_START) ||\n\t\t (cur->type == XML_XINCLUDE_END)) &&\n\t\t(cur->properties != NULL))\n\t\txmlFreePropList(cur->properties);\n\t    if ((cur->type != XML_ELEMENT_NODE) &&\n\t\t(cur->type != XML_XINCLUDE_START) &&\n\t\t(cur->type != XML_XINCLUDE_END) &&\n\t\t(cur->type != XML_ENTITY_REF_NODE) &&\n\t\t(cur->content != (xmlChar *) &(cur->properties))) {\n\t\tDICT_FREE(cur->content)\n\t    }\n\t    if (((cur->type == XML_ELEMENT_NODE) ||\n\t         (cur->type == XML_XINCLUDE_START) ||\n\t\t (cur->type == XML_XINCLUDE_END)) &&\n\t\t(cur->nsDef != NULL))\n\t\txmlFreeNsList(cur->nsDef);\n\n\t    /*\n\t     * When a node is a text node or a comment, it uses a global static\n\t     * variable for the name of the node.\n\t     * Otherwise the node name might come from the document's\n\t     * dictionary\n\t     */\n\t    if ((cur->name != NULL) &&\n\t\t(cur->type != XML_TEXT_NODE) &&\n\t\t(cur->type != XML_COMMENT_NODE))\n\t\tDICT_FREE(cur->name)\n\t    xmlFree(cur);\n\t}\n\n        if (next != NULL) {\n\t    cur = next;\n        } else {\n            if ((depth == 0) || (parent == NULL))\n                break;\n            depth -= 1;\n            cur = parent;\n            cur->children = NULL;\n        }\n    }\n}\nvoid\nxmlFreeNode(xmlNodePtr cur) {\n    xmlDictPtr dict = NULL;\n\n    if (cur == NULL) return;\n\n    /* use xmlFreeDtd for DTD nodes */\n    if (cur->type == XML_DTD_NODE) {\n\txmlFreeDtd((xmlDtdPtr) cur);\n\treturn;\n    }\n    if (cur->type == XML_NAMESPACE_DECL) {\n\txmlFreeNs((xmlNsPtr) cur);\n        return;\n    }\n    if (cur->type == XML_ATTRIBUTE_NODE) {\n\txmlFreeProp((xmlAttrPtr) cur);\n\treturn;\n    }\n\n    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n\txmlDeregisterNodeDefaultValue(cur);\n\n    if (cur->doc != NULL) dict = cur->doc->dict;\n\n    if (cur->type == XML_ENTITY_DECL) {\n        xmlEntityPtr ent = (xmlEntityPtr) cur;\n\tDICT_FREE(ent->SystemID);\n\tDICT_FREE(ent->ExternalID);\n    }\n    if ((cur->children != NULL) &&\n\t(cur->type != XML_ENTITY_REF_NODE))\n\txmlFreeNodeList(cur->children);\n\n    if ((cur->type == XML_ELEMENT_NODE) ||\n        (cur->type == XML_XINCLUDE_START) ||\n        (cur->type == XML_XINCLUDE_END)) {\n        if (cur->properties != NULL)\n            xmlFreePropList(cur->properties);\n        if (cur->nsDef != NULL)\n            xmlFreeNsList(cur->nsDef);\n    } else if ((cur->content != NULL) &&\n               (cur->type != XML_ENTITY_REF_NODE) &&\n               (cur->content != (xmlChar *) &(cur->properties))) {\n        DICT_FREE(cur->content)\n    }\n\n    /*\n     * When a node is a text node or a comment, it uses a global static\n     * variable for the name of the node.\n     * Otherwise the node name might come from the document's dictionary\n     */\n    if ((cur->name != NULL) &&\n        (cur->type != XML_TEXT_NODE) &&\n        (cur->type != XML_COMMENT_NODE))\n\tDICT_FREE(cur->name)\n\n    xmlFree(cur);\n}\nstatic xmlNodePtr\nxmlCtxtParseContent(xmlParserCtxtPtr ctxt, xmlParserInputPtr input,\n                    int hasTextDecl, int buildTree) {\n    xmlNodePtr root = NULL;\n    xmlNodePtr list = NULL;\n    xmlChar *rootName = BAD_CAST \"#root\";\n    int result;\n\n    if (buildTree) {\n        root = xmlNewDocNode(ctxt->myDoc, NULL, rootName, NULL);\n        if (root == NULL) {\n            xmlErrMemory(ctxt);\n            goto error;\n        }\n    }\n\n    if (xmlPushInput(ctxt, input) < 0)\n        goto error;\n\n    nameNsPush(ctxt, rootName, NULL, NULL, 0, 0);\n    spacePush(ctxt, -1);\n\n    if (buildTree)\n        nodePush(ctxt, root);\n\n    if (hasTextDecl) {\n        xmlDetectEncoding(ctxt);\n\n        /*\n         * Parse a possible text declaration first\n         */\n        if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) &&\n            (IS_BLANK_CH(NXT(5)))) {\n            xmlParseTextDecl(ctxt);\n            /*\n             * An XML-1.0 document can't reference an entity not XML-1.0\n             */\n            if ((xmlStrEqual(ctxt->version, BAD_CAST \"1.0\")) &&\n                (!xmlStrEqual(ctxt->input->version, BAD_CAST \"1.0\"))) {\n                xmlFatalErrMsg(ctxt, XML_ERR_VERSION_MISMATCH,\n                               \"Version mismatch between document and \"\n                               \"entity\\n\");\n            }\n        }\n    }\n\n    xmlParseContentInternal(ctxt);\n\n    if (ctxt->input->cur < ctxt->input->end)\n\txmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);\n\n    if ((ctxt->wellFormed) ||\n        ((ctxt->recovery) && (ctxt->errNo != XML_ERR_NO_MEMORY))) {\n        if (root != NULL) {\n            xmlNodePtr cur;\n\n            /*\n             * Return the newly created nodeset after unlinking it from\n             * its pseudo parent.\n             */\n            cur = root->children;\n            list = cur;\n            while (cur != NULL) {\n                cur->parent = NULL;\n                cur = cur->next;\n            }\n            root->children = NULL;\n            root->last = NULL;\n        }\n    }\n\n    /*\n     * Read the rest of the stream in case of errors. We want\n     * to account for the whole entity size.\n     */\n    do {\n        ctxt->input->cur = ctxt->input->end;\n        xmlParserShrink(ctxt);\n        result = xmlParserGrow(ctxt);\n    } while (result > 0);\n\n    if (buildTree)\n        nodePop(ctxt);\n\n    namePop(ctxt);\n    spacePop(ctxt);\n\n    /* xmlPopInput would free the stream */\n    inputPop(ctxt);\n\nerror:\n    xmlFreeNode(root);\n\n    return(list);\n}\nstatic void\nxmlCtxtParseEntity(xmlParserCtxtPtr ctxt, xmlEntityPtr ent) {\n    xmlParserInputPtr input;\n    xmlNodePtr list;\n    unsigned long consumed;\n    int isExternal;\n    int buildTree;\n    int oldMinNsIndex;\n    int oldNodelen, oldNodemem;\n\n    isExternal = (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY);\n    buildTree = (ctxt->node != NULL);\n\n    /*\n     * Recursion check\n     */\n    if (ent->flags & XML_ENT_EXPANDING) {\n        xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);\n        xmlHaltParser(ctxt);\n        goto error;\n    }\n\n    /*\n     * Load entity\n     */\n    input = xmlNewEntityInputStream(ctxt, ent);\n    if (input == NULL)\n        goto error;\n\n    /*\n     * When building a tree, we need to limit the scope of namespace\n     * declarations, so that entities don't reference xmlNs structs\n     * from the parent of a reference.\n     */\n    oldMinNsIndex = ctxt->nsdb->minNsIndex;\n    if (buildTree)\n        ctxt->nsdb->minNsIndex = ctxt->nsNr;\n\n    oldNodelen = ctxt->nodelen;\n    oldNodemem = ctxt->nodemem;\n    ctxt->nodelen = 0;\n    ctxt->nodemem = 0;\n\n    /*\n     * Parse content\n     *\n     * This initiates a recursive call chain:\n     *\n     * - xmlCtxtParseContent\n     * - xmlParseContentInternal\n     * - xmlParseReference\n     * - xmlCtxtParseEntity\n     *\n     * The nesting depth is limited by the maximum number of inputs,\n     * see xmlPushInput.\n     *\n     * It's possible to make this non-recursive (minNsIndex must be\n     * stored in the input struct) at the expense of code readability.\n     */\n\n    ent->flags |= XML_ENT_EXPANDING;\n\n    list = xmlCtxtParseContent(ctxt, input, isExternal, buildTree);\n\n    ent->flags &= ~XML_ENT_EXPANDING;\n\n    ctxt->nsdb->minNsIndex = oldMinNsIndex;\n    ctxt->nodelen = oldNodelen;\n    ctxt->nodemem = oldNodemem;\n\n    /*\n     * Entity size accounting\n     */\n    consumed = input->consumed;\n    xmlSaturatedAddSizeT(&consumed, input->end - input->base);\n\n    if ((ent->flags & XML_ENT_CHECKED) == 0)\n        xmlSaturatedAdd(&ent->expandedSize, consumed);\n\n    if ((ent->flags & XML_ENT_PARSED) == 0) {\n        if (isExternal)\n            xmlSaturatedAdd(&ctxt->sizeentities, consumed);\n\n        ent->children = list;\n\n        while (list != NULL) {\n            list->parent = (xmlNodePtr) ent;\n            if (list->next == NULL)\n                ent->last = list;\n            list = list->next;\n        }\n    } else {\n        xmlFreeNodeList(list);\n    }\n\n    xmlFreeInputStream(input);\n\nerror:\n    ent->flags |= XML_ENT_PARSED | XML_ENT_CHECKED;\n}\nint\nxmlParseChunk(xmlParserCtxtPtr ctxt, const char *chunk, int size,\n              int terminate) {\n    size_t curBase;\n    size_t maxLength;\n    int end_in_lf = 0;\n\n    if ((ctxt == NULL) || (size < 0))\n        return(XML_ERR_ARGUMENT);\n    if (ctxt->disableSAX != 0)\n        return(ctxt->errNo);\n    if (ctxt->input == NULL)\n        return(XML_ERR_INTERNAL_ERROR);\n\n    ctxt->input->flags |= XML_INPUT_PROGRESSIVE;\n    if (ctxt->instate == XML_PARSER_START)\n        xmlCtxtInitializeLate(ctxt);\n    if ((size > 0) && (chunk != NULL) && (!terminate) &&\n        (chunk[size - 1] == '\\r')) {\n\tend_in_lf = 1;\n\tsize--;\n    }\n\n    if ((size > 0) && (chunk != NULL) && (ctxt->input != NULL) &&\n        (ctxt->input->buf != NULL))  {\n\tsize_t pos = ctxt->input->cur - ctxt->input->base;\n\tint res;\n\n\tres = xmlParserInputBufferPush(ctxt->input->buf, size, chunk);\n        xmlBufUpdateInput(ctxt->input->buf->buffer, ctxt->input, pos);\n\tif (res < 0) {\n            xmlCtxtErrIO(ctxt, ctxt->input->buf->error, NULL);\n\t    xmlHaltParser(ctxt);\n\t    return(ctxt->errNo);\n\t}\n    }\n\n    xmlParseTryOrFinish(ctxt, terminate);\n\n    curBase = ctxt->input->cur - ctxt->input->base;\n    maxLength = (ctxt->options & XML_PARSE_HUGE) ?\n                XML_MAX_HUGE_LENGTH :\n                XML_MAX_LOOKUP_LIMIT;\n    if (curBase > maxLength) {\n        xmlFatalErr(ctxt, XML_ERR_RESOURCE_LIMIT,\n                    \"Buffer size limit exceeded, try XML_PARSE_HUGE\\n\");\n        xmlHaltParser(ctxt);\n    }\n\n    if ((ctxt->errNo != XML_ERR_OK) && (ctxt->disableSAX == 1))\n        return(ctxt->errNo);\n\n    if ((end_in_lf == 1) && (ctxt->input != NULL) &&\n        (ctxt->input->buf != NULL)) {\n\tsize_t pos = ctxt->input->cur - ctxt->input->base;\n        int res;\n\n\tres = xmlParserInputBufferPush(ctxt->input->buf, 1, \"\\r\");\n\txmlBufUpdateInput(ctxt->input->buf->buffer, ctxt->input, pos);\n        if (res < 0) {\n            xmlCtxtErrIO(ctxt, ctxt->input->buf->error, NULL);\n            xmlHaltParser(ctxt);\n            return(ctxt->errNo);\n        }\n    }\n    if (terminate) {\n\t/*\n\t * Check for termination\n\t */\n        if ((ctxt->instate != XML_PARSER_EOF) &&\n            (ctxt->instate != XML_PARSER_EPILOG)) {\n            if (ctxt->nameNr > 0) {\n                const xmlChar *name = ctxt->nameTab[ctxt->nameNr - 1];\n                int line = ctxt->pushTab[ctxt->nameNr - 1].line;\n                xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NOT_FINISHED,\n                        \"Premature end of data in tag %s line %d\\n\",\n                        name, line, NULL);\n            } else if (ctxt->instate == XML_PARSER_START) {\n                xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);\n            } else {\n                xmlFatalErrMsg(ctxt, XML_ERR_DOCUMENT_EMPTY,\n                               \"Start tag expected, '<' not found\\n\");\n            }\n        } else if ((ctxt->input->buf != NULL) &&\n                   (ctxt->input->buf->encoder != NULL) &&\n                   (!xmlBufIsEmpty(ctxt->input->buf->raw))) {\n            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n                           \"Truncated multi-byte sequence at EOF\\n\");\n        }\n\tif (ctxt->instate != XML_PARSER_EOF) {\n            ctxt->instate = XML_PARSER_EOF;\n            xmlFinishDocument(ctxt);\n\t}\n    }\n    if (ctxt->wellFormed == 0)\n\treturn((xmlParserErrors) ctxt->errNo);\n    else\n        return(0);\n}\nstatic int\nxmlTextReaderPushData(xmlTextReaderPtr reader) {\n    xmlBufPtr inbuf;\n    int val, s;\n    xmlTextReaderState oldstate;\n\n    if ((reader->input == NULL) || (reader->input->buffer == NULL))\n\treturn(-1);\n\n    oldstate = reader->state;\n    reader->state = XML_TEXTREADER_NONE;\n    inbuf = reader->input->buffer;\n\n    while (reader->state == XML_TEXTREADER_NONE) {\n\tif (xmlBufUse(inbuf) < reader->cur + CHUNK_SIZE) {\n\t    /*\n\t     * Refill the buffer unless we are at the end of the stream\n\t     */\n\t    if (reader->mode != XML_TEXTREADER_MODE_EOF) {\n\t\tval = xmlParserInputBufferRead(reader->input, 4096);\n\t\tif (val == 0) {\n\t\t    if (xmlBufUse(inbuf) == reader->cur) {\n\t\t\treader->mode = XML_TEXTREADER_MODE_EOF;\n                        break;\n\t\t    }\n\t\t} else if (val < 0) {\n                    xmlCtxtErrIO(reader->ctxt, reader->input->error, NULL);\n                    reader->mode = XML_TEXTREADER_MODE_ERROR;\n                    reader->state = XML_TEXTREADER_ERROR;\n                    return(-1);\n\t\t}\n\n\t    } else\n\t\tbreak;\n\t}\n\t/*\n\t * parse by block of CHUNK_SIZE bytes, various tests show that\n\t * it's the best tradeoff at least on a 1.2GH Duron\n\t */\n\tif (xmlBufUse(inbuf) >= reader->cur + CHUNK_SIZE) {\n\t    val = xmlParseChunk(reader->ctxt,\n                 (const char *) xmlBufContent(inbuf) + reader->cur,\n                                CHUNK_SIZE, 0);\n\t    reader->cur += CHUNK_SIZE;\n\t    if (val != 0)\n\t\treader->ctxt->wellFormed = 0;\n\t    if (reader->ctxt->wellFormed == 0)\n\t\tbreak;\n\t} else {\n\t    s = xmlBufUse(inbuf) - reader->cur;\n\t    val = xmlParseChunk(reader->ctxt,\n\t\t (const char *) xmlBufContent(inbuf) + reader->cur,\n\t\t\t        s, 0);\n\t    reader->cur += s;\n\t    if (val != 0)\n\t\treader->ctxt->wellFormed = 0;\n\t    break;\n\t}\n    }\n    reader->state = oldstate;\n\n    /*\n     * Discard the consumed input when needed and possible\n     */\n    if (reader->mode == XML_TEXTREADER_MODE_INTERACTIVE) {\n        if (reader->input->readcallback != NULL) {\n\t    if ((reader->cur >= 4096) &&\n\t\t(xmlBufUse(inbuf) - reader->cur <= CHUNK_SIZE)) {\n\t\tval = xmlBufShrink(inbuf, reader->cur);\n\t\tif (val >= 0) {\n\t\t    reader->cur -= val;\n\t\t}\n\t    }\n\t}\n    }\n\n    /*\n     * At the end of the stream signal that the work is done to the Push\n     * parser.\n     */\n    else if (reader->mode == XML_TEXTREADER_MODE_EOF) {\n\tif (reader->state != XML_TEXTREADER_DONE) {\n\t    s = xmlBufUse(inbuf) - reader->cur;\n\t    val = xmlParseChunk(reader->ctxt,\n\t\t (const char *) xmlBufContent(inbuf) + reader->cur,\n\t\t\t        s, 1);\n\t    reader->cur = xmlBufUse(inbuf);\n\t    reader->state  = XML_TEXTREADER_DONE;\n\t    if (val != 0) {\n\t        if (reader->ctxt->wellFormed)\n\t\t    reader->ctxt->wellFormed = 0;\n\t\telse\n\t\t    return(-1);\n\t    }\n\t}\n    }\n    if (reader->ctxt->wellFormed == 0) {\n\treader->mode = XML_TEXTREADER_MODE_EOF;\n        return(-1);\n    }\n\n    return(0);\n}\nint\nxmlTextReaderRead(xmlTextReaderPtr reader) {\n    int val, olddepth = 0;\n    xmlTextReaderState oldstate = XML_TEXTREADER_START;\n    xmlNodePtr oldnode = NULL;\n\n\n    if (reader == NULL)\n\treturn(-1);\n    reader->curnode = NULL;\n    if (reader->doc != NULL)\n        return(xmlTextReaderReadTree(reader));\n    if (reader->ctxt == NULL)\n\treturn(-1);\n\n    if (reader->mode == XML_TEXTREADER_MODE_INITIAL) {\n\treader->mode = XML_TEXTREADER_MODE_INTERACTIVE;\n\t/*\n\t * Initial state\n\t */\n\tdo {\n\t    val = xmlTextReaderPushData(reader);\n\t\tif (val < 0){\n\t\t\treader->mode = XML_TEXTREADER_MODE_ERROR;\n\t\t\treader->state = XML_TEXTREADER_ERROR;\n\t\treturn(-1);\n\t\t}\n\t} while ((reader->ctxt->node == NULL) &&\n\t\t ((reader->mode != XML_TEXTREADER_MODE_EOF) &&\n\t\t  (reader->state != XML_TEXTREADER_DONE)));\n\tif (reader->ctxt->node == NULL) {\n\t    if (reader->ctxt->myDoc != NULL) {\n\t\treader->node = reader->ctxt->myDoc->children;\n\t    }\n\t    if (reader->node == NULL){\n\t\t\treader->mode = XML_TEXTREADER_MODE_ERROR;\n\t\t\treader->state = XML_TEXTREADER_ERROR;\n\t\treturn(-1);\n\t\t}\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t} else {\n\t    if (reader->ctxt->myDoc != NULL) {\n\t\treader->node = reader->ctxt->myDoc->children;\n\t    }\n\t    if (reader->node == NULL)\n\t\treader->node = reader->ctxt->nodeTab[0];\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t}\n\treader->depth = 0;\n\treader->ctxt->parseMode = XML_PARSE_READER;\n\tgoto node_found;\n    }\n    oldstate = reader->state;\n    olddepth = reader->ctxt->nodeNr;\n    oldnode = reader->node;\n\nget_next_node:\n    if (reader->node == NULL) {\n\tif (reader->mode == XML_TEXTREADER_MODE_EOF)\n\t    return(0);\n\telse\n\t    return(-1);\n    }\n\n    /*\n     * If we are not backtracking on ancestors or examined nodes,\n     * that the parser didn't finished or that we aren't at the end\n     * of stream, continue processing.\n     */\n    while ((reader->node != NULL) && (reader->node->next == NULL) &&\n\t   (reader->ctxt->nodeNr == olddepth) &&\n           ((oldstate == XML_TEXTREADER_BACKTRACK) ||\n            (reader->node->children == NULL) ||\n\t    (reader->node->type == XML_ENTITY_REF_NODE) ||\n\t    ((reader->node->children != NULL) &&\n\t     (reader->node->children->type == XML_TEXT_NODE) &&\n\t     (reader->node->children->next == NULL)) ||\n\t    (reader->node->type == XML_DTD_NODE) ||\n\t    (reader->node->type == XML_DOCUMENT_NODE) ||\n\t    (reader->node->type == XML_HTML_DOCUMENT_NODE)) &&\n\t   ((reader->ctxt->node == NULL) ||\n\t    (reader->ctxt->node == reader->node) ||\n\t    (reader->ctxt->node == reader->node->parent)) &&\n\t   (reader->ctxt->instate != XML_PARSER_EOF) &&\n\t   (PARSER_STOPPED(reader->ctxt) == 0)) {\n\tval = xmlTextReaderPushData(reader);\n\tif (val < 0)\n\t    return(-1);\n\tif (reader->node == NULL)\n\t    goto node_end;\n    }\n    if (oldstate != XML_TEXTREADER_BACKTRACK) {\n\tif ((reader->node->children != NULL) &&\n\t    (reader->node->type != XML_ENTITY_REF_NODE) &&\n\t    (reader->node->type != XML_XINCLUDE_START) &&\n\t    (reader->node->type != XML_DTD_NODE)) {\n\t    reader->node = reader->node->children;\n\t    reader->depth++;\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t    goto node_found;\n\t}\n    }\n    if (reader->node->next != NULL) {\n\tif ((oldstate == XML_TEXTREADER_ELEMENT) &&\n            (reader->node->type == XML_ELEMENT_NODE) &&\n\t    (reader->node->children == NULL) &&\n\t    ((reader->node->extra & NODE_IS_EMPTY) == 0)\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    && (reader->in_xinclude <= 0)\n#endif\n\t    ) {\n\t    reader->state = XML_TEXTREADER_END;\n\t    goto node_found;\n\t}\n#ifdef LIBXML_REGEXP_ENABLED\n\tif ((reader->validate) &&\n\t    (reader->node->type == XML_ELEMENT_NODE))\n\t    if (xmlTextReaderValidatePop(reader) < 0)\n                return(-1);\n#endif /* LIBXML_REGEXP_ENABLED */\n        if ((reader->preserves > 0) &&\n\t    (reader->node->extra & NODE_IS_SPRESERVED))\n\t    reader->preserves--;\n\treader->node = reader->node->next;\n\treader->state = XML_TEXTREADER_ELEMENT;\n\n\t/*\n\t * Cleanup of the old node\n\t */\n\tif ((reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    (reader->in_xinclude == 0) &&\n#endif\n\t    (reader->entNr == 0) &&\n\t    (reader->node->prev != NULL) &&\n            (reader->node->prev->type != XML_DTD_NODE)) {\n\t    xmlNodePtr tmp = reader->node->prev;\n\t    if ((tmp->extra & NODE_IS_PRESERVED) == 0) {\n                if (oldnode == tmp)\n                    oldnode = NULL;\n\t\txmlUnlinkNode(tmp);\n\t\txmlTextReaderFreeNode(reader, tmp);\n\t    }\n\t}\n\n\tgoto node_found;\n    }\n    if ((oldstate == XML_TEXTREADER_ELEMENT) &&\n\t(reader->node->type == XML_ELEMENT_NODE) &&\n\t(reader->node->children == NULL) &&\n\t((reader->node->extra & NODE_IS_EMPTY) == 0)) {;\n\treader->state = XML_TEXTREADER_END;\n\tgoto node_found;\n    }\n#ifdef LIBXML_REGEXP_ENABLED\n    if ((reader->validate != XML_TEXTREADER_NOT_VALIDATE) &&\n        (reader->node->type == XML_ELEMENT_NODE)) {\n        if (xmlTextReaderValidatePop(reader) < 0)\n            return(-1);\n    }\n#endif /* LIBXML_REGEXP_ENABLED */\n    if ((reader->preserves > 0) &&\n\t(reader->node->extra & NODE_IS_SPRESERVED))\n\treader->preserves--;\n    reader->node = reader->node->parent;\n    if ((reader->node == NULL) ||\n\t(reader->node->type == XML_DOCUMENT_NODE) ||\n\t(reader->node->type == XML_HTML_DOCUMENT_NODE)) {\n\tif (reader->mode != XML_TEXTREADER_MODE_EOF) {\n\t    val = xmlParseChunk(reader->ctxt, \"\", 0, 1);\n\t    reader->state = XML_TEXTREADER_DONE;\n\t    if (val != 0)\n\t        return(-1);\n\t}\n\treader->node = NULL;\n\treader->depth = -1;\n\n\t/*\n\t * Cleanup of the old node\n\t */\n\tif ((oldnode != NULL) && (reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    (reader->in_xinclude == 0) &&\n#endif\n\t    (reader->entNr == 0) &&\n\t    (oldnode->type != XML_DTD_NODE) &&\n\t    ((oldnode->extra & NODE_IS_PRESERVED) == 0)) {\n\t    xmlUnlinkNode(oldnode);\n\t    xmlTextReaderFreeNode(reader, oldnode);\n\t}\n\n\tgoto node_end;\n    }\n    if ((reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n        (reader->in_xinclude == 0) &&\n#endif\n\t(reader->entNr == 0) &&\n        (reader->node->last != NULL) &&\n        ((reader->node->last->extra & NODE_IS_PRESERVED) == 0)) {\n\txmlNodePtr tmp = reader->node->last;\n\txmlUnlinkNode(tmp);\n\txmlTextReaderFreeNode(reader, tmp);\n    }\n    reader->depth--;\n    reader->state = XML_TEXTREADER_BACKTRACK;\n\nnode_found:\n    /*\n     * If we are in the middle of a piece of CDATA make sure it's finished\n     */\n    if ((reader->node != NULL) &&\n        (reader->node->next == NULL) &&\n        ((reader->node->type == XML_TEXT_NODE) ||\n\t (reader->node->type == XML_CDATA_SECTION_NODE))) {\n            if (xmlTextReaderExpand(reader) == NULL)\n\t        return -1;\n    }\n\n#ifdef LIBXML_XINCLUDE_ENABLED\n    /*\n     * Handle XInclude if asked for\n     */\n    if ((reader->xinclude) && (reader->in_xinclude == 0) &&\n        (reader->node != NULL) &&\n\t(reader->node->type == XML_ELEMENT_NODE) &&\n\t(reader->node->ns != NULL) &&\n\t((xmlStrEqual(reader->node->ns->href, XINCLUDE_NS)) ||\n\t (xmlStrEqual(reader->node->ns->href, XINCLUDE_OLD_NS)))) {\n\tif (reader->xincctxt == NULL) {\n\t    reader->xincctxt = xmlXIncludeNewContext(reader->ctxt->myDoc);\n            if (reader->xincctxt == NULL) {\n                xmlTextReaderErrMemory(reader);\n                return(-1);\n            }\n\t    xmlXIncludeSetFlags(reader->xincctxt,\n\t                        reader->parserFlags & (~XML_PARSE_NOXINCNODE));\n            xmlXIncludeSetStreamingMode(reader->xincctxt, 1);\n            if ((reader->errorFunc != NULL) || (reader->sErrorFunc != NULL))\n                xmlXIncludeSetErrorHandler(reader->xincctxt,\n                        xmlTextReaderStructuredRelay, reader);\n\t}\n\t/*\n\t * expand that node and process it\n\t */\n\tif (xmlTextReaderExpand(reader) == NULL)\n\t    return(-1);\n        if (xmlXIncludeProcessNode(reader->xincctxt, reader->node) < 0) {\n            int err = xmlXIncludeGetLastError(reader->xincctxt);\n\n            if (err == XML_ERR_NO_MEMORY)\n                xmlTextReaderErrMemory(reader);\n            return(-1);\n        }\n    }\n    if ((reader->node != NULL) && (reader->node->type == XML_XINCLUDE_START)) {\n        reader->in_xinclude++;\n\tgoto get_next_node;\n    }\n    if ((reader->node != NULL) && (reader->node->type == XML_XINCLUDE_END)) {\n        reader->in_xinclude--;\n\tgoto get_next_node;\n    }\n#endif\n    /*\n     * Handle entities enter and exit when in entity replacement mode\n     */\n    if ((reader->node != NULL) &&\n\t(reader->node->type == XML_ENTITY_REF_NODE) &&\n\t(reader->ctxt != NULL) && (reader->ctxt->replaceEntities == 1)) {\n\tif ((reader->node->children != NULL) &&\n\t    (reader->node->children->type == XML_ENTITY_DECL) &&\n\t    (reader->node->children->children != NULL)) {\n\t    if (xmlTextReaderEntPush(reader, reader->node) < 0)\n                goto get_next_node;\n\t    reader->node = reader->node->children->children;\n\t}\n#ifdef LIBXML_REGEXP_ENABLED\n    } else if ((reader->node != NULL) &&\n\t       (reader->node->type == XML_ENTITY_REF_NODE) &&\n\t       (reader->ctxt != NULL) && (reader->validate)) {\n\txmlTextReaderValidateEntity(reader);\n#endif /* LIBXML_REGEXP_ENABLED */\n    }\n    if ((reader->node != NULL) &&\n\t(reader->node->type == XML_ENTITY_DECL) &&\n\t(reader->ent != NULL) && (reader->ent->children == reader->node)) {\n\treader->node = xmlTextReaderEntPop(reader);\n\treader->depth++;\n        goto get_next_node;\n    }\n#ifdef LIBXML_REGEXP_ENABLED\n    if ((reader->validate != XML_TEXTREADER_NOT_VALIDATE) && (reader->node != NULL)) {\n\txmlNodePtr node = reader->node;\n\n\tif ((node->type == XML_ELEMENT_NODE) &&\n            ((reader->state != XML_TEXTREADER_END) &&\n\t     (reader->state != XML_TEXTREADER_BACKTRACK))) {\n\t    if (xmlTextReaderValidatePush(reader) < 0)\n                return(-1);\n\t} else if ((node->type == XML_TEXT_NODE) ||\n\t\t   (node->type == XML_CDATA_SECTION_NODE)) {\n            xmlTextReaderValidateCData(reader, node->content,\n\t                               xmlStrlen(node->content));\n\t}\n    }\n#endif /* LIBXML_REGEXP_ENABLED */\n#ifdef LIBXML_PATTERN_ENABLED\n    if ((reader->patternNr > 0) && (reader->state != XML_TEXTREADER_END) &&\n        (reader->state != XML_TEXTREADER_BACKTRACK)) {\n        int i;\n\tfor (i = 0;i < reader->patternNr;i++) {\n\t     if (xmlPatternMatch(reader->patternTab[i], reader->node) == 1) {\n\t         xmlTextReaderPreserve(reader);\n\t\t break;\n             }\n\t}\n    }\n#endif /* LIBXML_PATTERN_ENABLED */\n#ifdef LIBXML_SCHEMAS_ENABLED\n    if ((reader->validate == XML_TEXTREADER_VALIDATE_XSD) &&\n        (reader->xsdValidErrors == 0) &&\n\t(reader->xsdValidCtxt != NULL)) {\n\treader->xsdValidErrors = !xmlSchemaIsValid(reader->xsdValidCtxt);\n    }\n#endif /* LIBXML_PATTERN_ENABLED */\n    return(1);\nnode_end:\n    reader->state = XML_TEXTREADER_DONE;\n    return(0);\n}\nint\nLLVMFuzzerTestOneInput(const char *data, size_t size) {\n    xmlParserCtxtPtr ctxt;\n    xmlDocPtr doc;\n    const char *docBuffer, *docUrl;\n    size_t maxAlloc, docSize;\n    int opts;\n\n    xmlFuzzDataInit(data, size);\n    opts = (int) xmlFuzzReadInt(4);\n    /*\n     * Disable options that are known to cause timeouts\n     */\n    opts &= ~XML_PARSE_XINCLUDE &\n            ~XML_PARSE_DTDVALID &\n            ~XML_PARSE_SAX1;\n    maxAlloc = xmlFuzzReadInt(4) % (size + 100);\n\n    xmlFuzzReadEntities();\n    docBuffer = xmlFuzzMainEntity(&docSize);\n    docUrl = xmlFuzzMainUrl();\n    if (docBuffer == NULL)\n        goto exit;\n\n    /* Pull parser */\n\n    xmlFuzzMemSetLimit(maxAlloc);\n    ctxt = xmlNewParserCtxt();\n    if (ctxt != NULL) {\n        doc = xmlCtxtReadMemory(ctxt, docBuffer, docSize, docUrl, NULL, opts);\n        xmlFuzzCheckMallocFailure(\"xmlCtxtReadMemory\",\n                                  doc == NULL &&\n                                  ctxt->errNo == XML_ERR_NO_MEMORY);\n\n        if (doc != NULL) {\n#ifdef LIBXML_OUTPUT_ENABLED\n            xmlBufferPtr buffer;\n            xmlSaveCtxtPtr save;\n\n            /* Also test the serializer. */\n            buffer = xmlBufferCreate();\n            save = xmlSaveToBuffer(buffer, NULL, 0);\n            if (save != NULL) {\n                int errNo;\n\n                xmlSaveDoc(save, doc);\n                errNo = xmlSaveFinish(save);\n                xmlFuzzCheckMallocFailure(\"xmlSaveDoc\",\n                                          errNo == XML_ERR_NO_MEMORY);\n            }\n            xmlBufferFree(buffer);\n#endif\n            xmlFreeDoc(doc);\n        }\n\n        xmlFreeParserCtxt(ctxt);\n    }\n\n    /* Push parser */\n\n#ifdef LIBXML_PUSH_ENABLED\n    {\n        static const size_t maxChunkSize = 128;\n        size_t consumed, chunkSize;\n\n        xmlFuzzMemSetLimit(maxAlloc);\n        ctxt = xmlCreatePushParserCtxt(NULL, NULL, NULL, 0, docUrl);\n        if (ctxt != NULL) {\n            xmlCtxtUseOptions(ctxt, opts);\n\n            for (consumed = 0; consumed < docSize; consumed += chunkSize) {\n                chunkSize = docSize - consumed;\n                if (chunkSize > maxChunkSize)\n                    chunkSize = maxChunkSize;\n                xmlParseChunk(ctxt, docBuffer + consumed, chunkSize, 0);\n            }\n\n            xmlParseChunk(ctxt, NULL, 0, 1);\n            xmlFuzzCheckMallocFailure(\"xmlParseChunk\",\n                                      ctxt->errNo == XML_ERR_NO_MEMORY);\n            xmlFreeDoc(ctxt->myDoc);\n            xmlFreeParserCtxt(ctxt);\n        }\n    }\n#endif\n\n    /* Reader */\n\n#ifdef LIBXML_READER_ENABLED\n    {\n        xmlTextReaderPtr reader;\n        const xmlError *error;\n        int j;\n\n        xmlFuzzMemSetLimit(maxAlloc);\n        reader = xmlReaderForMemory(docBuffer, docSize, NULL, NULL, opts);\n        if (reader != NULL) {\n            while (xmlTextReaderRead(reader) == 1) {\n                if (xmlTextReaderNodeType(reader) == XML_ELEMENT_NODE) {\n                    int i, n = xmlTextReaderAttributeCount(reader);\n                    for (i=0; i<n; i++) {\n                        xmlTextReaderMoveToAttributeNo(reader, i);\n                        while (xmlTextReaderReadAttributeValue(reader) == 1);\n                    }\n                }\n            }\n            for (j = 0; j < 10; j++)\n                xmlTextReaderRead(reader);\n            error = xmlTextReaderGetLastError(reader);\n            xmlFuzzCheckMallocFailure(\"xmlTextReaderRead\",\n                                      error->code == XML_ERR_NO_MEMORY);\n            xmlFreeTextReader(reader);\n        }\n    }\n#endif\n\nexit:\n    xmlFuzzMemSetLimit(0);\n    xmlFuzzDataCleanup();\n    xmlResetLastError();\n    return(0);\n}\nstatic int ExecuteFilesOnyByOne(int argc, char **argv,\n                                int (*callback)(const uint8_t *data,\n                                                size_t         size)) {\n\n  unsigned char *buf = (unsigned char *)malloc(MAX_FILE);\n\n  __asan_poison_memory_region(buf, MAX_FILE);\n  ssize_t prev_length = 0;\n\n  for (int i = 1; i < argc; i++) {\n\n    int fd = 0;\n\n    if (strcmp(argv[i], \"-\") != 0) { fd = open(argv[i], O_RDONLY); }\n\n    if (fd == -1) { continue; }\n\n#ifndef __HAIKU__\n    ssize_t length = syscall(SYS_read, fd, buf, MAX_FILE);\n#else\n    ssize_t length = _kern_read(fd, buf, MAX_FILE);\n#endif  // HAIKU\n\n    if (length > 0) {\n\n      if (length < prev_length) {\n\n        __asan_poison_memory_region(buf + length, prev_length - length);\n\n      } else {\n\n        __asan_unpoison_memory_region(buf + prev_length, length - prev_length);\n\n      }\n\n      prev_length = length;\n\n      printf(\"Reading %zu bytes from %s\\n\", length, argv[i]);\n      callback(buf, length);\n      printf(\"Execution successful.\\n\");\n\n    }\n\n    if (fd > 0) { close(fd); }\n\n  }\n\n  free(buf);\n  return 0;\n\n}\n__attribute__((weak)) int main(int argc, char **argv) {\n\n  // Enable if LLVMFuzzerTestOneInput() has the weak attribute\n  /*\n    if (!LLVMFuzzerTestOneInput) {\n\n      fprintf(stderr, \"Error: function LLVMFuzzerTestOneInput() not found!\\n\");\n      abort();\n\n    }\n\n  */\n\n  if (argc < 2 || strncmp(argv[1], \"-h\", 2) == 0)\n    printf(\n        \"============================== INFO ================================\\n\"\n        \"This binary is built for afl++.\\n\"\n        \"To run the target function on individual input(s) execute:\\n\"\n        \"  %s INPUT_FILE1 [INPUT_FILE2 ... ]\\n\"\n        \"To fuzz with afl-fuzz execute:\\n\"\n        \"  afl-fuzz [afl-flags] -- %s [-N]\\n\"\n        \"afl-fuzz will run N iterations before re-spawning the process \"\n        \"(default: \"\n        \"INT_MAX)\\n\"\n        \"For stdin input processing, pass '-' as single command line option.\\n\"\n        \"For file input processing, pass '@@' as single command line option.\\n\"\n        \"To use with afl-cmin or afl-cmin.bash pass '-' as single command line \"\n        \"option\\n\"\n        \"===================================================================\\n\",\n        argv[0], argv[0]);\n\n  return LLVMFuzzerRunDriver(&argc, &argv, LLVMFuzzerTestOneInput);\n\n}",
    "target": 0,
    "idx": 2066446
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "int\nxmlAddIDSafe(xmlDocPtr doc, const xmlChar *value, xmlAttrPtr attr,\n             int streaming, xmlIDPtr *id) {\n    xmlIDPtr ret;\n    xmlIDTablePtr table;\n\n    if (id != NULL)\n        *id = NULL;\n\n    if (doc == NULL) {\n\treturn(-1);\n    }\n    if ((value == NULL) || (value[0] == 0)) {\n\treturn(0);\n    }\n    if (attr == NULL) {\n\treturn(-1);\n    }\n\n    /*\n     * Create the ID table if needed.\n     */\n    table = (xmlIDTablePtr) doc->ids;\n    if (table == NULL)  {\n        doc->ids = table = xmlHashCreateDict(0, doc->dict);\n        if (table == NULL)\n            return(-1);\n    } else {\n        ret = xmlHashLookup(table, value);\n        if (ret != NULL) {\n            /*\n             * Update the attribute to make entities work.\n             */\n            if (!streaming) {\n                if (ret->attr != NULL) {\n                    ret->attr->id = NULL;\n                    ret->attr = attr;\n                }\n                attr->id = ret;\n            }\n\t    attr->atype = XML_ATTRIBUTE_ID;\n            return(0);\n        }\n    }\n\n    ret = (xmlIDPtr) xmlMalloc(sizeof(xmlID));\n    if (ret == NULL)\n\treturn(-1);\n    memset(ret, 0, sizeof(*ret));\n\n    /*\n     * fill the structure.\n     */\n    ret->doc = doc;\n    ret->value = xmlStrdup(value);\n    if (ret->value == NULL) {\n        xmlFreeID(ret);\n        return(-1);\n    }\n    if (streaming) {\n\t/*\n\t * Operating in streaming mode, attr is gonna disappear\n\t */\n\tif (doc->dict != NULL)\n\t    ret->name = xmlDictLookup(doc->dict, attr->name, -1);\n\telse\n\t    ret->name = xmlStrdup(attr->name);\n        if (ret->name == NULL) {\n            xmlFreeID(ret);\n            return(-1);\n        }\n\tret->attr = NULL;\n    } else {\n\tret->attr = attr;\n\tret->name = NULL;\n    }\n    ret->lineno = xmlGetLineNo(attr->parent);\n\n    if (xmlHashAddEntry(table, value, ret) < 0) {\n\txmlFreeID(ret);\n\treturn(-1);\n    }\n\n    attr->atype = XML_ATTRIBUTE_ID;\n    if (!streaming)\n        attr->id = ret;\n\n    if (id != NULL)\n        *id = ret;\n    return(1);\n}\nint\nxmlRemoveID(xmlDocPtr doc, xmlAttrPtr attr) {\n    xmlIDTablePtr table;\n\n    if (doc == NULL) return(-1);\n    if ((attr == NULL) || (attr->id == NULL)) return(-1);\n\n    table = (xmlIDTablePtr) doc->ids;\n    if (table == NULL)\n        return(-1);\n\n    if (xmlHashRemoveEntry(table, attr->id->value, xmlFreeIDTableEntry) < 0)\n        return(-1);\n\n    attr->atype = 0;\n    attr->id = NULL;\n\n    return(0);\n}\nvoid\nxmlFreeProp(xmlAttrPtr cur) {\n    xmlDictPtr dict = NULL;\n    if (cur == NULL) return;\n\n    if (cur->doc != NULL) dict = cur->doc->dict;\n\n    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n\txmlDeregisterNodeDefaultValue((xmlNodePtr)cur);\n\n    /* Check for ID removal -> leading to invalid references ! */\n    if ((cur->doc != NULL) && (cur->atype == XML_ATTRIBUTE_ID)) {\n\t    xmlRemoveID(cur->doc, cur);\n    }\n    if (cur->children != NULL) xmlFreeNodeList(cur->children);\n    DICT_FREE(cur->name)\n    xmlFree(cur);\n}\nvoid\nxmlFreePropList(xmlAttrPtr cur) {\n    xmlAttrPtr next;\n    if (cur == NULL) return;\n    while (cur != NULL) {\n        next = cur->next;\n        xmlFreeProp(cur);\n\tcur = next;\n    }\n}\nvoid\nxmlFreeNodeList(xmlNodePtr cur) {\n    xmlNodePtr next;\n    xmlNodePtr parent;\n    xmlDictPtr dict = NULL;\n    size_t depth = 0;\n\n    if (cur == NULL) return;\n    if (cur->type == XML_NAMESPACE_DECL) {\n\txmlFreeNsList((xmlNsPtr) cur);\n\treturn;\n    }\n    if (cur->doc != NULL) dict = cur->doc->dict;\n    while (1) {\n        while ((cur->children != NULL) &&\n               (cur->type != XML_DOCUMENT_NODE) &&\n               (cur->type != XML_HTML_DOCUMENT_NODE) &&\n               (cur->type != XML_DTD_NODE) &&\n               (cur->type != XML_ENTITY_REF_NODE)) {\n            cur = cur->children;\n            depth += 1;\n        }\n\n        next = cur->next;\n        parent = cur->parent;\n\tif ((cur->type == XML_DOCUMENT_NODE) ||\n            (cur->type == XML_HTML_DOCUMENT_NODE)) {\n            xmlFreeDoc((xmlDocPtr) cur);\n        } else if (cur->type != XML_DTD_NODE) {\n\n\t    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n\t\txmlDeregisterNodeDefaultValue(cur);\n\n\t    if (((cur->type == XML_ELEMENT_NODE) ||\n\t\t (cur->type == XML_XINCLUDE_START) ||\n\t\t (cur->type == XML_XINCLUDE_END)) &&\n\t\t(cur->properties != NULL))\n\t\txmlFreePropList(cur->properties);\n\t    if ((cur->type != XML_ELEMENT_NODE) &&\n\t\t(cur->type != XML_XINCLUDE_START) &&\n\t\t(cur->type != XML_XINCLUDE_END) &&\n\t\t(cur->type != XML_ENTITY_REF_NODE) &&\n\t\t(cur->content != (xmlChar *) &(cur->properties))) {\n\t\tDICT_FREE(cur->content)\n\t    }\n\t    if (((cur->type == XML_ELEMENT_NODE) ||\n\t         (cur->type == XML_XINCLUDE_START) ||\n\t\t (cur->type == XML_XINCLUDE_END)) &&\n\t\t(cur->nsDef != NULL))\n\t\txmlFreeNsList(cur->nsDef);\n\n\t    /*\n\t     * When a node is a text node or a comment, it uses a global static\n\t     * variable for the name of the node.\n\t     * Otherwise the node name might come from the document's\n\t     * dictionary\n\t     */\n\t    if ((cur->name != NULL) &&\n\t\t(cur->type != XML_TEXT_NODE) &&\n\t\t(cur->type != XML_COMMENT_NODE))\n\t\tDICT_FREE(cur->name)\n\t    xmlFree(cur);\n\t}\n\n        if (next != NULL) {\n\t    cur = next;\n        } else {\n            if ((depth == 0) || (parent == NULL))\n                break;\n            depth -= 1;\n            cur = parent;\n            cur->children = NULL;\n        }\n    }\n}\nvoid\nxmlFreeNode(xmlNodePtr cur) {\n    xmlDictPtr dict = NULL;\n\n    if (cur == NULL) return;\n\n    /* use xmlFreeDtd for DTD nodes */\n    if (cur->type == XML_DTD_NODE) {\n\txmlFreeDtd((xmlDtdPtr) cur);\n\treturn;\n    }\n    if (cur->type == XML_NAMESPACE_DECL) {\n\txmlFreeNs((xmlNsPtr) cur);\n        return;\n    }\n    if (cur->type == XML_ATTRIBUTE_NODE) {\n\txmlFreeProp((xmlAttrPtr) cur);\n\treturn;\n    }\n\n    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n\txmlDeregisterNodeDefaultValue(cur);\n\n    if (cur->doc != NULL) dict = cur->doc->dict;\n\n    if (cur->type == XML_ENTITY_DECL) {\n        xmlEntityPtr ent = (xmlEntityPtr) cur;\n\tDICT_FREE(ent->SystemID);\n\tDICT_FREE(ent->ExternalID);\n    }\n    if ((cur->children != NULL) &&\n\t(cur->type != XML_ENTITY_REF_NODE))\n\txmlFreeNodeList(cur->children);\n\n    if ((cur->type == XML_ELEMENT_NODE) ||\n        (cur->type == XML_XINCLUDE_START) ||\n        (cur->type == XML_XINCLUDE_END)) {\n        if (cur->properties != NULL)\n            xmlFreePropList(cur->properties);\n        if (cur->nsDef != NULL)\n            xmlFreeNsList(cur->nsDef);\n    } else if ((cur->content != NULL) &&\n               (cur->type != XML_ENTITY_REF_NODE) &&\n               (cur->content != (xmlChar *) &(cur->properties))) {\n        DICT_FREE(cur->content)\n    }\n\n    /*\n     * When a node is a text node or a comment, it uses a global static\n     * variable for the name of the node.\n     * Otherwise the node name might come from the document's dictionary\n     */\n    if ((cur->name != NULL) &&\n        (cur->type != XML_TEXT_NODE) &&\n        (cur->type != XML_COMMENT_NODE))\n\tDICT_FREE(cur->name)\n\n    xmlFree(cur);\n}\nstatic xmlNodePtr\nxmlCtxtParseContent(xmlParserCtxtPtr ctxt, xmlParserInputPtr input,\n                    int hasTextDecl, int buildTree) {\n    xmlNodePtr root = NULL;\n    xmlNodePtr list = NULL;\n    xmlChar *rootName = BAD_CAST \"#root\";\n    int result;\n\n    if (buildTree) {\n        root = xmlNewDocNode(ctxt->myDoc, NULL, rootName, NULL);\n        if (root == NULL) {\n            xmlErrMemory(ctxt);\n            goto error;\n        }\n    }\n\n    if (xmlPushInput(ctxt, input) < 0)\n        goto error;\n\n    nameNsPush(ctxt, rootName, NULL, NULL, 0, 0);\n    spacePush(ctxt, -1);\n\n    if (buildTree)\n        nodePush(ctxt, root);\n\n    if (hasTextDecl) {\n        xmlDetectEncoding(ctxt);\n\n        /*\n         * Parse a possible text declaration first\n         */\n        if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) &&\n            (IS_BLANK_CH(NXT(5)))) {\n            xmlParseTextDecl(ctxt);\n            /*\n             * An XML-1.0 document can't reference an entity not XML-1.0\n             */\n            if ((xmlStrEqual(ctxt->version, BAD_CAST \"1.0\")) &&\n                (!xmlStrEqual(ctxt->input->version, BAD_CAST \"1.0\"))) {\n                xmlFatalErrMsg(ctxt, XML_ERR_VERSION_MISMATCH,\n                               \"Version mismatch between document and \"\n                               \"entity\\n\");\n            }\n        }\n    }\n\n    xmlParseContentInternal(ctxt);\n\n    if (ctxt->input->cur < ctxt->input->end)\n\txmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);\n\n    if ((ctxt->wellFormed) ||\n        ((ctxt->recovery) && (ctxt->errNo != XML_ERR_NO_MEMORY))) {\n        if (root != NULL) {\n            xmlNodePtr cur;\n\n            /*\n             * Return the newly created nodeset after unlinking it from\n             * its pseudo parent.\n             */\n            cur = root->children;\n            list = cur;\n            while (cur != NULL) {\n                cur->parent = NULL;\n                cur = cur->next;\n            }\n            root->children = NULL;\n            root->last = NULL;\n        }\n    }\n\n    /*\n     * Read the rest of the stream in case of errors. We want\n     * to account for the whole entity size.\n     */\n    do {\n        ctxt->input->cur = ctxt->input->end;\n        xmlParserShrink(ctxt);\n        result = xmlParserGrow(ctxt);\n    } while (result > 0);\n\n    if (buildTree)\n        nodePop(ctxt);\n\n    namePop(ctxt);\n    spacePop(ctxt);\n\n    /* xmlPopInput would free the stream */\n    inputPop(ctxt);\n\nerror:\n    xmlFreeNode(root);\n\n    return(list);\n}\nstatic void\nxmlCtxtParseEntity(xmlParserCtxtPtr ctxt, xmlEntityPtr ent) {\n    xmlParserInputPtr input;\n    xmlNodePtr list;\n    unsigned long consumed;\n    int isExternal;\n    int buildTree;\n    int oldMinNsIndex;\n    int oldNodelen, oldNodemem;\n\n    isExternal = (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY);\n    buildTree = (ctxt->node != NULL);\n\n    /*\n     * Recursion check\n     */\n    if (ent->flags & XML_ENT_EXPANDING) {\n        xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);\n        xmlHaltParser(ctxt);\n        goto error;\n    }\n\n    /*\n     * Load entity\n     */\n    input = xmlNewEntityInputStream(ctxt, ent);\n    if (input == NULL)\n        goto error;\n\n    /*\n     * When building a tree, we need to limit the scope of namespace\n     * declarations, so that entities don't reference xmlNs structs\n     * from the parent of a reference.\n     */\n    oldMinNsIndex = ctxt->nsdb->minNsIndex;\n    if (buildTree)\n        ctxt->nsdb->minNsIndex = ctxt->nsNr;\n\n    oldNodelen = ctxt->nodelen;\n    oldNodemem = ctxt->nodemem;\n    ctxt->nodelen = 0;\n    ctxt->nodemem = 0;\n\n    /*\n     * Parse content\n     *\n     * This initiates a recursive call chain:\n     *\n     * - xmlCtxtParseContent\n     * - xmlParseContentInternal\n     * - xmlParseReference\n     * - xmlCtxtParseEntity\n     *\n     * The nesting depth is limited by the maximum number of inputs,\n     * see xmlPushInput.\n     *\n     * It's possible to make this non-recursive (minNsIndex must be\n     * stored in the input struct) at the expense of code readability.\n     */\n\n    ent->flags |= XML_ENT_EXPANDING;\n\n    list = xmlCtxtParseContent(ctxt, input, isExternal, buildTree);\n\n    ent->flags &= ~XML_ENT_EXPANDING;\n\n    ctxt->nsdb->minNsIndex = oldMinNsIndex;\n    ctxt->nodelen = oldNodelen;\n    ctxt->nodemem = oldNodemem;\n\n    /*\n     * Entity size accounting\n     */\n    consumed = input->consumed;\n    xmlSaturatedAddSizeT(&consumed, input->end - input->base);\n\n    if ((ent->flags & XML_ENT_CHECKED) == 0)\n        xmlSaturatedAdd(&ent->expandedSize, consumed);\n\n    if ((ent->flags & XML_ENT_PARSED) == 0) {\n        if (isExternal)\n            xmlSaturatedAdd(&ctxt->sizeentities, consumed);\n\n        ent->children = list;\n\n        while (list != NULL) {\n            list->parent = (xmlNodePtr) ent;\n            if (list->next == NULL)\n                ent->last = list;\n            list = list->next;\n        }\n    } else {\n        xmlFreeNodeList(list);\n    }\n\n    xmlFreeInputStream(input);\n\nerror:\n    ent->flags |= XML_ENT_PARSED | XML_ENT_CHECKED;\n}\nint\nxmlParseChunk(xmlParserCtxtPtr ctxt, const char *chunk, int size,\n              int terminate) {\n    size_t curBase;\n    size_t maxLength;\n    int end_in_lf = 0;\n\n    if ((ctxt == NULL) || (size < 0))\n        return(XML_ERR_ARGUMENT);\n    if (ctxt->disableSAX != 0)\n        return(ctxt->errNo);\n    if (ctxt->input == NULL)\n        return(XML_ERR_INTERNAL_ERROR);\n\n    ctxt->input->flags |= XML_INPUT_PROGRESSIVE;\n    if (ctxt->instate == XML_PARSER_START)\n        xmlCtxtInitializeLate(ctxt);\n    if ((size > 0) && (chunk != NULL) && (!terminate) &&\n        (chunk[size - 1] == '\\r')) {\n\tend_in_lf = 1;\n\tsize--;\n    }\n\n    if ((size > 0) && (chunk != NULL) && (ctxt->input != NULL) &&\n        (ctxt->input->buf != NULL))  {\n\tsize_t pos = ctxt->input->cur - ctxt->input->base;\n\tint res;\n\n\tres = xmlParserInputBufferPush(ctxt->input->buf, size, chunk);\n        xmlBufUpdateInput(ctxt->input->buf->buffer, ctxt->input, pos);\n\tif (res < 0) {\n            xmlCtxtErrIO(ctxt, ctxt->input->buf->error, NULL);\n\t    xmlHaltParser(ctxt);\n\t    return(ctxt->errNo);\n\t}\n    }\n\n    xmlParseTryOrFinish(ctxt, terminate);\n\n    curBase = ctxt->input->cur - ctxt->input->base;\n    maxLength = (ctxt->options & XML_PARSE_HUGE) ?\n                XML_MAX_HUGE_LENGTH :\n                XML_MAX_LOOKUP_LIMIT;\n    if (curBase > maxLength) {\n        xmlFatalErr(ctxt, XML_ERR_RESOURCE_LIMIT,\n                    \"Buffer size limit exceeded, try XML_PARSE_HUGE\\n\");\n        xmlHaltParser(ctxt);\n    }\n\n    if ((ctxt->errNo != XML_ERR_OK) && (ctxt->disableSAX == 1))\n        return(ctxt->errNo);\n\n    if ((end_in_lf == 1) && (ctxt->input != NULL) &&\n        (ctxt->input->buf != NULL)) {\n\tsize_t pos = ctxt->input->cur - ctxt->input->base;\n        int res;\n\n\tres = xmlParserInputBufferPush(ctxt->input->buf, 1, \"\\r\");\n\txmlBufUpdateInput(ctxt->input->buf->buffer, ctxt->input, pos);\n        if (res < 0) {\n            xmlCtxtErrIO(ctxt, ctxt->input->buf->error, NULL);\n            xmlHaltParser(ctxt);\n            return(ctxt->errNo);\n        }\n    }\n    if (terminate) {\n\t/*\n\t * Check for termination\n\t */\n        if ((ctxt->instate != XML_PARSER_EOF) &&\n            (ctxt->instate != XML_PARSER_EPILOG)) {\n            if (ctxt->nameNr > 0) {\n                const xmlChar *name = ctxt->nameTab[ctxt->nameNr - 1];\n                int line = ctxt->pushTab[ctxt->nameNr - 1].line;\n                xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NOT_FINISHED,\n                        \"Premature end of data in tag %s line %d\\n\",\n                        name, line, NULL);\n            } else if (ctxt->instate == XML_PARSER_START) {\n                xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);\n            } else {\n                xmlFatalErrMsg(ctxt, XML_ERR_DOCUMENT_EMPTY,\n                               \"Start tag expected, '<' not found\\n\");\n            }\n        } else if ((ctxt->input->buf != NULL) &&\n                   (ctxt->input->buf->encoder != NULL) &&\n                   (!xmlBufIsEmpty(ctxt->input->buf->raw))) {\n            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n                           \"Truncated multi-byte sequence at EOF\\n\");\n        }\n\tif (ctxt->instate != XML_PARSER_EOF) {\n            ctxt->instate = XML_PARSER_EOF;\n            xmlFinishDocument(ctxt);\n\t}\n    }\n    if (ctxt->wellFormed == 0)\n\treturn((xmlParserErrors) ctxt->errNo);\n    else\n        return(0);\n}\nstatic int\nxmlTextReaderPushData(xmlTextReaderPtr reader) {\n    xmlBufPtr inbuf;\n    int val, s;\n    xmlTextReaderState oldstate;\n\n    if ((reader->input == NULL) || (reader->input->buffer == NULL))\n\treturn(-1);\n\n    oldstate = reader->state;\n    reader->state = XML_TEXTREADER_NONE;\n    inbuf = reader->input->buffer;\n\n    while (reader->state == XML_TEXTREADER_NONE) {\n\tif (xmlBufUse(inbuf) < reader->cur + CHUNK_SIZE) {\n\t    /*\n\t     * Refill the buffer unless we are at the end of the stream\n\t     */\n\t    if (reader->mode != XML_TEXTREADER_MODE_EOF) {\n\t\tval = xmlParserInputBufferRead(reader->input, 4096);\n\t\tif (val == 0) {\n\t\t    if (xmlBufUse(inbuf) == reader->cur) {\n\t\t\treader->mode = XML_TEXTREADER_MODE_EOF;\n                        break;\n\t\t    }\n\t\t} else if (val < 0) {\n                    xmlCtxtErrIO(reader->ctxt, reader->input->error, NULL);\n                    reader->mode = XML_TEXTREADER_MODE_ERROR;\n                    reader->state = XML_TEXTREADER_ERROR;\n                    return(-1);\n\t\t}\n\n\t    } else\n\t\tbreak;\n\t}\n\t/*\n\t * parse by block of CHUNK_SIZE bytes, various tests show that\n\t * it's the best tradeoff at least on a 1.2GH Duron\n\t */\n\tif (xmlBufUse(inbuf) >= reader->cur + CHUNK_SIZE) {\n\t    val = xmlParseChunk(reader->ctxt,\n                 (const char *) xmlBufContent(inbuf) + reader->cur,\n                                CHUNK_SIZE, 0);\n\t    reader->cur += CHUNK_SIZE;\n\t    if (val != 0)\n\t\treader->ctxt->wellFormed = 0;\n\t    if (reader->ctxt->wellFormed == 0)\n\t\tbreak;\n\t} else {\n\t    s = xmlBufUse(inbuf) - reader->cur;\n\t    val = xmlParseChunk(reader->ctxt,\n\t\t (const char *) xmlBufContent(inbuf) + reader->cur,\n\t\t\t        s, 0);\n\t    reader->cur += s;\n\t    if (val != 0)\n\t\treader->ctxt->wellFormed = 0;\n\t    break;\n\t}\n    }\n    reader->state = oldstate;\n\n    /*\n     * Discard the consumed input when needed and possible\n     */\n    if (reader->mode == XML_TEXTREADER_MODE_INTERACTIVE) {\n        if (reader->input->readcallback != NULL) {\n\t    if ((reader->cur >= 4096) &&\n\t\t(xmlBufUse(inbuf) - reader->cur <= CHUNK_SIZE)) {\n\t\tval = xmlBufShrink(inbuf, reader->cur);\n\t\tif (val >= 0) {\n\t\t    reader->cur -= val;\n\t\t}\n\t    }\n\t}\n    }\n\n    /*\n     * At the end of the stream signal that the work is done to the Push\n     * parser.\n     */\n    else if (reader->mode == XML_TEXTREADER_MODE_EOF) {\n\tif (reader->state != XML_TEXTREADER_DONE) {\n\t    s = xmlBufUse(inbuf) - reader->cur;\n\t    val = xmlParseChunk(reader->ctxt,\n\t\t (const char *) xmlBufContent(inbuf) + reader->cur,\n\t\t\t        s, 1);\n\t    reader->cur = xmlBufUse(inbuf);\n\t    reader->state  = XML_TEXTREADER_DONE;\n\t    if (val != 0) {\n\t        if (reader->ctxt->wellFormed)\n\t\t    reader->ctxt->wellFormed = 0;\n\t\telse\n\t\t    return(-1);\n\t    }\n\t}\n    }\n    if (reader->ctxt->wellFormed == 0) {\n\treader->mode = XML_TEXTREADER_MODE_EOF;\n        return(-1);\n    }\n\n    return(0);\n}\nint\nxmlTextReaderRead(xmlTextReaderPtr reader) {\n    int val, olddepth = 0;\n    xmlTextReaderState oldstate = XML_TEXTREADER_START;\n    xmlNodePtr oldnode = NULL;\n\n\n    if (reader == NULL)\n\treturn(-1);\n    reader->curnode = NULL;\n    if (reader->doc != NULL)\n        return(xmlTextReaderReadTree(reader));\n    if (reader->ctxt == NULL)\n\treturn(-1);\n\n    if (reader->mode == XML_TEXTREADER_MODE_INITIAL) {\n\treader->mode = XML_TEXTREADER_MODE_INTERACTIVE;\n\t/*\n\t * Initial state\n\t */\n\tdo {\n\t    val = xmlTextReaderPushData(reader);\n\t\tif (val < 0){\n\t\t\treader->mode = XML_TEXTREADER_MODE_ERROR;\n\t\t\treader->state = XML_TEXTREADER_ERROR;\n\t\treturn(-1);\n\t\t}\n\t} while ((reader->ctxt->node == NULL) &&\n\t\t ((reader->mode != XML_TEXTREADER_MODE_EOF) &&\n\t\t  (reader->state != XML_TEXTREADER_DONE)));\n\tif (reader->ctxt->node == NULL) {\n\t    if (reader->ctxt->myDoc != NULL) {\n\t\treader->node = reader->ctxt->myDoc->children;\n\t    }\n\t    if (reader->node == NULL){\n\t\t\treader->mode = XML_TEXTREADER_MODE_ERROR;\n\t\t\treader->state = XML_TEXTREADER_ERROR;\n\t\treturn(-1);\n\t\t}\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t} else {\n\t    if (reader->ctxt->myDoc != NULL) {\n\t\treader->node = reader->ctxt->myDoc->children;\n\t    }\n\t    if (reader->node == NULL)\n\t\treader->node = reader->ctxt->nodeTab[0];\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t}\n\treader->depth = 0;\n\treader->ctxt->parseMode = XML_PARSE_READER;\n\tgoto node_found;\n    }\n    oldstate = reader->state;\n    olddepth = reader->ctxt->nodeNr;\n    oldnode = reader->node;\n\nget_next_node:\n    if (reader->node == NULL) {\n\tif (reader->mode == XML_TEXTREADER_MODE_EOF)\n\t    return(0);\n\telse\n\t    return(-1);\n    }\n\n    /*\n     * If we are not backtracking on ancestors or examined nodes,\n     * that the parser didn't finished or that we aren't at the end\n     * of stream, continue processing.\n     */\n    while ((reader->node != NULL) && (reader->node->next == NULL) &&\n\t   (reader->ctxt->nodeNr == olddepth) &&\n           ((oldstate == XML_TEXTREADER_BACKTRACK) ||\n            (reader->node->children == NULL) ||\n\t    (reader->node->type == XML_ENTITY_REF_NODE) ||\n\t    ((reader->node->children != NULL) &&\n\t     (reader->node->children->type == XML_TEXT_NODE) &&\n\t     (reader->node->children->next == NULL)) ||\n\t    (reader->node->type == XML_DTD_NODE) ||\n\t    (reader->node->type == XML_DOCUMENT_NODE) ||\n\t    (reader->node->type == XML_HTML_DOCUMENT_NODE)) &&\n\t   ((reader->ctxt->node == NULL) ||\n\t    (reader->ctxt->node == reader->node) ||\n\t    (reader->ctxt->node == reader->node->parent)) &&\n\t   (reader->ctxt->instate != XML_PARSER_EOF) &&\n\t   (PARSER_STOPPED(reader->ctxt) == 0)) {\n\tval = xmlTextReaderPushData(reader);\n\tif (val < 0)\n\t    return(-1);\n\tif (reader->node == NULL)\n\t    goto node_end;\n    }\n    if (oldstate != XML_TEXTREADER_BACKTRACK) {\n\tif ((reader->node->children != NULL) &&\n\t    (reader->node->type != XML_ENTITY_REF_NODE) &&\n\t    (reader->node->type != XML_XINCLUDE_START) &&\n\t    (reader->node->type != XML_DTD_NODE)) {\n\t    reader->node = reader->node->children;\n\t    reader->depth++;\n\t    reader->state = XML_TEXTREADER_ELEMENT;\n\t    goto node_found;\n\t}\n    }\n    if (reader->node->next != NULL) {\n\tif ((oldstate == XML_TEXTREADER_ELEMENT) &&\n            (reader->node->type == XML_ELEMENT_NODE) &&\n\t    (reader->node->children == NULL) &&\n\t    ((reader->node->extra & NODE_IS_EMPTY) == 0)\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    && (reader->in_xinclude <= 0)\n#endif\n\t    ) {\n\t    reader->state = XML_TEXTREADER_END;\n\t    goto node_found;\n\t}\n#ifdef LIBXML_REGEXP_ENABLED\n\tif ((reader->validate) &&\n\t    (reader->node->type == XML_ELEMENT_NODE))\n\t    if (xmlTextReaderValidatePop(reader) < 0)\n                return(-1);\n#endif /* LIBXML_REGEXP_ENABLED */\n        if ((reader->preserves > 0) &&\n\t    (reader->node->extra & NODE_IS_SPRESERVED))\n\t    reader->preserves--;\n\treader->node = reader->node->next;\n\treader->state = XML_TEXTREADER_ELEMENT;\n\n\t/*\n\t * Cleanup of the old node\n\t */\n\tif ((reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    (reader->in_xinclude == 0) &&\n#endif\n\t    (reader->entNr == 0) &&\n\t    (reader->node->prev != NULL) &&\n            (reader->node->prev->type != XML_DTD_NODE)) {\n\t    xmlNodePtr tmp = reader->node->prev;\n\t    if ((tmp->extra & NODE_IS_PRESERVED) == 0) {\n                if (oldnode == tmp)\n                    oldnode = NULL;\n\t\txmlUnlinkNode(tmp);\n\t\txmlTextReaderFreeNode(reader, tmp);\n\t    }\n\t}\n\n\tgoto node_found;\n    }\n    if ((oldstate == XML_TEXTREADER_ELEMENT) &&\n\t(reader->node->type == XML_ELEMENT_NODE) &&\n\t(reader->node->children == NULL) &&\n\t((reader->node->extra & NODE_IS_EMPTY) == 0)) {;\n\treader->state = XML_TEXTREADER_END;\n\tgoto node_found;\n    }\n#ifdef LIBXML_REGEXP_ENABLED\n    if ((reader->validate != XML_TEXTREADER_NOT_VALIDATE) &&\n        (reader->node->type == XML_ELEMENT_NODE)) {\n        if (xmlTextReaderValidatePop(reader) < 0)\n            return(-1);\n    }\n#endif /* LIBXML_REGEXP_ENABLED */\n    if ((reader->preserves > 0) &&\n\t(reader->node->extra & NODE_IS_SPRESERVED))\n\treader->preserves--;\n    reader->node = reader->node->parent;\n    if ((reader->node == NULL) ||\n\t(reader->node->type == XML_DOCUMENT_NODE) ||\n\t(reader->node->type == XML_HTML_DOCUMENT_NODE)) {\n\tif (reader->mode != XML_TEXTREADER_MODE_EOF) {\n\t    val = xmlParseChunk(reader->ctxt, \"\", 0, 1);\n\t    reader->state = XML_TEXTREADER_DONE;\n\t    if (val != 0)\n\t        return(-1);\n\t}\n\treader->node = NULL;\n\treader->depth = -1;\n\n\t/*\n\t * Cleanup of the old node\n\t */\n\tif ((oldnode != NULL) && (reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n\t    (reader->in_xinclude == 0) &&\n#endif\n\t    (reader->entNr == 0) &&\n\t    (oldnode->type != XML_DTD_NODE) &&\n\t    ((oldnode->extra & NODE_IS_PRESERVED) == 0)) {\n\t    xmlUnlinkNode(oldnode);\n\t    xmlTextReaderFreeNode(reader, oldnode);\n\t}\n\n\tgoto node_end;\n    }\n    if ((reader->preserves == 0) &&\n#ifdef LIBXML_XINCLUDE_ENABLED\n        (reader->in_xinclude == 0) &&\n#endif\n\t(reader->entNr == 0) &&\n        (reader->node->last != NULL) &&\n        ((reader->node->last->extra & NODE_IS_PRESERVED) == 0)) {\n\txmlNodePtr tmp = reader->node->last;\n\txmlUnlinkNode(tmp);\n\txmlTextReaderFreeNode(reader, tmp);\n    }\n    reader->depth--;\n    reader->state = XML_TEXTREADER_BACKTRACK;\n\nnode_found:\n    /*\n     * If we are in the middle of a piece of CDATA make sure it's finished\n     */\n    if ((reader->node != NULL) &&\n        (reader->node->next == NULL) &&\n        ((reader->node->type == XML_TEXT_NODE) ||\n\t (reader->node->type == XML_CDATA_SECTION_NODE))) {\n            if (xmlTextReaderExpand(reader) == NULL)\n\t        return -1;\n    }\n\n#ifdef LIBXML_XINCLUDE_ENABLED\n    /*\n     * Handle XInclude if asked for\n     */\n    if ((reader->xinclude) && (reader->in_xinclude == 0) &&\n        (reader->state != XML_TEXTREADER_BACKTRACK) &&\n        (reader->node != NULL) &&\n\t(reader->node->type == XML_ELEMENT_NODE) &&\n\t(reader->node->ns != NULL) &&\n\t((xmlStrEqual(reader->node->ns->href, XINCLUDE_NS)) ||\n\t (xmlStrEqual(reader->node->ns->href, XINCLUDE_OLD_NS)))) {\n\tif (reader->xincctxt == NULL) {\n\t    reader->xincctxt = xmlXIncludeNewContext(reader->ctxt->myDoc);\n            if (reader->xincctxt == NULL) {\n                xmlTextReaderErrMemory(reader);\n                return(-1);\n            }\n\t    xmlXIncludeSetFlags(reader->xincctxt,\n\t                        reader->parserFlags & (~XML_PARSE_NOXINCNODE));\n            xmlXIncludeSetStreamingMode(reader->xincctxt, 1);\n            if ((reader->errorFunc != NULL) || (reader->sErrorFunc != NULL))\n                xmlXIncludeSetErrorHandler(reader->xincctxt,\n                        xmlTextReaderStructuredRelay, reader);\n\t}\n\t/*\n\t * expand that node and process it\n\t */\n\tif (xmlTextReaderExpand(reader) == NULL)\n\t    return(-1);\n        if (xmlXIncludeProcessNode(reader->xincctxt, reader->node) < 0) {\n            int err = xmlXIncludeGetLastError(reader->xincctxt);\n\n            if (err == XML_ERR_NO_MEMORY)\n                xmlTextReaderErrMemory(reader);\n            return(-1);\n        }\n    }\n    if ((reader->node != NULL) && (reader->node->type == XML_XINCLUDE_START)) {\n        reader->in_xinclude++;\n\tgoto get_next_node;\n    }\n    if ((reader->node != NULL) && (reader->node->type == XML_XINCLUDE_END)) {\n        reader->in_xinclude--;\n\tgoto get_next_node;\n    }\n#endif\n    /*\n     * Handle entities enter and exit when in entity replacement mode\n     */\n    if ((reader->node != NULL) &&\n\t(reader->node->type == XML_ENTITY_REF_NODE) &&\n\t(reader->ctxt != NULL) && (reader->ctxt->replaceEntities == 1)) {\n\tif ((reader->node->children != NULL) &&\n\t    (reader->node->children->type == XML_ENTITY_DECL) &&\n\t    (reader->node->children->children != NULL)) {\n\t    if (xmlTextReaderEntPush(reader, reader->node) < 0)\n                goto get_next_node;\n\t    reader->node = reader->node->children->children;\n\t}\n#ifdef LIBXML_REGEXP_ENABLED\n    } else if ((reader->node != NULL) &&\n\t       (reader->node->type == XML_ENTITY_REF_NODE) &&\n\t       (reader->ctxt != NULL) && (reader->validate)) {\n\txmlTextReaderValidateEntity(reader);\n#endif /* LIBXML_REGEXP_ENABLED */\n    }\n    if ((reader->node != NULL) &&\n\t(reader->node->type == XML_ENTITY_DECL) &&\n\t(reader->ent != NULL) && (reader->ent->children == reader->node)) {\n\treader->node = xmlTextReaderEntPop(reader);\n\treader->depth++;\n        goto get_next_node;\n    }\n#ifdef LIBXML_REGEXP_ENABLED\n    if ((reader->validate != XML_TEXTREADER_NOT_VALIDATE) && (reader->node != NULL)) {\n\txmlNodePtr node = reader->node;\n\n\tif ((node->type == XML_ELEMENT_NODE) &&\n            ((reader->state != XML_TEXTREADER_END) &&\n\t     (reader->state != XML_TEXTREADER_BACKTRACK))) {\n\t    if (xmlTextReaderValidatePush(reader) < 0)\n                return(-1);\n\t} else if ((node->type == XML_TEXT_NODE) ||\n\t\t   (node->type == XML_CDATA_SECTION_NODE)) {\n            xmlTextReaderValidateCData(reader, node->content,\n\t                               xmlStrlen(node->content));\n\t}\n    }\n#endif /* LIBXML_REGEXP_ENABLED */\n#ifdef LIBXML_PATTERN_ENABLED\n    if ((reader->patternNr > 0) && (reader->state != XML_TEXTREADER_END) &&\n        (reader->state != XML_TEXTREADER_BACKTRACK)) {\n        int i;\n\tfor (i = 0;i < reader->patternNr;i++) {\n\t     if (xmlPatternMatch(reader->patternTab[i], reader->node) == 1) {\n\t         xmlTextReaderPreserve(reader);\n\t\t break;\n             }\n\t}\n    }\n#endif /* LIBXML_PATTERN_ENABLED */\n#ifdef LIBXML_SCHEMAS_ENABLED\n    if ((reader->validate == XML_TEXTREADER_VALIDATE_XSD) &&\n        (reader->xsdValidErrors == 0) &&\n\t(reader->xsdValidCtxt != NULL)) {\n\treader->xsdValidErrors = !xmlSchemaIsValid(reader->xsdValidCtxt);\n    }\n#endif /* LIBXML_PATTERN_ENABLED */\n    return(1);\nnode_end:\n    reader->state = XML_TEXTREADER_DONE;\n    return(0);\n}\nint\nLLVMFuzzerTestOneInput(const char *data, size_t size) {\n    xmlParserCtxtPtr ctxt;\n    xmlDocPtr doc;\n    const char *docBuffer, *docUrl;\n    size_t maxAlloc, docSize;\n    int opts;\n\n    xmlFuzzDataInit(data, size);\n    opts = (int) xmlFuzzReadInt(4);\n    /*\n     * Disable options that are known to cause timeouts\n     */\n    opts &= ~XML_PARSE_XINCLUDE &\n            ~XML_PARSE_DTDVALID &\n            ~XML_PARSE_SAX1;\n    maxAlloc = xmlFuzzReadInt(4) % (size + 100);\n\n    xmlFuzzReadEntities();\n    docBuffer = xmlFuzzMainEntity(&docSize);\n    docUrl = xmlFuzzMainUrl();\n    if (docBuffer == NULL)\n        goto exit;\n\n    /* Pull parser */\n\n    xmlFuzzMemSetLimit(maxAlloc);\n    ctxt = xmlNewParserCtxt();\n    if (ctxt != NULL) {\n        doc = xmlCtxtReadMemory(ctxt, docBuffer, docSize, docUrl, NULL, opts);\n        xmlFuzzCheckMallocFailure(\"xmlCtxtReadMemory\",\n                                  doc == NULL &&\n                                  ctxt->errNo == XML_ERR_NO_MEMORY);\n\n        if (doc != NULL) {\n#ifdef LIBXML_OUTPUT_ENABLED\n            xmlBufferPtr buffer;\n            xmlSaveCtxtPtr save;\n\n            /* Also test the serializer. */\n            buffer = xmlBufferCreate();\n            save = xmlSaveToBuffer(buffer, NULL, 0);\n            if (save != NULL) {\n                int errNo;\n\n                xmlSaveDoc(save, doc);\n                errNo = xmlSaveFinish(save);\n                xmlFuzzCheckMallocFailure(\"xmlSaveDoc\",\n                                          errNo == XML_ERR_NO_MEMORY);\n            }\n            xmlBufferFree(buffer);\n#endif\n            xmlFreeDoc(doc);\n        }\n\n        xmlFreeParserCtxt(ctxt);\n    }\n\n    /* Push parser */\n\n#ifdef LIBXML_PUSH_ENABLED\n    {\n        static const size_t maxChunkSize = 128;\n        size_t consumed, chunkSize;\n\n        xmlFuzzMemSetLimit(maxAlloc);\n        ctxt = xmlCreatePushParserCtxt(NULL, NULL, NULL, 0, docUrl);\n        if (ctxt != NULL) {\n            xmlCtxtUseOptions(ctxt, opts);\n\n            for (consumed = 0; consumed < docSize; consumed += chunkSize) {\n                chunkSize = docSize - consumed;\n                if (chunkSize > maxChunkSize)\n                    chunkSize = maxChunkSize;\n                xmlParseChunk(ctxt, docBuffer + consumed, chunkSize, 0);\n            }\n\n            xmlParseChunk(ctxt, NULL, 0, 1);\n            xmlFuzzCheckMallocFailure(\"xmlParseChunk\",\n                                      ctxt->errNo == XML_ERR_NO_MEMORY);\n            xmlFreeDoc(ctxt->myDoc);\n            xmlFreeParserCtxt(ctxt);\n        }\n    }\n#endif\n\n    /* Reader */\n\n#ifdef LIBXML_READER_ENABLED\n    {\n        xmlTextReaderPtr reader;\n        const xmlError *error;\n        int j;\n\n        xmlFuzzMemSetLimit(maxAlloc);\n        reader = xmlReaderForMemory(docBuffer, docSize, NULL, NULL, opts);\n        if (reader != NULL) {\n            while (xmlTextReaderRead(reader) == 1) {\n                if (xmlTextReaderNodeType(reader) == XML_ELEMENT_NODE) {\n                    int i, n = xmlTextReaderAttributeCount(reader);\n                    for (i=0; i<n; i++) {\n                        xmlTextReaderMoveToAttributeNo(reader, i);\n                        while (xmlTextReaderReadAttributeValue(reader) == 1);\n                    }\n                }\n            }\n            for (j = 0; j < 10; j++)\n                xmlTextReaderRead(reader);\n            error = xmlTextReaderGetLastError(reader);\n            xmlFuzzCheckMallocFailure(\"xmlTextReaderRead\",\n                                      error->code == XML_ERR_NO_MEMORY);\n            xmlFreeTextReader(reader);\n        }\n    }\n#endif\n\nexit:\n    xmlFuzzMemSetLimit(0);\n    xmlFuzzDataCleanup();\n    xmlResetLastError();\n    return(0);\n}",
    "target": 0,
    "idx": 2066502
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "static int\nsc_oberthur_read_file(struct sc_pkcs15_card *p15card, const char *in_path,\n\t\tunsigned char **out, size_t *out_len,\n\t\tint verify_pin)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_card *card = p15card->card;\n\tstruct sc_file *file = NULL;\n\tstruct sc_path path;\n\tsize_t sz;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (!in_path || !out || !out_len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, \"Cannot read oberthur file\");\n\n\tsc_log(ctx, \"read file '%s'; verify_pin:%i\", in_path, verify_pin);\n\n\t*out = NULL;\n\t*out_len = 0;\n\n\tsc_format_path(in_path, &path);\n\trv = sc_select_file(card, &path, &file);\n\tif (rv != SC_SUCCESS) {\n\t\tsc_file_free(file);\n\t\tLOG_TEST_RET(ctx, rv, \"Cannot select oberthur file to read\");\n\t}\n\n\tif (file->ef_structure == SC_FILE_EF_TRANSPARENT)\n\t\tsz = file->size;\n\telse\n\t\tsz = (file->record_length + 2) * file->record_count;\n\n\t*out = calloc(sz, 1);\n\tif (*out == NULL) {\n\t\tsc_file_free(file);\n\t\tLOG_TEST_RET(ctx, SC_ERROR_OUT_OF_MEMORY, \"Cannot read oberthur file\");\n\t}\n\n\tif (file->ef_structure == SC_FILE_EF_TRANSPARENT)   {\n\t\trv = sc_read_binary(card, 0, *out, sz, 0);\n\t}\n\telse\t{\n\t\tsize_t rec;\n\t\tsize_t offs = 0;\n\t\tsize_t rec_len = file->record_length;\n\n\t\tfor (rec = 1; ; rec++)   {\n\t\t\tif (rec > file->record_count) {\n\t\t\t\trv = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trv = sc_read_record(card, rec, *out + offs + 2, rec_len, SC_RECORD_BY_REC_NR);\n\t\t\tif (rv == SC_ERROR_RECORD_NOT_FOUND)   {\n\t\t\t\trv = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (rv < 0)   {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trec_len = rv;\n\n\t\t\t*(*out + offs) = 'R';\n\t\t\t*(*out + offs + 1) = rv;\n\n\t\t\toffs += rv + 2;\n\t\t}\n\n\t\tsz = offs;\n\t}\n\n\tsc_log(ctx, \"read oberthur file result %i\", rv);\n\tif (verify_pin && rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)   {\n\t\tstruct sc_pkcs15_object *objs[0x10], *pin_obj = NULL;\n\t\tconst struct sc_acl_entry *acl = sc_file_get_acl_entry(file, SC_AC_OP_READ);\n\t\tint ii, nobjs;\n\n\t\tif (acl == NULL) {\n\t\t\tsc_file_free(file);\n\t\t\tfree(*out);\n\t\t\t*out = NULL;\n\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_DATA);\n\t\t}\n\n\t\tnobjs = sc_pkcs15_get_objects(p15card, SC_PKCS15_TYPE_AUTH_PIN, objs, 0x10);\n\t\tif (nobjs < 1) {\n\t\t\tsc_file_free(file);\n\t\t\tfree(*out);\n\t\t\t*out = NULL;\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_DATA_OBJECT_NOT_FOUND,\n\t\t\t\t\"Cannot read oberthur file: get AUTH objects error\");\n\t\t}\n\n\t\tfor (ii = 0; ii < nobjs; ii++) {\n\t\t\tstruct sc_pkcs15_auth_info *auth_info = (struct sc_pkcs15_auth_info *) objs[ii]->data;\n\t\t\tsc_log(ctx, \"compare PIN/ACL refs:%i/%i, method:%i/%i\",\n\t\t\t\tauth_info->attrs.pin.reference, acl->key_ref, auth_info->auth_method, acl->method);\n\t\t\tif (auth_info->attrs.pin.reference == (int)acl->key_ref && auth_info->auth_method == (unsigned)acl->method)   {\n\t\t\t\tpin_obj = objs[ii];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!pin_obj || !pin_obj->content.value)    {\n\t\t\trv = SC_ERROR_SECURITY_STATUS_NOT_SATISFIED;\n\t\t}\n\t\telse    {\n\t\t\trv = sc_pkcs15_verify_pin(p15card, pin_obj, pin_obj->content.value, pin_obj->content.len);\n\t\t\tif (!rv)\n\t\t\t\trv = sc_oberthur_read_file(p15card, in_path, out, out_len, 0);\n\t\t}\n\t}\n\n\tsc_file_free(file);\n\n\tif (rv < 0)   {\n\t\tfree(*out);\n\t\t*out = NULL;\n\t\t*out_len = 0;\n\t}\n\n\t*out_len = sz;\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\nint sc_file_valid(const sc_file_t *file) {\n\tif (file == NULL)\n\t\treturn 0;\n\treturn file->magic == SC_FILE_MAGIC;\n}\nvoid sc_file_free(sc_file_t *file)\n{\n\tunsigned int i;\n\tif (file == NULL || !sc_file_valid(file))\n\t\treturn;\n\tfile->magic = 0;\n\tfor (i = 0; i < SC_MAX_AC_OPS; i++)\n\t\tsc_file_clear_acl_entries(file, i);\n\tif (file->sec_attr)\n\t\tfree(file->sec_attr);\n\tif (file->prop_attr)\n\t\tfree(file->prop_attr);\n\tif (file->type_attr)\n\t\tfree(file->type_attr);\n\tif (file->encoded_content)\n\t\tfree(file->encoded_content);\n\tfree(file);\n}\nstatic int\nsc_pkcs15emu_oberthur_init(struct sc_pkcs15_card * p15card)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_pkcs15_auth_info auth_info;\n\tstruct sc_pkcs15_object   obj;\n\tstruct sc_card *card = p15card->card;\n\tstruct sc_path path;\n\tint rv, ii, tries_left;\n\tchar serial[0x10];\n\tunsigned char sopin_reference = 0x04;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\tsc_bin_to_hex(card->serialnr.value, card->serialnr.len, serial, sizeof(serial), 0);\n\tset_string(&p15card->tokeninfo->serial_number, serial);\n\n\tp15card->ops.parse_df = sc_awp_parse_df;\n\tp15card->ops.clear = sc_awp_clear;\n\n\tsc_log(ctx, \"Oberthur init: serial %s\", p15card->tokeninfo->serial_number);\n\n\tsc_format_path(AWP_PIN_DF, &path);\n\trv = sc_select_file(card, &path, NULL);\n\tLOG_TEST_RET(ctx, rv, \"Oberthur init failed: cannot select PIN dir\");\n\n\ttries_left = -1;\n\trv = sc_verify(card, SC_AC_CHV, sopin_reference, (unsigned char *)\"\", 0, &tries_left);\n\tif (rv && rv != SC_ERROR_PIN_CODE_INCORRECT)   {\n\t\tsopin_reference = 0x84;\n\t\trv = sc_verify(card, SC_AC_CHV, sopin_reference, (unsigned char *)\"\", 0, &tries_left);\n\t}\n\tif (rv && rv != SC_ERROR_PIN_CODE_INCORRECT)\n\t\tLOG_TEST_RET(ctx, rv, \"Invalid state of SO-PIN\");\n\n\t/* add PIN */\n\tmemset(&auth_info, 0, sizeof(auth_info));\n\tmemset(&obj,  0, sizeof(obj));\n\n\tauth_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;\n\tauth_info.auth_method\t= SC_AC_CHV;\n\tauth_info.auth_id.len = 1;\n\tauth_info.auth_id.value[0] = 0xFF;\n\tauth_info.attrs.pin.min_length\t\t= 4;\n\tauth_info.attrs.pin.max_length\t\t= 64;\n\tauth_info.attrs.pin.stored_length\t= 64;\n\tauth_info.attrs.pin.type\t\t= SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;\n\tauth_info.attrs.pin.reference\t\t= sopin_reference;\n\tauth_info.attrs.pin.pad_char\t\t= 0xFF;\n\tauth_info.attrs.pin.flags\t\t= SC_PKCS15_PIN_FLAG_CASE_SENSITIVE\n\t\t\t\t| SC_PKCS15_PIN_FLAG_INITIALIZED\n\t\t\t\t| SC_PKCS15_PIN_FLAG_NEEDS_PADDING\n\t\t\t\t| SC_PKCS15_PIN_FLAG_SO_PIN;\n\tauth_info.tries_left\t\t= tries_left;\n\tauth_info.logged_in = SC_PIN_STATE_UNKNOWN;\n\n\tstrncpy(obj.label, \"SO PIN\", SC_PKCS15_MAX_LABEL_SIZE-1);\n\tobj.flags = SC_PKCS15_CO_FLAG_MODIFIABLE | SC_PKCS15_CO_FLAG_PRIVATE;\n\n\tsc_log(ctx, \"Add PIN(%s,auth_id:%s,reference:%i)\", obj.label,\n\t\t\tsc_pkcs15_print_id(&auth_info.auth_id), auth_info.attrs.pin.reference);\n\trv = sc_pkcs15emu_add_pin_obj(p15card, &obj, &auth_info);\n\tLOG_TEST_RET(ctx, rv, \"Oberthur init failed: cannot add PIN object\");\n\n\ttries_left = -1;\n\trv = sc_verify(card, SC_AC_CHV, 0x81, (unsigned char *)\"\", 0, &tries_left);\n\tif (rv == SC_ERROR_PIN_CODE_INCORRECT)   {\n\t\t/* add PIN */\n\t\tmemset(&auth_info, 0, sizeof(auth_info));\n\t\tmemset(&obj,  0, sizeof(obj));\n\n\t\tauth_info.auth_id.len = sizeof(PinDomainID) > sizeof(auth_info.auth_id.value)\n\t\t\t\t? sizeof(auth_info.auth_id.value) : sizeof(PinDomainID);\n\t\tmemcpy(auth_info.auth_id.value, PinDomainID, auth_info.auth_id.len);\n\t\tauth_info.auth_method\t= SC_AC_CHV;\n\n\t\tauth_info.attrs.pin.min_length\t\t= 4;\n\t\tauth_info.attrs.pin.max_length\t\t= 64;\n\t\tauth_info.attrs.pin.stored_length\t= 64;\n\t\tauth_info.attrs.pin.type\t\t= SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;\n\t\tauth_info.attrs.pin.reference\t\t= 0x81;\n\t\tauth_info.attrs.pin.pad_char\t\t= 0xFF;\n\t\tauth_info.attrs.pin.flags\t\t= SC_PKCS15_PIN_FLAG_CASE_SENSITIVE\n\t\t\t\t\t| SC_PKCS15_PIN_FLAG_INITIALIZED\n\t\t\t\t\t| SC_PKCS15_PIN_FLAG_NEEDS_PADDING\n\t\t\t\t\t| SC_PKCS15_PIN_FLAG_LOCAL;\n\t\tauth_info.tries_left\t\t= tries_left;\n\n\t\tstrncpy(obj.label, PIN_DOMAIN_LABEL, SC_PKCS15_MAX_LABEL_SIZE-1);\n\t\tobj.flags = SC_PKCS15_CO_FLAG_MODIFIABLE | SC_PKCS15_CO_FLAG_PRIVATE;\n\t\tif (sopin_reference == 0x84) {\n\t\t\t/*\n\t\t\t * auth_pin_reset_oberthur_style() in card-oberthur.c\n\t\t\t * always uses PUK with reference 0x84 for\n\t\t\t * unblocking of User PIN\n\t\t\t */\n\t\t\tobj.auth_id.len = 1;\n\t\t\tobj.auth_id.value[0] = 0xFF;\n\t\t}\n\n\t\tsc_format_path(AWP_PIN_DF, &auth_info.path);\n\t\tauth_info.path.type = SC_PATH_TYPE_PATH;\n\n\t\tsc_log(ctx, \"Add PIN(%s,auth_id:%s,reference:%i)\", obj.label,\n\t\t\t\tsc_pkcs15_print_id(&auth_info.auth_id), auth_info.attrs.pin.reference);\n\t\trv = sc_pkcs15emu_add_pin_obj(p15card, &obj, &auth_info);\n\t\tLOG_TEST_RET(ctx, rv, \"Oberthur init failed: cannot add PIN object\");\n\t}\n\telse if (rv != SC_ERROR_DATA_OBJECT_NOT_FOUND)    {\n\t\tLOG_TEST_RET(ctx, rv, \"Oberthur init failed: cannot verify PIN\");\n\t}\n\n\tfor (ii=0; oberthur_infos[ii].name; ii++)   {\n\t\tsc_log(ctx, \"Oberthur init: read %s file\", oberthur_infos[ii].name);\n\t\tfree(oberthur_infos[ii].content);\n\t\trv = sc_oberthur_read_file(p15card, oberthur_infos[ii].path,\n\t\t\t\t&oberthur_infos[ii].content, &oberthur_infos[ii].len, 1);\n\t\tLOG_TEST_RET(ctx, rv, \"Oberthur init failed: read oberthur file error\");\n\n\t\tsc_log(ctx,\n\t\t       \"Oberthur init: parse %s file, content length %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t       oberthur_infos[ii].name, oberthur_infos[ii].len);\n\t\trv = oberthur_infos[ii].parser(p15card, oberthur_infos[ii].content, oberthur_infos[ii].len,\n\t\t\t\toberthur_infos[ii].postpone_allowed);\n\t\tLOG_TEST_RET(ctx, rv, \"Oberthur init failed: parse error\");\n\t}\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\nint\nsc_pkcs15emu_oberthur_init_ex(struct sc_pkcs15_card * p15card, struct sc_aid *aid)\n{\n\tint rv;\n\n\tLOG_FUNC_CALLED(p15card->card->ctx);\n\trv = oberthur_detect_card(p15card);\n\tif (!rv)\n\t\trv = sc_pkcs15emu_oberthur_init(p15card);\n\n\tLOG_FUNC_RETURN(p15card->card->ctx, rv);\n}\nint\nsc_pkcs15_bind_synthetic(sc_pkcs15_card_t *p15card, struct sc_aid *aid)\n{\n\tsc_context_t\t\t*ctx = p15card->card->ctx;\n\tscconf_block\t\t*conf_block, **blocks, *blk;\n\tint\t\t\ti, r = SC_ERROR_WRONG_CARD;\n\n\tSC_FUNC_CALLED(ctx, SC_LOG_DEBUG_VERBOSE);\n\tconf_block = NULL;\n\n\tconf_block = sc_get_conf_block(ctx, \"framework\", \"pkcs15\", 1);\n\n\tif (!conf_block) {\n\t\t/* no conf file found => try builtin drivers  */\n\t\tsc_log(ctx, \"no conf file (or section), trying all builtin emulators\");\n\t\tfor (i = 0; builtin_emulators[i].name; i++) {\n\t\t\tsc_log(ctx, \"trying %s\", builtin_emulators[i].name);\n\t\t\tr = builtin_emulators[i].handler(p15card, aid);\n\t\t\tif (r == SC_SUCCESS)\n\t\t\t\t/* we got a hit */\n\t\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t/* we have a conf file => let's use it */\n\t\tint builtin_enabled;\n\t\tconst scconf_list *list, *item;\n\n\t\tbuiltin_enabled = scconf_get_bool(conf_block, \"enable_builtin_emulation\", 1);\n\t\tlist = scconf_find_list(conf_block, \"builtin_emulators\"); /* FIXME: rename to enabled_emulators */\n\n\t\tif (builtin_enabled && list) {\n\t\t\t/* get the list of enabled emulation drivers */\n\t\t\tfor (item = list; item; item = item->next) {\n\t\t\t\t/* go through the list of builtin drivers */\n\t\t\t\tconst char *name = item->data;\n\n\t\t\t\tsc_log(ctx, \"trying %s\", name);\n\t\t\t\tfor (i = 0; builtin_emulators[i].name; i++)\n\t\t\t\t\tif (!strcmp(builtin_emulators[i].name, name)) {\n\t\t\t\t\t\tr = builtin_emulators[i].handler(p15card, aid);\n\t\t\t\t\t\tif (r == SC_SUCCESS)\n\t\t\t\t\t\t\t/* we got a hit */\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (builtin_enabled) {\n\t\t\tsc_log(ctx, \"no emulator list in config file, trying all builtin emulators\");\n\t\t\tfor (i = 0; builtin_emulators[i].name; i++) {\n\t\t\t\tsc_log(ctx, \"trying %s\", builtin_emulators[i].name);\n\t\t\t\tr = builtin_emulators[i].handler(p15card, aid);\n\t\t\t\tif (r == SC_SUCCESS)\n\t\t\t\t\t/* we got a hit */\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/* search for 'emulate foo { ... }' entries in the conf file */\n\t\tsc_log(ctx, \"searching for 'emulate foo { ... }' blocks\");\n\t\tblocks = scconf_find_blocks(ctx->conf, conf_block, \"emulate\", NULL);\n\t\tsc_log(ctx, \"Blocks: %p\", blocks);\n\t\tfor (i = 0; blocks && (blk = blocks[i]) != NULL; i++) {\n\t\t\tconst char *name = blk->name->data;\n\t\t\tsc_log(ctx, \"trying %s\", name);\n\t\t\tr = parse_emu_block(p15card, aid, blk);\n\t\t\tif (r == SC_SUCCESS) {\n\t\t\t\tfree(blocks);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tif (blocks)\n\t\t\tfree(blocks);\n\t}\n\nout:\n\tif (r == SC_SUCCESS) {\n\t\tp15card->magic  = SC_PKCS15_CARD_MAGIC;\n\t\tp15card->flags |= SC_PKCS15_CARD_FLAG_EMULATED;\n\t} else {\n\t\tif (r != SC_ERROR_WRONG_CARD)\n\t\t\tsc_log(ctx, \"Failed to load card emulator: %s\", sc_strerror(r));\n\t}\n\n\tLOG_FUNC_RETURN(ctx, r);\n}\nint\nsc_pkcs15_bind(struct sc_card *card, struct sc_aid *aid,\n\t\tstruct sc_pkcs15_card **p15card_out)\n{\n\tstruct sc_pkcs15_card *p15card = NULL;\n\tstruct sc_context *ctx;\n\tscconf_block *conf_block = NULL;\n\tint r, emu_first, enable_emu;\n\tconst char *private_certificate;\n\n\tif (card == NULL || p15card_out == NULL) {\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\tctx = card->ctx;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"application(aid:'%s')\", aid ? sc_dump_hex(aid->value, aid->len) : \"empty\");\n\n\tp15card = sc_pkcs15_card_new();\n\tif (p15card == NULL)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY);\n\n\tp15card->card = card;\n\tp15card->opts.use_file_cache = 0;\n\tp15card->opts.use_pin_cache = 1;\n\tp15card->opts.pin_cache_counter = 10;\n\tp15card->opts.pin_cache_ignore_user_consent = 0;\n\tif(0 == strcmp(ctx->app_name, \"tokend\")) {\n\t\tprivate_certificate = \"ignore\";\n\t\tp15card->opts.private_certificate = SC_PKCS15_CARD_OPTS_PRIV_CERT_IGNORE;\n\t} else {\n\t\tprivate_certificate = \"protect\";\n\t\tp15card->opts.private_certificate = SC_PKCS15_CARD_OPTS_PRIV_CERT_PROTECT;\n\t}\n\n\tconf_block = sc_get_conf_block(ctx, \"framework\", \"pkcs15\", 1);\n\tif (conf_block) {\n\t\tp15card->opts.use_file_cache = scconf_get_bool(conf_block, \"use_file_caching\", p15card->opts.use_file_cache);\n\t\tp15card->opts.use_pin_cache = scconf_get_bool(conf_block, \"use_pin_caching\", p15card->opts.use_pin_cache);\n\t\tp15card->opts.pin_cache_counter = scconf_get_int(conf_block, \"pin_cache_counter\", p15card->opts.pin_cache_counter);\n\t\tp15card->opts.pin_cache_ignore_user_consent = scconf_get_bool(conf_block, \"pin_cache_ignore_user_consent\",\n\t\t\t\tp15card->opts.pin_cache_ignore_user_consent);\n\t\tprivate_certificate = scconf_get_str(conf_block, \"private_certificate\", private_certificate);\n\t}\n\tif (0 == strcmp(private_certificate, \"protect\")) {\n\t\tp15card->opts.private_certificate = SC_PKCS15_CARD_OPTS_PRIV_CERT_PROTECT;\n\t} else if (0 == strcmp(private_certificate, \"ignore\")) {\n\t\tp15card->opts.private_certificate = SC_PKCS15_CARD_OPTS_PRIV_CERT_IGNORE;\n\t} else if (0 == strcmp(private_certificate, \"declassify\")) {\n\t\tp15card->opts.private_certificate = SC_PKCS15_CARD_OPTS_PRIV_CERT_DECLASSIFY;\n\t}\n\tsc_log(ctx, \"PKCS#15 options: use_file_cache=%d use_pin_cache=%d pin_cache_counter=%d pin_cache_ignore_user_consent=%d private_certificate=%d\",\n\t\t\tp15card->opts.use_file_cache, p15card->opts.use_pin_cache,p15card->opts.pin_cache_counter,\n\t\t\tp15card->opts.pin_cache_ignore_user_consent, p15card->opts.private_certificate);\n\n\tr = sc_lock(card);\n\tif (r) {\n\t\tsc_log(ctx, \"sc_lock() failed: %s\", sc_strerror(r));\n\t\tsc_pkcs15_card_free(p15card);\n\t\tLOG_FUNC_RETURN(ctx, r);\n\t}\n\n\tenable_emu = scconf_get_bool(conf_block, \"enable_pkcs15_emulation\", 1);\n\tif (enable_emu) {\n\t\tsc_log(ctx, \"PKCS#15 emulation enabled\");\n\t\temu_first = scconf_get_bool(conf_block, \"try_emulation_first\", 0);\n\t\tif (emu_first || sc_pkcs15_is_emulation_only(card)) {\n\t\t\tr = sc_pkcs15_bind_synthetic(p15card, aid);\n\t\t\tif (r == SC_SUCCESS)\n\t\t\t\tgoto done;\n\t\t\tr = sc_pkcs15_bind_internal(p15card, aid);\n\t\t\tif (r < 0)\n\t\t\t\tgoto error;\n\t\t} else {\n\t\t\tr = sc_pkcs15_bind_internal(p15card, aid);\n\t\t\tif (r == SC_SUCCESS)\n\t\t\t\tgoto done;\n\t\t\tr = sc_pkcs15_bind_synthetic(p15card, aid);\n\t\t\tif (r < 0)\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\telse {\n\t\tr = sc_pkcs15_bind_internal(p15card, aid);\n\t\tif (r < 0)\n\t\t\tgoto error;\n\t}\ndone:\n\t*p15card_out = p15card;\n\tsc_unlock(card);\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\nerror:\n\tsc_unlock(card);\n\tsc_pkcs15_card_free(p15card);\n\tLOG_FUNC_RETURN(ctx, r);\n}\nint LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size)\n{\n    struct sc_context *ctx = NULL;\n    struct sc_card *card = NULL;\n    struct sc_pkcs15_card *p15card = NULL;\n    struct sc_reader *reader;\n    struct sc_pkcs15_object *obj;\n\n    sc_establish_context(&ctx, \"fuzz\");\n    if (!ctx)\n        return 0;\n    /* copied from sc_release_context() */\n    while (list_size(&ctx->readers)) {\n        sc_reader_t *rdr = (sc_reader_t *) list_get_at(&ctx->readers, 0);\n        _sc_delete_reader(ctx, rdr);\n    }\n    if (ctx->reader_driver->ops->finish != NULL)\n        ctx->reader_driver->ops->finish(ctx);\n\n    ctx->reader_driver = sc_get_fuzz_driver();\n\n    fuzz_add_reader(ctx, Data, Size);\n\n    reader = sc_ctx_get_reader(ctx, 0);\n    sc_connect_card(reader, &card);\n    sc_pkcs15_bind(card, NULL, &p15card);\n\n    if (p15card) {\n        const uint8_t *in, *param;\n        uint16_t in_len, param_len;\n        fuzz_get_chunk(reader, &in, &in_len);\n        fuzz_get_chunk(reader, &param, &param_len);\n        for (obj = p15card->obj_list; obj != NULL; obj = obj->next) {\n            u8 buf[0xFFFF];\n            size_t i;\n\n            int decipher_flags[] = {SC_ALGORITHM_RSA_RAW,\n                SC_ALGORITHM_RSA_PAD_PKCS1, SC_ALGORITHM_RSA_PAD_ANSI,\n                SC_ALGORITHM_RSA_PAD_ISO9796};\n            for (i = 0; i < sizeof decipher_flags/sizeof *decipher_flags; i++) {\n                sc_pkcs15_decipher(p15card, obj, decipher_flags[i],\n                        in, in_len, buf, sizeof buf);\n            }\n\n            i = sizeof buf;\n            sc_pkcs15_derive(p15card, obj, 0,\n                    in, in_len, buf, &i);\n\n            int wrap_flags[] = {0, SC_ALGORITHM_AES_ECB, SC_ALGORITHM_AES_CBC_PAD,\n                SC_ALGORITHM_AES_CBC};\n            for (i = 0; i < sizeof wrap_flags/sizeof *wrap_flags; i++) {\n                /* see `pkcs15_create_secret_key` in\n                 * `src/pkcs11/framework-pkc15.c` for creating a temporary\n                 * secret key for wrapping/unwrapping */\n                unsigned long l = sizeof buf;\n                struct sc_pkcs15_object target_key;\n                struct sc_pkcs15_skey_info skey_info;\n                uint16_t len;\n                memset(&target_key, 0, sizeof target_key);\n                memset(&skey_info, 0, sizeof skey_info);\n                target_key.type = SC_PKCS15_TYPE_SKEY;\n                target_key.flags = 2; /* TODO not sure what these mean */\n                target_key.session_object = 1;\n                target_key.data = &skey_info;\n                skey_info.usage = SC_PKCS15_PRKEY_USAGE_UNWRAP | SC_PKCS15_PRKEY_USAGE_WRAP\n                    | SC_PKCS15_PRKEY_USAGE_ENCRYPT | SC_PKCS15_PRKEY_USAGE_DECRYPT;\n                skey_info.native = 0; /* card can not use this */\n                skey_info.access_flags = 0; /* looks like not needed */\n                skey_info.key_type = 0x1fUL; /* CKK_AES */\n                skey_info.value_len = 128;\n                fuzz_get_chunk(reader, (const u8 **) &skey_info.data.value, &len);\n                skey_info.data.len = len;\n\n                sc_pkcs15_unwrap(p15card, obj, &target_key, wrap_flags[i],\n                        in, in_len, param, param_len);\n                sc_pkcs15_wrap(p15card, obj, &target_key, wrap_flags[i],\n                        buf, &l, in, in_len);\n            }\n\n            int signature_flags[] = {SC_ALGORITHM_RSA_RAW,\n                SC_ALGORITHM_RSA_PAD_PKCS1, SC_ALGORITHM_RSA_PAD_ANSI,\n                SC_ALGORITHM_RSA_PAD_ISO9796,\n                SC_ALGORITHM_RSA_PAD_PSS|SC_ALGORITHM_MGF1_SHA1,\n                SC_ALGORITHM_RSA_PAD_PSS|SC_ALGORITHM_MGF1_SHA256,\n                SC_ALGORITHM_RSA_PAD_PSS|SC_ALGORITHM_MGF1_SHA384,\n                SC_ALGORITHM_RSA_PAD_PSS|SC_ALGORITHM_MGF1_SHA512,\n                SC_ALGORITHM_RSA_PAD_PSS|SC_ALGORITHM_MGF1_SHA224,\n                SC_ALGORITHM_ECDSA_RAW, SC_ALGORITHM_ECDSA_HASH_SHA1,\n                SC_ALGORITHM_ECDSA_HASH_SHA224, SC_ALGORITHM_ECDSA_HASH_SHA256,\n                SC_ALGORITHM_ECDSA_HASH_SHA384, SC_ALGORITHM_ECDSA_HASH_SHA512,\n                SC_ALGORITHM_GOSTR3410_RAW, SC_ALGORITHM_GOSTR3410_HASH_GOSTR3411,\n                SC_ALGORITHM_GOSTR3410_HASHES,\n            };\n            for (i = 0; i < sizeof signature_flags/sizeof *signature_flags; i++) {\n                sc_pkcs15_compute_signature(p15card, obj, signature_flags[i],\n                        in, in_len, buf, sizeof buf);\n            }\n\n            if (obj->type == SC_PKCS15_TYPE_AUTH_PIN) {\n                sc_pkcs15_verify_pin(p15card, obj, in, in_len);\n                sc_pkcs15_change_pin(p15card, obj, in, in_len, param, param_len);\n                sc_pkcs15_unblock_pin(p15card, obj, in, in_len, param, param_len);\n                sc_pkcs15_get_pin_info(p15card, obj);\n            }\n        }\n        sc_pkcs15_card_free(p15card);\n    }\n\n    sc_disconnect_card(card);\n    sc_release_context(ctx);\n\n    return 0;\n}",
    "target": 0,
    "idx": 2028843
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "static UA_StatusCode\nremoveSession(UA_SessionManager *sm, session_list_entry *sentry) {\n    /* Detach the Session from the SecureChannel */\n    UA_Session_detachFromSecureChannel(&sentry->session);\n\n    /* Deactivate the session */\n    sentry->session.activated = false;\n\n    /* Add a delayed callback to remove the session when the currently\n     * scheduled jobs have completed */\n    UA_StatusCode retval = UA_Server_delayedCallback(sm->server, removeSessionCallback, sentry);\n    if(retval != UA_STATUSCODE_GOOD) {\n        UA_LOG_WARNING_SESSION(sm->server->config.logger, &sentry->session,\n                       \"Could not remove session with error code %s\",\n                       UA_StatusCode_name(retval));\n        return retval; /* Try again next time */\n    }\n\n    /* Detach the session from the session manager and make the capacity\n     * available */\n    LIST_REMOVE(sentry, pointers);\n    UA_atomic_add(&sm->currentSessionCount, (UA_UInt32)-1);\n    return UA_STATUSCODE_GOOD;\n}\nvoid UA_Session_detachFromSecureChannel(UA_Session *session) {\n    if(!session->header.channel)\n        return;\n    session->header.channel = NULL;\n    LIST_REMOVE(&session->header, pointers);\n}\nvoid UA_Session_deleteMembersCleanup(UA_Session *session, UA_Server* server) {\n    UA_Session_detachFromSecureChannel(session);\n    UA_ApplicationDescription_deleteMembers(&session->clientDescription);\n    UA_NodeId_deleteMembers(&session->header.authenticationToken);\n    UA_NodeId_deleteMembers(&session->sessionId);\n    UA_String_deleteMembers(&session->sessionName);\n    UA_ByteString_deleteMembers(&session->serverNonce);\n    struct ContinuationPointEntry *cp, *temp;\n    LIST_FOREACH_SAFE(cp, &session->continuationPoints, pointers, temp) {\n        LIST_REMOVE(cp, pointers);\n        UA_ByteString_deleteMembers(&cp->identifier);\n        UA_BrowseDescription_deleteMembers(&cp->browseDescription);\n        UA_free(cp);\n    }\n#ifdef UA_ENABLE_SUBSCRIPTIONS\n    UA_Subscription *currents, *temps;\n    LIST_FOREACH_SAFE(currents, &session->serverSubscriptions, listEntry, temps) {\n        LIST_REMOVE(currents, listEntry);\n        UA_Subscription_deleteMembers(currents, server);\n        UA_free(currents);\n    }\n    UA_PublishResponseEntry *entry;\n    while((entry = UA_Session_getPublishReq(session))) {\n        UA_Session_removePublishReq(session,entry);\n        UA_PublishResponse_deleteMembers(&entry->response);\n        UA_free(entry);\n    }\n#endif\n}\nstatic void\nremoveSessionCallback(UA_Server *server, void *entry) {\n    session_list_entry *sentry = (session_list_entry*)entry;\n    UA_Session_deleteMembersCleanup(&sentry->session, server);\n    UA_free(sentry);\n}\nstatic void\nprocessDelayedCallbacks(UA_Server *server) {\n    UA_DelayedCallback *dc, *dc_tmp;\n    SLIST_FOREACH_SAFE(dc, &server->delayedCallbacks, next, dc_tmp) {\n        SLIST_REMOVE(&server->delayedCallbacks, dc, UA_DelayedCallback, next);\n        dc->callback(server, dc->data);\n        UA_free(dc);\n    }\n}\nUA_StatusCode\nUA_Server_run_shutdown(UA_Server *server) {\n    /* Stop the netowrk layer */\n    for(size_t i = 0; i < server->config.networkLayersSize; ++i) {\n        UA_ServerNetworkLayer *nl = &server->config.networkLayers[i];\n        nl->stop(nl, server);\n    }\n\n#ifndef UA_ENABLE_MULTITHREADING\n    /* Process remaining delayed callbacks */\n    processDelayedCallbacks(server);\n#else\n    /* Shut down the workers */\n    if(server->workers) {\n        UA_LOG_INFO(server->config.logger, UA_LOGCATEGORY_SERVER,\n                    \"Shutting down %u worker thread(s)\",\n                    server->config.nThreads);\n        for(size_t i = 0; i < server->config.nThreads; ++i)\n            server->workers[i].running = false;\n        pthread_cond_broadcast(&server->dispatchQueue_condition);\n        for(size_t i = 0; i < server->config.nThreads; ++i)\n            pthread_join(server->workers[i].thr, NULL);\n        UA_free(server->workers);\n        server->workers = NULL;\n    }\n\n    /* Execute the remaining callbacks in the dispatch queue.\n     * This also executes the delayed callbacks. */\n    emptyDispatchQueue(server);\n    \n#endif\n\n    /* Stop multicast discovery */\n#ifdef UA_ENABLE_DISCOVERY_MULTICAST\n    if(server->config.applicationDescription.applicationType ==\n       UA_APPLICATIONTYPE_DISCOVERYSERVER)\n        stopMulticastDiscoveryServer(server);\n#endif\n\n    return UA_STATUSCODE_GOOD;\n}\nextern \"C\" int\nLLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n    UA_Connection c = createDummyConnection(65535, NULL);\n    UA_ServerConfig *config = UA_ServerConfig_new_default();\n    UA_Server *server = UA_Server_new(config);\n    if (server == NULL) {\n        UA_LOG_ERROR(UA_Log_Stdout, UA_LOGCATEGORY_SERVER,\n                     \"Could not create server instance using UA_Server_new\");\n        return 1;\n    }\n\n    // we need to copy the message because it will be freed in the processing function\n    UA_ByteString msg = UA_ByteString();\n    UA_StatusCode retval = UA_ByteString_allocBuffer(&msg, size);\n    if(retval != UA_STATUSCODE_GOOD)\n        return (int)retval;\n    memcpy(msg.data, data, size);\n\n    UA_Server_processBinaryMessage(server, &c, &msg);\n    // if we got an invalid chunk, the message is not deleted, so delete it here\n    UA_ByteString_deleteMembers(&msg);\n    UA_Server_run_shutdown(server);\n    UA_Server_delete(server);\n    UA_ServerConfig_delete(config);\n    c.close(&c);\n    UA_Connection_deleteMembers(&c);\n    return 0;\n}\nint ExecuteFilesOnyByOne(int argc, char **argv) {\n  for (int i = 1; i < argc; i++) {\n    std::ifstream in(argv[i]);\n    in.seekg(0, in.end);\n    size_t length = in.tellg();\n    in.seekg (0, in.beg);\n    std::cout << \"Reading \" << length << \" bytes from \" << argv[i] << std::endl;\n    // Allocate exactly length bytes so that we reliably catch buffer overflows.\n    std::vector<char> bytes(length);\n    in.read(bytes.data(), bytes.size());\n    assert(in);\n    LLVMFuzzerTestOneInput(reinterpret_cast<const uint8_t *>(bytes.data()),\n                           bytes.size());\n    std::cout << \"Execution successfull\" << std::endl;\n  }\n  return 0;\n}\nint main(int argc, char **argv) {\n  fprintf(stderr,\n      \"======================= INFO =========================\\n\"\n      \"This binary is built for AFL-fuzz.\\n\"\n      \"To run the target function on individual input(s) execute this:\\n\"\n      \"  %s < INPUT_FILE\\n\"\n      \"or\\n\"\n      \"  %s INPUT_FILE1 [INPUT_FILE2 ... ]\\n\"\n      \"To fuzz with afl-fuzz execute this:\\n\"\n      \"  afl-fuzz [afl-flags] %s [-N]\\n\"\n      \"afl-fuzz will run N iterations before \"\n      \"re-spawning the process (default: 1000)\\n\"\n      \"======================================================\\n\",\n          argv[0], argv[0], argv[0]);\n  if (LLVMFuzzerInitialize)\n    LLVMFuzzerInitialize(&argc, &argv);\n  // Do any other expensive one-time initialization here.\n\n  maybe_duplicate_stderr();\n  maybe_initialize_extra_stats();\n\n  __afl_manual_init();\n\n  int N = 1000;\n  if (argc == 2 && argv[1][0] == '-')\n      N = atoi(argv[1] + 1);\n  else if(argc == 2 && (N = atoi(argv[1])) > 0)\n      fprintf(stderr, \"WARNING: using the deprecated call style `%s %d`\\n\",\n              argv[0], N);\n  else if (argc > 1)\n    return ExecuteFilesOnyByOne(argc, argv);\n\n  assert(N > 0);\n\n  // Call LLVMFuzzerTestOneInput here so that coverage caused by initialization\n  // on the first execution of LLVMFuzzerTestOneInput is ignored.\n  uint8_t dummy_input[1] = {0};\n  LLVMFuzzerTestOneInput(dummy_input, 1);\n\n  time_t unit_time_secs;\n  int num_runs = 0;\n  while (__afl_persistent_loop(N)) {\n    ssize_t n_read = read(0, AflInputBuf, kMaxAflInputSize);\n    if (n_read > 0) {\n      // Copy AflInputBuf into a separate buffer to let asan find buffer\n      // overflows. Don't use unique_ptr/etc to avoid extra dependencies.\n      uint8_t *copy = new uint8_t[n_read];\n      memcpy(copy, AflInputBuf, n_read);\n\n      struct timeval unit_start_time;\n      CHECK_ERROR(gettimeofday(&unit_start_time, NULL) == 0,\n                  \"Calling gettimeofday failed\");\n\n      num_runs++;\n      LLVMFuzzerTestOneInput(copy, n_read);\n\n      struct timeval unit_stop_time;\n      CHECK_ERROR(gettimeofday(&unit_stop_time, NULL) == 0,\n                  \"Calling gettimeofday failed\");\n\n      // Update slowest_unit_time_secs if we see a new max.\n      unit_time_secs = unit_stop_time.tv_sec - unit_start_time.tv_sec;\n      if (slowest_unit_time_secs < unit_time_secs)\n        slowest_unit_time_secs = unit_time_secs;\n\n      delete[] copy;\n    }\n  }\n  fprintf(stderr, \"%s: successfully executed %d input(s)\\n\", argv[0], num_runs);\n}",
    "target": 0,
    "idx": 2005577
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "GF_Err gf_isom_box_array_read_ex(GF_Box *parent, GF_BitStream *bs, u32 parent_type)\n{\n\tGF_Err e;\n\tGF_Box *a = NULL;\n\tBool skip_logs = (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_NO_LOGS ) ? GF_TRUE : GF_FALSE;\n\n\t//we may have terminators in some QT files (4 bytes set to 0 ...)\n\twhile (parent->size>=8) {\n\t\te = gf_isom_box_parse_ex(&a, bs, parent_type, GF_FALSE);\n\t\tif (e) {\n\t\t\tif (a) gf_isom_box_del(a);\n\t\t\treturn e;\n\t\t}\n\t\t//sub box parsing aborted with no error\n\t\tif (!a) return GF_OK;\n\n\t\tif (parent->size < a->size) {\n\t\t\tif (!skip_logs) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" is larger than container box\\n\", gf_4cc_to_str(a->type)));\n\t\t\t}\n\t\t\tif (!gf_opts_get_bool(\"core\", \"no-check\")) {\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tparent->size = 0;\n\t\t} else {\n\t\t\tparent->size -= a->size;\n\t\t}\n\n\t\t//check container validity\n\t\tif (strlen(a->registry->parents_4cc)) {\n\t\t\tBool parent_OK = GF_FALSE;\n\t\t\tconst char *parent_code = gf_4cc_to_str(parent->type);\n\t\t\tif (parent->type == GF_ISOM_BOX_TYPE_UNKNOWN)\n\t\t\t\tparent_code = gf_4cc_to_str( ((GF_UnknownBox*)parent)->original_4cc );\n\t\t\tif (strstr(a->registry->parents_4cc, parent_code) != NULL) {\n\t\t\t\tparent_OK = GF_TRUE;\n\t\t\t} else if (!strcmp(a->registry->parents_4cc, \"*\") || strstr(a->registry->parents_4cc, \"* \") || strstr(a->registry->parents_4cc, \" *\")) {\n\t\t\t\tparent_OK = GF_TRUE;\n\t\t\t} else {\n\t\t\t\t//parent must be a sample entry\n\t\t\t\tif (strstr(a->registry->parents_4cc, \"sample_entry\") !=\tNULL) {\n\t\t\t\t\t//parent is in an stsd\n\t\t\t\t\tif (strstr(parent->registry->parents_4cc, \"stsd\") != NULL) {\n\t\t\t\t\t\tif (strstr(a->registry->parents_4cc, \"video_sample_entry\") !=\tNULL) {\n\t\t\t\t\t\t\tif (((GF_SampleEntryBox*)parent)->internal_type==GF_ISOM_SAMPLE_ENTRY_VIDEO) {\n\t\t\t\t\t\t\t\tparent_OK = GF_TRUE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tparent_OK = GF_TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//other types are sample formats, eg a 3GPP text sample, RTP hint sample or VTT cue. Not handled at this level\n\t\t\t\telse if (a->type==GF_ISOM_BOX_TYPE_UNKNOWN) parent_OK = GF_TRUE;\n\t\t\t\telse if (a->type==GF_ISOM_BOX_TYPE_UUID) parent_OK = GF_TRUE;\n\t\t\t}\n\t\t\tif (! parent_OK && !skip_logs) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" is invalid in container %s\\n\", gf_4cc_to_str(a->type), parent_code));\n\t\t\t}\n\t\t}\n\n\t\t//always register boxes\n\t\tif (!parent->child_boxes) {\n\t\t\tparent->child_boxes = gf_list_new();\n\t\t\tif (!parent->child_boxes) return GF_OUT_OF_MEM;\n\t\t}\n\t\te = gf_list_add(parent->child_boxes, a);\n\t\tif (e) return e;\n\n\t\tif (parent->registry->add_rem_fn) {\n\t\t\te = parent->registry->add_rem_fn(parent, a, GF_FALSE);\n\t\t\tif (e) {\n\t\t\t\tif (e == GF_ISOM_INVALID_MEDIA) return GF_OK;\n\t\t\t\t//if the box is no longer present, consider it destroyed\n\t\t\t\tif (gf_list_find(parent->child_boxes, a) >=0) {\n\t\t\t\t\tgf_isom_box_del_parent(&parent->child_boxes, a);\n\t\t\t\t}\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\nGF_EXPORT\nvoid gf_isom_box_del(GF_Box *a)\n{\n\tGF_List *child_boxes;\n\tconst struct box_registry_entry *a_box_registry;\n\tif (!a) return;\n\n\tchild_boxes\t= a->child_boxes;\n\ta->child_boxes = NULL;\n\n\ta_box_registry = a->registry;\n\tif (!a_box_registry) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Delete invalid box type %s without registry\\n\", gf_4cc_to_str(a->type) ));\n\t} else {\n\t\ta_box_registry->del_fn(a);\n\t}\n\t//delete the other boxes after deleting the box for dumper case where all child boxes are stored in otherbox\n\tif (child_boxes) {\n\t\tgf_isom_box_array_del(child_boxes);\n\t}\n}\nvoid gf_isom_box_array_reset(GF_List *boxlist)\n{\n\tu32 count, i;\n\tif (!boxlist) return;\n\tcount = gf_list_count(boxlist);\n\tfor (i = 0; i < count; i++) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(boxlist, i);\n\t\tif (a) gf_isom_box_del(a);\n\t}\n}\nvoid gf_isom_box_array_del(GF_List *boxlist)\n{\n\tgf_isom_box_array_reset(boxlist);\n\tgf_list_del(boxlist);\n}\nGF_EXPORT\nvoid gf_isom_box_del(GF_Box *a)\n{\n\tGF_List *child_boxes;\n\tconst struct box_registry_entry *a_box_registry;\n\tif (!a) return;\n\n\tchild_boxes\t= a->child_boxes;\n\ta->child_boxes = NULL;\n\n\ta_box_registry = a->registry;\n\tif (!a_box_registry) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Delete invalid box type %s without registry\\n\", gf_4cc_to_str(a->type) ));\n\t} else {\n\t\ta_box_registry->del_fn(a);\n\t}\n\t//delete the other boxes after deleting the box for dumper case where all child boxes are stored in otherbox\n\tif (child_boxes) {\n\t\tgf_isom_box_array_del(child_boxes);\n\t}\n}\nvoid gf_isom_box_array_reset(GF_List *boxlist)\n{\n\tu32 count, i;\n\tif (!boxlist) return;\n\tcount = gf_list_count(boxlist);\n\tfor (i = 0; i < count; i++) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(boxlist, i);\n\t\tif (a) gf_isom_box_del(a);\n\t}\n}\nvoid gf_isom_box_array_del(GF_List *boxlist)\n{\n\tgf_isom_box_array_reset(boxlist);\n\tgf_list_del(boxlist);\n}\nGF_EXPORT\nvoid gf_isom_box_del(GF_Box *a)\n{\n\tGF_List *child_boxes;\n\tconst struct box_registry_entry *a_box_registry;\n\tif (!a) return;\n\n\tchild_boxes\t= a->child_boxes;\n\ta->child_boxes = NULL;\n\n\ta_box_registry = a->registry;\n\tif (!a_box_registry) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Delete invalid box type %s without registry\\n\", gf_4cc_to_str(a->type) ));\n\t} else {\n\t\ta_box_registry->del_fn(a);\n\t}\n\t//delete the other boxes after deleting the box for dumper case where all child boxes are stored in otherbox\n\tif (child_boxes) {\n\t\tgf_isom_box_array_del(child_boxes);\n\t}\n}\nvoid gf_isom_box_array_reset(GF_List *boxlist)\n{\n\tu32 count, i;\n\tif (!boxlist) return;\n\tcount = gf_list_count(boxlist);\n\tfor (i = 0; i < count; i++) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(boxlist, i);\n\t\tif (a) gf_isom_box_del(a);\n\t}\n}\nvoid gf_isom_box_array_del(GF_List *boxlist)\n{\n\tgf_isom_box_array_reset(boxlist);\n\tgf_list_del(boxlist);\n}\nvoid gf_isom_delete_movie(GF_ISOFile *mov)\n{\n\tif (!mov) return;\n\n\t//these are our two main files\n\tif (mov->movieFileMap) gf_isom_datamap_del(mov->movieFileMap);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tif (mov->editFileMap) {\n\t\tgf_isom_datamap_del(mov->editFileMap);\n\t}\n\tif (mov->finalName) gf_free(mov->finalName);\n#endif\n\n\tgf_isom_box_array_del(mov->TopBoxes);\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tgf_isom_box_array_del(mov->moof_list);\n\tif (mov->mfra)\n\t\tgf_isom_box_del((GF_Box*)mov->mfra);\n\tif (mov->sidx_pts_store)\n\t\tgf_free(mov->sidx_pts_store);\n\tif (mov->sidx_pts_next_store)\n\t\tgf_free(mov->sidx_pts_next_store);\n\n\tif (mov->main_sidx)\n\t\tgf_isom_box_del((GF_Box*)mov->main_sidx);\n\n\tif (mov->block_buffer)\n\t\tgf_free(mov->block_buffer);\n#endif\n\tif (mov->last_producer_ref_time)\n\t\tgf_isom_box_del((GF_Box *) mov->last_producer_ref_time);\n\tif (mov->fileName) gf_free(mov->fileName);\n\tgf_free(mov);\n}\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n    char filename[256];\n    sprintf(filename, \"/tmp/libfuzzer.%d\", getpid());\n\n    FILE *fp = fopen(filename, \"wb\");\n    if (!fp) {\n        return 0;\n    }\n    fwrite(data, size, 1, fp);\n    fclose(fp);\n\n    GF_ISOFile *movie = NULL;\n    movie = gf_isom_open_file(filename, GF_ISOM_OPEN_READ_DUMP, NULL);\n    if (movie != NULL) {\n        gf_isom_close(movie);\n    }\n    unlink(filename);\n    return 0;\n}\nstatic int ExecuteFilesOnyByOne(int argc, char **argv) {\n\n  unsigned char *buf = (unsigned char *)malloc(MAX_FILE);\n  for (int i = 1; i < argc; i++) {\n\n    int fd = open(argv[i], O_RDONLY);\n    if (fd == -1) continue;\n    ssize_t length = read(fd, buf, MAX_FILE);\n    if (length > 0) {\n\n      printf(\"Reading %zu bytes from %s\\n\", length, argv[i]);\n      LLVMFuzzerTestOneInput(buf, length);\n      printf(\"Execution successful.\\n\");\n\n    }\n\n  }\n\n  free(buf);\n  return 0;\n\n}\nint main(int argc, char **argv) {\n\n  printf(\n      \"======================= INFO =========================\\n\"\n      \"This binary is built for afl++.\\n\"\n      \"To run the target function on individual input(s) execute this:\\n\"\n      \"  %s INPUT_FILE1 [INPUT_FILE2 ... ]\\n\"\n      \"To fuzz with afl-fuzz execute this:\\n\"\n      \"  afl-fuzz [afl-flags] -- %s [-N]\\n\"\n      \"afl-fuzz will run N iterations before re-spawning the process (default: \"\n      \"INT_MAX)\\n\"\n      \"======================================================\\n\",\n      argv[0], argv[0]);\n\n  if (getenv(\"AFL_GDB\")) {\n\n    char cmd[64];\n    snprintf(cmd, sizeof(cmd), \"cat /proc/%d/maps\", getpid());\n    system(cmd);\n    fprintf(stderr, \"DEBUG: aflpp_driver pid is %d\\n\", getpid());\n    sleep(1);\n\n  }\n\n  output_file = stderr;\n  maybe_duplicate_stderr();\n  maybe_close_fd_mask();\n  if (LLVMFuzzerInitialize) {\n\n    fprintf(stderr, \"Running LLVMFuzzerInitialize ...\\n\");\n    LLVMFuzzerInitialize(&argc, &argv);\n    fprintf(stderr, \"continue...\\n\");\n\n  }\n\n  // Do any other expensive one-time initialization here.\n\n  uint8_t dummy_input[64] = {0};\n  memcpy(dummy_input, (void *)AFL_PERSISTENT, sizeof(AFL_PERSISTENT));\n  memcpy(dummy_input + 32, (void *)AFL_DEFER_FORKSVR,\n         sizeof(AFL_DEFER_FORKSVR));\n  int N = INT_MAX;\n  if (argc == 2 && argv[1][0] == '-')\n    N = atoi(argv[1] + 1);\n  else if (argc == 2 && (N = atoi(argv[1])) > 0)\n    printf(\"WARNING: using the deprecated call style `%s %d`\\n\", argv[0], N);\n  else if (argc > 1) {\n\n    __afl_sharedmem_fuzzing = 0;\n    __afl_manual_init();\n    return ExecuteFilesOnyByOne(argc, argv);\n\n  }\n\n  assert(N > 0);\n\n  //  if (!getenv(\"AFL_DRIVER_DONT_DEFER\"))\n  __afl_manual_init();\n\n  // Call LLVMFuzzerTestOneInput here so that coverage caused by initialization\n  // on the first execution of LLVMFuzzerTestOneInput is ignored.\n  LLVMFuzzerTestOneInput(dummy_input, 1);\n\n  int num_runs = 0;\n  while (__afl_persistent_loop(N)) {\n\n#ifdef _DEBUG\n    fprintf(stderr, \"CLIENT crc: %016llx len: %u\\n\",\n            hash64(__afl_fuzz_ptr, *__afl_fuzz_len, 0xa5b35705),\n            *__afl_fuzz_len);\n    fprintf(stderr, \"RECV:\");\n    for (int i = 0; i < *__afl_fuzz_len; i++)\n      fprintf(stderr, \"%02x\", __afl_fuzz_ptr[i]);\n    fprintf(stderr, \"\\n\");\n#endif\n    if (*__afl_fuzz_len) {\n\n      num_runs++;\n      LLVMFuzzerTestOneInput(__afl_fuzz_ptr, *__afl_fuzz_len);\n\n    }\n\n  }\n\n  printf(\"%s: successfully executed %d input(s)\\n\", argv[0], num_runs);\n\n}",
    "target": 0,
    "idx": 2032356
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {\n\tgboolean prefixedChoice = (gboolean)*data;\n\tgchar *copy;\n\tgchar **lines;\n\tgchar **head;\n\n\tif (size < 1) return 0;\n\n\ttest_server();\n\n\tcopy = g_strndup((const gchar *)data+1, size-1);\n\tlines = g_strsplit(copy, \"\\r\\n\", -1);\n\thead = lines;\n\n\tfor (; *lines != NULL; lines++) {\n\t\tgchar *prefixedLine;\n\t\tint disconnected;\n\t\tif (prefixedChoice) {\n\t\t\tprefixedLine = g_strdup_printf(\":user %s\\n\", *lines);\n\t\t} else {\n\t\t\tprefixedLine = g_strdup_printf(\"%s\\n\", *lines);\n\t\t}\n\t\tserver_ref(server);\n\t\tsignal_emit(\"server incoming\", 2, server, prefixedLine);\n\t\tdisconnected = server->disconnected;\n\t\t/*\n\t\tif (disconnected) {\n\t\t        server_connect_unref(server->connrec);\n\t\t}\n\t\t*/\n\t\tserver_unref(server);\n\t\tif (disconnected) {\n\t\t\t/* reconnect */\n\t\t\ttest_server();\n\t\t}\n\t\tg_free(prefixedLine);\n\t}\n\n\tg_strfreev(head);\n\tg_free(copy);\n\tserver_disconnect(server);\n\treturn 0;\n}\nvoid *module_check_cast(void *object, int type_pos, const char *id)\n{\n\treturn object == NULL || module_find_id(id,\n\t\tG_STRUCT_MEMBER(int, object, type_pos)) == -1 ? NULL : object;\n}\nvoid server_connect_unref(SERVER_CONNECT_REC *conn)\n{\n\tg_return_if_fail(IS_SERVER_CONNECT(conn));\n\n\tif (--conn->refcount > 0)\n\t\treturn;\n\tif (conn->refcount < 0) {\n\t\tg_warning(\"Connection '%s' refcount = %d\",\n\t\t\t  conn->tag, conn->refcount);\n\t}\n\n        CHAT_PROTOCOL(conn)->destroy_server_connect(conn);\n\n\tif (conn->connect_handle != NULL)\n\t\tnet_disconnect(conn->connect_handle);\n\n\tg_free_not_null(conn->proxy);\n\tg_free_not_null(conn->proxy_string);\n\tg_free_not_null(conn->proxy_string_after);\n\tg_free_not_null(conn->proxy_password);\n\n\tg_free_not_null(conn->tag);\n\tg_free_not_null(conn->address);\n\tg_free_not_null(conn->chatnet);\n\n\tg_free_not_null(conn->own_ip4);\n\tg_free_not_null(conn->own_ip6);\n\n\tg_free_not_null(conn->password);\n\tg_free_not_null(conn->nick);\n\tg_free_not_null(conn->username);\n\tg_free_not_null(conn->realname);\n\n\tg_free_not_null(conn->tls_cert);\n\tg_free_not_null(conn->tls_pkey);\n\tg_free_not_null(conn->tls_pass);\n\tg_free_not_null(conn->tls_cafile);\n\tg_free_not_null(conn->tls_capath);\n\tg_free_not_null(conn->tls_ciphers);\n\tg_free_not_null(conn->tls_pinned_cert);\n\tg_free_not_null(conn->tls_pinned_pubkey);\n\n\tg_free_not_null(conn->channels);\n\tg_free_not_null(conn->away_reason);\n\n\tconn->type = 0;\n\tg_free(conn);\n}\nint server_unref(SERVER_REC *server)\n{\n\tint chans;\n\n\tg_return_val_if_fail(IS_SERVER(server), FALSE);\n\n\tif (--server->refcount > 0)\n\t\treturn TRUE;\n\n\tif (g_slist_find(servers, server) != NULL) {\n\t\tg_warning(\"Non-referenced server wasn't disconnected\");\n\t\tserver_disconnect(server);\n\t\treturn TRUE;\n\t}\n\n\t/* close all channels */\n\tchans = server_remove_channels(server);\n\n\t/* since module initialisation uses server connected, only let\n\t   them know that the object got destroyed if the server was\n\t   disconnected */\n\tif (server->disconnected) {\n\t\tsignal_emit(\"server destroyed\", 1, server);\n\t}\n\n\tif (server->handle != NULL) {\n\t\tif (!chans || server->connection_lost)\n\t\t\tnet_sendbuffer_destroy(server->handle, TRUE);\n\t\telse {\n\t\t\t/* we were on some channels, try to let the server\n\t\t\t   disconnect so that our quit message is guaranteed\n\t\t\t   to get displayed */\n\t\t\tnet_disconnect_later(net_sendbuffer_handle(server->handle));\n\t\t\tnet_sendbuffer_destroy(server->handle, FALSE);\n\t\t}\n\t\tserver->handle = NULL;\n\t}\n\n        MODULE_DATA_DEINIT(server);\n\tserver_connect_unref(server->connrec);\n\tif (server->rawlog != NULL) rawlog_destroy(server->rawlog);\n\tg_free(server->version);\n\tg_free(server->away_reason);\n\tg_free(server->nick);\n\tg_free(server->tag);\n\tg_hash_table_destroy(server->current_incoming_meta);\n\n\tserver->type = 0;\n\tg_free(server);\n        return FALSE;\n}\nint LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {\n\tgboolean prefixedChoice = (gboolean)*data;\n\tgchar *copy;\n\tgchar **lines;\n\tgchar **head;\n\n\tif (size < 1) return 0;\n\n\ttest_server();\n\n\tcopy = g_strndup((const gchar *)data+1, size-1);\n\tlines = g_strsplit(copy, \"\\r\\n\", -1);\n\thead = lines;\n\n\tfor (; *lines != NULL; lines++) {\n\t\tgchar *prefixedLine;\n\t\tint disconnected;\n\t\tif (prefixedChoice) {\n\t\t\tprefixedLine = g_strdup_printf(\":user %s\\n\", *lines);\n\t\t} else {\n\t\t\tprefixedLine = g_strdup_printf(\"%s\\n\", *lines);\n\t\t}\n\t\tserver_ref(server);\n\t\tsignal_emit(\"server incoming\", 2, server, prefixedLine);\n\t\tdisconnected = server->disconnected;\n\t\t/*\n\t\tif (disconnected) {\n\t\t        server_connect_unref(server->connrec);\n\t\t}\n\t\t*/\n\t\tserver_unref(server);\n\t\tif (disconnected) {\n\t\t\t/* reconnect */\n\t\t\ttest_server();\n\t\t}\n\t\tg_free(prefixedLine);\n\t}\n\n\tg_strfreev(head);\n\tg_free(copy);\n\tserver_disconnect(server);\n\treturn 0;\n}",
    "target": 0,
    "idx": 2033444
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "ZEND_API zend_result ZEND_FASTCALL div_function(zval *result, zval *op1, zval *op2) /* {{{ */\n{\n\tZVAL_DEREF(op1);\n\tZVAL_DEREF(op2);\n\n\tint retval = div_function_base(result, op1, op2);\n\tif (EXPECTED(retval == SUCCESS)) {\n\t\treturn SUCCESS;\n\t}\n\n\tif (UNEXPECTED(retval == DIV_BY_ZERO)) {\n\t\tgoto div_by_zero;\n\t}\n\n\tZEND_TRY_BINARY_OBJECT_OPERATION(ZEND_DIV);\n\n\tzval result_copy, op1_copy, op2_copy;\n\tif (UNEXPECTED(zendi_try_convert_scalar_to_number(op1, &op1_copy) == FAILURE)\n\t\t\t|| UNEXPECTED(zendi_try_convert_scalar_to_number(op2, &op2_copy) == FAILURE)) {\n\t\tzend_binop_error(\"/\", op1, op2);\n\t\tif (result != op1) {\n\t\t\tZVAL_UNDEF(result);\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tretval = div_function_base(&result_copy, &op1_copy, &op2_copy);\n\tif (retval == SUCCESS) {\n\t\tif (result == op1) {\n\t\t\tzval_ptr_dtor(result);\n\t\t}\n\t\tZVAL_COPY_VALUE(result, &result_copy);\n\t\treturn SUCCESS;\n\t}\n\ndiv_by_zero:\n\tZEND_ASSERT(retval == DIV_BY_ZERO && \"TYPES_NOT_HANDLED should not occur here\");\n\tif (result != op1) {\n\t\tZVAL_UNDEF(result);\n\t}\n\tzend_throw_error(zend_ce_division_by_zero_error, \"Division by zero\");\n\treturn FAILURE;\n}\nstatic void fuzzer_execute_ex(zend_execute_data *execute_data) {\n\twhile (1) {\n\t\tint ret;\n\t\tif (--steps_left == 0) {\n\t\t\t/* Reset steps before bailing out, so code running after bailout (e.g. in\n\t\t\t * destructors) will get another MAX_STEPS, rather than UINT32_MAX steps. */\n\t\t\tsteps_left = MAX_STEPS;\n\t\t\tzend_bailout();\n\t\t}\n\n\t\tif ((ret = ((opcode_handler_t) EX(opline)->handler)(execute_data)) != 0) {\n\t\t\tif (ret > 0) {\n\t\t\t\texecute_data = EG(current_execute_data);\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\nint fuzzer_do_request_from_buffer(\n\t\tchar *filename, const char *data, size_t data_len, zend_bool execute)\n{\n\tint retval = FAILURE; /* failure by default */\n\n\tSG(options) |= SAPI_OPTION_NO_CHDIR;\n\tSG(request_info).argc=0;\n\tSG(request_info).argv=NULL;\n\n\tif (fuzzer_request_startup() == FAILURE) {\n\t\treturn FAILURE;\n\t}\n\n\t// Commented out to avoid leaking the header callback.\n\t//SG(headers_sent) = 1;\n\t//SG(request_info).no_headers = 1;\n\tphp_register_variable(\"PHP_SELF\", filename, NULL);\n\n\tzend_first_try {\n\t\tzend_file_handle file_handle;\n\t\tzend_stream_init_filename(&file_handle, filename);\n\t\tfile_handle.buf = estrndup(data, data_len);\n\t\tfile_handle.len = data_len;\n\n\t\tzend_op_array *op_array = zend_compile_file(&file_handle, ZEND_REQUIRE);\n\t\tif (op_array) {\n\t\t\tif (execute) {\n\t\t\t\tzend_execute(op_array, NULL);\n\t\t\t}\n\t\t\tdestroy_op_array(op_array);\n\t\t\tefree(op_array);\n\t\t}\n\t} zend_end_try();\n\n\tCG(compiled_filename) = NULL; /* ??? */\n\tfuzzer_request_shutdown();\n\n\treturn (retval == SUCCESS) ? SUCCESS : FAILURE;\n}\nint LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {\n\tif (Size > MAX_SIZE) {\n\t\t/* Large inputs have a large impact on fuzzer performance,\n\t\t * but are unlikely to be necessary to reach new codepaths. */\n\t\treturn 0;\n\t}\n\n\tsteps_left = MAX_STEPS;\n\tfuzzer_do_request_from_buffer(\"/fuzzer.php\", (const char *) Data, Size, /* execute */ 1);\n\n\treturn 0;\n}",
    "target": 0,
    "idx": 2035876
  },
  {
    "CWE_ID": [
      "CWE-416"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-122",
      "CWE-120",
      "CWE-125"
    ],
    "if_multi_func": false,
    "code": "int\ngnutls_pkcs12_simple_parse(gnutls_pkcs12_t p12,\n\t\t\t   const char *password,\n\t\t\t   gnutls_x509_privkey_t * key,\n\t\t\t   gnutls_x509_crt_t ** chain,\n\t\t\t   unsigned int *chain_len,\n\t\t\t   gnutls_x509_crt_t ** extra_certs,\n\t\t\t   unsigned int *extra_certs_len,\n\t\t\t   gnutls_x509_crl_t * crl, unsigned int flags)\n{\n\tgnutls_pkcs12_bag_t bag = NULL;\n\tgnutls_x509_crt_t *_extra_certs = NULL;\n\tunsigned int _extra_certs_len = 0;\n\tgnutls_x509_crt_t *_chain = NULL;\n\tunsigned int _chain_len = 0;\n\tint idx = 0;\n\tint ret;\n\tsize_t cert_id_size = 0;\n\tsize_t key_id_size = 0;\n\tuint8_t cert_id[20];\n\tuint8_t key_id[20];\n\tint privkey_ok = 0;\n\tunsigned int i;\n\tint elements_in_bag;\n\n\t*key = NULL;\n\n\tif (crl)\n\t\t*crl = NULL;\n\n\t/* find the first private key */\n\tfor (;;) {\n\n\t\tret = gnutls_pkcs12_bag_init(&bag);\n\t\tif (ret < 0) {\n\t\t\tbag = NULL;\n\t\t\tgnutls_assert();\n\t\t\tgoto done;\n\t\t}\n\n\t\tret = gnutls_pkcs12_get_bag(p12, idx, bag);\n\t\tif (ret == GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE) {\n\t\t\tgnutls_pkcs12_bag_deinit(bag);\n\t\t\tbag = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto done;\n\t\t}\n\n\t\tret = gnutls_pkcs12_bag_get_type(bag, 0);\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (ret == GNUTLS_BAG_ENCRYPTED) {\n\t\t\tif (password == NULL) {\n\t\t\t\tret =\n\t\t\t\t    gnutls_assert_val\n\t\t\t\t    (GNUTLS_E_DECRYPTION_FAILED);\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tret = gnutls_pkcs12_bag_decrypt(bag, password);\n\t\t\tif (ret < 0) {\n\t\t\t\tgnutls_assert();\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\n\t\telements_in_bag = gnutls_pkcs12_bag_get_count(bag);\n\t\tif (elements_in_bag < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto done;\n\t\t}\n\n\t\tfor (i = 0; i < (unsigned)elements_in_bag; i++) {\n\t\t\tint type;\n\t\t\tgnutls_datum_t data;\n\n\t\t\ttype = gnutls_pkcs12_bag_get_type(bag, i);\n\t\t\tif (type < 0) {\n\t\t\t\tgnutls_assert();\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tret = gnutls_pkcs12_bag_get_data(bag, i, &data);\n\t\t\tif (ret < 0) {\n\t\t\t\tgnutls_assert();\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tswitch (type) {\n\t\t\tcase GNUTLS_BAG_PKCS8_ENCRYPTED_KEY:\n\t\t\t\tif (password == NULL) {\n\t\t\t\t\tret =\n\t\t\t\t\t    gnutls_assert_val\n\t\t\t\t\t    (GNUTLS_E_DECRYPTION_FAILED);\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\t/* fallthrough */\n\t\t\tcase GNUTLS_BAG_PKCS8_KEY:\n\t\t\t\tif (*key != NULL) {\t/* too simple to continue */\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tret = gnutls_x509_privkey_init(key);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\tret = gnutls_x509_privkey_import_pkcs8\n\t\t\t\t    (*key, &data, GNUTLS_X509_FMT_DER,\n\t\t\t\t     password,\n\t\t\t\t     type ==\n\t\t\t\t     GNUTLS_BAG_PKCS8_KEY ?\n\t\t\t\t     GNUTLS_PKCS_PLAIN : 0);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\tkey_id_size = sizeof(key_id);\n\t\t\t\tret =\n\t\t\t\t    gnutls_x509_privkey_get_key_id(*key, 0,\n\t\t\t\t\t\t\t\t   key_id,\n\t\t\t\t\t\t\t\t   &key_id_size);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\tprivkey_ok = 1;\t/* break */\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tidx++;\n\t\tgnutls_pkcs12_bag_deinit(bag);\n\t\tbag = NULL;\n\n\t\tif (privkey_ok != 0)\t/* private key was found */\n\t\t\tbreak;\n\t}\n\n\tif (privkey_ok == 0) {\t/* no private key */\n\t\tgnutls_assert();\n\t\treturn GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE;\n\t}\n\n\t/* now find the corresponding certificate \n\t */\n\tidx = 0;\n\tbag = NULL;\n\tfor (;;) {\n\t\tret = gnutls_pkcs12_bag_init(&bag);\n\t\tif (ret < 0) {\n\t\t\tbag = NULL;\n\t\t\tgnutls_assert();\n\t\t\tgoto done;\n\t\t}\n\n\t\tret = gnutls_pkcs12_get_bag(p12, idx, bag);\n\t\tif (ret == GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE) {\n\t\t\tgnutls_pkcs12_bag_deinit(bag);\n\t\t\tbag = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto done;\n\t\t}\n\n\t\tret = gnutls_pkcs12_bag_get_type(bag, 0);\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (ret == GNUTLS_BAG_ENCRYPTED) {\n\t\t\tret = gnutls_pkcs12_bag_decrypt(bag, password);\n\t\t\tif (ret < 0) {\n\t\t\t\tgnutls_assert();\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\n\t\telements_in_bag = gnutls_pkcs12_bag_get_count(bag);\n\t\tif (elements_in_bag < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto done;\n\t\t}\n\n\t\tfor (i = 0; i < (unsigned)elements_in_bag; i++) {\n\t\t\tint type;\n\t\t\tgnutls_datum_t data;\n\t\t\tgnutls_x509_crt_t this_cert;\n\n\t\t\ttype = gnutls_pkcs12_bag_get_type(bag, i);\n\t\t\tif (type < 0) {\n\t\t\t\tgnutls_assert();\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tret = gnutls_pkcs12_bag_get_data(bag, i, &data);\n\t\t\tif (ret < 0) {\n\t\t\t\tgnutls_assert();\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tswitch (type) {\n\t\t\tcase GNUTLS_BAG_CERTIFICATE:\n\t\t\t\tret = gnutls_x509_crt_init(&this_cert);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\tret =\n\t\t\t\t    gnutls_x509_crt_import(this_cert,\n\t\t\t\t\t\t\t   &data,\n\t\t\t\t\t\t\t   GNUTLS_X509_FMT_DER);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tgnutls_x509_crt_deinit(this_cert);\n\t\t\t\t\tthis_cert = NULL;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\t/* check if the key id match */\n\t\t\t\tcert_id_size = sizeof(cert_id);\n\t\t\t\tret =\n\t\t\t\t    gnutls_x509_crt_get_key_id(this_cert,\n\t\t\t\t\t\t\t       0, cert_id,\n\t\t\t\t\t\t\t       &cert_id_size);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tgnutls_x509_crt_deinit(this_cert);\n\t\t\t\t\tthis_cert = NULL;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\tif (memcmp(cert_id, key_id, cert_id_size) != 0) {\t/* they don't match - skip the certificate */\n\t\t\t\t\t_extra_certs =\n\t\t\t\t\t\tgnutls_realloc_fast\n\t\t\t\t\t\t(_extra_certs,\n\t\t\t\t\t\t sizeof(_extra_certs\n\t\t\t\t\t\t\t[0]) *\n\t\t\t\t\t\t ++_extra_certs_len);\n\t\t\t\t\tif (!_extra_certs) {\n\t\t\t\t\t\tgnutls_assert();\n\t\t\t\t\t\tret =\n\t\t\t\t\t\t\tGNUTLS_E_MEMORY_ERROR;\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t\t_extra_certs\n\t\t\t\t\t\t[_extra_certs_len -\n\t\t\t\t\t\t 1] = this_cert;\n\t\t\t\t\tthis_cert = NULL;\n\t\t\t\t} else {\n\t\t\t\t\tif (chain && _chain_len == 0) {\n\t\t\t\t\t\t_chain =\n\t\t\t\t\t\t    gnutls_malloc(sizeof\n\t\t\t\t\t\t\t\t  (_chain\n\t\t\t\t\t\t\t\t   [0]) *\n\t\t\t\t\t\t\t\t  (++_chain_len));\n\t\t\t\t\t\tif (!_chain) {\n\t\t\t\t\t\t\tgnutls_assert();\n\t\t\t\t\t\t\tret =\n\t\t\t\t\t\t\t    GNUTLS_E_MEMORY_ERROR;\n\t\t\t\t\t\t\tgoto done;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_chain[_chain_len - 1] =\n\t\t\t\t\t\t    this_cert;\n\t\t\t\t\t\tthis_cert = NULL;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgnutls_x509_crt_deinit\n\t\t\t\t\t\t    (this_cert);\n\t\t\t\t\t\tthis_cert = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase GNUTLS_BAG_CRL:\n\t\t\t\tif (crl == NULL || *crl != NULL) {\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tret = gnutls_x509_crl_init(crl);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\tret =\n\t\t\t\t    gnutls_x509_crl_import(*crl, &data,\n\t\t\t\t\t\t\t   GNUTLS_X509_FMT_DER);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tgnutls_assert();\n\t\t\t\t\tgnutls_x509_crl_deinit(*crl);\n\t\t\t\t\t*crl = NULL;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase GNUTLS_BAG_ENCRYPTED:\n\t\t\t\t/* XXX Bother to recurse one level down?  Unlikely to\n\t\t\t\t   use the same password anyway. */\n\t\t\tcase GNUTLS_BAG_EMPTY:\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tidx++;\n\t\tgnutls_pkcs12_bag_deinit(bag);\n\t\tbag = NULL;\n\t}\n\n\tif (chain != NULL) {\n\t\tif (_chain_len != 1) {\n\t\t\tret = GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE;\n\t\t\tgoto done;\n\t\t}\n\n\t\tret =\n\t\t    make_chain(&_chain, &_chain_len, &_extra_certs,\n\t\t\t       &_extra_certs_len, flags);\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tret = 0;\n\n      done:\n\tif (bag)\n\t\tgnutls_pkcs12_bag_deinit(bag);\n\n\tif (ret < 0) {\n\t\tif (*key) {\n\t\t\tgnutls_x509_privkey_deinit(*key);\n\t\t\t*key = NULL;\n\t\t}\n\t\tif (crl != NULL && *crl != NULL) {\n\t\t\tgnutls_x509_crl_deinit(*crl);\n\t\t\t*crl = NULL;\n\t\t}\n\t\tif (_extra_certs_len && _extra_certs != NULL) {\n\t\t\tfor (i = 0; i < _extra_certs_len; i++)\n\t\t\t\tgnutls_x509_crt_deinit(_extra_certs[i]);\n\t\t\tgnutls_free(_extra_certs);\n\t\t}\n\t\tif (_chain_len && _chain != NULL) {\n\t\t\tfor (i = 0; i < _chain_len; i++)\n\t\t\t\tgnutls_x509_crt_deinit(_chain[i]);\n\t\t\tgnutls_free(_chain);\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tif (extra_certs && _extra_certs_len > 0) {\n\t\t*extra_certs = _extra_certs;\n\t\t*extra_certs_len = _extra_certs_len;\n\t} else {\n\t\tif (extra_certs) {\n\t\t\t*extra_certs = NULL;\n\t\t\t*extra_certs_len = 0;\n\t\t}\n\t\tfor (i = 0; i < _extra_certs_len; i++)\n\t\t\tgnutls_x509_crt_deinit(_extra_certs[i]);\n\t\tgnutls_free(_extra_certs);\n\t}\n\n\tif (chain != NULL) {\n\t\t*chain = _chain;\n\t\t*chain_len = _chain_len;\n\t}\n\n\treturn ret;\n}\nvoid gnutls_x509_crl_deinit(gnutls_x509_crl_t crl)\n{\n\tif (!crl)\n\t\treturn;\n\n\tif (crl->crl)\n\t\tasn1_delete_structure(&crl->crl);\n\tgnutls_free(crl->der.data);\n\n\tgnutls_free(crl);\n}\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n    gnutls_datum_t raw = {(unsigned char*)data, (unsigned int)size};\n    gnutls_pkcs12_t p12;\n    gnutls_x509_privkey_t key;\n    gnutls_x509_crt_t *chain;\n    gnutls_x509_crt_t *extras;\n    gnutls_x509_crl_t crl;\n    unsigned int chain_len = 0, extras_len = 0;\n    unsigned int i;\n    int ret;\n\n    raw.data = (unsigned char *)data;\n    raw.size = size;\n\n    ret = gnutls_pkcs12_init(&p12);\n    assert(ret >= 0);\n\n    ret = gnutls_pkcs12_import(p12, &raw, GNUTLS_X509_FMT_DER, 0);\n    if (ret < 0) {\n        goto cleanup;\n    }\n\n    /* catch crashes */\n    gnutls_pkcs12_verify_mac(p12, \"1234\");\n\n    ret = gnutls_pkcs12_simple_parse(p12, \"1234\", &key, &chain, &chain_len, &extras, &extras_len, &crl, 0);\n    if (ret >= 0) {\n    \tgnutls_x509_privkey_deinit(key);\n    \tif (crl)\n\t    \tgnutls_x509_crl_deinit(crl);\n\tif (extras_len > 0) {\n\t\tfor (i=0;i<extras_len;i++)\n\t\t\tgnutls_x509_crt_deinit(extras[i]);\n\t\tgnutls_free(extras);\n\t}\n\tif (chain_len > 0) {\n\t\tfor (i=0;i<chain_len;i++)\n\t\t\tgnutls_x509_crt_deinit(chain[i]);\n\t\tgnutls_free(chain);\n\t}\n    }\n\n cleanup:\n    gnutls_pkcs12_deinit(p12);\n    return 0;\n}\nvoid Fuzzer::ExecuteCallback(const uint8_t *Data, size_t Size) {\n  assert(InFuzzingThread());\n  if (SMR.IsClient())\n    SMR.WriteByteArray(Data, Size);\n  // We copy the contents of Unit into a separate heap buffer\n  // so that we reliably find buffer overflows in it.\n  uint8_t *DataCopy = new uint8_t[Size];\n  memcpy(DataCopy, Data, Size);\n  if (CurrentUnitData && CurrentUnitData != Data)\n    memcpy(CurrentUnitData, Data, Size);\n  CurrentUnitSize = Size;\n  AllocTracer.Start(Options.TraceMalloc);\n  UnitStartTime = system_clock::now();\n  TPC.ResetMaps();\n  RunningCB = true;\n  int Res = CB(DataCopy, Size);\n  RunningCB = false;\n  UnitStopTime = system_clock::now();\n  (void)Res;\n  assert(Res == 0);\n  HasMoreMallocsThanFrees = AllocTracer.Stop();\n  CurrentUnitSize = 0;\n  delete[] DataCopy;\n}\nsize_t Fuzzer::RunOne(const uint8_t *Data, size_t Size) {\n  if (!Size) return 0;\n  TotalNumberOfRuns++;\n\n  ExecuteCallback(Data, Size);\n\n  size_t NumUpdatesBefore = Corpus.NumFeatureUpdates();\n  TPC.CollectFeatures([&](size_t Feature) {\n    Corpus.AddFeature(Feature, Size, Options.Shrink);\n  });\n  size_t NumUpdatesAfter = Corpus.NumFeatureUpdates();\n\n  auto TimeOfUnit =\n      duration_cast<seconds>(UnitStopTime - UnitStartTime).count();\n  if (!(TotalNumberOfRuns & (TotalNumberOfRuns - 1)) &&\n      secondsSinceProcessStartUp() >= 2)\n    PrintStats(\"pulse \");\n  if (TimeOfUnit > TimeOfLongestUnitInSeconds * 1.1 &&\n      TimeOfUnit >= Options.ReportSlowUnits) {\n    TimeOfLongestUnitInSeconds = TimeOfUnit;\n    Printf(\"Slowest unit: %zd s:\\n\", TimeOfLongestUnitInSeconds);\n    WriteUnitToFileWithPrefix({Data, Data + Size}, \"slow-unit-\");\n  }\n  return NumUpdatesAfter - NumUpdatesBefore;\n}\nint RunOneTest(Fuzzer *F, const char *InputFilePath, size_t MaxLen) {\n  Unit U = FileToVector(InputFilePath);\n  if (MaxLen && MaxLen < U.size())\n    U.resize(MaxLen);\n  F->RunOne(U.data(), U.size());\n  F->TryDetectingAMemoryLeak(U.data(), U.size(), true);\n  return 0;\n}\nint FuzzerDriver(int *argc, char ***argv, UserCallback Callback) {\n  using namespace fuzzer;\n  assert(argc && argv && \"Argument pointers cannot be nullptr\");\n  std::string Argv0((*argv)[0]);\n  EF = new ExternalFunctions();\n  if (EF->LLVMFuzzerInitialize)\n    EF->LLVMFuzzerInitialize(argc, argv);\n  const std::vector<std::string> Args(*argv, *argv + *argc);\n  assert(!Args.empty());\n  ProgName = new std::string(Args[0]);\n  if (Argv0 != *ProgName) {\n    Printf(\"ERROR: argv[0] has been modified in LLVMFuzzerInitialize\\n\");\n    exit(1);\n  }\n  ParseFlags(Args);\n  if (Flags.help) {\n    PrintHelp();\n    return 0;\n  }\n\n  if (Flags.close_fd_mask & 2)\n    DupAndCloseStderr();\n  if (Flags.close_fd_mask & 1)\n    CloseStdout();\n\n  if (Flags.jobs > 0 && Flags.workers == 0) {\n    Flags.workers = std::min(NumberOfCpuCores() / 2, Flags.jobs);\n    if (Flags.workers > 1)\n      Printf(\"Running %u workers\\n\", Flags.workers);\n  }\n\n  if (Flags.workers > 0 && Flags.jobs > 0)\n    return RunInMultipleProcesses(Args, Flags.workers, Flags.jobs);\n\n  const size_t kMaxSaneLen = 1 << 20;\n  const size_t kMinDefaultLen = 64;\n  FuzzingOptions Options;\n  Options.Verbosity = Flags.verbosity;\n  Options.MaxLen = Flags.max_len;\n  Options.ExperimentalLenControl = Flags.experimental_len_control;\n  if (Flags.experimental_len_control && Flags.max_len == 64)\n    Options.MaxLen = 1 << 20;\n  Options.UnitTimeoutSec = Flags.timeout;\n  Options.ErrorExitCode = Flags.error_exitcode;\n  Options.TimeoutExitCode = Flags.timeout_exitcode;\n  Options.MaxTotalTimeSec = Flags.max_total_time;\n  Options.DoCrossOver = Flags.cross_over;\n  Options.MutateDepth = Flags.mutate_depth;\n  Options.UseCounters = Flags.use_counters;\n  Options.UseIndirCalls = Flags.use_indir_calls;\n  Options.UseMemmem = Flags.use_memmem;\n  Options.UseCmp = Flags.use_cmp;\n  Options.UseValueProfile = Flags.use_value_profile;\n  Options.Shrink = Flags.shrink;\n  Options.ShuffleAtStartUp = Flags.shuffle;\n  Options.PreferSmall = Flags.prefer_small;\n  Options.ReloadIntervalSec = Flags.reload;\n  Options.OnlyASCII = Flags.only_ascii;\n  Options.DetectLeaks = Flags.detect_leaks;\n  Options.TraceMalloc = Flags.trace_malloc;\n  Options.RssLimitMb = Flags.rss_limit_mb;\n  if (Flags.runs >= 0)\n    Options.MaxNumberOfRuns = Flags.runs;\n  if (!Inputs->empty() && !Flags.minimize_crash_internal_step)\n    Options.OutputCorpus = (*Inputs)[0];\n  Options.ReportSlowUnits = Flags.report_slow_units;\n  if (Flags.artifact_prefix)\n    Options.ArtifactPrefix = Flags.artifact_prefix;\n  if (Flags.exact_artifact_path)\n    Options.ExactArtifactPath = Flags.exact_artifact_path;\n  std::vector<Unit> Dictionary;\n  if (Flags.dict)\n    if (!ParseDictionaryFile(FileToString(Flags.dict), &Dictionary))\n      return 1;\n  if (Flags.verbosity > 0 && !Dictionary.empty())\n    Printf(\"Dictionary: %zd entries\\n\", Dictionary.size());\n  bool DoPlainRun = AllInputsAreFiles();\n  Options.SaveArtifacts =\n      !DoPlainRun || Flags.minimize_crash_internal_step;\n  Options.PrintNewCovPcs = Flags.print_pcs;\n  Options.PrintFinalStats = Flags.print_final_stats;\n  Options.PrintCorpusStats = Flags.print_corpus_stats;\n  Options.PrintCoverage = Flags.print_coverage;\n  Options.DumpCoverage = Flags.dump_coverage;\n  if (Flags.exit_on_src_pos)\n    Options.ExitOnSrcPos = Flags.exit_on_src_pos;\n  if (Flags.exit_on_item)\n    Options.ExitOnItem = Flags.exit_on_item;\n\n  unsigned Seed = Flags.seed;\n  // Initialize Seed.\n  if (Seed == 0)\n    Seed =\n        std::chrono::system_clock::now().time_since_epoch().count() + GetPid();\n  if (Flags.verbosity)\n    Printf(\"INFO: Seed: %u\\n\", Seed);\n\n  Random Rand(Seed);\n  auto *MD = new MutationDispatcher(Rand, Options);\n  auto *Corpus = new InputCorpus(Options.OutputCorpus);\n  auto *F = new Fuzzer(Callback, *Corpus, *MD, Options);\n\n  for (auto &U: Dictionary)\n    if (U.size() <= Word::GetMaxSize())\n      MD->AddWordToManualDictionary(Word(U.data(), U.size()));\n\n  StartRssThread(F, Flags.rss_limit_mb);\n\n  Options.HandleAbrt = Flags.handle_abrt;\n  Options.HandleBus = Flags.handle_bus;\n  Options.HandleFpe = Flags.handle_fpe;\n  Options.HandleIll = Flags.handle_ill;\n  Options.HandleInt = Flags.handle_int;\n  Options.HandleSegv = Flags.handle_segv;\n  Options.HandleTerm = Flags.handle_term;\n  Options.HandleXfsz = Flags.handle_xfsz;\n  SetSignalHandler(Options);\n\n  if (Flags.minimize_crash)\n    return MinimizeCrashInput(Args, Options);\n\n  if (Flags.minimize_crash_internal_step)\n    return MinimizeCrashInputInternalStep(F, Corpus);\n\n  if (Flags.cleanse_crash)\n    return CleanseCrashInput(Args, Options);\n\n  if (auto Name = Flags.run_equivalence_server) {\n    SMR.Destroy(Name);\n    if (!SMR.Create(Name)) {\n       Printf(\"ERROR: can't create shared memory region\\n\");\n      return 1;\n    }\n    Printf(\"INFO: EQUIVALENCE SERVER UP\\n\");\n    while (true) {\n      SMR.WaitClient();\n      size_t Size = SMR.ReadByteArraySize();\n      SMR.WriteByteArray(nullptr, 0);\n      F->RunOne(SMR.GetByteArray(), Size);\n      SMR.PostServer();\n    }\n    return 0;\n  }\n\n  if (auto Name = Flags.use_equivalence_server) {\n    if (!SMR.Open(Name)) {\n      Printf(\"ERROR: can't open shared memory region\\n\");\n      return 1;\n    }\n    Printf(\"INFO: EQUIVALENCE CLIENT UP\\n\");\n  }\n\n  if (DoPlainRun) {\n    Options.SaveArtifacts = false;\n    int Runs = std::max(1, Flags.runs);\n    Printf(\"%s: Running %zd inputs %d time(s) each.\\n\", ProgName->c_str(),\n           Inputs->size(), Runs);\n    for (auto &Path : *Inputs) {\n      auto StartTime = system_clock::now();\n      Printf(\"Running: %s\\n\", Path.c_str());\n      for (int Iter = 0; Iter < Runs; Iter++)\n        RunOneTest(F, Path.c_str(), Options.MaxLen);\n      auto StopTime = system_clock::now();\n      auto MS = duration_cast<milliseconds>(StopTime - StartTime).count();\n      Printf(\"Executed %s in %zd ms\\n\", Path.c_str(), (long)MS);\n    }\n    Printf(\"***\\n\"\n           \"*** NOTE: fuzzing was not performed, you have only\\n\"\n           \"***       executed the target code on a fixed set of inputs.\\n\"\n           \"***\\n\");\n    F->PrintFinalStats();\n    exit(0);\n  }\n\n  if (Flags.merge) {\n    if (Options.MaxLen == 0)\n      F->SetMaxInputLen(kMaxSaneLen);\n    if (Flags.merge_control_file)\n      F->CrashResistantMergeInternalStep(Flags.merge_control_file);\n    else\n      F->CrashResistantMerge(Args, *Inputs,\n                             Flags.load_coverage_summary,\n                             Flags.save_coverage_summary);\n    exit(0);\n  }\n\n  size_t TemporaryMaxLen = Options.MaxLen ? Options.MaxLen : kMaxSaneLen;\n\n  UnitVector InitialCorpus;\n  for (auto &Inp : *Inputs) {\n    Printf(\"Loading corpus dir: %s\\n\", Inp.c_str());\n    ReadDirToVectorOfUnits(Inp.c_str(), &InitialCorpus, nullptr,\n                           TemporaryMaxLen, /*ExitOnError=*/false);\n  }\n\n  if (Flags.analyze_dict) {\n    if (Dictionary.empty() || Inputs->empty()) {\n      Printf(\"ERROR: can't analyze dict without dict and corpus provided\\n\");\n      return 1;\n    }\n    if (AnalyzeDictionary(F, Dictionary, InitialCorpus)) {\n      Printf(\"Dictionary analysis failed\\n\");\n      exit(1);\n    }\n    Printf(\"Dictionary analysis suceeded\\n\");\n    exit(0);\n  }\n\n  if (Options.MaxLen == 0) {\n    size_t MaxLen = 0;\n    for (auto &U : InitialCorpus)\n      MaxLen = std::max(U.size(), MaxLen);\n    F->SetMaxInputLen(std::min(std::max(kMinDefaultLen, MaxLen), kMaxSaneLen));\n  }\n\n  if (InitialCorpus.empty()) {\n    InitialCorpus.push_back(Unit({'\\n'}));  // Valid ASCII input.\n    if (Options.Verbosity)\n      Printf(\"INFO: A corpus is not provided, starting from an empty corpus\\n\");\n  }\n  F->ShuffleAndMinimize(&InitialCorpus);\n  InitialCorpus.clear();  // Don't need this memory any more.\n  F->Loop();\n\n  if (Flags.verbosity)\n    Printf(\"Done %zd runs in %zd second(s)\\n\", F->getTotalNumberOfRuns(),\n           F->secondsSinceProcessStartUp());\n  F->PrintFinalStats();\n\n  exit(0);  // Don't let F destroy itself.\n}\nint main(int argc, char **argv) {\n  return fuzzer::FuzzerDriver(&argc, &argv, LLVMFuzzerTestOneInput);\n}",
    "target": 0,
    "idx": 2001304
  }
]