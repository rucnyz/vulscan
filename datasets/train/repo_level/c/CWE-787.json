[
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic void\nxmlParseCommentComplex(xmlParserCtxtPtr ctxt, xmlChar *buf,\n                       size_t len, size_t size) {\n    int q, ql;\n    int r, rl;\n    int cur, l;\n    size_t maxLength = (ctxt->options & XML_PARSE_HUGE) ?\n                       XML_MAX_HUGE_LENGTH :\n                       XML_MAX_TEXT_LENGTH;\n    int inputid;\n\n    inputid = ctxt->input->id;\n\n    if (buf == NULL) {\n        len = 0;\n\tsize = XML_PARSER_BUFFER_SIZE;\n\tbuf = (xmlChar *) xmlMallocAtomic(size);\n\tif (buf == NULL) {\n\t    xmlErrMemory(ctxt, NULL);\n\t    return;\n\t}\n    }\n    q = CUR_CHAR(ql);\n    if (q == 0)\n        goto not_terminated;\n    if (!IS_CHAR(q)) {\n        xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,\n                          \"xmlParseComment: invalid xmlChar value %d\\n\",\n\t                  q);\n\txmlFree (buf);\n\treturn;\n    }\n    NEXTL(ql);\n    r = CUR_CHAR(rl);\n    if (r == 0)\n        goto not_terminated;\n    if (!IS_CHAR(r)) {\n        xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,\n                          \"xmlParseComment: invalid xmlChar value %d\\n\",\n\t                  r);\n\txmlFree (buf);\n\treturn;\n    }\n    NEXTL(rl);\n    cur = CUR_CHAR(l);\n    if (cur == 0)\n        goto not_terminated;\n    while (IS_CHAR(cur) && /* checked */\n           ((cur != '>') ||\n\t    (r != '-') || (q != '-'))) {\n\tif ((r == '-') && (q == '-')) {\n\t    xmlFatalErr(ctxt, XML_ERR_HYPHEN_IN_COMMENT, NULL);\n\t}\n\tif (len + 5 >= size) {\n\t    xmlChar *new_buf;\n            size_t new_size;\n\n\t    new_size = size * 2;\n\t    new_buf = (xmlChar *) xmlRealloc(buf, new_size);\n\t    if (new_buf == NULL) {\n\t\txmlFree (buf);\n\t\txmlErrMemory(ctxt, NULL);\n\t\treturn;\n\t    }\n\t    buf = new_buf;\n            size = new_size;\n\t}\n\tCOPY_BUF(ql,buf,len,q);\n        if (len > maxLength) {\n            xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,\n                         \"Comment too big found\", NULL);\n            xmlFree (buf);\n            return;\n        }\n\n\tq = r;\n\tql = rl;\n\tr = cur;\n\trl = l;\n\n\tNEXTL(l);\n\tcur = CUR_CHAR(l);\n\n    }\n    buf[len] = 0;\n    if (ctxt->instate == XML_PARSER_EOF) {\n        xmlFree(buf);\n        return;\n    }\n    if (cur == 0) {\n\txmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,\n\t                     \"Comment not terminated \\n<!--%.50s\\n\", buf);\n    } else if (!IS_CHAR(cur)) {\n        xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,\n                          \"xmlParseComment: invalid xmlChar value %d\\n\",\n\t                  cur);\n    } else {\n\tif (inputid != ctxt->input->id) {\n\t    xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n\t\t           \"Comment doesn't start and stop in the same\"\n                           \" entity\\n\");\n\t}\n        NEXT;\n\tif ((ctxt->sax != NULL) && (ctxt->sax->comment != NULL) &&\n\t    (!ctxt->disableSAX))\n\t    ctxt->sax->comment(ctxt->userData, buf);\n    }\n    xmlFree(buf);\n    return;\nnot_terminated:\n    xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,\n\t\t\t \"Comment not terminated\\n\", NULL);\n    xmlFree(buf);\n    return;\n}\n\nvoid\nxmlParseComment(xmlParserCtxtPtr ctxt) {\n    xmlChar *buf = NULL;\n    size_t size = XML_PARSER_BUFFER_SIZE;\n    size_t len = 0;\n    size_t maxLength = (ctxt->options & XML_PARSE_HUGE) ?\n                       XML_MAX_HUGE_LENGTH :\n                       XML_MAX_TEXT_LENGTH;\n    xmlParserInputState state;\n    const xmlChar *in;\n    size_t nbchar = 0;\n    int ccol;\n    int inputid;\n\n    /*\n     * Check that there is a comment right here.\n     */\n    if ((RAW != '<') || (NXT(1) != '!'))\n        return;\n    SKIP(2);\n    if ((RAW != '-') || (NXT(1) != '-'))\n        return;\n    state = ctxt->instate;\n    ctxt->instate = XML_PARSER_COMMENT;\n    inputid = ctxt->input->id;\n    SKIP(2);\n    GROW;\n\n    /*\n     * Accelerated common case where input don't need to be\n     * modified before passing it to the handler.\n     */\n    in = ctxt->input->cur;\n    do {\n\tif (*in == 0xA) {\n\t    do {\n\t\tctxt->input->line++; ctxt->input->col = 1;\n\t\tin++;\n\t    } while (*in == 0xA);\n\t}\nget_more:\n        ccol = ctxt->input->col;\n\twhile (((*in > '-') && (*in <= 0x7F)) ||\n\t       ((*in >= 0x20) && (*in < '-')) ||\n\t       (*in == 0x09)) {\n\t\t    in++;\n\t\t    ccol++;\n\t}\n\tctxt->input->col = ccol;\n\tif (*in == 0xA) {\n\t    do {\n\t\tctxt->input->line++; ctxt->input->col = 1;\n\t\tin++;\n\t    } while (*in == 0xA);\n\t    goto get_more;\n\t}\n\tnbchar = in - ctxt->input->cur;\n\t/*\n\t * save current set of data\n\t */\n\tif (nbchar > 0) {\n            if (buf == NULL) {\n                if ((*in == '-') && (in[1] == '-'))\n                    size = nbchar + 1;\n                else\n                    size = XML_PARSER_BUFFER_SIZE + nbchar;\n                buf = (xmlChar *) xmlMallocAtomic(size);\n                if (buf == NULL) {\n                    xmlErrMemory(ctxt, NULL);\n                    ctxt->instate = state;\n                    return;\n                }\n                len = 0;\n            } else if (len + nbchar + 1 >= size) {\n                xmlChar *new_buf;\n                size  += len + nbchar + XML_PARSER_BUFFER_SIZE;\n                new_buf = (xmlChar *) xmlRealloc(buf, size);\n                if (new_buf == NULL) {\n                    xmlFree (buf);\n                    xmlErrMemory(ctxt, NULL);\n                    ctxt->instate = state;\n                    return;\n                }\n                buf = new_buf;\n            }\n            memcpy(&buf[len], ctxt->input->cur, nbchar);\n            len += nbchar;\n            buf[len] = 0;\n\t}\n        if (len > maxLength) {\n            xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,\n                         \"Comment too big found\", NULL);\n            xmlFree (buf);\n            return;\n        }\n\tctxt->input->cur = in;\n\tif (*in == 0xA) {\n\t    in++;\n\t    ctxt->input->line++; ctxt->input->col = 1;\n\t}\n\tif (*in == 0xD) {\n\t    in++;\n\t    if (*in == 0xA) {\n\t\tctxt->input->cur = in;\n\t\tin++;\n\t\tctxt->input->line++; ctxt->input->col = 1;\n\t\tgoto get_more;\n\t    }\n\t    in--;\n\t}\n\tSHRINK;\n\tGROW;\n        if (ctxt->instate == XML_PARSER_EOF) {\n            xmlFree(buf);\n            return;\n        }\n\tin = ctxt->input->cur;\n\tif (*in == '-') {\n\t    if (in[1] == '-') {\n\t        if (in[2] == '>') {\n\t\t    if (ctxt->input->id != inputid) {\n\t\t\txmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n\t\t\t               \"comment doesn't start and stop in the\"\n                                       \" same entity\\n\");\n\t\t    }\n\t\t    SKIP(3);\n\t\t    if ((ctxt->sax != NULL) && (ctxt->sax->comment != NULL) &&\n\t\t        (!ctxt->disableSAX)) {\n\t\t\tif (buf != NULL)\n\t\t\t    ctxt->sax->comment(ctxt->userData, buf);\n\t\t\telse\n\t\t\t    ctxt->sax->comment(ctxt->userData, BAD_CAST \"\");\n\t\t    }\n\t\t    if (buf != NULL)\n\t\t        xmlFree(buf);\n\t\t    if (ctxt->instate != XML_PARSER_EOF)\n\t\t\tctxt->instate = state;\n\t\t    return;\n\t\t}\n\t\tif (buf != NULL) {\n\t\t    xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,\n\t\t                      \"Double hyphen within comment: \"\n                                      \"<!--%.50s\\n\",\n\t\t\t\t      buf);\n\t\t} else\n\t\t    xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,\n\t\t                      \"Double hyphen within comment\\n\", NULL);\n                if (ctxt->instate == XML_PARSER_EOF) {\n                    xmlFree(buf);\n                    return;\n                }\n\t\tin++;\n\t\tctxt->input->col++;\n\t    }\n\t    in++;\n\t    ctxt->input->col++;\n\t    goto get_more;\n\t}\n    } while (((*in >= 0x20) && (*in <= 0x7F)) || (*in == 0x09) || (*in == 0x0a));\n    xmlParseCommentComplex(ctxt, buf, len, size);\n    ctxt->instate = state;\n    return;\n}\n\nvoid\nxmlParseMisc(xmlParserCtxtPtr ctxt) {\n    while (ctxt->instate != XML_PARSER_EOF) {\n        SKIP_BLANKS;\n        GROW;\n        if ((RAW == '<') && (NXT(1) == '?')) {\n\t    xmlParsePI(ctxt);\n        } else if (CMP4(CUR_PTR, '<', '!', '-', '-')) {\n\t    xmlParseComment(ctxt);\n        } else {\n            break;\n        }\n    }\n}\n\nint\nxmlParseDocument(xmlParserCtxtPtr ctxt) {\n    xmlInitParser();\n\n    if ((ctxt == NULL) || (ctxt->input == NULL))\n        return(-1);\n\n    GROW;\n\n    /*\n     * SAX: detecting the level.\n     */\n    xmlDetectSAX2(ctxt);\n\n    /*\n     * SAX: beginning of the document processing.\n     */\n    if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))\n        ctxt->sax->setDocumentLocator(ctxt->userData, &xmlDefaultSAXLocator);\n    if (ctxt->instate == XML_PARSER_EOF)\n\treturn(-1);\n\n    xmlDetectEncoding(ctxt);\n\n    if (CUR == 0) {\n\txmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);\n\treturn(-1);\n    }\n\n    GROW;\n    if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) && (IS_BLANK_CH(NXT(5)))) {\n\n\t/*\n\t * Note that we will switch encoding on the fly.\n\t */\n\txmlParseXMLDecl(ctxt);\n\tif ((ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) ||\n\t    (ctxt->instate == XML_PARSER_EOF)) {\n\t    /*\n\t     * The XML REC instructs us to stop parsing right here\n\t     */\n\t    return(-1);\n\t}\n\tSKIP_BLANKS;\n    } else {\n\tctxt->version = xmlCharStrdup(XML_DEFAULT_VERSION);\n    }\n    if ((ctxt->sax) && (ctxt->sax->startDocument) && (!ctxt->disableSAX))\n        ctxt->sax->startDocument(ctxt->userData);\n    if (ctxt->instate == XML_PARSER_EOF)\n\treturn(-1);\n    if ((ctxt->myDoc != NULL) && (ctxt->input != NULL) &&\n        (ctxt->input->buf != NULL) && (ctxt->input->buf->compressed >= 0)) {\n\tctxt->myDoc->compression = ctxt->input->buf->compressed;\n    }\n\n    /*\n     * The Misc part of the Prolog\n     */\n    xmlParseMisc(ctxt);\n\n    /*\n     * Then possibly doc type declaration(s) and more Misc\n     * (doctypedecl Misc*)?\n     */\n    GROW;\n    if (CMP9(CUR_PTR, '<', '!', 'D', 'O', 'C', 'T', 'Y', 'P', 'E')) {\n\n\tctxt->inSubset = 1;\n\txmlParseDocTypeDecl(ctxt);\n\tif (RAW == '[') {\n\t    ctxt->instate = XML_PARSER_DTD;\n\t    xmlParseInternalSubset(ctxt);\n\t    if (ctxt->instate == XML_PARSER_EOF)\n\t\treturn(-1);\n\t}\n\n\t/*\n\t * Create and update the external subset.\n\t */\n\tctxt->inSubset = 2;\n\tif ((ctxt->sax != NULL) && (ctxt->sax->externalSubset != NULL) &&\n\t    (!ctxt->disableSAX))\n\t    ctxt->sax->externalSubset(ctxt->userData, ctxt->intSubName,\n\t                              ctxt->extSubSystem, ctxt->extSubURI);\n\tif (ctxt->instate == XML_PARSER_EOF)\n\t    return(-1);\n\tctxt->inSubset = 0;\n\n        xmlCleanSpecialAttr(ctxt);\n\n\tctxt->instate = XML_PARSER_PROLOG;\n\txmlParseMisc(ctxt);\n    }\n\n    /*\n     * Time to start parsing the tree itself\n     */\n    GROW;\n    if (RAW != '<') {\n\txmlFatalErrMsg(ctxt, XML_ERR_DOCUMENT_EMPTY,\n\t\t       \"Start tag expected, '<' not found\\n\");\n    } else {\n\tctxt->instate = XML_PARSER_CONTENT;\n\txmlParseElement(ctxt);\n\tctxt->instate = XML_PARSER_EPILOG;\n\n\n\t/*\n\t * The Misc part at the end\n\t */\n\txmlParseMisc(ctxt);\n\n        if (ctxt->input->cur < ctxt->input->end) {\n            if (ctxt->errNo == XML_ERR_OK)\n\t        xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);\n        } else if ((ctxt->input->buf != NULL) &&\n                   (ctxt->input->buf->encoder != NULL) &&\n                   (!xmlBufIsEmpty(ctxt->input->buf->raw))) {\n            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n                           \"Truncated multi-byte sequence at EOF\\n\");\n        }\n\tctxt->instate = XML_PARSER_EOF;\n    }\n\n    /*\n     * SAX: end of the document processing.\n     */\n    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n        ctxt->sax->endDocument(ctxt->userData);\n\n    /*\n     * Remove locally kept entity definitions if the tree was not built\n     */\n    if ((ctxt->myDoc != NULL) &&\n\t(xmlStrEqual(ctxt->myDoc->version, SAX_COMPAT_MODE))) {\n\txmlFreeDoc(ctxt->myDoc);\n\tctxt->myDoc = NULL;\n    }\n\n    if ((ctxt->wellFormed) && (ctxt->myDoc != NULL)) {\n        ctxt->myDoc->properties |= XML_DOC_WELLFORMED;\n\tif (ctxt->valid)\n\t    ctxt->myDoc->properties |= XML_DOC_DTDVALID;\n\tif (ctxt->nsWellFormed)\n\t    ctxt->myDoc->properties |= XML_DOC_NSVALID;\n\tif (ctxt->options & XML_PARSE_OLD10)\n\t    ctxt->myDoc->properties |= XML_DOC_OLD10;\n    }\n    if (! ctxt->wellFormed) {\n\tctxt->valid = 0;\n\treturn(-1);\n    }\n    return(0);\n}\n\nstatic xmlDocPtr\nxmlDoRead(xmlParserCtxtPtr ctxt, const char *URL, const char *encoding,\n          int options, int reuse)\n{\n    xmlDocPtr ret;\n\n    xmlCtxtUseOptionsInternal(ctxt, options, encoding);\n    if (encoding != NULL) {\n        xmlCharEncodingHandlerPtr hdlr;\n\n        /*\n         * TODO: We should consider to set XML_PARSE_IGNORE_ENC if the\n         * caller provided an encoding. Otherwise, we might switch to\n         * the encoding from the XML declaration which is likely to\n         * break things. Also see xmlSwitchInputEncoding.\n         */\n\thdlr = xmlFindCharEncodingHandler(encoding);\n\tif (hdlr != NULL)\n\t    xmlSwitchToEncoding(ctxt, hdlr);\n    }\n    if ((URL != NULL) && (ctxt->input != NULL) &&\n        (ctxt->input->filename == NULL))\n        ctxt->input->filename = (char *) xmlStrdup((const xmlChar *) URL);\n    xmlParseDocument(ctxt);\n    if ((ctxt->wellFormed) || ctxt->recovery)\n        ret = ctxt->myDoc;\n    else {\n        ret = NULL;\n\tif (ctxt->myDoc != NULL) {\n\t    xmlFreeDoc(ctxt->myDoc);\n\t}\n    }\n    ctxt->myDoc = NULL;\n    if (!reuse) {\n\txmlFreeParserCtxt(ctxt);\n    }\n\n    return (ret);\n}\n\nxmlDocPtr\nxmlCtxtReadFile(xmlParserCtxtPtr ctxt, const char *filename,\n                const char *encoding, int options)\n{\n    xmlParserInputPtr stream;\n\n    if (filename == NULL)\n        return (NULL);\n    if (ctxt == NULL)\n        return (NULL);\n    xmlInitParser();\n\n    xmlCtxtReset(ctxt);\n\n    stream = xmlLoadExternalEntity(filename, NULL, ctxt);\n    if (stream == NULL) {\n        return (NULL);\n    }\n    inputPush(ctxt, stream);\n    return (xmlDoRead(ctxt, NULL, encoding, options, 1));\n}\n\nstatic int\nxmlSchemaAddSchemaDoc(xmlSchemaParserCtxtPtr pctxt,\n\t\tint type, /* import or include or redefine */\n\t\tconst xmlChar *schemaLocation,\n\t\txmlDocPtr schemaDoc,\n\t\tconst char *schemaBuffer,\n\t\tint schemaBufferLen,\n\t\txmlNodePtr invokingNode,\n\t\tconst xmlChar *sourceTargetNamespace,\n\t\tconst xmlChar *importNamespace,\n\t\txmlSchemaBucketPtr *bucket)\n{\n    const xmlChar *targetNamespace = NULL;\n    xmlSchemaSchemaRelationPtr relation = NULL;\n    xmlDocPtr doc = NULL;\n    int res = 0, err = 0, located = 0, preserveDoc = 0;\n    xmlSchemaBucketPtr bkt = NULL;\n\n    if (bucket != NULL)\n\t*bucket = NULL;\n\n    switch (type) {\n\tcase XML_SCHEMA_SCHEMA_IMPORT:\n\tcase XML_SCHEMA_SCHEMA_MAIN:\n\t    err = XML_SCHEMAP_SRC_IMPORT;\n\t    break;\n\tcase XML_SCHEMA_SCHEMA_INCLUDE:\n\t    err = XML_SCHEMAP_SRC_INCLUDE;\n\t    break;\n\tcase XML_SCHEMA_SCHEMA_REDEFINE:\n\t    err = XML_SCHEMAP_SRC_REDEFINE;\n\t    break;\n    }\n\n\n    /* Special handling for the main schema:\n    * skip the location and relation logic and just parse the doc.\n    * We need just a bucket to be returned in this case.\n    */\n    if ((type == XML_SCHEMA_SCHEMA_MAIN) || (! WXS_HAS_BUCKETS(pctxt)))\n\tgoto doc_load;\n\n    /* Note that we expect the location to be an absolute URI. */\n    if (schemaLocation != NULL) {\n\tbkt = xmlSchemaGetSchemaBucket(pctxt, schemaLocation);\n\tif ((bkt != NULL) &&\n\t    (pctxt->constructor->bucket == bkt)) {\n\t    /* Report self-imports/inclusions/redefinitions. */\n\n\t    xmlSchemaCustomErr(ACTXT_CAST pctxt, err,\n\t\tinvokingNode, NULL,\n\t\t\"The schema must not import/include/redefine itself\",\n\t\tNULL, NULL);\n\t    goto exit;\n\t}\n    }\n    /*\n    * Create a relation for the graph of schemas.\n    */\n    relation = xmlSchemaSchemaRelationCreate();\n    if (relation == NULL)\n\treturn(-1);\n    xmlSchemaSchemaRelationAddChild(pctxt->constructor->bucket,\n\trelation);\n    relation->type = type;\n\n    /*\n    * Save the namespace import information.\n    */\n    if (WXS_IS_BUCKET_IMPMAIN(type)) {\n\trelation->importNamespace = importNamespace;\n\tif (schemaLocation == NULL) {\n\t    /*\n\t    * No location; this is just an import of the namespace.\n\t    * Note that we don't assign a bucket to the relation\n\t    * in this case.\n\t    */\n\t    goto exit;\n\t}\n\ttargetNamespace = importNamespace;\n    }\n\n    /* Did we already fetch the doc? */\n    if (bkt != NULL) {\n\tif ((WXS_IS_BUCKET_IMPMAIN(type)) && (! bkt->imported)) {\n\t    /*\n\t    * We included/redefined and then try to import a schema,\n\t    * but the new location provided for import was different.\n\t    */\n\t    if (schemaLocation == NULL)\n\t\tschemaLocation = BAD_CAST \"in_memory_buffer\";\n\t    if (!xmlStrEqual(schemaLocation,\n\t\tbkt->schemaLocation)) {\n\t\txmlSchemaCustomErr(ACTXT_CAST pctxt, err,\n\t\t    invokingNode, NULL,\n\t\t    \"The schema document '%s' cannot be imported, since \"\n\t\t    \"it was already included or redefined\",\n\t\t    schemaLocation, NULL);\n\t\tgoto exit;\n\t    }\n\t} else if ((! WXS_IS_BUCKET_IMPMAIN(type)) && (bkt->imported)) {\n\t    /*\n\t    * We imported and then try to include/redefine a schema,\n\t    * but the new location provided for the include/redefine\n\t    * was different.\n\t    */\n\t    if (schemaLocation == NULL)\n\t\tschemaLocation = BAD_CAST \"in_memory_buffer\";\n\t    if (!xmlStrEqual(schemaLocation,\n\t\tbkt->schemaLocation)) {\n\t\txmlSchemaCustomErr(ACTXT_CAST pctxt, err,\n\t\t    invokingNode, NULL,\n\t\t    \"The schema document '%s' cannot be included or \"\n\t\t    \"redefined, since it was already imported\",\n\t\t    schemaLocation, NULL);\n\t\tgoto exit;\n\t    }\n\t}\n    }\n\n    if (WXS_IS_BUCKET_IMPMAIN(type)) {\n\t/*\n\t* Given that the schemaLocation [attribute] is only a hint, it is open\n\t* to applications to ignore all but the first <import> for a given\n\t* namespace, regardless of the `actual value` of schemaLocation, but\n\t* such a strategy risks missing useful information when new\n\t* schemaLocations are offered.\n\t*\n\t* We will use the first <import> that comes with a location.\n\t* Further <import>s *with* a location, will result in an error.\n\t* TODO: Better would be to just report a warning here, but\n\t* we'll try it this way until someone complains.\n\t*\n\t* Schema Document Location Strategy:\n\t* 3 Based on the namespace name, identify an existing schema document,\n\t* either as a resource which is an XML document or a <schema> element\n\t* information item, in some local schema repository;\n\t* 5 Attempt to resolve the namespace name to locate such a resource.\n\t*\n\t* NOTE: (3) and (5) are not supported.\n\t*/\n\tif (bkt != NULL) {\n\t    relation->bucket = bkt;\n\t    goto exit;\n\t}\n\tbkt = xmlSchemaGetSchemaBucketByTNS(pctxt,\n\t    importNamespace, 1);\n\n\tif (bkt != NULL) {\n\t    relation->bucket = bkt;\n\t    if (bkt->schemaLocation == NULL) {\n\t\t/* First given location of the schema; load the doc. */\n\t\tbkt->schemaLocation = schemaLocation;\n\t    } else {\n\t\tif (!xmlStrEqual(schemaLocation,\n\t\t    bkt->schemaLocation)) {\n\t\t    /*\n\t\t    * Additional location given; just skip it.\n\t\t    * URGENT TODO: We should report a warning here.\n\t\t    * res = XML_SCHEMAP_SRC_IMPORT;\n\t\t    */\n\t\t    if (schemaLocation == NULL)\n\t\t\tschemaLocation = BAD_CAST \"in_memory_buffer\";\n\n\t\t    xmlSchemaCustomWarning(ACTXT_CAST pctxt,\n\t\t\tXML_SCHEMAP_WARN_SKIP_SCHEMA,\n\t\t\tinvokingNode, NULL,\n\t\t\t\"Skipping import of schema located at '%s' for the \"\n\t\t\t\"namespace '%s', since this namespace was already \"\n\t\t\t\"imported with the schema located at '%s'\",\n\t\t\tschemaLocation, importNamespace, bkt->schemaLocation);\n\t\t}\n\t\tgoto exit;\n\t    }\n\t}\n\t/*\n\t* No bucket + first location: load the doc and create a\n\t* bucket.\n\t*/\n    } else {\n\t/* <include> and <redefine> */\n\tif (bkt != NULL) {\n\n\t    if ((bkt->origTargetNamespace == NULL) &&\n\t\t(bkt->targetNamespace != sourceTargetNamespace)) {\n\t\txmlSchemaBucketPtr chamel;\n\n\t\t/*\n\t\t* Chameleon include/redefine: skip loading only if it was\n\t\t* already build for the targetNamespace of the including\n\t\t* schema.\n\t\t*/\n\t\t/*\n\t\t* URGENT TODO: If the schema is a chameleon-include then copy\n\t\t* the components into the including schema and modify the\n\t\t* targetNamespace of those components, do nothing otherwise.\n\t\t* NOTE: This is currently worked-around by compiling the\n\t\t* chameleon for every distinct including targetNamespace; thus\n\t\t* not performant at the moment.\n\t\t* TODO: Check when the namespace in wildcards for chameleons\n\t\t* needs to be converted: before we built wildcard intersections\n\t\t* or after.\n\t\t*   Answer: after!\n\t\t*/\n\t\tchamel = xmlSchemaGetChameleonSchemaBucket(pctxt,\n\t\t    schemaLocation, sourceTargetNamespace);\n\t\tif (chamel != NULL) {\n\t\t    /* A fitting chameleon was already parsed; NOP. */\n\t\t    relation->bucket = chamel;\n\t\t    goto exit;\n\t\t}\n\t\t/*\n\t\t* We need to parse the chameleon again for a different\n\t\t* targetNamespace.\n\t\t* CHAMELEON TODO: Optimize this by only parsing the\n\t\t* chameleon once, and then copying the components to\n\t\t* the new targetNamespace.\n\t\t*/\n\t\tbkt = NULL;\n\t    } else {\n\t\trelation->bucket = bkt;\n\t\tgoto exit;\n\t    }\n\t}\n    }\n    if ((bkt != NULL) && (bkt->doc != NULL)) {\n\tPERROR_INT(\"xmlSchemaAddSchemaDoc\",\n\t    \"trying to load a schema doc, but a doc is already \"\n\t    \"assigned to the schema bucket\");\n\tgoto exit_failure;\n    }\n\ndoc_load:\n    /*\n    * Load the document.\n    */\n    if (schemaDoc != NULL) {\n\tdoc = schemaDoc;\n\t/* Don' free this one, since it was provided by the caller. */\n\tpreserveDoc = 1;\n\t/* TODO: Does the context or the doc hold the location? */\n\tif (schemaDoc->URL != NULL)\n\t    schemaLocation = xmlDictLookup(pctxt->dict,\n\t\tschemaDoc->URL, -1);\n        else\n\t    schemaLocation = BAD_CAST \"in_memory_buffer\";\n    } else if ((schemaLocation != NULL) || (schemaBuffer != NULL)) {\n\txmlParserCtxtPtr parserCtxt;\n\n\tparserCtxt = xmlNewParserCtxt();\n\tif (parserCtxt == NULL) {\n\t    xmlSchemaPErrMemory(NULL, \"xmlSchemaGetDoc, \"\n\t\t\"allocating a parser context\", NULL);\n\t    goto exit_failure;\n\t}\n\tif ((pctxt->dict != NULL) && (parserCtxt->dict != NULL)) {\n\t    /*\n\t    * TODO: Do we have to burden the schema parser dict with all\n\t    * the content of the schema doc?\n\t    */\n\t    xmlDictFree(parserCtxt->dict);\n\t    parserCtxt->dict = pctxt->dict;\n\t    xmlDictReference(parserCtxt->dict);\n\t}\n\tif (schemaLocation != NULL) {\n\t    /* Parse from file. */\n\t    doc = xmlCtxtReadFile(parserCtxt, (const char *) schemaLocation,\n\t\tNULL, SCHEMAS_PARSE_OPTIONS);\n\t} else if (schemaBuffer != NULL) {\n\t    /* Parse from memory buffer. */\n\t    doc = xmlCtxtReadMemory(parserCtxt, schemaBuffer, schemaBufferLen,\n\t\tNULL, NULL, SCHEMAS_PARSE_OPTIONS);\n\t    schemaLocation = BAD_CAST \"in_memory_buffer\";\n\t    if (doc != NULL)\n\t\tdoc->URL = xmlStrdup(schemaLocation);\n\t}\n\t/*\n\t* For <import>:\n\t* 2.1 The referent is (a fragment of) a resource which is an\n\t* XML document (see clause 1.1), which in turn corresponds to\n\t* a <schema> element information item in a well-formed information\n\t* set, which in turn corresponds to a valid schema.\n\t* TODO: (2.1) fragments of XML documents are not supported.\n\t*\n\t* 2.2 The referent is a <schema> element information item in\n\t* a well-formed information set, which in turn corresponds\n\t* to a valid schema.\n\t* TODO: (2.2) is not supported.\n\t*/\n\tif (doc == NULL) {\n\t    const xmlError *lerr;\n\t    lerr = xmlGetLastError();\n\t    /*\n\t    * Check if this a parser error, or if the document could\n\t    * just not be located.\n\t    * TODO: Try to find specific error codes to react only on\n\t    * localisation failures.\n\t    */\n\t    if ((lerr == NULL) || (lerr->domain != XML_FROM_IO)) {\n\t\t/*\n\t\t* We assume a parser error here.\n\t\t*/\n\t\tlocated = 1;\n\t\t/* TODO: Error code ?? */\n\t\tres = XML_SCHEMAP_SRC_IMPORT_2_1;\n\t\txmlSchemaCustomErr(ACTXT_CAST pctxt, res,\n\t\t    invokingNode, NULL,\n\t\t    \"Failed to parse the XML resource '%s'\",\n\t\t    schemaLocation, NULL);\n\t    }\n\t}\n\txmlFreeParserCtxt(parserCtxt);\n\tif ((doc == NULL) && located)\n\t    goto exit_error;\n    } else {\n\txmlSchemaPErr(pctxt, NULL,\n\t    XML_SCHEMAP_NOTHING_TO_PARSE,\n\t    \"No information for parsing was provided with the \"\n\t    \"given schema parser context.\\n\",\n\t    NULL, NULL);\n\tgoto exit_failure;\n    }\n    /*\n    * Preprocess the document.\n    */\n    if (doc != NULL) {\n\txmlNodePtr docElem = NULL;\n\n\tlocated = 1;\n\tdocElem = xmlDocGetRootElement(doc);\n\tif (docElem == NULL) {\n\t    xmlSchemaCustomErr(ACTXT_CAST pctxt, XML_SCHEMAP_NOROOT,\n\t\tinvokingNode, NULL,\n\t\t\"The document '%s' has no document element\",\n\t\tschemaLocation, NULL);\n\t    goto exit_error;\n\t}\n\t/*\n\t* Remove all the blank text nodes.\n\t*/\n\txmlSchemaCleanupDoc(pctxt, docElem);\n\t/*\n\t* Check the schema's top level element.\n\t*/\n\tif (!IS_SCHEMA(docElem, \"schema\")) {\n\t    xmlSchemaCustomErr(ACTXT_CAST pctxt, XML_SCHEMAP_NOT_SCHEMA,\n\t\tinvokingNode, NULL,\n\t\t\"The XML document '%s' is not a schema document\",\n\t\tschemaLocation, NULL);\n\t    goto exit_error;\n\t}\n\t/*\n\t* Note that we don't apply a type check for the\n\t* targetNamespace value here.\n\t*/\n\ttargetNamespace = xmlSchemaGetProp(pctxt, docElem,\n\t    \"targetNamespace\");\n    }\n\n/* after_doc_loading: */\n    if ((bkt == NULL) && located) {\n\t/* Only create a bucket if the schema was located. */\n        bkt = xmlSchemaBucketCreate(pctxt, type,\n\t    targetNamespace);\n\tif (bkt == NULL)\n\t    goto exit_failure;\n    }\n    if (bkt != NULL) {\n\tbkt->schemaLocation = schemaLocation;\n\tbkt->located = located;\n\tif (doc != NULL) {\n\t    bkt->doc = doc;\n\t    bkt->targetNamespace = targetNamespace;\n\t    bkt->origTargetNamespace = targetNamespace;\n\t    if (preserveDoc)\n\t\tbkt->preserveDoc = 1;\n\t}\n\tif (WXS_IS_BUCKET_IMPMAIN(type))\n\t    bkt->imported++;\n\t    /*\n\t    * Add it to the graph of schemas.\n\t    */\n\tif (relation != NULL)\n\t    relation->bucket = bkt;\n    }\n\nexit:\n    /*\n    * Return the bucket explicitly; this is needed for the\n    * main schema.\n    */\n    if (bucket != NULL)\n\t*bucket = bkt;\n    return (0);\n\nexit_error:\n    if ((doc != NULL) && (! preserveDoc)) {\n\txmlFreeDoc(doc);\n\tif (bkt != NULL)\n\t    bkt->doc = NULL;\n    }\n    return(pctxt->err);\n\nexit_failure:\n    if ((doc != NULL) && (! preserveDoc)) {\n\txmlFreeDoc(doc);\n\tif (bkt != NULL)\n\t    bkt->doc = NULL;\n    }\n    return (-1);\n}\n\nxmlSchemaPtr\nxmlSchemaParse(xmlSchemaParserCtxtPtr ctxt)\n{\n    xmlSchemaPtr mainSchema = NULL;\n    xmlSchemaBucketPtr bucket = NULL;\n    int res;\n\n    /*\n    * This one is used if the schema to be parsed was specified via\n    * the API; i.e. not automatically by the validated instance document.\n    */\n\n    if (xmlSchemaInitTypes() < 0)\n        return (NULL);\n\n    if (ctxt == NULL)\n        return (NULL);\n\n    /* TODO: Init the context. Is this all we need?*/\n    ctxt->nberrors = 0;\n    ctxt->err = 0;\n    ctxt->counter = 0;\n\n    /* Create the *main* schema. */\n    mainSchema = xmlSchemaNewSchema(ctxt);\n    if (mainSchema == NULL)\n\tgoto exit_failure;\n    /*\n    * Create the schema constructor.\n    */\n    if (ctxt->constructor == NULL) {\n\tctxt->constructor = xmlSchemaConstructionCtxtCreate(ctxt->dict);\n\tif (ctxt->constructor == NULL)\n\t    goto exit_failure;\n\t/* Take ownership of the constructor to be able to free it. */\n\tctxt->ownsConstructor = 1;\n    }\n    ctxt->constructor->mainSchema = mainSchema;\n    /*\n    * Locate and add the schema document.\n    */\n    res = xmlSchemaAddSchemaDoc(ctxt, XML_SCHEMA_SCHEMA_MAIN,\n\tctxt->URL, ctxt->doc, ctxt->buffer, ctxt->size, NULL,\n\tNULL, NULL, &bucket);\n    if (res == -1)\n\tgoto exit_failure;\n    if (res != 0)\n\tgoto exit;\n\n    if (bucket == NULL) {\n\t/* TODO: Error code, actually we failed to *locate* the schema. */\n\tif (ctxt->URL)\n\t    xmlSchemaCustomErr(ACTXT_CAST ctxt, XML_SCHEMAP_FAILED_LOAD,\n\t\tNULL, NULL,\n\t\t\"Failed to locate the main schema resource at '%s'\",\n\t\tctxt->URL, NULL);\n\telse\n\t    xmlSchemaCustomErr(ACTXT_CAST ctxt, XML_SCHEMAP_FAILED_LOAD,\n\t\tNULL, NULL,\n\t\t\"Failed to locate the main schema resource\",\n\t\t    NULL, NULL);\n\tgoto exit;\n    }\n    /* Then do the parsing for good. */\n    if (xmlSchemaParseNewDocWithContext(ctxt, mainSchema, bucket) == -1)\n\tgoto exit_failure;\n    if (ctxt->nberrors != 0)\n\tgoto exit;\n\n    mainSchema->doc = bucket->doc;\n    mainSchema->preserve = ctxt->preserve;\n\n    ctxt->schema = mainSchema;\n\n    if (xmlSchemaFixupComponents(ctxt, WXS_CONSTRUCTOR(ctxt)->mainBucket) == -1)\n\tgoto exit_failure;\n\n    /*\n    * TODO: This is not nice, since we cannot distinguish from the\n    * result if there was an internal error or not.\n    */\nexit:\n    if (ctxt->nberrors != 0) {\n\tif (mainSchema) {\n\t    xmlSchemaFree(mainSchema);\n\t    mainSchema = NULL;\n\t}\n\tif (ctxt->constructor) {\n\t    xmlSchemaConstructionCtxtFree(ctxt->constructor);\n\t    ctxt->constructor = NULL;\n\t    ctxt->ownsConstructor = 0;\n\t}\n    }\n    ctxt->schema = NULL;\n    return(mainSchema);\nexit_failure:\n    /*\n    * Quite verbose, but should catch internal errors, which were\n    * not communicated.\n    */\n    if (mainSchema) {\n        xmlSchemaFree(mainSchema);\n\tmainSchema = NULL;\n    }\n    if (ctxt->constructor) {\n\txmlSchemaConstructionCtxtFree(ctxt->constructor);\n\tctxt->constructor = NULL;\n\tctxt->ownsConstructor = 0;\n    }\n    PERROR_INT2(\"xmlSchemaParse\",\n\t\"An internal error occurred\");\n    ctxt->schema = NULL;\n    return(NULL);\n}\n\n\n// target function\nvoid\nxmlParseComment(xmlParserCtxtPtr ctxt) {\n    xmlChar *buf = NULL;\n    size_t size = XML_PARSER_BUFFER_SIZE;\n    size_t len = 0;\n    size_t maxLength = (ctxt->options & XML_PARSE_HUGE) ?\n                       XML_MAX_HUGE_LENGTH :\n                       XML_MAX_TEXT_LENGTH;\n    xmlParserInputState state;\n    const xmlChar *in;\n    size_t nbchar = 0;\n    int ccol;\n    int inputid;\n\n    /*\n     * Check that there is a comment right here.\n     */\n    if ((RAW != '<') || (NXT(1) != '!'))\n        return;\n    SKIP(2);\n    if ((RAW != '-') || (NXT(1) != '-'))\n        return;\n    state = ctxt->instate;\n    ctxt->instate = XML_PARSER_COMMENT;\n    inputid = ctxt->input->id;\n    SKIP(2);\n    GROW;\n\n    /*\n     * Accelerated common case where input don't need to be\n     * modified before passing it to the handler.\n     */\n    in = ctxt->input->cur;\n    do {\n\tif (*in == 0xA) {\n\t    do {\n\t\tctxt->input->line++; ctxt->input->col = 1;\n\t\tin++;\n\t    } while (*in == 0xA);\n\t}\nget_more:\n        ccol = ctxt->input->col;\n\twhile (((*in > '-') && (*in <= 0x7F)) ||\n\t       ((*in >= 0x20) && (*in < '-')) ||\n\t       (*in == 0x09)) {\n\t\t    in++;\n\t\t    ccol++;\n\t}\n\tctxt->input->col = ccol;\n\tif (*in == 0xA) {\n\t    do {\n\t\tctxt->input->line++; ctxt->input->col = 1;\n\t\tin++;\n\t    } while (*in == 0xA);\n\t    goto get_more;\n\t}\n\tnbchar = in - ctxt->input->cur;\n\t/*\n\t * save current set of data\n\t */\n\tif (nbchar > 0) {\n\t    if ((ctxt->sax != NULL) &&\n                (ctxt->disableSAX == 0) &&\n\t\t(ctxt->sax->comment != NULL)) {\n\t\tif (buf == NULL) {\n\t\t    if ((*in == '-') && (in[1] == '-'))\n\t\t        size = nbchar + 1;\n\t\t    else\n\t\t        size = XML_PARSER_BUFFER_SIZE + nbchar;\n\t\t    buf = (xmlChar *) xmlMallocAtomic(size);\n\t\t    if (buf == NULL) {\n\t\t        xmlErrMemory(ctxt, NULL);\n\t\t\tctxt->instate = state;\n\t\t\treturn;\n\t\t    }\n\t\t    len = 0;\n\t\t} else if (len + nbchar + 1 >= size) {\n\t\t    xmlChar *new_buf;\n\t\t    size  += len + nbchar + XML_PARSER_BUFFER_SIZE;\n\t\t    new_buf = (xmlChar *) xmlRealloc(buf, size);\n\t\t    if (new_buf == NULL) {\n\t\t        xmlFree (buf);\n\t\t\txmlErrMemory(ctxt, NULL);\n\t\t\tctxt->instate = state;\n\t\t\treturn;\n\t\t    }\n\t\t    buf = new_buf;\n\t\t}\n\t\tmemcpy(&buf[len], ctxt->input->cur, nbchar);\n\t\tlen += nbchar;\n\t\tbuf[len] = 0;\n\t    }\n\t}\n        if (len > maxLength) {\n            xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,\n                         \"Comment too big found\", NULL);\n            xmlFree (buf);\n            return;\n        }\n\tctxt->input->cur = in;\n\tif (*in == 0xA) {\n\t    in++;\n\t    ctxt->input->line++; ctxt->input->col = 1;\n\t}\n\tif (*in == 0xD) {\n\t    in++;\n\t    if (*in == 0xA) {\n\t\tctxt->input->cur = in;\n\t\tin++;\n\t\tctxt->input->line++; ctxt->input->col = 1;\n\t\tgoto get_more;\n\t    }\n\t    in--;\n\t}\n\tSHRINK;\n\tGROW;\n        if (ctxt->instate == XML_PARSER_EOF) {\n            xmlFree(buf);\n            return;\n        }\n\tin = ctxt->input->cur;\n\tif (*in == '-') {\n\t    if (in[1] == '-') {\n\t        if (in[2] == '>') {\n\t\t    if (ctxt->input->id != inputid) {\n\t\t\txmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n\t\t\t               \"comment doesn't start and stop in the\"\n                                       \" same entity\\n\");\n\t\t    }\n\t\t    SKIP(3);\n\t\t    if ((ctxt->sax != NULL) && (ctxt->sax->comment != NULL) &&\n\t\t        (!ctxt->disableSAX)) {\n\t\t\tif (buf != NULL)\n\t\t\t    ctxt->sax->comment(ctxt->userData, buf);\n\t\t\telse\n\t\t\t    ctxt->sax->comment(ctxt->userData, BAD_CAST \"\");\n\t\t    }\n\t\t    if (buf != NULL)\n\t\t        xmlFree(buf);\n\t\t    if (ctxt->instate != XML_PARSER_EOF)\n\t\t\tctxt->instate = state;\n\t\t    return;\n\t\t}\n\t\tif (buf != NULL) {\n\t\t    xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,\n\t\t                      \"Double hyphen within comment: \"\n                                      \"<!--%.50s\\n\",\n\t\t\t\t      buf);\n\t\t} else\n\t\t    xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,\n\t\t                      \"Double hyphen within comment\\n\", NULL);\n                if (ctxt->instate == XML_PARSER_EOF) {\n                    xmlFree(buf);\n                    return;\n                }\n\t\tin++;\n\t\tctxt->input->col++;\n\t    }\n\t    in++;\n\t    ctxt->input->col++;\n\t    goto get_more;\n\t}\n    } while (((*in >= 0x20) && (*in <= 0x7F)) || (*in == 0x09) || (*in == 0x0a));\n    xmlParseCommentComplex(ctxt, buf, len, size);\n    ctxt->instate = state;\n    return;\n}\n",
    "target": 1,
    "idx": 1063127,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic int parse_file_extra_owner(struct archive_read* a,\n        struct archive_entry* e, ssize_t* extra_data_size)\n{\n\tuint64_t flags = 0;\n\tuint64_t value_size = 0;\n\tuint64_t id = 0;\n\tsize_t name_len = 0;\n\tsize_t name_size = 0;\n\tchar namebuf[OWNER_MAXNAMELEN];\n\tconst uint8_t* p;\n\n\tif(!read_var(a, &flags, &value_size))\n\t\treturn ARCHIVE_EOF;\n\tif(ARCHIVE_OK != consume(a, (int64_t)value_size))\n\t\treturn ARCHIVE_EOF;\n\t*extra_data_size -= value_size;\n\n\tif ((flags & OWNER_USER_NAME) != 0) {\n\t\tif(!read_var_sized(a, &name_size, NULL))\n\t\t\treturn ARCHIVE_EOF;\n\t        *extra_data_size -= name_size + 1;\n\t\tif(!read_ahead(a, name_size, &p))\n\t\t\treturn ARCHIVE_EOF;\n\t\tif (name_size >= OWNER_MAXNAMELEN)\n\t\t\tname_len = OWNER_MAXNAMELEN - 1;\n\t\telse\n\t\t\tname_len = name_size;\n\t\tmemcpy(namebuf, p, name_len);\n\t\tnamebuf[name_len] = 0;\n\t\tif(ARCHIVE_OK != consume(a, (int64_t)name_size))\n\t\t\treturn ARCHIVE_EOF;\n\n\t\tarchive_entry_set_uname(e, namebuf);\n\t}\n\tif ((flags & OWNER_GROUP_NAME) != 0) {\n\t\tif(!read_var_sized(a, &name_size, NULL))\n\t\t\treturn ARCHIVE_EOF;\n\t        *extra_data_size -= name_size + 1;\n\t\tif(!read_ahead(a, name_size, &p))\n\t\t\treturn ARCHIVE_EOF;\n\t\tif (name_size >= OWNER_MAXNAMELEN)\n\t\t\tname_len = OWNER_MAXNAMELEN - 1;\n\t\telse\n\t\t\tname_len = name_size;\n\t\tmemcpy(namebuf, p, name_len);\n\t\tnamebuf[name_len] = 0;\n\t\tif(ARCHIVE_OK != consume(a, (int64_t)name_size))\n\t\t\treturn ARCHIVE_EOF;\n\n\t\tarchive_entry_set_gname(e, namebuf);\n\t}\n\tif ((flags & OWNER_USER_UID) != 0) {\n\t\tif(!read_var(a, &id, &value_size))\n\t\t\treturn ARCHIVE_EOF;\n\t\tif(ARCHIVE_OK != consume(a, (int64_t)value_size))\n\t\t\treturn ARCHIVE_EOF;\n\t\t*extra_data_size -= value_size;\n\n\t\tarchive_entry_set_uid(e, (la_int64_t)id);\n\t}\n\tif ((flags & OWNER_GROUP_GID) != 0) {\n\t\tif(!read_var(a, &id, &value_size))\n\t\t\treturn ARCHIVE_EOF;\n\t\tif(ARCHIVE_OK != consume(a, (int64_t)value_size))\n\t\t\treturn ARCHIVE_EOF;\n\t\t*extra_data_size -= value_size;\n\n\t\tarchive_entry_set_gid(e, (la_int64_t)id);\n\t}\n\treturn ARCHIVE_OK;\n}\n\nstatic int process_head_file_extra(struct archive_read* a,\n        struct archive_entry* e, struct rar5* rar,\n        ssize_t extra_data_size)\n{\n    size_t extra_field_size;\n    size_t extra_field_id = 0;\n    int ret = ARCHIVE_FATAL;\n    size_t var_size;\n\n    while(extra_data_size > 0) {\n        if(!read_var_sized(a, &extra_field_size, &var_size))\n            return ARCHIVE_EOF;\n\n        extra_data_size -= var_size;\n        if(ARCHIVE_OK != consume(a, var_size)) {\n            return ARCHIVE_EOF;\n        }\n\n        if(!read_var_sized(a, &extra_field_id, &var_size))\n            return ARCHIVE_EOF;\n\n        extra_data_size -= var_size;\n        if(ARCHIVE_OK != consume(a, var_size)) {\n            return ARCHIVE_EOF;\n        }\n\n        switch(extra_field_id) {\n            case EX_HASH:\n                ret = parse_file_extra_hash(a, rar, &extra_data_size);\n                break;\n            case EX_HTIME:\n                ret = parse_file_extra_htime(a, e, rar, &extra_data_size);\n                break;\n            case EX_REDIR:\n\t\tret = parse_file_extra_redir(a, e, rar, &extra_data_size);\n\t\tbreak;\n            case EX_UOWNER:\n\t\tret = parse_file_extra_owner(a, e, &extra_data_size);\n\t\tbreak;\n            case EX_CRYPT:\n                /* fallthrough */\n            case EX_VERSION:\n                /* fallthrough */\n            case EX_SUBDATA:\n                /* fallthrough */\n            default:\n                archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                        \"Unknown extra field in file/service block: 0x%x\",\n                        (int) extra_field_id);\n                return ARCHIVE_FATAL;\n        }\n    }\n\n    if(ret != ARCHIVE_OK) {\n        /* Attribute not implemented. */\n        return ret;\n    }\n\n    return ARCHIVE_OK;\n}\n\nstatic int process_head_file_extra(struct archive_read* a,\n        struct archive_entry* e, struct rar5* rar,\n        ssize_t extra_data_size)\n{\n    size_t extra_field_size;\n    size_t extra_field_id = 0;\n    int ret = ARCHIVE_FATAL;\n    size_t var_size;\n\n    while(extra_data_size > 0) {\n        if(!read_var_sized(a, &extra_field_size, &var_size))\n            return ARCHIVE_EOF;\n\n        extra_data_size -= var_size;\n        if(ARCHIVE_OK != consume(a, var_size)) {\n            return ARCHIVE_EOF;\n        }\n\n        if(!read_var_sized(a, &extra_field_id, &var_size))\n            return ARCHIVE_EOF;\n\n        extra_data_size -= var_size;\n        if(ARCHIVE_OK != consume(a, var_size)) {\n            return ARCHIVE_EOF;\n        }\n\n        switch(extra_field_id) {\n            case EX_HASH:\n                ret = parse_file_extra_hash(a, rar, &extra_data_size);\n                break;\n            case EX_HTIME:\n                ret = parse_file_extra_htime(a, e, rar, &extra_data_size);\n                break;\n            case EX_REDIR:\n\t\tret = parse_file_extra_redir(a, e, rar, &extra_data_size);\n\t\tbreak;\n            case EX_UOWNER:\n\t\tret = parse_file_extra_owner(a, e, &extra_data_size);\n\t\tbreak;\n            case EX_CRYPT:\n                /* fallthrough */\n            case EX_VERSION:\n                /* fallthrough */\n            case EX_SUBDATA:\n                /* fallthrough */\n            default:\n                archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                        \"Unknown extra field in file/service block: 0x%x\",\n                        (int) extra_field_id);\n                return ARCHIVE_FATAL;\n        }\n    }\n\n    if(ret != ARCHIVE_OK) {\n        /* Attribute not implemented. */\n        return ret;\n    }\n\n    return ARCHIVE_OK;\n}\n\nstatic int process_head_service(struct archive_read* a, struct rar5* rar,\n        struct archive_entry* entry, size_t block_flags)\n{\n    /* Process this SERVICE block the same way as FILE blocks. */\n    int ret = process_head_file(a, rar, entry, block_flags);\n    if(ret != ARCHIVE_OK)\n        return ret;\n\n    rar->file.service = 1;\n\n    /* But skip the data part automatically. It's no use for the user anyway.\n     * It contains only service data, not even needed to properly unpack the\n     * file. */\n    ret = rar5_read_data_skip(a);\n    if(ret != ARCHIVE_OK)\n        return ret;\n\n    /* After skipping, try parsing another block automatically. */\n    return ARCHIVE_RETRY;\n}\n\n\n\nstatic int rar5_read_header(struct archive_read *a,\n        struct archive_entry *entry)\n{\n    struct rar5* rar = get_context(a);\n    int ret;\n\n    if(rar->header_initialized == 0) {\n        init_header(a);\n        rar->header_initialized = 1;\n    }\n\n    if(rar->skipped_magic == 0) {\n        if(ARCHIVE_OK != consume(a, rar5_signature_size)) {\n            return ARCHIVE_EOF;\n        }\n\n        rar->skipped_magic = 1;\n    }\n\n    do {\n        ret = process_base_block(a, entry);\n    } while(ret == ARCHIVE_RETRY ||\n            (rar->main.endarc > 0 && ret == ARCHIVE_OK));\n\n    return ret;\n}\n\nstatic int\n_archive_read_next_header2(struct archive *_a, struct archive_entry *entry)\n{\n\tstruct archive_read *a = (struct archive_read *)_a;\n\tint r1 = ARCHIVE_OK, r2;\n\n\tarchive_check_magic(_a, ARCHIVE_READ_MAGIC,\n\t    ARCHIVE_STATE_HEADER | ARCHIVE_STATE_DATA,\n\t    \"archive_read_next_header\");\n\n\tarchive_entry_clear(entry);\n\tarchive_clear_error(&a->archive);\n\n\t/*\n\t * If client didn't consume entire data, skip any remainder\n\t * (This is especially important for GNU incremental directories.)\n\t */\n\tif (a->archive.state == ARCHIVE_STATE_DATA) {\n\t\tr1 = archive_read_data_skip(&a->archive);\n\t\tif (r1 == ARCHIVE_EOF)\n\t\t\tarchive_set_error(&a->archive, EIO,\n\t\t\t    \"Premature end-of-file.\");\n\t\tif (r1 == ARCHIVE_EOF || r1 == ARCHIVE_FATAL) {\n\t\t\ta->archive.state = ARCHIVE_STATE_FATAL;\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t}\n\n\t/* Record start-of-header offset in uncompressed stream. */\n\ta->header_position = a->filter->position;\n\n\t++_a->file_count;\n\tr2 = (a->format->read_header)(a, entry);\n\n\t/*\n\t * EOF and FATAL are persistent at this layer.  By\n\t * modifying the state, we guarantee that future calls to\n\t * read a header or read data will fail.\n\t */\n\tswitch (r2) {\n\tcase ARCHIVE_EOF:\n\t\ta->archive.state = ARCHIVE_STATE_EOF;\n\t\t--_a->file_count;/* Revert a file counter. */\n\t\tbreak;\n\tcase ARCHIVE_OK:\n\t\ta->archive.state = ARCHIVE_STATE_DATA;\n\t\tbreak;\n\tcase ARCHIVE_WARN:\n\t\ta->archive.state = ARCHIVE_STATE_DATA;\n\t\tbreak;\n\tcase ARCHIVE_RETRY:\n\t\tbreak;\n\tcase ARCHIVE_FATAL:\n\t\ta->archive.state = ARCHIVE_STATE_FATAL;\n\t\tbreak;\n\t}\n\n\t__archive_reset_read_data(&a->archive);\n\n\ta->data_start_node = a->client.cursor;\n\t/* EOF always wins; otherwise return the worst error. */\n\treturn (r2 < r1 || r2 == ARCHIVE_EOF) ? r2 : r1;\n}\n\nstatic int\n_archive_read_next_header(struct archive *_a, struct archive_entry **entryp)\n{\n\tint ret;\n\tstruct archive_read *a = (struct archive_read *)_a;\n\t*entryp = NULL;\n\tret = _archive_read_next_header2(_a, a->entry);\n\t*entryp = a->entry;\n\treturn ret;\n}\n\n\n// target function\nstatic int parse_file_extra_owner(struct archive_read* a,\n        struct archive_entry* e, ssize_t* extra_data_size)\n{\n\tuint64_t flags = 0;\n\tuint64_t value_size = 0;\n\tuint64_t id = 0;\n\tsize_t name_len = 0;\n\tsize_t name_size = 0;\n\tchar namebuf[OWNER_MAXNAMELEN];\n\tconst uint8_t* p;\n\n\tif(!read_var(a, &flags, &value_size))\n\t\treturn ARCHIVE_EOF;\n\tif(ARCHIVE_OK != consume(a, (int64_t)value_size))\n\t\treturn ARCHIVE_EOF;\n\t*extra_data_size -= value_size;\n\n\tif ((flags & OWNER_USER_NAME) != 0) {\n\t\tif(!read_var_sized(a, &name_size, NULL))\n\t\t\treturn ARCHIVE_EOF;\n\t        *extra_data_size -= name_size + 1;\n\t\tif(!read_ahead(a, name_size, &p))\n\t\t\treturn ARCHIVE_EOF;\n\t\tif (name_size > OWNER_MAXNAMELEN)\n\t\t\tname_len = OWNER_MAXNAMELEN;\n\t\telse\n\t\t\tname_len = name_size;\n\t\tmemcpy(namebuf, p, name_len);\n\t\tnamebuf[name_len] = 0;\n\t\tif(ARCHIVE_OK != consume(a, (int64_t)name_size))\n\t\t\treturn ARCHIVE_EOF;\n\n\t\tarchive_entry_set_uname(e, namebuf);\n\t}\n\tif ((flags & OWNER_GROUP_NAME) != 0) {\n\t\tif(!read_var_sized(a, &name_size, NULL))\n\t\t\treturn ARCHIVE_EOF;\n\t        *extra_data_size -= name_size + 1;\n\t\tif(!read_ahead(a, name_size, &p))\n\t\t\treturn ARCHIVE_EOF;\n\t\tif (name_size > OWNER_MAXNAMELEN)\n\t\t\tname_len = OWNER_MAXNAMELEN;\n\t\telse\n\t\t\tname_len = name_size;\n\t\tmemcpy(namebuf, p, name_len);\n\t\tnamebuf[name_len] = 0;\n\t\tif(ARCHIVE_OK != consume(a, (int64_t)name_size))\n\t\t\treturn ARCHIVE_EOF;\n\n\t\tarchive_entry_set_gname(e, namebuf);\n\t}\n\tif ((flags & OWNER_USER_UID) != 0) {\n\t\tif(!read_var(a, &id, &value_size))\n\t\t\treturn ARCHIVE_EOF;\n\t\tif(ARCHIVE_OK != consume(a, (int64_t)value_size))\n\t\t\treturn ARCHIVE_EOF;\n\t\t*extra_data_size -= value_size;\n\n\t\tarchive_entry_set_uid(e, (la_int64_t)id);\n\t}\n\tif ((flags & OWNER_GROUP_GID) != 0) {\n\t\tif(!read_var(a, &id, &value_size))\n\t\t\treturn ARCHIVE_EOF;\n\t\tif(ARCHIVE_OK != consume(a, (int64_t)value_size))\n\t\t\treturn ARCHIVE_EOF;\n\t\t*extra_data_size -= value_size;\n\n\t\tarchive_entry_set_gid(e, (la_int64_t)id);\n\t}\n\treturn ARCHIVE_OK;\n}\n",
    "target": 1,
    "idx": 1014331,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "// context\nbool BitstreamRange::read(uint8_t* data, size_t n)\n{\n  if (!prepare_read(n)) {\n    return false;\n  }\n\n  auto istr = get_istream();\n  bool success = istr->read(data, n);\n\n  if (!success) {\n    set_eof_while_reading();\n  }\n\n  return success;\n}\n\nstatic bool read_plane_interleaved(BitstreamRange* range,\n                                   std::shared_ptr<HeifPixelImage> image, heif_channel channel,\n                                   int width, int height, int bit_depth, int comps)\n{\n  if (width <= 0 || height <= 0) {\n    return false;\n  }\n  if (std::numeric_limits<size_t>::max()/width/height/comps == 0) {\n    return false;\n  }\n  if (!range->prepare_read(static_cast<size_t>(width) * height * comps)) {\n    return false;\n  }\n  if (!image->add_plane(channel, width, height, bit_depth)) {\n    return false;\n  }\n  int stride;\n  uint8_t* plane = image->get_plane(channel, &stride);\n  assert(stride >= width * comps);\n  auto stream = range->get_istream();\n  for (int y = 0; y < height; y++, plane += stride) {\n    assert(stream->read(plane, width * comps));\n  }\n  return true;\n}\n\n\n// target function\nstatic bool read_plane(BitstreamRange* range,\n                       std::shared_ptr<HeifPixelImage> image, heif_channel channel,\n                       int width, int height, int bit_depth)\n{\n  if (width <= 0 || height <= 0) {\n    return false;\n  }\n  if (!range->prepare_read(static_cast<uint64_t>(width) * height)) {\n    return false;\n  }\n  if (!image->add_plane(channel, width, height, bit_depth)) {\n    return false;\n  }\n  int stride;\n  uint8_t* plane = image->get_plane(channel, &stride);\n  assert(stride >= width);\n  auto stream = range->get_istream();\n  for (int y = 0; y < height; y++, plane += stride) {\n    assert(stream->read(plane, width));\n  }\n  return true;\n}\nstatic bool read_plane_interleaved(BitstreamRange* range,\n                                   std::shared_ptr<HeifPixelImage> image, heif_channel channel,\n                                   int width, int height, int bit_depth, int comps)\n{\n  if (width <= 0 || height <= 0) {\n    return false;\n  }\n  if (!range->prepare_read(static_cast<uint64_t>(width) * height * comps)) {\n    return false;\n  }\n  if (!image->add_plane(channel, width, height, bit_depth)) {\n    return false;\n  }\n  int stride;\n  uint8_t* plane = image->get_plane(channel, &stride);\n  assert(stride >= width * comps);\n  auto stream = range->get_istream();\n  for (int y = 0; y < height; y++, plane += stride) {\n    assert(stream->read(plane, width * comps));\n  }\n  return true;\n}\n",
    "target": 1,
    "idx": 1059814,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic int MqttClient_DecodePacket(MqttClient* client, byte* rx_buf,\n    word32 rx_len, void *packet_obj, MqttPacketType* ppacket_type,\n    MqttQoS* ppacket_qos, word16* ppacket_id)\n{\n    int rc = MQTT_CODE_SUCCESS;\n    MqttPacket* header;\n    MqttPacketType packet_type;\n    MqttQoS packet_qos;\n    word16 packet_id = 0;\n#ifdef WOLFMQTT_V5\n    MqttProp* props = NULL;\n#endif\n\n    /* must have rx buffer with at least 2 byes for header */\n    if (rx_buf == NULL || rx_len < MQTT_PACKET_HEADER_MIN_SIZE) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    /* Decode header */\n    header = (MqttPacket*)rx_buf;\n    packet_type = (MqttPacketType)MQTT_PACKET_TYPE_GET(header->type_flags);\n    if (ppacket_type) {\n        *ppacket_type = packet_type;\n    }\n    packet_qos = (MqttQoS)MQTT_PACKET_FLAGS_GET_QOS(header->type_flags);\n    if (ppacket_qos) {\n        *ppacket_qos = packet_qos;\n    }\n\n    /* Decode packet specific data (if requested) */\n    if (ppacket_id || packet_obj) {\n        switch (packet_type) {\n        case MQTT_PACKET_TYPE_CONNECT_ACK:\n        {\n            MqttConnectAck connect_ack, *p_connect_ack = &connect_ack;\n            if (packet_obj) {\n                p_connect_ack = (MqttConnectAck*)packet_obj;\n            }\n            else {\n                XMEMSET(p_connect_ack, 0, sizeof(MqttConnectAck));\n            }\n        #ifdef WOLFMQTT_V5\n            p_connect_ack->protocol_level = client->protocol_level;\n        #endif\n            rc = MqttDecode_ConnectAck(rx_buf, rx_len, p_connect_ack);\n        #ifdef WOLFMQTT_V5\n            if (rc >= 0) {\n                props = p_connect_ack->props;\n            }\n        #endif\n            break;\n        }\n        case MQTT_PACKET_TYPE_PUBLISH:\n        {\n            MqttPublish publish, *p_publish = &publish;\n            if (packet_obj) {\n                p_publish = (MqttPublish*)packet_obj;\n            }\n            else {\n                XMEMSET(p_publish, 0, sizeof(MqttPublish));\n            }\n        #ifdef WOLFMQTT_V5\n            p_publish->protocol_level = client->protocol_level;\n        #endif\n            rc = MqttDecode_Publish(rx_buf, rx_len, p_publish);\n            if (rc >= 0) {\n                packet_id = p_publish->packet_id;\n            #ifdef WOLFMQTT_V5\n                props = p_publish->props;\n            #endif\n            }\n            break;\n        }\n        case MQTT_PACKET_TYPE_PUBLISH_ACK:\n        case MQTT_PACKET_TYPE_PUBLISH_REC:\n        case MQTT_PACKET_TYPE_PUBLISH_REL:\n        case MQTT_PACKET_TYPE_PUBLISH_COMP:\n        {\n            MqttPublishResp publish_resp, *p_publish_resp = &publish_resp;\n            if (packet_obj) {\n                p_publish_resp = (MqttPublishResp*)packet_obj;\n            }\n            else {\n                XMEMSET(p_publish_resp, 0, sizeof(MqttPublishResp));\n            }\n        #ifdef WOLFMQTT_V5\n                p_publish_resp->protocol_level = client->protocol_level;\n        #endif\n                rc = MqttDecode_PublishResp(rx_buf, rx_len, packet_type,\n                p_publish_resp);\n            if (rc >= 0) {\n                packet_id = p_publish_resp->packet_id;\n            #ifdef WOLFMQTT_V5\n                props = p_publish_resp->props;\n            #endif\n            }\n            break;\n        }\n        case MQTT_PACKET_TYPE_SUBSCRIBE_ACK:\n        {\n            MqttSubscribeAck subscribe_ack, *p_subscribe_ack = &subscribe_ack;\n            if (packet_obj) {\n                p_subscribe_ack = (MqttSubscribeAck*)packet_obj;\n            }\n            else {\n                XMEMSET(p_subscribe_ack, 0, sizeof(MqttSubscribeAck));\n            }\n        #ifdef WOLFMQTT_V5\n            p_subscribe_ack->protocol_level = client->protocol_level;\n        #endif\n            rc = MqttDecode_SubscribeAck(rx_buf, rx_len, p_subscribe_ack);\n            if (rc >= 0) {\n                packet_id = p_subscribe_ack->packet_id;\n            #ifdef WOLFMQTT_V5\n                props = p_subscribe_ack->props;\n            #endif\n            }\n            break;\n        }\n        case MQTT_PACKET_TYPE_UNSUBSCRIBE_ACK:\n        {\n            MqttUnsubscribeAck unsubscribe_ack,\n                               *p_unsubscribe_ack = &unsubscribe_ack;\n            if (packet_obj) {\n                p_unsubscribe_ack = (MqttUnsubscribeAck*)packet_obj;\n            }\n            else {\n                XMEMSET(p_unsubscribe_ack, 0, sizeof(MqttUnsubscribeAck));\n            }\n        #ifdef WOLFMQTT_V5\n            p_unsubscribe_ack->protocol_level = client->protocol_level;\n        #endif\n            rc = MqttDecode_UnsubscribeAck(rx_buf, rx_len, p_unsubscribe_ack);\n            if (rc >= 0) {\n                packet_id = p_unsubscribe_ack->packet_id;\n            #ifdef WOLFMQTT_V5\n                props = p_unsubscribe_ack->props;\n            #endif\n            }\n            break;\n        }\n        case MQTT_PACKET_TYPE_PING_RESP:\n        {\n            MqttPing ping, *p_ping = &ping;\n            if (packet_obj) {\n                p_ping = (MqttPing*)packet_obj;\n            }\n            else {\n                XMEMSET(p_ping, 0, sizeof(MqttPing));\n            }\n            rc = MqttDecode_Ping(rx_buf, rx_len, p_ping);\n            break;\n        }\n        case MQTT_PACKET_TYPE_AUTH:\n        {\n        #ifdef WOLFMQTT_V5\n            MqttAuth auth, *p_auth = &auth;\n            if (packet_obj) {\n                p_auth = (MqttAuth*)packet_obj;\n            }\n            else {\n                XMEMSET(p_auth, 0, sizeof(MqttAuth));\n            }\n            rc = MqttDecode_Auth(rx_buf, rx_len, p_auth);\n            if (rc >= 0) {\n                props = p_auth->props;\n            }\n        #else\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n        #endif /* WOLFMQTT_V5 */\n            break;\n        }\n        case MQTT_PACKET_TYPE_DISCONNECT:\n        {\n        #ifdef WOLFMQTT_V5\n            MqttDisconnect disc, *p_disc = &disc;\n            if (packet_obj) {\n                p_disc = (MqttDisconnect*)packet_obj;\n            }\n            else {\n                XMEMSET(p_disc, 0, sizeof(MqttDisconnect));\n            }\n            rc = MqttDecode_Disconnect(rx_buf, rx_len, p_disc);\n            if (rc >= 0) {\n                props = p_disc->props;\n            }\n        #else\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n        #endif /* WOLFMQTT_V5 */\n            break;\n        }\n        case MQTT_PACKET_TYPE_CONNECT:\n        case MQTT_PACKET_TYPE_SUBSCRIBE:\n        case MQTT_PACKET_TYPE_UNSUBSCRIBE:\n        case MQTT_PACKET_TYPE_PING_REQ:\n        case MQTT_PACKET_TYPE_ANY:\n        case MQTT_PACKET_TYPE_RESERVED:\n        default:\n            /* these type are only encoded by client */\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n            break;\n        } /* switch (packet_type) */\n    }\n\n    if (ppacket_id) {\n        *ppacket_id = packet_id;\n    }\n\n#ifdef WOLFMQTT_V5\n    if (props) {\n    #ifdef WOLFMQTT_PROPERTY_CB\n        /* Check for properties set by the server */\n        if (packet_obj && client->property_cb) {\n            /* capture error if returned */\n            int rc_err = client->property_cb(client, props,\n                    client->property_ctx);\n            if (rc_err < 0) {\n                rc = rc_err;\n            }\n        }\n    #endif\n        /* Free the properties */\n        MqttProps_Free(props);\n    }\n#endif\n\n    (void)client;\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"MqttClient_DecodePacket: Rc %d, Len %d, Type %s (%d), ID %d,\"\n            \" QoS %d\",\n        rc, rx_len, MqttPacket_TypeDesc(packet_type), packet_type, packet_id,\n        packet_qos);\n#endif\n\n    return rc;\n}\n\nstatic int MqttClient_HandlePacket(MqttClient* client,\n    MqttPacketType packet_type, void *packet_obj, int timeout_ms)\n{\n    int rc = MQTT_CODE_SUCCESS;\n    MqttQoS packet_qos = MQTT_QOS_0;\n    word16 packet_id = 0;\n\n    if (client == NULL || packet_obj == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    switch (packet_type)\n    {\n        case MQTT_PACKET_TYPE_CONNECT_ACK:\n        {\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, packet_obj, &packet_type, &packet_qos,\n                &packet_id);\n            break;\n        }\n        case MQTT_PACKET_TYPE_PUBLISH:\n        {\n            MqttPublish *publish = (MqttPublish*)packet_obj;\n            MqttPacketType resp_type;\n\n            if (publish->stat == MQTT_MSG_BEGIN ||\n                publish->stat == MQTT_MSG_READ) {\n                rc = MqttClient_DecodePacket(client, client->rx_buf,\n                    client->packet.buf_len, packet_obj, &packet_type,\n                    &packet_qos, &packet_id);\n                if (rc <= 0) {\n                    return rc;\n                }\n            }\n            else {\n                /* packet ID and QoS were already established */\n                packet_id = client->msg.publish.packet_id;\n                packet_qos = client->msg.publish.qos;\n            }\n\n            rc = MqttClient_Publish_ReadPayload(client, publish, timeout_ms);\n            if (rc < 0) {\n                break;\n            }\n\n            /* Handle QoS */\n            if (packet_qos == MQTT_QOS_0) {\n                /* we are done, no QoS response */\n                break;\n            }\n\n            /* Determine packet type to write */\n            resp_type = (packet_qos == MQTT_QOS_1) ?\n                MQTT_PACKET_TYPE_PUBLISH_ACK :\n                MQTT_PACKET_TYPE_PUBLISH_REC;\n            publish->resp.packet_id = packet_id;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Lock send socket mutex */\n            rc = wm_SemLock(&client->lockSend);\n            if (rc != 0) {\n                return rc;\n            }\n        #endif\n\n            /* Encode publish response */\n            rc = MqttEncode_PublishResp(client->tx_buf, client->tx_buf_len,\n                resp_type, &publish->resp);\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d), ID %d,\"\n                    \" QoS %d\",\n                rc, MqttPacket_TypeDesc(resp_type), resp_type, packet_id,\n                packet_qos);\n        #endif\n            if (rc <= 0) {\n            #ifdef WOLFMQTT_MULTITHREAD\n                wm_SemUnlock(&client->lockSend);\n            #endif\n                return rc;\n            }\n            client->packet.buf_len = rc;\n\n            /* Send publish response packet */\n            rc = MqttPacket_Write(client, client->tx_buf,\n                client->packet.buf_len);\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            wm_SemUnlock(&client->lockSend);\n        #endif\n            break;\n        }\n        case MQTT_PACKET_TYPE_PUBLISH_ACK:\n        case MQTT_PACKET_TYPE_PUBLISH_REC:\n        case MQTT_PACKET_TYPE_PUBLISH_REL:\n        case MQTT_PACKET_TYPE_PUBLISH_COMP:\n        {\n            MqttPublishResp pubRespObj, *publish_resp = &pubRespObj;\n            XMEMSET(publish_resp, 0, sizeof(MqttPublishResp));\n\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, publish_resp, &packet_type,\n                &packet_qos, &packet_id);\n            if (rc <= 0) {\n                return rc;\n            }\n\n            /* If publish Received or Release QoS then proceed */\n            if (packet_type != MQTT_PACKET_TYPE_PUBLISH_REC &&\n                packet_type != MQTT_PACKET_TYPE_PUBLISH_REL) {\n                break;\n            }\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Lock send socket mutex */\n            rc = wm_SemLock(&client->lockSend);\n            if (rc != 0) {\n                return rc;\n            }\n        #endif\n\n            /* Encode publish response */\n            publish_resp->packet_id = packet_id;\n            packet_type = (MqttPacketType)((int)packet_type+1); /* next ack */\n        #ifdef WOLFMQTT_V5\n            #ifdef WOLFMQTT_DEBUG_CLIENT\n                PRINTF(\"\\tPublish response: reason code %d, Type %s (%d),\"\n                        \" ID %d, QoS %d\",\n                        publish_resp->reason_code,\n                        MqttPacket_TypeDesc(packet_type),\n                        packet_type, packet_id, packet_qos);\n            #endif\n\n            /* return reason code to caller */\n            if (packet_obj != NULL) {\n                MqttPublishResp* caller_rsp = (MqttPublishResp*)packet_obj;\n                caller_rsp->reason_code = publish_resp->reason_code;\n            }\n\n            /* Publish QoS response needs success reason code,\n             * otherwise will cause disconnect at broker */\n            publish_resp->reason_code = MQTT_REASON_SUCCESS;\n        #endif\n\n            rc = MqttEncode_PublishResp(client->tx_buf, client->tx_buf_len,\n                packet_type, publish_resp);\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d), ID %d,\"\n                    \" QoS %d\",\n                rc, MqttPacket_TypeDesc(packet_type), packet_type, packet_id,\n                packet_qos);\n        #endif\n            if (rc <= 0) {\n            #ifdef WOLFMQTT_MULTITHREAD\n                wm_SemUnlock(&client->lockSend);\n            #endif\n                return rc;\n            }\n            client->packet.buf_len = rc;\n\n            /* Send publish response packet */\n            rc = MqttPacket_Write(client, client->tx_buf,\n                client->packet.buf_len);\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            wm_SemUnlock(&client->lockSend);\n        #endif\n            break;\n        }\n        case MQTT_PACKET_TYPE_SUBSCRIBE_ACK:\n        {\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, packet_obj, &packet_type, &packet_qos,\n                &packet_id);\n            break;\n        }\n        case MQTT_PACKET_TYPE_UNSUBSCRIBE_ACK:\n        {\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, packet_obj, &packet_type, &packet_qos,\n                &packet_id);\n            break;\n        }\n        case MQTT_PACKET_TYPE_PING_RESP:\n        {\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, packet_obj, &packet_type, &packet_qos,\n                &packet_id);\n            break;\n        }\n        case MQTT_PACKET_TYPE_AUTH:\n        {\n        #ifdef WOLFMQTT_V5\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, packet_obj, &packet_type, &packet_qos,\n                &packet_id);\n        #else\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n        #endif\n            break;\n        }\n\n        case MQTT_PACKET_TYPE_DISCONNECT:\n        {\n        #ifdef WOLFMQTT_V5\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, packet_obj, &packet_type, &packet_qos,\n                &packet_id);\n        #else\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n        #endif\n            break;\n        }\n        case MQTT_PACKET_TYPE_CONNECT:\n        case MQTT_PACKET_TYPE_SUBSCRIBE:\n        case MQTT_PACKET_TYPE_UNSUBSCRIBE:\n        case MQTT_PACKET_TYPE_PING_REQ:\n        case MQTT_PACKET_TYPE_ANY:\n        case MQTT_PACKET_TYPE_RESERVED:\n        default:\n            /* these types are only sent from client and should not be sent\n             * by broker */\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n            break;\n    } /* switch (packet_type) */\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    if (rc < 0) {\n        PRINTF(\"MqttClient_HandlePacket: Rc %d, Type %s (%d), QoS %d, ID %d\",\n            rc, MqttPacket_TypeDesc(packet_type), packet_type, packet_qos,\n            packet_id);\n    }\n#endif\n\n    return rc;\n}\n\nstatic int MqttClient_WaitType(MqttClient *client, void *packet_obj,\n    byte wait_type, word16 wait_packet_id, int timeout_ms)\n{\n    int rc;\n    word16 packet_id;\n    MqttPacketType packet_type;\n#ifdef WOLFMQTT_MULTITHREAD\n    MqttPendResp *pendResp;\n    int readLocked;\n#endif\n    MqttMsgStat* mms_stat;\n    int waitMatchFound;\n\n    if (client == NULL || packet_obj == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    /* all packet type structures must have MqttMsgStat at top */\n    mms_stat = (MqttMsgStat*)packet_obj;\n\nwait_again:\n\n    /* initialize variables */\n    packet_id = 0;\n    packet_type = MQTT_PACKET_TYPE_RESERVED;\n#ifdef WOLFMQTT_MULTITHREAD\n    pendResp = NULL;\n    readLocked = 0;\n#endif\n    waitMatchFound = 0;\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"MqttClient_WaitType: Type %s (%d), ID %d\",\n        MqttPacket_TypeDesc((MqttPacketType)wait_type),\n            wait_type, wait_packet_id);\n#endif\n\n    switch ((int)*mms_stat)\n    {\n        case MQTT_MSG_BEGIN:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Lock recv socket mutex */\n            rc = wm_SemLock(&client->lockRecv);\n            if (rc != 0) {\n                PRINTF(\"MqttClient_WaitType: recv lock error!\");\n                return rc;\n            }\n            readLocked = 1;\n        #endif\n\n            /* reset the packet state */\n            client->packet.stat = MQTT_PK_BEGIN;\n        }\n        FALL_THROUGH;\n\n    #ifdef WOLFMQTT_V5\n        case MQTT_MSG_AUTH:\n    #endif\n        case MQTT_MSG_WAIT:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if packet type and id have already completed */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, (MqttPacketType)wait_type, \n                    wait_packet_id, &pendResp)) {\n                    if (pendResp->packetDone) {\n                        /* pending response is already done, so return */\n                        rc = pendResp->packet_ret;\n                    #ifdef WOLFMQTT_DEBUG_CLIENT\n                        PRINTF(\"PendResp already Done %p: Rc %d\", pendResp, rc);\n                    #endif\n                        MqttClient_RespList_Remove(client, pendResp);\n                        wm_SemUnlock(&client->lockClient);\n                        wm_SemUnlock(&client->lockRecv);\n                        return rc;\n                    }\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            *mms_stat = MQTT_MSG_WAIT;\n\n            /* Wait for packet */\n            rc = MqttPacket_Read(client, client->rx_buf, client->rx_buf_len,\n                    timeout_ms);\n            /* handle failure */\n            if (rc <= 0) {\n                break;\n            }\n\n            /* capture length read */\n            client->packet.buf_len = rc;\n\n            /* Decode Packet - get type and id */\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, NULL, &packet_type, NULL, &packet_id);\n            if (rc < 0) {\n                break;\n            }\n\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"Read Packet: Len %d, Type %d, ID %d\",\n                client->packet.buf_len, packet_type, packet_id);\n        #endif\n\n            *mms_stat = MQTT_MSG_READ;\n        }\n        FALL_THROUGH;\n\n        case MQTT_MSG_READ:\n        case MQTT_MSG_READ_PAYLOAD:\n        {\n            MqttPacketType use_packet_type;\n            void* use_packet_obj;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            readLocked = 1; /* if in this state read is locked */\n        #endif\n\n            /* read payload state only happens for publish messages */\n            if (*mms_stat == MQTT_MSG_READ_PAYLOAD) {\n                packet_type = MQTT_PACKET_TYPE_PUBLISH;\n            }\n\n            /* Determine if we received data for this request */\n            if ((wait_type == MQTT_PACKET_TYPE_ANY ||\n                 wait_type == packet_type ||\n                 (MqttIsPubRespPacket(packet_type) &&\n                  MqttIsPubRespPacket(wait_type))) &&\n                (wait_packet_id == 0 || wait_packet_id == packet_id))\n            {\n                use_packet_obj = packet_obj;\n                waitMatchFound = 1;\n            }\n            else {\n                /* use generic packet object */\n                use_packet_obj = &client->msg;\n            }\n            use_packet_type = packet_type;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if we have a pending response for this packet */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, packet_type, packet_id,\n                                                               &pendResp)) {\n                    /* we found packet match this incoming read packet */\n                    pendResp->packetProcessing = 1;\n                    use_packet_obj = pendResp->packet_obj;\n                    use_packet_type = pendResp->packet_type;\n                    /* req from another thread... not a match */\n                    waitMatchFound = 0;\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            /* Perform packet handling for publish callback and QoS */\n            rc = MqttClient_HandlePacket(client, use_packet_type,\n                use_packet_obj, timeout_ms);\n\n        #ifdef WOLFMQTT_NONBLOCK\n            if (rc == MQTT_CODE_CONTINUE) {\n                /* we have received some data, so keep the recv\n                    mutex lock active and return */\n                return rc;\n            }\n        #endif\n\n            /* handle success case */\n            if (rc >= 0) {\n                rc = MQTT_CODE_SUCCESS;\n            }\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (pendResp) {\n                /* Mark pending response entry done */\n                if (wm_SemLock(&client->lockClient) == 0) {\n                    pendResp->packetDone = 1;\n                    pendResp->packet_ret = rc;\n                #ifdef WOLFMQTT_DEBUG_CLIENT\n                    PRINTF(\"PendResp Done %p\", pendResp);\n                #endif\n                    pendResp = NULL;\n                    wm_SemUnlock(&client->lockClient);\n                }\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n            break;\n        }\n\n        case MQTT_MSG_WRITE:\n        case MQTT_MSG_WRITE_PAYLOAD:\n        default:\n        {\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"MqttClient_WaitType: Invalid state %d!\", *mms_stat);\n        #endif\n            rc = MQTT_CODE_ERROR_STAT;\n            break;\n        }\n    } /* switch (*mms_stat) */\n\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc != MQTT_CODE_CONTINUE)\n#endif\n    {\n        /* reset state */\n        *mms_stat = MQTT_MSG_BEGIN;\n    }\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (readLocked) {\n        wm_SemUnlock(&client->lockRecv);\n    }\n#endif\n    if (rc < 0) {\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_WaitType: Failure: %s (%d)\",\n            MqttClient_ReturnCodeToString(rc), rc);\n    #endif\n        return rc;\n    }\n\n    if (!waitMatchFound) {\n        /* if we get here, then the we are still waiting for a packet */\n        goto wait_again;\n    }\n\n    return rc;\n}\n\nint MqttClient_Subscribe(MqttClient *client, MqttSubscribe *subscribe)\n{\n    int rc, len, i;\n    MqttTopic* topic;\n\n    /* Validate required arguments */\n    if (client == NULL || subscribe == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n#ifdef WOLFMQTT_V5\n    /* Use specified protocol version if set */\n    subscribe->protocol_level = client->protocol_level;\n#endif\n\n    if (subscribe->stat == MQTT_MSG_BEGIN) {\n    #ifdef WOLFMQTT_MULTITHREAD\n        /* Lock send socket mutex */\n        rc = wm_SemLock(&client->lockSend);\n        if (rc != 0) {\n            return rc;\n        }\n    #endif\n\n        /* Encode the subscribe packet */\n        rc = MqttEncode_Subscribe(client->tx_buf, client->tx_buf_len,\n                subscribe);\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d), ID %d\",\n            rc, MqttPacket_TypeDesc(MQTT_PACKET_TYPE_SUBSCRIBE),\n            MQTT_PACKET_TYPE_SUBSCRIBE, subscribe->packet_id);\n    #endif\n        if (rc <= 0) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            wm_SemUnlock(&client->lockSend);\n        #endif\n            return rc;\n        }\n        len = rc;\n\n    #ifdef WOLFMQTT_MULTITHREAD\n        rc = wm_SemLock(&client->lockClient);\n        if (rc == 0) {\n            /* inform other threads of expected response */\n            rc = MqttClient_RespList_Add(client, MQTT_PACKET_TYPE_SUBSCRIBE_ACK,\n                subscribe->packet_id, &subscribe->pendResp, &subscribe->ack);\n            wm_SemUnlock(&client->lockClient);\n        }\n        if (rc != 0) {\n            wm_SemUnlock(&client->lockSend);\n            return rc; /* Error locking client */\n        }\n    #endif\n\n        /* Send subscribe packet */\n        rc = MqttPacket_Write(client, client->tx_buf, len);\n    #ifdef WOLFMQTT_MULTITHREAD\n        wm_SemUnlock(&client->lockSend);\n    #endif\n        if (rc != len) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (wm_SemLock(&client->lockClient) == 0) {\n                MqttClient_RespList_Remove(client, &subscribe->pendResp);\n                wm_SemUnlock(&client->lockClient);\n            }\n        #endif\n            return rc;\n        }\n\n        subscribe->stat = MQTT_MSG_WAIT;\n    }\n\n    /* Wait for subscribe ack packet */\n    rc = MqttClient_WaitType(client, &subscribe->ack,\n        MQTT_PACKET_TYPE_SUBSCRIBE_ACK, subscribe->packet_id,\n        client->cmd_timeout_ms);\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc == MQTT_CODE_CONTINUE)\n        return rc;\n#endif\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (wm_SemLock(&client->lockClient) == 0) {\n        MqttClient_RespList_Remove(client, &subscribe->pendResp);\n        wm_SemUnlock(&client->lockClient);\n    }\n#endif\n\n    /* Populate return codes */\n    if (rc == MQTT_CODE_SUCCESS) {\n        for (i = 0; i < subscribe->topic_count && i < MAX_MQTT_TOPICS; i++) {\n            topic = &subscribe->topics[i];\n            topic->return_code = subscribe->ack.return_codes[i];\n        }\n    }\n\n    /* reset state */\n    subscribe->stat = MQTT_MSG_BEGIN;\n\n    return rc;\n}\n\nbool wolfMQTTFuzzer::subscribe(void) {\n    MqttTopic* topicsArray = nullptr;\n\n    bool ret = false;\n\n    try {\n        Topics topics(ds);\n        CHECK_EQ(topics.Generate(), true);\n\n        MqttSubscribe subscribe;\n\n        memset(&subscribe, 0, sizeof(subscribe));\n\n        subscribe.packet_id = GetPacketId();\n        topicsArray = topics.ToArray();\n        subscribe.topic_count = topics.Size();\n        subscribe.topics = topicsArray;\n\n        CHECK_EQ(MqttClient_Subscribe(&client, &subscribe), MQTT_CODE_SUCCESS);\n\n        ret = true;\n    } catch ( ... ) { }\n\nend:\n    if ( topicsArray ) {\n        delete[] topicsArray;\n    }\n    return ret;\n}\n\nvoid wolfMQTTFuzzer::Run(void) {\n    try {\n        const auto numActions = ds.Get<uint8_t>() % 20;\n\n        for (size_t i = 0; i < numActions; i++) {\n            switch ( ds.Get<uint8_t>() ) {\n                case    0:\n                    subscribe();\n                    break;\n                case    1:\n                    unsubscribe();\n                    break;\n                case    2:\n                    publish();\n                    break;\n                case    3:\n                    ping();\n                    break;\n                case    4:\n                    wait();\n                    break;\n            }\n        }\n\n        MqttClient_NetDisconnect(&client);\n    } catch ( ... ) { }\n}\n\n\n// target function\nstatic int MqttClient_WaitType(MqttClient *client, void *packet_obj,\n    byte wait_type, word16 wait_packet_id, int timeout_ms)\n{\n    int rc;\n    word16 packet_id;\n    MqttPacketType packet_type;\n#ifdef WOLFMQTT_MULTITHREAD\n    MqttPendResp *pendResp;\n    int readLocked;\n#endif\n    MqttMsgStat* mms_stat;\n    int waitMatchFound;\n\n    if (client == NULL || packet_obj == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    /* all packet type structures must have MqttMsgStat at top */\n    mms_stat = (MqttMsgStat*)packet_obj;\n\nwait_again:\n\n    /* initialize variables */\n    packet_id = 0;\n    packet_type = MQTT_PACKET_TYPE_RESERVED;\n#ifdef WOLFMQTT_MULTITHREAD\n    pendResp = NULL;\n    readLocked = 0;\n#endif\n    waitMatchFound = 0;\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"MqttClient_WaitType: Type %s (%d), ID %d\",\n        MqttPacket_TypeDesc((MqttPacketType)wait_type),\n            wait_type, wait_packet_id);\n#endif\n\n    switch ((int)*mms_stat)\n    {\n        case MQTT_MSG_BEGIN:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Lock recv socket mutex */\n            rc = wm_SemLock(&client->lockRecv);\n            if (rc != 0) {\n                PRINTF(\"MqttClient_WaitType: recv lock error!\");\n                return rc;\n            }\n            readLocked = 1;\n        #endif\n\n            /* reset the packet state */\n            client->packet.stat = MQTT_PK_BEGIN;\n        }\n        FALL_THROUGH;\n\n    #ifdef WOLFMQTT_V5\n        case MQTT_MSG_AUTH:\n    #endif\n        case MQTT_MSG_WAIT:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if packet type and id have already completed */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, (MqttPacketType)wait_type, \n                    wait_packet_id, &pendResp)) {\n                    if (pendResp->packetDone) {\n                        /* pending response is already done, so return */\n                        rc = pendResp->packet_ret;\n                    #ifdef WOLFMQTT_DEBUG_CLIENT\n                        PRINTF(\"PendResp already Done %p: Rc %d\", pendResp, rc);\n                    #endif\n                        MqttClient_RespList_Remove(client, pendResp);\n                        wm_SemUnlock(&client->lockClient);\n                        wm_SemUnlock(&client->lockRecv);\n                        return rc;\n                    }\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            *mms_stat = MQTT_MSG_WAIT;\n\n            /* Wait for packet */\n            rc = MqttPacket_Read(client, client->rx_buf, client->rx_buf_len,\n                    timeout_ms);\n            /* handle failure */\n            if (rc <= 0) {\n                break;\n            }\n\n            /* capture length read */\n            client->packet.buf_len = rc;\n\n            /* Decode Packet - get type and id */\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, NULL, &packet_type, NULL, &packet_id);\n            if (rc < 0) {\n                break;\n            }\n\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"Read Packet: Len %d, Type %d, ID %d\",\n                client->packet.buf_len, packet_type, packet_id);\n        #endif\n\n            *mms_stat = MQTT_MSG_READ;\n        }\n        FALL_THROUGH;\n\n        case MQTT_MSG_READ:\n        case MQTT_MSG_READ_PAYLOAD:\n        {\n            MqttPacketType use_packet_type;\n            void* use_packet_obj;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            readLocked = 1; /* if in this state read is locked */\n        #endif\n\n            /* read payload state only happens for publish messages */\n            if (*mms_stat == MQTT_MSG_READ_PAYLOAD) {\n                packet_type = MQTT_PACKET_TYPE_PUBLISH;\n            }\n\n            /* Determine if we received data for this request */\n            if ((wait_type == MQTT_PACKET_TYPE_ANY ||\n                 wait_type == packet_type ||\n                 MqttIsPubRespPacket(packet_type) == MqttIsPubRespPacket(wait_type)) &&\n               (wait_packet_id == 0 || wait_packet_id == packet_id))\n            {\n                use_packet_obj = packet_obj;\n                waitMatchFound = 1;\n            }\n            else {\n                /* use generic packet object */\n                use_packet_obj = &client->msg;\n            }\n            use_packet_type = packet_type;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if we have a pending response for this packet */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, packet_type, packet_id,\n                                                               &pendResp)) {\n                    /* we found packet match this incoming read packet */\n                    pendResp->packetProcessing = 1;\n                    use_packet_obj = pendResp->packet_obj;\n                    use_packet_type = pendResp->packet_type;\n                    /* req from another thread... not a match */\n                    waitMatchFound = 0;\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            /* Perform packet handling for publish callback and QoS */\n            rc = MqttClient_HandlePacket(client, use_packet_type,\n                use_packet_obj, timeout_ms);\n\n        #ifdef WOLFMQTT_NONBLOCK\n            if (rc == MQTT_CODE_CONTINUE) {\n                /* we have received some data, so keep the recv\n                    mutex lock active and return */\n                return rc;\n            }\n        #endif\n\n            /* handle success case */\n            if (rc >= 0) {\n                rc = MQTT_CODE_SUCCESS;\n            }\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (pendResp) {\n                /* Mark pending response entry done */\n                if (wm_SemLock(&client->lockClient) == 0) {\n                    pendResp->packetDone = 1;\n                    pendResp->packet_ret = rc;\n                #ifdef WOLFMQTT_DEBUG_CLIENT\n                    PRINTF(\"PendResp Done %p\", pendResp);\n                #endif\n                    pendResp = NULL;\n                    wm_SemUnlock(&client->lockClient);\n                }\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n            break;\n        }\n\n        case MQTT_MSG_WRITE:\n        case MQTT_MSG_WRITE_PAYLOAD:\n        default:\n        {\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"MqttClient_WaitType: Invalid state %d!\", *mms_stat);\n        #endif\n            rc = MQTT_CODE_ERROR_STAT;\n            break;\n        }\n    } /* switch (*mms_stat) */\n\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc != MQTT_CODE_CONTINUE)\n#endif\n    {\n        /* reset state */\n        *mms_stat = MQTT_MSG_BEGIN;\n    }\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (readLocked) {\n        wm_SemUnlock(&client->lockRecv);\n    }\n#endif\n    if (rc < 0) {\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_WaitType: Failure: %s (%d)\",\n            MqttClient_ReturnCodeToString(rc), rc);\n    #endif\n        return rc;\n    }\n\n    if (!waitMatchFound) {\n        /* if we get here, then the we are still waiting for a packet */\n        goto wait_again;\n    }\n\n    return rc;\n}\n",
    "target": 1,
    "idx": 1039103,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "// context\n  void fill(size_t zero_pad_bytes) {\n    make_space(zero_pad_bytes);\n    for (size_t i = 0; i < zero_pad_bytes; i++) cur_[i] = 0;\n  }\n\n  template<typename T> void PreAlign(size_t len) {\n    AssertScalarT<T>();\n    PreAlign(len, sizeof(T));\n  }\n\n  void ForceVectorAlignment(size_t len, size_t elemsize, size_t alignment) {\n    FLATBUFFERS_ASSERT(VerifyAlignmentRequirements(alignment));\n    PreAlign(len * elemsize, alignment);\n  }\n\nCheckedError Parser::ParseVector(const Type &type, uoffset_t *ovalue,\n                                 FieldDef *field, size_t fieldn) {\n  uoffset_t count = 0;\n  auto err = ParseVectorDelimiters(count, [&](uoffset_t &) -> CheckedError {\n    Value val;\n    val.type = type;\n    ECHECK(ParseAnyValue(val, field, fieldn, nullptr, count, true));\n    field_stack_.push_back(std::make_pair(val, nullptr));\n    return NoError();\n  });\n  ECHECK(err);\n\n  const size_t len = count * InlineSize(type) / InlineAlignment(type);\n  const size_t elemsize = InlineAlignment(type);\n  const auto force_align = field->attributes.Lookup(\"force_align\");\n  if (force_align) {\n    size_t align;\n    ECHECK(ParseAlignAttribute(force_align->constant, 1, &align));\n    if (align > 1) { builder_.ForceVectorAlignment(len, elemsize, align); }\n  }\n\n  builder_.StartVector(len, elemsize);\n  for (uoffset_t i = 0; i < count; i++) {\n    // start at the back, since we're building the data backwards.\n    auto &val = field_stack_.back().first;\n    switch (val.type.base_type) {\n      // clang-format off\n      #define FLATBUFFERS_TD(ENUM, IDLTYPE, CTYPE,...) \\\n        case BASE_TYPE_ ## ENUM: \\\n          if (IsStruct(val.type)) SerializeStruct(*val.type.struct_def, val); \\\n          else { \\\n             CTYPE elem; \\\n             ECHECK(atot(val.constant.c_str(), *this, &elem)); \\\n             builder_.PushElement(elem); \\\n          } \\\n          break;\n        FLATBUFFERS_GEN_TYPES(FLATBUFFERS_TD)\n      #undef FLATBUFFERS_TD\n      // clang-format on\n    }\n    field_stack_.pop_back();\n  }\n\n  builder_.ClearOffsets();\n  *ovalue = builder_.EndVector(count);\n\n  if (type.base_type == BASE_TYPE_STRUCT && type.struct_def->has_key) {\n    // We should sort this vector. Find the key first.\n    const FieldDef *key = nullptr;\n    for (auto it = type.struct_def->fields.vec.begin();\n         it != type.struct_def->fields.vec.end(); ++it) {\n      if ((*it)->key) {\n        key = (*it);\n        break;\n      }\n    }\n    FLATBUFFERS_ASSERT(key);\n    // Now sort it.\n    // We can't use std::sort because for structs the size is not known at\n    // compile time, and for tables our iterators dereference offsets, so can't\n    // be used to swap elements.\n    // And we can't use C qsort either, since that would force use to use\n    // globals, making parsing thread-unsafe.\n    // So for now, we use SimpleQsort above.\n    // TODO: replace with something better, preferably not recursive.\n\n    if (type.struct_def->fixed) {\n      const voffset_t offset = key->value.offset;\n      const size_t struct_size = type.struct_def->bytesize;\n      auto v =\n          reinterpret_cast<VectorOfAny *>(builder_.GetCurrentBufferPointer());\n      SimpleQsort<uint8_t>(\n          v->Data(), v->Data() + v->size() * type.struct_def->bytesize,\n          type.struct_def->bytesize,\n          [offset, key](const uint8_t *a, const uint8_t *b) -> bool {\n            return CompareSerializedScalars(a + offset, b + offset, *key);\n          },\n          [struct_size](uint8_t *a, uint8_t *b) {\n            // FIXME: faster?\n            for (size_t i = 0; i < struct_size; i++) { std::swap(a[i], b[i]); }\n          });\n    } else {\n      auto v = reinterpret_cast<Vector<Offset<Table>> *>(\n          builder_.GetCurrentBufferPointer());\n      // Here also can't use std::sort. We do have an iterator type for it,\n      // but it is non-standard as it will dereference the offsets, and thus\n      // can't be used to swap elements.\n      if (key->value.type.base_type == BASE_TYPE_STRING) {\n        SimpleQsort<Offset<Table>>(\n            v->data(), v->data() + v->size(), 1,\n            [key](const Offset<Table> *_a, const Offset<Table> *_b) -> bool {\n              return CompareTablesByStringKey(_a, _b, *key);\n            },\n            SwapSerializedTables);\n      } else {\n        SimpleQsort<Offset<Table>>(\n            v->data(), v->data() + v->size(), 1,\n            [key](const Offset<Table> *_a, const Offset<Table> *_b) -> bool {\n              return CompareTablesByScalarKey(_a, _b, *key);\n            },\n            SwapSerializedTables);\n      }\n    }\n  }\n  return NoError();\n}\n\n\n\nCheckedError Parser::ParseTable(const StructDef &struct_def, std::string *value,\n                                uoffset_t *ovalue) {\n  ParseDepthGuard depth_guard(this);\n  ECHECK(depth_guard.Check());\n\n  size_t fieldn_outer = 0;\n  auto err = ParseTableDelimiters(\n      fieldn_outer, &struct_def,\n      [&](const std::string &name, size_t &fieldn,\n          const StructDef *struct_def_inner) -> CheckedError {\n        if (name == \"$schema\") {\n          ECHECK(Expect(kTokenStringConstant));\n          return NoError();\n        }\n        auto field = struct_def_inner->fields.Lookup(name);\n        if (!field) {\n          if (!opts.skip_unexpected_fields_in_json) {\n            return Error(\"unknown field: \" + name);\n          } else {\n            ECHECK(SkipAnyJsonValue());\n          }\n        } else {\n          if (IsIdent(\"null\") && !IsScalar(field->value.type.base_type)) {\n            ECHECK(Next());  // Ignore this field.\n          } else {\n            Value val = field->value;\n            if (field->flexbuffer) {\n              flexbuffers::Builder builder(1024,\n                                           flexbuffers::BUILDER_FLAG_SHARE_ALL);\n              ECHECK(ParseFlexBufferValue(&builder));\n              builder.Finish();\n              // Force alignment for nested flexbuffer\n              builder_.ForceVectorAlignment(builder.GetSize(), sizeof(uint8_t),\n                                            sizeof(largest_scalar_t));\n              auto off = builder_.CreateVector(builder.GetBuffer());\n              val.constant = NumToString(off.o);\n            } else if (field->nested_flatbuffer) {\n              ECHECK(\n                  ParseNestedFlatbuffer(val, field, fieldn, struct_def_inner));\n            } else {\n              ECHECK(ParseAnyValue(val, field, fieldn, struct_def_inner, 0));\n            }\n            // Hardcoded insertion-sort with error-check.\n            // If fields are specified in order, then this loop exits\n            // immediately.\n            auto elem = field_stack_.rbegin();\n            for (; elem != field_stack_.rbegin() + fieldn; ++elem) {\n              auto existing_field = elem->second;\n              if (existing_field == field)\n                return Error(\"field set more than once: \" + field->name);\n              if (existing_field->value.offset < field->value.offset) break;\n            }\n            // Note: elem points to before the insertion point, thus .base()\n            // points to the correct spot.\n            field_stack_.insert(elem.base(), std::make_pair(val, field));\n            fieldn++;\n          }\n        }\n        return NoError();\n      });\n  ECHECK(err);\n\n  // Check if all required fields are parsed.\n  for (auto field_it = struct_def.fields.vec.begin();\n       field_it != struct_def.fields.vec.end(); ++field_it) {\n    auto required_field = *field_it;\n    if (!required_field->IsRequired()) { continue; }\n    bool found = false;\n    for (auto pf_it = field_stack_.end() - fieldn_outer;\n         pf_it != field_stack_.end(); ++pf_it) {\n      auto parsed_field = pf_it->second;\n      if (parsed_field == required_field) {\n        found = true;\n        break;\n      }\n    }\n    if (!found) {\n      return Error(\"required field is missing: \" + required_field->name +\n                   \" in \" + struct_def.name);\n    }\n  }\n\n  if (struct_def.fixed && fieldn_outer != struct_def.fields.vec.size())\n    return Error(\"struct: wrong number of initializers: \" + struct_def.name);\n\n  auto start = struct_def.fixed ? builder_.StartStruct(struct_def.minalign)\n                                : builder_.StartTable();\n\n  for (size_t size = struct_def.sortbysize ? sizeof(largest_scalar_t) : 1; size;\n       size /= 2) {\n    // Go through elements in reverse, since we're building the data backwards.\n    for (auto it = field_stack_.rbegin();\n         it != field_stack_.rbegin() + fieldn_outer; ++it) {\n      auto &field_value = it->first;\n      auto field = it->second;\n      if (!struct_def.sortbysize ||\n          size == SizeOf(field_value.type.base_type)) {\n        switch (field_value.type.base_type) {\n          // clang-format off\n          #define FLATBUFFERS_TD(ENUM, IDLTYPE, CTYPE, ...) \\\n            case BASE_TYPE_ ## ENUM: \\\n              builder_.Pad(field->padding); \\\n              if (struct_def.fixed) { \\\n                CTYPE val; \\\n                ECHECK(atot(field_value.constant.c_str(), *this, &val)); \\\n                builder_.PushElement(val); \\\n              } else { \\\n                CTYPE val, valdef; \\\n                ECHECK(atot(field_value.constant.c_str(), *this, &val)); \\\n                ECHECK(atot(field->value.constant.c_str(), *this, &valdef)); \\\n                builder_.AddElement(field_value.offset, val, valdef); \\\n              } \\\n              break;\n            FLATBUFFERS_GEN_TYPES_SCALAR(FLATBUFFERS_TD)\n          #undef FLATBUFFERS_TD\n          #define FLATBUFFERS_TD(ENUM, IDLTYPE, CTYPE, ...) \\\n            case BASE_TYPE_ ## ENUM: \\\n              builder_.Pad(field->padding); \\\n              if (IsStruct(field->value.type)) { \\\n                SerializeStruct(*field->value.type.struct_def, field_value); \\\n              } else { \\\n                CTYPE val; \\\n                ECHECK(atot(field_value.constant.c_str(), *this, &val)); \\\n                builder_.AddOffset(field_value.offset, val); \\\n              } \\\n              break;\n            FLATBUFFERS_GEN_TYPES_POINTER(FLATBUFFERS_TD)\n          #undef FLATBUFFERS_TD\n            case BASE_TYPE_ARRAY:\n              builder_.Pad(field->padding);\n              builder_.PushBytes(\n                reinterpret_cast<const uint8_t*>(field_value.constant.c_str()),\n                InlineSize(field_value.type));\n              break;\n            // clang-format on\n        }\n      }\n    }\n  }\n  for (size_t i = 0; i < fieldn_outer; i++) field_stack_.pop_back();\n\n  if (struct_def.fixed) {\n    builder_.ClearOffsets();\n    builder_.EndStruct();\n    FLATBUFFERS_ASSERT(value);\n    // Temporarily store this struct in the value string, since it is to\n    // be serialized in-place elsewhere.\n    value->assign(\n        reinterpret_cast<const char *>(builder_.GetCurrentBufferPointer()),\n        struct_def.bytesize);\n    builder_.PopBytes(struct_def.bytesize);\n    FLATBUFFERS_ASSERT(!ovalue);\n  } else {\n    auto val = builder_.EndTable(start);\n    if (ovalue) *ovalue = val;\n    if (value) *value = NumToString(val);\n  }\n  return NoError();\n}\n\nCheckedError Parser::ParseTable(const StructDef &struct_def, std::string *value,\n                                uoffset_t *ovalue) {\n  ParseDepthGuard depth_guard(this);\n  ECHECK(depth_guard.Check());\n\n  size_t fieldn_outer = 0;\n  auto err = ParseTableDelimiters(\n      fieldn_outer, &struct_def,\n      [&](const std::string &name, size_t &fieldn,\n          const StructDef *struct_def_inner) -> CheckedError {\n        if (name == \"$schema\") {\n          ECHECK(Expect(kTokenStringConstant));\n          return NoError();\n        }\n        auto field = struct_def_inner->fields.Lookup(name);\n        if (!field) {\n          if (!opts.skip_unexpected_fields_in_json) {\n            return Error(\"unknown field: \" + name);\n          } else {\n            ECHECK(SkipAnyJsonValue());\n          }\n        } else {\n          if (IsIdent(\"null\") && !IsScalar(field->value.type.base_type)) {\n            ECHECK(Next());  // Ignore this field.\n          } else {\n            Value val = field->value;\n            if (field->flexbuffer) {\n              flexbuffers::Builder builder(1024,\n                                           flexbuffers::BUILDER_FLAG_SHARE_ALL);\n              ECHECK(ParseFlexBufferValue(&builder));\n              builder.Finish();\n              // Force alignment for nested flexbuffer\n              builder_.ForceVectorAlignment(builder.GetSize(), sizeof(uint8_t),\n                                            sizeof(largest_scalar_t));\n              auto off = builder_.CreateVector(builder.GetBuffer());\n              val.constant = NumToString(off.o);\n            } else if (field->nested_flatbuffer) {\n              ECHECK(\n                  ParseNestedFlatbuffer(val, field, fieldn, struct_def_inner));\n            } else {\n              ECHECK(ParseAnyValue(val, field, fieldn, struct_def_inner, 0));\n            }\n            // Hardcoded insertion-sort with error-check.\n            // If fields are specified in order, then this loop exits\n            // immediately.\n            auto elem = field_stack_.rbegin();\n            for (; elem != field_stack_.rbegin() + fieldn; ++elem) {\n              auto existing_field = elem->second;\n              if (existing_field == field)\n                return Error(\"field set more than once: \" + field->name);\n              if (existing_field->value.offset < field->value.offset) break;\n            }\n            // Note: elem points to before the insertion point, thus .base()\n            // points to the correct spot.\n            field_stack_.insert(elem.base(), std::make_pair(val, field));\n            fieldn++;\n          }\n        }\n        return NoError();\n      });\n  ECHECK(err);\n\n  // Check if all required fields are parsed.\n  for (auto field_it = struct_def.fields.vec.begin();\n       field_it != struct_def.fields.vec.end(); ++field_it) {\n    auto required_field = *field_it;\n    if (!required_field->IsRequired()) { continue; }\n    bool found = false;\n    for (auto pf_it = field_stack_.end() - fieldn_outer;\n         pf_it != field_stack_.end(); ++pf_it) {\n      auto parsed_field = pf_it->second;\n      if (parsed_field == required_field) {\n        found = true;\n        break;\n      }\n    }\n    if (!found) {\n      return Error(\"required field is missing: \" + required_field->name +\n                   \" in \" + struct_def.name);\n    }\n  }\n\n  if (struct_def.fixed && fieldn_outer != struct_def.fields.vec.size())\n    return Error(\"struct: wrong number of initializers: \" + struct_def.name);\n\n  auto start = struct_def.fixed ? builder_.StartStruct(struct_def.minalign)\n                                : builder_.StartTable();\n\n  for (size_t size = struct_def.sortbysize ? sizeof(largest_scalar_t) : 1; size;\n       size /= 2) {\n    // Go through elements in reverse, since we're building the data backwards.\n    for (auto it = field_stack_.rbegin();\n         it != field_stack_.rbegin() + fieldn_outer; ++it) {\n      auto &field_value = it->first;\n      auto field = it->second;\n      if (!struct_def.sortbysize ||\n          size == SizeOf(field_value.type.base_type)) {\n        switch (field_value.type.base_type) {\n          // clang-format off\n          #define FLATBUFFERS_TD(ENUM, IDLTYPE, CTYPE, ...) \\\n            case BASE_TYPE_ ## ENUM: \\\n              builder_.Pad(field->padding); \\\n              if (struct_def.fixed) { \\\n                CTYPE val; \\\n                ECHECK(atot(field_value.constant.c_str(), *this, &val)); \\\n                builder_.PushElement(val); \\\n              } else { \\\n                CTYPE val, valdef; \\\n                ECHECK(atot(field_value.constant.c_str(), *this, &val)); \\\n                ECHECK(atot(field->value.constant.c_str(), *this, &valdef)); \\\n                builder_.AddElement(field_value.offset, val, valdef); \\\n              } \\\n              break;\n            FLATBUFFERS_GEN_TYPES_SCALAR(FLATBUFFERS_TD)\n          #undef FLATBUFFERS_TD\n          #define FLATBUFFERS_TD(ENUM, IDLTYPE, CTYPE, ...) \\\n            case BASE_TYPE_ ## ENUM: \\\n              builder_.Pad(field->padding); \\\n              if (IsStruct(field->value.type)) { \\\n                SerializeStruct(*field->value.type.struct_def, field_value); \\\n              } else { \\\n                CTYPE val; \\\n                ECHECK(atot(field_value.constant.c_str(), *this, &val)); \\\n                builder_.AddOffset(field_value.offset, val); \\\n              } \\\n              break;\n            FLATBUFFERS_GEN_TYPES_POINTER(FLATBUFFERS_TD)\n          #undef FLATBUFFERS_TD\n            case BASE_TYPE_ARRAY:\n              builder_.Pad(field->padding);\n              builder_.PushBytes(\n                reinterpret_cast<const uint8_t*>(field_value.constant.c_str()),\n                InlineSize(field_value.type));\n              break;\n            // clang-format on\n        }\n      }\n    }\n  }\n  for (size_t i = 0; i < fieldn_outer; i++) field_stack_.pop_back();\n\n  if (struct_def.fixed) {\n    builder_.ClearOffsets();\n    builder_.EndStruct();\n    FLATBUFFERS_ASSERT(value);\n    // Temporarily store this struct in the value string, since it is to\n    // be serialized in-place elsewhere.\n    value->assign(\n        reinterpret_cast<const char *>(builder_.GetCurrentBufferPointer()),\n        struct_def.bytesize);\n    builder_.PopBytes(struct_def.bytesize);\n    FLATBUFFERS_ASSERT(!ovalue);\n  } else {\n    auto val = builder_.EndTable(start);\n    if (ovalue) *ovalue = val;\n    if (value) *value = NumToString(val);\n  }\n  return NoError();\n}\n\nCheckedError Parser::ParseTable(const StructDef &struct_def, std::string *value,\n                                uoffset_t *ovalue) {\n  ParseDepthGuard depth_guard(this);\n  ECHECK(depth_guard.Check());\n\n  size_t fieldn_outer = 0;\n  auto err = ParseTableDelimiters(\n      fieldn_outer, &struct_def,\n      [&](const std::string &name, size_t &fieldn,\n          const StructDef *struct_def_inner) -> CheckedError {\n        if (name == \"$schema\") {\n          ECHECK(Expect(kTokenStringConstant));\n          return NoError();\n        }\n        auto field = struct_def_inner->fields.Lookup(name);\n        if (!field) {\n          if (!opts.skip_unexpected_fields_in_json) {\n            return Error(\"unknown field: \" + name);\n          } else {\n            ECHECK(SkipAnyJsonValue());\n          }\n        } else {\n          if (IsIdent(\"null\") && !IsScalar(field->value.type.base_type)) {\n            ECHECK(Next());  // Ignore this field.\n          } else {\n            Value val = field->value;\n            if (field->flexbuffer) {\n              flexbuffers::Builder builder(1024,\n                                           flexbuffers::BUILDER_FLAG_SHARE_ALL);\n              ECHECK(ParseFlexBufferValue(&builder));\n              builder.Finish();\n              // Force alignment for nested flexbuffer\n              builder_.ForceVectorAlignment(builder.GetSize(), sizeof(uint8_t),\n                                            sizeof(largest_scalar_t));\n              auto off = builder_.CreateVector(builder.GetBuffer());\n              val.constant = NumToString(off.o);\n            } else if (field->nested_flatbuffer) {\n              ECHECK(\n                  ParseNestedFlatbuffer(val, field, fieldn, struct_def_inner));\n            } else {\n              ECHECK(ParseAnyValue(val, field, fieldn, struct_def_inner, 0));\n            }\n            // Hardcoded insertion-sort with error-check.\n            // If fields are specified in order, then this loop exits\n            // immediately.\n            auto elem = field_stack_.rbegin();\n            for (; elem != field_stack_.rbegin() + fieldn; ++elem) {\n              auto existing_field = elem->second;\n              if (existing_field == field)\n                return Error(\"field set more than once: \" + field->name);\n              if (existing_field->value.offset < field->value.offset) break;\n            }\n            // Note: elem points to before the insertion point, thus .base()\n            // points to the correct spot.\n            field_stack_.insert(elem.base(), std::make_pair(val, field));\n            fieldn++;\n          }\n        }\n        return NoError();\n      });\n  ECHECK(err);\n\n  // Check if all required fields are parsed.\n  for (auto field_it = struct_def.fields.vec.begin();\n       field_it != struct_def.fields.vec.end(); ++field_it) {\n    auto required_field = *field_it;\n    if (!required_field->IsRequired()) { continue; }\n    bool found = false;\n    for (auto pf_it = field_stack_.end() - fieldn_outer;\n         pf_it != field_stack_.end(); ++pf_it) {\n      auto parsed_field = pf_it->second;\n      if (parsed_field == required_field) {\n        found = true;\n        break;\n      }\n    }\n    if (!found) {\n      return Error(\"required field is missing: \" + required_field->name +\n                   \" in \" + struct_def.name);\n    }\n  }\n\n  if (struct_def.fixed && fieldn_outer != struct_def.fields.vec.size())\n    return Error(\"struct: wrong number of initializers: \" + struct_def.name);\n\n  auto start = struct_def.fixed ? builder_.StartStruct(struct_def.minalign)\n                                : builder_.StartTable();\n\n  for (size_t size = struct_def.sortbysize ? sizeof(largest_scalar_t) : 1; size;\n       size /= 2) {\n    // Go through elements in reverse, since we're building the data backwards.\n    for (auto it = field_stack_.rbegin();\n         it != field_stack_.rbegin() + fieldn_outer; ++it) {\n      auto &field_value = it->first;\n      auto field = it->second;\n      if (!struct_def.sortbysize ||\n          size == SizeOf(field_value.type.base_type)) {\n        switch (field_value.type.base_type) {\n          // clang-format off\n          #define FLATBUFFERS_TD(ENUM, IDLTYPE, CTYPE, ...) \\\n            case BASE_TYPE_ ## ENUM: \\\n              builder_.Pad(field->padding); \\\n              if (struct_def.fixed) { \\\n                CTYPE val; \\\n                ECHECK(atot(field_value.constant.c_str(), *this, &val)); \\\n                builder_.PushElement(val); \\\n              } else { \\\n                CTYPE val, valdef; \\\n                ECHECK(atot(field_value.constant.c_str(), *this, &val)); \\\n                ECHECK(atot(field->value.constant.c_str(), *this, &valdef)); \\\n                builder_.AddElement(field_value.offset, val, valdef); \\\n              } \\\n              break;\n            FLATBUFFERS_GEN_TYPES_SCALAR(FLATBUFFERS_TD)\n          #undef FLATBUFFERS_TD\n          #define FLATBUFFERS_TD(ENUM, IDLTYPE, CTYPE, ...) \\\n            case BASE_TYPE_ ## ENUM: \\\n              builder_.Pad(field->padding); \\\n              if (IsStruct(field->value.type)) { \\\n                SerializeStruct(*field->value.type.struct_def, field_value); \\\n              } else { \\\n                CTYPE val; \\\n                ECHECK(atot(field_value.constant.c_str(), *this, &val)); \\\n                builder_.AddOffset(field_value.offset, val); \\\n              } \\\n              break;\n            FLATBUFFERS_GEN_TYPES_POINTER(FLATBUFFERS_TD)\n          #undef FLATBUFFERS_TD\n            case BASE_TYPE_ARRAY:\n              builder_.Pad(field->padding);\n              builder_.PushBytes(\n                reinterpret_cast<const uint8_t*>(field_value.constant.c_str()),\n                InlineSize(field_value.type));\n              break;\n            // clang-format on\n        }\n      }\n    }\n  }\n  for (size_t i = 0; i < fieldn_outer; i++) field_stack_.pop_back();\n\n  if (struct_def.fixed) {\n    builder_.ClearOffsets();\n    builder_.EndStruct();\n    FLATBUFFERS_ASSERT(value);\n    // Temporarily store this struct in the value string, since it is to\n    // be serialized in-place elsewhere.\n    value->assign(\n        reinterpret_cast<const char *>(builder_.GetCurrentBufferPointer()),\n        struct_def.bytesize);\n    builder_.PopBytes(struct_def.bytesize);\n    FLATBUFFERS_ASSERT(!ovalue);\n  } else {\n    auto val = builder_.EndTable(start);\n    if (ovalue) *ovalue = val;\n    if (value) *value = NumToString(val);\n  }\n  return NoError();\n}\n\nCheckedError Parser::DoParseJson() {\n  if (token_ != '{') {\n    EXPECT('{');\n  } else {\n    if (!root_struct_def_) return Error(\"no root type set to parse json with\");\n    if (builder_.GetSize()) {\n      return Error(\"cannot have more than one json object in a file\");\n    }\n    uoffset_t toff;\n    ECHECK(ParseTable(*root_struct_def_, nullptr, &toff));\n    if (opts.size_prefixed) {\n      builder_.FinishSizePrefixed(\n          Offset<Table>(toff),\n          file_identifier_.length() ? file_identifier_.c_str() : nullptr);\n    } else {\n      builder_.Finish(Offset<Table>(toff), file_identifier_.length()\n                                               ? file_identifier_.c_str()\n                                               : nullptr);\n    }\n  }\n  // Check that JSON file doesn't contain more objects or IDL directives.\n  // Comments after JSON are allowed.\n  EXPECT(kTokenEof);\n  return NoError();\n}\n\nCheckedError Parser::DoParseJson() {\n  if (token_ != '{') {\n    EXPECT('{');\n  } else {\n    if (!root_struct_def_) return Error(\"no root type set to parse json with\");\n    if (builder_.GetSize()) {\n      return Error(\"cannot have more than one json object in a file\");\n    }\n    uoffset_t toff;\n    ECHECK(ParseTable(*root_struct_def_, nullptr, &toff));\n    if (opts.size_prefixed) {\n      builder_.FinishSizePrefixed(\n          Offset<Table>(toff),\n          file_identifier_.length() ? file_identifier_.c_str() : nullptr);\n    } else {\n      builder_.Finish(Offset<Table>(toff), file_identifier_.length()\n                                               ? file_identifier_.c_str()\n                                               : nullptr);\n    }\n  }\n  // Check that JSON file doesn't contain more objects or IDL directives.\n  // Comments after JSON are allowed.\n  EXPECT(kTokenEof);\n  return NoError();\n}\n\n\n\nbool Parser::Is(int t) const { return t == token_; }\n\n\n// target function\n  void ForceVectorAlignment(size_t len, size_t elemsize, size_t alignment) {\n    PreAlign(len * elemsize, alignment);\n  }\n  void ForceStringAlignment(size_t len, size_t alignment) {\n    PreAlign((len + 1) * sizeof(char), alignment);\n  }\nCheckedError Parser::ParseVector(const Type &type, uoffset_t *ovalue,\n                                 FieldDef *field, size_t fieldn) {\n  uoffset_t count = 0;\n  auto err = ParseVectorDelimiters(count, [&](uoffset_t &) -> CheckedError {\n    Value val;\n    val.type = type;\n    ECHECK(ParseAnyValue(val, field, fieldn, nullptr, count, true));\n    field_stack_.push_back(std::make_pair(val, nullptr));\n    return NoError();\n  });\n  ECHECK(err);\n\n  const auto *force_align = field->attributes.Lookup(\"force_align\");\n  const size_t align =\n      force_align ? static_cast<size_t>(atoi(force_align->constant.c_str()))\n                  : 1;\n  const size_t len = count * InlineSize(type) / InlineAlignment(type);\n  const size_t elemsize = InlineAlignment(type);\n  if (align > 1) { builder_.ForceVectorAlignment(len, elemsize, align); }\n\n  builder_.StartVector(len, elemsize);\n  for (uoffset_t i = 0; i < count; i++) {\n    // start at the back, since we're building the data backwards.\n    auto &val = field_stack_.back().first;\n    switch (val.type.base_type) {\n      // clang-format off\n      #define FLATBUFFERS_TD(ENUM, IDLTYPE, CTYPE,...) \\\n        case BASE_TYPE_ ## ENUM: \\\n          if (IsStruct(val.type)) SerializeStruct(*val.type.struct_def, val); \\\n          else { \\\n             CTYPE elem; \\\n             ECHECK(atot(val.constant.c_str(), *this, &elem)); \\\n             builder_.PushElement(elem); \\\n          } \\\n          break;\n        FLATBUFFERS_GEN_TYPES(FLATBUFFERS_TD)\n      #undef FLATBUFFERS_TD\n      // clang-format on\n    }\n    field_stack_.pop_back();\n  }\n\n  builder_.ClearOffsets();\n  *ovalue = builder_.EndVector(count);\n\n  if (type.base_type == BASE_TYPE_STRUCT && type.struct_def->has_key) {\n    // We should sort this vector. Find the key first.\n    const FieldDef *key = nullptr;\n    for (auto it = type.struct_def->fields.vec.begin();\n         it != type.struct_def->fields.vec.end(); ++it) {\n      if ((*it)->key) {\n        key = (*it);\n        break;\n      }\n    }\n    FLATBUFFERS_ASSERT(key);\n    // Now sort it.\n    // We can't use std::sort because for structs the size is not known at\n    // compile time, and for tables our iterators dereference offsets, so can't\n    // be used to swap elements.\n    // And we can't use C qsort either, since that would force use to use\n    // globals, making parsing thread-unsafe.\n    // So for now, we use SimpleQsort above.\n    // TODO: replace with something better, preferably not recursive.\n\n    if (type.struct_def->fixed) {\n      const voffset_t offset = key->value.offset;\n      const size_t struct_size = type.struct_def->bytesize;\n      auto v =\n          reinterpret_cast<VectorOfAny *>(builder_.GetCurrentBufferPointer());\n      SimpleQsort<uint8_t>(\n          v->Data(), v->Data() + v->size() * type.struct_def->bytesize,\n          type.struct_def->bytesize,\n          [offset, key](const uint8_t *a, const uint8_t *b) -> bool {\n            return CompareSerializedScalars(a + offset, b + offset, *key);\n          },\n          [struct_size](uint8_t *a, uint8_t *b) {\n            // FIXME: faster?\n            for (size_t i = 0; i < struct_size; i++) { std::swap(a[i], b[i]); }\n          });\n    } else {\n      auto v = reinterpret_cast<Vector<Offset<Table>> *>(\n          builder_.GetCurrentBufferPointer());\n      // Here also can't use std::sort. We do have an iterator type for it,\n      // but it is non-standard as it will dereference the offsets, and thus\n      // can't be used to swap elements.\n      if (key->value.type.base_type == BASE_TYPE_STRING) {\n        SimpleQsort<Offset<Table>>(\n            v->data(), v->data() + v->size(), 1,\n            [key](const Offset<Table> *_a, const Offset<Table> *_b) -> bool {\n              return CompareTablesByStringKey(_a, _b, *key);\n            },\n            SwapSerializedTables);\n      } else {\n        SimpleQsort<Offset<Table>>(\n            v->data(), v->data() + v->size(), 1,\n            [key](const Offset<Table> *_a, const Offset<Table> *_b) -> bool {\n              return CompareTablesByScalarKey(_a, _b, *key);\n            },\n            SwapSerializedTables);\n      }\n    }\n  }\n  return NoError();\n}\nCheckedError Parser::ParseDecl() {\n  std::vector<std::string> dc = doc_comment_;\n  bool fixed = IsIdent(\"struct\");\n  if (!fixed && !IsIdent(\"table\")) return Error(\"declaration expected\");\n  NEXT();\n  std::string name = attribute_;\n  EXPECT(kTokenIdentifier);\n  StructDef *struct_def;\n  ECHECK(StartStruct(name, &struct_def));\n  struct_def->doc_comment = dc;\n  struct_def->fixed = fixed;\n  ECHECK(ParseMetaData(&struct_def->attributes));\n  struct_def->sortbysize =\n      struct_def->attributes.Lookup(\"original_order\") == nullptr && !fixed;\n  EXPECT('{');\n  while (token_ != '}') ECHECK(ParseField(*struct_def));\n  auto force_align = struct_def->attributes.Lookup(\"force_align\");\n  if (fixed) {\n    if (force_align) {\n      auto align = static_cast<size_t>(atoi(force_align->constant.c_str()));\n      if (force_align->type.base_type != BASE_TYPE_INT ||\n          align < struct_def->minalign || align > FLATBUFFERS_MAX_ALIGNMENT ||\n          align & (align - 1))\n        return Error(\n            \"force_align must be a power of two integer ranging from the\"\n            \"struct\\'s natural alignment to \" +\n            NumToString(FLATBUFFERS_MAX_ALIGNMENT));\n      struct_def->minalign = align;\n    }\n    if (!struct_def->bytesize) return Error(\"size 0 structs not allowed\");\n  }\n  struct_def->PadLastField(struct_def->minalign);\n  // Check if this is a table that has manual id assignments\n  auto &fields = struct_def->fields.vec;\n  if (!fixed && fields.size()) {\n    size_t num_id_fields = 0;\n    for (auto it = fields.begin(); it != fields.end(); ++it) {\n      if ((*it)->attributes.Lookup(\"id\")) num_id_fields++;\n    }\n    // If any fields have ids..\n    if (num_id_fields || opts.require_explicit_ids) {\n      // Then all fields must have them.\n      if (num_id_fields != fields.size()) {\n        if (opts.require_explicit_ids) {\n          return Error(\n              \"all fields must have an 'id' attribute when \"\n              \"--require-explicit-ids is used\");\n        } else {\n          return Error(\n              \"either all fields or no fields must have an 'id' attribute\");\n        }\n      }\n      // Simply sort by id, then the fields are the same as if no ids had\n      // been specified.\n      std::sort(fields.begin(), fields.end(), compareFieldDefs);\n      // Verify we have a contiguous set, and reassign vtable offsets.\n      FLATBUFFERS_ASSERT(fields.size() <=\n                         flatbuffers::numeric_limits<voffset_t>::max());\n      for (voffset_t i = 0; i < static_cast<voffset_t>(fields.size()); i++) {\n        auto &field = *fields[i];\n        const auto &id_str = field.attributes.Lookup(\"id\")->constant;\n        // Metadata values have a dynamic type, they can be `float`, 'int', or\n        // 'string`.\n        // The FieldIndexToOffset(i) expects the voffset_t so `id` is limited by\n        // this type.\n        voffset_t id = 0;\n        const auto done = !atot(id_str.c_str(), *this, &id).Check();\n        if (!done)\n          return Error(\"field id\\'s must be non-negative number, field: \" +\n                       field.name + \", id: \" + id_str);\n        if (i != id)\n          return Error(\"field id\\'s must be consecutive from 0, id \" +\n                       NumToString(i) + \" missing or set twice, field: \" +\n                       field.name + \", id: \" + id_str);\n        field.value.offset = FieldIndexToOffset(i);\n      }\n    }\n  }\n\n  ECHECK(\n      CheckClash(fields, struct_def, UnionTypeFieldSuffix(), BASE_TYPE_UNION));\n  ECHECK(CheckClash(fields, struct_def, \"Type\", BASE_TYPE_UNION));\n  ECHECK(CheckClash(fields, struct_def, \"_length\", BASE_TYPE_VECTOR));\n  ECHECK(CheckClash(fields, struct_def, \"Length\", BASE_TYPE_VECTOR));\n  ECHECK(CheckClash(fields, struct_def, \"_byte_vector\", BASE_TYPE_STRING));\n  ECHECK(CheckClash(fields, struct_def, \"ByteVector\", BASE_TYPE_STRING));\n  EXPECT('}');\n  types_.Add(current_namespace_->GetFullyQualifiedName(struct_def->name),\n             new Type(BASE_TYPE_STRUCT, struct_def, nullptr));\n  return NoError();\n}\n",
    "target": 1,
    "idx": 1030684,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "// context\n\nstatic bool\nfill_comdat_hash (bfd *abfd)\n{\n  bfd_byte *esymstart, *esym, *esymend;\n\n  /* Unfortunately, the PE format stores essential information in the\n     symbol table, of all places.  We need to extract that information\n     now, so that objdump and the linker will know how to handle the\n     section without worrying about the symbols.  We can't call\n     slurp_symtab, because the linker doesn't want the swapped symbols.  */\n\n  /* COMDAT sections are special.  The first symbol is the section\n     symbol, which tells what kind of COMDAT section it is.  The\n     second symbol is the \"comdat symbol\" - the one with the unique\n     name.  GNU uses the section symbol for the unique name; MS uses\n     \".text\" for every comdat section.  Sigh.  - DJ.  */\n\n  /* This is not mirrored in sec_to_styp_flags(), but there doesn't\n     seem to be a need to, either, and it would at best be rather messy.  */\n\n  if (! _bfd_coff_get_external_symbols (abfd))\n    return true;\n\n  esymstart = esym = (bfd_byte *) obj_coff_external_syms (abfd);\n  esymend = esym + obj_raw_syment_count (abfd) * bfd_coff_symesz (abfd);\n\n  for (struct internal_syment isym;\n       esym < esymend;\n       esym += (isym.n_numaux + 1) * bfd_coff_symesz (abfd))\n    {\n      char buf[SYMNMLEN + 1];\n      const char *symname;\n      flagword sec_flags = SEC_LINK_ONCE;\n\n      bfd_coff_swap_sym_in (abfd, esym, &isym);\n\n      /* According to the MSVC documentation, the first TWO entries\n\t with the section # are both of interest to us.  The first one\n\t is the \"section symbol\" (section name).  The second is the\n\t comdat symbol name.  Here, we've found the first qualifying\n\t entry; we distinguish it from the second with a state flag.\n\n\t In the case of gas-generated (at least until that is fixed)\n\t .o files, it isn't necessarily the second one.  It may be\n\t some other later symbol.\n\n\t Since gas also doesn't follow MS conventions and emits the\n\t section similar to .text$<name>, where <something> is the\n\t name we're looking for, we distinguish the two as follows:\n\n\t If the section name is simply a section name (no $) we\n\t presume it's MS-generated, and look at precisely the second\n\t symbol for the comdat name.  If the section name has a $, we\n\t assume it's gas-generated, and look for <something> (whatever\n\t follows the $) as the comdat symbol.  */\n\n      /* All 3 branches use this.  */\n      symname = _bfd_coff_internal_syment_name (abfd, &isym, buf);\n\n      /* PR 17512 file: 078-11867-0.004  */\n      if (symname == NULL)\n\t{\n\t  _bfd_error_handler (_(\"%pB: unable to load COMDAT section name\"),\n\t\t\t      abfd);\n\t  continue;\n\t}\n\n      union internal_auxent aux;\n\n      struct comdat_hash_entry needle;\n      needle.target_index = isym.n_scnum;\n\n      void **slot\n\t= htab_find_slot (pe_data (abfd)->comdat_hash, &needle, INSERT);\n      if (slot == NULL)\n\treturn false;\n\n      if (*slot == NULL)\n\t{\n\t  if (isym.n_numaux != 1)\n\t    aux.x_scn.x_comdat = 0;\n\t  else\n\t    {\n\t      /* PR 17512: file: e2cfe54f.  */\n\t      if (esym + isym.n_numaux * bfd_coff_symesz (abfd) >= esymend)\n\t\t{\n\t\t  /* xgettext:c-format */\n\t\t  _bfd_error_handler (_(\"%pB: warning: no symbol for\"\n\t\t\t\t\t\" section '%s' found\"),\n\t\t\t\t      abfd, symname);\n\t\t  continue;\n\t\t}\n\t      bfd_coff_swap_aux_in (abfd, (esym + bfd_coff_symesz (abfd)),\n\t\t\t\t    isym.n_type, isym.n_sclass, 0,\n\t\t\t\t    isym.n_numaux, &aux);\n\t    }\n\n\t  /* FIXME: Microsoft uses NODUPLICATES and ASSOCIATIVE, but\n\t     gnu uses ANY and SAME_SIZE.  Unfortunately, gnu doesn't\n\t     do the comdat symbols right.  So, until we can fix it to\n\t     do the right thing, we are temporarily disabling comdats\n\t     for the MS types (they're used in DLLs and C++, but we\n\t     don't support *their* C++ libraries anyway - DJ.  */\n\n\t  /* Cygwin does not follow the MS style, and uses ANY and\n\t     SAME_SIZE where NODUPLICATES and ASSOCIATIVE should be\n\t     used.  For Interix, we just do the right thing up\n\t     front.  */\n\n\t  switch (aux.x_scn.x_comdat)\n\t    {\n\t    case IMAGE_COMDAT_SELECT_NODUPLICATES:\n#ifdef STRICT_PE_FORMAT\n\t      sec_flags |= SEC_LINK_DUPLICATES_ONE_ONLY;\n#else\n\t      sec_flags &= ~SEC_LINK_ONCE;\n#endif\n\t      break;\n\n\t    case IMAGE_COMDAT_SELECT_ANY:\n\t      sec_flags |= SEC_LINK_DUPLICATES_DISCARD;\n\t      break;\n\n\t    case IMAGE_COMDAT_SELECT_SAME_SIZE:\n\t      sec_flags |= SEC_LINK_DUPLICATES_SAME_SIZE;\n\t      break;\n\n\t    case IMAGE_COMDAT_SELECT_EXACT_MATCH:\n\t      /* Not yet fully implemented ??? */\n\t      sec_flags |= SEC_LINK_DUPLICATES_SAME_CONTENTS;\n\t      break;\n\n\t      /* debug$S gets this case; other implications ???  */\n\n\t      /* There may be no symbol.  We'll search the whole\n\t\t table.  Is this the right place to play this game?\n\t\t Or should we do it when reading it in?  */\n\t    case IMAGE_COMDAT_SELECT_ASSOCIATIVE:\n#ifdef STRICT_PE_FORMAT\n\t      /* FIXME: This is not currently implemented.  */\n\t      sec_flags |= SEC_LINK_DUPLICATES_DISCARD;\n#else\n\t      sec_flags &= ~SEC_LINK_ONCE;\n#endif\n\t      break;\n\n\t    default:  /* 0 means \"no symbol\" */\n\t      /* debug$F gets this case; other implications ???  */\n\t      sec_flags |= SEC_LINK_DUPLICATES_DISCARD;\n\t      break;\n\t    }\n\n\t  *slot = bfd_zmalloc (sizeof (struct comdat_hash_entry));\n\t  if (*slot == NULL)\n\t    return false;\n\t  struct comdat_hash_entry *newentry = *slot;\n\t  newentry->sec_flags = sec_flags;\n\t  newentry->symname = bfd_strdup (symname);\n\t  newentry->target_index = isym.n_scnum;\n\t  newentry->isym = isym;\n\t  newentry->comdat_symbol = -1;\n\t}\n      else\n\t{\n\t  struct comdat_hash_entry *entry = *slot;\n\n\t  if (entry->comdat_symbol != -1)\n\t    continue;\n\n\t  char *target_name = strchr (entry->symname, '$');\n\t  if (target_name != NULL)\n\t    {\n\t      /* Gas mode: the first matching on partial name.  */\n\n\t      target_name += 1;\n#ifndef TARGET_UNDERSCORE\n#define TARGET_UNDERSCORE 0\n#endif\n\t      /* Is this the name we're looking for ?  */\n\t      if (strcmp (target_name,\n\t\t\t  symname + (TARGET_UNDERSCORE ? 1 : 0)) != 0)\n\t\t{\n\t\t  /* Not the name we're looking for */\n\t\t  continue;\n\t\t}\n\t    }\n\t  /* MSVC mode: the lexically second symbol (or drop through\n\t     from the above).  */\n\t  /* This must the second symbol with the section #.  It is\n\t     the actual symbol name.  Intel puts the two adjacent, but\n\t     Alpha (at least) spreads them out.  */\n\n\t  entry->comdat_symbol = (esym - esymstart) / bfd_coff_symesz (abfd);\n\t  entry->comdat_name = bfd_strdup (symname);\n\t}\n    }\n\n  return true;\n\n\nstatic bool\nhandle_COMDAT (bfd *abfd, flagword *sec_flags, const char *name,\n\t       asection *section)\n{\n  if (pe_data (abfd)->comdat_hash == NULL)\n    {\n      pe_data (abfd)->comdat_hash = htab_create (10, comdat_hashf, comdat_eqf,\n\t\t\t\t\t\t comdat_delf);\n      if (pe_data (abfd)->comdat_hash == NULL)\n\treturn false;\n    }\n\n  if (htab_elements (pe_data (abfd)->comdat_hash) == 0)\n    if (! fill_comdat_hash (abfd))\n      return false;\n\n  struct comdat_hash_entry *found\n    = find_flags (pe_data (abfd)->comdat_hash, section->target_index);\n  if (found != NULL)\n    {\n      struct internal_syment isym = found->isym;\n\n      /* If it isn't the stuff we're expecting, die;  The MS\n\t documentation is vague, but it appears that the second entry\n\t serves BOTH as the comdat symbol and the defining symbol\n\t record (either C_STAT or C_EXT, possibly with an aux entry\n\t with debug information if it's a function.)  It appears the\n\t only way to find the second one is to count.  (On Intel, they\n\t appear to be adjacent, but on Alpha, they have been found\n\t separated.)\n\n\t Here, we think we've found the first one, but there's some\n\t checking we can do to be sure.  */\n\n      if (! ((isym.n_sclass == C_STAT || isym.n_sclass == C_EXT)\n\t     && BTYPE (isym.n_type) == T_NULL && isym.n_value == 0))\n\t{\n\t  /* Malformed input files can trigger this test.\n\t     cf PR 21781.  */\n\t  _bfd_error_handler\n\t    (_(\"%pB: error: unexpected symbol '%s' in COMDAT section\"),\n\t     abfd, found->symname);\n\t  return false;\n\t}\n\n      /* FIXME LATER: MSVC generates section names like .text for\n\t comdats.  Gas generates names like .text$foo__Fv (in the case\n\t of a function).  See comment above for more.  */\n\n      if (isym.n_sclass == C_STAT && strcmp (name, found->symname) != 0)\n\t/* xgettext:c-format */\n\t_bfd_error_handler (_(\"%pB: warning: COMDAT symbol '%s'\"\n\t\t\t      \" does not match section name '%s'\"),\n\t\t\t    abfd, found->symname, name);\n\n      if (found->comdat_symbol != -1)\n\t{\n\t  if (! insert_coff_comdat_info (abfd, section, found->comdat_name,\n\t\t\t\t\t found->comdat_symbol))\n\t    return false;\n\t}\n      *sec_flags = *sec_flags | found->sec_flags;\n      return true;\n    }\n  *sec_flags = *sec_flags | SEC_LINK_ONCE;\n  return true;\n\n\nstatic bool\nstyp_to_sec_flags (bfd *abfd,\n\t\t   void * hdr,\n\t\t   const char *name,\n\t\t   asection *section,\n\t\t   flagword *flags_ptr)\n{\n  struct internal_scnhdr *internal_s = (struct internal_scnhdr *) hdr;\n  unsigned long styp_flags = internal_s->s_flags;\n  flagword sec_flags;\n  bool result = true;\n  bool is_dbg = false;\n\n  if (startswith (name, DOT_DEBUG)\n      || startswith (name, DOT_ZDEBUG)\n#ifdef COFF_LONG_SECTION_NAMES\n      || startswith (name, GNU_LINKONCE_WI)\n      || startswith (name, GNU_LINKONCE_WT)\n      /* FIXME: These definitions ought to be in a header file.  */\n#define GNU_DEBUGLINK\t\t\".gnu_debuglink\"\n#define GNU_DEBUGALTLINK\t\".gnu_debugaltlink\"\n      || startswith (name, GNU_DEBUGLINK)\n      || startswith (name, GNU_DEBUGALTLINK)\n#endif\n      || startswith (name, \".stab\"))\n    is_dbg = true;\n  /* Assume read only unless IMAGE_SCN_MEM_WRITE is specified.  */\n  sec_flags = SEC_READONLY;\n\n  /* If section disallows read, then set the NOREAD flag. */\n  if ((styp_flags & IMAGE_SCN_MEM_READ) == 0)\n    sec_flags |= SEC_COFF_NOREAD;\n\n  /* Process each flag bit in styp_flags in turn.  */\n  while (styp_flags)\n    {\n      unsigned long flag = styp_flags & - styp_flags;\n      char * unhandled = NULL;\n\n      styp_flags &= ~ flag;\n\n      /* We infer from the distinct read/write/execute bits the settings\n\t of some of the bfd flags; the actual values, should we need them,\n\t are also in pei_section_data (abfd, section)->pe_flags.  */\n\n      switch (flag)\n\t{\n\tcase STYP_DSECT:\n\t  unhandled = \"STYP_DSECT\";\n\t  break;\n\tcase STYP_GROUP:\n\t  unhandled = \"STYP_GROUP\";\n\t  break;\n\tcase STYP_COPY:\n\t  unhandled = \"STYP_COPY\";\n\t  break;\n\tcase STYP_OVER:\n\t  unhandled = \"STYP_OVER\";\n\t  break;\n#ifdef SEC_NEVER_LOAD\n\tcase STYP_NOLOAD:\n\t  sec_flags |= SEC_NEVER_LOAD;\n\t  break;\n#endif\n\tcase IMAGE_SCN_MEM_READ:\n\t  sec_flags &= ~SEC_COFF_NOREAD;\n\t  break;\n\tcase IMAGE_SCN_TYPE_NO_PAD:\n\t  /* Skip.  */\n\t  break;\n\tcase IMAGE_SCN_LNK_OTHER:\n\t  unhandled = \"IMAGE_SCN_LNK_OTHER\";\n\t  break;\n\tcase IMAGE_SCN_MEM_NOT_CACHED:\n\t  unhandled = \"IMAGE_SCN_MEM_NOT_CACHED\";\n\t  break;\n\tcase IMAGE_SCN_MEM_NOT_PAGED:\n\t  /* Generate a warning message rather using the 'unhandled'\n\t     variable as this will allow some .sys files generate by\n\t     other toolchains to be processed.  See bugzilla issue 196.  */\n\t  /* xgettext:c-format */\n\t  _bfd_error_handler (_(\"%pB: warning: ignoring section flag\"\n\t\t\t\t\" %s in section %s\"),\n\t\t\t      abfd, \"IMAGE_SCN_MEM_NOT_PAGED\", name);\n\t  break;\n\tcase IMAGE_SCN_MEM_EXECUTE:\n\t  sec_flags |= SEC_CODE;\n\t  break;\n\tcase IMAGE_SCN_MEM_WRITE:\n\t  sec_flags &= ~ SEC_READONLY;\n\t  break;\n\tcase IMAGE_SCN_MEM_DISCARDABLE:\n\t  /* The MS PE spec says that debug sections are DISCARDABLE,\n\t     but the presence of a DISCARDABLE flag does not necessarily\n\t     mean that a given section contains debug information.  Thus\n\t     we only set the SEC_DEBUGGING flag on sections that we\n\t     recognise as containing debug information.  */\n\t     if (is_dbg\n#ifdef _COMMENT\n\t      || strcmp (name, _COMMENT) == 0\n#endif\n\t      )\n\t    {\n\t      sec_flags |= SEC_DEBUGGING | SEC_READONLY;\n\t    }\n\t  break;\n\tcase IMAGE_SCN_MEM_SHARED:\n\t  sec_flags |= SEC_COFF_SHARED;\n\t  break;\n\tcase IMAGE_SCN_LNK_REMOVE:\n\t  if (!is_dbg)\n\t    sec_flags |= SEC_EXCLUDE;\n\t  break;\n\tcase IMAGE_SCN_CNT_CODE:\n\t  sec_flags |= SEC_CODE | SEC_ALLOC | SEC_LOAD;\n\t  break;\n\tcase IMAGE_SCN_CNT_INITIALIZED_DATA:\n\t  if (is_dbg)\n\t    sec_flags |= SEC_DEBUGGING;\n\t  else\n\t    sec_flags |= SEC_DATA | SEC_ALLOC | SEC_LOAD;\n\t  break;\n\tcase IMAGE_SCN_CNT_UNINITIALIZED_DATA:\n\t  sec_flags |= SEC_ALLOC;\n\t  break;\n\tcase IMAGE_SCN_LNK_INFO:\n\t  /* We mark these as SEC_DEBUGGING, but only if COFF_PAGE_SIZE is\n\t     defined.  coff_compute_section_file_positions uses\n\t     COFF_PAGE_SIZE to ensure that the low order bits of the\n\t     section VMA and the file offset match.  If we don't know\n\t     COFF_PAGE_SIZE, we can't ensure the correct correspondence,\n\t     and demand page loading of the file will fail.  */\n#ifdef COFF_PAGE_SIZE\n\t  sec_flags |= SEC_DEBUGGING;\n#endif\n\t  break;\n\tcase IMAGE_SCN_LNK_COMDAT:\n\t  /* COMDAT gets very special treatment.  */\n\t  if (!handle_COMDAT (abfd, &sec_flags, name, section))\n\t    result = false;\n\t  break;\n\tdefault:\n\t  /* Silently ignore for now.  */\n\t  break;\n\t}\n\n      /* If the section flag was not handled, report it here.  */\n      if (unhandled != NULL)\n\t{\n\t  _bfd_error_handler\n\t    /* xgettext:c-format */\n\t    (_(\"%pB (%s): section flag %s (%#lx) ignored\"),\n\t     abfd, name, unhandled, flag);\n\t  result = false;\n\t}\n    }\n\n  if ((bfd_applicable_section_flags (abfd) & SEC_SMALL_DATA) != 0\n      && (startswith (name, \".sbss\")\n\t  || startswith (name, \".sdata\")))\n    sec_flags |= SEC_SMALL_DATA;\n\n#if defined (COFF_LONG_SECTION_NAMES) && defined (COFF_SUPPORT_GNU_LINKONCE)\n  /* As a GNU extension, if the name begins with .gnu.linkonce, we\n     only link a single copy of the section.  This is used to support\n     g++.  g++ will emit each template expansion in its own section.\n     The symbols will be defined as weak, so that multiple definitions\n     are permitted.  The GNU linker extension is to actually discard\n     all but one of the sections.  */\n  if (startswith (name, \".gnu.linkonce\"))\n    sec_flags |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;\n#endif\n\n  if (flags_ptr)\n    * flags_ptr = sec_flags;\n\n  return result;\n\n\n\nbfd_cleanup\ncoff_real_object_p (bfd *abfd,\n\t\t    unsigned nscns,\n\t\t    struct internal_filehdr *internal_f,\n\t\t    struct internal_aouthdr *internal_a)\n{\n  flagword oflags = abfd->flags;\n  bfd_vma ostart = bfd_get_start_address (abfd);\n  void * tdata;\n  void * tdata_save;\n  bfd_size_type readsize;\t/* Length of file_info.  */\n  unsigned int scnhsz;\n  char *external_sections;\n\n  if (!(internal_f->f_flags & F_RELFLG))\n    abfd->flags |= HAS_RELOC;\n  if ((internal_f->f_flags & F_EXEC))\n    abfd->flags |= EXEC_P;\n  if (!(internal_f->f_flags & F_LNNO))\n    abfd->flags |= HAS_LINENO;\n  if (!(internal_f->f_flags & F_LSYMS))\n    abfd->flags |= HAS_LOCALS;\n\n  /* FIXME: How can we set D_PAGED correctly?  */\n  if ((internal_f->f_flags & F_EXEC) != 0)\n    abfd->flags |= D_PAGED;\n\n  abfd->symcount = internal_f->f_nsyms;\n  if (internal_f->f_nsyms)\n    abfd->flags |= HAS_SYMS;\n\n  if (internal_a != (struct internal_aouthdr *) NULL)\n    abfd->start_address = internal_a->entry;\n  else\n    abfd->start_address = 0;\n\n  /* Set up the tdata area.  ECOFF uses its own routine, and overrides\n     abfd->flags.  */\n  tdata_save = abfd->tdata.any;\n  tdata = bfd_coff_mkobject_hook (abfd, (void *) internal_f, (void *) internal_a);\n  if (tdata == NULL)\n    goto fail2;\n\n  scnhsz = bfd_coff_scnhsz (abfd);\n  readsize = (bfd_size_type) nscns * scnhsz;\n  external_sections = (char *) _bfd_alloc_and_read (abfd, readsize, readsize);\n  if (!external_sections)\n    goto fail;\n\n  /* Set the arch/mach *before* swapping in sections; section header swapping\n     may depend on arch/mach info.  */\n  if (! bfd_coff_set_arch_mach_hook (abfd, (void *) internal_f))\n    goto fail;\n\n  /* Now copy data as required; construct all asections etc.  */\n  if (nscns != 0)\n    {\n      unsigned int i;\n      for (i = 0; i < nscns; i++)\n\t{\n\t  struct internal_scnhdr tmp;\n\t  bfd_coff_swap_scnhdr_in (abfd,\n\t\t\t\t   (void *) (external_sections + i * scnhsz),\n\t\t\t\t   (void *) & tmp);\n\t  if (! make_a_section_from_file (abfd, &tmp, i + 1))\n\t    goto fail;\n\t}\n    }\n\n  _bfd_coff_free_symbols (abfd);\n  return coff_object_cleanup;\n\n fail:\n  coff_object_cleanup (abfd);\n  _bfd_coff_free_symbols (abfd);\n  bfd_release (abfd, tdata);\n fail2:\n  abfd->tdata.any = tdata_save;\n  abfd->flags = oflags;\n  abfd->start_address = ostart;\n  return NULL;\n}\n\nbfd_cleanup\ncoff_object_p (bfd *abfd)\n{\n  bfd_size_type filhsz;\n  bfd_size_type aoutsz;\n  unsigned int nscns;\n  void * filehdr;\n  struct internal_filehdr internal_f;\n  struct internal_aouthdr internal_a;\n\n  /* Figure out how much to read.  */\n  filhsz = bfd_coff_filhsz (abfd);\n  aoutsz = bfd_coff_aoutsz (abfd);\n\n  filehdr = _bfd_alloc_and_read (abfd, filhsz, filhsz);\n  if (filehdr == NULL)\n    {\n      if (bfd_get_error () != bfd_error_system_call)\n\tbfd_set_error (bfd_error_wrong_format);\n      return NULL;\n    }\n  bfd_coff_swap_filehdr_in (abfd, filehdr, &internal_f);\n  bfd_release (abfd, filehdr);\n\n  /* The XCOFF format has two sizes for the f_opthdr.  SMALL_AOUTSZ\n     (less than aoutsz) used in object files and AOUTSZ (equal to\n     aoutsz) in executables.  The bfd_coff_swap_aouthdr_in function\n     expects this header to be aoutsz bytes in length, so we use that\n     value in the call to bfd_alloc below.  But we must be careful to\n     only read in f_opthdr bytes in the call to bfd_read.  We should\n     also attempt to catch corrupt or non-COFF binaries with a strange\n     value for f_opthdr.  */\n  if (! bfd_coff_bad_format_hook (abfd, &internal_f)\n      || internal_f.f_opthdr > aoutsz)\n    {\n      bfd_set_error (bfd_error_wrong_format);\n      return NULL;\n    }\n  nscns = internal_f.f_nscns;\n\n  if (internal_f.f_opthdr)\n    {\n      void * opthdr;\n\n      opthdr = _bfd_alloc_and_read (abfd, aoutsz, internal_f.f_opthdr);\n      if (opthdr == NULL)\n\treturn NULL;\n      /* PR 17512: file: 11056-1136-0.004.  */\n      if (internal_f.f_opthdr < aoutsz)\n\tmemset (((char *) opthdr) + internal_f.f_opthdr, 0,\n\t\taoutsz - internal_f.f_opthdr);\n\n      bfd_coff_swap_aouthdr_in (abfd, opthdr, (void *) &internal_a);\n      bfd_release (abfd, opthdr);\n    }\n\n  return coff_real_object_p (abfd, nscns, &internal_f,\n\t\t\t     (internal_f.f_opthdr != 0\n\t\t\t      ? &internal_a\n\t\t\t      : (struct internal_aouthdr *) NULL));\n}\n\nbool\nbfd_check_format_matches (bfd *abfd, bfd_format format, char ***matching)\n{\n  extern const bfd_target binary_vec;\n#if BFD_SUPPORTS_PLUGINS\n  extern const bfd_target plugin_vec;\n#endif\n  const bfd_target * const *target;\n  const bfd_target **matching_vector = NULL;\n  const bfd_target *save_targ, *right_targ, *ar_right_targ, *match_targ;\n  int match_count, best_count, best_match;\n  int ar_match_index;\n  unsigned int initial_section_id = _bfd_section_id;\n  struct bfd_preserve preserve, preserve_match;\n  bfd_cleanup cleanup = NULL;\n  bfd_error_handler_type orig_error_handler;\n  static int in_check_format;\n\n  if (matching != NULL)\n    *matching = NULL;\n\n  if (!bfd_read_p (abfd)\n      || (unsigned int) abfd->format >= (unsigned int) bfd_type_end)\n    {\n      bfd_set_error (bfd_error_invalid_operation);\n      return false;\n    }\n\n  if (abfd->format != bfd_unknown)\n    return abfd->format == format;\n\n  if (matching != NULL || *bfd_associated_vector != NULL)\n    {\n      size_t amt;\n\n      amt = sizeof (*matching_vector) * 2 * _bfd_target_vector_entries;\n      matching_vector = (const bfd_target **) bfd_malloc (amt);\n      if (!matching_vector)\n\treturn false;\n    }\n\n  /* Presume the answer is yes.  */\n  abfd->format = format;\n  save_targ = abfd->xvec;\n\n  /* Don't report errors on recursive calls checking the first element\n     of an archive.  */\n  if (in_check_format)\n    orig_error_handler = bfd_set_error_handler (null_error_handler);\n  else\n    orig_error_handler = _bfd_set_error_handler_caching (abfd);\n  ++in_check_format;\n\n  preserve_match.marker = NULL;\n  if (!bfd_preserve_save (abfd, &preserve, NULL))\n    goto err_ret;\n\n  /* If the target type was explicitly specified, just check that target.  */\n  if (!abfd->target_defaulted)\n    {\n      if (bfd_seek (abfd, 0, SEEK_SET) != 0)\t/* rewind! */\n\tgoto err_ret;\n\n      cleanup = BFD_SEND_FMT (abfd, _bfd_check_format, (abfd));\n\n      if (cleanup)\n\tgoto ok_ret;\n\n      /* For a long time the code has dropped through to check all\n\t targets if the specified target was wrong.  I don't know why,\n\t and I'm reluctant to change it.  However, in the case of an\n\t archive, it can cause problems.  If the specified target does\n\t not permit archives (e.g., the binary target), then we should\n\t not allow some other target to recognize it as an archive, but\n\t should instead allow the specified target to recognize it as an\n\t object.  When I first made this change, it broke the PE target,\n\t because the specified pei-i386 target did not recognize the\n\t actual pe-i386 archive.  Since there may be other problems of\n\t this sort, I changed this test to check only for the binary\n\t target.  */\n      if (format == bfd_archive && save_targ == &binary_vec)\n\tgoto err_unrecog;\n    }\n\n  /* Since the target type was defaulted, check them all in the hope\n     that one will be uniquely recognized.  */\n  right_targ = NULL;\n  ar_right_targ = NULL;\n  match_targ = NULL;\n  best_match = 256;\n  best_count = 0;\n  match_count = 0;\n  ar_match_index = _bfd_target_vector_entries;\n\n  for (target = bfd_target_vector; *target != NULL; target++)\n    {\n      void **high_water;\n\n      /* The binary target matches anything, so don't return it when\n\t searching.  Don't match the plugin target if we have another\n\t alternative since we want to properly set the input format\n\t before allowing a plugin to claim the file.  Also, don't\n\t check the default target twice.  */\n      if (*target == &binary_vec\n#if BFD_SUPPORTS_PLUGINS\n\t  || (match_count != 0 && *target == &plugin_vec)\n#endif\n\t  || (!abfd->target_defaulted && *target == save_targ))\n\tcontinue;\n\n      /* If we already tried a match, the bfd is modified and may\n\t have sections attached, which will confuse the next\n\t _bfd_check_format call.  */\n      bfd_reinit (abfd, initial_section_id, &preserve, cleanup);\n      /* Free bfd_alloc memory too.  If we have matched and preserved\n\t a target then the high water mark is that much higher.  */\n      if (preserve_match.marker)\n\thigh_water = &preserve_match.marker;\n      else\n\thigh_water = &preserve.marker;\n      bfd_release (abfd, *high_water);\n      *high_water = bfd_alloc (abfd, 1);\n\n      /* Change BFD's target temporarily.  */\n      abfd->xvec = *target;\n\n      if (bfd_seek (abfd, 0, SEEK_SET) != 0)\n\tgoto err_ret;\n\n      cleanup = BFD_SEND_FMT (abfd, _bfd_check_format, (abfd));\n      if (cleanup)\n\t{\n\t  int match_priority = abfd->xvec->match_priority;\n#if BFD_SUPPORTS_PLUGINS\n\t  /* If this object can be handled by a plugin, give that the\n\t     lowest priority; objects both handled by a plugin and\n\t     with an underlying object format will be claimed\n\t     separately by the plugin.  */\n\t  if (*target == &plugin_vec)\n\t    match_priority = (*target)->match_priority;\n#endif\n\n\t  if (abfd->format != bfd_archive\n\t      || (bfd_has_map (abfd)\n\t\t  && bfd_get_error () != bfd_error_wrong_object_format))\n\t    {\n\t      /* If this is the default target, accept it, even if\n\t\t other targets might match.  People who want those\n\t\t other targets have to set the GNUTARGET variable.  */\n\t      if (abfd->xvec == bfd_default_vector[0])\n\t\tgoto ok_ret;\n\n\t      if (matching_vector)\n\t\tmatching_vector[match_count] = abfd->xvec;\n\t      match_count++;\n\n\t      if (match_priority < best_match)\n\t\t{\n\t\t  best_match = match_priority;\n\t\t  best_count = 0;\n\t\t}\n\t      if (match_priority <= best_match)\n\t\t{\n\t\t  /* This format checks out as ok!  */\n\t\t  right_targ = abfd->xvec;\n\t\t  best_count++;\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      /* An archive with no armap or objects of the wrong\n\t\t type.  We want this target to match if we get no\n\t\t better matches.  */\n\t      if (ar_right_targ != bfd_default_vector[0])\n\t\tar_right_targ = *target;\n\t      if (matching_vector)\n\t\tmatching_vector[ar_match_index] = *target;\n\t      ar_match_index++;\n\t    }\n\n\t  if (preserve_match.marker == NULL)\n\t    {\n\t      match_targ = abfd->xvec;\n\t      if (!bfd_preserve_save (abfd, &preserve_match, cleanup))\n\t\tgoto err_ret;\n\t      cleanup = NULL;\n\t    }\n\t}\n    }\n\n  if (best_count == 1)\n    match_count = 1;\n\n  if (match_count == 0)\n    {\n      /* Try partial matches.  */\n      right_targ = ar_right_targ;\n\n      if (right_targ == bfd_default_vector[0])\n\t{\n\t  match_count = 1;\n\t}\n      else\n\t{\n\t  match_count = ar_match_index - _bfd_target_vector_entries;\n\n\t  if (matching_vector && match_count > 1)\n\t    memcpy (matching_vector,\n\t\t    matching_vector + _bfd_target_vector_entries,\n\t\t    sizeof (*matching_vector) * match_count);\n\t}\n    }\n\n  /* We have more than one equally good match.  If any of the best\n     matches is a target in config.bfd targ_defvec or targ_selvecs,\n     choose it.  */\n  if (match_count > 1)\n    {\n      const bfd_target * const *assoc = bfd_associated_vector;\n\n      while ((right_targ = *assoc++) != NULL)\n\t{\n\t  int i = match_count;\n\n\t  while (--i >= 0)\n\t    if (matching_vector[i] == right_targ\n\t\t&& right_targ->match_priority <= best_match)\n\t      break;\n\n\t  if (i >= 0)\n\t    {\n\t      match_count = 1;\n\t      break;\n\t    }\n\t}\n    }\n\n  /* We still have more than one equally good match, and at least some\n     of the targets support match priority.  Choose the first of the\n     best matches.  */\n  if (matching_vector && match_count > 1 && best_count != match_count)\n    {\n      int i;\n\n      for (i = 0; i < match_count; i++)\n\t{\n\t  right_targ = matching_vector[i];\n\t  if (right_targ->match_priority <= best_match)\n\t    break;\n\t}\n      match_count = 1;\n    }\n\n  /* There is way too much undoing of half-known state here.  We\n     really shouldn't iterate on live bfd's.  Note that saving the\n     whole bfd and restoring it would be even worse; the first thing\n     you notice is that the cached bfd file position gets out of sync.  */\n  if (preserve_match.marker != NULL)\n    cleanup = bfd_preserve_restore (abfd, &preserve_match);\n\n  if (match_count == 1)\n    {\n      abfd->xvec = right_targ;\n      /* If we come out of the loop knowing that the last target that\n\t matched is the one we want, then ABFD should still be in a usable\n\t state (except possibly for XVEC).  This is not just an\n\t optimisation.  In the case of plugins a match against the\n\t plugin target can result in the bfd being changed such that\n\t it no longer matches the plugin target, nor will it match\n\t RIGHT_TARG again.  */\n      if (match_targ != right_targ)\n\t{\n\t  bfd_reinit (abfd, initial_section_id, &preserve, cleanup);\n\t  bfd_release (abfd, preserve.marker);\n\t  if (bfd_seek (abfd, 0, SEEK_SET) != 0)\n\t    goto err_ret;\n\t  cleanup = BFD_SEND_FMT (abfd, _bfd_check_format, (abfd));\n\t  BFD_ASSERT (cleanup != NULL);\n\t}\n\n    ok_ret:\n      /* If the file was opened for update, then `output_has_begun'\n\t some time ago when the file was created.  Do not recompute\n\t sections sizes or alignments in _bfd_set_section_contents.\n\t We can not set this flag until after checking the format,\n\t because it will interfere with creation of BFD sections.  */\n      if (abfd->direction == both_direction)\n\tabfd->output_has_begun = true;\n\n      free (matching_vector);\n      if (preserve_match.marker != NULL)\n\tbfd_preserve_finish (abfd, &preserve_match);\n      bfd_preserve_finish (abfd, &preserve);\n      bfd_set_error_handler (orig_error_handler);\n\n      struct per_xvec_message **list = _bfd_per_xvec_warn (abfd->xvec, 0);\n      if (*list)\n\tprint_warnmsg (list);\n      list = _bfd_per_xvec_warn (NULL, 0);\n      for (size_t i = 0; i < _bfd_target_vector_entries + 1; i++)\n\tclear_warnmsg (list++);\n      --in_check_format;\n\n      /* File position has moved, BTW.  */\n      return true;\n    }\n\n  if (match_count == 0)\n    {\n    err_unrecog:\n      bfd_set_error (bfd_error_file_not_recognized);\n    err_ret:\n      if (cleanup)\n\tcleanup (abfd);\n      abfd->xvec = save_targ;\n      abfd->format = bfd_unknown;\n      free (matching_vector);\n      goto out;\n    }\n\n  /* Restore original target type and format.  */\n  abfd->xvec = save_targ;\n  abfd->format = bfd_unknown;\n  bfd_set_error (bfd_error_file_ambiguously_recognized);\n\n  if (matching)\n    {\n      *matching = (char **) matching_vector;\n      matching_vector[match_count] = NULL;\n      /* Return target names.  This is a little nasty.  Maybe we\n\t should do another bfd_malloc?  */\n      while (--match_count >= 0)\n\t{\n\t  const char *name = matching_vector[match_count]->name;\n\t  *(const char **) &matching_vector[match_count] = name;\n\t}\n    }\n  else\n    free (matching_vector);\n  if (cleanup)\n    cleanup (abfd);\n out:\n  if (preserve_match.marker != NULL)\n    bfd_preserve_finish (abfd, &preserve_match);\n  bfd_preserve_restore (abfd, &preserve);\n  bfd_set_error_handler (orig_error_handler);\n  struct per_xvec_message **list = _bfd_per_xvec_warn (NULL, 0);\n  struct per_xvec_message **one = NULL;\n  for (size_t i = 0; i < _bfd_target_vector_entries + 1; i++)\n    {\n      if (list[i])\n\t{\n\t  if (!one)\n\t    one = list + i;\n\t  else\n\t    {\n\t      one = NULL;\n\t      break;\n\t    }\n\t}\n    }\n  if (one)\n    print_warnmsg (one);\n  for (size_t i = 0; i < _bfd_target_vector_entries + 1; i++)\n    clear_warnmsg (list++);\n  --in_check_format;\n  return false;\n}\n\nbool\nbfd_check_format (bfd *abfd, bfd_format format)\n{\n  return bfd_check_format_matches (abfd, format, NULL);\n}\n\nstatic int ExecuteFilesOnyByOne(int argc, char **argv,\n                                int (*callback)(const uint8_t *data,\n                                                size_t         size)) {\n\n  unsigned char *buf = (unsigned char *)malloc(MAX_FILE);\n\n  __asan_poison_memory_region(buf, MAX_FILE);\n  ssize_t prev_length = 0;\n\n  for (int i = 1; i < argc; i++) {\n\n    int fd = 0;\n\n    if (strcmp(argv[i], \"-\") != 0) { fd = open(argv[i], O_RDONLY); }\n\n    if (fd == -1) { continue; }\n\n#ifndef __HAIKU__\n    ssize_t length = syscall(SYS_read, fd, buf, MAX_FILE);\n#else\n    ssize_t length = _kern_read(fd, buf, MAX_FILE);\n#endif  // HAIKU\n\n    if (length > 0) {\n\n      if (length < prev_length) {\n\n        __asan_poison_memory_region(buf + length, prev_length - length);\n\n      } else {\n\n        __asan_unpoison_memory_region(buf + prev_length, length - prev_length);\n\n      }\n\n      prev_length = length;\n\n      printf(\"Reading %zu bytes from %s\\n\", length, argv[i]);\n      callback(buf, length);\n      printf(\"Execution successful.\\n\");\n\n    }\n\n    if (fd > 0) { close(fd); }\n\n  }\n\n  free(buf);\n  return 0;\n\n}\n\n__attribute__((weak)) int main(int argc, char **argv) {\n\n  // Enable if LLVMFuzzerTestOneInput() has the weak attribute\n  /*\n    if (!LLVMFuzzerTestOneInput) {\n\n      fprintf(stderr, \"Error: function LLVMFuzzerTestOneInput() not found!\\n\");\n      abort();\n\n    }\n\n  */\n\n  if (argc < 2 || strncmp(argv[1], \"-h\", 2) == 0)\n    printf(\n        \"============================== INFO ================================\\n\"\n        \"This binary is built for afl++.\\n\"\n        \"To run the target function on individual input(s) execute:\\n\"\n        \"  %s INPUT_FILE1 [INPUT_FILE2 ... ]\\n\"\n        \"To fuzz with afl-fuzz execute:\\n\"\n        \"  afl-fuzz [afl-flags] -- %s [-N]\\n\"\n        \"afl-fuzz will run N iterations before re-spawning the process \"\n        \"(default: \"\n        \"INT_MAX)\\n\"\n        \"For stdin input processing, pass '-' as single command line option.\\n\"\n        \"For file input processing, pass '@@' as single command line option.\\n\"\n        \"To use with afl-cmin or afl-cmin.bash pass '-' as single command line \"\n        \"option\\n\"\n        \"===================================================================\\n\",\n        argv[0], argv[0]);\n\n  return LLVMFuzzerRunDriver(&argc, &argv, LLVMFuzzerTestOneInput);\n\n}\n\n\n// target function\n\nstatic void\ncomdat_delf (void *ent)\n{\n  struct comdat_hash_entry *e = ent;\n  free (e->symname);\n  free (e);\n\nstatic bool\nfill_comdat_hash (bfd *abfd)\n{\n  bfd_byte *esymstart, *esym, *esymend;\n\n  /* Unfortunately, the PE format stores essential information in the\n     symbol table, of all places.  We need to extract that information\n     now, so that objdump and the linker will know how to handle the\n     section without worrying about the symbols.  We can't call\n     slurp_symtab, because the linker doesn't want the swapped symbols.  */\n\n  /* COMDAT sections are special.  The first symbol is the section\n     symbol, which tells what kind of COMDAT section it is.  The\n     second symbol is the \"comdat symbol\" - the one with the unique\n     name.  GNU uses the section symbol for the unique name; MS uses\n     \".text\" for every comdat section.  Sigh.  - DJ.  */\n\n  /* This is not mirrored in sec_to_styp_flags(), but there doesn't\n     seem to be a need to, either, and it would at best be rather messy.  */\n\n  if (! _bfd_coff_get_external_symbols (abfd))\n    return true;\n\n  esymstart = esym = (bfd_byte *) obj_coff_external_syms (abfd);\n  esymend = esym + obj_raw_syment_count (abfd) * bfd_coff_symesz (abfd);\n\n  for (struct internal_syment isym;\n       esym < esymend;\n       esym += (isym.n_numaux + 1) * bfd_coff_symesz (abfd))\n    {\n      char buf[SYMNMLEN + 1];\n      const char *symname;\n      flagword sec_flags = SEC_LINK_ONCE;\n\n      bfd_coff_swap_sym_in (abfd, esym, &isym);\n\n      /* According to the MSVC documentation, the first TWO entries\n\t with the section # are both of interest to us.  The first one\n\t is the \"section symbol\" (section name).  The second is the\n\t comdat symbol name.  Here, we've found the first qualifying\n\t entry; we distinguish it from the second with a state flag.\n\n\t In the case of gas-generated (at least until that is fixed)\n\t .o files, it isn't necessarily the second one.  It may be\n\t some other later symbol.\n\n\t Since gas also doesn't follow MS conventions and emits the\n\t section similar to .text$<name>, where <something> is the\n\t name we're looking for, we distinguish the two as follows:\n\n\t If the section name is simply a section name (no $) we\n\t presume it's MS-generated, and look at precisely the second\n\t symbol for the comdat name.  If the section name has a $, we\n\t assume it's gas-generated, and look for <something> (whatever\n\t follows the $) as the comdat symbol.  */\n\n      /* All 3 branches use this.  */\n      symname = _bfd_coff_internal_syment_name (abfd, &isym, buf);\n\n      /* PR 17512 file: 078-11867-0.004  */\n      if (symname == NULL)\n\t{\n\t  _bfd_error_handler (_(\"%pB: unable to load COMDAT section name\"),\n\t\t\t      abfd);\n\t  continue;\n\t}\n\n      union internal_auxent aux;\n\n      struct comdat_hash_entry needle;\n      needle.target_index = isym.n_scnum;\n\n      void **slot\n\t= htab_find_slot (pe_data (abfd)->comdat_hash, &needle, INSERT);\n      if (slot == NULL)\n\treturn false;\n\n      if (*slot == NULL)\n\t{\n\t  if (isym.n_numaux == 0)\n\t    aux.x_scn.x_comdat = 0;\n\t  else\n\t    {\n\t      /* PR 17512: file: e2cfe54f.  */\n\t      if (esym + isym.n_numaux * bfd_coff_symesz (abfd) >= esymend)\n\t\t{\n\t\t  /* xgettext:c-format */\n\t\t  _bfd_error_handler (_(\"%pB: warning: no symbol for\"\n\t\t\t\t\t\" section '%s' found\"),\n\t\t\t\t      abfd, symname);\n\t\t  continue;\n\t\t}\n\t      bfd_coff_swap_aux_in (abfd, (esym + bfd_coff_symesz (abfd)),\n\t\t\t\t    isym.n_type, isym.n_sclass, 0,\n\t\t\t\t    isym.n_numaux, &aux);\n\t    }\n\n\t  /* FIXME: Microsoft uses NODUPLICATES and ASSOCIATIVE, but\n\t     gnu uses ANY and SAME_SIZE.  Unfortunately, gnu doesn't\n\t     do the comdat symbols right.  So, until we can fix it to\n\t     do the right thing, we are temporarily disabling comdats\n\t     for the MS types (they're used in DLLs and C++, but we\n\t     don't support *their* C++ libraries anyway - DJ.  */\n\n\t  /* Cygwin does not follow the MS style, and uses ANY and\n\t     SAME_SIZE where NODUPLICATES and ASSOCIATIVE should be\n\t     used.  For Interix, we just do the right thing up\n\t     front.  */\n\n\t  switch (aux.x_scn.x_comdat)\n\t    {\n\t    case IMAGE_COMDAT_SELECT_NODUPLICATES:\n#ifdef STRICT_PE_FORMAT\n\t      sec_flags |= SEC_LINK_DUPLICATES_ONE_ONLY;\n#else\n\t      sec_flags &= ~SEC_LINK_ONCE;\n#endif\n\t      break;\n\n\t    case IMAGE_COMDAT_SELECT_ANY:\n\t      sec_flags |= SEC_LINK_DUPLICATES_DISCARD;\n\t      break;\n\n\t    case IMAGE_COMDAT_SELECT_SAME_SIZE:\n\t      sec_flags |= SEC_LINK_DUPLICATES_SAME_SIZE;\n\t      break;\n\n\t    case IMAGE_COMDAT_SELECT_EXACT_MATCH:\n\t      /* Not yet fully implemented ??? */\n\t      sec_flags |= SEC_LINK_DUPLICATES_SAME_CONTENTS;\n\t      break;\n\n\t      /* debug$S gets this case; other implications ???  */\n\n\t      /* There may be no symbol.  We'll search the whole\n\t\t table.  Is this the right place to play this game?\n\t\t Or should we do it when reading it in?  */\n\t    case IMAGE_COMDAT_SELECT_ASSOCIATIVE:\n#ifdef STRICT_PE_FORMAT\n\t      /* FIXME: This is not currently implemented.  */\n\t      sec_flags |= SEC_LINK_DUPLICATES_DISCARD;\n#else\n\t      sec_flags &= ~SEC_LINK_ONCE;\n#endif\n\t      break;\n\n\t    default:  /* 0 means \"no symbol\" */\n\t      /* debug$F gets this case; other implications ???  */\n\t      sec_flags |= SEC_LINK_DUPLICATES_DISCARD;\n\t      break;\n\t    }\n\n\t  *slot = bfd_zmalloc (sizeof (struct comdat_hash_entry));\n\t  if (*slot == NULL)\n\t    return false;\n\t  struct comdat_hash_entry *newentry = *slot;\n\t  newentry->sec_flags = sec_flags;\n\t  newentry->symname = bfd_strdup (symname);\n\t  newentry->target_index = isym.n_scnum;\n\t  newentry->isym = isym;\n\t  newentry->comdat_symbol = -1;\n\t}\n      else\n\t{\n\t  struct comdat_hash_entry *entry = *slot;\n\n\t  if (entry->comdat_symbol != -1)\n\t    continue;\n\n\t  char *target_name = strchr (entry->symname, '$');\n\t  if (target_name != NULL)\n\t    {\n\t      /* Gas mode: the first matching on partial name.  */\n\n\t      target_name += 1;\n#ifndef TARGET_UNDERSCORE\n#define TARGET_UNDERSCORE 0\n#endif\n\t      /* Is this the name we're looking for ?  */\n\t      if (strcmp (target_name,\n\t\t\t  symname + (TARGET_UNDERSCORE ? 1 : 0)) != 0)\n\t\t{\n\t\t  /* Not the name we're looking for */\n\t\t  continue;\n\t\t}\n\t    }\n\t  /* MSVC mode: the lexically second symbol (or drop through\n\t     from the above).  */\n\t  /* This must the second symbol with the section #.  It is\n\t     the actual symbol name.  Intel puts the two adjacent, but\n\t     Alpha (at least) spreads them out.  */\n\n\t  entry->comdat_symbol = (esym - esymstart) / bfd_coff_symesz (abfd);\n\t  entry->comdat_name = bfd_strdup (symname);\n\t}\n    }\n\n  return true;\n",
    "target": 1,
    "idx": 1061822,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic void enqueue_lr_jobs(AV1LrSync *lr_sync, AV1LrStruct *lr_ctxt,\n                            AV1_COMMON *cm) {\n  FilterFrameCtxt *ctxt = lr_ctxt->ctxt;\n\n  const int num_planes = av1_num_planes(cm);\n  AV1LrMTInfo *lr_job_queue = lr_sync->job_queue;\n  int32_t lr_job_counter[2], num_even_lr_jobs = 0;\n  lr_sync->jobs_enqueued = 0;\n  lr_sync->jobs_dequeued = 0;\n\n  for (int plane = 0; plane < num_planes; plane++) {\n    if (cm->rst_info[plane].frame_restoration_type == RESTORE_NONE) continue;\n    num_even_lr_jobs =\n        num_even_lr_jobs + ((ctxt[plane].rsi->vert_units_per_tile + 1) >> 1);\n  }\n  lr_job_counter[0] = 0;\n  lr_job_counter[1] = num_even_lr_jobs;\n\n  for (int plane = 0; plane < num_planes; plane++) {\n    if (cm->rst_info[plane].frame_restoration_type == RESTORE_NONE) continue;\n    const int is_uv = plane > 0;\n    const int ss_y = is_uv && cm->seq_params.subsampling_y;\n\n    AV1PixelRect tile_rect = ctxt[plane].tile_rect;\n    const int unit_size = ctxt[plane].rsi->restoration_unit_size;\n\n    const int tile_h = tile_rect.bottom - tile_rect.top;\n    const int ext_size = unit_size * 3 / 2;\n\n    int y0 = 0, i = 0;\n    while (y0 < tile_h) {\n      int remaining_h = tile_h - y0;\n      int h = (remaining_h < ext_size) ? remaining_h : unit_size;\n\n      RestorationTileLimits limits;\n      limits.v_start = tile_rect.top + y0;\n      limits.v_end = tile_rect.top + y0 + h;\n      assert(limits.v_end <= tile_rect.bottom);\n      // Offset the tile upwards to align with the restoration processing stripe\n      const int voffset = RESTORATION_UNIT_OFFSET >> ss_y;\n      limits.v_start = AOMMAX(tile_rect.top, limits.v_start - voffset);\n      if (limits.v_end < tile_rect.bottom) limits.v_end -= voffset;\n\n      assert(lr_job_counter[0] <= num_even_lr_jobs);\n\n      lr_job_queue[lr_job_counter[i & 1]].lr_unit_row = i;\n      lr_job_queue[lr_job_counter[i & 1]].plane = plane;\n      lr_job_queue[lr_job_counter[i & 1]].v_start = limits.v_start;\n      lr_job_queue[lr_job_counter[i & 1]].v_end = limits.v_end;\n      lr_job_queue[lr_job_counter[i & 1]].sync_mode = i & 1;\n      if ((i & 1) == 0) {\n        lr_job_queue[lr_job_counter[i & 1]].v_copy_start =\n            limits.v_start + RESTORATION_BORDER;\n        lr_job_queue[lr_job_counter[i & 1]].v_copy_end =\n            limits.v_end - RESTORATION_BORDER;\n        if (i == 0) {\n          assert(limits.v_start == tile_rect.top);\n          lr_job_queue[lr_job_counter[i & 1]].v_copy_start = tile_rect.top;\n        }\n        if (i == (ctxt[plane].rsi->vert_units_per_tile - 1)) {\n          assert(limits.v_end == tile_rect.bottom);\n          lr_job_queue[lr_job_counter[i & 1]].v_copy_end = tile_rect.bottom;\n        }\n      } else {\n        lr_job_queue[lr_job_counter[i & 1]].v_copy_start =\n            AOMMAX(limits.v_start - RESTORATION_BORDER, tile_rect.top);\n        lr_job_queue[lr_job_counter[i & 1]].v_copy_end =\n            AOMMIN(limits.v_end + RESTORATION_BORDER, tile_rect.bottom);\n      }\n      lr_job_counter[i & 1]++;\n      lr_sync->jobs_enqueued++;\n\n      y0 += h;\n      ++i;\n    }\n  }\n}\n\nstatic uint32_t read_one_tile_group_obu(\n    AV1Decoder *pbi, struct aom_read_bit_buffer *rb, int is_first_tg,\n    const uint8_t *data, const uint8_t *data_end, const uint8_t **p_data_end,\n    int *is_last_tg, int tile_start_implicit) {\n  AV1_COMMON *const cm = &pbi->common;\n  int start_tile, end_tile;\n  int32_t header_size, tg_payload_size;\n\n  assert((rb->bit_offset & 7) == 0);\n  assert(rb->bit_buffer + aom_rb_bytes_read(rb) == data);\n\n  header_size = read_tile_group_header(pbi, rb, &start_tile, &end_tile,\n                                       tile_start_implicit);\n  if (header_size == -1 || byte_alignment(cm, rb)) return 0;\n  if (start_tile > end_tile) return header_size;\n  data += header_size;\n  av1_decode_tg_tiles_and_wrapup(pbi, data, data_end, p_data_end, start_tile,\n                                 end_tile, is_first_tg);\n\n  tg_payload_size = (uint32_t)(*p_data_end - data);\n\n  // TODO(shan):  For now, assume all tile groups received in order\n  *is_last_tg = end_tile == cm->tile_rows * cm->tile_cols - 1;\n  return header_size + tg_payload_size;\n}\n\nint av1_receive_compressed_data(AV1Decoder *pbi, size_t size,\n                                const uint8_t **psource) {\n  AV1_COMMON *volatile const cm = &pbi->common;\n  BufferPool *volatile const pool = cm->buffer_pool;\n  RefCntBuffer *volatile const frame_bufs = cm->buffer_pool->frame_bufs;\n  const uint8_t *source = *psource;\n  cm->error.error_code = AOM_CODEC_OK;\n\n  if (size == 0) {\n    // This is used to signal that we are missing frames.\n    // We do not know if the missing frame(s) was supposed to update\n    // any of the reference buffers, but we act conservative and\n    // mark only the last buffer as corrupted.\n    //\n    // TODO(jkoleszar): Error concealment is undefined and non-normative\n    // at this point, but if it becomes so, [0] may not always be the correct\n    // thing to do here.\n    if (cm->frame_refs[0].idx > 0) {\n      assert(cm->frame_refs[0].buf != NULL);\n      cm->frame_refs[0].buf->corrupted = 1;\n    }\n  }\n\n  // Find a free buffer for the new frame, releasing the reference previously\n  // held.\n\n  // Find a free frame buffer. Return error if can not find any.\n  cm->new_fb_idx = get_free_fb(cm);\n  if (cm->new_fb_idx == INVALID_IDX) {\n    cm->error.error_code = AOM_CODEC_MEM_ERROR;\n    return 1;\n  }\n\n  // Assign a MV array to the frame buffer.\n  cm->cur_frame = &pool->frame_bufs[cm->new_fb_idx];\n\n  if (!pbi->camera_frame_header_ready) pbi->hold_ref_buf = 0;\n\n  pbi->cur_buf = &frame_bufs[cm->new_fb_idx];\n\n  // The jmp_buf is valid only for the duration of the function that calls\n  // setjmp(). Therefore, this function must reset the 'setjmp' field to 0\n  // before it returns.\n  if (setjmp(cm->error.jmp)) {\n    const AVxWorkerInterface *const winterface = aom_get_worker_interface();\n    int i;\n\n    cm->error.setjmp = 0;\n\n    // Synchronize all threads immediately as a subsequent decode call may\n    // cause a resize invalidating some allocations.\n    winterface->sync(&pbi->lf_worker);\n    for (i = 0; i < pbi->num_workers; ++i) {\n      winterface->sync(&pbi->tile_workers[i]);\n    }\n\n    lock_buffer_pool(pool);\n    // Release all the reference buffers if worker thread is holding them.\n    if (pbi->hold_ref_buf == 1) {\n      int ref_index = 0, mask;\n      for (mask = pbi->refresh_frame_flags; mask; mask >>= 1) {\n        const int old_idx = cm->ref_frame_map[ref_index];\n        // Current thread releases the holding of reference frame.\n        decrease_ref_count(old_idx, frame_bufs, pool);\n\n        // Release the reference frame holding in the reference map for the\n        // decoding of the next frame.\n        if (mask & 1) decrease_ref_count(old_idx, frame_bufs, pool);\n        ++ref_index;\n      }\n\n      // Current thread releases the holding of reference frame.\n      const int check_on_show_existing_frame =\n          !cm->show_existing_frame || cm->reset_decoder_state;\n      for (; ref_index < REF_FRAMES && check_on_show_existing_frame;\n           ++ref_index) {\n        const int old_idx = cm->ref_frame_map[ref_index];\n        decrease_ref_count(old_idx, frame_bufs, pool);\n      }\n      pbi->hold_ref_buf = 0;\n    }\n    // Release current frame.\n    decrease_ref_count(cm->new_fb_idx, frame_bufs, pool);\n    unlock_buffer_pool(pool);\n\n    aom_clear_system_state();\n    return -1;\n  }\n\n  cm->error.setjmp = 1;\n\n  int frame_decoded =\n      aom_decode_frame_from_obus(pbi, source, source + size, psource);\n\n  if (cm->error.error_code != AOM_CODEC_OK) {\n    lock_buffer_pool(pool);\n    decrease_ref_count(cm->new_fb_idx, frame_bufs, pool);\n    unlock_buffer_pool(pool);\n    cm->error.setjmp = 0;\n    return 1;\n  }\n\n#if TXCOEFF_TIMER\n  cm->cum_txcoeff_timer += cm->txcoeff_timer;\n  fprintf(stderr,\n          \"txb coeff block number: %d, frame time: %ld, cum time %ld in us\\n\",\n          cm->txb_count, cm->txcoeff_timer, cm->cum_txcoeff_timer);\n  cm->txcoeff_timer = 0;\n  cm->txb_count = 0;\n#endif\n\n  // Note: At this point, this function holds a reference to cm->new_fb_idx\n  // in the buffer pool. This reference is consumed by swap_frame_buffers().\n  swap_frame_buffers(pbi, frame_decoded);\n\n  if (frame_decoded) {\n    pbi->decoding_first_frame = 0;\n  }\n\n  if (cm->error.error_code != AOM_CODEC_OK) {\n    cm->error.setjmp = 0;\n    return 1;\n  }\n\n  aom_clear_system_state();\n\n  if (!cm->show_existing_frame) {\n    cm->last_show_frame = cm->show_frame;\n\n    if (cm->seg.enabled) {\n      if (cm->prev_frame && (cm->mi_rows == cm->prev_frame->mi_rows) &&\n          (cm->mi_cols == cm->prev_frame->mi_cols)) {\n        cm->last_frame_seg_map = cm->prev_frame->seg_map;\n      } else {\n        cm->last_frame_seg_map = NULL;\n      }\n    }\n  }\n\n  // Update progress in frame parallel decode.\n  cm->last_width = cm->width;\n  cm->last_height = cm->height;\n  cm->last_tile_cols = cm->tile_cols;\n  cm->last_tile_rows = cm->tile_rows;\n  cm->error.setjmp = 0;\n\n  return 0;\n}\n\nstatic int frame_worker_hook(void *arg1, void *arg2) {\n  FrameWorkerData *const frame_worker_data = (FrameWorkerData *)arg1;\n  const uint8_t *data = frame_worker_data->data;\n  (void)arg2;\n\n  int result = av1_receive_compressed_data(frame_worker_data->pbi,\n                                           frame_worker_data->data_size, &data);\n  frame_worker_data->data_end = data;\n\n  if (result != 0) {\n    // Check decode result in serial decode.\n    frame_worker_data->pbi->cur_buf->buf.corrupted = 1;\n    frame_worker_data->pbi->need_resync = 1;\n  }\n  return !result;\n}\n\nstatic void execute(AVxWorker *const worker) {\n  if (worker->hook != NULL) {\n    worker->had_error |= !worker->hook(worker->data1, worker->data2);\n  }\n}\n\nstatic aom_codec_err_t decode_one(aom_codec_alg_priv_t *ctx,\n                                  const uint8_t **data, size_t data_sz,\n                                  void *user_priv) {\n  const AVxWorkerInterface *const winterface = aom_get_worker_interface();\n\n  // Determine the stream parameters. Note that we rely on peek_si to\n  // validate that we have a buffer that does not wrap around the top\n  // of the heap.\n  if (!ctx->si.h) {\n    int is_intra_only = 0;\n    ctx->si.is_annexb = ctx->is_annexb;\n    const aom_codec_err_t res =\n        decoder_peek_si_internal(*data, data_sz, &ctx->si, &is_intra_only);\n    if (res != AOM_CODEC_OK) return res;\n\n    if (!ctx->si.is_kf && !is_intra_only) return AOM_CODEC_ERROR;\n  }\n\n  AVxWorker *const worker = ctx->frame_workers;\n  FrameWorkerData *const frame_worker_data = (FrameWorkerData *)worker->data1;\n  frame_worker_data->data = *data;\n  frame_worker_data->data_size = data_sz;\n  frame_worker_data->user_priv = user_priv;\n  frame_worker_data->received_frame = 1;\n\n#if CONFIG_INSPECTION\n  frame_worker_data->pbi->inspect_cb = ctx->inspect_cb;\n  frame_worker_data->pbi->inspect_ctx = ctx->inspect_ctx;\n#endif\n\n  frame_worker_data->pbi->common.large_scale_tile = ctx->tile_mode;\n  frame_worker_data->pbi->dec_tile_row = ctx->decode_tile_row;\n  frame_worker_data->pbi->dec_tile_col = ctx->decode_tile_col;\n  frame_worker_data->pbi->ext_tile_debug = ctx->ext_tile_debug;\n  frame_worker_data->pbi->row_mt = ctx->row_mt;\n  frame_worker_data->pbi->ext_refs = ctx->ext_refs;\n\n  frame_worker_data->pbi->common.is_annexb = ctx->is_annexb;\n\n  worker->had_error = 0;\n  winterface->execute(worker);\n\n  // Update data pointer after decode.\n  *data = frame_worker_data->data_end;\n\n  if (worker->had_error)\n    return update_error_state(ctx, &frame_worker_data->pbi->common.error);\n\n  check_resync(ctx, frame_worker_data->pbi);\n\n  return AOM_CODEC_OK;\n}\n\naom_codec_err_t aom_codec_decode(aom_codec_ctx_t *ctx, const uint8_t *data,\n                                 size_t data_sz, void *user_priv) {\n  aom_codec_err_t res;\n\n  /* Sanity checks */\n  /* NULL data ptr allowed if data_sz is 0 too */\n  if (!ctx || (!data && data_sz) || (data && !data_sz))\n    res = AOM_CODEC_INVALID_PARAM;\n  else if (!ctx->iface || !ctx->priv)\n    res = AOM_CODEC_ERROR;\n  else {\n    res = ctx->iface->dec.decode(get_alg_priv(ctx), data, data_sz, user_priv);\n  }\n\n  return SAVE_STATUS(ctx, res);\n}\n\n\n// target function\nstatic void foreach_rest_unit_in_planes_mt(AV1LrStruct *lr_ctxt,\n                                           AVxWorker *workers, int nworkers,\n                                           AV1LrSync *lr_sync, AV1_COMMON *cm) {\n  FilterFrameCtxt *ctxt = lr_ctxt->ctxt;\n\n  const int num_planes = av1_num_planes(cm);\n\n  const AVxWorkerInterface *const winterface = aom_get_worker_interface();\n  int num_rows_lr = 0;\n\n  for (int plane = 0; plane < num_planes; plane++) {\n    const AV1PixelRect tile_rect = ctxt[plane].tile_rect;\n    const int max_tile_h = tile_rect.bottom - tile_rect.top;\n\n    const int unit_size = cm->seq_params.sb_size == BLOCK_128X128 ? 128 : 64;\n\n    num_rows_lr =\n        AOMMAX(num_rows_lr, av1_lr_count_units_in_tile(unit_size, max_tile_h));\n  }\n\n  const int num_workers = nworkers;\n  int i;\n  assert(MAX_MB_PLANE == 3);\n\n  if (!lr_sync->sync_range || num_rows_lr != lr_sync->rows ||\n      num_workers > lr_sync->num_workers || num_planes != lr_sync->num_planes) {\n    av1_loop_restoration_dealloc(lr_sync, num_workers);\n    loop_restoration_alloc(lr_sync, cm, num_workers, num_rows_lr, num_planes,\n                           cm->width);\n  }\n\n  // Initialize cur_sb_col to -1 for all SB rows.\n  for (i = 0; i < num_planes; i++) {\n    memset(lr_sync->cur_sb_col[i], -1,\n           sizeof(*(lr_sync->cur_sb_col[i])) * num_rows_lr);\n  }\n\n  enqueue_lr_jobs(lr_sync, lr_ctxt, cm);\n\n  // Set up looprestoration thread data.\n  for (i = 0; i < num_workers; ++i) {\n    AVxWorker *const worker = &workers[i];\n    lr_sync->lrworkerdata[i].lr_ctxt = (void *)lr_ctxt;\n    worker->hook = loop_restoration_row_worker;\n    worker->data1 = lr_sync;\n    worker->data2 = &lr_sync->lrworkerdata[i];\n\n    // Start loopfiltering\n    if (i == num_workers - 1) {\n      winterface->execute(worker);\n    } else {\n      winterface->launch(worker);\n    }\n  }\n\n  // Wait till all rows are finished\n  for (i = 0; i < num_workers; ++i) {\n    winterface->sync(&workers[i]);\n  }\n}\n",
    "target": 1,
    "idx": 1010252,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic void LZ4_write32(void* memPtr, U32 value)\n{\n    memcpy(memPtr, &value, sizeof(value));\n}\n\nLZ4_FORCE_INLINE int LZ4_compress_generic(\n                 LZ4_stream_t_internal* const cctx,\n                 const char* const source,\n                 char* const dest,\n                 const int inputSize,\n                 int *inputConsumed, /* only written when outputDirective == fillOutput */\n                 const int maxOutputSize,\n                 const limitedOutput_directive outputDirective,\n                 const tableType_t tableType,\n                 const dict_directive dictDirective,\n                 const dictIssue_directive dictIssue,\n                 const int acceleration)\n{\n    int result;\n    const BYTE* ip = (const BYTE*) source;\n\n    U32 const startIndex = cctx->currentOffset;\n    const BYTE* base = (const BYTE*) source - startIndex;\n    const BYTE* lowLimit;\n\n    const LZ4_stream_t_internal* dictCtx = (const LZ4_stream_t_internal*) cctx->dictCtx;\n    const BYTE* const dictionary =\n        dictDirective == usingDictCtx ? dictCtx->dictionary : cctx->dictionary;\n    const U32 dictSize =\n        dictDirective == usingDictCtx ? dictCtx->dictSize : cctx->dictSize;\n    const U32 dictDelta = (dictDirective == usingDictCtx) ? startIndex - dictCtx->currentOffset : 0;   /* make indexes in dictCtx comparable with index in current context */\n\n    int const maybe_extMem = (dictDirective == usingExtDict) || (dictDirective == usingDictCtx);\n    U32 const prefixIdxLimit = startIndex - dictSize;   /* used when dictDirective == dictSmall */\n    const BYTE* const dictEnd = dictionary + dictSize;\n    const BYTE* anchor = (const BYTE*) source;\n    const BYTE* const iend = ip + inputSize;\n    const BYTE* const mflimitPlusOne = iend - MFLIMIT + 1;\n    const BYTE* const matchlimit = iend - LASTLITERALS;\n\n    /* the dictCtx currentOffset is indexed on the start of the dictionary,\n     * while a dictionary in the current context precedes the currentOffset */\n    const BYTE* dictBase = (dictDirective == usingDictCtx) ?\n                            dictionary + dictSize - dictCtx->currentOffset :\n                            dictionary + dictSize - startIndex;\n\n    BYTE* op = (BYTE*) dest;\n    BYTE* const olimit = op + maxOutputSize;\n\n    U32 offset = 0;\n    U32 forwardH;\n\n    DEBUGLOG(5, \"LZ4_compress_generic: srcSize=%i, tableType=%u\", inputSize, tableType);\n    /* If init conditions are not met, we don't have to mark stream\n     * as having dirty context, since no action was taken yet */\n    if (outputDirective == fillOutput && maxOutputSize < 1) { return 0; } /* Impossible to store anything */\n    if ((U32)inputSize > (U32)LZ4_MAX_INPUT_SIZE) { return 0; }           /* Unsupported inputSize, too large (or negative) */\n    if ((tableType == byU16) && (inputSize>=LZ4_64Klimit)) { return 0; }  /* Size too large (not within 64K limit) */\n    if (tableType==byPtr) assert(dictDirective==noDict);      /* only supported use case with byPtr */\n    assert(acceleration >= 1);\n\n    lowLimit = (const BYTE*)source - (dictDirective == withPrefix64k ? dictSize : 0);\n\n    /* Update context state */\n    if (dictDirective == usingDictCtx) {\n        /* Subsequent linked blocks can't use the dictionary. */\n        /* Instead, they use the block we just compressed. */\n        cctx->dictCtx = NULL;\n        cctx->dictSize = (U32)inputSize;\n    } else {\n        cctx->dictSize += (U32)inputSize;\n    }\n    cctx->currentOffset += (U32)inputSize;\n    cctx->tableType = (U16)tableType;\n\n    if (inputSize<LZ4_minLength) goto _last_literals;        /* Input too small, no compression (all literals) */\n\n    /* First Byte */\n    LZ4_putPosition(ip, cctx->hashTable, tableType, base);\n    ip++; forwardH = LZ4_hashPosition(ip, tableType);\n\n    /* Main Loop */\n    for ( ; ; ) {\n        const BYTE* match;\n        BYTE* token;\n        const BYTE* filledIp;\n\n        /* Find a match */\n        if (tableType == byPtr) {\n            const BYTE* forwardIp = ip;\n            int step = 1;\n            int searchMatchNb = acceleration << LZ4_skipTrigger;\n            do {\n                U32 const h = forwardH;\n                ip = forwardIp;\n                forwardIp += step;\n                step = (searchMatchNb++ >> LZ4_skipTrigger);\n\n                if (unlikely(forwardIp > mflimitPlusOne)) goto _last_literals;\n                assert(ip < mflimitPlusOne);\n\n                match = LZ4_getPositionOnHash(h, cctx->hashTable, tableType, base);\n                forwardH = LZ4_hashPosition(forwardIp, tableType);\n                LZ4_putPositionOnHash(ip, h, cctx->hashTable, tableType, base);\n\n            } while ( (match+LZ4_DISTANCE_MAX < ip)\n                   || (LZ4_read32(match) != LZ4_read32(ip)) );\n\n        } else {   /* byU32, byU16 */\n\n            const BYTE* forwardIp = ip;\n            int step = 1;\n            int searchMatchNb = acceleration << LZ4_skipTrigger;\n            do {\n                U32 const h = forwardH;\n                U32 const current = (U32)(forwardIp - base);\n                U32 matchIndex = LZ4_getIndexOnHash(h, cctx->hashTable, tableType);\n                assert(matchIndex <= current);\n                assert(forwardIp - base < (ptrdiff_t)(2 GB - 1));\n                ip = forwardIp;\n                forwardIp += step;\n                step = (searchMatchNb++ >> LZ4_skipTrigger);\n\n                if (unlikely(forwardIp > mflimitPlusOne)) goto _last_literals;\n                assert(ip < mflimitPlusOne);\n\n                if (dictDirective == usingDictCtx) {\n                    if (matchIndex < startIndex) {\n                        /* there was no match, try the dictionary */\n                        assert(tableType == byU32);\n                        matchIndex = LZ4_getIndexOnHash(h, dictCtx->hashTable, byU32);\n                        match = dictBase + matchIndex;\n                        matchIndex += dictDelta;   /* make dictCtx index comparable with current context */\n                        lowLimit = dictionary;\n                    } else {\n                        match = base + matchIndex;\n                        lowLimit = (const BYTE*)source;\n                    }\n                } else if (dictDirective==usingExtDict) {\n                    if (matchIndex < startIndex) {\n                        DEBUGLOG(7, \"extDict candidate: matchIndex=%5u  <  startIndex=%5u\", matchIndex, startIndex);\n                        assert(startIndex - matchIndex >= MINMATCH);\n                        match = dictBase + matchIndex;\n                        lowLimit = dictionary;\n                    } else {\n                        match = base + matchIndex;\n                        lowLimit = (const BYTE*)source;\n                    }\n                } else {   /* single continuous memory segment */\n                    match = base + matchIndex;\n                }\n                forwardH = LZ4_hashPosition(forwardIp, tableType);\n                LZ4_putIndexOnHash(current, h, cctx->hashTable, tableType);\n\n                DEBUGLOG(7, \"candidate at pos=%u  (offset=%u \\n\", matchIndex, current - matchIndex);\n                if ((dictIssue == dictSmall) && (matchIndex < prefixIdxLimit)) { continue; }    /* match outside of valid area */\n                assert(matchIndex < current);\n                if ( ((tableType != byU16) || (LZ4_DISTANCE_MAX < LZ4_DISTANCE_ABSOLUTE_MAX))\n                  && (matchIndex+LZ4_DISTANCE_MAX < current)) {\n                    continue;\n                } /* too far */\n                assert((current - matchIndex) <= LZ4_DISTANCE_MAX);  /* match now expected within distance */\n\n                if (LZ4_read32(match) == LZ4_read32(ip)) {\n                    if (maybe_extMem) offset = current - matchIndex;\n                    break;   /* match found */\n                }\n\n            } while(1);\n        }\n\n        /* Catch up */\n        filledIp = ip;\n        while (((ip>anchor) & (match > lowLimit)) && (unlikely(ip[-1]==match[-1]))) { ip--; match--; }\n\n        /* Encode Literals */\n        {   unsigned const litLength = (unsigned)(ip - anchor);\n            token = op++;\n            if ((outputDirective == limitedOutput) &&  /* Check output buffer overflow */\n                (unlikely(op + litLength + (2 + 1 + LASTLITERALS) + (litLength/255) > olimit)) ) {\n                return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */\n            }\n            if ((outputDirective == fillOutput) &&\n                (unlikely(op + (litLength+240)/255 /* litlen */ + litLength /* literals */ + 2 /* offset */ + 1 /* token */ + MFLIMIT - MINMATCH /* min last literals so last match is <= end - MFLIMIT */ > olimit))) {\n                op--;\n                goto _last_literals;\n            }\n            if (litLength >= RUN_MASK) {\n                int len = (int)(litLength - RUN_MASK);\n                *token = (RUN_MASK<<ML_BITS);\n                for(; len >= 255 ; len-=255) *op++ = 255;\n                *op++ = (BYTE)len;\n            }\n            else *token = (BYTE)(litLength<<ML_BITS);\n\n            /* Copy Literals */\n            LZ4_wildCopy8(op, anchor, op+litLength);\n            op+=litLength;\n            DEBUGLOG(6, \"seq.start:%i, literals=%u, match.start:%i\",\n                        (int)(anchor-(const BYTE*)source), litLength, (int)(ip-(const BYTE*)source));\n        }\n\n_next_match:\n        /* at this stage, the following variables must be correctly set :\n         * - ip : at start of LZ operation\n         * - match : at start of previous pattern occurence; can be within current prefix, or within extDict\n         * - offset : if maybe_ext_memSegment==1 (constant)\n         * - lowLimit : must be == dictionary to mean \"match is within extDict\"; must be == source otherwise\n         * - token and *token : position to write 4-bits for match length; higher 4-bits for literal length supposed already written\n         */\n\n        if ((outputDirective == fillOutput) &&\n            (op + 2 /* offset */ + 1 /* token */ + MFLIMIT - MINMATCH /* min last literals so last match is <= end - MFLIMIT */ > olimit)) {\n            /* the match was too close to the end, rewind and go to last literals */\n            op = token;\n            goto _last_literals;\n        }\n\n        /* Encode Offset */\n        if (maybe_extMem) {   /* static test */\n            DEBUGLOG(6, \"             with offset=%u  (ext if > %i)\", offset, (int)(ip - (const BYTE*)source));\n            assert(offset <= LZ4_DISTANCE_MAX && offset > 0);\n            LZ4_writeLE16(op, (U16)offset); op+=2;\n        } else  {\n            DEBUGLOG(6, \"             with offset=%u  (same segment)\", (U32)(ip - match));\n            assert(ip-match <= LZ4_DISTANCE_MAX);\n            LZ4_writeLE16(op, (U16)(ip - match)); op+=2;\n        }\n\n        /* Encode MatchLength */\n        {   unsigned matchCode;\n\n            if ( (dictDirective==usingExtDict || dictDirective==usingDictCtx)\n              && (lowLimit==dictionary) /* match within extDict */ ) {\n                const BYTE* limit = ip + (dictEnd-match);\n                assert(dictEnd > match);\n                if (limit > matchlimit) limit = matchlimit;\n                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, limit);\n                ip += (size_t)matchCode + MINMATCH;\n                if (ip==limit) {\n                    unsigned const more = LZ4_count(limit, (const BYTE*)source, matchlimit);\n                    matchCode += more;\n                    ip += more;\n                }\n                DEBUGLOG(6, \"             with matchLength=%u starting in extDict\", matchCode+MINMATCH);\n            } else {\n                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, matchlimit);\n                ip += (size_t)matchCode + MINMATCH;\n                DEBUGLOG(6, \"             with matchLength=%u\", matchCode+MINMATCH);\n            }\n\n            if ((outputDirective) &&    /* Check output buffer overflow */\n                (unlikely(op + (1 + LASTLITERALS) + (matchCode+240)/255 > olimit)) ) {\n                if (outputDirective == fillOutput) {\n                    /* Match description too long : reduce it */\n                    U32 newMatchCode = 15 /* in token */ - 1 /* to avoid needing a zero byte */ + ((U32)(olimit - op) - 1 - LASTLITERALS) * 255;\n                    ip -= matchCode - newMatchCode;\n                    assert(newMatchCode < matchCode);\n                    matchCode = newMatchCode;\n                    if (unlikely(ip < filledIp)) {\n                        /* We have already filled up to filledIp so if ip ends up less than filledIp\n                         * we have positions in the hash table beyond the current position. This is\n                         * a problem if we reuse the hash table. So we have to remove these positions\n                         * from the hash table.\n                         */\n                        const BYTE* ptr;\n                        DEBUGLOG(5, \"Clearing %u positions\", (U32)(filledIp - ip));\n                        for (ptr = ip + 1; ptr <= filledIp; ++ptr) {\n                            U32 const h = LZ4_hashPosition(ptr, tableType);\n                            LZ4_clearHash(h, cctx->hashTable, tableType);\n                        }\n                    }\n                } else {\n                    assert(outputDirective == limitedOutput);\n                    return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */\n                }\n            }\n            if (matchCode >= ML_MASK) {\n                *token += ML_MASK;\n                matchCode -= ML_MASK;\n                LZ4_write32(op, 0xFFFFFFFF);\n                while (matchCode >= 4*255) {\n                    op+=4;\n                    LZ4_write32(op, 0xFFFFFFFF);\n                    matchCode -= 4*255;\n                }\n                op += matchCode / 255;\n                *op++ = (BYTE)(matchCode % 255);\n            } else\n                *token += (BYTE)(matchCode);\n        }\n        /* Ensure we have enough space for the last literals. */\n        assert(!(outputDirective == fillOutput && op + 1 + LASTLITERALS > olimit));\n\n        anchor = ip;\n\n        /* Test end of chunk */\n        if (ip >= mflimitPlusOne) break;\n\n        /* Fill table */\n        LZ4_putPosition(ip-2, cctx->hashTable, tableType, base);\n\n        /* Test next position */\n        if (tableType == byPtr) {\n\n            match = LZ4_getPosition(ip, cctx->hashTable, tableType, base);\n            LZ4_putPosition(ip, cctx->hashTable, tableType, base);\n            if ( (match+LZ4_DISTANCE_MAX >= ip)\n              && (LZ4_read32(match) == LZ4_read32(ip)) )\n            { token=op++; *token=0; goto _next_match; }\n\n        } else {   /* byU32, byU16 */\n\n            U32 const h = LZ4_hashPosition(ip, tableType);\n            U32 const current = (U32)(ip-base);\n            U32 matchIndex = LZ4_getIndexOnHash(h, cctx->hashTable, tableType);\n            assert(matchIndex < current);\n            if (dictDirective == usingDictCtx) {\n                if (matchIndex < startIndex) {\n                    /* there was no match, try the dictionary */\n                    matchIndex = LZ4_getIndexOnHash(h, dictCtx->hashTable, byU32);\n                    match = dictBase + matchIndex;\n                    lowLimit = dictionary;   /* required for match length counter */\n                    matchIndex += dictDelta;\n                } else {\n                    match = base + matchIndex;\n                    lowLimit = (const BYTE*)source;  /* required for match length counter */\n                }\n            } else if (dictDirective==usingExtDict) {\n                if (matchIndex < startIndex) {\n                    match = dictBase + matchIndex;\n                    lowLimit = dictionary;   /* required for match length counter */\n                } else {\n                    match = base + matchIndex;\n                    lowLimit = (const BYTE*)source;   /* required for match length counter */\n                }\n            } else {   /* single memory segment */\n                match = base + matchIndex;\n            }\n            LZ4_putIndexOnHash(current, h, cctx->hashTable, tableType);\n            assert(matchIndex < current);\n            if ( ((dictIssue==dictSmall) ? (matchIndex >= prefixIdxLimit) : 1)\n              && (((tableType==byU16) && (LZ4_DISTANCE_MAX == LZ4_DISTANCE_ABSOLUTE_MAX)) ? 1 : (matchIndex+LZ4_DISTANCE_MAX >= current))\n              && (LZ4_read32(match) == LZ4_read32(ip)) ) {\n                token=op++;\n                *token=0;\n                if (maybe_extMem) offset = current - matchIndex;\n                DEBUGLOG(6, \"seq.start:%i, literals=%u, match.start:%i\",\n                            (int)(anchor-(const BYTE*)source), 0, (int)(ip-(const BYTE*)source));\n                goto _next_match;\n            }\n        }\n\n        /* Prepare next loop */\n        forwardH = LZ4_hashPosition(++ip, tableType);\n\n    }\n\n_last_literals:\n    /* Encode Last Literals */\n    {   size_t lastRun = (size_t)(iend - anchor);\n        if ( (outputDirective) &&  /* Check output buffer overflow */\n            (op + lastRun + 1 + ((lastRun+255-RUN_MASK)/255) > olimit)) {\n            if (outputDirective == fillOutput) {\n                /* adapt lastRun to fill 'dst' */\n                assert(olimit >= op);\n                lastRun  = (size_t)(olimit-op) - 1;\n                lastRun -= (lastRun+240)/255;\n            } else {\n                assert(outputDirective == limitedOutput);\n                return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */\n            }\n        }\n        if (lastRun >= RUN_MASK) {\n            size_t accumulator = lastRun - RUN_MASK;\n            *op++ = RUN_MASK << ML_BITS;\n            for(; accumulator >= 255 ; accumulator-=255) *op++ = 255;\n            *op++ = (BYTE) accumulator;\n        } else {\n            *op++ = (BYTE)(lastRun<<ML_BITS);\n        }\n        memcpy(op, anchor, lastRun);\n        ip = anchor + lastRun;\n        op += lastRun;\n    }\n\n    if (outputDirective == fillOutput) {\n        *inputConsumed = (int) (((const char*)ip)-source);\n    }\n    DEBUGLOG(5, \"LZ4_compress_generic: compressed %i bytes into %i bytes\", inputSize, (int)(((char*)op) - dest));\n    result = (int)(((char*)op) - dest);\n    assert(result > 0);\n    return result;\n}\n\nint LZ4_compress_fast(const char* source, char* dest, int inputSize, int maxOutputSize, int acceleration)\n{\n    int result;\n#if (LZ4_HEAPMODE)\n    LZ4_stream_t* ctxPtr = ALLOC(sizeof(LZ4_stream_t));   /* malloc-calloc always properly aligned */\n    if (ctxPtr == NULL) return 0;\n#else\n    LZ4_stream_t ctx;\n    LZ4_stream_t* const ctxPtr = &ctx;\n#endif\n    result = LZ4_compress_fast_extState(ctxPtr, source, dest, inputSize, maxOutputSize, acceleration);\n\n#if (LZ4_HEAPMODE)\n    FREEMEM(ctxPtr);\n#endif\n    return result;\n}\n\n\n// target function\nLZ4_FORCE_INLINE int LZ4_compress_generic(\n                 LZ4_stream_t_internal* const cctx,\n                 const char* const source,\n                 char* const dest,\n                 const int inputSize,\n                 int *inputConsumed, /* only written when outputDirective == fillOutput */\n                 const int maxOutputSize,\n                 const limitedOutput_directive outputDirective,\n                 const tableType_t tableType,\n                 const dict_directive dictDirective,\n                 const dictIssue_directive dictIssue,\n                 const int acceleration)\n{\n    int result;\n    const BYTE* ip = (const BYTE*) source;\n\n    U32 const startIndex = cctx->currentOffset;\n    const BYTE* base = (const BYTE*) source - startIndex;\n    const BYTE* lowLimit;\n\n    const LZ4_stream_t_internal* dictCtx = (const LZ4_stream_t_internal*) cctx->dictCtx;\n    const BYTE* const dictionary =\n        dictDirective == usingDictCtx ? dictCtx->dictionary : cctx->dictionary;\n    const U32 dictSize =\n        dictDirective == usingDictCtx ? dictCtx->dictSize : cctx->dictSize;\n    const U32 dictDelta = (dictDirective == usingDictCtx) ? startIndex - dictCtx->currentOffset : 0;   /* make indexes in dictCtx comparable with index in current context */\n\n    int const maybe_extMem = (dictDirective == usingExtDict) || (dictDirective == usingDictCtx);\n    U32 const prefixIdxLimit = startIndex - dictSize;   /* used when dictDirective == dictSmall */\n    const BYTE* const dictEnd = dictionary + dictSize;\n    const BYTE* anchor = (const BYTE*) source;\n    const BYTE* const iend = ip + inputSize;\n    const BYTE* const mflimitPlusOne = iend - MFLIMIT + 1;\n    const BYTE* const matchlimit = iend - LASTLITERALS;\n\n    /* the dictCtx currentOffset is indexed on the start of the dictionary,\n     * while a dictionary in the current context precedes the currentOffset */\n    const BYTE* dictBase = (dictDirective == usingDictCtx) ?\n                            dictionary + dictSize - dictCtx->currentOffset :\n                            dictionary + dictSize - startIndex;\n\n    BYTE* op = (BYTE*) dest;\n    BYTE* const olimit = op + maxOutputSize;\n\n    U32 offset = 0;\n    U32 forwardH;\n\n    DEBUGLOG(5, \"LZ4_compress_generic: srcSize=%i, tableType=%u\", inputSize, tableType);\n    /* If init conditions are not met, we don't have to mark stream\n     * as having dirty context, since no action was taken yet */\n    if (outputDirective == fillOutput && maxOutputSize < 1) { return 0; } /* Impossible to store anything */\n    if ((U32)inputSize > (U32)LZ4_MAX_INPUT_SIZE) { return 0; }           /* Unsupported inputSize, too large (or negative) */\n    if ((tableType == byU16) && (inputSize>=LZ4_64Klimit)) { return 0; }  /* Size too large (not within 64K limit) */\n    if (tableType==byPtr) assert(dictDirective==noDict);      /* only supported use case with byPtr */\n    assert(acceleration >= 1);\n\n    lowLimit = (const BYTE*)source - (dictDirective == withPrefix64k ? dictSize : 0);\n\n    /* Update context state */\n    if (dictDirective == usingDictCtx) {\n        /* Subsequent linked blocks can't use the dictionary. */\n        /* Instead, they use the block we just compressed. */\n        cctx->dictCtx = NULL;\n        cctx->dictSize = (U32)inputSize;\n    } else {\n        cctx->dictSize += (U32)inputSize;\n    }\n    cctx->currentOffset += (U32)inputSize;\n    cctx->tableType = (U16)tableType;\n\n    if (inputSize<LZ4_minLength) goto _last_literals;        /* Input too small, no compression (all literals) */\n\n    /* First Byte */\n    LZ4_putPosition(ip, cctx->hashTable, tableType, base);\n    ip++; forwardH = LZ4_hashPosition(ip, tableType);\n\n    /* Main Loop */\n    for ( ; ; ) {\n        const BYTE* match;\n        BYTE* token;\n        const BYTE* filledIp;\n\n        /* Find a match */\n        if (tableType == byPtr) {\n            const BYTE* forwardIp = ip;\n            int step = 1;\n            int searchMatchNb = acceleration << LZ4_skipTrigger;\n            do {\n                U32 const h = forwardH;\n                ip = forwardIp;\n                forwardIp += step;\n                step = (searchMatchNb++ >> LZ4_skipTrigger);\n\n                if (unlikely(forwardIp > mflimitPlusOne)) goto _last_literals;\n                assert(ip < mflimitPlusOne);\n\n                match = LZ4_getPositionOnHash(h, cctx->hashTable, tableType, base);\n                forwardH = LZ4_hashPosition(forwardIp, tableType);\n                LZ4_putPositionOnHash(ip, h, cctx->hashTable, tableType, base);\n\n            } while ( (match+LZ4_DISTANCE_MAX < ip)\n                   || (LZ4_read32(match) != LZ4_read32(ip)) );\n\n        } else {   /* byU32, byU16 */\n\n            const BYTE* forwardIp = ip;\n            int step = 1;\n            int searchMatchNb = acceleration << LZ4_skipTrigger;\n            do {\n                U32 const h = forwardH;\n                U32 const current = (U32)(forwardIp - base);\n                U32 matchIndex = LZ4_getIndexOnHash(h, cctx->hashTable, tableType);\n                assert(matchIndex <= current);\n                assert(forwardIp - base < (ptrdiff_t)(2 GB - 1));\n                ip = forwardIp;\n                forwardIp += step;\n                step = (searchMatchNb++ >> LZ4_skipTrigger);\n\n                if (unlikely(forwardIp > mflimitPlusOne)) goto _last_literals;\n                assert(ip < mflimitPlusOne);\n\n                if (dictDirective == usingDictCtx) {\n                    if (matchIndex < startIndex) {\n                        /* there was no match, try the dictionary */\n                        assert(tableType == byU32);\n                        matchIndex = LZ4_getIndexOnHash(h, dictCtx->hashTable, byU32);\n                        match = dictBase + matchIndex;\n                        matchIndex += dictDelta;   /* make dictCtx index comparable with current context */\n                        lowLimit = dictionary;\n                    } else {\n                        match = base + matchIndex;\n                        lowLimit = (const BYTE*)source;\n                    }\n                } else if (dictDirective==usingExtDict) {\n                    if (matchIndex < startIndex) {\n                        DEBUGLOG(7, \"extDict candidate: matchIndex=%5u  <  startIndex=%5u\", matchIndex, startIndex);\n                        assert(startIndex - matchIndex >= MINMATCH);\n                        match = dictBase + matchIndex;\n                        lowLimit = dictionary;\n                    } else {\n                        match = base + matchIndex;\n                        lowLimit = (const BYTE*)source;\n                    }\n                } else {   /* single continuous memory segment */\n                    match = base + matchIndex;\n                }\n                forwardH = LZ4_hashPosition(forwardIp, tableType);\n                LZ4_putIndexOnHash(current, h, cctx->hashTable, tableType);\n\n                DEBUGLOG(7, \"candidate at pos=%u  (offset=%u \\n\", matchIndex, current - matchIndex);\n                if ((dictIssue == dictSmall) && (matchIndex < prefixIdxLimit)) { continue; }    /* match outside of valid area */\n                assert(matchIndex < current);\n                if ( ((tableType != byU16) || (LZ4_DISTANCE_MAX < LZ4_DISTANCE_ABSOLUTE_MAX))\n                  && (matchIndex+LZ4_DISTANCE_MAX < current)) {\n                    continue;\n                } /* too far */\n                assert((current - matchIndex) <= LZ4_DISTANCE_MAX);  /* match now expected within distance */\n\n                if (LZ4_read32(match) == LZ4_read32(ip)) {\n                    if (maybe_extMem) offset = current - matchIndex;\n                    break;   /* match found */\n                }\n\n            } while(1);\n        }\n\n        /* Catch up */\n        filledIp = ip;\n        while (((ip>anchor) & (match > lowLimit)) && (unlikely(ip[-1]==match[-1]))) { ip--; match--; }\n\n        /* Encode Literals */\n        {   unsigned const litLength = (unsigned)(ip - anchor);\n            token = op++;\n            if ((outputDirective == limitedOutput) &&  /* Check output buffer overflow */\n                (unlikely(op + litLength + (2 + 1 + LASTLITERALS) + (litLength/255) > olimit)) ) {\n                return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */\n            }\n            if ((outputDirective == fillOutput) &&\n                (unlikely(op + (litLength+240)/255 /* litlen */ + litLength /* literals */ + 2 /* offset */ + 1 /* token */ + MFLIMIT - MINMATCH /* min last literals so last match is <= end - MFLIMIT */ > olimit))) {\n                op--;\n                goto _last_literals;\n            }\n            if (litLength >= RUN_MASK) {\n                int len = (int)(litLength - RUN_MASK);\n                *token = (RUN_MASK<<ML_BITS);\n                for(; len >= 255 ; len-=255) *op++ = 255;\n                *op++ = (BYTE)len;\n            }\n            else *token = (BYTE)(litLength<<ML_BITS);\n\n            /* Copy Literals */\n            LZ4_wildCopy8(op, anchor, op+litLength);\n            op+=litLength;\n            DEBUGLOG(6, \"seq.start:%i, literals=%u, match.start:%i\",\n                        (int)(anchor-(const BYTE*)source), litLength, (int)(ip-(const BYTE*)source));\n        }\n\n_next_match:\n        /* at this stage, the following variables must be correctly set :\n         * - ip : at start of LZ operation\n         * - match : at start of previous pattern occurence; can be within current prefix, or within extDict\n         * - offset : if maybe_ext_memSegment==1 (constant)\n         * - lowLimit : must be == dictionary to mean \"match is within extDict\"; must be == source otherwise\n         * - token and *token : position to write 4-bits for match length; higher 4-bits for literal length supposed already written\n         */\n\n        if ((outputDirective == fillOutput) &&\n            (op + 2 /* offset */ + 1 /* token */ + MFLIMIT - MINMATCH /* min last literals so last match is <= end - MFLIMIT */ > olimit)) {\n            /* the match was too close to the end, rewind and go to last literals */\n            op = token;\n            goto _last_literals;\n        }\n\n        /* Encode Offset */\n        if (maybe_extMem) {   /* static test */\n            DEBUGLOG(6, \"             with offset=%u  (ext if > %i)\", offset, (int)(ip - (const BYTE*)source));\n            assert(offset <= LZ4_DISTANCE_MAX && offset > 0);\n            LZ4_writeLE16(op, (U16)offset); op+=2;\n        } else  {\n            DEBUGLOG(6, \"             with offset=%u  (same segment)\", (U32)(ip - match));\n            assert(ip-match <= LZ4_DISTANCE_MAX);\n            LZ4_writeLE16(op, (U16)(ip - match)); op+=2;\n        }\n\n        /* Encode MatchLength */\n        {   unsigned matchCode;\n\n            if ( (dictDirective==usingExtDict || dictDirective==usingDictCtx)\n              && (lowLimit==dictionary) /* match within extDict */ ) {\n                const BYTE* limit = ip + (dictEnd-match);\n                assert(dictEnd > match);\n                if (limit > matchlimit) limit = matchlimit;\n                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, limit);\n                ip += (size_t)matchCode + MINMATCH;\n                if (ip==limit) {\n                    unsigned const more = LZ4_count(limit, (const BYTE*)source, matchlimit);\n                    matchCode += more;\n                    ip += more;\n                }\n                DEBUGLOG(6, \"             with matchLength=%u starting in extDict\", matchCode+MINMATCH);\n            } else {\n                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, matchlimit);\n                ip += (size_t)matchCode + MINMATCH;\n                DEBUGLOG(6, \"             with matchLength=%u\", matchCode+MINMATCH);\n            }\n\n            if ((outputDirective) &&    /* Check output buffer overflow */\n                (unlikely(op + (1 + LASTLITERALS) + (matchCode>>8) > olimit)) ) {\n                if (outputDirective == fillOutput) {\n                    /* Match description too long : reduce it */\n                    U32 newMatchCode = 15 /* in token */ - 1 /* to avoid needing a zero byte */ + ((U32)(olimit - op) - 1 - LASTLITERALS) * 255;\n                    ip -= matchCode - newMatchCode;\n                    assert(newMatchCode < matchCode);\n                    matchCode = newMatchCode;\n                    if (unlikely(ip < filledIp)) {\n                        /* We have already filled up to filledIp so if ip ends up less than filledIp\n                         * we have positions in the hash table beyond the current position. This is\n                         * a problem if we reuse the hash table. So we have to remove these positions\n                         * from the hash table.\n                         */\n                        const BYTE* ptr;\n                        DEBUGLOG(5, \"Clearing %u positions\", (U32)(filledIp - ip));\n                        for (ptr = ip + 1; ptr <= filledIp; ++ptr) {\n                            U32 const h = LZ4_hashPosition(ptr, tableType);\n                            LZ4_clearHash(h, cctx->hashTable, tableType);\n                        }\n                    }\n                } else {\n                    assert(outputDirective == limitedOutput);\n                    return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */\n                }\n            }\n            if (matchCode >= ML_MASK) {\n                *token += ML_MASK;\n                matchCode -= ML_MASK;\n                LZ4_write32(op, 0xFFFFFFFF);\n                while (matchCode >= 4*255) {\n                    op+=4;\n                    LZ4_write32(op, 0xFFFFFFFF);\n                    matchCode -= 4*255;\n                }\n                op += matchCode / 255;\n                *op++ = (BYTE)(matchCode % 255);\n            } else\n                *token += (BYTE)(matchCode);\n        }\n        /* Ensure we have enough space for the last literals. */\n        assert(!(outputDirective == fillOutput && op + 1 + LASTLITERALS > olimit));\n\n        anchor = ip;\n\n        /* Test end of chunk */\n        if (ip >= mflimitPlusOne) break;\n\n        /* Fill table */\n        LZ4_putPosition(ip-2, cctx->hashTable, tableType, base);\n\n        /* Test next position */\n        if (tableType == byPtr) {\n\n            match = LZ4_getPosition(ip, cctx->hashTable, tableType, base);\n            LZ4_putPosition(ip, cctx->hashTable, tableType, base);\n            if ( (match+LZ4_DISTANCE_MAX >= ip)\n              && (LZ4_read32(match) == LZ4_read32(ip)) )\n            { token=op++; *token=0; goto _next_match; }\n\n        } else {   /* byU32, byU16 */\n\n            U32 const h = LZ4_hashPosition(ip, tableType);\n            U32 const current = (U32)(ip-base);\n            U32 matchIndex = LZ4_getIndexOnHash(h, cctx->hashTable, tableType);\n            assert(matchIndex < current);\n            if (dictDirective == usingDictCtx) {\n                if (matchIndex < startIndex) {\n                    /* there was no match, try the dictionary */\n                    matchIndex = LZ4_getIndexOnHash(h, dictCtx->hashTable, byU32);\n                    match = dictBase + matchIndex;\n                    lowLimit = dictionary;   /* required for match length counter */\n                    matchIndex += dictDelta;\n                } else {\n                    match = base + matchIndex;\n                    lowLimit = (const BYTE*)source;  /* required for match length counter */\n                }\n            } else if (dictDirective==usingExtDict) {\n                if (matchIndex < startIndex) {\n                    match = dictBase + matchIndex;\n                    lowLimit = dictionary;   /* required for match length counter */\n                } else {\n                    match = base + matchIndex;\n                    lowLimit = (const BYTE*)source;   /* required for match length counter */\n                }\n            } else {   /* single memory segment */\n                match = base + matchIndex;\n            }\n            LZ4_putIndexOnHash(current, h, cctx->hashTable, tableType);\n            assert(matchIndex < current);\n            if ( ((dictIssue==dictSmall) ? (matchIndex >= prefixIdxLimit) : 1)\n              && (((tableType==byU16) && (LZ4_DISTANCE_MAX == LZ4_DISTANCE_ABSOLUTE_MAX)) ? 1 : (matchIndex+LZ4_DISTANCE_MAX >= current))\n              && (LZ4_read32(match) == LZ4_read32(ip)) ) {\n                token=op++;\n                *token=0;\n                if (maybe_extMem) offset = current - matchIndex;\n                DEBUGLOG(6, \"seq.start:%i, literals=%u, match.start:%i\",\n                            (int)(anchor-(const BYTE*)source), 0, (int)(ip-(const BYTE*)source));\n                goto _next_match;\n            }\n        }\n\n        /* Prepare next loop */\n        forwardH = LZ4_hashPosition(++ip, tableType);\n\n    }\n\n_last_literals:\n    /* Encode Last Literals */\n    {   size_t lastRun = (size_t)(iend - anchor);\n        if ( (outputDirective) &&  /* Check output buffer overflow */\n            (op + lastRun + 1 + ((lastRun+255-RUN_MASK)/255) > olimit)) {\n            if (outputDirective == fillOutput) {\n                /* adapt lastRun to fill 'dst' */\n                assert(olimit >= op);\n                lastRun  = (size_t)(olimit-op) - 1;\n                lastRun -= (lastRun+240)/255;\n            } else {\n                assert(outputDirective == limitedOutput);\n                return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */\n            }\n        }\n        if (lastRun >= RUN_MASK) {\n            size_t accumulator = lastRun - RUN_MASK;\n            *op++ = RUN_MASK << ML_BITS;\n            for(; accumulator >= 255 ; accumulator-=255) *op++ = 255;\n            *op++ = (BYTE) accumulator;\n        } else {\n            *op++ = (BYTE)(lastRun<<ML_BITS);\n        }\n        memcpy(op, anchor, lastRun);\n        ip = anchor + lastRun;\n        op += lastRun;\n    }\n\n    if (outputDirective == fillOutput) {\n        *inputConsumed = (int) (((const char*)ip)-source);\n    }\n    DEBUGLOG(5, \"LZ4_compress_generic: compressed %i bytes into %i bytes\", inputSize, (int)(((char*)op) - dest));\n    result = (int)(((char*)op) - dest);\n    assert(result > 0);\n    return result;\n}\n",
    "target": 1,
    "idx": 1015941,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nvoid\nofpbuf_insert(struct ofpbuf *b, size_t offset, const void *data, size_t n)\n{\n    if (offset < b->size) {\n        ofpbuf_put_uninit(b, n); /* b->size gets increased. */\n        memmove((char *) b->data + offset + n, (char *) b->data + offset,\n                b->size - offset - n);\n        memcpy((char *) b->data + offset, data, n);\n    } else {\n        ovs_assert(offset == b->size);\n        ofpbuf_put(b, data, n);\n    }\n}\n\n\n\n * value can be zero if it appended nothing at all to 'b' (which happens if\n * 'cr' is a catch-all rule that matches every packet). */\nint\nnx_put_match(struct ofpbuf *b, const struct match *match,\n             ovs_be64 cookie, ovs_be64 cookie_mask)\n{\n    int match_len = nx_put_raw(b, 0, match, cookie, cookie_mask);\n\n    ofpbuf_put_zeros(b, PAD_SIZE(match_len, 8));\n\n\n\n\n\n\n\n\n// target function\nvoid\nofpbuf_insert(struct ofpbuf *b, size_t offset, const void *data, size_t n)\n{\n    if (offset < b->size) {\n        ofpbuf_put_uninit(b, n);\n        memmove((char *) b->data + offset + n, (char *) b->data + offset,\n                b->size - offset);\n        memcpy((char *) b->data + offset, data, n);\n    } else {\n        ovs_assert(offset == b->size);\n        ofpbuf_put(b, data, n);\n    }\n}\n",
    "target": 1,
    "idx": 1011253,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "// context\n\n// target function\nextern \"C\" int LLVMFuzzerTestOneInput (const uint8_t *data, size_t size)\n{\n    setup_test_context ();\n    void *s = test_context_socket (ZMQ_XPUB);\n    int option;\n\n    //  A lot of options expect a well-formatted string\n    ((uint8_t *)data)[size - 1] = 0;\n\n    for (option = ZMQ_AFFINITY; option < ZMQ_BINDTODEVICE + 1; ++option) {\n        uint8_t out[512];\n        size_t out_size = 512;\n\n        zmq_setsockopt(s, option, data, size);\n        zmq_getsockopt(s, option, out, &out_size);\n    }\n\n    test_context_socket_close_zero_linger (s);\n    teardown_test_context ();\n\n    return 0;\n}\nvoid test_socket_options_fuzzer ()\n{\n    uint8_t **data;\n    size_t *len, num_cases = 0;\n    if (fuzzer_corpus_encode (\n          \"tests/libzmq-fuzz-corpora/test_socket_options_fuzzer_seed_corpus\", &data,\n          &len, &num_cases)\n        != 0)\n        exit (77);\n\n    while (num_cases-- > 0) {\n        TEST_ASSERT_SUCCESS_ERRNO (\n          LLVMFuzzerTestOneInput (data[num_cases], len[num_cases]));\n        free (data[num_cases]);\n    }\n\n    free (data);\n    free (len);\n}\n",
    "target": 1,
    "idx": 1025136,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "// context\n\n\nrgb_rgb_convert(j_decompress_ptr cinfo, _JSAMPIMAGE input_buf,\n                JDIMENSION input_row, _JSAMPARRAY output_buf, int num_rows)\n{\n  switch (cinfo->out_color_space) {\n  case JCS_EXT_RGB:\n    rgb_extrgb_convert_internal(cinfo, input_buf, input_row, output_buf,\n                                num_rows);\n    break;\n  case JCS_EXT_RGBX:\n  case JCS_EXT_RGBA:\n    rgb_extrgbx_convert_internal(cinfo, input_buf, input_row, output_buf,\n                                 num_rows);\n    break;\n  case JCS_EXT_BGR:\n    rgb_extbgr_convert_internal(cinfo, input_buf, input_row, output_buf,\n                                num_rows);\n    break;\n  case JCS_EXT_BGRX:\n  case JCS_EXT_BGRA:\n    rgb_extbgrx_convert_internal(cinfo, input_buf, input_row, output_buf,\n                                 num_rows);\n    break;\n  case JCS_EXT_XBGR:\n  case JCS_EXT_ABGR:\n    rgb_extxbgr_convert_internal(cinfo, input_buf, input_row, output_buf,\n                                 num_rows);\n    break;\n  case JCS_EXT_XRGB:\n  case JCS_EXT_ARGB:\n    rgb_extxrgb_convert_internal(cinfo, input_buf, input_row, output_buf,\n                                 num_rows);\n    break;\n  default:\n    rgb_rgb_convert_internal(cinfo, input_buf, input_row, output_buf,\n                             num_rows);\n    break;\n  }\n}\n\nsep_upsample(j_decompress_ptr cinfo, _JSAMPIMAGE input_buf,\n             JDIMENSION *in_row_group_ctr, JDIMENSION in_row_groups_avail,\n             _JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,\n             JDIMENSION out_rows_avail)\n{\n  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n  int ci;\n  jpeg_component_info *compptr;\n  JDIMENSION num_rows;\n\n  /* Fill the conversion buffer, if it's empty */\n  if (upsample->next_row_out >= cinfo->max_v_samp_factor) {\n    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n         ci++, compptr++) {\n      /* Invoke per-component upsample method.  Notice we pass a POINTER\n       * to color_buf[ci], so that fullsize_upsample can change it.\n       */\n      (*upsample->methods[ci]) (cinfo, compptr,\n        input_buf[ci] + (*in_row_group_ctr * upsample->rowgroup_height[ci]),\n        upsample->color_buf + ci);\n    }\n    upsample->next_row_out = 0;\n  }\n\n  /* Color-convert and emit rows */\n\n  /* How many we have in the buffer: */\n  num_rows = (JDIMENSION)(cinfo->max_v_samp_factor - upsample->next_row_out);\n  /* Not more than the distance to the end of the image.  Need this test\n   * in case the image height is not a multiple of max_v_samp_factor:\n   */\n  if (num_rows > upsample->rows_to_go)\n    num_rows = upsample->rows_to_go;\n  /* And not more than what the client can accept: */\n  out_rows_avail -= *out_row_ctr;\n  if (num_rows > out_rows_avail)\n    num_rows = out_rows_avail;\n\n  (*cinfo->cconvert->_color_convert) (cinfo, upsample->color_buf,\n                                      (JDIMENSION)upsample->next_row_out,\n                                      output_buf + *out_row_ctr,\n                                      (int)num_rows);\n\n  /* Adjust counts */\n  *out_row_ctr += num_rows;\n  upsample->rows_to_go -= num_rows;\n  upsample->next_row_out += num_rows;\n  /* When the buffer is emptied, declare this input row group consumed */\n  if (upsample->next_row_out >= cinfo->max_v_samp_factor)\n    (*in_row_group_ctr)++;\n}\n\nprocess_data_simple_main(j_decompress_ptr cinfo, _JSAMPARRAY output_buf,\n                         JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)\n{\n  my_main_ptr main_ptr = (my_main_ptr)cinfo->main;\n  JDIMENSION rowgroups_avail;\n\n  /* Read input data if we haven't filled the main buffer yet */\n  if (!main_ptr->buffer_full) {\n    if (!(*cinfo->coef->_decompress_data) (cinfo, main_ptr->buffer))\n      return;                   /* suspension forced, can do nothing more */\n    main_ptr->buffer_full = TRUE;       /* OK, we have an iMCU row to work with */\n  }\n\n  /* There are always min_DCT_scaled_size row groups in an iMCU row. */\n  rowgroups_avail = (JDIMENSION)cinfo->_min_DCT_scaled_size;\n  /* Note: at the bottom of the image, we may pass extra garbage row groups\n   * to the postprocessor.  The postprocessor has to check for bottom\n   * of image anyway (at row resolution), so no point in us doing it too.\n   */\n\n  /* Feed the postprocessor */\n  (*cinfo->post->_post_process_data) (cinfo, main_ptr->buffer,\n                                      &main_ptr->rowgroup_ctr, rowgroups_avail,\n                                      output_buf, out_row_ctr, out_rows_avail);\n\n  /* Has postprocessor consumed all the data yet? If so, mark buffer empty */\n  if (main_ptr->rowgroup_ctr >= rowgroups_avail) {\n    main_ptr->buffer_full = FALSE;\n    main_ptr->rowgroup_ctr = 0;\n  }\n}\n\n_jpeg_read_scanlines(j_decompress_ptr cinfo, _JSAMPARRAY scanlines,\n                     JDIMENSION max_lines)\n{\n  JDIMENSION row_ctr;\n\n  if (cinfo->data_precision != BITS_IN_JSAMPLE)\n    ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n\n  if (cinfo->global_state != DSTATE_SCANNING)\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n  if (cinfo->output_scanline >= cinfo->output_height) {\n    WARNMS(cinfo, JWRN_TOO_MUCH_DATA);\n    return 0;\n  }\n\n  /* Call progress monitor hook if present */\n  if (cinfo->progress != NULL) {\n    cinfo->progress->pass_counter = (long)cinfo->output_scanline;\n    cinfo->progress->pass_limit = (long)cinfo->output_height;\n    (*cinfo->progress->progress_monitor) ((j_common_ptr)cinfo);\n  }\n\n  /* Process some data */\n  row_ctr = 0;\n  (*cinfo->main->_process_data) (cinfo, scanlines, &row_ctr, max_lines);\n  cinfo->output_scanline += row_ctr;\n  return row_ctr;\n}\n\nDLLEXPORT int tjDecompress2(tjhandle handle, const unsigned char *jpegBuf,\n                            unsigned long jpegSize, unsigned char *dstBuf,\n                            int width, int pitch, int height, int pixelFormat,\n                            int flags)\n{\n  JSAMPROW *row_pointer = NULL;\n  int i, retval = 0, jpegwidth, jpegheight, scaledw, scaledh;\n  struct my_progress_mgr progress;\n\n  GET_DINSTANCE(handle);\n  this->jerr.stopOnWarning = (flags & TJFLAG_STOPONWARNING) ? TRUE : FALSE;\n  if ((this->init & DECOMPRESS) == 0)\n    THROW(\"tjDecompress2(): Instance has not been initialized for decompression\");\n\n  if (jpegBuf == NULL || jpegSize <= 0 || dstBuf == NULL || width < 0 ||\n      pitch < 0 || height < 0 || pixelFormat < 0 || pixelFormat >= TJ_NUMPF)\n    THROW(\"tjDecompress2(): Invalid argument\");\n\n#ifndef NO_PUTENV\n  if (flags & TJFLAG_FORCEMMX) PUTENV_S(\"JSIMD_FORCEMMX\", \"1\");\n  else if (flags & TJFLAG_FORCESSE) PUTENV_S(\"JSIMD_FORCESSE\", \"1\");\n  else if (flags & TJFLAG_FORCESSE2) PUTENV_S(\"JSIMD_FORCESSE2\", \"1\");\n#endif\n\n  if (flags & TJFLAG_LIMITSCANS) {\n    memset(&progress, 0, sizeof(struct my_progress_mgr));\n    progress.pub.progress_monitor = my_progress_monitor;\n    progress.this = this;\n    dinfo->progress = &progress.pub;\n  } else\n    dinfo->progress = NULL;\n\n  if (setjmp(this->jerr.setjmp_buffer)) {\n    /* If we get here, the JPEG code has signaled an error. */\n    retval = -1;  goto bailout;\n  }\n\n  jpeg_mem_src_tj(dinfo, jpegBuf, jpegSize);\n  jpeg_read_header(dinfo, TRUE);\n  this->dinfo.out_color_space = pf2cs[pixelFormat];\n  if (flags & TJFLAG_FASTDCT) this->dinfo.dct_method = JDCT_FASTEST;\n  if (flags & TJFLAG_FASTUPSAMPLE) dinfo->do_fancy_upsampling = FALSE;\n\n  jpegwidth = dinfo->image_width;  jpegheight = dinfo->image_height;\n  if (width == 0) width = jpegwidth;\n  if (height == 0) height = jpegheight;\n  for (i = 0; i < NUMSF; i++) {\n    scaledw = TJSCALED(jpegwidth, sf[i]);\n    scaledh = TJSCALED(jpegheight, sf[i]);\n    if (scaledw <= width && scaledh <= height)\n      break;\n  }\n  if (i >= NUMSF)\n    THROW(\"tjDecompress2(): Could not scale down to desired image dimensions\");\n  width = scaledw;  height = scaledh;\n  dinfo->scale_num = sf[i].num;\n  dinfo->scale_denom = sf[i].denom;\n\n  jpeg_start_decompress(dinfo);\n  if (pitch == 0) pitch = dinfo->output_width * tjPixelSize[pixelFormat];\n\n  if ((row_pointer =\n       (JSAMPROW *)malloc(sizeof(JSAMPROW) * dinfo->output_height)) == NULL)\n    THROW(\"tjDecompress2(): Memory allocation failure\");\n  if (setjmp(this->jerr.setjmp_buffer)) {\n    /* If we get here, the JPEG code has signaled an error. */\n    retval = -1;  goto bailout;\n  }\n  for (i = 0; i < (int)dinfo->output_height; i++) {\n    if (flags & TJFLAG_BOTTOMUP)\n      row_pointer[i] = &dstBuf[(dinfo->output_height - i - 1) * (size_t)pitch];\n    else\n      row_pointer[i] = &dstBuf[i * (size_t)pitch];\n  }\n  while (dinfo->output_scanline < dinfo->output_height)\n    jpeg_read_scanlines(dinfo, &row_pointer[dinfo->output_scanline],\n                        dinfo->output_height - dinfo->output_scanline);\n  jpeg_finish_decompress(dinfo);\n\nbailout:\n  if (dinfo->global_state > DSTATE_START) jpeg_abort_decompress(dinfo);\n  free(row_pointer);\n  if (this->jerr.warning) retval = -1;\n  this->jerr.stopOnWarning = FALSE;\n  return retval;\n}\n\n\n// target function\n\n\n  public static void main(String[] argv) {\n\n    try {\n\n      TJScalingFactor scalingFactor = new TJScalingFactor(1, 1);\n      int outSubsamp = -1, outQual = -1;\n      TJTransform xform = new TJTransform();\n      boolean display = false;\n      int flags = 0;\n      int width, height;\n      String inFormat = \"jpg\", outFormat = \"jpg\";\n      BufferedImage img = null;\n      byte[] imgBuf = null;\n\n      if (argv.length < 2)\n        usage();\n\n      if (argv[1].substring(0, 2).equalsIgnoreCase(\"-d\"))\n        display = true;\n\n      /* Parse arguments. */\n      for (int i = 2; i < argv.length; i++) {\n        if (argv[i].length() < 2)\n          continue;\n        else if (argv[i].length() > 2 &&\n                 argv[i].substring(0, 3).equalsIgnoreCase(\"-sc\") &&\n                 i < argv.length - 1) {\n          int match = 0;\n          String[] scaleArg = argv[++i].split(\"/\");\n          if (scaleArg.length == 2) {\n            TJScalingFactor tempsf =\n              new TJScalingFactor(Integer.parseInt(scaleArg[0]),\n                                  Integer.parseInt(scaleArg[1]));\n            for (int j = 0; j < SCALING_FACTORS.length; j++) {\n              if (tempsf.equals(SCALING_FACTORS[j])) {\n                scalingFactor = SCALING_FACTORS[j];\n                match = 1;\n                break;\n              }\n            }\n          }\n          if (match != 1)\n            usage();\n        } else if (argv[i].length() > 2 &&\n                   argv[i].substring(0, 3).equalsIgnoreCase(\"-su\") &&\n                   i < argv.length - 1) {\n          i++;\n          if (argv[i].substring(0, 1).equalsIgnoreCase(\"g\"))\n            outSubsamp = TJ.SAMP_GRAY;\n          else if (argv[i].equals(\"444\"))\n            outSubsamp = TJ.SAMP_444;\n          else if (argv[i].equals(\"422\"))\n            outSubsamp = TJ.SAMP_422;\n          else if (argv[i].equals(\"420\"))\n            outSubsamp = TJ.SAMP_420;\n          else\n            usage();\n        } else if (argv[i].substring(0, 2).equalsIgnoreCase(\"-q\") &&\n                   i < argv.length - 1) {\n          outQual = Integer.parseInt(argv[++i]);\n          if (outQual < 1 || outQual > 100)\n            usage();\n        } else if (argv[i].substring(0, 2).equalsIgnoreCase(\"-g\"))\n          xform.options |= TJTransform.OPT_GRAY;\n        else if (argv[i].equalsIgnoreCase(\"-hflip\"))\n          xform.op = TJTransform.OP_HFLIP;\n        else if (argv[i].equalsIgnoreCase(\"-vflip\"))\n          xform.op = TJTransform.OP_VFLIP;\n        else if (argv[i].equalsIgnoreCase(\"-transpose\"))\n          xform.op = TJTransform.OP_TRANSPOSE;\n        else if (argv[i].equalsIgnoreCase(\"-transverse\"))\n          xform.op = TJTransform.OP_TRANSVERSE;\n        else if (argv[i].equalsIgnoreCase(\"-rot90\"))\n          xform.op = TJTransform.OP_ROT90;\n        else if (argv[i].equalsIgnoreCase(\"-rot180\"))\n          xform.op = TJTransform.OP_ROT180;\n        else if (argv[i].equalsIgnoreCase(\"-rot270\"))\n          xform.op = TJTransform.OP_ROT270;\n        else if (argv[i].equalsIgnoreCase(\"-custom\"))\n          xform.cf = new TJExample();\n        else if (argv[i].length() > 2 &&\n                 argv[i].substring(0, 2).equalsIgnoreCase(\"-c\") &&\n                 i < argv.length - 1) {\n          String[] cropArg = argv[++i].split(\"[x\\\\+]\");\n          if (cropArg.length != 4)\n            usage();\n          xform.width = Integer.parseInt(cropArg[0]);\n          xform.height = Integer.parseInt(cropArg[1]);\n          xform.x = Integer.parseInt(cropArg[2]);\n          xform.y = Integer.parseInt(cropArg[3]);\n          if (xform.x < 0 || xform.y < 0 || xform.width < 1 ||\n              xform.height < 1)\n            usage();\n          xform.options |= TJTransform.OPT_CROP;\n        } else if (argv[i].substring(0, 2).equalsIgnoreCase(\"-d\"))\n          display = true;\n        else if (argv[i].equalsIgnoreCase(\"-fastupsample\")) {\n          System.out.println(\"Using fast upsampling code\");\n          flags |= TJ.FLAG_FASTUPSAMPLE;\n        } else if (argv[i].equalsIgnoreCase(\"-fastdct\")) {\n          System.out.println(\"Using fastest DCT/IDCT algorithm\");\n          flags |= TJ.FLAG_FASTDCT;\n        } else if (argv[i].equalsIgnoreCase(\"-accuratedct\")) {\n          System.out.println(\"Using most accurate DCT/IDCT algorithm\");\n          flags |= TJ.FLAG_ACCURATEDCT;\n        } else usage();\n      }\n\n      /* Determine input and output image formats based on file extensions. */\n      String[] inFileTokens = argv[0].split(\"\\\\.\");\n      if (inFileTokens.length > 1)\n        inFormat = inFileTokens[inFileTokens.length - 1];\n      String[] outFileTokens;\n      if (display)\n        outFormat = \"bmp\";\n      else {\n        outFileTokens = argv[1].split(\"\\\\.\");\n        if (outFileTokens.length > 1)\n          outFormat = outFileTokens[outFileTokens.length - 1];\n      }\n\n      if (inFormat.equalsIgnoreCase(\"jpg\")) {\n        /* Input image is a JPEG image.  Decompress and/or transform it. */\n        boolean doTransform = (xform.op != TJTransform.OP_NONE ||\n                               xform.options != 0 || xform.cf != null);\n\n        /* Read the JPEG file into memory. */\n        File jpegFile = new File(argv[0]);\n        FileInputStream fis = new FileInputStream(jpegFile);\n        int jpegSize = fis.available();\n        if (jpegSize < 1) {\n          System.out.println(\"Input file contains no data\");\n          System.exit(1);\n        }\n        byte[] jpegBuf = new byte[jpegSize];\n        fis.read(jpegBuf);\n        fis.close();\n\n        TJDecompressor tjd;\n        if (doTransform) {\n          /* Transform it. */\n          TJTransformer tjt = new TJTransformer(jpegBuf);\n          TJTransform[] xforms = new TJTransform[1];\n          xforms[0] = xform;\n          xforms[0].options |= TJTransform.OPT_TRIM;\n          TJDecompressor[] tjds = tjt.transform(xforms, 0);\n          tjd = tjds[0];\n          tjt.close();\n        } else\n          tjd = new TJDecompressor(jpegBuf);\n\n        width = tjd.getWidth();\n        height = tjd.getHeight();\n        int inSubsamp = tjd.getSubsamp();\n        int inColorspace = tjd.getColorspace();\n\n        System.out.println((doTransform ? \"Transformed\" : \"Input\") +\n                           \" Image (jpg):  \" + width + \" x \" + height +\n                           \" pixels, \" + SUBSAMP_NAME[inSubsamp] +\n                           \" subsampling, \" + COLORSPACE_NAME[inColorspace]);\n\n        if (outFormat.equalsIgnoreCase(\"jpg\") && doTransform &&\n            scalingFactor.isOne() && outSubsamp < 0 && outQual < 0) {\n          /* Input image has been transformed, and no re-compression options\n             have been selected.  Write the transformed image to disk and\n             exit. */\n          File outFile = new File(argv[1]);\n          FileOutputStream fos = new FileOutputStream(outFile);\n          fos.write(tjd.getJPEGBuf(), 0, tjd.getJPEGSize());\n          fos.close();\n          System.exit(0);\n        }\n\n        /* Scaling and/or a non-JPEG output image format and/or compression\n           options have been selected, so we need to decompress the\n           input/transformed image. */\n        width = scalingFactor.getScaled(width);\n        height = scalingFactor.getScaled(height);\n        if (outSubsamp < 0)\n          outSubsamp = inSubsamp;\n\n        if (!outFormat.equalsIgnoreCase(\"jpg\"))\n          img = tjd.decompress(width, height, BufferedImage.TYPE_INT_RGB,\n                               flags);\n        else\n          imgBuf = tjd.decompress(width, 0, height, TJ.PF_BGRX, flags);\n        tjd.close();\n      } else {\n        /* Input image is not a JPEG image.  Load it into memory. */\n        img = ImageIO.read(new File(argv[0]));\n        if (img == null)\n          throw new Exception(\"Input image type not supported.\");\n        width = img.getWidth();\n        height = img.getHeight();\n        if (outSubsamp < 0) {\n          if (img.getType() == BufferedImage.TYPE_BYTE_GRAY)\n            outSubsamp = TJ.SAMP_GRAY;\n          else\n            outSubsamp = DEFAULT_SUBSAMP;\n        }\n        System.out.println(\"Input Image:  \" + width + \" x \" + height +\n                           \" pixels\");\n      }\n      System.gc();\n      if (!display)\n        System.out.print(\"Output Image (\" + outFormat + \"):  \" + width +\n                         \" x \" + height + \" pixels\");\n\n      if (display) {\n        /* Display the uncompressed image */\n        ImageIcon icon = new ImageIcon(img);\n        JLabel label = new JLabel(icon, JLabel.CENTER);\n        JOptionPane.showMessageDialog(null, label, \"Output Image\",\n                                      JOptionPane.PLAIN_MESSAGE);\n      } else if (outFormat.equalsIgnoreCase(\"jpg\")) {\n        /* Output image format is JPEG.  Compress the uncompressed image. */\n        if (outQual < 0)\n          outQual = DEFAULT_QUALITY;\n        System.out.println(\", \" + SUBSAMP_NAME[outSubsamp] +\n                           \" subsampling, quality = \" + outQual);\n\n        TJCompressor tjc = new TJCompressor();\n        tjc.setSubsamp(outSubsamp);\n        tjc.setJPEGQuality(outQual);\n        if (img != null)\n          tjc.setSourceImage(img, 0, 0, 0, 0);\n        else\n          tjc.setSourceImage(imgBuf, 0, 0, width, 0, height, TJ.PF_BGRX);\n        byte[] jpegBuf = tjc.compress(flags);\n        int jpegSize = tjc.getCompressedSize();\n        tjc.close();\n\n        /* Write the JPEG image to disk. */\n        File outFile = new File(argv[1]);\n        FileOutputStream fos = new FileOutputStream(outFile);\n        fos.write(jpegBuf, 0, jpegSize);\n        fos.close();\n      } else {\n        /* Output image format is not JPEG.  Save the uncompressed image\n           directly to disk. */\n        System.out.print(\"\\n\");\n        File outFile = new File(argv[1]);\n        ImageIO.write(img, outFormat, outFile);\n      }\n\n    } catch (Exception e) {\n      e.printStackTrace();\n      System.exit(-1);\n    }\n  }\n  public byte[] getJPEGBuf() {\n    if (jpegBuf == null)\n      throw new IllegalStateException(NO_ASSOC_ERROR);\n    return jpegBuf;\n  }\nstatic int decomp(unsigned char *srcBuf, unsigned char **jpegBuf,\n                  unsigned long *jpegSize, unsigned char *dstBuf, int w, int h,\n                  int subsamp, int jpegQual, char *fileName, int tilew,\n                  int tileh)\n{\n  char tempStr[1024], sizeStr[24] = \"\\0\", qualStr[13] = \"\\0\", *ptr;\n  FILE *file = NULL;\n  tjhandle handle = NULL;\n  int row, col, iter = 0, dstBufAlloc = 0, retval = 0;\n  double elapsed, elapsedDecode;\n  int ps = tjPixelSize[pf];\n  int scaledw = TJSCALED(w, sf);\n  int scaledh = TJSCALED(h, sf);\n  int pitch = scaledw * ps;\n  int ntilesw = (w + tilew - 1) / tilew, ntilesh = (h + tileh - 1) / tileh;\n  unsigned char *dstPtr, *dstPtr2, *yuvBuf = NULL;\n\n  if (jpegQual > 0) {\n    SNPRINTF(qualStr, 13, \"_Q%d\", jpegQual);\n    qualStr[12] = 0;\n  }\n\n  if ((handle = tjInitDecompress()) == NULL)\n    THROW_TJ(\"executing tjInitDecompress()\");\n\n  if (dstBuf == NULL) {\n    if ((unsigned long long)pitch * (unsigned long long)scaledh >\n        (unsigned long long)((size_t)-1))\n      THROW(\"allocating destination buffer\", \"Image is too large\");\n    if ((dstBuf = (unsigned char *)malloc((size_t)pitch * scaledh)) == NULL)\n      THROW_UNIX(\"allocating destination buffer\");\n    dstBufAlloc = 1;\n  }\n  /* Set the destination buffer to gray so we know whether the decompressor\n     attempted to write to it */\n  memset(dstBuf, 127, (size_t)pitch * scaledh);\n\n  if (doYUV) {\n    int width = doTile ? tilew : scaledw;\n    int height = doTile ? tileh : scaledh;\n    unsigned long yuvSize = tjBufSizeYUV2(width, yuvPad, height, subsamp);\n\n    if (yuvSize == (unsigned long)-1)\n      THROW_TJ(\"allocating YUV buffer\");\n    if ((yuvBuf = (unsigned char *)malloc(yuvSize)) == NULL)\n      THROW_UNIX(\"allocating YUV buffer\");\n    memset(yuvBuf, 127, yuvSize);\n  }\n\n  /* Benchmark */\n  iter = -1;\n  elapsed = elapsedDecode = 0.;\n  while (1) {\n    int tile = 0;\n    double start = getTime();\n\n    for (row = 0, dstPtr = dstBuf; row < ntilesh;\n         row++, dstPtr += (size_t)pitch * tileh) {\n      for (col = 0, dstPtr2 = dstPtr; col < ntilesw;\n           col++, tile++, dstPtr2 += ps * tilew) {\n        int width = doTile ? min(tilew, w - col * tilew) : scaledw;\n        int height = doTile ? min(tileh, h - row * tileh) : scaledh;\n\n        if (doYUV) {\n          double startDecode;\n\n          if (tjDecompressToYUV2(handle, jpegBuf[tile], jpegSize[tile], yuvBuf,\n                                 width, yuvPad, height, flags) == -1)\n            THROW_TJ(\"executing tjDecompressToYUV2()\");\n          startDecode = getTime();\n          if (tjDecodeYUV(handle, yuvBuf, yuvPad, subsamp, dstPtr2, width,\n                          pitch, height, pf, flags) == -1)\n            THROW_TJ(\"executing tjDecodeYUV()\");\n          if (iter >= 0) elapsedDecode += getTime() - startDecode;\n        } else if (tjDecompress2(handle, jpegBuf[tile], jpegSize[tile],\n                                 dstPtr2, width, pitch, height, pf,\n                                 flags) == -1)\n          THROW_TJ(\"executing tjDecompress2()\");\n      }\n    }\n    elapsed += getTime() - start;\n    if (iter >= 0) {\n      iter++;\n      if (elapsed >= benchTime) break;\n    } else if (elapsed >= warmup) {\n      iter = 0;\n      elapsed = elapsedDecode = 0.;\n    }\n  }\n  if (doYUV) elapsed -= elapsedDecode;\n\n  if (tjDestroy(handle) == -1) THROW_TJ(\"executing tjDestroy()\");\n  handle = NULL;\n\n  if (quiet) {\n    printf(\"%-6s%s\",\n           sigfig((double)(w * h) / 1000000. * (double)iter / elapsed, 4,\n                  tempStr, 1024),\n           quiet == 2 ? \"\\n\" : \"  \");\n    if (doYUV)\n      printf(\"%s\\n\",\n             sigfig((double)(w * h) / 1000000. * (double)iter / elapsedDecode,\n                    4, tempStr, 1024));\n    else if (quiet != 2) printf(\"\\n\");\n  } else {\n    printf(\"%s --> Frame rate:         %f fps\\n\",\n           doYUV ? \"Decomp to YUV\" : \"Decompress   \", (double)iter / elapsed);\n    printf(\"                  Throughput:         %f Megapixels/sec\\n\",\n           (double)(w * h) / 1000000. * (double)iter / elapsed);\n    if (doYUV) {\n      printf(\"YUV Decode    --> Frame rate:         %f fps\\n\",\n             (double)iter / elapsedDecode);\n      printf(\"                  Throughput:         %f Megapixels/sec\\n\",\n             (double)(w * h) / 1000000. * (double)iter / elapsedDecode);\n    }\n  }\n\n  if (!doWrite) goto bailout;\n\n  if (sf.num != 1 || sf.denom != 1)\n    SNPRINTF(sizeStr, 24, \"%d_%d\", sf.num, sf.denom);\n  else if (tilew != w || tileh != h)\n    SNPRINTF(sizeStr, 24, \"%dx%d\", tilew, tileh);\n  else SNPRINTF(sizeStr, 24, \"full\");\n  if (decompOnly)\n    SNPRINTF(tempStr, 1024, \"%s_%s.%s\", fileName, sizeStr, ext);\n  else\n    SNPRINTF(tempStr, 1024, \"%s_%s%s_%s.%s\", fileName, subName[subsamp],\n             qualStr, sizeStr, ext);\n\n  if (tjSaveImage(tempStr, dstBuf, scaledw, 0, scaledh, pf, flags) == -1)\n    THROW_TJG(\"saving bitmap\");\n  ptr = strrchr(tempStr, '.');\n  SNPRINTF(ptr, 1024 - (ptr - tempStr), \"-err.%s\", ext);\n  if (srcBuf && sf.num == 1 && sf.denom == 1) {\n    if (!quiet) printf(\"Compression error written to %s.\\n\", tempStr);\n    if (subsamp == TJ_GRAYSCALE) {\n      unsigned long index, index2;\n\n      for (row = 0, index = 0; row < h; row++, index += pitch) {\n        for (col = 0, index2 = index; col < w; col++, index2 += ps) {\n          unsigned long rindex = index2 + tjRedOffset[pf];\n          unsigned long gindex = index2 + tjGreenOffset[pf];\n          unsigned long bindex = index2 + tjBlueOffset[pf];\n          int y = (int)((double)srcBuf[rindex] * 0.299 +\n                        (double)srcBuf[gindex] * 0.587 +\n                        (double)srcBuf[bindex] * 0.114 + 0.5);\n\n          if (y > 255) y = 255;\n          if (y < 0) y = 0;\n          dstBuf[rindex] = (unsigned char)abs(dstBuf[rindex] - y);\n          dstBuf[gindex] = (unsigned char)abs(dstBuf[gindex] - y);\n          dstBuf[bindex] = (unsigned char)abs(dstBuf[bindex] - y);\n        }\n      }\n    } else {\n      for (row = 0; row < h; row++)\n        for (col = 0; col < w * ps; col++)\n          dstBuf[pitch * row + col] =\n            (unsigned char)abs(dstBuf[pitch * row + col] -\n                               srcBuf[pitch * row + col]);\n    }\n    if (tjSaveImage(tempStr, dstBuf, w, 0, h, pf, flags) == -1)\n      THROW_TJG(\"saving bitmap\");\n  }\n\nbailout:\n  if (file) fclose(file);\n  if (handle) tjDestroy(handle);\n  if (dstBufAlloc) free(dstBuf);\n  free(yuvBuf);\n  return retval;\n}\nstatic int decompTest(char *fileName)\n{\n  FILE *file = NULL;\n  tjhandle handle = NULL;\n  unsigned char **jpegBuf = NULL, *srcBuf = NULL;\n  unsigned long *jpegSize = NULL, srcSize, totalJpegSize;\n  tjtransform *t = NULL;\n  double start, elapsed;\n  int ps = tjPixelSize[pf], tile, row, col, i, iter, retval = 0, decompsrc = 0;\n  char *temp = NULL, tempStr[80], tempStr2[80];\n  /* Original image */\n  int w = 0, h = 0, tilew, tileh, ntilesw = 1, ntilesh = 1, subsamp = -1,\n    cs = -1;\n  /* Transformed image */\n  int tw, th, ttilew, ttileh, tntilesw, tntilesh, tsubsamp;\n\n  if ((file = fopen(fileName, \"rb\")) == NULL)\n    THROW_UNIX(\"opening file\");\n  if (fseek(file, 0, SEEK_END) < 0 ||\n      (srcSize = ftell(file)) == (unsigned long)-1)\n    THROW_UNIX(\"determining file size\");\n  if ((srcBuf = (unsigned char *)malloc(srcSize)) == NULL)\n    THROW_UNIX(\"allocating memory\");\n  if (fseek(file, 0, SEEK_SET) < 0)\n    THROW_UNIX(\"setting file position\");\n  if (fread(srcBuf, srcSize, 1, file) < 1)\n    THROW_UNIX(\"reading JPEG data\");\n  fclose(file);  file = NULL;\n\n  temp = strrchr(fileName, '.');\n  if (temp != NULL) *temp = '\\0';\n\n  if ((handle = tjInitTransform()) == NULL)\n    THROW_TJ(\"executing tjInitTransform()\");\n  if (tjDecompressHeader3(handle, srcBuf, srcSize, &w, &h, &subsamp,\n                          &cs) == -1)\n    THROW_TJ(\"executing tjDecompressHeader3()\");\n  if (w < 1 || h < 1)\n    THROW(\"reading JPEG header\", \"Invalid image dimensions\");\n  if (cs == TJCS_YCCK || cs == TJCS_CMYK) {\n    pf = TJPF_CMYK;  ps = tjPixelSize[pf];\n  }\n\n  if (quiet == 1) {\n    printf(\"All performance values in Mpixels/sec\\n\\n\");\n    printf(\"Bitmap     JPEG   JPEG     %s  %s   Xform   Comp    Decomp  \",\n           doTile ? \"Tile \" : \"Image\", doTile ? \"Tile \" : \"Image\");\n    if (doYUV) printf(\"Decode\");\n    printf(\"\\n\");\n    printf(\"Format     CS     Subsamp  Width  Height  Perf    Ratio   Perf    \");\n    if (doYUV) printf(\"Perf\");\n    printf(\"\\n\\n\");\n  } else if (!quiet)\n    printf(\">>>>>  JPEG %s --> %s (%s)  <<<<<\\n\",\n           formatName(subsamp, cs, tempStr), pixFormatStr[pf],\n           (flags & TJFLAG_BOTTOMUP) ? \"Bottom-up\" : \"Top-down\");\n\n  for (tilew = doTile ? 16 : w, tileh = doTile ? 16 : h; ;\n       tilew *= 2, tileh *= 2) {\n    if (tilew > w) tilew = w;\n    if (tileh > h) tileh = h;\n    ntilesw = (w + tilew - 1) / tilew;\n    ntilesh = (h + tileh - 1) / tileh;\n\n    if ((jpegBuf = (unsigned char **)malloc(sizeof(unsigned char *) *\n                                            ntilesw * ntilesh)) == NULL)\n      THROW_UNIX(\"allocating JPEG tile array\");\n    memset(jpegBuf, 0, sizeof(unsigned char *) * ntilesw * ntilesh);\n    if ((jpegSize = (unsigned long *)malloc(sizeof(unsigned long) *\n                                            ntilesw * ntilesh)) == NULL)\n      THROW_UNIX(\"allocating JPEG size array\");\n    memset(jpegSize, 0, sizeof(unsigned long) * ntilesw * ntilesh);\n\n    if ((flags & TJFLAG_NOREALLOC) != 0 &&\n        (doTile || xformOp != TJXOP_NONE || xformOpt != 0 || customFilter))\n      for (i = 0; i < ntilesw * ntilesh; i++) {\n        if (tjBufSize(tilew, tileh, subsamp) > (unsigned long)INT_MAX)\n          THROW(\"getting buffer size\", \"Image is too large\");\n        if ((jpegBuf[i] = (unsigned char *)\n                          tjAlloc(tjBufSize(tilew, tileh, subsamp))) == NULL)\n          THROW_UNIX(\"allocating JPEG tiles\");\n      }\n\n    tw = w;  th = h;  ttilew = tilew;  ttileh = tileh;\n    if (!quiet) {\n      printf(\"\\n%s size: %d x %d\", doTile ? \"Tile\" : \"Image\", ttilew, ttileh);\n      if (sf.num != 1 || sf.denom != 1)\n        printf(\" --> %d x %d\", TJSCALED(tw, sf), TJSCALED(th, sf));\n      printf(\"\\n\");\n    } else if (quiet == 1) {\n      printf(\"%-4s (%s)  %-5s  %-5s    \", pixFormatStr[pf],\n             (flags & TJFLAG_BOTTOMUP) ? \"BU\" : \"TD\", csName[cs],\n             subNameLong[subsamp]);\n      printf(\"%-5d  %-5d   \", tilew, tileh);\n    }\n\n    tsubsamp = subsamp;\n    if (doTile || xformOp != TJXOP_NONE || xformOpt != 0 || customFilter) {\n      if ((t = (tjtransform *)malloc(sizeof(tjtransform) * ntilesw *\n                                     ntilesh)) == NULL)\n        THROW_UNIX(\"allocating image transform array\");\n\n      if (xformOp == TJXOP_TRANSPOSE || xformOp == TJXOP_TRANSVERSE ||\n          xformOp == TJXOP_ROT90 || xformOp == TJXOP_ROT270) {\n        tw = h;  th = w;  ttilew = tileh;  ttileh = tilew;\n      }\n\n      if (xformOpt & TJXOPT_GRAY) tsubsamp = TJ_GRAYSCALE;\n      if (xformOp == TJXOP_HFLIP || xformOp == TJXOP_ROT180)\n        tw = tw - (tw % tjMCUWidth[tsubsamp]);\n      if (xformOp == TJXOP_VFLIP || xformOp == TJXOP_ROT180)\n        th = th - (th % tjMCUHeight[tsubsamp]);\n      if (xformOp == TJXOP_TRANSVERSE || xformOp == TJXOP_ROT90)\n        tw = tw - (tw % tjMCUHeight[tsubsamp]);\n      if (xformOp == TJXOP_TRANSVERSE || xformOp == TJXOP_ROT270)\n        th = th - (th % tjMCUWidth[tsubsamp]);\n      tntilesw = (tw + ttilew - 1) / ttilew;\n      tntilesh = (th + ttileh - 1) / ttileh;\n\n      if (xformOp == TJXOP_TRANSPOSE || xformOp == TJXOP_TRANSVERSE ||\n          xformOp == TJXOP_ROT90 || xformOp == TJXOP_ROT270) {\n        if (tsubsamp == TJSAMP_422) tsubsamp = TJSAMP_440;\n        else if (tsubsamp == TJSAMP_440) tsubsamp = TJSAMP_422;\n      }\n\n      for (row = 0, tile = 0; row < tntilesh; row++) {\n        for (col = 0; col < tntilesw; col++, tile++) {\n          t[tile].r.w = min(ttilew, tw - col * ttilew);\n          t[tile].r.h = min(ttileh, th - row * ttileh);\n          t[tile].r.x = col * ttilew;\n          t[tile].r.y = row * ttileh;\n          t[tile].op = xformOp;\n          t[tile].options = xformOpt | TJXOPT_TRIM;\n          t[tile].customFilter = customFilter;\n          if (t[tile].options & TJXOPT_NOOUTPUT && jpegBuf[tile]) {\n            tjFree(jpegBuf[tile]);  jpegBuf[tile] = NULL;\n          }\n        }\n      }\n\n      iter = -1;\n      elapsed = 0.;\n      while (1) {\n        start = getTime();\n        if (tjTransform(handle, srcBuf, srcSize, tntilesw * tntilesh, jpegBuf,\n                        jpegSize, t, flags) == -1)\n          THROW_TJ(\"executing tjTransform()\");\n        elapsed += getTime() - start;\n        if (iter >= 0) {\n          iter++;\n          if (elapsed >= benchTime) break;\n        } else if (elapsed >= warmup) {\n          iter = 0;\n          elapsed = 0.;\n        }\n      }\n\n      free(t);  t = NULL;\n\n      for (tile = 0, totalJpegSize = 0; tile < tntilesw * tntilesh; tile++)\n        totalJpegSize += jpegSize[tile];\n\n      if (quiet) {\n        printf(\"%-6s%s%-6s%s\",\n               sigfig((double)(w * h) / 1000000. / elapsed, 4, tempStr, 80),\n               quiet == 2 ? \"\\n\" : \"  \",\n               sigfig((double)(w * h * ps) / (double)totalJpegSize, 4,\n                      tempStr2, 80),\n               quiet == 2 ? \"\\n\" : \"  \");\n      } else {\n        printf(\"Transform     --> Frame rate:         %f fps\\n\",\n               1.0 / elapsed);\n        printf(\"                  Output image size:  %lu bytes\\n\",\n               totalJpegSize);\n        printf(\"                  Compression ratio:  %f:1\\n\",\n               (double)(w * h * ps) / (double)totalJpegSize);\n        printf(\"                  Throughput:         %f Megapixels/sec\\n\",\n               (double)(w * h) / 1000000. / elapsed);\n        printf(\"                  Output bit stream:  %f Megabits/sec\\n\",\n               (double)totalJpegSize * 8. / 1000000. / elapsed);\n      }\n    } else {\n      if (quiet == 1) printf(\"N/A     N/A     \");\n      tjFree(jpegBuf[0]);\n      jpegBuf[0] = NULL;\n      decompsrc = 1;\n    }\n\n    if (w == tilew) ttilew = tw;\n    if (h == tileh) ttileh = th;\n    if (!(xformOpt & TJXOPT_NOOUTPUT)) {\n      if (decomp(NULL, decompsrc ? &srcBuf : jpegBuf,\n                 decompsrc ? &srcSize : jpegSize, NULL, tw, th, tsubsamp, 0,\n                 fileName, ttilew, ttileh) == -1)\n        goto bailout;\n    } else if (quiet == 1) printf(\"N/A\\n\");\n\n    for (i = 0; i < ntilesw * ntilesh; i++) {\n      tjFree(jpegBuf[i]);\n      jpegBuf[i] = NULL;\n    }\n    free(jpegBuf);  jpegBuf = NULL;\n    free(jpegSize);  jpegSize = NULL;\n\n    if (tilew == w && tileh == h) break;\n  }\n\nbailout:\n  if (file) fclose(file);\n  if (jpegBuf) {\n    for (i = 0; i < ntilesw * ntilesh; i++)\n      tjFree(jpegBuf[i]);\n  }\n  free(jpegBuf);\n  free(jpegSize);\n  free(srcBuf);\n  free(t);\n  if (handle) { tjDestroy(handle);  handle = NULL; }\n  return retval;\n}\nint main(int argc, char **argv)\n{\n  tjscalingfactor scalingFactor = { 1, 1 };\n  int outSubsamp = -1, outQual = -1;\n  tjtransform xform;\n  int flags = 0;\n  int width, height;\n  char *inFormat, *outFormat;\n  FILE *jpegFile = NULL;\n  unsigned char *imgBuf = NULL, *jpegBuf = NULL;\n  int retval = 0, i, pixelFormat = TJPF_UNKNOWN;\n  tjhandle tjInstance = NULL;\n\n  if ((scalingFactors = tjGetScalingFactors(&numScalingFactors)) == NULL)\n    THROW_TJ(\"getting scaling factors\");\n  memset(&xform, 0, sizeof(tjtransform));\n\n  if (argc < 3)\n    usage(argv[0]);\n\n  /* Parse arguments. */\n  for (i = 3; i < argc; i++) {\n    if (!strncasecmp(argv[i], \"-sc\", 3) && i < argc - 1) {\n      int match = 0, temp1 = 0, temp2 = 0, j;\n\n      if (sscanf(argv[++i], \"%d/%d\", &temp1, &temp2) < 2)\n        usage(argv[0]);\n      for (j = 0; j < numScalingFactors; j++) {\n        if ((double)temp1 / (double)temp2 == (double)scalingFactors[j].num /\n                                             (double)scalingFactors[j].denom) {\n          scalingFactor = scalingFactors[j];\n          match = 1;\n          break;\n        }\n      }\n      if (match != 1)\n        usage(argv[0]);\n    } else if (!strncasecmp(argv[i], \"-su\", 3) && i < argc - 1) {\n      i++;\n      if (!strncasecmp(argv[i], \"g\", 1))\n        outSubsamp = TJSAMP_GRAY;\n      else if (!strcasecmp(argv[i], \"444\"))\n        outSubsamp = TJSAMP_444;\n      else if (!strcasecmp(argv[i], \"422\"))\n        outSubsamp = TJSAMP_422;\n      else if (!strcasecmp(argv[i], \"420\"))\n        outSubsamp = TJSAMP_420;\n      else\n        usage(argv[0]);\n    } else if (!strncasecmp(argv[i], \"-q\", 2) && i < argc - 1) {\n      outQual = atoi(argv[++i]);\n      if (outQual < 1 || outQual > 100)\n        usage(argv[0]);\n    } else if (!strncasecmp(argv[i], \"-g\", 2))\n      xform.options |= TJXOPT_GRAY;\n    else if (!strcasecmp(argv[i], \"-hflip\"))\n      xform.op = TJXOP_HFLIP;\n    else if (!strcasecmp(argv[i], \"-vflip\"))\n      xform.op = TJXOP_VFLIP;\n    else if (!strcasecmp(argv[i], \"-transpose\"))\n      xform.op = TJXOP_TRANSPOSE;\n    else if (!strcasecmp(argv[i], \"-transverse\"))\n      xform.op = TJXOP_TRANSVERSE;\n    else if (!strcasecmp(argv[i], \"-rot90\"))\n      xform.op = TJXOP_ROT90;\n    else if (!strcasecmp(argv[i], \"-rot180\"))\n      xform.op = TJXOP_ROT180;\n    else if (!strcasecmp(argv[i], \"-rot270\"))\n      xform.op = TJXOP_ROT270;\n    else if (!strcasecmp(argv[i], \"-custom\"))\n      xform.customFilter = customFilter;\n    else if (!strncasecmp(argv[i], \"-c\", 2) && i < argc - 1) {\n      if (sscanf(argv[++i], \"%dx%d+%d+%d\", &xform.r.w, &xform.r.h, &xform.r.x,\n                 &xform.r.y) < 4 ||\n          xform.r.x < 0 || xform.r.y < 0 || xform.r.w < 1 || xform.r.h < 1)\n        usage(argv[0]);\n      xform.options |= TJXOPT_CROP;\n    } else if (!strcasecmp(argv[i], \"-fastupsample\")) {\n      printf(\"Using fast upsampling code\\n\");\n      flags |= TJFLAG_FASTUPSAMPLE;\n    } else if (!strcasecmp(argv[i], \"-fastdct\")) {\n      printf(\"Using fastest DCT/IDCT algorithm\\n\");\n      flags |= TJFLAG_FASTDCT;\n    } else if (!strcasecmp(argv[i], \"-accuratedct\")) {\n      printf(\"Using most accurate DCT/IDCT algorithm\\n\");\n      flags |= TJFLAG_ACCURATEDCT;\n    } else usage(argv[0]);\n  }\n\n  /* Determine input and output image formats based on file extensions. */\n  inFormat = strrchr(argv[1], '.');\n  outFormat = strrchr(argv[2], '.');\n  if (inFormat == NULL || outFormat == NULL || strlen(inFormat) < 2 ||\n      strlen(outFormat) < 2)\n    usage(argv[0]);\n  inFormat = &inFormat[1];\n  outFormat = &outFormat[1];\n\n  if (!strcasecmp(inFormat, \"jpg\")) {\n    /* Input image is a JPEG image.  Decompress and/or transform it. */\n    long size;\n    int inSubsamp, inColorspace;\n    int doTransform = (xform.op != TJXOP_NONE || xform.options != 0 ||\n                       xform.customFilter != NULL);\n    unsigned long jpegSize;\n\n    /* Read the JPEG file into memory. */\n    if ((jpegFile = fopen(argv[1], \"rb\")) == NULL)\n      THROW_UNIX(\"opening input file\");\n    if (fseek(jpegFile, 0, SEEK_END) < 0 || ((size = ftell(jpegFile)) < 0) ||\n        fseek(jpegFile, 0, SEEK_SET) < 0)\n      THROW_UNIX(\"determining input file size\");\n    if (size == 0)\n      THROW(\"determining input file size\", \"Input file contains no data\");\n    jpegSize = (unsigned long)size;\n    if ((jpegBuf = (unsigned char *)tjAlloc(jpegSize)) == NULL)\n      THROW_UNIX(\"allocating JPEG buffer\");\n    if (fread(jpegBuf, jpegSize, 1, jpegFile) < 1)\n      THROW_UNIX(\"reading input file\");\n    fclose(jpegFile);  jpegFile = NULL;\n\n    if (doTransform) {\n      /* Transform it. */\n      unsigned char *dstBuf = NULL;  /* Dynamically allocate the JPEG buffer */\n      unsigned long dstSize = 0;\n\n      if ((tjInstance = tjInitTransform()) == NULL)\n        THROW_TJ(\"initializing transformer\");\n      xform.options |= TJXOPT_TRIM;\n      if (tjTransform(tjInstance, jpegBuf, jpegSize, 1, &dstBuf, &dstSize,\n                      &xform, flags) < 0) {\n        tjFree(dstBuf);\n        THROW_TJ(\"transforming input image\");\n      }\n      tjFree(jpegBuf);\n      jpegBuf = dstBuf;\n      jpegSize = dstSize;\n    } else {\n      if ((tjInstance = tjInitDecompress()) == NULL)\n        THROW_TJ(\"initializing decompressor\");\n    }\n\n    if (tjDecompressHeader3(tjInstance, jpegBuf, jpegSize, &width, &height,\n                            &inSubsamp, &inColorspace) < 0)\n      THROW_TJ(\"reading JPEG header\");\n\n    printf(\"%s Image:  %d x %d pixels, %s subsampling, %s colorspace\\n\",\n           (doTransform ? \"Transformed\" : \"Input\"), width, height,\n           subsampName[inSubsamp], colorspaceName[inColorspace]);\n\n    if (!strcasecmp(outFormat, \"jpg\") && doTransform &&\n        scalingFactor.num == 1 && scalingFactor.denom == 1 && outSubsamp < 0 &&\n        outQual < 0) {\n      /* Input image has been transformed, and no re-compression options\n         have been selected.  Write the transformed image to disk and exit. */\n      if ((jpegFile = fopen(argv[2], \"wb\")) == NULL)\n        THROW_UNIX(\"opening output file\");\n      if (fwrite(jpegBuf, jpegSize, 1, jpegFile) < 1)\n        THROW_UNIX(\"writing output file\");\n      fclose(jpegFile);  jpegFile = NULL;\n      goto bailout;\n    }\n\n    /* Scaling and/or a non-JPEG output image format and/or compression options\n       have been selected, so we need to decompress the input/transformed\n       image. */\n    width = TJSCALED(width, scalingFactor);\n    height = TJSCALED(height, scalingFactor);\n    if (outSubsamp < 0)\n      outSubsamp = inSubsamp;\n\n    pixelFormat = TJPF_BGRX;\n    if ((imgBuf = (unsigned char *)tjAlloc(width * height *\n                                           tjPixelSize[pixelFormat])) == NULL)\n      THROW_UNIX(\"allocating uncompressed image buffer\");\n\n    if (tjDecompress2(tjInstance, jpegBuf, jpegSize, imgBuf, width, 0, height,\n                      pixelFormat, flags) < 0)\n      THROW_TJ(\"decompressing JPEG image\");\n    tjFree(jpegBuf);  jpegBuf = NULL;\n    tjDestroy(tjInstance);  tjInstance = NULL;\n  } else {\n    /* Input image is not a JPEG image.  Load it into memory. */\n    if ((imgBuf = tjLoadImage(argv[1], &width, 1, &height, &pixelFormat,\n                              0)) == NULL)\n      THROW_TJ(\"loading input image\");\n    if (outSubsamp < 0) {\n      if (pixelFormat == TJPF_GRAY)\n        outSubsamp = TJSAMP_GRAY;\n      else\n        outSubsamp = TJSAMP_444;\n    }\n    printf(\"Input Image:  %d x %d pixels\\n\", width, height);\n  }\n\n  printf(\"Output Image (%s):  %d x %d pixels\", outFormat, width, height);\n\n  if (!strcasecmp(outFormat, \"jpg\")) {\n    /* Output image format is JPEG.  Compress the uncompressed image. */\n    unsigned long jpegSize = 0;\n\n    jpegBuf = NULL;  /* Dynamically allocate the JPEG buffer */\n\n    if (outQual < 0)\n      outQual = DEFAULT_QUALITY;\n    printf(\", %s subsampling, quality = %d\\n\", subsampName[outSubsamp],\n           outQual);\n\n    if ((tjInstance = tjInitCompress()) == NULL)\n      THROW_TJ(\"initializing compressor\");\n    if (tjCompress2(tjInstance, imgBuf, width, 0, height, pixelFormat,\n                    &jpegBuf, &jpegSize, outSubsamp, outQual, flags) < 0)\n      THROW_TJ(\"compressing image\");\n    tjDestroy(tjInstance);  tjInstance = NULL;\n\n    /* Write the JPEG image to disk. */\n    if ((jpegFile = fopen(argv[2], \"wb\")) == NULL)\n      THROW_UNIX(\"opening output file\");\n    if (fwrite(jpegBuf, jpegSize, 1, jpegFile) < 1)\n      THROW_UNIX(\"writing output file\");\n    tjDestroy(tjInstance);  tjInstance = NULL;\n    fclose(jpegFile);  jpegFile = NULL;\n    tjFree(jpegBuf);  jpegBuf = NULL;\n  } else {\n    /* Output image format is not JPEG.  Save the uncompressed image\n       directly to disk. */\n    printf(\"\\n\");\n    if (tjSaveImage(argv[2], imgBuf, width, 0, height, pixelFormat, 0) < 0)\n      THROW_TJ(\"saving output image\");\n  }\n\nbailout:\n  tjFree(imgBuf);\n  if (tjInstance) tjDestroy(tjInstance);\n  tjFree(jpegBuf);\n  if (jpegFile) fclose(jpegFile);\n  return retval;\n}\nJNIEXPORT void JNICALL Java_org_libjpegturbo_turbojpeg_TJDecompressor_decompressHeader\n  (JNIEnv *env, jobject obj, jbyteArray src, jint jpegSize)\n{\n  tjhandle handle = 0;\n  unsigned char *jpegBuf = NULL;\n  int width = 0, height = 0, jpegSubsamp = -1, jpegColorspace = -1;\n\n  GET_HANDLE();\n\n  if ((*env)->GetArrayLength(env, src) < jpegSize)\n    THROW_ARG(\"Source buffer is not large enough\");\n\n  BAILIF0NOEC(jpegBuf = (*env)->GetPrimitiveArrayCritical(env, src, 0));\n\n  if (tjDecompressHeader3(handle, jpegBuf, (unsigned long)jpegSize, &width,\n                          &height, &jpegSubsamp, &jpegColorspace) == -1) {\n    SAFE_RELEASE(src, jpegBuf);\n    THROW_TJ();\n  }\n\n  SAFE_RELEASE(src, jpegBuf);\n\n  BAILIF0(_fid = (*env)->GetFieldID(env, _cls, \"jpegSubsamp\", \"I\"));\n  (*env)->SetIntField(env, obj, _fid, jpegSubsamp);\n  if ((_fid = (*env)->GetFieldID(env, _cls, \"jpegColorspace\", \"I\")) == 0)\n    (*env)->ExceptionClear(env);\n  else\n    (*env)->SetIntField(env, obj, _fid, jpegColorspace);\n  BAILIF0(_fid = (*env)->GetFieldID(env, _cls, \"jpegWidth\", \"I\"));\n  (*env)->SetIntField(env, obj, _fid, width);\n  BAILIF0(_fid = (*env)->GetFieldID(env, _cls, \"jpegHeight\", \"I\"));\n  (*env)->SetIntField(env, obj, _fid, height);\n\nbailout:\n  SAFE_RELEASE(src, jpegBuf);\n}\nDLLEXPORT int tjDecompressHeader3(tjhandle handle,\n                                  const unsigned char *jpegBuf,\n                                  unsigned long jpegSize, int *width,\n                                  int *height, int *jpegSubsamp,\n                                  int *jpegColorspace)\n{\n  int retval = 0;\n\n  GET_DINSTANCE(handle);\n  if ((this->init & DECOMPRESS) == 0)\n    THROW(\"tjDecompressHeader3(): Instance has not been initialized for decompression\");\n\n  if (jpegBuf == NULL || jpegSize <= 0 || width == NULL || height == NULL ||\n      jpegSubsamp == NULL || jpegColorspace == NULL)\n    THROW(\"tjDecompressHeader3(): Invalid argument\");\n\n  if (setjmp(this->jerr.setjmp_buffer)) {\n    /* If we get here, the JPEG code has signaled an error. */\n    return -1;\n  }\n\n  jpeg_mem_src_tj(dinfo, jpegBuf, jpegSize);\n\n  /* jpeg_read_header() calls jpeg_abort() and returns JPEG_HEADER_TABLES_ONLY\n     if the datastream is a tables-only datastream.  Since we aren't using a\n     suspending data source, the only other value it can return is\n     JPEG_HEADER_OK. */\n  if (jpeg_read_header(dinfo, FALSE) == JPEG_HEADER_TABLES_ONLY)\n    return 0;\n\n  *width = dinfo->image_width;\n  *height = dinfo->image_height;\n  *jpegSubsamp = getSubsamp(dinfo);\n  switch (dinfo->jpeg_color_space) {\n  case JCS_GRAYSCALE:  *jpegColorspace = TJCS_GRAY;  break;\n  case JCS_RGB:        *jpegColorspace = TJCS_RGB;  break;\n  case JCS_YCbCr:      *jpegColorspace = TJCS_YCbCr;  break;\n  case JCS_CMYK:       *jpegColorspace = TJCS_CMYK;  break;\n  case JCS_YCCK:       *jpegColorspace = TJCS_YCCK;  break;\n  default:             *jpegColorspace = -1;  break;\n  }\n\n  jpeg_abort_decompress(dinfo);\n\n  if (*jpegSubsamp < 0)\n    THROW(\"tjDecompressHeader3(): Could not determine subsampling type for JPEG image\");\n  if (*jpegColorspace < 0)\n    THROW(\"tjDecompressHeader3(): Could not determine colorspace of JPEG image\");\n  if (*width < 1 || *height < 1)\n    THROW(\"tjDecompressHeader3(): Invalid data returned in header\");\n\nbailout:\n  if (this->jerr.warning) retval = -1;\n  return retval;\n}\nDLLEXPORT int tjDecompressHeader2(tjhandle handle, unsigned char *jpegBuf,\n                                  unsigned long jpegSize, int *width,\n                                  int *height, int *jpegSubsamp)\n{\n  int jpegColorspace;\n\n  return tjDecompressHeader3(handle, jpegBuf, jpegSize, width, height,\n                             jpegSubsamp, &jpegColorspace);\n}\nDLLEXPORT int tjDecompressHeader(tjhandle handle, unsigned char *jpegBuf,\n                                 unsigned long jpegSize, int *width,\n                                 int *height)\n{\n  int jpegSubsamp;\n\n  return tjDecompressHeader2(handle, jpegBuf, jpegSize, width, height,\n                             &jpegSubsamp);\n}\n",
    "target": 1,
    "idx": 1053499,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "// context\nstatic JXL_INLINE void StoreLE32(const uint32_t native, uint8_t* p) {\n#if JXL_BYTE_ORDER_LITTLE\n  const uint32_t little = native;\n  memcpy(p, &little, 4);\n#else\n  // Byte-order-independent - can't assume this machine is big endian.\n  p[3] = native >> 24;\n  p[2] = (native >> 16) & 0xFF;\n  p[1] = (native >> 8) & 0xFF;\n  p[0] = native & 0xFF;\n#endif\n}\n\nvoid StoreLEFloat(float value, uint8_t* p) {\n  uint32_t u;\n  memcpy(&u, &value, 4);\n  StoreLE32(u, p);\n}\n\nvoid JXL_INLINE Store8(uint32_t value, uint8_t* dest) { *dest = value & 0xff; }\n\n\n\n\n\nvoid ThreadParallelRunner::RunRange(ThreadParallelRunner* self,\n                                    const WorkerCommand command,\n                                    const int thread) {\n  const uint32_t begin = command >> 32;\n  const uint32_t end = command & 0xFFFFFFFF;\n  const uint32_t num_tasks = end - begin;\n  const uint32_t num_worker_threads = self->num_worker_threads_;\n\n  // OpenMP introduced several \"schedule\" strategies:\n  // \"single\" (static assignment of exactly one chunk per thread): slower.\n  // \"dynamic\" (allocates k tasks at a time): competitive for well-chosen k.\n  // \"guided\" (allocates k tasks, decreases k): computing k = remaining/n\n  //   is faster than halving k each iteration. We prefer this strategy\n  //   because it avoids user-specified parameters.\n\n  for (;;) {\n#if 0\n      // dynamic\n      const uint32_t my_size = std::max(num_tasks / (num_worker_threads * 4), 1);\n#else\n    // guided\n    const uint32_t num_reserved =\n        self->num_reserved_.load(std::memory_order_relaxed);\n    const uint32_t num_remaining = num_tasks - num_reserved;\n    const uint32_t my_size =\n        std::max(num_remaining / (num_worker_threads * 4), 1u);\n#endif\n    const uint32_t my_begin = begin + self->num_reserved_.fetch_add(\n                                          my_size, std::memory_order_relaxed);\n    const uint32_t my_end = std::min(my_begin + my_size, begin + num_tasks);\n    // Another thread already reserved the last task.\n    if (my_begin >= my_end) {\n      break;\n    }\n    for (uint32_t task = my_begin; task < my_end; ++task) {\n      self->data_func_(self->jpegxl_opaque_, task, thread);\n    }\n  }\n}\n\nvoid ThreadParallelRunner::ThreadFunc(ThreadParallelRunner* self,\n                                      const int thread) {\n  // Until kWorkerExit command received:\n  for (;;) {\n    std::unique_lock<std::mutex> lock(self->mutex_);\n    // Notify main thread that this thread is ready.\n    if (++self->workers_ready_ == self->num_threads_) {\n      self->workers_ready_cv_.notify_one();\n    }\n  RESUME_WAIT:\n    // Wait for a command.\n    self->worker_start_cv_.wait(lock);\n    const WorkerCommand command = self->worker_start_command_;\n    switch (command) {\n      case kWorkerWait:    // spurious wakeup:\n        goto RESUME_WAIT;  // lock still held, avoid incrementing ready.\n      case kWorkerOnce:\n        lock.unlock();\n        self->data_func_(self->jpegxl_opaque_, thread, thread);\n        break;\n      case kWorkerExit:\n        return;  // exits thread\n      default:\n        lock.unlock();\n        RunRange(self, command, thread);\n        break;\n    }\n  }\n}\n\n\n// target function\nJXL_EXPORT JxlDecoderStatus JxlDecoderPreviewOutBufferSize(\n    const JxlDecoder* dec, const JxlPixelFormat* format, size_t* size) {\n  size_t bits;\n  JxlDecoderStatus status = PrepareSizeCheck(dec, format, &bits);\n  if (status != JXL_DEC_SUCCESS) return status;\n\n  const auto& metadata = dec->metadata.m;\n  size_t xsize = metadata.preview_size.xsize();\n  size_t ysize = metadata.preview_size.ysize();\n\n  size_t row_size =\n      jxl::DivCeil(xsize * format->num_channels * bits, jxl::kBitsPerByte);\n  if (format->align > 1) {\n    row_size = jxl::DivCeil(row_size, format->align) * format->align;\n  }\n  *size = row_size * ysize;\n  return JXL_DEC_SUCCESS;\n}\nJXL_EXPORT JxlDecoderStatus JxlDecoderDCOutBufferSize(\n    const JxlDecoder* dec, const JxlPixelFormat* format, size_t* size) {\n  size_t bits;\n  JxlDecoderStatus status = PrepareSizeCheck(dec, format, &bits);\n  if (status != JXL_DEC_SUCCESS) return status;\n\n  size_t xsize = jxl::DivCeil(dec->metadata.size.xsize(), jxl::kBlockDim);\n  size_t ysize = jxl::DivCeil(dec->metadata.size.ysize(), jxl::kBlockDim);\n\n  size_t row_size =\n      jxl::DivCeil(xsize * format->num_channels * bits, jxl::kBitsPerByte);\n  if (format->align > 1) {\n    row_size = jxl::DivCeil(row_size, format->align) * format->align;\n  }\n  *size = row_size * ysize;\n  return JXL_DEC_SUCCESS;\n}\nJXL_EXPORT JxlDecoderStatus JxlDecoderImageOutBufferSize(\n    const JxlDecoder* dec, const JxlPixelFormat* format, size_t* size) {\n  size_t bits;\n  JxlDecoderStatus status = PrepareSizeCheck(dec, format, &bits);\n  if (status != JXL_DEC_SUCCESS) return status;\n\n  size_t row_size =\n      jxl::DivCeil(dec->metadata.size.xsize() * format->num_channels * bits,\n                   jxl::kBitsPerByte);\n  if (format->align > 1) {\n    row_size = jxl::DivCeil(row_size, format->align) * format->align;\n  }\n  *size = row_size * dec->metadata.size.ysize();\n\n  return JXL_DEC_SUCCESS;\n}\n",
    "target": 1,
    "idx": 1035172,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nint\nidn2_to_ascii_4i (const uint32_t * input, size_t inlen, char * output, int flags)\n{\n  uint32_t *input_u32;\n  uint8_t *input_u8, *output_u8;\n  size_t length;\n  int rc;\n\n  if (!input)\n    {\n      if (output)\n\t*output = 0;\n      return IDN2_OK;\n    }\n\n  input_u32 = (uint32_t *) malloc ((inlen + 1) * sizeof(uint32_t));\n  if (!input_u32)\n    return IDN2_MALLOC;\n\n  u32_cpy (input_u32, input, inlen);\n  input_u32[inlen] = 0;\n\n  input_u8 = u32_to_u8 (input_u32, inlen + 1, NULL, &length);\n  free (input_u32);\n  if (!input_u8)\n    {\n      if (errno == ENOMEM)\n\treturn IDN2_MALLOC;\n      return IDN2_ENCODING_ERROR;\n    }\n\n  rc = idn2_lookup_u8 (input_u8, &output_u8, flags);\n  free (input_u8);\n\n  if (rc == IDN2_OK)\n    {\n      /* wow, this is ugly, but libidn manpage states:\n       * char * out  output zero terminated string that must have room for at\n       * least 63 characters plus the terminating zero.\n       */\n      size_t len = strlen ((char *) output_u8);\n\n      if (len > 63)\n        {\n\t  free (output_u8);\n\t  return IDN2_TOO_BIG_DOMAIN;\n        }\n\n      if (output)\n\tstrcpy (output, (char *) output_u8);\n\n      free (output_u8);\n    }\n\n  return rc;\n}\n\n\n// target function\nint\nidn2_to_ascii_4i (const uint32_t * input, size_t inlen, char * output, int flags)\n{\n  uint32_t *input_u32;\n  uint8_t *input_u8, *output_u8;\n  size_t length;\n  int rc;\n\n  if (!input)\n    {\n      if (output)\n\t*output = 0;\n      return IDN2_OK;\n    }\n\n  input_u32 = (uint32_t *) malloc ((inlen + 1) * sizeof(uint32_t));\n  if (!input_u32)\n    return IDN2_MALLOC;\n\n  u32_cpy (input_u32, input, inlen);\n  input_u32[inlen] = 0;\n\n  input_u8 = u32_to_u8 (input_u32, inlen + 1, NULL, &length);\n  free (input_u32);\n  if (!input_u8)\n    {\n      if (errno == ENOMEM)\n\treturn IDN2_MALLOC;\n      return IDN2_ENCODING_ERROR;\n    }\n\n  rc = idn2_lookup_u8 (input_u8, &output_u8, flags);\n  free (input_u8);\n\n  if (rc == IDN2_OK)\n    {\n      /* wow, this is ugly, but libidn manpage states:\n       * char * out  output zero terminated string that must have room for at\n       * least 63 characters plus the terminating zero.\n       */\n      if (output)\n\tstrcpy (output, (const char *) output_u8);\n\n      free(output_u8);\n    }\n\n  return rc;\n}\n",
    "target": 1,
    "idx": 1012420,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic int MqttClient_DecodePacket(MqttClient* client, byte* rx_buf,\n    word32 rx_len, void *packet_obj, MqttPacketType* ppacket_type,\n    MqttQoS* ppacket_qos, word16* ppacket_id)\n{\n    int rc = MQTT_CODE_SUCCESS;\n    MqttPacket* header;\n    MqttPacketType packet_type;\n    MqttQoS packet_qos;\n    word16 packet_id = 0;\n#ifdef WOLFMQTT_V5\n    MqttProp* props = NULL;\n#endif\n\n    /* must have rx buffer with at least 2 byes for header */\n    if (rx_buf == NULL || rx_len < MQTT_PACKET_HEADER_MIN_SIZE) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    /* Decode header */\n    header = (MqttPacket*)rx_buf;\n    packet_type = (MqttPacketType)MQTT_PACKET_TYPE_GET(header->type_flags);\n    if (ppacket_type) {\n        *ppacket_type = packet_type;\n    }\n    packet_qos = (MqttQoS)MQTT_PACKET_FLAGS_GET_QOS(header->type_flags);\n    if (ppacket_qos) {\n        *ppacket_qos = packet_qos;\n    }\n\n    /* Decode packet specific data (if requested) */\n    if (ppacket_id || packet_obj) {\n        switch (packet_type) {\n        case MQTT_PACKET_TYPE_CONNECT_ACK:\n        {\n            MqttConnectAck connect_ack, *p_connect_ack = &connect_ack;\n            if (packet_obj) {\n                p_connect_ack = (MqttConnectAck*)packet_obj;\n            }\n            else {\n                XMEMSET(p_connect_ack, 0, sizeof(MqttConnectAck));\n            }\n        #ifdef WOLFMQTT_V5\n            p_connect_ack->protocol_level = client->protocol_level;\n        #endif\n            rc = MqttDecode_ConnectAck(rx_buf, rx_len, p_connect_ack);\n        #ifdef WOLFMQTT_V5\n            if (rc >= 0) {\n                props = p_connect_ack->props;\n            }\n        #endif\n            break;\n        }\n        case MQTT_PACKET_TYPE_PUBLISH:\n        {\n            MqttPublish publish, *p_publish = &publish;\n            if (packet_obj) {\n                p_publish = (MqttPublish*)packet_obj;\n            }\n            else {\n                XMEMSET(p_publish, 0, sizeof(MqttPublish));\n            }\n        #ifdef WOLFMQTT_V5\n            p_publish->protocol_level = client->protocol_level;\n        #endif\n            rc = MqttDecode_Publish(rx_buf, rx_len, p_publish);\n            if (rc >= 0) {\n                packet_id = p_publish->packet_id;\n            #ifdef WOLFMQTT_V5\n                props = p_publish->props;\n            #endif\n            }\n            break;\n        }\n        case MQTT_PACKET_TYPE_PUBLISH_ACK:\n        case MQTT_PACKET_TYPE_PUBLISH_REC:\n        case MQTT_PACKET_TYPE_PUBLISH_REL:\n        case MQTT_PACKET_TYPE_PUBLISH_COMP:\n        {\n            MqttPublishResp publish_resp, *p_publish_resp = &publish_resp;\n            if (packet_obj) {\n                p_publish_resp = (MqttPublishResp*)packet_obj;\n            }\n            else {\n                XMEMSET(p_publish_resp, 0, sizeof(MqttPublishResp));\n            }\n        #ifdef WOLFMQTT_V5\n                p_publish_resp->protocol_level = client->protocol_level;\n        #endif\n                rc = MqttDecode_PublishResp(rx_buf, rx_len, packet_type,\n                p_publish_resp);\n            if (rc >= 0) {\n                packet_id = p_publish_resp->packet_id;\n            #ifdef WOLFMQTT_V5\n                props = p_publish_resp->props;\n            #endif\n            }\n            break;\n        }\n        case MQTT_PACKET_TYPE_SUBSCRIBE_ACK:\n        {\n            MqttSubscribeAck subscribe_ack, *p_subscribe_ack = &subscribe_ack;\n            if (packet_obj) {\n                p_subscribe_ack = (MqttSubscribeAck*)packet_obj;\n            }\n            else {\n                XMEMSET(p_subscribe_ack, 0, sizeof(MqttSubscribeAck));\n            }\n        #ifdef WOLFMQTT_V5\n            p_subscribe_ack->protocol_level = client->protocol_level;\n        #endif\n            rc = MqttDecode_SubscribeAck(rx_buf, rx_len, p_subscribe_ack);\n            if (rc >= 0) {\n                packet_id = p_subscribe_ack->packet_id;\n            #ifdef WOLFMQTT_V5\n                props = p_subscribe_ack->props;\n            #endif\n            }\n            break;\n        }\n        case MQTT_PACKET_TYPE_UNSUBSCRIBE_ACK:\n        {\n            MqttUnsubscribeAck unsubscribe_ack,\n                               *p_unsubscribe_ack = &unsubscribe_ack;\n            if (packet_obj) {\n                p_unsubscribe_ack = (MqttUnsubscribeAck*)packet_obj;\n            }\n            else {\n                XMEMSET(p_unsubscribe_ack, 0, sizeof(MqttUnsubscribeAck));\n            }\n        #ifdef WOLFMQTT_V5\n            p_unsubscribe_ack->protocol_level = client->protocol_level;\n        #endif\n            rc = MqttDecode_UnsubscribeAck(rx_buf, rx_len, p_unsubscribe_ack);\n            if (rc >= 0) {\n                packet_id = p_unsubscribe_ack->packet_id;\n            #ifdef WOLFMQTT_V5\n                props = p_unsubscribe_ack->props;\n            #endif\n            }\n            break;\n        }\n        case MQTT_PACKET_TYPE_PING_RESP:\n        {\n            MqttPing ping, *p_ping = &ping;\n            if (packet_obj) {\n                p_ping = (MqttPing*)packet_obj;\n            }\n            else {\n                XMEMSET(p_ping, 0, sizeof(MqttPing));\n            }\n            rc = MqttDecode_Ping(rx_buf, rx_len, p_ping);\n            break;\n        }\n        case MQTT_PACKET_TYPE_AUTH:\n        {\n        #ifdef WOLFMQTT_V5\n            MqttAuth auth, *p_auth = &auth;\n            if (packet_obj) {\n                p_auth = (MqttAuth*)packet_obj;\n            }\n            else {\n                XMEMSET(p_auth, 0, sizeof(MqttAuth));\n            }\n            rc = MqttDecode_Auth(rx_buf, rx_len, p_auth);\n            if (rc >= 0) {\n                props = p_auth->props;\n            }\n        #else\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n        #endif /* WOLFMQTT_V5 */\n            break;\n        }\n        case MQTT_PACKET_TYPE_DISCONNECT:\n        {\n        #ifdef WOLFMQTT_V5\n            MqttDisconnect disc, *p_disc = &disc;\n            if (packet_obj) {\n                p_disc = (MqttDisconnect*)packet_obj;\n            }\n            else {\n                XMEMSET(p_disc, 0, sizeof(MqttDisconnect));\n            }\n            rc = MqttDecode_Disconnect(rx_buf, rx_len, p_disc);\n            if (rc >= 0) {\n                props = p_disc->props;\n            }\n        #else\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n        #endif /* WOLFMQTT_V5 */\n            break;\n        }\n        case MQTT_PACKET_TYPE_CONNECT:\n        case MQTT_PACKET_TYPE_SUBSCRIBE:\n        case MQTT_PACKET_TYPE_UNSUBSCRIBE:\n        case MQTT_PACKET_TYPE_PING_REQ:\n        case MQTT_PACKET_TYPE_ANY:\n        case MQTT_PACKET_TYPE_RESERVED:\n        default:\n            /* these type are only encoded by client */\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n            break;\n        } /* switch (packet_type) */\n    }\n\n    if (ppacket_id) {\n        *ppacket_id = packet_id;\n    }\n\n#ifdef WOLFMQTT_V5\n    if (props) {\n    #ifdef WOLFMQTT_PROPERTY_CB\n        /* Check for properties set by the server */\n        if (packet_obj && client->property_cb) {\n            /* capture error if returned */\n            int rc_err = client->property_cb(client, props,\n                    client->property_ctx);\n            if (rc_err < 0) {\n                rc = rc_err;\n            }\n        }\n    #endif\n        /* Free the properties */\n        MqttProps_Free(props);\n    }\n#endif\n\n    (void)client;\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"MqttClient_DecodePacket: Rc %d, Len %d, Type %s (%d), ID %d,\"\n            \" QoS %d\",\n        rc, rx_len, MqttPacket_TypeDesc(packet_type), packet_type, packet_id,\n        packet_qos);\n#endif\n\n    return rc;\n}\n\nstatic int MqttClient_WaitType(MqttClient *client, void *packet_obj,\n    byte wait_type, word16 wait_packet_id, int timeout_ms)\n{\n    int rc;\n    word16 packet_id;\n    MqttPacketType packet_type;\n#ifdef WOLFMQTT_MULTITHREAD\n    MqttPendResp *pendResp;\n    int readLocked;\n#endif\n    MqttMsgStat* mms_stat;\n    int waitMatchFound;\n\n    if (client == NULL || packet_obj == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    /* all packet type structures must have MqttMsgStat at top */\n    mms_stat = (MqttMsgStat*)packet_obj;\n\nwait_again:\n\n    /* initialize variables */\n    packet_id = 0;\n    packet_type = MQTT_PACKET_TYPE_RESERVED;\n#ifdef WOLFMQTT_MULTITHREAD\n    pendResp = NULL;\n    readLocked = 0;\n#endif\n    waitMatchFound = 0;\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"MqttClient_WaitType: Type %s (%d), ID %d\",\n        MqttPacket_TypeDesc((MqttPacketType)wait_type),\n            wait_type, wait_packet_id);\n#endif\n\n    switch ((int)*mms_stat)\n    {\n        case MQTT_MSG_BEGIN:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Lock recv socket mutex */\n            rc = wm_SemLock(&client->lockRecv);\n            if (rc != 0) {\n                PRINTF(\"MqttClient_WaitType: recv lock error!\");\n                return rc;\n            }\n            readLocked = 1;\n        #endif\n\n            /* reset the packet state */\n            client->packet.stat = MQTT_PK_BEGIN;\n        }\n        FALL_THROUGH;\n\n    #ifdef WOLFMQTT_V5\n        case MQTT_MSG_AUTH:\n    #endif\n        case MQTT_MSG_WAIT:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if packet type and id have already completed */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, (MqttPacketType)wait_type, \n                    wait_packet_id, &pendResp)) {\n                    if (pendResp->packetDone) {\n                        /* pending response is already done, so return */\n                        rc = pendResp->packet_ret;\n                    #ifdef WOLFMQTT_DEBUG_CLIENT\n                        PRINTF(\"PendResp already Done %p: Rc %d\", pendResp, rc);\n                    #endif\n                        MqttClient_RespList_Remove(client, pendResp);\n                        wm_SemUnlock(&client->lockClient);\n                        wm_SemUnlock(&client->lockRecv);\n                        return rc;\n                    }\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            *mms_stat = MQTT_MSG_WAIT;\n\n            /* Wait for packet */\n            rc = MqttPacket_Read(client, client->rx_buf, client->rx_buf_len,\n                    timeout_ms);\n            /* handle failure */\n            if (rc <= 0) {\n                break;\n            }\n\n            /* capture length read */\n            client->packet.buf_len = rc;\n\n            /* Decode Packet - get type and id */\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, NULL, &packet_type, NULL, &packet_id);\n            if (rc < 0) {\n                break;\n            }\n\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"Read Packet: Len %d, Type %d, ID %d\",\n                client->packet.buf_len, packet_type, packet_id);\n        #endif\n\n            *mms_stat = MQTT_MSG_READ;\n        }\n        FALL_THROUGH;\n\n        case MQTT_MSG_READ:\n        case MQTT_MSG_READ_PAYLOAD:\n        {\n            MqttPacketType use_packet_type;\n            void* use_packet_obj;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            readLocked = 1; /* if in this state read is locked */\n        #endif\n\n            /* read payload state only happens for publish messages */\n            if (*mms_stat == MQTT_MSG_READ_PAYLOAD) {\n                packet_type = MQTT_PACKET_TYPE_PUBLISH;\n            }\n\n            /* Determine if we received data for this request */\n            if ((wait_type == MQTT_PACKET_TYPE_ANY ||\n                 wait_type == packet_type ||\n                 (MqttIsPubRespPacket(packet_type) &&\n                  MqttIsPubRespPacket(wait_type))) &&\n                (wait_packet_id == 0 || wait_packet_id == packet_id))\n            {\n                use_packet_obj = packet_obj;\n                waitMatchFound = 1;\n            }\n            else {\n                /* use generic packet object */\n                use_packet_obj = &client->msg;\n            }\n            use_packet_type = packet_type;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if we have a pending response for this packet */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, packet_type, packet_id,\n                                                               &pendResp)) {\n                    /* we found packet match this incoming read packet */\n                    pendResp->packetProcessing = 1;\n                    use_packet_obj = pendResp->packet_obj;\n                    use_packet_type = pendResp->packet_type;\n                    /* req from another thread... not a match */\n                    waitMatchFound = 0;\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            /* Perform packet handling for publish callback and QoS */\n            rc = MqttClient_HandlePacket(client, use_packet_type,\n                use_packet_obj, timeout_ms);\n\n        #ifdef WOLFMQTT_NONBLOCK\n            if (rc == MQTT_CODE_CONTINUE) {\n                /* we have received some data, so keep the recv\n                    mutex lock active and return */\n                return rc;\n            }\n        #endif\n\n            /* handle success case */\n            if (rc >= 0) {\n                rc = MQTT_CODE_SUCCESS;\n            }\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (pendResp) {\n                /* Mark pending response entry done */\n                if (wm_SemLock(&client->lockClient) == 0) {\n                    pendResp->packetDone = 1;\n                    pendResp->packet_ret = rc;\n                #ifdef WOLFMQTT_DEBUG_CLIENT\n                    PRINTF(\"PendResp Done %p\", pendResp);\n                #endif\n                    pendResp = NULL;\n                    wm_SemUnlock(&client->lockClient);\n                }\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n            break;\n        }\n\n        case MQTT_MSG_WRITE:\n        case MQTT_MSG_WRITE_PAYLOAD:\n        default:\n        {\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"MqttClient_WaitType: Invalid state %d!\", *mms_stat);\n        #endif\n            rc = MQTT_CODE_ERROR_STAT;\n            break;\n        }\n    } /* switch (*mms_stat) */\n\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc != MQTT_CODE_CONTINUE)\n#endif\n    {\n        /* reset state */\n        *mms_stat = MQTT_MSG_BEGIN;\n    }\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (readLocked) {\n        wm_SemUnlock(&client->lockRecv);\n    }\n#endif\n    if (rc < 0) {\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_WaitType: Failure: %s (%d)\",\n            MqttClient_ReturnCodeToString(rc), rc);\n    #endif\n        return rc;\n    }\n\n    if (!waitMatchFound) {\n        /* if we get here, then the we are still waiting for a packet */\n        goto wait_again;\n    }\n\n    return rc;\n}\n\nint MqttClient_Connect(MqttClient *client, MqttConnect *mc_connect)\n{\n    int rc, len = 0;\n\n    /* Validate required arguments */\n    if (client == NULL || mc_connect == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    if (mc_connect->stat == MQTT_MSG_BEGIN) {\n    #ifdef WOLFMQTT_MULTITHREAD\n        /* Lock send socket mutex */\n        rc = wm_SemLock(&client->lockSend);\n        if (rc != 0) {\n            return rc;\n        }\n    #endif\n\n    #ifdef WOLFMQTT_V5\n        /* Use specified protocol version if set */\n        mc_connect->protocol_level = client->protocol_level;\n    #endif\n\n        /* Encode the connect packet */\n        rc = MqttEncode_Connect(client->tx_buf, client->tx_buf_len, mc_connect);\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d), ID %d, QoS %d\",\n            rc, MqttPacket_TypeDesc(MQTT_PACKET_TYPE_CONNECT),\n            MQTT_PACKET_TYPE_CONNECT, 0, 0);\n    #endif\n        if (rc <= 0) {\n            #ifdef WOLFMQTT_MULTITHREAD\n                wm_SemUnlock(&client->lockSend);\n            #endif\n            return rc;\n        }\n        len = rc;\n\n    #ifdef WOLFMQTT_MULTITHREAD\n        rc = wm_SemLock(&client->lockClient);\n        if (rc == 0) {\n            /* inform other threads of expected response */\n            rc = MqttClient_RespList_Add(client, MQTT_PACKET_TYPE_CONNECT_ACK,\n                    0, &mc_connect->pendResp, &mc_connect->ack);\n            wm_SemUnlock(&client->lockClient);\n        }\n        if (rc != 0) {\n            wm_SemUnlock(&client->lockSend);\n            return rc; /* Error locking client */\n        }\n    #endif\n\n        /* Send connect packet */\n        rc = MqttPacket_Write(client, client->tx_buf, len);\n    #ifdef WOLFMQTT_MULTITHREAD\n        wm_SemUnlock(&client->lockSend);\n    #endif\n        if (rc != len) {\n    #ifdef WOLFMQTT_MULTITHREAD\n            if ((rc != MQTT_CODE_CONTINUE) &&\n                (wm_SemLock(&client->lockClient)) == 0) {\n                MqttClient_RespList_Remove(client, &mc_connect->pendResp);\n                wm_SemUnlock(&client->lockClient);\n            }\n    #endif\n            return rc;\n        }\n    #ifdef WOLFMQTT_V5\n        /* Enhanced authentication */\n        if (client->enable_eauth == 1) {\n            mc_connect->stat = MQTT_MSG_AUTH;\n        }\n        else\n    #endif\n        {\n            mc_connect->stat = MQTT_MSG_WAIT;\n        }\n    }\n\n#ifdef WOLFMQTT_V5\n    /* Enhanced authentication */\n    if (mc_connect->protocol_level > MQTT_CONNECT_PROTOCOL_LEVEL_4 && \n            mc_connect->stat == MQTT_MSG_AUTH)\n    {\n        MqttAuth auth, *p_auth = &auth;\n        MqttProp* prop, *conn_prop;\n\n        /* Find the AUTH property in the connect structure */\n        for (conn_prop = mc_connect->props;\n             (conn_prop != NULL) && (conn_prop->type != MQTT_PROP_AUTH_METHOD);\n             conn_prop = conn_prop->next) {\n        }\n        if (conn_prop == NULL) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (wm_SemLock(&client->lockClient) == 0) {\n                MqttClient_RespList_Remove(client, &mc_connect->pendResp);\n                wm_SemUnlock(&client->lockClient);\n            }\n        #endif\n            /* AUTH property was not set in connect structure */\n            return MQTT_CODE_ERROR_BAD_ARG;\n        }\n\n        XMEMSET((void*)p_auth, 0, sizeof(MqttAuth));\n\n        /* Set the authentication reason */\n        p_auth->reason_code = MQTT_REASON_CONT_AUTH;\n\n        /* Use the same authentication method property from connect */\n        prop = MqttProps_Add(&p_auth->props);\n        prop->type = MQTT_PROP_AUTH_METHOD;\n        prop->data_str.str = conn_prop->data_str.str;\n        prop->data_str.len = conn_prop->data_str.len;\n\n        /* Send the AUTH packet */\n        rc = MqttClient_Auth(client, p_auth);\n        MqttClient_PropsFree(p_auth->props);\n    #ifdef WOLFMQTT_NONBLOCK\n        if (rc == MQTT_CODE_CONTINUE)\n            return rc;\n    #endif\n        if (rc != len) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (wm_SemLock(&client->lockClient) == 0) {\n                MqttClient_RespList_Remove(client, &mc_connect->pendResp);\n                wm_SemUnlock(&client->lockClient);\n            }\n        #endif\n            return rc;\n        }\n    }\n#endif /* WOLFMQTT_V5 */\n\n    /* Wait for connect ack packet */\n    rc = MqttClient_WaitType(client, &mc_connect->ack,\n        MQTT_PACKET_TYPE_CONNECT_ACK, 0, client->cmd_timeout_ms);\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc == MQTT_CODE_CONTINUE)\n        return rc;\n#endif\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (wm_SemLock(&client->lockClient) == 0) {\n        MqttClient_RespList_Remove(client, &mc_connect->pendResp);\n        wm_SemUnlock(&client->lockClient);\n    }\n#endif\n\n    /* reset state */\n    mc_connect->stat = MQTT_MSG_BEGIN;\n\n    return rc;\n}\n\nbool wolfMQTTFuzzer::Initialize(void) {\n    bool ret = false;\n    MqttMessage* lwt_msg = nullptr;\n\n    try {\n        /* net */\n        {\n            memset(net, 0, sizeof(*net));\n\n            net->connect = mqtt_connect;\n            net->read = mqtt_recv;\n            net->write = mqtt_write;\n            net->disconnect = mqtt_disconnect;\n            net->context = this;\n        }\n\n        /* client */\n        {\n            memset(client, 0, sizeof(*client));\n\n            tx_size = ds.Get<uint16_t>();\n            tx_size = 4096;\n            tx_buf = (uint8_t*)this->malloc(tx_size);\n            rx_size = ds.Get<uint16_t>();\n            rx_size = 4096;\n            rx_buf = (uint8_t*)this->malloc(rx_size);\n            memset(tx_buf, 0, tx_size);\n            memset(rx_buf, 0, rx_size);\n\n            client->msg_cb = mqtt_message_cb;\n            client->tx_buf = tx_buf;\n            client->tx_buf_len = tx_size;\n            client->rx_buf = rx_buf;\n            client->rx_buf_len = rx_size;\n            client->cmd_timeout_ms = 1000;\n        }\n\n        /* connect */\n        {\n            memset(connect, 0, sizeof(*connect));\n\n            connect->keep_alive_sec = 1;\n            connect->clean_session = ds.Get<bool>() ? 1 : 0;\n            client_id = ds.Get<std::string>();\n            connect->client_id = client_id.c_str();\n            connect->enable_lwt = ds.Get<bool>() ? 1 : 0;\n        }\n            \n        std::string lwt_topic_name;\n        std::vector<uint8_t> lwt_buffer;\n\n        if ( connect->enable_lwt ) {\n            lwt_topic_name = ds.Get<std::string>();\n            lwt_buffer = ds.GetData(0);\n\n            lwt_msg = new MqttMessage;\n            memset(lwt_msg, 0, sizeof(*lwt_msg));\n\n            connect->lwt_msg = lwt_msg;\n            lwt_msg->qos = GetQoS();\n            lwt_msg->retain = ds.Get<bool>() ? 1 : 0;\n            lwt_msg->topic_name = lwt_topic_name.c_str();\n            lwt_msg->buffer = lwt_buffer.data();\n            lwt_msg->total_len = lwt_buffer.size();\n        }\n\n        CHECK_EQ(MqttSocket_Init(client, net), MQTT_CODE_SUCCESS);\n\n#if 0\n        if ( ds.Get<bool>() ) {\n            //CHECK_EQ(MqttClient_SetPropertyCallback(&client, mqtt_property_cb, NULL);\n        }\n#endif\n\n        CHECK_EQ(MqttClient_NetConnect(client, \"dummy\", 12345, 1000, 0, NULL), MQTT_CODE_SUCCESS);\n        CHECK_EQ(MqttClient_Connect(client, connect), MQTT_CODE_SUCCESS);\n\n        ret = true;\n    } catch ( ... ) {\n        ret = false;\n    }\n\nend:\n    if ( lwt_msg ) {\n        delete lwt_msg;\n    }\n    return ret;\n}\n\n\n// target function\nstatic int MqttClient_WaitType(MqttClient *client, void *packet_obj,\n    byte wait_type, word16 wait_packet_id, int timeout_ms)\n{\n    int rc;\n    word16 packet_id;\n    MqttPacketType packet_type;\n#ifdef WOLFMQTT_MULTITHREAD\n    MqttPendResp *pendResp;\n    int readLocked;\n#endif\n    MqttMsgStat* mms_stat;\n    int waitMatchFound;\n\n    if (client == NULL || packet_obj == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    /* all packet type structures must have MqttMsgStat at top */\n    mms_stat = (MqttMsgStat*)packet_obj;\n\nwait_again:\n\n    /* initialize variables */\n    packet_id = 0;\n    packet_type = MQTT_PACKET_TYPE_RESERVED;\n#ifdef WOLFMQTT_MULTITHREAD\n    pendResp = NULL;\n    readLocked = 0;\n#endif\n    waitMatchFound = 0;\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"MqttClient_WaitType: Type %s (%d), ID %d\",\n        MqttPacket_TypeDesc((MqttPacketType)wait_type),\n            wait_type, wait_packet_id);\n#endif\n\n    switch ((int)*mms_stat)\n    {\n        case MQTT_MSG_BEGIN:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Lock recv socket mutex */\n            rc = wm_SemLock(&client->lockRecv);\n            if (rc != 0) {\n                PRINTF(\"MqttClient_WaitType: recv lock error!\");\n                return rc;\n            }\n            readLocked = 1;\n        #endif\n\n            /* reset the packet state */\n            client->packet.stat = MQTT_PK_BEGIN;\n        }\n        FALL_THROUGH;\n\n    #ifdef WOLFMQTT_V5\n        case MQTT_MSG_AUTH:\n    #endif\n        case MQTT_MSG_WAIT:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if packet type and id have already completed */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, (MqttPacketType)wait_type, \n                    wait_packet_id, &pendResp)) {\n                    if (pendResp->packetDone) {\n                        /* pending response is already done, so return */\n                        rc = pendResp->packet_ret;\n                    #ifdef WOLFMQTT_DEBUG_CLIENT\n                        PRINTF(\"PendResp already Done %p: Rc %d\", pendResp, rc);\n                    #endif\n                        MqttClient_RespList_Remove(client, pendResp);\n                        wm_SemUnlock(&client->lockClient);\n                        wm_SemUnlock(&client->lockRecv);\n                        return rc;\n                    }\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            *mms_stat = MQTT_MSG_WAIT;\n\n            /* Wait for packet */\n            rc = MqttPacket_Read(client, client->rx_buf, client->rx_buf_len,\n                    timeout_ms);\n            /* handle failure */\n            if (rc <= 0) {\n                break;\n            }\n\n            /* capture length read */\n            client->packet.buf_len = rc;\n\n            /* Decode Packet - get type and id */\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, NULL, &packet_type, NULL, &packet_id);\n            if (rc < 0) {\n                break;\n            }\n\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"Read Packet: Len %d, Type %d, ID %d\",\n                client->packet.buf_len, packet_type, packet_id);\n        #endif\n\n            *mms_stat = MQTT_MSG_READ;\n        }\n        FALL_THROUGH;\n\n        case MQTT_MSG_READ:\n        case MQTT_MSG_READ_PAYLOAD:\n        {\n            MqttPacketType use_packet_type;\n            void* use_packet_obj;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            readLocked = 1; /* if in this state read is locked */\n        #endif\n\n            /* read payload state only happens for publish messages */\n            if (*mms_stat == MQTT_MSG_READ_PAYLOAD) {\n                packet_type = MQTT_PACKET_TYPE_PUBLISH;\n            }\n\n            /* Determine if we received data for this request */\n            if ((wait_type == MQTT_PACKET_TYPE_ANY ||\n                 wait_type == packet_type ||\n                 MqttIsPubRespPacket(packet_type) == MqttIsPubRespPacket(wait_type)) &&\n               (wait_packet_id == 0 || wait_packet_id == packet_id))\n            {\n                use_packet_obj = packet_obj;\n                waitMatchFound = 1;\n            }\n            else {\n                /* use generic packet object */\n                use_packet_obj = &client->msg;\n            }\n            use_packet_type = packet_type;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if we have a pending response for this packet */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, packet_type, packet_id,\n                                                               &pendResp)) {\n                    /* we found packet match this incoming read packet */\n                    pendResp->packetProcessing = 1;\n                    use_packet_obj = pendResp->packet_obj;\n                    use_packet_type = pendResp->packet_type;\n                    /* req from another thread... not a match */\n                    waitMatchFound = 0;\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            /* Perform packet handling for publish callback and QoS */\n            rc = MqttClient_HandlePacket(client, use_packet_type,\n                use_packet_obj, timeout_ms);\n\n        #ifdef WOLFMQTT_NONBLOCK\n            if (rc == MQTT_CODE_CONTINUE) {\n                /* we have received some data, so keep the recv\n                    mutex lock active and return */\n                return rc;\n            }\n        #endif\n\n            /* handle success case */\n            if (rc >= 0) {\n                rc = MQTT_CODE_SUCCESS;\n            }\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (pendResp) {\n                /* Mark pending response entry done */\n                if (wm_SemLock(&client->lockClient) == 0) {\n                    pendResp->packetDone = 1;\n                    pendResp->packet_ret = rc;\n                #ifdef WOLFMQTT_DEBUG_CLIENT\n                    PRINTF(\"PendResp Done %p\", pendResp);\n                #endif\n                    pendResp = NULL;\n                    wm_SemUnlock(&client->lockClient);\n                }\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n            break;\n        }\n\n        case MQTT_MSG_WRITE:\n        case MQTT_MSG_WRITE_PAYLOAD:\n        default:\n        {\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"MqttClient_WaitType: Invalid state %d!\", *mms_stat);\n        #endif\n            rc = MQTT_CODE_ERROR_STAT;\n            break;\n        }\n    } /* switch (*mms_stat) */\n\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc != MQTT_CODE_CONTINUE)\n#endif\n    {\n        /* reset state */\n        *mms_stat = MQTT_MSG_BEGIN;\n    }\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (readLocked) {\n        wm_SemUnlock(&client->lockRecv);\n    }\n#endif\n    if (rc < 0) {\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_WaitType: Failure: %s (%d)\",\n            MqttClient_ReturnCodeToString(rc), rc);\n    #endif\n        return rc;\n    }\n\n    if (!waitMatchFound) {\n        /* if we get here, then the we are still waiting for a packet */\n        goto wait_again;\n    }\n\n    return rc;\n}\n",
    "target": 1,
    "idx": 1038146,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nint LibRaw::raw2image(void)\n{\n\n  CHECK_ORDER_LOW(LIBRAW_PROGRESS_LOAD_RAW);\n\n  try\n  {\n    raw2image_start();\n\n    if (is_phaseone_compressed() && imgdata.rawdata.raw_alloc)\n    {\n      phase_one_allocate_tempbuffer();\n      int rc = phase_one_subtract_black((ushort *)imgdata.rawdata.raw_alloc,\n                                        imgdata.rawdata.raw_image);\n      if (rc == 0)\n        rc = phase_one_correct();\n      if (rc != 0)\n      {\n        phase_one_free_tempbuffer();\n        return rc;\n      }\n    }\n\n    // free and re-allocate image bitmap\n    if (imgdata.image)\n    {\n      imgdata.image = (ushort(*)[4])realloc(\n          imgdata.image, S.iheight * S.iwidth * sizeof(*imgdata.image));\n      memset(imgdata.image, 0, S.iheight * S.iwidth * sizeof(*imgdata.image));\n    }\n    else\n      imgdata.image =\n          (ushort(*)[4])calloc(S.iheight * S.iwidth, sizeof(*imgdata.image));\n\n\n    libraw_decoder_info_t decoder_info;\n    get_decoder_info(&decoder_info);\n\n    // Copy area size\n    int copyheight = MAX(0, MIN(int(S.height), int(S.raw_height) - int(S.top_margin)));\n    int copywidth = MAX(0, MIN(int(S.width), int(S.raw_width) - int(S.left_margin)));\n\n    // Move saved bitmap to imgdata.image\n    if ((imgdata.idata.filters || P1.colors == 1) && imgdata.rawdata.raw_image)\n    {\n      if (IO.fuji_width)\n      {\n        unsigned r, c;\n        int row, col;\n        for (row = 0; row < S.raw_height - S.top_margin * 2; row++)\n        {\n          for (col = 0;\n               col < IO.fuji_width\n                         << int(!libraw_internal_data.unpacker_data.fuji_layout);\n               col++)\n          {\n            if (libraw_internal_data.unpacker_data.fuji_layout)\n            {\n              r = IO.fuji_width - 1 - col + (row >> 1);\n              c = col + ((row + 1) >> 1);\n            }\n            else\n            {\n              r = IO.fuji_width - 1 + row - (col >> 1);\n              c = row + ((col + 1) >> 1);\n            }\n            if (r < S.height && c < S.width && col + int(S.left_margin) < int(S.raw_width))\n              imgdata.image[((r) >> IO.shrink) * S.iwidth + ((c) >> IO.shrink)]\n                           [FC(r, c)] =\n                  imgdata.rawdata\n                      .raw_image[(row + S.top_margin) * S.raw_pitch / 2 +\n                                 (col + S.left_margin)];\n          }\n        }\n      }\n      else\n      {\n        int row, col;\n        for (row = 0; row < copyheight; row++)\n          for (col = 0; col < copywidth; col++)\n            imgdata.image[((row) >> IO.shrink) * S.iwidth +\n                          ((col) >> IO.shrink)][fcol(row, col)] =\n                imgdata.rawdata\n                    .raw_image[(row + S.top_margin) * S.raw_pitch / 2 +\n                               (col + S.left_margin)];\n      }\n    }\n    else // if(decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)\n    {\n      if (imgdata.rawdata.color4_image)\n      {\n        if (S.width * 8u == S.raw_pitch && S.height == S.raw_height)\n          memmove(imgdata.image, imgdata.rawdata.color4_image,\n                  S.width * S.height * sizeof(*imgdata.image));\n        else\n        {\n            for (int row = 0; row < copyheight; row++)\n            memmove(&imgdata.image[row * S.width],\n                    &imgdata.rawdata\n                         .color4_image[(row + S.top_margin) * S.raw_pitch / 8 +\n                                       S.left_margin],\n                    copywidth * sizeof(*imgdata.image));\n        }\n      }\n      else if (imgdata.rawdata.color3_image)\n      {\n        unsigned char *c3image = (unsigned char *)imgdata.rawdata.color3_image;\n        for (int row = 0; row < copyheight; row++)\n        {\n          ushort(*srcrow)[3] =\n              (ushort(*)[3]) & c3image[(row + S.top_margin) * S.raw_pitch];\n          ushort(*dstrow)[4] = (ushort(*)[4]) & imgdata.image[row * S.width];\n          for (int col = 0; col < copywidth; col++)\n          {\n            for (int c = 0; c < 3; c++)\n              dstrow[col][c] = srcrow[S.left_margin + col][c];\n            dstrow[col][3] = 0;\n          }\n        }\n      }\n      else\n      {\n        // legacy decoder, but no data?\n        throw LIBRAW_EXCEPTION_DECODE_RAW;\n      }\n    }\n\n    // Free PhaseOne separate copy allocated at function start\n    if (is_phaseone_compressed())\n    {\n      phase_one_free_tempbuffer();\n    }\n    // hack - clear later flags!\n\n    if (load_raw == &LibRaw::canon_600_load_raw && S.width < S.raw_width)\n    {\n      canon_600_correct();\n    }\n\n    imgdata.progress_flags =\n        LIBRAW_PROGRESS_START | LIBRAW_PROGRESS_OPEN |\n        LIBRAW_PROGRESS_RAW2_IMAGE | LIBRAW_PROGRESS_IDENTIFY |\n        LIBRAW_PROGRESS_SIZE_ADJUST | LIBRAW_PROGRESS_LOAD_RAW;\n    return 0;\n  }\n  catch (const std::bad_alloc&)\n  {\n      EXCEPTION_HANDLER(LIBRAW_EXCEPTION_ALLOC);\n  }\n  catch (const LibRaw_exceptions& err)\n  {\n    EXCEPTION_HANDLER(err);\n  }\n}\n\n\n// target function\nint LibRaw::open_datastream(LibRaw_abstract_datastream *stream)\n{\n\n  if (!stream)\n    return ENOENT;\n  if (!stream->valid())\n    return LIBRAW_IO_ERROR;\n  if ((stream->size() > (INT64)LIBRAW_MAX_DNG_RAW_FILE_SIZE) && (stream->size() > (INT64)LIBRAW_MAX_NONDNG_RAW_FILE_SIZE))\n      return LIBRAW_TOO_BIG;\n\n  recycle();\n  if (callbacks.pre_identify_cb)\n  {\n    int r = (callbacks.pre_identify_cb)(this);\n    if (r == 1)\n      goto final;\n  }\n\n  try\n  {\n\t  ID.input = stream;\n\t  SET_PROC_FLAG(LIBRAW_PROGRESS_OPEN);\n\n\t  identify();\n\n\t  // promote the old single thumbnail to the thumbs_list if not present already\n\t  if (imgdata.thumbs_list.thumbcount < LIBRAW_THUMBNAIL_MAXCOUNT)\n\t  {\n\t\t  bool already = false;\n\t\t  if(imgdata.thumbnail.tlength || libraw_internal_data.internal_data.toffset)\n\t\t\t  for(int i = 0; i < imgdata.thumbs_list.thumbcount; i++)\n\t\t\t\t  if (imgdata.thumbs_list.thumblist[i].toffset == libraw_internal_data.internal_data.toffset\n\t\t\t\t\t  && imgdata.thumbs_list.thumblist[i].tlength == imgdata.thumbnail.tlength)\n\t\t\t\t  {\n\t\t\t\t\t  already = true;\n\t\t\t\t\t  break;\n\t\t\t\t  }\n\t\t  if (!already)\n\t\t  {\n\t\t\t  int idx = imgdata.thumbs_list.thumbcount;\n\t\t\t  imgdata.thumbs_list.thumblist[idx].toffset = libraw_internal_data.internal_data.toffset;\n\t\t\t  imgdata.thumbs_list.thumblist[idx].tlength = imgdata.thumbnail.tlength;\n\t\t\t  imgdata.thumbs_list.thumblist[idx].tflip = 0xffff;\n\t\t\t  imgdata.thumbs_list.thumblist[idx].tformat = libraw_internal_data.unpacker_data.thumb_format;\n              imgdata.thumbs_list.thumblist[idx].tmisc = libraw_internal_data.unpacker_data.thumb_misc;\n\t\t\t  // promote if set\n\t\t\t  imgdata.thumbs_list.thumblist[idx].twidth = imgdata.thumbnail.twidth;\n              imgdata.thumbs_list.thumblist[idx].theight = imgdata.thumbnail.theight;\n\t\t\t  imgdata.thumbs_list.thumbcount++;\n\t\t  }\n\t  }\n\n\n\t  imgdata.lens.Lens[sizeof(imgdata.lens.Lens) - 1] = 0; // make sure lens is 0-terminated\n\n\t  if (callbacks.post_identify_cb)\n\t\t  (callbacks.post_identify_cb)(this);\n\n#define isRIC imgdata.sizes.raw_inset_crops[0]\n\n\t  if (!imgdata.idata.dng_version && makeIs(LIBRAW_CAMERAMAKER_Fujifilm)\n\t\t  && (!strcmp(imgdata.idata.normalized_model, \"S3Pro\")\n\t\t\t  || !strcmp(imgdata.idata.normalized_model, \"S5Pro\")\n\t\t\t  || !strcmp(imgdata.idata.normalized_model, \"S2Pro\")))\n\t  {\n\t\t  isRIC.cleft = isRIC.ctop = 0xffff;\n\t\t  isRIC.cwidth = isRIC.cheight = 0;\n\t  }\n      // Wipe out canon  incorrect in-camera crop\n      if (!imgdata.idata.dng_version && makeIs(LIBRAW_CAMERAMAKER_Canon)\n          && isRIC.cleft == 0 && isRIC.ctop == 0 // non symmetric!\n          && isRIC.cwidth < (imgdata.sizes.raw_width * 4 / 5))  // less than 80% of sensor width\n      {\n        isRIC.cleft = isRIC.ctop = 0xffff;\n        isRIC.cwidth = isRIC.cheight = 0;\n      }\n\n      // Wipe out non-standard WB\n      if (!imgdata.idata.dng_version &&\n          (makeIs(LIBRAW_CAMERAMAKER_Sony) && !strcmp(imgdata.idata.normalized_model, \"DSC-F828\"))\n          && !(imgdata.rawparams.options & LIBRAW_RAWOPTIONS_PROVIDE_NONSTANDARD_WB))\n      {\n          for (int i = 0; i < 4; i++) imgdata.color.cam_mul[i] = (i == 1);\n          memset(imgdata.color.WB_Coeffs, 0, sizeof(imgdata.color.WB_Coeffs));\n          memset(imgdata.color.WBCT_Coeffs, 0, sizeof(imgdata.color.WBCT_Coeffs));\n      }\n\n\t  if (load_raw == &LibRaw::nikon_load_raw)\n\t\t  nikon_read_curve();\n\n\t  if (load_raw == &LibRaw::lossless_jpeg_load_raw &&\n\t\t  MN.canon.RecordMode && makeIs(LIBRAW_CAMERAMAKER_Kodak) &&\n\t\t  /* Not normalized models here, it is intentional */\n\t\t  (!strncasecmp(imgdata.idata.model, \"EOS D2000\", 9) || // if we want something different for B&W cameras,\n\t\t\t  !strncasecmp(imgdata.idata.model, \"EOS D6000\", 9)))  // it's better to compare with CamIDs\n\t  {\n\t\t  imgdata.color.black = 0;\n\t\t  imgdata.color.maximum = 4501;\n\t\t  memset(imgdata.color.cblack, 0, sizeof(imgdata.color.cblack));\n\t\t  memset(imgdata.sizes.mask, 0, sizeof(imgdata.sizes.mask));\n\t\t  imgdata.sizes.mask[0][3] = 1; // to skip mask re-calc\n\t\t  libraw_internal_data.unpacker_data.load_flags |= 512;\n\t  }\n\n\t  if (load_raw == &LibRaw::panasonic_load_raw)\n\t  {\n\t\t  if (libraw_internal_data.unpacker_data.pana_encoding == 6 ||\n\t\t\t  libraw_internal_data.unpacker_data.pana_encoding == 7)\n\t\t  {\n\t\t\t  for (int i = 0; i < 3; i++)\n\t\t\t\t  imgdata.color.cblack[i] =\n\t\t\t\t  libraw_internal_data.internal_data.pana_black[i];\n\t\t\t  imgdata.color.cblack[3] = imgdata.color.cblack[1];\n\t\t\t  imgdata.color.cblack[4] = imgdata.color.cblack[5] = 0;\n\t\t\t  imgdata.color.black = 0;\n\t\t\t  imgdata.color.maximum =\n\t\t\t\t  MAX(imgdata.color.linear_max[0],\n\t\t\t\t\t  MAX(imgdata.color.linear_max[1], imgdata.color.linear_max[2]));\n\t\t  }\n\n\t\t  if (libraw_internal_data.unpacker_data.pana_encoding == 6)\n\t\t  {\n\t\t\t  int rowbytes11 = imgdata.sizes.raw_width / 11 * 16;\n              int rowbytes14 = imgdata.sizes.raw_width / 14 * 16;\n              INT64 ds = INT64(libraw_internal_data.unpacker_data.data_size);\n              if (!ds)\n                  ds = libraw_internal_data.internal_data.input->size() - libraw_internal_data.unpacker_data.data_offset;\n              if ((imgdata.sizes.raw_width % 11) == 0 &&\n\t\t\t\t  (INT64(imgdata.sizes.raw_height) * rowbytes11 == ds))\n\t\t\t\t  load_raw = &LibRaw::panasonicC6_load_raw;\n              else if ((imgdata.sizes.raw_width % 14) == 0 &&\n                (INT64(imgdata.sizes.raw_height) * rowbytes14 == ds))\n                  load_raw = &LibRaw::panasonicC6_load_raw;\n              else\n\t\t\t\t  imgdata.idata.raw_count = 0; // incorrect size\n\t\t  }\n\t\t  else if (libraw_internal_data.unpacker_data.pana_encoding == 7)\n\t\t  {\n\t\t\t  int pixperblock =\n\t\t\t\t  libraw_internal_data.unpacker_data.pana_bpp == 14 ? 9 : 10;\n\t\t\t  int rowbytes = imgdata.sizes.raw_width / pixperblock * 16;\n\t\t\t  if ((imgdata.sizes.raw_width % pixperblock) == 0 &&\n\t\t\t\t  (INT64(imgdata.sizes.raw_height) * rowbytes ==\n\t\t\t\t\t  INT64(libraw_internal_data.unpacker_data.data_size)))\n\t\t\t\t  load_raw = &LibRaw::panasonicC7_load_raw;\n\t\t\t  else\n\t\t\t\t  imgdata.idata.raw_count = 0; // incorrect size\n\t\t  }\n\t  }\n\n#define NIKON_14BIT_SIZE(rw, rh)                                               \\\n  (((unsigned)(ceilf((float)(rw * 7 / 4) / 16.0)) * 16) * rh)\n\n\t  // Ugly hack, replace with proper data/line size for different\n\t  // cameras/format when available\n\t  if (makeIs(LIBRAW_CAMERAMAKER_Nikon)\n\t\t  && (!strncasecmp(imgdata.idata.model, \"Z\", 1) || !strcasecmp(imgdata.idata.model,\"D6\"))\n\t\t  &&  NIKON_14BIT_SIZE(imgdata.sizes.raw_width, imgdata.sizes.raw_height) ==\n\t\t  libraw_internal_data.unpacker_data.data_size)\n\t  {\n\t\t  load_raw = &LibRaw::nikon_14bit_load_raw;\n\t  }\n#undef NIKON_14BIT_SIZE\n\n\t  // Linear max from 14-bit camera, but on 12-bit data?\n\t  if (makeIs(LIBRAW_CAMERAMAKER_Sony) &&\n\t\t  imgdata.color.maximum > 0 &&\n\t\t  imgdata.color.linear_max[0] > (long)imgdata.color.maximum &&\n\t\t  imgdata.color.linear_max[0] <= (long)imgdata.color.maximum * 4)\n\t\t  for (int c = 0; c < 4; c++)\n\t\t\t  imgdata.color.linear_max[c] /= 4;\n\n\t  if (makeIs(LIBRAW_CAMERAMAKER_Canon))\n\t  {\n\t\t  if (MN.canon.DefaultCropAbsolute.l != -1)  // tag 0x00e0 SensorInfo was parsed\n\t\t  {\n\t\t\t  if (imgdata.sizes.raw_aspect != LIBRAW_IMAGE_ASPECT_UNKNOWN)\n\t\t\t  { // tag 0x009a AspectInfo was parsed\n\t\t\t\t  isRIC.cleft += MN.canon.DefaultCropAbsolute.l;\n\t\t\t\t  isRIC.ctop  += MN.canon.DefaultCropAbsolute.t;\n\t\t\t  }\n\t\t\t  else\n\t\t\t  {\n\t\t\t\t  isRIC.cleft   = MN.canon.DefaultCropAbsolute.l;\n\t\t\t\t  isRIC.ctop    = MN.canon.DefaultCropAbsolute.t;\n\t\t\t\t  isRIC.cwidth  = MN.canon.DefaultCropAbsolute.r - MN.canon.DefaultCropAbsolute.l + 1;\n\t\t\t\t  isRIC.cheight = MN.canon.DefaultCropAbsolute.b - MN.canon.DefaultCropAbsolute.t + 1;\n\t\t\t  }\n\t\t  }\n\t\t  else\n\t\t  {\n\t\t\t  if (imgdata.sizes.raw_aspect != LIBRAW_IMAGE_ASPECT_UNKNOWN)\n\t\t\t  {\n\t\t\t  }\n\t\t\t  else\n\t\t\t  { // Canon PowerShot S2 IS\n\t\t\t  }\n\t\t  }\n#undef isRIC\n          if (imgdata.color.raw_bps < 14 && !imgdata.idata.dng_version && load_raw != &LibRaw::canon_sraw_load_raw)\n          {\n              int xmax = (1 << imgdata.color.raw_bps) - 1;\n              if (MN.canon.SpecularWhiteLevel > xmax) // Adjust 14-bit metadata to real bps\n              {\n                int div = 1 << (14 - imgdata.color.raw_bps);\n                for (int c = 0; c < 4; c++) imgdata.color.linear_max[c] /= div;\n                for (int c = 0; c < 4; c++)  MN.canon.ChannelBlackLevel[c] /= div;\n                MN.canon.AverageBlackLevel /= div;\n                MN.canon.SpecularWhiteLevel /= div;\n                MN.canon.NormalWhiteLevel /= div;\n              }\n          }\n\t  }\n\n\t  if (makeIs(LIBRAW_CAMERAMAKER_Canon) &&\n\t\t  (load_raw == &LibRaw::canon_sraw_load_raw) &&\n\t\t  imgdata.sizes.raw_width > 0)\n\t  {\n\t\t  float ratio =\n\t\t\t  float(imgdata.sizes.raw_height) / float(imgdata.sizes.raw_width);\n\t\t  if ((ratio < 0.57 || ratio > 0.75) &&\n\t\t\t  MN.canon.SensorHeight > 1 &&\n\t\t\t  MN.canon.SensorWidth > 1)\n\t\t  {\n\t\t\t  imgdata.sizes.raw_width = MN.canon.SensorWidth;\n\t\t\t  imgdata.sizes.left_margin = MN.canon.DefaultCropAbsolute.l;\n\t\t\t  imgdata.sizes.iwidth = imgdata.sizes.width =\n\t\t\t\t  MN.canon.DefaultCropAbsolute.r - MN.canon.DefaultCropAbsolute.l + 1;\n\t\t\t  imgdata.sizes.raw_height = MN.canon.SensorHeight;\n\t\t\t  imgdata.sizes.top_margin = MN.canon.DefaultCropAbsolute.t;\n\t\t\t  imgdata.sizes.iheight = imgdata.sizes.height =\n\t\t\t\t  MN.canon.DefaultCropAbsolute.b - MN.canon.DefaultCropAbsolute.t + 1;\n\t\t\t  libraw_internal_data.unpacker_data.load_flags |=\n\t\t\t\t  256; // reset width/height in canon_sraw_load_raw()\n\t\t\t  imgdata.sizes.raw_pitch = 8 * imgdata.sizes.raw_width;\n\t\t  }\n\t\t  else if (imgdata.sizes.raw_width == 4032 &&\n\t\t\t  imgdata.sizes.raw_height == 3402 &&\n\t\t\t  !strcasecmp(imgdata.idata.model, \"EOS 80D\")) // 80D hardcoded\n\t\t  {\n\t\t\t  imgdata.sizes.raw_width = 4536;\n\t\t\t  imgdata.sizes.left_margin = 28;\n\t\t\t  imgdata.sizes.iwidth = imgdata.sizes.width =\n\t\t\t\t  imgdata.sizes.raw_width - imgdata.sizes.left_margin;\n\t\t\t  imgdata.sizes.raw_height = 3024;\n\t\t\t  imgdata.sizes.top_margin = 8;\n\t\t\t  imgdata.sizes.iheight = imgdata.sizes.height =\n\t\t\t\t  imgdata.sizes.raw_height - imgdata.sizes.top_margin;\n\t\t\t  libraw_internal_data.unpacker_data.load_flags |= 256;\n\t\t\t  imgdata.sizes.raw_pitch = 8 * imgdata.sizes.raw_width;\n\t\t  }\n\t  }\n\n#ifdef USE_DNGSDK\n\t  if (imgdata.idata.dng_version\n\t\t  &&libraw_internal_data.unpacker_data.tiff_compress == 34892\n\t\t  && libraw_internal_data.unpacker_data.tiff_bps == 8\n\t\t  && libraw_internal_data.unpacker_data.tiff_samples == 3\n\t\t  && load_raw == &LibRaw::lossy_dng_load_raw)\n\t  {\n\t\t  // Data should be linearized by DNG SDK\n\t\t  C.black = 0;\n\t\t  memset(C.cblack, 0, sizeof(C.cblack));\n\t  }\n#endif\n\n\t  // XTrans Compressed?\n\t  if (!imgdata.idata.dng_version &&\n\t\t  makeIs(LIBRAW_CAMERAMAKER_Fujifilm) &&\n\t\t  (load_raw == &LibRaw::unpacked_load_raw))\n\t  {\n\t\t  if (imgdata.sizes.raw_width * (imgdata.sizes.raw_height * 2ul) !=\n\t\t\t  libraw_internal_data.unpacker_data.data_size)\n\t\t  {\n\t\t\t  if ((imgdata.sizes.raw_width * (imgdata.sizes.raw_height * 7ul)) / 4 ==\n\t\t\t\t  libraw_internal_data.unpacker_data.data_size)\n\t\t\t\t  load_raw = &LibRaw::fuji_14bit_load_raw;\n\t\t\t  else\n\t\t\t\t  parse_fuji_compressed_header();\n\t\t  }\n\t\t  else if (!strcmp(imgdata.idata.normalized_model, \"X-H2S\") \n\t\t\t  && libraw_internal_data.internal_data.input->size() \n\t\t\t  < (libraw_internal_data.unpacker_data.data_size + libraw_internal_data.unpacker_data.data_offset))\n\t\t  {\n            parse_fuji_compressed_header(); // try to use compressed header: X-H2S may record wrong data size\n\t\t  }\n\t  }\n      // set raw_inset_crops[1] via raw_aspect\n      if (imgdata.sizes.raw_aspect >= LIBRAW_IMAGE_ASPECT_MINIMAL_REAL_ASPECT_VALUE\n          && imgdata.sizes.raw_aspect <= LIBRAW_IMAGE_ASPECT_MAXIMAL_REAL_ASPECT_VALUE\n          /* crops[0] is valid*/\n          && (imgdata.sizes.raw_inset_crops[0].cleft < 0xffff)\n          && (imgdata.sizes.raw_inset_crops[0].cleft + imgdata.sizes.raw_inset_crops[0].cwidth <= imgdata.sizes.raw_width)\n          && (imgdata.sizes.raw_inset_crops[0].ctop < 0xffff)\n          && (imgdata.sizes.raw_inset_crops[0].ctop + imgdata.sizes.raw_inset_crops[0].cheight <= imgdata.sizes.raw_height)\n          && imgdata.sizes.raw_inset_crops[0].cwidth > 0 && imgdata.sizes.raw_inset_crops[0].cheight >0\n          /* crops[1] is not set*/\n          && (imgdata.sizes.raw_inset_crops[1].cleft == 0xffff)\n          && (imgdata.sizes.raw_inset_crops[1].ctop == 0xffff)\n          )\n      {\n          float c0_ratio = float(imgdata.sizes.raw_inset_crops[0].cwidth) / float(imgdata.sizes.raw_inset_crops[0].cheight);\n          float c1_ratio = float(imgdata.sizes.raw_aspect) / 1000.f;\n          if (c0_ratio / c1_ratio < 0.98 || c0_ratio / c1_ratio > 1.02) // set crops[1]\n          {\n              if (c1_ratio > c0_ratio) // requested image is wider, cut from top/bottom\n              {\n                  int newheight =  int(imgdata.sizes.raw_inset_crops[0].cwidth / c1_ratio);\n                  int dtop = (imgdata.sizes.raw_inset_crops[0].cheight - newheight) / 2;\n                  imgdata.sizes.raw_inset_crops[1].ctop = imgdata.sizes.raw_inset_crops[0].ctop + dtop;\n                  imgdata.sizes.raw_inset_crops[1].cheight = newheight;\n                  imgdata.sizes.raw_inset_crops[1].cleft = imgdata.sizes.raw_inset_crops[0].cleft;\n                  imgdata.sizes.raw_inset_crops[1].cwidth = imgdata.sizes.raw_inset_crops[0].cwidth;\n              }\n              else\n              {\n                  int newwidth = int(imgdata.sizes.raw_inset_crops[0].cheight * c1_ratio);\n                  int dleft = (imgdata.sizes.raw_inset_crops[0].cwidth - newwidth) / 2;\n                  imgdata.sizes.raw_inset_crops[1].cleft = imgdata.sizes.raw_inset_crops[0].cleft + dleft;\n                  imgdata.sizes.raw_inset_crops[1].cwidth = newwidth;\n                  imgdata.sizes.raw_inset_crops[1].ctop = imgdata.sizes.raw_inset_crops[0].ctop;\n                  imgdata.sizes.raw_inset_crops[1].cheight = imgdata.sizes.raw_inset_crops[0].cheight;\n              }\n          }\n      }\n\n      int adjust_margins = 0;\n      if (makeIs(LIBRAW_CAMERAMAKER_Fujifilm) && (imgdata.idata.filters == 9))\n      {\n          // Adjust top/left margins for X-Trans\n          int newtm = imgdata.sizes.top_margin % 6\n              ? (imgdata.sizes.top_margin / 6 + 1) * 6\n              : imgdata.sizes.top_margin;\n          int newlm = imgdata.sizes.left_margin % 6\n              ? (imgdata.sizes.left_margin / 6 + 1) * 6\n              : imgdata.sizes.left_margin;\n          if (newtm != imgdata.sizes.top_margin ||\n              newlm != imgdata.sizes.left_margin)\n          {\n              imgdata.sizes.height -= (newtm - imgdata.sizes.top_margin);\n              imgdata.sizes.top_margin = newtm;\n              imgdata.sizes.width -= (newlm - imgdata.sizes.left_margin);\n              imgdata.sizes.left_margin = newlm;\n              for (int c1 = 0; c1 < 6; c1++)\n                  for (int c2 = 0; c2 < 6; c2++)\n                      imgdata.idata.xtrans[c1][c2] = imgdata.idata.xtrans_abs[c1][c2];\n          }\n          adjust_margins = 6;\n      }\n      else if (!libraw_internal_data.internal_output_params.fuji_width\n          && imgdata.idata.filters >= 1000)\n\t  {\n          if ((imgdata.sizes.top_margin % 2) || (imgdata.sizes.left_margin % 2))\n          {\n              int crop[2] = { 0,0 };\n              unsigned filt;\n              int c;\n              if (imgdata.sizes.top_margin % 2)\n              {\n                  imgdata.sizes.top_margin += 1;\n                  imgdata.sizes.height -= 1;\n                  crop[1] = 1;\n              }\n              if (imgdata.sizes.left_margin % 2)\n              {\n                  imgdata.sizes.left_margin += 1;\n                  imgdata.sizes.width -= 1;\n                  crop[0] = 1;\n              }\n              for (filt = c = 0; c < 16; c++)\n                  filt |= FC((c >> 1) + (crop[1]), (c & 1) + (crop[0])) << c * 2;\n              imgdata.idata.filters = filt;\n          }\n          adjust_margins = 2;\n\t  }\n\n      if(adjust_margins) // adjust crop_inset margins\n          for (int i = 0; i < 2; i++)\n          {\n              if (imgdata.sizes.raw_inset_crops[i].cleft && imgdata.sizes.raw_inset_crops[i].cleft < 0xffff\n                  && imgdata.sizes.raw_inset_crops[i].cwidth && imgdata.sizes.raw_inset_crops[i].cwidth < 0xffff\n                  && (imgdata.sizes.raw_inset_crops[i].cleft%adjust_margins)\n                  && (imgdata.sizes.raw_inset_crops[i].cwidth > adjust_margins))\n              {\n                  int newleft = ((imgdata.sizes.raw_inset_crops[i].cleft / adjust_margins) + 1) * adjust_margins;\n                  int diff = newleft - imgdata.sizes.raw_inset_crops[i].cleft;\n                  if (diff > 0)\n                  {\n                      imgdata.sizes.raw_inset_crops[i].cleft += diff;\n                      imgdata.sizes.raw_inset_crops[i].cwidth -= diff;\n                  }\n              }\n              if (imgdata.sizes.raw_inset_crops[i].ctop && imgdata.sizes.raw_inset_crops[i].ctop < 0xffff\n                  && imgdata.sizes.raw_inset_crops[i].cheight && imgdata.sizes.raw_inset_crops[i].cheight < 0xffff\n                  && (imgdata.sizes.raw_inset_crops[i].ctop%adjust_margins)\n                  && (imgdata.sizes.raw_inset_crops[i].cheight > adjust_margins))\n              {\n                  int newtop = ((imgdata.sizes.raw_inset_crops[i].ctop / adjust_margins) + 1) * adjust_margins;\n                  int diff = newtop - imgdata.sizes.raw_inset_crops[i].ctop;\n                  if (diff > 0)\n                  {\n                      imgdata.sizes.raw_inset_crops[i].ctop += diff;\n                      imgdata.sizes.raw_inset_crops[i].cheight -= diff;\n                  }\n              }\n          }\n\n\n#ifdef USE_DNGSDK\n\t  if (\n\t\t  imgdata.rawparams.use_dngsdk &&\n\t\t  !(imgdata.rawparams.options & (LIBRAW_RAWOPTIONS_DNG_STAGE2 | LIBRAW_RAWOPTIONS_DNG_STAGE3 | LIBRAW_RAWOPTIONS_DNG_DISABLEWBADJUST)))\n#endif\n\t  {\n\t\t  // Fix DNG white balance if needed: observed only for Kalpanika X3F tools produced DNGs\n\t\t  if (imgdata.idata.dng_version && (imgdata.idata.filters == 0) &&\n\t\t\t  imgdata.idata.colors > 1 && imgdata.idata.colors < 5)\n\t\t  {\n\t\t\t  float delta[4] = { 0.f, 0.f, 0.f, 0.f };\n\t\t\t  int black[4];\n\t\t\t  for (int c = 0; c < 4; c++)\n\t\t\t\t  black[c] = imgdata.color.dng_levels.dng_black +\n\t\t\t\t  imgdata.color.dng_levels.dng_cblack[c];\n\t\t\t  for (int c = 0; c < imgdata.idata.colors; c++)\n\t\t\t\t  delta[c] = imgdata.color.dng_levels.dng_whitelevel[c] - black[c];\n\t\t\t  float mindelta = delta[0], maxdelta = delta[0];\n\t\t\t  for (int c = 1; c < imgdata.idata.colors; c++)\n\t\t\t  {\n\t\t\t\t  if (mindelta > delta[c])\n\t\t\t\t\t  mindelta = delta[c];\n\t\t\t\t  if (maxdelta < delta[c])\n\t\t\t\t\t  maxdelta = delta[c];\n\t\t\t  }\n\t\t\t  if (mindelta > 1 && maxdelta < (mindelta * 20)) // safety\n\t\t\t  {\n\t\t\t\t  for (int c = 0; c < imgdata.idata.colors; c++)\n\t\t\t\t  {\n\t\t\t\t\t  imgdata.color.cam_mul[c] /= (delta[c] / maxdelta);\n\t\t\t\t\t  imgdata.color.pre_mul[c] /= (delta[c] / maxdelta);\n\t\t\t\t  }\n\t\t\t\t  imgdata.color.maximum = imgdata.color.cblack[0] + maxdelta;\n\t\t\t  }\n\t\t  }\n\t  }\n\n    if (imgdata.idata.dng_version &&\n\t\tmakeIs(LIBRAW_CAMERAMAKER_Panasonic)\n          && !strcasecmp(imgdata.idata.normalized_model, \"DMC-LX100\"))\n      imgdata.sizes.width = 4288;\n\n    if (imgdata.idata.dng_version\n    \t&& makeIs(LIBRAW_CAMERAMAKER_Leica)\n        && !strcasecmp(imgdata.idata.normalized_model, \"SL2\"))\n        \timgdata.sizes.height -= 16;\n\n\tif (makeIs(LIBRAW_CAMERAMAKER_Sony) &&\n        imgdata.idata.dng_version)\n    {\n      if (S.raw_width == 3984)\n        S.width = 3925;\n      else if (S.raw_width == 4288)\n        S.width = S.raw_width - 32;\n      else if (S.raw_width == 4928 && S.height < 3280)\n        S.width = S.raw_width - 8;\n      else if (S.raw_width == 5504)\n        S.width = S.raw_width - (S.height > 3664 ? 8 : 32);\n    }\n\n\tif (makeIs(LIBRAW_CAMERAMAKER_Sony) &&\n        !imgdata.idata.dng_version)\n    {\n        if(load_raw ==&LibRaw::sony_arq_load_raw)\n        {\n            if(S.raw_width > 12000) // A7RM4 16x, both APS-C and APS\n                S.width = S.raw_width - 64;\n            else // A7RM3/M4 4x merge\n                S.width = S.raw_width - 32;\n        }\n\n      if (((!strncasecmp(imgdata.idata.model, \"ILCE-7RM\", 8) ||\n            !strcasecmp(imgdata.idata.model, \"ILCA-99M2\")) &&\n           (S.raw_width == 5216 || S.raw_width == 6304)) // A7RM2/M3/A99M2 in APS mode; A7RM4 in APS-C\n          ||\n          (!strcasecmp(imgdata.idata.model, \"ILCE-7R\") && S.raw_width >= 4580 &&\n           S.raw_width < 5020) // A7R in crop mode, no samples, so size est.\n          || (!strcasecmp(imgdata.idata.model, \"ILCE-7\") &&\n              S.raw_width == 3968) // A7 in crop mode\n          ||\n          ((!strncasecmp(imgdata.idata.model, \"ILCE-7M\", 7) ||\n            !strcasecmp(imgdata.idata.model, \"ILCE-9\") ||\n#if 0\n            !strcasecmp(imgdata.idata.model,\n                        \"SLT-A99V\")) // Does SLT-A99 also have APS-C mode??\n#endif\n           (mnCamID == SonyID_SLT_A99)) // 2 reasons: some cameras are SLT-A99, no 'V'; some are Hasselblad HV\n           && S.raw_width > 3750 &&\n           S.raw_width < 4120) // A7M2, A7M3, AA9, most likely APS-C raw_width\n                               // is 3968 (same w/ A7), but no samples, so guess\n          || (!strncasecmp(imgdata.idata.model, \"ILCE-7S\", 7) &&\n              S.raw_width == 2816) // A7S2=> exact, hope it works for A7S-I too\n      )\n        S.width = S.raw_width - 32;\n    }\n\n\n    // FIXME: it is possible that DNG contains 4x main frames + some previews; in this case imgdata.idata.raw_count will be greater than 4\n\tif (makeIs(LIBRAW_CAMERAMAKER_Pentax) &&\n        /*!strcasecmp(imgdata.idata.model,\"K-3 II\")  &&*/\n            imgdata.idata.raw_count == 4 &&\n        (imgdata.rawparams.options & LIBRAW_RAWOPTIONS_PENTAX_PS_ALLFRAMES))\n    {\n      imgdata.idata.raw_count = 1;\n      imgdata.idata.filters = 0;\n      imgdata.idata.colors = 4;\n      imgdata.sizes.top_margin+=2;\n      imgdata.sizes.left_margin+=2;\n      imgdata.sizes.width-=4;\n      imgdata.sizes.height-=4;\n      IO.mix_green = 1;\n      pentax_component_load_raw = load_raw;\n      load_raw = &LibRaw::pentax_4shot_load_raw;\n    }\n\n\tif (!imgdata.idata.dng_version && makeIs(LIBRAW_CAMERAMAKER_Leaf) &&\n        !strcmp(imgdata.idata.model, \"Credo 50\"))\n    {\n      imgdata.color.pre_mul[0] = 1.f / 0.3984f;\n      imgdata.color.pre_mul[2] = 1.f / 0.7666f;\n      imgdata.color.pre_mul[1] = imgdata.color.pre_mul[3] = 1.0;\n    }\n\n\tif (!imgdata.idata.dng_version && makeIs(LIBRAW_CAMERAMAKER_Fujifilm) &&\n        (!strncmp(imgdata.idata.model, \"S20Pro\", 6) ||\n         !strncmp(imgdata.idata.model, \"F700\", 4)))\n    {\n      imgdata.sizes.raw_width /= 2;\n      load_raw = &LibRaw::unpacked_load_raw_fuji_f700s20;\n    }\n\n    if (load_raw == &LibRaw::packed_load_raw &&\n\t\tmakeIs(LIBRAW_CAMERAMAKER_Nikon) &&\n        !libraw_internal_data.unpacker_data.load_flags &&\n        (!strncasecmp(imgdata.idata.model, \"D810\", 4) ||\n         !strcasecmp(imgdata.idata.model, \"D4S\")) &&\n        libraw_internal_data.unpacker_data.data_size * 2u ==\n            imgdata.sizes.raw_height * imgdata.sizes.raw_width * 3u)\n    {\n      libraw_internal_data.unpacker_data.load_flags = 80;\n    }\n    // Adjust BL for Sony A900/A850\n    if (load_raw == &LibRaw::packed_load_raw &&\n\t\tmakeIs(LIBRAW_CAMERAMAKER_Sony)) // 12 bit sony, but metadata may be for 14-bit range\n    {\n      if (C.maximum > 4095)\n        C.maximum = 4095;\n      if (C.black > 256 || C.cblack[0] > 256)\n      {\n        C.black /= 4;\n        for (int c = 0; c < 4; c++)\n          C.cblack[c] /= 4;\n        for (unsigned c = 0; c < C.cblack[4] * C.cblack[5]; c++)\n          C.cblack[6 + c] /= 4;\n      }\n    }\n\n\tif (load_raw == &LibRaw::nikon_yuv_load_raw) // Is it Nikon sRAW?\n    {\n      load_raw = &LibRaw::nikon_load_sraw;\n      C.black = 0;\n      memset(C.cblack, 0, sizeof(C.cblack));\n      imgdata.idata.filters = 0;\n      libraw_internal_data.unpacker_data.tiff_samples = 3;\n      imgdata.idata.colors = 3;\n      double beta_1 = -5.79342238397656E-02;\n      double beta_2 = 3.28163551282665;\n      double beta_3 = -8.43136004842678;\n      double beta_4 = 1.03533181861023E+01;\n      for (int i = 0; i <= 3072; i++)\n      {\n        double x = (double)i / 3072.;\n        double y = (1. - exp(-beta_1 * x - beta_2 * x * x - beta_3 * x * x * x -\n                             beta_4 * x * x * x * x));\n        if (y < 0.)\n          y = 0.;\n        imgdata.color.curve[i] = (y * 16383.);\n      }\n      for (int i = 0; i < 3; i++)\n        for (int j = 0; j < 4; j++)\n          imgdata.color.rgb_cam[i][j] = float(i == j);\n    }\n    // Adjust BL for Nikon 12bit\n    if ((load_raw == &LibRaw::nikon_load_raw ||\n         load_raw == &LibRaw::packed_load_raw ||\n         load_raw == &LibRaw::nikon_load_padded_packed_raw) &&\n\t\t makeIs(LIBRAW_CAMERAMAKER_Nikon) &&\n        strncmp(imgdata.idata.model, \"COOLPIX\", 7) &&\n        libraw_internal_data.unpacker_data.tiff_bps == 12)\n    {\n      C.maximum = 4095;\n      C.black /= 4;\n      for (int c = 0; c < 4; c++)\n        C.cblack[c] /= 4;\n      for (unsigned c = 0; c < C.cblack[4] * C.cblack[5]; c++)\n        C.cblack[6 + c] /= 4;\n    }\n\n    // Adjust wb_already_applied\n    if (load_raw == &LibRaw::nikon_load_sraw)\n      imgdata.color.as_shot_wb_applied =\n          LIBRAW_ASWB_APPLIED | LIBRAW_ASWB_NIKON_SRAW;\n    else if (makeIs(LIBRAW_CAMERAMAKER_Canon) &&\n             MN.canon.multishot[0] >= 8 &&\n             MN.canon.multishot[1] > 0)\n      imgdata.color.as_shot_wb_applied =\n          LIBRAW_ASWB_APPLIED | LIBRAW_ASWB_CANON;\n    else if (makeIs(LIBRAW_CAMERAMAKER_Nikon) &&\n             MN.nikon.ExposureMode == 1)\n      imgdata.color.as_shot_wb_applied =\n          LIBRAW_ASWB_APPLIED | LIBRAW_ASWB_NIKON;\n\telse if (makeIs(LIBRAW_CAMERAMAKER_Pentax) &&\n             ((MN.pentax.MultiExposure & 0x01) == 1))\n      imgdata.color.as_shot_wb_applied =\n          LIBRAW_ASWB_APPLIED | LIBRAW_ASWB_PENTAX;\n    else\n      imgdata.color.as_shot_wb_applied = 0;\n\n    // Adjust Highlight Linearity limit\n    if (C.linear_max[0] < 0)\n    {\n      if (imgdata.idata.dng_version)\n      {\n        for (int c = 0; c < 4; c++)\n          C.linear_max[c] = -1 * C.linear_max[c] + imgdata.color.cblack[c + 6];\n      }\n      else\n      {\n        for (int c = 0; c < 4; c++)\n          C.linear_max[c] = -1 * C.linear_max[c] + imgdata.color.cblack[c];\n      }\n    }\n\n\tif (makeIs(LIBRAW_CAMERAMAKER_Nikon) &&\n\t\t(!C.linear_max[0]) && (C.maximum > 1024) && (load_raw != &LibRaw::nikon_load_sraw))\n    {\n      C.linear_max[0] = C.linear_max[1] = C.linear_max[2] = C.linear_max[3] =\n          (long)((float)(C.maximum) / 1.07f);\n    }\n\n    // Correct WB for Samsung GX20\n\tif (\n#if 0\n        /* GX20 should be corrected, but K20 is not */\n        makeIs(LIBRAW_CAMERAMAKER_Pentax) &&\n\t\t!strcasecmp(imgdata.idata.normalized_model, \"K20D\")\n#endif\n#if 0\n\t\t!strcasecmp(imgdata.idata.make, \"Samsung\") &&\n        !strcasecmp(imgdata.idata.model, \"GX20\")\n#endif\n    makeIs(LIBRAW_CAMERAMAKER_Pentax) &&\n    (mnCamID == PentaxID_GX20) // Samsung rebranding\n\t\t)\n    {\n      for (int cnt = LIBRAW_WBI_Unknown; cnt <= LIBRAW_WBI_StudioTungsten; cnt++) {\n        if (C.WB_Coeffs[cnt][1]) {\n          C.WB_Coeffs[cnt][0] = (int)((float)(C.WB_Coeffs[cnt][0]) * 1.0503f);\n          C.WB_Coeffs[cnt][2] = (int)((float)(C.WB_Coeffs[cnt][2]) * 2.2867f);\n        }\n      }\n      for (int cnt = 0; cnt < 64; cnt++) {\n        if (C.WBCT_Coeffs[cnt][0] > 0.0f) {\n          C.WBCT_Coeffs[cnt][1] *= 1.0503f;\n          C.WBCT_Coeffs[cnt][3] *= 2.2867f;\n        }\n      }\n      for(int cnt = 0; cnt < 4; cnt++)\n        imgdata.color.pre_mul[cnt] =\n          C.WB_Coeffs[LIBRAW_WBI_Daylight][cnt];\n    }\n\n    // Adjust BL for Panasonic\n    if (load_raw == &LibRaw::panasonic_load_raw &&\n\t\tmakeIs(LIBRAW_CAMERAMAKER_Panasonic) &&\n        ID.pana_black[0] && ID.pana_black[1] && ID.pana_black[2])\n    {\n      if (libraw_internal_data.unpacker_data.pana_encoding == 5)\n        libraw_internal_data.internal_output_params.zero_is_bad = 0;\n      C.black = 0;\n      int add = libraw_internal_data.unpacker_data.pana_encoding == 4 ? 15 : 0;\n      C.cblack[0] = ID.pana_black[0] + add;\n      C.cblack[1] = C.cblack[3] = ID.pana_black[1] + add;\n      C.cblack[2] = ID.pana_black[2] + add;\n      unsigned i = C.cblack[3];\n      for (int c = 0; c < 3; c++)\n        if (i > C.cblack[c])\n          i = C.cblack[c];\n      for (int c = 0; c < 4; c++)\n        C.cblack[c] -= i;\n      C.black = i;\n    }\n\n    // Adjust sizes for X3F processing\n#ifdef USE_X3FTOOLS\n\tif (load_raw == &LibRaw::x3f_load_raw)\n    {\n      for (int i = 0; i < foveon_count; i++)\n        if (!strcasecmp(imgdata.idata.make, foveon_data[i].make) &&\n            !strcasecmp(imgdata.idata.model, foveon_data[i].model) &&\n            imgdata.sizes.raw_width == foveon_data[i].raw_width &&\n            imgdata.sizes.raw_height == foveon_data[i].raw_height)\n        {\n          imgdata.sizes.top_margin = foveon_data[i].top_margin;\n          imgdata.sizes.left_margin = foveon_data[i].left_margin;\n          imgdata.sizes.width = imgdata.sizes.iwidth = foveon_data[i].width;\n          imgdata.sizes.height = imgdata.sizes.iheight = foveon_data[i].height;\n          C.maximum = foveon_data[i].white;\n          break;\n        }\n    }\n#endif\n#if 0\n    size_t bytes = ID.input->size()-libraw_internal_data.unpacker_data.data_offset;\n    float bpp = float(bytes)/float(S.raw_width)/float(S.raw_height);\n    float bpp2 = float(bytes)/float(S.width)/float(S.height);\n    if(!strcasecmp(imgdata.idata.make,\"Hasselblad\") && bpp == 6.0f)\n      {\n        load_raw = &LibRaw::hasselblad_full_load_raw;\n        S.width = S.raw_width;\n        S.height = S.raw_height;\n        P1.filters = 0;\n        P1.colors=3;\n        P1.raw_count=1;\n        C.maximum=0xffff;\n      }\n#endif\n    if (C.profile_length)\n    {\n      if (C.profile)\n        free(C.profile);\n      C.profile = malloc(C.profile_length);\n      ID.input->seek(ID.profile_offset, SEEK_SET);\n      ID.input->read(C.profile, C.profile_length, 1);\n    }\n\n    SET_PROC_FLAG(LIBRAW_PROGRESS_IDENTIFY);\n  }\n  catch (const std::bad_alloc&)\n  {\n      EXCEPTION_HANDLER(LIBRAW_EXCEPTION_ALLOC);\n  }\n  catch (const LibRaw_exceptions& err)\n  {\n    EXCEPTION_HANDLER(err);\n  }\n  catch (const std::exception& )\n  {\n    EXCEPTION_HANDLER(LIBRAW_EXCEPTION_IO_CORRUPT);\n  }\n\nfinal:;\n\n  if (P1.raw_count < 1)\n    return LIBRAW_FILE_UNSUPPORTED;\n\n  write_fun = &LibRaw::write_ppm_tiff;\n\n  if (load_raw == &LibRaw::kodak_ycbcr_load_raw)\n  {\n    S.height += S.height & 1;\n    S.width += S.width & 1;\n  }\n\n  IO.shrink =\n      P1.filters &&\n      (O.half_size || ((O.threshold || O.aber[0] != 1 || O.aber[2] != 1)));\n  if (IO.shrink && P1.filters >= 1000)\n  {\n    S.width &= 65534;\n    S.height &= 65534;\n  }\n\n  S.iheight = (S.height + IO.shrink) >> IO.shrink;\n  S.iwidth = (S.width + IO.shrink) >> IO.shrink;\n\n  // Save color,sizes and internal data into raw_image fields\n  memmove(&imgdata.rawdata.color, &imgdata.color, sizeof(imgdata.color));\n  memmove(&imgdata.rawdata.sizes, &imgdata.sizes, sizeof(imgdata.sizes));\n  memmove(&imgdata.rawdata.iparams, &imgdata.idata, sizeof(imgdata.idata));\n  memmove(&imgdata.rawdata.ioparams,\n          &libraw_internal_data.internal_output_params,\n          sizeof(libraw_internal_data.internal_output_params));\n\n  SET_PROC_FLAG(LIBRAW_PROGRESS_SIZE_ADJUST);\n\n  return LIBRAW_SUCCESS;\n}\n",
    "target": 1,
    "idx": 1052901,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nint\nread_config(const char *filename,\n            struct config_line *line_handler, int when)\n{\n    static int      depth = 0;\n    static int      files = 0;\n\n    const char * const prev_filename = curfilename;\n    const unsigned int prev_linecount = linecount;\n\n    FILE           *ifile;\n    char           *line = NULL;  /* current line buffer */\n    size_t          linesize = 0; /* allocated size of line */\n\n    netsnmp_assert(line_handler);\n    netsnmp_assert(line_handler->config_token);\n\n    /* reset file counter when recursion depth is 0 */\n    if (depth == 0)\n        files = 0;\n\n    if ((ifile = fopen(filename, \"r\")) == NULL) {\n#ifdef ENOENT\n        if (errno == ENOENT) {\n            DEBUGMSGTL((\"read_config\", \"%s: %s\\n\", filename,\n                        strerror(errno)));\n        } else\n#endif                          /* ENOENT */\n#ifdef EACCES\n        if (errno == EACCES) {\n            DEBUGMSGTL((\"read_config\", \"%s: %s\\n\", filename,\n                        strerror(errno)));\n        } else\n#endif                          /* EACCES */\n        {\n            snmp_log_perror(filename);\n        }\n        return SNMPERR_GENERR;\n    }\n\n#define CONFIG_MAX_FILES 4096\n    if (files > CONFIG_MAX_FILES) {\n        netsnmp_config_error(\"maximum conf file count (%d) exceeded\\n\",\n                             CONFIG_MAX_FILES);\n\tfclose(ifile);\n        return SNMPERR_GENERR;\n    }\n#define CONFIG_MAX_RECURSE_DEPTH 16\n    if (depth > CONFIG_MAX_RECURSE_DEPTH) {\n        netsnmp_config_error(\"nested include depth > %d\\n\",\n                             CONFIG_MAX_RECURSE_DEPTH);\n\tfclose(ifile);\n        return SNMPERR_GENERR;\n    }\n\n    linecount = 0;\n    curfilename = filename;\n\n    ++files;\n    ++depth;\n\n    DEBUGMSGTL((\"read_config:file\", \"Reading configuration %s (%d)\\n\",\n                filename, when));\n\n    while (ifile) {\n        size_t              linelen = 0; /* strlen of the current line */\n        char               *cptr;\n        struct config_line *lptr = line_handler;\n\n        for (;;) {\n            if (linesize <= linelen + 1) {\n                char *tmp = realloc(line, linesize + 256);\n                if (tmp) {\n                    line = tmp;\n                    linesize += 256;\n                } else {\n                    netsnmp_config_error(\"Failed to allocate memory\\n\");\n                    free(line);\n                    fclose(ifile);\n                    return SNMPERR_GENERR;\n                }\n            }\n            if (fgets(line + linelen, linesize - linelen, ifile) == NULL) {\n                line[linelen] = '\\0';\n                fclose (ifile);\n                ifile = NULL;\n                break;\n            }\n\n            linelen += strlen(line + linelen);\n\n            if (linelen && line[linelen - 1] == '\\n') {\n              line[linelen - 1] = '\\0';\n              break;\n            }\n        }\n\n        ++linecount;\n        DEBUGMSGTL((\"9:read_config:line\", \"%s:%d examining: %s\\n\",\n                    filename, linecount, line));\n        /*\n         * check blank line or # comment \n         */\n        if ((cptr = skip_white(line))) {\n            char token[STRINGMAX];\n\n            cptr = copy_nword(cptr, token, sizeof(token));\n            if (token[0] == '[') {\n                if (token[strlen(token) - 1] != ']') {\n\t\t    netsnmp_config_error(\"no matching ']' for type %s.\",\n\t\t\t\t\t &token[1]);\n                    continue;\n                }\n                token[strlen(token) - 1] = '\\0';\n                lptr = read_config_get_handlers(&token[1]);\n                if (lptr == NULL) {\n\t\t    netsnmp_config_error(\"No handlers registered for type %s.\",\n\t\t\t\t\t &token[1]);\n                    continue;\n                }\n                DEBUGMSGTL((\"read_config:context\",\n                            \"Switching to new context: %s%s\\n\",\n                            ((cptr) ? \"(this line only) \" : \"\"),\n                            &token[1]));\n                if (cptr == NULL) {\n                    /*\n                     * change context permanently \n                     */\n                    line_handler = lptr;\n                    continue;\n                } else {\n                    /*\n                     * the rest of this line only applies. \n                     */\n                    cptr = copy_nword(cptr, token, sizeof(token));\n                }\n            } else if ((token[0] == 'i') && (strncasecmp(token,\"include\", 7 )==0)) {\n                if ( strcasecmp( token, \"include\" )==0) {\n                    if (when != PREMIB_CONFIG && \n\t                !netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, \n\t\t\t\t                NETSNMP_DS_LIB_NO_TOKEN_WARNINGS)) {\n\t                netsnmp_config_warn(\"Ambiguous token '%s' - use 'includeSearch' (or 'includeFile') instead.\", token);\n                    }\n                    continue;\n                } else if ( strcasecmp( token, \"includedir\" )==0) {\n                    DIR *d;\n                    struct dirent *entry;\n                    char  fname[SNMP_MAXPATH];\n                    int   len;\n\n                    if (cptr == NULL) {\n                        if (when != PREMIB_CONFIG)\n\t\t            netsnmp_config_error(\"Blank line following %s token.\", token);\n                        continue;\n                    }\n                    if ((d=opendir(cptr)) == NULL ) {\n                        if (when != PREMIB_CONFIG)\n                            netsnmp_config_error(\"Can't open include dir '%s'.\", cptr);\n                        continue;\n                    }\n                    while ((entry = readdir( d )) != NULL ) {\n                        if ( entry->d_name[0] != '.') {\n                            len = strlen(entry->d_name);\n                            if ((len > 5) && (strcmp(&(entry->d_name[len-5]),\".conf\") == 0)) {\n                                snprintf(fname, SNMP_MAXPATH, \"%s/%s\",\n                                         cptr, entry->d_name);\n                                (void)read_config(fname, line_handler, when);\n                            }\n                        }\n                    }\n                    closedir(d);\n                    continue;\n                } else if ( strcasecmp( token, \"includefile\" )==0) {\n                    char  fname[SNMP_MAXPATH], *cp;\n\n                    if (cptr == NULL) {\n                        if (when != PREMIB_CONFIG)\n\t\t            netsnmp_config_error(\"Blank line following %s token.\", token);\n                        continue;\n                    }\n                    if (strlen(cptr) + 1 >= SNMP_MAXPATH) {\n                        netsnmp_config_error(\"File name '%s' is too long\",\n                                             cptr);\n                        continue;\n                    }\n                    if ( cptr[0] == '/' ) {\n                        strlcpy(fname, cptr, SNMP_MAXPATH);\n                    } else {\n                        strlcpy(fname, filename, SNMP_MAXPATH);\n                        cp = strrchr(fname, '/');\n                        if (!cp)\n                            fname[0] = '\\0';\n                        else\n                            *(++cp) = '\\0';\n                        strlcat(fname, cptr, SNMP_MAXPATH);\n                    }\n                    if (read_config(fname, line_handler, when) !=\n                        SNMPERR_SUCCESS && when != PREMIB_CONFIG)\n                        netsnmp_config_error(\"Included file '%s' not found.\",\n                                             fname);\n                    continue;\n                } else if ( strcasecmp( token, \"includesearch\" )==0) {\n                    struct config_files ctmp;\n                    int len, ret;\n\n                    if (cptr == NULL) {\n                        if (when != PREMIB_CONFIG)\n\t\t            netsnmp_config_error(\"Blank line following %s token.\", token);\n                        continue;\n                    }\n                    len = strlen(cptr);\n                    ctmp.fileHeader = cptr;\n                    ctmp.start = line_handler;\n                    ctmp.next = NULL;\n                    if ((len > 5) && (strcmp(&cptr[len-5],\".conf\") == 0))\n                       cptr[len-5] = 0; /* chop off .conf */\n                    ret = read_config_files_of_type(when,&ctmp);\n                    if ((len > 5) && (cptr[len-5] == 0))\n                       cptr[len-5] = '.'; /* restore .conf */\n                    if (( ret != SNMPERR_SUCCESS ) && (when != PREMIB_CONFIG))\n\t\t        netsnmp_config_error(\"Included config '%s' not found.\", cptr);\n                    continue;\n                } else {\n                    lptr = line_handler;\n                }\n            } else {\n                lptr = line_handler;\n            }\n            if (cptr == NULL) {\n\t\tnetsnmp_config_error(\"Blank line following %s token.\", token);\n            } else {\n                DEBUGMSGTL((\"read_config:line\", \"%s:%d examining: %s\\n\",\n                            filename, linecount, line));\n                run_config_handler(lptr, token, cptr, when);\n            }\n        }\n    }\n    free(line);\n    linecount = prev_linecount;\n    curfilename = prev_filename;\n    --depth;\n    return SNMPERR_SUCCESS;\n\n}                               /* end read_config() */\n\n\n// target function\nint\nread_config(const char *filename,\n            struct config_line *line_handler, int when)\n{\n    static int      depth = 0;\n    static int      files = 0;\n\n    const char * const prev_filename = curfilename;\n    const unsigned int prev_linecount = linecount;\n\n    FILE           *ifile;\n    char           *line = NULL;  /* current line buffer */\n    size_t          linesize = 0; /* allocated size of line */\n\n    netsnmp_assert(line_handler);\n    netsnmp_assert(line_handler->config_token);\n\n    /* reset file counter when recursion depth is 0 */\n    if (depth == 0)\n        files = 0;\n\n    if ((ifile = fopen(filename, \"r\")) == NULL) {\n#ifdef ENOENT\n        if (errno == ENOENT) {\n            DEBUGMSGTL((\"read_config\", \"%s: %s\\n\", filename,\n                        strerror(errno)));\n        } else\n#endif                          /* ENOENT */\n#ifdef EACCES\n        if (errno == EACCES) {\n            DEBUGMSGTL((\"read_config\", \"%s: %s\\n\", filename,\n                        strerror(errno)));\n        } else\n#endif                          /* EACCES */\n        {\n            snmp_log_perror(filename);\n        }\n        return SNMPERR_GENERR;\n    }\n\n#define CONFIG_MAX_FILES 4096\n    if (files > CONFIG_MAX_FILES) {\n        netsnmp_config_error(\"maximum conf file count (%d) exceeded\\n\",\n                             CONFIG_MAX_FILES);\n\tfclose(ifile);\n        return SNMPERR_GENERR;\n    }\n#define CONFIG_MAX_RECURSE_DEPTH 16\n    if (depth > CONFIG_MAX_RECURSE_DEPTH) {\n        netsnmp_config_error(\"nested include depth > %d\\n\",\n                             CONFIG_MAX_RECURSE_DEPTH);\n\tfclose(ifile);\n        return SNMPERR_GENERR;\n    }\n\n    linecount = 0;\n    curfilename = filename;\n\n    ++files;\n    ++depth;\n\n    DEBUGMSGTL((\"read_config:file\", \"Reading configuration %s (%d)\\n\",\n                filename, when));\n\n    while (ifile) {\n        size_t              linelen = 0; /* strlen of the current line */\n        char               *cptr;\n        struct config_line *lptr = line_handler;\n\n        for (;;) {\n            if (linesize <= linelen + 1) {\n                char *tmp = realloc(line, linesize + 256);\n                if (tmp) {\n                    line = tmp;\n                    linesize += 256;\n                } else {\n                    netsnmp_config_error(\"Failed to allocate memory\\n\");\n                    free(line);\n                    fclose(ifile);\n                    return SNMPERR_GENERR;\n                }\n            }\n            if (fgets(line + linelen, linesize - linelen, ifile) == NULL) {\n                line[linelen] = '\\0';\n                fclose (ifile);\n                ifile = NULL;\n                break;\n            }\n\n            linelen += strlen(line + linelen);\n\n            if (linelen && line[linelen - 1] == '\\n') {\n              line[linelen - 1] = '\\0';\n              break;\n            }\n        }\n\n        ++linecount;\n        DEBUGMSGTL((\"9:read_config:line\", \"%s:%d examining: %s\\n\",\n                    filename, linecount, line));\n        /*\n         * check blank line or # comment \n         */\n        if ((cptr = skip_white(line))) {\n            char token[STRINGMAX];\n\n            cptr = copy_nword(cptr, token, sizeof(token));\n            if (token[0] == '[') {\n                if (token[strlen(token) - 1] != ']') {\n\t\t    netsnmp_config_error(\"no matching ']' for type %s.\",\n\t\t\t\t\t &token[1]);\n                    continue;\n                }\n                token[strlen(token) - 1] = '\\0';\n                lptr = read_config_get_handlers(&token[1]);\n                if (lptr == NULL) {\n\t\t    netsnmp_config_error(\"No handlers registered for type %s.\",\n\t\t\t\t\t &token[1]);\n                    continue;\n                }\n                DEBUGMSGTL((\"read_config:context\",\n                            \"Switching to new context: %s%s\\n\",\n                            ((cptr) ? \"(this line only) \" : \"\"),\n                            &token[1]));\n                if (cptr == NULL) {\n                    /*\n                     * change context permanently \n                     */\n                    line_handler = lptr;\n                    continue;\n                } else {\n                    /*\n                     * the rest of this line only applies. \n                     */\n                    cptr = copy_nword(cptr, token, sizeof(token));\n                }\n            } else if ((token[0] == 'i') && (strncasecmp(token,\"include\", 7 )==0)) {\n                if ( strcasecmp( token, \"include\" )==0) {\n                    if (when != PREMIB_CONFIG && \n\t                !netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, \n\t\t\t\t                NETSNMP_DS_LIB_NO_TOKEN_WARNINGS)) {\n\t                netsnmp_config_warn(\"Ambiguous token '%s' - use 'includeSearch' (or 'includeFile') instead.\", token);\n                    }\n                    continue;\n                } else if ( strcasecmp( token, \"includedir\" )==0) {\n                    DIR *d;\n                    struct dirent *entry;\n                    char  fname[SNMP_MAXPATH];\n                    int   len;\n\n                    if (cptr == NULL) {\n                        if (when != PREMIB_CONFIG)\n\t\t            netsnmp_config_error(\"Blank line following %s token.\", token);\n                        continue;\n                    }\n                    if ((d=opendir(cptr)) == NULL ) {\n                        if (when != PREMIB_CONFIG)\n                            netsnmp_config_error(\"Can't open include dir '%s'.\", cptr);\n                        continue;\n                    }\n                    while ((entry = readdir( d )) != NULL ) {\n                        if ( entry->d_name[0] != '.') {\n                            len = strlen(entry->d_name);\n                            if ((len > 5) && (strcmp(&(entry->d_name[len-5]),\".conf\") == 0)) {\n                                snprintf(fname, SNMP_MAXPATH, \"%s/%s\",\n                                         cptr, entry->d_name);\n                                (void)read_config(fname, line_handler, when);\n                            }\n                        }\n                    }\n                    closedir(d);\n                    continue;\n                } else if ( strcasecmp( token, \"includefile\" )==0) {\n                    char  fname[SNMP_MAXPATH], *cp;\n\n                    if (cptr == NULL) {\n                        if (when != PREMIB_CONFIG)\n\t\t            netsnmp_config_error(\"Blank line following %s token.\", token);\n                        continue;\n                    }\n                    if ( cptr[0] == '/' ) {\n                        strlcpy(fname, cptr, SNMP_MAXPATH);\n                    } else {\n                        strlcpy(fname, filename, SNMP_MAXPATH);\n                        cp = strrchr(fname, '/');\n                        if (!cp)\n                            fname[0] = '\\0';\n                        else\n                            *(++cp) = '\\0';\n                        strlcat(fname, cptr, SNMP_MAXPATH);\n                    }\n                    if (read_config(fname, line_handler, when) !=\n                        SNMPERR_SUCCESS && when != PREMIB_CONFIG)\n                        netsnmp_config_error(\"Included file '%s' not found.\",\n                                             fname);\n                    continue;\n                } else if ( strcasecmp( token, \"includesearch\" )==0) {\n                    struct config_files ctmp;\n                    int len, ret;\n\n                    if (cptr == NULL) {\n                        if (when != PREMIB_CONFIG)\n\t\t            netsnmp_config_error(\"Blank line following %s token.\", token);\n                        continue;\n                    }\n                    len = strlen(cptr);\n                    ctmp.fileHeader = cptr;\n                    ctmp.start = line_handler;\n                    ctmp.next = NULL;\n                    if ((len > 5) && (strcmp(&cptr[len-5],\".conf\") == 0))\n                       cptr[len-5] = 0; /* chop off .conf */\n                    ret = read_config_files_of_type(when,&ctmp);\n                    if ((len > 5) && (cptr[len-5] == 0))\n                       cptr[len-5] = '.'; /* restore .conf */\n                    if (( ret != SNMPERR_SUCCESS ) && (when != PREMIB_CONFIG))\n\t\t        netsnmp_config_error(\"Included config '%s' not found.\", cptr);\n                    continue;\n                } else {\n                    lptr = line_handler;\n                }\n            } else {\n                lptr = line_handler;\n            }\n            if (cptr == NULL) {\n\t\tnetsnmp_config_error(\"Blank line following %s token.\", token);\n            } else {\n                DEBUGMSGTL((\"read_config:line\", \"%s:%d examining: %s\\n\",\n                            filename, linecount, line));\n                run_config_handler(lptr, token, cptr, when);\n            }\n        }\n    }\n    free(line);\n    linecount = prev_linecount;\n    curfilename = prev_filename;\n    --depth;\n    return SNMPERR_SUCCESS;\n\n}                               /* end read_config() */\n",
    "target": 1,
    "idx": 1064315,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nint MqttDecode_Disconnect(byte *rx_buf, int rx_buf_len, MqttDisconnect *disc)\n{\n    int header_len, remain_len, tmp;\n    byte *rx_payload;\n    word32 props_len = 0;\n\n    /* Validate required arguments */\n    if ((rx_buf == NULL) || (rx_buf_len <= 0) || (disc == NULL)) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    /* Decode fixed header */\n    header_len = MqttDecode_FixedHeader(rx_buf, rx_buf_len, &remain_len,\n        MQTT_PACKET_TYPE_DISCONNECT, NULL, NULL, NULL);\n    if (header_len < 0) {\n        return header_len;\n    }\n    rx_payload = &rx_buf[header_len];\n\n    if (remain_len > 0) {\n        /* Decode variable header */\n        disc->reason_code = *rx_payload++;\n\n        if (remain_len > 1) {\n            /* Decode Length of Properties */\n            tmp = MqttDecode_Vbi(rx_payload, &props_len,\n                    (word32)(rx_buf_len - (rx_payload - rx_buf)));\n            if (tmp < 0)\n                return tmp;\n\n            if (props_len <= (word32)(rx_buf_len - (rx_payload - rx_buf))) {\n                rx_payload += tmp;\n                if (props_len > 0) {\n                    /* Decode the Properties */\n                    tmp = MqttDecode_Props(MQTT_PACKET_TYPE_DISCONNECT,\n                            &disc->props, rx_payload,\n                            (word32)(rx_buf_len - (rx_payload - rx_buf)),\n                            props_len);\n                    if (tmp < 0)\n                        return tmp;\n                    rx_payload += tmp;\n                }\n            }\n            else\n                return MQTT_CODE_ERROR_OUT_OF_BUFFER;\n        }\n    }\n\n    (void)rx_payload;\n\n    /* Return total length of packet */\n    return header_len + remain_len;\n}\n\nstatic int MqttClient_DecodePacket(MqttClient* client, byte* rx_buf,\n    word32 rx_len, void *packet_obj, MqttPacketType* ppacket_type,\n    MqttQoS* ppacket_qos, word16* ppacket_id)\n{\n    int rc = MQTT_CODE_SUCCESS;\n    MqttPacket* header;\n    MqttPacketType packet_type;\n    MqttQoS packet_qos;\n    word16 packet_id = 0;\n#ifdef WOLFMQTT_V5\n    MqttProp* props = NULL;\n#endif\n\n    /* must have rx buffer with at least 2 byes for header */\n    if (rx_buf == NULL || rx_len < MQTT_PACKET_HEADER_MIN_SIZE) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    /* Decode header */\n    header = (MqttPacket*)rx_buf;\n    packet_type = (MqttPacketType)MQTT_PACKET_TYPE_GET(header->type_flags);\n    if (ppacket_type) {\n        *ppacket_type = packet_type;\n    }\n    packet_qos = (MqttQoS)MQTT_PACKET_FLAGS_GET_QOS(header->type_flags);\n    if (ppacket_qos) {\n        *ppacket_qos = packet_qos;\n    }\n\n    /* Decode packet specific data (if requested) */\n    if (ppacket_id || packet_obj) {\n        switch (packet_type) {\n        case MQTT_PACKET_TYPE_CONNECT_ACK:\n        {\n            MqttConnectAck connect_ack, *p_connect_ack = &connect_ack;\n            if (packet_obj) {\n                p_connect_ack = (MqttConnectAck*)packet_obj;\n            }\n            else {\n                XMEMSET(p_connect_ack, 0, sizeof(MqttConnectAck));\n            }\n        #ifdef WOLFMQTT_V5\n            p_connect_ack->protocol_level = client->protocol_level;\n        #endif\n            rc = MqttDecode_ConnectAck(rx_buf, rx_len, p_connect_ack);\n        #ifdef WOLFMQTT_V5\n            if (rc >= 0) {\n                props = p_connect_ack->props;\n            }\n        #endif\n            break;\n        }\n        case MQTT_PACKET_TYPE_PUBLISH:\n        {\n            MqttPublish publish, *p_publish = &publish;\n            if (packet_obj) {\n                p_publish = (MqttPublish*)packet_obj;\n            }\n            else {\n                XMEMSET(p_publish, 0, sizeof(MqttPublish));\n            }\n        #ifdef WOLFMQTT_V5\n            p_publish->protocol_level = client->protocol_level;\n        #endif\n            rc = MqttDecode_Publish(rx_buf, rx_len, p_publish);\n            if (rc >= 0) {\n                packet_id = p_publish->packet_id;\n            #ifdef WOLFMQTT_V5\n                props = p_publish->props;\n            #endif\n            }\n            break;\n        }\n        case MQTT_PACKET_TYPE_PUBLISH_ACK:\n        case MQTT_PACKET_TYPE_PUBLISH_REC:\n        case MQTT_PACKET_TYPE_PUBLISH_REL:\n        case MQTT_PACKET_TYPE_PUBLISH_COMP:\n        {\n            MqttPublishResp publish_resp, *p_publish_resp = &publish_resp;\n            if (packet_obj) {\n                p_publish_resp = (MqttPublishResp*)packet_obj;\n            }\n            else {\n                XMEMSET(p_publish_resp, 0, sizeof(MqttPublishResp));\n            }\n        #ifdef WOLFMQTT_V5\n                p_publish_resp->protocol_level = client->protocol_level;\n        #endif\n                rc = MqttDecode_PublishResp(rx_buf, rx_len, packet_type,\n                p_publish_resp);\n            if (rc >= 0) {\n                packet_id = p_publish_resp->packet_id;\n            #ifdef WOLFMQTT_V5\n                props = p_publish_resp->props;\n            #endif\n            }\n            break;\n        }\n        case MQTT_PACKET_TYPE_SUBSCRIBE_ACK:\n        {\n            MqttSubscribeAck subscribe_ack, *p_subscribe_ack = &subscribe_ack;\n            if (packet_obj) {\n                p_subscribe_ack = (MqttSubscribeAck*)packet_obj;\n            }\n            else {\n                XMEMSET(p_subscribe_ack, 0, sizeof(MqttSubscribeAck));\n            }\n        #ifdef WOLFMQTT_V5\n            p_subscribe_ack->protocol_level = client->protocol_level;\n        #endif\n            rc = MqttDecode_SubscribeAck(rx_buf, rx_len, p_subscribe_ack);\n            if (rc >= 0) {\n                packet_id = p_subscribe_ack->packet_id;\n            #ifdef WOLFMQTT_V5\n                props = p_subscribe_ack->props;\n            #endif\n            }\n            break;\n        }\n        case MQTT_PACKET_TYPE_UNSUBSCRIBE_ACK:\n        {\n            MqttUnsubscribeAck unsubscribe_ack,\n                               *p_unsubscribe_ack = &unsubscribe_ack;\n            if (packet_obj) {\n                p_unsubscribe_ack = (MqttUnsubscribeAck*)packet_obj;\n            }\n            else {\n                XMEMSET(p_unsubscribe_ack, 0, sizeof(MqttUnsubscribeAck));\n            }\n        #ifdef WOLFMQTT_V5\n            p_unsubscribe_ack->protocol_level = client->protocol_level;\n        #endif\n            rc = MqttDecode_UnsubscribeAck(rx_buf, rx_len, p_unsubscribe_ack);\n            if (rc >= 0) {\n                packet_id = p_unsubscribe_ack->packet_id;\n            #ifdef WOLFMQTT_V5\n                props = p_unsubscribe_ack->props;\n            #endif\n            }\n            break;\n        }\n        case MQTT_PACKET_TYPE_PING_RESP:\n        {\n            MqttPing ping, *p_ping = &ping;\n            if (packet_obj) {\n                p_ping = (MqttPing*)packet_obj;\n            }\n            else {\n                XMEMSET(p_ping, 0, sizeof(MqttPing));\n            }\n            rc = MqttDecode_Ping(rx_buf, rx_len, p_ping);\n            break;\n        }\n        case MQTT_PACKET_TYPE_AUTH:\n        {\n        #ifdef WOLFMQTT_V5\n            MqttAuth auth, *p_auth = &auth;\n            if (packet_obj) {\n                p_auth = (MqttAuth*)packet_obj;\n            }\n            else {\n                XMEMSET(p_auth, 0, sizeof(MqttAuth));\n            }\n            rc = MqttDecode_Auth(rx_buf, rx_len, p_auth);\n            if (rc >= 0) {\n                props = p_auth->props;\n            }\n        #else\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n        #endif /* WOLFMQTT_V5 */\n            break;\n        }\n        case MQTT_PACKET_TYPE_DISCONNECT:\n        {\n        #ifdef WOLFMQTT_V5\n            MqttDisconnect disc, *p_disc = &disc;\n            if (packet_obj) {\n                p_disc = (MqttDisconnect*)packet_obj;\n            }\n            else {\n                XMEMSET(p_disc, 0, sizeof(MqttDisconnect));\n            }\n            rc = MqttDecode_Disconnect(rx_buf, rx_len, p_disc);\n            if (rc >= 0) {\n                props = p_disc->props;\n            }\n        #else\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n        #endif /* WOLFMQTT_V5 */\n            break;\n        }\n        case MQTT_PACKET_TYPE_CONNECT:\n        case MQTT_PACKET_TYPE_SUBSCRIBE:\n        case MQTT_PACKET_TYPE_UNSUBSCRIBE:\n        case MQTT_PACKET_TYPE_PING_REQ:\n        case MQTT_PACKET_TYPE_ANY:\n        case MQTT_PACKET_TYPE_RESERVED:\n        default:\n            /* these type are only encoded by client */\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n            break;\n        } /* switch (packet_type) */\n    }\n\n    if (ppacket_id) {\n        *ppacket_id = packet_id;\n    }\n\n#ifdef WOLFMQTT_V5\n    if (props) {\n    #ifdef WOLFMQTT_PROPERTY_CB\n        /* Check for properties set by the server */\n        if (packet_obj && client->property_cb) {\n            /* capture error if returned */\n            int rc_err = client->property_cb(client, props,\n                    client->property_ctx);\n            if (rc_err < 0) {\n                rc = rc_err;\n            }\n        }\n    #endif\n        /* Free the properties */\n        MqttProps_Free(props);\n    }\n#endif\n\n    (void)client;\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"MqttClient_DecodePacket: Rc %d, Len %d, Type %s (%d), ID %d,\"\n            \" QoS %d\",\n        rc, rx_len, MqttPacket_TypeDesc(packet_type), packet_type, packet_id,\n        packet_qos);\n#endif\n\n    return rc;\n}\n\nstatic int MqttClient_WaitType(MqttClient *client, void *packet_obj,\n    byte wait_type, word16 wait_packet_id, int timeout_ms)\n{\n    int rc;\n    word16 packet_id;\n    MqttPacketType packet_type;\n#ifdef WOLFMQTT_MULTITHREAD\n    MqttPendResp *pendResp;\n    int readLocked;\n#endif\n    MqttMsgStat* mms_stat;\n    int waitMatchFound;\n\n    if (client == NULL || packet_obj == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    /* all packet type structures must have MqttMsgStat at top */\n    mms_stat = (MqttMsgStat*)packet_obj;\n\nwait_again:\n\n    /* initialize variables */\n    packet_id = 0;\n    packet_type = MQTT_PACKET_TYPE_RESERVED;\n#ifdef WOLFMQTT_MULTITHREAD\n    pendResp = NULL;\n    readLocked = 0;\n#endif\n    waitMatchFound = 0;\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"MqttClient_WaitType: Type %s (%d), ID %d\",\n        MqttPacket_TypeDesc((MqttPacketType)wait_type),\n            wait_type, wait_packet_id);\n#endif\n\n    switch ((int)*mms_stat)\n    {\n        case MQTT_MSG_BEGIN:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Lock recv socket mutex */\n            rc = wm_SemLock(&client->lockRecv);\n            if (rc != 0) {\n                PRINTF(\"MqttClient_WaitType: recv lock error!\");\n                return rc;\n            }\n            readLocked = 1;\n        #endif\n\n            /* reset the packet state */\n            client->packet.stat = MQTT_PK_BEGIN;\n        }\n        FALL_THROUGH;\n\n    #ifdef WOLFMQTT_V5\n        case MQTT_MSG_AUTH:\n    #endif\n        case MQTT_MSG_WAIT:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if packet type and id have already completed */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, (MqttPacketType)wait_type, \n                    wait_packet_id, &pendResp)) {\n                    if (pendResp->packetDone) {\n                        /* pending response is already done, so return */\n                        rc = pendResp->packet_ret;\n                    #ifdef WOLFMQTT_DEBUG_CLIENT\n                        PRINTF(\"PendResp already Done %p: Rc %d\", pendResp, rc);\n                    #endif\n                        MqttClient_RespList_Remove(client, pendResp);\n                        wm_SemUnlock(&client->lockClient);\n                        wm_SemUnlock(&client->lockRecv);\n                        return rc;\n                    }\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            *mms_stat = MQTT_MSG_WAIT;\n\n            /* Wait for packet */\n            rc = MqttPacket_Read(client, client->rx_buf, client->rx_buf_len,\n                    timeout_ms);\n            /* handle failure */\n            if (rc <= 0) {\n                break;\n            }\n\n            /* capture length read */\n            client->packet.buf_len = rc;\n\n            /* Decode Packet - get type and id */\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, NULL, &packet_type, NULL, &packet_id);\n            if (rc < 0) {\n                break;\n            }\n\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"Read Packet: Len %d, Type %d, ID %d\",\n                client->packet.buf_len, packet_type, packet_id);\n        #endif\n\n            *mms_stat = MQTT_MSG_READ;\n        }\n        FALL_THROUGH;\n\n        case MQTT_MSG_READ:\n        case MQTT_MSG_READ_PAYLOAD:\n        {\n            MqttPacketType use_packet_type;\n            void* use_packet_obj;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            readLocked = 1; /* if in this state read is locked */\n        #endif\n\n            /* read payload state only happens for publish messages */\n            if (*mms_stat == MQTT_MSG_READ_PAYLOAD) {\n                packet_type = MQTT_PACKET_TYPE_PUBLISH;\n            }\n\n            /* Determine if we received data for this request */\n            if ((wait_type == MQTT_PACKET_TYPE_ANY ||\n                 wait_type == packet_type ||\n                 (MqttIsPubRespPacket(packet_type) &&\n                  MqttIsPubRespPacket(wait_type))) &&\n                (wait_packet_id == 0 || wait_packet_id == packet_id))\n            {\n                use_packet_obj = packet_obj;\n                waitMatchFound = 1;\n            }\n            else {\n                /* use generic packet object */\n                use_packet_obj = &client->msg;\n            }\n            use_packet_type = packet_type;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if we have a pending response for this packet */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, packet_type, packet_id,\n                                                               &pendResp)) {\n                    /* we found packet match this incoming read packet */\n                    pendResp->packetProcessing = 1;\n                    use_packet_obj = pendResp->packet_obj;\n                    use_packet_type = pendResp->packet_type;\n                    /* req from another thread... not a match */\n                    waitMatchFound = 0;\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            /* Perform packet handling for publish callback and QoS */\n            rc = MqttClient_HandlePacket(client, use_packet_type,\n                use_packet_obj, timeout_ms);\n\n        #ifdef WOLFMQTT_NONBLOCK\n            if (rc == MQTT_CODE_CONTINUE) {\n                /* we have received some data, so keep the recv\n                    mutex lock active and return */\n                return rc;\n            }\n        #endif\n\n            /* handle success case */\n            if (rc >= 0) {\n                rc = MQTT_CODE_SUCCESS;\n            }\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (pendResp) {\n                /* Mark pending response entry done */\n                if (wm_SemLock(&client->lockClient) == 0) {\n                    pendResp->packetDone = 1;\n                    pendResp->packet_ret = rc;\n                #ifdef WOLFMQTT_DEBUG_CLIENT\n                    PRINTF(\"PendResp Done %p\", pendResp);\n                #endif\n                    pendResp = NULL;\n                    wm_SemUnlock(&client->lockClient);\n                }\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n            break;\n        }\n\n        case MQTT_MSG_WRITE:\n        case MQTT_MSG_WRITE_PAYLOAD:\n        default:\n        {\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"MqttClient_WaitType: Invalid state %d!\", *mms_stat);\n        #endif\n            rc = MQTT_CODE_ERROR_STAT;\n            break;\n        }\n    } /* switch (*mms_stat) */\n\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc != MQTT_CODE_CONTINUE)\n#endif\n    {\n        /* reset state */\n        *mms_stat = MQTT_MSG_BEGIN;\n    }\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (readLocked) {\n        wm_SemUnlock(&client->lockRecv);\n    }\n#endif\n    if (rc < 0) {\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_WaitType: Failure: %s (%d)\",\n            MqttClient_ReturnCodeToString(rc), rc);\n    #endif\n        return rc;\n    }\n\n    if (!waitMatchFound) {\n        /* if we get here, then the we are still waiting for a packet */\n        goto wait_again;\n    }\n\n    return rc;\n}\n\nint MqttClient_Ping_ex(MqttClient *client, MqttPing* ping)\n{\n    int rc, len;\n\n    /* Validate required arguments */\n    if (client == NULL || ping == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    if (ping->stat == MQTT_MSG_BEGIN) {\n    #ifdef WOLFMQTT_MULTITHREAD\n        /* Lock send socket mutex */\n        rc = wm_SemLock(&client->lockSend);\n        if (rc != 0) {\n            return rc;\n        }\n    #endif\n\n        /* Encode the subscribe packet */\n        rc = MqttEncode_Ping(client->tx_buf, client->tx_buf_len, ping);\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d), ID %d, QoS %d\",\n            rc, MqttPacket_TypeDesc(MQTT_PACKET_TYPE_PING_REQ),\n            MQTT_PACKET_TYPE_PING_REQ, 0, 0);\n    #endif\n        if (rc <= 0) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            wm_SemUnlock(&client->lockSend);\n        #endif\n            return rc;\n        }\n        len = rc;\n\n    #ifdef WOLFMQTT_MULTITHREAD\n        rc = wm_SemLock(&client->lockClient);\n        if (rc == 0) {\n            /* inform other threads of expected response */\n            rc = MqttClient_RespList_Add(client, MQTT_PACKET_TYPE_PING_RESP, 0,\n                &ping->pendResp, ping);\n            wm_SemUnlock(&client->lockClient);\n        }\n        if (rc != 0) {\n            wm_SemUnlock(&client->lockSend);\n            return rc; /* Error locking client */\n        }\n    #endif\n\n        /* Send ping req packet */\n        rc = MqttPacket_Write(client, client->tx_buf, len);\n    #ifdef WOLFMQTT_MULTITHREAD\n        wm_SemUnlock(&client->lockSend);\n    #endif\n        if (rc != len) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (wm_SemLock(&client->lockClient) == 0) {\n                MqttClient_RespList_Remove(client, &ping->pendResp);\n                wm_SemUnlock(&client->lockClient);\n            }\n        #endif\n            return rc;\n        }\n\n        ping->stat = MQTT_MSG_WAIT;\n    }\n\n    /* Wait for ping resp packet */\n    rc = MqttClient_WaitType(client, ping, MQTT_PACKET_TYPE_PING_RESP, 0,\n        client->cmd_timeout_ms);\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc == MQTT_CODE_CONTINUE)\n        return rc;\n#endif\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (wm_SemLock(&client->lockClient) == 0) {\n        MqttClient_RespList_Remove(client, &ping->pendResp);\n        wm_SemUnlock(&client->lockClient);\n    }\n#endif\n\n    /* reset state */\n    ping->stat = MQTT_MSG_BEGIN;\n\n    return rc;\n}\n\nbool wolfMQTTFuzzer::ping(void) {\n    bool ret = false;\n\n    MqttPing ping;\n\n    memset(&ping, 0, sizeof(ping));\n\n    CHECK_EQ(MqttClient_Ping_ex(&client, &ping), true);\n\n    ret = true;\n\nend:\n    return ret;\n}\n\nvoid wolfMQTTFuzzer::Run(void) {\n    try {\n        const auto numActions = ds.Get<uint8_t>() % 20;\n\n        for (size_t i = 0; i < numActions; i++) {\n            switch ( ds.Get<uint8_t>() ) {\n                case    0:\n                    subscribe();\n                    break;\n                case    1:\n                    unsubscribe();\n                    break;\n                case    2:\n                    publish();\n                    break;\n                case    3:\n                    ping();\n                    break;\n                case    4:\n                    wait();\n                    break;\n            }\n        }\n\n        MqttClient_NetDisconnect(&client);\n    } catch ( ... ) { }\n}\n\n\n// target function\nstatic int MqttClient_WaitType(MqttClient *client, void *packet_obj,\n    byte wait_type, word16 wait_packet_id, int timeout_ms)\n{\n    int rc;\n    word16 packet_id;\n    MqttPacketType packet_type;\n#ifdef WOLFMQTT_MULTITHREAD\n    MqttPendResp *pendResp;\n    int readLocked;\n#endif\n    MqttMsgStat* mms_stat;\n    int waitMatchFound;\n\n    if (client == NULL || packet_obj == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    /* all packet type structures must have MqttMsgStat at top */\n    mms_stat = (MqttMsgStat*)packet_obj;\n\nwait_again:\n\n    /* initialize variables */\n    packet_id = 0;\n    packet_type = MQTT_PACKET_TYPE_RESERVED;\n#ifdef WOLFMQTT_MULTITHREAD\n    pendResp = NULL;\n    readLocked = 0;\n#endif\n    waitMatchFound = 0;\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"MqttClient_WaitType: Type %s (%d), ID %d\",\n        MqttPacket_TypeDesc((MqttPacketType)wait_type),\n            wait_type, wait_packet_id);\n#endif\n\n    switch ((int)*mms_stat)\n    {\n        case MQTT_MSG_BEGIN:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Lock recv socket mutex */\n            rc = wm_SemLock(&client->lockRecv);\n            if (rc != 0) {\n                PRINTF(\"MqttClient_WaitType: recv lock error!\");\n                return rc;\n            }\n            readLocked = 1;\n        #endif\n\n            /* reset the packet state */\n            client->packet.stat = MQTT_PK_BEGIN;\n        }\n        FALL_THROUGH;\n\n    #ifdef WOLFMQTT_V5\n        case MQTT_MSG_AUTH:\n    #endif\n        case MQTT_MSG_WAIT:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if packet type and id have already completed */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, (MqttPacketType)wait_type, \n                    wait_packet_id, &pendResp)) {\n                    if (pendResp->packetDone) {\n                        /* pending response is already done, so return */\n                        rc = pendResp->packet_ret;\n                    #ifdef WOLFMQTT_DEBUG_CLIENT\n                        PRINTF(\"PendResp already Done %p: Rc %d\", pendResp, rc);\n                    #endif\n                        MqttClient_RespList_Remove(client, pendResp);\n                        wm_SemUnlock(&client->lockClient);\n                        wm_SemUnlock(&client->lockRecv);\n                        return rc;\n                    }\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            *mms_stat = MQTT_MSG_WAIT;\n\n            /* Wait for packet */\n            rc = MqttPacket_Read(client, client->rx_buf, client->rx_buf_len,\n                    timeout_ms);\n            /* handle failure */\n            if (rc <= 0) {\n                break;\n            }\n\n            /* capture length read */\n            client->packet.buf_len = rc;\n\n            /* Decode Packet - get type and id */\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, NULL, &packet_type, NULL, &packet_id);\n            if (rc < 0) {\n                break;\n            }\n\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"Read Packet: Len %d, Type %d, ID %d\",\n                client->packet.buf_len, packet_type, packet_id);\n        #endif\n\n            *mms_stat = MQTT_MSG_READ;\n        }\n        FALL_THROUGH;\n\n        case MQTT_MSG_READ:\n        case MQTT_MSG_READ_PAYLOAD:\n        {\n            MqttPacketType use_packet_type;\n            void* use_packet_obj;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            readLocked = 1; /* if in this state read is locked */\n        #endif\n\n            /* read payload state only happens for publish messages */\n            if (*mms_stat == MQTT_MSG_READ_PAYLOAD) {\n                packet_type = MQTT_PACKET_TYPE_PUBLISH;\n            }\n\n            /* Determine if we received data for this request */\n            if ((wait_type == MQTT_PACKET_TYPE_ANY ||\n                 wait_type == packet_type ||\n                 MqttIsPubRespPacket(packet_type) == MqttIsPubRespPacket(wait_type)) &&\n               (wait_packet_id == 0 || wait_packet_id == packet_id))\n            {\n                use_packet_obj = packet_obj;\n                waitMatchFound = 1;\n            }\n            else {\n                /* use generic packet object */\n                use_packet_obj = &client->msg;\n            }\n            use_packet_type = packet_type;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if we have a pending response for this packet */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, packet_type, packet_id,\n                                                               &pendResp)) {\n                    /* we found packet match this incoming read packet */\n                    pendResp->packetProcessing = 1;\n                    use_packet_obj = pendResp->packet_obj;\n                    use_packet_type = pendResp->packet_type;\n                    /* req from another thread... not a match */\n                    waitMatchFound = 0;\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            /* Perform packet handling for publish callback and QoS */\n            rc = MqttClient_HandlePacket(client, use_packet_type,\n                use_packet_obj, timeout_ms);\n\n        #ifdef WOLFMQTT_NONBLOCK\n            if (rc == MQTT_CODE_CONTINUE) {\n                /* we have received some data, so keep the recv\n                    mutex lock active and return */\n                return rc;\n            }\n        #endif\n\n            /* handle success case */\n            if (rc >= 0) {\n                rc = MQTT_CODE_SUCCESS;\n            }\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (pendResp) {\n                /* Mark pending response entry done */\n                if (wm_SemLock(&client->lockClient) == 0) {\n                    pendResp->packetDone = 1;\n                    pendResp->packet_ret = rc;\n                #ifdef WOLFMQTT_DEBUG_CLIENT\n                    PRINTF(\"PendResp Done %p\", pendResp);\n                #endif\n                    pendResp = NULL;\n                    wm_SemUnlock(&client->lockClient);\n                }\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n            break;\n        }\n\n        case MQTT_MSG_WRITE:\n        case MQTT_MSG_WRITE_PAYLOAD:\n        default:\n        {\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"MqttClient_WaitType: Invalid state %d!\", *mms_stat);\n        #endif\n            rc = MQTT_CODE_ERROR_STAT;\n            break;\n        }\n    } /* switch (*mms_stat) */\n\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc != MQTT_CODE_CONTINUE)\n#endif\n    {\n        /* reset state */\n        *mms_stat = MQTT_MSG_BEGIN;\n    }\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (readLocked) {\n        wm_SemUnlock(&client->lockRecv);\n    }\n#endif\n    if (rc < 0) {\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_WaitType: Failure: %s (%d)\",\n            MqttClient_ReturnCodeToString(rc), rc);\n    #endif\n        return rc;\n    }\n\n    if (!waitMatchFound) {\n        /* if we get here, then the we are still waiting for a packet */\n        goto wait_again;\n    }\n\n    return rc;\n}\n",
    "target": 1,
    "idx": 1039053,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic void strcpy_url(char *output, const char *url, bool relative)\n{\n  /* we must add this with whitespace-replacing */\n  bool left = TRUE;\n  const unsigned char *iptr;\n  char *optr = output;\n  const unsigned char *host_sep = (const unsigned char *) url;\n\n  if(!relative)\n    host_sep = (const unsigned char *) find_host_sep(url);\n\n  for(iptr = (unsigned char *)url;    /* read from here */\n      *iptr;         /* until zero byte */\n      iptr++) {\n\n    if(iptr < host_sep) {\n      *optr++ = *iptr;\n      continue;\n    }\n\n    switch(*iptr) {\n    case '?':\n      left = FALSE;\n      /* fall through */\n    default:\n      if(*iptr >= 0x80) {\n        snprintf(optr, 4, \"%%%02x\", *iptr);\n        optr += 3;\n      }\n      else\n        *optr++=*iptr;\n      break;\n    case ' ':\n      if(left) {\n        *optr++='%'; /* add a '%' */\n        *optr++='2'; /* add a '2' */\n        *optr++='0'; /* add a '0' */\n      }\n      else\n        *optr++='+'; /* add a '+' here */\n      break;\n    }\n  }\n  *optr = 0; /* zero terminate output buffer */\n\n}\n\nCURLcode Curl_follow(struct Curl_easy *data,\n                     char *newurl,    /* the Location: string */\n                     followtype type) /* see transfer.h */\n{\n#ifdef CURL_DISABLE_HTTP\n  (void)data;\n  (void)newurl;\n  (void)type;\n  /* Location: following will not happen when HTTP is disabled */\n  return CURLE_TOO_MANY_REDIRECTS;\n#else\n\n  /* Location: redirect */\n  bool disallowport = FALSE;\n  bool reachedmax = FALSE;\n\n  if(type == FOLLOW_REDIR) {\n    if((data->set.maxredirs != -1) &&\n       (data->set.followlocation >= data->set.maxredirs)) {\n      reachedmax = TRUE;\n      type = FOLLOW_FAKE; /* switch to fake to store the would-be-redirected\n                             to URL */\n    }\n    else {\n      /* mark the next request as a followed location: */\n      data->state.this_is_a_follow = TRUE;\n\n      data->set.followlocation++; /* count location-followers */\n\n      if(data->set.http_auto_referer) {\n        /* We are asked to automatically set the previous URL as the referer\n           when we get the next URL. We pick the ->url field, which may or may\n           not be 100% correct */\n\n        if(data->change.referer_alloc) {\n          Curl_safefree(data->change.referer);\n          data->change.referer_alloc = FALSE;\n        }\n\n        data->change.referer = strdup(data->change.url);\n        if(!data->change.referer)\n          return CURLE_OUT_OF_MEMORY;\n        data->change.referer_alloc = TRUE; /* yes, free this later */\n      }\n    }\n  }\n\n  if(!is_absolute_url(newurl)) {\n    /***\n     *DANG* this is an RFC 2068 violation. The URL is supposed\n     to be absolute and this doesn't seem to be that!\n     */\n    char *absolute = concat_url(data->change.url, newurl);\n    if(!absolute)\n      return CURLE_OUT_OF_MEMORY;\n    newurl = absolute;\n  }\n  else {\n    /* The new URL MAY contain space or high byte values, that means a mighty\n       stupid redirect URL but we still make an effort to do \"right\". */\n    char *newest;\n    size_t newlen = strlen_url(newurl, FALSE);\n\n    /* This is an absolute URL, don't allow the custom port number */\n    disallowport = TRUE;\n\n    newest = malloc(newlen + 1); /* get memory for this */\n    if(!newest)\n      return CURLE_OUT_OF_MEMORY;\n\n    strcpy_url(newest, newurl, FALSE); /* create a space-free URL */\n    newurl = newest; /* use this instead now */\n\n  }\n\n  if(type == FOLLOW_FAKE) {\n    /* we're only figuring out the new url if we would've followed locations\n       but now we're done so we can get out! */\n    data->info.wouldredirect = newurl;\n\n    if(reachedmax) {\n      failf(data, \"Maximum (%ld) redirects followed\", data->set.maxredirs);\n      return CURLE_TOO_MANY_REDIRECTS;\n    }\n    return CURLE_OK;\n  }\n\n  if(disallowport)\n    data->state.allow_port = FALSE;\n\n  if(data->change.url_alloc) {\n    Curl_safefree(data->change.url);\n    data->change.url_alloc = FALSE;\n  }\n\n  data->change.url = newurl;\n  data->change.url_alloc = TRUE;\n\n  infof(data, \"Issue another request to this URL: '%s'\\n\", data->change.url);\n\n  /*\n   * We get here when the HTTP code is 300-399 (and 401). We need to perform\n   * differently based on exactly what return code there was.\n   *\n   * News from 7.10.6: we can also get here on a 401 or 407, in case we act on\n   * a HTTP (proxy-) authentication scheme other than Basic.\n   */\n  switch(data->info.httpcode) {\n    /* 401 - Act on a WWW-Authenticate, we keep on moving and do the\n       Authorization: XXXX header in the HTTP request code snippet */\n    /* 407 - Act on a Proxy-Authenticate, we keep on moving and do the\n       Proxy-Authorization: XXXX header in the HTTP request code snippet */\n    /* 300 - Multiple Choices */\n    /* 306 - Not used */\n    /* 307 - Temporary Redirect */\n  default:  /* for all above (and the unknown ones) */\n    /* Some codes are explicitly mentioned since I've checked RFC2616 and they\n     * seem to be OK to POST to.\n     */\n    break;\n  case 301: /* Moved Permanently */\n    /* (quote from RFC7231, section 6.4.2)\n     *\n     * Note: For historical reasons, a user agent MAY change the request\n     * method from POST to GET for the subsequent request.  If this\n     * behavior is undesired, the 307 (Temporary Redirect) status code\n     * can be used instead.\n     *\n     * ----\n     *\n     * Many webservers expect this, so these servers often answers to a POST\n     * request with an error page. To be sure that libcurl gets the page that\n     * most user agents would get, libcurl has to force GET.\n     *\n     * This behaviour is forbidden by RFC1945 and the obsolete RFC2616, and\n     * can be overridden with CURLOPT_POSTREDIR.\n     */\n    if((data->set.httpreq == HTTPREQ_POST\n        || data->set.httpreq == HTTPREQ_POST_FORM\n        || data->set.httpreq == HTTPREQ_POST_MIME)\n       && !(data->set.keep_post & CURL_REDIR_POST_301)) {\n      infof(data, \"Switch from POST to GET\\n\");\n      data->set.httpreq = HTTPREQ_GET;\n    }\n    break;\n  case 302: /* Found */\n    /* (quote from RFC7231, section 6.4.3)\n     *\n     * Note: For historical reasons, a user agent MAY change the request\n     * method from POST to GET for the subsequent request.  If this\n     * behavior is undesired, the 307 (Temporary Redirect) status code\n     * can be used instead.\n     *\n     * ----\n     *\n     * Many webservers expect this, so these servers often answers to a POST\n     * request with an error page. To be sure that libcurl gets the page that\n     * most user agents would get, libcurl has to force GET.\n     *\n     * This behaviour is forbidden by RFC1945 and the obsolete RFC2616, and\n     * can be overridden with CURLOPT_POSTREDIR.\n     */\n    if((data->set.httpreq == HTTPREQ_POST\n        || data->set.httpreq == HTTPREQ_POST_FORM\n        || data->set.httpreq == HTTPREQ_POST_MIME)\n       && !(data->set.keep_post & CURL_REDIR_POST_302)) {\n      infof(data, \"Switch from POST to GET\\n\");\n      data->set.httpreq = HTTPREQ_GET;\n    }\n    break;\n\n  case 303: /* See Other */\n    /* Disable both types of POSTs, unless the user explicitly\n       asks for POST after POST */\n    if(data->set.httpreq != HTTPREQ_GET\n      && !(data->set.keep_post & CURL_REDIR_POST_303)) {\n      data->set.httpreq = HTTPREQ_GET; /* enforce GET request */\n      infof(data, \"Disables POST, goes with %s\\n\",\n            data->set.opt_no_body?\"HEAD\":\"GET\");\n    }\n    break;\n  case 304: /* Not Modified */\n    /* 304 means we did a conditional request and it was \"Not modified\".\n     * We shouldn't get any Location: header in this response!\n     */\n    break;\n  case 305: /* Use Proxy */\n    /* (quote from RFC2616, section 10.3.6):\n     * \"The requested resource MUST be accessed through the proxy given\n     * by the Location field. The Location field gives the URI of the\n     * proxy.  The recipient is expected to repeat this single request\n     * via the proxy. 305 responses MUST only be generated by origin\n     * servers.\"\n     */\n    break;\n  }\n  Curl_pgrsTime(data, TIMER_REDIRECT);\n  Curl_pgrsResetTransferSizes(data);\n\n  return CURLE_OK;\n#endif /* CURL_DISABLE_HTTP */\n}\n\nstatic CURLMcode multi_runsingle(struct Curl_multi *multi,\n                                 struct curltime now,\n                                 struct Curl_easy *data)\n{\n  struct Curl_message *msg = NULL;\n  bool connected;\n  bool async;\n  bool protocol_connect = FALSE;\n  bool dophase_done = FALSE;\n  bool done = FALSE;\n  CURLMcode rc;\n  CURLcode result = CURLE_OK;\n  struct SingleRequest *k;\n  time_t timeout_ms;\n  time_t recv_timeout_ms;\n  timediff_t send_timeout_ms;\n  int control;\n\n  if(!GOOD_EASY_HANDLE(data))\n    return CURLM_BAD_EASY_HANDLE;\n\n  do {\n    /* A \"stream\" here is a logical stream if the protocol can handle that\n       (HTTP/2), or the full connection for older protocols */\n    bool stream_error = FALSE;\n    rc = CURLM_OK;\n\n    /* Handle the case when the pipe breaks, i.e., the connection\n       we're using gets cleaned up and we're left with nothing. */\n    if(data->state.pipe_broke) {\n      infof(data, \"Pipe broke: handle %p, url = %s\\n\",\n            (void *)data, data->state.path);\n\n      if(data->mstate < CURLM_STATE_COMPLETED) {\n        /* Head back to the CONNECT state */\n        multistate(data, CURLM_STATE_CONNECT);\n        rc = CURLM_CALL_MULTI_PERFORM;\n        result = CURLE_OK;\n      }\n\n      data->state.pipe_broke = FALSE;\n      data->easy_conn = NULL;\n      continue;\n    }\n\n    if(!data->easy_conn &&\n       data->mstate > CURLM_STATE_CONNECT &&\n       data->mstate < CURLM_STATE_DONE) {\n      /* In all these states, the code will blindly access 'data->easy_conn'\n         so this is precaution that it isn't NULL. And it silences static\n         analyzers. */\n      failf(data, \"In state %d with no easy_conn, bail out!\\n\", data->mstate);\n      return CURLM_INTERNAL_ERROR;\n    }\n\n    if(multi_ischanged(multi, TRUE)) {\n      DEBUGF(infof(data, \"multi changed, check CONNECT_PEND queue!\\n\"));\n      process_pending_handles(multi); /* pipelined/multiplexed */\n    }\n\n    if(data->easy_conn && data->mstate > CURLM_STATE_CONNECT &&\n       data->mstate < CURLM_STATE_COMPLETED) {\n      /* Make sure we set the connection's current owner */\n      data->easy_conn->data = data;\n    }\n\n    if(data->easy_conn &&\n       (data->mstate >= CURLM_STATE_CONNECT) &&\n       (data->mstate < CURLM_STATE_COMPLETED)) {\n      /* we need to wait for the connect state as only then is the start time\n         stored, but we must not check already completed handles */\n      timeout_ms = Curl_timeleft(data, &now,\n                                 (data->mstate <= CURLM_STATE_WAITDO)?\n                                 TRUE:FALSE);\n\n      if(timeout_ms < 0) {\n        /* Handle timed out */\n        if(data->mstate == CURLM_STATE_WAITRESOLVE)\n          failf(data, \"Resolving timed out after %ld milliseconds\",\n                Curl_timediff(now, data->progress.t_startsingle));\n        else if(data->mstate == CURLM_STATE_WAITCONNECT)\n          failf(data, \"Connection timed out after %ld milliseconds\",\n                Curl_timediff(now, data->progress.t_startsingle));\n        else {\n          k = &data->req;\n          if(k->size != -1) {\n            failf(data, \"Operation timed out after %ld milliseconds with %\"\n                  CURL_FORMAT_CURL_OFF_T \" out of %\"\n                  CURL_FORMAT_CURL_OFF_T \" bytes received\",\n                  Curl_timediff(now, data->progress.t_startsingle),\n                  k->bytecount, k->size);\n          }\n          else {\n            failf(data, \"Operation timed out after %ld milliseconds with %\"\n                  CURL_FORMAT_CURL_OFF_T \" bytes received\",\n                  Curl_timediff(now, data->progress.t_startsingle),\n                  k->bytecount);\n          }\n        }\n\n        /* Force connection closed if the connection has indeed been used */\n        if(data->mstate > CURLM_STATE_DO) {\n          streamclose(data->easy_conn, \"Disconnected with pending data\");\n          stream_error = TRUE;\n        }\n        result = CURLE_OPERATION_TIMEDOUT;\n        (void)multi_done(&data->easy_conn, result, TRUE);\n        /* Skip the statemachine and go directly to error handling section. */\n        goto statemachine_end;\n      }\n    }\n\n    switch(data->mstate) {\n    case CURLM_STATE_INIT:\n      /* init this transfer. */\n      result = Curl_pretransfer(data);\n\n      if(!result) {\n        /* after init, go CONNECT */\n        multistate(data, CURLM_STATE_CONNECT);\n        Curl_pgrsTime(data, TIMER_STARTOP);\n        rc = CURLM_CALL_MULTI_PERFORM;\n      }\n      break;\n\n    case CURLM_STATE_CONNECT_PEND:\n      /* We will stay here until there is a connection available. Then\n         we try again in the CURLM_STATE_CONNECT state. */\n      break;\n\n    case CURLM_STATE_CONNECT:\n      /* Connect. We want to get a connection identifier filled in. */\n      Curl_pgrsTime(data, TIMER_STARTSINGLE);\n      result = Curl_connect(data, &data->easy_conn,\n                            &async, &protocol_connect);\n      if(CURLE_NO_CONNECTION_AVAILABLE == result) {\n        /* There was no connection available. We will go to the pending\n           state and wait for an available connection. */\n        multistate(data, CURLM_STATE_CONNECT_PEND);\n\n        /* add this handle to the list of connect-pending handles */\n        Curl_llist_insert_next(&multi->pending, multi->pending.tail, data,\n                               &data->connect_queue);\n        result = CURLE_OK;\n        break;\n      }\n\n      if(!result) {\n        /* Add this handle to the send or pend pipeline */\n        result = Curl_add_handle_to_pipeline(data, data->easy_conn);\n        if(result)\n          stream_error = TRUE;\n        else {\n          if(async)\n            /* We're now waiting for an asynchronous name lookup */\n            multistate(data, CURLM_STATE_WAITRESOLVE);\n          else {\n            /* after the connect has been sent off, go WAITCONNECT unless the\n               protocol connect is already done and we can go directly to\n               WAITDO or DO! */\n            rc = CURLM_CALL_MULTI_PERFORM;\n\n            if(protocol_connect)\n              multistate(data, Curl_pipeline_wanted(multi, CURLPIPE_HTTP1)?\n                         CURLM_STATE_WAITDO:CURLM_STATE_DO);\n            else {\n#ifndef CURL_DISABLE_HTTP\n              if(Curl_connect_ongoing(data->easy_conn))\n                multistate(data, CURLM_STATE_WAITPROXYCONNECT);\n              else\n#endif\n                multistate(data, CURLM_STATE_WAITCONNECT);\n            }\n          }\n        }\n      }\n      break;\n\n    case CURLM_STATE_WAITRESOLVE:\n      /* awaiting an asynch name resolve to complete */\n    {\n      struct Curl_dns_entry *dns = NULL;\n      struct connectdata *conn = data->easy_conn;\n      const char *hostname;\n\n      if(conn->bits.httpproxy)\n        hostname = conn->http_proxy.host.name;\n      else if(conn->bits.conn_to_host)\n        hostname = conn->conn_to_host.name;\n      else\n        hostname = conn->host.name;\n\n      /* check if we have the name resolved by now */\n      dns = Curl_fetch_addr(conn, hostname, (int)conn->port);\n\n      if(dns) {\n#ifdef CURLRES_ASYNCH\n        conn->async.dns = dns;\n        conn->async.done = TRUE;\n#endif\n        result = CURLE_OK;\n        infof(data, \"Hostname '%s' was found in DNS cache\\n\", hostname);\n      }\n\n      if(!dns)\n        result = Curl_resolver_is_resolved(data->easy_conn, &dns);\n\n      /* Update sockets here, because the socket(s) may have been\n         closed and the application thus needs to be told, even if it\n         is likely that the same socket(s) will again be used further\n         down.  If the name has not yet been resolved, it is likely\n         that new sockets have been opened in an attempt to contact\n         another resolver. */\n      singlesocket(multi, data);\n\n      if(dns) {\n        /* Perform the next step in the connection phase, and then move on\n           to the WAITCONNECT state */\n        result = Curl_async_resolved(data->easy_conn, &protocol_connect);\n\n        if(result)\n          /* if Curl_async_resolved() returns failure, the connection struct\n             is already freed and gone */\n          data->easy_conn = NULL;           /* no more connection */\n        else {\n          /* call again please so that we get the next socket setup */\n          rc = CURLM_CALL_MULTI_PERFORM;\n          if(protocol_connect)\n            multistate(data, Curl_pipeline_wanted(multi, CURLPIPE_HTTP1)?\n                       CURLM_STATE_WAITDO:CURLM_STATE_DO);\n          else {\n#ifndef CURL_DISABLE_HTTP\n            if(Curl_connect_ongoing(data->easy_conn))\n              multistate(data, CURLM_STATE_WAITPROXYCONNECT);\n            else\n#endif\n              multistate(data, CURLM_STATE_WAITCONNECT);\n          }\n        }\n      }\n\n      if(result) {\n        /* failure detected */\n        stream_error = TRUE;\n        break;\n      }\n    }\n    break;\n\n#ifndef CURL_DISABLE_HTTP\n    case CURLM_STATE_WAITPROXYCONNECT:\n      /* this is HTTP-specific, but sending CONNECT to a proxy is HTTP... */\n      result = Curl_http_connect(data->easy_conn, &protocol_connect);\n\n      if(data->easy_conn->bits.proxy_connect_closed) {\n        rc = CURLM_CALL_MULTI_PERFORM;\n        /* connect back to proxy again */\n        result = CURLE_OK;\n        multi_done(&data->easy_conn, CURLE_OK, FALSE);\n        multistate(data, CURLM_STATE_CONNECT);\n      }\n      else if(!result) {\n        if((data->easy_conn->http_proxy.proxytype != CURLPROXY_HTTPS ||\n           data->easy_conn->bits.proxy_ssl_connected[FIRSTSOCKET]) &&\n           Curl_connect_complete(data->easy_conn)) {\n          rc = CURLM_CALL_MULTI_PERFORM;\n          /* initiate protocol connect phase */\n          multistate(data, CURLM_STATE_SENDPROTOCONNECT);\n        }\n      }\n      break;\n#endif\n\n    case CURLM_STATE_WAITCONNECT:\n      /* awaiting a completion of an asynch TCP connect */\n      result = Curl_is_connected(data->easy_conn, FIRSTSOCKET, &connected);\n      if(connected && !result) {\n#ifndef CURL_DISABLE_HTTP\n        if((data->easy_conn->http_proxy.proxytype == CURLPROXY_HTTPS &&\n            !data->easy_conn->bits.proxy_ssl_connected[FIRSTSOCKET]) ||\n           Curl_connect_ongoing(data->easy_conn)) {\n          multistate(data, CURLM_STATE_WAITPROXYCONNECT);\n          break;\n        }\n#endif\n        rc = CURLM_CALL_MULTI_PERFORM;\n        multistate(data, data->easy_conn->bits.tunnel_proxy?\n                   CURLM_STATE_WAITPROXYCONNECT:\n                   CURLM_STATE_SENDPROTOCONNECT);\n      }\n      else if(result) {\n        /* failure detected */\n        /* Just break, the cleaning up is handled all in one place */\n        stream_error = TRUE;\n        break;\n      }\n      break;\n\n    case CURLM_STATE_SENDPROTOCONNECT:\n      result = Curl_protocol_connect(data->easy_conn, &protocol_connect);\n      if(!protocol_connect)\n        /* switch to waiting state */\n        multistate(data, CURLM_STATE_PROTOCONNECT);\n      else if(!result) {\n        /* protocol connect has completed, go WAITDO or DO */\n        multistate(data, Curl_pipeline_wanted(multi, CURLPIPE_HTTP1)?\n                   CURLM_STATE_WAITDO:CURLM_STATE_DO);\n        rc = CURLM_CALL_MULTI_PERFORM;\n      }\n      else if(result) {\n        /* failure detected */\n        Curl_posttransfer(data);\n        multi_done(&data->easy_conn, result, TRUE);\n        stream_error = TRUE;\n      }\n      break;\n\n    case CURLM_STATE_PROTOCONNECT:\n      /* protocol-specific connect phase */\n      result = Curl_protocol_connecting(data->easy_conn, &protocol_connect);\n      if(!result && protocol_connect) {\n        /* after the connect has completed, go WAITDO or DO */\n        multistate(data, Curl_pipeline_wanted(multi, CURLPIPE_HTTP1)?\n                   CURLM_STATE_WAITDO:CURLM_STATE_DO);\n        rc = CURLM_CALL_MULTI_PERFORM;\n      }\n      else if(result) {\n        /* failure detected */\n        Curl_posttransfer(data);\n        multi_done(&data->easy_conn, result, TRUE);\n        stream_error = TRUE;\n      }\n      break;\n\n    case CURLM_STATE_WAITDO:\n      /* Wait for our turn to DO when we're pipelining requests */\n      if(Curl_pipeline_checkget_write(data, data->easy_conn)) {\n        /* Grabbed the channel */\n        multistate(data, CURLM_STATE_DO);\n        rc = CURLM_CALL_MULTI_PERFORM;\n      }\n      break;\n\n    case CURLM_STATE_DO:\n      if(data->set.connect_only) {\n        /* keep connection open for application to use the socket */\n        connkeep(data->easy_conn, \"CONNECT_ONLY\");\n        multistate(data, CURLM_STATE_DONE);\n        result = CURLE_OK;\n        rc = CURLM_CALL_MULTI_PERFORM;\n      }\n      else {\n        /* Perform the protocol's DO action */\n        result = multi_do(&data->easy_conn, &dophase_done);\n\n        /* When multi_do() returns failure, data->easy_conn might be NULL! */\n\n        if(!result) {\n          if(!dophase_done) {\n            /* some steps needed for wildcard matching */\n            if(data->state.wildcardmatch) {\n              struct WildcardData *wc = &data->wildcard;\n              if(wc->state == CURLWC_DONE || wc->state == CURLWC_SKIP) {\n                /* skip some states if it is important */\n                multi_done(&data->easy_conn, CURLE_OK, FALSE);\n                multistate(data, CURLM_STATE_DONE);\n                rc = CURLM_CALL_MULTI_PERFORM;\n                break;\n              }\n            }\n            /* DO was not completed in one function call, we must continue\n               DOING... */\n            multistate(data, CURLM_STATE_DOING);\n            rc = CURLM_OK;\n          }\n\n          /* after DO, go DO_DONE... or DO_MORE */\n          else if(data->easy_conn->bits.do_more) {\n            /* we're supposed to do more, but we need to sit down, relax\n               and wait a little while first */\n            multistate(data, CURLM_STATE_DO_MORE);\n            rc = CURLM_OK;\n          }\n          else {\n            /* we're done with the DO, now DO_DONE */\n            multistate(data, CURLM_STATE_DO_DONE);\n            rc = CURLM_CALL_MULTI_PERFORM;\n          }\n        }\n        else if((CURLE_SEND_ERROR == result) &&\n                data->easy_conn->bits.reuse) {\n          /*\n           * In this situation, a connection that we were trying to use\n           * may have unexpectedly died.  If possible, send the connection\n           * back to the CONNECT phase so we can try again.\n           */\n          char *newurl = NULL;\n          followtype follow = FOLLOW_NONE;\n          CURLcode drc;\n          bool retry = FALSE;\n\n          drc = Curl_retry_request(data->easy_conn, &newurl);\n          if(drc) {\n            /* a failure here pretty much implies an out of memory */\n            result = drc;\n            stream_error = TRUE;\n          }\n          else\n            retry = (newurl)?TRUE:FALSE;\n\n          Curl_posttransfer(data);\n          drc = multi_done(&data->easy_conn, result, FALSE);\n\n          /* When set to retry the connection, we must to go back to\n           * the CONNECT state */\n          if(retry) {\n            if(!drc || (drc == CURLE_SEND_ERROR)) {\n              follow = FOLLOW_RETRY;\n              drc = Curl_follow(data, newurl, follow);\n              if(!drc) {\n                multistate(data, CURLM_STATE_CONNECT);\n                rc = CURLM_CALL_MULTI_PERFORM;\n                result = CURLE_OK;\n              }\n              else {\n                /* Follow failed */\n                result = drc;\n              }\n            }\n            else {\n              /* done didn't return OK or SEND_ERROR */\n              result = drc;\n            }\n          }\n          else {\n            /* Have error handler disconnect conn if we can't retry */\n            stream_error = TRUE;\n          }\n          free(newurl);\n        }\n        else {\n          /* failure detected */\n          Curl_posttransfer(data);\n          if(data->easy_conn)\n            multi_done(&data->easy_conn, result, FALSE);\n          stream_error = TRUE;\n        }\n      }\n      break;\n\n    case CURLM_STATE_DOING:\n      /* we continue DOING until the DO phase is complete */\n      result = Curl_protocol_doing(data->easy_conn,\n                                   &dophase_done);\n      if(!result) {\n        if(dophase_done) {\n          /* after DO, go DO_DONE or DO_MORE */\n          multistate(data, data->easy_conn->bits.do_more?\n                     CURLM_STATE_DO_MORE:\n                     CURLM_STATE_DO_DONE);\n          rc = CURLM_CALL_MULTI_PERFORM;\n        } /* dophase_done */\n      }\n      else {\n        /* failure detected */\n        Curl_posttransfer(data);\n        multi_done(&data->easy_conn, result, FALSE);\n        stream_error = TRUE;\n      }\n      break;\n\n    case CURLM_STATE_DO_MORE:\n      /*\n       * When we are connected, DO MORE and then go DO_DONE\n       */\n      result = multi_do_more(data->easy_conn, &control);\n\n      /* No need to remove this handle from the send pipeline here since that\n         is done in multi_done() */\n      if(!result) {\n        if(control) {\n          /* if positive, advance to DO_DONE\n             if negative, go back to DOING */\n          multistate(data, control == 1?\n                     CURLM_STATE_DO_DONE:\n                     CURLM_STATE_DOING);\n          rc = CURLM_CALL_MULTI_PERFORM;\n        }\n        else\n          /* stay in DO_MORE */\n          rc = CURLM_OK;\n      }\n      else {\n        /* failure detected */\n        Curl_posttransfer(data);\n        multi_done(&data->easy_conn, result, FALSE);\n        stream_error = TRUE;\n      }\n      break;\n\n    case CURLM_STATE_DO_DONE:\n      /* Move ourselves from the send to recv pipeline */\n      Curl_move_handle_from_send_to_recv_pipe(data, data->easy_conn);\n\n      if(data->easy_conn->bits.multiplex || data->easy_conn->send_pipe.size)\n        /* Check if we can move pending requests to send pipe */\n        process_pending_handles(multi); /*  pipelined/multiplexed */\n\n      /* Only perform the transfer if there's a good socket to work with.\n         Having both BAD is a signal to skip immediately to DONE */\n      if((data->easy_conn->sockfd != CURL_SOCKET_BAD) ||\n         (data->easy_conn->writesockfd != CURL_SOCKET_BAD))\n        multistate(data, CURLM_STATE_WAITPERFORM);\n      else\n      {\n        if(data->state.wildcardmatch &&\n           ((data->easy_conn->handler->flags & PROTOPT_WILDCARD) == 0)) {\n           data->wildcard.state = CURLWC_DONE;\n        }\n        multistate(data, CURLM_STATE_DONE);\n      }\n      rc = CURLM_CALL_MULTI_PERFORM;\n      break;\n\n    case CURLM_STATE_WAITPERFORM:\n      /* Wait for our turn to PERFORM */\n      if(Curl_pipeline_checkget_read(data, data->easy_conn)) {\n        /* Grabbed the channel */\n        multistate(data, CURLM_STATE_PERFORM);\n        rc = CURLM_CALL_MULTI_PERFORM;\n      }\n      break;\n\n    case CURLM_STATE_TOOFAST: /* limit-rate exceeded in either direction */\n      /* if both rates are within spec, resume transfer */\n      if(Curl_pgrsUpdate(data->easy_conn))\n        result = CURLE_ABORTED_BY_CALLBACK;\n      else\n        result = Curl_speedcheck(data, now);\n\n      if(!result) {\n        send_timeout_ms = 0;\n        if(data->set.max_send_speed > 0)\n          send_timeout_ms =\n            Curl_pgrsLimitWaitTime(data->progress.uploaded,\n                                   data->progress.ul_limit_size,\n                                   data->set.max_send_speed,\n                                   data->progress.ul_limit_start,\n                                   now);\n\n        recv_timeout_ms = 0;\n        if(data->set.max_recv_speed > 0)\n          recv_timeout_ms =\n            Curl_pgrsLimitWaitTime(data->progress.downloaded,\n                                   data->progress.dl_limit_size,\n                                   data->set.max_recv_speed,\n                                   data->progress.dl_limit_start,\n                                   now);\n\n        if(!send_timeout_ms && !recv_timeout_ms) {\n          multistate(data, CURLM_STATE_PERFORM);\n          Curl_ratelimit(data, now);\n        }\n        else if(send_timeout_ms >= recv_timeout_ms)\n          Curl_expire(data, send_timeout_ms, EXPIRE_TOOFAST);\n        else\n          Curl_expire(data, recv_timeout_ms, EXPIRE_TOOFAST);\n      }\n      break;\n\n    case CURLM_STATE_PERFORM:\n    {\n      char *newurl = NULL;\n      bool retry = FALSE;\n      bool comeback = FALSE;\n\n      /* check if over send speed */\n      send_timeout_ms = 0;\n      if(data->set.max_send_speed > 0)\n        send_timeout_ms = Curl_pgrsLimitWaitTime(data->progress.uploaded,\n                                                 data->progress.ul_limit_size,\n                                                 data->set.max_send_speed,\n                                                 data->progress.ul_limit_start,\n                                                 now);\n\n      /* check if over recv speed */\n      recv_timeout_ms = 0;\n      if(data->set.max_recv_speed > 0)\n        recv_timeout_ms = Curl_pgrsLimitWaitTime(data->progress.downloaded,\n                                                 data->progress.dl_limit_size,\n                                                 data->set.max_recv_speed,\n                                                 data->progress.dl_limit_start,\n                                                 now);\n\n      if(send_timeout_ms || recv_timeout_ms) {\n        Curl_ratelimit(data, now);\n        multistate(data, CURLM_STATE_TOOFAST);\n        if(send_timeout_ms >= recv_timeout_ms)\n          Curl_expire(data, send_timeout_ms, EXPIRE_TOOFAST);\n        else\n          Curl_expire(data, recv_timeout_ms, EXPIRE_TOOFAST);\n        break;\n      }\n\n      /* read/write data if it is ready to do so */\n      result = Curl_readwrite(data->easy_conn, data, &done, &comeback);\n\n      k = &data->req;\n\n      if(!(k->keepon & KEEP_RECV))\n        /* We're done receiving */\n        Curl_pipeline_leave_read(data->easy_conn);\n\n      if(!(k->keepon & KEEP_SEND))\n        /* We're done sending */\n        Curl_pipeline_leave_write(data->easy_conn);\n\n      if(done || (result == CURLE_RECV_ERROR)) {\n        /* If CURLE_RECV_ERROR happens early enough, we assume it was a race\n         * condition and the server closed the re-used connection exactly when\n         * we wanted to use it, so figure out if that is indeed the case.\n         */\n        CURLcode ret = Curl_retry_request(data->easy_conn, &newurl);\n        if(!ret)\n          retry = (newurl)?TRUE:FALSE;\n\n        if(retry) {\n          /* if we are to retry, set the result to OK and consider the\n             request as done */\n          result = CURLE_OK;\n          done = TRUE;\n        }\n      }\n\n      if(result) {\n        /*\n         * The transfer phase returned error, we mark the connection to get\n         * closed to prevent being re-used. This is because we can't possibly\n         * know if the connection is in a good shape or not now.  Unless it is\n         * a protocol which uses two \"channels\" like FTP, as then the error\n         * happened in the data connection.\n         */\n\n        if(!(data->easy_conn->handler->flags & PROTOPT_DUAL) &&\n           result != CURLE_HTTP2_STREAM)\n          streamclose(data->easy_conn, \"Transfer returned error\");\n\n        Curl_posttransfer(data);\n        multi_done(&data->easy_conn, result, TRUE);\n      }\n      else if(done) {\n        followtype follow = FOLLOW_NONE;\n\n        /* call this even if the readwrite function returned error */\n        Curl_posttransfer(data);\n\n        /* we're no longer receiving */\n        Curl_removeHandleFromPipeline(data, &data->easy_conn->recv_pipe);\n\n        /* expire the new receiving pipeline head */\n        if(data->easy_conn->recv_pipe.head)\n          Curl_expire(data->easy_conn->recv_pipe.head->ptr, 0, EXPIRE_RUN_NOW);\n\n        /* When we follow redirects or is set to retry the connection, we must\n           to go back to the CONNECT state */\n        if(data->req.newurl || retry) {\n          if(!retry) {\n            /* if the URL is a follow-location and not just a retried request\n               then figure out the URL here */\n            free(newurl);\n            newurl = data->req.newurl;\n            data->req.newurl = NULL;\n            follow = FOLLOW_REDIR;\n          }\n          else\n            follow = FOLLOW_RETRY;\n          result = multi_done(&data->easy_conn, CURLE_OK, FALSE);\n          if(!result) {\n            result = Curl_follow(data, newurl, follow);\n            if(!result) {\n              multistate(data, CURLM_STATE_CONNECT);\n              rc = CURLM_CALL_MULTI_PERFORM;\n            }\n          }\n        }\n        else {\n          /* after the transfer is done, go DONE */\n\n          /* but first check to see if we got a location info even though we're\n             not following redirects */\n          if(data->req.location) {\n            free(newurl);\n            newurl = data->req.location;\n            data->req.location = NULL;\n            result = Curl_follow(data, newurl, FOLLOW_FAKE);\n            if(result)\n              stream_error = TRUE;\n          }\n\n          multistate(data, CURLM_STATE_DONE);\n          rc = CURLM_CALL_MULTI_PERFORM;\n        }\n      }\n      else if(comeback)\n        rc = CURLM_CALL_MULTI_PERFORM;\n\n      free(newurl);\n      break;\n    }\n\n    case CURLM_STATE_DONE:\n      /* this state is highly transient, so run another loop after this */\n      rc = CURLM_CALL_MULTI_PERFORM;\n\n      if(data->easy_conn) {\n        CURLcode res;\n\n        /* Remove ourselves from the receive pipeline, if we are there. */\n        Curl_removeHandleFromPipeline(data, &data->easy_conn->recv_pipe);\n\n        if(data->easy_conn->bits.multiplex || data->easy_conn->send_pipe.size)\n          /* Check if we can move pending requests to connection */\n          process_pending_handles(multi); /* pipelined/multiplexing */\n\n        /* post-transfer command */\n        res = multi_done(&data->easy_conn, result, FALSE);\n\n        /* allow a previously set error code take precedence */\n        if(!result)\n          result = res;\n\n        /*\n         * If there are other handles on the pipeline, multi_done won't set\n         * easy_conn to NULL.  In such a case, curl_multi_remove_handle() can\n         * access free'd data, if the connection is free'd and the handle\n         * removed before we perform the processing in CURLM_STATE_COMPLETED\n         */\n        if(data->easy_conn)\n          data->easy_conn = NULL;\n      }\n\n      if(data->state.wildcardmatch) {\n        if(data->wildcard.state != CURLWC_DONE) {\n          /* if a wildcard is set and we are not ending -> lets start again\n             with CURLM_STATE_INIT */\n          multistate(data, CURLM_STATE_INIT);\n          break;\n        }\n      }\n\n      /* after we have DONE what we're supposed to do, go COMPLETED, and\n         it doesn't matter what the multi_done() returned! */\n      multistate(data, CURLM_STATE_COMPLETED);\n      break;\n\n    case CURLM_STATE_COMPLETED:\n      /* this is a completed transfer, it is likely to still be connected */\n\n      /* This node should be delinked from the list now and we should post\n         an information message that we are complete. */\n\n      /* Important: reset the conn pointer so that we don't point to memory\n         that could be freed anytime */\n      data->easy_conn = NULL;\n\n      Curl_expire_clear(data); /* stop all timers */\n      break;\n\n    case CURLM_STATE_MSGSENT:\n      data->result = result;\n      return CURLM_OK; /* do nothing */\n\n    default:\n      return CURLM_INTERNAL_ERROR;\n    }\n    statemachine_end:\n\n    if(data->mstate < CURLM_STATE_COMPLETED) {\n      if(result) {\n        /*\n         * If an error was returned, and we aren't in completed state now,\n         * then we go to completed and consider this transfer aborted.\n         */\n\n        /* NOTE: no attempt to disconnect connections must be made\n           in the case blocks above - cleanup happens only here */\n\n        data->state.pipe_broke = FALSE;\n\n        /* Check if we can move pending requests to send pipe */\n        process_pending_handles(multi); /* connection */\n\n        if(data->easy_conn) {\n          /* if this has a connection, unsubscribe from the pipelines */\n          Curl_pipeline_leave_write(data->easy_conn);\n          Curl_pipeline_leave_read(data->easy_conn);\n          Curl_removeHandleFromPipeline(data, &data->easy_conn->send_pipe);\n          Curl_removeHandleFromPipeline(data, &data->easy_conn->recv_pipe);\n\n          if(stream_error) {\n            /* Don't attempt to send data over a connection that timed out */\n            bool dead_connection = result == CURLE_OPERATION_TIMEDOUT;\n            /* disconnect properly */\n            Curl_disconnect(data->easy_conn, dead_connection);\n\n            /* This is where we make sure that the easy_conn pointer is reset.\n               We don't have to do this in every case block above where a\n               failure is detected */\n            data->easy_conn = NULL;\n          }\n        }\n        else if(data->mstate == CURLM_STATE_CONNECT) {\n          /* Curl_connect() failed */\n          (void)Curl_posttransfer(data);\n        }\n\n        multistate(data, CURLM_STATE_COMPLETED);\n      }\n      /* if there's still a connection to use, call the progress function */\n      else if(data->easy_conn && Curl_pgrsUpdate(data->easy_conn)) {\n        /* aborted due to progress callback return code must close the\n           connection */\n        result = CURLE_ABORTED_BY_CALLBACK;\n        streamclose(data->easy_conn, \"Aborted by callback\");\n\n        /* if not yet in DONE state, go there, otherwise COMPLETED */\n        multistate(data, (data->mstate < CURLM_STATE_DONE)?\n                   CURLM_STATE_DONE: CURLM_STATE_COMPLETED);\n        rc = CURLM_CALL_MULTI_PERFORM;\n      }\n    }\n\n    if(CURLM_STATE_COMPLETED == data->mstate) {\n      /* now fill in the Curl_message with this info */\n      msg = &data->msg;\n\n      msg->extmsg.msg = CURLMSG_DONE;\n      msg->extmsg.easy_handle = data;\n      msg->extmsg.data.result = result;\n\n      rc = multi_addmsg(multi, msg);\n\n      multistate(data, CURLM_STATE_MSGSENT);\n    }\n  } while((rc == CURLM_CALL_MULTI_PERFORM) || multi_ischanged(multi, FALSE));\n\n  data->result = result;\n\n\n  return rc;\n}\n\nCURLMcode curl_multi_perform(struct Curl_multi *multi, int *running_handles)\n{\n  struct Curl_easy *data;\n  CURLMcode returncode = CURLM_OK;\n  struct Curl_tree *t;\n  struct curltime now = Curl_now();\n\n  if(!GOOD_MULTI_HANDLE(multi))\n    return CURLM_BAD_HANDLE;\n\n  if(multi->in_callback)\n    return CURLM_RECURSIVE_API_CALL;\n\n  data = multi->easyp;\n  while(data) {\n    CURLMcode result;\n    SIGPIPE_VARIABLE(pipe_st);\n\n    sigpipe_ignore(data, &pipe_st);\n    result = multi_runsingle(multi, now, data);\n    sigpipe_restore(&pipe_st);\n\n    if(result)\n      returncode = result;\n\n    data = data->next; /* operate on next handle */\n  }\n\n  /*\n   * Simply remove all expired timers from the splay since handles are dealt\n   * with unconditionally by this function and curl_multi_timeout() requires\n   * that already passed/handled expire times are removed from the splay.\n   *\n   * It is important that the 'now' value is set at the entry of this function\n   * and not for the current time as it may have ticked a little while since\n   * then and then we risk this loop to remove timers that actually have not\n   * been handled!\n   */\n  do {\n    multi->timetree = Curl_splaygetbest(now, multi->timetree, &t);\n    if(t)\n      /* the removed may have another timeout in queue */\n      (void)add_next_timeout(now, multi, t->payload);\n\n  } while(t);\n\n  *running_handles = multi->num_alive;\n\n  if(CURLM_OK >= returncode)\n    update_timer(multi);\n\n  return returncode;\n}\n\nint fuzz_handle_transfer(FUZZ_DATA *fuzz)\n{\n  int rc = 0;\n  CURLM *multi_handle;\n  int still_running; /* keep number of running handles */\n  CURLMsg *msg; /* for picking up messages with the transfer status */\n  int msgs_left; /* how many messages are left */\n  int double_timeout = 0;\n  fd_set fdread;\n  fd_set fdwrite;\n  fd_set fdexcep;\n  struct timeval timeout;\n  int select_rc;\n  CURLMcode mc;\n  int maxfd = -1;\n  long curl_timeo = -1;\n  int ii;\n  FUZZ_SOCKET_MANAGER *sman[FUZZ_NUM_CONNECTIONS];\n\n  for(ii = 0; ii < FUZZ_NUM_CONNECTIONS; ii++) {\n    sman[ii] = &fuzz->sockman[ii];\n\n    /* Set up the starting index for responses. */\n    sman[ii]->response_index = 1;\n  }\n\n  /* init a multi stack */\n  multi_handle = curl_multi_init();\n\n  /* add the individual transfers */\n  curl_multi_add_handle(multi_handle, fuzz->easy);\n\n  /* Do an initial process. This might end the transfer immediately. */\n  curl_multi_perform(multi_handle, &still_running);\n  FV_PRINTF(fuzz,\n            \"FUZZ: Initial perform; still running? %d \\n\",\n            still_running);\n\n  while(still_running) {\n    /* Reset the sets of file descriptors. */\n    FD_ZERO(&fdread);\n    FD_ZERO(&fdwrite);\n    FD_ZERO(&fdexcep);\n\n    /* Set a timeout of 10ms. This is lower than recommended by the multi guide\n       but we're not going to any remote servers, so everything should complete\n       very quickly. */\n    timeout.tv_sec = 0;\n    timeout.tv_usec = 10000;\n\n    /* get file descriptors from the transfers */\n    mc = curl_multi_fdset(multi_handle, &fdread, &fdwrite, &fdexcep, &maxfd);\n    if(mc != CURLM_OK) {\n      fprintf(stderr, \"curl_multi_fdset() failed, code %d.\\n\", mc);\n      rc = -1;\n      break;\n    }\n\n    for(ii = 0; ii < FUZZ_NUM_CONNECTIONS; ii++) {\n      /* Add the socket FD into the readable set if connected. */\n      if(sman[ii]->fd_state == FUZZ_SOCK_OPEN) {\n        FD_SET(sman[ii]->fd, &fdread);\n\n        /* Work out the maximum FD between the cURL file descriptors and the\n           server FD. */\n        maxfd = FUZZ_MAX(sman[ii]->fd, maxfd);\n      }\n    }\n\n    /* Work out what file descriptors need work. */\n    rc = fuzz_select(maxfd + 1, &fdread, &fdwrite, &fdexcep, &timeout);\n\n    if(rc == -1) {\n      /* Had an issue while selecting a file descriptor. Let's just exit. */\n      FV_PRINTF(fuzz, \"FUZZ: select failed, exiting \\n\");\n      break;\n    }\n    else if(rc == 0) {\n      FV_PRINTF(fuzz,\n                \"FUZZ: Timed out; double timeout? %d \\n\",\n                double_timeout);\n\n      /* Timed out. */\n      if(double_timeout == 1) {\n        /* We don't expect multiple timeouts in a row. If there are double\n           timeouts then exit. */\n        break;\n      }\n      else {\n        /* Set the timeout flag for the next time we select(). */\n        double_timeout = 1;\n      }\n    }\n    else {\n      /* There's an active file descriptor. Reset the timeout flag. */\n      double_timeout = 0;\n    }\n\n    /* Check to see if a server file descriptor is readable. If it is,\n       then send the next response from the fuzzing data. */\n    for(ii = 0; ii < FUZZ_NUM_CONNECTIONS; ii++) {\n      if(sman[ii]->fd_state == FUZZ_SOCK_OPEN &&\n         FD_ISSET(sman[ii]->fd, &fdread)) {\n        rc = fuzz_send_next_response(fuzz, sman[ii]);\n        if(rc != 0) {\n          /* Failed to send a response. Break out here. */\n          break;\n        }\n      }\n    }\n\n    curl_multi_perform(multi_handle, &still_running);\n  }\n\n  /* Remove the easy handle from the multi stack. */\n  curl_multi_remove_handle(multi_handle, fuzz->easy);\n\n  /* Clean up the multi handle - the top level function will handle the easy\n     handle. */\n  curl_multi_cleanup(multi_handle);\n\n  return(rc);\n}\n\n\n// target function\nstatic void strcpy_url(char *output, const char *url, bool relative)\n{\n  /* we must add this with whitespace-replacing */\n  bool left = TRUE;\n  const unsigned char *iptr;\n  char *optr = output;\n  const unsigned char *host_sep = (const unsigned char *) url;\n\n  if(!relative)\n    host_sep = (const unsigned char *) find_host_sep(url);\n\n  for(iptr = (unsigned char *)url;    /* read from here */\n      *iptr;         /* until zero byte */\n      iptr++) {\n\n    if(iptr < host_sep) {\n      *optr++ = *iptr;\n      continue;\n    }\n\n    switch(*iptr) {\n    case '?':\n      left = FALSE;\n      /* fall through */\n    default:\n      if(!ISPRINT(*iptr)) {\n        snprintf(optr, 4, \"%%%02x\", *iptr);\n        optr += 3;\n      }\n      else\n        *optr++=*iptr;\n      break;\n    case ' ':\n      if(left) {\n        *optr++='%'; /* add a '%' */\n        *optr++='2'; /* add a '2' */\n        *optr++='0'; /* add a '0' */\n      }\n      else\n        *optr++='+'; /* add a '+' here */\n      break;\n    }\n  }\n  *optr = 0; /* zero terminate output buffer */\n\n}\n",
    "target": 1,
    "idx": 1007997,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic int\nsc_get_response(struct sc_card *card, struct sc_apdu *apdu, size_t olen)\n{\n\tstruct sc_context *ctx  = card->ctx;\n\tsize_t le, minlen, buflen;\n\tunsigned char *buf;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (apdu->le == 0) {\n\t\t/* no data is requested => change return value to 0x9000 and ignore the remaining data */\n\t\tapdu->sw1 = 0x90;\n\t\tapdu->sw2 = 0x00;\n\t\treturn SC_SUCCESS;\n\t}\n\n\t/* this should _never_ happen */\n\tif (!card->ops->get_response)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"no GET RESPONSE command\");\n\n\t/* call GET RESPONSE until we have read all data requested or until the card returns 0x9000,\n\t * whatever happens first. */\n\n\t/* if there are already data in response append a new data to the end of the buffer */\n\tbuf = apdu->resp + apdu->resplen;\n\n\t/* read as much data as fits in apdu->resp (i.e. min(apdu->resplen, amount of data available)). */\n\tbuflen = olen - apdu->resplen;\n\n\t/* 0x6100 means at least 256 more bytes to read */\n\tle = apdu->sw2 != 0 ? (size_t)apdu->sw2 : 256;\n\t/* we try to read at least as much as bytes as promised in the response bytes */\n\tminlen = le;\n\n\tdo {\n\t\tunsigned char resp[256];\n\t\tsize_t resp_len = le;\n\n\t\t/* call GET RESPONSE to get more date from the card;\n\t\t * note: GET RESPONSE returns the left amount of data (== SW2) */\n\t\tmemset(resp, 0, sizeof(resp));\n\t\trv = card->ops->get_response(card, &resp_len, resp);\n\t\tif (rv < 0)   {\n#ifdef ENABLE_SM\n\t\t\tif (resp_len)   {\n\t\t\t\tsc_log_hex(ctx, \"SM response data\", resp, resp_len);\n\t\t\t\tsc_sm_update_apdu_response(card, resp, resp_len, rv, apdu);\n\t\t\t}\n#endif\n\t\t\tLOG_TEST_RET(ctx, rv, \"GET RESPONSE error\");\n\t\t}\n\n\t\tle = resp_len;\n\t\t/* copy as much as will fit in requested buffer */\n\t\tif (buflen < le)\n\t\t\tle = buflen;\n\n\t\tmemcpy(buf, resp, le);\n\t\tbuf    += le;\n\t\tbuflen -= le;\n\n\t\t/* we have all the data the caller requested even if the card has more data */\n\t\tif (buflen == 0)\n\t\t\tbreak;\n\n\t\tminlen -= le;\n\t\tif (rv != 0)\n\t\t\tle = minlen = (size_t)rv;\n\t\telse\n\t\t\t/* if the card has returned 0x9000 but we still expect data ask for more\n\t\t\t * until we have read enough bytes */\n\t\t\tle = minlen;\n\t} while (rv != 0 && minlen != 0);\n\n\t/* we've read all data, let's return 0x9000 */\n\tapdu->resplen = buf - apdu->resp;\n\tapdu->sw1 = 0x90;\n\tapdu->sw2 = 0x00;\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n\nstatic int\nsc_transmit(sc_card_t *card, sc_apdu_t *apdu)\n{\n\tstruct sc_context *ctx  = card->ctx;\n\tsize_t       olen  = apdu->resplen;\n\tint          r;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tr = sc_single_transmit(card, apdu);\n\tLOG_TEST_RET(ctx, r, \"transmit APDU failed\");\n\n\t/* ok, the APDU was successfully transmitted. Now we have two special cases:\n\t * 1. the card returned 0x6Cxx: in this case APDU will be re-transmitted with Le set to SW2\n\t * (possible only if response buffer size is larger than new Le = SW2)\n\t */\n\tif (apdu->sw1 == 0x6C && (apdu->flags & SC_APDU_FLAGS_NO_RETRY_WL) == 0)\n\t\tr = sc_set_le_and_transmit(card, apdu, olen);\n\tLOG_TEST_RET(ctx, r, \"cannot re-transmit APDU \");\n\n\t/* 2. the card returned 0x61xx: more data can be read from the card\n\t *    using the GET RESPONSE command (mostly used in the T0 protocol).\n\t *    Unless the SC_APDU_FLAGS_NO_GET_RESP is set we try to read as\n\t *    much data as possible using GET RESPONSE.\n\t */\n\tif (apdu->sw1 == 0x61 && (apdu->flags & SC_APDU_FLAGS_NO_GET_RESP) == 0)\n\t\tr = sc_get_response(card, apdu, olen);\n\tLOG_TEST_RET(ctx, r, \"cannot get all data with 'GET RESPONSE'\");\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n\nint sc_transmit_apdu(sc_card_t *card, sc_apdu_t *apdu)\n{\n\tint r = SC_SUCCESS;\n\n\tif (card == NULL || apdu == NULL)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\t/* determine the APDU type if necessary, i.e. to use\n\t * short or extended APDUs  */\n\tsc_detect_apdu_cse(card, apdu);\n\t/* basic APDU consistency check */\n\tr = sc_check_apdu(card, apdu);\n\tif (r != SC_SUCCESS)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\tr = sc_lock(card);\t/* acquire card lock*/\n\tif (r != SC_SUCCESS) {\n\t\tsc_log(card->ctx, \"unable to acquire lock\");\n\t\treturn r;\n\t}\n\n\tif ((apdu->flags & SC_APDU_FLAGS_CHAINING) != 0) {\n\t\t/* divide et impera: transmit APDU in chunks with Lc <= max_send_size\n\t\t * bytes using command chaining */\n\t\tsize_t    len  = apdu->datalen;\n\t\tconst u8  *buf = apdu->data;\n\t\tsize_t    max_send_size = sc_get_max_send_size(card);\n\n\t\twhile (len != 0) {\n\t\t\tsize_t    plen;\n\t\t\tsc_apdu_t tapdu;\n\t\t\tint       last = 0;\n\n\t\t\ttapdu = *apdu;\n\t\t\t/* clear chaining flag */\n\t\t\ttapdu.flags &= ~SC_APDU_FLAGS_CHAINING;\n\t\t\tif (len > max_send_size) {\n\t\t\t\t/* adjust APDU case: in case of CASE 4 APDU\n\t\t\t\t * the intermediate APDU are of CASE 3 */\n\t\t\t\tif ((tapdu.cse & SC_APDU_SHORT_MASK) == SC_APDU_CASE_4_SHORT)\n\t\t\t\t\ttapdu.cse--;\n\t\t\t\t/* XXX: the chunk size must be adjusted when\n\t\t\t\t *      secure messaging is used */\n\t\t\t\tplen          = max_send_size;\n\t\t\t\ttapdu.cla    |= 0x10;\n\t\t\t\ttapdu.le      = 0;\n\t\t\t\t/* the intermediate APDU don't expect data */\n\t\t\t\ttapdu.lc      = 0;\n\t\t\t\ttapdu.resplen = 0;\n\t\t\t\ttapdu.resp    = NULL;\n\t\t\t} else {\n\t\t\t\tplen = len;\n\t\t\t\tlast = 1;\n\t\t\t}\n\t\t\ttapdu.data    = buf;\n\t\t\ttapdu.datalen = tapdu.lc = plen;\n\n\t\t\tr = sc_check_apdu(card, &tapdu);\n\t\t\tif (r != SC_SUCCESS) {\n\t\t\t\tsc_log(card->ctx, \"inconsistent APDU while chaining\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tr = sc_transmit(card, &tapdu);\n\t\t\tif (r != SC_SUCCESS)\n\t\t\t\tbreak;\n\t\t\tif (last != 0) {\n\t\t\t\t/* in case of the last APDU set the SW1\n\t\t\t\t * and SW2 bytes in the original APDU */\n\t\t\t\tapdu->sw1 = tapdu.sw1;\n\t\t\t\tapdu->sw2 = tapdu.sw2;\n\t\t\t\tapdu->resplen = tapdu.resplen;\n\t\t\t} else {\n\t\t\t\t/* otherwise check the status bytes */\n\t\t\t\tr = sc_check_sw(card, tapdu.sw1, tapdu.sw2);\n\t\t\t\tif (r != SC_SUCCESS)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlen -= plen;\n\t\t\tbuf += plen;\n\t\t}\n\t} else {\n\t\t/* transmit single APDU */\n\t\tr = sc_transmit(card, apdu);\n\t}\n\n\tif (r == SC_ERROR_CARD_RESET || r == SC_ERROR_READER_REATTACHED) {\n\t\tsc_invalidate_cache(card);\n\t\t/* give card driver a chance to react on resets */\n\t\tif (card->ops->card_reader_lock_obtained)\n\t\t\tcard->ops->card_reader_lock_obtained(card, 1);\n\t}\n\n\t/* all done => release lock */\n\tif (sc_unlock(card) != SC_SUCCESS)\n\t\tsc_log(card->ctx, \"sc_unlock failed\");\n\n\treturn r;\n}\n\nstatic int\niso7816_read_binary(struct sc_card *card, unsigned int idx, u8 *buf, size_t count, unsigned long flags)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_apdu apdu;\n\tint r;\n\n\tif (idx > 0x7FFF) {\n\t\tsc_log(ctx, \"invalid EF offset: 0x%X > 0x7FFF\", idx);\n\t\treturn SC_ERROR_OFFSET_TOO_LARGE;\n\t}\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_2, 0xB0, (idx >> 8) & 0x7F, idx & 0xFF);\n\tapdu.le = count;\n\tapdu.resplen = count;\n\tapdu.resp = buf;\n\n\tfixup_transceive_length(card, &apdu);\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(ctx, r, \"APDU transmit failed\");\n\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tif (r == SC_ERROR_FILE_END_REACHED)\n\t\tLOG_FUNC_RETURN(ctx, apdu.resplen);\n\tLOG_TEST_RET(ctx, r, \"Check SW error\");\n\n\tLOG_FUNC_RETURN(ctx, apdu.resplen);\n}\n\nstatic int idprime_read_binary(sc_card_t *card, unsigned int offset,\n\tunsigned char *buf, size_t count, unsigned long flags)\n{\n\tstruct idprime_private_data *priv = card->drv_data;\n\tint r = 0;\n\tint size;\n\n\tsc_log(card->ctx, \"called; %\"SC_FORMAT_LEN_SIZE_T\"u bytes at offset %d\",\n\t\tcount, offset);\n\n\tif (!priv->cached && offset == 0) {\n\t\t/* Read what was reported by FCI from select command */\n\t\tint left = priv->file_size;\n\t\tsize_t read = 0;\n\n\t\t// this function is called to read and uncompress the certificate\n\t\tu8 buffer[SC_MAX_EXT_APDU_BUFFER_SIZE];\n\t\tif (sizeof(buffer) < count) {\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INTERNAL);\n\t\t}\n\t\twhile (left > 0) {\n\t\t\tr = iso_ops->read_binary(card, read, buffer + read, priv->file_size - read, flags);\n\t\t\tif (r <= 0) {\n\t\t\t\tLOG_FUNC_RETURN(card->ctx, r);\n\t\t\t}\n\t\t\tleft -= r;\n\t\t\tread += r;\n\t\t}\n\t\tif (read < 4 || read != priv->file_size) {\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_DATA);\n\t\t}\n\t\tif (buffer[0] == 1 && buffer[1] == 0) {\n#ifdef ENABLE_ZLIB\n\t\t\tsize_t expectedsize = buffer[2] + buffer[3] * 0x100;\n\t\t\tr = sc_decompress_alloc(&priv->cache_buf, &(priv->cache_buf_len),\n\t\t\t\tbuffer+4, priv->file_size-4, COMPRESSION_AUTO);\n\t\t\tif (r != SC_SUCCESS) {\n\t\t\t\tsc_log(card->ctx, \"Zlib error: %d\", r);\n\t\t\t\tLOG_FUNC_RETURN(card->ctx, r);\n\t\t\t}\n\t\t\tif (priv->cache_buf_len != expectedsize) {\n\t\t\t\tsc_log(card->ctx,\n\t\t\t\t\t \"expected size: %\"SC_FORMAT_LEN_SIZE_T\"u real size: %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t\t\t\t expectedsize, priv->cache_buf_len);\n\t\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_DATA);\n\t\t\t}\n#else\n\t\t\tsc_log(card->ctx, \"compression not supported, no zlib\");\n\t\t\treturn SC_ERROR_NOT_SUPPORTED;\n#endif /* ENABLE_ZLIB */\n\t\t} else {\n\t\t\t/* assuming uncompressed certificate */\n\t\t\tpriv->cache_buf = malloc(r);\n\t\t\tif (priv->cache_buf == NULL) {\n\t\t\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t\t\t}\n\t\t\tmemcpy(priv->cache_buf, buffer, r);\n\t\t\tpriv->cache_buf_len = r;\n\t\t}\n\t\tpriv->cached = 1;\n\t}\n\tif (offset >= priv->cache_buf_len) {\n\t\treturn 0;\n\t}\n\tsize = (int) MIN((priv->cache_buf_len - offset), count);\n\tmemcpy(buf, priv->cache_buf + offset, size);\n\treturn size;\n}\n\nint sc_read_binary(sc_card_t *card, unsigned int idx,\n\t\t   unsigned char *buf, size_t count, unsigned long flags)\n{\n\tsize_t max_le = sc_get_max_recv_size(card);\n\tsize_t todo = count;\n\tint r;\n\n\tif (card == NULL || card->ops == NULL || buf == NULL) {\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\tsc_log(card->ctx, \"called; %\"SC_FORMAT_LEN_SIZE_T\"u bytes at index %d\",\n\t       count, idx);\n\tif (count == 0)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n\n#ifdef ENABLE_SM\n\tif (card->sm_ctx.ops.read_binary)   {\n\t\tr = card->sm_ctx.ops.read_binary(card, idx, buf, count);\n\t\tif (r)\n\t\t\tLOG_FUNC_RETURN(card->ctx, r);\n\t}\n#endif\n\n\tif (card->ops->read_binary == NULL)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_NOT_SUPPORTED);\n\n\t/* lock the card now to avoid deselection of the file */\n\tr = sc_lock(card);\n\tLOG_TEST_RET(card->ctx, r, \"sc_lock() failed\");\n\n\twhile (todo > 0) {\n\t\tsize_t chunk = todo > max_le ? max_le : todo;\n\n\t\tr = card->ops->read_binary(card, idx, buf, chunk, flags);\n\t\tif (r == 0 || r == SC_ERROR_FILE_END_REACHED)\n\t\t\tbreak;\n\t\tif ((idx > SIZE_MAX - (size_t) r)\n\t\t\t\t|| (size_t) r > todo) {\n\t\t\t/* `idx + r` or `todo - r` would overflow */\n\t\t\tr = SC_ERROR_OFFSET_TOO_LARGE;\n\t\t}\n\t\tif (r < 0) {\n\t\t\tsc_unlock(card);\n\t\t\tLOG_FUNC_RETURN(card->ctx, r);\n\t\t}\n\n\t\ttodo -= (size_t) r;\n\t\tbuf  += (size_t) r;\n\t\tidx  += (size_t) r;\n\t}\n\n\tsc_unlock(card);\n\n\tLOG_FUNC_RETURN(card->ctx, count - todo);\n}\n\nint\nsc_pkcs15_bind(struct sc_card *card, struct sc_aid *aid,\n\t\tstruct sc_pkcs15_card **p15card_out)\n{\n\tstruct sc_pkcs15_card *p15card = NULL;\n\tstruct sc_context *ctx;\n\tscconf_block *conf_block = NULL;\n\tint r, emu_first, enable_emu;\n\tconst char *private_certificate;\n\n\tif (card == NULL || p15card_out == NULL) {\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\tctx = card->ctx;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"application(aid:'%s')\", aid ? sc_dump_hex(aid->value, aid->len) : \"empty\");\n\n\tp15card = sc_pkcs15_card_new();\n\tif (p15card == NULL)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY);\n\n\tp15card->card = card;\n\tp15card->opts.use_file_cache = 0;\n\tp15card->opts.use_pin_cache = 1;\n\tp15card->opts.pin_cache_counter = 10;\n\tp15card->opts.pin_cache_ignore_user_consent = 0;\n\tif(0 == strcmp(ctx->app_name, \"tokend\")) {\n\t\tprivate_certificate = \"ignore\";\n\t\tp15card->opts.private_certificate = SC_PKCS15_CARD_OPTS_PRIV_CERT_IGNORE;\n\t} else {\n\t\tprivate_certificate = \"protect\";\n\t\tp15card->opts.private_certificate = SC_PKCS15_CARD_OPTS_PRIV_CERT_PROTECT;\n\t}\n\n\tconf_block = sc_get_conf_block(ctx, \"framework\", \"pkcs15\", 1);\n\tif (conf_block) {\n\t\tp15card->opts.use_file_cache = scconf_get_bool(conf_block, \"use_file_caching\", p15card->opts.use_file_cache);\n\t\tp15card->opts.use_pin_cache = scconf_get_bool(conf_block, \"use_pin_caching\", p15card->opts.use_pin_cache);\n\t\tp15card->opts.pin_cache_counter = scconf_get_int(conf_block, \"pin_cache_counter\", p15card->opts.pin_cache_counter);\n\t\tp15card->opts.pin_cache_ignore_user_consent = scconf_get_bool(conf_block, \"pin_cache_ignore_user_consent\",\n\t\t\t\tp15card->opts.pin_cache_ignore_user_consent);\n\t\tprivate_certificate = scconf_get_str(conf_block, \"private_certificate\", private_certificate);\n\t}\n\tif (0 == strcmp(private_certificate, \"protect\")) {\n\t\tp15card->opts.private_certificate = SC_PKCS15_CARD_OPTS_PRIV_CERT_PROTECT;\n\t} else if (0 == strcmp(private_certificate, \"ignore\")) {\n\t\tp15card->opts.private_certificate = SC_PKCS15_CARD_OPTS_PRIV_CERT_IGNORE;\n\t} else if (0 == strcmp(private_certificate, \"declassify\")) {\n\t\tp15card->opts.private_certificate = SC_PKCS15_CARD_OPTS_PRIV_CERT_DECLASSIFY;\n\t}\n\tsc_log(ctx, \"PKCS#15 options: use_file_cache=%d use_pin_cache=%d pin_cache_counter=%d pin_cache_ignore_user_consent=%d private_certificate=%d\",\n\t\t\tp15card->opts.use_file_cache, p15card->opts.use_pin_cache,p15card->opts.pin_cache_counter,\n\t\t\tp15card->opts.pin_cache_ignore_user_consent, p15card->opts.private_certificate);\n\n\tr = sc_lock(card);\n\tif (r) {\n\t\tsc_log(ctx, \"sc_lock() failed: %s\", sc_strerror(r));\n\t\tsc_pkcs15_card_free(p15card);\n\t\tLOG_FUNC_RETURN(ctx, r);\n\t}\n\n\tenable_emu = scconf_get_bool(conf_block, \"enable_pkcs15_emulation\", 1);\n\tif (enable_emu) {\n\t\tsc_log(ctx, \"PKCS#15 emulation enabled\");\n\t\temu_first = scconf_get_bool(conf_block, \"try_emulation_first\", 0);\n\t\tif (emu_first || sc_pkcs15_is_emulation_only(card)) {\n\t\t\tr = sc_pkcs15_bind_synthetic(p15card, aid);\n\t\t\tif (r == SC_SUCCESS)\n\t\t\t\tgoto done;\n\t\t\tr = sc_pkcs15_bind_internal(p15card, aid);\n\t\t\tif (r < 0)\n\t\t\t\tgoto error;\n\t\t} else {\n\t\t\tr = sc_pkcs15_bind_internal(p15card, aid);\n\t\t\tif (r == SC_SUCCESS)\n\t\t\t\tgoto done;\n\t\t\tr = sc_pkcs15_bind_synthetic(p15card, aid);\n\t\t\tif (r < 0)\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\telse {\n\t\tr = sc_pkcs15_bind_internal(p15card, aid);\n\t\tif (r < 0)\n\t\t\tgoto error;\n\t}\ndone:\n\t*p15card_out = p15card;\n\tsc_unlock(card);\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\nerror:\n\tsc_unlock(card);\n\tsc_pkcs15_card_free(p15card);\n\tLOG_FUNC_RETURN(ctx, r);\n}\n\nint\nsc_pkcs15_bind(struct sc_card *card, struct sc_aid *aid,\n\t\tstruct sc_pkcs15_card **p15card_out)\n{\n\tstruct sc_pkcs15_card *p15card = NULL;\n\tstruct sc_context *ctx;\n\tscconf_block *conf_block = NULL;\n\tint r, emu_first, enable_emu;\n\tconst char *private_certificate;\n\n\tif (card == NULL || p15card_out == NULL) {\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\tctx = card->ctx;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"application(aid:'%s')\", aid ? sc_dump_hex(aid->value, aid->len) : \"empty\");\n\n\tp15card = sc_pkcs15_card_new();\n\tif (p15card == NULL)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY);\n\n\tp15card->card = card;\n\tp15card->opts.use_file_cache = 0;\n\tp15card->opts.use_pin_cache = 1;\n\tp15card->opts.pin_cache_counter = 10;\n\tp15card->opts.pin_cache_ignore_user_consent = 0;\n\tif(0 == strcmp(ctx->app_name, \"tokend\")) {\n\t\tprivate_certificate = \"ignore\";\n\t\tp15card->opts.private_certificate = SC_PKCS15_CARD_OPTS_PRIV_CERT_IGNORE;\n\t} else {\n\t\tprivate_certificate = \"protect\";\n\t\tp15card->opts.private_certificate = SC_PKCS15_CARD_OPTS_PRIV_CERT_PROTECT;\n\t}\n\n\tconf_block = sc_get_conf_block(ctx, \"framework\", \"pkcs15\", 1);\n\tif (conf_block) {\n\t\tp15card->opts.use_file_cache = scconf_get_bool(conf_block, \"use_file_caching\", p15card->opts.use_file_cache);\n\t\tp15card->opts.use_pin_cache = scconf_get_bool(conf_block, \"use_pin_caching\", p15card->opts.use_pin_cache);\n\t\tp15card->opts.pin_cache_counter = scconf_get_int(conf_block, \"pin_cache_counter\", p15card->opts.pin_cache_counter);\n\t\tp15card->opts.pin_cache_ignore_user_consent = scconf_get_bool(conf_block, \"pin_cache_ignore_user_consent\",\n\t\t\t\tp15card->opts.pin_cache_ignore_user_consent);\n\t\tprivate_certificate = scconf_get_str(conf_block, \"private_certificate\", private_certificate);\n\t}\n\tif (0 == strcmp(private_certificate, \"protect\")) {\n\t\tp15card->opts.private_certificate = SC_PKCS15_CARD_OPTS_PRIV_CERT_PROTECT;\n\t} else if (0 == strcmp(private_certificate, \"ignore\")) {\n\t\tp15card->opts.private_certificate = SC_PKCS15_CARD_OPTS_PRIV_CERT_IGNORE;\n\t} else if (0 == strcmp(private_certificate, \"declassify\")) {\n\t\tp15card->opts.private_certificate = SC_PKCS15_CARD_OPTS_PRIV_CERT_DECLASSIFY;\n\t}\n\tsc_log(ctx, \"PKCS#15 options: use_file_cache=%d use_pin_cache=%d pin_cache_counter=%d pin_cache_ignore_user_consent=%d private_certificate=%d\",\n\t\t\tp15card->opts.use_file_cache, p15card->opts.use_pin_cache,p15card->opts.pin_cache_counter,\n\t\t\tp15card->opts.pin_cache_ignore_user_consent, p15card->opts.private_certificate);\n\n\tr = sc_lock(card);\n\tif (r) {\n\t\tsc_log(ctx, \"sc_lock() failed: %s\", sc_strerror(r));\n\t\tsc_pkcs15_card_free(p15card);\n\t\tLOG_FUNC_RETURN(ctx, r);\n\t}\n\n\tenable_emu = scconf_get_bool(conf_block, \"enable_pkcs15_emulation\", 1);\n\tif (enable_emu) {\n\t\tsc_log(ctx, \"PKCS#15 emulation enabled\");\n\t\temu_first = scconf_get_bool(conf_block, \"try_emulation_first\", 0);\n\t\tif (emu_first || sc_pkcs15_is_emulation_only(card)) {\n\t\t\tr = sc_pkcs15_bind_synthetic(p15card, aid);\n\t\t\tif (r == SC_SUCCESS)\n\t\t\t\tgoto done;\n\t\t\tr = sc_pkcs15_bind_internal(p15card, aid);\n\t\t\tif (r < 0)\n\t\t\t\tgoto error;\n\t\t} else {\n\t\t\tr = sc_pkcs15_bind_internal(p15card, aid);\n\t\t\tif (r == SC_SUCCESS)\n\t\t\t\tgoto done;\n\t\t\tr = sc_pkcs15_bind_synthetic(p15card, aid);\n\t\t\tif (r < 0)\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\telse {\n\t\tr = sc_pkcs15_bind_internal(p15card, aid);\n\t\tif (r < 0)\n\t\t\tgoto error;\n\t}\ndone:\n\t*p15card_out = p15card;\n\tsc_unlock(card);\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\nerror:\n\tsc_unlock(card);\n\tsc_pkcs15_card_free(p15card);\n\tLOG_FUNC_RETURN(ctx, r);\n}\n\n\n// target function\nstatic int idprime_read_binary(sc_card_t *card, unsigned int offset,\n\tunsigned char *buf, size_t count, unsigned long flags)\n{\n\tstruct idprime_private_data *priv = card->drv_data;\n\tint r;\n\tint size;\n\n\tsc_log(card->ctx, \"called; %\"SC_FORMAT_LEN_SIZE_T\"u bytes at offset %d\",\n\t\tcount, offset);\n\n\tif (!priv->cached && offset == 0) {\n\t\t// this function is called to read and uncompress the certificate\n\t\tu8 buffer[SC_MAX_EXT_APDU_BUFFER_SIZE];\n\t\tif (sizeof(buffer) < count) {\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INTERNAL);\n\t\t}\n\t\t/* Read what was reported by FCI from select command */\n\t\tr = iso_ops->read_binary(card, 0, buffer, priv->file_size, flags);\n\t\tif (r < 0) {\n\t\t\tLOG_FUNC_RETURN(card->ctx, r);\n\t\t}\n\t\tif (r < 4) {\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_DATA);\n\t\t}\n\t\tif (buffer[0] == 1 && buffer[1] == 0) {\n#ifdef ENABLE_ZLIB\n\t\t\tsize_t expectedsize = buffer[2] + buffer[3] * 0x100;\n\t\t\tr = sc_decompress_alloc(&priv->cache_buf, &(priv->cache_buf_len),\n\t\t\t\tbuffer+4, priv->file_size-4, COMPRESSION_AUTO);\n\t\t\tif (r != SC_SUCCESS) {\n\t\t\t\tsc_log(card->ctx, \"Zlib error: %d\", r);\n\t\t\t\tLOG_FUNC_RETURN(card->ctx, r);\n\t\t\t}\n\t\t\tif (priv->cache_buf_len != expectedsize) {\n\t\t\t\tsc_log(card->ctx,\n\t\t\t\t\t \"expected size: %\"SC_FORMAT_LEN_SIZE_T\"u real size: %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t\t\t\t expectedsize, priv->cache_buf_len);\n\t\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_DATA);\n\t\t\t}\n#else\n\t\t\tsc_log(card->ctx, \"compression not supported, no zlib\");\n\t\t\treturn SC_ERROR_NOT_SUPPORTED;\n#endif /* ENABLE_ZLIB */\n\t\t} else {\n\t\t\t/* assuming uncompressed certificate */\n\t\t\tpriv->cache_buf = malloc(r);\n\t\t\tif (priv->cache_buf == NULL) {\n\t\t\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t\t\t}\n\t\t\tmemcpy(priv->cache_buf, buffer, r);\n\t\t\tpriv->cache_buf_len = r;\n\t\t}\n\t\tpriv->cached = 1;\n\t}\n\tif (offset >= priv->cache_buf_len) {\n\t\treturn 0;\n\t}\n\tsize = (int) MIN((priv->cache_buf_len - offset), count);\n\tmemcpy(buf, priv->cache_buf + offset, size);\n\treturn size;\n}\n",
    "target": 1,
    "idx": 1025998,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\n\n\n\n\nstatic Int decCompare(const decNumber *lhs, const decNumber *rhs,\n                      Flag abs) {\n  Int   result;                    // result value\n  Int   sigr;                      // rhs signum\n  Int   compare;                   // work\n\n  result=1;                                  // assume signum(lhs)\n  if (ISZERO(lhs)) result=0;\n  if (abs) {\n    if (ISZERO(rhs)) return result;          // LHS wins or both 0\n    // RHS is non-zero\n    if (result==0) return -1;                // LHS is 0; RHS wins\n    // [here, both non-zero, result=1]\n    }\n   else {                                    // signs matter\n    if (result && decNumberIsNegative(lhs)) result=-1;\n    sigr=1;                                  // compute signum(rhs)\n    if (ISZERO(rhs)) sigr=0;\n     else if (decNumberIsNegative(rhs)) sigr=-1;\n    if (result > sigr) return +1;            // L > R, return 1\n    if (result < sigr) return -1;            // L < R, return -1\n    if (result==0) return 0;                   // both 0\n    }\n\n  // signums are the same; both are non-zero\n  if ((lhs->bits | rhs->bits) & DECINF) {    // one or more infinities\n    if (decNumberIsInfinite(rhs)) {\n      if (decNumberIsInfinite(lhs)) result=0;// both infinite\n       else result=-result;                  // only rhs infinite\n      }\n    return result;\n    }\n  // must compare the coefficients, allowing for exponents\n  if (lhs->exponent>rhs->exponent) {         // LHS exponent larger\n    // swap sides, and sign\n    const decNumber *temp=lhs;\n    lhs=rhs;\n    rhs=temp;\n    result=-result;\n    }\n  compare=decUnitCompare(lhs->lsu, D2U(lhs->digits),\n                         rhs->lsu, D2U(rhs->digits),\n                         rhs->exponent-lhs->exponent);\n  if (compare!=BADINT) compare*=result;      // comparison succeeded\n  return compare;\n  } // decCompare\n\n\n\nint jvp_number_cmp(jv a, jv b) {\n  assert(JVP_HAS_KIND(a, JV_KIND_NUMBER));\n  assert(JVP_HAS_KIND(b, JV_KIND_NUMBER));\n\n#ifdef USE_DECNUM\n  if (JVP_HAS_FLAGS(a, JVP_FLAGS_NUMBER_LITERAL) && JVP_HAS_FLAGS(b, JVP_FLAGS_NUMBER_LITERAL)) {\n    struct {\n      decNumber number;\n      decNumberUnit units[1];\n    } res;\n\n    decNumberCompare(&res.number,\n                     jvp_dec_number_ptr(a),\n                     jvp_dec_number_ptr(b),\n                     DEC_CONTEXT()\n                     );\n    if (decNumberIsZero(&res.number)) {\n      return 0;\n    } else if (decNumberIsNegative(&res.number)) {\n      return -1;\n    } else {\n      return 1;\n    }\n  }\n#endif\n  double da = jv_number_value(a), db = jv_number_value(b);\n  if (da < db) {\n    return -1;\n  } else if (da == db) {\n    return 0;\n  } else {\n    return 1;\n  }\n}\n\nstatic int jvp_number_equal(jv a, jv b) {\n  return jvp_number_cmp(a, b) == 0;\n}\n\nint jv_equal(jv a, jv b) {\n  int r;\n  if (jv_get_kind(a) != jv_get_kind(b)) {\n    r = 0;\n  } else if (JVP_IS_ALLOCATED(a) &&\n             JVP_IS_ALLOCATED(b) &&\n             a.kind_flags == b.kind_flags &&\n             a.size == b.size &&\n             a.u.ptr == b.u.ptr) {\n    r = 1;\n  } else {\n    switch (jv_get_kind(a)) {\n    case JV_KIND_NUMBER:\n      r = jvp_number_equal(a, b);\n      break;\n    case JV_KIND_ARRAY:\n      r = jvp_array_equal(a, b);\n      break;\n    case JV_KIND_STRING:\n      r = jvp_string_equal(a, b);\n      break;\n    case JV_KIND_OBJECT:\n      r = jvp_object_equal(a, b);\n      break;\n    default:\n      r = 1;\n      break;\n    }\n  }\n  jv_free(a);\n  jv_free(b);\n  return r;\n}\n\njv binop_notequal(jv a, jv b) {\n  return jv_bool(!jv_equal(a, b));\n}\n\n\n\njv jq_next(jq_state *jq) {\n  jv cfunc_input[MAX_CFUNCTION_ARGS];\n\n  jv_nomem_handler(jq->nomem_handler, jq->nomem_handler_data);\n\n  uint16_t* pc = stack_restore(jq);\n  assert(pc);\n\n  int raising;\n  int backtracking = !jq->initial_execution;\n\n  jq->initial_execution = 0;\n  assert(jv_get_kind(jq->error) == JV_KIND_NULL);\n  while (1) {\n    if (jq->halted) {\n      if (jq->debug_trace_enabled)\n        printf(\"\\t<halted>\\n\");\n      return jv_invalid();\n    }\n    uint16_t opcode = *pc;\n    raising = 0;\n\n    if (jq->debug_trace_enabled) {\n      dump_operation(frame_current(jq)->bc, pc);\n      printf(\"\\t\");\n      const struct opcode_description* opdesc = opcode_describe(opcode);\n      stack_ptr param = 0;\n      if (!backtracking) {\n        int stack_in = opdesc->stack_in;\n        if (stack_in == -1) stack_in = pc[1];\n        param = jq->stk_top;\n        for (int i=0; i<stack_in; i++) {\n          if (i != 0) {\n            printf(\" | \");\n            param = *stack_block_next(&jq->stk, param);\n          }\n          if (!param) break;\n          jv_dump(jv_copy(*(jv*)stack_block(&jq->stk, param)), JV_PRINT_REFCOUNT);\n          //printf(\"<%d>\", jv_get_refcnt(param->val));\n          //printf(\" -- \");\n          //jv_dump(jv_copy(jq->path), 0);\n        }\n        if (jq->debug_trace_enabled & JQ_DEBUG_TRACE_DETAIL) {\n          while ((param = *stack_block_next(&jq->stk, param))) {\n            printf(\" || \");\n            jv_dump(jv_copy(*(jv*)stack_block(&jq->stk, param)), JV_PRINT_REFCOUNT);\n          }\n        }\n      } else {\n        printf(\"\\t<backtracking>\");\n      }\n\n      printf(\"\\n\");\n    }\n\n    if (backtracking) {\n      opcode = ON_BACKTRACK(opcode);\n      backtracking = 0;\n      raising = !jv_is_valid(jq->error);\n    }\n    pc++;\n\n    switch (opcode) {\n    default: assert(0 && \"invalid instruction\");\n\n    case TOP: break;\n\n    case ERRORK: {\n      jv v = jv_array_get(jv_copy(frame_current(jq)->bc->constants), *pc++);\n      set_error(jq, jv_invalid_with_msg(v));\n      goto do_backtrack;\n    }\n\n    case LOADK: {\n      jv v = jv_array_get(jv_copy(frame_current(jq)->bc->constants), *pc++);\n      assert(jv_is_valid(v));\n      jv_free(stack_pop(jq));\n      stack_push(jq, v);\n      break;\n    }\n\n    case GENLABEL: {\n      stack_push(jq, JV_OBJECT(jv_string(\"__jq\"), jv_number(jq->next_label++)));\n      break;\n    }\n\n    case DUP: {\n      jv v = stack_pop(jq);\n      stack_push(jq, jv_copy(v));\n      stack_push(jq, v);\n      break;\n    }\n\n    case DUPN: {\n      jv v = stack_popn(jq);\n      stack_push(jq, jv_copy(v));\n      stack_push(jq, v);\n      break;\n    }\n\n    case DUP2: {\n      jv keep = stack_pop(jq);\n      jv v = stack_pop(jq);\n      stack_push(jq, jv_copy(v));\n      stack_push(jq, keep);\n      stack_push(jq, v);\n      break;\n    }\n\n    case SUBEXP_BEGIN: {\n      jv v = stack_pop(jq);\n      stack_push(jq, jv_copy(v));\n      stack_push(jq, v);\n      jq->subexp_nest++;\n      break;\n    }\n\n    case SUBEXP_END: {\n      assert(jq->subexp_nest > 0);\n      jq->subexp_nest--;\n      jv a = stack_pop(jq);\n      jv b = stack_pop(jq);\n      stack_push(jq, a);\n      stack_push(jq, b);\n      break;\n    }\n\n    case PUSHK_UNDER: {\n      jv v = jv_array_get(jv_copy(frame_current(jq)->bc->constants), *pc++);\n      assert(jv_is_valid(v));\n      jv v2 = stack_pop(jq);\n      stack_push(jq, v);\n      stack_push(jq, v2);\n      break;\n    }\n\n    case POP: {\n      jv_free(stack_pop(jq));\n      break;\n    }\n\n    case APPEND: {\n      jv v = stack_pop(jq);\n      uint16_t level = *pc++;\n      uint16_t vidx = *pc++;\n      jv* var = frame_local_var(jq, vidx, level);\n      assert(jv_get_kind(*var) == JV_KIND_ARRAY);\n      *var = jv_array_append(*var, v);\n      break;\n    }\n\n    case INSERT: {\n      jv stktop = stack_pop(jq);\n      jv v = stack_pop(jq);\n      jv k = stack_pop(jq);\n      jv objv = stack_pop(jq);\n      assert(jv_get_kind(objv) == JV_KIND_OBJECT);\n      if (jv_get_kind(k) == JV_KIND_STRING) {\n        stack_push(jq, jv_object_set(objv, k, v));\n        stack_push(jq, stktop);\n      } else {\n        char errbuf[15];\n        set_error(jq, jv_invalid_with_msg(jv_string_fmt(\"Cannot use %s (%s) as object key\",\n                                                        jv_kind_name(jv_get_kind(k)),\n                                                        jv_dump_string_trunc(jv_copy(k), errbuf, sizeof(errbuf)))));\n        jv_free(stktop);\n        jv_free(v);\n        jv_free(k);\n        jv_free(objv);\n        goto do_backtrack;\n      }\n      break;\n    }\n\n    case ON_BACKTRACK(RANGE):\n    case RANGE: {\n      uint16_t level = *pc++;\n      uint16_t v = *pc++;\n      jv* var = frame_local_var(jq, v, level);\n      jv max = stack_pop(jq);\n      if (raising) {\n        jv_free(max);\n        goto do_backtrack;\n      } \n      if (jv_get_kind(*var) != JV_KIND_NUMBER ||\n          jv_get_kind(max) != JV_KIND_NUMBER) {\n        set_error(jq, jv_invalid_with_msg(jv_string_fmt(\"Range bounds must be numeric\")));\n        jv_free(max);\n        goto do_backtrack;\n      } else if (jv_number_value(*var) >= jv_number_value(max)) {\n        /* finished iterating */\n        jv_free(max);\n        goto do_backtrack;\n      } else {\n        jv curr = *var;\n        *var = jv_number(jv_number_value(*var) + 1);\n\n        struct stack_pos spos = stack_get_pos(jq);\n        stack_push(jq, max);\n        stack_save(jq, pc - 3, spos);\n\n        stack_push(jq, curr);\n      }\n      break;\n    }\n\n      // FIXME: loadv/storev may do too much copying/freeing\n    case LOADV: {\n      uint16_t level = *pc++;\n      uint16_t v = *pc++;\n      jv* var = frame_local_var(jq, v, level);\n      if (jq->debug_trace_enabled) {\n        printf(\"V%d = \", v);\n        jv_dump(jv_copy(*var), JV_PRINT_REFCOUNT);\n        printf(\"\\n\");\n      }\n      jv_free(stack_pop(jq));\n      stack_push(jq, jv_copy(*var));\n      break;\n    }\n\n      // Does a load but replaces the variable with null\n    case LOADVN: {\n      uint16_t level = *pc++;\n      uint16_t v = *pc++;\n      jv* var = frame_local_var(jq, v, level);\n      if (jq->debug_trace_enabled) {\n        printf(\"V%d = \", v);\n        jv_dump(jv_copy(*var), JV_PRINT_REFCOUNT);\n        printf(\"\\n\");\n      }\n      jv_free(stack_popn(jq));\n\n      // This `stack_push()` invalidates the `var` reference, so\n      stack_push(jq, *var);\n      // we have to re-resolve `var` before we can set it to null\n      var = frame_local_var(jq, v, level);\n      *var = jv_null();\n      break;\n    }\n\n    case STOREVN:\n        stack_save(jq, pc - 1, stack_get_pos(jq));\n        JQ_FALLTHROUGH;\n    case STOREV: {\n      uint16_t level = *pc++;\n      uint16_t v = *pc++;\n      jv* var = frame_local_var(jq, v, level);\n      jv val = stack_pop(jq);\n      if (jq->debug_trace_enabled) {\n        printf(\"V%d = \", v);\n        jv_dump(jv_copy(val), 0);\n        printf(\" (%d)\\n\", jv_get_refcnt(val));\n      }\n      jv_free(*var);\n      *var = val;\n      break;\n    }\n\n    case ON_BACKTRACK(STOREVN): {\n      uint16_t level = *pc++;\n      uint16_t v = *pc++;\n      jv* var = frame_local_var(jq, v, level);\n      jv_free(*var);\n      *var = jv_null();\n      goto do_backtrack;\n      break;\n    }\n\n    case STORE_GLOBAL: {\n      // Get the constant\n      jv val = jv_array_get(jv_copy(frame_current(jq)->bc->constants), *pc++);\n      assert(jv_is_valid(val));\n\n      // Store the var\n      uint16_t level = *pc++;\n      uint16_t v = *pc++;\n      jv* var = frame_local_var(jq, v, level);\n      if (jq->debug_trace_enabled) {\n        printf(\"V%d = \", v);\n        jv_dump(jv_copy(val), 0);\n        printf(\" (%d)\\n\", jv_get_refcnt(val));\n      }\n      jv_free(*var);\n      *var = val;\n      break;\n    }\n\n    case PATH_BEGIN: {\n      jv v = stack_pop(jq);\n      stack_push(jq, jq->path);\n\n      stack_save(jq, pc - 1, stack_get_pos(jq));\n\n      stack_push(jq, jv_number(jq->subexp_nest));\n      stack_push(jq, jq->value_at_path);\n      stack_push(jq, jv_copy(v));\n\n      jq->path = jv_array();\n      jq->value_at_path = v; // next INDEX operation must index into v\n      jq->subexp_nest = 0;\n      break;\n    }\n\n    case PATH_END: {\n      jv v = stack_pop(jq);\n      // detect invalid path expression like path(.a | reverse)\n      if (!path_intact(jq, jv_copy(v))) {\n        char errbuf[30];\n        jv msg = jv_string_fmt(\n            \"Invalid path expression with result %s\",\n            jv_dump_string_trunc(v, errbuf, sizeof(errbuf)));\n        set_error(jq, jv_invalid_with_msg(msg));\n        goto do_backtrack;\n      }\n      jv_free(v); // discard value, only keep path\n\n      jv old_value_at_path = stack_pop(jq);\n      int old_subexp_nest = (int)jv_number_value(stack_pop(jq));\n\n      jv path = jq->path;\n      jq->path = stack_pop(jq);\n\n      struct stack_pos spos = stack_get_pos(jq);\n      stack_push(jq, jv_copy(path));\n      stack_save(jq, pc - 1, spos);\n\n      stack_push(jq, path);\n      jq->subexp_nest = old_subexp_nest;\n      jv_free(jq->value_at_path);\n      jq->value_at_path = old_value_at_path;\n      break;\n    }\n\n    case ON_BACKTRACK(PATH_BEGIN):\n    case ON_BACKTRACK(PATH_END): {\n      jv_free(jq->path);\n      jq->path = stack_pop(jq);\n      goto do_backtrack;\n    }\n\n    case INDEX:\n    case INDEX_OPT: {\n      jv t = stack_pop(jq);\n      jv k = stack_pop(jq);\n      // detect invalid path expression like path(reverse | .a)\n      if (!path_intact(jq, jv_copy(t))) {\n        char keybuf[15];\n        char objbuf[30];\n        jv msg = jv_string_fmt(\n            \"Invalid path expression near attempt to access element %s of %s\",\n            jv_dump_string_trunc(k, keybuf, sizeof(keybuf)),\n            jv_dump_string_trunc(t, objbuf, sizeof(objbuf)));\n        set_error(jq, jv_invalid_with_msg(msg));\n        goto do_backtrack;\n      }\n      jv v = jv_get(t, jv_copy(k));\n      if (jv_is_valid(v)) {\n        path_append(jq, k, jv_copy(v));\n        stack_push(jq, v);\n      } else {\n        jv_free(k);\n        if (opcode == INDEX)\n          set_error(jq, v);\n        else\n          jv_free(v);\n        goto do_backtrack;\n      }\n      break;\n    }\n\n\n    case JUMP: {\n      uint16_t offset = *pc++;\n      pc += offset;\n      break;\n    }\n\n    case JUMP_F: {\n      uint16_t offset = *pc++;\n      jv t = stack_pop(jq);\n      jv_kind kind = jv_get_kind(t);\n      if (kind == JV_KIND_FALSE || kind == JV_KIND_NULL) {\n        pc += offset;\n      }\n      stack_push(jq, t); // FIXME do this better\n      break;\n    }\n\n    case EACH:\n    case EACH_OPT: {\n      jv container = stack_pop(jq);\n      // detect invalid path expression like path(reverse | .[])\n      if (!path_intact(jq, jv_copy(container))) {\n        char errbuf[30];\n        jv msg = jv_string_fmt(\n            \"Invalid path expression near attempt to iterate through %s\",\n            jv_dump_string_trunc(container, errbuf, sizeof(errbuf)));\n        set_error(jq, jv_invalid_with_msg(msg));\n        goto do_backtrack;\n      }\n      stack_push(jq, container);\n      stack_push(jq, jv_number(-1));\n      JQ_FALLTHROUGH;\n    }\n    case ON_BACKTRACK(EACH):\n    case ON_BACKTRACK(EACH_OPT): {\n      int idx = jv_number_value(stack_pop(jq));\n      jv container = stack_pop(jq);\n\n      int keep_going, is_last = 0;\n      jv key, value;\n      if (jv_get_kind(container) == JV_KIND_ARRAY) {\n        if (opcode == EACH || opcode == EACH_OPT) idx = 0;\n        else idx = idx + 1;\n        int len = jv_array_length(jv_copy(container));\n        keep_going = idx < len;\n        is_last = idx == len - 1;\n        if (keep_going) {\n          key = jv_number(idx);\n          value = jv_array_get(jv_copy(container), idx);\n        }\n      } else if (jv_get_kind(container) == JV_KIND_OBJECT) {\n        if (opcode == EACH || opcode == EACH_OPT) idx = jv_object_iter(container);\n        else idx = jv_object_iter_next(container, idx);\n        keep_going = jv_object_iter_valid(container, idx);\n        if (keep_going) {\n          key = jv_object_iter_key(container, idx);\n          value = jv_object_iter_value(container, idx);\n        }\n      } else {\n        assert(opcode == EACH || opcode == EACH_OPT);\n        if (opcode == EACH) {\n          char errbuf[15];\n          set_error(jq,\n                    jv_invalid_with_msg(jv_string_fmt(\"Cannot iterate over %s (%s)\",\n                                                      jv_kind_name(jv_get_kind(container)),\n                                                      jv_dump_string_trunc(jv_copy(container), errbuf, sizeof(errbuf)))));\n        }\n        keep_going = 0;\n      }\n\n      if (!keep_going || raising) {\n        if (keep_going)\n          jv_free(value);\n        jv_free(container);\n        goto do_backtrack;\n      } else if (is_last) {\n        // we don't need to make a backtrack point\n        jv_free(container);\n        path_append(jq, key, jv_copy(value));\n        stack_push(jq, value);\n      } else {\n        struct stack_pos spos = stack_get_pos(jq);\n        stack_push(jq, container);\n        stack_push(jq, jv_number(idx));\n        stack_save(jq, pc - 1, spos);\n        path_append(jq, key, jv_copy(value));\n        stack_push(jq, value);\n      }\n      break;\n    }\n\n    do_backtrack:\n    case BACKTRACK: {\n      pc = stack_restore(jq);\n      if (!pc) {\n        if (!jv_is_valid(jq->error)) {\n          jv error = jq->error;\n          jq->error = jv_null();\n          return error;\n        }\n        return jv_invalid();\n      }\n      backtracking = 1;\n      break;\n    }\n\n    case TRY_BEGIN:\n      stack_save(jq, pc - 1, stack_get_pos(jq));\n      pc++; // skip handler offset this time\n      break;\n\n    case TRY_END:\n      stack_save(jq, pc - 1, stack_get_pos(jq));\n      break;\n\n    case ON_BACKTRACK(TRY_BEGIN): {\n      if (!raising) {\n        /*\n         * `try EXP ...` -- EXP backtracked (e.g., EXP was `empty`), so we\n         * backtrack more:\n         */\n        jv_free(stack_pop(jq));\n        goto do_backtrack;\n      }\n\n      /*\n       * Else `(try EXP ... ) | EXP2` raised an error.\n       *\n       * If the error was wrapped in another error, then that means EXP2 raised\n       * the error.  We unwrap it and re-raise it as it wasn't raised by EXP.\n       *\n       * See commentary in gen_try().\n       */\n      jv e = jv_invalid_get_msg(jv_copy(jq->error));\n      if (!jv_is_valid(e) && jv_invalid_has_msg(jv_copy(e))) {\n        set_error(jq, e);\n        goto do_backtrack;\n      }\n      jv_free(e);\n\n      /*\n       * Else we caught an error containing a non-error value, so we jump to\n       * the handler.\n       *\n       * See commentary in gen_try().\n       */\n      uint16_t offset = *pc++;\n      jv_free(stack_pop(jq)); // free the input\n      stack_push(jq, jv_invalid_get_msg(jq->error));  // push the error's message\n      jq->error = jv_null();\n      pc += offset;\n      break;\n    }\n    case ON_BACKTRACK(TRY_END):\n      // Wrap the error so the matching TRY_BEGIN doesn't catch it\n      if (raising)\n        set_error(jq, jv_invalid_with_msg(jv_copy(jq->error)));\n      goto do_backtrack;\n\n    case DESTRUCTURE_ALT:\n    case FORK: {\n      stack_save(jq, pc - 1, stack_get_pos(jq));\n      pc++; // skip offset this time\n      break;\n    }\n\n    case ON_BACKTRACK(DESTRUCTURE_ALT): {\n      if (jv_is_valid(jq->error)) {\n        // `try EXP ...` backtracked here (no value, `empty`), so we backtrack more\n        jv_free(stack_pop(jq));\n        goto do_backtrack;\n      }\n      // `try EXP ...` exception caught in EXP\n      // DESTRUCTURE_ALT doesn't want the error message on the stack,\n      // as we would just want to throw it away anyway.\n      if (opcode != ON_BACKTRACK(DESTRUCTURE_ALT)) {\n        jv_free(stack_pop(jq)); // free the input\n        stack_push(jq, jv_invalid_get_msg(jq->error));  // push the error's message\n      } else {\n        jv_free(jq->error);\n      }\n      jq->error = jv_null();\n      uint16_t offset = *pc++;\n      pc += offset;\n      break;\n    }\n    case ON_BACKTRACK(FORK): {\n      if (raising) goto do_backtrack;\n      uint16_t offset = *pc++;\n      pc += offset;\n      break;\n    }\n\n    case CALL_BUILTIN: {\n      int nargs = *pc++;\n      jv top = stack_pop(jq);\n      jv* in = cfunc_input;\n      in[0] = top;\n      for (int i = 1; i < nargs; i++) {\n        in[i] = stack_pop(jq);\n      }\n      struct cfunction* function = &frame_current(jq)->bc->globals->cfunctions[*pc++];\n      switch (function->nargs) {\n      case 1: top = ((jv (*)(jq_state *, jv))function->fptr)(jq, in[0]); break;\n      case 2: top = ((jv (*)(jq_state *, jv, jv))function->fptr)(jq, in[0], in[1]); break;\n      case 3: top = ((jv (*)(jq_state *, jv, jv, jv))function->fptr)(jq, in[0], in[1], in[2]); break;\n      case 4: top = ((jv (*)(jq_state *, jv, jv, jv, jv))function->fptr)(jq, in[0], in[1], in[2], in[3]); break;\n      case 5: top = ((jv (*)(jq_state *, jv, jv, jv, jv, jv))function->fptr)(jq, in[0], in[1], in[2], in[3], in[4]); break;\n      // FIXME: a) up to 7 arguments (input + 6), b) should assert\n      // because the compiler should not generate this error.\n      default: return jv_invalid_with_msg(jv_string(\"Function takes too many arguments\"));\n      }\n\n      if (jv_is_valid(top)) {\n        stack_push(jq, top);\n      } else if (jv_invalid_has_msg(jv_copy(top))) {\n        set_error(jq, top);\n        goto do_backtrack;\n      } else {\n        // C-coded function returns invalid w/o msg? -> backtrack, as if\n        // it had returned `empty`\n        goto do_backtrack;\n      }\n      break;\n    }\n\n    case TAIL_CALL_JQ:\n    case CALL_JQ: {\n      /*\n       * Bytecode layout here:\n       *\n       *  CALL_JQ\n       *  <nclosures>                       (i.e., number of call arguments)\n       *  <callee closure>                  (what we're calling)\n       *  <nclosures' worth of closures>    (frame reference + code pointer)\n       *\n       *  <next instruction (to return to)>\n       *\n       * Each closure consists of two uint16_t values: a \"level\"\n       * identifying the frame to be closed over, and an index.\n       *\n       * The level is a relative number of call frames reachable from\n       * the currently one; 0 -> current frame, 1 -> previous frame, and\n       * so on.\n       *\n       * The index is either an index of the closed frame's subfunctions\n       * or of the closed frame's parameter closures.  If the latter,\n       * that closure will be passed, else the closed frame's pointer\n       * and the subfunction's code will form the closure to be passed.\n       *\n       * See make_closure() for more information.\n       */\n      jv input = stack_pop(jq);\n      uint16_t nclosures = *pc++;\n      uint16_t* retaddr = pc + 2 + nclosures*2;\n      stack_ptr retdata = jq->stk_top;\n      struct frame* new_frame;\n      struct closure cl = make_closure(jq, pc);\n      if (opcode == TAIL_CALL_JQ) {\n        retaddr = frame_current(jq)->retaddr;\n        retdata = frame_current(jq)->retdata;\n        frame_pop(jq);\n      }\n      new_frame = frame_push(jq, cl, pc + 2, nclosures);\n      new_frame->retdata = retdata;\n      new_frame->retaddr = retaddr;\n      pc = new_frame->bc->code;\n      stack_push(jq, input);\n      break;\n    }\n\n    case RET: {\n      jv value = stack_pop(jq);\n      assert(jq->stk_top == frame_current(jq)->retdata);\n      uint16_t* retaddr = frame_current(jq)->retaddr;\n      if (retaddr) {\n        // function return\n        pc = retaddr;\n        frame_pop(jq);\n      } else {\n        // top-level return, yielding value\n        struct stack_pos spos = stack_get_pos(jq);\n        stack_push(jq, jv_null());\n        stack_save(jq, pc - 1, spos);\n        return value;\n      }\n      stack_push(jq, value);\n      break;\n    }\n    case ON_BACKTRACK(RET): {\n      // resumed after top-level return\n      goto do_backtrack;\n    }\n    }\n  }\n}\n\n\n// target function\nint jvp_number_cmp(jv a, jv b) {\n  assert(JVP_HAS_KIND(a, JV_KIND_NUMBER));\n  assert(JVP_HAS_KIND(b, JV_KIND_NUMBER));\n\n#ifdef USE_DECNUM\n  if (JVP_HAS_FLAGS(a, JVP_FLAGS_NUMBER_LITERAL) && JVP_HAS_FLAGS(b, JVP_FLAGS_NUMBER_LITERAL)) {\n    decNumber res;\n    decNumberCompare(&res,\n                     jvp_dec_number_ptr(a),\n                     jvp_dec_number_ptr(b),\n                     DEC_CONTEXT()\n                     );\n    if (decNumberIsZero(&res)) {\n      return 0;\n    } else if (decNumberIsNegative(&res)) {\n      return -1;\n    } else {\n      return 1;\n    }\n  }\n#endif\n  double da = jv_number_value(a), db = jv_number_value(b);\n  if (da < db) {\n    return -1;\n  } else if (da == db) {\n    return 0;\n  } else {\n    return 1;\n  }\n}\n",
    "target": 1,
    "idx": 1064771,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "// context\n\n\nDataBuf readFile(const std::string& path) {\n  FileIo file(path);\n  if (file.open(\"rb\") != 0) {\n    throw Error(ErrorCode::kerFileOpenFailed, path, \"rb\", strError());\n  }\n  struct stat st;\n  if (0 != ::stat(path.c_str(), &st)) {\n    throw Error(ErrorCode::kerCallFailed, path, strError(), \"::stat\");\n  }\n  DataBuf buf(st.st_size);\n  const size_t len = file.read(buf.data(), buf.size());\n  if (len != buf.size()) {\n    throw Error(ErrorCode::kerCallFailed, path, strError(), \"FileIo::read\");\n  }\n  return buf;\n}\n\nvoid BasicIo::readOrThrow(byte* buf, size_t rcount, ErrorCode err) {\n  const size_t nread = read(buf, rcount);\n  enforce(nread == rcount, err);\n  enforce(!error(), err);\n}\n\nvoid QuickTimeVideo::userDataDecoder(size_t size_external) {\n  size_t cur_pos = io_->tell();\n  const TagVocabulary* td;\n  const TagVocabulary *tv, *tv_internal;\n\n  const long bufMinSize = 100;\n  DataBuf buf(bufMinSize);\n  size_t size_internal = size_external;\n  std::memset(buf.data(), 0x0, buf.size());\n\n  while ((size_internal / 4 != 0) && (size_internal > 0)) {\n    buf.data()[4] = '\\0';\n    io_->readOrThrow(buf.data(), 4);\n    const size_t size = buf.read_uint32(0, bigEndian);\n    if (size > size_internal)\n      break;\n    size_internal -= size;\n    io_->readOrThrow(buf.data(), 4);\n\n    if (buf.data()[0] == 169)\n      buf.data()[0] = ' ';\n    td = find(userDatatags, Exiv2::toString(buf.data()));\n\n    tv = find(userDataReferencetags, Exiv2::toString(buf.data()));\n\n    if (size <= 12)\n      break;\n\n    else if (equalsQTimeTag(buf, \"DcMD\") || equalsQTimeTag(buf, \"NCDT\"))\n      userDataDecoder(size - 8);\n\n    else if (equalsQTimeTag(buf, \"NCTG\"))\n      NikonTagsDecoder(size - 8);\n\n    else if (equalsQTimeTag(buf, \"TAGS\"))\n      CameraTagsDecoder(size - 8);\n\n    else if (equalsQTimeTag(buf, \"CNCV\") || equalsQTimeTag(buf, \"CNFV\") || equalsQTimeTag(buf, \"CNMN\") ||\n             equalsQTimeTag(buf, \"NCHD\") || equalsQTimeTag(buf, \"FFMV\")) {\n      enforce(tv, Exiv2::ErrorCode::kerCorruptedMetadata);\n      xmpData_[exvGettext(tv->label_)] = readString(*io_, size - 8);\n    }\n\n    else if (equalsQTimeTag(buf, \"CMbo\") || equalsQTimeTag(buf, \"Cmbo\")) {\n      io_->readOrThrow(buf.data(), 2);\n      buf.data()[2] = '\\0';\n      tv_internal = find(cameraByteOrderTags, Exiv2::toString(buf.data()));\n\n      if (tv_internal)\n        xmpData_[exvGettext(tv->label_)] = exvGettext(tv_internal->label_);\n      else\n        xmpData_[exvGettext(tv->label_)] = Exiv2::toString(buf.data());\n    }\n\n    else if (tv) {\n      io_->readOrThrow(buf.data(), 4);\n      xmpData_[exvGettext(tv->label_)] = readString(*io_, size - 12);\n    }\n\n    else if (td)\n      tagDecoder(buf, size - 8);\n  }\n\n  io_->seek(cur_pos + size_external, BasicIo::beg);\n}  // QuickTimeVideo::userDataDecoder\n\nvoid QuickTimeVideo::tagDecoder(Exiv2::DataBuf& buf, size_t size) {\n  assert(buf.size() > 4);\n\n  if (ignoreList(buf))\n    discard(size);\n\n  else if (dataIgnoreList(buf)) {\n    decodeBlock(Exiv2::toString(buf.data()));\n  } else if (equalsQTimeTag(buf, \"ftyp\"))\n    fileTypeDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"trak\"))\n    setMediaStream();\n\n  else if (equalsQTimeTag(buf, \"mvhd\"))\n    movieHeaderDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"tkhd\"))\n    trackHeaderDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"mdhd\"))\n    mediaHeaderDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"hdlr\"))\n    handlerDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"vmhd\"))\n    videoHeaderDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"udta\"))\n    userDataDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"dref\"))\n    multipleEntriesDecoder();\n\n  else if (equalsQTimeTag(buf, \"stsd\"))\n    sampleDesc(size);\n\n  else if (equalsQTimeTag(buf, \"stts\"))\n    timeToSampleDecoder();\n\n  else if (equalsQTimeTag(buf, \"pnot\"))\n    previewTagDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"tapt\"))\n    trackApertureTagDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"keys\"))\n    keysTagDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"url \")) {\n    if (currentStream_ == Video)\n      xmpData_[\"Xmp.video.URL\"] = readString(*io_, size);\n    else if (currentStream_ == Audio)\n      xmpData_[\"Xmp.audio.URL\"] = readString(*io_, size);\n  }\n\n  else if (equalsQTimeTag(buf, \"urn \")) {\n    if (currentStream_ == Video)\n      xmpData_[\"Xmp.video.URN\"] = readString(*io_, size);\n    else if (currentStream_ == Audio)\n      xmpData_[\"Xmp.audio.URN\"] = readString(*io_, size);\n  }\n\n  else if (equalsQTimeTag(buf, \"dcom\")) {\n    xmpData_[\"Xmp.video.Compressor\"] = readString(*io_, size);\n  }\n\n  else if (equalsQTimeTag(buf, \"smhd\")) {\n    io_->readOrThrow(buf.data(), 4);\n    io_->readOrThrow(buf.data(), 4);\n    xmpData_[\"Xmp.audio.Balance\"] = buf.read_uint16(0, bigEndian);\n  }\n\n  else {\n    discard(size);\n  }\n}  // QuickTimeVideo::tagDecoder\n\nvoid QuickTimeVideo::decodeBlock(std::string const& entered_from) {\n  const long bufMinSize = 4;\n  DataBuf buf(bufMinSize + 1);\n  uint64_t size = 0;\n  buf.data()[4] = '\\0';\n\n  io_->read(buf.data(), 4);\n  if (io_->eof()) {\n    continueTraversing_ = false;\n    return;\n  }\n\n  size = buf.read_uint32(0, bigEndian);\n\n  io_->readOrThrow(buf.data(), 4);\n\n  // we have read 2x 4 bytes\n  size_t hdrsize = 8;\n\n  if (size == 1) {\n    // The box size is encoded as a uint64_t, so we need to read another 8 bytes.\n    DataBuf data(8);\n    hdrsize += 8;\n    io_->readOrThrow(data.data(), data.size());\n    size = data.read_uint64(0, bigEndian);\n  } else if (size == 0) {\n    if (entered_from == \"meta\") {\n      size = buf.read_uint32(0, bigEndian);\n      io_->readOrThrow(buf.data(), 4, Exiv2::ErrorCode::kerCorruptedMetadata);\n    }\n  }\n\n  enforce(size >= hdrsize, Exiv2::ErrorCode::kerCorruptedMetadata);\n  enforce(size - hdrsize <= io_->size() - io_->tell(), Exiv2::ErrorCode::kerCorruptedMetadata);\n  enforce(size - hdrsize <= std::numeric_limits<size_t>::max(), Exiv2::ErrorCode::kerCorruptedMetadata);\n\n  // std::cerr<<\"Tag=>\"<<buf.data()<<\"     size=>\"<<size-hdrsize << std::endl;\n  const size_t newsize = static_cast<size_t>(size - hdrsize);\n  if (newsize > buf.size()) {\n    buf.resize(newsize);\n  }\n  tagDecoder(buf, newsize);\n}  // QuickTimeVideo::decodeBlock\n\nvoid QuickTimeVideo::readMetadata() {\n  if (io_->open() != 0)\n    throw Error(ErrorCode::kerDataSourceOpenFailed, io_->path(), strError());\n\n  // Ensure that this is the correct image type\n  if (!isQTimeType(*io_, false)) {\n    if (io_->error() || io_->eof())\n      throw Error(ErrorCode::kerFailedToReadImageData);\n    throw Error(ErrorCode::kerNotAnImage, \"QuickTime\");\n  }\n\n  IoCloser closer(*io_);\n  clearMetadata();\n  continueTraversing_ = true;\n  height_ = width_ = 1;\n\n  xmpData_[\"Xmp.video.FileSize\"] = (double)io_->size() / (double)1048576;\n  xmpData_[\"Xmp.video.MimeType\"] = mimeType();\n\n  while (continueTraversing_)\n    decodeBlock();\n\n  aspectRatio();\n}  // QuickTimeVideo::readMetadata\n\n\n// target function\nvoid QuickTimeVideo::tagDecoder(Exiv2::DataBuf& buf, size_t size) {\n  assert(buf.size() > 4);\n\n  if (ignoreList(buf))\n    discard(size);\n\n  else if (dataIgnoreList(buf)) {\n    decodeBlock(Exiv2::toString(buf.data()));\n  } else if (equalsQTimeTag(buf, \"ftyp\"))\n    fileTypeDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"trak\"))\n    setMediaStream();\n\n  else if (equalsQTimeTag(buf, \"mvhd\"))\n    movieHeaderDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"tkhd\"))\n    trackHeaderDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"mdhd\"))\n    mediaHeaderDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"hdlr\"))\n    handlerDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"vmhd\"))\n    videoHeaderDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"udta\"))\n    userDataDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"dref\"))\n    multipleEntriesDecoder();\n\n  else if (equalsQTimeTag(buf, \"stsd\"))\n    sampleDesc(size);\n\n  else if (equalsQTimeTag(buf, \"stts\"))\n    timeToSampleDecoder();\n\n  else if (equalsQTimeTag(buf, \"pnot\"))\n    previewTagDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"tapt\"))\n    trackApertureTagDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"keys\"))\n    keysTagDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"url \")) {\n    Exiv2::DataBuf url(size + 1);\n    io_->readOrThrow(url.data(), size);\n    url.write_uint8(size, 0);\n    if (currentStream_ == Video)\n      xmpData_[\"Xmp.video.URL\"] = Exiv2::toString(url.data());\n    else if (currentStream_ == Audio)\n      xmpData_[\"Xmp.audio.URL\"] = Exiv2::toString(url.data());\n  }\n\n  else if (equalsQTimeTag(buf, \"urn \")) {\n    Exiv2::DataBuf urn(size + 1);\n    io_->readOrThrow(urn.data(), size);\n    urn.write_uint8(size, 0);\n    if (currentStream_ == Video)\n      xmpData_[\"Xmp.video.URN\"] = Exiv2::toString(urn.data());\n    else if (currentStream_ == Audio)\n      xmpData_[\"Xmp.audio.URN\"] = Exiv2::toString(urn.data());\n  }\n\n  else if (equalsQTimeTag(buf, \"dcom\")) {\n    Exiv2::DataBuf dcom(size + 1);\n    io_->readOrThrow(dcom.data(), size);\n    dcom.write_uint8(size, 0);\n    xmpData_[\"Xmp.video.Compressor\"] = Exiv2::toString(dcom.data());\n  }\n\n  else if (equalsQTimeTag(buf, \"smhd\")) {\n    io_->readOrThrow(buf.data(), 4);\n    io_->readOrThrow(buf.data(), 4);\n    xmpData_[\"Xmp.audio.Balance\"] = buf.read_uint16(0, bigEndian);\n  }\n\n  else {\n    discard(size);\n  }\n}  // QuickTimeVideo::tagDecoder\nvoid QuickTimeVideo::CameraTagsDecoder(size_t size_external) {\n  size_t cur_pos = io_->tell();\n  DataBuf buf(50), buf2(4);\n  const TagDetails* td;\n\n  io_->readOrThrow(buf.data(), 4);\n  if (equalsQTimeTag(buf, \"NIKO\")) {\n    io_->seek(cur_pos, BasicIo::beg);\n\n    io_->readOrThrow(buf.data(), 24);\n    xmpData_[\"Xmp.video.Make\"] = Exiv2::toString(buf.data());\n    io_->readOrThrow(buf.data(), 14);\n    xmpData_[\"Xmp.video.Model\"] = Exiv2::toString(buf.data());\n    io_->readOrThrow(buf.data(), 4);\n    xmpData_[\"Xmp.video.ExposureTime\"] = \"1/\" + Exiv2::toString(ceil(buf.read_uint32(0, littleEndian) / (double)10));\n    io_->readOrThrow(buf.data(), 4);\n    io_->readOrThrow(buf2.data(), 4);\n    xmpData_[\"Xmp.video.FNumber\"] = buf.read_uint32(0, littleEndian) / (double)buf2.read_uint32(0, littleEndian);\n    io_->readOrThrow(buf.data(), 4);\n    io_->readOrThrow(buf2.data(), 4);\n    xmpData_[\"Xmp.video.ExposureCompensation\"] =\n        buf.read_uint32(0, littleEndian) / (double)buf2.read_uint32(0, littleEndian);\n    io_->readOrThrow(buf.data(), 10);\n    io_->readOrThrow(buf.data(), 4);\n    td = find(whiteBalance, buf.read_uint32(0, littleEndian));\n    if (td)\n      xmpData_[\"Xmp.video.WhiteBalance\"] = exvGettext(td->label_);\n    io_->readOrThrow(buf.data(), 4);\n    io_->readOrThrow(buf2.data(), 4);\n    xmpData_[\"Xmp.video.FocalLength\"] = buf.read_uint32(0, littleEndian) / (double)buf2.read_uint32(0, littleEndian);\n    io_->seek(static_cast<long>(95), BasicIo::cur);\n    io_->readOrThrow(buf.data(), 48);\n    xmpData_[\"Xmp.video.Software\"] = Exiv2::toString(buf.data());\n    io_->readOrThrow(buf.data(), 4);\n    xmpData_[\"Xmp.video.ISO\"] = buf.read_uint32(0, littleEndian);\n  }\n\n  io_->seek(cur_pos + size_external, BasicIo::beg);\n}  // QuickTimeVideo::CameraTagsDecoder\nvoid QuickTimeVideo::userDataDecoder(size_t size_external) {\n  size_t cur_pos = io_->tell();\n  const TagVocabulary* td;\n  const TagVocabulary *tv, *tv_internal;\n\n  const long bufMinSize = 100;\n  DataBuf buf(bufMinSize);\n  size_t size_internal = size_external;\n  std::memset(buf.data(), 0x0, buf.size());\n\n  while ((size_internal / 4 != 0) && (size_internal > 0)) {\n    buf.data()[4] = '\\0';\n    io_->readOrThrow(buf.data(), 4);\n    const size_t size = buf.read_uint32(0, bigEndian);\n    if (size > size_internal)\n      break;\n    size_internal -= size;\n    io_->readOrThrow(buf.data(), 4);\n\n    if (buf.data()[0] == 169)\n      buf.data()[0] = ' ';\n    td = find(userDatatags, Exiv2::toString(buf.data()));\n\n    tv = find(userDataReferencetags, Exiv2::toString(buf.data()));\n\n    if (size <= 12)\n      break;\n\n    else if (equalsQTimeTag(buf, \"DcMD\") || equalsQTimeTag(buf, \"NCDT\"))\n      userDataDecoder(size - 8);\n\n    else if (equalsQTimeTag(buf, \"NCTG\"))\n      NikonTagsDecoder(size - 8);\n\n    else if (equalsQTimeTag(buf, \"TAGS\"))\n      CameraTagsDecoder(size - 8);\n\n    else if (equalsQTimeTag(buf, \"CNCV\") || equalsQTimeTag(buf, \"CNFV\") || equalsQTimeTag(buf, \"CNMN\") ||\n             equalsQTimeTag(buf, \"NCHD\") || equalsQTimeTag(buf, \"FFMV\")) {\n      io_->readOrThrow(buf.data(), size - 8);\n      xmpData_[exvGettext(tv->label_)] = Exiv2::toString(buf.data());\n    }\n\n    else if (equalsQTimeTag(buf, \"CMbo\") || equalsQTimeTag(buf, \"Cmbo\")) {\n      io_->readOrThrow(buf.data(), 2);\n      buf.data()[2] = '\\0';\n      tv_internal = find(cameraByteOrderTags, Exiv2::toString(buf.data()));\n\n      if (tv_internal)\n        xmpData_[exvGettext(tv->label_)] = exvGettext(tv_internal->label_);\n      else\n        xmpData_[exvGettext(tv->label_)] = Exiv2::toString(buf.data());\n    }\n\n    else if (tv) {\n      const size_t tv_size = size - 12;\n      if (tv_size >= buf.size()) {\n        enforce(tv_size <= io_->size() - io_->tell(), Exiv2::ErrorCode::kerCorruptedMetadata);\n        buf.resize(tv_size + 1);\n      }\n      io_->readOrThrow(buf.data(), 4);\n      io_->readOrThrow(buf.data(), tv_size);\n      buf.write_uint8(tv_size, 0);  // nul-terminate string\n      xmpData_[exvGettext(tv->label_)] = Exiv2::toString(buf.data());\n    }\n\n    else if (td)\n      tagDecoder(buf, size - 8);\n  }\n\n  io_->seek(cur_pos + size_external, BasicIo::beg);\n}  // QuickTimeVideo::userDataDecoder\n",
    "target": 1,
    "idx": 1052053,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "// context\n  uint32 getBits(int nbits) {\n    if (!vbits) {\n      /* On truncated files this routine will just return just for the truncated\n       * part of the file. Since there is no chance of affecting output buffer\n       * size we allow the decoder to decode this\n       */\n      assert(BufSize >= load_flags);\n      auto size = std::min(input.getRemainSize(), BufSize - load_flags);\n      memcpy(buf.data() + load_flags, input.getData(size), size);\n\n      size = std::min(input.getRemainSize(), load_flags);\n      if (size != 0)\n        memcpy(buf.data(), input.getData(size), size);\n    }\n    vbits = (vbits - nbits) & 0x1ffff;\n    int byte = vbits >> 3 ^ 0x3ff0;\n    return (buf[byte] | buf[byte + 1UL] << 8) >> (vbits & 7) & ~(-(1 << nbits));\n  }\n\nvoid PanasonicDecompressor::decompressThreaded(\n    const RawDecompressorThread* t) const {\n  PanaBitpump bits(input, load_flags);\n\n  /* 9 + 1/7 bits per pixel */\n  bits.skipBytes(8 * mRaw->dim.x * t->start / 7);\n\n  std::vector<uint32> zero_pos;\n  for (uint32 y = t->start; y < t->end; y++) {\n    int sh = 0;\n    int pred[2];\n    int nonz[2];\n    int u = 0;\n\n    auto* dest = reinterpret_cast<ushort16*>(mRaw->getData(0, y));\n    for (int x = 0; x < mRaw->dim.x; x++) {\n      const int i = x % 14;\n      const int c = x & 1;\n\n      // did we process one whole block of 14 pixels?\n      if (i == 0)\n        u = pred[0] = pred[1] = nonz[0] = nonz[1] = 0;\n\n      if (u == 2) {\n        sh = 4 >> (3 - bits.getBits(2));\n        u = -1;\n      }\n\n      if (nonz[c]) {\n        int j = bits.getBits(8);\n        if (j) {\n          pred[c] -= 0x80 << sh;\n          if (pred[c] < 0 || sh == 4)\n            pred[c] &= ~(-(1 << sh));\n          pred[c] += j << sh;\n        }\n      } else {\n        nonz[c] = bits.getBits(8);\n        if (nonz[c] || i > 11)\n          pred[c] = nonz[c] << 4 | bits.getBits(4);\n      }\n\n      *dest = pred[c];\n\n      if (zero_is_bad && 0 == pred[c])\n        zero_pos.push_back((y << 16) | x);\n\n      u++;\n      dest++;\n    }\n  }\n\n  if (zero_is_bad && !zero_pos.empty()) {\n    MutexLocker guard(&mRaw->mBadPixelMutex);\n    mRaw->mBadPixelPositions.insert(mRaw->mBadPixelPositions.end(),\n                                    zero_pos.begin(), zero_pos.end());\n  }\n}\n\n\n\nvoid AbstractParallelizedDecompressor::decompressOne(uint32 pieces) const {\n  RawDecompressorThread t(this, 1);\n  t.taskNo = 0;\n  t.start = 0;\n  t.end = pieces;\n\n  RawDecompressorThread::start_routine(&t);\n\n  std::string firstErr;\n  if (mRaw->isTooManyErrors(1, &firstErr)) {\n    ThrowRDE(\"Too many errors encountered. Giving up. First Error:\\n%s\",\n             firstErr.c_str());\n  }\n};\n\n\n// target function\nPanasonicDecompressor::PanasonicDecompressor(const RawImage& img,\n                                             ByteStream input_,\n                                             bool zero_is_not_bad,\n                                             uint32 load_flags_)\n    : AbstractParallelizedDecompressor(img), input(std::move(input_)),\n      zero_is_bad(!zero_is_not_bad), load_flags(load_flags_) {\n  if (mRaw->getCpp() != 1 || mRaw->getDataType() != TYPE_USHORT16 ||\n      mRaw->getBpp() != 2)\n    ThrowRDE(\"Unexpected component count / data type\");\n\n  const uint32 width = mRaw->dim.x;\n  const uint32 height = mRaw->dim.y;\n\n  if (width == 0 || height == 0 || width > 5488 || height > 3904)\n    ThrowRDE(\"Unexpected image dimensions found: (%u; %u)\", width, height);\n\n  input.check(load_flags);\n}\n  uint32 getBits(int nbits) {\n    if (!vbits) {\n      /* On truncated files this routine will just return just for the truncated\n       * part of the file. Since there is no chance of affecting output buffer\n       * size we allow the decoder to decode this\n       */\n      auto size = std::min(input.getRemainSize(), BufSize - load_flags);\n      memcpy(buf.data() + load_flags, input.getData(size), size);\n\n      size = std::min(input.getRemainSize(), load_flags);\n      if (size != 0)\n        memcpy(buf.data(), input.getData(size), size);\n    }\n    vbits = (vbits - nbits) & 0x1ffff;\n    int byte = vbits >> 3 ^ 0x3ff0;\n    return (buf[byte] | buf[byte + 1UL] << 8) >> (vbits & 7) & ~(-(1 << nbits));\n  }\n",
    "target": 1,
    "idx": 1004511,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "// context\n\n\nKGzipFilter::Result KGzipFilter::uncompress()\n{\n#ifndef NDEBUG\n    if (d->mode == 0) {\n        //qCWarning(KArchiveLog) << \"mode==0; KGzipFilter::init was not called!\";\n        return KFilterBase::Error;\n    } else if (d->mode == QIODevice::WriteOnly) {\n        //qCWarning(KArchiveLog) << \"uncompress called but the filter was opened for writing!\";\n        return KFilterBase::Error;\n    }\n    Q_ASSERT(d->mode == QIODevice::ReadOnly);\n#endif\n\n    if (!d->compressed) {\n        return uncompress_noop();\n    }\n\n#ifdef DEBUG_GZIP\n    qCDebug(KArchiveLog) << \"Calling inflate with avail_in=\" << inBufferAvailable() << \" avail_out=\" << outBufferAvailable();\n    qCDebug(KArchiveLog) << \"    next_in=\" << d->zStream.next_in;\n#endif\n\n    while (d->zStream.avail_in > 0) {\n        int result = inflate(&d->zStream, Z_SYNC_FLUSH);\n\n#ifdef DEBUG_GZIP\n        qCDebug(KArchiveLog) << \" -> inflate returned \" << result;\n        qCDebug(KArchiveLog) << \" now avail_in=\" << inBufferAvailable() << \" avail_out=\" << outBufferAvailable();\n        qCDebug(KArchiveLog) << \"     next_in=\" << d->zStream.next_in;\n#endif\n\n        if (result == Z_OK) {\n            return KFilterBase::Ok;\n        }\n\n        // We can't handle any other results\n        if (result != Z_STREAM_END) {\n            return KFilterBase::Error;\n        }\n\n        // It really was the end\n        if (d->zStream.avail_in == 0) {\n            return KFilterBase::End;\n        }\n\n        // Store before resetting\n        Bytef *data = d->zStream.next_in; // This is increased appropriately by zlib beforehand\n        uInt size = d->zStream.avail_in;\n\n        // Reset the stream, if that fails we assume we're at the end\n        if (!init(d->mode)) {\n            return KFilterBase::End;\n        }\n\n        // Reset the data to where we left off\n        d->zStream.next_in = data;\n        d->zStream.avail_in = size;\n    }\n\n    return KFilterBase::End;\n}\n\nqint64 KCompressionDevice::readData(char *data, qint64 maxlen)\n{\n    Q_ASSERT(d->filter->mode() == QIODevice::ReadOnly);\n    //qCDebug(KArchiveLog) << \"maxlen=\" << maxlen;\n    KFilterBase *filter = d->filter;\n\n    uint dataReceived = 0;\n\n    // We came to the end of the stream\n    if (d->result == KFilterBase::End) {\n        return dataReceived;\n    }\n\n    // If we had an error, return -1.\n    if (d->result != KFilterBase::Ok) {\n        return -1;\n    }\n\n    qint64 availOut = maxlen;\n    filter->setOutBuffer(data, maxlen);\n\n    while (dataReceived < maxlen) {\n        if (filter->inBufferEmpty()) {\n            // Not sure about the best size to set there.\n            // For sure, it should be bigger than the header size (see comment in readHeader)\n            d->buffer.resize(BUFFER_SIZE);\n            // Request data from underlying device\n            int size = filter->device()->read(d->buffer.data(),\n                                              d->buffer.size());\n            //qCDebug(KArchiveLog) << \"got\" << size << \"bytes from device\";\n            if (size) {\n                filter->setInBuffer(d->buffer.data(), size);\n            } else {\n                // Not enough data available in underlying device for now\n                break;\n            }\n        }\n        if (d->bNeedHeader) {\n            (void) filter->readHeader();\n            d->bNeedHeader = false;\n        }\n\n        d->result = filter->uncompress();\n\n        if (d->result == KFilterBase::Error) {\n            //qCWarning(KArchiveLog) << \"KCompressionDevice: Error when uncompressing data\";\n            break;\n        }\n\n        // We got that much data since the last time we went here\n        uint outReceived = availOut - filter->outBufferAvailable();\n        //qCDebug(KArchiveLog) << \"avail_out = \" << filter->outBufferAvailable() << \" result=\" << d->result << \" outReceived=\" << outReceived;\n        if (availOut < uint(filter->outBufferAvailable())) {\n            //qCWarning(KArchiveLog) << \" last availOut \" << availOut << \" smaller than new avail_out=\" << filter->outBufferAvailable() << \" !\";\n        }\n\n        dataReceived += outReceived;\n        data += outReceived;\n        availOut = maxlen - dataReceived;\n        if (d->result == KFilterBase::End) {\n            // We're actually at the end, no more data to check\n            if (filter->device()->atEnd()) {\n                break;\n            }\n\n            // Still not done, re-init and try again\n            filter->init(filter->mode());\n        }\n        filter->setOutBuffer(data, availOut);\n    }\n\n    d->deviceReadPos += dataReceived;\n    return dataReceived;\n}\n\nQByteArray QIODevice::read(qint64 maxSize)\n{\n    Q_D(QIODevice);\n    QByteArray result;\n\n#if defined QIODEVICE_DEBUG\n    printf(\"%p QIODevice::read(%lld), d->pos = %lld, d->buffer.size() = %lld\\n\",\n           this, maxSize, d->pos, d->buffer.size());\n#endif\n\n    // Try to prevent the data from being copied, if we have a chunk\n    // with the same size in the read buffer.\n    if (maxSize == d->buffer.nextDataBlockSize() && !d->transactionStarted\n        && (d->openMode & (QIODevice::ReadOnly | QIODevice::Text)) == QIODevice::ReadOnly) {\n        result = d->buffer.read();\n        if (!d->isSequential())\n            d->pos += maxSize;\n        if (d->buffer.isEmpty())\n            readData(nullptr, 0);\n        return result;\n    }\n\n    CHECK_MAXLEN(read, result);\n    CHECK_MAXBYTEARRAYSIZE(read);\n\n    result.resize(int(maxSize));\n    qint64 readBytes = read(result.data(), result.size());\n\n    if (readBytes <= 0)\n        result.clear();\n    else\n        result.resize(int(readBytes));\n\n    return result;\n}\n\nbool KCompressionDevice::seek(qint64 pos)\n{\n    if (d->deviceReadPos == pos) {\n        return QIODevice::seek(pos);\n    }\n\n    //qCDebug(KArchiveLog) << \"seek(\" << pos << \") called, current pos=\" << QIODevice::pos();\n\n    Q_ASSERT(d->filter->mode() == QIODevice::ReadOnly);\n\n    if (pos == 0) {\n        if (!QIODevice::seek(pos))\n            return false;\n\n        // We can forget about the cached data\n        d->bNeedHeader = !d->bSkipHeaders;\n        d->result = KFilterBase::Ok;\n        d->filter->setInBuffer(nullptr, 0);\n        d->filter->reset();\n        d->deviceReadPos = 0;\n        return d->filter->device()->reset();\n    }\n\n    qint64 bytesToRead;\n    if (d->deviceReadPos < pos) { // we can start from here\n        bytesToRead = pos - d->deviceReadPos;\n        // Since we're going to do a read() below\n        // we need to reset the internal QIODevice pos to the real position we are\n        // so that after read() we are indeed pointing to the pos seek\n        // asked us to be in\n        if (!QIODevice::seek(d->deviceReadPos)) {\n            return false;\n        }\n    } else {\n        // we have to start from 0 ! Ugly and slow, but better than the previous\n        // solution (KTarGz was allocating everything into memory)\n        if (!seek(0)) { // recursive\n            return false;\n        }\n        bytesToRead = pos;\n    }\n\n    //qCDebug(KArchiveLog) << \"reading \" << bytesToRead << \" dummy bytes\";\n    QByteArray dummy(qMin(bytesToRead, qint64(SEEK_BUFFER_SIZE)), 0);\n    while (bytesToRead > 0) {\n        const qint64 bytesToReadThisTime = qMin(bytesToRead, qint64(dummy.size()));\n        const bool result = (read(dummy.data(), bytesToReadThisTime) == bytesToReadThisTime);\n        if (!result) {\n            return false;\n        }\n        bytesToRead -= bytesToReadThisTime;\n    }\n    return true;\n}\n\nbool KTar::openArchive(QIODevice::OpenMode mode)\n{\n\n    if (!(mode & QIODevice::ReadOnly)) {\n        return true;\n    }\n\n    if (!d->fillTempFile(fileName())) {\n        return false;\n    }\n\n    // We'll use the permission and user/group of d->rootDir\n    // for any directory we emulate (see findOrCreate)\n    //struct stat buf;\n    //stat( fileName(), &buf );\n\n    d->dirList.clear();\n    QIODevice *dev = device();\n\n    if (!dev) {\n        setErrorString(tr(\"Could not get underlying device\"));\n        qCWarning(KArchiveLog) << \"Could not get underlying device\";\n        return false;\n    }\n\n    // read dir information\n    char buffer[0x200];\n    bool ende = false;\n    do {\n        QString name;\n        QString symlink;\n\n        // Read header\n        qint64 n = d->readHeader(buffer, name, symlink);\n        if (n < 0) {\n            setErrorString(tr(\"Could not read tar header\"));\n            return false;\n        }\n        if (n == 0x200) {\n            bool isdir = false;\n\n            if (name.isEmpty()) {\n                continue;\n            }\n            if (name.endsWith(QLatin1Char('/'))) {\n                isdir = true;\n                name.truncate(name.length() - 1);\n            }\n\n            QByteArray prefix = QByteArray(buffer + 0x159, 155);\n            if (prefix[0] != '\\0') {\n                name = (QString::fromLatin1(prefix.constData()) + QLatin1Char('/') +  name);\n            }\n\n            int pos = name.lastIndexOf(QLatin1Char('/'));\n            QString nm = (pos == -1) ? name : name.mid(pos + 1);\n\n            // read access\n            buffer[0x6b] = 0;\n            char *dummy;\n            const char *p = buffer + 0x64;\n            while (*p == ' ') {\n                ++p;\n            }\n            int access = strtol(p, &dummy, 8);\n\n            // read user and group\n            const int maxUserGroupLength = 32;\n            const char *userStart = buffer + 0x109;\n            const int userLen = qstrnlen(userStart, maxUserGroupLength);\n            const QString user = QString::fromLocal8Bit(userStart, userLen);\n            const char *groupStart = buffer + 0x129;\n            const int groupLen = qstrnlen(groupStart, maxUserGroupLength);\n            const QString group = QString::fromLocal8Bit(groupStart, groupLen);\n\n            // read time\n            buffer[0x93] = 0;\n            p = buffer + 0x88;\n            while (*p == ' ') {\n                ++p;\n            }\n            uint time = strtol(p, &dummy, 8);\n\n            // read type flag\n            char typeflag = buffer[0x9c];\n            // '0' for files, '1' hard link, '2' symlink, '5' for directory\n            // (and 'L' for longlink fileNames, 'K' for longlink symlink targets)\n            // 'D' for GNU tar extension DUMPDIR, 'x' for Extended header referring\n            // to the next file in the archive and 'g' for Global extended header\n\n            if (typeflag == '5') {\n                isdir = true;\n            }\n\n            bool isDumpDir = false;\n            if (typeflag == 'D') {\n                isdir = false;\n                isDumpDir = true;\n            }\n            //qCDebug(KArchiveLog) << nm << \"isdir=\" << isdir << \"pos=\" << dev->pos() << \"typeflag=\" << typeflag << \" islink=\" << ( typeflag == '1' || typeflag == '2' );\n\n            if (typeflag == 'x' || typeflag == 'g') { // pax extended header, or pax global extended header\n                // Skip it for now. TODO: implement reading of extended header, as per http://pubs.opengroup.org/onlinepubs/009695399/utilities/pax.html\n                (void)dev->read(buffer, 0x200);\n                continue;\n            }\n\n            if (isdir) {\n                access |= S_IFDIR;    // f*cking broken tar files\n            }\n\n            KArchiveEntry *e;\n            if (isdir) {\n                //qCDebug(KArchiveLog) << \"directory\" << nm;\n                e = new KArchiveDirectory(this, nm, access, KArchivePrivate::time_tToDateTime(time), user, group, symlink);\n            } else {\n                // read size\n                QByteArray sizeBuffer(buffer + 0x7c, 12);\n                qint64 size = sizeBuffer.trimmed().toLongLong(nullptr, 8 /*octal*/);\n                //qCDebug(KArchiveLog) << \"sizeBuffer='\" << sizeBuffer << \"' -> size=\" << size;\n\n                // for isDumpDir we will skip the additional info about that dirs contents\n                if (isDumpDir) {\n                    //qCDebug(KArchiveLog) << nm << \"isDumpDir\";\n                    e = new KArchiveDirectory(this, nm, access, KArchivePrivate::time_tToDateTime(time), user, group, symlink);\n                } else {\n\n                    // Let's hack around hard links. Our classes don't support that, so make them symlinks\n                    if (typeflag == '1') {\n                        //qCDebug(KArchiveLog) << \"Hard link, setting size to 0 instead of\" << size;\n                        size = 0; // no contents\n                    }\n\n                    //qCDebug(KArchiveLog) << \"file\" << nm << \"size=\" << size;\n                    e = new KArchiveFile(this, nm, access, KArchivePrivate::time_tToDateTime(time), user, group, symlink,\n                                         dev->pos(), size);\n                }\n\n                // Skip contents + align bytes\n                qint64 rest = size % 0x200;\n                qint64 skip = size + (rest ? 0x200 - rest : 0);\n                //qCDebug(KArchiveLog) << \"pos()=\" << dev->pos() << \"rest=\" << rest << \"skipping\" << skip;\n                if (! dev->seek(dev->pos() + skip)) {\n                    //qCWarning(KArchiveLog) << \"skipping\" << skip << \"failed\";\n                }\n            }\n\n            if (pos == -1) {\n                if (nm == QLatin1String(\".\")) { // special case\n                    Q_ASSERT(isdir);\n                    if (isdir) {\n                        setRootDir(static_cast<KArchiveDirectory *>(e));\n                    } else {\n                        delete e;\n                    }\n                } else {\n                    rootDir()->addEntry(e);\n                }\n            } else {\n                // In some tar files we can find dir/./file => call cleanPath\n                QString path = QDir::cleanPath(name.left(pos));\n                // Ensure container directory exists, create otherwise\n                KArchiveDirectory *d = findOrCreate(path);\n                if (d) {\n                    d->addEntry(e);\n                } else {\n                    delete e;\n                    return false;\n                }\n            }\n        } else {\n            //qCDebug(KArchiveLog) << \"Terminating. Read \" << n << \" bytes, first one is \" << buffer[0];\n            d->tarEnd = dev->pos() - n; // Remember end of archive\n            ende = true;\n        }\n    } while (!ende);\n    return true;\n}\n\nbool KArchive::open(QIODevice::OpenMode mode)\n{\n    Q_ASSERT(mode != QIODevice::NotOpen);\n\n    if (isOpen()) {\n        close();\n    }\n\n    if (!d->fileName.isEmpty()) {\n        Q_ASSERT(!d->dev);\n        if (!createDevice(mode)) {\n            return false;\n        }\n    }\n\n    if (!d->dev) {\n        setErrorString(tr(\"No filename or device was specified\"));\n        return false;\n    }\n\n    if (!d->dev->isOpen() && !d->dev->open(mode)) {\n        setErrorString(tr(\"Could not set device mode to %1\").arg(mode));\n        return false;\n    }\n\n    d->mode = mode;\n\n    Q_ASSERT(!d->rootDir);\n    d->rootDir = nullptr;\n\n    return openArchive(mode);\n}\n\n\n// target function\nvoid KCompressionDeviceTest::testSeekReadUncompressedBuffer()\n{\n    const int dataSize = BUFFER_SIZE + BUFFER_SIZE / 2;\n    QByteArray ba(dataSize, 0);\n\n    // all data is zero except after BUFFER_SIZE that it's 0 to 9\n    for (int i = 0; i < 10; ++i) {\n        ba[BUFFER_SIZE + i] = i;\n    }\n\n    QBuffer b;\n    b.setData(ba);\n    QVERIFY(b.open(QIODevice::ReadOnly));\n\n    KCompressionDevice kcd(&b, false, KCompressionDevice::GZip);\n    QVERIFY(kcd.open(QIODevice::ReadOnly));\n    QVERIFY(kcd.seek(BUFFER_SIZE));\n\n    // the 10 bytes after BUFFER_SIZE should be 0 to 9\n    const QByteArray kcdData = kcd.read(10);\n    QCOMPARE(kcdData.size(), 10);\n    for (int i = 0; i < kcdData.size(); ++i) {\n        QCOMPARE(kcdData[i], i);\n    }\n}\nbool KCompressionDevice::seek(qint64 pos)\n{\n    if (d->deviceReadPos == pos) {\n        return QIODevice::seek(pos);\n    }\n\n    //qCDebug(KArchiveLog) << \"seek(\" << pos << \") called, current pos=\" << QIODevice::pos();\n\n    Q_ASSERT(d->filter->mode() == QIODevice::ReadOnly);\n\n    if (pos == 0) {\n        if (!QIODevice::seek(pos))\n            return false;\n\n        // We can forget about the cached data\n        d->bNeedHeader = !d->bSkipHeaders;\n        d->result = KFilterBase::Ok;\n        d->filter->setInBuffer(nullptr, 0);\n        d->filter->reset();\n        d->deviceReadPos = 0;\n        return d->filter->device()->reset();\n    }\n\n    qint64 bytesToRead;\n    if (d->deviceReadPos < pos) { // we can start from here\n        bytesToRead = pos - d->deviceReadPos;\n        // Since we're going to do a read() below\n        // we need to reset the internal QIODevice pos to the real position we are\n        // so that after read() we are indeed pointing to the pos seek\n        // asked us to be in\n        if (!QIODevice::seek(d->deviceReadPos)) {\n            return false;\n        }\n    } else {\n        // we have to start from 0 ! Ugly and slow, but better than the previous\n        // solution (KTarGz was allocating everything into memory)\n        if (!seek(0)) { // recursive\n            return false;\n        }\n        bytesToRead = pos;\n    }\n\n    //qCDebug(KArchiveLog) << \"reading \" << bytesToRead << \" dummy bytes\";\n    QByteArray dummy(qMin(bytesToRead, qint64(3 * BUFFER_SIZE)), 0);\n    const bool result = (read(dummy.data(), bytesToRead) == bytesToRead);\n    return result;\n}\nbool KCompressionDevice::atEnd() const\n{\n    return (d->type == KCompressionDevice::None || d->result == KFilterBase::End)\n           && QIODevice::atEnd() // take QIODevice's internal buffer into account\n           && d->filter->device()->atEnd();\n}\n",
    "target": 1,
    "idx": 1014959,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nvoid LibRaw::kodak_rgb_load_raw()\n{\n  if (!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n  short buf[768], *bp;\n  int row, col, len, c, i, rgb[3], ret;\n  ushort *ip = image[0];\n\n  for (row = 0; row < height; row++)\n  {\n    checkCancel();\n    for (col = 0; col < width; col += 256)\n    {\n      len = MIN(256, width - col);\n      ret = kodak_65000_decode(buf, len * 3);\n      memset(rgb, 0, sizeof rgb);\n      for (bp = buf, i = 0; i < len; i++, ip += 4)\n        if (load_flags == 12)\n          FORC3 ip[c] = ret ? (*bp++) : (rgb[c] += *bp++);\n        else\n          FORC3 if ((ip[c] = ret ? (*bp++) : (rgb[c] += *bp++)) >> 12) derror();\n    }\n  }\n}\n\nvoid LibRaw::kodak_thumb_loader()\n{\n  INT64 est_datasize =\n      T.theight * T.twidth / 3; // is 0.3 bytes per pixel good estimate?\n  if (ID.toffset < 0)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  if (ID.toffset + est_datasize > ID.input->size() + THUMB_READ_BEYOND)\n    throw LIBRAW_EXCEPTION_IO_EOF;\n\n  if(INT64(T.theight) * INT64(T.twidth) > 1024ULL * 1024ULL * LIBRAW_MAX_THUMBNAIL_MB)\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  if (INT64(T.theight) * INT64(T.twidth) < 64ULL)\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  if(T.twidth < 16 || T.twidth > 8192 || T.theight < 16 || T.theight > 8192)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  // some kodak cameras\n  ushort s_height = S.height, s_width = S.width, s_iwidth = S.iwidth,\n         s_iheight = S.iheight;\n  ushort s_flags = libraw_internal_data.unpacker_data.load_flags;\n  libraw_internal_data.unpacker_data.load_flags = 12;\n  int s_colors = P1.colors;\n  unsigned s_filters = P1.filters;\n  ushort(*s_image)[4] = imgdata.image;\n\n  S.height = T.theight;\n  S.width = T.twidth;\n  P1.filters = 0;\n\n#define Tformat libraw_internal_data.unpacker_data.thumb_format\n\n\n  if (Tformat == LIBRAW_INTERNAL_THUMBNAIL_KODAK_YCBCR)\n  {\n    S.height += S.height & 1;\n    S.width += S.width & 1;\n  }\n\n  S.iheight = S.height;\n  S.iwidth = S.width;\n\n  imgdata.image =\n      (ushort(*)[4])calloc(S.iheight * S.iwidth, sizeof(*imgdata.image));\n\n  ID.input->seek(ID.toffset, SEEK_SET);\n  // read kodak thumbnail into T.image[]\n  try\n  {\n      if (Tformat == LIBRAW_INTERNAL_THUMBNAIL_KODAK_YCBCR)\n          kodak_ycbcr_load_raw();\n      else if(Tformat == LIBRAW_INTERNAL_THUMBNAIL_KODAK_RGB)\n        kodak_rgb_load_raw();\n      else if (Tformat == LIBRAW_INTERNAL_THUMBNAIL_KODAK_THUMB)\n        kodak_thumb_load_raw();\n  }\n  catch (...)\n  {\n    free(imgdata.image);\n    imgdata.image = s_image;\n\n    T.twidth = 0;\n    S.width = s_width;\n\n    S.iwidth = s_iwidth;\n    S.iheight = s_iheight;\n\n    T.theight = 0;\n    S.height = s_height;\n\n    T.tcolors = 0;\n    P1.colors = s_colors;\n\n    P1.filters = s_filters;\n    T.tlength = 0;\n    libraw_internal_data.unpacker_data.load_flags = s_flags;\n    return;\n  }\n\n  // from scale_colors\n  {\n    double dmax;\n    float scale_mul[4];\n    int c, val;\n    for (dmax = DBL_MAX, c = 0; c < 3; c++)\n      if (dmax > C.pre_mul[c])\n        dmax = C.pre_mul[c];\n\n    for (c = 0; c < 3; c++)\n      scale_mul[c] = (C.pre_mul[c] / dmax) * 65535.0 / C.maximum;\n    scale_mul[3] = scale_mul[1];\n\n    size_t size = S.height * S.width;\n    for (unsigned i = 0; i < size * 4; i++)\n    {\n      val = imgdata.image[0][i];\n      if (!val)\n        continue;\n      val *= scale_mul[i & 3];\n      imgdata.image[0][i] = CLIP(val);\n    }\n  }\n\n  // from convert_to_rgb\n  ushort *img;\n  int row, col;\n\n  int(*t_hist)[LIBRAW_HISTOGRAM_SIZE] =\n      (int(*)[LIBRAW_HISTOGRAM_SIZE])calloc(sizeof(*t_hist), 4);\n\n  float out[3], out_cam[3][4] = {{2.81761312f, -1.98369181f, 0.166078627f, 0},\n                                 {-0.111855984f, 1.73688626f, -0.625030339f, 0},\n                                 {-0.0379119813f, -0.891268849f, 1.92918086f, 0}};\n\n  for (img = imgdata.image[0], row = 0; row < S.height; row++)\n    for (col = 0; col < S.width; col++, img += 4)\n    {\n      out[0] = out[1] = out[2] = 0;\n      int c;\n      for (c = 0; c < 3; c++)\n      {\n        out[0] += out_cam[0][c] * img[c];\n        out[1] += out_cam[1][c] * img[c];\n        out[2] += out_cam[2][c] * img[c];\n      }\n      for (c = 0; c < 3; c++)\n        img[c] = CLIP((int)out[c]);\n      for (c = 0; c < P1.colors; c++)\n        t_hist[c][img[c] >> 3]++;\n    }\n\n  // from gamma_lut\n  int(*save_hist)[LIBRAW_HISTOGRAM_SIZE] =\n      libraw_internal_data.output_data.histogram;\n  libraw_internal_data.output_data.histogram = t_hist;\n\n  // make curve output curve!\n  ushort *t_curve = (ushort *)calloc(sizeof(C.curve), 1);\n  memmove(t_curve, C.curve, sizeof(C.curve));\n  memset(C.curve, 0, sizeof(C.curve));\n  {\n    int perc, val, total, t_white = 0x2000, c;\n\n    perc = S.width * S.height * 0.01; /* 99th percentile white level */\n    if (IO.fuji_width)\n      perc /= 2;\n    if (!((O.highlight & ~2) || O.no_auto_bright))\n      for (t_white = c = 0; c < P1.colors; c++)\n      {\n        for (val = 0x2000, total = 0; --val > 32;)\n          if ((total += libraw_internal_data.output_data.histogram[c][val]) >\n              perc)\n            break;\n        if (t_white < val)\n          t_white = val;\n      }\n    gamma_curve(O.gamm[0], O.gamm[1], 2, (t_white << 3) / O.bright);\n  }\n\n  libraw_internal_data.output_data.histogram = save_hist;\n  free(t_hist);\n\n  // from write_ppm_tiff - copy pixels into bitmap\n\n  int s_flip = imgdata.sizes.flip;\n  if (imgdata.rawparams.options & LIBRAW_RAWOPTIONS_NO_ROTATE_FOR_KODAK_THUMBNAILS)\n    imgdata.sizes.flip = 0;\n\n  S.iheight = S.height;\n  S.iwidth = S.width;\n  if (S.flip & 4)\n    SWAP(S.height, S.width);\n\n  if (T.thumb)\n    free(T.thumb);\n  T.thumb = (char *)calloc(S.width * S.height, P1.colors);\n  T.tlength = S.width * S.height * P1.colors;\n\n  // from write_tiff_ppm\n  {\n    int soff = flip_index(0, 0);\n    int cstep = flip_index(0, 1) - soff;\n    int rstep = flip_index(1, 0) - flip_index(0, S.width);\n\n    for (int rr = 0; rr < S.height; rr++, soff += rstep)\n    {\n      char *ppm = T.thumb + rr * S.width * P1.colors;\n      for (int cc = 0; cc < S.width; cc++, soff += cstep)\n        for (int c = 0; c < P1.colors; c++)\n          ppm[cc * P1.colors + c] =\n              imgdata.color.curve[imgdata.image[soff][c]] >> 8;\n    }\n  }\n\n  memmove(C.curve, t_curve, sizeof(C.curve));\n  free(t_curve);\n\n  // restore variables\n  free(imgdata.image);\n  imgdata.image = s_image;\n\n  if (imgdata.rawparams.options & LIBRAW_RAWOPTIONS_NO_ROTATE_FOR_KODAK_THUMBNAILS)\n    imgdata.sizes.flip = s_flip;\n\n  T.twidth = S.width;\n  S.width = s_width;\n\n  S.iwidth = s_iwidth;\n  S.iheight = s_iheight;\n\n  T.theight = S.height;\n  S.height = s_height;\n\n  T.tcolors = P1.colors;\n  P1.colors = s_colors;\n\n  P1.filters = s_filters;\n  libraw_internal_data.unpacker_data.load_flags = s_flags;\n}\n\nint LibRaw::unpack_thumb(void)\n{\n  CHECK_ORDER_LOW(LIBRAW_PROGRESS_IDENTIFY);\n  CHECK_ORDER_BIT(LIBRAW_PROGRESS_THUMB_LOAD);\n\n#define THUMB_SIZE_CHECKT(A) \\\n  do { \\\n    if (INT64(A) > 1024LL * 1024LL * LIBRAW_MAX_THUMBNAIL_MB) return LIBRAW_UNSUPPORTED_THUMBNAIL; \\\n    if (INT64(A) > 0 &&  INT64(A) < 64LL)        return LIBRAW_NO_THUMBNAIL; \\\n  } while (0)\n\n#define THUMB_SIZE_CHECKTNZ(A) \\\n  do { \\\n    if (INT64(A) > 1024LL * 1024LL * LIBRAW_MAX_THUMBNAIL_MB) return LIBRAW_UNSUPPORTED_THUMBNAIL; \\\n    if (INT64(A) < 64LL)        return LIBRAW_NO_THUMBNAIL; \\\n  } while (0)\n\n\n#define THUMB_SIZE_CHECKWH(W,H) \\\n  do { \\\n    if (INT64(W)*INT64(H) > 1024ULL * 1024ULL * LIBRAW_MAX_THUMBNAIL_MB) return LIBRAW_UNSUPPORTED_THUMBNAIL; \\\n    if (INT64(W)*INT64(H) < 64ULL)        return LIBRAW_NO_THUMBNAIL; \\\n  } while (0)\n\n#define Tformat libraw_internal_data.unpacker_data.thumb_format\n\n  try\n  {\n    if (!libraw_internal_data.internal_data.input)\n      return LIBRAW_INPUT_CLOSED;\n\n    int t_colors = libraw_internal_data.unpacker_data.thumb_misc >> 5 & 7;\n    int t_bytesps = (libraw_internal_data.unpacker_data.thumb_misc & 31) / 8;\n\n    if (!ID.toffset && !(imgdata.thumbnail.tlength > 0 &&\n                         load_raw == &LibRaw::broadcom_load_raw)  // RPi\n#ifdef USE_6BY9RPI\n        && !(imgdata.thumbnail.tlength > 0 && libraw_internal_data.unpacker_data.load_flags & 0x4000\n            && (load_raw == &LibRaw::rpi_load_raw8 || load_raw == &LibRaw::nokia_load_raw ||\n           load_raw == &LibRaw::rpi_load_raw12 || load_raw == &LibRaw::rpi_load_raw14))\n#endif\n    )\n    {\n      return LIBRAW_NO_THUMBNAIL;\n    }\n    else if ((Tformat >= LIBRAW_INTERNAL_THUMBNAIL_KODAK_THUMB)\n\t\t&& ((Tformat <= LIBRAW_INTERNAL_THUMBNAIL_KODAK_RGB)))\n    {\n      kodak_thumb_loader();\n      T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n      SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n      return 0;\n    }\n    else\n    {\n#ifdef USE_X3FTOOLS\n\tif (Tformat == LIBRAW_INTERNAL_THUMBNAIL_X3F)\n      {\n        INT64 tsize = x3f_thumb_size();\n        if (tsize < 2048 || INT64(ID.toffset) + tsize < 1)\n          throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n        if (INT64(ID.toffset) + tsize > ID.input->size() + THUMB_READ_BEYOND)\n          throw LIBRAW_EXCEPTION_IO_EOF;\n        THUMB_SIZE_CHECKT(tsize);\n      }\n#else\n\tif (0) {}\n#endif\n      else\n      {\n        if (INT64(ID.toffset) + INT64(T.tlength) < 1)\n          throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n        if (INT64(ID.toffset) + INT64(T.tlength) >\n            ID.input->size() + THUMB_READ_BEYOND)\n          throw LIBRAW_EXCEPTION_IO_EOF;\n      }\n\n      ID.input->seek(ID.toffset, SEEK_SET);\n      if (Tformat == LIBRAW_INTERNAL_THUMBNAIL_JPEG)\n      {\n        THUMB_SIZE_CHECKTNZ(T.tlength);\n        if (T.thumb)\n          free(T.thumb);\n        T.thumb = (char *)malloc(T.tlength);\n        ID.input->read(T.thumb, 1, T.tlength);\n\t\tunsigned char *tthumb = (unsigned char *)T.thumb;\n\t\tif (load_raw == &LibRaw::crxLoadRaw && T.tlength > 0xE0)\n\t\t{\n\t\t\t// Check if it is canon H.265 preview:  CISZ at bytes 4-6, CISZ prefix is 000n\n\t\t\tif (tthumb[0] == 0 && tthumb[1] == 0 && tthumb[2] == 0 && !memcmp(tthumb + 4, \"CISZ\", 4))\n\t\t\t{\n\t\t\t\tT.tformat = LIBRAW_THUMBNAIL_H265;\n\t\t\t\tSET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n        tthumb[0] = 0xff;\n        tthumb[1] = 0xd8;\n#ifdef NO_JPEG\n        T.tcolors = 3;\n#else\n        {\n          jpegErrorManager jerr;\n          struct jpeg_decompress_struct cinfo;\n          cinfo.err = jpeg_std_error(&jerr.pub);\n          jerr.pub.error_exit = jpegErrorExit;\n          if (setjmp(jerr.setjmp_buffer))\n          {\n          err2:\n            // Error in original JPEG thumb, read it again because\n            // original bytes 0-1 was damaged above\n            jpeg_destroy_decompress(&cinfo);\n            T.tcolors = 3;\n            T.tformat = LIBRAW_THUMBNAIL_UNKNOWN;\n            ID.input->seek(ID.toffset, SEEK_SET);\n            ID.input->read(T.thumb, 1, T.tlength);\n            SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n            return 0;\n          }\n          jpeg_create_decompress(&cinfo);\n          jpeg_mem_src(&cinfo, (unsigned char *)T.thumb, T.tlength);\n          int rc = jpeg_read_header(&cinfo, TRUE);\n          if (rc != 1)\n            goto err2;\n          T.tcolors = (cinfo.num_components > 0 && cinfo.num_components <= 3)\n                          ? cinfo.num_components\n                          : 3;\n          jpeg_destroy_decompress(&cinfo);\n        }\n#endif\n        T.tformat = LIBRAW_THUMBNAIL_JPEG;\n        SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n        return 0;\n      }\n      else if (Tformat == LIBRAW_INTERNAL_THUMBNAIL_LAYER)\n      {\n        int colors = libraw_internal_data.unpacker_data.thumb_misc >> 5 & 7;\n        if (colors != 1 && colors != 3)\n          return LIBRAW_UNSUPPORTED_THUMBNAIL;\n\n        THUMB_SIZE_CHECKWH(T.twidth, T.theight);\n\n        int tlength = T.twidth * T.theight;\n        if (T.thumb)\n          free(T.thumb);\n        T.thumb = (char *)calloc(colors, tlength);\n        unsigned char *tbuf = (unsigned char *)calloc(colors, tlength);\n        // Avoid OOB of tbuf, should use tlength\n        ID.input->read(tbuf, colors, tlength);\n        if (libraw_internal_data.unpacker_data.thumb_misc >> 8 &&\n            colors == 3) // GRB order\n          for (int i = 0; i < tlength; i++)\n          {\n            T.thumb[i * 3] = tbuf[i + tlength];\n            T.thumb[i * 3 + 1] = tbuf[i];\n            T.thumb[i * 3 + 2] = tbuf[i + 2 * tlength];\n          }\n        else if (colors == 3) // RGB or 1-channel\n          for (int i = 0; i < tlength; i++)\n          {\n            T.thumb[i * 3] = tbuf[i];\n            T.thumb[i * 3 + 1] = tbuf[i + tlength];\n            T.thumb[i * 3 + 2] = tbuf[i + 2 * tlength];\n          }\n        else if (colors == 1)\n        {\n          free(T.thumb);\n          T.thumb = (char *)tbuf;\n          tbuf = 0;\n        }\n        if (tbuf)\n          free(tbuf);\n        T.tcolors = colors;\n        T.tlength = colors * tlength;\n        T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n        SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n        return 0;\n      }\n      else if (Tformat == LIBRAW_INTERNAL_THUMBNAIL_ROLLEI)\n      {\n        int i;\n        THUMB_SIZE_CHECKWH(T.twidth, T.theight);\n        int tlength = T.twidth * T.theight;\n        if (T.thumb)\n          free(T.thumb);\n        T.tcolors = 3;\n        T.thumb = (char *)calloc(T.tcolors, tlength);\n        unsigned short *tbuf = (unsigned short *)calloc(2, tlength);\n        read_shorts(tbuf, tlength);\n        for (i = 0; i < tlength; i++)\n        {\n          T.thumb[i * 3] = (tbuf[i] << 3) & 0xff;\n          T.thumb[i * 3 + 1] = (tbuf[i] >> 5 << 2) & 0xff;\n          T.thumb[i * 3 + 2] = (tbuf[i] >> 11 << 3) & 0xff;\n        }\n        free(tbuf);\n        T.tlength = T.tcolors * tlength;\n        T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n        SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n        return 0;\n      }\n      else if (Tformat == LIBRAW_INTERNAL_THUMBNAIL_PPM)\n      {\n        if (t_bytesps > 1)\n          throw LIBRAW_EXCEPTION_IO_CORRUPT; // 8-bit thumb, but parsed for more\n                                             // bits\n        THUMB_SIZE_CHECKWH(T.twidth, T.theight);\n        int t_length = T.twidth * T.theight * t_colors;\n\n        if (T.tlength &&\n            (int)T.tlength < t_length) // try to find tiff ifd with needed offset\n        {\n          int pifd = find_ifd_by_offset(libraw_internal_data.internal_data.toffset);\n          if (pifd >= 0 && tiff_ifd[pifd].strip_offsets_count &&\n              tiff_ifd[pifd].strip_byte_counts_count)\n          {\n            // We found it, calculate final size\n            unsigned total_size = 0;\n            for (int i = 0; i < tiff_ifd[pifd].strip_byte_counts_count; i++)\n              total_size += tiff_ifd[pifd].strip_byte_counts[i];\n            if (total_size != (unsigned)t_length) // recalculate colors\n            {\n              if (total_size == T.twidth * T.tlength * 3)\n                T.tcolors = 3;\n              else if (total_size == T.twidth * T.tlength)\n                T.tcolors = 1;\n            }\n            T.tlength = total_size;\n            THUMB_SIZE_CHECKTNZ(T.tlength);\n            if (T.thumb)\n              free(T.thumb);\n            T.thumb = (char *)malloc(T.tlength);\n\n            char *dest = T.thumb;\n            INT64 pos = ID.input->tell();\n\n            for (int i = 0; i < tiff_ifd[pifd].strip_byte_counts_count &&\n                            i < tiff_ifd[pifd].strip_offsets_count;\n                 i++)\n            {\n              int remain = T.tlength;\n              int sz = tiff_ifd[pifd].strip_byte_counts[i];\n              int off = tiff_ifd[pifd].strip_offsets[i];\n              if (off >= 0 && off + sz <= ID.input->size() && sz <= remain)\n              {\n                ID.input->seek(off, SEEK_SET);\n                ID.input->read(dest, sz, 1);\n                remain -= sz;\n                dest += sz;\n              }\n            }\n            ID.input->seek(pos, SEEK_SET);\n            T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n            SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n            return 0;\n          }\n        }\n\n        if (!T.tlength)\n          T.tlength = t_length;\n        if (T.thumb)\n          free(T.thumb);\n\n        THUMB_SIZE_CHECKTNZ(T.tlength);\n\n        T.thumb = (char *)malloc(T.tlength);\n        if (!T.tcolors)\n          T.tcolors = t_colors;\n\n        ID.input->read(T.thumb, 1, T.tlength);\n\n        T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n        SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n        return 0;\n      }\n      else if (Tformat == LIBRAW_INTERNAL_THUMBNAIL_PPM16)\n      {\n        if (t_bytesps > 2)\n          throw LIBRAW_EXCEPTION_IO_CORRUPT; // 16-bit thumb, but parsed for\n                                             // more bits\n        int o_bps = (imgdata.rawparams.options & LIBRAW_RAWOPTIONS_USE_PPM16_THUMBS) ? 2 : 1;\n        int o_length = T.twidth * T.theight * t_colors * o_bps;\n        int i_length = T.twidth * T.theight * t_colors * 2;\n        if (!T.tlength)\n          T.tlength = o_length;\n        THUMB_SIZE_CHECKTNZ(o_length);\n        THUMB_SIZE_CHECKTNZ(i_length);\n        THUMB_SIZE_CHECKTNZ(T.tlength);\n\n        ushort *t_thumb = (ushort *)calloc(i_length, 1);\n        ID.input->read(t_thumb, 1, i_length);\n        if ((libraw_internal_data.unpacker_data.order == 0x4949) ==\n            (ntohs(0x1234) == 0x1234))\n          libraw_swab(t_thumb, i_length);\n\n        if (T.thumb)\n          free(T.thumb);\n        if ((imgdata.rawparams.options & LIBRAW_RAWOPTIONS_USE_PPM16_THUMBS))\n        {\n          T.thumb = (char *)t_thumb;\n          T.tformat = LIBRAW_THUMBNAIL_BITMAP16;\n        }\n        else\n        {\n          T.thumb = (char *)malloc(o_length);\n          for (int i = 0; i < o_length; i++)\n            T.thumb[i] = t_thumb[i] >> 8;\n          free(t_thumb);\n          T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n        }\n        SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n        return 0;\n      }\n#ifdef USE_X3FTOOLS\n\t  else if (Tformat == LIBRAW_INTERNAL_THUMBNAIL_X3F)\n      {\n        x3f_thumb_loader();\n        SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n        return 0;\n      }\n#endif\n      else\n      {\n        return LIBRAW_UNSUPPORTED_THUMBNAIL;\n      }\n    }\n    // last resort\n    return LIBRAW_UNSUPPORTED_THUMBNAIL; /* warned as unreachable*/\n  }\n  catch (const LibRaw_exceptions& err)\n  {\n    EXCEPTION_HANDLER(err);\n  }\n}\n\n\n// target function\nvoid LibRaw::kodak_thumb_loader()\n{\n  INT64 est_datasize =\n      T.theight * T.twidth / 3; // is 0.3 bytes per pixel good estimate?\n  if (ID.toffset < 0)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  if (ID.toffset + est_datasize > ID.input->size() + THUMB_READ_BEYOND)\n    throw LIBRAW_EXCEPTION_IO_EOF;\n\n  if(INT64(T.theight) * INT64(T.twidth) > 1024ULL * 1024ULL * LIBRAW_MAX_THUMBNAIL_MB)\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  if (INT64(T.theight) * INT64(T.twidth) < 64ULL)\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  if(T.twidth < 16 || T.twidth > 8192 || T.theight < 16 || T.theight > 8192)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  // some kodak cameras\n  ushort s_height = S.height, s_width = S.width, s_iwidth = S.iwidth,\n         s_iheight = S.iheight;\n  ushort s_flags = libraw_internal_data.unpacker_data.load_flags;\n  libraw_internal_data.unpacker_data.load_flags = 12;\n  int s_colors = P1.colors;\n  unsigned s_filters = P1.filters;\n  ushort(*s_image)[4] = imgdata.image;\n\n  S.height = T.theight;\n  S.width = T.twidth;\n  P1.filters = 0;\n\n#define Tformat libraw_internal_data.unpacker_data.thumb_format\n\n\n  if (Tformat == LIBRAW_INTERNAL_THUMBNAIL_KODAK_YCBCR)\n  {\n    S.height += S.height & 1;\n    S.width += S.width & 1;\n  }\n\n  imgdata.image =\n      (ushort(*)[4])calloc(S.iheight * S.iwidth, sizeof(*imgdata.image));\n\n  ID.input->seek(ID.toffset, SEEK_SET);\n  // read kodak thumbnail into T.image[]\n  try\n  {\n      if (Tformat == LIBRAW_INTERNAL_THUMBNAIL_KODAK_YCBCR)\n          kodak_ycbcr_load_raw();\n      else if(Tformat == LIBRAW_INTERNAL_THUMBNAIL_KODAK_RGB)\n        kodak_rgb_load_raw();\n      else if (Tformat == LIBRAW_INTERNAL_THUMBNAIL_KODAK_THUMB)\n        kodak_thumb_load_raw();\n  }\n  catch (...)\n  {\n    free(imgdata.image);\n    imgdata.image = s_image;\n\n    T.twidth = 0;\n    S.width = s_width;\n\n    S.iwidth = s_iwidth;\n    S.iheight = s_iheight;\n\n    T.theight = 0;\n    S.height = s_height;\n\n    T.tcolors = 0;\n    P1.colors = s_colors;\n\n    P1.filters = s_filters;\n    T.tlength = 0;\n    libraw_internal_data.unpacker_data.load_flags = s_flags;\n    return;\n  }\n\n  // from scale_colors\n  {\n    double dmax;\n    float scale_mul[4];\n    int c, val;\n    for (dmax = DBL_MAX, c = 0; c < 3; c++)\n      if (dmax > C.pre_mul[c])\n        dmax = C.pre_mul[c];\n\n    for (c = 0; c < 3; c++)\n      scale_mul[c] = (C.pre_mul[c] / dmax) * 65535.0 / C.maximum;\n    scale_mul[3] = scale_mul[1];\n\n    size_t size = S.height * S.width;\n    for (unsigned i = 0; i < size * 4; i++)\n    {\n      val = imgdata.image[0][i];\n      if (!val)\n        continue;\n      val *= scale_mul[i & 3];\n      imgdata.image[0][i] = CLIP(val);\n    }\n  }\n\n  // from convert_to_rgb\n  ushort *img;\n  int row, col;\n\n  int(*t_hist)[LIBRAW_HISTOGRAM_SIZE] =\n      (int(*)[LIBRAW_HISTOGRAM_SIZE])calloc(sizeof(*t_hist), 4);\n\n  float out[3], out_cam[3][4] = {{2.81761312f, -1.98369181f, 0.166078627f, 0},\n                                 {-0.111855984f, 1.73688626f, -0.625030339f, 0},\n                                 {-0.0379119813f, -0.891268849f, 1.92918086f, 0}};\n\n  for (img = imgdata.image[0], row = 0; row < S.height; row++)\n    for (col = 0; col < S.width; col++, img += 4)\n    {\n      out[0] = out[1] = out[2] = 0;\n      int c;\n      for (c = 0; c < 3; c++)\n      {\n        out[0] += out_cam[0][c] * img[c];\n        out[1] += out_cam[1][c] * img[c];\n        out[2] += out_cam[2][c] * img[c];\n      }\n      for (c = 0; c < 3; c++)\n        img[c] = CLIP((int)out[c]);\n      for (c = 0; c < P1.colors; c++)\n        t_hist[c][img[c] >> 3]++;\n    }\n\n  // from gamma_lut\n  int(*save_hist)[LIBRAW_HISTOGRAM_SIZE] =\n      libraw_internal_data.output_data.histogram;\n  libraw_internal_data.output_data.histogram = t_hist;\n\n  // make curve output curve!\n  ushort *t_curve = (ushort *)calloc(sizeof(C.curve), 1);\n  memmove(t_curve, C.curve, sizeof(C.curve));\n  memset(C.curve, 0, sizeof(C.curve));\n  {\n    int perc, val, total, t_white = 0x2000, c;\n\n    perc = S.width * S.height * 0.01; /* 99th percentile white level */\n    if (IO.fuji_width)\n      perc /= 2;\n    if (!((O.highlight & ~2) || O.no_auto_bright))\n      for (t_white = c = 0; c < P1.colors; c++)\n      {\n        for (val = 0x2000, total = 0; --val > 32;)\n          if ((total += libraw_internal_data.output_data.histogram[c][val]) >\n              perc)\n            break;\n        if (t_white < val)\n          t_white = val;\n      }\n    gamma_curve(O.gamm[0], O.gamm[1], 2, (t_white << 3) / O.bright);\n  }\n\n  libraw_internal_data.output_data.histogram = save_hist;\n  free(t_hist);\n\n  // from write_ppm_tiff - copy pixels into bitmap\n\n  int s_flip = imgdata.sizes.flip;\n  if (imgdata.rawparams.options & LIBRAW_RAWOPTIONS_NO_ROTATE_FOR_KODAK_THUMBNAILS)\n    imgdata.sizes.flip = 0;\n\n  S.iheight = S.height;\n  S.iwidth = S.width;\n  if (S.flip & 4)\n    SWAP(S.height, S.width);\n\n  if (T.thumb)\n    free(T.thumb);\n  T.thumb = (char *)calloc(S.width * S.height, P1.colors);\n  T.tlength = S.width * S.height * P1.colors;\n\n  // from write_tiff_ppm\n  {\n    int soff = flip_index(0, 0);\n    int cstep = flip_index(0, 1) - soff;\n    int rstep = flip_index(1, 0) - flip_index(0, S.width);\n\n    for (int rr = 0; rr < S.height; rr++, soff += rstep)\n    {\n      char *ppm = T.thumb + rr * S.width * P1.colors;\n      for (int cc = 0; cc < S.width; cc++, soff += cstep)\n        for (int c = 0; c < P1.colors; c++)\n          ppm[cc * P1.colors + c] =\n              imgdata.color.curve[imgdata.image[soff][c]] >> 8;\n    }\n  }\n\n  memmove(C.curve, t_curve, sizeof(C.curve));\n  free(t_curve);\n\n  // restore variables\n  free(imgdata.image);\n  imgdata.image = s_image;\n\n  if (imgdata.rawparams.options & LIBRAW_RAWOPTIONS_NO_ROTATE_FOR_KODAK_THUMBNAILS)\n    imgdata.sizes.flip = s_flip;\n\n  T.twidth = S.width;\n  S.width = s_width;\n\n  S.iwidth = s_iwidth;\n  S.iheight = s_iheight;\n\n  T.theight = S.height;\n  S.height = s_height;\n\n  T.tcolors = P1.colors;\n  P1.colors = s_colors;\n\n  P1.filters = s_filters;\n  libraw_internal_data.unpacker_data.load_flags = s_flags;\n}\n",
    "target": 1,
    "idx": 1052802,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nint LibRaw_file_datastream::read(void *ptr, size_t size, size_t nmemb)\n{\n/* Visual Studio 2008 marks sgetn as insecure, but VS2010 does not. */\n#if defined(WIN32SECURECALLS) && (_MSC_VER < 1600)\n  LR_STREAM_CHK();\n  return int(f->_Sgetn_s(static_cast<char *>(ptr), nmemb * size, nmemb * size) /\n             (size > 0 ? size : 1));\n#else\n  LR_STREAM_CHK();\n  return int(f->sgetn(static_cast<char *>(ptr), std::streamsize(nmemb * size)) /\n             (size > 0 ? size : 1));\n#endif\n}\n\nvoid LibRaw::read_shorts(ushort *pixel, unsigned count)\n{\n  if ((unsigned)fread(pixel, 2, count, ifp) < count)\n    derror();\n  if ((order == 0x4949) == (ntohs(0x1234) == 0x1234))\n    libraw_swab(pixel, count * 2);\n}\n\nvoid LibRaw::kodak_thumb_load_raw()\n{\n  if (!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n  int row, col;\n  colors = thumb_misc >> 5;\n  for (row = 0; row < height; row++)\n    for (col = 0; col < width; col++)\n      read_shorts(image[row * width + col], colors);\n  maximum = (1 << (thumb_misc & 31)) - 1;\n}\n\nvoid LibRaw::kodak_thumb_loader()\n{\n  INT64 est_datasize =\n      T.theight * T.twidth / 3; // is 0.3 bytes per pixel good estimate?\n  if (ID.toffset < 0)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  if (ID.toffset + est_datasize > ID.input->size() + THUMB_READ_BEYOND)\n    throw LIBRAW_EXCEPTION_IO_EOF;\n\n  if(INT64(T.theight) * INT64(T.twidth) > 1024ULL * 1024ULL * LIBRAW_MAX_THUMBNAIL_MB)\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  if (INT64(T.theight) * INT64(T.twidth) < 64ULL)\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  if(T.twidth < 16 || T.twidth > 8192 || T.theight < 16 || T.theight > 8192)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  // some kodak cameras\n  ushort s_height = S.height, s_width = S.width, s_iwidth = S.iwidth,\n         s_iheight = S.iheight;\n  ushort s_flags = libraw_internal_data.unpacker_data.load_flags;\n  libraw_internal_data.unpacker_data.load_flags = 12;\n  int s_colors = P1.colors;\n  unsigned s_filters = P1.filters;\n  ushort(*s_image)[4] = imgdata.image;\n\n  S.height = T.theight;\n  S.width = T.twidth;\n  P1.filters = 0;\n\n#define Tformat libraw_internal_data.unpacker_data.thumb_format\n\n\n  if (Tformat == LIBRAW_INTERNAL_THUMBNAIL_KODAK_YCBCR)\n  {\n    S.height += S.height & 1;\n    S.width += S.width & 1;\n  }\n\n  S.iheight = S.height;\n  S.iwidth = S.width;\n\n  imgdata.image =\n      (ushort(*)[4])calloc(S.iheight * S.iwidth, sizeof(*imgdata.image));\n\n  ID.input->seek(ID.toffset, SEEK_SET);\n  // read kodak thumbnail into T.image[]\n  try\n  {\n      if (Tformat == LIBRAW_INTERNAL_THUMBNAIL_KODAK_YCBCR)\n          kodak_ycbcr_load_raw();\n      else if(Tformat == LIBRAW_INTERNAL_THUMBNAIL_KODAK_RGB)\n        kodak_rgb_load_raw();\n      else if (Tformat == LIBRAW_INTERNAL_THUMBNAIL_KODAK_THUMB)\n        kodak_thumb_load_raw();\n  }\n  catch (...)\n  {\n    free(imgdata.image);\n    imgdata.image = s_image;\n\n    T.twidth = 0;\n    S.width = s_width;\n\n    S.iwidth = s_iwidth;\n    S.iheight = s_iheight;\n\n    T.theight = 0;\n    S.height = s_height;\n\n    T.tcolors = 0;\n    P1.colors = s_colors;\n\n    P1.filters = s_filters;\n    T.tlength = 0;\n    libraw_internal_data.unpacker_data.load_flags = s_flags;\n    return;\n  }\n\n  // from scale_colors\n  {\n    double dmax;\n    float scale_mul[4];\n    int c, val;\n    for (dmax = DBL_MAX, c = 0; c < 3; c++)\n      if (dmax > C.pre_mul[c])\n        dmax = C.pre_mul[c];\n\n    for (c = 0; c < 3; c++)\n      scale_mul[c] = (C.pre_mul[c] / dmax) * 65535.0 / C.maximum;\n    scale_mul[3] = scale_mul[1];\n\n    size_t size = S.height * S.width;\n    for (unsigned i = 0; i < size * 4; i++)\n    {\n      val = imgdata.image[0][i];\n      if (!val)\n        continue;\n      val *= scale_mul[i & 3];\n      imgdata.image[0][i] = CLIP(val);\n    }\n  }\n\n  // from convert_to_rgb\n  ushort *img;\n  int row, col;\n\n  int(*t_hist)[LIBRAW_HISTOGRAM_SIZE] =\n      (int(*)[LIBRAW_HISTOGRAM_SIZE])calloc(sizeof(*t_hist), 4);\n\n  float out[3], out_cam[3][4] = {{2.81761312f, -1.98369181f, 0.166078627f, 0},\n                                 {-0.111855984f, 1.73688626f, -0.625030339f, 0},\n                                 {-0.0379119813f, -0.891268849f, 1.92918086f, 0}};\n\n  for (img = imgdata.image[0], row = 0; row < S.height; row++)\n    for (col = 0; col < S.width; col++, img += 4)\n    {\n      out[0] = out[1] = out[2] = 0;\n      int c;\n      for (c = 0; c < 3; c++)\n      {\n        out[0] += out_cam[0][c] * img[c];\n        out[1] += out_cam[1][c] * img[c];\n        out[2] += out_cam[2][c] * img[c];\n      }\n      for (c = 0; c < 3; c++)\n        img[c] = CLIP((int)out[c]);\n      for (c = 0; c < P1.colors; c++)\n        t_hist[c][img[c] >> 3]++;\n    }\n\n  // from gamma_lut\n  int(*save_hist)[LIBRAW_HISTOGRAM_SIZE] =\n      libraw_internal_data.output_data.histogram;\n  libraw_internal_data.output_data.histogram = t_hist;\n\n  // make curve output curve!\n  ushort *t_curve = (ushort *)calloc(sizeof(C.curve), 1);\n  memmove(t_curve, C.curve, sizeof(C.curve));\n  memset(C.curve, 0, sizeof(C.curve));\n  {\n    int perc, val, total, t_white = 0x2000, c;\n\n    perc = S.width * S.height * 0.01; /* 99th percentile white level */\n    if (IO.fuji_width)\n      perc /= 2;\n    if (!((O.highlight & ~2) || O.no_auto_bright))\n      for (t_white = c = 0; c < P1.colors; c++)\n      {\n        for (val = 0x2000, total = 0; --val > 32;)\n          if ((total += libraw_internal_data.output_data.histogram[c][val]) >\n              perc)\n            break;\n        if (t_white < val)\n          t_white = val;\n      }\n    gamma_curve(O.gamm[0], O.gamm[1], 2, (t_white << 3) / O.bright);\n  }\n\n  libraw_internal_data.output_data.histogram = save_hist;\n  free(t_hist);\n\n  // from write_ppm_tiff - copy pixels into bitmap\n\n  int s_flip = imgdata.sizes.flip;\n  if (imgdata.rawparams.options & LIBRAW_RAWOPTIONS_NO_ROTATE_FOR_KODAK_THUMBNAILS)\n    imgdata.sizes.flip = 0;\n\n  S.iheight = S.height;\n  S.iwidth = S.width;\n  if (S.flip & 4)\n    SWAP(S.height, S.width);\n\n  if (T.thumb)\n    free(T.thumb);\n  T.thumb = (char *)calloc(S.width * S.height, P1.colors);\n  T.tlength = S.width * S.height * P1.colors;\n\n  // from write_tiff_ppm\n  {\n    int soff = flip_index(0, 0);\n    int cstep = flip_index(0, 1) - soff;\n    int rstep = flip_index(1, 0) - flip_index(0, S.width);\n\n    for (int rr = 0; rr < S.height; rr++, soff += rstep)\n    {\n      char *ppm = T.thumb + rr * S.width * P1.colors;\n      for (int cc = 0; cc < S.width; cc++, soff += cstep)\n        for (int c = 0; c < P1.colors; c++)\n          ppm[cc * P1.colors + c] =\n              imgdata.color.curve[imgdata.image[soff][c]] >> 8;\n    }\n  }\n\n  memmove(C.curve, t_curve, sizeof(C.curve));\n  free(t_curve);\n\n  // restore variables\n  free(imgdata.image);\n  imgdata.image = s_image;\n\n  if (imgdata.rawparams.options & LIBRAW_RAWOPTIONS_NO_ROTATE_FOR_KODAK_THUMBNAILS)\n    imgdata.sizes.flip = s_flip;\n\n  T.twidth = S.width;\n  S.width = s_width;\n\n  S.iwidth = s_iwidth;\n  S.iheight = s_iheight;\n\n  T.theight = S.height;\n  S.height = s_height;\n\n  T.tcolors = P1.colors;\n  P1.colors = s_colors;\n\n  P1.filters = s_filters;\n  libraw_internal_data.unpacker_data.load_flags = s_flags;\n}\n\nint LibRaw::unpack_thumb(void)\n{\n  CHECK_ORDER_LOW(LIBRAW_PROGRESS_IDENTIFY);\n  CHECK_ORDER_BIT(LIBRAW_PROGRESS_THUMB_LOAD);\n\n#define THUMB_SIZE_CHECKT(A) \\\n  do { \\\n    if (INT64(A) > 1024LL * 1024LL * LIBRAW_MAX_THUMBNAIL_MB) return LIBRAW_UNSUPPORTED_THUMBNAIL; \\\n    if (INT64(A) > 0 &&  INT64(A) < 64LL)        return LIBRAW_NO_THUMBNAIL; \\\n  } while (0)\n\n#define THUMB_SIZE_CHECKTNZ(A) \\\n  do { \\\n    if (INT64(A) > 1024LL * 1024LL * LIBRAW_MAX_THUMBNAIL_MB) return LIBRAW_UNSUPPORTED_THUMBNAIL; \\\n    if (INT64(A) < 64LL)        return LIBRAW_NO_THUMBNAIL; \\\n  } while (0)\n\n\n#define THUMB_SIZE_CHECKWH(W,H) \\\n  do { \\\n    if (INT64(W)*INT64(H) > 1024ULL * 1024ULL * LIBRAW_MAX_THUMBNAIL_MB) return LIBRAW_UNSUPPORTED_THUMBNAIL; \\\n    if (INT64(W)*INT64(H) < 64ULL)        return LIBRAW_NO_THUMBNAIL; \\\n  } while (0)\n\n#define Tformat libraw_internal_data.unpacker_data.thumb_format\n\n  try\n  {\n    if (!libraw_internal_data.internal_data.input)\n      return LIBRAW_INPUT_CLOSED;\n\n    int t_colors = libraw_internal_data.unpacker_data.thumb_misc >> 5 & 7;\n    int t_bytesps = (libraw_internal_data.unpacker_data.thumb_misc & 31) / 8;\n\n    if (!ID.toffset && !(imgdata.thumbnail.tlength > 0 &&\n                         load_raw == &LibRaw::broadcom_load_raw)  // RPi\n#ifdef USE_6BY9RPI\n        && !(imgdata.thumbnail.tlength > 0 && libraw_internal_data.unpacker_data.load_flags & 0x4000\n            && (load_raw == &LibRaw::rpi_load_raw8 || load_raw == &LibRaw::nokia_load_raw ||\n           load_raw == &LibRaw::rpi_load_raw12 || load_raw == &LibRaw::rpi_load_raw14))\n#endif\n    )\n    {\n      return LIBRAW_NO_THUMBNAIL;\n    }\n    else if ((Tformat >= LIBRAW_INTERNAL_THUMBNAIL_KODAK_THUMB)\n\t\t&& ((Tformat <= LIBRAW_INTERNAL_THUMBNAIL_KODAK_RGB)))\n    {\n      kodak_thumb_loader();\n      T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n      SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n      return 0;\n    }\n    else\n    {\n#ifdef USE_X3FTOOLS\n\tif (Tformat == LIBRAW_INTERNAL_THUMBNAIL_X3F)\n      {\n        INT64 tsize = x3f_thumb_size();\n        if (tsize < 2048 || INT64(ID.toffset) + tsize < 1)\n          throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n        if (INT64(ID.toffset) + tsize > ID.input->size() + THUMB_READ_BEYOND)\n          throw LIBRAW_EXCEPTION_IO_EOF;\n        THUMB_SIZE_CHECKT(tsize);\n      }\n#else\n\tif (0) {}\n#endif\n      else\n      {\n        if (INT64(ID.toffset) + INT64(T.tlength) < 1)\n          throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n        if (INT64(ID.toffset) + INT64(T.tlength) >\n            ID.input->size() + THUMB_READ_BEYOND)\n          throw LIBRAW_EXCEPTION_IO_EOF;\n      }\n\n      ID.input->seek(ID.toffset, SEEK_SET);\n      if (Tformat == LIBRAW_INTERNAL_THUMBNAIL_JPEG)\n      {\n        THUMB_SIZE_CHECKTNZ(T.tlength);\n        if (T.thumb)\n          free(T.thumb);\n        T.thumb = (char *)malloc(T.tlength);\n        ID.input->read(T.thumb, 1, T.tlength);\n\t\tunsigned char *tthumb = (unsigned char *)T.thumb;\n\t\tif (load_raw == &LibRaw::crxLoadRaw && T.tlength > 0xE0)\n\t\t{\n\t\t\t// Check if it is canon H.265 preview:  CISZ at bytes 4-6, CISZ prefix is 000n\n\t\t\tif (tthumb[0] == 0 && tthumb[1] == 0 && tthumb[2] == 0 && !memcmp(tthumb + 4, \"CISZ\", 4))\n\t\t\t{\n\t\t\t\tT.tformat = LIBRAW_THUMBNAIL_H265;\n\t\t\t\tSET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n        tthumb[0] = 0xff;\n        tthumb[1] = 0xd8;\n#ifdef NO_JPEG\n        T.tcolors = 3;\n#else\n        {\n          jpegErrorManager jerr;\n          struct jpeg_decompress_struct cinfo;\n          cinfo.err = jpeg_std_error(&jerr.pub);\n          jerr.pub.error_exit = jpegErrorExit;\n          if (setjmp(jerr.setjmp_buffer))\n          {\n          err2:\n            // Error in original JPEG thumb, read it again because\n            // original bytes 0-1 was damaged above\n            jpeg_destroy_decompress(&cinfo);\n            T.tcolors = 3;\n            T.tformat = LIBRAW_THUMBNAIL_UNKNOWN;\n            ID.input->seek(ID.toffset, SEEK_SET);\n            ID.input->read(T.thumb, 1, T.tlength);\n            SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n            return 0;\n          }\n          jpeg_create_decompress(&cinfo);\n          jpeg_mem_src(&cinfo, (unsigned char *)T.thumb, T.tlength);\n          int rc = jpeg_read_header(&cinfo, TRUE);\n          if (rc != 1)\n            goto err2;\n          T.tcolors = (cinfo.num_components > 0 && cinfo.num_components <= 3)\n                          ? cinfo.num_components\n                          : 3;\n          jpeg_destroy_decompress(&cinfo);\n        }\n#endif\n        T.tformat = LIBRAW_THUMBNAIL_JPEG;\n        SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n        return 0;\n      }\n      else if (Tformat == LIBRAW_INTERNAL_THUMBNAIL_LAYER)\n      {\n        int colors = libraw_internal_data.unpacker_data.thumb_misc >> 5 & 7;\n        if (colors != 1 && colors != 3)\n          return LIBRAW_UNSUPPORTED_THUMBNAIL;\n\n        THUMB_SIZE_CHECKWH(T.twidth, T.theight);\n\n        int tlength = T.twidth * T.theight;\n        if (T.thumb)\n          free(T.thumb);\n        T.thumb = (char *)calloc(colors, tlength);\n        unsigned char *tbuf = (unsigned char *)calloc(colors, tlength);\n        // Avoid OOB of tbuf, should use tlength\n        ID.input->read(tbuf, colors, tlength);\n        if (libraw_internal_data.unpacker_data.thumb_misc >> 8 &&\n            colors == 3) // GRB order\n          for (int i = 0; i < tlength; i++)\n          {\n            T.thumb[i * 3] = tbuf[i + tlength];\n            T.thumb[i * 3 + 1] = tbuf[i];\n            T.thumb[i * 3 + 2] = tbuf[i + 2 * tlength];\n          }\n        else if (colors == 3) // RGB or 1-channel\n          for (int i = 0; i < tlength; i++)\n          {\n            T.thumb[i * 3] = tbuf[i];\n            T.thumb[i * 3 + 1] = tbuf[i + tlength];\n            T.thumb[i * 3 + 2] = tbuf[i + 2 * tlength];\n          }\n        else if (colors == 1)\n        {\n          free(T.thumb);\n          T.thumb = (char *)tbuf;\n          tbuf = 0;\n        }\n        if (tbuf)\n          free(tbuf);\n        T.tcolors = colors;\n        T.tlength = colors * tlength;\n        T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n        SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n        return 0;\n      }\n      else if (Tformat == LIBRAW_INTERNAL_THUMBNAIL_ROLLEI)\n      {\n        int i;\n        THUMB_SIZE_CHECKWH(T.twidth, T.theight);\n        int tlength = T.twidth * T.theight;\n        if (T.thumb)\n          free(T.thumb);\n        T.tcolors = 3;\n        T.thumb = (char *)calloc(T.tcolors, tlength);\n        unsigned short *tbuf = (unsigned short *)calloc(2, tlength);\n        read_shorts(tbuf, tlength);\n        for (i = 0; i < tlength; i++)\n        {\n          T.thumb[i * 3] = (tbuf[i] << 3) & 0xff;\n          T.thumb[i * 3 + 1] = (tbuf[i] >> 5 << 2) & 0xff;\n          T.thumb[i * 3 + 2] = (tbuf[i] >> 11 << 3) & 0xff;\n        }\n        free(tbuf);\n        T.tlength = T.tcolors * tlength;\n        T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n        SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n        return 0;\n      }\n      else if (Tformat == LIBRAW_INTERNAL_THUMBNAIL_PPM)\n      {\n        if (t_bytesps > 1)\n          throw LIBRAW_EXCEPTION_IO_CORRUPT; // 8-bit thumb, but parsed for more\n                                             // bits\n        THUMB_SIZE_CHECKWH(T.twidth, T.theight);\n        int t_length = T.twidth * T.theight * t_colors;\n\n        if (T.tlength &&\n            (int)T.tlength < t_length) // try to find tiff ifd with needed offset\n        {\n          int pifd = find_ifd_by_offset(libraw_internal_data.internal_data.toffset);\n          if (pifd >= 0 && tiff_ifd[pifd].strip_offsets_count &&\n              tiff_ifd[pifd].strip_byte_counts_count)\n          {\n            // We found it, calculate final size\n            unsigned total_size = 0;\n            for (int i = 0; i < tiff_ifd[pifd].strip_byte_counts_count; i++)\n              total_size += tiff_ifd[pifd].strip_byte_counts[i];\n            if (total_size != (unsigned)t_length) // recalculate colors\n            {\n              if (total_size == T.twidth * T.tlength * 3)\n                T.tcolors = 3;\n              else if (total_size == T.twidth * T.tlength)\n                T.tcolors = 1;\n            }\n            T.tlength = total_size;\n            THUMB_SIZE_CHECKTNZ(T.tlength);\n            if (T.thumb)\n              free(T.thumb);\n            T.thumb = (char *)malloc(T.tlength);\n\n            char *dest = T.thumb;\n            INT64 pos = ID.input->tell();\n\n            for (int i = 0; i < tiff_ifd[pifd].strip_byte_counts_count &&\n                            i < tiff_ifd[pifd].strip_offsets_count;\n                 i++)\n            {\n              int remain = T.tlength;\n              int sz = tiff_ifd[pifd].strip_byte_counts[i];\n              int off = tiff_ifd[pifd].strip_offsets[i];\n              if (off >= 0 && off + sz <= ID.input->size() && sz <= remain)\n              {\n                ID.input->seek(off, SEEK_SET);\n                ID.input->read(dest, sz, 1);\n                remain -= sz;\n                dest += sz;\n              }\n            }\n            ID.input->seek(pos, SEEK_SET);\n            T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n            SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n            return 0;\n          }\n        }\n\n        if (!T.tlength)\n          T.tlength = t_length;\n        if (T.thumb)\n          free(T.thumb);\n\n        THUMB_SIZE_CHECKTNZ(T.tlength);\n\n        T.thumb = (char *)malloc(T.tlength);\n        if (!T.tcolors)\n          T.tcolors = t_colors;\n\n        ID.input->read(T.thumb, 1, T.tlength);\n\n        T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n        SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n        return 0;\n      }\n      else if (Tformat == LIBRAW_INTERNAL_THUMBNAIL_PPM16)\n      {\n        if (t_bytesps > 2)\n          throw LIBRAW_EXCEPTION_IO_CORRUPT; // 16-bit thumb, but parsed for\n                                             // more bits\n        int o_bps = (imgdata.rawparams.options & LIBRAW_RAWOPTIONS_USE_PPM16_THUMBS) ? 2 : 1;\n        int o_length = T.twidth * T.theight * t_colors * o_bps;\n        int i_length = T.twidth * T.theight * t_colors * 2;\n        if (!T.tlength)\n          T.tlength = o_length;\n        THUMB_SIZE_CHECKTNZ(o_length);\n        THUMB_SIZE_CHECKTNZ(i_length);\n        THUMB_SIZE_CHECKTNZ(T.tlength);\n\n        ushort *t_thumb = (ushort *)calloc(i_length, 1);\n        ID.input->read(t_thumb, 1, i_length);\n        if ((libraw_internal_data.unpacker_data.order == 0x4949) ==\n            (ntohs(0x1234) == 0x1234))\n          libraw_swab(t_thumb, i_length);\n\n        if (T.thumb)\n          free(T.thumb);\n        if ((imgdata.rawparams.options & LIBRAW_RAWOPTIONS_USE_PPM16_THUMBS))\n        {\n          T.thumb = (char *)t_thumb;\n          T.tformat = LIBRAW_THUMBNAIL_BITMAP16;\n        }\n        else\n        {\n          T.thumb = (char *)malloc(o_length);\n          for (int i = 0; i < o_length; i++)\n            T.thumb[i] = t_thumb[i] >> 8;\n          free(t_thumb);\n          T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n        }\n        SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n        return 0;\n      }\n#ifdef USE_X3FTOOLS\n\t  else if (Tformat == LIBRAW_INTERNAL_THUMBNAIL_X3F)\n      {\n        x3f_thumb_loader();\n        SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n        return 0;\n      }\n#endif\n      else\n      {\n        return LIBRAW_UNSUPPORTED_THUMBNAIL;\n      }\n    }\n    // last resort\n    return LIBRAW_UNSUPPORTED_THUMBNAIL; /* warned as unreachable*/\n  }\n  catch (const LibRaw_exceptions& err)\n  {\n    EXCEPTION_HANDLER(err);\n  }\n}\n\n\n// target function\nvoid LibRaw::kodak_thumb_loader()\n{\n  INT64 est_datasize =\n      T.theight * T.twidth / 3; // is 0.3 bytes per pixel good estimate?\n  if (ID.toffset < 0)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  if (ID.toffset + est_datasize > ID.input->size() + THUMB_READ_BEYOND)\n    throw LIBRAW_EXCEPTION_IO_EOF;\n\n  if(INT64(T.theight) * INT64(T.twidth) > 1024ULL * 1024ULL * LIBRAW_MAX_THUMBNAIL_MB)\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  if (INT64(T.theight) * INT64(T.twidth) < 64ULL)\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  if(T.twidth < 16 || T.twidth > 8192 || T.theight < 16 || T.theight > 8192)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  // some kodak cameras\n  ushort s_height = S.height, s_width = S.width, s_iwidth = S.iwidth,\n         s_iheight = S.iheight;\n  ushort s_flags = libraw_internal_data.unpacker_data.load_flags;\n  libraw_internal_data.unpacker_data.load_flags = 12;\n  int s_colors = P1.colors;\n  unsigned s_filters = P1.filters;\n  ushort(*s_image)[4] = imgdata.image;\n\n  S.height = T.theight;\n  S.width = T.twidth;\n  P1.filters = 0;\n\n#define Tformat libraw_internal_data.unpacker_data.thumb_format\n\n\n  if (Tformat == LIBRAW_INTERNAL_THUMBNAIL_KODAK_YCBCR)\n  {\n    S.height += S.height & 1;\n    S.width += S.width & 1;\n  }\n\n  imgdata.image =\n      (ushort(*)[4])calloc(S.iheight * S.iwidth, sizeof(*imgdata.image));\n\n  ID.input->seek(ID.toffset, SEEK_SET);\n  // read kodak thumbnail into T.image[]\n  try\n  {\n      if (Tformat == LIBRAW_INTERNAL_THUMBNAIL_KODAK_YCBCR)\n          kodak_ycbcr_load_raw();\n      else if(Tformat == LIBRAW_INTERNAL_THUMBNAIL_KODAK_RGB)\n        kodak_rgb_load_raw();\n      else if (Tformat == LIBRAW_INTERNAL_THUMBNAIL_KODAK_THUMB)\n        kodak_thumb_load_raw();\n  }\n  catch (...)\n  {\n    free(imgdata.image);\n    imgdata.image = s_image;\n\n    T.twidth = 0;\n    S.width = s_width;\n\n    S.iwidth = s_iwidth;\n    S.iheight = s_iheight;\n\n    T.theight = 0;\n    S.height = s_height;\n\n    T.tcolors = 0;\n    P1.colors = s_colors;\n\n    P1.filters = s_filters;\n    T.tlength = 0;\n    libraw_internal_data.unpacker_data.load_flags = s_flags;\n    return;\n  }\n\n  // from scale_colors\n  {\n    double dmax;\n    float scale_mul[4];\n    int c, val;\n    for (dmax = DBL_MAX, c = 0; c < 3; c++)\n      if (dmax > C.pre_mul[c])\n        dmax = C.pre_mul[c];\n\n    for (c = 0; c < 3; c++)\n      scale_mul[c] = (C.pre_mul[c] / dmax) * 65535.0 / C.maximum;\n    scale_mul[3] = scale_mul[1];\n\n    size_t size = S.height * S.width;\n    for (unsigned i = 0; i < size * 4; i++)\n    {\n      val = imgdata.image[0][i];\n      if (!val)\n        continue;\n      val *= scale_mul[i & 3];\n      imgdata.image[0][i] = CLIP(val);\n    }\n  }\n\n  // from convert_to_rgb\n  ushort *img;\n  int row, col;\n\n  int(*t_hist)[LIBRAW_HISTOGRAM_SIZE] =\n      (int(*)[LIBRAW_HISTOGRAM_SIZE])calloc(sizeof(*t_hist), 4);\n\n  float out[3], out_cam[3][4] = {{2.81761312f, -1.98369181f, 0.166078627f, 0},\n                                 {-0.111855984f, 1.73688626f, -0.625030339f, 0},\n                                 {-0.0379119813f, -0.891268849f, 1.92918086f, 0}};\n\n  for (img = imgdata.image[0], row = 0; row < S.height; row++)\n    for (col = 0; col < S.width; col++, img += 4)\n    {\n      out[0] = out[1] = out[2] = 0;\n      int c;\n      for (c = 0; c < 3; c++)\n      {\n        out[0] += out_cam[0][c] * img[c];\n        out[1] += out_cam[1][c] * img[c];\n        out[2] += out_cam[2][c] * img[c];\n      }\n      for (c = 0; c < 3; c++)\n        img[c] = CLIP((int)out[c]);\n      for (c = 0; c < P1.colors; c++)\n        t_hist[c][img[c] >> 3]++;\n    }\n\n  // from gamma_lut\n  int(*save_hist)[LIBRAW_HISTOGRAM_SIZE] =\n      libraw_internal_data.output_data.histogram;\n  libraw_internal_data.output_data.histogram = t_hist;\n\n  // make curve output curve!\n  ushort *t_curve = (ushort *)calloc(sizeof(C.curve), 1);\n  memmove(t_curve, C.curve, sizeof(C.curve));\n  memset(C.curve, 0, sizeof(C.curve));\n  {\n    int perc, val, total, t_white = 0x2000, c;\n\n    perc = S.width * S.height * 0.01; /* 99th percentile white level */\n    if (IO.fuji_width)\n      perc /= 2;\n    if (!((O.highlight & ~2) || O.no_auto_bright))\n      for (t_white = c = 0; c < P1.colors; c++)\n      {\n        for (val = 0x2000, total = 0; --val > 32;)\n          if ((total += libraw_internal_data.output_data.histogram[c][val]) >\n              perc)\n            break;\n        if (t_white < val)\n          t_white = val;\n      }\n    gamma_curve(O.gamm[0], O.gamm[1], 2, (t_white << 3) / O.bright);\n  }\n\n  libraw_internal_data.output_data.histogram = save_hist;\n  free(t_hist);\n\n  // from write_ppm_tiff - copy pixels into bitmap\n\n  int s_flip = imgdata.sizes.flip;\n  if (imgdata.rawparams.options & LIBRAW_RAWOPTIONS_NO_ROTATE_FOR_KODAK_THUMBNAILS)\n    imgdata.sizes.flip = 0;\n\n  S.iheight = S.height;\n  S.iwidth = S.width;\n  if (S.flip & 4)\n    SWAP(S.height, S.width);\n\n  if (T.thumb)\n    free(T.thumb);\n  T.thumb = (char *)calloc(S.width * S.height, P1.colors);\n  T.tlength = S.width * S.height * P1.colors;\n\n  // from write_tiff_ppm\n  {\n    int soff = flip_index(0, 0);\n    int cstep = flip_index(0, 1) - soff;\n    int rstep = flip_index(1, 0) - flip_index(0, S.width);\n\n    for (int rr = 0; rr < S.height; rr++, soff += rstep)\n    {\n      char *ppm = T.thumb + rr * S.width * P1.colors;\n      for (int cc = 0; cc < S.width; cc++, soff += cstep)\n        for (int c = 0; c < P1.colors; c++)\n          ppm[cc * P1.colors + c] =\n              imgdata.color.curve[imgdata.image[soff][c]] >> 8;\n    }\n  }\n\n  memmove(C.curve, t_curve, sizeof(C.curve));\n  free(t_curve);\n\n  // restore variables\n  free(imgdata.image);\n  imgdata.image = s_image;\n\n  if (imgdata.rawparams.options & LIBRAW_RAWOPTIONS_NO_ROTATE_FOR_KODAK_THUMBNAILS)\n    imgdata.sizes.flip = s_flip;\n\n  T.twidth = S.width;\n  S.width = s_width;\n\n  S.iwidth = s_iwidth;\n  S.iheight = s_iheight;\n\n  T.theight = S.height;\n  S.height = s_height;\n\n  T.tcolors = P1.colors;\n  P1.colors = s_colors;\n\n  P1.filters = s_filters;\n  libraw_internal_data.unpacker_data.load_flags = s_flags;\n}\n",
    "target": 1,
    "idx": 1052579,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic inline void SetPixelRed(const Image *magick_restrict image,\n  const Quantum red,Quantum *magick_restrict pixel)\n{\n  pixel[image->channel_map[RedPixelChannel].offset]=red;\n}\n\n\n\n\n\n\n\n\n\nvoid Magick::Image::ping(const Blob& blob_)\n{\n  MagickCore::Image\n    *newImage;\n\n  GetPPException;\n  newImage=PingBlob(imageInfo(),blob_.data(),blob_.length(),exceptionInfo);\n  read(newImage,exceptionInfo);\n}\n\n\n// target function\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WriteQOIImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  MagickBooleanType\n    status;\n\n  const Quantum\n    *p;\n\n  size_t\n    channels,\n    colorspace,\n    end,\n    run,\n    idx,\n    i;\n\n  qoi_rgba_t\n    px,\n    pp,\n    lut[64];\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  image->endian=MSBEndian;\n  image->depth=8;\n\n  quantum_info=AcquireQuantumInfo(image_info,image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    ThrowWriterException(ImageError,\"MemoryAllocationFailed\");\n\n  quantum_type=GetQuantumType(image,exception);\n  if (quantum_type == RGBQuantum)\n    channels=3;\n  else if (quantum_type == RGBAQuantum)\n    channels=4;\n  else\n    ThrowWriterException(ImageError,\"MemoryAllocationFailed\");\n\n  if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n   (void) TransformImageColorspace(image,sRGBColorspace,exception);\n  if (IsRGBColorspace(image->colorspace))\n     colorspace=QOI_LINEAR;\n  else\n     colorspace=QOI_SRGB;\n  /*\n    Write QOI header.\n  */\n  (void) WriteBlobString(image,\"qoif\");\n  (void) WriteBlobMSBLong(image,(unsigned int) image->columns);\n  (void) WriteBlobMSBLong(image,(unsigned int) image->rows);\n  (void) WriteBlobByte(image,(const unsigned char) channels);\n  (void) WriteBlobByte(image,(const unsigned char) colorspace);\n  /*\n    Initialize encoding state.\n  */\n  px.rgba.r=0;\n  px.rgba.g=0;\n  px.rgba.b=0;\n  px.rgba.a=255;\n  memset(lut,0,sizeof(lut));\n  run=0;\n  p=GetVirtualPixels(image,0,0,image->columns,image->rows,exception);\n  if (p == (const Quantum *) NULL)\n    return(MagickFalse);\n  /*\n    Do the actual encoding.\n  */\n  end = image->rows * image->columns;\n  for (i=0; i < end; i++) {\n    pp=px;\n    px.rgba.r=ScaleQuantumToChar(GetPixelRed(image,p));\n    px.rgba.g=ScaleQuantumToChar(GetPixelGreen(image,p));\n    px.rgba.b=ScaleQuantumToChar(GetPixelBlue(image,p));\n    if (channels == 4)\n      px.rgba.a=ScaleQuantumToChar(GetPixelAlpha(image,p));\n    p+=GetPixelChannels(image);\n\n    if (pp.v == px.v) {\n      run++;\n      if (run == 62) {\n        (void) WriteBlobByte(image,QOI_OP_RUN |\n          (const unsigned char) (run - 1));\n        run=0;\n      }\n      continue;\n    }\n    if (run > 0) {\n      (void) WriteBlobByte(image,QOI_OP_RUN | (const unsigned char) (run - 1));\n      run=0;\n    }\n    idx=QOI_COLOR_HASH(px) % 64;\n    if (lut[idx].v == px.v) {\n      (void) WriteBlobByte(image,QOI_OP_INDEX | (const unsigned char) idx);\n      continue;\n    }\n    lut[QOI_COLOR_HASH(px) % 64]=px;\n    if (pp.rgba.a == px.rgba.a) {\n      signed char\n        vr,\n        vg,\n        vb,\n        vg_r,\n        vg_b;\n      vr=px.rgba.r - pp.rgba.r;\n      vg=px.rgba.g - pp.rgba.g;\n      vb=px.rgba.b - pp.rgba.b;\n      vg_r=vr - vg;\n      vg_b=vb - vg;\n\n      if (vr > -3 && vr < 2 &&\n          vg > -3 && vg < 2 &&\n          vb > -3 && vb < 2) {\n        (void) WriteBlobByte(image,QOI_OP_DIFF\n                 | (vr + 2) << 4 | (vg + 2) << 2 | (vb + 2));\n      } else if (vg_r >  -9 && vg_r < 8 &&\n                 vg   > -33 && vg   < 32 &&\n                 vg_b >  -9 && vg_b < 2) {\n        (void) WriteBlobByte(image,QOI_OP_LUMA | (vg + 32));\n        (void) WriteBlobByte(image,(vg_r + 8) << 4 | (vg_b +  8));\n      } else {\n        (void) WriteBlobByte(image,QOI_OP_RGB);\n        (void) WriteBlobByte(image,px.rgba.r);\n        (void) WriteBlobByte(image,px.rgba.g);\n        (void) WriteBlobByte(image,px.rgba.b);\n      }\n    } else {\n",
    "target": 1,
    "idx": 1043318,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nint blosclz_compress(const int clevel, const void* input, int length,\n                     void* output, int maxout, const int split_block) {\n  uint8_t* ibase = (uint8_t*)input;\n\n  // Experiments say that checking 1/4 of the buffer is enough to figure out approx cratio\n  int maxlen = length / 4;\n  // Start probing somewhere inside the buffer\n  int shift = length - maxlen;\n  // Actual entropy probing!\n  double cratio = get_cratio(ibase + shift, maxlen, 3, 3);\n  // discard probes with small compression ratios (too expensive)\n  double cratio_[10] = {0, 2, 1.5, 1.2, 1.2, 1.2, 1.2, 1.15, 1.1, 1.0};\n  if (cratio < cratio_[clevel]) {\n    goto out;\n  }\n\n  /* When we go back in a match (shift), we obtain quite different compression properties.\n   * It looks like 4 is more useful in combination with bitshuffle and small typesizes\n   * Fallback to 4 because it provides more consistent results for large cratios.\n   *\n   * In this block we also check cratios for the beginning of the buffers and\n   * eventually discard those that are small (take too long to decompress).\n   * This process is called _entropy probing_.\n   */\n  unsigned ipshift = 4;\n  // Compute optimal shift and minimum lengths for encoding\n  // Use 4 by default, except for low entropy data, where we should do a best effort\n  unsigned minlen = 4;\n  // BloscLZ works better with splits mostly, so when data is not split, do a best effort\n  // Why using cratio < 4 is based in experiments with low and high entropy\n  if (!split_block || cratio < 4) {\n    ipshift = 3;\n    minlen = 3;\n  }\n\n  uint8_t hashlog_[10] = {0, HASH_LOG - 2, HASH_LOG - 1, HASH_LOG, HASH_LOG,\n                          HASH_LOG, HASH_LOG, HASH_LOG, HASH_LOG, HASH_LOG};\n  uint8_t hashlog = hashlog_[clevel];\n\n  uint8_t* ip = ibase;\n  const uint8_t* ip_bound = ibase + length - 1;\n  const uint8_t* ip_limit = ibase + length - 12;\n  uint8_t* op = (uint8_t*)output;\n  const uint8_t* op_limit = op + maxout;\n\n  /* input and output buffer cannot be less than 16 and 66 bytes or we can get into trouble */\n  if (length < 16 || maxout < 66) {\n    return 0;\n  }\n\n  // Initialize the hash table\n  uint32_t htab[1U << (uint8_t)HASH_LOG];\n  memset(htab, 0, (1U << hashlog) * sizeof(uint32_t));\n\n  /* we start with literal copy */\n  uint8_t copy = 4;\n  *op++ = MAX_COPY - 1;\n  *op++ = *ip++;\n  *op++ = *ip++;\n  *op++ = *ip++;\n  *op++ = *ip++;\n\n  /* main loop */\n  while (BLOSCLZ_LIKELY(ip < ip_limit)) {\n    const uint8_t* ref;\n    unsigned distance;\n    uint8_t* anchor = ip;    /* comparison starting-point */\n\n    /* find potential match */\n    uint32_t seq = BLOSCLZ_READU32(ip);\n    uint32_t hval;\n    HASH_FUNCTION(hval, seq, hashlog)\n    ref = ibase + htab[hval];\n\n    /* calculate distance to the match */\n    distance = (unsigned int)(anchor - ref);\n\n    /* update hash table */\n    htab[hval] = (uint32_t) (anchor - ibase);\n\n    if (distance == 0 || (distance >= MAX_FARDISTANCE)) {\n      LITERAL(ip, op, op_limit, anchor, copy)\n      continue;\n    }\n\n    /* is this a match? check the first 4 bytes */\n    if (BLOSCLZ_UNLIKELY(BLOSCLZ_READU32(ref) == BLOSCLZ_READU32(ip))) {\n      ref += 4;\n    } else {\n      /* no luck, copy as a literal */\n      LITERAL(ip, op, op_limit, anchor, copy)\n      continue;\n    }\n\n    /* last matched byte */\n    ip = anchor + 4;\n\n    /* distance is biased */\n    distance--;\n\n    /* get runs or matches; zero distance means a run */\n    ip = get_run_or_match(ip, ip_bound, ref, !distance);\n\n    /* length is biased, '1' means a match of 3 bytes */\n    ip -= ipshift;\n\n    unsigned len = (int)(ip - anchor);\n\n    // Encoding short lengths is expensive during decompression\n    if (len < minlen || (len <= 5 && distance >= MAX_DISTANCE)) {\n      LITERAL(ip, op, op_limit, anchor, copy)\n      continue;\n    }\n\n    /* if we have copied something, adjust the copy count */\n    if (copy)\n      /* copy is biased, '0' means 1 byte copy */\n      *(op - copy - 1) = (uint8_t)(copy - 1);\n    else\n      /* back, to overwrite the copy count */\n      op--;\n    /* reset literal counter */\n    copy = 0;\n\n    /* encode the match */\n    if (distance < MAX_DISTANCE) {\n      if (len < 7) {\n        MATCH_SHORT(op, op_limit, len, distance)\n      } else {\n        MATCH_LONG(op, op_limit, len, distance)\n      }\n    } else {\n      /* far away, but not yet in the another galaxy... */\n      distance -= MAX_DISTANCE;\n      if (len < 7) {\n        MATCH_SHORT_FAR(op, op_limit, len, distance)\n      } else {\n        MATCH_LONG_FAR(op, op_limit, len, distance)\n      }\n    }\n\n    /* update the hash at match boundary */\n    seq = BLOSCLZ_READU32(ip);\n    HASH_FUNCTION(hval, seq, hashlog)\n    htab[hval] = (uint32_t) (ip++ - ibase);\n    if (clevel == 9) {\n      // In some situations, including a second hash proves to be useful,\n      // but not in others.  Activating here in max clevel only.\n      seq >>= 8U;\n      HASH_FUNCTION(hval, seq, hashlog)\n      htab[hval] = (uint32_t) (ip++ - ibase);\n    }\n    else {\n      ip++;\n    }\n\n    if (BLOSCLZ_UNLIKELY(op + 1 > op_limit))\n      goto out;\n\n    /* assuming literal copy */\n    *op++ = MAX_COPY - 1;\n  }\n\n  /* left-over as literal copy */\n  while (BLOSCLZ_UNLIKELY(ip <= ip_bound)) {\n    if (BLOSCLZ_UNLIKELY(op + 2 > op_limit)) goto out;\n    *op++ = *ip++;\n    copy++;\n    if (BLOSCLZ_UNLIKELY(copy == MAX_COPY)) {\n      copy = 0;\n      *op++ = MAX_COPY - 1;\n    }\n  }\n\n  /* if we have copied something, adjust the copy length */\n  if (copy)\n    *(op - copy - 1) = (uint8_t)(copy - 1);\n  else\n    op--;\n\n  /* marker for blosclz */\n  *(uint8_t*)output |= (1U << 5U);\n\n  return (int)(op - (uint8_t*)output);\n\n  out:\n  return 0;\n}\n\nstatic int blosc_c(const struct blosc_context* context, int32_t blocksize,\n                   int32_t leftoverblock, int32_t ntbytes, int32_t maxbytes,\n                   const uint8_t *src, uint8_t *dest, uint8_t *tmp,\n                   uint8_t *tmp2)\n{\n  int8_t header_flags = *(context->header_flags);\n  int dont_split = (header_flags & 0x10) >> 4;\n  int32_t j, neblock, nsplits;\n  int32_t cbytes;                   /* number of compressed bytes in split */\n  int32_t ctbytes = 0;              /* number of compressed bytes in block */\n  int32_t maxout;\n  int32_t typesize = context->typesize;\n  const uint8_t *_tmp = src;\n  const char *compname;\n  int accel;\n  int bscount;\n  int doshuffle = (header_flags & BLOSC_DOSHUFFLE) && (typesize > 1);\n  int dobitshuffle = ((header_flags & BLOSC_DOBITSHUFFLE) &&\n                      (blocksize >= typesize));\n\n  if (doshuffle) {\n    /* Byte shuffling only makes sense if typesize > 1 */\n    blosc_internal_shuffle(typesize, blocksize, src, tmp);\n    _tmp = tmp;\n  }\n  /* We don't allow more than 1 filter at the same time (yet) */\n  else if (dobitshuffle) {\n    bscount = blosc_internal_bitshuffle(typesize, blocksize, src, tmp, tmp2);\n    if (bscount < 0)\n      return bscount;\n    _tmp = tmp;\n  }\n\n  /* Calculate acceleration for different compressors */\n  accel = get_accel(context);\n\n  /* The number of splits for this block */\n  if (!dont_split && !leftoverblock) {\n    nsplits = typesize;\n  }\n  else {\n    nsplits = 1;\n  }\n  neblock = blocksize / nsplits;\n  for (j = 0; j < nsplits; j++) {\n    dest += sizeof(int32_t);\n    ntbytes += (int32_t)sizeof(int32_t);\n    ctbytes += (int32_t)sizeof(int32_t);\n    maxout = neblock;\n    #if defined(HAVE_SNAPPY)\n    if (context->compcode == BLOSC_SNAPPY) {\n      /* TODO perhaps refactor this to keep the value stashed somewhere */\n      maxout = snappy_max_compressed_length(neblock);\n    }\n    #endif /*  HAVE_SNAPPY */\n    if (ntbytes+maxout > maxbytes) {\n      maxout = maxbytes - ntbytes;   /* avoid buffer overrun */\n      if (maxout <= 0) {\n        return 0;                  /* non-compressible block */\n      }\n    }\n    if (context->compcode == BLOSC_BLOSCLZ) {\n      cbytes = blosclz_compress(context->clevel, _tmp+j*neblock, neblock,\n                                dest, maxout, !dont_split);\n    }\n    #if defined(HAVE_LZ4)\n    else if (context->compcode == BLOSC_LZ4) {\n      cbytes = lz4_wrap_compress((char *)_tmp+j*neblock, (size_t)neblock,\n                                 (char *)dest, (size_t)maxout, accel);\n    }\n    else if (context->compcode == BLOSC_LZ4HC) {\n      cbytes = lz4hc_wrap_compress((char *)_tmp+j*neblock, (size_t)neblock,\n                                   (char *)dest, (size_t)maxout,\n                                   context->clevel);\n    }\n    #endif /* HAVE_LZ4 */\n    #if defined(HAVE_SNAPPY)\n    else if (context->compcode == BLOSC_SNAPPY) {\n      cbytes = snappy_wrap_compress((char *)_tmp+j*neblock, (size_t)neblock,\n                                    (char *)dest, (size_t)maxout);\n    }\n    #endif /* HAVE_SNAPPY */\n    #if defined(HAVE_ZLIB)\n    else if (context->compcode == BLOSC_ZLIB) {\n      cbytes = zlib_wrap_compress((char *)_tmp+j*neblock, (size_t)neblock,\n                                  (char *)dest, (size_t)maxout,\n                                  context->clevel);\n    }\n    #endif /* HAVE_ZLIB */\n    #if defined(HAVE_ZSTD)\n    else if (context->compcode == BLOSC_ZSTD) {\n      cbytes = zstd_wrap_compress((char*)_tmp + j * neblock, (size_t)neblock,\n                                  (char*)dest, (size_t)maxout, context->clevel);\n    }\n    #endif /* HAVE_ZSTD */\n\n    else {\n      blosc_compcode_to_compname(context->compcode, &compname);\n      if (compname == NULL) {\n          compname = \"(null)\";\n      }\n      fprintf(stderr, \"Blosc has not been compiled with '%s' \", compname);\n      fprintf(stderr, \"compression support.  Please use one having it.\");\n      return -5;    /* signals no compression support */\n    }\n\n    if (cbytes > maxout) {\n      /* Buffer overrun caused by compression (should never happen) */\n      return -1;\n    }\n    else if (cbytes < 0) {\n      /* cbytes should never be negative */\n      return -2;\n    }\n    else if (cbytes == 0 || cbytes == neblock) {\n      /* The compressor has been unable to compress data at all. */\n      /* Before doing the copy, check that we are not running into a\n         buffer overflow. */\n      if ((ntbytes+neblock) > maxbytes) {\n        return 0;    /* Non-compressible data */\n      }\n      fastcopy(dest, _tmp + j * neblock, neblock);\n      cbytes = neblock;\n    }\n    _sw32(dest - 4, cbytes);\n    dest += cbytes;\n    ntbytes += cbytes;\n    ctbytes += cbytes;\n  }  /* Closes j < nsplits */\n\n  return ctbytes;\n}\n\nstatic int serial_blosc(struct blosc_context* context)\n{\n  int32_t j, bsize, leftoverblock;\n  int32_t cbytes;\n\n  int32_t ebsize = context->blocksize + context->typesize * (int32_t)sizeof(int32_t);\n  int32_t ntbytes = context->num_output_bytes;\n\n  uint8_t *tmp = my_malloc(context->blocksize + ebsize);\n  uint8_t *tmp2 = tmp + context->blocksize;\n\n  for (j = 0; j < context->nblocks; j++) {\n    if (context->compress && !(*(context->header_flags) & BLOSC_MEMCPYED)) {\n      _sw32(context->bstarts + j * 4, ntbytes);\n    }\n    bsize = context->blocksize;\n    leftoverblock = 0;\n    if ((j == context->nblocks - 1) && (context->leftover > 0)) {\n      bsize = context->leftover;\n      leftoverblock = 1;\n    }\n    if (context->compress) {\n      if (*(context->header_flags) & BLOSC_MEMCPYED) {\n        /* We want to memcpy only */\n        fastcopy(context->dest + BLOSC_MAX_OVERHEAD + j * context->blocksize,\n                 context->src + j * context->blocksize, bsize);\n        cbytes = bsize;\n      }\n      else {\n        /* Regular compression */\n        cbytes = blosc_c(context, bsize, leftoverblock, ntbytes,\n                         context->destsize, context->src+j*context->blocksize,\n                         context->dest+ntbytes, tmp, tmp2);\n        if (cbytes == 0) {\n          ntbytes = 0;              /* uncompressible data */\n          break;\n        }\n      }\n    }\n    else {\n      if (*(context->header_flags) & BLOSC_MEMCPYED) {\n        /* We want to memcpy only */\n        fastcopy(context->dest + j * context->blocksize,\n                 context->src + BLOSC_MAX_OVERHEAD + j * context->blocksize, bsize);\n        cbytes = bsize;\n      }\n      else {\n        /* Regular decompression */\n        cbytes = blosc_d(context, bsize, leftoverblock, context->src,\n                         sw32_(context->bstarts + j * 4),\n                         context->dest + j * context->blocksize, tmp, tmp2);\n      }\n    }\n    if (cbytes < 0) {\n      ntbytes = cbytes;         /* error in blosc_c or blosc_d */\n      break;\n    }\n    ntbytes += cbytes;\n  }\n\n  /* Free temporaries */\n  my_free(tmp);\n\n  return ntbytes;\n}\n\nstatic int do_job(struct blosc_context* context)\n{\n  int32_t ntbytes;\n\n  /* Run the serial version when nthreads is 1 or when the buffers are\n     not much larger than blocksize */\n  if (context->numthreads == 1 || (context->sourcesize / context->blocksize) <= 1) {\n    ntbytes = serial_blosc(context);\n  }\n  else {\n    ntbytes = parallel_blosc(context);\n  }\n\n  return ntbytes;\n}\n\nint blosc_compress_context(struct blosc_context* context)\n{\n  int32_t ntbytes = 0;\n\n  if ((*(context->header_flags) & BLOSC_MEMCPYED) &&\n      (context->sourcesize + BLOSC_MAX_OVERHEAD > context->destsize)) {\n    return 0;   /* data cannot be copied without overrun destination */\n  }\n\n  /* Do the actual compression */\n  ntbytes = do_job(context);\n  if (ntbytes < 0) {\n    return -1;\n  }\n  if ((ntbytes == 0) && (context->sourcesize + BLOSC_MAX_OVERHEAD <= context->destsize)) {\n    /* Last chance for fitting `src` buffer in `dest`.  Update flags and force a copy. */\n    *(context->header_flags) |= BLOSC_MEMCPYED;\n    context->num_output_bytes = BLOSC_MAX_OVERHEAD;  /* reset the output bytes in previous step */\n    ntbytes = do_job(context);\n    if (ntbytes < 0) {\n      return -1;\n    }\n  }\n\n  /* Set the number of compressed bytes in header */\n  _sw32(context->dest + 12, ntbytes);\n\n  assert(ntbytes <= context->destsize);\n  return ntbytes;\n}\n\nint blosc_compress(int clevel, int doshuffle, size_t typesize, size_t nbytes,\n                   const void *src, void *dest, size_t destsize)\n{\n  int result;\n  char* envvar;\n\n  /* Check if should initialize */\n  if (!g_initlib) blosc_init();\n\n  /* Check for environment variables */\n  envvar = getenv(\"BLOSC_CLEVEL\");\n  if (envvar != NULL) {\n    long value;\n    value = strtol(envvar, NULL, 10);\n    if ((value != EINVAL) && (value >= 0)) {\n      clevel = (int)value;\n    }\n  }\n\n  envvar = getenv(\"BLOSC_SHUFFLE\");\n  if (envvar != NULL) {\n    if (strcmp(envvar, \"NOSHUFFLE\") == 0) {\n      doshuffle = BLOSC_NOSHUFFLE;\n    }\n    if (strcmp(envvar, \"SHUFFLE\") == 0) {\n      doshuffle = BLOSC_SHUFFLE;\n    }\n    if (strcmp(envvar, \"BITSHUFFLE\") == 0) {\n      doshuffle = BLOSC_BITSHUFFLE;\n    }\n  }\n\n  envvar = getenv(\"BLOSC_TYPESIZE\");\n  if (envvar != NULL) {\n    long value;\n    value = strtol(envvar, NULL, 10);\n    if ((value != EINVAL) && (value > 0)) {\n      typesize = (int)value;\n    }\n  }\n\n  envvar = getenv(\"BLOSC_COMPRESSOR\");\n  if (envvar != NULL) {\n    result = blosc_set_compressor(envvar);\n    if (result < 0) { return result; }\n  }\n\n  envvar = getenv(\"BLOSC_BLOCKSIZE\");\n  if (envvar != NULL) {\n    long blocksize;\n    blocksize = strtol(envvar, NULL, 10);\n    if ((blocksize != EINVAL) && (blocksize > 0)) {\n      blosc_set_blocksize((size_t)blocksize);\n    }\n  }\n\n  envvar = getenv(\"BLOSC_NTHREADS\");\n  if (envvar != NULL) {\n    long nthreads;\n    nthreads = strtol(envvar, NULL, 10);\n    if ((nthreads != EINVAL) && (nthreads > 0)) {\n      result = blosc_set_nthreads((int)nthreads);\n      if (result < 0) { return result; }\n    }\n  }\n\n  envvar = getenv(\"BLOSC_SPLITMODE\");\n  if (envvar != NULL) {\n    if (strcmp(envvar, \"FORWARD_COMPAT\") == 0) {\n      blosc_set_splitmode(BLOSC_FORWARD_COMPAT_SPLIT);\n    }\n    else if (strcmp(envvar, \"AUTO\") == 0) {\n      blosc_set_splitmode(BLOSC_AUTO_SPLIT);\n    }\n    else if (strcmp(envvar, \"ALWAYS\") == 0) {\n      blosc_set_splitmode(BLOSC_ALWAYS_SPLIT);\n    }\n    else if (strcmp(envvar, \"NEVER\") == 0) {\n      blosc_set_splitmode(BLOSC_NEVER_SPLIT);\n    }\n    else {\n      fprintf(stderr, \"BLOSC_SPLITMODE environment variable '%s' not recognized\\n\", envvar);\n      return -1;\n    }\n  }\n\n  /* Check for a BLOSC_NOLOCK environment variable.  It is important\n     that this should be the last env var so that it can take the\n     previous ones into account */\n  envvar = getenv(\"BLOSC_NOLOCK\");\n  if (envvar != NULL) {\n    const char *compname;\n    blosc_compcode_to_compname(g_compressor, &compname);\n    result = blosc_compress_ctx(clevel, doshuffle, typesize,\n\t\t\t\tnbytes, src, dest, destsize,\n\t\t\t\tcompname, g_force_blocksize, g_threads);\n    return result;\n  }\n\n  pthread_mutex_lock(global_comp_mutex);\n\n  do {\n    result = initialize_context_compression(g_global_context, clevel, doshuffle,\n                                           typesize, nbytes, src, dest, destsize,\n                                           g_compressor, g_force_blocksize,\n                                           g_threads);\n    if (result <= 0) { break; }\n\n    result = write_compression_header(g_global_context, clevel, doshuffle);\n    if (result <= 0) { break; }\n\n    result = blosc_compress_context(g_global_context);\n  } while (0);\n\n  pthread_mutex_unlock(global_comp_mutex);\n\n  return result;\n}\n\n\n// target function\nint blosclz_compress(const int clevel, const void* input, int length,\n                     void* output, int maxout, const int split_block) {\n  uint8_t* ibase = (uint8_t*)input;\n\n  // Experiments say that checking 1/4 of the buffer is enough to figure out approx cratio\n  int maxlen = length / 4;\n  // Start probing somewhere inside the buffer\n  int shift = length - maxlen;\n  // Actual entropy probing!\n  double cratio = get_cratio(ibase + shift, maxlen, 3, 3);\n  // discard probes with small compression ratios (too expensive)\n  double cratio_[10] = {0, 2, 1.5, 1.2, 1.2, 1.2, 1.2, 1.15, 1.1, 1.0};\n  if (cratio < cratio_[clevel]) {\n    goto out;\n  }\n\n  /* When we go back in a match (shift), we obtain quite different compression properties.\n   * It looks like 4 is more useful in combination with bitshuffle and small typesizes\n   * Fallback to 4 because it provides more consistent results for large cratios.\n   *\n   * In this block we also check cratios for the beginning of the buffers and\n   * eventually discard those that are small (take too long to decompress).\n   * This process is called _entropy probing_.\n   */\n  unsigned ipshift = 4;\n  // Compute optimal shift and minimum lengths for encoding\n  // Use 4 by default, except for low entropy data, where we should do a best effort\n  unsigned minlen = 4;\n  // BloscLZ works better with splits mostly, so when data is not split, do a best effort\n  // Why using cratio < 4 is based in experiments with low and high entropy\n  if (!split_block || cratio < 4) {\n    ipshift = 3;\n    minlen = 3;\n  }\n\n  uint8_t hashlog_[10] = {0, HASH_LOG - 2, HASH_LOG - 1, HASH_LOG, HASH_LOG,\n                          HASH_LOG, HASH_LOG, HASH_LOG, HASH_LOG, HASH_LOG};\n  uint8_t hashlog = hashlog_[clevel];\n\n  uint8_t* ip = ibase;\n  const uint8_t* ip_bound = ibase + length - 1;\n  const uint8_t* ip_limit = ibase + length - 12;\n  uint8_t* op = (uint8_t*)output;\n\n  /* input and output buffer cannot be less than 16 and 66 bytes or we can get into trouble */\n  if (length < 16 || maxout < 66) {\n    return 0;\n  }\n\n  // Initialize the hash table\n  uint32_t htab[1U << (uint8_t)HASH_LOG];\n  memset(htab, 0, (1U << hashlog) * sizeof(uint32_t));\n\n  /* we start with literal copy */\n  uint8_t copy = 4;\n  *op++ = MAX_COPY - 1;\n  *op++ = *ip++;\n  *op++ = *ip++;\n  *op++ = *ip++;\n  *op++ = *ip++;\n\n  /* main loop */\n  const uint8_t* op_limit = op + maxout;\n  while (BLOSCLZ_LIKELY(ip < ip_limit)) {\n    const uint8_t* ref;\n    unsigned distance;\n    uint8_t* anchor = ip;    /* comparison starting-point */\n\n    /* find potential match */\n    uint32_t seq = BLOSCLZ_READU32(ip);\n    uint32_t hval;\n    HASH_FUNCTION(hval, seq, hashlog)\n    ref = ibase + htab[hval];\n\n    /* calculate distance to the match */\n    distance = (unsigned int)(anchor - ref);\n\n    /* update hash table */\n    htab[hval] = (uint32_t) (anchor - ibase);\n\n    if (distance == 0 || (distance >= MAX_FARDISTANCE)) {\n      LITERAL(ip, op, op_limit, anchor, copy)\n      continue;\n    }\n\n    /* is this a match? check the first 4 bytes */\n    if (BLOSCLZ_UNLIKELY(BLOSCLZ_READU32(ref) == BLOSCLZ_READU32(ip))) {\n      ref += 4;\n    } else {\n      /* no luck, copy as a literal */\n      LITERAL(ip, op, op_limit, anchor, copy)\n      continue;\n    }\n\n    /* last matched byte */\n    ip = anchor + 4;\n\n    /* distance is biased */\n    distance--;\n\n    /* get runs or matches; zero distance means a run */\n    ip = get_run_or_match(ip, ip_bound, ref, !distance);\n\n    /* length is biased, '1' means a match of 3 bytes */\n    ip -= ipshift;\n\n    unsigned len = (int)(ip - anchor);\n\n    // Encoding short lengths is expensive during decompression\n    if (len < minlen || (len <= 5 && distance >= MAX_DISTANCE)) {\n      LITERAL(ip, op, op_limit, anchor, copy)\n      continue;\n    }\n\n    /* if we have copied something, adjust the copy count */\n    if (copy)\n      /* copy is biased, '0' means 1 byte copy */\n      *(op - copy - 1) = (uint8_t)(copy - 1);\n    else\n      /* back, to overwrite the copy count */\n      op--;\n    /* reset literal counter */\n    copy = 0;\n\n    /* encode the match */\n    if (distance < MAX_DISTANCE) {\n      if (len < 7) {\n        MATCH_SHORT(op, op_limit, len, distance)\n      } else {\n        MATCH_LONG(op, op_limit, len, distance)\n      }\n    } else {\n      /* far away, but not yet in the another galaxy... */\n      distance -= MAX_DISTANCE;\n      if (len < 7) {\n        MATCH_SHORT_FAR(op, op_limit, len, distance)\n      } else {\n        MATCH_LONG_FAR(op, op_limit, len, distance)\n      }\n    }\n\n    /* update the hash at match boundary */\n    seq = BLOSCLZ_READU32(ip);\n    HASH_FUNCTION(hval, seq, hashlog)\n    htab[hval] = (uint32_t) (ip++ - ibase);\n    if (clevel == 9) {\n      // In some situations, including a second hash proves to be useful,\n      // but not in others.  Activating here in max clevel only.\n      seq >>= 8U;\n      HASH_FUNCTION(hval, seq, hashlog)\n      htab[hval] = (uint32_t) (ip++ - ibase);\n    }\n    else {\n      ip++;\n    }\n\n    if (BLOSCLZ_UNLIKELY(op + 1 > op_limit))\n      goto out;\n\n    /* assuming literal copy */\n    *op++ = MAX_COPY - 1;\n  }\n\n  /* left-over as literal copy */\n  while (BLOSCLZ_UNLIKELY(ip <= ip_bound)) {\n    if (BLOSCLZ_UNLIKELY(op + 2 > op_limit)) goto out;\n    *op++ = *ip++;\n    copy++;\n    if (BLOSCLZ_UNLIKELY(copy == MAX_COPY)) {\n      copy = 0;\n      *op++ = MAX_COPY - 1;\n    }\n  }\n\n  /* if we have copied something, adjust the copy length */\n  if (copy)\n    *(op - copy - 1) = (uint8_t)(copy - 1);\n  else\n    op--;\n\n  /* marker for blosclz */\n  *(uint8_t*)output |= (1U << 5U);\n\n  return (int)(op - (uint8_t*)output);\n\n  out:\n  return 0;\n}\n",
    "target": 1,
    "idx": 1038313,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "// context\n\n\n\n\n\n\n\n\n\n\n\n// target function\nstatic int simple_str_to_doublestr(const char *from, char *result, char **to)\n{\n    char *start = NULL, *end = NULL, *cur = (char *)from;\n\n#if !defined(HAVE_GETNUMBERFORMAT)\n    struct lconv *loc_data = localeconv();\n#endif\n    int i = 0;\n    double dtest;\n\n    /*sanity checks */\n    if (!from || !result) {\n        return 1;\n    }\n\n    /*skip the white spaces at the beginning */\n    while (*cur && isspace((int)*cur))\n        cur++;\n\n    start = cur;\n    /* copy the part that looks like a double into result.\n     * during the copy, we give ourselves a chance to convert the '.'\n     * into the decimal separator of the current locale.\n     */\n    while (*cur && (isdigit((int)*cur) || *cur == '.' || *cur == '+' || *cur == '-')) {\n        ++cur;\n    }\n    end = cur;\n    if (end - start + 1 > 100) {\n        /*huh hoh, number is too big. getting out */\n        return 1;\n    }\n\n    /* copy the float number string into tmp_buf, and take\n     * care to have the (optional) decimal separator be the one\n     * of the current locale.\n     */\n#if !defined(HAVE_GETNUMBERFORMAT)\n    for (i = 0; i < end - from; ++i) {\n        if (start[i] == '.' && loc_data && loc_data->decimal_point && loc_data->decimal_point[0]\n            && loc_data->decimal_point[0] != '.') {\n            /*replace '.' by the digit separator of the current locale */\n            result[i] = loc_data->decimal_point[0];\n        } else {\n            result[i] = start[i];\n        }\n    }\n#else\n    GetNumberFormat(LOCALE_SYSTEM_DEFAULT, 0, start, NULL, result, TMP_NUM_SIZE);\n#endif\n    if (to) {\n        *to = end;\n    }\n\n    /* now try to convert to a floating point number, to check for validity only */\n    if (sscanf(result, \"%lf\", &dtest) != 1) {\n        return 1;\n    }\n    return 0;\n}\nvoid test_geo_props(void)\n{\n    int estate;\n    icalcomponent *c;\n    icalproperty *p;\n\n    c = icalparser_parse_string(\"BEGIN:VEVENT\\n\" \"GEO:49.42612;7.75473\\n\" \"END:VEVENT\\n\");\n    ok(\"icalparser_parse_string()\", (c != NULL));\n    if (!c) {\n        exit(EXIT_FAILURE);\n    }\n    if (VERBOSE)\n        printf(\"%s\", icalcomponent_as_ical_string(c));\n    p = icalcomponent_get_first_property(c, ICAL_GEO_PROPERTY);\n    str_is(\"icalproperty_get_value_as_string() works\",\n           icalproperty_get_value_as_string(p), \"49.42612;7.75473\");\n    icalcomponent_free(c);\n\n    c = icalparser_parse_string(\"BEGIN:VEVENT\\n\" \"GEO:-0;+0\\n\" \"END:VEVENT\\n\");\n    ok(\"icalparser_parse_string()\", (c != NULL));\n    if (!c) {\n        exit(EXIT_FAILURE);\n    }\n    if (VERBOSE)\n        printf(\"%s\", icalcomponent_as_ical_string(c));\n    p = icalcomponent_get_first_property(c, ICAL_GEO_PROPERTY);\n    str_is(\"icalproperty_get_value_as_string() works\",\n           icalproperty_get_value_as_string(p), \"-0;+0\");\n    icalcomponent_free(c);\n\n    estate = icalerror_get_errors_are_fatal();\n    icalerror_set_errors_are_fatal(0);\n    c = icalparser_parse_string(\"BEGIN:VEVENT\\n\" \"GEO:-0a;+0\\n\" \"END:VEVENT\\n\");\n    if (!c) {\n        exit(EXIT_FAILURE);\n    }\n    if (VERBOSE)\n        printf(\"%s\", icalcomponent_as_ical_string(c));\n    p = icalcomponent_get_first_property(c, ICAL_GEO_PROPERTY);\n    ok(\"expected fail icalcomponent_get_first_property()\", (p == NULL));\n    icalcomponent_free(c);\n    icalerror_set_errors_are_fatal(estate);\n}\nvoid test_zoneinfo_stuff(void)\n{\n#if defined(HAVE_SETENV)\n    setenv(\"TZDIR\", TEST_DATADIR, 1);\n#else\n    char tzdir[256] = {0};\n    strncat(tzdir, \"TZDIR=\" TEST_DATADIR, 255);\n    putenv(tzdir);\n#endif\n    icaltzutil_set_zone_directory(NULL); /*resets to empty */\n    str_is(\"icaltzutil_get_zone_directory by TZDIR\", icaltzutil_get_zone_directory(), TEST_DATADIR);\n    icaltzutil_set_zone_directory(\"foo\");\n    str_is(\"icaltzutil_get_zone_directory\", icaltzutil_get_zone_directory(), \"foo\");\n\n    /* reset the environment */\n#if defined(HAVE_SETENV)\n    unsetenv(\"TZDIR\");\n#else\n    strcpy(tzdir, \"TZDIR=\");\n    putenv(tzdir);\n#endif\n    icaltzutil_set_zone_directory(NULL);\n}\n",
    "target": 1,
    "idx": 1047986,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "// context\n  void Put(const T* src, int num_values) override {\n    for (int32_t i = 0; i < num_values; i++) {\n      Put(src[i]);\n    }\n  }\n\n  Status DecodeArrowDense(int num_values, int null_count, const uint8_t* valid_bits,\n                          int64_t valid_bits_offset,\n                          typename EncodingTraits<ByteArrayType>::Accumulator* out,\n                          int* out_num_values) {\n    ArrowBinaryHelper helper(out);\n\n    std::vector<ByteArray> values(num_values);\n    const int num_valid_values = GetInternal(values.data(), num_values - null_count);\n    DCHECK_EQ(num_values - null_count, num_valid_values);\n\n    auto values_ptr = reinterpret_cast<const ByteArray*>(values.data());\n    int value_idx = 0;\n\n    RETURN_NOT_OK(VisitNullBitmapInline(\n        valid_bits, valid_bits_offset, num_values, null_count,\n        [&]() {\n          const auto& val = values_ptr[value_idx];\n          if (ARROW_PREDICT_FALSE(!helper.CanFit(val.len))) {\n            RETURN_NOT_OK(helper.PushChunk());\n          }\n          RETURN_NOT_OK(helper.Append(val.ptr, static_cast<int32_t>(val.len)));\n          ++value_idx;\n          return Status::OK();\n        },\n        [&]() {\n          RETURN_NOT_OK(helper.AppendNull());\n          --null_count;\n          return Status::OK();\n        }));\n\n    DCHECK_EQ(null_count, 0);\n    *out_num_values = num_valid_values;\n    return Status::OK();\n  }\n\n  void Put(const T* src, int num_values) override {\n    for (int32_t i = 0; i < num_values; i++) {\n      Put(src[i]);\n    }\n  }\n\n  Type::type type() const override { return this->descr_->physical_type(); }\n\n  Type::type type() const override { return this->descr_->physical_type(); }\n\n  END_PARQUET_CATCH_EXCEPTIONS\n  // Gather children arrays and def levels\n  for (auto& child : children_) {\n    std::shared_ptr<ChunkedArray> field;\n    RETURN_NOT_OK(child->BuildArray(validity_io.values_read, &field));\n    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<ArrayData> array_data, ChunksToSingle(*field));\n    children_array_data.push_back(std::move(array_data));\n  }\n\n  ::arrow::Status NextBatch(int64_t batch_size,\n                            std::shared_ptr<::arrow::ChunkedArray>* out) final {\n    RETURN_NOT_OK(LoadBatch(batch_size));\n    RETURN_NOT_OK(BuildArray(batch_size, out));\n    for (int x = 0; x < (*out)->num_chunks(); x++) {\n      RETURN_NOT_OK((*out)->chunk(x)->Validate());\n    }\n    return Status::OK();\n  }\n\n  END_PARQUET_CATCH_EXCEPTIONS\n  // Gather children arrays and def levels\n  for (auto& child : children_) {\n    std::shared_ptr<ChunkedArray> field;\n    RETURN_NOT_OK(child->BuildArray(validity_io.values_read, &field));\n    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<ArrayData> array_data, ChunksToSingle(*field));\n    children_array_data.push_back(std::move(array_data));\n  }\n\n  END_PARQUET_CATCH_EXCEPTIONS\n  // Gather children arrays and def levels\n  for (auto& child : children_) {\n    std::shared_ptr<ChunkedArray> field;\n    RETURN_NOT_OK(child->BuildArray(validity_io.values_read, &field));\n    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<ArrayData> array_data, ChunksToSingle(*field));\n    children_array_data.push_back(std::move(array_data));\n  }\n\nFuture<std::vector<R>> OptionalParallelForAsync(\n    bool use_threads, std::vector<T> inputs, FUNCTION&& func,\n    Executor* executor = internal::GetCpuThreadPool()) {\n  if (use_threads) {\n    return ParallelForAsync(std::move(inputs), std::forward<FUNCTION>(func), executor);\n  } else {\n    std::vector<R> result(inputs.size());\n    for (size_t i = 0; i < inputs.size(); ++i) {\n      ARROW_ASSIGN_OR_RAISE(result[i], func(i, inputs[i]));\n    }\n    return result;\n  }\n}\n\n  END_PARQUET_CATCH_EXCEPTIONS\n  // Gather children arrays and def levels\n  for (auto& child : children_) {\n    std::shared_ptr<ChunkedArray> field;\n    RETURN_NOT_OK(child->BuildArray(validity_io.values_read, &field));\n    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<ArrayData> array_data, ChunksToSingle(*field));\n    children_array_data.push_back(std::move(array_data));\n  }\n\n  END_PARQUET_CATCH_EXCEPTIONS\n  // Gather children arrays and def levels\n  for (auto& child : children_) {\n    std::shared_ptr<ChunkedArray> field;\n    RETURN_NOT_OK(child->BuildArray(validity_io.values_read, &field));\n    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<ArrayData> array_data, ChunksToSingle(*field));\n    children_array_data.push_back(std::move(array_data));\n  }\n\n  END_PARQUET_CATCH_EXCEPTIONS\n  // Gather children arrays and def levels\n  for (auto& child : children_) {\n    std::shared_ptr<ChunkedArray> field;\n    RETURN_NOT_OK(child->BuildArray(validity_io.values_read, &field));\n    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<ArrayData> array_data, ChunksToSingle(*field));\n    children_array_data.push_back(std::move(array_data));\n  }\n\n  END_PARQUET_CATCH_EXCEPTIONS\n  // Gather children arrays and def levels\n  for (auto& child : children_) {\n    std::shared_ptr<ChunkedArray> field;\n    RETURN_NOT_OK(child->BuildArray(validity_io.values_read, &field));\n    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<ArrayData> array_data, ChunksToSingle(*field));\n    children_array_data.push_back(std::move(array_data));\n  }\n\nStatus FuzzReader(const uint8_t* data, int64_t size) {\n  auto buffer = std::make_shared<::arrow::Buffer>(data, size);\n  auto file = std::make_shared<::arrow::io::BufferReader>(buffer);\n  FileReaderBuilder builder;\n  RETURN_NOT_OK(builder.Open(std::move(file)));\n\n  std::unique_ptr<FileReader> reader;\n  RETURN_NOT_OK(builder.Build(&reader));\n  return FuzzReader(std::move(reader));\n}\n\nStatus FuzzReader(const uint8_t* data, int64_t size) {\n  auto buffer = std::make_shared<::arrow::Buffer>(data, size);\n  auto file = std::make_shared<::arrow::io::BufferReader>(buffer);\n  FileReaderBuilder builder;\n  RETURN_NOT_OK(builder.Open(std::move(file)));\n\n  std::unique_ptr<FileReader> reader;\n  RETURN_NOT_OK(builder.Build(&reader));\n  return FuzzReader(std::move(reader));\n}\n\n\n// target function\n  Status DecodeArrowDense(int num_values, int null_count, const uint8_t* valid_bits,\n                          int64_t valid_bits_offset,\n                          typename EncodingTraits<ByteArrayType>::Accumulator* out,\n                          int* out_num_values) {\n    ArrowBinaryHelper helper(out);\n    ::arrow::internal::BitmapReader bit_reader(valid_bits, valid_bits_offset, num_values);\n\n    std::vector<ByteArray> values(num_values);\n    int num_valid_values = GetInternal(values.data(), num_values - null_count);\n    DCHECK_EQ(num_values - null_count, num_valid_values);\n\n    auto values_ptr = reinterpret_cast<const ByteArray*>(values.data());\n    int value_idx = 0;\n\n    for (int i = 0; i < num_values; ++i) {\n      bool is_valid = bit_reader.IsSet();\n      bit_reader.Next();\n\n      if (is_valid) {\n        const auto& val = values_ptr[value_idx];\n        if (ARROW_PREDICT_FALSE(!helper.CanFit(val.len))) {\n          RETURN_NOT_OK(helper.PushChunk());\n        }\n        RETURN_NOT_OK(helper.Append(val.ptr, static_cast<int32_t>(val.len)));\n        ++value_idx;\n      } else {\n        RETURN_NOT_OK(helper.AppendNull());\n        --null_count;\n      }\n    }\n    DCHECK_EQ(null_count, 0);\n    *out_num_values = num_valid_values;\n    return Status::OK();\n  }\n  int GetInternal(ByteArray* buffer, int max_values) {\n    // Decode up to `max_values` strings into an internal buffer\n    // and reference them into `buffer`.\n    max_values = std::min(max_values, num_valid_values_);\n    if (max_values == 0) {\n      return max_values;\n    }\n\n    suffix_decoder_.Decode(buffer, max_values);\n\n    int64_t data_size = 0;\n    const int32_t* prefix_len_ptr =\n        reinterpret_cast<const int32_t*>(buffered_prefix_length_->data()) +\n        prefix_len_offset_;\n    for (int i = 0; i < max_values; ++i) {\n      if (AddWithOverflow(data_size, prefix_len_ptr[i], &data_size) ||\n          AddWithOverflow(data_size, buffer[i].len, &data_size)) {\n        throw ParquetException(\"excess expansion in DELTA_BYTE_ARRAY\");\n      }\n    }\n    PARQUET_THROW_NOT_OK(buffered_data_->Resize(data_size));\n\n    string_view prefix{last_value_};\n    uint8_t* data_ptr = buffered_data_->mutable_data();\n    for (int i = 0; i < max_values; ++i) {\n      if (ARROW_PREDICT_FALSE(static_cast<size_t>(prefix_len_ptr[i]) > prefix.length())) {\n        throw ParquetException(\"prefix length too large\");\n      }\n      memcpy(data_ptr, prefix.data(), prefix_len_ptr[i]);\n      // buffer[i] currently points to the string suffix\n      memcpy(data_ptr + prefix_len_ptr[i], buffer[i].ptr, buffer[i].len);\n      buffer[i].ptr = data_ptr;\n      buffer[i].len += prefix_len_ptr[i];\n      data_ptr += buffer[i].len;\n      prefix = string_view{reinterpret_cast<const char*>(buffer[i].ptr), buffer[i].len};\n    }\n    prefix_len_offset_ += max_values;\n    this->num_values_ -= max_values;\n    num_valid_values_ -= max_values;\n    last_value_ = std::string{prefix};\n\n    if (num_valid_values_ == 0) {\n      last_value_in_previous_page_ = last_value_;\n    }\n    return max_values;\n  }\n",
    "target": 1,
    "idx": 1041221,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic void thrift_set_method(struct ndpi_detection_module_struct *ndpi_struct,\n                              struct ndpi_flow_struct *flow,\n                              char const * const method, size_t method_length)\n{\n  if (thrift_validate_method(method, method_length) == 0) {\n    ndpi_set_risk(ndpi_struct, flow, NDPI_INVALID_CHARACTERS, \"Invalid method name\");\n    flow->protos.thrift.method[0] = '\\0';\n  } else {\n    strncpy(flow->protos.thrift.method, method, ndpi_min(sizeof(flow->protos.thrift.method), method_length));\n  }\n}\n\nstatic void ndpi_dissect_strict_hdr(struct ndpi_detection_module_struct *ndpi_struct,\n                                    struct ndpi_flow_struct *flow,\n                                    struct thrift_strict_hdr const * const strict_hdr)\n{\n  struct ndpi_packet_struct const * const packet = &ndpi_struct->packet;\n  const size_t method_length = ntohl(strict_hdr->method_length);\n\n  if (packet->tcp == NULL) {\n    NDPI_EXCLUDE_PROTO(ndpi_struct, flow);\n    return;\n  }\n\n  if (packet->payload_packet_len < sizeof(*strict_hdr) + method_length) {\n    NDPI_EXCLUDE_PROTO(ndpi_struct, flow);\n    return;\n  }\n\n  if (thrift_validate_version(strict_hdr->version) == 0) {\n    NDPI_EXCLUDE_PROTO(ndpi_struct, flow);\n    return;\n  }\n\n  if (thrift_validate_type(strict_hdr->message_type) == 0) {\n    NDPI_EXCLUDE_PROTO(ndpi_struct, flow);\n    return;\n  }\n\n  ndpi_int_thrift_add_connection(ndpi_struct, flow, NDPI_PROTOCOL_UNKNOWN);\n\n  thrift_set_method(ndpi_struct, flow, strict_hdr->method, method_length);\n  thrift_set_type(ndpi_struct, flow, strict_hdr->message_type);\n}\n\nstatic void ndpi_search_thrift_tcp_udp(struct ndpi_detection_module_struct *ndpi_struct,\n                                       struct ndpi_flow_struct *flow)\n{\n  struct ndpi_packet_struct const * const packet = &ndpi_struct->packet;\n\n  NDPI_LOG_DBG(ndpi_struct, \"search Apache Thrift\\n\");\n\n  if (flow->detected_protocol_stack[0] == NDPI_PROTOCOL_HTTP ||\n      flow->detected_protocol_stack[1] == NDPI_PROTOCOL_HTTP)\n  {\n    /* Check Thrift over HTTP */\n    if (packet->content_line.ptr != NULL)\n    {\n      if ((LINE_ENDS(packet->content_line, \"application/vnd.apache.thrift.binary\") != 0) ||\n          (LINE_ENDS(packet->content_line, \"application/vnd.apache.thrift.compact\") != 0) ||\n          (LINE_ENDS(packet->content_line, \"application/vnd.apache.thrift.json\") != 0))\n      {\n        NDPI_LOG_INFO(ndpi_struct, \"found Apache Thrift over HTTP\\n\");\n        ndpi_int_thrift_add_connection(ndpi_struct, flow, NDPI_PROTOCOL_HTTP);\n        return;\n      }\n    }\n  } else if (packet->payload_packet_len >= sizeof(struct thrift_compact_hdr)) {\n    const union {\n      uint8_t const * const raw_ptr;\n      struct thrift_strict_hdr const * const strict_hdr;\n      struct thrift_compact_hdr const * const compact_hdr;\n    } thrift_data = { .raw_ptr = &packet->payload[0] };\n\n    if (thrift_data.raw_ptr[0] == 0x80)\n    {\n      /* Strict Binary Protocol */\n      if (packet->payload_packet_len < sizeof(*thrift_data.strict_hdr))\n      {\n        NDPI_EXCLUDE_PROTO(ndpi_struct, flow);\n        return;\n      }\n\n      ndpi_dissect_strict_hdr(ndpi_struct, flow, thrift_data.strict_hdr);\n      return;\n    } else if (thrift_data.raw_ptr[0] == 0x82) {\n      /* Compact Protocol */\n      ndpi_dissect_compact_hdr(ndpi_struct, flow, thrift_data.compact_hdr);\n      return;\n    } else {\n      /* Probably not Apache Thrift. */\n      NDPI_EXCLUDE_PROTO(ndpi_struct, flow);\n      return;\n    }\n  }\n\n  NDPI_EXCLUDE_PROTO(ndpi_struct, flow);\n}\n\nstatic u_int32_t check_ndpi_detection_func(struct ndpi_detection_module_struct * const ndpi_str,\n\t\t\t\t\t   struct ndpi_flow_struct * const flow,\n\t\t\t\t\t   NDPI_SELECTION_BITMASK_PROTOCOL_SIZE const ndpi_selection_packet,\n\t\t\t\t\t   struct ndpi_call_function_struct const * const callback_buffer,\n\t\t\t\t\t   uint32_t callback_buffer_size,\n\t\t\t\t\t   int is_tcp_without_payload)\n{\n  void *func = NULL;\n  u_int32_t num_calls = 0;\n  u_int16_t proto_index = ndpi_str->proto_defaults[flow->guessed_protocol_id].protoIdx;\n  u_int16_t proto_id = ndpi_str->proto_defaults[flow->guessed_protocol_id].protoId;\n  NDPI_PROTOCOL_BITMASK detection_bitmask;\n  u_int32_t a;\n\n  NDPI_SAVE_AS_BITMASK(detection_bitmask, flow->detected_protocol_stack[0]);\n\n  if((proto_id != NDPI_PROTOCOL_UNKNOWN) &&\n      NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,\n\t\t\t   ndpi_str->callback_buffer[proto_index].excluded_protocol_bitmask) == 0 &&\n      NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer[proto_index].detection_bitmask, detection_bitmask) != 0 &&\n      (ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask & ndpi_selection_packet) ==\n      ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask)\n    {\n      if((flow->guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN) &&\n          (ndpi_str->proto_defaults[flow->guessed_protocol_id].func != NULL) &&\n          (is_tcp_without_payload == 0 ||\n           ((ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask &\n\t     NDPI_SELECTION_BITMASK_PROTOCOL_HAS_PAYLOAD) == 0)))\n\t{\n\t  ndpi_str->proto_defaults[flow->guessed_protocol_id].func(ndpi_str, flow);\n\t  func = ndpi_str->proto_defaults[flow->guessed_protocol_id].func;\n\t  num_calls++;\n\t}\n    }\n\n  if(flow->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN)\n    {\n      for (a = 0; a < callback_buffer_size; a++) {\n        if((func != callback_buffer[a].func) &&\n            (callback_buffer[a].ndpi_selection_bitmask & ndpi_selection_packet) ==\n\t    callback_buffer[a].ndpi_selection_bitmask &&\n            NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,\n                                 callback_buffer[a].excluded_protocol_bitmask) == 0 &&\n            NDPI_BITMASK_COMPARE(callback_buffer[a].detection_bitmask,\n                                 detection_bitmask) != 0)\n\t  {\n\t    callback_buffer[a].func(ndpi_str, flow);\n\t    num_calls++;\n\n\t    if(flow->detected_protocol_stack[0] != NDPI_PROTOCOL_UNKNOWN)\n\t      {\n\t\tbreak; /* Stop after the first detected protocol. */\n\t      }\n\t  }\n      }\n    }\n\n  num_calls += check_ndpi_subprotocols(ndpi_str, flow, ndpi_selection_packet, detection_bitmask,\n                                       flow->detected_protocol_stack[0]);\n  num_calls += check_ndpi_subprotocols(ndpi_str, flow, ndpi_selection_packet, detection_bitmask,\n                                       flow->detected_protocol_stack[1]);\n\n  return num_calls;\n}\n\n\n\nndpi_protocol ndpi_detection_process_packet(struct ndpi_detection_module_struct *ndpi_str,\n\t\t\t\t\t    struct ndpi_flow_struct *flow, const unsigned char *packet_data,\n\t\t\t\t\t    const unsigned short packetlen, const u_int64_t current_time_ms,\n\t\t\t\t\t    const struct ndpi_flow_input_info *input_info) {\n\n\n  ndpi_protocol p  = ndpi_internal_detection_process_packet(ndpi_str, flow, packet_data,\n\t\t\t\t\t\t\t    packetlen, current_time_ms,\n\t\t\t\t\t\t\t    input_info);\n\n  p.master_protocol = ndpi_map_ndpi_id_to_user_proto_id(ndpi_str, p.master_protocol),\n    p.app_protocol = ndpi_map_ndpi_id_to_user_proto_id(ndpi_str, p.app_protocol);\n\n  return(p);\n}\n\nstatic struct ndpi_proto packet_processing(struct ndpi_workflow * workflow,\n\t\t\t\t\t   const u_int64_t time_ms,\n\t\t\t\t\t   u_int16_t vlan_id,\n\t\t\t\t\t   ndpi_packet_tunnel tunnel_type,\n\t\t\t\t\t   const struct ndpi_iphdr *iph,\n\t\t\t\t\t   struct ndpi_ipv6hdr *iph6,\n\t\t\t\t\t   u_int16_t ip_offset,\n\t\t\t\t\t   u_int16_t ipsize, u_int16_t rawsize,\n\t\t\t\t\t   const struct pcap_pkthdr *header,\n\t\t\t\t\t   const u_char *packet,\n\t\t\t\t\t   pkt_timeval when,\n\t\t\t\t\t   ndpi_risk *flow_risk) {\n  struct ndpi_flow_info *flow = NULL;\n  struct ndpi_flow_struct *ndpi_flow = NULL;\n  u_int8_t proto;\n  struct ndpi_tcphdr *tcph = NULL;\n  struct ndpi_udphdr *udph = NULL;\n  u_int16_t sport, dport, payload_len = 0;\n  u_int8_t *payload;\n  u_int8_t src_to_dst_direction = 1;\n  u_int8_t begin_or_end_tcp = 0;\n  struct ndpi_proto nproto = NDPI_PROTOCOL_NULL;\n\n  if(workflow->prefs.ignore_vlanid)\n    vlan_id = 0;\n\n  if(iph)\n    flow = get_ndpi_flow_info(workflow, IPVERSION, vlan_id,\n\t\t\t      tunnel_type, iph, NULL,\n\t\t\t      ip_offset, ipsize,\n\t\t\t      ntohs(iph->tot_len) ? (ntohs(iph->tot_len) - (iph->ihl * 4)) : ipsize - (iph->ihl * 4) /* TSO */,\n\t\t\t      iph->ihl * 4,\n\t\t\t      &tcph, &udph, &sport, &dport,\n\t\t\t      &proto,\n\t\t\t      &payload, &payload_len, &src_to_dst_direction, when);\n  else\n    flow = get_ndpi_flow_info6(workflow, vlan_id,\n\t\t\t       tunnel_type, iph6, ip_offset, ipsize,\n\t\t\t       &tcph, &udph, &sport, &dport,\n\t\t\t       &proto,\n\t\t\t       &payload, &payload_len, &src_to_dst_direction, when);\n\n  if(flow != NULL) {\n    pkt_timeval tdiff;\n\n    workflow->stats.ip_packet_count++;\n    workflow->stats.total_wire_bytes += rawsize + 24 /* CRC etc */,\n      workflow->stats.total_ip_bytes += rawsize;\n    ndpi_flow = flow->ndpi_flow;\n\n    if(tcph != NULL){\n      update_tcp_flags_count(flow, tcph, src_to_dst_direction);\n      if(tcph->syn && !flow->src2dst_bytes){\n\tflow->c_to_s_init_win = rawsize;\n      }else if(tcph->syn && tcph->ack && flow->src2dst_bytes == flow->c_to_s_init_win){\n\tflow->s_to_c_init_win = rawsize;\n      }\n    }\n\n    if((tcph != NULL) && (tcph->fin || tcph->rst || tcph->syn))\n      begin_or_end_tcp = 1;\n\n    if(flow->flow_last_pkt_time.tv_sec) {\n      ndpi_timer_sub(&when, &flow->flow_last_pkt_time, &tdiff);\n\n      if(flow->iat_flow\n\t && (tdiff.tv_sec >= 0) /* Discard backward time */\n\t ) {\n\tu_int64_t ms = ndpi_timeval_to_milliseconds(tdiff);\n\n\tif(ms > 0)\n\t  ndpi_data_add_value(flow->iat_flow, ms);\n      }\n    }\n\n    memcpy(&flow->flow_last_pkt_time, &when, sizeof(when));\n\n    if(src_to_dst_direction) {\n      if(flow->src2dst_last_pkt_time.tv_sec) {\n\tndpi_timer_sub(&when, &flow->src2dst_last_pkt_time, &tdiff);\n\n\tif(flow->iat_c_to_s\n\t   && (tdiff.tv_sec >= 0) /* Discard backward time */\n\t   ) {\n\t  u_int64_t ms = ndpi_timeval_to_milliseconds(tdiff);\n\n\t  ndpi_data_add_value(flow->iat_c_to_s, ms);\n\t}\n      }\n\n      ndpi_data_add_value(flow->pktlen_c_to_s, rawsize);\n      flow->src2dst_packets++, flow->src2dst_bytes += rawsize, flow->src2dst_goodput_bytes += payload_len;\n      memcpy(&flow->src2dst_last_pkt_time, &when, sizeof(when));\n\n#ifdef DIRECTION_BINS\n      if(payload_len && (flow->src2dst_packets < MAX_NUM_BIN_PKTS))\n\tndpi_inc_bin(&flow->payload_len_bin_src2dst, plen2slot(payload_len));\n#endif\n    } else {\n      if(flow->dst2src_last_pkt_time.tv_sec && (!begin_or_end_tcp)) {\n\tndpi_timer_sub(&when, &flow->dst2src_last_pkt_time, &tdiff);\n\n\tif(flow->iat_s_to_c) {\n\t  u_int64_t ms = ndpi_timeval_to_milliseconds(tdiff);\n\n\t  ndpi_data_add_value(flow->iat_s_to_c, ms);\n\t}\n      }\n      ndpi_data_add_value(flow->pktlen_s_to_c, rawsize);\n      flow->dst2src_packets++, flow->dst2src_bytes += rawsize, flow->dst2src_goodput_bytes += payload_len;\n      flow->risk &= ~(1ULL << NDPI_UNIDIRECTIONAL_TRAFFIC); /* Clear bit */\n      memcpy(&flow->dst2src_last_pkt_time, &when, sizeof(when));\n\n#ifdef DIRECTION_BINS\n      if(payload_len && (flow->dst2src_packets < MAX_NUM_BIN_PKTS))\n\tndpi_inc_bin(&flow->payload_len_bin_dst2src, plen2slot(payload_len));\n#endif\n    }\n\n#ifndef DIRECTION_BINS\n    if(payload_len && ((flow->src2dst_packets+flow->dst2src_packets) < MAX_NUM_BIN_PKTS)) {\n#if 0\n      /* Discard packets until the protocol is detected */\n      if(flow->detected_protocol.app_protocol != NDPI_PROTOCOL_UNKNOWN)\n#endif\n\tndpi_inc_bin(&flow->payload_len_bin, plen2slot(payload_len), 1);\n    }\n#endif\n\n    if(enable_payload_analyzer && (payload_len > 0))\n      ndpi_payload_analyzer(flow, src_to_dst_direction,\n\t\t\t    payload, payload_len,\n\t\t\t    workflow->stats.ip_packet_count);\n\n    if(enable_flow_stats) {\n      /* Update BD, distribution and mean. */\n      ndpi_flow_update_byte_count(flow, payload, payload_len, src_to_dst_direction);\n      ndpi_flow_update_byte_dist_mean_var(flow, payload, payload_len, src_to_dst_direction);\n      /* Update SPLT scores for first 32 packets. */\n      if((flow->entropy->src2dst_pkt_count+flow->entropy->dst2src_pkt_count) <= max_num_packets_per_flow) {\n        if(flow->bidirectional)\n          flow->entropy->score = ndpi_classify(flow->entropy->src2dst_pkt_len, flow->entropy->src2dst_pkt_time,\n\t\t\t\t\t      flow->entropy->dst2src_pkt_len, flow->entropy->dst2src_pkt_time,\n\t\t\t\t\t      flow->entropy->src2dst_start, flow->entropy->dst2src_start,\n\t\t\t\t\t      max_num_packets_per_flow, ntohs(flow->src_port), ntohs(flow->dst_port),\n\t\t\t\t\t      flow->src2dst_packets, flow->dst2src_packets,\n\t\t\t\t\t      flow->entropy->src2dst_opackets, flow->entropy->dst2src_opackets,\n\t\t\t\t\t      flow->entropy->src2dst_l4_bytes, flow->entropy->dst2src_l4_bytes, 1,\n\t\t\t\t\t      flow->entropy->src2dst_byte_count, flow->entropy->dst2src_byte_count);\n\telse\n\t  flow->entropy->score = ndpi_classify(flow->entropy->src2dst_pkt_len, flow->entropy->src2dst_pkt_time,\n\t\t\t\t\t      NULL, NULL, flow->entropy->src2dst_start, flow->entropy->src2dst_start,\n\t\t\t\t\t      max_num_packets_per_flow, ntohs(flow->src_port), ntohs(flow->dst_port),\n\t\t\t\t\t      flow->src2dst_packets, 0,\n\t\t\t\t\t      flow->entropy->src2dst_opackets, 0,\n\t\t\t\t\t      flow->entropy->src2dst_l4_bytes, 0, 1,\n\t\t\t\t\t      flow->entropy->src2dst_byte_count, NULL);\n      }\n    }\n\n    if(flow->first_seen_ms == 0)\n      flow->first_seen_ms = time_ms;\n\n    flow->last_seen_ms = time_ms;\n\n    /* Copy packets entropy if num packets count == 10 */\n    ndpi_clear_entropy_stats(flow);\n    /* Reset IAT reeference times (see https://github.com/ntop/nDPI/pull/1316) */\n    if(((flow->src2dst_packets + flow->dst2src_packets) % max_num_packets_per_flow) == 0) {\n      memset(&flow->src2dst_last_pkt_time, '\\0', sizeof(flow->src2dst_last_pkt_time));\n      memset(&flow->dst2src_last_pkt_time, '\\0', sizeof(flow->dst2src_last_pkt_time));\n      memset(&flow->flow_last_pkt_time, '\\0', sizeof(flow->flow_last_pkt_time));\n    }\n\n    if((human_readeable_string_len != 0) && (!flow->has_human_readeable_strings)) {\n      u_int8_t skip = 0;\n\n      if((proto == IPPROTO_TCP)\n\t && (\n\t     is_ndpi_proto(flow, NDPI_PROTOCOL_TLS)\n\t     || (flow->detected_protocol.master_protocol == NDPI_PROTOCOL_TLS)\n\t     || is_ndpi_proto(flow, NDPI_PROTOCOL_SSH)\n\t     || (flow->detected_protocol.master_protocol == NDPI_PROTOCOL_SSH))\n\t ) {\n\tif((flow->src2dst_packets+flow->dst2src_packets) < 10 /* MIN_NUM_ENCRYPT_SKIP_PACKETS */)\n\t  skip = 1; /* Skip initial negotiation packets */\n      }\n\n      if((!skip) && ((flow->src2dst_packets+flow->dst2src_packets) < 100)) {\n\tif(ndpi_has_human_readeable_string(workflow->ndpi_struct, (char*)packet, header->caplen,\n\t\t\t\t\t   human_readeable_string_len,\n\t\t\t\t\t   flow->human_readeable_string_buffer,\n\t\t\t\t\t   sizeof(flow->human_readeable_string_buffer)) == 1)\n\t  flow->has_human_readeable_strings = 1;\n      }\n    } else {\n      if((proto == IPPROTO_TCP)\n\t && (\n\t     is_ndpi_proto(flow, NDPI_PROTOCOL_TLS)\n\t     || (flow->detected_protocol.master_protocol == NDPI_PROTOCOL_TLS)\n\t     || is_ndpi_proto(flow, NDPI_PROTOCOL_SSH)\n\t     || (flow->detected_protocol.master_protocol == NDPI_PROTOCOL_SSH))\n\t )\n\tflow->has_human_readeable_strings = 0;\n    }\n  } else { // flow is NULL\n    workflow->stats.total_discarded_bytes += header->len;\n    return(nproto);\n  }\n\n  if(!flow->detection_completed) {\n    struct ndpi_flow_input_info input_info;\n\n    u_int enough_packets =\n      (((proto == IPPROTO_UDP) && ((flow->src2dst_packets + flow->dst2src_packets) > max_num_udp_dissected_pkts))\n       || ((proto == IPPROTO_TCP) && ((flow->src2dst_packets + flow->dst2src_packets) > max_num_tcp_dissected_pkts))) ? 1 : 0;\n\n#if 0\n    printf(\"%s()\\n\", __FUNCTION__);\n#endif\n\n    if(proto == IPPROTO_TCP)\n      workflow->stats.dpi_packet_count[0]++;\n    else if(proto == IPPROTO_UDP)\n      workflow->stats.dpi_packet_count[1]++;\n    else\n      workflow->stats.dpi_packet_count[2]++;\n    flow->dpi_packets++;\n\n    memset(&input_info, '\\0', sizeof(input_info)); /* To be sure to set to \"unknown\" any fields */\n    /* Set here any information (easily) available; in this trivial example we don't have any */\n    input_info.in_pkt_dir = NDPI_IN_PKT_DIR_UNKNOWN;\n    input_info.seen_flow_beginning = NDPI_FLOW_BEGINNING_UNKNOWN;\n    malloc_size_stats = 1;\n    flow->detected_protocol = ndpi_detection_process_packet(workflow->ndpi_struct, ndpi_flow,\n\t\t\t\t\t\t\t    iph ? (uint8_t *)iph : (uint8_t *)iph6,\n\t\t\t\t\t\t\t    ipsize, time_ms, &input_info);\n\n    enough_packets |= ndpi_flow->fail_with_unknown;\n    if(enough_packets || (flow->detected_protocol.app_protocol != NDPI_PROTOCOL_UNKNOWN)) {\n      if((!enough_packets)\n\t && ndpi_extra_dissection_possible(workflow->ndpi_struct, ndpi_flow))\n\t; /* Wait for certificate fingerprint */\n      else {\n\t/* New protocol detected or give up */\n\tflow->detection_completed = 1;\n\n#if 0\n\t/* Check if we should keep checking extra packets */\n\tif(ndpi_flow && ndpi_flow->check_extra_packets)\n\t  flow->check_extra_packets = 1;\n#endif\n\n\tif(flow->detected_protocol.app_protocol == NDPI_PROTOCOL_UNKNOWN) {\n\t  u_int8_t proto_guessed;\n\n\t  flow->detected_protocol = ndpi_detection_giveup(workflow->ndpi_struct, flow->ndpi_flow,\n\t\t\t\t\t\t\t  enable_protocol_guess, &proto_guessed);\n\t  if(enable_protocol_guess) workflow->stats.guessed_flow_protocols++;\n\t}\n\n\tprocess_ndpi_collected_info(workflow, flow);\n      }\n    }\n    malloc_size_stats = 0;\n  }\n  \n#if 0\n  if(flow->risk != 0) {\n    FILE *r = fopen(\"/tmp/e\", \"a\");\n\n    if(r) {\n      fprintf(r, \"->>> %u [%08X]\\n\", flow->risk, flow->risk);\n      fclose(r);\n    }\n  }\n#endif\n\n  *flow_risk = flow->risk;\n\n  return(flow->detected_protocol);\n}\n\nstruct ndpi_proto ndpi_workflow_process_packet(struct ndpi_workflow * workflow,\n\t\t\t\t\t       const struct pcap_pkthdr *header,\n\t\t\t\t\t       const u_char *packet,\n\t\t\t\t\t       ndpi_risk *flow_risk) {\n  /*\n   * Declare pointers to packet headers\n   */\n  /* --- Ethernet header --- */\n  const struct ndpi_ethhdr *ethernet;\n  /* --- LLC header --- */\n  const struct ndpi_llc_header_snap *llc;\n\n  /* --- Cisco HDLC header --- */\n  const struct ndpi_chdlc *chdlc;\n\n  /* --- Radio Tap header --- */\n  const struct ndpi_radiotap_header *radiotap;\n  /* --- Wifi header --- */\n  const struct ndpi_wifi_header *wifi;\n\n  /* --- MPLS header --- */\n  union mpls {\n    uint32_t u32;\n    struct ndpi_mpls_header mpls;\n  } mpls;\n\n  /** --- IP header --- **/\n  struct ndpi_iphdr *iph;\n  /** --- IPv6 header --- **/\n  struct ndpi_ipv6hdr *iph6;\n\n  struct ndpi_proto nproto = NDPI_PROTOCOL_NULL;\n  ndpi_packet_tunnel tunnel_type = ndpi_no_tunnel;\n\n  /* lengths and offsets */\n  u_int32_t eth_offset = 0, dlt;\n  u_int16_t radio_len, header_length;\n  u_int16_t fc;\n  u_int16_t type = 0;\n  int wifi_len = 0;\n  int pyld_eth_len = 0;\n  int check;\n  u_int64_t time_ms;\n  u_int16_t ip_offset = 0, ip_len;\n  u_int16_t frag_off = 0, vlan_id = 0;\n  u_int8_t proto = 0, recheck_type;\n  /*u_int32_t label;*/\n\n  /* counters */\n  u_int8_t vlan_packet = 0;\n\n  *flow_risk = 0 /* NDPI_NO_RISK */;\n\n  /* Increment raw packet counter */\n  workflow->stats.raw_packet_count++;\n\n  /* setting time */\n  time_ms = ((uint64_t) header->ts.tv_sec) * TICK_RESOLUTION + header->ts.tv_usec / (1000000 / TICK_RESOLUTION);\n\n  /* safety check */\n  if(workflow->last_time > time_ms) {\n    /* printf(\"\\nWARNING: timestamp bug in the pcap file (ts delta: %llu, repairing)\\n\", ndpi_thread_info[thread_id].last_time - time); */\n    time_ms = workflow->last_time;\n  }\n  /* update last time value */\n  workflow->last_time = time_ms;\n\n  /*** check Data Link type ***/\n  int datalink_type;\n\n#ifdef USE_DPDK\n  datalink_type = DLT_EN10MB;\n#else\n  datalink_type = (int)pcap_datalink(workflow->pcap_handle);\n#endif\n\n datalink_check:\n  // 20 for min iph and 8 for min UDP\n  if(header->caplen < eth_offset + 28)\n    return(nproto); /* Too short */\n\n  /* Keep in sync with ndpi_is_datalink_supported() */\n  switch(datalink_type) {\n  case DLT_NULL:\n    if(ntohl(*((u_int32_t*)&packet[eth_offset])) == 2)\n      type = ETH_P_IP;\n    else\n      type = ETH_P_IPV6;\n\n    ip_offset = 4 + eth_offset;\n    break;\n\n    /* Cisco PPP in HDLC-like framing - 50 */\n  case DLT_PPP_SERIAL:\n    chdlc = (struct ndpi_chdlc *) &packet[eth_offset];\n    ip_offset = eth_offset + sizeof(struct ndpi_chdlc); /* CHDLC_OFF = 4 */\n    type = ntohs(chdlc->proto_code);\n    break;\n\n    /* Cisco PPP - 9 or 104 */\n  case DLT_C_HDLC:\n  case DLT_PPP:\n    if(packet[0] == 0x0f || packet[0] == 0x8f) {\n      chdlc = (struct ndpi_chdlc *) &packet[eth_offset];\n      ip_offset = eth_offset + sizeof(struct ndpi_chdlc); /* CHDLC_OFF = 4 */\n      type = ntohs(chdlc->proto_code);\n    } else {\n      ip_offset = eth_offset + 2;\n      type = ntohs(*((u_int16_t*)&packet[eth_offset]));\n    }\n    break;\n\n#ifdef DLT_IPV4\n  case DLT_IPV4:\n    type = ETH_P_IP;\n    ip_offset = eth_offset;\n    break;\n#endif\n\n#ifdef DLT_IPV6\n  case DLT_IPV6:\n    type = ETH_P_IPV6;\n    ip_offset = eth_offset;\n    break;\n#endif\n\n    /* IEEE 802.3 Ethernet - 1 */\n  case DLT_EN10MB:\n    ethernet = (struct ndpi_ethhdr *) &packet[eth_offset];\n    ip_offset = sizeof(struct ndpi_ethhdr) + eth_offset;\n    check = ntohs(ethernet->h_proto);\n\n    if(check <= 1500)\n      pyld_eth_len = check;\n    else if(check >= 1536)\n      type = check;\n\n    if(pyld_eth_len != 0) {\n      llc = (struct ndpi_llc_header_snap *)(&packet[ip_offset]);\n      /* check for LLC layer with SNAP extension */\n      if(llc->dsap == SNAP || llc->ssap == SNAP) {\n\ttype = llc->snap.proto_ID;\n\tip_offset += + 8;\n      }\n      /* No SNAP extension - Spanning Tree pkt must be discarted */\n      else if(llc->dsap == BSTP || llc->ssap == BSTP) {\n\tgoto v4_warning;\n      }\n    }\n    break;\n\n    /* Linux Cooked Capture - 113 */\n  case DLT_LINUX_SLL:\n    type = (packet[eth_offset+14] << 8) + packet[eth_offset+15];\n    ip_offset = 16 + eth_offset;\n    break;\n\n    /* Linux Cooked Capture v2 - 276 */\n  case LINKTYPE_LINUX_SLL2:\n    type = (packet[eth_offset+10] << 8) + packet[eth_offset+11];\n    ip_offset = 20 + eth_offset;\n    break;\n\n    /* Radiotap link-layer - 127 */\n  case DLT_IEEE802_11_RADIO:\n    radiotap = (struct ndpi_radiotap_header *) &packet[eth_offset];\n    radio_len = radiotap->len;\n\n    /* Check Bad FCS presence */\n    if((radiotap->flags & BAD_FCS) == BAD_FCS) {\n      workflow->stats.total_discarded_bytes +=  header->len;\n      return(nproto);\n    }\n\n    if(header->caplen < (eth_offset + radio_len + sizeof(struct ndpi_wifi_header)))\n      return(nproto);\n\n    /* Calculate 802.11 header length (variable) */\n    wifi = (struct ndpi_wifi_header*)( packet + eth_offset + radio_len);\n    fc = wifi->fc;\n\n    /* check wifi data presence */\n    if(FCF_TYPE(fc) == WIFI_DATA) {\n      if((FCF_TO_DS(fc) && FCF_FROM_DS(fc) == 0x0) ||\n\t (FCF_TO_DS(fc) == 0x0 && FCF_FROM_DS(fc)))\n\twifi_len = 26; /* + 4 byte fcs */\n    } else   /* no data frames */\n      return(nproto);\n\n    /* Check ether_type from LLC */\n    if(header->caplen < (eth_offset + wifi_len + radio_len + sizeof(struct ndpi_llc_header_snap)))\n      return(nproto);\n    llc = (struct ndpi_llc_header_snap*)(packet + eth_offset + wifi_len + radio_len);\n    if(llc->dsap == SNAP)\n      type = ntohs(llc->snap.proto_ID);\n\n    /* Set IP header offset */\n    ip_offset = wifi_len + radio_len + sizeof(struct ndpi_llc_header_snap) + eth_offset;\n    break;\n\n  case DLT_RAW:\n    ip_offset = eth_offset;\n    break;\n\n  case DLT_PPI:\n    header_length = le16toh(*(u_int16_t *)&packet[eth_offset + 2]);\n    dlt = le32toh(*(u_int32_t *)&packet[eth_offset + 4]);\n    if(dlt != DLT_EN10MB) /* Handle only standard ethernet, for the time being */\n      return(nproto);\n    datalink_type = DLT_EN10MB;\n    eth_offset += header_length;\n    goto datalink_check;\n\n  default:\n    /*\n     * We shoudn't be here, because we already checked that this datalink is supported.\n     * Should ndpi_is_datalink_supported() be updated?\n     */\n    printf(\"Unknown datalink %d\\n\", datalink_type);\n    return(nproto);\n  }\n\n ether_type_check:\n  recheck_type = 0;\n\n  /* check ether type */\n  switch(type) {\n  case ETH_P_VLAN:\n    if(ip_offset+4 >= (int)header->caplen)\n      return(nproto);\n    vlan_id = ((packet[ip_offset] << 8) + packet[ip_offset+1]) & 0xFFF;\n    type = (packet[ip_offset+2] << 8) + packet[ip_offset+3];\n    ip_offset += 4;\n    vlan_packet = 1;\n\n    // double tagging for 802.1Q\n    while((type == 0x8100) && (((bpf_u_int32)ip_offset+4) < header->caplen)) {\n      vlan_id = ((packet[ip_offset] << 8) + packet[ip_offset+1]) & 0xFFF;\n      type = (packet[ip_offset+2] << 8) + packet[ip_offset+3];\n      ip_offset += 4;\n    }\n    recheck_type = 1;\n    break;\n\n  case ETH_P_MPLS_UNI:\n  case ETH_P_MPLS_MULTI:\n    if(ip_offset+4 >= (int)header->caplen)\n      return(nproto);\n    mpls.u32 = *((uint32_t *) &packet[ip_offset]);\n    mpls.u32 = ntohl(mpls.u32);\n    workflow->stats.mpls_count++;\n    type = ETH_P_IP, ip_offset += 4;\n\n    while(!mpls.mpls.s && (((bpf_u_int32)ip_offset) + 4 < header->caplen)) {\n      mpls.u32 = *((uint32_t *) &packet[ip_offset]);\n      mpls.u32 = ntohl(mpls.u32);\n      ip_offset += 4;\n    }\n    recheck_type = 1;\n    break;\n\n  case ETH_P_PPPoE:\n    workflow->stats.pppoe_count++;\n    type = ETH_P_IP;\n    ip_offset += 8;\n    recheck_type = 1;\n    break;\n\n  default:\n    break;\n  }\n\n  if(recheck_type)\n    goto ether_type_check;\n\n  workflow->stats.vlan_count += vlan_packet;\n\n iph_check:\n  /* Check and set IP header size and total packet length */\n  if(header->caplen < ip_offset + sizeof(struct ndpi_iphdr))\n    return(nproto); /* Too short for next IP header*/\n\n  iph = (struct ndpi_iphdr *) &packet[ip_offset];\n\n  /* just work on Ethernet packets that contain IP */\n  if(type == ETH_P_IP && header->caplen >= ip_offset) {\n    frag_off = ntohs(iph->frag_off);\n\n    proto = iph->protocol;\n    if(header->caplen < header->len) {\n      static u_int8_t cap_warning_used = 0;\n\n      if(cap_warning_used == 0) {\n\tif(!workflow->prefs.quiet_mode)\n\t  LOG(NDPI_LOG_DEBUG,\n\t\t   \"\\n\\nWARNING: packet capture size is smaller than packet size, DETECTION MIGHT NOT WORK CORRECTLY\\n\\n\");\n\tcap_warning_used = 1;\n      }\n    }\n  }\n\n  if(iph->version == IPVERSION) {\n    ip_len = ((u_int16_t)iph->ihl * 4);\n    iph6 = NULL;\n\n    if(iph->protocol == IPPROTO_IPV6\n       || iph->protocol == NDPI_IPIP_PROTOCOL_TYPE\n       ) {\n      ip_offset += ip_len;\n      if(ip_len > 0)\n        goto iph_check;\n    }\n\n    if((frag_off & 0x1FFF) != 0) {\n      static u_int8_t ipv4_frags_warning_used = 0;\n      workflow->stats.fragmented_count++;\n\n      if(ipv4_frags_warning_used == 0) {\n\tif(!workflow->prefs.quiet_mode)\n\t  LOG(NDPI_LOG_DEBUG, \"\\n\\nWARNING: IPv4 fragments are not handled by this demo (nDPI supports them)\\n\");\n\tipv4_frags_warning_used = 1;\n      }\n\n      workflow->stats.total_discarded_bytes +=  header->len;\n      return(nproto);\n    }\n  } else if(iph->version == 6) {\n    if(header->caplen < ip_offset + sizeof(struct ndpi_ipv6hdr))\n      return(nproto); /* Too short for IPv6 header*/\n\n    iph6 = (struct ndpi_ipv6hdr *)&packet[ip_offset];\n    proto = iph6->ip6_hdr.ip6_un1_nxt;\n    ip_len = ntohs(iph6->ip6_hdr.ip6_un1_plen);\n\n    if(header->caplen < (ip_offset + sizeof(struct ndpi_ipv6hdr) + ntohs(iph6->ip6_hdr.ip6_un1_plen)))\n      return(nproto); /* Too short for IPv6 payload*/\n\n    const u_int8_t *l4ptr = (((const u_int8_t *) iph6) + sizeof(struct ndpi_ipv6hdr));\n    u_int16_t ipsize = header->caplen - ip_offset;\n\n    if(ndpi_handle_ipv6_extension_headers(ipsize - sizeof(struct ndpi_ipv6hdr), &l4ptr, &ip_len, &proto) != 0) {\n      return(nproto);\n    }\n\n    if(proto == IPPROTO_IPV6\n       || proto == NDPI_IPIP_PROTOCOL_TYPE\n       ) {\n      if(l4ptr > packet) { /* Better safe than sorry */\n        ip_offset = (l4ptr - packet);\n        goto iph_check;\n      }\n    }\n\n    iph = NULL;\n  } else {\n    static u_int8_t ipv4_warning_used = 0;\n\n  v4_warning:\n    if(ipv4_warning_used == 0) {\n      if(!workflow->prefs.quiet_mode)\n        LOG(NDPI_LOG_DEBUG,\n\t\t \"\\n\\nWARNING: only IPv4/IPv6 packets are supported in this demo (nDPI supports both IPv4 and IPv6), all other packets will be discarded\\n\\n\");\n      ipv4_warning_used = 1;\n    }\n\n    workflow->stats.total_discarded_bytes +=  header->len;\n    return(nproto);\n  }\n\n  if(workflow->prefs.decode_tunnels && (proto == IPPROTO_UDP)) {\n    if(header->caplen < ip_offset + ip_len + sizeof(struct ndpi_udphdr))\n      return(nproto); /* Too short for UDP header*/\n    else {\n      struct ndpi_udphdr *udp = (struct ndpi_udphdr *)&packet[ip_offset+ip_len];\n      u_int16_t sport = ntohs(udp->source), dport = ntohs(udp->dest);\n\n      if(((sport == GTP_U_V1_PORT) || (dport == GTP_U_V1_PORT)) &&\n         (ip_offset + ip_len + sizeof(struct ndpi_udphdr) + 8 /* Minimum GTPv1 header len */ < header->caplen)) {\n\t/* Check if it's GTPv1 */\n\tu_int offset = ip_offset+ip_len+sizeof(struct ndpi_udphdr);\n\tu_int8_t flags = packet[offset];\n\tu_int8_t message_type = packet[offset+1];\n\tu_int8_t exts_parsing_error = 0;\n\n\tif((((flags & 0xE0) >> 5) == 1 /* GTPv1 */) &&\n\t   (message_type == 0xFF /* T-PDU */)) {\n\n\t  offset += 8; /* GTPv1 header len */\n\t  if(flags & 0x07)\n\t    offset += 4; /* sequence_number + pdu_number + next_ext_header fields */\n\t  /* Extensions parsing */\n\t  if(flags & 0x04) {\n\t    unsigned int ext_length = 0;\n\n\t    while(offset < header->caplen) {\n\t      ext_length = packet[offset] << 2;\n\t      offset += ext_length;\n\t      if(offset >= header->caplen || ext_length == 0) {\n\t        exts_parsing_error = 1;\n\t        break;\n\t      }\n\t      if(packet[offset - 1] == 0)\n\t        break;\n\t    }\n\t  }\n\n\t  if(offset < header->caplen && !exts_parsing_error) {\n\t    /* Ok, valid GTP-U */\n\t    tunnel_type = ndpi_gtp_tunnel;\n\t    ip_offset = offset;\n\t    iph = (struct ndpi_iphdr *)&packet[ip_offset];\n\t    if(iph->version == 6) {\n\t      iph6 = (struct ndpi_ipv6hdr *)&packet[ip_offset];\n\t      iph = NULL;\n              if(header->caplen < ip_offset + sizeof(struct ndpi_ipv6hdr))\n\t        return(nproto);\n\t    } else if(iph->version != IPVERSION) {\n\t      // printf(\"WARNING: not good (packet_id=%u)!\\n\", (unsigned int)workflow->stats.raw_packet_count);\n\t      goto v4_warning;\n\t    } else {\n              if(header->caplen < ip_offset + sizeof(struct ndpi_iphdr))\n\t        return(nproto);\n\t    }\n\t  }\n\t}\n      } else if((sport == TZSP_PORT) || (dport == TZSP_PORT)) {\n\t/* https://en.wikipedia.org/wiki/TZSP */\n\tif(header->caplen < ip_offset + ip_len + sizeof(struct ndpi_udphdr) + 4)\n\t  return(nproto); /* Too short for TZSP*/\n\n\tu_int offset           = ip_offset+ip_len+sizeof(struct ndpi_udphdr);\n\tu_int8_t version       = packet[offset];\n\tu_int8_t ts_type       = packet[offset+1];\n\tu_int16_t encapsulates = ntohs(*((u_int16_t*)&packet[offset+2]));\n\n\ttunnel_type = ndpi_tzsp_tunnel;\n\n\tif((version == 1) && (ts_type == 0) && (encapsulates == 1)) {\n\t  u_int8_t stop = 0;\n\n\t  offset += 4;\n\n\t  while((!stop) && (offset < header->caplen)) {\n\t    u_int8_t tag_type = packet[offset];\n\t    u_int8_t tag_len;\n\n\t    switch(tag_type) {\n\t    case 0: /* PADDING Tag */\n\t      tag_len = 1;\n\t      break;\n\t    case 1: /* END Tag */\n\t      tag_len = 1, stop = 1;\n\t      break;\n\t    default:\n\t      if(offset + 1 >= header->caplen)\n\t        return(nproto); /* Invalid packet */\n\t      tag_len = packet[offset+1];\n\t      break;\n\t    }\n\n\t    offset += tag_len;\n\n\t    if(offset >= header->caplen)\n\t      return(nproto); /* Invalid packet */\n\t    else {\n\t      eth_offset = offset;\n\t      goto datalink_check;\n\t    }\n\t  }\n\t}\n      } else if((sport == NDPI_CAPWAP_DATA_PORT) || (dport == NDPI_CAPWAP_DATA_PORT)) {\n\t/* We dissect ONLY CAPWAP traffic */\n\tu_int offset           = ip_offset+ip_len+sizeof(struct ndpi_udphdr);\n\n\tif((offset+1) < header->caplen) {\n\t  uint8_t preamble = packet[offset];\n\n\t  if((preamble & 0x0F) == 0) { /* CAPWAP header */\n\t    u_int16_t msg_len = (packet[offset+1] & 0xF8) >> 1;\n\n\t    offset += msg_len;\n\n\t    if((offset + 32 < header->caplen) &&\n\t       (packet[offset + 1] == 0x08)) {\n\t      /* IEEE 802.11 Data */\n\t      offset += 24;\n\t      /* LLC header is 8 bytes */\n\t      type = ntohs((u_int16_t)*((u_int16_t*)&packet[offset+6]));\n\n\t      ip_offset = offset + 8;\n\n\t      tunnel_type = ndpi_capwap_tunnel;\n\t      goto iph_check;\n\t    }\n\t  }\n\t}\n      }else if(ndpi_is_valid_vxlan(header, packet, ip_offset, ip_len)){\n\t      tunnel_type = ndpi_vxlan_tunnel;\n        eth_offset = ndpi_skip_vxlan(ip_offset, ip_len);\n\t      goto datalink_check;\n      }\n    }\n  } else if(workflow->prefs.decode_tunnels && (proto == IPPROTO_GRE)) {\n    if(header->caplen < ip_offset + ip_len + sizeof(struct ndpi_gre_basehdr))\n      return(nproto); /* Too short for GRE header*/\n    u_int32_t offset = 0;\n    if((offset = ndpi_is_valid_gre_tunnel(header, packet, ip_offset, ip_len))) {\n      tunnel_type = ndpi_gre_tunnel;\n      struct ndpi_gre_basehdr *grehdr = (struct ndpi_gre_basehdr*)&packet[ip_offset + ip_len];\n      if(grehdr->protocol == ntohs(ETH_P_IP) || grehdr->protocol == ntohs(ETH_P_IPV6)) { \n        ip_offset = offset;\n        goto iph_check; \n      } else if(grehdr->protocol ==  NDPI_GRE_PROTO_PPP) {  // ppp protocol\n        ip_offset = offset + NDPI_PPP_HDRLEN; \n        goto iph_check;\n      } else {\n        eth_offset = offset;\n        goto datalink_check;\n      }\n    } else {\n      return(nproto);\n    }\n  }\n\n  /* process the packet */\n  return(packet_processing(workflow, time_ms, vlan_id, tunnel_type, iph, iph6,\n\t\t\t   ip_offset, header->caplen - ip_offset,\n\t\t\t   header->caplen, header, packet, header->ts,\n\t\t\t   flow_risk));\n}\n\n\n// target function\nstatic void thrift_set_method(struct ndpi_detection_module_struct *ndpi_struct,\n                              struct ndpi_flow_struct *flow,\n                              char const * const method, size_t method_length)\n{\n  if (thrift_validate_method(method, method_length) == 0) {\n    ndpi_set_risk(ndpi_struct, flow, NDPI_INVALID_CHARACTERS, \"Invalid method name\");\n    flow->protos.thrift.method[0] = '\\0';\n  } else {\n    strncpy(flow->protos.thrift.method, method, method_length);\n  }\n}\n",
    "target": 1,
    "idx": 1060070,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\notError Commissioner::GeneratePskc(const char *              aPassPhrase,\n                                   const char *              aNetworkName,\n                                   const Mac::ExtendedPanId &aExtPanId,\n                                   Pskc &                    aPskc)\n{\n    otError     error      = OT_ERROR_NONE;\n    const char *saltPrefix = \"Thread\";\n    uint8_t     salt[OT_PBKDF2_SALT_MAX_LEN];\n    uint16_t    saltLen = 0;\n\n    VerifyOrExit((strlen(aPassPhrase) >= OT_COMMISSIONING_PASSPHRASE_MIN_SIZE) &&\n                     (strlen(aPassPhrase) <= OT_COMMISSIONING_PASSPHRASE_MAX_SIZE) &&\n                     (strlen(aNetworkName) <= OT_NETWORK_NAME_MAX_SIZE),\n                 error = OT_ERROR_INVALID_ARGS);\n\n    memset(salt, 0, sizeof(salt));\n    memcpy(salt, saltPrefix, strlen(saltPrefix));\n    saltLen += static_cast<uint16_t>(strlen(saltPrefix));\n\n    memcpy(salt + saltLen, aExtPanId.m8, sizeof(aExtPanId));\n    saltLen += OT_EXT_PAN_ID_SIZE;\n\n    memcpy(salt + saltLen, aNetworkName, strlen(aNetworkName));\n    saltLen += static_cast<uint16_t>(strlen(aNetworkName));\n\n    otPbkdf2Cmac(reinterpret_cast<const uint8_t *>(aPassPhrase), static_cast<uint16_t>(strlen(aPassPhrase)),\n                 reinterpret_cast<const uint8_t *>(salt), saltLen, 16384, OT_PSKC_MAX_SIZE, aPskc.m8);\n\nexit:\n    return error;\n}\n\notError NcpBase::HandlePropertySet_SPINEL_PROP_MESHCOP_COMMISSIONER_GENERATE_PSKC(uint8_t aHeader)\n{\n    otError        error = OT_ERROR_NONE;\n    const char *   passPhrase;\n    const char *   networkName;\n    const uint8_t *extPanIdData;\n    uint16_t       length;\n    otPskc         pskc;\n\n    SuccessOrExit(error = mDecoder.ReadUtf8(passPhrase));\n    SuccessOrExit(error = mDecoder.ReadUtf8(networkName));\n    SuccessOrExit(error = mDecoder.ReadDataWithLen(extPanIdData, length));\n    VerifyOrExit(length == sizeof(spinel_net_xpanid_t), error = OT_ERROR_PARSE);\n\n    SuccessOrExit(error = otCommissionerGeneratePskc(passPhrase, networkName,\n                                                     reinterpret_cast<const otExtendedPanId *>(extPanIdData), &pskc));\n\n    SuccessOrExit(\n        error = mEncoder.BeginFrame(aHeader, SPINEL_CMD_PROP_VALUE_IS, SPINEL_PROP_MESHCOP_COMMISSIONER_GENERATE_PSKC));\n    SuccessOrExit(error = mEncoder.WriteData(pskc.m8, sizeof(pskc)));\n    SuccessOrExit(error = mEncoder.EndFrame());\n\nexit:\n    return error;\n}\n\nbool NcpBase::HandlePropertySetForSpecialProperties(uint8_t aHeader, spinel_prop_key_t aKey, otError &aError)\n{\n    bool didHandle = true;\n\n    // Here the properties that require special treatment are handled.\n    // These properties are expected to form/write the response from\n    // their set handler directly.\n\n    switch (aKey)\n    {\n    case SPINEL_PROP_HOST_POWER_STATE:\n        ExitNow(aError = HandlePropertySet_SPINEL_PROP_HOST_POWER_STATE(aHeader));\n\n#if OPENTHREAD_CONFIG_DIAG_ENABLE\n    case SPINEL_PROP_NEST_STREAM_MFG:\n        ExitNow(aError = HandlePropertySet_SPINEL_PROP_NEST_STREAM_MFG(aHeader));\n#endif\n\n#if OPENTHREAD_FTD && OPENTHREAD_CONFIG_COMMISSIONER_ENABLE\n    case SPINEL_PROP_MESHCOP_COMMISSIONER_GENERATE_PSKC:\n        ExitNow(aError = HandlePropertySet_SPINEL_PROP_MESHCOP_COMMISSIONER_GENERATE_PSKC(aHeader));\n\n    case SPINEL_PROP_THREAD_COMMISSIONER_ENABLED:\n        ExitNow(aError = HandlePropertySet_SPINEL_PROP_THREAD_COMMISSIONER_ENABLED(aHeader));\n#endif\n\n#if OPENTHREAD_RADIO || OPENTHREAD_CONFIG_LINK_RAW_ENABLE\n    case SPINEL_PROP_STREAM_RAW:\n        ExitNow(aError = HandlePropertySet_SPINEL_PROP_STREAM_RAW(aHeader));\n#endif\n\n    default:\n        didHandle = false;\n        break;\n    }\n\nexit:\n    return didHandle;\n}\n\notError NcpBase::HandleCommandPropertySet(uint8_t aHeader, spinel_prop_key_t aKey)\n{\n    otError         error   = OT_ERROR_NONE;\n    PropertyHandler handler = FindSetPropertyHandler(aKey);\n\n    if (handler != NULL)\n    {\n        mDisableStreamWrite = false;\n        error               = (this->*handler)();\n        mDisableStreamWrite = true;\n    }\n    else\n    {\n        // If there is no \"set\" handler, check if this property is one of the\n        // ones that require different treatment.\n\n        bool didHandle = HandlePropertySetForSpecialProperties(aHeader, aKey, error);\n\n        VerifyOrExit(!didHandle);\n\n#if OPENTHREAD_ENABLE_NCP_VENDOR_HOOK\n        if (aKey >= SPINEL_PROP_VENDOR__BEGIN && aKey < SPINEL_PROP_VENDOR__END)\n        {\n            mDisableStreamWrite = false;\n            error               = VendorSetPropertyHandler(aKey);\n            mDisableStreamWrite = true;\n\n            // An `OT_ERROR_NOT_FOUND` status from vendor handler indicates\n            // that it does not support the given property key. In that\n            // case, `didHandle` is set to `false` so a `LAST_STATUS` with\n            // `PROP_NOT_FOUND` is emitted. Otherwise, we fall through to\n            // prepare the response.\n\n            didHandle = (error != OT_ERROR_NOT_FOUND);\n        }\n#endif\n\n        VerifyOrExit(didHandle, error = PrepareLastStatusResponse(aHeader, SPINEL_STATUS_PROP_NOT_FOUND));\n    }\n\n    if (error == OT_ERROR_NONE)\n    {\n        error = PrepareSetResponse(aHeader, aKey);\n    }\n    else\n    {\n        error = PrepareLastStatusResponse(aHeader, ThreadErrorToSpinelStatus(error));\n    }\n\nexit:\n    return error;\n}\n\notError NcpBase::CommandHandler_PROP_VALUE_update(uint8_t aHeader, unsigned int aCommand)\n{\n    otError      error   = OT_ERROR_NONE;\n    unsigned int propKey = 0;\n\n    error = mDecoder.ReadUintPacked(propKey);\n\n    VerifyOrExit(error == OT_ERROR_NONE, error = PrepareLastStatusResponse(aHeader, ThreadErrorToSpinelStatus(error)));\n\n    switch (aCommand)\n    {\n    case SPINEL_CMD_PROP_VALUE_GET:\n        error = PrepareGetResponse(aHeader, static_cast<spinel_prop_key_t>(propKey));\n        break;\n\n    case SPINEL_CMD_PROP_VALUE_SET:\n        error = HandleCommandPropertySet(aHeader, static_cast<spinel_prop_key_t>(propKey));\n        break;\n\n    case SPINEL_CMD_PROP_VALUE_INSERT:\n    case SPINEL_CMD_PROP_VALUE_REMOVE:\n        error = HandleCommandPropertyInsertRemove(aHeader, static_cast<spinel_prop_key_t>(propKey), aCommand);\n        break;\n\n    default:\n        break;\n    }\n\nexit:\n    return error;\n}\n\notError NcpBase::HandleCommand(uint8_t aHeader)\n{\n    otError      error = OT_ERROR_NONE;\n    unsigned int command;\n\n    SuccessOrExit(error = mDecoder.ReadUintPacked(command));\n\n    switch (command)\n    {\n    case SPINEL_CMD_NOOP:\n        error = CommandHandler_NOOP(aHeader);\n        break;\n\n    case SPINEL_CMD_RESET:\n        error = CommandHandler_RESET(aHeader);\n        break;\n\n    case SPINEL_CMD_PROP_VALUE_GET:\n    case SPINEL_CMD_PROP_VALUE_SET:\n    case SPINEL_CMD_PROP_VALUE_INSERT:\n    case SPINEL_CMD_PROP_VALUE_REMOVE:\n        error = CommandHandler_PROP_VALUE_update(aHeader, command);\n        break;\n\n#if OPENTHREAD_CONFIG_NCP_ENABLE_PEEK_POKE\n    case SPINEL_CMD_PEEK:\n        error = CommandHandler_PEEK(aHeader);\n        break;\n\n    case SPINEL_CMD_POKE:\n        error = CommandHandler_POKE(aHeader);\n        break;\n#endif\n\n#if OPENTHREAD_MTD || OPENTHREAD_FTD\n    case SPINEL_CMD_NET_SAVE:\n        error = CommandHandler_NET_SAVE(aHeader);\n        break;\n\n    case SPINEL_CMD_NET_CLEAR:\n        error = CommandHandler_NET_CLEAR(aHeader);\n        break;\n\n    case SPINEL_CMD_NET_RECALL:\n        error = CommandHandler_NET_RECALL(aHeader);\n        break;\n#endif // OPENTHREAD_MTD || OPENTHREAD_FTD\n\n    default:\n\n#if OPENTHREAD_ENABLE_NCP_VENDOR_HOOK\n        if (command >= SPINEL_CMD_VENDOR__BEGIN && command < SPINEL_CMD_VENDOR__END)\n        {\n            error = VendorCommandHandler(aHeader, command);\n            break;\n        }\n#endif\n\n        error = PrepareLastStatusResponse(aHeader, SPINEL_STATUS_INVALID_COMMAND);\n        break;\n    }\n\nexit:\n    return error;\n}\n\nvoid NcpBase::HandleReceive(const uint8_t *aBuf, uint16_t aBufLength)\n{\n    otError      error  = OT_ERROR_NONE;\n    uint8_t      header = 0;\n    spinel_tid_t tid    = 0;\n\n    mDisableStreamWrite = true;\n\n    // Initialize the decoder with the newly received spinel frame.\n    mDecoder.Init(aBuf, aBufLength);\n\n    // Receiving any message from the host has the side effect of transitioning the host power state to online.\n    mHostPowerState           = SPINEL_HOST_POWER_STATE_ONLINE;\n    mHostPowerStateInProgress = false;\n\n    // Skip if there is no header byte to read or this isn't a spinel frame.\n\n    SuccessOrExit(mDecoder.ReadUint8(header));\n    VerifyOrExit((SPINEL_HEADER_FLAG & header) == SPINEL_HEADER_FLAG);\n\n    mRxSpinelFrameCounter++;\n\n    // We only support IID zero for now.\n    if (SPINEL_HEADER_GET_IID(header) != 0)\n    {\n        WriteLastStatusFrame(header, SPINEL_STATUS_INVALID_INTERFACE);\n        ExitNow();\n    }\n\n    error = HandleCommand(header);\n\n    if (error != OT_ERROR_NONE)\n    {\n        PrepareLastStatusResponse(header, ThreadErrorToSpinelStatus(error));\n    }\n\n    if (!IsResponseQueueEmpty())\n    {\n        // A response may have been prepared and queued for this command,\n        // so we attempt to send/write any queued responses. Note that\n        // if the response was prepared but cannot be sent now (not\n        // enough buffer space available), it will be attempted again\n        // from `HandleFrameRemovedFromNcpBuffer()` when buffer space\n        // becomes available.\n\n        IgnoreReturnValue(SendQueuedResponses());\n    }\n\n    // Check for out of sequence TIDs and update `mNextExpectedTid`,\n\n    tid = SPINEL_HEADER_GET_TID(header);\n\n    if ((mNextExpectedTid != 0) && (tid != mNextExpectedTid))\n    {\n        mRxSpinelOutOfOrderTidCounter++;\n    }\n\n    mNextExpectedTid = SPINEL_GET_NEXT_TID(tid);\n\nexit:\n    mDisableStreamWrite = false;\n}\n\nvoid NcpUart::HandleFrame(otError aError)\n{\n    uint8_t *buf       = mRxBuffer.GetFrame();\n    uint16_t bufLength = mRxBuffer.GetLength();\n\n    if (aError == OT_ERROR_NONE)\n    {\n#if OPENTHREAD_ENABLE_NCP_SPINEL_ENCRYPTER\n        size_t dataLen = bufLength;\n        if (SpinelEncrypter::DecryptInbound(buf, kRxBufferSize, &dataLen))\n        {\n            super_t::HandleReceive(buf, dataLen);\n        }\n#else\n        super_t::HandleReceive(buf, bufLength);\n#endif // OPENTHREAD_ENABLE_NCP_SPINEL_ENCRYPTER\n    }\n    else\n    {\n        HandleError(aError, buf, bufLength);\n    }\n\n    mRxBuffer.Clear();\n}\n\nvoid Decoder::Decode(const uint8_t *aData, uint16_t aLength)\n{\n    while (aLength--)\n    {\n        uint8_t byte = *aData++;\n\n        switch (mState)\n        {\n        case kStateNoSync:\n            if (byte == kFlagSequence)\n            {\n                mState         = kStateSync;\n                mDecodedLength = 0;\n                mFcs           = kInitFcs;\n            }\n\n            break;\n\n        case kStateSync:\n            switch (byte)\n            {\n            case kEscapeSequence:\n                mState = kStateEscaped;\n                break;\n\n            case kFlagSequence:\n\n                if (mDecodedLength > 0)\n                {\n                    otError error = OT_ERROR_PARSE;\n\n                    if ((mDecodedLength >= kFcsSize)\n#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n                        && (mFcs == kGoodFcs)\n#endif\n                    )\n                    {\n                        // Remove the FCS from the frame.\n                        mWritePointer.UndoLastWrites(kFcsSize);\n                        error = OT_ERROR_NONE;\n                    }\n\n                    mFrameHandler(mContext, error);\n                }\n\n                mDecodedLength = 0;\n                mFcs           = kInitFcs;\n                break;\n\n            default:\n                if (mWritePointer.CanWrite(sizeof(uint8_t)))\n                {\n                    mFcs = UpdateFcs(mFcs, byte);\n                    mWritePointer.WriteByte(byte);\n                    mDecodedLength++;\n                }\n                else\n                {\n                    mFrameHandler(mContext, OT_ERROR_NO_BUFS);\n                    mState = kStateNoSync;\n                }\n\n                break;\n            }\n\n            break;\n\n        case kStateEscaped:\n            if (mWritePointer.CanWrite(sizeof(uint8_t)))\n            {\n                byte ^= 0x20;\n                mFcs = UpdateFcs(mFcs, byte);\n                mWritePointer.WriteByte(byte);\n                mDecodedLength++;\n                mState = kStateSync;\n            }\n            else\n            {\n                mFrameHandler(mContext, OT_ERROR_NO_BUFS);\n                mState = kStateNoSync;\n            }\n\n            break;\n        }\n    }\n}\n\n\n// target function\notError Commissioner::GeneratePskc(const char *              aPassPhrase,\n                                   const char *              aNetworkName,\n                                   const Mac::ExtendedPanId &aExtPanId,\n                                   Pskc &                    aPskc)\n{\n    otError     error      = OT_ERROR_NONE;\n    const char *saltPrefix = \"Thread\";\n    uint8_t     salt[OT_PBKDF2_SALT_MAX_LEN];\n    uint16_t    saltLen = 0;\n\n    VerifyOrExit((strlen(aPassPhrase) >= OT_COMMISSIONING_PASSPHRASE_MIN_SIZE) &&\n                     (strlen(aPassPhrase) <= OT_COMMISSIONING_PASSPHRASE_MAX_SIZE),\n                 error = OT_ERROR_INVALID_ARGS);\n\n    memset(salt, 0, sizeof(salt));\n    memcpy(salt, saltPrefix, strlen(saltPrefix));\n    saltLen += static_cast<uint16_t>(strlen(saltPrefix));\n\n    memcpy(salt + saltLen, aExtPanId.m8, sizeof(aExtPanId));\n    saltLen += OT_EXT_PAN_ID_SIZE;\n\n    memcpy(salt + saltLen, aNetworkName, strlen(aNetworkName));\n    saltLen += static_cast<uint16_t>(strlen(aNetworkName));\n\n    otPbkdf2Cmac(reinterpret_cast<const uint8_t *>(aPassPhrase), static_cast<uint16_t>(strlen(aPassPhrase)),\n                 reinterpret_cast<const uint8_t *>(salt), saltLen, 16384, OT_PSKC_MAX_SIZE, aPskc.m8);\n\nexit:\n    return error;\n}\n",
    "target": 1,
    "idx": 1019386,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nint msc_zero_object(sc_card_t *card, msc_id objectId, size_t dataLength)\n{\n\tu8 zeroBuffer[MSC_MAX_APDU];\n\tsize_t i;\n\tsize_t max_write_unit = MIN(MSC_MAX_APDU, MSC_MAX_SEND - 9); /* - 9 for object ID+length */\n\n\tmemset(zeroBuffer, 0, max_write_unit);\n\tfor(i = 0; i < dataLength; i += max_write_unit) {\n\t\tint r = msc_partial_update_object(card, objectId, i, zeroBuffer, MIN(dataLength - i, max_write_unit));\n\t\tLOG_TEST_RET(card->ctx, r, \"Error in zeroing file update\");\n\t}\n\treturn 0;\n}\n\nint msc_create_object(sc_card_t *card, msc_id objectId, size_t objectSize, unsigned short readAcl, unsigned short writeAcl, unsigned short deleteAcl)\n{\n\tu8 buffer[14];\n\tsc_apdu_t apdu;\n\tint r;\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x5A, 0x00, 0x00);\n\tapdu.lc = 14;\n\tapdu.data = buffer,\n\tapdu.datalen = 14;\n\t\n\tmemcpy(buffer, objectId.id, 4);\n\tulong2bebytes(buffer + 4, objectSize);\n\tushort2bebytes(buffer + 8, readAcl);\n\tushort2bebytes(buffer + 10, writeAcl);\n\tushort2bebytes(buffer + 12, deleteAcl);\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\tif(apdu.sw1 == 0x90 && apdu.sw2 == 0x00)\n\t\treturn objectSize;\n\tif(apdu.sw1 == 0x9C) {\n\t\tif(apdu.sw2 == 0x01) {\n\t\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_MEMORY_FAILURE);\n\t\t} else if(apdu.sw2 == 0x08) {\n\t\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_FILE_ALREADY_EXISTS);\n\t\t} else if(apdu.sw2 == 0x06) {\n\t\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_NOT_ALLOWED);\n\t\t}\n\t}\n\tif (card->ctx->debug >= 2) {\n\t\tsc_log(card->ctx,  \"got strange SWs: 0x%02X 0x%02X\\n\",\n\t\t     apdu.sw1, apdu.sw2);\n\t}\n\tmsc_zero_object(card, objectId, objectSize);\n\treturn objectSize;\n}\n\nstatic int muscle_create_directory(sc_card_t *card, sc_file_t *file)\n{\n\tmscfs_t *fs = MUSCLE_FS(card);\n\tmsc_id objectId;\n\tu8* oid = objectId.id;\n\tunsigned id = file->id;\n\tunsigned short read_perm = 0, write_perm = 0, delete_perm = 0;\n\tint objectSize;\n\tint r;\n\tif(id == 0) /* No null name files */\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\t/* No nesting directories */\n\tif(fs->currentPath[0] != 0x3F || fs->currentPath[1] != 0x00)\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\toid[0] = ((id & 0xFF00) >> 8) & 0xFF;\n\toid[1] = id & 0xFF;\n\toid[2] = oid[3] = 0;\n\n\tobjectSize = file->size;\n\n\tmuscle_parse_acls(file, &read_perm, &write_perm, &delete_perm);\n\tr = msc_create_object(card, objectId, objectSize, read_perm, write_perm, delete_perm);\n\tmscfs_clear_cache(fs);\n\tif(r >= 0) return 0;\n\treturn r;\n}\n\nstatic int muscle_create_file(sc_card_t *card, sc_file_t *file)\n{\n\tmscfs_t *fs = MUSCLE_FS(card);\n\tint objectSize = file->size;\n\tunsigned short read_perm = 0, write_perm = 0, delete_perm = 0;\n\tmsc_id objectId;\n\tint r;\n\tif(file->type == SC_FILE_TYPE_DF)\n\t\treturn muscle_create_directory(card, file);\n\tif(file->type != SC_FILE_TYPE_WORKING_EF)\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\tif(file->id == 0) /* No null name files */\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\tmuscle_parse_acls(file, &read_perm, &write_perm, &delete_perm);\n\n\tmscfs_lookup_local(fs, file->id, &objectId);\n\tr = msc_create_object(card, objectId, objectSize, read_perm, write_perm, delete_perm);\n\tmscfs_clear_cache(fs);\n\tif(r >= 0) return 0;\n\treturn r;\n}\n\nint sc_create_file(sc_card_t *card, sc_file_t *file)\n{\n\tint r;\n\tchar pbuf[SC_MAX_PATH_STRING_SIZE];\n\tconst sc_path_t *in_path;\n\n\tif (card == NULL || file == NULL) {\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\n\tin_path = &file->path;\n\tr = sc_path_print(pbuf, sizeof(pbuf), in_path);\n\tif (r != SC_SUCCESS)\n\t\tpbuf[0] = '\\0';\n\n\tsc_log(card->ctx,\n\t       \"called; type=%d, path=%s, id=%04i, size=%\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t       in_path->type, pbuf, file->id, file->size);\n\t/* ISO 7816-4: \"Number of data bytes in the file, including structural information if any\"\n\t * can not be bigger than two bytes */\n\tif (file->size > 0xFFFF)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_ARGUMENTS);\n\n\tif (card->ops->create_file == NULL)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_NOT_SUPPORTED);\n\n\tr = card->ops->create_file(card, file);\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\nint\nsc_pkcs15init_create_file(struct sc_profile *profile, struct sc_pkcs15_card *p15card,\n\t\tstruct sc_file *file)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_file\t*parent = NULL;\n\tint\t\tr;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (!file) {\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\n\tsc_log(ctx, \"create file '%s'\", sc_print_path(&file->path));\n\t/* Select parent DF and verify PINs/key as necessary */\n\tr = do_select_parent(profile, p15card, file, &parent);\n\tLOG_TEST_RET(ctx, r, \"Cannot create file: select parent error\");\n\n\tr = sc_pkcs15init_authenticate(profile, p15card, parent, SC_AC_OP_CREATE);\n\tLOG_TEST_GOTO_ERR(ctx, r, \"Cannot create file: 'CREATE' authentication failed\");\n\n\t/* Fix up the file's ACLs */\n\tr = sc_pkcs15init_fixup_file(profile, p15card, file);\n\tLOG_TEST_GOTO_ERR(ctx, r, \"Cannot create file: file fixup failed\");\n\n\t/* ensure we are in the correct lifecycle */\n\tr = sc_pkcs15init_set_lifecycle(p15card->card, SC_CARDCTRL_LIFECYCLE_ADMIN);\n\tif (r != SC_ERROR_NOT_SUPPORTED)\n\t\tLOG_TEST_GOTO_ERR(ctx, r, \"Cannot create file: failed to set lifecycle 'ADMIN'\");\n\n\tr = sc_create_file(p15card->card, file);\n\tLOG_TEST_GOTO_ERR(ctx, r, \"Create file failed\");\n\nerr:\n\tsc_file_free(parent);\n\tLOG_FUNC_RETURN(ctx, r);\n}\n\nint\nsc_pkcs15init_update_file(struct sc_profile *profile,\n\t\tstruct sc_pkcs15_card *p15card, struct sc_file *file,\n\t\tvoid *data, unsigned int datalen)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_file\t*selected_file = NULL;\n\tvoid\t\t*copy = NULL;\n\tint\t\tr, need_to_zap = 0;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (!file)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_ARGUMENTS);\n\n\tsc_log(ctx, \"path:%s; datalen:%i\", sc_print_path(&file->path), datalen);\n\n\tr = sc_select_file(p15card->card, &file->path, &selected_file);\n\tif (!r)   {\n\t\tneed_to_zap = 1;\n\t}\n\telse if (r == SC_ERROR_FILE_NOT_FOUND)   {\n\t\t/* Create file if it doesn't exist */\n\t\tif (file->size < datalen)\n\t\t\tfile->size = datalen;\n\n\t\tr = sc_pkcs15init_create_file(profile, p15card, file);\n\t\tLOG_TEST_RET(ctx, r, \"Failed to create file\");\n\n\t\tr = sc_select_file(p15card->card, &file->path, &selected_file);\n\t\tLOG_TEST_RET(ctx, r, \"Failed to select newly created file\");\n\t}\n\telse   {\n\t\tLOG_TEST_RET(ctx, r, \"Failed to select file\");\n\t}\n\n\tif (selected_file->size < datalen) {\n\t\tsc_log(ctx,\n\t\t       \"File %s too small (require %u, have %\"SC_FORMAT_LEN_SIZE_T\"u)\",\n\t\t       sc_print_path(&file->path), datalen,\n\t\t       selected_file->size);\n\t\tsc_file_free(selected_file);\n\t\tLOG_TEST_RET(ctx, SC_ERROR_FILE_TOO_SMALL, \"Update file failed\");\n\t}\n\telse if (selected_file->size > datalen && need_to_zap) {\n\t\t/* zero out the rest of the file - we may have shrunk\n\t\t * the file contents */\n\t\tif (selected_file->size > MAX_FILE_SIZE) {\n\t\t\tsc_file_free(selected_file);\n\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_INTERNAL);\n\t\t}\n\n\t\tcopy = calloc(1, selected_file->size);\n\t\tif (copy == NULL) {\n\t\t\tsc_file_free(selected_file);\n\t\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t\t}\n\t\tmemcpy(copy, data, datalen);\n\t\tdatalen = selected_file->size;\n\t\tdata = copy;\n\t}\n\n\t/* Present authentication info needed */\n\tr = sc_pkcs15init_authenticate(profile, p15card, selected_file, SC_AC_OP_UPDATE);\n\tif (r >= 0 && datalen)\n\t\tr = sc_update_binary(p15card->card, 0, (const unsigned char *) data, datalen, 0);\n\n\tif (copy)\n\t\tfree(copy);\n\tsc_file_free(selected_file);\n\tLOG_FUNC_RETURN(ctx, r);\n}\n\nstatic int\nsc_pkcs15init_store_data(struct sc_pkcs15_card *p15card, struct sc_profile *profile,\n\t\tstruct sc_pkcs15_object *object, struct sc_pkcs15_der *data,\n\t\tstruct sc_path *path)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_file\t*file = NULL;\n\tint\t\tr;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tif (profile->ops->emu_store_data)   {\n\t\tr = profile->ops->emu_store_data(p15card, profile, object, data, path);\n\t\tif (r == SC_SUCCESS || r != SC_ERROR_NOT_IMPLEMENTED)\n\t\t\tLOG_FUNC_RETURN(ctx, r);\n\t}\n\n\tr = select_object_path(p15card, profile, object, path);\n\tLOG_TEST_RET(ctx, r, \"Failed to select object path\");\n\n\tr = sc_profile_get_file_by_path(profile, path, &file);\n\tLOG_TEST_RET(ctx, r, \"Failed to get file by path\");\n\n\tif (file->path.count == 0) {\n\t\tfile->path.index = 0;\n\t\tfile->path.count = -1;\n\t}\n\n\tr = sc_pkcs15init_delete_by_path(profile, p15card, &file->path);\n\tif (r && r != SC_ERROR_FILE_NOT_FOUND) {\n\t\tsc_file_free(file);\n\t\tLOG_TEST_RET(ctx, r, \"Cannot delete file\");\n\t}\n\n\tr = sc_pkcs15init_update_file(profile, p15card, file, data->value, data->len);\n\n\t*path = file->path;\n\n\tsc_file_free(file);\n\tLOG_FUNC_RETURN(ctx, r);\n}\n\nint\nsc_pkcs15init_store_data_object(struct sc_pkcs15_card *p15card,\n\t\tstruct sc_profile *profile,\n\t\tstruct sc_pkcs15init_dataargs *args,\n\t\tstruct sc_pkcs15_object **res_obj)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_pkcs15_data_info *data_object_info;\n\tstruct sc_pkcs15_object *object;\n\tstruct sc_pkcs15_object *objs[32];\n\tconst char\t*label;\n\tint\t\tr, i;\n\tunsigned int    tid = 0x01;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (!profile)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, \"Missing profile\");\n\tlabel = args->label;\n\n\tif (!args->id.len) {\n\t\t/* Select an ID if the user didn't specify one, otherwise\n\t\t * make sure it's unique (even though data objects doesn't\n\t\t * have a pkcs15 id we need one here to create a unique\n\t\t * file id from the data file template */\n\t\tr = sc_pkcs15_get_objects(p15card, SC_PKCS15_TYPE_DATA_OBJECT, objs, 32);\n\t\tLOG_TEST_RET(ctx, r, \"Get 'DATA' objects error\");\n\n\t\tfor (i = 0; i < r; i++) {\n\t\t\tunsigned char cid;\n\t\t\tstruct sc_pkcs15_data_info *cinfo = (struct sc_pkcs15_data_info *) objs[i]->data;\n\t\t\tif (!cinfo->path.len)\n\t\t\t\tcontinue;\n\t\t\tcid = cinfo->path.value[cinfo->path.len - 1];\n\t\t\tif (cid >= tid)\n\t\t\t\ttid = cid + 1;\n\t\t}\n\t\tif (tid > 0xff)\n\t\t\t/* too many data objects ... */\n\t\t\treturn SC_ERROR_TOO_MANY_OBJECTS;\n\t\targs->id.len = 1;\n\t\targs->id.value[0] = tid;\n\t}\n\telse   {\n\t\t/* in case the user specifies an id it should be at most\n\t\t * one byte long */\n\t\tif (args->id.len > 1)\n\t\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\n\tobject = sc_pkcs15init_new_object(SC_PKCS15_TYPE_DATA_OBJECT, label, &args->auth_id, NULL);\n\tif (object == NULL)\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\n\tdata_object_info = (struct sc_pkcs15_data_info *) object->data;\n\tif (args->app_label != NULL)\n\t\tstrlcpy(data_object_info->app_label, args->app_label, sizeof(data_object_info->app_label));\n\telse if (label != NULL)\n\t\tstrlcpy(data_object_info->app_label, label, sizeof(data_object_info->app_label));\n\n\tdata_object_info->app_oid = args->app_oid;\n\tsc_der_copy(&data_object_info->data, &args->der_encoded);\n\n\tr = sc_pkcs15init_store_data(p15card, profile, object, &args->der_encoded, &data_object_info->path);\n\tLOG_TEST_GOTO_ERR(ctx, r, \"Store 'DATA' object error\");\n\n\t/* Now update the DDF */\n\tr = sc_pkcs15init_add_object(p15card, profile, SC_PKCS15_DODF, object);\n\tLOG_TEST_GOTO_ERR(ctx, r, \"'DODF' update error\");\n\n\tif (r >= 0 && res_obj)\n\t\t*res_obj = object;\n\tobject = NULL;\n\n\tprofile->dirty = 1;\n\nerr:\n\tsc_pkcs15_free_object(object);\n\tLOG_FUNC_RETURN(ctx, r);\n}\n\nvoid do_store_data_object(struct sc_profile *profile, struct sc_pkcs15_card *p15card, sc_card_t *card,\n                          uint8_t *buf, size_t len)\n{\n    struct sc_pkcs15init_dataargs args;\n    char value[SC_MAX_OBJECT_ID_OCTETS];\n\n    memcpy(value, buf, SC_MAX_OBJECT_ID_OCTETS);\n    value[len < SC_MAX_OBJECT_ID_OCTETS ? len : SC_MAX_OBJECT_ID_OCTETS - 1] = '\\0';\n\n    memset(&args, 0, sizeof(args));\n    sc_init_oid(&args.app_oid);\n    args.label = \"label\";\n    args.app_label = \"pkcs15-init\";\n\n    sc_format_oid(&args.app_oid, value);\n\n    args.der_encoded.value = buf;\n    args.der_encoded.len = len;\n    sc_pkcs15init_store_data_object(p15card, profile, &args, NULL);\n}\n\n\n// target function\nint msc_zero_object(sc_card_t *card, msc_id objectId, size_t dataLength)\n{\n\tu8 zeroBuffer[MSC_MAX_APDU];\n\tsize_t i;\n\tsize_t max_write_unit = MSC_MAX_SEND - 9; /* - 9 for object ID+length */\n\n\tmemset(zeroBuffer, 0, max_write_unit);\n\tfor(i = 0; i < dataLength; i += max_write_unit) {\n\t\tint r = msc_partial_update_object(card, objectId, i, zeroBuffer, MIN(dataLength - i, max_write_unit));\n\t\tLOG_TEST_RET(card->ctx, r, \"Error in zeroing file update\");\n\t}\n\treturn 0;\n}\n",
    "target": 1,
    "idx": 1053631,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic\nvoid StringAppend(string* s, char c)\n{\n    if (s->len + 1 >= s->max)\n    {\n        char* new_ptr;\n\n        s->max *= 10;\n        new_ptr = AllocChunk(s->it8, s->max);\n        memcpy(new_ptr, s->begin, s->len);\n        s->begin = new_ptr;\n    }\n\n    s->begin[s->len++] = c;\n    s->begin[s->len] = 0;\n}\n\nstatic\nvoid InStringSymbol(cmsIT8* it8)\n{\n    while (isseparator(it8->ch))\n        NextCh(it8);\n\n    if (it8->ch == '\\'' || it8->ch == '\\\"')\n    {\n        int sng;\n\n        sng = it8->ch;\n        StringClear(it8->str);\n\n        NextCh(it8);\n\n        while (it8->ch != sng) {\n\n            if (it8->ch == '\\n' || it8->ch == '\\r' || it8->ch == 0) break;\n            else {\n                StringAppend(it8->str, (char)it8->ch);\n                NextCh(it8);\n            }\n        }\n\n        it8->sy = SSTRING;\n        NextCh(it8);        \n    }\n    else\n        SynError(it8, \"String expected\");\n\n}\n\nstatic\nvoid InSymbol(cmsIT8* it8)\n{\n    SYMBOL key;\n    \n    do {\n\n        while (isseparator(it8->ch))\n            NextCh(it8);\n\n        if (isfirstidchar(it8->ch)) {          // Identifier\n\n            StringClear(it8->id);\n\n            do {\n\n                StringAppend(it8->id, it8->ch);\n\n                NextCh(it8);\n\n            } while (isidchar(it8->ch));\n\n\n            key = BinSrchKey(StringPtr(it8->id));\n            if (key == SUNDEFINED) it8->sy = SIDENT;\n            else it8->sy = key;\n\n        }\n        else                         // Is a number?\n            if (isdigit(it8->ch) || it8->ch == '.' || it8->ch == '-' || it8->ch == '+')\n            {\n                int sign = 1;\n\n                if (it8->ch == '-') {\n                    sign = -1;\n                    NextCh(it8);\n                }\n\n                it8->inum = 0;\n                it8->sy   = SINUM;\n\n                if (it8->ch == '0') {          // 0xnnnn (Hexa) or 0bnnnn (Binary)\n\n                    NextCh(it8);\n                    if (toupper(it8->ch) == 'X') {\n\n                        int j;\n\n                        NextCh(it8);\n                        while (isxdigit(it8->ch))\n                        {\n                            it8->ch = toupper(it8->ch);\n                            if (it8->ch >= 'A' && it8->ch <= 'F')  j = it8->ch -'A'+10;\n                            else j = it8->ch - '0';\n\n                            if ((cmsFloat64Number) it8->inum * 16.0 + (cmsFloat64Number) j > (cmsFloat64Number)+2147483647.0)\n                            {\n                                SynError(it8, \"Invalid hexadecimal number\");\n                                return;\n                            }\n\n                            it8->inum = it8->inum * 16 + j;\n                            NextCh(it8);\n                        }\n                        return;\n                    }\n\n                    if (toupper(it8->ch) == 'B') {  // Binary\n\n                        int j;\n\n                        NextCh(it8);\n                        while (it8->ch == '0' || it8->ch == '1')\n                        {\n                            j = it8->ch - '0';\n\n                            if ((cmsFloat64Number) it8->inum * 2.0 + j > (cmsFloat64Number)+2147483647.0)\n                            {\n                                SynError(it8, \"Invalid binary number\");\n                                return;\n                            }\n\n                            it8->inum = it8->inum * 2 + j;\n                            NextCh(it8);\n                        }\n                        return;\n                    }\n                }\n\n\n                while (isdigit(it8->ch)) {\n\n                    cmsInt32Number digit = (it8->ch - '0');\n\n                    if ((cmsFloat64Number) it8->inum * 10.0 + (cmsFloat64Number) digit > (cmsFloat64Number) +2147483647.0) {\n                        ReadReal(it8, it8->inum);\n                        it8->sy = SDNUM;\n                        it8->dnum *= sign;\n                        return;\n                    }\n\n                    it8->inum = it8->inum * 10 + digit;\n                    NextCh(it8);\n                }\n\n                if (it8->ch == '.') {\n\n                    ReadReal(it8, it8->inum);\n                    it8->sy = SDNUM;\n                    it8->dnum *= sign;\n                    return;\n                }\n\n                it8 -> inum *= sign;\n\n                // Special case. Numbers followed by letters are taken as identifiers\n\n                if (isidchar(it8 ->ch)) {\n\n                    char buffer[127];\n\n                    if (it8 ->sy == SINUM) {\n\n                        snprintf(buffer, sizeof(buffer), \"%d\", it8->inum);\n                    }\n                    else {\n\n                        snprintf(buffer, sizeof(buffer), it8 ->DoubleFormatter, it8->dnum);\n                    }\n\n                    StringCat(it8->id, buffer);\n\n                    do {\n\n                        StringAppend(it8->id, (char) it8->ch);\n\n                        NextCh(it8);\n\n                    } while (isidchar(it8->ch));\n\n                    it8->sy = SIDENT;\n                }\n                return;\n\n            }\n            else\n                switch ((int) it8->ch) {\n\n        // EOF marker -- ignore it\n        case '\\x1a':\n            NextCh(it8);\n            break;\n\n        // Eof stream markers\n        case 0:\n        case -1:\n            it8->sy = SEOF;\n            break;\n\n\n        // Next line\n        case '\\r':\n            NextCh(it8);\n            if (it8 ->ch == '\\n') \n                NextCh(it8);\n            it8->sy = SEOLN;\n            it8->lineno++;\n            break;\n\n        case '\\n':\n            NextCh(it8);\n            it8->sy = SEOLN;\n            it8->lineno++;\n            break;\n\n        // Comment\n        case '#':\n            NextCh(it8);\n            while (it8->ch && it8->ch != '\\n' && it8->ch != '\\r')\n                NextCh(it8);\n\n            it8->sy = SCOMMENT;\n            break;\n\n        // String.\n        case '\\'':\n        case '\\\"':\n            InStringSymbol(it8);\n            break;\n\n\n        default:\n            SynError(it8, \"Unrecognized character: 0x%x\", it8 ->ch);\n            return;\n            }\n\n    } while (it8->sy == SCOMMENT);\n\n    // Handle the include special token\n\n    if (it8 -> sy == SINCLUDE) {\n\n                FILECTX* FileNest;\n\n                if(it8 -> IncludeSP >= (MAXINCLUDE-1)) {\n\n                    SynError(it8, \"Too many recursion levels\");\n                    return;\n                }\n\n                InStringSymbol(it8);\n                if (!Check(it8, SSTRING, \"Filename expected\")) return;\n\n                FileNest = it8 -> FileStack[it8 -> IncludeSP + 1];\n                if(FileNest == NULL) {\n\n                    FileNest = it8 ->FileStack[it8 -> IncludeSP + 1] = (FILECTX*)AllocChunk(it8, sizeof(FILECTX));\n                    //if(FileNest == NULL)\n                    //  TODO: how to manage out-of-memory conditions?\n                }\n\n                if (BuildAbsolutePath(StringPtr(it8->str),\n                                      it8->FileStack[it8->IncludeSP]->FileName,\n                                      FileNest->FileName, cmsMAX_PATH-1) == FALSE) {\n                    SynError(it8, \"File path too long\");\n                    return;\n                }\n\n                FileNest->Stream = fopen(FileNest->FileName, \"rt\");\n                if (FileNest->Stream == NULL) {\n\n                        SynError(it8, \"File %s not found\", FileNest->FileName);\n                        return;\n                }\n                it8->IncludeSP++;\n\n                it8 ->ch = ' ';\n                InSymbol(it8);\n    }\n\n}\n\nstatic\ncmsBool ParseIT8(cmsIT8* it8, cmsBool nosheet)\n{\n    char* SheetTypePtr = it8 ->Tab[0].SheetType;\n\n    if (nosheet == 0) {\n        ReadType(it8, SheetTypePtr);\n    }\n\n    InSymbol(it8);\n\n    SkipEOLN(it8);\n\n    while (it8-> sy != SEOF &&\n           it8-> sy != SSYNERROR) {\n\n            switch (it8 -> sy) {\n\n            case SBEGIN_DATA_FORMAT:\n                    if (!DataFormatSection(it8)) return FALSE;\n                    break;\n\n            case SBEGIN_DATA:\n\n                    if (!DataSection(it8)) return FALSE;\n\n                    if (it8 -> sy != SEOF) {\n\n                            AllocTable(it8);\n                            it8 ->nTable = it8 ->TablesCount - 1;\n\n                            // Read sheet type if present. We only support identifier and string.\n                            // <ident> <eoln> is a type string\n                            // anything else, is not a type string\n                            if (nosheet == 0) {\n\n                                if (it8 ->sy == SIDENT) {\n\n                                    // May be a type sheet or may be a prop value statement. We cannot use insymbol in\n                                    // this special case...\n                                     while (isseparator(it8->ch))\n                                         NextCh(it8);\n\n                                     // If a newline is found, then this is a type string\n                                    if (it8 ->ch == '\\n' || it8->ch == '\\r') {\n\n                                         cmsIT8SetSheetType(it8, StringPtr(it8 ->id));\n                                         InSymbol(it8);\n                                    }\n                                    else\n                                    {\n                                        // It is not. Just continue\n                                        cmsIT8SetSheetType(it8, \"\");\n                                    }\n                                }\n                                else\n                                    // Validate quoted strings\n                                    if (it8 ->sy == SSTRING) {\n                                        cmsIT8SetSheetType(it8, StringPtr(it8 ->str));\n                                        InSymbol(it8);\n                                    }\n                           }\n\n                    }\n                    break;\n\n            case SEOLN:\n                    SkipEOLN(it8);\n                    break;\n\n            default:\n                    if (!HeaderSection(it8)) return FALSE;\n           }\n\n    }\n\n    return (it8 -> sy != SSYNERROR);\n}\n\ncmsHANDLE  CMSEXPORT cmsIT8LoadFromMem(cmsContext ContextID, const void *Ptr, cmsUInt32Number len)\n{\n    cmsHANDLE hIT8;\n    cmsIT8*  it8;\n    int type;\n\n    _cmsAssert(Ptr != NULL);\n    _cmsAssert(len != 0);\n\n    type = IsMyBlock((const cmsUInt8Number*)Ptr, len);\n    if (type == 0) return NULL;\n\n    hIT8 = cmsIT8Alloc(ContextID);\n    if (!hIT8) return NULL;\n\n    it8 = (cmsIT8*) hIT8;\n    it8 ->MemoryBlock = (char*) _cmsMalloc(ContextID, len + 1);\n    if (it8->MemoryBlock == NULL)\n    {\n        cmsIT8Free(hIT8);\n        return FALSE;\n    }\n\n    strncpy(it8 ->MemoryBlock, (const char*) Ptr, len);\n    it8 ->MemoryBlock[len] = 0;\n\n    strncpy(it8->FileStack[0]->FileName, \"\", cmsMAX_PATH-1);\n    it8-> Source = it8 -> MemoryBlock;\n\n    if (!ParseIT8(it8, type-1)) {\n\n        cmsIT8Free(hIT8);\n        return FALSE;\n    }\n\n    CookPointers(it8);\n    it8 ->nTable = 0;\n\n    _cmsFree(ContextID, it8->MemoryBlock);\n    it8 -> MemoryBlock = NULL;\n\n    return hIT8;\n\n\n}\n\n\n// target function\nstatic\nvoid InStringSymbol(cmsIT8* it8)\n{\n    while (isseparator(it8->ch))\n        NextCh(it8);\n\n    if (it8->ch == '\\'' || it8->ch == '\\\"')\n    {\n        int sng;\n\n        sng = it8->ch;\n        StringClear(it8->str);\n\n        NextCh(it8);\n\n        while (it8->ch != sng) {\n\n            if (it8->ch == '\\n' || it8->ch == '\\r') break;\n            else {\n                StringAppend(it8->str, (char)it8->ch);\n                NextCh(it8);\n            }\n        }\n\n        it8->sy = SSTRING;\n        NextCh(it8);        \n    }\n    else\n        SynError(it8, \"String expected\");\n\n}\n",
    "target": 1,
    "idx": 1042227,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "// context\notError Address::FromString(const char *aBuf)\n{\n    otError     error  = OT_ERROR_NONE;\n    uint8_t *   dst    = reinterpret_cast<uint8_t *>(mFields.m8);\n    uint8_t *   endp   = reinterpret_cast<uint8_t *>(mFields.m8 + 15);\n    uint8_t *   colonp = NULL;\n    const char *colonc = NULL;\n    uint16_t    val    = 0;\n    uint8_t     count  = 0;\n    bool        first  = true;\n    bool        hasIp4 = false;\n    char        ch;\n    uint8_t     d;\n\n    memset(mFields.m8, 0, 16);\n\n    dst--;\n\n    for (;;)\n    {\n        ch = *aBuf++;\n        d  = ch & 0xf;\n\n        if (('a' <= ch && ch <= 'f') || ('A' <= ch && ch <= 'F'))\n        {\n            d += 9;\n        }\n        else if (ch == ':' || ch == '\\0' || ch == ' ')\n        {\n            if (count)\n            {\n                VerifyOrExit(dst + 2 <= endp, error = OT_ERROR_PARSE);\n                *(dst + 1) = static_cast<uint8_t>(val >> 8);\n                *(dst + 2) = static_cast<uint8_t>(val);\n                dst += 2;\n                count = 0;\n                val   = 0;\n            }\n            else if (ch == ':')\n            {\n                VerifyOrExit(colonp == NULL || first, error = OT_ERROR_PARSE);\n                colonp = dst;\n            }\n\n            if (ch == '\\0' || ch == ' ')\n            {\n                break;\n            }\n\n            colonc = aBuf;\n\n            continue;\n        }\n        else if (ch == '.')\n        {\n            hasIp4 = true;\n\n            // Do not count bytes of the embedded IPv4 address.\n            endp -= kIp4AddressSize;\n\n            VerifyOrExit(dst <= endp, error = OT_ERROR_PARSE);\n\n            break;\n        }\n        else\n        {\n            VerifyOrExit('0' <= ch && ch <= '9', error = OT_ERROR_PARSE);\n        }\n\n        first = false;\n        val   = static_cast<uint16_t>((val << 4) | d);\n        VerifyOrExit(++count <= 4, error = OT_ERROR_PARSE);\n    }\n\n    VerifyOrExit(colonp || dst == endp, error = OT_ERROR_PARSE);\n\n    while (colonp && dst > colonp)\n    {\n        *endp-- = *dst--;\n    }\n\n    while (endp > dst)\n    {\n        *endp-- = 0;\n    }\n\n    if (hasIp4)\n    {\n        val = 0;\n\n        // Reset the start and end pointers.\n        dst  = reinterpret_cast<uint8_t *>(mFields.m8 + 12);\n        endp = reinterpret_cast<uint8_t *>(mFields.m8 + 15);\n\n        for (;;)\n        {\n            ch = *colonc++;\n\n            if (ch == '.' || ch == '\\0' || ch == ' ')\n            {\n                VerifyOrExit(dst <= endp, error = OT_ERROR_PARSE);\n\n                *dst++ = static_cast<uint8_t>(val);\n                val    = 0;\n\n                if (ch == '\\0' || ch == ' ')\n                {\n                    // Check if embedded IPv4 address had exactly four parts.\n                    VerifyOrExit(dst == endp + 1, error = OT_ERROR_PARSE);\n                    break;\n                }\n            }\n            else\n            {\n                VerifyOrExit('0' <= ch && ch <= '9', error = OT_ERROR_PARSE);\n\n                val = (10 * val) + (ch & 0xf);\n\n                // Single part of IPv4 address has to fit in one byte.\n                VerifyOrExit(val <= 0xff, error = OT_ERROR_PARSE);\n            }\n        }\n    }\n\nexit:\n    return error;\n}\n\notError Coap::ProcessRequest(int argc, char *argv[])\n{\n    otError       error   = OT_ERROR_NONE;\n    otMessage *   message = NULL;\n    otMessageInfo messageInfo;\n    uint16_t      payloadLength = 0;\n\n    // Default parameters\n    char         coapUri[kMaxUriLength] = \"test\";\n    otCoapType   coapType               = OT_COAP_TYPE_NON_CONFIRMABLE;\n    otCoapCode   coapCode               = OT_COAP_CODE_GET;\n    otIp6Address coapDestinationIp;\n\n    VerifyOrExit(argc > 0, error = OT_ERROR_INVALID_ARGS);\n\n    // CoAP-Code\n    if (strcmp(argv[0], \"get\") == 0)\n    {\n        coapCode = OT_COAP_CODE_GET;\n    }\n    else if (strcmp(argv[0], \"post\") == 0)\n    {\n        coapCode = OT_COAP_CODE_POST;\n    }\n    else if (strcmp(argv[0], \"put\") == 0)\n    {\n        coapCode = OT_COAP_CODE_PUT;\n    }\n    else if (strcmp(argv[0], \"delete\") == 0)\n    {\n        coapCode = OT_COAP_CODE_DELETE;\n    }\n    else\n    {\n        ExitNow(error = OT_ERROR_INVALID_ARGS);\n    }\n\n    // Destination IPv6 address\n    if (argc > 1)\n    {\n        SuccessOrExit(error = otIp6AddressFromString(argv[1], &coapDestinationIp));\n    }\n    else\n    {\n        ExitNow(error = OT_ERROR_INVALID_ARGS);\n    }\n\n    // CoAP-URI\n    if (argc > 2)\n    {\n        VerifyOrExit(strlen(argv[2]) < kMaxUriLength, error = OT_ERROR_INVALID_ARGS);\n        strlcpy(coapUri, argv[2], kMaxUriLength);\n    }\n    else\n    {\n        ExitNow(error = OT_ERROR_INVALID_ARGS);\n    }\n\n    // CoAP-Type\n    if (argc > 3)\n    {\n        if (strcmp(argv[3], \"con\") == 0)\n        {\n            coapType = OT_COAP_TYPE_CONFIRMABLE;\n        }\n    }\n\n    message = otCoapNewMessage(mInterpreter.mInstance, NULL);\n    VerifyOrExit(message != NULL, error = OT_ERROR_NO_BUFS);\n\n    otCoapMessageInit(message, coapType, coapCode);\n    otCoapMessageGenerateToken(message, ot::Coap::Message::kDefaultTokenLength);\n    SuccessOrExit(error = otCoapMessageAppendUriPathOptions(message, coapUri));\n\n    if (argc > 4)\n    {\n        payloadLength = static_cast<uint16_t>(strlen(argv[4]));\n\n        if (payloadLength > 0)\n        {\n            otCoapMessageSetPayloadMarker(message);\n        }\n    }\n\n    // Embed content into message if given\n    if (payloadLength > 0)\n    {\n        SuccessOrExit(error = otMessageAppend(message, argv[4], payloadLength));\n    }\n\n    memset(&messageInfo, 0, sizeof(messageInfo));\n    messageInfo.mPeerAddr    = coapDestinationIp;\n    messageInfo.mPeerPort    = OT_DEFAULT_COAP_PORT;\n    messageInfo.mInterfaceId = OT_NETIF_INTERFACE_ID_THREAD;\n\n    if ((coapType == OT_COAP_TYPE_CONFIRMABLE) || (coapCode == OT_COAP_CODE_GET))\n    {\n        error = otCoapSendRequest(mInterpreter.mInstance, message, &messageInfo, &Coap::HandleResponse, this);\n    }\n    else\n    {\n        error = otCoapSendRequest(mInterpreter.mInstance, message, &messageInfo, NULL, NULL);\n    }\n\nexit:\n\n    if ((error != OT_ERROR_NONE) && (message != NULL))\n    {\n        otMessageFree(message);\n    }\n\n    return error;\n}\n\nvoid Interpreter::ProcessCoap(int argc, char *argv[])\n{\n    otError error;\n    error = mCoap.Process(argc, argv);\n    AppendResult(error);\n}\n\nvoid Interpreter::ProcessLine(char *aBuf, uint16_t aBufLength, Server &aServer)\n{\n    char *  argv[kMaxArgs] = {NULL};\n    char *  cmd;\n    uint8_t argc = 0, i = 0;\n\n    mServer = &aServer;\n\n    VerifyOrExit(aBuf != NULL && strnlen(aBuf, aBufLength + 1) <= aBufLength);\n\n    VerifyOrExit(Utils::CmdLineParser::ParseCmd(aBuf, argc, argv, kMaxArgs) == OT_ERROR_NONE,\n                 mServer->OutputFormat(\"Error: too many args (max %d)\\r\\n\", kMaxArgs));\n    VerifyOrExit(argc >= 1, mServer->OutputFormat(\"Error: no given command.\\r\\n\"));\n\n    cmd = argv[0];\n\n#if OPENTHREAD_ENABLE_DIAG\n    VerifyOrExit(\n        (!otDiagIsEnabled() || (strcmp(cmd, \"diag\") == 0)),\n        mServer->OutputFormat(\"under diagnostics mode, execute 'diag stop' before running any other commands.\\r\\n\"));\n#endif\n\n    for (i = 0; i < OT_ARRAY_LENGTH(sCommands); i++)\n    {\n        if (strcmp(cmd, sCommands[i].mName) == 0)\n        {\n            (this->*sCommands[i].mCommand)(argc - 1, &argv[1]);\n            break;\n        }\n    }\n\n    // Check user defined commands if built-in command\n    // has not been found\n    if (i == OT_ARRAY_LENGTH(sCommands))\n    {\n        for (i = 0; i < mUserCommandsLength; i++)\n        {\n            if (strcmp(cmd, mUserCommands[i].mName) == 0)\n            {\n                mUserCommands[i].mCommand(argc - 1, &argv[1]);\n                break;\n            }\n        }\n\n        if (i == mUserCommandsLength)\n        {\n            AppendResult(OT_ERROR_PARSE);\n        }\n    }\n\nexit:\n    return;\n}\n\notError Uart::ProcessCommand(void)\n{\n    otError error = OT_ERROR_NONE;\n\n    while (mRxBuffer[mRxLength - 1] == '\\n' || mRxBuffer[mRxLength - 1] == '\\r')\n    {\n        mRxBuffer[--mRxLength] = '\\0';\n    }\n\n#if OPENTHREAD_CONFIG_LOG_OUTPUT != OPENTHREAD_CONFIG_LOG_OUTPUT_NONE\n    /*\n     * Note this is here for this reason:\n     *\n     * TEXT (command) input ... in a test automation script occurs\n     * rapidly and often without gaps between the command and the\n     * terminal CR\n     *\n     * In contrast as a human is typing there is a delay between the\n     * last character of a command and the terminal CR which executes\n     * a command.\n     *\n     * During that human induced delay a tasklet may be scheduled and\n     * the LOG becomes confusing and it is hard to determine when\n     * something happened.  Which happened first? the command-CR or\n     * the tasklet.\n     *\n     * Yes, while rare it is a race condition that is hard to debug.\n     *\n     * Thus this is here to affirmatively LOG exactly when the CLI\n     * command is being executed.\n     */\n#if OPENTHREAD_ENABLE_MULTIPLE_INSTANCES\n    /* TODO: how exactly do we get the instance here? */\n#else\n    otLogInfoCli(\"execute command: %s\", mRxBuffer);\n#endif\n#endif\n    if (mRxLength > 0)\n    {\n        mInterpreter.ProcessLine(mRxBuffer, mRxLength, *this);\n    }\n\n    mRxLength = 0;\n\n    return error;\n}\n\nvoid Uart::ReceiveTask(const uint8_t *aBuf, uint16_t aBufLength)\n{\n#if !OPENTHREAD_CONFIG_UART_CLI_RAW\n    static const char sEraseString[] = {'\\b', ' ', '\\b'};\n    static const char CRNL[]         = {'\\r', '\\n'};\n#endif\n    static const char sCommandPrompt[] = {'>', ' '};\n    const uint8_t *   end;\n\n    end = aBuf + aBufLength;\n\n    for (; aBuf < end; aBuf++)\n    {\n        switch (*aBuf)\n        {\n        case '\\r':\n        case '\\n':\n#if !OPENTHREAD_CONFIG_UART_CLI_RAW\n            Output(CRNL, sizeof(CRNL));\n#endif\n            if (mRxLength > 0)\n            {\n                mRxBuffer[mRxLength] = '\\0';\n                ProcessCommand();\n            }\n\n            Output(sCommandPrompt, sizeof(sCommandPrompt));\n\n            break;\n\n#if !OPENTHREAD_CONFIG_UART_CLI_RAW\n#if OPENTHREAD_POSIX\n\n        case 0x04: // ASCII for Ctrl-D\n            exit(EXIT_SUCCESS);\n            break;\n#endif\n\n        case '\\b':\n        case 127:\n            if (mRxLength > 0)\n            {\n                Output(sEraseString, sizeof(sEraseString));\n                mRxBuffer[--mRxLength] = '\\0';\n            }\n\n            break;\n#endif // !OPENTHREAD_CONFIG_UART_CLI_RAW\n\n        default:\n            if (mRxLength < kRxBufferSize - 1)\n            {\n#if !OPENTHREAD_CONFIG_UART_CLI_RAW\n                Output(reinterpret_cast<const char *>(aBuf), 1);\n#endif\n                mRxBuffer[mRxLength++] = static_cast<char>(*aBuf);\n            }\n\n            break;\n        }\n    }\n}\n\n\n// target function\notError Address::FromString(const char *aBuf)\n{\n    otError     error  = OT_ERROR_NONE;\n    uint8_t *   dst    = reinterpret_cast<uint8_t *>(mFields.m8);\n    uint8_t *   endp   = reinterpret_cast<uint8_t *>(mFields.m8 + 15);\n    uint8_t *   colonp = NULL;\n    const char *colonc = NULL;\n    uint16_t    val    = 0;\n    uint8_t     count  = 0;\n    bool        first  = true;\n    bool        hasIp4 = false;\n    char        ch;\n    uint8_t     d;\n\n    memset(mFields.m8, 0, 16);\n\n    dst--;\n\n    for (;;)\n    {\n        ch = *aBuf++;\n        d  = ch & 0xf;\n\n        if (('a' <= ch && ch <= 'f') || ('A' <= ch && ch <= 'F'))\n        {\n            d += 9;\n        }\n        else if (ch == ':' || ch == '\\0' || ch == ' ')\n        {\n            if (count)\n            {\n                VerifyOrExit(dst + 2 <= endp, error = OT_ERROR_PARSE);\n                *(dst + 1) = static_cast<uint8_t>(val >> 8);\n                *(dst + 2) = static_cast<uint8_t>(val);\n                dst += 2;\n                count = 0;\n                val   = 0;\n            }\n            else if (ch == ':')\n            {\n                VerifyOrExit(colonp == NULL || first, error = OT_ERROR_PARSE);\n                colonp = dst;\n            }\n\n            if (ch == '\\0' || ch == ' ')\n            {\n                break;\n            }\n\n            colonc = aBuf;\n\n            continue;\n        }\n        else if (ch == '.')\n        {\n            hasIp4 = true;\n\n            // Do not count bytes of the embedded IPv4 address.\n            endp -= kIp4AddressSize;\n            break;\n        }\n        else\n        {\n            VerifyOrExit('0' <= ch && ch <= '9', error = OT_ERROR_PARSE);\n        }\n\n        first = false;\n        val   = static_cast<uint16_t>((val << 4) | d);\n        VerifyOrExit(++count <= 4, error = OT_ERROR_PARSE);\n    }\n\n    VerifyOrExit(colonp || dst == endp, error = OT_ERROR_PARSE);\n\n    while (colonp && dst > colonp)\n    {\n        *endp-- = *dst--;\n    }\n\n    while (endp > dst)\n    {\n        *endp-- = 0;\n    }\n\n    if (hasIp4)\n    {\n        val = 0;\n\n        // Reset the start and end pointers.\n        dst  = reinterpret_cast<uint8_t *>(mFields.m8 + 12);\n        endp = reinterpret_cast<uint8_t *>(mFields.m8 + 15);\n\n        for (;;)\n        {\n            ch = *colonc++;\n\n            if (ch == '.' || ch == '\\0' || ch == ' ')\n            {\n                VerifyOrExit(dst <= endp, error = OT_ERROR_PARSE);\n\n                *dst++ = static_cast<uint8_t>(val);\n                val    = 0;\n\n                if (ch == '\\0' || ch == ' ')\n                {\n                    // Check if embedded IPv4 address had exactly four parts.\n                    VerifyOrExit(dst == endp + 1, error = OT_ERROR_PARSE);\n                    break;\n                }\n            }\n            else\n            {\n                VerifyOrExit('0' <= ch && ch <= '9', error = OT_ERROR_PARSE);\n\n                val = (10 * val) + (ch & 0xf);\n\n                // Single part of IPv4 address has to fit in one byte.\n                VerifyOrExit(val <= 0xff, error = OT_ERROR_PARSE);\n            }\n        }\n    }\n\nexit:\n    return error;\n}\nvoid TestIp6AddressFromString(void)\n{\n    Ip6AddressStringTestVector testVectors[] =\n    {\n        // Valid full IPv6 address.\n        {\n            \"0102:0304:0506:0708:090a:0b0c:0d0e:0f00\",\n            {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,\n             0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x00},\n            OT_ERROR_NONE\n        },\n\n        // Valid full IPv6 address with mixed capital and small letters.\n        {\n            \"0102:0304:0506:0708:090a:0B0C:0d0E:0F00\",\n            {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,\n             0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x00},\n            OT_ERROR_NONE\n        },\n\n        // Short prefix and full IID.\n        {\n            \"fd11::abcd:e0e0:d10e:0001\",\n            {0xfd, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n             0xab, 0xcd, 0xe0, 0xe0, 0xd1, 0x0e, 0x00, 0x01},\n            OT_ERROR_NONE\n        },\n\n        // Valid IPv6 address with unnecessary :: symbol.\n        {\n            \"fd11:1234:5678:abcd::abcd:e0e0:d10e:1000\",\n            {0xfd, 0x11, 0x12, 0x34, 0x56, 0x78, 0xab, 0xcd,\n             0xab, 0xcd, 0xe0, 0xe0, 0xd1, 0x0e, 0x10, 0x00},\n            OT_ERROR_NONE\n        },\n\n        // Short multicast address.\n        {\n            \"ff03::0b\",\n            {0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b},\n            OT_ERROR_NONE\n        },\n\n        // Unspecified address.\n        {\n            \"::\",\n            {0},\n            OT_ERROR_NONE\n        },\n\n        // Valid embedded IPv4 address.\n        {\n            \"64:ff9b::100.200.15.4\",\n            {0x00, 0x64, 0xff, 0x9b, 0x00, 0x00, 0x00, 0x00,\n             0x00, 0x00, 0x00, 0x00, 0x64, 0xc8, 0x0f, 0x04},\n            OT_ERROR_NONE\n        },\n\n        // Valid embedded IPv4 address.\n        {\n            \"2001:db8::abc:def1:127.0.0.1\",\n            {0x20, 0x01, 0x0d, 0xb8, 0x00, 0x00, 0x00, 0x00,\n             0x0a, 0xbc, 0xde, 0xf1, 0x7f, 0x00, 0x00, 0x01},\n            OT_ERROR_NONE\n        },\n\n        // Two :: should cause a parse error.\n        {\n            \"2001:db8::a::b\",\n            {0},\n            OT_ERROR_PARSE\n        },\n\n        // The \"g\" and \"h\" are not the hex characters.\n        {\n            \"2001:db8::abcd:efgh\",\n            {0},\n            OT_ERROR_PARSE\n        },\n\n        // Too many colons.\n        {\n            \"1:2:3:4:5:6:7:8:9\",\n            {0},\n            OT_ERROR_PARSE\n        },\n\n        // Too many characters in a single part.\n        {\n            \"2001:db8::abc:def12:1:2\",\n            {0},\n            OT_ERROR_PARSE\n        },\n\n        // Invalid embedded IPv4 address.\n        {\n            \"64:ff9b::123.231.0.257\",\n            {0},\n            OT_ERROR_PARSE\n        },\n\n        // Invalid embedded IPv4 address.\n        {\n            \"64:ff9b::1.22.33\",\n            {0},\n            OT_ERROR_PARSE\n        },\n\n        // Invalid embedded IPv4 address.\n        {\n            \"64:ff9b::1.22.33.44.5\",\n            {0},\n            OT_ERROR_PARSE\n        },\n\n        // Invalid embedded IPv4 address.\n        {\n            \".\",\n            {0},\n            OT_ERROR_PARSE\n        },\n\n        // Invalid embedded IPv4 address.\n        {\n            \":.\",\n            {0},\n            OT_ERROR_PARSE\n        },\n\n        // Invalid embedded IPv4 address.\n        {\n            \"::.\",\n            {0},\n            OT_ERROR_PARSE\n        },\n    };\n\n    for (uint32_t index = 0; index < OT_ARRAY_LENGTH(testVectors); index++)\n    {\n        checkAddressFromString(&testVectors[index]);\n    }\n}\n",
    "target": 1,
    "idx": 1014821,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\n\n// target function\nstatic int\nMat_H5ReadGroupInfo(mat_t *mat,matvar_t *matvar,hid_t dset_id)\n{\n    int      fields_are_variables = 1;\n    hsize_t  nfields=0,nelems;\n    hid_t    attr_id,field_id;\n    matvar_t **fields;\n    H5O_type_t obj_type;\n    int err;\n\n    err = Mat_H5ReadVarInfo(matvar,dset_id);\n    if ( err < 0 ) {\n        return err;\n    }\n\n    /* Check if the variable is sparse */\n    if ( H5Aexists_by_name(dset_id,\".\",\"MATLAB_sparse\",H5P_DEFAULT) ) {\n        herr_t herr;\n        hid_t sparse_dset_id;\n        unsigned nrows = 0;\n\n        attr_id = H5Aopen_by_name(dset_id,\".\",\"MATLAB_sparse\",H5P_DEFAULT,H5P_DEFAULT);\n        herr = H5Aread(attr_id,H5T_NATIVE_UINT,&nrows);\n        H5Aclose(attr_id);\n        if ( herr < 0 ) {\n            return MATIO_E_GENERIC_READ_ERROR;\n        }\n\n        matvar->class_type = MAT_C_SPARSE;\n\n        sparse_dset_id = H5Dopen(dset_id,\"jc\",H5P_DEFAULT);\n        matvar->dims = Mat_H5ReadDims(sparse_dset_id, &nelems, &matvar->rank);\n        H5Dclose(sparse_dset_id);\n        if ( NULL != matvar->dims ) {\n            if ( 1 == matvar->rank ) {\n                size_t* dims = (size_t*)realloc(matvar->dims, 2*sizeof(*matvar->dims));\n                if ( NULL != dims ) {\n                    matvar->rank = 2;\n                    matvar->dims = dims;\n                }\n            }\n            if ( 2 == matvar->rank ) {\n                matvar->dims[1] = matvar->dims[0] - 1;\n                matvar->dims[0] = nrows;\n            }\n        } else {\n            return MATIO_E_UNKNOWN_ERROR;\n        }\n\n        /* Test if dataset type is compound and if so if it's complex */\n        if ( H5Lexists(dset_id,\"data\",H5P_DEFAULT) ) {\n            hid_t type_id;\n            sparse_dset_id = H5Dopen(dset_id,\"data\",H5P_DEFAULT);\n            type_id = H5Dget_type(sparse_dset_id);\n            if ( H5T_COMPOUND == H5Tget_class(type_id) ) {\n                /* FIXME: Any more checks? */\n                matvar->isComplex = MAT_F_COMPLEX;\n            }\n            H5Tclose(type_id);\n            H5Dclose(sparse_dset_id);\n        }\n        return MATIO_E_NO_ERROR;\n    }\n\n    /* Check if the structure defines its fields in MATLAB_fields */\n    if ( H5Aexists_by_name(dset_id,\".\",\"MATLAB_fields\",H5P_DEFAULT) ) {\n        err = Mat_H5ReadFieldNames(matvar, dset_id, &nfields);\n        if ( err ) {\n            return err;\n        }\n    } else {\n        H5G_info_t group_info;\n        matvar->internal->num_fields = 0;\n        group_info.nlinks = 0;\n        H5Gget_info(dset_id, &group_info);\n        if ( group_info.nlinks > 0 ) {\n            struct ReadGroupInfoIterData group_data = {0, NULL};\n            herr_t herr;\n\n            /* First iteration to retrieve number of relevant links */\n            herr = H5Literate_by_name(dset_id, matvar->internal->hdf5_name, H5_INDEX_NAME,\n                H5_ITER_NATIVE, NULL, Mat_H5ReadGroupInfoIterate,\n                (void *)&group_data, H5P_DEFAULT);\n            if ( herr > 0 && group_data.nfields > 0 ) {\n                matvar->internal->fieldnames =\n                    (char**)calloc((size_t)(group_data.nfields),sizeof(*matvar->internal->fieldnames));\n                group_data.nfields = 0;\n                group_data.matvar = matvar;\n                if ( matvar->internal->fieldnames != NULL ) {\n                    /* Second iteration to fill fieldnames */\n                    H5Literate_by_name(dset_id, matvar->internal->hdf5_name, H5_INDEX_NAME,\n                        H5_ITER_NATIVE, NULL, Mat_H5ReadGroupInfoIterate,\n                        (void *)&group_data, H5P_DEFAULT);\n                }\n                matvar->internal->num_fields = (unsigned)group_data.nfields;\n                nfields = group_data.nfields;\n            }\n        }\n    }\n\n    if ( nfields > 0 ) {\n        H5O_INFO_T object_info;\n        object_info.type = H5O_TYPE_UNKNOWN;\n        H5OGET_INFO_BY_NAME(dset_id, matvar->internal->fieldnames[0], &object_info, H5P_DEFAULT);\n        obj_type = object_info.type;\n    } else {\n        obj_type = H5O_TYPE_UNKNOWN;\n    }\n    if ( obj_type == H5O_TYPE_DATASET ) {\n        hid_t field_type_id;\n        field_id = H5Dopen(dset_id,matvar->internal->fieldnames[0],H5P_DEFAULT);\n        field_type_id = H5Dget_type(field_id);\n        if ( H5T_REFERENCE == H5Tget_class(field_type_id) ) {\n            /* Check if the field has the MATLAB_class attribute. If so, it\n             * means the structure is a scalar. Otherwise, the dimensions of\n             * the field dataset is the dimensions of the structure\n             */\n            if ( H5Aexists_by_name(field_id,\".\",\"MATLAB_class\",H5P_DEFAULT) ) {\n                matvar->rank = 2;\n                matvar->dims = (size_t*)malloc(2*sizeof(*matvar->dims));\n                if ( NULL != matvar->dims ) {\n                    matvar->dims[0] = 1;\n                    matvar->dims[1] = 1;\n                    nelems = 1;\n                } else {\n                    H5Tclose(field_type_id);\n                    H5Dclose(field_id);\n                    Mat_Critical(\"Error allocating memory for matvar->dims\");\n                    return MATIO_E_OUT_OF_MEMORY;\n                }\n            } else {\n                matvar->dims = Mat_H5ReadDims(field_id, &nelems, &matvar->rank);\n                if ( NULL != matvar->dims ) {\n                    fields_are_variables = 0;\n                } else {\n                    H5Tclose(field_type_id);\n                    H5Dclose(field_id);\n                    return MATIO_E_UNKNOWN_ERROR;\n                }\n            }\n        } else {\n            /* Structure should be a scalar */\n            matvar->rank = 2;\n            matvar->dims = (size_t*)malloc(2*sizeof(*matvar->dims));\n            if ( NULL != matvar->dims ) {\n                matvar->dims[0] = 1;\n                matvar->dims[1] = 1;\n                nelems = 1;\n            } else {\n                H5Tclose(field_type_id);\n                H5Dclose(field_id);\n                Mat_Critical(\"Error allocating memory for matvar->dims\");\n                return MATIO_E_UNKNOWN_ERROR;\n            }\n        }\n        H5Tclose(field_type_id);\n        H5Dclose(field_id);\n    } else {\n        /* Structure should be a scalar */\n        matvar->rank = 2;\n        matvar->dims = (size_t*)malloc(2*sizeof(*matvar->dims));\n        if ( NULL != matvar->dims ) {\n            matvar->dims[0] = 1;\n            matvar->dims[1] = 1;\n            nelems = 1;\n        } else {\n            Mat_Critical(\"Error allocating memory for matvar->dims\");\n            return MATIO_E_OUT_OF_MEMORY;\n        }\n    }\n\n    if ( nelems < 1 || nfields < 1 )\n        return err;\n\n    matvar->data_size = sizeof(*fields);\n    {\n        size_t nelems_x_nfields;\n        err = Mul(&nelems_x_nfields, nelems, nfields);\n        err |= Mul(&matvar->nbytes, nelems_x_nfields, matvar->data_size);\n        if ( err ) {\n            Mat_Critical(\"Integer multiplication overflow\");\n            matvar->nbytes = 0;\n            return err;\n        }\n    }\n    fields = (matvar_t**)calloc(matvar->nbytes, 1);\n    matvar->data = fields;\n    if ( NULL != fields ) {\n        hsize_t k;\n        for ( k = 0; k < nfields; k++ ) {\n            H5O_INFO_T object_info;\n            fields[k] = NULL;\n            object_info.type = H5O_TYPE_UNKNOWN;\n            H5OGET_INFO_BY_NAME(dset_id, matvar->internal->fieldnames[k], &object_info, H5P_DEFAULT);\n            if ( object_info.type == H5O_TYPE_DATASET ) {\n                field_id = H5Dopen(dset_id,matvar->internal->fieldnames[k], H5P_DEFAULT);\n                if ( !fields_are_variables ) {\n                    hobj_ref_t *ref_ids = (hobj_ref_t*)calloc((size_t)nelems, sizeof(*ref_ids));\n                    if ( ref_ids != NULL ) {\n                        hsize_t l;\n                        herr_t herr = H5Dread(field_id,H5T_STD_REF_OBJ,H5S_ALL,H5S_ALL,\n                            H5P_DEFAULT,ref_ids);\n                        if ( herr < 0 ) {\n                            err = MATIO_E_GENERIC_READ_ERROR;\n                        } else {\n                            for ( l = 0; l < nelems; l++ ) {\n                                hid_t ref_id;\n                                fields[l*nfields+k] = Mat_VarCalloc();\n                                fields[l*nfields+k]->name =\n                                    strdup(matvar->internal->fieldnames[k]);\n                                fields[l*nfields+k]->internal->hdf5_ref=ref_ids[l];\n                                /* Closing of ref_id is done in Mat_H5ReadNextReferenceInfo */\n                                ref_id = H5RDEREFERENCE(field_id,H5R_OBJECT,ref_ids+l);\n                                if ( ref_id < 0 ) {\n                                    err = MATIO_E_GENERIC_READ_ERROR;\n                                } else {\n                                    fields[l*nfields+k]->internal->id = ref_id;\n                                    err = Mat_H5ReadNextReferenceInfo(ref_id,fields[l*nfields+k],mat);\n                                }\n                                if ( err ) {\n                                    break;\n                                }\n                            }\n                        }\n                        free(ref_ids);\n                    } else {\n                        err = MATIO_E_OUT_OF_MEMORY;\n                    }\n                } else {\n                    fields[k] = Mat_VarCalloc();\n                    fields[k]->name = strdup(matvar->internal->fieldnames[k]);\n                    err = Mat_H5ReadDatasetInfo(mat,fields[k],field_id);\n                }\n                H5Dclose(field_id);\n            } else if ( object_info.type == H5O_TYPE_GROUP ) {\n                field_id = H5Gopen(dset_id,matvar->internal->fieldnames[k],\n                                   H5P_DEFAULT);\n                if ( -1 < field_id ) {\n                    fields[k] = Mat_VarCalloc();\n                    fields[k]->name = strdup(matvar->internal->fieldnames[k]);\n                    err = Mat_H5ReadGroupInfo(mat,fields[k],field_id);\n                    H5Gclose(field_id);\n                }\n            }\n            if ( err ) {\n                break;\n            }\n        }\n    } else {\n        err = MATIO_E_OUT_OF_MEMORY;\n    }\n\n    return err;\n}\n",
    "target": 1,
    "idx": 1030081,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nMRB_API mrb_value\nmrb_vm_run(mrb_state *mrb, const struct RProc *proc, mrb_value self, mrb_int stack_keep)\n{\n  const mrb_irep *irep = proc->body.irep;\n  mrb_value result;\n  struct mrb_context *c = mrb->c;\n  ptrdiff_t cioff = c->ci - c->cibase;\n  mrb_int nregs = irep->nregs;\n\n  if (!c->stbase) {\n    stack_init(mrb);\n  }\n  if (stack_keep > nregs)\n    nregs = stack_keep;\n  mrb_stack_extend(mrb, nregs);\n  stack_clear(c->ci->stack + stack_keep, nregs - stack_keep);\n  c->ci->stack[0] = self;\n  result = mrb_vm_exec(mrb, proc, irep->iseq);\n  if (mrb->c != c) {\n    if (mrb->c->fib) {\n      mrb_write_barrier(mrb, (struct RBasic*)mrb->c->fib);\n    }\n    mrb->c = c;\n  }\n  else if (c->ci - c->cibase > cioff) {\n    c->ci = c->cibase + cioff;\n  }\n  return result;\n}\n\n\n// target function\nstatic void\ngen_assignment(codegen_scope *s, node *tree, node *rhs, int sp, int val)\n{\n  int idx;\n  int type = nint(tree->car);\n\n  switch (type) {\n  case NODE_GVAR:\n  case NODE_ARG:\n  case NODE_LVAR:\n  case NODE_IVAR:\n  case NODE_CVAR:\n  case NODE_CONST:\n  case NODE_NIL:\n  case NODE_MASGN:\n    if (rhs) {\n      codegen(s, rhs, VAL);\n      pop();\n      sp = cursp();\n    }\n    break;\n\n  case NODE_COLON2:\n  case NODE_CALL:\n  case NODE_SCALL:\n    /* keep evaluation order */\n    break;\n\n  case NODE_NVAR:\n    codegen_error(s, \"Can't assign to numbered parameter\");\n    break;\n\n  default:\n    codegen_error(s, \"unknown lhs\");\n    break;\n  }\n\n  tree = tree->cdr;\n  switch (type) {\n  case NODE_GVAR:\n    gen_setxv(s, OP_SETGV, sp, nsym(tree), val);\n    break;\n  case NODE_ARG:\n  case NODE_LVAR:\n    idx = lv_idx(s, nsym(tree));\n    if (idx > 0) {\n      if (idx != sp) {\n        gen_move(s, idx, sp, val);\n      }\n      break;\n    }\n    else {                      /* upvar */\n      gen_setupvar(s, sp, nsym(tree));\n    }\n    break;\n  case NODE_IVAR:\n    gen_setxv(s, OP_SETIV, sp, nsym(tree), val);\n    break;\n  case NODE_CVAR:\n    gen_setxv(s, OP_SETCV, sp, nsym(tree), val);\n    break;\n  case NODE_CONST:\n    gen_setxv(s, OP_SETCONST, sp, nsym(tree), val);\n    break;\n  case NODE_COLON2:\n    if (sp) {\n      gen_move(s, cursp(), sp, 0);\n    }\n    sp = cursp();\n    push();\n    codegen(s, tree->car, VAL);\n    if (rhs) {\n      codegen(s, rhs, VAL); pop();\n      gen_move(s, sp, cursp(), 0);\n    }\n    pop_n(2);\n    idx = new_sym(s, nsym(tree->cdr));\n    genop_2(s, OP_SETMCNST, sp, idx);\n    break;\n\n  case NODE_CALL:\n  case NODE_SCALL:\n    {\n      int noself = 0, safe = (type == NODE_SCALL), skip = 0, top, call, n = 0;\n      mrb_sym mid = nsym(tree->cdr->car);\n\n      top = cursp();\n      if (val || sp == cursp()) {\n        push();                   /* room for retval */\n      }\n      call = cursp();\n      if (!tree->car) {\n        noself = 1;\n        push();\n      }\n      else {\n        codegen(s, tree->car, VAL); /* receiver */\n      }\n      if (safe) {\n        int recv = cursp()-1;\n        gen_move(s, cursp(), recv, 1);\n        skip = genjmp2_0(s, OP_JMPNIL, cursp(), val);\n      }\n      tree = tree->cdr->cdr->car;\n      if (tree) {\n        if (tree->car) {            /* positional arguments */\n          n = gen_values(s, tree->car, VAL, (tree->cdr->car)?13:14);\n          if (n < 0) {              /* variable length */\n            n = 15;\n            push();\n          }\n        }\n        if (tree->cdr->car) {       /* keyword arguments */\n          if (n == 13 || n == 14) {\n            pop_n(n);\n            genop_2(s, OP_ARRAY, cursp(), n);\n            push();\n            n = 15;\n          }\n          gen_hash(s, tree->cdr->car->cdr, VAL, 0);\n          if (n < 14) {\n            n++;\n          }\n          else {\n            pop_n(2);\n            genop_2(s, OP_ARYPUSH, cursp(), 1);\n          }\n          push();\n        }\n      }\n      if (rhs) {\n        codegen(s, rhs, VAL);\n        pop();\n      }\n      else {\n        gen_move(s, cursp(), sp, 0);\n      }\n      if (val) {\n        gen_move(s, top, cursp(), 1);\n      }\n      if (n < 15) {\n        n++;\n        if (n == 15) {\n          pop_n(14);\n          genop_2(s, OP_ARRAY, cursp(), 15);\n        }\n      }\n      else {\n        pop();\n        genop_2(s, OP_ARYPUSH, cursp(), 1);\n      }\n      s->sp = call;\n      if (mid == MRB_OPSYM_2(s->mrb, aref) && n == 2) {\n        genop_1(s, OP_SETIDX, cursp());\n      }\n      else {\n        genop_3(s, noself ? OP_SSEND : OP_SEND, cursp(), new_sym(s, attrsym(s, mid)), n);\n      }\n      if (safe) {\n        dispatch(s, skip);\n      }\n      s->sp = top;\n    }\n    break;\n\n  case NODE_MASGN:\n    gen_massignment(s, tree->car, sp, val);\n    break;\n\n  /* splat without assignment */\n  case NODE_NIL:\n    break;\n\n  default:\n    codegen_error(s, \"unknown lhs\");\n    break;\n  }\n  if (val) push();\n}\n",
    "target": 1,
    "idx": 1049259,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "// context\nIM3CodePage  NewCodePage  (u32 i_minNumLines)\n{\n    static u32 s_sequence = 0;\n\n    IM3CodePage page;\n\n    u32 pageSize = sizeof (M3CodePageHeader) + sizeof (code_t) * i_minNumLines;\n\n    pageSize = (pageSize + (d_m3CodePageAlignSize-1)) & ~(d_m3CodePageAlignSize-1); // align\n    page = (IM3CodePage)m3_Malloc (pageSize);\n\n    if (page)\n    {\n        page->info.sequence = ++s_sequence;\n        page->info.numLines = (pageSize - sizeof (M3CodePageHeader)) / sizeof (code_t);\n\n#if d_m3RecordBacktraces\n        u32 pageSizeBt = sizeof (M3CodeMappingPage) + sizeof (M3CodeMapEntry) * page->info.numLines;\n        page->info.mapping = (M3CodeMappingPage *)m3_Malloc (pageSizeBt);\n\n        if (page->info.mapping)\n        {\n            page->info.mapping->size = 0;\n            page->info.mapping->capacity = page->info.numLines;\n        }\n        else\n        {\n            m3_Free (page);\n            return NULL;\n        }\n        page->info.mapping->basePC = GetPageStartPC(page);\n#endif // d_m3RecordBacktraces\n\n        m3log (runtime, \"new page: %p; seq: %d; bytes: %d; lines: %d\", GetPagePC (page), page->info.sequence, pageSize, page->info.numLines);\n    }\n\n    return page;\n}\n\nIM3CodePage  AcquireCodePageWithCapacity  (IM3Runtime i_runtime, u32 i_minLineCount)\n{\n    IM3CodePage page = RemoveCodePageOfCapacity (& i_runtime->pagesOpen, i_minLineCount);\n\n    if (not page)\n    {\n        page = Environment_AcquireCodePage (i_runtime->environment, i_minLineCount);\n\n        if (not page)\n            page = NewCodePage (i_minLineCount);\n\n        if (page)\n            i_runtime->numCodePages++;\n    }\n\n    if (page)\n    {                                                            m3log (emit, \"acquire page: %d\", page->info.sequence);\n        i_runtime->numActiveCodePages++;\n    }\n\n    return page;\n}\n\nM3Result  EnsureCodePageNumLines  (IM3Compilation o, u32 i_numLines)\n{\n    M3Result result = m3Err_none;\n\n    i_numLines += 2; // room for Bridge\n\n    if (NumFreeLines (o->page) < i_numLines)\n    {\n        IM3CodePage page = AcquireCodePageWithCapacity (o->runtime, i_numLines);\n\n        if (page)\n        {\n            m3log (emit, \"bridging new code page from: %d %p (free slots: %d) to: %d\", o->page->info.sequence, GetPC (o), NumFreeLines (o->page), page->info.sequence);\n            d_m3Assert (NumFreeLines (o->page) >= 2);\n\n            EmitWord (o->page, op_Branch);\n            EmitWord (o->page, GetPagePC (page));\n\n            ReleaseCodePage (o->runtime, o->page);\n\n            o->page = page;\n        }\n        else result = m3Err_mallocFailedCodePage;\n    }\n\n    return result;\n}\n\nM3Result  Compile_BranchTable  (IM3Compilation o, m3opcode_t i_opcode)\n{\n    M3Result result;\n\n_try {\n    u32 targetCount;\n_   (ReadLEB_u32 (& targetCount, & o->wasm, o->wasmEnd));\n\n_   (PreserveRegisterIfOccupied (o, c_m3Type_i64));         // move branch operand to a slot\n    u16 slot = GetStackTopSlotIndex (o);\n_   (Pop (o));\n\n    // OPTZ: according to spec: \"forward branches that target a control instruction with a non-empty\n    // result type consume matching operands first and push them back on the operand stack after unwinding\"\n    // So, this move-to-reg is only necessary if the target scopes have a type.\n    if (GetNumBlockValues (o) > 0)\n_      (MoveStackTopToRegister (o));\n\n    u32 numCodeLines = targetCount + 4; // 3 => IM3Operation + slot + target_count + default_target\n_   (EnsureCodePageNumLines (o, numCodeLines));\n\n_   (EmitOp (o, op_BranchTable));\n    EmitSlotOffset (o, slot);\n    EmitConstant32 (o, targetCount);\n\n    IM3CodePage continueOpPage = NULL;\n\n    ++targetCount; // include default\n    for (u32 i = 0; i < targetCount; ++i)\n    {\n        u32 target;\n_       (ReadLEB_u32 (& target, & o->wasm, o->wasmEnd));\n\n        IM3CompilationScope scope;\n_       (GetBlockScope (o, & scope, target));\n\n        if (scope->opcode == c_waOp_loop)\n        {\n            // create a ContinueLoop operation on a fresh page\n_           (AcquireCompilationCodePage (o, & continueOpPage));\n\n            pc_t startPC = GetPagePC (continueOpPage);\n            EmitPointer (o, startPC);\n\n            IM3CodePage savedPage = o->page;\n            o->page = continueOpPage;\n\n_           (EmitOp (o, op_ContinueLoop));\n            EmitPointer (o, scope->pc);\n\n            ReleaseCompilationCodePage (o);     // FIX: continueOpPage can get lost if thrown\n            o->page = savedPage;\n        }\n        else\n        {\n            IM3BranchPatch patch = NULL;\n_           (AcquirePatch (o, & patch));\n\n            patch->location = (pc_t *) ReservePointer (o);\n            patch->next = scope->patches;\n            scope->patches = patch;\n        }\n    }\n\n    o->block.isPolymorphic = true;\n\n    }\n\n    _catch: return result;\n}\n\nM3Result  Compile_BlockStatements  (IM3Compilation o)\n{\n    M3Result result = m3Err_none;\n\n    while (o->wasm < o->wasmEnd)\n    {                                                                   emit_stack_dump (o);\n        m3opcode_t opcode;\n        o->lastOpcodeStart = o->wasm;\n_       (Read_opcode (& opcode, & o->wasm, o->wasmEnd));                log_opcode (o, opcode);\n\n        if (IsCompilingExpressions(o)) {\n            switch (opcode) {\n            case c_waOp_i32_const: case c_waOp_i64_const:\n            case c_waOp_f32_const: case c_waOp_f64_const:\n            case c_waOp_getGlobal: case c_waOp_end:\n                break;\n            default:\n                _throw(m3Err_restictedOpcode);\n            }\n        }\n\n        IM3OpInfo opinfo = GetOpInfo(opcode);\n        _throwif (m3Err_unknownOpcode, opinfo == NULL);\n\n        if (opinfo->compiler) {\n_           ((* opinfo->compiler) (o, opcode))\n        } else {\n_           (Compile_Operator (o, opcode));\n        }\n\n        o->previousOpcode = opcode;                             //                      m3logif (stack, dump_type_stack (o))\n\n        if (o->stackIndex > d_m3MaxFunctionStackHeight)         // TODO: is this only place to check?\n            _throw (m3Err_functionStackOverflow);\n\n        if (opcode == c_waOp_end or opcode == c_waOp_else)\n            break;\n    }\n\n_catch:\n    return result;\n}\n\nM3Result  CompileBlock  (IM3Compilation o, IM3FuncType i_blockType, m3opcode_t i_blockOpcode)\n{\n    M3Result result;                                                                    d_m3Assert (not IsRegisterAllocated (o, 0));\n                                                                                        d_m3Assert (not IsRegisterAllocated (o, 1));\n    M3CompilationScope outerScope = o->block;\n    M3CompilationScope * block = & o->block;\n\n    block->outer            = & outerScope;\n    block->pc               = GetPagePC (o->page);\n    block->patches          = NULL;\n    block->type             = i_blockType;\n    block->initStackIndex   = o->stackIndex;\n    block->depth            ++;\n    block->opcode           = i_blockOpcode;\n\n_   (Compile_BlockStatements (o));\n\n    bool moveStackTopToRegister;\n_   (ValidateBlockEnd (o, & moveStackTopToRegister));\n\n    if (moveStackTopToRegister)\n_       (MoveStackTopToRegister (o));\n\n    PatchBranches (o);\n\n    o->block = outerScope;\n\n    _catch: return result;\n}\n\nM3Result  EvaluateExpression  (IM3Module i_module, void * o_expressed, u8 i_type, bytes_t * io_bytes, cbytes_t i_end)\n{\n    M3Result result = m3Err_none;\n\n    // create a temporary runtime context\n#if defined(d_m3PreferStaticAlloc)\n    static M3Runtime runtime;\n#else\n    M3Runtime runtime;\n#endif\n    M3_INIT (runtime);\n\n    runtime.environment = i_module->runtime->environment;\n    runtime.numStackSlots = i_module->runtime->numStackSlots;\n    runtime.stack = i_module->runtime->stack;\n    runtime.userdata = c_compilingExprsFlag;\n\n    m3stack_t stack = (m3stack_t)runtime.stack;\n\n    IM3Runtime savedRuntime = i_module->runtime;\n    i_module->runtime = & runtime;\n\n    IM3Compilation o = & runtime.compilation;\n    o->runtime = & runtime;\n    o->module =  i_module;\n    o->wasm =    * io_bytes;\n    o->wasmEnd = i_end;\n    o->lastOpcodeStart = o->wasm;\n\n    o->block.depth = -1;  // so that root compilation depth = 0\n\n    //  OPTZ: this code page could be erased after use.  maybe have 'empty' list in addition to full and open?\n    o->page = AcquireCodePage (& runtime);  // AcquireUnusedCodePage (...)\n\n    if (o->page)\n    {\n        IM3FuncType ftype = runtime.environment->retFuncTypes[i_type];\n\n        pc_t m3code = GetPagePC (o->page);\n        result = CompileBlock (o, ftype, c_waOp_block);\n\n        if (not result)\n        {\n            m3ret_t r = Call (m3code, stack, NULL, d_m3OpDefaultArgs);\n\n            if (r == 0)\n            {\n                if (SizeOfType (i_type) == sizeof (u32))\n                {\n                    * (u32 *) o_expressed = * ((u32 *) stack);\n                }\n                else\n                {\n                    * (u64 *) o_expressed = * ((u64 *) stack);\n                }\n            }\n        }\n\n        // TODO: EraseCodePage (...) see OPTZ above\n        ReleaseCodePage (& runtime, o->page);\n    }\n    else result = m3Err_mallocFailedCodePage;\n\n    runtime.stack = NULL;        // prevent free(stack) in ReleaseRuntime\n    Runtime_Release (& runtime);\n    i_module->runtime = savedRuntime;\n\n    * io_bytes = o->wasm;\n\n    return result;\n}\n\nM3Result  InitElements  (IM3Module io_module)\n{\n    M3Result result = m3Err_none;\n\n    bytes_t bytes = io_module->elementSection;\n    cbytes_t end = io_module->elementSectionEnd;\n\n    for (u32 i = 0; i < io_module->numElementSegments; ++i)\n    {\n        u32 index;\n_       (ReadLEB_u32 (& index, & bytes, end));\n\n        if (index == 0)\n        {\n            i32 offset;\n_           (EvaluateExpression (io_module, & offset, c_m3Type_i32, & bytes, end));\n            _throwif (\"table underflow\", offset < 0);\n\n            u32 numElements;\n_           (ReadLEB_u32 (& numElements, & bytes, end));\n\n            size_t endElement = numElements + offset;\n\n            io_module->table0 = m3_ReallocArray (IM3Function, io_module->table0, endElement, io_module->table0Size);\n            _throwifnull(io_module->table0);\n\n            _throwif (\"table overflow\", endElement > UINT_MAX)\n            io_module->table0Size = (u32) endElement;\n\n            for (u32 e = 0; e < numElements; ++e)\n            {\n                u32 functionIndex;\n_               (ReadLEB_u32 (& functionIndex, & bytes, end));\n                _throwif (\"function index out of range\", functionIndex >= io_module->numFunctions);\n                IM3Function function = & io_module->functions [functionIndex];      d_m3Assert (function); //printf (\"table: %s\\n\", m3_GetFunctionName(function));\n                io_module->table0 [e + offset] = function;\n            }\n        }\n        else _throw (\"element table index must be zero for MVP\");\n    }\n\n    _catch: return result;\n}\n\nM3Result  m3_LoadModule  (IM3Runtime io_runtime, IM3Module io_module)\n{\n    M3Result result = m3Err_none;\n\n    if (not io_module->runtime)\n    {\n        io_module->runtime = io_runtime;\n        M3Memory * memory = & io_runtime->memory;\n\n_       (InitMemory (io_runtime, io_module));\n_       (InitGlobals (io_module));\n_       (InitDataSegments (memory, io_module));\n_       (InitElements (io_module));\n\n        io_module->next = io_runtime->modules;\n        io_runtime->modules = io_module;\n\n        // Start func might use imported functions, which are not liked here yet,\n        // so it will be called before a function call is attempted (in m3_FindFuSnction)\n    }\n    else result = m3Err_moduleAlreadyLinked;\n\n    if (result)\n        io_module->runtime = NULL;\n\n    _catch: return result;\n}\n\n\n// target function\nM3Result  Compile_Memory_Size  (IM3Compilation o, m3opcode_t i_opcode)\n{\n    M3Result result;\n\n    i8 reserved;\n_   (ReadLEB_i7 (& reserved, & o->wasm, o->wasmEnd));\n\n_   (PreserveRegisterIfOccupied (o, c_m3Type_i32));\n\n_   (EmitOp     (o, op_MemCurrent));\n\n_   (PushRegister (o, c_m3Type_i32));\n\n    _catch: return result;\n}\nM3Result  Compile_BlockStatements  (IM3Compilation o)\n{\n    M3Result result = m3Err_none;\n\n    while (o->wasm < o->wasmEnd)\n    {                                                                   emit_stack_dump (o);\n        m3opcode_t opcode;\n        o->lastOpcodeStart = o->wasm;\n_       (Read_opcode (& opcode, & o->wasm, o->wasmEnd));                log_opcode (o, opcode);\n\n        IM3OpInfo opinfo = GetOpInfo(opcode);\n        _throwif (m3Err_unknownOpcode, opinfo == NULL);\n\n        if (opinfo->compiler) {\n_           ((* opinfo->compiler) (o, opcode))\n        } else {\n_           (Compile_Operator (o, opcode));\n        }\n\n        o->previousOpcode = opcode;                             //                      m3logif (stack, dump_type_stack (o))\n\n        if (o->stackIndex > d_m3MaxFunctionStackHeight)         // TODO: is this only place to check?\n            _throw (m3Err_functionStackOverflow);\n\n        if (opcode == c_waOp_end or opcode == c_waOp_else)\n            break;\n    }\n\n_catch:\n    return result;\n}\nM3Result  Compile_ReserveConstants  (IM3Compilation o)\n{\n    M3Result result = m3Err_none;\n\n    // in the interest of speed, this blindly scans the Wasm code looking for any byte\n    // that looks like an const opcode.\n    u32 numConstantSlots = 0;\n\n    bytes_t wa = o->wasm;\n    while (wa < o->wasmEnd)\n    {\n        u8 code = * wa++;\n\n        if (code == 0x41 or code == 0x43)       // i32, f32\n            numConstantSlots += 1;\n        else if (code == 0x42 or code == 0x44)  // i64, f64\n            numConstantSlots += GetTypeNumSlots (c_m3Type_i64);\n    }\n\n    // if constants overflow their reserved stack space, the compiler simply emits op_Const\n    // operations as needed. Compiled expressions (global inits) don't pass through this\n    // ReserveConstants function and thus always produce inline constants.\n    u16 cappedConstantSlots = M3_MIN (numConstantSlots, d_m3MaxConstantTableSize);\n\n    AlignSlotIndexToType (& cappedConstantSlots, c_m3Type_i64);                                         m3log (compile, \"estimated constant slots: %d; reserved: %d\", numConstantSlots, (u32) cappedConstantSlots)\n\n    o->slotFirstDynamicIndex = o->slotFirstConstIndex + cappedConstantSlots;\n\n    if (o->slotFirstDynamicIndex >= d_m3MaxFunctionSlots)\n        _throw (m3Err_functionStackOverflow);\n\n    _catch:\n    return result;\n}\nM3Result  EvaluateExpression  (IM3Module i_module, void * o_expressed, u8 i_type, bytes_t * io_bytes, cbytes_t i_end)\n{\n    M3Result result = m3Err_none;\n\n    // create a temporary runtime context\n#if defined(d_m3PreferStaticAlloc)\n    static M3Runtime runtime;\n#else\n    M3Runtime runtime;\n#endif\n    M3_INIT (runtime);\n\n    runtime.environment = i_module->runtime->environment;\n    runtime.numStackSlots = i_module->runtime->numStackSlots;\n    runtime.stack = i_module->runtime->stack;\n\n    m3stack_t stack = (m3stack_t)runtime.stack;\n\n    IM3Runtime savedRuntime = i_module->runtime;\n    i_module->runtime = & runtime;\n\n    IM3Compilation o = & runtime.compilation;\n    o->runtime = & runtime;\n    o->module =  i_module;\n    o->wasm =    * io_bytes;\n    o->wasmEnd = i_end;\n    o->lastOpcodeStart = o->wasm;\n\n    o->block.depth = -1;  // so that root compilation depth = 0\n\n    //  OPTZ: this code page could be erased after use.  maybe have 'empty' list in addition to full and open?\n    o->page = AcquireCodePage (& runtime);  // AcquireUnusedCodePage (...)\n\n    if (o->page)\n    {\n        IM3FuncType ftype = runtime.environment->retFuncTypes[i_type];\n\n        pc_t m3code = GetPagePC (o->page);\n        result = CompileBlock (o, ftype, c_waOp_block);\n\n        if (not result)\n        {\n            m3ret_t r = Call (m3code, stack, NULL, d_m3OpDefaultArgs);\n\n            if (r == 0)\n            {\n                if (SizeOfType (i_type) == sizeof (u32))\n                {\n                    * (u32 *) o_expressed = * ((u32 *) stack);\n                }\n                else\n                {\n                    * (u64 *) o_expressed = * ((u64 *) stack);\n                }\n            }\n        }\n\n        // TODO: EraseCodePage (...) see OPTZ above\n        ReleaseCodePage (& runtime, o->page);\n    }\n    else result = m3Err_mallocFailedCodePage;\n\n    runtime.stack = NULL;        // prevent free(stack) in ReleaseRuntime\n    Runtime_Release (& runtime);\n    i_module->runtime = savedRuntime;\n\n    * io_bytes = o->wasm;\n\n    return result;\n}\n",
    "target": 1,
    "idx": 1033196,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic int\nsc_oberthur_read_file(struct sc_pkcs15_card *p15card, const char *in_path,\n\t\tunsigned char **out, size_t *out_len,\n\t\tint verify_pin)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_card *card = p15card->card;\n\tstruct sc_file *file = NULL;\n\tstruct sc_path path;\n\tsize_t sz;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (!in_path || !out || !out_len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, \"Cannot read oberthur file\");\n\n\tsc_log(ctx, \"read file '%s'; verify_pin:%i\", in_path, verify_pin);\n\n\t*out = NULL;\n\t*out_len = 0;\n\n\tsc_format_path(in_path, &path);\n\trv = sc_select_file(card, &path, &file);\n\tif (rv != SC_SUCCESS) {\n\t\tsc_file_free(file);\n\t\tLOG_TEST_RET(ctx, rv, \"Cannot select oberthur file to read\");\n\t}\n\n\tif (file->ef_structure == SC_FILE_EF_TRANSPARENT)\n\t\tsz = file->size;\n\telse\n\t\tsz = (file->record_length + 2) * file->record_count;\n\n\t*out = calloc(sz, 1);\n\tif (*out == NULL) {\n\t\tsc_file_free(file);\n\t\tLOG_TEST_RET(ctx, SC_ERROR_OUT_OF_MEMORY, \"Cannot read oberthur file\");\n\t}\n\n\tif (file->ef_structure == SC_FILE_EF_TRANSPARENT)   {\n\t\trv = sc_read_binary(card, 0, *out, sz, 0);\n\t}\n\telse\t{\n\t\tsize_t rec;\n\t\tsize_t offs = 0;\n\t\tsize_t rec_len = file->record_length;\n\n\t\tfor (rec = 1; ; rec++)   {\n\t\t\tif (rec > file->record_count) {\n\t\t\t\trv = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trv = sc_read_record(card, rec, *out + offs + 2, rec_len, SC_RECORD_BY_REC_NR);\n\t\t\tif (rv == SC_ERROR_RECORD_NOT_FOUND)   {\n\t\t\t\trv = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (rv < 0)   {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trec_len = rv;\n\n\t\t\t*(*out + offs) = 'R';\n\t\t\t*(*out + offs + 1) = rv;\n\n\t\t\toffs += rv + 2;\n\t\t}\n\n\t\tsz = offs;\n\t}\n\n\tsc_log(ctx, \"read oberthur file result %i\", rv);\n\tif (verify_pin && rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)   {\n\t\tstruct sc_pkcs15_object *objs[0x10], *pin_obj = NULL;\n\t\tconst struct sc_acl_entry *acl = sc_file_get_acl_entry(file, SC_AC_OP_READ);\n\t\tint ii;\n\n\t\trv = sc_pkcs15_get_objects(p15card, SC_PKCS15_TYPE_AUTH_PIN, objs, 0x10);\n\t\tif (rv != SC_SUCCESS) {\n\t\t\tsc_file_free(file);\n\t\t\tLOG_TEST_RET(ctx, rv, \"Cannot read oberthur file: get AUTH objects error\");\n\t\t}\n\n\t\tfor (ii=0; ii<rv; ii++)   {\n\t\t\tstruct sc_pkcs15_auth_info *auth_info = (struct sc_pkcs15_auth_info *) objs[ii]->data;\n\t\t\tsc_log(ctx, \"compare PIN/ACL refs:%i/%i, method:%i/%i\",\n\t\t\t\t\tauth_info->attrs.pin.reference, acl->key_ref, auth_info->auth_method, acl->method);\n\t\t\tif (auth_info->attrs.pin.reference == (int)acl->key_ref && auth_info->auth_method == (unsigned)acl->method)   {\n\t\t\t\tpin_obj = objs[ii];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!pin_obj || !pin_obj->content.value)    {\n\t\t\trv = SC_ERROR_SECURITY_STATUS_NOT_SATISFIED;\n\t\t}\n\t\telse    {\n\t\t\trv = sc_pkcs15_verify_pin(p15card, pin_obj, pin_obj->content.value, pin_obj->content.len);\n\t\t\tif (!rv)\n\t\t\t\trv = sc_oberthur_read_file(p15card, in_path, out, out_len, 0);\n\t\t}\n\t};\n\n\tsc_file_free(file);\n\n\tif (rv < 0)   {\n\t\tfree(*out);\n\t\t*out = NULL;\n\t\t*out_len = 0;\n\t}\n\n\t*out_len = sz;\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\nstatic int\nsc_pkcs15emu_oberthur_init(struct sc_pkcs15_card * p15card)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_pkcs15_auth_info auth_info;\n\tstruct sc_pkcs15_object   obj;\n\tstruct sc_card *card = p15card->card;\n\tstruct sc_path path;\n\tint rv, ii, tries_left;\n\tchar serial[0x10];\n\tunsigned char sopin_reference = 0x04;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\tsc_bin_to_hex(card->serialnr.value, card->serialnr.len, serial, sizeof(serial), 0);\n\tset_string(&p15card->tokeninfo->serial_number, serial);\n\n\tp15card->ops.parse_df = sc_awp_parse_df;\n\tp15card->ops.clear = sc_awp_clear;\n\n\tsc_log(ctx, \"Oberthur init: serial %s\", p15card->tokeninfo->serial_number);\n\n\tsc_format_path(AWP_PIN_DF, &path);\n\trv = sc_select_file(card, &path, NULL);\n\tLOG_TEST_RET(ctx, rv, \"Oberthur init failed: cannot select PIN dir\");\n\n\ttries_left = -1;\n\trv = sc_verify(card, SC_AC_CHV, sopin_reference, (unsigned char *)\"\", 0, &tries_left);\n\tif (rv && rv != SC_ERROR_PIN_CODE_INCORRECT)   {\n\t\tsopin_reference = 0x84;\n\t\trv = sc_verify(card, SC_AC_CHV, sopin_reference, (unsigned char *)\"\", 0, &tries_left);\n\t}\n\tif (rv && rv != SC_ERROR_PIN_CODE_INCORRECT)\n\t\tLOG_TEST_RET(ctx, rv, \"Invalid state of SO-PIN\");\n\n\t/* add PIN */\n\tmemset(&auth_info, 0, sizeof(auth_info));\n\tmemset(&obj,  0, sizeof(obj));\n\n\tauth_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;\n\tauth_info.auth_method\t= SC_AC_CHV;\n\tauth_info.auth_id.len = 1;\n\tauth_info.auth_id.value[0] = 0xFF;\n\tauth_info.attrs.pin.min_length\t\t= 4;\n\tauth_info.attrs.pin.max_length\t\t= 64;\n\tauth_info.attrs.pin.stored_length\t= 64;\n\tauth_info.attrs.pin.type\t\t= SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;\n\tauth_info.attrs.pin.reference\t\t= sopin_reference;\n\tauth_info.attrs.pin.pad_char\t\t= 0xFF;\n\tauth_info.attrs.pin.flags\t\t= SC_PKCS15_PIN_FLAG_CASE_SENSITIVE\n\t\t\t\t| SC_PKCS15_PIN_FLAG_INITIALIZED\n\t\t\t\t| SC_PKCS15_PIN_FLAG_NEEDS_PADDING\n\t\t\t\t| SC_PKCS15_PIN_FLAG_SO_PIN;\n\tauth_info.tries_left\t\t= tries_left;\n\tauth_info.logged_in = SC_PIN_STATE_UNKNOWN;\n\n\tstrncpy(obj.label, \"SO PIN\", SC_PKCS15_MAX_LABEL_SIZE-1);\n\tobj.flags = SC_PKCS15_CO_FLAG_MODIFIABLE | SC_PKCS15_CO_FLAG_PRIVATE;\n\n\tsc_log(ctx, \"Add PIN(%s,auth_id:%s,reference:%i)\", obj.label,\n\t\t\tsc_pkcs15_print_id(&auth_info.auth_id), auth_info.attrs.pin.reference);\n\trv = sc_pkcs15emu_add_pin_obj(p15card, &obj, &auth_info);\n\tLOG_TEST_RET(ctx, rv, \"Oberthur init failed: cannot add PIN object\");\n\n\ttries_left = -1;\n\trv = sc_verify(card, SC_AC_CHV, 0x81, (unsigned char *)\"\", 0, &tries_left);\n\tif (rv == SC_ERROR_PIN_CODE_INCORRECT)   {\n\t\t/* add PIN */\n\t\tmemset(&auth_info, 0, sizeof(auth_info));\n\t\tmemset(&obj,  0, sizeof(obj));\n\n\t\tauth_info.auth_id.len = sizeof(PinDomainID) > sizeof(auth_info.auth_id.value)\n\t\t\t\t? sizeof(auth_info.auth_id.value) : sizeof(PinDomainID);\n\t\tmemcpy(auth_info.auth_id.value, PinDomainID, auth_info.auth_id.len);\n\t\tauth_info.auth_method\t= SC_AC_CHV;\n\n\t\tauth_info.attrs.pin.min_length\t\t= 4;\n\t\tauth_info.attrs.pin.max_length\t\t= 64;\n\t\tauth_info.attrs.pin.stored_length\t= 64;\n\t\tauth_info.attrs.pin.type\t\t= SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;\n\t\tauth_info.attrs.pin.reference\t\t= 0x81;\n\t\tauth_info.attrs.pin.pad_char\t\t= 0xFF;\n\t\tauth_info.attrs.pin.flags\t\t= SC_PKCS15_PIN_FLAG_CASE_SENSITIVE\n\t\t\t\t\t| SC_PKCS15_PIN_FLAG_INITIALIZED\n\t\t\t\t\t| SC_PKCS15_PIN_FLAG_NEEDS_PADDING\n\t\t\t\t\t| SC_PKCS15_PIN_FLAG_LOCAL;\n\t\tauth_info.tries_left\t\t= tries_left;\n\n\t\tstrncpy(obj.label, PIN_DOMAIN_LABEL, SC_PKCS15_MAX_LABEL_SIZE-1);\n\t\tobj.flags = SC_PKCS15_CO_FLAG_MODIFIABLE | SC_PKCS15_CO_FLAG_PRIVATE;\n\t\tif (sopin_reference == 0x84) {\n\t\t\t/*\n\t\t\t * auth_pin_reset_oberthur_style() in card-oberthur.c\n\t\t\t * always uses PUK with reference 0x84 for\n\t\t\t * unblocking of User PIN\n\t\t\t */\n\t\t\tobj.auth_id.len = 1;\n\t\t\tobj.auth_id.value[0] = 0xFF;\n\t\t}\n\n\t\tsc_format_path(AWP_PIN_DF, &auth_info.path);\n\t\tauth_info.path.type = SC_PATH_TYPE_PATH;\n\n\t\tsc_log(ctx, \"Add PIN(%s,auth_id:%s,reference:%i)\", obj.label,\n\t\t\t\tsc_pkcs15_print_id(&auth_info.auth_id), auth_info.attrs.pin.reference);\n\t\trv = sc_pkcs15emu_add_pin_obj(p15card, &obj, &auth_info);\n\t\tLOG_TEST_RET(ctx, rv, \"Oberthur init failed: cannot add PIN object\");\n\t}\n\telse if (rv != SC_ERROR_DATA_OBJECT_NOT_FOUND)    {\n\t\tLOG_TEST_RET(ctx, rv, \"Oberthur init failed: cannot verify PIN\");\n\t}\n\n\tfor (ii=0; oberthur_infos[ii].name; ii++)   {\n\t\tsc_log(ctx, \"Oberthur init: read %s file\", oberthur_infos[ii].name);\n\t\trv = sc_oberthur_read_file(p15card, oberthur_infos[ii].path,\n\t\t\t\t&oberthur_infos[ii].content, &oberthur_infos[ii].len, 1);\n\t\tLOG_TEST_RET(ctx, rv, \"Oberthur init failed: read oberthur file error\");\n\n\t\tsc_log(ctx,\n\t\t       \"Oberthur init: parse %s file, content length %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t       oberthur_infos[ii].name, oberthur_infos[ii].len);\n\t\trv = oberthur_infos[ii].parser(p15card, oberthur_infos[ii].content, oberthur_infos[ii].len,\n\t\t\t\toberthur_infos[ii].postpone_allowed);\n\t\tLOG_TEST_RET(ctx, rv, \"Oberthur init failed: parse error\");\n\t}\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n\nint\nsc_pkcs15emu_oberthur_init_ex(struct sc_pkcs15_card * p15card, struct sc_aid *aid)\n{\n\tint rv;\n\n\tLOG_FUNC_CALLED(p15card->card->ctx);\n\trv = oberthur_detect_card(p15card);\n\tif (!rv)\n\t\trv = sc_pkcs15emu_oberthur_init(p15card);\n\n\tLOG_FUNC_RETURN(p15card->card->ctx, rv);\n}\n\nint\nsc_pkcs15_bind_synthetic(sc_pkcs15_card_t *p15card, struct sc_aid *aid)\n{\n\tsc_context_t\t\t*ctx = p15card->card->ctx;\n\tscconf_block\t\t*conf_block, **blocks, *blk;\n\tint\t\t\ti, r = SC_ERROR_WRONG_CARD;\n\n\tSC_FUNC_CALLED(ctx, SC_LOG_DEBUG_VERBOSE);\n\tconf_block = NULL;\n\n\tconf_block = sc_get_conf_block(ctx, \"framework\", \"pkcs15\", 1);\n\n\tif (!conf_block) {\n\t\t/* no conf file found => try builtin drivers  */\n\t\tsc_log(ctx, \"no conf file (or section), trying all builtin emulators\");\n\t\tfor (i = 0; builtin_emulators[i].name; i++) {\n\t\t\tsc_log(ctx, \"trying %s\", builtin_emulators[i].name);\n\t\t\tr = builtin_emulators[i].handler(p15card, aid);\n\t\t\tif (r == SC_SUCCESS)\n\t\t\t\t/* we got a hit */\n\t\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t/* we have a conf file => let's use it */\n\t\tint builtin_enabled;\n\t\tconst scconf_list *list, *item;\n\n\t\tbuiltin_enabled = scconf_get_bool(conf_block, \"enable_builtin_emulation\", 1);\n\t\tlist = scconf_find_list(conf_block, \"builtin_emulators\"); /* FIXME: rename to enabled_emulators */\n\n\t\tif (builtin_enabled && list) {\n\t\t\t/* get the list of enabled emulation drivers */\n\t\t\tfor (item = list; item; item = item->next) {\n\t\t\t\t/* go through the list of builtin drivers */\n\t\t\t\tconst char *name = item->data;\n\n\t\t\t\tsc_log(ctx, \"trying %s\", name);\n\t\t\t\tfor (i = 0; builtin_emulators[i].name; i++)\n\t\t\t\t\tif (!strcmp(builtin_emulators[i].name, name)) {\n\t\t\t\t\t\tr = builtin_emulators[i].handler(p15card, aid);\n\t\t\t\t\t\tif (r == SC_SUCCESS)\n\t\t\t\t\t\t\t/* we got a hit */\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (builtin_enabled) {\n\t\t\tsc_log(ctx, \"no emulator list in config file, trying all builtin emulators\");\n\t\t\tfor (i = 0; builtin_emulators[i].name; i++) {\n\t\t\t\tsc_log(ctx, \"trying %s\", builtin_emulators[i].name);\n\t\t\t\tr = builtin_emulators[i].handler(p15card, aid);\n\t\t\t\tif (r == SC_SUCCESS)\n\t\t\t\t\t/* we got a hit */\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/* search for 'emulate foo { ... }' entries in the conf file */\n\t\tsc_log(ctx, \"searching for 'emulate foo { ... }' blocks\");\n\t\tblocks = scconf_find_blocks(ctx->conf, conf_block, \"emulate\", NULL);\n\t\tsc_log(ctx, \"Blocks: %p\", blocks);\n\t\tfor (i = 0; blocks && (blk = blocks[i]) != NULL; i++) {\n\t\t\tconst char *name = blk->name->data;\n\t\t\tsc_log(ctx, \"trying %s\", name);\n\t\t\tr = parse_emu_block(p15card, aid, blk);\n\t\t\tif (r == SC_SUCCESS) {\n\t\t\t\tfree(blocks);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tif (blocks)\n\t\t\tfree(blocks);\n\t}\n\nout:\n\tif (r == SC_SUCCESS) {\n\t\tp15card->magic  = SC_PKCS15_CARD_MAGIC;\n\t\tp15card->flags |= SC_PKCS15_CARD_FLAG_EMULATED;\n\t} else {\n\t\tif (r != SC_ERROR_WRONG_CARD)\n\t\t\tsc_log(ctx, \"Failed to load card emulator: %s\", sc_strerror(r));\n\t}\n\n\tLOG_FUNC_RETURN(ctx, r);\n}\n\nint\nsc_pkcs15_bind(struct sc_card *card, struct sc_aid *aid,\n\t\tstruct sc_pkcs15_card **p15card_out)\n{\n\tstruct sc_pkcs15_card *p15card = NULL;\n\tstruct sc_context *ctx;\n\tscconf_block *conf_block = NULL;\n\tint r, emu_first, enable_emu;\n\tconst char *private_certificate;\n\n\tif (card == NULL || p15card_out == NULL) {\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\tctx = card->ctx;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"application(aid:'%s')\", aid ? sc_dump_hex(aid->value, aid->len) : \"empty\");\n\n\tp15card = sc_pkcs15_card_new();\n\tif (p15card == NULL)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY);\n\n\tp15card->card = card;\n\tp15card->opts.use_file_cache = 0;\n\tp15card->opts.use_pin_cache = 1;\n\tp15card->opts.pin_cache_counter = 10;\n\tp15card->opts.pin_cache_ignore_user_consent = 0;\n\tif(0 == strcmp(ctx->app_name, \"tokend\")) {\n\t\tprivate_certificate = \"ignore\";\n\t\tp15card->opts.private_certificate = SC_PKCS15_CARD_OPTS_PRIV_CERT_IGNORE;\n\t} else {\n\t\tprivate_certificate = \"protect\";\n\t\tp15card->opts.private_certificate = SC_PKCS15_CARD_OPTS_PRIV_CERT_PROTECT;\n\t}\n\n\tconf_block = sc_get_conf_block(ctx, \"framework\", \"pkcs15\", 1);\n\tif (conf_block) {\n\t\tp15card->opts.use_file_cache = scconf_get_bool(conf_block, \"use_file_caching\", p15card->opts.use_file_cache);\n\t\tp15card->opts.use_pin_cache = scconf_get_bool(conf_block, \"use_pin_caching\", p15card->opts.use_pin_cache);\n\t\tp15card->opts.pin_cache_counter = scconf_get_int(conf_block, \"pin_cache_counter\", p15card->opts.pin_cache_counter);\n\t\tp15card->opts.pin_cache_ignore_user_consent = scconf_get_bool(conf_block, \"pin_cache_ignore_user_consent\",\n\t\t\t\tp15card->opts.pin_cache_ignore_user_consent);\n\t\tprivate_certificate = scconf_get_str(conf_block, \"private_certificate\", private_certificate);\n\t}\n\tif (0 == strcmp(private_certificate, \"protect\")) {\n\t\tp15card->opts.private_certificate = SC_PKCS15_CARD_OPTS_PRIV_CERT_PROTECT;\n\t} else if (0 == strcmp(private_certificate, \"ignore\")) {\n\t\tp15card->opts.private_certificate = SC_PKCS15_CARD_OPTS_PRIV_CERT_IGNORE;\n\t} else if (0 == strcmp(private_certificate, \"declassify\")) {\n\t\tp15card->opts.private_certificate = SC_PKCS15_CARD_OPTS_PRIV_CERT_DECLASSIFY;\n\t}\n\tsc_log(ctx, \"PKCS#15 options: use_file_cache=%d use_pin_cache=%d pin_cache_counter=%d pin_cache_ignore_user_consent=%d private_certificate=%d\",\n\t\t\tp15card->opts.use_file_cache, p15card->opts.use_pin_cache,p15card->opts.pin_cache_counter,\n\t\t\tp15card->opts.pin_cache_ignore_user_consent, p15card->opts.private_certificate);\n\n\tr = sc_lock(card);\n\tif (r) {\n\t\tsc_log(ctx, \"sc_lock() failed: %s\", sc_strerror(r));\n\t\tsc_pkcs15_card_free(p15card);\n\t\tLOG_FUNC_RETURN(ctx, r);\n\t}\n\n\tenable_emu = scconf_get_bool(conf_block, \"enable_pkcs15_emulation\", 1);\n\tif (enable_emu) {\n\t\tsc_log(ctx, \"PKCS#15 emulation enabled\");\n\t\temu_first = scconf_get_bool(conf_block, \"try_emulation_first\", 0);\n\t\tif (emu_first || sc_pkcs15_is_emulation_only(card)) {\n\t\t\tr = sc_pkcs15_bind_synthetic(p15card, aid);\n\t\t\tif (r == SC_SUCCESS)\n\t\t\t\tgoto done;\n\t\t\tr = sc_pkcs15_bind_internal(p15card, aid);\n\t\t\tif (r < 0)\n\t\t\t\tgoto error;\n\t\t} else {\n\t\t\tr = sc_pkcs15_bind_internal(p15card, aid);\n\t\t\tif (r == SC_SUCCESS)\n\t\t\t\tgoto done;\n\t\t\tr = sc_pkcs15_bind_synthetic(p15card, aid);\n\t\t\tif (r < 0)\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\telse {\n\t\tr = sc_pkcs15_bind_internal(p15card, aid);\n\t\tif (r < 0)\n\t\t\tgoto error;\n\t}\ndone:\n\t*p15card_out = p15card;\n\tsc_unlock(card);\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\nerror:\n\tsc_unlock(card);\n\tsc_pkcs15_card_free(p15card);\n\tLOG_FUNC_RETURN(ctx, r);\n}\n\n\n// target function\nstatic int\nsc_oberthur_read_file(struct sc_pkcs15_card *p15card, const char *in_path,\n\t\tunsigned char **out, size_t *out_len,\n\t\tint verify_pin)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_card *card = p15card->card;\n\tstruct sc_file *file = NULL;\n\tstruct sc_path path;\n\tsize_t sz;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (!in_path || !out || !out_len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, \"Cannot read oberthur file\");\n\n\tsc_log(ctx, \"read file '%s'; verify_pin:%i\", in_path, verify_pin);\n\n\t*out = NULL;\n\t*out_len = 0;\n\n\tsc_format_path(in_path, &path);\n\trv = sc_select_file(card, &path, &file);\n\tif (rv != SC_SUCCESS) {\n\t\tsc_file_free(file);\n\t\tLOG_TEST_RET(ctx, rv, \"Cannot select oberthur file to read\");\n\t}\n\n\tif (file->ef_structure == SC_FILE_EF_TRANSPARENT)\n\t\tsz = file->size;\n\telse\n\t\tsz = (file->record_length + 2) * file->record_count;\n\n\t*out = calloc(sz, 1);\n\tif (*out == NULL) {\n\t\tsc_file_free(file);\n\t\tLOG_TEST_RET(ctx, SC_ERROR_OUT_OF_MEMORY, \"Cannot read oberthur file\");\n\t}\n\n\tif (file->ef_structure == SC_FILE_EF_TRANSPARENT)   {\n\t\trv = sc_read_binary(card, 0, *out, sz, 0);\n\t}\n\telse\t{\n\t\tint rec;\n\t\tint offs = 0;\n\t\tint rec_len = file->record_length;\n\n\t\tfor (rec = 1; ; rec++)   {\n\t\t\trv = sc_read_record(card, rec, *out + offs + 2, rec_len, SC_RECORD_BY_REC_NR);\n\t\t\tif (rv == SC_ERROR_RECORD_NOT_FOUND)   {\n\t\t\t\trv = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (rv < 0)   {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trec_len = rv;\n\n\t\t\t*(*out + offs) = 'R';\n\t\t\t*(*out + offs + 1) = rv;\n\n\t\t\toffs += rv + 2;\n\t\t}\n\n\t\tsz = offs;\n\t}\n\n\tsc_log(ctx, \"read oberthur file result %i\", rv);\n\tif (verify_pin && rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)   {\n\t\tstruct sc_pkcs15_object *objs[0x10], *pin_obj = NULL;\n\t\tconst struct sc_acl_entry *acl = sc_file_get_acl_entry(file, SC_AC_OP_READ);\n\t\tint ii;\n\n\t\trv = sc_pkcs15_get_objects(p15card, SC_PKCS15_TYPE_AUTH_PIN, objs, 0x10);\n\t\tif (rv != SC_SUCCESS) {\n\t\t\tsc_file_free(file);\n\t\t\tLOG_TEST_RET(ctx, rv, \"Cannot read oberthur file: get AUTH objects error\");\n\t\t}\n\n\t\tfor (ii=0; ii<rv; ii++)   {\n\t\t\tstruct sc_pkcs15_auth_info *auth_info = (struct sc_pkcs15_auth_info *) objs[ii]->data;\n\t\t\tsc_log(ctx, \"compare PIN/ACL refs:%i/%i, method:%i/%i\",\n\t\t\t\t\tauth_info->attrs.pin.reference, acl->key_ref, auth_info->auth_method, acl->method);\n\t\t\tif (auth_info->attrs.pin.reference == (int)acl->key_ref && auth_info->auth_method == (unsigned)acl->method)   {\n\t\t\t\tpin_obj = objs[ii];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!pin_obj || !pin_obj->content.value)    {\n\t\t\trv = SC_ERROR_SECURITY_STATUS_NOT_SATISFIED;\n\t\t}\n\t\telse    {\n\t\t\trv = sc_pkcs15_verify_pin(p15card, pin_obj, pin_obj->content.value, pin_obj->content.len);\n\t\t\tif (!rv)\n\t\t\t\trv = sc_oberthur_read_file(p15card, in_path, out, out_len, 0);\n\t\t}\n\t};\n\n\tsc_file_free(file);\n\n\tif (rv < 0)   {\n\t\tfree(*out);\n\t\t*out = NULL;\n\t\t*out_len = 0;\n\t}\n\n\t*out_len = sz;\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n",
    "target": 1,
    "idx": 1024316,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nMRB_API mrb_value\nmrb_funcall_argv(mrb_state *mrb, mrb_value self, mrb_sym mid, mrb_int argc, const mrb_value *argv)\n{\n  return mrb_funcall_with_block(mrb, self, mid, argc, argv, mrb_nil_value());\n}\n\nstatic mrb_value\nconst_get(mrb_state *mrb, struct RClass *base, mrb_sym sym, mrb_bool skip)\n{\n  struct RClass *c = base;\n  mrb_value v;\n  mrb_bool retry = FALSE;\n  mrb_value name;\n\n  if (skip) c = c->super;\nL_RETRY:\n  while (c) {\n    if (!MRB_FLAG_TEST(c, MRB_FL_CLASS_IS_PREPENDED) && c->iv) {\n      if (iv_get(mrb, c->iv, sym, &v))\n        return v;\n    }\n    c = c->super;\n  }\n  if (!retry && base->tt == MRB_TT_MODULE) {\n    c = mrb->object_class;\n    retry = TRUE;\n    goto L_RETRY;\n  }\n  name = mrb_symbol_value(sym);\n  return mrb_funcall_argv(mrb, mrb_obj_value(base), MRB_SYM(const_missing), 1, &name);\n}\n\nmrb_value\nmrb_vm_const_get(mrb_state *mrb, mrb_sym sym)\n{\n  struct RClass *c;\n  struct RClass *c2;\n  mrb_value v;\n  const struct RProc *proc = mrb->c->ci->proc;\n\n  c = MRB_PROC_TARGET_CLASS(proc);\n  if (!c) c = mrb->object_class;\n  if (iv_get(mrb, c->iv, sym, &v)) {\n    return v;\n  }\n  c2 = c;\n  while (c2 && c2->tt == MRB_TT_SCLASS) {\n    mrb_value klass;\n\n    if (!iv_get(mrb, c2->iv, MRB_SYM(__attached__), &klass)) {\n      c2 = NULL;\n      break;\n    }\n    c2 = mrb_class_ptr(klass);\n  }\n  if (c2 && (c2->tt == MRB_TT_CLASS || c2->tt == MRB_TT_MODULE)) c = c2;\n  proc = proc->upper;\n  while (proc) {\n    c2 = MRB_PROC_TARGET_CLASS(proc);\n    if (c2 && iv_get(mrb, c2->iv, sym, &v)) {\n      return v;\n    }\n    proc = proc->upper;\n  }\n  return const_get(mrb, c, sym, TRUE);\n}\n\nMRB_API mrb_value\nmrb_vm_exec(mrb_state *mrb, const struct RProc *proc, const mrb_code *pc)\n{\n  /* mrb_assert(MRB_PROC_CFUNC_P(proc)) */\n  const mrb_irep *irep = proc->body.irep;\n  const mrb_pool_value *pool = irep->pool;\n  const mrb_sym *syms = irep->syms;\n  mrb_code insn;\n  int ai = mrb_gc_arena_save(mrb);\n  struct mrb_jmpbuf *prev_jmp = mrb->jmp;\n  struct mrb_jmpbuf c_jmp;\n  uint32_t a;\n  uint16_t b;\n  uint16_t c;\n  mrb_sym mid;\n  const struct mrb_irep_catch_handler *ch;\n\n#ifdef DIRECT_THREADED\n  static const void * const optable[] = {\n#define OPCODE(x,_) &&L_OP_ ## x,\n#include \"mruby/ops.h\"\n#undef OPCODE\n  };\n#endif\n\n  mrb_bool exc_catched = FALSE;\nRETRY_TRY_BLOCK:\n\n  MRB_TRY(&c_jmp) {\n\n  if (exc_catched) {\n    exc_catched = FALSE;\n    mrb_gc_arena_restore(mrb, ai);\n    if (mrb->exc && mrb->exc->tt == MRB_TT_BREAK)\n      goto L_BREAK;\n    goto L_RAISE;\n  }\n  mrb->jmp = &c_jmp;\n  mrb_vm_ci_proc_set(mrb->c->ci, proc);\n\n#define regs (mrb->c->ci->stack)\n  INIT_DISPATCH {\n    CASE(OP_NOP, Z) {\n      /* do nothing */\n      NEXT;\n    }\n\n    CASE(OP_MOVE, BB) {\n      regs[a] = regs[b];\n      NEXT;\n    }\n\n    CASE(OP_LOADL, BB) {\n      switch (pool[b].tt) {   /* number */\n      case IREP_TT_INT32:\n        regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i32);\n        break;\n      case IREP_TT_INT64:\n#if defined(MRB_INT64)\n        regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i64);\n        break;\n#else\n#if defined(MRB_64BIT)\n        if (INT32_MIN <= pool[b].u.i64 && pool[b].u.i64 <= INT32_MAX) {\n          regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i64);\n          break;\n        }\n#endif\n        goto L_INT_OVERFLOW;\n#endif\n      case IREP_TT_BIGINT:\n        goto L_INT_OVERFLOW;\n#ifndef MRB_NO_FLOAT\n      case IREP_TT_FLOAT:\n        regs[a] = mrb_float_value(mrb, pool[b].u.f);\n        break;\n#endif\n      default:\n        /* should not happen (tt:string) */\n        regs[a] = mrb_nil_value();\n        break;\n      }\n      NEXT;\n    }\n\n    CASE(OP_LOADI, BB) {\n      SET_FIXNUM_VALUE(regs[a], b);\n      NEXT;\n    }\n\n    CASE(OP_LOADINEG, BB) {\n      SET_FIXNUM_VALUE(regs[a], -b);\n      NEXT;\n    }\n\n    CASE(OP_LOADI__1,B) goto L_LOADI;\n    CASE(OP_LOADI_0,B) goto L_LOADI;\n    CASE(OP_LOADI_1,B) goto L_LOADI;\n    CASE(OP_LOADI_2,B) goto L_LOADI;\n    CASE(OP_LOADI_3,B) goto L_LOADI;\n    CASE(OP_LOADI_4,B) goto L_LOADI;\n    CASE(OP_LOADI_5,B) goto L_LOADI;\n    CASE(OP_LOADI_6,B) goto L_LOADI;\n    CASE(OP_LOADI_7, B) {\n    L_LOADI:\n      SET_FIXNUM_VALUE(regs[a], (mrb_int)insn - (mrb_int)OP_LOADI_0);\n      NEXT;\n    }\n\n    CASE(OP_LOADI16, BS) {\n      SET_FIXNUM_VALUE(regs[a], (mrb_int)(int16_t)b);\n      NEXT;\n    }\n\n    CASE(OP_LOADI32, BSS) {\n      SET_INT_VALUE(mrb, regs[a], (int32_t)(((uint32_t)b<<16)+c));\n      NEXT;\n    }\n\n    CASE(OP_LOADSYM, BB) {\n      SET_SYM_VALUE(regs[a], syms[b]);\n      NEXT;\n    }\n\n    CASE(OP_LOADNIL, B) {\n      SET_NIL_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_LOADSELF, B) {\n      regs[a] = regs[0];\n      NEXT;\n    }\n\n    CASE(OP_LOADT, B) {\n      SET_TRUE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_LOADF, B) {\n      SET_FALSE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETGV, BB) {\n      mrb_value val = mrb_gv_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETGV, BB) {\n      mrb_gv_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETSV, BB) {\n      mrb_value val = mrb_vm_special_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETSV, BB) {\n      mrb_vm_special_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETIV, BB) {\n      regs[a] = mrb_iv_get(mrb, regs[0], syms[b]);\n      NEXT;\n    }\n\n    CASE(OP_SETIV, BB) {\n      mrb_iv_set(mrb, regs[0], syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETCV, BB) {\n      mrb_value val;\n      val = mrb_vm_cv_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETCV, BB) {\n      mrb_vm_cv_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETIDX, B) {\n      mrb_value va = regs[a], vb = regs[a+1];\n      switch (mrb_type(va)) {\n      case MRB_TT_ARRAY:\n        if (!mrb_integer_p(vb)) goto getidx_fallback;\n        regs[a] = mrb_ary_entry(va, mrb_integer(vb));\n        break;\n      case MRB_TT_HASH:\n        regs[a] = mrb_hash_get(mrb, va, vb);\n        break;\n      case MRB_TT_STRING:\n        switch (mrb_type(vb)) {\n        case MRB_TT_INTEGER:\n        case MRB_TT_STRING:\n        case MRB_TT_RANGE:\n          regs[a] = mrb_str_aref(mrb, va, vb, mrb_undef_value());\n          break;\n        default:\n          goto getidx_fallback;\n        }\n        break;\n      default:\n      getidx_fallback:\n        c = 1;\n        mid = MRB_OPSYM(aref);\n        goto L_SEND_SYM;\n      }\n      NEXT;\n    }\n\n    CASE(OP_SETIDX, B) {\n      c = 2;\n      mid = MRB_OPSYM(aset);\n      goto L_SEND_SYM;\n    }\n\n    CASE(OP_GETCONST, BB) {\n      mrb_value val;\n      mrb_sym sym = syms[b];\n\n      val = mrb_vm_const_get(mrb, sym);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETCONST, BB) {\n      mrb_vm_const_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETMCNST, BB) {\n      mrb_value val;\n\n      val = mrb_const_get(mrb, regs[a], syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETMCNST, BB) {\n      mrb_const_set(mrb, regs[a+1], syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETUPVAR, BBB) {\n      mrb_value *regs_a = regs + a;\n      struct REnv *e = uvenv(mrb, c);\n\n      if (e && b < MRB_ENV_LEN(e)) {\n        *regs_a = e->stack[b];\n      }\n      else {\n        *regs_a = mrb_nil_value();\n      }\n      NEXT;\n    }\n\n    CASE(OP_SETUPVAR, BBB) {\n      struct REnv *e = uvenv(mrb, c);\n\n      if (e) {\n        mrb_value *regs_a = regs + a;\n\n        if (b < MRB_ENV_LEN(e)) {\n          e->stack[b] = *regs_a;\n          mrb_write_barrier(mrb, (struct RBasic*)e);\n        }\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMP, S) {\n      pc += (int16_t)a;\n      JUMP;\n    }\n    CASE(OP_JMPIF, BS) {\n      if (mrb_test(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n    CASE(OP_JMPNOT, BS) {\n      if (!mrb_test(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n    CASE(OP_JMPNIL, BS) {\n      if (mrb_nil_p(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMPUW, S) {\n      a = (uint32_t)((pc - irep->iseq) + (int16_t)a);\n      CHECKPOINT_RESTORE(RBREAK_TAG_JUMP) {\n        struct RBreak *brk = (struct RBreak*)mrb->exc;\n        mrb_value target = mrb_break_value_get(brk);\n        mrb_assert(mrb_integer_p(target));\n        a = (uint32_t)mrb_integer(target);\n        mrb_assert(a >= 0 && a < irep->ilen);\n      }\n      CHECKPOINT_MAIN(RBREAK_TAG_JUMP) {\n        ch = catch_handler_find(mrb, mrb->c->ci, pc, MRB_CATCH_FILTER_ENSURE);\n        if (ch) {\n          /* avoiding a jump from a catch handler into the same handler */\n          if (a < mrb_irep_catch_handler_unpack(ch->begin) || a >= mrb_irep_catch_handler_unpack(ch->end)) {\n            THROW_TAGGED_BREAK(mrb, RBREAK_TAG_JUMP, proc, mrb_fixnum_value(a));\n          }\n        }\n      }\n      CHECKPOINT_END(RBREAK_TAG_JUMP);\n\n      mrb->exc = NULL; /* clear break object */\n      pc = irep->iseq + a;\n      JUMP;\n    }\n\n    CASE(OP_EXCEPT, B) {\n      mrb_value exc;\n\n      if (mrb->exc == NULL) {\n        exc = mrb_nil_value();\n      }\n      else {\n        switch (mrb->exc->tt) {\n        case MRB_TT_BREAK:\n        case MRB_TT_EXCEPTION:\n          exc = mrb_obj_value(mrb->exc);\n          break;\n        default:\n          mrb_assert(!\"bad mrb_type\");\n          exc = mrb_nil_value();\n          break;\n        }\n        mrb->exc = NULL;\n      }\n      regs[a] = exc;\n      NEXT;\n    }\n    CASE(OP_RESCUE, BB) {\n      mrb_value exc = regs[a];  /* exc on stack */\n      mrb_value e = regs[b];\n      struct RClass *ec;\n\n      switch (mrb_type(e)) {\n      case MRB_TT_CLASS:\n      case MRB_TT_MODULE:\n        break;\n      default:\n        {\n          mrb_value exc;\n\n          exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR,\n                                    \"class or module required for rescue clause\");\n          mrb_exc_set(mrb, exc);\n          goto L_RAISE;\n        }\n      }\n      ec = mrb_class_ptr(e);\n      regs[b] = mrb_bool_value(mrb_obj_is_kind_of(mrb, exc, ec));\n      NEXT;\n    }\n\n    CASE(OP_RAISEIF, B) {\n      mrb_value exc = regs[a];\n      if (mrb_break_p(exc)) {\n        mrb->exc = mrb_obj_ptr(exc);\n        goto L_BREAK;\n      }\n      mrb_exc_set(mrb, exc);\n      if (mrb->exc) {\n        goto L_RAISE;\n      }\n      NEXT;\n    }\n\n    CASE(OP_SEND, BBB)\n    goto L_SENDB;\n\n    L_SEND_SYM:\n    c = 1;\n    /* push nil after arguments */\n    SET_NIL_VALUE(regs[a+2]);\n    goto L_SENDB_SYM;\n\n    CASE(OP_SENDB, BBB)\n    L_SENDB:\n    mid = syms[b];\n    L_SENDB_SYM:\n    {\n      int n = c&0xf;\n      int nk = (c>>4)&0xf;\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_int bidx = a + ((n == 15) ? 1 : n) + ((nk == 15) ? 1 : 2*nk) + 1;\n      mrb_method_t m;\n      struct RClass *cls;\n      mrb_value recv;\n\n      if (0 < nk && nk < 15) {  /* pack keyword arguments */\n        mrb_int kidx = a+n+1;\n        mrb_value kdict = hash_new_from_values(mrb, nk, regs+kidx);\n        regs[kidx] = kdict;\n        nk = 15;\n        c = n | (nk<<4);\n      }\n\n      mrb_assert(bidx < irep->nregs+a);\n      mrb_value blk = mrb_nil_value();\n      mrb_int new_bidx = a+((n==15)?1:n)+1+(nk==15);\n      if (insn == OP_SEND) {\n        /* clear block argument */\n        SET_NIL_VALUE(regs[new_bidx]);\n      }\n      else {\n        blk = regs[bidx];\n        if (!mrb_nil_p(blk) && !mrb_proc_p(blk)) {\n          blk = mrb_type_convert(mrb, blk, MRB_TT_PROC, MRB_SYM(to_proc));\n          /* The stack might have been reallocated during mrb_type_convert(),\n             see #3622 */\n        }\n        regs[new_bidx] = blk;\n      }\n\n      recv = regs[a];\n      cls = mrb_class(mrb, recv);\n      m = mrb_method_search_vm(mrb, &cls, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        m = prepare_missing(mrb, recv, mid, &cls, a, &c, blk, 0);\n        mid = MRB_SYM(method_missing);\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb, a, 0, cls, NULL, mid, c);\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        if (MRB_METHOD_PROC_P(m)) {\n          struct RProc *p = MRB_METHOD_PROC(m);\n\n          mrb_vm_ci_proc_set(ci, p);\n          recv = p->body.func(mrb, recv);\n        }\n        else if (MRB_METHOD_NOARG_P(m) &&\n                 !(n == 0 || (n == CALL_MAXARGS && RARRAY_LEN(regs[1]) == 0))) {\n          argnum_error(mrb, 0);\n          goto L_RAISE;\n        }\n        else {\n          recv = MRB_METHOD_FUNC(m)(mrb, recv);\n        }\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        if (mrb_proc_p(blk)) {\n          struct RProc *p = mrb_proc_ptr(blk);\n          if (p && !MRB_PROC_STRICT_P(p) && MRB_PROC_ENV(p) == mrb_vm_ci_env(&ci[-1])) {\n            p->flags |= MRB_PROC_ORPHAN;\n          }\n        }\n        if (!ci->u.target_class) { /* return from context modifying method (resume/yield) */\n          if (ci->cci == CINFO_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return recv;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        ci->stack[0] = recv;\n        /* pop stackpos */\n        ci = cipop(mrb);\n        pc = ci->pc;\n      }\n      else {\n        /* setup environment for calling method */\n        mrb_vm_ci_proc_set(ci, (proc = MRB_METHOD_PROC(m)));\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, (irep->nregs < 4) ? 4 : irep->nregs);\n        pc = irep->iseq;\n      }\n    }\n    JUMP;\n\n    CASE(OP_CALL, Z) {\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv = ci->stack[0];\n      struct RProc *m = mrb_proc_ptr(recv);\n\n      /* replace callinfo */\n      ci->u.target_class = MRB_PROC_TARGET_CLASS(m);\n      mrb_vm_ci_proc_set(ci, m);\n      if (MRB_PROC_ENV_P(m)) {\n        ci->mid = MRB_PROC_ENV(m)->mid;\n      }\n\n      /* prepare stack */\n      if (MRB_PROC_CFUNC_P(m)) {\n        recv = MRB_PROC_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        /* pop stackpos */\n        ci = cipop(mrb);\n        pc = ci->pc;\n        ci[1].stack[0] = recv;\n        irep = mrb->c->ci->proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        JUMP;\n      }\n      else {\n        /* setup environment for calling method */\n        proc = m;\n        irep = m->body.irep;\n        if (!irep) {\n          mrb->c->ci->stack[0] = mrb_nil_value();\n          a = 0;\n          c = OP_R_NORMAL;\n          goto L_OP_RETURN_BODY;\n        }\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_int nargs = mrb_ci_bidx(ci)+1;\n        if (nargs < irep->nregs) {\n          mrb_stack_extend(mrb, irep->nregs);\n          stack_clear(regs+nargs, irep->nregs-nargs);\n        }\n        if (MRB_PROC_ENV_P(m)) {\n          regs[0] = MRB_PROC_ENV(m)->stack[0];\n        }\n        pc = irep->iseq;\n        JUMP;\n      }\n    }\n\n    CASE(OP_SUPER, BB) {\n      mrb_method_t m;\n      struct RClass *cls;\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_int bidx = mrb_bidx(b)+a;\n      mrb_value recv, blk;\n      const struct RProc *p = ci->proc;\n      mrb_sym mid = ci->mid;\n      struct RClass* target_class = MRB_PROC_TARGET_CLASS(p);\n\n      if (MRB_PROC_ENV_P(p) && p->e.env->mid && p->e.env->mid != mid) { /* alias support */\n        mid = p->e.env->mid;    /* restore old mid */\n      }\n      mrb_assert(bidx < irep->nregs);\n\n      if (mid == 0 || !target_class) {\n        mrb_value exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (target_class->flags & MRB_FL_CLASS_IS_PREPENDED) {\n        target_class = mrb_vm_ci_target_class(ci);\n      }\n      else if (target_class->tt == MRB_TT_MODULE) {\n        target_class = mrb_vm_ci_target_class(ci);\n        if (target_class->tt != MRB_TT_ICLASS) {\n          goto super_typeerror;\n        }\n      }\n      recv = regs[0];\n      if (!mrb_obj_is_kind_of(mrb, recv, target_class)) {\n      super_typeerror: ;\n        mrb_value exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR,\n                                            \"self has wrong type to call super in this context\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      blk = regs[bidx];\n      if (!mrb_nil_p(blk) && !mrb_proc_p(blk)) {\n        blk = mrb_type_convert(mrb, blk, MRB_TT_PROC, MRB_SYM(to_proc));\n        /* The stack or ci stack might have been reallocated during\n           mrb_type_convert(), see #3622 and #3784 */\n        regs[bidx] = blk;\n        ci = mrb->c->ci;\n      }\n      cls = target_class->super;\n      m = mrb_method_search_vm(mrb, &cls, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        m = prepare_missing(mrb, recv, mid, &cls, a, &b, blk, 1);\n        mid = MRB_SYM(method_missing);\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb, a, 0, cls, NULL, mid, b);\n\n      /* prepare stack */\n      ci->stack[0] = recv;\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        mrb_value v;\n\n        if (MRB_METHOD_PROC_P(m)) {\n          mrb_vm_ci_proc_set(ci, MRB_METHOD_PROC(m));\n        }\n        v = MRB_METHOD_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_restore(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        mrb_assert(!mrb_break_p(v));\n        if (!mrb_vm_ci_target_class(ci)) { /* return from context modifying method (resume/yield) */\n          if (ci->cci == CINFO_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return v;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        mrb->c->ci->stack[0] = v;\n        ci = cipop(mrb);\n        pc = ci->pc;\n        JUMP;\n      }\n      else {\n        /* setup environment for calling method */\n        mrb_vm_ci_proc_set(ci, (proc = MRB_METHOD_PROC(m)));\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, (irep->nregs < 4) ? 4 : irep->nregs);\n        pc = irep->iseq;\n        JUMP;\n      }\n    }\n\n    CASE(OP_ARGARY, BS) {\n      mrb_int m1 = (b>>11)&0x3f;\n      mrb_int r  = (b>>10)&0x1;\n      mrb_int m2 = (b>>5)&0x1f;\n      mrb_int kd = (b>>4)&0x1;\n      mrb_int lv = (b>>0)&0xf;\n      mrb_value *stack;\n\n      if (mrb->c->ci->mid == 0 || mrb_vm_ci_target_class(mrb->c->ci) == NULL) {\n        mrb_value exc;\n\n      L_NOSUPER:\n        exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (lv == 0) stack = regs + 1;\n      else {\n        struct REnv *e = uvenv(mrb, lv-1);\n        if (!e) goto L_NOSUPER;\n        if (MRB_ENV_LEN(e) <= m1+r+m2+1)\n          goto L_NOSUPER;\n        stack = e->stack + 1;\n      }\n      if (r == 0) {\n        regs[a] = mrb_ary_new_from_values(mrb, m1+m2, stack);\n      }\n      else {\n        mrb_value *pp = NULL;\n        struct RArray *rest;\n        mrb_int len = 0;\n\n        if (mrb_array_p(stack[m1])) {\n          struct RArray *ary = mrb_ary_ptr(stack[m1]);\n\n          pp = ARY_PTR(ary);\n          len = ARY_LEN(ary);\n        }\n        regs[a] = mrb_ary_new_capa(mrb, m1+len+m2);\n        rest = mrb_ary_ptr(regs[a]);\n        if (m1 > 0) {\n          stack_copy(ARY_PTR(rest), stack, m1);\n        }\n        if (len > 0) {\n          stack_copy(ARY_PTR(rest)+m1, pp, len);\n        }\n        if (m2 > 0) {\n          stack_copy(ARY_PTR(rest)+m1+len, stack+m1+1, m2);\n        }\n        ARY_SET_LEN(rest, m1+len+m2);\n      }\n      if (kd) {\n        regs[a+1] = stack[m1+r+m2];\n        regs[a+2] = stack[m1+r+m2+1];\n      }\n      else {\n        regs[a+1] = stack[m1+r+m2];\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ENTER, W) {\n      mrb_int m1 = MRB_ASPEC_REQ(a);\n      mrb_int o  = MRB_ASPEC_OPT(a);\n      mrb_int r  = MRB_ASPEC_REST(a);\n      mrb_int m2 = MRB_ASPEC_POST(a);\n      mrb_int kd = (MRB_ASPEC_KEY(a) > 0 || MRB_ASPEC_KDICT(a))? 1 : 0;\n      /* unused\n      int b  = MRB_ASPEC_BLOCK(a);\n      */\n      mrb_int const len = m1 + o + r + m2;\n\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_int argc = ci->n;\n      mrb_value *argv = regs+1;\n      mrb_value * const argv0 = argv;\n      mrb_int const kw_pos = len + kd;    /* where kwhash should be */\n      mrb_int const blk_pos = kw_pos + 1; /* where block should be */\n      mrb_value blk = regs[mrb_ci_bidx(ci)];\n      mrb_value kdict = mrb_nil_value();\n\n      /* keyword arguments */\n      if (ci->nk > 0) {\n        mrb_int kidx = mrb_ci_kidx(ci);\n        kdict = regs[kidx];\n        if (!mrb_hash_p(kdict) || mrb_hash_size(mrb, kdict) == 0) {\n          kdict = mrb_nil_value();\n          ci->nk = 0;\n        }\n      }\n      if (!kd && !mrb_nil_p(kdict)) {\n        if (argc < 14) {\n          ci->n++;\n          argc++;    /* include kdict in normal arguments */\n        }\n        else if (argc == 14) {\n          /* pack arguments and kdict */\n          regs[1] = mrb_ary_new_from_values(mrb, argc+1, &regs[1]);\n          argc = ci->n = 15;\n        }\n        else {/* argc == 15 */\n          /* push kdict to packed arguments */\n          mrb_ary_push(mrb, regs[1], regs[2]);\n        }\n        ci->nk = 0;\n      }\n      if (kd && MRB_ASPEC_KEY(a) > 0 && mrb_hash_p(kdict)) {\n        kdict = mrb_hash_dup(mrb, kdict);\n      }\n\n      /* arguments is passed with Array */\n      if (argc == 15) {\n        struct RArray *ary = mrb_ary_ptr(regs[1]);\n        argv = ARY_PTR(ary);\n        argc = (int)ARY_LEN(ary);\n        mrb_gc_protect(mrb, regs[1]);\n      }\n\n      /* strict argument check */\n      if (ci->proc && MRB_PROC_STRICT_P(ci->proc)) {\n        if (argc < m1 + m2 || (r == 0 && argc > len)) {\n          argnum_error(mrb, m1+m2);\n          goto L_RAISE;\n        }\n      }\n      /* extract first argument array to arguments */\n      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {\n        mrb_gc_protect(mrb, argv[0]);\n        argc = (int)RARRAY_LEN(argv[0]);\n        argv = RARRAY_PTR(argv[0]);\n      }\n\n      /* rest arguments */\n      mrb_value rest = mrb_nil_value();\n      if (argc < len) {\n        mrb_int mlen = m2;\n        if (argc < m1+m2) {\n          mlen = m1 < argc ? argc - m1 : 0;\n        }\n\n        /* copy mandatory and optional arguments */\n        if (argv0 != argv && argv) {\n          value_move(&regs[1], argv, argc-mlen); /* m1 + o */\n        }\n        if (argc < m1) {\n          stack_clear(&regs[argc+1], m1-argc);\n        }\n        /* copy post mandatory arguments */\n        if (mlen) {\n          value_move(&regs[len-m2+1], &argv[argc-mlen], mlen);\n        }\n        if (mlen < m2) {\n          stack_clear(&regs[len-m2+mlen+1], m2-mlen);\n        }\n        /* initialize rest arguments with empty Array */\n        if (r) {\n          rest = mrb_ary_new_capa(mrb, 0);\n          regs[m1+o+1] = rest;\n        }\n        /* skip initializer of passed arguments */\n        if (o > 0 && argc > m1+m2)\n          pc += (argc - m1 - m2)*3;\n      }\n      else {\n        mrb_int rnum = 0;\n        if (argv0 != argv) {\n          value_move(&regs[1], argv, m1+o);\n        }\n        if (r) {\n          rnum = argc-m1-o-m2;\n          rest = mrb_ary_new_from_values(mrb, rnum, argv+m1+o);\n          regs[m1+o+1] = rest;\n        }\n        if (m2 > 0 && argc-m2 > m1) {\n          value_move(&regs[m1+o+r+1], &argv[m1+o+rnum], m2);\n        }\n        pc += o*3;\n      }\n\n      /* need to be update blk first to protect blk from GC */\n      regs[blk_pos] = blk;              /* move block */\n      if (kd) {\n        if (mrb_nil_p(kdict))\n          kdict = mrb_hash_new_capa(mrb, 0);\n        regs[kw_pos] = kdict;           /* set kwhash */\n      }\n\n      /* format arguments for generated code */\n      mrb->c->ci->n = len;\n\n      /* clear local (but non-argument) variables */\n      if (irep->nlocals-blk_pos-1 > 0) {\n        stack_clear(&regs[blk_pos+1], irep->nlocals-blk_pos-1);\n      }\n      JUMP;\n    }\n\n    CASE(OP_KARG, BB) {\n      mrb_value k = mrb_symbol_value(syms[b]);\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict;\n\n      if (kidx < 0 || !mrb_hash_p(kdict=regs[kidx]) || !mrb_hash_key_p(mrb, kdict, k)) {\n        mrb_value str = mrb_format(mrb, \"missing keyword: %v\", k);\n        mrb_exc_set(mrb, mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str));\n        goto L_RAISE;\n      }\n      regs[a] = mrb_hash_get(mrb, kdict, k);\n      mrb_hash_delete_key(mrb, kdict, k);\n      NEXT;\n    }\n\n    CASE(OP_KEY_P, BB) {\n      mrb_value k = mrb_symbol_value(syms[b]);\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict;\n      mrb_bool key_p = FALSE;\n\n      if (kidx >= 0 && mrb_hash_p(kdict=regs[kidx])) {\n        key_p = mrb_hash_key_p(mrb, kdict, k);\n      }\n      regs[a] = mrb_bool_value(key_p);\n      NEXT;\n    }\n\n    CASE(OP_KEYEND, Z) {\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict;\n\n      if (kidx >= 0 && mrb_hash_p(kdict=regs[kidx]) && !mrb_hash_empty_p(mrb, kdict)) {\n        mrb_value keys = mrb_hash_keys(mrb, kdict);\n        mrb_value key1 = RARRAY_PTR(keys)[0];\n        mrb_value str = mrb_format(mrb, \"unknown keyword: %v\", key1);\n        mrb_exc_set(mrb, mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str));\n        goto L_RAISE;\n      }\n      NEXT;\n    }\n\n    CASE(OP_BREAK, B) {\n      c = OP_R_BREAK;\n      goto L_RETURN;\n    }\n    CASE(OP_RETURN_BLK, B) {\n      c = OP_R_RETURN;\n      goto L_RETURN;\n    }\n    CASE(OP_RETURN, B)\n    c = OP_R_NORMAL;\n    L_RETURN:\n    {\n      mrb_callinfo *ci;\n\n      ci = mrb->c->ci;\n      if (ci->mid) {\n        mrb_value blk = regs[mrb_ci_bidx(ci)];\n\n        if (mrb_proc_p(blk)) {\n          struct RProc *p = mrb_proc_ptr(blk);\n\n          if (!MRB_PROC_STRICT_P(p) &&\n              ci > mrb->c->cibase && MRB_PROC_ENV(p) == mrb_vm_ci_env(&ci[-1])) {\n            p->flags |= MRB_PROC_ORPHAN;\n          }\n        }\n      }\n\n      if (mrb->exc) {\n      L_RAISE:\n        ci = mrb->c->ci;\n        if (ci == mrb->c->cibase) {\n          ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL);\n          if (ch == NULL) goto L_FTOP;\n          goto L_CATCH;\n        }\n        while ((ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL)) == NULL) {\n          ci = cipop(mrb);\n          if (ci[1].cci == CINFO_SKIP && prev_jmp) {\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          pc = ci[0].pc;\n          if (ci == mrb->c->cibase) {\n            ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL);\n            if (ch == NULL) {\n            L_FTOP:             /* fiber top */\n              if (mrb->c == mrb->root_c) {\n                mrb->c->ci->stack = mrb->c->stbase;\n                goto L_STOP;\n              }\n              else {\n                struct mrb_context *c = mrb->c;\n\n                c->status = MRB_FIBER_TERMINATED;\n                mrb->c = c->prev;\n                c->prev = NULL;\n                goto L_RAISE;\n              }\n            }\n            break;\n          }\n        }\n      L_CATCH:\n        if (ch == NULL) goto L_STOP;\n        if (FALSE) {\n        L_CATCH_TAGGED_BREAK: /* from THROW_TAGGED_BREAK() or UNWIND_ENSURE() */\n          ci = mrb->c->ci;\n        }\n        proc = ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, irep->nregs);\n        pc = irep->iseq + mrb_irep_catch_handler_unpack(ch->target);\n      }\n      else {\n        mrb_int acc;\n        mrb_value v;\n\n        ci = mrb->c->ci;\n        v = regs[a];\n        mrb_gc_protect(mrb, v);\n        switch (c) {\n        case OP_R_RETURN:\n          /* Fall through to OP_R_NORMAL otherwise */\n          if (ci->cci == CINFO_NONE && MRB_PROC_ENV_P(proc) && !MRB_PROC_STRICT_P(proc)) {\n            const struct RProc *dst;\n            mrb_callinfo *cibase;\n            cibase = mrb->c->cibase;\n            dst = top_proc(mrb, proc);\n\n            if (MRB_PROC_ENV_P(dst)) {\n              struct REnv *e = MRB_PROC_ENV(dst);\n\n              if (!MRB_ENV_ONSTACK_P(e) || (e->cxt && e->cxt != mrb->c)) {\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n            }\n            /* check jump destination */\n            while (cibase <= ci && ci->proc != dst) {\n              if (ci->cci > CINFO_NONE) { /* jump cross C boundary */\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n              ci--;\n            }\n            if (ci <= cibase) { /* no jump destination */\n              localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n              goto L_RAISE;\n            }\n            ci = mrb->c->ci;\n            while (cibase <= ci && ci->proc != dst) {\n              CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_BLOCK) {\n                cibase = mrb->c->cibase;\n                dst = top_proc(mrb, proc);\n              }\n              CHECKPOINT_MAIN(RBREAK_TAG_RETURN_BLOCK) {\n                UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN_BLOCK, proc, v);\n              }\n              CHECKPOINT_END(RBREAK_TAG_RETURN_BLOCK);\n              ci = cipop(mrb);\n              pc = ci->pc;\n            }\n            proc = ci->proc;\n            mrb->exc = NULL; /* clear break object */\n            break;\n          }\n          /* fallthrough */\n        case OP_R_NORMAL:\n        NORMAL_RETURN:\n          if (ci == mrb->c->cibase) {\n            struct mrb_context *c;\n            c = mrb->c;\n\n            if (!c->prev) { /* toplevel return */\n              regs[irep->nlocals] = v;\n              goto CHECKPOINT_LABEL_MAKE(RBREAK_TAG_STOP);\n            }\n            if (!c->vmexec && c->prev->ci == c->prev->cibase) {\n              mrb_value exc = mrb_exc_new_lit(mrb, E_FIBER_ERROR, \"double resume\");\n              mrb_exc_set(mrb, exc);\n              goto L_RAISE;\n            }\n            CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_TOPLEVEL) {\n              c = mrb->c;\n            }\n            CHECKPOINT_MAIN(RBREAK_TAG_RETURN_TOPLEVEL) {\n              UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN_TOPLEVEL, proc, v);\n            }\n            CHECKPOINT_END(RBREAK_TAG_RETURN_TOPLEVEL);\n            /* automatic yield at the end */\n            c->status = MRB_FIBER_TERMINATED;\n            mrb->c = c->prev;\n            mrb->c->status = MRB_FIBER_RUNNING;\n            c->prev = NULL;\n            if (c->vmexec) {\n              mrb_gc_arena_restore(mrb, ai);\n              c->vmexec = FALSE;\n              mrb->jmp = prev_jmp;\n              return v;\n            }\n            ci = mrb->c->ci;\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_RETURN) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_RETURN) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_RETURN);\n          mrb->exc = NULL; /* clear break object */\n          break;\n        case OP_R_BREAK:\n          if (MRB_PROC_STRICT_P(proc)) goto NORMAL_RETURN;\n          if (MRB_PROC_ORPHAN_P(proc)) {\n            mrb_value exc;\n\n          L_BREAK_ERROR:\n            exc = mrb_exc_new_lit(mrb, E_LOCALJUMP_ERROR,\n                                      \"break from proc-closure\");\n            mrb_exc_set(mrb, exc);\n            goto L_RAISE;\n          }\n          if (!MRB_PROC_ENV_P(proc) || !MRB_ENV_ONSTACK_P(MRB_PROC_ENV(proc))) {\n            goto L_BREAK_ERROR;\n          }\n          else {\n            struct REnv *e = MRB_PROC_ENV(proc);\n\n            if (e->cxt != mrb->c) {\n              goto L_BREAK_ERROR;\n            }\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_BREAK) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_BREAK) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_BREAK);\n          /* break from fiber block */\n          if (ci == mrb->c->cibase && ci->pc) {\n            struct mrb_context *c = mrb->c;\n\n            mrb->c = c->prev;\n            c->prev = NULL;\n            ci = mrb->c->ci;\n          }\n          if (ci->cci > CINFO_NONE) {\n            ci = cipop(mrb);\n            mrb_gc_arena_restore(mrb, ai);\n            mrb->c->vmexec = FALSE;\n            mrb->exc = (struct RObject*)break_new(mrb, RBREAK_TAG_BREAK, proc, v);\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          if (FALSE) {\n            struct RBreak *brk;\n\n          L_BREAK:\n            brk = (struct RBreak*)mrb->exc;\n            proc = mrb_break_proc_get(brk);\n            v = mrb_break_value_get(brk);\n            ci = mrb->c->ci;\n\n            switch (mrb_break_tag_get(brk)) {\n#define DISPATCH_CHECKPOINTS(n, i) case n: goto CHECKPOINT_LABEL_MAKE(n);\n              RBREAK_TAG_FOREACH(DISPATCH_CHECKPOINTS)\n#undef DISPATCH_CHECKPOINTS\n              default:\n                mrb_assert(!\"wrong break tag\");\n            }\n          }\n          while (mrb->c->cibase < ci && ci[-1].proc != proc->upper) {\n            if (ci[-1].cci == CINFO_SKIP) {\n              goto L_BREAK_ERROR;\n            }\n            CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_UPPER) {\n              /* do nothing */\n            }\n            CHECKPOINT_MAIN(RBREAK_TAG_BREAK_UPPER) {\n              UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK_UPPER, proc, v);\n            }\n            CHECKPOINT_END(RBREAK_TAG_BREAK_UPPER);\n            ci = cipop(mrb);\n            pc = ci->pc;\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_INTARGET) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_BREAK_INTARGET) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK_INTARGET, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_BREAK_INTARGET);\n          if (ci == mrb->c->cibase) {\n            goto L_BREAK_ERROR;\n          }\n          mrb->exc = NULL; /* clear break object */\n          break;\n        default:\n          /* cannot happen */\n          break;\n        }\n        mrb_assert(ci == mrb->c->ci);\n        mrb_assert(mrb->exc == NULL);\n\n        if (mrb->c->vmexec && !mrb_vm_ci_target_class(ci)) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->c->vmexec = FALSE;\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        acc = ci->cci;\n        ci = cipop(mrb);\n        if (acc == CINFO_SKIP || acc == CINFO_DIRECT) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        pc = ci->pc;\n        DEBUG(fprintf(stderr, \"from :%s\\n\", mrb_sym_name(mrb, ci->mid)));\n        proc = ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n\n        ci[1].stack[0] = v;\n        mrb_gc_arena_restore(mrb, ai);\n      }\n      JUMP;\n    }\n\nMRB_API mrb_value\nmrb_vm_run(mrb_state *mrb, const struct RProc *proc, mrb_value self, mrb_int stack_keep)\n{\n  const mrb_irep *irep = proc->body.irep;\n  mrb_value result;\n  struct mrb_context *c = mrb->c;\n  ptrdiff_t cioff = c->ci - c->cibase;\n  mrb_int nregs = irep->nregs;\n\n  if (!c->stbase) {\n    stack_init(mrb);\n  }\n  if (stack_keep > nregs)\n    nregs = stack_keep;\n  mrb_stack_extend(mrb, nregs);\n  stack_clear(c->ci->stack + stack_keep, nregs - stack_keep);\n  c->ci->stack[0] = self;\n  result = mrb_vm_exec(mrb, proc, irep->iseq);\n  if (mrb->c != c) {\n    if (mrb->c->fib) {\n      mrb_write_barrier(mrb, (struct RBasic*)mrb->c->fib);\n    }\n    mrb->c = c;\n  }\n  else if (c->ci - c->cibase > cioff) {\n    c->ci = c->cibase + cioff;\n  }\n  return result;\n}\n\n\n// target function\nMRB_API mrb_value\nmrb_funcall_with_block(mrb_state *mrb, mrb_value self, mrb_sym mid, mrb_int argc, const mrb_value *argv, mrb_value blk)\n{\n  mrb_value val;\n  int ai = mrb_gc_arena_save(mrb);\n\n  if (!mrb->jmp) {\n    struct mrb_jmpbuf c_jmp;\n    ptrdiff_t nth_ci = mrb->c->ci - mrb->c->cibase;\n\n    MRB_TRY(&c_jmp) {\n      mrb->jmp = &c_jmp;\n      /* recursive call */\n      val = mrb_funcall_with_block(mrb, self, mid, argc, argv, blk);\n      mrb->jmp = 0;\n    }\n    MRB_CATCH(&c_jmp) { /* error */\n      while (nth_ci < (mrb->c->ci - mrb->c->cibase)) {\n        cipop(mrb);\n      }\n      mrb->jmp = 0;\n      val = mrb_obj_value(mrb->exc);\n    }\n    MRB_END_EXC(&c_jmp);\n    mrb->jmp = 0;\n  }\n  else {\n    mrb_method_t m;\n    struct RClass *c;\n    mrb_callinfo *ci = mrb->c->ci;\n    mrb_int n = mrb_ci_nregs(ci);\n    ptrdiff_t voff = -1;\n\n    if (!mrb->c->stbase) {\n      stack_init(mrb);\n    }\n    if (ci - mrb->c->cibase > MRB_CALL_LEVEL_MAX) {\n      mrb_exc_raise(mrb, mrb_obj_value(mrb->stack_err));\n    }\n    if (mrb->c->stbase <= argv && argv < mrb->c->stend) {\n      voff = argv - mrb->c->stbase;\n    }\n    if (argc < 0) {\n      mrb_raisef(mrb, E_ARGUMENT_ERROR, \"negative argc for funcall (%i)\", argc);\n    }\n    c = mrb_class(mrb, self);\n    m = mrb_method_search_vm(mrb, &c, mid);\n    mrb_stack_extend(mrb, argc + 3);\n    if (MRB_METHOD_UNDEF_P(m) || argc >= 15) {\n      mrb_value args = mrb_ary_new_from_values(mrb, argc, argv);\n\n      ci->stack[n+1] = args;\n      argc = 15;\n    }\n    if (MRB_METHOD_UNDEF_P(m)) {\n      mrb_sym missing = MRB_SYM(method_missing);\n      mrb_value args = ci->stack[n+1];\n\n      m = mrb_method_search_vm(mrb, &c, missing);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        mrb_method_missing(mrb, mid, self, args);\n      }\n      mrb_ary_unshift(mrb, args, mrb_symbol_value(mid));\n      mrb_stack_extend(mrb, n+2);\n      ci->stack[n+1] = args;\n      argc = 15;\n    }\n    ci = cipush(mrb, n, 0, c, NULL, mid, argc);\n    if (MRB_METHOD_PROC_P(m)) {\n      struct RProc *p = MRB_METHOD_PROC(m);\n\n      mrb_vm_ci_proc_set(ci, p);\n      if (!MRB_PROC_CFUNC_P(p)) {\n        mrb_stack_extend(mrb, p->body.irep->nregs + argc);\n      }\n    }\n    if (voff >= 0) {\n      argv = mrb->c->stbase + voff;\n    }\n    ci->stack[0] = self;\n    if (argc < 15) {\n      if (argc > 0)\n        stack_copy(ci->stack+1, argv, argc);\n      ci->stack[argc+1] = blk;\n    }\n    else {\n      ci->stack[2] = blk;\n    }\n\n    if (MRB_METHOD_CFUNC_P(m)) {\n      ci->cci = CINFO_DIRECT;\n      val = MRB_METHOD_CFUNC(m)(mrb, self);\n      cipop(mrb);\n    }\n    else {\n      ci->cci = CINFO_SKIP;\n      val = mrb_run(mrb, MRB_METHOD_PROC(m), self);\n    }\n  }\n  mrb_gc_arena_restore(mrb, ai);\n  mrb_gc_protect(mrb, val);\n  return val;\n}\n",
    "target": 1,
    "idx": 1039940,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic int fuzz_reader_transmit(sc_reader_t *reader, sc_apdu_t *apdu)\n{\n    const uint8_t *chunk;\n    uint16_t chunk_size;\n\n    fuzz_get_chunk(reader, &chunk, &chunk_size);\n\n    if (chunk_size >= 2) {\n        /* set the SW1 and SW2 status bytes (the last two bytes of\n         * the response */\n        apdu->sw1 = (unsigned int)chunk[chunk_size - 2];\n        apdu->sw2 = (unsigned int)chunk[chunk_size - 1];\n        chunk_size -= 2;\n        /* set output length and copy the returned data if necessary */\n        if (chunk_size <= apdu->resplen)\n            apdu->resplen = chunk_size;\n\n        if (apdu->resplen != 0)\n            memcpy(apdu->resp, chunk, apdu->resplen);\n    } else {\n        apdu->sw1 = 0x6D;\n        apdu->sw2 = 0x00;\n        apdu->resplen = 0;\n    }\n\n    return SC_SUCCESS;\n}\n\nstatic int\nsc_single_transmit(struct sc_card *card, struct sc_apdu *apdu)\n{\n\tstruct sc_context *ctx  = card->ctx;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (card->reader->ops->transmit == NULL)\n\t\tLOG_TEST_RET(card->ctx, SC_ERROR_NOT_SUPPORTED, \"cannot transmit APDU\");\n\n\tsc_log(ctx,\n\t       \"CLA:%X, INS:%X, P1:%X, P2:%X, data(%\"SC_FORMAT_LEN_SIZE_T\"u) %p\",\n\t       apdu->cla, apdu->ins, apdu->p1, apdu->p2, apdu->datalen,\n\t       apdu->data);\n#ifdef ENABLE_SM\n\tif (card->sm_ctx.sm_mode == SM_MODE_TRANSMIT\n\t\t   \t&& (apdu->flags & SC_APDU_FLAGS_NO_SM) == 0) {\n\t\tLOG_FUNC_RETURN(ctx, sc_sm_single_transmit(card, apdu));\n\t}\n#endif\n\n\t/* send APDU to the reader driver */\n\trv = card->reader->ops->transmit(card->reader, apdu);\n\tLOG_TEST_RET(ctx, rv, \"unable to transmit APDU\");\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\nstatic int\nsc_transmit(sc_card_t *card, sc_apdu_t *apdu)\n{\n\tstruct sc_context *ctx  = card->ctx;\n\tsize_t       olen  = apdu->resplen;\n\tint          r;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tr = sc_single_transmit(card, apdu);\n\tLOG_TEST_RET(ctx, r, \"transmit APDU failed\");\n\n\t/* ok, the APDU was successfully transmitted. Now we have two special cases:\n\t * 1. the card returned 0x6Cxx: in this case APDU will be re-transmitted with Le set to SW2\n\t * (possible only if response buffer size is larger than new Le = SW2)\n\t */\n\tif (apdu->sw1 == 0x6C && (apdu->flags & SC_APDU_FLAGS_NO_RETRY_WL) == 0)\n\t\tr = sc_set_le_and_transmit(card, apdu, olen);\n\tLOG_TEST_RET(ctx, r, \"cannot re-transmit APDU \");\n\n\t/* 2. the card returned 0x61xx: more data can be read from the card\n\t *    using the GET RESPONSE command (mostly used in the T0 protocol).\n\t *    Unless the SC_APDU_FLAGS_NO_GET_RESP is set we try to read as\n\t *    much data as possible using GET RESPONSE.\n\t */\n\tif (apdu->sw1 == 0x61 && (apdu->flags & SC_APDU_FLAGS_NO_GET_RESP) == 0)\n\t\tr = sc_get_response(card, apdu, olen);\n\tLOG_TEST_RET(ctx, r, \"cannot get all data with 'GET RESPONSE'\");\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n\nint sc_transmit_apdu(sc_card_t *card, sc_apdu_t *apdu)\n{\n\tint r = SC_SUCCESS;\n\n\tif (card == NULL || apdu == NULL)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\t/* determine the APDU type if necessary, i.e. to use\n\t * short or extended APDUs  */\n\tsc_detect_apdu_cse(card, apdu);\n\t/* basic APDU consistency check */\n\tr = sc_check_apdu(card, apdu);\n\tif (r != SC_SUCCESS)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\tr = sc_lock(card);\t/* acquire card lock*/\n\tif (r != SC_SUCCESS) {\n\t\tsc_log(card->ctx, \"unable to acquire lock\");\n\t\treturn r;\n\t}\n\n\tif ((apdu->flags & SC_APDU_FLAGS_CHAINING) != 0) {\n\t\t/* divide et impera: transmit APDU in chunks with Lc <= max_send_size\n\t\t * bytes using command chaining */\n\t\tsize_t    len  = apdu->datalen;\n\t\tconst u8  *buf = apdu->data;\n\t\tsize_t    max_send_size = sc_get_max_send_size(card);\n\n\t\twhile (len != 0) {\n\t\t\tsize_t    plen;\n\t\t\tsc_apdu_t tapdu;\n\t\t\tint       last = 0;\n\n\t\t\ttapdu = *apdu;\n\t\t\t/* clear chaining flag */\n\t\t\ttapdu.flags &= ~SC_APDU_FLAGS_CHAINING;\n\t\t\tif (len > max_send_size) {\n\t\t\t\t/* adjust APDU case: in case of CASE 4 APDU\n\t\t\t\t * the intermediate APDU are of CASE 3 */\n\t\t\t\tif ((tapdu.cse & SC_APDU_SHORT_MASK) == SC_APDU_CASE_4_SHORT)\n\t\t\t\t\ttapdu.cse--;\n\t\t\t\t/* XXX: the chunk size must be adjusted when\n\t\t\t\t *      secure messaging is used */\n\t\t\t\tplen          = max_send_size;\n\t\t\t\ttapdu.cla    |= 0x10;\n\t\t\t\ttapdu.le      = 0;\n\t\t\t\t/* the intermediate APDU don't expect data */\n\t\t\t\ttapdu.lc      = 0;\n\t\t\t\ttapdu.resplen = 0;\n\t\t\t\ttapdu.resp    = NULL;\n\t\t\t} else {\n\t\t\t\tplen = len;\n\t\t\t\tlast = 1;\n\t\t\t}\n\t\t\ttapdu.data    = buf;\n\t\t\ttapdu.datalen = tapdu.lc = plen;\n\n\t\t\tr = sc_check_apdu(card, &tapdu);\n\t\t\tif (r != SC_SUCCESS) {\n\t\t\t\tsc_log(card->ctx, \"inconsistent APDU while chaining\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tr = sc_transmit(card, &tapdu);\n\t\t\tif (r != SC_SUCCESS)\n\t\t\t\tbreak;\n\t\t\tif (last != 0) {\n\t\t\t\t/* in case of the last APDU set the SW1\n\t\t\t\t * and SW2 bytes in the original APDU */\n\t\t\t\tapdu->sw1 = tapdu.sw1;\n\t\t\t\tapdu->sw2 = tapdu.sw2;\n\t\t\t\tapdu->resplen = tapdu.resplen;\n\t\t\t} else {\n\t\t\t\t/* otherwise check the status bytes */\n\t\t\t\tr = sc_check_sw(card, tapdu.sw1, tapdu.sw2);\n\t\t\t\tif (r != SC_SUCCESS)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlen -= plen;\n\t\t\tbuf += plen;\n\t\t}\n\t} else {\n\t\t/* transmit single APDU */\n\t\tr = sc_transmit(card, apdu);\n\t}\n\n\tif (r == SC_ERROR_CARD_RESET || r == SC_ERROR_READER_REATTACHED) {\n\t\tsc_invalidate_cache(card);\n\t\t/* give card driver a chance to react on resets */\n\t\tif (card->ops->card_reader_lock_obtained)\n\t\t\tcard->ops->card_reader_lock_obtained(card, 1);\n\t}\n\n\t/* all done => release lock */\n\tif (sc_unlock(card) != SC_SUCCESS)\n\t\tsc_log(card->ctx, \"sc_unlock failed\");\n\n\treturn r;\n}\n\nstatic int\niso7816_read_binary(struct sc_card *card, unsigned int idx, u8 *buf, size_t count, unsigned long flags)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_apdu apdu;\n\tint r;\n\n\tif (idx > 0x7FFF) {\n\t\tsc_log(ctx, \"invalid EF offset: 0x%X > 0x7FFF\", idx);\n\t\treturn SC_ERROR_OFFSET_TOO_LARGE;\n\t}\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_2, 0xB0, (idx >> 8) & 0x7F, idx & 0xFF);\n\tapdu.le = count;\n\tapdu.resplen = count;\n\tapdu.resp = buf;\n\n\tfixup_transceive_length(card, &apdu);\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(ctx, r, \"APDU transmit failed\");\n\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tif (r == SC_ERROR_FILE_END_REACHED)\n\t\tLOG_FUNC_RETURN(ctx, apdu.resplen);\n\tLOG_TEST_RET(ctx, r, \"Check SW error\");\n\n\tLOG_FUNC_RETURN(ctx, apdu.resplen);\n}\n\nstatic int idprime_read_binary(sc_card_t *card, unsigned int offset,\n\tunsigned char *buf, size_t count, unsigned long flags)\n{\n\tstruct idprime_private_data *priv = card->drv_data;\n\tint r = 0;\n\tint size;\n\n\tsc_log(card->ctx, \"called; %\"SC_FORMAT_LEN_SIZE_T\"u bytes at offset %d\",\n\t\tcount, offset);\n\n\tif (!priv->cached && offset == 0) {\n\t\t/* Read what was reported by FCI from select command */\n\t\tint left = priv->file_size;\n\t\tsize_t read = 0;\n\n\t\t// this function is called to read and uncompress the certificate\n\t\tu8 buffer[SC_MAX_EXT_APDU_BUFFER_SIZE];\n\t\tif (sizeof(buffer) < count || sizeof(buffer) < priv->file_size) {\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INTERNAL);\n\t\t}\n\t\twhile (left > 0) {\n\t\t\tr = iso_ops->read_binary(card, read, buffer + read, priv->file_size - read, flags);\n\t\t\tif (r <= 0) {\n\t\t\t\tLOG_FUNC_RETURN(card->ctx, r);\n\t\t\t}\n\t\t\tleft -= r;\n\t\t\tread += r;\n\t\t}\n\t\tif (read < 4 || read != priv->file_size) {\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_DATA);\n\t\t}\n\t\tif (buffer[0] == 1 && buffer[1] == 0) {\n#ifdef ENABLE_ZLIB\n\t\t\tsize_t expectedsize = buffer[2] + buffer[3] * 0x100;\n\t\t\tr = sc_decompress_alloc(&priv->cache_buf, &(priv->cache_buf_len),\n\t\t\t\tbuffer+4, priv->file_size-4, COMPRESSION_AUTO);\n\t\t\tif (r != SC_SUCCESS) {\n\t\t\t\tsc_log(card->ctx, \"Zlib error: %d\", r);\n\t\t\t\tLOG_FUNC_RETURN(card->ctx, r);\n\t\t\t}\n\t\t\tif (priv->cache_buf_len != expectedsize) {\n\t\t\t\tsc_log(card->ctx,\n\t\t\t\t\t \"expected size: %\"SC_FORMAT_LEN_SIZE_T\"u real size: %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t\t\t\t expectedsize, priv->cache_buf_len);\n\t\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_DATA);\n\t\t\t}\n#else\n\t\t\tsc_log(card->ctx, \"compression not supported, no zlib\");\n\t\t\treturn SC_ERROR_NOT_SUPPORTED;\n#endif /* ENABLE_ZLIB */\n\t\t} else {\n\t\t\t/* assuming uncompressed certificate */\n\t\t\tpriv->cache_buf = malloc(r);\n\t\t\tif (priv->cache_buf == NULL) {\n\t\t\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t\t\t}\n\t\t\tmemcpy(priv->cache_buf, buffer, r);\n\t\t\tpriv->cache_buf_len = r;\n\t\t}\n\t\tpriv->cached = 1;\n\t}\n\tif (offset >= priv->cache_buf_len) {\n\t\treturn 0;\n\t}\n\tsize = (int) MIN((priv->cache_buf_len - offset), count);\n\tmemcpy(buf, priv->cache_buf + offset, size);\n\treturn size;\n}\n\nint sc_read_binary(sc_card_t *card, unsigned int idx,\n\t\t   unsigned char *buf, size_t count, unsigned long flags)\n{\n\tsize_t max_le = sc_get_max_recv_size(card);\n\tsize_t todo = count;\n\tint r;\n\n\tif (card == NULL || card->ops == NULL || buf == NULL) {\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\tsc_log(card->ctx, \"called; %\"SC_FORMAT_LEN_SIZE_T\"u bytes at index %d\",\n\t       count, idx);\n\tif (count == 0)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n\n#ifdef ENABLE_SM\n\tif (card->sm_ctx.ops.read_binary)   {\n\t\tr = card->sm_ctx.ops.read_binary(card, idx, buf, count);\n\t\tif (r)\n\t\t\tLOG_FUNC_RETURN(card->ctx, r);\n\t}\n#endif\n\n\tif (card->ops->read_binary == NULL)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_NOT_SUPPORTED);\n\n\t/* lock the card now to avoid deselection of the file */\n\tr = sc_lock(card);\n\tLOG_TEST_RET(card->ctx, r, \"sc_lock() failed\");\n\n\twhile (todo > 0) {\n\t\tsize_t chunk = todo > max_le ? max_le : todo;\n\n\t\tr = card->ops->read_binary(card, idx, buf, chunk, flags);\n\t\tif (r == 0 || r == SC_ERROR_FILE_END_REACHED)\n\t\t\tbreak;\n\t\tif ((idx > SIZE_MAX - (size_t) r)\n\t\t\t\t|| (size_t) r > todo) {\n\t\t\t/* `idx + r` or `todo - r` would overflow */\n\t\t\tr = SC_ERROR_OFFSET_TOO_LARGE;\n\t\t}\n\t\tif (r < 0) {\n\t\t\tsc_unlock(card);\n\t\t\tLOG_FUNC_RETURN(card->ctx, r);\n\t\t}\n\n\t\ttodo -= (size_t) r;\n\t\tbuf  += (size_t) r;\n\t\tidx  += (size_t) r;\n\t}\n\n\tsc_unlock(card);\n\n\tLOG_FUNC_RETURN(card->ctx, count - todo);\n}\n\nint\nsc_pkcs15_bind(struct sc_card *card, struct sc_aid *aid,\n\t\tstruct sc_pkcs15_card **p15card_out)\n{\n\tstruct sc_pkcs15_card *p15card = NULL;\n\tstruct sc_context *ctx;\n\tscconf_block *conf_block = NULL;\n\tint r, emu_first, enable_emu;\n\tconst char *private_certificate;\n\n\tif (card == NULL || p15card_out == NULL) {\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\tctx = card->ctx;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"application(aid:'%s')\", aid ? sc_dump_hex(aid->value, aid->len) : \"empty\");\n\n\tp15card = sc_pkcs15_card_new();\n\tif (p15card == NULL)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY);\n\n\tp15card->card = card;\n\tp15card->opts.use_file_cache = 0;\n\tp15card->opts.use_pin_cache = 1;\n\tp15card->opts.pin_cache_counter = 10;\n\tp15card->opts.pin_cache_ignore_user_consent = 0;\n\tif(0 == strcmp(ctx->app_name, \"tokend\")) {\n\t\tprivate_certificate = \"ignore\";\n\t\tp15card->opts.private_certificate = SC_PKCS15_CARD_OPTS_PRIV_CERT_IGNORE;\n\t} else {\n\t\tprivate_certificate = \"protect\";\n\t\tp15card->opts.private_certificate = SC_PKCS15_CARD_OPTS_PRIV_CERT_PROTECT;\n\t}\n\n\tconf_block = sc_get_conf_block(ctx, \"framework\", \"pkcs15\", 1);\n\tif (conf_block) {\n\t\tp15card->opts.use_file_cache = scconf_get_bool(conf_block, \"use_file_caching\", p15card->opts.use_file_cache);\n\t\tp15card->opts.use_pin_cache = scconf_get_bool(conf_block, \"use_pin_caching\", p15card->opts.use_pin_cache);\n\t\tp15card->opts.pin_cache_counter = scconf_get_int(conf_block, \"pin_cache_counter\", p15card->opts.pin_cache_counter);\n\t\tp15card->opts.pin_cache_ignore_user_consent = scconf_get_bool(conf_block, \"pin_cache_ignore_user_consent\",\n\t\t\t\tp15card->opts.pin_cache_ignore_user_consent);\n\t\tprivate_certificate = scconf_get_str(conf_block, \"private_certificate\", private_certificate);\n\t}\n\tif (0 == strcmp(private_certificate, \"protect\")) {\n\t\tp15card->opts.private_certificate = SC_PKCS15_CARD_OPTS_PRIV_CERT_PROTECT;\n\t} else if (0 == strcmp(private_certificate, \"ignore\")) {\n\t\tp15card->opts.private_certificate = SC_PKCS15_CARD_OPTS_PRIV_CERT_IGNORE;\n\t} else if (0 == strcmp(private_certificate, \"declassify\")) {\n\t\tp15card->opts.private_certificate = SC_PKCS15_CARD_OPTS_PRIV_CERT_DECLASSIFY;\n\t}\n\tsc_log(ctx, \"PKCS#15 options: use_file_cache=%d use_pin_cache=%d pin_cache_counter=%d pin_cache_ignore_user_consent=%d private_certificate=%d\",\n\t\t\tp15card->opts.use_file_cache, p15card->opts.use_pin_cache,p15card->opts.pin_cache_counter,\n\t\t\tp15card->opts.pin_cache_ignore_user_consent, p15card->opts.private_certificate);\n\n\tr = sc_lock(card);\n\tif (r) {\n\t\tsc_log(ctx, \"sc_lock() failed: %s\", sc_strerror(r));\n\t\tsc_pkcs15_card_free(p15card);\n\t\tLOG_FUNC_RETURN(ctx, r);\n\t}\n\n\tenable_emu = scconf_get_bool(conf_block, \"enable_pkcs15_emulation\", 1);\n\tif (enable_emu) {\n\t\tsc_log(ctx, \"PKCS#15 emulation enabled\");\n\t\temu_first = scconf_get_bool(conf_block, \"try_emulation_first\", 0);\n\t\tif (emu_first || sc_pkcs15_is_emulation_only(card)) {\n\t\t\tr = sc_pkcs15_bind_synthetic(p15card, aid);\n\t\t\tif (r == SC_SUCCESS)\n\t\t\t\tgoto done;\n\t\t\tr = sc_pkcs15_bind_internal(p15card, aid);\n\t\t\tif (r < 0)\n\t\t\t\tgoto error;\n\t\t} else {\n\t\t\tr = sc_pkcs15_bind_internal(p15card, aid);\n\t\t\tif (r == SC_SUCCESS)\n\t\t\t\tgoto done;\n\t\t\tr = sc_pkcs15_bind_synthetic(p15card, aid);\n\t\t\tif (r < 0)\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\telse {\n\t\tr = sc_pkcs15_bind_internal(p15card, aid);\n\t\tif (r < 0)\n\t\t\tgoto error;\n\t}\ndone:\n\t*p15card_out = p15card;\n\tsc_unlock(card);\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\nerror:\n\tsc_unlock(card);\n\tsc_pkcs15_card_free(p15card);\n\tLOG_FUNC_RETURN(ctx, r);\n}\n\nint\nsc_pkcs15_bind(struct sc_card *card, struct sc_aid *aid,\n\t\tstruct sc_pkcs15_card **p15card_out)\n{\n\tstruct sc_pkcs15_card *p15card = NULL;\n\tstruct sc_context *ctx;\n\tscconf_block *conf_block = NULL;\n\tint r, emu_first, enable_emu;\n\tconst char *private_certificate;\n\n\tif (card == NULL || p15card_out == NULL) {\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\tctx = card->ctx;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"application(aid:'%s')\", aid ? sc_dump_hex(aid->value, aid->len) : \"empty\");\n\n\tp15card = sc_pkcs15_card_new();\n\tif (p15card == NULL)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY);\n\n\tp15card->card = card;\n\tp15card->opts.use_file_cache = 0;\n\tp15card->opts.use_pin_cache = 1;\n\tp15card->opts.pin_cache_counter = 10;\n\tp15card->opts.pin_cache_ignore_user_consent = 0;\n\tif(0 == strcmp(ctx->app_name, \"tokend\")) {\n\t\tprivate_certificate = \"ignore\";\n\t\tp15card->opts.private_certificate = SC_PKCS15_CARD_OPTS_PRIV_CERT_IGNORE;\n\t} else {\n\t\tprivate_certificate = \"protect\";\n\t\tp15card->opts.private_certificate = SC_PKCS15_CARD_OPTS_PRIV_CERT_PROTECT;\n\t}\n\n\tconf_block = sc_get_conf_block(ctx, \"framework\", \"pkcs15\", 1);\n\tif (conf_block) {\n\t\tp15card->opts.use_file_cache = scconf_get_bool(conf_block, \"use_file_caching\", p15card->opts.use_file_cache);\n\t\tp15card->opts.use_pin_cache = scconf_get_bool(conf_block, \"use_pin_caching\", p15card->opts.use_pin_cache);\n\t\tp15card->opts.pin_cache_counter = scconf_get_int(conf_block, \"pin_cache_counter\", p15card->opts.pin_cache_counter);\n\t\tp15card->opts.pin_cache_ignore_user_consent = scconf_get_bool(conf_block, \"pin_cache_ignore_user_consent\",\n\t\t\t\tp15card->opts.pin_cache_ignore_user_consent);\n\t\tprivate_certificate = scconf_get_str(conf_block, \"private_certificate\", private_certificate);\n\t}\n\tif (0 == strcmp(private_certificate, \"protect\")) {\n\t\tp15card->opts.private_certificate = SC_PKCS15_CARD_OPTS_PRIV_CERT_PROTECT;\n\t} else if (0 == strcmp(private_certificate, \"ignore\")) {\n\t\tp15card->opts.private_certificate = SC_PKCS15_CARD_OPTS_PRIV_CERT_IGNORE;\n\t} else if (0 == strcmp(private_certificate, \"declassify\")) {\n\t\tp15card->opts.private_certificate = SC_PKCS15_CARD_OPTS_PRIV_CERT_DECLASSIFY;\n\t}\n\tsc_log(ctx, \"PKCS#15 options: use_file_cache=%d use_pin_cache=%d pin_cache_counter=%d pin_cache_ignore_user_consent=%d private_certificate=%d\",\n\t\t\tp15card->opts.use_file_cache, p15card->opts.use_pin_cache,p15card->opts.pin_cache_counter,\n\t\t\tp15card->opts.pin_cache_ignore_user_consent, p15card->opts.private_certificate);\n\n\tr = sc_lock(card);\n\tif (r) {\n\t\tsc_log(ctx, \"sc_lock() failed: %s\", sc_strerror(r));\n\t\tsc_pkcs15_card_free(p15card);\n\t\tLOG_FUNC_RETURN(ctx, r);\n\t}\n\n\tenable_emu = scconf_get_bool(conf_block, \"enable_pkcs15_emulation\", 1);\n\tif (enable_emu) {\n\t\tsc_log(ctx, \"PKCS#15 emulation enabled\");\n\t\temu_first = scconf_get_bool(conf_block, \"try_emulation_first\", 0);\n\t\tif (emu_first || sc_pkcs15_is_emulation_only(card)) {\n\t\t\tr = sc_pkcs15_bind_synthetic(p15card, aid);\n\t\t\tif (r == SC_SUCCESS)\n\t\t\t\tgoto done;\n\t\t\tr = sc_pkcs15_bind_internal(p15card, aid);\n\t\t\tif (r < 0)\n\t\t\t\tgoto error;\n\t\t} else {\n\t\t\tr = sc_pkcs15_bind_internal(p15card, aid);\n\t\t\tif (r == SC_SUCCESS)\n\t\t\t\tgoto done;\n\t\t\tr = sc_pkcs15_bind_synthetic(p15card, aid);\n\t\t\tif (r < 0)\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\telse {\n\t\tr = sc_pkcs15_bind_internal(p15card, aid);\n\t\tif (r < 0)\n\t\t\tgoto error;\n\t}\ndone:\n\t*p15card_out = p15card;\n\tsc_unlock(card);\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\nerror:\n\tsc_unlock(card);\n\tsc_pkcs15_card_free(p15card);\n\tLOG_FUNC_RETURN(ctx, r);\n}\n\n\n// target function\nstatic int idprime_read_binary(sc_card_t *card, unsigned int offset,\n\tunsigned char *buf, size_t count, unsigned long flags)\n{\n\tstruct idprime_private_data *priv = card->drv_data;\n\tint r = 0;\n\tint size;\n\n\tsc_log(card->ctx, \"called; %\"SC_FORMAT_LEN_SIZE_T\"u bytes at offset %d\",\n\t\tcount, offset);\n\n\tif (!priv->cached && offset == 0) {\n\t\t/* Read what was reported by FCI from select command */\n\t\tint left = priv->file_size;\n\t\tsize_t read = 0;\n\n\t\t// this function is called to read and uncompress the certificate\n\t\tu8 buffer[SC_MAX_EXT_APDU_BUFFER_SIZE];\n\t\tif (sizeof(buffer) < count) {\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INTERNAL);\n\t\t}\n\t\twhile (left > 0) {\n\t\t\tr = iso_ops->read_binary(card, read, buffer + read, priv->file_size - read, flags);\n\t\t\tif (r <= 0) {\n\t\t\t\tLOG_FUNC_RETURN(card->ctx, r);\n\t\t\t}\n\t\t\tleft -= r;\n\t\t\tread += r;\n\t\t}\n\t\tif (read < 4 || read != priv->file_size) {\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_DATA);\n\t\t}\n\t\tif (buffer[0] == 1 && buffer[1] == 0) {\n#ifdef ENABLE_ZLIB\n\t\t\tsize_t expectedsize = buffer[2] + buffer[3] * 0x100;\n\t\t\tr = sc_decompress_alloc(&priv->cache_buf, &(priv->cache_buf_len),\n\t\t\t\tbuffer+4, priv->file_size-4, COMPRESSION_AUTO);\n\t\t\tif (r != SC_SUCCESS) {\n\t\t\t\tsc_log(card->ctx, \"Zlib error: %d\", r);\n\t\t\t\tLOG_FUNC_RETURN(card->ctx, r);\n\t\t\t}\n\t\t\tif (priv->cache_buf_len != expectedsize) {\n\t\t\t\tsc_log(card->ctx,\n\t\t\t\t\t \"expected size: %\"SC_FORMAT_LEN_SIZE_T\"u real size: %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t\t\t\t expectedsize, priv->cache_buf_len);\n\t\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_DATA);\n\t\t\t}\n#else\n\t\t\tsc_log(card->ctx, \"compression not supported, no zlib\");\n\t\t\treturn SC_ERROR_NOT_SUPPORTED;\n#endif /* ENABLE_ZLIB */\n\t\t} else {\n\t\t\t/* assuming uncompressed certificate */\n\t\t\tpriv->cache_buf = malloc(r);\n\t\t\tif (priv->cache_buf == NULL) {\n\t\t\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t\t\t}\n\t\t\tmemcpy(priv->cache_buf, buffer, r);\n\t\t\tpriv->cache_buf_len = r;\n\t\t}\n\t\tpriv->cached = 1;\n\t}\n\tif (offset >= priv->cache_buf_len) {\n\t\treturn 0;\n\t}\n\tsize = (int) MIN((priv->cache_buf_len - offset), count);\n\tmemcpy(buf, priv->cache_buf + offset, size);\n\treturn size;\n}\n",
    "target": 1,
    "idx": 1026103,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\n  void Finish() {\n    // Store current byte if we didn't went go bitmap storage\n    if (length_ > 0 && (bit_mask_ != 0x01 || position_ < length_)) {\n      bitmap_[byte_offset_] = current_byte_;\n    }\n  }\n\nvoid DefLevelsToBitmap(const int16_t* def_levels, int64_t num_def_levels,\n                       LevelInfo level_info, ValidityBitmapInputOutput* output) {\n  // It is simpler to rely on rep_level here until PARQUET-1899 is done and the code\n  // is deleted in a follow-up release.\n  if (level_info.rep_level > 0) {\n#if defined(ARROW_HAVE_RUNTIME_BMI2)\n    if (CpuInfo::GetInstance()->HasEfficientBmi2()) {\n      return DefLevelsToBitmapBmi2WithRepeatedParent(def_levels, num_def_levels,\n                                                     level_info, output);\n    }\n#endif\n    standard::DefLevelsToBitmapSimd</*has_repeated_parent=*/true>(\n        def_levels, num_def_levels, level_info, output);\n  } else {\n    standard::DefLevelsToBitmapSimd</*has_repeated_parent=*/false>(\n        def_levels, num_def_levels, level_info, output);\n  }\n}\n\nvoid DefRepLevelsToBitmap(const int16_t* def_levels, const int16_t* rep_levels,\n                          int64_t num_def_levels, LevelInfo level_info,\n                          ValidityBitmapInputOutput* output) {\n  // DefReplevelsToListInfo assumes it for the actual list method and this\n  // method is for parent structs, so we need to bump def and ref level.\n  level_info.rep_level += 1;\n  level_info.def_level += 1;\n  DefRepLevelsToListInfo<int32_t>(def_levels, rep_levels, num_def_levels, level_info,\n                                  output, /*offsets=*/nullptr);\n}\n\n  END_PARQUET_CATCH_EXCEPTIONS\n  // Gather children arrays and def levels\n  for (auto& child : children_) {\n    std::shared_ptr<ChunkedArray> field;\n    RETURN_NOT_OK(child->BuildArray(validity_io.values_read, &field));\n    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<ArrayData> array_data, ChunksToSingle(*field));\n    children_array_data.push_back(std::move(array_data));\n  }\n\n  END_PARQUET_CATCH_EXCEPTIONS\n  // Gather children arrays and def levels\n  for (auto& child : children_) {\n    std::shared_ptr<ChunkedArray> field;\n    RETURN_NOT_OK(child->BuildArray(validity_io.values_read, &field));\n    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<ArrayData> array_data, ChunksToSingle(*field));\n    children_array_data.push_back(std::move(array_data));\n  }\n\n  END_PARQUET_CATCH_EXCEPTIONS\n  // Gather children arrays and def levels\n  for (auto& child : children_) {\n    std::shared_ptr<ChunkedArray> field;\n    RETURN_NOT_OK(child->BuildArray(validity_io.values_read, &field));\n    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<ArrayData> array_data, ChunksToSingle(*field));\n    children_array_data.push_back(std::move(array_data));\n  }\n\n  ::arrow::Status NextBatch(int64_t batch_size,\n                            std::shared_ptr<::arrow::ChunkedArray>* out) final {\n    RETURN_NOT_OK(LoadBatch(batch_size));\n    RETURN_NOT_OK(BuildArray(batch_size, out));\n    for (int x = 0; x < (*out)->num_chunks(); x++) {\n      RETURN_NOT_OK((*out)->chunk(x)->Validate());\n    }\n    return Status::OK();\n  }\n\n  END_PARQUET_CATCH_EXCEPTIONS\n  // Gather children arrays and def levels\n  for (auto& child : children_) {\n    std::shared_ptr<ChunkedArray> field;\n    RETURN_NOT_OK(child->BuildArray(validity_io.values_read, &field));\n    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<ArrayData> array_data, ChunksToSingle(*field));\n    children_array_data.push_back(std::move(array_data));\n  }\n\n\n\nStatus OptionalParallelFor(bool use_threads, int num_tasks, FUNCTION&& func) {\n  if (use_threads) {\n    return ParallelFor(num_tasks, std::forward<FUNCTION>(func));\n  } else {\n    for (int i = 0; i < num_tasks; ++i) {\n      RETURN_NOT_OK(func(i));\n    }\n    return Status::OK();\n  }\n}\n\n  END_PARQUET_CATCH_EXCEPTIONS\n  // Gather children arrays and def levels\n  for (auto& child : children_) {\n    std::shared_ptr<ChunkedArray> field;\n    RETURN_NOT_OK(child->BuildArray(validity_io.values_read, &field));\n    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<ArrayData> array_data, ChunksToSingle(*field));\n    children_array_data.push_back(std::move(array_data));\n  }\n\n  END_PARQUET_CATCH_EXCEPTIONS\n  // Gather children arrays and def levels\n  for (auto& child : children_) {\n    std::shared_ptr<ChunkedArray> field;\n    RETURN_NOT_OK(child->BuildArray(validity_io.values_read, &field));\n    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<ArrayData> array_data, ChunksToSingle(*field));\n    children_array_data.push_back(std::move(array_data));\n  }\n\n  END_PARQUET_CATCH_EXCEPTIONS\n  // Gather children arrays and def levels\n  for (auto& child : children_) {\n    std::shared_ptr<ChunkedArray> field;\n    RETURN_NOT_OK(child->BuildArray(validity_io.values_read, &field));\n    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<ArrayData> array_data, ChunksToSingle(*field));\n    children_array_data.push_back(std::move(array_data));\n  }\n\nStatus FuzzReader(const uint8_t* data, int64_t size) {\n  auto buffer = std::make_shared<::arrow::Buffer>(data, size);\n  auto file = std::make_shared<::arrow::io::BufferReader>(buffer);\n  FileReaderBuilder builder;\n  RETURN_NOT_OK(builder.Open(std::move(file)));\n\n  std::unique_ptr<FileReader> reader;\n  RETURN_NOT_OK(builder.Build(&reader));\n  return FuzzReader(std::move(reader));\n}\n\nStatus FuzzReader(const uint8_t* data, int64_t size) {\n  auto buffer = std::make_shared<::arrow::Buffer>(data, size);\n  auto file = std::make_shared<::arrow::io::BufferReader>(buffer);\n  FileReaderBuilder builder;\n  RETURN_NOT_OK(builder.Open(std::move(file)));\n\n  std::unique_ptr<FileReader> reader;\n  RETURN_NOT_OK(builder.Build(&reader));\n  return FuzzReader(std::move(reader));\n}\n\n\n// target function\nvoid DefRepLevelsToListInfo(const int16_t* def_levels, const int16_t* rep_levels,\n                            int64_t num_def_levels, LevelInfo level_info,\n                            ValidityBitmapInputOutput* output, OffsetType* offsets) {\n  OffsetType* orig_pos = offsets;\n  std::unique_ptr<::arrow::internal::FirstTimeBitmapWriter> valid_bits_writer;\n  if (output->valid_bits) {\n    valid_bits_writer.reset(new ::arrow::internal::FirstTimeBitmapWriter(\n        output->valid_bits, output->valid_bits_offset, num_def_levels));\n  }\n  for (int x = 0; x < num_def_levels; x++) {\n    // Skip items that belong to empty or null ancestor lists and further nested lists.\n    if (def_levels[x] < level_info.repeated_ancestor_def_level ||\n        rep_levels[x] > level_info.rep_level) {\n      continue;\n    }\n\n    if (rep_levels[x] == level_info.rep_level) {\n      // A continuation of an existing list.\n      // offsets can be null for structs with repeated children (we don't need to know\n      // offsets until we get to the children).\n      if (offsets != nullptr) {\n        if (ARROW_PREDICT_FALSE(*offsets == std::numeric_limits<OffsetType>::max())) {\n          throw ParquetException(\"List index overflow.\");\n        }\n        *offsets += 1;\n      }\n    } else {\n      if (ARROW_PREDICT_FALSE(\n              (valid_bits_writer != nullptr &&\n               valid_bits_writer->position() >= output->values_read_upper_bound) ||\n              (offsets - orig_pos) >= output->values_read_upper_bound)) {\n        std::stringstream ss;\n        ss << \"Definition levels exceeded upper bound: \"\n           << output->values_read_upper_bound;\n        throw ParquetException(ss.str());\n      }\n\n      // current_rep < list rep_level i.e. start of a list (ancestor empty lists are\n      // filtered out above).\n      // offsets can be null for structs with repeated children (we don't need to know\n      // offsets until we get to the children).\n      if (offsets != nullptr) {\n        ++offsets;\n        // Use cumulative offsets because variable size lists are more common then\n        // fixed size lists so it should be cheaper to make these cumulative and\n        // subtract when validating fixed size lists.\n        *offsets = *(offsets - 1);\n        if (def_levels[x] >= level_info.def_level) {\n          if (ARROW_PREDICT_FALSE(*offsets == std::numeric_limits<OffsetType>::max())) {\n            throw ParquetException(\"List index overflow.\");\n          }\n          *offsets += 1;\n        }\n      }\n\n      if (valid_bits_writer != nullptr) {\n        // the level_info def level for lists reflects element present level.\n        // the prior level distinguishes between empty lists.\n        if (def_levels[x] >= level_info.def_level - 1) {\n          valid_bits_writer->Set();\n        } else {\n          output->null_count++;\n          valid_bits_writer->Clear();\n        }\n        valid_bits_writer->Next();\n      }\n    }\n  }\n  if (valid_bits_writer != nullptr) {\n    valid_bits_writer->Finish();\n  }\n  if (offsets != nullptr) {\n    output->values_read = offsets - orig_pos;\n  } else if (valid_bits_writer != nullptr) {\n    output->values_read = valid_bits_writer->position();\n  }\n  if (output->null_count > 0 && level_info.null_slot_usage > 1) {\n    throw ParquetException(\n        \"Null values with null_slot_usage > 1 not supported.\"\n        \"(i.e. FixedSizeLists with null values are not supported)\");\n  }\n}\n",
    "target": 1,
    "idx": 1026829,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nint\nsc_pkcs15init_rmdir(struct sc_pkcs15_card *p15card, struct sc_profile *profile,\n\t\tstruct sc_file *df)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tunsigned char buffer[1024];\n\tstruct sc_path\tpath;\n\tstruct sc_file\t*file, *parent;\n\tint\t\tr = 0, nfids;\n\n\tif (df == NULL)\n\t\treturn SC_ERROR_INTERNAL;\n\tsc_log(ctx, \"sc_pkcs15init_rmdir(%s)\", sc_print_path(&df->path));\n\n\tif (df->type == SC_FILE_TYPE_DF) {\n\t\tr = sc_pkcs15init_authenticate(profile, p15card, df, SC_AC_OP_LIST_FILES);\n\t\tif (r < 0)\n\t\t\treturn r;\n\t\tr = sc_list_files(p15card->card, buffer, sizeof(buffer));\n\t\tif (r < 0)\n\t\t\treturn r;\n\n\t\tpath = df->path;\n\t\tpath.len += 2;\n\t\tif (path.len > SC_MAX_PATH_SIZE)\n\t\t\treturn SC_ERROR_INTERNAL;\n\n\t\tnfids = r / 2;\n\t\twhile (r >= 0 && nfids--) {\n\t\t\tpath.value[path.len-2] = buffer[2*nfids];\n\t\t\tpath.value[path.len-1] = buffer[2*nfids+1];\n\t\t\tr = sc_select_file(p15card->card, &path, &file);\n\t\t\tif (r < 0) {\n\t\t\t\tif (r == SC_ERROR_FILE_NOT_FOUND)\n\t\t\t\t\tcontinue;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr = sc_pkcs15init_rmdir(p15card, profile, file);\n\t\t\tsc_file_free(file);\n\t\t}\n\n\t\tif (r < 0)\n\t\t\treturn r;\n\t}\n\n\t/* Select the parent DF */\n\tpath = df->path;\n\tpath.len -= 2;\n\tr = sc_select_file(p15card->card, &path, &parent);\n\tif (r < 0)\n\t\treturn r;\n\n\tr = sc_pkcs15init_authenticate(profile, p15card, df, SC_AC_OP_DELETE);\n\tif (r < 0) {\n\t\tsc_file_free(parent);\n\t\treturn r;\n\t}\n\tr = sc_pkcs15init_authenticate(profile, p15card, parent, SC_AC_OP_DELETE);\n\tsc_file_free(parent);\n\tif (r < 0)\n\t\treturn r;\n\n\tmemset(&path, 0, sizeof(path));\n\tpath.type = SC_PATH_TYPE_FILE_ID;\n\tpath.value[0] = df->id >> 8;\n\tpath.value[1] = df->id & 0xFF;\n\tpath.len = 2;\n\n\t/* ensure that the card is in the correct lifecycle */\n\tr = sc_pkcs15init_set_lifecycle(p15card->card, SC_CARDCTRL_LIFECYCLE_ADMIN);\n\tif (r < 0 && r != SC_ERROR_NOT_SUPPORTED)\n\t\treturn r;\n\n\tr = sc_delete_file(p15card->card, &path);\n\treturn r;\n}\n\nint\nsc_pkcs15init_erase_card_recursively(struct sc_pkcs15_card *p15card,\n\t\tstruct sc_profile *profile)\n{\n\tstruct sc_file\t*df = profile->df_info->file, *dir;\n\tint\t\tr;\n\n\t/* Delete EF(DIR). This may not be very nice\n\t * against other applications that use this file, but\n\t * extremely useful for testing :)\n\t * Note we need to delete it before the DF because we create\n\t * it *after* the DF. Some cards (e.g. the cryptoflex) want\n\t * us to delete files in reverse order of creation.\n\t * */\n\tif (sc_profile_get_file(profile, \"DIR\", &dir) >= 0) {\n\t\tr = sc_pkcs15init_rmdir(p15card, profile, dir);\n\t\tsc_file_free(dir);\n\t\tif (r < 0 && r != SC_ERROR_FILE_NOT_FOUND)   {\n\t\t\tsc_free_apps(p15card->card);\n\t\t\treturn r;\n\t\t}\n\t}\n\n\tr = sc_select_file(p15card->card, &df->path, &df);\n\tif (r >= 0) {\n\t\tr = sc_pkcs15init_rmdir(p15card, profile, df);\n\t\tsc_file_free(df);\n\t}\n\tif (r == SC_ERROR_FILE_NOT_FOUND)\n\t\tr = 0;\n\n\tsc_free_apps(p15card->card);\n\treturn r;\n}\n\nstatic int\ncardos_erase(struct sc_profile *profile, sc_pkcs15_card_t *p15card)\n{\n\treturn sc_pkcs15init_erase_card_recursively(p15card, profile);\n}\n\nint\nsc_pkcs15init_erase_card(struct sc_pkcs15_card *p15card, struct sc_profile *profile,\n\t\tstruct sc_aid *aid)\n{\n\tstruct sc_context *ctx = NULL;\n\tint rv;\n\n\tif (!p15card)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\tctx = p15card->card->ctx;\n\tLOG_FUNC_CALLED(ctx);\n\t/* Needs the 'SOPIN' AUTH pkcs15 object.\n\t * So that, SOPIN can be found by it's reference. */\n\tif (sc_pkcs15_bind(p15card->card, aid, &p15card) >= 0)\n\t\tprofile->p15_data = p15card;\n\n\tif (profile->ops->erase_card == NULL)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_NOT_SUPPORTED);\n\n\trv = profile->ops->erase_card(profile, p15card);\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n\nvoid do_erase(struct sc_profile *profile, sc_card_t *card)\n{\n    struct sc_pkcs15_card *p15card;\n\n    p15card = sc_pkcs15_card_new();\n    p15card->card = card;\n\n    sc_pkcs15init_erase_card(p15card, profile, NULL);\n    sc_pkcs15_card_free(p15card);\n}\n\n\n// target function\nint\nsc_pkcs15init_rmdir(struct sc_pkcs15_card *p15card, struct sc_profile *profile,\n\t\tstruct sc_file *df)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tunsigned char buffer[1024];\n\tstruct sc_path\tpath;\n\tstruct sc_file\t*file, *parent;\n\tint\t\tr = 0, nfids;\n\n\tif (df == NULL)\n\t\treturn SC_ERROR_INTERNAL;\n\tsc_log(ctx, \"sc_pkcs15init_rmdir(%s)\", sc_print_path(&df->path));\n\n\tif (df->type == SC_FILE_TYPE_DF) {\n\t\tr = sc_pkcs15init_authenticate(profile, p15card, df, SC_AC_OP_LIST_FILES);\n\t\tif (r < 0)\n\t\t\treturn r;\n\t\tr = sc_list_files(p15card->card, buffer, sizeof(buffer));\n\t\tif (r < 0)\n\t\t\treturn r;\n\n\t\tpath = df->path;\n\t\tpath.len += 2;\n\n\t\tnfids = r / 2;\n\t\twhile (r >= 0 && nfids--) {\n\t\t\tpath.value[path.len-2] = buffer[2*nfids];\n\t\t\tpath.value[path.len-1] = buffer[2*nfids+1];\n\t\t\tr = sc_select_file(p15card->card, &path, &file);\n\t\t\tif (r < 0) {\n\t\t\t\tif (r == SC_ERROR_FILE_NOT_FOUND)\n\t\t\t\t\tcontinue;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr = sc_pkcs15init_rmdir(p15card, profile, file);\n\t\t\tsc_file_free(file);\n\t\t}\n\n\t\tif (r < 0)\n\t\t\treturn r;\n\t}\n\n\t/* Select the parent DF */\n\tpath = df->path;\n\tpath.len -= 2;\n\tr = sc_select_file(p15card->card, &path, &parent);\n\tif (r < 0)\n\t\treturn r;\n\n\tr = sc_pkcs15init_authenticate(profile, p15card, df, SC_AC_OP_DELETE);\n\tif (r < 0) {\n\t\tsc_file_free(parent);\n\t\treturn r;\n\t}\n\tr = sc_pkcs15init_authenticate(profile, p15card, parent, SC_AC_OP_DELETE);\n\tsc_file_free(parent);\n\tif (r < 0)\n\t\treturn r;\n\n\tmemset(&path, 0, sizeof(path));\n\tpath.type = SC_PATH_TYPE_FILE_ID;\n\tpath.value[0] = df->id >> 8;\n\tpath.value[1] = df->id & 0xFF;\n\tpath.len = 2;\n\n\t/* ensure that the card is in the correct lifecycle */\n\tr = sc_pkcs15init_set_lifecycle(p15card->card, SC_CARDCTRL_LIFECYCLE_ADMIN);\n\tif (r < 0 && r != SC_ERROR_NOT_SUPPORTED)\n\t\treturn r;\n\n\tr = sc_delete_file(p15card->card, &path);\n\treturn r;\n}\n",
    "target": 1,
    "idx": 1053927,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic int\ncosm_new_file(struct sc_profile *profile, struct sc_card *card,\n\t      unsigned int type, unsigned int num, struct sc_file **out)\n{\n\tstruct sc_file *file = NULL;\n\tconst char *_template = NULL, *desc = NULL;\n\tunsigned int structure = 0xFFFFFFFF;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\tsc_log(card->ctx,  \"type %X; num %i\\n\", type,\n\t\t num);\n\twhile (1) {\n\t\tswitch (type) {\n\t\tcase SC_PKCS15_TYPE_PRKEY_EC:\n\t\t\tdesc = \"EC private key\";\n\t\t\t_template = \"private-key\";\n\t\t\tstructure = SC_CARDCTL_OBERTHUR_KEY_EC_CRT;\n\t\t\tbreak;\n\t\tcase SC_PKCS15_TYPE_PUBKEY_EC:\n\t\t\tdesc = \"EC public key\";\n\t\t\t_template = \"public-key\";\n\t\t\tstructure = SC_CARDCTL_OBERTHUR_KEY_EC_PUBLIC;\n\t\t\tbreak;\n\t\tcase SC_PKCS15_TYPE_PRKEY_RSA:\n\t\t\tdesc = \"RSA private key\";\n\t\t\t_template = \"private-key\";\n\t\t\tstructure = SC_CARDCTL_OBERTHUR_KEY_RSA_CRT;\n\t\t\tbreak;\n\t\tcase SC_PKCS15_TYPE_PUBKEY_RSA:\n\t\t\tdesc = \"RSA public key\";\n\t\t\t_template = \"public-key\";\n\t\t\tstructure = SC_CARDCTL_OBERTHUR_KEY_RSA_PUBLIC;\n\t\t\tbreak;\n\t\tcase SC_PKCS15_TYPE_PRKEY:\n\t\t\tdesc = \"extractable private key\";\n\t\t\t_template = \"extractable-key\";\n\t\t\tbreak;\n\t\tcase SC_PKCS15_TYPE_CERT:\n\t\t\tdesc = \"certificate\";\n\t\t\t_template = \"certificate\";\n\t\t\tbreak;\n\t\tcase SC_PKCS15_TYPE_DATA_OBJECT:\n\t\t\tdesc = \"data object\";\n\t\t\t_template = \"data\";\n\t\t\tbreak;\n\t\t}\n\t\tif (_template)\n\t\t\tbreak;\n\t\t/* If this is a specific type such as\n\t\t * SC_PKCS15_TYPE_CERT_FOOBAR, fall back to\n\t\t * the generic class (SC_PKCS15_TYPE_CERT)\n\t\t */\n\t\tif (!(type & ~SC_PKCS15_TYPE_CLASS_MASK)) {\n\t\t\tsc_log(card->ctx, \n\t\t\t\t \"File type %X not supported by card driver\",\n\t\t\t\t type);\n\t\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t\t}\n\t\ttype &= SC_PKCS15_TYPE_CLASS_MASK;\n\t}\n\n\tsc_log(card->ctx,  \"template %s; num %i\\n\",\n\t\t _template, num);\n\tif (sc_profile_get_file(profile, _template, &file) < 0) {\n\t\tsc_log(card->ctx, \n\t\t\t \"Profile doesn't define %s template '%s'\\n\", desc,\n\t\t\t _template);\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t}\n\n\tif (file->path.len < 1) {\n\t\tsc_file_free(file);\n\t\treturn SC_ERROR_INTERNAL;\n\t}\n\n\tfile->id &= 0xFF00;\n\tfile->id |= (num & 0x00FF);\n\n\tfile->path.value[file->path.len - 1] = (num & 0xFF);\n\tfile->type = SC_FILE_TYPE_INTERNAL_EF;\n\tfile->ef_structure = structure;\n\n\tsc_log(card->ctx, \n\t\t \"file size %\"SC_FORMAT_LEN_SIZE_T\"u; ef type %i/%i; id %04X, path_len %\"SC_FORMAT_LEN_SIZE_T\"u\\n\",\n\t\t file->size, file->type, file->ef_structure, file->id,\n\t\t file->path.len);\n\tsc_log(card->ctx,  \"file path: %s\",\n\t\t sc_print_path(&(file->path)));\n\t*out = file;\n\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_SUCCESS);\n}\n\nstatic int epass2003_pkcs15_generate_key(struct sc_profile *profile,\n\t\t\t\t\t struct sc_pkcs15_card *p15card,\n\t\t\t\t\t struct sc_pkcs15_object *obj,\n\t\t\t\t\t struct sc_pkcs15_pubkey *pubkey)\n{\n\tstruct sc_card *card = p15card->card;\n\tint r;\n\tsc_epass2003_gen_key_data gendat;\n\tstruct sc_pkcs15_prkey_info *key_info =\n\t    (struct sc_pkcs15_prkey_info *)obj->data;\n\tsize_t idx = key_info->key_reference;\n\tsize_t keybits = key_info->modulus_length;\n\tstruct sc_file *tfile = NULL, *pukf = NULL;\n\tstruct sc_path path;\n\tstruct sc_file *file = NULL;\n\tint fidl = 0;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\tif (obj->type != SC_PKCS15_TYPE_PRKEY_RSA && obj->type != SC_PKCS15_TYPE_PRKEY_EC)\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\n\tif(obj->type == SC_PKCS15_TYPE_PRKEY_EC && keybits == 0)\n\t\tkeybits = 256; \t//EC key length is 256 ...\n\n\t/* allocate key object */\n\tr = cosm_new_file(profile, card, obj->type, idx, &file); //replace SC_PKCS15_TYPE_PRKEY_RSA with obj->type\n\tSC_TEST_GOTO_ERR(card->ctx, SC_LOG_DEBUG_VERBOSE, r,\n\t\t    \"create key: failed to allocate new key object\");\n\tfile->size = keybits;\n\tsc_log(card->ctx,  \"private key path: %s\",\n\t\t sc_print_path(&file->path));\n\tsc_log(card->ctx,  \"private key_info path: %s\",\n\t\t sc_print_path(&(key_info->path)));\n\n\tr = sc_pkcs15init_authenticate(profile, p15card, file,\n\t\t\t\t       SC_AC_OP_DELETE);\n\tSC_TEST_GOTO_ERR(card->ctx, SC_LOG_DEBUG_VERBOSE, r,\n\t\t    \"generate key: pkcs15init_authenticate(SC_AC_OP_DELETE) failed\");\n\n\tsc_delete_file(p15card->card, &file->path);\n\t/* create */\n\tr = sc_pkcs15init_create_file(profile, p15card, file);\n\tSC_TEST_GOTO_ERR(card->ctx, SC_LOG_DEBUG_VERBOSE, r,\n\t\t    \"create key: failed to create key file\");\n\n\tsc_log(card->ctx, \n\t\t \"index %\"SC_FORMAT_LEN_SIZE_T\"u; keybits %\"SC_FORMAT_LEN_SIZE_T\"u\\n\",\n\t\t idx, keybits);\n\tif (keybits < 1024 || keybits > 2048 || (keybits % 0x20)) {\n\t\tif(obj->type == SC_PKCS15_TYPE_PRKEY_EC && keybits == 256)\n\t\t{\n\t\t\tsc_log(card->ctx, \"current Alg is EC,Only support 256 ..\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE_TOOL,\n\t\t\t\t \"Unsupported key size %\"SC_FORMAT_LEN_SIZE_T\"u\\n\",\n\t\t\t\t keybits);\n\t\t\tr = SC_ERROR_INVALID_ARGUMENTS;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tpath = key_info->path;\n\tpath.len -= 2;\n\n\tr = sc_select_file(card, &path, &tfile);\n\tSC_TEST_GOTO_ERR(card->ctx, SC_LOG_DEBUG_VERBOSE, r,\n\t\t    \"generate key: no private object DF\");\n\n\tr = sc_pkcs15init_authenticate(profile, p15card, tfile,\n\t\t\t\t       SC_AC_OP_CRYPTO);\n\tSC_TEST_GOTO_ERR(card->ctx, SC_LOG_DEBUG_VERBOSE, r,\n\t\t    \"generate key: pkcs15init_authenticate(SC_AC_OP_CRYPTO) failed\");\n\n\tr = sc_pkcs15init_authenticate(profile, p15card, tfile,\n\t\t\t\t       SC_AC_OP_CREATE);\n\tSC_TEST_GOTO_ERR(card->ctx, SC_LOG_DEBUG_VERBOSE, r,\n\t\t    \"generate key: pkcs15init_authenticate(SC_AC_OP_CREATE) failed\");\n\n\tif (obj->type != SC_PKCS15_TYPE_PRKEY_RSA )\n\t{\n\t\n\t\tr = cosm_new_file(profile, card, SC_PKCS15_TYPE_PUBKEY_EC, idx, &pukf);\n\t}\n\telse\n\t{\n\t\t\n\t\tr = cosm_new_file(profile, card, SC_PKCS15_TYPE_PUBKEY_RSA, idx, &pukf);\n\t}\n\n\tif (r < 0) {\n\t\tsc_log(card->ctx, \n\t\t\t \"generate key: create temporary pukf failed\\n\");\n\t\tgoto err;\n\t}\n\n\tpukf->size = keybits;\n\tpukf->id = pukf->path.value[pukf->path.len - 2] * 0x100\n\t    + pukf->path.value[pukf->path.len - 1];\n\n\tsc_log(card->ctx, \n\t\t \"public key size %\"SC_FORMAT_LEN_SIZE_T\"u; ef type %i/%i; id %04X; path: %s\",\n\t\t pukf->size, pukf->type, pukf->ef_structure, pukf->id,\n\t\t sc_print_path(&pukf->path));\n\n\tr = sc_select_file(p15card->card, &pukf->path, NULL);\n\t/* if exist, delete */\n\tif (r == SC_SUCCESS) {\n\t\tr = sc_pkcs15init_authenticate(profile, p15card, pukf,\n\t\t       SC_AC_OP_DELETE);\n\t\tSC_TEST_GOTO_ERR(card->ctx, SC_LOG_DEBUG_VERBOSE, r,\n\t\t    \"generate key - pubkey: pkcs15init_authenticate(SC_AC_OP_DELETE) failed\");\n\n\t\tr = sc_pkcs15init_delete_by_path(profile, p15card, &pukf->path);\n\t\tif (r != SC_SUCCESS) {\n\t\t\tsc_log(card->ctx, \n\t\t\t\t \"generate key: failed to delete existing key file\\n\");\n\t\t\tgoto err;\n\t\t}\n\t}\n\t/* create */\n\tr = sc_pkcs15init_create_file(profile, p15card, pukf);\n\tif (r != SC_SUCCESS) {\n\t\tsc_log(card->ctx, \n\t\t\t \"generate key: pukf create file failed\\n\");\n\t\tgoto err;\n\t}\n\n\tr = sc_pkcs15init_authenticate(profile, p15card, pukf,\n\t\t\t\t       SC_AC_OP_UPDATE);\n\tSC_TEST_GOTO_ERR(card->ctx, SC_LOG_DEBUG_VERBOSE, r,\n\t\t    \"generate key - pubkey: pkcs15init_authenticate(SC_AC_OP_UPDATE) failed\");\n\n\t/* generate key pair */\n\tfidl = (file->id & 0xff) * FID_STEP;\n\tfile->id = (file->id & 0xff00) + fidl;\n\tpukf->id = (pukf->id & 0xff00) + fidl;\n\tgendat.prkey_id = file->id;\n\tgendat.pukey_id = pukf->id;\n\tgendat.key_length = keybits;\n\tgendat.modulus = NULL;\n\tr = sc_card_ctl(card, SC_CARDCTL_ENTERSAFE_GENERATE_KEY, &gendat);\n\tSC_TEST_GOTO_ERR(card->ctx, SC_LOG_DEBUG_VERBOSE, r,\n\t\t    \"generate RSA key pair failed\");\n\t\n\tif (!gendat.modulus) {\n\t\tr = SC_ERROR_OUT_OF_MEMORY;\n\t\tgoto err;\n\t}\n\n\t/* get the modulus */\n\tif (pubkey && (obj->type == SC_PKCS15_TYPE_PRKEY_RSA)) {\n\t\tu8 *buf;\n\t\tstruct sc_pkcs15_pubkey_rsa *rsa = &pubkey->u.rsa;\n\t\t/* set the modulus */\n\t\trsa->modulus.data = gendat.modulus;\n\t\trsa->modulus.len = keybits >> 3;\n\t\t/* set the exponent (always 0x10001) */\n\t\tbuf = (u8 *) malloc(3);\n\t\tif (!buf) {\n\t\t\tr = SC_ERROR_OUT_OF_MEMORY;\n\t\t\tgoto err;\n\t\t}\n\t\tbuf[0] = 0x01;\n\t\tbuf[1] = 0x00;\n\t\tbuf[2] = 0x01;\n\t\trsa->exponent.data = buf;\n\t\trsa->exponent.len = 3;\n\n\t\tpubkey->algorithm = SC_ALGORITHM_RSA;\n\t}\n\telse if(pubkey && (obj->type == SC_PKCS15_TYPE_PRKEY_EC)){\n\t\tstruct sc_ec_parameters *ecparams = (struct\t\n\t\t\t\tsc_ec_parameters *)key_info->params.data;\n\t\tpubkey->algorithm = SC_ALGORITHM_EC; \n\t\tpubkey->u.ec.ecpointQ.value = (u8 *) malloc(65);\n\t\tif (!pubkey->u.ec.ecpointQ.value) {\n\t\t\tr = SC_ERROR_OUT_OF_MEMORY;\n\t\t\tgoto err;\n\t\t}\n\n\t\tpubkey->u.ec.ecpointQ.value[0] = 0x04;\n\t\tmemcpy(&pubkey->u.ec.ecpointQ.value[1], gendat.modulus, 64);\n\t\tpubkey->u.ec.ecpointQ.len = 65;\n\n\t\tfree(pubkey->u.ec.params.named_curve);\n\t\tpubkey->u.ec.params.named_curve = NULL; \n\n\t\tfree(pubkey->u.ec.params.der.value);\n\t\tpubkey->u.ec.params.der.value = NULL;\n\t\tpubkey->u.ec.params.der.len = 0;\n\t\tpubkey->u.ec.params.named_curve = strdup(ecparams->named_curve); \n\n\t\tif (!pubkey->u.ec.params.named_curve){\n\t\t\tr = SC_ERROR_OUT_OF_MEMORY;\n\t\t\tgoto err;\n\t\t}\n\n\t\tr = sc_pkcs15_fix_ec_parameters(card->ctx, &pubkey->u.ec.params);\n\t}\n\telse\n\t\t/* free public key */\n\t\tfree(gendat.modulus);\n\nerr:\n\tsc_file_free(pukf);\n\tsc_file_free(file);\n\tsc_file_free(tfile);\n\t\n\tif(r < 0 && pubkey->u.ec.ecpointQ.value)\n\t{\n\t\tfree(pubkey->u.ec.ecpointQ.value);\n\t\tpubkey->u.ec.ecpointQ.value = NULL;\n\t\tpubkey->u.ec.ecpointQ.len = 0;\n\t}\n\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);\n}\n\nint\nsc_pkcs15init_generate_key(struct sc_pkcs15_card *p15card, struct sc_profile *profile,\n\t\tstruct sc_pkcs15init_keygen_args *keygen_args, unsigned int keybits,\n\t\tstruct sc_pkcs15_object **res_obj)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_pkcs15init_pubkeyargs pubkey_args;\n\tstruct sc_pkcs15_object *object = NULL;\n\tstruct sc_pkcs15_prkey_info *key_info = NULL;\n\tstruct sc_pkcs15_pubkey *pubkey = NULL;\n\tint r, caller_supplied_id = 0;\n\tint algorithm = keygen_args->prkey_args.key.algorithm;\n\n\tLOG_FUNC_CALLED(ctx);\n\t/* check supported key size */\n\tr = check_keygen_params_consistency(p15card->card,\n\t\talgorithm, &keygen_args->prkey_args,\n\t\t&keybits);\n\tLOG_TEST_RET(ctx, r, \"Invalid key size\");\n\n\tif (check_key_compatibility(p15card, algorithm,\n\t\t\t&keygen_args->prkey_args.key, keygen_args->prkey_args.x509_usage,\n\t\t\tkeybits, SC_ALGORITHM_ONBOARD_KEY_GEN) != SC_SUCCESS) {\n\t\tr = SC_ERROR_NOT_SUPPORTED;\n\t\tLOG_TEST_GOTO_ERR(ctx, r, \"Cannot generate key with the given parameters\");\n\t}\n\n\tif (profile->ops->generate_key == NULL) {\n\t\tr = SC_ERROR_NOT_SUPPORTED;\n\t\tLOG_TEST_GOTO_ERR(ctx, r, \"Key generation not supported\");\n\t}\n\n\tif (keygen_args->prkey_args.id.len)   {\n\t\tcaller_supplied_id = 1;\n\n\t\t/* Make sure that private key's ID is the unique inside the PKCS#15 application */\n\t\tr = sc_pkcs15_find_prkey_by_id(p15card, &keygen_args->prkey_args.id, NULL);\n\t\tif (!r) {\n\t\t\tr = SC_ERROR_NON_UNIQUE_ID;\n\t\t\tLOG_TEST_GOTO_ERR(ctx, r, \"Non unique ID of the private key object\");\n\t\t}\n\t\telse if (r != SC_ERROR_OBJECT_NOT_FOUND) {\n\t\t\tLOG_TEST_GOTO_ERR(ctx, r, \"Find private key error\");\n\t\t}\n\t}\n\n\t/* Set up the PrKDF object */\n\tr = sc_pkcs15init_init_prkdf(p15card, profile, &keygen_args->prkey_args,\n\t\t&keygen_args->prkey_args.key, keybits, &object);\n\tLOG_TEST_GOTO_ERR(ctx, r, \"Set up private key object error\");\n\n\tkey_info = (struct sc_pkcs15_prkey_info *) object->data;\n\n\tr = _pkcd15init_set_aux_md_data(p15card, &key_info->aux_data,\n\t\t\tkeygen_args->prkey_args.guid, keygen_args->prkey_args.guid_len);\n\tLOG_TEST_GOTO_ERR(ctx, r, \"Failed to set aux MD data\");\n\n\t/* Set up the PuKDF info. The public key will be filled in\n\t * by the card driver's generate_key function called below.\n\t * Auth.ID of the public key object is left empty. */\n\tmemset(&pubkey_args, 0, sizeof(pubkey_args));\n\tpubkey_args.id = keygen_args->prkey_args.id;\n\tpubkey_args.label = keygen_args->pubkey_label ? keygen_args->pubkey_label : object->label;\n\tpubkey_args.usage = keygen_args->prkey_args.usage;\n\tpubkey_args.x509_usage = keygen_args->prkey_args.x509_usage;\n\n\tif (algorithm == SC_ALGORITHM_GOSTR3410)   {\n\t\tpubkey_args.params.gost = keygen_args->prkey_args.params.gost;\n\t\tr = sc_copy_gost_params(&(pubkey_args.key.u.gostr3410.params), &(keygen_args->prkey_args.key.u.gostr3410.params));\n\t\tLOG_TEST_GOTO_ERR(ctx, r, \"Cannot allocate GOST parameters\");\n\t}\n\telse if (algorithm == SC_ALGORITHM_EC)   {\n\t\t/* needs to be freed in case of failure when pubkey is not set yet */\n\t\tpubkey_args.key.u.ec.params = keygen_args->prkey_args.key.u.ec.params;\n\t\tr = sc_copy_ec_params(&pubkey_args.key.u.ec.params, &keygen_args->prkey_args.key.u.ec.params);\n\t\tLOG_TEST_GOTO_ERR(ctx, r, \"Cannot allocate EC parameters\");\n\t}\n\n\t/* Generate the private key on card */\n\tr = profile->ops->create_key(profile, p15card, object);\n\tif (r < 0 && algorithm == SC_ALGORITHM_EC) {\n\t\t/* pubkey->alg_id->algorithm is not set yet, needs to be freed independently */\n\t\tfree(pubkey_args.key.u.ec.params.der.value);\n\t\tfree(pubkey_args.key.u.ec.params.named_curve);\n\t}\n\tLOG_TEST_GOTO_ERR(ctx, r, \"Cannot generate key: create key failed\");\n\n\tr = profile->ops->generate_key(profile, p15card, object, &pubkey_args.key);\n\tif (r < 0 && algorithm == SC_ALGORITHM_EC) {\n\t\tfree(pubkey_args.key.u.ec.params.der.value);\n\t\tfree(pubkey_args.key.u.ec.params.named_curve);\n\t}\n\tLOG_TEST_GOTO_ERR(ctx, r, \"Failed to generate key\");\n\n\t/* update PrKDF entry */\n\tif (!caller_supplied_id)   {\n\t\tstruct sc_pkcs15_id iid;\n\n\t\t/* Caller not supplied ID, so,\n\t\t * if intrinsic ID can be calculated -- overwrite the native one */\n\t\tmemset(&iid, 0, sizeof(iid));\n\t\tr = sc_pkcs15init_select_intrinsic_id(p15card, profile, SC_PKCS15_TYPE_PUBKEY, &iid, &pubkey_args.key);\n\t\tif (r < 0 && algorithm == SC_ALGORITHM_EC) {\n\t\t\tfree(pubkey_args.key.u.ec.params.der.value);\n\t\t\tfree(pubkey_args.key.u.ec.params.named_curve);\n\t\t\tfree(pubkey_args.key.u.ec.ecpointQ.value); /* allocated in profile->ops->generate_key */\n\t\t}\n\t\tLOG_TEST_GOTO_ERR(ctx, r, \"Select intrinsic ID error\");\n\n\t\tif (iid.len)\n\t\t\tkey_info->id = iid;\n\t}\n\n\tpubkey = &pubkey_args.key;\n\tif (!pubkey->alg_id)   {\n\t\tpubkey->alg_id = calloc(1, sizeof(struct sc_algorithm_id));\n\t\tif (!pubkey->alg_id) {\n\t\t\tif (algorithm == SC_ALGORITHM_EC) {\n\t\t\t\tfree(pubkey_args.key.u.ec.params.der.value);\n\t\t\t\tfree(pubkey_args.key.u.ec.params.named_curve);\n\t\t\t}\n\t\t\tr = SC_ERROR_OUT_OF_MEMORY;\n\t\t\tLOG_TEST_GOTO_ERR(ctx, r, \"Can not allocate memory for algorithm id\");\n\t\t}\n\n\t\tsc_init_oid(&pubkey->alg_id->oid);\n\t\tpubkey->alg_id->algorithm = pubkey->algorithm;\n\t}\n\n\tpubkey_args.id = key_info->id;\n\tr = sc_pkcs15_encode_pubkey(ctx, pubkey, &object->content.value, &object->content.len);\n\tLOG_TEST_GOTO_ERR(ctx, r, \"Failed to encode public key\");\n\n\tr = sc_pkcs15init_add_object(p15card, profile, SC_PKCS15_PRKDF, object);\n\tLOG_TEST_GOTO_ERR(ctx, r, \"Failed to add generated private key object\");\n\n\tif (!r && profile->ops->emu_store_data)   {\n\t\tr = profile->ops->emu_store_data(p15card, profile, object, NULL, NULL);\n\t\tif (r == SC_ERROR_NOT_IMPLEMENTED)\n\t\t\tr = SC_SUCCESS;\n\t\tLOG_TEST_GOTO_ERR(ctx, r, \"Card specific 'store data' failed\");\n\t}\n\n\tr = sc_pkcs15init_store_public_key(p15card, profile, &pubkey_args, NULL);\n\tif (r < 0)\n\t\tsc_pkcs15_remove_object(p15card, object);\n\tLOG_TEST_GOTO_ERR(ctx, r, \"Failed to store public key\");\n\n\tif (res_obj)\n\t\t*res_obj = object;\n\tobject = NULL;\n\n\tsc_pkcs15_erase_pubkey(pubkey);\n\n\tprofile->dirty = 1;\n\nerr:\n\tsc_pkcs15_erase_pubkey(pubkey);\n\tsc_pkcs15_free_object(object);\n\tif (algorithm == SC_ALGORITHM_EC) {\n\t\t/* allocated in check_keygen_params_consistency() */\n\t\tfree(keygen_args->prkey_args.key.u.ec.params.der.value);\n\t\tkeygen_args->prkey_args.key.u.ec.params.der.value = NULL;\n\t}\n\tLOG_FUNC_RETURN(ctx, r);\n}\n\nvoid do_generate_key(struct sc_profile *profile, struct sc_pkcs15_card *p15card, sc_card_t *card)\n{\n    struct sc_pkcs15init_keygen_args keygen_args;\n    int algorithms[] = { SC_ALGORITHM_RSA, SC_ALGORITHM_EC };\n    unsigned int keybits[] = { 1024, 0 };\n\n    memset(&keygen_args, 0, sizeof(keygen_args));\n    sc_pkcs15_format_id(\"01\", &(keygen_args.prkey_args.auth_id));\n    keygen_args.prkey_args.access_flags |=\n                    SC_PKCS15_PRKEY_ACCESS_SENSITIVE\n                | SC_PKCS15_PRKEY_ACCESS_ALWAYSSENSITIVE\n                | SC_PKCS15_PRKEY_ACCESS_NEVEREXTRACTABLE\n                | SC_PKCS15_PRKEY_ACCESS_LOCAL;\n\n    for (int i = 1; i < 2; i++) {\n        keygen_args.prkey_args.key.algorithm = algorithms[i];\n        if (algorithms[i] == SC_ALGORITHM_EC) /* strdup called also in parse_alg_spec() */\n            keygen_args.prkey_args.key.u.ec.params.named_curve = strdup(\"prime256v1\");\n        sc_pkcs15init_generate_key(p15card, profile, &keygen_args, keybits[i], NULL);\n        if (algorithms[i] == SC_ALGORITHM_EC)\n            free(keygen_args.prkey_args.key.u.ec.params.named_curve);\n    }\n}\n\n\n// target function\nstatic int\ncosm_new_file(struct sc_profile *profile, struct sc_card *card,\n\t      unsigned int type, unsigned int num, struct sc_file **out)\n{\n\tstruct sc_file *file;\n\tconst char *_template = NULL, *desc = NULL;\n\tunsigned int structure = 0xFFFFFFFF;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\tsc_log(card->ctx,  \"type %X; num %i\\n\", type,\n\t\t num);\n\twhile (1) {\n\t\tswitch (type) {\n\t\tcase SC_PKCS15_TYPE_PRKEY_EC:\n\t\t\tdesc = \"RSA private key\";\n\t\t\t_template = \"private-key\";\n\t\t\tstructure = SC_CARDCTL_OBERTHUR_KEY_EC_CRT;\n\t\t\tbreak;\n\t\tcase SC_PKCS15_TYPE_PUBKEY_EC:\n\t\t\tdesc = \"RSA public key\";\n\t\t\t_template = \"public-key\";\n\t\t\tstructure = SC_CARDCTL_OBERTHUR_KEY_EC_PUBLIC;\n\t\t\tbreak;\n\t\tcase SC_PKCS15_TYPE_PRKEY_RSA:\n\t\t\tdesc = \"RSA private key\";\n\t\t\t_template = \"private-key\";\n\t\t\tstructure = SC_CARDCTL_OBERTHUR_KEY_RSA_CRT;\n\t\t\tbreak;\n\t\tcase SC_PKCS15_TYPE_PUBKEY_RSA:\n\t\t\tdesc = \"RSA public key\";\n\t\t\t_template = \"public-key\";\n\t\t\tstructure = SC_CARDCTL_OBERTHUR_KEY_RSA_PUBLIC;\n\t\t\tbreak;\n\t\tcase SC_PKCS15_TYPE_PRKEY:\n\t\t\tdesc = \"extractable private key\";\n\t\t\t_template = \"extractable-key\";\n\t\t\tbreak;\n\t\tcase SC_PKCS15_TYPE_CERT:\n\t\t\tdesc = \"certificate\";\n\t\t\t_template = \"certificate\";\n\t\t\tbreak;\n\t\tcase SC_PKCS15_TYPE_DATA_OBJECT:\n\t\t\tdesc = \"data object\";\n\t\t\t_template = \"data\";\n\t\t\tbreak;\n\t\t}\n\t\tif (_template)\n\t\t\tbreak;\n\t\t/* If this is a specific type such as\n\t\t * SC_PKCS15_TYPE_CERT_FOOBAR, fall back to\n\t\t * the generic class (SC_PKCS15_TYPE_CERT)\n\t\t */\n\t\tif (!(type & ~SC_PKCS15_TYPE_CLASS_MASK)) {\n\t\t\tsc_log(card->ctx, \n\t\t\t\t \"File type %X not supported by card driver\",\n\t\t\t\t type);\n\t\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t\t}\n\t\ttype &= SC_PKCS15_TYPE_CLASS_MASK;\n\t}\n\n\tsc_log(card->ctx,  \"template %s; num %i\\n\",\n\t\t _template, num);\n\tif (sc_profile_get_file(profile, _template, &file) < 0) {\n\t\tsc_log(card->ctx, \n\t\t\t \"Profile doesn't define %s template '%s'\\n\", desc,\n\t\t\t _template);\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t}\n\n\tfile->id &= 0xFF00;\n\tfile->id |= (num & 0x00FF);\n\n\tfile->path.value[file->path.len - 1] = (num & 0xFF);\n\tfile->type = SC_FILE_TYPE_INTERNAL_EF;\n\tfile->ef_structure = structure;\n\n\tsc_log(card->ctx, \n\t\t \"file size %\"SC_FORMAT_LEN_SIZE_T\"u; ef type %i/%i; id %04X, path_len %\"SC_FORMAT_LEN_SIZE_T\"u\\n\",\n\t\t file->size, file->type, file->ef_structure, file->id,\n\t\t file->path.len);\n\tsc_log(card->ctx,  \"file path: %s\",\n\t\t sc_print_path(&(file->path)));\n\t*out = file;\n\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_SUCCESS);\n}\n",
    "target": 1,
    "idx": 1046002,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic int\nwavlike_ima_decode_block (SF_PRIVATE *psf, IMA_ADPCM_PRIVATE *pima)\n{\tint\t\tchan, k, predictor, blockindx, indx, indxstart, diff ;\n\tshort\tstep, bytecode, stepindx [2] ;\n\n\tpima->blockcount ++ ;\n\tpima->samplecount = 0 ;\n\n\tif (pima->blockcount > pima->blocks)\n\t{\tmemset (pima->samples, 0, pima->samplesperblock * pima->channels * sizeof (short)) ;\n\t\treturn 1 ;\n\t\t} ;\n\n\tif ((k = psf_fread (pima->block, 1, pima->blocksize, psf)) != pima->blocksize)\n\t\tpsf_log_printf (psf, \"*** Warning : short read (%d != %d).\\n\", k, pima->blocksize) ;\n\n\t/* Read and check the block header. */\n\n\tfor (chan = 0 ; chan < pima->channels ; chan++)\n\t{\tpredictor = pima->block [chan*4] | (pima->block [chan*4+1] << 8) ;\n\t\tif (predictor & 0x8000)\n\t\t\tpredictor -= 0x10000 ;\n\n\t\tstepindx [chan] = pima->block [chan*4+2] ;\n\t\tstepindx [chan] = clamp_ima_step_index (stepindx [chan]) ;\n\n\n\t\tif (pima->block [chan*4+3] != 0)\n\t\t\tpsf_log_printf (psf, \"IMA ADPCM synchronisation error.\\n\") ;\n\n\t\tpima->samples [chan] = predictor ;\n\t\t} ;\n\n\t/*\n\t**\tPull apart the packed 4 bit samples and store them in their\n\t**\tcorrect sample positions.\n\t*/\n\n\tblockindx = 4 * pima->channels ;\n\n\tindxstart = pima->channels ;\n\twhile (blockindx < pima->blocksize)\n\t{\tfor (chan = 0 ; chan < pima->channels ; chan++)\n\t\t{\tindx = indxstart + chan ;\n\t\t\tfor (k = 0 ; k < 4 ; k++)\n\t\t\t{\tbytecode = pima->block [blockindx++] ;\n\t\t\t\tpima->samples [indx] = bytecode & 0x0F ;\n\t\t\t\tindx += pima->channels ;\n\t\t\t\tpima->samples [indx] = (bytecode >> 4) & 0x0F ;\n\t\t\t\tindx += pima->channels ;\n\t\t\t\t} ;\n\t\t\t} ;\n\t\tindxstart += 8 * pima->channels ;\n\t\t} ;\n\n\t/* Decode the encoded 4 bit samples. */\n\n\tfor (k = pima->channels ; k < (pima->samplesperblock * pima->channels) ; k ++)\n\t{\tchan = (pima->channels > 1) ? (k % 2) : 0 ;\n\n\t\tbytecode = pima->samples [k] & 0xF ;\n\n\t\tstep = ima_step_size [stepindx [chan]] ;\n\t\tpredictor = pima->samples [k - pima->channels] ;\n\n\t\tdiff = step >> 3 ;\n\t\tif (bytecode & 1)\n\t\t\tdiff += step >> 2 ;\n\t\tif (bytecode & 2)\n\t\t\tdiff += step >> 1 ;\n\t\tif (bytecode & 4)\n\t\t\tdiff += step ;\n\t\tif (bytecode & 8)\n\t\t\tdiff = -diff ;\n\n\t\tpredictor += diff ;\n\n\t\tif (predictor > 32767)\n\t\t\tpredictor = 32767 ;\n\t\telse if (predictor < -32768)\n\t\t\tpredictor = -32768 ;\n\n\t\tstepindx [chan] += ima_indx_adjust [bytecode] ;\n\t\tstepindx [chan] = clamp_ima_step_index (stepindx [chan]) ;\n\n\t\tpima->samples [k] = predictor ;\n\t\t} ;\n\n\treturn 1 ;\n} /* wavlike_ima_decode_block */\n\nstatic int\nima_reader_init (SF_PRIVATE *psf, int blockalign, int samplesperblock)\n{\tIMA_ADPCM_PRIVATE\t*pima ;\n\tint\t\tpimasize, count ;\n\n\tif (psf->file.mode != SFM_READ)\n\t\treturn SFE_BAD_MODE_RW ;\n\n\t/*\n\t**\tAllocate enough space for 1 more than a multiple of 8 samples\n\t**\tto avoid having to branch when pulling apart the nibbles.\n\t*/\n\tcount = ((samplesperblock - 2) | 7) + 2 ;\n\tpimasize = sizeof (IMA_ADPCM_PRIVATE) + psf->sf.channels * (blockalign + samplesperblock + sizeof(short) * count) ;\n\n\tif (! (pima = calloc (1, pimasize)))\n\t\treturn SFE_MALLOC_FAILED ;\n\n\tpsf->codec_data = (void*) pima ;\n\n\tpima->samples\t= pima->data ;\n\tpima->block\t\t= (unsigned char*) (pima->data + samplesperblock * psf->sf.channels) ;\n\n\tpima->channels\t\t\t= psf->sf.channels ;\n\tpima->blocksize\t\t\t= blockalign ;\n\tpima->samplesperblock\t= samplesperblock ;\n\n\tpsf->filelength = psf_get_filelen (psf) ;\n\tpsf->datalength = (psf->dataend) ? psf->dataend - psf->dataoffset :\n\t\t\t\t\t\t\tpsf->filelength - psf->dataoffset ;\n\n\tif (pima->blocksize <= 0)\n\t{\tpsf_log_printf (psf, \"*** Error : pima->blocksize should be > 0.\\n\") ;\n\t\treturn SFE_INTERNAL ;\n\t\t} ;\n\n\tif (pima->samplesperblock <= 0)\n\t{\tpsf_log_printf (psf, \"*** Error : pima->samplesperblock should be > 0.\\n\") ;\n\t\treturn SFE_INTERNAL ;\n\t\t} ;\n\n\tif (psf->datalength % pima->blocksize)\n\t\tpima->blocks = psf->datalength / pima->blocksize + 1 ;\n\telse\n\t\tpima->blocks = psf->datalength / pima->blocksize ;\n\n\tswitch (SF_CONTAINER (psf->sf.format))\n\t{\tcase SF_FORMAT_WAV :\n\t\tcase SF_FORMAT_W64 :\n\t\t\t\tcount = 2 * (pima->blocksize - 4 * pima->channels) / pima->channels + 1 ;\n\n\t\t\t\tif (pima->samplesperblock != count)\n\t\t\t\t{\tpsf_log_printf (psf, \"*** Error : samplesperblock should be %d.\\n\", count) ;\n\t\t\t\t\treturn SFE_INTERNAL ;\n\t\t\t\t\t} ;\n\n\t\t\t\tpima->decode_block = wavlike_ima_decode_block ;\n\n\t\t\t\tpsf->sf.frames = pima->samplesperblock * pima->blocks ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_AIFF :\n\t\t\t\tpsf_log_printf (psf, \"still need to check block count\\n\") ;\n\t\t\t\tpima->decode_block = aiff_ima_decode_block ;\n\t\t\t\tpsf->sf.frames = pima->samplesperblock * pima->blocks / pima->channels ;\n\t\t\t\tbreak ;\n\n\t\tdefault :\n\t\t\t\tpsf_log_printf (psf, \"ima_reader_init: bad psf->sf.format\\n\") ;\n\t\t\t\treturn SFE_INTERNAL ;\n\t\t} ;\n\n\tpima->decode_block (psf, pima) ;\t/* Read first block. */\n\n\tpsf->read_short\t\t= ima_read_s ;\n\tpsf->read_int\t\t= ima_read_i ;\n\tpsf->read_float\t\t= ima_read_f ;\n\tpsf->read_double\t= ima_read_d ;\n\n\treturn 0 ;\n} /* ima_reader_init */\n\nint\nwavlike_ima_init (SF_PRIVATE *psf, int blockalign, int samplesperblock)\n{\tint error ;\n\n\tif (psf->codec_data != NULL)\n\t{\tpsf_log_printf (psf, \"*** psf->codec_data is not NULL.\\n\") ;\n\t\treturn SFE_INTERNAL ;\n\t\t} ;\n\n\tif (psf->file.mode == SFM_RDWR)\n\t\treturn SFE_BAD_MODE_RW ;\n\n\tif (psf->file.mode == SFM_READ)\n\t\tif ((error = ima_reader_init (psf, blockalign, samplesperblock)))\n\t\t\treturn error ;\n\n\tif (psf->file.mode == SFM_WRITE)\n\t\tif ((error = ima_writer_init (psf, blockalign)))\n\t\t\treturn error ;\n\n\tpsf->codec_close = ima_close ;\n\tpsf->seek = wavlike_ima_seek ;\n\n\treturn 0 ;\n} /* wavlike_ima_init */\n\nint\nwav_open\t(SF_PRIVATE *psf)\n{\tWAVLIKE_PRIVATE * wpriv ;\n\tint\tformat, subformat, error, blockalign = 0, framesperblock = 0 ;\n\n\tif ((wpriv = calloc (1, sizeof (WAVLIKE_PRIVATE))) == NULL)\n\t\treturn SFE_MALLOC_FAILED ;\n\tpsf->container_data = wpriv ;\n\n\twpriv->wavex_ambisonic = SF_AMBISONIC_NONE ;\n\tpsf->strings.flags = SF_STR_ALLOW_START | SF_STR_ALLOW_END ;\n\n\tif (psf->file.mode == SFM_READ || (psf->file.mode == SFM_RDWR && psf->filelength > 0))\n\t{\tif ((error = wav_read_header (psf, &blockalign, &framesperblock)))\n\t\t\treturn error ;\n\n\t\tpsf->next_chunk_iterator = wav_next_chunk_iterator ;\n\t\tpsf->get_chunk_size = wav_get_chunk_size ;\n\t\tpsf->get_chunk_data = wav_get_chunk_data ;\n\t\t} ;\n\n\tsubformat = SF_CODEC (psf->sf.format) ;\n\n\tif (psf->file.mode == SFM_WRITE || psf->file.mode == SFM_RDWR)\n\t{\tif (psf->is_pipe)\n\t\t\treturn SFE_NO_PIPE_WRITE ;\n\n\t\twpriv->wavex_ambisonic = SF_AMBISONIC_NONE ;\n\n\t\tformat = SF_CONTAINER (psf->sf.format) ;\n\t\tif (format != SF_FORMAT_WAV && format != SF_FORMAT_WAVEX)\n\t\t\treturn\tSFE_BAD_OPEN_FORMAT ;\n\n\t\tpsf->blockwidth = psf->bytewidth * psf->sf.channels ;\n\n\t\t/* RIFF WAVs are little-endian, RIFX WAVs are big-endian, default to little */\n\t\tpsf->endian = SF_ENDIAN (psf->sf.format) ;\n\t\tif (CPU_IS_BIG_ENDIAN && psf->endian == SF_ENDIAN_CPU)\n\t\t\tpsf->endian = SF_ENDIAN_BIG ;\n\t\telse if (psf->endian != SF_ENDIAN_BIG)\n\t\t\tpsf->endian = SF_ENDIAN_LITTLE ;\n\n\t\tif (psf->file.mode != SFM_RDWR || psf->filelength < 44)\n\t\t{\tpsf->filelength = 0 ;\n\t\t\tpsf->datalength = 0 ;\n\t\t\tpsf->dataoffset = 0 ;\n\t\t\tpsf->sf.frames = 0 ;\n\t\t\t} ;\n\n\t\tif (subformat == SF_FORMAT_IMA_ADPCM || subformat == SF_FORMAT_MS_ADPCM)\n\t\t{\tblockalign = wavlike_srate2blocksize (psf->sf.samplerate * psf->sf.channels) ;\n\t\t\tframesperblock = -1 ; /* Corrected later. */\n\t\t\t} ;\n\n\t\t/* By default, add the peak chunk to floating point files. Default behaviour\n\t\t** can be switched off using sf_command (SFC_SET_PEAK_CHUNK, SF_FALSE).\n\t\t*/\n\t\tif (psf->file.mode == SFM_WRITE && (subformat == SF_FORMAT_FLOAT || subformat == SF_FORMAT_DOUBLE))\n\t\t{\tif ((psf->peak_info = peak_info_calloc (psf->sf.channels)) == NULL)\n\t\t\t\treturn SFE_MALLOC_FAILED ;\n\t\t\tpsf->peak_info->peak_loc = SF_PEAK_START ;\n\t\t\t} ;\n\n\t\tpsf->write_header\t= wav_write_header ;\n\t\tpsf->set_chunk\t\t= wav_set_chunk ;\n\t\t} ;\n\n\tpsf->container_close = wav_close ;\n\tpsf->command = wav_command ;\n\n\tswitch (subformat)\n\t{\tcase SF_FORMAT_PCM_U8 :\n\t\tcase SF_FORMAT_PCM_16 :\n\t\tcase SF_FORMAT_PCM_24 :\n\t\tcase SF_FORMAT_PCM_32 :\n\t\t\t\t\terror = pcm_init (psf) ;\n\t\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_ULAW :\n\t\t\t\t\terror = ulaw_init (psf) ;\n\t\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_ALAW :\n\t\t\t\t\terror = alaw_init (psf) ;\n\t\t\t\t\tbreak ;\n\n\t\t/* Lite remove start */\n\t\tcase SF_FORMAT_FLOAT :\n\t\t\t\t\terror = float32_init (psf) ;\n\t\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_DOUBLE :\n\t\t\t\t\terror = double64_init (psf) ;\n\t\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_IMA_ADPCM :\n\t\t\t\t\terror = wavlike_ima_init (psf, blockalign, framesperblock) ;\n\t\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_MS_ADPCM :\n\t\t\t\t\terror = wavlike_msadpcm_init (psf, blockalign, framesperblock) ;\n\t\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_G721_32 :\n\t\t\t\t\terror = g72x_init (psf) ;\n\t\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_NMS_ADPCM_16 :\n\t\tcase SF_FORMAT_NMS_ADPCM_24 :\n\t\tcase SF_FORMAT_NMS_ADPCM_32 :\n\t\t\t\t\terror = nms_adpcm_init (psf) ;\n\t\t\t\t\tbreak ;\n\n\t\t/* Lite remove end */\n\n\t\tcase SF_FORMAT_GSM610 :\n\t\t\t\t\terror = gsm610_init (psf) ;\n\t\t\t\t\tbreak ;\n\n\t\tdefault : \treturn SFE_UNIMPLEMENTED ;\n\t\t} ;\n\n\tif (psf->file.mode == SFM_WRITE || (psf->file.mode == SFM_RDWR && psf->filelength == 0))\n\t\treturn psf->write_header (psf, SF_FALSE) ;\n\n\treturn error ;\n} /* wav_open */\n\n\n\n\n\n\n// target function\nstatic int\nima_reader_init (SF_PRIVATE *psf, int blockalign, int samplesperblock)\n{\tIMA_ADPCM_PRIVATE\t*pima ;\n\tint\t\tpimasize, count ;\n\n\tif (psf->file.mode != SFM_READ)\n\t\treturn SFE_BAD_MODE_RW ;\n\n\tpimasize = sizeof (IMA_ADPCM_PRIVATE) + blockalign * psf->sf.channels + 3 * psf->sf.channels * samplesperblock ;\n\n\tif (! (pima = calloc (1, pimasize)))\n\t\treturn SFE_MALLOC_FAILED ;\n\n\tpsf->codec_data = (void*) pima ;\n\n\tpima->samples\t= pima->data ;\n\tpima->block\t\t= (unsigned char*) (pima->data + samplesperblock * psf->sf.channels) ;\n\n\tpima->channels\t\t\t= psf->sf.channels ;\n\tpima->blocksize\t\t\t= blockalign ;\n\tpima->samplesperblock\t= samplesperblock ;\n\n\tpsf->filelength = psf_get_filelen (psf) ;\n\tpsf->datalength = (psf->dataend) ? psf->dataend - psf->dataoffset :\n\t\t\t\t\t\t\tpsf->filelength - psf->dataoffset ;\n\n\tif (pima->blocksize <= 0)\n\t{\tpsf_log_printf (psf, \"*** Error : pima->blocksize should be > 0.\\n\") ;\n\t\treturn SFE_INTERNAL ;\n\t\t} ;\n\n\tif (pima->samplesperblock <= 0)\n\t{\tpsf_log_printf (psf, \"*** Error : pima->samplesperblock should be > 0.\\n\") ;\n\t\treturn SFE_INTERNAL ;\n\t\t} ;\n\n\tif (psf->datalength % pima->blocksize)\n\t\tpima->blocks = psf->datalength / pima->blocksize + 1 ;\n\telse\n\t\tpima->blocks = psf->datalength / pima->blocksize ;\n\n\tswitch (SF_CONTAINER (psf->sf.format))\n\t{\tcase SF_FORMAT_WAV :\n\t\tcase SF_FORMAT_W64 :\n\t\t\t\tcount = 2 * (pima->blocksize - 4 * pima->channels) / pima->channels + 1 ;\n\n\t\t\t\tif (pima->samplesperblock != count)\n\t\t\t\t{\tpsf_log_printf (psf, \"*** Error : samplesperblock should be %d.\\n\", count) ;\n\t\t\t\t\treturn SFE_INTERNAL ;\n\t\t\t\t\t} ;\n\n\t\t\t\tpima->decode_block = wavlike_ima_decode_block ;\n\n\t\t\t\tpsf->sf.frames = pima->samplesperblock * pima->blocks ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_AIFF :\n\t\t\t\tpsf_log_printf (psf, \"still need to check block count\\n\") ;\n\t\t\t\tpima->decode_block = aiff_ima_decode_block ;\n\t\t\t\tpsf->sf.frames = pima->samplesperblock * pima->blocks / pima->channels ;\n\t\t\t\tbreak ;\n\n\t\tdefault :\n\t\t\t\tpsf_log_printf (psf, \"ima_reader_init: bad psf->sf.format\\n\") ;\n\t\t\t\treturn SFE_INTERNAL ;\n\t\t} ;\n\n\tpima->decode_block (psf, pima) ;\t/* Read first block. */\n\n\tpsf->read_short\t\t= ima_read_s ;\n\tpsf->read_int\t\t= ima_read_i ;\n\tpsf->read_float\t\t= ima_read_f ;\n\tpsf->read_double\t= ima_read_d ;\n\n\treturn 0 ;\n} /* ima_reader_init */\n",
    "target": 1,
    "idx": 1025530,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nint proj_hgrid_init(PJ* P, const char *grids) {\n/**********************************************\n\n  Initizalize and populate list of horizontal\n  grids.\n\n    Takes a PJ-object and the plus-parameter\n    name that is used in the proj-string to\n    specify the grids to load, e.g. \"+grids\".\n    The + should be left out here.\n\n    Returns the number of loaded grids.\n\n***********************************************/\n\n    /* prepend \"s\" to the \"grids\" string to allow usage with pj_param */\n    char *sgrids = (char *) pj_malloc( (strlen(grids)+1+1) *sizeof(char) );\n    sprintf(sgrids, \"%s%s\", \"s\", grids);\n\n    if (P->gridlist == NULL) {\n        P->gridlist = pj_gridlist_from_nadgrids(\n            P->ctx,\n            pj_param(P->ctx, P->params, sgrids).s,\n            &(P->gridlist_count)\n        );\n\n        if( P->gridlist == NULL || P->gridlist_count == 0 ) {\n            pj_dealloc(sgrids);\n            return 0;\n        }\n    }\n\n    if (P->gridlist_count == 0) {\n        proj_errno_set(P, PJD_ERR_FAILED_TO_LOAD_GRID);\n    }\n\n    pj_dealloc(sgrids);\n    return P->gridlist_count;\n}\n\n\n\n\n\n\n\n\n// target function\nint proj_hgrid_init(PJ* P, const char *grids) {\n/**********************************************\n\n  Initizalize and populate list of horizontal\n  grids.\n\n    Takes a PJ-object and the plus-parameter\n    name that is used in the proj-string to\n    specify the grids to load, e.g. \"+grids\".\n    The + should be left out here.\n\n    Returns the number of loaded grids.\n\n***********************************************/\n\n    /* prepend \"s\" to the \"grids\" string to allow usage with pj_param */\n    char *sgrids = (char *) pj_malloc( (strlen(grids)+1) *sizeof(char) );\n    sprintf(sgrids, \"%s%s\", \"s\", grids);\n\n    if (P->gridlist == NULL) {\n        P->gridlist = pj_gridlist_from_nadgrids(\n            P->ctx,\n            pj_param(P->ctx, P->params, sgrids).s,\n            &(P->gridlist_count)\n        );\n\n        if( P->gridlist == NULL || P->gridlist_count == 0 ) {\n            pj_dealloc(sgrids);\n            return 0;\n        }\n    }\n\n    if (P->gridlist_count == 0) {\n        proj_errno_set(P, PJD_ERR_FAILED_TO_LOAD_GRID);\n    }\n\n    pj_dealloc(sgrids);\n    return P->gridlist_count;\n}\n",
    "target": 1,
    "idx": 1003940,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "// context\nUA_StatusCode\nUA_copy(const void *src, void *dst, const UA_DataType *type) {\n    memset(dst, 0, type->memSize); /* init */\n    UA_StatusCode retval = copyJumpTable[type->typeKind](src, dst, type);\n    if(retval != UA_STATUSCODE_GOOD)\n        UA_clear(dst, type);\n    return retval;\n}\n\nstatic UA_INLINE UA_StatusCode\nUA_NodeId_copy(const UA_NodeId *src, UA_NodeId *dst) {\n    return UA_copy(src, dst, &UA_TYPES[UA_TYPES_NODEID]);\n}\n\nvoid\nOperation_Browse(UA_Server *server, UA_Session *session, const struct BrowseOpts *bo,\n                 const UA_BrowseDescription *descr, UA_BrowseResult *result) {\n    /* How many references can we return at most? */\n    UA_UInt32 maxRefs = bo->maxReferences;\n    if(maxRefs == 0) {\n        if(server->config.maxReferencesPerNode != 0) {\n            maxRefs = server->config.maxReferencesPerNode;\n        } else {\n            maxRefs = UA_INT32_MAX;\n        }\n    } else {\n        if(server->config.maxReferencesPerNode != 0 &&\n           maxRefs > server->config.maxReferencesPerNode) {\n            maxRefs = server->config.maxReferencesPerNode;\n        }\n    }\n\n    /* Create the results array */\n    RefResult rr;\n    result->statusCode = RefResult_init(&rr, maxRefs);\n    if(result->statusCode != UA_STATUSCODE_GOOD)\n        return;\n\n    ContinuationPoint cp;\n    result->statusCode = ContinuationPoint_init(&cp, maxRefs, bo->recursive);\n    if(result->statusCode != UA_STATUSCODE_GOOD) {\n        RefResult_clear(&rr);\n        return;\n    }\n    cp.bd = *descr; /* Deep-copy only when the cp is persisted in the session */\n\n    /* Add the initial node to the RefTree */\n    result->statusCode = RefTree_add(&cp.rt, &descr->nodeId);\n    if(result->statusCode != UA_STATUSCODE_GOOD) {\n        RefTree_clear(&cp.rt);\n        RefResult_clear(&rr);\n        return;\n    }\n    \n    /* Recurse to get all references */\n    UA_Boolean maxed = false;\n    result->statusCode = browseWithCp(server, session, &cp, &rr, &maxed);\n    if(result->statusCode != UA_STATUSCODE_GOOD) {\n        RefTree_clear(&cp.rt);\n        RefResult_clear(&rr);\n        return;\n    }\n\n    /* No results */\n    if(rr.size == 0) {\n        result->references = (UA_ReferenceDescription*)UA_EMPTY_ARRAY_SENTINEL;\n        RefTree_clear(&cp.rt);\n        UA_free(rr.descr);\n        return;\n    }\n\n    /* Move results to the output */\n    result->references = rr.descr;\n    result->referencesSize = rr.size;\n\n    /* Nothing left for BrowseNext */\n    if(!maxed) {\n        RefTree_clear(&cp.rt);\n        return;\n    }\n\n    /* Create a new continuation point. */\n    ContinuationPoint *newCp = (ContinuationPoint*)UA_malloc(sizeof(ContinuationPoint));\n    UA_StatusCode retval = UA_STATUSCODE_GOOD;\n    UA_ByteString tmp;\n    if(!newCp) {\n        retval = UA_STATUSCODE_BADOUTOFMEMORY;\n        goto cleanup;\n    }\n    *newCp = cp;\n\n    /* Make a deep copy of the BrowseDescription */\n    retval = UA_BrowseDescription_copy(descr, &newCp->bd);\n    if(retval != UA_STATUSCODE_GOOD)\n        goto cleanup;\n\n    /* Return the cp identifier */\n    tmp.length = sizeof(UA_Guid);\n    tmp.data = (UA_Byte*)&newCp->identifier;\n    retval = UA_ByteString_copy(&tmp, &result->continuationPoint);\n    if(retval != UA_STATUSCODE_GOOD)\n        goto cleanup;\n\n    /* Remove the oldest continuation point if required */\n    if(session->availableContinuationPoints <= 0) {\n        struct ContinuationPoint **prev = &session->continuationPoints;\n        struct ContinuationPoint *cp2 = session->continuationPoints;\n        while(cp2 && cp2->next) {\n            prev = &cp2->next;\n            cp2 = cp2->next;\n        }\n        if(cp2) {\n            *prev = NULL;\n            ContinuationPoint_clear(cp2);\n            UA_free(cp2);\n            ++session->availableContinuationPoints;\n        }\n    }\n\n    /* Attach the cp to the session */\n    newCp->next = session->continuationPoints;\n    session->continuationPoints = newCp;\n    --session->availableContinuationPoints;\n    return;\n\n cleanup:\n    UA_BrowseResult_deleteMembers(result); /* Holds the content that was in rr before */\n    if(newCp) {\n        ContinuationPoint_clear(newCp);\n        UA_free(newCp);\n    }\n    result->statusCode = retval;\n}\n\nstatic UA_StatusCode\nrecursiveCallConstructors(UA_Server *server, UA_Session *session,\n                          const UA_Node *node, const UA_Node *type) {\n    if(node->constructed)\n        return UA_STATUSCODE_GOOD;\n    \n    /* Construct the children */\n    UA_BrowseDescription bd;\n    UA_BrowseDescription_init(&bd);\n    bd.nodeId = node->nodeId;\n    bd.referenceTypeId = UA_NODEID_NUMERIC(0, UA_NS0ID_AGGREGATES);\n    bd.includeSubtypes = true;\n    bd.browseDirection = UA_BROWSEDIRECTION_FORWARD;\n\n    UA_BrowseResult br;\n    UA_BrowseResult_init(&br);\n    struct BrowseOpts bo;\n    bo.maxReferences = 0;\n    bo.recursive = false;\n    Operation_Browse(server, session, &bo, &bd, &br);\n    if(br.statusCode != UA_STATUSCODE_GOOD)\n        return br.statusCode;\n\n    /* Call the constructor for every unconstructed node */\n    UA_StatusCode retval = UA_STATUSCODE_GOOD;\n    for(size_t i = 0; i < br.referencesSize; ++i) {\n        UA_ReferenceDescription *rd = &br.references[i];\n        const UA_Node *target = UA_Nodestore_getNode(server->nsCtx, &rd->nodeId.nodeId);\n        if(!target)\n            continue;\n        if(target->constructed) {\n            UA_Nodestore_releaseNode(server->nsCtx, target);\n            continue;\n        }\n\n        const UA_Node *targetType = NULL;\n        if(node->nodeClass == UA_NODECLASS_VARIABLE ||\n           node->nodeClass == UA_NODECLASS_OBJECT) {\n            targetType = getNodeType(server, target);\n            if(!targetType) {\n                UA_Nodestore_releaseNode(server->nsCtx, target);\n                retval = UA_STATUSCODE_BADTYPEDEFINITIONINVALID;\n                break;\n            }\n        }\n        retval = recursiveCallConstructors(server, session, target, targetType);\n        UA_Nodestore_releaseNode(server->nsCtx, target);\n        if(targetType)\n            UA_Nodestore_releaseNode(server->nsCtx, targetType);\n        if(retval != UA_STATUSCODE_GOOD)\n            break;\n    }\n\n    UA_BrowseResult_deleteMembers(&br);\n\n    /* If a child could not be constructed or the node is already constructed */\n    if(retval != UA_STATUSCODE_GOOD)\n        return retval;\n\n    /* Get the node type constructor */\n    const UA_NodeTypeLifecycle *lifecycle = NULL;\n    if(type && node->nodeClass == UA_NODECLASS_OBJECT) {\n        const UA_ObjectTypeNode *ot = (const UA_ObjectTypeNode*)type;\n        lifecycle = &ot->lifecycle;\n    } else if(type && node->nodeClass == UA_NODECLASS_VARIABLE) {\n        const UA_VariableTypeNode *vt = (const UA_VariableTypeNode*)type;\n        lifecycle = &vt->lifecycle;\n    }\n\n    /* Call the global constructor */\n    void *context = node->context;\n    if(server->config.nodeLifecycle.constructor)\n        retval = server->config.nodeLifecycle.constructor(server, &session->sessionId,\n                                                          session->sessionHandle,\n                                                          &node->nodeId, &context);\n\n    /* Call the type constructor */\n    if(retval == UA_STATUSCODE_GOOD && lifecycle && lifecycle->constructor)\n        retval = lifecycle->constructor(server, &session->sessionId,\n                                        session->sessionHandle, &type->nodeId,\n                                        type->context, &node->nodeId, &context);\n    if(retval != UA_STATUSCODE_GOOD)\n        goto fail1;\n\n    /* Set the context *and* mark the node as constructed */\n    if(retval == UA_STATUSCODE_GOOD)\n        retval = UA_Server_editNode(server, &server->adminSession, &node->nodeId,\n                                    (UA_EditNodeCallback)setConstructedNodeContext,\n                                    context);\n\n    /* All good, return */\n    if(retval == UA_STATUSCODE_GOOD)\n        return retval;\n\n    /* Fail. Call the destructors. */\n    if(lifecycle && lifecycle->destructor)\n        lifecycle->destructor(server, &session->sessionId,\n                              session->sessionHandle, &type->nodeId,\n                              type->context, &node->nodeId, &context);\n\n fail1:\n    if(server->config.nodeLifecycle.destructor)\n        server->config.nodeLifecycle.destructor(server, &session->sessionId,\n                                                session->sessionHandle,\n                                                &node->nodeId, context);\n    return retval;\n}\n\nUA_StatusCode\nAddNode_finish(UA_Server *server, UA_Session *session, const UA_NodeId *nodeId) {\n    UA_StatusCode retval = UA_STATUSCODE_GOOD;\n\n    /* Get the node */\n    const UA_Node *node = UA_Nodestore_getNode(server->nsCtx, nodeId);\n    if(!node)\n        return UA_STATUSCODE_BADNODEIDUNKNOWN;\n\n    const UA_Node *type = NULL;\n\n    /* Instantiate variables and objects */\n    if(node->nodeClass == UA_NODECLASS_VARIABLE ||\n       node->nodeClass == UA_NODECLASS_VARIABLETYPE ||\n       node->nodeClass == UA_NODECLASS_OBJECT) {\n        /* Get the type node */\n        type = getNodeType(server, node);\n        if(!type) {\n            if(server->bootstrapNS0)\n                goto constructor;\n            UA_LOG_NODEID_WRAP(&node->nodeId, UA_LOG_INFO_SESSION(&server->config.logger, session,\n                               \"AddNodes: Node type for %.*s not found\",\n                               (int)nodeIdStr.length, nodeIdStr.data));\n            retval = UA_STATUSCODE_BADTYPEDEFINITIONINVALID;\n            goto cleanup;\n        }\n\n        retval = checkValidBrowseName(server, session, node, type);\n        if(retval != UA_STATUSCODE_GOOD)\n            goto cleanup;\n\n        retval = recursiveTypeCheckAddChildren(server, session, &node, type);\n        if(retval != UA_STATUSCODE_GOOD)\n            goto cleanup;\n    }\n\n    /* Call the constructor(s) */\n constructor:\n    retval = recursiveCallConstructors(server, session, node, type);\n    if(retval != UA_STATUSCODE_GOOD) {\n        UA_LOG_NODEID_WRAP(&node->nodeId, UA_LOG_INFO_SESSION(&server->config.logger, session,\n                           \"AddNodes: Calling the node constructor(s) of %.*s failed \"\n                           \"with status code %s\", (int)nodeIdStr.length,\n                           nodeIdStr.data, UA_StatusCode_name(retval)));\n    }\n\n cleanup:\n    if(type)\n        UA_Nodestore_releaseNode(server->nsCtx, type);\n    if(retval != UA_STATUSCODE_GOOD) {\n        recursiveDeconstructNode(server, session, 0, NULL, node);\n        recursiveDeleteNode(server, session, 0, NULL, node, true);\n    }\n    UA_Nodestore_releaseNode(server->nsCtx, node);\n    return retval;\n}\n\nstatic void\nOperation_addNode(UA_Server *server, UA_Session *session, void *nodeContext,\n                  const UA_AddNodesItem *item, UA_AddNodesResult *result) {\n    result->statusCode =\n        Operation_addNode_begin(server, session, nodeContext, item, &item->parentNodeId.nodeId,\n                                &item->referenceTypeId, &result->addedNodeId);\n    if(result->statusCode != UA_STATUSCODE_GOOD)\n        return;\n\n    /* AddNodes_finish */\n    result->statusCode = AddNode_finish(server, session, &result->addedNodeId);\n\n    /* If finishing failed, the node was deleted */\n    if(result->statusCode != UA_STATUSCODE_GOOD)\n        UA_NodeId_deleteMembers(&result->addedNodeId);\n}\n\nstatic UA_INLINE UA_StatusCode\nUA_Server_addReferenceTypeNode(UA_Server *server,\n                               const UA_NodeId requestedNewNodeId,\n                               const UA_NodeId parentNodeId,\n                               const UA_NodeId referenceTypeId,\n                               const UA_QualifiedName browseName,\n                               const UA_ReferenceTypeAttributes attr,\n                               void *nodeContext, UA_NodeId *outNewNodeId) {\n    return __UA_Server_addNode(server, UA_NODECLASS_REFERENCETYPE,\n                               &requestedNewNodeId, &parentNodeId, &referenceTypeId,\n                               browseName, &UA_NODEID_NULL,\n                               (const UA_NodeAttributes*)&attr,\n                               &UA_TYPES[UA_TYPES_REFERENCETYPEATTRIBUTES],\n                               nodeContext, outNewNodeId);\n}\n\n\n\n\n// target function\nstatic UA_StatusCode\nRefTree_double(RefTree *rt) {\n    size_t capacity = rt->capacity * 2;\n    size_t space = (sizeof(UA_NodeId) + sizeof(RefEntry)) * capacity;\n    UA_NodeId *newTargets = (UA_NodeId*)realloc(rt->targets, space);\n    if(!newTargets)\n        return UA_STATUSCODE_BADOUTOFMEMORY;\n\n    /* Repair the pointers for the realloced array+tree  */\n    uintptr_t arraydiff = (uintptr_t)newTargets - (uintptr_t)rt->targets;\n    RefEntry *reArray = (RefEntry*)\n        ((uintptr_t)newTargets + (capacity * sizeof(UA_NodeId)));\n    uintptr_t entrydiff = (uintptr_t)reArray -\n        ((uintptr_t)rt->targets + (rt->capacity * sizeof(UA_NodeId)));\n    RefEntry *oldReArray = (RefEntry*)\n        ((uintptr_t)newTargets + (rt->capacity * sizeof(UA_NodeId)));\n    memmove(reArray, oldReArray, rt->size * sizeof(RefEntry));\n    for(size_t i = 0; i < rt->size; i++) {\n        if(reArray[i].zipfields.zip_left)\n            *(uintptr_t*)&reArray[i].zipfields.zip_left += entrydiff;\n        if(reArray[i].zipfields.zip_right)\n            *(uintptr_t*)&reArray[i].zipfields.zip_right += entrydiff;\n        *(uintptr_t*)&reArray[i].target += arraydiff;\n    }\n\n    rt->head.zip_root = (RefEntry*)((uintptr_t)rt->head.zip_root + entrydiff);\n    rt->capacity = capacity;\n    rt->targets = newTargets;\n    return UA_STATUSCODE_GOOD;\n}\nvoid\nOperation_Browse(UA_Server *server, UA_Session *session, const struct BrowseOpts *bo,\n                 const UA_BrowseDescription *descr, UA_BrowseResult *result) {\n    /* How many references can we return at most? */\n    UA_UInt32 maxRefs = bo->maxReferences;\n    if(maxRefs == 0) {\n        if(server->config.maxReferencesPerNode != 0) {\n            maxRefs = server->config.maxReferencesPerNode;\n        } else {\n            maxRefs = UA_INT32_MAX;\n        }\n    } else {\n        if(server->config.maxReferencesPerNode != 0 &&\n           maxRefs > server->config.maxReferencesPerNode) {\n            maxRefs = server->config.maxReferencesPerNode;\n        }\n    }\n\n    /* Create the results array */\n    RefResult rr;\n    result->statusCode = RefResult_init(&rr, maxRefs);\n    if(result->statusCode != UA_STATUSCODE_GOOD)\n        return;\n\n    ContinuationPoint cp;\n    ContinuationPoint_init(&cp, maxRefs, bo->recursive);\n    cp.bd = *descr; /* Deep-copy only when the cp is persisted in the session */\n\n    /* Add the initial node to the RefTree */\n    result->statusCode = RefTree_add(&cp.rt, &descr->nodeId);\n    if(result->statusCode != UA_STATUSCODE_GOOD) {\n        RefTree_clear(&cp.rt);\n        RefResult_clear(&rr);\n        return;\n    }\n    \n    /* Recurse to get all references */\n    UA_Boolean maxed = false;\n    result->statusCode = browseWithCp(server, session, &cp, &rr, &maxed);\n    if(result->statusCode != UA_STATUSCODE_GOOD) {\n        RefTree_clear(&cp.rt);\n        RefResult_clear(&rr);\n        return;\n    }\n\n    /* No results */\n    if(rr.size == 0) {\n        result->references = (UA_ReferenceDescription*)UA_EMPTY_ARRAY_SENTINEL;\n        RefTree_clear(&cp.rt);\n        UA_free(rr.descr);\n        return;\n    }\n\n    /* Move results to the output */\n    result->references = rr.descr;\n    result->referencesSize = rr.size;\n\n    /* Nothing left for BrowseNext */\n    if(!maxed) {\n        RefTree_clear(&cp.rt);\n        return;\n    }\n\n    /* Create a new continuation point. */\n    ContinuationPoint *newCp = (ContinuationPoint*)UA_malloc(sizeof(ContinuationPoint));\n    UA_StatusCode retval = UA_STATUSCODE_GOOD;\n    UA_ByteString tmp;\n    if(!newCp) {\n        retval = UA_STATUSCODE_BADOUTOFMEMORY;\n        goto cleanup;\n    }\n    *newCp = cp;\n\n    /* Make a deep copy of the BrowseDescription */\n    retval = UA_BrowseDescription_copy(descr, &newCp->bd);\n    if(retval != UA_STATUSCODE_GOOD)\n        goto cleanup;\n\n    /* Return the cp identifier */\n    tmp.length = sizeof(UA_Guid);\n    tmp.data = (UA_Byte*)&newCp->identifier;\n    retval = UA_ByteString_copy(&tmp, &result->continuationPoint);\n    if(retval != UA_STATUSCODE_GOOD)\n        goto cleanup;\n\n    /* Remove the oldest continuation point if required */\n    if(session->availableContinuationPoints <= 0) {\n        struct ContinuationPoint **prev = &session->continuationPoints;\n        struct ContinuationPoint *cp2 = session->continuationPoints;\n        while(cp2 && cp2->next) {\n            prev = &cp2->next;\n            cp2 = cp2->next;\n        }\n        if(cp2) {\n            *prev = NULL;\n            ContinuationPoint_clear(cp2);\n            UA_free(cp2);\n            ++session->availableContinuationPoints;\n        }\n    }\n\n    /* Attach the cp to the session */\n    newCp->next = session->continuationPoints;\n    session->continuationPoints = newCp;\n    --session->availableContinuationPoints;\n    return;\n\n cleanup:\n    UA_BrowseResult_deleteMembers(result); /* Holds the content that was in rr before */\n    if(newCp) {\n        ContinuationPoint_clear(newCp);\n        UA_free(newCp);\n    }\n    result->statusCode = retval;\n}\n",
    "target": 1,
    "idx": 1015152,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nint\ncdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h,\n    uint32_t offs, cdf_property_info_t **info, size_t *count, size_t *maxcount)\n{\n\tconst cdf_section_header_t *shp;\n\tcdf_section_header_t sh;\n\tconst uint8_t *p, *q, *e;\n\tsize_t i, o4, nelements, j, slen, left;\n\tcdf_property_info_t *inp;\n\n\tif (offs > UINT32_MAX / 4) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tshp = CAST(const cdf_section_header_t *,\n\t    cdf_offset(sst->sst_tab, offs));\n\tif (cdf_check_stream_offset(sst, h, shp, sizeof(*shp), __LINE__) == -1)\n\t\tgoto out;\n\tsh.sh_len = CDF_TOLE4(shp->sh_len);\n\tif (sh.sh_len > CDF_SHLEN_LIMIT) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\n\tif (cdf_check_stream_offset(sst, h, shp, sh.sh_len, __LINE__) == -1)\n\t\tgoto out;\n\n\tsh.sh_properties = CDF_TOLE4(shp->sh_properties);\n\tDPRINTF((\"section len: %u properties %u\\n\", sh.sh_len,\n\t    sh.sh_properties));\n\tif (sh.sh_properties > CDF_PROP_LIMIT)\n\t\tgoto out;\n\tinp = cdf_grow_info(info, maxcount, sh.sh_properties);\n\tif (inp == NULL)\n\t\tgoto out;\n\tinp += *count;\n\t*count += sh.sh_properties;\n\tp = CAST(const uint8_t *, cdf_offset(sst->sst_tab, offs + sizeof(sh)));\n\te = CAST(const uint8_t *, cdf_offset(shp, sh.sh_len));\n\tif (p >= e || cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1)\n\t\tgoto out;\n\n\tfor (i = 0; i < sh.sh_properties; i++) {\n\t\tif ((q = cdf_get_property_info_pos(sst, h, p, e, i)) == NULL)\n\t\t\tgoto out;\n\t\tinp[i].pi_id = CDF_GETUINT32(p, i << 1);\n\t\tleft = CAST(size_t, e - q);\n\t\tif (left < sizeof(uint32_t)) {\n\t\t\tDPRINTF((\"short info (no type)_\\n\"));\n\t\t\tgoto out;\n\t\t}\n\t\tinp[i].pi_type = CDF_GETUINT32(q, 0);\n\t\tDPRINTF((\"%\" SIZE_T_FORMAT \"u) id=%#x type=%#x offs=%#tx,%#x\\n\",\n\t\t    i, inp[i].pi_id, inp[i].pi_type, q - p, offs));\n\t\tif (inp[i].pi_type & CDF_VECTOR) {\n\t\t\tif (left < sizeof(uint32_t) * 2) {\n\t\t\t\tDPRINTF((\"missing CDF_VECTOR length\\n\"));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tnelements = CDF_GETUINT32(q, 1);\n\t\t\tif (nelements > CDF_ELEMENT_LIMIT || nelements == 0) {\n\t\t\t\tDPRINTF((\"CDF_VECTOR with nelements == %\"\n\t\t\t\t    SIZE_T_FORMAT \"u\\n\", nelements));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tslen = 2;\n\t\t} else {\n\t\t\tnelements = 1;\n\t\t\tslen = 1;\n\t\t}\n\t\to4 = slen * sizeof(uint32_t);\n\t\tif (inp[i].pi_type & (CDF_ARRAY|CDF_BYREF|CDF_RESERVED))\n\t\t\tgoto unknown;\n\t\tswitch (inp[i].pi_type & CDF_TYPEMASK) {\n\t\tcase CDF_NULL:\n\t\tcase CDF_EMPTY:\n\t\t\tbreak;\n\t\tcase CDF_SIGNED16:\n\t\t\tif (!cdf_copy_info(&inp[i], &q[o4], e, sizeof(int16_t)))\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tcase CDF_SIGNED32:\n\t\tcase CDF_BOOL:\n\t\tcase CDF_UNSIGNED32:\n\t\tcase CDF_FLOAT:\n\t\t\tif (!cdf_copy_info(&inp[i], &q[o4], e, sizeof(int32_t)))\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tcase CDF_SIGNED64:\n\t\tcase CDF_UNSIGNED64:\n\t\tcase CDF_DOUBLE:\n\t\tcase CDF_FILETIME:\n\t\t\tif (!cdf_copy_info(&inp[i], &q[o4], e, sizeof(int64_t)))\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tcase CDF_LENGTH32_STRING:\n\t\tcase CDF_LENGTH32_WSTRING:\n\t\t\tif (nelements > 1) {\n\t\t\t\tsize_t nelem = inp - *info;\n\t\t\t\tinp = cdf_grow_info(info, maxcount, nelements);\n\t\t\t\tif (inp == NULL)\n\t\t\t\t\tgoto out;\n\t\t\t\tinp += nelem;\n\t\t\t}\n\t\t\tfor (j = 0; j < nelements && i < sh.sh_properties;\n\t\t\t    j++, i++)\n\t\t\t{\n\t\t\t\tuint32_t l;\n\n\t\t\t\tif (o4 + sizeof(uint32_t) > left)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tl = CDF_GETUINT32(q, slen);\n\t\t\t\to4 += sizeof(uint32_t);\n\t\t\t\tif (o4 + l > left)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tinp[i].pi_str.s_len = l;\n\t\t\t\tinp[i].pi_str.s_buf = CAST(const char *,\n\t\t\t\t    CAST(const void *, &q[o4]));\n\n\t\t\t\tDPRINTF((\"o=%\" SIZE_T_FORMAT \"u l=%d(%\"\n\t\t\t\t    SIZE_T_FORMAT \"u), t=%\" SIZE_T_FORMAT\n\t\t\t\t    \"u s=%s\\n\", o4, l, CDF_ROUND(l, sizeof(l)),\n\t\t\t\t    left, inp[i].pi_str.s_buf));\n\n\t\t\t\tif (l & 1)\n\t\t\t\t\tl++;\n\n\t\t\t\tslen += l >> 1;\n\t\t\t\to4 = slen * sizeof(uint32_t);\n\t\t\t}\n\t\t\ti--;\n\t\t\tbreak;\n\t\tcase CDF_CLIPBOARD:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tdefault:\n\t\tunknown:\n\t\t\tmemset(&inp[i].pi_val, 0, sizeof(inp[i].pi_val));\n\t\t\tDPRINTF((\"Don't know how to deal with %#x\\n\",\n\t\t\t    inp[i].pi_type));\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\nout:\n\tfree(*info);\n\t*info = NULL;\n\t*count = 0;\n\t*maxcount = 0;\n\terrno = EFTYPE;\n\treturn -1;\n}\n\nint\ncdf_unpack_summary_info(const cdf_stream_t *sst, const cdf_header_t *h,\n    cdf_summary_info_header_t *ssi, cdf_property_info_t **info, size_t *count)\n{\n\tsize_t maxcount;\n\tconst cdf_summary_info_header_t *si =\n\t    CAST(const cdf_summary_info_header_t *, sst->sst_tab);\n\tconst cdf_section_declaration_t *sd =\n\t    CAST(const cdf_section_declaration_t *, RCAST(const void *,\n\t    RCAST(const char *, sst->sst_tab)\n\t    + CDF_SECTION_DECLARATION_OFFSET));\n\n\tif (cdf_check_stream_offset(sst, h, si, sizeof(*si), __LINE__) == -1 ||\n\t    cdf_check_stream_offset(sst, h, sd, sizeof(*sd), __LINE__) == -1)\n\t\treturn -1;\n\tssi->si_byte_order = CDF_TOLE2(si->si_byte_order);\n\tssi->si_os_version = CDF_TOLE2(si->si_os_version);\n\tssi->si_os = CDF_TOLE2(si->si_os);\n\tssi->si_class = si->si_class;\n\tcdf_swap_class(&ssi->si_class);\n\tssi->si_count = CDF_TOLE4(si->si_count);\n\t*count = 0;\n\tmaxcount = 0;\n\t*info = NULL;\n\tif (cdf_read_property_info(sst, h, CDF_TOLE4(sd->sd_offset), info,\n\t    count, &maxcount) == -1)\n\t\treturn -1;\n\treturn 0;\n}\n\nprivate int\ncdf_file_summary_info(struct magic_set *ms, const cdf_header_t *h,\n    const cdf_stream_t *sst, const cdf_directory_t *root_storage)\n{\n\tcdf_summary_info_header_t si;\n\tcdf_property_info_t *info;\n\tsize_t count;\n\tint m;\n\n\tif (cdf_unpack_summary_info(sst, h, &si, &info, &count) == -1)\n\t\treturn -1;\n\n\tif (NOTMIME(ms)) {\n\t\tconst char *str;\n\n\t\tif (file_printf(ms, \"Composite Document File V2 Document\")\n\t\t    == -1)\n\t\t\treturn -1;\n\n\t\tif (file_printf(ms, \", %s Endian\",\n\t\t    si.si_byte_order == 0xfffe ?  \"Little\" : \"Big\") == -1)\n\t\t\treturn -2;\n\t\tswitch (si.si_os) {\n\t\tcase 2:\n\t\t\tif (file_printf(ms, \", Os: Windows, Version %d.%d\",\n\t\t\t    si.si_os_version & 0xff,\n\t\t\t    CAST(uint32_t, si.si_os_version) >> 8) == -1)\n\t\t\t\treturn -2;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (file_printf(ms, \", Os: MacOS, Version %d.%d\",\n\t\t\t    CAST(uint32_t, si.si_os_version) >> 8,\n\t\t\t    si.si_os_version & 0xff) == -1)\n\t\t\t\treturn -2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (file_printf(ms, \", Os %d, Version: %d.%d\", si.si_os,\n\t\t\t    si.si_os_version & 0xff,\n\t\t\t    CAST(uint32_t, si.si_os_version) >> 8) == -1)\n\t\t\t\treturn -2;\n\t\t\tbreak;\n\t\t}\n\t\tif (root_storage) {\n\t\t\tstr = cdf_clsid_to_mime(root_storage->d_storage_uuid,\n\t\t\t    clsid2desc);\n\t\t\tif (str) {\n\t\t\t\tif (file_printf(ms, \", %s\", str) == -1)\n\t\t\t\t\treturn -2;\n\t\t\t}\n\t\t}\n\t}\n\n\tm = cdf_file_property_info(ms, info, count, root_storage);\n\tfree(info);\n\n\treturn m == -1 ? -2 : m;\n}\n\nprivate int\ncdf_check_summary_info(struct magic_set *ms, const cdf_info_t *info,\n    const cdf_header_t *h, const cdf_sat_t *sat, const cdf_sat_t *ssat,\n    const cdf_stream_t *sst, const cdf_dir_t *dir, cdf_stream_t *scn,\n    const cdf_directory_t *root_storage, const char **expn)\n{\n\tint i;\n\tconst char *str = NULL;\n\tcdf_directory_t *d;\n\tchar name[__arraycount(d->d_name)];\n\tsize_t j, k;\n\n#ifdef CDF_DEBUG\n\tcdf_dump_summary_info(h, scn);\n#endif\n\tif ((i = cdf_file_summary_info(ms, h, scn, root_storage)) < 0) {\n\t    *expn = \"Can't expand summary_info\";\n\t    return i;\n\t}\n\tif (i == 1)\n\t\treturn i;\n\tfor (j = 0; str == NULL && j < dir->dir_len; j++) {\n\t\td = &dir->dir_tab[j];\n\t\tfor (k = 0; k < sizeof(name); k++)\n\t\t\tname[k] = CAST(char, cdf_tole2(d->d_name[k]));\n\t\tstr = cdf_app_to_mime(name,\n\t\t\t\t      NOTMIME(ms) ? name2desc : name2mime);\n\t}\n\tif (NOTMIME(ms)) {\n\t\tif (str != NULL) {\n\t\t\tif (file_printf(ms, \"%s\", str) == -1)\n\t\t\t\treturn -1;\n\t\t\ti = 1;\n\t\t}\n\t} else if (ms->flags & MAGIC_MIME_TYPE) {\n\t\tif (str == NULL)\n\t\t\tstr = \"vnd.ms-office\";\n\t\tif (file_printf(ms, \"application/%s\", str) == -1)\n\t\t\treturn -1;\n\t\ti = 1;\n\t}\n\tif (i <= 0) {\n\t\ti = cdf_file_catalog_info(ms, info, h, sat, ssat, sst,\n\t\t\t\t\t  dir, scn);\n\t}\n\treturn i;\n}\n\nprotected int\nfile_trycdf(struct magic_set *ms, const struct buffer *b)\n{\n\tint fd = b->fd;\n\tconst unsigned char *buf = CAST(const unsigned char *, b->fbuf);\n\tsize_t nbytes = b->flen;\n\tcdf_info_t info;\n\tcdf_header_t h;\n\tcdf_sat_t sat, ssat;\n\tcdf_stream_t sst, scn;\n\tcdf_dir_t dir;\n\tint i;\n\tconst char *expn = \"\";\n\tconst cdf_directory_t *root_storage;\n\n\tscn.sst_tab = NULL;\n\tinfo.i_fd = fd;\n\tinfo.i_buf = buf;\n\tinfo.i_len = nbytes;\n\tif (ms->flags & (MAGIC_APPLE|MAGIC_EXTENSION))\n\t\treturn 0;\n\tif (cdf_read_header(&info, &h) == -1)\n\t\treturn 0;\n#ifdef CDF_DEBUG\n\tcdf_dump_header(&h);\n#endif\n\n\tif ((i = cdf_read_sat(&info, &h, &sat)) == -1) {\n\t\texpn = \"Can't read SAT\";\n\t\tgoto out0;\n\t}\n#ifdef CDF_DEBUG\n\tcdf_dump_sat(\"SAT\", &sat, CDF_SEC_SIZE(&h));\n#endif\n\n\tif ((i = cdf_read_ssat(&info, &h, &sat, &ssat)) == -1) {\n\t\texpn = \"Can't read SSAT\";\n\t\tgoto out1;\n\t}\n#ifdef CDF_DEBUG\n\tcdf_dump_sat(\"SSAT\", &ssat, CDF_SHORT_SEC_SIZE(&h));\n#endif\n\n\tif ((i = cdf_read_dir(&info, &h, &sat, &dir)) == -1) {\n\t\texpn = \"Can't read directory\";\n\t\tgoto out2;\n\t}\n\n\tif ((i = cdf_read_short_stream(&info, &h, &sat, &dir, &sst,\n\t    &root_storage)) == -1) {\n\t\texpn = \"Cannot read short stream\";\n\t\tgoto out3;\n\t}\n#ifdef CDF_DEBUG\n\tcdf_dump_dir(&info, &h, &sat, &ssat, &sst, &dir);\n#endif\n#ifdef notdef\n\tif (root_storage) {\n\t\tif (NOTMIME(ms)) {\n\t\t\tchar clsbuf[128];\n\t\t\tif (file_printf(ms, \"CLSID %s, \",\n\t\t\t    format_clsid(clsbuf, sizeof(clsbuf),\n\t\t\t    root_storage->d_storage_uuid)) == -1)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n#endif\n\n\tif ((i = cdf_read_user_stream(&info, &h, &sat, &ssat, &sst, &dir,\n\t    \"FileHeader\", &scn)) != -1) {\n#define HWP5_SIGNATURE \"HWP Document File\"\n\t\tif (scn.sst_len * scn.sst_ss >= sizeof(HWP5_SIGNATURE) - 1\n\t\t    && memcmp(scn.sst_tab, HWP5_SIGNATURE,\n\t\t    sizeof(HWP5_SIGNATURE) - 1) == 0) {\n\t\t    if (NOTMIME(ms)) {\n\t\t\tif (file_printf(ms,\n\t\t\t    \"Hangul (Korean) Word Processor File 5.x\") == -1)\n\t\t\t    return -1;\n\t\t    } else if (ms->flags & MAGIC_MIME_TYPE) {\n\t\t\tif (file_printf(ms, \"application/x-hwp\") == -1)\n\t\t\t    return -1;\n\t\t    }\n\t\t    i = 1;\n\t\t    goto out5;\n\t\t} else {\n\t\t    cdf_zero_stream(&scn);\n\t\t}\n\t}\n\n\tif ((i = cdf_read_summary_info(&info, &h, &sat, &ssat, &sst, &dir,\n\t    &scn)) == -1) {\n\t\tif (errno != ESRCH) {\n\t\t\texpn = \"Cannot read summary info\";\n\t\t}\n\t} else {\n\t\ti = cdf_check_summary_info(ms, &info, &h,\n\t\t    &sat, &ssat, &sst, &dir, &scn, root_storage, &expn);\n\t\tcdf_zero_stream(&scn);\n\t}\n\tif (i <= 0) {\n\t\tif ((i = cdf_read_doc_summary_info(&info, &h, &sat, &ssat,\n\t\t    &sst, &dir, &scn)) == -1) {\n\t\t\tif (errno != ESRCH) {\n\t\t\t\texpn = \"Cannot read summary info\";\n\t\t\t}\n\t\t} else {\n\t\t\ti = cdf_check_summary_info(ms, &info, &h, &sat, &ssat,\n\t\t\t    &sst, &dir, &scn, root_storage, &expn);\n\t\t}\n\t}\n\tif (i <= 0) {\n\t\ti = cdf_file_dir_info(ms, &dir);\n\t\tif (i < 0)\n\t\t\texpn = \"Cannot read section info\";\n\t}\nout5:\n\tcdf_zero_stream(&scn);\n\tcdf_zero_stream(&sst);\nout3:\n\tfree(dir.dir_tab);\nout2:\n\tfree(ssat.sat_tab);\nout1:\n\tfree(sat.sat_tab);\nout0:\n\t/* If we handled it already, return */\n\tif (i != -1)\n\t\treturn i;\n\t/* Provide a default handler */\n\tif (NOTMIME(ms)) {\n\t\tif (file_printf(ms,\n\t\t    \"Composite Document File V2 Document\") == -1)\n\t\t\treturn -1;\n\t\tif (*expn)\n\t\t\tif (file_printf(ms, \", %s\", expn) == -1)\n\t\t\t\treturn -1;\n\t} else if (ms->flags & MAGIC_MIME_TYPE) {\n\t\tif (file_printf(ms, \"application/CDFV2\") == -1)\n\t\t\treturn -1;\n\t}\n\treturn 1;\n}\n\nprotected int\nfile_buffer(struct magic_set *ms, int fd, struct stat *st,\n    const char *inname __attribute__ ((__unused__)),\n    const void *buf, size_t nb)\n{\n\tint m = 0, rv = 0, looks_text = 0;\n\tconst char *code = NULL;\n\tconst char *code_mime = \"binary\";\n\tconst char *def = \"data\";\n\tconst char *ftype = NULL;\n\tchar *rbuf = NULL;\n\tstruct buffer b;\n\n\tbuffer_init(&b, fd, st, buf, nb);\n\tms->mode = b.st.st_mode;\n\n\tif (nb == 0) {\n\t\tdef = \"empty\";\n\t\tgoto simple;\n\t} else if (nb == 1) {\n\t\tdef = \"very short file (no magic)\";\n\t\tgoto simple;\n\t}\n\n\tif ((ms->flags & MAGIC_NO_CHECK_ENCODING) == 0) {\n\t\tlooks_text = file_encoding(ms, &b, NULL, 0,\n\t\t    &code, &code_mime, &ftype);\n\t}\n\n#ifdef __EMX__\n\tif ((ms->flags & MAGIC_NO_CHECK_APPTYPE) == 0 && inname) {\n\t\tm = file_os2_apptype(ms, inname, &b);\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t(void)fprintf(stderr, \"[try os2_apptype %d]\\n\", m);\n\t\tswitch (m) {\n\t\tcase -1:\n\t\t\treturn -1;\n\t\tcase 0:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 1;\n\t\t}\n\t}\n#endif\n#if HAVE_FORK\n\t/* try compression stuff */\n\tif ((ms->flags & MAGIC_NO_CHECK_COMPRESS) == 0) {\n\t\tm = file_zmagic(ms, &b, inname);\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t(void)fprintf(stderr, \"[try zmagic %d]\\n\", m);\n\t\tif (m) {\n\t\t\tgoto done_encoding;\n\t\t}\n\t}\n#endif\n\t/* Check if we have a tar file */\n\tif ((ms->flags & MAGIC_NO_CHECK_TAR) == 0) {\n\t\tm = file_is_tar(ms, &b);\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t(void)fprintf(stderr, \"[try tar %d]\\n\", m);\n\t\tif (m) {\n\t\t\tif (checkdone(ms, &rv))\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* Check if we have a JSON file */\n\tif ((ms->flags & MAGIC_NO_CHECK_JSON) == 0) {\n\t\tm = file_is_json(ms, &b);\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t(void)fprintf(stderr, \"[try json %d]\\n\", m);\n\t\tif (m) {\n\t\t\tif (checkdone(ms, &rv))\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* Check if we have a CSV file */\n\tif ((ms->flags & MAGIC_NO_CHECK_CSV) == 0) {\n\t\tm = file_is_csv(ms, &b, looks_text);\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t(void)fprintf(stderr, \"[try csv %d]\\n\", m);\n\t\tif (m) {\n\t\t\tif (checkdone(ms, &rv))\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* Check if we have a CDF file */\n\tif ((ms->flags & MAGIC_NO_CHECK_CDF) == 0) {\n\t\tm = file_trycdf(ms, &b);\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t(void)fprintf(stderr, \"[try cdf %d]\\n\", m);\n\t\tif (m) {\n\t\t\tif (checkdone(ms, &rv))\n\t\t\t\tgoto done;\n\t\t}\n\t}\n#ifdef BUILTIN_ELF\n\tif ((ms->flags & MAGIC_NO_CHECK_ELF) == 0 && nb > 5 && fd != -1) {\n\t\tfile_pushbuf_t *pb;\n\t\t/*\n\t\t * We matched something in the file, so this\n\t\t * *might* be an ELF file, and the file is at\n\t\t * least 5 bytes long, so if it's an ELF file\n\t\t * it has at least one byte past the ELF magic\n\t\t * number - try extracting information from the\n\t\t * ELF headers that cannot easily be  extracted\n\t\t * with rules in the magic file. We we don't\n\t\t * print the information yet.\n\t\t */\n\t\tif ((pb = file_push_buffer(ms)) == NULL)\n\t\t\treturn -1;\n\n\t\trv = file_tryelf(ms, &b);\n\t\trbuf = file_pop_buffer(ms, pb);\n\t\tif (rv == -1) {\n\t\t\tfree(rbuf);\n\t\t\trbuf = NULL;\n\t\t}\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t(void)fprintf(stderr, \"[try elf %d]\\n\", m);\n\t}\n#endif\n\n\t/* try soft magic tests */\n\tif ((ms->flags & MAGIC_NO_CHECK_SOFT) == 0) {\n\t\tm = file_softmagic(ms, &b, NULL, NULL, BINTEST, looks_text);\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t(void)fprintf(stderr, \"[try softmagic %d]\\n\", m);\n\t\tif (m == 1 && rbuf) {\n\t\t\tif (file_printf(ms, \"%s\", rbuf) == -1)\n\t\t\t\tgoto done;\n\t\t}\n\t\tif (m) {\n\t\t\tif (checkdone(ms, &rv))\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* try text properties */\n\tif ((ms->flags & MAGIC_NO_CHECK_TEXT) == 0) {\n\n\t\tm = file_ascmagic(ms, &b, looks_text);\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t(void)fprintf(stderr, \"[try ascmagic %d]\\n\", m);\n\t\tif (m) {\n\t\t\tgoto done;\n\t\t}\n\t}\n\nsimple:\n\t/* give up */\n\tif (m == 0) {\n\t\tm = 1;\n\t\trv = file_default(ms, nb);\n\t\tif (rv == 0)\n\t\t\tif (file_printf(ms, \"%s\", def) == -1)\n\t\t\t\trv = -1;\n\t}\n done:\n\tif ((ms->flags & MAGIC_MIME_ENCODING) != 0) {\n\t\tif (ms->flags & MAGIC_MIME_TYPE)\n\t\t\tif (file_printf(ms, \"; charset=\") == -1)\n\t\t\t\trv = -1;\n\t\tif (file_printf(ms, \"%s\", code_mime) == -1)\n\t\t\trv = -1;\n\t}\n#if HAVE_FORK\n done_encoding:\n#endif\n\tfree(rbuf);\n\tbuffer_fini(&b);\n\tif (rv)\n\t\treturn rv;\n\n\treturn m;\n}\n\n\n\n\n// target function\nint\ncdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h,\n    uint32_t offs, cdf_property_info_t **info, size_t *count, size_t *maxcount)\n{\n\tconst cdf_section_header_t *shp;\n\tcdf_section_header_t sh;\n\tconst uint8_t *p, *q, *e;\n\tsize_t i, o4, nelements, j, slen, left;\n\tcdf_property_info_t *inp;\n\n\tif (offs > UINT32_MAX / 4) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tshp = CAST(const cdf_section_header_t *,\n\t    cdf_offset(sst->sst_tab, offs));\n\tif (cdf_check_stream_offset(sst, h, shp, sizeof(*shp), __LINE__) == -1)\n\t\tgoto out;\n\tsh.sh_len = CDF_TOLE4(shp->sh_len);\n\tif (sh.sh_len > CDF_SHLEN_LIMIT) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\n\tif (cdf_check_stream_offset(sst, h, shp, sh.sh_len, __LINE__) == -1)\n\t\tgoto out;\n\n\tsh.sh_properties = CDF_TOLE4(shp->sh_properties);\n\tDPRINTF((\"section len: %u properties %u\\n\", sh.sh_len,\n\t    sh.sh_properties));\n\tif (sh.sh_properties > CDF_PROP_LIMIT)\n\t\tgoto out;\n\tinp = cdf_grow_info(info, maxcount, sh.sh_properties);\n\tif (inp == NULL)\n\t\tgoto out;\n\tinp += *count;\n\t*count += sh.sh_properties;\n\tp = CAST(const uint8_t *, cdf_offset(sst->sst_tab, offs + sizeof(sh)));\n\te = CAST(const uint8_t *, cdf_offset(shp, sh.sh_len));\n\tif (p >= e || cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1)\n\t\tgoto out;\n\n\tfor (i = 0; i < sh.sh_properties; i++) {\n\t\tif ((q = cdf_get_property_info_pos(sst, h, p, e, i)) == NULL)\n\t\t\tgoto out;\n\t\tinp[i].pi_id = CDF_GETUINT32(p, i << 1);\n\t\tleft = CAST(size_t, e - q);\n\t\tif (left < sizeof(uint32_t)) {\n\t\t\tDPRINTF((\"short info (no type)_\\n\"));\n\t\t\tgoto out;\n\t\t}\n\t\tinp[i].pi_type = CDF_GETUINT32(q, 0);\n\t\tDPRINTF((\"%\" SIZE_T_FORMAT \"u) id=%#x type=%#x offs=%#tx,%#x\\n\",\n\t\t    i, inp[i].pi_id, inp[i].pi_type, q - p, offs));\n\t\tif (inp[i].pi_type & CDF_VECTOR) {\n\t\t\tif (left < sizeof(uint32_t) * 2) {\n\t\t\t\tDPRINTF((\"missing CDF_VECTOR length\\n\"));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tnelements = CDF_GETUINT32(q, 1);\n\t\t\tif (nelements == 0) {\n\t\t\t\tDPRINTF((\"CDF_VECTOR with nelements == 0\\n\"));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tslen = 2;\n\t\t} else {\n\t\t\tnelements = 1;\n\t\t\tslen = 1;\n\t\t}\n\t\to4 = slen * sizeof(uint32_t);\n\t\tif (inp[i].pi_type & (CDF_ARRAY|CDF_BYREF|CDF_RESERVED))\n\t\t\tgoto unknown;\n\t\tswitch (inp[i].pi_type & CDF_TYPEMASK) {\n\t\tcase CDF_NULL:\n\t\tcase CDF_EMPTY:\n\t\t\tbreak;\n\t\tcase CDF_SIGNED16:\n\t\t\tif (!cdf_copy_info(&inp[i], &q[o4], e, sizeof(int16_t)))\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tcase CDF_SIGNED32:\n\t\tcase CDF_BOOL:\n\t\tcase CDF_UNSIGNED32:\n\t\tcase CDF_FLOAT:\n\t\t\tif (!cdf_copy_info(&inp[i], &q[o4], e, sizeof(int32_t)))\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tcase CDF_SIGNED64:\n\t\tcase CDF_UNSIGNED64:\n\t\tcase CDF_DOUBLE:\n\t\tcase CDF_FILETIME:\n\t\t\tif (!cdf_copy_info(&inp[i], &q[o4], e, sizeof(int64_t)))\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tcase CDF_LENGTH32_STRING:\n\t\tcase CDF_LENGTH32_WSTRING:\n\t\t\tif (nelements > 1) {\n\t\t\t\tsize_t nelem = inp - *info;\n\t\t\t\tinp = cdf_grow_info(info, maxcount, nelements);\n\t\t\t\tif (inp == NULL)\n\t\t\t\t\tgoto out;\n\t\t\t\tinp += nelem;\n\t\t\t}\n\t\t\tDPRINTF((\"nelements = %\" SIZE_T_FORMAT \"u\\n\",\n\t\t\t    nelements));\n\t\t\tfor (j = 0; j < nelements && i < sh.sh_properties;\n\t\t\t    j++, i++)\n\t\t\t{\n\t\t\t\tuint32_t l;\n\n\t\t\t\tif (o4 + sizeof(uint32_t) > left)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tl = CDF_GETUINT32(q, slen);\n\t\t\t\to4 += sizeof(uint32_t);\n\t\t\t\tif (o4 + l > left)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tinp[i].pi_str.s_len = l;\n\t\t\t\tinp[i].pi_str.s_buf = CAST(const char *,\n\t\t\t\t    CAST(const void *, &q[o4]));\n\n\t\t\t\tDPRINTF((\"o=%\" SIZE_T_FORMAT \"u l=%d(%\"\n\t\t\t\t    SIZE_T_FORMAT \"u), t=%\" SIZE_T_FORMAT\n\t\t\t\t    \"u s=%s\\n\", o4, l, CDF_ROUND(l, sizeof(l)),\n\t\t\t\t    left, inp[i].pi_str.s_buf));\n\n\t\t\t\tif (l & 1)\n\t\t\t\t\tl++;\n\n\t\t\t\tslen += l >> 1;\n\t\t\t\to4 = slen * sizeof(uint32_t);\n\t\t\t}\n\t\t\ti--;\n\t\t\tbreak;\n\t\tcase CDF_CLIPBOARD:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tdefault:\n\t\tunknown:\n\t\t\tmemset(&inp[i].pi_val, 0, sizeof(inp[i].pi_val));\n\t\t\tDPRINTF((\"Don't know how to deal with %#x\\n\",\n\t\t\t    inp[i].pi_type));\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\nout:\n\tfree(*info);\n\t*info = NULL;\n\t*count = 0;\n\t*maxcount = 0;\n\terrno = EFTYPE;\n\treturn -1;\n}\n",
    "target": 1,
    "idx": 1016780,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nGF_EXPORT\ns32 gf_token_get_line(const char *Buffer, u32 Start, u32 Size, char *LineBuffer, u32 LineBufferSize)\n{\n\tu32 offset;\n\ts32 End, Total;\n\tLineBuffer[0] = 0;\n\tif (Start >= Size) return -1;\n\n\toffset = 2;\n\tEnd = gf_token_find(Buffer, Start, Size, \"\\r\\n\");\n\tif (End<0) {\n\t\tEnd = gf_token_find(Buffer, Start, Size, \"\\r\");\n\t\tif (End<0) End = gf_token_find(Buffer, Start, Size, \"\\n\");\n\t\tif (End < 0) return -1;\n\t\toffset = 1;\n\t}\n\n\tTotal = End - Start + offset;\n\tif ((u32) Total >= LineBufferSize) Total = LineBufferSize-1;\n\tmemcpy(LineBuffer, Buffer + Start, Total);\n\tLineBuffer[Total] = 0;\n\treturn (End + offset);\n}\n\n\n\n\n\nstatic Bool rtpin_process_event(GF_Filter *filter, const GF_FilterEvent *evt)\n{\n\tGF_RTPInStream *stream;\n\tGF_RTPIn *ctx = (GF_RTPIn *) gf_filter_get_udta(filter);\n\tBool reset_stream = GF_FALSE;\n\tBool skip_rtsp_teardown = GF_FALSE;\n\n\tif (evt->base.type == GF_FEVT_QUALITY_SWITCH) {\n\t\tgf_rtp_switch_quality(ctx, evt->quality_switch.up);\n\t\treturn GF_TRUE;\n\t}\n\n\t/*ignore commands other than channels one*/\n\tif (!evt->base.on_pid) {\n\t\treturn GF_TRUE;\n\t}\n\n\tstream = rtpin_find_stream(ctx, evt->base.on_pid, 0, NULL, GF_FALSE);\n\tif (!stream) return GF_TRUE;\n\tif (stream->last_err) return GF_TRUE;\n\n\tswitch (evt->base.type) {\n\tcase GF_FEVT_PLAY:\n\n\t\tctx->is_eos = GF_FALSE;\n\n\t\tif ((stream->status==RTP_Running) && ((ctx->last_start_range >= 0) && (ctx->last_start_range==evt->play.start_range)))\n\t\t \treturn GF_TRUE;\n\t\t//stream was canceled due to setup failure\n\t\tif (stream->status == RTP_Unavailable)\n\t\t\treturn GF_TRUE;\n\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_RTP, (\"[RTP] Processing play on channel @%08x - %s\\n\", stream, stream->rtsp ? \"RTSP control\" : \"No control (RTP)\" ));\n\t\t/*is this RTSP or direct RTP?*/\n\t\tstream->flags &= ~RTP_EOS;\n\t\tstream->flags &= ~RTP_EOS_FLUSHED;\n\t\tstream->last_udp_time = 0;\n\n\t\tif (!(stream->flags & RTP_INTERLEAVED)) {\n\t\t\tif (stream->rtp_ch->rtp)\n\t\t\t\tgf_sk_group_register(ctx->sockgroup, stream->rtp_ch->rtp);\n\t\t\tif (stream->rtp_ch->rtcp)\n\t\t\t\tgf_sk_group_register(ctx->sockgroup, stream->rtp_ch->rtcp);\n\t\t}\n\n\t\tif (stream->rtsp) {\n\t\t\t//send a setup if needed\n\t\t\trtpin_check_setup(stream);\n\n\t\t\t//if not aggregated control or no more queued events send a play\n\t\t\tif (! (stream->rtsp->flags & RTSP_AGG_CONTROL) )  {\n\t\t\t\trtpin_rtsp_usercom_send(stream->rtsp, stream, evt);\n\t\t\t\tctx->last_start_range = evt->play.start_range;\n\t\t\t} else {\n\t\t\t//tricky point here: the play events may get at different times depending on the length\n\t\t\t//of each filter chain connected to our output pids.\n\t\t\t//we store the event and wait for no more pending events\n\t\t\t\tif (!ctx->postponed_play_stream) {\n\t\t\t\t\tctx->postponed_play = evt->play;\n\t\t\t\t\tctx->postponed_play_stream = stream;\n\t\t\t\t\tctx->last_start_range = evt->play.start_range;\n\t\t\t\t}\n\t\t\t\tstream->flags &= ~RTP_SKIP_NEXT_COM;\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t} else {\n\t\t\tctx->last_start_range = evt->play.start_range;\n\t\t\tstream->status = RTP_Running;\n\t\t\tctx->cur_mid = stream->mid;\n\n\t\t\tif (stream->rtp_ch) {\n\t\t\t\t//wait for RTCP to perform stream sync\n\t\t\t\tstream->rtcp_init = GF_FALSE;\n\t\t\t\trtpin_stream_init(stream, (stream->flags & RTP_CONNECTED) ? GF_TRUE : GF_FALSE);\n\t\t\t\tgf_rtp_set_info_rtp(stream->rtp_ch, 0, 0, 0);\n\t\t\t} else {\n\t\t\t\t/*direct channel, store current start*/\n\t\t\t\tstream->current_start = evt->play.start_range;\n\t\t\t\tstream->flags |= GF_RTP_NEW_AU;\n\t\t\t\tgf_rtp_depacketizer_reset(stream->depacketizer, GF_FALSE);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase GF_FEVT_STOP:\n\n\t\twhile (1) {\n\t\t\tu32 size = gf_rtp_read_flush(stream->rtp_ch, stream->buffer, stream->rtpin->block_size);\n\t\t\tif (!size) break;\n\t\t\trtpin_stream_on_rtp_pck(stream, stream->buffer, size);\n\t\t}\n\n\t\t/*is this RTSP or direct RTP?*/\n\t\tif (stream->rtsp) {\n\t\t\tif (!ctx->is_eos)\n\t\t\t\trtpin_rtsp_usercom_send(stream->rtsp, stream, evt);\n\t\t\telse\n\t\t\t\tskip_rtsp_teardown=GF_TRUE;\n\t\t} else {\n\t\t\tstream->status = RTP_Connected;\n\t\t\tstream->rtpin->last_ntp = 0;\n\t\t\tstream->flags |= RTP_EOS;\n\t\t}\n\t\tctx->last_start_range = -1.0;\n\t\tstream->rtcp_init = GF_FALSE;\n\t\treset_stream = stream->pck_queue ? GF_TRUE : GF_FALSE;\n\n\t\tif (!(stream->flags & RTP_INTERLEAVED)) {\n\t\t\tif (stream->rtp_ch->rtp)\n\t\t\t\tgf_sk_group_unregister(ctx->sockgroup, stream->rtp_ch->rtp);\n\t\t\tif (stream->rtp_ch->rtcp)\n\t\t\t\tgf_sk_group_unregister(ctx->sockgroup, stream->rtp_ch->rtcp);\n\t\t}\n\t\tif (reset_stream) {\n\t\t\twhile (gf_list_count(stream->pck_queue)) {\n\t\t\t\tGF_FilterPacket *pck = gf_list_pop_front(stream->pck_queue);\n\t\t\t\tgf_filter_pck_send(pck);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase GF_FEVT_SET_SPEED:\n\t\tbreak;\n\tcase GF_FEVT_PAUSE:\n\tcase GF_FEVT_RESUME:\n\t\tif (stream->rtsp)\n\t\t\trtpin_rtsp_usercom_send(stream->rtsp, stream, evt);\n\t\tbreak;\n\tcase GF_FEVT_CONNECT_FAIL:\n\t\t//stream canceled due to setup failure, prevent any further setup on PLAY\n\t\tstream->status = RTP_Unavailable;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!ctx->creds) {\n\t\t//flush rtsp commands\n\t\tif (ctx->session && !skip_rtsp_teardown) {\n\t\t\trtpin_rtsp_process_commands(ctx->session);\n\t\t}\n\t}\n\tif (reset_stream) rtpin_stream_reset_queue(stream);\n\n\t//cancel event\n\treturn GF_TRUE;\n}\n\nstatic void gf_filter_process_task(GF_FSTask *task)\n{\n\tGF_Err e;\n\tBool skip_block_mode = GF_FALSE;\n\tGF_Filter *filter = task->filter;\n\tBool force_block_state_check=GF_FALSE;\n\tgf_assert(task->filter);\n\tgf_assert(filter->freg);\n\tgf_assert(filter->freg->process);\n\ttask->can_swap = 1;\n\n\tfilter->schedule_next_time = 0;\n\n\tif (filter->disabled) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s is disabled, cancelling process\\n\", filter->name));\n\t\tgf_mx_p(task->filter->tasks_mx);\n\t\ttask->filter->process_task_queued = 0;\n\t\tgf_mx_v(task->filter->tasks_mx);\n\t\treturn;\n\t}\n\n\tif (filter->out_pid_connection_pending || filter->detached_pid_inst || filter->caps_negotiate) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s has %s pending, requeuing process\\n\", filter->name, filter->out_pid_connection_pending ? \"connections\" : filter->caps_negotiate ? \"caps negotiation\" : \"input pid reassignments\"));\n\t\t//do not cancel the process task since it might have been triggered by the filter itself,\n\t\t//we would not longer call it\n\t\ttask->requeue_request = GF_TRUE;\n\n \t\tgf_assert(filter->process_task_queued);\n\t\t//in we are during the graph resolution phase, to not ask for RT reschedule: this can post-pone process tasks and change their initial\n\t\t//scheduling order, resulting in random change of input pid declaration, for example:\n\t\t//fin1 -> reframe1 -> fA\n\t\t//fin2 -> reframe2 -> fA\n\t\t//if we postpone by 10 us finX process while wating for rfX->fA setup, depending on the CPU charge fin2 might be rescheduled before fin1\n\t\t//leading to pushing new/pending packets ro reframe2 before reframe1, and having fA declare its pid in the reverse order as the one expected\n\t\t//note that this is only valid for single-thread case, as in multithread we do not guarantee PID declaration order\n\t\tif (!filter->out_pid_connection_pending) {\n\t\t\ttask->schedule_next_time = gf_sys_clock_high_res() + 10000;\n\t\t\tcheck_filter_error(filter, GF_OK, GF_TRUE);\n\t\t}\n\t\treturn;\n\t}\n\tif (filter->removed || filter->finalized) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s has been %s, skipping process\\n\", filter->name, filter->finalized ? \"finalized\" : \"removed\"));\n\t\treturn;\n\t}\n\n\tif (filter->prevent_blocking) skip_block_mode = GF_TRUE;\n\telse if (filter->in_eos_resume) skip_block_mode = GF_TRUE;\n\telse if (filter->session->in_final_flush) skip_block_mode = GF_TRUE;\n\n\t//blocking filter: remove filter process task - task will be reinserted upon unblock()\n\tif (!skip_block_mode && filter->would_block && (filter->would_block + filter->num_out_pids_not_connected == filter->num_output_pids ) ) {\n\t\tgf_mx_p(task->filter->tasks_mx);\n\t\t//it may happen that by the time we get the lock, the filter has been unblocked by another thread. If so, don't skip task\n\t\tif (filter->would_block) {\n\t\t\tfilter->nb_tasks_done--;\n\t\t\ttask->filter->process_task_queued = 0;\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s blocked, skipping process\\n\", filter->name));\n\t\t\tgf_mx_v(task->filter->tasks_mx);\n\t\t\treturn;\n\t\t}\n\t\tgf_mx_v(task->filter->tasks_mx);\n\t}\n\tif (filter->stream_reset_pending) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s has stream reset pending, postponing process\\n\", filter->name));\n\t\tfilter->nb_tasks_done--;\n\t\ttask->requeue_request = GF_TRUE;\n\t\tgf_assert(filter->process_task_queued);\n\t\treturn;\n\t}\n\tgf_assert(filter->process_task_queued);\n\tif (filter->multi_sink_target) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Filter %s is a multi-sink target, process disabled\\n\", filter->name));\n\t\treturn;\n\t}\n\n\t//the following breaks demuxers where PIDs are not all known from start: if we filter some pids due to user request,\n\t//we may end up with the following test true but not all PIDs yet declared, hence no more processing\n\t//we could add a filter cap for that, but for now we simply rely on the blocking mode algo only\n#if 0\n\tif (filter->num_output_pids && (filter->num_out_pids_not_connected==filter->num_output_pids)) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s has no valid connected outputs, skipping process\\n\", filter->name));\n\t\treturn;\n\t}\n#endif\n\n\t//we have postponed packets on filter, flush them\n\tif (task->filter->postponed_packets) {\n\t\twhile (gf_list_count(task->filter->postponed_packets)) {\n\t\t\tGF_FilterPacket *pck = gf_list_pop_front(task->filter->postponed_packets);\n\t\t\te = gf_filter_pck_send_internal(pck, GF_FALSE);\n\t\t\tif (e==GF_PENDING_PACKET) {\n\t\t\t\t//packet is pending so was added at the end of our postponed queue - remove from queue and reinsert in front\n\t\t\t\tgf_list_del_item(task->filter->postponed_packets, pck);\n\t\t\t\tgf_list_insert(task->filter->postponed_packets, pck, 0);\n\t\t\t\ttask->requeue_request = GF_TRUE;\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s still has postponed packets, postponing process\\n\", filter->name));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tgf_list_del(task->filter->postponed_packets);\n\t\ttask->filter->postponed_packets = NULL;\n\t}\n\tFSESS_CHECK_THREAD(filter)\n\n\tfilter->nb_pck_io = 0;\n\n\tif (filter->nb_caps_renegotiate) {\n\t\tgf_filter_renegotiate_output(filter, GF_FALSE);\n\t}\n\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s process\\n\", filter->name));\n\tgf_rmt_begin_hash(filter->name, GF_RMT_AGGREGATE, &filter->rmt_hash);\n\n\tfilter->in_process_callback = GF_TRUE;\n\n#ifdef GPAC_MEMORY_TRACKING\n\tif (filter->session->check_allocs)\n\t\te = gf_filter_process_check_alloc(filter);\n\telse\n#endif\n\t\te = filter->freg->process(filter);\n\n\tfilter->in_process_callback = GF_FALSE;\n\tgf_rmt_end();\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s process done\\n\", filter->name));\n\n\t//flush all pending pid init requests following the call to init\n\tif (filter->has_pending_pids) {\n\t\tfilter->has_pending_pids=GF_FALSE;\n\t\twhile (gf_fq_count(filter->pending_pids)) {\n\t\t\tGF_FilterPid *pid=gf_fq_pop(filter->pending_pids);\n\t\t\tgf_filter_pid_post_init_task(filter, pid);\n\t\t}\n\t}\n\t//no requeue if end of session\n\tif (session_should_abort(filter->session)) {\n\t\treturn;\n\t}\n\t//if eos but we still have pending packets or process tasks queued, move to GF_OK so that\n\t//we evaluate the blocking state\n\tif (e==GF_EOS) {\n\t\tif (filter->postponed_packets) {\n\t\t \te = GF_OK;\n\t\t} else if (filter->process_task_queued) {\n\t\t\te = GF_OK;\n\t\t\tforce_block_state_check = GF_TRUE;\n\t\t}\n\t}\n\n\tif ((e==GF_EOS) || filter->removed || filter->finalized) {\n\t\tgf_mx_p(filter->tasks_mx);\n\t\tfilter->process_task_queued = 0;\n\t\tgf_mx_v(filter->tasks_mx);\n\t\treturn;\n\t}\n\n\tif ((e==GF_PROFILE_NOT_SUPPORTED) && filter->has_out_caps && !(filter->session->flags & GF_FS_FLAG_NO_REASSIGN)) {\n\t\tu32 i;\n\t\t//disconnect all other inputs, and post a re-init\n\t\tgf_mx_p(filter->tasks_mx);\n\t\tfor (i=0; i<filter->num_input_pids; i++) {\n\t\t\tGF_FilterPidInst *a_pidinst = gf_list_get(filter->input_pids, i);\n\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"Codec/Profile not supported for filter %s - blacklisting as output from %s and retrying connections\\n\", filter->name, a_pidinst->pid->filter->name));\n\n\t\t\tgf_list_add(a_pidinst->pid->filter->blacklisted, (void *) filter->freg);\n\n\t\t\tgf_filter_relink_dst(a_pidinst, e);\n\t\t}\n\t\tfilter->process_task_queued = 0;\n\t\tgf_mx_v(filter->tasks_mx);\n\t\treturn;\n\t}\n\tcheck_filter_error(filter, e, GF_FALSE);\n\n\t//source filters, flush data if enough space available.\n\tif ( (!filter->num_output_pids || (filter->would_block + filter->num_out_pids_not_connected < filter->num_output_pids) )\n\t\t&& !filter->input_pids\n\t\t&& (e!=GF_EOS)\n\t\t&& !force_block_state_check\n\t) {\n\t\tif (filter->schedule_next_time)\n\t\t\ttask->schedule_next_time = filter->schedule_next_time;\n\t\ttask->requeue_request = GF_TRUE;\n\t\tgf_assert(filter->process_task_queued);\n\t}\n\t//filter requested a requeue\n\telse if (filter->schedule_next_time) {\n\t\tif (!filter->session->in_final_flush) {\n\t\t\ttask->schedule_next_time = filter->schedule_next_time;\n\t\t\ttask->requeue_request = GF_TRUE;\n\t\t\tgf_assert(filter->process_task_queued);\n\t\t}\n\t}\n\t//last task for filter but pending packets and not blocking, requeue in main scheduler\n\telse if ((filter->would_block < filter->num_output_pids)\n\t\t\t&& filter->pending_packets\n\t\t\t&& (gf_fq_count(filter->tasks)<=1)\n\t) {\n\t\t//prune eos packets that could still be present\n\t\tif (filter->pending_packets && filter->session->in_final_flush) {\n\t\t\tu32 i;\n\t\t\tfor (i=0; i<filter->num_input_pids; i++) {\n\t\t\t\tGF_FilterPidInst *pidi = gf_list_get(filter->input_pids, i);\n\t\t\t\tgf_filter_pid_get_packet((GF_FilterPid *)pidi);\n\t\t\t}\n\t\t\tif (!filter->num_input_pids)\n\t\t\t\tfilter->pending_packets = 0;\n\t\t}\n\t\ttask->requeue_request = GF_TRUE;\n\t\ttask->can_swap = 2;\n\t\tgf_assert(filter->process_task_queued);\n\t}\n\telse {\n\t\tgf_assert (!filter->schedule_next_time);\n\t\tgf_filter_check_pending_tasks(filter, task);\n\t\tif (task->requeue_request) {\n\t\t\ttask->can_swap = 2;\n\t\t\tgf_assert(filter->process_task_queued);\n\t\t}\n\t}\n}\n\nstatic u32 gf_fs_thread_proc(GF_SessionThread *sess_thread)\n{\n\tGF_FilterSession *fsess = sess_thread->fsess;\n#ifndef GPAC_DISABLE_THREADS\n\tu32 i;\n\tu32 th_count = fsess->threads ? gf_list_count(fsess->threads) : 0;\n\tu32 thid =  1 + gf_list_find(fsess->threads, sess_thread);\n#else\n\tu32 th_count = 0;\n\tu32 thid = 0;\n#endif\n\tu64 enter_time = gf_sys_clock_high_res();\n\tBool use_main_sema = thid ? GF_FALSE : GF_TRUE;\n#ifndef GPAC_DISABLE_LOG\n\tu32 sys_thid = gf_th_id();\n#endif\n\tu64 next_task_schedule_time = 0;\n\tBool do_regulate = (fsess->flags & GF_FS_FLAG_NO_REGULATION) ? GF_FALSE : GF_TRUE;\n\tu32 consecutive_filter_tasks=0;\n\tBool force_secondary_tasks = GF_FALSE;\n\tBool skip_next_sema_wait = GF_FALSE;\n\tGF_Filter *current_filter = NULL;\n\n#if defined(GPAC_CONFIG_EMSCRIPTEN) && !defined(GPAC_DISABLE_THREADS)\n\tBool flush_main_blocking = (!thid && !fsess->is_worker) ? GF_TRUE : GF_FALSE;\n\tif (flush_main_blocking) do_regulate = GF_FALSE;\n#endif\n\n\t//main thread\n\tif (!thid) {\n\t\tif (!sess_thread->run_time) {\n\t\t\tsess_thread->run_time = enter_time;\n\t\t}\n\t\tif (fsess->non_blocking) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Main thread proc enter\\n\"));\n\t\t}\n\t}\n\t//first time we enter the thread proc\n\tif (!sess_thread->th_id) {\n\t\tsess_thread->th_id = gf_th_id();\n#ifdef GPAC_CONFIG_EMSCRIPTEN\n\t\tif (fsess->non_blocking && thid) {\n\t\t\tsess_thread->run_time = 0;\n\t\t\tsafe_int_dec(&fsess->pending_threads);\n\t\t}\n#endif\n\n#ifndef GPAC_DISABLE_REMOTERY\n\t\tgf_rmt_set_thread_name(sess_thread->rmt_name);\n#endif\n\t}\n\n#ifndef GPAC_DISABLE_REMOTERY\n\tsess_thread->rmt_tasks=40;\n#endif\n\n\tgf_rmt_begin(fs_thread, 0);\n\n\tsafe_int_inc(&fsess->active_threads);\n\n\twhile (1) {\n\t\tBool notified;\n\t\tBool requeue = GF_FALSE;\n\t\tu64 active_start, task_time;\n\t\tGF_FSTask *task=NULL;\n#ifdef CHECK_TASK_LIST_INTEGRITY\n\t\tGF_Filter *prev_current_filter = NULL;\n\t\tBool skip_filter_task_check = GF_FALSE;\n#endif\n\n\t\tif ((fsess->dbg_flags & GF_FS_DEBUG_CONTINUOUS) && !thid) {\n\t\t\tgf_fs_print_debug_info(fsess, fsess->dbg_flags ? fsess->dbg_flags : GF_FS_DEBUG_ALL);\n\t\t}\n\n#ifndef GPAC_DISABLE_REMOTERY\n\t\tsess_thread->rmt_tasks--;\n\t\tif (!sess_thread->rmt_tasks) {\n\t\t\tgf_rmt_end();\n\t\t\tgf_rmt_begin(fs_thread, 0);\n\t\t\tsess_thread->rmt_tasks=40;\n\t\t}\n#endif\n\n#if defined(GPAC_CONFIG_EMSCRIPTEN) && !defined(GPAC_DISABLE_THREADS)\n\t\tif (flush_main_blocking)\n\t\t\temscripten_main_thread_process_queued_calls();\n#endif\n\n\t\tsafe_int_dec(&fsess->active_threads);\n\n\t\tif (!skip_next_sema_wait && (current_filter==NULL)) {\n\t\t\tgf_rmt_begin(sema_wait, GF_RMT_AGGREGATE);\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u Waiting scheduler %s semaphore\\n\", sys_thid, use_main_sema ? \"main\" : \"secondary\"));\n\t\t\t//wait for something to be done\n\t\t\tgf_fs_sema_io(fsess, GF_FALSE, use_main_sema);\n\t\t\tconsecutive_filter_tasks = 0;\n\t\t\tgf_rmt_end();\n#ifdef GPAC_CONFIG_EMSCRIPTEN\n\t\t\t//no tasks on main thread, exit setting in_main_sem_wait to trigger a NOT_READY on fs_run\n\t\t\t//this will give control back to JS\n\t\t\tif (use_main_sema && fsess->non_blocking && !gf_fq_count(fsess->main_thread_tasks)) {\n\t\t\t\tsafe_int_inc(&fsess->active_threads);\n\t\t\t\tfsess->in_main_sem_wait=1;\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n\t\t}\n\t\tsafe_int_inc(&fsess->active_threads);\n\t\tskip_next_sema_wait = GF_FALSE;\n\n\t\tactive_start = gf_sys_clock_high_res();\n\n\t\tif (current_filter==NULL) {\n\t\t\t//main thread\n\t\t\tif (thid==0) {\n\t\t\t\tif (!force_secondary_tasks) {\n\t\t\t\t\ttask = gf_fq_pop(fsess->main_thread_tasks);\n\t\t\t\t}\n\t\t\t\tif (!task) {\n\t\t\t\t\ttask = gf_fq_pop(fsess->tasks);\n\t\t\t\t\t//if task is blocking, don't use it, let a secondary thread deal with it\n\t\t\t\t\tif (task && task->blocking) {\n\t\t\t\t\t\tgf_fq_add(fsess->tasks, task);\n\t\t\t\t\t\ttask = NULL;\n\t\t\t\t\t\tgf_fs_sema_io(fsess, GF_TRUE, GF_FALSE);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tforce_secondary_tasks = GF_FALSE;\n\t\t\t} else {\n\t\t\t\ttask = gf_fq_pop(fsess->tasks);\n\t\t\t\tif (task && (task->force_main || (task->filter && task->filter->nb_main_thread_forced) ) ) {\n\t\t\t\t\t//post to main\n\t\t\t\t\tgf_fq_add(fsess->main_thread_tasks, task);\n\t\t\t\t\tgf_fs_sema_io(fsess, GF_TRUE, GF_TRUE);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_assert(!task || task->run_task );\n\t\t\tgf_assert(!task || task->notified );\n\t\t} else {\n\t\t\t//keep task in filter tasks list until done\n\t\t\ttask = gf_fq_head(current_filter->tasks);\n\t\t\tif (task) {\n\t\t\t\tgf_assert( task->run_task );\n\t\t\t\tgf_assert( ! task->notified );\n\n\t\t\t\t//task was requested for main thread\n\t\t\t\tif ((task->force_main || current_filter->nb_main_thread_forced) && thid) {\n\t\t\t\t\t//make task notified and increase pending tasks\n\t\t\t\t\ttask->notified = GF_TRUE;\n\t\t\t\t\tsafe_int_inc(&fsess->tasks_pending);\n\n\t\t\t\t\t//post to main\n\t\t\t\t\tgf_fq_add(fsess->main_thread_tasks, task);\n\t\t\t\t\tgf_fs_sema_io(fsess, GF_TRUE, GF_TRUE);\n\t\t\t\t\t//disable current filter\n\t\t\t\t\tcurrent_filter = NULL;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!task) {\n\t\t\tu32 force_nb_notif = 0;\n\t\t\tnext_task_schedule_time = 0;\n\t\t\t//no more task and EOS signal\n\t\t\tif (fsess->run_status != GF_OK)\n\t\t\t\tbreak;\n\n\t\t\tif (!fsess->tasks_pending && fsess->main_th.has_seen_eot) {\n\t\t\t\t//check all threads\n\t\t\t\tBool all_done = GF_TRUE;\n\n#ifndef GPAC_DISABLE_THREADS\n\t\t\t\tfor (i=0; i<th_count; i++) {\n\t\t\t\t\tGF_SessionThread *st = gf_list_get(fsess->threads, i);\n\t\t\t\t\tif (!st->has_seen_eot) {\n\t\t\t\t\t\tall_done = GF_FALSE;\n\t\t\t\t\t\tforce_nb_notif++;\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t\tif (all_done)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (current_filter) {\n\t\t\t\tcurrent_filter->scheduled_for_next_task = GF_FALSE;\n\t\t\t\tcurrent_filter->process_th_id = 0;\n\t\t\t\tgf_assert(current_filter->in_process);\n\t\t\t\tcurrent_filter->in_process = GF_FALSE;\n\t\t\t}\n\t\t\tcurrent_filter = NULL;\n\t\t\tsess_thread->active_time += gf_sys_clock_high_res() - active_start;\n\n\n\t\t\t//no pending tasks and first time main task queue is empty, flush to detect if we\n\t\t\t//are indeed done\n\t\t\tif (!fsess->tasks_pending && !fsess->tasks_in_process && !sess_thread->has_seen_eot && !gf_fq_count(fsess->tasks)) {\n\t\t\t\t//maybe last task, force a notify to check if we are truly done\n\t\t\t\tsess_thread->has_seen_eot = GF_TRUE;\n\t\t\t\t//not main thread and some tasks pending on main, notify only ourselves\n\t\t\t\tif (thid && gf_fq_count(fsess->main_thread_tasks)) {\n\t\t\t\t\tgf_fs_sema_io(fsess, GF_TRUE, use_main_sema);\n\t\t\t\t}\n\t\t\t\t//main thread exit probing, send a notify to main sema (for this thread), and N for the secondary one\n\t\t\t\telse {\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u notify scheduler main semaphore\\n\", gf_th_id()));\n\t\t\t\t\tgf_sema_notify(fsess->semaphore_main, 1);\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u notify scheduler secondary semaphore %d\\n\", gf_th_id(), th_count));\n\t\t\t\t\tgf_sema_notify(fsess->semaphore_other, th_count);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//this thread and the main thread are done but we still have unfinished threads, re-notify everyone\n\t\t\telse if (!fsess->tasks_pending && fsess->main_th.has_seen_eot && force_nb_notif) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u notify scheduler main semaphore\\n\", gf_th_id()));\n\t\t\t\tgf_sema_notify(fsess->semaphore_main, 1);\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u notify scheduler secondary semaphore %d\\n\", gf_th_id(), th_count));\n\t\t\t\tgf_sema_notify(fsess->semaphore_other, th_count);\n\t\t\t}\n\n\t\t\t//no main thread, return\n\t\t\tif (!thid && fsess->non_blocking) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Main thread proc exit\\n\"));\n\t\t\t\tsafe_int_dec(&fsess->active_threads);\n\t\t\t\treturn 0;\n\t\t\t}\n\n#if defined(GPAC_CONFIG_EMSCRIPTEN) && !defined(GPAC_DISABLE_THREADS)\n\t\t\tif (thid && (fsess->run_status == GF_OK)) {\n\t\t\t\tsess_thread->run_time += gf_sys_clock_high_res() - enter_time;\n\t\t\t\tsafe_int_dec(&fsess->active_threads);\n\t\t\t\tgf_th_async_call(sess_thread->th, (gf_thread_run) gf_fs_thread_proc, sess_thread);\n\t\t\t\treturn 0;\n\t\t\t}\n#endif\n\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u: no task available\\n\", sys_thid));\n\n\t\t\tif (do_regulate) {\n\t\t\t\tgf_sleep(0);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n#ifdef CHECK_TASK_LIST_INTEGRITY\n\t\tcheck_task_list(fsess->main_thread_tasks, task);\n\t\tcheck_task_list(fsess->tasks, task);\n#endif\n\t\tgf_assert(!current_filter || (current_filter==task->filter));\n\n\t\tcurrent_filter = task->filter;\n\n\t\t//unless task was explicitly forced to main (pid init mostly), reschedule if filter is not on desired thread\n\t\tif (current_filter && !task->force_main\n\t\t\t&& current_filter->restrict_th_idx\n\t\t\t&& (thid != current_filter->restrict_th_idx)\n\t\t) {\n\t\t\t//reschedule task to secondary list\n\t\t\tif (!task->notified) {\n\t\t\t\ttask->notified = GF_TRUE;\n\t\t\t\tsafe_int_inc(&fsess->tasks_pending);\n\t\t\t}\n\t\t\tgf_fq_add(fsess->tasks, task);\n\t\t\tgf_fs_sema_io(fsess, GF_TRUE, GF_FALSE);\n\t\t\tcurrent_filter = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t//this is a crude way of scheduling the next task, we should\n\t\t//1- have a way to make sure we will not repost after a time-consuming task\n\t\t//2- have a way to wait for the given amount of time rather than just do a sema_wait/notify in loop\n\t\tif (task->schedule_next_time) {\n\t\t\ts64 now = gf_sys_clock_high_res();\n\t\t\ts64 diff = task->schedule_next_time;\n\t\t\tdiff -= now;\n\t\t\tdiff /= 1000;\n\n\n\t\t\tif (diff > 0) {\n\t\t\t\tGF_FSTask *next;\n\t\t\t\ts64 tdiff = diff;\n\t\t\t\ts64 ndiff = 0;\n\n\t\t\t\t//no filter, just reschedule the task\n\t\t\t\tif (!current_filter) {\n#ifndef GPAC_DISABLE_LOG\n\t\t\t\t\tconst char *task_log_name = task->log_name;\n#endif\n\t\t\t\t\tnext = gf_fq_head(fsess->tasks);\n\t\t\t\t\tnext_task_schedule_time = task->schedule_next_time;\n\t\t\t\t\tgf_assert(task->run_task);\n#ifdef CHECK_TASK_LIST_INTEGRITY\n\t\t\t\t\tcheck_task_list(fsess->main_thread_tasks, task);\n\t\t\t\t\tcheck_task_list(fsess->tasks, task);\n\t\t\t\t\tcheck_task_list(fsess->tasks_reservoir, task);\n#endif\n\t\t\t\t\t//tasks without filter are currently only posted to the secondary task list\n\t\t\t\t\tgf_fq_add(fsess->tasks, task);\n\t\t\t\t\tif (next) {\n\t\t\t\t\t\tif (next->schedule_next_time <= (u64) now) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u: task %s reposted, next task time ready for execution\\n\", sys_thid, task_log_name));\n\n\t\t\t\t\t\t\tskip_next_sema_wait = GF_TRUE;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tndiff = next->schedule_next_time;\n\t\t\t\t\t\tndiff -= now;\n\t\t\t\t\t\tndiff /= 1000;\n\t\t\t\t\t\tif (ndiff<diff) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u: task %s scheduled after next task %s:%s (in %d ms vs %d ms)\\n\", sys_thid, task_log_name, next->log_name, next->filter ? next->filter->name : \"\", (s32) diff, (s32) ndiff));\n\t\t\t\t\t\t\tdiff = ndiff;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!do_regulate) {\n\t\t\t\t\t\tdiff = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (diff && do_regulate) {\n\t\t\t\t\t\tif (diff > fsess->max_sleep)\n\t\t\t\t\t\t\tdiff = fsess->max_sleep;\n\t\t\t\t\t\tif (th_count==0) {\n\t\t\t\t\t\t\tif ( gf_fq_count(fsess->tasks) > MONOTH_MIN_TASKS)\n\t\t\t\t\t\t\t\tdiff = MONOTH_MIN_SLEEP;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u: task %s reposted, %s task scheduled after this task, sleeping for %d ms (task diff %d - next diff %d)\\n\", sys_thid, task_log_name, next ? \"next\" : \"no\", diff, tdiff, ndiff));\n\t\t\t\t\t\tgf_sleep((u32) diff);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u: task %s reposted, next task scheduled after this task, rerun\\n\", sys_thid, task_log_name));\n\t\t\t\t\t}\n\t\t\t\t\tskip_next_sema_wait = GF_TRUE;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (!task->filter->finalized) {\n#ifdef CHECK_TASK_LIST_INTEGRITY\n\t\t\t\t\tnext = gf_fq_head(current_filter->tasks);\n\t\t\t\t\tgf_assert(next == task);\n\t\t\t\t\tcheck_task_list(fsess->main_thread_tasks, task);\n\t\t\t\t\tcheck_task_list(fsess->tasks_reservoir, task);\n#endif\n\n\t\t\t\t\t//next in filter should be handled before this task, move task at the end of the filter task\n\t\t\t\t\tnext = gf_fq_get(current_filter->tasks, 1);\n\t\t\t\t\tif (next && next->schedule_next_time < task->schedule_next_time) {\n\t\t\t\t\t\tif (task->notified) {\n\t\t\t\t\t\t\tgf_assert(fsess->tasks_pending);\n\t\t\t\t\t\t\tsafe_int_dec(&fsess->tasks_pending);\n\t\t\t\t\t\t\ttask->notified = GF_FALSE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u: task %s:%s reposted to filter task until task exec time is reached (%d us)\\n\", sys_thid, current_filter->name, task->log_name, (s32) (task->schedule_next_time - next->schedule_next_time) ));\n\t\t\t\t\t\t//remove task\n\t\t\t\t\t\tgf_fq_pop(current_filter->tasks);\n\t\t\t\t\t\t//and queue it after the next one\n\t\t\t\t\t\tgf_fq_add(current_filter->tasks, task);\n\t\t\t\t\t\t//and continue with the same filter\n#if defined(GPAC_CONFIG_EMSCRIPTEN) && !defined(GPAC_DISABLE_THREADS)\n\t\t\t\t\t\tif (thid && (fsess->run_status == GF_OK)) {\n\t\t\t\t\t\t\tsess_thread->run_time += gf_sys_clock_high_res() - enter_time;\n\t\t\t\t\t\t\tsafe_int_dec(&fsess->active_threads);\n\t\t\t\t\t\t\tgf_th_async_call(sess_thread->th, (gf_thread_run) gf_fs_thread_proc, sess_thread);\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t//little optim here: if this is the main thread and we have other tasks pending\n\t\t\t\t\t//check the timing of tasks in the secondary list. If a task is present with smaller time than\n\t\t\t\t\t//the head of the main task, force a temporary swap to the secondary task list\n\t\t\t\t\tif (!thid && task->notified && (diff > MONOTH_MIN_SLEEP) ) {\n\t\t\t\t\t\tu32 idx=0;\n\t\t\t\t\t\twhile (1) {\n\t\t\t\t\t\t\tnext = gf_fq_get(fsess->tasks, idx);\n\t\t\t\t\t\t\tif (!next || next->blocking) break;\n\t\t\t\t\t\t\tidx++;\n\n\t\t\t\t\t\t\tu64 next_time_main = task->schedule_next_time;\n\t\t\t\t\t\t\tu64 next_time_secondary = next->schedule_next_time;\n\t\t\t\t\t\t\t//if we have several threads, also check the next task on the main task list\n\t\t\t\t\t\t\t// (different from secondary tasks in multithread case)\n\t\t\t\t\t\t\tif (th_count) {\n\t\t\t\t\t\t\t\tGF_FSTask *next_main = gf_fq_head(fsess->main_thread_tasks);\n\t\t\t\t\t\t\t\tif (next_main && (next_time_main > next_main->schedule_next_time))\n\t\t\t\t\t\t\t\t\tnext_time_main = next_main->schedule_next_time;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (next_time_secondary<next_time_main) {\n\t\t\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u: forcing secondary task list on main - current task schedule time \"LLU\" (diff to now %d) vs next time secondary \"LLU\" (%s::%s)\\n\", sys_thid, task->schedule_next_time, (s32) diff, next_time_secondary, next->filter ? next->filter->freg->name : \"\", next->log_name));\n\t\t\t\t\t\t\t\tdiff = 0;\n\t\t\t\t\t\t\t\tforce_secondary_tasks = GF_TRUE;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t//move task to main list\n\t\t\t\t\tif (!task->notified) {\n\t\t\t\t\t\ttask->notified = GF_TRUE;\n\t\t\t\t\t\tsafe_int_inc(&fsess->tasks_pending);\n\t\t\t\t\t}\n\n\t\t\t\t\tsess_thread->active_time += gf_sys_clock_high_res() - active_start;\n\n\t\t\t\t\tif (next_task_schedule_time && (next_task_schedule_time <= task->schedule_next_time)) {\n\t\t\t\t\t\ttdiff = next_task_schedule_time;\n\t\t\t\t\t\ttdiff -= now;\n\t\t\t\t\t\tif (tdiff < 0) tdiff=0;\n\t\t\t\t\t\tif (tdiff<diff) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u: next task has earlier exec time than current task %s:%s, adjusting sleep (old %d - new %d)\\n\", sys_thid, current_filter->name, task->log_name, (s32) diff, (s32) tdiff));\n\t\t\t\t\t\t\tdiff = tdiff;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u: next task has earlier exec time#2 than current task %s:%s, adjusting sleep (old %d - new %d)\\n\", sys_thid, current_filter->name, task->log_name, (s32) diff, (s32) tdiff));\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (do_regulate && diff) {\n\t\t\t\t\t\tif (diff > fsess->max_sleep)\n\t\t\t\t\t\t\tdiff = fsess->max_sleep;\n\t\t\t\t\t\tif (th_count==0) {\n\t\t\t\t\t\t\tif ( gf_fq_count(fsess->tasks) > MONOTH_MIN_TASKS)\n\t\t\t\t\t\t\t\tdiff = MONOTH_MIN_SLEEP;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u: task %s:%s postponed for %d ms (scheduled time \"LLU\" us, next task schedule \"LLU\" us)\\n\", sys_thid, current_filter->name, task->log_name, (s32) diff, task->schedule_next_time, next_task_schedule_time));\n\n\t\t\t\t\t\tgf_sleep((u32) diff);\n\t\t\t\t\t\tactive_start = gf_sys_clock_high_res();\n\t\t\t\t\t}\n\t\t\t\t\tdiff = (s64)task->schedule_next_time;\n\t\t\t\t\tdiff -= (s64) gf_sys_clock_high_res();\n\t\t\t\t\tif (diff > 100 ) {\n\t\t\t\t\t\tu32 pending_tasks;\n\t\t\t\t\t\tBool use_main = (current_filter->freg->flags & GF_FS_REG_MAIN_THREAD) ? GF_TRUE : GF_FALSE;\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u: releasing current filter %s, exec time for %s due in \"LLD\" us\\n\", sys_thid, current_filter->name, task->log_name, diff));\n\t\t\t\t\t\tcurrent_filter->process_th_id = 0;\n\t\t\t\t\t\tcurrent_filter->in_process = GF_FALSE;\n\t\t\t\t\t\t//don't touch the current filter tasks, just repost the task to the main/secondary list\n\t\t\t\t\t\tgf_assert(gf_fq_count(current_filter->tasks));\n\t\t\t\t\t\tcurrent_filter = NULL;\n\n#ifdef CHECK_TASK_LIST_INTEGRITY\n\t\t\t\t\t\tcheck_task_list(fsess->main_thread_tasks, task);\n\t\t\t\t\t\tcheck_task_list(fsess->tasks, task);\n\t\t\t\t\t\tcheck_task_list(fsess->tasks_reservoir, task);\n\t\t\t\t\t\tgf_assert(task->run_task);\n#endif\n\n\t\t\t\t\t\tif (use_main) {\n\t\t\t\t\t\t\tpending_tasks = gf_fq_count(fsess->main_thread_tasks);\n\t\t\t\t\t\t\tgf_fq_add(fsess->main_thread_tasks, task);\n\t\t\t\t\t\t\t//we are the main thread and reposting to the main task list, don't notify/wait for the sema, just retry\n\t\t\t\t\t\t\t//we are sure to get a task from main list at next iteration\n\t\t\t\t\t\t\tif (use_main_sema) {\n\t\t\t\t\t\t\t\tskip_next_sema_wait = GF_TRUE;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tgf_fs_sema_io(fsess, GF_TRUE, GF_TRUE);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpending_tasks = gf_fq_count(fsess->main_thread_tasks);\n\t\t\t\t\t\t\tgf_fq_add(fsess->tasks, task);\n\t\t\t\t\t\t\t//we are not the main thread and we are reposting to the secondary task list, don't notify/wait for the sema, just retry\n\t\t\t\t\t\t\t//we are not sure to get a task from secondary list at next iteration, but the end of thread check will make\n\t\t\t\t\t\t\t//sure we renotify secondary sema if some tasks are still pending\n\t\t\t\t\t\t\tif (!use_main_sema) {\n\t\t\t\t\t\t\t\tskip_next_sema_wait = GF_TRUE;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tgf_fs_sema_io(fsess, GF_TRUE, GF_FALSE);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//we temporary force the main thread to fetch a task from the secondary list\n\t\t\t\t\t\t//because the first main task was not yet due for execution\n\t\t\t\t\t\t//it is likely that the execution of the next task will not wake up the main thread\n\t\t\t\t\t\t//but we must reevaluate the previous main task timing, so we force a notification of the main sema\n\t\t\t\t\t\tif (force_secondary_tasks) {\n\t\t\t\t\t\t\tgf_fs_sema_io(fsess, GF_TRUE, GF_TRUE);\n\t\t\t\t\t\t} else if (!thid && fsess->non_blocking && !pending_tasks) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Main thread proc exit\\n\"));\n\t\t\t\t\t\t\tsafe_int_dec(&fsess->active_threads);\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\n#if defined(GPAC_CONFIG_EMSCRIPTEN) && !defined(GPAC_DISABLE_THREADS)\n\t\t\t\t\t\tif (thid && (fsess->run_status == GF_OK)) {\n\t\t\t\t\t\t\tsess_thread->run_time += gf_sys_clock_high_res() - enter_time;\n\t\t\t\t\t\t\tsafe_int_dec(&fsess->active_threads);\n\t\t\t\t\t\t\tgf_th_async_call(sess_thread->th, (gf_thread_run) gf_fs_thread_proc, sess_thread);\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tforce_secondary_tasks=GF_FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u: task %s:%s schedule time \"LLU\" us reached (diff %d ms)\\n\", sys_thid, current_filter ? current_filter->name : \"\", task->log_name, task->schedule_next_time, (s32) diff));\n\n\t\t}\n\t\tnext_task_schedule_time = 0;\n\n\t\tif (current_filter) {\n\t\t\tcurrent_filter->scheduled_for_next_task = GF_TRUE;\n\t\t\tgf_assert(!current_filter->in_process);\n\t\t\tcurrent_filter->in_process = GF_TRUE;\n\t\t\tcurrent_filter->process_th_id = gf_th_id();\n\t\t}\n\n\t\tsess_thread->nb_tasks++;\n\t\tsess_thread->has_seen_eot = GF_FALSE;\n\t\tgf_assert(!task->filter || gf_fq_count(task->filter->tasks));\n\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u task#%d %p executing Filter %s::%s (%d tasks pending, %d(%d) process task queued)\\n\", sys_thid, sess_thread->nb_tasks, task, task->filter ? task->filter->name : \"none\", task->log_name, fsess->tasks_pending, task->filter ? task->filter->process_task_queued : 0, task->filter ? gf_fq_count(task->filter->tasks) : 0));\n\n\t\tsafe_int_inc(& fsess->tasks_in_process );\n\t\tgf_assert( task->run_task );\n\t\ttask_time = gf_sys_clock_high_res();\n\t\t//remember the last time we scheduled this filter\n\t\tif (task->filter)\n\t\t\ttask->filter->last_schedule_task_time = task_time;\n\n\t\ttask->can_swap = 0;\n\t\ttask->requeue_request = GF_FALSE;\n\t\ttask->thid = 1+thid;\n\t\ttask->run_task(task);\n\t\ttask->thid = 0;\n\t\trequeue = task->requeue_request;\n\n\t\ttask_time = gf_sys_clock_high_res() - task_time;\n\t\tsafe_int_dec(& fsess->tasks_in_process );\n\n\t\t//may now be NULL if task was a filter destruction task\n\t\tcurrent_filter = task->filter;\n\n#ifdef CHECK_TASK_LIST_INTEGRITY\n\t\tprev_current_filter = task->filter;\n#endif\n\n\t\t//source task was current filter, pop the filter task list\n\t\tif (current_filter) {\n\t\t\tBool last_task = GF_FALSE;\n\t\t\tcurrent_filter->nb_tasks_done++;\n\t\t\tcurrent_filter->time_process += task_time;\n\t\t\tconsecutive_filter_tasks++;\n\n#if defined(GPAC_CONFIG_EMSCRIPTEN)\n\t\t\t//for mono-thread case non blocking: if filter is marked as async blocking, abort and release\n\t\t\t//control to caller\n\t\t\tif  (!thid && fsess->non_blocking && (current_filter->freg->flags & GF_FS_REG_ASYNC_BLOCK)) {\n\t\t\t\tconsecutive_filter_tasks=11;\n\t\t\t\tfsess->in_main_sem_wait = GF_TRUE;\n\t\t\t}\n#endif\n\n\t\t\tgf_mx_p(current_filter->tasks_mx);\n\t\t\tif (gf_fq_count(current_filter->tasks)==1) {\n\t\t\t\t//if task is set to immediate reschedule, don't consider this is the last task\n\t\t\t\t//and check consecutive_filter_tasks - this will keep the active filter running\n\t\t\t\t//when the last task is a process task and the filter is not blocking\n\t\t\t\t//FIXME: commented out as this breaks ssome tests, needs further checking\n\t\t\t\t//if (task->can_swap!=2)\n\t\t\t\t{\n\t\t\t\t\tlast_task = GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//if last task\n\t\t\tif ( last_task\n\t\t\t\t//if requeue request and stream reset pending (we must exit the filter task loop for the reset task to be processed)\n\t\t\t\t|| (requeue && current_filter->stream_reset_pending)\n\t\t\t\t//or requeue request and pid swap pending (we must exit the filter task loop for the swap task to be processed)\n\t\t\t\t|| (requeue && (current_filter->swap_pidinst_src ||  current_filter->swap_pidinst_dst) )\n\t\t\t\t//or requeue request and pid detach / cap negotiate pending\n\t\t\t\t|| (requeue && (current_filter->out_pid_connection_pending || current_filter->detached_pid_inst || current_filter->caps_negotiate) )\n\n\t\t\t\t//or requeue request and we have been running on that filter for more than 10 times, abort\n\t\t\t\t|| (requeue && (consecutive_filter_tasks>10))\n\t\t\t) {\n\n\t\t\t\tif (requeue) {\n\t\t\t\t\t//filter task can be pushed back the queue of tasks\n\t\t\t\t\tif (task->can_swap) {\n\t\t\t\t\t\tGF_FSTask *next_task;\n\n\t\t\t\t\t\t//drop task from filter task list\n\t\t\t\t\t\tgf_fq_pop(current_filter->tasks);\n\n\t\t\t\t\t\tnext_task = gf_fq_head(current_filter->tasks);\n\t\t\t\t\t\t//if first task was notified, swap the flag\n\t\t\t\t\t\tif (next_task) {\n\t\t\t\t\t\t\t//see note in post_task_ex for caution about this !!\n\t\t\t\t\t\t\tnext_task->notified = task->notified;\n\t\t\t\t\t\t\ttask->notified = GF_FALSE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//requeue task\n\t\t\t\t\t\tgf_fq_add(current_filter->tasks, task);\n\n\t\t\t\t\t\t//ans swap task for later requeing\n\t\t\t\t\t\tif (next_task) task = next_task;\n\t\t\t\t\t}\n\t\t\t\t\t//otherwise (can't swap) keep task first in the list\n\n\t\t\t\t\t//don't reset scheduled_for_next_task flag if requeued to make sure no other task posted from\n\t\t\t\t\t//another thread will post to main sched\n\n#ifdef CHECK_TASK_LIST_INTEGRITY\n\t\t\t\t\tskip_filter_task_check = GF_TRUE;\n#endif\n\t\t\t\t} else {\n\t\t\t\t\t//no requeue, filter no longer scheduled and drop task\n\t\t\t\t\tcurrent_filter->scheduled_for_next_task = GF_FALSE;\n\n\t\t\t\t\t//drop task from filter task list\n\t\t\t\t\tgf_fq_pop(current_filter->tasks);\n\t\t\t\t}\n\n\t\t\t\tcurrent_filter->process_th_id = 0;\n\t\t\t\tcurrent_filter->in_process = GF_FALSE;\n\n\t\t\t\t//unlock once we modified in_process, otherwise this will make our assert fail\n\t\t\t\tgf_mx_v(current_filter->tasks_mx);\n#ifdef CHECK_TASK_LIST_INTEGRITY\n\t\t\t\tif (requeue && !skip_filter_task_check) check_task_list(current_filter->tasks, task);\n#endif\n\t\t\t\tcurrent_filter = NULL;\n\t\t\t} else {\n\t\t\t\t//drop task from filter task list\n\t\t\t\tgf_fq_pop(current_filter->tasks);\n\n\t\t\t\t//not requeued, no more tasks, deactivate filter\n\t\t\t\tif (!requeue && !gf_fq_count(current_filter->tasks)) {\n\t\t\t\t\tcurrent_filter->process_th_id = 0;\n\t\t\t\t\tcurrent_filter->in_process = GF_FALSE;\n\t\t\t\t\tcurrent_filter->scheduled_for_next_task = GF_FALSE;\n\t\t\t\t\tgf_mx_v(current_filter->tasks_mx);\n\t\t\t\t\tcurrent_filter = NULL;\n\t\t\t\t} else {\n#ifdef CHECK_TASK_LIST_INTEGRITY\n\t\t\t\t\tcheck_task_list(fsess->main_thread_tasks, task);\n\t\t\t\t\tcheck_task_list(fsess->tasks, task);\n\t\t\t\t\tcheck_task_list(fsess->tasks_reservoir, task);\n#endif\n\n\t\t\t\t\t//requeue task in current filter\n\t\t\t\t\tif (requeue)\n\t\t\t\t\t\tgf_fq_add(current_filter->tasks, task);\n\n\t\t\t\t\tgf_mx_v(current_filter->tasks_mx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//do not touch the filter task list after this, it has to be mutex protected to ensure proper posting of tasks\n\n\t\tnotified = task->notified;\n\t\tif (requeue) {\n\t\t\t//if requeue on a filter active, use filter queue to avoid another thread grabing the task (we would have concurrent access to the filter)\n\t\t\tif (current_filter) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u re-posted task Filter %s::%s in filter tasks (%d pending)\\n\", sys_thid, task->filter->name, task->log_name, fsess->tasks_pending));\n\t\t\t\ttask->notified = GF_FALSE;\n\t\t\t\t//keep this thread running on the current filter no signaling of semaphore\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u re-posted task Filter %s::%s in %s tasks (%d pending)\\n\", sys_thid, task->filter ? task->filter->name : \"none\", task->log_name, (task->filter && (task->filter->freg->flags & GF_FS_REG_MAIN_THREAD)) ? \"main\" : \"secondary\", fsess->tasks_pending));\n\n\t\t\t\ttask->notified = GF_TRUE;\n\t\t\t\tsafe_int_inc(&fsess->tasks_pending);\n\n#ifdef CHECK_TASK_LIST_INTEGRITY\n\t\t\t\tcheck_task_list(fsess->main_thread_tasks, task);\n\t\t\t\tcheck_task_list(fsess->tasks, task);\n\t\t\t\tcheck_task_list(fsess->tasks_reservoir, task);\n\t\t\t\tif (prev_current_filter && !skip_filter_task_check) check_task_list(prev_current_filter->tasks, task);\n#endif\n\n\t\t\t\t//main thread\n\t\t\t\tif (task->filter && (task->filter->freg->flags & GF_FS_REG_MAIN_THREAD)) {\n\t\t\t\t\tgf_fq_add(fsess->main_thread_tasks, task);\n\n#ifndef GPAC_DISABLE_THREADS\n\t\t\t\t\t//FIXME, we sometimes miss a sema notfiy resulting in secondary tasks being locked\n\t\t\t\t\t//until we find the cause, notify secondary sema if non-main-thread tasks are scheduled and we are the only task in main\n\t\t\t\t\tif (use_main_sema && (thid==0) && fsess->threads && (gf_fq_count(fsess->main_thread_tasks)==1) && gf_fq_count(fsess->tasks)) {\n\t\t\t\t\t\tgf_fs_sema_io(fsess, GF_TRUE, GF_FALSE);\n\t\t\t\t\t}\n#endif\n\t\t\t\t} else {\n\t\t\t\t\tgf_fq_add(fsess->tasks, task);\n\t\t\t\t}\n\t\t\t\tgf_fs_sema_io(fsess, GF_TRUE, use_main_sema);\n\t\t\t}\n\t\t} else {\n#ifdef CHECK_TASK_LIST_INTEGRITY\n\t\t\tcheck_task_list(fsess->main_thread_tasks, task);\n\t\t\tcheck_task_list(fsess->tasks, task);\n\t\t\tcheck_task_list(fsess->tasks_reservoir, task);\n\t\t\tif (prev_current_filter)\n\t\t\t\tcheck_task_list(prev_current_filter->tasks, task);\n\n\t\t\t{\n\t\t\t\tgf_mx_p(fsess->filters_mx);\n\t\t\t\tu32 k, c2 = gf_list_count(fsess->filters);\n\t\t\t\tfor (k=0; k<c2; k++) {\n\t\t\t\t\tGF_Filter *af = gf_list_get(fsess->filters, k);\n\t\t\t\t\tcheck_task_list(af->tasks, task);\n\t\t\t\t}\n\t\t\t\tgf_mx_v(fsess->filters_mx);\n\t\t\t}\n#endif\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Thread %u task#%d %p pushed to reservoir\\n\", sys_thid, sess_thread->nb_tasks, task));\n\n\t\t\tif (gf_fq_res_add(fsess->tasks_reservoir, task)) {\n\t\t\t\tgf_free(task);\n\t\t\t}\n\t\t}\n\n\t\t//decrement task counter\n\t\tif (notified) {\n\t\t\tgf_assert(fsess->tasks_pending);\n\t\t\tsafe_int_dec(&fsess->tasks_pending);\n\t\t}\n\t\tif (current_filter) {\n\t\t\tcurrent_filter->process_th_id = 0;\n\t\t\tcurrent_filter->in_process = GF_FALSE;\n\t\t}\n\t\t//not requeuing and first time we have an empty task queue, flush to detect if we are indeed done\n\t\tif (!current_filter && !fsess->tasks_pending && !sess_thread->has_seen_eot && !gf_fq_count(fsess->tasks)) {\n\t\t\t//if not the main thread, or if main thread and task list is empty, enter end of session probing mode\n\t\t\tif (thid || !gf_fq_count(fsess->main_thread_tasks) ) {\n\t\t\t\t//maybe last task, force a notify to check if we are truly done. We only tag \"session done\" for the non-main\n\t\t\t\t//threads, in order to enter the end-of session signaling above\n\t\t\t\tif (thid) sess_thread->has_seen_eot = GF_TRUE;\n\t\t\t\tgf_fs_sema_io(fsess, GF_TRUE, use_main_sema);\n\t\t\t}\n\t\t}\n\n\t\tsess_thread->active_time += gf_sys_clock_high_res() - active_start;\n\n\n\t\t//no main thread, return\n\t\tif (!thid && fsess->non_blocking && !current_filter && !fsess->pid_connect_tasks_pending) {\n\t\t\tgf_rmt_end();\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Main thread proc exit\\n\"));\n\t\t\tsafe_int_dec(&fsess->active_threads);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tgf_rmt_end();\n\n\tsafe_int_dec(&fsess->active_threads);\n\t//no main thread, return\n\tif (!thid && fsess->non_blocking) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_SCHEDULER, (\"Main thread proc exit\\n\"));\n\t\treturn 0;\n\t}\n\n#if defined(GPAC_CONFIG_EMSCRIPTEN) && !defined(GPAC_DISABLE_THREADS)\n\tif (thid) {\n\t\tsess_thread->run_time += gf_sys_clock_high_res() - enter_time;\n\t} else\n#endif\n\t\tsess_thread->run_time = gf_sys_clock_high_res() - enter_time;\n\n\tsafe_int_inc(&fsess->nb_threads_stopped);\n\n\tif (!fsess->run_status)\n\t\tfsess->run_status = GF_EOS;\n\n\t// thread exit, notify the semaphores\n\tif (fsess->semaphore_main && ! gf_sema_notify(fsess->semaphore_main, 1)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_SCHEDULER, (\"Failed to notify main semaphore, might hang up !!\\n\"));\n\t}\n\tif (fsess->semaphore_other && ! gf_sema_notify(fsess->semaphore_other, th_count)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_SCHEDULER, (\"Failed to notify secondary semaphore, might hang up !!\\n\"));\n\t}\n\n\treturn 0;\n}\n\nGF_EXPORT\nGF_Err gf_fs_run(GF_FilterSession *fsess)\n{\n\tif (!fsess) return GF_BAD_PARAM;\n\n\t//non blocking mode and threads created, only run main thread proc\n\tif (fsess->non_blocking && (fsess->non_blocking==2) ) {\n#ifdef GPAC_CONFIG_EMSCRIPTEN\n\t\tif (fsess->pending_threads) return GF_NOT_READY;\n#endif\n\t\tgf_fs_thread_proc(&fsess->main_th);\n#ifdef GPAC_CONFIG_EMSCRIPTEN\n\t\tif (fsess->in_main_sem_wait) {\n\t\t\tfsess->in_main_sem_wait = GF_FALSE;\n\t\t\treturn GF_NOT_READY;\n\t\t}\n#endif\n\t\treturn fsess->run_status;\n\t}\n\n\t//run threads\n\tfsess->run_status = GF_OK;\n\tfsess->main_th.has_seen_eot = GF_FALSE;\n\tfsess->nb_threads_stopped = 0;\n\n#ifndef GPAC_DISABLE_THREADS\n\tu32 i, nb_threads;\n\tnb_threads = gf_list_count(fsess->threads);\n\tfor (i=0;i<nb_threads; i++) {\n\t\tGF_SessionThread *sess_th = gf_list_get(fsess->threads, i);\n\t\tif ( gf_th_run(sess_th->th, (gf_thread_run) gf_fs_thread_proc, sess_th) ==GF_OK) {\n#ifdef GPAC_CONFIG_EMSCRIPTEN\n\t\t\tif (fsess->non_blocking) {\n\t\t\t\tsafe_int_inc(&fsess->pending_threads);\n\t\t\t}\n#endif\n\t\t}\n\t}\n#endif\n\n\n\t//run main thread - for emscripten, we only call if no pending threads\n#ifdef GPAC_CONFIG_EMSCRIPTEN\n\tif (!fsess->pending_threads)\n#endif\n\t{\n\t\tgf_fs_thread_proc(&fsess->main_th);\n\t}\n\n\t//non blocking mode init, don't wait for other threads\n\tif (fsess->non_blocking) {\n\t\tfsess->non_blocking = 2;\n\t\treturn fsess->run_status;\n\t}\n\n#ifndef GPAC_DISABLE_THREADS\n\t//blocking mode, wait for all threads to be done\n\twhile (nb_threads+1 != fsess->nb_threads_stopped) {\n\t\tgf_sleep(1);\n\t}\n#endif\n\n\treturn fsess->run_status;\n}\n\n\n// target function\nGF_EXPORT\ns32 gf_token_get_line(const char *Buffer, u32 Start, u32 Size, char *LineBuffer, u32 LineBufferSize)\n{\n\tu32 offset;\n\ts32 i, End, Total;\n\tLineBuffer[0] = 0;\n\tif (Start >= Size) return -1;\n\n\toffset = 2;\n\tEnd = gf_token_find(Buffer, Start, Size, \"\\r\\n\");\n\tif (End<0) {\n\t\tEnd = gf_token_find(Buffer, Start, Size, \"\\r\");\n\t\tif (End<0) End = gf_token_find(Buffer, Start, Size, \"\\n\");\n\t\tif (End < 0) return -1;\n\t\toffset = 1;\n\t}\n\n\tTotal = End - Start + offset;\n\tif ((u32) Total >= LineBufferSize) Total = LineBufferSize;\n\tfor (i=0; i<Total; i++) LineBuffer[i] = Buffer[Start+i];\n\tLineBuffer[i] = 0;\n\treturn (End + offset);\n}\n",
    "target": 1,
    "idx": 1065264,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "// context\n\n\nd_m3RetSig  Call  (d_m3OpSig)\n{\n    m3ret_t possible_trap = m3_Yield ();\n    if (UNLIKELY(possible_trap)) return possible_trap;\n\n    nextOpDirect();\n}\n\nM3Result  EvaluateExpression  (IM3Module i_module, void * o_expressed, u8 i_type, bytes_t * io_bytes, cbytes_t i_end)\n{\n    M3Result result = m3Err_none;\n\n    // OPTZ: use a simplified interpreter for expressions\n\n    // create a temporary runtime context\n#if defined(d_m3PreferStaticAlloc)\n    static M3Runtime runtime;\n#else\n    M3Runtime runtime;\n#endif\n    M3_INIT (runtime);\n\n    runtime.environment = i_module->runtime->environment;\n    runtime.numStackSlots = i_module->runtime->numStackSlots;\n    runtime.stack = i_module->runtime->stack;\n\n    m3stack_t stack = (m3stack_t)runtime.stack;\n\n    IM3Runtime savedRuntime = i_module->runtime;\n    i_module->runtime = & runtime;\n\n    IM3Compilation o = & runtime.compilation;\n    o->runtime = & runtime;\n    o->module =  i_module;\n    o->wasm =    * io_bytes;\n    o->wasmEnd = i_end;\n    o->lastOpcodeStart = o->wasm;\n\n    o->block.depth = -1;  // so that root compilation depth = 0\n\n    //  OPTZ: this code page could be erased after use.  maybe have 'empty' list in addition to full and open?\n    o->page = AcquireCodePage (& runtime);  // AcquireUnusedCodePage (...)\n\n    if (o->page)\n    {\n        IM3FuncType ftype = runtime.environment->retFuncTypes[i_type];\n\n        pc_t m3code = GetPagePC (o->page);\n        result = CompileBlock (o, ftype, c_waOp_block);\n\n        if (not result && o->maxStackSlots >= runtime.numStackSlots) {\n            result = m3Err_trapStackOverflow;\n        }\n\n        if (not result)\n        {\n            m3ret_t r = Call (m3code, stack, NULL, d_m3OpDefaultArgs);\n\n            if (r == 0)\n            {                                                                               m3log (runtime, \"expression result: %s\", SPrintValue (stack, i_type));\n                if (SizeOfType (i_type) == sizeof (u32))\n                {\n                    * (u32 *) o_expressed = * ((u32 *) stack);\n                }\n                else\n                {\n                    * (u64 *) o_expressed = * ((u64 *) stack);\n                }\n            }\n        }\n\n        // TODO: EraseCodePage (...) see OPTZ above\n        ReleaseCodePage (& runtime, o->page);\n    }\n    else result = m3Err_mallocFailedCodePage;\n\n    runtime.stack = NULL;        // prevent free(stack) in ReleaseRuntime\n    Runtime_Release (& runtime);\n    i_module->runtime = savedRuntime;\n\n    * io_bytes = o->wasm;\n\n    return result;\n}\n\nM3Result  InitElements  (IM3Module io_module)\n{\n    M3Result result = m3Err_none;\n\n    bytes_t bytes = io_module->elementSection;\n    cbytes_t end = io_module->elementSectionEnd;\n\n    for (u32 i = 0; i < io_module->numElementSegments; ++i)\n    {\n        u32 index;\n_       (ReadLEB_u32 (& index, & bytes, end));\n\n        if (index == 0)\n        {\n            i32 offset;\n_           (EvaluateExpression (io_module, & offset, c_m3Type_i32, & bytes, end));\n            _throwif (\"table underflow\", offset < 0);\n\n            u32 numElements;\n_           (ReadLEB_u32 (& numElements, & bytes, end));\n\n            size_t endElement = (size_t)(numElements) + offset;\n            _throwif (\"table overflow\", endElement > d_m3MaxSaneTableSize);\n\n            io_module->table0 = m3_ReallocArray (IM3Function, io_module->table0, endElement, io_module->table0Size);\n            _throwifnull(io_module->table0);\n\n            io_module->table0Size = (u32) endElement;\n\n            for (u32 e = 0; e < numElements; ++e)\n            {\n                u32 functionIndex;\n_               (ReadLEB_u32 (& functionIndex, & bytes, end));\n                _throwif (\"function index out of range\", functionIndex >= io_module->numFunctions);\n                IM3Function function = & io_module->functions [functionIndex];      d_m3Assert (function); //printf (\"table: %s\\n\", m3_GetFunctionName(function));\n                io_module->table0 [e + offset] = function;\n            }\n        }\n        else _throw (\"element table index must be zero for MVP\");\n    }\n\n    _catch: return result;\n}\n\nM3Result  m3_LoadModule  (IM3Runtime io_runtime, IM3Module io_module)\n{\n    M3Result result = m3Err_none;\n\n    if (UNLIKELY(io_module->runtime)) {\n        return m3Err_moduleAlreadyLinked;\n    }\n\n    io_module->runtime = io_runtime;\n    M3Memory * memory = & io_runtime->memory;\n\n_   (InitMemory (io_runtime, io_module));\n_   (InitGlobals (io_module));\n_   (InitDataSegments (memory, io_module));\n_   (InitElements (io_module));\n\n    // Start func might use imported functions, which are not liked here yet,\n    // so it will be called before a function call is attempted (in m3_FindFunction)\n\n    io_module->next = io_runtime->modules;\n    io_runtime->modules = io_module;\n    return result; // ok\n\n_catch:\n    io_module->runtime = NULL;\n    return result;\n}\n\n\n// target function\nu16  GetMaxUsedSlotPlusOne  (IM3Compilation o)\n{\n    while (o->slotMaxAllocatedIndexPlusOne > o->slotFirstDynamicIndex)\n    {\n        if (IsSlotAllocated (o, o->slotMaxAllocatedIndexPlusOne - 1))\n            break;\n\n        o->slotMaxAllocatedIndexPlusOne--;\n    }\n    \n#   ifdef DEBUG\n        u16 maxSlot = o->slotMaxAllocatedIndexPlusOne;\n        while (maxSlot < d_m3MaxFunctionSlots)\n        {\n            d_m3Assert (o->m3Slots [maxSlot] == 0);\n            maxSlot++;\n        }\n#   endif\n\n    return o->slotMaxAllocatedIndexPlusOne;\n}\nM3Result  Push  (IM3Compilation o, u8 i_type, u16 i_slot)\n{\n    M3Result result = m3Err_none;\n\n#if !d_m3HasFloat\n    if (i_type == c_m3Type_f32 || i_type == c_m3Type_f64) {\n        return m3Err_unknownOpcode;\n    }\n#endif\n\n    u16 stackIndex = o->stackIndex++;                                       // printf (\"push: %d\\n\", (i32) i);\n\n    if (stackIndex < d_m3MaxFunctionStackHeight)\n    {\n        o->wasmStack        [stackIndex] = i_slot;\n        o->typeStack        [stackIndex] = i_type;\n\n        if (IsRegisterSlotAlias (i_slot))\n        {\n            u32 regSelect = IsFpRegisterSlotAlias (i_slot);\n            AllocateRegister (o, regSelect, stackIndex);\n        }\n        else\n        {\n            if (o->function)\n            {\n                // op_Entry uses this value to track and detect stack overflow\n                o->function->maxStackSlots = M3_MAX (o->function->maxStackSlots, i_slot + 1);\n            }\n        }\n\n        if (d_m3LogWasmStack) dump_type_stack (o);\n    }\n    else result = m3Err_functionStackOverflow;\n\n    return result;\n}\nbool  PatchBranches  (IM3Compilation o)\n{\n    pc_t pc = GetPC (o);\n\n    IM3BranchPatch patches = o->block.patches;\n    o->block.patches = NULL;\n    \n    bool didPatch = patches;\n    \n    while (patches)\n    {                                                           m3log (compile, \"patching location: %p to pc: %p\", patches, pc);\n        patches->location = pc;\n        patches = patches->next;\n    }\n\n    return didPatch;\n}\nM3Result  MoveStackTopToSlot  (IM3Compilation o, u16 i_slot, bool i_doPushPop)\n{\n    M3Result result = m3Err_none;\n\n    if (GetStackTopSlotNumber (o) != i_slot)    // (registers have a unique slot num alias)\n    {\n        u8 type = GetStackTopType (o);\n\n_       (CopyStackTopToSlot (o, i_slot));\n        \n        if (i_doPushPop)\n        {\n_           (Pop (o));\n_           (PushAllocatedSlot (o, type))\n//          MarkSlotAllocated (o, i_slot);\n//_         (Push (o, type, i_slot));\n        }\n    }\n\n    _catch: return result;\n}\nM3Result  ResolveBlockResults  (IM3Compilation o, IM3CompilationScope i_targetBlock, bool i_doPushPop)\n{\n    M3Result result = m3Err_none;                                   if (d_m3LogWasmStack) dump_type_stack (o);\n\n    u8 stackType = GetSingleRetType (i_targetBlock->type);\n\n    if (stackType != c_m3Type_none)\n    {\n        if (IsFpType (stackType))\n_           (CopyStackTopToRegister (o, i_doPushPop))\n        else\n_           (MoveStackTopToSlot (o, i_targetBlock->topSlot, i_doPushPop))\n    }\n    \n    _catch: return result;\n}\nM3Result  ValidateBlockEnd  (IM3Compilation o)\n{\n    M3Result result = m3Err_none;\n\n    u8 stackType = GetSingleRetType (o->block.type);\n\n    if (stackType != c_m3Type_none)\n    {\n        if (IsStackPolymorphic (o))\n        {\n            /*\n             according to reference implementations: the type stack should still be validated\n             here, which is totally senseless in practice.\n            \n             the spec behavior which I had to deduce from the ocaml and wat2wasm tools is:\n             a polymorphic stack can pop any type requested, but if values have been pushed\n             since going polymorphic, those type are not polymorphic.\n            */\n            \n_           (UnwindBlockStack (o));\n            \n            if (IsFpType (stackType))\n_               (PushRegister (o, stackType))\n            else\n_               (PushAllocatedSlot (o, stackType))\n        }\n        else\n        {\n            i16 initStackIndex = o->block.initStackIndex;\n\n            if (o->block.depth > 0 and initStackIndex != o->stackIndex)\n            {\n                if (o->stackIndex == initStackIndex + 1)\n                {\n_                   (ResolveBlockResults (o, & o->block, true));\n                }\n                else _throw (\"unexpected block stack offset\");\n            }\n        }\n    }\n    else\n_       (UnwindBlockStack (o));\n\n    _catch: return result;\n}\nM3Result  Compile_End  (IM3Compilation o, m3opcode_t i_opcode)\n{\n    M3Result result = m3Err_none;\n\n    // function end:\n    if (o->block.depth == 0)\n    {\n        ValidateBlockEnd (o);\n        \n        u8 type = GetSingleRetType (o->block.type);\n\n        u32 numReturns = GetFuncTypeNumReturns (o->block.type);\n\n        if (numReturns)\n        {\n            if (not o->block.isPolymorphic and type != GetStackTopType (o))\n                _throw (m3Err_typeMismatch);\n\n            if (not o->block.isPolymorphic)\n                ResolveBlockResults (o, & o->block, true);\n        \n            // if there are branches to the function end, then their values are in a register\n            // if the block happens to have its top in a register too, then we can patch the branch\n            // to here. Otherwise, an ReturnStackTop is appended to the end of the function (at B) and\n            // branches patched there.\n            PatchBranches (o);\n\n_           (ReturnStackTop (o));\n        }\n        else PatchBranches (o);  // for no return type, branch to op_End\n\n_       (EmitOp (o, op_Return));\n\n_       (UnwindBlockStack (o));\n    }\n\n    _catch: return result;\n}\nM3Result  EmitPatchingBranch  (IM3Compilation o, IM3CompilationScope i_scope)\n{\n    M3Result result ;\n\n_try {\n    \n_   (EmitOp (o, op_Branch));\n    \n    // IM3BranchPatch is two word struct; reserve two words\n    IM3BranchPatch patch = (IM3BranchPatch) ReservePointer (o);                     m3log (compile, \"branch patch required at: %p\", patch);\n                                            ReservePointer (o);\n    patch->next = i_scope->patches;\n    i_scope->patches = patch;\n\n}   _catch:\nM3Result  Compile_Branch  (IM3Compilation o, m3opcode_t i_opcode)\n{\n    M3Result result;\n\n    u32 depth;\n_   (ReadLEB_u32 (& depth, & o->wasm, o->wasmEnd));\n\n    IM3CompilationScope scope;\n_   (GetBlockScope (o, & scope, depth));\n\n    // branch target is a loop (continue)\n    if (scope->opcode == c_waOp_loop)\n    {\n        IM3Operation op;\n\n        if (i_opcode == c_waOp_branchIf)\n        {\n            op = op_ContinueLoopIf;\n            // move the condition to a register\n_           (CopyStackTopToRegister (o, false));\n_           (PopType (o, c_m3Type_i32));\n        }\n        else // is c_waOp_branch\n        {\n            op = op_ContinueLoop;\n            o->block.isPolymorphic = true;\n        }\n\n_       (EmitOp (o, op));\n        EmitPointer (o, scope->pc);\n    }\n    else // forward branch\n    {\n        pc_t * jumpTo = NULL;\n        \n        if (i_opcode == c_waOp_branchIf)\n        {\n            // OPTZ: need a flipped BranchIf without ResolveBlockResults prologue\n            // when no stack results\n            \n            IM3Operation op = IsStackTopInRegister (o) ? op_BranchIfPrologue_r : op_BranchIfPrologue_s;\n\n    _       (EmitOp (o, op));\n            EmitSlotNumOfStackTopAndPop (o); // condition\n            \n            // this is continuation point, if the branch isn't taken\n            jumpTo = (pc_t *) ReservePointer (o);\n        }\n\n        if (not IsStackPolymorphic (o))\n_           (ResolveBlockResults (o, scope, false));\n        \n_       (EmitPatchingBranch (o, scope));\n        \n        if (jumpTo)\n        {\n            * jumpTo = GetPC (o);\n        }\n        else SetStackPolymorphic (o);\n    }\n\n    _catch: return result;\n}\nM3Result  Compile_BranchTable  (IM3Compilation o, m3opcode_t i_opcode)\n{\n    M3Result result;\n\n_try {\n    u32 targetCount;\n_   (ReadLEB_u32 (& targetCount, & o->wasm, o->wasmEnd));\n\n_   (PreserveRegisterIfOccupied (o, c_m3Type_i64));         // move branch operand to a slot\n    u16 slot = GetStackTopSlotNumber (o);\n_   (Pop (o));\n\n    // OPTZ: according to spec: \"forward branches that target a control instruction with a non-empty\n    // result type consume matching operands first and push them back on the operand stack after unwinding\"\n    // So, this move-to-reg is only necessary if the target scopes have a type.\n\n    u32 numCodeLines = targetCount + 4; // 3 => IM3Operation + slot + target_count + default_target\n_   (EnsureCodePageNumLines (o, numCodeLines));\n\n_   (EmitOp (o, op_BranchTable));\n    EmitSlotOffset (o, slot);\n    EmitConstant32 (o, targetCount);\n\n    IM3CodePage continueOpPage = NULL;\n\n    ++targetCount; // include default\n    for (u32 i = 0; i < targetCount; ++i)\n    {\n        u32 target;\n_       (ReadLEB_u32 (& target, & o->wasm, o->wasmEnd));\n\n        IM3CompilationScope scope;\n_       (GetBlockScope (o, & scope, target));\n\n        // create a ContinueLoop operation on a fresh page\n_       (AcquireCompilationCodePage (o, & continueOpPage));\n        \n        pc_t startPC = GetPagePC (continueOpPage);\n        IM3CodePage savedPage = o->page;\n        o->page = continueOpPage;\n\n        if (scope->opcode == c_waOp_loop)\n        {\n_           (EmitOp (o, op_ContinueLoop));\n            EmitPointer (o, scope->pc);\n        }\n        else\n        {\n            // TODO: this could be fused with equivalent targets\n_           (ResolveBlockResults (o, scope, false));\n\n_           (EmitPatchingBranch (o, scope));\n        }\n        \n        ReleaseCompilationCodePage (o);     // FIX: continueOpPage can get lost if thrown\n        o->page = savedPage;\n\n        EmitPointer (o, startPC);\n    }\n\n    SetStackPolymorphic (o);\n\n    }\nM3Result  CompileFunction  (IM3Function io_function)\n{\n    if (!io_function->wasm) return \"function body is missing\";\n\n    IM3FuncType funcType = io_function->funcType;\n\n    M3Result result = m3Err_none;                                   m3log (compile, \"compiling: '%s'; wasm-size: %d; numArgs: %d; return: %s\",\n                                                                           m3_GetFunctionName(io_function), (u32) (io_function->wasmEnd - io_function->wasm), GetFunctionNumArgs (io_function),\n                                                                           c_waTypes [GetSingleRetType(funcType)]);\n    IM3Runtime runtime = io_function->module->runtime;\n\n    IM3Compilation o = & runtime->compilation;                      d_m3Assert (d_m3MaxFunctionSlots >= d_m3MaxFunctionStackHeight * (d_m3Use32BitSlots + 1))  // need twice as many slots in 32-bit mode\n    SetupCompilation (o);\n\n    o->runtime  = runtime;\n    o->module   = io_function->module;\n    o->function = io_function;\n    o->wasm     = io_function->wasm;\n    o->wasmEnd  = io_function->wasmEnd;\n    o->block.type = funcType;\n\n_try {\n    // skip over code size. the end was already calculated during parse phase\n    u32 size;\n_   (ReadLEB_u32 (& size, & o->wasm, o->wasmEnd));                  d_m3Assert (size == (o->wasmEnd - o->wasm))\n\n_   (AcquireCompilationCodePage (o, & o->page));\n\n    pc_t pc = GetPagePC (o->page);\n\n    u16 numRetSlots = GetFunctionNumReturns (o->function) * c_ioSlotCount;\n\n    for (u16 i = 0; i < numRetSlots; ++i)\n        MarkSlotAllocated (o, i);\n\n    o->function->numRetSlots = o->slotFirstDynamicIndex = numRetSlots;\n\n    u16 numArgs = GetFunctionNumArgs (o->function);\n\n    // push the arg types to the type stack\n    for (u16 i = 0; i < numArgs; ++i)\n    {\n        u8 type = GetFunctionArgType (o->function, i);\n_       (PushAllocatedSlot (o, type));\n\n        // prevent allocator fill-in\n        o->slotFirstDynamicIndex += c_ioSlotCount;\n    }\n\n    o->slotMaxAllocatedIndexPlusOne = o->function->numRetAndArgSlots = o->slotFirstLocalIndex = o->slotFirstDynamicIndex;\n\n_   (CompileLocals (o));\n\n    u16 maxSlot = GetMaxUsedSlotPlusOne (o);\n\n    o->function->numLocalBytes = (maxSlot - o->slotFirstLocalIndex) * sizeof (m3slot_t);\n\n    o->slotFirstConstIndex = o->slotMaxConstIndex = maxSlot;\n\n    // ReserveConstants initializes o->firstDynamicSlotNumber\n_   (Compile_ReserveConstants (o));\n\n    // start tracking the max stack used (Push() also updates this value) so that op_Entry can precisely detect stack overflow\n    o->function->maxStackSlots = o->slotMaxAllocatedIndexPlusOne = o->slotFirstDynamicIndex;\n\n    o->block.topSlot = o->slotFirstDynamicIndex;\n    o->block.initStackIndex = o->stackFirstDynamicIndex = o->stackIndex;                           m3log (compile, \"start stack index: %d;  top slot num: %d\", (u32) o->stackFirstDynamicIndex, (u32) o->block.topSlot);\n    \n_   (EmitOp (o, op_Entry));\n    EmitPointer (o, io_function);\n\n_   (CompileBlockStatements (o));\n\n    // TODO: validate opcode sequences\n    _throwif(m3Err_wasmMalformed, o->previousOpcode != c_waOp_end);\n\n    io_function->compiled = pc;\n\n    u16 numConstantSlots = o->slotMaxConstIndex - o->slotFirstConstIndex;       m3log (compile, \"unique constant slots: %d; unused slots: %d\", numConstantSlots, o->slotFirstDynamicIndex - o->slotMaxConstIndex);\n\n    io_function->numConstantBytes = numConstantSlots * sizeof (m3slot_t);\n\n    if (numConstantSlots)\n    {\n        io_function->constants = m3_CopyMem (o->constants, io_function->numConstantBytes);\n        _throwifnull(io_function->constants);\n    }\n\n} _catch:\nvoid  m3_FreeImpl  (void * io_ptr)\n{\n//    if (io_ptr) printf(\"== free %p\\n\", io_ptr);\n    free ((void*)io_ptr);\n}\nM3Result  EvaluateExpression  (IM3Module i_module, void * o_expressed, u8 i_type, bytes_t * io_bytes, cbytes_t i_end)\n{\n    M3Result result = m3Err_none;\n\n    // OPTZ: use a simplified interpreter for expressions\n\n    // create a temporary runtime context\n#if defined(d_m3PreferStaticAlloc)\n    static M3Runtime runtime;\n#else\n    M3Runtime runtime;\n#endif\n    M3_INIT (runtime);\n\n    runtime.environment = i_module->runtime->environment;\n    runtime.numStackSlots = i_module->runtime->numStackSlots;\n    runtime.stack = i_module->runtime->stack;\n\n    m3stack_t stack = (m3stack_t)runtime.stack;\n\n    IM3Runtime savedRuntime = i_module->runtime;\n    i_module->runtime = & runtime;\n\n    IM3Compilation o = & runtime.compilation;\n    o->runtime = & runtime;\n    o->module =  i_module;\n    o->wasm =    * io_bytes;\n    o->wasmEnd = i_end;\n    o->lastOpcodeStart = o->wasm;\n\n    o->block.depth = -1;  // so that root compilation depth = 0\n\n    //  OPTZ: this code page could be erased after use.  maybe have 'empty' list in addition to full and open?\n    o->page = AcquireCodePage (& runtime);  // AcquireUnusedCodePage (...)\n\n    if (o->page)\n    {\n        IM3FuncType ftype = runtime.environment->retFuncTypes[i_type];\n\n        pc_t m3code = GetPagePC (o->page);\n        result = CompileBlock (o, ftype, c_waOp_block);\n\n        if (not result)\n        {\n            m3ret_t r = Call (m3code, stack, NULL, d_m3OpDefaultArgs);\n\n            if (r == 0)\n            {                                                                               m3log (runtime, \"expression result: %s\", SPrintValue (stack, i_type));\n                if (SizeOfType (i_type) == sizeof (u32))\n                {\n                    * (u32 *) o_expressed = * ((u32 *) stack);\n                }\n                else\n                {\n                    * (u64 *) o_expressed = * ((u64 *) stack);\n                }\n            }\n        }\n\n        // TODO: EraseCodePage (...) see OPTZ above\n        ReleaseCodePage (& runtime, o->page);\n    }\n    else result = m3Err_mallocFailedCodePage;\n\n    runtime.stack = NULL;        // prevent free(stack) in ReleaseRuntime\n    Runtime_Release (& runtime);\n    i_module->runtime = savedRuntime;\n\n    * io_bytes = o->wasm;\n\n    return result;\n}\nM3Result  m3_LoadModule  (IM3Runtime io_runtime, IM3Module io_module)\n{\n    M3Result result = m3Err_none;\n\n    if (not io_module->runtime)\n    {\n        io_module->runtime = io_runtime;\n        M3Memory * memory = & io_runtime->memory;\n\n_       (InitMemory (io_runtime, io_module));\n_       (InitGlobals (io_module));\n_       (InitDataSegments (memory, io_module));\n_       (InitElements (io_module));\n\n        io_module->next = io_runtime->modules;\n        io_runtime->modules = io_module;\n\n        // Start func might use imported functions, which are not liked here yet,\n        // so it will be called before a function call is attempted (in m3_FindFuSnction)\n    }\n    else result = m3Err_moduleAlreadyLinked;\n\n    if (result)\n        io_module->runtime = NULL;\n\n    _catch: return result;\n}\nIM3Global  m3_FindGlobal  (IM3Module               io_module,\n                           const char * const      i_globalName)\n{\n    // Search exports\n    for (u32 i = 0; i < io_module->numGlobals; ++i)\n    {\n        IM3Global g = & io_module->globals [i];\n        if (g->name and strcmp (g->name, i_globalName) == 0)\n        {\n            return g;\n        }\n    }\n\n    // Search imports\n    for (u32 i = 0; i < io_module->numGlobals; ++i)\n    {\n        IM3Global g = & io_module->globals [i];\n\n        if (g->import.moduleUtf8 and g->import.fieldUtf8)\n        {\n            if (strcmp (g->import.fieldUtf8, i_globalName) == 0)\n            {\n                return g;\n            }\n        }\n    }\n    return NULL;\n}\nvoid  dump_type_stack  (IM3Compilation o)\n{\n    /* Reminders about how the stack works! :)\n     -- args & locals remain on the type stack for duration of the function. Denoted with a constant 'A' and 'L' in this dump.\n     -- the initial stack dumps originate from the CompileLocals () function, so these identifiers won't/can't be\n     applied until this compilation stage is finished\n     -- constants are not statically represented in the type stack (like args & constants) since they don't have/need\n     write counts\n\n     -- the number shown for static args and locals (value in wasmStack [i]) represents the write count for the variable\n\n     -- (does Wasm ever write to an arg? I dunno/don't remember.)\n     -- the number for the dynamic stack values represents the slot number.\n     -- if the slot index points to arg, local or constant it's denoted with a lowercase 'a', 'l' or 'c'\n\n     */\n\n    // for the assert at end of dump:\n    i32 regAllocated [2] = { (i32) IsRegisterAllocated (o, 0), (i32) IsRegisterAllocated (o, 1) };\n\n    // display whether r0 or fp0 is allocated. these should then also be reflected somewhere in the stack too.\n    d_m3Log(stack, \"\\n\");\n    d_m3Log(stack, \"        \");\n    printf (\"%s %s    \", regAllocated [0] ? \"(r0)\" : \"    \", regAllocated [1] ? \"(fp0)\" : \"     \");\n\n//  printf (\"%d\", o->stackIndex -)\n    for (u32 i = o->stackFirstDynamicIndex; i < o->stackIndex; ++i)\n    {\n        printf (\" %s\", c_waCompactTypes [o->typeStack [i]]);\n\n        u16 slot = o->wasmStack [i];\n\n        if (IsRegisterSlotAlias (slot))\n        {\n            bool isFp = IsFpRegisterSlotAlias (slot);\n            printf (\"%s\", isFp ? \"f0\" : \"r0\");\n\n            regAllocated [isFp]--;\n        }\n        else\n        {\n            if (slot < o->slotFirstDynamicIndex)\n            {\n                if (slot >= o->slotFirstConstIndex)\n                    printf (\"c\");\n                else if (slot >= o->function->numRetAndArgSlots)\n                    printf (\"L\");\n                else\n                    printf (\"a\");\n            }\n\n            printf (\"%d\", (i32) slot);  // slot\n        }\n\n        printf (\" \");\n    }\n    printf (\"\\n\");\n\n    for (u32 r = 0; r < 2; ++r)\n        d_m3Assert (regAllocated [r] == 0);         // reg allocation & stack out of sync\n    \n    u16 maxSlot = GetMaxUsedSlotPlusOne (o);\n    \n    if (maxSlot > o->slotFirstDynamicIndex)\n    {\n        d_m3Log (stack, \"                      -\");\n\n        for (u16 i = o->slotFirstDynamicIndex; i < maxSlot; ++i)\n            printf (\"----\");\n\n        printf (\"\\n\");\n\n        d_m3Log (stack, \"                 slot |\");\n        for (u16 i = o->slotFirstDynamicIndex; i < maxSlot; ++i)\n            printf (\"%3d|\", i);\n\n        printf (\"\\n\");\n        d_m3Log (stack, \"                alloc |\");\n\n        for (u16 i = o->slotFirstDynamicIndex; i < maxSlot; ++i)\n        {\n            printf (\"%3d|\", o->m3Slots [i]);\n        }\n        \n        printf (\"\\n\");\n    }\n    d_m3Log(stack, \"\\n\");\n}\nvoid  m3_FreeModule  (IM3Module i_module)\n{\n    if (i_module)\n    {\n        m3log (module, \"freeing module: %s (funcs: %d; segments: %d)\",\n               i_module->name, i_module->numFunctions, i_module->numDataSegments);\n\n        Module_FreeFunctions (i_module);\n\n        m3_Free (i_module->functions);\n        //m3_Free (i_module->imports);\n        m3_Free (i_module->funcTypes);\n        m3_Free (i_module->dataSegments);\n        m3_Free (i_module->table0);\n\n        for (u32 i = 0; i < i_module->numGlobals; ++i)\n        {\n            m3_Free (i_module->globals[i].name);\n        }\n        for (u32 i = 0; i < i_module->numGlobals; ++i)\n        {\n            FreeImportInfo(&(i_module->globals[i].import));\n        }\n        m3_Free (i_module->globals);\n\n        m3_Free (i_module);\n    }\n}\nIM3Runtime  m3_GetModuleRuntime  (IM3Module i_module)\n{\n    return i_module ? i_module->runtime : NULL;\n}\n",
    "target": 1,
    "idx": 1033318,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "// context\nint freerdp_assistance_parse_file_buffer(rdpAssistanceFile* file, const char* cbuffer, size_t size,\n                                         const char* password)\n{\n\tWINPR_ASSERT(file);\n\tif (!password)\n\t{\n\t\tWLog_WARN(TAG, \"empty password supplied\");\n\t}\n\n\tif (!cbuffer || (size == 0))\n\t{\n\t\tWLog_WARN(TAG, \"no data supplied [%p, %\" PRIuz \"]\", cbuffer, size);\n\t\treturn -1;\n\t}\n\n\tchar* abuffer = strndup(cbuffer, size);\n\tconst size_t len = strnlen(cbuffer, size);\n\tif (len == size)\n\t\tWLog_WARN(TAG, \"Input data not '\\0' terminated\");\n\n\tif (!abuffer)\n\t\treturn -1;\n\n\tconst int rc = freerdp_assistance_parse_file_buffer_int(file, abuffer, len + 1, password);\n\tfree(abuffer);\n\treturn rc;\n}\n\nstatic int parse_file_buffer(const uint8_t* Data, size_t Size)\n{\n\tstatic const char TEST_MSRC_INCIDENT_PASSWORD_TYPE2[] = \"48BJQ853X3B4\";\n\tint status = -1;\n\trdpAssistanceFile* file = freerdp_assistance_file_new();\n\tif (!file)\n\t\treturn -1;\n\n\tchar* buf = calloc(Size + 1, sizeof(char));\n\tif (buf == NULL)\n\t\tgoto err;\n\tmemcpy(buf, Data, Size);\n\tbuf[Size] = '\\0';\n\n\tstatus = freerdp_assistance_parse_file_buffer(file, (char*)buf, Size + 1,\n\t                                              TEST_MSRC_INCIDENT_PASSWORD_TYPE2);\n\nerr:\n\tfreerdp_assistance_file_free(file);\n\tfree(buf);\n\n\treturn status >= 0 ? TRUE : FALSE;\n}\n\n\n// target function\nstatic BOOL freerdp_assistance_crypt_derive_key_sha1(BYTE* hash, size_t hashLength, BYTE* key,\n                                                     size_t keyLength)\n{\n\tBOOL rc = FALSE;\n\tsize_t i;\n\tBYTE* buffer;\n\tBYTE pad1[64];\n\tBYTE pad2[64];\n\tmemset(pad1, 0x36, 64);\n\tmemset(pad2, 0x5C, 64);\n\n\tfor (i = 0; i < hashLength; i++)\n\t{\n\t\tpad1[i] ^= hash[i];\n\t\tpad2[i] ^= hash[i];\n\t}\n\n\tbuffer = (BYTE*)calloc(hashLength, 2);\n\n\tif (!buffer)\n\t\tgoto fail;\n\n\tif (!winpr_Digest(WINPR_MD_SHA1, pad1, 64, buffer, hashLength))\n\t\tgoto fail;\n\n\tif (!winpr_Digest(WINPR_MD_SHA1, pad2, 64, &buffer[hashLength], hashLength))\n\t\tgoto fail;\n\n\tCopyMemory(key, buffer, keyLength);\n\trc = TRUE;\nfail:\n\tfree(buffer);\n\treturn rc;\n}\nstatic BOOL reallocate(rdpAssistanceFile* file, const char* host, UINT32 port)\n{\n\tvoid *tmp1, *tmp2;\n\tfile->MachineCount++;\n\ttmp1 = realloc(file->MachinePorts, sizeof(UINT32) * file->MachineCount);\n\ttmp2 = realloc(file->MachineAddresses, sizeof(char*) * file->MachineCount);\n\n\tif (!tmp1 || !tmp2)\n\t{\n\t\tfree(tmp1);\n\t\tfree(tmp2);\n\t\treturn FALSE;\n\t}\n\n\tfile->MachinePorts = tmp1;\n\tfile->MachineAddresses = tmp2;\n\tfile->MachinePorts[file->MachineCount - 1] = port;\n\tfile->MachineAddresses[file->MachineCount - 1] = _strdup(host);\n\treturn TRUE;\n}\nstatic BOOL append_address(rdpAssistanceFile* file, const char* host, const char* port)\n{\n\tunsigned long p;\n\terrno = 0;\n\tp = strtoul(port, NULL, 0);\n\n\tif ((errno != 0) || (p == 0) || (p > UINT16_MAX))\n\t{\n\t\tWLog_ERR(TAG, \"Failed to parse ASSISTANCE file: ConnectionString2 invalid port value %s\",\n\t\t         port);\n\t\treturn FALSE;\n\t}\n\n\treturn reallocate(file, host, (UINT16)p);\n}\nstatic BOOL freerdp_assistance_parse_connection_string1(rdpAssistanceFile* file)\n{\n\tsize_t i;\n\tchar* str;\n\tint count;\n\tsize_t length;\n\tchar* tokens[8];\n\tBOOL rc = FALSE;\n\n\tif (!file || !file->RCTicket)\n\t\treturn FALSE;\n\n\t/**\n\t * <ProtocolVersion>,<protocolType>,<machineAddressList>,<assistantAccountPwd>,\n\t * <RASessionID>,<RASessionName>,<RASessionPwd>,<protocolSpecificParms>\n\t */\n\tcount = 1;\n\tstr = _strdup(file->RCTicket);\n\n\tif (!str)\n\t\tgoto error;\n\n\tlength = strlen(str);\n\n\tfor (i = 0; i < length; i++)\n\t{\n\t\tif (str[i] == ',')\n\t\t\tcount++;\n\t}\n\n\tif (count != 8)\n\t\tgoto error;\n\n\tcount = 0;\n\ttokens[count++] = str;\n\n\tfor (i = 0; i < length; i++)\n\t{\n\t\tif (str[i] == ',')\n\t\t{\n\t\t\tstr[i] = '\\0';\n\t\t\ttokens[count++] = &str[i + 1];\n\t\t}\n\t}\n\n\tif (strcmp(tokens[0], \"65538\") != 0)\n\t\tgoto error;\n\n\tif (strcmp(tokens[1], \"1\") != 0)\n\t\tgoto error;\n\n\tif (strcmp(tokens[3], \"*\") != 0)\n\t\tgoto error;\n\n\tif (strcmp(tokens[5], \"*\") != 0)\n\t\tgoto error;\n\n\tif (strcmp(tokens[6], \"*\") != 0)\n\t\tgoto error;\n\n\tfile->RASessionId = _strdup(tokens[4]);\n\n\tif (!file->RASessionId)\n\t\tgoto error;\n\n\tfile->RASpecificParams = _strdup(tokens[7]);\n\n\tif (!file->RASpecificParams)\n\t\tgoto error;\n\n\tif (!freerdp_assistance_parse_address_list(file, tokens[2]))\n\t\tgoto error;\n\n\trc = TRUE;\nerror:\n\tfree(str);\n\treturn rc;\n}\nstatic BOOL freerdp_assistance_parse_connection_string2(rdpAssistanceFile* file)\n{\n\tchar* str;\n\tchar* tag;\n\tchar* end;\n\tchar* p;\n\tBOOL rc = FALSE;\n\n\tif (!file || !file->ConnectionString2)\n\t\treturn FALSE;\n\n\tstr = file->ConnectionString2;\n\n\tif (!strstr(str, \"<E>\"))\n\t{\n\t\tWLog_ERR(TAG, \"Failed to parse ASSISTANCE file: ConnectionString2 missing field <E>\");\n\t\treturn FALSE;\n\t}\n\n\tif (!strstr(str, \"<C>\"))\n\t{\n\t\tWLog_ERR(TAG, \"Failed to parse ASSISTANCE file: ConnectionString2 missing field <C>\");\n\t\treturn FALSE;\n\t}\n\n\tstr = _strdup(file->ConnectionString2);\n\n\tif (!str)\n\t\tgoto out_fail;\n\n\tif (!(tag = strstr(str, \"<A\")))\n\t{\n\t\tWLog_ERR(TAG, \"Failed to parse ASSISTANCE file: ConnectionString2 missing field <A\");\n\t\tgoto out_fail;\n\t}\n\n\t/* Parse Auth String Node (<A>) */\n\tend = strstr(tag, \"/>\");\n\n\tif (!end)\n\t\tgoto out_fail;\n\n\t*end = '\\0';\n\tp = strstr(tag, \"KH=\\\"\");\n\n\tif (p)\n\t{\n\t\tchar* q;\n\t\tsize_t length;\n\t\tp += sizeof(\"KH=\\\"\") - 1;\n\t\tq = strchr(p, '\"');\n\n\t\tif (!q)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Failed to parse ASSISTANCE file: ConnectionString2 invalid field KH=%s\",\n\t\t\t         q);\n\t\t\tgoto out_fail;\n\t\t}\n\n\t\tif (p > q)\n\t\t{\n\t\t\tWLog_ERR(\n\t\t\t    TAG,\n\t\t\t    \"Failed to parse ASSISTANCE file: ConnectionString2 invalid field order for KH\");\n\t\t\tgoto out_fail;\n\t\t}\n\n\t\tlength = q - p;\n\t\tfree(file->RASpecificParams);\n\t\tfile->RASpecificParams = (char*)malloc(length + 1);\n\n\t\tif (!file->RASpecificParams)\n\t\t\tgoto out_fail;\n\n\t\tCopyMemory(file->RASpecificParams, p, length);\n\t\tfile->RASpecificParams[length] = '\\0';\n\t}\n\n\tp = strstr(tag, \"ID=\\\"\");\n\n\tif (p)\n\t{\n\t\tchar* q;\n\t\tsize_t length;\n\t\tp += sizeof(\"ID=\\\"\") - 1;\n\t\tq = strchr(p, '\"');\n\n\t\tif (!q)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Failed to parse ASSISTANCE file: ConnectionString2 invalid field ID=%s\",\n\t\t\t         q);\n\t\t\tgoto out_fail;\n\t\t}\n\n\t\tif (p > q)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Failed to parse ASSISTANCE file: ConnectionString2 invalid field \"\n\t\t\t              \"order for ID\");\n\t\t\tgoto out_fail;\n\t\t}\n\t\tlength = q - p;\n\t\tfree(file->RASessionId);\n\t\tfile->RASessionId = (char*)malloc(length + 1);\n\n\t\tif (!file->RASessionId)\n\t\t\tgoto out_fail;\n\n\t\tCopyMemory(file->RASessionId, p, length);\n\t\tfile->RASessionId[length] = '\\0';\n\t}\n\n\t*end = '/';\n\t/* Parse <L  last address is used */\n\tp = strstr(str, \"<L P=\\\"\");\n\n\twhile (p)\n\t{\n\t\tchar* port;\n\t\tchar* q;\n\t\tsize_t length;\n\t\tp += sizeof(\"<L P=\\\"\") - 1;\n\t\tq = strchr(p, '\"');\n\n\t\tif (!q)\n\t\t{\n\t\t\tWLog_ERR(TAG,\n\t\t\t         \"Failed to parse ASSISTANCE file: ConnectionString2 invalid field <L P=%s\", q);\n\t\t\tgoto out_fail;\n\t\t}\n\n\t\tq[0] = '\\0';\n\t\tq++;\n\t\tport = p;\n\t\tp = strstr(q, \" N=\\\"\");\n\n\t\tif (!p)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Failed to parse ASSISTANCE file: ConnectionString2 invalid field N=%s\",\n\t\t\t         p);\n\t\t\tgoto out_fail;\n\t\t}\n\n\t\tp += sizeof(\" N=\\\"\") - 1;\n\t\tq = strchr(p, '\"');\n\n\t\tif (!q)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Failed to parse ASSISTANCE file: ConnectionString2 invalid field N=%s\",\n\t\t\t         q);\n\t\t\tgoto out_fail;\n\t\t}\n\n\t\tq[0] = '\\0';\n\t\tq++;\n\t\tlength = strlen(p);\n\n\t\tif (length > 6)\n\t\t{\n\t\t\tif (!append_address(file, p, port))\n\t\t\t\tgoto out_fail;\n\t\t}\n\n\t\tp = strstr(q, \"<L P=\\\"\");\n\t}\n\n\trc = TRUE;\nout_fail:\n\tfree(str);\n\treturn rc;\n}\nstatic BOOL freerdp_assistance_decrypt2(rdpAssistanceFile* file, const char* password)\n{\n\tBOOL rc = FALSE;\n\tint status = 0;\n\tsize_t cbPasswordW;\n\tsize_t cchOutW = 0;\n\tWINPR_CIPHER_CTX* aesDec = NULL;\n\tWCHAR* PasswordW = NULL;\n\tBYTE* pbIn = NULL;\n\tBYTE* pbOut = NULL;\n\tsize_t cbOut, cbIn, cbFinal;\n\tBYTE DerivedKey[WINPR_AES_BLOCK_SIZE] = { 0 };\n\tBYTE InitializationVector[WINPR_AES_BLOCK_SIZE] = { 0 };\n\tBYTE PasswordHash[WINPR_SHA1_DIGEST_LENGTH] = { 0 };\n\n\tif (!file || !password)\n\t\treturn FALSE;\n\n\tPasswordW = ConvertUtf8ToWCharAlloc(password, &cbPasswordW);\n\tif (!PasswordW)\n\t{\n\t\tWLog_ERR(TAG, \"Failed to parse ASSISTANCE file: Conversion from UCS2 to UTF8 failed\");\n\t\treturn FALSE;\n\t}\n\n\tcbPasswordW = (cbPasswordW) * sizeof(WCHAR);\n\n\tif (!winpr_Digest(WINPR_MD_SHA1, (BYTE*)PasswordW, cbPasswordW, PasswordHash,\n\t                  sizeof(PasswordHash)))\n\t\tgoto fail;\n\n\tif (!freerdp_assistance_crypt_derive_key_sha1(PasswordHash, sizeof(PasswordHash), DerivedKey,\n\t                                              sizeof(DerivedKey)))\n\t\tgoto fail;\n\n\taesDec =\n\t    winpr_Cipher_New(WINPR_CIPHER_AES_128_CBC, WINPR_DECRYPT, DerivedKey, InitializationVector);\n\n\tif (!aesDec)\n\t\tgoto fail;\n\n\tcbOut = cbFinal = 0;\n\tcbIn = (size_t)file->EncryptedLHTicketLength;\n\tpbIn = (BYTE*)file->EncryptedLHTicket;\n\tpbOut = (BYTE*)calloc(1, cbIn + WINPR_AES_BLOCK_SIZE + 2);\n\n\tif (!pbOut)\n\t\tgoto fail;\n\n\tif (!winpr_Cipher_Update(aesDec, pbIn, cbIn, pbOut, &cbOut))\n\t\tgoto fail;\n\n\tif (!winpr_Cipher_Final(aesDec, pbOut + cbOut, &cbFinal))\n\t{\n\t\tWLog_ERR(TAG, \"winpr_Cipher_Final failure\");\n\t\tgoto fail;\n\t}\n\n\tcbOut += cbFinal;\n\tcbFinal = 0;\n\n\tunion\n\t{\n\t\tconst WCHAR* wc;\n\t\tconst BYTE* b;\n\t} cnv;\n\n\tcnv.b = pbOut;\n\tcchOutW = cbOut / sizeof(WCHAR);\n\tfile->ConnectionString2 = ConvertWCharNToUtf8Alloc(cnv.wc, cchOutW, NULL);\n\tif (!file->ConnectionString2)\n\t{\n\t\tWLog_ERR(TAG, \"Failed to parse ASSISTANCE file: Conversion from UCS2 to UTF8 failed\");\n\t\tgoto fail;\n\t}\n\n\tif (!freerdp_assistance_parse_connection_string2(file))\n\t\tgoto fail;\n\n\trc = TRUE;\nfail:\n\twinpr_Cipher_Free(aesDec);\n\tfree(PasswordW);\n\tfree(pbOut);\n\tWLog_DBG(TAG, \"freerdp_assistance_parse_connection_string2: %d\", status);\n\treturn rc;\n}\nint freerdp_assistance_parse_file_buffer(rdpAssistanceFile* file, const char* buffer, size_t size,\n                                         const char* password)\n{\n\tchar* p;\n\tchar* q;\n\tchar* r;\n\tchar* amp;\n\tint status;\n\tsize_t length;\n\n\tfree(file->password);\n\tfile->password = _strdup(password);\n\n\tp = strstr(buffer, \"UPLOADINFO\");\n\n\tif (p)\n\t{\n\t\tp = strstr(p + sizeof(\"UPLOADINFO\") - 1, \"TYPE=\\\"\");\n\n\t\tif (!p)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Failed to parse ASSISTANCE file: Missing UPLOADINFO TYPE\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tp = strstr(buffer, \"UPLOADDATA\");\n\n\t\tif (!p)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Failed to parse ASSISTANCE file: Missing UPLOADDATA\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* Parse USERNAME */\n\t\tp = strstr(buffer, \"USERNAME=\\\"\");\n\n\t\tif (p)\n\t\t{\n\t\t\tp += sizeof(\"USERNAME=\\\"\") - 1;\n\t\t\tq = strchr(p, '\"');\n\n\t\t\tif (!q)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Failed to parse ASSISTANCE file: Invalid USERNAME=%s\", p);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (p > q)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Failed to parse ASSISTANCE file: invalid field \"\n\t\t\t\t              \"order for USERNAME\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tlength = q - p;\n\t\t\tfile->Username = (char*)malloc(length + 1);\n\n\t\t\tif (!file->Username)\n\t\t\t\treturn -1;\n\n\t\t\tCopyMemory(file->Username, p, length);\n\t\t\tfile->Username[length] = '\\0';\n\t\t}\n\n\t\t/* Parse LHTICKET */\n\t\tp = strstr(buffer, \"LHTICKET=\\\"\");\n\n\t\tif (p)\n\t\t{\n\t\t\tp += sizeof(\"LHTICKET=\\\"\") - 1;\n\t\t\tq = strchr(p, '\"');\n\n\t\t\tif (!q)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Failed to parse ASSISTANCE file: Invalid LHTICKET=%s\", p);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (p > q)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Failed to parse ASSISTANCE file: invalid field \"\n\t\t\t\t              \"order for LHTICKET\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tlength = q - p;\n\t\t\tfile->LHTicket = (char*)malloc(length + 1);\n\n\t\t\tif (!file->LHTicket)\n\t\t\t\treturn -1;\n\n\t\t\tCopyMemory(file->LHTicket, p, length);\n\t\t\tfile->LHTicket[length] = '\\0';\n\t\t}\n\n\t\t/* Parse RCTICKET */\n\t\tp = strstr(buffer, \"RCTICKET=\\\"\");\n\n\t\tif (p)\n\t\t{\n\t\t\tp += sizeof(\"RCTICKET=\\\"\") - 1;\n\t\t\tq = strchr(p, '\"');\n\n\t\t\tif (!q)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Failed to parse ASSISTANCE file: Invalid RCTICKET=%s\", p);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (p > q)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Failed to parse ASSISTANCE file: invalid field \"\n\t\t\t\t              \"order for RCTICKET\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tlength = q - p;\n\t\t\tfile->RCTicket = (char*)malloc(length + 1);\n\n\t\t\tif (!file->RCTicket)\n\t\t\t\treturn -1;\n\n\t\t\tCopyMemory(file->RCTicket, p, length);\n\t\t\tfile->RCTicket[length] = '\\0';\n\t\t}\n\n\t\t/* Parse RCTICKETENCRYPTED */\n\t\tp = strstr(buffer, \"RCTICKETENCRYPTED=\\\"\");\n\n\t\tif (p)\n\t\t{\n\t\t\tp += sizeof(\"RCTICKETENCRYPTED=\\\"\") - 1;\n\t\t\tq = strchr(p, '\"');\n\n\t\t\tif (!q)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Failed to parse ASSISTANCE file: Invalid RCTICKETENCRYPTED=%s\", p);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (p > q)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Failed to parse ASSISTANCE file: invalid field \"\n\t\t\t\t              \"order for RCTICKETENCRYPTED\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tlength = q - p;\n\n\t\t\tif ((length == 1) && (p[0] == '1'))\n\t\t\t\tfile->RCTicketEncrypted = TRUE;\n\t\t}\n\n\t\t/* Parse PassStub */\n\t\tp = strstr(buffer, \"PassStub=\\\"\");\n\n\t\tif (p)\n\t\t{\n\t\t\tp += sizeof(\"PassStub=\\\"\") - 1;\n\n\t\t\t// needs to be unescaped (&amp; => &)\n\t\t\tamp = strstr(p, \"&amp;\");\n\n\t\t\tq = strchr(p, '\"');\n\n\t\t\tif (!q)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Failed to parse ASSISTANCE file: Invalid PassStub=%s\", p);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (p > q)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Failed to parse ASSISTANCE file: invalid field \"\n\t\t\t\t              \"order for PassStub\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (amp)\n\t\t\t{\n\t\t\t\tlength = q - p - 4;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlength = q - p;\n\t\t\t}\n\n\t\t\tfile->PassStub = (char*)malloc(length + 1);\n\n\t\t\tif (!file->PassStub)\n\t\t\t\treturn -1;\n\n\t\t\tif (amp)\n\t\t\t{\n\t\t\t\t// just skip over \"amp;\" leaving \"&\"\n\t\t\t\tCopyMemory(file->PassStub, p, amp - p + 1);\n\t\t\t\tCopyMemory(file->PassStub + (amp - p + 1), amp + 5, q - amp + 5);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tCopyMemory(file->PassStub, p, length);\n\t\t\t}\n\n\t\t\tfile->PassStub[length] = '\\0';\n\t\t}\n\n\t\t/* Parse DtStart */\n\t\tp = strstr(buffer, \"DtStart=\\\"\");\n\n\t\tif (p)\n\t\t{\n\t\t\tp += sizeof(\"DtStart=\\\"\") - 1;\n\t\t\tq = strchr(p, '\"');\n\n\t\t\tif (!q)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Failed to parse ASSISTANCE file: Invalid DtStart=%s\", p);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (p > q)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Failed to parse ASSISTANCE file: invalid field \"\n\t\t\t\t              \"order for DtStart\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tlength = q - p;\n\t\t\tr = (char*)malloc(length + 1);\n\n\t\t\tif (!r)\n\t\t\t\treturn -1;\n\n\t\t\tCopyMemory(r, p, length);\n\t\t\tr[length] = '\\0';\n\t\t\terrno = 0;\n\t\t\t{\n\t\t\t\tunsigned long val = strtoul(r, NULL, 0);\n\n\t\t\t\tif ((errno != 0) || (val > UINT32_MAX))\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(TAG, \"Failed to parse ASSISTANCE file: Invalid DtStart value %s\", r);\n\t\t\t\t\tfree(r);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tfree(r);\n\t\t\t\tfile->DtStart = val;\n\t\t\t}\n\t\t}\n\n\t\t/* Parse DtLength */\n\t\tp = strstr(buffer, \"DtLength=\\\"\");\n\n\t\tif (p)\n\t\t{\n\t\t\tp += sizeof(\"DtLength=\\\"\") - 1;\n\t\t\tq = strchr(p, '\"');\n\n\t\t\tif (!q)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Failed to parse ASSISTANCE file: Invalid DtLength=%s\", p);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (p > q)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Failed to parse ASSISTANCE file: invalid field \"\n\t\t\t\t              \"order for DtLength\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tlength = q - p;\n\t\t\tr = (char*)malloc(length + 1);\n\n\t\t\tif (!r)\n\t\t\t\treturn -1;\n\n\t\t\tCopyMemory(r, p, length);\n\t\t\tr[length] = '\\0';\n\t\t\terrno = 0;\n\t\t\t{\n\t\t\t\tunsigned long val = strtoul(r, NULL, 0);\n\n\t\t\t\tif ((errno != 0) || (val > UINT32_MAX))\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(TAG, \"Failed to parse ASSISTANCE file: Invalid DtLength value %s\", r);\n\t\t\t\t\tfree(r);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tfree(r);\n\t\t\t\tfile->DtLength = val;\n\t\t\t}\n\t\t}\n\n\t\t/* Parse L (LowSpeed) */\n\t\tp = strstr(buffer, \" L=\\\"\");\n\n\t\tif (p)\n\t\t{\n\t\t\tp += sizeof(\" L=\\\"\") - 1;\n\t\t\tq = strchr(p, '\"');\n\n\t\t\tif (!q)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Failed to parse ASSISTANCE file: Invalid L=%s\", p);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (p > q)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Failed to parse ASSISTANCE file: invalid field \"\n\t\t\t\t              \"order for L\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tlength = q - p;\n\n\t\t\tif ((length == 1) && (p[0] == '1'))\n\t\t\t\tfile->LowSpeed = TRUE;\n\t\t}\n\n\t\tfile->Type = (file->LHTicket) ? 2 : 1;\n\t\tstatus = 0;\n\n\t\tswitch (file->Type)\n\t\t{\n\t\t\tcase 2:\n\t\t\t{\n\t\t\t\tfile->EncryptedLHTicket = freerdp_assistance_hex_string_to_bin(\n\t\t\t\t    file->LHTicket, &file->EncryptedLHTicketLength);\n\n\t\t\t\tif (!freerdp_assistance_decrypt2(file, password))\n\t\t\t\t\tstatus = -1;\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\tcase 1:\n\t\t\t{\n\t\t\t\tif (!freerdp_assistance_parse_connection_string1(file))\n\t\t\t\t\tstatus = -1;\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tif (status < 0)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"freerdp_assistance_parse_connection_string1 failure: %d\", status);\n\t\t\treturn -1;\n\t\t}\n\n\t\tfile->EncryptedPassStub = freerdp_assistance_encrypt_pass_stub(\n\t\t    password, file->PassStub, &file->EncryptedPassStubLength);\n\n\t\tif (!file->EncryptedPassStub)\n\t\t\treturn -1;\n\n\t\treturn 1;\n\t}\n\n\tp = strstr(buffer, \"<E>\");\n\n\tif (p)\n\t{\n\t\tq = strstr(buffer, \"</E>\");\n\n\t\tif (!q)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Failed to parse ASSISTANCE file: Missing </E> tag\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (p > q)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Failed to parse ASSISTANCE file: invalid field order for <E>\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tq += sizeof(\"</E>\") - 1;\n\t\tlength = q - p;\n\t\tfile->ConnectionString2 = (char*)malloc(length + 1);\n\n\t\tif (!file->ConnectionString2)\n\t\t\treturn -1;\n\n\t\tCopyMemory(file->ConnectionString2, p, length);\n\t\tfile->ConnectionString2[length] = '\\0';\n\n\t\tif (!freerdp_assistance_parse_connection_string2(file))\n\t\t\treturn -1;\n\n\t\treturn 1;\n\t}\n\n\tWLog_ERR(TAG, \"Failed to parse ASSISTANCE file: Neither UPLOADINFO nor <E> found\");\n\treturn -1;\n}\nint freerdp_assistance_parse_file(rdpAssistanceFile* file, const char* name, const char* password)\n{\n\tint status;\n\tBYTE* buffer;\n\tFILE* fp = NULL;\n\tsize_t readSize;\n\tunion\n\t{\n\t\tINT64 i64;\n\t\tsize_t s;\n\t} fileSize;\n\n\tif (!name)\n\t{\n\t\tWLog_ERR(TAG, \"ASSISTANCE file %s invalid name\", name);\n\t\treturn -1;\n\t}\n\n\tfree(file->filename);\n\tfile->filename = _strdup(name);\n\tfp = winpr_fopen(name, \"r\");\n\n\tif (!fp)\n\t{\n\t\tWLog_ERR(TAG, \"Failed to open ASSISTANCE file %s \", name);\n\t\treturn -1;\n\t}\n\n\t_fseeki64(fp, 0, SEEK_END);\n\tfileSize.i64 = _ftelli64(fp);\n\t_fseeki64(fp, 0, SEEK_SET);\n\n\tif (fileSize.i64 < 1)\n\t{\n\t\tWLog_ERR(TAG, \"Failed to read ASSISTANCE file %s \", name);\n\t\tfclose(fp);\n\t\treturn -1;\n\t}\n\n\tbuffer = (BYTE*)malloc(fileSize.s + 2);\n\n\tif (!buffer)\n\t{\n\t\tfclose(fp);\n\t\treturn -1;\n\t}\n\n\treadSize = fread(buffer, fileSize.s, 1, fp);\n\n\tif (!readSize)\n\t{\n\t\tif (!ferror(fp))\n\t\t\treadSize = fileSize.s;\n\t}\n\n\tfclose(fp);\n\n\tif (readSize < 1)\n\t{\n\t\tWLog_ERR(TAG, \"Failed to read ASSISTANCE file %s \", name);\n\t\tfree(buffer);\n\t\tbuffer = NULL;\n\t\treturn -1;\n\t}\n\n\tbuffer[fileSize.s] = '\\0';\n\tbuffer[fileSize.s + 1] = '\\0';\n\tstatus = freerdp_assistance_parse_file_buffer(file, (char*)buffer, fileSize.s, password);\n\tfree(buffer);\n\treturn status;\n}\nBOOL freerdp_assistance_populate_settings_from_assistance_file(rdpAssistanceFile* file,\n                                                               rdpSettings* settings)\n{\n\tUINT32 i;\n\n\tif (!freerdp_settings_set_bool(settings, FreeRDP_RemoteAssistanceMode, TRUE))\n\t\treturn FALSE;\n\n\tif (!file->RASessionId || !file->MachineAddresses)\n\t\treturn FALSE;\n\n\tif (!freerdp_settings_set_string(settings, FreeRDP_RemoteAssistanceSessionId,\n\t                                 file->RASessionId))\n\t\treturn FALSE;\n\n\tif (file->RCTicket)\n\t{\n\t\tif (!freerdp_settings_set_string(settings, FreeRDP_RemoteAssistanceRCTicket,\n\t\t                                 file->RCTicket))\n\t\t\treturn FALSE;\n\t}\n\telse\n\t{\n\t\tif (!freerdp_settings_set_string(settings, FreeRDP_RemoteAssistanceRCTicket,\n\t\t                                 file->ConnectionString2))\n\t\t\treturn FALSE;\n\t}\n\n\tif (file->PassStub)\n\t{\n\t\tif (!freerdp_settings_set_string(settings, FreeRDP_RemoteAssistancePassStub,\n\t\t                                 file->PassStub))\n\t\t\treturn FALSE;\n\t}\n\n\tif (!freerdp_settings_set_string(settings, FreeRDP_ServerHostname, file->MachineAddresses[0]))\n\t\treturn FALSE;\n\n\tif (!freerdp_settings_set_string(settings, FreeRDP_AssistanceFile, file->filename))\n\t\treturn FALSE;\n\n\tif (!freerdp_settings_set_string(settings, FreeRDP_RemoteAssistancePassword, file->password))\n\t\treturn FALSE;\n\n\tif (file->Username)\n\t{\n\t\tif (!freerdp_settings_set_string(settings, FreeRDP_Username, file->Username))\n\t\t\treturn FALSE;\n\t}\n\n\tif (!freerdp_settings_set_bool(settings, FreeRDP_RemoteAssistanceMode, TRUE))\n\t\treturn FALSE;\n\n\tif (!freerdp_settings_set_uint32(settings, FreeRDP_ServerPort, file->MachinePorts[0]))\n\t\treturn FALSE;\n\n\tif (!freerdp_settings_set_pointer_len(settings, FreeRDP_TargetNetAddresses, NULL,\n\t                                      file->MachineCount))\n\t\treturn FALSE;\n\tif (!freerdp_settings_set_pointer_len(settings, FreeRDP_TargetNetPorts, file->MachinePorts,\n\t                                      file->MachineCount))\n\t\treturn FALSE;\n\n\tfor (i = 0; i < file->MachineCount; i++)\n\t{\n\t\tif (!freerdp_settings_set_pointer_array(settings, FreeRDP_TargetNetAddresses, i,\n\t\t                                        file->MachineAddresses[i]))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\nvoid freerdp_assistance_file_free(rdpAssistanceFile* file)\n{\n\tUINT32 i;\n\n\tif (!file)\n\t\treturn;\n\n\tfree(file->filename);\n\tfree(file->password);\n\tfree(file->Username);\n\tfree(file->LHTicket);\n\tfree(file->RCTicket);\n\tfree(file->PassStub);\n\tfree(file->ConnectionString1);\n\tfree(file->ConnectionString2);\n\tfree(file->EncryptedLHTicket);\n\tfree(file->RASessionId);\n\tfree(file->RASpecificParams);\n\tfree(file->EncryptedPassStub);\n\n\tfor (i = 0; i < file->MachineCount; i++)\n\t{\n\t\tfree(file->MachineAddresses[i]);\n\t}\n\n\tfree(file->MachineAddresses);\n\tfree(file->MachinePorts);\n\tfree(file);\n}\nvoid freerdp_assistance_print_file(rdpAssistanceFile* file, wLog* log, DWORD level)\n{\n\tsize_t x;\n\tWLog_Print(log, level, \"Username: %s\", file->Username);\n\tWLog_Print(log, level, \"LHTicket: %s\", file->LHTicket);\n\tWLog_Print(log, level, \"RCTicket: %s\", file->RCTicket);\n\tWLog_Print(log, level, \"RCTicketEncrypted: %\" PRId32, file->RCTicketEncrypted);\n\tWLog_Print(log, level, \"PassStub: %s\", file->PassStub);\n\tWLog_Print(log, level, \"DtStart: %\" PRIu32, file->DtStart);\n\tWLog_Print(log, level, \"DtLength: %\" PRIu32, file->DtLength);\n\tWLog_Print(log, level, \"LowSpeed: %\" PRId32, file->LowSpeed);\n\tWLog_Print(log, level, \"RASessionId: %s\", file->RASessionId);\n\tWLog_Print(log, level, \"RASpecificParams: %s\", file->RASpecificParams);\n\n\tfor (x = 0; x < file->MachineCount; x++)\n\t{\n\t\tWLog_Print(log, level, \"MachineAddress [%\" PRIdz \": %s\", x, file->MachineAddresses[x]);\n\t\tWLog_Print(log, level, \"MachinePort    [%\" PRIdz \": %\" PRIu32, x, file->MachinePorts[x]);\n\t}\n}\nBOOL freerdp_assistance_get_encrypted_pass_stub(rdpAssistanceFile* file, const char** pwd,\n                                                size_t* size)\n{\n\tif (!file || !pwd || !size)\n\t\treturn FALSE;\n\n\t*pwd = (const char*)file->EncryptedPassStub;\n\t*size = file->EncryptedPassStubLength;\n\treturn TRUE;\n}\nint freerdp_assistance_set_connection_string2(rdpAssistanceFile* file, const char* string,\n                                              const char* password)\n{\n\tif (!file || !string || !password)\n\t\treturn -1;\n\n\tfree(file->ConnectionString2);\n\tfree(file->password);\n\tfile->ConnectionString2 = _strdup(string);\n\tfile->password = _strdup(password);\n\treturn freerdp_assistance_parse_connection_string2(file);\n}\nstatic BOOL test_msrsc_incident_file_type1(wLog* log)\n{\n\tBOOL rc = FALSE;\n\tint status;\n\tchar* pass = NULL;\n\tchar* expertBlob = NULL;\n\tconst char* EncryptedPassStub;\n\tsize_t EncryptedPassStubLength;\n\trdpAssistanceFile* file = freerdp_assistance_file_new();\n\n\tif (!file)\n\t\treturn -1;\n\n\tstatus = freerdp_assistance_parse_file_buffer(file, TEST_MSRC_INCIDENT_FILE_TYPE1,\n\t                                              sizeof(TEST_MSRC_INCIDENT_FILE_TYPE1),\n\t                                              TEST_MSRC_INCIDENT_PASSWORD_TYPE1);\n\tWLog_Print(log, WLOG_INFO, \"freerdp_assistance_parse_file_buffer: %d\", status);\n\n\tif (status < 0)\n\t\tgoto fail;\n\n\tfreerdp_assistance_print_file(file, WLog_Get(\"foo\"), WLOG_INFO);\n\n\tif (!freerdp_assistance_get_encrypted_pass_stub(file, &EncryptedPassStub,\n\t                                                &EncryptedPassStubLength))\n\t\tgoto fail;\n\n\tpass = freerdp_assistance_bin_to_hex_string(EncryptedPassStub, EncryptedPassStubLength);\n\n\tif (!pass)\n\t\tgoto fail;\n\n\tWLog_Print(log, WLOG_INFO, \"freerdp_assistance_decrypt: %d %s [%\" PRIdz \"]\", status, pass,\n\t           EncryptedPassStubLength);\n\texpertBlob = freerdp_assistance_construct_expert_blob(\"Edgar Olougouna\", pass);\n\tWLog_Print(log, WLOG_INFO, \"expertBlob='%s'\", expertBlob);\n\trc = TRUE;\nfail:\n\tfreerdp_assistance_file_free(file);\n\tfree(pass);\n\tfree(expertBlob);\n\treturn rc;\n}\nstatic BOOL test_msrsc_incident_file_type2(wLog* log)\n{\n\tint status = -1;\n\tchar* pass = NULL;\n\tchar* expertBlob = NULL;\n\tconst char* EncryptedPassStub = NULL;\n\tsize_t EncryptedPassStubLength;\n\trdpAssistanceFile* file = freerdp_assistance_file_new();\n\n\tif (!file)\n\t\treturn -1;\n\n\tstatus = freerdp_assistance_parse_file_buffer(file, TEST_MSRC_INCIDENT_FILE_TYPE2,\n\t                                              sizeof(TEST_MSRC_INCIDENT_FILE_TYPE2),\n\t                                              TEST_MSRC_INCIDENT_PASSWORD_TYPE2);\n\tprintf(\"freerdp_assistance_parse_file_buffer: %d\\n\", status);\n\n\tif (status < 0)\n\t\tgoto fail;\n\n\tfreerdp_assistance_print_file(file, log, WLOG_INFO);\n\tstatus = freerdp_assistance_get_encrypted_pass_stub(file, &EncryptedPassStub,\n\t                                                    &EncryptedPassStubLength);\n\tpass = freerdp_assistance_bin_to_hex_string(EncryptedPassStub, EncryptedPassStubLength);\n\n\tif (!pass)\n\t\tgoto fail;\n\n\tWLog_Print(log, WLOG_INFO, \"freerdp_assistance_decrypt: %d %s [%\" PRIdz \"]\", status, pass,\n\t           EncryptedPassStubLength);\n\n\tif (status < 0)\n\t\tgoto fail;\n\n\texpertBlob = freerdp_assistance_construct_expert_blob(\"Edgar Olougouna\", pass);\n\tWLog_Print(log, WLOG_INFO, \"expertBlob='%s'\", expertBlob);\nfail:\n\tfreerdp_assistance_file_free(file);\n\tfree(expertBlob);\n\tfree(pass);\n\treturn status >= 0 ? TRUE : FALSE;\n}\n",
    "target": 1,
    "idx": 1059682,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "// context\n\n// target function\n    simdutf_really_inline size_t convert(const char* in, size_t size, char32_t* utf32_output) {\n      size_t pos = 0;\n      char32_t* start{utf32_output};\n      // In the worst case, we have the haswell kernel which can cause an overflow of\n      // 8 bytes when calling convert_masked_utf8_to_utf32. If you skip the last 16 bytes,\n      // and if the data is valid, then it is entirely safe because 16 UTF-8 bytes generate\n      // much more than 8 bytes. However, you cannot generally assume that you have valid\n      // UTF-8 input, so we are going to go back from the end counting 4 leading bytes,\n      // to give us a good margin.\n      size_t leading_byte = 0;\n      size_t margin = size;\n      for(; margin > 0 && leading_byte < 4; margin--) {\n        leading_byte += (int8_t(in[margin-1]) > -65);\n      }\n      // If the input is long enough, then we have that margin-1 is the fourth last leading byte.\n      const size_t safety_margin = size - margin + 1; // to avoid overruns!\n      while(pos + 64 + safety_margin <= size) {\n        simd8x64<int8_t> input(reinterpret_cast<const int8_t *>(in + pos));\n        if(input.is_ascii()) {\n          input.store_ascii_as_utf32(utf32_output);\n          utf32_output += 64;\n          pos += 64;\n        } else {\n          // you might think that a for-loop would work, but under Visual Studio, it is not good enough.\n          static_assert((simd8x64<uint8_t>::NUM_CHUNKS == 2) || (simd8x64<uint8_t>::NUM_CHUNKS == 4),\n              \"We support either two or four chunks per 64-byte block.\");\n          auto zero = simd8<uint8_t>{uint8_t(0)};\n          if(simd8x64<uint8_t>::NUM_CHUNKS == 2) {\n            this->check_utf8_bytes(input.chunks[0], zero);\n            this->check_utf8_bytes(input.chunks[1], input.chunks[0]);\n          } else if(simd8x64<uint8_t>::NUM_CHUNKS == 4) {\n            this->check_utf8_bytes(input.chunks[0], zero);\n            this->check_utf8_bytes(input.chunks[1], input.chunks[0]);\n            this->check_utf8_bytes(input.chunks[2], input.chunks[1]);\n            this->check_utf8_bytes(input.chunks[3], input.chunks[2]);\n          }\n          uint64_t utf8_continuation_mask = input.lt(-65 + 1);\n          uint64_t utf8_leading_mask = ~utf8_continuation_mask;\n          uint64_t utf8_end_of_code_point_mask = utf8_leading_mask>>1;\n          // We process in blocks of up to 12 bytes except possibly\n          // for fast paths which may process up to 16 bytes. For the\n          // slow path to work, we should have at least 12 input bytes left.\n          size_t max_starting_point = (pos + 64) - 12;\n          // Next loop is going to run at least five times.\n          while(pos < max_starting_point) {\n            // Performance note: our ability to compute 'consumed' and\n            // then shift and recompute is critical. If there is a\n            // latency of, say, 4 cycles on getting 'consumed', then\n            // the inner loop might have a total latency of about 6 cycles.\n            // Yet we process between 6 to 12 inputs bytes, thus we get\n            // a speed limit between 1 cycle/byte and 0.5 cycle/byte\n            // for this section of the code. Hence, there is a limit\n            // to how much we can further increase this latency before\n            // it seriously harms performance.\n            size_t consumed = convert_masked_utf8_to_utf32(in + pos,\n                            utf8_end_of_code_point_mask, utf32_output);\n            pos += consumed;\n            utf8_end_of_code_point_mask >>= consumed;\n          }\n          // At this point there may remain between 0 and 12 bytes in the\n          // 64-byte block. These bytes will be processed again. So we have an\n          // 80% efficiency (in the worst case). In practice we expect an\n          // 85% to 90% efficiency.\n        }\n      }\n      if(errors()) { return 0; }\n      if(pos < size) {\n        size_t howmany  = scalar::utf8_to_utf32::convert(in + pos, size - pos, utf32_output);\n        if(howmany == 0) { return 0; }\n        utf32_output += howmany;\n      }\n      return utf32_output - start;\n    }\n    simdutf_really_inline result convert_with_errors(const char* in, size_t size, char32_t* utf32_output) {\n      size_t pos = 0;\n      char32_t* start{utf32_output};\n      // In the worst case, we have the haswell kernel which can cause an overflow of\n      // 8 bytes when calling convert_masked_utf8_to_utf32. If you skip the last 16 bytes,\n      // and if the data is valid, then it is entirely safe because 16 UTF-8 bytes generate\n      // much more than 8 bytes. However, you cannot generally assume that you have valid\n      // UTF-8 input, so we are going to go back from the end counting 4 leading bytes,\n      // to give us a good margin.\n      size_t leading_byte = 0;\n      size_t margin = size;\n      for(; margin > 0 && leading_byte < 4; margin--) {\n        leading_byte += (int8_t(in[margin-1]) > -65);\n      }\n      // If the input is long enough, then we have that margin-1 is the fourth last leading byte.\n      const size_t safety_margin = size - margin + 1; // to avoid overruns!\n      while(pos + 64 + safety_margin <= size) {\n        simd8x64<int8_t> input(reinterpret_cast<const int8_t *>(in + pos));\n        if(input.is_ascii()) {\n          input.store_ascii_as_utf32(utf32_output);\n          utf32_output += 64;\n          pos += 64;\n        } else {\n          // you might think that a for-loop would work, but under Visual Studio, it is not good enough.\n          static_assert((simd8x64<uint8_t>::NUM_CHUNKS == 2) || (simd8x64<uint8_t>::NUM_CHUNKS == 4),\n              \"We support either two or four chunks per 64-byte block.\");\n          auto zero = simd8<uint8_t>{uint8_t(0)};\n          if(simd8x64<uint8_t>::NUM_CHUNKS == 2) {\n            this->check_utf8_bytes(input.chunks[0], zero);\n            this->check_utf8_bytes(input.chunks[1], input.chunks[0]);\n          } else if(simd8x64<uint8_t>::NUM_CHUNKS == 4) {\n            this->check_utf8_bytes(input.chunks[0], zero);\n            this->check_utf8_bytes(input.chunks[1], input.chunks[0]);\n            this->check_utf8_bytes(input.chunks[2], input.chunks[1]);\n            this->check_utf8_bytes(input.chunks[3], input.chunks[2]);\n          }\n          if (errors()) {\n            result res = scalar::utf8_to_utf32::rewind_and_convert_with_errors(pos, in + pos, size - pos, utf32_output);\n            res.count += pos;\n            return res;\n          }\n          uint64_t utf8_continuation_mask = input.lt(-65 + 1);\n          uint64_t utf8_leading_mask = ~utf8_continuation_mask;\n          uint64_t utf8_end_of_code_point_mask = utf8_leading_mask>>1;\n          // We process in blocks of up to 12 bytes except possibly\n          // for fast paths which may process up to 16 bytes. For the\n          // slow path to work, we should have at least 12 input bytes left.\n          size_t max_starting_point = (pos + 64) - 12;\n          // Next loop is going to run at least five times.\n          while(pos < max_starting_point) {\n            // Performance note: our ability to compute 'consumed' and\n            // then shift and recompute is critical. If there is a\n            // latency of, say, 4 cycles on getting 'consumed', then\n            // the inner loop might have a total latency of about 6 cycles.\n            // Yet we process between 6 to 12 inputs bytes, thus we get\n            // a speed limit between 1 cycle/byte and 0.5 cycle/byte\n            // for this section of the code. Hence, there is a limit\n            // to how much we can further increase this latency before\n            // it seriously harms performance.\n            size_t consumed = convert_masked_utf8_to_utf32(in + pos,\n                            utf8_end_of_code_point_mask, utf32_output);\n            pos += consumed;\n            utf8_end_of_code_point_mask >>= consumed;\n          }\n          // At this point there may remain between 0 and 12 bytes in the\n          // 64-byte block. These bytes will be processed again. So we have an\n          // 80% efficiency (in the worst case). In practice we expect an\n          // 85% to 90% efficiency.\n        }\n      }\n      if(errors()) {\n        result res = scalar::utf8_to_utf32::rewind_and_convert_with_errors(pos, in + pos, size - pos, utf32_output);\n        res.count += pos;\n        return res;\n      }\n      if(pos < size) {\n        result res = scalar::utf8_to_utf32::rewind_and_convert_with_errors(pos, in + pos, size - pos, utf32_output);\n        if (res.error) {    // In case of error, we want the error position\n          res.count += pos;\n          return res;\n        } else {    // In case of success, we want the number of word written\n          utf32_output += res.count;\n        }\n      }\n      return result(error_code::SUCCESS, utf32_output - start);\n    }\nTEST(convert_null_4_UTF8_bytes) {\n  for(size_t trial = 0; trial < trials; trial ++) {\n    uint32_t seed{1234+uint32_t(trial)};\n    if((trial % 100) == 0) { std::cout << \".\"; std::cout.flush(); }\n    simdutf::tests::helpers::RandomIntRanges random({{0x0000, 0x00000},\n                                                     {0x10000, 0x10ffff}}, seed); // range for 3 or 4 UTF-8 bytes\n\n    auto procedure = [&implementation](const char* utf8, size_t size, char32_t* utf32) -> size_t {\n      return implementation.convert_utf8_to_utf32(utf8, size, utf32);\n    };\n\n    for (size_t size: input_size) {\n      transcode_utf8_to_utf32_test_base test(random, size);\n      ASSERT_TRUE(test(procedure));\n    }\n  }\n}\nint main(int argc, char* argv[]) {\n  return simdutf::test::main(argc, argv);\n}\n",
    "target": 1,
    "idx": 1066063,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "// context\nstatic uint16_t ipcsum(const void *buf, size_t len) {\n  uint32_t sum = csumup(0, buf, len);\n  return csumfin(sum);\n}\n\nstatic void rx_icmp(struct mip_if *ifp, struct pkt *pkt) {\n  // MG_DEBUG((\"ICMP %d\", (int) len));\n  if (pkt->icmp->type == 8 && pkt->ip != NULL && pkt->ip->dst == ifp->ip) {\n    struct ip *ip = tx_ip(ifp, 1, ifp->ip, pkt->ip->src,\n                          sizeof(struct icmp) + pkt->pay.len);\n    struct icmp *icmp = (struct icmp *) (ip + 1);\n    size_t len = PDIFF(ifp->tx.buf, icmp + 1), left = ifp->tx.len - len;\n    if (left > pkt->pay.len) left = pkt->pay.len;  // Don't overflow TX\n    memset(icmp, 0, sizeof(*icmp));                // Set csum to 0\n    memcpy(icmp + 1, pkt->pay.buf, left);          // Copy RX payload to TX\n    icmp->csum = ipcsum(icmp, sizeof(*icmp) + left);\n    ifp->driver->tx(ifp->tx.buf, len + left, ifp->driver_data);\n  }\n}\n\nstatic void rx_ip(struct mip_if *ifp, struct pkt *pkt) {\n  // MG_DEBUG((\"IP %d\", (int) pkt->pay.len));\n  if (pkt->ip->proto == 1) {\n    pkt->icmp = (struct icmp *) (pkt->ip + 1);\n    if (pkt->pay.len < sizeof(*pkt->icmp)) return;\n    mkpay(pkt, pkt->icmp + 1);\n    rx_icmp(ifp, pkt);\n  } else if (pkt->ip->proto == 17) {\n    pkt->udp = (struct udp *) (pkt->ip + 1);\n    if (pkt->pay.len < sizeof(*pkt->udp)) return;\n    // MG_DEBUG((\"  UDP %u %u -> %u\", len, mg_htons(udp->sport),\n    // mg_htons(udp->dport)));\n    mkpay(pkt, pkt->udp + 1);\n    if (pkt->udp->dport == mg_htons(68)) {\n      pkt->dhcp = (struct dhcp *) (pkt->udp + 1);\n      mkpay(pkt, pkt->dhcp + 1);\n      rx_dhcp(ifp, pkt);\n    } else {\n      rx_udp(ifp, pkt);\n    }\n  } else if (pkt->ip->proto == 6) {\n    pkt->tcp = (struct tcp *) (pkt->ip + 1);\n    if (pkt->pay.len < sizeof(*pkt->tcp)) return;\n    mkpay(pkt, pkt->tcp + 1);\n    uint16_t iplen = mg_ntohs(pkt->ip->len);\n    uint16_t off = (uint16_t) (sizeof(*pkt->ip) + ((pkt->tcp->off >> 4) * 4U));\n    if (iplen >= off) pkt->pay.len = (size_t) (iplen - off);\n    rx_tcp(ifp, pkt);\n  }\n}\n\nstatic void mip_rx(struct mip_if *ifp, void *buf, size_t len) {\n  const uint8_t broadcast[] = {255, 255, 255, 255, 255, 255};\n  // struct pkt pkt = {.raw = {.buf = (uint8_t *) buf, .len = len}};\n  struct pkt pkt;\n  memset(&pkt, 0, sizeof(pkt));\n  pkt.raw.buf = (uint8_t *) buf;\n  pkt.raw.len = len;\n  pkt.eth = (struct eth *) buf;\n  if (pkt.raw.len < sizeof(*pkt.eth)) return;  // Truncated - runt?\n  if (memcmp(pkt.eth->dst, ifp->mac, sizeof(pkt.eth->dst)) != 0 &&\n      memcmp(pkt.eth->dst, broadcast, sizeof(pkt.eth->dst)) != 0) {\n    // Not for us. Drop silently\n  } else if (pkt.eth->type == mg_htons(0x806)) {\n    pkt.arp = (struct arp *) (pkt.eth + 1);\n    if (sizeof(*pkt.eth) + sizeof(*pkt.arp) > pkt.raw.len) return;  // Truncated\n    rx_arp(ifp, &pkt);\n  } else if (pkt.eth->type == mg_htons(0x86dd)) {\n    pkt.ip6 = (struct ip6 *) (pkt.eth + 1);\n    if (pkt.raw.len < sizeof(*pkt.eth) + sizeof(*pkt.ip6)) return;  // Truncated\n    if ((pkt.ip6->ver >> 4) != 0x6) return;                         // Not IP\n    mkpay(&pkt, pkt.ip6 + 1);\n    rx_ip6(ifp, &pkt);\n  } else if (pkt.eth->type == mg_htons(0x800)) {\n    pkt.ip = (struct ip *) (pkt.eth + 1);\n    if (pkt.raw.len < sizeof(*pkt.eth) + sizeof(*pkt.ip)) return;  // Truncated\n    if ((pkt.ip->ver >> 4) != 4) return;                           // Not IP\n    mkpay(&pkt, pkt.ip + 1);\n    rx_ip(ifp, &pkt);\n  } else {\n    MG_DEBUG((\"  Unknown eth type %x\", mg_htons(pkt.eth->type)));\n  }\n}\n\n\n// target function\nstatic void rx_icmp(struct mip_if *ifp, struct pkt *pkt) {\n  // MG_DEBUG((\"ICMP %d\", (int) len));\n  if (pkt->icmp->type == 8 && pkt->ip != NULL && pkt->ip->dst == ifp->ip) {\n    struct ip *ip = tx_ip(ifp, 1, ifp->ip, pkt->ip->src,\n                          sizeof(struct icmp) + pkt->pay.len);\n    struct icmp *icmp = (struct icmp *) (ip + 1);\n    size_t len = PDIFF(ifp->tx.buf, icmp + 1), left = ifp->tx.len - len;\n    if (left > pkt->pay.len) left = pkt->pay.len;  // Don't overflow TX\n    memset(icmp, 0, sizeof(*icmp));                // Set csum to 0\n    memcpy(icmp + 1, pkt->pay.buf, left);          // Copy RX payload to TX\n    icmp->csum = ipcsum(icmp, sizeof(*icmp) + pkt->pay.len);\n    ifp->driver->tx(ifp->tx.buf, len + left, ifp->driver_data);\n  }\n}\nint mg_base64_decode(const char *src, int n, char *dst) {\n  const char *end = src + n;\n  int len = 0;\n  while (src + 3 < end) {\n    int a = mg_b64rev(src[0]), b = mg_b64rev(src[1]), c = mg_b64rev(src[2]),\n        d = mg_b64rev(src[3]);\n    if (a == 64 || a < 0 || b == 64 || b < 0 || c < 0 || d < 0) return 0;\n    dst[len++] = (char) ((a << 2) | (b >> 4));\n    if (src[2] != '=') {\n      dst[len++] = (char) ((b << 4) | (c >> 2));\n      if (src[3] != '=') dst[len++] = (char) ((c << 6) | d);\n    }\n    src += 4;\n  }\n  dst[len] = '\\0';\n  return len;\n}\nint mg_http_parse(const char *s, size_t len, struct mg_http_message *hm) {\n  int is_response, req_len = mg_http_get_request_len((unsigned char *) s, len);\n  const char *end = s + req_len, *qs;\n  struct mg_str *cl;\n\n  memset(hm, 0, sizeof(*hm));\n  if (req_len <= 0) return req_len;\n\n  hm->message.ptr = hm->head.ptr = s;\n  hm->body.ptr = end;\n  hm->head.len = (size_t) req_len;\n  hm->chunk.ptr = end;\n  hm->message.len = hm->body.len = (size_t) ~0;  // Set body length to infinite\n\n  // Parse request line\n  s = skip(s, end, \" \", &hm->method);\n  s = skip(s, end, \" \", &hm->uri);\n  s = skip(s, end, \"\\r\\n\", &hm->proto);\n\n  // Sanity check. Allow protocol/reason to be empty\n  if (hm->method.len == 0 || hm->uri.len == 0) return -1;\n\n  // If URI contains '?' character, setup query string\n  if ((qs = (const char *) memchr(hm->uri.ptr, '?', hm->uri.len)) != NULL) {\n    hm->query.ptr = qs + 1;\n    hm->query.len = (size_t) (&hm->uri.ptr[hm->uri.len] - (qs + 1));\n    hm->uri.len = (size_t) (qs - hm->uri.ptr);\n  }\n\n  mg_http_parse_headers(s, end, hm->headers,\n                        sizeof(hm->headers) / sizeof(hm->headers[0]));\n  if ((cl = mg_http_get_header(hm, \"Content-Length\")) != NULL) {\n    hm->body.len = (size_t) mg_to64(*cl);\n    hm->message.len = (size_t) req_len + hm->body.len;\n  }\n\n  // mg_http_parse() is used to parse both HTTP requests and HTTP\n  // responses. If HTTP response does not have Content-Length set, then\n  // body is read until socket is closed, i.e. body.len is infinite (~0).\n  //\n  // For HTTP requests though, according to\n  // http://tools.ietf.org/html/rfc7231#section-8.1.3,\n  // only POST and PUT methods have defined body semantics.\n  // Therefore, if Content-Length is not specified and methods are\n  // not one of PUT or POST, set body length to 0.\n  //\n  // So, if it is HTTP request, and Content-Length is not set,\n  // and method is not (PUT or POST) then reset body length to zero.\n  is_response = mg_ncasecmp(hm->method.ptr, \"HTTP/\", 5) == 0;\n  if (hm->body.len == (size_t) ~0 && !is_response &&\n      mg_vcasecmp(&hm->method, \"PUT\") != 0 &&\n      mg_vcasecmp(&hm->method, \"POST\") != 0) {\n    hm->body.len = 0;\n    hm->message.len = (size_t) req_len;\n  }\n\n  // The 204 (No content) responses also have 0 body length\n  if (hm->body.len == (size_t) ~0 && is_response &&\n      mg_vcasecmp(&hm->uri, \"204\") == 0) {\n    hm->body.len = 0;\n    hm->message.len = (size_t) req_len;\n  }\n\n  return req_len;\n}\nstatic void printdirentry(const char *name, void *userdata) {\n  struct printdirentrydata *d = (struct printdirentrydata *) userdata;\n  struct mg_fs *fs = d->opts->fs == NULL ? &mg_fs_posix : d->opts->fs;\n  size_t size = 0;\n  time_t t = 0;\n  char path[MG_PATH_MAX], sz[40], mod[40];\n  int flags, n = 0;\n\n  // MG_DEBUG((\"[%s] [%s]\", d->dir, name));\n  if (mg_snprintf(path, sizeof(path), \"%s%c%s\", d->dir, '/', name) >\n      sizeof(path)) {\n    MG_ERROR((\"%s truncated\", name));\n  } else if ((flags = fs->st(path, &size, &t)) == 0) {\n    MG_ERROR((\"%lu stat(%s): %d\", d->c->id, path, errno));\n  } else {\n    const char *slash = flags & MG_FS_DIR ? \"/\" : \"\";\n    if (flags & MG_FS_DIR) {\n      mg_snprintf(sz, sizeof(sz), \"%s\", \"[DIR]\");\n    } else {\n      mg_snprintf(sz, sizeof(sz), \"%lld\", (uint64_t) size);\n    }\n#if defined(MG_HTTP_DIRLIST_TIME)\n    char time_str[30];\n    struct tm * time_info = localtime(&t);\n    strftime(time_str, sizeof time_str, \"%Y/%m/%d %H:%M:%S\", time_info);\n    mg_snprintf(mod, sizeof(mod), \"%s\", time_str);\n#elif defined(MG_HTTP_DIRLIST_TIME_UTC)\n    char time_str[30];\n    struct tm * time_info = gmtime(&t);\n    strftime(time_str, sizeof time_str, \"%Y/%m/%d %H:%M:%S\", time_info);\n    mg_snprintf(mod, sizeof(mod), \"%s\", time_str);\n#else\n    mg_snprintf(mod, sizeof(mod), \"%ld\", (unsigned long) t);\n#endif\n    n = (int) mg_url_encode(name, strlen(name), path, sizeof(path));\n    mg_printf(d->c,\n              \"  <tr><td><a href=\\\"%.*s%s\\\">%s%s</a></td>\"\n              \"<td name=%lu>%s</td><td name=%lld>%s</td></tr>\\n\",\n              n, path, slash, name, slash, (unsigned long) t, mod,\n              flags & MG_FS_DIR ? (int64_t) -1 : (int64_t) size, sz);\n  }\n}\nstatic void rx_icmp(struct mip_if *ifp, struct pkt *pkt) {\n  // MG_DEBUG((\"ICMP %d\", (int) len));\n  if (pkt->icmp->type == 8 && pkt->ip != NULL && pkt->ip->dst == ifp->ip) {\n    struct ip *ip = tx_ip(ifp, 1, ifp->ip, pkt->ip->src,\n                          sizeof(struct icmp) + pkt->pay.len);\n    struct icmp *icmp = (struct icmp *) (ip + 1);\n    size_t len = PDIFF(ifp->tx.buf, icmp + 1), left = ifp->tx.len - len;\n    if (left > pkt->pay.len) left = pkt->pay.len;\n    memset(icmp, 0, sizeof(*icmp));  // Important - set csum to 0\n    memcpy(icmp + 1, pkt->pay.buf, left);\n    icmp->csum = ipcsum(icmp, sizeof(*icmp) + pkt->pay.len);\n    ifp->driver->tx(ifp->tx.buf, len + left, ifp->driver_data);\n  }\n}\nint mg_base64_decode(const char *src, int n, char *dst) {\n  const char *end = src + n;\n  int len = 0;\n  while (src + 3 < end) {\n    int a = mg_b64rev(src[0]), b = mg_b64rev(src[1]), c = mg_b64rev(src[2]),\n        d = mg_b64rev(src[3]);\n    if (a == 64 || a < 0 || b == 64 || b < 0 || c < 0 || d < 0) return 0;\n    dst[len++] = (char) ((a << 2) | (b >> 4));\n    if (src[2] != '=') {\n      dst[len++] = (char) ((b << 4) | (c >> 2));\n      if (src[3] != '=') dst[len++] = (char) ((c << 6) | d);\n    }\n    src += 4;\n  }\n  dst[len] = '\\0';\n  return len;\n}\nint mg_http_parse(const char *s, size_t len, struct mg_http_message *hm) {\n  int is_response, req_len = mg_http_get_request_len((unsigned char *) s, len);\n  const char *end = s + req_len, *qs;\n  struct mg_str *cl;\n\n  memset(hm, 0, sizeof(*hm));\n  if (req_len <= 0) return req_len;\n\n  hm->message.ptr = hm->head.ptr = s;\n  hm->body.ptr = end;\n  hm->head.len = (size_t) req_len;\n  hm->chunk.ptr = end;\n  hm->message.len = hm->body.len = (size_t) ~0;  // Set body length to infinite\n\n  // Parse request line\n  s = skip(s, end, \" \", &hm->method);\n  s = skip(s, end, \" \", &hm->uri);\n  s = skip(s, end, \"\\r\\n\", &hm->proto);\n\n  // Sanity check. Allow protocol/reason to be empty\n  if (hm->method.len == 0 || hm->uri.len == 0) return -1;\n\n  // If URI contains '?' character, setup query string\n  if ((qs = (const char *) memchr(hm->uri.ptr, '?', hm->uri.len)) != NULL) {\n    hm->query.ptr = qs + 1;\n    hm->query.len = (size_t) (&hm->uri.ptr[hm->uri.len] - (qs + 1));\n    hm->uri.len = (size_t) (qs - hm->uri.ptr);\n  }\n\n  mg_http_parse_headers(s, end, hm->headers,\n                        sizeof(hm->headers) / sizeof(hm->headers[0]));\n  if ((cl = mg_http_get_header(hm, \"Content-Length\")) != NULL) {\n    hm->body.len = (size_t) mg_to64(*cl);\n    hm->message.len = (size_t) req_len + hm->body.len;\n  }\n\n  // mg_http_parse() is used to parse both HTTP requests and HTTP\n  // responses. If HTTP response does not have Content-Length set, then\n  // body is read until socket is closed, i.e. body.len is infinite (~0).\n  //\n  // For HTTP requests though, according to\n  // http://tools.ietf.org/html/rfc7231#section-8.1.3,\n  // only POST and PUT methods have defined body semantics.\n  // Therefore, if Content-Length is not specified and methods are\n  // not one of PUT or POST, set body length to 0.\n  //\n  // So, if it is HTTP request, and Content-Length is not set,\n  // and method is not (PUT or POST) then reset body length to zero.\n  is_response = mg_ncasecmp(hm->method.ptr, \"HTTP/\", 5) == 0;\n  if (hm->body.len == (size_t) ~0 && !is_response &&\n      mg_vcasecmp(&hm->method, \"PUT\") != 0 &&\n      mg_vcasecmp(&hm->method, \"POST\") != 0) {\n    hm->body.len = 0;\n    hm->message.len = (size_t) req_len;\n  }\n\n  // The 204 (No content) responses also have 0 body length\n  if (hm->body.len == (size_t) ~0 && is_response &&\n      mg_vcasecmp(&hm->uri, \"204\") == 0) {\n    hm->body.len = 0;\n    hm->message.len = (size_t) req_len;\n  }\n\n  return req_len;\n}\nstatic void printdirentry(const char *name, void *userdata) {\n  struct printdirentrydata *d = (struct printdirentrydata *) userdata;\n  struct mg_fs *fs = d->opts->fs == NULL ? &mg_fs_posix : d->opts->fs;\n  size_t size = 0;\n  time_t t = 0;\n  char path[MG_PATH_MAX], sz[40], mod[40];\n  int flags, n = 0;\n\n  // MG_DEBUG((\"[%s] [%s]\", d->dir, name));\n  if (mg_snprintf(path, sizeof(path), \"%s%c%s\", d->dir, '/', name) >\n      sizeof(path)) {\n    MG_ERROR((\"%s truncated\", name));\n  } else if ((flags = fs->st(path, &size, &t)) == 0) {\n    MG_ERROR((\"%lu stat(%s): %d\", d->c->id, path, errno));\n  } else {\n    const char *slash = flags & MG_FS_DIR ? \"/\" : \"\";\n    if (flags & MG_FS_DIR) {\n      mg_snprintf(sz, sizeof(sz), \"%s\", \"[DIR]\");\n    } else {\n      mg_snprintf(sz, sizeof(sz), \"%lld\", (uint64_t) size);\n    }\n#if defined(MG_HTTP_DIRLIST_TIME)\n    char time_str[30];\n    struct tm * time_info = localtime(&t);\n    strftime(time_str, sizeof time_str, \"%Y/%m/%d %H:%M:%S\", time_info);\n    mg_snprintf(mod, sizeof(mod), \"%s\", time_str);\n#elif defined(MG_HTTP_DIRLIST_TIME_UTC)\n    char time_str[30];\n    struct tm * time_info = gmtime(&t);\n    strftime(time_str, sizeof time_str, \"%Y/%m/%d %H:%M:%S\", time_info);\n    mg_snprintf(mod, sizeof(mod), \"%s\", time_str);\n#else\n    mg_snprintf(mod, sizeof(mod), \"%ld\", (unsigned long) t);\n#endif\n    n = (int) mg_url_encode(name, strlen(name), path, sizeof(path));\n    mg_printf(d->c,\n              \"  <tr><td><a href=\\\"%.*s%s\\\">%s%s</a></td>\"\n              \"<td name=%lu>%s</td><td name=%lld>%s</td></tr>\\n\",\n              n, path, slash, name, slash, (unsigned long) t, mod,\n              flags & MG_FS_DIR ? (int64_t) -1 : (int64_t) size, sz);\n  }\n}\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n  mg_log_set(MG_LL_NONE);\n\n  struct mg_dns_message dm;\n  mg_dns_parse(data, size, &dm);\n  mg_dns_parse(NULL, 0, &dm);\n\n  struct mg_http_message hm;\n  mg_http_parse((const char *) data, size, &hm);\n  mg_http_parse(NULL, 0, &hm);\n\n  struct mg_str body = mg_str_n((const char *) data, size);\n  char tmp[256];\n  mg_http_get_var(&body, \"key\", tmp, sizeof(tmp));\n  mg_http_get_var(&body, \"key\", NULL, 0);\n  mg_url_decode((char *) data, size, tmp, sizeof(tmp), 1);\n  mg_url_decode((char *) data, size, tmp, 1, 1);\n  mg_url_decode(NULL, 0, tmp, 1, 1);\n\n  struct mg_mqtt_message mm;\n  mg_mqtt_parse(data, size, 0, &mm);\n  mg_mqtt_parse(NULL, 0, 0, &mm);\n  mg_mqtt_parse(data, size, 5, &mm);\n  mg_mqtt_parse(NULL, 0, 5, &mm);\n\n  mg_sntp_parse(data, size);\n  mg_sntp_parse(NULL, 0);\n\n  char buf[size * 4 / 3 + 5];  // At least 4 chars and nul termination\n  mg_base64_decode((char *) data, (int) size, buf);\n  mg_base64_decode(NULL, 0, buf);\n  mg_base64_encode(data, (int) size, buf);\n  mg_base64_encode(NULL, 0, buf);\n\n  mg_globmatch((char *) data, size, (char *) data, size);\n\n  struct mg_str k, v, s = mg_str_n((char *) data, size);\n  while (mg_commalist(&s, &k, &v)) k.len = v.len = 0;\n\n  int n;\n  mg_json_get(mg_str_n((char *) data, size), \"$\", &n);\n  mg_json_get(mg_str_n((char *) data, size), \"$.a.b\", &n);\n  mg_json_get(mg_str_n((char *) data, size), \"$[0]\", &n);\n\n  if (size > 0) {\n    struct mip_cfg cfg = {};\n    size_t pktlen = 1540;\n    char t[sizeof(struct mip_if) + pktlen * 2 + 0 /* qlen */];\n    struct mip_if *ifp = (struct mip_if *) t;\n    struct mg_mgr mgr;\n    mg_mgr_init(&mgr);\n    if_init(ifp, &mgr, &cfg, &mip_driver_mock, NULL, pktlen, 0);\n\n    // Make a copy of the random data, in order to modify it\n    uint8_t pkt[size];\n    struct eth *eth = (struct eth *) pkt;\n    memcpy(pkt, data, size);\n    if (size > sizeof(*eth)) {\n      static size_t i;\n      uint16_t eth_types[] = {0x800, 0x800, 0x806, 0x86dd};\n      memcpy(eth->dst, ifp->mac, 6);  // Set valid destination MAC\n      eth->type = mg_htons(eth_types[i++]);\n      if (i >= sizeof(eth_types) / sizeof(eth_types[0])) i = 0;\n    }\n\n    mip_rx(ifp, (void *) pkt, size);\n    mgr.priv = NULL;  // Don't let Mongoose free() ifp\n    mg_mgr_free(&mgr);\n  }\n\n  return 0;\n}\n",
    "target": 1,
    "idx": 1051757,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "// context\nuint16_t Message::Read(uint16_t aOffset, uint16_t aLength, void *aBuf) const\n{\n    Buffer * curBuffer;\n    uint16_t bytesCopied = 0;\n    uint16_t bytesToCopy;\n\n    if (aOffset >= GetLength())\n    {\n        ExitNow();\n    }\n\n    if (aOffset + aLength >= GetLength())\n    {\n        aLength = GetLength() - aOffset;\n    }\n\n    aOffset += GetReserved();\n\n    // special case first buffer\n    if (aOffset < kHeadBufferDataSize)\n    {\n        bytesToCopy = kHeadBufferDataSize - aOffset;\n\n        if (bytesToCopy > aLength)\n        {\n            bytesToCopy = aLength;\n        }\n\n        memcpy(aBuf, GetFirstData() + aOffset, bytesToCopy);\n\n        aLength -= bytesToCopy;\n        bytesCopied += bytesToCopy;\n        aBuf = static_cast<uint8_t *>(aBuf) + bytesToCopy;\n\n        aOffset = 0;\n    }\n    else\n    {\n        aOffset -= kHeadBufferDataSize;\n    }\n\n    // advance to offset\n    curBuffer = GetNextBuffer();\n\n    while (aOffset >= kBufferDataSize)\n    {\n        assert(curBuffer != NULL);\n\n        curBuffer = curBuffer->GetNextBuffer();\n        aOffset -= kBufferDataSize;\n    }\n\n    // begin copy\n    while (aLength > 0)\n    {\n        assert(curBuffer != NULL);\n\n        bytesToCopy = kBufferDataSize - aOffset;\n\n        if (bytesToCopy > aLength)\n        {\n            bytesToCopy = aLength;\n        }\n\n        memcpy(aBuf, curBuffer->GetData() + aOffset, bytesToCopy);\n\n        aLength -= bytesToCopy;\n        bytesCopied += bytesToCopy;\n        aBuf = static_cast<uint8_t *>(aBuf) + bytesToCopy;\n\n        curBuffer = curBuffer->GetNextBuffer();\n        aOffset   = 0;\n    }\n\nexit:\n    return bytesCopied;\n}\n\nvoid Leader::HandleCommissioningGet(Coap::Message &aMessage, const Ip6::MessageInfo &aMessageInfo)\n{\n    uint16_t length = 0;\n    uint16_t offset;\n\n    SuccessOrExit(Tlv::GetValueOffset(aMessage, MeshCoP::Tlv::kGet, offset, length));\n    aMessage.SetOffset(offset);\n\nexit:\n    SendCommissioningGetResponse(aMessage, length, aMessageInfo);\n}\n\nvoid CoapBase::ProcessReceivedRequest(Message &aMessage, const Ip6::MessageInfo &aMessageInfo)\n{\n    char     uriPath[Resource::kMaxReceivedUriPath];\n    char *   curUriPath     = uriPath;\n    Message *cachedResponse = NULL;\n    otError  error          = OT_ERROR_NOT_FOUND;\n\n    if (mInterceptor != NULL)\n    {\n        SuccessOrExit(error = mInterceptor(aMessage, aMessageInfo, mContext));\n    }\n\n    switch (mResponsesQueue.GetMatchedResponseCopy(aMessage, aMessageInfo, &cachedResponse))\n    {\n    case OT_ERROR_NONE:\n        cachedResponse->Finish();\n        error = Send(*cachedResponse, aMessageInfo);\n        // fall through\n        ;\n\n    case OT_ERROR_NO_BUFS:\n        ExitNow();\n\n    case OT_ERROR_NOT_FOUND:\n    default:\n        break;\n    }\n\n    for (const otCoapOption *option = aMessage.GetFirstOption(); option != NULL; option = aMessage.GetNextOption())\n    {\n        switch (option->mNumber)\n        {\n        case OT_COAP_OPTION_URI_PATH:\n            if (curUriPath != uriPath)\n            {\n                *curUriPath++ = '/';\n            }\n\n            VerifyOrExit(option->mLength < sizeof(uriPath) - static_cast<size_t>(curUriPath + 1 - uriPath));\n\n            aMessage.GetOptionValue(curUriPath);\n            curUriPath += option->mLength;\n            break;\n\n        default:\n            break;\n        }\n    }\n\n    curUriPath[0] = '\\0';\n\n    for (const Resource *resource = mResources; resource; resource = resource->GetNext())\n    {\n        if (strcmp(resource->mUriPath, uriPath) == 0)\n        {\n            resource->HandleRequest(aMessage, aMessageInfo);\n            error = OT_ERROR_NONE;\n            ExitNow();\n        }\n    }\n\n    if (mDefaultHandler)\n    {\n        mDefaultHandler(mDefaultHandlerContext, &aMessage, &aMessageInfo);\n        error = OT_ERROR_NONE;\n    }\n\nexit:\n\n    if (error != OT_ERROR_NONE)\n    {\n        otLogInfoCoapErr(error, \"Failed to process request\");\n\n        if (error == OT_ERROR_NOT_FOUND && !aMessageInfo.GetSockAddr().IsMulticast())\n        {\n            SendNotFound(aMessage, aMessageInfo);\n        }\n\n        if (cachedResponse != NULL)\n        {\n            cachedResponse->Free();\n        }\n    }\n}\n\notError Udp::HandleMessage(Message &aMessage, MessageInfo &aMessageInfo)\n{\n    otError   error = OT_ERROR_NONE;\n    UdpHeader udpHeader;\n    uint16_t  payloadLength;\n    uint16_t  checksum;\n\n    payloadLength = aMessage.GetLength() - aMessage.GetOffset();\n\n    // check length\n    VerifyOrExit(payloadLength >= sizeof(UdpHeader), error = OT_ERROR_PARSE);\n\n    // verify checksum\n    checksum = Ip6::ComputePseudoheaderChecksum(aMessageInfo.GetPeerAddr(), aMessageInfo.GetSockAddr(), payloadLength,\n                                                kProtoUdp);\n    checksum = aMessage.UpdateChecksum(checksum, aMessage.GetOffset(), payloadLength);\n\n#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n    VerifyOrExit(checksum == 0xffff, error = OT_ERROR_DROP);\n#endif\n\n    VerifyOrExit(aMessage.Read(aMessage.GetOffset(), sizeof(udpHeader), &udpHeader) == sizeof(udpHeader),\n                 error = OT_ERROR_PARSE);\n    aMessage.MoveOffset(sizeof(udpHeader));\n    aMessageInfo.mPeerPort = udpHeader.GetSourcePort();\n    aMessageInfo.mSockPort = udpHeader.GetDestinationPort();\n\n#if OPENTHREAD_CONFIG_PLATFORM_UDP_ENABLE\n    VerifyOrExit(IsMle(GetInstance(), aMessageInfo.mSockPort));\n#endif\n\n    for (UdpReceiver *receiver = mReceivers; receiver; receiver = receiver->GetNext())\n    {\n        VerifyOrExit(!receiver->HandleMessage(aMessage, aMessageInfo));\n    }\n\n    HandlePayload(aMessage, aMessageInfo);\n\nexit:\n    return error;\n}\n\notError Ip6::HandleDatagram(Message &aMessage, Netif *aNetif, const void *aLinkMessageInfo, bool aFromNcpHost)\n{\n    otError     error = OT_ERROR_NONE;\n    MessageInfo messageInfo;\n    Header      header;\n    bool        receive              = false;\n    bool        forward              = false;\n    bool        tunnel               = false;\n    bool        multicastPromiscuous = false;\n    uint8_t     nextHeader;\n    uint8_t     hopLimit;\n\n    SuccessOrExit(error = header.Init(aMessage));\n\n    messageInfo.SetPeerAddr(header.GetSource());\n    messageInfo.SetSockAddr(header.GetDestination());\n    messageInfo.SetHopLimit(header.GetHopLimit());\n    messageInfo.SetLinkInfo(aLinkMessageInfo);\n\n    // determine destination of packet\n    if (header.GetDestination().IsMulticast())\n    {\n        if (aNetif != NULL)\n        {\n            if (aNetif->IsMulticastSubscribed(header.GetDestination()))\n            {\n                receive = true;\n            }\n            else if (aNetif->IsMulticastPromiscuousEnabled())\n            {\n                multicastPromiscuous = true;\n            }\n\n            if (header.GetDestination().IsMulticastLargerThanRealmLocal() &&\n                Get<Mle::MleRouter>().HasSleepyChildrenSubscribed(header.GetDestination()))\n            {\n                forward = true;\n            }\n        }\n        else\n        {\n            forward = true;\n        }\n    }\n    else\n    {\n        if (Get<ThreadNetif>().IsUnicastAddress(header.GetDestination()))\n        {\n            receive = true;\n        }\n        else if (!header.GetDestination().IsLinkLocal())\n        {\n            forward = true;\n        }\n        else if (aNetif == NULL)\n        {\n            forward = true;\n        }\n    }\n\n    aMessage.SetOffset(sizeof(header));\n\n    // process IPv6 Extension Headers\n    nextHeader = static_cast<uint8_t>(header.GetNextHeader());\n    SuccessOrExit(error = HandleExtensionHeaders(aMessage, aNetif, messageInfo, header, nextHeader, forward,\n                                                 aFromNcpHost, receive));\n\n    // process IPv6 Payload\n    if (receive)\n    {\n        if (nextHeader == kProtoIp6)\n        {\n            // Remove encapsulating header.\n            aMessage.RemoveHeader(aMessage.GetOffset());\n\n            HandleDatagram(aMessage, aNetif, aLinkMessageInfo, aFromNcpHost);\n            ExitNow(tunnel = true);\n        }\n\n        ProcessReceiveCallback(aMessage, messageInfo, nextHeader, aFromNcpHost);\n\n        SuccessOrExit(error = HandlePayload(aMessage, messageInfo, nextHeader));\n    }\n    else if (multicastPromiscuous)\n    {\n        ProcessReceiveCallback(aMessage, messageInfo, nextHeader, aFromNcpHost);\n    }\n\n    if (forward)\n    {\n        if (!ShouldForwardToThread(messageInfo))\n        {\n            // try passing to host\n            SuccessOrExit(error = ProcessReceiveCallback(aMessage, messageInfo, nextHeader, aFromNcpHost));\n\n            // the caller transfers custody in the success case, so free the aMessage here\n            aMessage.Free();\n\n            ExitNow();\n        }\n\n        if (aNetif != NULL)\n        {\n            VerifyOrExit(mForwardingEnabled, forward = false);\n            header.SetHopLimit(header.GetHopLimit() - 1);\n        }\n\n        if (header.GetHopLimit() == 0)\n        {\n            // send time exceeded\n            ExitNow(error = OT_ERROR_DROP);\n        }\n        else\n        {\n            hopLimit = header.GetHopLimit();\n            aMessage.Write(Header::GetHopLimitOffset(), Header::GetHopLimitSize(), &hopLimit);\n\n            // submit aMessage to interface\n            SuccessOrExit(error = Get<ThreadNetif>().SendMessage(aMessage));\n        }\n    }\n\nexit:\n\n    if (!tunnel && (error != OT_ERROR_NONE || !forward))\n    {\n        aMessage.Free();\n    }\n\n    return error;\n}\n\notError Ip6::SendRaw(Message &aMessage)\n{\n    otError     error = OT_ERROR_NONE;\n    Header      header;\n    MessageInfo messageInfo;\n    bool        freed = false;\n\n    SuccessOrExit(error = header.Init(aMessage));\n\n    messageInfo.SetPeerAddr(header.GetSource());\n    messageInfo.SetSockAddr(header.GetDestination());\n    messageInfo.SetHopLimit(header.GetHopLimit());\n    messageInfo.SetLinkInfo(NULL);\n\n    if (header.GetDestination().IsMulticast())\n    {\n        SuccessOrExit(error = InsertMplOption(aMessage, header, messageInfo));\n    }\n\n    error = HandleDatagram(aMessage, NULL, NULL, true);\n    freed = true;\n\nexit:\n\n    if (!freed)\n    {\n        aMessage.Free();\n    }\n\n    return error;\n}\n\n\n// target function\nvoid Leader::HandleCommissioningGet(Coap::Message &aMessage, const Ip6::MessageInfo &aMessageInfo)\n{\n    MeshCoP::Tlv tlv;\n    uint16_t     offset = aMessage.GetOffset();\n    uint8_t      tlvs[NetworkData::kMaxSize];\n    uint8_t      length = 0;\n\n    while (offset < aMessage.GetLength())\n    {\n        aMessage.Read(offset, sizeof(tlv), &tlv);\n\n        if (tlv.GetType() == MeshCoP::Tlv::kGet)\n        {\n            length = tlv.GetLength();\n            aMessage.Read(offset + sizeof(MeshCoP::Tlv), length, tlvs);\n            break;\n        }\n\n        offset += sizeof(tlv) + tlv.GetLength();\n    }\n\n    SendCommissioningGetResponse(aMessage, aMessageInfo, tlvs, length);\n}\nvoid Leader::SendCommissioningGetResponse(const Coap::Message &   aRequest,\n                                          const Ip6::MessageInfo &aMessageInfo,\n                                          const uint8_t *         aTlvs,\n                                          uint8_t                 aLength)\n{\n    otError        error = OT_ERROR_NONE;\n    Coap::Message *message;\n    uint8_t        index;\n    uint8_t *      data   = NULL;\n    uint8_t        length = 0;\n\n    VerifyOrExit((message = MeshCoP::NewMeshCoPMessage(Get<Coap::Coap>())) != NULL, error = OT_ERROR_NO_BUFS);\n\n    SuccessOrExit(error = message->SetDefaultResponseHeader(aRequest));\n    SuccessOrExit(error = message->SetPayloadMarker());\n\n    for (NetworkDataTlv *cur                                            = reinterpret_cast<NetworkDataTlv *>(mTlvs);\n         cur < reinterpret_cast<NetworkDataTlv *>(mTlvs + mLength); cur = cur->GetNext())\n    {\n        if (cur->GetType() == NetworkDataTlv::kTypeCommissioningData)\n        {\n            data   = cur->GetValue();\n            length = cur->GetLength();\n            break;\n        }\n    }\n\n    VerifyOrExit(data && length, error = OT_ERROR_DROP);\n\n    if (aLength == 0)\n    {\n        SuccessOrExit(error = message->Append(data, length));\n    }\n    else\n    {\n        for (index = 0; index < aLength; index++)\n        {\n            for (MeshCoP::Tlv *cur                                          = reinterpret_cast<MeshCoP::Tlv *>(data);\n                 cur < reinterpret_cast<MeshCoP::Tlv *>(data + length); cur = cur->GetNext())\n            {\n                if (cur->GetType() == aTlvs[index])\n                {\n                    SuccessOrExit(error = message->AppendTlv(*cur));\n                    break;\n                }\n            }\n        }\n    }\n\n    if (message->GetLength() == message->GetOffset())\n    {\n        // no payload, remove coap payload marker\n        message->SetLength(message->GetLength() - 1);\n    }\n\n    SuccessOrExit(error = Get<Coap::Coap>().SendMessage(*message, aMessageInfo));\n\n    otLogInfoMeshCoP(\"sent commissioning dataset get response\");\n\nexit:\n\n    if (error != OT_ERROR_NONE && message != NULL)\n    {\n        message->Free();\n    }\n}\n",
    "target": 1,
    "idx": 1017330,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "// context\nKGzipFilter::Result KGzipFilter::uncompress_noop()\n{\n    // I'm not sure we really need support for that (uncompressed streams),\n    // but why not, it can't hurt to have it. One case I can think of is someone\n    // naming a tar file \"blah.tar.gz\" :-)\n    if (d->zStream.avail_in > 0) {\n        int n = (d->zStream.avail_in < d->zStream.avail_out) ? d->zStream.avail_in : d->zStream.avail_out;\n        memcpy(d->zStream.next_out, d->zStream.next_in, n);\n        d->zStream.avail_out -= n;\n        d->zStream.next_in += n;\n        d->zStream.avail_in -= n;\n        return KFilterBase::Ok;\n    } else {\n        return KFilterBase::End;\n    }\n}\n\nqint64 KCompressionDevice::readData(char *data, qint64 maxlen)\n{\n    Q_ASSERT(d->filter->mode() == QIODevice::ReadOnly);\n    //qCDebug(KArchiveLog) << \"maxlen=\" << maxlen;\n    KFilterBase *filter = d->filter;\n\n    uint dataReceived = 0;\n\n    // We came to the end of the stream\n    if (d->result == KFilterBase::End) {\n        return dataReceived;\n    }\n\n    // If we had an error, return -1.\n    if (d->result != KFilterBase::Ok) {\n        return -1;\n    }\n\n    qint64 availOut = maxlen;\n    filter->setOutBuffer(data, maxlen);\n\n    while (dataReceived < maxlen) {\n        if (filter->inBufferEmpty()) {\n            // Not sure about the best size to set there.\n            // For sure, it should be bigger than the header size (see comment in readHeader)\n            d->buffer.resize(BUFFER_SIZE);\n            // Request data from underlying device\n            int size = filter->device()->read(d->buffer.data(),\n                                              d->buffer.size());\n            //qCDebug(KArchiveLog) << \"got\" << size << \"bytes from device\";\n            if (size) {\n                filter->setInBuffer(d->buffer.data(), size);\n            } else {\n                // Not enough data available in underlying device for now\n                break;\n            }\n        }\n        if (d->bNeedHeader) {\n            (void) filter->readHeader();\n            d->bNeedHeader = false;\n        }\n\n        d->result = filter->uncompress();\n\n        if (d->result == KFilterBase::Error) {\n            //qCWarning(KArchiveLog) << \"KCompressionDevice: Error when uncompressing data\";\n            break;\n        }\n\n        // We got that much data since the last time we went here\n        uint outReceived = availOut - filter->outBufferAvailable();\n        //qCDebug(KArchiveLog) << \"avail_out = \" << filter->outBufferAvailable() << \" result=\" << d->result << \" outReceived=\" << outReceived;\n        if (availOut < uint(filter->outBufferAvailable())) {\n            //qCWarning(KArchiveLog) << \" last availOut \" << availOut << \" smaller than new avail_out=\" << filter->outBufferAvailable() << \" !\";\n        }\n\n        dataReceived += outReceived;\n        data += outReceived;\n        availOut = maxlen - dataReceived;\n        if (d->result == KFilterBase::End) {\n            // We're actually at the end, no more data to check\n            if (filter->device()->atEnd()) {\n                break;\n            }\n\n            // Still not done, re-init and try again\n            filter->init(filter->mode());\n        }\n        filter->setOutBuffer(data, availOut);\n    }\n\n    d->deviceReadPos += dataReceived;\n    return dataReceived;\n}\n\nQByteArray QIODevice::read(qint64 maxSize)\n{\n    Q_D(QIODevice);\n    QByteArray result;\n\n#if defined QIODEVICE_DEBUG\n    printf(\"%p QIODevice::read(%lld), d->pos = %lld, d->buffer.size() = %lld\\n\",\n           this, maxSize, d->pos, d->buffer.size());\n#endif\n\n    // Try to prevent the data from being copied, if we have a chunk\n    // with the same size in the read buffer.\n    if (maxSize == d->buffer.nextDataBlockSize() && !d->transactionStarted\n        && (d->openMode & (QIODevice::ReadOnly | QIODevice::Text)) == QIODevice::ReadOnly) {\n        result = d->buffer.read();\n        if (!d->isSequential())\n            d->pos += maxSize;\n        if (d->buffer.isEmpty())\n            readData(nullptr, 0);\n        return result;\n    }\n\n    CHECK_MAXLEN(read, result);\n    CHECK_MAXBYTEARRAYSIZE(read);\n\n    result.resize(int(maxSize));\n    qint64 readBytes = read(result.data(), result.size());\n\n    if (readBytes <= 0)\n        result.clear();\n    else\n        result.resize(int(readBytes));\n\n    return result;\n}\n\nbool KCompressionDevice::seek(qint64 pos)\n{\n    if (d->deviceReadPos == pos) {\n        return QIODevice::seek(pos);\n    }\n\n    //qCDebug(KArchiveLog) << \"seek(\" << pos << \") called, current pos=\" << QIODevice::pos();\n\n    Q_ASSERT(d->filter->mode() == QIODevice::ReadOnly);\n\n    if (pos == 0) {\n        if (!QIODevice::seek(pos))\n            return false;\n\n        // We can forget about the cached data\n        d->bNeedHeader = !d->bSkipHeaders;\n        d->result = KFilterBase::Ok;\n        d->filter->setInBuffer(nullptr, 0);\n        d->filter->reset();\n        d->deviceReadPos = 0;\n        return d->filter->device()->reset();\n    }\n\n    qint64 bytesToRead;\n    if (d->deviceReadPos < pos) { // we can start from here\n        bytesToRead = pos - d->deviceReadPos;\n        // Since we're going to do a read() below\n        // we need to reset the internal QIODevice pos to the real position we are\n        // so that after read() we are indeed pointing to the pos seek\n        // asked us to be in\n        if (!QIODevice::seek(d->deviceReadPos)) {\n            return false;\n        }\n    } else {\n        // we have to start from 0 ! Ugly and slow, but better than the previous\n        // solution (KTarGz was allocating everything into memory)\n        if (!seek(0)) { // recursive\n            return false;\n        }\n        bytesToRead = pos;\n    }\n\n    //qCDebug(KArchiveLog) << \"reading \" << bytesToRead << \" dummy bytes\";\n    QByteArray dummy(qMin(bytesToRead, qint64(SEEK_BUFFER_SIZE)), 0);\n    while (bytesToRead > 0) {\n        const qint64 bytesToReadThisTime = qMin(bytesToRead, qint64(dummy.size()));\n        const bool result = (read(dummy.data(), bytesToReadThisTime) == bytesToReadThisTime);\n        if (!result) {\n            return false;\n        }\n        bytesToRead -= bytesToReadThisTime;\n    }\n    return true;\n}\n\nbool KTar::openArchive(QIODevice::OpenMode mode)\n{\n\n    if (!(mode & QIODevice::ReadOnly)) {\n        return true;\n    }\n\n    if (!d->fillTempFile(fileName())) {\n        return false;\n    }\n\n    // We'll use the permission and user/group of d->rootDir\n    // for any directory we emulate (see findOrCreate)\n    //struct stat buf;\n    //stat( fileName(), &buf );\n\n    d->dirList.clear();\n    QIODevice *dev = device();\n\n    if (!dev) {\n        setErrorString(tr(\"Could not get underlying device\"));\n        qCWarning(KArchiveLog) << \"Could not get underlying device\";\n        return false;\n    }\n\n    // read dir information\n    char buffer[0x200];\n    bool ende = false;\n    do {\n        QString name;\n        QString symlink;\n\n        // Read header\n        qint64 n = d->readHeader(buffer, name, symlink);\n        if (n < 0) {\n            setErrorString(tr(\"Could not read tar header\"));\n            return false;\n        }\n        if (n == 0x200) {\n            bool isdir = false;\n\n            if (name.isEmpty()) {\n                continue;\n            }\n            if (name.endsWith(QLatin1Char('/'))) {\n                isdir = true;\n                name.truncate(name.length() - 1);\n            }\n\n            QByteArray prefix = QByteArray(buffer + 0x159, 155);\n            if (prefix[0] != '\\0') {\n                name = (QString::fromLatin1(prefix.constData()) + QLatin1Char('/') +  name);\n            }\n\n            int pos = name.lastIndexOf(QLatin1Char('/'));\n            QString nm = (pos == -1) ? name : name.mid(pos + 1);\n\n            // read access\n            buffer[0x6b] = 0;\n            char *dummy;\n            const char *p = buffer + 0x64;\n            while (*p == ' ') {\n                ++p;\n            }\n            int access = strtol(p, &dummy, 8);\n\n            // read user and group\n            const int maxUserGroupLength = 32;\n            const char *userStart = buffer + 0x109;\n            const int userLen = qstrnlen(userStart, maxUserGroupLength);\n            const QString user = QString::fromLocal8Bit(userStart, userLen);\n            const char *groupStart = buffer + 0x129;\n            const int groupLen = qstrnlen(groupStart, maxUserGroupLength);\n            const QString group = QString::fromLocal8Bit(groupStart, groupLen);\n\n            // read time\n            buffer[0x93] = 0;\n            p = buffer + 0x88;\n            while (*p == ' ') {\n                ++p;\n            }\n            uint time = strtol(p, &dummy, 8);\n\n            // read type flag\n            char typeflag = buffer[0x9c];\n            // '0' for files, '1' hard link, '2' symlink, '5' for directory\n            // (and 'L' for longlink fileNames, 'K' for longlink symlink targets)\n            // 'D' for GNU tar extension DUMPDIR, 'x' for Extended header referring\n            // to the next file in the archive and 'g' for Global extended header\n\n            if (typeflag == '5') {\n                isdir = true;\n            }\n\n            bool isDumpDir = false;\n            if (typeflag == 'D') {\n                isdir = false;\n                isDumpDir = true;\n            }\n            //qCDebug(KArchiveLog) << nm << \"isdir=\" << isdir << \"pos=\" << dev->pos() << \"typeflag=\" << typeflag << \" islink=\" << ( typeflag == '1' || typeflag == '2' );\n\n            if (typeflag == 'x' || typeflag == 'g') { // pax extended header, or pax global extended header\n                // Skip it for now. TODO: implement reading of extended header, as per http://pubs.opengroup.org/onlinepubs/009695399/utilities/pax.html\n                (void)dev->read(buffer, 0x200);\n                continue;\n            }\n\n            if (isdir) {\n                access |= S_IFDIR;    // f*cking broken tar files\n            }\n\n            KArchiveEntry *e;\n            if (isdir) {\n                //qCDebug(KArchiveLog) << \"directory\" << nm;\n                e = new KArchiveDirectory(this, nm, access, KArchivePrivate::time_tToDateTime(time), user, group, symlink);\n            } else {\n                // read size\n                QByteArray sizeBuffer(buffer + 0x7c, 12);\n                qint64 size = sizeBuffer.trimmed().toLongLong(nullptr, 8 /*octal*/);\n                //qCDebug(KArchiveLog) << \"sizeBuffer='\" << sizeBuffer << \"' -> size=\" << size;\n\n                // for isDumpDir we will skip the additional info about that dirs contents\n                if (isDumpDir) {\n                    //qCDebug(KArchiveLog) << nm << \"isDumpDir\";\n                    e = new KArchiveDirectory(this, nm, access, KArchivePrivate::time_tToDateTime(time), user, group, symlink);\n                } else {\n\n                    // Let's hack around hard links. Our classes don't support that, so make them symlinks\n                    if (typeflag == '1') {\n                        //qCDebug(KArchiveLog) << \"Hard link, setting size to 0 instead of\" << size;\n                        size = 0; // no contents\n                    }\n\n                    //qCDebug(KArchiveLog) << \"file\" << nm << \"size=\" << size;\n                    e = new KArchiveFile(this, nm, access, KArchivePrivate::time_tToDateTime(time), user, group, symlink,\n                                         dev->pos(), size);\n                }\n\n                // Skip contents + align bytes\n                qint64 rest = size % 0x200;\n                qint64 skip = size + (rest ? 0x200 - rest : 0);\n                //qCDebug(KArchiveLog) << \"pos()=\" << dev->pos() << \"rest=\" << rest << \"skipping\" << skip;\n                if (! dev->seek(dev->pos() + skip)) {\n                    //qCWarning(KArchiveLog) << \"skipping\" << skip << \"failed\";\n                }\n            }\n\n            if (pos == -1) {\n                if (nm == QLatin1String(\".\")) { // special case\n                    Q_ASSERT(isdir);\n                    if (isdir) {\n                        setRootDir(static_cast<KArchiveDirectory *>(e));\n                    } else {\n                        delete e;\n                    }\n                } else {\n                    rootDir()->addEntry(e);\n                }\n            } else {\n                // In some tar files we can find dir/./file => call cleanPath\n                QString path = QDir::cleanPath(name.left(pos));\n                // Ensure container directory exists, create otherwise\n                KArchiveDirectory *d = findOrCreate(path);\n                if (d) {\n                    d->addEntry(e);\n                } else {\n                    delete e;\n                    return false;\n                }\n            }\n        } else {\n            //qCDebug(KArchiveLog) << \"Terminating. Read \" << n << \" bytes, first one is \" << buffer[0];\n            d->tarEnd = dev->pos() - n; // Remember end of archive\n            ende = true;\n        }\n    } while (!ende);\n    return true;\n}\n\nbool KArchive::open(QIODevice::OpenMode mode)\n{\n    Q_ASSERT(mode != QIODevice::NotOpen);\n\n    if (isOpen()) {\n        close();\n    }\n\n    if (!d->fileName.isEmpty()) {\n        Q_ASSERT(!d->dev);\n        if (!createDevice(mode)) {\n            return false;\n        }\n    }\n\n    if (!d->dev) {\n        setErrorString(tr(\"No filename or device was specified\"));\n        return false;\n    }\n\n    if (!d->dev->isOpen() && !d->dev->open(mode)) {\n        setErrorString(tr(\"Could not set device mode to %1\").arg(mode));\n        return false;\n    }\n\n    d->mode = mode;\n\n    Q_ASSERT(!d->rootDir);\n    d->rootDir = nullptr;\n\n    return openArchive(mode);\n}\n\n\n// target function\nvoid KCompressionDeviceTest::testSeekReadUncompressedBuffer()\n{\n    const int dataSize = BUFFER_SIZE + BUFFER_SIZE / 2;\n    QByteArray ba(dataSize, 0);\n\n    // all data is zero except after BUFFER_SIZE that it's 0 to 9\n    for (int i = 0; i < 10; ++i) {\n        ba[BUFFER_SIZE + i] = i;\n    }\n\n    QBuffer b;\n    b.setData(ba);\n    QVERIFY(b.open(QIODevice::ReadOnly));\n\n    KCompressionDevice kcd(&b, false, KCompressionDevice::GZip);\n    QVERIFY(kcd.open(QIODevice::ReadOnly));\n    QVERIFY(kcd.seek(BUFFER_SIZE));\n\n    // the 10 bytes after BUFFER_SIZE should be 0 to 9\n    const QByteArray kcdData = kcd.read(10);\n    QCOMPARE(kcdData.size(), 10);\n    for (int i = 0; i < kcdData.size(); ++i) {\n        QCOMPARE(kcdData[i], i);\n    }\n}\nbool KCompressionDevice::seek(qint64 pos)\n{\n    if (d->deviceReadPos == pos) {\n        return QIODevice::seek(pos);\n    }\n\n    //qCDebug(KArchiveLog) << \"seek(\" << pos << \") called, current pos=\" << QIODevice::pos();\n\n    Q_ASSERT(d->filter->mode() == QIODevice::ReadOnly);\n\n    if (pos == 0) {\n        if (!QIODevice::seek(pos))\n            return false;\n\n        // We can forget about the cached data\n        d->bNeedHeader = !d->bSkipHeaders;\n        d->result = KFilterBase::Ok;\n        d->filter->setInBuffer(nullptr, 0);\n        d->filter->reset();\n        d->deviceReadPos = 0;\n        return d->filter->device()->reset();\n    }\n\n    qint64 bytesToRead;\n    if (d->deviceReadPos < pos) { // we can start from here\n        bytesToRead = pos - d->deviceReadPos;\n        // Since we're going to do a read() below\n        // we need to reset the internal QIODevice pos to the real position we are\n        // so that after read() we are indeed pointing to the pos seek\n        // asked us to be in\n        if (!QIODevice::seek(d->deviceReadPos)) {\n            return false;\n        }\n    } else {\n        // we have to start from 0 ! Ugly and slow, but better than the previous\n        // solution (KTarGz was allocating everything into memory)\n        if (!seek(0)) { // recursive\n            return false;\n        }\n        bytesToRead = pos;\n    }\n\n    //qCDebug(KArchiveLog) << \"reading \" << bytesToRead << \" dummy bytes\";\n    QByteArray dummy(qMin(bytesToRead, qint64(3 * BUFFER_SIZE)), 0);\n    const bool result = (read(dummy.data(), bytesToRead) == bytesToRead);\n    return result;\n}\nbool KCompressionDevice::atEnd() const\n{\n    return (d->type == KCompressionDevice::None || d->result == KFilterBase::End)\n           && QIODevice::atEnd() // take QIODevice's internal buffer into account\n           && d->filter->device()->atEnd();\n}\n",
    "target": 1,
    "idx": 1014961,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nflb_sds_t flb_signv4_uri_normalize_path(char *uri, size_t len)\n{\n    char *p;\n    int end_slash = FLB_FALSE;\n    struct mk_list *tmp;\n    struct mk_list *prev;\n    struct mk_list *head;\n    struct mk_list *split;\n    struct flb_split_entry *entry;\n    flb_sds_t out;\n\n    out = flb_sds_create_len(uri, len+1);\n    if (!out) {\n        return NULL;\n    }\n    out[len] = '\\0';\n\n    if (uri[len - 1] == '/') {\n        end_slash = FLB_TRUE;\n    }\n\n    split = flb_utils_split(out, '/', -1);\n    if (!split) {\n        flb_sds_destroy(out);\n        return NULL;\n    }\n\n    p = out;\n    *p++ = '/';\n\n    mk_list_foreach_safe(head, tmp, split) {\n        entry = mk_list_entry(head, struct flb_split_entry, _head);\n        if (entry->len == 1 && *entry->value == '.') {\n            flb_utils_split_free_entry(entry);\n        }\n        else if (entry->len == 2 && memcmp(entry->value, \"..\", 2) == 0) {\n            prev = head->prev;\n            if (prev != split) {\n                entry = mk_list_entry(prev, struct flb_split_entry, _head);\n                flb_utils_split_free_entry(entry);\n            }\n            entry = mk_list_entry(head, struct flb_split_entry, _head);\n            flb_utils_split_free_entry(entry);\n        }\n    }\n\n    mk_list_foreach(head, split) {\n        entry = mk_list_entry(head, struct flb_split_entry, _head);\n        memcpy(p, entry->value, entry->len);\n        p += entry->len;\n\n        if (head->next != split) {\n            *p++ = '/';\n        }\n    }\n\n    len = (p - out);\n    if (end_slash == FLB_TRUE && out[len - 1] != '/') {\n        *p++ = '/';\n    }\n\n    flb_utils_split_free(split);\n\n    flb_sds_len_set(out, p - out);\n    out[p - out] = '\\0';\n\n    return out;\n}\n\nstatic flb_sds_t flb_signv4_canonical_request(struct flb_http_client *c,\n                                              int normalize_uri,\n                                              int amz_date_header,\n                                              char *amzdate,\n                                              char *security_token,\n                                              int s3_mode,\n                                              flb_sds_t *signed_headers)\n{\n    int i;\n    int len;\n    int items;\n    int post_params = FLB_FALSE;\n    size_t size;\n    char *val;\n    struct flb_kv **arr;\n    flb_sds_t cr;\n    flb_sds_t uri;\n    flb_sds_t tmp = NULL;\n    flb_sds_t params = NULL;\n    flb_sds_t payload_hash = NULL;\n    struct flb_kv *kv;\n    struct mk_list list_tmp;\n    struct mk_list *head;\n    unsigned char sha256_buf[64] = {0};\n    mbedtls_sha256_context sha256_ctx;\n\n    /* Size hint */\n    size = strlen(c->uri) + (mk_list_size(&c->headers) * 64) + 256;\n\n    cr = flb_sds_create_size(size);\n    if (!cr) {\n        flb_error(\"[signv4] cannot allocate buffer\");\n        return NULL;\n    }\n\n    switch (c->method) {\n    case FLB_HTTP_GET:\n        tmp = flb_sds_cat(cr, \"GET\\n\", 4);\n        break;\n    case FLB_HTTP_POST:\n        tmp = flb_sds_cat(cr, \"POST\\n\", 5);\n        break;\n    case FLB_HTTP_PUT:\n        tmp = flb_sds_cat(cr, \"PUT\\n\", 4);\n        break;\n    case FLB_HTTP_HEAD:\n        tmp = flb_sds_cat(cr, \"HEAD\\n\", 5);\n        break;\n    };\n\n    if (!tmp) {\n        flb_error(\"[signv4] invalid processing of HTTP method\");\n        flb_sds_destroy(cr);\n        return NULL;\n    }\n\n    cr = tmp;\n\n    /* Our URI already contains the query string, so do the proper adjustments */\n    if (c->query_string) {\n        len = (c->query_string - c->uri) - 1;\n    }\n    else {\n        len = strlen(c->uri);\n    }\n\n    /*\n     * URI normalization is required by certain AWS service, for hence the caller\n     * plugin is responsible to enable/disable this flag. If set the URI in the\n     * canonical request will be normalized.\n     */\n    if (normalize_uri == FLB_TRUE) {\n        tmp = flb_signv4_uri_normalize_path((char *) c->uri, len);\n        if (!tmp) {\n            flb_error(\"[signv4] error normalizing path\");\n            flb_sds_destroy(cr);\n            return NULL;\n        }\n        len = flb_sds_len(tmp);\n    }\n    else {\n        tmp = (char *) c->uri;\n    }\n\n    /* Do URI encoding (rfc3986) */\n    uri = uri_encode(tmp, len);\n    if (tmp != c->uri) {\n        flb_sds_destroy(tmp);\n    }\n    if (!uri) {\n        /* error composing outgoing buffer */\n        flb_sds_destroy(cr);\n        return NULL;\n    }\n\n    tmp = flb_sds_cat(cr, uri, flb_sds_len(uri));\n    if (!tmp) {\n        flb_error(\"[signv4] error concatenating encoded URI\");\n        flb_sds_destroy(uri);\n        flb_sds_destroy(cr);\n        return NULL;\n    }\n    cr = tmp;\n    flb_sds_destroy(uri);\n\n    tmp = flb_sds_cat(cr, \"\\n\", 1);\n    if (!tmp) {\n        flb_error(\"[signv4] error concatenating encoded URI break line\");\n        flb_sds_destroy(cr);\n        return NULL;\n    }\n    cr = tmp;\n\n    /* Canonical Query String */\n    tmp = NULL;\n    if (c->query_string) {\n        params = url_params_format((char *) c->query_string);\n        if (!params) {\n            flb_sds_destroy(cr);\n            return NULL;\n        }\n        tmp = flb_sds_cat(cr, params, flb_sds_len(params));\n        if (!tmp) {\n            flb_error(\"[signv4] error concatenating query string\");\n            flb_sds_destroy(params);\n            flb_sds_destroy(cr);\n            return NULL;\n        }\n        flb_sds_destroy(params);\n        cr = tmp;\n    }\n\n    /*\n     * If the original HTTP method is POST and we have some urlencoded parameters\n     * as payload, we must handle them as we did for the query string.\n     */\n    if (c->method == FLB_HTTP_POST && c->body_len > 0) {\n        val = (char *) flb_kv_get_key_value(\"Content-Type\", &c->headers);\n        if (val) {\n            if (strstr(val, \"application/x-www-form-urlencoded\")) {\n                params = url_params_format((char *) c->body_buf);\n                if (!params) {\n                    flb_error(\"[signv4] error processing POST payload params\");\n                    flb_sds_destroy(cr);\n                    return NULL;\n                }\n                tmp = flb_sds_cat(cr, params, flb_sds_len(params));\n                if (!tmp) {\n                    flb_error(\"[signv4] error concatenating POST payload params\");\n                    flb_sds_destroy(params);\n                    flb_sds_destroy(cr);\n                    return NULL;\n                }\n                cr = tmp;\n                flb_sds_destroy(params);\n                post_params = FLB_TRUE;\n            }\n        }\n    }\n\n    /* query string / POST separator */\n    tmp = flb_sds_cat(cr, \"\\n\", 1);\n    if (!tmp) {\n        flb_error(\"[signv4] error adding params breakline separator\");\n        flb_sds_destroy(cr);\n        return NULL;\n    }\n    cr = tmp;\n\n    /*\n     * Calculate payload hash.\n     * This is added at the end of all canonical requests, unless\n     * S3_MODE_UNSIGNED_PAYLOAD is set.\n     * If we're using S3_MODE_SIGNED_PAYLOAD, then the hash is added to the\n     * canonical headers.\n     */\n    if (s3_mode == S3_MODE_UNSIGNED_PAYLOAD) {\n        payload_hash = flb_sds_create(\"UNSIGNED-PAYLOAD\");\n    } else {\n        mbedtls_sha256_init(&sha256_ctx);\n        mbedtls_sha256_starts(&sha256_ctx, 0);\n        if (c->body_len > 0 && post_params == FLB_FALSE) {\n            mbedtls_sha256_update(&sha256_ctx, (const unsigned char *) c->body_buf,\n                                  c->body_len);\n        }\n        mbedtls_sha256_finish(&sha256_ctx, sha256_buf);\n\n        payload_hash = flb_sds_create_size(64);\n        if (!payload_hash) {\n            flb_error(\"[signv4] error formatting hashed payload\");\n            flb_sds_destroy(cr);\n            return NULL;\n        }\n        for (i = 0; i < 32; i++) {\n            tmp = flb_sds_printf(&payload_hash, \"%02x\",\n                                 (unsigned char) sha256_buf[i]);\n            if (!tmp) {\n                flb_error(\"[signv4] error formatting hashed payload\");\n                flb_sds_destroy(cr);\n                flb_sds_destroy(payload_hash);\n                return NULL;\n            }\n            payload_hash = tmp;\n        }\n    }\n\n    /*\n     * Canonical Headers\n     *\n     * Add the required custom headers:\n     *\n     * - x-amz-date\n     * - x-amz-security-token (if set)\n     * - x-amz-content-sha256 (if S3_MODE_SIGNED_PAYLOAD)\n     */\n    mk_list_init(&list_tmp);\n\n    /* include x-amz-date header ? */\n    if (amz_date_header == FLB_TRUE) {\n        len = strlen(amzdate);\n        flb_http_add_header(c, \"x-amz-date\", 10, amzdate, len);\n    }\n\n    /* x-amz-security_token */\n    if (security_token) {\n        len = strlen(security_token);\n        flb_http_add_header(c, \"x-amz-security-token\", 20, security_token, len);\n    }\n\n    if (s3_mode == S3_MODE_SIGNED_PAYLOAD) {\n        flb_http_add_header(c, \"x-amz-content-sha256\", 20, payload_hash, 64);\n    }\n\n    headers_sanitize(&c->headers, &list_tmp);\n\n    /*\n     * For every header registered, append it to the temporal array so we can sort them\n     * later.\n     */\n    items = mk_list_size(&list_tmp);\n    size = (sizeof(struct flb_kv *) * items);\n    arr = flb_malloc(size);\n    if (!arr) {\n        flb_errno();\n        flb_kv_release(&list_tmp);\n        flb_sds_destroy(cr);\n        flb_sds_destroy(payload_hash);\n        return NULL;\n    }\n\n    /* Compose temporal array to sort headers */\n    i = 0;\n    mk_list_foreach(head, &list_tmp) {\n        kv = mk_list_entry(head, struct flb_kv, _head);\n        arr[i] = kv;\n        i++;\n    }\n\n    /* Sort the headers from the temporal array */\n    qsort(arr, items, sizeof(struct flb_kv *), kv_key_cmp);\n\n    /* Iterate sorted headers and append them to the outgoing buffer */\n    for (i = 0; i < items; i++) {\n        kv = (struct flb_kv *) arr[i];\n        tmp = flb_sds_printf(&cr, \"%s:%s\\n\", kv->key, kv->val);\n        if (!tmp) {\n            flb_error(\"[signv4] error composing canonical headers\");\n            flb_free(arr);\n            flb_kv_release(&list_tmp);\n            flb_sds_destroy(cr);\n            flb_sds_destroy(payload_hash);\n            return NULL;\n        }\n        cr = tmp;\n    }\n\n    /* Add required breakline */\n    tmp = flb_sds_printf(&cr, \"\\n\");\n    if (!tmp) {\n        flb_error(\"[signv4] error adding extra breakline separator\");\n        flb_free(arr);\n        flb_kv_release(&list_tmp);\n        flb_sds_destroy(cr);\n        flb_sds_destroy(payload_hash);\n        return NULL;\n    }\n    cr = tmp;\n\n    /* Signed Headers for canonical request context */\n    for (i = 0; i < items; i++) {\n        kv = (struct flb_kv *) arr[i];\n\n        /* Check if this is the last header, if so add breakline separator */\n        if (i + 1 == items) {\n            tmp = flb_sds_printf(&cr, \"%s\\n\", kv->key);\n        }\n        else {\n            tmp = flb_sds_printf(&cr, \"%s;\", kv->key);\n        }\n        if (!tmp) {\n            flb_error(\"[signv4] error composing canonical signed headers\");\n            flb_free(arr);\n            flb_kv_release(&list_tmp);\n            flb_sds_destroy(cr);\n            flb_sds_destroy(payload_hash);\n            return NULL;\n        }\n        cr = tmp;\n    }\n\n    /* Signed Headers for authorization header (Task 4) */\n    for (i = 0; i < items; i++) {\n        kv = (struct flb_kv *) arr[i];\n\n        /* Check if this is the last header, if so add breakline separator */\n        if (i + 1 == items) {\n            tmp = flb_sds_printf(signed_headers, \"%s\", kv->key);\n        }\n        else {\n            tmp = flb_sds_printf(signed_headers, \"%s;\", kv->key);\n        }\n        if (!tmp) {\n            flb_error(\"[signv4] error composing auth signed headers\");\n            flb_free(arr);\n            flb_kv_release(&list_tmp);\n            flb_sds_destroy(cr);\n            flb_sds_destroy(payload_hash);\n            return NULL;\n        }\n        *signed_headers = tmp;\n    }\n\n    flb_free(arr);\n    flb_kv_release(&list_tmp);\n\n    /* Add Payload Hash */\n    tmp = flb_sds_printf(&cr, \"%s\", payload_hash);\n    if (!tmp) {\n        flb_error(\"[signv4] error adding payload hash\");\n        flb_sds_destroy(cr);\n        flb_sds_destroy(payload_hash);\n        return NULL;\n    }\n    cr = tmp;\n    flb_sds_destroy(payload_hash);\n\n    return cr;\n}\n\nflb_sds_t flb_signv4_do(struct flb_http_client *c, int normalize_uri,\n                        int amz_date_header,\n                        time_t t_now,\n                        char *region, char *service,\n                        int s3_mode,\n                        struct flb_aws_provider *provider)\n{\n    char amzdate[32];\n    char datestamp[32];\n    struct tm *gmt;\n    flb_sds_t cr;\n    flb_sds_t string_to_sign;\n    flb_sds_t signature;\n    flb_sds_t signed_headers;\n    flb_sds_t auth_header;\n    struct flb_aws_credentials *creds;\n\n    creds = provider->provider_vtable->get_credentials(provider);\n    if (!creds) {\n        flb_error(\"[signv4] Provider returned no credentials, service=%s\",\n                  service);\n        return NULL;\n    }\n\n    gmt = flb_malloc(sizeof(struct tm));\n    if (!gmt) {\n        flb_errno();\n        flb_aws_credentials_destroy(creds);\n        return NULL;\n    }\n\n    if (!gmtime_r(&t_now, gmt)) {\n        flb_error(\"[signv4] error converting given unix timestamp\");\n        flb_free(gmt);\n        flb_aws_credentials_destroy(creds);\n        return NULL;\n    }\n\n    strftime(amzdate, sizeof(amzdate) - 1, \"%Y%m%dT%H%M%SZ\", gmt);\n    strftime(datestamp, sizeof(datestamp) - 1, \"%Y%m%d\", gmt);\n    flb_free(gmt);\n\n    /* Task 1: canonical request */\n    signed_headers = flb_sds_create_size(256);\n    if (!signed_headers) {\n        flb_error(\"[signedv4] cannot allocate buffer for auth signed headers\");\n        flb_aws_credentials_destroy(creds);\n        return NULL;\n    }\n\n    cr = flb_signv4_canonical_request(c, normalize_uri,\n                                      amz_date_header, amzdate,\n                                      creds->session_token, s3_mode,\n                                      &signed_headers);\n    if (!cr) {\n        flb_error(\"[signv4] failed canonical request\");\n        flb_sds_destroy(signed_headers);\n        flb_aws_credentials_destroy(creds);\n        return NULL;\n    }\n\n    /* Task 2: string to sign */\n    string_to_sign = flb_signv4_string_to_sign(c, cr, amzdate,\n                                               datestamp, service, region);\n    if (!string_to_sign) {\n        flb_error(\"[signv4] failed string to sign\");\n        flb_sds_destroy(cr);\n        flb_sds_destroy(signed_headers);\n        flb_aws_credentials_destroy(creds);\n        return NULL;\n    }\n    flb_sds_destroy(cr);\n\n    /* Task 3: calculate the signature */\n    signature = flb_signv4_calculate_signature(string_to_sign, datestamp,\n                                               service, region,\n                                               creds->secret_access_key);\n    if (!signature) {\n        flb_error(\"[signv4] failed calculate_string\");\n        flb_sds_destroy(signed_headers);\n        flb_sds_destroy(string_to_sign);\n        flb_aws_credentials_destroy(creds);\n        return NULL;\n    }\n    flb_sds_destroy(string_to_sign);\n\n    /* Task 4: add signature to HTTP request */\n    auth_header = flb_signv4_add_authorization(c,\n                                               creds->access_key_id,\n                                               datestamp, region, service,\n                                               signed_headers, signature);\n    flb_sds_destroy(signed_headers);\n    flb_sds_destroy(signature);\n    flb_aws_credentials_destroy(creds);\n\n    if (!auth_header) {\n        flb_error(\"[signv4] error creating authorization header\");\n        return NULL;\n    }\n\n    return auth_header;\n}\n\n\n// target function\nflb_sds_t flb_signv4_uri_normalize_path(char *uri, size_t len)\n{\n    char *p;\n    int end_slash = FLB_FALSE;\n    struct mk_list *tmp;\n    struct mk_list *prev;\n    struct mk_list *head;\n    struct mk_list *split;\n    struct flb_split_entry *entry;\n    flb_sds_t out;\n\n    out = flb_sds_create_len(uri, len);\n    if (!out) {\n        return NULL;\n    }\n\n    if (uri[len - 1] == '/') {\n        end_slash = FLB_TRUE;\n    }\n\n    split = flb_utils_split(out, '/', -1);\n    if (!split) {\n        flb_sds_destroy(out);\n        return NULL;\n    }\n\n    p = out;\n    *p++ = '/';\n\n    mk_list_foreach_safe(head, tmp, split) {\n        entry = mk_list_entry(head, struct flb_split_entry, _head);\n        if (entry->len == 1 && *entry->value == '.') {\n            flb_utils_split_free_entry(entry);\n        }\n        else if (entry->len == 2 && memcmp(entry->value, \"..\", 2) == 0) {\n            prev = head->prev;\n            if (prev != split) {\n                entry = mk_list_entry(prev, struct flb_split_entry, _head);\n                flb_utils_split_free_entry(entry);\n            }\n            entry = mk_list_entry(head, struct flb_split_entry, _head);\n            flb_utils_split_free_entry(entry);\n        }\n    }\n\n    mk_list_foreach(head, split) {\n        entry = mk_list_entry(head, struct flb_split_entry, _head);\n        memcpy(p, entry->value, entry->len);\n        p += entry->len;\n\n        if (head->next != split) {\n            *p++ = '/';\n        }\n    }\n\n    len = (p - out);\n    if (end_slash == FLB_TRUE && out[len - 1] != '/') {\n        *p++ = '/';\n    }\n\n    flb_utils_split_free(split);\n\n    flb_sds_len_set(out, p - out);\n    out[p - out] = '\\0';\n\n    return out;\n}\n",
    "target": 1,
    "idx": 1027710,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nint\nxmlCopyCharMultiByte(xmlChar *out, int val) {\n    if ((out == NULL) || (val < 0)) return(0);\n    /*\n     * We are supposed to handle UTF8, check it's valid\n     * From rfc2044: encoding of the Unicode values on UTF-8:\n     *\n     * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n     * 0000 0000-0000 007F   0xxxxxxx\n     * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n     * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n     */\n    if  (val >= 0x80) {\n\txmlChar *savedout = out;\n\tint bits;\n\tif (val <   0x800) { *out++= (val >>  6) | 0xC0;  bits=  0; }\n\telse if (val < 0x10000) { *out++= (val >> 12) | 0xE0;  bits=  6;}\n\telse if (val < 0x110000)  { *out++= (val >> 18) | 0xF0;  bits=  12; }\n\telse {\n\t    xmlErrEncodingInt(NULL, XML_ERR_INVALID_CHAR,\n\t\t    \"Internal error, xmlCopyCharMultiByte 0x%X out of bound\\n\",\n\t\t\t      val);\n\t    return(0);\n\t}\n\tfor ( ; bits >= 0; bits-= 6)\n\t    *out++= ((val >> bits) & 0x3F) | 0x80 ;\n\treturn (out - savedout);\n    }\n    *out = val;\n    return 1;\n}\n\nstatic void\nxmlParseCommentComplex(xmlParserCtxtPtr ctxt, xmlChar *buf,\n                       size_t len, size_t size) {\n    int q, ql;\n    int r, rl;\n    int cur, l;\n    size_t maxLength = (ctxt->options & XML_PARSE_HUGE) ?\n                       XML_MAX_HUGE_LENGTH :\n                       XML_MAX_TEXT_LENGTH;\n    int inputid;\n\n    inputid = ctxt->input->id;\n\n    if (buf == NULL) {\n        len = 0;\n\tsize = XML_PARSER_BUFFER_SIZE;\n\tbuf = (xmlChar *) xmlMallocAtomic(size);\n\tif (buf == NULL) {\n\t    xmlErrMemory(ctxt, NULL);\n\t    return;\n\t}\n    }\n    q = CUR_CHAR(ql);\n    if (q == 0)\n        goto not_terminated;\n    if (!IS_CHAR(q)) {\n        xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,\n                          \"xmlParseComment: invalid xmlChar value %d\\n\",\n\t                  q);\n\txmlFree (buf);\n\treturn;\n    }\n    NEXTL(ql);\n    r = CUR_CHAR(rl);\n    if (r == 0)\n        goto not_terminated;\n    if (!IS_CHAR(r)) {\n        xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,\n                          \"xmlParseComment: invalid xmlChar value %d\\n\",\n\t                  r);\n\txmlFree (buf);\n\treturn;\n    }\n    NEXTL(rl);\n    cur = CUR_CHAR(l);\n    if (cur == 0)\n        goto not_terminated;\n    while (IS_CHAR(cur) && /* checked */\n           ((cur != '>') ||\n\t    (r != '-') || (q != '-'))) {\n\tif ((r == '-') && (q == '-')) {\n\t    xmlFatalErr(ctxt, XML_ERR_HYPHEN_IN_COMMENT, NULL);\n\t}\n\tif (len + 5 >= size) {\n\t    xmlChar *new_buf;\n            size_t new_size;\n\n\t    new_size = size * 2;\n\t    new_buf = (xmlChar *) xmlRealloc(buf, new_size);\n\t    if (new_buf == NULL) {\n\t\txmlFree (buf);\n\t\txmlErrMemory(ctxt, NULL);\n\t\treturn;\n\t    }\n\t    buf = new_buf;\n            size = new_size;\n\t}\n\tCOPY_BUF(ql,buf,len,q);\n        if (len > maxLength) {\n            xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,\n                         \"Comment too big found\", NULL);\n            xmlFree (buf);\n            return;\n        }\n\n\tq = r;\n\tql = rl;\n\tr = cur;\n\trl = l;\n\n\tNEXTL(l);\n\tcur = CUR_CHAR(l);\n\n    }\n    buf[len] = 0;\n    if (ctxt->instate == XML_PARSER_EOF) {\n        xmlFree(buf);\n        return;\n    }\n    if (cur == 0) {\n\txmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,\n\t                     \"Comment not terminated \\n<!--%.50s\\n\", buf);\n    } else if (!IS_CHAR(cur)) {\n        xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,\n                          \"xmlParseComment: invalid xmlChar value %d\\n\",\n\t                  cur);\n    } else {\n\tif (inputid != ctxt->input->id) {\n\t    xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n\t\t           \"Comment doesn't start and stop in the same\"\n                           \" entity\\n\");\n\t}\n        NEXT;\n\tif ((ctxt->sax != NULL) && (ctxt->sax->comment != NULL) &&\n\t    (!ctxt->disableSAX))\n\t    ctxt->sax->comment(ctxt->userData, buf);\n    }\n    xmlFree(buf);\n    return;\nnot_terminated:\n    xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,\n\t\t\t \"Comment not terminated\\n\", NULL);\n    xmlFree(buf);\n    return;\n}\n\nvoid\nxmlParseComment(xmlParserCtxtPtr ctxt) {\n    xmlChar *buf = NULL;\n    size_t size = XML_PARSER_BUFFER_SIZE;\n    size_t len = 0;\n    size_t maxLength = (ctxt->options & XML_PARSE_HUGE) ?\n                       XML_MAX_HUGE_LENGTH :\n                       XML_MAX_TEXT_LENGTH;\n    xmlParserInputState state;\n    const xmlChar *in;\n    size_t nbchar = 0;\n    int ccol;\n    int inputid;\n\n    /*\n     * Check that there is a comment right here.\n     */\n    if ((RAW != '<') || (NXT(1) != '!'))\n        return;\n    SKIP(2);\n    if ((RAW != '-') || (NXT(1) != '-'))\n        return;\n    state = ctxt->instate;\n    ctxt->instate = XML_PARSER_COMMENT;\n    inputid = ctxt->input->id;\n    SKIP(2);\n    GROW;\n\n    /*\n     * Accelerated common case where input don't need to be\n     * modified before passing it to the handler.\n     */\n    in = ctxt->input->cur;\n    do {\n\tif (*in == 0xA) {\n\t    do {\n\t\tctxt->input->line++; ctxt->input->col = 1;\n\t\tin++;\n\t    } while (*in == 0xA);\n\t}\nget_more:\n        ccol = ctxt->input->col;\n\twhile (((*in > '-') && (*in <= 0x7F)) ||\n\t       ((*in >= 0x20) && (*in < '-')) ||\n\t       (*in == 0x09)) {\n\t\t    in++;\n\t\t    ccol++;\n\t}\n\tctxt->input->col = ccol;\n\tif (*in == 0xA) {\n\t    do {\n\t\tctxt->input->line++; ctxt->input->col = 1;\n\t\tin++;\n\t    } while (*in == 0xA);\n\t    goto get_more;\n\t}\n\tnbchar = in - ctxt->input->cur;\n\t/*\n\t * save current set of data\n\t */\n\tif (nbchar > 0) {\n            if (buf == NULL) {\n                if ((*in == '-') && (in[1] == '-'))\n                    size = nbchar + 1;\n                else\n                    size = XML_PARSER_BUFFER_SIZE + nbchar;\n                buf = (xmlChar *) xmlMallocAtomic(size);\n                if (buf == NULL) {\n                    xmlErrMemory(ctxt, NULL);\n                    ctxt->instate = state;\n                    return;\n                }\n                len = 0;\n            } else if (len + nbchar + 1 >= size) {\n                xmlChar *new_buf;\n                size  += len + nbchar + XML_PARSER_BUFFER_SIZE;\n                new_buf = (xmlChar *) xmlRealloc(buf, size);\n                if (new_buf == NULL) {\n                    xmlFree (buf);\n                    xmlErrMemory(ctxt, NULL);\n                    ctxt->instate = state;\n                    return;\n                }\n                buf = new_buf;\n            }\n            memcpy(&buf[len], ctxt->input->cur, nbchar);\n            len += nbchar;\n            buf[len] = 0;\n\t}\n        if (len > maxLength) {\n            xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,\n                         \"Comment too big found\", NULL);\n            xmlFree (buf);\n            return;\n        }\n\tctxt->input->cur = in;\n\tif (*in == 0xA) {\n\t    in++;\n\t    ctxt->input->line++; ctxt->input->col = 1;\n\t}\n\tif (*in == 0xD) {\n\t    in++;\n\t    if (*in == 0xA) {\n\t\tctxt->input->cur = in;\n\t\tin++;\n\t\tctxt->input->line++; ctxt->input->col = 1;\n\t\tgoto get_more;\n\t    }\n\t    in--;\n\t}\n\tSHRINK;\n\tGROW;\n        if (ctxt->instate == XML_PARSER_EOF) {\n            xmlFree(buf);\n            return;\n        }\n\tin = ctxt->input->cur;\n\tif (*in == '-') {\n\t    if (in[1] == '-') {\n\t        if (in[2] == '>') {\n\t\t    if (ctxt->input->id != inputid) {\n\t\t\txmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n\t\t\t               \"comment doesn't start and stop in the\"\n                                       \" same entity\\n\");\n\t\t    }\n\t\t    SKIP(3);\n\t\t    if ((ctxt->sax != NULL) && (ctxt->sax->comment != NULL) &&\n\t\t        (!ctxt->disableSAX)) {\n\t\t\tif (buf != NULL)\n\t\t\t    ctxt->sax->comment(ctxt->userData, buf);\n\t\t\telse\n\t\t\t    ctxt->sax->comment(ctxt->userData, BAD_CAST \"\");\n\t\t    }\n\t\t    if (buf != NULL)\n\t\t        xmlFree(buf);\n\t\t    if (ctxt->instate != XML_PARSER_EOF)\n\t\t\tctxt->instate = state;\n\t\t    return;\n\t\t}\n\t\tif (buf != NULL) {\n\t\t    xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,\n\t\t                      \"Double hyphen within comment: \"\n                                      \"<!--%.50s\\n\",\n\t\t\t\t      buf);\n\t\t} else\n\t\t    xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,\n\t\t                      \"Double hyphen within comment\\n\", NULL);\n                if (ctxt->instate == XML_PARSER_EOF) {\n                    xmlFree(buf);\n                    return;\n                }\n\t\tin++;\n\t\tctxt->input->col++;\n\t    }\n\t    in++;\n\t    ctxt->input->col++;\n\t    goto get_more;\n\t}\n    } while (((*in >= 0x20) && (*in <= 0x7F)) || (*in == 0x09) || (*in == 0x0a));\n    xmlParseCommentComplex(ctxt, buf, len, size);\n    ctxt->instate = state;\n    return;\n}\n\nstatic void\nxmlParseContentInternal(xmlParserCtxtPtr ctxt) {\n    int nameNr = ctxt->nameNr;\n\n    GROW;\n    while ((ctxt->input->cur < ctxt->input->end) &&\n\t   (ctxt->instate != XML_PARSER_EOF)) {\n\tconst xmlChar *cur = ctxt->input->cur;\n\n\t/*\n\t * First case : a Processing Instruction.\n\t */\n\tif ((*cur == '<') && (cur[1] == '?')) {\n\t    xmlParsePI(ctxt);\n\t}\n\n\t/*\n\t * Second case : a CDSection\n\t */\n\t/* 2.6.0 test was *cur not RAW */\n\telse if (CMP9(CUR_PTR, '<', '!', '[', 'C', 'D', 'A', 'T', 'A', '[')) {\n\t    xmlParseCDSect(ctxt);\n\t}\n\n\t/*\n\t * Third case :  a comment\n\t */\n\telse if ((*cur == '<') && (NXT(1) == '!') &&\n\t\t (NXT(2) == '-') && (NXT(3) == '-')) {\n\t    xmlParseComment(ctxt);\n\t    ctxt->instate = XML_PARSER_CONTENT;\n\t}\n\n\t/*\n\t * Fourth case :  a sub-element.\n\t */\n\telse if (*cur == '<') {\n            if (NXT(1) == '/') {\n                if (ctxt->nameNr <= nameNr)\n                    break;\n\t        xmlParseElementEnd(ctxt);\n            } else {\n\t        xmlParseElementStart(ctxt);\n            }\n\t}\n\n\t/*\n\t * Fifth case : a reference. If if has not been resolved,\n\t *    parsing returns it's Name, create the node\n\t */\n\n\telse if (*cur == '&') {\n\t    xmlParseReference(ctxt);\n\t}\n\n\t/*\n\t * Last case, text. Note that References are handled directly.\n\t */\n\telse {\n\t    xmlParseCharDataInternal(ctxt, 0);\n\t}\n\n\tSHRINK;\n\tGROW;\n    }\n}\n\nvoid\nxmlParseContent(xmlParserCtxtPtr ctxt) {\n    int nameNr = ctxt->nameNr;\n\n    xmlParseContentInternal(ctxt);\n\n    if ((ctxt->instate != XML_PARSER_EOF) &&\n        (ctxt->errNo == XML_ERR_OK) &&\n        (ctxt->nameNr > nameNr)) {\n        const xmlChar *name = ctxt->nameTab[ctxt->nameNr - 1];\n        int line = ctxt->pushTab[ctxt->nameNr - 1].line;\n        xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NOT_FINISHED,\n                \"Premature end of data in tag %s line %d\\n\",\n\t\tname, line, NULL);\n    }\n}\n\nstatic xmlParserErrors\nxmlParseBalancedChunkMemoryInternal(xmlParserCtxtPtr oldctxt,\n\tconst xmlChar *string, void *user_data, xmlNodePtr *lst) {\n    xmlParserCtxtPtr ctxt;\n    xmlDocPtr newDoc = NULL;\n    xmlNodePtr newRoot;\n    xmlSAXHandlerPtr oldsax = NULL;\n    xmlNodePtr content = NULL;\n    xmlNodePtr last = NULL;\n    xmlParserErrors ret = XML_ERR_OK;\n#if 0\n    unsigned i;\n#endif\n\n    if (((oldctxt->depth > 40) && ((oldctxt->options & XML_PARSE_HUGE) == 0)) ||\n        (oldctxt->depth >  100)) {\n\txmlFatalErrMsg(oldctxt, XML_ERR_ENTITY_LOOP,\n                       \"Maximum entity nesting depth exceeded\");\n\treturn(XML_ERR_ENTITY_LOOP);\n    }\n\n\n    if (lst != NULL)\n        *lst = NULL;\n    if (string == NULL)\n        return(XML_ERR_INTERNAL_ERROR);\n\n    ctxt = xmlCreateDocParserCtxt(string);\n    if (ctxt == NULL) return(XML_WAR_UNDECLARED_ENTITY);\n    ctxt->nbErrors = oldctxt->nbErrors;\n    ctxt->nbWarnings = oldctxt->nbWarnings;\n    if (user_data != NULL)\n\tctxt->userData = user_data;\n    else\n\tctxt->userData = ctxt;\n    if (ctxt->dict != NULL) xmlDictFree(ctxt->dict);\n    ctxt->dict = oldctxt->dict;\n    ctxt->input_id = oldctxt->input_id;\n    ctxt->str_xml = xmlDictLookup(ctxt->dict, BAD_CAST \"xml\", 3);\n    ctxt->str_xmlns = xmlDictLookup(ctxt->dict, BAD_CAST \"xmlns\", 5);\n    ctxt->str_xml_ns = xmlDictLookup(ctxt->dict, XML_XML_NAMESPACE, 36);\n\n    /*\n     * Propagate namespaces down the entity\n     *\n     * This is disabled for now. The pre-2.12 code was already broken\n     * since the SAX handler was using xmlSearchNs which didn't see the\n     * namespaces added here.\n     *\n     * Making entities and namespaces work correctly requires additional\n     * changes, see xmlParseReference.\n     */\n#if 0\n    for (i = 0; i < oldctxt->nsdb->hashSize; i++) {\n        xmlParserNsBucket *bucket = &oldctxt->nsdb->hash[i];\n        xmlHashedString hprefix, huri;\n        const xmlChar **ns;\n        xmlParserNsExtra *extra;\n        unsigned nsIndex;\n\n        if ((bucket->hashValue != 0) &&\n            (bucket->index != INT_MAX)) {\n            nsIndex = bucket->index;\n            ns = &oldctxt->nsTab[nsIndex * 2];\n            extra = &oldctxt->nsdb->extra[nsIndex];\n\n            hprefix.name = ns[0];\n            hprefix.hashValue = bucket->hashValue;\n            huri.name = ns[1];\n            huri.hashValue = extra->uriHashValue;\n            xmlParserNsPush(ctxt, &hprefix, &huri, extra->saxData, 0);\n        }\n    }\n#endif\n\n    oldsax = ctxt->sax;\n    ctxt->sax = oldctxt->sax;\n    xmlDetectSAX2(ctxt);\n    ctxt->replaceEntities = oldctxt->replaceEntities;\n    ctxt->options = oldctxt->options;\n\n    ctxt->_private = oldctxt->_private;\n    if (oldctxt->myDoc == NULL) {\n\tnewDoc = xmlNewDoc(BAD_CAST \"1.0\");\n\tif (newDoc == NULL) {\n            ret = XML_ERR_INTERNAL_ERROR;\n            goto error;\n\t}\n\tnewDoc->properties = XML_DOC_INTERNAL;\n\tnewDoc->dict = ctxt->dict;\n\txmlDictReference(newDoc->dict);\n\tctxt->myDoc = newDoc;\n    } else {\n\tctxt->myDoc = oldctxt->myDoc;\n        content = ctxt->myDoc->children;\n\tlast = ctxt->myDoc->last;\n    }\n    newRoot = xmlNewDocNode(ctxt->myDoc, NULL, BAD_CAST \"pseudoroot\", NULL);\n    if (newRoot == NULL) {\n        ret = XML_ERR_INTERNAL_ERROR;\n        goto error;\n    }\n    ctxt->myDoc->children = NULL;\n    ctxt->myDoc->last = NULL;\n    xmlAddChild((xmlNodePtr) ctxt->myDoc, newRoot);\n    nodePush(ctxt, ctxt->myDoc->children);\n    ctxt->instate = XML_PARSER_CONTENT;\n    ctxt->depth = oldctxt->depth;\n\n    ctxt->validate = 0;\n    ctxt->loadsubset = oldctxt->loadsubset;\n    if ((oldctxt->validate) || (oldctxt->replaceEntities != 0)) {\n\t/*\n\t * ID/IDREF registration will be done in xmlValidateElement below\n\t */\n\tctxt->loadsubset |= XML_SKIP_IDS;\n    }\n    ctxt->dictNames = oldctxt->dictNames;\n    ctxt->attsDefault = oldctxt->attsDefault;\n    ctxt->attsSpecial = oldctxt->attsSpecial;\n\n    xmlParseContent(ctxt);\n    if ((RAW == '<') && (NXT(1) == '/')) {\n\txmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);\n    } else if (RAW != 0) {\n\txmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, NULL);\n    }\n    if (ctxt->node != ctxt->myDoc->children) {\n\txmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);\n    }\n\n    if (!ctxt->wellFormed) {\n\tret = (xmlParserErrors)ctxt->errNo;\n        oldctxt->errNo = ctxt->errNo;\n        oldctxt->wellFormed = 0;\n        xmlCopyError(&ctxt->lastError, &oldctxt->lastError);\n    } else {\n        ret = XML_ERR_OK;\n    }\n\n    if ((lst != NULL) && (ret == XML_ERR_OK)) {\n\txmlNodePtr cur;\n\n\t/*\n\t * Return the newly created nodeset after unlinking it from\n\t * they pseudo parent.\n\t */\n\tcur = ctxt->myDoc->children->children;\n\t*lst = cur;\n\twhile (cur != NULL) {\n#ifdef LIBXML_VALID_ENABLED\n\t    if ((oldctxt->validate) && (oldctxt->wellFormed) &&\n\t\t(oldctxt->myDoc) && (oldctxt->myDoc->intSubset) &&\n\t\t(cur->type == XML_ELEMENT_NODE)) {\n\t\toldctxt->valid &= xmlValidateElement(&oldctxt->vctxt,\n\t\t\toldctxt->myDoc, cur);\n\t    }\n#endif /* LIBXML_VALID_ENABLED */\n\t    cur->parent = NULL;\n\t    cur = cur->next;\n\t}\n\tctxt->myDoc->children->children = NULL;\n    }\n    if (ctxt->myDoc != NULL) {\n\txmlFreeNode(ctxt->myDoc->children);\n        ctxt->myDoc->children = content;\n        ctxt->myDoc->last = last;\n    }\n\n    /*\n     * Also record the size of the entity parsed\n     */\n    if (ctxt->input != NULL && oldctxt != NULL) {\n        unsigned long consumed = ctxt->input->consumed;\n\n        xmlSaturatedAddSizeT(&consumed, ctxt->input->cur - ctxt->input->base);\n\n        xmlSaturatedAdd(&oldctxt->sizeentcopy, consumed);\n        xmlSaturatedAdd(&oldctxt->sizeentcopy, ctxt->sizeentcopy);\n    }\n\n    oldctxt->nbErrors = ctxt->nbErrors;\n    oldctxt->nbWarnings = ctxt->nbWarnings;\n\nerror:\n    ctxt->sax = oldsax;\n    ctxt->dict = NULL;\n    ctxt->attsDefault = NULL;\n    ctxt->attsSpecial = NULL;\n    xmlFreeParserCtxt(ctxt);\n    if (newDoc != NULL) {\n\txmlFreeDoc(newDoc);\n    }\n\n    return(ret);\n}\n\nvoid\nxmlParseReference(xmlParserCtxtPtr ctxt) {\n    xmlEntityPtr ent;\n    xmlChar *val;\n    int was_checked;\n    xmlNodePtr list = NULL;\n    xmlParserErrors ret = XML_ERR_OK;\n\n\n    if (RAW != '&')\n        return;\n\n    /*\n     * Simple case of a CharRef\n     */\n    if (NXT(1) == '#') {\n\tint i = 0;\n\txmlChar out[16];\n\tint value = xmlParseCharRef(ctxt);\n\n\tif (value == 0)\n\t    return;\n\n        /*\n         * Just encode the value in UTF-8\n         */\n        COPY_BUF(0, out, i, value);\n        out[i] = 0;\n        if ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL) &&\n            (!ctxt->disableSAX))\n            ctxt->sax->characters(ctxt->userData, out, i);\n\treturn;\n    }\n\n    /*\n     * We are seeing an entity reference\n     */\n    ent = xmlParseEntityRef(ctxt);\n    if (ent == NULL) return;\n    if (!ctxt->wellFormed)\n\treturn;\n    was_checked = ent->flags & XML_ENT_PARSED;\n\n    /* special case of predefined entities */\n    if ((ent->name == NULL) ||\n        (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n\tval = ent->content;\n\tif (val == NULL) return;\n\t/*\n\t * inline the entity.\n\t */\n\tif ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL) &&\n\t    (!ctxt->disableSAX))\n\t    ctxt->sax->characters(ctxt->userData, val, xmlStrlen(val));\n\treturn;\n    }\n\n    /*\n     * The first reference to the entity trigger a parsing phase\n     * where the ent->children is filled with the result from\n     * the parsing.\n     * Note: external parsed entities will not be loaded, it is not\n     * required for a non-validating parser, unless the parsing option\n     * of validating, or substituting entities were given. Doing so is\n     * far more secure as the parser will only process data coming from\n     * the document entity by default.\n     *\n     * FIXME: This doesn't work correctly since entities can be\n     * expanded with different namespace declarations in scope.\n     * For example:\n     *\n     * <!DOCTYPE doc [\n     *   <!ENTITY ent \"<ns:elem/>\">\n     * ]>\n     * <doc>\n     *   <decl1 xmlns:ns=\"urn:ns1\">\n     *     &ent;\n     *   </decl1>\n     *   <decl2 xmlns:ns=\"urn:ns2\">\n     *     &ent;\n     *   </decl2>\n     * </doc>\n     *\n     * Proposed fix:\n     *\n     * - Remove the ent->owner optimization which tries to avoid the\n     *   initial copy of the entity. Always make entities own the\n     *   subtree.\n     * - Ignore current namespace declarations when parsing the\n     *   entity. If a prefix can't be resolved, don't report an error\n     *   but mark it as unresolved.\n     * - Try to resolve these prefixes when expanding the entity.\n     *   This will require a specialized version of xmlStaticCopyNode\n     *   which can also make use of the namespace hash table to avoid\n     *   quadratic behavior.\n     *\n     * Alternatively, we could simply reparse the entity on each\n     * expansion like we already do with custom SAX callbacks.\n     * External entity content should be cached in this case.\n     */\n    if (((ent->flags & XML_ENT_PARSED) == 0) &&\n        ((ent->etype != XML_EXTERNAL_GENERAL_PARSED_ENTITY) ||\n         (ctxt->options & (XML_PARSE_NOENT | XML_PARSE_DTDVALID)))) {\n\tunsigned long oldsizeentcopy = ctxt->sizeentcopy;\n\n\t/*\n\t * This is a bit hackish but this seems the best\n\t * way to make sure both SAX and DOM entity support\n\t * behaves okay.\n\t */\n\tvoid *user_data;\n\tif (ctxt->userData == ctxt)\n\t    user_data = NULL;\n\telse\n\t    user_data = ctxt->userData;\n\n        /* Avoid overflow as much as possible */\n        ctxt->sizeentcopy = 0;\n\n        if (ent->flags & XML_ENT_EXPANDING) {\n            xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);\n            xmlHaltParser(ctxt);\n            return;\n        }\n\n        ent->flags |= XML_ENT_EXPANDING;\n\n\t/*\n\t * Check that this entity is well formed\n\t * 4.3.2: An internal general parsed entity is well-formed\n\t * if its replacement text matches the production labeled\n\t * content.\n\t */\n\tif (ent->etype == XML_INTERNAL_GENERAL_ENTITY) {\n\t    ctxt->depth++;\n\t    ret = xmlParseBalancedChunkMemoryInternal(ctxt, ent->content,\n\t                                              user_data, &list);\n\t    ctxt->depth--;\n\n\t} else if (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY) {\n\t    ctxt->depth++;\n\t    ret = xmlParseExternalEntityPrivate(ctxt->myDoc, ctxt, ctxt->sax,\n\t                                   user_data, ctxt->depth, ent->URI,\n\t\t\t\t\t   ent->ExternalID, &list);\n\t    ctxt->depth--;\n\t} else {\n\t    ret = XML_ERR_ENTITY_PE_INTERNAL;\n\t    xmlErrMsgStr(ctxt, XML_ERR_INTERNAL_ERROR,\n\t\t\t \"invalid entity type found\\n\", NULL);\n\t}\n\n        ent->flags &= ~XML_ENT_EXPANDING;\n        ent->flags |= XML_ENT_PARSED | XML_ENT_CHECKED;\n        ent->expandedSize = ctxt->sizeentcopy;\n\tif (ret == XML_ERR_ENTITY_LOOP) {\n            xmlHaltParser(ctxt);\n\t    xmlFreeNodeList(list);\n\t    return;\n\t}\n\tif (xmlParserEntityCheck(ctxt, oldsizeentcopy)) {\n\t    xmlFreeNodeList(list);\n\t    return;\n\t}\n\n\tif ((ret == XML_ERR_OK) && (list != NULL)) {\n            ent->children = list;\n            /*\n             * Prune it directly in the generated document\n             * except for single text nodes.\n             */\n            if ((ctxt->replaceEntities == 0) ||\n                (ctxt->parseMode == XML_PARSE_READER) ||\n                ((list->type == XML_TEXT_NODE) &&\n                 (list->next == NULL))) {\n                ent->owner = 1;\n                while (list != NULL) {\n                    list->parent = (xmlNodePtr) ent;\n                    if (list->doc != ent->doc)\n                        xmlSetTreeDoc(list, ent->doc);\n                    if (list->next == NULL)\n                        ent->last = list;\n                    list = list->next;\n                }\n                list = NULL;\n            } else {\n                ent->owner = 0;\n                while (list != NULL) {\n                    list->parent = (xmlNodePtr) ctxt->node;\n                    list->doc = ctxt->myDoc;\n                    if (list->next == NULL)\n                        ent->last = list;\n                    list = list->next;\n                }\n                list = ent->children;\n#ifdef LIBXML_LEGACY_ENABLED\n                if (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)\n                    xmlAddEntityReference(ent, list, NULL);\n#endif /* LIBXML_LEGACY_ENABLED */\n            }\n\t} else if ((ret != XML_ERR_OK) &&\n\t\t   (ret != XML_WAR_UNDECLARED_ENTITY)) {\n\t    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,\n\t\t     \"Entity '%s' failed to parse\\n\", ent->name);\n            if (ent->content != NULL)\n                ent->content[0] = 0;\n\t} else if (list != NULL) {\n\t    xmlFreeNodeList(list);\n\t    list = NULL;\n\t}\n\n        /* Prevent entity from being parsed and expanded twice (Bug 760367). */\n        was_checked = 0;\n    }\n\n    /*\n     * Now that the entity content has been gathered\n     * provide it to the application, this can take different forms based\n     * on the parsing modes.\n     */\n    if (ent->children == NULL) {\n\t/*\n\t * Probably running in SAX mode and the callbacks don't\n\t * build the entity content. So unless we already went\n\t * though parsing for first checking go though the entity\n\t * content to generate callbacks associated to the entity\n\t */\n\tif (was_checked != 0) {\n\t    void *user_data;\n\t    /*\n\t     * This is a bit hackish but this seems the best\n\t     * way to make sure both SAX and DOM entity support\n\t     * behaves okay.\n\t     */\n\t    if (ctxt->userData == ctxt)\n\t\tuser_data = NULL;\n\t    else\n\t\tuser_data = ctxt->userData;\n\n\t    if (ent->etype == XML_INTERNAL_GENERAL_ENTITY) {\n\t\tctxt->depth++;\n\t\tret = xmlParseBalancedChunkMemoryInternal(ctxt,\n\t\t\t\t   ent->content, user_data, NULL);\n\t\tctxt->depth--;\n\t    } else if (ent->etype ==\n\t\t       XML_EXTERNAL_GENERAL_PARSED_ENTITY) {\n\t        unsigned long oldsizeentities = ctxt->sizeentities;\n\n\t\tctxt->depth++;\n\t\tret = xmlParseExternalEntityPrivate(ctxt->myDoc, ctxt,\n\t\t\t   ctxt->sax, user_data, ctxt->depth,\n\t\t\t   ent->URI, ent->ExternalID, NULL);\n\t\tctxt->depth--;\n\n                /* Undo the change to sizeentities */\n                ctxt->sizeentities = oldsizeentities;\n\t    } else {\n\t\tret = XML_ERR_ENTITY_PE_INTERNAL;\n\t\txmlErrMsgStr(ctxt, XML_ERR_INTERNAL_ERROR,\n\t\t\t     \"invalid entity type found\\n\", NULL);\n\t    }\n\t    if (ret == XML_ERR_ENTITY_LOOP) {\n\t\txmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);\n\t\treturn;\n\t    }\n            if (xmlParserEntityCheck(ctxt, 0))\n                return;\n\t}\n\tif ((ctxt->sax != NULL) && (ctxt->sax->reference != NULL) &&\n\t    (ctxt->replaceEntities == 0) && (!ctxt->disableSAX)) {\n\t    /*\n\t     * Entity reference callback comes second, it's somewhat\n\t     * superfluous but a compatibility to historical behaviour\n\t     */\n\t    ctxt->sax->reference(ctxt->userData, ent->name);\n\t}\n\treturn;\n    }\n\n    /*\n     * We also check for amplification if entities aren't substituted.\n     * They might be expanded later.\n     */\n    if ((was_checked != 0) &&\n        (xmlParserEntityCheck(ctxt, ent->expandedSize)))\n        return;\n\n    /*\n     * If we didn't get any children for the entity being built\n     */\n    if ((ctxt->sax != NULL) && (ctxt->sax->reference != NULL) &&\n\t(ctxt->replaceEntities == 0) && (!ctxt->disableSAX)) {\n\t/*\n\t * Create a node.\n\t */\n\tctxt->sax->reference(ctxt->userData, ent->name);\n\treturn;\n    }\n\n    if (ctxt->replaceEntities)  {\n\t/*\n\t * There is a problem on the handling of _private for entities\n\t * (bug 155816): Should we copy the content of the field from\n\t * the entity (possibly overwriting some value set by the user\n\t * when a copy is created), should we leave it alone, or should\n\t * we try to take care of different situations?  The problem\n\t * is exacerbated by the usage of this field by the xmlReader.\n\t * To fix this bug, we look at _private on the created node\n\t * and, if it's NULL, we copy in whatever was in the entity.\n\t * If it's not NULL we leave it alone.  This is somewhat of a\n\t * hack - maybe we should have further tests to determine\n\t * what to do.\n\t */\n\tif (ctxt->node != NULL) {\n\t    /*\n\t     * Seems we are generating the DOM content, do\n\t     * a simple tree copy for all references except the first\n\t     * In the first occurrence list contains the replacement.\n\t     */\n\t    if (((list == NULL) && (ent->owner == 0)) ||\n\t\t(ctxt->parseMode == XML_PARSE_READER)) {\n\t\txmlNodePtr nw = NULL, cur, firstChild = NULL;\n\n\t\t/*\n\t\t * when operating on a reader, the entities definitions\n\t\t * are always owning the entities subtree.\n\t\tif (ctxt->parseMode == XML_PARSE_READER)\n\t\t    ent->owner = 1;\n\t\t */\n\n\t\tcur = ent->children;\n\t\twhile (cur != NULL) {\n\t\t    nw = xmlDocCopyNode(cur, ctxt->myDoc, 1);\n\t\t    if (nw != NULL) {\n\t\t\tif (nw->_private == NULL)\n\t\t\t    nw->_private = cur->_private;\n\t\t\tif (firstChild == NULL){\n\t\t\t    firstChild = nw;\n\t\t\t}\n\t\t\tnw = xmlAddChild(ctxt->node, nw);\n\t\t    }\n\t\t    if (cur == ent->last) {\n\t\t\t/*\n\t\t\t * needed to detect some strange empty\n\t\t\t * node cases in the reader tests\n\t\t\t */\n\t\t\tif ((ctxt->parseMode == XML_PARSE_READER) &&\n\t\t\t    (nw != NULL) &&\n\t\t\t    (nw->type == XML_ELEMENT_NODE) &&\n\t\t\t    (nw->children == NULL))\n\t\t\t    nw->extra = 1;\n\n\t\t\tbreak;\n\t\t    }\n\t\t    cur = cur->next;\n\t\t}\n#ifdef LIBXML_LEGACY_ENABLED\n\t\tif (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)\n\t\t  xmlAddEntityReference(ent, firstChild, nw);\n#endif /* LIBXML_LEGACY_ENABLED */\n\t    } else if ((list == NULL) || (ctxt->inputNr > 0)) {\n\t\txmlNodePtr nw = NULL, cur, next, last,\n\t\t\t   firstChild = NULL;\n\n\t\t/*\n\t\t * Copy the entity child list and make it the new\n\t\t * entity child list. The goal is to make sure any\n\t\t * ID or REF referenced will be the one from the\n\t\t * document content and not the entity copy.\n\t\t */\n\t\tcur = ent->children;\n\t\tent->children = NULL;\n\t\tlast = ent->last;\n\t\tent->last = NULL;\n\t\twhile (cur != NULL) {\n\t\t    next = cur->next;\n\t\t    cur->next = NULL;\n\t\t    cur->parent = NULL;\n\t\t    nw = xmlDocCopyNode(cur, ctxt->myDoc, 1);\n\t\t    if (nw != NULL) {\n\t\t\tif (nw->_private == NULL)\n\t\t\t    nw->_private = cur->_private;\n\t\t\tif (firstChild == NULL){\n\t\t\t    firstChild = cur;\n\t\t\t}\n\t\t\txmlAddChild((xmlNodePtr) ent, nw);\n\t\t    }\n\t\t    xmlAddChild(ctxt->node, cur);\n\t\t    if (cur == last)\n\t\t\tbreak;\n\t\t    cur = next;\n\t\t}\n\t\tif (ent->owner == 0)\n\t\t    ent->owner = 1;\n#ifdef LIBXML_LEGACY_ENABLED\n\t\tif (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)\n\t\t  xmlAddEntityReference(ent, firstChild, nw);\n#endif /* LIBXML_LEGACY_ENABLED */\n\t    } else {\n\t\tconst xmlChar *nbktext;\n\n\t\t/*\n\t\t * the name change is to avoid coalescing of the\n\t\t * node with a possible previous text one which\n\t\t * would make ent->children a dangling pointer\n\t\t */\n\t\tnbktext = xmlDictLookup(ctxt->dict, BAD_CAST \"nbktext\",\n\t\t\t\t\t-1);\n\t\tif (ent->children->type == XML_TEXT_NODE)\n\t\t    ent->children->name = nbktext;\n\t\tif ((ent->last != ent->children) &&\n\t\t    (ent->last->type == XML_TEXT_NODE))\n\t\t    ent->last->name = nbktext;\n\t\txmlAddChildList(ctxt->node, ent->children);\n\t    }\n\n\t    /*\n\t     * This is to avoid a nasty side effect, see\n\t     * characters() in SAX.c\n\t     */\n\t    ctxt->nodemem = 0;\n\t    ctxt->nodelen = 0;\n\t    return;\n\t}\n    }\n}\n\nstatic void\nxmlParseContentInternal(xmlParserCtxtPtr ctxt) {\n    int nameNr = ctxt->nameNr;\n\n    GROW;\n    while ((ctxt->input->cur < ctxt->input->end) &&\n\t   (ctxt->instate != XML_PARSER_EOF)) {\n\tconst xmlChar *cur = ctxt->input->cur;\n\n\t/*\n\t * First case : a Processing Instruction.\n\t */\n\tif ((*cur == '<') && (cur[1] == '?')) {\n\t    xmlParsePI(ctxt);\n\t}\n\n\t/*\n\t * Second case : a CDSection\n\t */\n\t/* 2.6.0 test was *cur not RAW */\n\telse if (CMP9(CUR_PTR, '<', '!', '[', 'C', 'D', 'A', 'T', 'A', '[')) {\n\t    xmlParseCDSect(ctxt);\n\t}\n\n\t/*\n\t * Third case :  a comment\n\t */\n\telse if ((*cur == '<') && (NXT(1) == '!') &&\n\t\t (NXT(2) == '-') && (NXT(3) == '-')) {\n\t    xmlParseComment(ctxt);\n\t    ctxt->instate = XML_PARSER_CONTENT;\n\t}\n\n\t/*\n\t * Fourth case :  a sub-element.\n\t */\n\telse if (*cur == '<') {\n            if (NXT(1) == '/') {\n                if (ctxt->nameNr <= nameNr)\n                    break;\n\t        xmlParseElementEnd(ctxt);\n            } else {\n\t        xmlParseElementStart(ctxt);\n            }\n\t}\n\n\t/*\n\t * Fifth case : a reference. If if has not been resolved,\n\t *    parsing returns it's Name, create the node\n\t */\n\n\telse if (*cur == '&') {\n\t    xmlParseReference(ctxt);\n\t}\n\n\t/*\n\t * Last case, text. Note that References are handled directly.\n\t */\n\telse {\n\t    xmlParseCharDataInternal(ctxt, 0);\n\t}\n\n\tSHRINK;\n\tGROW;\n    }\n}\n\nvoid\nxmlParseElement(xmlParserCtxtPtr ctxt) {\n    if (xmlParseElementStart(ctxt) != 0)\n        return;\n\n    xmlParseContentInternal(ctxt);\n    if (ctxt->instate == XML_PARSER_EOF)\n\treturn;\n\n    if (ctxt->input->cur >= ctxt->input->end) {\n        if (ctxt->errNo == XML_ERR_OK) {\n            const xmlChar *name = ctxt->nameTab[ctxt->nameNr - 1];\n            int line = ctxt->pushTab[ctxt->nameNr - 1].line;\n            xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NOT_FINISHED,\n                    \"Premature end of data in tag %s line %d\\n\",\n                    name, line, NULL);\n        }\n        return;\n    }\n\n    xmlParseElementEnd(ctxt);\n}\n\nint\nxmlParseDocument(xmlParserCtxtPtr ctxt) {\n    xmlInitParser();\n\n    if ((ctxt == NULL) || (ctxt->input == NULL))\n        return(-1);\n\n    GROW;\n\n    /*\n     * SAX: detecting the level.\n     */\n    xmlDetectSAX2(ctxt);\n\n    /*\n     * SAX: beginning of the document processing.\n     */\n    if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))\n        ctxt->sax->setDocumentLocator(ctxt->userData, &xmlDefaultSAXLocator);\n    if (ctxt->instate == XML_PARSER_EOF)\n\treturn(-1);\n\n    xmlDetectEncoding(ctxt);\n\n    if (CUR == 0) {\n\txmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);\n\treturn(-1);\n    }\n\n    GROW;\n    if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) && (IS_BLANK_CH(NXT(5)))) {\n\n\t/*\n\t * Note that we will switch encoding on the fly.\n\t */\n\txmlParseXMLDecl(ctxt);\n\tif ((ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) ||\n\t    (ctxt->instate == XML_PARSER_EOF)) {\n\t    /*\n\t     * The XML REC instructs us to stop parsing right here\n\t     */\n\t    return(-1);\n\t}\n\tSKIP_BLANKS;\n    } else {\n\tctxt->version = xmlCharStrdup(XML_DEFAULT_VERSION);\n    }\n    if ((ctxt->sax) && (ctxt->sax->startDocument) && (!ctxt->disableSAX))\n        ctxt->sax->startDocument(ctxt->userData);\n    if (ctxt->instate == XML_PARSER_EOF)\n\treturn(-1);\n    if ((ctxt->myDoc != NULL) && (ctxt->input != NULL) &&\n        (ctxt->input->buf != NULL) && (ctxt->input->buf->compressed >= 0)) {\n\tctxt->myDoc->compression = ctxt->input->buf->compressed;\n    }\n\n    /*\n     * The Misc part of the Prolog\n     */\n    xmlParseMisc(ctxt);\n\n    /*\n     * Then possibly doc type declaration(s) and more Misc\n     * (doctypedecl Misc*)?\n     */\n    GROW;\n    if (CMP9(CUR_PTR, '<', '!', 'D', 'O', 'C', 'T', 'Y', 'P', 'E')) {\n\n\tctxt->inSubset = 1;\n\txmlParseDocTypeDecl(ctxt);\n\tif (RAW == '[') {\n\t    ctxt->instate = XML_PARSER_DTD;\n\t    xmlParseInternalSubset(ctxt);\n\t    if (ctxt->instate == XML_PARSER_EOF)\n\t\treturn(-1);\n\t}\n\n\t/*\n\t * Create and update the external subset.\n\t */\n\tctxt->inSubset = 2;\n\tif ((ctxt->sax != NULL) && (ctxt->sax->externalSubset != NULL) &&\n\t    (!ctxt->disableSAX))\n\t    ctxt->sax->externalSubset(ctxt->userData, ctxt->intSubName,\n\t                              ctxt->extSubSystem, ctxt->extSubURI);\n\tif (ctxt->instate == XML_PARSER_EOF)\n\t    return(-1);\n\tctxt->inSubset = 0;\n\n        xmlCleanSpecialAttr(ctxt);\n\n\tctxt->instate = XML_PARSER_PROLOG;\n\txmlParseMisc(ctxt);\n    }\n\n    /*\n     * Time to start parsing the tree itself\n     */\n    GROW;\n    if (RAW != '<') {\n\txmlFatalErrMsg(ctxt, XML_ERR_DOCUMENT_EMPTY,\n\t\t       \"Start tag expected, '<' not found\\n\");\n    } else {\n\tctxt->instate = XML_PARSER_CONTENT;\n\txmlParseElement(ctxt);\n\tctxt->instate = XML_PARSER_EPILOG;\n\n\n\t/*\n\t * The Misc part at the end\n\t */\n\txmlParseMisc(ctxt);\n\n        if (ctxt->input->cur < ctxt->input->end) {\n            if (ctxt->errNo == XML_ERR_OK)\n\t        xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);\n        } else if ((ctxt->input->buf != NULL) &&\n                   (ctxt->input->buf->encoder != NULL) &&\n                   (!xmlBufIsEmpty(ctxt->input->buf->raw))) {\n            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n                           \"Truncated multi-byte sequence at EOF\\n\");\n        }\n\tctxt->instate = XML_PARSER_EOF;\n    }\n\n    /*\n     * SAX: end of the document processing.\n     */\n    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n        ctxt->sax->endDocument(ctxt->userData);\n\n    /*\n     * Remove locally kept entity definitions if the tree was not built\n     */\n    if ((ctxt->myDoc != NULL) &&\n\t(xmlStrEqual(ctxt->myDoc->version, SAX_COMPAT_MODE))) {\n\txmlFreeDoc(ctxt->myDoc);\n\tctxt->myDoc = NULL;\n    }\n\n    if ((ctxt->wellFormed) && (ctxt->myDoc != NULL)) {\n        ctxt->myDoc->properties |= XML_DOC_WELLFORMED;\n\tif (ctxt->valid)\n\t    ctxt->myDoc->properties |= XML_DOC_DTDVALID;\n\tif (ctxt->nsWellFormed)\n\t    ctxt->myDoc->properties |= XML_DOC_NSVALID;\n\tif (ctxt->options & XML_PARSE_OLD10)\n\t    ctxt->myDoc->properties |= XML_DOC_OLD10;\n    }\n    if (! ctxt->wellFormed) {\n\tctxt->valid = 0;\n\treturn(-1);\n    }\n    return(0);\n}\n\nstatic xmlDocPtr\nxmlDoRead(xmlParserCtxtPtr ctxt, const char *URL, const char *encoding,\n          int options, int reuse)\n{\n    xmlDocPtr ret;\n\n    xmlCtxtUseOptionsInternal(ctxt, options, encoding);\n    if (encoding != NULL) {\n        xmlCharEncodingHandlerPtr hdlr;\n\n        /*\n         * TODO: We should consider to set XML_PARSE_IGNORE_ENC if the\n         * caller provided an encoding. Otherwise, we might switch to\n         * the encoding from the XML declaration which is likely to\n         * break things. Also see xmlSwitchInputEncoding.\n         */\n\thdlr = xmlFindCharEncodingHandler(encoding);\n\tif (hdlr != NULL)\n\t    xmlSwitchToEncoding(ctxt, hdlr);\n    }\n    if ((URL != NULL) && (ctxt->input != NULL) &&\n        (ctxt->input->filename == NULL))\n        ctxt->input->filename = (char *) xmlStrdup((const xmlChar *) URL);\n    xmlParseDocument(ctxt);\n    if ((ctxt->wellFormed) || ctxt->recovery)\n        ret = ctxt->myDoc;\n    else {\n        ret = NULL;\n\tif (ctxt->myDoc != NULL) {\n\t    xmlFreeDoc(ctxt->myDoc);\n\t}\n    }\n    ctxt->myDoc = NULL;\n    if (!reuse) {\n\txmlFreeParserCtxt(ctxt);\n    }\n\n    return (ret);\n}\n\nxmlDocPtr\nxmlReadMemory(const char *buffer, int size, const char *URL, const char *encoding, int options)\n{\n    xmlParserCtxtPtr ctxt;\n\n    xmlInitParser();\n    ctxt = xmlCreateMemoryParserCtxt(buffer, size);\n    if (ctxt == NULL)\n        return (NULL);\n    return (xmlDoRead(ctxt, URL, encoding, options, 0));\n}\n\n\n// target function\nvoid\nxmlParseComment(xmlParserCtxtPtr ctxt) {\n    xmlChar *buf = NULL;\n    size_t size = XML_PARSER_BUFFER_SIZE;\n    size_t len = 0;\n    size_t maxLength = (ctxt->options & XML_PARSE_HUGE) ?\n                       XML_MAX_HUGE_LENGTH :\n                       XML_MAX_TEXT_LENGTH;\n    xmlParserInputState state;\n    const xmlChar *in;\n    size_t nbchar = 0;\n    int ccol;\n    int inputid;\n\n    /*\n     * Check that there is a comment right here.\n     */\n    if ((RAW != '<') || (NXT(1) != '!'))\n        return;\n    SKIP(2);\n    if ((RAW != '-') || (NXT(1) != '-'))\n        return;\n    state = ctxt->instate;\n    ctxt->instate = XML_PARSER_COMMENT;\n    inputid = ctxt->input->id;\n    SKIP(2);\n    GROW;\n\n    /*\n     * Accelerated common case where input don't need to be\n     * modified before passing it to the handler.\n     */\n    in = ctxt->input->cur;\n    do {\n\tif (*in == 0xA) {\n\t    do {\n\t\tctxt->input->line++; ctxt->input->col = 1;\n\t\tin++;\n\t    } while (*in == 0xA);\n\t}\nget_more:\n        ccol = ctxt->input->col;\n\twhile (((*in > '-') && (*in <= 0x7F)) ||\n\t       ((*in >= 0x20) && (*in < '-')) ||\n\t       (*in == 0x09)) {\n\t\t    in++;\n\t\t    ccol++;\n\t}\n\tctxt->input->col = ccol;\n\tif (*in == 0xA) {\n\t    do {\n\t\tctxt->input->line++; ctxt->input->col = 1;\n\t\tin++;\n\t    } while (*in == 0xA);\n\t    goto get_more;\n\t}\n\tnbchar = in - ctxt->input->cur;\n\t/*\n\t * save current set of data\n\t */\n\tif (nbchar > 0) {\n\t    if ((ctxt->sax != NULL) &&\n                (ctxt->disableSAX == 0) &&\n\t\t(ctxt->sax->comment != NULL)) {\n\t\tif (buf == NULL) {\n\t\t    if ((*in == '-') && (in[1] == '-'))\n\t\t        size = nbchar + 1;\n\t\t    else\n\t\t        size = XML_PARSER_BUFFER_SIZE + nbchar;\n\t\t    buf = (xmlChar *) xmlMallocAtomic(size);\n\t\t    if (buf == NULL) {\n\t\t        xmlErrMemory(ctxt, NULL);\n\t\t\tctxt->instate = state;\n\t\t\treturn;\n\t\t    }\n\t\t    len = 0;\n\t\t} else if (len + nbchar + 1 >= size) {\n\t\t    xmlChar *new_buf;\n\t\t    size  += len + nbchar + XML_PARSER_BUFFER_SIZE;\n\t\t    new_buf = (xmlChar *) xmlRealloc(buf, size);\n\t\t    if (new_buf == NULL) {\n\t\t        xmlFree (buf);\n\t\t\txmlErrMemory(ctxt, NULL);\n\t\t\tctxt->instate = state;\n\t\t\treturn;\n\t\t    }\n\t\t    buf = new_buf;\n\t\t}\n\t\tmemcpy(&buf[len], ctxt->input->cur, nbchar);\n\t\tlen += nbchar;\n\t\tbuf[len] = 0;\n\t    }\n\t}\n        if (len > maxLength) {\n            xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,\n                         \"Comment too big found\", NULL);\n            xmlFree (buf);\n            return;\n        }\n\tctxt->input->cur = in;\n\tif (*in == 0xA) {\n\t    in++;\n\t    ctxt->input->line++; ctxt->input->col = 1;\n\t}\n\tif (*in == 0xD) {\n\t    in++;\n\t    if (*in == 0xA) {\n\t\tctxt->input->cur = in;\n\t\tin++;\n\t\tctxt->input->line++; ctxt->input->col = 1;\n\t\tgoto get_more;\n\t    }\n\t    in--;\n\t}\n\tSHRINK;\n\tGROW;\n        if (ctxt->instate == XML_PARSER_EOF) {\n            xmlFree(buf);\n            return;\n        }\n\tin = ctxt->input->cur;\n\tif (*in == '-') {\n\t    if (in[1] == '-') {\n\t        if (in[2] == '>') {\n\t\t    if (ctxt->input->id != inputid) {\n\t\t\txmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n\t\t\t               \"comment doesn't start and stop in the\"\n                                       \" same entity\\n\");\n\t\t    }\n\t\t    SKIP(3);\n\t\t    if ((ctxt->sax != NULL) && (ctxt->sax->comment != NULL) &&\n\t\t        (!ctxt->disableSAX)) {\n\t\t\tif (buf != NULL)\n\t\t\t    ctxt->sax->comment(ctxt->userData, buf);\n\t\t\telse\n\t\t\t    ctxt->sax->comment(ctxt->userData, BAD_CAST \"\");\n\t\t    }\n\t\t    if (buf != NULL)\n\t\t        xmlFree(buf);\n\t\t    if (ctxt->instate != XML_PARSER_EOF)\n\t\t\tctxt->instate = state;\n\t\t    return;\n\t\t}\n\t\tif (buf != NULL) {\n\t\t    xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,\n\t\t                      \"Double hyphen within comment: \"\n                                      \"<!--%.50s\\n\",\n\t\t\t\t      buf);\n\t\t} else\n\t\t    xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,\n\t\t                      \"Double hyphen within comment\\n\", NULL);\n                if (ctxt->instate == XML_PARSER_EOF) {\n                    xmlFree(buf);\n                    return;\n                }\n\t\tin++;\n\t\tctxt->input->col++;\n\t    }\n\t    in++;\n\t    ctxt->input->col++;\n\t    goto get_more;\n\t}\n    } while (((*in >= 0x20) && (*in <= 0x7F)) || (*in == 0x09) || (*in == 0x0a));\n    xmlParseCommentComplex(ctxt, buf, len, size);\n    ctxt->instate = state;\n    return;\n}\n",
    "target": 1,
    "idx": 1063086,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "// context\nvoid GREv0Layer::computeCalculateFields()\n{\n\tcomputeCalculateFieldsInner();\n\n\tif (getGreHeader()->checksumBit == 0)\n\t\treturn;\n\n\t// calculate checksum\n\tsetChecksum(0);\n\n\tScalarBuffer<uint16_t> buffer;\n\tbuffer.buffer = (uint16_t*)m_Data;\n\tbuffer.len = m_DataLen;\n\tsize_t checksum = computeChecksum(&buffer, 1);\n\n\tsetChecksum(checksum);\n}\n\nvoid Packet::computeCalculateFields()\n{\n\t// calculated fields should be calculated from top layer to bottom layer\n\n\tLayer* curLayer = m_LastLayer;\n\twhile (curLayer != nullptr)\n\t{\n\t\tcurLayer->computeCalculateFields();\n\t\tcurLayer = curLayer->getPrevLayer();\n\t}\n}\n\n\n// target function\nvoid IPv4Layer::parseNextLayer()\n{\n\tsize_t hdrLen = getHeaderLen();\n\tif (m_DataLen <= hdrLen || hdrLen == 0)\n\t\treturn;\n\n\tiphdr* ipHdr = getIPv4Header();\n\n\tProtocolType greVer = UnknownProtocol;\n\tProtocolType igmpVer = UnknownProtocol;\n\tbool igmpQuery = false;\n\n\tuint8_t ipVersion = 0;\n\n\tuint8_t* payload = m_Data + hdrLen;\n\tsize_t payloadLen = m_DataLen - hdrLen;\n\n\t// If it's a fragment don't parse upper layers, unless if it's the first fragment\n\t// TODO: assuming first fragment contains at least L4 header, what if it's not true?\n\tif (isFragment())\n\t{\n\t\tm_NextLayer = new PayloadLayer(payload, payloadLen, this, m_Packet);\n\t\treturn;\n\t}\n\n\tswitch (ipHdr->protocol)\n\t{\n\tcase PACKETPP_IPPROTO_UDP:\n\t\tif (payloadLen >= sizeof(udphdr))\n\t\t\tm_NextLayer = new UdpLayer(payload, payloadLen, this, m_Packet);\n\t\tbreak;\n\tcase PACKETPP_IPPROTO_TCP:\n\t\tm_NextLayer = TcpLayer::isDataValid(payload, payloadLen)\n\t\t\t? static_cast<Layer*>(new TcpLayer(payload, payloadLen, this, m_Packet))\n\t\t\t: static_cast<Layer*>(new PayloadLayer(payload, payloadLen, this, m_Packet));\n\t\tbreak;\n\tcase PACKETPP_IPPROTO_ICMP:\n\t\tm_NextLayer = IcmpLayer::isDataValid(payload, payloadLen)\n\t\t\t? static_cast<Layer*>(new IcmpLayer(payload, payloadLen, this, m_Packet))\n\t\t\t: static_cast<Layer*>(new PayloadLayer(payload, payloadLen, this, m_Packet));\n\t\tbreak;\n\tcase PACKETPP_IPPROTO_IPIP:\n\t\tipVersion = *payload >> 4;\n\t\tif (ipVersion == 4 && IPv4Layer::isDataValid(payload, payloadLen))\n\t\t\tm_NextLayer = new IPv4Layer(payload, payloadLen, this, m_Packet);\n\t\telse if (ipVersion == 6 && IPv6Layer::isDataValid(payload, payloadLen))\n\t\t\tm_NextLayer = new IPv6Layer(payload, payloadLen, this, m_Packet);\n\t\telse\n\t\t\tm_NextLayer = new PayloadLayer(payload, payloadLen, this, m_Packet);\n\t\tbreak;\n\tcase PACKETPP_IPPROTO_GRE:\n\t\tgreVer = GreLayer::getGREVersion(payload, payloadLen);\n\t\tif (greVer == GREv0)\n\t\t\tm_NextLayer = new GREv0Layer(payload, payloadLen, this, m_Packet);\n\t\telse if (greVer == GREv1)\n\t\t\tm_NextLayer = new GREv1Layer(payload, payloadLen, this, m_Packet);\n\t\telse\n\t\t\tm_NextLayer = new PayloadLayer(payload, payloadLen, this, m_Packet);\n\t\tbreak;\n\tcase PACKETPP_IPPROTO_IGMP:\n\t\tigmpVer = IgmpLayer::getIGMPVerFromData(\n\t\t\tpayload, std::min<size_t>(payloadLen, be16toh(getIPv4Header()->totalLength) - hdrLen), igmpQuery);\n\t\tif (igmpVer == IGMPv1)\n\t\t\tm_NextLayer = new IgmpV1Layer(payload, payloadLen, this, m_Packet);\n\t\telse if (igmpVer == IGMPv2)\n\t\t\tm_NextLayer = new IgmpV2Layer(payload, payloadLen, this, m_Packet);\n\t\telse if (igmpVer == IGMPv3)\n\t\t{\n\t\t\tif (igmpQuery)\n\t\t\t\tm_NextLayer = new IgmpV3QueryLayer(payload, payloadLen, this, m_Packet);\n\t\t\telse\n\t\t\t\tm_NextLayer = new IgmpV3ReportLayer(payload, payloadLen, this, m_Packet);\n\t\t}\n\t\telse\n\t\t\tm_NextLayer = new PayloadLayer(payload, payloadLen, this, m_Packet);\n\t\tbreak;\n\tcase PACKETPP_IPPROTO_AH:\n\t\tm_NextLayer = AuthenticationHeaderLayer::isDataValid(payload, payloadLen)\n\t\t\t? static_cast<Layer*>(new AuthenticationHeaderLayer(payload, payloadLen, this, m_Packet))\n\t\t\t: static_cast<Layer*>(new PayloadLayer(payload, payloadLen, this, m_Packet));\n\t\tbreak;\n\tcase PACKETPP_IPPROTO_ESP:\n\t\tm_NextLayer = ESPLayer::isDataValid(payload, payloadLen)\n\t\t\t? static_cast<Layer*>(new ESPLayer(payload, payloadLen, this, m_Packet))\n\t\t\t: static_cast<Layer*>(new PayloadLayer(payload, payloadLen, this, m_Packet));\n\t\tbreak;\n\tcase PACKETPP_IPPROTO_IPV6:\n\t\tm_NextLayer = IPv6Layer::isDataValid(payload, payloadLen)\n\t\t\t? static_cast<Layer*>(new IPv6Layer(payload, payloadLen, this, m_Packet))\n\t\t\t: static_cast<Layer*>(new PayloadLayer(payload, payloadLen, this, m_Packet));\n\t\tbreak;\n\tcase PACKETPP_IPPROTO_VRRP:\n\t{\n\t\tauto vrrpVer = VrrpLayer::getVersionFromData(payload, payloadLen);\n\t\tif (vrrpVer == VRRPv2)\n\t\t\tm_NextLayer = new VrrpV2Layer(payload, payloadLen, this, m_Packet);\n\t\telse if (vrrpVer == VRRPv3)\n\t\t\tm_NextLayer = new VrrpV3Layer(payload, payloadLen, this, m_Packet, IPAddress::IPv4AddressType);\n\t\telse\n\t\t\tm_NextLayer = new PayloadLayer(payload, payloadLen, this, m_Packet);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tm_NextLayer = new PayloadLayer(payload, payloadLen, this, m_Packet);\n\t}\n}\nvoid IPv6Layer::parseNextLayer()\n{\n\tsize_t headerLen = getHeaderLen();\n\n\tif (m_DataLen <= headerLen)\n\t\treturn;\n\n\tuint8_t* payload = m_Data + headerLen;\n\tsize_t payloadLen = m_DataLen - headerLen;\n\n\tuint8_t nextHdr;\n\tif (m_LastExtension != nullptr)\n\t{\n\t\tif (m_LastExtension->getExtensionType() == IPv6Extension::IPv6Fragmentation)\n\t\t{\n\t\t\tm_NextLayer = new PayloadLayer(payload, payloadLen, this, m_Packet);\n\t\t\treturn;\n\t\t}\n\n\t\tnextHdr = m_LastExtension->getBaseHeader()->nextHeader;\n\t}\n\telse\n\t{\n\t\tnextHdr = getIPv6Header()->nextHeader;\n\t}\n\n\tswitch (nextHdr)\n\t{\n\tcase PACKETPP_IPPROTO_UDP:\n\t\tm_NextLayer = new UdpLayer(payload, payloadLen, this, m_Packet);\n\t\tbreak;\n\tcase PACKETPP_IPPROTO_TCP:\n\t\tm_NextLayer = TcpLayer::isDataValid(payload, payloadLen)\n\t\t\t? static_cast<Layer*>(new TcpLayer(payload, payloadLen, this, m_Packet))\n\t\t\t: static_cast<Layer*>(new PayloadLayer(payload, payloadLen, this, m_Packet));\n\t\tbreak;\n\tcase PACKETPP_IPPROTO_IPIP:\n\t{\n\t\tuint8_t ipVersion = *payload >> 4;\n\t\tif (ipVersion == 4 && IPv4Layer::isDataValid(payload, payloadLen))\n\t\t\tm_NextLayer = new IPv4Layer(payload, payloadLen, this, m_Packet);\n\t\telse if (ipVersion == 6 && IPv6Layer::isDataValid(payload, payloadLen))\n\t\t\tm_NextLayer = new IPv6Layer(payload, payloadLen, this, m_Packet);\n\t\telse\n\t\t\tm_NextLayer = new PayloadLayer(payload, payloadLen, this, m_Packet);\n\t\tbreak;\n\t}\n\tcase PACKETPP_IPPROTO_GRE:\n\t{\n\t\tProtocolType greVer = GreLayer::getGREVersion(payload, payloadLen);\n\t\tif (greVer == GREv0)\n\t\t\tm_NextLayer = new GREv0Layer(payload, payloadLen, this, m_Packet);\n\t\telse if (greVer == GREv1)\n\t\t\tm_NextLayer = new GREv1Layer(payload, payloadLen, this, m_Packet);\n\t\telse\n\t\t\tm_NextLayer = new PayloadLayer(payload, payloadLen, this, m_Packet);\n\t\tbreak;\n\t}\n\tcase PACKETPP_IPPROTO_AH:\n\t\tm_NextLayer = AuthenticationHeaderLayer::isDataValid(payload, payloadLen)\n\t\t\t? static_cast<Layer*>(new AuthenticationHeaderLayer(payload, payloadLen, this, m_Packet))\n\t\t\t: static_cast<Layer*>(new PayloadLayer(payload, payloadLen, this, m_Packet));\n\t\tbreak;\n\tcase PACKETPP_IPPROTO_ESP:\n\t\tm_NextLayer = ESPLayer::isDataValid(payload, payloadLen)\n\t\t\t? static_cast<Layer*>(new ESPLayer(payload, payloadLen, this, m_Packet))\n\t\t\t: static_cast<Layer*>(new PayloadLayer(payload, payloadLen, this, m_Packet));\n\t\tbreak;\n\tcase PACKETPP_IPPROTO_ICMPV6:\n\t{\n\t\tm_NextLayer = IcmpV6Layer::parseIcmpV6Layer(payload, payloadLen, this, m_Packet);\n\t\tbreak;\n\t}\n\tcase PACKETPP_IPPROTO_VRRP:\n\t{\n\t\tauto vrrpVer = VrrpLayer::getVersionFromData(payload, payloadLen);\n\t\tif (vrrpVer == VRRPv3)\n\t\t\tm_NextLayer = new VrrpV3Layer(payload, payloadLen, this, m_Packet, IPAddress::IPv6AddressType);\n\t\telse\n\t\t\tm_NextLayer = new PayloadLayer(payload, payloadLen, this, m_Packet);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tm_NextLayer = new PayloadLayer(payload, payloadLen, this, m_Packet);\n\t\treturn;\n\t}\n}\n",
    "target": 1,
    "idx": 1064110,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic void\nxmlParseCommentComplex(xmlParserCtxtPtr ctxt, xmlChar *buf,\n                       size_t len, size_t size) {\n    int q, ql;\n    int r, rl;\n    int cur, l;\n    size_t maxLength = (ctxt->options & XML_PARSE_HUGE) ?\n                       XML_MAX_HUGE_LENGTH :\n                       XML_MAX_TEXT_LENGTH;\n    int inputid;\n\n    inputid = ctxt->input->id;\n\n    if (buf == NULL) {\n        len = 0;\n\tsize = XML_PARSER_BUFFER_SIZE;\n\tbuf = (xmlChar *) xmlMallocAtomic(size);\n\tif (buf == NULL) {\n\t    xmlErrMemory(ctxt, NULL);\n\t    return;\n\t}\n    }\n    q = CUR_CHAR(ql);\n    if (q == 0)\n        goto not_terminated;\n    if (!IS_CHAR(q)) {\n        xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,\n                          \"xmlParseComment: invalid xmlChar value %d\\n\",\n\t                  q);\n\txmlFree (buf);\n\treturn;\n    }\n    NEXTL(ql);\n    r = CUR_CHAR(rl);\n    if (r == 0)\n        goto not_terminated;\n    if (!IS_CHAR(r)) {\n        xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,\n                          \"xmlParseComment: invalid xmlChar value %d\\n\",\n\t                  r);\n\txmlFree (buf);\n\treturn;\n    }\n    NEXTL(rl);\n    cur = CUR_CHAR(l);\n    if (cur == 0)\n        goto not_terminated;\n    while (IS_CHAR(cur) && /* checked */\n           ((cur != '>') ||\n\t    (r != '-') || (q != '-'))) {\n\tif ((r == '-') && (q == '-')) {\n\t    xmlFatalErr(ctxt, XML_ERR_HYPHEN_IN_COMMENT, NULL);\n\t}\n\tif (len + 5 >= size) {\n\t    xmlChar *new_buf;\n            size_t new_size;\n\n\t    new_size = size * 2;\n\t    new_buf = (xmlChar *) xmlRealloc(buf, new_size);\n\t    if (new_buf == NULL) {\n\t\txmlFree (buf);\n\t\txmlErrMemory(ctxt, NULL);\n\t\treturn;\n\t    }\n\t    buf = new_buf;\n            size = new_size;\n\t}\n\tCOPY_BUF(ql,buf,len,q);\n        if (len > maxLength) {\n            xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,\n                         \"Comment too big found\", NULL);\n            xmlFree (buf);\n            return;\n        }\n\n\tq = r;\n\tql = rl;\n\tr = cur;\n\trl = l;\n\n\tNEXTL(l);\n\tcur = CUR_CHAR(l);\n\n    }\n    buf[len] = 0;\n    if (ctxt->instate == XML_PARSER_EOF) {\n        xmlFree(buf);\n        return;\n    }\n    if (cur == 0) {\n\txmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,\n\t                     \"Comment not terminated \\n<!--%.50s\\n\", buf);\n    } else if (!IS_CHAR(cur)) {\n        xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,\n                          \"xmlParseComment: invalid xmlChar value %d\\n\",\n\t                  cur);\n    } else {\n\tif (inputid != ctxt->input->id) {\n\t    xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n\t\t           \"Comment doesn't start and stop in the same\"\n                           \" entity\\n\");\n\t}\n        NEXT;\n\tif ((ctxt->sax != NULL) && (ctxt->sax->comment != NULL) &&\n\t    (!ctxt->disableSAX))\n\t    ctxt->sax->comment(ctxt->userData, buf);\n    }\n    xmlFree(buf);\n    return;\nnot_terminated:\n    xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,\n\t\t\t \"Comment not terminated\\n\", NULL);\n    xmlFree(buf);\n    return;\n}\n\nvoid\nxmlParseComment(xmlParserCtxtPtr ctxt) {\n    xmlChar *buf = NULL;\n    size_t size = XML_PARSER_BUFFER_SIZE;\n    size_t len = 0;\n    size_t maxLength = (ctxt->options & XML_PARSE_HUGE) ?\n                       XML_MAX_HUGE_LENGTH :\n                       XML_MAX_TEXT_LENGTH;\n    xmlParserInputState state;\n    const xmlChar *in;\n    size_t nbchar = 0;\n    int ccol;\n    int inputid;\n\n    /*\n     * Check that there is a comment right here.\n     */\n    if ((RAW != '<') || (NXT(1) != '!'))\n        return;\n    SKIP(2);\n    if ((RAW != '-') || (NXT(1) != '-'))\n        return;\n    state = ctxt->instate;\n    ctxt->instate = XML_PARSER_COMMENT;\n    inputid = ctxt->input->id;\n    SKIP(2);\n    GROW;\n\n    /*\n     * Accelerated common case where input don't need to be\n     * modified before passing it to the handler.\n     */\n    in = ctxt->input->cur;\n    do {\n\tif (*in == 0xA) {\n\t    do {\n\t\tctxt->input->line++; ctxt->input->col = 1;\n\t\tin++;\n\t    } while (*in == 0xA);\n\t}\nget_more:\n        ccol = ctxt->input->col;\n\twhile (((*in > '-') && (*in <= 0x7F)) ||\n\t       ((*in >= 0x20) && (*in < '-')) ||\n\t       (*in == 0x09)) {\n\t\t    in++;\n\t\t    ccol++;\n\t}\n\tctxt->input->col = ccol;\n\tif (*in == 0xA) {\n\t    do {\n\t\tctxt->input->line++; ctxt->input->col = 1;\n\t\tin++;\n\t    } while (*in == 0xA);\n\t    goto get_more;\n\t}\n\tnbchar = in - ctxt->input->cur;\n\t/*\n\t * save current set of data\n\t */\n\tif (nbchar > 0) {\n            if (buf == NULL) {\n                if ((*in == '-') && (in[1] == '-'))\n                    size = nbchar + 1;\n                else\n                    size = XML_PARSER_BUFFER_SIZE + nbchar;\n                buf = (xmlChar *) xmlMallocAtomic(size);\n                if (buf == NULL) {\n                    xmlErrMemory(ctxt, NULL);\n                    ctxt->instate = state;\n                    return;\n                }\n                len = 0;\n            } else if (len + nbchar + 1 >= size) {\n                xmlChar *new_buf;\n                size  += len + nbchar + XML_PARSER_BUFFER_SIZE;\n                new_buf = (xmlChar *) xmlRealloc(buf, size);\n                if (new_buf == NULL) {\n                    xmlFree (buf);\n                    xmlErrMemory(ctxt, NULL);\n                    ctxt->instate = state;\n                    return;\n                }\n                buf = new_buf;\n            }\n            memcpy(&buf[len], ctxt->input->cur, nbchar);\n            len += nbchar;\n            buf[len] = 0;\n\t}\n        if (len > maxLength) {\n            xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,\n                         \"Comment too big found\", NULL);\n            xmlFree (buf);\n            return;\n        }\n\tctxt->input->cur = in;\n\tif (*in == 0xA) {\n\t    in++;\n\t    ctxt->input->line++; ctxt->input->col = 1;\n\t}\n\tif (*in == 0xD) {\n\t    in++;\n\t    if (*in == 0xA) {\n\t\tctxt->input->cur = in;\n\t\tin++;\n\t\tctxt->input->line++; ctxt->input->col = 1;\n\t\tgoto get_more;\n\t    }\n\t    in--;\n\t}\n\tSHRINK;\n\tGROW;\n        if (ctxt->instate == XML_PARSER_EOF) {\n            xmlFree(buf);\n            return;\n        }\n\tin = ctxt->input->cur;\n\tif (*in == '-') {\n\t    if (in[1] == '-') {\n\t        if (in[2] == '>') {\n\t\t    if (ctxt->input->id != inputid) {\n\t\t\txmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n\t\t\t               \"comment doesn't start and stop in the\"\n                                       \" same entity\\n\");\n\t\t    }\n\t\t    SKIP(3);\n\t\t    if ((ctxt->sax != NULL) && (ctxt->sax->comment != NULL) &&\n\t\t        (!ctxt->disableSAX)) {\n\t\t\tif (buf != NULL)\n\t\t\t    ctxt->sax->comment(ctxt->userData, buf);\n\t\t\telse\n\t\t\t    ctxt->sax->comment(ctxt->userData, BAD_CAST \"\");\n\t\t    }\n\t\t    if (buf != NULL)\n\t\t        xmlFree(buf);\n\t\t    if (ctxt->instate != XML_PARSER_EOF)\n\t\t\tctxt->instate = state;\n\t\t    return;\n\t\t}\n\t\tif (buf != NULL) {\n\t\t    xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,\n\t\t                      \"Double hyphen within comment: \"\n                                      \"<!--%.50s\\n\",\n\t\t\t\t      buf);\n\t\t} else\n\t\t    xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,\n\t\t                      \"Double hyphen within comment\\n\", NULL);\n                if (ctxt->instate == XML_PARSER_EOF) {\n                    xmlFree(buf);\n                    return;\n                }\n\t\tin++;\n\t\tctxt->input->col++;\n\t    }\n\t    in++;\n\t    ctxt->input->col++;\n\t    goto get_more;\n\t}\n    } while (((*in >= 0x20) && (*in <= 0x7F)) || (*in == 0x09) || (*in == 0x0a));\n    xmlParseCommentComplex(ctxt, buf, len, size);\n    ctxt->instate = state;\n    return;\n}\n\nvoid\nxmlParseMisc(xmlParserCtxtPtr ctxt) {\n    while (ctxt->instate != XML_PARSER_EOF) {\n        SKIP_BLANKS;\n        GROW;\n        if ((RAW == '<') && (NXT(1) == '?')) {\n\t    xmlParsePI(ctxt);\n        } else if (CMP4(CUR_PTR, '<', '!', '-', '-')) {\n\t    xmlParseComment(ctxt);\n        } else {\n            break;\n        }\n    }\n}\n\nint\nxmlParseDocument(xmlParserCtxtPtr ctxt) {\n    xmlInitParser();\n\n    if ((ctxt == NULL) || (ctxt->input == NULL))\n        return(-1);\n\n    GROW;\n\n    /*\n     * SAX: detecting the level.\n     */\n    xmlDetectSAX2(ctxt);\n\n    /*\n     * SAX: beginning of the document processing.\n     */\n    if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))\n        ctxt->sax->setDocumentLocator(ctxt->userData, &xmlDefaultSAXLocator);\n    if (ctxt->instate == XML_PARSER_EOF)\n\treturn(-1);\n\n    xmlDetectEncoding(ctxt);\n\n    if (CUR == 0) {\n\txmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);\n\treturn(-1);\n    }\n\n    GROW;\n    if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) && (IS_BLANK_CH(NXT(5)))) {\n\n\t/*\n\t * Note that we will switch encoding on the fly.\n\t */\n\txmlParseXMLDecl(ctxt);\n\tif ((ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) ||\n\t    (ctxt->instate == XML_PARSER_EOF)) {\n\t    /*\n\t     * The XML REC instructs us to stop parsing right here\n\t     */\n\t    return(-1);\n\t}\n\tSKIP_BLANKS;\n    } else {\n\tctxt->version = xmlCharStrdup(XML_DEFAULT_VERSION);\n    }\n    if ((ctxt->sax) && (ctxt->sax->startDocument) && (!ctxt->disableSAX))\n        ctxt->sax->startDocument(ctxt->userData);\n    if (ctxt->instate == XML_PARSER_EOF)\n\treturn(-1);\n    if ((ctxt->myDoc != NULL) && (ctxt->input != NULL) &&\n        (ctxt->input->buf != NULL) && (ctxt->input->buf->compressed >= 0)) {\n\tctxt->myDoc->compression = ctxt->input->buf->compressed;\n    }\n\n    /*\n     * The Misc part of the Prolog\n     */\n    xmlParseMisc(ctxt);\n\n    /*\n     * Then possibly doc type declaration(s) and more Misc\n     * (doctypedecl Misc*)?\n     */\n    GROW;\n    if (CMP9(CUR_PTR, '<', '!', 'D', 'O', 'C', 'T', 'Y', 'P', 'E')) {\n\n\tctxt->inSubset = 1;\n\txmlParseDocTypeDecl(ctxt);\n\tif (RAW == '[') {\n\t    ctxt->instate = XML_PARSER_DTD;\n\t    xmlParseInternalSubset(ctxt);\n\t    if (ctxt->instate == XML_PARSER_EOF)\n\t\treturn(-1);\n\t}\n\n\t/*\n\t * Create and update the external subset.\n\t */\n\tctxt->inSubset = 2;\n\tif ((ctxt->sax != NULL) && (ctxt->sax->externalSubset != NULL) &&\n\t    (!ctxt->disableSAX))\n\t    ctxt->sax->externalSubset(ctxt->userData, ctxt->intSubName,\n\t                              ctxt->extSubSystem, ctxt->extSubURI);\n\tif (ctxt->instate == XML_PARSER_EOF)\n\t    return(-1);\n\tctxt->inSubset = 0;\n\n        xmlCleanSpecialAttr(ctxt);\n\n\tctxt->instate = XML_PARSER_PROLOG;\n\txmlParseMisc(ctxt);\n    }\n\n    /*\n     * Time to start parsing the tree itself\n     */\n    GROW;\n    if (RAW != '<') {\n\txmlFatalErrMsg(ctxt, XML_ERR_DOCUMENT_EMPTY,\n\t\t       \"Start tag expected, '<' not found\\n\");\n    } else {\n\tctxt->instate = XML_PARSER_CONTENT;\n\txmlParseElement(ctxt);\n\tctxt->instate = XML_PARSER_EPILOG;\n\n\n\t/*\n\t * The Misc part at the end\n\t */\n\txmlParseMisc(ctxt);\n\n        if (ctxt->input->cur < ctxt->input->end) {\n            if (ctxt->errNo == XML_ERR_OK)\n\t        xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);\n        } else if ((ctxt->input->buf != NULL) &&\n                   (ctxt->input->buf->encoder != NULL) &&\n                   (!xmlBufIsEmpty(ctxt->input->buf->raw))) {\n            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n                           \"Truncated multi-byte sequence at EOF\\n\");\n        }\n\tctxt->instate = XML_PARSER_EOF;\n    }\n\n    /*\n     * SAX: end of the document processing.\n     */\n    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n        ctxt->sax->endDocument(ctxt->userData);\n\n    /*\n     * Remove locally kept entity definitions if the tree was not built\n     */\n    if ((ctxt->myDoc != NULL) &&\n\t(xmlStrEqual(ctxt->myDoc->version, SAX_COMPAT_MODE))) {\n\txmlFreeDoc(ctxt->myDoc);\n\tctxt->myDoc = NULL;\n    }\n\n    if ((ctxt->wellFormed) && (ctxt->myDoc != NULL)) {\n        ctxt->myDoc->properties |= XML_DOC_WELLFORMED;\n\tif (ctxt->valid)\n\t    ctxt->myDoc->properties |= XML_DOC_DTDVALID;\n\tif (ctxt->nsWellFormed)\n\t    ctxt->myDoc->properties |= XML_DOC_NSVALID;\n\tif (ctxt->options & XML_PARSE_OLD10)\n\t    ctxt->myDoc->properties |= XML_DOC_OLD10;\n    }\n    if (! ctxt->wellFormed) {\n\tctxt->valid = 0;\n\treturn(-1);\n    }\n    return(0);\n}\n\nstatic xmlDocPtr\nxmlDoRead(xmlParserCtxtPtr ctxt, const char *URL, const char *encoding,\n          int options, int reuse)\n{\n    xmlDocPtr ret;\n\n    xmlCtxtUseOptionsInternal(ctxt, options, encoding);\n    if (encoding != NULL) {\n        xmlCharEncodingHandlerPtr hdlr;\n\n        /*\n         * TODO: We should consider to set XML_PARSE_IGNORE_ENC if the\n         * caller provided an encoding. Otherwise, we might switch to\n         * the encoding from the XML declaration which is likely to\n         * break things. Also see xmlSwitchInputEncoding.\n         */\n\thdlr = xmlFindCharEncodingHandler(encoding);\n\tif (hdlr != NULL)\n\t    xmlSwitchToEncoding(ctxt, hdlr);\n    }\n    if ((URL != NULL) && (ctxt->input != NULL) &&\n        (ctxt->input->filename == NULL))\n        ctxt->input->filename = (char *) xmlStrdup((const xmlChar *) URL);\n    xmlParseDocument(ctxt);\n    if ((ctxt->wellFormed) || ctxt->recovery)\n        ret = ctxt->myDoc;\n    else {\n        ret = NULL;\n\tif (ctxt->myDoc != NULL) {\n\t    xmlFreeDoc(ctxt->myDoc);\n\t}\n    }\n    ctxt->myDoc = NULL;\n    if (!reuse) {\n\txmlFreeParserCtxt(ctxt);\n    }\n\n    return (ret);\n}\n\nxmlDocPtr\nxmlReadMemory(const char *buffer, int size, const char *URL, const char *encoding, int options)\n{\n    xmlParserCtxtPtr ctxt;\n\n    xmlInitParser();\n    ctxt = xmlCreateMemoryParserCtxt(buffer, size);\n    if (ctxt == NULL)\n        return (NULL);\n    return (xmlDoRead(ctxt, URL, encoding, options, 0));\n}\n\nint\nxsltFuzzXsltInit(void) {\n    xsltFuzzInit();\n    xmlSetExternalEntityLoader(xmlFuzzEntityLoader);\n    return(0);\n}\n\n\n// target function\nvoid\nxmlParseComment(xmlParserCtxtPtr ctxt) {\n    xmlChar *buf = NULL;\n    size_t size = XML_PARSER_BUFFER_SIZE;\n    size_t len = 0;\n    size_t maxLength = (ctxt->options & XML_PARSE_HUGE) ?\n                       XML_MAX_HUGE_LENGTH :\n                       XML_MAX_TEXT_LENGTH;\n    xmlParserInputState state;\n    const xmlChar *in;\n    size_t nbchar = 0;\n    int ccol;\n    int inputid;\n\n    /*\n     * Check that there is a comment right here.\n     */\n    if ((RAW != '<') || (NXT(1) != '!'))\n        return;\n    SKIP(2);\n    if ((RAW != '-') || (NXT(1) != '-'))\n        return;\n    state = ctxt->instate;\n    ctxt->instate = XML_PARSER_COMMENT;\n    inputid = ctxt->input->id;\n    SKIP(2);\n    GROW;\n\n    /*\n     * Accelerated common case where input don't need to be\n     * modified before passing it to the handler.\n     */\n    in = ctxt->input->cur;\n    do {\n\tif (*in == 0xA) {\n\t    do {\n\t\tctxt->input->line++; ctxt->input->col = 1;\n\t\tin++;\n\t    } while (*in == 0xA);\n\t}\nget_more:\n        ccol = ctxt->input->col;\n\twhile (((*in > '-') && (*in <= 0x7F)) ||\n\t       ((*in >= 0x20) && (*in < '-')) ||\n\t       (*in == 0x09)) {\n\t\t    in++;\n\t\t    ccol++;\n\t}\n\tctxt->input->col = ccol;\n\tif (*in == 0xA) {\n\t    do {\n\t\tctxt->input->line++; ctxt->input->col = 1;\n\t\tin++;\n\t    } while (*in == 0xA);\n\t    goto get_more;\n\t}\n\tnbchar = in - ctxt->input->cur;\n\t/*\n\t * save current set of data\n\t */\n\tif (nbchar > 0) {\n\t    if ((ctxt->sax != NULL) &&\n                (ctxt->disableSAX == 0) &&\n\t\t(ctxt->sax->comment != NULL)) {\n\t\tif (buf == NULL) {\n\t\t    if ((*in == '-') && (in[1] == '-'))\n\t\t        size = nbchar + 1;\n\t\t    else\n\t\t        size = XML_PARSER_BUFFER_SIZE + nbchar;\n\t\t    buf = (xmlChar *) xmlMallocAtomic(size);\n\t\t    if (buf == NULL) {\n\t\t        xmlErrMemory(ctxt, NULL);\n\t\t\tctxt->instate = state;\n\t\t\treturn;\n\t\t    }\n\t\t    len = 0;\n\t\t} else if (len + nbchar + 1 >= size) {\n\t\t    xmlChar *new_buf;\n\t\t    size  += len + nbchar + XML_PARSER_BUFFER_SIZE;\n\t\t    new_buf = (xmlChar *) xmlRealloc(buf, size);\n\t\t    if (new_buf == NULL) {\n\t\t        xmlFree (buf);\n\t\t\txmlErrMemory(ctxt, NULL);\n\t\t\tctxt->instate = state;\n\t\t\treturn;\n\t\t    }\n\t\t    buf = new_buf;\n\t\t}\n\t\tmemcpy(&buf[len], ctxt->input->cur, nbchar);\n\t\tlen += nbchar;\n\t\tbuf[len] = 0;\n\t    }\n\t}\n        if (len > maxLength) {\n            xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,\n                         \"Comment too big found\", NULL);\n            xmlFree (buf);\n            return;\n        }\n\tctxt->input->cur = in;\n\tif (*in == 0xA) {\n\t    in++;\n\t    ctxt->input->line++; ctxt->input->col = 1;\n\t}\n\tif (*in == 0xD) {\n\t    in++;\n\t    if (*in == 0xA) {\n\t\tctxt->input->cur = in;\n\t\tin++;\n\t\tctxt->input->line++; ctxt->input->col = 1;\n\t\tgoto get_more;\n\t    }\n\t    in--;\n\t}\n\tSHRINK;\n\tGROW;\n        if (ctxt->instate == XML_PARSER_EOF) {\n            xmlFree(buf);\n            return;\n        }\n\tin = ctxt->input->cur;\n\tif (*in == '-') {\n\t    if (in[1] == '-') {\n\t        if (in[2] == '>') {\n\t\t    if (ctxt->input->id != inputid) {\n\t\t\txmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n\t\t\t               \"comment doesn't start and stop in the\"\n                                       \" same entity\\n\");\n\t\t    }\n\t\t    SKIP(3);\n\t\t    if ((ctxt->sax != NULL) && (ctxt->sax->comment != NULL) &&\n\t\t        (!ctxt->disableSAX)) {\n\t\t\tif (buf != NULL)\n\t\t\t    ctxt->sax->comment(ctxt->userData, buf);\n\t\t\telse\n\t\t\t    ctxt->sax->comment(ctxt->userData, BAD_CAST \"\");\n\t\t    }\n\t\t    if (buf != NULL)\n\t\t        xmlFree(buf);\n\t\t    if (ctxt->instate != XML_PARSER_EOF)\n\t\t\tctxt->instate = state;\n\t\t    return;\n\t\t}\n\t\tif (buf != NULL) {\n\t\t    xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,\n\t\t                      \"Double hyphen within comment: \"\n                                      \"<!--%.50s\\n\",\n\t\t\t\t      buf);\n\t\t} else\n\t\t    xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,\n\t\t                      \"Double hyphen within comment\\n\", NULL);\n                if (ctxt->instate == XML_PARSER_EOF) {\n                    xmlFree(buf);\n                    return;\n                }\n\t\tin++;\n\t\tctxt->input->col++;\n\t    }\n\t    in++;\n\t    ctxt->input->col++;\n\t    goto get_more;\n\t}\n    } while (((*in >= 0x20) && (*in <= 0x7F)) || (*in == 0x09) || (*in == 0x0a));\n    xmlParseCommentComplex(ctxt, buf, len, size);\n    ctxt->instate = state;\n    return;\n}\n",
    "target": 1,
    "idx": 1063082,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic int MqttClient_DecodePacket(MqttClient* client, byte* rx_buf,\n    word32 rx_len, void *packet_obj, MqttPacketType* ppacket_type,\n    MqttQoS* ppacket_qos, word16* ppacket_id)\n{\n    int rc = MQTT_CODE_SUCCESS;\n    MqttPacket* header;\n    MqttPacketType packet_type;\n    MqttQoS packet_qos;\n    word16 packet_id = 0;\n#ifdef WOLFMQTT_V5\n    MqttProp* props = NULL;\n#endif\n\n    /* must have rx buffer with at least 2 byes for header */\n    if (rx_buf == NULL || rx_len < MQTT_PACKET_HEADER_MIN_SIZE) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    /* Decode header */\n    header = (MqttPacket*)rx_buf;\n    packet_type = (MqttPacketType)MQTT_PACKET_TYPE_GET(header->type_flags);\n    if (ppacket_type) {\n        *ppacket_type = packet_type;\n    }\n    packet_qos = (MqttQoS)MQTT_PACKET_FLAGS_GET_QOS(header->type_flags);\n    if (ppacket_qos) {\n        *ppacket_qos = packet_qos;\n    }\n\n    /* Decode packet specific data (if requested) */\n    if (ppacket_id || packet_obj) {\n        switch (packet_type) {\n        case MQTT_PACKET_TYPE_CONNECT_ACK:\n        {\n            MqttConnectAck connect_ack, *p_connect_ack = &connect_ack;\n            if (packet_obj) {\n                p_connect_ack = (MqttConnectAck*)packet_obj;\n            }\n            else {\n                XMEMSET(p_connect_ack, 0, sizeof(MqttConnectAck));\n            }\n        #ifdef WOLFMQTT_V5\n            p_connect_ack->protocol_level = client->protocol_level;\n        #endif\n            rc = MqttDecode_ConnectAck(rx_buf, rx_len, p_connect_ack);\n        #ifdef WOLFMQTT_V5\n            if (rc >= 0) {\n                props = p_connect_ack->props;\n            }\n        #endif\n            break;\n        }\n        case MQTT_PACKET_TYPE_PUBLISH:\n        {\n            MqttPublish publish, *p_publish = &publish;\n            if (packet_obj) {\n                p_publish = (MqttPublish*)packet_obj;\n            }\n            else {\n                XMEMSET(p_publish, 0, sizeof(MqttPublish));\n            }\n        #ifdef WOLFMQTT_V5\n            p_publish->protocol_level = client->protocol_level;\n        #endif\n            rc = MqttDecode_Publish(rx_buf, rx_len, p_publish);\n            if (rc >= 0) {\n                packet_id = p_publish->packet_id;\n            #ifdef WOLFMQTT_V5\n                props = p_publish->props;\n            #endif\n            }\n            break;\n        }\n        case MQTT_PACKET_TYPE_PUBLISH_ACK:\n        case MQTT_PACKET_TYPE_PUBLISH_REC:\n        case MQTT_PACKET_TYPE_PUBLISH_REL:\n        case MQTT_PACKET_TYPE_PUBLISH_COMP:\n        {\n            MqttPublishResp publish_resp, *p_publish_resp = &publish_resp;\n            if (packet_obj) {\n                p_publish_resp = (MqttPublishResp*)packet_obj;\n            }\n            else {\n                XMEMSET(p_publish_resp, 0, sizeof(MqttPublishResp));\n            }\n        #ifdef WOLFMQTT_V5\n                p_publish_resp->protocol_level = client->protocol_level;\n        #endif\n                rc = MqttDecode_PublishResp(rx_buf, rx_len, packet_type,\n                p_publish_resp);\n            if (rc >= 0) {\n                packet_id = p_publish_resp->packet_id;\n            #ifdef WOLFMQTT_V5\n                props = p_publish_resp->props;\n            #endif\n            }\n            break;\n        }\n        case MQTT_PACKET_TYPE_SUBSCRIBE_ACK:\n        {\n            MqttSubscribeAck subscribe_ack, *p_subscribe_ack = &subscribe_ack;\n            if (packet_obj) {\n                p_subscribe_ack = (MqttSubscribeAck*)packet_obj;\n            }\n            else {\n                XMEMSET(p_subscribe_ack, 0, sizeof(MqttSubscribeAck));\n            }\n        #ifdef WOLFMQTT_V5\n            p_subscribe_ack->protocol_level = client->protocol_level;\n        #endif\n            rc = MqttDecode_SubscribeAck(rx_buf, rx_len, p_subscribe_ack);\n            if (rc >= 0) {\n                packet_id = p_subscribe_ack->packet_id;\n            #ifdef WOLFMQTT_V5\n                props = p_subscribe_ack->props;\n            #endif\n            }\n            break;\n        }\n        case MQTT_PACKET_TYPE_UNSUBSCRIBE_ACK:\n        {\n            MqttUnsubscribeAck unsubscribe_ack,\n                               *p_unsubscribe_ack = &unsubscribe_ack;\n            if (packet_obj) {\n                p_unsubscribe_ack = (MqttUnsubscribeAck*)packet_obj;\n            }\n            else {\n                XMEMSET(p_unsubscribe_ack, 0, sizeof(MqttUnsubscribeAck));\n            }\n        #ifdef WOLFMQTT_V5\n            p_unsubscribe_ack->protocol_level = client->protocol_level;\n        #endif\n            rc = MqttDecode_UnsubscribeAck(rx_buf, rx_len, p_unsubscribe_ack);\n            if (rc >= 0) {\n                packet_id = p_unsubscribe_ack->packet_id;\n            #ifdef WOLFMQTT_V5\n                props = p_unsubscribe_ack->props;\n            #endif\n            }\n            break;\n        }\n        case MQTT_PACKET_TYPE_PING_RESP:\n        {\n            MqttPing ping, *p_ping = &ping;\n            if (packet_obj) {\n                p_ping = (MqttPing*)packet_obj;\n            }\n            else {\n                XMEMSET(p_ping, 0, sizeof(MqttPing));\n            }\n            rc = MqttDecode_Ping(rx_buf, rx_len, p_ping);\n            break;\n        }\n        case MQTT_PACKET_TYPE_AUTH:\n        {\n        #ifdef WOLFMQTT_V5\n            MqttAuth auth, *p_auth = &auth;\n            if (packet_obj) {\n                p_auth = (MqttAuth*)packet_obj;\n            }\n            else {\n                XMEMSET(p_auth, 0, sizeof(MqttAuth));\n            }\n            rc = MqttDecode_Auth(rx_buf, rx_len, p_auth);\n            if (rc >= 0) {\n                props = p_auth->props;\n            }\n        #else\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n        #endif /* WOLFMQTT_V5 */\n            break;\n        }\n        case MQTT_PACKET_TYPE_DISCONNECT:\n        {\n        #ifdef WOLFMQTT_V5\n            MqttDisconnect disc, *p_disc = &disc;\n            if (packet_obj) {\n                p_disc = (MqttDisconnect*)packet_obj;\n            }\n            else {\n                XMEMSET(p_disc, 0, sizeof(MqttDisconnect));\n            }\n            rc = MqttDecode_Disconnect(rx_buf, rx_len, p_disc);\n            if (rc >= 0) {\n                props = p_disc->props;\n            }\n        #else\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n        #endif /* WOLFMQTT_V5 */\n            break;\n        }\n        case MQTT_PACKET_TYPE_CONNECT:\n        case MQTT_PACKET_TYPE_SUBSCRIBE:\n        case MQTT_PACKET_TYPE_UNSUBSCRIBE:\n        case MQTT_PACKET_TYPE_PING_REQ:\n        case MQTT_PACKET_TYPE_ANY:\n        case MQTT_PACKET_TYPE_RESERVED:\n        default:\n            /* these type are only encoded by client */\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n            break;\n        } /* switch (packet_type) */\n    }\n\n    if (ppacket_id) {\n        *ppacket_id = packet_id;\n    }\n\n#ifdef WOLFMQTT_V5\n    if (props) {\n    #ifdef WOLFMQTT_PROPERTY_CB\n        /* Check for properties set by the server */\n        if (packet_obj && client->property_cb) {\n            /* capture error if returned */\n            int rc_err = client->property_cb(client, props,\n                    client->property_ctx);\n            if (rc_err < 0) {\n                rc = rc_err;\n            }\n        }\n    #endif\n        /* Free the properties */\n        MqttProps_Free(props);\n    }\n#endif\n\n    (void)client;\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"MqttClient_DecodePacket: Rc %d, Len %d, Type %s (%d), ID %d,\"\n            \" QoS %d\",\n        rc, rx_len, MqttPacket_TypeDesc(packet_type), packet_type, packet_id,\n        packet_qos);\n#endif\n\n    return rc;\n}\n\nstatic int MqttClient_HandlePacket(MqttClient* client,\n    MqttPacketType packet_type, void *packet_obj, int timeout_ms)\n{\n    int rc = MQTT_CODE_SUCCESS;\n    MqttQoS packet_qos = MQTT_QOS_0;\n    word16 packet_id = 0;\n\n    if (client == NULL || packet_obj == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    switch (packet_type)\n    {\n        case MQTT_PACKET_TYPE_CONNECT_ACK:\n        {\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, packet_obj, &packet_type, &packet_qos,\n                &packet_id);\n            break;\n        }\n        case MQTT_PACKET_TYPE_PUBLISH:\n        {\n            MqttPublish *publish = (MqttPublish*)packet_obj;\n            MqttPacketType resp_type;\n\n            if (publish->stat == MQTT_MSG_BEGIN ||\n                publish->stat == MQTT_MSG_READ) {\n                rc = MqttClient_DecodePacket(client, client->rx_buf,\n                    client->packet.buf_len, packet_obj, &packet_type,\n                    &packet_qos, &packet_id);\n                if (rc <= 0) {\n                    return rc;\n                }\n            }\n            else {\n                /* packet ID and QoS were already established */\n                packet_id = client->msg.publish.packet_id;\n                packet_qos = client->msg.publish.qos;\n            }\n\n            rc = MqttClient_Publish_ReadPayload(client, publish, timeout_ms);\n            if (rc < 0) {\n                break;\n            }\n\n            /* Handle QoS */\n            if (packet_qos == MQTT_QOS_0) {\n                /* we are done, no QoS response */\n                break;\n            }\n\n            /* Determine packet type to write */\n            resp_type = (packet_qos == MQTT_QOS_1) ?\n                MQTT_PACKET_TYPE_PUBLISH_ACK :\n                MQTT_PACKET_TYPE_PUBLISH_REC;\n            publish->resp.packet_id = packet_id;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Lock send socket mutex */\n            rc = wm_SemLock(&client->lockSend);\n            if (rc != 0) {\n                return rc;\n            }\n        #endif\n\n            /* Encode publish response */\n            rc = MqttEncode_PublishResp(client->tx_buf, client->tx_buf_len,\n                resp_type, &publish->resp);\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d), ID %d,\"\n                    \" QoS %d\",\n                rc, MqttPacket_TypeDesc(resp_type), resp_type, packet_id,\n                packet_qos);\n        #endif\n            if (rc <= 0) {\n            #ifdef WOLFMQTT_MULTITHREAD\n                wm_SemUnlock(&client->lockSend);\n            #endif\n                return rc;\n            }\n            client->packet.buf_len = rc;\n\n            /* Send publish response packet */\n            rc = MqttPacket_Write(client, client->tx_buf,\n                client->packet.buf_len);\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            wm_SemUnlock(&client->lockSend);\n        #endif\n            break;\n        }\n        case MQTT_PACKET_TYPE_PUBLISH_ACK:\n        case MQTT_PACKET_TYPE_PUBLISH_REC:\n        case MQTT_PACKET_TYPE_PUBLISH_REL:\n        case MQTT_PACKET_TYPE_PUBLISH_COMP:\n        {\n            MqttPublishResp pubRespObj, *publish_resp = &pubRespObj;\n            XMEMSET(publish_resp, 0, sizeof(MqttPublishResp));\n\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, publish_resp, &packet_type,\n                &packet_qos, &packet_id);\n            if (rc <= 0) {\n                return rc;\n            }\n\n            /* If publish Received or Release QoS then proceed */\n            if (packet_type != MQTT_PACKET_TYPE_PUBLISH_REC &&\n                packet_type != MQTT_PACKET_TYPE_PUBLISH_REL) {\n                break;\n            }\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Lock send socket mutex */\n            rc = wm_SemLock(&client->lockSend);\n            if (rc != 0) {\n                return rc;\n            }\n        #endif\n\n            /* Encode publish response */\n            publish_resp->packet_id = packet_id;\n            packet_type = (MqttPacketType)((int)packet_type+1); /* next ack */\n        #ifdef WOLFMQTT_V5\n            #ifdef WOLFMQTT_DEBUG_CLIENT\n                PRINTF(\"\\tPublish response: reason code %d, Type %s (%d),\"\n                        \" ID %d, QoS %d\",\n                        publish_resp->reason_code,\n                        MqttPacket_TypeDesc(packet_type),\n                        packet_type, packet_id, packet_qos);\n            #endif\n\n            /* return reason code to caller */\n            if (packet_obj != NULL) {\n                MqttPublishResp* caller_rsp = (MqttPublishResp*)packet_obj;\n                caller_rsp->reason_code = publish_resp->reason_code;\n            }\n\n            /* Publish QoS response needs success reason code,\n             * otherwise will cause disconnect at broker */\n            publish_resp->reason_code = MQTT_REASON_SUCCESS;\n        #endif\n\n            rc = MqttEncode_PublishResp(client->tx_buf, client->tx_buf_len,\n                packet_type, publish_resp);\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d), ID %d,\"\n                    \" QoS %d\",\n                rc, MqttPacket_TypeDesc(packet_type), packet_type, packet_id,\n                packet_qos);\n        #endif\n            if (rc <= 0) {\n            #ifdef WOLFMQTT_MULTITHREAD\n                wm_SemUnlock(&client->lockSend);\n            #endif\n                return rc;\n            }\n            client->packet.buf_len = rc;\n\n            /* Send publish response packet */\n            rc = MqttPacket_Write(client, client->tx_buf,\n                client->packet.buf_len);\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            wm_SemUnlock(&client->lockSend);\n        #endif\n            break;\n        }\n        case MQTT_PACKET_TYPE_SUBSCRIBE_ACK:\n        {\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, packet_obj, &packet_type, &packet_qos,\n                &packet_id);\n            break;\n        }\n        case MQTT_PACKET_TYPE_UNSUBSCRIBE_ACK:\n        {\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, packet_obj, &packet_type, &packet_qos,\n                &packet_id);\n            break;\n        }\n        case MQTT_PACKET_TYPE_PING_RESP:\n        {\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, packet_obj, &packet_type, &packet_qos,\n                &packet_id);\n            break;\n        }\n        case MQTT_PACKET_TYPE_AUTH:\n        {\n        #ifdef WOLFMQTT_V5\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, packet_obj, &packet_type, &packet_qos,\n                &packet_id);\n        #else\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n        #endif\n            break;\n        }\n\n        case MQTT_PACKET_TYPE_DISCONNECT:\n        {\n        #ifdef WOLFMQTT_V5\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, packet_obj, &packet_type, &packet_qos,\n                &packet_id);\n        #else\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n        #endif\n            break;\n        }\n        case MQTT_PACKET_TYPE_CONNECT:\n        case MQTT_PACKET_TYPE_SUBSCRIBE:\n        case MQTT_PACKET_TYPE_UNSUBSCRIBE:\n        case MQTT_PACKET_TYPE_PING_REQ:\n        case MQTT_PACKET_TYPE_ANY:\n        case MQTT_PACKET_TYPE_RESERVED:\n        default:\n            /* these types are only sent from client and should not be sent\n             * by broker */\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n            break;\n    } /* switch (packet_type) */\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    if (rc < 0) {\n        PRINTF(\"MqttClient_HandlePacket: Rc %d, Type %s (%d), QoS %d, ID %d\",\n            rc, MqttPacket_TypeDesc(packet_type), packet_type, packet_qos,\n            packet_id);\n    }\n#endif\n\n    return rc;\n}\n\nstatic int MqttClient_WaitType(MqttClient *client, void *packet_obj,\n    byte wait_type, word16 wait_packet_id, int timeout_ms)\n{\n    int rc;\n    word16 packet_id;\n    MqttPacketType packet_type;\n#ifdef WOLFMQTT_MULTITHREAD\n    MqttPendResp *pendResp;\n    int readLocked;\n#endif\n    MqttMsgStat* mms_stat;\n    int waitMatchFound;\n\n    if (client == NULL || packet_obj == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    /* all packet type structures must have MqttMsgStat at top */\n    mms_stat = (MqttMsgStat*)packet_obj;\n\nwait_again:\n\n    /* initialize variables */\n    packet_id = 0;\n    packet_type = MQTT_PACKET_TYPE_RESERVED;\n#ifdef WOLFMQTT_MULTITHREAD\n    pendResp = NULL;\n    readLocked = 0;\n#endif\n    waitMatchFound = 0;\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"MqttClient_WaitType: Type %s (%d), ID %d\",\n        MqttPacket_TypeDesc((MqttPacketType)wait_type),\n            wait_type, wait_packet_id);\n#endif\n\n    switch ((int)*mms_stat)\n    {\n        case MQTT_MSG_BEGIN:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Lock recv socket mutex */\n            rc = wm_SemLock(&client->lockRecv);\n            if (rc != 0) {\n                PRINTF(\"MqttClient_WaitType: recv lock error!\");\n                return rc;\n            }\n            readLocked = 1;\n        #endif\n\n            /* reset the packet state */\n            client->packet.stat = MQTT_PK_BEGIN;\n        }\n        FALL_THROUGH;\n\n    #ifdef WOLFMQTT_V5\n        case MQTT_MSG_AUTH:\n    #endif\n        case MQTT_MSG_WAIT:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if packet type and id have already completed */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, (MqttPacketType)wait_type, \n                    wait_packet_id, &pendResp)) {\n                    if (pendResp->packetDone) {\n                        /* pending response is already done, so return */\n                        rc = pendResp->packet_ret;\n                    #ifdef WOLFMQTT_DEBUG_CLIENT\n                        PRINTF(\"PendResp already Done %p: Rc %d\", pendResp, rc);\n                    #endif\n                        MqttClient_RespList_Remove(client, pendResp);\n                        wm_SemUnlock(&client->lockClient);\n                        wm_SemUnlock(&client->lockRecv);\n                        return rc;\n                    }\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            *mms_stat = MQTT_MSG_WAIT;\n\n            /* Wait for packet */\n            rc = MqttPacket_Read(client, client->rx_buf, client->rx_buf_len,\n                    timeout_ms);\n            /* handle failure */\n            if (rc <= 0) {\n                break;\n            }\n\n            /* capture length read */\n            client->packet.buf_len = rc;\n\n            /* Decode Packet - get type and id */\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, NULL, &packet_type, NULL, &packet_id);\n            if (rc < 0) {\n                break;\n            }\n\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"Read Packet: Len %d, Type %d, ID %d\",\n                client->packet.buf_len, packet_type, packet_id);\n        #endif\n\n            *mms_stat = MQTT_MSG_READ;\n        }\n        FALL_THROUGH;\n\n        case MQTT_MSG_READ:\n        case MQTT_MSG_READ_PAYLOAD:\n        {\n            MqttPacketType use_packet_type;\n            void* use_packet_obj;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            readLocked = 1; /* if in this state read is locked */\n        #endif\n\n            /* read payload state only happens for publish messages */\n            if (*mms_stat == MQTT_MSG_READ_PAYLOAD) {\n                packet_type = MQTT_PACKET_TYPE_PUBLISH;\n            }\n\n            /* Determine if we received data for this request */\n            if ((wait_type == MQTT_PACKET_TYPE_ANY ||\n                 wait_type == packet_type ||\n                 (MqttIsPubRespPacket(packet_type) &&\n                  MqttIsPubRespPacket(wait_type))) &&\n                (wait_packet_id == 0 || wait_packet_id == packet_id))\n            {\n                use_packet_obj = packet_obj;\n                waitMatchFound = 1;\n            }\n            else {\n                /* use generic packet object */\n                use_packet_obj = &client->msg;\n            }\n            use_packet_type = packet_type;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if we have a pending response for this packet */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, packet_type, packet_id,\n                                                               &pendResp)) {\n                    /* we found packet match this incoming read packet */\n                    pendResp->packetProcessing = 1;\n                    use_packet_obj = pendResp->packet_obj;\n                    use_packet_type = pendResp->packet_type;\n                    /* req from another thread... not a match */\n                    waitMatchFound = 0;\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            /* Perform packet handling for publish callback and QoS */\n            rc = MqttClient_HandlePacket(client, use_packet_type,\n                use_packet_obj, timeout_ms);\n\n        #ifdef WOLFMQTT_NONBLOCK\n            if (rc == MQTT_CODE_CONTINUE) {\n                /* we have received some data, so keep the recv\n                    mutex lock active and return */\n                return rc;\n            }\n        #endif\n\n            /* handle success case */\n            if (rc >= 0) {\n                rc = MQTT_CODE_SUCCESS;\n            }\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (pendResp) {\n                /* Mark pending response entry done */\n                if (wm_SemLock(&client->lockClient) == 0) {\n                    pendResp->packetDone = 1;\n                    pendResp->packet_ret = rc;\n                #ifdef WOLFMQTT_DEBUG_CLIENT\n                    PRINTF(\"PendResp Done %p\", pendResp);\n                #endif\n                    pendResp = NULL;\n                    wm_SemUnlock(&client->lockClient);\n                }\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n            break;\n        }\n\n        case MQTT_MSG_WRITE:\n        case MQTT_MSG_WRITE_PAYLOAD:\n        default:\n        {\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"MqttClient_WaitType: Invalid state %d!\", *mms_stat);\n        #endif\n            rc = MQTT_CODE_ERROR_STAT;\n            break;\n        }\n    } /* switch (*mms_stat) */\n\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc != MQTT_CODE_CONTINUE)\n#endif\n    {\n        /* reset state */\n        *mms_stat = MQTT_MSG_BEGIN;\n    }\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (readLocked) {\n        wm_SemUnlock(&client->lockRecv);\n    }\n#endif\n    if (rc < 0) {\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_WaitType: Failure: %s (%d)\",\n            MqttClient_ReturnCodeToString(rc), rc);\n    #endif\n        return rc;\n    }\n\n    if (!waitMatchFound) {\n        /* if we get here, then the we are still waiting for a packet */\n        goto wait_again;\n    }\n\n    return rc;\n}\n\nint MqttClient_Connect(MqttClient *client, MqttConnect *mc_connect)\n{\n    int rc, len = 0;\n\n    /* Validate required arguments */\n    if (client == NULL || mc_connect == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    if (mc_connect->stat == MQTT_MSG_BEGIN) {\n    #ifdef WOLFMQTT_MULTITHREAD\n        /* Lock send socket mutex */\n        rc = wm_SemLock(&client->lockSend);\n        if (rc != 0) {\n            return rc;\n        }\n    #endif\n\n    #ifdef WOLFMQTT_V5\n        /* Use specified protocol version if set */\n        mc_connect->protocol_level = client->protocol_level;\n    #endif\n\n        /* Encode the connect packet */\n        rc = MqttEncode_Connect(client->tx_buf, client->tx_buf_len, mc_connect);\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d), ID %d, QoS %d\",\n            rc, MqttPacket_TypeDesc(MQTT_PACKET_TYPE_CONNECT),\n            MQTT_PACKET_TYPE_CONNECT, 0, 0);\n    #endif\n        if (rc <= 0) {\n            #ifdef WOLFMQTT_MULTITHREAD\n                wm_SemUnlock(&client->lockSend);\n            #endif\n            return rc;\n        }\n        len = rc;\n\n    #ifdef WOLFMQTT_MULTITHREAD\n        rc = wm_SemLock(&client->lockClient);\n        if (rc == 0) {\n            /* inform other threads of expected response */\n            rc = MqttClient_RespList_Add(client, MQTT_PACKET_TYPE_CONNECT_ACK,\n                    0, &mc_connect->pendResp, &mc_connect->ack);\n            wm_SemUnlock(&client->lockClient);\n        }\n        if (rc != 0) {\n            wm_SemUnlock(&client->lockSend);\n            return rc; /* Error locking client */\n        }\n    #endif\n\n        /* Send connect packet */\n        rc = MqttPacket_Write(client, client->tx_buf, len);\n    #ifdef WOLFMQTT_MULTITHREAD\n        wm_SemUnlock(&client->lockSend);\n    #endif\n        if (rc != len) {\n    #ifdef WOLFMQTT_MULTITHREAD\n            if ((rc != MQTT_CODE_CONTINUE) &&\n                (wm_SemLock(&client->lockClient)) == 0) {\n                MqttClient_RespList_Remove(client, &mc_connect->pendResp);\n                wm_SemUnlock(&client->lockClient);\n            }\n    #endif\n            return rc;\n        }\n    #ifdef WOLFMQTT_V5\n        /* Enhanced authentication */\n        if (client->enable_eauth == 1) {\n            mc_connect->stat = MQTT_MSG_AUTH;\n        }\n        else\n    #endif\n        {\n            mc_connect->stat = MQTT_MSG_WAIT;\n        }\n    }\n\n#ifdef WOLFMQTT_V5\n    /* Enhanced authentication */\n    if (mc_connect->protocol_level > MQTT_CONNECT_PROTOCOL_LEVEL_4 && \n            mc_connect->stat == MQTT_MSG_AUTH)\n    {\n        MqttAuth auth, *p_auth = &auth;\n        MqttProp* prop, *conn_prop;\n\n        /* Find the AUTH property in the connect structure */\n        for (conn_prop = mc_connect->props;\n             (conn_prop != NULL) && (conn_prop->type != MQTT_PROP_AUTH_METHOD);\n             conn_prop = conn_prop->next) {\n        }\n        if (conn_prop == NULL) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (wm_SemLock(&client->lockClient) == 0) {\n                MqttClient_RespList_Remove(client, &mc_connect->pendResp);\n                wm_SemUnlock(&client->lockClient);\n            }\n        #endif\n            /* AUTH property was not set in connect structure */\n            return MQTT_CODE_ERROR_BAD_ARG;\n        }\n\n        XMEMSET((void*)p_auth, 0, sizeof(MqttAuth));\n\n        /* Set the authentication reason */\n        p_auth->reason_code = MQTT_REASON_CONT_AUTH;\n\n        /* Use the same authentication method property from connect */\n        prop = MqttProps_Add(&p_auth->props);\n        prop->type = MQTT_PROP_AUTH_METHOD;\n        prop->data_str.str = conn_prop->data_str.str;\n        prop->data_str.len = conn_prop->data_str.len;\n\n        /* Send the AUTH packet */\n        rc = MqttClient_Auth(client, p_auth);\n        MqttClient_PropsFree(p_auth->props);\n    #ifdef WOLFMQTT_NONBLOCK\n        if (rc == MQTT_CODE_CONTINUE)\n            return rc;\n    #endif\n        if (rc != len) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (wm_SemLock(&client->lockClient) == 0) {\n                MqttClient_RespList_Remove(client, &mc_connect->pendResp);\n                wm_SemUnlock(&client->lockClient);\n            }\n        #endif\n            return rc;\n        }\n    }\n#endif /* WOLFMQTT_V5 */\n\n    /* Wait for connect ack packet */\n    rc = MqttClient_WaitType(client, &mc_connect->ack,\n        MQTT_PACKET_TYPE_CONNECT_ACK, 0, client->cmd_timeout_ms);\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc == MQTT_CODE_CONTINUE)\n        return rc;\n#endif\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (wm_SemLock(&client->lockClient) == 0) {\n        MqttClient_RespList_Remove(client, &mc_connect->pendResp);\n        wm_SemUnlock(&client->lockClient);\n    }\n#endif\n\n    /* reset state */\n    mc_connect->stat = MQTT_MSG_BEGIN;\n\n    return rc;\n}\n\nbool wolfMQTTFuzzer::Initialize(void) {\n    bool ret = false;\n\n    try {\n        /* net */\n        {\n            memset(&net, 0, sizeof(net));\n\n            net.connect = mqtt_connect;\n            net.read = mqtt_recv;\n            net.write = mqtt_write;\n            net.disconnect = mqtt_disconnect;\n            net.context = this;\n        }\n\n        /* client */\n        {\n            memset(&client, 0, sizeof(client));\n\n            tx_size = ds.Get<uint16_t>();\n            tx_size = 4096;\n            tx_buf = (uint8_t*)this->malloc(tx_size);\n            rx_size = ds.Get<uint16_t>();\n            rx_size = 4096;\n            rx_buf = (uint8_t*)this->malloc(rx_size);\n            memset(tx_buf, 0, tx_size);\n            memset(rx_buf, 0, rx_size);\n\n            client.msg_cb = mqtt_message_cb;\n            client.tx_buf = tx_buf;\n            client.tx_buf_len = tx_size;\n            client.rx_buf = rx_buf;\n            client.rx_buf_len = rx_size;\n            client.cmd_timeout_ms = 1000;\n        }\n\n        /* connect */\n        MqttMessage lwt_msg;\n        {\n            memset(&connect, 0, sizeof(connect));\n\n            connect.keep_alive_sec = 1;\n            connect.clean_session = ds.Get<bool>() ? 1 : 0;\n            client_id = ds.Get<std::string>();\n            connect.client_id = client_id.c_str();\n            connect.enable_lwt = ds.Get<bool>() ? 1 : 0;\n        }\n            \n        std::string lwt_topic_name;\n        std::vector<uint8_t> lwt_buffer;\n\n        if ( connect.enable_lwt ) {\n            lwt_topic_name = ds.Get<std::string>();\n            lwt_buffer = ds.GetData(0);\n\n            connect.lwt_msg = &lwt_msg;\n            lwt_msg.qos = GetQoS();\n            lwt_msg.retain = ds.Get<bool>() ? 1 : 0;\n            lwt_msg.topic_name = lwt_topic_name.c_str();\n            lwt_msg.buffer = lwt_buffer.data();\n            lwt_msg.total_len = lwt_buffer.size();\n        }\n\n        CHECK_EQ(MqttSocket_Init(&client, &net), MQTT_CODE_SUCCESS);\n\n#if 0\n        if ( ds.Get<bool>() ) {\n            //CHECK_EQ(MqttClient_SetPropertyCallback(&client, mqtt_property_cb, NULL);\n        }\n#endif\n\n        CHECK_EQ(MqttClient_NetConnect(&client, \"dummy\", 12345, 1000, 0, NULL), MQTT_CODE_SUCCESS);\n        CHECK_EQ(MqttClient_Connect(&client, &connect), MQTT_CODE_SUCCESS);\n\n        ret = true;\n\n    } catch ( ... ) {\n        return false;\n    }\n\nend:\n    return ret;\n}\n\n\n// target function\nstatic int MqttClient_WaitType(MqttClient *client, void *packet_obj,\n    byte wait_type, word16 wait_packet_id, int timeout_ms)\n{\n    int rc;\n    word16 packet_id;\n    MqttPacketType packet_type;\n#ifdef WOLFMQTT_MULTITHREAD\n    MqttPendResp *pendResp;\n    int readLocked;\n#endif\n    MqttMsgStat* mms_stat;\n    int waitMatchFound;\n\n    if (client == NULL || packet_obj == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    /* all packet type structures must have MqttMsgStat at top */\n    mms_stat = (MqttMsgStat*)packet_obj;\n\nwait_again:\n\n    /* initialize variables */\n    packet_id = 0;\n    packet_type = MQTT_PACKET_TYPE_RESERVED;\n#ifdef WOLFMQTT_MULTITHREAD\n    pendResp = NULL;\n    readLocked = 0;\n#endif\n    waitMatchFound = 0;\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"MqttClient_WaitType: Type %s (%d), ID %d\",\n        MqttPacket_TypeDesc((MqttPacketType)wait_type),\n            wait_type, wait_packet_id);\n#endif\n\n    switch ((int)*mms_stat)\n    {\n        case MQTT_MSG_BEGIN:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Lock recv socket mutex */\n            rc = wm_SemLock(&client->lockRecv);\n            if (rc != 0) {\n                PRINTF(\"MqttClient_WaitType: recv lock error!\");\n                return rc;\n            }\n            readLocked = 1;\n        #endif\n\n            /* reset the packet state */\n            client->packet.stat = MQTT_PK_BEGIN;\n        }\n        FALL_THROUGH;\n\n    #ifdef WOLFMQTT_V5\n        case MQTT_MSG_AUTH:\n    #endif\n        case MQTT_MSG_WAIT:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if packet type and id have already completed */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, (MqttPacketType)wait_type, \n                    wait_packet_id, &pendResp)) {\n                    if (pendResp->packetDone) {\n                        /* pending response is already done, so return */\n                        rc = pendResp->packet_ret;\n                    #ifdef WOLFMQTT_DEBUG_CLIENT\n                        PRINTF(\"PendResp already Done %p: Rc %d\", pendResp, rc);\n                    #endif\n                        MqttClient_RespList_Remove(client, pendResp);\n                        wm_SemUnlock(&client->lockClient);\n                        wm_SemUnlock(&client->lockRecv);\n                        return rc;\n                    }\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            *mms_stat = MQTT_MSG_WAIT;\n\n            /* Wait for packet */\n            rc = MqttPacket_Read(client, client->rx_buf, client->rx_buf_len,\n                    timeout_ms);\n            /* handle failure */\n            if (rc <= 0) {\n                break;\n            }\n\n            /* capture length read */\n            client->packet.buf_len = rc;\n\n            /* Decode Packet - get type and id */\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, NULL, &packet_type, NULL, &packet_id);\n            if (rc < 0) {\n                break;\n            }\n\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"Read Packet: Len %d, Type %d, ID %d\",\n                client->packet.buf_len, packet_type, packet_id);\n        #endif\n\n            *mms_stat = MQTT_MSG_READ;\n        }\n        FALL_THROUGH;\n\n        case MQTT_MSG_READ:\n        case MQTT_MSG_READ_PAYLOAD:\n        {\n            MqttPacketType use_packet_type;\n            void* use_packet_obj;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            readLocked = 1; /* if in this state read is locked */\n        #endif\n\n            /* read payload state only happens for publish messages */\n            if (*mms_stat == MQTT_MSG_READ_PAYLOAD) {\n                packet_type = MQTT_PACKET_TYPE_PUBLISH;\n            }\n\n            /* Determine if we received data for this request */\n            if ((wait_type == MQTT_PACKET_TYPE_ANY ||\n                 wait_type == packet_type ||\n                 MqttIsPubRespPacket(packet_type) == MqttIsPubRespPacket(wait_type)) &&\n               (wait_packet_id == 0 || wait_packet_id == packet_id))\n            {\n                use_packet_obj = packet_obj;\n                waitMatchFound = 1;\n            }\n            else {\n                /* use generic packet object */\n                use_packet_obj = &client->msg;\n            }\n            use_packet_type = packet_type;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if we have a pending response for this packet */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, packet_type, packet_id,\n                                                               &pendResp)) {\n                    /* we found packet match this incoming read packet */\n                    pendResp->packetProcessing = 1;\n                    use_packet_obj = pendResp->packet_obj;\n                    use_packet_type = pendResp->packet_type;\n                    /* req from another thread... not a match */\n                    waitMatchFound = 0;\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            /* Perform packet handling for publish callback and QoS */\n            rc = MqttClient_HandlePacket(client, use_packet_type,\n                use_packet_obj, timeout_ms);\n\n        #ifdef WOLFMQTT_NONBLOCK\n            if (rc == MQTT_CODE_CONTINUE) {\n                /* we have received some data, so keep the recv\n                    mutex lock active and return */\n                return rc;\n            }\n        #endif\n\n            /* handle success case */\n            if (rc >= 0) {\n                rc = MQTT_CODE_SUCCESS;\n            }\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (pendResp) {\n                /* Mark pending response entry done */\n                if (wm_SemLock(&client->lockClient) == 0) {\n                    pendResp->packetDone = 1;\n                    pendResp->packet_ret = rc;\n                #ifdef WOLFMQTT_DEBUG_CLIENT\n                    PRINTF(\"PendResp Done %p\", pendResp);\n                #endif\n                    pendResp = NULL;\n                    wm_SemUnlock(&client->lockClient);\n                }\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n            break;\n        }\n\n        case MQTT_MSG_WRITE:\n        case MQTT_MSG_WRITE_PAYLOAD:\n        default:\n        {\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"MqttClient_WaitType: Invalid state %d!\", *mms_stat);\n        #endif\n            rc = MQTT_CODE_ERROR_STAT;\n            break;\n        }\n    } /* switch (*mms_stat) */\n\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc != MQTT_CODE_CONTINUE)\n#endif\n    {\n        /* reset state */\n        *mms_stat = MQTT_MSG_BEGIN;\n    }\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (readLocked) {\n        wm_SemUnlock(&client->lockRecv);\n    }\n#endif\n    if (rc < 0) {\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_WaitType: Failure: %s (%d)\",\n            MqttClient_ReturnCodeToString(rc), rc);\n    #endif\n        return rc;\n    }\n\n    if (!waitMatchFound) {\n        /* if we get here, then the we are still waiting for a packet */\n        goto wait_again;\n    }\n\n    return rc;\n}\n",
    "target": 1,
    "idx": 1038237,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nAFL_GCC_POP\n\nstatic int\njson_header_write (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  int error = 0;\n  RECORD (HEADER); // single hash\n  // separate funcs to catch the return, and end with ENDRECORD\n  PRE (R_13b1)\n    error = json_preR13_header_write_private (dat, dwg);\n  LATER_VERSIONS\n    error = json_header_write_private (dat, dwg);\n  ENDRECORD ();\n  return error;\n}\n\nEXPORT int\ndwg_write_json (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  const int minimal = dwg->opts & DWG_OPTS_MINIMAL;\n  Dwg_Header *obj = &dwg->header;\n  int error = 0;\n\n  fprintf (dat->fh, \"{\\n  \\\"created_by\\\": \\\"%s\\\"\", PACKAGE_STRING);\n  dat->bit++; // ident\n\n  if (!minimal)\n    {\n      json_fileheader_write (dat, dwg);\n    }\n\n  // A minimal HEADER requires only $ACADVER, $HANDSEED, and then ENTITIES\n  json_header_write (dat, dwg);\n\n  if (!minimal && dat->version >= R_13b1)\n    {\n      if (json_classes_write (dat, dwg) >= DWG_ERR_CRITICAL)\n        goto fail;\n    }\n  if (!minimal && dat->version < R_13b1 && 0)\n    {\n      if (json_tables_write (dat, dwg) >= DWG_ERR_CRITICAL)\n        goto fail;\n    }\n\n  if (json_objects_write (dat, dwg) >= DWG_ERR_CRITICAL)\n    goto fail;\n\n  if (!minimal && dat->version >= R_13b1)\n    {\n      if (json_thumbnail_write (dat, dwg) >= DWG_ERR_CRITICAL)\n        goto fail;\n      /* the other sections */\n      if (dat->version <= R_2000)\n        {\n          error |= json_section_template (dat, dwg); // i.e. MEASUREMENT\n          error |= json_section_auxheader (dat, dwg);\n          //error |= json_section_2ndheader (dat, dwg);\n        }\n      if (dat->version >= R_2004)\n        {\n          error |= json_section_r2004fileheader (dat, dwg);\n          if (dwg->header.summaryinfo_address)\n            error |= json_section_summary (dat, dwg);\n          if (dwg->header.vbaproj_address)\n            error |= json_section_vbaproject (dat, dwg);\n          error |= json_section_appinfo (dat, dwg);\n          error |= json_section_appinfohistory (dat, dwg);\n          error |= json_section_filedeplist (dat, dwg);\n          error |= json_section_security (dat, dwg);\n          error |= json_section_revhistory (dat, dwg);\n          error |= json_section_objfreespace (dat, dwg);\n          //error |= json_section_signature (dat, dwg);\n          error |= json_section_template (dat, dwg);\n          error |= json_section_acds (dat, dwg);\n        }\n    }\n\n#if 0\n  /* object map */\n  if (!minimal && dat->version >= R_13b1)\n    {\n      if (json_handles_write (dat, dwg) >= DWG_ERR_CRITICAL)\n        goto fail;\n    }\n#endif\n\n  dat->bit--;\n  fprintf (dat->fh, \"}\\n\");\n  return 0;\nfail:\n  return 1;\n}\n\n\n// target function\nint\ndecode_preR13_entities (BITCODE_RL start, BITCODE_RL end,\n                        unsigned num_entities, BITCODE_RL size,\n                        BITCODE_RL blocks_max, Bit_Chain *restrict dat,\n                        Dwg_Data *restrict dwg)\n{\n  int error = 0;\n  BITCODE_BL num = dwg->num_objects;\n  unsigned long oldpos = dat->byte;\n\n  dat->bit = 0;\n  LOG_TRACE (\"\\n%sentities: (\" FORMAT_RLx \"-\" FORMAT_RLx \" (%u), size \" FORMAT_RL \", 0x%x)\\n\",\n             blocks_max != (BITCODE_RL)0 ? \"block \" : \"\", start, end, num_entities,\n             size, blocks_max);\n  LOG_INFO (\"==========================================\\n\");\n  if (end != 0 && start == end)\n    // with empty entities, ignore num_entities as they include block ents\n    return 0;\n  if (end == 0 && size == 0) // empty blocks\n    return 0;\n  while (dat->byte < oldpos + end)\n    {\n      Dwg_Object *obj;\n      Dwg_Object_Entity *ent, *_ent;\n      BITCODE_RS type, crc;\n\n      if (!num)\n        dwg->object\n          = (Dwg_Object *)calloc (REFS_PER_REALLOC, sizeof (Dwg_Object));\n      else if (num >= dwg->num_alloced_objects)\n        {\n          while (num >= dwg->num_alloced_objects)\n            dwg->num_alloced_objects *= 2;\n          dwg->object = (Dwg_Object *)realloc (\n              dwg->object, dwg->num_alloced_objects * sizeof (Dwg_Object));\n          LOG_TRACE (\"REALLOC dwg->object vector to %u\\n\", dwg->num_alloced_objects)\n          dwg->dirty_refs = 1;\n        }\n      if (!dwg->object)\n        {\n          LOG_ERROR (\"Out of memory\");\n          return DWG_ERR_OUTOFMEM;\n        }\n      obj = &dwg->object[num];\n      memset (obj, 0, sizeof (Dwg_Object));\n      dwg->num_objects++;\n      obj->index = num;\n      obj->parent = dwg;\n      obj->address = dat->byte;\n      obj->supertype = DWG_SUPERTYPE_ENTITY;\n\n      PRE (R_2_0b)\n        {\n          type = bit_read_RS (dat);\n          obj->type = (BITCODE_RC)type;\n          LOG_TRACE (\"type: \" FORMAT_RS \" [RS]\\n\", type);\n          if (type > 127) // deleted. moved into BLOCK\n            type = abs ((int8_t)obj->type);\n        }\n      else\n        {\n          obj->type = bit_read_RC (dat);\n          LOG_TRACE (\"type: \" FORMAT_RCd \" [RCd]\\n\", obj->type);\n          type = obj->type & 0x7F;\n        }\n\n      switch (type)\n        {\n        case 1:\n          error |= dwg_decode_LINE (dat, obj);\n          break;\n        case 2:\n          error |= dwg_decode_POINT (dat, obj);\n          break;\n        case 3:\n          error |= dwg_decode_CIRCLE (dat, obj);\n          break;\n        case 4:\n          error |= dwg_decode_SHAPE (dat, obj);\n          break;\n        case 5:\n          error |= dwg_decode_REPEAT (dat, obj);\n          break;\n        case 6:\n          error |= dwg_decode_ENDREP (dat, obj);\n          break;\n        case 7:\n          error |= dwg_decode_TEXT (dat, obj);\n          break;\n        case 8:\n          error |= dwg_decode_ARC (dat, obj);\n          break;\n        case 9:\n          error |= dwg_decode_TRACE (dat, obj);\n          break;\n        case 10:\n          error |= dwg_decode_LOAD (dat, obj);\n          break;\n        case 11:\n          error |= dwg_decode_SOLID (dat, obj);\n          break;\n        case 12:\n          error |= dwg_decode_BLOCK (dat, obj);\n          break;\n        case 13:\n          error |= dwg_decode_ENDBLK (dat, obj);\n          break;\n        case 14:\n          error |= dwg_decode_INSERT (dat, obj);\n          break;\n        case 15:\n          error |= dwg_decode_ATTDEF (dat, obj);\n          break;\n        case 16:\n          error |= dwg_decode_ATTRIB (dat, obj);\n          break;\n        case 17:\n          error |= dwg_decode_SEQEND (dat, obj);\n          break;\n        case 18: /* another polyline */\n        case 19:\n          { // which polyline\n            BITCODE_RC flag;\n            dat->byte += 5;\n            flag = bit_read_RC (dat);\n            dat->byte -= 6;\n            if (flag & 8)\n              error |= dwg_decode_POLYLINE_3D (dat, obj);\n            else if (flag & 16)\n              error |= dwg_decode_POLYLINE_MESH (dat, obj);\n            else if (flag & 64)\n              error |= dwg_decode_POLYLINE_PFACE (dat, obj);\n            else\n              error |= dwg_decode_POLYLINE_2D (dat, obj);\n          }\n          break;\n        case 20:\n          { // which vertex?\n            BITCODE_RC flag;\n            dat->byte += 5;\n            flag = bit_read_RC (dat);\n            dat->byte -= 6;\n            if (flag & 32)\n              error |= dwg_decode_VERTEX_3D (dat, obj);\n            else if (flag & 64 && !(flag & 128))\n              error |= dwg_decode_VERTEX_MESH (dat, obj);\n            else if (flag & (64 + 128))\n              error |= dwg_decode_VERTEX_PFACE (dat, obj);\n            else if (flag & 128 && !(flag & 64))\n              error |= dwg_decode_VERTEX_PFACE_FACE (dat, obj);\n            else\n              error |= dwg_decode_VERTEX_2D (dat, obj);\n          }\n          break;\n        case 21:\n          error |= dwg_decode__3DLINE (dat, obj);\n          break;\n        case 22:\n          error |= dwg_decode__3DFACE (dat, obj);\n          break;\n        case 23:\n          error |= decode_preR13_DIMENSION (dat, obj);\n          break;\n        case 24:\n          error |= dwg_decode_VIEWPORT (dat, obj);\n          break;\n        /*\n        case 25:\n          error |= dwg_decode_3DLINE (dat, obj);\n          break;\n        */\n        default:\n          dat->byte--;\n\t  DEBUG_HERE;\n          LOG_ERROR (\"Unknown object type %d\", type);\n          error |= DWG_ERR_SECTIONNOTFOUND;\n          break;\n        }\n\n      assert (!dat->bit);\n      PRE (R_2_0b)\n      {\n        obj->size = dat->byte - oldpos;\n        oldpos = dat->byte;\n        if (obj->type > 127) // deleted\n          {\n            obj->fixedtype = DWG_TYPE_UNUSED;\n            dwg->num_entities--; // for stats only\n          }\n        if (num + 1 > dwg->num_objects)\n          break;\n      }\n      SINCE (R_2_0b) // Pre R_2_0 doesn't contain size of entity\n      {\n        PRE (R_11) // no crc16\n        {\n          if (obj->address + obj->size != dat->byte)\n            {\n              LOG_ERROR (\"offset %ld\", obj->address + obj->size - dat->byte);\n              dat->byte = obj->address + obj->size;\n            }\n        }\n        LATER_VERSIONS\n        {\n          if (obj->address + obj->size != dat->byte + 2)\n            {\n              LOG_ERROR (\"offset %ld\", obj->address + obj->size - (dat->byte + 2));\n              dat->byte = obj->address + obj->size - 2;\n            }\n          crc = bit_read_RS (dat);\n          LOG_TRACE (\"crc: %04X [RSx]\\n\", crc);\n        }\n      }\n      LOG_TRACE (\"\\n\");\n      num++;\n\n      if (end > 0 && dat->byte >= end)\n        {\n          if (size == 0 && blocks_max != 0) // else we just loop until end with wrong num\n            {\n              LOG_ERROR (\"overflow with wrong blocks num_entities 0x%lx > 0x%x, %u\",\n                         dat->byte, end, num_entities);\n              error |= DWG_ERR_SECTIONNOTFOUND;\n            }\n          dat->byte = end;\n          return error;\n        }\n      SINCE (R_2_0b) {\n        if (obj->size < 2 || obj->size > 0x1000)// FIXME\n          {\n            LOG_ERROR (\"wrong obj->size %u\", obj->size);\n            error |= DWG_ERR_SECTIONNOTFOUND;\n            if (end)\n              dat->byte = end;\n          }\n      }\n    }\n\n  if (end)\n    dat->byte = end;\n  return error;\n}\n",
    "target": 1,
    "idx": 1054625,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic float make_unnormalized_half_kernel(float* halfKernel, int halfKernelSize, float sigma) {\n    const float invSigma = 1.f / sigma;\n    const float b = -0.5f * invSigma * invSigma;\n    float tot = 0.0f;\n    // Compute half kernel values at half pixel steps out from the center.\n    float t = 0.5f;\n    for (int i = 0; i < halfKernelSize; ++i) {\n        float value = expf(t * t * b);\n        tot += value;\n        halfKernel[i] = value;\n        t += 1.f;\n    }\n    return tot;\n}\n\nstatic void make_half_kernel_and_summed_table(float* halfKernel,\n                                              float* summedHalfKernel,\n                                              int halfKernelSize,\n                                              float sigma) {\n    // The half kernel should sum to 0.5 not 1.0.\n    const float tot = 2.f * make_unnormalized_half_kernel(halfKernel, halfKernelSize, sigma);\n    float sum = 0.f;\n    for (int i = 0; i < halfKernelSize; ++i) {\n        halfKernel[i] /= tot;\n        sum += halfKernel[i];\n        summedHalfKernel[i] = sum;\n    }\n}\n\nstatic void create_circle_profile(uint8_t* weights,\n                                  float sigma,\n                                  float circleR,\n                                  int profileTextureWidth) {\n    const int numSteps = profileTextureWidth;\n\n    // The full kernel is 6 sigmas wide.\n    int halfKernelSize = SkScalarCeilToInt(6.0f * sigma);\n    // round up to next multiple of 2 and then divide by 2\n    halfKernelSize = ((halfKernelSize + 1) & ~1) >> 1;\n\n    // Number of x steps at which to apply kernel in y to cover all the profile samples in x.\n    int numYSteps = numSteps + 2 * halfKernelSize;\n\n    SkAutoTArray<float> bulkAlloc(halfKernelSize + halfKernelSize + numYSteps);\n    float* halfKernel = bulkAlloc.get();\n    float* summedKernel = bulkAlloc.get() + halfKernelSize;\n    float* yEvals = bulkAlloc.get() + 2 * halfKernelSize;\n    make_half_kernel_and_summed_table(halfKernel, summedKernel, halfKernelSize, sigma);\n\n    float firstX = -halfKernelSize + 0.5f;\n    apply_kernel_in_y(yEvals, numYSteps, firstX, circleR, halfKernelSize, summedKernel);\n\n    for (int i = 0; i < numSteps - 1; ++i) {\n        float evalX = i + 0.5f;\n        weights[i] = eval_at(evalX, circleR, halfKernel, halfKernelSize, yEvals + i);\n    }\n    // Ensure the tail of the Gaussian goes to zero.\n    weights[numSteps - 1] = 0;\n}\n\nstatic std::unique_ptr<GrFragmentProcessor> create_profile_effect(GrRecordingContext* rContext,\n                                                                  const SkRect& circle,\n                                                                  float sigma,\n                                                                  float* solidRadius,\n                                                                  float* textureRadius) {\n    float circleR = circle.width() / 2.0f;\n    if (!sk_float_isfinite(circleR) || circleR < SK_ScalarNearlyZero) {\n        return nullptr;\n    }\n\n    auto threadSafeCache = rContext->priv().threadSafeCache();\n\n    // Profile textures are cached by the ratio of sigma to circle radius and by the size of the\n    // profile texture (binned by powers of 2).\n    SkScalar sigmaToCircleRRatio = sigma / circleR;\n    // When sigma is really small this becomes a equivalent to convolving a Gaussian with a\n    // half-plane. Similarly, in the extreme high ratio cases circle becomes a point WRT to the\n    // Guassian and the profile texture is a just a Gaussian evaluation. However, we haven't yet\n    // implemented this latter optimization.\n    sigmaToCircleRRatio = std::min(sigmaToCircleRRatio, 8.f);\n    SkFixed sigmaToCircleRRatioFixed;\n    static const SkScalar kHalfPlaneThreshold = 0.1f;\n    bool useHalfPlaneApprox = false;\n    if (sigmaToCircleRRatio <= kHalfPlaneThreshold) {\n        useHalfPlaneApprox = true;\n        sigmaToCircleRRatioFixed = 0;\n        *solidRadius = circleR - 3 * sigma;\n        *textureRadius = 6 * sigma;\n    } else {\n        // Convert to fixed point for the key.\n        sigmaToCircleRRatioFixed = SkScalarToFixed(sigmaToCircleRRatio);\n        // We shave off some bits to reduce the number of unique entries. We could probably\n        // shave off more than we do.\n        sigmaToCircleRRatioFixed &= ~0xff;\n        sigmaToCircleRRatio = SkFixedToScalar(sigmaToCircleRRatioFixed);\n        sigma = circleR * sigmaToCircleRRatio;\n        *solidRadius = 0;\n        *textureRadius = circleR + 3 * sigma;\n    }\n\n    static constexpr int kProfileTextureWidth = 512;\n    // This would be kProfileTextureWidth/textureRadius if it weren't for the fact that we do\n    // the calculation of the profile coord in a coord space that has already been scaled by\n    // 1 / textureRadius. This is done to avoid overflow in length().\n    SkMatrix texM = SkMatrix::Scale(kProfileTextureWidth, 1.f);\n\n    static const GrUniqueKey::Domain kDomain = GrUniqueKey::GenerateDomain();\n    GrUniqueKey key;\n    GrUniqueKey::Builder builder(&key, kDomain, 1, \"1-D Circular Blur\");\n    builder[0] = sigmaToCircleRRatioFixed;\n    builder.finish();\n\n    GrSurfaceProxyView profileView = threadSafeCache->find(key);\n    if (profileView) {\n        SkASSERT(profileView.asTextureProxy());\n        SkASSERT(profileView.origin() == kTopLeft_GrSurfaceOrigin);\n        return GrTextureEffect::Make(std::move(profileView), kPremul_SkAlphaType, texM);\n    }\n\n    SkBitmap bm;\n    if (!bm.tryAllocPixels(SkImageInfo::MakeA8(kProfileTextureWidth, 1))) {\n        return nullptr;\n    }\n\n    if (useHalfPlaneApprox) {\n        create_half_plane_profile(bm.getAddr8(0, 0), kProfileTextureWidth);\n    } else {\n        // Rescale params to the size of the texture we're creating.\n        SkScalar scale = kProfileTextureWidth / *textureRadius;\n        create_circle_profile(bm.getAddr8(0, 0), sigma * scale, circleR * scale,\n                              kProfileTextureWidth);\n    }\n\n    bm.setImmutable();\n\n    GrBitmapTextureMaker maker(rContext, bm, GrImageTexGenPolicy::kNew_Uncached_Budgeted);\n    profileView = maker.view(GrMipmapped::kNo);\n    if (!profileView) {\n        return nullptr;\n    }\n\n    profileView = threadSafeCache->add(key, profileView);\n    return GrTextureEffect::Make(std::move(profileView), kPremul_SkAlphaType, texM);\n}\n\nstd::unique_ptr<GrFragmentProcessor> GrCircleBlurFragmentProcessor::Make(\n        std::unique_ptr<GrFragmentProcessor> inputFP,\n        GrRecordingContext* context,\n        const SkRect& circle,\n        float sigma) {\n    if (SkGpuBlurUtils::IsEffectivelyZeroSigma(sigma)) {\n        return inputFP;\n    }\n\n    float solidRadius;\n    float textureRadius;\n    std::unique_ptr<GrFragmentProcessor> profile =\n            create_profile_effect(context, circle, sigma, &solidRadius, &textureRadius);\n    if (!profile) {\n        return nullptr;\n    }\n    return std::unique_ptr<GrFragmentProcessor>(new GrCircleBlurFragmentProcessor(\n            std::move(inputFP), circle, solidRadius, textureRadius, std::move(profile)));\n}\n\nbool SkBlurMaskFilterImpl::directFilterMaskGPU(GrRecordingContext* context,\n                                               GrSurfaceDrawContext* surfaceDrawContext,\n                                               GrPaint&& paint,\n                                               const GrClip* clip,\n                                               const SkMatrix& viewMatrix,\n                                               const GrStyledShape& shape) const {\n    SkASSERT(surfaceDrawContext);\n\n    if (fBlurStyle != kNormal_SkBlurStyle) {\n        return false;\n    }\n\n    // TODO: we could handle blurred stroked circles\n    if (!shape.style().isSimpleFill()) {\n        return false;\n    }\n\n    SkScalar xformedSigma = this->computeXformedSigma(viewMatrix);\n    if (SkGpuBlurUtils::IsEffectivelyZeroSigma(xformedSigma)) {\n        surfaceDrawContext->drawShape(clip, std::move(paint), GrAA::kYes, viewMatrix, shape);\n        return true;\n    }\n\n    SkRRect srcRRect;\n    bool inverted;\n    if (!shape.asRRect(&srcRRect, nullptr, nullptr, &inverted) || inverted) {\n        return false;\n    }\n\n    std::unique_ptr<GrFragmentProcessor> fp;\n\n    SkRRect devRRect;\n    bool devRRectIsValid = srcRRect.transform(viewMatrix, &devRRect);\n\n    bool devRRectIsCircle = devRRectIsValid && SkRRectPriv::IsCircle(devRRect);\n\n    bool canBeRect = srcRRect.isRect() && viewMatrix.preservesRightAngles();\n    bool canBeCircle = (SkRRectPriv::IsCircle(srcRRect) && viewMatrix.isSimilarity()) ||\n                       devRRectIsCircle;\n\n    if (canBeRect || canBeCircle) {\n        if (canBeRect) {\n            fp = GrRectBlurEffect::Make(\n                    /*inputFP=*/nullptr, context, *context->priv().caps()->shaderCaps(),\n                    srcRRect.rect(), viewMatrix, xformedSigma);\n        } else {\n            SkRect devBounds;\n            if (devRRectIsCircle) {\n                devBounds = devRRect.getBounds();\n            } else {\n                SkPoint center = {srcRRect.getBounds().centerX(), srcRRect.getBounds().centerY()};\n                viewMatrix.mapPoints(&center, 1);\n                SkScalar radius = viewMatrix.mapVector(0, srcRRect.width()/2.f).length();\n                devBounds = {center.x() - radius,\n                             center.y() - radius,\n                             center.x() + radius,\n                             center.y() + radius};\n            }\n            fp = GrCircleBlurFragmentProcessor::Make(/*inputFP=*/nullptr, context, devBounds,\n                                                     xformedSigma);\n        }\n\n        if (!fp) {\n            return false;\n        }\n        paint.setCoverageFragmentProcessor(std::move(fp));\n\n        SkRect srcProxyRect = srcRRect.rect();\n        // Determine how much to outset the src rect to ensure we hit pixels within three sigma.\n        SkScalar outsetX = 3.0f*xformedSigma;\n        SkScalar outsetY = 3.0f*xformedSigma;\n        if (viewMatrix.isScaleTranslate()) {\n            outsetX /= SkScalarAbs(viewMatrix.getScaleX());\n            outsetY /= SkScalarAbs(viewMatrix.getScaleY());\n        } else {\n            SkSize scale;\n            if (!viewMatrix.decomposeScale(&scale, nullptr)) {\n                return false;\n            }\n            outsetX /= scale.width();\n            outsetY /= scale.height();\n        }\n        srcProxyRect.outset(outsetX, outsetY);\n\n        surfaceDrawContext->drawRect(clip, std::move(paint), GrAA::kNo, viewMatrix, srcProxyRect);\n        return true;\n    }\n    if (!viewMatrix.isScaleTranslate()) {\n        return false;\n    }\n    if (!devRRectIsValid || !SkRRectPriv::AllCornersCircular(devRRect)) {\n        return false;\n    }\n\n    fp = GrRRectBlurEffect::Make(/*inputFP=*/nullptr, context, fSigma, xformedSigma,\n                                 srcRRect, devRRect);\n    if (!fp) {\n        return false;\n    }\n\n    if (!this->ignoreXform()) {\n        SkRect srcProxyRect = srcRRect.rect();\n        srcProxyRect.outset(3.0f*fSigma, 3.0f*fSigma);\n\n        SkVertices::Builder builder(SkVertices::kTriangles_VertexMode, 4, 6, 0);\n        srcProxyRect.toQuad(builder.positions());\n\n        static const uint16_t fullIndices[6] = { 0, 1, 2, 0, 2, 3 };\n        memcpy(builder.indices(), fullIndices, sizeof(fullIndices));\n        sk_sp<SkVertices> vertices = builder.detach();\n\n        paint.setCoverageFragmentProcessor(std::move(fp));\n        SkSimpleMatrixProvider matrixProvider(viewMatrix);\n        surfaceDrawContext->drawVertices(clip, std::move(paint), matrixProvider,\n                                         std::move(vertices));\n    } else {\n        SkMatrix inverse;\n        if (!viewMatrix.invert(&inverse)) {\n            return false;\n        }\n\n        float extra=3.f*SkScalarCeilToScalar(xformedSigma-1/6.0f);\n        SkRect proxyRect = devRRect.rect();\n        proxyRect.outset(extra, extra);\n\n        paint.setCoverageFragmentProcessor(std::move(fp));\n        surfaceDrawContext->fillRectWithLocalMatrix(clip, std::move(paint), GrAA::kNo,\n                                                    SkMatrix::I(), proxyRect, inverse);\n    }\n\n    return true;\n}\n\nstatic void draw_shape_with_mask_filter(GrRecordingContext* rContext,\n                                        GrSurfaceDrawContext* surfaceDrawContext,\n                                        const GrClip* clip,\n                                        GrPaint&& paint,\n                                        const SkMatrix& viewMatrix,\n                                        const SkMaskFilterBase* maskFilter,\n                                        const GrStyledShape& origShape) {\n    SkASSERT(maskFilter);\n\n    const GrStyledShape* shape = &origShape;\n    SkTLazy<GrStyledShape> tmpShape;\n\n    if (origShape.style().applies()) {\n        SkScalar styleScale =  GrStyle::MatrixToScaleFactor(viewMatrix);\n        if (0 == styleScale) {\n            return;\n        }\n\n        tmpShape.init(origShape.applyStyle(GrStyle::Apply::kPathEffectAndStrokeRec, styleScale));\n        if (tmpShape->isEmpty()) {\n            return;\n        }\n\n        shape = tmpShape.get();\n    }\n\n    if (maskFilter->directFilterMaskGPU(rContext, surfaceDrawContext, std::move(paint), clip,\n                                        viewMatrix, *shape)) {\n        // the mask filter was able to draw itself directly, so there's nothing\n        // left to do.\n        return;\n    }\n    assert_alive(paint);\n\n    // If the path is hairline, ignore inverse fill.\n    bool inverseFilled = shape->inverseFilled() &&\n                         !GrPathRenderer::IsStrokeHairlineOrEquivalent(shape->style(),\n                                                                       viewMatrix, nullptr);\n\n    SkIRect unclippedDevShapeBounds, devClipBounds;\n    if (!get_shape_and_clip_bounds(surfaceDrawContext, clip, *shape, viewMatrix,\n                                   &unclippedDevShapeBounds, &devClipBounds)) {\n        // TODO: just cons up an opaque mask here\n        if (!inverseFilled) {\n            return;\n        }\n    }\n\n    GrUniqueKey maskKey;\n    SkIRect boundsForClip;\n    if (!compute_key_and_clip_bounds(&maskKey, &boundsForClip,\n                                     surfaceDrawContext->caps(),\n                                     viewMatrix, inverseFilled,\n                                     maskFilter, *shape,\n                                     unclippedDevShapeBounds,\n                                     devClipBounds)) {\n        return; // 'shape' was entirely clipped out\n    }\n\n    GrSurfaceProxyView filteredMaskView;\n    SkIRect maskRect;\n\n    if (auto dContext = rContext->asDirectContext()) {\n        filteredMaskView = hw_create_filtered_mask(dContext, surfaceDrawContext,\n                                                   viewMatrix, *shape, maskFilter,\n                                                   unclippedDevShapeBounds, boundsForClip,\n                                                   &maskRect, &maskKey);\n        if (filteredMaskView) {\n            if (draw_mask(surfaceDrawContext, clip, viewMatrix, maskRect, std::move(paint),\n                          std::move(filteredMaskView))) {\n                // This path is completely drawn\n                return;\n            }\n            assert_alive(paint);\n        }\n    }\n\n    // Either HW mask rendering failed or we're in a DDL recording thread\n    filteredMaskView = sw_create_filtered_mask(rContext,\n                                               viewMatrix, *shape, maskFilter,\n                                               unclippedDevShapeBounds, boundsForClip,\n                                               &maskRect, &maskKey);\n    if (filteredMaskView) {\n        if (draw_mask(surfaceDrawContext, clip, viewMatrix, maskRect, std::move(paint),\n                      std::move(filteredMaskView))) {\n            return;\n        }\n        assert_alive(paint);\n    }\n}\n\nvoid GrBlurUtils::drawShapeWithMaskFilter(GrRecordingContext* context,\n                                          GrSurfaceDrawContext* surfaceDrawContext,\n                                          const GrClip* clip,\n                                          const SkPaint& paint,\n                                          const SkMatrixProvider& matrixProvider,\n                                          const GrStyledShape& shape) {\n    if (context->abandoned()) {\n        return;\n    }\n\n    GrPaint grPaint;\n    if (!SkPaintToGrPaint(context, surfaceDrawContext->colorInfo(), paint, matrixProvider,\n                          &grPaint)) {\n        return;\n    }\n\n    const SkMatrix& viewMatrix(matrixProvider.localToDevice());\n    SkMaskFilterBase* mf = as_MFB(paint.getMaskFilter());\n    if (mf && !mf->hasFragmentProcessor()) {\n        // The MaskFilter wasn't already handled in SkPaintToGrPaint\n        draw_shape_with_mask_filter(context, surfaceDrawContext, clip, std::move(grPaint),\n                                    viewMatrix, mf, shape);\n    } else {\n        GrAA aa = GrAA(paint.isAntiAlias());\n        surfaceDrawContext->drawShape(clip, std::move(grPaint), aa, viewMatrix, shape);\n    }\n}\n\nvoid SkGpuDevice::drawRRect(const SkRRect& rrect, const SkPaint& paint) {\n    ASSERT_SINGLE_OWNER\n    GR_CREATE_TRACE_MARKER_CONTEXT(\"SkGpuDevice\", \"drawRRect\", fContext.get());\n\n    SkMaskFilterBase* mf = as_MFB(paint.getMaskFilter());\n    if (mf) {\n        if (mf->hasFragmentProcessor()) {\n            mf = nullptr; // already handled in SkPaintToGrPaint\n        }\n    }\n\n    GrStyle style(paint);\n\n    if (mf || style.pathEffect()) {\n        // A path effect will presumably transform this rrect into something else.\n        GrStyledShape shape(rrect, style);\n\n        GrBlurUtils::drawShapeWithMaskFilter(fContext.get(), fSurfaceDrawContext.get(),\n                                             this->clip(), paint, this->asMatrixProvider(), shape);\n        return;\n    }\n\n    SkASSERT(!style.pathEffect());\n\n    GrPaint grPaint;\n    if (!SkPaintToGrPaint(this->recordingContext(), fSurfaceDrawContext->colorInfo(), paint,\n                          this->asMatrixProvider(), &grPaint)) {\n        return;\n    }\n\n    fSurfaceDrawContext->drawRRect(this->clip(), std::move(grPaint), GrAA(paint.isAntiAlias()),\n                                   this->localToDevice(), rrect, style);\n}\n\nvoid SkGpuDevice::drawOval(const SkRect& oval, const SkPaint& paint) {\n    ASSERT_SINGLE_OWNER\n    GR_CREATE_TRACE_MARKER_CONTEXT(\"SkGpuDevice\", \"drawOval\", fContext.get());\n\n    if (paint.getMaskFilter()) {\n        // The RRect path can handle special case blurring\n        SkRRect rr = SkRRect::MakeOval(oval);\n        return this->drawRRect(rr, paint);\n    }\n\n    GrPaint grPaint;\n    if (!SkPaintToGrPaint(this->recordingContext(), fSurfaceDrawContext->colorInfo(), paint,\n                          this->asMatrixProvider(), &grPaint)) {\n        return;\n    }\n\n    fSurfaceDrawContext->drawOval(this->clip(), std::move(grPaint), GrAA(paint.isAntiAlias()),\n                                  this->localToDevice(), oval, GrStyle(paint));\n}\n\nvoid SkCanvas::onDrawOval(const SkRect& oval, const SkPaint& paint) {\n    SkASSERT(oval.isSorted());\n    if (this->internalQuickReject(oval, paint)) {\n        return;\n    }\n\n    AutoLayerForImageFilter layer(this, paint, &oval);\n    this->topDevice()->drawOval(oval, layer.paint());\n}\n\nvoid SkCanvas::drawOval(const SkRect& r, const SkPaint& paint) {\n    TRACE_EVENT0(\"skia\", TRACE_FUNC);\n    // To avoid redundant logic in our culling code and various backends, we always sort rects\n    // before passing them along.\n    this->onDrawOval(r.makeSorted(), paint);\n}\n\nvoid SkCanvas::drawCircle(SkScalar cx, SkScalar cy, SkScalar radius, const SkPaint& paint) {\n    if (radius < 0) {\n        radius = 0;\n    }\n\n    SkRect  r;\n    r.setLTRB(cx - radius, cy - radius, cx + radius, cy + radius);\n    this->drawOval(r, paint);\n}\n\n    void drawCircle(SkPoint center, SkScalar radius, const SkPaint& paint) {\n        this->drawCircle(center.x(), center.y(), radius, paint);\n    }\n\nstatic void fuzz_canvas(Fuzz* fuzz, SkCanvas* canvas, int depth = 9) {\n    if (!fuzz || !canvas || depth <= 0) {\n        return;\n    }\n    SkAutoCanvasRestore autoCanvasRestore(canvas, false);\n    unsigned N;\n    fuzz->nextRange(&N, 0, 2000);\n    for (unsigned i = 0; i < N; ++i) {\n        if (fuzz->exhausted()) {\n            return;\n        }\n        SkPaint paint;\n        SkFont font;\n        unsigned drawCommand;\n        fuzz->nextRange(&drawCommand, 0, 62);\n        switch (drawCommand) {\n            case 0:\n                canvas->flush();\n                break;\n            case 1:\n                canvas->save();\n                break;\n            case 2: {\n                SkRect bounds;\n                fuzz->next(&bounds);\n                fuzz_paint(fuzz, &paint, depth - 1);\n                canvas->saveLayer(&bounds, &paint);\n                break;\n            }\n            case 3: {\n                SkRect bounds;\n                fuzz->next(&bounds);\n                canvas->saveLayer(&bounds, nullptr);\n                break;\n            }\n            case 4:\n                fuzz_paint(fuzz, &paint, depth - 1);\n                canvas->saveLayer(nullptr, &paint);\n                break;\n            case 5:\n                canvas->saveLayer(nullptr, nullptr);\n                break;\n            case 6: {\n                uint8_t alpha;\n                fuzz->next(&alpha);\n                canvas->saveLayerAlpha(nullptr, (U8CPU)alpha);\n                break;\n            }\n            case 7: {\n                SkRect bounds;\n                uint8_t alpha;\n                fuzz->next(&bounds, &alpha);\n                canvas->saveLayerAlpha(&bounds, (U8CPU)alpha);\n                break;\n            }\n            case 8: {\n                SkCanvas::SaveLayerRec saveLayerRec;\n                SkRect bounds;\n                if (make_fuzz_t<bool>(fuzz)) {\n                    fuzz->next(&bounds);\n                    saveLayerRec.fBounds = &bounds;\n                }\n                if (make_fuzz_t<bool>(fuzz)) {\n                    fuzz_paint(fuzz, &paint, depth - 1);\n                    saveLayerRec.fPaint = &paint;\n                }\n                sk_sp<SkImageFilter> imageFilter;\n                if (make_fuzz_t<bool>(fuzz)) {\n                    imageFilter = make_fuzz_imageFilter(fuzz, depth - 1);\n                    saveLayerRec.fBackdrop = imageFilter.get();\n                }\n                // _DumpCanvas can't handle this.\n                // if (make_fuzz_t<bool>(fuzz)) {\n                //     saveLayerRec.fSaveLayerFlags |= SkCanvas::kPreserveLCDText_SaveLayerFlag;\n                // }\n\n                canvas->saveLayer(saveLayerRec);\n                break;\n            }\n            case 9:\n                canvas->restore();\n                break;\n            case 10: {\n                int saveCount;\n                fuzz->next(&saveCount);\n                canvas->restoreToCount(saveCount);\n                break;\n            }\n            case 11: {\n                SkScalar x, y;\n                fuzz->next(&x, &y);\n                canvas->translate(x, y);\n                break;\n            }\n            case 12: {\n                SkScalar x, y;\n                fuzz->next(&x, &y);\n                canvas->scale(x, y);\n                break;\n            }\n            case 13: {\n                SkScalar v;\n                fuzz->next(&v);\n                canvas->rotate(v);\n                break;\n            }\n            case 14: {\n                SkScalar x, y, v;\n                fuzz->next(&x, &y, &v);\n                canvas->rotate(v, x, y);\n                break;\n            }\n            case 15: {\n                SkScalar x, y;\n                fuzz->next(&x, &y);\n                canvas->skew(x, y);\n                break;\n            }\n            case 16: {\n                SkMatrix mat;\n                FuzzNiceMatrix(fuzz, &mat);\n                canvas->concat(mat);\n                break;\n            }\n            case 17: {\n                SkMatrix mat;\n                FuzzNiceMatrix(fuzz, &mat);\n                canvas->setMatrix(mat);\n                break;\n            }\n            case 18:\n                canvas->resetMatrix();\n                break;\n            case 19: {\n                SkRect r;\n                int op;\n                bool doAntiAlias;\n                fuzz->next(&r, &doAntiAlias);\n                fuzz->nextRange(&op, 0, 1);\n                r.sort();\n                canvas->clipRect(r, (SkClipOp)op, doAntiAlias);\n                break;\n            }\n            case 20: {\n                SkRRect rr;\n                int op;\n                bool doAntiAlias;\n                FuzzNiceRRect(fuzz, &rr);\n                fuzz->next(&doAntiAlias);\n                fuzz->nextRange(&op, 0, 1);\n                canvas->clipRRect(rr, (SkClipOp)op, doAntiAlias);\n                break;\n            }\n            case 21: {\n                SkPath path;\n                FuzzNicePath(fuzz, &path, 30);\n                int op;\n                bool doAntiAlias;\n                fuzz->next(&doAntiAlias);\n                fuzz->nextRange(&op, 0, 1);\n                canvas->clipPath(path, (SkClipOp)op, doAntiAlias);\n                break;\n            }\n            case 22: {\n                SkRegion region;\n                int op;\n                fuzz->next(&region);\n                fuzz->nextRange(&op, 0, 1);\n                canvas->clipRegion(region, (SkClipOp)op);\n                break;\n            }\n            case 23:\n                fuzz_paint(fuzz, &paint, depth - 1);\n                canvas->drawPaint(paint);\n                break;\n            case 24: {\n                fuzz_paint(fuzz, &paint, depth - 1);\n                SkCanvas::PointMode pointMode;\n                fuzz->nextRange(&pointMode,\n                                SkCanvas::kPoints_PointMode, SkCanvas::kPolygon_PointMode);\n                size_t count;\n                constexpr int kMaxCount = 30;\n                fuzz->nextRange(&count, 0, kMaxCount);\n                SkPoint pts[kMaxCount];\n                fuzz->nextN(pts, count);\n                canvas->drawPoints(pointMode, count, pts, paint);\n                break;\n            }\n            case 25: {\n                fuzz_paint(fuzz, &paint, depth - 1);\n                SkRect r;\n                fuzz->next(&r);\n                if (!r.isFinite()) {\n                    break;\n                }\n                canvas->drawRect(r, paint);\n                break;\n            }\n            case 26: {\n                fuzz_paint(fuzz, &paint, depth - 1);\n                SkRegion region;\n                fuzz->next(&region);\n                canvas->drawRegion(region, paint);\n                break;\n            }\n            case 27: {\n                fuzz_paint(fuzz, &paint, depth - 1);\n                SkRect r;\n                fuzz->next(&r);\n                if (!r.isFinite()) {\n                    break;\n                }\n                canvas->drawOval(r, paint);\n                break;\n            }\n            case 28: break; // must have deleted this some time earlier\n            case 29: {\n                fuzz_paint(fuzz, &paint, depth - 1);\n                SkRRect rr;\n                FuzzNiceRRect(fuzz, &rr);\n                canvas->drawRRect(rr, paint);\n                break;\n            }\n            case 30: {\n                fuzz_paint(fuzz, &paint, depth - 1);\n                SkRRect orr, irr;\n                FuzzNiceRRect(fuzz, &orr);\n                FuzzNiceRRect(fuzz, &irr);\n                if (orr.getBounds().contains(irr.getBounds())) {\n                    canvas->drawDRRect(orr, irr, paint);\n                }\n                break;\n            }\n            case 31: {\n                fuzz_paint(fuzz, &paint, depth - 1);\n                SkRect r;\n                SkScalar start, sweep;\n                bool useCenter;\n                fuzz->next(&r, &start, &sweep, &useCenter);\n                canvas->drawArc(r, start, sweep, useCenter, paint);\n                break;\n            }\n            case 32: {\n                fuzz_paint(fuzz, &paint, depth - 1);\n                SkPath path;\n                FuzzNicePath(fuzz, &path, 60);\n                canvas->drawPath(path, paint);\n                break;\n            }\n            case 33: {\n                sk_sp<SkImage> img = make_fuzz_image(fuzz);\n                SkScalar left, top;\n                bool usePaint;\n                fuzz->next(&left, &top, &usePaint);\n                if (usePaint) {\n                    fuzz_paint(fuzz, &paint, depth - 1);\n                }\n                canvas->drawImage(img.get(), left, top, usePaint ? &paint : nullptr);\n                break;\n            }\n            case 34: {\n                auto img = make_fuzz_image(fuzz);\n                SkRect src, dst;\n                bool usePaint;\n                fuzz->next(&src, &dst, &usePaint);\n                if (usePaint) {\n                    fuzz_paint(fuzz, &paint, depth - 1);\n                }\n                canvas->drawImageRect(img, src, dst, usePaint ? &paint : nullptr);\n                break;\n            }\n            case 35: {\n                auto img = make_fuzz_image(fuzz);\n                SkIRect src;\n                SkRect dst;\n                bool usePaint;\n                fuzz->next(&src, &dst, &usePaint);\n                if (usePaint) {\n                    fuzz_paint(fuzz, &paint, depth - 1);\n                }\n                SkCanvas::SrcRectConstraint constraint =\n                        make_fuzz_t<bool>(fuzz) ? SkCanvas::kStrict_SrcRectConstraint\n                                                : SkCanvas::kFast_SrcRectConstraint;\n                canvas->drawImageRect(img, src, dst, usePaint ? &paint : nullptr, constraint);\n                break;\n            }\n            case 36: {\n                bool usePaint;\n                auto img = make_fuzz_image(fuzz);\n                SkRect dst;\n                fuzz->next(&dst, &usePaint);\n                if (usePaint) {\n                    fuzz_paint(fuzz, &paint, depth - 1);\n                }\n                canvas->drawImageRect(img, dst, usePaint ? &paint : nullptr);\n                break;\n            }\n            case 37: {\n                auto img = make_fuzz_image(fuzz);\n                SkIRect center;\n                SkRect dst;\n                bool usePaint;\n                fuzz->next(&usePaint);\n                if (usePaint) {\n                    fuzz_paint(fuzz, &paint, depth - 1);\n                }\n                if (make_fuzz_t<bool>(fuzz)) {\n                    fuzz->next(&center);\n                } else {  // Make valid center, see SkLatticeIter::Valid().\n                    fuzz->nextRange(&center.fLeft, 0, img->width() - 1);\n                    fuzz->nextRange(&center.fTop, 0, img->height() - 1);\n                    fuzz->nextRange(&center.fRight, center.fLeft + 1, img->width());\n                    fuzz->nextRange(&center.fBottom, center.fTop + 1, img->height());\n                }\n                fuzz->next(&dst);\n                canvas->drawImageNine(img, center, dst, usePaint ? &paint : nullptr);\n                break;\n            }\n            case 38: {\n                SkBitmap bitmap = make_fuzz_bitmap(fuzz);\n                SkScalar left, top;\n                bool usePaint;\n                fuzz->next(&left, &top, &usePaint);\n                if (usePaint) {\n                    fuzz_paint(fuzz, &paint, depth - 1);\n                }\n                canvas->drawBitmap(bitmap, left, top, usePaint ? &paint : nullptr);\n                break;\n            }\n            case 39: {\n                SkBitmap bitmap = make_fuzz_bitmap(fuzz);\n                SkRect src, dst;\n                bool usePaint;\n                fuzz->next(&src, &dst, &usePaint);\n                if (usePaint) {\n                    fuzz_paint(fuzz, &paint, depth - 1);\n                }\n                SkCanvas::SrcRectConstraint constraint =\n                        make_fuzz_t<bool>(fuzz) ? SkCanvas::kStrict_SrcRectConstraint\n                                                : SkCanvas::kFast_SrcRectConstraint;\n                canvas->drawBitmapRect(bitmap, src, dst, usePaint ? &paint : nullptr, constraint);\n                break;\n            }\n            case 40: {\n                SkBitmap img = make_fuzz_bitmap(fuzz);\n                SkIRect src;\n                SkRect dst;\n                bool usePaint;\n                fuzz->next(&src, &dst, &usePaint);\n                if (usePaint) {\n                    fuzz_paint(fuzz, &paint, depth - 1);\n                }\n                SkCanvas::SrcRectConstraint constraint =\n                        make_fuzz_t<bool>(fuzz) ? SkCanvas::kStrict_SrcRectConstraint\n                                                : SkCanvas::kFast_SrcRectConstraint;\n                canvas->drawBitmapRect(img, src, dst, usePaint ? &paint : nullptr, constraint);\n                break;\n            }\n            case 41: {\n                SkBitmap img = make_fuzz_bitmap(fuzz);\n                SkRect dst;\n                bool usePaint;\n                fuzz->next(&dst, &usePaint);\n                if (usePaint) {\n                    fuzz_paint(fuzz, &paint, depth - 1);\n                }\n                SkCanvas::SrcRectConstraint constraint =\n                        make_fuzz_t<bool>(fuzz) ? SkCanvas::kStrict_SrcRectConstraint\n                                                : SkCanvas::kFast_SrcRectConstraint;\n                canvas->drawBitmapRect(img, dst, usePaint ? &paint : nullptr, constraint);\n                break;\n            }\n            case 42: {\n                break;\n            }\n            case 43: {\n                break;\n            }\n            case 44: {\n                auto img = make_fuzz_image(fuzz);\n                bool usePaint;\n                SkRect dst;\n                fuzz->next(&usePaint, &dst);\n                if (usePaint) {\n                    fuzz_paint(fuzz, &paint, depth - 1);\n                }\n                constexpr int kMax = 6;\n                int xDivs[kMax], yDivs[kMax];\n                SkCanvas::Lattice lattice{xDivs, yDivs, nullptr, 0, 0, nullptr, nullptr};\n                fuzz->nextRange(&lattice.fXCount, 2, kMax);\n                fuzz->nextRange(&lattice.fYCount, 2, kMax);\n                fuzz->nextN(xDivs, lattice.fXCount);\n                fuzz->nextN(yDivs, lattice.fYCount);\n                canvas->drawImageLattice(img.get(), lattice, dst, usePaint ? &paint : nullptr);\n                break;\n            }\n            case 45: {\n                fuzz_paint(fuzz, &paint, depth - 1);\n                font = fuzz_font(fuzz);\n                SkTextEncoding encoding = fuzz_paint_text_encoding(fuzz);\n                SkScalar x, y;\n                fuzz->next(&x, &y);\n                SkTDArray<uint8_t> text = make_fuzz_text(fuzz, font, encoding);\n                canvas->drawSimpleText(text.begin(), SkToSizeT(text.count()), encoding, x, y,\n                                       font, paint);\n                break;\n            }\n            case 46: {\n                // was drawPosText\n                break;\n            }\n            case 47: {\n                // was drawPosTextH\n                break;\n            }\n            case 48: {\n                // was drawtextonpath\n                break;\n            }\n            case 49: {\n                // was drawtextonpath\n                break;\n            }\n            case 50: {\n                // was drawTextRSXform\n                break;\n            }\n            case 51: {\n                sk_sp<SkTextBlob> blob = make_fuzz_textblob(fuzz);\n                fuzz_paint(fuzz, &paint, depth - 1);\n                SkScalar x, y;\n                fuzz->next(&x, &y);\n                canvas->drawTextBlob(blob, x, y, paint);\n                break;\n            }\n            case 52: {\n                SkMatrix matrix;\n                bool usePaint, useMatrix;\n                fuzz->next(&usePaint, &useMatrix);\n                if (usePaint) {\n                    fuzz_paint(fuzz, &paint, depth - 1);\n                }\n                if (useMatrix) {\n                    FuzzNiceMatrix(fuzz, &matrix);\n                }\n                auto pic = make_fuzz_picture(fuzz, depth - 1);\n                canvas->drawPicture(pic, useMatrix ? &matrix : nullptr,\n                                    usePaint ? &paint : nullptr);\n                break;\n            }\n            case 53: {\n                fuzz_paint(fuzz, &paint, depth - 1);\n                SkVertices::VertexMode vertexMode;\n                SkBlendMode blendMode;\n                fuzz->nextRange(&vertexMode, 0, SkVertices::kTriangleFan_VertexMode);\n                fuzz->nextRange(&blendMode, 0, SkBlendMode::kLastMode);\n                constexpr int kMaxCount = 100;\n                int vertexCount;\n                SkPoint vertices[kMaxCount];\n                SkPoint texs[kMaxCount];\n                SkColor colors[kMaxCount];\n                fuzz->nextRange(&vertexCount, 3, kMaxCount);\n                fuzz->nextN(vertices, vertexCount);\n                bool useTexs, useColors;\n                fuzz->next(&useTexs, &useColors);\n                if (useTexs) {\n                    fuzz->nextN(texs, vertexCount);\n                }\n                if (useColors) {\n                    fuzz->nextN(colors, vertexCount);\n                }\n                int indexCount = 0;\n                uint16_t indices[kMaxCount * 2];\n                if (make_fuzz_t<bool>(fuzz)) {\n                    fuzz->nextRange(&indexCount, vertexCount, vertexCount + kMaxCount);\n                    for (int i = 0; i < indexCount; ++i) {\n                        fuzz->nextRange(&indices[i], 0, vertexCount - 1);\n                    }\n                }\n                canvas->drawVertices(SkVertices::MakeCopy(vertexMode, vertexCount, vertices,\n                                                          useTexs ? texs : nullptr,\n                                                          useColors ? colors : nullptr,\n                                                          indexCount, indices),\n                                     blendMode, paint);\n                break;\n            }\n            case 54: {\n                SkColor color;\n                SkBlendMode blendMode;\n                fuzz->nextRange(&blendMode, 0, SkBlendMode::kSrcOver);\n                fuzz->next(&color);\n                canvas->drawColor(color, blendMode);\n                break;\n            }\n            case 55: {\n                SkColor4f color;\n                SkBlendMode blendMode;\n                float R, G, B, Alpha;\n                fuzz->nextRange(&blendMode, 0, SkBlendMode::kSrcOver);\n                fuzz->nextRange(&R, -1, 2);\n                fuzz->nextRange(&G, -1, 2);\n                fuzz->nextRange(&B, -1, 2);\n                fuzz->nextRange(&Alpha, 0, 1);\n                color = {R, G, B, Alpha};\n                canvas->drawColor(color, blendMode);\n                break;\n            }\n            case 56: {\n                fuzz_paint(fuzz, &paint, depth - 1);\n                SkPoint p0, p1;\n                fuzz->next(&p0, &p1);\n                canvas->drawLine(p0, p1, paint);\n                break;\n            }\n            case 57: {\n                fuzz_paint(fuzz, &paint, depth - 1);\n                SkIRect r;\n                fuzz->next(&r);\n                canvas->drawIRect(r, paint);\n                break;\n            }\n            case 58: {\n                fuzz_paint(fuzz, &paint, depth - 1);\n                SkScalar radius;\n                SkPoint center;\n                fuzz->next(&radius, &center);\n                canvas->drawCircle(center, radius, paint);\n                break;\n            }\n            case 59: {\n                fuzz_paint(fuzz, &paint, depth - 1);\n                SkRect oval;\n                SkScalar startAngle, sweepAngle;\n                bool useCenter;\n                fuzz->next(&oval, &startAngle, &sweepAngle, &useCenter);\n                canvas->drawArc(oval, startAngle, sweepAngle, useCenter, paint);\n                break;\n            }\n            case 60: {\n                fuzz_paint(fuzz, &paint, depth - 1);\n                SkRect rect;\n                SkScalar rx, ry;\n                fuzz->next(&rect, &rx, &ry);\n                canvas->drawRoundRect(rect, rx, ry, paint);\n                break;\n            }\n            case 61: {\n                fuzz_paint(fuzz, &paint, depth - 1);\n                font = fuzz_font(fuzz);\n                std::string str = make_fuzz_string(fuzz);\n                SkScalar x, y;\n                fuzz->next(&x, &y);\n                canvas->drawString(str.c_str(), x, y, font, paint);\n                break;\n            }\n            case 62: {\n                fuzz_paint(fuzz, &paint, depth - 1);\n                SkPoint cubics[12];\n                SkColor colors[4];\n                SkPoint texCoords[4];\n                bool useTexCoords;\n                fuzz->nextN(cubics, 12);\n                fuzz->nextN(colors, 4);\n                fuzz->next(&useTexCoords);\n                if (useTexCoords) {\n                    fuzz->nextN(texCoords, 4);\n                }\n                SkBlendMode mode;\n                fuzz->nextEnum(&mode, SkBlendMode::kLastMode);\n                canvas->drawPatch(cubics, colors, useTexCoords ? texCoords : nullptr\n                    , mode, paint);\n                break;\n            }\n            default:\n                SkASSERT(false);\n                break;\n        }\n    }\n}\n\nstatic void fuzz_ganesh(Fuzz* fuzz, GrDirectContext* context) {\n    SkASSERT(context);\n    auto surface = SkSurface::MakeRenderTarget(\n            context,\n            SkBudgeted::kNo,\n            SkImageInfo::Make(kCanvasSize, kRGBA_8888_SkColorType, kPremul_SkAlphaType));\n    SkASSERT(surface && surface->getCanvas());\n    fuzz_canvas(fuzz, surface->getCanvas());\n}\n\n\n\n\n// target function\nstatic std::unique_ptr<GrFragmentProcessor> create_profile_effect(GrRecordingContext* rContext,\n                                                                  const SkRect& circle,\n                                                                  float sigma,\n                                                                  float* solidRadius,\n                                                                  float* textureRadius) {\n    float circleR = circle.width() / 2.0f;\n    if (circleR < SK_ScalarNearlyZero) {\n        return nullptr;\n    }\n\n    auto threadSafeCache = rContext->priv().threadSafeCache();\n\n    // Profile textures are cached by the ratio of sigma to circle radius and by the size of the\n    // profile texture (binned by powers of 2).\n    SkScalar sigmaToCircleRRatio = sigma / circleR;\n    // When sigma is really small this becomes a equivalent to convolving a Gaussian with a\n    // half-plane. Similarly, in the extreme high ratio cases circle becomes a point WRT to the\n    // Guassian and the profile texture is a just a Gaussian evaluation. However, we haven't yet\n    // implemented this latter optimization.\n    sigmaToCircleRRatio = std::min(sigmaToCircleRRatio, 8.f);\n    SkFixed sigmaToCircleRRatioFixed;\n    static const SkScalar kHalfPlaneThreshold = 0.1f;\n    bool useHalfPlaneApprox = false;\n    if (sigmaToCircleRRatio <= kHalfPlaneThreshold) {\n        useHalfPlaneApprox = true;\n        sigmaToCircleRRatioFixed = 0;\n        *solidRadius = circleR - 3 * sigma;\n        *textureRadius = 6 * sigma;\n    } else {\n        // Convert to fixed point for the key.\n        sigmaToCircleRRatioFixed = SkScalarToFixed(sigmaToCircleRRatio);\n        // We shave off some bits to reduce the number of unique entries. We could probably\n        // shave off more than we do.\n        sigmaToCircleRRatioFixed &= ~0xff;\n        sigmaToCircleRRatio = SkFixedToScalar(sigmaToCircleRRatioFixed);\n        sigma = circleR * sigmaToCircleRRatio;\n        *solidRadius = 0;\n        *textureRadius = circleR + 3 * sigma;\n    }\n\n    static constexpr int kProfileTextureWidth = 512;\n    // This would be kProfileTextureWidth/textureRadius if it weren't for the fact that we do\n    // the calculation of the profile coord in a coord space that has already been scaled by\n    // 1 / textureRadius. This is done to avoid overflow in length().\n    SkMatrix texM = SkMatrix::Scale(kProfileTextureWidth, 1.f);\n\n    static const GrUniqueKey::Domain kDomain = GrUniqueKey::GenerateDomain();\n    GrUniqueKey key;\n    GrUniqueKey::Builder builder(&key, kDomain, 1, \"1-D Circular Blur\");\n    builder[0] = sigmaToCircleRRatioFixed;\n    builder.finish();\n\n    GrSurfaceProxyView profileView = threadSafeCache->find(key);\n    if (profileView) {\n        SkASSERT(profileView.asTextureProxy());\n        SkASSERT(profileView.origin() == kTopLeft_GrSurfaceOrigin);\n        return GrTextureEffect::Make(std::move(profileView), kPremul_SkAlphaType, texM);\n    }\n\n    SkBitmap bm;\n    if (!bm.tryAllocPixels(SkImageInfo::MakeA8(kProfileTextureWidth, 1))) {\n        return nullptr;\n    }\n\n    if (useHalfPlaneApprox) {\n        create_half_plane_profile(bm.getAddr8(0, 0), kProfileTextureWidth);\n    } else {\n        // Rescale params to the size of the texture we're creating.\n        SkScalar scale = kProfileTextureWidth / *textureRadius;\n        create_circle_profile(bm.getAddr8(0, 0), sigma * scale, circleR * scale,\n                              kProfileTextureWidth);\n    }\n\n    bm.setImmutable();\n\n    GrBitmapTextureMaker maker(rContext, bm, GrImageTexGenPolicy::kNew_Uncached_Budgeted);\n    profileView = maker.view(GrMipmapped::kNo);\n    if (!profileView) {\n        return nullptr;\n    }\n\n    profileView = threadSafeCache->add(key, profileView);\n    return GrTextureEffect::Make(std::move(profileView), kPremul_SkAlphaType, texM);\n}\n",
    "target": 1,
    "idx": 1029183,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "// context\n\n\n\n\nstatus \ndecodeFields(CtxJson *ctx, ParseCtx *parseCtx, DecodeEntry *entries,\n             size_t entryCount, const UA_DataType *type) {\n    CHECK_TOKEN_BOUNDS;\n    size_t objectCount = (size_t)(parseCtx->tokenArray[parseCtx->index].size);\n    status ret = UA_STATUSCODE_GOOD;\n\n    if(entryCount == 1) {\n        if(*(entries[0].fieldName) == 0) { /*No MemberName*/\n            return entries[0].function(entries[0].fieldPointer, type,\n                                       ctx, parseCtx, true); /*ENCODE DIRECT*/\n        }\n    } else if(entryCount == 0) {\n        return UA_STATUSCODE_BADDECODINGERROR;\n    }\n\n    parseCtx->index++; /*go to first key*/\n    CHECK_TOKEN_BOUNDS;\n    \n    for (size_t currentObjectCount = 0; currentObjectCount < objectCount &&\n             parseCtx->index < parseCtx->tokenCount; currentObjectCount++) {\n\n        /* start searching at the index of currentObjectCount */\n        for (size_t i = currentObjectCount; i < entryCount + currentObjectCount; i++) {\n            /* Search for KEY, if found outer loop will be one less. Best case\n             * is objectCount if in order! */\n            size_t index = i % entryCount;\n            \n            CHECK_TOKEN_BOUNDS;\n            if(jsoneq((char*) ctx->pos, &parseCtx->tokenArray[parseCtx->index], \n                       entries[index].fieldName) != 0)\n                continue;\n\n            if(entries[index].found) {\n                /*Duplicate Key found, abort.*/\n                return UA_STATUSCODE_BADDECODINGERROR;\n            }\n\n            entries[index].found = true;\n\n            parseCtx->index++; /*goto value*/\n            CHECK_TOKEN_BOUNDS;\n            \n            /* Find the data type.\n             * TODO: get rid of parameter type. Only forward via DecodeEntry.\n             */\n            const UA_DataType *membertype = type;\n            if(entries[index].type)\n                membertype = entries[index].type;\n\n            if(entries[index].function != NULL) {\n                ret = entries[index].function(entries[index].fieldPointer,\n                                              membertype, ctx, parseCtx, true); /*Move Token True*/\n                if(ret != UA_STATUSCODE_GOOD)\n                    return ret;\n            } else {\n                /*overstep single value, this will not work if object or array\n                 Only used not to double parse pre looked up type, but it has to be overstepped*/\n                parseCtx->index++;\n            }\n            break;\n        }\n    }\n    return ret;\n}\n\nstatic status\nVariant_decodeJsonUnwrapExtensionObject(UA_Variant *dst, const UA_DataType *type, \n                                        CtxJson *ctx, ParseCtx *parseCtx, UA_Boolean moveToken) {\n    (void) type, (void) moveToken;\n    /*EXTENSIONOBJECT POSITION!*/\n    UA_UInt16 old_index = parseCtx->index;\n    UA_Boolean typeIdFound;\n    \n    /* Decode the DataType */\n    UA_NodeId typeId;\n    UA_NodeId_init(&typeId);\n\n    size_t searchTypeIdResult = 0;\n    status ret = lookAheadForKey(UA_JSONKEY_TYPEID, ctx, parseCtx, &searchTypeIdResult);\n\n    if(ret != UA_STATUSCODE_GOOD) {\n        /*No Typeid found*/\n        typeIdFound = false;\n        /*return UA_STATUSCODE_BADDECODINGERROR;*/\n    } else {\n        typeIdFound = true;\n        /* parse the nodeid */\n        parseCtx->index = (UA_UInt16)searchTypeIdResult;\n        ret = NodeId_decodeJson(&typeId, &UA_TYPES[UA_TYPES_NODEID], ctx, parseCtx, true);\n        if(ret != UA_STATUSCODE_GOOD) {\n            UA_NodeId_deleteMembers(&typeId);\n            return ret;\n        }\n\n        /*restore index, ExtensionObject position*/\n        parseCtx->index = old_index;\n    }\n\n    /* ---Decode the EncodingByte--- */\n    if(!typeIdFound)\n        return UA_STATUSCODE_BADDECODINGERROR;\n\n    UA_Boolean encodingFound = false;\n    /*Search for Encoding*/\n    size_t searchEncodingResult = 0;\n    ret = lookAheadForKey(UA_JSONKEY_ENCODING, ctx, parseCtx, &searchEncodingResult);\n\n    UA_UInt64 encoding = 0;\n    /*If no encoding found it is Structure encoding*/\n    if(ret == UA_STATUSCODE_GOOD) { /*FOUND*/\n        encodingFound = true;\n        char *extObjEncoding = (char*)(ctx->pos + parseCtx->tokenArray[searchEncodingResult].start);\n        size_t size = (size_t)(parseCtx->tokenArray[searchEncodingResult].end \n                               - parseCtx->tokenArray[searchEncodingResult].start);\n        atoiUnsigned(extObjEncoding, size, &encoding);\n    }\n        \n    const UA_DataType *typeOfBody = UA_findDataType(&typeId);\n        \n    if(encoding == 0 || typeOfBody != NULL) {\n        /*This value is 0 if the body is Structure encoded as a JSON object (see 5.4.6).*/\n        /* Found a valid type and it is structure encoded so it can be unwrapped */\n        dst->type = typeOfBody;\n\n        /* Allocate memory for type*/\n        dst->data = UA_new(dst->type);\n        if(!dst->data) {\n            UA_NodeId_deleteMembers(&typeId);\n            return UA_STATUSCODE_BADOUTOFMEMORY;\n        }\n\n        /* Decode the content */\n        UA_NodeId nodeIddummy;\n        DecodeEntry entries[3] =\n            {\n             {UA_JSONKEY_TYPEID, &nodeIddummy, (decodeJsonSignature) NodeId_decodeJson, false, NULL},\n             {UA_JSONKEY_BODY, dst->data,\n              (decodeJsonSignature) decodeJsonJumpTable[dst->type->typeKind], false, NULL},\n             {UA_JSONKEY_ENCODING, NULL, NULL, false, NULL}};\n\n        ret = decodeFields(ctx, parseCtx, entries, encodingFound ? 3:2, typeOfBody);\n        if(ret != UA_STATUSCODE_GOOD) {\n            UA_free(dst->data);\n        }\n    } else if(encoding == 1 || encoding == 2 || typeOfBody == NULL) {\n        UA_NodeId_deleteMembers(&typeId);\n            \n        /* decode as ExtensionObject */\n        dst->type = &UA_TYPES[UA_TYPES_EXTENSIONOBJECT];\n\n        /* Allocate memory for extensionobject*/\n        dst->data = UA_new(dst->type);\n        if(!dst->data)\n            return UA_STATUSCODE_BADOUTOFMEMORY;\n\n        /* decode: Does not move tokenindex. */\n        ret = DECODE_DIRECT_JSON(dst->data, ExtensionObject);\n        if(ret != UA_STATUSCODE_GOOD)\n            UA_free(dst->data);\n    } else {\n        /*no recognized encoding type*/\n        return UA_STATUSCODE_BADDECODINGERROR;\n    }\n    return ret;\n}\n\n\n// target function\nUA_StatusCode UA_ByteString_toBase64String(const UA_ByteString *byteString, UA_String *str) {\n    if (str->length != 0) {\n        UA_free(str->data);\n        str->data = NULL;\n        str->length = 0;\n    }\n    if (byteString == NULL || byteString->data == NULL)\n        return UA_STATUSCODE_GOOD;\n    if (byteString == str)\n        return UA_STATUSCODE_BADINVALIDARGUMENT;\n\n    int resSize = 0;\n    str->data = (UA_Byte*)UA_base64(byteString->data, (int)byteString->length, &resSize);\n    str->length = (size_t) resSize;\n    if (str->data == NULL)\n        return UA_STATUSCODE_BADOUTOFMEMORY;\n\n    return UA_STATUSCODE_GOOD;\n}\nextern \"C\" int\nLLVMFuzzerTestOneInput(uint8_t *data, size_t size) {\n    UA_ByteString buf;\n    buf.data = (UA_Byte*)data;\n    buf.length = size;\n\n    UA_Variant value;\n    UA_Variant_init(&value);\n\n    UA_StatusCode retval = UA_decodeJson(&buf, &value, &UA_TYPES[UA_TYPES_VARIANT]);\n    if(retval != UA_STATUSCODE_GOOD)\n        return 0;\n\n    size_t jsonSize = UA_calcSizeJson(&value, &UA_TYPES[UA_TYPES_VARIANT],\n                                      NULL, 0, NULL, 0, true);\n\n    UA_ByteString buf2 = UA_BYTESTRING_NULL;\n    retval = UA_ByteString_allocBuffer(&buf2, jsonSize);\n    if(retval != UA_STATUSCODE_GOOD) {\n        UA_Variant_deleteMembers(&value);\n        return 0;\n    }\n\n    uint8_t *bufPos = buf2.data;\n    const uint8_t *bufEnd = &buf2.data[buf2.length];\n    retval = UA_encodeJson(&value, &UA_TYPES[UA_TYPES_VARIANT],\n                           &bufPos, &bufEnd, NULL, 0, NULL, 0, true);\n\tUA_Variant_deleteMembers(&value);\n\tif(retval != UA_STATUSCODE_GOOD || bufPos != bufEnd) {\n\t\treturn 0;\n\t}\n\n    UA_Variant value2;\n    UA_Variant_init(&value2);\n\n    retval = UA_decodeJson(&buf2, &value2, &UA_TYPES[UA_TYPES_VARIANT]);\n    if(retval != UA_STATUSCODE_GOOD) {\n\t\treturn 0;\n\t}\n\n    UA_ByteString buf3 = UA_BYTESTRING_NULL;\n    retval = UA_ByteString_allocBuffer(&buf3, jsonSize);\n    if(retval != UA_STATUSCODE_GOOD) {\n        UA_Variant_deleteMembers(&value2);\n        UA_ByteString_deleteMembers(&buf2);\n        return 0;\n    }\n\n    bufPos = buf3.data;\n    bufEnd = &buf3.data[buf3.length];\n    retval = UA_encodeJson(&value2, &UA_TYPES[UA_TYPES_VARIANT],\n                           &bufPos, &bufEnd, NULL, 0, NULL, 0, true);\n\tUA_Variant_deleteMembers(&value2);\n\tif(retval != UA_STATUSCODE_GOOD) {\n\t\tUA_ByteString_deleteMembers(&buf2);\n\t\tUA_ByteString_deleteMembers(&buf3);\n\t\treturn 0;\n\t}\n    if (memcmp(buf2.data, buf3.data, buf.length) != 0) {\n    \t// ignore\n    }\n\n    UA_ByteString_deleteMembers(&buf2);\n    UA_ByteString_deleteMembers(&buf3);\n\n    return 0;\n}\n",
    "target": 1,
    "idx": 1014621,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic int do_uncompress_block(struct archive_read* a, const uint8_t* p) {\n    struct rar5* rar = get_context(a);\n    uint16_t num;\n    int ret;\n\n    const int cmask = rar->cstate.window_mask;\n    const struct compressed_block_header* hdr = &rar->last_block_hdr;\n    const uint8_t bit_size = 1 + bf_bit_size(hdr);\n\n    while(1) {\n        if(rar->cstate.write_ptr - rar->cstate.last_write_ptr >\n                (rar->cstate.window_size >> 1)) {\n\n            /* Don't allow growing data by more than half of the window size\n             * at a time. In such case, break the loop; next call to this\n             * function will continue processing from this moment. */\n\n            break;\n        }\n\n        if(rar->bits.in_addr > rar->cstate.cur_block_size - 1 ||\n                (rar->bits.in_addr == rar->cstate.cur_block_size - 1 &&\n                 rar->bits.bit_addr >= bit_size))\n        {\n            /* If the program counter is here, it means the function has\n             * finished processing the block. */\n            rar->cstate.block_parsing_finished = 1;\n            break;\n        }\n\n        /* Decode the next literal. */\n        if(ARCHIVE_OK != decode_number(a, &rar->cstate.ld, p, &num)) {\n            return ARCHIVE_EOF;\n        }\n\n        /* Num holds a decompression literal, or 'command code'.\n         *\n         * - Values lower than 256 are just bytes. Those codes can be stored\n         *   in the output buffer directly.\n         *\n         * - Code 256 defines a new filter, which is later used to transform\n         *   the data block accordingly to the filter type. The data block\n         *   needs to be fully uncompressed first.\n         *\n         * - Code bigger than 257 and smaller than 262 define a repetition\n         *   pattern that should be copied from an already uncompressed chunk\n         *   of data.\n         */\n\n        if(num < 256) {\n            /* Directly store the byte. */\n\n            int64_t write_idx = rar->cstate.solid_offset +\n                rar->cstate.write_ptr++;\n\n            rar->cstate.window_buf[write_idx & cmask] = (uint8_t) num;\n            continue;\n        } else if(num >= 262) {\n            uint16_t dist_slot;\n            int len = decode_code_length(rar, p, num - 262),\n                dbits,\n                dist = 1;\n\n            if(len == -1) {\n                archive_set_error(&a->archive, ARCHIVE_ERRNO_PROGRAMMER,\n                    \"Failed to decode the code length\");\n\n                return ARCHIVE_FATAL;\n            }\n\n            if(ARCHIVE_OK != decode_number(a, &rar->cstate.dd, p, &dist_slot))\n            {\n                archive_set_error(&a->archive, ARCHIVE_ERRNO_PROGRAMMER,\n                    \"Failed to decode the distance slot\");\n\n                return ARCHIVE_FATAL;\n            }\n\n            if(dist_slot < 4) {\n                dbits = 0;\n                dist += dist_slot;\n            } else {\n                dbits = dist_slot / 2 - 1;\n                dist += (2 | (dist_slot & 1)) << dbits;\n            }\n\n            if(dbits > 0) {\n                if(dbits >= 4) {\n                    uint32_t add = 0;\n                    uint16_t low_dist;\n\n                    if(dbits > 4) {\n                        if(ARCHIVE_OK != read_bits_32(rar, p, &add)) {\n                            /* Return EOF if we can't read more data. */\n                            return ARCHIVE_EOF;\n                        }\n\n                        skip_bits(rar, dbits - 4);\n                        add = (add >> (36 - dbits)) << 4;\n                        dist += add;\n                    }\n\n                    if(ARCHIVE_OK != decode_number(a, &rar->cstate.ldd, p,\n                                &low_dist))\n                    {\n                        archive_set_error(&a->archive,\n                                ARCHIVE_ERRNO_PROGRAMMER,\n                                \"Failed to decode the distance slot\");\n\n                        return ARCHIVE_FATAL;\n                    }\n\n                    dist += low_dist;\n                } else {\n                    /* dbits is one of [0,1,2,3] */\n                    int add;\n\n                    if(ARCHIVE_OK != read_consume_bits(rar, p, dbits, &add)) {\n                        /* Return EOF if we can't read more data. */\n                        return ARCHIVE_EOF;\n                    }\n\n                    dist += add;\n                }\n            }\n\n            if(dist > 0x100) {\n                len++;\n\n                if(dist > 0x2000) {\n                    len++;\n\n                    if(dist > 0x40000) {\n                        len++;\n                    }\n                }\n            }\n\n            dist_cache_push(rar, dist);\n            rar->cstate.last_len = len;\n\n            if(ARCHIVE_OK != copy_string(a, len, dist))\n                return ARCHIVE_FATAL;\n\n            continue;\n        } else if(num == 256) {\n            /* Create a filter. */\n            ret = parse_filter(a, p);\n            if(ret != ARCHIVE_OK)\n                return ret;\n\n            continue;\n        } else if(num == 257) {\n            if(rar->cstate.last_len != 0) {\n                if(ARCHIVE_OK != copy_string(a, rar->cstate.last_len,\n                            rar->cstate.dist_cache[0]))\n                {\n                    return ARCHIVE_FATAL;\n                }\n            }\n\n            continue;\n        } else if(num < 262) {\n            const int idx = num - 258;\n            const int dist = dist_cache_touch(rar, idx);\n\n            uint16_t len_slot;\n            int len;\n\n            if(ARCHIVE_OK != decode_number(a, &rar->cstate.rd, p, &len_slot)) {\n                return ARCHIVE_FATAL;\n            }\n\n            len = decode_code_length(rar, p, len_slot);\n            rar->cstate.last_len = len;\n\n            if(ARCHIVE_OK != copy_string(a, len, dist))\n                return ARCHIVE_FATAL;\n\n            continue;\n        }\n\n        /* The program counter shouldn't reach here. */\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                \"Unsupported block code: 0x%02x\", num);\n\n        return ARCHIVE_FATAL;\n    }\n\n    return ARCHIVE_OK;\n}\n\nstatic int process_block(struct archive_read* a) {\n    const uint8_t* p;\n    struct rar5* rar = get_context(a);\n    int ret;\n\n    /* If we don't have any data to be processed, this most probably means\n     * we need to switch to the next volume. */\n    if(rar->main.volume && rar->file.bytes_remaining == 0) {\n        ret = advance_multivolume(a);\n        if(ret != ARCHIVE_OK)\n            return ret;\n    }\n\n    if(rar->cstate.block_parsing_finished) {\n        ssize_t block_size;\n\n        rar->cstate.block_parsing_finished = 0;\n\n        /* The header size won't be bigger than 6 bytes. */\n        if(!read_ahead(a, 6, &p)) {\n            /* Failed to prefetch data block header. */\n            return ARCHIVE_EOF;\n        }\n\n        /*\n         * Read block_size by parsing block header. Validate the header by\n         * calculating CRC byte stored inside the header. Size of the header is\n         * not constant (block size can be stored either in 1 or 2 bytes),\n         * that's why block size is left out from the `compressed_block_header`\n         * structure and returned by `parse_block_header` as the second\n         * argument. */\n\n        ret = parse_block_header(a, p, &block_size, &rar->last_block_hdr);\n        if(ret != ARCHIVE_OK)\n            return ret;\n\n        /* Skip block header. Next data is huffman tables, if present. */\n        ssize_t to_skip = sizeof(struct compressed_block_header) +\n            bf_byte_count(&rar->last_block_hdr) + 1;\n\n        if(ARCHIVE_OK != consume(a, to_skip))\n            return ARCHIVE_EOF;\n\n        rar->file.bytes_remaining -= to_skip;\n\n        /* The block size gives information about the whole block size, but\n         * the block could be stored in split form when using multi-volume\n         * archives. In this case, the block size will be bigger than the\n         * actual data stored in this file. Remaining part of the data will\n         * be in another file. */\n\n        ssize_t cur_block_size =\n            rar5_min(rar->file.bytes_remaining, block_size);\n\n        if(block_size > rar->file.bytes_remaining) {\n            /* If current blocks' size is bigger than our data size, this\n             * means we have a multivolume archive. In this case, skip\n             * all base headers until the end of the file, proceed to next\n             * \"partXXX.rar\" volume, find its signature, skip all headers up\n             * to the first FILE base header, and continue from there.\n             *\n             * Note that `merge_block` will update the `rar` context structure\n             * quite extensively. */\n\n            ret = merge_block(a, block_size, &p);\n            if(ret != ARCHIVE_OK) {\n                return ret;\n            }\n\n            cur_block_size = block_size;\n\n            /* Current stream pointer should be now directly *after* the\n             * block that spanned through multiple archive files. `p` pointer\n             * should have the data of the *whole* block (merged from\n             * partial blocks stored in multiple archives files). */\n        } else {\n            rar->cstate.switch_multivolume = 0;\n\n            /* Read the whole block size into memory. This can take up to\n             * 8 megabytes of memory in theoretical cases. Might be worth to\n             * optimize this and use a standard chunk of 4kb's. */\n\n            if(!read_ahead(a, 4 + cur_block_size, &p)) {\n                /* Failed to prefetch block data. */\n                return ARCHIVE_EOF;\n            }\n        }\n\n        rar->cstate.block_buf = p;\n        rar->cstate.cur_block_size = cur_block_size;\n\n        rar->bits.in_addr = 0;\n        rar->bits.bit_addr = 0;\n\n        if(bf_is_table_present(&rar->last_block_hdr)) {\n            /* Load Huffman tables. */\n            ret = parse_tables(a, rar, p);\n            if(ret != ARCHIVE_OK) {\n                /* Error during decompression of Huffman tables. */\n                return ret;\n            }\n        }\n    } else {\n        p = rar->cstate.block_buf;\n    }\n\n    /* Uncompress the block, or a part of it, depending on how many bytes\n     * will be generated by uncompressing the block.\n     *\n     * In case too many bytes will be generated, calling this function again\n     * will resume the uncompression operation. */\n    ret = do_uncompress_block(a, p);\n    if(ret != ARCHIVE_OK) {\n        return ret;\n    }\n\n    if(rar->cstate.block_parsing_finished &&\n            rar->cstate.switch_multivolume == 0 &&\n            rar->cstate.cur_block_size > 0)\n    {\n        /* If we're processing a normal block, consume the whole block. We\n         * can do this because we've already read the whole block to memory.\n         */\n        if(ARCHIVE_OK != consume(a, rar->cstate.cur_block_size))\n            return ARCHIVE_FATAL;\n\n        rar->file.bytes_remaining -= rar->cstate.cur_block_size;\n    } else if(rar->cstate.switch_multivolume) {\n        /* Don't consume the block if we're doing multivolume processing.\n         * The volume switching function will consume the proper count of\n         * bytes instead. */\n\n        rar->cstate.switch_multivolume = 0;\n    }\n\n    return ARCHIVE_OK;\n}\n\nstatic int do_uncompress_file(struct archive_read* a) {\n    struct rar5* rar = get_context(a);\n    int ret;\n    int64_t max_end_pos;\n\n    if(!rar->cstate.initialized) {\n        /* Don't perform full context reinitialization if we're processing\n         * a solid archive. */\n        if(!rar->main.solid || !rar->cstate.window_buf) {\n            init_unpack(rar);\n        }\n\n        rar->cstate.initialized = 1;\n    }\n\n    if(rar->cstate.all_filters_applied == 1) {\n        /* We use while(1) here, but standard case allows for just 1 iteration.\n         * The loop will iterate if process_block() didn't generate any data at\n         * all. This can happen if the block contains only filter definitions\n         * (this is common in big files). */\n\n        while(1) {\n            ret = process_block(a);\n            if(ret == ARCHIVE_EOF || ret == ARCHIVE_FATAL)\n                return ret;\n\n            if(rar->cstate.last_write_ptr == rar->cstate.write_ptr) {\n                /* The block didn't generate any new data, so just process\n                 * a new block. */\n                continue;\n            }\n\n            /* The block has generated some new data, so break the loop. */\n            break;\n        }\n    }\n\n    /* Try to run filters. If filters won't be applied, it means that\n     * insufficient data was generated. */\n    ret = apply_filters(a);\n    if(ret == ARCHIVE_RETRY) {\n        return ARCHIVE_OK;\n    } else if(ret == ARCHIVE_FATAL) {\n        return ARCHIVE_FATAL;\n    }\n\n    /* If apply_filters() will return ARCHIVE_OK, we can continue here. */\n\n    if(cdeque_size(&rar->cstate.filters) > 0) {\n        /* Check if we can write something before hitting first filter. */\n        struct filter_info* flt;\n\n        /* Get the block_start offset from the first filter. */\n        if(CDE_OK != cdeque_front(&rar->cstate.filters, cdeque_filter_p(&flt)))\n        {\n            archive_set_error(&a->archive, ARCHIVE_ERRNO_PROGRAMMER,\n                    \"Can't read first filter\");\n            return ARCHIVE_FATAL;\n        }\n\n        max_end_pos = rar5_min(flt->block_start, rar->cstate.write_ptr);\n    } else {\n        /* There are no filters defined, or all filters were applied. This\n         * means we can just store the data without any postprocessing. */\n        max_end_pos = rar->cstate.write_ptr;\n    }\n\n    if(max_end_pos == rar->cstate.last_write_ptr) {\n        /* We can't write anything yet. The block uncompression function did\n         * not generate enough data, and no filter can be applied. At the same\n         * time we don't have any data that can be stored without filter\n         * postprocessing. This means we need to wait for more data to be\n         * generated, so we can apply the filters.\n         *\n         * Signal the caller that we need more data to be able to do anything.\n         */\n        return ARCHIVE_RETRY;\n    } else {\n        /* We can write the data before hitting the first filter. So let's\n         * do it. The push_window_data() function will effectively return\n         * the selected data block to the user application. */\n        push_window_data(a, rar, rar->cstate.last_write_ptr, max_end_pos);\n        rar->cstate.last_write_ptr = max_end_pos;\n    }\n\n    return ARCHIVE_OK;\n}\n\nstatic int uncompress_file(struct archive_read* a) {\n    int ret;\n\n    while(1) {\n        /* Sometimes the uncompression function will return a 'retry' signal.\n         * If this will happen, we have to retry the function. */\n        ret = do_uncompress_file(a);\n        if(ret != ARCHIVE_RETRY)\n            return ret;\n    }\n}\n\nstatic int rar5_read_data(struct archive_read *a, const void **buff,\n                                  size_t *size, int64_t *offset) {\n    int ret;\n    struct rar5* rar = get_context(a);\n\n    if(!rar->skip_mode && (rar->cstate.last_write_ptr > rar->file.unpacked_size)) {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_PROGRAMMER,\n                \"Unpacker has written too many bytes\");\n        return ARCHIVE_FATAL;\n    }\n\n    ret = use_data(rar, buff, size, offset);\n    if(ret == ARCHIVE_OK) {\n        return ret;\n    }\n\n    if(rar->file.eof == 1) {\n        return ARCHIVE_EOF;\n    }\n\n    ret = do_unpack(a, rar, buff, size, offset);\n    if(ret != ARCHIVE_OK) {\n        return ret;\n    }\n\n    if(rar->file.bytes_remaining == 0 &&\n            rar->cstate.last_write_ptr == rar->file.unpacked_size)\n    {\n        /* If all bytes of current file were processed, run finalization.\n         *\n         * Finalization will check checksum against proper values. If\n         * some of the checksums will not match, we'll return an error\n         * value in the last `archive_read_data` call to signal an error\n         * to the user. */\n\n        rar->file.eof = 1;\n        return verify_global_checksums(a);\n    }\n\n    return ARCHIVE_OK;\n}\n\nla_ssize_t\narchive_read_data(struct archive *_a, void *buff, size_t s)\n{\n\tstruct archive *a = (struct archive *)_a;\n\tchar\t*dest;\n\tconst void *read_buf;\n\tsize_t\t bytes_read;\n\tsize_t\t len;\n\tint\t r;\n\n\tbytes_read = 0;\n\tdest = (char *)buff;\n\n\twhile (s > 0) {\n\t\tif (a->read_data_remaining == 0) {\n\t\t\tread_buf = a->read_data_block;\n\t\t\ta->read_data_is_posix_read = 1;\n\t\t\ta->read_data_requested = s;\n\t\t\tr = archive_read_data_block(a, &read_buf,\n\t\t\t    &a->read_data_remaining, &a->read_data_offset);\n\t\t\ta->read_data_block = read_buf;\n\t\t\tif (r == ARCHIVE_EOF)\n\t\t\t\treturn (bytes_read);\n\t\t\t/*\n\t\t\t * Error codes are all negative, so the status\n\t\t\t * return here cannot be confused with a valid\n\t\t\t * byte count.  (ARCHIVE_OK is zero.)\n\t\t\t */\n\t\t\tif (r < ARCHIVE_OK)\n\t\t\t\treturn (r);\n\t\t}\n\n\t\tif (a->read_data_offset < a->read_data_output_offset) {\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Encountered out-of-order sparse blocks\");\n\t\t\treturn (ARCHIVE_RETRY);\n\t\t}\n\n\t\t/* Compute the amount of zero padding needed. */\n\t\tif (a->read_data_output_offset + (int64_t)s <\n\t\t    a->read_data_offset) {\n\t\t\tlen = s;\n\t\t} else if (a->read_data_output_offset <\n\t\t    a->read_data_offset) {\n\t\t\tlen = (size_t)(a->read_data_offset -\n\t\t\t    a->read_data_output_offset);\n\t\t} else\n\t\t\tlen = 0;\n\n\t\t/* Add zeroes. */\n\t\tmemset(dest, 0, len);\n\t\ts -= len;\n\t\ta->read_data_output_offset += len;\n\t\tdest += len;\n\t\tbytes_read += len;\n\n\t\t/* Copy data if there is any space left. */\n\t\tif (s > 0) {\n\t\t\tlen = a->read_data_remaining;\n\t\t\tif (len > s)\n\t\t\t\tlen = s;\n\t\t\tif (len)\n\t\t\t\tmemcpy(dest, a->read_data_block, len);\n\t\t\ts -= len;\n\t\t\ta->read_data_block += len;\n\t\t\ta->read_data_remaining -= len;\n\t\t\ta->read_data_output_offset += len;\n\t\t\ta->read_data_offset += len;\n\t\t\tdest += len;\n\t\t\tbytes_read += len;\n\t\t}\n\t}\n\ta->read_data_is_posix_read = 0;\n\ta->read_data_requested = 0;\n\treturn (bytes_read);\n}\n\n\n// target function\nstatic void init_unpack(struct rar5* rar) {\n    rar->file.calculated_crc32 = 0;\n    rar->cstate.window_mask = rar->cstate.window_size - 1;\n\n    if(rar->cstate.window_buf)\n        free(rar->cstate.window_buf);\n\n    if(rar->cstate.filtered_buf)\n        free(rar->cstate.filtered_buf);\n\n    rar->cstate.window_buf = calloc(1, rar->cstate.window_size);\n    rar->cstate.filtered_buf = calloc(1, rar->cstate.window_size);\n\n    rar->cstate.write_ptr = 0;\n    rar->cstate.last_write_ptr = 0;\n\n    memset(&rar->cstate.bd, 0, sizeof(rar->cstate.bd));\n    memset(&rar->cstate.ld, 0, sizeof(rar->cstate.ld));\n    memset(&rar->cstate.dd, 0, sizeof(rar->cstate.dd));\n    memset(&rar->cstate.ldd, 0, sizeof(rar->cstate.ldd));\n    memset(&rar->cstate.rd, 0, sizeof(rar->cstate.rd));\n}\n",
    "target": 1,
    "idx": 1011011,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nint LibRaw_file_datastream::read(void *ptr, size_t size, size_t nmemb)\n{\n/* Visual Studio 2008 marks sgetn as insecure, but VS2010 does not. */\n#if defined(WIN32SECURECALLS) && (_MSC_VER < 1600)\n  LR_STREAM_CHK();\n  return int(f->_Sgetn_s(static_cast<char *>(ptr), nmemb * size, nmemb * size) /\n             (size > 0 ? size : 1));\n#else\n  LR_STREAM_CHK();\n  return int(f->sgetn(static_cast<char *>(ptr), std::streamsize(nmemb * size)) /\n             (size > 0 ? size : 1));\n#endif\n}\n\nvoid LibRaw::uncompressed_fp_dng_load_raw()\n{\n    int iifd = find_ifd_by_offset(libraw_internal_data.unpacker_data.data_offset);\n    if (iifd < 0 || iifd > (int)libraw_internal_data.identify_data.tiff_nifds)\n        throw LIBRAW_EXCEPTION_DECODE_RAW;\n    struct tiff_ifd_t *ifd = &tiff_ifd[iifd];\n\n    float *float_raw_image = 0;\n\n    if (ifd->samples != 1 && ifd->samples != 3 && ifd->samples != 4)\n        throw LIBRAW_EXCEPTION_DECODE_RAW; \n\n    if(imgdata.idata.filters && ifd->samples > 1)\n      throw LIBRAW_EXCEPTION_DECODE_RAW;\n\n    if ((int)libraw_internal_data.unpacker_data.tiff_samples != ifd->samples)\n        throw LIBRAW_EXCEPTION_DECODE_RAW; // Wrong IFD\n\n    int bytesps = (ifd->bps + 7) >> 3; // round to upper value\n\n\tif(bytesps < 1 || bytesps > 4)\n      throw LIBRAW_EXCEPTION_DECODE_RAW;\n\n    tile_stripe_data_t tiles;\n    tiles.init(ifd, imgdata.sizes, libraw_internal_data.unpacker_data, libraw_internal_data.unpacker_data.order,\n        libraw_internal_data.internal_data.input);\n\n\tINT64 allocsz = INT64(tiles.tileCnt) * INT64(tiles.tileWidth) * INT64(tiles.tileHeight) * INT64(ifd->samples) * INT64(sizeof(float));\n\tif (allocsz > INT64(imgdata.rawparams.max_raw_memory_mb) * INT64(1024 * 1024))\n\t\tthrow LIBRAW_EXCEPTION_TOOBIG;\n\n    if (ifd->sample_format == 3)\n        float_raw_image = (float *)calloc(tiles.tileCnt * tiles.tileWidth * tiles.tileHeight *ifd->samples, sizeof(float));\n    else\n        throw LIBRAW_EXCEPTION_DECODE_RAW; // Only float supported\n\n    bool difford = (libraw_internal_data.unpacker_data.order == 0x4949) == (ntohs(0x1234) == 0x1234);\n    float max = 0.f;\n\n    std::vector<uchar> rowbuf(tiles.tileWidth *sizeof(float) * ifd->samples); // line buffer for last tile in tile row\n\n    for (size_t y = 0, t = 0; y < imgdata.sizes.raw_height; y += tiles.tileHeight)\n    {\n        for (unsigned x = 0; x < imgdata.sizes.raw_width  && t < (unsigned)tiles.tileCnt; x += tiles.tileWidth, ++t)\n        {\n            libraw_internal_data.internal_data.input->seek(tiles.tOffsets[t], SEEK_SET);\n            size_t rowsInTile = y + tiles.tileHeight > imgdata.sizes.raw_height ? imgdata.sizes.raw_height - y : tiles.tileHeight;\n            size_t colsInTile = x + tiles.tileWidth > imgdata.sizes.raw_width ? imgdata.sizes.raw_width - x : tiles.tileWidth;\n\n            size_t inrowbytes = colsInTile * bytesps * ifd->samples;\n            int fullrowbytes = tiles.tileWidth *bytesps * ifd->samples;\n            size_t outrowbytes = colsInTile * sizeof(float) * ifd->samples;\n\n            for (size_t row = 0; row < rowsInTile; ++row) // do not process full tile if not needed\n            {\n                unsigned char *dst = fullrowbytes > inrowbytes ? rowbuf.data(): // last tile in row, use buffer\n                    (unsigned char *)&float_raw_image\n                    [((y + row) * imgdata.sizes.raw_width + x) * ifd->samples];\n                libraw_internal_data.internal_data.input->read(dst, 1, fullrowbytes);\n                if (bytesps == 2 && difford)\n                    libraw_swab(dst, fullrowbytes);\n                else if (bytesps == 3 && (libraw_internal_data.unpacker_data.order == 0x4949)) // II-16bit\n                    swap24(dst, fullrowbytes);\n                if (bytesps == 4 && difford)\n                    swap32(dst, fullrowbytes);\n\n                float lmax = expandFloats(\n                    dst,\n                    tiles.tileWidth * ifd->samples,\n                    bytesps);\n                if (fullrowbytes > inrowbytes) // last tile in row: copy buffer to destination\n                    memmove(&float_raw_image[((y + row) * imgdata.sizes.raw_width + x) * ifd->samples], dst, outrowbytes);\n                max = MAX(max, lmax);\n            }\n        }\n    }\n\n    imgdata.color.fmaximum = max;\n\n    // setup outpuf fields\n    imgdata.rawdata.raw_alloc = float_raw_image;\n    if (ifd->samples == 1)\n    {\n        imgdata.rawdata.float_image = float_raw_image;\n        imgdata.rawdata.sizes.raw_pitch = imgdata.sizes.raw_pitch =\n            imgdata.sizes.raw_width * 4;\n    }\n    else if (ifd->samples == 3)\n    {\n        imgdata.rawdata.float3_image = (float(*)[3])float_raw_image;\n        imgdata.rawdata.sizes.raw_pitch = imgdata.sizes.raw_pitch =\n            imgdata.sizes.raw_width * 12;\n    }\n    else if (ifd->samples == 4)\n    {\n        imgdata.rawdata.float4_image = (float(*)[4])float_raw_image;\n        imgdata.rawdata.sizes.raw_pitch = imgdata.sizes.raw_pitch =\n            imgdata.sizes.raw_width * 16;\n    }\n\n    if (imgdata.rawparams.options & LIBRAW_RAWOPTIONS_CONVERTFLOAT_TO_INT)\n        convertFloatToInt();  \n}\n\nint LibRaw::unpack(void)\n{\n  CHECK_ORDER_HIGH(LIBRAW_PROGRESS_LOAD_RAW);\n  CHECK_ORDER_LOW(LIBRAW_PROGRESS_IDENTIFY);\n  try\n  {\n\n    if (!libraw_internal_data.internal_data.input)\n      return LIBRAW_INPUT_CLOSED;\n\n    RUN_CALLBACK(LIBRAW_PROGRESS_LOAD_RAW, 0, 2);\n    if (imgdata.rawparams.shot_select >= P1.raw_count)\n      return LIBRAW_REQUEST_FOR_NONEXISTENT_IMAGE;\n\n    if (!load_raw)\n      return LIBRAW_UNSPECIFIED_ERROR;\n\n    // already allocated ?\n    if (imgdata.image)\n    {\n      free(imgdata.image);\n      imgdata.image = 0;\n    }\n    if (imgdata.rawdata.raw_alloc)\n    {\n      free(imgdata.rawdata.raw_alloc);\n      imgdata.rawdata.raw_alloc = 0;\n    }\n    if (libraw_internal_data.unpacker_data.meta_length)\n    {\n      if (libraw_internal_data.unpacker_data.meta_length >\n          INT64(imgdata.rawparams.max_raw_memory_mb) * INT64(1024 * 1024))\n        throw LIBRAW_EXCEPTION_TOOBIG;\n\n      libraw_internal_data.internal_data.meta_data =\n          (char *)malloc(libraw_internal_data.unpacker_data.meta_length);\n    }\n\n    libraw_decoder_info_t decoder_info;\n    get_decoder_info(&decoder_info);\n\n    int save_iwidth = S.iwidth, save_iheight = S.iheight,\n        save_shrink = IO.shrink;\n\n    int rwidth = S.raw_width, rheight = S.raw_height;\n    if (!IO.fuji_width)\n    {\n      // adjust non-Fuji allocation\n      if (rwidth < S.width + S.left_margin)\n        rwidth = S.width + S.left_margin;\n      if (rheight < S.height + S.top_margin)\n        rheight = S.height + S.top_margin;\n    }\n    if (rwidth > 65535 ||\n        rheight > 65535) // No way to make image larger than 64k pix\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n    imgdata.rawdata.raw_image = 0;\n    imgdata.rawdata.color4_image = 0;\n    imgdata.rawdata.color3_image = 0;\n    imgdata.rawdata.float_image = 0;\n    imgdata.rawdata.float3_image = 0;\n\n#ifdef USE_DNGSDK\n    if (imgdata.idata.dng_version && dnghost\n        && libraw_internal_data.unpacker_data.tiff_samples != 2  // Fuji SuperCCD; it is better to detect is more rigid way\n        && valid_for_dngsdk() && load_raw != &LibRaw::pentax_4shot_load_raw)\n    {\n      // Data size check\n      INT64 pixcount =\n          INT64(MAX(S.width, S.raw_width)) * INT64(MAX(S.height, S.raw_height));\n      INT64 planecount =\n          (imgdata.idata.filters || P1.colors == 1) ? 1 : LIM(P1.colors, 3, 4);\n      INT64 samplesize = is_floating_point() ? 4 : 2;\n      INT64 bytes = pixcount * planecount * samplesize;\n      if (bytes + INT64(libraw_internal_data.unpacker_data.meta_length )\n\t\t\t> INT64(imgdata.rawparams.max_raw_memory_mb) * INT64(1024 * 1024))\n        throw LIBRAW_EXCEPTION_TOOBIG;\n\n      // find ifd to check sample\n      try_dngsdk();\n      if (raw_was_read())\n        imgdata.process_warnings |= LIBRAW_WARN_DNGSDK_PROCESSED;\n    }\n#endif\n#ifdef USE_RAWSPEED3\n    if (!raw_was_read()\n        && (!IO.fuji_width) // Do not use for fuji rotated\n        && ((imgdata.idata.raw_count == 1) \n            // Canon dual pixel, 1st frame\n            || (makeIs(LIBRAW_CAMERAMAKER_Canon) && imgdata.idata.raw_count == 2 && imgdata.rawparams.shot_select==0)\n            )\n#ifdef USE_RAWSPEED_BITS\n        && (imgdata.rawparams.use_rawspeed & LIBRAW_RAWSPEEDV3_USE)\n#else\n        && imgdata.rawparams.use_rawspeed\n#endif\n        && (decoder_info.decoder_flags & LIBRAW_DECODER_TRYRAWSPEED3)\n        )\n    {\n      INT64 pixcount = INT64(MAX(S.width, S.raw_width)) * INT64(MAX(S.height, S.raw_height));\n      INT64 planecount = (imgdata.idata.filters || P1.colors == 1) ? 1 : LIM(P1.colors, 3, 4);\n      INT64 bytes = pixcount * planecount * 2; // sample size is always 2 for rawspeed\n      if (bytes + INT64(libraw_internal_data.unpacker_data.meta_length) \n\t\t\t\t> INT64(imgdata.rawparams.max_raw_memory_mb) * INT64(1024 * 1024))\n        throw LIBRAW_EXCEPTION_TOOBIG;\n\n        if (!_rawspeed3_handle)\n            _rawspeed3_handle = rawspeed3_initdefault();\n\n        if (_rawspeed3_handle && ID.input->size() > 0) // large bound is checked at identify\n        {\n            void *_rawspeed_buffer = 0;\n            try {\n                ID.input->seek(0, SEEK_SET);\n                INT64 _rawspeed_buffer_sz = ID.input->size() + 32;\n                _rawspeed_buffer = malloc(_rawspeed_buffer_sz);\n                if (!_rawspeed_buffer)\n                    throw LIBRAW_EXCEPTION_ALLOC;\n                ID.input->read(_rawspeed_buffer, ID.input->size(), 1);\n\n                rawspeed3_ret_t rs3ret;\n                rawspeed3_clearresult(&rs3ret);\n                int status = rawspeed3_decodefile(_rawspeed3_handle, &rs3ret, _rawspeed_buffer, ID.input->size(),\n#ifdef USE_RAWSPEED_BITS\n                    !(imgdata.rawparams.use_rawspeed & LIBRAW_RAWSPEEDV3_FAILONUNKNOWN)\n#else\n                    false\n#endif\n                );\n                if (status != rawspeed3_ok)\n                  imgdata.process_warnings |= LIBRAW_WARN_RAWSPEED_UNSUPPORTED;\n\n                if (status == rawspeed3_not_supported)\n                  imgdata.process_warnings |= LIBRAW_WARN_RAWSPEED3_NOTLISTED;\n\n                if (status == rawspeed3_ok\n#ifdef USE_RAWSPEED_BITS\n                    ||\n                    (status == rawspeed3_ok_warnings && (imgdata.rawparams.use_rawspeed & LIBRAW_RAWSPEEDV3_IGNOREERRORS))\n#endif\n                    )\n                {\n\n                  if ((S.raw_width != rs3ret.width) || (S.raw_height != rs3ret.height))\n                      throw \"Size mismatch\";\n\n                    // DECODED w/ success\n                  if (rs3ret.filters>1) // Fuji or bayer\n                      imgdata.rawdata.raw_image = (ushort*)rs3ret.pixeldata;\n                  else if (rs3ret.cpp == 4)\n                  {\n                      imgdata.rawdata.color4_image = (ushort(*)[4])rs3ret.pixeldata;\n                    //if (r->whitePoint > 0 && r->whitePoint < 65536)\n                    //  C.maximum = r->whitePoint;\n                  }\n                  else if (rs3ret.cpp == 3)\n                  {\n                      imgdata.rawdata.color3_image = (ushort(*)[3])rs3ret.pixeldata;\n                    //if (r->whitePoint > 0 && r->whitePoint < 65536)\n                    //  C.maximum = r->whitePoint;\n                  }\n\n                  if (raw_was_read()) // buffers are assigned above\n                  {\n                    // set sizes\n                    S.raw_pitch = rs3ret.pitch;\n                    S.raw_width = rs3ret.width;\n                    S.raw_height = rs3ret.height;\n                    imgdata.process_warnings |= LIBRAW_WARN_RAWSPEED3_PROCESSED;\n                    // if (r->whitePoint > 0 && r->whitePoint < 65536)\n                    // C.maximum = r->whitePoint;\n                  }\n                }\n                free(_rawspeed_buffer);\n            }\n            catch (...)\n            {\n                imgdata.process_warnings |= LIBRAW_WARN_RAWSPEED3_PROBLEM;\n                if (_rawspeed_buffer)\n                    free(_rawspeed_buffer);\n            }\n         }\n    }\n#endif\n#ifdef USE_RAWSPEED\n    if (!raw_was_read())\n    {\n      int rawspeed_enabled = 1;\n\n      if (imgdata.idata.dng_version && (libraw_internal_data.unpacker_data.tiff_samples == 2 || imgdata.idata.raw_count > 1))\n        rawspeed_enabled = 0;\n\n      if (libraw_internal_data.unpacker_data.is_NikonTransfer)\n        rawspeed_enabled = 0;\n\n      if (libraw_internal_data.unpacker_data.pana_encoding == 5)\n        rawspeed_enabled = 0;\n\n      if (imgdata.idata.raw_count > 1)\n        rawspeed_enabled = 0;\n      if (!strncasecmp(imgdata.idata.software, \"Magic\", 5))\n        rawspeed_enabled = 0;\n      // Disable rawspeed for double-sized Oly files\n      if (makeIs(LIBRAW_CAMERAMAKER_Olympus) &&\n          ((imgdata.sizes.raw_width > 6000) ||\n           !strncasecmp(imgdata.idata.model, \"SH-\", 3) ||\n           !strncasecmp(imgdata.idata.model, \"TG-\", 3) ))\n        rawspeed_enabled = 0;\n\n      if (makeIs(LIBRAW_CAMERAMAKER_Canon) &&\n          (libraw_internal_data.identify_data.unique_id == CanonID_EOS_6D_Mark_II))\n        rawspeed_enabled = 0;\n\n      if (imgdata.idata.dng_version && imgdata.idata.filters == 0 &&\n          libraw_internal_data.unpacker_data.tiff_bps == 8) // Disable for 8 bit\n        rawspeed_enabled = 0;\n\n      if (load_raw == &LibRaw::packed_load_raw &&\n        makeIs(LIBRAW_CAMERAMAKER_Nikon) &&\n          (!strncasecmp(imgdata.idata.model, \"E\", 1) ||\n           !strncasecmp(imgdata.idata.model, \"COOLPIX B\", 9) ||\n\t\t   !strncasecmp(imgdata.idata.model, \"COOLPIX P9\", 10) ||\n           !strncasecmp(imgdata.idata.model, \"COOLPIX P1000\", 13)))\n        rawspeed_enabled = 0;\n\n      if (load_raw == &LibRaw::nikon_load_raw && makeIs(LIBRAW_CAMERAMAKER_Nikon) &&\n          !strcasecmp(imgdata.idata.model, \"D6\"))\n        rawspeed_enabled = 0;\n\n\tif (load_raw == &LibRaw::lossless_jpeg_load_raw &&\n\t\tMN.canon.RecordMode && makeIs(LIBRAW_CAMERAMAKER_Kodak) &&\n\t\t/* Not normalized models here, it is intentional */\n\t\t(!strncasecmp(imgdata.idata.model, \"EOS D2000\", 9) ||\n\t\t !strncasecmp(imgdata.idata.model, \"EOS D6000\", 9)))\n\t  rawspeed_enabled = 0;\n\n      if (load_raw == &LibRaw::nikon_load_raw &&\n        makeIs(LIBRAW_CAMERAMAKER_Nikon) &&\n          (!strncasecmp(imgdata.idata.model, \"Z\", 1) || !strncasecmp(imgdata.idata.model,\"D780\",4)))\n        rawspeed_enabled = 0;\n\n      if (load_raw == &LibRaw::panasonic_load_raw &&\n          libraw_internal_data.unpacker_data.pana_encoding > 4)\n        rawspeed_enabled = 0;\n\n      // RawSpeed Supported,\n      if (\n#ifdef USE_RAWSPEED_BITS\n          (imgdata.rawparams.use_rawspeed & LIBRAW_RAWSPEEDV1_USE)\n#else\n          imgdata.rawparams.use_rawspeed \n#endif\n          && rawspeed_enabled &&\n          !(is_sraw() && (imgdata.rawparams.specials &\n                          (LIBRAW_RAWSPECIAL_SRAW_NO_RGB |\n                           LIBRAW_RAWSPECIAL_SRAW_NO_INTERPOLATE))) &&\n          (decoder_info.decoder_flags & LIBRAW_DECODER_TRYRAWSPEED) &&\n          _rawspeed_camerameta)\n      {\n        INT64 pixcount = INT64(MAX(S.width, S.raw_width)) *\n                         INT64(MAX(S.height, S.raw_height));\n        INT64 planecount = (imgdata.idata.filters || P1.colors == 1)\n                               ? 1\n                               : LIM(P1.colors, 3, 4);\n        INT64 bytes =\n            pixcount * planecount * 2; // sample size is always 2 for rawspeed\n        if (bytes + +INT64(libraw_internal_data.unpacker_data.meta_length) >\n            INT64(imgdata.rawparams.max_raw_memory_mb) * INT64(1024 * 1024))\n          throw LIBRAW_EXCEPTION_TOOBIG;\n\n        /*int rr = */ try_rawspeed();\n\n      }\n    }\n#endif\n    if (!raw_was_read()) // RawSpeed failed or not run\n    {\n      // Not allocated on RawSpeed call, try call LibRaow\n      int zero_rawimage = 0;\n      if (decoder_info.decoder_flags & LIBRAW_DECODER_OWNALLOC)\n      {\n        // x3f foveon decoder and DNG float\n        // Do nothing! Decoder will allocate data internally\n      }\n      if (decoder_info.decoder_flags & LIBRAW_DECODER_SINAR4SHOT)\n      {\n        if (imgdata.rawparams.shot_select) // single image extract\n        {\n          if (INT64(rwidth) * INT64(rheight + 8) *\n                  INT64(sizeof(imgdata.rawdata.raw_image[0])) \n\t\t\t\t+ +INT64(libraw_internal_data.unpacker_data.meta_length) >\n              INT64(imgdata.rawparams.max_raw_memory_mb) * INT64(1024 * 1024))\n            throw LIBRAW_EXCEPTION_TOOBIG;\n          imgdata.rawdata.raw_alloc = malloc(\n              rwidth * (rheight + 8) * sizeof(imgdata.rawdata.raw_image[0]));\n          imgdata.rawdata.raw_image = (ushort *)imgdata.rawdata.raw_alloc;\n          if (!S.raw_pitch)\n            S.raw_pitch = S.raw_width * 2; // Bayer case, not set before\n        }\n        else // Full image extract\n        {\n          if (INT64(rwidth) * INT64(rheight + 8) *\n                  INT64(sizeof(imgdata.rawdata.raw_image[0])) * 4 \n\t\t\t\t+INT64(libraw_internal_data.unpacker_data.meta_length) >\n              INT64(imgdata.rawparams.max_raw_memory_mb) * INT64(1024 * 1024))\n            throw LIBRAW_EXCEPTION_TOOBIG;\n          S.raw_pitch = S.raw_width * 8;\n          imgdata.rawdata.raw_alloc = 0;\n          imgdata.image = (ushort(*)[4])calloc(\n              unsigned(MAX(S.width, S.raw_width)) *\n                  unsigned(MAX(S.height, S.raw_height) + 8),\n              sizeof(*imgdata.image));\n        }\n      }\n      else if (decoder_info.decoder_flags & LIBRAW_DECODER_3CHANNEL)\n      {\n        if (INT64(rwidth) * INT64(rheight + 8) *\n                INT64(sizeof(imgdata.rawdata.raw_image[0])) * 3 \n\t\t\t+ INT64(libraw_internal_data.unpacker_data.meta_length) >\n            INT64(imgdata.rawparams.max_raw_memory_mb) * INT64(1024 * 1024))\n          throw LIBRAW_EXCEPTION_TOOBIG;\n\n        imgdata.rawdata.raw_alloc = malloc(\n            rwidth * (rheight + 8) * sizeof(imgdata.rawdata.raw_image[0]) * 3);\n        imgdata.rawdata.color3_image = (ushort(*)[3])imgdata.rawdata.raw_alloc;\n        if (!S.raw_pitch)\n          S.raw_pitch = S.raw_width * 6;\n      }\n      else if (imgdata.idata.filters ||\n               P1.colors ==\n                   1) // Bayer image or single color -> decode to raw_image\n      {\n        if (INT64(rwidth) * INT64(rheight + 8) *\n                INT64(sizeof(imgdata.rawdata.raw_image[0])) \n\t\t\t+ INT64(libraw_internal_data.unpacker_data.meta_length) >\n            INT64(imgdata.rawparams.max_raw_memory_mb) * INT64(1024 * 1024))\n          throw LIBRAW_EXCEPTION_TOOBIG;\n        imgdata.rawdata.raw_alloc = malloc(\n            rwidth * (rheight + 8) * sizeof(imgdata.rawdata.raw_image[0]));\n        imgdata.rawdata.raw_image = (ushort *)imgdata.rawdata.raw_alloc;\n        if (!S.raw_pitch)\n          S.raw_pitch = S.raw_width * 2; // Bayer case, not set before\n      }\n      else // NO LEGACY FLAG if (decoder_info.decoder_flags &\n           // LIBRAW_DECODER_LEGACY)\n      {\n        if (decoder_info.decoder_flags & LIBRAW_DECODER_ADOBECOPYPIXEL)\n        {\n          S.raw_pitch = S.raw_width * 8;\n        }\n        else\n        {\n          S.iwidth = S.width;\n          S.iheight = S.height;\n          IO.shrink = 0;\n          if (!S.raw_pitch)\n            S.raw_pitch = (decoder_info.decoder_flags &\n                           LIBRAW_DECODER_LEGACY_WITH_MARGINS)\n                              ? S.raw_width * 8\n                              : S.width * 8;\n        }\n        // sRAW and old Foveon decoders only, so extra buffer size is just 1/4\n        // allocate image as temporary buffer, size\n        if (INT64(MAX(S.width, S.raw_width)) *\n                INT64(MAX(S.height, S.raw_height) + 8) *\n                INT64(sizeof(*imgdata.image)) \n\t\t\t+ INT64(libraw_internal_data.unpacker_data.meta_length) >\n            INT64(imgdata.rawparams.max_raw_memory_mb) * INT64(1024 * 1024))\n          throw LIBRAW_EXCEPTION_TOOBIG;\n\n        imgdata.rawdata.raw_alloc = 0;\n        imgdata.image =\n            (ushort(*)[4])calloc(unsigned(MAX(S.width, S.raw_width)) *\n                                     unsigned(MAX(S.height, S.raw_height) + 8),\n                                 sizeof(*imgdata.image));\n        if (!(decoder_info.decoder_flags & LIBRAW_DECODER_ADOBECOPYPIXEL))\n        {\n          imgdata.rawdata.raw_image = (ushort *)imgdata.image;\n          zero_rawimage = 1;\n        }\n      }\n      ID.input->seek(libraw_internal_data.unpacker_data.data_offset, SEEK_SET);\n\n      unsigned m_save = C.maximum;\n      if (load_raw == &LibRaw::unpacked_load_raw &&\n          (!strcasecmp(imgdata.idata.make, \"Nikon\") || !strcasecmp(imgdata.idata.make, \"Hasselblad\"))\n          )\n        C.maximum = 65535;\n      (this->*load_raw)();\n      if (zero_rawimage)\n        imgdata.rawdata.raw_image = 0;\n      if (load_raw == &LibRaw::unpacked_load_raw &&\n          (!strcasecmp(imgdata.idata.make, \"Nikon\") || !strcasecmp(imgdata.idata.make, \"Hasselblad\"))\n          )\n        C.maximum = m_save;\n      if (decoder_info.decoder_flags & LIBRAW_DECODER_OWNALLOC)\n      {\n        // x3f foveon decoder only: do nothing\n      }\n      else if (decoder_info.decoder_flags & LIBRAW_DECODER_SINAR4SHOT &&\n               imgdata.rawparams.shot_select == 0)\n      {\n        imgdata.rawdata.raw_alloc = imgdata.image;\n        imgdata.rawdata.color4_image = (ushort(*)[4])imgdata.rawdata.raw_alloc;\n        imgdata.image = 0;\n      }\n      else if (!(imgdata.idata.filters ||\n                 P1.colors == 1)) // legacy decoder, ownalloc handled above\n      {\n        // successfully decoded legacy image, attach image to raw_alloc\n        imgdata.rawdata.raw_alloc = imgdata.image;\n        imgdata.rawdata.color4_image = (ushort(*)[4])imgdata.rawdata.raw_alloc;\n        imgdata.image = 0;\n        // Restore saved values. Note: Foveon have masked frame\n        // Other 4-color legacy data: no borders\n        if (!(libraw_internal_data.unpacker_data.load_flags & 256) &&\n            !(decoder_info.decoder_flags & LIBRAW_DECODER_ADOBECOPYPIXEL) &&\n            !(decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY_WITH_MARGINS))\n        {\n          S.raw_width = S.width;\n          S.left_margin = 0;\n          S.raw_height = S.height;\n          S.top_margin = 0;\n        }\n      }\n    }\n\n    if (imgdata.rawdata.raw_image)\n      crop_masked_pixels(); // calculate black levels\n\n    // recover image sizes\n    S.iwidth = save_iwidth;\n    S.iheight = save_iheight;\n    IO.shrink = save_shrink;\n\n    // adjust black to possible maximum\n    unsigned int i = C.cblack[3];\n    unsigned int c;\n    for (c = 0; c < 3; c++)\n      if (i > C.cblack[c])\n        i = C.cblack[c];\n    for (c = 0; c < 4; c++)\n      C.cblack[c] -= i;\n    C.black += i;\n\n    // Save color,sizes and internal data into raw_image fields\n    memmove(&imgdata.rawdata.color, &imgdata.color, sizeof(imgdata.color));\n    memmove(&imgdata.rawdata.sizes, &imgdata.sizes, sizeof(imgdata.sizes));\n    memmove(&imgdata.rawdata.iparams, &imgdata.idata, sizeof(imgdata.idata));\n    memmove(&imgdata.rawdata.ioparams,\n            &libraw_internal_data.internal_output_params,\n            sizeof(libraw_internal_data.internal_output_params));\n\n    SET_PROC_FLAG(LIBRAW_PROGRESS_LOAD_RAW);\n    RUN_CALLBACK(LIBRAW_PROGRESS_LOAD_RAW, 1, 2);\n\n    return 0;\n  }\n  catch (const std::bad_alloc&)\n  {\n      EXCEPTION_HANDLER(LIBRAW_EXCEPTION_ALLOC);\n  }\n  catch (const LibRaw_exceptions& err)\n  {\n    EXCEPTION_HANDLER(err);\n  }\n  catch (const std::exception& )\n  {\n    EXCEPTION_HANDLER(LIBRAW_EXCEPTION_IO_CORRUPT);\n  }\n}\n\n\n// target function\nvoid LibRaw::uncompressed_fp_dng_load_raw()\n{\n    int iifd = find_ifd_by_offset(libraw_internal_data.unpacker_data.data_offset);\n    if (iifd < 0 || iifd > (int)libraw_internal_data.identify_data.tiff_nifds)\n        throw LIBRAW_EXCEPTION_DECODE_RAW;\n    struct tiff_ifd_t *ifd = &tiff_ifd[iifd];\n\n    float *float_raw_image = 0;\n\n    if (ifd->samples != 1 && ifd->samples != 3 && ifd->samples != 4)\n        throw LIBRAW_EXCEPTION_DECODE_RAW; \n\n    if(imgdata.idata.filters && ifd->samples > 1)\n      throw LIBRAW_EXCEPTION_DECODE_RAW;\n\n    if ((int)libraw_internal_data.unpacker_data.tiff_samples != ifd->samples)\n        throw LIBRAW_EXCEPTION_DECODE_RAW; // Wrong IFD\n\n    int bytesps = (ifd->bps + 7) >> 3; // round to upper value\n\n    tile_stripe_data_t tiles;\n    tiles.init(ifd, imgdata.sizes, libraw_internal_data.unpacker_data, libraw_internal_data.unpacker_data.order,\n        libraw_internal_data.internal_data.input);\n\n\tINT64 allocsz = INT64(tiles.tileCnt) * INT64(tiles.tileWidth) * INT64(tiles.tileHeight) * INT64(ifd->samples) * INT64(sizeof(float));\n\tif (allocsz > INT64(imgdata.rawparams.max_raw_memory_mb) * INT64(1024 * 1024))\n\t\tthrow LIBRAW_EXCEPTION_TOOBIG;\n\n    if (ifd->sample_format == 3)\n        float_raw_image = (float *)calloc(tiles.tileCnt * tiles.tileWidth * tiles.tileHeight *ifd->samples, sizeof(float));\n    else\n        throw LIBRAW_EXCEPTION_DECODE_RAW; // Only float supported\n\n    bool difford = (libraw_internal_data.unpacker_data.order == 0x4949) == (ntohs(0x1234) == 0x1234);\n    float max = 0.f;\n\n    std::vector<uchar> rowbuf(tiles.tileWidth *sizeof(float) * ifd->samples); // line buffer for last tile in tile row\n\n    for (size_t y = 0, t = 0; y < imgdata.sizes.raw_height; y += tiles.tileHeight)\n    {\n        for (unsigned x = 0; x < imgdata.sizes.raw_width  && t < (unsigned)tiles.tileCnt; x += tiles.tileWidth, ++t)\n        {\n            libraw_internal_data.internal_data.input->seek(tiles.tOffsets[t], SEEK_SET);\n            size_t rowsInTile = y + tiles.tileHeight > imgdata.sizes.raw_height ? imgdata.sizes.raw_height - y : tiles.tileHeight;\n            size_t colsInTile = x + tiles.tileWidth > imgdata.sizes.raw_width ? imgdata.sizes.raw_width - x : tiles.tileWidth;\n\n            size_t inrowbytes = colsInTile * bytesps * ifd->samples;\n            int fullrowbytes = tiles.tileWidth *bytesps * ifd->samples;\n            size_t outrowbytes = colsInTile * sizeof(float) * ifd->samples;\n\n            for (size_t row = 0; row < rowsInTile; ++row) // do not process full tile if not needed\n            {\n                unsigned char *dst = fullrowbytes > inrowbytes ? rowbuf.data(): // last tile in row, use buffer\n                    (unsigned char *)&float_raw_image\n                    [((y + row) * imgdata.sizes.raw_width + x) * ifd->samples];\n                libraw_internal_data.internal_data.input->read(dst, 1, fullrowbytes);\n                if (bytesps == 2 && difford)\n                    libraw_swab(dst, fullrowbytes);\n                else if (bytesps == 3 && (libraw_internal_data.unpacker_data.order == 0x4949)) // II-16bit\n                    swap24(dst, fullrowbytes);\n                if (bytesps == 4 && difford)\n                    swap32(dst, fullrowbytes);\n\n                float lmax = expandFloats(\n                    dst,\n                    tiles.tileWidth * ifd->samples,\n                    bytesps);\n                if (fullrowbytes > inrowbytes) // last tile in row: copy buffer to destination\n                    memmove(&float_raw_image[((y + row) * imgdata.sizes.raw_width + x) * ifd->samples], dst, outrowbytes);\n                max = MAX(max, lmax);\n            }\n        }\n    }\n\n    imgdata.color.fmaximum = max;\n\n    // setup outpuf fields\n    imgdata.rawdata.raw_alloc = float_raw_image;\n    if (ifd->samples == 1)\n    {\n        imgdata.rawdata.float_image = float_raw_image;\n        imgdata.rawdata.sizes.raw_pitch = imgdata.sizes.raw_pitch =\n            imgdata.sizes.raw_width * 4;\n    }\n    else if (ifd->samples == 3)\n    {\n        imgdata.rawdata.float3_image = (float(*)[3])float_raw_image;\n        imgdata.rawdata.sizes.raw_pitch = imgdata.sizes.raw_pitch =\n            imgdata.sizes.raw_width * 12;\n    }\n    else if (ifd->samples == 4)\n    {\n        imgdata.rawdata.float4_image = (float(*)[4])float_raw_image;\n        imgdata.rawdata.sizes.raw_pitch = imgdata.sizes.raw_pitch =\n            imgdata.sizes.raw_width * 16;\n    }\n\n    if (imgdata.rawparams.options & LIBRAW_RAWOPTIONS_CONVERTFLOAT_TO_INT)\n        convertFloatToInt();  \n}\n",
    "target": 1,
    "idx": 1053158,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nint\nmrb_format_float(mrb_float f, char *buf, size_t buf_size, char fmt, int prec, char sign) {\n  char *s = buf;\n  int buf_remaining = buf_size - 1;\n  int alt_form = 0;\n\n  if ((uint8_t)fmt & 0x80) {\n    fmt &= 0x7f;  /* turn off alt_form flag */\n    alt_form = 1;\n  }\n  if (buf_size <= FLT_MIN_BUF_SIZE) {\n    // Smallest exp notion is -9e+99 (-9e+199) which is 6 (7) chars plus terminating\n    // null.\n\n    if (buf_size >= 2) {\n      *s++ = '?';\n    }\n    if (buf_size >= 1) {\n      *s++ = '\\0';\n    }\n    return buf_size >= 2;\n  }\n  if (signbit(f)) {\n    *s++ = '-';\n    f = -f;\n  } else if (sign) {\n    *s++ = sign;\n  }\n  buf_remaining -= (s - buf); // Adjust for sign\n\n  {\n    char uc = fmt & 0x20;\n    if (isinf(f)) {\n      *s++ = 'I' ^ uc;\n      *s++ = 'N' ^ uc;\n      *s++ = 'F' ^ uc;\n      goto ret;\n    } else if (isnan(f)) {\n      *s++ = 'N' ^ uc;\n      *s++ = 'A' ^ uc;\n      *s++ = 'N' ^ uc;\n    ret:\n      *s = '\\0';\n      return s - buf;\n    }\n  }\n\n  if (prec < 0) {\n    prec = 6;\n  }\n  char e_char = 'E' | (fmt & 0x20);   // e_char will match case of fmt\n  fmt |= 0x20; // Force fmt to be lowercase\n  char org_fmt = fmt;\n  if (fmt == 'g' && prec == 0) {\n    prec = 1;\n  }\n  int e, e1;\n  int dec = 0;\n  char e_sign = '\\0';\n  int num_digits = 0;\n  const mrb_float *pos_pow = g_pos_pow;\n  const mrb_float *neg_pow = g_neg_pow;\n\n  if (f == 0.0) {\n    e = 0;\n    if (fmt == 'e') {\n      e_sign = '+';\n    } else if (fmt == 'f') {\n      num_digits = prec + 1;\n    }\n  } else if (f < 1.0) { // f < 1.0\n    char first_dig = '0';\n    if (f >= FLT_ROUND_TO_ONE) {\n      first_dig = '1';\n    }\n\n    // Build negative exponent\n    for (e = 0, e1 = FLT_DECEXP; e1; e1 >>= 1, pos_pow++, neg_pow++) {\n      if (*neg_pow > f) {\n        e += e1;\n        f *= *pos_pow;\n      }\n    }\n    char e_sign_char = '-';\n    if (f < 1.0) {\n      if (f >= FLT_ROUND_TO_ONE) {\n        f = 1.0;\n        if (e == 0) {\n          e_sign_char = '+';\n        }\n      } else {\n        e++;\n        f *= 10.0;\n      }\n    }\n\n    // If the user specified 'g' format, and e is <= 4, then we'll switch\n    // to the fixed format ('f')\n\n    if (fmt == 'f' || (fmt == 'g' && e <= 4)) {\n      fmt = 'f';\n      dec = -1;\n      *s++ = first_dig;\n\n      if (org_fmt == 'g') {\n        prec += (e - 1);\n      }\n      // truncate precision to prevent buffer overflow\n      if (prec + 2 > buf_remaining) {\n        prec = buf_remaining - 2;\n      }\n      num_digits = prec;\n      if (num_digits || alt_form) {\n        *s++ = '.';\n        while (--e && num_digits) {\n          *s++ = '0';\n          num_digits--;\n        }\n      }\n    } else {\n      // For e & g formats, we'll be printing the exponent, so set the\n      // sign.\n      e_sign = e_sign_char;\n      dec = 0;\n\n      if (prec > (buf_remaining - FLT_MIN_BUF_SIZE)) {\n        prec = buf_remaining - FLT_MIN_BUF_SIZE;\n        if (fmt == 'g') {\n          prec++;\n        }\n      }\n    }\n  } else {\n    // Build positive exponent\n    for (e = 0, e1 = FLT_DECEXP; e1; e1 >>= 1, pos_pow++, neg_pow++) {\n      if (*pos_pow <= f) {\n        e += e1;\n        f *= *neg_pow;\n      }\n    }\n\n    // If the user specified fixed format (fmt == 'f') and e makes the\n    // number too big to fit into the available buffer, then we'll\n    // switch to the 'e' format.\n\n    if (fmt == 'f') {\n      if (e >= buf_remaining) {\n        fmt = 'e';\n      } else if ((e + prec + 2) > buf_remaining) {\n        prec = buf_remaining - e - 2;\n        if (prec < 0) {\n          // This means no decimal point, so we can add one back\n          // for the decimal.\n          prec++;\n        }\n      }\n    }\n    if (fmt == 'e' && prec > (buf_remaining - 6)) {\n      prec = buf_remaining - 6;\n    }\n    // If the user specified 'g' format, and e is < prec, then we'll switch\n    // to the fixed format.\n\n    if (fmt == 'g' && e < prec) {\n      fmt = 'f';\n      prec -= (e + 1);\n    }\n    if (fmt == 'f') {\n      dec = e;\n      num_digits = prec + e + 1;\n    } else {\n      e_sign = '+';\n    }\n  }\n  if (prec < 0) {\n    // This can happen when the prec is trimmed to prevent buffer overflow\n    prec = 0;\n  }\n\n  // We now have f as a floating point number between >= 1 and < 10\n  // (or equal to zero), and e contains the absolute value of the power of\n  // 10 exponent. and (dec + 1) == the number of dgits before the decimal.\n\n  // For e, prec is # digits after the decimal\n  // For f, prec is # digits after the decimal\n  // For g, prec is the max number of significant digits\n  //\n  // For e & g there will be a single digit before the decimal\n  // for f there will be e digits before the decimal\n\n  if (fmt == 'e') {\n    num_digits = prec + 1;\n  } else if (fmt == 'g') {\n    if (prec == 0) {\n      prec = 1;\n    }\n    num_digits = prec;\n  }\n\n  // Print the digits of the mantissa\n  for (int i = 0; i < num_digits; ++i, --dec) {\n    int8_t d = f;\n    *s++ = '0' + d;\n    if (dec == 0 && (prec > 0 || alt_form)) {\n      *s++ = '.';\n    }\n    f -= (mrb_float)d;\n    f *= 10.0;\n  }\n\n  // Round\n  if (f >= 5.0) {\n    char *rs = s;\n    rs--;\n    while (1) {\n      if (*rs == '.') {\n        rs--;\n        continue;\n      }\n      if (*rs < '0' || *rs > '9') {\n        // + or -\n        rs++; // So we sit on the digit to the right of the sign\n        break;\n      }\n      if (*rs < '9') {\n        (*rs)++;\n        break;\n      }\n      *rs = '0';\n      if (rs == buf) {\n        break;\n      }\n      rs--;\n    }\n    if (*rs == '0') {\n      // We need to insert a 1\n      if (rs[1] == '.' && fmt != 'f') {\n        // We're going to round 9.99 to 10.00\n        // Move the decimal point\n        rs[0] = '.';\n        rs[1] = '0';\n        if (e_sign == '-') {\n          e--;\n        } else {\n          e++;\n        }\n      }\n      s++;\n      char *ss = s;\n      while (ss > rs) {\n        *ss = ss[-1];\n        ss--;\n      }\n      *rs = '1';\n      if (f < 1.0 && fmt == 'f') {\n        // We rounded up to 1.0\n        prec--;\n      }\n    }\n  }\n\n  if (org_fmt == 'g' && prec > 0 && !alt_form) {\n    // Remove trailing zeros and a trailing decimal point\n    while (s[-1] == '0') {\n      s--;\n    }\n    if (s[-1] == '.') {\n      s--;\n    }\n  }\n  // Append the exponent\n  if (e_sign) {\n    *s++ = e_char;\n    *s++ = e_sign;\n    if (e >= 100) {\n      *s++ = '0' + (e / 100);\n      e %= 100;\n    }\n    *s++ = '0' + (e / 10);\n    *s++ = '0' + (e % 10);\n  }\n  *s = '\\0';\n\n  return s - buf;\n}\n\nstatic int\nfmt_float(char *buf, size_t buf_size, char fmt, int flags, mrb_int width, mrb_int prec, mrb_float f)\n{\n  char sign = '\\0';\n  int left_align = 0;\n  int zero_pad = 0;\n\n  if (flags & FSHARP) fmt |= 0x80;\n  if (flags & FPLUS)  sign = '+';\n  if (flags & FMINUS) left_align = 1;\n  if (flags & FZERO)  zero_pad = 1;\n  if (flags & FSPACE) sign = ' ';\n\n  int len = mrb_format_float(f, buf, buf_size, fmt, prec, sign);\n\n  // buf[0] < '0' returns true if the first character is space, + or -\n  // buf[1] < '9' matches a digit, and doesn't match when we get back +nan or +inf\n  if (buf[0] < '0' && buf[1] <= '9' && zero_pad) {\n    buf++;\n    width--;\n    len--;\n  }\n  if (*buf < '0' || *buf >= '9') {\n    // For inf or nan, we don't want to zero pad.\n    zero_pad = 0;\n  }\n  if (len >= width) {\n    return len;\n  }\n  buf[width] = '\\0';\n  if (left_align) {\n    memset(&buf[len], ' ', width - len);\n    return width;\n  }\n  memmove(&buf[width - len], buf, len);\n  if (zero_pad) {\n    memset(buf, '0', width - len);\n  } else {\n    memset(buf, ' ', width - len);\n  }\n  return width;\n}\n\nmrb_value\nmrb_str_format(mrb_state *mrb, mrb_int argc, const mrb_value *argv, mrb_value fmt)\n{\n  const char *p, *end;\n  char *buf;\n  mrb_int blen;\n  mrb_int bsiz;\n  mrb_value result;\n  mrb_int n;\n  mrb_int width;\n  mrb_int prec;\n  int nextarg = 1;\n  int posarg = 0;\n  mrb_value nextvalue;\n  mrb_value str;\n  mrb_value hash = mrb_undef_value();\n\n#define CHECK_FOR_WIDTH(f)                                              \\\n  if ((f) & FWIDTH) {                                                   \\\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"width given twice\");              \\\n    }                                                                   \\\n  if ((f) & FPREC0) {                                                   \\\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"width after precision\");          \\\n  }\n#define CHECK_FOR_FLAGS(f)                                              \\\n  if ((f) & FWIDTH) {                                                   \\\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"flag after width\");               \\\n  }                                                                     \\\n  if ((f) & FPREC0) {                                                   \\\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"flag after precision\");           \\\n  }\n\n  ++argc;\n  --argv;\n  mrb_to_str(mrb, fmt);\n  p = RSTRING_PTR(fmt);\n  end = p + RSTRING_LEN(fmt);\n  blen = 0;\n  bsiz = 120;\n  result = mrb_str_new_capa(mrb, bsiz);\n  buf = RSTRING_PTR(result);\n  memset(buf, 0, bsiz);\n\n  for (; p < end; p++) {\n    const char *t;\n    mrb_sym id = 0;\n    int flags = FNONE;\n\n    for (t = p; t < end && *t != '%'; t++) ;\n    if (t + 1 == end) ++t;\n    PUSH(p, t - p);\n    if (t >= end)\n      goto sprint_exit; /* end of fmt string */\n\n    p = t + 1;    /* skip '%' */\n\n    width = prec = -1;\n    nextvalue = mrb_undef_value();\n\nretry:\n    switch (*p) {\n      default:\n        mrb_raisef(mrb, E_ARGUMENT_ERROR, \"malformed format string - %%%c\", *p);\n        break;\n\n      case ' ':\n        CHECK_FOR_FLAGS(flags);\n        flags |= FSPACE;\n        p++;\n        goto retry;\n\n      case '#':\n        CHECK_FOR_FLAGS(flags);\n        flags |= FSHARP;\n        p++;\n        goto retry;\n\n      case '+':\n        CHECK_FOR_FLAGS(flags);\n        flags |= FPLUS;\n        p++;\n        goto retry;\n\n      case '-':\n        CHECK_FOR_FLAGS(flags);\n        flags |= FMINUS;\n        p++;\n        goto retry;\n\n      case '0':\n        CHECK_FOR_FLAGS(flags);\n        flags |= FZERO;\n        p++;\n        goto retry;\n\n      case '1': case '2': case '3': case '4':\n      case '5': case '6': case '7': case '8': case '9':\n        n = 0;\n        GETNUM(n, width);\n        if (*p == '$') {\n          if (!mrb_undef_p(nextvalue)) {\n            mrb_raisef(mrb, E_ARGUMENT_ERROR, \"value given twice - %i$\", n);\n          }\n          nextvalue = GETPOSARG(n);\n          p++;\n          goto retry;\n        }\n        CHECK_FOR_WIDTH(flags);\n        width = n;\n        flags |= FWIDTH;\n        goto retry;\n\n      case '<':\n      case '{': {\n        const char *start = p;\n        char term = (*p == '<') ? '>' : '}';\n\n        for (; p < end && *p != term; )\n          p++;\n        if (id) {\n          mrb_raisef(mrb, E_ARGUMENT_ERROR, \"name%l after <%n>\",\n                     start, p - start + 1, id);\n        }\n        CHECKNAMEARG(start, p - start + 1);\n        get_hash(mrb, &hash, argc, argv);\n        id = mrb_intern_check(mrb, start + 1, p - start - 1);\n        if (id) {\n          nextvalue = mrb_hash_fetch(mrb, hash, mrb_symbol_value(id), mrb_undef_value());\n        }\n        if (!id || mrb_undef_p(nextvalue)) {\n          mrb_raisef(mrb, E_KEY_ERROR, \"key%l not found\", start, p - start + 1);\n        }\n        if (term == '}') goto format_s;\n        p++;\n        goto retry;\n      }\n\n      case '*':\n        CHECK_FOR_WIDTH(flags);\n        flags |= FWIDTH;\n        GETASTER(width);\n        if (width < 0) {\n          flags |= FMINUS;\n          width = -width;\n        }\n        p++;\n        goto retry;\n\n      case '.':\n        if (flags & FPREC0) {\n          mrb_raise(mrb, E_ARGUMENT_ERROR, \"precision given twice\");\n        }\n        flags |= FPREC|FPREC0;\n\n        prec = 0;\n        p++;\n        if (*p == '*') {\n          GETASTER(prec);\n          if (prec < 0) {  /* ignore negative precision */\n            flags &= ~FPREC;\n          }\n          p++;\n          goto retry;\n        }\n\n        GETNUM(prec, precision);\n        goto retry;\n\n      case '\\n':\n      case '\\0':\n        p--;\n        /* fallthrough */\n      case '%':\n        if (flags != FNONE) {\n          mrb_raise(mrb, E_ARGUMENT_ERROR, \"invalid format character - %\");\n        }\n        PUSH(\"%\", 1);\n        break;\n\n      case 'c': {\n        mrb_value val = GETARG();\n        mrb_value tmp;\n        char *c;\n\n        tmp = mrb_check_string_type(mrb, val);\n        if (!mrb_nil_p(tmp)) {\n          if (RSTRING_LEN(tmp) != 1) {\n            mrb_raise(mrb, E_ARGUMENT_ERROR, \"%c requires a character\");\n          }\n        }\n        else if (mrb_integer_p(val)) {\n          mrb_int n = mrb_integer(val);\n#ifndef MRB_UTF8_STRING\n          char buf[1];\n\n          buf[0] = (char)n&0xff;\n          tmp = mrb_str_new(mrb, buf, 1);\n#else\n          if (n < 0x80) {\n            char buf[1];\n\n            buf[0] = (char)n;\n            tmp = mrb_str_new(mrb, buf, 1);\n          }\n          else {\n            tmp = mrb_funcall_id(mrb, val, MRB_SYM(chr), 0);\n            mrb_check_type(mrb, tmp, MRB_TT_STRING);\n          }\n#endif\n        }\n        else {\n          mrb_raise(mrb, E_ARGUMENT_ERROR, \"invalid character\");\n        }\n        c = RSTRING_PTR(tmp);\n        n = RSTRING_LEN(tmp);\n        if (!(flags & FWIDTH)) {\n          PUSH(c, n);\n        }\n        else if ((flags & FMINUS)) {\n          PUSH(c, n);\n          if (width>0) FILL(' ', width-1);\n        }\n        else {\n          if (width>0) FILL(' ', width-1);\n          PUSH(c, n);\n        }\n      }\n      break;\n\n      case 's':\n      case 'p':\n  format_s:\n      {\n        mrb_value arg = GETARG();\n        mrb_int len;\n        mrb_int slen;\n\n        if (*p == 'p') arg = mrb_inspect(mrb, arg);\n        str = mrb_obj_as_string(mrb, arg);\n        len = RSTRING_LEN(str);\n        if (RSTRING(result)->flags & MRB_STR_EMBED) {\n          mrb_int tmp_n = len;\n          RSTRING(result)->flags &= ~MRB_STR_EMBED_LEN_MASK;\n          RSTRING(result)->flags |= tmp_n << MRB_STR_EMBED_LEN_SHIFT;\n        }\n        else {\n          RSTRING(result)->as.heap.len = blen;\n        }\n        if (flags&(FPREC|FWIDTH)) {\n          slen = RSTRING_LEN(str);\n          if (slen < 0) {\n            mrb_raise(mrb, E_ARGUMENT_ERROR, \"invalid mbstring sequence\");\n          }\n          if ((flags&FPREC) && (prec < slen)) {\n            char *p = RSTRING_PTR(str) + prec;\n            slen = prec;\n            len = (mrb_int)(p - RSTRING_PTR(str));\n          }\n          /* need to adjust multi-byte string pos */\n          if ((flags&FWIDTH) && (width > slen)) {\n            width -= (int)slen;\n            if (!(flags&FMINUS)) {\n              FILL(' ', width);\n            }\n            PUSH(RSTRING_PTR(str), len);\n            if (flags&FMINUS) {\n              FILL(' ', width);\n            }\n            break;\n          }\n        }\n        PUSH(RSTRING_PTR(str), len);\n      }\n      break;\n\n      case 'd':\n      case 'i':\n      case 'o':\n      case 'x':\n      case 'X':\n      case 'b':\n      case 'B':\n      case 'u': {\n        mrb_value val = GETARG();\n        char nbuf[69], *s;\n        const char *prefix = NULL;\n        int sign = 0, dots = 0;\n        char sc = 0;\n        mrb_int v = 0;\n        int base;\n        mrb_int len;\n\n        if (flags & FSHARP) {\n          switch (*p) {\n            case 'o': prefix = \"0\"; break;\n            case 'x': prefix = \"0x\"; break;\n            case 'X': prefix = \"0X\"; break;\n            case 'b': prefix = \"0b\"; break;\n            case 'B': prefix = \"0B\"; break;\n            default: break;\n          }\n        }\n\n  bin_retry:\n        switch (mrb_type(val)) {\n#ifndef MRB_NO_FLOAT\n          case MRB_TT_FLOAT:\n            val = mrb_float_to_integer(mrb, val);\n            goto bin_retry;\n#endif\n          case MRB_TT_STRING:\n            val = mrb_str_to_inum(mrb, val, 0, TRUE);\n            goto bin_retry;\n          case MRB_TT_INTEGER:\n            v = mrb_integer(val);\n            break;\n          default:\n            v = mrb_as_int(mrb, val);\n            break;\n        }\n\n        switch (*p) {\n          case 'o':\n            base = 8; break;\n          case 'x':\n          case 'X':\n            base = 16; break;\n          case 'b':\n          case 'B':\n            base = 2; break;\n          case 'u':\n          case 'd':\n          case 'i':\n            sign = 1;\n            /* fall through */\n          default:\n            base = 10; break;\n        }\n\n        if (sign) {\n          if (v >= 0) {\n            if (flags & FPLUS) {\n              sc = '+';\n              width--;\n            }\n            else if (flags & FSPACE) {\n              sc = ' ';\n              width--;\n            }\n          }\n          else {\n            sc = '-';\n            width--;\n          }\n          mrb_assert(base == 10);\n          mrb_int2str(nbuf, sizeof(nbuf)-1, v);\n          s = nbuf;\n          if (v < 0) s++;       /* skip minus sign */\n        }\n        else {\n          s = nbuf;\n          if (v < 0) {\n            dots = 1;\n            val = mrb_fix2binstr(mrb, mrb_int_value(mrb, v), base);\n          }\n          else {\n            val = mrb_integer_to_str(mrb, mrb_int_value(mrb, v), base);\n          }\n          strncpy(++s, RSTRING_PTR(val), sizeof(nbuf)-2);\n        }\n        {\n          size_t size;\n          size = strlen(s);\n          /* PARANOID: assert(size <= MRB_INT_MAX) */\n          len = (mrb_int)size;\n        }\n\n        if (*p == 'X') {\n          char *pp = s;\n          int c;\n          while ((c = (int)(unsigned char)*pp) != 0) {\n            *pp = toupper(c);\n            pp++;\n          }\n        }\n\n        if (prefix && !prefix[1]) { /* octal */\n          if (dots) {\n            prefix = NULL;\n          }\n          else if (len == 1 && *s == '0') {\n            len = 0;\n            if (flags & FPREC) prec--;\n          }\n          else if ((flags & FPREC) && (prec > len)) {\n            prefix = NULL;\n          }\n        }\n        else if (len == 1 && *s == '0') {\n          prefix = NULL;\n        }\n\n        if (prefix) {\n          size_t size;\n          size = strlen(prefix);\n          /* PARANOID: assert(size <= MRB_INT_MAX).\n           *  this check is absolutely paranoid. */\n          width -= (mrb_int)size;\n        }\n\n        if ((flags & (FZERO|FMINUS|FPREC)) == FZERO) {\n          prec = width;\n          width = 0;\n        }\n        else {\n          if (prec < len) {\n            if (!prefix && prec == 0 && len == 1 && *s == '0') len = 0;\n            prec = len;\n          }\n          width -= prec;\n        }\n\n        if (!(flags&FMINUS) && width > 0) {\n          FILL(' ', width);\n          width = 0;\n        }\n\n        if (sc) PUSH(&sc, 1);\n\n        if (prefix) {\n          int plen = (int)strlen(prefix);\n          PUSH(prefix, plen);\n        }\n        if (dots) {\n          prec -= 2;\n          width -= 2;\n          PUSH(\"..\", 2);\n        }\n\n        if (prec > len) {\n          CHECK(prec - len);\n          if ((flags & (FMINUS|FPREC)) != FMINUS) {\n            char c = '0';\n            FILL(c, prec - len);\n          } else if (v < 0) {\n            char c = sign_bits(base, p);\n            FILL(c, prec - len);\n          }\n        }\n        PUSH(s, len);\n        if (width > 0) {\n          FILL(' ', width);\n        }\n      }\n      break;\n\n#ifndef MRB_NO_FLOAT\n      case 'f':\n      case 'g':\n      case 'G':\n      case 'e':\n      case 'E': {\n        mrb_value val = GETARG();\n        double fval;\n        mrb_int need = 6;\n\n        fval = mrb_as_float(mrb, val);\n        if (!isfinite(fval)) {\n          const char *expr;\n          const mrb_int elen = 3;\n          char sign = '\\0';\n\n          if (isnan(fval)) {\n            expr = \"NaN\";\n          }\n          else {\n            expr = \"Inf\";\n          }\n          need = elen;\n          if (!isnan(fval) && fval < 0.0)\n            sign = '-';\n          else if (flags & (FPLUS|FSPACE))\n            sign = (flags & FPLUS) ? '+' : ' ';\n          if (sign)\n            ++need;\n          if ((flags & FWIDTH) && need < width)\n            need = width;\n\n          if (need < 0) {\n            mrb_raise(mrb, E_ARGUMENT_ERROR, \"width too big\");\n          }\n          FILL(' ', need);\n          if (flags & FMINUS) {\n            if (sign)\n              buf[blen - need--] = sign;\n            memcpy(&buf[blen - need], expr, elen);\n          }\n          else {\n            if (sign)\n              buf[blen - elen - 1] = sign;\n            memcpy(&buf[blen - elen], expr, elen);\n          }\n          break;\n        }\n\n        need = 0;\n        if (*p != 'e' && *p != 'E') {\n          int i;\n          frexp(fval, &i);\n          if (i > 0)\n            need = BIT_DIGITS(i);\n        }\n        if (need > MRB_INT_MAX - ((flags&FPREC) ? prec : 6)) {\n        too_big_width:\n          mrb_raise(mrb, E_ARGUMENT_ERROR,\n                    (width > prec ? \"width too big\" : \"prec too big\"));\n        }\n        need += (flags&FPREC) ? prec : 6;\n        if ((flags&FWIDTH) && need < width)\n          need = width;\n        if (need > MRB_INT_MAX - 20) {\n          goto too_big_width;\n        }\n        need += 20;\n\n        CHECK(need);\n        n = fmt_float(&buf[blen], need, *p, flags, width, prec, fval);\n        if (n < 0 || n >= need) {\n          mrb_raise(mrb, E_RUNTIME_ERROR, \"formatting error\");\n        }\n        blen += n;\n      }\n      break;\n#endif\n    }\n    flags = FNONE;\n  }\n\n  sprint_exit:\n#if 0\n  /* XXX - We cannot validate the number of arguments if (digit)$ style used.\n   */\n  if (posarg >= 0 && nextarg < argc) {\n    const char *mesg = \"too many arguments for format string\";\n    if (mrb_test(ruby_debug)) mrb_raise(mrb, E_ARGUMENT_ERROR, mesg);\n    if (mrb_test(ruby_verbose)) mrb_warn(mrb, \"%s\", mesg);\n  }\n#endif\n  mrb_str_resize(mrb, result, blen);\n\n  return result;\n}\n\nstatic mrb_value\nmrb_f_sprintf(mrb_state *mrb, mrb_value obj)\n{\n  mrb_int argc;\n  const mrb_value *argv;\n\n  mrb_get_args(mrb, \"*\", &argv, &argc);\n\n  if (argc <= 0) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"too few arguments\");\n    return mrb_nil_value();\n  }\n  else {\n    return mrb_str_format(mrb, argc - 1, argv + 1, argv[0]);\n  }\n}\n\nMRB_API mrb_value\nmrb_vm_run(mrb_state *mrb, const struct RProc *proc, mrb_value self, mrb_int stack_keep)\n{\n  const mrb_irep *irep = proc->body.irep;\n  mrb_value result;\n  struct mrb_context *c = mrb->c;\n  ptrdiff_t cioff = c->ci - c->cibase;\n  mrb_int nregs = irep->nregs;\n\n  if (!c->stbase) {\n    stack_init(mrb);\n  }\n  if (stack_keep > nregs)\n    nregs = stack_keep;\n  mrb_stack_extend(mrb, nregs);\n  stack_clear(c->ci->stack + stack_keep, nregs - stack_keep);\n  c->ci->stack[0] = self;\n  result = mrb_vm_exec(mrb, proc, irep->iseq);\n  if (mrb->c != c) {\n    if (mrb->c->fib) {\n      mrb_write_barrier(mrb, (struct RBasic*)mrb->c->fib);\n    }\n    mrb->c = c;\n  }\n  else if (c->ci - c->cibase > cioff) {\n    c->ci = c->cibase + cioff;\n  }\n  return result;\n}\n\n\n// target function\nint\nmrb_format_float(mrb_float f, char *buf, size_t buf_size, char fmt, int prec, char sign) {\n  char *s = buf;\n  int buf_remaining = buf_size - 1;\n  int alt_form = 0;\n\n  if ((uint8_t)fmt & 0x80) {\n    fmt &= 0x7f;  /* turn off alt_form flag */\n    alt_form = 1;\n  }\n  if (buf_size <= FLT_MIN_BUF_SIZE) {\n    // Smallest exp notion is -9e+99 (-9e+199) which is 6 (7) chars plus terminating\n    // null.\n\n    if (buf_size >= 2) {\n      *s++ = '?';\n    }\n    if (buf_size >= 1) {\n      *s++ = '\\0';\n    }\n    return buf_size >= 2;\n  }\n  if (signbit(f)) {\n    *s++ = '-';\n    f = -f;\n  } else if (sign) {\n    *s++ = sign;\n  }\n  buf_remaining -= (s - buf); // Adjust for sign\n\n  {\n    char uc = fmt & 0x20;\n    if (isinf(f)) {\n      *s++ = 'I' ^ uc;\n      *s++ = 'N' ^ uc;\n      *s++ = 'F' ^ uc;\n      goto ret;\n    } else if (isnan(f)) {\n      *s++ = 'N' ^ uc;\n      *s++ = 'A' ^ uc;\n      *s++ = 'N' ^ uc;\n    ret:\n      *s = '\\0';\n      return s - buf;\n    }\n  }\n\n  if (prec < 0) {\n    prec = 6;\n  }\n  char e_char = 'E' | (fmt & 0x20);   // e_char will match case of fmt\n  fmt |= 0x20; // Force fmt to be lowercase\n  char org_fmt = fmt;\n  if (fmt == 'g' && prec == 0) {\n    prec = 1;\n  }\n  int e, e1;\n  int dec = 0;\n  char e_sign = '\\0';\n  int num_digits = 0;\n  const mrb_float *pos_pow = g_pos_pow;\n  const mrb_float *neg_pow = g_neg_pow;\n\n  if (f == 0.0) {\n    e = 0;\n    if (fmt == 'e') {\n      e_sign = '+';\n    } else if (fmt == 'f') {\n      num_digits = prec + 1;\n    }\n  } else if (f < 1.0) { // f < 1.0\n    char first_dig = '0';\n    if (f >= FLT_ROUND_TO_ONE) {\n      first_dig = '1';\n    }\n\n    // Build negative exponent\n    for (e = 0, e1 = FLT_DECEXP; e1; e1 >>= 1, pos_pow++, neg_pow++) {\n      if (*neg_pow > f) {\n        e += e1;\n        f *= *pos_pow;\n      }\n    }\n    char e_sign_char = '-';\n    if (f < 1.0) {\n      if (f >= FLT_ROUND_TO_ONE) {\n        f = 1.0;\n        if (e == 0) {\n          e_sign_char = '+';\n        }\n      } else {\n        e++;\n        f *= 10.0;\n      }\n    }\n\n    // If the user specified 'g' format, and e is <= 4, then we'll switch\n    // to the fixed format ('f')\n\n    if (fmt == 'f' || (fmt == 'g' && e <= 4)) {\n      fmt = 'f';\n      dec = -1;\n      *s++ = first_dig;\n\n      if (prec + e + 1 > buf_remaining) {\n        prec = buf_remaining - e - 1;\n      }\n\n      if (org_fmt == 'g') {\n        prec += (e - 1);\n      }\n      num_digits = prec;\n      if (num_digits || alt_form) {\n        *s++ = '.';\n        while (--e && num_digits) {\n          *s++ = '0';\n          num_digits--;\n        }\n      }\n    } else {\n      // For e & g formats, we'll be printing the exponent, so set the\n      // sign.\n      e_sign = e_sign_char;\n      dec = 0;\n\n      if (prec > (buf_remaining - FLT_MIN_BUF_SIZE)) {\n        prec = buf_remaining - FLT_MIN_BUF_SIZE;\n        if (fmt == 'g') {\n          prec++;\n        }\n      }\n    }\n  } else {\n    // Build positive exponent\n    for (e = 0, e1 = FLT_DECEXP; e1; e1 >>= 1, pos_pow++, neg_pow++) {\n      if (*pos_pow <= f) {\n        e += e1;\n        f *= *neg_pow;\n      }\n    }\n\n    // If the user specified fixed format (fmt == 'f') and e makes the\n    // number too big to fit into the available buffer, then we'll\n    // switch to the 'e' format.\n\n    if (fmt == 'f') {\n      if (e >= buf_remaining) {\n        fmt = 'e';\n      } else if ((e + prec + 2) > buf_remaining) {\n        prec = buf_remaining - e - 2;\n        if (prec < 0) {\n          // This means no decimal point, so we can add one back\n          // for the decimal.\n          prec++;\n        }\n      }\n    }\n    if (fmt == 'e' && prec > (buf_remaining - 6)) {\n      prec = buf_remaining - 6;\n    }\n    // If the user specified 'g' format, and e is < prec, then we'll switch\n    // to the fixed format.\n\n    if (fmt == 'g' && e < prec) {\n      fmt = 'f';\n      prec -= (e + 1);\n    }\n    if (fmt == 'f') {\n      dec = e;\n      num_digits = prec + e + 1;\n    } else {\n      e_sign = '+';\n    }\n  }\n  if (prec < 0) {\n    // This can happen when the prec is trimmed to prevent buffer overflow\n    prec = 0;\n  }\n\n  // We now have f as a floating point number between >= 1 and < 10\n  // (or equal to zero), and e contains the absolute value of the power of\n  // 10 exponent. and (dec + 1) == the number of dgits before the decimal.\n\n  // For e, prec is # digits after the decimal\n  // For f, prec is # digits after the decimal\n  // For g, prec is the max number of significant digits\n  //\n  // For e & g there will be a single digit before the decimal\n  // for f there will be e digits before the decimal\n\n  if (fmt == 'e') {\n    num_digits = prec + 1;\n  } else if (fmt == 'g') {\n    if (prec == 0) {\n      prec = 1;\n    }\n    num_digits = prec;\n  }\n\n  // Print the digits of the mantissa\n  for (int i = 0; i < num_digits; ++i, --dec) {\n    int8_t d = f;\n    *s++ = '0' + d;\n    if (dec == 0 && (prec > 0 || alt_form)) {\n      *s++ = '.';\n    }\n    f -= (mrb_float)d;\n    f *= 10.0;\n  }\n\n  // Round\n  if (f >= 5.0) {\n    char *rs = s;\n    rs--;\n    while (1) {\n      if (*rs == '.') {\n        rs--;\n        continue;\n      }\n      if (*rs < '0' || *rs > '9') {\n        // + or -\n        rs++; // So we sit on the digit to the right of the sign\n        break;\n      }\n      if (*rs < '9') {\n        (*rs)++;\n        break;\n      }\n      *rs = '0';\n      if (rs == buf) {\n        break;\n      }\n      rs--;\n    }\n    if (*rs == '0') {\n      // We need to insert a 1\n      if (rs[1] == '.' && fmt != 'f') {\n        // We're going to round 9.99 to 10.00\n        // Move the decimal point\n        rs[0] = '.';\n        rs[1] = '0';\n        if (e_sign == '-') {\n          e--;\n        } else {\n          e++;\n        }\n      }\n      s++;\n      char *ss = s;\n      while (ss > rs) {\n        *ss = ss[-1];\n        ss--;\n      }\n      *rs = '1';\n      if (f < 1.0 && fmt == 'f') {\n        // We rounded up to 1.0\n        prec--;\n      }\n    }\n  }\n\n  if (org_fmt == 'g' && prec > 0 && !alt_form) {\n    // Remove trailing zeros and a trailing decimal point\n    while (s[-1] == '0') {\n      s--;\n    }\n    if (s[-1] == '.') {\n      s--;\n    }\n  }\n  // Append the exponent\n  if (e_sign) {\n    *s++ = e_char;\n    *s++ = e_sign;\n    if (e >= 100) {\n      *s++ = '0' + (e / 100);\n      e %= 100;\n    }\n    *s++ = '0' + (e / 10);\n    *s++ = '0' + (e % 10);\n  }\n  *s = '\\0';\n\n  return s - buf;\n}\n",
    "target": 1,
    "idx": 1034652,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "// context\nstatic size_t merge_utf16be_ascii(unsigned char *out, size_t out_len, const unsigned char *utf16, const unsigned char *ascii, size_t len)\n{\n\tsize_t o, a, u;\n\n\tfor (o = 0, a = 0, u = 0; u + 1 < len && a < len && o + 1 < out_len; o += 2, a++, u += 2) {\n\t\t/* Surrogate pair with code point above U+FFFF */\n\t\tif (utf16[u] >= 0xD8 && utf16[u] <= 0xDB && u + 3 < len &&\n\t\t    utf16[u + 2] >= 0xDC && utf16[u + 2] <= 0xDF) {\n\t\t\tout[o++] = utf16[u++];\n\t\t\tout[o++] = utf16[u++];\n\t\t}\n\t\t/* Value '_' is replacement for non-representable character */\n\t\tif (ascii[a] == '_') {\n\t\t\tout[o] = utf16[u];\n\t\t\tout[o + 1] = utf16[u + 1];\n\t\t} else if (utf16[u] == 0x00 && utf16[u + 1] == '_') {\n\t\t\tout[o] = 0x00;\n\t\t\tout[o + 1] = ascii[a];\n\t\t} else if (utf16[u] == 0x00 && c_toupper(ascii[a]) == c_toupper(utf16[u + 1])) {\n\t\t\tout[o] = 0x00;\n\t\t\tout[o + 1] = c_isupper(ascii[a]) ? utf16[u + 1] : ascii[a];\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tfor (; a < len && o + 1 < out_len; o += 2, a++) {\n\t\tout[o] = 0x00;\n\t\tout[o + 1] = ascii[a];\n\t}\n\n\treturn o;\n}\n\nstatic int probe_iso9660(blkid_probe pr, const struct blkid_idmag *mag)\n{\n\tstruct boot_record *boot = NULL;\n\tstruct iso_volume_descriptor *pvd = NULL;\n\tstruct iso_volume_descriptor *joliet = NULL;\n\t/* space for merge_utf16be_ascii(ISO_ID_BUFSIZ bytes) */\n\tunsigned char buf[ISO_MAX_FIELDSIZ * 5 / 2];\n\tsize_t len;\n\tint is_unicode_empty;\n\tint is_ascii_empty;\n\tint i;\n\tuint64_t off;\n\n\tif (blkid_probe_get_hint(pr, mag->hoff, &off) < 0)\n\t\toff = 0;\n\n\tif (off % ISO_SECTOR_SIZE)\n\t\treturn 1;\n\n\tif (strcmp(mag->magic, \"CDROM\") == 0)\n\t\treturn probe_iso9660_hsfs(pr, mag);\n\n\tfor (i = 0, off += ISO_SUPERBLOCK_OFFSET; i < ISO_VD_MAX && (!boot || !pvd || !joliet); i++, off += ISO_SECTOR_SIZE) {\n\t\tunsigned char *desc =\n\t\t\tblkid_probe_get_buffer(pr,\n\t\t\t\t\toff,\n\t\t\t\t\tmax(sizeof(struct boot_record),\n\t\t\t\t\t    sizeof(struct iso_volume_descriptor)));\n\n\t\tif (desc == NULL || desc[0] == ISO_VD_END)\n\t\t\tbreak;\n\t\telse if (!boot && desc[0] == ISO_VD_BOOT_RECORD)\n\t\t\tboot = (struct boot_record *)desc;\n\t\telse if (!pvd && desc[0] == ISO_VD_PRIMARY)\n\t\t\tpvd = (struct iso_volume_descriptor *)desc;\n\t\telse if (!joliet && desc[0] == ISO_VD_SUPPLEMENTARY) {\n\t\t\tjoliet = (struct iso_volume_descriptor *)desc;\n\t\t\tif (memcmp(joliet->escape_sequences, \"%/@\", 3) != 0 &&\n\t\t\t    memcmp(joliet->escape_sequences, \"%/C\", 3) != 0 &&\n\t\t\t    memcmp(joliet->escape_sequences, \"%/E\", 3) != 0)\n\t\t\t\tjoliet = NULL;\n\t\t}\n\t}\n\n\tif (!pvd)\n\t\treturn errno ? -errno : 1;\n\n\tblkid_probe_set_fsblocksize(pr, ISO_SECTOR_SIZE);\n\tblkid_probe_set_block_size(pr, ISO_SECTOR_SIZE);\n\n\tif (joliet && (len = merge_utf16be_ascii(buf, sizeof(buf), joliet->system_id, pvd->system_id, sizeof(pvd->system_id))) != 0)\n\t\tblkid_probe_set_utf8_id_label(pr, \"SYSTEM_ID\", buf, len, UL_ENCODE_UTF16BE);\n\telse if (joliet)\n\t\tblkid_probe_set_utf8_id_label(pr, \"SYSTEM_ID\", joliet->system_id, sizeof(joliet->system_id), UL_ENCODE_UTF16BE);\n\telse\n\t\tblkid_probe_set_id_label(pr, \"SYSTEM_ID\", pvd->system_id, sizeof(pvd->system_id));\n\n\tif (joliet && (len = merge_utf16be_ascii(buf, sizeof(buf), joliet->volume_set_id, pvd->volume_set_id, sizeof(pvd->volume_set_id))) != 0)\n\t\tblkid_probe_set_utf8_id_label(pr, \"VOLUME_SET_ID\", buf, len, UL_ENCODE_UTF16BE);\n\telse if (joliet)\n\t\tblkid_probe_set_utf8_id_label(pr, \"VOLUME_SET_ID\", joliet->volume_set_id, sizeof(joliet->volume_set_id), UL_ENCODE_UTF16BE);\n\telse\n\t\tblkid_probe_set_id_label(pr, \"VOLUME_SET_ID\", pvd->volume_set_id, sizeof(pvd->volume_set_id));\n\n\tis_ascii_empty = (is_str_empty(pvd->publisher_id, sizeof(pvd->publisher_id)) || pvd->publisher_id[0] == '_');\n\tis_unicode_empty = (!joliet || is_utf16be_str_empty(joliet->publisher_id, sizeof(joliet->publisher_id)) || (joliet->publisher_id[0] == 0x00 && joliet->publisher_id[1] == '_'));\n\tif (!is_unicode_empty && !is_ascii_empty && (len = merge_utf16be_ascii(buf, sizeof(buf), joliet->publisher_id, pvd->publisher_id, sizeof(pvd->publisher_id))) != 0)\n\t\tblkid_probe_set_utf8_id_label(pr, \"PUBLISHER_ID\", buf, len, UL_ENCODE_UTF16BE);\n\telse if (!is_unicode_empty)\n\t\tblkid_probe_set_utf8_id_label(pr, \"PUBLISHER_ID\", joliet->publisher_id, sizeof(joliet->publisher_id), UL_ENCODE_UTF16BE);\n\telse if (!is_ascii_empty)\n\t\tblkid_probe_set_id_label(pr, \"PUBLISHER_ID\", pvd->publisher_id, sizeof(pvd->publisher_id));\n\n\tis_ascii_empty = (is_str_empty(pvd->data_preparer_id, sizeof(pvd->data_preparer_id)) || pvd->data_preparer_id[0] == '_');\n\tis_unicode_empty = (!joliet || is_utf16be_str_empty(joliet->data_preparer_id, sizeof(joliet->data_preparer_id)) || (joliet->data_preparer_id[0] == 0x00 && joliet->data_preparer_id[1] == '_'));\n\tif (!is_unicode_empty && !is_ascii_empty && (len = merge_utf16be_ascii(buf, sizeof(buf), joliet->data_preparer_id, pvd->data_preparer_id, sizeof(pvd->data_preparer_id))) != 0)\n\t\tblkid_probe_set_utf8_id_label(pr, \"DATA_PREPARER_ID\", buf, len, UL_ENCODE_UTF16BE);\n\telse if (!is_unicode_empty)\n\t\tblkid_probe_set_utf8_id_label(pr, \"DATA_PREPARER_ID\", joliet->data_preparer_id, sizeof(joliet->data_preparer_id), UL_ENCODE_UTF16BE);\n\telse if (!is_ascii_empty)\n\t\tblkid_probe_set_id_label(pr, \"DATA_PREPARER_ID\", pvd->data_preparer_id, sizeof(pvd->data_preparer_id));\n\n\tis_ascii_empty = (is_str_empty(pvd->application_id, sizeof(pvd->application_id)) || pvd->application_id[0] == '_');\n\tis_unicode_empty = (!joliet || is_utf16be_str_empty(joliet->application_id, sizeof(joliet->application_id)) || (joliet->application_id[0] == 0x00 && joliet->application_id[1] == '_'));\n\tif (!is_unicode_empty && !is_ascii_empty && (len = merge_utf16be_ascii(buf, sizeof(buf), joliet->application_id, pvd->application_id, sizeof(pvd->application_id))) != 0)\n\t\tblkid_probe_set_utf8_id_label(pr, \"APPLICATION_ID\", buf, len, UL_ENCODE_UTF16BE);\n\telse if (!is_unicode_empty)\n\t\tblkid_probe_set_utf8_id_label(pr, \"APPLICATION_ID\", joliet->application_id, sizeof(joliet->application_id), UL_ENCODE_UTF16BE);\n\telse if (!is_ascii_empty)\n\t\tblkid_probe_set_id_label(pr, \"APPLICATION_ID\", pvd->application_id, sizeof(pvd->application_id));\n\n\t/* create an UUID using the modified/created date */\n\tif (! probe_iso9660_set_uuid(pr, &pvd->modified))\n\t\tprobe_iso9660_set_uuid(pr, &pvd->created);\n\n\tif (boot)\n\t\tblkid_probe_set_id_label(pr, \"BOOT_SYSTEM_ID\",\n\t\t\t\t\tboot->boot_system_id,\n\t\t\t\t\tsizeof(boot->boot_system_id));\n\n\tif (joliet)\n\t\tblkid_probe_set_version(pr, \"Joliet Extension\");\n\n\t/* Label in Joliet is UNICODE (UTF16BE) but can contain only 16 characters. Label in PVD is\n\t * subset of ASCII but can contain up to the 32 characters. Non-representable characters are\n\t * stored as replacement character '_'. Label in Joliet is in most cases trimmed but UNICODE\n\t * version of label in PVD. Based on these facts try to reconstruct original label if label\n\t * in Joliet is prefix of the label in PVD (ignoring non-representable characters).\n\t */\n\tif (joliet && (len = merge_utf16be_ascii(buf, sizeof(buf), joliet->volume_id, pvd->volume_id, sizeof(pvd->volume_id))) != 0)\n\t\tblkid_probe_set_utf8label(pr, buf, len, UL_ENCODE_UTF16BE);\n\telse if (joliet)\n\t\tblkid_probe_set_utf8label(pr, joliet->volume_id, sizeof(joliet->volume_id), UL_ENCODE_UTF16BE);\n\telse\n\t\tblkid_probe_set_label(pr, pvd->volume_id, sizeof(pvd->volume_id));\n\n\treturn 0;\n}\n\nstatic int superblocks_probe(blkid_probe pr, struct blkid_chain *chn)\n{\n\tsize_t i;\n\tint rc = BLKID_PROBE_NONE;\n\n\tif (chn->idx < -1)\n\t\treturn -EINVAL;\n\n\tblkid_probe_chain_reset_values(pr, chn);\n\n\tif (pr->flags & BLKID_FL_NOSCAN_DEV) {\n\t\tDBG(LOWPROBE, ul_debug(\"*** ignore (noscan flag)\"));\n\t\treturn BLKID_PROBE_NONE;\n\t}\n\n\tif (pr->size <= 0 || (pr->size <= 1024 && !S_ISCHR(pr->mode))) {\n\t\t/* Ignore very very small block devices or regular files (e.g.\n\t\t * extended partitions). Note that size of the UBI char devices\n\t\t * is 1 byte */\n\t\tDBG(LOWPROBE, ul_debug(\"*** ignore (size <= 1024)\"));\n\t\treturn BLKID_PROBE_NONE;\n\t}\n\n\tDBG(LOWPROBE, ul_debug(\"--> starting probing loop [SUBLKS idx=%d]\",\n\t\tchn->idx));\n\n\ti = chn->idx < 0 ? 0 : chn->idx + 1U;\n\n\tfor ( ; i < ARRAY_SIZE(idinfos); i++) {\n\t\tconst struct blkid_idinfo *id;\n\t\tconst struct blkid_idmag *mag = NULL;\n\t\tuint64_t off = 0;\n\n\t\tchn->idx = i;\n\t\tid = idinfos[i];\n\n\t\tif (chn->fltr && blkid_bmp_get_item(chn->fltr, i)) {\n\t\t\tDBG(LOWPROBE, ul_debug(\"filter out: %s\", id->name));\n\t\t\trc = BLKID_PROBE_NONE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (id->minsz && (unsigned)id->minsz > pr->size) {\n\t\t\trc = BLKID_PROBE_NONE;\n\t\t\tcontinue;\t/* the device is too small */\n\t\t}\n\n\t\t/* don't probe for RAIDs, swap or journal on CD/DVDs */\n\t\tif ((id->usage & (BLKID_USAGE_RAID | BLKID_USAGE_OTHER)) &&\n\t\t    blkid_probe_is_cdrom(pr)) {\n\t\t\trc = BLKID_PROBE_NONE;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* don't probe for RAIDs on floppies */\n\t\tif ((id->usage & BLKID_USAGE_RAID) && blkid_probe_is_tiny(pr)) {\n\t\t\trc = BLKID_PROBE_NONE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tDBG(LOWPROBE, ul_debug(\"[%zd] %s:\", i, id->name));\n\n\t\trc = blkid_probe_get_idmag(pr, id, &off, &mag);\n\t\tif (rc < 0)\n\t\t\tbreak;\n\t\tif (rc != BLKID_PROBE_OK)\n\t\t\tcontinue;\n\n\t\t/* final check by probing function */\n\t\tif (id->probefunc) {\n\t\t\tDBG(LOWPROBE, ul_debug(\"\\tcall probefunc()\"));\n\t\t\trc = id->probefunc(pr, mag);\n\t\t\tif (rc != BLKID_PROBE_OK) {\n\t\t\t\tblkid_probe_chain_reset_values(pr, chn);\n\t\t\t\tif (rc < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* all checks passed */\n\t\tif (chn->flags & BLKID_SUBLKS_TYPE)\n\t\t\trc = blkid_probe_set_value(pr, \"TYPE\",\n\t\t\t\t(const unsigned char *) id->name,\n\t\t\t\tstrlen(id->name) + 1);\n\n\t\tif (!rc)\n\t\t\trc = blkid_probe_set_usage(pr, id->usage);\n\n\t\tif (!rc && mag)\n\t\t\trc = blkid_probe_set_magic(pr, off, mag->len,\n\t\t\t\t\t(const unsigned char *) mag->magic);\n\t\tif (rc) {\n\t\t\tblkid_probe_chain_reset_values(pr, chn);\n\t\t\tDBG(LOWPROBE, ul_debug(\"failed to set result -- ignore\"));\n\t\t\tcontinue;\n\t\t}\n\n\t\tDBG(LOWPROBE, ul_debug(\"<-- leaving probing loop (type=%s) [SUBLKS idx=%d]\",\n\t\t\tid->name, chn->idx));\n\t\treturn BLKID_PROBE_OK;\n\t}\n\n\tDBG(LOWPROBE, ul_debug(\"<-- leaving probing loop (failed=%d) [SUBLKS idx=%d]\",\n\t\t\trc, chn->idx));\n\treturn rc;\n}\n\nstatic int superblocks_safeprobe(blkid_probe pr, struct blkid_chain *chn)\n{\n\tstruct list_head vals;\n\tint idx = -1;\n\tint count = 0;\n\tint intol = 0;\n\tint rc;\n\n\tINIT_LIST_HEAD(&vals);\n\n\tif (pr->flags & BLKID_FL_NOSCAN_DEV)\n\t\treturn BLKID_PROBE_NONE;\n\n\twhile ((rc = superblocks_probe(pr, chn)) == 0) {\n\n\t\tif (blkid_probe_is_tiny(pr) && !count)\n\t\t\treturn BLKID_PROBE_OK;\t/* floppy or so -- returns the first result. */\n\n\t\tcount++;\n\n\t\tif (chn->idx >= 0 &&\n\t\t    idinfos[chn->idx]->usage & (BLKID_USAGE_RAID | BLKID_USAGE_CRYPTO))\n\t\t\tbreak;\n\n\t\tif (chn->idx >= 0 &&\n\t\t    !(idinfos[chn->idx]->flags & BLKID_IDINFO_TOLERANT))\n\t\t\tintol++;\n\n\t\tif (count == 1) {\n\t\t\t/* save the first result */\n\t\t\tblkid_probe_chain_save_values(pr, chn, &vals);\n\t\t\tidx = chn->idx;\n\t\t}\n\t}\n\n\tif (rc < 0)\n\t\tgoto done;\t\t/* error */\n\n\tif (count > 1 && intol) {\n\t\tDBG(LOWPROBE, ul_debug(\"ERROR: superblocks chain: \"\n\t\t\t       \"ambivalent result detected (%d filesystems)!\",\n\t\t\t       count));\n\t\trc = -2;\t\t/* error, ambivalent result (more FS) */\n\t\tgoto done;\n\t}\n\tif (!count) {\n\t\trc = BLKID_PROBE_NONE;\n\t\tgoto done;\n\t}\n\n\tif (idx != -1) {\n\t\t/* restore the first result */\n\t\tblkid_probe_chain_reset_values(pr, chn);\n\t\tblkid_probe_append_values_list(pr, &vals);\n\t\tchn->idx = idx;\n\t}\n\n\t/*\n\t * The RAID device could be partitioned. The problem are RAID1 devices\n\t * where the partition table is visible from underlying devices. We\n\t * have to ignore such partition tables.\n\t */\n\tif (chn->idx >= 0 && idinfos[chn->idx]->usage & BLKID_USAGE_RAID)\n\t\tpr->prob_flags |= BLKID_PROBE_FL_IGNORE_PT;\n\n\trc = BLKID_PROBE_OK;\ndone:\n\tblkid_probe_free_values_list(&vals);\n\treturn rc;\n}\n\nint blkid_do_safeprobe(blkid_probe pr)\n{\n\tint i, count = 0, rc = 0;\n\n\tif (pr->flags & BLKID_FL_NOSCAN_DEV)\n\t\treturn 1;\n\n\tblkid_probe_start(pr);\n\n\tfor (i = 0; i < BLKID_NCHAINS; i++) {\n\t\tstruct blkid_chain *chn;\n\n\t\tchn = pr->cur_chain = &pr->chains[i];\n\t\tchn->binary = FALSE;\t\t/* for sure... */\n\n\t\tDBG(LOWPROBE, ul_debug(\"chain safeprobe %s %s\",\n\t\t\t\tchn->driver->name,\n\t\t\t\tchn->enabled? \"ENABLED\" : \"DISABLED\"));\n\n\t\tif (!chn->enabled)\n\t\t\tcontinue;\n\n\t\tblkid_probe_chain_reset_position(chn);\n\n\t\trc = chn->driver->safeprobe(pr, chn);\n\n\t\tblkid_probe_chain_reset_position(chn);\n\n\t\t/* rc: -2 ambivalent, -1 = error, 0 = success, 1 = no result */\n\t\tif (rc < 0)\n\t\t\tgoto done;\t/* error */\n\t\tif (rc == 0)\n\t\t\tcount++;\t/* success */\n\t}\n\ndone:\n\tblkid_probe_end(pr);\n\tif (rc < 0)\n\t\treturn rc;\n\treturn count ? 0 : 1;\n}\n\n\n// target function\nstatic size_t merge_utf16be_ascii(unsigned char *out, const unsigned char *utf16, const unsigned char *ascii, size_t len)\n{\n\tsize_t o, a, u;\n\n\tfor (o = 0, a = 0, u = 0; u + 1 < len && a < len; o += 2, a++, u += 2) {\n\t\t/* Surrogate pair with code point above U+FFFF */\n\t\tif (utf16[u] >= 0xD8 && utf16[u] <= 0xDB && u + 3 < len &&\n\t\t    utf16[u + 2] >= 0xDC && utf16[u + 2] <= 0xDF) {\n\t\t\tout[o++] = utf16[u++];\n\t\t\tout[o++] = utf16[u++];\n\t\t}\n\t\t/* Value '_' is replacement for non-representable character */\n\t\tif (ascii[a] == '_') {\n\t\t\tout[o] = utf16[u];\n\t\t\tout[o + 1] = utf16[u + 1];\n\t\t} else if (utf16[u] == 0x00 && utf16[u + 1] == '_') {\n\t\t\tout[o] = 0x00;\n\t\t\tout[o + 1] = ascii[a];\n\t\t} else if (utf16[u] == 0x00 && c_toupper(ascii[a]) == c_toupper(utf16[u + 1])) {\n\t\t\tout[o] = 0x00;\n\t\t\tout[o + 1] = c_isupper(ascii[a]) ? utf16[u + 1] : ascii[a];\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tfor (; a < len; o += 2, a++) {\n\t\tout[o] = 0x00;\n\t\tout[o + 1] = ascii[a];\n\t}\n\n\treturn o;\n}\nstatic int probe_iso9660(blkid_probe pr, const struct blkid_idmag *mag)\n{\n\tstruct boot_record *boot = NULL;\n\tstruct iso_volume_descriptor *pvd = NULL;\n\tstruct iso_volume_descriptor *joliet = NULL;\n\tunsigned char buf[256];\n\tsize_t len;\n\tint is_unicode_empty;\n\tint is_ascii_empty;\n\tint i;\n\tuint64_t off;\n\n\tif (blkid_probe_get_hint(pr, mag->hoff, &off) < 0)\n\t\toff = 0;\n\n\tif (off % ISO_SECTOR_SIZE)\n\t\treturn 1;\n\n\tif (strcmp(mag->magic, \"CDROM\") == 0)\n\t\treturn probe_iso9660_hsfs(pr, mag);\n\n\tfor (i = 0, off += ISO_SUPERBLOCK_OFFSET; i < ISO_VD_MAX && (!boot || !pvd || !joliet); i++, off += ISO_SECTOR_SIZE) {\n\t\tunsigned char *desc =\n\t\t\tblkid_probe_get_buffer(pr,\n\t\t\t\t\toff,\n\t\t\t\t\tmax(sizeof(struct boot_record),\n\t\t\t\t\t    sizeof(struct iso_volume_descriptor)));\n\n\t\tif (desc == NULL || desc[0] == ISO_VD_END)\n\t\t\tbreak;\n\t\telse if (!boot && desc[0] == ISO_VD_BOOT_RECORD)\n\t\t\tboot = (struct boot_record *)desc;\n\t\telse if (!pvd && desc[0] == ISO_VD_PRIMARY)\n\t\t\tpvd = (struct iso_volume_descriptor *)desc;\n\t\telse if (!joliet && desc[0] == ISO_VD_SUPPLEMENTARY) {\n\t\t\tjoliet = (struct iso_volume_descriptor *)desc;\n\t\t\tif (memcmp(joliet->escape_sequences, \"%/@\", 3) != 0 &&\n\t\t\t    memcmp(joliet->escape_sequences, \"%/C\", 3) != 0 &&\n\t\t\t    memcmp(joliet->escape_sequences, \"%/E\", 3) != 0)\n\t\t\t\tjoliet = NULL;\n\t\t}\n\t}\n\n\tif (!pvd)\n\t\treturn errno ? -errno : 1;\n\n\tblkid_probe_set_fsblocksize(pr, ISO_SECTOR_SIZE);\n\tblkid_probe_set_block_size(pr, ISO_SECTOR_SIZE);\n\n\tif (joliet && (len = merge_utf16be_ascii(buf, joliet->system_id, pvd->system_id, sizeof(pvd->system_id))) != 0)\n\t\tblkid_probe_set_utf8_id_label(pr, \"SYSTEM_ID\", buf, len, UL_ENCODE_UTF16BE);\n\telse if (joliet)\n\t\tblkid_probe_set_utf8_id_label(pr, \"SYSTEM_ID\", joliet->system_id, sizeof(joliet->system_id), UL_ENCODE_UTF16BE);\n\telse\n\t\tblkid_probe_set_id_label(pr, \"SYSTEM_ID\", pvd->system_id, sizeof(pvd->system_id));\n\n\tif (joliet && (len = merge_utf16be_ascii(buf, joliet->volume_set_id, pvd->volume_set_id, sizeof(pvd->volume_set_id))) != 0)\n\t\tblkid_probe_set_utf8_id_label(pr, \"VOLUME_SET_ID\", buf, len, UL_ENCODE_UTF16BE);\n\telse if (joliet)\n\t\tblkid_probe_set_utf8_id_label(pr, \"VOLUME_SET_ID\", joliet->volume_set_id, sizeof(joliet->volume_set_id), UL_ENCODE_UTF16BE);\n\telse\n\t\tblkid_probe_set_id_label(pr, \"VOLUME_SET_ID\", pvd->volume_set_id, sizeof(pvd->volume_set_id));\n\n\tis_ascii_empty = (is_str_empty(pvd->publisher_id, sizeof(pvd->publisher_id)) || pvd->publisher_id[0] == '_');\n\tis_unicode_empty = (!joliet || is_utf16be_str_empty(joliet->publisher_id, sizeof(joliet->publisher_id)) || (joliet->publisher_id[0] == 0x00 && joliet->publisher_id[1] == '_'));\n\tif (!is_unicode_empty && !is_ascii_empty && (len = merge_utf16be_ascii(buf, joliet->publisher_id, pvd->publisher_id, sizeof(pvd->publisher_id))) != 0)\n\t\tblkid_probe_set_utf8_id_label(pr, \"PUBLISHER_ID\", buf, len, UL_ENCODE_UTF16BE);\n\telse if (!is_unicode_empty)\n\t\tblkid_probe_set_utf8_id_label(pr, \"PUBLISHER_ID\", joliet->publisher_id, sizeof(joliet->publisher_id), UL_ENCODE_UTF16BE);\n\telse if (!is_ascii_empty)\n\t\tblkid_probe_set_id_label(pr, \"PUBLISHER_ID\", pvd->publisher_id, sizeof(pvd->publisher_id));\n\n\tis_ascii_empty = (is_str_empty(pvd->data_preparer_id, sizeof(pvd->data_preparer_id)) || pvd->data_preparer_id[0] == '_');\n\tis_unicode_empty = (!joliet || is_utf16be_str_empty(joliet->data_preparer_id, sizeof(joliet->data_preparer_id)) || (joliet->data_preparer_id[0] == 0x00 && joliet->data_preparer_id[1] == '_'));\n\tif (!is_unicode_empty && !is_ascii_empty && (len = merge_utf16be_ascii(buf, joliet->data_preparer_id, pvd->data_preparer_id, sizeof(pvd->data_preparer_id))) != 0)\n\t\tblkid_probe_set_utf8_id_label(pr, \"DATA_PREPARER_ID\", buf, len, UL_ENCODE_UTF16BE);\n\telse if (!is_unicode_empty)\n\t\tblkid_probe_set_utf8_id_label(pr, \"DATA_PREPARER_ID\", joliet->data_preparer_id, sizeof(joliet->data_preparer_id), UL_ENCODE_UTF16BE);\n\telse if (!is_ascii_empty)\n\t\tblkid_probe_set_id_label(pr, \"DATA_PREPARER_ID\", pvd->data_preparer_id, sizeof(pvd->data_preparer_id));\n\n\tis_ascii_empty = (is_str_empty(pvd->application_id, sizeof(pvd->application_id)) || pvd->application_id[0] == '_');\n\tis_unicode_empty = (!joliet || is_utf16be_str_empty(joliet->application_id, sizeof(joliet->application_id)) || (joliet->application_id[0] == 0x00 && joliet->application_id[1] == '_'));\n\tif (!is_unicode_empty && !is_ascii_empty && (len = merge_utf16be_ascii(buf, joliet->application_id, pvd->application_id, sizeof(pvd->application_id))) != 0)\n\t\tblkid_probe_set_utf8_id_label(pr, \"APPLICATION_ID\", buf, len, UL_ENCODE_UTF16BE);\n\telse if (!is_unicode_empty)\n\t\tblkid_probe_set_utf8_id_label(pr, \"APPLICATION_ID\", joliet->application_id, sizeof(joliet->application_id), UL_ENCODE_UTF16BE);\n\telse if (!is_ascii_empty)\n\t\tblkid_probe_set_id_label(pr, \"APPLICATION_ID\", pvd->application_id, sizeof(pvd->application_id));\n\n\t/* create an UUID using the modified/created date */\n\tif (! probe_iso9660_set_uuid(pr, &pvd->modified))\n\t\tprobe_iso9660_set_uuid(pr, &pvd->created);\n\n\tif (boot)\n\t\tblkid_probe_set_id_label(pr, \"BOOT_SYSTEM_ID\",\n\t\t\t\t\tboot->boot_system_id,\n\t\t\t\t\tsizeof(boot->boot_system_id));\n\n\tif (joliet)\n\t\tblkid_probe_set_version(pr, \"Joliet Extension\");\n\n\t/* Label in Joliet is UNICODE (UTF16BE) but can contain only 16 characters. Label in PVD is\n\t * subset of ASCII but can contain up to the 32 characters. Non-representable characters are\n\t * stored as replacement character '_'. Label in Joliet is in most cases trimmed but UNICODE\n\t * version of label in PVD. Based on these facts try to reconstruct original label if label\n\t * in Joliet is prefix of the label in PVD (ignoring non-representable characters).\n\t */\n\tif (joliet && (len = merge_utf16be_ascii(buf, joliet->volume_id, pvd->volume_id, sizeof(pvd->volume_id))) != 0)\n\t\tblkid_probe_set_utf8label(pr, buf, len, UL_ENCODE_UTF16BE);\n\telse if (joliet)\n\t\tblkid_probe_set_utf8label(pr, joliet->volume_id, sizeof(joliet->volume_id), UL_ENCODE_UTF16BE);\n\telse\n\t\tblkid_probe_set_label(pr, pvd->volume_id, sizeof(pvd->volume_id));\n\n\treturn 0;\n}\n",
    "target": 1,
    "idx": 1053149,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nint add_file(struct thread_data *td, const char *fname, int numjob, int inc)\n{\n\tint cur_files = td->files_index;\n\tchar file_name[PATH_MAX];\n\tstruct fio_file *f;\n\tint len = 0;\n\n\tdprint(FD_FILE, \"add file %s\\n\", fname);\n\n\tif (td->o.directory)\n\t\tlen = set_name_idx(file_name, PATH_MAX, td->o.directory, numjob,\n\t\t\t\t\ttd->o.unique_filename);\n\n\tsprintf(file_name + len, \"%s\", fname);\n\n\t/* clean cloned siblings using existing files */\n\tif (numjob && is_already_allocated(file_name) &&\n\t    !exists_and_not_regfile(fname))\n\t\treturn 0;\n\n\tf = alloc_new_file(td);\n\n\tif (td->files_size <= td->files_index) {\n\t\tunsigned int new_size = td->o.nr_files + 1;\n\n\t\tdprint(FD_FILE, \"resize file array to %d files\\n\", new_size);\n\n\t\ttd->files = realloc(td->files, new_size * sizeof(f));\n\t\tif (td->files == NULL) {\n\t\t\tlog_err(\"fio: realloc OOM\\n\");\n\t\t\tassert(0);\n\t\t}\n\t\tif (td->o.file_lock_mode != FILE_LOCK_NONE) {\n\t\t\ttd->file_locks = realloc(td->file_locks, new_size);\n\t\t\tif (!td->file_locks) {\n\t\t\t\tlog_err(\"fio: realloc OOM\\n\");\n\t\t\t\tassert(0);\n\t\t\t}\n\t\t\ttd->file_locks[cur_files] = FILE_LOCK_NONE;\n\t\t}\n\t\ttd->files_size = new_size;\n\t}\n\ttd->files[cur_files] = f;\n\tf->fileno = cur_files;\n\n\t/*\n\t * init function, io engine may not be loaded yet\n\t */\n\tif (td->io_ops && td_ioengine_flagged(td, FIO_DISKLESSIO))\n\t\tf->real_file_size = -1ULL;\n\n\tif (td_ioengine_flagged(td, FIO_NOFILEHASH))\n\t\tf->file_name = strdup(file_name);\n\telse\n\t\tf->file_name = smalloc_strdup(file_name);\n\n\t/* can't handle smalloc failure from here */\n\tassert(f->file_name);\n\n\tget_file_type(f);\n\n\tswitch (td->o.file_lock_mode) {\n\tcase FILE_LOCK_NONE:\n\t\tbreak;\n\tcase FILE_LOCK_READWRITE:\n\t\tf->rwlock = fio_rwlock_init();\n\t\tbreak;\n\tcase FILE_LOCK_EXCLUSIVE:\n\t\tf->lock = fio_sem_init(FIO_SEM_UNLOCKED);\n\t\tbreak;\n\tdefault:\n\t\tlog_err(\"fio: unknown lock mode: %d\\n\", td->o.file_lock_mode);\n\t\tassert(0);\n\t}\n\n\ttd->files_index++;\n\n\tif (td->o.numjobs > 1)\n\t\tset_already_allocated(file_name);\n\n\tif (inc)\n\t\ttd->o.nr_files++;\n\n\tdprint(FD_FILE, \"file %p \\\"%s\\\" added at %d\\n\", f, f->file_name,\n\t\t\t\t\t\t\tcur_files);\n\n\treturn cur_files;\n}\n\nstatic int str_filename_cb(void *data, const char *input)\n{\n\tstruct thread_data *td = cb_data_to_td(data);\n\tchar *fname, *str, *p;\n\n\tp = str = strdup(input);\n\n\tstrip_blank_front(&str);\n\tstrip_blank_end(str);\n\n\t/*\n\t * Ignore what we may already have from nrfiles option.\n\t */\n\tif (!td->files_index)\n\t\ttd->o.nr_files = 0;\n\n\twhile ((fname = get_next_str(&str)) != NULL) {\n\t\tif (!strlen(fname))\n\t\t\tbreak;\n\t\tadd_file(td, fname, 0, 1);\n\t}\n\n\tfree(p);\n\treturn 0;\n}\n\nstatic int __handle_option(const struct fio_option *o, const char *ptr,\n\t\t\t   void *data, int first, int more, int curr)\n{\n\tint il=0, *ilp;\n\tfio_fp64_t *flp;\n\tlong long ull, *ullp;\n\tlong ul2;\n\tlong long ull1, ull2;\n\tdouble uf;\n\tchar **cp = NULL;\n\tint ret = 0, is_time = 0;\n\tconst struct value_pair *vp;\n\tstruct value_pair posval[PARSE_MAX_VP];\n\tint i, all_skipped = 1;\n\n\tdprint(FD_PARSE, \"__handle_option=%s, type=%s, ptr=%s\\n\", o->name,\n\t\t\t\t\t\t\topt_type_name(o), ptr);\n\n\tif (!ptr && o->type != FIO_OPT_STR_SET && o->type != FIO_OPT_STR) {\n\t\tlog_err(\"Option %s requires an argument\\n\", o->name);\n\t\treturn 1;\n\t}\n\n\tswitch (o->type) {\n\tcase FIO_OPT_STR:\n\tcase FIO_OPT_STR_ULL:\n\tcase FIO_OPT_STR_MULTI: {\n\t\tfio_opt_str_fn *fn = o->cb;\n\n\t\tposval_sort(o, posval);\n\n\t\tret = 1;\n\t\tfor (i = 0; i < PARSE_MAX_VP; i++) {\n\t\t\tvp = &posval[i];\n\t\t\tif (!vp->ival || vp->ival[0] == '\\0')\n\t\t\t\tcontinue;\n\t\t\tall_skipped = 0;\n\t\t\tif (!ptr)\n\t\t\t\tbreak;\n\t\t\tif (!strncmp(vp->ival, ptr, str_match_len(vp, ptr))) {\n\t\t\t\tret = 0;\n\t\t\t\tif (!o->off1)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (o->type == FIO_OPT_STR_ULL)\n\t\t\t\t\tval_store(ullp, vp->oval, o->off1, vp->orval, data, o);\n\t\t\t\telse\n\t\t\t\t\tval_store(ilp, vp->oval, o->off1, vp->orval, data, o);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (ret && !all_skipped)\n\t\t\tshow_option_values(o);\n\t\telse if (fn)\n\t\t\tret = fn(data, ptr);\n\t\tbreak;\n\t}\n\tcase FIO_OPT_STR_VAL_TIME:\n\t\tis_time = 1;\n\t\tfallthrough;\n\tcase FIO_OPT_ULL:\n\tcase FIO_OPT_INT:\n\tcase FIO_OPT_STR_VAL: {\n\t\tfio_opt_str_val_fn *fn = o->cb;\n\t\tchar tmp[128], *p;\n\n\t\tif (!is_time && o->is_time)\n\t\t\tis_time = o->is_time;\n\n\t\tsnprintf(tmp, sizeof(tmp), \"%s\", ptr);\n\t\tp = strchr(tmp, ',');\n\t\tif (p)\n\t\t\t*p = '\\0';\n\n\t\tif (is_time)\n\t\t\tret = check_str_time(tmp, &ull, o->is_seconds);\n\t\telse\n\t\t\tret = check_str_bytes(tmp, &ull, data);\n\n\t\tdprint(FD_PARSE, \"  ret=%d, out=%llu\\n\", ret, ull);\n\n\t\tif (ret)\n\t\t\tbreak;\n\t\tif (o->pow2 && !is_power_of_2(ull)) {\n\t\t\tlog_err(\"%s: must be a power-of-2\\n\", o->name);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (val_too_large(o, ull, o->type == FIO_OPT_INT)) {\n\t\t\tlog_err(\"%s: max value out of range: %llu\"\n\t\t\t\t\" (%llu max)\\n\", o->name, ull, o->maxval);\n\t\t\treturn 1;\n\t\t}\n\t\tif (val_too_small(o, ull, o->type == FIO_OPT_INT)) {\n\t\t\tlog_err(\"%s: min value out of range: %lld\"\n\t\t\t\t\" (%d min)\\n\", o->name, ull, o->minval);\n\t\t\treturn 1;\n\t\t}\n\t\tif (o->posval[0].ival) {\n\t\t\tposval_sort(o, posval);\n\n\t\t\tret = 1;\n\t\t\tfor (i = 0; i < PARSE_MAX_VP; i++) {\n\t\t\t\tvp = &posval[i];\n\t\t\t\tif (!vp->ival || vp->ival[0] == '\\0')\n\t\t\t\t\tcontinue;\n\t\t\t\tif (vp->oval == ull) {\n\t\t\t\t\tret = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ret) {\n\t\t\t\tlog_err(\"fio: value %llu not allowed:\\n\", ull);\n\t\t\t\tshow_option_values(o);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\tif (fn)\n\t\t\tret = fn(data, &ull);\n\t\telse {\n\t\t\tif (o->type == FIO_OPT_INT) {\n\t\t\t\tif (first)\n\t\t\t\t\tval_store(ilp, ull, o->off1, 0, data, o);\n\t\t\t\tif (curr == 1) {\n\t\t\t\t\tif (o->off2)\n\t\t\t\t\t\tval_store(ilp, ull, o->off2, 0, data, o);\n\t\t\t\t}\n\t\t\t\tif (curr == 2) {\n\t\t\t\t\tif (o->off3)\n\t\t\t\t\t\tval_store(ilp, ull, o->off3, 0, data, o);\n\t\t\t\t}\n\t\t\t\tif (!more) {\n\t\t\t\t\tif (curr < 1) {\n\t\t\t\t\t\tif (o->off2)\n\t\t\t\t\t\t\tval_store(ilp, ull, o->off2, 0, data, o);\n\t\t\t\t\t}\n\t\t\t\t\tif (curr < 2) {\n\t\t\t\t\t\tif (o->off3)\n\t\t\t\t\t\t\tval_store(ilp, ull, o->off3, 0, data, o);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (o->type == FIO_OPT_ULL) {\n\t\t\t\tif (first)\n\t\t\t\t\tval_store(ullp, ull, o->off1, 0, data, o);\n\t\t\t\tif (curr == 1) {\n\t\t\t\t\tif (o->off2)\n\t\t\t\t\t\tval_store(ullp, ull, o->off2, 0, data, o);\n\t\t\t\t}\n\t\t\t\tif (curr == 2) {\n\t\t\t\t\tif (o->off3)\n\t\t\t\t\t\tval_store(ullp, ull, o->off3, 0, data, o);\n\t\t\t\t}\n\t\t\t\tif (!more) {\n\t\t\t\t\tif (curr < 1) {\n\t\t\t\t\t\tif (o->off2)\n\t\t\t\t\t\t\tval_store(ullp, ull, o->off2, 0, data, o);\n\t\t\t\t\t}\n\t\t\t\t\tif (curr < 2) {\n\t\t\t\t\t\tif (o->off3)\n\t\t\t\t\t\t\tval_store(ullp, ull, o->off3, 0, data, o);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (first)\n\t\t\t\t\tval_store(ullp, ull, o->off1, 0, data, o);\n\t\t\t\tif (!more) {\n\t\t\t\t\tif (o->off2)\n\t\t\t\t\t\tval_store(ullp, ull, o->off2, 0, data, o);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase FIO_OPT_FLOAT_LIST: {\n\t\tchar *cp2;\n\n\t\tif (first) {\n\t\t\t/*\n\t\t\t** Initialize precision to 0 and zero out list\n\t\t\t** in case specified list is shorter than default\n\t\t\t*/\n\t\t\tif (o->off2) {\n\t\t\t\tul2 = 0;\n\t\t\t\tilp = td_var(data, o, o->off2);\n\t\t\t\t*ilp = ul2;\n\t\t\t}\n\n\t\t\tflp = td_var(data, o, o->off1);\n\t\t\tfor(i = 0; i < o->maxlen; i++)\n\t\t\t\tflp[i].u.f = 0.0;\n\t\t}\n\t\tif (curr >= o->maxlen) {\n\t\t\tlog_err(\"the list exceeding max length %d\\n\",\n\t\t\t\t\to->maxlen);\n\t\t\treturn 1;\n\t\t}\n\t\tif (!str_to_float(ptr, &uf, 0)) { /* this breaks if we ever have lists of times */\n\t\t\tlog_err(\"not a floating point value: %s\\n\", ptr);\n\t\t\treturn 1;\n\t\t}\n\t\tif (o->minfp || o->maxfp) {\n\t\t\tif (uf > o->maxfp) {\n\t\t\t\tlog_err(\"value out of range: %f\"\n\t\t\t\t\t\" (range max: %f)\\n\", uf, o->maxfp);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (uf < o->minfp) {\n\t\t\t\tlog_err(\"value out of range: %f\"\n\t\t\t\t\t\" (range min: %f)\\n\", uf, o->minfp);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\tflp = td_var(data, o, o->off1);\n\t\tflp[curr].u.f = uf;\n\n\t\tdprint(FD_PARSE, \"  out=%f\\n\", uf);\n\n\t\t/*\n\t\t** Calculate precision for output by counting\n\t\t** number of digits after period. Find first\n\t\t** period in entire remaining list each time\n\t\t*/\n\t\tcp2 = strchr(ptr, '.');\n\t\tif (cp2 != NULL) {\n\t\t\tint len = 0;\n\n\t\t\twhile (*++cp2 != '\\0' && *cp2 >= '0' && *cp2 <= '9')\n\t\t\t\tlen++;\n\n\t\t\tif (o->off2) {\n\t\t\t\tilp = td_var(data, o, o->off2);\n\t\t\t\tif (len > *ilp)\n\t\t\t\t\t*ilp = len;\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\t}\n\tcase FIO_OPT_STR_STORE: {\n\t\tfio_opt_str_fn *fn = o->cb;\n\n\t\tif (!strlen(ptr))\n\t\t\treturn 1;\n\n\t\tif (o->off1) {\n\t\t\tcp = td_var(data, o, o->off1);\n\t\t\t*cp = strdup(ptr);\n\t\t\tif (strlen(ptr) > o->maxlen - 1) {\n\t\t\t\tlog_err(\"value exceeds max length of %d\\n\",\n\t\t\t\t\to->maxlen);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\tif (fn)\n\t\t\tret = fn(data, ptr);\n\t\telse if (o->posval[0].ival) {\n\t\t\tposval_sort(o, posval);\n\n\t\t\tret = 1;\n\t\t\tfor (i = 0; i < PARSE_MAX_VP; i++) {\n\t\t\t\tvp = &posval[i];\n\t\t\t\tif (!vp->ival || vp->ival[0] == '\\0' || !cp)\n\t\t\t\t\tcontinue;\n\t\t\t\tall_skipped = 0;\n\t\t\t\tif (!strncmp(vp->ival, ptr, str_match_len(vp, ptr))) {\n\t\t\t\t\tchar *rest;\n\n\t\t\t\t\tret = 0;\n\t\t\t\t\tif (vp->cb)\n\t\t\t\t\t\tfn = vp->cb;\n\t\t\t\t\trest = strstr(*cp ?: ptr, \":\");\n\t\t\t\t\tif (rest) {\n\t\t\t\t\t\tif (*cp)\n\t\t\t\t\t\t\t*rest = '\\0';\n\t\t\t\t\t\tptr = rest + 1;\n\t\t\t\t\t} else\n\t\t\t\t\t\tptr = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!all_skipped) {\n\t\t\tif (ret && !*cp)\n\t\t\t\tshow_option_values(o);\n\t\t\telse if (ret && *cp)\n\t\t\t\tret = 0;\n\t\t\telse if (fn && ptr)\n\t\t\t\tret = fn(data, ptr);\n\t\t}\n\n\t\tbreak;\n\t}\n\tcase FIO_OPT_RANGE: {\n\t\tchar tmp[128];\n\t\tchar *p1, *p2;\n\n\t\tsnprintf(tmp, sizeof(tmp), \"%s\", ptr);\n\n\t\t/* Handle bsrange with separate read,write values: */\n\t\tp1 = strchr(tmp, ',');\n\t\tif (p1)\n\t\t\t*p1 = '\\0';\n\n\t\tp1 = strchr(tmp, '-');\n\t\tif (!p1) {\n\t\t\tp1 = strchr(tmp, ':');\n\t\t\tif (!p1) {\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tp2 = p1 + 1;\n\t\t*p1 = '\\0';\n\t\tp1 = tmp;\n\n\t\tret = 1;\n\t\tif (!check_range_bytes(p1, &ull1, data) &&\n\t\t\t!check_range_bytes(p2, &ull2, data)) {\n\t\t\tret = 0;\n\t\t\tif (ull1 > ull2) {\n\t\t\t\tunsigned long long foo = ull1;\n\n\t\t\t\tull1 = ull2;\n\t\t\t\tull2 = foo;\n\t\t\t}\n\n\t\t\tif (first) {\n\t\t\t\tval_store(ullp, ull1, o->off1, 0, data, o);\n\t\t\t\tval_store(ullp, ull2, o->off2, 0, data, o);\n\t\t\t}\n\t\t\tif (curr == 1) {\n\t\t\t\tif (o->off3 && o->off4) {\n\t\t\t\t\tval_store(ullp, ull1, o->off3, 0, data, o);\n\t\t\t\t\tval_store(ullp, ull2, o->off4, 0, data, o);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (curr == 2) {\n\t\t\t\tif (o->off5 && o->off6) {\n\t\t\t\t\tval_store(ullp, ull1, o->off5, 0, data, o);\n\t\t\t\t\tval_store(ullp, ull2, o->off6, 0, data, o);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!more) {\n\t\t\t\tif (curr < 1) {\n\t\t\t\t\tif (o->off3 && o->off4) {\n\t\t\t\t\t\tval_store(ullp, ull1, o->off3, 0, data, o);\n\t\t\t\t\t\tval_store(ullp, ull2, o->off4, 0, data, o);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (curr < 2) {\n\t\t\t\t\tif (o->off5 && o->off6) {\n\t\t\t\t\t\tval_store(ullp, ull1, o->off5, 0, data, o);\n\t\t\t\t\t\tval_store(ullp, ull2, o->off6, 0, data, o);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\t}\n\tcase FIO_OPT_BOOL:\n\tcase FIO_OPT_STR_SET: {\n\t\tfio_opt_int_fn *fn = o->cb;\n\n\t\tif (ptr)\n\t\t\tret = check_int(ptr, &il);\n\t\telse if (o->type == FIO_OPT_BOOL)\n\t\t\tret = 1;\n\t\telse\n\t\t\til = 1;\n\n\t\tdprint(FD_PARSE, \"  ret=%d, out=%d\\n\", ret, il);\n\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (o->maxval && il > (int) o->maxval) {\n\t\t\tlog_err(\"max value out of range: %d (%llu max)\\n\",\n\t\t\t\t\t\t\t\til, o->maxval);\n\t\t\treturn 1;\n\t\t}\n\t\tif (o->minval && il < o->minval) {\n\t\t\tlog_err(\"min value out of range: %d (%d min)\\n\",\n\t\t\t\t\t\t\t\til, o->minval);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (o->neg)\n\t\t\til = !il;\n\n\t\tif (fn)\n\t\t\tret = fn(data, &il);\n\t\telse {\n\t\t\tif (first)\n\t\t\t\tval_store(ilp, il, o->off1, 0, data, o);\n\t\t\tif (!more) {\n\t\t\t\tif (o->off2)\n\t\t\t\t\tval_store(ilp, il, o->off2, 0, data, o);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase FIO_OPT_DEPRECATED:\n\t\tret = 1;\n\t\tfallthrough;\n\tcase FIO_OPT_SOFT_DEPRECATED:\n\t\tlog_info(\"Option %s is deprecated\\n\", o->name);\n\t\tbreak;\n\tdefault:\n\t\tlog_err(\"Bad option type %u\\n\", o->type);\n\t\tret = 1;\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (o->verify) {\n\t\tret = o->verify(o, data);\n\t\tif (ret) {\n\t\t\tlog_err(\"Correct format for offending option\\n\");\n\t\t\tlog_err(\"%20s: %s\\n\", o->name, o->help);\n\t\t\tshow_option_help(o, 1);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int handle_option(const struct fio_option *o, const char *__ptr,\n\t\t\t void *data)\n{\n\tchar *o_ptr, *ptr, *ptr2;\n\tint ret, done;\n\n\tdprint(FD_PARSE, \"handle_option=%s, ptr=%s\\n\", o->name, __ptr);\n\n\to_ptr = ptr = NULL;\n\tif (__ptr)\n\t\to_ptr = ptr = strdup(__ptr);\n\n\t/*\n\t * See if we have another set of parameters, hidden after a comma.\n\t * Do this before parsing this round, to check if we should\n\t * copy set 1 options to set 2.\n\t */\n\tdone = 0;\n\tret = 1;\n\tdo {\n\t\tint __ret;\n\n\t\tptr2 = NULL;\n\t\tif (ptr &&\n\t\t    (o->type != FIO_OPT_STR_STORE) &&\n\t\t    (o->type != FIO_OPT_STR) &&\n\t\t    (o->type != FIO_OPT_STR_ULL) &&\n\t\t    (o->type != FIO_OPT_FLOAT_LIST)) {\n\t\t\tptr2 = strchr(ptr, ',');\n\t\t\tif (ptr2 && *(ptr2 + 1) == '\\0')\n\t\t\t\t*ptr2 = '\\0';\n\t\t\tif (o->type != FIO_OPT_STR_MULTI && o->type != FIO_OPT_RANGE) {\n\t\t\t\tif (!ptr2)\n\t\t\t\t\tptr2 = strchr(ptr, ':');\n\t\t\t\tif (!ptr2)\n\t\t\t\t\tptr2 = strchr(ptr, '-');\n\t\t\t}\n\t\t} else if (ptr && o->type == FIO_OPT_FLOAT_LIST) {\n\t\t\tptr2 = strchr(ptr, ':');\n\t\t}\n\n\t\t/*\n\t\t * Don't return early if parsing the first option fails - if\n\t\t * we are doing multiple arguments, we can allow the first one\n\t\t * being empty.\n\t\t */\n\t\t__ret = __handle_option(o, ptr, data, !done, !!ptr2, done);\n\t\tif (ret)\n\t\t\tret = __ret;\n\n\t\tif (!ptr2)\n\t\t\tbreak;\n\n\t\tptr = ptr2 + 1;\n\t\tdone++;\n\t} while (1);\n\n\tif (o_ptr)\n\t\tfree(o_ptr);\n\treturn ret;\n}\n\nint parse_option(char *opt, const char *input, const struct fio_option *options,\n\t\t const struct fio_option **o, void *data,\n\t\t struct flist_head *dump_list)\n{\n\tchar *post;\n\n\tif (!opt) {\n\t\tlog_err(\"fio: failed parsing %s\\n\", input);\n\t\t*o = NULL;\n\t\treturn 1;\n\t}\n\n\t*o = get_option(opt, options, &post);\n\tif (!*o) {\n\t\tif (post) {\n\t\t\tint len = strlen(opt);\n\t\t\tif (opt + len + 1 != post)\n\t\t\t\tmemmove(opt + len + 1, post, strlen(post));\n\t\t\topt[len] = '=';\n\t\t}\n\t\treturn 1;\n\t}\n\n\tif (handle_option(*o, post, data)) {\n\t\tlog_err(\"fio: failed parsing %s\\n\", input);\n\t\treturn 1;\n\t}\n\n\tadd_to_dump_list(*o, dump_list, post);\n\treturn 0;\n}\n\nint fio_options_parse(struct thread_data *td, char **opts, int num_opts)\n{\n\tint i, ret, unknown;\n\tchar **opts_copy;\n\n\tsort_options(opts, fio_options, num_opts);\n\topts_copy = dup_and_sub_options(opts, num_opts);\n\n\tfor (ret = 0, i = 0, unknown = 0; i < num_opts; i++) {\n\t\tconst struct fio_option *o;\n\t\tint newret = parse_option(opts_copy[i], opts[i], fio_options,\n\t\t\t\t\t\t&o, &td->o, &td->opt_list);\n\n\t\tif (!newret && o)\n\t\t\tfio_option_mark_set(&td->o, o);\n\n\t\tif (opts_copy[i]) {\n\t\t\tif (newret && !o) {\n\t\t\t\tunknown++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfree(opts_copy[i]);\n\t\t\topts_copy[i] = NULL;\n\t\t}\n\n\t\tret |= newret;\n\t}\n\n\tif (unknown) {\n\t\tret |= ioengine_load(td);\n\t\tif (td->eo) {\n\t\t\tsort_options(opts_copy, td->io_ops->options, num_opts);\n\t\t\topts = opts_copy;\n\t\t}\n\t\tfor (i = 0; i < num_opts; i++) {\n\t\t\tconst struct fio_option *o = NULL;\n\t\t\tint newret = 1;\n\n\t\t\tif (!opts_copy[i])\n\t\t\t\tcontinue;\n\n\t\t\tif (td->eo)\n\t\t\t\tnewret = parse_option(opts_copy[i], opts[i],\n\t\t\t\t\t\t      td->io_ops->options, &o,\n\t\t\t\t\t\t      td->eo, &td->opt_list);\n\n\t\t\tret |= newret;\n\t\t\tif (!o) {\n\t\t\t\tlog_err(\"Bad option <%s>\\n\", opts[i]);\n\t\t\t\tshow_closest_option(opts[i]);\n\t\t\t}\n\t\t\tfree(opts_copy[i]);\n\t\t\topts_copy[i] = NULL;\n\t\t}\n\t}\n\n\tfree(opts_copy);\n\treturn ret;\n}\n\nstatic int __parse_jobs_ini(struct thread_data *td,\n\t\tchar *file, int is_buf, int stonewall_flag, int type,\n\t\tint nested, char *name, char ***popts, int *aopts, int *nopts)\n{\n\tbool global = false;\n\tbool stdin_occupied = false;\n\tchar *string;\n\tFILE *f;\n\tchar *p;\n\tint ret = 0, stonewall;\n\tint first_sect = 1;\n\tint skip_fgets = 0;\n\tint inside_skip = 0;\n\tchar **opts;\n\tint i, alloc_opts, num_opts;\n\n\tdprint(FD_PARSE, \"Parsing ini file %s\\n\", file);\n\tassert(td || !nested);\n\n\tif (is_buf)\n\t\tf = NULL;\n\telse {\n\t\tif (!strcmp(file, \"-\")) {\n\t\t\tf = stdin;\n\t\t\tstdin_occupied = true;\n\t\t} else\n\t\t\tf = fopen(file, \"r\");\n\n\t\tif (!f) {\n\t\t\tint __err = errno;\n\n\t\t\tlog_err(\"fio: unable to open '%s' job file\\n\", file);\n\t\t\tif (td)\n\t\t\t\ttd_verror(td, __err, \"job file open\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tstring = malloc(OPT_LEN_MAX);\n\n\t/*\n\t * it's really 256 + small bit, 280 should suffice\n\t */\n\tif (!nested) {\n\t\tname = malloc(280);\n\t\tmemset(name, 0, 280);\n\t}\n\n\topts = NULL;\n\tif (nested && popts) {\n\t\topts = *popts;\n\t\talloc_opts = *aopts;\n\t\tnum_opts = *nopts;\n\t}\n\n\tif (!opts) {\n\t\talloc_opts = 8;\n\t\topts = malloc(sizeof(char *) * alloc_opts);\n\t\tnum_opts = 0;\n\t}\n\n\tstonewall = stonewall_flag;\n\tdo {\n\t\t/*\n\t\t * if skip_fgets is set, we already have loaded a line we\n\t\t * haven't handled.\n\t\t */\n\t\tif (!skip_fgets) {\n\t\t\tif (is_buf)\n\t\t\t\tp = strsep(&file, \"\\n\");\n\t\t\telse\n\t\t\t\tp = fgets(string, OPT_LEN_MAX, f);\n\t\t\tif (!p)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tskip_fgets = 0;\n\t\tstrip_blank_front(&p);\n\t\tstrip_blank_end(p);\n\n\t\tdprint(FD_PARSE, \"%s\\n\", p);\n\t\tif (is_empty_or_comment(p))\n\t\t\tcontinue;\n\n\t\tif (!nested) {\n\t\t\tif (sscanf(p, \"[%255[^\\n]]\", name) != 1) {\n\t\t\t\tif (inside_skip)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tlog_err(\"fio: option <%s> outside of \"\n\t\t\t\t\t\"[] job section\\n\", p);\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tname[strlen(name) - 1] = '\\0';\n\n\t\t\tif (skip_this_section(name)) {\n\t\t\t\tinside_skip = 1;\n\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\tinside_skip = 0;\n\n\t\t\tdprint(FD_PARSE, \"Parsing section [%s]\\n\", name);\n\n\t\t\tglobal = !strncmp(name, \"global\", 6);\n\n\t\t\tif (dump_cmdline) {\n\t\t\t\tif (first_sect)\n\t\t\t\t\tlog_info(\"fio \");\n\t\t\t\tif (!global)\n\t\t\t\t\tlog_info(\"--name=%s \", name);\n\t\t\t\tfirst_sect = 0;\n\t\t\t}\n\n\t\t\ttd = get_new_job(global, &def_thread, false, name);\n\t\t\tif (!td) {\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Separate multiple job files by a stonewall\n\t\t\t */\n\t\t\tif (!global && stonewall) {\n\t\t\t\ttd->o.stonewall = stonewall;\n\t\t\t\tstonewall = 0;\n\t\t\t}\n\n\t\t\tnum_opts = 0;\n\t\t\tmemset(opts, 0, alloc_opts * sizeof(char *));\n\t\t}\n\t\telse\n\t\t\tskip_fgets = 1;\n\n\t\twhile (1) {\n\t\t\tif (!skip_fgets) {\n\t\t\t\tif (is_buf)\n\t\t\t\t\tp = strsep(&file, \"\\n\");\n\t\t\t\telse\n\t\t\t\t\tp = fgets(string, OPT_LEN_MAX, f);\n\t\t\t\tif (!p)\n\t\t\t\t\tbreak;\n\t\t\t\tdprint(FD_PARSE, \"%s\", p);\n\t\t\t}\n\t\t\telse\n\t\t\t\tskip_fgets = 0;\n\n\t\t\tif (is_empty_or_comment(p))\n\t\t\t\tcontinue;\n\n\t\t\tstrip_blank_front(&p);\n\n\t\t\t/*\n\t\t\t * new section, break out and make sure we don't\n\t\t\t * fgets() a new line at the top.\n\t\t\t */\n\t\t\tif (p[0] == '[') {\n\t\t\t\tif (nested) {\n\t\t\t\t\tlog_err(\"No new sections in included files\\n\");\n\t\t\t\t\tret = 1;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tskip_fgets = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tstrip_blank_end(p);\n\n\t\t\tif (!strncmp(p, \"include\", strlen(\"include\"))) {\n\t\t\t\tchar *filename = p + strlen(\"include\") + 1,\n\t\t\t\t\t*ts, *full_fn = NULL;\n\n\t\t\t\t/*\n\t\t\t\t * Allow for the include filename\n\t\t\t\t * specification to be relative.\n\t\t\t\t */\n\t\t\t\tif (access(filename, F_OK) &&\n\t\t\t\t    (ts = strrchr(file, '/'))) {\n\t\t\t\t\tif (asprintf(&full_fn, \"%.*s%s\",\n\t\t\t\t\t\t (int)(ts - file + 1), file,\n\t\t\t\t\t\t filename) < 0) {\n\t\t\t\t\t\tret = ENOMEM;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfilename = full_fn;\n\t\t\t\t}\n\n\t\t\t\tret = __parse_jobs_ini(td, filename, is_buf,\n\t\t\t\t\t\t       stonewall_flag, type, 1,\n\t\t\t\t\t\t       name, &opts,\n\t\t\t\t\t\t       &alloc_opts, &num_opts);\n\n\t\t\t\tif (ret) {\n\t\t\t\t\tlog_err(\"Error %d while parsing \"\n\t\t\t\t\t\t\"include file %s\\n\",\n\t\t\t\t\t\tret, filename);\n\t\t\t\t}\n\n\t\t\t\tif (full_fn)\n\t\t\t\t\tfree(full_fn);\n\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (num_opts == alloc_opts) {\n\t\t\t\talloc_opts <<= 1;\n\t\t\t\topts = realloc(opts,\n\t\t\t\t\t\talloc_opts * sizeof(char *));\n\t\t\t}\n\n\t\t\topts[num_opts] = strdup(p);\n\t\t\tnum_opts++;\n\t\t}\n\n\t\tif (nested) {\n\t\t\t*popts = opts;\n\t\t\t*aopts = alloc_opts;\n\t\t\t*nopts = num_opts;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = fio_options_parse(td, opts, num_opts);\n\n\t\tif (!ret && td->o.read_iolog_file != NULL) {\n\t\t\tchar *fname = get_name_by_idx(td->o.read_iolog_file,\n\t\t\t\t\t\t      td->subjob_number);\n\t\t\tif (!strcmp(fname, \"-\")) {\n\t\t\t\tif (stdin_occupied) {\n\t\t\t\t\tlog_err(\"fio: only one user (read_iolog_file/job \"\n\t\t\t\t\t\t\"file) of stdin is permitted at once but \"\n\t\t\t\t\t\t\"more than one was found.\\n\");\n\t\t\t\t\tret = 1;\n\t\t\t\t}\n\t\t\t\tstdin_occupied = true;\n\t\t\t}\n\t\t}\n\t\tif (!ret) {\n\t\t\tif (dump_cmdline)\n\t\t\t\tdump_opt_list(td);\n\n\t\t\tret = add_job(td, name, 0, 0, type);\n\t\t} else {\n\t\t\tlog_err(\"fio: job %s dropped\\n\", name);\n\t\t\tput_job(td);\n\t\t}\n\n\t\tfor (i = 0; i < num_opts; i++)\n\t\t\tfree(opts[i]);\n\t\tnum_opts = 0;\n\t} while (!ret);\n\n\tif (dump_cmdline)\n\t\tlog_info(\"\\n\");\n\n\ti = 0;\n\twhile (i < nr_job_sections) {\n\t\tfree(job_sections[i]);\n\t\ti++;\n\t}\n\n\tfree(opts);\nout:\n\tfree(string);\n\tif (!nested)\n\t\tfree(name);\n\tif (!is_buf && f != stdin)\n\t\tfclose(f);\n\treturn ret;\n}\n\nint parse_jobs_ini(char *file, int is_buf, int stonewall_flag, int type)\n{\n\treturn __parse_jobs_ini(NULL, file, is_buf, stonewall_flag, type,\n\t\t\t0, NULL, NULL, NULL, NULL);\n}\n\n\n// target function\nstatic int __handle_option(const struct fio_option *o, const char *ptr,\n\t\t\t   void *data, int first, int more, int curr)\n{\n\tint il=0, *ilp;\n\tfio_fp64_t *flp;\n\tlong long ull, *ullp;\n\tlong ul2;\n\tlong long ull1, ull2;\n\tdouble uf;\n\tchar **cp = NULL;\n\tint ret = 0, is_time = 0;\n\tconst struct value_pair *vp;\n\tstruct value_pair posval[PARSE_MAX_VP];\n\tint i, all_skipped = 1;\n\n\tdprint(FD_PARSE, \"__handle_option=%s, type=%s, ptr=%s\\n\", o->name,\n\t\t\t\t\t\t\topt_type_name(o), ptr);\n\n\tif (!ptr && o->type != FIO_OPT_STR_SET && o->type != FIO_OPT_STR) {\n\t\tlog_err(\"Option %s requires an argument\\n\", o->name);\n\t\treturn 1;\n\t}\n\n\tswitch (o->type) {\n\tcase FIO_OPT_STR:\n\tcase FIO_OPT_STR_ULL:\n\tcase FIO_OPT_STR_MULTI: {\n\t\tfio_opt_str_fn *fn = o->cb;\n\n\t\tposval_sort(o, posval);\n\n\t\tret = 1;\n\t\tfor (i = 0; i < PARSE_MAX_VP; i++) {\n\t\t\tvp = &posval[i];\n\t\t\tif (!vp->ival || vp->ival[0] == '\\0')\n\t\t\t\tcontinue;\n\t\t\tall_skipped = 0;\n\t\t\tif (!ptr)\n\t\t\t\tbreak;\n\t\t\tif (!strncmp(vp->ival, ptr, str_match_len(vp, ptr))) {\n\t\t\t\tret = 0;\n\t\t\t\tif (!o->off1)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (o->type == FIO_OPT_STR_ULL)\n\t\t\t\t\tval_store(ullp, vp->oval, o->off1, vp->orval, data, o);\n\t\t\t\telse\n\t\t\t\t\tval_store(ilp, vp->oval, o->off1, vp->orval, data, o);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (ret && !all_skipped)\n\t\t\tshow_option_values(o);\n\t\telse if (fn)\n\t\t\tret = fn(data, ptr);\n\t\tbreak;\n\t}\n\tcase FIO_OPT_STR_VAL_TIME:\n\t\tis_time = 1;\n\t\tfallthrough;\n\tcase FIO_OPT_ULL:\n\tcase FIO_OPT_INT:\n\tcase FIO_OPT_STR_VAL: {\n\t\tfio_opt_str_val_fn *fn = o->cb;\n\t\tchar tmp[128], *p;\n\n\t\tif (!is_time && o->is_time)\n\t\t\tis_time = o->is_time;\n\n\t\tsnprintf(tmp, sizeof(tmp), \"%s\", ptr);\n\t\tp = strchr(tmp, ',');\n\t\tif (p)\n\t\t\t*p = '\\0';\n\n\t\tif (is_time)\n\t\t\tret = check_str_time(tmp, &ull, o->is_seconds);\n\t\telse\n\t\t\tret = check_str_bytes(tmp, &ull, data);\n\n\t\tdprint(FD_PARSE, \"  ret=%d, out=%llu\\n\", ret, ull);\n\n\t\tif (ret)\n\t\t\tbreak;\n\t\tif (o->pow2 && !is_power_of_2(ull)) {\n\t\t\tlog_err(\"%s: must be a power-of-2\\n\", o->name);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (val_too_large(o, ull, o->type == FIO_OPT_INT)) {\n\t\t\tlog_err(\"%s: max value out of range: %llu\"\n\t\t\t\t\" (%llu max)\\n\", o->name, ull, o->maxval);\n\t\t\treturn 1;\n\t\t}\n\t\tif (val_too_small(o, ull, o->type == FIO_OPT_INT)) {\n\t\t\tlog_err(\"%s: min value out of range: %lld\"\n\t\t\t\t\" (%d min)\\n\", o->name, ull, o->minval);\n\t\t\treturn 1;\n\t\t}\n\t\tif (o->posval[0].ival) {\n\t\t\tposval_sort(o, posval);\n\n\t\t\tret = 1;\n\t\t\tfor (i = 0; i < PARSE_MAX_VP; i++) {\n\t\t\t\tvp = &posval[i];\n\t\t\t\tif (!vp->ival || vp->ival[0] == '\\0')\n\t\t\t\t\tcontinue;\n\t\t\t\tif (vp->oval == ull) {\n\t\t\t\t\tret = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ret) {\n\t\t\t\tlog_err(\"fio: value %llu not allowed:\\n\", ull);\n\t\t\t\tshow_option_values(o);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\tif (fn)\n\t\t\tret = fn(data, &ull);\n\t\telse {\n\t\t\tif (o->type == FIO_OPT_INT) {\n\t\t\t\tif (first)\n\t\t\t\t\tval_store(ilp, ull, o->off1, 0, data, o);\n\t\t\t\tif (curr == 1) {\n\t\t\t\t\tif (o->off2)\n\t\t\t\t\t\tval_store(ilp, ull, o->off2, 0, data, o);\n\t\t\t\t}\n\t\t\t\tif (curr == 2) {\n\t\t\t\t\tif (o->off3)\n\t\t\t\t\t\tval_store(ilp, ull, o->off3, 0, data, o);\n\t\t\t\t}\n\t\t\t\tif (!more) {\n\t\t\t\t\tif (curr < 1) {\n\t\t\t\t\t\tif (o->off2)\n\t\t\t\t\t\t\tval_store(ilp, ull, o->off2, 0, data, o);\n\t\t\t\t\t}\n\t\t\t\t\tif (curr < 2) {\n\t\t\t\t\t\tif (o->off3)\n\t\t\t\t\t\t\tval_store(ilp, ull, o->off3, 0, data, o);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (o->type == FIO_OPT_ULL) {\n\t\t\t\tif (first)\n\t\t\t\t\tval_store(ullp, ull, o->off1, 0, data, o);\n\t\t\t\tif (curr == 1) {\n\t\t\t\t\tif (o->off2)\n\t\t\t\t\t\tval_store(ullp, ull, o->off2, 0, data, o);\n\t\t\t\t}\n\t\t\t\tif (curr == 2) {\n\t\t\t\t\tif (o->off3)\n\t\t\t\t\t\tval_store(ullp, ull, o->off3, 0, data, o);\n\t\t\t\t}\n\t\t\t\tif (!more) {\n\t\t\t\t\tif (curr < 1) {\n\t\t\t\t\t\tif (o->off2)\n\t\t\t\t\t\t\tval_store(ullp, ull, o->off2, 0, data, o);\n\t\t\t\t\t}\n\t\t\t\t\tif (curr < 2) {\n\t\t\t\t\t\tif (o->off3)\n\t\t\t\t\t\t\tval_store(ullp, ull, o->off3, 0, data, o);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (first)\n\t\t\t\t\tval_store(ullp, ull, o->off1, 0, data, o);\n\t\t\t\tif (!more) {\n\t\t\t\t\tif (o->off2)\n\t\t\t\t\t\tval_store(ullp, ull, o->off2, 0, data, o);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase FIO_OPT_FLOAT_LIST: {\n\t\tchar *cp2;\n\n\t\tif (first) {\n\t\t\t/*\n\t\t\t** Initialize precision to 0 and zero out list\n\t\t\t** in case specified list is shorter than default\n\t\t\t*/\n\t\t\tif (o->off2) {\n\t\t\t\tul2 = 0;\n\t\t\t\tilp = td_var(data, o, o->off2);\n\t\t\t\t*ilp = ul2;\n\t\t\t}\n\n\t\t\tflp = td_var(data, o, o->off1);\n\t\t\tfor(i = 0; i < o->maxlen; i++)\n\t\t\t\tflp[i].u.f = 0.0;\n\t\t}\n\t\tif (curr >= o->maxlen) {\n\t\t\tlog_err(\"the list exceeding max length %d\\n\",\n\t\t\t\t\to->maxlen);\n\t\t\treturn 1;\n\t\t}\n\t\tif (!str_to_float(ptr, &uf, 0)) { /* this breaks if we ever have lists of times */\n\t\t\tlog_err(\"not a floating point value: %s\\n\", ptr);\n\t\t\treturn 1;\n\t\t}\n\t\tif (o->minfp || o->maxfp) {\n\t\t\tif (uf > o->maxfp) {\n\t\t\t\tlog_err(\"value out of range: %f\"\n\t\t\t\t\t\" (range max: %f)\\n\", uf, o->maxfp);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (uf < o->minfp) {\n\t\t\t\tlog_err(\"value out of range: %f\"\n\t\t\t\t\t\" (range min: %f)\\n\", uf, o->minfp);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\tflp = td_var(data, o, o->off1);\n\t\tflp[curr].u.f = uf;\n\n\t\tdprint(FD_PARSE, \"  out=%f\\n\", uf);\n\n\t\t/*\n\t\t** Calculate precision for output by counting\n\t\t** number of digits after period. Find first\n\t\t** period in entire remaining list each time\n\t\t*/\n\t\tcp2 = strchr(ptr, '.');\n\t\tif (cp2 != NULL) {\n\t\t\tint len = 0;\n\n\t\t\twhile (*++cp2 != '\\0' && *cp2 >= '0' && *cp2 <= '9')\n\t\t\t\tlen++;\n\n\t\t\tif (o->off2) {\n\t\t\t\tilp = td_var(data, o, o->off2);\n\t\t\t\tif (len > *ilp)\n\t\t\t\t\t*ilp = len;\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\t}\n\tcase FIO_OPT_STR_STORE: {\n\t\tfio_opt_str_fn *fn = o->cb;\n\n\t\tif (!strlen(ptr))\n\t\t\treturn 1;\n\n\t\tif (o->off1) {\n\t\t\tcp = td_var(data, o, o->off1);\n\t\t\t*cp = strdup(ptr);\n\t\t}\n\n\t\tif (fn)\n\t\t\tret = fn(data, ptr);\n\t\telse if (o->posval[0].ival) {\n\t\t\tposval_sort(o, posval);\n\n\t\t\tret = 1;\n\t\t\tfor (i = 0; i < PARSE_MAX_VP; i++) {\n\t\t\t\tvp = &posval[i];\n\t\t\t\tif (!vp->ival || vp->ival[0] == '\\0' || !cp)\n\t\t\t\t\tcontinue;\n\t\t\t\tall_skipped = 0;\n\t\t\t\tif (!strncmp(vp->ival, ptr, str_match_len(vp, ptr))) {\n\t\t\t\t\tchar *rest;\n\n\t\t\t\t\tret = 0;\n\t\t\t\t\tif (vp->cb)\n\t\t\t\t\t\tfn = vp->cb;\n\t\t\t\t\trest = strstr(*cp ?: ptr, \":\");\n\t\t\t\t\tif (rest) {\n\t\t\t\t\t\tif (*cp)\n\t\t\t\t\t\t\t*rest = '\\0';\n\t\t\t\t\t\tptr = rest + 1;\n\t\t\t\t\t} else\n\t\t\t\t\t\tptr = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!all_skipped) {\n\t\t\tif (ret && !*cp)\n\t\t\t\tshow_option_values(o);\n\t\t\telse if (ret && *cp)\n\t\t\t\tret = 0;\n\t\t\telse if (fn && ptr)\n\t\t\t\tret = fn(data, ptr);\n\t\t}\n\n\t\tbreak;\n\t}\n\tcase FIO_OPT_RANGE: {\n\t\tchar tmp[128];\n\t\tchar *p1, *p2;\n\n\t\tsnprintf(tmp, sizeof(tmp), \"%s\", ptr);\n\n\t\t/* Handle bsrange with separate read,write values: */\n\t\tp1 = strchr(tmp, ',');\n\t\tif (p1)\n\t\t\t*p1 = '\\0';\n\n\t\tp1 = strchr(tmp, '-');\n\t\tif (!p1) {\n\t\t\tp1 = strchr(tmp, ':');\n\t\t\tif (!p1) {\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tp2 = p1 + 1;\n\t\t*p1 = '\\0';\n\t\tp1 = tmp;\n\n\t\tret = 1;\n\t\tif (!check_range_bytes(p1, &ull1, data) &&\n\t\t\t!check_range_bytes(p2, &ull2, data)) {\n\t\t\tret = 0;\n\t\t\tif (ull1 > ull2) {\n\t\t\t\tunsigned long long foo = ull1;\n\n\t\t\t\tull1 = ull2;\n\t\t\t\tull2 = foo;\n\t\t\t}\n\n\t\t\tif (first) {\n\t\t\t\tval_store(ullp, ull1, o->off1, 0, data, o);\n\t\t\t\tval_store(ullp, ull2, o->off2, 0, data, o);\n\t\t\t}\n\t\t\tif (curr == 1) {\n\t\t\t\tif (o->off3 && o->off4) {\n\t\t\t\t\tval_store(ullp, ull1, o->off3, 0, data, o);\n\t\t\t\t\tval_store(ullp, ull2, o->off4, 0, data, o);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (curr == 2) {\n\t\t\t\tif (o->off5 && o->off6) {\n\t\t\t\t\tval_store(ullp, ull1, o->off5, 0, data, o);\n\t\t\t\t\tval_store(ullp, ull2, o->off6, 0, data, o);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!more) {\n\t\t\t\tif (curr < 1) {\n\t\t\t\t\tif (o->off3 && o->off4) {\n\t\t\t\t\t\tval_store(ullp, ull1, o->off3, 0, data, o);\n\t\t\t\t\t\tval_store(ullp, ull2, o->off4, 0, data, o);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (curr < 2) {\n\t\t\t\t\tif (o->off5 && o->off6) {\n\t\t\t\t\t\tval_store(ullp, ull1, o->off5, 0, data, o);\n\t\t\t\t\t\tval_store(ullp, ull2, o->off6, 0, data, o);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\t}\n\tcase FIO_OPT_BOOL:\n\tcase FIO_OPT_STR_SET: {\n\t\tfio_opt_int_fn *fn = o->cb;\n\n\t\tif (ptr)\n\t\t\tret = check_int(ptr, &il);\n\t\telse if (o->type == FIO_OPT_BOOL)\n\t\t\tret = 1;\n\t\telse\n\t\t\til = 1;\n\n\t\tdprint(FD_PARSE, \"  ret=%d, out=%d\\n\", ret, il);\n\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (o->maxval && il > (int) o->maxval) {\n\t\t\tlog_err(\"max value out of range: %d (%llu max)\\n\",\n\t\t\t\t\t\t\t\til, o->maxval);\n\t\t\treturn 1;\n\t\t}\n\t\tif (o->minval && il < o->minval) {\n\t\t\tlog_err(\"min value out of range: %d (%d min)\\n\",\n\t\t\t\t\t\t\t\til, o->minval);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (o->neg)\n\t\t\til = !il;\n\n\t\tif (fn)\n\t\t\tret = fn(data, &il);\n\t\telse {\n\t\t\tif (first)\n\t\t\t\tval_store(ilp, il, o->off1, 0, data, o);\n\t\t\tif (!more) {\n\t\t\t\tif (o->off2)\n\t\t\t\t\tval_store(ilp, il, o->off2, 0, data, o);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase FIO_OPT_DEPRECATED:\n\t\tret = 1;\n\t\tfallthrough;\n\tcase FIO_OPT_SOFT_DEPRECATED:\n\t\tlog_info(\"Option %s is deprecated\\n\", o->name);\n\t\tbreak;\n\tdefault:\n\t\tlog_err(\"Bad option type %u\\n\", o->type);\n\t\tret = 1;\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (o->verify) {\n\t\tret = o->verify(o, data);\n\t\tif (ret) {\n\t\t\tlog_err(\"Correct format for offending option\\n\");\n\t\t\tlog_err(\"%20s: %s\\n\", o->name, o->help);\n\t\t\tshow_option_help(o, 1);\n\t\t}\n\t}\n\n\treturn ret;\n}\n",
    "target": 1,
    "idx": 1029633,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "// context\nstatic lzma_ret\ndecode_buffer(lzma_coder *coder,\n\t\tconst uint8_t *restrict in, size_t *restrict in_pos,\n\t\tsize_t in_size, uint8_t *restrict out,\n\t\tsize_t *restrict out_pos, size_t out_size)\n{\n\twhile (true) {\n\t\t// Wrap the dictionary if needed.\n\t\tif (coder->dict.pos == coder->dict.size)\n\t\t\tcoder->dict.pos = 0;\n\n\t\t// Store the current dictionary position. It is needed to know\n\t\t// where to start copying to the out[] buffer.\n\t\tconst size_t dict_start = coder->dict.pos;\n\n\t\t// Calculate how much we allow coder->lz.code() to decode.\n\t\t// It must not decode past the end of the dictionary\n\t\t// buffer, and we don't want it to decode more than is\n\t\t// actually needed to fill the out[] buffer.\n\t\tcoder->dict.limit = coder->dict.pos\n\t\t\t\t+ my_min(out_size - *out_pos,\n\t\t\t\t\tcoder->dict.size - coder->dict.pos);\n\n\t\t// Call the coder->lz.code() to do the actual decoding.\n\t\tconst lzma_ret ret = coder->lz.code(\n\t\t\t\tcoder->lz.coder, &coder->dict,\n\t\t\t\tin, in_pos, in_size);\n\n\t\t// Copy the decoded data from the dictionary to the out[]\n\t\t// buffer. Do it conditionally because out can be NULL\n\t\t// (in which case copy_size is always 0). Calling memcpy()\n\t\t// with a null-pointer is undefined even if the third\n\t\t// argument is 0.\n\t\tconst size_t copy_size = coder->dict.pos - dict_start;\n\t\tassert(copy_size <= out_size - *out_pos);\n\n\t\tif (copy_size > 0)\n\t\t\tmemcpy(out + *out_pos, coder->dict.buf + dict_start,\n\t\t\t\t\tcopy_size);\n\n\t\t*out_pos += copy_size;\n\n\t\t// Reset the dictionary if so requested by coder->lz.code().\n\t\tif (coder->dict.need_reset) {\n\t\t\tlz_decoder_reset(coder);\n\n\t\t\t// Since we reset dictionary, we don't check if\n\t\t\t// dictionary became full.\n\t\t\tif (ret != LZMA_OK || *out_pos == out_size)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\t// Return if everything got decoded or an error\n\t\t\t// occurred, or if there's no more data to decode.\n\t\t\t//\n\t\t\t// Note that detecting if there's something to decode\n\t\t\t// is done by looking if dictionary become full\n\t\t\t// instead of looking if *in_pos == in_size. This\n\t\t\t// is because it is possible that all the input was\n\t\t\t// consumed already but some data is pending to be\n\t\t\t// written to the dictionary.\n\t\t\tif (ret != LZMA_OK || *out_pos == out_size\n\t\t\t\t\t|| coder->dict.pos < coder->dict.size)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n}\n\nstatic lzma_ret\nlz_decode(void *coder_ptr,\n\t\tconst lzma_allocator *allocator lzma_attribute((__unused__)),\n\t\tconst uint8_t *restrict in, size_t *restrict in_pos,\n\t\tsize_t in_size, uint8_t *restrict out,\n\t\tsize_t *restrict out_pos, size_t out_size,\n\t\tlzma_action action)\n{\n\tlzma_coder *coder = coder_ptr;\n\n\tif (coder->next.code == NULL)\n\t\treturn decode_buffer(coder, in, in_pos, in_size,\n\t\t\t\tout, out_pos, out_size);\n\n\t// We aren't the last coder in the chain, we need to decode\n\t// our input to a temporary buffer.\n\twhile (*out_pos < out_size) {\n\t\t// Fill the temporary buffer if it is empty.\n\t\tif (!coder->next_finished\n\t\t\t\t&& coder->temp.pos == coder->temp.size) {\n\t\t\tcoder->temp.pos = 0;\n\t\t\tcoder->temp.size = 0;\n\n\t\t\tconst lzma_ret ret = coder->next.code(\n\t\t\t\t\tcoder->next.coder,\n\t\t\t\t\tallocator, in, in_pos, in_size,\n\t\t\t\t\tcoder->temp.buffer, &coder->temp.size,\n\t\t\t\t\tLZMA_BUFFER_SIZE, action);\n\n\t\t\tif (ret == LZMA_STREAM_END)\n\t\t\t\tcoder->next_finished = true;\n\t\t\telse if (ret != LZMA_OK || coder->temp.size == 0)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tif (coder->this_finished) {\n\t\t\tif (coder->temp.size != 0)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t\tif (coder->next_finished)\n\t\t\t\treturn LZMA_STREAM_END;\n\n\t\t\treturn LZMA_OK;\n\t\t}\n\n\t\tconst lzma_ret ret = decode_buffer(coder, coder->temp.buffer,\n\t\t\t\t&coder->temp.pos, coder->temp.size,\n\t\t\t\tout, out_pos, out_size);\n\n\t\tif (ret == LZMA_STREAM_END)\n\t\t\tcoder->this_finished = true;\n\t\telse if (ret != LZMA_OK)\n\t\t\treturn ret;\n\t\telse if (coder->next_finished && *out_pos < out_size)\n\t\t\treturn LZMA_DATA_ERROR;\n\t}\n\n\treturn LZMA_OK;\n}\n\nstatic lzma_ret\ncopy_or_code(lzma_simple_coder *coder, const lzma_allocator *allocator,\n\t\tconst uint8_t *restrict in, size_t *restrict in_pos,\n\t\tsize_t in_size, uint8_t *restrict out,\n\t\tsize_t *restrict out_pos, size_t out_size, lzma_action action)\n{\n\tassert(!coder->end_was_reached);\n\n\tif (coder->next.code == NULL) {\n\t\tlzma_bufcpy(in, in_pos, in_size, out, out_pos, out_size);\n\n\t\t// Check if end of stream was reached.\n\t\tif (coder->is_encoder && action == LZMA_FINISH\n\t\t\t\t&& *in_pos == in_size)\n\t\t\tcoder->end_was_reached = true;\n\n\t} else {\n\t\t// Call the next coder in the chain to provide us some data.\n\t\tconst lzma_ret ret = coder->next.code(\n\t\t\t\tcoder->next.coder, allocator,\n\t\t\t\tin, in_pos, in_size,\n\t\t\t\tout, out_pos, out_size, action);\n\n\t\tif (ret == LZMA_STREAM_END) {\n\t\t\tassert(!coder->is_encoder\n\t\t\t\t\t|| action == LZMA_FINISH);\n\t\t\tcoder->end_was_reached = true;\n\n\t\t} else if (ret != LZMA_OK) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn LZMA_OK;\n}\n\nstatic lzma_ret\nsimple_code(void *coder_ptr, const lzma_allocator *allocator,\n\t\tconst uint8_t *restrict in, size_t *restrict in_pos,\n\t\tsize_t in_size, uint8_t *restrict out,\n\t\tsize_t *restrict out_pos, size_t out_size, lzma_action action)\n{\n\tlzma_simple_coder *coder = coder_ptr;\n\n\t// TODO: Add partial support for LZMA_SYNC_FLUSH. We can support it\n\t// in cases when the filter is able to filter everything. With most\n\t// simple filters it can be done at offset that is a multiple of 2,\n\t// 4, or 16. With x86 filter, it needs good luck, and thus cannot\n\t// be made to work predictably.\n\tif (action == LZMA_SYNC_FLUSH)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t// Flush already filtered data from coder->buffer[] to out[].\n\tif (coder->pos < coder->filtered) {\n\t\tlzma_bufcpy(coder->buffer, &coder->pos, coder->filtered,\n\t\t\t\tout, out_pos, out_size);\n\n\t\t// If we couldn't flush all the filtered data, return to\n\t\t// application immediately.\n\t\tif (coder->pos < coder->filtered)\n\t\t\treturn LZMA_OK;\n\n\t\tif (coder->end_was_reached) {\n\t\t\tassert(coder->filtered == coder->size);\n\t\t\treturn LZMA_STREAM_END;\n\t\t}\n\t}\n\n\t// If we get here, there is no filtered data left in the buffer.\n\tcoder->filtered = 0;\n\n\tassert(!coder->end_was_reached);\n\n\t// If there is more output space left than there is unfiltered data\n\t// in coder->buffer[], flush coder->buffer[] to out[], and copy/code\n\t// more data to out[] hopefully filling it completely. Then filter\n\t// the data in out[]. This step is where most of the data gets\n\t// filtered if the buffer sizes used by the application are reasonable.\n\tconst size_t out_avail = out_size - *out_pos;\n\tconst size_t buf_avail = coder->size - coder->pos;\n\tif (out_avail > buf_avail || buf_avail == 0) {\n\t\t// Store the old position so that we know from which byte\n\t\t// to start filtering.\n\t\tconst size_t out_start = *out_pos;\n\n\t\t// Flush data from coder->buffer[] to out[], but don't reset\n\t\t// coder->pos and coder->size yet. This way the coder can be\n\t\t// restarted if the next filter in the chain returns e.g.\n\t\t// LZMA_MEM_ERROR.\n\t\t//\n\t\t// Do the memcpy() conditionally because out can be NULL\n\t\t// (in which case buf_avail is always 0). Calling memcpy()\n\t\t// with a null-pointer is undefined even if the third\n\t\t// argument is 0.\n\t\tif (buf_avail > 0)\n\t\t\tmemcpy(out + *out_pos, coder->buffer + coder->pos,\n\t\t\t\t\tbuf_avail);\n\n\t\t*out_pos += buf_avail;\n\n\t\t// Copy/Encode/Decode more data to out[].\n\t\t{\n\t\t\tconst lzma_ret ret = copy_or_code(coder, allocator,\n\t\t\t\t\tin, in_pos, in_size,\n\t\t\t\t\tout, out_pos, out_size, action);\n\t\t\tassert(ret != LZMA_STREAM_END);\n\t\t\tif (ret != LZMA_OK)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\t// Filter out[].\n\t\tconst size_t size = *out_pos - out_start;\n\t\tconst size_t filtered = call_filter(\n\t\t\t\tcoder, out + out_start, size);\n\n\t\tconst size_t unfiltered = size - filtered;\n\t\tassert(unfiltered <= coder->allocated / 2);\n\n\t\t// Now we can update coder->pos and coder->size, because\n\t\t// the next coder in the chain (if any) was successful.\n\t\tcoder->pos = 0;\n\t\tcoder->size = unfiltered;\n\n\t\tif (coder->end_was_reached) {\n\t\t\t// The last byte has been copied to out[] already.\n\t\t\t// They are left as is.\n\t\t\tcoder->size = 0;\n\n\t\t} else if (unfiltered > 0) {\n\t\t\t// There is unfiltered data left in out[]. Copy it to\n\t\t\t// coder->buffer[] and rewind *out_pos appropriately.\n\t\t\t*out_pos -= unfiltered;\n\t\t\tmemcpy(coder->buffer, out + *out_pos, unfiltered);\n\t\t}\n\t} else if (coder->pos > 0) {\n\t\tmemmove(coder->buffer, coder->buffer + coder->pos, buf_avail);\n\t\tcoder->size -= coder->pos;\n\t\tcoder->pos = 0;\n\t}\n\n\tassert(coder->pos == 0);\n\n\t// If coder->buffer[] isn't empty, try to fill it by copying/decoding\n\t// more data. Then filter coder->buffer[] and copy the successfully\n\t// filtered data to out[]. It is probable, that some filtered and\n\t// unfiltered data will be left to coder->buffer[].\n\tif (coder->size > 0) {\n\t\t{\n\t\t\tconst lzma_ret ret = copy_or_code(coder, allocator,\n\t\t\t\t\tin, in_pos, in_size,\n\t\t\t\t\tcoder->buffer, &coder->size,\n\t\t\t\t\tcoder->allocated, action);\n\t\t\tassert(ret != LZMA_STREAM_END);\n\t\t\tif (ret != LZMA_OK)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tcoder->filtered = call_filter(\n\t\t\t\tcoder, coder->buffer, coder->size);\n\n\t\t// Everything is considered to be filtered if coder->buffer[]\n\t\t// contains the last bytes of the data.\n\t\tif (coder->end_was_reached)\n\t\t\tcoder->filtered = coder->size;\n\n\t\t// Flush as much as possible.\n\t\tlzma_bufcpy(coder->buffer, &coder->pos, coder->filtered,\n\t\t\t\tout, out_pos, out_size);\n\t}\n\n\t// Check if we got everything done.\n\tif (coder->end_was_reached && coder->pos == coder->size)\n\t\treturn LZMA_STREAM_END;\n\n\treturn LZMA_OK;\n}\n\nstatic lzma_ret\nblock_decode(void *coder_ptr, const lzma_allocator *allocator,\n\t\tconst uint8_t *restrict in, size_t *restrict in_pos,\n\t\tsize_t in_size, uint8_t *restrict out,\n\t\tsize_t *restrict out_pos, size_t out_size, lzma_action action)\n{\n\tlzma_block_coder *coder = coder_ptr;\n\n\tswitch (coder->sequence) {\n\tcase SEQ_CODE: {\n\t\tconst size_t in_start = *in_pos;\n\t\tconst size_t out_start = *out_pos;\n\n\t\tconst lzma_ret ret = coder->next.code(coder->next.coder,\n\t\t\t\tallocator, in, in_pos, in_size,\n\t\t\t\tout, out_pos, out_size, action);\n\n\t\tconst size_t in_used = *in_pos - in_start;\n\t\tconst size_t out_used = *out_pos - out_start;\n\n\t\t// NOTE: We compare to compressed_limit here, which prevents\n\t\t// the total size of the Block growing past LZMA_VLI_MAX.\n\t\tif (update_size(&coder->compressed_size, in_used,\n\t\t\t\t\tcoder->compressed_limit)\n\t\t\t\t|| update_size(&coder->uncompressed_size,\n\t\t\t\t\tout_used,\n\t\t\t\t\tcoder->block->uncompressed_size))\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\tif (!coder->ignore_check)\n\t\t\tlzma_check_update(&coder->check, coder->block->check,\n\t\t\t\t\tout + out_start, out_used);\n\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\treturn ret;\n\n\t\t// Compressed and Uncompressed Sizes are now at their final\n\t\t// values. Verify that they match the values given to us.\n\t\tif (!is_size_valid(coder->compressed_size,\n\t\t\t\t\tcoder->block->compressed_size)\n\t\t\t\t|| !is_size_valid(coder->uncompressed_size,\n\t\t\t\t\tcoder->block->uncompressed_size))\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Copy the values into coder->block. The caller\n\t\t// may use this information to construct Index.\n\t\tcoder->block->compressed_size = coder->compressed_size;\n\t\tcoder->block->uncompressed_size = coder->uncompressed_size;\n\n\t\tcoder->sequence = SEQ_PADDING;\n\t}\n\n\t// Fall through\n\n\tcase SEQ_PADDING:\n\t\t// Compressed Data is padded to a multiple of four bytes.\n\t\twhile (coder->compressed_size & 3) {\n\t\t\tif (*in_pos >= in_size)\n\t\t\t\treturn LZMA_OK;\n\n\t\t\t// We use compressed_size here just get the Padding\n\t\t\t// right. The actual Compressed Size was stored to\n\t\t\t// coder->block already, and won't be modified by\n\t\t\t// us anymore.\n\t\t\t++coder->compressed_size;\n\n\t\t\tif (in[(*in_pos)++] != 0x00)\n\t\t\t\treturn LZMA_DATA_ERROR;\n\t\t}\n\n\t\tif (coder->block->check == LZMA_CHECK_NONE)\n\t\t\treturn LZMA_STREAM_END;\n\n\t\tif (!coder->ignore_check)\n\t\t\tlzma_check_finish(&coder->check, coder->block->check);\n\n\t\tcoder->sequence = SEQ_CHECK;\n\n\t// Fall through\n\n\tcase SEQ_CHECK: {\n\t\tconst size_t check_size = lzma_check_size(coder->block->check);\n\t\tlzma_bufcpy(in, in_pos, in_size, coder->block->raw_check,\n\t\t\t\t&coder->check_pos, check_size);\n\t\tif (coder->check_pos < check_size)\n\t\t\treturn LZMA_OK;\n\n\t\t// Validate the Check only if we support it.\n\t\t// coder->check.buffer may be uninitialized\n\t\t// when the Check ID is not supported.\n\t\tif (!coder->ignore_check\n\t\t\t\t&& lzma_check_is_supported(coder->block->check)\n\t\t\t\t&& memcmp(coder->block->raw_check,\n\t\t\t\t\tcoder->check.buffer.u8,\n\t\t\t\t\tcheck_size) != 0)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\treturn LZMA_STREAM_END;\n\t}\n\t}\n\n\treturn LZMA_PROG_ERROR;\n}\n\nstatic lzma_ret\nstream_decode(void *coder_ptr, const lzma_allocator *allocator,\n\t\tconst uint8_t *restrict in, size_t *restrict in_pos,\n\t\tsize_t in_size, uint8_t *restrict out,\n\t\tsize_t *restrict out_pos, size_t out_size, lzma_action action)\n{\n\tlzma_stream_coder *coder = coder_ptr;\n\n\t// When decoding the actual Block, it may be able to produce more\n\t// output even if we don't give it any new input.\n\twhile (true)\n\tswitch (coder->sequence) {\n\tcase SEQ_STREAM_HEADER: {\n\t\t// Copy the Stream Header to the internal buffer.\n\t\tlzma_bufcpy(in, in_pos, in_size, coder->buffer, &coder->pos,\n\t\t\t\tLZMA_STREAM_HEADER_SIZE);\n\n\t\t// Return if we didn't get the whole Stream Header yet.\n\t\tif (coder->pos < LZMA_STREAM_HEADER_SIZE)\n\t\t\treturn LZMA_OK;\n\n\t\tcoder->pos = 0;\n\n\t\t// Decode the Stream Header.\n\t\tconst lzma_ret ret = lzma_stream_header_decode(\n\t\t\t\t&coder->stream_flags, coder->buffer);\n\t\tif (ret != LZMA_OK)\n\t\t\treturn ret == LZMA_FORMAT_ERROR && !coder->first_stream\n\t\t\t\t\t? LZMA_DATA_ERROR : ret;\n\n\t\t// If we are decoding concatenated Streams, and the later\n\t\t// Streams have invalid Header Magic Bytes, we give\n\t\t// LZMA_DATA_ERROR instead of LZMA_FORMAT_ERROR.\n\t\tcoder->first_stream = false;\n\n\t\t// Copy the type of the Check so that Block Header and Block\n\t\t// decoders see it.\n\t\tcoder->block_options.check = coder->stream_flags.check;\n\n\t\t// Even if we return LZMA_*_CHECK below, we want\n\t\t// to continue from Block Header decoding.\n\t\tcoder->sequence = SEQ_BLOCK_HEADER;\n\n\t\t// Detect if there's no integrity check or if it is\n\t\t// unsupported if those were requested by the application.\n\t\tif (coder->tell_no_check && coder->stream_flags.check\n\t\t\t\t== LZMA_CHECK_NONE)\n\t\t\treturn LZMA_NO_CHECK;\n\n\t\tif (coder->tell_unsupported_check\n\t\t\t\t&& !lzma_check_is_supported(\n\t\t\t\t\tcoder->stream_flags.check))\n\t\t\treturn LZMA_UNSUPPORTED_CHECK;\n\n\t\tif (coder->tell_any_check)\n\t\t\treturn LZMA_GET_CHECK;\n\t}\n\n\t// Fall through\n\n\tcase SEQ_BLOCK_HEADER: {\n\t\tif (*in_pos >= in_size)\n\t\t\treturn LZMA_OK;\n\n\t\tif (coder->pos == 0) {\n\t\t\t// Detect if it's Index.\n\t\t\tif (in[*in_pos] == 0x00) {\n\t\t\t\tcoder->sequence = SEQ_INDEX;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Calculate the size of the Block Header. Note that\n\t\t\t// Block Header decoder wants to see this byte too\n\t\t\t// so don't advance *in_pos.\n\t\t\tcoder->block_options.header_size\n\t\t\t\t\t= lzma_block_header_size_decode(\n\t\t\t\t\t\tin[*in_pos]);\n\t\t}\n\n\t\t// Copy the Block Header to the internal buffer.\n\t\tlzma_bufcpy(in, in_pos, in_size, coder->buffer, &coder->pos,\n\t\t\t\tcoder->block_options.header_size);\n\n\t\t// Return if we didn't get the whole Block Header yet.\n\t\tif (coder->pos < coder->block_options.header_size)\n\t\t\treturn LZMA_OK;\n\n\t\tcoder->pos = 0;\n\n\t\t// Version 1 is needed to support the .ignore_check option.\n\t\tcoder->block_options.version = 1;\n\n\t\t// Set up a buffer to hold the filter chain. Block Header\n\t\t// decoder will initialize all members of this array so\n\t\t// we don't need to do it here.\n\t\tlzma_filter filters[LZMA_FILTERS_MAX + 1];\n\t\tcoder->block_options.filters = filters;\n\n\t\t// Decode the Block Header.\n\t\treturn_if_error(lzma_block_header_decode(&coder->block_options,\n\t\t\t\tallocator, coder->buffer));\n\n\t\t// If LZMA_IGNORE_CHECK was used, this flag needs to be set.\n\t\t// It has to be set after lzma_block_header_decode() because\n\t\t// it always resets this to false.\n\t\tcoder->block_options.ignore_check = coder->ignore_check;\n\n\t\t// Check the memory usage limit.\n\t\tconst uint64_t memusage = lzma_raw_decoder_memusage(filters);\n\t\tlzma_ret ret;\n\n\t\tif (memusage == UINT64_MAX) {\n\t\t\t// One or more unknown Filter IDs.\n\t\t\tret = LZMA_OPTIONS_ERROR;\n\t\t} else {\n\t\t\t// Now we can set coder->memusage since we know that\n\t\t\t// the filter chain is valid. We don't want\n\t\t\t// lzma_memusage() to return UINT64_MAX in case of\n\t\t\t// invalid filter chain.\n\t\t\tcoder->memusage = memusage;\n\n\t\t\tif (memusage > coder->memlimit) {\n\t\t\t\t// The chain would need too much memory.\n\t\t\t\tret = LZMA_MEMLIMIT_ERROR;\n\t\t\t} else {\n\t\t\t\t// Memory usage is OK.\n\t\t\t\t// Initialize the Block decoder.\n\t\t\t\tret = lzma_block_decoder_init(\n\t\t\t\t\t\t&coder->block_decoder,\n\t\t\t\t\t\tallocator,\n\t\t\t\t\t\t&coder->block_options);\n\t\t\t}\n\t\t}\n\n\t\t// Free the allocated filter options since they are needed\n\t\t// only to initialize the Block decoder.\n\t\tfor (size_t i = 0; i < LZMA_FILTERS_MAX; ++i)\n\t\t\tlzma_free(filters[i].options, allocator);\n\n\t\tcoder->block_options.filters = NULL;\n\n\t\t// Check if memory usage calculation and Block enocoder\n\t\t// initialization succeeded.\n\t\tif (ret != LZMA_OK)\n\t\t\treturn ret;\n\n\t\tcoder->sequence = SEQ_BLOCK;\n\t}\n\n\t// Fall through\n\n\tcase SEQ_BLOCK: {\n\t\tconst lzma_ret ret = coder->block_decoder.code(\n\t\t\t\tcoder->block_decoder.coder, allocator,\n\t\t\t\tin, in_pos, in_size, out, out_pos, out_size,\n\t\t\t\taction);\n\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\treturn ret;\n\n\t\t// Block decoded successfully. Add the new size pair to\n\t\t// the Index hash.\n\t\treturn_if_error(lzma_index_hash_append(coder->index_hash,\n\t\t\t\tlzma_block_unpadded_size(\n\t\t\t\t\t&coder->block_options),\n\t\t\t\tcoder->block_options.uncompressed_size));\n\n\t\tcoder->sequence = SEQ_BLOCK_HEADER;\n\t\tbreak;\n\t}\n\n\tcase SEQ_INDEX: {\n\t\t// If we don't have any input, don't call\n\t\t// lzma_index_hash_decode() since it would return\n\t\t// LZMA_BUF_ERROR, which we must not do here.\n\t\tif (*in_pos >= in_size)\n\t\t\treturn LZMA_OK;\n\n\t\t// Decode the Index and compare it to the hash calculated\n\t\t// from the sizes of the Blocks (if any).\n\t\tconst lzma_ret ret = lzma_index_hash_decode(coder->index_hash,\n\t\t\t\tin, in_pos, in_size);\n\t\tif (ret != LZMA_STREAM_END)\n\t\t\treturn ret;\n\n\t\tcoder->sequence = SEQ_STREAM_FOOTER;\n\t}\n\n\t// Fall through\n\n\tcase SEQ_STREAM_FOOTER: {\n\t\t// Copy the Stream Footer to the internal buffer.\n\t\tlzma_bufcpy(in, in_pos, in_size, coder->buffer, &coder->pos,\n\t\t\t\tLZMA_STREAM_HEADER_SIZE);\n\n\t\t// Return if we didn't get the whole Stream Footer yet.\n\t\tif (coder->pos < LZMA_STREAM_HEADER_SIZE)\n\t\t\treturn LZMA_OK;\n\n\t\tcoder->pos = 0;\n\n\t\t// Decode the Stream Footer. The decoder gives\n\t\t// LZMA_FORMAT_ERROR if the magic bytes don't match,\n\t\t// so convert that return code to LZMA_DATA_ERROR.\n\t\tlzma_stream_flags footer_flags;\n\t\tconst lzma_ret ret = lzma_stream_footer_decode(\n\t\t\t\t&footer_flags, coder->buffer);\n\t\tif (ret != LZMA_OK)\n\t\t\treturn ret == LZMA_FORMAT_ERROR\n\t\t\t\t\t? LZMA_DATA_ERROR : ret;\n\n\t\t// Check that Index Size stored in the Stream Footer matches\n\t\t// the real size of the Index field.\n\t\tif (lzma_index_hash_size(coder->index_hash)\n\t\t\t\t!= footer_flags.backward_size)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\t// Compare that the Stream Flags fields are identical in\n\t\t// both Stream Header and Stream Footer.\n\t\treturn_if_error(lzma_stream_flags_compare(\n\t\t\t\t&coder->stream_flags, &footer_flags));\n\n\t\tif (!coder->concatenated)\n\t\t\treturn LZMA_STREAM_END;\n\n\t\tcoder->sequence = SEQ_STREAM_PADDING;\n\t}\n\n\t// Fall through\n\n\tcase SEQ_STREAM_PADDING:\n\t\tassert(coder->concatenated);\n\n\t\t// Skip over possible Stream Padding.\n\t\twhile (true) {\n\t\t\tif (*in_pos >= in_size) {\n\t\t\t\t// Unless LZMA_FINISH was used, we cannot\n\t\t\t\t// know if there's more input coming later.\n\t\t\t\tif (action != LZMA_FINISH)\n\t\t\t\t\treturn LZMA_OK;\n\n\t\t\t\t// Stream Padding must be a multiple of\n\t\t\t\t// four bytes.\n\t\t\t\treturn coder->pos == 0\n\t\t\t\t\t\t? LZMA_STREAM_END\n\t\t\t\t\t\t: LZMA_DATA_ERROR;\n\t\t\t}\n\n\t\t\t// If the byte is not zero, it probably indicates\n\t\t\t// beginning of a new Stream (or the file is corrupt).\n\t\t\tif (in[*in_pos] != 0x00)\n\t\t\t\tbreak;\n\n\t\t\t++*in_pos;\n\t\t\tcoder->pos = (coder->pos + 1) & 3;\n\t\t}\n\n\t\t// Stream Padding must be a multiple of four bytes (empty\n\t\t// Stream Padding is OK).\n\t\tif (coder->pos != 0) {\n\t\t\t++*in_pos;\n\t\t\treturn LZMA_DATA_ERROR;\n\t\t}\n\n\t\t// Prepare to decode the next Stream.\n\t\treturn_if_error(stream_decoder_reset(coder, allocator));\n\t\tbreak;\n\n\tdefault:\n\t\tassert(0);\n\t\treturn LZMA_PROG_ERROR;\n\t}\n\n\t// Never reached\n}\n\nstatic lzma_ret\nauto_decode(void *coder_ptr, const lzma_allocator *allocator,\n\t\tconst uint8_t *restrict in, size_t *restrict in_pos,\n\t\tsize_t in_size, uint8_t *restrict out,\n\t\tsize_t *restrict out_pos, size_t out_size, lzma_action action)\n{\n\tlzma_auto_coder *coder = coder_ptr;\n\n\tswitch (coder->sequence) {\n\tcase SEQ_INIT:\n\t\tif (*in_pos >= in_size)\n\t\t\treturn LZMA_OK;\n\n\t\t// Update the sequence now, because we want to continue from\n\t\t// SEQ_CODE even if we return some LZMA_*_CHECK.\n\t\tcoder->sequence = SEQ_CODE;\n\n\t\t// Detect the file format. For now this is simple, since if\n\t\t// it doesn't start with 0xFD (the first magic byte of the\n\t\t// new format), it has to be LZMA_Alone, or something that\n\t\t// we don't support at all.\n\t\tif (in[*in_pos] == 0xFD) {\n\t\t\treturn_if_error(lzma_stream_decoder_init(\n\t\t\t\t\t&coder->next, allocator,\n\t\t\t\t\tcoder->memlimit, coder->flags));\n\t\t} else {\n\t\t\treturn_if_error(lzma_alone_decoder_init(&coder->next,\n\t\t\t\t\tallocator, coder->memlimit, true));\n\n\t\t\t// If the application wants to know about missing\n\t\t\t// integrity check or about the check in general, we\n\t\t\t// need to handle it here, because LZMA_Alone decoder\n\t\t\t// doesn't accept any flags.\n\t\t\tif (coder->flags & LZMA_TELL_NO_CHECK)\n\t\t\t\treturn LZMA_NO_CHECK;\n\n\t\t\tif (coder->flags & LZMA_TELL_ANY_CHECK)\n\t\t\t\treturn LZMA_GET_CHECK;\n\t\t}\n\n\t// Fall through\n\n\tcase SEQ_CODE: {\n\t\tconst lzma_ret ret = coder->next.code(\n\t\t\t\tcoder->next.coder, allocator,\n\t\t\t\tin, in_pos, in_size,\n\t\t\t\tout, out_pos, out_size, action);\n\t\tif (ret != LZMA_STREAM_END\n\t\t\t\t|| (coder->flags & LZMA_CONCATENATED) == 0)\n\t\t\treturn ret;\n\n\t\tcoder->sequence = SEQ_FINISH;\n\t}\n\n\t// Fall through\n\n\tcase SEQ_FINISH:\n\t\t// When LZMA_DECODE_CONCATENATED was used and we were decoding\n\t\t// LZMA_Alone file, we need to check check that there is no\n\t\t// trailing garbage and wait for LZMA_FINISH.\n\t\tif (*in_pos < in_size)\n\t\t\treturn LZMA_DATA_ERROR;\n\n\t\treturn action == LZMA_FINISH ? LZMA_STREAM_END : LZMA_OK;\n\n\tdefault:\n\t\tassert(0);\n\t\treturn LZMA_PROG_ERROR;\n\t}\n}\n\n\n\nKXzFilter::Result KXzFilter::uncompress()\n{\n    //qCDebug(KArchiveLog) << \"Calling lzma_code with avail_in=\" << inBufferAvailable() << \" avail_out =\" << outBufferAvailable();\n    lzma_ret result;\n    result = lzma_code(&d->zStream, LZMA_RUN);\n\n    /*if (result != LZMA_OK) {\n        qCDebug(KArchiveLog) << \"lzma_code returned \" << result;\n        //qCDebug(KArchiveLog) << \"KXzFilter::uncompress \" << ( result == LZMA_STREAM_END ? KFilterBase::End : KFilterBase::Error );\n    }*/\n\n    switch (result) {\n    case LZMA_OK:\n        return KFilterBase::Ok;\n    case LZMA_STREAM_END:\n        return KFilterBase::End;\n    default:\n        return KFilterBase::Error;\n    }\n}\n\nqint64 KCompressionDevice::readData(char *data, qint64 maxlen)\n{\n    Q_ASSERT(d->filter->mode() == QIODevice::ReadOnly);\n    //qCDebug(KArchiveLog) << \"maxlen=\" << maxlen;\n    KFilterBase *filter = d->filter;\n\n    uint dataReceived = 0;\n\n    // We came to the end of the stream\n    if (d->result == KFilterBase::End) {\n        return dataReceived;\n    }\n\n    // If we had an error, return -1.\n    if (d->result != KFilterBase::Ok) {\n        return -1;\n    }\n\n    qint64 availOut = maxlen;\n    filter->setOutBuffer(data, maxlen);\n\n    while (dataReceived < maxlen) {\n        if (filter->inBufferEmpty()) {\n            // Not sure about the best size to set there.\n            // For sure, it should be bigger than the header size (see comment in readHeader)\n            d->buffer.resize(BUFFER_SIZE);\n            // Request data from underlying device\n            int size = filter->device()->read(d->buffer.data(),\n                                              d->buffer.size());\n            //qCDebug(KArchiveLog) << \"got\" << size << \"bytes from device\";\n            if (size) {\n                filter->setInBuffer(d->buffer.data(), size);\n            } else {\n                // Not enough data available in underlying device for now\n                break;\n            }\n        }\n        if (d->bNeedHeader) {\n            (void) filter->readHeader();\n            d->bNeedHeader = false;\n        }\n\n        d->result = filter->uncompress();\n\n        if (d->result == KFilterBase::Error) {\n            //qCWarning(KArchiveLog) << \"KCompressionDevice: Error when uncompressing data\";\n            break;\n        }\n\n        // We got that much data since the last time we went here\n        uint outReceived = availOut - filter->outBufferAvailable();\n        //qCDebug(KArchiveLog) << \"avail_out = \" << filter->outBufferAvailable() << \" result=\" << d->result << \" outReceived=\" << outReceived;\n        if (availOut < uint(filter->outBufferAvailable())) {\n            //qCWarning(KArchiveLog) << \" last availOut \" << availOut << \" smaller than new avail_out=\" << filter->outBufferAvailable() << \" !\";\n        }\n\n        dataReceived += outReceived;\n        data += outReceived;\n        availOut = maxlen - dataReceived;\n        if (d->result == KFilterBase::End) {\n            // We're actually at the end, no more data to check\n            if (filter->device()->atEnd()) {\n                break;\n            }\n\n            // Still not done, re-init and try again\n            filter->init(filter->mode());\n        }\n        filter->setOutBuffer(data, availOut);\n    }\n\n    d->deviceReadPos += dataReceived;\n    return dataReceived;\n}\n\nQByteArray QIODevice::read(qint64 maxSize)\n{\n    Q_D(QIODevice);\n    QByteArray result;\n\n#if defined QIODEVICE_DEBUG\n    printf(\"%p QIODevice::read(%lld), d->pos = %lld, d->buffer.size() = %lld\\n\",\n           this, maxSize, d->pos, d->buffer.size());\n#endif\n\n    // Try to prevent the data from being copied, if we have a chunk\n    // with the same size in the read buffer.\n    if (maxSize == d->buffer.nextDataBlockSize() && !d->transactionStarted\n        && (d->openMode & (QIODevice::ReadOnly | QIODevice::Text)) == QIODevice::ReadOnly) {\n        result = d->buffer.read();\n        if (!d->isSequential())\n            d->pos += maxSize;\n        if (d->buffer.isEmpty())\n            readData(nullptr, 0);\n        return result;\n    }\n\n    CHECK_MAXLEN(read, result);\n    CHECK_MAXBYTEARRAYSIZE(read);\n\n    result.resize(int(maxSize));\n    qint64 readBytes = read(result.data(), result.size());\n\n    if (readBytes <= 0)\n        result.clear();\n    else\n        result.resize(int(readBytes));\n\n    return result;\n}\n\nbool KCompressionDevice::seek(qint64 pos)\n{\n    if (d->deviceReadPos == pos) {\n        return QIODevice::seek(pos);\n    }\n\n    //qCDebug(KArchiveLog) << \"seek(\" << pos << \") called, current pos=\" << QIODevice::pos();\n\n    Q_ASSERT(d->filter->mode() == QIODevice::ReadOnly);\n\n    if (pos == 0) {\n        if (!QIODevice::seek(pos))\n            return false;\n\n        // We can forget about the cached data\n        d->bNeedHeader = !d->bSkipHeaders;\n        d->result = KFilterBase::Ok;\n        d->filter->setInBuffer(nullptr, 0);\n        d->filter->reset();\n        d->deviceReadPos = 0;\n        return d->filter->device()->reset();\n    }\n\n    qint64 bytesToRead;\n    if (d->deviceReadPos < pos) { // we can start from here\n        bytesToRead = pos - d->deviceReadPos;\n        // Since we're going to do a read() below\n        // we need to reset the internal QIODevice pos to the real position we are\n        // so that after read() we are indeed pointing to the pos seek\n        // asked us to be in\n        if (!QIODevice::seek(d->deviceReadPos)) {\n            return false;\n        }\n    } else {\n        // we have to start from 0 ! Ugly and slow, but better than the previous\n        // solution (KTarGz was allocating everything into memory)\n        if (!seek(0)) { // recursive\n            return false;\n        }\n        bytesToRead = pos;\n    }\n\n    //qCDebug(KArchiveLog) << \"reading \" << bytesToRead << \" dummy bytes\";\n    QByteArray dummy(qMin(bytesToRead, qint64(SEEK_BUFFER_SIZE)), 0);\n    while (bytesToRead > 0) {\n        const qint64 bytesToReadThisTime = qMin(bytesToRead, qint64(dummy.size()));\n        const bool result = (read(dummy.data(), bytesToReadThisTime) == bytesToReadThisTime);\n        if (!result) {\n            return false;\n        }\n        bytesToRead -= bytesToReadThisTime;\n    }\n    return true;\n}\n\nbool KTar::openArchive(QIODevice::OpenMode mode)\n{\n\n    if (!(mode & QIODevice::ReadOnly)) {\n        return true;\n    }\n\n    if (!d->fillTempFile(fileName())) {\n        return false;\n    }\n\n    // We'll use the permission and user/group of d->rootDir\n    // for any directory we emulate (see findOrCreate)\n    //struct stat buf;\n    //stat( fileName(), &buf );\n\n    d->dirList.clear();\n    QIODevice *dev = device();\n\n    if (!dev) {\n        setErrorString(tr(\"Could not get underlying device\"));\n        qCWarning(KArchiveLog) << \"Could not get underlying device\";\n        return false;\n    }\n\n    // read dir information\n    char buffer[0x200];\n    bool ende = false;\n    do {\n        QString name;\n        QString symlink;\n\n        // Read header\n        qint64 n = d->readHeader(buffer, name, symlink);\n        if (n < 0) {\n            setErrorString(tr(\"Could not read tar header\"));\n            return false;\n        }\n        if (n == 0x200) {\n            bool isdir = false;\n\n            if (name.isEmpty()) {\n                continue;\n            }\n            if (name.endsWith(QLatin1Char('/'))) {\n                isdir = true;\n                name.truncate(name.length() - 1);\n            }\n\n            QByteArray prefix = QByteArray(buffer + 0x159, 155);\n            if (prefix[0] != '\\0') {\n                name = (QString::fromLatin1(prefix.constData()) + QLatin1Char('/') +  name);\n            }\n\n            int pos = name.lastIndexOf(QLatin1Char('/'));\n            QString nm = (pos == -1) ? name : name.mid(pos + 1);\n\n            // read access\n            buffer[0x6b] = 0;\n            char *dummy;\n            const char *p = buffer + 0x64;\n            while (*p == ' ') {\n                ++p;\n            }\n            int access = strtol(p, &dummy, 8);\n\n            // read user and group\n            const int maxUserGroupLength = 32;\n            const char *userStart = buffer + 0x109;\n            const int userLen = qstrnlen(userStart, maxUserGroupLength);\n            const QString user = QString::fromLocal8Bit(userStart, userLen);\n            const char *groupStart = buffer + 0x129;\n            const int groupLen = qstrnlen(groupStart, maxUserGroupLength);\n            const QString group = QString::fromLocal8Bit(groupStart, groupLen);\n\n            // read time\n            buffer[0x93] = 0;\n            p = buffer + 0x88;\n            while (*p == ' ') {\n                ++p;\n            }\n            uint time = strtol(p, &dummy, 8);\n\n            // read type flag\n            char typeflag = buffer[0x9c];\n            // '0' for files, '1' hard link, '2' symlink, '5' for directory\n            // (and 'L' for longlink fileNames, 'K' for longlink symlink targets)\n            // 'D' for GNU tar extension DUMPDIR, 'x' for Extended header referring\n            // to the next file in the archive and 'g' for Global extended header\n\n            if (typeflag == '5') {\n                isdir = true;\n            }\n\n            bool isDumpDir = false;\n            if (typeflag == 'D') {\n                isdir = false;\n                isDumpDir = true;\n            }\n            //qCDebug(KArchiveLog) << nm << \"isdir=\" << isdir << \"pos=\" << dev->pos() << \"typeflag=\" << typeflag << \" islink=\" << ( typeflag == '1' || typeflag == '2' );\n\n            if (typeflag == 'x' || typeflag == 'g') { // pax extended header, or pax global extended header\n                // Skip it for now. TODO: implement reading of extended header, as per http://pubs.opengroup.org/onlinepubs/009695399/utilities/pax.html\n                (void)dev->read(buffer, 0x200);\n                continue;\n            }\n\n            if (isdir) {\n                access |= S_IFDIR;    // f*cking broken tar files\n            }\n\n            KArchiveEntry *e;\n            if (isdir) {\n                //qCDebug(KArchiveLog) << \"directory\" << nm;\n                e = new KArchiveDirectory(this, nm, access, KArchivePrivate::time_tToDateTime(time), user, group, symlink);\n            } else {\n                // read size\n                QByteArray sizeBuffer(buffer + 0x7c, 12);\n                qint64 size = sizeBuffer.trimmed().toLongLong(nullptr, 8 /*octal*/);\n                //qCDebug(KArchiveLog) << \"sizeBuffer='\" << sizeBuffer << \"' -> size=\" << size;\n\n                // for isDumpDir we will skip the additional info about that dirs contents\n                if (isDumpDir) {\n                    //qCDebug(KArchiveLog) << nm << \"isDumpDir\";\n                    e = new KArchiveDirectory(this, nm, access, KArchivePrivate::time_tToDateTime(time), user, group, symlink);\n                } else {\n\n                    // Let's hack around hard links. Our classes don't support that, so make them symlinks\n                    if (typeflag == '1') {\n                        //qCDebug(KArchiveLog) << \"Hard link, setting size to 0 instead of\" << size;\n                        size = 0; // no contents\n                    }\n\n                    //qCDebug(KArchiveLog) << \"file\" << nm << \"size=\" << size;\n                    e = new KArchiveFile(this, nm, access, KArchivePrivate::time_tToDateTime(time), user, group, symlink,\n                                         dev->pos(), size);\n                }\n\n                // Skip contents + align bytes\n                qint64 rest = size % 0x200;\n                qint64 skip = size + (rest ? 0x200 - rest : 0);\n                //qCDebug(KArchiveLog) << \"pos()=\" << dev->pos() << \"rest=\" << rest << \"skipping\" << skip;\n                if (! dev->seek(dev->pos() + skip)) {\n                    //qCWarning(KArchiveLog) << \"skipping\" << skip << \"failed\";\n                }\n            }\n\n            if (pos == -1) {\n                if (nm == QLatin1String(\".\")) { // special case\n                    Q_ASSERT(isdir);\n                    if (isdir) {\n                        setRootDir(static_cast<KArchiveDirectory *>(e));\n                    } else {\n                        delete e;\n                    }\n                } else {\n                    rootDir()->addEntry(e);\n                }\n            } else {\n                // In some tar files we can find dir/./file => call cleanPath\n                QString path = QDir::cleanPath(name.left(pos));\n                // Ensure container directory exists, create otherwise\n                KArchiveDirectory *d = findOrCreate(path);\n                if (d) {\n                    d->addEntry(e);\n                } else {\n                    delete e;\n                    return false;\n                }\n            }\n        } else {\n            //qCDebug(KArchiveLog) << \"Terminating. Read \" << n << \" bytes, first one is \" << buffer[0];\n            d->tarEnd = dev->pos() - n; // Remember end of archive\n            ende = true;\n        }\n    } while (!ende);\n    return true;\n}\n\nbool KArchive::open(QIODevice::OpenMode mode)\n{\n    Q_ASSERT(mode != QIODevice::NotOpen);\n\n    if (isOpen()) {\n        close();\n    }\n\n    if (!d->fileName.isEmpty()) {\n        Q_ASSERT(!d->dev);\n        if (!createDevice(mode)) {\n            return false;\n        }\n    }\n\n    if (!d->dev) {\n        setErrorString(tr(\"No filename or device was specified\"));\n        return false;\n    }\n\n    if (!d->dev->isOpen() && !d->dev->open(mode)) {\n        setErrorString(tr(\"Could not set device mode to %1\").arg(mode));\n        return false;\n    }\n\n    d->mode = mode;\n\n    Q_ASSERT(!d->rootDir);\n    d->rootDir = nullptr;\n\n    return openArchive(mode);\n}\n\n\n// target function\nvoid KCompressionDeviceTest::testSeekReadUncompressedBuffer()\n{\n    const int dataSize = BUFFER_SIZE + BUFFER_SIZE / 2;\n    QByteArray ba(dataSize, 0);\n\n    // all data is zero except after BUFFER_SIZE that it's 0 to 9\n    for (int i = 0; i < 10; ++i) {\n        ba[BUFFER_SIZE + i] = i;\n    }\n\n    QBuffer b;\n    b.setData(ba);\n    QVERIFY(b.open(QIODevice::ReadOnly));\n\n    KCompressionDevice kcd(&b, false, KCompressionDevice::GZip);\n    QVERIFY(kcd.open(QIODevice::ReadOnly));\n    QVERIFY(kcd.seek(BUFFER_SIZE));\n\n    // the 10 bytes after BUFFER_SIZE should be 0 to 9\n    const QByteArray kcdData = kcd.read(10);\n    QCOMPARE(kcdData.size(), 10);\n    for (int i = 0; i < kcdData.size(); ++i) {\n        QCOMPARE(kcdData[i], i);\n    }\n}\nbool KCompressionDevice::seek(qint64 pos)\n{\n    if (d->deviceReadPos == pos) {\n        return QIODevice::seek(pos);\n    }\n\n    //qCDebug(KArchiveLog) << \"seek(\" << pos << \") called, current pos=\" << QIODevice::pos();\n\n    Q_ASSERT(d->filter->mode() == QIODevice::ReadOnly);\n\n    if (pos == 0) {\n        if (!QIODevice::seek(pos))\n            return false;\n\n        // We can forget about the cached data\n        d->bNeedHeader = !d->bSkipHeaders;\n        d->result = KFilterBase::Ok;\n        d->filter->setInBuffer(nullptr, 0);\n        d->filter->reset();\n        d->deviceReadPos = 0;\n        return d->filter->device()->reset();\n    }\n\n    qint64 bytesToRead;\n    if (d->deviceReadPos < pos) { // we can start from here\n        bytesToRead = pos - d->deviceReadPos;\n        // Since we're going to do a read() below\n        // we need to reset the internal QIODevice pos to the real position we are\n        // so that after read() we are indeed pointing to the pos seek\n        // asked us to be in\n        if (!QIODevice::seek(d->deviceReadPos)) {\n            return false;\n        }\n    } else {\n        // we have to start from 0 ! Ugly and slow, but better than the previous\n        // solution (KTarGz was allocating everything into memory)\n        if (!seek(0)) { // recursive\n            return false;\n        }\n        bytesToRead = pos;\n    }\n\n    //qCDebug(KArchiveLog) << \"reading \" << bytesToRead << \" dummy bytes\";\n    QByteArray dummy(qMin(bytesToRead, qint64(3 * BUFFER_SIZE)), 0);\n    const bool result = (read(dummy.data(), bytesToRead) == bytesToRead);\n    return result;\n}\nbool KCompressionDevice::atEnd() const\n{\n    return (d->type == KCompressionDevice::None || d->result == KFilterBase::End)\n           && QIODevice::atEnd() // take QIODevice's internal buffer into account\n           && d->filter->device()->atEnd();\n}\n",
    "target": 1,
    "idx": 1014980,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nget_word_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading raw-word-format PPM files with any maxval */\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n  register int rindex = rgb_red[cinfo->in_color_space];\n  register int gindex = rgb_green[cinfo->in_color_space];\n  register int bindex = rgb_blue[cinfo->in_color_space];\n  register int aindex = alpha_index[cinfo->in_color_space];\n  register int ps = rgb_pixelsize[cinfo->in_color_space];\n\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub.buffer[0];\n  bufferptr = source->iobuffer;\n  for (col = cinfo->image_width; col > 0; col--) {\n    register unsigned int temp;\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    ptr[rindex] = rescale[temp];\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    ptr[gindex] = rescale[temp];\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    ptr[bindex] = rescale[temp];\n    if (aindex >= 0)\n      ptr[aindex] = 0xFF;\n    ptr += ps;\n  }\n  return 1;\n}\n\n\n\n\n// target function\nget_word_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading raw-word-format PPM files with any maxval */\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub.buffer[0];\n  bufferptr = source->iobuffer;\n  for (col = cinfo->image_width; col > 0; col--) {\n    register unsigned int temp;\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    *ptr++ = rescale[temp];\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    *ptr++ = rescale[temp];\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    *ptr++ = rescale[temp];\n  }\n  return 1;\n}\n",
    "target": 1,
    "idx": 1032964,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "// context\n\n\nDataBuf readFile(const std::string& path) {\n  FileIo file(path);\n  if (file.open(\"rb\") != 0) {\n    throw Error(ErrorCode::kerFileOpenFailed, path, \"rb\", strError());\n  }\n  struct stat st;\n  if (0 != ::stat(path.c_str(), &st)) {\n    throw Error(ErrorCode::kerCallFailed, path, strError(), \"::stat\");\n  }\n  DataBuf buf(st.st_size);\n  const size_t len = file.read(buf.data(), buf.size());\n  if (len != buf.size()) {\n    throw Error(ErrorCode::kerCallFailed, path, strError(), \"FileIo::read\");\n  }\n  return buf;\n}\n\nvoid BasicIo::readOrThrow(byte* buf, size_t rcount, ErrorCode err) {\n  const size_t nread = read(buf, rcount);\n  enforce(nread == rcount, err);\n  enforce(!error(), err);\n}\n\nvoid QuickTimeVideo::tagDecoder(Exiv2::DataBuf& buf, size_t size) {\n  assert(buf.size() > 4);\n\n  if (ignoreList(buf))\n    discard(size);\n\n  else if (dataIgnoreList(buf)) {\n    decodeBlock(Exiv2::toString(buf.data()));\n  } else if (equalsQTimeTag(buf, \"ftyp\"))\n    fileTypeDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"trak\"))\n    setMediaStream();\n\n  else if (equalsQTimeTag(buf, \"mvhd\"))\n    movieHeaderDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"tkhd\"))\n    trackHeaderDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"mdhd\"))\n    mediaHeaderDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"hdlr\"))\n    handlerDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"vmhd\"))\n    videoHeaderDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"udta\"))\n    userDataDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"dref\"))\n    multipleEntriesDecoder();\n\n  else if (equalsQTimeTag(buf, \"stsd\"))\n    sampleDesc(size);\n\n  else if (equalsQTimeTag(buf, \"stts\"))\n    timeToSampleDecoder();\n\n  else if (equalsQTimeTag(buf, \"pnot\"))\n    previewTagDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"tapt\"))\n    trackApertureTagDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"keys\"))\n    keysTagDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"url \")) {\n    Exiv2::DataBuf url(size+1);\n    io_->readOrThrow(url.data(), size);\n    url.write_uint8(size, 0);\n    if (currentStream_ == Video)\n      xmpData_[\"Xmp.video.URL\"] = Exiv2::toString(url.data());\n    else if (currentStream_ == Audio)\n      xmpData_[\"Xmp.audio.URL\"] = Exiv2::toString(url.data());\n  }\n\n  else if (equalsQTimeTag(buf, \"urn \")) {\n    Exiv2::DataBuf urn(size+1);\n    io_->readOrThrow(urn.data(), size);\n    urn.write_uint8(size, 0);\n    if (currentStream_ == Video)\n      xmpData_[\"Xmp.video.URN\"] = Exiv2::toString(urn.data());\n    else if (currentStream_ == Audio)\n      xmpData_[\"Xmp.audio.URN\"] = Exiv2::toString(urn.data());\n  }\n\n  else if (equalsQTimeTag(buf, \"dcom\")) {\n    Exiv2::DataBuf dcom(size+1);\n    io_->readOrThrow(dcom.data(), size);\n    dcom.write_uint8(size, 0);\n    xmpData_[\"Xmp.video.Compressor\"] = Exiv2::toString(dcom.data());\n  }\n\n  else if (equalsQTimeTag(buf, \"smhd\")) {\n    io_->readOrThrow(buf.data(), 4);\n    io_->readOrThrow(buf.data(), 4);\n    xmpData_[\"Xmp.audio.Balance\"] = buf.read_uint16(0, bigEndian);\n  }\n\n  else {\n    discard(size);\n  }\n}  // QuickTimeVideo::tagDecoder\n\nvoid QuickTimeVideo::decodeBlock(std::string const& entered_from) {\n  const long bufMinSize = 4;\n  DataBuf buf(bufMinSize + 1);\n  uint64_t size = 0;\n  buf.data()[4] = '\\0';\n\n  io_->read(buf.data(), 4);\n  if (io_->eof()) {\n    continueTraversing_ = false;\n    return;\n  }\n\n  size = buf.read_uint32(0, bigEndian);\n\n  io_->readOrThrow(buf.data(), 4);\n\n  // we have read 2x 4 bytes\n  size_t hdrsize = 8;\n\n  if (size == 1) {\n    // The box size is encoded as a uint64_t, so we need to read another 8 bytes.\n    DataBuf data(8);\n    hdrsize += 8;\n    io_->readOrThrow(data.data(), data.size());\n    size = data.read_uint64(0, bigEndian);\n  } else if (size == 0) {\n    if (entered_from == \"meta\") {\n      size = buf.read_uint32(0, bigEndian);\n      io_->readOrThrow(buf.data(), 4, Exiv2::ErrorCode::kerCorruptedMetadata);\n    }\n  }\n\n  enforce(size >= hdrsize, Exiv2::ErrorCode::kerCorruptedMetadata);\n  enforce(size - hdrsize <= io_->size() - io_->tell(), Exiv2::ErrorCode::kerCorruptedMetadata);\n  enforce(size - hdrsize <= std::numeric_limits<size_t>::max(), Exiv2::ErrorCode::kerCorruptedMetadata);\n\n  // std::cerr<<\"Tag=>\"<<buf.data()<<\"     size=>\"<<size-hdrsize << std::endl;\n  const size_t newsize = static_cast<size_t>(size - hdrsize);\n  if (newsize > buf.size()) {\n    buf.resize(newsize);\n  }\n  tagDecoder(buf, newsize);\n}  // QuickTimeVideo::decodeBlock\n\nvoid QuickTimeVideo::readMetadata() {\n  if (io_->open() != 0)\n    throw Error(ErrorCode::kerDataSourceOpenFailed, io_->path(), strError());\n\n  // Ensure that this is the correct image type\n  if (!isQTimeType(*io_, false)) {\n    if (io_->error() || io_->eof())\n      throw Error(ErrorCode::kerFailedToReadImageData);\n    throw Error(ErrorCode::kerNotAnImage, \"QuickTime\");\n  }\n\n  IoCloser closer(*io_);\n  clearMetadata();\n  continueTraversing_ = true;\n  height_ = width_ = 1;\n\n  xmpData_[\"Xmp.video.FileSize\"] = (double)io_->size() / (double)1048576;\n  xmpData_[\"Xmp.video.MimeType\"] = mimeType();\n\n  while (continueTraversing_)\n    decodeBlock();\n\n  aspectRatio();\n}  // QuickTimeVideo::readMetadata\n\n\n// target function\nvoid QuickTimeVideo::decodeBlock(std::string const& entered_from) {\n  const long bufMinSize = 4;\n  DataBuf buf(bufMinSize + 1);\n  uint64_t size = 0;\n  buf.data()[4] = '\\0';\n\n  io_->read(buf.data(), 4);\n  if (io_->eof()) {\n    continueTraversing_ = false;\n    return;\n  }\n\n  size = buf.read_uint32(0, bigEndian);\n\n  io_->readOrThrow(buf.data(), 4);\n\n  // we have read 2x 4 bytes\n  size_t hdrsize = 8;\n\n  if (size == 1) {\n    // The box size is encoded as a uint64_t, so we need to read another 8 bytes.\n    DataBuf data(8);\n    hdrsize += 8;\n    io_->readOrThrow(data.data(), data.size());\n    size = data.read_uint64(0, bigEndian);\n  } else if (size == 0) {\n    if (entered_from == \"meta\") {\n      size = buf.read_uint32(0, bigEndian);\n      io_->readOrThrow(buf.data(), 4, Exiv2::ErrorCode::kerCorruptedMetadata);\n    }\n  }\n\n  enforce(size >= hdrsize, Exiv2::ErrorCode::kerCorruptedMetadata);\n  enforce(size - hdrsize <= io_->size() - io_->tell(), Exiv2::ErrorCode::kerCorruptedMetadata);\n  enforce(size - hdrsize <= std::numeric_limits<size_t>::max(), Exiv2::ErrorCode::kerCorruptedMetadata);\n\n  // std::cerr<<\"Tag=>\"<<buf.data()<<\"     size=>\"<<size-hdrsize << std::endl;\n  tagDecoder(buf, static_cast<size_t>(size - hdrsize));\n}  // QuickTimeVideo::decodeBlock\nvoid QuickTimeVideo::tagDecoder(Exiv2::DataBuf& buf, size_t size) {\n  if (ignoreList(buf))\n    discard(size);\n\n  else if (dataIgnoreList(buf)) {\n    decodeBlock(Exiv2::toString(buf.data()));\n  } else if (equalsQTimeTag(buf, \"ftyp\"))\n    fileTypeDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"trak\"))\n    setMediaStream();\n\n  else if (equalsQTimeTag(buf, \"mvhd\"))\n    movieHeaderDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"tkhd\"))\n    trackHeaderDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"mdhd\"))\n    mediaHeaderDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"hdlr\"))\n    handlerDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"vmhd\"))\n    videoHeaderDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"udta\"))\n    userDataDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"dref\"))\n    multipleEntriesDecoder();\n\n  else if (equalsQTimeTag(buf, \"stsd\"))\n    sampleDesc(size);\n\n  else if (equalsQTimeTag(buf, \"stts\"))\n    timeToSampleDecoder();\n\n  else if (equalsQTimeTag(buf, \"pnot\"))\n    previewTagDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"tapt\"))\n    trackApertureTagDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"keys\"))\n    keysTagDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"url \")) {\n    io_->readOrThrow(buf.data(), size);\n    if (currentStream_ == Video)\n      xmpData_[\"Xmp.video.URL\"] = Exiv2::toString(buf.data());\n    else if (currentStream_ == Audio)\n      xmpData_[\"Xmp.audio.URL\"] = Exiv2::toString(buf.data());\n  }\n\n  else if (equalsQTimeTag(buf, \"urn \")) {\n    io_->readOrThrow(buf.data(), size);\n    if (currentStream_ == Video)\n      xmpData_[\"Xmp.video.URN\"] = Exiv2::toString(buf.data());\n    else if (currentStream_ == Audio)\n      xmpData_[\"Xmp.audio.URN\"] = Exiv2::toString(buf.data());\n  }\n\n  else if (equalsQTimeTag(buf, \"dcom\")) {\n    io_->readOrThrow(buf.data(), size);\n    xmpData_[\"Xmp.video.Compressor\"] = Exiv2::toString(buf.data());\n  }\n\n  else if (equalsQTimeTag(buf, \"smhd\")) {\n    io_->readOrThrow(buf.data(), 4);\n    io_->readOrThrow(buf.data(), 4);\n    xmpData_[\"Xmp.audio.Balance\"] = buf.read_uint16(0, bigEndian);\n  }\n\n  else {\n    discard(size);\n  }\n}  // QuickTimeVideo::tagDecoder\n",
    "target": 1,
    "idx": 1050901,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nsize_t strlcpy(char *dest, const char *src, size_t size)\n{\n\tsize_t ret = strlen(src);\n\n\tif (size) {\n\t\tsize_t len = (ret >= size) ? size - 1 : ret;\n\t\tmemcpy(dest, src, len);\n\t\tdest[len] = '\\0';\n\t}\n\n\treturn ret;\n}\n\nint parse_lxc_mntopts(struct lxc_mount_options *opts, char *mnt_opts)\n{\n\tfor (size_t i = LXC_MOUNT_CREATE_DIR; i < LXC_MOUNT_MAX; i++) {\n\t\t__do_close int fd_userns = -EBADF;\n\t\tconst char *opt_name = lxc_mount_options_info[i];\n\t\tsize_t len;\n\t\tchar *idmap_path, *opt, *opt_next;\n\n\t\topt = strstr(mnt_opts, opt_name);\n\t\tif (!opt)\n\t\t\tcontinue;\n\n\t\tswitch (i) {\n\t\tcase LXC_MOUNT_CREATE_DIR:\n\t\t\topts->create_dir = 1;\n\t\t\tbreak;\n\t\tcase LXC_MOUNT_CREATE_FILE:\n\t\t\topts->create_file = 1;\n\t\t\tbreak;\n\t\tcase LXC_MOUNT_OPTIONAL:\n\t\t\topts->optional = 1;\n\t\t\tbreak;\n\t\tcase LXC_MOUNT_RELATIVE:\n\t\t\topts->relative = 1;\n\t\t\tbreak;\n\t\tcase LXC_MOUNT_IDMAP:\n\t\t\topt_next = opt;\n\t\t\topt_next += STRLITERALLEN(\"idmap=\");\n\t\t\tidmap_path = strchrnul(opt_next, ',');\n\t\t\tlen = idmap_path - opt_next + 1;\n\n\t\t\tif (len >= sizeof(opts->userns_path))\n\t\t\t\treturn syserror_set(-EIO, \"Excessive idmap path length for \\\"idmap=<path>\\\" LXC specific mount option\");\n\n\t\t\tmemcpy(opts->userns_path, opt_next, len);\n\n\t\t\tif (is_empty_string(opts->userns_path))\n\t\t\t\treturn syserror_set(-EINVAL, \"Missing idmap path for \\\"idmap=<path>\\\" LXC specific mount option\");\n\n\t\t\tfd_userns = open(opts->userns_path, O_RDONLY | O_NOCTTY | O_CLOEXEC);\n\t\t\tif (fd_userns < 0)\n\t\t\t\treturn syserror(\"Failed to open user namespace\");\n\n\t\t\tTRACE(\"Parse LXC specific mount option %d->\\\"idmap=%s\\\"\", fd_userns, opts->userns_path);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn syserror_set(-EINVAL, \"Unknown LXC specific mount option\");\n\t\t}\n\n\t\topt_next = strchr(opt, ',');\n\t\tif (!opt_next)\n\t\t\t*opt = '\\0'; /* no more mntopts, so just chop it here */\n\t\telse\n\t\t\tmemmove(opt, opt_next + 1, strlen(opt_next + 1) + 1);\n\t}\n\n\treturn 0;\n}\n\nstatic int set_config_rootfs_options(const char *key, const char *value,\n\t\t\t\t     struct lxc_conf *lxc_conf, void *data)\n{\n\t__do_free char *dup = NULL, *mdata = NULL, *opts = NULL;\n\tunsigned long mflags = 0, pflags = 0;\n\tstruct lxc_rootfs *rootfs = &lxc_conf->rootfs;\n\tint ret;\n\n\tclr_config_rootfs_options(key, lxc_conf, data);\n\tif (lxc_config_value_empty(value))\n\t\treturn 0;\n\n\tdup = strdup(value);\n\tif (!dup)\n\t\treturn -ENOMEM;\n\n\tret = parse_lxc_mntopts(&rootfs->mnt_opts, dup);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = parse_mntopts(dup, &mflags, &mdata);\n\tif (ret < 0)\n\t\treturn ret_errno(EINVAL);\n\n\tret = parse_propagationopts(dup, &pflags);\n\tif (ret < 0)\n\t\treturn ret_errno(EINVAL);\n\n\tret = set_config_string_item(&opts, dup);\n\tif (ret < 0)\n\t\treturn ret_errno(ENOMEM);\n\n\tif (rootfs->mnt_opts.create_dir || rootfs->mnt_opts.create_file ||\n\t    rootfs->mnt_opts.optional || rootfs->mnt_opts.relative)\n\t\treturn syserror_set(-EINVAL, \"Invalid LXC specifc mount option for rootfs mount\");\n\n\trootfs->mountflags\t= mflags | pflags;\n\trootfs->options\t\t= move_ptr(opts);\n\trootfs->data\t\t= move_ptr(mdata);\n\n\treturn 0;\n}\n\nint lxc_set_config_item_locked(struct lxc_conf *conf, const char *key,\n\t\t\t       const char *v)\n{\n\tint ret;\n\tstruct lxc_config_t *config;\n\tbool bret = true;\n\n\tconfig = lxc_get_config(key);\n\n\tret = config->set(key, v, conf, NULL);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\tif (lxc_config_value_empty(v))\n\t\tdo_clear_unexp_config_line(conf, key);\n\telse\n\t\tbret = do_append_unexp_config_line(conf, key, v);\n\tif (!bret)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic bool do_set_config_item_locked(struct lxc_container *c, const char *key,\n\t\t\t\t      const char *v)\n{\n\tint ret;\n\n\tif (!c->lxc_conf)\n\t\tc->lxc_conf = lxc_conf_init();\n\n\tif (!c->lxc_conf)\n\t\treturn false;\n\n\tret = lxc_set_config_item_locked(c->lxc_conf, key, v);\n\tif (ret < 0)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool do_lxcapi_set_config_item(struct lxc_container *c, const char *key, const char *v)\n{\n\tbool b = false;\n\n\tif (!c)\n\t\treturn false;\n\n\tif (container_mem_lock(c))\n\t\treturn false;\n\n\tb = do_set_config_item_locked(c, key, v);\n\n\tcontainer_mem_unlock(c);\n\treturn b;\n}\n\nstatic bool do_lxcapi_set_config_item(struct lxc_container *c, const char *key, const char *v)\n{\n\tbool b = false;\n\n\tif (!c)\n\t\treturn false;\n\n\tif (container_mem_lock(c))\n\t\treturn false;\n\n\tb = do_set_config_item_locked(c, key, v);\n\n\tcontainer_mem_unlock(c);\n\treturn b;\n}\n\nbool lxc_config_define_load(struct lxc_list *defines, struct lxc_container *c)\n{\n\tstruct lxc_list *it;\n\tbool bret = true;\n\n\tlxc_list_for_each(it, defines) {\n\t\tstruct new_config_item *new_item = it->elem;\n\t\tbret = c->set_config_item(c, new_item->key, new_item->val);\n\t\tif (!bret)\n\t\t\tbreak;\n\t}\n\n#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n\tlxc_config_define_free(defines);\n#endif /* !FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION */\n\n\treturn bret;\n}\n\n\n// target function\nint parse_lxc_mntopts(struct lxc_mount_options *opts, char *mnt_opts)\n{\n\tfor (size_t i = LXC_MOUNT_CREATE_DIR; i < LXC_MOUNT_MAX; i++) {\n\t\t__do_close int fd_userns = -EBADF;\n\t\tconst char *opt_name = lxc_mount_options_info[i];\n\t\tsize_t len;\n\t\tchar *idmap_path, *opt, *opt_next;\n\n\t\topt = strstr(mnt_opts, opt_name);\n\t\tif (!opt)\n\t\t\tcontinue;\n\n\t\tswitch (i) {\n\t\tcase LXC_MOUNT_CREATE_DIR:\n\t\t\topts->create_dir = 1;\n\t\t\tbreak;\n\t\tcase LXC_MOUNT_CREATE_FILE:\n\t\t\topts->create_file = 1;\n\t\t\tbreak;\n\t\tcase LXC_MOUNT_OPTIONAL:\n\t\t\topts->optional = 1;\n\t\t\tbreak;\n\t\tcase LXC_MOUNT_RELATIVE:\n\t\t\topts->relative = 1;\n\t\t\tbreak;\n\t\tcase LXC_MOUNT_IDMAP:\n\t\t\topt_next = opt;\n\t\t\topt_next += STRLITERALLEN(\"idmap=\");\n\t\t\tidmap_path = strchrnul(opt_next, ',');\n\n\t\t\tlen = strlcpy(opts->userns_path, opt_next, idmap_path - opt_next + 1);\n\t\t\tif (len >= sizeof(opts->userns_path))\n\t\t\t\treturn syserror_set(-EIO, \"Excessive idmap path length for \\\"idmap=<path>\\\" LXC specific mount option\");\n\n\t\t\tif (is_empty_string(opts->userns_path))\n\t\t\t\treturn syserror_set(-EINVAL, \"Missing idmap path for \\\"idmap=<path>\\\" LXC specific mount option\");\n\n\t\t\tfd_userns = open(opts->userns_path, O_RDONLY | O_NOCTTY | O_CLOEXEC);\n\t\t\tif (fd_userns < 0)\n\t\t\t\treturn syserror(\"Failed to open user namespace\");\n\n\t\t\tTRACE(\"Parse LXC specific mount option %d->\\\"idmap=%s\\\"\", fd_userns, opts->userns_path);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn syserror_set(-EINVAL, \"Unknown LXC specific mount option\");\n\t\t}\n\n\t\topt_next = strchr(opt, ',');\n\t\tif (!opt_next)\n\t\t\t*opt = '\\0'; /* no more mntopts, so just chop it here */\n\t\telse\n\t\t\tmemmove(opt, opt_next + 1, strlen(opt_next + 1) + 1);\n\t}\n\n\treturn 0;\n}\n",
    "target": 1,
    "idx": 1033556,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic int\nget_register_operand (unsigned char fragment, char *buffer)\n{\n  const reg *current_reg = tic30_regtab;\n\n  if (buffer == NULL)\n    return 0;\n  for (; current_reg < tic30_regtab_end; current_reg++)\n    {\n      if ((fragment & 0x1F) == current_reg->opcode)\n\t{\n\t  strncpy (buffer, current_reg->name, OPERAND_BUFFER_LEN);\n\t  buffer[OPERAND_BUFFER_LEN - 1] = 0;\n\t  return 1;\n\t}\n    }\n  return 0;\n}\n\nint\nprint_insn_tic30 (bfd_vma pc, disassemble_info *info)\n{\n  unsigned long insn_word;\n  struct instruction insn = { 0, NULL, NULL };\n  bfd_vma bufaddr = pc - info->buffer_vma;\n\n  /* Obtain the current instruction word from the buffer.  */\n  insn_word = (*(info->buffer + bufaddr) << 24) | (*(info->buffer + bufaddr + 1) << 16) |\n    (*(info->buffer + bufaddr + 2) << 8) | *(info->buffer + bufaddr + 3);\n  _pc = pc / 4;\n  /* Get the instruction refered to by the current instruction word\n     and print it out based on its type.  */\n  if (!get_tic30_instruction (insn_word, &insn))\n    return -1;\n  switch (GET_TYPE (insn_word))\n    {\n    case TWO_OPERAND_1:\n    case TWO_OPERAND_2:\n      if (!print_two_operand (info, insn_word, &insn))\n\treturn -1;\n      break;\n    case THREE_OPERAND:\n      if (!print_three_operand (info, insn_word, &insn))\n\treturn -1;\n      break;\n    case PAR_STORE:\n    case MUL_ADDS:\n      if (!print_par_insn (info, insn_word, &insn))\n\treturn -1;\n      break;\n    case BRANCHES:\n      if (!print_branch (info, insn_word, &insn))\n\treturn -1;\n      break;\n    }\n  return 4;\n}\n\nvoid Fuzzer::ExecuteCallback(const uint8_t *Data, size_t Size) {\n  TPC.RecordInitialStack();\n  TotalNumberOfRuns++;\n  assert(InFuzzingThread());\n  // We copy the contents of Unit into a separate heap buffer\n  // so that we reliably find buffer overflows in it.\n  uint8_t *DataCopy = new uint8_t[Size];\n  memcpy(DataCopy, Data, Size);\n  if (EF->__msan_unpoison)\n    EF->__msan_unpoison(DataCopy, Size);\n  if (EF->__msan_unpoison_param)\n    EF->__msan_unpoison_param(2);\n  if (CurrentUnitData && CurrentUnitData != Data)\n    memcpy(CurrentUnitData, Data, Size);\n  CurrentUnitSize = Size;\n  {\n    ScopedEnableMsanInterceptorChecks S;\n    AllocTracer.Start(Options.TraceMalloc);\n    UnitStartTime = system_clock::now();\n    TPC.ResetMaps();\n    RunningUserCallback = true;\n    int Res = CB(DataCopy, Size);\n    RunningUserCallback = false;\n    UnitStopTime = system_clock::now();\n    (void)Res;\n    assert(Res == 0);\n    HasMoreMallocsThanFrees = AllocTracer.Stop();\n  }\n  if (!LooseMemeq(DataCopy, Data, Size))\n    CrashOnOverwrittenData();\n  CurrentUnitSize = 0;\n  delete[] DataCopy;\n}\n\nint RunOneTest(Fuzzer *F, const char *InputFilePath, size_t MaxLen) {\n  Unit U = FileToVector(InputFilePath);\n  if (MaxLen && MaxLen < U.size())\n    U.resize(MaxLen);\n  F->ExecuteCallback(U.data(), U.size());\n  F->TryDetectingAMemoryLeak(U.data(), U.size(), true);\n  return 0;\n}\n\nint FuzzerDriver(int *argc, char ***argv, UserCallback Callback) {\n  using namespace fuzzer;\n  assert(argc && argv && \"Argument pointers cannot be nullptr\");\n  std::string Argv0((*argv)[0]);\n  EF = new ExternalFunctions();\n  if (EF->LLVMFuzzerInitialize)\n    EF->LLVMFuzzerInitialize(argc, argv);\n  if (EF->__msan_scoped_disable_interceptor_checks)\n    EF->__msan_scoped_disable_interceptor_checks();\n  const Vector<std::string> Args(*argv, *argv + *argc);\n  assert(!Args.empty());\n  ProgName = new std::string(Args[0]);\n  if (Argv0 != *ProgName) {\n    Printf(\"ERROR: argv[0] has been modified in LLVMFuzzerInitialize\\n\");\n    exit(1);\n  }\n  ParseFlags(Args, EF);\n  if (Flags.help) {\n    PrintHelp();\n    return 0;\n  }\n\n  if (Flags.close_fd_mask & 2)\n    DupAndCloseStderr();\n  if (Flags.close_fd_mask & 1)\n    CloseStdout();\n\n  if (Flags.jobs > 0 && Flags.workers == 0) {\n    Flags.workers = std::min(NumberOfCpuCores() / 2, Flags.jobs);\n    if (Flags.workers > 1)\n      Printf(\"Running %u workers\\n\", Flags.workers);\n  }\n\n  if (Flags.workers > 0 && Flags.jobs > 0)\n    return RunInMultipleProcesses(Args, Flags.workers, Flags.jobs);\n\n  FuzzingOptions Options;\n  Options.Verbosity = Flags.verbosity;\n  Options.MaxLen = Flags.max_len;\n  Options.LenControl = Flags.len_control;\n  Options.UnitTimeoutSec = Flags.timeout;\n  Options.ErrorExitCode = Flags.error_exitcode;\n  Options.TimeoutExitCode = Flags.timeout_exitcode;\n  Options.IgnoreTimeouts = Flags.ignore_timeouts;\n  Options.IgnoreOOMs = Flags.ignore_ooms;\n  Options.IgnoreCrashes = Flags.ignore_crashes;\n  Options.MaxTotalTimeSec = Flags.max_total_time;\n  Options.DoCrossOver = Flags.cross_over;\n  Options.MutateDepth = Flags.mutate_depth;\n  Options.ReduceDepth = Flags.reduce_depth;\n  Options.UseCounters = Flags.use_counters;\n  Options.UseMemmem = Flags.use_memmem;\n  Options.UseCmp = Flags.use_cmp;\n  Options.UseValueProfile = Flags.use_value_profile;\n  Options.Shrink = Flags.shrink;\n  Options.ReduceInputs = Flags.reduce_inputs;\n  Options.ShuffleAtStartUp = Flags.shuffle;\n  Options.PreferSmall = Flags.prefer_small;\n  Options.ReloadIntervalSec = Flags.reload;\n  Options.OnlyASCII = Flags.only_ascii;\n  Options.DetectLeaks = Flags.detect_leaks;\n  Options.PurgeAllocatorIntervalSec = Flags.purge_allocator_interval;\n  Options.TraceMalloc = Flags.trace_malloc;\n  Options.RssLimitMb = Flags.rss_limit_mb;\n  Options.MallocLimitMb = Flags.malloc_limit_mb;\n  if (!Options.MallocLimitMb)\n    Options.MallocLimitMb = Options.RssLimitMb;\n  if (Flags.runs >= 0)\n    Options.MaxNumberOfRuns = Flags.runs;\n  if (!Inputs->empty() && !Flags.minimize_crash_internal_step)\n    Options.OutputCorpus = (*Inputs)[0];\n  Options.ReportSlowUnits = Flags.report_slow_units;\n  if (Flags.artifact_prefix)\n    Options.ArtifactPrefix = Flags.artifact_prefix;\n  if (Flags.exact_artifact_path)\n    Options.ExactArtifactPath = Flags.exact_artifact_path;\n  Vector<Unit> Dictionary;\n  if (Flags.dict)\n    if (!ParseDictionaryFile(FileToString(Flags.dict), &Dictionary))\n      return 1;\n  if (Flags.verbosity > 0 && !Dictionary.empty())\n    Printf(\"Dictionary: %zd entries\\n\", Dictionary.size());\n  bool RunIndividualFiles = AllInputsAreFiles();\n  Options.SaveArtifacts =\n      !RunIndividualFiles || Flags.minimize_crash_internal_step;\n  Options.PrintNewCovPcs = Flags.print_pcs;\n  Options.PrintNewCovFuncs = Flags.print_funcs;\n  Options.PrintFinalStats = Flags.print_final_stats;\n  Options.PrintCorpusStats = Flags.print_corpus_stats;\n  Options.PrintCoverage = Flags.print_coverage;\n  if (Flags.exit_on_src_pos)\n    Options.ExitOnSrcPos = Flags.exit_on_src_pos;\n  if (Flags.exit_on_item)\n    Options.ExitOnItem = Flags.exit_on_item;\n  if (Flags.focus_function)\n    Options.FocusFunction = Flags.focus_function;\n  if (Flags.data_flow_trace)\n    Options.DataFlowTrace = Flags.data_flow_trace;\n  if (Flags.features_dir)\n    Options.FeaturesDir = Flags.features_dir;\n  if (Flags.collect_data_flow)\n    Options.CollectDataFlow = Flags.collect_data_flow;\n  if (Flags.stop_file)\n    Options.StopFile = Flags.stop_file;\n\n  unsigned Seed = Flags.seed;\n  // Initialize Seed.\n  if (Seed == 0)\n    Seed =\n        std::chrono::system_clock::now().time_since_epoch().count() + GetPid();\n  if (Flags.verbosity)\n    Printf(\"INFO: Seed: %u\\n\", Seed);\n\n  if (Flags.collect_data_flow && !Flags.fork && !Flags.merge) {\n    if (RunIndividualFiles)\n      return CollectDataFlow(Flags.collect_data_flow, Flags.data_flow_trace,\n                        ReadCorpora({}, *Inputs));\n    else\n      return CollectDataFlow(Flags.collect_data_flow, Flags.data_flow_trace,\n                        ReadCorpora(*Inputs, {}));\n  }\n\n  Random Rand(Seed);\n  auto *MD = new MutationDispatcher(Rand, Options);\n  auto *Corpus = new InputCorpus(Options.OutputCorpus);\n  auto *F = new Fuzzer(Callback, *Corpus, *MD, Options);\n\n  for (auto &U: Dictionary)\n    if (U.size() <= Word::GetMaxSize())\n      MD->AddWordToManualDictionary(Word(U.data(), U.size()));\n\n  StartRssThread(F, Flags.rss_limit_mb);\n\n  Options.HandleAbrt = Flags.handle_abrt;\n  Options.HandleBus = Flags.handle_bus;\n  Options.HandleFpe = Flags.handle_fpe;\n  Options.HandleIll = Flags.handle_ill;\n  Options.HandleInt = Flags.handle_int;\n  Options.HandleSegv = Flags.handle_segv;\n  Options.HandleTerm = Flags.handle_term;\n  Options.HandleXfsz = Flags.handle_xfsz;\n  Options.HandleUsr1 = Flags.handle_usr1;\n  Options.HandleUsr2 = Flags.handle_usr2;\n  SetSignalHandler(Options);\n\n  std::atexit(Fuzzer::StaticExitCallback);\n\n  if (Flags.minimize_crash)\n    return MinimizeCrashInput(Args, Options);\n\n  if (Flags.minimize_crash_internal_step)\n    return MinimizeCrashInputInternalStep(F, Corpus);\n\n  if (Flags.cleanse_crash)\n    return CleanseCrashInput(Args, Options);\n\n  if (RunIndividualFiles) {\n    Options.SaveArtifacts = false;\n    int Runs = std::max(1, Flags.runs);\n    Printf(\"%s: Running %zd inputs %d time(s) each.\\n\", ProgName->c_str(),\n           Inputs->size(), Runs);\n    for (auto &Path : *Inputs) {\n      auto StartTime = system_clock::now();\n      Printf(\"Running: %s\\n\", Path.c_str());\n      for (int Iter = 0; Iter < Runs; Iter++)\n        RunOneTest(F, Path.c_str(), Options.MaxLen);\n      auto StopTime = system_clock::now();\n      auto MS = duration_cast<milliseconds>(StopTime - StartTime).count();\n      Printf(\"Executed %s in %zd ms\\n\", Path.c_str(), (long)MS);\n    }\n    Printf(\"***\\n\"\n           \"*** NOTE: fuzzing was not performed, you have only\\n\"\n           \"***       executed the target code on a fixed set of inputs.\\n\"\n           \"***\\n\");\n    F->PrintFinalStats();\n    exit(0);\n  }\n\n  if (Flags.fork)\n    FuzzWithFork(F->GetMD().GetRand(), Options, Args, *Inputs, Flags.fork);\n\n  if (Flags.merge)\n    Merge(F, Options, Args, *Inputs, Flags.merge_control_file);\n\n  if (Flags.merge_inner) {\n    const size_t kDefaultMaxMergeLen = 1 << 20;\n    if (Options.MaxLen == 0)\n      F->SetMaxInputLen(kDefaultMaxMergeLen);\n    assert(Flags.merge_control_file);\n    F->CrashResistantMergeInternalStep(Flags.merge_control_file);\n    exit(0);\n  }\n\n  if (Flags.analyze_dict) {\n    size_t MaxLen = INT_MAX;  // Large max length.\n    UnitVector InitialCorpus;\n    for (auto &Inp : *Inputs) {\n      Printf(\"Loading corpus dir: %s\\n\", Inp.c_str());\n      ReadDirToVectorOfUnits(Inp.c_str(), &InitialCorpus, nullptr,\n                             MaxLen, /*ExitOnError=*/false);\n    }\n\n    if (Dictionary.empty() || Inputs->empty()) {\n      Printf(\"ERROR: can't analyze dict without dict and corpus provided\\n\");\n      return 1;\n    }\n    if (AnalyzeDictionary(F, Dictionary, InitialCorpus)) {\n      Printf(\"Dictionary analysis failed\\n\");\n      exit(1);\n    }\n    Printf(\"Dictionary analysis succeeded\\n\");\n    exit(0);\n  }\n\n  auto CorporaFiles = ReadCorpora(*Inputs, ParseSeedInuts(Flags.seed_inputs));\n  F->Loop(CorporaFiles);\n\n  if (Flags.verbosity)\n    Printf(\"Done %zd runs in %zd second(s)\\n\", F->getTotalNumberOfRuns(),\n           F->secondsSinceProcessStartUp());\n  F->PrintFinalStats();\n\n  exit(0);  // Don't let F destroy itself.\n}\n\nATTRIBUTE_INTERFACE int main(int argc, char **argv) {\n  return fuzzer::FuzzerDriver(&argc, &argv, LLVMFuzzerTestOneInput);\n}\n\n\n// target function\nstatic int\nprint_branch (disassemble_info *info,\n\t      unsigned long insn_word,\n\t      struct instruction *insn)\n{\n  char operand[2][13] =\n  {\n    {0},\n    {0}\n  };\n  unsigned long address;\n  int print_label = 0;\n\n  if (insn->tm == NULL)\n    return 0;\n  /* Get the operands for 24-bit immediate jumps.  */\n  if (insn->tm->operand_types[0] & Imm24)\n    {\n      address = insn_word & 0x00FFFFFF;\n      sprintf (operand[0], \"0x%lX\", address);\n      print_label = 1;\n    }\n  /* Get the operand for the trap instruction.  */\n  else if (insn->tm->operand_types[0] & IVector)\n    {\n      address = insn_word & 0x0000001F;\n      sprintf (operand[0], \"0x%lX\", address);\n    }\n  else\n    {\n      address = insn_word & 0x0000FFFF;\n      /* Get the operands for the DB instructions.  */\n      if (insn->tm->operands == 2)\n\t{\n\t  get_register_operand (((insn_word & 0x01C00000) >> 22) + REG_AR0, operand[0]);\n\t  if (insn_word & PCRel)\n\t    {\n\t      sprintf (operand[1], \"%d\", (short) address);\n\t      print_label = 1;\n\t    }\n\t  else\n\t    get_register_operand (insn_word & 0x0000001F, operand[1]);\n\t}\n      /* Get the operands for the standard branches.  */\n      else if (insn->tm->operands == 1)\n\t{\n\t  if (insn_word & PCRel)\n\t    {\n\t      address = (short) address;\n\t      sprintf (operand[0], \"%ld\", address);\n\t      print_label = 1;\n\t    }\n\t  else\n\t    get_register_operand (insn_word & 0x0000001F, operand[0]);\n\t}\n    }\n  info->fprintf_func (info->stream, \"   %s %s%c%s\", insn->tm->name,\n\t\t      operand[0][0] ? operand[0] : \"\",\n\t\t      operand[1][0] ? ',' : ' ',\n\t\t      operand[1][0] ? operand[1] : \"\");\n  /* Print destination of branch in relation to current symbol.  */\n  if (print_label && info->symbols)\n    {\n      asymbol *sym = *info->symbols;\n\n      if ((insn->tm->opcode_modifier == PCRel) && (insn_word & PCRel))\n\t{\n\t  address = (_pc + 1 + (short) address) - ((sym->section->vma + sym->value) / 4);\n\t  /* Check for delayed instruction, if so adjust destination.  */\n\t  if (insn_word & 0x00200000)\n\t    address += 2;\n\t}\n      else\n\t{\n\t  address -= ((sym->section->vma + sym->value) / 4);\n\t}\n      if (address == 0)\n\tinfo->fprintf_func (info->stream, \" <%s>\", sym->name);\n      else\n\tinfo->fprintf_func (info->stream, \" <%s %c %lu>\", sym->name,\n\t\t\t    ((short) address < 0) ? '-' : '+',\n\t\t\t    address);\n    }\n  return 1;\n}\n",
    "target": 1,
    "idx": 1018615,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "// context\nint\nmdb_crack_row(MdbTableDef *table, int row_start, size_t row_size, MdbField *fields)\n{\n\tMdbColumn *col;\n\tMdbCatalogEntry *entry = table->entry;\n\tMdbHandle *mdb = entry->mdb;\n\tvoid *pg_buf = mdb->pg_buf;\n\tunsigned int row_var_cols=0, row_cols;\n\tunsigned char *nullmask;\n\tunsigned int bitmask_sz;\n\tunsigned int *var_col_offsets = NULL;\n\tunsigned int fixed_cols_found, row_fixed_cols;\n\tunsigned int col_count_size;\n\tunsigned int i;\n    unsigned int row_end = row_start + row_size - 1;\n\n\tif (mdb_get_option(MDB_DEBUG_ROW)) {\n\t\tmdb_buffer_dump(pg_buf, row_start, row_size);\n\t}\n\n\tif (IS_JET3(mdb)) {\n\t\trow_cols = mdb_get_byte(pg_buf, row_start);\n\t\tcol_count_size = 1;\n\t} else {\n\t\trow_cols = mdb_get_int16(pg_buf, row_start);\n\t\tcol_count_size = 2;\n\t}\n\n\tbitmask_sz = (row_cols + 7) / 8;\n    if (bitmask_sz + !IS_JET3(mdb) >= row_end) {\n        fprintf(stderr, \"warning: Invalid page buffer detected in mdb_crack_row.\\n\");\n        return -1;\n    }\n\n\tnullmask = (unsigned char*)pg_buf + row_end - bitmask_sz + 1;\n\n\t/* read table of variable column locations */\n\tif (table->num_var_cols > 0) {\n\t\trow_var_cols = IS_JET3(mdb) ?\n\t\t\tmdb_get_byte(pg_buf, row_end - bitmask_sz) :\n\t\t\tmdb_get_int16(pg_buf, row_end - bitmask_sz - 1);\n\t\tvar_col_offsets = (unsigned int *)g_malloc((row_var_cols+1)*sizeof(int));\n        int success = 0;\n\t\tif (IS_JET3(mdb)) {\n\t\t\tsuccess = mdb_crack_row3(mdb, row_start, row_end, bitmask_sz,\n                    row_var_cols, var_col_offsets);\n\t\t} else {\n\t\t\tsuccess = mdb_crack_row4(mdb, row_start, row_end, bitmask_sz,\n                    row_var_cols, var_col_offsets);\n\t\t}\n        if (!success) {\n            fprintf(stderr, \"warning: Invalid page buffer detected in mdb_crack_row.\\n\");\n            g_free(var_col_offsets);\n            return -1;\n        }\n\t}\n\n\tfixed_cols_found = 0;\n\trow_fixed_cols = row_cols - row_var_cols;\n\n\tif (mdb_get_option(MDB_DEBUG_ROW)) {\n\t\tfprintf(stdout,\"bitmask_sz %d\\n\", bitmask_sz);\n\t\tfprintf(stdout,\"row_var_cols %d\\n\", row_var_cols);\n\t\tfprintf(stdout,\"row_fixed_cols %d\\n\", row_fixed_cols);\n\t}\n\n\tfor (i=0;i<table->num_cols;i++) {\n\t\tunsigned int byte_num, bit_num;\n\t\tunsigned int col_start;\n\t\tcol = g_ptr_array_index(table->columns,i);\n\t\tfields[i].colnum = i;\n\t\tfields[i].is_fixed = col->is_fixed;\n\t\tbyte_num = col->col_num / 8;\n\t\tbit_num = col->col_num % 8;\n\t\t/* logic on nulls is reverse, 1 is not null, 0 is null */\n\t\tfields[i].is_null = nullmask[byte_num] & (1 << bit_num) ? 0 : 1;\n\n\t\tif ((fields[i].is_fixed)\n\t\t && (fixed_cols_found < row_fixed_cols)) {\n\t\t\tcol_start = col->fixed_offset + col_count_size;\n\t\t\tfields[i].start = row_start + col_start;\n\t\t\tfields[i].value = (char*)pg_buf + row_start + col_start;\n\t\t\tfields[i].siz = col->col_size;\n\t\t\tfixed_cols_found++;\n\t\t/* Use col->var_col_num because a deleted column is still\n\t\t * present in the variable column offsets table for the row */\n\t\t} else if ((!fields[i].is_fixed)\n\t\t && (col->var_col_num < row_var_cols)) {\n\t\t\tcol_start = var_col_offsets[col->var_col_num];\n\t\t\tfields[i].start = row_start + col_start;\n\t\t\tfields[i].value = (char*)pg_buf + row_start + col_start;\n\t\t\tfields[i].siz = var_col_offsets[(col->var_col_num)+1] -\n\t\t                col_start;\n\t\t} else {\n\t\t\tfields[i].start = 0;\n\t\t\tfields[i].value = NULL;\n\t\t\tfields[i].siz = 0;\n\t\t\tfields[i].is_null = 1;\n\t\t}\n\t\tif ((size_t)(fields[i].start + fields[i].siz) > row_start + row_size) {\n\t\t\tfprintf(stderr, \"warning: Invalid data location detected in mdb_crack_row.\\n\");\n\t\t\tg_free(var_col_offsets);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tg_free(var_col_offsets);\n\treturn row_cols;\n}\n\nint mdb_read_row(MdbTableDef *table, unsigned int row)\n{\n\tMdbHandle *mdb = table->entry->mdb;\n\tMdbColumn *col;\n\tunsigned int i;\n\tint row_start;\n\tsize_t row_size;\n\tint delflag, lookupflag;\n\tMdbField *fields;\n\tint num_fields;\n\n\tif (table->num_rows == 0 || table->num_cols == 0)\n\t\treturn 0;\n\n\tif (mdb_find_row(mdb, row, &row_start, &row_size)) {\n\t\tfprintf(stderr, \"warning: mdb_find_row failed.\\n\");\n\t\treturn 0;\n\t}\n    if (row_size == 0) {\n\t\tfprintf(stderr, \"warning: row_size = 0.\\n\");\n\t\treturn 0;\n    }\n\n\tdelflag = lookupflag = 0;\n\tif (row_start & 0x8000) lookupflag++;\n\tif (row_start & 0x4000) delflag++;\n\trow_start &= OFFSET_MASK; /* remove flags */\n#if MDB_DEBUG\n\tfprintf(stdout,\"Row %d bytes %d to %d %s %s\\n\", \n\t\trow, row_start, row_start + row_size - 1,\n\t\tlookupflag ? \"[lookup]\" : \"\",\n\t\tdelflag ? \"[delflag]\" : \"\");\n#endif\t\n\n\tif (!table->noskip_del && delflag) {\n\t\treturn 0;\n\t}\n\n\tfields = malloc(sizeof(MdbField) * table->num_cols);\n\n\tnum_fields = mdb_crack_row(table, row_start, row_size, fields);\n\tif (num_fields < 0 || !mdb_test_sargs(table, fields, num_fields)) {\n\t\tfree(fields);\n\t\treturn 0;\n\t}\n\t\n#if MDB_DEBUG\n\tfprintf(stdout,\"sarg test passed row %d \\n\", row);\n#endif \n\n#if MDB_DEBUG\n\tmdb_buffer_dump(mdb->pg_buf, row_start, row_size);\n#endif\n\n\t/* take advantage of mdb_crack_row() to clean up binding */\n\t/* use num_cols instead of num_fields -- bsb 03/04/02 */\n\tfor (i = 0; i < table->num_cols; i++) {\n\t\tcol = g_ptr_array_index(table->columns,fields[i].colnum);\n\t\t_mdb_attempt_bind(mdb, col, fields[i].is_null,\n\t\t\tfields[i].start, fields[i].siz);\n\t}\n\n\tfree(fields);\n\n\treturn 1;\n}\n\nint \nmdb_fetch_row(MdbTableDef *table)\n{\n\tMdbHandle *mdb = table->entry->mdb;\n\tMdbFormatConstants *fmt = mdb->fmt;\n\tunsigned int rows;\n\tint rc;\n\tguint32 pg;\n\n\tif (table->num_rows==0)\n\t\treturn 0;\n\n\t/* initialize */\n\tif (!table->cur_pg_num) {\n\t\ttable->cur_pg_num=1;\n\t\ttable->cur_row=0;\n\t\tif ((!table->is_temp_table)&&(table->strategy!=MDB_INDEX_SCAN))\n\t\t\tif (!mdb_read_next_dpg(table)) return 0;\n\t}\n\n\tdo {\n\t\tif (table->is_temp_table) {\n\t\t\tGPtrArray *pages = table->temp_table_pages;\n\t\t\trows = mdb_get_int16(\n\t\t\t\tg_ptr_array_index(pages, table->cur_pg_num-1),\n\t\t\t\tfmt->row_count_offset);\n\t\t\tif (table->cur_row >= rows) {\n\t\t\t\ttable->cur_row = 0;\n\t\t\t\tif (++table->cur_pg_num > (unsigned int)pages->len)\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tmemcpy(mdb->pg_buf,\n\t\t\t\tg_ptr_array_index(pages, table->cur_pg_num-1),\n\t\t\t\tfmt->pg_size);\n\t\t} else if (table->strategy==MDB_INDEX_SCAN) {\n\t\t\n\t\t\tif (!mdb_index_find_next(table->mdbidx, table->scan_idx, table->chain, &pg, (guint16 *) &(table->cur_row))) {\n\t\t\t\tmdb_index_scan_free(table);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tmdb_read_pg(mdb, pg);\n\t\t} else {\n\t\t\trows = mdb_get_int16(mdb->pg_buf,fmt->row_count_offset);\n\n\t\t\t/* if at end of page, find a new data page */\n\t\t\tif (table->cur_row >= rows) {\n\t\t\t\ttable->cur_row=0;\n\t\n\t\t\t\tif (!mdb_read_next_dpg(table)) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* printf(\"page %d row %d\\n\",table->cur_phys_pg, table->cur_row); */\n\t\trc = mdb_read_row(table, table->cur_row);\n\t\ttable->cur_row++;\n\t} while (!rc);\n\n\treturn 1;\n}\n\n\n\n\n// target function\nint mdb_read_row(MdbTableDef *table, unsigned int row)\n{\n\tMdbHandle *mdb = table->entry->mdb;\n\tMdbColumn *col;\n\tunsigned int i;\n\tint row_start;\n\tsize_t row_size;\n\tint delflag, lookupflag;\n\tMdbField fields[256];\n\tint num_fields;\n\n\tif (table->num_rows == 0) \n\t\treturn 0;\n\n\tif (mdb_find_row(mdb, row, &row_start, &row_size)) {\n\t\tfprintf(stderr, \"warning: mdb_find_row failed.\\n\");\n\t\treturn 0;\n\t}\n    if (row_size == 0) {\n\t\tfprintf(stderr, \"warning: row_size = 0.\\n\");\n\t\treturn 0;\n    }\n\n\tdelflag = lookupflag = 0;\n\tif (row_start & 0x8000) lookupflag++;\n\tif (row_start & 0x4000) delflag++;\n\trow_start &= OFFSET_MASK; /* remove flags */\n#if MDB_DEBUG\n\tfprintf(stdout,\"Row %d bytes %d to %d %s %s\\n\", \n\t\trow, row_start, row_start + row_size - 1,\n\t\tlookupflag ? \"[lookup]\" : \"\",\n\t\tdelflag ? \"[delflag]\" : \"\");\n#endif\t\n\n\tif (!table->noskip_del && delflag) {\n\t\treturn 0;\n\t}\n\n\tnum_fields = mdb_crack_row(table, row_start, row_size, fields);\n\tif (num_fields < 0)\n\t\treturn 0;\n\tif (!mdb_test_sargs(table, fields, num_fields)) return 0;\n\t\n#if MDB_DEBUG\n\tfprintf(stdout,\"sarg test passed row %d \\n\", row);\n#endif \n\n#if MDB_DEBUG\n\tmdb_buffer_dump(mdb->pg_buf, row_start, row_size);\n#endif\n\n\t/* take advantage of mdb_crack_row() to clean up binding */\n\t/* use num_cols instead of num_fields -- bsb 03/04/02 */\n\tfor (i = 0; i < table->num_cols; i++) {\n\t\tcol = g_ptr_array_index(table->columns,fields[i].colnum);\n\t\t_mdb_attempt_bind(mdb, col, fields[i].is_null,\n\t\t\tfields[i].start, fields[i].siz);\n\t}\n\n\treturn 1;\n}\nstatic int _mdb_attempt_bind(MdbHandle *mdb, \n\tMdbColumn *col, \n\tunsigned char isnull, \n\tint offset, \n\tint len)\n{\n\tif (col->col_type == MDB_BOOL) {\n\t\tmdb_xfer_bound_bool(mdb, col, isnull);\n\t} else if (isnull) {\n\t\tmdb_xfer_bound_data(mdb, 0, col, 0);\n\t} else if (col->col_type == MDB_OLE) {\n\t\tmdb_xfer_bound_ole(mdb, offset, col, len);\n\t} else {\n\t\t//if (!mdb_test_sargs(mdb, col, offset, len)) {\n\t\t\t//return 0;\n\t\t//}\n\t\tmdb_xfer_bound_data(mdb, offset, col, len);\n\t}\n\treturn 1;\n}\n",
    "target": 1,
    "idx": 1028780,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "// context\nvoid\nPl_ASCII85Decoder::write(unsigned char* buf, size_t len)\n{\n    if (eod > 1)\n    {\n\treturn;\n    }\n    for (size_t i = 0; i < len; ++i)\n    {\n\tif (eod > 1)\n\t{\n\t    break;\n\t}\n\telse if (eod == 1)\n\t{\n\t    if (buf[i] == '>')\n\t    {\n\t\tflush();\n\t\teod = 2;\n\t    }\n\t    else\n\t    {\n\t\tthrow std::runtime_error(\n\t\t    \"broken end-of-data sequence in base 85 data\");\n\t    }\n\t}\n\telse\n\t{\n\t    switch (buf[i])\n\t    {\n\t      case ' ':\n\t      case '\\f':\n\t      case '\\v':\n\t      case '\\t':\n\t      case '\\r':\n\t      case '\\n':\n\t\tQTC::TC(\"libtests\", \"Pl_ASCII85Decoder ignore space\");\n\t\t// ignore whitespace\n\t\tbreak;\n\n\t      case '~':\n\t\teod = 1;\n\t\tbreak;\n\n\t      case 'z':\n\t\tif (pos != 0)\n\t\t{\n\t\t    throw std::runtime_error(\n\t\t\t\"unexpected z during base 85 decode\");\n\t\t}\n\t\telse\n\t\t{\n\t\t    QTC::TC(\"libtests\", \"Pl_ASCII85Decoder read z\");\n                    unsigned char zeroes[4];\n                    memset(zeroes, '\\0', 4);\n\t\t    getNext()->write(zeroes, 4);\n\t\t}\n\t\tbreak;\n\n\t      default:\n\t\tif ((buf[i] < 33) || (buf[i] > 117))\n\t\t{\n\t\t    throw std::runtime_error(\n\t\t\t\"character out of range during base 85 decode\");\n\t\t}\n\t\telse\n\t\t{\n\t\t    this->inbuf[this->pos++] = buf[i];\n\t\t    if (pos == 5)\n\t\t    {\n\t\t\tflush();\n\t\t    }\n\t\t}\n\t\tbreak;\n\t    }\n\t}\n    }\n}\n\nvoid\nPl_AES_PDF::flush(bool strip_padding)\n{\n    assert(this->offset == this->buf_size);\n\n    if (first)\n    {\n\tfirst = false;\n        bool return_after_init = false;\n\tif (this->cbc_mode)\n\t{\n\t    if (encrypt)\n\t    {\n\t\t// Set cbc_block to the initialization vector, and if\n\t\t// not zero, write it to the output stream.\n\t\tinitializeVector();\n                if (! (this->use_zero_iv || this->use_specified_iv))\n                {\n                    getNext()->write(this->cbc_block, this->buf_size);\n                }\n\t    }\n\t    else if (this->use_zero_iv || this->use_specified_iv)\n            {\n                // Initialize vector with zeroes; zero vector was not\n                // written to the beginning of the input file.\n                initializeVector();\n            }\n            else\n\t    {\n\t\t// Take the first block of input as the initialization\n\t\t// vector.  There's nothing to write at this time.\n\t\tmemcpy(this->cbc_block, this->inbuf, this->buf_size);\n\t\tthis->offset = 0;\n                return_after_init = true;\n\t    }\n\t}\n        this->crypto->rijndael_init(\n            encrypt, this->key.get(), key_bytes,\n            this->cbc_mode, this->cbc_block);\n        if (return_after_init)\n        {\n            return;\n        }\n    }\n\n    if (this->encrypt)\n    {\n\tthis->crypto->rijndael_process(this->inbuf, this->outbuf);\n    }\n    else\n    {\n\tthis->crypto->rijndael_process(this->inbuf, this->outbuf);\n    }\n    unsigned int bytes = this->buf_size;\n    if (strip_padding)\n    {\n\tunsigned char last = this->outbuf[this->buf_size - 1];\n\tif (last <= this->buf_size)\n\t{\n\t    bool strip = true;\n\t    for (unsigned int i = 1; i <= last; ++i)\n\t    {\n\t\tif (this->outbuf[this->buf_size - i] != last)\n\t\t{\n\t\t    strip = false;\n\t\t    break;\n\t\t}\n\t    }\n\t    if (strip)\n\t    {\n\t\tbytes -= last;\n\t    }\n\t}\n    }\n    this->offset = 0;\n    getNext()->write(this->outbuf, bytes);\n}\n\nbool\nQPDF::pipeStreamData(int objid, int generation,\n\t\t     qpdf_offset_t offset, size_t length,\n\t\t     QPDFObjectHandle stream_dict,\n\t\t     Pipeline* pipeline,\n                     bool suppress_warnings,\n                     bool will_retry)\n{\n    bool is_attachment_stream = (\n        this->m->attachment_streams.count(\n            QPDFObjGen(objid, generation)) > 0);\n    return pipeStreamData(\n        this->m->encp, this->m->file, *this,\n        objid, generation, offset, length,\n        stream_dict, is_attachment_stream,\n        pipeline, suppress_warnings, will_retry);\n}\n\nbool\nQPDF::pipeStreamData(int objid, int generation,\n\t\t     qpdf_offset_t offset, size_t length,\n\t\t     QPDFObjectHandle stream_dict,\n\t\t     Pipeline* pipeline,\n                     bool suppress_warnings,\n                     bool will_retry)\n{\n    bool is_attachment_stream = (\n        this->m->attachment_streams.count(\n            QPDFObjGen(objid, generation)) > 0);\n    return pipeStreamData(\n        this->m->encp, this->m->file, *this,\n        objid, generation, offset, length,\n        stream_dict, is_attachment_stream,\n        pipeline, suppress_warnings, will_retry);\n}\n\nbool\nQPDF_Stream::pipeStreamData(Pipeline* pipeline, bool* filterp,\n                            int encode_flags,\n                            qpdf_stream_decode_level_e decode_level,\n                            bool suppress_warnings, bool will_retry)\n{\n    std::vector<std::shared_ptr<QPDFStreamFilter>> filters;\n    bool specialized_compression = false;\n    bool lossy_compression = false;\n    bool ignored;\n    if (filterp == nullptr)\n    {\n        filterp = &ignored;\n    }\n    bool& filter = *filterp;\n    filter = (! ((encode_flags == 0) && (decode_level == qpdf_dl_none)));\n    bool success = true;\n    if (filter)\n    {\n\tfilter = filterable(\n            filters, specialized_compression, lossy_compression);\n        if ((decode_level < qpdf_dl_all) && lossy_compression)\n        {\n            filter = false;\n        }\n        if ((decode_level < qpdf_dl_specialized) && specialized_compression)\n        {\n            filter = false;\n        }\n        QTC::TC(\"qpdf\", \"QPDF_Stream special filters\",\n                (! filter) ? 0 :\n                lossy_compression ? 1 :\n                specialized_compression ? 2 :\n                3);\n    }\n\n    if (pipeline == 0)\n    {\n\tQTC::TC(\"qpdf\", \"QPDF_Stream pipeStreamData with null pipeline\");\n        // Return value is whether we can filter in this case.\n\treturn filter;\n    }\n\n    // Construct the pipeline in reverse order. Force pipelines we\n    // create to be deleted when this function finishes. Pipelines\n    // created by QPDFStreamFilter objects will be deleted by those\n    // objects.\n    std::vector<PointerHolder<Pipeline>> to_delete;\n\n    PointerHolder<ContentNormalizer> normalizer;\n    if (filter)\n    {\n\tif (encode_flags & qpdf_ef_compress)\n\t{\n\t    pipeline = new Pl_Flate(\"compress stream\", pipeline,\n\t\t\t\t    Pl_Flate::a_deflate);\n\t    to_delete.push_back(pipeline);\n\t}\n\n\tif (encode_flags & qpdf_ef_normalize)\n\t{\n            normalizer = new ContentNormalizer();\n\t    pipeline = new Pl_QPDFTokenizer(\n                \"normalizer\", normalizer.getPointer(), pipeline);\n\t    to_delete.push_back(pipeline);\n\t}\n\n        for (std::vector<PointerHolder<\n                 QPDFObjectHandle::TokenFilter> >::reverse_iterator iter =\n                 this->token_filters.rbegin();\n             iter != this->token_filters.rend(); ++iter)\n        {\n            pipeline = new Pl_QPDFTokenizer(\n                \"token filter\", (*iter).getPointer(), pipeline);\n            to_delete.push_back(pipeline);\n        }\n\n\tfor (auto f_iter = filters.rbegin();\n             f_iter != filters.rend(); ++f_iter)\n\t{\n            auto decode_pipeline = (*f_iter)->getDecodePipeline(pipeline);\n            if (decode_pipeline)\n            {\n                pipeline = decode_pipeline;\n            }\n\t}\n    }\n\n    if (this->stream_data.getPointer())\n    {\n\tQTC::TC(\"qpdf\", \"QPDF_Stream pipe replaced stream data\");\n\tpipeline->write(this->stream_data->getBuffer(),\n\t\t\tthis->stream_data->getSize());\n\tpipeline->finish();\n    }\n    else if (this->stream_provider.getPointer())\n    {\n\tPl_Count count(\"stream provider count\", pipeline);\n        if (this->stream_provider->supportsRetry())\n        {\n            if (! this->stream_provider->provideStreamData(\n                    this->objid, this->generation, &count,\n                    suppress_warnings, will_retry))\n            {\n                filter = false;\n                success = false;\n            }\n        }\n        else\n        {\n            this->stream_provider->provideStreamData(\n                this->objid, this->generation, &count);\n        }\n\tqpdf_offset_t actual_length = count.getCount();\n\tqpdf_offset_t desired_length = 0;\n        if (this->stream_dict.hasKey(\"/Length\"))\n        {\n\t    desired_length = this->stream_dict.getKey(\"/Length\").getIntValue();\n            if (actual_length == desired_length)\n            {\n                QTC::TC(\"qpdf\", \"QPDF_Stream pipe use stream provider\");\n            }\n            else\n            {\n                QTC::TC(\"qpdf\", \"QPDF_Stream provider length mismatch\");\n                // This would be caused by programmer error on the\n                // part of a library user, not by invalid input data.\n                throw std::runtime_error(\n                    \"stream data provider for \" +\n                    QUtil::int_to_string(this->objid) + \" \" +\n                    QUtil::int_to_string(this->generation) +\n                    \" provided \" +\n                    QUtil::int_to_string(actual_length) +\n                    \" bytes instead of expected \" +\n                    QUtil::int_to_string(desired_length) + \" bytes\");\n            }\n        }\n        else\n        {\n            QTC::TC(\"qpdf\", \"QPDF_Stream provider length not provided\");\n            this->stream_dict.replaceKey(\n                \"/Length\", QPDFObjectHandle::newInteger(actual_length));\n        }\n    }\n    else if (this->offset == 0)\n    {\n\tQTC::TC(\"qpdf\", \"QPDF_Stream pipe no stream data\");\n\tthrow std::logic_error(\n\t    \"pipeStreamData called for stream with no data\");\n    }\n    else\n    {\n\tQTC::TC(\"qpdf\", \"QPDF_Stream pipe original stream data\");\n\tif (! QPDF::Pipe::pipeStreamData(this->qpdf, this->objid, this->generation,\n                                         this->offset, this->length,\n                                         this->stream_dict, pipeline,\n                                         suppress_warnings,\n                                         will_retry))\n        {\n            filter = false;\n            success = false;\n        }\n    }\n\n    if (filter &&\n        (! suppress_warnings) &&\n        normalizer.getPointer() &&\n        normalizer->anyBadTokens())\n    {\n        warn(QPDFExc(qpdf_e_damaged_pdf, qpdf->getFilename(),\n                     \"\", this->offset,\n                     \"content normalization encountered bad tokens\"));\n        if (normalizer->lastTokenWasBad())\n        {\n            QTC::TC(\"qpdf\", \"QPDF_Stream bad token at end during normalize\");\n            warn(QPDFExc(qpdf_e_damaged_pdf, qpdf->getFilename(),\n                         \"\", this->offset,\n                         \"normalized content ended with a bad token;\"\n                         \" you may be able to resolve this by\"\n                         \" coalescing content streams in combination\"\n                         \" with normalizing content. From the command\"\n                         \" line, specify --coalesce-contents\"));\n        }\n        warn(QPDFExc(qpdf_e_damaged_pdf, qpdf->getFilename(),\n                     \"\", this->offset,\n                     \"Resulting stream data may be corrupted but is\"\n                     \" may still useful for manual inspection.\"\n                     \" For more information on this warning, search\"\n                     \" for content normalization in the manual.\"));\n    }\n\n    return success;\n}\n\nbool\nQPDFObjectHandle::pipeStreamData(Pipeline* p, bool filter,\n\t\t\t\t bool normalize, bool compress)\n{\n    int encode_flags = 0;\n    qpdf_stream_decode_level_e decode_level = qpdf_dl_none;\n    if (filter)\n    {\n        decode_level = qpdf_dl_generalized;\n        if (normalize)\n        {\n            encode_flags |= qpdf_ef_normalize;\n        }\n        if (compress)\n        {\n            encode_flags |= qpdf_ef_compress;\n        }\n    }\n    return pipeStreamData(p, encode_flags, decode_level, false);\n}\n\nbool\nQPDFWriter::willFilterStream(QPDFObjectHandle stream,\n                             bool& compress_stream, bool& is_metadata,\n                             PointerHolder<Buffer>* stream_data)\n{\n    compress_stream = false;\n    is_metadata = false;\n\n    QPDFObjGen old_og = stream.getObjGen();\n    QPDFObjectHandle stream_dict = stream.getDict();\n\n    if (stream_dict.getKey(\"/Type\").isName() &&\n        (stream_dict.getKey(\"/Type\").getName() == \"/Metadata\"))\n    {\n        is_metadata = true;\n    }\n    bool filter = (stream.isDataModified() ||\n                   this->m->compress_streams ||\n                   this->m->stream_decode_level);\n    bool filter_on_write = stream.getFilterOnWrite();\n    if (! filter_on_write)\n    {\n        QTC::TC(\"qpdf\", \"QPDFWriter getFilterOnWrite false\");\n        filter = false;\n    }\n    if (filter_on_write && this->m->compress_streams)\n    {\n        // Don't filter if the stream is already compressed with\n        // FlateDecode. This way we don't make it worse if the\n        // original file used a better Flate algorithm, and we\n        // don't spend time and CPU cycles uncompressing and\n        // recompressing stuff. This can be overridden with\n        // setRecompressFlate(true).\n        QPDFObjectHandle filter_obj = stream_dict.getKey(\"/Filter\");\n        if ((! this->m->recompress_flate) &&\n            (! stream.isDataModified()) &&\n            filter_obj.isName() &&\n            ((filter_obj.getName() == \"/FlateDecode\") ||\n             (filter_obj.getName() == \"/Fl\")))\n        {\n            QTC::TC(\"qpdf\", \"QPDFWriter not recompressing /FlateDecode\");\n            filter = false;\n        }\n    }\n    bool normalize = false;\n    bool uncompress = false;\n    if (filter_on_write && is_metadata &&\n        ((! this->m->encrypted) || (this->m->encrypt_metadata == false)))\n    {\n        QTC::TC(\"qpdf\", \"QPDFWriter not compressing metadata\");\n        filter = true;\n        compress_stream = false;\n        uncompress = true;\n    }\n    else if (filter_on_write && this->m->normalize_content &&\n             this->m->normalized_streams.count(old_og))\n    {\n        normalize = true;\n        filter = true;\n    }\n    else if (filter_on_write && filter && this->m->compress_streams)\n    {\n        compress_stream = true;\n        QTC::TC(\"qpdf\", \"QPDFWriter compressing uncompressed stream\");\n    }\n\n    bool filtered = false;\n    for (int attempt = 1; attempt <= 2; ++attempt)\n    {\n        pushPipeline(new Pl_Buffer(\"stream data\"));\n        PipelinePopper pp_stream_data(this, stream_data);\n        activatePipelineStack(pp_stream_data);\n        filtered =\n            stream.pipeStreamData(\n                this->m->pipeline,\n                (((filter && normalize) ? qpdf_ef_normalize : 0) |\n                 ((filter && compress_stream) ? qpdf_ef_compress : 0)),\n                (filter\n                 ? (uncompress ? qpdf_dl_all : this->m->stream_decode_level)\n                 : qpdf_dl_none), false, (attempt == 1));\n        if (filter && (! filtered))\n        {\n            // Try again\n            filter = false;\n        }\n        else\n        {\n            break;\n        }\n    }\n    if (! filtered)\n    {\n        compress_stream = false;\n    }\n    return filtered;\n}\n\n\n\nvoid\nQPDFWriter::writeObjectStreamOffsets(std::vector<qpdf_offset_t>& offsets,\n\t\t\t\t     int first_obj)\n{\n    for (size_t i = 0; i < offsets.size(); ++i)\n    {\n\tif (i != 0)\n\t{\n\t    writeStringQDF(\"\\n\");\n\t    writeStringNoQDF(\" \");\n\t}\n\twriteString(QUtil::uint_to_string(i + QIntC::to_size(first_obj)));\n\twriteString(\" \");\n\twriteString(QUtil::int_to_string(offsets.at(i)));\n    }\n    writeString(\"\\n\");\n}\n\nvoid\nQPDFWriter::writeStandard()\n{\n    PointerHolder<PipelinePopper> pp_md5 = new PipelinePopper(this);\n    if (this->m->deterministic_id)\n    {\n        pushMD5Pipeline(*pp_md5);\n    }\n\n    // Start writing\n\n    writeHeader();\n    writeString(this->m->extra_header_text);\n\n    if (this->m->pclm)\n    {\n        enqueueObjectsPCLm();\n    }\n    else\n    {\n        enqueueObjectsStandard();\n    }\n\n    // Now start walking queue, outputting each object.\n    while (this->m->object_queue.size())\n    {\n\tQPDFObjectHandle cur_object = this->m->object_queue.front();\n\tthis->m->object_queue.pop_front();\n\twriteObject(cur_object);\n    }\n\n    // Write out the encryption dictionary, if any\n    if (this->m->encrypted)\n    {\n\twriteEncryptionDictionary();\n    }\n\n    // Now write out xref.  next_objid is now the number of objects.\n    qpdf_offset_t xref_offset = this->m->pipeline->getCount();\n    if (this->m->object_stream_to_objects.empty())\n    {\n\t// Write regular cross-reference table\n\twriteXRefTable(t_normal, 0, this->m->next_objid - 1,\n                       this->m->next_objid);\n    }\n    else\n    {\n\t// Write cross-reference stream.\n\tint xref_id = this->m->next_objid++;\n\twriteXRefStream(xref_id, xref_id, xref_offset, t_normal,\n\t\t\t0, this->m->next_objid - 1, this->m->next_objid);\n    }\n    writeString(\"startxref\\n\");\n    writeString(QUtil::int_to_string(xref_offset));\n    writeString(\"\\n%%EOF\\n\");\n\n    if (this->m->deterministic_id)\n    {\n\tQTC::TC(\"qpdf\", \"QPDFWriter standard deterministic ID\",\n                this->m->object_stream_to_objects.empty() ? 0 : 1);\n        pp_md5 = 0;\n        assert(this->m->md5_pipeline == 0);\n    }\n}\n\nvoid\nQPDFWriter::write()\n{\n    doWriteSetup();\n\n    // Set up progress reporting. For linearized files, we write two\n    // passes. events_expected is an approximation, but it's good\n    // enough for progress reporting, which is mostly a guess anyway.\n    this->m->events_expected = QIntC::to_int(\n        this->m->pdf.getObjectCount() * (this->m->linearized ? 2 : 1));\n\n    prepareFileForWrite();\n\n    if (this->m->linearized)\n    {\n\twriteLinearized();\n    }\n    else\n    {\n\twriteStandard();\n    }\n\n    this->m->pipeline->finish();\n    if (this->m->close_file)\n    {\n\tfclose(this->m->file);\n    }\n    this->m->file = 0;\n    if (this->m->buffer_pipeline)\n    {\n\tthis->m->output_buffer = this->m->buffer_pipeline->getBuffer();\n\tthis->m->buffer_pipeline = 0;\n    }\n    indicateProgress(false, true);\n}\n\nvoid\nFuzzHelper::doWrite(PointerHolder<QPDFWriter> w)\n{\n    try\n    {\n        w->write();\n    }\n    catch (QPDFExc const& e)\n    {\n        std::cerr << e.what() << std::endl;\n    }\n    catch (std::runtime_error const& e)\n    {\n        std::cerr << e.what() << std::endl;\n    }\n}\n\nvoid\nFuzzHelper::testWrite()\n{\n    // Write in various ways to exercise QPDFWriter\n\n    PointerHolder<QPDF> q;\n    PointerHolder<QPDFWriter> w;\n\n    q = getQpdf();\n    w = getWriter(q);\n    w->setDeterministicID(true);\n    w->setQDFMode(true);\n    doWrite(w);\n\n    q = getQpdf();\n    w = getWriter(q);\n    w->setStaticID(true);\n    w->setLinearization(true);\n    w->setR6EncryptionParameters(\n        \"u\", \"o\", true, true, true, true, true, true, qpdf_r3p_full, true);\n    doWrite(w);\n\n    q = getQpdf();\n    w = getWriter(q);\n    w->setStaticID(true);\n    w->setObjectStreamMode(qpdf_o_disable);\n    w->setR3EncryptionParameters(\n\t\"u\", \"o\", true, true, qpdf_r3p_full, qpdf_r3m_all);\n    doWrite(w);\n\n    q = getQpdf();\n    w = getWriter(q);\n    w->setDeterministicID(true);\n    w->setObjectStreamMode(qpdf_o_generate);\n    w->setLinearization(true);\n    doWrite(w);\n}\n\nvoid\nFuzzHelper::doChecks()\n{\n    // Get as much coverage as possible in parts of the library that\n    // might benefit from fuzzing.\n    testWrite();\n    testPages();\n    testOutlines();\n}\n\nvoid\nFuzzHelper::run()\n{\n    // The goal here is that you should be able to throw anything at\n    // libqpdf and it will respond without any memory errors and never\n    // do anything worse than throwing a QPDFExc or\n    // std::runtime_error. Throwing any other kind of exception,\n    // segfaulting, or having a memory error (when built with\n    // appropriate sanitizers) will all cause abnormal exit.\n    try\n    {\n        doChecks();\n    }\n    catch (QPDFExc const& e)\n    {\n        std::cerr << \"QPDFExc: \" << e.what() << std::endl;\n    }\n    catch (std::runtime_error const& e)\n    {\n        std::cerr << \"runtime_error: \" << e.what() << std::endl;\n    }\n}\n\n\n// target function\nvoid\nPl_AES_PDF::flush(bool strip_padding)\n{\n    assert(this->offset == this->buf_size);\n\n    if (first)\n    {\n\tfirst = false;\n        bool return_after_init = false;\n\tif (this->cbc_mode)\n\t{\n\t    if (encrypt)\n\t    {\n\t\t// Set cbc_block to the initialization vector, and if\n\t\t// not zero, write it to the output stream.\n\t\tinitializeVector();\n                if (! (this->use_zero_iv || this->use_specified_iv))\n                {\n                    getNext()->write(this->cbc_block, this->buf_size);\n                }\n\t    }\n\t    else if (this->use_zero_iv || this->use_specified_iv)\n            {\n                // Initialize vector with zeroes; zero vector was not\n                // written to the beginning of the input file.\n                initializeVector();\n            }\n            else\n\t    {\n\t\t// Take the first block of input as the initialization\n\t\t// vector.  There's nothing to write at this time.\n\t\tmemcpy(this->cbc_block, this->inbuf, this->buf_size);\n\t\tthis->offset = 0;\n                return_after_init = true;\n\t    }\n\t}\n        this->crypto->rijndael_init(\n            encrypt, this->key.get(), key_bytes,\n            this->cbc_mode, this->cbc_block);\n        if (return_after_init)\n        {\n            return;\n        }\n    }\n\n    if (this->encrypt)\n    {\n\tthis->crypto->rijndael_process(this->inbuf, this->outbuf);\n    }\n    else\n    {\n\tthis->crypto->rijndael_process(this->inbuf, this->outbuf);\n    }\n    unsigned int bytes = this->buf_size;\n    if (strip_padding)\n    {\n\tunsigned char last = this->outbuf[this->buf_size - 1];\n\tif (last <= this->buf_size)\n\t{\n\t    bool strip = true;\n\t    for (unsigned int i = 1; i <= last; ++i)\n\t    {\n\t\tif (this->outbuf[this->buf_size - i] != last)\n\t\t{\n\t\t    strip = false;\n\t\t    break;\n\t\t}\n\t    }\n\t    if (strip)\n\t    {\n\t\tbytes -= last;\n\t    }\n\t}\n    }\n    getNext()->write(this->outbuf, bytes);\n    this->offset = 0;\n}\nvoid\nPl_ASCII85Decoder::flush()\n{\n    if (this->pos == 0)\n    {\n\tQTC::TC(\"libtests\", \"Pl_ASCII85Decoder no-op flush\");\n\treturn;\n    }\n    unsigned long lval = 0;\n    for (int i = 0; i < 5; ++i)\n    {\n\tlval *= 85;\n\tlval += (this->inbuf[i] - 33U);\n    }\n\n    unsigned char outbuf[4];\n    memset(outbuf, 0, 4);\n    for (int i = 3; i >= 0; --i)\n    {\n\toutbuf[i] = lval & 0xff;\n\tlval >>= 8;\n    }\n\n    QTC::TC(\"libtests\", \"Pl_ASCII85Decoder partial flush\",\n\t    (this->pos == 5) ? 0 : 1);\n    getNext()->write(outbuf, this->pos - 1);\n\n    this->pos = 0;\n    memset(this->inbuf, 117, 5);\n}\nvoid\nPl_ASCII85Decoder::finish()\n{\n    flush();\n    getNext()->finish();\n}\nvoid\nPl_ASCIIHexDecoder::flush()\n{\n    if (this->pos == 0)\n    {\n\tQTC::TC(\"libtests\", \"Pl_ASCIIHexDecoder no-op flush\");\n\treturn;\n    }\n    int b[2];\n    for (int i = 0; i < 2; ++i)\n    {\n\tif (this->inbuf[i] >= 'A')\n\t{\n\t    b[i] = this->inbuf[i] - 'A' + 10;\n\t}\n\telse\n\t{\n\t    b[i] = this->inbuf[i] - '0';\n\t}\n    }\n    unsigned char ch = static_cast<unsigned char>((b[0] << 4) + b[1]);\n\n    QTC::TC(\"libtests\", \"Pl_ASCIIHexDecoder partial flush\",\n\t    (this->pos == 2) ? 0 : 1);\n    getNext()->write(&ch, 1);\n\n    this->pos = 0;\n    this->inbuf[0] = '0';\n    this->inbuf[1] = '0';\n    this->inbuf[2] = '\\0';\n}\nvoid\nPl_Count::write(unsigned char* buf, size_t len)\n{\n    if (len)\n    {\n\tthis->m->count += QIntC::to_offset(len);\n\tgetNext()->write(buf, len);\n\tthis->m->last_char = buf[len - 1];\n    }\n}\n",
    "target": 1,
    "idx": 1028262,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic int tcos_decipher(sc_card_t *card, const u8 * crgram, size_t crgram_len, u8 * out, size_t outlen)\n{\n\tsc_context_t *ctx;\n\tsc_apdu_t apdu;\n\tu8 rbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tu8 sbuf[SC_MAX_APDU_BUFFER_SIZE];\n\ttcos_data *data;\n\tint tcos3, r;\n\n\tassert(card != NULL && crgram != NULL && out != NULL);\n\tctx = card->ctx;\n\ttcos3=(card->type==SC_CARD_TYPE_TCOS_V3);\n\tdata=(tcos_data *)card->drv_data;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx,\n\t\t\"TCOS3:%d PKCS1:%d\\n\",tcos3,\n\t\t!!(data->pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1));\n\n\tsc_format_apdu(card, &apdu, crgram_len>255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT, 0x2A, 0x80, 0x86);\n\tapdu.resp = rbuf;\n\tapdu.resplen = sizeof(rbuf);\n\tapdu.le = crgram_len;\n\n\tapdu.data = sbuf;\n\tapdu.lc = apdu.datalen = crgram_len+1;\n\tsbuf[0] = tcos3 ? 0x00 : ((data->pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1) ? 0x81 : 0x02);\n\tif (sizeof sbuf - 1 < crgram_len)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\tmemcpy(sbuf+1, crgram, crgram_len);\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\n\tif (apdu.sw1==0x90 && apdu.sw2==0x00) {\n\t\tsize_t len= (apdu.resplen>outlen) ? outlen : apdu.resplen;\n\t\tunsigned int offset=0;\n\t\tif(tcos3 && (data->pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1) && apdu.resp[0]==0 && apdu.resp[1]==2) {\n\t\t\toffset=2; while(offset<len && apdu.resp[offset]!=0) ++offset;\n\t\t\toffset=(offset<len-1) ? offset+1 : 0;\n\t\t}\n\t\tmemcpy(out, apdu.resp+offset, len-offset);\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, len-offset);\n\t}\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, sc_check_sw(card, apdu.sw1, apdu.sw2));\n}\n\nint sc_decipher(sc_card_t *card,\n\t\tconst u8 * crgram, size_t crgram_len, u8 * out, size_t outlen)\n{\n\tint r;\n\n\tif (card == NULL || crgram == NULL || out == NULL) {\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\tLOG_FUNC_CALLED(card->ctx);\n\tif (card->ops->decipher == NULL)\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_NOT_SUPPORTED);\n\tr = card->ops->decipher(card, crgram, crgram_len, out, outlen);\n        SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);\n}\n\nstatic int use_key(struct sc_pkcs15_card *p15card,\n\t\tconst struct sc_pkcs15_object *obj,\n\t\tsc_security_env_t *senv,\n\t\tint (*card_command)(sc_card_t *card,\n\t\t\t const u8 * in, size_t inlen,\n\t\t\t u8 * out, size_t outlen),\n\t\tconst u8 * in, size_t inlen, u8 * out, size_t outlen)\n{\n\tint r = SC_SUCCESS;\n\tint revalidated_cached_pin = 0;\n\tsc_path_t path;\n\tLOG_TEST_RET(p15card->card->ctx, get_file_path(obj, &path), \"Failed to get key file path.\");\n\n\tr = sc_lock(p15card->card);\n\tLOG_TEST_RET(p15card->card->ctx, r, \"sc_lock() failed\");\n\n\tdo {\n\t\tif (path.len != 0 || path.aid.len != 0) {\n\t\t\tr = select_key_file(p15card, obj, senv);\n\t\t\tif (r < 0) {\n\t\t\t\tsc_log(p15card->card->ctx,\n\t\t\t\t\t\t\"Unable to select private key file\");\n\t\t\t}\n\t\t}\n\t\tif (r == SC_SUCCESS)\n\t\t\tr = sc_set_security_env(p15card->card, senv, 0);\n\n\t\tif (r == SC_SUCCESS)\n\t\t\tr = card_command(p15card->card, in, inlen, out, outlen);\n\n\t\tif (revalidated_cached_pin)\n\t\t\t/* only re-validate once */\n\t\t\tbreak;\n\t\tif (r == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED) {\n\t\t\tr = sc_pkcs15_pincache_revalidate(p15card, obj);\n\t\t\tif (r < 0)\n\t\t\t\tbreak;\n\t\t\trevalidated_cached_pin = 1;\n\t\t}\n\t} while (revalidated_cached_pin);\n\n\tsc_unlock(p15card->card);\n\n\treturn r;\n}\n\nint sc_pkcs15_decipher(struct sc_pkcs15_card *p15card,\n\t\tconst struct sc_pkcs15_object *obj,\n\t\tunsigned long flags,\n\t\tconst u8 * in, size_t inlen, u8 *out, size_t outlen)\n{\n\tsc_context_t *ctx = p15card->card->ctx;\n\tint r;\n\tsc_algorithm_info_t *alg_info = NULL;\n\tsc_security_env_t senv;\n\tconst struct sc_pkcs15_prkey_info *prkey = (const struct sc_pkcs15_prkey_info *) obj->data;\n\tunsigned long pad_flags = 0, sec_flags = 0;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tif (!(prkey->usage & (SC_PKCS15_PRKEY_USAGE_DECRYPT|SC_PKCS15_PRKEY_USAGE_UNWRAP)))\n\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_ALLOWED, \"This key cannot be used for decryption\");\n\n\tr = format_senv(p15card, obj, &senv, &alg_info);\n\tLOG_TEST_RET(ctx, r, \"Could not initialize security environment\");\n\tsenv.operation = SC_SEC_OPERATION_DECIPHER;\n\n\tr = sc_get_encoding_flags(ctx, flags, alg_info->flags, &pad_flags, &sec_flags);\n\tLOG_TEST_RET(ctx, r, \"cannot encode security operation flags\");\n\tsenv.algorithm_flags = sec_flags;\n\n\tr = use_key(p15card, obj, &senv, sc_decipher, in, inlen, out,\n\t\t\toutlen);\n\tLOG_TEST_RET(ctx, r, \"use_key() failed\");\n\n\t/* Strip any padding */\n\tif (pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1) {\n\t\tsize_t s = r;\n\t\tr = sc_pkcs1_strip_02_padding(ctx, out, s, out, &s);\n\t\tLOG_TEST_RET(ctx, r, \"Invalid PKCS#1 padding\");\n\t}\n\n\tLOG_FUNC_RETURN(ctx, r);\n}\n\n\n// target function\nstatic int tcos_decipher(sc_card_t *card, const u8 * crgram, size_t crgram_len, u8 * out, size_t outlen)\n{\n\tsc_context_t *ctx;\n\tsc_apdu_t apdu;\n\tu8 rbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tu8 sbuf[SC_MAX_APDU_BUFFER_SIZE];\n\ttcos_data *data;\n\tint tcos3, r;\n\n\tassert(card != NULL && crgram != NULL && out != NULL);\n\tctx = card->ctx;\n\ttcos3=(card->type==SC_CARD_TYPE_TCOS_V3);\n\tdata=(tcos_data *)card->drv_data;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx,\n\t\t\"TCOS3:%d PKCS1:%d\\n\",tcos3,\n\t\t!!(data->pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1));\n\n\tsc_format_apdu(card, &apdu, crgram_len>255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT, 0x2A, 0x80, 0x86);\n\tapdu.resp = rbuf;\n\tapdu.resplen = sizeof(rbuf);\n\tapdu.le = crgram_len;\n\n\tapdu.data = sbuf;\n\tapdu.lc = apdu.datalen = crgram_len+1;\n\tsbuf[0] = tcos3 ? 0x00 : ((data->pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1) ? 0x81 : 0x02);\n\tmemcpy(sbuf+1, crgram, crgram_len);\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\n\tif (apdu.sw1==0x90 && apdu.sw2==0x00) {\n\t\tsize_t len= (apdu.resplen>outlen) ? outlen : apdu.resplen;\n\t\tunsigned int offset=0;\n\t\tif(tcos3 && (data->pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1) && apdu.resp[0]==0 && apdu.resp[1]==2) {\n\t\t\toffset=2; while(offset<len && apdu.resp[offset]!=0) ++offset;\n\t\t\toffset=(offset<len-1) ? offset+1 : 0;\n\t\t}\n\t\tmemcpy(out, apdu.resp+offset, len-offset);\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, len-offset);\n\t}\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, sc_check_sw(card, apdu.sw1, apdu.sw2));\n}\n",
    "target": 1,
    "idx": 1022967,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic int\njson_HEADER (Bit_Chain *restrict dat, Dwg_Data *restrict dwg,\n             jsmntokens_t *restrict tokens)\n{\n  const char *section = \"HEADER\";\n  const char *name = section;\n  jsmntok_t *t = &tokens->tokens[tokens->index];\n  // Dwg_Header_Variables *_obj = &dwg->header_vars;\n  Dwg_Object *obj = NULL;\n  int size = t->size;\n\n  if (t->type != JSMN_OBJECT)\n    {\n      LOG_ERROR (\"Unexpected %s at %u of %ld tokens, expected %s OBJECT\",\n                 t_typename[t->type], tokens->index, tokens->num_tokens,\n                 section);\n      json_advance_unknown (dat, tokens, t->type, 0);\n      return DWG_ERR_INVALIDTYPE;\n    }\n  LOG_TRACE (\"\\n%s pos:%d [%d keys]\\n--------------------\\n\", section,\n             tokens->index, t->size);\n  tokens->index++;\n  for (int i = 0; i < size; i++)\n    {\n      char key[80];\n      Dwg_DYNAPI_field *f;\n\n      json_fixed_key (key, dat, tokens);\n      JSON_TOKENS_CHECK_OVERFLOW_ERR\n      t = &tokens->tokens[tokens->index];\n      f = (Dwg_DYNAPI_field *)dwg_dynapi_header_field (key);\n      if (!f)\n        {\n          if (t->type == JSMN_ARRAY && strEQc (key, \"layer_colors\"))\n            {\n              tokens->index++;\n              for (int index = 0; index < MAX (t->size, 128); index++)\n                {\n                  dwg->header_vars.layer_colors[index]\n                      = (BITCODE_RS)json_long (dat, tokens);\n                  LOG_TRACE (\"%s: \" FORMAT_RS \" [RS]\\n\", key,\n                             dwg->header_vars.layer_colors[index]);\n                }\n              JSON_TOKENS_CHECK_OVERFLOW_ERR;\n            }\n          else\n            {\n              LOG_WARN (\"Unknown key HEADER.%s\", key)\n              json_advance_unknown (dat, tokens, t->type, 0);\n              continue;\n            }\n        }\n      else if (t->type == JSMN_PRIMITIVE\n               && (strEQc (f->type, \"BD\") || strEQc (f->type, \"RD\")))\n        {\n          double num = json_float (dat, tokens);\n          LOG_TRACE (\"%s: \" FORMAT_RD \" [%s]\\n\", key, num, f->type)\n          dwg_dynapi_header_set_value (dwg, key, &num, 0);\n        }\n      else if (t->type == JSMN_PRIMITIVE\n               && f->size <= 4  // not a RS[]\n               && (strEQc (f->type, \"RC\") || strEQc (f->type, \"B\")\n                   || strEQc (f->type, \"BB\") || strEQc (f->type, \"RS\")\n                   || strEQc (f->type, \"BS\") || strEQc (f->type, \"RL\")\n                   || strEQc (f->type, \"BL\") || strEQc (f->type, \"RSd\")\n                   || strEQc (f->type, \"BLd\") || strEQc (f->type, \"BSd\")))\n        {\n          long num = json_long (dat, tokens);\n          LOG_TRACE (\"%s: %ld [%s]\\n\", key, num, f->type)\n          dwg_dynapi_header_set_value (dwg, key, &num, 0);\n        }\n      else if (t->type == JSMN_PRIMITIVE\n               && f->size == 8 // not a RLL[]\n               && (strEQc (f->type, \"RLL\") || strEQc (f->type, \"BLL\")))\n        {\n          uint64_t num = json_longlong (dat, tokens);\n          LOG_TRACE (\"%s: \" FORMAT_RLL \" [%s]\\n\", key, num, f->type)\n          dwg_dynapi_header_set_value (dwg, key, &num, 0);\n        }\n      else if (t->type == JSMN_STRING\n               && (strEQc (f->type, \"TV\") || strEQc (f->type, \"T\")))\n        {\n          size_t len;\n          char *str = json_string (dat, tokens);\n          LOG_TRACE (\"%s: \\\"%s\\\" [%s]\\n\", key, str, f->type);\n          if (dwg->header.version < R_13b1 && strEQc (key, \"MENU\")\n              && (len = strlen (str) > 15))\n            { // split into MENU + MENUEXT\n              strncpy ((char *)dwg->header_vars.MENUEXT, &str[15], 45);\n              str[15] = '\\0';\n              dwg->header_vars.MENU = strdup (str);\n              dwg->header_vars.MENUEXT[45] = '\\0';\n            }\n          else\n            dwg_dynapi_header_set_value (dwg, key, &str, 1);\n          free (str);\n        }\n      else if (t->type == JSMN_ARRAY\n               && (strEQc (f->type, \"3BD\") || strEQc (f->type, \"3RD\")\n                   || strEQc (f->type, \"3DPOINT\") || strEQc (f->type, \"BE\")\n                   || strEQc (f->type, \"3BD_1\")))\n        {\n          BITCODE_3DPOINT pt;\n          json_3DPOINT (dat, tokens, name, key, f->type, &pt);\n          dwg_dynapi_header_set_value (dwg, key, &pt, 1);\n        }\n      else if (t->type == JSMN_ARRAY\n               && (strEQc (f->type, \"2BD\") || strEQc (f->type, \"2RD\")\n                   || strEQc (f->type, \"2DPOINT\")\n                   || strEQc (f->type, \"2BD_1\")))\n        {\n          BITCODE_2DPOINT pt;\n          json_2DPOINT (dat, tokens, name, key, f->type, &pt);\n          dwg_dynapi_header_set_value (dwg, key, &pt, 1);\n        }\n      else if (t->type == JSMN_ARRAY\n               && (strEQc (f->type, \"BS\") || strEQc (f->type, \"RS\")))\n        {\n          int size1 = t->size;\n          BITCODE_BS *nums = (BITCODE_BS *)calloc (f->size, 1);\n          tokens->index++;\n          // fail if not malloced or inlined array (but json has an array)\n          if (f->size <= 2 && size1 > 1)\n            {\n              LOG_ERROR (\"Invalid JSON: HEADER.%s array where primitive expected\",\n                         f->name);\n              free (nums);\n              tokens->index += size1;\n              return 0;\n            }\n          for (int k = 0; k < size1; k++)\n            {\n              JSON_TOKENS_CHECK_OVERFLOW_ERR\n              if (k < (f->size / 2))\n                {\n                  nums[k] = (BITCODE_BS)json_long (dat, tokens);\n                  LOG_TRACE (\"%s.%s[%d]: \" FORMAT_BS \" [%s]\\n\", name, key, k,\n                             nums[k], f->type);\n                }\n              else\n                {\n                  LOG_WARN (\"Ignored %s.%s[%d]: %ld [%s]\", name, key, k,\n                             json_long (dat, tokens), f->type);\n                }\n            }\n          if (!size1)\n            LOG_TRACE (\"%s.%s: [%s] empty\\n\", name, key, f->type);\n          if (!f->is_malloc)\n            {\n              dwg_dynapi_header_set_value (dwg, key, nums, 1);\n              free (nums);\n            }\n          else\n            dwg_dynapi_header_set_value (dwg, key, &nums, 1);\n        }\n      else if (strEQc (f->type, \"TIMEBLL\") || strEQc (f->type, \"TIMERLL\"))\n        {\n          BITCODE_TIMEBLL date = { 0 };\n          json_TIMEBLL (dat, tokens, key, &date);\n          dwg_dynapi_header_set_value (dwg, key, &date, 0);\n        }\n      else if (strEQc (f->type, \"CMC\"))\n        {\n          BITCODE_CMC color = { 0 };\n          json_CMC (dat, dwg, tokens, name, key, &color);\n          dwg_dynapi_header_set_value (dwg, key, &color, 0);\n        }\n      else if (t->type == JSMN_ARRAY && strEQc (f->type, \"H\"))\n        {\n          BITCODE_H hdl\n              = json_HANDLE (dat, dwg, tokens, section, key, NULL, -1);\n          if (hdl)\n            dwg_dynapi_header_set_value (dwg, key, &hdl, 0);\n        }\n      //...\n      else if (t->type == JSMN_OBJECT && strEQc (key, \"CLASSES\"))\n        {\n          LOG_WARN (\"Unexpected next section %s\", key)\n          tokens->index--;\n          tokens->index--;\n          return 0;\n        }\n      else\n        {\n          LOG_WARN (\"Unhandled %s [%s] with %s\", key, f->type,\n                    t_typename[t->type])\n          tokens->index++;\n          continue;\n        }\n    }\n  LOG_TRACE (\"End of %s\\n\", section)\n  // the key\n  tokens->index--;\n  return 0;\n}\n\nEXPORT int\ndwg_read_json (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  Dwg_Header *obj = &dwg->header;\n  jsmn_parser parser;\n  jsmntokens_t tokens;\n  unsigned int i;\n  int error = -1;\n  created_by = NULL;\n\n  dwg->opts |= (loglevel | DWG_OPTS_INJSON);\n  dat->opts |= (loglevel | DWG_OPTS_INJSON);\n  loglevel = dwg->opts & 0xf;\n  if (dat->fh && (!dat->chain || !*dat->chain))\n    {\n      error = dat_read_stream (dat, dat->fh);\n      if (error >= DWG_ERR_CRITICAL)\n        return error;\n      LOG_TRACE (\"  json file size: %\" PRIuSIZE \"\\n\", dat->size);\n    }\n  g_dat = dat;\n\n  jsmn_init (&parser);\n  // How big will it be? This is the max. memory variant.\n  // we could also use less, see jsmn/examples/jsondump.c for small devices.\n  tokens.num_tokens\n      = jsmn_parse (&parser, (char *)dat->chain, dat->size, NULL, 0);\n  if (tokens.num_tokens <= 0)\n    {\n      const long remaining = (long)(dat->size - parser.pos);\n      if (parser.pos > 10 && remaining > 10)\n        {\n          char err[21];\n          memcpy (&err, &dat->chain[parser.pos - 10], 20);\n          err[20] = 0;\n          LOG_ERROR (\"Invalid json. jsmn error at pos: %u (... %s ...)\",\n                     parser.pos, err);\n        }\n      else\n        {\n          LOG_ERROR (\"Invalid json. jsmn error at pos: %u (%.*s ...)\",\n                     parser.pos, (int)remaining, &dat->chain[parser.pos]);\n        }\n      return DWG_ERR_INVALIDDWG;\n    }\n  LOG_TRACE (\"  num_tokens: %ld\\n\", tokens.num_tokens);\n  tokens.tokens\n      = (jsmntok_t *)calloc (tokens.num_tokens + 1024, sizeof (jsmntok_t));\n  if (!tokens.tokens)\n    return DWG_ERR_OUTOFMEM;\n\n  dwg->object_map = hash_new (tokens.num_tokens / 50);\n  if (!dwg->object_map) // we are obviously on a tiny system\n    {\n      dwg->object_map = hash_new (1024);\n      if (!dwg->object_map)\n        {\n          LOG_ERROR (\"Out of memory\");\n          json_free_globals (&tokens);\n          return DWG_ERR_OUTOFMEM;\n        }\n    }\n  dwg->dirty_refs = 1;\n  // set the target version earlier (than e.g. in DXF)\n  // we cannot write DWG >= R_2004 yet. avoid widestrings for now\n  /* if (!dwg->header.version)\n    dwg->header.version = dat->version = R_2000;\n  */\n  dat->version = R_2000;\n\n  jsmn_init (&parser); // reset pos to 0\n  error = jsmn_parse (&parser, (char *)dat->chain, dat->size, tokens.tokens,\n                      (unsigned int)tokens.num_tokens);\n  if (error < 0)\n    {\n      const long remaining = (long)(dat->size - parser.pos);\n      if (parser.pos > 10 && remaining > 10)\n        {\n          char err[21];\n          memcpy (&err, &dat->chain[parser.pos - 10], 20);\n          err[20] = 0;\n          LOG_ERROR (\"Invalid json. jsmn error %d at the %u-th token, pos: %u \"\n                     \"(... %s ...)\",\n                     error, parser.toknext, parser.pos, err);\n        }\n      else\n        {\n          LOG_ERROR (\"Invalid json. jsmn error %d at the %u-th token, pos: %u \"\n                     \"(%.*s ...)\",\n                     error, parser.toknext, parser.pos, (int)remaining,\n                     &dat->chain[parser.pos]);\n        }\n      json_free_globals (&tokens);\n      return DWG_ERR_INVALIDDWG;\n    }\n\n  if (tokens.tokens[0].type != JSMN_OBJECT)\n    {\n      fprintf (stderr, \"First JSON element is not an object/hash\\n\");\n      json_free_globals (&tokens);\n      return DWG_ERR_INVALIDDWG;\n    }\n\n  // valid first level tokens:\n  // created_by: string\n  // section objects: FILEHEADER, HEADER, THUMBNAILIMAGE, R2004_Header,\n  //                  SummaryInfo, AppInfo,\n  //                  AppInfoHistory, FileDepList, Security, RevHistory,\n  //                  ObjFreeSpace, Template,\n  //                  AuxHeader, SecondHeader\n  // section arrays: CLASSES, OBJECTS, HANDLES\n  error = 0;\n  for (tokens.index = 1; tokens.index < (unsigned int)tokens.num_tokens;\n       tokens.index++)\n    {\n      char key[80];\n      const jsmntok_t *t = &tokens.tokens[tokens.index];\n      const int len = t->end - t->start;\n\n      if (t->type == JSMN_UNDEFINED)\n        break;\n      if (t->type != JSMN_STRING)\n        {\n          LOG_ERROR (\"Unexpected JSON key at %u of %ld tokens, got %s\",\n                     tokens.index, tokens.num_tokens, t_typename[t->type]);\n          json_free_globals (&tokens);\n          return DWG_ERR_INVALIDDWG;\n        }\n      if (len >= 80)\n        {\n          LOG_ERROR (\"Unknown JSON key at %u of %ld tokens, len %d > 80\",\n                     tokens.index, tokens.num_tokens, len);\n          json_free_globals (&tokens);\n          return DWG_ERR_INVALIDDWG;\n        }\n      memcpy (key, &dat->chain[t->start], len);\n      key[len] = '\\0';\n      tokens.index++;\n      if (tokens.index > (unsigned int)tokens.num_tokens)\n        {\n          LOG_ERROR (\"Unexpected end of JSON at %u of %ld tokens %s:%d\",\n                     tokens.index, tokens.num_tokens, __FILE__, __LINE__);\n          json_free_globals (&tokens);\n          return DWG_ERR_INVALIDDWG;\n        }\n      if (strEQc (key, \"created_by\"))\n        error |= json_created_by (dat, dwg, &tokens);\n      else if (strEQc (key, \"FILEHEADER\"))\n        error |= json_FILEHEADER (dat, dwg, &tokens);\n      else if (strEQc (key, \"HEADER\"))\n        error |= json_HEADER (dat, dwg, &tokens);\n      else if (strEQc (key, \"CLASSES\"))\n        error |= json_CLASSES (dat, dwg, &tokens);\n      else if (strEQc (key, \"OBJECTS\"))\n        error |= json_OBJECTS (dat, dwg, &tokens);\n      else if (strEQc (key, \"THUMBNAILIMAGE\"))\n        error |= json_THUMBNAILIMAGE (dat, dwg, &tokens);\n      else if (strEQc (key, \"AuxHeader\"))\n        error |= json_AuxHeader (dat, dwg, &tokens);\n      else if (strEQc (key, \"SecondHeader\"))\n        error |= json_SecondHeader (dat, dwg, &tokens);\n      else if (strEQc (key, \"R2004_Header\"))\n        error |= json_R2004_Header (dat, dwg, &tokens);\n      else if (strEQc (key, \"R2007_Header\"))\n        error |= json_R2007_Header (dat, dwg, &tokens);\n      else if (strEQc (key, \"SummaryInfo\"))\n        error |= json_SummaryInfo (dat, dwg, &tokens);\n      else if (strEQc (key, \"VBAProject\"))\n        error |= json_VBAProject (dat, dwg, &tokens);\n      else if (strEQc (key, \"AppInfo\"))\n        error |= json_AppInfo (dat, dwg, &tokens);\n      else if (strEQc (key, \"AppInfoHistory\"))\n        error |= json_AppInfoHistory (dat, dwg, &tokens);\n      else if (strEQc (key, \"FileDepList\"))\n        error |= json_FileDepList (dat, dwg, &tokens);\n      else if (strEQc (key, \"Security\"))\n        error |= json_Security (dat, dwg, &tokens);\n      else if (strEQc (key, \"RevHistory\"))\n        error |= json_RevHistory (dat, dwg, &tokens);\n      else if (strEQc (key, \"ObjFreeSpace\"))\n        error |= json_ObjFreeSpace (dat, dwg, &tokens);\n      else if (strEQc (key, \"AcDs\"))\n        error |= json_AcDs (dat, dwg, &tokens);\n      else if (strEQc (key, \"Template\"))\n        error |= json_Template (dat, dwg, &tokens);\n      /* Only in json early versions <0.11 */\n      else if (strEQc (key, \"HANDLES\"))\n        error |= json_HANDLES (dat, dwg, &tokens);\n      else\n        {\n          LOG_ERROR (\"Unexpected JSON key %s at %u of %ld tokens. %s:%d\", key,\n                     tokens.index, tokens.num_tokens, __FUNCTION__, __LINE__);\n          LOG_TRACE (\"\\n\")\n          json_free_globals (&tokens);\n          return error | DWG_ERR_INVALIDTYPE;\n        }\n      if (error >= DWG_ERR_CRITICAL)\n        {\n          LOG_TRACE (\"\\n\")\n          json_free_globals (&tokens);\n          return error;\n        }\n    }\n\n  LOG_TRACE (\"\\n\")\n  if (dat->version <= R_2000 && dwg->header.from_version > R_2000)\n    dwg_fixup_BLOCKS_entities (dwg);\n\n  json_free_globals (&tokens);\n  created_by = NULL;\n  return error;\n}\n\n\n// target function\nstatic int\njson_HEADER (Bit_Chain *restrict dat, Dwg_Data *restrict dwg,\n             jsmntokens_t *restrict tokens)\n{\n  const char *section = \"HEADER\";\n  const char *name = section;\n  jsmntok_t *t = &tokens->tokens[tokens->index];\n  // Dwg_Header_Variables *_obj = &dwg->header_vars;\n  Dwg_Object *obj = NULL;\n  int size = t->size;\n\n  if (t->type != JSMN_OBJECT)\n    {\n      LOG_ERROR (\"Unexpected %s at %u of %ld tokens, expected %s OBJECT\",\n                 t_typename[t->type], tokens->index, tokens->num_tokens,\n                 section);\n      json_advance_unknown (dat, tokens, t->type, 0);\n      return DWG_ERR_INVALIDTYPE;\n    }\n  LOG_TRACE (\"\\n%s pos:%d [%d keys]\\n--------------------\\n\", section,\n             tokens->index, t->size);\n  tokens->index++;\n  for (int i = 0; i < size; i++)\n    {\n      char key[80];\n      Dwg_DYNAPI_field *f;\n\n      json_fixed_key (key, dat, tokens);\n      JSON_TOKENS_CHECK_OVERFLOW_ERR\n      t = &tokens->tokens[tokens->index];\n      f = (Dwg_DYNAPI_field *)dwg_dynapi_header_field (key);\n      if (!f)\n        {\n          if (t->type == JSMN_ARRAY && strEQc (key, \"layer_colors\"))\n            {\n              tokens->index++;\n              for (int index = 0; index < MAX (t->size, 128); index++)\n                {\n                  dwg->header_vars.layer_colors[index]\n                      = (BITCODE_RS)json_long (dat, tokens);\n                  LOG_TRACE (\"%s: \" FORMAT_RS \" [RS]\\n\", key,\n                             dwg->header_vars.layer_colors[index]);\n                }\n              JSON_TOKENS_CHECK_OVERFLOW_ERR;\n            }\n          else\n            {\n              LOG_WARN (\"Unknown key HEADER.%s\", key)\n              json_advance_unknown (dat, tokens, t->type, 0);\n              continue;\n            }\n        }\n      else if (t->type == JSMN_PRIMITIVE\n               && (strEQc (f->type, \"BD\") || strEQc (f->type, \"RD\")))\n        {\n          double num = json_float (dat, tokens);\n          LOG_TRACE (\"%s: \" FORMAT_RD \" [%s]\\n\", key, num, f->type)\n          dwg_dynapi_header_set_value (dwg, key, &num, 0);\n        }\n      else if (t->type == JSMN_PRIMITIVE\n               && f->size <= 4  // not a RS[]\n               && (strEQc (f->type, \"RC\") || strEQc (f->type, \"B\")\n                   || strEQc (f->type, \"BB\") || strEQc (f->type, \"RS\")\n                   || strEQc (f->type, \"BS\") || strEQc (f->type, \"RL\")\n                   || strEQc (f->type, \"BL\") || strEQc (f->type, \"RSd\")\n                   || strEQc (f->type, \"BLd\") || strEQc (f->type, \"BSd\")))\n        {\n          long num = json_long (dat, tokens);\n          LOG_TRACE (\"%s: %ld [%s]\\n\", key, num, f->type)\n          dwg_dynapi_header_set_value (dwg, key, &num, 0);\n        }\n      else if (t->type == JSMN_PRIMITIVE\n               && f->size == 8 // not a RLL[]\n               && (strEQc (f->type, \"RLL\") || strEQc (f->type, \"BLL\")))\n        {\n          uint64_t num = json_longlong (dat, tokens);\n          LOG_TRACE (\"%s: \" FORMAT_RLL \" [%s]\\n\", key, num, f->type)\n          dwg_dynapi_header_set_value (dwg, key, &num, 0);\n        }\n      else if (t->type == JSMN_STRING\n               && (strEQc (f->type, \"TV\") || strEQc (f->type, \"T\")))\n        {\n          size_t len;\n          char *str = json_string (dat, tokens);\n          LOG_TRACE (\"%s: \\\"%s\\\" [%s]\\n\", key, str, f->type);\n          if (dwg->header.version < R_13b1 && strEQc (key, \"MENU\")\n              && (len = strlen (str) > 15))\n            { // split into MENU + MENUEXT\n              strncpy ((char *)dwg->header_vars.MENUEXT, &str[15], 45);\n              str[15] = '\\0';\n              dwg->header_vars.MENU = strdup (str);\n              dwg->header_vars.MENUEXT[45] = '\\0';\n            }\n          else\n            dwg_dynapi_header_set_value (dwg, key, &str, 1);\n          free (str);\n        }\n      else if (t->type == JSMN_ARRAY\n               && (strEQc (f->type, \"3BD\") || strEQc (f->type, \"3RD\")\n                   || strEQc (f->type, \"3DPOINT\") || strEQc (f->type, \"BE\")\n                   || strEQc (f->type, \"3BD_1\")))\n        {\n          BITCODE_3DPOINT pt;\n          json_3DPOINT (dat, tokens, name, key, f->type, &pt);\n          dwg_dynapi_header_set_value (dwg, key, &pt, 1);\n        }\n      else if (t->type == JSMN_ARRAY\n               && (strEQc (f->type, \"2BD\") || strEQc (f->type, \"2RD\")\n                   || strEQc (f->type, \"2DPOINT\")\n                   || strEQc (f->type, \"2BD_1\")))\n        {\n          BITCODE_2DPOINT pt;\n          json_2DPOINT (dat, tokens, name, key, f->type, &pt);\n          dwg_dynapi_header_set_value (dwg, key, &pt, 1);\n        }\n      else if (t->type == JSMN_ARRAY\n               && (strEQc (f->type, \"BS\") || strEQc (f->type, \"RS\")))\n        {\n          int size1 = t->size;\n          BITCODE_BS *nums = (BITCODE_BS *)calloc (f->size, 1);\n          tokens->index++;\n          // fail if not malloced or inlined array (but json has an array)\n          if (f->size <= 2 && size1 > 1)\n            {\n              LOG_ERROR (\"Invalid JSON: HEADER.%s array where primitive expected\",\n                         f->name);\n              free (nums);\n              tokens->index += size1;\n              return 0;\n            }\n          for (int k = 0; k < size1; k++)\n            {\n              JSON_TOKENS_CHECK_OVERFLOW_ERR\n              nums[k] = (BITCODE_BS)json_long (dat, tokens);\n              LOG_TRACE (\"%s.%s[%d]: \" FORMAT_BS \" [%s]\\n\", name, key, k,\n                         nums[k], f->type);\n            }\n          if (!size1)\n            LOG_TRACE (\"%s.%s: [%s] empty\\n\", name, key, f->type);\n          if (!f->is_malloc)\n            {\n              dwg_dynapi_header_set_value (dwg, key, nums, 1);\n              free (nums);\n            }\n          else\n            dwg_dynapi_header_set_value (dwg, key, &nums, 1);\n        }\n      else if (strEQc (f->type, \"TIMEBLL\") || strEQc (f->type, \"TIMERLL\"))\n        {\n          BITCODE_TIMEBLL date = { 0 };\n          json_TIMEBLL (dat, tokens, key, &date);\n          dwg_dynapi_header_set_value (dwg, key, &date, 0);\n        }\n      else if (strEQc (f->type, \"CMC\"))\n        {\n          BITCODE_CMC color = { 0 };\n          json_CMC (dat, dwg, tokens, name, key, &color);\n          dwg_dynapi_header_set_value (dwg, key, &color, 0);\n        }\n      else if (t->type == JSMN_ARRAY && strEQc (f->type, \"H\"))\n        {\n          BITCODE_H hdl\n              = json_HANDLE (dat, dwg, tokens, section, key, NULL, -1);\n          if (hdl)\n            dwg_dynapi_header_set_value (dwg, key, &hdl, 0);\n        }\n      //...\n      else if (t->type == JSMN_OBJECT && strEQc (key, \"CLASSES\"))\n        {\n          LOG_WARN (\"Unexpected next section %s\", key)\n          tokens->index--;\n          tokens->index--;\n          return 0;\n        }\n      else\n        {\n          LOG_WARN (\"Unhandled %s [%s] with %s\", key, f->type,\n                    t_typename[t->type])\n          tokens->index++;\n          continue;\n        }\n    }\n  LOG_TRACE (\"End of %s\\n\", section)\n  // the key\n  tokens->index--;\n  return 0;\n}\n",
    "target": 1,
    "idx": 1066046,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "// context\nint ndlz4_decompress(const uint8_t *input, int32_t input_len, uint8_t *output, int32_t output_len,\n                    uint8_t meta, blosc2_dparams *dparams) {\n  BLOSC_UNUSED_PARAM(meta);\n  BLOSC_UNUSED_PARAM(dparams);\n\n  uint8_t* ip = (uint8_t*)input;\n  uint8_t* ip_limit = ip + input_len;\n  uint8_t* op = (uint8_t*)output;\n  uint8_t ndim;\n  uint32_t blockshape[2];\n  uint32_t eshape[2];\n  uint8_t* buffercpy;\n  uint8_t local_buffer[16];\n  uint8_t token;\n  if (NDLZ_UNEXPECT_CONDITIONAL(input_len < 8)) {\n    return 0;\n  }\n\n  /* we start with literal copy */\n  ndim = *ip;\n  ip ++;\n  if (ndim != 2) {\n    fprintf(stderr, \"This codec only works for ndim = 2\");\n    return -1;\n  }\n  memcpy(&blockshape[0], ip, 4);\n  ip += 4;\n  memcpy(&blockshape[1], ip, 4);\n  ip += 4;\n  eshape[0] = ((blockshape[0] + 3) / 4) * 4;\n  eshape[1] = ((blockshape[1] + 3) / 4) * 4;\n\n  if (NDLZ_UNEXPECT_CONDITIONAL(output_len < blockshape[0] * blockshape[1])) {\n    return 0;\n  }\n  memset(op, 0, blockshape[0] * blockshape[1]);\n\n  uint32_t i_stop[2];\n  for (int i = 0; i < 2; ++i) {\n    i_stop[i] = eshape[i] / 4;\n  }\n\n\n  /* main loop */\n  uint32_t ii[2];\n  uint32_t padding[2];\n  uint32_t ind;\n  uint8_t cell_aux[16];\n  for (ii[0] = 0; ii[0] < i_stop[0]; ++ii[0]) {\n    for (ii[1] = 0; ii[1] < i_stop[1]; ++ii[1]) {      // for each cell\n      if (NDLZ_UNEXPECT_CONDITIONAL(ip > ip_limit)) {\n        printf(\"Literal copy \\n\");\n        return 0;\n      }\n      if (ii[0] == i_stop[0] - 1) {\n        padding[0] = (blockshape[0] % 4 == 0) ? 4 : blockshape[0] % 4;\n      } else {\n        padding[0] = 4;\n      }\n      if (ii[1] == i_stop[1] - 1) {\n        padding[1] = (blockshape[1] % 4 == 0) ? 4 : blockshape[1] % 4;\n      } else {\n        padding[1] = 4;\n      }\n      token = *ip++;\n      if (token == 0){    // no match\n        buffercpy = ip;\n        ip += padding[0] * padding[1];\n      } else if (token == (uint8_t)((1U << 7U) | (1U << 6U))) {  // cell match\n        uint16_t offset = *((uint16_t*) ip);\n        buffercpy = ip - offset - 1;\n        ip += 2;\n      } else if (token == (uint8_t)(1U << 6U)) { // whole cell of same element\n        buffercpy = cell_aux;\n        memset(buffercpy, *ip, 16);\n        ip++;\n      } else if (token >= 224) { // three rows match\n        buffercpy = local_buffer;\n        uint16_t offset = *((uint16_t*) ip);\n        offset += 3;\n        ip += 2;\n        int i, j, k;\n        if ((token >> 3U) == 28) {\n          i = 1;\n          j = 2;\n          k = 3;\n        } else {\n          i = 0;\n          if ((token >> 3U) < 30) {\n            j = 1;\n            k = 2;\n          } else {\n            k = 3;\n            if ((token >> 3U) == 30) {\n              j = 1;\n            } else {\n              j = 2;\n            }\n          }\n        }\n        memcpy(&buffercpy[i * 4], ip - offset, 4);\n        memcpy(&buffercpy[j * 4], ip - offset + 4, 4);\n        memcpy(&buffercpy[k * 4], ip - offset + 8, 4);\n        for (int l = 0; l < 4; l++) {\n          if ((l != i) && (l != j) && (l != k)) {\n            memcpy(&buffercpy[l * 4], ip, 4);\n            ip += 4;\n            break;\n          }\n        }\n\n      } else if ((token >= 128) && (token <= 191)){ // rows pair match\n        buffercpy = local_buffer;\n        uint16_t offset = *((uint16_t*) ip);\n        offset += 3;\n        ip += 2;\n        int i, j;\n        if (token == 128) {\n          i = 2;\n          j = 3;\n        } else {\n          i = (token - 128) >> 5U;\n          j = ((token - 128) >> 3U) - (i << 2U);\n        }\n        memcpy(&buffercpy[i * 4], ip - offset, 4);\n        memcpy(&buffercpy[j * 4], ip - offset + 4, 4);\n        for (int k = 0; k < 4; k++) {\n          if ((k != i) && (k != j)) {\n            memcpy(&buffercpy[k * 4], ip, 4);\n            ip += 4;\n          }\n        }\n      } else if ((token >= 40) && (token <= 63)) {  // 2 rows pair matches\n        buffercpy = local_buffer;\n        uint16_t offset_1 = *((uint16_t*) ip);\n        offset_1 += 5;\n        ip += 2;\n        uint16_t offset_2 = *((uint16_t*) ip);\n        offset_2 += 5;\n        ip += 2;\n        int i, j, k, l, m;\n        i = 0;\n        j = ((token - 32) >> 3U);\n        l = -1;\n        for (k = 1; k < 4; k++) {\n          if ((k != i) && (k != j)) {\n            if (l == -1) {\n              l = k;\n            } else {\n              m = k;\n            }\n          }\n        }\n        memcpy(&buffercpy[i * 4], ip - offset_1, 4);\n        memcpy(&buffercpy[j * 4], ip - offset_1 + 4, 4);\n        memcpy(&buffercpy[l * 4], ip - offset_2, 4);\n        memcpy(&buffercpy[m * 4], ip - offset_2 + 4, 4);\n\n      } else {\n        printf(\"Invalid token: %u at cell [%d, %d]\\n\", token, ii[0], ii[1]);\n        return 0;\n      }\n      // fill op with buffercpy\n      uint32_t orig = ii[0] * 4 * blockshape[1] + ii[1] * 4;\n      for (uint32_t i = 0; i < 4; i++) {\n        if (i < padding[0]) {\n          ind = orig + i * blockshape[1];\n          memcpy(&op[ind], buffercpy, padding[1]);\n        }\n        buffercpy += padding[1];\n      }\n      if (ind > (uint32_t) output_len) {\n        printf(\"Output size is bigger than max \\n\");\n        return 0;\n      }\n    }\n  }\n  ind += padding[1];\n\n  if (ind != (blockshape[0] * blockshape[1])) {\n    printf(\"Output size is not compatible with embedded blockshape \\n\");\n    return 0;\n  }\n  if (ind > (uint32_t) output_len) {\n    printf(\"Output size is bigger than max \\n\");\n    return 0;\n  }\n\n  return (int)ind;\n}\n\nstatic int blosc_d(\n    struct thread_context* thread_context, int32_t bsize,\n    int32_t leftoverblock, bool memcpyed, const uint8_t* src, int32_t srcsize, int32_t src_offset,\n    int32_t nblock, uint8_t* dest, int32_t dest_offset, uint8_t* tmp, uint8_t* tmp2) {\n  blosc2_context* context = thread_context->parent_context;\n  uint8_t* filters = context->filters;\n  uint8_t *tmp3 = thread_context->tmp4;\n  int32_t compformat = (context->header_flags & (uint8_t)0xe0) >> 5u;\n  int dont_split = (context->header_flags & 0x10) >> 4;\n  int32_t chunk_nbytes;\n  int32_t chunk_cbytes;\n  int nstreams;\n  int32_t neblock;\n  int32_t nbytes;                /* number of decompressed bytes in split */\n  int32_t cbytes;                /* number of compressed bytes in split */\n  int32_t ctbytes = 0;           /* number of compressed bytes in block */\n  int32_t ntbytes = 0;           /* number of uncompressed bytes in block */\n  uint8_t* _dest;\n  int32_t typesize = context->typesize;\n  bool instr_codec = context->blosc2_flags & BLOSC2_INSTR_CODEC;\n  const char* compname;\n  int rc;\n\n  rc = blosc2_cbuffer_sizes(src, &chunk_nbytes, &chunk_cbytes, NULL);\n  if (rc < 0) {\n    return rc;\n  }\n\n  if (context->block_maskout != NULL && context->block_maskout[nblock]) {\n    // Do not decompress, but act as if we successfully decompressed everything\n    return bsize;\n  }\n\n  // In some situations (lazychunks) the context can arrive uninitialized\n  // (but BITSHUFFLE needs it for accessing the format of the chunk)\n  if (context->src == NULL) {\n    context->src = src;\n  }\n\n  // Chunks with special values cannot be lazy\n  bool is_lazy = ((context->header_overhead == BLOSC_EXTENDED_HEADER_LENGTH) &&\n          (context->blosc2_flags & 0x08u) && !context->special_type);\n  if (is_lazy) {\n    // The chunk is on disk, so just lazily load the block\n    if (context->schunk == NULL) {\n      BLOSC_TRACE_ERROR(\"Lazy chunk needs an associated super-chunk.\");\n      return BLOSC2_ERROR_INVALID_PARAM;\n    }\n    if (context->schunk->frame == NULL) {\n      BLOSC_TRACE_ERROR(\"Lazy chunk needs an associated frame.\");\n      return BLOSC2_ERROR_INVALID_PARAM;\n    }\n    blosc2_frame_s* frame = (blosc2_frame_s*)context->schunk->frame;\n    char* urlpath = frame->urlpath;\n    size_t trailer_offset = BLOSC_EXTENDED_HEADER_LENGTH + context->nblocks * sizeof(int32_t);\n    int32_t nchunk;\n    int64_t chunk_offset;\n    // The nchunk and the offset of the current chunk are in the trailer\n    nchunk = *(int32_t*)(src + trailer_offset);\n    chunk_offset = *(int64_t*)(src + trailer_offset + sizeof(int32_t));\n    // Get the csize of the nblock\n    int32_t *block_csizes = (int32_t *)(src + trailer_offset + sizeof(int32_t) + sizeof(int64_t));\n    int32_t block_csize = block_csizes[nblock];\n    // Read the lazy block on disk\n    void* fp = NULL;\n    blosc2_io_cb *io_cb = blosc2_get_io_cb(context->schunk->storage->io->id);\n    if (io_cb == NULL) {\n      BLOSC_TRACE_ERROR(\"Error getting the input/output API\");\n      return BLOSC2_ERROR_PLUGIN_IO;\n    }\n\n    if (frame->sframe) {\n      // The chunk is not in the frame\n      char* chunkpath = malloc(strlen(frame->urlpath) + 1 + 8 + strlen(\".chunk\") + 1);\n      BLOSC_ERROR_NULL(chunkpath, BLOSC2_ERROR_MEMORY_ALLOC);\n      sprintf(chunkpath, \"%s/%08X.chunk\", frame->urlpath, nchunk);\n      fp = io_cb->open(chunkpath, \"rb\", context->schunk->storage->io->params);\n      free(chunkpath);\n      // The offset of the block is src_offset\n      io_cb->seek(fp, src_offset, SEEK_SET);\n    }\n    else {\n      fp = io_cb->open(urlpath, \"rb\", context->schunk->storage->io->params);\n      // The offset of the block is src_offset\n      io_cb->seek(fp, chunk_offset + src_offset, SEEK_SET);\n    }\n    // We can make use of tmp3 because it will be used after src is not needed anymore\n    int64_t rbytes = io_cb->read(tmp3, 1, block_csize, fp);\n    io_cb->close(fp);\n    if ((int32_t)rbytes != block_csize) {\n      BLOSC_TRACE_ERROR(\"Cannot read the (lazy) block out of the fileframe.\");\n      return BLOSC2_ERROR_READ_BUFFER;\n    }\n    src = tmp3;\n    src_offset = 0;\n    srcsize = block_csize;\n  }\n\n  // If the chunk is memcpyed, we just have to copy the block to dest and return\n  if (memcpyed) {\n    int bsize_ = leftoverblock ? chunk_nbytes % context->blocksize : bsize;\n    if (!context->special_type) {\n      if (chunk_nbytes + context->header_overhead != chunk_cbytes) {\n        return BLOSC2_ERROR_WRITE_BUFFER;\n      }\n      if (chunk_cbytes < context->header_overhead + (nblock * context->blocksize) + bsize_) {\n        /* Not enough input to copy block */\n        return BLOSC2_ERROR_READ_BUFFER;\n      }\n    }\n    if (!is_lazy) {\n      src += context->header_overhead + nblock * context->blocksize;\n    }\n    _dest = dest + dest_offset;\n    if (context->postfilter != NULL) {\n      // We are making use of a postfilter, so use a temp for destination\n      _dest = tmp;\n    }\n    rc = 0;\n    switch (context->special_type) {\n      case BLOSC2_SPECIAL_VALUE:\n        // All repeated values\n        rc = set_values(context->typesize, context->src, _dest, bsize_);\n        if (rc < 0) {\n          BLOSC_TRACE_ERROR(\"set_values failed\");\n          return BLOSC2_ERROR_DATA;\n        }\n        break;\n      case BLOSC2_SPECIAL_NAN:\n        rc = set_nans(context->typesize, _dest, bsize_);\n        if (rc < 0) {\n          BLOSC_TRACE_ERROR(\"set_nans failed\");\n          return BLOSC2_ERROR_DATA;\n        }\n        break;\n      case BLOSC2_SPECIAL_ZERO:\n        memset(_dest, 0, bsize_);\n        break;\n      case BLOSC2_SPECIAL_UNINIT:\n        // We do nothing here\n        break;\n      default:\n        memcpy(_dest, src, bsize_);\n    }\n    if (context->postfilter != NULL) {\n      // Create new postfilter parameters for this block (must be private for each thread)\n      blosc2_postfilter_params postparams;\n      memcpy(&postparams, context->postparams, sizeof(postparams));\n      postparams.in = tmp;\n      postparams.out = dest + dest_offset;\n      postparams.size = bsize;\n      postparams.typesize = typesize;\n      postparams.offset = nblock * context->blocksize;\n      postparams.nchunk = context->schunk != NULL ? context->schunk->current_nchunk : -1;\n      postparams.nblock = nblock;\n      postparams.tid = thread_context->tid;\n      postparams.ttmp = thread_context->tmp;\n      postparams.ttmp_nbytes = thread_context->tmp_nbytes;\n      postparams.ctx = context;\n\n      // Execute the postfilter (the processed block will be copied to dest)\n      if (context->postfilter(&postparams) != 0) {\n        BLOSC_TRACE_ERROR(\"Execution of postfilter function failed\");\n        return BLOSC2_ERROR_POSTFILTER;\n      }\n    }\n    context->zfp_cell_nitems = 0;\n    return bsize_;\n  }\n\n  if (!is_lazy && (src_offset <= 0 || src_offset >= srcsize)) {\n    /* Invalid block src offset encountered */\n    return BLOSC2_ERROR_DATA;\n  }\n\n  src += src_offset;\n  srcsize -= src_offset;\n\n  int last_filter_index = last_filter(filters, 'd');\n  if (instr_codec) {\n    // If instrumented, we don't want to run the filters\n    _dest = dest + dest_offset;\n  }\n  else if (((last_filter_index >= 0) &&\n       (next_filter(filters, BLOSC2_MAX_FILTERS, 'd') != BLOSC_DELTA)) ||\n    context->postfilter != NULL) {\n    // We are making use of some filter, so use a temp for destination\n    _dest = tmp;\n  }\n  else {\n    // If no filters, or only DELTA in pipeline\n    _dest = dest + dest_offset;\n  }\n\n  /* The number of compressed data streams for this block */\n  if (!dont_split && !leftoverblock && !context->use_dict) {\n    // We don't want to split when in a training dict state\n    nstreams = (int32_t)typesize;\n  }\n  else {\n    nstreams = 1;\n  }\n\n  neblock = bsize / nstreams;\n  if (neblock == 0) {\n    /* Not enough space to output bytes */\n    return -1;\n  }\n  for (int j = 0; j < nstreams; j++) {\n    if (srcsize < (signed)sizeof(int32_t)) {\n      /* Not enough input to read compressed size */\n      return BLOSC2_ERROR_READ_BUFFER;\n    }\n    srcsize -= sizeof(int32_t);\n    cbytes = sw32_(src);      /* amount of compressed bytes */\n    if (cbytes > 0) {\n      if (srcsize < cbytes) {\n        /* Not enough input to read compressed bytes */\n        return BLOSC2_ERROR_READ_BUFFER;\n      }\n      srcsize -= cbytes;\n    }\n    src += sizeof(int32_t);\n    ctbytes += (signed)sizeof(int32_t);\n\n    /* Uncompress */\n    if (cbytes == 0) {\n      // A run of 0's\n      memset(_dest, 0, (unsigned int)neblock);\n      nbytes = neblock;\n    }\n    else if (cbytes < 0) {\n      // A negative number means some encoding depending on the token that comes next\n      uint8_t token;\n\n      if (srcsize < (signed)sizeof(uint8_t)) {\n        // Not enough input to read token */\n        return BLOSC2_ERROR_READ_BUFFER;\n      }\n      srcsize -= sizeof(uint8_t);\n\n      token = src[0];\n      src += 1;\n      ctbytes += 1;\n\n      if (token & 0x1) {\n        // A run of bytes that are different than 0\n        if (cbytes < -255) {\n          // Runs can only encode a byte\n          return BLOSC2_ERROR_RUN_LENGTH;\n        }\n        uint8_t value = -cbytes;\n        memset(_dest, value, (unsigned int)neblock);\n      } else {\n        BLOSC_TRACE_ERROR(\"Invalid or unsupported compressed stream token value - %d\", token);\n        return BLOSC2_ERROR_RUN_LENGTH;\n      }\n      nbytes = neblock;\n      cbytes = 0;  // everything is encoded in the cbytes token\n    }\n    else if (cbytes == neblock) {\n      memcpy(_dest, src, (unsigned int)neblock);\n      nbytes = (int32_t)neblock;\n    }\n    else {\n      if (compformat == BLOSC_BLOSCLZ_FORMAT) {\n        nbytes = blosclz_decompress(src, cbytes, _dest, (int)neblock);\n      }\n      else if (compformat == BLOSC_LZ4_FORMAT) {\n        nbytes = lz4_wrap_decompress((char*)src, (size_t)cbytes,\n                                     (char*)_dest, (size_t)neblock);\n      }\n  #if defined(HAVE_ZLIB)\n      else if (compformat == BLOSC_ZLIB_FORMAT) {\n        nbytes = zlib_wrap_decompress((char*)src, (size_t)cbytes,\n                                      (char*)_dest, (size_t)neblock);\n      }\n  #endif /*  HAVE_ZLIB */\n  #if defined(HAVE_ZSTD)\n      else if (compformat == BLOSC_ZSTD_FORMAT) {\n        nbytes = zstd_wrap_decompress(thread_context,\n                                      (char*)src, (size_t)cbytes,\n                                      (char*)_dest, (size_t)neblock);\n      }\n  #endif /*  HAVE_ZSTD */\n      else if (compformat == BLOSC_UDCODEC_FORMAT) {\n        bool getcell = false;\n\n#if defined(HAVE_PLUGINS)\n        if ((context->compcode == BLOSC_CODEC_ZFP_FIXED_RATE) && (context->zfp_cell_nitems > 0)) {\n          nbytes = zfp_getcell(context, src, cbytes, _dest, neblock);\n          if (nbytes < 0) {\n            return BLOSC2_ERROR_DATA;\n          }\n          if (nbytes == context->zfp_cell_nitems * typesize) {\n            getcell = true;\n          }\n        }\n#endif /* HAVE_PLUGINS */\n        if (!getcell) {\n          context->zfp_cell_nitems = 0;\n          for (int i = 0; i < g_ncodecs; ++i) {\n            if (g_codecs[i].compcode == context->compcode) {\n              blosc2_dparams dparams;\n              blosc2_ctx_get_dparams(context, &dparams);\n              nbytes = g_codecs[i].decoder(src,\n                                           cbytes,\n                                           _dest,\n                                           neblock,\n                                           context->compcode_meta,\n                                           &dparams,\n                                           context->src);\n              goto urcodecsuccess;\n            }\n          }\n          BLOSC_TRACE_ERROR(\"User-defined compressor codec %d not found during decompression\", context->compcode);\n          return BLOSC2_ERROR_CODEC_SUPPORT;\n        }\n      urcodecsuccess:\n        ;\n      }\n      else {\n        compname = clibcode_to_clibname(compformat);\n        BLOSC_TRACE_ERROR(\n                \"Blosc has not been compiled with decompression \"\n                \"support for '%s' format.  \"\n                \"Please recompile for adding this support.\", compname);\n        return BLOSC2_ERROR_CODEC_SUPPORT;\n      }\n\n      /* Check that decompressed bytes number is correct */\n      if ((nbytes != neblock) && (context->zfp_cell_nitems == 0)) {\n        return BLOSC2_ERROR_DATA;\n      }\n\n    }\n    src += cbytes;\n    ctbytes += cbytes;\n    _dest += nbytes;\n    ntbytes += nbytes;\n  } /* Closes j < nstreams */\n\nstatic int serial_blosc(struct thread_context* thread_context) {\n  blosc2_context* context = thread_context->parent_context;\n  int32_t j, bsize, leftoverblock;\n  int32_t cbytes;\n  int32_t ntbytes = (int32_t)context->output_bytes;\n  int32_t* bstarts = context->bstarts;\n  uint8_t* tmp = thread_context->tmp;\n  uint8_t* tmp2 = thread_context->tmp2;\n  int dict_training = context->use_dict && (context->dict_cdict == NULL);\n  bool memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;\n  if (!context->do_compress && context->special_type) {\n    // Fake a runlen as if it was a memcpyed chunk\n    memcpyed = true;\n  }\n\n  for (j = 0; j < context->nblocks; j++) {\n    if (context->do_compress && !memcpyed && !dict_training) {\n      _sw32(bstarts + j, ntbytes);\n    }\n    bsize = context->blocksize;\n    leftoverblock = 0;\n    if ((j == context->nblocks - 1) && (context->leftover > 0)) {\n      bsize = context->leftover;\n      leftoverblock = 1;\n    }\n    if (context->do_compress) {\n      if (memcpyed && !context->prefilter) {\n        /* We want to memcpy only */\n        memcpy(context->dest + context->header_overhead + j * context->blocksize,\n               context->src + j * context->blocksize, (unsigned int)bsize);\n        cbytes = (int32_t)bsize;\n      }\n      else {\n        /* Regular compression */\n        cbytes = blosc_c(thread_context, bsize, leftoverblock, ntbytes,\n                         context->destsize, context->src, j * context->blocksize,\n                         context->dest + ntbytes, tmp, tmp2);\n        if (cbytes == 0) {\n          ntbytes = 0;              /* uncompressible data */\n          break;\n        }\n      }\n    }\n    else {\n      /* Regular decompression */\n      // If memcpyed we don't have a bstarts section (because it is not needed)\n      int32_t src_offset = memcpyed ?\n          context->header_overhead + j * context->blocksize : sw32_(bstarts + j);\n      cbytes = blosc_d(thread_context, bsize, leftoverblock, memcpyed,\n                       context->src, context->srcsize, src_offset, j,\n                       context->dest, j * context->blocksize, tmp, tmp2);\n    }\n\n    if (cbytes < 0) {\n      ntbytes = cbytes;         /* error in blosc_c or blosc_d */\n      break;\n    }\n    ntbytes += cbytes;\n  }\n\n  return ntbytes;\n}\n\nstatic int do_job(blosc2_context* context) {\n  int32_t ntbytes;\n\n  /* Set sentinels */\n  context->dref_not_init = 1;\n\n  /* Check whether we need to restart threads */\n  check_nthreads(context);\n\n  /* Run the serial version when nthreads is 1 or when the buffers are\n     not larger than blocksize */\n  if (context->nthreads == 1 || (context->sourcesize / context->blocksize) <= 1) {\n    /* The context for this 'thread' has no been initialized yet */\n    if (context->serial_context == NULL) {\n      context->serial_context = create_thread_context(context, 0);\n    }\n    else if (context->blocksize != context->serial_context->tmp_blocksize) {\n      free_thread_context(context->serial_context);\n      context->serial_context = create_thread_context(context, 0);\n    }\n    BLOSC_ERROR_NULL(context->serial_context, BLOSC2_ERROR_THREAD_CREATE);\n    ntbytes = serial_blosc(context->serial_context);\n  }\n  else {\n    ntbytes = parallel_blosc(context);\n  }\n\n  return ntbytes;\n}\n\nint blosc_run_decompression_with_context(blosc2_context* context, const void* src, int32_t srcsize,\n                                         void* dest, int32_t destsize) {\n  blosc_header header;\n  int32_t ntbytes;\n  int rc;\n\n  rc = read_chunk_header(src, srcsize, true, &header);\n  if (rc < 0) {\n    return rc;\n  }\n\n  if (header.nbytes > destsize) {\n    // Not enough space for writing into the destination\n    return BLOSC2_ERROR_WRITE_BUFFER;\n  }\n\n  rc = initialize_context_decompression(context, &header, src, srcsize, dest, destsize);\n  if (rc < 0) {\n    return rc;\n  }\n\n  /* Do the actual decompression */\n  ntbytes = do_job(context);\n  if (ntbytes < 0) {\n    return ntbytes;\n  }\n\n  assert(ntbytes <= (int32_t)destsize);\n  return ntbytes;\n}\n\nint blosc2_decompress(const void* src, int32_t srcsize, void* dest, int32_t destsize) {\n  int result;\n  char* envvar;\n  long nthreads;\n  blosc2_context *dctx;\n  blosc2_dparams dparams = BLOSC2_DPARAMS_DEFAULTS;\n\n  /* Check whether the library should be initialized */\n  if (!g_initlib) blosc_init();\n\n  /* Check for a BLOSC_NTHREADS environment variable */\n  envvar = getenv(\"BLOSC_NTHREADS\");\n  if (envvar != NULL) {\n    nthreads = strtol(envvar, NULL, 10);\n    if ((nthreads != EINVAL) && (nthreads > 0)) {\n      result = blosc_set_nthreads((int16_t)nthreads);\n      if (result < 0) { return result; }\n    }\n  }\n\n  /* Check for a BLOSC_NOLOCK environment variable.  It is important\n     that this should be the last env var so that it can take the\n     previous ones into account */\n  envvar = getenv(\"BLOSC_NOLOCK\");\n  if (envvar != NULL) {\n    dparams.nthreads = g_nthreads;\n    dctx = blosc2_create_dctx(dparams);\n    result = blosc2_decompress_ctx(dctx, src, srcsize, dest, destsize);\n    blosc2_free_ctx(dctx);\n    return result;\n  }\n\n  pthread_mutex_lock(&global_comp_mutex);\n\n  result = blosc_run_decompression_with_context(\n          g_global_context, src, srcsize, dest, destsize);\n\n  pthread_mutex_unlock(&global_comp_mutex);\n\n  return result;\n}\n\n\n// target function\nint ndlz4_decompress(const uint8_t *input, int32_t input_len, uint8_t *output, int32_t output_len,\n                    uint8_t meta, blosc2_dparams *dparams) {\n  BLOSC_UNUSED_PARAM(meta);\n  BLOSC_UNUSED_PARAM(dparams);\n\n  uint8_t* ip = (uint8_t*)input;\n  uint8_t* ip_limit = ip + input_len;\n  uint8_t* op = (uint8_t*)output;\n  uint8_t ndim;\n  uint32_t blockshape[2];\n  uint32_t eshape[2];\n  uint8_t* buffercpy;\n  uint8_t local_buffer[16];\n  uint8_t token;\n  if (NDLZ_UNEXPECT_CONDITIONAL(input_len <= 0)) {\n    return 0;\n  }\n\n  /* we start with literal copy */\n  ndim = *ip;\n  ip ++;\n  if (ndim != 2) {\n    fprintf(stderr, \"This codec only works for ndim = 2\");\n    return -1;\n  }\n  memcpy(&blockshape[0], ip, 4);\n  ip += 4;\n  memcpy(&blockshape[1], ip, 4);\n  ip += 4;\n  eshape[0] = ((blockshape[0] + 3) / 4) * 4;\n  eshape[1] = ((blockshape[1] + 3) / 4) * 4;\n\n  memset(op, 0, blockshape[0] * blockshape[1]);\n\n  uint32_t i_stop[2];\n  for (int i = 0; i < 2; ++i) {\n    i_stop[i] = eshape[i] / 4;\n  }\n\n\n  /* main loop */\n  uint32_t ii[2];\n  uint32_t padding[2];\n  uint32_t ind;\n  uint8_t cell_aux[16];\n  for (ii[0] = 0; ii[0] < i_stop[0]; ++ii[0]) {\n    for (ii[1] = 0; ii[1] < i_stop[1]; ++ii[1]) {      // for each cell\n      if (NDLZ_UNEXPECT_CONDITIONAL(ip > ip_limit)) {\n        printf(\"Literal copy \\n\");\n        return 0;\n      }\n      if (ii[0] == i_stop[0] - 1) {\n        padding[0] = (blockshape[0] % 4 == 0) ? 4 : blockshape[0] % 4;\n      } else {\n        padding[0] = 4;\n      }\n      if (ii[1] == i_stop[1] - 1) {\n        padding[1] = (blockshape[1] % 4 == 0) ? 4 : blockshape[1] % 4;\n      } else {\n        padding[1] = 4;\n      }\n      token = *ip++;\n      if (token == 0){    // no match\n        buffercpy = ip;\n        ip += padding[0] * padding[1];\n      } else if (token == (uint8_t)((1U << 7U) | (1U << 6U))) {  // cell match\n        uint16_t offset = *((uint16_t*) ip);\n        buffercpy = ip - offset - 1;\n        ip += 2;\n      } else if (token == (uint8_t)(1U << 6U)) { // whole cell of same element\n        buffercpy = cell_aux;\n        memset(buffercpy, *ip, 16);\n        ip++;\n      } else if (token >= 224) { // three rows match\n        buffercpy = local_buffer;\n        uint16_t offset = *((uint16_t*) ip);\n        offset += 3;\n        ip += 2;\n        int i, j, k;\n        if ((token >> 3U) == 28) {\n          i = 1;\n          j = 2;\n          k = 3;\n        } else {\n          i = 0;\n          if ((token >> 3U) < 30) {\n            j = 1;\n            k = 2;\n          } else {\n            k = 3;\n            if ((token >> 3U) == 30) {\n              j = 1;\n            } else {\n              j = 2;\n            }\n          }\n        }\n        memcpy(&buffercpy[i * 4], ip - offset, 4);\n        memcpy(&buffercpy[j * 4], ip - offset + 4, 4);\n        memcpy(&buffercpy[k * 4], ip - offset + 8, 4);\n        for (int l = 0; l < 4; l++) {\n          if ((l != i) && (l != j) && (l != k)) {\n            memcpy(&buffercpy[l * 4], ip, 4);\n            ip += 4;\n            break;\n          }\n        }\n\n      } else if ((token >= 128) && (token <= 191)){ // rows pair match\n        buffercpy = local_buffer;\n        uint16_t offset = *((uint16_t*) ip);\n        offset += 3;\n        ip += 2;\n        int i, j;\n        if (token == 128) {\n          i = 2;\n          j = 3;\n        } else {\n          i = (token - 128) >> 5U;\n          j = ((token - 128) >> 3U) - (i << 2U);\n        }\n        memcpy(&buffercpy[i * 4], ip - offset, 4);\n        memcpy(&buffercpy[j * 4], ip - offset + 4, 4);\n        for (int k = 0; k < 4; k++) {\n          if ((k != i) && (k != j)) {\n            memcpy(&buffercpy[k * 4], ip, 4);\n            ip += 4;\n          }\n        }\n      } else if ((token >= 40) && (token <= 63)) {  // 2 rows pair matches\n        buffercpy = local_buffer;\n        uint16_t offset_1 = *((uint16_t*) ip);\n        offset_1 += 5;\n        ip += 2;\n        uint16_t offset_2 = *((uint16_t*) ip);\n        offset_2 += 5;\n        ip += 2;\n        int i, j, k, l, m;\n        i = 0;\n        j = ((token - 32) >> 3U);\n        l = -1;\n        for (k = 1; k < 4; k++) {\n          if ((k != i) && (k != j)) {\n            if (l == -1) {\n              l = k;\n            } else {\n              m = k;\n            }\n          }\n        }\n        memcpy(&buffercpy[i * 4], ip - offset_1, 4);\n        memcpy(&buffercpy[j * 4], ip - offset_1 + 4, 4);\n        memcpy(&buffercpy[l * 4], ip - offset_2, 4);\n        memcpy(&buffercpy[m * 4], ip - offset_2 + 4, 4);\n\n      } else {\n        printf(\"Invalid token: %u at cell [%d, %d]\\n\", token, ii[0], ii[1]);\n        return 0;\n      }\n      // fill op with buffercpy\n      uint32_t orig = ii[0] * 4 * blockshape[1] + ii[1] * 4;\n      for (uint32_t i = 0; i < 4; i++) {\n        if (i < padding[0]) {\n          ind = orig + i * blockshape[1];\n          memcpy(&op[ind], buffercpy, padding[1]);\n        }\n        buffercpy += padding[1];\n      }\n      if (ind > (uint32_t) output_len) {\n        printf(\"Output size is bigger than max \\n\");\n        return 0;\n      }\n    }\n  }\n  ind += padding[1];\n\n  if (ind != (blockshape[0] * blockshape[1])) {\n    printf(\"Output size is not compatible with embedded blockshape \\n\");\n    return 0;\n  }\n  if (ind > (uint32_t) output_len) {\n    printf(\"Output size is bigger than max \\n\");\n    return 0;\n  }\n\n  return (int)ind;\n}\nint ndlz8_decompress(const uint8_t *input, int32_t input_len, uint8_t *output, int32_t output_len,\n                     uint8_t meta, blosc2_dparams *dparams) {\n  BLOSC_UNUSED_PARAM(meta);\n  BLOSC_UNUSED_PARAM(dparams);\n\n  const int cell_shape = 8;\n  const int cell_size = 64;\n  uint8_t* ip = (uint8_t*)input;\n  uint8_t* ip_limit = ip + input_len;\n  uint8_t* op = (uint8_t*)output;\n  uint8_t ndim;\n  uint32_t blockshape[2];\n  uint32_t eshape[2];\n  uint8_t* buffercpy;\n  uint8_t token;\n  if (NDLZ_UNEXPECT_CONDITIONAL(input_len < 8)) {\n    return 0;\n  }\n\n  /* we start with literal copy */\n  ndim = *ip;\n  ip ++;\n  if (ndim != 2) {\n    fprintf(stderr, \"This codec only works for ndim = 2\");\n    return -1;\n  }\n  memcpy(&blockshape[0], ip, 4);\n  ip += 4;\n  memcpy(&blockshape[1], ip, 4);\n  ip += 4;\n  eshape[0] = ((blockshape[0] + 7) / cell_shape) * cell_shape;\n  eshape[1] = ((blockshape[1] + 7) / cell_shape) * cell_shape;\n\n  memset(op, 0, blockshape[0] * blockshape[1]);\n\n  uint32_t i_stop[2];\n  for (int i = 0; i < 2; ++i) {\n    i_stop[i] = eshape[i] / cell_shape;\n  }\n\n\n  /* main loop */\n  uint32_t ii[2];\n  uint32_t padding[2];\n  uint32_t ind = 0;\n  uint8_t* local_buffer = malloc(cell_size);\n  uint8_t* cell_aux = malloc(cell_size);\n  for (ii[0] = 0; ii[0] < i_stop[0]; ++ii[0]) {\n    for (ii[1] = 0; ii[1] < i_stop[1]; ++ii[1]) {      // for each cell\n      if (NDLZ_UNEXPECT_CONDITIONAL(ip > ip_limit)) {\n        printf(\"Literal copy \\n\");\n        free(local_buffer);\n        free(cell_aux);\n        return 0;\n      }\n      if (ii[0] == i_stop[0] - 1) {\n        padding[0] = (blockshape[0] % cell_shape == 0) ? cell_shape : blockshape[0] % cell_shape;\n      } else {\n        padding[0] = cell_shape;\n      }\n      if (ii[1] == i_stop[1] - 1) {\n        padding[1] = (blockshape[1] % cell_shape == 0) ? cell_shape : blockshape[1] % cell_shape;\n      } else {\n        padding[1] = cell_shape;\n      }\n      token = *ip++;\n      uint8_t match_type = (token >> 3U);\n      if (token == 0){    // no match\n        buffercpy = ip;\n        ip += padding[0] * padding[1];\n      } else if (token == (uint8_t)((1U << 7U) | (1U << 6U))) {  // cell match\n        uint16_t offset = *((uint16_t*) ip);\n        buffercpy = ip - offset - 1;\n        ip += 2;\n      } else if (token == (uint8_t)(1U << 6U)) { // whole cell of same element\n        buffercpy = cell_aux;\n        memset(buffercpy, *ip, cell_size);\n        ip++;\n      } else if (match_type == 21) {    // triple match\n        buffercpy = local_buffer;\n        int row = (int) (token & 7);\n        uint16_t offset = *((uint16_t*) ip);\n        ip += 2;\n        for (int l = 0; l < 3; l++) {\n          memcpy(&buffercpy[(row + l) * cell_shape],\n                 ip - sizeof(token) - sizeof(offset) - offset + l * cell_shape, cell_shape);\n        }\n        for (int l = 0; l < cell_shape; l++) {\n          if ((l < row) || (l > row + 2)) {\n            memcpy(&buffercpy[l * cell_shape], ip, cell_shape);\n            ip += cell_shape;\n          }\n        }\n      } else if (match_type == 17) {    // pair match\n        buffercpy = local_buffer;\n        int row = (int) (token & 7);\n        uint16_t offset = *((uint16_t*) ip);\n        ip += 2;\n        for (int l = 0; l < 2; l++) {\n          memcpy(&buffercpy[(row + l) * cell_shape],\n                 ip - sizeof(token) - sizeof(offset) - offset + l * cell_shape, cell_shape);\n        }\n        for (int l = 0; l < cell_shape; l++) {\n          if ((l < row) || (l > row + 1)) {\n            memcpy(&buffercpy[l * cell_shape], ip, cell_shape);\n            ip += cell_shape;\n          }\n        }\n      } else {\n        printf(\"Invalid token: %u at cell [%d, %d]\\n\", token, ii[0], ii[1]);\n        free(local_buffer);\n        free(cell_aux);\n        return 0;\n      }\n\n      uint32_t orig = ii[0] * cell_shape * blockshape[1] + ii[1] * cell_shape;\n      for (uint32_t i = 0; i < (uint32_t) cell_shape; i++) {\n        if (i < padding[0]) {\n          ind = orig + i * blockshape[1];\n          memcpy(&op[ind], buffercpy, padding[1]);\n        }\n        buffercpy += padding[1];\n      }\n      if (ind > (uint32_t) output_len) {\n        printf(\"Output size is bigger than max \\n\");\n        free(local_buffer);\n        free(cell_aux);\n        return 0;\n      }\n    }\n  }\n  ind += padding[1];\n\n  free(cell_aux);\n  free(local_buffer);\n\n  if (ind != (blockshape[0] * blockshape[1])) {\n    printf(\"Output size is not compatible with embedded blockshape \\n\");\n    return 0;\n  }\n  if (ind > (uint32_t) output_len) {\n    printf(\"Output size is bigger than max \\n\");\n    return 0;\n  }\n\n  return (int)ind;\n}\n",
    "target": 1,
    "idx": 1042131,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nvoid VC5Decompressor::decode(unsigned int offsetX, unsigned int offsetY,\n                             unsigned int width, unsigned int height) {\n  if (offsetX || offsetY || mRaw->dim != iPoint2D(width, height))\n    ThrowRDE(\"VC5Decompressor expects to fill the whole image, not some tile.\");\n\n  initVC5LogTable();\n\n  const std::vector<DecodeableBand> allDecodeableBands = [&]() {\n    std::vector<DecodeableBand> bands;\n    bands.reserve(numSubbandsTotal);\n    // All the high-pass bands for all wavelets,\n    // in this specific order of decreasing worksize.\n    for (int waveletLevel = 0; waveletLevel < numWaveletLevels;\n         waveletLevel++) {\n      for (auto channelId = 0; channelId < numChannels; channelId++) {\n        for (int bandId = 1; bandId <= numHighPassBands; bandId++) {\n          auto& channel = channels[channelId];\n          auto& wavelet = channel.wavelets[waveletLevel];\n          auto* band = wavelet.bands[bandId].get();\n          auto* decodeableHighPassBand =\n              dynamic_cast<Wavelet::HighPassBand*>(band);\n          bands.emplace_back(decodeableHighPassBand, wavelet);\n        }\n      }\n    }\n    // The low-pass bands at the end. I'm guessing they should be fast to\n    // decode.\n    for (Channel& channel : channels) {\n      // Low-pass band of the smallest wavelet.\n      Wavelet& smallestWavelet = channel.wavelets.back();\n      auto* decodeableLowPassBand =\n          dynamic_cast<Wavelet::LowPassBand*>(smallestWavelet.bands[0].get());\n      bands.emplace_back(decodeableLowPassBand, smallestWavelet);\n    }\n    assert(allDecodeableBands.size() == numSubbandsTotal);\n    return bands;\n  }();\n\n#ifdef HAVE_OPENMP\n  bool exceptionThrown = false;\n#pragma omp parallel default(none) shared(exceptionThrown)                     \\\n    num_threads(rawspeed_get_number_of_processor_cores())\n  {\n#endif\n#ifdef HAVE_OPENMP\n#pragma omp for schedule(guided)\n#endif\n    for (auto decodeableBand = allDecodeableBands.begin();\n         decodeableBand < allDecodeableBands.end(); ++decodeableBand) {\n      try {\n        decodeableBand->band->decode(decodeableBand->wavelet);\n      } catch (RawspeedException& err) {\n        // Propagate the exception out of OpenMP magic.\n        mRaw->setError(err.what());\n#ifdef HAVE_OPENMP\n#pragma omp atomic write\n        exceptionThrown = true;\n#pragma omp cancel for\n#else\n        throw;\n#endif\n      }\n    }\n\n#ifdef HAVE_OPENMP\n#pragma omp cancel parallel if (exceptionThrown)\n#endif\n\n    // And now, for every channel, recursively reconstruct the low-pass bands.\n    for (int waveletLevel = numWaveletLevels - 1; waveletLevel > 0;\n         waveletLevel--) {\n#ifdef HAVE_OPENMP\n#pragma omp for schedule(static)\n#endif\n      for (auto channel = channels.begin(); channel < channels.end();\n           ++channel) {\n        Wavelet& wavelet = channel->wavelets[waveletLevel];\n        Wavelet& nextWavelet = channel->wavelets[waveletLevel - 1];\n\n        auto& reconstructableBand = nextWavelet.bands[0];\n        reconstructableBand->decode(wavelet);\n\n        wavelet.clear(); // we no longer need it.\n      }\n    }\n\n    // Finally, for each channel, reconstruct the final lowpass band.\n#ifdef HAVE_OPENMP\n#pragma omp for schedule(static)\n#endif\n    for (auto channel = channels.begin(); channel < channels.end(); ++channel) {\n      Wavelet& wavelet = channel->wavelets.front();\n      channel->band.decode(wavelet);\n    }\n\n    // And finally!\n    combineFinalLowpassBands();\n\n#ifdef HAVE_OPENMP\n  }\n\n  std::string firstErr;\n  if (mRaw->isTooManyErrors(1, &firstErr)) {\n    assert(exceptionThrown);\n    ThrowRDE(\"Too many errors encountered. Giving up. First Error:\\n%s\",\n             firstErr.c_str());\n  } else {\n    assert(!exceptionThrown);\n  }\n#endif\n}\n\nvoid VC5Decompressor::combineFinalLowpassBands() const noexcept {\n  const Array2DRef<uint16_t> out(reinterpret_cast<uint16_t*>(mRaw->getData()),\n                                 static_cast<unsigned int>(mRaw->dim.x),\n                                 static_cast<unsigned int>(mRaw->dim.y),\n                                 mRaw->pitch / sizeof(uint16_t));\n\n  const unsigned int width = out.width / 2;\n  const unsigned int height = out.height / 2;\n\n  const Array2DRef<const int16_t> lowbands0 = Array2DRef<const int16_t>(\n      channels[0].band.data.data(), channels[0].width, channels[0].height);\n  const Array2DRef<const int16_t> lowbands1 = Array2DRef<const int16_t>(\n      channels[1].band.data.data(), channels[1].width, channels[1].height);\n  const Array2DRef<const int16_t> lowbands2 = Array2DRef<const int16_t>(\n      channels[2].band.data.data(), channels[2].width, channels[2].height);\n  const Array2DRef<const int16_t> lowbands3 = Array2DRef<const int16_t>(\n      channels[3].band.data.data(), channels[3].width, channels[3].height);\n\n  // Convert to RGGB output\n#ifdef HAVE_OPENMP\n#pragma omp for schedule(static) collapse(2)\n#endif\n  for (unsigned int row = 0; row < height; ++row) {\n    for (unsigned int col = 0; col < width; ++col) {\n      const int mid = 2048;\n\n      int gs = lowbands0(col, row);\n      int rg = lowbands1(col, row) - mid;\n      int bg = lowbands2(col, row) - mid;\n      int gd = lowbands3(col, row) - mid;\n\n      int r = gs + 2 * rg;\n      int b = gs + 2 * bg;\n      int g1 = gs + gd;\n      int g2 = gs - gd;\n\n      out(2 * col + 0, 2 * row + 0) = static_cast<uint16_t>(mVC5LogTable[r]);\n      out(2 * col + 1, 2 * row + 0) = static_cast<uint16_t>(mVC5LogTable[g1]);\n      out(2 * col + 0, 2 * row + 1) = static_cast<uint16_t>(mVC5LogTable[g2]);\n      out(2 * col + 1, 2 * row + 1) = static_cast<uint16_t>(mVC5LogTable[b]);\n    }\n  }\n}\n\n// static\nvoid VC5Decompressor::getRLV(BitPumpMSB* bits, int* value,\n                             unsigned int* count) {\n  unsigned int iTab;\n\n  static constexpr auto maxBits = 1 + table17.entries[table17.length - 1].size;\n\n  // Ensure the maximum number of bits are cached to make peekBits() as fast as\n  // possible.\n  bits->fill(maxBits);\n  for (iTab = 0; iTab < table17.length; ++iTab) {\n    if (table17.entries[iTab].bits ==\n        bits->peekBitsNoFill(table17.entries[iTab].size))\n      break;\n  }\n  if (iTab >= table17.length)\n    ThrowRDE(\"Code not found in codebook\");\n\n  bits->skipBitsNoFill(table17.entries[iTab].size);\n  *value = table17.entries[iTab].value;\n  *count = table17.entries[iTab].count;\n  if (*value != 0) {\n    if (bits->getBitsNoFill(1))\n      *value = -(*value);\n  }\n}\n\n} // namespace rawspeed\n\nvoid VC5Decompressor::decode(unsigned int offsetX, unsigned int offsetY,\n                             unsigned int width, unsigned int height) {\n  if (offsetX || offsetY || mRaw->dim != iPoint2D(width, height))\n    ThrowRDE(\"VC5Decompressor expects to fill the whole image, not some tile.\");\n\n  initVC5LogTable();\n\n  const std::vector<DecodeableBand> allDecodeableBands = [&]() {\n    std::vector<DecodeableBand> bands;\n    bands.reserve(numSubbandsTotal);\n    // All the high-pass bands for all wavelets,\n    // in this specific order of decreasing worksize.\n    for (int waveletLevel = 0; waveletLevel < numWaveletLevels;\n         waveletLevel++) {\n      for (auto channelId = 0; channelId < numChannels; channelId++) {\n        for (int bandId = 1; bandId <= numHighPassBands; bandId++) {\n          auto& channel = channels[channelId];\n          auto& wavelet = channel.wavelets[waveletLevel];\n          auto* band = wavelet.bands[bandId].get();\n          auto* decodeableHighPassBand =\n              dynamic_cast<Wavelet::HighPassBand*>(band);\n          bands.emplace_back(decodeableHighPassBand, wavelet);\n        }\n      }\n    }\n    // The low-pass bands at the end. I'm guessing they should be fast to\n    // decode.\n    for (Channel& channel : channels) {\n      // Low-pass band of the smallest wavelet.\n      Wavelet& smallestWavelet = channel.wavelets.back();\n      auto* decodeableLowPassBand =\n          dynamic_cast<Wavelet::LowPassBand*>(smallestWavelet.bands[0].get());\n      bands.emplace_back(decodeableLowPassBand, smallestWavelet);\n    }\n    assert(allDecodeableBands.size() == numSubbandsTotal);\n    return bands;\n  }();\n\n#ifdef HAVE_OPENMP\n  bool exceptionThrown = false;\n#pragma omp parallel default(none) shared(exceptionThrown)                     \\\n    num_threads(rawspeed_get_number_of_processor_cores())\n  {\n#endif\n#ifdef HAVE_OPENMP\n#pragma omp for schedule(guided)\n#endif\n    for (auto decodeableBand = allDecodeableBands.begin();\n         decodeableBand < allDecodeableBands.end(); ++decodeableBand) {\n      try {\n        decodeableBand->band->decode(decodeableBand->wavelet);\n      } catch (RawspeedException& err) {\n        // Propagate the exception out of OpenMP magic.\n        mRaw->setError(err.what());\n#ifdef HAVE_OPENMP\n#pragma omp atomic write\n        exceptionThrown = true;\n#pragma omp cancel for\n#else\n        throw;\n#endif\n      }\n    }\n\n#ifdef HAVE_OPENMP\n#pragma omp cancel parallel if (exceptionThrown)\n#endif\n\n    // And now, for every channel, recursively reconstruct the low-pass bands.\n    for (int waveletLevel = numWaveletLevels - 1; waveletLevel > 0;\n         waveletLevel--) {\n#ifdef HAVE_OPENMP\n#pragma omp for schedule(static)\n#endif\n      for (auto channel = channels.begin(); channel < channels.end();\n           ++channel) {\n        Wavelet& wavelet = channel->wavelets[waveletLevel];\n        Wavelet& nextWavelet = channel->wavelets[waveletLevel - 1];\n\n        auto& reconstructableBand = nextWavelet.bands[0];\n        reconstructableBand->decode(wavelet);\n\n        wavelet.clear(); // we no longer need it.\n      }\n    }\n\n    // Finally, for each channel, reconstruct the final lowpass band.\n#ifdef HAVE_OPENMP\n#pragma omp for schedule(static)\n#endif\n    for (auto channel = channels.begin(); channel < channels.end(); ++channel) {\n      Wavelet& wavelet = channel->wavelets.front();\n      channel->band.decode(wavelet);\n    }\n\n    // And finally!\n    combineFinalLowpassBands();\n\n#ifdef HAVE_OPENMP\n  }\n\n  std::string firstErr;\n  if (mRaw->isTooManyErrors(1, &firstErr)) {\n    assert(exceptionThrown);\n    ThrowRDE(\"Too many errors encountered. Giving up. First Error:\\n%s\",\n             firstErr.c_str());\n  } else {\n    assert(!exceptionThrown);\n  }\n#endif\n}\n\nvoid VC5Decompressor::combineFinalLowpassBands() const noexcept {\n  const Array2DRef<uint16_t> out(reinterpret_cast<uint16_t*>(mRaw->getData()),\n                                 static_cast<unsigned int>(mRaw->dim.x),\n                                 static_cast<unsigned int>(mRaw->dim.y),\n                                 mRaw->pitch / sizeof(uint16_t));\n\n  const unsigned int width = out.width / 2;\n  const unsigned int height = out.height / 2;\n\n  const Array2DRef<const int16_t> lowbands0 = Array2DRef<const int16_t>(\n      channels[0].band.data.data(), channels[0].width, channels[0].height);\n  const Array2DRef<const int16_t> lowbands1 = Array2DRef<const int16_t>(\n      channels[1].band.data.data(), channels[1].width, channels[1].height);\n  const Array2DRef<const int16_t> lowbands2 = Array2DRef<const int16_t>(\n      channels[2].band.data.data(), channels[2].width, channels[2].height);\n  const Array2DRef<const int16_t> lowbands3 = Array2DRef<const int16_t>(\n      channels[3].band.data.data(), channels[3].width, channels[3].height);\n\n  // Convert to RGGB output\n#ifdef HAVE_OPENMP\n#pragma omp for schedule(static) collapse(2)\n#endif\n  for (unsigned int row = 0; row < height; ++row) {\n    for (unsigned int col = 0; col < width; ++col) {\n      const int mid = 2048;\n\n      int gs = lowbands0(col, row);\n      int rg = lowbands1(col, row) - mid;\n      int bg = lowbands2(col, row) - mid;\n      int gd = lowbands3(col, row) - mid;\n\n      int r = gs + 2 * rg;\n      int b = gs + 2 * bg;\n      int g1 = gs + gd;\n      int g2 = gs - gd;\n\n      out(2 * col + 0, 2 * row + 0) = static_cast<uint16_t>(mVC5LogTable[r]);\n      out(2 * col + 1, 2 * row + 0) = static_cast<uint16_t>(mVC5LogTable[g1]);\n      out(2 * col + 0, 2 * row + 1) = static_cast<uint16_t>(mVC5LogTable[g2]);\n      out(2 * col + 1, 2 * row + 1) = static_cast<uint16_t>(mVC5LogTable[b]);\n    }\n  }\n}\n\n// static\nvoid VC5Decompressor::getRLV(BitPumpMSB* bits, int* value,\n                             unsigned int* count) {\n  unsigned int iTab;\n\n  static constexpr auto maxBits = 1 + table17.entries[table17.length - 1].size;\n\n  // Ensure the maximum number of bits are cached to make peekBits() as fast as\n  // possible.\n  bits->fill(maxBits);\n  for (iTab = 0; iTab < table17.length; ++iTab) {\n    if (table17.entries[iTab].bits ==\n        bits->peekBitsNoFill(table17.entries[iTab].size))\n      break;\n  }\n  if (iTab >= table17.length)\n    ThrowRDE(\"Code not found in codebook\");\n\n  bits->skipBitsNoFill(table17.entries[iTab].size);\n  *value = table17.entries[iTab].value;\n  *count = table17.entries[iTab].count;\n  if (*value != 0) {\n    if (bits->getBitsNoFill(1))\n      *value = -(*value);\n  }\n}\n\n} // namespace rawspeed\n\n\n// target function\nvoid VC5Decompressor::Wavelet::HighPassBand::decode(const Wavelet& wavelet) {\n  auto dequantize = [quant = quant](int16_t val) -> int16_t {\n    return mVC5DecompandingTable[uint16_t(val)] * quant;\n  };\n\n  data = Array2DRef<int16_t>::create(wavelet.width, wavelet.height);\n  const Array2DRef<int16_t> dst(data.data(), wavelet.width, wavelet.height);\n\n  BitPumpMSB bits(bs);\n  // decode highpass band\n  int pixelValue = 0;\n  unsigned int count = 0;\n  int nPixels = wavelet.width * wavelet.height;\n  for (int iPixel = 0; iPixel < nPixels;) {\n    getRLV(&bits, &pixelValue, &count);\n    for (; count > 0; --count) {\n      if (iPixel > nPixels)\n        ThrowRDE(\"Buffer overflow\");\n      data[iPixel] = dequantize(pixelValue);\n      ++iPixel;\n    }\n  }\n  if (bits.getPosition() < bits.getSize()) {\n    getRLV(&bits, &pixelValue, &count);\n    if (pixelValue != MARKER_BAND_END || count != 0)\n      ThrowRDE(\"EndOfBand marker not found\");\n  }\n}\n",
    "target": 1,
    "idx": 1011429,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "// context\n\n\ninline\nvoid\nweak_ptr<_Tp>::swap(weak_ptr& __r) _NOEXCEPT\n{\n    _VSTD::swap(__ptr_, __r.__ptr_);\n    _VSTD::swap(__cntrl_, __r.__cntrl_);\n}\n\ninline\ntypename enable_if\n<\n    __compatible_with<_Yp, _Tp>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(shared_ptr<_Yp> const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\n\n\n    BufferPtrVector Get(const ArrayDataVector& fields) && {\n      AppendFrom(fields);\n      return std::move(buffers_);\n    }\n\n    BufferPtrVector Get(const ArrayDataVector& fields) && {\n      AppendFrom(fields);\n      return std::move(buffers_);\n    }\n\ninline auto VisitType(const DataType& type, VISITOR&& visitor, ARGS&&... args)\n    -> decltype(std::forward<VISITOR>(visitor)(type, args...)) {\n  switch (type.id()) {\n    ARROW_GENERATE_FOR_ALL_TYPES(TYPE_VISIT_INLINE);\n    default:\n      break;\n  }\n  return std::forward<VISITOR>(visitor)(type, std::forward<ARGS>(args)...);\n}\n\n  Status LoadType(const DataType& type) {\n    DCHECK_NE(out_, nullptr);\n    return VisitTypeInline(type, this);\n  }\n\n  Status Load(const Field* field, ArrayData* out) {\n    if (max_recursion_depth_ <= 0) {\n      return Status::Invalid(\"Max recursion depth reached\");\n    }\n\n    field_ = field;\n    out_ = out;\n    out_->type = field_->type();\n    return LoadType(*field_->type());\n  }\n\n    BufferPtrVector Get(const ArrayDataVector& fields) && {\n      AppendFrom(fields);\n      return std::move(buffers_);\n    }\n\nResult<std::shared_ptr<RecordBatch>> LoadRecordBatch(\n    const flatbuf::RecordBatch* metadata, const std::shared_ptr<Schema>& schema,\n    const std::vector<bool>& inclusion_mask, const IpcReadContext& context,\n    io::RandomAccessFile* file) {\n  if (inclusion_mask.size() > 0) {\n    return LoadRecordBatchSubset(metadata, schema, &inclusion_mask, context, file);\n  } else {\n    return LoadRecordBatchSubset(metadata, schema, /*inclusion_mask=*/nullptr, context,\n                                 file);\n  }\n}\n\n    BufferPtrVector Get(const ArrayDataVector& fields) && {\n      AppendFrom(fields);\n      return std::move(buffers_);\n    }\n\n  Status OnRecordBatchMessageDecoded(std::unique_ptr<Message> message) {\n    if (message->type() == MessageType::DICTIONARY_BATCH) {\n      return ReadDictionary(*message);\n    } else {\n      CHECK_HAS_BODY(*message);\n      ARROW_ASSIGN_OR_RAISE(auto reader, Buffer::GetReader(message->body()));\n      IpcReadContext context(&dictionary_memo_, options_, swap_endian_);\n      ARROW_ASSIGN_OR_RAISE(\n          auto batch_with_metadata,\n          ReadRecordBatchInternal(*message->metadata(), schema_, field_inclusion_mask_,\n                                  context, reader.get()));\n      ++stats_.num_record_batches;\n      return listener_->OnRecordBatchWithMetadataDecoded(batch_with_metadata);\n    }\n  }\n\n  Status OnMessageDecoded(std::unique_ptr<Message> message) override {\n    ++stats_.num_messages;\n    switch (state_) {\n      case State::SCHEMA:\n        ARROW_RETURN_NOT_OK(OnSchemaMessageDecoded(std::move(message)));\n        break;\n      case State::INITIAL_DICTIONARIES:\n        ARROW_RETURN_NOT_OK(OnInitialDictionaryMessageDecoded(std::move(message)));\n        break;\n      case State::RECORD_BATCHES:\n        ARROW_RETURN_NOT_OK(OnRecordBatchMessageDecoded(std::move(message)));\n        break;\n      case State::EOS:\n        break;\n    }\n    return Status::OK();\n  }\n\n  Result<RecordBatchWithMetadata> ReadNext() override {\n    auto collect_listener = checked_cast<CollectListener*>(raw_listener());\n    while (collect_listener->num_record_batches() == 0 &&\n           state() != StreamDecoderInternal::State::EOS) {\n      ARROW_ASSIGN_OR_RAISE(auto message, message_reader_->ReadNextMessage());\n      if (!message) {  // End of stream\n        if (state() == StreamDecoderInternal::State::INITIAL_DICTIONARIES) {\n          if (num_read_initial_dictionaries() == 0) {\n            // ARROW-6006: If we fail to find any dictionaries in the\n            // stream, then it may be that the stream has a schema\n            // but no actual data. In such case we communicate that\n            // we were unable to find the dictionaries (but there was\n            // no failure otherwise), so the caller can decide what\n            // to do\n            return RecordBatchWithMetadata{nullptr, nullptr};\n          } else {\n            // ARROW-6126, the stream terminated before receiving the\n            // expected number of dictionaries\n            return Status::Invalid(\n                \"IPC stream ended without reading the \"\n                \"expected number (\",\n                num_required_initial_dictionaries(), \") of dictionaries\");\n          }\n        } else {\n          return RecordBatchWithMetadata{nullptr, nullptr};\n        }\n      }\n      ARROW_RETURN_NOT_OK(OnMessageDecoded(std::move(message)));\n    }\n    return collect_listener->PopRecordBatchWithMetadata();\n  }\n\n  Result<RecordBatchWithMetadata> ReadNext() override {\n    auto collect_listener = checked_cast<CollectListener*>(raw_listener());\n    while (collect_listener->num_record_batches() == 0 &&\n           state() != StreamDecoderInternal::State::EOS) {\n      ARROW_ASSIGN_OR_RAISE(auto message, message_reader_->ReadNextMessage());\n      if (!message) {  // End of stream\n        if (state() == StreamDecoderInternal::State::INITIAL_DICTIONARIES) {\n          if (num_read_initial_dictionaries() == 0) {\n            // ARROW-6006: If we fail to find any dictionaries in the\n            // stream, then it may be that the stream has a schema\n            // but no actual data. In such case we communicate that\n            // we were unable to find the dictionaries (but there was\n            // no failure otherwise), so the caller can decide what\n            // to do\n            return RecordBatchWithMetadata{nullptr, nullptr};\n          } else {\n            // ARROW-6126, the stream terminated before receiving the\n            // expected number of dictionaries\n            return Status::Invalid(\n                \"IPC stream ended without reading the \"\n                \"expected number (\",\n                num_required_initial_dictionaries(), \") of dictionaries\");\n          }\n        } else {\n          return RecordBatchWithMetadata{nullptr, nullptr};\n        }\n      }\n      ARROW_RETURN_NOT_OK(OnMessageDecoded(std::move(message)));\n    }\n    return collect_listener->PopRecordBatchWithMetadata();\n  }\n\nStatus FuzzIpcStream(const uint8_t* data, int64_t size) {\n  auto buffer = std::make_shared<Buffer>(data, size);\n  io::BufferReader buffer_reader(buffer);\n\n  std::shared_ptr<RecordBatchReader> batch_reader;\n  ARROW_ASSIGN_OR_RAISE(batch_reader, RecordBatchStreamReader::Open(&buffer_reader));\n  Status st;\n\n  while (true) {\n    std::shared_ptr<arrow::RecordBatch> batch;\n    RETURN_NOT_OK(batch_reader->ReadNext(&batch));\n    if (batch == nullptr) {\n      break;\n    }\n    st &= ValidateFuzzBatch(*batch);\n  }\n\n  return st;\n}\n\n\n// target function\n  Result<size_t> GetVariadicCount(int i) {\n    auto* variadic_counts = metadata_->variadicBufferCounts();\n    CHECK_FLATBUFFERS_NOT_NULL(variadic_counts, \"RecordBatch.variadicBufferCounts\");\n    if (i >= static_cast<int>(variadic_counts->size())) {\n      return Status::IOError(\"variadic_count_index out of range.\");\n    }\n    return static_cast<size_t>(variadic_counts->Get(i));\n  }\n  Status GetFieldMetadata(int field_index, ArrayData* out) {\n    auto nodes = metadata_->nodes();\n    CHECK_FLATBUFFERS_NOT_NULL(nodes, \"Table.nodes\");\n    // pop off a field\n    if (field_index >= static_cast<int>(nodes->size())) {\n      return Status::Invalid(\"Ran out of field metadata, likely malformed\");\n    }\n    const flatbuf::FieldNode* node = nodes->Get(field_index);\n\n    out->length = node->length();\n    out->null_count = node->null_count();\n    out->offset = 0;\n    return Status::OK();\n  }\n",
    "target": 1,
    "idx": 1063679,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic void strcpy_url(char *output, const char *url, bool relative)\n{\n  /* we must add this with whitespace-replacing */\n  bool left = TRUE;\n  const unsigned char *iptr;\n  char *optr = output;\n  const unsigned char *host_sep = (const unsigned char *) url;\n\n  if(!relative)\n    host_sep = (const unsigned char *) find_host_sep(url);\n\n  for(iptr = (unsigned char *)url;    /* read from here */\n      *iptr;         /* until zero byte */\n      iptr++) {\n\n    if(iptr < host_sep) {\n      *optr++ = *iptr;\n      continue;\n    }\n\n    switch(*iptr) {\n    case '?':\n      left = FALSE;\n      /* fall through */\n    default:\n      if(*iptr >= 0x80) {\n        snprintf(optr, 4, \"%%%02x\", *iptr);\n        optr += 3;\n      }\n      else\n        *optr++=*iptr;\n      break;\n    case ' ':\n      if(left) {\n        *optr++='%'; /* add a '%' */\n        *optr++='2'; /* add a '2' */\n        *optr++='0'; /* add a '0' */\n      }\n      else\n        *optr++='+'; /* add a '+' here */\n      break;\n    }\n  }\n  *optr = 0; /* zero terminate output buffer */\n\n}\n\n\n\nCURLcode Curl_follow(struct Curl_easy *data,\n                     char *newurl,    /* the Location: string */\n                     followtype type) /* see transfer.h */\n{\n#ifdef CURL_DISABLE_HTTP\n  (void)data;\n  (void)newurl;\n  (void)type;\n  /* Location: following will not happen when HTTP is disabled */\n  return CURLE_TOO_MANY_REDIRECTS;\n#else\n\n  /* Location: redirect */\n  bool disallowport = FALSE;\n  bool reachedmax = FALSE;\n\n  if(type == FOLLOW_REDIR) {\n    if((data->set.maxredirs != -1) &&\n       (data->set.followlocation >= data->set.maxredirs)) {\n      reachedmax = TRUE;\n      type = FOLLOW_FAKE; /* switch to fake to store the would-be-redirected\n                             to URL */\n    }\n    else {\n      /* mark the next request as a followed location: */\n      data->state.this_is_a_follow = TRUE;\n\n      data->set.followlocation++; /* count location-followers */\n\n      if(data->set.http_auto_referer) {\n        /* We are asked to automatically set the previous URL as the referer\n           when we get the next URL. We pick the ->url field, which may or may\n           not be 100% correct */\n\n        if(data->change.referer_alloc) {\n          Curl_safefree(data->change.referer);\n          data->change.referer_alloc = FALSE;\n        }\n\n        data->change.referer = strdup(data->change.url);\n        if(!data->change.referer)\n          return CURLE_OUT_OF_MEMORY;\n        data->change.referer_alloc = TRUE; /* yes, free this later */\n      }\n    }\n  }\n\n  if(!is_absolute_url(newurl)) {\n    /***\n     *DANG* this is an RFC 2068 violation. The URL is supposed\n     to be absolute and this doesn't seem to be that!\n     */\n    char *absolute = concat_url(data->change.url, newurl);\n    if(!absolute)\n      return CURLE_OUT_OF_MEMORY;\n    newurl = absolute;\n  }\n  else {\n    /* The new URL MAY contain space or high byte values, that means a mighty\n       stupid redirect URL but we still make an effort to do \"right\". */\n    char *newest;\n    size_t newlen = strlen_url(newurl, FALSE);\n\n    /* This is an absolute URL, don't allow the custom port number */\n    disallowport = TRUE;\n\n    newest = malloc(newlen + 1); /* get memory for this */\n    if(!newest)\n      return CURLE_OUT_OF_MEMORY;\n\n    strcpy_url(newest, newurl, FALSE); /* create a space-free URL */\n    newurl = newest; /* use this instead now */\n\n  }\n\n  if(type == FOLLOW_FAKE) {\n    /* we're only figuring out the new url if we would've followed locations\n       but now we're done so we can get out! */\n    data->info.wouldredirect = newurl;\n\n    if(reachedmax) {\n      failf(data, \"Maximum (%ld) redirects followed\", data->set.maxredirs);\n      return CURLE_TOO_MANY_REDIRECTS;\n    }\n    return CURLE_OK;\n  }\n\n  if(disallowport)\n    data->state.allow_port = FALSE;\n\n  if(data->change.url_alloc) {\n    Curl_safefree(data->change.url);\n    data->change.url_alloc = FALSE;\n  }\n\n  data->change.url = newurl;\n  data->change.url_alloc = TRUE;\n\n  infof(data, \"Issue another request to this URL: '%s'\\n\", data->change.url);\n\n  /*\n   * We get here when the HTTP code is 300-399 (and 401). We need to perform\n   * differently based on exactly what return code there was.\n   *\n   * News from 7.10.6: we can also get here on a 401 or 407, in case we act on\n   * a HTTP (proxy-) authentication scheme other than Basic.\n   */\n  switch(data->info.httpcode) {\n    /* 401 - Act on a WWW-Authenticate, we keep on moving and do the\n       Authorization: XXXX header in the HTTP request code snippet */\n    /* 407 - Act on a Proxy-Authenticate, we keep on moving and do the\n       Proxy-Authorization: XXXX header in the HTTP request code snippet */\n    /* 300 - Multiple Choices */\n    /* 306 - Not used */\n    /* 307 - Temporary Redirect */\n  default:  /* for all above (and the unknown ones) */\n    /* Some codes are explicitly mentioned since I've checked RFC2616 and they\n     * seem to be OK to POST to.\n     */\n    break;\n  case 301: /* Moved Permanently */\n    /* (quote from RFC7231, section 6.4.2)\n     *\n     * Note: For historical reasons, a user agent MAY change the request\n     * method from POST to GET for the subsequent request.  If this\n     * behavior is undesired, the 307 (Temporary Redirect) status code\n     * can be used instead.\n     *\n     * ----\n     *\n     * Many webservers expect this, so these servers often answers to a POST\n     * request with an error page. To be sure that libcurl gets the page that\n     * most user agents would get, libcurl has to force GET.\n     *\n     * This behaviour is forbidden by RFC1945 and the obsolete RFC2616, and\n     * can be overridden with CURLOPT_POSTREDIR.\n     */\n    if((data->set.httpreq == HTTPREQ_POST\n        || data->set.httpreq == HTTPREQ_POST_FORM\n        || data->set.httpreq == HTTPREQ_POST_MIME)\n       && !(data->set.keep_post & CURL_REDIR_POST_301)) {\n      infof(data, \"Switch from POST to GET\\n\");\n      data->set.httpreq = HTTPREQ_GET;\n    }\n    break;\n  case 302: /* Found */\n    /* (quote from RFC7231, section 6.4.3)\n     *\n     * Note: For historical reasons, a user agent MAY change the request\n     * method from POST to GET for the subsequent request.  If this\n     * behavior is undesired, the 307 (Temporary Redirect) status code\n     * can be used instead.\n     *\n     * ----\n     *\n     * Many webservers expect this, so these servers often answers to a POST\n     * request with an error page. To be sure that libcurl gets the page that\n     * most user agents would get, libcurl has to force GET.\n     *\n     * This behaviour is forbidden by RFC1945 and the obsolete RFC2616, and\n     * can be overridden with CURLOPT_POSTREDIR.\n     */\n    if((data->set.httpreq == HTTPREQ_POST\n        || data->set.httpreq == HTTPREQ_POST_FORM\n        || data->set.httpreq == HTTPREQ_POST_MIME)\n       && !(data->set.keep_post & CURL_REDIR_POST_302)) {\n      infof(data, \"Switch from POST to GET\\n\");\n      data->set.httpreq = HTTPREQ_GET;\n    }\n    break;\n\n  case 303: /* See Other */\n    /* Disable both types of POSTs, unless the user explicitly\n       asks for POST after POST */\n    if(data->set.httpreq != HTTPREQ_GET\n      && !(data->set.keep_post & CURL_REDIR_POST_303)) {\n      data->set.httpreq = HTTPREQ_GET; /* enforce GET request */\n      infof(data, \"Disables POST, goes with %s\\n\",\n            data->set.opt_no_body?\"HEAD\":\"GET\");\n    }\n    break;\n  case 304: /* Not Modified */\n    /* 304 means we did a conditional request and it was \"Not modified\".\n     * We shouldn't get any Location: header in this response!\n     */\n    break;\n  case 305: /* Use Proxy */\n    /* (quote from RFC2616, section 10.3.6):\n     * \"The requested resource MUST be accessed through the proxy given\n     * by the Location field. The Location field gives the URI of the\n     * proxy.  The recipient is expected to repeat this single request\n     * via the proxy. 305 responses MUST only be generated by origin\n     * servers.\"\n     */\n    break;\n  }\n  Curl_pgrsTime(data, TIMER_REDIRECT);\n  Curl_pgrsResetTransferSizes(data);\n\n  return CURLE_OK;\n#endif /* CURL_DISABLE_HTTP */\n}\n\nstatic CURLMcode multi_runsingle(struct Curl_multi *multi,\n                                 struct curltime now,\n                                 struct Curl_easy *data)\n{\n  struct Curl_message *msg = NULL;\n  bool connected;\n  bool async;\n  bool protocol_connect = FALSE;\n  bool dophase_done = FALSE;\n  bool done = FALSE;\n  CURLMcode rc;\n  CURLcode result = CURLE_OK;\n  struct SingleRequest *k;\n  time_t timeout_ms;\n  time_t recv_timeout_ms;\n  timediff_t send_timeout_ms;\n  int control;\n\n  if(!GOOD_EASY_HANDLE(data))\n    return CURLM_BAD_EASY_HANDLE;\n\n  do {\n    /* A \"stream\" here is a logical stream if the protocol can handle that\n       (HTTP/2), or the full connection for older protocols */\n    bool stream_error = FALSE;\n    rc = CURLM_OK;\n\n    /* Handle the case when the pipe breaks, i.e., the connection\n       we're using gets cleaned up and we're left with nothing. */\n    if(data->state.pipe_broke) {\n      infof(data, \"Pipe broke: handle %p, url = %s\\n\",\n            (void *)data, data->state.path);\n\n      if(data->mstate < CURLM_STATE_COMPLETED) {\n        /* Head back to the CONNECT state */\n        multistate(data, CURLM_STATE_CONNECT);\n        rc = CURLM_CALL_MULTI_PERFORM;\n        result = CURLE_OK;\n      }\n\n      data->state.pipe_broke = FALSE;\n      data->easy_conn = NULL;\n      continue;\n    }\n\n    if(!data->easy_conn &&\n       data->mstate > CURLM_STATE_CONNECT &&\n       data->mstate < CURLM_STATE_DONE) {\n      /* In all these states, the code will blindly access 'data->easy_conn'\n         so this is precaution that it isn't NULL. And it silences static\n         analyzers. */\n      failf(data, \"In state %d with no easy_conn, bail out!\\n\", data->mstate);\n      return CURLM_INTERNAL_ERROR;\n    }\n\n    if(multi_ischanged(multi, TRUE)) {\n      DEBUGF(infof(data, \"multi changed, check CONNECT_PEND queue!\\n\"));\n      process_pending_handles(multi); /* pipelined/multiplexed */\n    }\n\n    if(data->easy_conn && data->mstate > CURLM_STATE_CONNECT &&\n       data->mstate < CURLM_STATE_COMPLETED) {\n      /* Make sure we set the connection's current owner */\n      data->easy_conn->data = data;\n    }\n\n    if(data->easy_conn &&\n       (data->mstate >= CURLM_STATE_CONNECT) &&\n       (data->mstate < CURLM_STATE_COMPLETED)) {\n      /* we need to wait for the connect state as only then is the start time\n         stored, but we must not check already completed handles */\n      timeout_ms = Curl_timeleft(data, &now,\n                                 (data->mstate <= CURLM_STATE_WAITDO)?\n                                 TRUE:FALSE);\n\n      if(timeout_ms < 0) {\n        /* Handle timed out */\n        if(data->mstate == CURLM_STATE_WAITRESOLVE)\n          failf(data, \"Resolving timed out after %ld milliseconds\",\n                Curl_timediff(now, data->progress.t_startsingle));\n        else if(data->mstate == CURLM_STATE_WAITCONNECT)\n          failf(data, \"Connection timed out after %ld milliseconds\",\n                Curl_timediff(now, data->progress.t_startsingle));\n        else {\n          k = &data->req;\n          if(k->size != -1) {\n            failf(data, \"Operation timed out after %ld milliseconds with %\"\n                  CURL_FORMAT_CURL_OFF_T \" out of %\"\n                  CURL_FORMAT_CURL_OFF_T \" bytes received\",\n                  Curl_timediff(now, data->progress.t_startsingle),\n                  k->bytecount, k->size);\n          }\n          else {\n            failf(data, \"Operation timed out after %ld milliseconds with %\"\n                  CURL_FORMAT_CURL_OFF_T \" bytes received\",\n                  Curl_timediff(now, data->progress.t_startsingle),\n                  k->bytecount);\n          }\n        }\n\n        /* Force connection closed if the connection has indeed been used */\n        if(data->mstate > CURLM_STATE_DO) {\n          streamclose(data->easy_conn, \"Disconnected with pending data\");\n          stream_error = TRUE;\n        }\n        result = CURLE_OPERATION_TIMEDOUT;\n        (void)multi_done(&data->easy_conn, result, TRUE);\n        /* Skip the statemachine and go directly to error handling section. */\n        goto statemachine_end;\n      }\n    }\n\n    switch(data->mstate) {\n    case CURLM_STATE_INIT:\n      /* init this transfer. */\n      result = Curl_pretransfer(data);\n\n      if(!result) {\n        /* after init, go CONNECT */\n        multistate(data, CURLM_STATE_CONNECT);\n        Curl_pgrsTime(data, TIMER_STARTOP);\n        rc = CURLM_CALL_MULTI_PERFORM;\n      }\n      break;\n\n    case CURLM_STATE_CONNECT_PEND:\n      /* We will stay here until there is a connection available. Then\n         we try again in the CURLM_STATE_CONNECT state. */\n      break;\n\n    case CURLM_STATE_CONNECT:\n      /* Connect. We want to get a connection identifier filled in. */\n      Curl_pgrsTime(data, TIMER_STARTSINGLE);\n      result = Curl_connect(data, &data->easy_conn,\n                            &async, &protocol_connect);\n      if(CURLE_NO_CONNECTION_AVAILABLE == result) {\n        /* There was no connection available. We will go to the pending\n           state and wait for an available connection. */\n        multistate(data, CURLM_STATE_CONNECT_PEND);\n\n        /* add this handle to the list of connect-pending handles */\n        Curl_llist_insert_next(&multi->pending, multi->pending.tail, data,\n                               &data->connect_queue);\n        result = CURLE_OK;\n        break;\n      }\n\n      if(!result) {\n        /* Add this handle to the send or pend pipeline */\n        result = Curl_add_handle_to_pipeline(data, data->easy_conn);\n        if(result)\n          stream_error = TRUE;\n        else {\n          if(async)\n            /* We're now waiting for an asynchronous name lookup */\n            multistate(data, CURLM_STATE_WAITRESOLVE);\n          else {\n            /* after the connect has been sent off, go WAITCONNECT unless the\n               protocol connect is already done and we can go directly to\n               WAITDO or DO! */\n            rc = CURLM_CALL_MULTI_PERFORM;\n\n            if(protocol_connect)\n              multistate(data, Curl_pipeline_wanted(multi, CURLPIPE_HTTP1)?\n                         CURLM_STATE_WAITDO:CURLM_STATE_DO);\n            else {\n#ifndef CURL_DISABLE_HTTP\n              if(Curl_connect_ongoing(data->easy_conn))\n                multistate(data, CURLM_STATE_WAITPROXYCONNECT);\n              else\n#endif\n                multistate(data, CURLM_STATE_WAITCONNECT);\n            }\n          }\n        }\n      }\n      break;\n\n    case CURLM_STATE_WAITRESOLVE:\n      /* awaiting an asynch name resolve to complete */\n    {\n      struct Curl_dns_entry *dns = NULL;\n      struct connectdata *conn = data->easy_conn;\n      const char *hostname;\n\n      if(conn->bits.httpproxy)\n        hostname = conn->http_proxy.host.name;\n      else if(conn->bits.conn_to_host)\n        hostname = conn->conn_to_host.name;\n      else\n        hostname = conn->host.name;\n\n      /* check if we have the name resolved by now */\n      dns = Curl_fetch_addr(conn, hostname, (int)conn->port);\n\n      if(dns) {\n#ifdef CURLRES_ASYNCH\n        conn->async.dns = dns;\n        conn->async.done = TRUE;\n#endif\n        result = CURLE_OK;\n        infof(data, \"Hostname '%s' was found in DNS cache\\n\", hostname);\n      }\n\n      if(!dns)\n        result = Curl_resolver_is_resolved(data->easy_conn, &dns);\n\n      /* Update sockets here, because the socket(s) may have been\n         closed and the application thus needs to be told, even if it\n         is likely that the same socket(s) will again be used further\n         down.  If the name has not yet been resolved, it is likely\n         that new sockets have been opened in an attempt to contact\n         another resolver. */\n      singlesocket(multi, data);\n\n      if(dns) {\n        /* Perform the next step in the connection phase, and then move on\n           to the WAITCONNECT state */\n        result = Curl_async_resolved(data->easy_conn, &protocol_connect);\n\n        if(result)\n          /* if Curl_async_resolved() returns failure, the connection struct\n             is already freed and gone */\n          data->easy_conn = NULL;           /* no more connection */\n        else {\n          /* call again please so that we get the next socket setup */\n          rc = CURLM_CALL_MULTI_PERFORM;\n          if(protocol_connect)\n            multistate(data, Curl_pipeline_wanted(multi, CURLPIPE_HTTP1)?\n                       CURLM_STATE_WAITDO:CURLM_STATE_DO);\n          else {\n#ifndef CURL_DISABLE_HTTP\n            if(Curl_connect_ongoing(data->easy_conn))\n              multistate(data, CURLM_STATE_WAITPROXYCONNECT);\n            else\n#endif\n              multistate(data, CURLM_STATE_WAITCONNECT);\n          }\n        }\n      }\n\n      if(result) {\n        /* failure detected */\n        stream_error = TRUE;\n        break;\n      }\n    }\n    break;\n\n#ifndef CURL_DISABLE_HTTP\n    case CURLM_STATE_WAITPROXYCONNECT:\n      /* this is HTTP-specific, but sending CONNECT to a proxy is HTTP... */\n      result = Curl_http_connect(data->easy_conn, &protocol_connect);\n\n      if(data->easy_conn->bits.proxy_connect_closed) {\n        rc = CURLM_CALL_MULTI_PERFORM;\n        /* connect back to proxy again */\n        result = CURLE_OK;\n        multi_done(&data->easy_conn, CURLE_OK, FALSE);\n        multistate(data, CURLM_STATE_CONNECT);\n      }\n      else if(!result) {\n        if((data->easy_conn->http_proxy.proxytype != CURLPROXY_HTTPS ||\n           data->easy_conn->bits.proxy_ssl_connected[FIRSTSOCKET]) &&\n           Curl_connect_complete(data->easy_conn)) {\n          rc = CURLM_CALL_MULTI_PERFORM;\n          /* initiate protocol connect phase */\n          multistate(data, CURLM_STATE_SENDPROTOCONNECT);\n        }\n      }\n      break;\n#endif\n\n    case CURLM_STATE_WAITCONNECT:\n      /* awaiting a completion of an asynch TCP connect */\n      result = Curl_is_connected(data->easy_conn, FIRSTSOCKET, &connected);\n      if(connected && !result) {\n#ifndef CURL_DISABLE_HTTP\n        if((data->easy_conn->http_proxy.proxytype == CURLPROXY_HTTPS &&\n            !data->easy_conn->bits.proxy_ssl_connected[FIRSTSOCKET]) ||\n           Curl_connect_ongoing(data->easy_conn)) {\n          multistate(data, CURLM_STATE_WAITPROXYCONNECT);\n          break;\n        }\n#endif\n        rc = CURLM_CALL_MULTI_PERFORM;\n        multistate(data, data->easy_conn->bits.tunnel_proxy?\n                   CURLM_STATE_WAITPROXYCONNECT:\n                   CURLM_STATE_SENDPROTOCONNECT);\n      }\n      else if(result) {\n        /* failure detected */\n        /* Just break, the cleaning up is handled all in one place */\n        stream_error = TRUE;\n        break;\n      }\n      break;\n\n    case CURLM_STATE_SENDPROTOCONNECT:\n      result = Curl_protocol_connect(data->easy_conn, &protocol_connect);\n      if(!protocol_connect)\n        /* switch to waiting state */\n        multistate(data, CURLM_STATE_PROTOCONNECT);\n      else if(!result) {\n        /* protocol connect has completed, go WAITDO or DO */\n        multistate(data, Curl_pipeline_wanted(multi, CURLPIPE_HTTP1)?\n                   CURLM_STATE_WAITDO:CURLM_STATE_DO);\n        rc = CURLM_CALL_MULTI_PERFORM;\n      }\n      else if(result) {\n        /* failure detected */\n        Curl_posttransfer(data);\n        multi_done(&data->easy_conn, result, TRUE);\n        stream_error = TRUE;\n      }\n      break;\n\n    case CURLM_STATE_PROTOCONNECT:\n      /* protocol-specific connect phase */\n      result = Curl_protocol_connecting(data->easy_conn, &protocol_connect);\n      if(!result && protocol_connect) {\n        /* after the connect has completed, go WAITDO or DO */\n        multistate(data, Curl_pipeline_wanted(multi, CURLPIPE_HTTP1)?\n                   CURLM_STATE_WAITDO:CURLM_STATE_DO);\n        rc = CURLM_CALL_MULTI_PERFORM;\n      }\n      else if(result) {\n        /* failure detected */\n        Curl_posttransfer(data);\n        multi_done(&data->easy_conn, result, TRUE);\n        stream_error = TRUE;\n      }\n      break;\n\n    case CURLM_STATE_WAITDO:\n      /* Wait for our turn to DO when we're pipelining requests */\n      if(Curl_pipeline_checkget_write(data, data->easy_conn)) {\n        /* Grabbed the channel */\n        multistate(data, CURLM_STATE_DO);\n        rc = CURLM_CALL_MULTI_PERFORM;\n      }\n      break;\n\n    case CURLM_STATE_DO:\n      if(data->set.connect_only) {\n        /* keep connection open for application to use the socket */\n        connkeep(data->easy_conn, \"CONNECT_ONLY\");\n        multistate(data, CURLM_STATE_DONE);\n        result = CURLE_OK;\n        rc = CURLM_CALL_MULTI_PERFORM;\n      }\n      else {\n        /* Perform the protocol's DO action */\n        result = multi_do(&data->easy_conn, &dophase_done);\n\n        /* When multi_do() returns failure, data->easy_conn might be NULL! */\n\n        if(!result) {\n          if(!dophase_done) {\n            /* some steps needed for wildcard matching */\n            if(data->state.wildcardmatch) {\n              struct WildcardData *wc = &data->wildcard;\n              if(wc->state == CURLWC_DONE || wc->state == CURLWC_SKIP) {\n                /* skip some states if it is important */\n                multi_done(&data->easy_conn, CURLE_OK, FALSE);\n                multistate(data, CURLM_STATE_DONE);\n                rc = CURLM_CALL_MULTI_PERFORM;\n                break;\n              }\n            }\n            /* DO was not completed in one function call, we must continue\n               DOING... */\n            multistate(data, CURLM_STATE_DOING);\n            rc = CURLM_OK;\n          }\n\n          /* after DO, go DO_DONE... or DO_MORE */\n          else if(data->easy_conn->bits.do_more) {\n            /* we're supposed to do more, but we need to sit down, relax\n               and wait a little while first */\n            multistate(data, CURLM_STATE_DO_MORE);\n            rc = CURLM_OK;\n          }\n          else {\n            /* we're done with the DO, now DO_DONE */\n            multistate(data, CURLM_STATE_DO_DONE);\n            rc = CURLM_CALL_MULTI_PERFORM;\n          }\n        }\n        else if((CURLE_SEND_ERROR == result) &&\n                data->easy_conn->bits.reuse) {\n          /*\n           * In this situation, a connection that we were trying to use\n           * may have unexpectedly died.  If possible, send the connection\n           * back to the CONNECT phase so we can try again.\n           */\n          char *newurl = NULL;\n          followtype follow = FOLLOW_NONE;\n          CURLcode drc;\n          bool retry = FALSE;\n\n          drc = Curl_retry_request(data->easy_conn, &newurl);\n          if(drc) {\n            /* a failure here pretty much implies an out of memory */\n            result = drc;\n            stream_error = TRUE;\n          }\n          else\n            retry = (newurl)?TRUE:FALSE;\n\n          Curl_posttransfer(data);\n          drc = multi_done(&data->easy_conn, result, FALSE);\n\n          /* When set to retry the connection, we must to go back to\n           * the CONNECT state */\n          if(retry) {\n            if(!drc || (drc == CURLE_SEND_ERROR)) {\n              follow = FOLLOW_RETRY;\n              drc = Curl_follow(data, newurl, follow);\n              if(!drc) {\n                multistate(data, CURLM_STATE_CONNECT);\n                rc = CURLM_CALL_MULTI_PERFORM;\n                result = CURLE_OK;\n              }\n              else {\n                /* Follow failed */\n                result = drc;\n              }\n            }\n            else {\n              /* done didn't return OK or SEND_ERROR */\n              result = drc;\n            }\n          }\n          else {\n            /* Have error handler disconnect conn if we can't retry */\n            stream_error = TRUE;\n          }\n          free(newurl);\n        }\n        else {\n          /* failure detected */\n          Curl_posttransfer(data);\n          if(data->easy_conn)\n            multi_done(&data->easy_conn, result, FALSE);\n          stream_error = TRUE;\n        }\n      }\n      break;\n\n    case CURLM_STATE_DOING:\n      /* we continue DOING until the DO phase is complete */\n      result = Curl_protocol_doing(data->easy_conn,\n                                   &dophase_done);\n      if(!result) {\n        if(dophase_done) {\n          /* after DO, go DO_DONE or DO_MORE */\n          multistate(data, data->easy_conn->bits.do_more?\n                     CURLM_STATE_DO_MORE:\n                     CURLM_STATE_DO_DONE);\n          rc = CURLM_CALL_MULTI_PERFORM;\n        } /* dophase_done */\n      }\n      else {\n        /* failure detected */\n        Curl_posttransfer(data);\n        multi_done(&data->easy_conn, result, FALSE);\n        stream_error = TRUE;\n      }\n      break;\n\n    case CURLM_STATE_DO_MORE:\n      /*\n       * When we are connected, DO MORE and then go DO_DONE\n       */\n      result = multi_do_more(data->easy_conn, &control);\n\n      /* No need to remove this handle from the send pipeline here since that\n         is done in multi_done() */\n      if(!result) {\n        if(control) {\n          /* if positive, advance to DO_DONE\n             if negative, go back to DOING */\n          multistate(data, control == 1?\n                     CURLM_STATE_DO_DONE:\n                     CURLM_STATE_DOING);\n          rc = CURLM_CALL_MULTI_PERFORM;\n        }\n        else\n          /* stay in DO_MORE */\n          rc = CURLM_OK;\n      }\n      else {\n        /* failure detected */\n        Curl_posttransfer(data);\n        multi_done(&data->easy_conn, result, FALSE);\n        stream_error = TRUE;\n      }\n      break;\n\n    case CURLM_STATE_DO_DONE:\n      /* Move ourselves from the send to recv pipeline */\n      Curl_move_handle_from_send_to_recv_pipe(data, data->easy_conn);\n\n      if(data->easy_conn->bits.multiplex || data->easy_conn->send_pipe.size)\n        /* Check if we can move pending requests to send pipe */\n        process_pending_handles(multi); /*  pipelined/multiplexed */\n\n      /* Only perform the transfer if there's a good socket to work with.\n         Having both BAD is a signal to skip immediately to DONE */\n      if((data->easy_conn->sockfd != CURL_SOCKET_BAD) ||\n         (data->easy_conn->writesockfd != CURL_SOCKET_BAD))\n        multistate(data, CURLM_STATE_WAITPERFORM);\n      else\n      {\n        if(data->state.wildcardmatch &&\n           ((data->easy_conn->handler->flags & PROTOPT_WILDCARD) == 0)) {\n           data->wildcard.state = CURLWC_DONE;\n        }\n        multistate(data, CURLM_STATE_DONE);\n      }\n      rc = CURLM_CALL_MULTI_PERFORM;\n      break;\n\n    case CURLM_STATE_WAITPERFORM:\n      /* Wait for our turn to PERFORM */\n      if(Curl_pipeline_checkget_read(data, data->easy_conn)) {\n        /* Grabbed the channel */\n        multistate(data, CURLM_STATE_PERFORM);\n        rc = CURLM_CALL_MULTI_PERFORM;\n      }\n      break;\n\n    case CURLM_STATE_TOOFAST: /* limit-rate exceeded in either direction */\n      /* if both rates are within spec, resume transfer */\n      if(Curl_pgrsUpdate(data->easy_conn))\n        result = CURLE_ABORTED_BY_CALLBACK;\n      else\n        result = Curl_speedcheck(data, now);\n\n      if(!result) {\n        send_timeout_ms = 0;\n        if(data->set.max_send_speed > 0)\n          send_timeout_ms =\n            Curl_pgrsLimitWaitTime(data->progress.uploaded,\n                                   data->progress.ul_limit_size,\n                                   data->set.max_send_speed,\n                                   data->progress.ul_limit_start,\n                                   now);\n\n        recv_timeout_ms = 0;\n        if(data->set.max_recv_speed > 0)\n          recv_timeout_ms =\n            Curl_pgrsLimitWaitTime(data->progress.downloaded,\n                                   data->progress.dl_limit_size,\n                                   data->set.max_recv_speed,\n                                   data->progress.dl_limit_start,\n                                   now);\n\n        if(!send_timeout_ms && !recv_timeout_ms) {\n          multistate(data, CURLM_STATE_PERFORM);\n          Curl_ratelimit(data, now);\n        }\n        else if(send_timeout_ms >= recv_timeout_ms)\n          Curl_expire(data, send_timeout_ms, EXPIRE_TOOFAST);\n        else\n          Curl_expire(data, recv_timeout_ms, EXPIRE_TOOFAST);\n      }\n      break;\n\n    case CURLM_STATE_PERFORM:\n    {\n      char *newurl = NULL;\n      bool retry = FALSE;\n      bool comeback = FALSE;\n\n      /* check if over send speed */\n      send_timeout_ms = 0;\n      if(data->set.max_send_speed > 0)\n        send_timeout_ms = Curl_pgrsLimitWaitTime(data->progress.uploaded,\n                                                 data->progress.ul_limit_size,\n                                                 data->set.max_send_speed,\n                                                 data->progress.ul_limit_start,\n                                                 now);\n\n      /* check if over recv speed */\n      recv_timeout_ms = 0;\n      if(data->set.max_recv_speed > 0)\n        recv_timeout_ms = Curl_pgrsLimitWaitTime(data->progress.downloaded,\n                                                 data->progress.dl_limit_size,\n                                                 data->set.max_recv_speed,\n                                                 data->progress.dl_limit_start,\n                                                 now);\n\n      if(send_timeout_ms || recv_timeout_ms) {\n        Curl_ratelimit(data, now);\n        multistate(data, CURLM_STATE_TOOFAST);\n        if(send_timeout_ms >= recv_timeout_ms)\n          Curl_expire(data, send_timeout_ms, EXPIRE_TOOFAST);\n        else\n          Curl_expire(data, recv_timeout_ms, EXPIRE_TOOFAST);\n        break;\n      }\n\n      /* read/write data if it is ready to do so */\n      result = Curl_readwrite(data->easy_conn, data, &done, &comeback);\n\n      k = &data->req;\n\n      if(!(k->keepon & KEEP_RECV))\n        /* We're done receiving */\n        Curl_pipeline_leave_read(data->easy_conn);\n\n      if(!(k->keepon & KEEP_SEND))\n        /* We're done sending */\n        Curl_pipeline_leave_write(data->easy_conn);\n\n      if(done || (result == CURLE_RECV_ERROR)) {\n        /* If CURLE_RECV_ERROR happens early enough, we assume it was a race\n         * condition and the server closed the re-used connection exactly when\n         * we wanted to use it, so figure out if that is indeed the case.\n         */\n        CURLcode ret = Curl_retry_request(data->easy_conn, &newurl);\n        if(!ret)\n          retry = (newurl)?TRUE:FALSE;\n\n        if(retry) {\n          /* if we are to retry, set the result to OK and consider the\n             request as done */\n          result = CURLE_OK;\n          done = TRUE;\n        }\n      }\n\n      if(result) {\n        /*\n         * The transfer phase returned error, we mark the connection to get\n         * closed to prevent being re-used. This is because we can't possibly\n         * know if the connection is in a good shape or not now.  Unless it is\n         * a protocol which uses two \"channels\" like FTP, as then the error\n         * happened in the data connection.\n         */\n\n        if(!(data->easy_conn->handler->flags & PROTOPT_DUAL) &&\n           result != CURLE_HTTP2_STREAM)\n          streamclose(data->easy_conn, \"Transfer returned error\");\n\n        Curl_posttransfer(data);\n        multi_done(&data->easy_conn, result, TRUE);\n      }\n      else if(done) {\n        followtype follow = FOLLOW_NONE;\n\n        /* call this even if the readwrite function returned error */\n        Curl_posttransfer(data);\n\n        /* we're no longer receiving */\n        Curl_removeHandleFromPipeline(data, &data->easy_conn->recv_pipe);\n\n        /* expire the new receiving pipeline head */\n        if(data->easy_conn->recv_pipe.head)\n          Curl_expire(data->easy_conn->recv_pipe.head->ptr, 0, EXPIRE_RUN_NOW);\n\n        /* When we follow redirects or is set to retry the connection, we must\n           to go back to the CONNECT state */\n        if(data->req.newurl || retry) {\n          if(!retry) {\n            /* if the URL is a follow-location and not just a retried request\n               then figure out the URL here */\n            free(newurl);\n            newurl = data->req.newurl;\n            data->req.newurl = NULL;\n            follow = FOLLOW_REDIR;\n          }\n          else\n            follow = FOLLOW_RETRY;\n          result = multi_done(&data->easy_conn, CURLE_OK, FALSE);\n          if(!result) {\n            result = Curl_follow(data, newurl, follow);\n            if(!result) {\n              multistate(data, CURLM_STATE_CONNECT);\n              rc = CURLM_CALL_MULTI_PERFORM;\n            }\n          }\n        }\n        else {\n          /* after the transfer is done, go DONE */\n\n          /* but first check to see if we got a location info even though we're\n             not following redirects */\n          if(data->req.location) {\n            free(newurl);\n            newurl = data->req.location;\n            data->req.location = NULL;\n            result = Curl_follow(data, newurl, FOLLOW_FAKE);\n            if(result)\n              stream_error = TRUE;\n          }\n\n          multistate(data, CURLM_STATE_DONE);\n          rc = CURLM_CALL_MULTI_PERFORM;\n        }\n      }\n      else if(comeback)\n        rc = CURLM_CALL_MULTI_PERFORM;\n\n      free(newurl);\n      break;\n    }\n\n    case CURLM_STATE_DONE:\n      /* this state is highly transient, so run another loop after this */\n      rc = CURLM_CALL_MULTI_PERFORM;\n\n      if(data->easy_conn) {\n        CURLcode res;\n\n        /* Remove ourselves from the receive pipeline, if we are there. */\n        Curl_removeHandleFromPipeline(data, &data->easy_conn->recv_pipe);\n\n        if(data->easy_conn->bits.multiplex || data->easy_conn->send_pipe.size)\n          /* Check if we can move pending requests to connection */\n          process_pending_handles(multi); /* pipelined/multiplexing */\n\n        /* post-transfer command */\n        res = multi_done(&data->easy_conn, result, FALSE);\n\n        /* allow a previously set error code take precedence */\n        if(!result)\n          result = res;\n\n        /*\n         * If there are other handles on the pipeline, multi_done won't set\n         * easy_conn to NULL.  In such a case, curl_multi_remove_handle() can\n         * access free'd data, if the connection is free'd and the handle\n         * removed before we perform the processing in CURLM_STATE_COMPLETED\n         */\n        if(data->easy_conn)\n          data->easy_conn = NULL;\n      }\n\n      if(data->state.wildcardmatch) {\n        if(data->wildcard.state != CURLWC_DONE) {\n          /* if a wildcard is set and we are not ending -> lets start again\n             with CURLM_STATE_INIT */\n          multistate(data, CURLM_STATE_INIT);\n          break;\n        }\n      }\n\n      /* after we have DONE what we're supposed to do, go COMPLETED, and\n         it doesn't matter what the multi_done() returned! */\n      multistate(data, CURLM_STATE_COMPLETED);\n      break;\n\n    case CURLM_STATE_COMPLETED:\n      /* this is a completed transfer, it is likely to still be connected */\n\n      /* This node should be delinked from the list now and we should post\n         an information message that we are complete. */\n\n      /* Important: reset the conn pointer so that we don't point to memory\n         that could be freed anytime */\n      data->easy_conn = NULL;\n\n      Curl_expire_clear(data); /* stop all timers */\n      break;\n\n    case CURLM_STATE_MSGSENT:\n      data->result = result;\n      return CURLM_OK; /* do nothing */\n\n    default:\n      return CURLM_INTERNAL_ERROR;\n    }\n    statemachine_end:\n\n    if(data->mstate < CURLM_STATE_COMPLETED) {\n      if(result) {\n        /*\n         * If an error was returned, and we aren't in completed state now,\n         * then we go to completed and consider this transfer aborted.\n         */\n\n        /* NOTE: no attempt to disconnect connections must be made\n           in the case blocks above - cleanup happens only here */\n\n        data->state.pipe_broke = FALSE;\n\n        /* Check if we can move pending requests to send pipe */\n        process_pending_handles(multi); /* connection */\n\n        if(data->easy_conn) {\n          /* if this has a connection, unsubscribe from the pipelines */\n          Curl_pipeline_leave_write(data->easy_conn);\n          Curl_pipeline_leave_read(data->easy_conn);\n          Curl_removeHandleFromPipeline(data, &data->easy_conn->send_pipe);\n          Curl_removeHandleFromPipeline(data, &data->easy_conn->recv_pipe);\n\n          if(stream_error) {\n            /* Don't attempt to send data over a connection that timed out */\n            bool dead_connection = result == CURLE_OPERATION_TIMEDOUT;\n            /* disconnect properly */\n            Curl_disconnect(data->easy_conn, dead_connection);\n\n            /* This is where we make sure that the easy_conn pointer is reset.\n               We don't have to do this in every case block above where a\n               failure is detected */\n            data->easy_conn = NULL;\n          }\n        }\n        else if(data->mstate == CURLM_STATE_CONNECT) {\n          /* Curl_connect() failed */\n          (void)Curl_posttransfer(data);\n        }\n\n        multistate(data, CURLM_STATE_COMPLETED);\n      }\n      /* if there's still a connection to use, call the progress function */\n      else if(data->easy_conn && Curl_pgrsUpdate(data->easy_conn)) {\n        /* aborted due to progress callback return code must close the\n           connection */\n        result = CURLE_ABORTED_BY_CALLBACK;\n        streamclose(data->easy_conn, \"Aborted by callback\");\n\n        /* if not yet in DONE state, go there, otherwise COMPLETED */\n        multistate(data, (data->mstate < CURLM_STATE_DONE)?\n                   CURLM_STATE_DONE: CURLM_STATE_COMPLETED);\n        rc = CURLM_CALL_MULTI_PERFORM;\n      }\n    }\n\n    if(CURLM_STATE_COMPLETED == data->mstate) {\n      /* now fill in the Curl_message with this info */\n      msg = &data->msg;\n\n      msg->extmsg.msg = CURLMSG_DONE;\n      msg->extmsg.easy_handle = data;\n      msg->extmsg.data.result = result;\n\n      rc = multi_addmsg(multi, msg);\n\n      multistate(data, CURLM_STATE_MSGSENT);\n    }\n  } while((rc == CURLM_CALL_MULTI_PERFORM) || multi_ischanged(multi, FALSE));\n\n  data->result = result;\n\n\n  return rc;\n}\n\nCURLMcode curl_multi_perform(struct Curl_multi *multi, int *running_handles)\n{\n  struct Curl_easy *data;\n  CURLMcode returncode = CURLM_OK;\n  struct Curl_tree *t;\n  struct curltime now = Curl_now();\n\n  if(!GOOD_MULTI_HANDLE(multi))\n    return CURLM_BAD_HANDLE;\n\n  if(multi->in_callback)\n    return CURLM_RECURSIVE_API_CALL;\n\n  data = multi->easyp;\n  while(data) {\n    CURLMcode result;\n    SIGPIPE_VARIABLE(pipe_st);\n\n    sigpipe_ignore(data, &pipe_st);\n    result = multi_runsingle(multi, now, data);\n    sigpipe_restore(&pipe_st);\n\n    if(result)\n      returncode = result;\n\n    data = data->next; /* operate on next handle */\n  }\n\n  /*\n   * Simply remove all expired timers from the splay since handles are dealt\n   * with unconditionally by this function and curl_multi_timeout() requires\n   * that already passed/handled expire times are removed from the splay.\n   *\n   * It is important that the 'now' value is set at the entry of this function\n   * and not for the current time as it may have ticked a little while since\n   * then and then we risk this loop to remove timers that actually have not\n   * been handled!\n   */\n  do {\n    multi->timetree = Curl_splaygetbest(now, multi->timetree, &t);\n    if(t)\n      /* the removed may have another timeout in queue */\n      (void)add_next_timeout(now, multi, t->payload);\n\n  } while(t);\n\n  *running_handles = multi->num_alive;\n\n  if(CURLM_OK >= returncode)\n    update_timer(multi);\n\n  return returncode;\n}\n\nint fuzz_handle_transfer(FUZZ_DATA *fuzz)\n{\n  int rc = 0;\n  CURLM *multi_handle;\n  int still_running; /* keep number of running handles */\n  CURLMsg *msg; /* for picking up messages with the transfer status */\n  int msgs_left; /* how many messages are left */\n  int double_timeout = 0;\n  fd_set fdread;\n  fd_set fdwrite;\n  fd_set fdexcep;\n  struct timeval timeout;\n  int select_rc;\n  CURLMcode mc;\n  int maxfd = -1;\n  long curl_timeo = -1;\n  int ii;\n  FUZZ_SOCKET_MANAGER *sman[FUZZ_NUM_CONNECTIONS];\n\n  for(ii = 0; ii < FUZZ_NUM_CONNECTIONS; ii++) {\n    sman[ii] = &fuzz->sockman[ii];\n\n    /* Set up the starting index for responses. */\n    sman[ii]->response_index = 1;\n  }\n\n  /* init a multi stack */\n  multi_handle = curl_multi_init();\n\n  /* add the individual transfers */\n  curl_multi_add_handle(multi_handle, fuzz->easy);\n\n  /* Do an initial process. This might end the transfer immediately. */\n  curl_multi_perform(multi_handle, &still_running);\n  FV_PRINTF(fuzz,\n            \"FUZZ: Initial perform; still running? %d \\n\",\n            still_running);\n\n  while(still_running) {\n    /* Reset the sets of file descriptors. */\n    FD_ZERO(&fdread);\n    FD_ZERO(&fdwrite);\n    FD_ZERO(&fdexcep);\n\n    /* Set a timeout of 10ms. This is lower than recommended by the multi guide\n       but we're not going to any remote servers, so everything should complete\n       very quickly. */\n    timeout.tv_sec = 0;\n    timeout.tv_usec = 10000;\n\n    /* get file descriptors from the transfers */\n    mc = curl_multi_fdset(multi_handle, &fdread, &fdwrite, &fdexcep, &maxfd);\n    if(mc != CURLM_OK) {\n      fprintf(stderr, \"curl_multi_fdset() failed, code %d.\\n\", mc);\n      rc = -1;\n      break;\n    }\n\n    for(ii = 0; ii < FUZZ_NUM_CONNECTIONS; ii++) {\n      /* Add the socket FD into the readable set if connected. */\n      if(sman[ii]->fd_state == FUZZ_SOCK_OPEN) {\n        FD_SET(sman[ii]->fd, &fdread);\n\n        /* Work out the maximum FD between the cURL file descriptors and the\n           server FD. */\n        maxfd = FUZZ_MAX(sman[ii]->fd, maxfd);\n      }\n    }\n\n    /* Work out what file descriptors need work. */\n    rc = fuzz_select(maxfd + 1, &fdread, &fdwrite, &fdexcep, &timeout);\n\n    if(rc == -1) {\n      /* Had an issue while selecting a file descriptor. Let's just exit. */\n      FV_PRINTF(fuzz, \"FUZZ: select failed, exiting \\n\");\n      break;\n    }\n    else if(rc == 0) {\n      FV_PRINTF(fuzz,\n                \"FUZZ: Timed out; double timeout? %d \\n\",\n                double_timeout);\n\n      /* Timed out. */\n      if(double_timeout == 1) {\n        /* We don't expect multiple timeouts in a row. If there are double\n           timeouts then exit. */\n        break;\n      }\n      else {\n        /* Set the timeout flag for the next time we select(). */\n        double_timeout = 1;\n      }\n    }\n    else {\n      /* There's an active file descriptor. Reset the timeout flag. */\n      double_timeout = 0;\n    }\n\n    /* Check to see if a server file descriptor is readable. If it is,\n       then send the next response from the fuzzing data. */\n    for(ii = 0; ii < FUZZ_NUM_CONNECTIONS; ii++) {\n      if(sman[ii]->fd_state == FUZZ_SOCK_OPEN &&\n         FD_ISSET(sman[ii]->fd, &fdread)) {\n        rc = fuzz_send_next_response(fuzz, sman[ii]);\n        if(rc != 0) {\n          /* Failed to send a response. Break out here. */\n          break;\n        }\n      }\n    }\n\n    curl_multi_perform(multi_handle, &still_running);\n  }\n\n  /* Remove the easy handle from the multi stack. */\n  curl_multi_remove_handle(multi_handle, fuzz->easy);\n\n  /* Clean up the multi handle - the top level function will handle the easy\n     handle. */\n  curl_multi_cleanup(multi_handle);\n\n  return(rc);\n}\n\n\n// target function\nstatic void strcpy_url(char *output, const char *url, bool relative)\n{\n  /* we must add this with whitespace-replacing */\n  bool left = TRUE;\n  const unsigned char *iptr;\n  char *optr = output;\n  const unsigned char *host_sep = (const unsigned char *) url;\n\n  if(!relative)\n    host_sep = (const unsigned char *) find_host_sep(url);\n\n  for(iptr = (unsigned char *)url;    /* read from here */\n      *iptr;         /* until zero byte */\n      iptr++) {\n\n    if(iptr < host_sep) {\n      *optr++ = *iptr;\n      continue;\n    }\n\n    switch(*iptr) {\n    case '?':\n      left = FALSE;\n      /* fall through */\n    default:\n      if(!ISPRINT(*iptr)) {\n        snprintf(optr, 4, \"%%%02x\", *iptr);\n        optr += 3;\n      }\n      else\n        *optr++=*iptr;\n      break;\n    case ' ':\n      if(left) {\n        *optr++='%'; /* add a '%' */\n        *optr++='2'; /* add a '2' */\n        *optr++='0'; /* add a '0' */\n      }\n      else\n        *optr++='+'; /* add a '+' here */\n      break;\n    }\n  }\n  *optr = 0; /* zero terminate output buffer */\n\n}\n",
    "target": 1,
    "idx": 1008000,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "// context\nstatic void bn_sqr_karat_imp(bn_t c, const bn_t a, int level) {\n\tbn_t a0, a1, a0a0, a1a1, t;\n\tint h = a->used >> 1;\n\n\tbn_null(a0);\n\tbn_null(a1);\n\tbn_null(a0a0);\n\tbn_null(a1a1);\n\tbn_null(t);\n\n\tRLC_TRY {\n\t\t/* Allocate the temp variables. */\n\t\tbn_new_size(a0, h);\n\t\tbn_new_size(a1, a->used - h);\n\t\tbn_new(a0a0);\n\t\tbn_new(a1a1);\n\t\tbn_new(t);\n\n\t\t/* a = a1 || a0 */\n\t\ta0->used = h;\n\t\ta1->used = a->used - h;\n\t\tdv_copy(a0->dp, a->dp, h);\n\t\tdv_copy(a1->dp, a->dp + h, a->used - h);\n\t\tbn_trim(a0);\n\t\tbn_trim(a1);\n\n\t\tif (level <= 1) {\n\t\t\t/* a0a0 = a0 * a0 and a1a1 = a1 * a1 */\n#if BN_SQR == BASIC\n\t\t\tbn_sqr_basic(a0a0, a0);\n\t\t\tbn_sqr_basic(a1a1, a1);\n#elif BN_SQR == COMBA\n\t\t\tbn_sqr_comba(a0a0, a0);\n\t\t\tbn_sqr_comba(a1a1, a1);\n#elif BN_SQR == MULTP\n\t\t\tbn_mul_comba(a0a0, a0, a0);\n\t\t\tbn_mul_comba(a1a1, a1, a1);\n#endif\n\t\t} else {\n\t\t\tbn_sqr_karat_imp(a0a0, a0, level - 1);\n\t\t\tbn_sqr_karat_imp(a1a1, a1, level - 1);\n\t\t}\n\n\t\t/* t = (a1 + a0) */\n\t\tbn_add(t, a1, a0);\n\n\t\tif (level <= 1) {\n\t\t\t/* t = (a1 + a0)*(a1 + a0) */\n#if BN_SQR == BASIC\n\t\t\tbn_sqr_basic(t, t);\n#elif BN_SQR == COMBA\n\t\t\tbn_sqr_comba(t, t);\n#elif BN_SQR == MULTP\n\t\t\tbn_mul_comba(t, t, t);\n#endif\n\t\t} else {\n\t\t\tbn_sqr_karat_imp(t, t, level - 1);\n\t\t}\n\n\t\t/* t2 = (a0*a0 + a1*a1) */\n\t\tbn_add(a0, a0a0, a1a1);\n\t\t/* t = (a1 + a0)*(b1 + b0) - (a0*a0 + a1*a1) */\n\t\tbn_sub(t, t, a0);\n\n\t\t/* t = (a1 + a0)*(a1 + a0) - (a0*a0 + a1*a1) << h digits */\n\t\tbn_lsh(t, t, h * RLC_DIG);\n\n\t\t/* t2 = a1 * b1 << 2*h digits */\n\t\tbn_lsh(a1a1, a1a1, 2 * h * RLC_DIG);\n\n\t\t/* t = t + a0*a0 */\n\t\tbn_add(t, t, a0a0);\n\t\t/* c = t + a1*a1 */\n\t\tbn_add(t, t, a1a1);\n\n\t\tt->sign = RLC_POS;\n\t\tbn_copy(c, t);\n\t}\n\nvoid bn_sqr_karat(bn_t c, const bn_t a) {\n\tbn_sqr_karat_imp(c, a, BN_KARAT);\n}\n\nbool Add::Run(Datasource& ds, Bignum& res, std::vector<Bignum>& bn) const {\n    (void)ds;\n\n    RLC_TRY {\n        /* noret */ bn_add(res.Get(), bn[0].Get(), bn[1].Get());\n    } RLC_CATCH_ANY {\n\nstd::optional<component::Bignum> relic::OpBignumCalc(operation::BignumCalc& op) {\n    std::optional<component::Bignum> ret = std::nullopt;\n    Datasource ds(op.modifier.GetPtr(), op.modifier.GetSize());\n\n    relic_bignum::Bignum res(ds);\n    std::vector<relic_bignum::Bignum> bn = {\n        std::move(relic_bignum::Bignum(ds)),\n        std::move(relic_bignum::Bignum(ds)),\n        std::move(relic_bignum::Bignum(ds)),\n        std::move(relic_bignum::Bignum(ds)),\n    };\n\n    std::unique_ptr<relic_bignum::Operation> opRunner = nullptr;\n\n    CF_CHECK_TRUE(res.Set(\"0\"));\n    CF_CHECK_TRUE(bn[0].Set(op.bn0.ToString(ds)));\n    CF_CHECK_TRUE(bn[1].Set(op.bn1.ToString(ds)));\n    CF_CHECK_TRUE(bn[2].Set(op.bn2.ToString(ds)));\n    CF_CHECK_TRUE(bn[3].Set(op.bn3.ToString(ds)));\n\n    switch ( op.calcOp.Get() ) {\n        case    CF_CALCOP(\"Add(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::Add>();\n            break;\n        case    CF_CALCOP(\"Sub(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::Sub>();\n            break;\n        case    CF_CALCOP(\"Mul(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::Mul>();\n            break;\n        case    CF_CALCOP(\"Sqr(A)\"):\n            opRunner = std::make_unique<relic_bignum::Sqr>();\n            break;\n        case    CF_CALCOP(\"Div(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::Div>();\n            break;\n        case    CF_CALCOP(\"GCD(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::GCD>();\n            break;\n        case    CF_CALCOP(\"LCM(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::LCM>();\n            break;\n        case    CF_CALCOP(\"InvMod(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::InvMod>();\n            break;\n        case    CF_CALCOP(\"LShift1(A)\"):\n            opRunner = std::make_unique<relic_bignum::LShift1>();\n            break;\n        case    CF_CALCOP(\"Jacobi(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::Jacobi>();\n            break;\n        case    CF_CALCOP(\"Cmp(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::Cmp>();\n            break;\n        case    CF_CALCOP(\"Mod(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::Mod>();\n            break;\n        case    CF_CALCOP(\"IsEven(A)\"):\n            opRunner = std::make_unique<relic_bignum::IsEven>();\n            break;\n        case    CF_CALCOP(\"IsOdd(A)\"):\n            opRunner = std::make_unique<relic_bignum::IsOdd>();\n            break;\n        case    CF_CALCOP(\"IsZero(A)\"):\n            opRunner = std::make_unique<relic_bignum::IsZero>();\n            break;\n        case    CF_CALCOP(\"Neg(A)\"):\n            opRunner = std::make_unique<relic_bignum::Neg>();\n            break;\n        case    CF_CALCOP(\"Sqrt(A)\"):\n            opRunner = std::make_unique<relic_bignum::Sqrt>();\n            break;\n        case    CF_CALCOP(\"Abs(A)\"):\n            opRunner = std::make_unique<relic_bignum::Abs>();\n            break;\n        case    CF_CALCOP(\"ExpMod(A,B,C)\"):\n            opRunner = std::make_unique<relic_bignum::ExpMod>();\n            break;\n        case    CF_CALCOP(\"NumBits(A)\"):\n            opRunner = std::make_unique<relic_bignum::NumBits>();\n            break;\n        case    CF_CALCOP(\"CmpAbs(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::CmpAbs>();\n            break;\n        case    CF_CALCOP(\"RShift(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::RShift>();\n            break;\n        case    CF_CALCOP(\"Bit(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::Bit>();\n            break;\n        case    CF_CALCOP(\"SetBit(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::SetBit>();\n            break;\n        case    CF_CALCOP(\"ClearBit(A,B)\"):\n            opRunner = std::make_unique<relic_bignum::ClearBit>();\n            break;\n    }\n\n    CF_CHECK_NE(opRunner, nullptr);\n    CF_CHECK_EQ(opRunner->Run(ds, res, bn), true);\n\n    ret = res.ToComponentBignum();\n\nend:\n    return ret;\n}\n\ntemplate<> std::optional<bool> ExecutorBase<bool, operation::Verify>::callModule(std::shared_ptr<Module> module, operation::Verify& op) const {\n    return module->OpVerify(op);\n}\n\nvoid ExecutorBase<ResultType, OperationType>::Run(Datasource& parentDs, const uint8_t* data, const size_t size) const {\n    typename ExecutorBase<ResultType, OperationType>::ResultSet results;\n\n    std::vector< std::pair<std::shared_ptr<Module>, OperationType> > operations;\n\n    do {\n        auto op = getOp(&parentDs, data, size);\n        auto module = getModule(parentDs);\n        if ( module == nullptr ) {\n            continue;\n        }\n\n        operations.push_back( {module, op} );\n\n        /* Limit number of operations per run to prevent time-outs */\n        if ( operations.size() == OperationType::MaxOperations() ) {\n            break;\n        }\n    } while ( parentDs.Get<bool>() == true );\n\n    if ( operations.empty() == true ) {\n        return;\n    }\n\n    /* Enable this to run every operation on every loaded module */\n#if 1\n    {\n        std::set<uint64_t> moduleIDs;\n        for (const auto& m : modules ) {\n            const auto moduleID = m.first;\n\n            /* Skip if this is a disabled module */\n            if ( options.disableModules != std::nullopt ) {\n                if ( std::find(\n                            options.disableModules->begin(),\n                            options.disableModules->end(),\n                            moduleID) != options.disableModules->end() ) {\n                    continue;\n                }\n            }\n            moduleIDs.insert(moduleID);\n        }\n\n        std::set<uint64_t> operationModuleIDs;\n        for (const auto& op : operations) {\n            operationModuleIDs.insert(op.first->ID);\n        }\n\n        std::vector<uint64_t> addModuleIDs(moduleIDs.size());\n        auto it = std::set_difference(moduleIDs.begin(), moduleIDs.end(), operationModuleIDs.begin(), operationModuleIDs.end(), addModuleIDs.begin());\n        addModuleIDs.resize(it - addModuleIDs.begin());\n\n        for (const auto& id : addModuleIDs) {\n            operations.push_back({ modules.at(id), operations[0].second});\n        }\n    }\n#endif\n\n    if ( operations.size() < options.minModules ) {\n        return;\n    }\n\n    if ( options.debug == true && !operations.empty() ) {\n        printf(\"Running:\\n%s\\n\", operations[0].second.ToString().c_str());\n    }\n    for (size_t i = 0; i < operations.size(); i++) {\n        auto& operation = operations[i];\n\n        auto& module = operation.first;\n        auto& op = operation.second;\n\n        if ( i > 0 ) {\n            auto& prevModule = operations[i-1].first;\n            auto& prevOp = operations[i].second;\n\n            if ( prevModule == module && prevOp.modifier == op.modifier ) {\n                auto& curModifier = op.modifier.GetVectorPtr();\n                if ( curModifier.size() == 0 ) {\n                    for (size_t j = 0; j < 512; j++) {\n                        curModifier.push_back(1);\n                    }\n                } else {\n                    for (auto& c : curModifier) {\n                        c++;\n                    }\n                }\n            }\n        }\n\n        results.push_back( {module, std::move(callModule(module, op))} );\n\n        const auto& result = results.back();\n\n        if ( result.second != std::nullopt ) {\n            updateExtraCounters(module->ID, op);\n\n            if ( options.jsonDumpFP != std::nullopt ) {\n                nlohmann::json j;\n                j[\"operation\"] = op.ToJSON();\n                j[\"result\"] = util::ToJSON(*result.second);\n                fprintf(*options.jsonDumpFP, \"%s\\n\", j.dump().c_str());\n            }\n        }\n\n        if ( options.debug == true ) {\n            printf(\"Module %s result:\\n\\n%s\\n\\n\",\n                    result.first->name.c_str(),\n                    result.second == std::nullopt ?\n                        \"(empty)\" :\n                        util::ToString(*result.second).c_str());\n        }\n\n        if ( options.disableTests == false ) {\n            tests::test(op, result.second);\n        }\n\n        postprocess(module, op, result);\n    }\n\n    if ( options.noCompare == false ) {\n        compare(operations, results, data, size);\n    }\n}\n\nvoid Driver::Run(const uint8_t* data, const size_t size) const {\n    using fuzzing::datasource::ID;\n\n    static ExecutorDigest executorDigest(CF_OPERATION(\"Digest\"), modules, options);\n    static ExecutorHMAC executorHMAC(CF_OPERATION(\"HMAC\"), modules, options);\n    static ExecutorCMAC executorCMAC(CF_OPERATION(\"CMAC\"), modules, options);\n    static ExecutorSymmetricEncrypt executorSymmetricEncrypt(CF_OPERATION(\"SymmetricEncrypt\"), modules, options);\n    static ExecutorSymmetricDecrypt executorSymmetricDecrypt(CF_OPERATION(\"SymmetricDecrypt\"), modules, options);\n    static ExecutorKDF_SCRYPT executorKDF_SCRYPT(CF_OPERATION(\"KDF_SCRYPT\"), modules, options);\n    static ExecutorKDF_HKDF executorKDF_HKDF(CF_OPERATION(\"KDF_HKDF\"), modules, options);\n    static ExecutorKDF_TLS1_PRF executorKDF_TLS1_PRF(CF_OPERATION(\"KDF_TLS1_PRF\"), modules, options);\n    static ExecutorKDF_PBKDF executorKDF_PBKDF(CF_OPERATION(\"KDF_PBKDF\"), modules, options);\n    static ExecutorKDF_PBKDF1 executorKDF_PBKDF1(CF_OPERATION(\"KDF_PBKDF1\"), modules, options);\n    static ExecutorKDF_PBKDF2 executorKDF_PBKDF2(CF_OPERATION(\"KDF_PBKDF2\"), modules, options);\n    static ExecutorKDF_ARGON2 executorKDF_ARGON2(CF_OPERATION(\"KDF_ARGON2\"), modules, options);\n    static ExecutorKDF_SSH executorKDF_SSH(ID(\"Cryptofuzz/Operation/KDF_SSH\"), modules, options);\n    static ExecutorKDF_X963 executorKDF_X963(CF_OPERATION(\"KDF_X963\"), modules, options);\n    static ExecutorKDF_BCRYPT executorKDF_BCRYPT(CF_OPERATION(\"KDF_BCRYPT\"), modules, options);\n    static ExecutorKDF_SP_800_108 executorKDF_SP_800_108(CF_OPERATION(\"KDF_SP_800_108\"), modules, options);\n    static ExecutorECC_PrivateToPublic executorECC_PrivateToPublic(CF_OPERATION(\"ECC_PrivateToPublic\"), modules, options);\n    static ExecutorECC_ValidatePubkey executorECC_ValidatePubkey(CF_OPERATION(\"ECC_ValidatePubkey\"), modules, options);\n    static ExecutorECC_GenerateKeyPair executorECC_GenerateKeyPair(CF_OPERATION(\"ECC_GenerateKeyPair\"), modules, options);\n    static ExecutorECDSA_Sign executorECDSA_Sign(CF_OPERATION(\"ECDSA_Sign\"), modules, options);\n    static ExecutorECDSA_Verify executorECDSA_Verify(CF_OPERATION(\"ECDSA_Verify\"), modules, options);\n    static ExecutorECDH_Derive executorECDH_Derive(CF_OPERATION(\"ECDH_Derive\"), modules, options);\n    static ExecutorECIES_Encrypt executorECIES_Encrypt(CF_OPERATION(\"ECIES_Encrypt\"), modules, options);\n    static ExecutorDH_GenerateKeyPair executorDH_GenerateKeyPair(CF_OPERATION(\"DH_GenerateKeyPair\"), modules, options);\n    static ExecutorDH_Derive executorDH_Derive(CF_OPERATION(\"DH_Derive\"), modules, options);\n    static ExecutorBignumCalc executorBignumCalc(CF_OPERATION(\"BignumCalc\"), modules, options);\n\n    try {\n\n        Datasource ds(data, size);\n\n        const auto operation = ds.Get<uint64_t>();\n\n        /* Only run whitelisted operations, if specified */\n        if ( options.operations != std::nullopt ) {\n            if ( std::find(\n                    options.operations->begin(),\n                    options.operations->end(),\n                    operation) == options.operations->end() ) {\n                return;\n            }\n        }\n        const auto payload = ds.GetData(0, 1);\n\n        switch ( operation ) {\n            case CF_OPERATION(\"Digest\"):\n                executorDigest.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"HMAC\"):\n                executorHMAC.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"CMAC\"):\n                executorCMAC.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"SymmetricEncrypt\"):\n                executorSymmetricEncrypt.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"SymmetricDecrypt\"):\n                executorSymmetricDecrypt.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"KDF_SCRYPT\"):\n                executorKDF_SCRYPT.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"KDF_HKDF\"):\n                executorKDF_HKDF.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"KDF_TLS1_PRF\"):\n                executorKDF_TLS1_PRF.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"KDF_PBKDF\"):\n                executorKDF_PBKDF.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"KDF_PBKDF1\"):\n                executorKDF_PBKDF1.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"KDF_PBKDF2\"):\n                executorKDF_PBKDF2.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"KDF_ARGON2\"):\n                executorKDF_ARGON2.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"KDF_SSH\"):\n                executorKDF_SSH.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"KDF_X963\"):\n                executorKDF_X963.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"KDF_BCRYPT\"):\n                executorKDF_BCRYPT.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"KDF_SP_800_108\"):\n                executorKDF_SP_800_108.Run(ds, payload.data(), payload.size());\n                break;\n#if 0\n            case    ID(\"Cryptofuzz/Operation/Sign\"):\n                executorSign.Run(ds, payload.data(), payload.size());\n                break;\n            case    ID(\"Cryptofuzz/Operation/Verify\"):\n                executorVerify.Run(ds, payload.data(), payload.size());\n                break;\n#endif\n            case CF_OPERATION(\"ECC_PrivateToPublic\"):\n                executorECC_PrivateToPublic.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"ECC_ValidatePubkey\"):\n                executorECC_ValidatePubkey.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"ECC_GenerateKeyPair\"):\n                executorECC_GenerateKeyPair.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"ECDSA_Sign\"):\n                executorECDSA_Sign.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"ECDSA_Verify\"):\n                executorECDSA_Verify.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"ECDH_Derive\"):\n                executorECDH_Derive.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"ECIES_Encrypt\"):\n                executorECIES_Encrypt.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"DH_GenerateKeyPair\"):\n                executorDH_GenerateKeyPair.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"DH_Derive\"):\n                executorDH_Derive.Run(ds, payload.data(), payload.size());\n                break;\n            case CF_OPERATION(\"BignumCalc\"):\n                executorBignumCalc.Run(ds, payload.data(), payload.size());\n                break;\n        }\n    } catch ( Datasource::OutOfData ) {\n    }\n};\n\n\n// target function\nstatic void bn_mul_karat_imp(bn_t c, const bn_t a, const bn_t b, int level) {\n\tint h;\n\tbn_t a0, a1, b0, b1, a0b0, a1b1;\n\tbn_t t;\n\tconst dig_t *tmpa, *tmpb;\n\tdig_t *t0;\n\n\tbn_null(a0);\n\tbn_null(a1);\n\tbn_null(b0);\n\tbn_null(b1);\n\tbn_null(a0b0);\n\tbn_null(a1b1);\n\tbn_null(t);\n\n\t/* Compute half the digits of a or b. */\n\th = RLC_MIN(a->used, b->used) >> 1;\n\n\tRLC_TRY {\n\t\t/* Allocate the temp variables. */\n\t\tbn_new(a0);\n\t\tbn_new(a1);\n\t\tbn_new(b0);\n\t\tbn_new(b1);\n\t\tbn_new(a0b0);\n\t\tbn_new(a1b1);\n\t\tbn_new(t);\n\n\t\ta0->used = b0->used = h;\n\t\ta1->used = a->used - h;\n\t\tb1->used = b->used - h;\n\n\t\ttmpa = a->dp;\n\t\ttmpb = b->dp;\n\n\t\t/* a = a1 || a0 */\n\t\tt0 = a0->dp;\n\t\tfor (int i = 0; i < h; i++, t0++, tmpa++)\n\t\t\t*t0 = *tmpa;\n\t\tt0 = a1->dp;\n\t\tfor (int i = 0; i < a1->used; i++, t0++, tmpa++)\n\t\t\t*t0 = *tmpa;\n\n\t\t/* b = b1 || b0 */\n\t\tt0 = b0->dp;\n\t\tfor (int i = 0; i < h; i++, t0++, tmpb++)\n\t\t\t*t0 = *tmpb;\n\t\tt0 = b1->dp;\n\t\tfor (int i = 0; i < b1->used; i++, t0++, tmpb++)\n\t\t\t*t0 = *tmpb;\n\n\t\tbn_trim(a0);\n\t\tbn_trim(b0);\n\t\tbn_trim(a1);\n\t\tbn_trim(b1);\n\n\t\t/* a0b0 = a0 * b0 and a1b1 = a1 * b1 */\n\t\tif (level <= 1) {\n#if BN_MUL == BASIC\n\t\t\tbn_mul_basic(a0b0, a0, b0);\n\t\t\tbn_mul_basic(a1b1, a1, b1);\n#elif BN_MUL == COMBA\n\t\t\tbn_mul_comba(a0b0, a0, b0);\n\t\t\tbn_mul_comba(a1b1, a1, b1);\n#endif\n\t\t} else {\n\t\t\tbn_mul_karat_imp(a0b0, a0, b0, level - 1);\n\t\t\tbn_mul_karat_imp(a1b1, a1, b1, level - 1);\n\t\t}\n\n\t\t/* t = (a1 + a0) */\n\t\tbn_add(a1, a1, a0);\n\t\t/* t2 = (b1 + b0) */\n\t\tbn_add(b1, b1, b0);\n\n\t\t/* t = (a1 + a0)*(b1 + b0) */\n\t\tif (level <= 1) {\n#if BN_MUL == BASIC\n\t\t\tbn_mul_basic(t, a1, b1);\n#elif BN_MUL == COMBA\n\t\t\tbn_mul_comba(t, a1, b1);\n#endif\n\t\t} else {\n\t\t\tbn_mul_karat_imp(t, a1, b1, level - 1);\n\t\t}\n\t\t/* t2 = (a0*b0 + a1*b1) */\n\t\tbn_sub(t, t, a0b0);\n\n\t\t/* t = (a1 + a0)*(b1 + b0) - (a0*b0 + a1*b1) */\n\t\tbn_sub(t, t, a1b1);\n\n\t\t/* t = (a1 + a0)*(b1 + b0) - (a0*b0 + a1*b1) << h digits */\n\t\tbn_lsh(t, t, h * RLC_DIG);\n\n\t\t/* t2 = a1 * b1 << 2*h digits */\n\t\tbn_lsh(a1b1, a1b1, 2 * h * RLC_DIG);\n\n\t\t/* t = t + a0*b0 */\n\t\tbn_add(t, t, a0b0);\n\n\t\t/* c = t + a1*b1 */\n\t\tbn_add(t, t, a1b1);\n\n\t\tt->sign = a->sign ^ b->sign;\n\t\tbn_copy(c, t);\n\t\tbn_trim(c);\n\t}\nstatic void bn_sqr_karat_imp(bn_t c, const bn_t a, int level) {\n\tint h;\n\tbn_t a0, a1, a0a0, a1a1, t;\n\tconst dig_t *tmpa;\n\tdig_t *t0;\n\n\tbn_null(a0);\n\tbn_null(a1);\n\tbn_null(a0a0);\n\tbn_null(a1a1);\n\tbn_null(t);\n\n\t/* Compute half the digits of a or b. */\n\th = a->used >> 1;\n\n\tRLC_TRY {\n\t\t/* Allocate the temp variables. */\n\t\tbn_new(a0);\n\t\tbn_new(a1);\n\t\tbn_new(a0a0);\n\t\tbn_new(a1a1);\n\t\tbn_new(t);\n\n\t\ta0->used = h;\n\t\ta1->used = a->used - h;\n\n\t\ttmpa = a->dp;\n\n\t\t/* a = a1 || a0 */\n\t\tt0 = a0->dp;\n\t\tfor (int i = 0; i < h; i++, t0++, tmpa++)\n\t\t\t*t0 = *tmpa;\n\t\tt0 = a1->dp;\n\t\tfor (int i = 0; i < a1->used; i++, t0++, tmpa++)\n\t\t\t*t0 = *tmpa;\n\n\t\tbn_trim(a0);\n\n\t\tif (level <= 1) {\n\t\t\t/* a0a0 = a0 * a0 and a1a1 = a1 * a1 */\n#if BN_SQR == BASIC\n\t\t\tbn_sqr_basic(a0a0, a0);\n\t\t\tbn_sqr_basic(a1a1, a1);\n#elif BN_SQR == COMBA\n\t\t\tbn_sqr_comba(a0a0, a0);\n\t\t\tbn_sqr_comba(a1a1, a1);\n#elif BN_SQR == MULTP\n\t\t\tbn_mul_comba(a0a0, a0, a0);\n\t\t\tbn_mul_comba(a1a1, a1, a1);\n#endif\n\t\t} else {\n\t\t\tbn_sqr_karat_imp(a0a0, a0, level - 1);\n\t\t\tbn_sqr_karat_imp(a1a1, a1, level - 1);\n\t\t}\n\n\t\t/* t = (a1 + a0) */\n\t\tbn_add(t, a1, a0);\n\n\t\tif (level <= 1) {\n\t\t\t/* t = (a1 + a0)*(a1 + a0) */\n#if BN_SQR == BASIC\n\t\t\tbn_sqr_basic(t, t);\n#elif BN_SQR == COMBA\n\t\t\tbn_sqr_comba(t, t);\n#elif BN_SQR == MULTP\n\t\t\tbn_mul_comba(t, t, t);\n#endif\n\t\t} else {\n\t\t\tbn_sqr_karat_imp(t, t, level - 1);\n\t\t}\n\n\t\t/* t2 = (a0*a0 + a1*a1) */\n\t\tbn_add(a0, a0a0, a1a1);\n\t\t/* t = (a1 + a0)*(b1 + b0) - (a0*a0 + a1*a1) */\n\t\tbn_sub(t, t, a0);\n\n\t\t/* t = (a1 + a0)*(a1 + a0) - (a0*a0 + a1*a1) << h digits */\n\t\tbn_lsh(t, t, h * RLC_DIG);\n\n\t\t/* t2 = a1 * b1 << 2*h digits */\n\t\tbn_lsh(a1a1, a1a1, 2 * h * RLC_DIG);\n\n\t\t/* t = t + a0*a0 */\n\t\tbn_add(t, t, a0a0);\n\t\t/* c = t + a1*a1 */\n\t\tbn_add(t, t, a1a1);\n\n\t\tt->sign = RLC_POS;\n\t\tbn_copy(c, t);\n\t}\nvoid dv_lshd(dig_t *c, const dig_t *a, int size, int digits) {\n\tdig_t *top;\n\tconst dig_t *bot;\n\tint i;\n\n\ttop = c + size + digits - 1;\n\tbot = a + size - 1;\n\n\tfor (i = 0; i < size; i++, top--, bot--) {\n\t\t*top = *bot;\n\t}\n\tfor (i = 0; i < digits; i++, c++) {\n\t\t*c = 0;\n\t}\n}\n",
    "target": 1,
    "idx": 1030537,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nint curl_mvsnprintf(char *buffer, size_t maxlength, const char *format,\n                    va_list ap_save)\n{\n  int retcode;\n  struct nsprintf info;\n\n  info.buffer = buffer;\n  info.length = 0;\n  info.max = maxlength;\n\n  retcode = dprintf_formatf(&info, addbyter, format, ap_save);\n  if((retcode != -1) && info.max) {\n    /* we terminate this with a zero byte */\n    if(info.max == info.length)\n      /* we're at maximum, scrap the last letter */\n      info.buffer[-1] = 0;\n    else\n      info.buffer[0] = 0;\n  }\n  return retcode;\n}\n\nint curl_msnprintf(char *buffer, size_t maxlength, const char *format, ...)\n{\n  int retcode;\n  va_list ap_save; /* argument pointer */\n  va_start(ap_save, format);\n  retcode = curl_mvsnprintf(buffer, maxlength, format, ap_save);\n  va_end(ap_save);\n  return retcode;\n}\n\nstatic void strcpy_url(char *output, const char *url, bool relative)\n{\n  /* we must add this with whitespace-replacing */\n  bool left = TRUE;\n  const unsigned char *iptr;\n  char *optr = output;\n  const unsigned char *host_sep = (const unsigned char *) url;\n\n  if(!relative)\n    host_sep = (const unsigned char *) find_host_sep(url);\n\n  for(iptr = (unsigned char *)url;    /* read from here */\n      *iptr;         /* until zero byte */\n      iptr++) {\n\n    if(iptr < host_sep) {\n      *optr++ = *iptr;\n      continue;\n    }\n\n    switch(*iptr) {\n    case '?':\n      left = FALSE;\n      /* fall through */\n    default:\n      if(*iptr >= 0x80) {\n        snprintf(optr, 4, \"%%%02x\", *iptr);\n        optr += 3;\n      }\n      else\n        *optr++=*iptr;\n      break;\n    case ' ':\n      if(left) {\n        *optr++='%'; /* add a '%' */\n        *optr++='2'; /* add a '2' */\n        *optr++='0'; /* add a '0' */\n      }\n      else\n        *optr++='+'; /* add a '+' here */\n      break;\n    }\n  }\n  *optr = 0; /* zero terminate output buffer */\n\n}\n\n\n\nCURLcode Curl_follow(struct Curl_easy *data,\n                     char *newurl,    /* the Location: string */\n                     followtype type) /* see transfer.h */\n{\n#ifdef CURL_DISABLE_HTTP\n  (void)data;\n  (void)newurl;\n  (void)type;\n  /* Location: following will not happen when HTTP is disabled */\n  return CURLE_TOO_MANY_REDIRECTS;\n#else\n\n  /* Location: redirect */\n  bool disallowport = FALSE;\n  bool reachedmax = FALSE;\n\n  if(type == FOLLOW_REDIR) {\n    if((data->set.maxredirs != -1) &&\n       (data->set.followlocation >= data->set.maxredirs)) {\n      reachedmax = TRUE;\n      type = FOLLOW_FAKE; /* switch to fake to store the would-be-redirected\n                             to URL */\n    }\n    else {\n      /* mark the next request as a followed location: */\n      data->state.this_is_a_follow = TRUE;\n\n      data->set.followlocation++; /* count location-followers */\n\n      if(data->set.http_auto_referer) {\n        /* We are asked to automatically set the previous URL as the referer\n           when we get the next URL. We pick the ->url field, which may or may\n           not be 100% correct */\n\n        if(data->change.referer_alloc) {\n          Curl_safefree(data->change.referer);\n          data->change.referer_alloc = FALSE;\n        }\n\n        data->change.referer = strdup(data->change.url);\n        if(!data->change.referer)\n          return CURLE_OUT_OF_MEMORY;\n        data->change.referer_alloc = TRUE; /* yes, free this later */\n      }\n    }\n  }\n\n  if(!is_absolute_url(newurl)) {\n    /***\n     *DANG* this is an RFC 2068 violation. The URL is supposed\n     to be absolute and this doesn't seem to be that!\n     */\n    char *absolute = concat_url(data->change.url, newurl);\n    if(!absolute)\n      return CURLE_OUT_OF_MEMORY;\n    newurl = absolute;\n  }\n  else {\n    /* The new URL MAY contain space or high byte values, that means a mighty\n       stupid redirect URL but we still make an effort to do \"right\". */\n    char *newest;\n    size_t newlen = strlen_url(newurl, FALSE);\n\n    /* This is an absolute URL, don't allow the custom port number */\n    disallowport = TRUE;\n\n    newest = malloc(newlen + 1); /* get memory for this */\n    if(!newest)\n      return CURLE_OUT_OF_MEMORY;\n\n    strcpy_url(newest, newurl, FALSE); /* create a space-free URL */\n    newurl = newest; /* use this instead now */\n\n  }\n\n  if(type == FOLLOW_FAKE) {\n    /* we're only figuring out the new url if we would've followed locations\n       but now we're done so we can get out! */\n    data->info.wouldredirect = newurl;\n\n    if(reachedmax) {\n      failf(data, \"Maximum (%ld) redirects followed\", data->set.maxredirs);\n      return CURLE_TOO_MANY_REDIRECTS;\n    }\n    return CURLE_OK;\n  }\n\n  if(disallowport)\n    data->state.allow_port = FALSE;\n\n  if(data->change.url_alloc) {\n    Curl_safefree(data->change.url);\n    data->change.url_alloc = FALSE;\n  }\n\n  data->change.url = newurl;\n  data->change.url_alloc = TRUE;\n\n  infof(data, \"Issue another request to this URL: '%s'\\n\", data->change.url);\n\n  /*\n   * We get here when the HTTP code is 300-399 (and 401). We need to perform\n   * differently based on exactly what return code there was.\n   *\n   * News from 7.10.6: we can also get here on a 401 or 407, in case we act on\n   * a HTTP (proxy-) authentication scheme other than Basic.\n   */\n  switch(data->info.httpcode) {\n    /* 401 - Act on a WWW-Authenticate, we keep on moving and do the\n       Authorization: XXXX header in the HTTP request code snippet */\n    /* 407 - Act on a Proxy-Authenticate, we keep on moving and do the\n       Proxy-Authorization: XXXX header in the HTTP request code snippet */\n    /* 300 - Multiple Choices */\n    /* 306 - Not used */\n    /* 307 - Temporary Redirect */\n  default:  /* for all above (and the unknown ones) */\n    /* Some codes are explicitly mentioned since I've checked RFC2616 and they\n     * seem to be OK to POST to.\n     */\n    break;\n  case 301: /* Moved Permanently */\n    /* (quote from RFC7231, section 6.4.2)\n     *\n     * Note: For historical reasons, a user agent MAY change the request\n     * method from POST to GET for the subsequent request.  If this\n     * behavior is undesired, the 307 (Temporary Redirect) status code\n     * can be used instead.\n     *\n     * ----\n     *\n     * Many webservers expect this, so these servers often answers to a POST\n     * request with an error page. To be sure that libcurl gets the page that\n     * most user agents would get, libcurl has to force GET.\n     *\n     * This behaviour is forbidden by RFC1945 and the obsolete RFC2616, and\n     * can be overridden with CURLOPT_POSTREDIR.\n     */\n    if((data->set.httpreq == HTTPREQ_POST\n        || data->set.httpreq == HTTPREQ_POST_FORM\n        || data->set.httpreq == HTTPREQ_POST_MIME)\n       && !(data->set.keep_post & CURL_REDIR_POST_301)) {\n      infof(data, \"Switch from POST to GET\\n\");\n      data->set.httpreq = HTTPREQ_GET;\n    }\n    break;\n  case 302: /* Found */\n    /* (quote from RFC7231, section 6.4.3)\n     *\n     * Note: For historical reasons, a user agent MAY change the request\n     * method from POST to GET for the subsequent request.  If this\n     * behavior is undesired, the 307 (Temporary Redirect) status code\n     * can be used instead.\n     *\n     * ----\n     *\n     * Many webservers expect this, so these servers often answers to a POST\n     * request with an error page. To be sure that libcurl gets the page that\n     * most user agents would get, libcurl has to force GET.\n     *\n     * This behaviour is forbidden by RFC1945 and the obsolete RFC2616, and\n     * can be overridden with CURLOPT_POSTREDIR.\n     */\n    if((data->set.httpreq == HTTPREQ_POST\n        || data->set.httpreq == HTTPREQ_POST_FORM\n        || data->set.httpreq == HTTPREQ_POST_MIME)\n       && !(data->set.keep_post & CURL_REDIR_POST_302)) {\n      infof(data, \"Switch from POST to GET\\n\");\n      data->set.httpreq = HTTPREQ_GET;\n    }\n    break;\n\n  case 303: /* See Other */\n    /* Disable both types of POSTs, unless the user explicitly\n       asks for POST after POST */\n    if(data->set.httpreq != HTTPREQ_GET\n      && !(data->set.keep_post & CURL_REDIR_POST_303)) {\n      data->set.httpreq = HTTPREQ_GET; /* enforce GET request */\n      infof(data, \"Disables POST, goes with %s\\n\",\n            data->set.opt_no_body?\"HEAD\":\"GET\");\n    }\n    break;\n  case 304: /* Not Modified */\n    /* 304 means we did a conditional request and it was \"Not modified\".\n     * We shouldn't get any Location: header in this response!\n     */\n    break;\n  case 305: /* Use Proxy */\n    /* (quote from RFC2616, section 10.3.6):\n     * \"The requested resource MUST be accessed through the proxy given\n     * by the Location field. The Location field gives the URI of the\n     * proxy.  The recipient is expected to repeat this single request\n     * via the proxy. 305 responses MUST only be generated by origin\n     * servers.\"\n     */\n    break;\n  }\n  Curl_pgrsTime(data, TIMER_REDIRECT);\n  Curl_pgrsResetTransferSizes(data);\n\n  return CURLE_OK;\n#endif /* CURL_DISABLE_HTTP */\n}\n\nstatic CURLMcode multi_runsingle(struct Curl_multi *multi,\n                                 struct curltime now,\n                                 struct Curl_easy *data)\n{\n  struct Curl_message *msg = NULL;\n  bool connected;\n  bool async;\n  bool protocol_connect = FALSE;\n  bool dophase_done = FALSE;\n  bool done = FALSE;\n  CURLMcode rc;\n  CURLcode result = CURLE_OK;\n  struct SingleRequest *k;\n  time_t timeout_ms;\n  time_t recv_timeout_ms;\n  timediff_t send_timeout_ms;\n  int control;\n\n  if(!GOOD_EASY_HANDLE(data))\n    return CURLM_BAD_EASY_HANDLE;\n\n  do {\n    /* A \"stream\" here is a logical stream if the protocol can handle that\n       (HTTP/2), or the full connection for older protocols */\n    bool stream_error = FALSE;\n    rc = CURLM_OK;\n\n    /* Handle the case when the pipe breaks, i.e., the connection\n       we're using gets cleaned up and we're left with nothing. */\n    if(data->state.pipe_broke) {\n      infof(data, \"Pipe broke: handle %p, url = %s\\n\",\n            (void *)data, data->state.path);\n\n      if(data->mstate < CURLM_STATE_COMPLETED) {\n        /* Head back to the CONNECT state */\n        multistate(data, CURLM_STATE_CONNECT);\n        rc = CURLM_CALL_MULTI_PERFORM;\n        result = CURLE_OK;\n      }\n\n      data->state.pipe_broke = FALSE;\n      data->easy_conn = NULL;\n      continue;\n    }\n\n    if(!data->easy_conn &&\n       data->mstate > CURLM_STATE_CONNECT &&\n       data->mstate < CURLM_STATE_DONE) {\n      /* In all these states, the code will blindly access 'data->easy_conn'\n         so this is precaution that it isn't NULL. And it silences static\n         analyzers. */\n      failf(data, \"In state %d with no easy_conn, bail out!\\n\", data->mstate);\n      return CURLM_INTERNAL_ERROR;\n    }\n\n    if(multi_ischanged(multi, TRUE)) {\n      DEBUGF(infof(data, \"multi changed, check CONNECT_PEND queue!\\n\"));\n      process_pending_handles(multi); /* pipelined/multiplexed */\n    }\n\n    if(data->easy_conn && data->mstate > CURLM_STATE_CONNECT &&\n       data->mstate < CURLM_STATE_COMPLETED) {\n      /* Make sure we set the connection's current owner */\n      data->easy_conn->data = data;\n    }\n\n    if(data->easy_conn &&\n       (data->mstate >= CURLM_STATE_CONNECT) &&\n       (data->mstate < CURLM_STATE_COMPLETED)) {\n      /* we need to wait for the connect state as only then is the start time\n         stored, but we must not check already completed handles */\n      timeout_ms = Curl_timeleft(data, &now,\n                                 (data->mstate <= CURLM_STATE_WAITDO)?\n                                 TRUE:FALSE);\n\n      if(timeout_ms < 0) {\n        /* Handle timed out */\n        if(data->mstate == CURLM_STATE_WAITRESOLVE)\n          failf(data, \"Resolving timed out after %ld milliseconds\",\n                Curl_timediff(now, data->progress.t_startsingle));\n        else if(data->mstate == CURLM_STATE_WAITCONNECT)\n          failf(data, \"Connection timed out after %ld milliseconds\",\n                Curl_timediff(now, data->progress.t_startsingle));\n        else {\n          k = &data->req;\n          if(k->size != -1) {\n            failf(data, \"Operation timed out after %ld milliseconds with %\"\n                  CURL_FORMAT_CURL_OFF_T \" out of %\"\n                  CURL_FORMAT_CURL_OFF_T \" bytes received\",\n                  Curl_timediff(now, data->progress.t_startsingle),\n                  k->bytecount, k->size);\n          }\n          else {\n            failf(data, \"Operation timed out after %ld milliseconds with %\"\n                  CURL_FORMAT_CURL_OFF_T \" bytes received\",\n                  Curl_timediff(now, data->progress.t_startsingle),\n                  k->bytecount);\n          }\n        }\n\n        /* Force connection closed if the connection has indeed been used */\n        if(data->mstate > CURLM_STATE_DO) {\n          streamclose(data->easy_conn, \"Disconnected with pending data\");\n          stream_error = TRUE;\n        }\n        result = CURLE_OPERATION_TIMEDOUT;\n        (void)multi_done(&data->easy_conn, result, TRUE);\n        /* Skip the statemachine and go directly to error handling section. */\n        goto statemachine_end;\n      }\n    }\n\n    switch(data->mstate) {\n    case CURLM_STATE_INIT:\n      /* init this transfer. */\n      result = Curl_pretransfer(data);\n\n      if(!result) {\n        /* after init, go CONNECT */\n        multistate(data, CURLM_STATE_CONNECT);\n        Curl_pgrsTime(data, TIMER_STARTOP);\n        rc = CURLM_CALL_MULTI_PERFORM;\n      }\n      break;\n\n    case CURLM_STATE_CONNECT_PEND:\n      /* We will stay here until there is a connection available. Then\n         we try again in the CURLM_STATE_CONNECT state. */\n      break;\n\n    case CURLM_STATE_CONNECT:\n      /* Connect. We want to get a connection identifier filled in. */\n      Curl_pgrsTime(data, TIMER_STARTSINGLE);\n      result = Curl_connect(data, &data->easy_conn,\n                            &async, &protocol_connect);\n      if(CURLE_NO_CONNECTION_AVAILABLE == result) {\n        /* There was no connection available. We will go to the pending\n           state and wait for an available connection. */\n        multistate(data, CURLM_STATE_CONNECT_PEND);\n\n        /* add this handle to the list of connect-pending handles */\n        Curl_llist_insert_next(&multi->pending, multi->pending.tail, data,\n                               &data->connect_queue);\n        result = CURLE_OK;\n        break;\n      }\n\n      if(!result) {\n        /* Add this handle to the send or pend pipeline */\n        result = Curl_add_handle_to_pipeline(data, data->easy_conn);\n        if(result)\n          stream_error = TRUE;\n        else {\n          if(async)\n            /* We're now waiting for an asynchronous name lookup */\n            multistate(data, CURLM_STATE_WAITRESOLVE);\n          else {\n            /* after the connect has been sent off, go WAITCONNECT unless the\n               protocol connect is already done and we can go directly to\n               WAITDO or DO! */\n            rc = CURLM_CALL_MULTI_PERFORM;\n\n            if(protocol_connect)\n              multistate(data, Curl_pipeline_wanted(multi, CURLPIPE_HTTP1)?\n                         CURLM_STATE_WAITDO:CURLM_STATE_DO);\n            else {\n#ifndef CURL_DISABLE_HTTP\n              if(Curl_connect_ongoing(data->easy_conn))\n                multistate(data, CURLM_STATE_WAITPROXYCONNECT);\n              else\n#endif\n                multistate(data, CURLM_STATE_WAITCONNECT);\n            }\n          }\n        }\n      }\n      break;\n\n    case CURLM_STATE_WAITRESOLVE:\n      /* awaiting an asynch name resolve to complete */\n    {\n      struct Curl_dns_entry *dns = NULL;\n      struct connectdata *conn = data->easy_conn;\n      const char *hostname;\n\n      if(conn->bits.httpproxy)\n        hostname = conn->http_proxy.host.name;\n      else if(conn->bits.conn_to_host)\n        hostname = conn->conn_to_host.name;\n      else\n        hostname = conn->host.name;\n\n      /* check if we have the name resolved by now */\n      dns = Curl_fetch_addr(conn, hostname, (int)conn->port);\n\n      if(dns) {\n#ifdef CURLRES_ASYNCH\n        conn->async.dns = dns;\n        conn->async.done = TRUE;\n#endif\n        result = CURLE_OK;\n        infof(data, \"Hostname '%s' was found in DNS cache\\n\", hostname);\n      }\n\n      if(!dns)\n        result = Curl_resolver_is_resolved(data->easy_conn, &dns);\n\n      /* Update sockets here, because the socket(s) may have been\n         closed and the application thus needs to be told, even if it\n         is likely that the same socket(s) will again be used further\n         down.  If the name has not yet been resolved, it is likely\n         that new sockets have been opened in an attempt to contact\n         another resolver. */\n      singlesocket(multi, data);\n\n      if(dns) {\n        /* Perform the next step in the connection phase, and then move on\n           to the WAITCONNECT state */\n        result = Curl_async_resolved(data->easy_conn, &protocol_connect);\n\n        if(result)\n          /* if Curl_async_resolved() returns failure, the connection struct\n             is already freed and gone */\n          data->easy_conn = NULL;           /* no more connection */\n        else {\n          /* call again please so that we get the next socket setup */\n          rc = CURLM_CALL_MULTI_PERFORM;\n          if(protocol_connect)\n            multistate(data, Curl_pipeline_wanted(multi, CURLPIPE_HTTP1)?\n                       CURLM_STATE_WAITDO:CURLM_STATE_DO);\n          else {\n#ifndef CURL_DISABLE_HTTP\n            if(Curl_connect_ongoing(data->easy_conn))\n              multistate(data, CURLM_STATE_WAITPROXYCONNECT);\n            else\n#endif\n              multistate(data, CURLM_STATE_WAITCONNECT);\n          }\n        }\n      }\n\n      if(result) {\n        /* failure detected */\n        stream_error = TRUE;\n        break;\n      }\n    }\n    break;\n\n#ifndef CURL_DISABLE_HTTP\n    case CURLM_STATE_WAITPROXYCONNECT:\n      /* this is HTTP-specific, but sending CONNECT to a proxy is HTTP... */\n      result = Curl_http_connect(data->easy_conn, &protocol_connect);\n\n      if(data->easy_conn->bits.proxy_connect_closed) {\n        rc = CURLM_CALL_MULTI_PERFORM;\n        /* connect back to proxy again */\n        result = CURLE_OK;\n        multi_done(&data->easy_conn, CURLE_OK, FALSE);\n        multistate(data, CURLM_STATE_CONNECT);\n      }\n      else if(!result) {\n        if((data->easy_conn->http_proxy.proxytype != CURLPROXY_HTTPS ||\n           data->easy_conn->bits.proxy_ssl_connected[FIRSTSOCKET]) &&\n           Curl_connect_complete(data->easy_conn)) {\n          rc = CURLM_CALL_MULTI_PERFORM;\n          /* initiate protocol connect phase */\n          multistate(data, CURLM_STATE_SENDPROTOCONNECT);\n        }\n      }\n      break;\n#endif\n\n    case CURLM_STATE_WAITCONNECT:\n      /* awaiting a completion of an asynch TCP connect */\n      result = Curl_is_connected(data->easy_conn, FIRSTSOCKET, &connected);\n      if(connected && !result) {\n#ifndef CURL_DISABLE_HTTP\n        if((data->easy_conn->http_proxy.proxytype == CURLPROXY_HTTPS &&\n            !data->easy_conn->bits.proxy_ssl_connected[FIRSTSOCKET]) ||\n           Curl_connect_ongoing(data->easy_conn)) {\n          multistate(data, CURLM_STATE_WAITPROXYCONNECT);\n          break;\n        }\n#endif\n        rc = CURLM_CALL_MULTI_PERFORM;\n        multistate(data, data->easy_conn->bits.tunnel_proxy?\n                   CURLM_STATE_WAITPROXYCONNECT:\n                   CURLM_STATE_SENDPROTOCONNECT);\n      }\n      else if(result) {\n        /* failure detected */\n        /* Just break, the cleaning up is handled all in one place */\n        stream_error = TRUE;\n        break;\n      }\n      break;\n\n    case CURLM_STATE_SENDPROTOCONNECT:\n      result = Curl_protocol_connect(data->easy_conn, &protocol_connect);\n      if(!protocol_connect)\n        /* switch to waiting state */\n        multistate(data, CURLM_STATE_PROTOCONNECT);\n      else if(!result) {\n        /* protocol connect has completed, go WAITDO or DO */\n        multistate(data, Curl_pipeline_wanted(multi, CURLPIPE_HTTP1)?\n                   CURLM_STATE_WAITDO:CURLM_STATE_DO);\n        rc = CURLM_CALL_MULTI_PERFORM;\n      }\n      else if(result) {\n        /* failure detected */\n        Curl_posttransfer(data);\n        multi_done(&data->easy_conn, result, TRUE);\n        stream_error = TRUE;\n      }\n      break;\n\n    case CURLM_STATE_PROTOCONNECT:\n      /* protocol-specific connect phase */\n      result = Curl_protocol_connecting(data->easy_conn, &protocol_connect);\n      if(!result && protocol_connect) {\n        /* after the connect has completed, go WAITDO or DO */\n        multistate(data, Curl_pipeline_wanted(multi, CURLPIPE_HTTP1)?\n                   CURLM_STATE_WAITDO:CURLM_STATE_DO);\n        rc = CURLM_CALL_MULTI_PERFORM;\n      }\n      else if(result) {\n        /* failure detected */\n        Curl_posttransfer(data);\n        multi_done(&data->easy_conn, result, TRUE);\n        stream_error = TRUE;\n      }\n      break;\n\n    case CURLM_STATE_WAITDO:\n      /* Wait for our turn to DO when we're pipelining requests */\n      if(Curl_pipeline_checkget_write(data, data->easy_conn)) {\n        /* Grabbed the channel */\n        multistate(data, CURLM_STATE_DO);\n        rc = CURLM_CALL_MULTI_PERFORM;\n      }\n      break;\n\n    case CURLM_STATE_DO:\n      if(data->set.connect_only) {\n        /* keep connection open for application to use the socket */\n        connkeep(data->easy_conn, \"CONNECT_ONLY\");\n        multistate(data, CURLM_STATE_DONE);\n        result = CURLE_OK;\n        rc = CURLM_CALL_MULTI_PERFORM;\n      }\n      else {\n        /* Perform the protocol's DO action */\n        result = multi_do(&data->easy_conn, &dophase_done);\n\n        /* When multi_do() returns failure, data->easy_conn might be NULL! */\n\n        if(!result) {\n          if(!dophase_done) {\n            /* some steps needed for wildcard matching */\n            if(data->state.wildcardmatch) {\n              struct WildcardData *wc = &data->wildcard;\n              if(wc->state == CURLWC_DONE || wc->state == CURLWC_SKIP) {\n                /* skip some states if it is important */\n                multi_done(&data->easy_conn, CURLE_OK, FALSE);\n                multistate(data, CURLM_STATE_DONE);\n                rc = CURLM_CALL_MULTI_PERFORM;\n                break;\n              }\n            }\n            /* DO was not completed in one function call, we must continue\n               DOING... */\n            multistate(data, CURLM_STATE_DOING);\n            rc = CURLM_OK;\n          }\n\n          /* after DO, go DO_DONE... or DO_MORE */\n          else if(data->easy_conn->bits.do_more) {\n            /* we're supposed to do more, but we need to sit down, relax\n               and wait a little while first */\n            multistate(data, CURLM_STATE_DO_MORE);\n            rc = CURLM_OK;\n          }\n          else {\n            /* we're done with the DO, now DO_DONE */\n            multistate(data, CURLM_STATE_DO_DONE);\n            rc = CURLM_CALL_MULTI_PERFORM;\n          }\n        }\n        else if((CURLE_SEND_ERROR == result) &&\n                data->easy_conn->bits.reuse) {\n          /*\n           * In this situation, a connection that we were trying to use\n           * may have unexpectedly died.  If possible, send the connection\n           * back to the CONNECT phase so we can try again.\n           */\n          char *newurl = NULL;\n          followtype follow = FOLLOW_NONE;\n          CURLcode drc;\n          bool retry = FALSE;\n\n          drc = Curl_retry_request(data->easy_conn, &newurl);\n          if(drc) {\n            /* a failure here pretty much implies an out of memory */\n            result = drc;\n            stream_error = TRUE;\n          }\n          else\n            retry = (newurl)?TRUE:FALSE;\n\n          Curl_posttransfer(data);\n          drc = multi_done(&data->easy_conn, result, FALSE);\n\n          /* When set to retry the connection, we must to go back to\n           * the CONNECT state */\n          if(retry) {\n            if(!drc || (drc == CURLE_SEND_ERROR)) {\n              follow = FOLLOW_RETRY;\n              drc = Curl_follow(data, newurl, follow);\n              if(!drc) {\n                multistate(data, CURLM_STATE_CONNECT);\n                rc = CURLM_CALL_MULTI_PERFORM;\n                result = CURLE_OK;\n              }\n              else {\n                /* Follow failed */\n                result = drc;\n              }\n            }\n            else {\n              /* done didn't return OK or SEND_ERROR */\n              result = drc;\n            }\n          }\n          else {\n            /* Have error handler disconnect conn if we can't retry */\n            stream_error = TRUE;\n          }\n          free(newurl);\n        }\n        else {\n          /* failure detected */\n          Curl_posttransfer(data);\n          if(data->easy_conn)\n            multi_done(&data->easy_conn, result, FALSE);\n          stream_error = TRUE;\n        }\n      }\n      break;\n\n    case CURLM_STATE_DOING:\n      /* we continue DOING until the DO phase is complete */\n      result = Curl_protocol_doing(data->easy_conn,\n                                   &dophase_done);\n      if(!result) {\n        if(dophase_done) {\n          /* after DO, go DO_DONE or DO_MORE */\n          multistate(data, data->easy_conn->bits.do_more?\n                     CURLM_STATE_DO_MORE:\n                     CURLM_STATE_DO_DONE);\n          rc = CURLM_CALL_MULTI_PERFORM;\n        } /* dophase_done */\n      }\n      else {\n        /* failure detected */\n        Curl_posttransfer(data);\n        multi_done(&data->easy_conn, result, FALSE);\n        stream_error = TRUE;\n      }\n      break;\n\n    case CURLM_STATE_DO_MORE:\n      /*\n       * When we are connected, DO MORE and then go DO_DONE\n       */\n      result = multi_do_more(data->easy_conn, &control);\n\n      /* No need to remove this handle from the send pipeline here since that\n         is done in multi_done() */\n      if(!result) {\n        if(control) {\n          /* if positive, advance to DO_DONE\n             if negative, go back to DOING */\n          multistate(data, control == 1?\n                     CURLM_STATE_DO_DONE:\n                     CURLM_STATE_DOING);\n          rc = CURLM_CALL_MULTI_PERFORM;\n        }\n        else\n          /* stay in DO_MORE */\n          rc = CURLM_OK;\n      }\n      else {\n        /* failure detected */\n        Curl_posttransfer(data);\n        multi_done(&data->easy_conn, result, FALSE);\n        stream_error = TRUE;\n      }\n      break;\n\n    case CURLM_STATE_DO_DONE:\n      /* Move ourselves from the send to recv pipeline */\n      Curl_move_handle_from_send_to_recv_pipe(data, data->easy_conn);\n\n      if(data->easy_conn->bits.multiplex || data->easy_conn->send_pipe.size)\n        /* Check if we can move pending requests to send pipe */\n        process_pending_handles(multi); /*  pipelined/multiplexed */\n\n      /* Only perform the transfer if there's a good socket to work with.\n         Having both BAD is a signal to skip immediately to DONE */\n      if((data->easy_conn->sockfd != CURL_SOCKET_BAD) ||\n         (data->easy_conn->writesockfd != CURL_SOCKET_BAD))\n        multistate(data, CURLM_STATE_WAITPERFORM);\n      else\n      {\n        if(data->state.wildcardmatch &&\n           ((data->easy_conn->handler->flags & PROTOPT_WILDCARD) == 0)) {\n           data->wildcard.state = CURLWC_DONE;\n        }\n        multistate(data, CURLM_STATE_DONE);\n      }\n      rc = CURLM_CALL_MULTI_PERFORM;\n      break;\n\n    case CURLM_STATE_WAITPERFORM:\n      /* Wait for our turn to PERFORM */\n      if(Curl_pipeline_checkget_read(data, data->easy_conn)) {\n        /* Grabbed the channel */\n        multistate(data, CURLM_STATE_PERFORM);\n        rc = CURLM_CALL_MULTI_PERFORM;\n      }\n      break;\n\n    case CURLM_STATE_TOOFAST: /* limit-rate exceeded in either direction */\n      /* if both rates are within spec, resume transfer */\n      if(Curl_pgrsUpdate(data->easy_conn))\n        result = CURLE_ABORTED_BY_CALLBACK;\n      else\n        result = Curl_speedcheck(data, now);\n\n      if(!result) {\n        send_timeout_ms = 0;\n        if(data->set.max_send_speed > 0)\n          send_timeout_ms =\n            Curl_pgrsLimitWaitTime(data->progress.uploaded,\n                                   data->progress.ul_limit_size,\n                                   data->set.max_send_speed,\n                                   data->progress.ul_limit_start,\n                                   now);\n\n        recv_timeout_ms = 0;\n        if(data->set.max_recv_speed > 0)\n          recv_timeout_ms =\n            Curl_pgrsLimitWaitTime(data->progress.downloaded,\n                                   data->progress.dl_limit_size,\n                                   data->set.max_recv_speed,\n                                   data->progress.dl_limit_start,\n                                   now);\n\n        if(!send_timeout_ms && !recv_timeout_ms) {\n          multistate(data, CURLM_STATE_PERFORM);\n          Curl_ratelimit(data, now);\n        }\n        else if(send_timeout_ms >= recv_timeout_ms)\n          Curl_expire(data, send_timeout_ms, EXPIRE_TOOFAST);\n        else\n          Curl_expire(data, recv_timeout_ms, EXPIRE_TOOFAST);\n      }\n      break;\n\n    case CURLM_STATE_PERFORM:\n    {\n      char *newurl = NULL;\n      bool retry = FALSE;\n      bool comeback = FALSE;\n\n      /* check if over send speed */\n      send_timeout_ms = 0;\n      if(data->set.max_send_speed > 0)\n        send_timeout_ms = Curl_pgrsLimitWaitTime(data->progress.uploaded,\n                                                 data->progress.ul_limit_size,\n                                                 data->set.max_send_speed,\n                                                 data->progress.ul_limit_start,\n                                                 now);\n\n      /* check if over recv speed */\n      recv_timeout_ms = 0;\n      if(data->set.max_recv_speed > 0)\n        recv_timeout_ms = Curl_pgrsLimitWaitTime(data->progress.downloaded,\n                                                 data->progress.dl_limit_size,\n                                                 data->set.max_recv_speed,\n                                                 data->progress.dl_limit_start,\n                                                 now);\n\n      if(send_timeout_ms || recv_timeout_ms) {\n        Curl_ratelimit(data, now);\n        multistate(data, CURLM_STATE_TOOFAST);\n        if(send_timeout_ms >= recv_timeout_ms)\n          Curl_expire(data, send_timeout_ms, EXPIRE_TOOFAST);\n        else\n          Curl_expire(data, recv_timeout_ms, EXPIRE_TOOFAST);\n        break;\n      }\n\n      /* read/write data if it is ready to do so */\n      result = Curl_readwrite(data->easy_conn, data, &done, &comeback);\n\n      k = &data->req;\n\n      if(!(k->keepon & KEEP_RECV))\n        /* We're done receiving */\n        Curl_pipeline_leave_read(data->easy_conn);\n\n      if(!(k->keepon & KEEP_SEND))\n        /* We're done sending */\n        Curl_pipeline_leave_write(data->easy_conn);\n\n      if(done || (result == CURLE_RECV_ERROR)) {\n        /* If CURLE_RECV_ERROR happens early enough, we assume it was a race\n         * condition and the server closed the re-used connection exactly when\n         * we wanted to use it, so figure out if that is indeed the case.\n         */\n        CURLcode ret = Curl_retry_request(data->easy_conn, &newurl);\n        if(!ret)\n          retry = (newurl)?TRUE:FALSE;\n\n        if(retry) {\n          /* if we are to retry, set the result to OK and consider the\n             request as done */\n          result = CURLE_OK;\n          done = TRUE;\n        }\n      }\n\n      if(result) {\n        /*\n         * The transfer phase returned error, we mark the connection to get\n         * closed to prevent being re-used. This is because we can't possibly\n         * know if the connection is in a good shape or not now.  Unless it is\n         * a protocol which uses two \"channels\" like FTP, as then the error\n         * happened in the data connection.\n         */\n\n        if(!(data->easy_conn->handler->flags & PROTOPT_DUAL) &&\n           result != CURLE_HTTP2_STREAM)\n          streamclose(data->easy_conn, \"Transfer returned error\");\n\n        Curl_posttransfer(data);\n        multi_done(&data->easy_conn, result, TRUE);\n      }\n      else if(done) {\n        followtype follow = FOLLOW_NONE;\n\n        /* call this even if the readwrite function returned error */\n        Curl_posttransfer(data);\n\n        /* we're no longer receiving */\n        Curl_removeHandleFromPipeline(data, &data->easy_conn->recv_pipe);\n\n        /* expire the new receiving pipeline head */\n        if(data->easy_conn->recv_pipe.head)\n          Curl_expire(data->easy_conn->recv_pipe.head->ptr, 0, EXPIRE_RUN_NOW);\n\n        /* When we follow redirects or is set to retry the connection, we must\n           to go back to the CONNECT state */\n        if(data->req.newurl || retry) {\n          if(!retry) {\n            /* if the URL is a follow-location and not just a retried request\n               then figure out the URL here */\n            free(newurl);\n            newurl = data->req.newurl;\n            data->req.newurl = NULL;\n            follow = FOLLOW_REDIR;\n          }\n          else\n            follow = FOLLOW_RETRY;\n          result = multi_done(&data->easy_conn, CURLE_OK, FALSE);\n          if(!result) {\n            result = Curl_follow(data, newurl, follow);\n            if(!result) {\n              multistate(data, CURLM_STATE_CONNECT);\n              rc = CURLM_CALL_MULTI_PERFORM;\n            }\n          }\n        }\n        else {\n          /* after the transfer is done, go DONE */\n\n          /* but first check to see if we got a location info even though we're\n             not following redirects */\n          if(data->req.location) {\n            free(newurl);\n            newurl = data->req.location;\n            data->req.location = NULL;\n            result = Curl_follow(data, newurl, FOLLOW_FAKE);\n            if(result)\n              stream_error = TRUE;\n          }\n\n          multistate(data, CURLM_STATE_DONE);\n          rc = CURLM_CALL_MULTI_PERFORM;\n        }\n      }\n      else if(comeback)\n        rc = CURLM_CALL_MULTI_PERFORM;\n\n      free(newurl);\n      break;\n    }\n\n    case CURLM_STATE_DONE:\n      /* this state is highly transient, so run another loop after this */\n      rc = CURLM_CALL_MULTI_PERFORM;\n\n      if(data->easy_conn) {\n        CURLcode res;\n\n        /* Remove ourselves from the receive pipeline, if we are there. */\n        Curl_removeHandleFromPipeline(data, &data->easy_conn->recv_pipe);\n\n        if(data->easy_conn->bits.multiplex || data->easy_conn->send_pipe.size)\n          /* Check if we can move pending requests to connection */\n          process_pending_handles(multi); /* pipelined/multiplexing */\n\n        /* post-transfer command */\n        res = multi_done(&data->easy_conn, result, FALSE);\n\n        /* allow a previously set error code take precedence */\n        if(!result)\n          result = res;\n\n        /*\n         * If there are other handles on the pipeline, multi_done won't set\n         * easy_conn to NULL.  In such a case, curl_multi_remove_handle() can\n         * access free'd data, if the connection is free'd and the handle\n         * removed before we perform the processing in CURLM_STATE_COMPLETED\n         */\n        if(data->easy_conn)\n          data->easy_conn = NULL;\n      }\n\n      if(data->state.wildcardmatch) {\n        if(data->wildcard.state != CURLWC_DONE) {\n          /* if a wildcard is set and we are not ending -> lets start again\n             with CURLM_STATE_INIT */\n          multistate(data, CURLM_STATE_INIT);\n          break;\n        }\n      }\n\n      /* after we have DONE what we're supposed to do, go COMPLETED, and\n         it doesn't matter what the multi_done() returned! */\n      multistate(data, CURLM_STATE_COMPLETED);\n      break;\n\n    case CURLM_STATE_COMPLETED:\n      /* this is a completed transfer, it is likely to still be connected */\n\n      /* This node should be delinked from the list now and we should post\n         an information message that we are complete. */\n\n      /* Important: reset the conn pointer so that we don't point to memory\n         that could be freed anytime */\n      data->easy_conn = NULL;\n\n      Curl_expire_clear(data); /* stop all timers */\n      break;\n\n    case CURLM_STATE_MSGSENT:\n      data->result = result;\n      return CURLM_OK; /* do nothing */\n\n    default:\n      return CURLM_INTERNAL_ERROR;\n    }\n    statemachine_end:\n\n    if(data->mstate < CURLM_STATE_COMPLETED) {\n      if(result) {\n        /*\n         * If an error was returned, and we aren't in completed state now,\n         * then we go to completed and consider this transfer aborted.\n         */\n\n        /* NOTE: no attempt to disconnect connections must be made\n           in the case blocks above - cleanup happens only here */\n\n        data->state.pipe_broke = FALSE;\n\n        /* Check if we can move pending requests to send pipe */\n        process_pending_handles(multi); /* connection */\n\n        if(data->easy_conn) {\n          /* if this has a connection, unsubscribe from the pipelines */\n          Curl_pipeline_leave_write(data->easy_conn);\n          Curl_pipeline_leave_read(data->easy_conn);\n          Curl_removeHandleFromPipeline(data, &data->easy_conn->send_pipe);\n          Curl_removeHandleFromPipeline(data, &data->easy_conn->recv_pipe);\n\n          if(stream_error) {\n            /* Don't attempt to send data over a connection that timed out */\n            bool dead_connection = result == CURLE_OPERATION_TIMEDOUT;\n            /* disconnect properly */\n            Curl_disconnect(data->easy_conn, dead_connection);\n\n            /* This is where we make sure that the easy_conn pointer is reset.\n               We don't have to do this in every case block above where a\n               failure is detected */\n            data->easy_conn = NULL;\n          }\n        }\n        else if(data->mstate == CURLM_STATE_CONNECT) {\n          /* Curl_connect() failed */\n          (void)Curl_posttransfer(data);\n        }\n\n        multistate(data, CURLM_STATE_COMPLETED);\n      }\n      /* if there's still a connection to use, call the progress function */\n      else if(data->easy_conn && Curl_pgrsUpdate(data->easy_conn)) {\n        /* aborted due to progress callback return code must close the\n           connection */\n        result = CURLE_ABORTED_BY_CALLBACK;\n        streamclose(data->easy_conn, \"Aborted by callback\");\n\n        /* if not yet in DONE state, go there, otherwise COMPLETED */\n        multistate(data, (data->mstate < CURLM_STATE_DONE)?\n                   CURLM_STATE_DONE: CURLM_STATE_COMPLETED);\n        rc = CURLM_CALL_MULTI_PERFORM;\n      }\n    }\n\n    if(CURLM_STATE_COMPLETED == data->mstate) {\n      /* now fill in the Curl_message with this info */\n      msg = &data->msg;\n\n      msg->extmsg.msg = CURLMSG_DONE;\n      msg->extmsg.easy_handle = data;\n      msg->extmsg.data.result = result;\n\n      rc = multi_addmsg(multi, msg);\n\n      multistate(data, CURLM_STATE_MSGSENT);\n    }\n  } while((rc == CURLM_CALL_MULTI_PERFORM) || multi_ischanged(multi, FALSE));\n\n  data->result = result;\n\n\n  return rc;\n}\n\nCURLMcode curl_multi_perform(struct Curl_multi *multi, int *running_handles)\n{\n  struct Curl_easy *data;\n  CURLMcode returncode = CURLM_OK;\n  struct Curl_tree *t;\n  struct curltime now = Curl_now();\n\n  if(!GOOD_MULTI_HANDLE(multi))\n    return CURLM_BAD_HANDLE;\n\n  if(multi->in_callback)\n    return CURLM_RECURSIVE_API_CALL;\n\n  data = multi->easyp;\n  while(data) {\n    CURLMcode result;\n    SIGPIPE_VARIABLE(pipe_st);\n\n    sigpipe_ignore(data, &pipe_st);\n    result = multi_runsingle(multi, now, data);\n    sigpipe_restore(&pipe_st);\n\n    if(result)\n      returncode = result;\n\n    data = data->next; /* operate on next handle */\n  }\n\n  /*\n   * Simply remove all expired timers from the splay since handles are dealt\n   * with unconditionally by this function and curl_multi_timeout() requires\n   * that already passed/handled expire times are removed from the splay.\n   *\n   * It is important that the 'now' value is set at the entry of this function\n   * and not for the current time as it may have ticked a little while since\n   * then and then we risk this loop to remove timers that actually have not\n   * been handled!\n   */\n  do {\n    multi->timetree = Curl_splaygetbest(now, multi->timetree, &t);\n    if(t)\n      /* the removed may have another timeout in queue */\n      (void)add_next_timeout(now, multi, t->payload);\n\n  } while(t);\n\n  *running_handles = multi->num_alive;\n\n  if(CURLM_OK >= returncode)\n    update_timer(multi);\n\n  return returncode;\n}\n\nint fuzz_handle_transfer(FUZZ_DATA *fuzz)\n{\n  int rc = 0;\n  CURLM *multi_handle;\n  int still_running; /* keep number of running handles */\n  CURLMsg *msg; /* for picking up messages with the transfer status */\n  int msgs_left; /* how many messages are left */\n  int double_timeout = 0;\n  fd_set fdread;\n  fd_set fdwrite;\n  fd_set fdexcep;\n  struct timeval timeout;\n  int select_rc;\n  CURLMcode mc;\n  int maxfd = -1;\n  long curl_timeo = -1;\n  int ii;\n  FUZZ_SOCKET_MANAGER *sman[FUZZ_NUM_CONNECTIONS];\n\n  for(ii = 0; ii < FUZZ_NUM_CONNECTIONS; ii++) {\n    sman[ii] = &fuzz->sockman[ii];\n\n    /* Set up the starting index for responses. */\n    sman[ii]->response_index = 1;\n  }\n\n  /* init a multi stack */\n  multi_handle = curl_multi_init();\n\n  /* add the individual transfers */\n  curl_multi_add_handle(multi_handle, fuzz->easy);\n\n  /* Do an initial process. This might end the transfer immediately. */\n  curl_multi_perform(multi_handle, &still_running);\n  FV_PRINTF(fuzz,\n            \"FUZZ: Initial perform; still running? %d \\n\",\n            still_running);\n\n  while(still_running) {\n    /* Reset the sets of file descriptors. */\n    FD_ZERO(&fdread);\n    FD_ZERO(&fdwrite);\n    FD_ZERO(&fdexcep);\n\n    /* Set a timeout of 10ms. This is lower than recommended by the multi guide\n       but we're not going to any remote servers, so everything should complete\n       very quickly. */\n    timeout.tv_sec = 0;\n    timeout.tv_usec = 10000;\n\n    /* get file descriptors from the transfers */\n    mc = curl_multi_fdset(multi_handle, &fdread, &fdwrite, &fdexcep, &maxfd);\n    if(mc != CURLM_OK) {\n      fprintf(stderr, \"curl_multi_fdset() failed, code %d.\\n\", mc);\n      rc = -1;\n      break;\n    }\n\n    for(ii = 0; ii < FUZZ_NUM_CONNECTIONS; ii++) {\n      /* Add the socket FD into the readable set if connected. */\n      if(sman[ii]->fd_state == FUZZ_SOCK_OPEN) {\n        FD_SET(sman[ii]->fd, &fdread);\n\n        /* Work out the maximum FD between the cURL file descriptors and the\n           server FD. */\n        maxfd = FUZZ_MAX(sman[ii]->fd, maxfd);\n      }\n    }\n\n    /* Work out what file descriptors need work. */\n    rc = fuzz_select(maxfd + 1, &fdread, &fdwrite, &fdexcep, &timeout);\n\n    if(rc == -1) {\n      /* Had an issue while selecting a file descriptor. Let's just exit. */\n      FV_PRINTF(fuzz, \"FUZZ: select failed, exiting \\n\");\n      break;\n    }\n    else if(rc == 0) {\n      FV_PRINTF(fuzz,\n                \"FUZZ: Timed out; double timeout? %d \\n\",\n                double_timeout);\n\n      /* Timed out. */\n      if(double_timeout == 1) {\n        /* We don't expect multiple timeouts in a row. If there are double\n           timeouts then exit. */\n        break;\n      }\n      else {\n        /* Set the timeout flag for the next time we select(). */\n        double_timeout = 1;\n      }\n    }\n    else {\n      /* There's an active file descriptor. Reset the timeout flag. */\n      double_timeout = 0;\n    }\n\n    /* Check to see if a server file descriptor is readable. If it is,\n       then send the next response from the fuzzing data. */\n    for(ii = 0; ii < FUZZ_NUM_CONNECTIONS; ii++) {\n      if(sman[ii]->fd_state == FUZZ_SOCK_OPEN &&\n         FD_ISSET(sman[ii]->fd, &fdread)) {\n        rc = fuzz_send_next_response(fuzz, sman[ii]);\n        if(rc != 0) {\n          /* Failed to send a response. Break out here. */\n          break;\n        }\n      }\n    }\n\n    curl_multi_perform(multi_handle, &still_running);\n  }\n\n  /* Remove the easy handle from the multi stack. */\n  curl_multi_remove_handle(multi_handle, fuzz->easy);\n\n  /* Clean up the multi handle - the top level function will handle the easy\n     handle. */\n  curl_multi_cleanup(multi_handle);\n\n  return(rc);\n}\n\n\n// target function\nstatic void strcpy_url(char *output, const char *url, bool relative)\n{\n  /* we must add this with whitespace-replacing */\n  bool left = TRUE;\n  const unsigned char *iptr;\n  char *optr = output;\n  const unsigned char *host_sep = (const unsigned char *) url;\n\n  if(!relative)\n    host_sep = (const unsigned char *) find_host_sep(url);\n\n  for(iptr = (unsigned char *)url;    /* read from here */\n      *iptr;         /* until zero byte */\n      iptr++) {\n\n    if(iptr < host_sep) {\n      *optr++ = *iptr;\n      continue;\n    }\n\n    switch(*iptr) {\n    case '?':\n      left = FALSE;\n      /* fall through */\n    default:\n      if(!ISPRINT(*iptr)) {\n        snprintf(optr, 4, \"%%%02x\", *iptr);\n        optr += 3;\n      }\n      else\n        *optr++=*iptr;\n      break;\n    case ' ':\n      if(left) {\n        *optr++='%'; /* add a '%' */\n        *optr++='2'; /* add a '2' */\n        *optr++='0'; /* add a '0' */\n      }\n      else\n        *optr++='+'; /* add a '+' here */\n      break;\n    }\n  }\n  *optr = 0; /* zero terminate output buffer */\n\n}\n",
    "target": 1,
    "idx": 1008007,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\n\n\n\n\n\n\n\n\nstatic inline bool skcms_Parse(const void* buf, size_t len, skcms_ICCProfile* profile) {\n    // For continuity of existing user expectations,\n    // prefer A2B0 (perceptual) over A2B1 (relative colormetric), and ignore A2B2 (saturation).\n    const int priority[] = {0,1};\n    return skcms_ParseWithA2BPriority(buf, len,\n                                      priority, sizeof(priority)/sizeof(*priority),\n                                      profile);\n}\n\n\n// target function\nstatic bool read_curve_curv(const uint8_t* buf, uint32_t size,\n                            skcms_Curve* curve, uint32_t* curve_size) {\n    if (size < SAFE_FIXED_SIZE(curv_Layout)) {\n        return false;\n    }\n\n    const curv_Layout* curvTag = (const curv_Layout*)buf;\n\n    uint32_t value_count = read_big_u32(curvTag->value_count);\n    if (size < SAFE_FIXED_SIZE(curv_Layout) + value_count * SAFE_SIZEOF(uint16_t)) {\n        return false;\n    }\n\n    if (curve_size) {\n        *curve_size = SAFE_FIXED_SIZE(curv_Layout) + value_count * SAFE_SIZEOF(uint16_t);\n    }\n\n    if (value_count < 2) {\n        curve->table_entries = 0;\n        curve->parametric.a  = 1.0f;\n        curve->parametric.b  = 0.0f;\n        curve->parametric.c  = 0.0f;\n        curve->parametric.d  = 0.0f;\n        curve->parametric.e  = 0.0f;\n        curve->parametric.f  = 0.0f;\n        if (value_count == 0) {\n            // Empty tables are a shorthand for an identity curve\n            curve->parametric.g = 1.0f;\n        } else {\n            // Single entry tables are a shorthand for simple gamma\n            curve->parametric.g = read_big_u16(curvTag->variable) * (1.0f / 256.0f);\n        }\n    } else {\n        curve->table_8       = nullptr;\n        curve->table_16      = curvTag->variable;\n        curve->table_entries = value_count;\n    }\n\n    return true;\n}\n\n// Parses both curveType and parametricCurveType data. Ensures that at most 'size' bytes are read.\n// If curve_size is not nullptr, writes the number of bytes used by the curve in (*curve_size).\nstatic bool read_curve(const uint8_t* buf, uint32_t size,\n                       skcms_Curve* curve, uint32_t* curve_size) {\n    if (!buf || size < 4 || !curve) {\n        return false;\n    }\n\n    uint32_t type = read_big_u32(buf);\n    if (type == skcms_Signature_para) {\n        return read_curve_para(buf, size, curve, curve_size);\n    } else if (type == skcms_Signature_curv) {\n        return read_curve_curv(buf, size, curve, curve_size);\n    }\n\n    return false;\n}\n\n// mft1 and mft2 share a large chunk of data\ntypedef struct {\n    uint8_t type                 [ 4];\n    uint8_t reserved_a           [ 4];\n    uint8_t input_channels       [ 1];\n    uint8_t output_channels      [ 1];\n    uint8_t grid_points          [ 1];\n    uint8_t reserved_b           [ 1];\n    uint8_t matrix               [36];\n} mft_CommonLayout;\n\ntypedef struct {\n    mft_CommonLayout common      [1];\n\n    uint8_t variable             [1/*variable*/];\n} mft1_Layout;\n\ntypedef struct {\n    mft_CommonLayout common      [1];\n\n    uint8_t input_table_entries  [2];\n    uint8_t output_table_entries [2];\n    uint8_t variable             [1/*variable*/];\n} mft2_Layout;\n\nstatic bool read_mft_common(const mft_CommonLayout* mftTag, skcms_A2B* a2b) {\n    // MFT matrices are applied before the first set of curves, but must be identity unless the\n    // input is PCSXYZ. We don't support PCSXYZ profiles, so we ignore this matrix. Note that the\n    // matrix in skcms_A2B is applied later in the pipe, so supporting this would require another\n    // field/flag.\n    a2b->matrix_channels = 0;\n\n    a2b-> input_channels = mftTag-> input_channels[0];\n    a2b->output_channels = mftTag->output_channels[0];\n\n    for (uint32_t i = 0; i < a2b->input_channels; ++i) {\n        a2b->grid_points[i] = mftTag->grid_points[0];\n    }\n    // The grid only makes sense with at least two points along each axis\n    if (a2b->grid_points[0] < 2) {\n        return false;\n    }\n\n    // We require exactly three (ie XYZ/Lab/RGB) output channels\n    if (a2b->output_channels != ARRAY_COUNT(a2b->output_curves)) {\n        return false;\n    }\n    // We require at least one, and no more than four (ie CMYK) input channels\n    if (a2b->input_channels < 1 || a2b->input_channels > ARRAY_COUNT(a2b->input_curves)) {\n        return false;\n    }\n\n    return true;\n}\n\n// All as the A2B version above, except where noted.\nstatic bool read_mft_common(const mft_CommonLayout* mftTag, skcms_B2A* b2a) {\n    // All the same as A2B until the next comment...\n    b2a->matrix_channels = 0;\n\n    b2a-> input_channels = mftTag-> input_channels[0];\n    b2a->output_channels = mftTag->output_channels[0];\n\n    for (uint32_t i = 0; i < b2a->input_channels; ++i) {\n        b2a->grid_points[i] = mftTag->grid_points[0];\n    }\n    if (b2a->grid_points[0] < 2) {\n        return false;\n    }\n\n    // ...for B2A, exactly 3 *input* channels and 1-4 *output* channels.\n    if (b2a->input_channels != ARRAY_COUNT(b2a->input_curves)) {\n        return false;\n    }\n    if (b2a->output_channels < 1 || b2a->output_channels > ARRAY_COUNT(b2a->output_curves)) {\n        return false;\n    }\n\n    return true;\n}\n\ntemplate <typename A2B_or_B2A>\nstatic bool init_tables(const uint8_t* table_base, uint64_t max_tables_len, uint32_t byte_width,\n                        uint32_t input_table_entries, uint32_t output_table_entries,\n                        A2B_or_B2A* out) {\n    // byte_width is 1 or 2, [input|output]_table_entries are in [2, 4096], so no overflow\n    uint32_t byte_len_per_input_table  = input_table_entries * byte_width;\n    uint32_t byte_len_per_output_table = output_table_entries * byte_width;\n\n    // [input|output]_channels are <= 4, so still no overflow\n    uint32_t byte_len_all_input_tables  = out->input_channels * byte_len_per_input_table;\n    uint32_t byte_len_all_output_tables = out->output_channels * byte_len_per_output_table;\n\n    uint64_t grid_size = out->output_channels * byte_width;\n    for (uint32_t axis = 0; axis < out->input_channels; ++axis) {\n        grid_size *= out->grid_points[axis];\n    }\n\n    if (max_tables_len < byte_len_all_input_tables + grid_size + byte_len_all_output_tables) {\n        return false;\n    }\n\n    for (uint32_t i = 0; i < out->input_channels; ++i) {\n        out->input_curves[i].table_entries = input_table_entries;\n        if (byte_width == 1) {\n            out->input_curves[i].table_8  = table_base + i * byte_len_per_input_table;\n            out->input_curves[i].table_16 = nullptr;\n        } else {\n            out->input_curves[i].table_8  = nullptr;\n            out->input_curves[i].table_16 = table_base + i * byte_len_per_input_table;\n        }\n    }\n\n    if (byte_width == 1) {\n        out->grid_8  = table_base + byte_len_all_input_tables;\n        out->grid_16 = nullptr;\n    } else {\n        out->grid_8  = nullptr;\n        out->grid_16 = table_base + byte_len_all_input_tables;\n    }\n\n    const uint8_t* output_table_base = table_base + byte_len_all_input_tables + grid_size;\n    for (uint32_t i = 0; i < out->output_channels; ++i) {\n        out->output_curves[i].table_entries = output_table_entries;\n        if (byte_width == 1) {\n            out->output_curves[i].table_8  = output_table_base + i * byte_len_per_output_table;\n            out->output_curves[i].table_16 = nullptr;\n        } else {\n            out->output_curves[i].table_8  = nullptr;\n            out->output_curves[i].table_16 = output_table_base + i * byte_len_per_output_table;\n        }\n    }\n\n    return true;\n}\n\ntemplate <typename A2B_or_B2A>\nstatic bool read_tag_mft1(const skcms_ICCTag* tag, A2B_or_B2A* out) {\n    if (tag->size < SAFE_FIXED_SIZE(mft1_Layout)) {\n        return false;\n    }\n\n    const mft1_Layout* mftTag = (const mft1_Layout*)tag->buf;\n    if (!read_mft_common(mftTag->common, out)) {\n        return false;\n    }\n\n    uint32_t input_table_entries  = 256;\n    uint32_t output_table_entries = 256;\n\n    return init_tables(mftTag->variable, tag->size - SAFE_FIXED_SIZE(mft1_Layout), 1,\n                       input_table_entries, output_table_entries, out);\n}\n\ntemplate <typename A2B_or_B2A>\nstatic bool read_tag_mft2(const skcms_ICCTag* tag, A2B_or_B2A* out) {\n    if (tag->size < SAFE_FIXED_SIZE(mft2_Layout)) {\n        return false;\n    }\n\n    const mft2_Layout* mftTag = (const mft2_Layout*)tag->buf;\n    if (!read_mft_common(mftTag->common, out)) {\n        return false;\n    }\n\n    uint32_t input_table_entries = read_big_u16(mftTag->input_table_entries);\n    uint32_t output_table_entries = read_big_u16(mftTag->output_table_entries);\n\n    // ICC spec mandates that 2 <= table_entries <= 4096\n    if (input_table_entries < 2 || input_table_entries > 4096 ||\n        output_table_entries < 2 || output_table_entries > 4096) {\n        return false;\n    }\n\n    return init_tables(mftTag->variable, tag->size - SAFE_FIXED_SIZE(mft2_Layout), 2,\n                       input_table_entries, output_table_entries, out);\n}\n",
    "target": 1,
    "idx": 1032837,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "// context\nM3Result  ParseSection_Type  (IM3Module io_module, bytes_t i_bytes, cbytes_t i_end)\n{\n    M3Result result = m3Err_none;\n    IM3FuncType ftype = NULL;\n\n_try {\n    u32 numTypes;\n_   (ReadLEB_u32 (& numTypes, & i_bytes, i_end));                                   m3log (parse, \"** Type [%d]\", numTypes);\n\n    _throwif(\"too many types\", numTypes > d_m3MaxSaneTypesCount);\n\n    if (numTypes)\n    {\n        // table of IM3FuncType (that point to the actual M3FuncType struct in the Environment)\n        io_module->funcTypes = m3_AllocArray (IM3FuncType, numTypes);\n        _throwifnull(io_module->funcTypes);\n        io_module->numFuncTypes = numTypes;\n\n        for (u32 i = 0; i < numTypes; ++i)\n        {\n            i8 form;\n_           (ReadLEB_i7 (& form, & i_bytes, i_end));\n            _throwif (m3Err_wasmMalformed, form != -32); // for Wasm MVP\n\n            u32 numArgs;\n_           (ReadLEB_u32 (& numArgs, & i_bytes, i_end));\n\n            _throwif (m3Err_tooManyArgsRets, numArgs > d_m3MaxSaneFunctionArgRetCount);\n#if defined(M3_COMPILER_MSVC)\n            u8 argTypes [d_m3MaxSaneFunctionArgRetCount];\n#else\n            u8 argTypes[numArgs+1]; // make ubsan happy\n#endif\n            for (u32 a = 0; a < numArgs; ++a)\n            {\n                i8 wasmType;\n                u8 argType;\n_               (ReadLEB_i7 (& wasmType, & i_bytes, i_end));\n_               (NormalizeType (& argType, wasmType));\n\n                argTypes[a] = argType;\n            }\n\n            u32 numRets;\n_           (ReadLEB_u32 (& numRets, & i_bytes, i_end));\n            _throwif (m3Err_tooManyArgsRets, (u64)(numRets) + numArgs > d_m3MaxSaneFunctionArgRetCount);\n\n_           (AllocFuncType (& ftype, numRets + numArgs));\n            ftype->numArgs = numArgs;\n            ftype->numRets = numRets;\n\n            for (u32 r = 0; r < numRets; ++r)\n            {\n                i8 wasmType;\n                u8 retType;\n_               (ReadLEB_i7 (& wasmType, & i_bytes, i_end));\n_               (NormalizeType (& retType, wasmType));\n\n                ftype->types[r] = retType;\n            }\n            memcpy (ftype->types + numRets, argTypes, numArgs);                                 m3log (parse, \"    type %2d: %s\", i, SPrintFuncTypeSignature (ftype));\n\n            Environment_AddFuncType (io_module->environment, & ftype);\n            io_module->funcTypes [i] = ftype;\n            ftype = NULL; // ownership transfered to environment\n        }\n    }\n\n} _catch:\n\n    if (result)\n    {\n        m3_Free (ftype);\n        m3_Free (io_module->funcTypes);\n        io_module->numFuncTypes = 0;\n    }\n\n    return result;\n}\n\nM3Result  ParseModuleSection  (M3Module * o_module, u8 i_sectionType, bytes_t i_bytes, u32 i_numBytes)\n{\n    M3Result result = m3Err_none;\n\n    typedef M3Result (* M3Parser) (M3Module *, bytes_t, cbytes_t);\n\n    static M3Parser s_parsers [] =\n    {\n        ParseSection_Custom,    // 0\n        ParseSection_Type,      // 1\n        ParseSection_Import,    // 2\n        ParseSection_Function,  // 3\n        NULL,                   // 4: TODO Table\n        ParseSection_Memory,    // 5\n        ParseSection_Global,    // 6\n        ParseSection_Export,    // 7\n        ParseSection_Start,     // 8\n        ParseSection_Element,   // 9\n        ParseSection_Code,      // 10\n        ParseSection_Data,      // 11\n        NULL,                   // 12: TODO DataCount\n    };\n\n    M3Parser parser = NULL;\n\n    if (i_sectionType <= 12)\n        parser = s_parsers [i_sectionType];\n\n    if (parser)\n    {\n        cbytes_t end = i_bytes + i_numBytes;\n        result = parser (o_module, i_bytes, end);\n    }\n    else\n    {\n        m3log (parse, \" skipped section type: %d\", (u32) i_sectionType);\n    }\n\n    return result;\n}\n\nM3Result  m3_ParseModule  (IM3Environment i_environment, IM3Module * o_module, cbytes_t i_bytes, u32 i_numBytes)\n{\n    M3Result result;\n\n    IM3Module module;\n_try {\n    module = m3_AllocStruct (M3Module);\n    _throwifnull(module);\n    module->name = \".unnamed\";                                                      m3log (parse, \"load module: %d bytes\", i_numBytes);\n    module->startFunction = -1;\n    //module->hasWasmCodeCopy = false;\n    module->environment = i_environment;\n\n    const u8 * pos = i_bytes;\n    const u8 * end = pos + i_numBytes;\n\n    module->wasmStart = pos;\n    module->wasmEnd = end;\n\n    u32 magic, version;\n_   (Read_u32 (& magic, & pos, end));\n_   (Read_u32 (& version, & pos, end));\n\n    _throwif (m3Err_wasmMalformed, magic != 0x6d736100);\n    _throwif (m3Err_incompatibleWasmVersion, version != 1);\n                                                                                    m3log (parse,  \"found magic + version\");\n    u8 previousSection = 0;\n\n    while (pos < end)\n    {\n        u8 section;\n_       (ReadLEB_u7 (& section, & pos, end));\n\n        if (section > previousSection or                    // from the spec: sections must appear in order\n            section == 0 or                                 // custom section\n            (section == 12 and previousSection == 9) or     // if present, DataCount goes after Element\n            (section == 10 and previousSection == 12))      // and before Code\n        {\n            u32 sectionLength;\n_           (ReadLEB_u32 (& sectionLength, & pos, end));\n            _throwif(m3Err_wasmMalformed, pos + sectionLength > end);\n_           (ParseModuleSection (module, section, pos, sectionLength));\n\n            pos += sectionLength;\n\n            if (section)\n                previousSection = section;\n        }\n        else _throw (m3Err_misorderedWasmSection);\n    }\n\n    } _catch:\n\n\n// target function\nM3Result  SignatureToFuncType  (IM3FuncType * o_functionType, ccstr_t i_signature)\n{\n    M3Result result = m3Err_none;\n\n    IM3FuncType funcType = NULL;\n\n_try {\n    if (not o_functionType)\n        _throw (\"null function type\");\n\n    if (not i_signature)\n        _throw (\"null function signature\");\n\n    cstr_t sig = i_signature;\n\n    size_t maxNumTypes = strlen (i_signature);\n\n    // assume min signature is \"()\"\n    _throwif (m3Err_malformedFunctionSignature, maxNumTypes < 2);\n    maxNumTypes -= 2;\n\n    _throwif (m3Err_tooManyArgsRets, maxNumTypes > d_m3MaxSaneFunctionArgRetCount);\n\n_   (AllocFuncType (& funcType, (u32) maxNumTypes));\n\n    u8 * typelist = funcType->types;\n\n    bool parsingRets = true;\n    while (* sig)\n    {\n        char typeChar = * sig++;\n\n        if (typeChar == '(')\n        {\n            parsingRets = false;\n            continue;\n        }\n        else if ( typeChar == ' ')\n            continue;\n        else if (typeChar == ')')\n            break;\n\n        u8 type = ConvertTypeCharToTypeId (typeChar);\n\n        _throwif (\"unknown argument type char\", c_m3Type_unknown == type);\n\n        if (type == c_m3Type_none)\n            continue;\n\n        if (parsingRets)\n        {\n            _throwif (\"malformed signature; return count overflow\", funcType->numRets >= maxNumTypes);\n            funcType->numRets++;\n            *typelist++ = type;\n        }\n        else\n        {\n            _throwif (\"malformed signature; arg count overflow\", funcType->numRets + funcType->numArgs >= maxNumTypes);\n            funcType->numArgs++;\n            *typelist++ = type;\n        }\n    }\n\n} _catch:\n\n    if (result)\n        m3_Free (funcType);\n\n    * o_functionType = funcType;\n\n    return result;\n}\nM3Result  Compile_BlockStatements  (IM3Compilation o)\n{\n    M3Result result = m3Err_none;\n\n    _throwif (\"block code underrun\", o->wasm >= o->wasmEnd);\n\n    while (o->wasm < o->wasmEnd)\n    {                                                                   emit_stack_dump (o);\n        m3opcode_t opcode;\n        o->lastOpcodeStart = o->wasm;\n_       (Read_opcode (& opcode, & o->wasm, o->wasmEnd));                log_opcode (o, opcode);\n\n        // Restrict opcodes when evaluating expressions\n        if (not o->function) {\n            switch (opcode) {\n            case c_waOp_i32_const: case c_waOp_i64_const:\n            case c_waOp_f32_const: case c_waOp_f64_const:\n            case c_waOp_getGlobal: case c_waOp_end:\n                break;\n            default:\n                _throw(m3Err_restictedOpcode);\n            }\n        }\n\n        IM3OpInfo opinfo = GetOpInfo(opcode);\n        _throwif (m3Err_unknownOpcode, opinfo == NULL);\n\n        if (opinfo->compiler) {\n_           ((* opinfo->compiler) (o, opcode))\n        } else {\n_           (Compile_Operator (o, opcode));\n        }\n\n        o->previousOpcode = opcode;                             //                      m3logif (stack, dump_type_stack (o))\n\n        if (o->stackIndex > d_m3MaxFunctionStackHeight)         // TODO: is this only place to check?\n            _throw (m3Err_functionStackOverflow);\n\n        if (opcode == c_waOp_end or opcode == c_waOp_else)\n            break;\n    }\n\n_catch:\n    return result;\n}\nM3Result  InitDataSegments  (M3Memory * io_memory, IM3Module io_module)\n{\n    M3Result result = m3Err_none;\n\n    for (u32 i = 0; i < io_module->numDataSegments; ++i)\n    {\n        M3DataSegment * segment = & io_module->dataSegments [i];\n\n        i32 segmentOffset;\n        bytes_t start = segment->initExpr;\n_       (EvaluateExpression (io_module, & segmentOffset, c_m3Type_i32, & start, segment->initExpr + segment->initExprSize));\n\n        m3log (runtime, \"loading data segment: %d; size: %d; offset: %d\", i, segment->size, segmentOffset);\n\n        if (io_memory->mallocated)\n        {\n            u8 * dest = m3MemData (io_memory->mallocated) + segmentOffset;\n\n            if ((size_t) segmentOffset + segment->size <= io_memory->mallocated->length)\n                memcpy (dest, segment->data, segment->size);\n            else\n                _throw (\"data segment overflowing linear memory\");\n        }\n        else _throw (\"unallocated linear memory\");\n    }\n\n    _catch: return result;\n}\nM3Result  InitElements  (IM3Module io_module)\n{\n    M3Result result = m3Err_none;\n\n    bytes_t bytes = io_module->elementSection;\n    cbytes_t end = io_module->elementSectionEnd;\n\n    for (u32 i = 0; i < io_module->numElementSegments; ++i)\n    {\n        u32 index;\n_       (ReadLEB_u32 (& index, & bytes, end));\n\n        if (index == 0)\n        {\n            i32 offset;\n_           (EvaluateExpression (io_module, & offset, c_m3Type_i32, & bytes, end));\n            _throwif (\"table underflow\", offset < 0);\n\n            u32 numElements;\n_           (ReadLEB_u32 (& numElements, & bytes, end));\n\n            size_t endElement = numElements + offset;\n\n            io_module->table0 = m3_ReallocArray (IM3Function, io_module->table0, endElement, io_module->table0Size);\n            _throwifnull(io_module->table0);\n\n            _throwif (\"table overflow\", endElement > UINT_MAX)\n            io_module->table0Size = (u32) endElement;\n\n            for (u32 e = 0; e < numElements; ++e)\n            {\n                u32 functionIndex;\n_               (ReadLEB_u32 (& functionIndex, & bytes, end));\n                _throwif (\"function index out of range\", functionIndex >= io_module->numFunctions);\n                IM3Function function = & io_module->functions [functionIndex];      d_m3Assert (function); //printf (\"table: %s\\n\", m3_GetFunctionName(function));\n                io_module->table0 [e + offset] = function;\n            }\n        }\n        else _throw (\"element table index must be zero for MVP\");\n    }\n\n    _catch: return result;\n}\nM3Result  ParseSection_Type  (IM3Module io_module, bytes_t i_bytes, cbytes_t i_end)\n{\n    M3Result result = m3Err_none;\n    IM3FuncType ftype = NULL;\n\n_try {\n    u32 numTypes;\n_   (ReadLEB_u32 (& numTypes, & i_bytes, i_end));                                   m3log (parse, \"** Type [%d]\", numTypes);\n\n    _throwif(\"too many types\", numTypes > d_m3MaxSaneTypesCount);\n\n    if (numTypes)\n    {\n        // table of IM3FuncType (that point to the actual M3FuncType struct in the Environment)\n        io_module->funcTypes = m3_AllocArray (IM3FuncType, numTypes);\n        _throwifnull(io_module->funcTypes);\n        io_module->numFuncTypes = numTypes;\n\n        for (u32 i = 0; i < numTypes; ++i)\n        {\n            i8 form;\n_           (ReadLEB_i7 (& form, & i_bytes, i_end));\n            _throwif (m3Err_wasmMalformed, form != -32); // for Wasm MVP\n\n            u32 numArgs;\n_           (ReadLEB_u32 (& numArgs, & i_bytes, i_end));\n\n            _throwif (m3Err_tooManyArgsRets, numArgs > d_m3MaxSaneFunctionArgRetCount);\n#if defined(M3_COMPILER_MSVC)\n            u8 argTypes [d_m3MaxSaneFunctionArgRetCount];\n#else\n            u8 argTypes[numArgs+1]; // make ubsan happy\n#endif\n            for (u32 a = 0; a < numArgs; ++a)\n            {\n                i8 wasmType;\n                u8 argType;\n_               (ReadLEB_i7 (& wasmType, & i_bytes, i_end));\n_               (NormalizeType (& argType, wasmType));\n\n                argTypes[a] = argType;\n            }\n\n            u32 numRets;\n_           (ReadLEB_u32 (& numRets, & i_bytes, i_end));\n\n            _throwif (m3Err_tooManyArgsRets, numRets + numArgs > d_m3MaxSaneFunctionArgRetCount);\n\n_           (AllocFuncType (& ftype, numRets + numArgs));\n            ftype->numArgs = numArgs;\n            ftype->numRets = numRets;\n\n            for (u32 r = 0; r < numRets; ++r)\n            {\n                i8 wasmType;\n                u8 retType;\n_               (ReadLEB_i7 (& wasmType, & i_bytes, i_end));\n_               (NormalizeType (& retType, wasmType));\n\n                ftype->types[r] = retType;\n            }\n            memcpy (ftype->types + numRets, argTypes, numArgs);                                 m3log (parse, \"    type %2d: %s\", i, SPrintFuncTypeSignature (ftype));\n\n            Environment_AddFuncType (io_module->environment, & ftype);\n            io_module->funcTypes [i] = ftype;\n            ftype = NULL; // ownership transfered to environment\n        }\n    }\n\n} _catch:\n\n    if (result)\n    {\n        m3_Free (ftype);\n        m3_Free (io_module->funcTypes);\n        io_module->numFuncTypes = 0;\n    }\n\n    return result;\n}\n",
    "target": 1,
    "idx": 1033240,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "// context\nstatic INLINE void init_mt(VP9Decoder *pbi) {\n  int n;\n  VP9_COMMON *const cm = &pbi->common;\n  VP9LfSync *lf_row_sync = &pbi->lf_row_sync;\n  const int aligned_mi_cols = mi_cols_aligned_to_sb(cm->mi_cols);\n  const VPxWorkerInterface *const winterface = vpx_get_worker_interface();\n\n  if (pbi->num_tile_workers == 0) {\n    const int num_threads = pbi->max_threads;\n    CHECK_MEM_ERROR(cm, pbi->tile_workers,\n                    vpx_malloc(num_threads * sizeof(*pbi->tile_workers)));\n    for (n = 0; n < num_threads; ++n) {\n      VPxWorker *const worker = &pbi->tile_workers[n];\n      ++pbi->num_tile_workers;\n\n      winterface->init(worker);\n      if (n < num_threads - 1 && !winterface->reset(worker)) {\n        vpx_internal_error(&cm->error, VPX_CODEC_ERROR,\n                           \"Tile decoder thread creation failed\");\n      }\n    }\n  }\n\n  // Initialize LPF\n  if ((pbi->lpf_mt_opt || pbi->row_mt) && cm->lf.filter_level &&\n      !cm->skip_loop_filter) {\n    vp9_lpf_mt_init(lf_row_sync, cm, cm->lf.filter_level,\n                    pbi->num_tile_workers);\n  }\n\n  // Note: this memset assumes above_context[0], [1] and [2]\n  // are allocated as part of the same buffer.\n  memset(cm->above_context, 0,\n         sizeof(*cm->above_context) * MAX_MB_PLANE * 2 * aligned_mi_cols);\n\n  memset(cm->above_seg_context, 0,\n         sizeof(*cm->above_seg_context) * aligned_mi_cols);\n\n  vp9_reset_lfm(cm);\n}\n\n\n\nvoid vp9_decode_frame(VP9Decoder *pbi, const uint8_t *data,\n                      const uint8_t *data_end, const uint8_t **p_data_end) {\n  VP9_COMMON *const cm = &pbi->common;\n  MACROBLOCKD *const xd = &pbi->mb;\n  struct vpx_read_bit_buffer rb;\n  int context_updated = 0;\n  uint8_t clear_data[MAX_VP9_HEADER_SIZE];\n  const size_t first_partition_size = read_uncompressed_header(\n      pbi, init_read_bit_buffer(pbi, &rb, data, data_end, clear_data));\n  const int tile_rows = 1 << cm->log2_tile_rows;\n  const int tile_cols = 1 << cm->log2_tile_cols;\n  YV12_BUFFER_CONFIG *const new_fb = get_frame_new_buffer(cm);\n#if CONFIG_BITSTREAM_DEBUG || CONFIG_MISMATCH_DEBUG\n  bitstream_queue_set_frame_read(cm->current_video_frame * 2 + cm->show_frame);\n#endif\n#if CONFIG_MISMATCH_DEBUG\n  mismatch_move_frame_idx_r();\n#endif\n  xd->cur_buf = new_fb;\n\n  if (!first_partition_size) {\n    // showing a frame directly\n    *p_data_end = data + (cm->profile <= PROFILE_2 ? 1 : 2);\n    return;\n  }\n\n  data += vpx_rb_bytes_read(&rb);\n  if (!read_is_valid(data, first_partition_size, data_end))\n    vpx_internal_error(&cm->error, VPX_CODEC_CORRUPT_FRAME,\n                       \"Truncated packet or corrupt header length\");\n\n  cm->use_prev_frame_mvs =\n      !cm->error_resilient_mode && cm->width == cm->last_width &&\n      cm->height == cm->last_height && !cm->last_intra_only &&\n      cm->last_show_frame && (cm->last_frame_type != KEY_FRAME);\n\n  vp9_setup_block_planes(xd, cm->subsampling_x, cm->subsampling_y);\n\n  *cm->fc = cm->frame_contexts[cm->frame_context_idx];\n  if (!cm->fc->initialized)\n    vpx_internal_error(&cm->error, VPX_CODEC_CORRUPT_FRAME,\n                       \"Uninitialized entropy context.\");\n\n  xd->corrupted = 0;\n  new_fb->corrupted = read_compressed_header(pbi, data, first_partition_size);\n  if (new_fb->corrupted)\n    vpx_internal_error(&cm->error, VPX_CODEC_CORRUPT_FRAME,\n                       \"Decode failed. Frame data header is corrupted.\");\n\n  if (cm->lf.filter_level && !cm->skip_loop_filter) {\n    vp9_loop_filter_frame_init(cm, cm->lf.filter_level);\n  }\n\n  if (pbi->tile_worker_data == NULL ||\n      (tile_cols * tile_rows) != pbi->total_tiles) {\n    const int num_tile_workers =\n        tile_cols * tile_rows + ((pbi->max_threads > 1) ? pbi->max_threads : 0);\n    const size_t twd_size = num_tile_workers * sizeof(*pbi->tile_worker_data);\n    // Ensure tile data offsets will be properly aligned. This may fail on\n    // platforms without DECLARE_ALIGNED().\n    assert((sizeof(*pbi->tile_worker_data) % 16) == 0);\n    vpx_free(pbi->tile_worker_data);\n    CHECK_MEM_ERROR(cm, pbi->tile_worker_data, vpx_memalign(32, twd_size));\n    pbi->total_tiles = tile_rows * tile_cols;\n  }\n\n  if (pbi->max_threads > 1 && tile_rows == 1 &&\n      (tile_cols > 1 || pbi->row_mt == 1)) {\n    if (pbi->row_mt == 1) {\n      *p_data_end =\n          decode_tiles_row_wise_mt(pbi, data + first_partition_size, data_end);\n    } else {\n      // Multi-threaded tile decoder\n      *p_data_end = decode_tiles_mt(pbi, data + first_partition_size, data_end);\n      if (!pbi->lpf_mt_opt) {\n        if (!xd->corrupted) {\n          if (!cm->skip_loop_filter) {\n            // If multiple threads are used to decode tiles, then we use those\n            // threads to do parallel loopfiltering.\n            vp9_loop_filter_frame_mt(\n                new_fb, cm, pbi->mb.plane, cm->lf.filter_level, 0, 0,\n                pbi->tile_workers, pbi->num_tile_workers, &pbi->lf_row_sync);\n          }\n        } else {\n          vpx_internal_error(&cm->error, VPX_CODEC_CORRUPT_FRAME,\n                             \"Decode failed. Frame data is corrupted.\");\n        }\n      }\n    }\n  } else {\n    *p_data_end = decode_tiles(pbi, data + first_partition_size, data_end);\n  }\n\n  if (!xd->corrupted) {\n    if (!cm->error_resilient_mode && !cm->frame_parallel_decoding_mode) {\n      vp9_adapt_coef_probs(cm);\n\n      if (!frame_is_intra_only(cm)) {\n        vp9_adapt_mode_probs(cm);\n        vp9_adapt_mv_probs(cm, cm->allow_high_precision_mv);\n      }\n    }\n  } else {\n    vpx_internal_error(&cm->error, VPX_CODEC_CORRUPT_FRAME,\n                       \"Decode failed. Frame data is corrupted.\");\n  }\n\n  // Non frame parallel update frame context here.\n  if (cm->refresh_frame_context && !context_updated)\n    cm->frame_contexts[cm->frame_context_idx] = *cm->fc;\n}\n\nint vp9_receive_compressed_data(VP9Decoder *pbi, size_t size,\n                                const uint8_t **psource) {\n  VP9_COMMON *volatile const cm = &pbi->common;\n  BufferPool *volatile const pool = cm->buffer_pool;\n  RefCntBuffer *volatile const frame_bufs = cm->buffer_pool->frame_bufs;\n  const uint8_t *source = *psource;\n  int retcode = 0;\n  cm->error.error_code = VPX_CODEC_OK;\n\n  if (size == 0) {\n    // This is used to signal that we are missing frames.\n    // We do not know if the missing frame(s) was supposed to update\n    // any of the reference buffers, but we act conservative and\n    // mark only the last buffer as corrupted.\n    //\n    // TODO(jkoleszar): Error concealment is undefined and non-normative\n    // at this point, but if it becomes so, [0] may not always be the correct\n    // thing to do here.\n    if (cm->frame_refs[0].idx > 0) {\n      assert(cm->frame_refs[0].buf != NULL);\n      cm->frame_refs[0].buf->corrupted = 1;\n    }\n  }\n\n  pbi->ready_for_new_data = 0;\n\n  // Check if the previous frame was a frame without any references to it.\n  if (cm->new_fb_idx >= 0 && frame_bufs[cm->new_fb_idx].ref_count == 0 &&\n      !frame_bufs[cm->new_fb_idx].released) {\n    pool->release_fb_cb(pool->cb_priv,\n                        &frame_bufs[cm->new_fb_idx].raw_frame_buffer);\n    frame_bufs[cm->new_fb_idx].released = 1;\n  }\n\n  // Find a free frame buffer. Return error if can not find any.\n  cm->new_fb_idx = get_free_fb(cm);\n  if (cm->new_fb_idx == INVALID_IDX) {\n    pbi->ready_for_new_data = 1;\n    release_fb_on_decoder_exit(pbi);\n    vpx_clear_system_state();\n    vpx_internal_error(&cm->error, VPX_CODEC_MEM_ERROR,\n                       \"Unable to find free frame buffer\");\n    return cm->error.error_code;\n  }\n\n  // Assign a MV array to the frame buffer.\n  cm->cur_frame = &pool->frame_bufs[cm->new_fb_idx];\n\n  pbi->hold_ref_buf = 0;\n  pbi->cur_buf = &frame_bufs[cm->new_fb_idx];\n\n  if (setjmp(cm->error.jmp)) {\n    cm->error.setjmp = 0;\n    pbi->ready_for_new_data = 1;\n    release_fb_on_decoder_exit(pbi);\n    // Release current frame.\n    decrease_ref_count(cm->new_fb_idx, frame_bufs, pool);\n    vpx_clear_system_state();\n    return -1;\n  }\n\n  cm->error.setjmp = 1;\n  vp9_decode_frame(pbi, source, source + size, psource);\n\n  swap_frame_buffers(pbi);\n\n  vpx_clear_system_state();\n\n  if (!cm->show_existing_frame) {\n    cm->last_show_frame = cm->show_frame;\n    cm->prev_frame = cm->cur_frame;\n    if (cm->seg.enabled) vp9_swap_current_and_last_seg_map(cm);\n  }\n\n  if (cm->show_frame) cm->cur_show_frame_fb_idx = cm->new_fb_idx;\n\n  // Update progress in frame parallel decode.\n  cm->last_width = cm->width;\n  cm->last_height = cm->height;\n  if (cm->show_frame) {\n    cm->current_video_frame++;\n  }\n\n  cm->error.setjmp = 0;\n  return retcode;\n}\n\nstatic vpx_codec_err_t decode_one(vpx_codec_alg_priv_t *ctx,\n                                  const uint8_t **data, unsigned int data_sz,\n                                  void *user_priv, int64_t deadline) {\n  (void)deadline;\n\n  // Determine the stream parameters. Note that we rely on peek_si to\n  // validate that we have a buffer that does not wrap around the top\n  // of the heap.\n  if (!ctx->si.h) {\n    int is_intra_only = 0;\n    const vpx_codec_err_t res =\n        decoder_peek_si_internal(*data, data_sz, &ctx->si, &is_intra_only,\n                                 ctx->decrypt_cb, ctx->decrypt_state);\n    if (res != VPX_CODEC_OK) return res;\n\n    if (!ctx->si.is_kf && !is_intra_only) return VPX_CODEC_ERROR;\n  }\n\n  ctx->user_priv = user_priv;\n\n  // Set these even if already initialized.  The caller may have changed the\n  // decrypt config between frames.\n  ctx->pbi->decrypt_cb = ctx->decrypt_cb;\n  ctx->pbi->decrypt_state = ctx->decrypt_state;\n\n  if (vp9_receive_compressed_data(ctx->pbi, data_sz, data)) {\n    ctx->pbi->cur_buf->buf.corrupted = 1;\n    ctx->pbi->need_resync = 1;\n    ctx->need_resync = 1;\n    return update_error_state(ctx, &ctx->pbi->common.error);\n  }\n\n  check_resync(ctx, ctx->pbi);\n\n  return VPX_CODEC_OK;\n}\n\nstatic vpx_codec_err_t decoder_decode(vpx_codec_alg_priv_t *ctx,\n                                      const uint8_t *data, unsigned int data_sz,\n                                      void *user_priv, long deadline) {\n  const uint8_t *data_start = data;\n  const uint8_t *const data_end = data + data_sz;\n  vpx_codec_err_t res;\n  uint32_t frame_sizes[8];\n  int frame_count;\n\n  if (data == NULL && data_sz == 0) {\n    ctx->flushed = 1;\n    return VPX_CODEC_OK;\n  }\n\n  // Reset flushed when receiving a valid frame.\n  ctx->flushed = 0;\n\n  // Initialize the decoder on the first frame.\n  if (ctx->pbi == NULL) {\n    const vpx_codec_err_t res = init_decoder(ctx);\n    if (res != VPX_CODEC_OK) return res;\n  }\n\n  res = vp9_parse_superframe_index(data, data_sz, frame_sizes, &frame_count,\n                                   ctx->decrypt_cb, ctx->decrypt_state);\n  if (res != VPX_CODEC_OK) return res;\n\n  if (ctx->svc_decoding && ctx->svc_spatial_layer < frame_count - 1)\n    frame_count = ctx->svc_spatial_layer + 1;\n\n  // Decode in serial mode.\n  if (frame_count > 0) {\n    int i;\n\n    for (i = 0; i < frame_count; ++i) {\n      const uint8_t *data_start_copy = data_start;\n      const uint32_t frame_size = frame_sizes[i];\n      vpx_codec_err_t res;\n      if (data_start < data || frame_size > (uint32_t)(data_end - data_start)) {\n        set_error_detail(ctx, \"Invalid frame size in index\");\n        return VPX_CODEC_CORRUPT_FRAME;\n      }\n\n      res = decode_one(ctx, &data_start_copy, frame_size, user_priv, deadline);\n      if (res != VPX_CODEC_OK) return res;\n\n      data_start += frame_size;\n    }\n  } else {\n    while (data_start < data_end) {\n      const uint32_t frame_size = (uint32_t)(data_end - data_start);\n      const vpx_codec_err_t res =\n          decode_one(ctx, &data_start, frame_size, user_priv, deadline);\n      if (res != VPX_CODEC_OK) return res;\n\n      // Account for suboptimal termination by the encoder.\n      while (data_start < data_end) {\n        const uint8_t marker =\n            read_marker(ctx->decrypt_cb, ctx->decrypt_state, data_start);\n        if (marker) break;\n        ++data_start;\n      }\n    }\n  }\n\n  return res;\n}\n\nvpx_codec_err_t vpx_codec_decode(vpx_codec_ctx_t *ctx, const uint8_t *data,\n                                 unsigned int data_sz, void *user_priv,\n                                 long deadline) {\n  vpx_codec_err_t res;\n\n  /* Sanity checks */\n  /* NULL data ptr allowed if data_sz is 0 too */\n  if (!ctx || (!data && data_sz) || (data && !data_sz))\n    res = VPX_CODEC_INVALID_PARAM;\n  else if (!ctx->iface || !ctx->priv)\n    res = VPX_CODEC_ERROR;\n  else {\n    res = ctx->iface->dec.decode(get_alg_priv(ctx), data, data_sz, user_priv,\n                                 deadline);\n  }\n\n  return SAVE_STATUS(ctx, res);\n}\n\n\n// target function\nvoid ScaleForFrameNumber(unsigned int frame, unsigned int initial_w,\n                         unsigned int initial_h, unsigned int *w,\n                         unsigned int *h, bool flag_codec,\n                         bool smaller_width_larger_size_) {\n  if (smaller_width_larger_size_) {\n    if (frame < 30) {\n      *w = initial_w;\n      *h = initial_h;\n      return;\n    }\n    *w = initial_w * 7 / 10;\n    *h = initial_h * 16 / 10;\n    return;\n  }\n  if (frame < 10) {\n    *w = initial_w;\n    *h = initial_h;\n    return;\n  }\n  if (frame < 20) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }\n  if (frame < 30) {\n    *w = initial_w / 2;\n    *h = initial_h / 2;\n    return;\n  }\n  if (frame < 40) {\n    *w = initial_w;\n    *h = initial_h;\n    return;\n  }\n  if (frame < 50) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }\n  if (frame < 60) {\n    *w = initial_w / 2;\n    *h = initial_h / 2;\n    return;\n  }\n  if (frame < 70) {\n    *w = initial_w;\n    *h = initial_h;\n    return;\n  }\n  if (frame < 80) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }\n  if (frame < 90) {\n    *w = initial_w / 2;\n    *h = initial_h / 2;\n    return;\n  }\n  if (frame < 100) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }\n  if (frame < 110) {\n    *w = initial_w;\n    *h = initial_h;\n    return;\n  }\n  if (frame < 120) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }\n  if (frame < 130) {\n    *w = initial_w / 2;\n    *h = initial_h / 2;\n    return;\n  }\n  if (frame < 140) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }\n  if (frame < 150) {\n    *w = initial_w;\n    *h = initial_h;\n    return;\n  }\n  if (frame < 160) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }\n  if (frame < 170) {\n    *w = initial_w / 2;\n    *h = initial_h / 2;\n    return;\n  }\n  if (frame < 180) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }\n  if (frame < 190) {\n    *w = initial_w;\n    *h = initial_h;\n    return;\n  }\n  if (frame < 200) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }\n  if (frame < 210) {\n    *w = initial_w / 2;\n    *h = initial_h / 2;\n    return;\n  }\n  if (frame < 220) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }\n  if (frame < 230) {\n    *w = initial_w;\n    *h = initial_h;\n    return;\n  }\n  if (frame < 240) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }\n  if (frame < 250) {\n    *w = initial_w / 2;\n    *h = initial_h / 2;\n    return;\n  }\n  if (frame < 260) {\n    *w = initial_w;\n    *h = initial_h;\n    return;\n  }\n  // Go down very low.\n  if (frame < 270) {\n    *w = initial_w / 4;\n    *h = initial_h / 4;\n    return;\n  }\n  if (flag_codec == 1) {\n    // Cases that only works for VP9.\n    // For VP9: Swap width and height of original.\n    if (frame < 320) {\n      *w = initial_h;\n      *h = initial_w;\n      return;\n    }\n  }\n  *w = initial_w;\n  *h = initial_h;\n}\nint vp9_alloc_context_buffers(VP9_COMMON *cm, int width, int height) {\n  int new_mi_size;\n\n  vp9_set_mb_mi(cm, width, height);\n  new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);\n  if (cm->mi_alloc_size < new_mi_size) {\n    cm->free_mi(cm);\n    if (cm->alloc_mi(cm, new_mi_size)) goto fail;\n    vpx_free(cm->above_context);\n    cm->above_context = (ENTROPY_CONTEXT *)vpx_calloc(\n        2 * mi_cols_aligned_to_sb(cm->mi_cols) * MAX_MB_PLANE,\n        sizeof(*cm->above_context));\n    if (!cm->above_context) goto fail;\n\n    vpx_free(cm->above_seg_context);\n    cm->above_seg_context = (PARTITION_CONTEXT *)vpx_calloc(\n        mi_cols_aligned_to_sb(cm->mi_cols), sizeof(*cm->above_seg_context));\n    if (!cm->above_seg_context) goto fail;\n    cm->above_context_alloc_cols = cm->mi_cols;\n  }\n\n  if (cm->seg_map_alloc_size < cm->mi_rows * cm->mi_cols) {\n    // Create the segmentation map structure and set to 0.\n    free_seg_map(cm);\n    if (alloc_seg_map(cm, cm->mi_rows * cm->mi_cols)) goto fail;\n  }\n\n  if (vp9_alloc_loop_filter(cm)) goto fail;\n\n  return 0;\n\nfail:\n  // clear the mi_* values to force a realloc on resync\n  vp9_set_mb_mi(cm, 0, 0);\n  vp9_free_context_buffers(cm);\n  return 1;\n}\nstatic void free_copy_partition_data(VP9_COMP *cpi) {\n  vpx_free(cpi->prev_partition);\n  cpi->prev_partition = NULL;\n  vpx_free(cpi->prev_segment_id);\n  cpi->prev_segment_id = NULL;\n  vpx_free(cpi->prev_variance_low);\n  cpi->prev_variance_low = NULL;\n  vpx_free(cpi->copied_frame_cnt);\n  cpi->copied_frame_cnt = NULL;\n}\nvoid vp9_change_config(struct VP9_COMP *cpi, const VP9EncoderConfig *oxcf) {\n  VP9_COMMON *const cm = &cpi->common;\n  RATE_CONTROL *const rc = &cpi->rc;\n  int last_w = cpi->oxcf.width;\n  int last_h = cpi->oxcf.height;\n\n  vp9_init_quantizer(cpi);\n  if (cm->profile != oxcf->profile) cm->profile = oxcf->profile;\n  cm->bit_depth = oxcf->bit_depth;\n  cm->color_space = oxcf->color_space;\n  cm->color_range = oxcf->color_range;\n\n  cpi->target_level = oxcf->target_level;\n  cpi->keep_level_stats = oxcf->target_level != LEVEL_MAX;\n  set_level_constraint(&cpi->level_constraint,\n                       get_level_index(cpi->target_level));\n\n  if (cm->profile <= PROFILE_1)\n    assert(cm->bit_depth == VPX_BITS_8);\n  else\n    assert(cm->bit_depth > VPX_BITS_8);\n\n  cpi->oxcf = *oxcf;\n#if CONFIG_VP9_HIGHBITDEPTH\n  cpi->td.mb.e_mbd.bd = (int)cm->bit_depth;\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n\n  if ((oxcf->pass == 0) && (oxcf->rc_mode == VPX_Q)) {\n    rc->baseline_gf_interval = FIXED_GF_INTERVAL;\n  } else {\n    rc->baseline_gf_interval = (MIN_GF_INTERVAL + MAX_GF_INTERVAL) / 2;\n  }\n\n  cpi->refresh_golden_frame = 0;\n  cpi->refresh_last_frame = 1;\n  cm->refresh_frame_context = 1;\n  cm->reset_frame_context = 0;\n\n  vp9_reset_segment_features(&cm->seg);\n  vp9_set_high_precision_mv(cpi, 0);\n\n  {\n    int i;\n\n    for (i = 0; i < MAX_SEGMENTS; i++)\n      cpi->segment_encode_breakout[i] = cpi->oxcf.encode_breakout;\n  }\n  cpi->encode_breakout = cpi->oxcf.encode_breakout;\n\n  vp9_set_rc_buffer_sizes(cpi);\n\n  // Set up frame rate and related parameters rate control values.\n  vp9_new_framerate(cpi, cpi->framerate);\n\n  // Set absolute upper and lower quality limits\n  rc->worst_quality = cpi->oxcf.worst_allowed_q;\n  rc->best_quality = cpi->oxcf.best_allowed_q;\n\n  cm->interp_filter = cpi->sf.default_interp_filter;\n\n  if (cpi->oxcf.render_width > 0 && cpi->oxcf.render_height > 0) {\n    cm->render_width = cpi->oxcf.render_width;\n    cm->render_height = cpi->oxcf.render_height;\n  } else {\n    cm->render_width = cpi->oxcf.width;\n    cm->render_height = cpi->oxcf.height;\n  }\n  if (last_w != cpi->oxcf.width || last_h != cpi->oxcf.height) {\n    cm->width = cpi->oxcf.width;\n    cm->height = cpi->oxcf.height;\n    cpi->external_resize = 1;\n  }\n\n  if (cpi->initial_width) {\n    int new_mi_size = 0;\n    vp9_set_mb_mi(cm, cm->width, cm->height);\n    new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);\n    if (cm->mi_alloc_size < new_mi_size) {\n      vp9_free_context_buffers(cm);\n      vp9_free_pc_tree(&cpi->td);\n      vpx_free(cpi->mbmi_ext_base);\n      alloc_compressor_data(cpi);\n      realloc_segmentation_maps(cpi);\n      cpi->initial_width = cpi->initial_height = 0;\n      cpi->external_resize = 0;\n    } else if (cm->mi_alloc_size == new_mi_size &&\n               (cpi->oxcf.width > last_w || cpi->oxcf.height > last_h)) {\n      if (vp9_alloc_loop_filter(cm)) {\n        vpx_internal_error(&cm->error, VPX_CODEC_MEM_ERROR,\n                           \"Failed to allocate loop filter data\");\n      }\n    }\n  }\n\n  if (cm->current_video_frame == 0 || last_w != cpi->oxcf.width ||\n      last_h != cpi->oxcf.height)\n    update_frame_size(cpi);\n\n  if (last_w != cpi->oxcf.width || last_h != cpi->oxcf.height) {\n    vpx_free(cpi->consec_zero_mv);\n    CHECK_MEM_ERROR(\n        cm, cpi->consec_zero_mv,\n        vpx_calloc(cm->mi_rows * cm->mi_cols, sizeof(*cpi->consec_zero_mv)));\n\n    vpx_free(cpi->skin_map);\n    CHECK_MEM_ERROR(\n        cm, cpi->skin_map,\n        vpx_calloc(cm->mi_rows * cm->mi_cols, sizeof(cpi->skin_map[0])));\n\n    free_copy_partition_data(cpi);\n    alloc_copy_partition_data(cpi);\n    if (cpi->oxcf.aq_mode == CYCLIC_REFRESH_AQ)\n      vp9_cyclic_refresh_reset_resize(cpi);\n    rc->rc_1_frame = 0;\n    rc->rc_2_frame = 0;\n  }\n\n  if ((cpi->svc.number_temporal_layers > 1 && cpi->oxcf.rc_mode == VPX_CBR) ||\n      ((cpi->svc.number_temporal_layers > 1 ||\n        cpi->svc.number_spatial_layers > 1) &&\n       cpi->oxcf.pass != 1)) {\n    vp9_update_layer_context_change_config(cpi,\n                                           (int)cpi->oxcf.target_bandwidth);\n  }\n\n  vp9_check_reset_rc_flag(cpi);\n\n  cpi->alt_ref_source = NULL;\n  rc->is_src_frame_alt_ref = 0;\n\n#if 0\n  // Experimental RD Code\n  cpi->frame_distortion = 0;\n  cpi->last_frame_distortion = 0;\n#endif\n\n  set_tile_limits(cpi);\n\n  cpi->ext_refresh_frame_flags_pending = 0;\n  cpi->ext_refresh_frame_context_pending = 0;\n\n#if CONFIG_VP9_HIGHBITDEPTH\n  highbd_set_var_fns(cpi);\n#endif\n\n  vp9_set_row_mt(cpi);\n}\n",
    "target": 1,
    "idx": 1048609,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nstd::string toString(const T& arg) {\n  std::ostringstream os;\n  os << arg;\n  return os.str();\n}\n\nvoid QuickTimeVideo::userDataDecoder(size_t size_external) {\n  size_t cur_pos = io_->tell();\n  const TagVocabulary* td;\n  const TagVocabulary *tv, *tv_internal;\n\n  const long bufMinSize = 100;\n  DataBuf buf(bufMinSize);\n  size_t size_internal = size_external;\n  std::memset(buf.data(), 0x0, buf.size());\n\n  while ((size_internal / 4 != 0) && (size_internal > 0)) {\n    buf.data()[4] = '\\0';\n    io_->readOrThrow(buf.data(), 4);\n    const size_t size = buf.read_uint32(0, bigEndian);\n    if (size > size_internal)\n      break;\n    size_internal -= size;\n    io_->readOrThrow(buf.data(), 4);\n\n    if (buf.data()[0] == 169)\n      buf.data()[0] = ' ';\n    td = find(userDatatags, Exiv2::toString(buf.data()));\n\n    tv = find(userDataReferencetags, Exiv2::toString(buf.data()));\n\n    if (size <= 12)\n      break;\n\n    else if (equalsQTimeTag(buf, \"DcMD\") || equalsQTimeTag(buf, \"NCDT\"))\n      userDataDecoder(size - 8);\n\n    else if (equalsQTimeTag(buf, \"NCTG\"))\n      NikonTagsDecoder(size - 8);\n\n    else if (equalsQTimeTag(buf, \"TAGS\"))\n      CameraTagsDecoder(size - 8);\n\n    else if (equalsQTimeTag(buf, \"CNCV\") || equalsQTimeTag(buf, \"CNFV\") || equalsQTimeTag(buf, \"CNMN\") ||\n             equalsQTimeTag(buf, \"NCHD\") || equalsQTimeTag(buf, \"FFMV\")) {\n      io_->readOrThrow(buf.data(), size - 8);\n      xmpData_[exvGettext(tv->label_)] = Exiv2::toString(buf.data());\n    }\n\n    else if (equalsQTimeTag(buf, \"CMbo\") || equalsQTimeTag(buf, \"Cmbo\")) {\n      io_->readOrThrow(buf.data(), 2);\n      buf.data()[2] = '\\0';\n      tv_internal = find(cameraByteOrderTags, Exiv2::toString(buf.data()));\n\n      if (tv_internal)\n        xmpData_[exvGettext(tv->label_)] = exvGettext(tv_internal->label_);\n      else\n        xmpData_[exvGettext(tv->label_)] = Exiv2::toString(buf.data());\n    }\n\n    else if (tv) {\n      const size_t tv_size = size - 12;\n      if (tv_size >= buf.size()) {\n        enforce(tv_size <= io_->size() - io_->tell(), Exiv2::ErrorCode::kerCorruptedMetadata);\n        buf.resize(tv_size + 1);\n      }\n      io_->readOrThrow(buf.data(), 4);\n      io_->readOrThrow(buf.data(), tv_size);\n      buf.write_uint8(tv_size, 0); // nul-terminate string\n      xmpData_[exvGettext(tv->label_)] = Exiv2::toString(buf.data());\n    }\n\n    else if (td)\n      tagDecoder(buf, size - 8);\n  }\n\n  io_->seek(cur_pos + size_external, BasicIo::beg);\n}  // QuickTimeVideo::userDataDecoder\n\nvoid QuickTimeVideo::tagDecoder(Exiv2::DataBuf& buf, size_t size) {\n  assert(buf.size() > 4);\n\n  if (ignoreList(buf))\n    discard(size);\n\n  else if (dataIgnoreList(buf)) {\n    decodeBlock(Exiv2::toString(buf.data()));\n  } else if (equalsQTimeTag(buf, \"ftyp\"))\n    fileTypeDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"trak\"))\n    setMediaStream();\n\n  else if (equalsQTimeTag(buf, \"mvhd\"))\n    movieHeaderDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"tkhd\"))\n    trackHeaderDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"mdhd\"))\n    mediaHeaderDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"hdlr\"))\n    handlerDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"vmhd\"))\n    videoHeaderDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"udta\"))\n    userDataDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"dref\"))\n    multipleEntriesDecoder();\n\n  else if (equalsQTimeTag(buf, \"stsd\"))\n    sampleDesc(size);\n\n  else if (equalsQTimeTag(buf, \"stts\"))\n    timeToSampleDecoder();\n\n  else if (equalsQTimeTag(buf, \"pnot\"))\n    previewTagDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"tapt\"))\n    trackApertureTagDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"keys\"))\n    keysTagDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"url \")) {\n    Exiv2::DataBuf url(size + 1);\n    io_->readOrThrow(url.data(), size);\n    url.write_uint8(size, 0);\n    if (currentStream_ == Video)\n      xmpData_[\"Xmp.video.URL\"] = Exiv2::toString(url.data());\n    else if (currentStream_ == Audio)\n      xmpData_[\"Xmp.audio.URL\"] = Exiv2::toString(url.data());\n  }\n\n  else if (equalsQTimeTag(buf, \"urn \")) {\n    Exiv2::DataBuf urn(size + 1);\n    io_->readOrThrow(urn.data(), size);\n    urn.write_uint8(size, 0);\n    if (currentStream_ == Video)\n      xmpData_[\"Xmp.video.URN\"] = Exiv2::toString(urn.data());\n    else if (currentStream_ == Audio)\n      xmpData_[\"Xmp.audio.URN\"] = Exiv2::toString(urn.data());\n  }\n\n  else if (equalsQTimeTag(buf, \"dcom\")) {\n    Exiv2::DataBuf dcom(size + 1);\n    io_->readOrThrow(dcom.data(), size);\n    dcom.write_uint8(size, 0);\n    xmpData_[\"Xmp.video.Compressor\"] = Exiv2::toString(dcom.data());\n  }\n\n  else if (equalsQTimeTag(buf, \"smhd\")) {\n    io_->readOrThrow(buf.data(), 4);\n    io_->readOrThrow(buf.data(), 4);\n    xmpData_[\"Xmp.audio.Balance\"] = buf.read_uint16(0, bigEndian);\n  }\n\n  else {\n    discard(size);\n  }\n}  // QuickTimeVideo::tagDecoder\n\nvoid QuickTimeVideo::decodeBlock(std::string const& entered_from) {\n  const long bufMinSize = 4;\n  DataBuf buf(bufMinSize + 1);\n  uint64_t size = 0;\n  buf.data()[4] = '\\0';\n\n  io_->read(buf.data(), 4);\n  if (io_->eof()) {\n    continueTraversing_ = false;\n    return;\n  }\n\n  size = buf.read_uint32(0, bigEndian);\n\n  io_->readOrThrow(buf.data(), 4);\n\n  // we have read 2x 4 bytes\n  size_t hdrsize = 8;\n\n  if (size == 1) {\n    // The box size is encoded as a uint64_t, so we need to read another 8 bytes.\n    DataBuf data(8);\n    hdrsize += 8;\n    io_->readOrThrow(data.data(), data.size());\n    size = data.read_uint64(0, bigEndian);\n  } else if (size == 0) {\n    if (entered_from == \"meta\") {\n      size = buf.read_uint32(0, bigEndian);\n      io_->readOrThrow(buf.data(), 4, Exiv2::ErrorCode::kerCorruptedMetadata);\n    }\n  }\n\n  enforce(size >= hdrsize, Exiv2::ErrorCode::kerCorruptedMetadata);\n  enforce(size - hdrsize <= io_->size() - io_->tell(), Exiv2::ErrorCode::kerCorruptedMetadata);\n  enforce(size - hdrsize <= std::numeric_limits<size_t>::max(), Exiv2::ErrorCode::kerCorruptedMetadata);\n\n  // std::cerr<<\"Tag=>\"<<buf.data()<<\"     size=>\"<<size-hdrsize << std::endl;\n  const size_t newsize = static_cast<size_t>(size - hdrsize);\n  if (newsize > buf.size()) {\n    buf.resize(newsize);\n  }\n  tagDecoder(buf, newsize);\n}  // QuickTimeVideo::decodeBlock\n\nvoid QuickTimeVideo::readMetadata() {\n  if (io_->open() != 0)\n    throw Error(ErrorCode::kerDataSourceOpenFailed, io_->path(), strError());\n\n  // Ensure that this is the correct image type\n  if (!isQTimeType(*io_, false)) {\n    if (io_->error() || io_->eof())\n      throw Error(ErrorCode::kerFailedToReadImageData);\n    throw Error(ErrorCode::kerNotAnImage, \"QuickTime\");\n  }\n\n  IoCloser closer(*io_);\n  clearMetadata();\n  continueTraversing_ = true;\n  height_ = width_ = 1;\n\n  xmpData_[\"Xmp.video.FileSize\"] = (double)io_->size() / (double)1048576;\n  xmpData_[\"Xmp.video.MimeType\"] = mimeType();\n\n  while (continueTraversing_)\n    decodeBlock();\n\n  aspectRatio();\n}  // QuickTimeVideo::readMetadata\n\n\n// target function\nvoid QuickTimeVideo::userDataDecoder(size_t size_external) {\n  size_t cur_pos = io_->tell();\n  const TagVocabulary* td;\n  const TagVocabulary *tv, *tv_internal;\n\n  const long bufMinSize = 100;\n  DataBuf buf(bufMinSize);\n  size_t size_internal = size_external;\n  std::memset(buf.data(), 0x0, buf.size());\n\n  while ((size_internal / 4 != 0) && (size_internal > 0)) {\n    buf.data()[4] = '\\0';\n    io_->readOrThrow(buf.data(), 4);\n    const size_t size = buf.read_uint32(0, bigEndian);\n    if (size > size_internal)\n      break;\n    size_internal -= size;\n    io_->readOrThrow(buf.data(), 4);\n\n    if (buf.data()[0] == 169)\n      buf.data()[0] = ' ';\n    td = find(userDatatags, Exiv2::toString(buf.data()));\n\n    tv = find(userDataReferencetags, Exiv2::toString(buf.data()));\n\n    if (size <= 12)\n      break;\n\n    else if (equalsQTimeTag(buf, \"DcMD\") || equalsQTimeTag(buf, \"NCDT\"))\n      userDataDecoder(size - 8);\n\n    else if (equalsQTimeTag(buf, \"NCTG\"))\n      NikonTagsDecoder(size - 8);\n\n    else if (equalsQTimeTag(buf, \"TAGS\"))\n      CameraTagsDecoder(size - 8);\n\n    else if (equalsQTimeTag(buf, \"CNCV\") || equalsQTimeTag(buf, \"CNFV\") || equalsQTimeTag(buf, \"CNMN\") ||\n             equalsQTimeTag(buf, \"NCHD\") || equalsQTimeTag(buf, \"FFMV\")) {\n      io_->readOrThrow(buf.data(), size - 8);\n      xmpData_[exvGettext(tv->label_)] = Exiv2::toString(buf.data());\n    }\n\n    else if (equalsQTimeTag(buf, \"CMbo\") || equalsQTimeTag(buf, \"Cmbo\")) {\n      io_->readOrThrow(buf.data(), 2);\n      buf.data()[2] = '\\0';\n      tv_internal = find(cameraByteOrderTags, Exiv2::toString(buf.data()));\n\n      if (tv_internal)\n        xmpData_[exvGettext(tv->label_)] = exvGettext(tv_internal->label_);\n      else\n        xmpData_[exvGettext(tv->label_)] = Exiv2::toString(buf.data());\n    }\n\n    else if (tv) {\n      const size_t tv_size = size - 12;\n      if (tv_size > buf.size()) {\n        enforce(tv_size <= io_->size() - io_->tell(), Exiv2::ErrorCode::kerCorruptedMetadata);\n        buf.resize(tv_size);\n      }\n      io_->readOrThrow(buf.data(), 4);\n      io_->readOrThrow(buf.data(), tv_size);\n      xmpData_[exvGettext(tv->label_)] = Exiv2::toString(buf.data());\n    }\n\n    else if (td)\n      tagDecoder(buf, size - 8);\n  }\n\n  io_->seek(cur_pos + size_external, BasicIo::beg);\n}  // QuickTimeVideo::userDataDecoder\n",
    "target": 1,
    "idx": 1051707,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic size_t generateRandomSequences(FUZZ_dataProducer_t* producer,\n                                      size_t literalsSizeLimit, size_t dictSize,\n                                      size_t windowLog, ZSTD_sequenceFormat_e mode)\n{\n    const uint32_t repCode = 0;  /* not used by sequence ingestion api */\n    const uint32_t windowSize = 1 << windowLog;\n    const uint32_t blockSizeMax = MIN(128 << 10, 1 << windowLog);\n    uint32_t matchLengthMax = ZSTD_FUZZ_MATCHLENGTH_MAXSIZE;\n    uint32_t bytesGenerated = 0;\n    uint32_t nbSeqGenerated = 0;\n    uint32_t isFirstSequence = 1;\n    uint32_t blockSize = 0;\n\n    if (mode == ZSTD_sf_explicitBlockDelimiters) {\n        /* ensure that no sequence can be larger than one block */\n        literalsSizeLimit = MIN(literalsSizeLimit, blockSizeMax/2);\n        matchLengthMax = MIN(matchLengthMax, blockSizeMax/2);\n    }\n\n    while ( nbSeqGenerated < ZSTD_FUZZ_MAX_NBSEQ-2 /* extra room for explicit delimiters */\n         && bytesGenerated < ZSTD_FUZZ_GENERATED_SRC_MAXSIZE\n         && !FUZZ_dataProducer_empty(producer)) {\n        uint32_t matchLength;\n        uint32_t matchBound = matchLengthMax;\n        uint32_t offset;\n        uint32_t offsetBound;\n        const uint32_t minLitLength = (isFirstSequence && (dictSize == 0));\n        const uint32_t litLength = FUZZ_dataProducer_uint32Range(producer, minLitLength, (uint32_t)literalsSizeLimit);\n        bytesGenerated += litLength;\n        if (bytesGenerated > ZSTD_FUZZ_GENERATED_SRC_MAXSIZE) {\n            break;\n        }\n        offsetBound = (bytesGenerated > windowSize) ? windowSize : bytesGenerated + (uint32_t)dictSize;\n        offset = FUZZ_dataProducer_uint32Range(producer, 1, offsetBound);\n        if (dictSize > 0 && bytesGenerated <= windowSize) {\n            /* Prevent match length from being such that it would be associated with an offset too large\n             * from the decoder's perspective. If not possible (match would be too small),\n             * then reduce the offset if necessary.\n             */\n            const size_t bytesToReachWindowSize = windowSize - bytesGenerated;\n            if (bytesToReachWindowSize < ZSTD_MINMATCH_MIN) {\n                const uint32_t newOffsetBound = offsetBound > windowSize ? windowSize : offsetBound;\n                offset = FUZZ_dataProducer_uint32Range(producer, 1, newOffsetBound);\n            } else {\n                matchBound = MIN(matchLengthMax, (uint32_t)bytesToReachWindowSize);\n            }\n        }\n        matchLength = FUZZ_dataProducer_uint32Range(producer, ZSTD_MINMATCH_MIN, matchBound);\n        bytesGenerated += matchLength;\n        if (bytesGenerated > ZSTD_FUZZ_GENERATED_SRC_MAXSIZE) {\n            break;\n        }\n        {   ZSTD_Sequence seq = {offset, litLength, matchLength, repCode};\n            const uint32_t lastLits = FUZZ_dataProducer_uint32Range(producer, 0, litLength);\n            #define SPLITPROB 6000\n            #define SPLITMARK 5234\n            const int split = (FUZZ_dataProducer_uint32Range(producer, 0, SPLITPROB) == SPLITMARK);\n            if (mode == ZSTD_sf_explicitBlockDelimiters) {\n                const size_t seqSize = seq.litLength + seq.matchLength;\n                if (blockSize + seqSize > blockSizeMax) {  /* reaching limit : must end block now */\n                    const ZSTD_Sequence endBlock = {0, 0, 0, 0};\n                    generatedSequences[nbSeqGenerated++] = endBlock;\n                    blockSize = seqSize;\n                }\n                if (split) {\n                    const ZSTD_Sequence endBlock = {0, lastLits, 0, 0};\n                    generatedSequences[nbSeqGenerated++] = endBlock;\n                    assert(lastLits <= seq.litLength);\n                    seq.litLength -= lastLits;\n                    blockSize = seqSize - lastLits;\n                } else {\n                    blockSize += seqSize;\n                }\n            }\n            generatedSequences[nbSeqGenerated++] = seq;\n            isFirstSequence = 0;\n    }   }\n    if (mode == ZSTD_sf_explicitBlockDelimiters) {\n        /* always end sequences with a block delimiter */\n        const ZSTD_Sequence endBlock = {0, 0, 0, 0};\n        assert(nbSeqGenerated < ZSTD_FUZZ_MAX_NBSEQ);\n        generatedSequences[nbSeqGenerated++] = endBlock;\n    }\n\n    return nbSeqGenerated;\n}\n\n\n// target function\nstatic size_t generateRandomSequences(FUZZ_dataProducer_t* producer,\n                                      size_t literalsSizeLimit, size_t dictSize,\n                                      size_t windowLog, ZSTD_sequenceFormat_e mode)\n{\n    const uint32_t repCode = 0;  /* not used by sequence ingestion api */\n    const uint32_t windowSize = 1 << windowLog;\n    const uint32_t blockSizeMax = MIN(128 << 10, 1 << windowLog);\n    uint32_t matchLengthMax = ZSTD_FUZZ_MATCHLENGTH_MAXSIZE;\n    uint32_t bytesGenerated = 0;\n    uint32_t nbSeqGenerated = 0;\n    uint32_t isFirstSequence = 1;\n    uint32_t blockSize = 0;\n\n    if (mode == ZSTD_sf_explicitBlockDelimiters) {\n        /* ensure that no sequence can be larger than one block */\n        literalsSizeLimit = MIN(literalsSizeLimit, blockSizeMax/2);\n        matchLengthMax = MIN(matchLengthMax, blockSizeMax/2);\n    }\n\n    while ( nbSeqGenerated < ZSTD_FUZZ_MAX_NBSEQ-1\n         && bytesGenerated < ZSTD_FUZZ_GENERATED_SRC_MAXSIZE\n         && !FUZZ_dataProducer_empty(producer)) {\n        uint32_t matchLength;\n        uint32_t matchBound = matchLengthMax;\n        uint32_t offset;\n        uint32_t offsetBound;\n        const uint32_t minLitLength = (isFirstSequence && (dictSize == 0));\n        const uint32_t litLength = FUZZ_dataProducer_uint32Range(producer, minLitLength, (uint32_t)literalsSizeLimit);\n        bytesGenerated += litLength;\n        if (bytesGenerated > ZSTD_FUZZ_GENERATED_SRC_MAXSIZE) {\n            break;\n        }\n        offsetBound = (bytesGenerated > windowSize) ? windowSize : bytesGenerated + (uint32_t)dictSize;\n        offset = FUZZ_dataProducer_uint32Range(producer, 1, offsetBound);\n        if (dictSize > 0 && bytesGenerated <= windowSize) {\n            /* Prevent match length from being such that it would be associated with an offset too large\n             * from the decoder's perspective. If not possible (match would be too small),\n             * then reduce the offset if necessary.\n             */\n            const size_t bytesToReachWindowSize = windowSize - bytesGenerated;\n            if (bytesToReachWindowSize < ZSTD_MINMATCH_MIN) {\n                const uint32_t newOffsetBound = offsetBound > windowSize ? windowSize : offsetBound;\n                offset = FUZZ_dataProducer_uint32Range(producer, 1, newOffsetBound);\n            } else {\n                matchBound = MIN(matchLengthMax, (uint32_t)bytesToReachWindowSize);\n            }\n        }\n        matchLength = FUZZ_dataProducer_uint32Range(producer, ZSTD_MINMATCH_MIN, matchBound);\n        bytesGenerated += matchLength;\n        if (bytesGenerated > ZSTD_FUZZ_GENERATED_SRC_MAXSIZE) {\n            break;\n        }\n        {   ZSTD_Sequence seq = {offset, litLength, matchLength, repCode};\n            const uint32_t lastLits = FUZZ_dataProducer_uint32Range(producer, 0, litLength);\n            #define SPLITPROB 6000\n            #define SPLITMARK 5234\n            const int split = (FUZZ_dataProducer_uint32Range(producer, 0, SPLITPROB) == SPLITMARK);\n            if (mode == ZSTD_sf_explicitBlockDelimiters) {\n                const size_t seqSize = seq.litLength + seq.matchLength;\n                if (blockSize + seqSize > blockSizeMax) {  /* reaching limit : must end block now */\n                    const ZSTD_Sequence endBlock = {0, 0, 0, 0};\n                    generatedSequences[nbSeqGenerated++] = endBlock;\n                    blockSize = seqSize;\n                }\n                if (split) {\n                    const ZSTD_Sequence endBlock = {0, lastLits, 0, 0};\n                    generatedSequences[nbSeqGenerated++] = endBlock;\n                    assert(lastLits <= seq.litLength);\n                    seq.litLength -= lastLits;\n                    blockSize = seqSize - lastLits;\n                } else {\n                    blockSize += seqSize;\n                }\n            }\n            generatedSequences[nbSeqGenerated++] = seq;\n            isFirstSequence = 0;\n    }   }\n    if (mode == ZSTD_sf_explicitBlockDelimiters) {\n        /* always end sequences with a block delimiter */\n        const ZSTD_Sequence endBlock = {0, 0, 0, 0};\n        generatedSequences[nbSeqGenerated++] = endBlock;\n    }\n\n    return nbSeqGenerated;\n}\n",
    "target": 1,
    "idx": 1044122,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "// context\nint blosclz_compress(const int clevel, const void* input, int length,\n                     void* output, int maxout) {\n  uint8_t* ibase = (uint8_t*)input;\n  uint8_t* ip = ibase;\n  uint8_t* ip_bound = ibase + length - 1;\n  uint8_t* ip_limit = ibase + length - 12;\n  uint8_t* op = (uint8_t*)output;\n  uint8_t* op_limit;\n  uint32_t htab[1U << (uint8_t)HASH_LOG];\n  uint32_t hval;\n  uint32_t seq;\n  uint8_t copy;\n\n  op_limit = op + maxout;\n\n  // Minimum lengths for encoding\n  unsigned minlen_[10] = {0, 12, 12, 11, 10, 9, 8, 7, 6, 5};\n\n  // Minimum compression ratios for initiate encoding\n  double cratio_[10] = {0, 2, 2, 2, 2, 1.8, 1.6, 1.4, 1.2, 1.1};\n\n  uint8_t hashlog_[10] = {0, HASH_LOG - 2, HASH_LOG - 1, HASH_LOG, HASH_LOG,\n                          HASH_LOG, HASH_LOG, HASH_LOG, HASH_LOG, HASH_LOG};\n  uint8_t hashlog = hashlog_[clevel];\n  // Initialize the hash table to distances of 0\n  for (unsigned i = 0; i < (1U << hashlog); i++) {\n    htab[i] = 0;\n  }\n\n  /* input and output buffer cannot be less than 16 and 66 bytes or we can get into trouble */\n  if (length < 16 || maxout < 66) {\n    return 0;\n  }\n\n  /* When we go back in a match (shift), we obtain quite different compression properties.\n   * It looks like 4 is more useful in combination with bitshuffle and small typesizes\n   * (compress better and faster in e.g. `b2bench blosclz bitshuffle single 6 6291456 1 19`).\n   * Fallback to 4 because it provides more consistent results on small itemsizes.\n   *\n   * In this block we also check cratios for the beginning of the buffers and\n   * eventually discard those that are small (take too long to decompress).\n   * This process is called _entropy probing_.\n   */\n  int ipshift = 4;\n  int maxlen;  // maximum length for entropy probing\n  int csize_3b;\n  int csize_4b;\n  double cratio = 0;\n  switch (clevel) {\n    case 1:\n    case 2:\n    case 3:\n      maxlen = length / 8;\n      csize_4b = get_csize(ibase, maxlen, false);\n      cratio = (double)maxlen / csize_4b;\n      break;\n    case 4:\n    case 5:\n    case 6:\n    case 7:\n    case 8:\n      maxlen = length / 8;\n      csize_4b = get_csize(ibase, maxlen, false);\n      cratio = (double)maxlen / csize_4b;\n      break;\n    case 9:\n      // case 9 is special.  we need to asses the optimal shift\n      maxlen = length / 8;\n      csize_3b = get_csize(ibase, maxlen, true);\n      csize_4b = get_csize(ibase, maxlen, false);\n      ipshift = (csize_3b < csize_4b) ? 3 : 4;\n      cratio = (csize_3b < csize_4b) ? ((double)maxlen / csize_3b) : ((double)maxlen / csize_4b);\n      break;\n    default:\n      break;\n  }\n  // discard probes with small compression ratios (too expensive)\n  if (cratio < cratio_ [clevel]) {\n    goto out;\n  }\n\n  /* we start with literal copy */\n  copy = 4;\n  *op++ = MAX_COPY - 1;\n  *op++ = *ip++;\n  *op++ = *ip++;\n  *op++ = *ip++;\n  *op++ = *ip++;\n\n  /* main loop */\n  while (BLOSCLZ_LIKELY(ip < ip_limit)) {\n    const uint8_t* ref;\n    unsigned distance;\n    uint8_t* anchor = ip;    /* comparison starting-point */\n\n    /* find potential match */\n    seq = BLOSCLZ_READU32(ip);\n    HASH_FUNCTION(hval, seq, hashlog)\n    ref = ibase + htab[hval];\n\n    /* calculate distance to the match */\n    distance = anchor - ref;\n\n    /* update hash table */\n    htab[hval] = (uint32_t) (anchor - ibase);\n\n    if (distance == 0 || (distance >= MAX_FARDISTANCE)) {\n      LITERAL(ip, op, op_limit, anchor, copy)\n      continue;\n    }\n\n    /* is this a match? check the first 4 bytes */\n    if (BLOSCLZ_UNLIKELY(BLOSCLZ_READU32(ref) == BLOSCLZ_READU32(ip))) {\n      ref += 4;\n    } else {\n      /* no luck, copy as a literal */\n      LITERAL(ip, op, op_limit, anchor, copy)\n      continue;\n    }\n\n    /* last matched byte */\n    ip = anchor + 4;\n\n    /* distance is biased */\n    distance--;\n\n    /* get runs or matches; zero distance means a run */\n    ip = get_run_or_match(ip, ip_bound, ref, !distance);\n\n    /* length is biased, '1' means a match of 3 bytes */\n    ip -= ipshift;\n\n    unsigned len = (int)(ip - anchor);\n    // If match is close, let's reduce the minimum length to encode it\n    unsigned minlen = (clevel == 9) ? ipshift : minlen_[clevel];\n\n    // Encoding short lengths is expensive during decompression\n    // Encode only for reasonable lengths (extensive experiments done)\n    if (len < minlen || (len <= 5 && distance >= MAX_DISTANCE)) {\n      LITERAL(ip, op, op_limit, anchor, copy)\n      continue;\n    }\n\n    /* if we have copied something, adjust the copy count */\n    if (copy)\n      /* copy is biased, '0' means 1 byte copy */\n      *(op - copy - 1) = (uint8_t)(copy - 1);\n    else\n      /* back, to overwrite the copy count */\n      op--;\n    /* reset literal counter */\n    copy = 0;\n\n    /* encode the match */\n    if (distance < MAX_DISTANCE) {\n      if (len < 7) {\n        DISTANCE_SHORT(op, op_limit, len, distance)\n      } else {\n        DISTANCE_LONG(op, op_limit, len, distance)\n      }\n    } else {\n      /* far away, but not yet in the another galaxy... */\n      distance -= MAX_DISTANCE;\n      if (len < 7) {\n        DISTANCE_SHORT_FAR(op, op_limit, len, distance)\n      } else {\n        DISTANCE_LONG_FAR(op, op_limit, len, distance)\n      }\n    }\n\n    /* update the hash at match boundary */\n    seq = BLOSCLZ_READU32(ip);\n    HASH_FUNCTION(hval, seq, hashlog)\n    htab[hval] = (uint32_t) (ip++ - ibase);\n    seq >>= 8U;\n    HASH_FUNCTION(hval, seq, hashlog)\n    htab[hval] = (uint32_t) (ip++ - ibase);\n    /* assuming literal copy */\n\n    if (BLOSCLZ_UNLIKELY(op + 1 > op_limit))\n      goto out;\n    *op++ = MAX_COPY - 1;\n  }\n\n  /* left-over as literal copy */\n  while (BLOSCLZ_UNLIKELY(ip <= ip_bound)) {\n    if (BLOSCLZ_UNLIKELY(op + 2 > op_limit)) goto out;\n    *op++ = *ip++;\n    copy++;\n    if (BLOSCLZ_UNLIKELY(copy == MAX_COPY)) {\n      copy = 0;\n      *op++ = MAX_COPY - 1;\n    }\n  }\n\n  /* if we have copied something, adjust the copy length */\n  if (copy)\n    *(op - copy - 1) = (uint8_t)(copy - 1);\n  else\n    op--;\n\n  /* marker for blosclz */\n  *(uint8_t*)output |= (1U << 5U);\n\n  return (int)(op - (uint8_t*)output);\n\n  out:\n  return 0;\n}\n\nstatic int blosc_c(const struct blosc_context* context, int32_t blocksize,\n                   int32_t leftoverblock, int32_t ntbytes, int32_t maxbytes,\n                   const uint8_t *src, uint8_t *dest, uint8_t *tmp,\n                   uint8_t *tmp2)\n{\n  int8_t header_flags = *(context->header_flags);\n  int dont_split = (header_flags & 0x10) >> 4;\n  int32_t j, neblock, nsplits;\n  int32_t cbytes;                   /* number of compressed bytes in split */\n  int32_t ctbytes = 0;              /* number of compressed bytes in block */\n  int32_t maxout;\n  int32_t typesize = context->typesize;\n  const uint8_t *_tmp = src;\n  const char *compname;\n  int accel;\n  int bscount;\n  int doshuffle = (header_flags & BLOSC_DOSHUFFLE) && (typesize > 1);\n  int dobitshuffle = ((header_flags & BLOSC_DOBITSHUFFLE) &&\n                      (blocksize >= typesize));\n\n  if (doshuffle) {\n    /* Byte shuffling only makes sense if typesize > 1 */\n    blosc_internal_shuffle(typesize, blocksize, src, tmp);\n    _tmp = tmp;\n  }\n  /* We don't allow more than 1 filter at the same time (yet) */\n  else if (dobitshuffle) {\n    bscount = blosc_internal_bitshuffle(typesize, blocksize, src, tmp, tmp2);\n    if (bscount < 0)\n      return bscount;\n    _tmp = tmp;\n  }\n\n  /* Calculate acceleration for different compressors */\n  accel = get_accel(context);\n\n  /* The number of splits for this block */\n  if (!dont_split && !leftoverblock) {\n    nsplits = typesize;\n  }\n  else {\n    nsplits = 1;\n  }\n  neblock = blocksize / nsplits;\n  for (j = 0; j < nsplits; j++) {\n    dest += sizeof(int32_t);\n    ntbytes += (int32_t)sizeof(int32_t);\n    ctbytes += (int32_t)sizeof(int32_t);\n    maxout = neblock;\n    #if defined(HAVE_SNAPPY)\n    if (context->compcode == BLOSC_SNAPPY) {\n      /* TODO perhaps refactor this to keep the value stashed somewhere */\n      maxout = snappy_max_compressed_length(neblock);\n    }\n    #endif /*  HAVE_SNAPPY */\n    if (ntbytes+maxout > maxbytes) {\n      maxout = maxbytes - ntbytes;   /* avoid buffer overrun */\n      if (maxout <= 0) {\n        return 0;                  /* non-compressible block */\n      }\n    }\n    if (context->compcode == BLOSC_BLOSCLZ) {\n      cbytes = blosclz_compress(context->clevel, _tmp+j*neblock, neblock,\n                                dest, maxout);\n    }\n    #if defined(HAVE_LZ4)\n    else if (context->compcode == BLOSC_LZ4) {\n      cbytes = lz4_wrap_compress((char *)_tmp+j*neblock, (size_t)neblock,\n                                 (char *)dest, (size_t)maxout, accel);\n    }\n    else if (context->compcode == BLOSC_LZ4HC) {\n      cbytes = lz4hc_wrap_compress((char *)_tmp+j*neblock, (size_t)neblock,\n                                   (char *)dest, (size_t)maxout,\n                                   context->clevel);\n    }\n    #endif /* HAVE_LZ4 */\n    #if defined(HAVE_SNAPPY)\n    else if (context->compcode == BLOSC_SNAPPY) {\n      cbytes = snappy_wrap_compress((char *)_tmp+j*neblock, (size_t)neblock,\n                                    (char *)dest, (size_t)maxout);\n    }\n    #endif /* HAVE_SNAPPY */\n    #if defined(HAVE_ZLIB)\n    else if (context->compcode == BLOSC_ZLIB) {\n      cbytes = zlib_wrap_compress((char *)_tmp+j*neblock, (size_t)neblock,\n                                  (char *)dest, (size_t)maxout,\n                                  context->clevel);\n    }\n    #endif /* HAVE_ZLIB */\n    #if defined(HAVE_ZSTD)\n    else if (context->compcode == BLOSC_ZSTD) {\n      cbytes = zstd_wrap_compress((char*)_tmp + j * neblock, (size_t)neblock,\n                                  (char*)dest, (size_t)maxout, context->clevel);\n    }\n    #endif /* HAVE_ZSTD */\n\n    else {\n      blosc_compcode_to_compname(context->compcode, &compname);\n      if (compname == NULL) {\n          compname = \"(null)\";\n      }\n      fprintf(stderr, \"Blosc has not been compiled with '%s' \", compname);\n      fprintf(stderr, \"compression support.  Please use one having it.\");\n      return -5;    /* signals no compression support */\n    }\n\n    if (cbytes > maxout) {\n      /* Buffer overrun caused by compression (should never happen) */\n      return -1;\n    }\n    else if (cbytes < 0) {\n      /* cbytes should never be negative */\n      return -2;\n    }\n    else if (cbytes == 0 || cbytes == neblock) {\n      /* The compressor has been unable to compress data at all. */\n      /* Before doing the copy, check that we are not running into a\n         buffer overflow. */\n      if ((ntbytes+neblock) > maxbytes) {\n        return 0;    /* Non-compressible data */\n      }\n      fastcopy(dest, _tmp + j * neblock, neblock);\n      cbytes = neblock;\n    }\n    _sw32(dest - 4, cbytes);\n    dest += cbytes;\n    ntbytes += cbytes;\n    ctbytes += cbytes;\n  }  /* Closes j < nsplits */\n\n  return ctbytes;\n}\n\nstatic int serial_blosc(struct blosc_context* context)\n{\n  int32_t j, bsize, leftoverblock;\n  int32_t cbytes;\n\n  int32_t ebsize = context->blocksize + context->typesize * (int32_t)sizeof(int32_t);\n  int32_t ntbytes = context->num_output_bytes;\n\n  uint8_t *tmp = my_malloc(context->blocksize + ebsize);\n  uint8_t *tmp2 = tmp + context->blocksize;\n\n  for (j = 0; j < context->nblocks; j++) {\n    if (context->compress && !(*(context->header_flags) & BLOSC_MEMCPYED)) {\n      _sw32(context->bstarts + j * 4, ntbytes);\n    }\n    bsize = context->blocksize;\n    leftoverblock = 0;\n    if ((j == context->nblocks - 1) && (context->leftover > 0)) {\n      bsize = context->leftover;\n      leftoverblock = 1;\n    }\n    if (context->compress) {\n      if (*(context->header_flags) & BLOSC_MEMCPYED) {\n        /* We want to memcpy only */\n        fastcopy(context->dest + BLOSC_MAX_OVERHEAD + j * context->blocksize,\n                 context->src + j * context->blocksize, bsize);\n        cbytes = bsize;\n      }\n      else {\n        /* Regular compression */\n        cbytes = blosc_c(context, bsize, leftoverblock, ntbytes,\n                         context->destsize, context->src+j*context->blocksize,\n                         context->dest+ntbytes, tmp, tmp2);\n        if (cbytes == 0) {\n          ntbytes = 0;              /* uncompressible data */\n          break;\n        }\n      }\n    }\n    else {\n      if (*(context->header_flags) & BLOSC_MEMCPYED) {\n        /* We want to memcpy only */\n        fastcopy(context->dest + j * context->blocksize,\n                 context->src + BLOSC_MAX_OVERHEAD + j * context->blocksize, bsize);\n        cbytes = bsize;\n      }\n      else {\n        /* Regular decompression */\n        cbytes = blosc_d(context, bsize, leftoverblock, context->src,\n                         sw32_(context->bstarts + j * 4),\n                         context->dest + j * context->blocksize, tmp, tmp2);\n      }\n    }\n    if (cbytes < 0) {\n      ntbytes = cbytes;         /* error in blosc_c or blosc_d */\n      break;\n    }\n    ntbytes += cbytes;\n  }\n\n  /* Free temporaries */\n  my_free(tmp);\n\n  return ntbytes;\n}\n\nstatic int do_job(struct blosc_context* context)\n{\n  int32_t ntbytes;\n\n  /* Run the serial version when nthreads is 1 or when the buffers are\n     not much larger than blocksize */\n  if (context->numthreads == 1 || (context->sourcesize / context->blocksize) <= 1) {\n    ntbytes = serial_blosc(context);\n  }\n  else {\n    ntbytes = parallel_blosc(context);\n  }\n\n  return ntbytes;\n}\n\nint blosc_compress_context(struct blosc_context* context)\n{\n  int32_t ntbytes = 0;\n\n  if ((*(context->header_flags) & BLOSC_MEMCPYED) &&\n      (context->sourcesize + BLOSC_MAX_OVERHEAD > context->destsize)) {\n    return 0;   /* data cannot be copied without overrun destination */\n  }\n\n  /* Do the actual compression */\n  ntbytes = do_job(context);\n  if (ntbytes < 0) {\n    return -1;\n  }\n  if ((ntbytes == 0) && (context->sourcesize + BLOSC_MAX_OVERHEAD <= context->destsize)) {\n    /* Last chance for fitting `src` buffer in `dest`.  Update flags and force a copy. */\n    *(context->header_flags) |= BLOSC_MEMCPYED;\n    context->num_output_bytes = BLOSC_MAX_OVERHEAD;  /* reset the output bytes in previous step */\n    ntbytes = do_job(context);\n    if (ntbytes < 0) {\n      return -1;\n    }\n  }\n\n  /* Set the number of compressed bytes in header */\n  _sw32(context->dest + 12, ntbytes);\n\n  assert(ntbytes <= context->destsize);\n  return ntbytes;\n}\n\nint blosc_compress(int clevel, int doshuffle, size_t typesize, size_t nbytes,\n                   const void *src, void *dest, size_t destsize)\n{\n  int result;\n  char* envvar;\n\n  /* Check if should initialize */\n  if (!g_initlib) blosc_init();\n\n  /* Check for environment variables */\n  envvar = getenv(\"BLOSC_CLEVEL\");\n  if (envvar != NULL) {\n    long value;\n    value = strtol(envvar, NULL, 10);\n    if ((value != EINVAL) && (value >= 0)) {\n      clevel = (int)value;\n    }\n  }\n\n  envvar = getenv(\"BLOSC_SHUFFLE\");\n  if (envvar != NULL) {\n    if (strcmp(envvar, \"NOSHUFFLE\") == 0) {\n      doshuffle = BLOSC_NOSHUFFLE;\n    }\n    if (strcmp(envvar, \"SHUFFLE\") == 0) {\n      doshuffle = BLOSC_SHUFFLE;\n    }\n    if (strcmp(envvar, \"BITSHUFFLE\") == 0) {\n      doshuffle = BLOSC_BITSHUFFLE;\n    }\n  }\n\n  envvar = getenv(\"BLOSC_TYPESIZE\");\n  if (envvar != NULL) {\n    long value;\n    value = strtol(envvar, NULL, 10);\n    if ((value != EINVAL) && (value > 0)) {\n      typesize = (int)value;\n    }\n  }\n\n  envvar = getenv(\"BLOSC_COMPRESSOR\");\n  if (envvar != NULL) {\n    result = blosc_set_compressor(envvar);\n    if (result < 0) { return result; }\n  }\n\n  envvar = getenv(\"BLOSC_BLOCKSIZE\");\n  if (envvar != NULL) {\n    long blocksize;\n    blocksize = strtol(envvar, NULL, 10);\n    if ((blocksize != EINVAL) && (blocksize > 0)) {\n      blosc_set_blocksize((size_t)blocksize);\n    }\n  }\n\n  envvar = getenv(\"BLOSC_NTHREADS\");\n  if (envvar != NULL) {\n    long nthreads;\n    nthreads = strtol(envvar, NULL, 10);\n    if ((nthreads != EINVAL) && (nthreads > 0)) {\n      result = blosc_set_nthreads((int)nthreads);\n      if (result < 0) { return result; }\n    }\n  }\n\n  envvar = getenv(\"BLOSC_SPLITMODE\");\n  if (envvar != NULL) {\n    if (strcmp(envvar, \"FORWARD_COMPAT\") == 0) {\n      blosc_set_splitmode(BLOSC_FORWARD_COMPAT_SPLIT);\n    }\n    else if (strcmp(envvar, \"AUTO\") == 0) {\n      blosc_set_splitmode(BLOSC_AUTO_SPLIT);\n    }\n    else if (strcmp(envvar, \"ALWAYS\") == 0) {\n      blosc_set_splitmode(BLOSC_ALWAYS_SPLIT);\n    }\n    else if (strcmp(envvar, \"NEVER\") == 0) {\n      blosc_set_splitmode(BLOSC_NEVER_SPLIT);\n    }\n    else {\n      fprintf(stderr, \"BLOSC_SPLITMODE environment variable '%s' not recognized\\n\", envvar);\n      return -1;\n    }\n  }\n\n  /* Check for a BLOSC_NOLOCK environment variable.  It is important\n     that this should be the last env var so that it can take the\n     previous ones into account */\n  envvar = getenv(\"BLOSC_NOLOCK\");\n  if (envvar != NULL) {\n    const char *compname;\n    blosc_compcode_to_compname(g_compressor, &compname);\n    result = blosc_compress_ctx(clevel, doshuffle, typesize,\n\t\t\t\tnbytes, src, dest, destsize,\n\t\t\t\tcompname, g_force_blocksize, g_threads);\n    return result;\n  }\n\n  pthread_mutex_lock(global_comp_mutex);\n\n  do {\n    result = initialize_context_compression(g_global_context, clevel, doshuffle,\n                                           typesize, nbytes, src, dest, destsize,\n                                           g_compressor, g_force_blocksize,\n                                           g_threads);\n    if (result <= 0) { break; }\n\n    result = write_compression_header(g_global_context, clevel, doshuffle);\n    if (result <= 0) { break; }\n\n    result = blosc_compress_context(g_global_context);\n  } while (0);\n\n  pthread_mutex_unlock(global_comp_mutex);\n\n  return result;\n}\n\n\n// target function\nint blosclz_compress(const int clevel, const void* input, int length,\n                     void* output, int maxout) {\n  uint8_t* ibase = (uint8_t*)input;\n  uint8_t* ip = ibase;\n  uint8_t* ip_bound = ibase + length - 1;\n  uint8_t* ip_limit = ibase + length - 12;\n  uint8_t* op = (uint8_t*)output;\n  uint8_t* op_limit;\n  uint32_t htab[1U << (uint8_t)HASH_LOG];\n  uint32_t hval;\n  uint32_t seq;\n  uint8_t copy;\n\n  // Minimum cratios before issuing and _early giveup_\n  // Remind that blosclz is not meant for cratios <= 2 (too costly to decompress)\n  double maxlength_[10] = {-1, .07, .1, .15, .25, .45, .5, .5, .5, .5};\n  int32_t maxlength = (int32_t)(length * maxlength_[clevel]);\n  if (maxlength > (int32_t)maxout) {\n    maxlength = (int32_t)maxout;\n  }\n  op_limit = op + maxlength;\n\n  uint8_t hashlog_[10] = {0, HASH_LOG - 2, HASH_LOG - 1, HASH_LOG, HASH_LOG,\n                           HASH_LOG, HASH_LOG, HASH_LOG, HASH_LOG, HASH_LOG};\n  uint8_t hashlog = hashlog_[clevel];\n  // Initialize the hash table to distances of 0\n  for (unsigned i = 0; i < (1U << hashlog); i++) {\n    htab[i] = 0;\n  }\n\n  /* input and output buffer cannot be less than 16 and 66 bytes or we can get into trouble */\n  if (length < 16 || maxout < 66) {\n    return 0;\n  }\n\n  /* we start with literal copy */\n  copy = 4;\n  *op++ = MAX_COPY - 1;\n  *op++ = *ip++;\n  *op++ = *ip++;\n  *op++ = *ip++;\n  *op++ = *ip++;\n\n  /* main loop */\n  while (BLOSCLZ_EXPECT_CONDITIONAL(ip < ip_limit)) {\n    const uint8_t* ref;\n    uint32_t distance;\n    uint8_t* anchor = ip;    /* comparison starting-point */\n\n    /* find potential match */\n    seq = BLOSCLZ_READU32(ip);\n    HASH_FUNCTION(hval, seq, hashlog)\n    ref = ibase + htab[hval];\n\n    /* calculate distance to the match */\n    distance = (int32_t)(anchor - ref);\n\n    /* update hash table */\n    htab[hval] = (uint32_t) (anchor - ibase);\n\n    if (distance == 0 || (distance >= MAX_FARDISTANCE)) {\n      LITERAL(ip, op, op_limit, anchor, copy)\n      continue;\n    }\n\n    /* is this a match? check the first 4 bytes */\n    if (BLOSCLZ_UNEXPECT_CONDITIONAL(BLOSCLZ_READU32(ref) == BLOSCLZ_READU32(ip))) {\n      ref += 4;\n    }\n    else {\n      /* no luck, copy as a literal */\n      LITERAL(ip, op, op_limit, anchor, copy)\n      continue;\n    }\n\n    /* last matched byte */\n    ip = anchor + 4;\n\n    /* distance is biased */\n    distance--;\n\n    if (BLOSCLZ_UNEXPECT_CONDITIONAL(!distance)) {\n      /* zero distance means a run */\n#if defined(__AVX2__)\n      ip = get_run_32(ip, ip_bound, ref);\n#elif defined(__SSE2__)\n      ip = get_run_16(ip, ip_bound, ref);\n#else\n      ip = get_run(ip, ip_bound, ref);\n#endif\n    }\n    else {\n#if defined(__AVX2__)\n      ip = get_match_32(ip, ip_bound, ref);\n#elif defined(__SSE2__)\n      ip = get_match_16(ip, ip_bound, ref);\n#else\n      ip = get_match(ip, ip_bound, ref);\n#endif\n    }\n\n    /* if we have copied something, adjust the copy count */\n    if (copy)\n      /* copy is biased, '0' means 1 byte copy */\n      *(op - copy - 1) = (uint8_t)(copy - 1);\n    else\n      /* back, to overwrite the copy count */\n      op--;\n\n    /* reset literal counter */\n    copy = 0;\n\n    /* length is biased, '1' means a match of 3 bytes */\n    /* When we get back by 4 we obtain quite different compression properties.\n     * It looks like 4 is more useful in combination with bitshuffle and small typesizes\n     * (compress better and faster in e.g. `b2bench blosclz bitshuffle single 6 6291456 1 19`).\n     * Worth experimenting with this in the future.  For the time being, use 3 for high clevels. */\n    ip -= clevel > 8 ? 3 : 4;\n    long len = ip - anchor;\n\n    /* encode the match */\n    if (distance < MAX_DISTANCE) {\n      if (len < 7) {\n        *op++ = (uint8_t)((len << 5U) + (distance >> 8U));\n        *op++ = (uint8_t)((distance & 255U));\n      }\n      else {\n        *op++ = (uint8_t)((7U << 5U) + (distance >> 8U));\n        for (len -= 7; len >= 255; len -= 255)\n          *op++ = 255;\n        *op++ = (uint8_t)len;\n        *op++ = (uint8_t)((distance & 255U));\n      }\n    }\n    else {\n      /* far away, but not yet in the another galaxy... */\n      if (len < 7) {\n        distance -= MAX_DISTANCE;\n        *op++ = (uint8_t)((len << 5U) + 31);\n        *op++ = 255;\n        *op++ = (uint8_t)(distance >> 8U);\n        *op++ = (uint8_t)(distance & 255U);\n      }\n      else {\n        distance -= MAX_DISTANCE;\n        *op++ = (7U << 5U) + 31;\n        for (len -= 7; len >= 255; len -= 255)\n          *op++ = 255;\n        *op++ = (uint8_t)len;\n        *op++ = 255;\n        *op++ = (uint8_t)(distance >> 8U);\n        *op++ = (uint8_t)(distance & 255U);\n      }\n    }\n\n    /* update the hash at match boundary */\n    seq = BLOSCLZ_READU32(ip);\n    HASH_FUNCTION(hval, seq, hashlog)\n    htab[hval] = (uint32_t) (ip++ - ibase);\n    seq >>= 8U;\n    HASH_FUNCTION(hval, seq, hashlog)\n    htab[hval] = (uint32_t) (ip++ - ibase);\n    /* assuming literal copy */\n    *op++ = MAX_COPY - 1;\n\n  }\n\n  /* left-over as literal copy */\n  while (BLOSCLZ_UNEXPECT_CONDITIONAL(ip <= ip_bound)) {\n    if (BLOSCLZ_UNEXPECT_CONDITIONAL(op + 2 > op_limit)) goto out;\n    *op++ = *ip++;\n    copy++;\n    if (BLOSCLZ_UNEXPECT_CONDITIONAL(copy == MAX_COPY)) {\n      copy = 0;\n      *op++ = MAX_COPY - 1;\n    }\n  }\n\n  /* if we have copied something, adjust the copy length */\n  if (copy)\n    *(op - copy - 1) = (uint8_t)(copy - 1);\n  else\n    op--;\n\n  /* marker for blosclz */\n  *(uint8_t*)output |= (1U << 5U);\n\n  return (int)(op - (uint8_t*)output);\n\n  out:\n  return 0;\n\n}\nstatic inline void wild_copy(uint8_t *out, const uint8_t* from, uint8_t* end) {\n  uint8_t* d = out;\n  const uint8_t* s = from;\n  uint8_t* const e = end;\n\n  do { memcpy(d,s,8); d+=8; s+=8; } while (d<e);\n}\nint blosclz_decompress(const void* input, int length, void* output, int maxout) {\n  const uint8_t* ip = (const uint8_t*)input;\n  const uint8_t* ip_limit = ip + length;\n  uint8_t* op = (uint8_t*)output;\n  uint32_t ctrl;\n  uint8_t* op_limit = op + maxout;\n  if (BLOSCLZ_UNEXPECT_CONDITIONAL(length == 0)) {\n    return 0;\n  }\n  ctrl = (*ip++) & 31U;\n\n  while (1) {\n    uint8_t* ref = op;\n    int32_t len = ctrl >> 5U;\n    int32_t ofs = (ctrl & 31U) << 8U;\n\n    if (ctrl >= 32) {\n      uint8_t code;\n      len--;\n      ref -= ofs;\n      if (len == 7 - 1) {\n        do {\n          if (BLOSCLZ_UNEXPECT_CONDITIONAL(ip + 1 >= ip_limit)) {\n            return 0;\n          }\n          code = *ip++;\n          len += code;\n        } while (code == 255);\n      }\n      else {\n        if (BLOSCLZ_UNEXPECT_CONDITIONAL(ip + 1 >= ip_limit)) {\n          return 0;\n        }\n      }\n      code = *ip++;\n      ref -= code;\n\n      /* match from 16-bit distance */\n      if (BLOSCLZ_UNEXPECT_CONDITIONAL(code == 255)) {\n        if (BLOSCLZ_EXPECT_CONDITIONAL(ofs == (31U << 8U))) {\n          if (BLOSCLZ_UNEXPECT_CONDITIONAL(ip + 1 >= ip_limit)) {\n            return 0;\n          }\n          ofs = (*ip++) << 8U;\n          ofs += *ip++;\n          ref = op - ofs - MAX_DISTANCE;\n        }\n      }\n\n      if (BLOSCLZ_UNEXPECT_CONDITIONAL(op + len + 3 > op_limit)) {\n        return 0;\n      }\n\n      if (BLOSCLZ_UNEXPECT_CONDITIONAL(ref - 1 < (uint8_t*)output)) {\n        return 0;\n      }\n\n      if (BLOSCLZ_EXPECT_CONDITIONAL(ip < ip_limit))\n        ctrl = *ip++;\n      else\n        break;\n\n      if (ref == op) {\n        /* optimized copy for a run */\n        uint8_t b = ref[-1];\n        memset(op, b, len + 3);\n        op += len + 3;\n      }\n      else {\n        /* copy from reference */\n        ref--;\n        len += 3;\n#ifdef __AVX2__\n        if (op - ref <= 16) {\n          // This is not faster on a combination of compilers (clang, gcc, icc) or machines, but\n          // it is not slower either.  Let's activate here for experimentation.\n          op = copy_match_16(op, ref, len);\n        }\n        else {\n#endif\n          uint8_t* endcpy = op + len;\n          if ((op - ref < 8) || (op_limit - endcpy < 8)) {\n            // We absolutely need a copy_match here\n            op = copy_match(op, ref, (unsigned) len);\n          }\n          else {\n            wild_copy(op, ref, endcpy);\n            op = endcpy;\n          }\n\n#ifdef __AVX2__\n        }\n#endif\n      }\n    }\n    else {\n      ctrl++;\n      if (BLOSCLZ_UNEXPECT_CONDITIONAL(op + ctrl > op_limit)) {\n        return 0;\n      }\n      if (BLOSCLZ_UNEXPECT_CONDITIONAL(ip + ctrl > ip_limit)) {\n        return 0;\n      }\n\n      memcpy(op, ip, ctrl); op += ctrl; ip += ctrl;\n      // On GCC-6, fastcopy this is still faster than plain memcpy\n      // However, using recent CLANG/LLVM 9.0, there is almost no difference\n      // in performance.\n      // And starting on CLANG/LLVM 10 and GCC 9, memcpy is generally faster.\n      // op = fastcopy(op, ip, (unsigned) ctrl); ip += ctrl;\n\n      if (BLOSCLZ_UNEXPECT_CONDITIONAL(ip >= ip_limit)) break;\n      ctrl = *ip++;\n    }\n  }\n\n  return (int)(op - (uint8_t*)output);\n}\n",
    "target": 1,
    "idx": 1023794,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\n\n/* Read an ECOFF symbol table.  */\n\nbool\n_bfd_ecoff_slurp_symbol_table (bfd *abfd)\n{\n  const struct ecoff_backend_data * const backend = ecoff_backend (abfd);\n  const bfd_size_type external_ext_size\n    = backend->debug_swap.external_ext_size;\n  const bfd_size_type external_sym_size\n    = backend->debug_swap.external_sym_size;\n  void (* const swap_ext_in) (bfd *, void *, EXTR *)\n    = backend->debug_swap.swap_ext_in;\n  void (* const swap_sym_in) (bfd *, void *, SYMR *)\n    = backend->debug_swap.swap_sym_in;\n  ecoff_symbol_type *internal;\n  ecoff_symbol_type *internal_ptr;\n  char *eraw_src;\n  char *eraw_end;\n  FDR *fdr_ptr;\n  FDR *fdr_end;\n  size_t amt;\n\n  /* If we've already read in the symbol table, do nothing.  */\n  if (ecoff_data (abfd)->canonical_symbols != NULL)\n    return true;\n\n  /* Get the symbolic information.  */\n  if (! _bfd_ecoff_slurp_symbolic_info (abfd, NULL,\n\t\t\t\t\t&ecoff_data (abfd)->debug_info))\n    return false;\n  if (bfd_get_symcount (abfd) == 0)\n    return true;\n\n  if (_bfd_mul_overflow (bfd_get_symcount (abfd),\n\t\t\t sizeof (ecoff_symbol_type), &amt))\n    {\n      bfd_set_error (bfd_error_file_too_big);\n      return false;\n    }\n  internal = (ecoff_symbol_type *) bfd_alloc (abfd, amt);\n  if (internal == NULL)\n    return false;\n\n  internal_ptr = internal;\n  eraw_src = (char *) ecoff_data (abfd)->debug_info.external_ext;\n  eraw_end = (eraw_src\n\t      + (ecoff_data (abfd)->debug_info.symbolic_header.iextMax\n\t\t * external_ext_size));\n  for (; eraw_src < eraw_end; eraw_src += external_ext_size, internal_ptr++)\n    {\n      EXTR internal_esym;\n\n      (*swap_ext_in) (abfd, (void *) eraw_src, &internal_esym);\n\n      /* PR 17512: file: 3372-1000-0.004.  */\n      HDRR *symhdr = &ecoff_data (abfd)->debug_info.symbolic_header;\n      if (internal_esym.asym.iss >= symhdr->issExtMax\n\t  || internal_esym.asym.iss < 0)\n\t{\n\t  bfd_set_error (bfd_error_bad_value);\n\t  return false;\n\t}\n\n      internal_ptr->symbol.name = (ecoff_data (abfd)->debug_info.ssext\n\t\t\t\t   + internal_esym.asym.iss);\n\n      if (!ecoff_set_symbol_info (abfd, &internal_esym.asym,\n\t\t\t\t  &internal_ptr->symbol, 1,\n\t\t\t\t  internal_esym.weakext))\n\treturn false;\n\n      /* The alpha uses a negative ifd field for section symbols.  */\n      /* PR 17512: file: 3372-1983-0.004.  */\n      if (internal_esym.ifd >= symhdr->ifdMax\n\t  || internal_esym.ifd < 0)\n\tinternal_ptr->fdr = NULL;\n      else\n\tinternal_ptr->fdr = (ecoff_data (abfd)->debug_info.fdr\n\t\t\t     + internal_esym.ifd);\n      internal_ptr->local = false;\n      internal_ptr->native = (void *) eraw_src;\n    }\n\n  /* The local symbols must be accessed via the fdr's, because the\n     string and aux indices are relative to the fdr information.  */\n  fdr_ptr = ecoff_data (abfd)->debug_info.fdr;\n  fdr_end = fdr_ptr + ecoff_data (abfd)->debug_info.symbolic_header.ifdMax;\n  for (; fdr_ptr < fdr_end; fdr_ptr++)\n    {\n      char *lraw_src;\n      char *lraw_end;\n\n      lraw_src = ((char *) ecoff_data (abfd)->debug_info.external_sym\n\t\t  + fdr_ptr->isymBase * external_sym_size);\n      lraw_end = lraw_src + fdr_ptr->csym * external_sym_size;\n      for (;\n\t   lraw_src < lraw_end;\n\t   lraw_src += external_sym_size, internal_ptr++)\n\t{\n\t  SYMR internal_sym;\n\n\t  (*swap_sym_in) (abfd, (void *) lraw_src, &internal_sym);\n\n\t  HDRR *symhdr = &ecoff_data (abfd)->debug_info.symbolic_header;\n\t  if (internal_sym.iss >= symhdr->issMax\n\t      || internal_sym.iss < 0)\n\t    {\n\t      bfd_set_error (bfd_error_bad_value);\n\t      return false;\n\t    }\n\t  internal_ptr->symbol.name = (ecoff_data (abfd)->debug_info.ss\n\t\t\t\t       + fdr_ptr->issBase\n\t\t\t\t       + internal_sym.iss);\n\t  if (!ecoff_set_symbol_info (abfd, &internal_sym,\n\t\t\t\t      &internal_ptr->symbol, 0, 0))\n\t    return false;\n\t  internal_ptr->fdr = fdr_ptr;\n\t  internal_ptr->local = true;\n\t  internal_ptr->native = (void *) lraw_src;\n\t}\n    }\n\n  /* PR 17512: file: 3372-3080-0.004.\n     A discrepancy between ecoff_data (abfd)->debug_info.symbolic_header.isymMax\n     and ecoff_data (abfd)->debug_info.symbolic_header.ifdMax can mean that\n     we have fewer symbols than we were expecting.  Allow for this by updating\n     the symbol count and warning the user.  */\n  if (internal_ptr - internal < (ptrdiff_t) bfd_get_symcount (abfd))\n    {\n      abfd->symcount = internal_ptr - internal;\n      _bfd_error_handler\n\t/* xgettext:c-format */\n\t(_(\"%pB: warning: isymMax (%ld) is greater than ifdMax (%ld)\"),\n\t abfd, ecoff_data (abfd)->debug_info.symbolic_header.isymMax,\n\t ecoff_data (abfd)->debug_info.symbolic_header.ifdMax);\n    }\n\n  ecoff_data (abfd)->canonical_symbols = internal;\n\n\n/* Get the canonical symbols.  */\n\nlong\n_bfd_ecoff_canonicalize_symtab (bfd *abfd, asymbol **alocation)\n{\n  unsigned int counter = 0;\n  ecoff_symbol_type *symbase;\n  ecoff_symbol_type **location = (ecoff_symbol_type **) alocation;\n\n  if (! _bfd_ecoff_slurp_symbol_table (abfd))\n    return -1;\n  if (bfd_get_symcount (abfd) == 0)\n    return 0;\n\n  symbase = ecoff_data (abfd)->canonical_symbols;\n  while (counter < bfd_get_symcount (abfd))\n    {\n      *(location++) = symbase++;\n      counter++;\n    }\n\n\n// target function\n\n/* Read an ECOFF symbol table.  */\n\nbool\n_bfd_ecoff_slurp_symbol_table (bfd *abfd)\n{\n  const struct ecoff_backend_data * const backend = ecoff_backend (abfd);\n  const bfd_size_type external_ext_size\n    = backend->debug_swap.external_ext_size;\n  const bfd_size_type external_sym_size\n    = backend->debug_swap.external_sym_size;\n  void (* const swap_ext_in) (bfd *, void *, EXTR *)\n    = backend->debug_swap.swap_ext_in;\n  void (* const swap_sym_in) (bfd *, void *, SYMR *)\n    = backend->debug_swap.swap_sym_in;\n  ecoff_symbol_type *internal;\n  ecoff_symbol_type *internal_ptr;\n  char *eraw_src;\n  char *eraw_end;\n  FDR *fdr_ptr;\n  FDR *fdr_end;\n  size_t amt;\n\n  /* If we've already read in the symbol table, do nothing.  */\n  if (ecoff_data (abfd)->canonical_symbols != NULL)\n    return true;\n\n  /* Get the symbolic information.  */\n  if (! _bfd_ecoff_slurp_symbolic_info (abfd, NULL,\n\t\t\t\t\t&ecoff_data (abfd)->debug_info))\n    return false;\n  if (bfd_get_symcount (abfd) == 0)\n    return true;\n\n  if (_bfd_mul_overflow (bfd_get_symcount (abfd),\n\t\t\t sizeof (ecoff_symbol_type), &amt))\n    {\n      bfd_set_error (bfd_error_file_too_big);\n      return false;\n    }\n  internal = (ecoff_symbol_type *) bfd_alloc (abfd, amt);\n  if (internal == NULL)\n    return false;\n\n  internal_ptr = internal;\n  eraw_src = (char *) ecoff_data (abfd)->debug_info.external_ext;\n  eraw_end = (eraw_src\n\t      + (ecoff_data (abfd)->debug_info.symbolic_header.iextMax\n\t\t * external_ext_size));\n  for (; eraw_src < eraw_end; eraw_src += external_ext_size, internal_ptr++)\n    {\n      EXTR internal_esym;\n\n      (*swap_ext_in) (abfd, (void *) eraw_src, &internal_esym);\n\n      /* PR 17512: file: 3372-1000-0.004.  */\n      if (internal_esym.asym.iss >= ecoff_data (abfd)->debug_info.symbolic_header.issExtMax\n\t  || internal_esym.asym.iss < 0)\n\treturn false;\n\n      internal_ptr->symbol.name = (ecoff_data (abfd)->debug_info.ssext\n\t\t\t\t   + internal_esym.asym.iss);\n\n      if (!ecoff_set_symbol_info (abfd, &internal_esym.asym,\n\t\t\t\t  &internal_ptr->symbol, 1,\n\t\t\t\t  internal_esym.weakext))\n\treturn false;\n\n      /* The alpha uses a negative ifd field for section symbols.  */\n      if (internal_esym.ifd >= 0)\n\t{\n\t  /* PR 17512: file: 3372-1983-0.004.  */\n\t  if (internal_esym.ifd >= ecoff_data (abfd)->debug_info.symbolic_header.ifdMax)\n\t    internal_ptr->fdr = NULL;\n\t  else\n\t    internal_ptr->fdr = (ecoff_data (abfd)->debug_info.fdr\n\t\t\t\t + internal_esym.ifd);\n\t}\n      else\n\tinternal_ptr->fdr = NULL;\n      internal_ptr->local = false;\n      internal_ptr->native = (void *) eraw_src;\n    }\n\n  /* The local symbols must be accessed via the fdr's, because the\n     string and aux indices are relative to the fdr information.  */\n  fdr_ptr = ecoff_data (abfd)->debug_info.fdr;\n  fdr_end = fdr_ptr + ecoff_data (abfd)->debug_info.symbolic_header.ifdMax;\n  for (; fdr_ptr < fdr_end; fdr_ptr++)\n    {\n      char *lraw_src;\n      char *lraw_end;\n\n      lraw_src = ((char *) ecoff_data (abfd)->debug_info.external_sym\n\t\t  + fdr_ptr->isymBase * external_sym_size);\n      lraw_end = lraw_src + fdr_ptr->csym * external_sym_size;\n      for (;\n\t   lraw_src < lraw_end;\n\t   lraw_src += external_sym_size, internal_ptr++)\n\t{\n\t  SYMR internal_sym;\n\n\t  (*swap_sym_in) (abfd, (void *) lraw_src, &internal_sym);\n\t  internal_ptr->symbol.name = (ecoff_data (abfd)->debug_info.ss\n\t\t\t\t       + fdr_ptr->issBase\n\t\t\t\t       + internal_sym.iss);\n\t  if (!ecoff_set_symbol_info (abfd, &internal_sym,\n\t\t\t\t      &internal_ptr->symbol, 0, 0))\n\t    return false;\n\t  internal_ptr->fdr = fdr_ptr;\n\t  internal_ptr->local = true;\n\t  internal_ptr->native = (void *) lraw_src;\n\t}\n    }\n\n  /* PR 17512: file: 3372-3080-0.004.\n     A discrepancy between ecoff_data (abfd)->debug_info.symbolic_header.isymMax\n     and ecoff_data (abfd)->debug_info.symbolic_header.ifdMax can mean that\n     we have fewer symbols than we were expecting.  Allow for this by updating\n     the symbol count and warning the user.  */\n  if (internal_ptr - internal < (ptrdiff_t) bfd_get_symcount (abfd))\n    {\n      abfd->symcount = internal_ptr - internal;\n      _bfd_error_handler\n\t/* xgettext:c-format */\n\t(_(\"%pB: warning: isymMax (%ld) is greater than ifdMax (%ld)\"),\n\t abfd, ecoff_data (abfd)->debug_info.symbolic_header.isymMax,\n\t ecoff_data (abfd)->debug_info.symbolic_header.ifdMax);\n    }\n\n  ecoff_data (abfd)->canonical_symbols = internal;\n",
    "target": 1,
    "idx": 1055933,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\n\n// target function\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)\n{\n    static char copy[32768];\n    struct lwan_tpl *tpl;\n\n    if (size > sizeof(copy))\n        size = sizeof(copy) - 1;\n    memcpy(copy, data, size);\n    copy[size] = '\\0';\n\n    tpl = lwan_tpl_compile_string_full(copy, file_list_desc,\n                                       LWAN_TPL_FLAG_CONST_TEMPLATE);\n    if (tpl)\n        lwan_tpl_free(tpl);\n\n    return tpl ? 1 : 0;\n}\n",
    "target": 1,
    "idx": 1018988,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\n\n\n\n\n\n\nEXPORT int\ndwg_read_dxf (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  // const int minimal = dwg->opts & DWG_OPTS_MINIMAL;\n  Dxf_Pair *pair = NULL;\n  int error = 0;\n\n  loglevel = dwg->opts & DWG_OPTS_LOGLEVEL;\n  if (!dat->chain && dat->fh)\n    {\n      error = dat_read_stream (dat, dat->fh);\n      if (error >= DWG_ERR_CRITICAL)\n        return error;\n      if (dat->size >= 22 &&\n          !memcmp (dat->chain, \"AutoCAD Binary DXF\",\n                   sizeof (\"AutoCAD Binary DXF\") - 1))\n        {\n          dat->opts |= DWG_OPTS_DXFB;\n          dat->byte = 22;\n        }\n    }\n  if (dat->size < 256)\n    {\n      LOG_ERROR (\"DXF input too small, %lu byte.\\n\", dat->size);\n      return DWG_ERR_IOERROR;\n    }\n  /* Fail early on DWG */\n  if (!memcmp (dat->chain, \"AC10\", 4) ||\n      !memcmp (dat->chain, \"AC1.\", 4) ||\n      !memcmp (dat->chain, \"AC2.10\", 4) ||\n      !memcmp (dat->chain, \"MC0.0\", 4))\n    {\n      LOG_ERROR (\"This is a DWG, not a DXF\\n\");\n      return DWG_ERR_INVALIDDWG;\n    }\n  dat->opts |= DWG_OPTS_INDXF;\n  dwg->opts |= DWG_OPTS_INDXF;\n  //num_dxf_objs = 0;\n  //size_dxf_objs = 1000;\n  //dxf_objs = (Dxf_Objs *)malloc (1000 * sizeof (Dxf_Objs));\n  if (!dwg->object_map)\n    dwg->object_map = hash_new (dat->size / 1000);\n  // cannot rely on ref->obj during realloc's\n  dwg->dirty_refs = 1;\n\n  header_hdls = new_array_hdls (16);\n  eed_hdls = new_array_hdls (16);\n  obj_hdls = new_array_hdls (16);\n\n  // start with the BLOCK_HEADER at objid 0\n  if (!dwg->num_objects)\n    {\n      Dwg_Object *obj;\n      Dwg_Object_BLOCK_HEADER *_obj;\n      char *dxfname = strdup ((char *)\"BLOCK_HEADER\");\n      NEW_OBJECT (dwg, obj);\n      ADD_OBJECT (BLOCK_HEADER);\n      // dwg->header.version probably here still unknown. <r2000: 0x17\n      // later fixed up when reading $ACADVER and the BLOCK_HEADER.name\n      _obj->name = dwg_add_u8_input (dwg, \"*Model_Space\");\n      _obj->is_xref_ref = 1;\n      obj->tio.object->is_xdic_missing = 1;\n      dwg_add_handle (&obj->handle, 0, 0x1F, obj);\n      obj->tio.object->ownerhandle = dwg_add_handleref (dwg, 4, 1, NULL);\n    }\n\n  while (dat->byte < dat->size)\n    {\n      pair = dxf_read_pair (dat);\n      DXF_BREAK_EOF;\n      pair = dxf_expect_code (dat, pair, 0);\n      DXF_BREAK_EOF;\n      if (pair->type == DWG_VT_STRING && strEQc (pair->value.s, \"SECTION\"))\n        {\n          dxf_free_pair (pair);\n          pair = dxf_read_pair (dat);\n          DXF_BREAK_EOF;\n          pair = dxf_expect_code (dat, pair, 2);\n          DXF_BREAK_EOF;\n          if (!pair->value.s)\n            {\n              LOG_ERROR (\"Expected SECTION string code 2, got code %d\",\n                         pair->code);\n              dxf_free_pair (pair);\n              pair = NULL;\n              break;\n            }\n          else if (strEQc (pair->value.s, \"HEADER\"))\n            {\n              dxf_free_pair (pair);\n              pair = NULL;\n              error = dxf_header_read (dat, dwg);\n              if (error > DWG_ERR_CRITICAL)\n                goto error;\n              dxf_fixup_header (dwg);\n              // skip minimal DXF\n              /*\n              if (!dwg->header_vars.DIMPOST) // T in all versions\n                {\n                  LOG_ERROR (\"Unsupported minimal DXF\");\n                  return DWG_ERR_INVALIDDWG;\n                }\n              */\n            }\n          else if (strEQc (pair->value.s, \"CLASSES\"))\n            {\n              dxf_free_pair (pair);\n              pair = NULL;\n              if (dwg->header.from_version == R_INVALID)\n                dxf_fixup_header (dwg);\n              error = dxf_classes_read (dat, dwg);\n              if (error > DWG_ERR_CRITICAL)\n                return error;\n            }\n          else if (strEQc (pair->value.s, \"TABLES\"))\n            {\n              BITCODE_H hdl;\n              dxf_free_pair (pair);\n              pair = NULL;\n              error = dxf_tables_read (dat, dwg);\n              if (error > DWG_ERR_CRITICAL)\n                goto error;\n\n              resolve_postponed_header_refs (dwg);\n              resolve_postponed_eed_refs (dwg);\n              if (dwg->header.from_version == R_INVALID)\n                dxf_fixup_header (dwg);\n\n              // should not happen\n              if (!dwg->header_vars.LTYPE_BYLAYER\n                  && (hdl = dwg_find_tablehandle_silent (\n                          dwg, (char *)\"ByLayer\", \"LTYPE\")))\n                dwg->header_vars.LTYPE_BYLAYER\n                    = dwg_add_handleref (dwg, 5, hdl->handleref.value, NULL);\n              // should not happen\n              if (!dwg->header_vars.LTYPE_BYBLOCK\n                  && (hdl = dwg_find_tablehandle_silent (\n                          dwg, (char *)\"ByBlock\", \"LTYPE\")))\n                dwg->header_vars.LTYPE_BYBLOCK\n                    = dwg_add_handleref (dwg, 5, hdl->handleref.value, NULL);\n              // but this is needed\n              if (!dwg->header_vars.LTYPE_CONTINUOUS\n                  && (hdl = dwg_find_tablehandle_silent (\n                          dwg, (char *)\"Continuous\", \"LTYPE\")))\n                dwg->header_vars.LTYPE_CONTINUOUS\n                    = dwg_add_handleref (dwg, 5, hdl->handleref.value, NULL);\n            }\n          else if (strEQc (pair->value.s, \"BLOCKS\"))\n            {\n              BITCODE_H hdl;\n              dxf_free_pair (pair);\n              pair = NULL;\n              if (dwg->header.from_version == R_INVALID)\n                dxf_fixup_header (dwg);\n              error = dxf_blocks_read (dat, dwg);\n              if (error > DWG_ERR_CRITICAL)\n                goto error;\n\n              // resolve_postponed_header_refs (dwg);\n              if (!dwg->header_vars.BLOCK_RECORD_PSPACE\n                  && (hdl = dwg_find_tablehandle_silent (\n                          dwg, (char *)\"*Paper_Space\", \"BLOCK\")))\n                dwg->header_vars.BLOCK_RECORD_PSPACE\n                    = dwg_add_handleref (dwg, 5, hdl->handleref.value, NULL);\n              if (!dwg->header_vars.BLOCK_RECORD_MSPACE\n                  && (hdl = dwg_find_tablehandle_silent (\n                          dwg, (char *)\"*Model_Space\", \"BLOCK\")))\n                dwg->header_vars.BLOCK_RECORD_MSPACE\n                    = dwg_add_handleref (dwg, 5, hdl->handleref.value, NULL);\n            }\n          else if (strEQc (pair->value.s, \"ENTITIES\"))\n            {\n              dxf_free_pair (pair);\n              pair = NULL;\n              resolve_postponed_object_refs (dwg);\n              error = dxf_entities_read (dat, dwg);\n              if (error > DWG_ERR_CRITICAL)\n                goto error;\n            }\n          else if (strEQc (pair->value.s, \"OBJECTS\"))\n            {\n              dxf_free_pair (pair);\n              pair = NULL;\n              error = dxf_objects_read (dat, dwg);\n              if (error > DWG_ERR_CRITICAL)\n                goto error;\n              resolve_header_dicts (dwg);\n            }\n          else if (strEQc (pair->value.s, \"THUMBNAILIMAGE\"))\n            {\n              dxf_free_pair (pair);\n              pair = NULL;\n              error = dxf_thumbnail_read (dat, dwg);\n            }\n          else if (strEQc (pair->value.s, \"ACDSDATA\"))\n            {\n              dxf_free_pair (pair);\n              pair = NULL;\n              error = dxf_acds_read (dat, dwg);\n            }\n          else // if (strEQc (pair->value.s, \"\"))\n            {\n              LOG_WARN (\"SECTION %s ignored for now\", pair->value.s);\n              dxf_free_pair (pair);\n              pair = NULL;\n              error = dxf_unknownsection_read (dat, dwg);\n            }\n        }\n      else\n        {\n          LOG_ERROR (\"Expected string SECTION\");\n          dxf_free_pair (pair);\n        }\n    }\n  if (pair != NULL && pair->code == 0 &&\n      pair->value.s != NULL && strEQc (pair->value.s, \"EOF\"))\n    ;\n  else if (dat->byte >= dat->size || (pair == NULL))\n    error |= DWG_ERR_IOERROR;\n  dxf_free_pair (pair);\n  resolve_postponed_header_refs (dwg);\n  resolve_postponed_object_refs (dwg);\n  LOG_HANDLE (\"Resolving pointers from ObjectRef vector:\\n\");\n  dwg_resolve_objectrefs_silent (dwg);\n  free_array_hdls (header_hdls);\n  free_array_hdls (eed_hdls);\n  free_array_hdls (obj_hdls);\n  if (dwg->header.version <= R_2000 && dwg->header.from_version > R_2000)\n    dwg_fixup_BLOCKS_entities (dwg);\n  LOG_TRACE (\"import from DXF\\n\");\n  if (error > DWG_ERR_CRITICAL)\n    return error;\n  else\n    return dwg->num_objects ? 1 : 0;\n\nerror:\n  dwg->dirty_refs = 0;\n  free_array_hdls (header_hdls);\n  free_array_hdls (eed_hdls);\n  free_array_hdls (obj_hdls);\n  return error;\n}\n\n\n// target function\nstatic void\ndynapi_set_helper (void *restrict old, const Dwg_DYNAPI_field *restrict f,\n                   const Dwg_Version_Type dwg_version,\n                   const void *restrict value, const bool is_utf8)\n{\n  // TODO: sanity checks. is_malloc (TF), copy zero's (TFv)\n  // if text strcpy or wcscpy, or do utf8 conversion.\n  //if ((char*)old && f->is_malloc)\n  //  free (old);\n  if (f->is_malloc)\n    {\n      // NULL ptr\n      if (!*(char**)value)\n        memcpy (old, value, sizeof (char*));\n      // fixed length (but not yet TF)\n      else if (strEQc (f->type, \"TFv\"))\n        {\n          char *str = (char *)calloc (f->size, 1);\n          strcpy (str, *(char**)value);\n          memcpy (old, &str, sizeof (char*)); // size of ptr\n        }\n      // ascii\n      else if (f->is_string && dwg_version < R_2007)\n        {\n          // FIXME: TF size calc is probably wrong\n          char *str = (char *)malloc (strlen (*(char**)value)+1);\n          strcpy (str, *(char**)value);\n          memcpy (old, &str, sizeof (char*)); // size of ptr\n        }\n      // or wide\n      else if (strNE (f->type, \"TF\") && (f->is_string && dwg_version >= R_2007))\n        {\n          BITCODE_TU wstr;\n          if (is_utf8)\n            wstr = bit_utf8_to_TU (*(char **)value, 0);\n          else // source is already TU\n            {\n#if defined(HAVE_WCHAR_H) && defined(SIZEOF_WCHAR_T) && SIZEOF_WCHAR_T == 2\n              wstr = (BITCODE_TU)malloc (2 * (wcslen (*(wchar_t **)value) + 1));\n              wcscpy ((wchar_t *)wstr, *(wchar_t **)value);\n#else\n              int length = 0;\n              for (; (*(BITCODE_TU*)value)[length]; length++)\n                ;\n              length++;\n              wstr = (BITCODE_TU)malloc (2 * length);\n              memcpy (wstr, value, length * 2);\n#endif\n            }\n          memcpy (old, &wstr, sizeof (char*)); // size of ptr\n        }\n      else\n        memcpy (old, value, sizeof (char*));\n    }\n  else\n    memcpy (old, value, f->size);\n}\n",
    "target": 1,
    "idx": 1049613,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nint ndpi_vsnprintf(char * str, size_t size, char const * format, va_list va_args)\n{\n#ifdef WIN32\n  if((str == NULL) || (size == 0) || (format == NULL)) {\n    return -1;\n  }\n\n  int ret = vsnprintf_s(str, size, _TRUNCATE, format, va_args);\n\n  if(ret < 0) {\n    return size;\n  } else {\n    return ret;\n  }\n#else\n  return vsnprintf(str, size, format, va_args);\n#endif\n}\n\nint ndpi_snprintf(char * str, size_t size, char const * format, ...) {\n  va_list va_args;\n\n  va_start(va_args, format);\n  int ret = ndpi_vsnprintf(str, size, format, va_args);\n  va_end(va_args);\n\n  return ret;\n}\n\nint ndpi_serialize_string_int32(ndpi_serializer *_serializer,\n\t\t\t\tconst char *key, int32_t value) {\n#ifdef OPTIMIZE_CSV_SERIALIZATION\n  ndpi_private_serializer *serializer = (ndpi_private_serializer*)_serializer;\n\n  if(serializer->fmt == ndpi_serialization_format_csv) {\n    /* Key is ignored */\n    u_int32_t buff_diff = serializer->buffer.size - serializer->status.buffer.size_used;\n    u_int16_t needed = 12 /* 10 (billion) + CVS separator + \\0 */;\n    int rc;\n\n    if(buff_diff < needed) {\n      if(ndpi_extend_serializer_buffer(&serializer->buffer, needed - buff_diff) < 0)\n\treturn(-1);     \t\n    }\n\n    if(!(serializer->status.flags & NDPI_SERIALIZER_STATUS_HDR_DONE)) {\n      if(ndpi_serializer_header_string(serializer, key, strlen(key)) < 0)\n\treturn(-1);\n    }\n\n    ndpi_serialize_csv_pre(serializer);\n    buff_diff = serializer->buffer.size - serializer->status.buffer.size_used;\n\n    rc = ndpi_snprintf((char*)&serializer->buffer.data[serializer->status.buffer.size_used],\n\t\t       buff_diff, \"%u\", value);\n\n    if(rc < 0 || (u_int)rc >= buff_diff)\n      return(-1);\n    \n    serializer->status.buffer.size_used += rc;\n    \n    return(0);\n  } else\n#endif\n  return(ndpi_serialize_binary_int32(_serializer, key, strlen(key), value));\n}\n\n\n// target function\nint ndpi_serialize_string_int32(ndpi_serializer *_serializer,\n\t\t\t\tconst char *key, int32_t value) {\n#ifdef OPTIMIZE_CSV_SERIALIZATION\n  ndpi_private_serializer *serializer = (ndpi_private_serializer*)_serializer;\n\n  if(serializer->fmt == ndpi_serialization_format_csv) {\n    /* Key is ignored */\n    u_int32_t buff_diff = serializer->buffer.size - serializer->status.buffer.size_used;\n    u_int16_t needed = 11 /* 10 (billion) + CVS separator */;\n    int rc;\n\n    if(buff_diff < needed) {\n      if(ndpi_extend_serializer_buffer(&serializer->buffer, needed - buff_diff) < 0)\n\treturn(-1);\n      else\n\tbuff_diff = serializer->buffer.size - serializer->status.buffer.size_used;\n    }\n\n    if(!(serializer->status.flags & NDPI_SERIALIZER_STATUS_HDR_DONE)) {\n      if(ndpi_serializer_header_string(serializer, key, strlen(key)) < 0)\n\treturn(-1);\n    }\n\n    ndpi_serialize_csv_pre(serializer);\n    /* needed--; */\n\n    rc = ndpi_snprintf((char*)&serializer->buffer.data[serializer->status.buffer.size_used],\n\t\t       needed, \"%u\", value);\n\n    if(rc < 0 || (u_int)rc >= buff_diff)\n      return(-1);\n    serializer->status.buffer.size_used += rc;\n    return(0);\n  } else\n#endif\n  return(ndpi_serialize_binary_int32(_serializer, key, strlen(key), value));\n}\n",
    "target": 1,
    "idx": 1063179,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic void\nudiv(mrb_state *mrb, mpz_t *qq, mpz_t *rr, mpz_t *xx, mpz_t *yy)\n{\n  /* simple cases */\n  int cmp = ucmp(xx, yy);\n  if (cmp == 0) {\n    mpz_set_int(mrb, qq, 1);\n    zero(rr);\n    return;\n  }\n  else if (cmp < 0) {\n    zero(qq);\n    mpz_set(mrb, rr, xx);\n    return;\n  }\n\n  mpz_t q, x, y;\n  size_t i;\n\n  mrb_assert(!uzero(yy));       /* divided by zero */\n  mpz_init(mrb, &q);\n  mpz_init(mrb, &x);\n  mpz_init(mrb, &y);\n  mpz_realloc(mrb, &x, xx->sz+1);\n  size_t yd = digits(yy);\n  size_t ns = lzb(yy->p[yd-1]);\n  ulshift(mrb, &x, xx, ns);\n  ulshift(mrb, &y, yy, ns);\n  size_t xd = digits(&x);\n  mpz_realloc(mrb, &q, xd);\n  mp_dbl_limb z = y.p[yd-1];\n  if (xd>=yd) {\n    for (size_t j=xd-yd;; j--) {\n      mp_dbl_limb_signed b=0;\n      mp_dbl_limb qhat;\n\n      if (j+yd == xd)\n        qhat = x.p[j+yd-1] / z;\n      else\n        qhat = (((mp_dbl_limb)x.p[j+yd] << DIG_SIZE) + x.p[j+yd-1]) / z;\n      if (qhat) {\n        for (i=0; i<yd; i++) {\n          mp_dbl_limb zz = qhat * y.p[i];\n          mp_dbl_limb_signed u = LOW(b)+x.p[i+j]-LOW(zz);\n          x.p[i+j] = LOW(u);\n          b = HIGH(b) - HIGH(zz) + HIGH(u);\n        }\n        b += x.p[i+j];\n      }\n      for (; b!=0; qhat--) {\n        mp_dbl_limb c = 0;\n        for (i=0; i<yd; i++) {\n          c += (mp_dbl_limb)x.p[i+j] + (mp_dbl_limb)y.p[i];\n          x.p[i+j] = LOW(c);\n          c = HIGH(c);\n        }\n        b += c;\n      }\n      q.p[j] = (mp_limb)qhat;\n      if (j == 0) break;\n    }\n  }\n  x.sz = yy->sz;\n  urshift(mrb, rr, &x, ns);\n  trim(&q);\n  mpz_move(mrb, qq, &q);\n  mpz_clear(mrb, &x);\n  mpz_clear(mrb, &y);\n}\n\nstatic void\nmpz_mdiv(mrb_state *mrb, mpz_t *q, mpz_t *x, mpz_t *y)\n{\n  mpz_t r;\n  short sn1 = x->sn, sn2 = y->sn, qsign;\n\n  if (uzero(x)) {\n    mpz_init_set_int(mrb, q, 0);\n    return;\n  }\n  mpz_init(mrb, &r);\n  udiv(mrb, q, &r, x, y);\n  qsign = q->sn = sn1*sn2;\n  if (uzero(q))\n    q->sn = 0;\n  /* now if r != 0 and q < 0 we need to round q towards -inf */\n  if (!uzero(&r) && qsign < 0)\n    mpz_sub_int(mrb, q, q, 1);\n  mpz_clear(mrb, &r);\n}\n\nmrb_value\nmrb_bint_div(mrb_state *mrb, mrb_value x, mrb_value y)\n{\n#ifndef MRB_NO_FLOAT\n  if (mrb_float_p(y)) {\n    mrb_float v1 = mrb_bint_as_float(mrb, x);\n    mrb_float v2 = mrb_float(y);\n    return mrb_float_value(mrb,v1*v2);\n  }\n#endif\n  if (mrb_integer_p(y) && mrb_integer(y) == 0) {\n    mrb_int_zerodiv(mrb);\n  }\n  y = mrb_as_bint(mrb, y);\n  struct RBigint *b = RBIGINT(x);\n  struct RBigint *b2 = RBIGINT(y);\n  struct RBigint *b3 = bint_new(mrb);\n  if (b2->mp.sn == 0 || uzero(&b2->mp)) {\n    mrb_int_zerodiv(mrb);\n  }\n  mpz_mdiv(mrb, &b3->mp, &b->mp, &b2->mp);\n  return bint_norm(mrb, b3);\n}\n\nMRB_API mrb_value\nmrb_vm_run(mrb_state *mrb, const struct RProc *proc, mrb_value self, mrb_int stack_keep)\n{\n  const mrb_irep *irep = proc->body.irep;\n  mrb_value result;\n  struct mrb_context *c = mrb->c;\n  ptrdiff_t cioff = c->ci - c->cibase;\n  mrb_int nregs = irep->nregs;\n\n  if (!c->stbase) {\n    stack_init(mrb);\n  }\n  if (stack_keep > nregs)\n    nregs = stack_keep;\n  mrb_stack_extend(mrb, nregs);\n  stack_clear(c->ci->stack + stack_keep, nregs - stack_keep);\n  c->ci->stack[0] = self;\n  result = mrb_vm_exec(mrb, proc, irep->iseq);\n  if (mrb->c != c) {\n    if (mrb->c->fib) {\n      mrb_write_barrier(mrb, (struct RBasic*)mrb->c->fib);\n    }\n    mrb->c = c;\n  }\n  else if (c->ci - c->cibase > cioff) {\n    c->ci = c->cibase + cioff;\n  }\n  return result;\n}\n\nint FuzzRB(const uint8_t *Data, size_t size) {\n  mrb_value v;\n  mrb_state *mrb = mrb_open();\n  if (!mrb)\n    return 0;\n\n  char *code = (char *)malloc(size+1);\n  if (!code)\n    return 0;\n  memcpy(code, Data, size);\n  code[size] = '\\0';\n\n  if (const char *dump_path = getenv(\"PROTO_FUZZER_DUMP_PATH\")) {\n    // With libFuzzer binary run this to generate an RB file x.rb:\n    // PROTO_FUZZER_DUMP_PATH=x.rb ./a.out proto-input\n    std::ofstream of(dump_path);\n    of.write(code, size);\n  }\n  std::cout << \"\\n\\n############\\n\" << code << \"\\n############\\n\\n\";\n  v = mrb_load_string(mrb, code);\n  mrb_close(mrb);\n\n  free(code);\n  return 0;\n}\n\n\n\n\n// target function\nstatic void\nudiv(mrb_state *mrb, mpz_t *qq, mpz_t *rr, mpz_t *xx, mpz_t *yy)\n{\n  /* simple cases */\n  int cmp = ucmp(xx, yy);\n  if (cmp == 0) {\n    mpz_set_int(mrb, qq, 1);\n    zero(rr);\n    return;\n  }\n  else if (cmp < 0) {\n    zero(qq);\n    mpz_set(mrb, rr, xx);\n    return;\n  }\n\n  mpz_t q, x, y;\n  size_t i;\n\n  mrb_assert(!uzero(yy));       /* divided by zero */\n  mpz_init(mrb, &q);\n  mpz_init(mrb, &x);\n  mpz_init(mrb, &y);\n  mpz_realloc(mrb, &x, xx->sz+1);\n  size_t yd = digits(yy);\n  size_t ns = lzb(yy->p[yd-1]);\n  ulshift(mrb, &x, xx, ns);\n  ulshift(mrb, &y, yy, ns);\n  size_t xd = digits(&x);\n  mpz_realloc(mrb, &q, xd);\n  mp_dbl_limb z = y.p[yd-1];\n  for (size_t j=xd-yd;; j--) {\n    mp_dbl_limb_signed b=0;\n    mp_dbl_limb qhat;\n\n    if (j+yd == xd)\n      qhat = x.p[j+yd-1] / z;\n    else\n      qhat = (((mp_dbl_limb)x.p[j+yd] << DIG_SIZE) + x.p[j+yd-1]) / z;\n    if (qhat) {\n      for (i=0; i<yd; i++) {\n        mp_dbl_limb zz = qhat * y.p[i];\n        mp_dbl_limb_signed u = LOW(b)+x.p[i+j]-LOW(zz);\n        x.p[i+j] = LOW(u);\n        b = HIGH(b) - HIGH(zz) + HIGH(u);\n      }\n      b += x.p[i+j];\n    }\n    for (; b!=0; qhat--) {\n      mp_dbl_limb c = 0;\n      for (i=0; i<yd; i++) {\n        c += (mp_dbl_limb)x.p[i+j] + (mp_dbl_limb)y.p[i];\n        x.p[i+j] = LOW(c);\n        c = HIGH(c);\n      }\n      b += c;\n    }\n    q.p[j] = (mp_limb)qhat;\n    if (j == 0) break;\n  }\n  x.sz = yy->sz;\n  urshift(mrb, rr, &x, ns);\n  trim(&q);\n  mpz_move(mrb, qq, &q);\n  mpz_clear(mrb, &x);\n  mpz_clear(mrb, &y);\n}\n",
    "target": 1,
    "idx": 1049763,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nGF_Err diST_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DIMSScriptTypesBox *p = (GF_DIMSScriptTypesBox *)s;\n\n\tp->content_script_types = gf_malloc(sizeof(char) * (s->size+1));\n\tif (!p->content_script_types) return GF_OUT_OF_MEM;\n\tgf_bs_read_data(bs, p->content_script_types, s->size);\n\tp->content_script_types[s->size] = 0;\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_box_read(GF_Box *a, GF_BitStream *bs)\n{\n\tif (!a) return GF_BAD_PARAM;\n\tif (!a->registry) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Read invalid box type %s without registry\\n\", gf_4cc_to_str(a->type) ));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn a->registry->read_fn(a, bs);\n}\n\nGF_Err gf_isom_box_parse_ex(GF_Box **outBox, GF_BitStream *bs, u32 parent_type, Bool is_root_box, u64 parent_size)\n{\n\tu32 type, uuid_type, hdr_size, restore_type;\n\tu64 size, start, comp_start, end;\n\tchar uuid[16];\n\tGF_Err e;\n\tGF_BitStream *uncomp_bs = NULL;\n\tu8 *uncomp_data = NULL;\n\tu32 compressed_size=0;\n\tGF_Box *newBox;\n\tBool skip_logs = (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_NO_LOGS ) ? GF_TRUE : GF_FALSE;\n\tBool is_special = GF_TRUE;\n\t\n\tif ((bs == NULL) || (outBox == NULL) ) return GF_BAD_PARAM;\n\t*outBox = NULL;\n\tif (gf_bs_available(bs) < 8) {\n\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t}\n\n\tcomp_start = start = gf_bs_get_position(bs);\n\n\tuuid_type = 0;\n\tsize = (u64) gf_bs_read_u32(bs);\n\thdr_size = 4;\n\t/*fix for some boxes found in some old hinted files*/\n\tif ((size >= 2) && (size <= 4)) {\n\t\tsize = 4;\n\t\ttype = GF_ISOM_BOX_TYPE_VOID;\n\t} else {\n\t\ttype = gf_bs_read_u32(bs);\n\t\thdr_size += 4;\n\t\t/*no size means till end of file - EXCEPT FOR some old QuickTime boxes...*/\n\t\tif (type == GF_ISOM_BOX_TYPE_TOTL)\n\t\t\tsize = 12;\n\t\tif (!size) {\n\t\t\tif (is_root_box) {\n\t\t\t\tif (!skip_logs) {\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Warning Read Box type %s (0x%08X) size 0 reading till the end of file\\n\", gf_4cc_to_str(type), type));\n\t\t\t\t}\n\t\t\t\tsize = gf_bs_available(bs) + 8;\n\t\t\t} else {\n\t\t\t\tif (!skip_logs) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Read Box type %s (0x%08X) at position \"LLU\" has size 0 but is not at root/file level. Forbidden, skipping end of parent box !\\n\", gf_4cc_to_str(type), type, start));\n\t\t\t\t\treturn GF_SKIP_BOX;\n\t\t\t\t}\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t}\n\t\tif (is_root_box && (size>=8)) {\n\t\t\tBool do_uncompress = GF_FALSE;\n\t\t\tu8 *compb = NULL;\n\t\t\tu32 osize = 0;\n\t\t\tu32 otype = type;\n\t\t\tif (type==GF_4CC('!', 'm', 'o', 'f')) {\n\t\t\t\tdo_uncompress = GF_TRUE;\n\t\t\t\ttype = GF_ISOM_BOX_TYPE_MOOF;\n\t\t\t}\n\t\t\telse if (type==GF_4CC('!', 'm', 'o', 'v')) {\n\t\t\t\tdo_uncompress = GF_TRUE;\n\t\t\t\ttype = GF_ISOM_BOX_TYPE_MOOV;\n\t\t\t}\n\t\t\telse if (type==GF_4CC('!', 's', 'i', 'x')) {\n\t\t\t\tdo_uncompress = GF_TRUE;\n\t\t\t\ttype = GF_ISOM_BOX_TYPE_SIDX;\n\t\t\t}\n\t\t\telse if (type==GF_4CC('!', 's', 's', 'x')) {\n\t\t\t\tdo_uncompress = GF_TRUE;\n\t\t\t\ttype = GF_ISOM_BOX_TYPE_SSIX;\n\t\t\t}\n\n\t\t\tif (do_uncompress) {\n\t\t\t\tcompb = gf_malloc((u32) (size-8));\n\n\t\t\t\tcompressed_size = (u32) (size - 8);\n\t\t\t\tgf_bs_read_data(bs, compb, compressed_size);\n\t\t\t\te = gf_gz_decompress_payload(compb, compressed_size, &uncomp_data, &osize);\n\t\t\t\tif (e) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Failed to uncompress payload for box type %s (0x%08X)\\n\", gf_4cc_to_str(otype), otype));\n\t\t\t\t\treturn e;\n\t\t\t\t}\n\n\t\t\t\t//keep size as complete box size for tests below\n\t\t\t\tsize = osize + 8;\n\t\t\t\tuncomp_bs = gf_bs_new(uncomp_data, osize, GF_BITSTREAM_READ);\n\t\t\t\tbs = uncomp_bs;\n\t\t\t\tstart = 0;\n\t\t\t\tgf_free(compb);\n\t\t\t}\n\t\t}\n\t}\n\t/*handle uuid*/\n\tmemset(uuid, 0, 16);\n\tif (type == GF_ISOM_BOX_TYPE_UUID ) {\n\t\tif (gf_bs_available(bs) < 16) {\n\t\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t\t}\n\t\tgf_bs_read_data(bs, uuid, 16);\n\t\thdr_size += 16;\n\t\tuuid_type = gf_isom_solve_uuid_box(uuid);\n\t}\n\n\t//handle large box\n\tif (size == 1) {\n\t\tif (gf_bs_available(bs) < 8) {\n\t\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t\t}\n\t\tsize = gf_bs_read_u64(bs);\n\t\thdr_size += 8;\n\t}\n\tif (!skip_logs)\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Read Box type %s size \"LLD\" start \"LLD\"\\n\", gf_4cc_to_str(type), size,  start));\n\n\tif ( size < hdr_size ) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Box %s size \"LLD\" less than box header size %d\\n\", gf_4cc_to_str(type), size, hdr_size));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\t//if parent size is given, make sure box fits within parent\n\tif (parent_size && (parent_size<size)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Box %s size \"LLU\" is larger than remaining parent size \"LLU\"\\n\", gf_4cc_to_str(type), size, parent_size ));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\trestore_type = 0;\n\tif ((parent_type==GF_ISOM_BOX_TYPE_STSD) && (type==GF_QT_SUBTYPE_RAW) ) {\n\t\tu64 cookie = gf_bs_get_cookie(bs);\n\t\trestore_type = type;\n\t\tif (cookie & GF_ISOM_BS_COOKIE_VISUAL_TRACK)\n\t\t\ttype = GF_QT_SUBTYPE_RAW_VID;\n\t\telse\n\t\t\ttype = GF_QT_SUBTYPE_RAW_AUD;\n\n\t}\n\n\t//some special boxes (references and track groups) are handled by a single generic box with an associated ref/group type\n\tif (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TREF)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFT);\n\t\tif (!newBox) return GF_OUT_OF_MEM;\n\t\t((GF_TrackReferenceTypeBox*)newBox)->reference_type = type;\n\t} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_IREF)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFI);\n\t\tif (!newBox) return GF_OUT_OF_MEM;\n\t\t((GF_ItemReferenceTypeBox*)newBox)->reference_type = type;\n\t} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TRGR)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_TRGT);\n\t\tif (!newBox) return GF_OUT_OF_MEM;\n\t\t((GF_TrackGroupTypeBox*)newBox)->group_type = type;\n\t} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_GRPL)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_GRPT);\n\t\tif (!newBox) return GF_OUT_OF_MEM;\n\t\t((GF_EntityToGroupTypeBox*)newBox)->grouping_type = type;\n\t} else {\n\t\t//OK, create the box based on the type\n\t\tis_special = GF_FALSE;\n\t\tnewBox = gf_isom_box_new_ex(uuid_type ? uuid_type : type, parent_type, skip_logs, is_root_box);\n\t\tif (!newBox) return GF_OUT_OF_MEM;\n\t}\n\n\t//OK, init and read this box\n\tif (type==GF_ISOM_BOX_TYPE_UUID && !is_special) {\n\t\tmemcpy(((GF_UUIDBox *)newBox)->uuid, uuid, 16);\n\t\t((GF_UUIDBox *)newBox)->internal_4cc = uuid_type;\n\t}\n\n\tif (!newBox->type) newBox->type = type;\n\tif (restore_type)\n\t\tnewBox->type = restore_type;\n\n\tend = gf_bs_available(bs);\n\tif (size - hdr_size > end ) {\n\t\tnewBox->size = size - hdr_size - end;\n\t\t*outBox = newBox;\n\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t}\n\n\tnewBox->size = size - hdr_size;\n\n\te = gf_isom_full_box_read(newBox, bs);\n\tif (!e) e = gf_isom_box_read(newBox, bs);\n\tif (e) {\n\t\tif (gf_opts_get_bool(\"core\", \"no-check\"))\n\t\t\te = GF_OK;\n\t}\n\tnewBox->size = size;\n\tend = gf_bs_get_position(bs);\n\n\tif (uncomp_bs) {\n\t\tgf_free(uncomp_data);\n\t\tgf_bs_del(uncomp_bs);\n\t\tif (e) {\n\t\t\tgf_isom_box_del(newBox);\n\t\t\t*outBox = NULL;\n\t\t\treturn e;\n\t\t}\n\t\t//move size to real bitstream offsets for tests below\n\t\tsize -= 8;\n\t\t//remember compressed vs real size info for moof in order to properly recompute data_offset/base_data_offset\n\t\tif (type==GF_ISOM_BOX_TYPE_MOOF) {\n\t\t\t((GF_MovieFragmentBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;\n\t\t}\n\t\t//remember compressed vs real size info for moov in order to properly recompute chunk offset\n\t\telse if (type==GF_ISOM_BOX_TYPE_MOOV) {\n\t\t\t((GF_MovieBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;\n\t\t\t((GF_MovieBox *)newBox)->file_offset = comp_start;\n\t\t}\n\t\t//remember compressed vs real size info for dump\n\t\telse if (type==GF_ISOM_BOX_TYPE_SIDX) {\n\t\t\t((GF_SegmentIndexBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;\n\t\t}\n\t\t//remember compressed vs real size info for dump\n\t\telse if (type==GF_ISOM_BOX_TYPE_SSIX) {\n\t\t\t((GF_SubsegmentIndexBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;\n\t\t}\n\t\tnewBox->internal_flags = GF_ISOM_BOX_COMPRESSED;\n\t}\n\n\n\tif (e && (e != GF_ISOM_INCOMPLETE_FILE)) {\n\t\tgf_isom_box_del(newBox);\n\t\t*outBox = NULL;\n\t\tif (is_root_box && (e==GF_SKIP_BOX))\n\t\t\te = GF_ISOM_INVALID_FILE;\n\n\t\tif (!skip_logs && (e!=GF_SKIP_BOX)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Read Box \\\"%s\\\" (start \"LLU\") failed (%s) - skipping\\n\", gf_4cc_to_str(type), start, gf_error_to_string(e)));\n\t\t}\n\t\t//we don't try to reparse known boxes that have been failing (too dangerous)\n\t\treturn e;\n\t}\n\n\tif (end-start > size) {\n\t\tif (!skip_logs) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" size \"LLU\" (start \"LLU\") invalid (read \"LLU\")\\n\", gf_4cc_to_str(type), size, start, (end-start) ));\n\t\t}\n\t\t/*let's still try to load the file since no error was notified*/\n\t\tgf_bs_seek(bs, start+size);\n\t} else if (end-start < size) {\n\t\tu32 to_skip = (u32) (size-(end-start));\n\t\tif (!skip_logs) {\n\t\t\tif ((to_skip!=4) || gf_bs_peek_bits(bs, 32, 0)) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" (start \"LLU\") has %u extra bytes\\n\", gf_4cc_to_str(type), start, to_skip));\n\t\t\t\tunused_bytes += to_skip;\n\t\t\t}\n\t\t}\n\t\tgf_bs_skip_bytes(bs, to_skip);\n\t}\n\t*outBox = newBox;\n\n\treturn e;\n}\n\nGF_Err gf_isom_parse_root_box(GF_Box **outBox, GF_BitStream *bs, u32 *box_type, u64 *bytesExpected, Bool progressive_mode)\n{\n\tGF_Err ret;\n\tu64 start;\n\tstart = gf_bs_get_position(bs);\n\tret = gf_isom_box_parse_ex(outBox, bs, 0, GF_TRUE, 0);\n\tif (ret == GF_ISOM_INCOMPLETE_FILE) {\n\t\tif (!*outBox) {\n\t\t\t// We could not even read the box size, we at least need 8 bytes\n\t\t\t*bytesExpected = 8;\n\t\t\tif (box_type) *box_type = 0;\n\t\t\tGF_LOG(progressive_mode ? GF_LOG_DEBUG : GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Incomplete box - start \"LLU\"\\n\", start));\n\t\t}\n\t\telse {\n\t\t\tu32 type = (*outBox)->type;\n\t\t\tif (type==GF_ISOM_BOX_TYPE_UNKNOWN)\n\t\t\t\ttype = ((GF_UnknownBox *) (*outBox))->original_4cc;\n\n\t\t\t*bytesExpected = (*outBox)->size;\n\t\t\tif (box_type) *box_type = (*outBox)->type;\n\n\t\t\tGF_LOG(progressive_mode ? GF_LOG_DEBUG : GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Incomplete box %s - start \"LLU\" size \"LLU\"\\n\", gf_4cc_to_str(type), start, (*outBox)->size));\n\t\t\tgf_isom_box_del(*outBox);\n\t\t\t*outBox = NULL;\n\t\t}\n\t\tgf_bs_seek(bs, start);\n\t}\n\treturn ret;\n}\n\nGF_Err gf_isom_parse_movie_boxes(GF_ISOFile *mov, u32 *boxType, u64 *bytesMissing, Bool progressive_mode)\n{\n\tGF_Err e;\n\tGF_Blob *blob = NULL;\n\n\t//if associated file is a blob, lock blob before parsing !\n\tif (mov->movieFileMap && ((mov->movieFileMap->type == GF_ISOM_DATA_MEM) || (mov->movieFileMap->type == GF_ISOM_DATA_FILE))) {\n\t\tblob = ((GF_FileDataMap *)mov->movieFileMap)->blob;\n\t}\n\n\tif (blob)\n\t\tgf_mx_p(blob->mx);\n\n\tunused_bytes = 0;\n\te = gf_isom_parse_movie_boxes_internal(mov, boxType, bytesMissing, progressive_mode);\n\n\tif (blob)\n\t\tgf_mx_v(blob->mx);\n\treturn e;\n\n}\n\nGF_Err gf_isom_parse_movie_boxes(GF_ISOFile *mov, u32 *boxType, u64 *bytesMissing, Bool progressive_mode)\n{\n\tGF_Err e;\n\tGF_Blob *blob = NULL;\n\n\t//if associated file is a blob, lock blob before parsing !\n\tif (mov->movieFileMap && ((mov->movieFileMap->type == GF_ISOM_DATA_MEM) || (mov->movieFileMap->type == GF_ISOM_DATA_FILE))) {\n\t\tblob = ((GF_FileDataMap *)mov->movieFileMap)->blob;\n\t}\n\n\tif (blob)\n\t\tgf_mx_p(blob->mx);\n\n\tunused_bytes = 0;\n\te = gf_isom_parse_movie_boxes_internal(mov, boxType, bytesMissing, progressive_mode);\n\n\tif (blob)\n\t\tgf_mx_v(blob->mx);\n\treturn e;\n\n}\n\n\n\n\n// target function\nGF_Err diST_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tchar str[1024];\n\tGF_DIMSScriptTypesBox *p = (GF_DIMSScriptTypesBox *)s;\n\n\ti=0;\n\tstr[0]=0;\n\twhile (1) {\n\t\tstr[i] = gf_bs_read_u8(bs);\n\t\tif (!str[i]) break;\n\t\ti++;\n\t}\n\tISOM_DECREASE_SIZE(p, i);\n\n\tp->content_script_types = gf_strdup(str);\n\treturn GF_OK;\n}\n",
    "target": 1,
    "idx": 1044221,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nint\ncdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h,\n    uint32_t offs, cdf_property_info_t **info, size_t *count, size_t *maxcount)\n{\n\tconst cdf_section_header_t *shp;\n\tcdf_section_header_t sh;\n\tconst uint8_t *p, *q, *e;\n\tsize_t i, o4, nelements, j, slen, left;\n\tcdf_property_info_t *inp;\n\n\tif (offs > UINT32_MAX / 4) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tshp = CAST(const cdf_section_header_t *,\n\t    cdf_offset(sst->sst_tab, offs));\n\tif (cdf_check_stream_offset(sst, h, shp, sizeof(*shp), __LINE__) == -1)\n\t\tgoto out;\n\tsh.sh_len = CDF_TOLE4(shp->sh_len);\n\tif (sh.sh_len > CDF_SHLEN_LIMIT) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\n\tif (cdf_check_stream_offset(sst, h, shp, sh.sh_len, __LINE__) == -1)\n\t\tgoto out;\n\n\tsh.sh_properties = CDF_TOLE4(shp->sh_properties);\n\tDPRINTF((\"section len: %u properties %u\\n\", sh.sh_len,\n\t    sh.sh_properties));\n\tif (sh.sh_properties > CDF_PROP_LIMIT)\n\t\tgoto out;\n\tinp = cdf_grow_info(info, maxcount, sh.sh_properties);\n\tif (inp == NULL)\n\t\tgoto out;\n\tinp += *count;\n\t*count += sh.sh_properties;\n\tp = CAST(const uint8_t *, cdf_offset(sst->sst_tab, offs + sizeof(sh)));\n\te = CAST(const uint8_t *, cdf_offset(shp, sh.sh_len));\n\tif (p >= e || cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1)\n\t\tgoto out;\n\n\tfor (i = 0; i < sh.sh_properties; i++) {\n\t\tif ((q = cdf_get_property_info_pos(sst, h, p, e, i)) == NULL)\n\t\t\tgoto out;\n\t\tinp[i].pi_id = CDF_GETUINT32(p, i << 1);\n\t\tleft = CAST(size_t, e - q);\n\t\tif (left < sizeof(uint32_t)) {\n\t\t\tDPRINTF((\"short info (no type)_\\n\"));\n\t\t\tgoto out;\n\t\t}\n\t\tinp[i].pi_type = CDF_GETUINT32(q, 0);\n\t\tDPRINTF((\"%\" SIZE_T_FORMAT \"u) id=%#x type=%#x offs=%#tx,%#x\\n\",\n\t\t    i, inp[i].pi_id, inp[i].pi_type, q - p, offs));\n\t\tif (inp[i].pi_type & CDF_VECTOR) {\n\t\t\tif (left < sizeof(uint32_t) * 2) {\n\t\t\t\tDPRINTF((\"missing CDF_VECTOR length\\n\"));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tnelements = CDF_GETUINT32(q, 1);\n\t\t\tif (nelements == 0) {\n\t\t\t\tDPRINTF((\"CDF_VECTOR with nelements == 0\\n\"));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tslen = 2;\n\t\t} else {\n\t\t\tnelements = 1;\n\t\t\tslen = 1;\n\t\t}\n\t\to4 = slen * sizeof(uint32_t);\n\t\tif (inp[i].pi_type & (CDF_ARRAY|CDF_BYREF|CDF_RESERVED))\n\t\t\tgoto unknown;\n\t\tswitch (inp[i].pi_type & CDF_TYPEMASK) {\n\t\tcase CDF_NULL:\n\t\tcase CDF_EMPTY:\n\t\t\tbreak;\n\t\tcase CDF_SIGNED16:\n\t\t\tif (!cdf_copy_info(&inp[i], &q[o4], e, sizeof(int16_t)))\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tcase CDF_SIGNED32:\n\t\tcase CDF_BOOL:\n\t\tcase CDF_UNSIGNED32:\n\t\tcase CDF_FLOAT:\n\t\t\tif (!cdf_copy_info(&inp[i], &q[o4], e, sizeof(int32_t)))\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tcase CDF_SIGNED64:\n\t\tcase CDF_UNSIGNED64:\n\t\tcase CDF_DOUBLE:\n\t\tcase CDF_FILETIME:\n\t\t\tif (!cdf_copy_info(&inp[i], &q[o4], e, sizeof(int64_t)))\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tcase CDF_LENGTH32_STRING:\n\t\tcase CDF_LENGTH32_WSTRING:\n\t\t\tif (nelements > 1) {\n\t\t\t\tsize_t nelem = inp - *info;\n\t\t\t\tinp = cdf_grow_info(info, maxcount, nelements);\n\t\t\t\tif (inp == NULL)\n\t\t\t\t\tgoto out;\n\t\t\t\tinp += nelem;\n\t\t\t}\n\t\t\tDPRINTF((\"nelements = %\" SIZE_T_FORMAT \"u\\n\",\n\t\t\t    nelements));\n\t\t\tfor (j = 0; j < nelements && i < sh.sh_properties;\n\t\t\t    j++, i++)\n\t\t\t{\n\t\t\t\tuint32_t l;\n\n\t\t\t\tif (o4 + sizeof(uint32_t) > left)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tl = CDF_GETUINT32(q, slen);\n\t\t\t\to4 += sizeof(uint32_t);\n\t\t\t\tif (o4 + l > left)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tinp[i].pi_str.s_len = l;\n\t\t\t\tinp[i].pi_str.s_buf = CAST(const char *,\n\t\t\t\t    CAST(const void *, &q[o4]));\n\n\t\t\t\tDPRINTF((\"o=%\" SIZE_T_FORMAT \"u l=%d(%\"\n\t\t\t\t    SIZE_T_FORMAT \"u), t=%\" SIZE_T_FORMAT\n\t\t\t\t    \"u s=%s\\n\", o4, l, CDF_ROUND(l, sizeof(l)),\n\t\t\t\t    left, inp[i].pi_str.s_buf));\n\n\t\t\t\tif (l & 1)\n\t\t\t\t\tl++;\n\n\t\t\t\tslen += l >> 1;\n\t\t\t\to4 = slen * sizeof(uint32_t);\n\t\t\t}\n\t\t\ti--;\n\t\t\tbreak;\n\t\tcase CDF_CLIPBOARD:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tdefault:\n\t\tunknown:\n\t\t\tmemset(&inp[i].pi_val, 0, sizeof(inp[i].pi_val));\n\t\t\tDPRINTF((\"Don't know how to deal with %#x\\n\",\n\t\t\t    inp[i].pi_type));\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\nout:\n\tfree(*info);\n\t*info = NULL;\n\t*count = 0;\n\t*maxcount = 0;\n\terrno = EFTYPE;\n\treturn -1;\n}\n\nint\ncdf_unpack_summary_info(const cdf_stream_t *sst, const cdf_header_t *h,\n    cdf_summary_info_header_t *ssi, cdf_property_info_t **info, size_t *count)\n{\n\tsize_t maxcount;\n\tconst cdf_summary_info_header_t *si =\n\t    CAST(const cdf_summary_info_header_t *, sst->sst_tab);\n\tconst cdf_section_declaration_t *sd =\n\t    CAST(const cdf_section_declaration_t *, RCAST(const void *,\n\t    RCAST(const char *, sst->sst_tab)\n\t    + CDF_SECTION_DECLARATION_OFFSET));\n\n\tif (cdf_check_stream_offset(sst, h, si, sizeof(*si), __LINE__) == -1 ||\n\t    cdf_check_stream_offset(sst, h, sd, sizeof(*sd), __LINE__) == -1)\n\t\treturn -1;\n\tssi->si_byte_order = CDF_TOLE2(si->si_byte_order);\n\tssi->si_os_version = CDF_TOLE2(si->si_os_version);\n\tssi->si_os = CDF_TOLE2(si->si_os);\n\tssi->si_class = si->si_class;\n\tcdf_swap_class(&ssi->si_class);\n\tssi->si_count = CDF_TOLE4(si->si_count);\n\t*count = 0;\n\tmaxcount = 0;\n\t*info = NULL;\n\tif (cdf_read_property_info(sst, h, CDF_TOLE4(sd->sd_offset), info,\n\t    count, &maxcount) == -1)\n\t\treturn -1;\n\treturn 0;\n}\n\nprivate int\ncdf_file_summary_info(struct magic_set *ms, const cdf_header_t *h,\n    const cdf_stream_t *sst, const cdf_directory_t *root_storage)\n{\n\tcdf_summary_info_header_t si;\n\tcdf_property_info_t *info;\n\tsize_t count;\n\tint m;\n\n\tif (cdf_unpack_summary_info(sst, h, &si, &info, &count) == -1)\n\t\treturn -1;\n\n\tif (NOTMIME(ms)) {\n\t\tconst char *str;\n\n\t\tif (file_printf(ms, \"Composite Document File V2 Document\")\n\t\t    == -1)\n\t\t\treturn -1;\n\n\t\tif (file_printf(ms, \", %s Endian\",\n\t\t    si.si_byte_order == 0xfffe ?  \"Little\" : \"Big\") == -1)\n\t\t\treturn -2;\n\t\tswitch (si.si_os) {\n\t\tcase 2:\n\t\t\tif (file_printf(ms, \", Os: Windows, Version %d.%d\",\n\t\t\t    si.si_os_version & 0xff,\n\t\t\t    CAST(uint32_t, si.si_os_version) >> 8) == -1)\n\t\t\t\treturn -2;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (file_printf(ms, \", Os: MacOS, Version %d.%d\",\n\t\t\t    CAST(uint32_t, si.si_os_version) >> 8,\n\t\t\t    si.si_os_version & 0xff) == -1)\n\t\t\t\treturn -2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (file_printf(ms, \", Os %d, Version: %d.%d\", si.si_os,\n\t\t\t    si.si_os_version & 0xff,\n\t\t\t    CAST(uint32_t, si.si_os_version) >> 8) == -1)\n\t\t\t\treturn -2;\n\t\t\tbreak;\n\t\t}\n\t\tif (root_storage) {\n\t\t\tstr = cdf_clsid_to_mime(root_storage->d_storage_uuid,\n\t\t\t    clsid2desc);\n\t\t\tif (str) {\n\t\t\t\tif (file_printf(ms, \", %s\", str) == -1)\n\t\t\t\t\treturn -2;\n\t\t\t}\n\t\t}\n\t}\n\n\tm = cdf_file_property_info(ms, info, count, root_storage);\n\tfree(info);\n\n\treturn m == -1 ? -2 : m;\n}\n\nprivate int\ncdf_check_summary_info(struct magic_set *ms, const cdf_info_t *info,\n    const cdf_header_t *h, const cdf_sat_t *sat, const cdf_sat_t *ssat,\n    const cdf_stream_t *sst, const cdf_dir_t *dir, cdf_stream_t *scn,\n    const cdf_directory_t *root_storage, const char **expn)\n{\n\tint i;\n\tconst char *str = NULL;\n\tcdf_directory_t *d;\n\tchar name[__arraycount(d->d_name)];\n\tsize_t j, k;\n\n#ifdef CDF_DEBUG\n\tcdf_dump_summary_info(h, scn);\n#endif\n\tif ((i = cdf_file_summary_info(ms, h, scn, root_storage)) < 0) {\n\t    *expn = \"Can't expand summary_info\";\n\t    return i;\n\t}\n\tif (i == 1)\n\t\treturn i;\n\tfor (j = 0; str == NULL && j < dir->dir_len; j++) {\n\t\td = &dir->dir_tab[j];\n\t\tfor (k = 0; k < sizeof(name); k++)\n\t\t\tname[k] = CAST(char, cdf_tole2(d->d_name[k]));\n\t\tstr = cdf_app_to_mime(name,\n\t\t\t\t      NOTMIME(ms) ? name2desc : name2mime);\n\t}\n\tif (NOTMIME(ms)) {\n\t\tif (str != NULL) {\n\t\t\tif (file_printf(ms, \"%s\", str) == -1)\n\t\t\t\treturn -1;\n\t\t\ti = 1;\n\t\t}\n\t} else if (ms->flags & MAGIC_MIME_TYPE) {\n\t\tif (str == NULL)\n\t\t\tstr = \"vnd.ms-office\";\n\t\tif (file_printf(ms, \"application/%s\", str) == -1)\n\t\t\treturn -1;\n\t\ti = 1;\n\t}\n\tif (i <= 0) {\n\t\ti = cdf_file_catalog_info(ms, info, h, sat, ssat, sst,\n\t\t\t\t\t  dir, scn);\n\t}\n\treturn i;\n}\n\nprotected int\nfile_trycdf(struct magic_set *ms, const struct buffer *b)\n{\n\tint fd = b->fd;\n\tconst unsigned char *buf = CAST(const unsigned char *, b->fbuf);\n\tsize_t nbytes = b->flen;\n\tcdf_info_t info;\n\tcdf_header_t h;\n\tcdf_sat_t sat, ssat;\n\tcdf_stream_t sst, scn;\n\tcdf_dir_t dir;\n\tint i;\n\tconst char *expn = \"\";\n\tconst cdf_directory_t *root_storage;\n\n\tscn.sst_tab = NULL;\n\tinfo.i_fd = fd;\n\tinfo.i_buf = buf;\n\tinfo.i_len = nbytes;\n\tif (ms->flags & (MAGIC_APPLE|MAGIC_EXTENSION))\n\t\treturn 0;\n\tif (cdf_read_header(&info, &h) == -1)\n\t\treturn 0;\n#ifdef CDF_DEBUG\n\tcdf_dump_header(&h);\n#endif\n\n\tif ((i = cdf_read_sat(&info, &h, &sat)) == -1) {\n\t\texpn = \"Can't read SAT\";\n\t\tgoto out0;\n\t}\n#ifdef CDF_DEBUG\n\tcdf_dump_sat(\"SAT\", &sat, CDF_SEC_SIZE(&h));\n#endif\n\n\tif ((i = cdf_read_ssat(&info, &h, &sat, &ssat)) == -1) {\n\t\texpn = \"Can't read SSAT\";\n\t\tgoto out1;\n\t}\n#ifdef CDF_DEBUG\n\tcdf_dump_sat(\"SSAT\", &ssat, CDF_SHORT_SEC_SIZE(&h));\n#endif\n\n\tif ((i = cdf_read_dir(&info, &h, &sat, &dir)) == -1) {\n\t\texpn = \"Can't read directory\";\n\t\tgoto out2;\n\t}\n\n\tif ((i = cdf_read_short_stream(&info, &h, &sat, &dir, &sst,\n\t    &root_storage)) == -1) {\n\t\texpn = \"Cannot read short stream\";\n\t\tgoto out3;\n\t}\n#ifdef CDF_DEBUG\n\tcdf_dump_dir(&info, &h, &sat, &ssat, &sst, &dir);\n#endif\n#ifdef notdef\n\tif (root_storage) {\n\t\tif (NOTMIME(ms)) {\n\t\t\tchar clsbuf[128];\n\t\t\tif (file_printf(ms, \"CLSID %s, \",\n\t\t\t    format_clsid(clsbuf, sizeof(clsbuf),\n\t\t\t    root_storage->d_storage_uuid)) == -1)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n#endif\n\n\tif ((i = cdf_read_user_stream(&info, &h, &sat, &ssat, &sst, &dir,\n\t    \"FileHeader\", &scn)) != -1) {\n#define HWP5_SIGNATURE \"HWP Document File\"\n\t\tif (scn.sst_len * scn.sst_ss >= sizeof(HWP5_SIGNATURE) - 1\n\t\t    && memcmp(scn.sst_tab, HWP5_SIGNATURE,\n\t\t    sizeof(HWP5_SIGNATURE) - 1) == 0) {\n\t\t    if (NOTMIME(ms)) {\n\t\t\tif (file_printf(ms,\n\t\t\t    \"Hangul (Korean) Word Processor File 5.x\") == -1)\n\t\t\t    return -1;\n\t\t    } else if (ms->flags & MAGIC_MIME_TYPE) {\n\t\t\tif (file_printf(ms, \"application/x-hwp\") == -1)\n\t\t\t    return -1;\n\t\t    }\n\t\t    i = 1;\n\t\t    goto out5;\n\t\t} else {\n\t\t    cdf_zero_stream(&scn);\n\t\t}\n\t}\n\n\tif ((i = cdf_read_summary_info(&info, &h, &sat, &ssat, &sst, &dir,\n\t    &scn)) == -1) {\n\t\tif (errno != ESRCH) {\n\t\t\texpn = \"Cannot read summary info\";\n\t\t}\n\t} else {\n\t\ti = cdf_check_summary_info(ms, &info, &h,\n\t\t    &sat, &ssat, &sst, &dir, &scn, root_storage, &expn);\n\t\tcdf_zero_stream(&scn);\n\t}\n\tif (i <= 0) {\n\t\tif ((i = cdf_read_doc_summary_info(&info, &h, &sat, &ssat,\n\t\t    &sst, &dir, &scn)) == -1) {\n\t\t\tif (errno != ESRCH) {\n\t\t\t\texpn = \"Cannot read summary info\";\n\t\t\t}\n\t\t} else {\n\t\t\ti = cdf_check_summary_info(ms, &info, &h, &sat, &ssat,\n\t\t\t    &sst, &dir, &scn, root_storage, &expn);\n\t\t}\n\t}\n\tif (i <= 0) {\n\t\ti = cdf_file_dir_info(ms, &dir);\n\t\tif (i < 0)\n\t\t\texpn = \"Cannot read section info\";\n\t}\nout5:\n\tcdf_zero_stream(&scn);\n\tcdf_zero_stream(&sst);\nout3:\n\tfree(dir.dir_tab);\nout2:\n\tfree(ssat.sat_tab);\nout1:\n\tfree(sat.sat_tab);\nout0:\n\t/* If we handled it already, return */\n\tif (i != -1)\n\t\treturn i;\n\t/* Provide a default handler */\n\tif (NOTMIME(ms)) {\n\t\tif (file_printf(ms,\n\t\t    \"Composite Document File V2 Document\") == -1)\n\t\t\treturn -1;\n\t\tif (*expn)\n\t\t\tif (file_printf(ms, \", %s\", expn) == -1)\n\t\t\t\treturn -1;\n\t} else if (ms->flags & MAGIC_MIME_TYPE) {\n\t\tif (file_printf(ms, \"application/CDFV2\") == -1)\n\t\t\treturn -1;\n\t}\n\treturn 1;\n}\n\nprotected int\nfile_buffer(struct magic_set *ms, int fd, struct stat *st,\n    const char *inname __attribute__ ((__unused__)),\n    const void *buf, size_t nb)\n{\n\tint m = 0, rv = 0, looks_text = 0;\n\tconst char *code = NULL;\n\tconst char *code_mime = \"binary\";\n\tconst char *def = \"data\";\n\tconst char *ftype = NULL;\n\tchar *rbuf = NULL;\n\tstruct buffer b;\n\n\tbuffer_init(&b, fd, st, buf, nb);\n\tms->mode = b.st.st_mode;\n\n\tif (nb == 0) {\n\t\tdef = \"empty\";\n\t\tgoto simple;\n\t} else if (nb == 1) {\n\t\tdef = \"very short file (no magic)\";\n\t\tgoto simple;\n\t}\n\n\tif ((ms->flags & MAGIC_NO_CHECK_ENCODING) == 0) {\n\t\tlooks_text = file_encoding(ms, &b, NULL, 0,\n\t\t    &code, &code_mime, &ftype);\n\t}\n\n#ifdef __EMX__\n\tif ((ms->flags & MAGIC_NO_CHECK_APPTYPE) == 0 && inname) {\n\t\tm = file_os2_apptype(ms, inname, &b);\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t(void)fprintf(stderr, \"[try os2_apptype %d]\\n\", m);\n\t\tswitch (m) {\n\t\tcase -1:\n\t\t\treturn -1;\n\t\tcase 0:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 1;\n\t\t}\n\t}\n#endif\n#if HAVE_FORK\n\t/* try compression stuff */\n\tif ((ms->flags & MAGIC_NO_CHECK_COMPRESS) == 0) {\n\t\tm = file_zmagic(ms, &b, inname);\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t(void)fprintf(stderr, \"[try zmagic %d]\\n\", m);\n\t\tif (m) {\n\t\t\tgoto done_encoding;\n\t\t}\n\t}\n#endif\n\t/* Check if we have a tar file */\n\tif ((ms->flags & MAGIC_NO_CHECK_TAR) == 0) {\n\t\tm = file_is_tar(ms, &b);\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t(void)fprintf(stderr, \"[try tar %d]\\n\", m);\n\t\tif (m) {\n\t\t\tif (checkdone(ms, &rv))\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* Check if we have a JSON file */\n\tif ((ms->flags & MAGIC_NO_CHECK_JSON) == 0) {\n\t\tm = file_is_json(ms, &b);\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t(void)fprintf(stderr, \"[try json %d]\\n\", m);\n\t\tif (m) {\n\t\t\tif (checkdone(ms, &rv))\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* Check if we have a CSV file */\n\tif ((ms->flags & MAGIC_NO_CHECK_CSV) == 0) {\n\t\tm = file_is_csv(ms, &b, looks_text);\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t(void)fprintf(stderr, \"[try csv %d]\\n\", m);\n\t\tif (m) {\n\t\t\tif (checkdone(ms, &rv))\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* Check if we have a CDF file */\n\tif ((ms->flags & MAGIC_NO_CHECK_CDF) == 0) {\n\t\tm = file_trycdf(ms, &b);\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t(void)fprintf(stderr, \"[try cdf %d]\\n\", m);\n\t\tif (m) {\n\t\t\tif (checkdone(ms, &rv))\n\t\t\t\tgoto done;\n\t\t}\n\t}\n#ifdef BUILTIN_ELF\n\tif ((ms->flags & MAGIC_NO_CHECK_ELF) == 0 && nb > 5 && fd != -1) {\n\t\tfile_pushbuf_t *pb;\n\t\t/*\n\t\t * We matched something in the file, so this\n\t\t * *might* be an ELF file, and the file is at\n\t\t * least 5 bytes long, so if it's an ELF file\n\t\t * it has at least one byte past the ELF magic\n\t\t * number - try extracting information from the\n\t\t * ELF headers that cannot easily be  extracted\n\t\t * with rules in the magic file. We we don't\n\t\t * print the information yet.\n\t\t */\n\t\tif ((pb = file_push_buffer(ms)) == NULL)\n\t\t\treturn -1;\n\n\t\trv = file_tryelf(ms, &b);\n\t\trbuf = file_pop_buffer(ms, pb);\n\t\tif (rv == -1) {\n\t\t\tfree(rbuf);\n\t\t\trbuf = NULL;\n\t\t}\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t(void)fprintf(stderr, \"[try elf %d]\\n\", m);\n\t}\n#endif\n\n\t/* try soft magic tests */\n\tif ((ms->flags & MAGIC_NO_CHECK_SOFT) == 0) {\n\t\tm = file_softmagic(ms, &b, NULL, NULL, BINTEST, looks_text);\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t(void)fprintf(stderr, \"[try softmagic %d]\\n\", m);\n\t\tif (m == 1 && rbuf) {\n\t\t\tif (file_printf(ms, \"%s\", rbuf) == -1)\n\t\t\t\tgoto done;\n\t\t}\n\t\tif (m) {\n\t\t\tif (checkdone(ms, &rv))\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* try text properties */\n\tif ((ms->flags & MAGIC_NO_CHECK_TEXT) == 0) {\n\n\t\tm = file_ascmagic(ms, &b, looks_text);\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t(void)fprintf(stderr, \"[try ascmagic %d]\\n\", m);\n\t\tif (m) {\n\t\t\tgoto done;\n\t\t}\n\t}\n\nsimple:\n\t/* give up */\n\tif (m == 0) {\n\t\tm = 1;\n\t\trv = file_default(ms, nb);\n\t\tif (rv == 0)\n\t\t\tif (file_printf(ms, \"%s\", def) == -1)\n\t\t\t\trv = -1;\n\t}\n done:\n\tif ((ms->flags & MAGIC_MIME_ENCODING) != 0) {\n\t\tif (ms->flags & MAGIC_MIME_TYPE)\n\t\t\tif (file_printf(ms, \"; charset=\") == -1)\n\t\t\t\trv = -1;\n\t\tif (file_printf(ms, \"%s\", code_mime) == -1)\n\t\t\trv = -1;\n\t}\n#if HAVE_FORK\n done_encoding:\n#endif\n\tfree(rbuf);\n\tbuffer_fini(&b);\n\tif (rv)\n\t\treturn rv;\n\n\treturn m;\n}\n\n\n\n\n// target function\nssize_t\ncdf_read_short_sector(const cdf_stream_t *sst, void *buf, size_t offs,\n    size_t len, const cdf_header_t *h, cdf_secid_t id)\n{\n\tsize_t ss = CDF_SHORT_SEC_SIZE(h);\n\tsize_t pos = CDF_SHORT_SEC_POS(h, id);\n\tassert(ss == len);\n\tif (pos + len > CDF_SEC_SIZE(h) * sst->sst_len) {\n\t\tDPRINTF((\"Out of bounds read %\" SIZE_T_FORMAT \"u > %\"\n\t\t    SIZE_T_FORMAT \"u\\n\",\n\t\t    pos + len, CDF_SEC_SIZE(h) * sst->sst_len));\n\t\tgoto out;\n\t}\n\t(void)memcpy(RCAST(char *, buf) + offs,\n\t    RCAST(const char *, sst->sst_tab) + pos, len);\n\treturn len;\nout:\n\terrno = EFTYPE;\n\treturn -1;\n}\n",
    "target": 1,
    "idx": 1016634,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "// context\nstatic int\npiv_compute_signature(sc_card_t *card, const u8 * data, size_t datalen,\n\t\tu8 * out, size_t outlen)\n{\n\tpiv_private_data_t * priv = PIV_DATA(card);\n\tint r;\n\tint i;\n\tsize_t nLen;\n\tu8 rbuf[128]; /* For EC conversions  384 will fit */\n\tconst unsigned char *pseq, *pint, *ptemp, *pend;\n\tunsigned int cla, tag;\n\tsize_t seqlen;\n\tsize_t intlen;\n\tsize_t templen;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\t/* The PIV returns a DER SEQUENCE{INTEGER, INTEGER}\n\t * Which may have leading 00 to force a positive integer\n\t * But PKCS11 just wants 2* field_length in bytes\n\t * So we have to strip out the integers\n\t * and pad on left if too short.\n\t */\n\n\tif (priv->alg_id == 0x11 || priv->alg_id == 0x14 ) {\n\t\tnLen = (priv->key_size + 7) / 8;\n\t\tif (outlen < 2*nLen) {\n\t\t\tsc_log(card->ctx,\n\t\t\t       \" output too small for EC signature %\"SC_FORMAT_LEN_SIZE_T\"u < %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t\t       outlen, 2 * nLen);\n\t\t\tr = SC_ERROR_INVALID_DATA;\n\t\t\tgoto err;\n\t\t}\n\t\tmemset(out, 0, outlen);\n\n\t\tr = piv_validate_general_authentication(card, data, datalen, rbuf, sizeof rbuf);\n\t\tif (r < 0)\n\t\t\tgoto err;\n\n\t\tpseq = rbuf;\n\t\tr = sc_asn1_read_tag(&pseq, r, &cla, &tag, &seqlen);\n\t\tif (pseq == NULL || r < 0 || seqlen == 0 || (cla|tag) != 0x30)\n\t\t\tLOG_TEST_GOTO_ERR(card->ctx, SC_ERROR_INVALID_DATA, \"Can't find 0x30\");\n\n\t\tpint = pseq;\n\t\tpend = pseq + seqlen;\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tr = sc_asn1_read_tag(&pint, (pend - pint), &cla, &tag, &intlen);\n\t\t\tif (pint == NULL || r < 0 || intlen == 0 || (cla|tag) != 0x02)\n\t\t\t\tLOG_TEST_GOTO_ERR(card->ctx, SC_ERROR_INVALID_DATA, \"Can't find 0x02\");\n\t\t\tif (intlen > nLen + 1)\n\t\t\t\tLOG_TEST_GOTO_ERR(card->ctx, SC_ERROR_INVALID_DATA,\"Signature too long\");\n\n\t\t\tptemp = pint;\n\t\t\ttemplen = intlen;\n\t\t\tif (intlen > nLen) { /* drop leading 00 if present */\n\t\t\t\tif (*ptemp != 0x00) {\n\t\t\t\t\tLOG_TEST_GOTO_ERR(card->ctx, SC_ERROR_INVALID_DATA,\"Signature too long\");\n\t\t\t\t\tr = SC_ERROR_INVALID_DATA;\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tptemp++;\n\t\t\t\ttemplen--;\n\t\t\t}\n\t\t\tmemcpy(out + nLen*i + nLen - templen , ptemp, templen);\n\t\t\tpint += intlen; /* next integer */\n\t\t\t\n\t\t}\n\t\tr = 2 * nLen;\n\t} else { /* RSA is all set */\n\t\tr = piv_validate_general_authentication(card, data, datalen, out, outlen);\n\t}\n\nerr:\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);\n}\n\nint sc_compute_signature(sc_card_t *card,\n\t\t\t const u8 * data, size_t datalen,\n\t\t\t u8 * out, size_t outlen)\n{\n\tint r;\n\n\tif (card == NULL) {\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\tLOG_FUNC_CALLED(card->ctx);\n\tif (card->ops->compute_signature == NULL)\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_NOT_SUPPORTED);\n\tr = card->ops->compute_signature(card, data, datalen, out, outlen);\n        SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);\n}\n\nstatic int use_key(struct sc_pkcs15_card *p15card,\n\t\tconst struct sc_pkcs15_object *obj,\n\t\tsc_security_env_t *senv,\n\t\tint (*card_command)(sc_card_t *card,\n\t\t\t const u8 * in, size_t inlen,\n\t\t\t u8 * out, size_t outlen),\n\t\tconst u8 * in, size_t inlen, u8 * out, size_t outlen)\n{\n\tint r = SC_SUCCESS;\n\tint revalidated_cached_pin = 0;\n\tsc_path_t path;\n\tLOG_TEST_RET(p15card->card->ctx, get_file_path(obj, &path), \"Failed to get key file path.\");\n\n\tr = sc_lock(p15card->card);\n\tLOG_TEST_RET(p15card->card->ctx, r, \"sc_lock() failed\");\n\n\tdo {\n\t\tif (path.len != 0 || path.aid.len != 0) {\n\t\t\tr = select_key_file(p15card, obj, senv);\n\t\t\tif (r < 0) {\n\t\t\t\tsc_log(p15card->card->ctx,\n\t\t\t\t\t\t\"Unable to select private key file\");\n\t\t\t}\n\t\t}\n\t\tif (r == SC_SUCCESS)\n\t\t\tr = sc_set_security_env(p15card->card, senv, 0);\n\n\t\tif (r == SC_SUCCESS)\n\t\t\tr = card_command(p15card->card, in, inlen, out, outlen);\n\n\t\tif (revalidated_cached_pin)\n\t\t\t/* only re-validate once */\n\t\t\tbreak;\n\t\tif (r == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED) {\n\t\t\tr = sc_pkcs15_pincache_revalidate(p15card, obj);\n\t\t\tif (r < 0)\n\t\t\t\tbreak;\n\t\t\trevalidated_cached_pin = 1;\n\t\t}\n\t} while (revalidated_cached_pin);\n\n\tsc_unlock(p15card->card);\n\n\tLOG_FUNC_RETURN(p15card->card->ctx, r);\n}\n\nint sc_pkcs15_compute_signature(struct sc_pkcs15_card *p15card,\n\t\t\t\tconst struct sc_pkcs15_object *obj,\n\t\t\t\tunsigned long flags, const u8 *in, size_t inlen,\n\t\t\t\tu8 *out, size_t outlen)\n{\n\tsc_context_t *ctx = p15card->card->ctx;\n\tint r;\n\tsc_security_env_t senv;\n\tsc_algorithm_info_t *alg_info;\n\tconst struct sc_pkcs15_prkey_info *prkey = (const struct sc_pkcs15_prkey_info *) obj->data;\n\tu8 buf[1024], *tmp;\n\tsize_t modlen;\n\tunsigned long pad_flags = 0, sec_flags = 0;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tif (!(prkey->usage & (SC_PKCS15_PRKEY_USAGE_SIGN|SC_PKCS15_PRKEY_USAGE_SIGNRECOVER|\n\t\t\t\t\tSC_PKCS15_PRKEY_USAGE_NONREPUDIATION)))\n\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_ALLOWED, \"This key cannot be used for signing\");\n\n\tr = format_senv(p15card, obj, &senv, &alg_info);\n\tLOG_TEST_RET(ctx, r, \"Could not initialize security environment\");\n\tsenv.operation = SC_SEC_OPERATION_SIGN;\n\n\tswitch (obj->type) {\n\t\tcase SC_PKCS15_TYPE_PRKEY_RSA:\n\t\t\tmodlen = (prkey->modulus_length + 7) / 8;\n\t\t\tbreak;\n\t\tcase SC_PKCS15_TYPE_PRKEY_GOSTR3410:\n\t\t\tmodlen = (prkey->modulus_length + 7) / 8 * 2;\n\t\t\tbreak;\n\t\tcase SC_PKCS15_TYPE_PRKEY_EC:\n\t\tcase SC_PKCS15_TYPE_PRKEY_EDDSA:\n\t\tcase SC_PKCS15_TYPE_PRKEY_XEDDSA:\n\t\t\tmodlen = ((prkey->field_length +7) / 8) * 2;  /* 2*nLen */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"Key type not supported\");\n\t}\n\n\t/* Probably never happens, but better make sure */\n\tif (inlen > sizeof(buf) || outlen < modlen)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_BUFFER_TOO_SMALL);\n\n\tmemcpy(buf, in, inlen);\n\n\t/* revert data to sign when signing with the GOST key.\n\t * TODO: can it be confirmed by the GOST standard?\n\t * TODO: tested with RuTokenECP, has to be validated for RuToken. */\n\tif (obj->type == SC_PKCS15_TYPE_PRKEY_GOSTR3410) {\n\t\tr = sc_mem_reverse(buf, inlen);\n\t\tLOG_TEST_RET(ctx, r, \"Reverse memory error\");\n\t}\n\n\ttmp = buf;\n\n\t/* flags: the requested algo\n\t * algo_info->flags: what is supported by the card\n\t * senv.algorithm_flags: what the card will have to do */\n\n\t/* if the card has SC_ALGORITHM_NEED_USAGE set, and the\n\t * key is for signing and decryption, we need to emulate signing */\n\n\tsc_log(ctx, \"supported algorithm flags 0x%X, private key usage 0x%X\", alg_info->flags, prkey->usage);\n\tif (obj->type == SC_PKCS15_TYPE_PRKEY_RSA) {\n\t\tif ((alg_info->flags & SC_ALGORITHM_NEED_USAGE) &&\n\t\t\t((prkey->usage & USAGE_ANY_SIGN) &&\n\t\t\t(prkey->usage & USAGE_ANY_DECIPHER)) ) {\n\t\t\tsize_t tmplen = sizeof(buf);\n\t\t\tif (flags & SC_ALGORITHM_RSA_RAW) {\n\t\t\t\tr = sc_pkcs15_decipher(p15card, obj, flags, in, inlen, out, outlen);\n\t\t\t\tLOG_FUNC_RETURN(ctx, r);\n\t\t\t}\n\t\t\tif (modlen > tmplen)\n\t\t\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_ALLOWED, \"Buffer too small, needs recompile!\");\n\n\t\t\t/* XXX Assuming RSA key here */\n\t\t\tr = sc_pkcs1_encode(ctx, flags, in, inlen, buf, &tmplen, prkey->modulus_length);\n\n\t\t\t/* no padding needed - already done */\n\t\t\tflags &= ~SC_ALGORITHM_RSA_PADS;\n\t\t\t/* instead use raw rsa */\n\t\t\tflags |= SC_ALGORITHM_RSA_RAW;\n\n\t\t\tLOG_TEST_RET(ctx, r, \"Unable to add padding\");\n\n\t\t\tr = sc_pkcs15_decipher(p15card, obj, flags, buf, modlen, out, outlen);\n\t\t\tLOG_FUNC_RETURN(ctx, r);\n\t\t}\n\n\n\t\t/* If the card doesn't support the requested algorithm, we normally add the\n\t\t * padding here in software and ask the card to do a raw signature.  There's\n\t\t * one exception to that, where we might be able to get the signature to\n\t\t * succeed by stripping padding if the card only offers higher-level\n\t\t * signature operations.  The only thing we can strip is the DigestInfo\n\t\t * block from PKCS1 padding. */\n\t\tif ((flags == (SC_ALGORITHM_RSA_PAD_PKCS1 | SC_ALGORITHM_RSA_HASH_NONE)) &&\n\t\t    !(alg_info->flags & SC_ALGORITHM_RSA_RAW) &&\n\t\t    !(alg_info->flags & SC_ALGORITHM_RSA_HASH_NONE) &&\n\t\t    (alg_info->flags & SC_ALGORITHM_RSA_PAD_PKCS1)) {\n\t\t\tunsigned int algo;\n\t\t\tsize_t tmplen = sizeof(buf);\n\n\t\t\tr = sc_pkcs1_strip_digest_info_prefix(&algo, tmp, inlen, tmp, &tmplen);\n\t\t\tif (r != SC_SUCCESS || algo == SC_ALGORITHM_RSA_HASH_NONE) {\n\t\t\t\tsc_mem_clear(buf, sizeof(buf));\n\t\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_DATA);\n\t\t\t}\n\t\t\tflags &= ~SC_ALGORITHM_RSA_HASH_NONE;\n\t\t\tflags |= algo;\n\t\t\tinlen = tmplen;\n\t\t}\n\t}\n\n\n\t/* ECDSA sofware hash has already been done, or is not needed, or card will do hash */\n\t/* if card can not do the hash, will use SC_ALGORITHM_ECDSA_RAW */\n\tif (obj->type == SC_PKCS15_TYPE_PRKEY_EC) {\n\t\tif ((alg_info->flags & SC_ALGORITHM_ECDSA_RAW)\n\t\t\t\t&& !(flags & SC_ALGORITHM_ECDSA_HASHES & alg_info->flags)) {\n\t\t\tsc_log(ctx, \"ECDSA using SC_ALGORITHM_ECDSA_RAW flags before 0x%8.8lx\", flags);\n\t\t\t\tflags |= SC_ALGORITHM_ECDSA_RAW;\n\t\t\t\tflags &= ~SC_ALGORITHM_ECDSA_HASHES;\n\t\t}\n\t}\n\n\tr = sc_get_encoding_flags(ctx, flags, alg_info->flags, &pad_flags, &sec_flags);\n\tif (r != SC_SUCCESS) {\n\t\tsc_mem_clear(buf, sizeof(buf));\n\t\tLOG_FUNC_RETURN(ctx, r);\n\t}\n\t/* senv now has flags card or driver will do */\n\tsenv.algorithm_flags = sec_flags;\n\n\tsc_log(ctx, \"DEE flags:0x%8.8lx alg_info->flags:0x%8.8x pad:0x%8.8lx sec:0x%8.8lx\",\n\t\tflags, alg_info->flags, pad_flags, sec_flags);\n\n\t/* add the padding bytes (if necessary) */\n\tif (pad_flags != 0) {\n\t\tsize_t tmplen = sizeof(buf);\n\n\t\t/* XXX Assuming RSA key here */\n\t\tr = sc_pkcs1_encode(ctx, pad_flags, tmp, inlen, tmp, &tmplen,\n\t\t    prkey->modulus_length);\n\t\tLOG_TEST_RET(ctx, r, \"Unable to add padding\");\n\t\tinlen = tmplen;\n\t}\n\telse if ( senv.algorithm == SC_ALGORITHM_RSA &&\n\t          (flags & SC_ALGORITHM_RSA_PADS) == SC_ALGORITHM_RSA_PAD_NONE) {\n\t\t/* Add zero-padding if input is shorter than the modulus */\n\t\tif (inlen < modlen) {\n\t\t\tif (modlen > sizeof(buf))\n\t\t\t\treturn SC_ERROR_BUFFER_TOO_SMALL;\n\t\t\tmemmove(tmp+modlen-inlen, tmp, inlen);\n\t\t\tmemset(tmp, 0, modlen-inlen);\n\t\t}\n\t\tinlen = modlen;\n\t}\n\t/* PKCS#11 MECHANISMS V2.30: 6.3.1 EC Signatures\n\t * If the length of the hash value is larger than the bit length of n, only\n\t * the leftmost bits of the hash up to the length of n will be used. Any\n\t * truncation is done by the token.\n\t * But if card is going to do the hash, pass in all the data\n\t */\n\telse if (senv.algorithm == SC_ALGORITHM_EC &&\n\t\t\t(senv.algorithm_flags & SC_ALGORITHM_ECDSA_HASHES) == 0) {\n\t\tinlen = MIN(inlen, (prkey->field_length+7)/8);\n\t}\n\n\n\tr = use_key(p15card, obj, &senv, sc_compute_signature, tmp, inlen,\n\t\t\tout, outlen);\n\tLOG_TEST_RET(ctx, r, \"use_key() failed\");\n\n\t/* Some cards may return RSA signature as integer without leading zero bytes */\n\t/* Already know outlen >= modlen and r >= 0 */\n\tif (obj->type == SC_PKCS15_TYPE_PRKEY_RSA && (unsigned)r < modlen) {\n\t\tmemmove(out + modlen - r, out, r);\n\t\tmemset(out, 0, modlen - r);\n\t\tr = modlen;\n\t}\n\n\tsc_mem_clear(buf, sizeof(buf));\n\n\tLOG_FUNC_RETURN(ctx, r);\n}\n\n\n// target function\nstatic int piv_generate_key(sc_card_t *card,\n\t\tsc_cardctl_piv_genkey_info_t *keydata)\n{\n\tint r;\n\tu8 rbuf[4096];\n\tu8 *p;\n\tconst u8 *tag;\n\tu8 tagbuf[16];\n\tu8 outdata[3]; /* we could also add tag 81 for exponent */\n\tsize_t taglen, i;\n\tsize_t out_len;\n\tsize_t in_len;\n\tunsigned int cla_out, tag_out;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\tkeydata->exponent = 0;\n\tkeydata->pubkey = NULL;\n\tkeydata->pubkey_len = 0;\n\tkeydata->ecparam = NULL; /* will show size as we only support 2 curves */\n\tkeydata->ecparam_len = 0;\n\tkeydata->ecpoint = NULL;\n\tkeydata->ecpoint_len = 0;\n\n\tout_len = 3;\n\toutdata[0] = 0x80;\n\toutdata[1] = 0x01;\n\toutdata[2] = keydata->key_algid;\n\tswitch (keydata->key_algid) {\n\t\tcase 0x05: keydata->key_bits = 3072; break;\n\t\tcase 0x06: keydata->key_bits = 1024; break;\n\t\tcase 0x07: keydata->key_bits = 2048; break;\n\t\t/* TODO: - DEE For EC, also set the curve parameter as the OID */\n\t\tcase 0x11: keydata->key_bits = 0;\n\t\t\tkeydata->ecparam =0; /* we only support prime256v1 for 11 */\n\t\t\tkeydata->ecparam_len =0;\n\t\t\tbreak;\n\t\tcase 0x14: keydata->key_bits = 0;\n\t\t\tkeydata->ecparam = 0; /* we only support secp384r1 */\n\t\t\tkeydata->ecparam_len = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_ARGUMENTS);\n\t}\n\n\tp = tagbuf;\n\n\tr = sc_asn1_put_tag(0xAC, outdata, out_len, tagbuf, sizeof(tagbuf), &p);\n\tif (r != SC_SUCCESS) {\n\t\tsc_log(card->ctx, \"Failed to encode ASN1 tag\");\n\t\tgoto err;\n\t}\n\n\tr = piv_general_io(card, 0x47, 0x00, keydata->key_num,\n\t\t\ttagbuf, p - tagbuf, rbuf, sizeof rbuf);\n\n\tif (r >= 0) {\n\t\tconst u8 *cp;\n\t\tkeydata->exponent = 0;\n\n\t\t/* expected tag is 7f49.  */\n\t\t/* we will whatever tag is present */\n\n\t\tcp = rbuf;\n\t\tin_len = r;\n\n\t\tr = sc_asn1_read_tag(&cp, in_len, &cla_out, &tag_out, &in_len);\n\t\tif (cp == NULL) {\n\t\t\tr = SC_ERROR_ASN1_OBJECT_NOT_FOUND;\n\t\t}\n\t\tif (r != SC_SUCCESS) {\n\t\t\tsc_log(card->ctx, \"Tag buffer not found\");\n\t\t\tgoto err;\n\t\t}\n\n\t\t/* if RSA vs EC */\n\t\tif (keydata->key_bits > 0 ) {\n\t\t\ttag = sc_asn1_find_tag(card->ctx, cp, in_len, 0x82, &taglen);\n\t\t\tif (tag != NULL && taglen <= 4) {\n\t\t\t\tkeydata->exponent = 0;\n\t\t\t\tfor (i = 0; i < taglen;i++)\n\t\t\t\t\tkeydata->exponent = (keydata->exponent<<8) + tag[i];\n\t\t\t}\n\n\t\t\ttag = sc_asn1_find_tag(card->ctx, cp, in_len, 0x81, &taglen);\n\t\t\tif (tag != NULL && taglen > 0) {\n\t\t\t\tkeydata->pubkey = malloc(taglen);\n\t\t\t\tif (keydata->pubkey == NULL)\n\t\t\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t\t\t\tkeydata->pubkey_len = taglen;\n\t\t\t\tmemcpy (keydata->pubkey, tag, taglen);\n\t\t\t}\n\t\t}\n\t\telse { /* must be EC */\n\t\t\ttag = sc_asn1_find_tag(card->ctx, cp, in_len, 0x86, &taglen);\n\t\t\tif (tag != NULL && taglen > 0) {\n\t\t\t\tkeydata->ecpoint = malloc(taglen);\n\t\t\t\tif (keydata->ecpoint == NULL)\n\t\t\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t\t\t\tkeydata->ecpoint_len = taglen;\n\t\t\t\tmemcpy (keydata->ecpoint, tag, taglen);\n\t\t\t}\n\t\t}\n\n\t\t/* TODO: -DEE Could add key to cache so could use engine to generate key,\n\t\t * and sign req in single operation */\n\t\tr = 0;\n\t}\n\nerr:\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\nstatic int piv_general_mutual_authenticate(sc_card_t *card,\n\tunsigned int key_ref, unsigned int alg_id)\n{\n\tint r;\n#ifdef ENABLE_OPENSSL\n\tint N;\n\tint locked = 0;\n\tu8 rbuf[4096];\n\tu8 *nonce = NULL;\n\tsize_t nonce_len;\n\tu8 *p;\n\tu8 *key = NULL;\n\tsize_t keylen;\n\tu8 *plain_text = NULL;\n\tsize_t plain_text_len = 0;\n\tu8 *tmp;\n\tsize_t tmplen, tmplen2;\n\tu8 *built = NULL;\n\tsize_t built_len;\n\tconst u8 *body = NULL;\n\tsize_t body_len;\n\tconst u8 *witness_data = NULL;\n\tsize_t witness_len;\n\tconst u8 *challenge_response = NULL;\n\tsize_t challenge_response_len;\n\tu8 *decrypted_reponse = NULL;\n\tsize_t decrypted_reponse_len;\n\tEVP_CIPHER_CTX * ctx = NULL;\n\n\tu8 sbuf[255];\n\tconst EVP_CIPHER *cipher;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\tctx = EVP_CIPHER_CTX_new();\n\tif (ctx == NULL) {\n\t\tr = SC_ERROR_OUT_OF_MEMORY;\n\t\tgoto err;\n\t}\n\n\tcipher = get_cipher_for_algo(alg_id);\n\tif(!cipher) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"Invalid cipher selector, none found for:  %02x\\n\", alg_id);\n\t\tr = SC_ERROR_INVALID_ARGUMENTS;\n\t\tgoto err;\n\t}\n\n\tr = piv_get_key(card, alg_id, &key, &keylen);\n\tif (r) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"Error getting General Auth key\\n\");\n\t\tgoto err;\n\t}\n\n\tr = sc_lock(card);\n\tif (r != SC_SUCCESS) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"sc_lock failed\\n\");\n\t\tgoto err; /* cleanup */\n\t}\n\tlocked = 1;\n\n\tp = sbuf;\n\t*p++ = 0x7C;\n\t*p++ = 0x02;\n\t*p++ = 0x80;\n\t*p++ = 0x00;\n\n\t/* get the encrypted nonce */\n\tr = piv_general_io(card, 0x87, alg_id, key_ref, sbuf, p - sbuf, rbuf, sizeof rbuf);\n\n\tif (r < 0) goto err;\n\n\t/* Remove the encompassing outer TLV of 0x7C and get the data */\n\tbody = sc_asn1_find_tag(card->ctx, rbuf,\n\t\tr, 0x7C, &body_len);\n\tif (!body) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"Invalid Witness Data response of NULL\\n\");\n\t\tr =  SC_ERROR_INVALID_DATA;\n\t\tgoto err;\n\t}\n\n\t/* Get the witness data indicated by the TAG 0x80 */\n\twitness_data = sc_asn1_find_tag(card->ctx, body,\n\t\tbody_len, 0x80, &witness_len);\n\tif (!witness_len) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"Invalid Challenge Data none found in TLV\\n\");\n\t\tr =  SC_ERROR_INVALID_DATA;\n\t\tgoto err;\n\t}\n\n\t/* Allocate an output buffer for openssl */\n\tplain_text = malloc(witness_len);\n\tif (!plain_text) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"Could not allocate buffer for plain text\\n\");\n\t\tr = SC_ERROR_INTERNAL;\n\t\tgoto err;\n\t}\n\n\t/* decrypt the data from the card */\n\tif (!EVP_DecryptInit(ctx, cipher, key, NULL)) {\n\t\t/* may fail if des parity of key is wrong. depends on OpenSSL options */\n\t\tr = SC_ERROR_INTERNAL;\n\t\tgoto err;\n\t}\n\tEVP_CIPHER_CTX_set_padding(ctx,0);\n\n\tp = plain_text;\n\tif (!EVP_DecryptUpdate(ctx, p, &N, witness_data, witness_len)) {\n\t\tr = SC_ERROR_INTERNAL;\n\t\tgoto err;\n\t}\n\tplain_text_len = tmplen = N;\n\tp += tmplen;\n\n\tif(!EVP_DecryptFinal(ctx, p, &N)) {\n\t\tr = SC_ERROR_INTERNAL;\n\t\tgoto err;\n\t}\n\ttmplen = N;\n\tplain_text_len += tmplen;\n\n\tif (plain_text_len != witness_len) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t \"Encrypted and decrypted lengths do not match: %\"SC_FORMAT_LEN_SIZE_T\"u:%\"SC_FORMAT_LEN_SIZE_T\"u\\n\",\n\t\t\t witness_len, plain_text_len);\n\t\tr = SC_ERROR_INTERNAL;\n\t\tgoto err;\n\t}\n\n\t/* Build a response to the card of:\n\t * [GEN AUTH][ 80<decrypted witness>81 <challenge> ]\n\t * Start by computing the nonce for <challenge> the\n\t * nonce length should match the witness length of\n\t * the card.\n\t */\n\tnonce = malloc(witness_len);\n\tif(!nonce) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t \"OOM allocating nonce (%\"SC_FORMAT_LEN_SIZE_T\"u : %\"SC_FORMAT_LEN_SIZE_T\"u)\\n\",\n\t\t\t witness_len, plain_text_len);\n\t\tr = SC_ERROR_INTERNAL;\n\t\tgoto err;\n\t}\n\tnonce_len = witness_len;\n\n\tr = RAND_bytes(nonce, witness_len);\n\tif(!r) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t \"Generating random for nonce (%\"SC_FORMAT_LEN_SIZE_T\"u : %\"SC_FORMAT_LEN_SIZE_T\"u)\\n\",\n\t\t\t witness_len, plain_text_len);\n\t\tr = SC_ERROR_INTERNAL;\n\t\tgoto err;\n\t}\n\n\t/* nonce for challenge */\n\tr = sc_asn1_put_tag(0x81, NULL, witness_len, NULL, 0, NULL);\n\tif (r <= 0) {\n\t\tr = SC_ERROR_INTERNAL;\n\t\tgoto err;\n\t}\n\ttmplen = r;\n\n\t/* plain text witness keep a length separate for the 0x7C tag */\n\tr = sc_asn1_put_tag(0x80, NULL, witness_len, NULL, 0, NULL);\n\tif (r <= 0) {\n\t\tr = SC_ERROR_INTERNAL;\n\t\tgoto err;\n\t}\n\ttmplen += r;\n\ttmplen2 = tmplen;\n\n\t/* outside 7C tag with 81:80 as innards */\n\tr = sc_asn1_put_tag(0x7C, NULL, tmplen, NULL, 0, NULL);\n\tif (r <= 0) {\n\t\tr = SC_ERROR_INTERNAL;\n\t\tgoto err;\n\t}\n\n\tbuilt_len = r;\n\n\t/* Build the response buffer */\n\tp = built = malloc(built_len);\n\tif(!built) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"OOM Building witness response and challenge\\n\");\n\t\tr = SC_ERROR_INTERNAL;\n\t\tgoto err;\n\t}\n\n\tp = built;\n\n\t/* Start with the 7C Tag */\n\tr = sc_asn1_put_tag(0x7C, NULL, tmplen2, p, built_len, &p);\n\tif (r != SC_SUCCESS) {\n\t\tgoto err;\n\t}\n\n\t/* Add the DECRYPTED witness, tag 0x80 */\n\tr = sc_asn1_put_tag(0x80, plain_text, witness_len, p, built_len - (p - built), &p);\n\tif (r != SC_SUCCESS) {\n\t\tgoto err;\n\t}\n\n\t/* Add the challenge, tag 0x81 */\n\tr = sc_asn1_put_tag(0x81, nonce, witness_len, p, built_len - (p - built), &p);\n\tif (r != SC_SUCCESS) {\n\t\tgoto err;\n\t}\n\n\t/* Send constructed data */\n\tr = piv_general_io(card, 0x87, alg_id, key_ref, built, built_len, rbuf, sizeof rbuf);\n\tif (r < 0) {\n\t\tgoto err;\n\t}\n\n\t/* Remove the encompassing outer TLV of 0x7C and get the data */\n\tbody = sc_asn1_find_tag(card->ctx, rbuf,\n\t\tr, 0x7C, &body_len);\n\tif(!body) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"Could not find outer tag 0x7C in response\");\n\t\tr =  SC_ERROR_INVALID_DATA;\n\t\tgoto err;\n\t}\n\n\t/* SP800-73 not clear if  80 or 82 */\n\tchallenge_response = sc_asn1_find_tag(card->ctx, body,\n\t\tbody_len, 0x82, &challenge_response_len);\n\tif(!challenge_response) {\n\t\tchallenge_response = sc_asn1_find_tag(card->ctx, body,\n\t\t\t\tbody_len, 0x80, &challenge_response_len);\n\t\tif(!challenge_response) {\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"Could not find tag 0x82 or 0x80 in response\");\n\t\t\tr =  SC_ERROR_INVALID_DATA;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\t/* Decrypt challenge and check against nonce */\n\tdecrypted_reponse = malloc(challenge_response_len);\n\tif(!decrypted_reponse) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"OOM Allocating decryption buffer\");\n\t\tr =  SC_ERROR_INVALID_DATA;\n\t\tgoto err;\n\t}\n\n\tEVP_CIPHER_CTX_cleanup(ctx);\n\n\tif (!EVP_DecryptInit(ctx, cipher, key, NULL)) {\n\t\tr = SC_ERROR_INTERNAL;\n\t\tgoto err;\n\t}\n\tEVP_CIPHER_CTX_set_padding(ctx,0);\n\n\ttmp = decrypted_reponse;\n\tif (!EVP_DecryptUpdate(ctx, tmp, &N, challenge_response, challenge_response_len)) {\n\t\tr = SC_ERROR_INTERNAL;\n\t\tgoto err;\n\t}\n\tdecrypted_reponse_len = tmplen = N;\n\ttmp += tmplen;\n\n\tif(!EVP_DecryptFinal(ctx, tmp, &N)) {\n\t\tr = SC_ERROR_INTERNAL;\n\t\tgoto err;\n\t}\n\ttmplen = N;\n\tdecrypted_reponse_len += tmplen;\n\n\tif (decrypted_reponse_len != nonce_len || memcmp(nonce, decrypted_reponse, nonce_len) != 0) {\n\t\tsc_log(card->ctx,\n\t\t       \"mutual authentication failed, card returned wrong value %\"SC_FORMAT_LEN_SIZE_T\"u:%\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t       decrypted_reponse_len, nonce_len);\n\t\tr = SC_ERROR_DECRYPT_FAILED;\n\t\tgoto err;\n\t}\n\tr = SC_SUCCESS;\n\nerr:\n\tif (ctx)\n\t\tEVP_CIPHER_CTX_free(ctx);\n\tif (locked)\n\t\tsc_unlock(card);\n\tif (decrypted_reponse)\n\t\tfree(decrypted_reponse);\n\tif (built)\n\t\tfree(built);\n\tif (plain_text)\n\t\tfree(plain_text);\n\tif (nonce)\n\t\tfree(nonce);\n\tif (key)\n\t\tfree(key);\n\n#else\n\tsc_log(card->ctx, \"OpenSSL Required\");\n\tr = SC_ERROR_NOT_SUPPORTED;\n#endif /* ENABLE_OPENSSL */\n\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\nstatic int piv_general_external_authenticate(sc_card_t *card,\n\t\tunsigned int key_ref, unsigned int alg_id)\n{\n\tint r;\n#ifdef ENABLE_OPENSSL\n\tint tmplen;\n\tint outlen;\n\tint locked = 0;\n\tu8 *p;\n\tu8 rbuf[4096];\n\tu8 *key = NULL;\n\tu8 *cypher_text = NULL;\n\tu8 *output_buf = NULL;\n\tconst u8 *body = NULL;\n\tconst u8 *challenge_data = NULL;\n\tsize_t body_len;\n\tsize_t output_len;\n\tsize_t challenge_len;\n\tsize_t keylen = 0;\n\tsize_t cypher_text_len = 0;\n\tu8 sbuf[255];\n\tEVP_CIPHER_CTX * ctx = NULL;\n\tconst EVP_CIPHER *cipher;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\tctx = EVP_CIPHER_CTX_new();\n\tif (ctx == NULL) {\n\t    r = SC_ERROR_OUT_OF_MEMORY;\n\t    goto err;\n\t}\n\n\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"Selected cipher for algorithm id: %02x\\n\", alg_id);\n\n\tcipher = get_cipher_for_algo(alg_id);\n\tif(!cipher) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"Invalid cipher selector, none found for:  %02x\\n\", alg_id);\n\t\tr = SC_ERROR_INVALID_ARGUMENTS;\n\t\tgoto err;\n\t}\n\n\tr = piv_get_key(card, alg_id, &key, &keylen);\n\tif (r) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"Error getting General Auth key\\n\");\n\t\tgoto err;\n\t}\n\n\tr = sc_lock(card);\n\tif (r != SC_SUCCESS) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"sc_lock failed\\n\");\n\t\tgoto err; /* cleanup */\n\t}\n\tlocked = 1;\n\n\tp = sbuf;\n\t*p++ = 0x7C;\n\t*p++ = 0x02;\n\t*p++ = 0x81;\n\t*p++ = 0x00;\n\n\t/* get a challenge */\n\tr = piv_general_io(card, 0x87, alg_id, key_ref, sbuf, p - sbuf, rbuf, sizeof rbuf);\n\tif (r < 0) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"Error getting Challenge\\n\");\n\t\tgoto err;\n\t}\n\n\t/*\n\t * the value here corresponds with the response size, so we use this\n\t * to alloc the response buffer, rather than re-computing it.\n\t */\n\toutput_len = r;\n\n\t/* Remove the encompassing outer TLV of 0x7C and get the data */\n\tbody = sc_asn1_find_tag(card->ctx, rbuf,\n\t\tr, 0x7C, &body_len);\n\tif (!body) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"Invalid Challenge Data response of NULL\\n\");\n\t\tr =  SC_ERROR_INVALID_DATA;\n\t\tgoto err;\n\t}\n\n\t/* Get the challenge data indicated by the TAG 0x81 */\n\tchallenge_data = sc_asn1_find_tag(card->ctx, body,\n\t\tbody_len, 0x81, &challenge_len);\n\tif (!challenge_data) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"Invalid Challenge Data none found in TLV\\n\");\n\t\tr =  SC_ERROR_INVALID_DATA;\n\t\tgoto err;\n\t}\n\n\t/* Store this to sanity check that plaintext length and cyphertext lengths match */\n\t/* TODO is this required */\n\ttmplen = challenge_len;\n\n\t/* Encrypt the challenge with the secret */\n\tif (!EVP_EncryptInit(ctx, cipher, key, NULL)) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"Encrypt fail\\n\");\n\t\tr = SC_ERROR_INTERNAL;\n\t\tgoto err;\n\t}\n\n\tcypher_text = malloc(challenge_len);\n\tif (!cypher_text) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"Could not allocate buffer for cipher text\\n\");\n\t\tr = SC_ERROR_INTERNAL;\n\t\tgoto err;\n\t}\n\n\tEVP_CIPHER_CTX_set_padding(ctx,0);\n\tif (!EVP_EncryptUpdate(ctx, cypher_text, &outlen, challenge_data, challenge_len)) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"Encrypt update fail\\n\");\n\t\tr = SC_ERROR_INTERNAL;\n\t\tgoto err;\n\t}\n\tcypher_text_len += outlen;\n\n\tif (!EVP_EncryptFinal(ctx, cypher_text + cypher_text_len, &outlen)) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"Final fail\\n\");\n\t\tr = SC_ERROR_INTERNAL;\n\t\tgoto err;\n\t}\n\tcypher_text_len += outlen;\n\n\t/*\n\t * Actually perform the sanity check on lengths plaintext length vs\n\t * encrypted length\n\t */\n\tif (cypher_text_len != (size_t)tmplen) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"Length test fail\\n\");\n\t\tr = SC_ERROR_INTERNAL;\n\t\tgoto err;\n\t}\n\n\toutput_buf = malloc(output_len);\n\tif(!output_buf) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"Could not allocate output buffer: %s\\n\",\n\t\t\t\tstrerror(errno));\n\t\tr = SC_ERROR_INTERNAL;\n\t\tgoto err;\n\t}\n\n\tp = output_buf;\n\n\t/*\n\t * Build: 7C<len>[82<len><challenge>]\n\t * Start off by capturing the data of the response:\n\t *     - 82<len><encrypted challenege response>\n\t * Build the outside TLV (7C)\n\t * Advance past that tag + len\n\t * Build the body (82)\n\t * memcopy the body past the 7C<len> portion\n\t * Transmit\n\t */\n\ttmplen = sc_asn1_put_tag(0x82, NULL, cypher_text_len, NULL, 0, NULL);\n\tif (tmplen <= 0) {\n\t\tr = SC_ERROR_INTERNAL;\n\t\tgoto err;\n\t}\n\n\tr = sc_asn1_put_tag(0x7C, NULL, tmplen, p, output_len, &p);\n\tif (r != SC_SUCCESS) {\n\t\tgoto err;\n\t}\n\n\t/* Build the 0x82 TLV and append to the 7C<len> tag */\n\tr = sc_asn1_put_tag(0x82, cypher_text, cypher_text_len, p, output_len - (p - output_buf), &p);\n\tif (r != SC_SUCCESS) {\n\t\tgoto err;\n\t}\n\n\t/* Sanity check the lengths again */\n\ttmplen = sc_asn1_put_tag(0x7C, NULL, tmplen, NULL, 0, NULL)\n\t\t+ sc_asn1_put_tag(0x82, NULL, cypher_text_len, NULL, 0, NULL);\n\tif (output_len != (size_t)tmplen) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"Allocated and computed lengths do not match! \"\n\t\t\t \"Expected %\"SC_FORMAT_LEN_SIZE_T\"d, found: %d\\n\", output_len, tmplen);\n\t\tr = SC_ERROR_INTERNAL;\n\t\tgoto err;\n\t}\n\n\tr = piv_general_io(card, 0x87, alg_id, key_ref, output_buf, output_len, NULL, 0);\n\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"Got response  challenge\\n\");\n\nerr:\n\tif (ctx)\n\t\tEVP_CIPHER_CTX_free(ctx);\n\n\tif (locked)\n\t\tsc_unlock(card);\n\n\tif (key) {\n\t\tsc_mem_clear(key, keylen);\n\t\tfree(key);\n\t}\n\n\tif (cypher_text)\n\t\tfree(cypher_text);\n\n\tif (output_buf)\n\t\tfree(output_buf);\n#else\n\tsc_log(card->ctx, \"OpenSSL Required\");\n\tr = SC_ERROR_NOT_SUPPORTED;\n#endif /* ENABLE_OPENSSL */\n\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\nstatic int\npiv_get_serial_nr_from_CHUI(sc_card_t* card, sc_serial_number_t* serial)\n{\n\tint r;\n\tint i;\n\tu8 gbits;\n\tu8 *rbuf = NULL;\n\tconst u8 *body;\n\tconst u8 *fascn;\n\tconst u8 *guid;\n\tsize_t rbuflen = 0, bodylen, fascnlen, guidlen;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\tif (card->serialnr.len)   {\n\t\t*serial = card->serialnr;\n\t\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n\t}\n\n\t/*\n\t * 800-73-3 Part 1 and CIO Council docs say for PIV Compatible cards\n\t * the FASC-N Agency code should be 9999 and there should be a GUID\n\t * based on RFC 4122. If GUID present and not zero\n\t * we will use the GUID as the serial number.\n\t */\n\n\tr = piv_get_cached_data(card, PIV_OBJ_CHUI, &rbuf, &rbuflen);\n\tLOG_TEST_RET(card->ctx, r, \"Failure retrieving CHUI\");\n\n\tr = SC_ERROR_INTERNAL;\n\tif (rbuflen != 0) {\n\t\tbody = sc_asn1_find_tag(card->ctx, rbuf, rbuflen, 0x53, &bodylen); /* Pass the outer wrapper asn1 */\n\t\tif (body != NULL && bodylen != 0) {\n\t\t\tfascn = sc_asn1_find_tag(card->ctx, body, bodylen, 0x30, &fascnlen); /* Find the FASC-N data */\n\t\t\tguid = sc_asn1_find_tag(card->ctx, body, bodylen, 0x34, &guidlen);\n\n\t\t\tgbits = 0; /* if guid is valid, gbits will not be zero */\n\t\t\tif (guid && guidlen == 16) {\n\t\t\t\tfor (i = 0; i < 16; i++) {\n\t\t\t\t\tgbits = gbits | guid[i]; /* if all are zero, gbits will be zero */\n\t\t\t\t}\n\t\t\t}\n\t\t\tsc_log(card->ctx,\n\t\t\t       \"fascn=%p,fascnlen=%\"SC_FORMAT_LEN_SIZE_T\"u,guid=%p,guidlen=%\"SC_FORMAT_LEN_SIZE_T\"u,gbits=%2.2x\",\n\t\t\t       fascn, fascnlen, guid, guidlen, gbits);\n\n\t\t\tif (fascn && fascnlen == 25) {\n\t\t\t\t/* test if guid and the fascn starts with ;9999 (in ISO 4bit + parity code) */\n\t\t\t\tif (!(gbits && fascn[0] == 0xD4 && fascn[1] == 0xE7\n\t\t\t\t\t\t    && fascn[2] == 0x39 && (fascn[3] | 0x7F) == 0xFF)) {\n\t\t\t\t\t/* fascnlen is 25 */\n\t\t\t\t\tserial->len = fascnlen;\n\t\t\t\t\tmemcpy (serial->value, fascn, serial->len);\n\t\t\t\t\tr = SC_SUCCESS;\n\t\t\t\t\tgbits = 0; /* set to skip using guid below */\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (guid && gbits) {\n\t\t\t\t/* guidlen is 16 */\n\t\t\t\tserial->len = guidlen;\n\t\t\t\tmemcpy (serial->value, guid, serial->len);\n\t\t\t\tr = SC_SUCCESS;\n\t\t\t}\n\t\t}\n\t}\n\n\tcard->serialnr = *serial;\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\nstatic int piv_validate_general_authentication(sc_card_t *card,\n\t\t\t\t\tconst u8 * data, size_t datalen,\n\t\t\t\t\tu8 * out, size_t outlen)\n{\n\tpiv_private_data_t * priv = PIV_DATA(card);\n\tint r, tmplen, tmplen2;\n\tu8 *p;\n\tconst u8 *tag;\n\tsize_t taglen;\n\tconst u8 *body;\n\tsize_t bodylen;\n\tunsigned int real_alg_id, op_tag;\n\n\tu8 sbuf[4096]; /* needs work. for 3072 keys, needs 384+10 or so */\n\tsize_t sbuflen = sizeof(sbuf);\n\tu8 rbuf[4096];\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\t/* should assume large send data */\n\tp = sbuf;\n\ttmplen = sc_asn1_put_tag(0xff, NULL, datalen, NULL, 0, NULL);\n\ttmplen2 = sc_asn1_put_tag(0x82, NULL, 0, NULL, 0, NULL);\n\tif (tmplen <= 0 || tmplen2 <= 0) {\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INTERNAL);\n\t}\n\ttmplen += tmplen2;\n\tif ((r = sc_asn1_put_tag(0x7c, NULL, tmplen, p, sbuflen, &p)) != SC_SUCCESS ||\n\t    (r = sc_asn1_put_tag(0x82, NULL, 0, p, sbuflen - (p - sbuf), &p)) != SC_SUCCESS) {\n\t\tLOG_FUNC_RETURN(card->ctx, r);\n\t}\n\tif (priv->operation == SC_SEC_OPERATION_DERIVE\n\t\t\t&& priv->algorithm == SC_ALGORITHM_EC) {\n\t\top_tag = 0x85;\n\t} else {\n\t\top_tag = 0x81;\n\t}\n\tr = sc_asn1_put_tag(op_tag, data, datalen, p, sbuflen - (p - sbuf), &p);\n\tif (r != SC_SUCCESS) {\n\t\tLOG_FUNC_RETURN(card->ctx, r);\n\t}\n\n\t/*\n\t * alg_id=06 is a place holder for all RSA keys.\n\t * Derive the real alg_id based on the size of the\n\t * the data, as we are always using raw mode.\n\t * Non RSA keys needs some work in this area.\n\t */\n\n\treal_alg_id = priv->alg_id;\n\tif (priv->alg_id == 0x06) {\n\t\tswitch  (datalen) {\n\t\t\tcase 128: real_alg_id = 0x06; break;\n\t\t\tcase 256: real_alg_id = 0x07; break;\n\t\t\tcase 384: real_alg_id = 0x05; break;\n\t\t\tdefault:\n\t\t\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_NO_CARD_SUPPORT);\n\t\t}\n\t}\n\t/* EC alg_id was already set */\n\n\tr = piv_general_io(card, 0x87, real_alg_id, priv->key_ref,\n\t\t\tsbuf, p - sbuf, rbuf, sizeof rbuf);\n\n\tif (r >= 0) {\n\t\tbody = sc_asn1_find_tag(card->ctx, rbuf, r, 0x7c, &bodylen);\n\t\tif (body) {\n\t\t\ttag = sc_asn1_find_tag(card->ctx, body,  bodylen, 0x82, &taglen);\n\t\t\tif (tag) {\n\t\t\t\tmemcpy(out, tag, taglen);\n\t\t\t\tr = taglen;\n\t\t\t} else\n\t\t\t\tr = SC_ERROR_INVALID_DATA;\n\t\t} else\n\t\t\tr = SC_ERROR_INVALID_DATA;\n\t}\n\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\nstatic int\npiv_compute_signature(sc_card_t *card, const u8 * data, size_t datalen,\n\t\tu8 * out, size_t outlen)\n{\n\tpiv_private_data_t * priv = PIV_DATA(card);\n\tint r;\n\tint i;\n\tsize_t nLen;\n\tu8 rbuf[128]; /* For EC conversions  384 will fit */\n\tconst u8 * body;\n\tsize_t bodylen;\n\tconst u8 * tag;\n\tsize_t taglen;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\t/* The PIV returns a DER SEQUENCE{INTEGER, INTEGER}\n\t * Which may have leading 00 to force positive\n\t * TODO: -DEE should check if PKCS15 want the same\n\t * But PKCS11 just wants 2* filed_length in bytes\n\t * So we have to strip out the integers\n\t * if present and pad on left if too short.\n\t */\n\n\tif (priv->alg_id == 0x11 || priv->alg_id == 0x14 ) {\n\t\tnLen = (priv->key_size + 7) / 8;\n\t\tif (outlen < 2*nLen) {\n\t\t\tsc_log(card->ctx,\n\t\t\t       \" output too small for EC signature %\"SC_FORMAT_LEN_SIZE_T\"u < %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t\t       outlen, 2 * nLen);\n\t\t\tr = SC_ERROR_INVALID_DATA;\n\t\t\tgoto err;\n\t\t}\n\t\tmemset(out, 0, outlen);\n\n\t\tr = piv_validate_general_authentication(card, data, datalen, rbuf, sizeof rbuf);\n\t\tif (r < 0)\n\t\t\tgoto err;\n\n\t\tbody = sc_asn1_find_tag(card->ctx, rbuf, r, 0x30, &bodylen);\n\n\t\tfor (i = 0; i<2; i++) {\n\t\t\tif (body) {\n\t\t\t\ttag = sc_asn1_find_tag(card->ctx, body,  bodylen, 0x02, &taglen);\n\t\t\t\tif (tag) {\n\t\t\t\t\tbodylen -= taglen - (tag - body);\n\t\t\t\t\tbody = tag + taglen;\n\n\t\t\t\t\tif (taglen > nLen) { /* drop leading 00 if present */\n\t\t\t\t\t\tif (*tag != 0x00) {\n\t\t\t\t\t\t\tr = SC_ERROR_INVALID_DATA;\n\t\t\t\t\t\t\tgoto err;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttag++;\n\t\t\t\t\t\ttaglen--;\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy(out + nLen*i + nLen - taglen , tag, taglen);\n\t\t\t\t} else {\n\t\t\t\t\tr = SC_ERROR_INVALID_DATA;\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t} else  {\n\t\t\t\tr = SC_ERROR_INVALID_DATA;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t\tr = 2 * nLen;\n\t} else { /* RSA is all set */\n\t\tr = piv_validate_general_authentication(card, data, datalen, out, outlen);\n\t}\n\nerr:\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);\n}\n",
    "target": 1,
    "idx": 1036200,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic inline void _sw32(void* dest, int32_t a) {\n  uint8_t* dest_ = (uint8_t*)dest;\n  uint8_t* pa = (uint8_t*)&a;\n\n  bool little_endian = is_little_endian();\n  if (little_endian) {\n    *(int32_t *)dest_ = a;\n  }\n  else {\n#if defined (__GNUC__)\n    *(int32_t *)dest_ = __builtin_bswap32(*(unsigned int *)pa);\n#elif defined (_MSC_VER) /* Visual Studio */\n    *(int32_t *)dest_ = _byteswap_ulong(*(unsigned int *)pa);\n#else\n    dest_[0] = pa[3];\n    dest_[1] = pa[2];\n    dest_[2] = pa[1];\n    dest_[3] = pa[0];\n#endif\n  }\n}\n\nstatic int blosc_c(struct thread_context* thread_context, int32_t bsize,\n                   int32_t leftoverblock, int32_t ntbytes, int32_t destsize,\n                   const uint8_t* src, const int32_t offset, uint8_t* dest,\n                   uint8_t* tmp, uint8_t* tmp2) {\n  blosc2_context* context = thread_context->parent_context;\n  int dont_split = (context->header_flags & 0x10) >> 4;\n  int dict_training = context->use_dict && context->dict_cdict == NULL;\n  int32_t j, neblock, nstreams;\n  int32_t cbytes;                   /* number of compressed bytes in split */\n  int32_t ctbytes = 0;              /* number of compressed bytes in block */\n  int64_t maxout;\n  int32_t typesize = context->typesize;\n  const char* compname;\n  int accel;\n  const uint8_t* _src;\n  uint8_t *_tmp = tmp, *_tmp2 = tmp2;\n  uint8_t *_tmp3 = thread_context->tmp4;\n  int last_filter_index = last_filter(context->filters, 'c');\n  bool memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;\n\n  if (last_filter_index >= 0 || context->prefilter != NULL) {\n    /* Apply the filter pipeline just for the prefilter */\n    if (memcpyed && context->prefilter != NULL) {\n      // We only need the prefilter output\n      _src = pipeline_c(thread_context, bsize, src, offset, dest, _tmp2, _tmp3);\n\n      if (_src == NULL) {\n        return -9;  // signals a problem with the filter pipeline\n      }\n      return bsize;\n    }\n    /* Apply regular filter pipeline */\n    _src = pipeline_c(thread_context, bsize, src, offset, _tmp, _tmp2, _tmp3);\n\n    if (_src == NULL) {\n      return -9;  // signals a problem with the filter pipeline\n    }\n  } else {\n    _src = src + offset;\n  }\n\n  assert(context->clevel > 0);\n\n  /* Calculate acceleration for different compressors */\n  accel = get_accel(context);\n\n  /* The number of compressed data streams for this block */\n  if (!dont_split && !leftoverblock && !dict_training) {\n    nstreams = (int32_t)typesize;\n  }\n  else {\n    nstreams = 1;\n  }\n  neblock = bsize / nstreams;\n  for (j = 0; j < nstreams; j++) {\n    if (!dict_training) {\n      dest += sizeof(int32_t);\n      ntbytes += sizeof(int32_t);\n      ctbytes += sizeof(int32_t);\n    }\n\n    // See if we have a run here\n    const uint8_t* ip = (uint8_t*)_src + j * neblock;\n    const uint8_t* ipbound = (uint8_t*)_src + (j + 1) * neblock;\n    if (get_run(ip, ipbound)) {\n      // A run.  Encode the repeated byte as a negative length in the length of the split.\n      int32_t value = _src[j * neblock];\n      if (ntbytes > destsize) {\n        /* Not enough space to write out compressed block size */\n        return -1;\n      }\n      _sw32(dest - 4, -value);\n      continue;\n    }\n\n    maxout = neblock;\n  #if defined(HAVE_SNAPPY)\n    if (context->compcode == BLOSC_SNAPPY) {\n      maxout = (int32_t)snappy_max_compressed_length((size_t)neblock);\n    }\n  #endif /*  HAVE_SNAPPY */\n    if (ntbytes + maxout > destsize) {\n      /* avoid buffer * overrun */\n      maxout = (int64_t)destsize - (int64_t)ntbytes;\n      if (maxout <= 0) {\n        return 0;                  /* non-compressible block */\n      }\n    }\n    if (dict_training) {\n      // We are in the build dict state, so don't compress\n      // TODO: copy only a percentage for sampling\n      memcpy(dest, _src + j * neblock, (unsigned int)neblock);\n      cbytes = (int32_t)neblock;\n    }\n    else if (context->compcode == BLOSC_BLOSCLZ) {\n      cbytes = blosclz_compress(context->clevel, _src + j * neblock,\n                                (int)neblock, dest, (int)maxout);\n    }\n  #if defined(HAVE_LZ4)\n    else if (context->compcode == BLOSC_LZ4) {\n      void *hash_table = NULL;\n    #ifdef HAVE_IPP\n      hash_table = (void*)thread_context->lz4_hash_table;\n    #endif\n      cbytes = lz4_wrap_compress((char*)_src + j * neblock, (size_t)neblock,\n                                 (char*)dest, (size_t)maxout, accel, hash_table);\n    }\n    else if (context->compcode == BLOSC_LZ4HC) {\n      cbytes = lz4hc_wrap_compress((char*)_src + j * neblock, (size_t)neblock,\n                                   (char*)dest, (size_t)maxout, context->clevel);\n    }\n  #endif /* HAVE_LZ4 */\n  #if defined(HAVE_LIZARD)\n    else if (context->compcode == BLOSC_LIZARD) {\n      cbytes = lizard_wrap_compress((char*)_src + j * neblock, (size_t)neblock,\n                                    (char*)dest, (size_t)maxout, accel);\n    }\n  #endif /* HAVE_LIZARD */\n  #if defined(HAVE_SNAPPY)\n    else if (context->compcode == BLOSC_SNAPPY) {\n      cbytes = snappy_wrap_compress((char*)_src + j * neblock, (size_t)neblock,\n                                    (char*)dest, (size_t)maxout);\n    }\n  #endif /* HAVE_SNAPPY */\n  #if defined(HAVE_ZLIB)\n    else if (context->compcode == BLOSC_ZLIB) {\n      cbytes = zlib_wrap_compress((char*)_src + j * neblock, (size_t)neblock,\n                                  (char*)dest, (size_t)maxout, context->clevel);\n    }\n  #endif /* HAVE_ZLIB */\n  #if defined(HAVE_ZSTD)\n    else if (context->compcode == BLOSC_ZSTD) {\n      cbytes = zstd_wrap_compress(thread_context,\n                                  (char*)_src + j * neblock, (size_t)neblock,\n                                  (char*)dest, (size_t)maxout, context->clevel);\n    }\n  #endif /* HAVE_ZSTD */\n\n    else {\n      blosc_compcode_to_compname(context->compcode, &compname);\n      fprintf(stderr, \"Blosc has not been compiled with '%s' \", compname);\n      fprintf(stderr, \"compression support.  Please use one having it.\");\n      return -5;    /* signals no compression support */\n    }\n\n    if (cbytes > maxout) {\n      /* Buffer overrun caused by compression (should never happen) */\n      return -1;\n    }\n    if (cbytes < 0) {\n      /* cbytes should never be negative */\n      return -2;\n    }\n    if (!dict_training) {\n      if (cbytes == 0 || cbytes == neblock) {\n        /* The compressor has been unable to compress data at all. */\n        /* Before doing the copy, check that we are not running into a\n           buffer overflow. */\n        if ((ntbytes + neblock) > destsize) {\n          return 0;    /* Non-compressible data */\n        }\n        memcpy(dest, _src + j * neblock, (unsigned int)neblock);\n        cbytes = neblock;\n      }\n      _sw32(dest - 4, cbytes);\n    }\n    dest += cbytes;\n    ntbytes += cbytes;\n    ctbytes += cbytes;\n  }  /* Closes j < nstreams */\n\nstatic int serial_blosc(struct thread_context* thread_context) {\n  blosc2_context* context = thread_context->parent_context;\n  int32_t j, bsize, leftoverblock;\n  int32_t cbytes;\n  int32_t ntbytes = (int32_t)context->output_bytes;\n  int32_t* bstarts = context->bstarts;\n  uint8_t* tmp = thread_context->tmp;\n  uint8_t* tmp2 = thread_context->tmp2;\n  int dict_training = context->use_dict && (context->dict_cdict == NULL);\n  bool memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;\n\n  for (j = 0; j < context->nblocks; j++) {\n    if (context->do_compress && !memcpyed && !dict_training) {\n      _sw32(bstarts + j, ntbytes);\n    }\n    bsize = context->blocksize;\n    leftoverblock = 0;\n    if ((j == context->nblocks - 1) && (context->leftover > 0)) {\n      bsize = context->leftover;\n      leftoverblock = 1;\n    }\n    if (context->do_compress) {\n      if (memcpyed && !context->prefilter) {\n        /* We want to memcpy only */\n        memcpy(context->dest + BLOSC_MAX_OVERHEAD + j * context->blocksize,\n                 context->src + j * context->blocksize,\n                 (unsigned int)bsize);\n        cbytes = (int32_t)bsize;\n      }\n      else {\n        /* Regular compression */\n        cbytes = blosc_c(thread_context, bsize, leftoverblock, ntbytes,\n                         context->destsize, context->src, j * context->blocksize,\n                         context->dest + ntbytes, tmp, tmp2);\n        if (cbytes == 0) {\n          ntbytes = 0;              /* uncompressible data */\n          break;\n        }\n      }\n    }\n    else {\n      if (memcpyed) {\n        // Check that sizes in header are compatible, otherwise there is a header corruption\n        int32_t csize = sw32_(context->src + 12);   /* compressed buffer size */\n        if (context->sourcesize + BLOSC_MAX_OVERHEAD != csize) {\n          return -1;\n        }\n        if (context->srcsize < BLOSC_MAX_OVERHEAD + (j * context->blocksize) + bsize) {\n          /* Not enough input to copy block */\n          return -1;\n        }\n        memcpy(context->dest + j * context->blocksize,\n               context->src + BLOSC_MAX_OVERHEAD + j * context->blocksize,\n               (unsigned int)bsize);\n        cbytes = (int32_t)bsize;\n      }\n      else {\n        /* Regular decompression */\n        cbytes = blosc_d(thread_context, bsize, leftoverblock,\n                         context->src, context->srcsize, sw32_(bstarts + j),\n                         context->dest, j * context->blocksize, tmp, tmp2);\n      }\n    }\n\n    if (cbytes < 0) {\n      ntbytes = cbytes;         /* error in blosc_c or blosc_d */\n      break;\n    }\n    ntbytes += cbytes;\n  }\n\n  return ntbytes;\n}\n\nstatic int do_job(blosc2_context* context) {\n  int32_t ntbytes;\n\n  /* Set sentinels */\n  context->dref_not_init = 1;\n\n  /* Check whether we need to restart threads */\n  check_nthreads(context);\n\n  /* Run the serial version when nthreads is 1 or when the buffers are\n     not larger than blocksize */\n  if (context->nthreads == 1 || (context->sourcesize / context->blocksize) <= 1) {\n    /* The context for this 'thread' has no been initialized yet */\n    if (context->serial_context == NULL) {\n      context->serial_context = create_thread_context(context, 0);\n    }\n    else if (context->blocksize != context->serial_context->tmp_blocksize) {\n      free_thread_context(context->serial_context);\n      context->serial_context = create_thread_context(context, 0);\n    }\n    ntbytes = serial_blosc(context->serial_context);\n  }\n  else {\n    ntbytes = parallel_blosc(context);\n  }\n\n  return ntbytes;\n}\n\nint blosc_compress_context(blosc2_context* context) {\n  int ntbytes = 0;\n  blosc_timestamp_t last, current;\n  bool memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;\n\n  blosc_set_timestamp(&last);\n\n  if (!memcpyed) {\n    /* Do the actual compression */\n    ntbytes = do_job(context);\n    if (ntbytes < 0) {\n      return -1;\n    }\n    if (ntbytes == 0) {\n      // Try out with a memcpy later on (last chance for fitting src buffer in dest).\n      context->header_flags |= (uint8_t)BLOSC_MEMCPYED;\n      memcpyed = true;\n    }\n  }\n\n  if (memcpyed) {\n    if (context->sourcesize + BLOSC_MAX_OVERHEAD > context->destsize) {\n      /* We are exceeding maximum output size */\n      ntbytes = 0;\n    }\n    else {\n      context->output_bytes = BLOSC_MAX_OVERHEAD;\n      ntbytes = do_job(context);\n      if (ntbytes < 0) {\n        return -1;\n      }\n      // Success!  update the memcpy bit in header\n      context->dest[2] = context->header_flags;\n      // and clear the memcpy bit in context (for next reuse)\n      context->header_flags &= ~(uint8_t)BLOSC_MEMCPYED;\n    }\n  }\n\n  /* Set the number of compressed bytes in header */\n  _sw32(context->dest + 12, ntbytes);\n\n  /* Set the number of bytes in dest buffer (might be useful for btune) */\n  context->destsize = ntbytes;\n\n  assert(ntbytes <= context->destsize);\n\n  if (context->btune != NULL) {\n    blosc_set_timestamp(&current);\n    double ctime = blosc_elapsed_secs(last, current);\n    btune_update(context, ctime);\n  }\n\n  return ntbytes;\n}\n\nint blosc2_compress(int clevel, int doshuffle, int32_t typesize,\n                    const void* src, int32_t srcsize, void* dest, int32_t destsize) {\n  int error;\n  int result;\n  char* envvar;\n\n  /* Check whether the library should be initialized */\n  if (!g_initlib) blosc_init();\n\n  /* Check for a BLOSC_CLEVEL environment variable */\n  envvar = getenv(\"BLOSC_CLEVEL\");\n  if (envvar != NULL) {\n    long value;\n    value = strtol(envvar, NULL, 10);\n    if ((value != EINVAL) && (value >= 0)) {\n      clevel = (int)value;\n    }\n  }\n\n  /* Check for a BLOSC_SHUFFLE environment variable */\n  envvar = getenv(\"BLOSC_SHUFFLE\");\n  if (envvar != NULL) {\n    if (strcmp(envvar, \"NOSHUFFLE\") == 0) {\n      doshuffle = BLOSC_NOSHUFFLE;\n    }\n    if (strcmp(envvar, \"SHUFFLE\") == 0) {\n      doshuffle = BLOSC_SHUFFLE;\n    }\n    if (strcmp(envvar, \"BITSHUFFLE\") == 0) {\n      doshuffle = BLOSC_BITSHUFFLE;\n    }\n  }\n\n  /* Check for a BLOSC_DELTA environment variable */\n  envvar = getenv(\"BLOSC_DELTA\");\n  if (envvar != NULL) {\n    if (strcmp(envvar, \"1\") == 0) {\n      blosc_set_delta(1);\n    } else {\n      blosc_set_delta(0);\n    }\n  }\n\n  /* Check for a BLOSC_TYPESIZE environment variable */\n  envvar = getenv(\"BLOSC_TYPESIZE\");\n  if (envvar != NULL) {\n    long value;\n    value = strtol(envvar, NULL, 10);\n    if ((value != EINVAL) && (value > 0)) {\n      typesize = (size_t)value;\n    }\n  }\n\n  /* Check for a BLOSC_COMPRESSOR environment variable */\n  envvar = getenv(\"BLOSC_COMPRESSOR\");\n  if (envvar != NULL) {\n    result = blosc_set_compressor(envvar);\n    if (result < 0) { return result; }\n  }\n\n  /* Check for a BLOSC_COMPRESSOR environment variable */\n  envvar = getenv(\"BLOSC_BLOCKSIZE\");\n  if (envvar != NULL) {\n    long blocksize;\n    blocksize = strtol(envvar, NULL, 10);\n    if ((blocksize != EINVAL) && (blocksize > 0)) {\n      blosc_set_blocksize((size_t)blocksize);\n    }\n  }\n\n  /* Check for a BLOSC_NTHREADS environment variable */\n  envvar = getenv(\"BLOSC_NTHREADS\");\n  if (envvar != NULL) {\n    long nthreads;\n    nthreads = strtol(envvar, NULL, 10);\n    if ((nthreads != EINVAL) && (nthreads > 0)) {\n      result = blosc_set_nthreads((int)nthreads);\n      if (result < 0) { return result; }\n    }\n  }\n\n  /* Check for a BLOSC_NOLOCK environment variable.  It is important\n     that this should be the last env var so that it can take the\n     previous ones into account */\n  envvar = getenv(\"BLOSC_NOLOCK\");\n  if (envvar != NULL) {\n    // TODO: here is the only place that returns an extended header from\n    //   a blosc_compress() call.  This should probably be fixed.\n    const char *compname;\n    blosc2_context *cctx;\n    blosc2_cparams cparams = BLOSC2_CPARAMS_DEFAULTS;\n\n    blosc_compcode_to_compname(g_compressor, &compname);\n    /* Create a context for compression */\n    build_filters(doshuffle, g_delta, typesize, cparams.filters);\n    // TODO: cparams can be shared in a multithreaded environment.  do a copy!\n    cparams.typesize = (uint8_t)typesize;\n    cparams.compcode = (uint8_t)g_compressor;\n    cparams.clevel = (uint8_t)clevel;\n    cparams.nthreads = (uint8_t)g_nthreads;\n    cctx = blosc2_create_cctx(cparams);\n    /* Do the actual compression */\n    result = blosc2_compress_ctx(cctx, src, srcsize, dest, destsize);\n    /* Release context resources */\n    blosc2_free_ctx(cctx);\n    return result;\n  }\n\n  pthread_mutex_lock(&global_comp_mutex);\n\n  /* Initialize a context compression */\n  uint8_t* filters = calloc(1, BLOSC2_MAX_FILTERS);\n  uint8_t* filters_meta = calloc(1, BLOSC2_MAX_FILTERS);\n  build_filters(doshuffle, g_delta, typesize, filters);\n  error = initialize_context_compression(\n    g_global_context, src, srcsize, dest, destsize, clevel, filters,\n    filters_meta, (int32_t)typesize, g_compressor, g_force_blocksize, g_nthreads, g_nthreads,\n    g_schunk);\n  free(filters);\n  free(filters_meta);\n  if (error <= 0) {\n    pthread_mutex_unlock(&global_comp_mutex);\n    return error;\n  }\n\n  /* Write chunk header without extended header (Blosc1 compatibility mode) */\n  error = write_compression_header(g_global_context, false);\n  if (error < 0) {\n    pthread_mutex_unlock(&global_comp_mutex);\n    return error;\n  }\n\n  result = blosc_compress_context(g_global_context);\n\n  pthread_mutex_unlock(&global_comp_mutex);\n\n  return result;\n}\n\n\n// target function\nstatic int blosc_c(struct thread_context* thread_context, int32_t bsize,\n                   int32_t leftoverblock, int32_t ntbytes, int32_t maxbytes,\n                   const uint8_t* src, const int32_t offset, uint8_t* dest,\n                   uint8_t* tmp, uint8_t* tmp2) {\n  blosc2_context* context = thread_context->parent_context;\n  int dont_split = (context->header_flags & 0x10) >> 4;\n  int dict_training = context->use_dict && context->dict_cdict == NULL;\n  int32_t j, neblock, nstreams;\n  int32_t cbytes;                   /* number of compressed bytes in split */\n  int32_t ctbytes = 0;              /* number of compressed bytes in block */\n  int64_t maxout;\n  int32_t typesize = context->typesize;\n  const char* compname;\n  int accel;\n  const uint8_t* _src;\n  uint8_t *_tmp = tmp, *_tmp2 = tmp2;\n  uint8_t *_tmp3 = thread_context->tmp4;\n  int last_filter_index = last_filter(context->filters, 'c');\n  bool memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;\n\n  if (last_filter_index >= 0 || context->prefilter != NULL) {\n    /* Apply the filter pipeline just for the prefilter */\n    if (memcpyed && context->prefilter != NULL) {\n      // We only need the prefilter output\n      _src = pipeline_c(thread_context, bsize, src, offset, dest, _tmp2, _tmp3);\n\n      if (_src == NULL) {\n        return -9;  // signals a problem with the filter pipeline\n      }\n      return bsize;\n    }\n    /* Apply regular filter pipeline */\n    _src = pipeline_c(thread_context, bsize, src, offset, _tmp, _tmp2, _tmp3);\n\n    if (_src == NULL) {\n      return -9;  // signals a problem with the filter pipeline\n    }\n  } else {\n    _src = src + offset;\n  }\n\n  assert(context->clevel > 0);\n\n  /* Calculate acceleration for different compressors */\n  accel = get_accel(context);\n\n  /* The number of compressed data streams for this block */\n  if (!dont_split && !leftoverblock && !dict_training) {\n    nstreams = (int32_t)typesize;\n  }\n  else {\n    nstreams = 1;\n  }\n  neblock = bsize / nstreams;\n  for (j = 0; j < nstreams; j++) {\n    if (!dict_training) {\n      dest += sizeof(int32_t);\n      ntbytes += sizeof(int32_t);\n      ctbytes += sizeof(int32_t);\n    }\n\n    // See if we have a run here\n    const uint8_t* ip = (uint8_t*)_src + j * neblock;\n    const uint8_t* ipbound = (uint8_t*)_src + (j + 1) * neblock;\n    if (get_run(ip, ipbound)) {\n      // A run.  Encode the repeated byte as a negative length in the length of the split.\n      int32_t value = _src[j * neblock];\n      _sw32(dest - 4, -value);\n      continue;\n    }\n\n    maxout = neblock;\n  #if defined(HAVE_SNAPPY)\n    if (context->compcode == BLOSC_SNAPPY) {\n      maxout = (int32_t)snappy_max_compressed_length((size_t)neblock);\n    }\n  #endif /*  HAVE_SNAPPY */\n    if (ntbytes + maxout > maxbytes) {\n      /* avoid buffer * overrun */\n      maxout = (int64_t)maxbytes - (int64_t)ntbytes;\n      if (maxout <= 0) {\n        return 0;                  /* non-compressible block */\n      }\n    }\n    if (dict_training) {\n      // We are in the build dict state, so don't compress\n      // TODO: copy only a percentage for sampling\n      memcpy(dest, _src + j * neblock, (unsigned int)neblock);\n      cbytes = (int32_t)neblock;\n    }\n    else if (context->compcode == BLOSC_BLOSCLZ) {\n      cbytes = blosclz_compress(context->clevel, _src + j * neblock,\n                                (int)neblock, dest, (int)maxout);\n    }\n  #if defined(HAVE_LZ4)\n    else if (context->compcode == BLOSC_LZ4) {\n      void *hash_table = NULL;\n    #ifdef HAVE_IPP\n      hash_table = (void*)thread_context->lz4_hash_table;\n    #endif\n      cbytes = lz4_wrap_compress((char*)_src + j * neblock, (size_t)neblock,\n                                 (char*)dest, (size_t)maxout, accel, hash_table);\n    }\n    else if (context->compcode == BLOSC_LZ4HC) {\n      cbytes = lz4hc_wrap_compress((char*)_src + j * neblock, (size_t)neblock,\n                                   (char*)dest, (size_t)maxout, context->clevel);\n    }\n  #endif /* HAVE_LZ4 */\n  #if defined(HAVE_LIZARD)\n    else if (context->compcode == BLOSC_LIZARD) {\n      cbytes = lizard_wrap_compress((char*)_src + j * neblock, (size_t)neblock,\n                                    (char*)dest, (size_t)maxout, accel);\n    }\n  #endif /* HAVE_LIZARD */\n  #if defined(HAVE_SNAPPY)\n    else if (context->compcode == BLOSC_SNAPPY) {\n      cbytes = snappy_wrap_compress((char*)_src + j * neblock, (size_t)neblock,\n                                    (char*)dest, (size_t)maxout);\n    }\n  #endif /* HAVE_SNAPPY */\n  #if defined(HAVE_ZLIB)\n    else if (context->compcode == BLOSC_ZLIB) {\n      cbytes = zlib_wrap_compress((char*)_src + j * neblock, (size_t)neblock,\n                                  (char*)dest, (size_t)maxout, context->clevel);\n    }\n  #endif /* HAVE_ZLIB */\n  #if defined(HAVE_ZSTD)\n    else if (context->compcode == BLOSC_ZSTD) {\n      cbytes = zstd_wrap_compress(thread_context,\n                                  (char*)_src + j * neblock, (size_t)neblock,\n                                  (char*)dest, (size_t)maxout, context->clevel);\n    }\n  #endif /* HAVE_ZSTD */\n\n    else {\n      blosc_compcode_to_compname(context->compcode, &compname);\n      fprintf(stderr, \"Blosc has not been compiled with '%s' \", compname);\n      fprintf(stderr, \"compression support.  Please use one having it.\");\n      return -5;    /* signals no compression support */\n    }\n\n    if (cbytes > maxout) {\n      /* Buffer overrun caused by compression (should never happen) */\n      return -1;\n    }\n    if (cbytes < 0) {\n      /* cbytes should never be negative */\n      return -2;\n    }\n    if (!dict_training) {\n      if (cbytes == 0 || cbytes == neblock) {\n        /* The compressor has been unable to compress data at all. */\n        /* Before doing the copy, check that we are not running into a\n           buffer overflow. */\n        if ((ntbytes + neblock) > maxbytes) {\n          return 0;    /* Non-compressible data */\n        }\n        memcpy(dest, _src + j * neblock, (unsigned int)neblock);\n        cbytes = neblock;\n      }\n      _sw32(dest - 4, cbytes);\n    }\n    dest += cbytes;\n    ntbytes += cbytes;\n    ctbytes += cbytes;\n  }  /* Closes j < nstreams */\n",
    "target": 1,
    "idx": 1026442,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "// context\n\n// target function\nstatic int\nMat_H5ReadDatasetInfo(mat_t *mat,matvar_t *matvar,hid_t dset_id)\n{\n    int err;\n    hsize_t nelems;\n\n    err = Mat_H5ReadVarInfo(matvar, dset_id);\n    if ( err ) {\n        return err;\n    }\n\n    matvar->dims = Mat_H5ReadDims(dset_id, &nelems, &matvar->rank);\n    if ( NULL == matvar->dims ) {\n        return MATIO_E_UNKNOWN_ERROR;\n    }\n\n    /* Check for attribute that indicates an empty array */\n    if ( H5Aexists_by_name(dset_id,\".\",\"MATLAB_empty\",H5P_DEFAULT) ) {\n        int empty = 0;\n        herr_t herr;\n        hid_t attr_id = H5Aopen_by_name(dset_id,\".\",\"MATLAB_empty\",H5P_DEFAULT,H5P_DEFAULT);\n        /* FIXME: Check that dataspace is scalar */\n        herr = H5Aread(attr_id,H5T_NATIVE_INT,&empty);\n        H5Aclose(attr_id);\n        if ( herr < 0 ) {\n            err = MATIO_E_GENERIC_READ_ERROR;\n        } else if ( empty ) {\n            matvar->rank = (int)matvar->dims[0];\n            free(matvar->dims);\n            matvar->dims = (size_t*)calloc(matvar->rank,sizeof(*matvar->dims));\n            if ( matvar->dims == NULL ) {\n                err = MATIO_E_OUT_OF_MEMORY;\n            } else {\n                herr = H5Dread(dset_id,SizeType2H5T(),H5S_ALL,H5S_ALL,H5P_DEFAULT,matvar->dims);\n                if ( herr < 0 ) {\n                    err = MATIO_E_GENERIC_READ_ERROR;\n                } else {\n                    size_t tmp = 1;\n                    err = Mat_MulDims(matvar, &tmp);\n                    nelems = (hsize_t)tmp;\n                }\n            }\n        }\n        if ( err ) {\n            return err;\n        }\n    }\n\n    /* Test if dataset type is compound and if so if it's complex */\n    {\n        hid_t type_id = H5Dget_type(dset_id);\n        if ( H5T_COMPOUND == H5Tget_class(type_id) ) {\n            /* FIXME: Any more checks? */\n            matvar->isComplex = MAT_F_COMPLEX;\n        }\n        H5Tclose(type_id);\n    }\n\n    /* If the dataset is a cell array read the info of the cells */\n    if ( MAT_C_CELL == matvar->class_type ) {\n        matvar_t **cells;\n\n        matvar->data_size = sizeof(matvar_t**);\n        err = Mul(&matvar->nbytes, nelems, matvar->data_size);\n        if ( err ) {\n            Mat_Critical(\"Integer multiplication overflow\");\n            return err;\n        }\n        matvar->data = calloc(matvar->nbytes, 1);\n        if ( NULL == matvar->data ) {\n            Mat_Critical(\"Couldn't allocate memory for the data\");\n            return MATIO_E_OUT_OF_MEMORY;\n        }\n        cells = (matvar_t**)matvar->data;\n\n        if ( nelems ) {\n            hobj_ref_t *ref_ids = (hobj_ref_t*)calloc(nelems, sizeof(*ref_ids));\n            if ( ref_ids != NULL ) {\n                size_t i;\n                herr_t herr = H5Dread(dset_id,H5T_STD_REF_OBJ,H5S_ALL,H5S_ALL,H5P_DEFAULT,ref_ids);\n                if ( herr < 0 ) {\n                    free(ref_ids);\n                    return MATIO_E_GENERIC_READ_ERROR;\n                }\n                for ( i = 0; i < nelems; i++ ) {\n                    hid_t ref_id;\n                    cells[i] = Mat_VarCalloc();\n                    cells[i]->internal->hdf5_ref = ref_ids[i];\n                    /* Closing of ref_id is done in Mat_H5ReadNextReferenceInfo */\n                    ref_id = H5RDEREFERENCE(dset_id,H5R_OBJECT,ref_ids+i);\n                    cells[i]->internal->id = ref_id;\n                    err = Mat_H5ReadNextReferenceInfo(ref_id,cells[i],mat);\n                    if ( err ) {\n                        break;\n                    }\n                }\n                free(ref_ids);\n            } else {\n                err = MATIO_E_OUT_OF_MEMORY;\n            }\n        }\n    } else if ( MAT_C_STRUCT == matvar->class_type ) {\n        /* Empty structures can be a dataset */\n\n        /* Check if the structure defines its fields in MATLAB_fields */\n        if ( H5Aexists_by_name(dset_id,\".\",\"MATLAB_fields\",H5P_DEFAULT) ) {\n            hsize_t nfields;\n            err = Mat_H5ReadFieldNames(matvar, dset_id, &nfields);\n        }\n    }\n\n    return err;\n}\nstatic int\nMat_H5ReadGroupInfo(mat_t *mat,matvar_t *matvar,hid_t dset_id)\n{\n    int      fields_are_variables = 1;\n    hsize_t  nfields=0,nelems;\n    hid_t    attr_id,field_id;\n    matvar_t **fields;\n    H5O_type_t obj_type;\n    int err;\n\n    err = Mat_H5ReadVarInfo(matvar,dset_id);\n    if ( err < 0 ) {\n        return err;\n    }\n\n    /* Check if the variable is sparse */\n    if ( H5Aexists_by_name(dset_id,\".\",\"MATLAB_sparse\",H5P_DEFAULT) ) {\n        herr_t herr;\n        hid_t sparse_dset_id;\n        unsigned nrows = 0;\n\n        attr_id = H5Aopen_by_name(dset_id,\".\",\"MATLAB_sparse\",H5P_DEFAULT,H5P_DEFAULT);\n        herr = H5Aread(attr_id,H5T_NATIVE_UINT,&nrows);\n        H5Aclose(attr_id);\n        if ( herr < 0 ) {\n            return MATIO_E_GENERIC_READ_ERROR;\n        }\n\n        matvar->class_type = MAT_C_SPARSE;\n\n        sparse_dset_id = H5Dopen(dset_id,\"jc\",H5P_DEFAULT);\n        matvar->dims = Mat_H5ReadDims(sparse_dset_id, &nelems, &matvar->rank);\n        H5Dclose(sparse_dset_id);\n        if ( NULL != matvar->dims ) {\n            if ( 1 == matvar->rank ) {\n                size_t* dims = (size_t*)realloc(matvar->dims, 2*sizeof(*matvar->dims));\n                if ( NULL != dims ) {\n                    matvar->rank = 2;\n                    matvar->dims = dims;\n                }\n            }\n            if ( 2 == matvar->rank ) {\n                matvar->dims[1] = matvar->dims[0] - 1;\n                matvar->dims[0] = nrows;\n            }\n        } else {\n            return MATIO_E_UNKNOWN_ERROR;\n        }\n\n        /* Test if dataset type is compound and if so if it's complex */\n        if ( H5Lexists(dset_id,\"data\",H5P_DEFAULT) ) {\n            hid_t type_id;\n            sparse_dset_id = H5Dopen(dset_id,\"data\",H5P_DEFAULT);\n            type_id = H5Dget_type(sparse_dset_id);\n            if ( H5T_COMPOUND == H5Tget_class(type_id) ) {\n                /* FIXME: Any more checks? */\n                matvar->isComplex = MAT_F_COMPLEX;\n            }\n            H5Tclose(type_id);\n            H5Dclose(sparse_dset_id);\n        }\n        return MATIO_E_NO_ERROR;\n    }\n\n    /* Check if the structure defines its fields in MATLAB_fields */\n    if ( H5Aexists_by_name(dset_id,\".\",\"MATLAB_fields\",H5P_DEFAULT) ) {\n        err = Mat_H5ReadFieldNames(matvar, dset_id, &nfields);\n        if ( err ) {\n            return err;\n        }\n    } else {\n        H5G_info_t group_info;\n        matvar->internal->num_fields = 0;\n        group_info.nlinks = 0;\n        H5Gget_info(dset_id, &group_info);\n        if ( group_info.nlinks > 0 ) {\n            struct ReadGroupInfoIterData group_data = {0, NULL};\n            herr_t herr;\n\n            /* First iteration to retrieve number of relevant links */\n            herr = H5Literate_by_name(dset_id, matvar->internal->hdf5_name, H5_INDEX_NAME,\n                H5_ITER_NATIVE, NULL, Mat_H5ReadGroupInfoIterate,\n                (void *)&group_data, H5P_DEFAULT);\n            if ( herr > 0 && group_data.nfields > 0 ) {\n                matvar->internal->fieldnames =\n                    (char**)calloc((size_t)(group_data.nfields),sizeof(*matvar->internal->fieldnames));\n                group_data.nfields = 0;\n                group_data.matvar = matvar;\n                if ( matvar->internal->fieldnames != NULL ) {\n                    /* Second iteration to fill fieldnames */\n                    H5Literate_by_name(dset_id, matvar->internal->hdf5_name, H5_INDEX_NAME,\n                        H5_ITER_NATIVE, NULL, Mat_H5ReadGroupInfoIterate,\n                        (void *)&group_data, H5P_DEFAULT);\n                }\n                matvar->internal->num_fields = (unsigned)group_data.nfields;\n                nfields = group_data.nfields;\n            }\n        }\n    }\n\n    if ( nfields > 0 ) {\n        H5O_INFO_T object_info;\n        object_info.type = H5O_TYPE_UNKNOWN;\n        H5OGET_INFO_BY_NAME(dset_id, matvar->internal->fieldnames[0], &object_info, H5P_DEFAULT);\n        obj_type = object_info.type;\n    } else {\n        obj_type = H5O_TYPE_UNKNOWN;\n    }\n    if ( obj_type == H5O_TYPE_DATASET ) {\n        hid_t field_type_id;\n        field_id = H5Dopen(dset_id,matvar->internal->fieldnames[0],H5P_DEFAULT);\n        field_type_id = H5Dget_type(field_id);\n        if ( H5T_REFERENCE == H5Tget_class(field_type_id) ) {\n            /* Check if the field has the MATLAB_class attribute. If so, it\n             * means the structure is a scalar. Otherwise, the dimensions of\n             * the field dataset is the dimensions of the structure\n             */\n            if ( H5Aexists_by_name(field_id,\".\",\"MATLAB_class\",H5P_DEFAULT) ) {\n                matvar->rank = 2;\n                matvar->dims = (size_t*)malloc(2*sizeof(*matvar->dims));\n                if ( NULL != matvar->dims ) {\n                    matvar->dims[0] = 1;\n                    matvar->dims[1] = 1;\n                    nelems = 1;\n                } else {\n                    H5Tclose(field_type_id);\n                    H5Dclose(field_id);\n                    Mat_Critical(\"Error allocating memory for matvar->dims\");\n                    return MATIO_E_OUT_OF_MEMORY;\n                }\n            } else {\n                matvar->dims = Mat_H5ReadDims(field_id, &nelems, &matvar->rank);\n                if ( NULL != matvar->dims ) {\n                    fields_are_variables = 0;\n                } else {\n                    H5Tclose(field_type_id);\n                    H5Dclose(field_id);\n                    return MATIO_E_UNKNOWN_ERROR;\n                }\n            }\n        } else {\n            /* Structure should be a scalar */\n            matvar->rank = 2;\n            matvar->dims = (size_t*)malloc(2*sizeof(*matvar->dims));\n            if ( NULL != matvar->dims ) {\n                matvar->dims[0] = 1;\n                matvar->dims[1] = 1;\n                nelems = 1;\n            } else {\n                H5Tclose(field_type_id);\n                H5Dclose(field_id);\n                Mat_Critical(\"Error allocating memory for matvar->dims\");\n                return MATIO_E_UNKNOWN_ERROR;\n            }\n        }\n        H5Tclose(field_type_id);\n        H5Dclose(field_id);\n    } else {\n        /* Structure should be a scalar */\n        matvar->rank = 2;\n        matvar->dims = (size_t*)malloc(2*sizeof(*matvar->dims));\n        if ( NULL != matvar->dims ) {\n            matvar->dims[0] = 1;\n            matvar->dims[1] = 1;\n            nelems = 1;\n        } else {\n            Mat_Critical(\"Error allocating memory for matvar->dims\");\n            return MATIO_E_OUT_OF_MEMORY;\n        }\n    }\n\n    if ( nelems < 1 || nfields < 1 )\n        return err;\n\n    matvar->data_size = sizeof(*fields);\n    {\n        size_t nelems_x_nfields;\n        err = Mul(&nelems_x_nfields, nelems, nfields);\n        err |= Mul(&matvar->nbytes, nelems_x_nfields, matvar->data_size);\n        if ( err ) {\n            Mat_Critical(\"Integer multiplication overflow\");\n            matvar->nbytes = 0;\n            return err;\n        }\n    }\n    fields = (matvar_t**)calloc(matvar->nbytes, 1);\n    matvar->data = fields;\n    if ( NULL != fields ) {\n        hsize_t k;\n        for ( k = 0; k < nfields; k++ ) {\n            H5O_INFO_T object_info;\n            fields[k] = NULL;\n            object_info.type = H5O_TYPE_UNKNOWN;\n            H5OGET_INFO_BY_NAME(dset_id, matvar->internal->fieldnames[k], &object_info, H5P_DEFAULT);\n            if ( object_info.type == H5O_TYPE_DATASET ) {\n                field_id = H5Dopen(dset_id,matvar->internal->fieldnames[k], H5P_DEFAULT);\n                if ( !fields_are_variables ) {\n                    hobj_ref_t *ref_ids = (hobj_ref_t*)calloc((size_t)nelems, sizeof(*ref_ids));\n                    if ( ref_ids != NULL ) {\n                        hsize_t l;\n                        herr_t herr = H5Dread(field_id,H5T_STD_REF_OBJ,H5S_ALL,H5S_ALL,\n                            H5P_DEFAULT,ref_ids);\n                        if ( herr < 0 ) {\n                            err = MATIO_E_GENERIC_READ_ERROR;\n                        } else {\n                            for ( l = 0; l < nelems; l++ ) {\n                                hid_t ref_id;\n                                fields[l*nfields+k] = Mat_VarCalloc();\n                                fields[l*nfields+k]->name =\n                                    strdup(matvar->internal->fieldnames[k]);\n                                fields[l*nfields+k]->internal->hdf5_ref=ref_ids[l];\n                                /* Closing of ref_id is done in Mat_H5ReadNextReferenceInfo */\n                                ref_id = H5RDEREFERENCE(field_id,H5R_OBJECT,ref_ids+l);\n                                fields[l*nfields+k]->internal->id = ref_id;\n                                err = Mat_H5ReadNextReferenceInfo(ref_id,fields[l*nfields+k],mat);\n                                if ( err ) {\n                                    break;\n                                }\n                            }\n                        }\n                        free(ref_ids);\n                    } else {\n                        err = MATIO_E_OUT_OF_MEMORY;\n                    }\n                } else {\n                    fields[k] = Mat_VarCalloc();\n                    fields[k]->name = strdup(matvar->internal->fieldnames[k]);\n                    err = Mat_H5ReadDatasetInfo(mat,fields[k],field_id);\n                }\n                H5Dclose(field_id);\n            } else if ( object_info.type == H5O_TYPE_GROUP ) {\n                field_id = H5Gopen(dset_id,matvar->internal->fieldnames[k],\n                                   H5P_DEFAULT);\n                if ( -1 < field_id ) {\n                    fields[k] = Mat_VarCalloc();\n                    fields[k]->name = strdup(matvar->internal->fieldnames[k]);\n                    err = Mat_H5ReadGroupInfo(mat,fields[k],field_id);\n                    H5Gclose(field_id);\n                }\n            }\n            if ( err ) {\n                break;\n            }\n        }\n    } else {\n        err = MATIO_E_OUT_OF_MEMORY;\n    }\n\n    return err;\n}\n",
    "target": 1,
    "idx": 1029545,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic\n    int\n_asn_build_header_check(const char *str, const u_char * data,\n                        size_t datalen, size_t typedlen)\n{\n    char            ebuf[128];\n\n    if (data == NULL) {\n        /*\n         * error message is set \n         */\n        return 1;\n    }\n    if (datalen < typedlen) {\n        snprintf(ebuf, sizeof(ebuf),\n                \"%s: bad header, length too short: %lu < %lu\", str,\n                (unsigned long)datalen, (unsigned long)typedlen);\n        ebuf[ sizeof(ebuf)-1 ] = 0;\n        ERROR_MSG(ebuf);\n        return 1;\n    }\n    return 0;\n}\n\n\n\n\n\n\n\n\n// target function\nstatic unsigned int encoded_oid_len(oid objid)\n{\n    unsigned int encoded_len = 0;\n\n    if (objid == 0)\n        return 1;\n\n    while (objid) {\n        encoded_len++;\n        objid >>= 7;\n    }\n\n    return encoded_len;\n}\n",
    "target": 1,
    "idx": 1052465,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nvoid LibRaw::xtrans_interpolate(int passes)\n{\n  int cstat[4] = {0, 0, 0, 0};\n  int ndir;\n  static const short orth[12] = {1, 0, 0, 1, -1, 0, 0, -1, 1, 0, 0, 1},\n                     patt[2][16] = {{0, 1, 0, -1, 2, 0, -1, 0, 1, 1, 1, -1, 0,\n                                     0, 0, 0},\n                                    {0, 1, 0, -2, 1, 0, -2, 0, 1, 1, -2, -2, 1,\n                                     -1, -1, 1}},\n                     dir[4] = {1, LIBRAW_AHD_TILE, LIBRAW_AHD_TILE + 1,\n                               LIBRAW_AHD_TILE - 1};\n  short allhex[3][3][2][8];\n  ushort sgrow = 0, sgcol = 0;\n\n  if (width < LIBRAW_AHD_TILE || height < LIBRAW_AHD_TILE)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT; // too small image\n                                       /* Check against right pattern */\n  for (int row = 0; row < 6; row++)\n    for (int col = 0; col < 6; col++)\n      cstat[(unsigned)fcol(row, col)]++;\n\n  if (cstat[0] < 6 || cstat[0] > 10 || cstat[1] < 16 || cstat[1] > 24 ||\n      cstat[2] < 6 || cstat[2] > 10 || cstat[3])\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  // Init allhex table to unreasonable values\n  for (int i = 0; i < 3; i++)\n    for (int j = 0; j < 3; j++)\n      for (int k = 0; k < 2; k++)\n        for (int l = 0; l < 8; l++)\n          allhex[i][j][k][l] = 32700;\n\n  cielab(0, 0);\n  ndir = 4 << int(passes > 1);\n\n  int minv = 0, maxv = 0, minh = 0, maxh = 0;\n  /* Map a green hexagon around each non-green pixel and vice versa:\t*/\n  for (int row = 0; row < 3; row++)\n    for (int col = 0; col < 3; col++)\n      for (int ng = 0, d = 0; d < 10; d += 2)\n      {\n        int g = fcol(row, col) == 1;\n        if (fcol(row + orth[d], col + orth[d + 2]) == 1)\n          ng = 0;\n        else\n          ng++;\n        if (ng == 4)\n        {\n          sgrow = row;\n          sgcol = col;\n        }\n        if (ng == g + 1)\n        {\n            int c;\n            FORC(8)\n            {\n                int v = orth[d] * patt[g][c * 2] + orth[d + 1] * patt[g][c * 2 + 1];\n                int h = orth[d + 2] * patt[g][c * 2] + orth[d + 3] * patt[g][c * 2 + 1];\n                minv = MIN(v, minv);\n                maxv = MAX(v, maxv);\n                minh = MIN(v, minh);\n                maxh = MAX(v, maxh);\n                allhex[row][col][0][c ^ (g * 2 & d)] = h + v * width;\n                allhex[row][col][1][c ^ (g * 2 & d)] = h + v * LIBRAW_AHD_TILE;\n            }\n        }\n      }\n\n  // Check allhex table initialization\n  for (int i = 0; i < 3; i++)\n    for (int j = 0; j < 3; j++)\n      for (int k = 0; k < 2; k++)\n        for (int l = 0; l < 8; l++)\n          if (allhex[i][j][k][l] > maxh + maxv * width + 1 ||\n              allhex[i][j][k][l] < minh + minv * width - 1)\n            throw LIBRAW_EXCEPTION_IO_CORRUPT;\n  int retrycount = 0;\n\n  /* Set green1 and green3 to the minimum and maximum allowed values:\t*/\n  for (int row = 2; row < height - 2; row++)\n  {\n      int col;\n      ushort min, max;\n      for (col = 2, max = 0u, min = 0xffffu; col < int(width) - 2; col++)\n      {\n          if (fcol(row, col) == 1 && (min = ~(max = 0)))\n              continue;\n          ushort(*pix)[4];\n          pix = image + row * width + col;\n          short* hex = allhex[row % 3][col % 3][0];\n          if (!max)\n          {\n              int c;\n              FORC(6)\n              {\n                  int val = pix[hex[c]][1];\n                  if (min > val)\n                      min = val;\n                  if (max < val)\n                      max = val;\n              }\n          }\n          pix[0][1] = min;\n          pix[0][3] = max;\n          switch ((row - sgrow) % 3)\n          {\n          case 1:\n              if (row < height - 3)\n              {\n                  row++;\n                  col--;\n              }\n              break;\n          case 2:\n              if ((min = ~(max = 0)) && (col += 2) < width - 3 && row > 2)\n              {\n                  row--;\n                  if (retrycount++ > width * height)\n                      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n              }\n          }\n      }\n  }\n\n  for (int row = 3; row < 9 && row < height - 3; row++)\n\t  for (int col = 3; col < 9 && col < width - 3; col++)\n\t  {\n\t\t  if ((fcol(row, col)) == 1)\n\t\t\t  continue;\n          short* hex = allhex[row % 3][col % 3][0];\n          int c;\n\t\t  FORC(2)\n\t\t  {\n\t\t\t  int idx3 = 3 * hex[4 + c] + row * width + col;\n\t\t\t  int idx4 = -3 * hex[4 + c] + row * width + col;\n\t\t\t  int maxidx = width * height;\n\t\t\t  if (idx3 < 0 || idx3 >= maxidx)\n\t\t\t\t  throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\t\t\t  if (idx4 < 0 || idx4 >= maxidx)\n\t\t\t\t  throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\t\t  }\n\t  }\n\n#if defined(LIBRAW_USE_OPENMP)\n  int buffer_count = omp_get_max_threads();\n#else\n  int buffer_count = 1;\n#endif\n\n  size_t buffer_size = LIBRAW_AHD_TILE * LIBRAW_AHD_TILE * (ndir * 11 + 6);\n  char** buffers = malloc_omp_buffers(buffer_count, buffer_size);\n\n#if defined(LIBRAW_USE_OPENMP)\n# pragma omp parallel for schedule(dynamic) default(none) firstprivate(buffers, allhex, passes, sgrow, sgcol, ndir) shared(dir) \n#endif\n    for (int top = 3; top < height - 19; top += LIBRAW_AHD_TILE - 16)\n    {\n#if defined(LIBRAW_USE_OPENMP)\n        char* buffer = buffers[omp_get_thread_num()];\n#else\n        char* buffer = buffers[0];\n#endif\n\n        ushort(*rgb)[LIBRAW_AHD_TILE][LIBRAW_AHD_TILE][3], (*rix)[3];\n        short(*lab)[LIBRAW_AHD_TILE][3], (*lix)[3];\n        float(*drv)[LIBRAW_AHD_TILE][LIBRAW_AHD_TILE];\n        char(*homo)[LIBRAW_AHD_TILE][LIBRAW_AHD_TILE];\n\n        rgb = (ushort(*)[LIBRAW_AHD_TILE][LIBRAW_AHD_TILE][3])buffer;\n        lab = (short(*)[LIBRAW_AHD_TILE][3])(\n            buffer + LIBRAW_AHD_TILE * LIBRAW_AHD_TILE * (ndir * 6));\n        drv = (float(*)[LIBRAW_AHD_TILE][LIBRAW_AHD_TILE])(\n            buffer + LIBRAW_AHD_TILE * LIBRAW_AHD_TILE * (ndir * 6 + 6));\n        homo = (char(*)[LIBRAW_AHD_TILE][LIBRAW_AHD_TILE])(\n            buffer + LIBRAW_AHD_TILE * LIBRAW_AHD_TILE * (ndir * 10 + 6));\n\n        for (int left = 3; left < width - 19; left += LIBRAW_AHD_TILE - 16)\n        {\n            int mrow = MIN(top + LIBRAW_AHD_TILE, height - 3);\n            int mcol = MIN(left + LIBRAW_AHD_TILE, width - 3);\n            for (int row = top; row < mrow; row++)\n                for (int col = left; col < mcol; col++)\n                    memcpy(rgb[0][row - top][col - left], image[row * width + col], 6);\n            int c;\n            FORC3 memcpy(rgb[c + 1], rgb[0], sizeof * rgb);\n\n            /* Interpolate green horizontally, vertically, and along both diagonals:\n             */\n            int color[3][8];\n            for (int row = top; row < mrow; row++)\n                for (int col = left; col < mcol; col++)\n                {\n                    int f;\n                    if ((f = fcol(row, col)) == 1)\n                        continue;\n                    ushort (*pix)[4] = image + row * width + col;\n                    short* hex = allhex[row % 3][col % 3][0];\n                    color[1][0] = 174 * (pix[hex[1]][1] + pix[hex[0]][1]) -\n                        46 * (pix[2 * hex[1]][1] + pix[2 * hex[0]][1]);\n                    color[1][1] = 223 * pix[hex[3]][1] + pix[hex[2]][1] * 33 +\n                        92 * (pix[0][f] - pix[-hex[2]][f]);\n                    FORC(2)\n                        color[1][2 + c] = 164 * pix[hex[4 + c]][1] +\n                        92 * pix[-2 * hex[4 + c]][1] +\n                        33 * (2 * pix[0][f] - pix[3 * hex[4 + c]][f] -\n                            pix[-3 * hex[4 + c]][f]);\n                    FORC4 rgb[c ^ !((row - sgrow) % 3)][row - top][col - left][1] =\n                        LIM(color[1][c] >> 8, pix[0][1], pix[0][3]);\n                }\n\n            for (int pass = 0; pass < passes; pass++)\n            {\n                if (pass == 1)\n                    memcpy(rgb += 4, buffer, 4 * sizeof * rgb);\n\n                /* Recalculate green from interpolated values of closer pixels:\t*/\n                if (pass)\n                {\n                    for (int row = top + 2; row < mrow - 2; row++)\n                        for (int col = left + 2; col < mcol - 2; col++)\n                        {\n                            int f;\n                            if ((f = fcol(row, col)) == 1)\n                                continue;\n                            ushort(*pix)[4] = image + row * width + col;\n                            short* hex = allhex[row % 3][col % 3][1];\n                            for (int d = 3; d < 6; d++)\n                            {\n                                rix =\n                                    &rgb[(d - 2) ^ !((row - sgrow) % 3)][row - top][col - left];\n                                int val = rix[-2 * hex[d]][1] + 2 * rix[hex[d]][1] -\n                                    rix[-2 * hex[d]][f] - 2 * rix[hex[d]][f] + 3 * rix[0][f];\n                                rix[0][1] = LIM(val / 3, pix[0][1], pix[0][3]);\n                            }\n                        }\n                }\n\n                /* Interpolate red and blue values for solitary green pixels:\t*/\n                for (int row = (top - sgrow + 4) / 3 * 3 + sgrow; row < mrow - 2; row += 3)\n                    for (int col = (left - sgcol + 4) / 3 * 3 + sgcol; col < mcol - 2; col += 3)\n                {\n                    rix = &rgb[0][row - top][col - left];\n                    int h = fcol(row, col + 1);\n\n\t\t\t\t\tif (h == 1) // Incorrect pattern\n                      break;\n\n                    float diff[6];\n                    memset(diff, 0, sizeof diff);\n                    for (int i = 1, d = 0; d < 6; d++, i ^= LIBRAW_AHD_TILE ^ 1, h ^= 2)\n                    {\n                        for (c = 0; c < 2; c++, h ^= 2)\n                        {\n                            int g = 2 * rix[0][1] - rix[i << c][1] - rix[-i << c][1];\n                            color[h][d] = g + rix[i << c][h] + rix[-i << c][h];\n                            if (d > 1)\n                                diff[d] += SQR((float)rix[i << c][1] - (float)rix[-i << c][1] -\n                                    (float)rix[i << c][h] + (float)rix[-i << c][h]) + SQR((float)g);\n                        }\n                        if (d > 1 && (d & 1))\n                            if (diff[d - 1] < diff[d])\n                                FORC(2) color[c * 2][d] = color[c * 2][d - 1];\n                        if (d < 2 || (d & 1))\n                        {\n                            FORC(2) rix[0][c * 2] = CLIP(color[c * 2][d] / 2);\n                            rix += LIBRAW_AHD_TILE * LIBRAW_AHD_TILE;\n                        }\n                    }\n                }\n\n                /* Interpolate red for blue pixels and vice versa:\t\t*/\n                for (int row = top + 3; row < mrow - 3; row++)\n                    for (int col = left + 3; col < mcol - 3; col++)\n                    {\n                        int f;\n                        if ((f = 2 - fcol(row, col)) == 1)\n                            continue;\n                        rix = &rgb[0][row - top][col - left];\n                        c = (row - sgrow) % 3 ? LIBRAW_AHD_TILE : 1;\n                        int h = 3 * (c ^ LIBRAW_AHD_TILE ^ 1);\n                        for (int d = 0; d < 4; d++, rix += LIBRAW_AHD_TILE * LIBRAW_AHD_TILE)\n                        {\n                            int i = d > 1 || ((d ^ c) & 1) ||\n                                ((ABS(rix[0][1] - rix[c][1]) +\n                                    ABS(rix[0][1] - rix[-c][1])) <\n                                    2 * (ABS(rix[0][1] - rix[h][1]) +\n                                        ABS(rix[0][1] - rix[-h][1])))\n                                ? c\n                                : h;\n                            rix[0][f] = CLIP((rix[i][f] + rix[-i][f] + 2 * rix[0][1] -\n                                rix[i][1] - rix[-i][1]) /\n                                2);\n                        }\n                    }\n\n                /* Fill in red and blue for 2x2 blocks of green:\t\t*/\n                for (int row = top + 2; row < mrow - 2; row++)\n                    if ((row - sgrow) % 3)\n                        for (int col = left + 2; col < mcol - 2; col++)\n                            if ((col - sgcol) % 3)\n                            {\n                                rix = &rgb[0][row - top][col - left];\n                                short* hex = allhex[row % 3][col % 3][1];\n                                for (int d = 0; d < 8;\n                                    d += 2, rix += LIBRAW_AHD_TILE * LIBRAW_AHD_TILE)\n                                    if (hex[d] + hex[d + 1])\n                                    {\n                                        int g = 3 * rix[0][1] - 2 * rix[hex[d]][1] - rix[hex[d + 1]][1];\n                                        for (c = 0; c < 4; c += 2)\n                                            rix[0][c] = CLIP(\n                                                (g + 2 * rix[hex[d]][c] + rix[hex[d + 1]][c]) / 3);\n                                    }\n                                    else\n                                    {\n                                        int g = 2 * rix[0][1] - rix[hex[d]][1] - rix[hex[d + 1]][1];\n                                        for (c = 0; c < 4; c += 2)\n                                            rix[0][c] =\n                                            CLIP((g + rix[hex[d]][c] + rix[hex[d + 1]][c]) / 2);\n                                    }\n                            }\n            }\n            rgb = (ushort(*)[LIBRAW_AHD_TILE][LIBRAW_AHD_TILE][3])buffer;\n            mrow -= top;\n            mcol -= left;\n\n            /* Convert to CIELab and differentiate in all directions:\t*/\n            // no effect\n            for (int d = 0; d < ndir; d++)\n            {\n                for (int row = 2; row < mrow - 2; row++)\n                    for (int col = 2; col < mcol - 2; col++)\n                        cielab(rgb[d][row][col], lab[row][col]);\n                for (int f = dir[d & 3], row = 3; row < mrow - 3; row++)\n                    for (int col = 3; col < mcol - 3; col++)\n                    {\n                        lix = &lab[row][col];\n                        int g = 2 * lix[0][0] - lix[f][0] - lix[-f][0];\n                        drv[d][row][col] =\n                            SQR(g) +\n                            SQR((2 * lix[0][1] - lix[f][1] - lix[-f][1] + g * 500 / 232)) +\n                            SQR((2 * lix[0][2] - lix[f][2] - lix[-f][2] - g * 500 / 580));\n                    }\n            }\n\n            /* Build homogeneity maps from the derivatives:\t\t\t*/\n            memset(homo, 0, ndir * LIBRAW_AHD_TILE * LIBRAW_AHD_TILE);\n            for (int row = 4; row < mrow - 4; row++)\n                for (int col = 4; col < mcol - 4; col++)\n                {\n                    int d;\n                    float tr;\n                    for (tr = FLT_MAX, d = 0; d < ndir; d++)\n                        if (tr > drv[d][row][col])\n                            tr = drv[d][row][col];\n                    tr *= 8;\n                    for (int dd = 0; dd < ndir; dd++)\n                        for (int v = -1; v <= 1; v++)\n                            for (int h = -1; h <= 1; h++)\n                                if (drv[dd][row + v][col + h] <= tr)\n                                    homo[dd][row][col]++;\n                }\n\n            /* Average the most homogeneous pixels for the final result:\t*/\n            if (height - top < LIBRAW_AHD_TILE + 4)\n                mrow = height - top + 2;\n            if (width - left < LIBRAW_AHD_TILE + 4)\n                mcol = width - left + 2;\n            for (int row = MIN(top, 8); row < mrow - 8; row++)\n                for (int col = MIN(left, 8); col < mcol - 8; col++)\n                {\n                    int v;\n                    int hm[8];\n                    for (int d = 0; d < ndir; d++)\n                        for (v = -2, hm[d] = 0; v <= 2; v++)\n                            for (int h = -2; h <= 2; h++)\n                                hm[d] += homo[d][row + v][col + h];\n                    for (int d = 0; d < ndir - 4; d++)\n                        if (hm[d] < hm[d + 4])\n                            hm[d] = 0;\n                        else if (hm[d] > hm[d + 4])\n                            hm[d + 4] = 0;\n                    ushort max;\n                    int d;\n                    for (d = 1, max = hm[0]; d < ndir; d++)\n                        if (max < hm[d])\n                            max = hm[d];\n                    max -= max >> 3;\n\n                    int avg[4];\n                    memset(avg, 0, sizeof avg);\n                    for (int dd = 0; dd < ndir; dd++)\n                        if (hm[dd] >= max)\n                        {\n                            FORC3 avg[c] += rgb[dd][row][col][c];\n                            avg[3]++;\n                        }\n                    FORC3 image[(row + top) * width + col + left][c] = avg[c] / avg[3];\n                }\n        }\n    }\n  \n#ifdef LIBRAW_USE_OPENMP\n#pragma omp barrier\n#endif\n\n    free_omp_buffers(buffers, buffer_count);\n\n    border_interpolate(8);\n}\n\nint LibRaw::dcraw_process(void)\n{\n  int quality, i;\n\n  int iterations = -1, dcb_enhance = 1, noiserd = 0;\n  float preser = 0;\n  float expos = 1.0;\n\n  CHECK_ORDER_LOW(LIBRAW_PROGRESS_LOAD_RAW);\n  //    CHECK_ORDER_HIGH(LIBRAW_PROGRESS_PRE_INTERPOLATE);\n\n  try\n  {\n\n    int no_crop = 1;\n\n    if (~O.cropbox[2] && ~O.cropbox[3])\n      no_crop = 0;\n\n    libraw_decoder_info_t di;\n    get_decoder_info(&di);\n\n    bool is_bayer = (imgdata.idata.filters || P1.colors == 1);\n    int subtract_inline =\n        !O.bad_pixels && !O.dark_frame && is_bayer && !IO.zero_is_bad;\n\n    int rc = raw2image_ex(subtract_inline); // allocate imgdata.image and copy data!\n\tif (rc != LIBRAW_SUCCESS)\n\t\treturn rc;\n\n    // Adjust sizes\n\n    int save_4color = O.four_color_rgb;\n\n    if (IO.zero_is_bad)\n    {\n      remove_zeroes();\n      SET_PROC_FLAG(LIBRAW_PROGRESS_REMOVE_ZEROES);\n    }\n\n    if (O.bad_pixels && no_crop)\n    {\n      bad_pixels(O.bad_pixels);\n      SET_PROC_FLAG(LIBRAW_PROGRESS_BAD_PIXELS);\n    }\n\n    if (O.dark_frame && no_crop)\n    {\n      subtract(O.dark_frame);\n      SET_PROC_FLAG(LIBRAW_PROGRESS_DARK_FRAME);\n    }\n    /* pre subtract black callback: check for it above to disable subtract\n     * inline */\n\n    if (callbacks.pre_subtractblack_cb)\n      (callbacks.pre_subtractblack_cb)(this);\n\n    quality = 2 + !IO.fuji_width;\n\n    if (O.user_qual >= 0)\n      quality = O.user_qual;\n\n    if (!subtract_inline || !C.data_maximum)\n    {\n      adjust_bl();\n      subtract_black_internal();\n    }\n\n    if (!(di.decoder_flags & LIBRAW_DECODER_FIXEDMAXC))\n      adjust_maximum();\n\n    if (O.user_sat > 0)\n      C.maximum = O.user_sat;\n\n    if (P1.is_foveon)\n    {\n      if (load_raw == &LibRaw::x3f_load_raw)\n      {\n        // Filter out zeroes\n        for (int q = 0; q < S.height * S.width; q++)\n        {\n          for (int c = 0; c < 4; c++)\n            if ((short)imgdata.image[q][c] < 0)\n              imgdata.image[q][c] = 0;\n        }\n      }\n      SET_PROC_FLAG(LIBRAW_PROGRESS_FOVEON_INTERPOLATE);\n    }\n\n    if (O.green_matching && !O.half_size)\n    {\n      green_matching();\n    }\n\n    if (callbacks.pre_scalecolors_cb)\n      (callbacks.pre_scalecolors_cb)(this);\n\n    if (!O.no_auto_scale)\n    {\n      scale_colors();\n      SET_PROC_FLAG(LIBRAW_PROGRESS_SCALE_COLORS);\n    }\n\n    if (callbacks.pre_preinterpolate_cb)\n      (callbacks.pre_preinterpolate_cb)(this);\n\n    pre_interpolate();\n\n    SET_PROC_FLAG(LIBRAW_PROGRESS_PRE_INTERPOLATE);\n\n    if (O.dcb_iterations >= 0)\n      iterations = O.dcb_iterations;\n    if (O.dcb_enhance_fl >= 0)\n      dcb_enhance = O.dcb_enhance_fl;\n    if (O.fbdd_noiserd >= 0)\n      noiserd = O.fbdd_noiserd;\n\n    /* pre-exposure correction callback */\n\n    if (O.exp_correc > 0)\n    {\n      expos = O.exp_shift;\n      preser = O.exp_preser;\n      exp_bef(expos, preser);\n    }\n\n    if (callbacks.pre_interpolate_cb)\n      (callbacks.pre_interpolate_cb)(this);\n\n    /* post-exposure correction fallback */\n    if (P1.filters && !O.no_interpolation)\n    {\n      if (noiserd > 0 && P1.colors == 3 && P1.filters > 1000)\n        fbdd(noiserd);\n\n      if (P1.filters > 1000 && callbacks.interpolate_bayer_cb)\n        (callbacks.interpolate_bayer_cb)(this);\n      else if (P1.filters == 9 && callbacks.interpolate_xtrans_cb)\n        (callbacks.interpolate_xtrans_cb)(this);\n      else if (quality == 0)\n        lin_interpolate();\n      else if (quality == 1 || P1.colors > 3)\n        vng_interpolate();\n      else if (quality == 2 && P1.filters > 1000)\n        ppg_interpolate();\n      else if (P1.filters == LIBRAW_XTRANS)\n      {\n        // Fuji X-Trans\n        xtrans_interpolate(quality > 2 ? 3 : 1);\n      }\n      else if (quality == 3)\n        ahd_interpolate(); // really don't need it here due to fallback op\n      else if (quality == 4)\n        dcb(iterations, dcb_enhance);\n\n      else if (quality == 11)\n        dht_interpolate();\n      else if (quality == 12)\n        aahd_interpolate();\n      // fallback to AHD\n      else\n      {\n        ahd_interpolate();\n        imgdata.process_warnings |= LIBRAW_WARN_FALLBACK_TO_AHD;\n      }\n\n      SET_PROC_FLAG(LIBRAW_PROGRESS_INTERPOLATE);\n    }\n    if (IO.mix_green)\n    {\n      for (P1.colors = 3, i = 0; i < S.height * S.width; i++)\n        imgdata.image[i][1] = (imgdata.image[i][1] + imgdata.image[i][3]) >> 1;\n      SET_PROC_FLAG(LIBRAW_PROGRESS_MIX_GREEN);\n    }\n\n    if (callbacks.post_interpolate_cb)\n      (callbacks.post_interpolate_cb)(this);\n    else if (!P1.is_foveon && P1.colors == 3 && O.med_passes > 0)\n    {\n      median_filter();\n      SET_PROC_FLAG(LIBRAW_PROGRESS_MEDIAN_FILTER);\n    }\n\n    if (O.highlight == 2)\n    {\n      blend_highlights();\n      SET_PROC_FLAG(LIBRAW_PROGRESS_HIGHLIGHTS);\n    }\n\n    if (O.highlight > 2)\n    {\n      recover_highlights();\n      SET_PROC_FLAG(LIBRAW_PROGRESS_HIGHLIGHTS);\n    }\n\n    if (O.use_fuji_rotate)\n    {\n      fuji_rotate();\n      SET_PROC_FLAG(LIBRAW_PROGRESS_FUJI_ROTATE);\n    }\n\n    if (!libraw_internal_data.output_data.histogram)\n    {\n      libraw_internal_data.output_data.histogram =\n          (int(*)[LIBRAW_HISTOGRAM_SIZE])malloc(\n              sizeof(*libraw_internal_data.output_data.histogram) * 4);\n    }\n#ifndef NO_LCMS\n    if (O.camera_profile)\n    {\n      apply_profile(O.camera_profile, O.output_profile);\n      SET_PROC_FLAG(LIBRAW_PROGRESS_APPLY_PROFILE);\n    }\n#endif\n\n    if (callbacks.pre_converttorgb_cb)\n      (callbacks.pre_converttorgb_cb)(this);\n\n    convert_to_rgb();\n    SET_PROC_FLAG(LIBRAW_PROGRESS_CONVERT_RGB);\n\n    if (callbacks.post_converttorgb_cb)\n      (callbacks.post_converttorgb_cb)(this);\n\n    if (O.use_fuji_rotate)\n    {\n      stretch();\n      SET_PROC_FLAG(LIBRAW_PROGRESS_STRETCH);\n    }\n    O.four_color_rgb = save_4color; // also, restore\n\n    return 0;\n  }\n  catch (const std::bad_alloc&)\n  {\n      recycle();\n      return LIBRAW_UNSUFFICIENT_MEMORY;\n  }\n  catch (const LibRaw_exceptions& err)\n  {\n    EXCEPTION_HANDLER(err);\n  }\n}\n\n\n// target function\nvoid LibRaw::xtrans_interpolate(int passes)\n{\n  int cstat[4] = {0, 0, 0, 0};\n  int ndir;\n  static const short orth[12] = {1, 0, 0, 1, -1, 0, 0, -1, 1, 0, 0, 1},\n                     patt[2][16] = {{0, 1, 0, -1, 2, 0, -1, 0, 1, 1, 1, -1, 0,\n                                     0, 0, 0},\n                                    {0, 1, 0, -2, 1, 0, -2, 0, 1, 1, -2, -2, 1,\n                                     -1, -1, 1}},\n                     dir[4] = {1, LIBRAW_AHD_TILE, LIBRAW_AHD_TILE + 1,\n                               LIBRAW_AHD_TILE - 1};\n  short allhex[3][3][2][8];\n  ushort sgrow = 0, sgcol = 0;\n\n  if (width < LIBRAW_AHD_TILE || height < LIBRAW_AHD_TILE)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT; // too small image\n                                       /* Check against right pattern */\n  for (int row = 0; row < 6; row++)\n    for (int col = 0; col < 6; col++)\n      cstat[(unsigned)fcol(row, col)]++;\n\n  if (cstat[0] < 6 || cstat[0] > 10 || cstat[1] < 16 || cstat[1] > 24 ||\n      cstat[2] < 6 || cstat[2] > 10 || cstat[3])\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  // Init allhex table to unreasonable values\n  for (int i = 0; i < 3; i++)\n    for (int j = 0; j < 3; j++)\n      for (int k = 0; k < 2; k++)\n        for (int l = 0; l < 8; l++)\n          allhex[i][j][k][l] = 32700;\n\n  cielab(0, 0);\n  ndir = 4 << int(passes > 1);\n\n  int minv = 0, maxv = 0, minh = 0, maxh = 0;\n  /* Map a green hexagon around each non-green pixel and vice versa:\t*/\n  for (int row = 0; row < 3; row++)\n    for (int col = 0; col < 3; col++)\n      for (int ng = 0, d = 0; d < 10; d += 2)\n      {\n        int g = fcol(row, col) == 1;\n        if (fcol(row + orth[d], col + orth[d + 2]) == 1)\n          ng = 0;\n        else\n          ng++;\n        if (ng == 4)\n        {\n          sgrow = row;\n          sgcol = col;\n        }\n        if (ng == g + 1)\n        {\n            int c;\n            FORC(8)\n            {\n                int v = orth[d] * patt[g][c * 2] + orth[d + 1] * patt[g][c * 2 + 1];\n                int h = orth[d + 2] * patt[g][c * 2] + orth[d + 3] * patt[g][c * 2 + 1];\n                minv = MIN(v, minv);\n                maxv = MAX(v, maxv);\n                minh = MIN(v, minh);\n                maxh = MAX(v, maxh);\n                allhex[row][col][0][c ^ (g * 2 & d)] = h + v * width;\n                allhex[row][col][1][c ^ (g * 2 & d)] = h + v * LIBRAW_AHD_TILE;\n            }\n        }\n      }\n\n  // Check allhex table initialization\n  for (int i = 0; i < 3; i++)\n    for (int j = 0; j < 3; j++)\n      for (int k = 0; k < 2; k++)\n        for (int l = 0; l < 8; l++)\n          if (allhex[i][j][k][l] > maxh + maxv * width + 1 ||\n              allhex[i][j][k][l] < minh + minv * width - 1)\n            throw LIBRAW_EXCEPTION_IO_CORRUPT;\n  int retrycount = 0;\n\n  /* Set green1 and green3 to the minimum and maximum allowed values:\t*/\n  for (int row = 2; row < height - 2; row++)\n  {\n      int col;\n      ushort min, max;\n      for (col = 2, max = 0u, min = 0xffffu; col < int(width) - 2; col++)\n      {\n          if (fcol(row, col) == 1 && (min = ~(max = 0)))\n              continue;\n          ushort(*pix)[4];\n          pix = image + row * width + col;\n          short* hex = allhex[row % 3][col % 3][0];\n          if (!max)\n          {\n              int c;\n              FORC(6)\n              {\n                  int val = pix[hex[c]][1];\n                  if (min > val)\n                      min = val;\n                  if (max < val)\n                      max = val;\n              }\n          }\n          pix[0][1] = min;\n          pix[0][3] = max;\n          switch ((row - sgrow) % 3)\n          {\n          case 1:\n              if (row < height - 3)\n              {\n                  row++;\n                  col--;\n              }\n              break;\n          case 2:\n              if ((min = ~(max = 0)) && (col += 2) < width - 3 && row > 2)\n              {\n                  row--;\n                  if (retrycount++ > width * height)\n                      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n              }\n          }\n      }\n  }\n\n  for (int row = 3; row < 9 && row < height - 3; row++)\n\t  for (int col = 3; col < 9 && col < width - 3; col++)\n\t  {\n\t\t  if ((fcol(row, col)) == 1)\n\t\t\t  continue;\n          short* hex = allhex[row % 3][col % 3][0];\n          int c;\n\t\t  FORC(2)\n\t\t  {\n\t\t\t  int idx3 = 3 * hex[4 + c] + row * width + col;\n\t\t\t  int idx4 = -3 * hex[4 + c] + row * width + col;\n\t\t\t  int maxidx = width * height;\n\t\t\t  if (idx3 < 0 || idx3 >= maxidx)\n\t\t\t\t  throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\t\t\t  if (idx4 < 0 || idx4 >= maxidx)\n\t\t\t\t  throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\t\t  }\n\t  }\n\n#if defined(LIBRAW_USE_OPENMP)\n  int buffer_count = omp_get_max_threads();\n#else\n  int buffer_count = 1;\n#endif\n\n  size_t buffer_size = LIBRAW_AHD_TILE * LIBRAW_AHD_TILE * (ndir * 11 + 6);\n  char** buffers = malloc_omp_buffers(buffer_count, buffer_size);\n\n#if defined(LIBRAW_USE_OPENMP)\n# pragma omp parallel for schedule(dynamic) default(none) firstprivate(buffers, allhex, passes, sgrow, sgcol, ndir) shared(dir) \n#endif\n    for (int top = 3; top < height - 19; top += LIBRAW_AHD_TILE - 16)\n    {\n#if defined(LIBRAW_USE_OPENMP)\n        char* buffer = buffers[omp_get_thread_num()];\n#else\n        char* buffer = buffers[0];\n#endif\n\n        ushort(*rgb)[LIBRAW_AHD_TILE][LIBRAW_AHD_TILE][3], (*rix)[3];\n        short(*lab)[LIBRAW_AHD_TILE][3], (*lix)[3];\n        float(*drv)[LIBRAW_AHD_TILE][LIBRAW_AHD_TILE];\n        char(*homo)[LIBRAW_AHD_TILE][LIBRAW_AHD_TILE];\n\n        rgb = (ushort(*)[LIBRAW_AHD_TILE][LIBRAW_AHD_TILE][3])buffer;\n        lab = (short(*)[LIBRAW_AHD_TILE][3])(\n            buffer + LIBRAW_AHD_TILE * LIBRAW_AHD_TILE * (ndir * 6));\n        drv = (float(*)[LIBRAW_AHD_TILE][LIBRAW_AHD_TILE])(\n            buffer + LIBRAW_AHD_TILE * LIBRAW_AHD_TILE * (ndir * 6 + 6));\n        homo = (char(*)[LIBRAW_AHD_TILE][LIBRAW_AHD_TILE])(\n            buffer + LIBRAW_AHD_TILE * LIBRAW_AHD_TILE * (ndir * 10 + 6));\n\n        for (int left = 3; left < width - 19; left += LIBRAW_AHD_TILE - 16)\n        {\n            int mrow = MIN(top + LIBRAW_AHD_TILE, height - 3);\n            int mcol = MIN(left + LIBRAW_AHD_TILE, width - 3);\n            for (int row = top; row < mrow; row++)\n                for (int col = left; col < mcol; col++)\n                    memcpy(rgb[0][row - top][col - left], image[row * width + col], 6);\n            int c;\n            FORC3 memcpy(rgb[c + 1], rgb[0], sizeof * rgb);\n\n            /* Interpolate green horizontally, vertically, and along both diagonals:\n             */\n            int color[3][8];\n            for (int row = top; row < mrow; row++)\n                for (int col = left; col < mcol; col++)\n                {\n                    int f;\n                    if ((f = fcol(row, col)) == 1)\n                        continue;\n                    ushort (*pix)[4] = image + row * width + col;\n                    short* hex = allhex[row % 3][col % 3][0];\n                    color[1][0] = 174 * (pix[hex[1]][1] + pix[hex[0]][1]) -\n                        46 * (pix[2 * hex[1]][1] + pix[2 * hex[0]][1]);\n                    color[1][1] = 223 * pix[hex[3]][1] + pix[hex[2]][1] * 33 +\n                        92 * (pix[0][f] - pix[-hex[2]][f]);\n                    FORC(2)\n                        color[1][2 + c] = 164 * pix[hex[4 + c]][1] +\n                        92 * pix[-2 * hex[4 + c]][1] +\n                        33 * (2 * pix[0][f] - pix[3 * hex[4 + c]][f] -\n                            pix[-3 * hex[4 + c]][f]);\n                    FORC4 rgb[c ^ !((row - sgrow) % 3)][row - top][col - left][1] =\n                        LIM(color[1][c] >> 8, pix[0][1], pix[0][3]);\n                }\n\n            for (int pass = 0; pass < passes; pass++)\n            {\n                if (pass == 1)\n                    memcpy(rgb += 4, buffer, 4 * sizeof * rgb);\n\n                /* Recalculate green from interpolated values of closer pixels:\t*/\n                if (pass)\n                {\n                    for (int row = top + 2; row < mrow - 2; row++)\n                        for (int col = left + 2; col < mcol - 2; col++)\n                        {\n                            int f;\n                            if ((f = fcol(row, col)) == 1)\n                                continue;\n                            ushort(*pix)[4] = image + row * width + col;\n                            short* hex = allhex[row % 3][col % 3][1];\n                            for (int d = 3; d < 6; d++)\n                            {\n                                rix =\n                                    &rgb[(d - 2) ^ !((row - sgrow) % 3)][row - top][col - left];\n                                int val = rix[-2 * hex[d]][1] + 2 * rix[hex[d]][1] -\n                                    rix[-2 * hex[d]][f] - 2 * rix[hex[d]][f] + 3 * rix[0][f];\n                                rix[0][1] = LIM(val / 3, pix[0][1], pix[0][3]);\n                            }\n                        }\n                }\n\n                /* Interpolate red and blue values for solitary green pixels:\t*/\n                for (int row = (top - sgrow + 4) / 3 * 3 + sgrow; row < mrow - 2; row += 3)\n                    for (int col = (left - sgcol + 4) / 3 * 3 + sgcol; col < mcol - 2; col += 3)\n                {\n                    rix = &rgb[0][row - top][col - left];\n                    int h = fcol(row, col + 1);\n                    float diff[6];\n                    memset(diff, 0, sizeof diff);\n                    for (int i = 1, d = 0; d < 6; d++, i ^= LIBRAW_AHD_TILE ^ 1, h ^= 2)\n                    {\n                        for (c = 0; c < 2; c++, h ^= 2)\n                        {\n                            int g = 2 * rix[0][1] - rix[i << c][1] - rix[-i << c][1];\n                            color[h][d] = g + rix[i << c][h] + rix[-i << c][h];\n                            if (d > 1)\n                                diff[d] += SQR((float)rix[i << c][1] - (float)rix[-i << c][1] -\n                                    (float)rix[i << c][h] + (float)rix[-i << c][h]) + SQR((float)g);\n                        }\n                        if (d > 1 && (d & 1))\n                            if (diff[d - 1] < diff[d])\n                                FORC(2) color[c * 2][d] = color[c * 2][d - 1];\n                        if (d < 2 || (d & 1))\n                        {\n                            FORC(2) rix[0][c * 2] = CLIP(color[c * 2][d] / 2);\n                            rix += LIBRAW_AHD_TILE * LIBRAW_AHD_TILE;\n                        }\n                    }\n                }\n\n                /* Interpolate red for blue pixels and vice versa:\t\t*/\n                for (int row = top + 3; row < mrow - 3; row++)\n                    for (int col = left + 3; col < mcol - 3; col++)\n                    {\n                        int f;\n                        if ((f = 2 - fcol(row, col)) == 1)\n                            continue;\n                        rix = &rgb[0][row - top][col - left];\n                        c = (row - sgrow) % 3 ? LIBRAW_AHD_TILE : 1;\n                        int h = 3 * (c ^ LIBRAW_AHD_TILE ^ 1);\n                        for (int d = 0; d < 4; d++, rix += LIBRAW_AHD_TILE * LIBRAW_AHD_TILE)\n                        {\n                            int i = d > 1 || ((d ^ c) & 1) ||\n                                ((ABS(rix[0][1] - rix[c][1]) +\n                                    ABS(rix[0][1] - rix[-c][1])) <\n                                    2 * (ABS(rix[0][1] - rix[h][1]) +\n                                        ABS(rix[0][1] - rix[-h][1])))\n                                ? c\n                                : h;\n                            rix[0][f] = CLIP((rix[i][f] + rix[-i][f] + 2 * rix[0][1] -\n                                rix[i][1] - rix[-i][1]) /\n                                2);\n                        }\n                    }\n\n                /* Fill in red and blue for 2x2 blocks of green:\t\t*/\n                for (int row = top + 2; row < mrow - 2; row++)\n                    if ((row - sgrow) % 3)\n                        for (int col = left + 2; col < mcol - 2; col++)\n                            if ((col - sgcol) % 3)\n                            {\n                                rix = &rgb[0][row - top][col - left];\n                                short* hex = allhex[row % 3][col % 3][1];\n                                for (int d = 0; d < 8;\n                                    d += 2, rix += LIBRAW_AHD_TILE * LIBRAW_AHD_TILE)\n                                    if (hex[d] + hex[d + 1])\n                                    {\n                                        int g = 3 * rix[0][1] - 2 * rix[hex[d]][1] - rix[hex[d + 1]][1];\n                                        for (c = 0; c < 4; c += 2)\n                                            rix[0][c] = CLIP(\n                                                (g + 2 * rix[hex[d]][c] + rix[hex[d + 1]][c]) / 3);\n                                    }\n                                    else\n                                    {\n                                        int g = 2 * rix[0][1] - rix[hex[d]][1] - rix[hex[d + 1]][1];\n                                        for (c = 0; c < 4; c += 2)\n                                            rix[0][c] =\n                                            CLIP((g + rix[hex[d]][c] + rix[hex[d + 1]][c]) / 2);\n                                    }\n                            }\n            }\n            rgb = (ushort(*)[LIBRAW_AHD_TILE][LIBRAW_AHD_TILE][3])buffer;\n            mrow -= top;\n            mcol -= left;\n\n            /* Convert to CIELab and differentiate in all directions:\t*/\n            // no effect\n            for (int d = 0; d < ndir; d++)\n            {\n                for (int row = 2; row < mrow - 2; row++)\n                    for (int col = 2; col < mcol - 2; col++)\n                        cielab(rgb[d][row][col], lab[row][col]);\n                for (int f = dir[d & 3], row = 3; row < mrow - 3; row++)\n                    for (int col = 3; col < mcol - 3; col++)\n                    {\n                        lix = &lab[row][col];\n                        int g = 2 * lix[0][0] - lix[f][0] - lix[-f][0];\n                        drv[d][row][col] =\n                            SQR(g) +\n                            SQR((2 * lix[0][1] - lix[f][1] - lix[-f][1] + g * 500 / 232)) +\n                            SQR((2 * lix[0][2] - lix[f][2] - lix[-f][2] - g * 500 / 580));\n                    }\n            }\n\n            /* Build homogeneity maps from the derivatives:\t\t\t*/\n            memset(homo, 0, ndir * LIBRAW_AHD_TILE * LIBRAW_AHD_TILE);\n            for (int row = 4; row < mrow - 4; row++)\n                for (int col = 4; col < mcol - 4; col++)\n                {\n                    int d;\n                    float tr;\n                    for (tr = FLT_MAX, d = 0; d < ndir; d++)\n                        if (tr > drv[d][row][col])\n                            tr = drv[d][row][col];\n                    tr *= 8;\n                    for (int dd = 0; dd < ndir; dd++)\n                        for (int v = -1; v <= 1; v++)\n                            for (int h = -1; h <= 1; h++)\n                                if (drv[dd][row + v][col + h] <= tr)\n                                    homo[dd][row][col]++;\n                }\n\n            /* Average the most homogeneous pixels for the final result:\t*/\n            if (height - top < LIBRAW_AHD_TILE + 4)\n                mrow = height - top + 2;\n            if (width - left < LIBRAW_AHD_TILE + 4)\n                mcol = width - left + 2;\n            for (int row = MIN(top, 8); row < mrow - 8; row++)\n                for (int col = MIN(left, 8); col < mcol - 8; col++)\n                {\n                    int v;\n                    int hm[8];\n                    for (int d = 0; d < ndir; d++)\n                        for (v = -2, hm[d] = 0; v <= 2; v++)\n                            for (int h = -2; h <= 2; h++)\n                                hm[d] += homo[d][row + v][col + h];\n                    for (int d = 0; d < ndir - 4; d++)\n                        if (hm[d] < hm[d + 4])\n                            hm[d] = 0;\n                        else if (hm[d] > hm[d + 4])\n                            hm[d + 4] = 0;\n                    ushort max;\n                    int d;\n                    for (d = 1, max = hm[0]; d < ndir; d++)\n                        if (max < hm[d])\n                            max = hm[d];\n                    max -= max >> 3;\n\n                    int avg[4];\n                    memset(avg, 0, sizeof avg);\n                    for (int dd = 0; dd < ndir; dd++)\n                        if (hm[dd] >= max)\n                        {\n                            FORC3 avg[c] += rgb[dd][row][col][c];\n                            avg[3]++;\n                        }\n                    FORC3 image[(row + top) * width + col + left][c] = avg[c] / avg[3];\n                }\n        }\n    }\n  \n#ifdef LIBRAW_USE_OPENMP\n#pragma omp barrier\n#endif\n\n    free_omp_buffers(buffers, buffer_count);\n\n    border_interpolate(8);\n}\n",
    "target": 1,
    "idx": 1060728,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\n  TT_Get_MM_Var( TT_Face      face,\n                 FT_MM_Var*  *master )\n  {\n    FT_Stream            stream = face->root.stream;\n    FT_Memory            memory = face->root.memory;\n    FT_ULong             table_len;\n    FT_Error             error  = FT_Err_Ok;\n    FT_ULong             fvar_start;\n    FT_UInt              i, j;\n    FT_MM_Var*           mmvar = NULL;\n    FT_Fixed*            next_coords;\n    FT_Fixed*            nsc;\n    FT_String*           next_name;\n    FT_Var_Axis*         a;\n    FT_Fixed*            c;\n    FT_Var_Named_Style*  ns;\n    GX_FVar_Head         fvar_head;\n    FT_Bool              usePsName;\n    FT_UInt              num_instances;\n\n    static const FT_Frame_Field  fvar_fields[] =\n    {\n\n#undef  FT_STRUCTURE\n#define FT_STRUCTURE  GX_FVar_Head\n\n      FT_FRAME_START( 16 ),\n        FT_FRAME_LONG      ( version ),\n        FT_FRAME_USHORT    ( offsetToData ),\n        FT_FRAME_SKIP_SHORT,\n        FT_FRAME_USHORT    ( axisCount ),\n        FT_FRAME_USHORT    ( axisSize ),\n        FT_FRAME_USHORT    ( instanceCount ),\n        FT_FRAME_USHORT    ( instanceSize ),\n      FT_FRAME_END\n    };\n\n    static const FT_Frame_Field  fvaraxis_fields[] =\n    {\n\n#undef  FT_STRUCTURE\n#define FT_STRUCTURE  GX_FVar_Axis\n\n      FT_FRAME_START( 20 ),\n        FT_FRAME_ULONG ( axisTag ),\n        FT_FRAME_LONG  ( minValue ),\n        FT_FRAME_LONG  ( defaultValue ),\n        FT_FRAME_LONG  ( maxValue ),\n        FT_FRAME_USHORT( flags ),\n        FT_FRAME_USHORT( nameID ),\n      FT_FRAME_END\n    };\n\n\n    /* read the font data and set up the internal representation */\n    /* if not already done                                       */\n\n    if ( !face->blend )\n    {\n      FT_TRACE2(( \"FVAR \" ));\n\n      /* both `fvar' and `gvar' must be present */\n      if ( FT_SET_ERROR( face->goto_table( face, TTAG_gvar,\n                                           stream, &table_len ) ) )\n      {\n        /* CFF2 is an alternate to gvar here */\n        if ( FT_SET_ERROR( face->goto_table( face, TTAG_CFF2,\n                                             stream, &table_len ) ) )\n        {\n          FT_TRACE1(( \"\\n\"\n                      \"TT_Get_MM_Var: `gvar' or `CFF2' table is missing\\n\" ));\n          goto Exit;\n        }\n      }\n\n      if ( FT_SET_ERROR( face->goto_table( face, TTAG_fvar,\n                                           stream, &table_len ) ) )\n      {\n        FT_TRACE1(( \"is missing\\n\" ));\n        goto Exit;\n      }\n\n      fvar_start = FT_STREAM_POS( );\n\n      /* the validity of the `fvar' header data was already checked */\n      /* in function `sfnt_init_face'                               */\n      if ( FT_STREAM_READ_FIELDS( fvar_fields, &fvar_head ) )\n        goto Exit;\n\n      usePsName = FT_BOOL( fvar_head.instanceSize ==\n                           6 + 4 * fvar_head.axisCount );\n\n      FT_TRACE2(( \"loaded\\n\" ));\n\n      FT_TRACE5(( \"number of GX style axes: %d\\n\", fvar_head.axisCount ));\n\n      if ( FT_NEW( face->blend ) )\n        goto Exit;\n\n      /* `num_instances' holds the number of all named instances, */\n      /* including the default instance which might be missing    */\n      /* in fvar's table of named instances                       */\n      num_instances = face->root.style_flags >> 16;\n\n      /* cannot overflow 32-bit arithmetic because of the size limits */\n      /* used in the `fvar' table validity check in `sfnt_init_face'  */\n      face->blend->mmvar_len =\n        sizeof ( FT_MM_Var ) +\n        fvar_head.axisCount * sizeof ( FT_Var_Axis ) +\n        num_instances * sizeof ( FT_Var_Named_Style ) +\n        num_instances * fvar_head.axisCount * sizeof ( FT_Fixed ) +\n        5 * fvar_head.axisCount;\n\n      if ( FT_ALLOC( mmvar, face->blend->mmvar_len ) )\n        goto Exit;\n      face->blend->mmvar = mmvar;\n\n      /* set up pointers and offsets into the `mmvar' array; */\n      /* the data gets filled in later on                    */\n\n      mmvar->num_axis =\n        fvar_head.axisCount;\n      mmvar->num_designs =\n        ~0U;                   /* meaningless in this context; each glyph */\n                               /* may have a different number of designs  */\n                               /* (or tuples, as called by Apple)         */\n      mmvar->num_namedstyles =\n        num_instances;\n      mmvar->axis =\n        (FT_Var_Axis*)&( mmvar[1] );\n      mmvar->namedstyle =\n        (FT_Var_Named_Style*)&( mmvar->axis[fvar_head.axisCount] );\n\n      next_coords =\n        (FT_Fixed*)&( mmvar->namedstyle[num_instances] );\n      for ( i = 0; i < num_instances; i++ )\n      {\n        mmvar->namedstyle[i].coords  = next_coords;\n        next_coords                 += fvar_head.axisCount;\n      }\n\n      next_name = (FT_String*)next_coords;\n      for ( i = 0; i < fvar_head.axisCount; i++ )\n      {\n        mmvar->axis[i].name  = next_name;\n        next_name           += 5;\n      }\n\n      /* now fill in the data */\n\n      if ( FT_STREAM_SEEK( fvar_start + fvar_head.offsetToData ) )\n        goto Exit;\n\n      a = mmvar->axis;\n      for ( i = 0; i < fvar_head.axisCount; i++ )\n      {\n        GX_FVar_Axis  axis_rec;\n\n\n        if ( FT_STREAM_READ_FIELDS( fvaraxis_fields, &axis_rec ) )\n          goto Exit;\n        a->tag     = axis_rec.axisTag;\n        a->minimum = axis_rec.minValue;\n        a->def     = axis_rec.defaultValue;\n        a->maximum = axis_rec.maxValue;\n        a->strid   = axis_rec.nameID;\n\n        a->name[0] = (FT_String)(   a->tag >> 24 );\n        a->name[1] = (FT_String)( ( a->tag >> 16 ) & 0xFF );\n        a->name[2] = (FT_String)( ( a->tag >>  8 ) & 0xFF );\n        a->name[3] = (FT_String)( ( a->tag       ) & 0xFF );\n        a->name[4] = '\\0';\n\n        if ( a->minimum > a->def ||\n             a->def > a->maximum )\n        {\n          FT_TRACE2(( \"TT_Get_MM_Var:\"\n                      \" invalid \\\"%s\\\" axis record; disabling\\n\",\n                      a->name ));\n\n          a->minimum = a->def;\n          a->maximum = a->def;\n        }\n\n        FT_TRACE5(( \"  \\\"%s\\\": minimum=%.5f, default=%.5f, maximum=%.5f\\n\",\n                    a->name,\n                    a->minimum / 65536.0,\n                    a->def / 65536.0,\n                    a->maximum / 65536.0 ));\n\n        a++;\n      }\n\n      FT_TRACE5(( \"\\n\" ));\n\n      /* named instance coordinates are stored as design coordinates; */\n      /* we have to convert them to normalized coordinates also       */\n      if ( FT_NEW_ARRAY( face->blend->normalized_stylecoords,\n                         fvar_head.axisCount * num_instances ) )\n        goto Exit;\n\n      if ( fvar_head.instanceCount && !face->blend->avar_checked )\n        ft_var_load_avar( face );\n\n      ns  = mmvar->namedstyle;\n      nsc = face->blend->normalized_stylecoords;\n      for ( i = 0; i < fvar_head.instanceCount; i++, ns++ )\n      {\n        /* PostScript names add 2 bytes to the instance record size */\n        if ( FT_FRAME_ENTER( ( usePsName ? 6L : 4L ) +\n                             4L * fvar_head.axisCount ) )\n          goto Exit;\n\n        ns->strid       =    FT_GET_USHORT();\n        (void) /* flags = */ FT_GET_USHORT();\n\n        c = ns->coords;\n        for ( j = 0; j < fvar_head.axisCount; j++, c++ )\n          *c = FT_GET_LONG();\n\n        if ( usePsName )\n          ns->psid = FT_GET_USHORT();\n\n        ft_var_to_normalized( face,\n                              fvar_head.axisCount,\n                              ns->coords,\n                              nsc );\n        nsc += fvar_head.axisCount;\n\n        FT_FRAME_EXIT();\n      }\n\n      if ( num_instances != fvar_head.instanceCount )\n      {\n        SFNT_Service  sfnt = (SFNT_Service)face->sfnt;\n\n        FT_Int  found, win, apple;\n\n\n        /* the default instance is missing in array the   */\n        /* of named instances; try to synthesize an entry */\n        found = sfnt->get_name_id( face,\n                                   TT_NAME_ID_TYPOGRAPHIC_SUBFAMILY,\n                                   &win,\n                                   &apple );\n        if ( !found )\n          found = sfnt->get_name_id( face,\n                                     TT_NAME_ID_FONT_SUBFAMILY,\n                                     &win,\n                                     &apple );\n\n        if ( found )\n        {\n          FT_Int  strid = win >= 0 ? win : apple;\n\n\n          found = sfnt->get_name_id( face,\n                                     TT_NAME_ID_PS_NAME,\n                                     &win,\n                                     &apple );\n          if ( found )\n          {\n            FT_Int  psid = win >= 0 ? win : apple;\n\n\n            FT_TRACE5(( \"TT_Get_MM_Var:\"\n                        \" Adding default instance to named instances\\n\" ));\n\n            ns = &mmvar->namedstyle[fvar_head.instanceCount];\n\n            ns->strid = strid;\n            ns->psid  = psid;\n\n            a = mmvar->axis;\n            c = ns->coords;\n            for ( j = 0; j < fvar_head.axisCount; j++, a++, c++ )\n              *c = a->def;\n          }\n        }\n      }\n\n      ft_var_load_mvar( face );\n    }\n\n    /* fill the output array if requested */\n\n    if ( master )\n    {\n      FT_UInt  n;\n\n\n      if ( FT_ALLOC( mmvar, face->blend->mmvar_len ) )\n        goto Exit;\n      FT_MEM_COPY( mmvar, face->blend->mmvar, face->blend->mmvar_len );\n\n      mmvar->axis =\n        (FT_Var_Axis*)&( mmvar[1] );\n      mmvar->namedstyle =\n        (FT_Var_Named_Style*)&( mmvar->axis[mmvar->num_axis] );\n      next_coords =\n        (FT_Fixed*)&( mmvar->namedstyle[mmvar->num_namedstyles] );\n\n      for ( n = 0; n < mmvar->num_namedstyles; n++ )\n      {\n        mmvar->namedstyle[n].coords  = next_coords;\n        next_coords                 += mmvar->num_axis;\n      }\n\n      a         = mmvar->axis;\n      next_name = (FT_String*)next_coords;\n      for ( n = 0; n < mmvar->num_axis; n++ )\n      {\n        a->name = next_name;\n\n        /* standard PostScript names for some standard apple tags */\n        if ( a->tag == TTAG_wght )\n          a->name = (char*)\"Weight\";\n        else if ( a->tag == TTAG_wdth )\n          a->name = (char*)\"Width\";\n        else if ( a->tag == TTAG_opsz )\n          a->name = (char*)\"OpticalSize\";\n        else if ( a->tag == TTAG_slnt )\n          a->name = (char*)\"Slant\";\n\n        next_name += 5;\n        a++;\n      }\n\n      *master = mmvar;\n    }\n\n  Exit:\n    return error;\n  }\n\n  FT_Get_MM_Var( FT_Face      face,\n                 FT_MM_Var*  *amaster )\n  {\n    FT_Error                 error;\n    FT_Service_MultiMasters  service;\n\n\n    /* check of `face' delayed to `ft_face_get_mm_service' */\n\n    if ( !amaster )\n      return FT_THROW( Invalid_Argument );\n\n    error = ft_face_get_mm_service( face, &service );\n    if ( !error )\n    {\n      error = FT_ERR( Invalid_Argument );\n      if ( service->get_mm_var )\n        error = service->get_mm_var( face, amaster );\n    }\n\n    return error;\n  }\n\n  static void\n  setIntermediateAxis( FT_Face  face )\n  {\n    // only handle Multiple Masters and GX variation fonts\n    if ( !FT_HAS_MULTIPLE_MASTERS( face ) )\n      return;\n\n    // get variation data for current instance\n    FT_MM_Var*  variations_ptr = nullptr;\n    if ( FT_Get_MM_Var( face, &variations_ptr ) )\n      return;\n\n    unique_ptr<FT_MM_Var,\n               decltype ( free )*>  variations( variations_ptr, free );\n    vector<FT_Fixed>                coords( variations->num_axis );\n\n    // select an arbitrary instance\n    for ( unsigned int  i = 0; i < variations->num_axis; i++ )\n      coords[i] = ( variations->axis[i].minimum +\n                    variations->axis[i].def     ) / 2;\n\n    if ( FT_Set_Var_Design_Coordinates( face,\n                                        FT_UInt( coords.size() ),\n                                        coords.data() ) )\n      return;\n  }\n\n\n// target function\n  sfnt_init_face( FT_Stream      stream,\n                  TT_Face        face,\n                  FT_Int         face_instance_index,\n                  FT_Int         num_params,\n                  FT_Parameter*  params )\n  {\n    FT_Error      error;\n    FT_Memory     memory = face->root.memory;\n    FT_Library    library = face->root.driver->root.library;\n    SFNT_Service  sfnt;\n    FT_Int        face_index;\n\n\n    /* for now, parameters are unused */\n    FT_UNUSED( num_params );\n    FT_UNUSED( params );\n\n\n    sfnt = (SFNT_Service)face->sfnt;\n    if ( !sfnt )\n    {\n      sfnt = (SFNT_Service)FT_Get_Module_Interface( library, \"sfnt\" );\n      if ( !sfnt )\n      {\n        FT_ERROR(( \"sfnt_init_face: cannot access `sfnt' module\\n\" ));\n        return FT_THROW( Missing_Module );\n      }\n\n      face->sfnt       = sfnt;\n      face->goto_table = sfnt->goto_table;\n    }\n\n    FT_FACE_FIND_GLOBAL_SERVICE( face, face->psnames, POSTSCRIPT_CMAPS );\n\n#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n    if ( !face->mm )\n    {\n      /* we want the MM interface from the `truetype' module only */\n      FT_Module  tt_module = FT_Get_Module( library, \"truetype\" );\n\n\n      face->mm = ft_module_get_service( tt_module,\n                                        FT_SERVICE_ID_MULTI_MASTERS,\n                                        0 );\n    }\n\n    if ( !face->var )\n    {\n      /* we want the metrics variations interface */\n      /* from the `truetype' module only          */\n      FT_Module  tt_module = FT_Get_Module( library, \"truetype\" );\n\n\n      face->var = ft_module_get_service( tt_module,\n                                         FT_SERVICE_ID_METRICS_VARIATIONS,\n                                         0 );\n    }\n#endif\n\n    FT_TRACE2(( \"SFNT driver\\n\" ));\n\n    error = sfnt_open_font( stream, face );\n    if ( error )\n      return error;\n\n    /* Stream may have changed in sfnt_open_font. */\n    stream = face->root.stream;\n\n    FT_TRACE2(( \"sfnt_init_face: %08p, %d\\n\", face, face_instance_index ));\n\n    face_index = FT_ABS( face_instance_index ) & 0xFFFF;\n\n    /* value -(N+1) requests information on index N */\n    if ( face_instance_index < 0 )\n      face_index--;\n\n    if ( face_index >= face->ttc_header.count )\n    {\n      if ( face_instance_index >= 0 )\n        return FT_THROW( Invalid_Argument );\n      else\n        face_index = 0;\n    }\n\n    if ( FT_STREAM_SEEK( face->ttc_header.offsets[face_index] ) )\n      return error;\n\n    /* check whether we have a valid TrueType file */\n    error = sfnt->load_font_dir( face, stream );\n    if ( error )\n      return error;\n\n#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n    {\n      FT_ULong  fvar_len;\n\n      FT_ULong  version;\n      FT_ULong  offset;\n\n      FT_UShort  num_axes;\n      FT_UShort  axis_size;\n      FT_UShort  num_instances;\n      FT_UShort  instance_size;\n\n      FT_Int  instance_index;\n\n      FT_Byte*  default_values  = NULL;\n      FT_Byte*  instance_values = NULL;\n\n\n      face->is_default_instance = 1;\n\n      instance_index = FT_ABS( face_instance_index ) >> 16;\n\n      /* test whether current face is a GX font with named instances */\n      if ( face->goto_table( face, TTAG_fvar, stream, &fvar_len ) ||\n           fvar_len < 20                                          ||\n           FT_READ_ULONG( version )                               ||\n           FT_READ_USHORT( offset )                               ||\n           FT_STREAM_SKIP( 2 ) /* reserved */                     ||\n           FT_READ_USHORT( num_axes )                             ||\n           FT_READ_USHORT( axis_size )                            ||\n           FT_READ_USHORT( num_instances )                        ||\n           FT_READ_USHORT( instance_size )                        )\n      {\n        version       = 0;\n        offset        = 0;\n        num_axes      = 0;\n        axis_size     = 0;\n        num_instances = 0;\n        instance_size = 0;\n      }\n\n      /* check that the data is bound by the table length */\n      if ( version != 0x00010000UL                    ||\n           axis_size != 20                            ||\n           num_axes == 0                              ||\n           /* `num_axes' limit implied by 16-bit `instance_size' */\n           num_axes > 0x3FFE                          ||\n           !( instance_size == 4 + 4 * num_axes ||\n              instance_size == 6 + 4 * num_axes )     ||\n           /* `num_instances' limit implied by limited range of name IDs */\n           num_instances > 0x7EFF                     ||\n           offset                          +\n             axis_size * num_axes          +\n             instance_size * num_instances > fvar_len )\n        num_instances = 0;\n      else\n        face->variation_support |= TT_FACE_FLAG_VAR_FVAR;\n\n      /* we don't support Multiple Master CFFs yet */\n      if ( !face->goto_table( face, TTAG_CFF, stream, 0 ) )\n        num_instances = 0;\n\n      /*\n       *  As documented in the OpenType specification, an entry for the\n       *  default instance may be omitted in the named instance table.  In\n       *  particular this means that even if there is no named instance\n       *  table in the font we actually do have a named instance, namely the\n       *  default instance.\n       *\n       *  For consistency, we always want the default instance in our list\n       *  of named instances.  If it is missing, we try to synthesize it\n       *  later on.  Here, we have to adjust `num_instances' accordingly.\n       */\n\n      if ( !( FT_ALLOC( default_values, num_axes * 2 )  ||\n              FT_ALLOC( instance_values, num_axes * 2 ) ) )\n      {\n        /* the current stream position is 16 bytes after the table start */\n        FT_ULong  array_start = FT_STREAM_POS() - 16 + offset;\n        FT_ULong  default_value_offset, instance_offset;\n\n        FT_Byte*  p;\n        FT_UInt   i;\n\n\n        default_value_offset = array_start + 8;\n        p                    = default_values;\n\n        for ( i = 0; i < num_axes; i++ )\n        {\n          (void)FT_STREAM_READ_AT( default_value_offset, p, 2 );\n\n          default_value_offset += axis_size;\n          p                    += 2;\n        }\n\n        instance_offset = array_start + axis_size * num_axes + 4;\n\n        for ( i = 0; i < num_instances; i++ )\n        {\n          (void)FT_STREAM_READ_AT( instance_offset,\n                                   instance_values,\n                                   num_axes * 2 );\n\n          if ( !ft_memcmp( default_values, instance_values, num_axes * 2 ) )\n            break;\n\n          instance_offset += instance_size;\n        }\n\n        if ( i == num_instances )\n        {\n          /* no default instance in named instance table; */\n          /* we thus have to synthesize it                */\n          num_instances++;\n        }\n      }\n\n      FT_FREE( default_values );\n      FT_FREE( instance_values );\n\n      /* instance indices in `face_instance_index' start with index 1, */\n      /* thus `>' and not `>='                                         */\n      if ( instance_index > num_instances )\n      {\n        if ( face_instance_index >= 0 )\n          return FT_THROW( Invalid_Argument );\n        else\n          num_instances = 0;\n      }\n\n      face->root.style_flags = (FT_Long)num_instances << 16;\n    }\n#endif\n\n    face->root.num_faces  = face->ttc_header.count;\n    face->root.face_index = face_instance_index;\n\n    return error;\n  }\n",
    "target": 1,
    "idx": 1000739,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "// context\nstatic int\nmyeid_create_key(struct sc_profile *profile, struct sc_pkcs15_card *p15card,\n\t\tstruct sc_pkcs15_object *object) {\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_card *card = p15card->card;\n\tstruct sc_pkcs15_prkey_info *prkey_info = (struct sc_pkcs15_prkey_info *) object->data;\n\tstruct sc_pkcs15_skey_info *skey_info = (struct sc_pkcs15_skey_info *) object->data;\n\tstruct sc_pkcs15_id *id;\n\tstruct sc_path *path;\n\tint *key_reference;\n\tstruct sc_file *file = NULL;\n\tstruct sc_pkcs15_object *pin_object = NULL;\n\tstruct sc_pkcs15_auth_info *pkcs15_auth_info = NULL;\n\tunsigned char sec_attrs[] = {0xFF, 0xFF, 0xFF};\n\tint r, ef_structure = 0, keybits = 0, pin_reference = -1;\n\tunsigned char prop_info[] = {0x00, 0x00};\n\tint extractable = FALSE;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tswitch (object->type) {\n\t\tcase SC_PKCS15_TYPE_PRKEY_RSA:\n\t\t\tef_structure = SC_CARDCTL_MYEID_KEY_RSA;\n\t\t\tkeybits = prkey_info->modulus_length;\n\t\t\tbreak;\n\t\tcase SC_PKCS15_TYPE_PRKEY_EC:\n\t\t\tef_structure = SC_CARDCTL_MYEID_KEY_EC;\n\t\t\tkeybits = prkey_info->field_length;\n\t\t\tbreak;\n\t\tcase SC_PKCS15_TYPE_SKEY_DES:\n\t\tcase SC_PKCS15_TYPE_SKEY_3DES:\n\t\t\tef_structure = SC_CARDCTL_MYEID_KEY_DES;\n\t\t\tkeybits = skey_info->value_len;\n\t\t\tif ((skey_info->access_flags & SC_PKCS15_PRKEY_ACCESS_EXTRACTABLE) == SC_PKCS15_PRKEY_ACCESS_EXTRACTABLE)\n\t\t\t\textractable = TRUE;\n\t\t\tbreak;\n\t\tcase SC_PKCS15_TYPE_SKEY_GENERIC:\n\t\t\tkeybits = skey_info->value_len;\n\t\t\tif ((skey_info->access_flags & SC_PKCS15_PRKEY_ACCESS_EXTRACTABLE) == SC_PKCS15_PRKEY_ACCESS_EXTRACTABLE)\n\t\t\t\textractable = TRUE;\n\t\t\tswitch (skey_info->key_type) {\n\t\t\tcase CKK_AES:\n\t\t\t\tef_structure = SC_CARDCTL_MYEID_KEY_AES;\n\t\t\t\tbreak;\n\t\t\tcase CKK_DES:\n\t\t\t\tef_structure = SC_CARDCTL_MYEID_KEY_DES;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (object->type == SC_PKCS15_TYPE_SKEY_GENERIC)\n\t\t\t\t\tef_structure = SC_CARDCTL_MYEID_KEY_GENERIC_SECRET;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t}\n\tif (!ef_structure) {\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS,\n\t\t\t\t\"Unsupported key type\");\n\t}\n\n\tmyeid_fixup_supported_algos(profile, p15card, object);\n\n\tif ((object->type & SC_PKCS15_TYPE_CLASS_MASK) == SC_PKCS15_TYPE_PRKEY) {\n\t\tid = &prkey_info->id;\n\t\tpath = &prkey_info->path;\n\t\tkey_reference = &prkey_info->key_reference;\n\t} else {\n\t\tid = &skey_info->id;\n\t\tpath = &skey_info->path;\n\t\tkey_reference = &skey_info->key_reference;\n\t}\n\n\tsc_log(ctx, \"create MyEID key ID:%s\", sc_pkcs15_print_id(id));\n\n\t/* Get the private key file */\n\tr = myeid_new_file(profile, card, object->type, *key_reference, &file);\n\tLOG_TEST_RET(ctx, r, \"Cannot get new MyEID key file\");\n\n\tif (!file || !file->path.len || file->path.len > SC_MAX_PATH_SIZE) {\n\t\tsc_file_free(file);\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, \"Cannot determine key file\");\n\t}\n\n\tsc_log(ctx, \"Key file size %d\", keybits);\n\tfile->size = keybits;\n\tfile->ef_structure = ef_structure;\n\n\tmemcpy(path->value, &file->path.value, file->path.len);\n\t*key_reference = file->path.value[file->path.len - 1] & 0xFF;\n\n\tsc_log(ctx, \"Path of MyEID key file to create %s\",\n\t\t\tsc_print_path(&file->path));\n\n\tif (object->auth_id.len >= 1) {\n\t\tr = sc_pkcs15_find_pin_by_auth_id(p15card, &object->auth_id, &pin_object);\n\n\t\tif (r != SC_SUCCESS)\n\t\t\tsc_file_free(file);\n\t\tLOG_TEST_RET(ctx, r, \"Failed to get pin object by auth_id\");\n\n\t\tif (pin_object->type != SC_PKCS15_TYPE_AUTH_PIN) {\n\t\t\tsc_file_free(file);\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_OBJECT_NOT_VALID, \"Invalid object returned when locating pin object.\");\n\t\t}\n\n\t\tpkcs15_auth_info =  (struct sc_pkcs15_auth_info*) pin_object->data;\n\n\t\tif (pkcs15_auth_info == NULL || pkcs15_auth_info->auth_type != SC_PKCS15_PIN_AUTH_TYPE_PIN) {\n\t\t\tsc_file_free(file);\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_OBJECT_NOT_VALID, \"NULL or invalid sc_pkcs15_auth_info in pin object\");\n\t\t}\n\n\t\tpin_reference = pkcs15_auth_info->attrs.pin.reference;\n\n\t\tif (pin_reference >= 1 && pin_reference < MYEID_MAX_PINS) {\n\t\t\tsec_attrs[0] = (pin_reference << 4 | (pin_reference & 0x0F));\n\t\t\tsec_attrs[1] = (pin_reference << 4 | (pin_reference & 0x0F));\n\t\t\tsc_file_set_sec_attr(file, sec_attrs, sizeof(sec_attrs));\n\t\t}\n\t}\n\telse {\n\t\tsc_file_free(file);\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, \"Invalid AuthID value for a private key.\");\n\t}\n\n\t/* TODO: fill all proprietary attributes here based on the object */\n\n\tif (object->user_consent != 0 && pin_reference >= 1)\n\t    prop_info[0] |= (pin_reference << 4);\n\n\tif (extractable)\n\t    prop_info[1] |= MYEID_PROP_INFO_2_EXCTRACTABLE;\n\n\tif (object->session_object != 0) /* Object will be removed during next reset. */\n\t\tprop_info[1] |= MYEID_PROP_INFO_2_SESSION_OBJECT;\n\n\t/* TODO: add other flags, like CKA_TRUSTED and CKA_WRAP_WITH_TRUSTED */\n\n\tr = sc_file_set_prop_attr(file, prop_info, 2);\n\tLOG_TEST_RET(ctx, r, \"Cannot create MyEID key file\");\n\n\t/* Now create the key file */\n\tr = sc_pkcs15init_create_file(profile, p15card, file);\n\tsc_file_free(file);\n\tLOG_TEST_RET(ctx, r, \"Cannot create MyEID key file\");\n\n\tLOG_FUNC_RETURN(ctx, r);\n}\n\nint\nsc_pkcs15init_store_secret_key(struct sc_pkcs15_card *p15card, struct sc_profile *profile,\n\t\tstruct sc_pkcs15init_skeyargs *keyargs, struct sc_pkcs15_object **res_obj)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_pkcs15_object *object = NULL;\n\tint r = 0;\n\n\tLOG_FUNC_CALLED(ctx);\n\n\t/* Now check whether the card is able to handle this key */\n\tif (check_key_compatibility(p15card, keyargs->algorithm, NULL, 0, keyargs->value_len, 0) != SC_SUCCESS) {\n\t\t/* Make sure the caller explicitly tells us to store\n\t\t * the key as extractable. */\n\t\tif (!(keyargs->access_flags & SC_PKCS15_PRKEY_ACCESS_EXTRACTABLE))\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_INCOMPATIBLE_KEY, \"Card does not support this key for crypto. Cannot store it as non extractable.\");\n\t}\n\n#ifdef ENABLE_OPENSSL\n\tif (!keyargs->id.len) {\n\t\t/* Calculating intrinsic Key ID for secret key does not make\n\t\t * sense - just generate random one */\n\t\tif (RAND_bytes(keyargs->id.value, 20) == 1)\n\t\t\tkeyargs->id.len = 20;\n\t}\n#endif\n\n\t/* Make sure that secret key's ID is the unique inside the PKCS#15 application */\n\tr = sc_pkcs15_find_skey_by_id(p15card, &keyargs->id, NULL);\n\tif (!r)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_NON_UNIQUE_ID, \"Non unique ID of the secret key object\");\n\telse if (r != SC_ERROR_OBJECT_NOT_FOUND)\n\t\tLOG_TEST_RET(ctx, r, \"Find secret key error\");\n\n\t/* Set up the SKDF object */\n\tr = sc_pkcs15init_init_skdf(p15card, profile, keyargs, &object);\n\tLOG_TEST_RET(ctx, r, \"Failed to initialize secret key object\");\n\n\tif (profile->ops->create_key)\n\t\tr = profile->ops->create_key(profile, p15card, object);\n\tLOG_TEST_GOTO_ERR(ctx, r, \"Card specific 'create key' failed\");\n\n\t/* If no key data, only an empty EF is created. \n\t * It can be used to receive an unwrapped key later. */\n\tif (keyargs->key.data_len > 0) {\n\t\tif (profile->ops->store_key) {\n\t\t\tstruct sc_pkcs15_prkey key;\n\t\t\tmemset(&key, 0, sizeof(key));\n\t\t\tkey.algorithm = keyargs->algorithm;\n\t\t\tkey.u.secret = keyargs->key;\n\t\t\tr = profile->ops->store_key(profile, p15card, object, &key);\n\t\t}\n\t}\n\tLOG_TEST_GOTO_ERR(ctx, r, \"Card specific 'store key' failed\");\n\n\tsc_pkcs15_free_object_content(object);\n\n\t/* Now update the SKDF, unless it is a session object.\n\t   If we have an on card session object, we have created the actual key object on card.\n\t   The card handles removing it when the session is finished or during the next reset.\n\t   We will maintain the object in the P15 structure in memory for duration of the session,\n\t   but we don't want it to be written into SKDF. */\n\tif (!object->session_object) {\n\t\tr = sc_pkcs15init_add_object(p15card, profile, SC_PKCS15_SKDF, object);\n\t\tLOG_TEST_GOTO_ERR(ctx, r, \"Failed to add new secret key PKCS#15 object\");\n\t}\n\n\tif (!r && profile->ops->emu_store_data && !object->session_object)   {\n\t\tr = profile->ops->emu_store_data(p15card, profile, object, NULL, NULL);\n\t\tif (r == SC_ERROR_NOT_IMPLEMENTED)\n\t\t\tr = SC_SUCCESS;\n\t\tLOG_TEST_GOTO_ERR(ctx, r, \"Card specific 'store data' failed\");\n\t}\n\n\tif (r >= 0 && res_obj)\n\t\t*res_obj = object;\n\tobject = NULL;\n\n\tprofile->dirty = 1;\n\nerr:\n\tsc_pkcs15_free_object(object);\n\tLOG_FUNC_RETURN(ctx, r);\n}\n\nvoid do_store_secret_key(struct sc_profile *profile, struct sc_pkcs15_card *p15card,\n                         sc_card_t *card, uint8_t *buf)\n{\n    struct sc_pkcs15init_skeyargs args;\n    int algorithms[] = { SC_ALGORITHM_AES, SC_ALGORITHM_DES, SC_ALGORITHM_3DES };\n    unsigned int keybits[] = { 128, 64, 192 };\n\n    memset(&args, 0, sizeof(args));\n    args.access_flags |= SC_PKCS15_PRKEY_ACCESS_EXTRACTABLE | SC_PKCS15_PRKEY_ACCESS_SENSITIVE;\n    args.usage |= SC_PKCS15_PRKEY_USAGE_ENCRYPT | SC_PKCS15_PRKEY_USAGE_DECRYPT;\n    sc_pkcs15_format_id(\"02\", &(args.auth_id));\n\n    for (int i = 0; i < 3; i++) {\n        size_t keybytes = (keybits[i] + 7) / 8;\n        args.key.data = malloc(keybytes);\n        memcpy(args.key.data, buf, keybytes);\n        args.key.data_len = keybytes;\n        args.algorithm = algorithms[i];\n        args.value_len = keybits[i];\n\n        sc_pkcs15init_store_secret_key(p15card, profile, &args, NULL);\n        if (args.key.data)\n            free(args.key.data);\n    }\n}\n\n\n// target function\nstatic int\nmyeid_new_file(sc_profile_t *profile, sc_card_t *card,\n\t\tunsigned int type, unsigned int num,\n\t\tsc_file_t **out) {\n\tsc_file_t *file;\n\tsc_path_t *p;\n\tchar name[64];\n\tconst char *tag = NULL;\n\tint r;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\tswitch (type) {\n\tcase SC_PKCS15_TYPE_PRKEY_RSA:\n\tcase SC_PKCS15_TYPE_PRKEY_EC:\n\t\ttag = \"private-key\";\n\t\tbreak;\n\tcase SC_PKCS15_TYPE_PUBKEY_RSA:\n\tcase SC_PKCS15_TYPE_PUBKEY_EC:\n\t\ttag = \"public-key\";\n\t\tbreak;\n\tcase SC_PKCS15_TYPE_SKEY_GENERIC:\n\tcase SC_PKCS15_TYPE_SKEY_DES:\n\tcase SC_PKCS15_TYPE_SKEY_3DES:\n\t\ttag = \"secret-key\";\n\t\tbreak;\n\tdefault:\n\t\tif ((type & SC_PKCS15_TYPE_CLASS_MASK) == SC_PKCS15_TYPE_CERT)\n\t\t\ttag = \"certificate\";\n\t\telse if ((type & SC_PKCS15_TYPE_CLASS_MASK) == SC_PKCS15_TYPE_DATA_OBJECT)\n\t\t\ttag = \"data\";\n\t\tbreak;\n\t}\n\n\tif (!tag) {\n\t\tsc_log(card->ctx, \"Unsupported file type\");\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\n\t/* Get template from profile  */\n\tsnprintf(name, sizeof (name), \"template-%s\", tag);\n\tif (sc_profile_get_file(profile, name, &file) < 0) {\n\t\tsc_log(card->ctx, \"Profile doesn't define %s\", name);\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t}\n\n\t/* Auto-increment FID for next object */\n\tfile->id += num;\n\tp = &file->path;\n\t*p = profile->df_info->file->path;\n\tp->value[p->len++] = (u8) (file->id / 256);\n\tp->value[p->len++] = (u8) (file->id % 256);\n\n\t/* Increment FID until there's no file with such path */\n\tr = sc_select_file(card, p, NULL);\n\twhile (r == 0) {\n\t\tfile->id++;\n\t\tp->value[p->len - 2] = (u8) (file->id / 256);\n\t\tp->value[p->len - 1] = (u8) (file->id % 256);\n\t\tr = sc_select_file(card, p, NULL);\n\t}\n\n\t*out = file;\n\tLOG_FUNC_RETURN(card->ctx, 0);\n}\nstatic int\nmyeid_create_key(struct sc_profile *profile, struct sc_pkcs15_card *p15card,\n\t\tstruct sc_pkcs15_object *object) {\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_card *card = p15card->card;\n\tstruct sc_pkcs15_prkey_info *prkey_info = (struct sc_pkcs15_prkey_info *) object->data;\n\tstruct sc_pkcs15_skey_info *skey_info = (struct sc_pkcs15_skey_info *) object->data;\n\tstruct sc_pkcs15_id *id;\n\tstruct sc_path *path;\n\tint *key_reference;\n\tstruct sc_file *file = NULL;\n\tstruct sc_pkcs15_object *pin_object = NULL;\n\tstruct sc_pkcs15_auth_info *pkcs15_auth_info = NULL;\n\tunsigned char sec_attrs[] = {0xFF, 0xFF, 0xFF};\n\tint r, ef_structure = 0, keybits = 0, pin_reference = -1;\n\tunsigned char prop_info[] = {0x00, 0x00};\n\tint extractable = FALSE;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tswitch (object->type) {\n\t\tcase SC_PKCS15_TYPE_PRKEY_RSA:\n\t\t\tef_structure = SC_CARDCTL_MYEID_KEY_RSA;\n\t\t\tkeybits = prkey_info->modulus_length;\n\t\t\tbreak;\n\t\tcase SC_PKCS15_TYPE_PRKEY_EC:\n\t\t\tef_structure = SC_CARDCTL_MYEID_KEY_EC;\n\t\t\tkeybits = prkey_info->field_length;\n\t\t\tbreak;\n\t\tcase SC_PKCS15_TYPE_SKEY_DES:\n\t\tcase SC_PKCS15_TYPE_SKEY_3DES:\n\t\t\tef_structure = SC_CARDCTL_MYEID_KEY_DES;\n\t\t\tkeybits = skey_info->value_len;\n\t\t\tif ((skey_info->access_flags & SC_PKCS15_PRKEY_ACCESS_EXTRACTABLE) == SC_PKCS15_PRKEY_ACCESS_EXTRACTABLE)\n\t\t\t\textractable = TRUE;\n\t\t\tbreak;\n\t\tcase SC_PKCS15_TYPE_SKEY_GENERIC:\n\t\t\tkeybits = skey_info->value_len;\n\t\t\tif ((skey_info->access_flags & SC_PKCS15_PRKEY_ACCESS_EXTRACTABLE) == SC_PKCS15_PRKEY_ACCESS_EXTRACTABLE)\n\t\t\t\textractable = TRUE;\n\t\t\tswitch (skey_info->key_type) {\n\t\t\tcase CKK_AES:\n\t\t\t\tef_structure = SC_CARDCTL_MYEID_KEY_AES;\n\t\t\t\tbreak;\n\t\t\tcase CKK_DES:\n\t\t\t\tef_structure = SC_CARDCTL_MYEID_KEY_DES;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (object->type == SC_PKCS15_TYPE_SKEY_GENERIC)\n\t\t\t\t\tef_structure = SC_CARDCTL_MYEID_KEY_GENERIC_SECRET;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t}\n\tif (!ef_structure) {\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS,\n\t\t\t\t\"Unsupported key type\");\n\t}\n\n\tmyeid_fixup_supported_algos(profile, p15card, object);\n\n\tif ((object->type & SC_PKCS15_TYPE_CLASS_MASK) == SC_PKCS15_TYPE_PRKEY) {\n\t\tid = &prkey_info->id;\n\t\tpath = &prkey_info->path;\n\t\tkey_reference = &prkey_info->key_reference;\n\t} else {\n\t\tid = &skey_info->id;\n\t\tpath = &skey_info->path;\n\t\tkey_reference = &skey_info->key_reference;\n\t}\n\n\tsc_log(ctx, \"create MyEID key ID:%s\", sc_pkcs15_print_id(id));\n\n\t/* Get the private key file */\n\tr = myeid_new_file(profile, card, object->type, *key_reference, &file);\n\tLOG_TEST_RET(ctx, r, \"Cannot get new MyEID key file\");\n\n\tif (!file || !file->path.len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, \"Cannot determine key file\");\n\n\tsc_log(ctx, \"Key file size %d\", keybits);\n\tfile->size = keybits;\n\tfile->ef_structure = ef_structure;\n\n\tmemcpy(path->value, &file->path.value, file->path.len);\n\t*key_reference = file->path.value[file->path.len - 1] & 0xFF;\n\n\tsc_log(ctx, \"Path of MyEID key file to create %s\",\n\t\t\tsc_print_path(&file->path));\n\n\tif (object->auth_id.len >= 1) {\n\t\tr = sc_pkcs15_find_pin_by_auth_id(p15card, &object->auth_id, &pin_object);\n\n\t\tif (r != SC_SUCCESS)\n\t\t\tsc_file_free(file);\n\t\tLOG_TEST_RET(ctx, r, \"Failed to get pin object by auth_id\");\n\n\t\tif (pin_object->type != SC_PKCS15_TYPE_AUTH_PIN) {\n\t\t\tsc_file_free(file);\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_OBJECT_NOT_VALID, \"Invalid object returned when locating pin object.\");\n\t\t}\n\n\t\tpkcs15_auth_info =  (struct sc_pkcs15_auth_info*) pin_object->data;\n\n\t\tif (pkcs15_auth_info == NULL || pkcs15_auth_info->auth_type != SC_PKCS15_PIN_AUTH_TYPE_PIN) {\n\t\t\tsc_file_free(file);\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_OBJECT_NOT_VALID, \"NULL or invalid sc_pkcs15_auth_info in pin object\");\n\t\t}\n\n\t\tpin_reference = pkcs15_auth_info->attrs.pin.reference;\n\n\t\tif (pin_reference >= 1 && pin_reference < MYEID_MAX_PINS) {\n\t\t\tsec_attrs[0] = (pin_reference << 4 | (pin_reference & 0x0F));\n\t\t\tsec_attrs[1] = (pin_reference << 4 | (pin_reference & 0x0F));\n\t\t\tsc_file_set_sec_attr(file, sec_attrs, sizeof(sec_attrs));\n\t\t}\n\t}\n\telse {\n\t\tsc_file_free(file);\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, \"Invalid AuthID value for a private key.\");\n\t}\n\n\t/* TODO: fill all proprietary attributes here based on the object */\n\n\tif (object->user_consent != 0 && pin_reference >= 1)\n\t    prop_info[0] |= (pin_reference << 4);\n\n\tif (extractable)\n\t    prop_info[1] |= MYEID_PROP_INFO_2_EXCTRACTABLE;\n\n\tif (object->session_object != 0) /* Object will be removed during next reset. */\n\t\tprop_info[1] |= MYEID_PROP_INFO_2_SESSION_OBJECT;\n\n\t/* TODO: add other flags, like CKA_TRUSTED and CKA_WRAP_WITH_TRUSTED */\n\n\tr = sc_file_set_prop_attr(file, prop_info, 2);\n\tLOG_TEST_RET(ctx, r, \"Cannot create MyEID key file\");\n\n\t/* Now create the key file */\n\tr = sc_pkcs15init_create_file(profile, p15card, file);\n\tsc_file_free(file);\n\tLOG_TEST_RET(ctx, r, \"Cannot create MyEID key file\");\n\n\tLOG_FUNC_RETURN(ctx, r);\n}\n",
    "target": 1,
    "idx": 1047769,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic int MqttClient_DecodePacket(MqttClient* client, byte* rx_buf,\n    word32 rx_len, void *packet_obj, MqttPacketType* ppacket_type,\n    MqttQoS* ppacket_qos, word16* ppacket_id)\n{\n    int rc = MQTT_CODE_SUCCESS;\n    MqttPacket* header;\n    MqttPacketType packet_type;\n    MqttQoS packet_qos;\n    word16 packet_id = 0;\n#ifdef WOLFMQTT_V5\n    MqttProp* props = NULL;\n#endif\n\n    /* must have rx buffer with at least 2 byes for header */\n    if (rx_buf == NULL || rx_len < MQTT_PACKET_HEADER_MIN_SIZE) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    /* Decode header */\n    header = (MqttPacket*)rx_buf;\n    packet_type = (MqttPacketType)MQTT_PACKET_TYPE_GET(header->type_flags);\n    if (ppacket_type) {\n        *ppacket_type = packet_type;\n    }\n    packet_qos = (MqttQoS)MQTT_PACKET_FLAGS_GET_QOS(header->type_flags);\n    if (ppacket_qos) {\n        *ppacket_qos = packet_qos;\n    }\n\n    /* Decode packet specific data (if requested) */\n    if (ppacket_id || packet_obj) {\n        switch (packet_type) {\n        case MQTT_PACKET_TYPE_CONNECT_ACK:\n        {\n            MqttConnectAck connect_ack, *p_connect_ack = &connect_ack;\n            if (packet_obj) {\n                p_connect_ack = (MqttConnectAck*)packet_obj;\n            }\n            else {\n                XMEMSET(p_connect_ack, 0, sizeof(MqttConnectAck));\n            }\n        #ifdef WOLFMQTT_V5\n            p_connect_ack->protocol_level = client->protocol_level;\n        #endif\n            rc = MqttDecode_ConnectAck(rx_buf, rx_len, p_connect_ack);\n        #ifdef WOLFMQTT_V5\n            if (rc >= 0) {\n                props = p_connect_ack->props;\n            }\n        #endif\n            break;\n        }\n        case MQTT_PACKET_TYPE_PUBLISH:\n        {\n            MqttPublish publish, *p_publish = &publish;\n            if (packet_obj) {\n                p_publish = (MqttPublish*)packet_obj;\n            }\n            else {\n                XMEMSET(p_publish, 0, sizeof(MqttPublish));\n            }\n        #ifdef WOLFMQTT_V5\n            p_publish->protocol_level = client->protocol_level;\n        #endif\n            rc = MqttDecode_Publish(rx_buf, rx_len, p_publish);\n            if (rc >= 0) {\n                packet_id = p_publish->packet_id;\n            #ifdef WOLFMQTT_V5\n                props = p_publish->props;\n            #endif\n            }\n            break;\n        }\n        case MQTT_PACKET_TYPE_PUBLISH_ACK:\n        case MQTT_PACKET_TYPE_PUBLISH_REC:\n        case MQTT_PACKET_TYPE_PUBLISH_REL:\n        case MQTT_PACKET_TYPE_PUBLISH_COMP:\n        {\n            MqttPublishResp publish_resp, *p_publish_resp = &publish_resp;\n            if (packet_obj) {\n                p_publish_resp = (MqttPublishResp*)packet_obj;\n            }\n            else {\n                XMEMSET(p_publish_resp, 0, sizeof(MqttPublishResp));\n            }\n        #ifdef WOLFMQTT_V5\n                p_publish_resp->protocol_level = client->protocol_level;\n        #endif\n                rc = MqttDecode_PublishResp(rx_buf, rx_len, packet_type,\n                p_publish_resp);\n            if (rc >= 0) {\n                packet_id = p_publish_resp->packet_id;\n            #ifdef WOLFMQTT_V5\n                props = p_publish_resp->props;\n            #endif\n            }\n            break;\n        }\n        case MQTT_PACKET_TYPE_SUBSCRIBE_ACK:\n        {\n            MqttSubscribeAck subscribe_ack, *p_subscribe_ack = &subscribe_ack;\n            if (packet_obj) {\n                p_subscribe_ack = (MqttSubscribeAck*)packet_obj;\n            }\n            else {\n                XMEMSET(p_subscribe_ack, 0, sizeof(MqttSubscribeAck));\n            }\n        #ifdef WOLFMQTT_V5\n            p_subscribe_ack->protocol_level = client->protocol_level;\n        #endif\n            rc = MqttDecode_SubscribeAck(rx_buf, rx_len, p_subscribe_ack);\n            if (rc >= 0) {\n                packet_id = p_subscribe_ack->packet_id;\n            #ifdef WOLFMQTT_V5\n                props = p_subscribe_ack->props;\n            #endif\n            }\n            break;\n        }\n        case MQTT_PACKET_TYPE_UNSUBSCRIBE_ACK:\n        {\n            MqttUnsubscribeAck unsubscribe_ack,\n                               *p_unsubscribe_ack = &unsubscribe_ack;\n            if (packet_obj) {\n                p_unsubscribe_ack = (MqttUnsubscribeAck*)packet_obj;\n            }\n            else {\n                XMEMSET(p_unsubscribe_ack, 0, sizeof(MqttUnsubscribeAck));\n            }\n        #ifdef WOLFMQTT_V5\n            p_unsubscribe_ack->protocol_level = client->protocol_level;\n        #endif\n            rc = MqttDecode_UnsubscribeAck(rx_buf, rx_len, p_unsubscribe_ack);\n            if (rc >= 0) {\n                packet_id = p_unsubscribe_ack->packet_id;\n            #ifdef WOLFMQTT_V5\n                props = p_unsubscribe_ack->props;\n            #endif\n            }\n            break;\n        }\n        case MQTT_PACKET_TYPE_PING_RESP:\n        {\n            MqttPing ping, *p_ping = &ping;\n            if (packet_obj) {\n                p_ping = (MqttPing*)packet_obj;\n            }\n            else {\n                XMEMSET(p_ping, 0, sizeof(MqttPing));\n            }\n            rc = MqttDecode_Ping(rx_buf, rx_len, p_ping);\n            break;\n        }\n        case MQTT_PACKET_TYPE_AUTH:\n        {\n        #ifdef WOLFMQTT_V5\n            MqttAuth auth, *p_auth = &auth;\n            if (packet_obj) {\n                p_auth = (MqttAuth*)packet_obj;\n            }\n            else {\n                XMEMSET(p_auth, 0, sizeof(MqttAuth));\n            }\n            rc = MqttDecode_Auth(rx_buf, rx_len, p_auth);\n            if (rc >= 0) {\n                props = p_auth->props;\n            }\n        #else\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n        #endif /* WOLFMQTT_V5 */\n            break;\n        }\n        case MQTT_PACKET_TYPE_DISCONNECT:\n        {\n        #ifdef WOLFMQTT_V5\n            MqttDisconnect disc, *p_disc = &disc;\n            if (packet_obj) {\n                p_disc = (MqttDisconnect*)packet_obj;\n            }\n            else {\n                XMEMSET(p_disc, 0, sizeof(MqttDisconnect));\n            }\n            rc = MqttDecode_Disconnect(rx_buf, rx_len, p_disc);\n            if (rc >= 0) {\n                props = p_disc->props;\n            }\n        #else\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n        #endif /* WOLFMQTT_V5 */\n            break;\n        }\n        case MQTT_PACKET_TYPE_CONNECT:\n        case MQTT_PACKET_TYPE_SUBSCRIBE:\n        case MQTT_PACKET_TYPE_UNSUBSCRIBE:\n        case MQTT_PACKET_TYPE_PING_REQ:\n        case MQTT_PACKET_TYPE_ANY:\n        case MQTT_PACKET_TYPE_RESERVED:\n        default:\n            /* these type are only encoded by client */\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n            break;\n        } /* switch (packet_type) */\n    }\n\n    if (ppacket_id) {\n        *ppacket_id = packet_id;\n    }\n\n#ifdef WOLFMQTT_V5\n    if (props) {\n    #ifdef WOLFMQTT_PROPERTY_CB\n        /* Check for properties set by the server */\n        if (packet_obj && client->property_cb) {\n            /* capture error if returned */\n            int rc_err = client->property_cb(client, props,\n                    client->property_ctx);\n            if (rc_err < 0) {\n                rc = rc_err;\n            }\n        }\n    #endif\n        /* Free the properties */\n        MqttProps_Free(props);\n    }\n#endif\n\n    (void)client;\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"MqttClient_DecodePacket: Rc %d, Len %d, Type %s (%d), ID %d,\"\n            \" QoS %d\",\n        rc, rx_len, MqttPacket_TypeDesc(packet_type), packet_type, packet_id,\n        packet_qos);\n#endif\n\n    return rc;\n}\n\nstatic int MqttClient_WaitType(MqttClient *client, void *packet_obj,\n    byte wait_type, word16 wait_packet_id, int timeout_ms)\n{\n    int rc;\n    word16 packet_id;\n    MqttPacketType packet_type;\n#ifdef WOLFMQTT_MULTITHREAD\n    MqttPendResp *pendResp;\n    int readLocked;\n#endif\n    MqttMsgStat* mms_stat;\n    int waitMatchFound;\n\n    if (client == NULL || packet_obj == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    /* all packet type structures must have MqttMsgStat at top */\n    mms_stat = (MqttMsgStat*)packet_obj;\n\nwait_again:\n\n    /* initialize variables */\n    packet_id = 0;\n    packet_type = MQTT_PACKET_TYPE_RESERVED;\n#ifdef WOLFMQTT_MULTITHREAD\n    pendResp = NULL;\n    readLocked = 0;\n#endif\n    waitMatchFound = 0;\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"MqttClient_WaitType: Type %s (%d), ID %d\",\n        MqttPacket_TypeDesc((MqttPacketType)wait_type),\n            wait_type, wait_packet_id);\n#endif\n\n    switch ((int)*mms_stat)\n    {\n        case MQTT_MSG_BEGIN:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Lock recv socket mutex */\n            rc = wm_SemLock(&client->lockRecv);\n            if (rc != 0) {\n                PRINTF(\"MqttClient_WaitType: recv lock error!\");\n                return rc;\n            }\n            readLocked = 1;\n        #endif\n\n            /* reset the packet state */\n            client->packet.stat = MQTT_PK_BEGIN;\n        }\n        FALL_THROUGH;\n\n    #ifdef WOLFMQTT_V5\n        case MQTT_MSG_AUTH:\n    #endif\n        case MQTT_MSG_WAIT:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if packet type and id have already completed */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, (MqttPacketType)wait_type, \n                    wait_packet_id, &pendResp)) {\n                    if (pendResp->packetDone) {\n                        /* pending response is already done, so return */\n                        rc = pendResp->packet_ret;\n                    #ifdef WOLFMQTT_DEBUG_CLIENT\n                        PRINTF(\"PendResp already Done %p: Rc %d\", pendResp, rc);\n                    #endif\n                        MqttClient_RespList_Remove(client, pendResp);\n                        wm_SemUnlock(&client->lockClient);\n                        wm_SemUnlock(&client->lockRecv);\n                        return rc;\n                    }\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            *mms_stat = MQTT_MSG_WAIT;\n\n            /* Wait for packet */\n            rc = MqttPacket_Read(client, client->rx_buf, client->rx_buf_len,\n                    timeout_ms);\n            /* handle failure */\n            if (rc <= 0) {\n                break;\n            }\n\n            /* capture length read */\n            client->packet.buf_len = rc;\n\n            /* Decode Packet - get type and id */\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, NULL, &packet_type, NULL, &packet_id);\n            if (rc < 0) {\n                break;\n            }\n\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"Read Packet: Len %d, Type %d, ID %d\",\n                client->packet.buf_len, packet_type, packet_id);\n        #endif\n\n            *mms_stat = MQTT_MSG_READ;\n        }\n        FALL_THROUGH;\n\n        case MQTT_MSG_READ:\n        case MQTT_MSG_READ_PAYLOAD:\n        {\n            MqttPacketType use_packet_type;\n            void* use_packet_obj;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            readLocked = 1; /* if in this state read is locked */\n        #endif\n\n            /* read payload state only happens for publish messages */\n            if (*mms_stat == MQTT_MSG_READ_PAYLOAD) {\n                packet_type = MQTT_PACKET_TYPE_PUBLISH;\n            }\n\n            /* Determine if we received data for this request */\n            if ((wait_type == MQTT_PACKET_TYPE_ANY ||\n                 wait_type == packet_type ||\n                 (MqttIsPubRespPacket(packet_type) &&\n                  MqttIsPubRespPacket(wait_type))) &&\n                (wait_packet_id == 0 || wait_packet_id == packet_id))\n            {\n                use_packet_obj = packet_obj;\n                waitMatchFound = 1;\n            }\n            else {\n                /* use generic packet object */\n                use_packet_obj = &client->msg;\n            }\n            use_packet_type = packet_type;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if we have a pending response for this packet */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, packet_type, packet_id,\n                                                               &pendResp)) {\n                    /* we found packet match this incoming read packet */\n                    pendResp->packetProcessing = 1;\n                    use_packet_obj = pendResp->packet_obj;\n                    use_packet_type = pendResp->packet_type;\n                    /* req from another thread... not a match */\n                    waitMatchFound = 0;\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            /* Perform packet handling for publish callback and QoS */\n            rc = MqttClient_HandlePacket(client, use_packet_type,\n                use_packet_obj, timeout_ms);\n\n        #ifdef WOLFMQTT_NONBLOCK\n            if (rc == MQTT_CODE_CONTINUE) {\n                /* we have received some data, so keep the recv\n                    mutex lock active and return */\n                return rc;\n            }\n        #endif\n\n            /* handle success case */\n            if (rc >= 0) {\n                rc = MQTT_CODE_SUCCESS;\n            }\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (pendResp) {\n                /* Mark pending response entry done */\n                if (wm_SemLock(&client->lockClient) == 0) {\n                    pendResp->packetDone = 1;\n                    pendResp->packet_ret = rc;\n                #ifdef WOLFMQTT_DEBUG_CLIENT\n                    PRINTF(\"PendResp Done %p\", pendResp);\n                #endif\n                    pendResp = NULL;\n                    wm_SemUnlock(&client->lockClient);\n                }\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n            break;\n        }\n\n        case MQTT_MSG_WRITE:\n        case MQTT_MSG_WRITE_PAYLOAD:\n        default:\n        {\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"MqttClient_WaitType: Invalid state %d!\", *mms_stat);\n        #endif\n            rc = MQTT_CODE_ERROR_STAT;\n            break;\n        }\n    } /* switch (*mms_stat) */\n\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc != MQTT_CODE_CONTINUE)\n#endif\n    {\n        /* reset state */\n        *mms_stat = MQTT_MSG_BEGIN;\n    }\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (readLocked) {\n        wm_SemUnlock(&client->lockRecv);\n    }\n#endif\n    if (rc < 0) {\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_WaitType: Failure: %s (%d)\",\n            MqttClient_ReturnCodeToString(rc), rc);\n    #endif\n        return rc;\n    }\n\n    if (!waitMatchFound) {\n        /* if we get here, then the we are still waiting for a packet */\n        goto wait_again;\n    }\n\n    return rc;\n}\n\nint MqttClient_Connect(MqttClient *client, MqttConnect *mc_connect)\n{\n    int rc, len = 0;\n\n    /* Validate required arguments */\n    if (client == NULL || mc_connect == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    if (mc_connect->stat == MQTT_MSG_BEGIN) {\n    #ifdef WOLFMQTT_MULTITHREAD\n        /* Lock send socket mutex */\n        rc = wm_SemLock(&client->lockSend);\n        if (rc != 0) {\n            return rc;\n        }\n    #endif\n\n    #ifdef WOLFMQTT_V5\n        /* Use specified protocol version if set */\n        mc_connect->protocol_level = client->protocol_level;\n    #endif\n\n        /* Encode the connect packet */\n        rc = MqttEncode_Connect(client->tx_buf, client->tx_buf_len, mc_connect);\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d), ID %d, QoS %d\",\n            rc, MqttPacket_TypeDesc(MQTT_PACKET_TYPE_CONNECT),\n            MQTT_PACKET_TYPE_CONNECT, 0, 0);\n    #endif\n        if (rc <= 0) {\n            #ifdef WOLFMQTT_MULTITHREAD\n                wm_SemUnlock(&client->lockSend);\n            #endif\n            return rc;\n        }\n        len = rc;\n\n    #ifdef WOLFMQTT_MULTITHREAD\n        rc = wm_SemLock(&client->lockClient);\n        if (rc == 0) {\n            /* inform other threads of expected response */\n            rc = MqttClient_RespList_Add(client, MQTT_PACKET_TYPE_CONNECT_ACK,\n                    0, &mc_connect->pendResp, &mc_connect->ack);\n            wm_SemUnlock(&client->lockClient);\n        }\n        if (rc != 0) {\n            wm_SemUnlock(&client->lockSend);\n            return rc; /* Error locking client */\n        }\n    #endif\n\n        /* Send connect packet */\n        rc = MqttPacket_Write(client, client->tx_buf, len);\n    #ifdef WOLFMQTT_MULTITHREAD\n        wm_SemUnlock(&client->lockSend);\n    #endif\n        if (rc != len) {\n    #ifdef WOLFMQTT_MULTITHREAD\n            if ((rc != MQTT_CODE_CONTINUE) &&\n                (wm_SemLock(&client->lockClient)) == 0) {\n                MqttClient_RespList_Remove(client, &mc_connect->pendResp);\n                wm_SemUnlock(&client->lockClient);\n            }\n    #endif\n            return rc;\n        }\n    #ifdef WOLFMQTT_V5\n        /* Enhanced authentication */\n        if (client->enable_eauth == 1) {\n            mc_connect->stat = MQTT_MSG_AUTH;\n        }\n        else\n    #endif\n        {\n            mc_connect->stat = MQTT_MSG_WAIT;\n        }\n    }\n\n#ifdef WOLFMQTT_V5\n    /* Enhanced authentication */\n    if (mc_connect->protocol_level > MQTT_CONNECT_PROTOCOL_LEVEL_4 && \n            mc_connect->stat == MQTT_MSG_AUTH)\n    {\n        MqttAuth auth, *p_auth = &auth;\n        MqttProp* prop, *conn_prop;\n\n        /* Find the AUTH property in the connect structure */\n        for (conn_prop = mc_connect->props;\n             (conn_prop != NULL) && (conn_prop->type != MQTT_PROP_AUTH_METHOD);\n             conn_prop = conn_prop->next) {\n        }\n        if (conn_prop == NULL) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (wm_SemLock(&client->lockClient) == 0) {\n                MqttClient_RespList_Remove(client, &mc_connect->pendResp);\n                wm_SemUnlock(&client->lockClient);\n            }\n        #endif\n            /* AUTH property was not set in connect structure */\n            return MQTT_CODE_ERROR_BAD_ARG;\n        }\n\n        XMEMSET((void*)p_auth, 0, sizeof(MqttAuth));\n\n        /* Set the authentication reason */\n        p_auth->reason_code = MQTT_REASON_CONT_AUTH;\n\n        /* Use the same authentication method property from connect */\n        prop = MqttProps_Add(&p_auth->props);\n        prop->type = MQTT_PROP_AUTH_METHOD;\n        prop->data_str.str = conn_prop->data_str.str;\n        prop->data_str.len = conn_prop->data_str.len;\n\n        /* Send the AUTH packet */\n        rc = MqttClient_Auth(client, p_auth);\n        MqttClient_PropsFree(p_auth->props);\n    #ifdef WOLFMQTT_NONBLOCK\n        if (rc == MQTT_CODE_CONTINUE)\n            return rc;\n    #endif\n        if (rc != len) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (wm_SemLock(&client->lockClient) == 0) {\n                MqttClient_RespList_Remove(client, &mc_connect->pendResp);\n                wm_SemUnlock(&client->lockClient);\n            }\n        #endif\n            return rc;\n        }\n    }\n#endif /* WOLFMQTT_V5 */\n\n    /* Wait for connect ack packet */\n    rc = MqttClient_WaitType(client, &mc_connect->ack,\n        MQTT_PACKET_TYPE_CONNECT_ACK, 0, client->cmd_timeout_ms);\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc == MQTT_CODE_CONTINUE)\n        return rc;\n#endif\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (wm_SemLock(&client->lockClient) == 0) {\n        MqttClient_RespList_Remove(client, &mc_connect->pendResp);\n        wm_SemUnlock(&client->lockClient);\n    }\n#endif\n\n    /* reset state */\n    mc_connect->stat = MQTT_MSG_BEGIN;\n\n    return rc;\n}\n\nbool wolfMQTTFuzzer::Initialize(void) {\n    bool ret = false;\n    MqttMessage* lwt_msg = nullptr;\n\n    try {\n        /* net */\n        {\n            memset(net, 0, sizeof(*net));\n\n            net->connect = mqtt_connect;\n            net->read = mqtt_recv;\n            net->write = mqtt_write;\n            net->disconnect = mqtt_disconnect;\n            net->context = this;\n        }\n\n        /* client */\n        {\n            memset(client, 0, sizeof(*client));\n\n            tx_size = ds.Get<uint16_t>();\n            tx_size = 4096;\n            tx_buf = (uint8_t*)this->malloc(tx_size);\n            rx_size = ds.Get<uint16_t>();\n            rx_size = 4096;\n            rx_buf = (uint8_t*)this->malloc(rx_size);\n            memset(tx_buf, 0, tx_size);\n            memset(rx_buf, 0, rx_size);\n\n            client->msg_cb = mqtt_message_cb;\n            client->tx_buf = tx_buf;\n            client->tx_buf_len = tx_size;\n            client->rx_buf = rx_buf;\n            client->rx_buf_len = rx_size;\n            client->cmd_timeout_ms = 1000;\n        }\n\n        /* connect */\n        {\n            memset(connect, 0, sizeof(*connect));\n\n            connect->keep_alive_sec = 1;\n            connect->clean_session = ds.Get<bool>() ? 1 : 0;\n            client_id = ds.Get<std::string>();\n            connect->client_id = client_id.c_str();\n            connect->enable_lwt = ds.Get<bool>() ? 1 : 0;\n        }\n            \n        std::string lwt_topic_name;\n        std::vector<uint8_t> lwt_buffer;\n\n        if ( connect->enable_lwt ) {\n            lwt_topic_name = ds.Get<std::string>();\n            lwt_buffer = ds.GetData(0);\n\n            lwt_msg = new MqttMessage;\n            memset(lwt_msg, 0, sizeof(*lwt_msg));\n\n            connect->lwt_msg = lwt_msg;\n            lwt_msg->qos = GetQoS();\n            lwt_msg->retain = ds.Get<bool>() ? 1 : 0;\n            lwt_msg->topic_name = lwt_topic_name.c_str();\n            lwt_msg->buffer = lwt_buffer.data();\n            lwt_msg->total_len = lwt_buffer.size();\n        }\n\n        CHECK_EQ(MqttSocket_Init(client, net), MQTT_CODE_SUCCESS);\n\n#if 0\n        if ( ds.Get<bool>() ) {\n            //CHECK_EQ(MqttClient_SetPropertyCallback(&client, mqtt_property_cb, NULL);\n        }\n#endif\n\n        CHECK_EQ(MqttClient_NetConnect(client, \"dummy\", 12345, 1000, 0, NULL), MQTT_CODE_SUCCESS);\n        CHECK_EQ(MqttClient_Connect(client, connect), MQTT_CODE_SUCCESS);\n\n        ret = true;\n    } catch ( ... ) {\n        ret = false;\n    }\n\nend:\n    if ( lwt_msg ) {\n        delete lwt_msg;\n    }\n    return ret;\n}\n\n\n// target function\nstatic int MqttClient_WaitType(MqttClient *client, void *packet_obj,\n    byte wait_type, word16 wait_packet_id, int timeout_ms)\n{\n    int rc;\n    word16 packet_id;\n    MqttPacketType packet_type;\n#ifdef WOLFMQTT_MULTITHREAD\n    MqttPendResp *pendResp;\n    int readLocked;\n#endif\n    MqttMsgStat* mms_stat;\n    int waitMatchFound;\n\n    if (client == NULL || packet_obj == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    /* all packet type structures must have MqttMsgStat at top */\n    mms_stat = (MqttMsgStat*)packet_obj;\n\nwait_again:\n\n    /* initialize variables */\n    packet_id = 0;\n    packet_type = MQTT_PACKET_TYPE_RESERVED;\n#ifdef WOLFMQTT_MULTITHREAD\n    pendResp = NULL;\n    readLocked = 0;\n#endif\n    waitMatchFound = 0;\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"MqttClient_WaitType: Type %s (%d), ID %d\",\n        MqttPacket_TypeDesc((MqttPacketType)wait_type),\n            wait_type, wait_packet_id);\n#endif\n\n    switch ((int)*mms_stat)\n    {\n        case MQTT_MSG_BEGIN:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Lock recv socket mutex */\n            rc = wm_SemLock(&client->lockRecv);\n            if (rc != 0) {\n                PRINTF(\"MqttClient_WaitType: recv lock error!\");\n                return rc;\n            }\n            readLocked = 1;\n        #endif\n\n            /* reset the packet state */\n            client->packet.stat = MQTT_PK_BEGIN;\n        }\n        FALL_THROUGH;\n\n    #ifdef WOLFMQTT_V5\n        case MQTT_MSG_AUTH:\n    #endif\n        case MQTT_MSG_WAIT:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if packet type and id have already completed */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, (MqttPacketType)wait_type, \n                    wait_packet_id, &pendResp)) {\n                    if (pendResp->packetDone) {\n                        /* pending response is already done, so return */\n                        rc = pendResp->packet_ret;\n                    #ifdef WOLFMQTT_DEBUG_CLIENT\n                        PRINTF(\"PendResp already Done %p: Rc %d\", pendResp, rc);\n                    #endif\n                        MqttClient_RespList_Remove(client, pendResp);\n                        wm_SemUnlock(&client->lockClient);\n                        wm_SemUnlock(&client->lockRecv);\n                        return rc;\n                    }\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            *mms_stat = MQTT_MSG_WAIT;\n\n            /* Wait for packet */\n            rc = MqttPacket_Read(client, client->rx_buf, client->rx_buf_len,\n                    timeout_ms);\n            /* handle failure */\n            if (rc <= 0) {\n                break;\n            }\n\n            /* capture length read */\n            client->packet.buf_len = rc;\n\n            /* Decode Packet - get type and id */\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, NULL, &packet_type, NULL, &packet_id);\n            if (rc < 0) {\n                break;\n            }\n\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"Read Packet: Len %d, Type %d, ID %d\",\n                client->packet.buf_len, packet_type, packet_id);\n        #endif\n\n            *mms_stat = MQTT_MSG_READ;\n        }\n        FALL_THROUGH;\n\n        case MQTT_MSG_READ:\n        case MQTT_MSG_READ_PAYLOAD:\n        {\n            MqttPacketType use_packet_type;\n            void* use_packet_obj;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            readLocked = 1; /* if in this state read is locked */\n        #endif\n\n            /* read payload state only happens for publish messages */\n            if (*mms_stat == MQTT_MSG_READ_PAYLOAD) {\n                packet_type = MQTT_PACKET_TYPE_PUBLISH;\n            }\n\n            /* Determine if we received data for this request */\n            if ((wait_type == MQTT_PACKET_TYPE_ANY ||\n                 wait_type == packet_type ||\n                 MqttIsPubRespPacket(packet_type) == MqttIsPubRespPacket(wait_type)) &&\n               (wait_packet_id == 0 || wait_packet_id == packet_id))\n            {\n                use_packet_obj = packet_obj;\n                waitMatchFound = 1;\n            }\n            else {\n                /* use generic packet object */\n                use_packet_obj = &client->msg;\n            }\n            use_packet_type = packet_type;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if we have a pending response for this packet */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, packet_type, packet_id,\n                                                               &pendResp)) {\n                    /* we found packet match this incoming read packet */\n                    pendResp->packetProcessing = 1;\n                    use_packet_obj = pendResp->packet_obj;\n                    use_packet_type = pendResp->packet_type;\n                    /* req from another thread... not a match */\n                    waitMatchFound = 0;\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            /* Perform packet handling for publish callback and QoS */\n            rc = MqttClient_HandlePacket(client, use_packet_type,\n                use_packet_obj, timeout_ms);\n\n        #ifdef WOLFMQTT_NONBLOCK\n            if (rc == MQTT_CODE_CONTINUE) {\n                /* we have received some data, so keep the recv\n                    mutex lock active and return */\n                return rc;\n            }\n        #endif\n\n            /* handle success case */\n            if (rc >= 0) {\n                rc = MQTT_CODE_SUCCESS;\n            }\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (pendResp) {\n                /* Mark pending response entry done */\n                if (wm_SemLock(&client->lockClient) == 0) {\n                    pendResp->packetDone = 1;\n                    pendResp->packet_ret = rc;\n                #ifdef WOLFMQTT_DEBUG_CLIENT\n                    PRINTF(\"PendResp Done %p\", pendResp);\n                #endif\n                    pendResp = NULL;\n                    wm_SemUnlock(&client->lockClient);\n                }\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n            break;\n        }\n\n        case MQTT_MSG_WRITE:\n        case MQTT_MSG_WRITE_PAYLOAD:\n        default:\n        {\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"MqttClient_WaitType: Invalid state %d!\", *mms_stat);\n        #endif\n            rc = MQTT_CODE_ERROR_STAT;\n            break;\n        }\n    } /* switch (*mms_stat) */\n\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc != MQTT_CODE_CONTINUE)\n#endif\n    {\n        /* reset state */\n        *mms_stat = MQTT_MSG_BEGIN;\n    }\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (readLocked) {\n        wm_SemUnlock(&client->lockRecv);\n    }\n#endif\n    if (rc < 0) {\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_WaitType: Failure: %s (%d)\",\n            MqttClient_ReturnCodeToString(rc), rc);\n    #endif\n        return rc;\n    }\n\n    if (!waitMatchFound) {\n        /* if we get here, then the we are still waiting for a packet */\n        goto wait_again;\n    }\n\n    return rc;\n}\n",
    "target": 1,
    "idx": 1039083,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "// context\n\n\n\n\nKGzipFilter::Result KGzipFilter::uncompress()\n{\n#ifndef NDEBUG\n    if (d->mode == 0) {\n        //qCWarning(KArchiveLog) << \"mode==0; KGzipFilter::init was not called!\";\n        return KFilterBase::Error;\n    } else if (d->mode == QIODevice::WriteOnly) {\n        //qCWarning(KArchiveLog) << \"uncompress called but the filter was opened for writing!\";\n        return KFilterBase::Error;\n    }\n    Q_ASSERT(d->mode == QIODevice::ReadOnly);\n#endif\n\n    if (!d->compressed) {\n        return uncompress_noop();\n    }\n\n#ifdef DEBUG_GZIP\n    qCDebug(KArchiveLog) << \"Calling inflate with avail_in=\" << inBufferAvailable() << \" avail_out=\" << outBufferAvailable();\n    qCDebug(KArchiveLog) << \"    next_in=\" << d->zStream.next_in;\n#endif\n\n    while (d->zStream.avail_in > 0) {\n        int result = inflate(&d->zStream, Z_SYNC_FLUSH);\n\n#ifdef DEBUG_GZIP\n        qCDebug(KArchiveLog) << \" -> inflate returned \" << result;\n        qCDebug(KArchiveLog) << \" now avail_in=\" << inBufferAvailable() << \" avail_out=\" << outBufferAvailable();\n        qCDebug(KArchiveLog) << \"     next_in=\" << d->zStream.next_in;\n#endif\n\n        if (result == Z_OK) {\n            return KFilterBase::Ok;\n        }\n\n        // We can't handle any other results\n        if (result != Z_STREAM_END) {\n            return KFilterBase::Error;\n        }\n\n        // It really was the end\n        if (d->zStream.avail_in == 0) {\n            return KFilterBase::End;\n        }\n\n        // Store before resetting\n        Bytef *data = d->zStream.next_in; // This is increased appropriately by zlib beforehand\n        uInt size = d->zStream.avail_in;\n\n        // Reset the stream, if that fails we assume we're at the end\n        if (!init(d->mode)) {\n            return KFilterBase::End;\n        }\n\n        // Reset the data to where we left off\n        d->zStream.next_in = data;\n        d->zStream.avail_in = size;\n    }\n\n    return KFilterBase::End;\n}\n\nqint64 KCompressionDevice::readData(char *data, qint64 maxlen)\n{\n    Q_ASSERT(d->filter->mode() == QIODevice::ReadOnly);\n    //qCDebug(KArchiveLog) << \"maxlen=\" << maxlen;\n    KFilterBase *filter = d->filter;\n\n    uint dataReceived = 0;\n\n    // We came to the end of the stream\n    if (d->result == KFilterBase::End) {\n        return dataReceived;\n    }\n\n    // If we had an error, return -1.\n    if (d->result != KFilterBase::Ok) {\n        return -1;\n    }\n\n    qint64 availOut = maxlen;\n    filter->setOutBuffer(data, maxlen);\n\n    while (dataReceived < maxlen) {\n        if (filter->inBufferEmpty()) {\n            // Not sure about the best size to set there.\n            // For sure, it should be bigger than the header size (see comment in readHeader)\n            d->buffer.resize(BUFFER_SIZE);\n            // Request data from underlying device\n            int size = filter->device()->read(d->buffer.data(),\n                                              d->buffer.size());\n            //qCDebug(KArchiveLog) << \"got\" << size << \"bytes from device\";\n            if (size) {\n                filter->setInBuffer(d->buffer.data(), size);\n            } else {\n                // Not enough data available in underlying device for now\n                break;\n            }\n        }\n        if (d->bNeedHeader) {\n            (void) filter->readHeader();\n            d->bNeedHeader = false;\n        }\n\n        d->result = filter->uncompress();\n\n        if (d->result == KFilterBase::Error) {\n            //qCWarning(KArchiveLog) << \"KCompressionDevice: Error when uncompressing data\";\n            break;\n        }\n\n        // We got that much data since the last time we went here\n        uint outReceived = availOut - filter->outBufferAvailable();\n        //qCDebug(KArchiveLog) << \"avail_out = \" << filter->outBufferAvailable() << \" result=\" << d->result << \" outReceived=\" << outReceived;\n        if (availOut < uint(filter->outBufferAvailable())) {\n            //qCWarning(KArchiveLog) << \" last availOut \" << availOut << \" smaller than new avail_out=\" << filter->outBufferAvailable() << \" !\";\n        }\n\n        dataReceived += outReceived;\n        data += outReceived;\n        availOut = maxlen - dataReceived;\n        if (d->result == KFilterBase::End) {\n            // We're actually at the end, no more data to check\n            if (filter->device()->atEnd()) {\n                break;\n            }\n\n            // Still not done, re-init and try again\n            filter->init(filter->mode());\n        }\n        filter->setOutBuffer(data, availOut);\n    }\n\n    d->deviceReadPos += dataReceived;\n    return dataReceived;\n}\n\nQByteArray QIODevice::read(qint64 maxSize)\n{\n    Q_D(QIODevice);\n    QByteArray result;\n\n#if defined QIODEVICE_DEBUG\n    printf(\"%p QIODevice::read(%lld), d->pos = %lld, d->buffer.size() = %lld\\n\",\n           this, maxSize, d->pos, d->buffer.size());\n#endif\n\n    // Try to prevent the data from being copied, if we have a chunk\n    // with the same size in the read buffer.\n    if (maxSize == d->buffer.nextDataBlockSize() && !d->transactionStarted\n        && (d->openMode & (QIODevice::ReadOnly | QIODevice::Text)) == QIODevice::ReadOnly) {\n        result = d->buffer.read();\n        if (!d->isSequential())\n            d->pos += maxSize;\n        if (d->buffer.isEmpty())\n            readData(nullptr, 0);\n        return result;\n    }\n\n    CHECK_MAXLEN(read, result);\n    CHECK_MAXBYTEARRAYSIZE(read);\n\n    result.resize(int(maxSize));\n    qint64 readBytes = read(result.data(), result.size());\n\n    if (readBytes <= 0)\n        result.clear();\n    else\n        result.resize(int(readBytes));\n\n    return result;\n}\n\nbool KCompressionDevice::seek(qint64 pos)\n{\n    if (d->deviceReadPos == pos) {\n        return QIODevice::seek(pos);\n    }\n\n    //qCDebug(KArchiveLog) << \"seek(\" << pos << \") called, current pos=\" << QIODevice::pos();\n\n    Q_ASSERT(d->filter->mode() == QIODevice::ReadOnly);\n\n    if (pos == 0) {\n        if (!QIODevice::seek(pos))\n            return false;\n\n        // We can forget about the cached data\n        d->bNeedHeader = !d->bSkipHeaders;\n        d->result = KFilterBase::Ok;\n        d->filter->setInBuffer(nullptr, 0);\n        d->filter->reset();\n        d->deviceReadPos = 0;\n        return d->filter->device()->reset();\n    }\n\n    qint64 bytesToRead;\n    if (d->deviceReadPos < pos) { // we can start from here\n        bytesToRead = pos - d->deviceReadPos;\n        // Since we're going to do a read() below\n        // we need to reset the internal QIODevice pos to the real position we are\n        // so that after read() we are indeed pointing to the pos seek\n        // asked us to be in\n        if (!QIODevice::seek(d->deviceReadPos)) {\n            return false;\n        }\n    } else {\n        // we have to start from 0 ! Ugly and slow, but better than the previous\n        // solution (KTarGz was allocating everything into memory)\n        if (!seek(0)) { // recursive\n            return false;\n        }\n        bytesToRead = pos;\n    }\n\n    //qCDebug(KArchiveLog) << \"reading \" << bytesToRead << \" dummy bytes\";\n    QByteArray dummy(qMin(bytesToRead, qint64(SEEK_BUFFER_SIZE)), 0);\n    while (bytesToRead > 0) {\n        const qint64 bytesToReadThisTime = qMin(bytesToRead, qint64(dummy.size()));\n        const bool result = (read(dummy.data(), bytesToReadThisTime) == bytesToReadThisTime);\n        if (!result) {\n            return false;\n        }\n        bytesToRead -= bytesToReadThisTime;\n    }\n    return true;\n}\n\nbool KTar::openArchive(QIODevice::OpenMode mode)\n{\n\n    if (!(mode & QIODevice::ReadOnly)) {\n        return true;\n    }\n\n    if (!d->fillTempFile(fileName())) {\n        return false;\n    }\n\n    // We'll use the permission and user/group of d->rootDir\n    // for any directory we emulate (see findOrCreate)\n    //struct stat buf;\n    //stat( fileName(), &buf );\n\n    d->dirList.clear();\n    QIODevice *dev = device();\n\n    if (!dev) {\n        setErrorString(tr(\"Could not get underlying device\"));\n        qCWarning(KArchiveLog) << \"Could not get underlying device\";\n        return false;\n    }\n\n    // read dir information\n    char buffer[0x200];\n    bool ende = false;\n    do {\n        QString name;\n        QString symlink;\n\n        // Read header\n        qint64 n = d->readHeader(buffer, name, symlink);\n        if (n < 0) {\n            setErrorString(tr(\"Could not read tar header\"));\n            return false;\n        }\n        if (n == 0x200) {\n            bool isdir = false;\n\n            if (name.isEmpty()) {\n                continue;\n            }\n            if (name.endsWith(QLatin1Char('/'))) {\n                isdir = true;\n                name.truncate(name.length() - 1);\n            }\n\n            QByteArray prefix = QByteArray(buffer + 0x159, 155);\n            if (prefix[0] != '\\0') {\n                name = (QString::fromLatin1(prefix.constData()) + QLatin1Char('/') +  name);\n            }\n\n            int pos = name.lastIndexOf(QLatin1Char('/'));\n            QString nm = (pos == -1) ? name : name.mid(pos + 1);\n\n            // read access\n            buffer[0x6b] = 0;\n            char *dummy;\n            const char *p = buffer + 0x64;\n            while (*p == ' ') {\n                ++p;\n            }\n            int access = strtol(p, &dummy, 8);\n\n            // read user and group\n            const int maxUserGroupLength = 32;\n            const char *userStart = buffer + 0x109;\n            const int userLen = qstrnlen(userStart, maxUserGroupLength);\n            const QString user = QString::fromLocal8Bit(userStart, userLen);\n            const char *groupStart = buffer + 0x129;\n            const int groupLen = qstrnlen(groupStart, maxUserGroupLength);\n            const QString group = QString::fromLocal8Bit(groupStart, groupLen);\n\n            // read time\n            buffer[0x93] = 0;\n            p = buffer + 0x88;\n            while (*p == ' ') {\n                ++p;\n            }\n            uint time = strtol(p, &dummy, 8);\n\n            // read type flag\n            char typeflag = buffer[0x9c];\n            // '0' for files, '1' hard link, '2' symlink, '5' for directory\n            // (and 'L' for longlink fileNames, 'K' for longlink symlink targets)\n            // 'D' for GNU tar extension DUMPDIR, 'x' for Extended header referring\n            // to the next file in the archive and 'g' for Global extended header\n\n            if (typeflag == '5') {\n                isdir = true;\n            }\n\n            bool isDumpDir = false;\n            if (typeflag == 'D') {\n                isdir = false;\n                isDumpDir = true;\n            }\n            //qCDebug(KArchiveLog) << nm << \"isdir=\" << isdir << \"pos=\" << dev->pos() << \"typeflag=\" << typeflag << \" islink=\" << ( typeflag == '1' || typeflag == '2' );\n\n            if (typeflag == 'x' || typeflag == 'g') { // pax extended header, or pax global extended header\n                // Skip it for now. TODO: implement reading of extended header, as per http://pubs.opengroup.org/onlinepubs/009695399/utilities/pax.html\n                (void)dev->read(buffer, 0x200);\n                continue;\n            }\n\n            if (isdir) {\n                access |= S_IFDIR;    // f*cking broken tar files\n            }\n\n            KArchiveEntry *e;\n            if (isdir) {\n                //qCDebug(KArchiveLog) << \"directory\" << nm;\n                e = new KArchiveDirectory(this, nm, access, KArchivePrivate::time_tToDateTime(time), user, group, symlink);\n            } else {\n                // read size\n                QByteArray sizeBuffer(buffer + 0x7c, 12);\n                qint64 size = sizeBuffer.trimmed().toLongLong(nullptr, 8 /*octal*/);\n                //qCDebug(KArchiveLog) << \"sizeBuffer='\" << sizeBuffer << \"' -> size=\" << size;\n\n                // for isDumpDir we will skip the additional info about that dirs contents\n                if (isDumpDir) {\n                    //qCDebug(KArchiveLog) << nm << \"isDumpDir\";\n                    e = new KArchiveDirectory(this, nm, access, KArchivePrivate::time_tToDateTime(time), user, group, symlink);\n                } else {\n\n                    // Let's hack around hard links. Our classes don't support that, so make them symlinks\n                    if (typeflag == '1') {\n                        //qCDebug(KArchiveLog) << \"Hard link, setting size to 0 instead of\" << size;\n                        size = 0; // no contents\n                    }\n\n                    //qCDebug(KArchiveLog) << \"file\" << nm << \"size=\" << size;\n                    e = new KArchiveFile(this, nm, access, KArchivePrivate::time_tToDateTime(time), user, group, symlink,\n                                         dev->pos(), size);\n                }\n\n                // Skip contents + align bytes\n                qint64 rest = size % 0x200;\n                qint64 skip = size + (rest ? 0x200 - rest : 0);\n                //qCDebug(KArchiveLog) << \"pos()=\" << dev->pos() << \"rest=\" << rest << \"skipping\" << skip;\n                if (! dev->seek(dev->pos() + skip)) {\n                    //qCWarning(KArchiveLog) << \"skipping\" << skip << \"failed\";\n                }\n            }\n\n            if (pos == -1) {\n                if (nm == QLatin1String(\".\")) { // special case\n                    Q_ASSERT(isdir);\n                    if (isdir) {\n                        setRootDir(static_cast<KArchiveDirectory *>(e));\n                    } else {\n                        delete e;\n                    }\n                } else {\n                    rootDir()->addEntry(e);\n                }\n            } else {\n                // In some tar files we can find dir/./file => call cleanPath\n                QString path = QDir::cleanPath(name.left(pos));\n                // Ensure container directory exists, create otherwise\n                KArchiveDirectory *d = findOrCreate(path);\n                if (d) {\n                    d->addEntry(e);\n                } else {\n                    delete e;\n                    return false;\n                }\n            }\n        } else {\n            //qCDebug(KArchiveLog) << \"Terminating. Read \" << n << \" bytes, first one is \" << buffer[0];\n            d->tarEnd = dev->pos() - n; // Remember end of archive\n            ende = true;\n        }\n    } while (!ende);\n    return true;\n}\n\nbool KArchive::open(QIODevice::OpenMode mode)\n{\n    Q_ASSERT(mode != QIODevice::NotOpen);\n\n    if (isOpen()) {\n        close();\n    }\n\n    if (!d->fileName.isEmpty()) {\n        Q_ASSERT(!d->dev);\n        if (!createDevice(mode)) {\n            return false;\n        }\n    }\n\n    if (!d->dev) {\n        setErrorString(tr(\"No filename or device was specified\"));\n        return false;\n    }\n\n    if (!d->dev->isOpen() && !d->dev->open(mode)) {\n        setErrorString(tr(\"Could not set device mode to %1\").arg(mode));\n        return false;\n    }\n\n    d->mode = mode;\n\n    Q_ASSERT(!d->rootDir);\n    d->rootDir = nullptr;\n\n    return openArchive(mode);\n}\n\n\n// target function\nvoid KCompressionDeviceTest::testSeekReadUncompressedBuffer()\n{\n    const int dataSize = BUFFER_SIZE + BUFFER_SIZE / 2;\n    QByteArray ba(dataSize, 0);\n\n    // all data is zero except after BUFFER_SIZE that it's 0 to 9\n    for (int i = 0; i < 10; ++i) {\n        ba[BUFFER_SIZE + i] = i;\n    }\n\n    QBuffer b;\n    b.setData(ba);\n    QVERIFY(b.open(QIODevice::ReadOnly));\n\n    KCompressionDevice kcd(&b, false, KCompressionDevice::GZip);\n    QVERIFY(kcd.open(QIODevice::ReadOnly));\n    QVERIFY(kcd.seek(BUFFER_SIZE));\n\n    // the 10 bytes after BUFFER_SIZE should be 0 to 9\n    const QByteArray kcdData = kcd.read(10);\n    QCOMPARE(kcdData.size(), 10);\n    for (int i = 0; i < kcdData.size(); ++i) {\n        QCOMPARE(kcdData[i], i);\n    }\n}\nbool KCompressionDevice::seek(qint64 pos)\n{\n    if (d->deviceReadPos == pos) {\n        return QIODevice::seek(pos);\n    }\n\n    //qCDebug(KArchiveLog) << \"seek(\" << pos << \") called, current pos=\" << QIODevice::pos();\n\n    Q_ASSERT(d->filter->mode() == QIODevice::ReadOnly);\n\n    if (pos == 0) {\n        if (!QIODevice::seek(pos))\n            return false;\n\n        // We can forget about the cached data\n        d->bNeedHeader = !d->bSkipHeaders;\n        d->result = KFilterBase::Ok;\n        d->filter->setInBuffer(nullptr, 0);\n        d->filter->reset();\n        d->deviceReadPos = 0;\n        return d->filter->device()->reset();\n    }\n\n    qint64 bytesToRead;\n    if (d->deviceReadPos < pos) { // we can start from here\n        bytesToRead = pos - d->deviceReadPos;\n        // Since we're going to do a read() below\n        // we need to reset the internal QIODevice pos to the real position we are\n        // so that after read() we are indeed pointing to the pos seek\n        // asked us to be in\n        if (!QIODevice::seek(d->deviceReadPos)) {\n            return false;\n        }\n    } else {\n        // we have to start from 0 ! Ugly and slow, but better than the previous\n        // solution (KTarGz was allocating everything into memory)\n        if (!seek(0)) { // recursive\n            return false;\n        }\n        bytesToRead = pos;\n    }\n\n    //qCDebug(KArchiveLog) << \"reading \" << bytesToRead << \" dummy bytes\";\n    QByteArray dummy(qMin(bytesToRead, qint64(3 * BUFFER_SIZE)), 0);\n    const bool result = (read(dummy.data(), bytesToRead) == bytesToRead);\n    return result;\n}\nbool KCompressionDevice::atEnd() const\n{\n    return (d->type == KCompressionDevice::None || d->result == KFilterBase::End)\n           && QIODevice::atEnd() // take QIODevice's internal buffer into account\n           && d->filter->device()->atEnd();\n}\n",
    "target": 1,
    "idx": 1014960,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "// context\nstatic inline void _sw32(void* dest, int32_t a) {\n  uint8_t* dest_ = (uint8_t*)dest;\n  uint8_t* pa = (uint8_t*)&a;\n\n  bool little_endian = is_little_endian();\n  if (little_endian) {\n    *(int32_t *)dest_ = a;\n  }\n  else {\n#if defined (__GNUC__)\n    *(int32_t *)dest_ = __builtin_bswap32(*(unsigned int *)pa);\n#elif defined (_MSC_VER) /* Visual Studio */\n    *(int32_t *)dest_ = _byteswap_ulong(*(unsigned int *)pa);\n#else\n    dest_[0] = pa[3];\n    dest_[1] = pa[2];\n    dest_[2] = pa[1];\n    dest_[3] = pa[0];\n#endif\n  }\n}\n\nstatic int serial_blosc(struct thread_context* thread_context) {\n  blosc2_context* context = thread_context->parent_context;\n  int32_t j, bsize, leftoverblock;\n  int32_t cbytes;\n  int32_t ntbytes = (int32_t)context->output_bytes;\n  int32_t* bstarts = context->bstarts;\n  uint8_t* tmp = thread_context->tmp;\n  uint8_t* tmp2 = thread_context->tmp2;\n  int dict_training = context->use_dict && (context->dict_cdict == NULL);\n  bool memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;\n  if (!context->do_compress && context->special_type) {\n    // Fake a runlen as if it was a memcpyed chunk\n    memcpyed = true;\n  }\n\n  for (j = 0; j < context->nblocks; j++) {\n    if (context->do_compress && !memcpyed && !dict_training) {\n      _sw32(bstarts + j, ntbytes);\n    }\n    bsize = context->blocksize;\n    leftoverblock = 0;\n    if ((j == context->nblocks - 1) && (context->leftover > 0)) {\n      bsize = context->leftover;\n      leftoverblock = 1;\n    }\n    if (context->do_compress) {\n      if (memcpyed && !context->prefilter) {\n        /* We want to memcpy only */\n        memcpy(context->dest + context->header_overhead + j * context->blocksize,\n               context->src + j * context->blocksize, (unsigned int)bsize);\n        cbytes = (int32_t)bsize;\n      }\n      else {\n        /* Regular compression */\n        cbytes = blosc_c(thread_context, bsize, leftoverblock, ntbytes,\n                         context->destsize, context->src, j * context->blocksize,\n                         context->dest + ntbytes, tmp, tmp2);\n        if (cbytes == 0) {\n          ntbytes = 0;              /* uncompressible data */\n          break;\n        }\n      }\n    }\n    else {\n      /* Regular decompression */\n      // If memcpyed we don't have a bstarts section (because it is not needed)\n      int32_t src_offset = memcpyed ?\n          context->header_overhead + j * context->blocksize : sw32_(bstarts + j);\n      cbytes = blosc_d(thread_context, bsize, leftoverblock, memcpyed,\n                       context->src, context->srcsize, src_offset, j,\n                       context->dest, j * context->blocksize, tmp, tmp2);\n    }\n\n    if (cbytes < 0) {\n      ntbytes = cbytes;         /* error in blosc_c or blosc_d */\n      break;\n    }\n    ntbytes += cbytes;\n  }\n\n  return ntbytes;\n}\n\nstatic int do_job(blosc2_context* context) {\n  int32_t ntbytes;\n\n  /* Set sentinels */\n  context->dref_not_init = 1;\n\n  /* Check whether we need to restart threads */\n  check_nthreads(context);\n\n  /* Run the serial version when nthreads is 1 or when the buffers are\n     not larger than blocksize */\n  if (context->nthreads == 1 || (context->sourcesize / context->blocksize) <= 1) {\n    /* The context for this 'thread' has no been initialized yet */\n    if (context->serial_context == NULL) {\n      context->serial_context = create_thread_context(context, 0);\n    }\n    else if (context->blocksize != context->serial_context->tmp_blocksize) {\n      free_thread_context(context->serial_context);\n      context->serial_context = create_thread_context(context, 0);\n    }\n    BLOSC_ERROR_NULL(context->serial_context, BLOSC2_ERROR_THREAD_CREATE);\n    ntbytes = serial_blosc(context->serial_context);\n  }\n  else {\n    ntbytes = parallel_blosc(context);\n  }\n\n  return ntbytes;\n}\n\nint blosc_compress_context(blosc2_context* context) {\n  int ntbytes = 0;\n  blosc_timestamp_t last, current;\n  bool memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;\n\n  blosc_set_timestamp(&last);\n\n  if (!memcpyed) {\n    /* Do the actual compression */\n    ntbytes = do_job(context);\n    if (ntbytes < 0) {\n      return ntbytes;\n    }\n    if (ntbytes == 0) {\n      // Try out with a memcpy later on (last chance for fitting src buffer in dest).\n      context->header_flags |= (uint8_t)BLOSC_MEMCPYED;\n      memcpyed = true;\n    }\n  }\n\n  int dont_split = (context->header_flags & 0x10) >> 4;\n  int nstreams = context->nblocks;\n  if (!dont_split) {\n    // When splitting, the number of streams is computed differently\n    if (context->leftover) {\n      nstreams = (context->nblocks - 1) * context->typesize + 1;\n    }\n    else {\n      nstreams *= context->typesize;\n    }\n  }\n\n  if (memcpyed) {\n    if (context->sourcesize + context->header_overhead > context->destsize) {\n      /* We are exceeding maximum output size */\n      ntbytes = 0;\n    }\n    else {\n      context->output_bytes = context->header_overhead;\n      ntbytes = do_job(context);\n      if (ntbytes < 0) {\n        return ntbytes;\n      }\n      // Success!  update the memcpy bit in header\n      context->dest[BLOSC2_CHUNK_FLAGS] = context->header_flags;\n      // and clear the memcpy bit in context (for next reuse)\n      context->header_flags &= ~(uint8_t)BLOSC_MEMCPYED;\n    }\n  }\n  else {\n    // Check whether we have a run for the whole chunk\n    int start_csizes = context->header_overhead + 4 * context->nblocks;\n    if (ntbytes == (int)(start_csizes + nstreams * sizeof(int32_t))) {\n      // The streams are all zero runs (by construction).  Encode it...\n      context->dest[BLOSC2_CHUNK_BLOSC2_FLAGS] |= BLOSC2_SPECIAL_ZERO << 4;\n      // ...and assign the new chunk length\n      ntbytes = context->header_overhead;\n    }\n  }\n\n  /* Set the number of compressed bytes in header */\n  _sw32(context->dest + BLOSC2_CHUNK_CBYTES, ntbytes);\n  if (context->blosc2_flags & BLOSC2_INSTR_CODEC) {\n    dont_split = (context->header_flags & 0x10) >> 4;\n    int32_t blocksize = dont_split ? (int32_t)sizeof(blosc2_instr) : (int32_t)sizeof(blosc2_instr) * context->typesize;\n    _sw32(context->dest + BLOSC2_CHUNK_NBYTES, nstreams * (int32_t)sizeof(blosc2_instr));\n    _sw32(context->dest + BLOSC2_CHUNK_BLOCKSIZE, blocksize);\n  }\n\n  /* Set the number of bytes in dest buffer (might be useful for btune) */\n  context->destsize = ntbytes;\n\n  if (context->btune != NULL) {\n    blosc_set_timestamp(&current);\n    double ctime = blosc_elapsed_secs(last, current);\n    context->udbtune->btune_update(context, ctime);\n  }\n\n  return ntbytes;\n}\n\nint blosc2_compress_ctx(blosc2_context* context, const void* src, int32_t srcsize,\n                        void* dest, int32_t destsize) {\n  int error, cbytes;\n\n  if (context->do_compress != 1) {\n    BLOSC_TRACE_ERROR(\"Context is not meant for compression.  Giving up.\");\n    return BLOSC2_ERROR_INVALID_PARAM;\n  }\n\n  error = initialize_context_compression(\n    context, src, srcsize, dest, destsize,\n    context->clevel, context->filters, context->filters_meta,\n    context->typesize, context->compcode, context->blocksize,\n    context->new_nthreads, context->nthreads, context->splitmode,\n    context->udbtune, context->btune, context->schunk);\n  if (error <= 0) {\n    return error;\n  }\n\n  /* Write the extended header */\n  error = write_compression_header(context, true);\n  if (error < 0) {\n    return error;\n  }\n\n  cbytes = blosc_compress_context(context);\n  if (cbytes < 0) {\n    return cbytes;\n  }\n\n  if (context->use_dict && context->dict_cdict == NULL) {\n\n    if (context->compcode != BLOSC_ZSTD) {\n      const char* compname;\n      compname = clibcode_to_clibname(context->compcode);\n      BLOSC_TRACE_ERROR(\"Codec %s does not support dicts.  Giving up.\",\n                        compname);\n      return BLOSC2_ERROR_CODEC_DICT;\n    }\n\n#ifdef HAVE_ZSTD\n    // Build the dictionary out of the filters outcome and compress with it\n    int32_t dict_maxsize = BLOSC2_MAXDICTSIZE;\n    // Do not make the dict more than 5% larger than uncompressed buffer\n    if (dict_maxsize > srcsize / 20) {\n      dict_maxsize = srcsize / 20;\n    }\n    void* samples_buffer = context->dest + context->header_overhead;\n    unsigned nblocks = 8;  // the minimum that accepts zstd as of 1.4.0\n    unsigned sample_fraction = 1;  // 1 allows to use most of the chunk for training\n    size_t sample_size = context->sourcesize / nblocks / sample_fraction;\n\n    // Populate the samples sizes for training the dictionary\n    size_t* samples_sizes = malloc(nblocks * sizeof(void*));\n    BLOSC_ERROR_NULL(samples_sizes, BLOSC2_ERROR_MEMORY_ALLOC);\n    for (size_t i = 0; i < nblocks; i++) {\n      samples_sizes[i] = sample_size;\n    }\n\n    // Train from samples\n    void* dict_buffer = malloc(dict_maxsize);\n    BLOSC_ERROR_NULL(dict_buffer, BLOSC2_ERROR_MEMORY_ALLOC);\n    int32_t dict_actual_size = (int32_t)ZDICT_trainFromBuffer(dict_buffer, dict_maxsize, samples_buffer, samples_sizes, nblocks);\n\n    // TODO: experiment with parameters of low-level fast cover algorithm\n    // Note that this API is still unstable.  See: https://github.com/facebook/zstd/issues/1599\n    // ZDICT_fastCover_params_t fast_cover_params;\n    // memset(&fast_cover_params, 0, sizeof(fast_cover_params));\n    // fast_cover_params.d = nblocks;\n    // fast_cover_params.steps = 4;\n    // fast_cover_params.zParams.compressionLevel = context->clevel;\n    //size_t dict_actual_size = ZDICT_optimizeTrainFromBuffer_fastCover(dict_buffer, dict_maxsize, samples_buffer, samples_sizes, nblocks, &fast_cover_params);\n\n    if (ZDICT_isError(dict_actual_size) != ZSTD_error_no_error) {\n      BLOSC_TRACE_ERROR(\"Error in ZDICT_trainFromBuffer(): '%s'.\"\n                        \"  Giving up.\", ZDICT_getErrorName(dict_actual_size));\n      return BLOSC2_ERROR_CODEC_DICT;\n    }\n    assert(dict_actual_size > 0);\n    free(samples_sizes);\n\n    // Update bytes counter and pointers to bstarts for the new compressed buffer\n    context->bstarts = (int32_t*)(context->dest + context->header_overhead);\n    context->output_bytes = context->header_overhead + (int32_t)sizeof(int32_t) * context->nblocks;\n    /* Write the size of trained dict at the end of bstarts */\n    _sw32(context->dest + context->output_bytes, (int32_t)dict_actual_size);\n    context->output_bytes += sizeof(int32_t);\n    /* Write the trained dict afterwards */\n    context->dict_buffer = context->dest + context->output_bytes;\n    memcpy(context->dict_buffer, dict_buffer, (unsigned int)dict_actual_size);\n    context->dict_cdict = ZSTD_createCDict(dict_buffer, dict_actual_size, 1);  // TODO: use get_accel()\n    free(dict_buffer);      // the dictionary is copied in the header now\n    context->output_bytes += (int32_t)dict_actual_size;\n    context->dict_size = dict_actual_size;\n\n    /* Compress with dict */\n    cbytes = blosc_compress_context(context);\n\n    // Invalidate the dictionary for compressing other chunks using the same context\n    context->dict_buffer = NULL;\n    ZSTD_freeCDict(context->dict_cdict);\n    context->dict_cdict = NULL;\n#endif  // HAVE_ZSTD\n  }\n\n  return cbytes;\n}\n\nint64_t blosc2_schunk_append_buffer(blosc2_schunk *schunk, void *src, int32_t nbytes) {\n  uint8_t* chunk = malloc(nbytes + BLOSC2_MAX_OVERHEAD);\n  schunk->current_nchunk = schunk->nchunks;\n  /* Compress the src buffer using super-chunk context */\n  int cbytes = blosc2_compress_ctx(schunk->cctx, src, nbytes, chunk,\n                                   nbytes + BLOSC2_MAX_OVERHEAD);\n  if (cbytes < 0) {\n    free(chunk);\n    return cbytes;\n  }\n  // We don't need a copy of the chunk, as it will be shrunk if necessary\n  int64_t nchunks = blosc2_schunk_append_chunk(schunk, chunk, false);\n  if (nchunks < 0) {\n    BLOSC_TRACE_ERROR(\"Error appending a buffer in super-chunk\");\n    return nchunks;\n  }\n\n  return nchunks;\n}\n\n\n// target function\nstatic int write_compression_header(blosc2_context* context, bool extended_header) {\n  blosc_header header;\n  int dont_split;\n  int dict_training = context->use_dict && (context->dict_cdict == NULL);\n\n  context->header_flags = 0;\n\n  if (context->clevel == 0) {\n    /* Compression level 0 means buffer to be memcpy'ed */\n    context->header_flags |= (uint8_t)BLOSC_MEMCPYED;\n  }\n\n  bool memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;\n  if (extended_header) {\n    /* Indicate that we are building an extended header */\n    context->header_overhead = BLOSC_EXTENDED_HEADER_LENGTH;\n    context->header_flags |= (BLOSC_DOSHUFFLE | BLOSC_DOBITSHUFFLE);\n    /* Store filter pipeline info at the end of the header */\n    if (dict_training || memcpyed) {\n      context->bstarts = NULL;\n      context->output_bytes = context->header_overhead;\n    } else {\n      context->bstarts = (int32_t*)(context->dest + context->header_overhead);\n      context->output_bytes = context->header_overhead + (int32_t)sizeof(int32_t) * context->nblocks;\n    }\n  } else {\n    // Regular header\n    context->header_overhead = BLOSC_MIN_HEADER_LENGTH;\n    if (memcpyed) {\n      context->bstarts = NULL;\n      context->output_bytes = context->header_overhead;\n    } else {\n      context->bstarts = (int32_t *) (context->dest + context->header_overhead);\n      context->output_bytes = context->header_overhead + (int32_t)sizeof(int32_t) * context->nblocks;\n    }\n  }\n\n  // when memcpyed bit is set, there is no point in dealing with others\n  if (!memcpyed) {\n    if (context->filter_flags & BLOSC_DOSHUFFLE) {\n      /* Byte-shuffle is active */\n      context->header_flags |= BLOSC_DOSHUFFLE;\n    }\n\n    if (context->filter_flags & BLOSC_DOBITSHUFFLE) {\n      /* Bit-shuffle is active */\n      context->header_flags |= BLOSC_DOBITSHUFFLE;\n    }\n\n    if (context->filter_flags & BLOSC_DODELTA) {\n      /* Delta is active */\n      context->header_flags |= BLOSC_DODELTA;\n    }\n\n    dont_split = !split_block(context, context->typesize,\n                              context->blocksize);\n\n    /* dont_split is in bit 4 */\n    context->header_flags |= dont_split << 4;\n    /* codec starts at bit 5 */\n    uint8_t compformat = compcode_to_compformat(context->compcode);\n    context->header_flags |= compformat << 5;\n  }\n\n  // Create blosc header and store to dest\n  blosc2_intialize_header_from_context(context, &header, extended_header);\n\n  memcpy(context->dest, &header, (extended_header) ?\n    BLOSC_EXTENDED_HEADER_LENGTH : BLOSC_MIN_HEADER_LENGTH);\n\n  return 1;\n}\nint main(void) {\n  int64_t *_src;\n  char *result;\n  size_t i;\n\n  blosc2_init();\n  blosc1_set_compressor(\"blosclz\");\n\n  /* Initialize buffers */\n  src = blosc_test_malloc(BUFFER_ALIGN_SIZE, size);\n  srccpy = blosc_test_malloc(BUFFER_ALIGN_SIZE, size);\n  dest = blosc_test_malloc(BUFFER_ALIGN_SIZE, size + BLOSC2_MAX_OVERHEAD);\n  dest2 = blosc_test_malloc(BUFFER_ALIGN_SIZE, size);\n  _src = (int64_t *)src;\n  for (i=0; i < (size / sizeof(int64_t)); i++) {\n    _src[i] = (int64_t)i;\n  }\n  memcpy(srccpy, src, size);\n\n  /* Run all the suite */\n  result = all_tests();\n  if (result != 0) {\n    printf(\" (%s)\\n\", result);\n  }\n  else {\n    printf(\" ALL TESTS PASSED\");\n  }\n  printf(\"\\tTests run: %d\\n\", tests_run);\n\n  blosc_test_free(src);\n  blosc_test_free(srccpy);\n  blosc_test_free(dest);\n  blosc_test_free(dest2);\n\n  blosc2_destroy();\n\n  return result != 0;\n}\n",
    "target": 1,
    "idx": 1050433,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nint flb_gzip_compress(void *in_data, size_t in_len,\n                      void **out_data, size_t *out_len)\n{\n    int flush;\n    int status;\n    int footer_start;\n    uint8_t *pb;\n    size_t out_size;\n    void *out_buf;\n    z_stream strm;\n    mz_ulong crc;\n\n    /*\n     * Calculating the upper bound for a gzip compression is\n     * non-trivial, so we rely on miniz's own calculation\n     * to guarantee memory safety.\n     */\n    out_size = compressBound(in_len);\n    out_buf = flb_malloc(out_size);\n\n    if (!out_buf) {\n        flb_errno();\n        flb_error(\"[gzip] could not allocate outgoing buffer\");\n        return -1;\n    }\n\n    /* Initialize streaming buffer context */\n    memset(&strm, '\\0', sizeof(strm));\n    strm.zalloc    = Z_NULL;\n    strm.zfree     = Z_NULL;\n    strm.opaque    = Z_NULL;\n    strm.next_in   = in_data;\n    strm.avail_in  = in_len;\n    strm.total_out = 0;\n\n    /* Deflate mode */\n    deflateInit2(&strm, Z_DEFAULT_COMPRESSION,\n                 Z_DEFLATED, -Z_DEFAULT_WINDOW_BITS, 9, Z_DEFAULT_STRATEGY);\n\n    /*\n     * Miniz don't support GZip format directly, instead we will:\n     *\n     * - append manual GZip magic bytes\n     * - deflate raw content\n     * - append manual CRC32 data\n     */\n    gzip_header(out_buf);\n\n    /* Header offset */\n    pb = (uint8_t *) out_buf + FLB_GZIP_HEADER_OFFSET;\n\n    flush = Z_NO_FLUSH;\n    while (1) {\n        strm.next_out  = pb + strm.total_out;\n        strm.avail_out = out_size - (pb - (uint8_t *) out_buf);\n\n        if (strm.avail_in == 0) {\n            flush = Z_FINISH;\n        }\n\n        status = deflate(&strm, flush);\n        if (status == Z_STREAM_END) {\n            break;\n        }\n        else if (status != Z_OK) {\n            deflateEnd(&strm);\n            return -1;\n        }\n    }\n\n    if (deflateEnd(&strm) != Z_OK) {\n        flb_free(out_buf);\n        return -1;\n    }\n    *out_len = strm.total_out;\n\n    /* Construct the gzip checksum (CRC32 footer) */\n    footer_start = FLB_GZIP_HEADER_OFFSET + *out_len;\n    pb = (uint8_t *) out_buf + footer_start;\n\n    crc = mz_crc32(MZ_CRC32_INIT, in_data, in_len);\n    *pb++ = crc & 0xFF;\n    *pb++ = (crc >> 8) & 0xFF;\n    *pb++ = (crc >> 16) & 0xFF;\n    *pb++ = (crc >> 24) & 0xFF;\n    *pb++ = in_len & 0xFF;\n    *pb++ = (in_len >> 8) & 0xFF;\n    *pb++ = (in_len >> 16) & 0xFF;\n    *pb++ = (in_len >> 24) & 0xFF;\n\n    /* Set the real buffer size for the caller */\n    *out_len += FLB_GZIP_HEADER_OFFSET + 8;\n    *out_data = out_buf;\n\n    return 0;\n}\n\n\n// target function\nint flb_gzip_compress(void *in_data, size_t in_len,\n                      void **out_data, size_t *out_len)\n{\n    int flush;\n    int status;\n    int footer_start;\n    uint8_t *pb;\n    size_t out_size;\n    void *out_buf;\n    z_stream strm;\n    mz_ulong crc;\n\n\n    /*\n     * GZIP relies on an algorithm with worst-case expansion\n     * of 5 bytes per 32KB data. This means we need to create a variable\n     * length output, that depends on the input length.\n     * See RFC 1951 for details.\n     */\n    int max_input_expansion = ((int)(in_len / 32000) + 1) * 5;\n\n    /*\n     * Max compressed size is equal to sum of:\n     *   10 byte header\n     *   8 byte foot\n     *   max input expansion\n     *   size of input\n     */\n    out_size = 10 + 8 + max_input_expansion + in_len;\n    out_buf = flb_malloc(out_size);\n\n    if (!out_buf) {\n        flb_errno();\n        flb_error(\"[gzip] could not allocate outgoing buffer\");\n        return -1;\n    }\n\n    /* Initialize streaming buffer context */\n    memset(&strm, '\\0', sizeof(strm));\n    strm.zalloc    = Z_NULL;\n    strm.zfree     = Z_NULL;\n    strm.opaque    = Z_NULL;\n    strm.next_in   = in_data;\n    strm.avail_in  = in_len;\n    strm.total_out = 0;\n\n    /* Deflate mode */\n    deflateInit2(&strm, Z_DEFAULT_COMPRESSION,\n                 Z_DEFLATED, -Z_DEFAULT_WINDOW_BITS, 9, Z_DEFAULT_STRATEGY);\n\n    /*\n     * Miniz don't support GZip format directly, instead we will:\n     *\n     * - append manual GZip magic bytes\n     * - deflate raw content\n     * - append manual CRC32 data\n     */\n    gzip_header(out_buf);\n\n    /* Header offset */\n    pb = (uint8_t *) out_buf + FLB_GZIP_HEADER_OFFSET;\n\n    flush = Z_NO_FLUSH;\n    while (1) {\n        strm.next_out  = pb + strm.total_out;\n        strm.avail_out = out_size - (pb - (uint8_t *) out_buf);\n\n        if (strm.avail_in == 0) {\n            flush = Z_FINISH;\n        }\n\n        status = deflate(&strm, flush);\n        if (status == Z_STREAM_END) {\n            break;\n        }\n        else if (status != Z_OK) {\n            deflateEnd(&strm);\n            return -1;\n        }\n    }\n\n    if (deflateEnd(&strm) != Z_OK) {\n        flb_free(out_buf);\n        return -1;\n    }\n    *out_len = strm.total_out;\n\n    /* Construct the gzip checksum (CRC32 footer) */\n    footer_start = FLB_GZIP_HEADER_OFFSET + *out_len;\n    pb = (uint8_t *) out_buf + footer_start;\n\n    crc = mz_crc32(MZ_CRC32_INIT, in_data, in_len);\n    *pb++ = crc & 0xFF;\n    *pb++ = (crc >> 8) & 0xFF;\n    *pb++ = (crc >> 16) & 0xFF;\n    *pb++ = (crc >> 24) & 0xFF;\n    *pb++ = in_len & 0xFF;\n    *pb++ = (in_len >> 8) & 0xFF;\n    *pb++ = (in_len >> 16) & 0xFF;\n    *pb++ = (in_len >> 24) & 0xFF;\n\n    /* Set the real buffer size for the caller */\n    *out_len += FLB_GZIP_HEADER_OFFSET + 8;\n    *out_data = out_buf;\n\n    return 0;\n}\n",
    "target": 1,
    "idx": 1027368,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic int MqttClient_DecodePacket(MqttClient* client, byte* rx_buf,\n    word32 rx_len, void *packet_obj, MqttPacketType* ppacket_type,\n    MqttQoS* ppacket_qos, word16* ppacket_id)\n{\n    int rc = MQTT_CODE_SUCCESS;\n    MqttPacket* header;\n    MqttPacketType packet_type;\n    MqttQoS packet_qos;\n    word16 packet_id = 0;\n#ifdef WOLFMQTT_V5\n    MqttProp* props = NULL;\n#endif\n\n    /* must have rx buffer with at least 2 byes for header */\n    if (rx_buf == NULL || rx_len < MQTT_PACKET_HEADER_MIN_SIZE) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    /* Decode header */\n    header = (MqttPacket*)rx_buf;\n    packet_type = (MqttPacketType)MQTT_PACKET_TYPE_GET(header->type_flags);\n    if (ppacket_type) {\n        *ppacket_type = packet_type;\n    }\n    packet_qos = (MqttQoS)MQTT_PACKET_FLAGS_GET_QOS(header->type_flags);\n    if (ppacket_qos) {\n        *ppacket_qos = packet_qos;\n    }\n\n    /* Decode packet specific data (if requested) */\n    if (ppacket_id || packet_obj) {\n        switch (packet_type) {\n        case MQTT_PACKET_TYPE_CONNECT_ACK:\n        {\n            MqttConnectAck connect_ack, *p_connect_ack = &connect_ack;\n            if (packet_obj) {\n                p_connect_ack = (MqttConnectAck*)packet_obj;\n            }\n            else {\n                XMEMSET(p_connect_ack, 0, sizeof(MqttConnectAck));\n            }\n        #ifdef WOLFMQTT_V5\n            p_connect_ack->protocol_level = client->protocol_level;\n        #endif\n            rc = MqttDecode_ConnectAck(rx_buf, rx_len, p_connect_ack);\n        #ifdef WOLFMQTT_V5\n            if (rc >= 0) {\n                props = p_connect_ack->props;\n            }\n        #endif\n            break;\n        }\n        case MQTT_PACKET_TYPE_PUBLISH:\n        {\n            MqttPublish publish, *p_publish = &publish;\n            if (packet_obj) {\n                p_publish = (MqttPublish*)packet_obj;\n            }\n            else {\n                XMEMSET(p_publish, 0, sizeof(MqttPublish));\n            }\n        #ifdef WOLFMQTT_V5\n            p_publish->protocol_level = client->protocol_level;\n        #endif\n            rc = MqttDecode_Publish(rx_buf, rx_len, p_publish);\n            if (rc >= 0) {\n                packet_id = p_publish->packet_id;\n            #ifdef WOLFMQTT_V5\n                props = p_publish->props;\n            #endif\n            }\n            break;\n        }\n        case MQTT_PACKET_TYPE_PUBLISH_ACK:\n        case MQTT_PACKET_TYPE_PUBLISH_REC:\n        case MQTT_PACKET_TYPE_PUBLISH_REL:\n        case MQTT_PACKET_TYPE_PUBLISH_COMP:\n        {\n            MqttPublishResp publish_resp, *p_publish_resp = &publish_resp;\n            if (packet_obj) {\n                p_publish_resp = (MqttPublishResp*)packet_obj;\n            }\n            else {\n                XMEMSET(p_publish_resp, 0, sizeof(MqttPublishResp));\n            }\n        #ifdef WOLFMQTT_V5\n                p_publish_resp->protocol_level = client->protocol_level;\n        #endif\n                rc = MqttDecode_PublishResp(rx_buf, rx_len, packet_type,\n                p_publish_resp);\n            if (rc >= 0) {\n                packet_id = p_publish_resp->packet_id;\n            #ifdef WOLFMQTT_V5\n                props = p_publish_resp->props;\n            #endif\n            }\n            break;\n        }\n        case MQTT_PACKET_TYPE_SUBSCRIBE_ACK:\n        {\n            MqttSubscribeAck subscribe_ack, *p_subscribe_ack = &subscribe_ack;\n            if (packet_obj) {\n                p_subscribe_ack = (MqttSubscribeAck*)packet_obj;\n            }\n            else {\n                XMEMSET(p_subscribe_ack, 0, sizeof(MqttSubscribeAck));\n            }\n        #ifdef WOLFMQTT_V5\n            p_subscribe_ack->protocol_level = client->protocol_level;\n        #endif\n            rc = MqttDecode_SubscribeAck(rx_buf, rx_len, p_subscribe_ack);\n            if (rc >= 0) {\n                packet_id = p_subscribe_ack->packet_id;\n            #ifdef WOLFMQTT_V5\n                props = p_subscribe_ack->props;\n            #endif\n            }\n            break;\n        }\n        case MQTT_PACKET_TYPE_UNSUBSCRIBE_ACK:\n        {\n            MqttUnsubscribeAck unsubscribe_ack,\n                               *p_unsubscribe_ack = &unsubscribe_ack;\n            if (packet_obj) {\n                p_unsubscribe_ack = (MqttUnsubscribeAck*)packet_obj;\n            }\n            else {\n                XMEMSET(p_unsubscribe_ack, 0, sizeof(MqttUnsubscribeAck));\n            }\n        #ifdef WOLFMQTT_V5\n            p_unsubscribe_ack->protocol_level = client->protocol_level;\n        #endif\n            rc = MqttDecode_UnsubscribeAck(rx_buf, rx_len, p_unsubscribe_ack);\n            if (rc >= 0) {\n                packet_id = p_unsubscribe_ack->packet_id;\n            #ifdef WOLFMQTT_V5\n                props = p_unsubscribe_ack->props;\n            #endif\n            }\n            break;\n        }\n        case MQTT_PACKET_TYPE_PING_RESP:\n        {\n            MqttPing ping, *p_ping = &ping;\n            if (packet_obj) {\n                p_ping = (MqttPing*)packet_obj;\n            }\n            else {\n                XMEMSET(p_ping, 0, sizeof(MqttPing));\n            }\n            rc = MqttDecode_Ping(rx_buf, rx_len, p_ping);\n            break;\n        }\n        case MQTT_PACKET_TYPE_AUTH:\n        {\n        #ifdef WOLFMQTT_V5\n            MqttAuth auth, *p_auth = &auth;\n            if (packet_obj) {\n                p_auth = (MqttAuth*)packet_obj;\n            }\n            else {\n                XMEMSET(p_auth, 0, sizeof(MqttAuth));\n            }\n            rc = MqttDecode_Auth(rx_buf, rx_len, p_auth);\n            if (rc >= 0) {\n                props = p_auth->props;\n            }\n        #else\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n        #endif /* WOLFMQTT_V5 */\n            break;\n        }\n        case MQTT_PACKET_TYPE_DISCONNECT:\n        {\n        #ifdef WOLFMQTT_V5\n            MqttDisconnect disc, *p_disc = &disc;\n            if (packet_obj) {\n                p_disc = (MqttDisconnect*)packet_obj;\n            }\n            else {\n                XMEMSET(p_disc, 0, sizeof(MqttDisconnect));\n            }\n            rc = MqttDecode_Disconnect(rx_buf, rx_len, p_disc);\n            if (rc >= 0) {\n                props = p_disc->props;\n            }\n        #else\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n        #endif /* WOLFMQTT_V5 */\n            break;\n        }\n        case MQTT_PACKET_TYPE_CONNECT:\n        case MQTT_PACKET_TYPE_SUBSCRIBE:\n        case MQTT_PACKET_TYPE_UNSUBSCRIBE:\n        case MQTT_PACKET_TYPE_PING_REQ:\n        case MQTT_PACKET_TYPE_ANY:\n        case MQTT_PACKET_TYPE_RESERVED:\n        default:\n            /* these type are only encoded by client */\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n            break;\n        } /* switch (packet_type) */\n    }\n\n    if (ppacket_id) {\n        *ppacket_id = packet_id;\n    }\n\n#ifdef WOLFMQTT_V5\n    if (props) {\n    #ifdef WOLFMQTT_PROPERTY_CB\n        /* Check for properties set by the server */\n        if (packet_obj && client->property_cb) {\n            /* capture error if returned */\n            int rc_err = client->property_cb(client, props,\n                    client->property_ctx);\n            if (rc_err < 0) {\n                rc = rc_err;\n            }\n        }\n    #endif\n        /* Free the properties */\n        MqttProps_Free(props);\n    }\n#endif\n\n    (void)client;\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"MqttClient_DecodePacket: Rc %d, Len %d, Type %s (%d), ID %d,\"\n            \" QoS %d\",\n        rc, rx_len, MqttPacket_TypeDesc(packet_type), packet_type, packet_id,\n        packet_qos);\n#endif\n\n    return rc;\n}\n\nstatic int MqttClient_HandlePacket(MqttClient* client,\n    MqttPacketType packet_type, void *packet_obj, int timeout_ms)\n{\n    int rc = MQTT_CODE_SUCCESS;\n    MqttQoS packet_qos = MQTT_QOS_0;\n    word16 packet_id = 0;\n\n    if (client == NULL || packet_obj == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    switch (packet_type)\n    {\n        case MQTT_PACKET_TYPE_CONNECT_ACK:\n        {\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, packet_obj, &packet_type, &packet_qos,\n                &packet_id);\n            break;\n        }\n        case MQTT_PACKET_TYPE_PUBLISH:\n        {\n            MqttPublish *publish = (MqttPublish*)packet_obj;\n            MqttPacketType resp_type;\n\n            if (publish->stat == MQTT_MSG_BEGIN ||\n                publish->stat == MQTT_MSG_READ) {\n                rc = MqttClient_DecodePacket(client, client->rx_buf,\n                    client->packet.buf_len, packet_obj, &packet_type,\n                    &packet_qos, &packet_id);\n                if (rc <= 0) {\n                    return rc;\n                }\n            }\n            else {\n                /* packet ID and QoS were already established */\n                packet_id = client->msg.publish.packet_id;\n                packet_qos = client->msg.publish.qos;\n            }\n\n            rc = MqttClient_Publish_ReadPayload(client, publish, timeout_ms);\n            if (rc < 0) {\n                break;\n            }\n\n            /* Handle QoS */\n            if (packet_qos == MQTT_QOS_0) {\n                /* we are done, no QoS response */\n                break;\n            }\n\n            /* Determine packet type to write */\n            resp_type = (packet_qos == MQTT_QOS_1) ?\n                MQTT_PACKET_TYPE_PUBLISH_ACK :\n                MQTT_PACKET_TYPE_PUBLISH_REC;\n            publish->resp.packet_id = packet_id;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Lock send socket mutex */\n            rc = wm_SemLock(&client->lockSend);\n            if (rc != 0) {\n                return rc;\n            }\n        #endif\n\n            /* Encode publish response */\n            rc = MqttEncode_PublishResp(client->tx_buf, client->tx_buf_len,\n                resp_type, &publish->resp);\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d), ID %d,\"\n                    \" QoS %d\",\n                rc, MqttPacket_TypeDesc(resp_type), resp_type, packet_id,\n                packet_qos);\n        #endif\n            if (rc <= 0) {\n            #ifdef WOLFMQTT_MULTITHREAD\n                wm_SemUnlock(&client->lockSend);\n            #endif\n                return rc;\n            }\n            client->packet.buf_len = rc;\n\n            /* Send publish response packet */\n            rc = MqttPacket_Write(client, client->tx_buf,\n                client->packet.buf_len);\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            wm_SemUnlock(&client->lockSend);\n        #endif\n            break;\n        }\n        case MQTT_PACKET_TYPE_PUBLISH_ACK:\n        case MQTT_PACKET_TYPE_PUBLISH_REC:\n        case MQTT_PACKET_TYPE_PUBLISH_REL:\n        case MQTT_PACKET_TYPE_PUBLISH_COMP:\n        {\n            MqttPublishResp pubRespObj, *publish_resp = &pubRespObj;\n            XMEMSET(publish_resp, 0, sizeof(MqttPublishResp));\n\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, publish_resp, &packet_type,\n                &packet_qos, &packet_id);\n            if (rc <= 0) {\n                return rc;\n            }\n\n            /* If publish Received or Release QoS then proceed */\n            if (packet_type != MQTT_PACKET_TYPE_PUBLISH_REC &&\n                packet_type != MQTT_PACKET_TYPE_PUBLISH_REL) {\n                break;\n            }\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Lock send socket mutex */\n            rc = wm_SemLock(&client->lockSend);\n            if (rc != 0) {\n                return rc;\n            }\n        #endif\n\n            /* Encode publish response */\n            publish_resp->packet_id = packet_id;\n            packet_type = (MqttPacketType)((int)packet_type+1); /* next ack */\n        #ifdef WOLFMQTT_V5\n            #ifdef WOLFMQTT_DEBUG_CLIENT\n                PRINTF(\"\\tPublish response: reason code %d, Type %s (%d),\"\n                        \" ID %d, QoS %d\",\n                        publish_resp->reason_code,\n                        MqttPacket_TypeDesc(packet_type),\n                        packet_type, packet_id, packet_qos);\n            #endif\n\n            /* return reason code to caller */\n            if (packet_obj != NULL) {\n                MqttPublishResp* caller_rsp = (MqttPublishResp*)packet_obj;\n                caller_rsp->reason_code = publish_resp->reason_code;\n            }\n\n            /* Publish QoS response needs success reason code,\n             * otherwise will cause disconnect at broker */\n            publish_resp->reason_code = MQTT_REASON_SUCCESS;\n        #endif\n\n            rc = MqttEncode_PublishResp(client->tx_buf, client->tx_buf_len,\n                packet_type, publish_resp);\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d), ID %d,\"\n                    \" QoS %d\",\n                rc, MqttPacket_TypeDesc(packet_type), packet_type, packet_id,\n                packet_qos);\n        #endif\n            if (rc <= 0) {\n            #ifdef WOLFMQTT_MULTITHREAD\n                wm_SemUnlock(&client->lockSend);\n            #endif\n                return rc;\n            }\n            client->packet.buf_len = rc;\n\n            /* Send publish response packet */\n            rc = MqttPacket_Write(client, client->tx_buf,\n                client->packet.buf_len);\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            wm_SemUnlock(&client->lockSend);\n        #endif\n            break;\n        }\n        case MQTT_PACKET_TYPE_SUBSCRIBE_ACK:\n        {\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, packet_obj, &packet_type, &packet_qos,\n                &packet_id);\n            break;\n        }\n        case MQTT_PACKET_TYPE_UNSUBSCRIBE_ACK:\n        {\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, packet_obj, &packet_type, &packet_qos,\n                &packet_id);\n            break;\n        }\n        case MQTT_PACKET_TYPE_PING_RESP:\n        {\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, packet_obj, &packet_type, &packet_qos,\n                &packet_id);\n            break;\n        }\n        case MQTT_PACKET_TYPE_AUTH:\n        {\n        #ifdef WOLFMQTT_V5\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, packet_obj, &packet_type, &packet_qos,\n                &packet_id);\n        #else\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n        #endif\n            break;\n        }\n\n        case MQTT_PACKET_TYPE_DISCONNECT:\n        {\n        #ifdef WOLFMQTT_V5\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, packet_obj, &packet_type, &packet_qos,\n                &packet_id);\n        #else\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n        #endif\n            break;\n        }\n        case MQTT_PACKET_TYPE_CONNECT:\n        case MQTT_PACKET_TYPE_SUBSCRIBE:\n        case MQTT_PACKET_TYPE_UNSUBSCRIBE:\n        case MQTT_PACKET_TYPE_PING_REQ:\n        case MQTT_PACKET_TYPE_ANY:\n        case MQTT_PACKET_TYPE_RESERVED:\n        default:\n            /* these types are only sent from client and should not be sent\n             * by broker */\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n            break;\n    } /* switch (packet_type) */\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    if (rc < 0) {\n        PRINTF(\"MqttClient_HandlePacket: Rc %d, Type %s (%d), QoS %d, ID %d\",\n            rc, MqttPacket_TypeDesc(packet_type), packet_type, packet_qos,\n            packet_id);\n    }\n#endif\n\n    return rc;\n}\n\nstatic int MqttClient_WaitType(MqttClient *client, void *packet_obj,\n    byte wait_type, word16 wait_packet_id, int timeout_ms)\n{\n    int rc;\n    word16 packet_id;\n    MqttPacketType packet_type;\n#ifdef WOLFMQTT_MULTITHREAD\n    MqttPendResp *pendResp;\n    int readLocked;\n#endif\n    MqttMsgStat* mms_stat;\n    int waitMatchFound;\n\n    if (client == NULL || packet_obj == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    /* all packet type structures must have MqttMsgStat at top */\n    mms_stat = (MqttMsgStat*)packet_obj;\n\nwait_again:\n\n    /* initialize variables */\n    packet_id = 0;\n    packet_type = MQTT_PACKET_TYPE_RESERVED;\n#ifdef WOLFMQTT_MULTITHREAD\n    pendResp = NULL;\n    readLocked = 0;\n#endif\n    waitMatchFound = 0;\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"MqttClient_WaitType: Type %s (%d), ID %d\",\n        MqttPacket_TypeDesc((MqttPacketType)wait_type),\n            wait_type, wait_packet_id);\n#endif\n\n    switch ((int)*mms_stat)\n    {\n        case MQTT_MSG_BEGIN:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Lock recv socket mutex */\n            rc = wm_SemLock(&client->lockRecv);\n            if (rc != 0) {\n                PRINTF(\"MqttClient_WaitType: recv lock error!\");\n                return rc;\n            }\n            readLocked = 1;\n        #endif\n\n            /* reset the packet state */\n            client->packet.stat = MQTT_PK_BEGIN;\n        }\n        FALL_THROUGH;\n\n    #ifdef WOLFMQTT_V5\n        case MQTT_MSG_AUTH:\n    #endif\n        case MQTT_MSG_WAIT:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if packet type and id have already completed */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, (MqttPacketType)wait_type, \n                    wait_packet_id, &pendResp)) {\n                    if (pendResp->packetDone) {\n                        /* pending response is already done, so return */\n                        rc = pendResp->packet_ret;\n                    #ifdef WOLFMQTT_DEBUG_CLIENT\n                        PRINTF(\"PendResp already Done %p: Rc %d\", pendResp, rc);\n                    #endif\n                        MqttClient_RespList_Remove(client, pendResp);\n                        wm_SemUnlock(&client->lockClient);\n                        wm_SemUnlock(&client->lockRecv);\n                        return rc;\n                    }\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            *mms_stat = MQTT_MSG_WAIT;\n\n            /* Wait for packet */\n            rc = MqttPacket_Read(client, client->rx_buf, client->rx_buf_len,\n                    timeout_ms);\n            /* handle failure */\n            if (rc <= 0) {\n                break;\n            }\n\n            /* capture length read */\n            client->packet.buf_len = rc;\n\n            /* Decode Packet - get type and id */\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, NULL, &packet_type, NULL, &packet_id);\n            if (rc < 0) {\n                break;\n            }\n\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"Read Packet: Len %d, Type %d, ID %d\",\n                client->packet.buf_len, packet_type, packet_id);\n        #endif\n\n            *mms_stat = MQTT_MSG_READ;\n        }\n        FALL_THROUGH;\n\n        case MQTT_MSG_READ:\n        case MQTT_MSG_READ_PAYLOAD:\n        {\n            MqttPacketType use_packet_type;\n            void* use_packet_obj;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            readLocked = 1; /* if in this state read is locked */\n        #endif\n\n            /* read payload state only happens for publish messages */\n            if (*mms_stat == MQTT_MSG_READ_PAYLOAD) {\n                packet_type = MQTT_PACKET_TYPE_PUBLISH;\n            }\n\n            /* Determine if we received data for this request */\n            if ((wait_type == MQTT_PACKET_TYPE_ANY ||\n                 wait_type == packet_type ||\n                 (MqttIsPubRespPacket(packet_type) &&\n                  MqttIsPubRespPacket(wait_type))) &&\n                (wait_packet_id == 0 || wait_packet_id == packet_id))\n            {\n                use_packet_obj = packet_obj;\n                waitMatchFound = 1;\n            }\n            else {\n                /* use generic packet object */\n                use_packet_obj = &client->msg;\n            }\n            use_packet_type = packet_type;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if we have a pending response for this packet */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, packet_type, packet_id,\n                                                               &pendResp)) {\n                    /* we found packet match this incoming read packet */\n                    pendResp->packetProcessing = 1;\n                    use_packet_obj = pendResp->packet_obj;\n                    use_packet_type = pendResp->packet_type;\n                    /* req from another thread... not a match */\n                    waitMatchFound = 0;\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            /* Perform packet handling for publish callback and QoS */\n            rc = MqttClient_HandlePacket(client, use_packet_type,\n                use_packet_obj, timeout_ms);\n\n        #ifdef WOLFMQTT_NONBLOCK\n            if (rc == MQTT_CODE_CONTINUE) {\n                /* we have received some data, so keep the recv\n                    mutex lock active and return */\n                return rc;\n            }\n        #endif\n\n            /* handle success case */\n            if (rc >= 0) {\n                rc = MQTT_CODE_SUCCESS;\n            }\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (pendResp) {\n                /* Mark pending response entry done */\n                if (wm_SemLock(&client->lockClient) == 0) {\n                    pendResp->packetDone = 1;\n                    pendResp->packet_ret = rc;\n                #ifdef WOLFMQTT_DEBUG_CLIENT\n                    PRINTF(\"PendResp Done %p\", pendResp);\n                #endif\n                    pendResp = NULL;\n                    wm_SemUnlock(&client->lockClient);\n                }\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n            break;\n        }\n\n        case MQTT_MSG_WRITE:\n        case MQTT_MSG_WRITE_PAYLOAD:\n        default:\n        {\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"MqttClient_WaitType: Invalid state %d!\", *mms_stat);\n        #endif\n            rc = MQTT_CODE_ERROR_STAT;\n            break;\n        }\n    } /* switch (*mms_stat) */\n\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc != MQTT_CODE_CONTINUE)\n#endif\n    {\n        /* reset state */\n        *mms_stat = MQTT_MSG_BEGIN;\n    }\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (readLocked) {\n        wm_SemUnlock(&client->lockRecv);\n    }\n#endif\n    if (rc < 0) {\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_WaitType: Failure: %s (%d)\",\n            MqttClient_ReturnCodeToString(rc), rc);\n    #endif\n        return rc;\n    }\n\n    if (!waitMatchFound) {\n        /* if we get here, then the we are still waiting for a packet */\n        goto wait_again;\n    }\n\n    return rc;\n}\n\nint MqttClient_Unsubscribe(MqttClient *client, MqttUnsubscribe *unsubscribe)\n{\n    int rc, len;\n\n    /* Validate required arguments */\n    if (client == NULL || unsubscribe == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n#ifdef WOLFMQTT_V5\n    /* Use specified protocol version if set */\n    unsubscribe->protocol_level = client->protocol_level;\n#endif\n\n    if (unsubscribe->stat == MQTT_MSG_BEGIN) {\n    #ifdef WOLFMQTT_MULTITHREAD\n        /* Lock send socket mutex */\n        rc = wm_SemLock(&client->lockSend);\n        if (rc != 0) {\n            return rc;\n        }\n    #endif\n\n        /* Encode the subscribe packet */\n        rc = MqttEncode_Unsubscribe(client->tx_buf, client->tx_buf_len,\n            unsubscribe);\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d), ID %d, QoS %d\",\n            rc, MqttPacket_TypeDesc(MQTT_PACKET_TYPE_UNSUBSCRIBE),\n            MQTT_PACKET_TYPE_UNSUBSCRIBE, unsubscribe->packet_id, 0);\n    #endif\n        if (rc <= 0) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            wm_SemUnlock(&client->lockSend);\n        #endif\n            return rc;\n        }\n        len = rc;\n\n    #ifdef WOLFMQTT_MULTITHREAD\n        rc = wm_SemLock(&client->lockClient);\n        if (rc == 0) {\n            /* inform other threads of expected response */\n            rc = MqttClient_RespList_Add(client,\n                MQTT_PACKET_TYPE_UNSUBSCRIBE_ACK, unsubscribe->packet_id,\n                &unsubscribe->pendResp, &unsubscribe->ack);\n            wm_SemUnlock(&client->lockClient);\n        }\n        if (rc != 0) {\n            wm_SemUnlock(&client->lockSend); /* Error locking client */\n            return rc;\n        }\n    #endif\n\n        /* Send unsubscribe packet */\n        rc = MqttPacket_Write(client, client->tx_buf, len);\n    #ifdef WOLFMQTT_MULTITHREAD\n        wm_SemUnlock(&client->lockSend);\n    #endif\n        if (rc != len) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (wm_SemLock(&client->lockClient) == 0) {\n                MqttClient_RespList_Remove(client, &unsubscribe->pendResp);\n                wm_SemUnlock(&client->lockClient);\n            }\n        #endif\n            return rc;\n        }\n\n        unsubscribe->stat = MQTT_MSG_WAIT;\n    }\n\n    /* Wait for unsubscribe ack packet */\n    rc = MqttClient_WaitType(client, &unsubscribe->ack,\n        MQTT_PACKET_TYPE_UNSUBSCRIBE_ACK, unsubscribe->packet_id,\n        client->cmd_timeout_ms);\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc == MQTT_CODE_CONTINUE)\n        return rc;\n#endif\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (wm_SemLock(&client->lockClient) == 0) {\n        MqttClient_RespList_Remove(client, &unsubscribe->pendResp);\n        wm_SemUnlock(&client->lockClient);\n    }\n#endif\n\n#ifdef WOLFMQTT_V5\n    if (unsubscribe->ack.props != NULL) {\n        /* Release the allocated properties */\n        MqttClient_PropsFree(unsubscribe->ack.props);\n    }\n#endif\n\n    /* reset state */\n    unsubscribe->stat = MQTT_MSG_BEGIN;\n\n    return rc;\n}\n\nbool wolfMQTTFuzzer::unsubscribe(void) {\n    MqttTopic* topicsArray = nullptr;\n\n    bool ret = false;\n\n    try {\n        Topics topics(ds);\n        CHECK_EQ(topics.Generate(), true);\n\n        MqttUnsubscribe unsubscribe;\n\n        memset(&unsubscribe, 0, sizeof(unsubscribe));\n\n        unsubscribe.packet_id = GetPacketId();\n        topicsArray = topics.ToArray();\n        unsubscribe.topic_count = topics.Size();\n        unsubscribe.topics = topicsArray;\n\n        CHECK_EQ(MqttClient_Unsubscribe(&client, &unsubscribe), MQTT_CODE_SUCCESS);\n\n        ret = true;\n    } catch ( ... ) { }\n\nend:\n    if ( topicsArray ) {\n        delete[] topicsArray;\n    }\n    return ret;\n}\n\nvoid wolfMQTTFuzzer::Run(void) {\n    try {\n        const auto numActions = ds.Get<uint8_t>() % 20;\n\n        for (size_t i = 0; i < numActions; i++) {\n            switch ( ds.Get<uint8_t>() ) {\n                case    0:\n                    subscribe();\n                    break;\n                case    1:\n                    unsubscribe();\n                    break;\n                case    2:\n                    publish();\n                    break;\n                case    3:\n                    ping();\n                    break;\n                case    4:\n                    wait();\n                    break;\n            }\n        }\n\n        MqttClient_NetDisconnect(&client);\n    } catch ( ... ) { }\n}\n\n\n// target function\nstatic int MqttClient_WaitType(MqttClient *client, void *packet_obj,\n    byte wait_type, word16 wait_packet_id, int timeout_ms)\n{\n    int rc;\n    word16 packet_id;\n    MqttPacketType packet_type;\n#ifdef WOLFMQTT_MULTITHREAD\n    MqttPendResp *pendResp;\n    int readLocked;\n#endif\n    MqttMsgStat* mms_stat;\n    int waitMatchFound;\n\n    if (client == NULL || packet_obj == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    /* all packet type structures must have MqttMsgStat at top */\n    mms_stat = (MqttMsgStat*)packet_obj;\n\nwait_again:\n\n    /* initialize variables */\n    packet_id = 0;\n    packet_type = MQTT_PACKET_TYPE_RESERVED;\n#ifdef WOLFMQTT_MULTITHREAD\n    pendResp = NULL;\n    readLocked = 0;\n#endif\n    waitMatchFound = 0;\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"MqttClient_WaitType: Type %s (%d), ID %d\",\n        MqttPacket_TypeDesc((MqttPacketType)wait_type),\n            wait_type, wait_packet_id);\n#endif\n\n    switch ((int)*mms_stat)\n    {\n        case MQTT_MSG_BEGIN:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Lock recv socket mutex */\n            rc = wm_SemLock(&client->lockRecv);\n            if (rc != 0) {\n                PRINTF(\"MqttClient_WaitType: recv lock error!\");\n                return rc;\n            }\n            readLocked = 1;\n        #endif\n\n            /* reset the packet state */\n            client->packet.stat = MQTT_PK_BEGIN;\n        }\n        FALL_THROUGH;\n\n    #ifdef WOLFMQTT_V5\n        case MQTT_MSG_AUTH:\n    #endif\n        case MQTT_MSG_WAIT:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if packet type and id have already completed */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, (MqttPacketType)wait_type, \n                    wait_packet_id, &pendResp)) {\n                    if (pendResp->packetDone) {\n                        /* pending response is already done, so return */\n                        rc = pendResp->packet_ret;\n                    #ifdef WOLFMQTT_DEBUG_CLIENT\n                        PRINTF(\"PendResp already Done %p: Rc %d\", pendResp, rc);\n                    #endif\n                        MqttClient_RespList_Remove(client, pendResp);\n                        wm_SemUnlock(&client->lockClient);\n                        wm_SemUnlock(&client->lockRecv);\n                        return rc;\n                    }\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            *mms_stat = MQTT_MSG_WAIT;\n\n            /* Wait for packet */\n            rc = MqttPacket_Read(client, client->rx_buf, client->rx_buf_len,\n                    timeout_ms);\n            /* handle failure */\n            if (rc <= 0) {\n                break;\n            }\n\n            /* capture length read */\n            client->packet.buf_len = rc;\n\n            /* Decode Packet - get type and id */\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, NULL, &packet_type, NULL, &packet_id);\n            if (rc < 0) {\n                break;\n            }\n\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"Read Packet: Len %d, Type %d, ID %d\",\n                client->packet.buf_len, packet_type, packet_id);\n        #endif\n\n            *mms_stat = MQTT_MSG_READ;\n        }\n        FALL_THROUGH;\n\n        case MQTT_MSG_READ:\n        case MQTT_MSG_READ_PAYLOAD:\n        {\n            MqttPacketType use_packet_type;\n            void* use_packet_obj;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            readLocked = 1; /* if in this state read is locked */\n        #endif\n\n            /* read payload state only happens for publish messages */\n            if (*mms_stat == MQTT_MSG_READ_PAYLOAD) {\n                packet_type = MQTT_PACKET_TYPE_PUBLISH;\n            }\n\n            /* Determine if we received data for this request */\n            if ((wait_type == MQTT_PACKET_TYPE_ANY ||\n                 wait_type == packet_type ||\n                 MqttIsPubRespPacket(packet_type) == MqttIsPubRespPacket(wait_type)) &&\n               (wait_packet_id == 0 || wait_packet_id == packet_id))\n            {\n                use_packet_obj = packet_obj;\n                waitMatchFound = 1;\n            }\n            else {\n                /* use generic packet object */\n                use_packet_obj = &client->msg;\n            }\n            use_packet_type = packet_type;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if we have a pending response for this packet */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, packet_type, packet_id,\n                                                               &pendResp)) {\n                    /* we found packet match this incoming read packet */\n                    pendResp->packetProcessing = 1;\n                    use_packet_obj = pendResp->packet_obj;\n                    use_packet_type = pendResp->packet_type;\n                    /* req from another thread... not a match */\n                    waitMatchFound = 0;\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            /* Perform packet handling for publish callback and QoS */\n            rc = MqttClient_HandlePacket(client, use_packet_type,\n                use_packet_obj, timeout_ms);\n\n        #ifdef WOLFMQTT_NONBLOCK\n            if (rc == MQTT_CODE_CONTINUE) {\n                /* we have received some data, so keep the recv\n                    mutex lock active and return */\n                return rc;\n            }\n        #endif\n\n            /* handle success case */\n            if (rc >= 0) {\n                rc = MQTT_CODE_SUCCESS;\n            }\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (pendResp) {\n                /* Mark pending response entry done */\n                if (wm_SemLock(&client->lockClient) == 0) {\n                    pendResp->packetDone = 1;\n                    pendResp->packet_ret = rc;\n                #ifdef WOLFMQTT_DEBUG_CLIENT\n                    PRINTF(\"PendResp Done %p\", pendResp);\n                #endif\n                    pendResp = NULL;\n                    wm_SemUnlock(&client->lockClient);\n                }\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n            break;\n        }\n\n        case MQTT_MSG_WRITE:\n        case MQTT_MSG_WRITE_PAYLOAD:\n        default:\n        {\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"MqttClient_WaitType: Invalid state %d!\", *mms_stat);\n        #endif\n            rc = MQTT_CODE_ERROR_STAT;\n            break;\n        }\n    } /* switch (*mms_stat) */\n\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc != MQTT_CODE_CONTINUE)\n#endif\n    {\n        /* reset state */\n        *mms_stat = MQTT_MSG_BEGIN;\n    }\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (readLocked) {\n        wm_SemUnlock(&client->lockRecv);\n    }\n#endif\n    if (rc < 0) {\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_WaitType: Failure: %s (%d)\",\n            MqttClient_ReturnCodeToString(rc), rc);\n    #endif\n        return rc;\n    }\n\n    if (!waitMatchFound) {\n        /* if we get here, then the we are still waiting for a packet */\n        goto wait_again;\n    }\n\n    return rc;\n}\n",
    "target": 1,
    "idx": 1037866,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic int pj_cs2cs_emulation_setup (PJ *P) {\n/**************************************************************************************\nIf any cs2cs style modifiers are given (axis=..., towgs84=..., ) create the 4D API\nequivalent operations, so the preparation and finalization steps in the pj_inv/pj_fwd\ninvocators can emulate the behaviour of pj_transform and the cs2cs app.\n**************************************************************************************/\n    PJ *Q;\n    paralist *p;\n    if (0==P)\n        return 0;\n\n    /* Don't recurse when calling proj_create (which calls us back) */\n    if (pj_param_exists (P->params, \"break_cs2cs_recursion\"))\n        return 1;\n\n    /* Swap axes? */\n    p = pj_param_exists (P->params, \"axis\");\n\n    /* Don't axisswap if data are already in \"enu\" order */\n    if (p && (0!=strcmp (\"enu\", p->param))) {\n        char *def = malloc (100+strlen(P->axis));\n        if (0==def)\n            return 0;\n        sprintf (def, \"break_cs2cs_recursion     proj=axisswap  axis=%s\", P->axis);\n        Q = proj_create (P->ctx, def);\n        free (def);\n        if (0==Q)\n            return 0;\n        P->axisswap = skip_prep_fin(Q);\n    }\n\n    /* Geoid grid(s) given? */\n    p = pj_param_exists (P->params, \"geoidgrids\");\n    if (p  &&  strlen (p->param) > strlen (\"geoidgrids=\")) {\n        char *gridnames = p->param + strlen (\"geoidgrids=\");\n        char *def = malloc (100+strlen(gridnames));\n        if (0==def)\n            return 0;\n        sprintf (def, \"break_cs2cs_recursion     proj=vgridshift  grids=%s\", gridnames);\n        Q = proj_create (P->ctx, def);\n        free (def);\n        if (0==Q)\n            return 0;\n        P->vgridshift = skip_prep_fin(Q);\n    }\n\n    /* Datum shift grid(s) given? */\n    p = pj_param_exists (P->params, \"nadgrids\");\n    if (p  &&  strlen (p->param) > strlen (\"nadgrids=\")) {\n        char *gridnames = p->param + strlen (\"nadgrids=\");\n        char *def = malloc (100+strlen(gridnames));\n        if (0==def)\n            return 0;\n        sprintf (def, \"break_cs2cs_recursion     proj=hgridshift  grids=%s\", gridnames);\n        Q = proj_create (P->ctx, def);\n        free (def);\n        if (0==Q)\n            return 0;\n        P->hgridshift = skip_prep_fin(Q);\n    }\n\n    /* We ignore helmert if we have grid shift */\n    p = P->hgridshift ? 0 : pj_param_exists (P->params, \"towgs84\");\n    while (p) {\n        char *def;\n        char *s = p->param;\n        double *d = P->datum_params;\n        size_t n = strlen (s);\n\n        /* We ignore null helmert shifts (common in auto-translated resource files, e.g. epsg) */\n        if (0==d[0] && 0==d[1] && 0==d[2] && 0==d[3] && 0==d[4] && 0==d[5] && 0==d[6])\n            break;\n\n        if (n <= 8) /* 8==strlen (\"towgs84=\") */\n            return 0;\n\n        def = malloc (100+n);\n        if (0==def)\n            return 0;\n        sprintf (def, \"break_cs2cs_recursion     proj=helmert %s\", s);\n        Q = proj_create (P->ctx, def);\n        free (def);\n        if (0==Q)\n            return 0;\n        P->helmert = skip_prep_fin(Q);\n\n        break;\n    }\n\n    /* We also need cartesian/geographical transformations if we are working in */\n    /* geocentric/cartesian space or we need to do a Helmert transform.         */\n    if (P->is_geocent || P->helmert) {\n        char def[100];\n        sprintf (def, \"break_cs2cs_recursion     proj=cart\");\n        Q = proj_create (P->ctx, def);\n        if (0==Q)\n            return 0;\n        pj_inherit_ellipsoid_def(P, Q);\n        P->cart = skip_prep_fin(Q);\n\n        sprintf (def, \"break_cs2cs_recursion     proj=cart  ellps=WGS84\");\n        Q = proj_create (P->ctx, def);\n        if (0==Q)\n            return 0;\n        P->cart_wgs84 = skip_prep_fin(Q);\n    }\n\n    return 1;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n// target function\nstatic int pj_cs2cs_emulation_setup (PJ *P) {\n/**************************************************************************************\nIf any cs2cs style modifiers are given (axis=..., towgs84=..., ) create the 4D API\nequivalent operations, so the preparation and finalization steps in the pj_inv/pj_fwd\ninvocators can emulate the behaviour of pj_transform and the cs2cs app.\n**************************************************************************************/\n    PJ *Q;\n    paralist *p;\n    char def[1000];\n    if (0==P)\n        return 0;\n\n    /* Don't recurse when calling proj_create (which calls us back) */\n    if (pj_param_exists (P->params, \"break_cs2cs_recursion\"))\n        return 1;\n\n    /* Swap axes? */\n    p = pj_param_exists (P->params, \"axis\");\n\n    /* Don't axisswap if data are already in \"enu\" order */\n    if (p && (0!=strcmp (\"enu\", p->param))) {\n        sprintf (def, \"break_cs2cs_recursion     proj=axisswap  axis=%s\", P->axis);\n        Q = proj_create (P->ctx, def);\n        if (0==Q)\n            return 0;\n        P->axisswap = skip_prep_fin(Q);\n    }\n\n    /* Geoid grid(s) given? */\n    p = pj_param_exists (P->params, \"geoidgrids\");\n    if (p  &&  strlen (p->param) > strlen (\"geoidgrids=\")) {\n        char *gridnames = p->param + strlen (\"geoidgrids=\");\n        sprintf (def, \"break_cs2cs_recursion     proj=vgridshift  grids=%s\", gridnames);\n        Q = proj_create (P->ctx, def);\n        if (0==Q)\n            return 0;\n        P->vgridshift = skip_prep_fin(Q);\n    }\n\n    /* Datum shift grid(s) given? */\n    p = pj_param_exists (P->params, \"nadgrids\");\n    if (p  &&  strlen (p->param) > strlen (\"nadgrids=\")) {\n        char *gridnames = p->param + strlen (\"nadgrids=\");\n        sprintf (def, \"break_cs2cs_recursion     proj=hgridshift  grids=%s\", gridnames);\n        Q = proj_create (P->ctx, def);\n        if (0==Q)\n            return 0;\n        P->hgridshift = skip_prep_fin(Q);\n    }\n\n    /* We ignore helmert if we have grid shift */\n    p = P->hgridshift ? 0 : pj_param_exists (P->params, \"towgs84\");\n    while (p) {\n        char *s = p->param;\n        double *d = P->datum_params;\n        size_t n = strlen (s);\n\n        /* We ignore null helmert shifts (common in auto-translated resource files, e.g. epsg) */\n        if (0==d[0] && 0==d[1] && 0==d[2] && 0==d[3] && 0==d[4] && 0==d[5] && 0==d[6])\n            break;\n\n        if (n > 900)\n            return 0;\n        if (n <= 8) /* 8==strlen (\"towgs84=\") */\n            return 0;\n        sprintf (def, \"break_cs2cs_recursion     proj=helmert %s\", s);\n        Q = proj_create (P->ctx, def);\n        if (0==Q)\n            return 0;\n        P->helmert = skip_prep_fin(Q);\n\n        break;\n    }\n\n    /* We also need cartesian/geographical transformations if we are working in */\n    /* geocentric/cartesian space or we need to do a Helmert transform.         */\n    if (P->is_geocent || P->helmert) {\n        char *wgs84 = \"ellps=WGS84\";\n        sprintf (def, \"break_cs2cs_recursion     proj=cart\");\n        Q = proj_create (P->ctx, def);\n        if (0==Q)\n            return 0;\n        pj_inherit_ellipsoid_def(P, Q);\n        P->cart = skip_prep_fin(Q);\n\n        sprintf (def, \"break_cs2cs_recursion     proj=cart  %s\", wgs84);\n        Q = proj_create (P->ctx, def);\n        if (0==Q)\n            return 0;\n        P->cart_wgs84 = skip_prep_fin(Q);\n    }\n\n    return 1;\n}\n",
    "target": 1,
    "idx": 1005903,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic void ZSTD_storeLastLiterals(seqStore_t* seqStorePtr,\n                                   const BYTE* anchor, size_t lastLLSize)\n{\n    memcpy(seqStorePtr->lit, anchor, lastLLSize);\n    seqStorePtr->lit += lastLLSize;\n}\n\nstatic size_t ZSTD_compressBlock_internal(ZSTD_CCtx* zc, void* dst, size_t dstCapacity, const void* src, size_t srcSize)\n{\n    const BYTE* const base = zc->base;\n    const BYTE* const istart = (const BYTE*)src;\n    const U32 current = (U32)(istart-base);\n    size_t lastLLSize;\n    const BYTE* anchor;\n    U32 const extDict = zc->lowLimit < zc->dictLimit;\n    const ZSTD_blockCompressor blockCompressor =\n        zc->appliedParams.ldmParams.enableLdm\n            ? (extDict ? ZSTD_compressBlock_ldm_extDict : ZSTD_compressBlock_ldm)\n            : ZSTD_selectBlockCompressor(zc->appliedParams.cParams.strategy, extDict);\n\n    if (srcSize < MIN_CBLOCK_SIZE+ZSTD_blockHeaderSize+1) return 0;   /* don't even attempt compression below a certain srcSize */\n    ZSTD_resetSeqStore(&(zc->seqStore));\n    if (current > zc->nextToUpdate + 384)\n        zc->nextToUpdate = current - MIN(192, (U32)(current - zc->nextToUpdate - 384));   /* limited update after finding a very long match */\n\n    lastLLSize = blockCompressor(zc, src, srcSize);\n\n    /* Last literals */\n    anchor = (const BYTE*)src + srcSize - lastLLSize;\n    ZSTD_storeLastLiterals(&zc->seqStore, anchor, lastLLSize);\n\n    return ZSTD_compressSequences(&zc->seqStore, zc->entropy, &zc->appliedParams.cParams, dst, dstCapacity, srcSize);\n}\n\nstatic size_t ZSTD_compressContinue_internal (ZSTD_CCtx* cctx,\n                              void* dst, size_t dstCapacity,\n                        const void* src, size_t srcSize,\n                               U32 frame, U32 lastFrameChunk)\n{\n    const BYTE* const ip = (const BYTE*) src;\n    size_t fhSize = 0;\n\n    DEBUGLOG(5, \"ZSTD_compressContinue_internal\");\n    DEBUGLOG(5, \"stage: %u\", cctx->stage);\n    if (cctx->stage==ZSTDcs_created) return ERROR(stage_wrong);   /* missing init (ZSTD_compressBegin) */\n\n    if (frame && (cctx->stage==ZSTDcs_init)) {\n        fhSize = ZSTD_writeFrameHeader(dst, dstCapacity, cctx->appliedParams,\n                                       cctx->pledgedSrcSizePlusOne-1, cctx->dictID);\n        if (ZSTD_isError(fhSize)) return fhSize;\n        dstCapacity -= fhSize;\n        dst = (char*)dst + fhSize;\n        cctx->stage = ZSTDcs_ongoing;\n    }\n\n    /* Check if blocks follow each other */\n    if (src != cctx->nextSrc) {\n        /* not contiguous */\n        ptrdiff_t const delta = cctx->nextSrc - ip;\n        cctx->lowLimit = cctx->dictLimit;\n        cctx->dictLimit = (U32)(cctx->nextSrc - cctx->base);\n        cctx->dictBase = cctx->base;\n        cctx->base -= delta;\n        cctx->nextToUpdate = cctx->dictLimit;\n        if (cctx->dictLimit - cctx->lowLimit < HASH_READ_SIZE) cctx->lowLimit = cctx->dictLimit;   /* too small extDict */\n    }\n\n    /* if input and dictionary overlap : reduce dictionary (area presumed modified by input) */\n    if ((ip+srcSize > cctx->dictBase + cctx->lowLimit) & (ip < cctx->dictBase + cctx->dictLimit)) {\n        ptrdiff_t const highInputIdx = (ip + srcSize) - cctx->dictBase;\n        U32 const lowLimitMax = (highInputIdx > (ptrdiff_t)cctx->dictLimit) ? cctx->dictLimit : (U32)highInputIdx;\n        cctx->lowLimit = lowLimitMax;\n    }\n\n    cctx->nextSrc = ip + srcSize;\n\n    if (srcSize) {\n        size_t const cSize = frame ?\n                             ZSTD_compress_frameChunk (cctx, dst, dstCapacity, src, srcSize, lastFrameChunk) :\n                             ZSTD_compressBlock_internal (cctx, dst, dstCapacity, src, srcSize);\n        if (ZSTD_isError(cSize)) return cSize;\n        cctx->consumedSrcSize += srcSize;\n        return cSize + fhSize;\n    } else\n        return fhSize;\n}\n\nsize_t ZSTD_compressBlock(ZSTD_CCtx* cctx, void* dst, size_t dstCapacity, const void* src, size_t srcSize)\n{\n    size_t const blockSizeMax = ZSTD_getBlockSize(cctx);\n    if (srcSize > blockSizeMax) return ERROR(srcSize_wrong);\n    return ZSTD_compressContinue_internal(cctx, dst, dstCapacity, src, srcSize, 0 /* frame mode */, 0 /* last chunk */);\n}\n\nstatic size_t roundTripTest(void *result, size_t resultCapacity,\n                            void *compressed, size_t compressedCapacity,\n                            const void *src, size_t srcSize)\n{\n    int const cLevel = FUZZ_rand(&seed) % kMaxClevel;\n    ZSTD_parameters const params = ZSTD_getParams(cLevel, srcSize, 0);\n    size_t ret = ZSTD_compressBegin_advanced(cctx, NULL, 0, params, srcSize);\n    FUZZ_ZASSERT(ret);\n\n    ret = ZSTD_compressBlock(cctx, compressed, compressedCapacity, src, srcSize);\n    FUZZ_ZASSERT(ret);\n    if (ret == 0) {\n        FUZZ_ASSERT(resultCapacity >= srcSize);\n        memcpy(result, src, srcSize);\n        return srcSize;\n    }\n    ZSTD_decompressBegin(dctx);\n    return ZSTD_decompressBlock(dctx, result, resultCapacity, compressed, ret);\n}\n\n\n// target function\nZSTD_compressionParameters ZSTD_adjustCParams_internal(ZSTD_compressionParameters cPar, unsigned long long srcSize, size_t dictSize)\n{\n    static const U64 minSrcSize = 513; /* (1<<9) + 1 */\n    static const U64 maxWindowResize = 1ULL << (ZSTD_WINDOWLOG_MAX-1);\n    assert(ZSTD_checkCParams(cPar)==0);\n\n    if (dictSize && (srcSize+1<2) /* srcSize unknown */ )\n        srcSize = minSrcSize;  /* presumed small when there is a dictionary */\n    else\n        srcSize -= 1;  /* unknown 0 => -1ULL : presumed large */\n\n    /* resize windowLog if input is small enough, to use less memory */\n    if ( (srcSize < maxWindowResize)\n      && (dictSize < maxWindowResize) )  {\n        U32 const tSize = (U32)(srcSize + dictSize);\n        static U32 const hashSizeMin = 1 << ZSTD_HASHLOG_MIN;\n        U32 const srcLog = (tSize < hashSizeMin) ? ZSTD_HASHLOG_MIN :\n                            ZSTD_highbit32(tSize-1) + 1;\n        if (cPar.windowLog > srcLog) cPar.windowLog = srcLog;\n    }\n    if (cPar.hashLog > cPar.windowLog) cPar.hashLog = cPar.windowLog;\n    {   U32 const cycleLog = ZSTD_cycleLog(cPar.chainLog, cPar.strategy);\n        if (cycleLog > cPar.windowLog)\n            cPar.chainLog -= (cycleLog - cPar.windowLog);\n    }\n\n    if (cPar.windowLog < ZSTD_WINDOWLOG_ABSOLUTEMIN)\n        cPar.windowLog = ZSTD_WINDOWLOG_ABSOLUTEMIN;  /* required for frame header */\n\n    return cPar;\n}\n",
    "target": 1,
    "idx": 1003522,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic int\npgp_parse_algo_attr_blob(const pgp_blob_t *blob, sc_cardctl_openpgp_keygen_info_t *key_info)\n{\n\tstruct sc_object_id oid;\n\tunsigned int j;\n\n\tif (blob == NULL || blob->data == NULL || blob->len == 0 ||\n\t    blob->id < 0x00c1 || blob->id > 0x00c3 || key_info == NULL)\n\t\treturn SC_ERROR_INCORRECT_PARAMETERS;\n\n\tkey_info->key_id = blob->id - 0x00c0;\t/* attribute algorithm blobs are C1 - C3 */\n\n\tswitch (blob->data[0]) {\n\t\tcase SC_OPENPGP_KEYALGO_RSA:\n\t\t\tif (blob->len < 5)\n\t\t\t\treturn SC_ERROR_INCORRECT_PARAMETERS;\n\n\t\t\tkey_info->algorithm = SC_OPENPGP_KEYALGO_RSA;\n\t\t\tkey_info->u.rsa.modulus_len = bebytes2ushort(blob->data + 1);\n\t\t\tkey_info->u.rsa.exponent_len = bebytes2ushort(blob->data + 3);\n\n\t\t\tkey_info->u.rsa.keyformat = (blob->len > 5)\n\t\t\t\t\t\t  ? blob->data[5]\n\t\t\t\t\t\t  : SC_OPENPGP_KEYFORMAT_RSA_STD;\n\t\t\tbreak;\n\t\tcase SC_OPENPGP_KEYALGO_ECDH:\n\t\tcase SC_OPENPGP_KEYALGO_ECDSA:\n\n\t\t\t/* SC_OPENPGP_KEYALGO_ECDH || SC_OPENPGP_KEYALGO_ECDSA */\n\t\t\tkey_info->algorithm = blob->data[0];\n\n\t\t\tsc_init_oid(&oid);\n\t\t\t/* Create copy of oid from blob */\n\t\t\tfor (j=0; j < (blob->len-1) && j < SC_MAX_OBJECT_ID_OCTETS; j++) {\n\t\t\t\toid.value[j] = blob->data[j+1]; /* ignore first byte of blob (algo ID) */\n\t\t\t}\n\n\t\t\t/* compare with list of supported ec_curves */\n\t\t\tfor (j=0; ec_curves[j].oid.value[0] >= 0; j++){\n\t\t\t\tif (sc_compare_oid(&ec_curves[j].oid_binary, &oid)){\n\t\t\t\t\tkey_info->u.ec.oid = ec_curves[j].oid;\n\t\t\t\t\tkey_info->u.ec.key_length = ec_curves[j].size;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn SC_ERROR_NOT_IMPLEMENTED;\n\t}\n\n\treturn SC_SUCCESS;\n}\n\nstatic int\npgp_get_card_features(sc_card_t *card)\n{\n\tstruct pgp_priv_data *priv = DRVDATA(card);\n\tu8 *hist_bytes = card->reader->atr_info.hist_bytes;\n\tsize_t hist_bytes_len = card->reader->atr_info.hist_bytes_len;\n\tsize_t i;\n\tpgp_blob_t *blob, *blob6e, *blob73;\n\n\t/* parse card capabilities from historical bytes in ATR */\n\tif (hist_bytes_len > 0) {\n\t\t/* category indicator 0x00, 0x10 or 0x80 => compact TLV (ISO) */\n\t\tswitch (hist_bytes[0]) {\n\t\t\tcase 0x00:\n\t\t\t\tif (hist_bytes_len > 4) {\n\t\t\t\t\tpgp_parse_hist_bytes(card, hist_bytes+1, hist_bytes_len-4);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 0x80:\n\t\t\t\tif (hist_bytes_len > 1) {\n\t\t\t\t\tpgp_parse_hist_bytes(card, hist_bytes+1, hist_bytes_len-1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 0x10:\n\t\t\t\tif (hist_bytes_len > 2) {\n\t\t\t\t\tpgp_parse_hist_bytes(card, hist_bytes+2, hist_bytes_len-2);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* v1.1 does not support lifecycle via ACTIVATE & TERMINATE: set default */\n\tpriv->ext_caps &= ~EXT_CAP_LCS;\n\n\tif (priv->bcd_version >= OPENPGP_CARD_2_0) {\n\t\t/* get card capabilities from \"historical bytes\" DO */\n\t\tif ((pgp_get_blob(card, priv->mf, 0x5f52, &blob) >= 0) &&\n\t\t    (blob->data != NULL) && (blob->data[0] == 0x00)) {\n\n\t\t\tif (blob->len > 4) {\n\t\t\t\tpgp_parse_hist_bytes(card, blob->data+1, blob->len-4);\n\t\t\t}\n\n\t\t\t/* get card status from historical bytes status indicator */\n\t\t\tif ((blob->data[0] == 0x00) && (blob->len >= 4)) {\n\t\t\t\tpriv->state = blob->data[blob->len-3];\n\t\t\t\t/* state not CARD_STATE_UNKNOWN => LCS supported */\n\t\t\t\tif (priv->state != CARD_STATE_UNKNOWN)\n\t\t\t\t\tpriv->ext_caps |= EXT_CAP_LCS;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (priv->bcd_version >= OPENPGP_CARD_3_1) {\n\t\tcard->caps |= SC_CARD_CAP_ISO7816_PIN_INFO;\n\t}\n\n\tif ((pgp_get_blob(card, priv->mf, 0x006e, &blob6e) >= 0) &&\n\t    (pgp_get_blob(card, blob6e, 0x0073, &blob73) >= 0)) {\n\n\t\t/* get \"extended capabilities\" DO */\n\t\tif ((pgp_get_blob(card, blob73, 0x00c0, &blob) >= 0) &&\n\t\t    (blob->data != NULL) && (blob->len > 0)) {\n\t\t\t/* v2.0+: bit 0x04 in first byte means \"algorithm attributes changeable\" */\n\t\t\tif ((blob->data[0] & 0x04) &&\n\t\t\t\t\t(priv->bcd_version >= OPENPGP_CARD_2_0))\n\t\t\t\tpriv->ext_caps |= EXT_CAP_ALG_ATTR_CHANGEABLE;\n\t\t\t/* bit 0x08 in first byte means \"support for private use DOs\" */\n\t\t\tif (blob->data[0] & 0x08)\n\t\t\t\tpriv->ext_caps |= EXT_CAP_PRIVATE_DO;\n\t\t\t/* bit 0x10 in first byte means \"support for CHV status byte changeable\" */\n\t\t\tif (blob->data[0] & 0x10)\n\t\t\t\tpriv->ext_caps |= EXT_CAP_C4_CHANGEABLE;\n\t\t\t/* bit 0x20 in first byte means \"support for Key Import\" */\n\t\t\tif (blob->data[0] & 0x20)\n\t\t\t\tpriv->ext_caps |= EXT_CAP_KEY_IMPORT;\n\t\t\t/* bit 0x40 in first byte means \"support for Get Challenge\" */\n\t\t\tif (blob->data[0] & 0x40) {\n\t\t\t\tcard->caps |= SC_CARD_CAP_RNG;\n\t\t\t\tpriv->ext_caps |= EXT_CAP_GET_CHALLENGE;\n\t\t\t}\n\t\t\t/* v2.0+: bit 0x80 in first byte means \"support Secure Messaging\" */\n\t\t\tif ((blob->data[0] & 0x80) &&\n\t\t\t\t\t(priv->bcd_version >= OPENPGP_CARD_2_0))\n\t\t\t\tpriv->ext_caps |= EXT_CAP_SM;\n\n\t\t\tif ((priv->bcd_version >= OPENPGP_CARD_2_0) && (blob->len >= 10)) {\n\t\t\t\t/* v2.0+: max. challenge size is at bytes 3-4 */\n\t\t\t\tpriv->max_challenge_size = bebytes2ushort(blob->data + 2);\n\t\t\t\t/* v2.0+: max. cert size it at bytes 5-6 */\n\t\t\t\tpriv->max_cert_size = bebytes2ushort(blob->data + 4);\n\n\t\t\t\tif (priv->bcd_version < OPENPGP_CARD_3_0) {\n\t\t\t\t\t/* v2.x: SM algorithm is at byte 2: 0 == 3DES */\n\t\t\t\t\tpriv->sm_algo = blob->data[1];\n\t\t\t\t\tif ((priv->sm_algo == SM_ALGO_NONE) && (priv->ext_caps & EXT_CAP_SM))\n\t\t\t\t\t\tpriv->sm_algo = SM_ALGO_3DES;\n\n\t\t\t\t\t/* v2.x: max. send/receive sizes are at bytes 7-8 resp. 9-10 */\n\t\t\t\t\tcard->max_send_size = bebytes2ushort(blob->data + 6);\n\t\t\t\t\tcard->max_recv_size = bebytes2ushort(blob->data + 8);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t/* v3.0+: SM algorithm is at byte 2: 0 == UNKNOWN */\n\t\t\t\t\tpriv->sm_algo = blob->data[1];\n\t\t\t\t\tif ((priv->sm_algo == SM_ALGO_NONE) && (priv->ext_caps & EXT_CAP_SM))\n\t\t\t\t\t\tpriv->sm_algo = SM_ALGO_UNKNOWN;\n\t\t\t\t}\n\t\t\t\tif (priv->bcd_version >= OPENPGP_CARD_3_3 && (blob->len >= 10)) {\n\t\t\t\t\t/* v3.3+: MSE for key numbers 2(DEC) and 3(AUT) supported */\n\t\t\t\t\tif (blob->data[9])\n\t\t\t\t\t\tpriv->ext_caps |= EXT_CAP_MSE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* get max. PIN length from \"CHV status bytes\" DO */\n\t\tif ((pgp_get_blob(card, blob73, 0x00c4, &blob) >= 0) &&\n\t\t\t(blob->data != NULL) && (blob->len > 1)) {\n\t\t\t/* 2nd byte in \"CHV status bytes\" DO means \"max. PIN length\" */\n\t\t\tcard->max_pin_len = blob->data[1];\n\t\t}\n\n\t\t/* get _current_ algorithms & key lengths from \"algorithm attributes\" DOs\n\t\t *\n\t\t * All available algorithms should be already provided by pgp_init. However, if another\n\t\t * algorithm is found in the \"algorithm attributes\" DOs, it is supported by the card as\n\t\t * well and therefore added\n\t\t * see OpenPGP card spec 1.1 & 2.x section 4.3.3.6 / v3.x section 4.4.3.7 */\n\t\tfor (i = 0x00c1; i <= 0x00c3; i++) {\n\t\t\tsc_cardctl_openpgp_keygen_info_t key_info;\n\n\t\t\t/* OpenPGP card spec 1.1 & 2.x section 4.3.3.6 / v3.x section 4.4.3.7 */\n\t\t\tif ((pgp_get_blob(card, blob73, i, &blob) >= 0) &&\n\t\t\t    (pgp_parse_algo_attr_blob(blob, &key_info) >= 0)) {\n\n\t\t\t\t/* RSA [RFC 4880] */\n\t\t\t\tif (key_info.algorithm == SC_OPENPGP_KEYALGO_RSA){\n\t\t\t\t\t/* OpenPGP card spec 1.1 & 2.x, section 7.2.9 & 7.2.10 /\n\t\t\t\t\t * v3.x section 7.2.11 & 7.2.12 */\n\t\t\t\t\tunsigned long flags = SC_ALGORITHM_RSA_PAD_PKCS1 |\n\t\t\t\t\t\t  SC_ALGORITHM_RSA_HASH_NONE |\n\t\t\t\t\t\t  SC_ALGORITHM_ONBOARD_KEY_GEN;\t/* key gen on card */\n\t\t\t\t\t_sc_card_add_rsa_alg(card, key_info.u.rsa.modulus_len, flags, 0);\n\t\t\t\t}\n\t\t\t\t/* v3.0+: ECC [RFC 4880 & 6637] */\n\t\t\t\telse if (key_info.algorithm == SC_OPENPGP_KEYALGO_ECDH\n\t\t\t\t\t|| key_info.algorithm == SC_OPENPGP_KEYALGO_ECDSA) {\n\n\t\t\t\t\tunsigned long flags, ext_flags;\n\n\t\t\t\t\tif (key_info.algorithm == SC_OPENPGP_KEYALGO_ECDH)\n\t\t\t\t\t\tflags = SC_ALGORITHM_ECDH_CDH_RAW;\n\t\t\t\t\tif (key_info.algorithm == SC_OPENPGP_KEYALGO_ECDSA)\n\t\t\t\t\t\tflags = SC_ALGORITHM_ECDSA_RAW;\n\t\t\t\t\tflags |= SC_ALGORITHM_ECDSA_HASH_NONE;\n\t\t\t\t\tflags |= SC_ALGORITHM_ONBOARD_KEY_GEN;\n\t\t\t\t\text_flags =  SC_ALGORITHM_EXT_EC_NAMEDCURVE;\n\n\t\t\t\t\t_sc_card_add_ec_alg(card, key_info.u.ec.key_length, flags, ext_flags,\n\t\t\t\t\t\t\t&key_info.u.ec.oid);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (priv->bcd_version >= OPENPGP_CARD_3_0) {\n\t\t\t/* v3.0+: get length info from \"extended length information\" DO */\n\t\t\tif ((pgp_get_blob(card, blob6e, 0x7f66, &blob) >= 0) &&\n\t\t\t\t(blob->data != NULL) && (blob->len >= 8)) {\n\t\t\t\t/* kludge: treat as SIMPLE DO and use appropriate offsets */\n\t\t\t\tcard->max_send_size = bebytes2ushort(blob->data + 2);\n\t\t\t\tcard->max_recv_size = bebytes2ushort(blob->data + 6);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn SC_SUCCESS;\n}\n\nstatic int\npgp_init(sc_card_t *card)\n{\n\tstruct pgp_priv_data *priv;\n\tsc_path_t\tpath;\n\tsc_file_t\t*file = NULL;\n\tstruct do_info\t*info;\n\tint\t\tr, i;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tpriv = calloc (1, sizeof *priv);\n\tif (!priv)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\tcard->drv_data = priv;\n\n\tcard->cla = 0x00;\n\n\t/* select application \"OpenPGP\" */\n\tsc_format_path(\"D276:0001:2401\", &path);\n\tpath.type = SC_PATH_TYPE_DF_NAME;\n\tif ((r = iso_ops->select_file(card, &path, &file)) < 0) {\n\t\tsc_file_free(file);\n\t\tpgp_finish(card);\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_CARD);\n\t}\n\n\t/* defensive programming check */\n\tif (!file)   {\n\t\tpgp_finish(card);\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_CARD);\n\t}\n\n\tif (file->namelen != 16) {\n\t\t/* explicitly get the full aid */\n\t\tr = get_full_pgp_aid(card, file);\n\t\tif (r < 0) {\n\t\t\tsc_file_free(file);\n\t\t\tpgp_finish(card);\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_CARD);\n\t\t}\n\t}\n\n\t/* read information from AID */\n\tif (file->namelen == 16) {\n\t\tstatic char card_name[SC_MAX_APDU_BUFFER_SIZE] = \"OpenPGP card\";\n\n\t\t/* OpenPGP card spec 1.1, 2.x & 3.x, section 4.2.1 & 4.1.2.1 */\n\t\tpriv->bcd_version = bebytes2ushort(file->name + 6);\n\t\tcard->version.fw_major = card->version.hw_major = BCD2UCHAR(file->name[6]);\n\t\tcard->version.fw_minor = card->version.hw_minor = BCD2UCHAR(file->name[7]);\n\n\t\t/* for \"standard\" cards, include detailed card version & serial no. in card name */\n\t\tif (card->name == default_cardname_v1 ||\n\t\t    card->name == default_cardname_v2 ||\n\t\t    card->name == default_cardname_v3) {\n\t\t\tsnprintf(card_name, sizeof(card_name),\n\t\t\t\t \"OpenPGP card v%u.%u (%04X %08lX)\",\n\t\t\t\t card->version.hw_major, card->version.hw_minor,\n\t\t\t\t bebytes2ushort(file->name + 8),\n\t\t\t\t bebytes2ulong(file->name + 10));\n\t\t}\n\t\telse if (card->name != NULL) {\n\t\t\t/* for other cards, append serial number to the card name */\n\t\t\tsnprintf(card_name, sizeof(card_name),\n\t\t\t\t \"%s (%04X %08lX)\",\n\t\t\t\t card->name,\n\t\t\t\t bebytes2ushort(file->name + 8),\n\t\t\t\t bebytes2ulong(file->name + 10));\n\t\t}\n\t\tcard->name = card_name;\n\n\t\t/* GPG compatibility: set card's serial number to manufacturer ID + serial number */\n\t\tmemcpy(card->serialnr.value, file->name + 8, 6);\n\t\tcard->serialnr.len = 6;\n\t} else {\n\t\t/* set detailed card version */\n\t\tswitch (card->type) {\n\t\t\tcase SC_CARD_TYPE_OPENPGP_V3:\n\t\t\t\tpriv->bcd_version = OPENPGP_CARD_3_0;\n\t\t\t\tbreak;\n\t\t\tcase SC_CARD_TYPE_OPENPGP_GNUK:\n\t\t\tcase SC_CARD_TYPE_OPENPGP_V2:\n\t\t\t\tpriv->bcd_version = OPENPGP_CARD_2_0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpriv->bcd_version = OPENPGP_CARD_1_1;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* set pointer to correct list of card objects */\n\tpriv->pgp_objects = (priv->bcd_version < OPENPGP_CARD_2_0) ? pgp1x_objects\n\t\t\t  : (priv->bcd_version < OPENPGP_CARD_2_1) ? pgp20_objects\n\t\t\t  : (priv->bcd_version < OPENPGP_CARD_3_0) ? pgp21_objects\n\t\t\t  : (priv->bcd_version < OPENPGP_CARD_3_3) ? pgp30_objects\n\t\t\t  :\t\t\t\t\t     pgp33_objects;\n\n\t/* change file path to MF for re-use in MF */\n\tsc_format_path(\"3f00\", &file->path);\n\n\t/* set up the root of our fake file tree */\n\t/* Transfers ownership of the file to the priv->mf structure */\n\tpriv->mf = pgp_new_blob(card, NULL, 0x3f00, file);\n\tif (!priv->mf) {\n\t\tsc_file_free(file);\n\t\tpgp_finish(card);\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t}\n\n\t/* select MF */\n\tpriv->current = priv->mf;\n\n\t/* populate MF - add matching blobs listed in the pgp_objects table */\n\tfor (info = priv->pgp_objects; (info != NULL) && (info->id > 0); info++) {\n\t\tif (((info->access & READ_MASK) != READ_NEVER) && (info->get_fn != NULL)) {\n\t\t\tpgp_blob_t *child = NULL;\n\n\t\t\tchild = pgp_new_blob(card, priv->mf, info->id, sc_file_new());\n\n\t\t\t/* catch out of memory condition */\n\t\t\tif (child == NULL) {\n\t\t\t\tpgp_finish(card);\n\t\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* get card_features from ATR & DOs */\n\tpgp_get_card_features(card);\n\n\t/* if algorithm attributes can be changed,\n\t * add supported algorithms based on specification for pkcs15-init */\n\tif ((priv->ext_caps & EXT_CAP_ALG_ATTR_CHANGEABLE) &&\n\t    (strcmp(card->ctx->app_name, \"pkcs15-init\") == 0)) {\n\t\tunsigned long flags_rsa, flags_ecc, ext_flags;\n\n\t\t/* OpenPGP card spec 1.1 & 2.x, section 7.2.9 & 7.2.10 / v3.x section 7.2.11 & 7.2.12 */\n\t\tflags_rsa = SC_ALGORITHM_RSA_PAD_PKCS1|\n\t\t\t    SC_ALGORITHM_RSA_HASH_NONE|\n\t\t\t    SC_ALGORITHM_ONBOARD_KEY_GEN;\n\t\tflags_ecc = SC_ALGORITHM_ECDSA_RAW|\n\t\t\t    SC_ALGORITHM_ECDH_CDH_RAW|\n\t\t\t    SC_ALGORITHM_ECDSA_HASH_NONE|\n\t\t\t    SC_ALGORITHM_ONBOARD_KEY_GEN;\n\t\text_flags = SC_ALGORITHM_EXT_EC_NAMEDCURVE;\n\n\t\tswitch (card->type) {\n\t\t\tcase SC_CARD_TYPE_OPENPGP_V3:\n\t\t\t\t/* RSA 1024 was removed for v3+ */\n\t\t\t\t_sc_card_add_rsa_alg(card, 2048, flags_rsa, 0);\n\t\t\t\t_sc_card_add_rsa_alg(card, 3072, flags_rsa, 0);\n\t\t\t\t_sc_card_add_rsa_alg(card, 4096, flags_rsa, 0);\n\t\t\t\t/* v3.0+ supports: [RFC 4880 & 6637] 0x12 = ECDH, 0x13 = ECDSA */\n\t\t\t\tfor (i=0; ec_curves[i].oid.value[0] >= 0; i++)\n\t\t\t\t{\n\t\t\t\t\t_sc_card_add_ec_alg(card, ec_curves[i].size, flags_ecc, ext_flags, &ec_curves[i].oid);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase SC_CARD_TYPE_OPENPGP_GNUK:\n\t\t\t\t_sc_card_add_rsa_alg(card, 2048, flags_rsa, 0);\n\t\t\t\t/* TODO add ECC for more recent Gnuk (1.2.x)\n\t\t\t\t * these are not include in SC_CARD_TYPE_OPENPGP_GNUK, but\n\t\t\t\t * are treated like SC_CARD_TYPE_OPENPGP_V2\n\t\t\t\t * Gnuk supports NIST, SECG and Curve25519 from version 1.2.x on */\n\t\t\t\tbreak;\n\t\t\tcase SC_CARD_TYPE_OPENPGP_V2:\n\t\t\tdefault:\n\t\t\t\t_sc_card_add_rsa_alg(card, 1024, flags_rsa, 0);\n\t\t\t\t_sc_card_add_rsa_alg(card, 2048, flags_rsa, 0);\n\t\t\t\t_sc_card_add_rsa_alg(card, 3072, flags_rsa, 0);\n\t\t\t\t_sc_card_add_rsa_alg(card, 4096, flags_rsa, 0);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}\n\nint sc_connect_card(sc_reader_t *reader, sc_card_t **card_out)\n{\n\tsc_card_t *card;\n\tsc_context_t *ctx;\n\tstruct sc_card_driver *driver;\n\tint i, r = 0, idx, connected = 0;\n\n\tif (card_out == NULL || reader == NULL)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\tctx = reader->ctx;\n\tSC_FUNC_CALLED(ctx, SC_LOG_DEBUG_VERBOSE);\n\tif (reader->ops->connect == NULL)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_NOT_SUPPORTED);\n\n\tcard = sc_card_new(ctx);\n\tif (card == NULL)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY);\n\tr = reader->ops->connect(reader);\n\tif (r)\n\t\tgoto err;\n\n\tconnected = 1;\n\tcard->reader = reader;\n\tcard->ctx = ctx;\n\n\tif (reader->flags & SC_READER_ENABLE_ESCAPE)\n\t\tsc_detect_escape_cmds(reader);\n\n\tmemcpy(&card->atr, &reader->atr, sizeof(card->atr));\n\tmemcpy(&card->uid, &reader->uid, sizeof(card->uid));\n\n\t_sc_parse_atr(reader);\n\n\t/* See if the ATR matches any ATR specified in the config file */\n\tif ((driver = ctx->forced_driver) == NULL) {\n\t\tsc_log(ctx, \"matching configured ATRs\");\n\t\tfor (i = 0; ctx->card_drivers[i] != NULL; i++) {\n\t\t\tdriver = ctx->card_drivers[i];\n\n\t\t\tif (driver->atr_map == NULL ||\n\t\t\t    !strcmp(driver->short_name, \"default\")) {\n\t\t\t\tdriver = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsc_log(ctx, \"trying driver '%s'\", driver->short_name);\n\t\t\tidx = _sc_match_atr(card, driver->atr_map, NULL);\n\t\t\tif (idx >= 0) {\n\t\t\t\tstruct sc_atr_table *src = &driver->atr_map[idx];\n\n\t\t\t\tsc_log(ctx, \"matched driver '%s'\", driver->name);\n\t\t\t\t/* It's up to card driver to notice these correctly */\n\t\t\t\tcard->name = src->name;\n\t\t\t\tcard->type = src->type;\n\t\t\t\tcard->flags = src->flags;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdriver = NULL;\n\t\t}\n\t}\n\n\tif (driver != NULL) {\n\t\t/* Forced driver, or matched via ATR mapping from config file */\n\t\tcard->driver = driver;\n\n\t\tmemcpy(card->ops, card->driver->ops, sizeof(struct sc_card_operations));\n\t\tif (card->ops->match_card != NULL)\n\t\t\tif (card->ops->match_card(card) != 1)\n\t\t\t\tsc_log(ctx, \"driver '%s' match_card() failed: %s (will continue anyway)\", card->driver->name, sc_strerror(r));\n\n\t\tif (card->ops->init != NULL) {\n\t\t\tr = card->ops->init(card);\n\t\t\tif (r) {\n\t\t\t\tsc_log(ctx, \"driver '%s' init() failed: %s\", card->driver->name, sc_strerror(r));\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tsc_card_t uninitialized = *card;\n\t\tsc_log(ctx, \"matching built-in ATRs\");\n\t\tfor (i = 0; ctx->card_drivers[i] != NULL; i++) {\n\t\t\t/* FIXME If we had a clean API description, we'd propably get a\n\t\t\t * cleaner implementation of the driver's match_card and init,\n\t\t\t * which should normally *not* modify the card object if\n\t\t\t * unsuccessful. However, after years of relentless hacking, reality\n\t\t\t * is different: The card object is changed in virtually every card\n\t\t\t * driver so in order to prevent unwanted interaction, we reset the\n\t\t\t * card object here and hope that the card driver at least doesn't\n\t\t\t * allocate any internal ressources that need to be freed. If we\n\t\t\t * had more time, we should refactor the existing code to not\n\t\t\t * modify sc_card_t until complete success (possibly by combining\n\t\t\t * `match_card()` and `init()`) */\n\t\t\t*card = uninitialized;\n\n\t\t\tstruct sc_card_driver *drv = ctx->card_drivers[i];\n\t\t\tconst struct sc_card_operations *ops = drv->ops;\n\n\t\t\tsc_log(ctx, \"trying driver '%s'\", drv->short_name);\n\t\t\tif (ops == NULL || ops->match_card == NULL)   {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (!(ctx->flags & SC_CTX_FLAG_ENABLE_DEFAULT_DRIVER)\n\t\t\t\t   \t&& !strcmp(\"default\", drv->short_name))   {\n\t\t\t\tsc_log(ctx , \"ignore 'default' card driver\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Needed if match_card() needs to talk with the card (e.g. card-muscle) */\n\t\t\t*card->ops = *ops;\n\t\t\tif (ops->match_card(card) != 1)\n\t\t\t\tcontinue;\n\t\t\tsc_log(ctx, \"matched: %s\", drv->name);\n\t\t\tmemcpy(card->ops, ops, sizeof(struct sc_card_operations));\n\t\t\tcard->driver = drv;\n\t\t\tr = ops->init(card);\n\t\t\tif (r) {\n\t\t\t\tsc_log(ctx, \"driver '%s' init() failed: %s\", drv->name, sc_strerror(r));\n\t\t\t\tif (r == SC_ERROR_INVALID_CARD) {\n\t\t\t\t\tcard->driver = NULL;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (card->driver == NULL) {\n\t\tsc_log(ctx, \"unable to find driver for inserted card\");\n\t\tr = SC_ERROR_INVALID_CARD;\n\t\tgoto err;\n\t}\n\tif (card->name == NULL)\n\t\tcard->name = card->driver->name;\n\n\t/* initialize max_send_size/max_recv_size to a meaningful value */\n\tcard->max_recv_size = sc_get_max_recv_size(card);\n\tcard->max_send_size = sc_get_max_send_size(card);\n\n\tsc_log(ctx,\n\t       \"card info name:'%s', type:%i, flags:0x%lX, max_send/recv_size:%\"SC_FORMAT_LEN_SIZE_T\"u/%\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t       card->name, card->type, card->flags, card->max_send_size,\n\t       card->max_recv_size);\n\n#ifdef ENABLE_SM\n        /* Check, if secure messaging module present. */\n\tr = sc_card_sm_check(card);\n\tif (r)   {\n\t\tsc_log(ctx, \"cannot load secure messaging module\");\n\t\tgoto err;\n\t}\n#endif\n\t*card_out = card;\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\nerr:\n\tif (connected)\n\t\treader->ops->disconnect(reader);\n\tif (card != NULL)\n\t\tsc_card_free(card);\n\tLOG_FUNC_RETURN(ctx, r);\n}\n\n\n// target function\nstatic int\npgp_parse_algo_attr_blob(const pgp_blob_t *blob, sc_cardctl_openpgp_keygen_info_t *key_info)\n{\n\tstruct sc_object_id oid;\n\tunsigned int j;\n\n\tif (blob == NULL || blob->data == NULL || blob->len == 0 ||\n\t    blob->id < 0x00c1 || blob->id > 0x00c3 || key_info == NULL)\n\t\treturn SC_ERROR_INCORRECT_PARAMETERS;\n\n\tkey_info->key_id = blob->id - 0x00c0;\t/* attribute algorithm blobs are C1 - C3 */\n\n\tswitch (blob->data[0]) {\n\t\tcase SC_OPENPGP_KEYALGO_RSA:\n\t\t\tif (blob->len < 5)\n\t\t\t\treturn SC_ERROR_INCORRECT_PARAMETERS;\n\n\t\t\tkey_info->algorithm = SC_OPENPGP_KEYALGO_RSA;\n\t\t\tkey_info->u.rsa.modulus_len = bebytes2ushort(blob->data + 1);\n\t\t\tkey_info->u.rsa.exponent_len = bebytes2ushort(blob->data + 3);\n\n\t\t\tkey_info->u.rsa.keyformat = (blob->len > 5)\n\t\t\t\t\t\t  ? blob->data[5]\n\t\t\t\t\t\t  : SC_OPENPGP_KEYFORMAT_RSA_STD;\n\t\t\tbreak;\n\t\tcase SC_OPENPGP_KEYALGO_ECDH:\n\t\tcase SC_OPENPGP_KEYALGO_ECDSA:\n\n\t\t\t/* SC_OPENPGP_KEYALGO_ECDH || SC_OPENPGP_KEYALGO_ECDSA */\n\t\t\tkey_info->algorithm = blob->data[0];\n\n\t\t\tsc_init_oid(&oid);\n\t\t\t/* Create copy of oid from blob */\n\t\t\tfor (j=0; j < (blob->len-1); j++) {\n\t\t\t\toid.value[j] = blob->data[j+1]; /* ignore first byte of blob (algo ID) */\n\t\t\t}\n\n\t\t\t/* compare with list of supported ec_curves */\n\t\t\tfor (j=0; ec_curves[j].oid.value[0] >= 0; j++){\n\t\t\t\tif (sc_compare_oid(&ec_curves[j].oid_binary, &oid)){\n\t\t\t\t\tkey_info->u.ec.oid = ec_curves[j].oid;\n\t\t\t\t\tkey_info->u.ec.key_length = ec_curves[j].size;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn SC_ERROR_NOT_IMPLEMENTED;\n\t}\n\n\treturn SC_SUCCESS;\n}\n",
    "target": 1,
    "idx": 1019548,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "// context\nstatic void backup_lpf(const Dav1dFrameContext *const f,\n                       pixel *dst, const ptrdiff_t dst_stride,\n                       const pixel *src, const ptrdiff_t src_stride,\n                       const int ss_ver, const int sb128,\n                       int row, const int row_h, const int src_w,\n                       const int h, const int ss_hor)\n{\n    const int dst_w = f->frame_hdr->super_res.enabled ?\n                      (f->frame_hdr->width[1] + ss_hor) >> ss_hor : src_w;\n\n    // The first stripe of the frame is shorter by 8 luma pixel rows.\n    int stripe_h = (64 - 8 * !row) >> ss_ver;\n    src += (stripe_h - 2) * PXSTRIDE(src_stride);\n\n    if (f->c->n_tc == 1) {\n        if (row) {\n            const int top = 4 << sb128;\n            // Copy the top part of the stored loop filtered pixels from the\n            // previous sb row needed above the first stripe of this sb row.\n            pixel_copy(&dst[PXSTRIDE(dst_stride) *  0],\n                       &dst[PXSTRIDE(dst_stride) *  top],      dst_w);\n            pixel_copy(&dst[PXSTRIDE(dst_stride) *  1],\n                       &dst[PXSTRIDE(dst_stride) * (top + 1)], dst_w);\n            pixel_copy(&dst[PXSTRIDE(dst_stride) *  2],\n                       &dst[PXSTRIDE(dst_stride) * (top + 2)], dst_w);\n            pixel_copy(&dst[PXSTRIDE(dst_stride) *  3],\n                       &dst[PXSTRIDE(dst_stride) * (top + 3)], dst_w);\n        }\n        dst += 4 * PXSTRIDE(dst_stride);\n    }\n\n    if (f->frame_hdr->width[0] != f->frame_hdr->width[1]) {\n        while (row + stripe_h <= row_h) {\n            const int n_lines = 4 - (row + stripe_h + 1 == h);\n            f->dsp->mc.resize(dst, dst_stride, src, src_stride,\n                              dst_w, n_lines, src_w, f->resize_step[ss_hor],\n                              f->resize_start[ss_hor] HIGHBD_CALL_SUFFIX);\n            row += stripe_h; // unmodified stripe_h for the 1st stripe\n            stripe_h = 64 >> ss_ver;\n            src += stripe_h * PXSTRIDE(src_stride);\n            dst += n_lines * PXSTRIDE(dst_stride);\n            if (n_lines == 3) {\n                pixel_copy(dst, &dst[-PXSTRIDE(dst_stride)], dst_w);\n                dst += PXSTRIDE(dst_stride);\n            }\n        }\n    } else {\n        while (row + stripe_h <= row_h) {\n            const int n_lines = 4 - (row + stripe_h + 1 == h);\n            for (int i = 0; i < 4; i++) {\n                pixel_copy(dst, i == n_lines ? &dst[-PXSTRIDE(dst_stride)] :\n                                               src, src_w);\n                dst += PXSTRIDE(dst_stride);\n                src += PXSTRIDE(src_stride);\n            }\n            row += stripe_h; // unmodified stripe_h for the 1st stripe\n            stripe_h = 64 >> ss_ver;\n            src += (stripe_h - 4) * PXSTRIDE(src_stride);\n        }\n    }\n}\n\n\n\n\n\n\n\n\n// target function\nint dav1d_decode_frame_init(Dav1dFrameContext *const f) {\n    const Dav1dContext *const c = f->c;\n    int retval = DAV1D_ERR(ENOMEM);\n\n    if (f->sbh > f->lf.start_of_tile_row_sz) {\n        free(f->lf.start_of_tile_row);\n        f->lf.start_of_tile_row = malloc(f->sbh * sizeof(uint8_t));\n        if (!f->lf.start_of_tile_row) {\n            f->lf.start_of_tile_row_sz = 0;\n            goto error;\n        }\n        f->lf.start_of_tile_row_sz = f->sbh;\n    }\n    int sby = 0;\n    for (int tile_row = 0; tile_row < f->frame_hdr->tiling.rows; tile_row++) {\n        f->lf.start_of_tile_row[sby++] = tile_row;\n        while (sby < f->frame_hdr->tiling.row_start_sb[tile_row + 1])\n            f->lf.start_of_tile_row[sby++] = 0;\n    }\n\n    const int n_ts = f->frame_hdr->tiling.cols * f->frame_hdr->tiling.rows;\n    if (n_ts != f->n_ts) {\n        if (c->n_fc > 1) {\n            freep(&f->frame_thread.tile_start_off);\n            f->frame_thread.tile_start_off =\n                malloc(sizeof(*f->frame_thread.tile_start_off) * n_ts);\n            if (!f->frame_thread.tile_start_off) {\n                f->n_ts = 0;\n                goto error;\n            }\n        }\n        Dav1dTileState *ts_new = dav1d_alloc_aligned(sizeof(*f->ts) * n_ts, 32);\n        if (!ts_new) goto error;\n        if (f->ts) {\n            memcpy(ts_new, f->ts, sizeof(*f->ts) * imin(n_ts, f->n_ts));\n            dav1d_free_aligned(f->ts);\n        }\n        f->n_ts = n_ts;\n        f->ts = ts_new;\n    }\n\n    const int a_sz = f->sb128w * f->frame_hdr->tiling.rows * (1 + (c->n_fc > 1 && c->n_tc > 1));\n    if (a_sz != f->a_sz) {\n        freep(&f->a);\n        f->a = malloc(sizeof(*f->a) * a_sz);\n        if (!f->a) {\n            f->a_sz = 0;\n            goto error;\n        }\n        f->a_sz = a_sz;\n    }\n\n    const int num_sb128 = f->sb128w * f->sb128h;\n    const uint8_t *const size_mul = ss_size_mul[f->cur.p.layout];\n    const int hbd = !!f->seq_hdr->hbd;\n    if (c->n_fc > 1) {\n        int tile_idx = 0;\n        for (int tile_row = 0; tile_row < f->frame_hdr->tiling.rows; tile_row++) {\n            int row_off = f->frame_hdr->tiling.row_start_sb[tile_row] *\n                          f->sb_step * 4 * f->sb128w * 128;\n            int b_diff = (f->frame_hdr->tiling.row_start_sb[tile_row + 1] -\n                          f->frame_hdr->tiling.row_start_sb[tile_row]) * f->sb_step * 4;\n            for (int tile_col = 0; tile_col < f->frame_hdr->tiling.cols; tile_col++) {\n                f->frame_thread.tile_start_off[tile_idx++] = row_off + b_diff *\n                    f->frame_hdr->tiling.col_start_sb[tile_col] * f->sb_step * 4;\n            }\n        }\n\n        const int lowest_pixel_mem_sz = f->frame_hdr->tiling.cols * f->sbh;\n        if (lowest_pixel_mem_sz != f->tile_thread.lowest_pixel_mem_sz) {\n            free(f->tile_thread.lowest_pixel_mem);\n            f->tile_thread.lowest_pixel_mem =\n                malloc(lowest_pixel_mem_sz * sizeof(*f->tile_thread.lowest_pixel_mem));\n            if (!f->tile_thread.lowest_pixel_mem) {\n                f->tile_thread.lowest_pixel_mem_sz = 0;\n                goto error;\n            }\n            f->tile_thread.lowest_pixel_mem_sz = lowest_pixel_mem_sz;\n        }\n        int (*lowest_pixel_ptr)[7][2] = f->tile_thread.lowest_pixel_mem;\n        for (int tile_row = 0, tile_row_base = 0; tile_row < f->frame_hdr->tiling.rows;\n             tile_row++, tile_row_base += f->frame_hdr->tiling.cols)\n        {\n            const int tile_row_sb_h = f->frame_hdr->tiling.row_start_sb[tile_row + 1] -\n                                      f->frame_hdr->tiling.row_start_sb[tile_row];\n            for (int tile_col = 0; tile_col < f->frame_hdr->tiling.cols; tile_col++) {\n                f->ts[tile_row_base + tile_col].lowest_pixel = lowest_pixel_ptr;\n                lowest_pixel_ptr += tile_row_sb_h;\n            }\n        }\n\n        const int cf_sz = (num_sb128 * size_mul[0]) << hbd;\n        if (cf_sz != f->frame_thread.cf_sz) {\n            dav1d_freep_aligned(&f->frame_thread.cf);\n            f->frame_thread.cf =\n                dav1d_alloc_aligned((size_t)cf_sz * 128 * 128 / 2, 32);\n            if (!f->frame_thread.cf) {\n                f->frame_thread.cf_sz = 0;\n                goto error;\n            }\n            memset(f->frame_thread.cf, 0, (size_t)cf_sz * 128 * 128 / 2);\n            f->frame_thread.cf_sz = cf_sz;\n        }\n\n        if (f->frame_hdr->allow_screen_content_tools) {\n            if (num_sb128 != f->frame_thread.pal_sz) {\n                dav1d_freep_aligned(&f->frame_thread.pal);\n                f->frame_thread.pal =\n                    dav1d_alloc_aligned(sizeof(*f->frame_thread.pal) *\n                                        num_sb128 * 16 * 16, 32);\n                if (!f->frame_thread.pal) {\n                    f->frame_thread.pal_sz = 0;\n                    goto error;\n                }\n                f->frame_thread.pal_sz = num_sb128;\n            }\n\n            const int pal_idx_sz = num_sb128 * size_mul[1];\n            if (pal_idx_sz != f->frame_thread.pal_idx_sz) {\n                dav1d_freep_aligned(&f->frame_thread.pal_idx);\n                f->frame_thread.pal_idx =\n                    dav1d_alloc_aligned(sizeof(*f->frame_thread.pal_idx) *\n                                        pal_idx_sz * 128 * 128 / 4, 32);\n                if (!f->frame_thread.pal_idx) {\n                    f->frame_thread.pal_idx_sz = 0;\n                    goto error;\n                }\n                f->frame_thread.pal_idx_sz = pal_idx_sz;\n            }\n        } else if (f->frame_thread.pal) {\n            dav1d_freep_aligned(&f->frame_thread.pal);\n            dav1d_freep_aligned(&f->frame_thread.pal_idx);\n            f->frame_thread.pal_sz = f->frame_thread.pal_idx_sz = 0;\n        }\n    }\n\n    // update allocation of block contexts for above\n    const ptrdiff_t y_stride = f->cur.stride[0], uv_stride = f->cur.stride[1];\n    if (y_stride != f->lf.cdef_line_sz[0] || uv_stride != f->lf.cdef_line_sz[1]) {\n        dav1d_free_aligned(f->lf.cdef_line_buf);\n        size_t alloc_sz = 64;\n        alloc_sz += (y_stride  < 0 ? -y_stride  : y_stride ) * 4;\n        alloc_sz += (uv_stride < 0 ? -uv_stride : uv_stride) * 8;\n        uint8_t *ptr = f->lf.cdef_line_buf = dav1d_alloc_aligned(alloc_sz, 32);\n        if (!ptr) {\n            f->lf.cdef_line_sz[0] = f->lf.cdef_line_sz[1] = 0;\n            goto error;\n        }\n\n        ptr += 32;\n        if (y_stride < 0) {\n            f->lf.cdef_line[0][0] = ptr - y_stride * 1;\n            f->lf.cdef_line[1][0] = ptr - y_stride * 3;\n            ptr -= y_stride * 4;\n        } else {\n            f->lf.cdef_line[0][0] = ptr + y_stride * 0;\n            f->lf.cdef_line[1][0] = ptr + y_stride * 2;\n            ptr += y_stride * 4;\n        }\n        if (uv_stride < 0) {\n            f->lf.cdef_line[0][1] = ptr - uv_stride * 1;\n            f->lf.cdef_line[0][2] = ptr - uv_stride * 3;\n            f->lf.cdef_line[1][1] = ptr - uv_stride * 5;\n            f->lf.cdef_line[1][2] = ptr - uv_stride * 7;\n        } else {\n            f->lf.cdef_line[0][1] = ptr + uv_stride * 0;\n            f->lf.cdef_line[0][2] = ptr + uv_stride * 2;\n            f->lf.cdef_line[1][1] = ptr + uv_stride * 4;\n            f->lf.cdef_line[1][2] = ptr + uv_stride * 6;\n        }\n\n        f->lf.cdef_line_sz[0] = (int) y_stride;\n        f->lf.cdef_line_sz[1] = (int) uv_stride;\n    }\n\n    const int lr_line_sz = ((f->sr_cur.p.p.w + 31) & ~31) << hbd;\n    if (lr_line_sz != f->lf.lr_line_sz) {\n        dav1d_freep_aligned(&f->lf.lr_lpf_line[0]);\n        const int num_lines = c->n_tc > 1 ? f->sbh * (4 << f->seq_hdr->sb128) : 12;\n        // lr simd may overread the input, so slightly over-allocate the lpf buffer\n        uint8_t *lr_ptr = dav1d_alloc_aligned(lr_line_sz * num_lines * 3 + 64, 32);\n        if (!lr_ptr) {\n            f->lf.lr_line_sz = 0;\n            goto error;\n        }\n\n        for (int pl = 0; pl <= 2; pl++) {\n            f->lf.lr_lpf_line[pl] = lr_ptr;\n            lr_ptr += lr_line_sz * num_lines;\n        }\n\n        f->lf.lr_line_sz = lr_line_sz;\n    }\n\n    // update allocation for loopfilter masks\n    if (num_sb128 != f->lf.mask_sz) {\n        freep(&f->lf.mask);\n        freep(&f->lf.level);\n        f->lf.mask = malloc(sizeof(*f->lf.mask) * num_sb128);\n        // over-allocate by 3 bytes since some of the SIMD implementations\n        // index this from the level type and can thus over-read by up to 3\n        f->lf.level = malloc(sizeof(*f->lf.level) * num_sb128 * 32 * 32 + 3);\n        if (!f->lf.mask || !f->lf.level) {\n            f->lf.mask_sz = 0;\n            goto error;\n        }\n        if (c->n_fc > 1) {\n            freep(&f->frame_thread.b);\n            freep(&f->frame_thread.cbi);\n            f->frame_thread.b = malloc(sizeof(*f->frame_thread.b) *\n                                       num_sb128 * 32 * 32);\n            f->frame_thread.cbi = malloc(sizeof(*f->frame_thread.cbi) *\n                                         num_sb128 * 32 * 32);\n            if (!f->frame_thread.b || !f->frame_thread.cbi) {\n                f->lf.mask_sz = 0;\n                goto error;\n            }\n        }\n        f->lf.mask_sz = num_sb128;\n    }\n\n    f->sr_sb128w = (f->sr_cur.p.p.w + 127) >> 7;\n    const int lr_mask_sz = f->sr_sb128w * f->sb128h;\n    if (lr_mask_sz != f->lf.lr_mask_sz) {\n        freep(&f->lf.lr_mask);\n        f->lf.lr_mask = malloc(sizeof(*f->lf.lr_mask) * lr_mask_sz);\n        if (!f->lf.lr_mask) {\n            f->lf.lr_mask_sz = 0;\n            goto error;\n        }\n        f->lf.lr_mask_sz = lr_mask_sz;\n    }\n    f->lf.restore_planes =\n        ((f->frame_hdr->restoration.type[0] != DAV1D_RESTORATION_NONE) << 0) +\n        ((f->frame_hdr->restoration.type[1] != DAV1D_RESTORATION_NONE) << 1) +\n        ((f->frame_hdr->restoration.type[2] != DAV1D_RESTORATION_NONE) << 2);\n    if (f->frame_hdr->loopfilter.sharpness != f->lf.last_sharpness) {\n        dav1d_calc_eih(&f->lf.lim_lut, f->frame_hdr->loopfilter.sharpness);\n        f->lf.last_sharpness = f->frame_hdr->loopfilter.sharpness;\n    }\n    dav1d_calc_lf_values(f->lf.lvl, f->frame_hdr, (int8_t[4]) { 0, 0, 0, 0 });\n    memset(f->lf.mask, 0, sizeof(*f->lf.mask) * num_sb128);\n\n    const int ipred_edge_sz = f->sbh * f->sb128w << hbd;\n    if (ipred_edge_sz != f->ipred_edge_sz) {\n        dav1d_freep_aligned(&f->ipred_edge[0]);\n        uint8_t *ptr = f->ipred_edge[0] =\n            dav1d_alloc_aligned(ipred_edge_sz * 128 * 3, 32);\n        if (!ptr) {\n            f->ipred_edge_sz = 0;\n            goto error;\n        }\n        f->ipred_edge[1] = ptr + ipred_edge_sz * 128 * 1;\n        f->ipred_edge[2] = ptr + ipred_edge_sz * 128 * 2;\n        f->ipred_edge_sz = ipred_edge_sz;\n    }\n\n    const int re_sz = f->sb128h * f->frame_hdr->tiling.cols;\n    if (re_sz != f->lf.re_sz) {\n        freep(&f->lf.tx_lpf_right_edge[0]);\n        f->lf.tx_lpf_right_edge[0] = malloc(re_sz * 32 * 2);\n        if (!f->lf.tx_lpf_right_edge[0]) {\n            f->lf.re_sz = 0;\n            goto error;\n        }\n        f->lf.tx_lpf_right_edge[1] = f->lf.tx_lpf_right_edge[0] + re_sz * 32;\n        f->lf.re_sz = re_sz;\n    }\n\n    // init ref mvs\n    if (IS_INTER_OR_SWITCH(f->frame_hdr) || f->frame_hdr->allow_intrabc) {\n        const int ret =\n            dav1d_refmvs_init_frame(&f->rf, f->seq_hdr, f->frame_hdr,\n                                    f->refpoc, f->mvs, f->refrefpoc, f->ref_mvs,\n                                    f->c->n_tc, f->c->n_fc);\n        if (ret < 0) goto error;\n    }\n\n    retval = DAV1D_ERR(EINVAL);\n\n    // setup dequant tables\n    init_quant_tables(f->seq_hdr, f->frame_hdr, f->frame_hdr->quant.yac, f->dq);\n    if (f->frame_hdr->quant.qm)\n        for (int i = 0; i < N_RECT_TX_SIZES; i++) {\n            f->qm[i][0] = dav1d_qm_tbl[f->frame_hdr->quant.qm_y][0][i];\n            f->qm[i][1] = dav1d_qm_tbl[f->frame_hdr->quant.qm_u][1][i];\n            f->qm[i][2] = dav1d_qm_tbl[f->frame_hdr->quant.qm_v][1][i];\n        }\n    else\n        memset(f->qm, 0, sizeof(f->qm));\n\n    // setup jnt_comp weights\n    if (f->frame_hdr->switchable_comp_refs) {\n        for (int i = 0; i < 7; i++) {\n            const unsigned ref0poc = f->refp[i].p.frame_hdr->frame_offset;\n\n            for (int j = i + 1; j < 7; j++) {\n                const unsigned ref1poc = f->refp[j].p.frame_hdr->frame_offset;\n\n                const unsigned d1 =\n                    imin(abs(get_poc_diff(f->seq_hdr->order_hint_n_bits, ref0poc,\n                                          f->cur.frame_hdr->frame_offset)), 31);\n                const unsigned d0 =\n                    imin(abs(get_poc_diff(f->seq_hdr->order_hint_n_bits, ref1poc,\n                                          f->cur.frame_hdr->frame_offset)), 31);\n                const int order = d0 <= d1;\n\n                static const uint8_t quant_dist_weight[3][2] = {\n                    { 2, 3 }, { 2, 5 }, { 2, 7 }\n                };\n                static const uint8_t quant_dist_lookup_table[4][2] = {\n                    { 9, 7 }, { 11, 5 }, { 12, 4 }, { 13, 3 }\n                };\n\n                int k;\n                for (k = 0; k < 3; k++) {\n                    const int c0 = quant_dist_weight[k][order];\n                    const int c1 = quant_dist_weight[k][!order];\n                    const int d0_c0 = d0 * c0;\n                    const int d1_c1 = d1 * c1;\n                    if ((d0 > d1 && d0_c0 < d1_c1) || (d0 <= d1 && d0_c0 > d1_c1)) break;\n                }\n\n                f->jnt_weights[i][j] = quant_dist_lookup_table[k][order];\n            }\n        }\n    }\n\n    /* Init loopfilter pointers. Increasing NULL pointers is technically UB,\n     * so just point the chroma pointers in 4:0:0 to the luma plane here to\n     * avoid having additional in-loop branches in various places. We never\n     * dereference those pointers so it doesn't really matter what they\n     * point at, as long as the pointers are valid. */\n    const int has_chroma = f->cur.p.layout != DAV1D_PIXEL_LAYOUT_I400;\n    f->lf.mask_ptr = f->lf.mask;\n    f->lf.p[0] = f->cur.data[0];\n    f->lf.p[1] = f->cur.data[has_chroma ? 1 : 0];\n    f->lf.p[2] = f->cur.data[has_chroma ? 2 : 0];\n    f->lf.sr_p[0] = f->sr_cur.p.data[0];\n    f->lf.sr_p[1] = f->sr_cur.p.data[has_chroma ? 1 : 0];\n    f->lf.sr_p[2] = f->sr_cur.p.data[has_chroma ? 2 : 0];\n\n    if (f->frame_hdr->refresh_context)\n        dav1d_cdf_thread_copy(f->out_cdf.data.cdf, &f->in_cdf);\n\n    // parse individual tiles per tile group\n    int tile_row = 0, tile_col = 0;\n    f->task_thread.update_set = 0;\n    for (int i = 0; i < f->n_tile_data; i++) {\n        const uint8_t *data = f->tile[i].data.data;\n        size_t size = f->tile[i].data.sz;\n\n        for (int j = f->tile[i].start; j <= f->tile[i].end; j++) {\n            size_t tile_sz;\n            if (j == f->tile[i].end) {\n                tile_sz = size;\n            } else {\n                if (f->frame_hdr->tiling.n_bytes > size) goto error;\n                tile_sz = 0;\n                for (unsigned k = 0; k < f->frame_hdr->tiling.n_bytes; k++)\n                    tile_sz |= (unsigned)*data++ << (k * 8);\n                tile_sz++;\n                size -= f->frame_hdr->tiling.n_bytes;\n                if (tile_sz > size) goto error;\n            }\n\n            setup_tile(&f->ts[j], f, data, tile_sz, tile_row, tile_col++,\n                       c->n_fc > 1 ? f->frame_thread.tile_start_off[j] : 0);\n\n            if (tile_col == f->frame_hdr->tiling.cols) {\n                tile_col = 0;\n                tile_row++;\n            }\n            if (j == f->frame_hdr->tiling.update && f->frame_hdr->refresh_context)\n                f->task_thread.update_set = 1;\n            data += tile_sz;\n            size -= tile_sz;\n        }\n    }\n\n    if (c->n_tc > 1) {\n        const int uses_2pass = c->n_fc > 1;\n        for (int n = 0; n < f->sb128w * f->frame_hdr->tiling.rows * (1 + uses_2pass); n++)\n            reset_context(&f->a[n], IS_KEY_OR_INTRA(f->frame_hdr),\n                          uses_2pass ? 1 + (n >= f->sb128w * f->frame_hdr->tiling.rows) : 0);\n    }\n\n    retval = 0;\nerror:\n    return retval;\n}\n",
    "target": 1,
    "idx": 1038152,
    "stack_trace": true
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "int proj_hgrid_init(PJ* P, const char *grids) {\n/**********************************************\n\n  Initizalize and populate list of horizontal\n  grids.\n\n    Takes a PJ-object and the plus-parameter\n    name that is used in the proj-string to\n    specify the grids to load, e.g. \"+grids\".\n    The + should be left out here.\n\n    Returns the number of loaded grids.\n\n***********************************************/\n\n    /* prepend \"s\" to the \"grids\" string to allow usage with pj_param */\n    char *sgrids = (char *) pj_malloc( (strlen(grids)+1+1) *sizeof(char) );\n    sprintf(sgrids, \"%s%s\", \"s\", grids);\n\n    if (P->gridlist == NULL) {\n        P->gridlist = pj_gridlist_from_nadgrids(\n            P->ctx,\n            pj_param(P->ctx, P->params, sgrids).s,\n            &(P->gridlist_count)\n        );\n\n        if( P->gridlist == NULL || P->gridlist_count == 0 ) {\n            pj_dealloc(sgrids);\n            return 0;\n        }\n    }\n\n    if (P->gridlist_count == 0) {\n        proj_errno_set(P, PJD_ERR_FAILED_TO_LOAD_GRID);\n    }\n\n    pj_dealloc(sgrids);\n    return P->gridlist_count;\n}\n",
    "target": 0,
    "idx": 2003940
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "PanasonicDecompressor::PanasonicDecompressor(const RawImage& img,\n                                             ByteStream input_,\n                                             bool zero_is_not_bad,\n                                             uint32 load_flags_)\n    : AbstractParallelizedDecompressor(img), input(std::move(input_)),\n      zero_is_bad(!zero_is_not_bad), load_flags(load_flags_) {\n  if (mRaw->getCpp() != 1 || mRaw->getDataType() != TYPE_USHORT16 ||\n      mRaw->getBpp() != 2)\n    ThrowRDE(\"Unexpected component count / data type\");\n\n  const uint32 width = mRaw->dim.x;\n  const uint32 height = mRaw->dim.y;\n\n  if (width == 0 || height == 0 || width > 5488 || height > 3904)\n    ThrowRDE(\"Unexpected image dimensions found: (%u; %u)\", width, height);\n\n  if (BufSize < load_flags)\n    ThrowRDE(\"Bad load_flags: %u, less than BufSize (%u)\", load_flags, BufSize);\n\n  input.check(load_flags);\n}\n  uint32 getBits(int nbits) {\n    if (!vbits) {\n      /* On truncated files this routine will just return just for the truncated\n       * part of the file. Since there is no chance of affecting output buffer\n       * size we allow the decoder to decode this\n       */\n      assert(BufSize >= load_flags);\n      auto size = std::min(input.getRemainSize(), BufSize - load_flags);\n      memcpy(buf.data() + load_flags, input.getData(size), size);\n\n      size = std::min(input.getRemainSize(), load_flags);\n      if (size != 0)\n        memcpy(buf.data(), input.getData(size), size);\n    }\n    vbits = (vbits - nbits) & 0x1ffff;\n    int byte = vbits >> 3 ^ 0x3ff0;\n    return (buf[byte] | buf[byte + 1UL] << 8) >> (vbits & 7) & ~(-(1 << nbits));\n  }\n",
    "target": 0,
    "idx": 2004511
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "static int pj_cs2cs_emulation_setup (PJ *P) {\n/**************************************************************************************\nIf any cs2cs style modifiers are given (axis=..., towgs84=..., ) create the 4D API\nequivalent operations, so the preparation and finalization steps in the pj_inv/pj_fwd\ninvocators can emulate the behaviour of pj_transform and the cs2cs app.\n**************************************************************************************/\n    PJ *Q;\n    paralist *p;\n    if (0==P)\n        return 0;\n\n    /* Don't recurse when calling proj_create (which calls us back) */\n    if (pj_param_exists (P->params, \"break_cs2cs_recursion\"))\n        return 1;\n\n    /* Swap axes? */\n    p = pj_param_exists (P->params, \"axis\");\n\n    /* Don't axisswap if data are already in \"enu\" order */\n    if (p && (0!=strcmp (\"enu\", p->param))) {\n        char *def = malloc (100+strlen(P->axis));\n        if (0==def)\n            return 0;\n        sprintf (def, \"break_cs2cs_recursion     proj=axisswap  axis=%s\", P->axis);\n        Q = proj_create (P->ctx, def);\n        free (def);\n        if (0==Q)\n            return 0;\n        P->axisswap = skip_prep_fin(Q);\n    }\n\n    /* Geoid grid(s) given? */\n    p = pj_param_exists (P->params, \"geoidgrids\");\n    if (p  &&  strlen (p->param) > strlen (\"geoidgrids=\")) {\n        char *gridnames = p->param + strlen (\"geoidgrids=\");\n        char *def = malloc (100+strlen(gridnames));\n        if (0==def)\n            return 0;\n        sprintf (def, \"break_cs2cs_recursion     proj=vgridshift  grids=%s\", gridnames);\n        Q = proj_create (P->ctx, def);\n        free (def);\n        if (0==Q)\n            return 0;\n        P->vgridshift = skip_prep_fin(Q);\n    }\n\n    /* Datum shift grid(s) given? */\n    p = pj_param_exists (P->params, \"nadgrids\");\n    if (p  &&  strlen (p->param) > strlen (\"nadgrids=\")) {\n        char *gridnames = p->param + strlen (\"nadgrids=\");\n        char *def = malloc (100+strlen(gridnames));\n        if (0==def)\n            return 0;\n        sprintf (def, \"break_cs2cs_recursion     proj=hgridshift  grids=%s\", gridnames);\n        Q = proj_create (P->ctx, def);\n        free (def);\n        if (0==Q)\n            return 0;\n        P->hgridshift = skip_prep_fin(Q);\n    }\n\n    /* We ignore helmert if we have grid shift */\n    p = P->hgridshift ? 0 : pj_param_exists (P->params, \"towgs84\");\n    while (p) {\n        char *def;\n        char *s = p->param;\n        double *d = P->datum_params;\n        size_t n = strlen (s);\n\n        /* We ignore null helmert shifts (common in auto-translated resource files, e.g. epsg) */\n        if (0==d[0] && 0==d[1] && 0==d[2] && 0==d[3] && 0==d[4] && 0==d[5] && 0==d[6])\n            break;\n\n        if (n <= 8) /* 8==strlen (\"towgs84=\") */\n            return 0;\n\n        def = malloc (100+n);\n        if (0==def)\n            return 0;\n        sprintf (def, \"break_cs2cs_recursion     proj=helmert %s\", s);\n        Q = proj_create (P->ctx, def);\n        free (def);\n        if (0==Q)\n            return 0;\n        P->helmert = skip_prep_fin(Q);\n\n        break;\n    }\n\n    /* We also need cartesian/geographical transformations if we are working in */\n    /* geocentric/cartesian space or we need to do a Helmert transform.         */\n    if (P->is_geocent || P->helmert) {\n        char def[100];\n        sprintf (def, \"break_cs2cs_recursion     proj=cart\");\n        Q = proj_create (P->ctx, def);\n        if (0==Q)\n            return 0;\n        pj_inherit_ellipsoid_def(P, Q);\n        P->cart = skip_prep_fin(Q);\n\n        sprintf (def, \"break_cs2cs_recursion     proj=cart  ellps=WGS84\");\n        Q = proj_create (P->ctx, def);\n        if (0==Q)\n            return 0;\n        P->cart_wgs84 = skip_prep_fin(Q);\n    }\n\n    return 1;\n}\n",
    "target": 0,
    "idx": 2005903
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "static void strcpy_url(char *output, const char *url, bool relative)\n{\n  /* we must add this with whitespace-replacing */\n  bool left = TRUE;\n  const unsigned char *iptr;\n  char *optr = output;\n  const unsigned char *host_sep = (const unsigned char *) url;\n\n  if(!relative)\n    host_sep = (const unsigned char *) find_host_sep(url);\n\n  for(iptr = (unsigned char *)url;    /* read from here */\n      *iptr;         /* until zero byte */\n      iptr++) {\n\n    if(iptr < host_sep) {\n      *optr++ = *iptr;\n      continue;\n    }\n\n    switch(*iptr) {\n    case '?':\n      left = FALSE;\n      /* fall through */\n    default:\n      if(*iptr >= 0x80) {\n        snprintf(optr, 4, \"%%%02x\", *iptr);\n        optr += 3;\n      }\n      else\n        *optr++=*iptr;\n      break;\n    case ' ':\n      if(left) {\n        *optr++='%'; /* add a '%' */\n        *optr++='2'; /* add a '2' */\n        *optr++='0'; /* add a '0' */\n      }\n      else\n        *optr++='+'; /* add a '+' here */\n      break;\n    }\n  }\n  *optr = 0; /* zero terminate output buffer */\n\n}\n",
    "target": 0,
    "idx": 2007997
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "static void strcpy_url(char *output, const char *url, bool relative)\n{\n  /* we must add this with whitespace-replacing */\n  bool left = TRUE;\n  const unsigned char *iptr;\n  char *optr = output;\n  const unsigned char *host_sep = (const unsigned char *) url;\n\n  if(!relative)\n    host_sep = (const unsigned char *) find_host_sep(url);\n\n  for(iptr = (unsigned char *)url;    /* read from here */\n      *iptr;         /* until zero byte */\n      iptr++) {\n\n    if(iptr < host_sep) {\n      *optr++ = *iptr;\n      continue;\n    }\n\n    switch(*iptr) {\n    case '?':\n      left = FALSE;\n      /* fall through */\n    default:\n      if(*iptr >= 0x80) {\n        snprintf(optr, 4, \"%%%02x\", *iptr);\n        optr += 3;\n      }\n      else\n        *optr++=*iptr;\n      break;\n    case ' ':\n      if(left) {\n        *optr++='%'; /* add a '%' */\n        *optr++='2'; /* add a '2' */\n        *optr++='0'; /* add a '0' */\n      }\n      else\n        *optr++='+'; /* add a '+' here */\n      break;\n    }\n  }\n  *optr = 0; /* zero terminate output buffer */\n\n}\n",
    "target": 0,
    "idx": 2008000
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "static void strcpy_url(char *output, const char *url, bool relative)\n{\n  /* we must add this with whitespace-replacing */\n  bool left = TRUE;\n  const unsigned char *iptr;\n  char *optr = output;\n  const unsigned char *host_sep = (const unsigned char *) url;\n\n  if(!relative)\n    host_sep = (const unsigned char *) find_host_sep(url);\n\n  for(iptr = (unsigned char *)url;    /* read from here */\n      *iptr;         /* until zero byte */\n      iptr++) {\n\n    if(iptr < host_sep) {\n      *optr++ = *iptr;\n      continue;\n    }\n\n    switch(*iptr) {\n    case '?':\n      left = FALSE;\n      /* fall through */\n    default:\n      if(*iptr >= 0x80) {\n        snprintf(optr, 4, \"%%%02x\", *iptr);\n        optr += 3;\n      }\n      else\n        *optr++=*iptr;\n      break;\n    case ' ':\n      if(left) {\n        *optr++='%'; /* add a '%' */\n        *optr++='2'; /* add a '2' */\n        *optr++='0'; /* add a '0' */\n      }\n      else\n        *optr++='+'; /* add a '+' here */\n      break;\n    }\n  }\n  *optr = 0; /* zero terminate output buffer */\n\n}\n",
    "target": 0,
    "idx": 2008007
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "static void foreach_rest_unit_in_planes_mt(AV1LrStruct *lr_ctxt,\n                                           AVxWorker *workers, int nworkers,\n                                           AV1LrSync *lr_sync, AV1_COMMON *cm) {\n  FilterFrameCtxt *ctxt = lr_ctxt->ctxt;\n\n  const int num_planes = av1_num_planes(cm);\n\n  const AVxWorkerInterface *const winterface = aom_get_worker_interface();\n  int num_rows_lr = 0;\n\n  for (int plane = 0; plane < num_planes; plane++) {\n    if (cm->rst_info[plane].frame_restoration_type == RESTORE_NONE) continue;\n\n    const AV1PixelRect tile_rect = ctxt[plane].tile_rect;\n    const int max_tile_h = tile_rect.bottom - tile_rect.top;\n\n    const int unit_size = cm->rst_info[plane].restoration_unit_size;\n\n    num_rows_lr =\n        AOMMAX(num_rows_lr, av1_lr_count_units_in_tile(unit_size, max_tile_h));\n  }\n\n  const int num_workers = nworkers;\n  int i;\n  assert(MAX_MB_PLANE == 3);\n\n  if (!lr_sync->sync_range || num_rows_lr != lr_sync->rows ||\n      num_workers > lr_sync->num_workers || num_planes != lr_sync->num_planes) {\n    av1_loop_restoration_dealloc(lr_sync, num_workers);\n    loop_restoration_alloc(lr_sync, cm, num_workers, num_rows_lr, num_planes,\n                           cm->width);\n  }\n\n  // Initialize cur_sb_col to -1 for all SB rows.\n  for (i = 0; i < num_planes; i++) {\n    memset(lr_sync->cur_sb_col[i], -1,\n           sizeof(*(lr_sync->cur_sb_col[i])) * num_rows_lr);\n  }\n\n  enqueue_lr_jobs(lr_sync, lr_ctxt, cm);\n\n  // Set up looprestoration thread data.\n  for (i = 0; i < num_workers; ++i) {\n    AVxWorker *const worker = &workers[i];\n    lr_sync->lrworkerdata[i].lr_ctxt = (void *)lr_ctxt;\n    worker->hook = loop_restoration_row_worker;\n    worker->data1 = lr_sync;\n    worker->data2 = &lr_sync->lrworkerdata[i];\n\n    // Start loopfiltering\n    if (i == num_workers - 1) {\n      winterface->execute(worker);\n    } else {\n      winterface->launch(worker);\n    }\n  }\n\n  // Wait till all rows are finished\n  for (i = 0; i < num_workers; ++i) {\n    winterface->sync(&workers[i]);\n  }\n}\n",
    "target": 0,
    "idx": 2010252
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "static void init_unpack(struct rar5* rar) {\n    rar->file.calculated_crc32 = 0;\n    if (rar->cstate.window_size)\n        rar->cstate.window_mask = rar->cstate.window_size - 1;\n    else\n        rar->cstate.window_mask = 0;\n\n    if(rar->cstate.window_buf)\n        free(rar->cstate.window_buf);\n\n    if(rar->cstate.filtered_buf)\n        free(rar->cstate.filtered_buf);\n\n    rar->cstate.window_buf = calloc(1, rar->cstate.window_size);\n    rar->cstate.filtered_buf = calloc(1, rar->cstate.window_size);\n\n    rar->cstate.write_ptr = 0;\n    rar->cstate.last_write_ptr = 0;\n\n    memset(&rar->cstate.bd, 0, sizeof(rar->cstate.bd));\n    memset(&rar->cstate.ld, 0, sizeof(rar->cstate.ld));\n    memset(&rar->cstate.dd, 0, sizeof(rar->cstate.dd));\n    memset(&rar->cstate.ldd, 0, sizeof(rar->cstate.ldd));\n    memset(&rar->cstate.rd, 0, sizeof(rar->cstate.rd));\n}\n",
    "target": 0,
    "idx": 2011011
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "void\nofpbuf_insert(struct ofpbuf *b, size_t offset, const void *data, size_t n)\n{\n    if (offset < b->size) {\n        ofpbuf_put_uninit(b, n); /* b->size gets increased. */\n        memmove((char *) b->data + offset + n, (char *) b->data + offset,\n                b->size - offset - n);\n        memcpy((char *) b->data + offset, data, n);\n    } else {\n        ovs_assert(offset == b->size);\n        ofpbuf_put(b, data, n);\n    }\n}\n",
    "target": 0,
    "idx": 2011253
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "void VC5Decompressor::Wavelet::HighPassBand::decode(const Wavelet& wavelet) {\n  auto dequantize = [quant = quant](int16_t val) -> int16_t {\n    return mVC5DecompandingTable[uint16_t(val)] * quant;\n  };\n\n  data = Array2DRef<int16_t>::create(wavelet.width, wavelet.height);\n  const Array2DRef<int16_t> dst(data.data(), wavelet.width, wavelet.height);\n\n  BitPumpMSB bits(bs);\n  // decode highpass band\n  int pixelValue = 0;\n  unsigned int count = 0;\n  int nPixels = wavelet.width * wavelet.height;\n  for (int iPixel = 0; iPixel < nPixels;) {\n    getRLV(&bits, &pixelValue, &count);\n    for (; count > 0; --count) {\n      if (iPixel >= nPixels)\n        ThrowRDE(\"Buffer overflow\");\n      data[iPixel] = dequantize(pixelValue);\n      ++iPixel;\n    }\n  }\n  if (bits.getPosition() < bits.getSize()) {\n    getRLV(&bits, &pixelValue, &count);\n    if (pixelValue != MARKER_BAND_END || count != 0)\n      ThrowRDE(\"EndOfBand marker not found\");\n  }\n}\n",
    "target": 0,
    "idx": 2011429
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "int\nidn2_to_ascii_4i (const uint32_t * input, size_t inlen, char * output, int flags)\n{\n  uint32_t *input_u32;\n  uint8_t *input_u8, *output_u8;\n  size_t length;\n  int rc;\n\n  if (!input)\n    {\n      if (output)\n\t*output = 0;\n      return IDN2_OK;\n    }\n\n  input_u32 = (uint32_t *) malloc ((inlen + 1) * sizeof(uint32_t));\n  if (!input_u32)\n    return IDN2_MALLOC;\n\n  u32_cpy (input_u32, input, inlen);\n  input_u32[inlen] = 0;\n\n  input_u8 = u32_to_u8 (input_u32, inlen + 1, NULL, &length);\n  free (input_u32);\n  if (!input_u8)\n    {\n      if (errno == ENOMEM)\n\treturn IDN2_MALLOC;\n      return IDN2_ENCODING_ERROR;\n    }\n\n  rc = idn2_lookup_u8 (input_u8, &output_u8, flags);\n  free (input_u8);\n\n  if (rc == IDN2_OK)\n    {\n      /* wow, this is ugly, but libidn manpage states:\n       * char * out  output zero terminated string that must have room for at\n       * least 63 characters plus the terminating zero.\n       */\n      size_t len = strlen ((char *) output_u8);\n\n      if (len > 63)\n        {\n\t  free (output_u8);\n\t  return IDN2_TOO_BIG_DOMAIN;\n        }\n\n      if (output)\n\tstrcpy (output, (char *) output_u8);\n\n      free (output_u8);\n    }\n\n  return rc;\n}\n",
    "target": 0,
    "idx": 2012420
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "static int parse_file_extra_owner(struct archive_read* a,\n        struct archive_entry* e, ssize_t* extra_data_size)\n{\n\tuint64_t flags = 0;\n\tuint64_t value_size = 0;\n\tuint64_t id = 0;\n\tsize_t name_len = 0;\n\tsize_t name_size = 0;\n\tchar namebuf[OWNER_MAXNAMELEN];\n\tconst uint8_t* p;\n\n\tif(!read_var(a, &flags, &value_size))\n\t\treturn ARCHIVE_EOF;\n\tif(ARCHIVE_OK != consume(a, (int64_t)value_size))\n\t\treturn ARCHIVE_EOF;\n\t*extra_data_size -= value_size;\n\n\tif ((flags & OWNER_USER_NAME) != 0) {\n\t\tif(!read_var_sized(a, &name_size, NULL))\n\t\t\treturn ARCHIVE_EOF;\n\t        *extra_data_size -= name_size + 1;\n\t\tif(!read_ahead(a, name_size, &p))\n\t\t\treturn ARCHIVE_EOF;\n\t\tif (name_size >= OWNER_MAXNAMELEN)\n\t\t\tname_len = OWNER_MAXNAMELEN - 1;\n\t\telse\n\t\t\tname_len = name_size;\n\t\tmemcpy(namebuf, p, name_len);\n\t\tnamebuf[name_len] = 0;\n\t\tif(ARCHIVE_OK != consume(a, (int64_t)name_size))\n\t\t\treturn ARCHIVE_EOF;\n\n\t\tarchive_entry_set_uname(e, namebuf);\n\t}\n\tif ((flags & OWNER_GROUP_NAME) != 0) {\n\t\tif(!read_var_sized(a, &name_size, NULL))\n\t\t\treturn ARCHIVE_EOF;\n\t        *extra_data_size -= name_size + 1;\n\t\tif(!read_ahead(a, name_size, &p))\n\t\t\treturn ARCHIVE_EOF;\n\t\tif (name_size >= OWNER_MAXNAMELEN)\n\t\t\tname_len = OWNER_MAXNAMELEN - 1;\n\t\telse\n\t\t\tname_len = name_size;\n\t\tmemcpy(namebuf, p, name_len);\n\t\tnamebuf[name_len] = 0;\n\t\tif(ARCHIVE_OK != consume(a, (int64_t)name_size))\n\t\t\treturn ARCHIVE_EOF;\n\n\t\tarchive_entry_set_gname(e, namebuf);\n\t}\n\tif ((flags & OWNER_USER_UID) != 0) {\n\t\tif(!read_var(a, &id, &value_size))\n\t\t\treturn ARCHIVE_EOF;\n\t\tif(ARCHIVE_OK != consume(a, (int64_t)value_size))\n\t\t\treturn ARCHIVE_EOF;\n\t\t*extra_data_size -= value_size;\n\n\t\tarchive_entry_set_uid(e, (la_int64_t)id);\n\t}\n\tif ((flags & OWNER_GROUP_GID) != 0) {\n\t\tif(!read_var(a, &id, &value_size))\n\t\t\treturn ARCHIVE_EOF;\n\t\tif(ARCHIVE_OK != consume(a, (int64_t)value_size))\n\t\t\treturn ARCHIVE_EOF;\n\t\t*extra_data_size -= value_size;\n\n\t\tarchive_entry_set_gid(e, (la_int64_t)id);\n\t}\n\treturn ARCHIVE_OK;\n}\n",
    "target": 0,
    "idx": 2014331
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "UA_StatusCode UA_ByteString_toBase64String(const UA_ByteString *byteString, UA_String *str) {\n    if (str->length != 0) {\n        UA_free(str->data);\n        str->data = NULL;\n        str->length = 0;\n    }\n    if (byteString == NULL || byteString->data == NULL)\n        return UA_STATUSCODE_GOOD;\n    if (byteString == str)\n        return UA_STATUSCODE_BADINVALIDARGUMENT;\n\n    str->data = (UA_Byte*)UA_base64(byteString->data,\n                                    byteString->length, &str->length);\n    if(str->data == NULL)\n        return UA_STATUSCODE_BADOUTOFMEMORY;\n\n    return UA_STATUSCODE_GOOD;\n}\nextern \"C\" int\nLLVMFuzzerTestOneInput(uint8_t *data, size_t size) {\n    UA_ByteString buf;\n    buf.data = (UA_Byte*)data;\n    buf.length = size;\n\n    UA_Variant value;\n    UA_Variant_init(&value);\n\n    UA_StatusCode retval = UA_decodeJson(&buf, &value, &UA_TYPES[UA_TYPES_VARIANT]);\n    if(retval != UA_STATUSCODE_GOOD)\n        return 0;\n\n    size_t jsonSize = UA_calcSizeJson(&value, &UA_TYPES[UA_TYPES_VARIANT],\n                                      NULL, 0, NULL, 0, true);\n\n    UA_ByteString buf2 = UA_BYTESTRING_NULL;\n    retval = UA_ByteString_allocBuffer(&buf2, jsonSize);\n    if(retval != UA_STATUSCODE_GOOD) {\n        UA_Variant_deleteMembers(&value);\n        return 0;\n    }\n\n    uint8_t *bufPos = buf2.data;\n    const uint8_t *bufEnd = &buf2.data[buf2.length];\n    retval = UA_encodeJson(&value, &UA_TYPES[UA_TYPES_VARIANT],\n                           &bufPos, &bufEnd, NULL, 0, NULL, 0, true);\n\tUA_Variant_deleteMembers(&value);\n\tif(retval != UA_STATUSCODE_GOOD || bufPos != bufEnd) {\n\t\treturn 0;\n\t}\n\n    UA_Variant value2;\n    UA_Variant_init(&value2);\n\n    retval = UA_decodeJson(&buf2, &value2, &UA_TYPES[UA_TYPES_VARIANT]);\n    if(retval != UA_STATUSCODE_GOOD) {\n\t\treturn 0;\n\t}\n\n    UA_ByteString buf3 = UA_BYTESTRING_NULL;\n    retval = UA_ByteString_allocBuffer(&buf3, jsonSize);\n    if(retval != UA_STATUSCODE_GOOD) {\n        UA_Variant_deleteMembers(&value2);\n        UA_ByteString_deleteMembers(&buf2);\n        return 0;\n    }\n\n    bufPos = buf3.data;\n    bufEnd = &buf3.data[buf3.length];\n    retval = UA_encodeJson(&value2, &UA_TYPES[UA_TYPES_VARIANT],\n                           &bufPos, &bufEnd, NULL, 0, NULL, 0, true);\n\tUA_Variant_deleteMembers(&value2);\n\tif(retval != UA_STATUSCODE_GOOD) {\n\t\tUA_ByteString_deleteMembers(&buf2);\n\t\tUA_ByteString_deleteMembers(&buf3);\n\t\treturn 0;\n\t}\n\n    UA_assert(buf2.length == buf3.length);\n    UA_assert(memcmp(buf2.data, buf3.data, buf2.length) == 0);\n    UA_ByteString_deleteMembers(&buf2);\n    UA_ByteString_deleteMembers(&buf3);\n    return 0;\n}\n",
    "target": 0,
    "idx": 2014621
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "otError Address::FromString(const char *aBuf)\n{\n    otError     error  = OT_ERROR_NONE;\n    uint8_t *   dst    = reinterpret_cast<uint8_t *>(mFields.m8);\n    uint8_t *   endp   = reinterpret_cast<uint8_t *>(mFields.m8 + 15);\n    uint8_t *   colonp = NULL;\n    const char *colonc = NULL;\n    uint16_t    val    = 0;\n    uint8_t     count  = 0;\n    bool        first  = true;\n    bool        hasIp4 = false;\n    char        ch;\n    uint8_t     d;\n\n    memset(mFields.m8, 0, 16);\n\n    dst--;\n\n    for (;;)\n    {\n        ch = *aBuf++;\n        d  = ch & 0xf;\n\n        if (('a' <= ch && ch <= 'f') || ('A' <= ch && ch <= 'F'))\n        {\n            d += 9;\n        }\n        else if (ch == ':' || ch == '\\0' || ch == ' ')\n        {\n            if (count)\n            {\n                VerifyOrExit(dst + 2 <= endp, error = OT_ERROR_PARSE);\n                *(dst + 1) = static_cast<uint8_t>(val >> 8);\n                *(dst + 2) = static_cast<uint8_t>(val);\n                dst += 2;\n                count = 0;\n                val   = 0;\n            }\n            else if (ch == ':')\n            {\n                VerifyOrExit(colonp == NULL || first, error = OT_ERROR_PARSE);\n                colonp = dst;\n            }\n\n            if (ch == '\\0' || ch == ' ')\n            {\n                break;\n            }\n\n            colonc = aBuf;\n\n            continue;\n        }\n        else if (ch == '.')\n        {\n            hasIp4 = true;\n\n            // Do not count bytes of the embedded IPv4 address.\n            endp -= kIp4AddressSize;\n\n            VerifyOrExit(dst <= endp, error = OT_ERROR_PARSE);\n\n            break;\n        }\n        else\n        {\n            VerifyOrExit('0' <= ch && ch <= '9', error = OT_ERROR_PARSE);\n        }\n\n        first = false;\n        val   = static_cast<uint16_t>((val << 4) | d);\n        VerifyOrExit(++count <= 4, error = OT_ERROR_PARSE);\n    }\n\n    VerifyOrExit(colonp || dst == endp, error = OT_ERROR_PARSE);\n\n    while (colonp && dst > colonp)\n    {\n        *endp-- = *dst--;\n    }\n\n    while (endp > dst)\n    {\n        *endp-- = 0;\n    }\n\n    if (hasIp4)\n    {\n        val = 0;\n\n        // Reset the start and end pointers.\n        dst  = reinterpret_cast<uint8_t *>(mFields.m8 + 12);\n        endp = reinterpret_cast<uint8_t *>(mFields.m8 + 15);\n\n        for (;;)\n        {\n            ch = *colonc++;\n\n            if (ch == '.' || ch == '\\0' || ch == ' ')\n            {\n                VerifyOrExit(dst <= endp, error = OT_ERROR_PARSE);\n\n                *dst++ = static_cast<uint8_t>(val);\n                val    = 0;\n\n                if (ch == '\\0' || ch == ' ')\n                {\n                    // Check if embedded IPv4 address had exactly four parts.\n                    VerifyOrExit(dst == endp + 1, error = OT_ERROR_PARSE);\n                    break;\n                }\n            }\n            else\n            {\n                VerifyOrExit('0' <= ch && ch <= '9', error = OT_ERROR_PARSE);\n\n                val = (10 * val) + (ch & 0xf);\n\n                // Single part of IPv4 address has to fit in one byte.\n                VerifyOrExit(val <= 0xff, error = OT_ERROR_PARSE);\n            }\n        }\n    }\n\nexit:\n    return error;\n}\nvoid TestIp6AddressFromString(void)\n{\n    Ip6AddressStringTestVector testVectors[] =\n    {\n        // Valid full IPv6 address.\n        {\n            \"0102:0304:0506:0708:090a:0b0c:0d0e:0f00\",\n            {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,\n             0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x00},\n            OT_ERROR_NONE\n        },\n\n        // Valid full IPv6 address with mixed capital and small letters.\n        {\n            \"0102:0304:0506:0708:090a:0B0C:0d0E:0F00\",\n            {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,\n             0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x00},\n            OT_ERROR_NONE\n        },\n\n        // Short prefix and full IID.\n        {\n            \"fd11::abcd:e0e0:d10e:0001\",\n            {0xfd, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n             0xab, 0xcd, 0xe0, 0xe0, 0xd1, 0x0e, 0x00, 0x01},\n            OT_ERROR_NONE\n        },\n\n        // Valid IPv6 address with unnecessary :: symbol.\n        {\n            \"fd11:1234:5678:abcd::abcd:e0e0:d10e:1000\",\n            {0xfd, 0x11, 0x12, 0x34, 0x56, 0x78, 0xab, 0xcd,\n             0xab, 0xcd, 0xe0, 0xe0, 0xd1, 0x0e, 0x10, 0x00},\n            OT_ERROR_NONE\n        },\n\n        // Short multicast address.\n        {\n            \"ff03::0b\",\n            {0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b},\n            OT_ERROR_NONE\n        },\n\n        // Unspecified address.\n        {\n            \"::\",\n            {0},\n            OT_ERROR_NONE\n        },\n\n        // Valid embedded IPv4 address.\n        {\n            \"64:ff9b::100.200.15.4\",\n            {0x00, 0x64, 0xff, 0x9b, 0x00, 0x00, 0x00, 0x00,\n             0x00, 0x00, 0x00, 0x00, 0x64, 0xc8, 0x0f, 0x04},\n            OT_ERROR_NONE\n        },\n\n        // Valid embedded IPv4 address.\n        {\n            \"2001:db8::abc:def1:127.0.0.1\",\n            {0x20, 0x01, 0x0d, 0xb8, 0x00, 0x00, 0x00, 0x00,\n             0x0a, 0xbc, 0xde, 0xf1, 0x7f, 0x00, 0x00, 0x01},\n            OT_ERROR_NONE\n        },\n\n        // Two :: should cause a parse error.\n        {\n            \"2001:db8::a::b\",\n            {0},\n            OT_ERROR_PARSE\n        },\n\n        // The \"g\" and \"h\" are not the hex characters.\n        {\n            \"2001:db8::abcd:efgh\",\n            {0},\n            OT_ERROR_PARSE\n        },\n\n        // Too many colons.\n        {\n            \"1:2:3:4:5:6:7:8:9\",\n            {0},\n            OT_ERROR_PARSE\n        },\n\n        // Too many characters in a single part.\n        {\n            \"2001:db8::abc:def12:1:2\",\n            {0},\n            OT_ERROR_PARSE\n        },\n\n        // Invalid embedded IPv4 address.\n        {\n            \"64:ff9b::123.231.0.257\",\n            {0},\n            OT_ERROR_PARSE\n        },\n\n        // Invalid embedded IPv4 address.\n        {\n            \"64:ff9b::1.22.33\",\n            {0},\n            OT_ERROR_PARSE\n        },\n\n        // Invalid embedded IPv4 address.\n        {\n            \"64:ff9b::1.22.33.44.5\",\n            {0},\n            OT_ERROR_PARSE\n        },\n\n        // Invalid embedded IPv4 address.\n        {\n            \".\",\n            {0},\n            OT_ERROR_PARSE\n        },\n\n        // Invalid embedded IPv4 address.\n        {\n            \":.\",\n            {0},\n            OT_ERROR_PARSE\n        },\n\n        // Invalid embedded IPv4 address.\n        {\n            \"::.\",\n            {0},\n            OT_ERROR_PARSE\n        },\n\n        // Invalid embedded IPv4 address.\n        {\n            \":f:0:0:c:0:f:f:.\",\n            {0},\n            OT_ERROR_PARSE\n        },\n    };\n\n    for (uint32_t index = 0; index < OT_ARRAY_LENGTH(testVectors); index++)\n    {\n        checkAddressFromString(&testVectors[index]);\n    }\n}\n",
    "target": 0,
    "idx": 2014821
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "void KCompressionDeviceTest::testSeekReadUncompressedBuffer()\n{\n    QFETCH(int, dataSize);\n    QFETCH(int, realDataPos);\n\n    QByteArray ba(dataSize, 0);\n\n    // all data is zero except after realDataPos that it's 0 to 9\n    for (int i = 0; i < 10; ++i) {\n        ba[realDataPos + i] = i;\n    }\n\n    QBuffer b;\n    b.setData(ba);\n    QVERIFY(b.open(QIODevice::ReadOnly));\n\n    KCompressionDevice kcd(&b, false, KCompressionDevice::GZip);\n    QVERIFY(kcd.open(QIODevice::ReadOnly));\n    QVERIFY(kcd.seek(realDataPos));\n\n    // the 10 bytes after realDataPos should be 0 to 9\n    const QByteArray kcdData = kcd.read(10);\n    QCOMPARE(kcdData.size(), 10);\n    for (int i = 0; i < kcdData.size(); ++i) {\n        QCOMPARE(kcdData[i], i);\n    }\n}\nbool KCompressionDevice::seek(qint64 pos)\n{\n    if (d->deviceReadPos == pos) {\n        return QIODevice::seek(pos);\n    }\n\n    //qCDebug(KArchiveLog) << \"seek(\" << pos << \") called, current pos=\" << QIODevice::pos();\n\n    Q_ASSERT(d->filter->mode() == QIODevice::ReadOnly);\n\n    if (pos == 0) {\n        if (!QIODevice::seek(pos))\n            return false;\n\n        // We can forget about the cached data\n        d->bNeedHeader = !d->bSkipHeaders;\n        d->result = KFilterBase::Ok;\n        d->filter->setInBuffer(nullptr, 0);\n        d->filter->reset();\n        d->deviceReadPos = 0;\n        return d->filter->device()->reset();\n    }\n\n    qint64 bytesToRead;\n    if (d->deviceReadPos < pos) { // we can start from here\n        bytesToRead = pos - d->deviceReadPos;\n        // Since we're going to do a read() below\n        // we need to reset the internal QIODevice pos to the real position we are\n        // so that after read() we are indeed pointing to the pos seek\n        // asked us to be in\n        if (!QIODevice::seek(d->deviceReadPos)) {\n            return false;\n        }\n    } else {\n        // we have to start from 0 ! Ugly and slow, but better than the previous\n        // solution (KTarGz was allocating everything into memory)\n        if (!seek(0)) { // recursive\n            return false;\n        }\n        bytesToRead = pos;\n    }\n\n    //qCDebug(KArchiveLog) << \"reading \" << bytesToRead << \" dummy bytes\";\n    QByteArray dummy(qMin(bytesToRead, qint64(SEEK_BUFFER_SIZE)), 0);\n    while (bytesToRead > 0) {\n        const qint64 bytesToReadThisTime = qMin(bytesToRead, qint64(dummy.size()));\n        const bool result = (read(dummy.data(), bytesToReadThisTime) == bytesToReadThisTime);\n        if (!result) {\n            return false;\n        }\n        bytesToRead -= bytesToReadThisTime;\n    }\n    return true;\n}\nbool KCompressionDevice::atEnd() const\n{\n    return (d->type == KCompressionDevice::None || d->result == KFilterBase::End)\n           && QIODevice::atEnd() // take QIODevice's internal buffer into account\n           && d->filter->device()->atEnd();\n}\n",
    "target": 0,
    "idx": 2014959
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "void KCompressionDeviceTest::testSeekReadUncompressedBuffer()\n{\n    QFETCH(int, dataSize);\n    QFETCH(int, realDataPos);\n\n    QByteArray ba(dataSize, 0);\n\n    // all data is zero except after realDataPos that it's 0 to 9\n    for (int i = 0; i < 10; ++i) {\n        ba[realDataPos + i] = i;\n    }\n\n    QBuffer b;\n    b.setData(ba);\n    QVERIFY(b.open(QIODevice::ReadOnly));\n\n    KCompressionDevice kcd(&b, false, KCompressionDevice::GZip);\n    QVERIFY(kcd.open(QIODevice::ReadOnly));\n    QVERIFY(kcd.seek(realDataPos));\n\n    // the 10 bytes after realDataPos should be 0 to 9\n    const QByteArray kcdData = kcd.read(10);\n    QCOMPARE(kcdData.size(), 10);\n    for (int i = 0; i < kcdData.size(); ++i) {\n        QCOMPARE(kcdData[i], i);\n    }\n}\nbool KCompressionDevice::seek(qint64 pos)\n{\n    if (d->deviceReadPos == pos) {\n        return QIODevice::seek(pos);\n    }\n\n    //qCDebug(KArchiveLog) << \"seek(\" << pos << \") called, current pos=\" << QIODevice::pos();\n\n    Q_ASSERT(d->filter->mode() == QIODevice::ReadOnly);\n\n    if (pos == 0) {\n        if (!QIODevice::seek(pos))\n            return false;\n\n        // We can forget about the cached data\n        d->bNeedHeader = !d->bSkipHeaders;\n        d->result = KFilterBase::Ok;\n        d->filter->setInBuffer(nullptr, 0);\n        d->filter->reset();\n        d->deviceReadPos = 0;\n        return d->filter->device()->reset();\n    }\n\n    qint64 bytesToRead;\n    if (d->deviceReadPos < pos) { // we can start from here\n        bytesToRead = pos - d->deviceReadPos;\n        // Since we're going to do a read() below\n        // we need to reset the internal QIODevice pos to the real position we are\n        // so that after read() we are indeed pointing to the pos seek\n        // asked us to be in\n        if (!QIODevice::seek(d->deviceReadPos)) {\n            return false;\n        }\n    } else {\n        // we have to start from 0 ! Ugly and slow, but better than the previous\n        // solution (KTarGz was allocating everything into memory)\n        if (!seek(0)) { // recursive\n            return false;\n        }\n        bytesToRead = pos;\n    }\n\n    //qCDebug(KArchiveLog) << \"reading \" << bytesToRead << \" dummy bytes\";\n    QByteArray dummy(qMin(bytesToRead, qint64(SEEK_BUFFER_SIZE)), 0);\n    while (bytesToRead > 0) {\n        const qint64 bytesToReadThisTime = qMin(bytesToRead, qint64(dummy.size()));\n        const bool result = (read(dummy.data(), bytesToReadThisTime) == bytesToReadThisTime);\n        if (!result) {\n            return false;\n        }\n        bytesToRead -= bytesToReadThisTime;\n    }\n    return true;\n}\nbool KCompressionDevice::atEnd() const\n{\n    return (d->type == KCompressionDevice::None || d->result == KFilterBase::End)\n           && QIODevice::atEnd() // take QIODevice's internal buffer into account\n           && d->filter->device()->atEnd();\n}\n",
    "target": 0,
    "idx": 2014960
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "void KCompressionDeviceTest::testSeekReadUncompressedBuffer()\n{\n    QFETCH(int, dataSize);\n    QFETCH(int, realDataPos);\n\n    QByteArray ba(dataSize, 0);\n\n    // all data is zero except after realDataPos that it's 0 to 9\n    for (int i = 0; i < 10; ++i) {\n        ba[realDataPos + i] = i;\n    }\n\n    QBuffer b;\n    b.setData(ba);\n    QVERIFY(b.open(QIODevice::ReadOnly));\n\n    KCompressionDevice kcd(&b, false, KCompressionDevice::GZip);\n    QVERIFY(kcd.open(QIODevice::ReadOnly));\n    QVERIFY(kcd.seek(realDataPos));\n\n    // the 10 bytes after realDataPos should be 0 to 9\n    const QByteArray kcdData = kcd.read(10);\n    QCOMPARE(kcdData.size(), 10);\n    for (int i = 0; i < kcdData.size(); ++i) {\n        QCOMPARE(kcdData[i], i);\n    }\n}\nbool KCompressionDevice::seek(qint64 pos)\n{\n    if (d->deviceReadPos == pos) {\n        return QIODevice::seek(pos);\n    }\n\n    //qCDebug(KArchiveLog) << \"seek(\" << pos << \") called, current pos=\" << QIODevice::pos();\n\n    Q_ASSERT(d->filter->mode() == QIODevice::ReadOnly);\n\n    if (pos == 0) {\n        if (!QIODevice::seek(pos))\n            return false;\n\n        // We can forget about the cached data\n        d->bNeedHeader = !d->bSkipHeaders;\n        d->result = KFilterBase::Ok;\n        d->filter->setInBuffer(nullptr, 0);\n        d->filter->reset();\n        d->deviceReadPos = 0;\n        return d->filter->device()->reset();\n    }\n\n    qint64 bytesToRead;\n    if (d->deviceReadPos < pos) { // we can start from here\n        bytesToRead = pos - d->deviceReadPos;\n        // Since we're going to do a read() below\n        // we need to reset the internal QIODevice pos to the real position we are\n        // so that after read() we are indeed pointing to the pos seek\n        // asked us to be in\n        if (!QIODevice::seek(d->deviceReadPos)) {\n            return false;\n        }\n    } else {\n        // we have to start from 0 ! Ugly and slow, but better than the previous\n        // solution (KTarGz was allocating everything into memory)\n        if (!seek(0)) { // recursive\n            return false;\n        }\n        bytesToRead = pos;\n    }\n\n    //qCDebug(KArchiveLog) << \"reading \" << bytesToRead << \" dummy bytes\";\n    QByteArray dummy(qMin(bytesToRead, qint64(SEEK_BUFFER_SIZE)), 0);\n    while (bytesToRead > 0) {\n        const qint64 bytesToReadThisTime = qMin(bytesToRead, qint64(dummy.size()));\n        const bool result = (read(dummy.data(), bytesToReadThisTime) == bytesToReadThisTime);\n        if (!result) {\n            return false;\n        }\n        bytesToRead -= bytesToReadThisTime;\n    }\n    return true;\n}\nbool KCompressionDevice::atEnd() const\n{\n    return (d->type == KCompressionDevice::None || d->result == KFilterBase::End)\n           && QIODevice::atEnd() // take QIODevice's internal buffer into account\n           && d->filter->device()->atEnd();\n}\n",
    "target": 0,
    "idx": 2014961
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "void KCompressionDeviceTest::testSeekReadUncompressedBuffer()\n{\n    QFETCH(int, dataSize);\n    QFETCH(int, realDataPos);\n\n    QByteArray ba(dataSize, 0);\n\n    // all data is zero except after realDataPos that it's 0 to 9\n    for (int i = 0; i < 10; ++i) {\n        ba[realDataPos + i] = i;\n    }\n\n    QBuffer b;\n    b.setData(ba);\n    QVERIFY(b.open(QIODevice::ReadOnly));\n\n    KCompressionDevice kcd(&b, false, KCompressionDevice::GZip);\n    QVERIFY(kcd.open(QIODevice::ReadOnly));\n    QVERIFY(kcd.seek(realDataPos));\n\n    // the 10 bytes after realDataPos should be 0 to 9\n    const QByteArray kcdData = kcd.read(10);\n    QCOMPARE(kcdData.size(), 10);\n    for (int i = 0; i < kcdData.size(); ++i) {\n        QCOMPARE(kcdData[i], i);\n    }\n}\nbool KCompressionDevice::seek(qint64 pos)\n{\n    if (d->deviceReadPos == pos) {\n        return QIODevice::seek(pos);\n    }\n\n    //qCDebug(KArchiveLog) << \"seek(\" << pos << \") called, current pos=\" << QIODevice::pos();\n\n    Q_ASSERT(d->filter->mode() == QIODevice::ReadOnly);\n\n    if (pos == 0) {\n        if (!QIODevice::seek(pos))\n            return false;\n\n        // We can forget about the cached data\n        d->bNeedHeader = !d->bSkipHeaders;\n        d->result = KFilterBase::Ok;\n        d->filter->setInBuffer(nullptr, 0);\n        d->filter->reset();\n        d->deviceReadPos = 0;\n        return d->filter->device()->reset();\n    }\n\n    qint64 bytesToRead;\n    if (d->deviceReadPos < pos) { // we can start from here\n        bytesToRead = pos - d->deviceReadPos;\n        // Since we're going to do a read() below\n        // we need to reset the internal QIODevice pos to the real position we are\n        // so that after read() we are indeed pointing to the pos seek\n        // asked us to be in\n        if (!QIODevice::seek(d->deviceReadPos)) {\n            return false;\n        }\n    } else {\n        // we have to start from 0 ! Ugly and slow, but better than the previous\n        // solution (KTarGz was allocating everything into memory)\n        if (!seek(0)) { // recursive\n            return false;\n        }\n        bytesToRead = pos;\n    }\n\n    //qCDebug(KArchiveLog) << \"reading \" << bytesToRead << \" dummy bytes\";\n    QByteArray dummy(qMin(bytesToRead, qint64(SEEK_BUFFER_SIZE)), 0);\n    while (bytesToRead > 0) {\n        const qint64 bytesToReadThisTime = qMin(bytesToRead, qint64(dummy.size()));\n        const bool result = (read(dummy.data(), bytesToReadThisTime) == bytesToReadThisTime);\n        if (!result) {\n            return false;\n        }\n        bytesToRead -= bytesToReadThisTime;\n    }\n    return true;\n}\nbool KCompressionDevice::atEnd() const\n{\n    return (d->type == KCompressionDevice::None || d->result == KFilterBase::End)\n           && QIODevice::atEnd() // take QIODevice's internal buffer into account\n           && d->filter->device()->atEnd();\n}\n",
    "target": 0,
    "idx": 2014980
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "static UA_StatusCode\nRefTree_double(RefTree *rt) {\n    size_t capacity = rt->capacity * 2;\n    UA_assert(capacity > 0);\n    size_t space = (sizeof(UA_NodeId) + sizeof(RefEntry)) * capacity;\n    UA_NodeId *newTargets = (UA_NodeId*)UA_realloc(rt->targets, space);\n    if(!newTargets)\n        return UA_STATUSCODE_BADOUTOFMEMORY;\n\n    /* Repair the pointers for the realloced array+tree  */\n    uintptr_t arraydiff = (uintptr_t)newTargets - (uintptr_t)rt->targets;\n    RefEntry *reArray = (RefEntry*)\n        ((uintptr_t)newTargets + (capacity * sizeof(UA_NodeId)));\n    uintptr_t entrydiff = (uintptr_t)reArray -\n        ((uintptr_t)rt->targets + (rt->capacity * sizeof(UA_NodeId)));\n    RefEntry *oldReArray = (RefEntry*)\n        ((uintptr_t)newTargets + (rt->capacity * sizeof(UA_NodeId)));\n    memmove(reArray, oldReArray, rt->size * sizeof(RefEntry));\n    for(size_t i = 0; i < rt->size; i++) {\n        if(reArray[i].zipfields.zip_left)\n            *(uintptr_t*)&reArray[i].zipfields.zip_left += entrydiff;\n        if(reArray[i].zipfields.zip_right)\n            *(uintptr_t*)&reArray[i].zipfields.zip_right += entrydiff;\n        *(uintptr_t*)&reArray[i].target += arraydiff;\n    }\n\n    rt->head.zip_root = (RefEntry*)((uintptr_t)rt->head.zip_root + entrydiff);\n    rt->capacity = capacity;\n    rt->targets = newTargets;\n    return UA_STATUSCODE_GOOD;\n}\nvoid\nOperation_Browse(UA_Server *server, UA_Session *session, const struct BrowseOpts *bo,\n                 const UA_BrowseDescription *descr, UA_BrowseResult *result) {\n    /* How many references can we return at most? */\n    UA_UInt32 maxRefs = bo->maxReferences;\n    if(maxRefs == 0) {\n        if(server->config.maxReferencesPerNode != 0) {\n            maxRefs = server->config.maxReferencesPerNode;\n        } else {\n            maxRefs = UA_INT32_MAX;\n        }\n    } else {\n        if(server->config.maxReferencesPerNode != 0 &&\n           maxRefs > server->config.maxReferencesPerNode) {\n            maxRefs = server->config.maxReferencesPerNode;\n        }\n    }\n\n    /* Create the results array */\n    RefResult rr;\n    result->statusCode = RefResult_init(&rr, maxRefs);\n    if(result->statusCode != UA_STATUSCODE_GOOD)\n        return;\n\n    ContinuationPoint cp;\n    result->statusCode = ContinuationPoint_init(&cp, maxRefs, bo->recursive);\n    if(result->statusCode != UA_STATUSCODE_GOOD) {\n        RefResult_clear(&rr);\n        return;\n    }\n    cp.bd = *descr; /* Deep-copy only when the cp is persisted in the session */\n\n    /* Add the initial node to the RefTree */\n    result->statusCode = RefTree_add(&cp.rt, &descr->nodeId);\n    if(result->statusCode != UA_STATUSCODE_GOOD) {\n        RefTree_clear(&cp.rt);\n        RefResult_clear(&rr);\n        return;\n    }\n    \n    /* Recurse to get all references */\n    UA_Boolean maxed = false;\n    result->statusCode = browseWithCp(server, session, &cp, &rr, &maxed);\n    if(result->statusCode != UA_STATUSCODE_GOOD) {\n        RefTree_clear(&cp.rt);\n        RefResult_clear(&rr);\n        return;\n    }\n\n    /* No results */\n    if(rr.size == 0) {\n        result->references = (UA_ReferenceDescription*)UA_EMPTY_ARRAY_SENTINEL;\n        RefTree_clear(&cp.rt);\n        UA_free(rr.descr);\n        return;\n    }\n\n    /* Move results to the output */\n    result->references = rr.descr;\n    result->referencesSize = rr.size;\n\n    /* Nothing left for BrowseNext */\n    if(!maxed) {\n        RefTree_clear(&cp.rt);\n        return;\n    }\n\n    /* Create a new continuation point. */\n    ContinuationPoint *newCp = (ContinuationPoint*)UA_malloc(sizeof(ContinuationPoint));\n    UA_StatusCode retval = UA_STATUSCODE_GOOD;\n    UA_ByteString tmp;\n    if(!newCp) {\n        retval = UA_STATUSCODE_BADOUTOFMEMORY;\n        goto cleanup;\n    }\n    *newCp = cp;\n\n    /* Make a deep copy of the BrowseDescription */\n    retval = UA_BrowseDescription_copy(descr, &newCp->bd);\n    if(retval != UA_STATUSCODE_GOOD)\n        goto cleanup;\n\n    /* Return the cp identifier */\n    tmp.length = sizeof(UA_Guid);\n    tmp.data = (UA_Byte*)&newCp->identifier;\n    retval = UA_ByteString_copy(&tmp, &result->continuationPoint);\n    if(retval != UA_STATUSCODE_GOOD)\n        goto cleanup;\n\n    /* Remove the oldest continuation point if required */\n    if(session->availableContinuationPoints <= 0) {\n        struct ContinuationPoint **prev = &session->continuationPoints;\n        struct ContinuationPoint *cp2 = session->continuationPoints;\n        while(cp2 && cp2->next) {\n            prev = &cp2->next;\n            cp2 = cp2->next;\n        }\n        if(cp2) {\n            *prev = NULL;\n            ContinuationPoint_clear(cp2);\n            UA_free(cp2);\n            ++session->availableContinuationPoints;\n        }\n    }\n\n    /* Attach the cp to the session */\n    newCp->next = session->continuationPoints;\n    session->continuationPoints = newCp;\n    --session->availableContinuationPoints;\n    return;\n\n cleanup:\n    UA_BrowseResult_deleteMembers(result); /* Holds the content that was in rr before */\n    if(newCp) {\n        ContinuationPoint_clear(newCp);\n        UA_free(newCp);\n    }\n    result->statusCode = retval;\n}\n",
    "target": 0,
    "idx": 2015152
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "LZ4_FORCE_INLINE int LZ4_compress_generic(\n                 LZ4_stream_t_internal* const cctx,\n                 const char* const source,\n                 char* const dest,\n                 const int inputSize,\n                 int *inputConsumed, /* only written when outputDirective == fillOutput */\n                 const int maxOutputSize,\n                 const limitedOutput_directive outputDirective,\n                 const tableType_t tableType,\n                 const dict_directive dictDirective,\n                 const dictIssue_directive dictIssue,\n                 const int acceleration)\n{\n    int result;\n    const BYTE* ip = (const BYTE*) source;\n\n    U32 const startIndex = cctx->currentOffset;\n    const BYTE* base = (const BYTE*) source - startIndex;\n    const BYTE* lowLimit;\n\n    const LZ4_stream_t_internal* dictCtx = (const LZ4_stream_t_internal*) cctx->dictCtx;\n    const BYTE* const dictionary =\n        dictDirective == usingDictCtx ? dictCtx->dictionary : cctx->dictionary;\n    const U32 dictSize =\n        dictDirective == usingDictCtx ? dictCtx->dictSize : cctx->dictSize;\n    const U32 dictDelta = (dictDirective == usingDictCtx) ? startIndex - dictCtx->currentOffset : 0;   /* make indexes in dictCtx comparable with index in current context */\n\n    int const maybe_extMem = (dictDirective == usingExtDict) || (dictDirective == usingDictCtx);\n    U32 const prefixIdxLimit = startIndex - dictSize;   /* used when dictDirective == dictSmall */\n    const BYTE* const dictEnd = dictionary + dictSize;\n    const BYTE* anchor = (const BYTE*) source;\n    const BYTE* const iend = ip + inputSize;\n    const BYTE* const mflimitPlusOne = iend - MFLIMIT + 1;\n    const BYTE* const matchlimit = iend - LASTLITERALS;\n\n    /* the dictCtx currentOffset is indexed on the start of the dictionary,\n     * while a dictionary in the current context precedes the currentOffset */\n    const BYTE* dictBase = (dictDirective == usingDictCtx) ?\n                            dictionary + dictSize - dictCtx->currentOffset :\n                            dictionary + dictSize - startIndex;\n\n    BYTE* op = (BYTE*) dest;\n    BYTE* const olimit = op + maxOutputSize;\n\n    U32 offset = 0;\n    U32 forwardH;\n\n    DEBUGLOG(5, \"LZ4_compress_generic: srcSize=%i, tableType=%u\", inputSize, tableType);\n    /* If init conditions are not met, we don't have to mark stream\n     * as having dirty context, since no action was taken yet */\n    if (outputDirective == fillOutput && maxOutputSize < 1) { return 0; } /* Impossible to store anything */\n    if ((U32)inputSize > (U32)LZ4_MAX_INPUT_SIZE) { return 0; }           /* Unsupported inputSize, too large (or negative) */\n    if ((tableType == byU16) && (inputSize>=LZ4_64Klimit)) { return 0; }  /* Size too large (not within 64K limit) */\n    if (tableType==byPtr) assert(dictDirective==noDict);      /* only supported use case with byPtr */\n    assert(acceleration >= 1);\n\n    lowLimit = (const BYTE*)source - (dictDirective == withPrefix64k ? dictSize : 0);\n\n    /* Update context state */\n    if (dictDirective == usingDictCtx) {\n        /* Subsequent linked blocks can't use the dictionary. */\n        /* Instead, they use the block we just compressed. */\n        cctx->dictCtx = NULL;\n        cctx->dictSize = (U32)inputSize;\n    } else {\n        cctx->dictSize += (U32)inputSize;\n    }\n    cctx->currentOffset += (U32)inputSize;\n    cctx->tableType = (U16)tableType;\n\n    if (inputSize<LZ4_minLength) goto _last_literals;        /* Input too small, no compression (all literals) */\n\n    /* First Byte */\n    LZ4_putPosition(ip, cctx->hashTable, tableType, base);\n    ip++; forwardH = LZ4_hashPosition(ip, tableType);\n\n    /* Main Loop */\n    for ( ; ; ) {\n        const BYTE* match;\n        BYTE* token;\n        const BYTE* filledIp;\n\n        /* Find a match */\n        if (tableType == byPtr) {\n            const BYTE* forwardIp = ip;\n            int step = 1;\n            int searchMatchNb = acceleration << LZ4_skipTrigger;\n            do {\n                U32 const h = forwardH;\n                ip = forwardIp;\n                forwardIp += step;\n                step = (searchMatchNb++ >> LZ4_skipTrigger);\n\n                if (unlikely(forwardIp > mflimitPlusOne)) goto _last_literals;\n                assert(ip < mflimitPlusOne);\n\n                match = LZ4_getPositionOnHash(h, cctx->hashTable, tableType, base);\n                forwardH = LZ4_hashPosition(forwardIp, tableType);\n                LZ4_putPositionOnHash(ip, h, cctx->hashTable, tableType, base);\n\n            } while ( (match+LZ4_DISTANCE_MAX < ip)\n                   || (LZ4_read32(match) != LZ4_read32(ip)) );\n\n        } else {   /* byU32, byU16 */\n\n            const BYTE* forwardIp = ip;\n            int step = 1;\n            int searchMatchNb = acceleration << LZ4_skipTrigger;\n            do {\n                U32 const h = forwardH;\n                U32 const current = (U32)(forwardIp - base);\n                U32 matchIndex = LZ4_getIndexOnHash(h, cctx->hashTable, tableType);\n                assert(matchIndex <= current);\n                assert(forwardIp - base < (ptrdiff_t)(2 GB - 1));\n                ip = forwardIp;\n                forwardIp += step;\n                step = (searchMatchNb++ >> LZ4_skipTrigger);\n\n                if (unlikely(forwardIp > mflimitPlusOne)) goto _last_literals;\n                assert(ip < mflimitPlusOne);\n\n                if (dictDirective == usingDictCtx) {\n                    if (matchIndex < startIndex) {\n                        /* there was no match, try the dictionary */\n                        assert(tableType == byU32);\n                        matchIndex = LZ4_getIndexOnHash(h, dictCtx->hashTable, byU32);\n                        match = dictBase + matchIndex;\n                        matchIndex += dictDelta;   /* make dictCtx index comparable with current context */\n                        lowLimit = dictionary;\n                    } else {\n                        match = base + matchIndex;\n                        lowLimit = (const BYTE*)source;\n                    }\n                } else if (dictDirective==usingExtDict) {\n                    if (matchIndex < startIndex) {\n                        DEBUGLOG(7, \"extDict candidate: matchIndex=%5u  <  startIndex=%5u\", matchIndex, startIndex);\n                        assert(startIndex - matchIndex >= MINMATCH);\n                        match = dictBase + matchIndex;\n                        lowLimit = dictionary;\n                    } else {\n                        match = base + matchIndex;\n                        lowLimit = (const BYTE*)source;\n                    }\n                } else {   /* single continuous memory segment */\n                    match = base + matchIndex;\n                }\n                forwardH = LZ4_hashPosition(forwardIp, tableType);\n                LZ4_putIndexOnHash(current, h, cctx->hashTable, tableType);\n\n                DEBUGLOG(7, \"candidate at pos=%u  (offset=%u \\n\", matchIndex, current - matchIndex);\n                if ((dictIssue == dictSmall) && (matchIndex < prefixIdxLimit)) { continue; }    /* match outside of valid area */\n                assert(matchIndex < current);\n                if ( ((tableType != byU16) || (LZ4_DISTANCE_MAX < LZ4_DISTANCE_ABSOLUTE_MAX))\n                  && (matchIndex+LZ4_DISTANCE_MAX < current)) {\n                    continue;\n                } /* too far */\n                assert((current - matchIndex) <= LZ4_DISTANCE_MAX);  /* match now expected within distance */\n\n                if (LZ4_read32(match) == LZ4_read32(ip)) {\n                    if (maybe_extMem) offset = current - matchIndex;\n                    break;   /* match found */\n                }\n\n            } while(1);\n        }\n\n        /* Catch up */\n        filledIp = ip;\n        while (((ip>anchor) & (match > lowLimit)) && (unlikely(ip[-1]==match[-1]))) { ip--; match--; }\n\n        /* Encode Literals */\n        {   unsigned const litLength = (unsigned)(ip - anchor);\n            token = op++;\n            if ((outputDirective == limitedOutput) &&  /* Check output buffer overflow */\n                (unlikely(op + litLength + (2 + 1 + LASTLITERALS) + (litLength/255) > olimit)) ) {\n                return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */\n            }\n            if ((outputDirective == fillOutput) &&\n                (unlikely(op + (litLength+240)/255 /* litlen */ + litLength /* literals */ + 2 /* offset */ + 1 /* token */ + MFLIMIT - MINMATCH /* min last literals so last match is <= end - MFLIMIT */ > olimit))) {\n                op--;\n                goto _last_literals;\n            }\n            if (litLength >= RUN_MASK) {\n                int len = (int)(litLength - RUN_MASK);\n                *token = (RUN_MASK<<ML_BITS);\n                for(; len >= 255 ; len-=255) *op++ = 255;\n                *op++ = (BYTE)len;\n            }\n            else *token = (BYTE)(litLength<<ML_BITS);\n\n            /* Copy Literals */\n            LZ4_wildCopy8(op, anchor, op+litLength);\n            op+=litLength;\n            DEBUGLOG(6, \"seq.start:%i, literals=%u, match.start:%i\",\n                        (int)(anchor-(const BYTE*)source), litLength, (int)(ip-(const BYTE*)source));\n        }\n\n_next_match:\n        /* at this stage, the following variables must be correctly set :\n         * - ip : at start of LZ operation\n         * - match : at start of previous pattern occurence; can be within current prefix, or within extDict\n         * - offset : if maybe_ext_memSegment==1 (constant)\n         * - lowLimit : must be == dictionary to mean \"match is within extDict\"; must be == source otherwise\n         * - token and *token : position to write 4-bits for match length; higher 4-bits for literal length supposed already written\n         */\n\n        if ((outputDirective == fillOutput) &&\n            (op + 2 /* offset */ + 1 /* token */ + MFLIMIT - MINMATCH /* min last literals so last match is <= end - MFLIMIT */ > olimit)) {\n            /* the match was too close to the end, rewind and go to last literals */\n            op = token;\n            goto _last_literals;\n        }\n\n        /* Encode Offset */\n        if (maybe_extMem) {   /* static test */\n            DEBUGLOG(6, \"             with offset=%u  (ext if > %i)\", offset, (int)(ip - (const BYTE*)source));\n            assert(offset <= LZ4_DISTANCE_MAX && offset > 0);\n            LZ4_writeLE16(op, (U16)offset); op+=2;\n        } else  {\n            DEBUGLOG(6, \"             with offset=%u  (same segment)\", (U32)(ip - match));\n            assert(ip-match <= LZ4_DISTANCE_MAX);\n            LZ4_writeLE16(op, (U16)(ip - match)); op+=2;\n        }\n\n        /* Encode MatchLength */\n        {   unsigned matchCode;\n\n            if ( (dictDirective==usingExtDict || dictDirective==usingDictCtx)\n              && (lowLimit==dictionary) /* match within extDict */ ) {\n                const BYTE* limit = ip + (dictEnd-match);\n                assert(dictEnd > match);\n                if (limit > matchlimit) limit = matchlimit;\n                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, limit);\n                ip += (size_t)matchCode + MINMATCH;\n                if (ip==limit) {\n                    unsigned const more = LZ4_count(limit, (const BYTE*)source, matchlimit);\n                    matchCode += more;\n                    ip += more;\n                }\n                DEBUGLOG(6, \"             with matchLength=%u starting in extDict\", matchCode+MINMATCH);\n            } else {\n                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, matchlimit);\n                ip += (size_t)matchCode + MINMATCH;\n                DEBUGLOG(6, \"             with matchLength=%u\", matchCode+MINMATCH);\n            }\n\n            if ((outputDirective) &&    /* Check output buffer overflow */\n                (unlikely(op + (1 + LASTLITERALS) + (matchCode+240)/255 > olimit)) ) {\n                if (outputDirective == fillOutput) {\n                    /* Match description too long : reduce it */\n                    U32 newMatchCode = 15 /* in token */ - 1 /* to avoid needing a zero byte */ + ((U32)(olimit - op) - 1 - LASTLITERALS) * 255;\n                    ip -= matchCode - newMatchCode;\n                    assert(newMatchCode < matchCode);\n                    matchCode = newMatchCode;\n                    if (unlikely(ip < filledIp)) {\n                        /* We have already filled up to filledIp so if ip ends up less than filledIp\n                         * we have positions in the hash table beyond the current position. This is\n                         * a problem if we reuse the hash table. So we have to remove these positions\n                         * from the hash table.\n                         */\n                        const BYTE* ptr;\n                        DEBUGLOG(5, \"Clearing %u positions\", (U32)(filledIp - ip));\n                        for (ptr = ip + 1; ptr <= filledIp; ++ptr) {\n                            U32 const h = LZ4_hashPosition(ptr, tableType);\n                            LZ4_clearHash(h, cctx->hashTable, tableType);\n                        }\n                    }\n                } else {\n                    assert(outputDirective == limitedOutput);\n                    return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */\n                }\n            }\n            if (matchCode >= ML_MASK) {\n                *token += ML_MASK;\n                matchCode -= ML_MASK;\n                LZ4_write32(op, 0xFFFFFFFF);\n                while (matchCode >= 4*255) {\n                    op+=4;\n                    LZ4_write32(op, 0xFFFFFFFF);\n                    matchCode -= 4*255;\n                }\n                op += matchCode / 255;\n                *op++ = (BYTE)(matchCode % 255);\n            } else\n                *token += (BYTE)(matchCode);\n        }\n        /* Ensure we have enough space for the last literals. */\n        assert(!(outputDirective == fillOutput && op + 1 + LASTLITERALS > olimit));\n\n        anchor = ip;\n\n        /* Test end of chunk */\n        if (ip >= mflimitPlusOne) break;\n\n        /* Fill table */\n        LZ4_putPosition(ip-2, cctx->hashTable, tableType, base);\n\n        /* Test next position */\n        if (tableType == byPtr) {\n\n            match = LZ4_getPosition(ip, cctx->hashTable, tableType, base);\n            LZ4_putPosition(ip, cctx->hashTable, tableType, base);\n            if ( (match+LZ4_DISTANCE_MAX >= ip)\n              && (LZ4_read32(match) == LZ4_read32(ip)) )\n            { token=op++; *token=0; goto _next_match; }\n\n        } else {   /* byU32, byU16 */\n\n            U32 const h = LZ4_hashPosition(ip, tableType);\n            U32 const current = (U32)(ip-base);\n            U32 matchIndex = LZ4_getIndexOnHash(h, cctx->hashTable, tableType);\n            assert(matchIndex < current);\n            if (dictDirective == usingDictCtx) {\n                if (matchIndex < startIndex) {\n                    /* there was no match, try the dictionary */\n                    matchIndex = LZ4_getIndexOnHash(h, dictCtx->hashTable, byU32);\n                    match = dictBase + matchIndex;\n                    lowLimit = dictionary;   /* required for match length counter */\n                    matchIndex += dictDelta;\n                } else {\n                    match = base + matchIndex;\n                    lowLimit = (const BYTE*)source;  /* required for match length counter */\n                }\n            } else if (dictDirective==usingExtDict) {\n                if (matchIndex < startIndex) {\n                    match = dictBase + matchIndex;\n                    lowLimit = dictionary;   /* required for match length counter */\n                } else {\n                    match = base + matchIndex;\n                    lowLimit = (const BYTE*)source;   /* required for match length counter */\n                }\n            } else {   /* single memory segment */\n                match = base + matchIndex;\n            }\n            LZ4_putIndexOnHash(current, h, cctx->hashTable, tableType);\n            assert(matchIndex < current);\n            if ( ((dictIssue==dictSmall) ? (matchIndex >= prefixIdxLimit) : 1)\n              && (((tableType==byU16) && (LZ4_DISTANCE_MAX == LZ4_DISTANCE_ABSOLUTE_MAX)) ? 1 : (matchIndex+LZ4_DISTANCE_MAX >= current))\n              && (LZ4_read32(match) == LZ4_read32(ip)) ) {\n                token=op++;\n                *token=0;\n                if (maybe_extMem) offset = current - matchIndex;\n                DEBUGLOG(6, \"seq.start:%i, literals=%u, match.start:%i\",\n                            (int)(anchor-(const BYTE*)source), 0, (int)(ip-(const BYTE*)source));\n                goto _next_match;\n            }\n        }\n\n        /* Prepare next loop */\n        forwardH = LZ4_hashPosition(++ip, tableType);\n\n    }\n\n_last_literals:\n    /* Encode Last Literals */\n    {   size_t lastRun = (size_t)(iend - anchor);\n        if ( (outputDirective) &&  /* Check output buffer overflow */\n            (op + lastRun + 1 + ((lastRun+255-RUN_MASK)/255) > olimit)) {\n            if (outputDirective == fillOutput) {\n                /* adapt lastRun to fill 'dst' */\n                assert(olimit >= op);\n                lastRun  = (size_t)(olimit-op) - 1;\n                lastRun -= (lastRun+240)/255;\n            } else {\n                assert(outputDirective == limitedOutput);\n                return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */\n            }\n        }\n        if (lastRun >= RUN_MASK) {\n            size_t accumulator = lastRun - RUN_MASK;\n            *op++ = RUN_MASK << ML_BITS;\n            for(; accumulator >= 255 ; accumulator-=255) *op++ = 255;\n            *op++ = (BYTE) accumulator;\n        } else {\n            *op++ = (BYTE)(lastRun<<ML_BITS);\n        }\n        memcpy(op, anchor, lastRun);\n        ip = anchor + lastRun;\n        op += lastRun;\n    }\n\n    if (outputDirective == fillOutput) {\n        *inputConsumed = (int) (((const char*)ip)-source);\n    }\n    DEBUGLOG(5, \"LZ4_compress_generic: compressed %i bytes into %i bytes\", inputSize, (int)(((char*)op) - dest));\n    result = (int)(((char*)op) - dest);\n    assert(result > 0);\n    return result;\n}\n",
    "target": 0,
    "idx": 2015941
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "int\ncdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h,\n    uint32_t offs, cdf_property_info_t **info, size_t *count, size_t *maxcount)\n{\n\tconst cdf_section_header_t *shp;\n\tcdf_section_header_t sh;\n\tconst uint8_t *p, *q, *e;\n\tsize_t i, o4, nelements, j, slen, left;\n\tcdf_property_info_t *inp;\n\n\tif (offs > UINT32_MAX / 4) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tshp = CAST(const cdf_section_header_t *,\n\t    cdf_offset(sst->sst_tab, offs));\n\tif (cdf_check_stream_offset(sst, h, shp, sizeof(*shp), __LINE__) == -1)\n\t\tgoto out;\n\tsh.sh_len = CDF_TOLE4(shp->sh_len);\n\tif (sh.sh_len > CDF_SHLEN_LIMIT) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\n\tif (cdf_check_stream_offset(sst, h, shp, sh.sh_len, __LINE__) == -1)\n\t\tgoto out;\n\n\tsh.sh_properties = CDF_TOLE4(shp->sh_properties);\n\tDPRINTF((\"section len: %u properties %u\\n\", sh.sh_len,\n\t    sh.sh_properties));\n\tif (sh.sh_properties > CDF_PROP_LIMIT)\n\t\tgoto out;\n\tinp = cdf_grow_info(info, maxcount, sh.sh_properties);\n\tif (inp == NULL)\n\t\tgoto out;\n\tinp += *count;\n\t*count += sh.sh_properties;\n\tp = CAST(const uint8_t *, cdf_offset(sst->sst_tab, offs + sizeof(sh)));\n\te = CAST(const uint8_t *, cdf_offset(shp, sh.sh_len));\n\tif (p >= e || cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1)\n\t\tgoto out;\n\n\tfor (i = 0; i < sh.sh_properties; i++) {\n\t\tif ((q = cdf_get_property_info_pos(sst, h, p, e, i)) == NULL)\n\t\t\tgoto out;\n\t\tinp[i].pi_id = CDF_GETUINT32(p, i << 1);\n\t\tleft = CAST(size_t, e - q);\n\t\tif (left < sizeof(uint32_t)) {\n\t\t\tDPRINTF((\"short info (no type)_\\n\"));\n\t\t\tgoto out;\n\t\t}\n\t\tinp[i].pi_type = CDF_GETUINT32(q, 0);\n\t\tDPRINTF((\"%\" SIZE_T_FORMAT \"u) id=%#x type=%#x offs=%#tx,%#x\\n\",\n\t\t    i, inp[i].pi_id, inp[i].pi_type, q - p, offs));\n\t\tif (inp[i].pi_type & CDF_VECTOR) {\n\t\t\tif (left < sizeof(uint32_t) * 2) {\n\t\t\t\tDPRINTF((\"missing CDF_VECTOR length\\n\"));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tnelements = CDF_GETUINT32(q, 1);\n\t\t\tif (nelements > CDF_ELEMENT_LIMIT || nelements == 0) {\n\t\t\t\tDPRINTF((\"CDF_VECTOR with nelements == %\"\n\t\t\t\t    SIZE_T_FORMAT \"u\\n\", nelements));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tslen = 2;\n\t\t} else {\n\t\t\tnelements = 1;\n\t\t\tslen = 1;\n\t\t}\n\t\to4 = slen * sizeof(uint32_t);\n\t\tif (inp[i].pi_type & (CDF_ARRAY|CDF_BYREF|CDF_RESERVED))\n\t\t\tgoto unknown;\n\t\tswitch (inp[i].pi_type & CDF_TYPEMASK) {\n\t\tcase CDF_NULL:\n\t\tcase CDF_EMPTY:\n\t\t\tbreak;\n\t\tcase CDF_SIGNED16:\n\t\t\tif (!cdf_copy_info(&inp[i], &q[o4], e, sizeof(int16_t)))\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tcase CDF_SIGNED32:\n\t\tcase CDF_BOOL:\n\t\tcase CDF_UNSIGNED32:\n\t\tcase CDF_FLOAT:\n\t\t\tif (!cdf_copy_info(&inp[i], &q[o4], e, sizeof(int32_t)))\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tcase CDF_SIGNED64:\n\t\tcase CDF_UNSIGNED64:\n\t\tcase CDF_DOUBLE:\n\t\tcase CDF_FILETIME:\n\t\t\tif (!cdf_copy_info(&inp[i], &q[o4], e, sizeof(int64_t)))\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tcase CDF_LENGTH32_STRING:\n\t\tcase CDF_LENGTH32_WSTRING:\n\t\t\tif (nelements > 1) {\n\t\t\t\tsize_t nelem = inp - *info;\n\t\t\t\tinp = cdf_grow_info(info, maxcount, nelements);\n\t\t\t\tif (inp == NULL)\n\t\t\t\t\tgoto out;\n\t\t\t\tinp += nelem;\n\t\t\t}\n\t\t\tfor (j = 0; j < nelements && i < sh.sh_properties;\n\t\t\t    j++, i++)\n\t\t\t{\n\t\t\t\tuint32_t l;\n\n\t\t\t\tif (o4 + sizeof(uint32_t) > left)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tl = CDF_GETUINT32(q, slen);\n\t\t\t\to4 += sizeof(uint32_t);\n\t\t\t\tif (o4 + l > left)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tinp[i].pi_str.s_len = l;\n\t\t\t\tinp[i].pi_str.s_buf = CAST(const char *,\n\t\t\t\t    CAST(const void *, &q[o4]));\n\n\t\t\t\tDPRINTF((\"o=%\" SIZE_T_FORMAT \"u l=%d(%\"\n\t\t\t\t    SIZE_T_FORMAT \"u), t=%\" SIZE_T_FORMAT\n\t\t\t\t    \"u s=%s\\n\", o4, l, CDF_ROUND(l, sizeof(l)),\n\t\t\t\t    left, inp[i].pi_str.s_buf));\n\n\t\t\t\tif (l & 1)\n\t\t\t\t\tl++;\n\n\t\t\t\tslen += l >> 1;\n\t\t\t\to4 = slen * sizeof(uint32_t);\n\t\t\t}\n\t\t\ti--;\n\t\t\tbreak;\n\t\tcase CDF_CLIPBOARD:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tdefault:\n\t\tunknown:\n\t\t\tmemset(&inp[i].pi_val, 0, sizeof(inp[i].pi_val));\n\t\t\tDPRINTF((\"Don't know how to deal with %#x\\n\",\n\t\t\t    inp[i].pi_type));\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\nout:\n\tfree(*info);\n\t*info = NULL;\n\t*count = 0;\n\t*maxcount = 0;\n\terrno = EFTYPE;\n\treturn -1;\n}\n",
    "target": 0,
    "idx": 2016780
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "void Leader::HandleCommissioningGet(Coap::Message &aMessage, const Ip6::MessageInfo &aMessageInfo)\n{\n    uint16_t length = 0;\n    uint16_t offset;\n\n    SuccessOrExit(Tlv::GetValueOffset(aMessage, MeshCoP::Tlv::kGet, offset, length));\n    aMessage.SetOffset(offset);\n\nexit:\n    SendCommissioningGetResponse(aMessage, length, aMessageInfo);\n}\nvoid Leader::SendCommissioningGetResponse(const Coap::Message &   aRequest,\n                                          uint16_t                aLength,\n                                          const Ip6::MessageInfo &aMessageInfo)\n{\n    otError        error = OT_ERROR_NONE;\n    Coap::Message *message;\n    uint8_t        index;\n    uint8_t *      data   = NULL;\n    uint8_t        length = 0;\n\n    VerifyOrExit((message = MeshCoP::NewMeshCoPMessage(Get<Coap::Coap>())) != NULL, error = OT_ERROR_NO_BUFS);\n\n    SuccessOrExit(error = message->SetDefaultResponseHeader(aRequest));\n    SuccessOrExit(error = message->SetPayloadMarker());\n\n    for (NetworkDataTlv *cur                                            = reinterpret_cast<NetworkDataTlv *>(mTlvs);\n         cur < reinterpret_cast<NetworkDataTlv *>(mTlvs + mLength); cur = cur->GetNext())\n    {\n        if (cur->GetType() == NetworkDataTlv::kTypeCommissioningData)\n        {\n            data   = cur->GetValue();\n            length = cur->GetLength();\n            break;\n        }\n    }\n\n    VerifyOrExit(data && length, error = OT_ERROR_DROP);\n\n    if (aLength == 0)\n    {\n        SuccessOrExit(error = message->Append(data, length));\n    }\n    else\n    {\n        for (index = 0; index < aLength; index++)\n        {\n            uint8_t type;\n\n            aRequest.Read(aRequest.GetOffset() + index, sizeof(type), &type);\n\n            for (MeshCoP::Tlv *cur                                          = reinterpret_cast<MeshCoP::Tlv *>(data);\n                 cur < reinterpret_cast<MeshCoP::Tlv *>(data + length); cur = cur->GetNext())\n            {\n                if (cur->GetType() == type)\n                {\n                    SuccessOrExit(error = message->AppendTlv(*cur));\n                    break;\n                }\n            }\n        }\n    }\n\n    if (message->GetLength() == message->GetOffset())\n    {\n        // no payload, remove coap payload marker\n        message->SetLength(message->GetLength() - 1);\n    }\n\n    SuccessOrExit(error = Get<Coap::Coap>().SendMessage(*message, aMessageInfo));\n\n    otLogInfoMeshCoP(\"sent commissioning dataset get response\");\n\nexit:\n\n    if (error != OT_ERROR_NONE && message != NULL)\n    {\n        message->Free();\n    }\n}\n",
    "target": 0,
    "idx": 2017330
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "static int\nprint_branch (disassemble_info *info,\n\t      unsigned long insn_word,\n\t      struct instruction *insn)\n{\n  char operand[2][OPERAND_BUFFER_LEN] =\n  {\n    {0},\n    {0}\n  };\n  unsigned long address;\n  int print_label = 0;\n\n  if (insn->tm == NULL)\n    return 0;\n  /* Get the operands for 24-bit immediate jumps.  */\n  if (insn->tm->operand_types[0] & Imm24)\n    {\n      address = insn_word & 0x00FFFFFF;\n      sprintf (operand[0], \"0x%lX\", address);\n      print_label = 1;\n    }\n  /* Get the operand for the trap instruction.  */\n  else if (insn->tm->operand_types[0] & IVector)\n    {\n      address = insn_word & 0x0000001F;\n      sprintf (operand[0], \"0x%lX\", address);\n    }\n  else\n    {\n      address = insn_word & 0x0000FFFF;\n      /* Get the operands for the DB instructions.  */\n      if (insn->tm->operands == 2)\n\t{\n\t  get_register_operand (((insn_word & 0x01C00000) >> 22) + REG_AR0, operand[0]);\n\t  if (insn_word & PCRel)\n\t    {\n\t      sprintf (operand[1], \"%d\", (short) address);\n\t      print_label = 1;\n\t    }\n\t  else\n\t    get_register_operand (insn_word & 0x0000001F, operand[1]);\n\t}\n      /* Get the operands for the standard branches.  */\n      else if (insn->tm->operands == 1)\n\t{\n\t  if (insn_word & PCRel)\n\t    {\n\t      address = (short) address;\n\t      sprintf (operand[0], \"%ld\", address);\n\t      print_label = 1;\n\t    }\n\t  else\n\t    get_register_operand (insn_word & 0x0000001F, operand[0]);\n\t}\n    }\n  info->fprintf_func (info->stream, \"   %s %s%c%s\", insn->tm->name,\n\t\t      operand[0][0] ? operand[0] : \"\",\n\t\t      operand[1][0] ? ',' : ' ',\n\t\t      operand[1][0] ? operand[1] : \"\");\n  /* Print destination of branch in relation to current symbol.  */\n  if (print_label && info->symbols)\n    {\n      asymbol *sym = *info->symbols;\n\n      if ((insn->tm->opcode_modifier == PCRel) && (insn_word & PCRel))\n\t{\n\t  address = (_pc + 1 + (short) address) - ((sym->section->vma + sym->value) / 4);\n\t  /* Check for delayed instruction, if so adjust destination.  */\n\t  if (insn_word & 0x00200000)\n\t    address += 2;\n\t}\n      else\n\t{\n\t  address -= ((sym->section->vma + sym->value) / 4);\n\t}\n      if (address == 0)\n\tinfo->fprintf_func (info->stream, \" <%s>\", sym->name);\n      else\n\tinfo->fprintf_func (info->stream, \" <%s %c %lu>\", sym->name,\n\t\t\t    ((short) address < 0) ? '-' : '+',\n\t\t\t    address);\n    }\n  return 1;\n}\n",
    "target": 0,
    "idx": 2018615
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "extern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)\n{\n    static char copy[32768];\n    struct lwan_tpl *tpl;\n\n    size = min(sizeof(copy) - 1, size);\n    memcpy(copy, data, size);\n    copy[size] = '\\0';\n\n    tpl = lwan_tpl_compile_string_full(copy, file_list_desc,\n                                       LWAN_TPL_FLAG_CONST_TEMPLATE);\n    if (tpl)\n        lwan_tpl_free(tpl);\n\n    return tpl ? 1 : 0;\n}\n",
    "target": 0,
    "idx": 2018988
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "otError Commissioner::GeneratePskc(const char *              aPassPhrase,\n                                   const char *              aNetworkName,\n                                   const Mac::ExtendedPanId &aExtPanId,\n                                   Pskc &                    aPskc)\n{\n    otError     error      = OT_ERROR_NONE;\n    const char *saltPrefix = \"Thread\";\n    uint8_t     salt[OT_PBKDF2_SALT_MAX_LEN];\n    uint16_t    saltLen = 0;\n\n    VerifyOrExit((strlen(aPassPhrase) >= OT_COMMISSIONING_PASSPHRASE_MIN_SIZE) &&\n                     (strlen(aPassPhrase) <= OT_COMMISSIONING_PASSPHRASE_MAX_SIZE) &&\n                     (strlen(aNetworkName) <= OT_NETWORK_NAME_MAX_SIZE),\n                 error = OT_ERROR_INVALID_ARGS);\n\n    memset(salt, 0, sizeof(salt));\n    memcpy(salt, saltPrefix, strlen(saltPrefix));\n    saltLen += static_cast<uint16_t>(strlen(saltPrefix));\n\n    memcpy(salt + saltLen, aExtPanId.m8, sizeof(aExtPanId));\n    saltLen += OT_EXT_PAN_ID_SIZE;\n\n    memcpy(salt + saltLen, aNetworkName, strlen(aNetworkName));\n    saltLen += static_cast<uint16_t>(strlen(aNetworkName));\n\n    otPbkdf2Cmac(reinterpret_cast<const uint8_t *>(aPassPhrase), static_cast<uint16_t>(strlen(aPassPhrase)),\n                 reinterpret_cast<const uint8_t *>(salt), saltLen, 16384, OT_PSKC_MAX_SIZE, aPskc.m8);\n\nexit:\n    return error;\n}\n",
    "target": 0,
    "idx": 2019386
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "static int\npgp_parse_algo_attr_blob(const pgp_blob_t *blob, sc_cardctl_openpgp_keygen_info_t *key_info)\n{\n\tstruct sc_object_id oid;\n\tunsigned int j;\n\n\tif (blob == NULL || blob->data == NULL || blob->len == 0 ||\n\t    blob->id < 0x00c1 || blob->id > 0x00c3 || key_info == NULL)\n\t\treturn SC_ERROR_INCORRECT_PARAMETERS;\n\n\tkey_info->key_id = blob->id - 0x00c0;\t/* attribute algorithm blobs are C1 - C3 */\n\n\tswitch (blob->data[0]) {\n\t\tcase SC_OPENPGP_KEYALGO_RSA:\n\t\t\tif (blob->len < 5)\n\t\t\t\treturn SC_ERROR_INCORRECT_PARAMETERS;\n\n\t\t\tkey_info->algorithm = SC_OPENPGP_KEYALGO_RSA;\n\t\t\tkey_info->u.rsa.modulus_len = bebytes2ushort(blob->data + 1);\n\t\t\tkey_info->u.rsa.exponent_len = bebytes2ushort(blob->data + 3);\n\n\t\t\tkey_info->u.rsa.keyformat = (blob->len > 5)\n\t\t\t\t\t\t  ? blob->data[5]\n\t\t\t\t\t\t  : SC_OPENPGP_KEYFORMAT_RSA_STD;\n\t\t\tbreak;\n\t\tcase SC_OPENPGP_KEYALGO_ECDH:\n\t\tcase SC_OPENPGP_KEYALGO_ECDSA:\n\n\t\t\t/* SC_OPENPGP_KEYALGO_ECDH || SC_OPENPGP_KEYALGO_ECDSA */\n\t\t\tkey_info->algorithm = blob->data[0];\n\n\t\t\tsc_init_oid(&oid);\n\t\t\t/* Create copy of oid from blob */\n\t\t\tfor (j=0; j < (blob->len-1) && j < SC_MAX_OBJECT_ID_OCTETS; j++) {\n\t\t\t\toid.value[j] = blob->data[j+1]; /* ignore first byte of blob (algo ID) */\n\t\t\t}\n\n\t\t\t/* compare with list of supported ec_curves */\n\t\t\tfor (j=0; ec_curves[j].oid.value[0] >= 0; j++){\n\t\t\t\tif (sc_compare_oid(&ec_curves[j].oid_binary, &oid)){\n\t\t\t\t\tkey_info->u.ec.oid = ec_curves[j].oid;\n\t\t\t\t\tkey_info->u.ec.key_length = ec_curves[j].size;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn SC_ERROR_NOT_IMPLEMENTED;\n\t}\n\n\treturn SC_SUCCESS;\n}\n",
    "target": 0,
    "idx": 2019548
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "static int tcos_decipher(sc_card_t *card, const u8 * crgram, size_t crgram_len, u8 * out, size_t outlen)\n{\n\tsc_context_t *ctx;\n\tsc_apdu_t apdu;\n\tu8 rbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tu8 sbuf[SC_MAX_APDU_BUFFER_SIZE];\n\ttcos_data *data;\n\tint tcos3, r;\n\n\tassert(card != NULL && crgram != NULL && out != NULL);\n\tctx = card->ctx;\n\ttcos3=(card->type==SC_CARD_TYPE_TCOS_V3);\n\tdata=(tcos_data *)card->drv_data;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx,\n\t\t\"TCOS3:%d PKCS1:%d\\n\",tcos3,\n\t\t!!(data->pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1));\n\n\tsc_format_apdu(card, &apdu, crgram_len>255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT, 0x2A, 0x80, 0x86);\n\tapdu.resp = rbuf;\n\tapdu.resplen = sizeof(rbuf);\n\tapdu.le = crgram_len;\n\n\tapdu.data = sbuf;\n\tapdu.lc = apdu.datalen = crgram_len+1;\n\tsbuf[0] = tcos3 ? 0x00 : ((data->pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1) ? 0x81 : 0x02);\n\tif (sizeof sbuf - 1 < crgram_len)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\tmemcpy(sbuf+1, crgram, crgram_len);\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\n\tif (apdu.sw1==0x90 && apdu.sw2==0x00) {\n\t\tsize_t len= (apdu.resplen>outlen) ? outlen : apdu.resplen;\n\t\tunsigned int offset=0;\n\t\tif(tcos3 && (data->pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1) && apdu.resp[0]==0 && apdu.resp[1]==2) {\n\t\t\toffset=2; while(offset<len && apdu.resp[offset]!=0) ++offset;\n\t\t\toffset=(offset<len-1) ? offset+1 : 0;\n\t\t}\n\t\tmemcpy(out, apdu.resp+offset, len-offset);\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, len-offset);\n\t}\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, sc_check_sw(card, apdu.sw1, apdu.sw2));\n}\n",
    "target": 0,
    "idx": 2022967
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "int blosclz_compress(const int clevel, const void* input, int length,\n                     void* output, int maxout) {\n  uint8_t* ibase = (uint8_t*)input;\n  uint8_t* ip = ibase;\n  uint8_t* ip_bound = ibase + length - 1;\n  uint8_t* ip_limit = ibase + length - 12;\n  uint8_t* op = (uint8_t*)output;\n  uint8_t* op_limit;\n  uint32_t htab[1U << (uint8_t)HASH_LOG];\n  uint32_t hval;\n  uint32_t seq;\n  uint8_t copy;\n\n  op_limit = op + maxout;\n\n  // Minimum lengths for encoding\n  unsigned minlen_[10] = {0, 12, 12, 11, 10, 9, 8, 7, 6, 5};\n\n  // Minimum compression ratios for initiate encoding\n  double cratio_[10] = {0, 2, 2, 2, 2, 1.8, 1.6, 1.4, 1.2, 1.1};\n\n  uint8_t hashlog_[10] = {0, HASH_LOG - 2, HASH_LOG - 1, HASH_LOG, HASH_LOG,\n                          HASH_LOG, HASH_LOG, HASH_LOG, HASH_LOG, HASH_LOG};\n  uint8_t hashlog = hashlog_[clevel];\n  // Initialize the hash table to distances of 0\n  for (unsigned i = 0; i < (1U << hashlog); i++) {\n    htab[i] = 0;\n  }\n\n  /* input and output buffer cannot be less than 16 and 66 bytes or we can get into trouble */\n  if (length < 16 || maxout < 66) {\n    return 0;\n  }\n\n  /* When we go back in a match (shift), we obtain quite different compression properties.\n   * It looks like 4 is more useful in combination with bitshuffle and small typesizes\n   * (compress better and faster in e.g. `b2bench blosclz bitshuffle single 6 6291456 1 19`).\n   * Fallback to 4 because it provides more consistent results on small itemsizes.\n   *\n   * In this block we also check cratios for the beginning of the buffers and\n   * eventually discard those that are small (take too long to decompress).\n   * This process is called _entropy probing_.\n   */\n  int ipshift = 4;\n  int maxlen;  // maximum length for entropy probing\n  int csize_3b;\n  int csize_4b;\n  double cratio = 0;\n  switch (clevel) {\n    case 1:\n    case 2:\n    case 3:\n      maxlen = length / 8;\n      csize_4b = get_csize(ibase, maxlen, false);\n      cratio = (double)maxlen / csize_4b;\n      break;\n    case 4:\n    case 5:\n    case 6:\n    case 7:\n    case 8:\n      maxlen = length / 8;\n      csize_4b = get_csize(ibase, maxlen, false);\n      cratio = (double)maxlen / csize_4b;\n      break;\n    case 9:\n      // case 9 is special.  we need to asses the optimal shift\n      maxlen = length / 8;\n      csize_3b = get_csize(ibase, maxlen, true);\n      csize_4b = get_csize(ibase, maxlen, false);\n      ipshift = (csize_3b < csize_4b) ? 3 : 4;\n      cratio = (csize_3b < csize_4b) ? ((double)maxlen / csize_3b) : ((double)maxlen / csize_4b);\n      break;\n    default:\n      break;\n  }\n  // discard probes with small compression ratios (too expensive)\n  if (cratio < cratio_ [clevel]) {\n    goto out;\n  }\n\n  /* we start with literal copy */\n  copy = 4;\n  *op++ = MAX_COPY - 1;\n  *op++ = *ip++;\n  *op++ = *ip++;\n  *op++ = *ip++;\n  *op++ = *ip++;\n\n  /* main loop */\n  while (BLOSCLZ_LIKELY(ip < ip_limit)) {\n    const uint8_t* ref;\n    unsigned distance;\n    uint8_t* anchor = ip;    /* comparison starting-point */\n\n    /* find potential match */\n    seq = BLOSCLZ_READU32(ip);\n    HASH_FUNCTION(hval, seq, hashlog)\n    ref = ibase + htab[hval];\n\n    /* calculate distance to the match */\n    distance = anchor - ref;\n\n    /* update hash table */\n    htab[hval] = (uint32_t) (anchor - ibase);\n\n    if (distance == 0 || (distance >= MAX_FARDISTANCE)) {\n      LITERAL(ip, op, op_limit, anchor, copy)\n      continue;\n    }\n\n    /* is this a match? check the first 4 bytes */\n    if (BLOSCLZ_UNLIKELY(BLOSCLZ_READU32(ref) == BLOSCLZ_READU32(ip))) {\n      ref += 4;\n    } else {\n      /* no luck, copy as a literal */\n      LITERAL(ip, op, op_limit, anchor, copy)\n      continue;\n    }\n\n    /* last matched byte */\n    ip = anchor + 4;\n\n    /* distance is biased */\n    distance--;\n\n    /* get runs or matches; zero distance means a run */\n    ip = get_run_or_match(ip, ip_bound, ref, !distance);\n\n    /* length is biased, '1' means a match of 3 bytes */\n    ip -= ipshift;\n\n    unsigned len = (int)(ip - anchor);\n    // If match is close, let's reduce the minimum length to encode it\n    unsigned minlen = (clevel == 9) ? ipshift : minlen_[clevel];\n\n    // Encoding short lengths is expensive during decompression\n    // Encode only for reasonable lengths (extensive experiments done)\n    if (len < minlen || (len <= 5 && distance >= MAX_DISTANCE)) {\n      LITERAL(ip, op, op_limit, anchor, copy)\n      continue;\n    }\n\n    /* if we have copied something, adjust the copy count */\n    if (copy)\n      /* copy is biased, '0' means 1 byte copy */\n      *(op - copy - 1) = (uint8_t)(copy - 1);\n    else\n      /* back, to overwrite the copy count */\n      op--;\n    /* reset literal counter */\n    copy = 0;\n\n    /* encode the match */\n    if (distance < MAX_DISTANCE) {\n      if (len < 7) {\n        DISTANCE_SHORT(op, op_limit, len, distance)\n      } else {\n        DISTANCE_LONG(op, op_limit, len, distance)\n      }\n    } else {\n      /* far away, but not yet in the another galaxy... */\n      distance -= MAX_DISTANCE;\n      if (len < 7) {\n        DISTANCE_SHORT_FAR(op, op_limit, len, distance)\n      } else {\n        DISTANCE_LONG_FAR(op, op_limit, len, distance)\n      }\n    }\n\n    /* update the hash at match boundary */\n    seq = BLOSCLZ_READU32(ip);\n    HASH_FUNCTION(hval, seq, hashlog)\n    htab[hval] = (uint32_t) (ip++ - ibase);\n    seq >>= 8U;\n    HASH_FUNCTION(hval, seq, hashlog)\n    htab[hval] = (uint32_t) (ip++ - ibase);\n    /* assuming literal copy */\n\n    if (BLOSCLZ_UNLIKELY(op + 1 > op_limit))\n      goto out;\n    *op++ = MAX_COPY - 1;\n  }\n\n  /* left-over as literal copy */\n  while (BLOSCLZ_UNLIKELY(ip <= ip_bound)) {\n    if (BLOSCLZ_UNLIKELY(op + 2 > op_limit)) goto out;\n    *op++ = *ip++;\n    copy++;\n    if (BLOSCLZ_UNLIKELY(copy == MAX_COPY)) {\n      copy = 0;\n      *op++ = MAX_COPY - 1;\n    }\n  }\n\n  /* if we have copied something, adjust the copy length */\n  if (copy)\n    *(op - copy - 1) = (uint8_t)(copy - 1);\n  else\n    op--;\n\n  /* marker for blosclz */\n  *(uint8_t*)output |= (1U << 5U);\n\n  return (int)(op - (uint8_t*)output);\n\n  out:\n  return 0;\n}\nstatic inline void wild_copy(uint8_t *out, const uint8_t* from, uint8_t* end) {\n  uint8_t* d = out;\n  const uint8_t* s = from;\n  uint8_t* const e = end;\n\n  do { memcpy(d,s,8); d+=8; s+=8; } while (d<e);\n}\nint blosclz_decompress(const void* input, int length, void* output, int maxout) {\n  const uint8_t* ip = (const uint8_t*)input;\n  const uint8_t* ip_limit = ip + length;\n  uint8_t* op = (uint8_t*)output;\n  uint32_t ctrl;\n  uint8_t* op_limit = op + maxout;\n  if (BLOSCLZ_UNLIKELY(length == 0)) {\n    return 0;\n  }\n  ctrl = (*ip++) & 31U;\n\n  while (1) {\n    if (ctrl >= 32) {\n      // match\n      int32_t len = (ctrl >> 5U) - 1 ;\n      int32_t ofs = (ctrl & 31U) << 8U;\n      uint8_t code;\n      const uint8_t* ref = op - ofs;\n\n      if (len == 7 - 1) {\n        do {\n          if (BLOSCLZ_UNLIKELY(ip + 1 >= ip_limit)) {\n            return 0;\n          }\n          code = *ip++;\n          len += code;\n        } while (code == 255);\n      }\n      else {\n        if (BLOSCLZ_UNLIKELY(ip + 1 >= ip_limit)) {\n          return 0;\n        }\n      }\n      code = *ip++;\n      len += 3;\n      ref -= code;\n\n      /* match from 16-bit distance */\n      if (BLOSCLZ_UNLIKELY(code == 255)) {\n        if (ofs == (31U << 8U)) {\n          if (ip + 1 >= ip_limit) {\n            return 0;\n          }\n          ofs = (*ip++) << 8U;\n          ofs += *ip++;\n          ref = op - ofs - MAX_DISTANCE;\n        }\n      }\n\n      if (BLOSCLZ_UNLIKELY(op + len > op_limit)) {\n        return 0;\n      }\n\n      if (BLOSCLZ_UNLIKELY(ref - 1 < (uint8_t*)output)) {\n        return 0;\n      }\n\n      if (BLOSCLZ_UNLIKELY(ip >= ip_limit)) break;\n      ctrl = *ip++;\n\n      ref--;\n      if (ref == op - 1) {\n        /* optimized copy for a run */\n        memset(op, *ref, len);\n        op += len;\n      }\n      else if ((op - ref >= 8) && (op_limit - op >= len + 8)) {\n        // copy with an overlap not larger than 8\n        wild_copy(op, ref, op + len);\n        op += len;\n      }\n      else {\n        // general copy with any overlap\n#ifdef __AVX2__\n        if (op - ref <= 16) {\n          // This is not faster on a combination of compilers (clang, gcc, icc) or machines, but\n          // it is not slower either.  Let's activate here for experimentation.\n          op = copy_match_16(op, ref, len);\n        }\n        else {\n#endif\n          op = copy_match(op, ref, (unsigned) len);\n#ifdef __AVX2__\n        }\n#endif\n      }\n    }\n    else {\n      // literal\n      ctrl++;\n      if (BLOSCLZ_UNLIKELY(op + ctrl > op_limit)) {\n        return 0;\n      }\n      if (BLOSCLZ_UNLIKELY(ip + ctrl > ip_limit)) {\n        return 0;\n      }\n\n      memcpy(op, ip, ctrl); op += ctrl; ip += ctrl;\n      // On GCC-6, fastcopy this is still faster than plain memcpy\n      // However, using recent CLANG/LLVM 9.0, there is almost no difference\n      // in performance.\n      // And starting on CLANG/LLVM 10 and GCC 9, memcpy is generally faster.\n      // op = fastcopy(op, ip, (unsigned) ctrl); ip += ctrl;\n\n      if (BLOSCLZ_UNLIKELY(ip >= ip_limit)) break;\n      ctrl = *ip++;\n    }\n  }\n\n  return (int)(op - (uint8_t*)output);\n}\n",
    "target": 0,
    "idx": 2023794
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "static int\nsc_oberthur_read_file(struct sc_pkcs15_card *p15card, const char *in_path,\n\t\tunsigned char **out, size_t *out_len,\n\t\tint verify_pin)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_card *card = p15card->card;\n\tstruct sc_file *file = NULL;\n\tstruct sc_path path;\n\tsize_t sz;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (!in_path || !out || !out_len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, \"Cannot read oberthur file\");\n\n\tsc_log(ctx, \"read file '%s'; verify_pin:%i\", in_path, verify_pin);\n\n\t*out = NULL;\n\t*out_len = 0;\n\n\tsc_format_path(in_path, &path);\n\trv = sc_select_file(card, &path, &file);\n\tif (rv != SC_SUCCESS) {\n\t\tsc_file_free(file);\n\t\tLOG_TEST_RET(ctx, rv, \"Cannot select oberthur file to read\");\n\t}\n\n\tif (file->ef_structure == SC_FILE_EF_TRANSPARENT)\n\t\tsz = file->size;\n\telse\n\t\tsz = (file->record_length + 2) * file->record_count;\n\n\t*out = calloc(sz, 1);\n\tif (*out == NULL) {\n\t\tsc_file_free(file);\n\t\tLOG_TEST_RET(ctx, SC_ERROR_OUT_OF_MEMORY, \"Cannot read oberthur file\");\n\t}\n\n\tif (file->ef_structure == SC_FILE_EF_TRANSPARENT)   {\n\t\trv = sc_read_binary(card, 0, *out, sz, 0);\n\t}\n\telse\t{\n\t\tsize_t rec;\n\t\tsize_t offs = 0;\n\t\tsize_t rec_len = file->record_length;\n\n\t\tfor (rec = 1; ; rec++)   {\n\t\t\tif (rec > file->record_count) {\n\t\t\t\trv = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trv = sc_read_record(card, rec, *out + offs + 2, rec_len, SC_RECORD_BY_REC_NR);\n\t\t\tif (rv == SC_ERROR_RECORD_NOT_FOUND)   {\n\t\t\t\trv = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (rv < 0)   {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trec_len = rv;\n\n\t\t\t*(*out + offs) = 'R';\n\t\t\t*(*out + offs + 1) = rv;\n\n\t\t\toffs += rv + 2;\n\t\t}\n\n\t\tsz = offs;\n\t}\n\n\tsc_log(ctx, \"read oberthur file result %i\", rv);\n\tif (verify_pin && rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)   {\n\t\tstruct sc_pkcs15_object *objs[0x10], *pin_obj = NULL;\n\t\tconst struct sc_acl_entry *acl = sc_file_get_acl_entry(file, SC_AC_OP_READ);\n\t\tint ii;\n\n\t\trv = sc_pkcs15_get_objects(p15card, SC_PKCS15_TYPE_AUTH_PIN, objs, 0x10);\n\t\tif (rv != SC_SUCCESS) {\n\t\t\tsc_file_free(file);\n\t\t\tLOG_TEST_RET(ctx, rv, \"Cannot read oberthur file: get AUTH objects error\");\n\t\t}\n\n\t\tfor (ii=0; ii<rv; ii++)   {\n\t\t\tstruct sc_pkcs15_auth_info *auth_info = (struct sc_pkcs15_auth_info *) objs[ii]->data;\n\t\t\tsc_log(ctx, \"compare PIN/ACL refs:%i/%i, method:%i/%i\",\n\t\t\t\t\tauth_info->attrs.pin.reference, acl->key_ref, auth_info->auth_method, acl->method);\n\t\t\tif (auth_info->attrs.pin.reference == (int)acl->key_ref && auth_info->auth_method == (unsigned)acl->method)   {\n\t\t\t\tpin_obj = objs[ii];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!pin_obj || !pin_obj->content.value)    {\n\t\t\trv = SC_ERROR_SECURITY_STATUS_NOT_SATISFIED;\n\t\t}\n\t\telse    {\n\t\t\trv = sc_pkcs15_verify_pin(p15card, pin_obj, pin_obj->content.value, pin_obj->content.len);\n\t\t\tif (!rv)\n\t\t\t\trv = sc_oberthur_read_file(p15card, in_path, out, out_len, 0);\n\t\t}\n\t};\n\n\tsc_file_free(file);\n\n\tif (rv < 0)   {\n\t\tfree(*out);\n\t\t*out = NULL;\n\t\t*out_len = 0;\n\t}\n\n\t*out_len = sz;\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n",
    "target": 0,
    "idx": 2024316
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "extern \"C\" int LLVMFuzzerTestOneInput (const uint8_t *data, size_t size)\n{\n    int option;\n    void *ctx = zmq_ctx_new ();\n    TEST_ASSERT_NOT_NULL (ctx);\n    void *server = zmq_socket (ctx, ZMQ_XPUB);\n    TEST_ASSERT_NOT_NULL (server);\n\n    if (!size)\n        return 0;\n\n    for (option = ZMQ_AFFINITY; option <= LAST_OPTION; ++option) {\n        uint8_t out[8192];\n        size_t out_size = 8192;\n\n        zmq_setsockopt (server, option, data, size);\n        zmq_getsockopt (server, option, out, &out_size);\n    }\n\n    zmq_close (server);\n    zmq_ctx_term (ctx);\n\n    return 0;\n}\nvoid test_socket_options_fuzzer ()\n{\n    uint8_t **data;\n    size_t *len, num_cases = 0;\n    if (fuzzer_corpus_encode (\n          \"tests/libzmq-fuzz-corpora/test_socket_options_fuzzer_seed_corpus\",\n          &data, &len, &num_cases)\n        != 0)\n        exit (77);\n\n    while (num_cases-- > 0) {\n        TEST_ASSERT_SUCCESS_ERRNO (\n          LLVMFuzzerTestOneInput (data[num_cases], len[num_cases]));\n        free (data[num_cases]);\n    }\n\n    free (data);\n    free (len);\n}\n",
    "target": 0,
    "idx": 2025136
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "static int\nima_reader_init (SF_PRIVATE *psf, int blockalign, int samplesperblock)\n{\tIMA_ADPCM_PRIVATE\t*pima ;\n\tint\t\tpimasize, count ;\n\n\tif (psf->file.mode != SFM_READ)\n\t\treturn SFE_BAD_MODE_RW ;\n\n\t/*\n\t**\tAllocate enough space for 1 more than a multiple of 8 samples\n\t**\tto avoid having to branch when pulling apart the nibbles.\n\t*/\n\tcount = ((samplesperblock - 2) | 7) + 2 ;\n\tpimasize = sizeof (IMA_ADPCM_PRIVATE) + psf->sf.channels * (blockalign + samplesperblock + sizeof(short) * count) ;\n\n\tif (! (pima = calloc (1, pimasize)))\n\t\treturn SFE_MALLOC_FAILED ;\n\n\tpsf->codec_data = (void*) pima ;\n\n\tpima->samples\t= pima->data ;\n\tpima->block\t\t= (unsigned char*) (pima->data + samplesperblock * psf->sf.channels) ;\n\n\tpima->channels\t\t\t= psf->sf.channels ;\n\tpima->blocksize\t\t\t= blockalign ;\n\tpima->samplesperblock\t= samplesperblock ;\n\n\tpsf->filelength = psf_get_filelen (psf) ;\n\tpsf->datalength = (psf->dataend) ? psf->dataend - psf->dataoffset :\n\t\t\t\t\t\t\tpsf->filelength - psf->dataoffset ;\n\n\tif (pima->blocksize <= 0)\n\t{\tpsf_log_printf (psf, \"*** Error : pima->blocksize should be > 0.\\n\") ;\n\t\treturn SFE_INTERNAL ;\n\t\t} ;\n\n\tif (pima->samplesperblock <= 0)\n\t{\tpsf_log_printf (psf, \"*** Error : pima->samplesperblock should be > 0.\\n\") ;\n\t\treturn SFE_INTERNAL ;\n\t\t} ;\n\n\tif (psf->datalength % pima->blocksize)\n\t\tpima->blocks = psf->datalength / pima->blocksize + 1 ;\n\telse\n\t\tpima->blocks = psf->datalength / pima->blocksize ;\n\n\tswitch (SF_CONTAINER (psf->sf.format))\n\t{\tcase SF_FORMAT_WAV :\n\t\tcase SF_FORMAT_W64 :\n\t\t\t\tcount = 2 * (pima->blocksize - 4 * pima->channels) / pima->channels + 1 ;\n\n\t\t\t\tif (pima->samplesperblock != count)\n\t\t\t\t{\tpsf_log_printf (psf, \"*** Error : samplesperblock should be %d.\\n\", count) ;\n\t\t\t\t\treturn SFE_INTERNAL ;\n\t\t\t\t\t} ;\n\n\t\t\t\tpima->decode_block = wavlike_ima_decode_block ;\n\n\t\t\t\tpsf->sf.frames = pima->samplesperblock * pima->blocks ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_AIFF :\n\t\t\t\tpsf_log_printf (psf, \"still need to check block count\\n\") ;\n\t\t\t\tpima->decode_block = aiff_ima_decode_block ;\n\t\t\t\tpsf->sf.frames = pima->samplesperblock * pima->blocks / pima->channels ;\n\t\t\t\tbreak ;\n\n\t\tdefault :\n\t\t\t\tpsf_log_printf (psf, \"ima_reader_init: bad psf->sf.format\\n\") ;\n\t\t\t\treturn SFE_INTERNAL ;\n\t\t} ;\n\n\tpima->decode_block (psf, pima) ;\t/* Read first block. */\n\n\tpsf->read_short\t\t= ima_read_s ;\n\tpsf->read_int\t\t= ima_read_i ;\n\tpsf->read_float\t\t= ima_read_f ;\n\tpsf->read_double\t= ima_read_d ;\n\n\treturn 0 ;\n} /* ima_reader_init */\n",
    "target": 0,
    "idx": 2025530
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "static int idprime_read_binary(sc_card_t *card, unsigned int offset,\n\tunsigned char *buf, size_t count, unsigned long flags)\n{\n\tstruct idprime_private_data *priv = card->drv_data;\n\tint r = 0;\n\tint size;\n\n\tsc_log(card->ctx, \"called; %\"SC_FORMAT_LEN_SIZE_T\"u bytes at offset %d\",\n\t\tcount, offset);\n\n\tif (!priv->cached && offset == 0) {\n\t\t/* Read what was reported by FCI from select command */\n\t\tint left = priv->file_size;\n\t\tsize_t read = 0;\n\n\t\t// this function is called to read and uncompress the certificate\n\t\tu8 buffer[SC_MAX_EXT_APDU_BUFFER_SIZE];\n\t\tif (sizeof(buffer) < count) {\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INTERNAL);\n\t\t}\n\t\twhile (left > 0) {\n\t\t\tr = iso_ops->read_binary(card, read, buffer + read, priv->file_size - read, flags);\n\t\t\tif (r <= 0) {\n\t\t\t\tLOG_FUNC_RETURN(card->ctx, r);\n\t\t\t}\n\t\t\tleft -= r;\n\t\t\tread += r;\n\t\t}\n\t\tif (read < 4 || read != priv->file_size) {\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_DATA);\n\t\t}\n\t\tif (buffer[0] == 1 && buffer[1] == 0) {\n#ifdef ENABLE_ZLIB\n\t\t\tsize_t expectedsize = buffer[2] + buffer[3] * 0x100;\n\t\t\tr = sc_decompress_alloc(&priv->cache_buf, &(priv->cache_buf_len),\n\t\t\t\tbuffer+4, priv->file_size-4, COMPRESSION_AUTO);\n\t\t\tif (r != SC_SUCCESS) {\n\t\t\t\tsc_log(card->ctx, \"Zlib error: %d\", r);\n\t\t\t\tLOG_FUNC_RETURN(card->ctx, r);\n\t\t\t}\n\t\t\tif (priv->cache_buf_len != expectedsize) {\n\t\t\t\tsc_log(card->ctx,\n\t\t\t\t\t \"expected size: %\"SC_FORMAT_LEN_SIZE_T\"u real size: %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t\t\t\t expectedsize, priv->cache_buf_len);\n\t\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_DATA);\n\t\t\t}\n#else\n\t\t\tsc_log(card->ctx, \"compression not supported, no zlib\");\n\t\t\treturn SC_ERROR_NOT_SUPPORTED;\n#endif /* ENABLE_ZLIB */\n\t\t} else {\n\t\t\t/* assuming uncompressed certificate */\n\t\t\tpriv->cache_buf = malloc(r);\n\t\t\tif (priv->cache_buf == NULL) {\n\t\t\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t\t\t}\n\t\t\tmemcpy(priv->cache_buf, buffer, r);\n\t\t\tpriv->cache_buf_len = r;\n\t\t}\n\t\tpriv->cached = 1;\n\t}\n\tif (offset >= priv->cache_buf_len) {\n\t\treturn 0;\n\t}\n\tsize = (int) MIN((priv->cache_buf_len - offset), count);\n\tmemcpy(buf, priv->cache_buf + offset, size);\n\treturn size;\n}\n",
    "target": 0,
    "idx": 2025998
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "static int idprime_read_binary(sc_card_t *card, unsigned int offset,\n\tunsigned char *buf, size_t count, unsigned long flags)\n{\n\tstruct idprime_private_data *priv = card->drv_data;\n\tint r = 0;\n\tint size;\n\n\tsc_log(card->ctx, \"called; %\"SC_FORMAT_LEN_SIZE_T\"u bytes at offset %d\",\n\t\tcount, offset);\n\n\tif (!priv->cached && offset == 0) {\n\t\t/* Read what was reported by FCI from select command */\n\t\tint left = priv->file_size;\n\t\tsize_t read = 0;\n\n\t\t// this function is called to read and uncompress the certificate\n\t\tu8 buffer[SC_MAX_EXT_APDU_BUFFER_SIZE];\n\t\tif (sizeof(buffer) < count || sizeof(buffer) < priv->file_size) {\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INTERNAL);\n\t\t}\n\t\twhile (left > 0) {\n\t\t\tr = iso_ops->read_binary(card, read, buffer + read, priv->file_size - read, flags);\n\t\t\tif (r <= 0) {\n\t\t\t\tLOG_FUNC_RETURN(card->ctx, r);\n\t\t\t}\n\t\t\tleft -= r;\n\t\t\tread += r;\n\t\t}\n\t\tif (read < 4 || read != priv->file_size) {\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_DATA);\n\t\t}\n\t\tif (buffer[0] == 1 && buffer[1] == 0) {\n#ifdef ENABLE_ZLIB\n\t\t\tsize_t expectedsize = buffer[2] + buffer[3] * 0x100;\n\t\t\tr = sc_decompress_alloc(&priv->cache_buf, &(priv->cache_buf_len),\n\t\t\t\tbuffer+4, priv->file_size-4, COMPRESSION_AUTO);\n\t\t\tif (r != SC_SUCCESS) {\n\t\t\t\tsc_log(card->ctx, \"Zlib error: %d\", r);\n\t\t\t\tLOG_FUNC_RETURN(card->ctx, r);\n\t\t\t}\n\t\t\tif (priv->cache_buf_len != expectedsize) {\n\t\t\t\tsc_log(card->ctx,\n\t\t\t\t\t \"expected size: %\"SC_FORMAT_LEN_SIZE_T\"u real size: %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t\t\t\t expectedsize, priv->cache_buf_len);\n\t\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_DATA);\n\t\t\t}\n#else\n\t\t\tsc_log(card->ctx, \"compression not supported, no zlib\");\n\t\t\treturn SC_ERROR_NOT_SUPPORTED;\n#endif /* ENABLE_ZLIB */\n\t\t} else {\n\t\t\t/* assuming uncompressed certificate */\n\t\t\tpriv->cache_buf = malloc(r);\n\t\t\tif (priv->cache_buf == NULL) {\n\t\t\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t\t\t}\n\t\t\tmemcpy(priv->cache_buf, buffer, r);\n\t\t\tpriv->cache_buf_len = r;\n\t\t}\n\t\tpriv->cached = 1;\n\t}\n\tif (offset >= priv->cache_buf_len) {\n\t\treturn 0;\n\t}\n\tsize = (int) MIN((priv->cache_buf_len - offset), count);\n\tmemcpy(buf, priv->cache_buf + offset, size);\n\treturn size;\n}\n",
    "target": 0,
    "idx": 2026103
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "static int blosc_c(struct thread_context* thread_context, int32_t bsize,\n                   int32_t leftoverblock, int32_t ntbytes, int32_t destsize,\n                   const uint8_t* src, const int32_t offset, uint8_t* dest,\n                   uint8_t* tmp, uint8_t* tmp2) {\n  blosc2_context* context = thread_context->parent_context;\n  int dont_split = (context->header_flags & 0x10) >> 4;\n  int dict_training = context->use_dict && context->dict_cdict == NULL;\n  int32_t j, neblock, nstreams;\n  int32_t cbytes;                   /* number of compressed bytes in split */\n  int32_t ctbytes = 0;              /* number of compressed bytes in block */\n  int64_t maxout;\n  int32_t typesize = context->typesize;\n  const char* compname;\n  int accel;\n  const uint8_t* _src;\n  uint8_t *_tmp = tmp, *_tmp2 = tmp2;\n  uint8_t *_tmp3 = thread_context->tmp4;\n  int last_filter_index = last_filter(context->filters, 'c');\n  bool memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;\n\n  if (last_filter_index >= 0 || context->prefilter != NULL) {\n    /* Apply the filter pipeline just for the prefilter */\n    if (memcpyed && context->prefilter != NULL) {\n      // We only need the prefilter output\n      _src = pipeline_c(thread_context, bsize, src, offset, dest, _tmp2, _tmp3);\n\n      if (_src == NULL) {\n        return -9;  // signals a problem with the filter pipeline\n      }\n      return bsize;\n    }\n    /* Apply regular filter pipeline */\n    _src = pipeline_c(thread_context, bsize, src, offset, _tmp, _tmp2, _tmp3);\n\n    if (_src == NULL) {\n      return -9;  // signals a problem with the filter pipeline\n    }\n  } else {\n    _src = src + offset;\n  }\n\n  assert(context->clevel > 0);\n\n  /* Calculate acceleration for different compressors */\n  accel = get_accel(context);\n\n  /* The number of compressed data streams for this block */\n  if (!dont_split && !leftoverblock && !dict_training) {\n    nstreams = (int32_t)typesize;\n  }\n  else {\n    nstreams = 1;\n  }\n  neblock = bsize / nstreams;\n  for (j = 0; j < nstreams; j++) {\n    if (!dict_training) {\n      dest += sizeof(int32_t);\n      ntbytes += sizeof(int32_t);\n      ctbytes += sizeof(int32_t);\n    }\n\n    // See if we have a run here\n    const uint8_t* ip = (uint8_t*)_src + j * neblock;\n    const uint8_t* ipbound = (uint8_t*)_src + (j + 1) * neblock;\n    if (get_run(ip, ipbound)) {\n      // A run.  Encode the repeated byte as a negative length in the length of the split.\n      int32_t value = _src[j * neblock];\n      if (ntbytes > destsize) {\n        /* Not enough space to write out compressed block size */\n        return -1;\n      }\n      _sw32(dest - 4, -value);\n      continue;\n    }\n\n    maxout = neblock;\n  #if defined(HAVE_SNAPPY)\n    if (context->compcode == BLOSC_SNAPPY) {\n      maxout = (int32_t)snappy_max_compressed_length((size_t)neblock);\n    }\n  #endif /*  HAVE_SNAPPY */\n    if (ntbytes + maxout > destsize) {\n      /* avoid buffer * overrun */\n      maxout = (int64_t)destsize - (int64_t)ntbytes;\n      if (maxout <= 0) {\n        return 0;                  /* non-compressible block */\n      }\n    }\n    if (dict_training) {\n      // We are in the build dict state, so don't compress\n      // TODO: copy only a percentage for sampling\n      memcpy(dest, _src + j * neblock, (unsigned int)neblock);\n      cbytes = (int32_t)neblock;\n    }\n    else if (context->compcode == BLOSC_BLOSCLZ) {\n      cbytes = blosclz_compress(context->clevel, _src + j * neblock,\n                                (int)neblock, dest, (int)maxout);\n    }\n  #if defined(HAVE_LZ4)\n    else if (context->compcode == BLOSC_LZ4) {\n      void *hash_table = NULL;\n    #ifdef HAVE_IPP\n      hash_table = (void*)thread_context->lz4_hash_table;\n    #endif\n      cbytes = lz4_wrap_compress((char*)_src + j * neblock, (size_t)neblock,\n                                 (char*)dest, (size_t)maxout, accel, hash_table);\n    }\n    else if (context->compcode == BLOSC_LZ4HC) {\n      cbytes = lz4hc_wrap_compress((char*)_src + j * neblock, (size_t)neblock,\n                                   (char*)dest, (size_t)maxout, context->clevel);\n    }\n  #endif /* HAVE_LZ4 */\n  #if defined(HAVE_LIZARD)\n    else if (context->compcode == BLOSC_LIZARD) {\n      cbytes = lizard_wrap_compress((char*)_src + j * neblock, (size_t)neblock,\n                                    (char*)dest, (size_t)maxout, accel);\n    }\n  #endif /* HAVE_LIZARD */\n  #if defined(HAVE_SNAPPY)\n    else if (context->compcode == BLOSC_SNAPPY) {\n      cbytes = snappy_wrap_compress((char*)_src + j * neblock, (size_t)neblock,\n                                    (char*)dest, (size_t)maxout);\n    }\n  #endif /* HAVE_SNAPPY */\n  #if defined(HAVE_ZLIB)\n    else if (context->compcode == BLOSC_ZLIB) {\n      cbytes = zlib_wrap_compress((char*)_src + j * neblock, (size_t)neblock,\n                                  (char*)dest, (size_t)maxout, context->clevel);\n    }\n  #endif /* HAVE_ZLIB */\n  #if defined(HAVE_ZSTD)\n    else if (context->compcode == BLOSC_ZSTD) {\n      cbytes = zstd_wrap_compress(thread_context,\n                                  (char*)_src + j * neblock, (size_t)neblock,\n                                  (char*)dest, (size_t)maxout, context->clevel);\n    }\n  #endif /* HAVE_ZSTD */\n\n    else {\n      blosc_compcode_to_compname(context->compcode, &compname);\n      fprintf(stderr, \"Blosc has not been compiled with '%s' \", compname);\n      fprintf(stderr, \"compression support.  Please use one having it.\");\n      return -5;    /* signals no compression support */\n    }\n\n    if (cbytes > maxout) {\n      /* Buffer overrun caused by compression (should never happen) */\n      return -1;\n    }\n    if (cbytes < 0) {\n      /* cbytes should never be negative */\n      return -2;\n    }\n    if (!dict_training) {\n      if (cbytes == 0 || cbytes == neblock) {\n        /* The compressor has been unable to compress data at all. */\n        /* Before doing the copy, check that we are not running into a\n           buffer overflow. */\n        if ((ntbytes + neblock) > destsize) {\n          return 0;    /* Non-compressible data */\n        }\n        memcpy(dest, _src + j * neblock, (unsigned int)neblock);\n        cbytes = neblock;\n      }\n      _sw32(dest - 4, cbytes);\n    }\n    dest += cbytes;\n    ntbytes += cbytes;\n    ctbytes += cbytes;\n  }  /* Closes j < nstreams */\n",
    "target": 0,
    "idx": 2026442
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "void DefRepLevelsToListInfo(const int16_t* def_levels, const int16_t* rep_levels,\n                            int64_t num_def_levels, LevelInfo level_info,\n                            ValidityBitmapInputOutput* output, OffsetType* offsets) {\n  OffsetType* orig_pos = offsets;\n  optional<::arrow::internal::FirstTimeBitmapWriter> valid_bits_writer;\n  if (output->valid_bits) {\n    valid_bits_writer.emplace(output->valid_bits, output->valid_bits_offset,\n                              output->values_read_upper_bound);\n  }\n  for (int x = 0; x < num_def_levels; x++) {\n    // Skip items that belong to empty or null ancestor lists and further nested lists.\n    if (def_levels[x] < level_info.repeated_ancestor_def_level ||\n        rep_levels[x] > level_info.rep_level) {\n      continue;\n    }\n\n    if (rep_levels[x] == level_info.rep_level) {\n      // A continuation of an existing list.\n      // offsets can be null for structs with repeated children (we don't need to know\n      // offsets until we get to the children).\n      if (offsets != nullptr) {\n        if (ARROW_PREDICT_FALSE(*offsets == std::numeric_limits<OffsetType>::max())) {\n          throw ParquetException(\"List index overflow.\");\n        }\n        *offsets += 1;\n      }\n    } else {\n      if (ARROW_PREDICT_FALSE(\n              (valid_bits_writer.has_value() &&\n               valid_bits_writer->position() >= output->values_read_upper_bound) ||\n              (offsets - orig_pos) >= output->values_read_upper_bound)) {\n        std::stringstream ss;\n        ss << \"Definition levels exceeded upper bound: \"\n           << output->values_read_upper_bound;\n        throw ParquetException(ss.str());\n      }\n\n      // current_rep < list rep_level i.e. start of a list (ancestor empty lists are\n      // filtered out above).\n      // offsets can be null for structs with repeated children (we don't need to know\n      // offsets until we get to the children).\n      if (offsets != nullptr) {\n        ++offsets;\n        // Use cumulative offsets because variable size lists are more common then\n        // fixed size lists so it should be cheaper to make these cumulative and\n        // subtract when validating fixed size lists.\n        *offsets = *(offsets - 1);\n        if (def_levels[x] >= level_info.def_level) {\n          if (ARROW_PREDICT_FALSE(*offsets == std::numeric_limits<OffsetType>::max())) {\n            throw ParquetException(\"List index overflow.\");\n          }\n          *offsets += 1;\n        }\n      }\n\n      if (valid_bits_writer.has_value()) {\n        // the level_info def level for lists reflects element present level.\n        // the prior level distinguishes between empty lists.\n        if (def_levels[x] >= level_info.def_level - 1) {\n          valid_bits_writer->Set();\n        } else {\n          output->null_count++;\n          valid_bits_writer->Clear();\n        }\n        valid_bits_writer->Next();\n      }\n    }\n  }\n  if (valid_bits_writer.has_value()) {\n    valid_bits_writer->Finish();\n  }\n  if (offsets != nullptr) {\n    output->values_read = offsets - orig_pos;\n  } else if (valid_bits_writer.has_value()) {\n    output->values_read = valid_bits_writer->position();\n  }\n  if (output->null_count > 0 && level_info.null_slot_usage > 1) {\n    throw ParquetException(\n        \"Null values with null_slot_usage > 1 not supported.\"\n        \"(i.e. FixedSizeLists with null values are not supported)\");\n  }\n}\n",
    "target": 0,
    "idx": 2026829
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "int flb_gzip_compress(void *in_data, size_t in_len,\n                      void **out_data, size_t *out_len)\n{\n    int flush;\n    int status;\n    int footer_start;\n    uint8_t *pb;\n    size_t out_size;\n    void *out_buf;\n    z_stream strm;\n    mz_ulong crc;\n\n    /*\n     * Calculating the upper bound for a gzip compression is\n     * non-trivial, so we rely on miniz's own calculation\n     * to guarantee memory safety.\n     */\n    out_size = compressBound(in_len);\n    out_buf = flb_malloc(out_size);\n\n    if (!out_buf) {\n        flb_errno();\n        flb_error(\"[gzip] could not allocate outgoing buffer\");\n        return -1;\n    }\n\n    /* Initialize streaming buffer context */\n    memset(&strm, '\\0', sizeof(strm));\n    strm.zalloc    = Z_NULL;\n    strm.zfree     = Z_NULL;\n    strm.opaque    = Z_NULL;\n    strm.next_in   = in_data;\n    strm.avail_in  = in_len;\n    strm.total_out = 0;\n\n    /* Deflate mode */\n    deflateInit2(&strm, Z_DEFAULT_COMPRESSION,\n                 Z_DEFLATED, -Z_DEFAULT_WINDOW_BITS, 9, Z_DEFAULT_STRATEGY);\n\n    /*\n     * Miniz don't support GZip format directly, instead we will:\n     *\n     * - append manual GZip magic bytes\n     * - deflate raw content\n     * - append manual CRC32 data\n     */\n    gzip_header(out_buf);\n\n    /* Header offset */\n    pb = (uint8_t *) out_buf + FLB_GZIP_HEADER_OFFSET;\n\n    flush = Z_NO_FLUSH;\n    while (1) {\n        strm.next_out  = pb + strm.total_out;\n        strm.avail_out = out_size - (pb - (uint8_t *) out_buf);\n\n        if (strm.avail_in == 0) {\n            flush = Z_FINISH;\n        }\n\n        status = deflate(&strm, flush);\n        if (status == Z_STREAM_END) {\n            break;\n        }\n        else if (status != Z_OK) {\n            deflateEnd(&strm);\n            return -1;\n        }\n    }\n\n    if (deflateEnd(&strm) != Z_OK) {\n        flb_free(out_buf);\n        return -1;\n    }\n    *out_len = strm.total_out;\n\n    /* Construct the gzip checksum (CRC32 footer) */\n    footer_start = FLB_GZIP_HEADER_OFFSET + *out_len;\n    pb = (uint8_t *) out_buf + footer_start;\n\n    crc = mz_crc32(MZ_CRC32_INIT, in_data, in_len);\n    *pb++ = crc & 0xFF;\n    *pb++ = (crc >> 8) & 0xFF;\n    *pb++ = (crc >> 16) & 0xFF;\n    *pb++ = (crc >> 24) & 0xFF;\n    *pb++ = in_len & 0xFF;\n    *pb++ = (in_len >> 8) & 0xFF;\n    *pb++ = (in_len >> 16) & 0xFF;\n    *pb++ = (in_len >> 24) & 0xFF;\n\n    /* Set the real buffer size for the caller */\n    *out_len += FLB_GZIP_HEADER_OFFSET + 8;\n    *out_data = out_buf;\n\n    return 0;\n}\n",
    "target": 0,
    "idx": 2027368
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "flb_sds_t flb_signv4_uri_normalize_path(char *uri, size_t len)\n{\n    char *p;\n    int end_slash = FLB_FALSE;\n    struct mk_list *tmp;\n    struct mk_list *prev;\n    struct mk_list *head;\n    struct mk_list *split;\n    struct flb_split_entry *entry;\n    flb_sds_t out;\n\n    out = flb_sds_create_len(uri, len+1);\n    if (!out) {\n        return NULL;\n    }\n    out[len] = '\\0';\n\n    if (uri[len - 1] == '/') {\n        end_slash = FLB_TRUE;\n    }\n\n    split = flb_utils_split(out, '/', -1);\n    if (!split) {\n        flb_sds_destroy(out);\n        return NULL;\n    }\n\n    p = out;\n    *p++ = '/';\n\n    mk_list_foreach_safe(head, tmp, split) {\n        entry = mk_list_entry(head, struct flb_split_entry, _head);\n        if (entry->len == 1 && *entry->value == '.') {\n            flb_utils_split_free_entry(entry);\n        }\n        else if (entry->len == 2 && memcmp(entry->value, \"..\", 2) == 0) {\n            prev = head->prev;\n            if (prev != split) {\n                entry = mk_list_entry(prev, struct flb_split_entry, _head);\n                flb_utils_split_free_entry(entry);\n            }\n            entry = mk_list_entry(head, struct flb_split_entry, _head);\n            flb_utils_split_free_entry(entry);\n        }\n    }\n\n    mk_list_foreach(head, split) {\n        entry = mk_list_entry(head, struct flb_split_entry, _head);\n        memcpy(p, entry->value, entry->len);\n        p += entry->len;\n\n        if (head->next != split) {\n            *p++ = '/';\n        }\n    }\n\n    len = (p - out);\n    if (end_slash == FLB_TRUE && out[len - 1] != '/') {\n        *p++ = '/';\n    }\n\n    flb_utils_split_free(split);\n\n    flb_sds_len_set(out, p - out);\n    out[p - out] = '\\0';\n\n    return out;\n}\n",
    "target": 0,
    "idx": 2027710
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "void\nPl_AES_PDF::flush(bool strip_padding)\n{\n    assert(this->offset == this->buf_size);\n\n    if (first)\n    {\n\tfirst = false;\n        bool return_after_init = false;\n\tif (this->cbc_mode)\n\t{\n\t    if (encrypt)\n\t    {\n\t\t// Set cbc_block to the initialization vector, and if\n\t\t// not zero, write it to the output stream.\n\t\tinitializeVector();\n                if (! (this->use_zero_iv || this->use_specified_iv))\n                {\n                    getNext()->write(this->cbc_block, this->buf_size);\n                }\n\t    }\n\t    else if (this->use_zero_iv || this->use_specified_iv)\n            {\n                // Initialize vector with zeroes; zero vector was not\n                // written to the beginning of the input file.\n                initializeVector();\n            }\n            else\n\t    {\n\t\t// Take the first block of input as the initialization\n\t\t// vector.  There's nothing to write at this time.\n\t\tmemcpy(this->cbc_block, this->inbuf, this->buf_size);\n\t\tthis->offset = 0;\n                return_after_init = true;\n\t    }\n\t}\n        this->crypto->rijndael_init(\n            encrypt, this->key.get(), key_bytes,\n            this->cbc_mode, this->cbc_block);\n        if (return_after_init)\n        {\n            return;\n        }\n    }\n\n    if (this->encrypt)\n    {\n\tthis->crypto->rijndael_process(this->inbuf, this->outbuf);\n    }\n    else\n    {\n\tthis->crypto->rijndael_process(this->inbuf, this->outbuf);\n    }\n    unsigned int bytes = this->buf_size;\n    if (strip_padding)\n    {\n\tunsigned char last = this->outbuf[this->buf_size - 1];\n\tif (last <= this->buf_size)\n\t{\n\t    bool strip = true;\n\t    for (unsigned int i = 1; i <= last; ++i)\n\t    {\n\t\tif (this->outbuf[this->buf_size - i] != last)\n\t\t{\n\t\t    strip = false;\n\t\t    break;\n\t\t}\n\t    }\n\t    if (strip)\n\t    {\n\t\tbytes -= last;\n\t    }\n\t}\n    }\n    this->offset = 0;\n    getNext()->write(this->outbuf, bytes);\n}\nvoid\nPl_ASCII85Decoder::flush()\n{\n    if (this->pos == 0)\n    {\n\tQTC::TC(\"libtests\", \"Pl_ASCII85Decoder no-op flush\");\n\treturn;\n    }\n    unsigned long lval = 0;\n    for (int i = 0; i < 5; ++i)\n    {\n\tlval *= 85;\n\tlval += (this->inbuf[i] - 33U);\n    }\n\n    unsigned char outbuf[4];\n    memset(outbuf, 0, 4);\n    for (int i = 3; i >= 0; --i)\n    {\n\toutbuf[i] = lval & 0xff;\n\tlval >>= 8;\n    }\n\n    QTC::TC(\"libtests\", \"Pl_ASCII85Decoder partial flush\",\n\t    (this->pos == 5) ? 0 : 1);\n    // Reset before calling getNext()->write in case that throws an\n    // exception.\n    auto t = this->pos - 1;\n    this->pos = 0;\n    memset(this->inbuf, 117, 5);\n\n    getNext()->write(outbuf, t);\n}\nvoid\nPl_ASCII85Decoder::finish()\n{\n    flush();\n    getNext()->finish();\n}\nvoid\nPl_ASCIIHexDecoder::flush()\n{\n    if (this->pos == 0)\n    {\n\tQTC::TC(\"libtests\", \"Pl_ASCIIHexDecoder no-op flush\");\n\treturn;\n    }\n    int b[2];\n    for (int i = 0; i < 2; ++i)\n    {\n\tif (this->inbuf[i] >= 'A')\n\t{\n\t    b[i] = this->inbuf[i] - 'A' + 10;\n\t}\n\telse\n\t{\n\t    b[i] = this->inbuf[i] - '0';\n\t}\n    }\n    unsigned char ch = static_cast<unsigned char>((b[0] << 4) + b[1]);\n\n    QTC::TC(\"libtests\", \"Pl_ASCIIHexDecoder partial flush\",\n\t    (this->pos == 2) ? 0 : 1);\n    // Reset before calling getNext()->write in case that throws an\n    // exception.\n    this->pos = 0;\n    this->inbuf[0] = '0';\n    this->inbuf[1] = '0';\n    this->inbuf[2] = '\\0';\n\n    getNext()->write(&ch, 1);\n}\nvoid\nPl_Count::write(unsigned char* buf, size_t len)\n{\n    if (len)\n    {\n\tthis->m->count += QIntC::to_offset(len);\n\tthis->m->last_char = buf[len - 1];\n\tgetNext()->write(buf, len);\n    }\n}\n",
    "target": 0,
    "idx": 2028262
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "int mdb_read_row(MdbTableDef *table, unsigned int row)\n{\n\tMdbHandle *mdb = table->entry->mdb;\n\tMdbColumn *col;\n\tunsigned int i;\n\tint row_start;\n\tsize_t row_size;\n\tint delflag, lookupflag;\n\tMdbField *fields;\n\tint num_fields;\n\n\tif (table->num_rows == 0 || table->num_cols == 0)\n\t\treturn 0;\n\n\tif (mdb_find_row(mdb, row, &row_start, &row_size)) {\n\t\tfprintf(stderr, \"warning: mdb_find_row failed.\\n\");\n\t\treturn 0;\n\t}\n    if (row_size == 0) {\n\t\tfprintf(stderr, \"warning: row_size = 0.\\n\");\n\t\treturn 0;\n    }\n\n\tdelflag = lookupflag = 0;\n\tif (row_start & 0x8000) lookupflag++;\n\tif (row_start & 0x4000) delflag++;\n\trow_start &= OFFSET_MASK; /* remove flags */\n#if MDB_DEBUG\n\tfprintf(stdout,\"Row %d bytes %d to %d %s %s\\n\", \n\t\trow, row_start, row_start + row_size - 1,\n\t\tlookupflag ? \"[lookup]\" : \"\",\n\t\tdelflag ? \"[delflag]\" : \"\");\n#endif\t\n\n\tif (!table->noskip_del && delflag) {\n\t\treturn 0;\n\t}\n\n\tfields = malloc(sizeof(MdbField) * table->num_cols);\n\n\tnum_fields = mdb_crack_row(table, row_start, row_size, fields);\n\tif (num_fields < 0 || !mdb_test_sargs(table, fields, num_fields)) {\n\t\tfree(fields);\n\t\treturn 0;\n\t}\n\t\n#if MDB_DEBUG\n\tfprintf(stdout,\"sarg test passed row %d \\n\", row);\n#endif \n\n#if MDB_DEBUG\n\tmdb_buffer_dump(mdb->pg_buf, row_start, row_size);\n#endif\n\n\t/* take advantage of mdb_crack_row() to clean up binding */\n\t/* use num_cols instead of num_fields -- bsb 03/04/02 */\n\tfor (i = 0; i < table->num_cols; i++) {\n\t\tcol = g_ptr_array_index(table->columns,fields[i].colnum);\n\t\t_mdb_attempt_bind(mdb, col, fields[i].is_null,\n\t\t\tfields[i].start, fields[i].siz);\n\t}\n\n\tfree(fields);\n\n\treturn 1;\n}\nstatic int _mdb_attempt_bind(MdbHandle *mdb, \n\tMdbColumn *col, \n\tunsigned char isnull, \n\tint offset, \n\tint len)\n{\n\tif (col->col_type == MDB_BOOL) {\n\t\tmdb_xfer_bound_bool(mdb, col, isnull);\n\t} else if (isnull) {\n\t\tmdb_xfer_bound_data(mdb, 0, col, 0);\n\t} else if (col->col_type == MDB_OLE) {\n\t\tmdb_xfer_bound_ole(mdb, offset, col, len);\n\t} else {\n\t\t//if (!mdb_test_sargs(mdb, col, offset, len)) {\n\t\t\t//return 0;\n\t\t//}\n\t\tmdb_xfer_bound_data(mdb, offset, col, len);\n\t}\n\treturn 1;\n}\n",
    "target": 0,
    "idx": 2028780
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "static std::unique_ptr<GrFragmentProcessor> create_profile_effect(GrRecordingContext* rContext,\n                                                                  const SkRect& circle,\n                                                                  float sigma,\n                                                                  float* solidRadius,\n                                                                  float* textureRadius) {\n    float circleR = circle.width() / 2.0f;\n    if (!sk_float_isfinite(circleR) || circleR < SK_ScalarNearlyZero) {\n        return nullptr;\n    }\n\n    auto threadSafeCache = rContext->priv().threadSafeCache();\n\n    // Profile textures are cached by the ratio of sigma to circle radius and by the size of the\n    // profile texture (binned by powers of 2).\n    SkScalar sigmaToCircleRRatio = sigma / circleR;\n    // When sigma is really small this becomes a equivalent to convolving a Gaussian with a\n    // half-plane. Similarly, in the extreme high ratio cases circle becomes a point WRT to the\n    // Guassian and the profile texture is a just a Gaussian evaluation. However, we haven't yet\n    // implemented this latter optimization.\n    sigmaToCircleRRatio = std::min(sigmaToCircleRRatio, 8.f);\n    SkFixed sigmaToCircleRRatioFixed;\n    static const SkScalar kHalfPlaneThreshold = 0.1f;\n    bool useHalfPlaneApprox = false;\n    if (sigmaToCircleRRatio <= kHalfPlaneThreshold) {\n        useHalfPlaneApprox = true;\n        sigmaToCircleRRatioFixed = 0;\n        *solidRadius = circleR - 3 * sigma;\n        *textureRadius = 6 * sigma;\n    } else {\n        // Convert to fixed point for the key.\n        sigmaToCircleRRatioFixed = SkScalarToFixed(sigmaToCircleRRatio);\n        // We shave off some bits to reduce the number of unique entries. We could probably\n        // shave off more than we do.\n        sigmaToCircleRRatioFixed &= ~0xff;\n        sigmaToCircleRRatio = SkFixedToScalar(sigmaToCircleRRatioFixed);\n        sigma = circleR * sigmaToCircleRRatio;\n        *solidRadius = 0;\n        *textureRadius = circleR + 3 * sigma;\n    }\n\n    static constexpr int kProfileTextureWidth = 512;\n    // This would be kProfileTextureWidth/textureRadius if it weren't for the fact that we do\n    // the calculation of the profile coord in a coord space that has already been scaled by\n    // 1 / textureRadius. This is done to avoid overflow in length().\n    SkMatrix texM = SkMatrix::Scale(kProfileTextureWidth, 1.f);\n\n    static const GrUniqueKey::Domain kDomain = GrUniqueKey::GenerateDomain();\n    GrUniqueKey key;\n    GrUniqueKey::Builder builder(&key, kDomain, 1, \"1-D Circular Blur\");\n    builder[0] = sigmaToCircleRRatioFixed;\n    builder.finish();\n\n    GrSurfaceProxyView profileView = threadSafeCache->find(key);\n    if (profileView) {\n        SkASSERT(profileView.asTextureProxy());\n        SkASSERT(profileView.origin() == kTopLeft_GrSurfaceOrigin);\n        return GrTextureEffect::Make(std::move(profileView), kPremul_SkAlphaType, texM);\n    }\n\n    SkBitmap bm;\n    if (!bm.tryAllocPixels(SkImageInfo::MakeA8(kProfileTextureWidth, 1))) {\n        return nullptr;\n    }\n\n    if (useHalfPlaneApprox) {\n        create_half_plane_profile(bm.getAddr8(0, 0), kProfileTextureWidth);\n    } else {\n        // Rescale params to the size of the texture we're creating.\n        SkScalar scale = kProfileTextureWidth / *textureRadius;\n        create_circle_profile(bm.getAddr8(0, 0), sigma * scale, circleR * scale,\n                              kProfileTextureWidth);\n    }\n\n    bm.setImmutable();\n\n    GrBitmapTextureMaker maker(rContext, bm, GrImageTexGenPolicy::kNew_Uncached_Budgeted);\n    profileView = maker.view(GrMipmapped::kNo);\n    if (!profileView) {\n        return nullptr;\n    }\n\n    profileView = threadSafeCache->add(key, profileView);\n    return GrTextureEffect::Make(std::move(profileView), kPremul_SkAlphaType, texM);\n}\n",
    "target": 0,
    "idx": 2029183
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "static int\nMat_H5ReadDatasetInfo(mat_t *mat,matvar_t *matvar,hid_t dset_id)\n{\n    int err;\n    hsize_t nelems;\n\n    err = Mat_H5ReadVarInfo(matvar, dset_id);\n    if ( err ) {\n        return err;\n    }\n\n    matvar->dims = Mat_H5ReadDims(dset_id, &nelems, &matvar->rank);\n    if ( NULL == matvar->dims ) {\n        return MATIO_E_UNKNOWN_ERROR;\n    }\n\n    /* Check for attribute that indicates an empty array */\n    if ( H5Aexists_by_name(dset_id,\".\",\"MATLAB_empty\",H5P_DEFAULT) ) {\n        int empty = 0;\n        herr_t herr;\n        hid_t attr_id = H5Aopen_by_name(dset_id,\".\",\"MATLAB_empty\",H5P_DEFAULT,H5P_DEFAULT);\n        /* FIXME: Check that dataspace is scalar */\n        herr = H5Aread(attr_id,H5T_NATIVE_INT,&empty);\n        H5Aclose(attr_id);\n        if ( herr < 0 ) {\n            err = MATIO_E_GENERIC_READ_ERROR;\n        } else if ( empty ) {\n            matvar->rank = (int)matvar->dims[0];\n            free(matvar->dims);\n            matvar->dims = (size_t*)calloc(matvar->rank,sizeof(*matvar->dims));\n            if ( matvar->dims == NULL ) {\n                err = MATIO_E_OUT_OF_MEMORY;\n            } else {\n                herr = H5Dread(dset_id,SizeType2H5T(),H5S_ALL,H5S_ALL,H5P_DEFAULT,matvar->dims);\n                if ( herr < 0 ) {\n                    err = MATIO_E_GENERIC_READ_ERROR;\n                } else {\n                    size_t tmp = 1;\n                    err = Mat_MulDims(matvar, &tmp);\n                    nelems = (hsize_t)tmp;\n                }\n            }\n        }\n        if ( err ) {\n            return err;\n        }\n    }\n\n    /* Test if dataset type is compound and if so if it's complex */\n    {\n        hid_t type_id = H5Dget_type(dset_id);\n        if ( H5T_COMPOUND == H5Tget_class(type_id) ) {\n            /* FIXME: Any more checks? */\n            matvar->isComplex = MAT_F_COMPLEX;\n        }\n        H5Tclose(type_id);\n    }\n\n    /* If the dataset is a cell array read the info of the cells */\n    if ( MAT_C_CELL == matvar->class_type ) {\n        matvar_t **cells;\n\n        matvar->data_size = sizeof(matvar_t**);\n        err = Mul(&matvar->nbytes, nelems, matvar->data_size);\n        if ( err ) {\n            Mat_Critical(\"Integer multiplication overflow\");\n            return err;\n        }\n        matvar->data = calloc(matvar->nbytes, 1);\n        if ( NULL == matvar->data ) {\n            Mat_Critical(\"Couldn't allocate memory for the data\");\n            return MATIO_E_OUT_OF_MEMORY;\n        }\n        cells = (matvar_t**)matvar->data;\n\n        if ( nelems ) {\n            hobj_ref_t *ref_ids = (hobj_ref_t*)calloc(nelems, sizeof(*ref_ids));\n            if ( ref_ids != NULL ) {\n                size_t i;\n                herr_t herr = H5Dread(dset_id,H5T_STD_REF_OBJ,H5S_ALL,H5S_ALL,H5P_DEFAULT,ref_ids);\n                if ( herr < 0 ) {\n                    free(ref_ids);\n                    return MATIO_E_GENERIC_READ_ERROR;\n                }\n                for ( i = 0; i < nelems; i++ ) {\n                    hid_t ref_id;\n                    cells[i] = Mat_VarCalloc();\n                    cells[i]->internal->hdf5_ref = ref_ids[i];\n                    /* Closing of ref_id is done in Mat_H5ReadNextReferenceInfo */\n                    ref_id = H5RDEREFERENCE(dset_id,H5R_OBJECT,ref_ids+i);\n                    if ( ref_id < 0 ) {\n                        err = MATIO_E_GENERIC_READ_ERROR;\n                    } else {\n                        cells[i]->internal->id = ref_id;\n                        err = Mat_H5ReadNextReferenceInfo(ref_id,cells[i],mat);\n                    }\n                    if ( err ) {\n                        break;\n                    }\n                }\n                free(ref_ids);\n            } else {\n                err = MATIO_E_OUT_OF_MEMORY;\n            }\n        }\n    } else if ( MAT_C_STRUCT == matvar->class_type ) {\n        /* Empty structures can be a dataset */\n\n        /* Check if the structure defines its fields in MATLAB_fields */\n        if ( H5Aexists_by_name(dset_id,\".\",\"MATLAB_fields\",H5P_DEFAULT) ) {\n            hsize_t nfields;\n            err = Mat_H5ReadFieldNames(matvar, dset_id, &nfields);\n        }\n    }\n\n    return err;\n}\nstatic int\nMat_H5ReadGroupInfo(mat_t *mat,matvar_t *matvar,hid_t dset_id)\n{\n    int      fields_are_variables = 1;\n    hsize_t  nfields=0,nelems;\n    hid_t    attr_id,field_id;\n    matvar_t **fields;\n    H5O_type_t obj_type;\n    int err;\n\n    err = Mat_H5ReadVarInfo(matvar,dset_id);\n    if ( err < 0 ) {\n        return err;\n    }\n\n    /* Check if the variable is sparse */\n    if ( H5Aexists_by_name(dset_id,\".\",\"MATLAB_sparse\",H5P_DEFAULT) ) {\n        herr_t herr;\n        hid_t sparse_dset_id;\n        unsigned nrows = 0;\n\n        attr_id = H5Aopen_by_name(dset_id,\".\",\"MATLAB_sparse\",H5P_DEFAULT,H5P_DEFAULT);\n        herr = H5Aread(attr_id,H5T_NATIVE_UINT,&nrows);\n        H5Aclose(attr_id);\n        if ( herr < 0 ) {\n            return MATIO_E_GENERIC_READ_ERROR;\n        }\n\n        matvar->class_type = MAT_C_SPARSE;\n\n        sparse_dset_id = H5Dopen(dset_id,\"jc\",H5P_DEFAULT);\n        matvar->dims = Mat_H5ReadDims(sparse_dset_id, &nelems, &matvar->rank);\n        H5Dclose(sparse_dset_id);\n        if ( NULL != matvar->dims ) {\n            if ( 1 == matvar->rank ) {\n                size_t* dims = (size_t*)realloc(matvar->dims, 2*sizeof(*matvar->dims));\n                if ( NULL != dims ) {\n                    matvar->rank = 2;\n                    matvar->dims = dims;\n                }\n            }\n            if ( 2 == matvar->rank ) {\n                matvar->dims[1] = matvar->dims[0] - 1;\n                matvar->dims[0] = nrows;\n            }\n        } else {\n            return MATIO_E_UNKNOWN_ERROR;\n        }\n\n        /* Test if dataset type is compound and if so if it's complex */\n        if ( H5Lexists(dset_id,\"data\",H5P_DEFAULT) ) {\n            hid_t type_id;\n            sparse_dset_id = H5Dopen(dset_id,\"data\",H5P_DEFAULT);\n            type_id = H5Dget_type(sparse_dset_id);\n            if ( H5T_COMPOUND == H5Tget_class(type_id) ) {\n                /* FIXME: Any more checks? */\n                matvar->isComplex = MAT_F_COMPLEX;\n            }\n            H5Tclose(type_id);\n            H5Dclose(sparse_dset_id);\n        }\n        return MATIO_E_NO_ERROR;\n    }\n\n    /* Check if the structure defines its fields in MATLAB_fields */\n    if ( H5Aexists_by_name(dset_id,\".\",\"MATLAB_fields\",H5P_DEFAULT) ) {\n        err = Mat_H5ReadFieldNames(matvar, dset_id, &nfields);\n        if ( err ) {\n            return err;\n        }\n    } else {\n        H5G_info_t group_info;\n        matvar->internal->num_fields = 0;\n        group_info.nlinks = 0;\n        H5Gget_info(dset_id, &group_info);\n        if ( group_info.nlinks > 0 ) {\n            struct ReadGroupInfoIterData group_data = {0, NULL};\n            herr_t herr;\n\n            /* First iteration to retrieve number of relevant links */\n            herr = H5Literate_by_name(dset_id, matvar->internal->hdf5_name, H5_INDEX_NAME,\n                H5_ITER_NATIVE, NULL, Mat_H5ReadGroupInfoIterate,\n                (void *)&group_data, H5P_DEFAULT);\n            if ( herr > 0 && group_data.nfields > 0 ) {\n                matvar->internal->fieldnames =\n                    (char**)calloc((size_t)(group_data.nfields),sizeof(*matvar->internal->fieldnames));\n                group_data.nfields = 0;\n                group_data.matvar = matvar;\n                if ( matvar->internal->fieldnames != NULL ) {\n                    /* Second iteration to fill fieldnames */\n                    H5Literate_by_name(dset_id, matvar->internal->hdf5_name, H5_INDEX_NAME,\n                        H5_ITER_NATIVE, NULL, Mat_H5ReadGroupInfoIterate,\n                        (void *)&group_data, H5P_DEFAULT);\n                }\n                matvar->internal->num_fields = (unsigned)group_data.nfields;\n                nfields = group_data.nfields;\n            }\n        }\n    }\n\n    if ( nfields > 0 ) {\n        H5O_INFO_T object_info;\n        object_info.type = H5O_TYPE_UNKNOWN;\n        H5OGET_INFO_BY_NAME(dset_id, matvar->internal->fieldnames[0], &object_info, H5P_DEFAULT);\n        obj_type = object_info.type;\n    } else {\n        obj_type = H5O_TYPE_UNKNOWN;\n    }\n    if ( obj_type == H5O_TYPE_DATASET ) {\n        hid_t field_type_id;\n        field_id = H5Dopen(dset_id,matvar->internal->fieldnames[0],H5P_DEFAULT);\n        field_type_id = H5Dget_type(field_id);\n        if ( H5T_REFERENCE == H5Tget_class(field_type_id) ) {\n            /* Check if the field has the MATLAB_class attribute. If so, it\n             * means the structure is a scalar. Otherwise, the dimensions of\n             * the field dataset is the dimensions of the structure\n             */\n            if ( H5Aexists_by_name(field_id,\".\",\"MATLAB_class\",H5P_DEFAULT) ) {\n                matvar->rank = 2;\n                matvar->dims = (size_t*)malloc(2*sizeof(*matvar->dims));\n                if ( NULL != matvar->dims ) {\n                    matvar->dims[0] = 1;\n                    matvar->dims[1] = 1;\n                    nelems = 1;\n                } else {\n                    H5Tclose(field_type_id);\n                    H5Dclose(field_id);\n                    Mat_Critical(\"Error allocating memory for matvar->dims\");\n                    return MATIO_E_OUT_OF_MEMORY;\n                }\n            } else {\n                matvar->dims = Mat_H5ReadDims(field_id, &nelems, &matvar->rank);\n                if ( NULL != matvar->dims ) {\n                    fields_are_variables = 0;\n                } else {\n                    H5Tclose(field_type_id);\n                    H5Dclose(field_id);\n                    return MATIO_E_UNKNOWN_ERROR;\n                }\n            }\n        } else {\n            /* Structure should be a scalar */\n            matvar->rank = 2;\n            matvar->dims = (size_t*)malloc(2*sizeof(*matvar->dims));\n            if ( NULL != matvar->dims ) {\n                matvar->dims[0] = 1;\n                matvar->dims[1] = 1;\n                nelems = 1;\n            } else {\n                H5Tclose(field_type_id);\n                H5Dclose(field_id);\n                Mat_Critical(\"Error allocating memory for matvar->dims\");\n                return MATIO_E_UNKNOWN_ERROR;\n            }\n        }\n        H5Tclose(field_type_id);\n        H5Dclose(field_id);\n    } else {\n        /* Structure should be a scalar */\n        matvar->rank = 2;\n        matvar->dims = (size_t*)malloc(2*sizeof(*matvar->dims));\n        if ( NULL != matvar->dims ) {\n            matvar->dims[0] = 1;\n            matvar->dims[1] = 1;\n            nelems = 1;\n        } else {\n            Mat_Critical(\"Error allocating memory for matvar->dims\");\n            return MATIO_E_OUT_OF_MEMORY;\n        }\n    }\n\n    if ( nelems < 1 || nfields < 1 )\n        return err;\n\n    matvar->data_size = sizeof(*fields);\n    {\n        size_t nelems_x_nfields;\n        err = Mul(&nelems_x_nfields, nelems, nfields);\n        err |= Mul(&matvar->nbytes, nelems_x_nfields, matvar->data_size);\n        if ( err ) {\n            Mat_Critical(\"Integer multiplication overflow\");\n            matvar->nbytes = 0;\n            return err;\n        }\n    }\n    fields = (matvar_t**)calloc(matvar->nbytes, 1);\n    matvar->data = fields;\n    if ( NULL != fields ) {\n        hsize_t k;\n        for ( k = 0; k < nfields; k++ ) {\n            H5O_INFO_T object_info;\n            fields[k] = NULL;\n            object_info.type = H5O_TYPE_UNKNOWN;\n            H5OGET_INFO_BY_NAME(dset_id, matvar->internal->fieldnames[k], &object_info, H5P_DEFAULT);\n            if ( object_info.type == H5O_TYPE_DATASET ) {\n                field_id = H5Dopen(dset_id,matvar->internal->fieldnames[k], H5P_DEFAULT);\n                if ( !fields_are_variables ) {\n                    hobj_ref_t *ref_ids = (hobj_ref_t*)calloc((size_t)nelems, sizeof(*ref_ids));\n                    if ( ref_ids != NULL ) {\n                        hsize_t l;\n                        herr_t herr = H5Dread(field_id,H5T_STD_REF_OBJ,H5S_ALL,H5S_ALL,\n                            H5P_DEFAULT,ref_ids);\n                        if ( herr < 0 ) {\n                            err = MATIO_E_GENERIC_READ_ERROR;\n                        } else {\n                            for ( l = 0; l < nelems; l++ ) {\n                                hid_t ref_id;\n                                fields[l*nfields+k] = Mat_VarCalloc();\n                                fields[l*nfields+k]->name =\n                                    strdup(matvar->internal->fieldnames[k]);\n                                fields[l*nfields+k]->internal->hdf5_ref=ref_ids[l];\n                                /* Closing of ref_id is done in Mat_H5ReadNextReferenceInfo */\n                                ref_id = H5RDEREFERENCE(field_id,H5R_OBJECT,ref_ids+l);\n                                if ( ref_id < 0 ) {\n                                    err = MATIO_E_GENERIC_READ_ERROR;\n                                } else {\n                                    fields[l*nfields+k]->internal->id = ref_id;\n                                    err = Mat_H5ReadNextReferenceInfo(ref_id,fields[l*nfields+k],mat);\n                                }\n                                if ( err ) {\n                                    break;\n                                }\n                            }\n                        }\n                        free(ref_ids);\n                    } else {\n                        err = MATIO_E_OUT_OF_MEMORY;\n                    }\n                } else {\n                    fields[k] = Mat_VarCalloc();\n                    fields[k]->name = strdup(matvar->internal->fieldnames[k]);\n                    err = Mat_H5ReadDatasetInfo(mat,fields[k],field_id);\n                }\n                H5Dclose(field_id);\n            } else if ( object_info.type == H5O_TYPE_GROUP ) {\n                field_id = H5Gopen(dset_id,matvar->internal->fieldnames[k],\n                                   H5P_DEFAULT);\n                if ( -1 < field_id ) {\n                    fields[k] = Mat_VarCalloc();\n                    fields[k]->name = strdup(matvar->internal->fieldnames[k]);\n                    err = Mat_H5ReadGroupInfo(mat,fields[k],field_id);\n                    H5Gclose(field_id);\n                }\n            }\n            if ( err ) {\n                break;\n            }\n        }\n    } else {\n        err = MATIO_E_OUT_OF_MEMORY;\n    }\n\n    return err;\n}\n",
    "target": 0,
    "idx": 2029545
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "static int __handle_option(const struct fio_option *o, const char *ptr,\n\t\t\t   void *data, int first, int more, int curr)\n{\n\tint il=0, *ilp;\n\tfio_fp64_t *flp;\n\tlong long ull, *ullp;\n\tlong ul2;\n\tlong long ull1, ull2;\n\tdouble uf;\n\tchar **cp = NULL;\n\tint ret = 0, is_time = 0;\n\tconst struct value_pair *vp;\n\tstruct value_pair posval[PARSE_MAX_VP];\n\tint i, all_skipped = 1;\n\n\tdprint(FD_PARSE, \"__handle_option=%s, type=%s, ptr=%s\\n\", o->name,\n\t\t\t\t\t\t\topt_type_name(o), ptr);\n\n\tif (!ptr && o->type != FIO_OPT_STR_SET && o->type != FIO_OPT_STR) {\n\t\tlog_err(\"Option %s requires an argument\\n\", o->name);\n\t\treturn 1;\n\t}\n\n\tswitch (o->type) {\n\tcase FIO_OPT_STR:\n\tcase FIO_OPT_STR_ULL:\n\tcase FIO_OPT_STR_MULTI: {\n\t\tfio_opt_str_fn *fn = o->cb;\n\n\t\tposval_sort(o, posval);\n\n\t\tret = 1;\n\t\tfor (i = 0; i < PARSE_MAX_VP; i++) {\n\t\t\tvp = &posval[i];\n\t\t\tif (!vp->ival || vp->ival[0] == '\\0')\n\t\t\t\tcontinue;\n\t\t\tall_skipped = 0;\n\t\t\tif (!ptr)\n\t\t\t\tbreak;\n\t\t\tif (!strncmp(vp->ival, ptr, str_match_len(vp, ptr))) {\n\t\t\t\tret = 0;\n\t\t\t\tif (!o->off1)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (o->type == FIO_OPT_STR_ULL)\n\t\t\t\t\tval_store(ullp, vp->oval, o->off1, vp->orval, data, o);\n\t\t\t\telse\n\t\t\t\t\tval_store(ilp, vp->oval, o->off1, vp->orval, data, o);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (ret && !all_skipped)\n\t\t\tshow_option_values(o);\n\t\telse if (fn)\n\t\t\tret = fn(data, ptr);\n\t\tbreak;\n\t}\n\tcase FIO_OPT_STR_VAL_TIME:\n\t\tis_time = 1;\n\t\tfallthrough;\n\tcase FIO_OPT_ULL:\n\tcase FIO_OPT_INT:\n\tcase FIO_OPT_STR_VAL: {\n\t\tfio_opt_str_val_fn *fn = o->cb;\n\t\tchar tmp[128], *p;\n\n\t\tif (!is_time && o->is_time)\n\t\t\tis_time = o->is_time;\n\n\t\tsnprintf(tmp, sizeof(tmp), \"%s\", ptr);\n\t\tp = strchr(tmp, ',');\n\t\tif (p)\n\t\t\t*p = '\\0';\n\n\t\tif (is_time)\n\t\t\tret = check_str_time(tmp, &ull, o->is_seconds);\n\t\telse\n\t\t\tret = check_str_bytes(tmp, &ull, data);\n\n\t\tdprint(FD_PARSE, \"  ret=%d, out=%llu\\n\", ret, ull);\n\n\t\tif (ret)\n\t\t\tbreak;\n\t\tif (o->pow2 && !is_power_of_2(ull)) {\n\t\t\tlog_err(\"%s: must be a power-of-2\\n\", o->name);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (val_too_large(o, ull, o->type == FIO_OPT_INT)) {\n\t\t\tlog_err(\"%s: max value out of range: %llu\"\n\t\t\t\t\" (%llu max)\\n\", o->name, ull, o->maxval);\n\t\t\treturn 1;\n\t\t}\n\t\tif (val_too_small(o, ull, o->type == FIO_OPT_INT)) {\n\t\t\tlog_err(\"%s: min value out of range: %lld\"\n\t\t\t\t\" (%d min)\\n\", o->name, ull, o->minval);\n\t\t\treturn 1;\n\t\t}\n\t\tif (o->posval[0].ival) {\n\t\t\tposval_sort(o, posval);\n\n\t\t\tret = 1;\n\t\t\tfor (i = 0; i < PARSE_MAX_VP; i++) {\n\t\t\t\tvp = &posval[i];\n\t\t\t\tif (!vp->ival || vp->ival[0] == '\\0')\n\t\t\t\t\tcontinue;\n\t\t\t\tif (vp->oval == ull) {\n\t\t\t\t\tret = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ret) {\n\t\t\t\tlog_err(\"fio: value %llu not allowed:\\n\", ull);\n\t\t\t\tshow_option_values(o);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\tif (fn)\n\t\t\tret = fn(data, &ull);\n\t\telse {\n\t\t\tif (o->type == FIO_OPT_INT) {\n\t\t\t\tif (first)\n\t\t\t\t\tval_store(ilp, ull, o->off1, 0, data, o);\n\t\t\t\tif (curr == 1) {\n\t\t\t\t\tif (o->off2)\n\t\t\t\t\t\tval_store(ilp, ull, o->off2, 0, data, o);\n\t\t\t\t}\n\t\t\t\tif (curr == 2) {\n\t\t\t\t\tif (o->off3)\n\t\t\t\t\t\tval_store(ilp, ull, o->off3, 0, data, o);\n\t\t\t\t}\n\t\t\t\tif (!more) {\n\t\t\t\t\tif (curr < 1) {\n\t\t\t\t\t\tif (o->off2)\n\t\t\t\t\t\t\tval_store(ilp, ull, o->off2, 0, data, o);\n\t\t\t\t\t}\n\t\t\t\t\tif (curr < 2) {\n\t\t\t\t\t\tif (o->off3)\n\t\t\t\t\t\t\tval_store(ilp, ull, o->off3, 0, data, o);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (o->type == FIO_OPT_ULL) {\n\t\t\t\tif (first)\n\t\t\t\t\tval_store(ullp, ull, o->off1, 0, data, o);\n\t\t\t\tif (curr == 1) {\n\t\t\t\t\tif (o->off2)\n\t\t\t\t\t\tval_store(ullp, ull, o->off2, 0, data, o);\n\t\t\t\t}\n\t\t\t\tif (curr == 2) {\n\t\t\t\t\tif (o->off3)\n\t\t\t\t\t\tval_store(ullp, ull, o->off3, 0, data, o);\n\t\t\t\t}\n\t\t\t\tif (!more) {\n\t\t\t\t\tif (curr < 1) {\n\t\t\t\t\t\tif (o->off2)\n\t\t\t\t\t\t\tval_store(ullp, ull, o->off2, 0, data, o);\n\t\t\t\t\t}\n\t\t\t\t\tif (curr < 2) {\n\t\t\t\t\t\tif (o->off3)\n\t\t\t\t\t\t\tval_store(ullp, ull, o->off3, 0, data, o);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (first)\n\t\t\t\t\tval_store(ullp, ull, o->off1, 0, data, o);\n\t\t\t\tif (!more) {\n\t\t\t\t\tif (o->off2)\n\t\t\t\t\t\tval_store(ullp, ull, o->off2, 0, data, o);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase FIO_OPT_FLOAT_LIST: {\n\t\tchar *cp2;\n\n\t\tif (first) {\n\t\t\t/*\n\t\t\t** Initialize precision to 0 and zero out list\n\t\t\t** in case specified list is shorter than default\n\t\t\t*/\n\t\t\tif (o->off2) {\n\t\t\t\tul2 = 0;\n\t\t\t\tilp = td_var(data, o, o->off2);\n\t\t\t\t*ilp = ul2;\n\t\t\t}\n\n\t\t\tflp = td_var(data, o, o->off1);\n\t\t\tfor(i = 0; i < o->maxlen; i++)\n\t\t\t\tflp[i].u.f = 0.0;\n\t\t}\n\t\tif (curr >= o->maxlen) {\n\t\t\tlog_err(\"the list exceeding max length %d\\n\",\n\t\t\t\t\to->maxlen);\n\t\t\treturn 1;\n\t\t}\n\t\tif (!str_to_float(ptr, &uf, 0)) { /* this breaks if we ever have lists of times */\n\t\t\tlog_err(\"not a floating point value: %s\\n\", ptr);\n\t\t\treturn 1;\n\t\t}\n\t\tif (o->minfp || o->maxfp) {\n\t\t\tif (uf > o->maxfp) {\n\t\t\t\tlog_err(\"value out of range: %f\"\n\t\t\t\t\t\" (range max: %f)\\n\", uf, o->maxfp);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (uf < o->minfp) {\n\t\t\t\tlog_err(\"value out of range: %f\"\n\t\t\t\t\t\" (range min: %f)\\n\", uf, o->minfp);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\tflp = td_var(data, o, o->off1);\n\t\tflp[curr].u.f = uf;\n\n\t\tdprint(FD_PARSE, \"  out=%f\\n\", uf);\n\n\t\t/*\n\t\t** Calculate precision for output by counting\n\t\t** number of digits after period. Find first\n\t\t** period in entire remaining list each time\n\t\t*/\n\t\tcp2 = strchr(ptr, '.');\n\t\tif (cp2 != NULL) {\n\t\t\tint len = 0;\n\n\t\t\twhile (*++cp2 != '\\0' && *cp2 >= '0' && *cp2 <= '9')\n\t\t\t\tlen++;\n\n\t\t\tif (o->off2) {\n\t\t\t\tilp = td_var(data, o, o->off2);\n\t\t\t\tif (len > *ilp)\n\t\t\t\t\t*ilp = len;\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\t}\n\tcase FIO_OPT_STR_STORE: {\n\t\tfio_opt_str_fn *fn = o->cb;\n\n\t\tif (!strlen(ptr))\n\t\t\treturn 1;\n\n\t\tif (o->off1) {\n\t\t\tcp = td_var(data, o, o->off1);\n\t\t\t*cp = strdup(ptr);\n\t\t\tif (strlen(ptr) > o->maxlen - 1) {\n\t\t\t\tlog_err(\"value exceeds max length of %d\\n\",\n\t\t\t\t\to->maxlen);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\tif (fn)\n\t\t\tret = fn(data, ptr);\n\t\telse if (o->posval[0].ival) {\n\t\t\tposval_sort(o, posval);\n\n\t\t\tret = 1;\n\t\t\tfor (i = 0; i < PARSE_MAX_VP; i++) {\n\t\t\t\tvp = &posval[i];\n\t\t\t\tif (!vp->ival || vp->ival[0] == '\\0' || !cp)\n\t\t\t\t\tcontinue;\n\t\t\t\tall_skipped = 0;\n\t\t\t\tif (!strncmp(vp->ival, ptr, str_match_len(vp, ptr))) {\n\t\t\t\t\tchar *rest;\n\n\t\t\t\t\tret = 0;\n\t\t\t\t\tif (vp->cb)\n\t\t\t\t\t\tfn = vp->cb;\n\t\t\t\t\trest = strstr(*cp ?: ptr, \":\");\n\t\t\t\t\tif (rest) {\n\t\t\t\t\t\tif (*cp)\n\t\t\t\t\t\t\t*rest = '\\0';\n\t\t\t\t\t\tptr = rest + 1;\n\t\t\t\t\t} else\n\t\t\t\t\t\tptr = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!all_skipped) {\n\t\t\tif (ret && !*cp)\n\t\t\t\tshow_option_values(o);\n\t\t\telse if (ret && *cp)\n\t\t\t\tret = 0;\n\t\t\telse if (fn && ptr)\n\t\t\t\tret = fn(data, ptr);\n\t\t}\n\n\t\tbreak;\n\t}\n\tcase FIO_OPT_RANGE: {\n\t\tchar tmp[128];\n\t\tchar *p1, *p2;\n\n\t\tsnprintf(tmp, sizeof(tmp), \"%s\", ptr);\n\n\t\t/* Handle bsrange with separate read,write values: */\n\t\tp1 = strchr(tmp, ',');\n\t\tif (p1)\n\t\t\t*p1 = '\\0';\n\n\t\tp1 = strchr(tmp, '-');\n\t\tif (!p1) {\n\t\t\tp1 = strchr(tmp, ':');\n\t\t\tif (!p1) {\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tp2 = p1 + 1;\n\t\t*p1 = '\\0';\n\t\tp1 = tmp;\n\n\t\tret = 1;\n\t\tif (!check_range_bytes(p1, &ull1, data) &&\n\t\t\t!check_range_bytes(p2, &ull2, data)) {\n\t\t\tret = 0;\n\t\t\tif (ull1 > ull2) {\n\t\t\t\tunsigned long long foo = ull1;\n\n\t\t\t\tull1 = ull2;\n\t\t\t\tull2 = foo;\n\t\t\t}\n\n\t\t\tif (first) {\n\t\t\t\tval_store(ullp, ull1, o->off1, 0, data, o);\n\t\t\t\tval_store(ullp, ull2, o->off2, 0, data, o);\n\t\t\t}\n\t\t\tif (curr == 1) {\n\t\t\t\tif (o->off3 && o->off4) {\n\t\t\t\t\tval_store(ullp, ull1, o->off3, 0, data, o);\n\t\t\t\t\tval_store(ullp, ull2, o->off4, 0, data, o);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (curr == 2) {\n\t\t\t\tif (o->off5 && o->off6) {\n\t\t\t\t\tval_store(ullp, ull1, o->off5, 0, data, o);\n\t\t\t\t\tval_store(ullp, ull2, o->off6, 0, data, o);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!more) {\n\t\t\t\tif (curr < 1) {\n\t\t\t\t\tif (o->off3 && o->off4) {\n\t\t\t\t\t\tval_store(ullp, ull1, o->off3, 0, data, o);\n\t\t\t\t\t\tval_store(ullp, ull2, o->off4, 0, data, o);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (curr < 2) {\n\t\t\t\t\tif (o->off5 && o->off6) {\n\t\t\t\t\t\tval_store(ullp, ull1, o->off5, 0, data, o);\n\t\t\t\t\t\tval_store(ullp, ull2, o->off6, 0, data, o);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\t}\n\tcase FIO_OPT_BOOL:\n\tcase FIO_OPT_STR_SET: {\n\t\tfio_opt_int_fn *fn = o->cb;\n\n\t\tif (ptr)\n\t\t\tret = check_int(ptr, &il);\n\t\telse if (o->type == FIO_OPT_BOOL)\n\t\t\tret = 1;\n\t\telse\n\t\t\til = 1;\n\n\t\tdprint(FD_PARSE, \"  ret=%d, out=%d\\n\", ret, il);\n\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (o->maxval && il > (int) o->maxval) {\n\t\t\tlog_err(\"max value out of range: %d (%llu max)\\n\",\n\t\t\t\t\t\t\t\til, o->maxval);\n\t\t\treturn 1;\n\t\t}\n\t\tif (o->minval && il < o->minval) {\n\t\t\tlog_err(\"min value out of range: %d (%d min)\\n\",\n\t\t\t\t\t\t\t\til, o->minval);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (o->neg)\n\t\t\til = !il;\n\n\t\tif (fn)\n\t\t\tret = fn(data, &il);\n\t\telse {\n\t\t\tif (first)\n\t\t\t\tval_store(ilp, il, o->off1, 0, data, o);\n\t\t\tif (!more) {\n\t\t\t\tif (o->off2)\n\t\t\t\t\tval_store(ilp, il, o->off2, 0, data, o);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase FIO_OPT_DEPRECATED:\n\t\tret = 1;\n\t\tfallthrough;\n\tcase FIO_OPT_SOFT_DEPRECATED:\n\t\tlog_info(\"Option %s is deprecated\\n\", o->name);\n\t\tbreak;\n\tdefault:\n\t\tlog_err(\"Bad option type %u\\n\", o->type);\n\t\tret = 1;\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (o->verify) {\n\t\tret = o->verify(o, data);\n\t\tif (ret) {\n\t\t\tlog_err(\"Correct format for offending option\\n\");\n\t\t\tlog_err(\"%20s: %s\\n\", o->name, o->help);\n\t\t\tshow_option_help(o, 1);\n\t\t}\n\t}\n\n\treturn ret;\n}\n",
    "target": 0,
    "idx": 2029633
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "static int\nMat_H5ReadGroupInfo(mat_t *mat,matvar_t *matvar,hid_t dset_id)\n{\n    int      fields_are_variables = 1;\n    hsize_t  nfields=0,nelems;\n    hid_t    attr_id,field_id;\n    matvar_t **fields;\n    H5O_type_t obj_type;\n    int err;\n\n    err = Mat_H5ReadVarInfo(matvar,dset_id);\n    if ( err < 0 ) {\n        return err;\n    }\n\n    /* Check if the variable is sparse */\n    if ( H5Aexists_by_name(dset_id,\".\",\"MATLAB_sparse\",H5P_DEFAULT) ) {\n        herr_t herr;\n        hid_t sparse_dset_id;\n        unsigned nrows = 0;\n\n        attr_id = H5Aopen_by_name(dset_id,\".\",\"MATLAB_sparse\",H5P_DEFAULT,H5P_DEFAULT);\n        herr = H5Aread(attr_id,H5T_NATIVE_UINT,&nrows);\n        H5Aclose(attr_id);\n        if ( herr < 0 ) {\n            return MATIO_E_GENERIC_READ_ERROR;\n        }\n\n        matvar->class_type = MAT_C_SPARSE;\n\n        sparse_dset_id = H5Dopen(dset_id,\"jc\",H5P_DEFAULT);\n        matvar->dims = Mat_H5ReadDims(sparse_dset_id, &nelems, &matvar->rank);\n        H5Dclose(sparse_dset_id);\n        if ( NULL != matvar->dims ) {\n            if ( 1 == matvar->rank ) {\n                size_t* dims = (size_t*)realloc(matvar->dims, 2*sizeof(*matvar->dims));\n                if ( NULL != dims ) {\n                    matvar->rank = 2;\n                    matvar->dims = dims;\n                }\n            }\n            if ( 2 == matvar->rank ) {\n                matvar->dims[1] = matvar->dims[0] - 1;\n                matvar->dims[0] = nrows;\n            }\n        } else {\n            return MATIO_E_UNKNOWN_ERROR;\n        }\n\n        /* Test if dataset type is compound and if so if it's complex */\n        if ( H5Lexists(dset_id,\"data\",H5P_DEFAULT) ) {\n            hid_t type_id;\n            sparse_dset_id = H5Dopen(dset_id,\"data\",H5P_DEFAULT);\n            type_id = H5Dget_type(sparse_dset_id);\n            if ( H5T_COMPOUND == H5Tget_class(type_id) ) {\n                /* FIXME: Any more checks? */\n                matvar->isComplex = MAT_F_COMPLEX;\n            }\n            H5Tclose(type_id);\n            H5Dclose(sparse_dset_id);\n        }\n        return MATIO_E_NO_ERROR;\n    }\n\n    if (MAT_C_STRUCT != matvar->class_type ) {\n        return MATIO_E_GENERIC_READ_ERROR;\n    }\n\n    /* Check if the structure defines its fields in MATLAB_fields */\n    if ( H5Aexists_by_name(dset_id,\".\",\"MATLAB_fields\",H5P_DEFAULT) ) {\n        err = Mat_H5ReadFieldNames(matvar, dset_id, &nfields);\n        if ( err ) {\n            return err;\n        }\n    } else {\n        H5G_info_t group_info;\n        matvar->internal->num_fields = 0;\n        group_info.nlinks = 0;\n        H5Gget_info(dset_id, &group_info);\n        if ( group_info.nlinks > 0 ) {\n            struct ReadGroupInfoIterData group_data = {0, NULL};\n            herr_t herr;\n\n            /* First iteration to retrieve number of relevant links */\n            herr = H5Literate_by_name(dset_id, matvar->internal->hdf5_name, H5_INDEX_NAME,\n                H5_ITER_NATIVE, NULL, Mat_H5ReadGroupInfoIterate,\n                (void *)&group_data, H5P_DEFAULT);\n            if ( herr > 0 && group_data.nfields > 0 ) {\n                matvar->internal->fieldnames =\n                    (char**)calloc((size_t)(group_data.nfields),sizeof(*matvar->internal->fieldnames));\n                group_data.nfields = 0;\n                group_data.matvar = matvar;\n                if ( matvar->internal->fieldnames != NULL ) {\n                    /* Second iteration to fill fieldnames */\n                    H5Literate_by_name(dset_id, matvar->internal->hdf5_name, H5_INDEX_NAME,\n                        H5_ITER_NATIVE, NULL, Mat_H5ReadGroupInfoIterate,\n                        (void *)&group_data, H5P_DEFAULT);\n                }\n                matvar->internal->num_fields = (unsigned)group_data.nfields;\n                nfields = group_data.nfields;\n            }\n        }\n    }\n\n    if ( nfields > 0 ) {\n        H5O_INFO_T object_info;\n        object_info.type = H5O_TYPE_UNKNOWN;\n        H5OGET_INFO_BY_NAME(dset_id, matvar->internal->fieldnames[0], &object_info, H5P_DEFAULT);\n        obj_type = object_info.type;\n    } else {\n        obj_type = H5O_TYPE_UNKNOWN;\n    }\n    if ( obj_type == H5O_TYPE_DATASET ) {\n        hid_t field_type_id;\n        field_id = H5Dopen(dset_id,matvar->internal->fieldnames[0],H5P_DEFAULT);\n        field_type_id = H5Dget_type(field_id);\n        if ( H5T_REFERENCE == H5Tget_class(field_type_id) ) {\n            /* Check if the field has the MATLAB_class attribute. If so, it\n             * means the structure is a scalar. Otherwise, the dimensions of\n             * the field dataset is the dimensions of the structure\n             */\n            if ( H5Aexists_by_name(field_id,\".\",\"MATLAB_class\",H5P_DEFAULT) ) {\n                matvar->rank = 2;\n                matvar->dims = (size_t*)malloc(2*sizeof(*matvar->dims));\n                if ( NULL != matvar->dims ) {\n                    matvar->dims[0] = 1;\n                    matvar->dims[1] = 1;\n                    nelems = 1;\n                } else {\n                    H5Tclose(field_type_id);\n                    H5Dclose(field_id);\n                    Mat_Critical(\"Error allocating memory for matvar->dims\");\n                    return MATIO_E_OUT_OF_MEMORY;\n                }\n            } else {\n                matvar->dims = Mat_H5ReadDims(field_id, &nelems, &matvar->rank);\n                if ( NULL != matvar->dims ) {\n                    fields_are_variables = 0;\n                } else {\n                    H5Tclose(field_type_id);\n                    H5Dclose(field_id);\n                    return MATIO_E_UNKNOWN_ERROR;\n                }\n            }\n        } else {\n            /* Structure should be a scalar */\n            matvar->rank = 2;\n            matvar->dims = (size_t*)malloc(2*sizeof(*matvar->dims));\n            if ( NULL != matvar->dims ) {\n                matvar->dims[0] = 1;\n                matvar->dims[1] = 1;\n                nelems = 1;\n            } else {\n                H5Tclose(field_type_id);\n                H5Dclose(field_id);\n                Mat_Critical(\"Error allocating memory for matvar->dims\");\n                return MATIO_E_UNKNOWN_ERROR;\n            }\n        }\n        H5Tclose(field_type_id);\n        H5Dclose(field_id);\n    } else {\n        /* Structure should be a scalar */\n        matvar->rank = 2;\n        matvar->dims = (size_t*)malloc(2*sizeof(*matvar->dims));\n        if ( NULL != matvar->dims ) {\n            matvar->dims[0] = 1;\n            matvar->dims[1] = 1;\n            nelems = 1;\n        } else {\n            Mat_Critical(\"Error allocating memory for matvar->dims\");\n            return MATIO_E_OUT_OF_MEMORY;\n        }\n    }\n\n    if ( nelems < 1 || nfields < 1 )\n        return err;\n\n    matvar->data_size = sizeof(*fields);\n    {\n        size_t nelems_x_nfields;\n        err = Mul(&nelems_x_nfields, nelems, nfields);\n        err |= Mul(&matvar->nbytes, nelems_x_nfields, matvar->data_size);\n        if ( err ) {\n            Mat_Critical(\"Integer multiplication overflow\");\n            matvar->nbytes = 0;\n            return err;\n        }\n    }\n    fields = (matvar_t**)calloc(matvar->nbytes, 1);\n    matvar->data = fields;\n    if ( NULL != fields ) {\n        hsize_t k;\n        for ( k = 0; k < nfields; k++ ) {\n            H5O_INFO_T object_info;\n            fields[k] = NULL;\n            object_info.type = H5O_TYPE_UNKNOWN;\n            H5OGET_INFO_BY_NAME(dset_id, matvar->internal->fieldnames[k], &object_info, H5P_DEFAULT);\n            if ( object_info.type == H5O_TYPE_DATASET ) {\n                field_id = H5Dopen(dset_id,matvar->internal->fieldnames[k], H5P_DEFAULT);\n                if ( !fields_are_variables ) {\n                    hobj_ref_t *ref_ids = (hobj_ref_t*)calloc((size_t)nelems, sizeof(*ref_ids));\n                    if ( ref_ids != NULL ) {\n                        hsize_t l;\n                        herr_t herr = H5Dread(field_id,H5T_STD_REF_OBJ,H5S_ALL,H5S_ALL,\n                            H5P_DEFAULT,ref_ids);\n                        if ( herr < 0 ) {\n                            err = MATIO_E_GENERIC_READ_ERROR;\n                        } else {\n                            for ( l = 0; l < nelems; l++ ) {\n                                hid_t ref_id;\n                                fields[l*nfields+k] = Mat_VarCalloc();\n                                fields[l*nfields+k]->name =\n                                    strdup(matvar->internal->fieldnames[k]);\n                                fields[l*nfields+k]->internal->hdf5_ref=ref_ids[l];\n                                /* Closing of ref_id is done in Mat_H5ReadNextReferenceInfo */\n                                ref_id = H5RDEREFERENCE(field_id,H5R_OBJECT,ref_ids+l);\n                                if ( ref_id < 0 ) {\n                                    err = MATIO_E_GENERIC_READ_ERROR;\n                                } else {\n                                    fields[l*nfields+k]->internal->id = ref_id;\n                                    err = Mat_H5ReadNextReferenceInfo(ref_id,fields[l*nfields+k],mat);\n                                }\n                                if ( err ) {\n                                    break;\n                                }\n                            }\n                        }\n                        free(ref_ids);\n                    } else {\n                        err = MATIO_E_OUT_OF_MEMORY;\n                    }\n                } else {\n                    fields[k] = Mat_VarCalloc();\n                    fields[k]->name = strdup(matvar->internal->fieldnames[k]);\n                    err = Mat_H5ReadDatasetInfo(mat,fields[k],field_id);\n                }\n                H5Dclose(field_id);\n            } else if ( object_info.type == H5O_TYPE_GROUP ) {\n                field_id = H5Gopen(dset_id,matvar->internal->fieldnames[k],\n                                   H5P_DEFAULT);\n                if ( -1 < field_id ) {\n                    fields[k] = Mat_VarCalloc();\n                    fields[k]->name = strdup(matvar->internal->fieldnames[k]);\n                    err = Mat_H5ReadGroupInfo(mat,fields[k],field_id);\n                    H5Gclose(field_id);\n                }\n            }\n            if ( err ) {\n                break;\n            }\n        }\n    } else {\n        err = MATIO_E_OUT_OF_MEMORY;\n    }\n\n    return err;\n}\n",
    "target": 0,
    "idx": 2030081
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "static void bn_mul_karat_imp(bn_t c, const bn_t a, const bn_t b, int level) {\n\tbn_t a0, a1, b0, b1, a0b0, a1b1, t;\n\n\t/* Compute half the digits of a or b. */\n\tint h = RLC_MIN(a->used, b->used) >> 1;\n\n\tbn_null(a0);\n\tbn_null(a1);\n\tbn_null(b0);\n\tbn_null(b1);\n\tbn_null(a0b0);\n\tbn_null(a1b1);\n\tbn_null(t);\n\n\tRLC_TRY {\n\t\t/* Allocate the temp variables. */\n\t\tbn_new_size(a0, h);\n\t\tbn_new_size(a1, h);\n\t\tbn_new_size(b0, a->used - h);\n\t\tbn_new_size(b1, b->used - h);\n\t\tbn_new(a0b0);\n\t\tbn_new(a1b1);\n\t\tbn_new(t);\n\n\t\t/* a = a1 || a0, b = b1 || b0 */\n\t\ta0->used = b0->used = h;\n\t\ta1->used = a->used - h;\n\t\tb1->used = b->used - h;\n\t\tdv_copy(a0->dp, a->dp, h);\n\t\tdv_copy(a1->dp, a->dp + h, a->used - h);\n\t\tdv_copy(b0->dp, b->dp, h);\n\t\tdv_copy(b1->dp, b->dp + h, b->used - h);\n\t\tbn_trim(a0);\n\t\tbn_trim(b0);\n\t\tbn_trim(a1);\n\t\tbn_trim(b1);\n\n\t\t/* a0b0 = a0 * b0 and a1b1 = a1 * b1 */\n\t\tif (level <= 1) {\n#if BN_MUL == BASIC\n\t\t\tbn_mul_basic(a0b0, a0, b0);\n\t\t\tbn_mul_basic(a1b1, a1, b1);\n#elif BN_MUL == COMBA\n\t\t\tbn_mul_comba(a0b0, a0, b0);\n\t\t\tbn_mul_comba(a1b1, a1, b1);\n#endif\n\t\t} else {\n\t\t\tbn_mul_karat_imp(a0b0, a0, b0, level - 1);\n\t\t\tbn_mul_karat_imp(a1b1, a1, b1, level - 1);\n\t\t}\n\n\t\t/* t = (a1 + a0) */\n\t\tbn_add(a1, a1, a0);\n\t\t/* t2 = (b1 + b0) */\n\t\tbn_add(b1, b1, b0);\n\n\t\t/* t = (a1 + a0)*(b1 + b0) */\n\t\tif (level <= 1) {\n#if BN_MUL == BASIC\n\t\t\tbn_mul_basic(t, a1, b1);\n#elif BN_MUL == COMBA\n\t\t\tbn_mul_comba(t, a1, b1);\n#endif\n\t\t} else {\n\t\t\tbn_mul_karat_imp(t, a1, b1, level - 1);\n\t\t}\n\t\t/* t2 = (a0*b0 + a1*b1) */\n\t\tbn_sub(t, t, a0b0);\n\n\t\t/* t = (a1 + a0)*(b1 + b0) - (a0*b0 + a1*b1) */\n\t\tbn_sub(t, t, a1b1);\n\n\t\t/* t = (a1 + a0)*(b1 + b0) - (a0*b0 + a1*b1) << h digits */\n\t\tbn_lsh(t, t, h * RLC_DIG);\n\n\t\t/* t2 = a1 * b1 << 2*h digits */\n\t\tbn_lsh(a1b1, a1b1, 2 * h * RLC_DIG);\n\n\t\t/* t = t + a0*b0 */\n\t\tbn_add(t, t, a0b0);\n\n\t\t/* c = t + a1*b1 */\n\t\tbn_add(t, t, a1b1);\n\n\t\tt->sign = a->sign ^ b->sign;\n\t\tbn_copy(c, t);\n\t\tbn_trim(c);\n\t}\nstatic void bn_sqr_karat_imp(bn_t c, const bn_t a, int level) {\n\tbn_t a0, a1, a0a0, a1a1, t;\n\tint h = a->used >> 1;\n\n\tbn_null(a0);\n\tbn_null(a1);\n\tbn_null(a0a0);\n\tbn_null(a1a1);\n\tbn_null(t);\n\n\tRLC_TRY {\n\t\t/* Allocate the temp variables. */\n\t\tbn_new_size(a0, h);\n\t\tbn_new_size(a1, a->used - h);\n\t\tbn_new(a0a0);\n\t\tbn_new(a1a1);\n\t\tbn_new(t);\n\n\t\t/* a = a1 || a0 */\n\t\ta0->used = h;\n\t\ta1->used = a->used - h;\n\t\tdv_copy(a0->dp, a->dp, h);\n\t\tdv_copy(a1->dp, a->dp + h, a->used - h);\n\t\tbn_trim(a0);\n\t\tbn_trim(a1);\n\n\t\tif (level <= 1) {\n\t\t\t/* a0a0 = a0 * a0 and a1a1 = a1 * a1 */\n#if BN_SQR == BASIC\n\t\t\tbn_sqr_basic(a0a0, a0);\n\t\t\tbn_sqr_basic(a1a1, a1);\n#elif BN_SQR == COMBA\n\t\t\tbn_sqr_comba(a0a0, a0);\n\t\t\tbn_sqr_comba(a1a1, a1);\n#elif BN_SQR == MULTP\n\t\t\tbn_mul_comba(a0a0, a0, a0);\n\t\t\tbn_mul_comba(a1a1, a1, a1);\n#endif\n\t\t} else {\n\t\t\tbn_sqr_karat_imp(a0a0, a0, level - 1);\n\t\t\tbn_sqr_karat_imp(a1a1, a1, level - 1);\n\t\t}\n\n\t\t/* t = (a1 + a0) */\n\t\tbn_add(t, a1, a0);\n\n\t\tif (level <= 1) {\n\t\t\t/* t = (a1 + a0)*(a1 + a0) */\n#if BN_SQR == BASIC\n\t\t\tbn_sqr_basic(t, t);\n#elif BN_SQR == COMBA\n\t\t\tbn_sqr_comba(t, t);\n#elif BN_SQR == MULTP\n\t\t\tbn_mul_comba(t, t, t);\n#endif\n\t\t} else {\n\t\t\tbn_sqr_karat_imp(t, t, level - 1);\n\t\t}\n\n\t\t/* t2 = (a0*a0 + a1*a1) */\n\t\tbn_add(a0, a0a0, a1a1);\n\t\t/* t = (a1 + a0)*(b1 + b0) - (a0*a0 + a1*a1) */\n\t\tbn_sub(t, t, a0);\n\n\t\t/* t = (a1 + a0)*(a1 + a0) - (a0*a0 + a1*a1) << h digits */\n\t\tbn_lsh(t, t, h * RLC_DIG);\n\n\t\t/* t2 = a1 * b1 << 2*h digits */\n\t\tbn_lsh(a1a1, a1a1, 2 * h * RLC_DIG);\n\n\t\t/* t = t + a0*a0 */\n\t\tbn_add(t, t, a0a0);\n\t\t/* c = t + a1*a1 */\n\t\tbn_add(t, t, a1a1);\n\n\t\tt->sign = RLC_POS;\n\t\tbn_copy(c, t);\n\t}\n\n",
    "target": 0,
    "idx": 2030537
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "  void ForceVectorAlignment(size_t len, size_t elemsize, size_t alignment) {\n    FLATBUFFERS_ASSERT(VerifyAlignmentRequirements(alignment));\n    PreAlign(len * elemsize, alignment);\n  }\n  void ForceStringAlignment(size_t len, size_t alignment) {\n    FLATBUFFERS_ASSERT(VerifyAlignmentRequirements(alignment));\n    PreAlign((len + 1) * sizeof(char), alignment);\n  }\nCheckedError Parser::ParseVector(const Type &type, uoffset_t *ovalue,\n                                 FieldDef *field, size_t fieldn) {\n  uoffset_t count = 0;\n  auto err = ParseVectorDelimiters(count, [&](uoffset_t &) -> CheckedError {\n    Value val;\n    val.type = type;\n    ECHECK(ParseAnyValue(val, field, fieldn, nullptr, count, true));\n    field_stack_.push_back(std::make_pair(val, nullptr));\n    return NoError();\n  });\n  ECHECK(err);\n\n  const size_t len = count * InlineSize(type) / InlineAlignment(type);\n  const size_t elemsize = InlineAlignment(type);\n  const auto force_align = field->attributes.Lookup(\"force_align\");\n  if (force_align) {\n    size_t align;\n    ECHECK(ParseAlignAttribute(force_align->constant, 1, &align));\n    if (align > 1) { builder_.ForceVectorAlignment(len, elemsize, align); }\n  }\n\n  builder_.StartVector(len, elemsize);\n  for (uoffset_t i = 0; i < count; i++) {\n    // start at the back, since we're building the data backwards.\n    auto &val = field_stack_.back().first;\n    switch (val.type.base_type) {\n      // clang-format off\n      #define FLATBUFFERS_TD(ENUM, IDLTYPE, CTYPE,...) \\\n        case BASE_TYPE_ ## ENUM: \\\n          if (IsStruct(val.type)) SerializeStruct(*val.type.struct_def, val); \\\n          else { \\\n             CTYPE elem; \\\n             ECHECK(atot(val.constant.c_str(), *this, &elem)); \\\n             builder_.PushElement(elem); \\\n          } \\\n          break;\n        FLATBUFFERS_GEN_TYPES(FLATBUFFERS_TD)\n      #undef FLATBUFFERS_TD\n      // clang-format on\n    }\n    field_stack_.pop_back();\n  }\n\n  builder_.ClearOffsets();\n  *ovalue = builder_.EndVector(count);\n\n  if (type.base_type == BASE_TYPE_STRUCT && type.struct_def->has_key) {\n    // We should sort this vector. Find the key first.\n    const FieldDef *key = nullptr;\n    for (auto it = type.struct_def->fields.vec.begin();\n         it != type.struct_def->fields.vec.end(); ++it) {\n      if ((*it)->key) {\n        key = (*it);\n        break;\n      }\n    }\n    FLATBUFFERS_ASSERT(key);\n    // Now sort it.\n    // We can't use std::sort because for structs the size is not known at\n    // compile time, and for tables our iterators dereference offsets, so can't\n    // be used to swap elements.\n    // And we can't use C qsort either, since that would force use to use\n    // globals, making parsing thread-unsafe.\n    // So for now, we use SimpleQsort above.\n    // TODO: replace with something better, preferably not recursive.\n\n    if (type.struct_def->fixed) {\n      const voffset_t offset = key->value.offset;\n      const size_t struct_size = type.struct_def->bytesize;\n      auto v =\n          reinterpret_cast<VectorOfAny *>(builder_.GetCurrentBufferPointer());\n      SimpleQsort<uint8_t>(\n          v->Data(), v->Data() + v->size() * type.struct_def->bytesize,\n          type.struct_def->bytesize,\n          [offset, key](const uint8_t *a, const uint8_t *b) -> bool {\n            return CompareSerializedScalars(a + offset, b + offset, *key);\n          },\n          [struct_size](uint8_t *a, uint8_t *b) {\n            // FIXME: faster?\n            for (size_t i = 0; i < struct_size; i++) { std::swap(a[i], b[i]); }\n          });\n    } else {\n      auto v = reinterpret_cast<Vector<Offset<Table>> *>(\n          builder_.GetCurrentBufferPointer());\n      // Here also can't use std::sort. We do have an iterator type for it,\n      // but it is non-standard as it will dereference the offsets, and thus\n      // can't be used to swap elements.\n      if (key->value.type.base_type == BASE_TYPE_STRING) {\n        SimpleQsort<Offset<Table>>(\n            v->data(), v->data() + v->size(), 1,\n            [key](const Offset<Table> *_a, const Offset<Table> *_b) -> bool {\n              return CompareTablesByStringKey(_a, _b, *key);\n            },\n            SwapSerializedTables);\n      } else {\n        SimpleQsort<Offset<Table>>(\n            v->data(), v->data() + v->size(), 1,\n            [key](const Offset<Table> *_a, const Offset<Table> *_b) -> bool {\n              return CompareTablesByScalarKey(_a, _b, *key);\n            },\n            SwapSerializedTables);\n      }\n    }\n  }\n  return NoError();\n}\nCheckedError Parser::ParseDecl() {\n  std::vector<std::string> dc = doc_comment_;\n  bool fixed = IsIdent(\"struct\");\n  if (!fixed && !IsIdent(\"table\")) return Error(\"declaration expected\");\n  NEXT();\n  std::string name = attribute_;\n  EXPECT(kTokenIdentifier);\n  StructDef *struct_def;\n  ECHECK(StartStruct(name, &struct_def));\n  struct_def->doc_comment = dc;\n  struct_def->fixed = fixed;\n  ECHECK(ParseMetaData(&struct_def->attributes));\n  struct_def->sortbysize =\n      struct_def->attributes.Lookup(\"original_order\") == nullptr && !fixed;\n  EXPECT('{');\n  while (token_ != '}') ECHECK(ParseField(*struct_def));\n  if (fixed) {\n    const auto force_align = struct_def->attributes.Lookup(\"force_align\");\n    if (force_align) {\n      size_t align;\n      ECHECK(ParseAlignAttribute(force_align->constant, struct_def->minalign,\n                                 &align));\n      struct_def->minalign = align;\n    }\n    if (!struct_def->bytesize) return Error(\"size 0 structs not allowed\");\n  }\n  struct_def->PadLastField(struct_def->minalign);\n  // Check if this is a table that has manual id assignments\n  auto &fields = struct_def->fields.vec;\n  if (!fixed && fields.size()) {\n    size_t num_id_fields = 0;\n    for (auto it = fields.begin(); it != fields.end(); ++it) {\n      if ((*it)->attributes.Lookup(\"id\")) num_id_fields++;\n    }\n    // If any fields have ids..\n    if (num_id_fields || opts.require_explicit_ids) {\n      // Then all fields must have them.\n      if (num_id_fields != fields.size()) {\n        if (opts.require_explicit_ids) {\n          return Error(\n              \"all fields must have an 'id' attribute when \"\n              \"--require-explicit-ids is used\");\n        } else {\n          return Error(\n              \"either all fields or no fields must have an 'id' attribute\");\n        }\n      }\n      // Simply sort by id, then the fields are the same as if no ids had\n      // been specified.\n      std::sort(fields.begin(), fields.end(), compareFieldDefs);\n      // Verify we have a contiguous set, and reassign vtable offsets.\n      FLATBUFFERS_ASSERT(fields.size() <=\n                         flatbuffers::numeric_limits<voffset_t>::max());\n      for (voffset_t i = 0; i < static_cast<voffset_t>(fields.size()); i++) {\n        auto &field = *fields[i];\n        const auto &id_str = field.attributes.Lookup(\"id\")->constant;\n        // Metadata values have a dynamic type, they can be `float`, 'int', or\n        // 'string`.\n        // The FieldIndexToOffset(i) expects the voffset_t so `id` is limited by\n        // this type.\n        voffset_t id = 0;\n        const auto done = !atot(id_str.c_str(), *this, &id).Check();\n        if (!done)\n          return Error(\"field id\\'s must be non-negative number, field: \" +\n                       field.name + \", id: \" + id_str);\n        if (i != id)\n          return Error(\"field id\\'s must be consecutive from 0, id \" +\n                       NumToString(i) + \" missing or set twice, field: \" +\n                       field.name + \", id: \" + id_str);\n        field.value.offset = FieldIndexToOffset(i);\n      }\n    }\n  }\n\n  ECHECK(\n      CheckClash(fields, struct_def, UnionTypeFieldSuffix(), BASE_TYPE_UNION));\n  ECHECK(CheckClash(fields, struct_def, \"Type\", BASE_TYPE_UNION));\n  ECHECK(CheckClash(fields, struct_def, \"_length\", BASE_TYPE_VECTOR));\n  ECHECK(CheckClash(fields, struct_def, \"Length\", BASE_TYPE_VECTOR));\n  ECHECK(CheckClash(fields, struct_def, \"_byte_vector\", BASE_TYPE_STRING));\n  ECHECK(CheckClash(fields, struct_def, \"ByteVector\", BASE_TYPE_STRING));\n  EXPECT('}');\n  types_.Add(current_namespace_->GetFullyQualifiedName(struct_def->name),\n             new Type(BASE_TYPE_STRUCT, struct_def, nullptr));\n  return NoError();\n}\n",
    "target": 0,
    "idx": 2030684
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "get_word_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading raw-word-format PPM files with any maxval */\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n  register int rindex = rgb_red[cinfo->in_color_space];\n  register int gindex = rgb_green[cinfo->in_color_space];\n  register int bindex = rgb_blue[cinfo->in_color_space];\n  register int aindex = alpha_index[cinfo->in_color_space];\n  register int ps = rgb_pixelsize[cinfo->in_color_space];\n\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub.buffer[0];\n  bufferptr = source->iobuffer;\n  for (col = cinfo->image_width; col > 0; col--) {\n    register unsigned int temp;\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    ptr[rindex] = rescale[temp];\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    ptr[gindex] = rescale[temp];\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    ptr[bindex] = rescale[temp];\n    if (aindex >= 0)\n      ptr[aindex] = 0xFF;\n    ptr += ps;\n  }\n  return 1;\n}\n",
    "target": 0,
    "idx": 2032964
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "M3Result  Compile_Memory_Size  (IM3Compilation o, m3opcode_t i_opcode)\n{\n    M3Result result;\n\n    i8 reserved;\n_   (ReadLEB_i7 (& reserved, & o->wasm, o->wasmEnd));\n\n_   (PreserveRegisterIfOccupied (o, c_m3Type_i32));\n\n_   (EmitOp     (o, op_MemSize));\n\n_   (PushRegister (o, c_m3Type_i32));\n\n    _catch: return result;\n}\nM3Result  Compile_BlockStatements  (IM3Compilation o)\n{\n    M3Result result = m3Err_none;\n\n    while (o->wasm < o->wasmEnd)\n    {                                                                   emit_stack_dump (o);\n        m3opcode_t opcode;\n        o->lastOpcodeStart = o->wasm;\n_       (Read_opcode (& opcode, & o->wasm, o->wasmEnd));                log_opcode (o, opcode);\n\n        if (IsCompilingExpressions(o)) {\n            switch (opcode) {\n            case c_waOp_i32_const: case c_waOp_i64_const:\n            case c_waOp_f32_const: case c_waOp_f64_const:\n            case c_waOp_getGlobal: case c_waOp_end:\n                break;\n            default:\n                _throw(m3Err_restictedOpcode);\n            }\n        }\n\n        IM3OpInfo opinfo = GetOpInfo(opcode);\n        _throwif (m3Err_unknownOpcode, opinfo == NULL);\n\n        if (opinfo->compiler) {\n_           ((* opinfo->compiler) (o, opcode))\n        } else {\n_           (Compile_Operator (o, opcode));\n        }\n\n        o->previousOpcode = opcode;                             //                      m3logif (stack, dump_type_stack (o))\n\n        if (o->stackIndex > d_m3MaxFunctionStackHeight)         // TODO: is this only place to check?\n            _throw (m3Err_functionStackOverflow);\n\n        if (opcode == c_waOp_end or opcode == c_waOp_else)\n            break;\n    }\n\n_catch:\n    return result;\n}\nM3Result  Compile_ReserveConstants  (IM3Compilation o)\n{\n    M3Result result = m3Err_none;\n\n    // in the interest of speed, this blindly scans the Wasm code looking for any byte\n    // that looks like an const opcode.\n    u32 numConstantSlots = 0;\n\n    bytes_t wa = o->wasm;\n    while (wa < o->wasmEnd)\n    {\n        u8 code = * wa++;\n\n        if (code == c_waOp_i32_const or code == c_waOp_f32_const)\n            numConstantSlots += 1;\n        else if (code == c_waOp_i64_const or code == c_waOp_f64_const)\n            numConstantSlots += GetTypeNumSlots (c_m3Type_i64);\n    }\n\n    // if constants overflow their reserved stack space, the compiler simply emits op_Const\n    // operations as needed. Compiled expressions (global inits) don't pass through this\n    // ReserveConstants function and thus always produce inline constants.\n    u16 cappedConstantSlots = M3_MIN (numConstantSlots, d_m3MaxConstantTableSize);\n\n    AlignSlotIndexToType (& cappedConstantSlots, c_m3Type_i64);                                         m3log (compile, \"estimated constant slots: %d; reserved: %d\", numConstantSlots, (u32) cappedConstantSlots)\n\n    o->slotFirstDynamicIndex = o->slotFirstConstIndex + cappedConstantSlots;\n\n    if (o->slotFirstDynamicIndex >= d_m3MaxFunctionSlots)\n        _throw (m3Err_functionStackOverflow);\n\n    _catch:\n    return result;\n}\nM3Result  EvaluateExpression  (IM3Module i_module, void * o_expressed, u8 i_type, bytes_t * io_bytes, cbytes_t i_end)\n{\n    M3Result result = m3Err_none;\n\n    // create a temporary runtime context\n#if defined(d_m3PreferStaticAlloc)\n    static M3Runtime runtime;\n#else\n    M3Runtime runtime;\n#endif\n    M3_INIT (runtime);\n\n    runtime.environment = i_module->runtime->environment;\n    runtime.numStackSlots = i_module->runtime->numStackSlots;\n    runtime.stack = i_module->runtime->stack;\n    runtime.userdata = c_compilingExprsFlag;\n\n    m3stack_t stack = (m3stack_t)runtime.stack;\n\n    IM3Runtime savedRuntime = i_module->runtime;\n    i_module->runtime = & runtime;\n\n    IM3Compilation o = & runtime.compilation;\n    o->runtime = & runtime;\n    o->module =  i_module;\n    o->wasm =    * io_bytes;\n    o->wasmEnd = i_end;\n    o->lastOpcodeStart = o->wasm;\n\n    o->block.depth = -1;  // so that root compilation depth = 0\n\n    //  OPTZ: this code page could be erased after use.  maybe have 'empty' list in addition to full and open?\n    o->page = AcquireCodePage (& runtime);  // AcquireUnusedCodePage (...)\n\n    if (o->page)\n    {\n        IM3FuncType ftype = runtime.environment->retFuncTypes[i_type];\n\n        pc_t m3code = GetPagePC (o->page);\n        result = CompileBlock (o, ftype, c_waOp_block);\n\n        if (not result)\n        {\n            m3ret_t r = Call (m3code, stack, NULL, d_m3OpDefaultArgs);\n\n            if (r == 0)\n            {\n                if (SizeOfType (i_type) == sizeof (u32))\n                {\n                    * (u32 *) o_expressed = * ((u32 *) stack);\n                }\n                else\n                {\n                    * (u64 *) o_expressed = * ((u64 *) stack);\n                }\n            }\n        }\n\n        // TODO: EraseCodePage (...) see OPTZ above\n        ReleaseCodePage (& runtime, o->page);\n    }\n    else result = m3Err_mallocFailedCodePage;\n\n    runtime.stack = NULL;        // prevent free(stack) in ReleaseRuntime\n    Runtime_Release (& runtime);\n    i_module->runtime = savedRuntime;\n\n    * io_bytes = o->wasm;\n\n    return result;\n}\n",
    "target": 0,
    "idx": 2033196
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "M3Result  SignatureToFuncType  (IM3FuncType * o_functionType, ccstr_t i_signature)\n{\n    M3Result result = m3Err_none;\n\n    IM3FuncType funcType = NULL;\n\n_try {\n    if (not o_functionType)\n        _throw (\"null function type\");\n\n    if (not i_signature)\n        _throw (\"null function signature\");\n\n    cstr_t sig = i_signature;\n\n    size_t maxNumTypes = strlen (i_signature);\n\n    // assume min signature is \"()\"\n    _throwif (m3Err_malformedFunctionSignature, maxNumTypes < 2);\n    maxNumTypes -= 2;\n\n    _throwif (m3Err_tooManyArgsRets, maxNumTypes > d_m3MaxSaneFunctionArgRetCount);\n\n_   (AllocFuncType (& funcType, (u32) maxNumTypes));\n\n    u8 * typelist = funcType->types;\n\n    bool parsingRets = true;\n    while (* sig)\n    {\n        char typeChar = * sig++;\n\n        if (typeChar == '(')\n        {\n            parsingRets = false;\n            continue;\n        }\n        else if ( typeChar == ' ')\n            continue;\n        else if (typeChar == ')')\n            break;\n\n        u8 type = ConvertTypeCharToTypeId (typeChar);\n\n        _throwif (\"unknown argument type char\", c_m3Type_unknown == type);\n\n        if (type == c_m3Type_none)\n            continue;\n\n        if (parsingRets)\n        {\n            _throwif (\"malformed signature; return count overflow\", funcType->numRets >= maxNumTypes);\n            funcType->numRets++;\n            *typelist++ = type;\n        }\n        else\n        {\n            _throwif (\"malformed signature; arg count overflow\", (u32)(funcType->numRets) + funcType->numArgs >= maxNumTypes);\n            funcType->numArgs++;\n            *typelist++ = type;\n        }\n    }\n\n} _catch:\n\n    if (result)\n        m3_Free (funcType);\n\n    * o_functionType = funcType;\n\n    return result;\n}\nM3Result  Compile_BlockStatements  (IM3Compilation o)\n{\n    M3Result result = m3Err_none;\n    bool ended = false;\n\n    while (o->wasm < o->wasmEnd)\n    {                                                                   emit_stack_dump (o);\n        m3opcode_t opcode;\n        o->lastOpcodeStart = o->wasm;\n_       (Read_opcode (& opcode, & o->wasm, o->wasmEnd));                log_opcode (o, opcode);\n\n        // Restrict opcodes when evaluating expressions\n        if (not o->function) {\n            switch (opcode) {\n            case c_waOp_i32_const: case c_waOp_i64_const:\n            case c_waOp_f32_const: case c_waOp_f64_const:\n            case c_waOp_getGlobal: case c_waOp_end:\n                break;\n            default:\n                _throw(m3Err_restictedOpcode);\n            }\n        }\n\n        IM3OpInfo opinfo = GetOpInfo(opcode);\n        _throwif (m3Err_unknownOpcode, opinfo == NULL);\n\n        if (opinfo->compiler) {\n_           ((* opinfo->compiler) (o, opcode))\n        } else {\n_           (Compile_Operator (o, opcode));\n        }\n\n        o->previousOpcode = opcode;                             //                      m3logif (stack, dump_type_stack (o))\n\n        if (o->stackIndex > d_m3MaxFunctionStackHeight)         // TODO: is this only place to check?\n            _throw (m3Err_functionStackOverflow);\n\n        if (opcode == c_waOp_end or opcode == c_waOp_else) {\n            ended = true;\n            break;\n        }\n    }\n    _throwif(m3Err_wasmMalformed, !(ended));\n\n_catch:\n    return result;\n}\nM3Result  InitDataSegments  (M3Memory * io_memory, IM3Module io_module)\n{\n    M3Result result = m3Err_none;\n\n    for (u32 i = 0; i < io_module->numDataSegments; ++i)\n    {\n        M3DataSegment * segment = & io_module->dataSegments [i];\n\n        i32 segmentOffset;\n        bytes_t start = segment->initExpr;\n_       (EvaluateExpression (io_module, & segmentOffset, c_m3Type_i32, & start, segment->initExpr + segment->initExprSize));\n\n        m3log (runtime, \"loading data segment: %d; size: %d; offset: %d\", i, segment->size, segmentOffset);\n\n        _throwif (\"unallocated linear memory\", !(io_memory->mallocated));\n\n        if (segmentOffset > 0 && (size_t) segmentOffset + segment->size <= io_memory->mallocated->length)\n        {\n            u8 * dest = m3MemData (io_memory->mallocated) + segmentOffset;\n            memcpy (dest, segment->data, segment->size);\n        } else {\n            _throw (\"data segment out of bounds\");\n        }\n    }\n\n    _catch: return result;\n}\nM3Result  InitElements  (IM3Module io_module)\n{\n    M3Result result = m3Err_none;\n\n    bytes_t bytes = io_module->elementSection;\n    cbytes_t end = io_module->elementSectionEnd;\n\n    for (u32 i = 0; i < io_module->numElementSegments; ++i)\n    {\n        u32 index;\n_       (ReadLEB_u32 (& index, & bytes, end));\n\n        if (index == 0)\n        {\n            i32 offset;\n_           (EvaluateExpression (io_module, & offset, c_m3Type_i32, & bytes, end));\n            _throwif (\"table underflow\", offset < 0);\n\n            u32 numElements;\n_           (ReadLEB_u32 (& numElements, & bytes, end));\n\n            size_t endElement = (size_t)(numElements) + offset;\n            _throwif (\"table overflow\", endElement > d_m3MaxSaneTableSize);\n\n            io_module->table0 = m3_ReallocArray (IM3Function, io_module->table0, endElement, io_module->table0Size);\n            _throwifnull(io_module->table0);\n\n            io_module->table0Size = (u32) endElement;\n\n            for (u32 e = 0; e < numElements; ++e)\n            {\n                u32 functionIndex;\n_               (ReadLEB_u32 (& functionIndex, & bytes, end));\n                _throwif (\"function index out of range\", functionIndex >= io_module->numFunctions);\n                IM3Function function = & io_module->functions [functionIndex];      d_m3Assert (function); //printf (\"table: %s\\n\", m3_GetFunctionName(function));\n                io_module->table0 [e + offset] = function;\n            }\n        }\n        else _throw (\"element table index must be zero for MVP\");\n    }\n\n    _catch: return result;\n}\nM3Result  ParseSection_Type  (IM3Module io_module, bytes_t i_bytes, cbytes_t i_end)\n{\n    M3Result result = m3Err_none;\n    IM3FuncType ftype = NULL;\n\n_try {\n    u32 numTypes;\n_   (ReadLEB_u32 (& numTypes, & i_bytes, i_end));                                   m3log (parse, \"** Type [%d]\", numTypes);\n\n    _throwif(\"too many types\", numTypes > d_m3MaxSaneTypesCount);\n\n    if (numTypes)\n    {\n        // table of IM3FuncType (that point to the actual M3FuncType struct in the Environment)\n        io_module->funcTypes = m3_AllocArray (IM3FuncType, numTypes);\n        _throwifnull(io_module->funcTypes);\n        io_module->numFuncTypes = numTypes;\n\n        for (u32 i = 0; i < numTypes; ++i)\n        {\n            i8 form;\n_           (ReadLEB_i7 (& form, & i_bytes, i_end));\n            _throwif (m3Err_wasmMalformed, form != -32); // for Wasm MVP\n\n            u32 numArgs;\n_           (ReadLEB_u32 (& numArgs, & i_bytes, i_end));\n\n            _throwif (m3Err_tooManyArgsRets, numArgs > d_m3MaxSaneFunctionArgRetCount);\n#if defined(M3_COMPILER_MSVC)\n            u8 argTypes [d_m3MaxSaneFunctionArgRetCount];\n#else\n            u8 argTypes[numArgs+1]; // make ubsan happy\n#endif\n            for (u32 a = 0; a < numArgs; ++a)\n            {\n                i8 wasmType;\n                u8 argType;\n_               (ReadLEB_i7 (& wasmType, & i_bytes, i_end));\n_               (NormalizeType (& argType, wasmType));\n\n                argTypes[a] = argType;\n            }\n\n            u32 numRets;\n_           (ReadLEB_u32 (& numRets, & i_bytes, i_end));\n            _throwif (m3Err_tooManyArgsRets, (u64)(numRets) + numArgs > d_m3MaxSaneFunctionArgRetCount);\n\n_           (AllocFuncType (& ftype, numRets + numArgs));\n            ftype->numArgs = numArgs;\n            ftype->numRets = numRets;\n\n            for (u32 r = 0; r < numRets; ++r)\n            {\n                i8 wasmType;\n                u8 retType;\n_               (ReadLEB_i7 (& wasmType, & i_bytes, i_end));\n_               (NormalizeType (& retType, wasmType));\n\n                ftype->types[r] = retType;\n            }\n            memcpy (ftype->types + numRets, argTypes, numArgs);                                 m3log (parse, \"    type %2d: %s\", i, SPrintFuncTypeSignature (ftype));\n\n            Environment_AddFuncType (io_module->environment, & ftype);\n            io_module->funcTypes [i] = ftype;\n            ftype = NULL; // ownership transfered to environment\n        }\n    }\n\n} _catch:\n\n    if (result)\n    {\n        m3_Free (ftype);\n        m3_Free (io_module->funcTypes);\n        io_module->numFuncTypes = 0;\n    }\n\n    return result;\n}\n",
    "target": 0,
    "idx": 2033240
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "u16  GetMaxUsedSlotPlusOne  (IM3Compilation o)\n{\n    while (o->slotMaxAllocatedIndexPlusOne > o->slotFirstDynamicIndex)\n    {\n        if (IsSlotAllocated (o, o->slotMaxAllocatedIndexPlusOne - 1))\n            break;\n\n        o->slotMaxAllocatedIndexPlusOne--;\n    }\n\n#   ifdef DEBUG\n        u16 maxSlot = o->slotMaxAllocatedIndexPlusOne;\n        while (maxSlot < d_m3MaxFunctionSlots)\n        {\n            d_m3Assert (o->m3Slots [maxSlot] == 0);\n            maxSlot++;\n        }\n#   endif\n\n    return o->slotMaxAllocatedIndexPlusOne;\n}\nM3Result  Push  (IM3Compilation o, u8 i_type, u16 i_slot)\n{\n    M3Result result = m3Err_none;\n\n#if !d_m3HasFloat\n    if (i_type == c_m3Type_f32 || i_type == c_m3Type_f64) {\n        return m3Err_unknownOpcode;\n    }\n#endif\n\n    u16 stackIndex = o->stackIndex++;                                       // printf (\"push: %d\\n\", (i32) i);\n\n    if (stackIndex < d_m3MaxFunctionStackHeight)\n    {\n        o->wasmStack        [stackIndex] = i_slot;\n        o->typeStack        [stackIndex] = i_type;\n\n        if (IsRegisterSlotAlias (i_slot))\n        {\n            u32 regSelect = IsFpRegisterSlotAlias (i_slot);\n            AllocateRegister (o, regSelect, stackIndex);\n        }\n        else\n        {\n            // op_Entry and EvaluateExpression use this value to track and detect stack overflow\n            o->maxStackSlots = M3_MAX (o->maxStackSlots, i_slot + 1);\n        }\n\n        if (d_m3LogWasmStack) dump_type_stack (o);\n    }\n    else result = m3Err_functionStackOverflow;\n\n    return result;\n}\nbool  PatchBranches  (IM3Compilation o)\n{\n    pc_t pc = GetPC (o);\n\n    IM3BranchPatch patches = o->block.patches;\n    o->block.patches = NULL;\n\n    bool didPatch = patches;\n\n    while (patches)\n    {                                                           m3log (compile, \"patching location: %p to pc: %p\", patches, pc);\n        patches->location = pc;\n        patches = patches->next;\n    }\n\n    return didPatch;\n}\nM3Result  MoveStackTopToSlot  (IM3Compilation o, u16 i_slot, bool i_doPushPop)\n{\n    M3Result result = m3Err_none;\n\n    if (GetStackTopSlotNumber (o) != i_slot)    // (registers have a unique slot num alias)\n    {\n        u8 type = GetStackTopType (o);\n\n_       (CopyStackTopToSlot (o, i_slot));\n\n        if (i_doPushPop)\n        {\n_           (Pop (o));\n_           (PushAllocatedSlot (o, type))\n//          MarkSlotAllocated (o, i_slot);\n//_         (Push (o, type, i_slot));\n        }\n    }\n\n    _catch: return result;\n}\nM3Result  ResolveBlockResults  (IM3Compilation o, IM3CompilationScope i_targetBlock, bool i_doPushPop)\n{\n    M3Result result = m3Err_none;                                   if (d_m3LogWasmStack) dump_type_stack (o);\n\n    u8 stackType = GetSingleRetType (i_targetBlock->type);\n\n    if (stackType != c_m3Type_none)\n    {\n        if (IsFpType (stackType))\n_           (CopyStackTopToRegister (o, i_doPushPop))\n        else\n_           (MoveStackTopToSlot (o, i_targetBlock->topSlot, i_doPushPop))\n    }\n\n    _catch: return result;\n}\nM3Result  ValidateBlockEnd  (IM3Compilation o)\n{\n    M3Result result = m3Err_none;\n\n    u8 stackType = GetSingleRetType (o->block.type);\n\n    if (stackType != c_m3Type_none)\n    {\n        if (IsStackPolymorphic (o))\n        {\n            /*\n             according to reference implementations: the type stack should still be validated\n             here, which is totally senseless in practice.\n\n             the spec behavior which I had to deduce from the ocaml and wat2wasm tools is:\n             a polymorphic stack can pop any type requested, but if values have been pushed\n             since going polymorphic, those type are not polymorphic.\n            */\n\n_           (UnwindBlockStack (o));\n\n            if (IsFpType (stackType))\n_               (PushRegister (o, stackType))\n            else\n_               (PushAllocatedSlot (o, stackType))\n        }\n        else\n        {\n            i16 initStackIndex = o->block.initStackIndex;\n\n            if (o->block.depth > 0 and initStackIndex != o->stackIndex)\n            {\n                if (o->stackIndex == initStackIndex + 1)\n                {\n_                   (ResolveBlockResults (o, & o->block, true));\n                }\n                else _throw (\"unexpected block stack offset\");\n            }\n        }\n    }\n    else\n_       (UnwindBlockStack (o));\n\n    _catch: return result;\n}\nM3Result  Compile_End  (IM3Compilation o, m3opcode_t i_opcode)\n{\n    M3Result result = m3Err_none;\n\n    // function end:\n    if (o->block.depth == 0)\n    {\n        ValidateBlockEnd (o);\n\n        u8 type = GetSingleRetType (o->block.type);\n\n        u32 numReturns = GetFuncTypeNumReturns (o->block.type);\n\n        if (numReturns)\n        {\n            if (not o->block.isPolymorphic and type != GetStackTopType (o))\n                _throw (m3Err_typeMismatch);\n\n            if (not o->block.isPolymorphic)\n                ResolveBlockResults (o, & o->block, true);\n\n            // if there are branches to the function end, then their values are in a register\n            // if the block happens to have its top in a register too, then we can patch the branch\n            // to here. Otherwise, an ReturnStackTop is appended to the end of the function (at B) and\n            // branches patched there.\n            PatchBranches (o);\n\n_           (ReturnStackTop (o));\n        }\n        else PatchBranches (o);  // for no return type, branch to op_End\n\n_       (EmitOp (o, op_Return));\n\n_       (UnwindBlockStack (o));\n    }\n\n    _catch: return result;\n}\nM3Result  EmitPatchingBranch  (IM3Compilation o, IM3CompilationScope i_scope)\n{\n    M3Result result ;\n\n_try {\n\n_   (EmitOp (o, op_Branch));\n\n    // IM3BranchPatch is two word struct; reserve two words\n    IM3BranchPatch patch = (IM3BranchPatch) ReservePointer (o);                     m3log (compile, \"branch patch required at: %p\", patch);\n                                            ReservePointer (o);\n    patch->next = i_scope->patches;\n    i_scope->patches = patch;\n\n}   _catch:\nM3Result  Compile_Branch  (IM3Compilation o, m3opcode_t i_opcode)\n{\n    M3Result result;\n\n    u32 depth;\n_   (ReadLEB_u32 (& depth, & o->wasm, o->wasmEnd));\n\n    IM3CompilationScope scope;\n_   (GetBlockScope (o, & scope, depth));\n\n    // branch target is a loop (continue)\n    if (scope->opcode == c_waOp_loop)\n    {\n        IM3Operation op;\n\n        if (i_opcode == c_waOp_branchIf)\n        {\n            op = op_ContinueLoopIf;\n            // move the condition to a register\n_           (CopyStackTopToRegister (o, false));\n_           (PopType (o, c_m3Type_i32));\n        }\n        else // is c_waOp_branch\n        {\n            op = op_ContinueLoop;\n            o->block.isPolymorphic = true;\n        }\n\n_       (EmitOp (o, op));\n        EmitPointer (o, scope->pc);\n    }\n    else // forward branch\n    {\n        pc_t * jumpTo = NULL;\n\n        if (i_opcode == c_waOp_branchIf)\n        {\n            // OPTZ: need a flipped BranchIf without ResolveBlockResults prologue\n            // when no stack results\n\n            IM3Operation op = IsStackTopInRegister (o) ? op_BranchIfPrologue_r : op_BranchIfPrologue_s;\n\n    _       (EmitOp (o, op));\n            EmitSlotNumOfStackTopAndPop (o); // condition\n\n            // this is continuation point, if the branch isn't taken\n            jumpTo = (pc_t *) ReservePointer (o);\n        }\n\n        if (not IsStackPolymorphic (o))\n_           (ResolveBlockResults (o, scope, false));\n\n_       (EmitPatchingBranch (o, scope));\n\n        if (jumpTo)\n        {\n            * jumpTo = GetPC (o);\n        }\n        else SetStackPolymorphic (o);\n    }\n\n    _catch: return result;\n}\nM3Result  Compile_BranchTable  (IM3Compilation o, m3opcode_t i_opcode)\n{\n    M3Result result;\n\n_try {\n    u32 targetCount;\n_   (ReadLEB_u32 (& targetCount, & o->wasm, o->wasmEnd));\n\n_   (PreserveRegisterIfOccupied (o, c_m3Type_i64));         // move branch operand to a slot\n    u16 slot = GetStackTopSlotNumber (o);\n_   (Pop (o));\n\n    // OPTZ: according to spec: \"forward branches that target a control instruction with a non-empty\n    // result type consume matching operands first and push them back on the operand stack after unwinding\"\n    // So, this move-to-reg is only necessary if the target scopes have a type.\n\n    u32 numCodeLines = targetCount + 4; // 3 => IM3Operation + slot + target_count + default_target\n_   (EnsureCodePageNumLines (o, numCodeLines));\n\n_   (EmitOp (o, op_BranchTable));\n    EmitSlotOffset (o, slot);\n    EmitConstant32 (o, targetCount);\n\n    IM3CodePage continueOpPage = NULL;\n\n    ++targetCount; // include default\n    for (u32 i = 0; i < targetCount; ++i)\n    {\n        u32 target;\n_       (ReadLEB_u32 (& target, & o->wasm, o->wasmEnd));\n\n        IM3CompilationScope scope;\n_       (GetBlockScope (o, & scope, target));\n\n        // create a ContinueLoop operation on a fresh page\n_       (AcquireCompilationCodePage (o, & continueOpPage));\n\n        pc_t startPC = GetPagePC (continueOpPage);\n        IM3CodePage savedPage = o->page;\n        o->page = continueOpPage;\n\n        if (scope->opcode == c_waOp_loop)\n        {\n_           (EmitOp (o, op_ContinueLoop));\n            EmitPointer (o, scope->pc);\n        }\n        else\n        {\n            // TODO: this could be fused with equivalent targets\n_           (ResolveBlockResults (o, scope, false));\n\n_           (EmitPatchingBranch (o, scope));\n        }\n\n        ReleaseCompilationCodePage (o);     // FIX: continueOpPage can get lost if thrown\n        o->page = savedPage;\n\n        EmitPointer (o, startPC);\n    }\n\n    SetStackPolymorphic (o);\n\n    }\nM3Result  CompileFunction  (IM3Function io_function)\n{\n    if (!io_function->wasm) return \"function body is missing\";\n\n    IM3FuncType funcType = io_function->funcType;\n\n    M3Result result = m3Err_none;                                   m3log (compile, \"compiling: '%s'; wasm-size: %d; numArgs: %d; return: %s\",\n                                                                           m3_GetFunctionName(io_function), (u32) (io_function->wasmEnd - io_function->wasm), GetFunctionNumArgs (io_function),\n                                                                           c_waTypes [GetSingleRetType(funcType)]);\n    IM3Runtime runtime = io_function->module->runtime;\n\n    IM3Compilation o = & runtime->compilation;                      d_m3Assert (d_m3MaxFunctionSlots >= d_m3MaxFunctionStackHeight * (d_m3Use32BitSlots + 1))  // need twice as many slots in 32-bit mode\n    SetupCompilation (o);\n\n    o->runtime  = runtime;\n    o->module   = io_function->module;\n    o->function = io_function;\n    o->wasm     = io_function->wasm;\n    o->wasmEnd  = io_function->wasmEnd;\n    o->block.type = funcType;\n\n_try {\n    // skip over code size. the end was already calculated during parse phase\n    u32 size;\n_   (ReadLEB_u32 (& size, & o->wasm, o->wasmEnd));                  d_m3Assert (size == (o->wasmEnd - o->wasm))\n\n_   (AcquireCompilationCodePage (o, & o->page));\n\n    pc_t pc = GetPagePC (o->page);\n\n    u16 numRetSlots = GetFunctionNumReturns (o->function) * c_ioSlotCount;\n\n    for (u16 i = 0; i < numRetSlots; ++i)\n        MarkSlotAllocated (o, i);\n\n    o->function->numRetSlots = o->slotFirstDynamicIndex = numRetSlots;\n\n    u16 numArgs = GetFunctionNumArgs (o->function);\n\n    // push the arg types to the type stack\n    for (u16 i = 0; i < numArgs; ++i)\n    {\n        u8 type = GetFunctionArgType (o->function, i);\n_       (PushAllocatedSlot (o, type));\n\n        // prevent allocator fill-in\n        o->slotFirstDynamicIndex += c_ioSlotCount;\n    }\n\n    o->slotMaxAllocatedIndexPlusOne = o->function->numRetAndArgSlots = o->slotFirstLocalIndex = o->slotFirstDynamicIndex;\n\n_   (CompileLocals (o));\n\n    u16 maxSlot = GetMaxUsedSlotPlusOne (o);\n\n    o->function->numLocalBytes = (maxSlot - o->slotFirstLocalIndex) * sizeof (m3slot_t);\n\n    o->slotFirstConstIndex = o->slotMaxConstIndex = maxSlot;\n\n    // ReserveConstants initializes o->firstDynamicSlotNumber\n_   (Compile_ReserveConstants (o));\n\n    // start tracking the max stack used (Push() also updates this value) so that op_Entry can precisely detect stack overflow\n    o->maxStackSlots = o->slotMaxAllocatedIndexPlusOne = o->slotFirstDynamicIndex;\n\n    o->block.topSlot = o->slotFirstDynamicIndex;\n    o->block.initStackIndex = o->stackFirstDynamicIndex = o->stackIndex;                           m3log (compile, \"start stack index: %d;  top slot num: %d\", (u32) o->stackFirstDynamicIndex, (u32) o->block.topSlot);\n\n_   (EmitOp (o, op_Entry));\n    EmitPointer (o, io_function);\n\n_   (CompileBlockStatements (o));\n\n    // TODO: validate opcode sequences\n    _throwif(m3Err_wasmMalformed, o->previousOpcode != c_waOp_end);\n\n    io_function->compiled = pc;\n    io_function->maxStackSlots = o->maxStackSlots;\n\n    u16 numConstantSlots = o->slotMaxConstIndex - o->slotFirstConstIndex;       m3log (compile, \"unique constant slots: %d; unused slots: %d\", numConstantSlots, o->slotFirstDynamicIndex - o->slotMaxConstIndex);\n\n    io_function->numConstantBytes = numConstantSlots * sizeof (m3slot_t);\n\n    if (numConstantSlots)\n    {\n        io_function->constants = m3_CopyMem (o->constants, io_function->numConstantBytes);\n        _throwifnull(io_function->constants);\n    }\n\n} _catch:\nvoid  m3_FreeImpl  (void * io_ptr)\n{\n//    if (io_ptr) printf(\"== free %p\\n\", io_ptr);\n    free (io_ptr);\n}\nM3Result  EvaluateExpression  (IM3Module i_module, void * o_expressed, u8 i_type, bytes_t * io_bytes, cbytes_t i_end)\n{\n    M3Result result = m3Err_none;\n\n    // OPTZ: use a simplified interpreter for expressions\n\n    // create a temporary runtime context\n#if defined(d_m3PreferStaticAlloc)\n    static M3Runtime runtime;\n#else\n    M3Runtime runtime;\n#endif\n    M3_INIT (runtime);\n\n    runtime.environment = i_module->runtime->environment;\n    runtime.numStackSlots = i_module->runtime->numStackSlots;\n    runtime.stack = i_module->runtime->stack;\n\n    m3stack_t stack = (m3stack_t)runtime.stack;\n\n    IM3Runtime savedRuntime = i_module->runtime;\n    i_module->runtime = & runtime;\n\n    IM3Compilation o = & runtime.compilation;\n    o->runtime = & runtime;\n    o->module =  i_module;\n    o->wasm =    * io_bytes;\n    o->wasmEnd = i_end;\n    o->lastOpcodeStart = o->wasm;\n\n    o->block.depth = -1;  // so that root compilation depth = 0\n\n    //  OPTZ: this code page could be erased after use.  maybe have 'empty' list in addition to full and open?\n    o->page = AcquireCodePage (& runtime);  // AcquireUnusedCodePage (...)\n\n    if (o->page)\n    {\n        IM3FuncType ftype = runtime.environment->retFuncTypes[i_type];\n\n        pc_t m3code = GetPagePC (o->page);\n        result = CompileBlock (o, ftype, c_waOp_block);\n\n        if (not result && o->maxStackSlots >= runtime.numStackSlots) {\n            result = m3Err_trapStackOverflow;\n        }\n\n        if (not result)\n        {\n            m3ret_t r = Call (m3code, stack, NULL, d_m3OpDefaultArgs);\n\n            if (r == 0)\n            {                                                                               m3log (runtime, \"expression result: %s\", SPrintValue (stack, i_type));\n                if (SizeOfType (i_type) == sizeof (u32))\n                {\n                    * (u32 *) o_expressed = * ((u32 *) stack);\n                }\n                else\n                {\n                    * (u64 *) o_expressed = * ((u64 *) stack);\n                }\n            }\n        }\n\n        // TODO: EraseCodePage (...) see OPTZ above\n        ReleaseCodePage (& runtime, o->page);\n    }\n    else result = m3Err_mallocFailedCodePage;\n\n    runtime.stack = NULL;        // prevent free(stack) in ReleaseRuntime\n    Runtime_Release (& runtime);\n    i_module->runtime = savedRuntime;\n\n    * io_bytes = o->wasm;\n\n    return result;\n}\nM3Result  m3_LoadModule  (IM3Runtime io_runtime, IM3Module io_module)\n{\n    M3Result result = m3Err_none;\n\n    if (UNLIKELY(io_module->runtime)) {\n        return m3Err_moduleAlreadyLinked;\n    }\n\n    io_module->runtime = io_runtime;\n    M3Memory * memory = & io_runtime->memory;\n\n_   (InitMemory (io_runtime, io_module));\n_   (InitGlobals (io_module));\n_   (InitDataSegments (memory, io_module));\n_   (InitElements (io_module));\n\n    // Start func might use imported functions, which are not liked here yet,\n    // so it will be called before a function call is attempted (in m3_FindFunction)\n\n    io_module->next = io_runtime->modules;\n    io_runtime->modules = io_module;\n    return result; // ok\n\n_catch:\n    io_module->runtime = NULL;\n    return result;\n}\nIM3Global  m3_FindGlobal  (IM3Module               io_module,\n                           const char * const      i_globalName)\n{\n    // Search exports\n    for (u32 i = 0; i < io_module->numGlobals; ++i)\n    {\n        IM3Global g = & io_module->globals [i];\n        if (g->name and strcmp (g->name, i_globalName) == 0)\n        {\n            return g;\n        }\n    }\n\n    // Search imports\n    for (u32 i = 0; i < io_module->numGlobals; ++i)\n    {\n        IM3Global g = & io_module->globals [i];\n\n        if (g->import.moduleUtf8 and g->import.fieldUtf8)\n        {\n            if (strcmp (g->import.fieldUtf8, i_globalName) == 0)\n            {\n                return g;\n            }\n        }\n    }\n    return NULL;\n}\nvoid  dump_type_stack  (IM3Compilation o)\n{\n    /* Reminders about how the stack works! :)\n     -- args & locals remain on the type stack for duration of the function. Denoted with a constant 'A' and 'L' in this dump.\n     -- the initial stack dumps originate from the CompileLocals () function, so these identifiers won't/can't be\n     applied until this compilation stage is finished\n     -- constants are not statically represented in the type stack (like args & constants) since they don't have/need\n     write counts\n\n     -- the number shown for static args and locals (value in wasmStack [i]) represents the write count for the variable\n\n     -- (does Wasm ever write to an arg? I dunno/don't remember.)\n     -- the number for the dynamic stack values represents the slot number.\n     -- if the slot index points to arg, local or constant it's denoted with a lowercase 'a', 'l' or 'c'\n\n     */\n\n    // for the assert at end of dump:\n    i32 regAllocated [2] = { (i32) IsRegisterAllocated (o, 0), (i32) IsRegisterAllocated (o, 1) };\n\n    // display whether r0 or fp0 is allocated. these should then also be reflected somewhere in the stack too.\n    d_m3Log(stack, \"\\n\");\n    d_m3Log(stack, \"        \");\n    printf (\"%s %s    \", regAllocated [0] ? \"(r0)\" : \"    \", regAllocated [1] ? \"(fp0)\" : \"     \");\n\n//  printf (\"%d\", o->stackIndex -)\n    for (u32 i = o->stackFirstDynamicIndex; i < o->stackIndex; ++i)\n    {\n        printf (\" %s\", c_waCompactTypes [o->typeStack [i]]);\n\n        u16 slot = o->wasmStack [i];\n\n        if (IsRegisterSlotAlias (slot))\n        {\n            bool isFp = IsFpRegisterSlotAlias (slot);\n            printf (\"%s\", isFp ? \"f0\" : \"r0\");\n\n            regAllocated [isFp]--;\n        }\n        else\n        {\n            if (slot < o->slotFirstDynamicIndex)\n            {\n                if (slot >= o->slotFirstConstIndex)\n                    printf (\"c\");\n                else if (slot >= o->function->numRetAndArgSlots)\n                    printf (\"L\");\n                else\n                    printf (\"a\");\n            }\n\n            printf (\"%d\", (i32) slot);  // slot\n        }\n\n        printf (\" \");\n    }\n    printf (\"\\n\");\n\n    for (u32 r = 0; r < 2; ++r)\n        d_m3Assert (regAllocated [r] == 0);         // reg allocation & stack out of sync\n\n    u16 maxSlot = GetMaxUsedSlotPlusOne (o);\n\n    if (maxSlot > o->slotFirstDynamicIndex)\n    {\n        d_m3Log (stack, \"                      -\");\n\n        for (u16 i = o->slotFirstDynamicIndex; i < maxSlot; ++i)\n            printf (\"----\");\n\n        printf (\"\\n\");\n\n        d_m3Log (stack, \"                 slot |\");\n        for (u16 i = o->slotFirstDynamicIndex; i < maxSlot; ++i)\n            printf (\"%3d|\", i);\n\n        printf (\"\\n\");\n        d_m3Log (stack, \"                alloc |\");\n\n        for (u16 i = o->slotFirstDynamicIndex; i < maxSlot; ++i)\n        {\n            printf (\"%3d|\", o->m3Slots [i]);\n        }\n\n        printf (\"\\n\");\n    }\n    d_m3Log(stack, \"\\n\");\n}\nvoid  m3_FreeModule  (IM3Module i_module)\n{\n    if (i_module)\n    {\n        m3log (module, \"freeing module: %s (funcs: %d; segments: %d)\",\n               i_module->name, i_module->numFunctions, i_module->numDataSegments);\n\n        Module_FreeFunctions (i_module);\n\n        m3_Free (i_module->functions);\n        //m3_Free (i_module->imports);\n        m3_Free (i_module->funcTypes);\n        m3_Free (i_module->dataSegments);\n        m3_Free (i_module->table0);\n\n        for (u32 i = 0; i < i_module->numGlobals; ++i)\n        {\n            m3_Free (i_module->globals[i].name);\n            FreeImportInfo(&(i_module->globals[i].import));\n        }\n        m3_Free (i_module->globals);\n\n        m3_Free (i_module);\n    }\n}\nIM3Runtime  m3_GetModuleRuntime  (IM3Module i_module)\n{\n    return i_module ? i_module->runtime : NULL;\n}\n",
    "target": 0,
    "idx": 2033318
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "int parse_lxc_mntopts(struct lxc_mount_options *opts, char *mnt_opts)\n{\n\tfor (size_t i = LXC_MOUNT_CREATE_DIR; i < LXC_MOUNT_MAX; i++) {\n\t\t__do_close int fd_userns = -EBADF;\n\t\tconst char *opt_name = lxc_mount_options_info[i];\n\t\tsize_t len;\n\t\tchar *idmap_path, *opt, *opt_next;\n\n\t\topt = strstr(mnt_opts, opt_name);\n\t\tif (!opt)\n\t\t\tcontinue;\n\n\t\tswitch (i) {\n\t\tcase LXC_MOUNT_CREATE_DIR:\n\t\t\topts->create_dir = 1;\n\t\t\tbreak;\n\t\tcase LXC_MOUNT_CREATE_FILE:\n\t\t\topts->create_file = 1;\n\t\t\tbreak;\n\t\tcase LXC_MOUNT_OPTIONAL:\n\t\t\topts->optional = 1;\n\t\t\tbreak;\n\t\tcase LXC_MOUNT_RELATIVE:\n\t\t\topts->relative = 1;\n\t\t\tbreak;\n\t\tcase LXC_MOUNT_IDMAP:\n\t\t\topt_next = opt;\n\t\t\topt_next += STRLITERALLEN(\"idmap=\");\n\t\t\tidmap_path = strchrnul(opt_next, ',');\n\t\t\tlen = idmap_path - opt_next + 1;\n\n\t\t\tif (len >= sizeof(opts->userns_path))\n\t\t\t\treturn syserror_set(-EIO, \"Excessive idmap path length for \\\"idmap=<path>\\\" LXC specific mount option\");\n\n\t\t\tmemcpy(opts->userns_path, opt_next, len);\n\n\t\t\tif (is_empty_string(opts->userns_path))\n\t\t\t\treturn syserror_set(-EINVAL, \"Missing idmap path for \\\"idmap=<path>\\\" LXC specific mount option\");\n\n\t\t\tfd_userns = open(opts->userns_path, O_RDONLY | O_NOCTTY | O_CLOEXEC);\n\t\t\tif (fd_userns < 0)\n\t\t\t\treturn syserror(\"Failed to open user namespace\");\n\n\t\t\tTRACE(\"Parse LXC specific mount option %d->\\\"idmap=%s\\\"\", fd_userns, opts->userns_path);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn syserror_set(-EINVAL, \"Unknown LXC specific mount option\");\n\t\t}\n\n\t\topt_next = strchr(opt, ',');\n\t\tif (!opt_next)\n\t\t\t*opt = '\\0'; /* no more mntopts, so just chop it here */\n\t\telse\n\t\t\tmemmove(opt, opt_next + 1, strlen(opt_next + 1) + 1);\n\t}\n\n\treturn 0;\n}\n",
    "target": 0,
    "idx": 2033556
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "int\nmrb_format_float(mrb_float f, char *buf, size_t buf_size, char fmt, int prec, char sign) {\n  char *s = buf;\n  int buf_remaining = buf_size - 1;\n  int alt_form = 0;\n\n  if ((uint8_t)fmt & 0x80) {\n    fmt &= 0x7f;  /* turn off alt_form flag */\n    alt_form = 1;\n  }\n  if (buf_size <= FLT_MIN_BUF_SIZE) {\n    // Smallest exp notion is -9e+99 (-9e+199) which is 6 (7) chars plus terminating\n    // null.\n\n    if (buf_size >= 2) {\n      *s++ = '?';\n    }\n    if (buf_size >= 1) {\n      *s++ = '\\0';\n    }\n    return buf_size >= 2;\n  }\n  if (signbit(f)) {\n    *s++ = '-';\n    f = -f;\n  } else if (sign) {\n    *s++ = sign;\n  }\n  buf_remaining -= (s - buf); // Adjust for sign\n\n  {\n    char uc = fmt & 0x20;\n    if (isinf(f)) {\n      *s++ = 'I' ^ uc;\n      *s++ = 'N' ^ uc;\n      *s++ = 'F' ^ uc;\n      goto ret;\n    } else if (isnan(f)) {\n      *s++ = 'N' ^ uc;\n      *s++ = 'A' ^ uc;\n      *s++ = 'N' ^ uc;\n    ret:\n      *s = '\\0';\n      return s - buf;\n    }\n  }\n\n  if (prec < 0) {\n    prec = 6;\n  }\n  char e_char = 'E' | (fmt & 0x20);   // e_char will match case of fmt\n  fmt |= 0x20; // Force fmt to be lowercase\n  char org_fmt = fmt;\n  if (fmt == 'g' && prec == 0) {\n    prec = 1;\n  }\n  int e, e1;\n  int dec = 0;\n  char e_sign = '\\0';\n  int num_digits = 0;\n  const mrb_float *pos_pow = g_pos_pow;\n  const mrb_float *neg_pow = g_neg_pow;\n\n  if (f == 0.0) {\n    e = 0;\n    if (fmt == 'e') {\n      e_sign = '+';\n    } else if (fmt == 'f') {\n      num_digits = prec + 1;\n    }\n  } else if (f < 1.0) { // f < 1.0\n    char first_dig = '0';\n    if (f >= FLT_ROUND_TO_ONE) {\n      first_dig = '1';\n    }\n\n    // Build negative exponent\n    for (e = 0, e1 = FLT_DECEXP; e1; e1 >>= 1, pos_pow++, neg_pow++) {\n      if (*neg_pow > f) {\n        e += e1;\n        f *= *pos_pow;\n      }\n    }\n    char e_sign_char = '-';\n    if (f < 1.0) {\n      if (f >= FLT_ROUND_TO_ONE) {\n        f = 1.0;\n        if (e == 0) {\n          e_sign_char = '+';\n        }\n      } else {\n        e++;\n        f *= 10.0;\n      }\n    }\n\n    // If the user specified 'g' format, and e is <= 4, then we'll switch\n    // to the fixed format ('f')\n\n    if (fmt == 'f' || (fmt == 'g' && e <= 4)) {\n      fmt = 'f';\n      dec = -1;\n      *s++ = first_dig;\n\n      if (org_fmt == 'g') {\n        prec += (e - 1);\n      }\n      // truncate precision to prevent buffer overflow\n      if (prec + 2 > buf_remaining) {\n        prec = buf_remaining - 2;\n      }\n      num_digits = prec;\n      if (num_digits || alt_form) {\n        *s++ = '.';\n        while (--e && num_digits) {\n          *s++ = '0';\n          num_digits--;\n        }\n      }\n    } else {\n      // For e & g formats, we'll be printing the exponent, so set the\n      // sign.\n      e_sign = e_sign_char;\n      dec = 0;\n\n      if (prec > (buf_remaining - FLT_MIN_BUF_SIZE)) {\n        prec = buf_remaining - FLT_MIN_BUF_SIZE;\n        if (fmt == 'g') {\n          prec++;\n        }\n      }\n    }\n  } else {\n    // Build positive exponent\n    for (e = 0, e1 = FLT_DECEXP; e1; e1 >>= 1, pos_pow++, neg_pow++) {\n      if (*pos_pow <= f) {\n        e += e1;\n        f *= *neg_pow;\n      }\n    }\n\n    // If the user specified fixed format (fmt == 'f') and e makes the\n    // number too big to fit into the available buffer, then we'll\n    // switch to the 'e' format.\n\n    if (fmt == 'f') {\n      if (e >= buf_remaining) {\n        fmt = 'e';\n      } else if ((e + prec + 2) > buf_remaining) {\n        prec = buf_remaining - e - 2;\n        if (prec < 0) {\n          // This means no decimal point, so we can add one back\n          // for the decimal.\n          prec++;\n        }\n      }\n    }\n    if (fmt == 'e' && prec > (buf_remaining - 6)) {\n      prec = buf_remaining - 6;\n    }\n    // If the user specified 'g' format, and e is < prec, then we'll switch\n    // to the fixed format.\n\n    if (fmt == 'g' && e < prec) {\n      fmt = 'f';\n      prec -= (e + 1);\n    }\n    if (fmt == 'f') {\n      dec = e;\n      num_digits = prec + e + 1;\n    } else {\n      e_sign = '+';\n    }\n  }\n  if (prec < 0) {\n    // This can happen when the prec is trimmed to prevent buffer overflow\n    prec = 0;\n  }\n\n  // We now have f as a floating point number between >= 1 and < 10\n  // (or equal to zero), and e contains the absolute value of the power of\n  // 10 exponent. and (dec + 1) == the number of dgits before the decimal.\n\n  // For e, prec is # digits after the decimal\n  // For f, prec is # digits after the decimal\n  // For g, prec is the max number of significant digits\n  //\n  // For e & g there will be a single digit before the decimal\n  // for f there will be e digits before the decimal\n\n  if (fmt == 'e') {\n    num_digits = prec + 1;\n  } else if (fmt == 'g') {\n    if (prec == 0) {\n      prec = 1;\n    }\n    num_digits = prec;\n  }\n\n  // Print the digits of the mantissa\n  for (int i = 0; i < num_digits; ++i, --dec) {\n    int8_t d = f;\n    *s++ = '0' + d;\n    if (dec == 0 && (prec > 0 || alt_form)) {\n      *s++ = '.';\n    }\n    f -= (mrb_float)d;\n    f *= 10.0;\n  }\n\n  // Round\n  if (f >= 5.0) {\n    char *rs = s;\n    rs--;\n    while (1) {\n      if (*rs == '.') {\n        rs--;\n        continue;\n      }\n      if (*rs < '0' || *rs > '9') {\n        // + or -\n        rs++; // So we sit on the digit to the right of the sign\n        break;\n      }\n      if (*rs < '9') {\n        (*rs)++;\n        break;\n      }\n      *rs = '0';\n      if (rs == buf) {\n        break;\n      }\n      rs--;\n    }\n    if (*rs == '0') {\n      // We need to insert a 1\n      if (rs[1] == '.' && fmt != 'f') {\n        // We're going to round 9.99 to 10.00\n        // Move the decimal point\n        rs[0] = '.';\n        rs[1] = '0';\n        if (e_sign == '-') {\n          e--;\n        } else {\n          e++;\n        }\n      }\n      s++;\n      char *ss = s;\n      while (ss > rs) {\n        *ss = ss[-1];\n        ss--;\n      }\n      *rs = '1';\n      if (f < 1.0 && fmt == 'f') {\n        // We rounded up to 1.0\n        prec--;\n      }\n    }\n  }\n\n  if (org_fmt == 'g' && prec > 0 && !alt_form) {\n    // Remove trailing zeros and a trailing decimal point\n    while (s[-1] == '0') {\n      s--;\n    }\n    if (s[-1] == '.') {\n      s--;\n    }\n  }\n  // Append the exponent\n  if (e_sign) {\n    *s++ = e_char;\n    *s++ = e_sign;\n    if (e >= 100) {\n      *s++ = '0' + (e / 100);\n      e %= 100;\n    }\n    *s++ = '0' + (e / 10);\n    *s++ = '0' + (e % 10);\n  }\n  *s = '\\0';\n\n  return s - buf;\n}\n",
    "target": 0,
    "idx": 2034652
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "static int piv_generate_key(sc_card_t *card,\n\t\tsc_cardctl_piv_genkey_info_t *keydata)\n{\n\tint r;\n\tu8 rbuf[4096];\n\tu8 *p;\n\tconst u8 *tag;\n\tu8 tagbuf[16];\n\tu8 outdata[3]; /* we could also add tag 81 for exponent */\n\tsize_t taglen, i;\n\tsize_t out_len;\n\tsize_t in_len;\n\tunsigned int cla_out, tag_out;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\tkeydata->exponent = 0;\n\tkeydata->pubkey = NULL;\n\tkeydata->pubkey_len = 0;\n\tkeydata->ecparam = NULL; /* will show size as we only support 2 curves */\n\tkeydata->ecparam_len = 0;\n\tkeydata->ecpoint = NULL;\n\tkeydata->ecpoint_len = 0;\n\n\tout_len = 3;\n\toutdata[0] = 0x80;\n\toutdata[1] = 0x01;\n\toutdata[2] = keydata->key_algid;\n\tswitch (keydata->key_algid) {\n\t\tcase 0x05: keydata->key_bits = 3072; break;\n\t\tcase 0x06: keydata->key_bits = 1024; break;\n\t\tcase 0x07: keydata->key_bits = 2048; break;\n\t\t/* TODO: - DEE For EC, also set the curve parameter as the OID */\n\t\tcase 0x11: keydata->key_bits = 0;\n\t\t\tkeydata->ecparam =0; /* we only support prime256v1 for 11 */\n\t\t\tkeydata->ecparam_len =0;\n\t\t\tbreak;\n\t\tcase 0x14: keydata->key_bits = 0;\n\t\t\tkeydata->ecparam = 0; /* we only support secp384r1 */\n\t\t\tkeydata->ecparam_len = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_ARGUMENTS);\n\t}\n\n\tp = tagbuf;\n\n\tr = sc_asn1_put_tag(0xAC, outdata, out_len, tagbuf, sizeof(tagbuf), &p);\n\tif (r != SC_SUCCESS) {\n\t\tsc_log(card->ctx, \"Failed to encode ASN1 tag\");\n\t\tgoto err;\n\t}\n\n\tr = piv_general_io(card, 0x47, 0x00, keydata->key_num,\n\t\t\ttagbuf, p - tagbuf, rbuf, sizeof rbuf);\n\n\tif (r >= 0) {\n\t\tconst u8 *cp;\n\t\tkeydata->exponent = 0;\n\n\t\tcp = rbuf;\n\t\tin_len = r;\n\n\t\t/* expected tag is 0x7f49,returned as cla_out == 0x60 and tag_out = 0x1F49 */\n\t\tr = sc_asn1_read_tag(&cp, in_len, &cla_out, &tag_out, &in_len);\n\t\tif (cp == NULL || in_len == 0 || cla_out != 0x60 || tag_out != 0x1f49) {\n\t\t\tr = SC_ERROR_ASN1_OBJECT_NOT_FOUND;\n\t\t}\n\t\tif (r != SC_SUCCESS) {\n\t\t\tsc_log(card->ctx, \"Tag buffer not found\");\n\t\t\tgoto err;\n\t\t}\n\n\t\t/* if RSA vs EC */\n\t\tif (keydata->key_bits > 0 ) {\n\t\t\ttag = sc_asn1_find_tag(card->ctx, cp, in_len, 0x82, &taglen);\n\t\t\tif (tag != NULL && taglen <= 4) {\n\t\t\t\tkeydata->exponent = 0;\n\t\t\t\tfor (i = 0; i < taglen;i++)\n\t\t\t\t\tkeydata->exponent = (keydata->exponent<<8) + tag[i];\n\t\t\t}\n\n\t\t\ttag = sc_asn1_find_tag(card->ctx, cp, in_len, 0x81, &taglen);\n\t\t\tif (tag != NULL && taglen > 0) {\n\t\t\t\tkeydata->pubkey = malloc(taglen);\n\t\t\t\tif (keydata->pubkey == NULL)\n\t\t\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t\t\t\tkeydata->pubkey_len = taglen;\n\t\t\t\tmemcpy (keydata->pubkey, tag, taglen);\n\t\t\t}\n\t\t}\n\t\telse { /* must be EC */\n\t\t\ttag = sc_asn1_find_tag(card->ctx, cp, in_len, 0x86, &taglen);\n\t\t\tif (tag != NULL && taglen > 0) {\n\t\t\t\tkeydata->ecpoint = malloc(taglen);\n\t\t\t\tif (keydata->ecpoint == NULL)\n\t\t\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t\t\t\tkeydata->ecpoint_len = taglen;\n\t\t\t\tmemcpy (keydata->ecpoint, tag, taglen);\n\t\t\t}\n\t\t}\n\n\t\t/* TODO: -DEE Could add key to cache so could use engine to generate key,\n\t\t * and sign req in single operation */\n\t\tr = 0;\n\t}\n\nerr:\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\nstatic int piv_general_mutual_authenticate(sc_card_t *card,\n\tunsigned int key_ref, unsigned int alg_id)\n{\n\tint r;\n#ifdef ENABLE_OPENSSL\n\tint N;\n\tint locked = 0;\n\tu8 rbuf[4096];\n\tu8 *nonce = NULL;\n\tsize_t nonce_len;\n\tu8 *p;\n\tu8 *key = NULL;\n\tsize_t keylen;\n\tu8 *plain_text = NULL;\n\tsize_t plain_text_len = 0;\n\tu8 *tmp;\n\tsize_t tmplen, tmplen2;\n\tu8 *built = NULL;\n\tsize_t built_len;\n\tconst u8 *body = NULL;\n\tsize_t body_len;\n\tconst u8 *witness_data = NULL;\n\tsize_t witness_len;\n\tconst u8 *challenge_response = NULL;\n\tsize_t challenge_response_len;\n\tu8 *decrypted_reponse = NULL;\n\tsize_t decrypted_reponse_len;\n\tEVP_CIPHER_CTX * ctx = NULL;\n\n\tu8 sbuf[255];\n\tconst EVP_CIPHER *cipher;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\tctx = EVP_CIPHER_CTX_new();\n\tif (ctx == NULL) {\n\t\tr = SC_ERROR_OUT_OF_MEMORY;\n\t\tgoto err;\n\t}\n\n\tcipher = get_cipher_for_algo(alg_id);\n\tif(!cipher) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"Invalid cipher selector, none found for:  %02x\\n\", alg_id);\n\t\tr = SC_ERROR_INVALID_ARGUMENTS;\n\t\tgoto err;\n\t}\n\n\tr = piv_get_key(card, alg_id, &key, &keylen);\n\tif (r) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"Error getting General Auth key\\n\");\n\t\tgoto err;\n\t}\n\n\tr = sc_lock(card);\n\tif (r != SC_SUCCESS) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"sc_lock failed\\n\");\n\t\tgoto err; /* cleanup */\n\t}\n\tlocked = 1;\n\n\tp = sbuf;\n\t*p++ = 0x7C;\n\t*p++ = 0x02;\n\t*p++ = 0x80;\n\t*p++ = 0x00;\n\n\t/* get the encrypted nonce */\n\tr = piv_general_io(card, 0x87, alg_id, key_ref, sbuf, p - sbuf, rbuf, sizeof rbuf);\n\n\tif (r < 0) goto err;\n\n\t/* Remove the encompassing outer TLV of 0x7C and get the data */\n\tbody = sc_asn1_find_tag(card->ctx, rbuf,\n\t\tr, 0x7C, &body_len);\n\tif (!body || rbuf[0] != 0x7C) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"Invalid Witness Data response of NULL\\n\");\n\t\tr =  SC_ERROR_INVALID_DATA;\n\t\tgoto err;\n\t}\n\n\t/* Get the witness data indicated by the TAG 0x80 */\n\twitness_data = sc_asn1_find_tag(card->ctx, body,\n\t\tbody_len, 0x80, &witness_len);\n\tif (!witness_len) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"Invalid Challenge Data none found in TLV\\n\");\n\t\tr =  SC_ERROR_INVALID_DATA;\n\t\tgoto err;\n\t}\n\n\t/* Allocate an output buffer for openssl */\n\tplain_text = malloc(witness_len);\n\tif (!plain_text) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"Could not allocate buffer for plain text\\n\");\n\t\tr = SC_ERROR_INTERNAL;\n\t\tgoto err;\n\t}\n\n\t/* decrypt the data from the card */\n\tif (!EVP_DecryptInit(ctx, cipher, key, NULL)) {\n\t\t/* may fail if des parity of key is wrong. depends on OpenSSL options */\n\t\tr = SC_ERROR_INTERNAL;\n\t\tgoto err;\n\t}\n\tEVP_CIPHER_CTX_set_padding(ctx,0);\n\n\tp = plain_text;\n\tif (!EVP_DecryptUpdate(ctx, p, &N, witness_data, witness_len)) {\n\t\tr = SC_ERROR_INTERNAL;\n\t\tgoto err;\n\t}\n\tplain_text_len = tmplen = N;\n\tp += tmplen;\n\n\tif(!EVP_DecryptFinal(ctx, p, &N)) {\n\t\tr = SC_ERROR_INTERNAL;\n\t\tgoto err;\n\t}\n\ttmplen = N;\n\tplain_text_len += tmplen;\n\n\tif (plain_text_len != witness_len) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t \"Encrypted and decrypted lengths do not match: %\"SC_FORMAT_LEN_SIZE_T\"u:%\"SC_FORMAT_LEN_SIZE_T\"u\\n\",\n\t\t\t witness_len, plain_text_len);\n\t\tr = SC_ERROR_INTERNAL;\n\t\tgoto err;\n\t}\n\n\t/* Build a response to the card of:\n\t * [GEN AUTH][ 80<decrypted witness>81 <challenge> ]\n\t * Start by computing the nonce for <challenge> the\n\t * nonce length should match the witness length of\n\t * the card.\n\t */\n\tnonce = malloc(witness_len);\n\tif(!nonce) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t \"OOM allocating nonce (%\"SC_FORMAT_LEN_SIZE_T\"u : %\"SC_FORMAT_LEN_SIZE_T\"u)\\n\",\n\t\t\t witness_len, plain_text_len);\n\t\tr = SC_ERROR_INTERNAL;\n\t\tgoto err;\n\t}\n\tnonce_len = witness_len;\n\n\tr = RAND_bytes(nonce, witness_len);\n\tif(!r) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t \"Generating random for nonce (%\"SC_FORMAT_LEN_SIZE_T\"u : %\"SC_FORMAT_LEN_SIZE_T\"u)\\n\",\n\t\t\t witness_len, plain_text_len);\n\t\tr = SC_ERROR_INTERNAL;\n\t\tgoto err;\n\t}\n\n\t/* nonce for challenge */\n\tr = sc_asn1_put_tag(0x81, NULL, witness_len, NULL, 0, NULL);\n\tif (r <= 0) {\n\t\tr = SC_ERROR_INTERNAL;\n\t\tgoto err;\n\t}\n\ttmplen = r;\n\n\t/* plain text witness keep a length separate for the 0x7C tag */\n\tr = sc_asn1_put_tag(0x80, NULL, witness_len, NULL, 0, NULL);\n\tif (r <= 0) {\n\t\tr = SC_ERROR_INTERNAL;\n\t\tgoto err;\n\t}\n\ttmplen += r;\n\ttmplen2 = tmplen;\n\n\t/* outside 7C tag with 81:80 as innards */\n\tr = sc_asn1_put_tag(0x7C, NULL, tmplen, NULL, 0, NULL);\n\tif (r <= 0) {\n\t\tr = SC_ERROR_INTERNAL;\n\t\tgoto err;\n\t}\n\n\tbuilt_len = r;\n\n\t/* Build the response buffer */\n\tp = built = malloc(built_len);\n\tif(!built) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"OOM Building witness response and challenge\\n\");\n\t\tr = SC_ERROR_INTERNAL;\n\t\tgoto err;\n\t}\n\n\tp = built;\n\n\t/* Start with the 7C Tag */\n\tr = sc_asn1_put_tag(0x7C, NULL, tmplen2, p, built_len, &p);\n\tif (r != SC_SUCCESS) {\n\t\tgoto err;\n\t}\n\n\t/* Add the DECRYPTED witness, tag 0x80 */\n\tr = sc_asn1_put_tag(0x80, plain_text, witness_len, p, built_len - (p - built), &p);\n\tif (r != SC_SUCCESS) {\n\t\tgoto err;\n\t}\n\n\t/* Add the challenge, tag 0x81 */\n\tr = sc_asn1_put_tag(0x81, nonce, witness_len, p, built_len - (p - built), &p);\n\tif (r != SC_SUCCESS) {\n\t\tgoto err;\n\t}\n\n\t/* Send constructed data */\n\tr = piv_general_io(card, 0x87, alg_id, key_ref, built, built_len, rbuf, sizeof rbuf);\n\tif (r < 0) {\n\t\tgoto err;\n\t}\n\n\t/* Remove the encompassing outer TLV of 0x7C and get the data */\n\tbody = sc_asn1_find_tag(card->ctx, rbuf,\n\t\tr, 0x7C, &body_len);\n\tif(!body || rbuf[0] != 0x7C) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"Could not find outer tag 0x7C in response\");\n\t\tr =  SC_ERROR_INVALID_DATA;\n\t\tgoto err;\n\t}\n\n\t/* SP800-73 not clear if  80 or 82 */\n\tchallenge_response = sc_asn1_find_tag(card->ctx, body,\n\t\tbody_len, 0x82, &challenge_response_len);\n\tif(!challenge_response) {\n\t\tchallenge_response = sc_asn1_find_tag(card->ctx, body,\n\t\t\t\tbody_len, 0x80, &challenge_response_len);\n\t\tif(!challenge_response) {\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"Could not find tag 0x82 or 0x80 in response\");\n\t\t\tr =  SC_ERROR_INVALID_DATA;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\t/* Decrypt challenge and check against nonce */\n\tdecrypted_reponse = malloc(challenge_response_len);\n\tif(!decrypted_reponse) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"OOM Allocating decryption buffer\");\n\t\tr =  SC_ERROR_INVALID_DATA;\n\t\tgoto err;\n\t}\n\n\tEVP_CIPHER_CTX_cleanup(ctx);\n\n\tif (!EVP_DecryptInit(ctx, cipher, key, NULL)) {\n\t\tr = SC_ERROR_INTERNAL;\n\t\tgoto err;\n\t}\n\tEVP_CIPHER_CTX_set_padding(ctx,0);\n\n\ttmp = decrypted_reponse;\n\tif (!EVP_DecryptUpdate(ctx, tmp, &N, challenge_response, challenge_response_len)) {\n\t\tr = SC_ERROR_INTERNAL;\n\t\tgoto err;\n\t}\n\tdecrypted_reponse_len = tmplen = N;\n\ttmp += tmplen;\n\n\tif(!EVP_DecryptFinal(ctx, tmp, &N)) {\n\t\tr = SC_ERROR_INTERNAL;\n\t\tgoto err;\n\t}\n\ttmplen = N;\n\tdecrypted_reponse_len += tmplen;\n\n\tif (decrypted_reponse_len != nonce_len || memcmp(nonce, decrypted_reponse, nonce_len) != 0) {\n\t\tsc_log(card->ctx,\n\t\t       \"mutual authentication failed, card returned wrong value %\"SC_FORMAT_LEN_SIZE_T\"u:%\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t       decrypted_reponse_len, nonce_len);\n\t\tr = SC_ERROR_DECRYPT_FAILED;\n\t\tgoto err;\n\t}\n\tr = SC_SUCCESS;\n\nerr:\n\tif (ctx)\n\t\tEVP_CIPHER_CTX_free(ctx);\n\tif (locked)\n\t\tsc_unlock(card);\n\tif (decrypted_reponse)\n\t\tfree(decrypted_reponse);\n\tif (built)\n\t\tfree(built);\n\tif (plain_text)\n\t\tfree(plain_text);\n\tif (nonce)\n\t\tfree(nonce);\n\tif (key)\n\t\tfree(key);\n\n#else\n\tsc_log(card->ctx, \"OpenSSL Required\");\n\tr = SC_ERROR_NOT_SUPPORTED;\n#endif /* ENABLE_OPENSSL */\n\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\nstatic int piv_general_external_authenticate(sc_card_t *card,\n\t\tunsigned int key_ref, unsigned int alg_id)\n{\n\tint r;\n#ifdef ENABLE_OPENSSL\n\tint tmplen;\n\tint outlen;\n\tint locked = 0;\n\tu8 *p;\n\tu8 rbuf[4096];\n\tu8 *key = NULL;\n\tu8 *cypher_text = NULL;\n\tu8 *output_buf = NULL;\n\tconst u8 *body = NULL;\n\tconst u8 *challenge_data = NULL;\n\tsize_t body_len;\n\tsize_t output_len;\n\tsize_t challenge_len;\n\tsize_t keylen = 0;\n\tsize_t cypher_text_len = 0;\n\tu8 sbuf[255];\n\tEVP_CIPHER_CTX * ctx = NULL;\n\tconst EVP_CIPHER *cipher;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\tctx = EVP_CIPHER_CTX_new();\n\tif (ctx == NULL) {\n\t    r = SC_ERROR_OUT_OF_MEMORY;\n\t    goto err;\n\t}\n\n\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"Selected cipher for algorithm id: %02x\\n\", alg_id);\n\n\tcipher = get_cipher_for_algo(alg_id);\n\tif(!cipher) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"Invalid cipher selector, none found for:  %02x\\n\", alg_id);\n\t\tr = SC_ERROR_INVALID_ARGUMENTS;\n\t\tgoto err;\n\t}\n\n\tr = piv_get_key(card, alg_id, &key, &keylen);\n\tif (r) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"Error getting General Auth key\\n\");\n\t\tgoto err;\n\t}\n\n\tr = sc_lock(card);\n\tif (r != SC_SUCCESS) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"sc_lock failed\\n\");\n\t\tgoto err; /* cleanup */\n\t}\n\tlocked = 1;\n\n\tp = sbuf;\n\t*p++ = 0x7C;\n\t*p++ = 0x02;\n\t*p++ = 0x81;\n\t*p++ = 0x00;\n\n\t/* get a challenge */\n\tr = piv_general_io(card, 0x87, alg_id, key_ref, sbuf, p - sbuf, rbuf, sizeof rbuf);\n\tif (r < 0) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"Error getting Challenge\\n\");\n\t\tgoto err;\n\t}\n\n\t/*\n\t * the value here corresponds with the response size, so we use this\n\t * to alloc the response buffer, rather than re-computing it.\n\t */\n\toutput_len = r;\n\n\t/* Remove the encompassing outer TLV of 0x7C and get the data */\n\tbody = sc_asn1_find_tag(card->ctx, rbuf,\n\t\tr, 0x7C, &body_len);\n\tif (!body || rbuf[0] != 0x7C) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"Invalid Challenge Data response of NULL\\n\");\n\t\tr =  SC_ERROR_INVALID_DATA;\n\t\tgoto err;\n\t}\n\n\t/* Get the challenge data indicated by the TAG 0x81 */\n\tchallenge_data = sc_asn1_find_tag(card->ctx, body,\n\t\tbody_len, 0x81, &challenge_len);\n\tif (!challenge_data) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"Invalid Challenge Data none found in TLV\\n\");\n\t\tr =  SC_ERROR_INVALID_DATA;\n\t\tgoto err;\n\t}\n\n\t/* Store this to sanity check that plaintext length and cyphertext lengths match */\n\t/* TODO is this required */\n\ttmplen = challenge_len;\n\n\t/* Encrypt the challenge with the secret */\n\tif (!EVP_EncryptInit(ctx, cipher, key, NULL)) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"Encrypt fail\\n\");\n\t\tr = SC_ERROR_INTERNAL;\n\t\tgoto err;\n\t}\n\n\tcypher_text = malloc(challenge_len);\n\tif (!cypher_text) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"Could not allocate buffer for cipher text\\n\");\n\t\tr = SC_ERROR_INTERNAL;\n\t\tgoto err;\n\t}\n\n\tEVP_CIPHER_CTX_set_padding(ctx,0);\n\tif (!EVP_EncryptUpdate(ctx, cypher_text, &outlen, challenge_data, challenge_len)) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"Encrypt update fail\\n\");\n\t\tr = SC_ERROR_INTERNAL;\n\t\tgoto err;\n\t}\n\tcypher_text_len += outlen;\n\n\tif (!EVP_EncryptFinal(ctx, cypher_text + cypher_text_len, &outlen)) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"Final fail\\n\");\n\t\tr = SC_ERROR_INTERNAL;\n\t\tgoto err;\n\t}\n\tcypher_text_len += outlen;\n\n\t/*\n\t * Actually perform the sanity check on lengths plaintext length vs\n\t * encrypted length\n\t */\n\tif (cypher_text_len != (size_t)tmplen) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"Length test fail\\n\");\n\t\tr = SC_ERROR_INTERNAL;\n\t\tgoto err;\n\t}\n\n\toutput_buf = malloc(output_len);\n\tif(!output_buf) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"Could not allocate output buffer: %s\\n\",\n\t\t\t\tstrerror(errno));\n\t\tr = SC_ERROR_INTERNAL;\n\t\tgoto err;\n\t}\n\n\tp = output_buf;\n\n\t/*\n\t * Build: 7C<len>[82<len><challenge>]\n\t * Start off by capturing the data of the response:\n\t *     - 82<len><encrypted challenege response>\n\t * Build the outside TLV (7C)\n\t * Advance past that tag + len\n\t * Build the body (82)\n\t * memcopy the body past the 7C<len> portion\n\t * Transmit\n\t */\n\ttmplen = sc_asn1_put_tag(0x82, NULL, cypher_text_len, NULL, 0, NULL);\n\tif (tmplen <= 0) {\n\t\tr = SC_ERROR_INTERNAL;\n\t\tgoto err;\n\t}\n\n\tr = sc_asn1_put_tag(0x7C, NULL, tmplen, p, output_len, &p);\n\tif (r != SC_SUCCESS) {\n\t\tgoto err;\n\t}\n\n\t/* Build the 0x82 TLV and append to the 7C<len> tag */\n\tr = sc_asn1_put_tag(0x82, cypher_text, cypher_text_len, p, output_len - (p - output_buf), &p);\n\tif (r != SC_SUCCESS) {\n\t\tgoto err;\n\t}\n\n\t/* Sanity check the lengths again */\n\ttmplen = sc_asn1_put_tag(0x7C, NULL, tmplen, NULL, 0, NULL)\n\t\t+ sc_asn1_put_tag(0x82, NULL, cypher_text_len, NULL, 0, NULL);\n\tif (output_len != (size_t)tmplen) {\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"Allocated and computed lengths do not match! \"\n\t\t\t \"Expected %\"SC_FORMAT_LEN_SIZE_T\"d, found: %d\\n\", output_len, tmplen);\n\t\tr = SC_ERROR_INTERNAL;\n\t\tgoto err;\n\t}\n\n\tr = piv_general_io(card, 0x87, alg_id, key_ref, output_buf, output_len, NULL, 0);\n\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE, \"Got response  challenge\\n\");\n\nerr:\n\tif (ctx)\n\t\tEVP_CIPHER_CTX_free(ctx);\n\n\tif (locked)\n\t\tsc_unlock(card);\n\n\tif (key) {\n\t\tsc_mem_clear(key, keylen);\n\t\tfree(key);\n\t}\n\n\tif (cypher_text)\n\t\tfree(cypher_text);\n\n\tif (output_buf)\n\t\tfree(output_buf);\n#else\n\tsc_log(card->ctx, \"OpenSSL Required\");\n\tr = SC_ERROR_NOT_SUPPORTED;\n#endif /* ENABLE_OPENSSL */\n\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\nstatic int\npiv_get_serial_nr_from_CHUI(sc_card_t* card, sc_serial_number_t* serial)\n{\n\tint r;\n\tint i;\n\tu8 gbits;\n\tu8 *rbuf = NULL;\n\tconst u8 *body;\n\tconst u8 *fascn;\n\tconst u8 *guid;\n\tsize_t rbuflen = 0, bodylen, fascnlen, guidlen;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\tif (card->serialnr.len)   {\n\t\t*serial = card->serialnr;\n\t\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n\t}\n\n\t/*\n\t * 800-73-3 Part 1 and CIO Council docs say for PIV Compatible cards\n\t * the FASC-N Agency code should be 9999 and there should be a GUID\n\t * based on RFC 4122. If GUID present and not zero\n\t * we will use the GUID as the serial number.\n\t */\n\n\tr = piv_get_cached_data(card, PIV_OBJ_CHUI, &rbuf, &rbuflen);\n\tLOG_TEST_RET(card->ctx, r, \"Failure retrieving CHUI\");\n\n\tr = SC_ERROR_INTERNAL;\n\tif (rbuflen != 0) {\n\t\tbody = sc_asn1_find_tag(card->ctx, rbuf, rbuflen, 0x53, &bodylen); /* Pass the outer wrapper asn1 */\n\t\tif (body != NULL && bodylen != 0 && rbuf[0] == 0x53) {\n\t\t\tfascn = sc_asn1_find_tag(card->ctx, body, bodylen, 0x30, &fascnlen); /* Find the FASC-N data */\n\t\t\tguid = sc_asn1_find_tag(card->ctx, body, bodylen, 0x34, &guidlen);\n\n\t\t\tgbits = 0; /* if guid is valid, gbits will not be zero */\n\t\t\tif (guid && guidlen == 16) {\n\t\t\t\tfor (i = 0; i < 16; i++) {\n\t\t\t\t\tgbits = gbits | guid[i]; /* if all are zero, gbits will be zero */\n\t\t\t\t}\n\t\t\t}\n\t\t\tsc_log(card->ctx,\n\t\t\t       \"fascn=%p,fascnlen=%\"SC_FORMAT_LEN_SIZE_T\"u,guid=%p,guidlen=%\"SC_FORMAT_LEN_SIZE_T\"u,gbits=%2.2x\",\n\t\t\t       fascn, fascnlen, guid, guidlen, gbits);\n\n\t\t\tif (fascn && fascnlen == 25) {\n\t\t\t\t/* test if guid and the fascn starts with ;9999 (in ISO 4bit + parity code) */\n\t\t\t\tif (!(gbits && fascn[0] == 0xD4 && fascn[1] == 0xE7\n\t\t\t\t\t\t    && fascn[2] == 0x39 && (fascn[3] | 0x7F) == 0xFF)) {\n\t\t\t\t\t/* fascnlen is 25 */\n\t\t\t\t\tserial->len = fascnlen;\n\t\t\t\t\tmemcpy (serial->value, fascn, serial->len);\n\t\t\t\t\tr = SC_SUCCESS;\n\t\t\t\t\tgbits = 0; /* set to skip using guid below */\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (guid && gbits) {\n\t\t\t\t/* guidlen is 16 */\n\t\t\t\tserial->len = guidlen;\n\t\t\t\tmemcpy (serial->value, guid, serial->len);\n\t\t\t\tr = SC_SUCCESS;\n\t\t\t}\n\t\t}\n\t}\n\n\tcard->serialnr = *serial;\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\nstatic int piv_validate_general_authentication(sc_card_t *card,\n\t\t\t\t\tconst u8 * data, size_t datalen,\n\t\t\t\t\tu8 * out, size_t outlen)\n{\n\tpiv_private_data_t * priv = PIV_DATA(card);\n\tint r, tmplen, tmplen2;\n\tu8 *p;\n\tconst unsigned char *p2;\n\tsize_t taglen;\n\tsize_t bodylen;\n\tunsigned int cla, tag;\n\tunsigned int real_alg_id, op_tag;\n\n\tu8 sbuf[4096]; /* needs work. for 3072 keys, needs 384+10 or so */\n\tsize_t sbuflen = sizeof(sbuf);\n\tu8 rbuf[4096];\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\t/* should assume large send data */\n\tp = sbuf;\n\ttmplen = sc_asn1_put_tag(0xff, NULL, datalen, NULL, 0, NULL);\n\ttmplen2 = sc_asn1_put_tag(0x82, NULL, 0, NULL, 0, NULL);\n\tif (tmplen <= 0 || tmplen2 <= 0) {\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INTERNAL);\n\t}\n\ttmplen += tmplen2;\n\tif ((r = sc_asn1_put_tag(0x7c, NULL, tmplen, p, sbuflen, &p)) != SC_SUCCESS ||\n\t    (r = sc_asn1_put_tag(0x82, NULL, 0, p, sbuflen - (p - sbuf), &p)) != SC_SUCCESS) {\n\t\tLOG_FUNC_RETURN(card->ctx, r);\n\t}\n\tif (priv->operation == SC_SEC_OPERATION_DERIVE\n\t\t\t&& priv->algorithm == SC_ALGORITHM_EC) {\n\t\top_tag = 0x85;\n\t} else {\n\t\top_tag = 0x81;\n\t}\n\tr = sc_asn1_put_tag(op_tag, data, datalen, p, sbuflen - (p - sbuf), &p);\n\tif (r != SC_SUCCESS) {\n\t\tLOG_FUNC_RETURN(card->ctx, r);\n\t}\n\n\t/*\n\t * alg_id=06 is a place holder for all RSA keys.\n\t * Derive the real alg_id based on the size of the\n\t * the data, as we are always using raw mode.\n\t * Non RSA keys needs some work in this area.\n\t */\n\n\treal_alg_id = priv->alg_id;\n\tif (priv->alg_id == 0x06) {\n\t\tswitch  (datalen) {\n\t\t\tcase 128: real_alg_id = 0x06; break;\n\t\t\tcase 256: real_alg_id = 0x07; break;\n\t\t\tcase 384: real_alg_id = 0x05; break;\n\t\t\tdefault:\n\t\t\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_NO_CARD_SUPPORT);\n\t\t}\n\t}\n\t/* EC alg_id was already set */\n\n\tr = piv_general_io(card, 0x87, real_alg_id, priv->key_ref,\n\t\t\tsbuf, p - sbuf, rbuf, sizeof rbuf);\n\tif (r < 0)\n\t\tgoto err;\n\n\tp2 = rbuf;\n\tr = sc_asn1_read_tag(&p2, r, &cla, &tag, &bodylen);\n\tif (p2 == NULL || r < 0 || bodylen == 0 || (cla|tag) != 0x7C) {\n\t\tLOG_TEST_GOTO_ERR(card->ctx, SC_ERROR_INVALID_DATA, \"Can't find 0x7C\");\n        }\n\n\tr = sc_asn1_read_tag(&p2, bodylen, &cla, &tag, &taglen);\n\tif (p2 == NULL || r < 0 || taglen == 0 || (cla|tag) != 0x82) {\n\t\tLOG_TEST_GOTO_ERR(card->ctx, SC_ERROR_INVALID_DATA, \"Can't find 0x82\");\n\t}\n\n\tif (taglen > outlen) {\n\t\tLOG_TEST_GOTO_ERR(card->ctx, SC_ERROR_INVALID_DATA, \"data read longer then buffer\");\n\t}\n\n\tmemcpy(out, p2, taglen);\n\tr = taglen;\n\nerr:\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\nstatic int\npiv_compute_signature(sc_card_t *card, const u8 * data, size_t datalen,\n\t\tu8 * out, size_t outlen)\n{\n\tpiv_private_data_t * priv = PIV_DATA(card);\n\tint r;\n\tint i;\n\tsize_t nLen;\n\tu8 rbuf[128]; /* For EC conversions  384 will fit */\n\tconst unsigned char *pseq, *pint, *ptemp, *pend;\n\tunsigned int cla, tag;\n\tsize_t seqlen;\n\tsize_t intlen;\n\tsize_t templen;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\t/* The PIV returns a DER SEQUENCE{INTEGER, INTEGER}\n\t * Which may have leading 00 to force a positive integer\n\t * But PKCS11 just wants 2* field_length in bytes\n\t * So we have to strip out the integers\n\t * and pad on left if too short.\n\t */\n\n\tif (priv->alg_id == 0x11 || priv->alg_id == 0x14 ) {\n\t\tnLen = (priv->key_size + 7) / 8;\n\t\tif (outlen < 2*nLen) {\n\t\t\tsc_log(card->ctx,\n\t\t\t       \" output too small for EC signature %\"SC_FORMAT_LEN_SIZE_T\"u < %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t\t       outlen, 2 * nLen);\n\t\t\tr = SC_ERROR_INVALID_DATA;\n\t\t\tgoto err;\n\t\t}\n\t\tmemset(out, 0, outlen);\n\n\t\tr = piv_validate_general_authentication(card, data, datalen, rbuf, sizeof rbuf);\n\t\tif (r < 0)\n\t\t\tgoto err;\n\n\t\tpseq = rbuf;\n\t\tr = sc_asn1_read_tag(&pseq, r, &cla, &tag, &seqlen);\n\t\tif (pseq == NULL || r < 0 || seqlen == 0 || (cla|tag) != 0x30)\n\t\t\tLOG_TEST_GOTO_ERR(card->ctx, SC_ERROR_INVALID_DATA, \"Can't find 0x30\");\n\n\t\tpint = pseq;\n\t\tpend = pseq + seqlen;\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tr = sc_asn1_read_tag(&pint, (pend - pint), &cla, &tag, &intlen);\n\t\t\tif (pint == NULL || r < 0 || intlen == 0 || (cla|tag) != 0x02)\n\t\t\t\tLOG_TEST_GOTO_ERR(card->ctx, SC_ERROR_INVALID_DATA, \"Can't find 0x02\");\n\t\t\tif (intlen > nLen + 1)\n\t\t\t\tLOG_TEST_GOTO_ERR(card->ctx, SC_ERROR_INVALID_DATA,\"Signature too long\");\n\n\t\t\tptemp = pint;\n\t\t\ttemplen = intlen;\n\t\t\tif (intlen > nLen) { /* drop leading 00 if present */\n\t\t\t\tif (*ptemp != 0x00) {\n\t\t\t\t\tLOG_TEST_GOTO_ERR(card->ctx, SC_ERROR_INVALID_DATA,\"Signature too long\");\n\t\t\t\t\tr = SC_ERROR_INVALID_DATA;\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tptemp++;\n\t\t\t\ttemplen--;\n\t\t\t}\n\t\t\tmemcpy(out + nLen*i + nLen - templen , ptemp, templen);\n\t\t\tpint += intlen; /* next integer */\n\t\t\t\n\t\t}\n\t\tr = 2 * nLen;\n\t} else { /* RSA is all set */\n\t\tr = piv_validate_general_authentication(card, data, datalen, out, outlen);\n\t}\n\nerr:\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);\n}\n",
    "target": 0,
    "idx": 2036200
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "static int MqttClient_WaitType(MqttClient *client, void *packet_obj,\n    byte wait_type, word16 wait_packet_id, int timeout_ms)\n{\n    int rc;\n    word16 packet_id;\n    MqttPacketType packet_type;\n#ifdef WOLFMQTT_MULTITHREAD\n    MqttPendResp *pendResp;\n    int readLocked;\n#endif\n    MqttMsgStat* mms_stat;\n    int waitMatchFound;\n\n    if (client == NULL || packet_obj == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    /* all packet type structures must have MqttMsgStat at top */\n    mms_stat = (MqttMsgStat*)packet_obj;\n\nwait_again:\n\n    /* initialize variables */\n    packet_id = 0;\n    packet_type = MQTT_PACKET_TYPE_RESERVED;\n#ifdef WOLFMQTT_MULTITHREAD\n    pendResp = NULL;\n    readLocked = 0;\n#endif\n    waitMatchFound = 0;\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"MqttClient_WaitType: Type %s (%d), ID %d\",\n        MqttPacket_TypeDesc((MqttPacketType)wait_type),\n            wait_type, wait_packet_id);\n#endif\n\n    switch ((int)*mms_stat)\n    {\n        case MQTT_MSG_BEGIN:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Lock recv socket mutex */\n            rc = wm_SemLock(&client->lockRecv);\n            if (rc != 0) {\n                PRINTF(\"MqttClient_WaitType: recv lock error!\");\n                return rc;\n            }\n            readLocked = 1;\n        #endif\n\n            /* reset the packet state */\n            client->packet.stat = MQTT_PK_BEGIN;\n        }\n        FALL_THROUGH;\n\n    #ifdef WOLFMQTT_V5\n        case MQTT_MSG_AUTH:\n    #endif\n        case MQTT_MSG_WAIT:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if packet type and id have already completed */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, (MqttPacketType)wait_type, \n                    wait_packet_id, &pendResp)) {\n                    if (pendResp->packetDone) {\n                        /* pending response is already done, so return */\n                        rc = pendResp->packet_ret;\n                    #ifdef WOLFMQTT_DEBUG_CLIENT\n                        PRINTF(\"PendResp already Done %p: Rc %d\", pendResp, rc);\n                    #endif\n                        MqttClient_RespList_Remove(client, pendResp);\n                        wm_SemUnlock(&client->lockClient);\n                        wm_SemUnlock(&client->lockRecv);\n                        return rc;\n                    }\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            *mms_stat = MQTT_MSG_WAIT;\n\n            /* Wait for packet */\n            rc = MqttPacket_Read(client, client->rx_buf, client->rx_buf_len,\n                    timeout_ms);\n            /* handle failure */\n            if (rc <= 0) {\n                break;\n            }\n\n            /* capture length read */\n            client->packet.buf_len = rc;\n\n            /* Decode Packet - get type and id */\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, NULL, &packet_type, NULL, &packet_id);\n            if (rc < 0) {\n                break;\n            }\n\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"Read Packet: Len %d, Type %d, ID %d\",\n                client->packet.buf_len, packet_type, packet_id);\n        #endif\n\n            *mms_stat = MQTT_MSG_READ;\n        }\n        FALL_THROUGH;\n\n        case MQTT_MSG_READ:\n        case MQTT_MSG_READ_PAYLOAD:\n        {\n            MqttPacketType use_packet_type;\n            void* use_packet_obj;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            readLocked = 1; /* if in this state read is locked */\n        #endif\n\n            /* read payload state only happens for publish messages */\n            if (*mms_stat == MQTT_MSG_READ_PAYLOAD) {\n                packet_type = MQTT_PACKET_TYPE_PUBLISH;\n            }\n\n            /* Determine if we received data for this request */\n            if ((wait_type == MQTT_PACKET_TYPE_ANY ||\n                 wait_type == packet_type ||\n                 (MqttIsPubRespPacket(packet_type) &&\n                  MqttIsPubRespPacket(wait_type))) &&\n                (wait_packet_id == 0 || wait_packet_id == packet_id))\n            {\n                use_packet_obj = packet_obj;\n                waitMatchFound = 1;\n            }\n            else {\n                /* use generic packet object */\n                use_packet_obj = &client->msg;\n            }\n            use_packet_type = packet_type;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if we have a pending response for this packet */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, packet_type, packet_id,\n                                                               &pendResp)) {\n                    /* we found packet match this incoming read packet */\n                    pendResp->packetProcessing = 1;\n                    use_packet_obj = pendResp->packet_obj;\n                    use_packet_type = pendResp->packet_type;\n                    /* req from another thread... not a match */\n                    waitMatchFound = 0;\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            /* Perform packet handling for publish callback and QoS */\n            rc = MqttClient_HandlePacket(client, use_packet_type,\n                use_packet_obj, timeout_ms);\n\n        #ifdef WOLFMQTT_NONBLOCK\n            if (rc == MQTT_CODE_CONTINUE) {\n                /* we have received some data, so keep the recv\n                    mutex lock active and return */\n                return rc;\n            }\n        #endif\n\n            /* handle success case */\n            if (rc >= 0) {\n                rc = MQTT_CODE_SUCCESS;\n            }\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (pendResp) {\n                /* Mark pending response entry done */\n                if (wm_SemLock(&client->lockClient) == 0) {\n                    pendResp->packetDone = 1;\n                    pendResp->packet_ret = rc;\n                #ifdef WOLFMQTT_DEBUG_CLIENT\n                    PRINTF(\"PendResp Done %p\", pendResp);\n                #endif\n                    pendResp = NULL;\n                    wm_SemUnlock(&client->lockClient);\n                }\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n            break;\n        }\n\n        case MQTT_MSG_WRITE:\n        case MQTT_MSG_WRITE_PAYLOAD:\n        default:\n        {\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"MqttClient_WaitType: Invalid state %d!\", *mms_stat);\n        #endif\n            rc = MQTT_CODE_ERROR_STAT;\n            break;\n        }\n    } /* switch (*mms_stat) */\n\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc != MQTT_CODE_CONTINUE)\n#endif\n    {\n        /* reset state */\n        *mms_stat = MQTT_MSG_BEGIN;\n    }\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (readLocked) {\n        wm_SemUnlock(&client->lockRecv);\n    }\n#endif\n    if (rc < 0) {\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_WaitType: Failure: %s (%d)\",\n            MqttClient_ReturnCodeToString(rc), rc);\n    #endif\n        return rc;\n    }\n\n    if (!waitMatchFound) {\n        /* if we get here, then the we are still waiting for a packet */\n        goto wait_again;\n    }\n\n    return rc;\n}\n",
    "target": 0,
    "idx": 2037866
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "static int MqttClient_WaitType(MqttClient *client, void *packet_obj,\n    byte wait_type, word16 wait_packet_id, int timeout_ms)\n{\n    int rc;\n    word16 packet_id;\n    MqttPacketType packet_type;\n#ifdef WOLFMQTT_MULTITHREAD\n    MqttPendResp *pendResp;\n    int readLocked;\n#endif\n    MqttMsgStat* mms_stat;\n    int waitMatchFound;\n\n    if (client == NULL || packet_obj == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    /* all packet type structures must have MqttMsgStat at top */\n    mms_stat = (MqttMsgStat*)packet_obj;\n\nwait_again:\n\n    /* initialize variables */\n    packet_id = 0;\n    packet_type = MQTT_PACKET_TYPE_RESERVED;\n#ifdef WOLFMQTT_MULTITHREAD\n    pendResp = NULL;\n    readLocked = 0;\n#endif\n    waitMatchFound = 0;\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"MqttClient_WaitType: Type %s (%d), ID %d\",\n        MqttPacket_TypeDesc((MqttPacketType)wait_type),\n            wait_type, wait_packet_id);\n#endif\n\n    switch ((int)*mms_stat)\n    {\n        case MQTT_MSG_BEGIN:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Lock recv socket mutex */\n            rc = wm_SemLock(&client->lockRecv);\n            if (rc != 0) {\n                PRINTF(\"MqttClient_WaitType: recv lock error!\");\n                return rc;\n            }\n            readLocked = 1;\n        #endif\n\n            /* reset the packet state */\n            client->packet.stat = MQTT_PK_BEGIN;\n        }\n        FALL_THROUGH;\n\n    #ifdef WOLFMQTT_V5\n        case MQTT_MSG_AUTH:\n    #endif\n        case MQTT_MSG_WAIT:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if packet type and id have already completed */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, (MqttPacketType)wait_type, \n                    wait_packet_id, &pendResp)) {\n                    if (pendResp->packetDone) {\n                        /* pending response is already done, so return */\n                        rc = pendResp->packet_ret;\n                    #ifdef WOLFMQTT_DEBUG_CLIENT\n                        PRINTF(\"PendResp already Done %p: Rc %d\", pendResp, rc);\n                    #endif\n                        MqttClient_RespList_Remove(client, pendResp);\n                        wm_SemUnlock(&client->lockClient);\n                        wm_SemUnlock(&client->lockRecv);\n                        return rc;\n                    }\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            *mms_stat = MQTT_MSG_WAIT;\n\n            /* Wait for packet */\n            rc = MqttPacket_Read(client, client->rx_buf, client->rx_buf_len,\n                    timeout_ms);\n            /* handle failure */\n            if (rc <= 0) {\n                break;\n            }\n\n            /* capture length read */\n            client->packet.buf_len = rc;\n\n            /* Decode Packet - get type and id */\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, NULL, &packet_type, NULL, &packet_id);\n            if (rc < 0) {\n                break;\n            }\n\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"Read Packet: Len %d, Type %d, ID %d\",\n                client->packet.buf_len, packet_type, packet_id);\n        #endif\n\n            *mms_stat = MQTT_MSG_READ;\n        }\n        FALL_THROUGH;\n\n        case MQTT_MSG_READ:\n        case MQTT_MSG_READ_PAYLOAD:\n        {\n            MqttPacketType use_packet_type;\n            void* use_packet_obj;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            readLocked = 1; /* if in this state read is locked */\n        #endif\n\n            /* read payload state only happens for publish messages */\n            if (*mms_stat == MQTT_MSG_READ_PAYLOAD) {\n                packet_type = MQTT_PACKET_TYPE_PUBLISH;\n            }\n\n            /* Determine if we received data for this request */\n            if ((wait_type == MQTT_PACKET_TYPE_ANY ||\n                 wait_type == packet_type ||\n                 (MqttIsPubRespPacket(packet_type) &&\n                  MqttIsPubRespPacket(wait_type))) &&\n                (wait_packet_id == 0 || wait_packet_id == packet_id))\n            {\n                use_packet_obj = packet_obj;\n                waitMatchFound = 1;\n            }\n            else {\n                /* use generic packet object */\n                use_packet_obj = &client->msg;\n            }\n            use_packet_type = packet_type;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if we have a pending response for this packet */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, packet_type, packet_id,\n                                                               &pendResp)) {\n                    /* we found packet match this incoming read packet */\n                    pendResp->packetProcessing = 1;\n                    use_packet_obj = pendResp->packet_obj;\n                    use_packet_type = pendResp->packet_type;\n                    /* req from another thread... not a match */\n                    waitMatchFound = 0;\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            /* Perform packet handling for publish callback and QoS */\n            rc = MqttClient_HandlePacket(client, use_packet_type,\n                use_packet_obj, timeout_ms);\n\n        #ifdef WOLFMQTT_NONBLOCK\n            if (rc == MQTT_CODE_CONTINUE) {\n                /* we have received some data, so keep the recv\n                    mutex lock active and return */\n                return rc;\n            }\n        #endif\n\n            /* handle success case */\n            if (rc >= 0) {\n                rc = MQTT_CODE_SUCCESS;\n            }\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (pendResp) {\n                /* Mark pending response entry done */\n                if (wm_SemLock(&client->lockClient) == 0) {\n                    pendResp->packetDone = 1;\n                    pendResp->packet_ret = rc;\n                #ifdef WOLFMQTT_DEBUG_CLIENT\n                    PRINTF(\"PendResp Done %p\", pendResp);\n                #endif\n                    pendResp = NULL;\n                    wm_SemUnlock(&client->lockClient);\n                }\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n            break;\n        }\n\n        case MQTT_MSG_WRITE:\n        case MQTT_MSG_WRITE_PAYLOAD:\n        default:\n        {\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"MqttClient_WaitType: Invalid state %d!\", *mms_stat);\n        #endif\n            rc = MQTT_CODE_ERROR_STAT;\n            break;\n        }\n    } /* switch (*mms_stat) */\n\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc != MQTT_CODE_CONTINUE)\n#endif\n    {\n        /* reset state */\n        *mms_stat = MQTT_MSG_BEGIN;\n    }\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (readLocked) {\n        wm_SemUnlock(&client->lockRecv);\n    }\n#endif\n    if (rc < 0) {\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_WaitType: Failure: %s (%d)\",\n            MqttClient_ReturnCodeToString(rc), rc);\n    #endif\n        return rc;\n    }\n\n    if (!waitMatchFound) {\n        /* if we get here, then the we are still waiting for a packet */\n        goto wait_again;\n    }\n\n    return rc;\n}\n",
    "target": 0,
    "idx": 2038146
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "int dav1d_decode_frame_init(Dav1dFrameContext *const f) {\n    const Dav1dContext *const c = f->c;\n    int retval = DAV1D_ERR(ENOMEM);\n\n    if (f->sbh > f->lf.start_of_tile_row_sz) {\n        free(f->lf.start_of_tile_row);\n        f->lf.start_of_tile_row = malloc(f->sbh * sizeof(uint8_t));\n        if (!f->lf.start_of_tile_row) {\n            f->lf.start_of_tile_row_sz = 0;\n            goto error;\n        }\n        f->lf.start_of_tile_row_sz = f->sbh;\n    }\n    int sby = 0;\n    for (int tile_row = 0; tile_row < f->frame_hdr->tiling.rows; tile_row++) {\n        f->lf.start_of_tile_row[sby++] = tile_row;\n        while (sby < f->frame_hdr->tiling.row_start_sb[tile_row + 1])\n            f->lf.start_of_tile_row[sby++] = 0;\n    }\n\n    const int n_ts = f->frame_hdr->tiling.cols * f->frame_hdr->tiling.rows;\n    if (n_ts != f->n_ts) {\n        if (c->n_fc > 1) {\n            freep(&f->frame_thread.tile_start_off);\n            f->frame_thread.tile_start_off =\n                malloc(sizeof(*f->frame_thread.tile_start_off) * n_ts);\n            if (!f->frame_thread.tile_start_off) {\n                f->n_ts = 0;\n                goto error;\n            }\n        }\n        Dav1dTileState *ts_new = dav1d_alloc_aligned(sizeof(*f->ts) * n_ts, 32);\n        if (!ts_new) goto error;\n        if (f->ts) {\n            memcpy(ts_new, f->ts, sizeof(*f->ts) * imin(n_ts, f->n_ts));\n            dav1d_free_aligned(f->ts);\n        }\n        f->n_ts = n_ts;\n        f->ts = ts_new;\n    }\n\n    const int a_sz = f->sb128w * f->frame_hdr->tiling.rows * (1 + (c->n_fc > 1 && c->n_tc > 1));\n    if (a_sz != f->a_sz) {\n        freep(&f->a);\n        f->a = malloc(sizeof(*f->a) * a_sz);\n        if (!f->a) {\n            f->a_sz = 0;\n            goto error;\n        }\n        f->a_sz = a_sz;\n    }\n\n    const int num_sb128 = f->sb128w * f->sb128h;\n    const uint8_t *const size_mul = ss_size_mul[f->cur.p.layout];\n    const int hbd = !!f->seq_hdr->hbd;\n    if (c->n_fc > 1) {\n        int tile_idx = 0;\n        for (int tile_row = 0; tile_row < f->frame_hdr->tiling.rows; tile_row++) {\n            int row_off = f->frame_hdr->tiling.row_start_sb[tile_row] *\n                          f->sb_step * 4 * f->sb128w * 128;\n            int b_diff = (f->frame_hdr->tiling.row_start_sb[tile_row + 1] -\n                          f->frame_hdr->tiling.row_start_sb[tile_row]) * f->sb_step * 4;\n            for (int tile_col = 0; tile_col < f->frame_hdr->tiling.cols; tile_col++) {\n                f->frame_thread.tile_start_off[tile_idx++] = row_off + b_diff *\n                    f->frame_hdr->tiling.col_start_sb[tile_col] * f->sb_step * 4;\n            }\n        }\n\n        const int lowest_pixel_mem_sz = f->frame_hdr->tiling.cols * f->sbh;\n        if (lowest_pixel_mem_sz != f->tile_thread.lowest_pixel_mem_sz) {\n            free(f->tile_thread.lowest_pixel_mem);\n            f->tile_thread.lowest_pixel_mem =\n                malloc(lowest_pixel_mem_sz * sizeof(*f->tile_thread.lowest_pixel_mem));\n            if (!f->tile_thread.lowest_pixel_mem) {\n                f->tile_thread.lowest_pixel_mem_sz = 0;\n                goto error;\n            }\n            f->tile_thread.lowest_pixel_mem_sz = lowest_pixel_mem_sz;\n        }\n        int (*lowest_pixel_ptr)[7][2] = f->tile_thread.lowest_pixel_mem;\n        for (int tile_row = 0, tile_row_base = 0; tile_row < f->frame_hdr->tiling.rows;\n             tile_row++, tile_row_base += f->frame_hdr->tiling.cols)\n        {\n            const int tile_row_sb_h = f->frame_hdr->tiling.row_start_sb[tile_row + 1] -\n                                      f->frame_hdr->tiling.row_start_sb[tile_row];\n            for (int tile_col = 0; tile_col < f->frame_hdr->tiling.cols; tile_col++) {\n                f->ts[tile_row_base + tile_col].lowest_pixel = lowest_pixel_ptr;\n                lowest_pixel_ptr += tile_row_sb_h;\n            }\n        }\n\n        const int cf_sz = (num_sb128 * size_mul[0]) << hbd;\n        if (cf_sz != f->frame_thread.cf_sz) {\n            dav1d_freep_aligned(&f->frame_thread.cf);\n            f->frame_thread.cf =\n                dav1d_alloc_aligned((size_t)cf_sz * 128 * 128 / 2, 32);\n            if (!f->frame_thread.cf) {\n                f->frame_thread.cf_sz = 0;\n                goto error;\n            }\n            memset(f->frame_thread.cf, 0, (size_t)cf_sz * 128 * 128 / 2);\n            f->frame_thread.cf_sz = cf_sz;\n        }\n\n        if (f->frame_hdr->allow_screen_content_tools) {\n            if (num_sb128 != f->frame_thread.pal_sz) {\n                dav1d_freep_aligned(&f->frame_thread.pal);\n                f->frame_thread.pal =\n                    dav1d_alloc_aligned(sizeof(*f->frame_thread.pal) *\n                                        num_sb128 * 16 * 16, 32);\n                if (!f->frame_thread.pal) {\n                    f->frame_thread.pal_sz = 0;\n                    goto error;\n                }\n                f->frame_thread.pal_sz = num_sb128;\n            }\n\n            const int pal_idx_sz = num_sb128 * size_mul[1];\n            if (pal_idx_sz != f->frame_thread.pal_idx_sz) {\n                dav1d_freep_aligned(&f->frame_thread.pal_idx);\n                f->frame_thread.pal_idx =\n                    dav1d_alloc_aligned(sizeof(*f->frame_thread.pal_idx) *\n                                        pal_idx_sz * 128 * 128 / 4, 32);\n                if (!f->frame_thread.pal_idx) {\n                    f->frame_thread.pal_idx_sz = 0;\n                    goto error;\n                }\n                f->frame_thread.pal_idx_sz = pal_idx_sz;\n            }\n        } else if (f->frame_thread.pal) {\n            dav1d_freep_aligned(&f->frame_thread.pal);\n            dav1d_freep_aligned(&f->frame_thread.pal_idx);\n            f->frame_thread.pal_sz = f->frame_thread.pal_idx_sz = 0;\n        }\n    }\n\n    // update allocation of block contexts for above\n    const ptrdiff_t y_stride = f->cur.stride[0], uv_stride = f->cur.stride[1];\n    if (y_stride != f->lf.cdef_line_sz[0] || uv_stride != f->lf.cdef_line_sz[1]) {\n        dav1d_free_aligned(f->lf.cdef_line_buf);\n        size_t alloc_sz = 64;\n        alloc_sz += (y_stride  < 0 ? -y_stride  : y_stride ) * 4;\n        alloc_sz += (uv_stride < 0 ? -uv_stride : uv_stride) * 8;\n        uint8_t *ptr = f->lf.cdef_line_buf = dav1d_alloc_aligned(alloc_sz, 32);\n        if (!ptr) {\n            f->lf.cdef_line_sz[0] = f->lf.cdef_line_sz[1] = 0;\n            goto error;\n        }\n\n        ptr += 32;\n        if (y_stride < 0) {\n            f->lf.cdef_line[0][0] = ptr - y_stride * 1;\n            f->lf.cdef_line[1][0] = ptr - y_stride * 3;\n            ptr -= y_stride * 4;\n        } else {\n            f->lf.cdef_line[0][0] = ptr + y_stride * 0;\n            f->lf.cdef_line[1][0] = ptr + y_stride * 2;\n            ptr += y_stride * 4;\n        }\n        if (uv_stride < 0) {\n            f->lf.cdef_line[0][1] = ptr - uv_stride * 1;\n            f->lf.cdef_line[0][2] = ptr - uv_stride * 3;\n            f->lf.cdef_line[1][1] = ptr - uv_stride * 5;\n            f->lf.cdef_line[1][2] = ptr - uv_stride * 7;\n        } else {\n            f->lf.cdef_line[0][1] = ptr + uv_stride * 0;\n            f->lf.cdef_line[0][2] = ptr + uv_stride * 2;\n            f->lf.cdef_line[1][1] = ptr + uv_stride * 4;\n            f->lf.cdef_line[1][2] = ptr + uv_stride * 6;\n        }\n\n        f->lf.cdef_line_sz[0] = (int) y_stride;\n        f->lf.cdef_line_sz[1] = (int) uv_stride;\n    }\n\n    const int num_lines = c->n_tc > 1 ? f->sbh * (4 << f->seq_hdr->sb128) : 12;\n    const int lr_line_sz = ((f->sr_cur.p.p.w + 31) & ~31) << hbd;\n    const size_t lr_plane_sz = num_lines * lr_line_sz;\n    if (lr_plane_sz != f->lf.lr_plane_sz) {\n        dav1d_freep_aligned(&f->lf.lr_lpf_line[0]);\n        // lr simd may overread the input, so slightly over-allocate the lpf buffer\n        uint8_t *lr_ptr = dav1d_alloc_aligned(lr_plane_sz * 3 + 64, 32);\n        if (!lr_ptr) {\n            f->lf.lr_plane_sz = 0;\n            goto error;\n        }\n\n        for (int pl = 0; pl <= 2; pl++) {\n            f->lf.lr_lpf_line[pl] = lr_ptr;\n            lr_ptr += lr_plane_sz;\n        }\n\n        f->lf.lr_plane_sz = lr_plane_sz;\n    }\n\n    // update allocation for loopfilter masks\n    if (num_sb128 != f->lf.mask_sz) {\n        freep(&f->lf.mask);\n        freep(&f->lf.level);\n        f->lf.mask = malloc(sizeof(*f->lf.mask) * num_sb128);\n        // over-allocate by 3 bytes since some of the SIMD implementations\n        // index this from the level type and can thus over-read by up to 3\n        f->lf.level = malloc(sizeof(*f->lf.level) * num_sb128 * 32 * 32 + 3);\n        if (!f->lf.mask || !f->lf.level) {\n            f->lf.mask_sz = 0;\n            goto error;\n        }\n        if (c->n_fc > 1) {\n            freep(&f->frame_thread.b);\n            freep(&f->frame_thread.cbi);\n            f->frame_thread.b = malloc(sizeof(*f->frame_thread.b) *\n                                       num_sb128 * 32 * 32);\n            f->frame_thread.cbi = malloc(sizeof(*f->frame_thread.cbi) *\n                                         num_sb128 * 32 * 32);\n            if (!f->frame_thread.b || !f->frame_thread.cbi) {\n                f->lf.mask_sz = 0;\n                goto error;\n            }\n        }\n        f->lf.mask_sz = num_sb128;\n    }\n\n    f->sr_sb128w = (f->sr_cur.p.p.w + 127) >> 7;\n    const int lr_mask_sz = f->sr_sb128w * f->sb128h;\n    if (lr_mask_sz != f->lf.lr_mask_sz) {\n        freep(&f->lf.lr_mask);\n        f->lf.lr_mask = malloc(sizeof(*f->lf.lr_mask) * lr_mask_sz);\n        if (!f->lf.lr_mask) {\n            f->lf.lr_mask_sz = 0;\n            goto error;\n        }\n        f->lf.lr_mask_sz = lr_mask_sz;\n    }\n    f->lf.restore_planes =\n        ((f->frame_hdr->restoration.type[0] != DAV1D_RESTORATION_NONE) << 0) +\n        ((f->frame_hdr->restoration.type[1] != DAV1D_RESTORATION_NONE) << 1) +\n        ((f->frame_hdr->restoration.type[2] != DAV1D_RESTORATION_NONE) << 2);\n    if (f->frame_hdr->loopfilter.sharpness != f->lf.last_sharpness) {\n        dav1d_calc_eih(&f->lf.lim_lut, f->frame_hdr->loopfilter.sharpness);\n        f->lf.last_sharpness = f->frame_hdr->loopfilter.sharpness;\n    }\n    dav1d_calc_lf_values(f->lf.lvl, f->frame_hdr, (int8_t[4]) { 0, 0, 0, 0 });\n    memset(f->lf.mask, 0, sizeof(*f->lf.mask) * num_sb128);\n\n    const int ipred_edge_sz = f->sbh * f->sb128w << hbd;\n    if (ipred_edge_sz != f->ipred_edge_sz) {\n        dav1d_freep_aligned(&f->ipred_edge[0]);\n        uint8_t *ptr = f->ipred_edge[0] =\n            dav1d_alloc_aligned(ipred_edge_sz * 128 * 3, 32);\n        if (!ptr) {\n            f->ipred_edge_sz = 0;\n            goto error;\n        }\n        f->ipred_edge[1] = ptr + ipred_edge_sz * 128 * 1;\n        f->ipred_edge[2] = ptr + ipred_edge_sz * 128 * 2;\n        f->ipred_edge_sz = ipred_edge_sz;\n    }\n\n    const int re_sz = f->sb128h * f->frame_hdr->tiling.cols;\n    if (re_sz != f->lf.re_sz) {\n        freep(&f->lf.tx_lpf_right_edge[0]);\n        f->lf.tx_lpf_right_edge[0] = malloc(re_sz * 32 * 2);\n        if (!f->lf.tx_lpf_right_edge[0]) {\n            f->lf.re_sz = 0;\n            goto error;\n        }\n        f->lf.tx_lpf_right_edge[1] = f->lf.tx_lpf_right_edge[0] + re_sz * 32;\n        f->lf.re_sz = re_sz;\n    }\n\n    // init ref mvs\n    if (IS_INTER_OR_SWITCH(f->frame_hdr) || f->frame_hdr->allow_intrabc) {\n        const int ret =\n            dav1d_refmvs_init_frame(&f->rf, f->seq_hdr, f->frame_hdr,\n                                    f->refpoc, f->mvs, f->refrefpoc, f->ref_mvs,\n                                    f->c->n_tc, f->c->n_fc);\n        if (ret < 0) goto error;\n    }\n\n    retval = DAV1D_ERR(EINVAL);\n\n    // setup dequant tables\n    init_quant_tables(f->seq_hdr, f->frame_hdr, f->frame_hdr->quant.yac, f->dq);\n    if (f->frame_hdr->quant.qm)\n        for (int i = 0; i < N_RECT_TX_SIZES; i++) {\n            f->qm[i][0] = dav1d_qm_tbl[f->frame_hdr->quant.qm_y][0][i];\n            f->qm[i][1] = dav1d_qm_tbl[f->frame_hdr->quant.qm_u][1][i];\n            f->qm[i][2] = dav1d_qm_tbl[f->frame_hdr->quant.qm_v][1][i];\n        }\n    else\n        memset(f->qm, 0, sizeof(f->qm));\n\n    // setup jnt_comp weights\n    if (f->frame_hdr->switchable_comp_refs) {\n        for (int i = 0; i < 7; i++) {\n            const unsigned ref0poc = f->refp[i].p.frame_hdr->frame_offset;\n\n            for (int j = i + 1; j < 7; j++) {\n                const unsigned ref1poc = f->refp[j].p.frame_hdr->frame_offset;\n\n                const unsigned d1 =\n                    imin(abs(get_poc_diff(f->seq_hdr->order_hint_n_bits, ref0poc,\n                                          f->cur.frame_hdr->frame_offset)), 31);\n                const unsigned d0 =\n                    imin(abs(get_poc_diff(f->seq_hdr->order_hint_n_bits, ref1poc,\n                                          f->cur.frame_hdr->frame_offset)), 31);\n                const int order = d0 <= d1;\n\n                static const uint8_t quant_dist_weight[3][2] = {\n                    { 2, 3 }, { 2, 5 }, { 2, 7 }\n                };\n                static const uint8_t quant_dist_lookup_table[4][2] = {\n                    { 9, 7 }, { 11, 5 }, { 12, 4 }, { 13, 3 }\n                };\n\n                int k;\n                for (k = 0; k < 3; k++) {\n                    const int c0 = quant_dist_weight[k][order];\n                    const int c1 = quant_dist_weight[k][!order];\n                    const int d0_c0 = d0 * c0;\n                    const int d1_c1 = d1 * c1;\n                    if ((d0 > d1 && d0_c0 < d1_c1) || (d0 <= d1 && d0_c0 > d1_c1)) break;\n                }\n\n                f->jnt_weights[i][j] = quant_dist_lookup_table[k][order];\n            }\n        }\n    }\n\n    /* Init loopfilter pointers. Increasing NULL pointers is technically UB,\n     * so just point the chroma pointers in 4:0:0 to the luma plane here to\n     * avoid having additional in-loop branches in various places. We never\n     * dereference those pointers so it doesn't really matter what they\n     * point at, as long as the pointers are valid. */\n    const int has_chroma = f->cur.p.layout != DAV1D_PIXEL_LAYOUT_I400;\n    f->lf.mask_ptr = f->lf.mask;\n    f->lf.p[0] = f->cur.data[0];\n    f->lf.p[1] = f->cur.data[has_chroma ? 1 : 0];\n    f->lf.p[2] = f->cur.data[has_chroma ? 2 : 0];\n    f->lf.sr_p[0] = f->sr_cur.p.data[0];\n    f->lf.sr_p[1] = f->sr_cur.p.data[has_chroma ? 1 : 0];\n    f->lf.sr_p[2] = f->sr_cur.p.data[has_chroma ? 2 : 0];\n\n    if (f->frame_hdr->refresh_context)\n        dav1d_cdf_thread_copy(f->out_cdf.data.cdf, &f->in_cdf);\n\n    // parse individual tiles per tile group\n    int tile_row = 0, tile_col = 0;\n    f->task_thread.update_set = 0;\n    for (int i = 0; i < f->n_tile_data; i++) {\n        const uint8_t *data = f->tile[i].data.data;\n        size_t size = f->tile[i].data.sz;\n\n        for (int j = f->tile[i].start; j <= f->tile[i].end; j++) {\n            size_t tile_sz;\n            if (j == f->tile[i].end) {\n                tile_sz = size;\n            } else {\n                if (f->frame_hdr->tiling.n_bytes > size) goto error;\n                tile_sz = 0;\n                for (unsigned k = 0; k < f->frame_hdr->tiling.n_bytes; k++)\n                    tile_sz |= (unsigned)*data++ << (k * 8);\n                tile_sz++;\n                size -= f->frame_hdr->tiling.n_bytes;\n                if (tile_sz > size) goto error;\n            }\n\n            setup_tile(&f->ts[j], f, data, tile_sz, tile_row, tile_col++,\n                       c->n_fc > 1 ? f->frame_thread.tile_start_off[j] : 0);\n\n            if (tile_col == f->frame_hdr->tiling.cols) {\n                tile_col = 0;\n                tile_row++;\n            }\n            if (j == f->frame_hdr->tiling.update && f->frame_hdr->refresh_context)\n                f->task_thread.update_set = 1;\n            data += tile_sz;\n            size -= tile_sz;\n        }\n    }\n\n    if (c->n_tc > 1) {\n        const int uses_2pass = c->n_fc > 1;\n        for (int n = 0; n < f->sb128w * f->frame_hdr->tiling.rows * (1 + uses_2pass); n++)\n            reset_context(&f->a[n], IS_KEY_OR_INTRA(f->frame_hdr),\n                          uses_2pass ? 1 + (n >= f->sb128w * f->frame_hdr->tiling.rows) : 0);\n    }\n\n    retval = 0;\nerror:\n    return retval;\n}\n",
    "target": 0,
    "idx": 2038152
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "static int MqttClient_WaitType(MqttClient *client, void *packet_obj,\n    byte wait_type, word16 wait_packet_id, int timeout_ms)\n{\n    int rc;\n    word16 packet_id;\n    MqttPacketType packet_type;\n#ifdef WOLFMQTT_MULTITHREAD\n    MqttPendResp *pendResp;\n    int readLocked;\n#endif\n    MqttMsgStat* mms_stat;\n    int waitMatchFound;\n\n    if (client == NULL || packet_obj == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    /* all packet type structures must have MqttMsgStat at top */\n    mms_stat = (MqttMsgStat*)packet_obj;\n\nwait_again:\n\n    /* initialize variables */\n    packet_id = 0;\n    packet_type = MQTT_PACKET_TYPE_RESERVED;\n#ifdef WOLFMQTT_MULTITHREAD\n    pendResp = NULL;\n    readLocked = 0;\n#endif\n    waitMatchFound = 0;\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"MqttClient_WaitType: Type %s (%d), ID %d\",\n        MqttPacket_TypeDesc((MqttPacketType)wait_type),\n            wait_type, wait_packet_id);\n#endif\n\n    switch ((int)*mms_stat)\n    {\n        case MQTT_MSG_BEGIN:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Lock recv socket mutex */\n            rc = wm_SemLock(&client->lockRecv);\n            if (rc != 0) {\n                PRINTF(\"MqttClient_WaitType: recv lock error!\");\n                return rc;\n            }\n            readLocked = 1;\n        #endif\n\n            /* reset the packet state */\n            client->packet.stat = MQTT_PK_BEGIN;\n        }\n        FALL_THROUGH;\n\n    #ifdef WOLFMQTT_V5\n        case MQTT_MSG_AUTH:\n    #endif\n        case MQTT_MSG_WAIT:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if packet type and id have already completed */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, (MqttPacketType)wait_type, \n                    wait_packet_id, &pendResp)) {\n                    if (pendResp->packetDone) {\n                        /* pending response is already done, so return */\n                        rc = pendResp->packet_ret;\n                    #ifdef WOLFMQTT_DEBUG_CLIENT\n                        PRINTF(\"PendResp already Done %p: Rc %d\", pendResp, rc);\n                    #endif\n                        MqttClient_RespList_Remove(client, pendResp);\n                        wm_SemUnlock(&client->lockClient);\n                        wm_SemUnlock(&client->lockRecv);\n                        return rc;\n                    }\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            *mms_stat = MQTT_MSG_WAIT;\n\n            /* Wait for packet */\n            rc = MqttPacket_Read(client, client->rx_buf, client->rx_buf_len,\n                    timeout_ms);\n            /* handle failure */\n            if (rc <= 0) {\n                break;\n            }\n\n            /* capture length read */\n            client->packet.buf_len = rc;\n\n            /* Decode Packet - get type and id */\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, NULL, &packet_type, NULL, &packet_id);\n            if (rc < 0) {\n                break;\n            }\n\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"Read Packet: Len %d, Type %d, ID %d\",\n                client->packet.buf_len, packet_type, packet_id);\n        #endif\n\n            *mms_stat = MQTT_MSG_READ;\n        }\n        FALL_THROUGH;\n\n        case MQTT_MSG_READ:\n        case MQTT_MSG_READ_PAYLOAD:\n        {\n            MqttPacketType use_packet_type;\n            void* use_packet_obj;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            readLocked = 1; /* if in this state read is locked */\n        #endif\n\n            /* read payload state only happens for publish messages */\n            if (*mms_stat == MQTT_MSG_READ_PAYLOAD) {\n                packet_type = MQTT_PACKET_TYPE_PUBLISH;\n            }\n\n            /* Determine if we received data for this request */\n            if ((wait_type == MQTT_PACKET_TYPE_ANY ||\n                 wait_type == packet_type ||\n                 (MqttIsPubRespPacket(packet_type) &&\n                  MqttIsPubRespPacket(wait_type))) &&\n                (wait_packet_id == 0 || wait_packet_id == packet_id))\n            {\n                use_packet_obj = packet_obj;\n                waitMatchFound = 1;\n            }\n            else {\n                /* use generic packet object */\n                use_packet_obj = &client->msg;\n            }\n            use_packet_type = packet_type;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if we have a pending response for this packet */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, packet_type, packet_id,\n                                                               &pendResp)) {\n                    /* we found packet match this incoming read packet */\n                    pendResp->packetProcessing = 1;\n                    use_packet_obj = pendResp->packet_obj;\n                    use_packet_type = pendResp->packet_type;\n                    /* req from another thread... not a match */\n                    waitMatchFound = 0;\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            /* Perform packet handling for publish callback and QoS */\n            rc = MqttClient_HandlePacket(client, use_packet_type,\n                use_packet_obj, timeout_ms);\n\n        #ifdef WOLFMQTT_NONBLOCK\n            if (rc == MQTT_CODE_CONTINUE) {\n                /* we have received some data, so keep the recv\n                    mutex lock active and return */\n                return rc;\n            }\n        #endif\n\n            /* handle success case */\n            if (rc >= 0) {\n                rc = MQTT_CODE_SUCCESS;\n            }\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (pendResp) {\n                /* Mark pending response entry done */\n                if (wm_SemLock(&client->lockClient) == 0) {\n                    pendResp->packetDone = 1;\n                    pendResp->packet_ret = rc;\n                #ifdef WOLFMQTT_DEBUG_CLIENT\n                    PRINTF(\"PendResp Done %p\", pendResp);\n                #endif\n                    pendResp = NULL;\n                    wm_SemUnlock(&client->lockClient);\n                }\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n            break;\n        }\n\n        case MQTT_MSG_WRITE:\n        case MQTT_MSG_WRITE_PAYLOAD:\n        default:\n        {\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"MqttClient_WaitType: Invalid state %d!\", *mms_stat);\n        #endif\n            rc = MQTT_CODE_ERROR_STAT;\n            break;\n        }\n    } /* switch (*mms_stat) */\n\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc != MQTT_CODE_CONTINUE)\n#endif\n    {\n        /* reset state */\n        *mms_stat = MQTT_MSG_BEGIN;\n    }\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (readLocked) {\n        wm_SemUnlock(&client->lockRecv);\n    }\n#endif\n    if (rc < 0) {\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_WaitType: Failure: %s (%d)\",\n            MqttClient_ReturnCodeToString(rc), rc);\n    #endif\n        return rc;\n    }\n\n    if (!waitMatchFound) {\n        /* if we get here, then the we are still waiting for a packet */\n        goto wait_again;\n    }\n\n    return rc;\n}\n",
    "target": 0,
    "idx": 2038237
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "int blosclz_compress(const int clevel, const void* input, int length,\n                     void* output, int maxout, const int split_block) {\n  uint8_t* ibase = (uint8_t*)input;\n\n  // Experiments say that checking 1/4 of the buffer is enough to figure out approx cratio\n  int maxlen = length / 4;\n  // Start probing somewhere inside the buffer\n  int shift = length - maxlen;\n  // Actual entropy probing!\n  double cratio = get_cratio(ibase + shift, maxlen, 3, 3);\n  // discard probes with small compression ratios (too expensive)\n  double cratio_[10] = {0, 2, 1.5, 1.2, 1.2, 1.2, 1.2, 1.15, 1.1, 1.0};\n  if (cratio < cratio_[clevel]) {\n    goto out;\n  }\n\n  /* When we go back in a match (shift), we obtain quite different compression properties.\n   * It looks like 4 is more useful in combination with bitshuffle and small typesizes\n   * Fallback to 4 because it provides more consistent results for large cratios.\n   *\n   * In this block we also check cratios for the beginning of the buffers and\n   * eventually discard those that are small (take too long to decompress).\n   * This process is called _entropy probing_.\n   */\n  unsigned ipshift = 4;\n  // Compute optimal shift and minimum lengths for encoding\n  // Use 4 by default, except for low entropy data, where we should do a best effort\n  unsigned minlen = 4;\n  // BloscLZ works better with splits mostly, so when data is not split, do a best effort\n  // Why using cratio < 4 is based in experiments with low and high entropy\n  if (!split_block || cratio < 4) {\n    ipshift = 3;\n    minlen = 3;\n  }\n\n  uint8_t hashlog_[10] = {0, HASH_LOG - 2, HASH_LOG - 1, HASH_LOG, HASH_LOG,\n                          HASH_LOG, HASH_LOG, HASH_LOG, HASH_LOG, HASH_LOG};\n  uint8_t hashlog = hashlog_[clevel];\n\n  uint8_t* ip = ibase;\n  const uint8_t* ip_bound = ibase + length - 1;\n  const uint8_t* ip_limit = ibase + length - 12;\n  uint8_t* op = (uint8_t*)output;\n  const uint8_t* op_limit = op + maxout;\n\n  /* input and output buffer cannot be less than 16 and 66 bytes or we can get into trouble */\n  if (length < 16 || maxout < 66) {\n    return 0;\n  }\n\n  // Initialize the hash table\n  uint32_t htab[1U << (uint8_t)HASH_LOG];\n  memset(htab, 0, (1U << hashlog) * sizeof(uint32_t));\n\n  /* we start with literal copy */\n  uint8_t copy = 4;\n  *op++ = MAX_COPY - 1;\n  *op++ = *ip++;\n  *op++ = *ip++;\n  *op++ = *ip++;\n  *op++ = *ip++;\n\n  /* main loop */\n  while (BLOSCLZ_LIKELY(ip < ip_limit)) {\n    const uint8_t* ref;\n    unsigned distance;\n    uint8_t* anchor = ip;    /* comparison starting-point */\n\n    /* find potential match */\n    uint32_t seq = BLOSCLZ_READU32(ip);\n    uint32_t hval;\n    HASH_FUNCTION(hval, seq, hashlog)\n    ref = ibase + htab[hval];\n\n    /* calculate distance to the match */\n    distance = (unsigned int)(anchor - ref);\n\n    /* update hash table */\n    htab[hval] = (uint32_t) (anchor - ibase);\n\n    if (distance == 0 || (distance >= MAX_FARDISTANCE)) {\n      LITERAL(ip, op, op_limit, anchor, copy)\n      continue;\n    }\n\n    /* is this a match? check the first 4 bytes */\n    if (BLOSCLZ_UNLIKELY(BLOSCLZ_READU32(ref) == BLOSCLZ_READU32(ip))) {\n      ref += 4;\n    } else {\n      /* no luck, copy as a literal */\n      LITERAL(ip, op, op_limit, anchor, copy)\n      continue;\n    }\n\n    /* last matched byte */\n    ip = anchor + 4;\n\n    /* distance is biased */\n    distance--;\n\n    /* get runs or matches; zero distance means a run */\n    ip = get_run_or_match(ip, ip_bound, ref, !distance);\n\n    /* length is biased, '1' means a match of 3 bytes */\n    ip -= ipshift;\n\n    unsigned len = (int)(ip - anchor);\n\n    // Encoding short lengths is expensive during decompression\n    if (len < minlen || (len <= 5 && distance >= MAX_DISTANCE)) {\n      LITERAL(ip, op, op_limit, anchor, copy)\n      continue;\n    }\n\n    /* if we have copied something, adjust the copy count */\n    if (copy)\n      /* copy is biased, '0' means 1 byte copy */\n      *(op - copy - 1) = (uint8_t)(copy - 1);\n    else\n      /* back, to overwrite the copy count */\n      op--;\n    /* reset literal counter */\n    copy = 0;\n\n    /* encode the match */\n    if (distance < MAX_DISTANCE) {\n      if (len < 7) {\n        MATCH_SHORT(op, op_limit, len, distance)\n      } else {\n        MATCH_LONG(op, op_limit, len, distance)\n      }\n    } else {\n      /* far away, but not yet in the another galaxy... */\n      distance -= MAX_DISTANCE;\n      if (len < 7) {\n        MATCH_SHORT_FAR(op, op_limit, len, distance)\n      } else {\n        MATCH_LONG_FAR(op, op_limit, len, distance)\n      }\n    }\n\n    /* update the hash at match boundary */\n    seq = BLOSCLZ_READU32(ip);\n    HASH_FUNCTION(hval, seq, hashlog)\n    htab[hval] = (uint32_t) (ip++ - ibase);\n    if (clevel == 9) {\n      // In some situations, including a second hash proves to be useful,\n      // but not in others.  Activating here in max clevel only.\n      seq >>= 8U;\n      HASH_FUNCTION(hval, seq, hashlog)\n      htab[hval] = (uint32_t) (ip++ - ibase);\n    }\n    else {\n      ip++;\n    }\n\n    if (BLOSCLZ_UNLIKELY(op + 1 > op_limit))\n      goto out;\n\n    /* assuming literal copy */\n    *op++ = MAX_COPY - 1;\n  }\n\n  /* left-over as literal copy */\n  while (BLOSCLZ_UNLIKELY(ip <= ip_bound)) {\n    if (BLOSCLZ_UNLIKELY(op + 2 > op_limit)) goto out;\n    *op++ = *ip++;\n    copy++;\n    if (BLOSCLZ_UNLIKELY(copy == MAX_COPY)) {\n      copy = 0;\n      *op++ = MAX_COPY - 1;\n    }\n  }\n\n  /* if we have copied something, adjust the copy length */\n  if (copy)\n    *(op - copy - 1) = (uint8_t)(copy - 1);\n  else\n    op--;\n\n  /* marker for blosclz */\n  *(uint8_t*)output |= (1U << 5U);\n\n  return (int)(op - (uint8_t*)output);\n\n  out:\n  return 0;\n}\n",
    "target": 0,
    "idx": 2038313
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "static int MqttClient_WaitType(MqttClient *client, void *packet_obj,\n    byte wait_type, word16 wait_packet_id, int timeout_ms)\n{\n    int rc;\n    word16 packet_id;\n    MqttPacketType packet_type;\n#ifdef WOLFMQTT_MULTITHREAD\n    MqttPendResp *pendResp;\n    int readLocked;\n#endif\n    MqttMsgStat* mms_stat;\n    int waitMatchFound;\n\n    if (client == NULL || packet_obj == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    /* all packet type structures must have MqttMsgStat at top */\n    mms_stat = (MqttMsgStat*)packet_obj;\n\nwait_again:\n\n    /* initialize variables */\n    packet_id = 0;\n    packet_type = MQTT_PACKET_TYPE_RESERVED;\n#ifdef WOLFMQTT_MULTITHREAD\n    pendResp = NULL;\n    readLocked = 0;\n#endif\n    waitMatchFound = 0;\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"MqttClient_WaitType: Type %s (%d), ID %d\",\n        MqttPacket_TypeDesc((MqttPacketType)wait_type),\n            wait_type, wait_packet_id);\n#endif\n\n    switch ((int)*mms_stat)\n    {\n        case MQTT_MSG_BEGIN:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Lock recv socket mutex */\n            rc = wm_SemLock(&client->lockRecv);\n            if (rc != 0) {\n                PRINTF(\"MqttClient_WaitType: recv lock error!\");\n                return rc;\n            }\n            readLocked = 1;\n        #endif\n\n            /* reset the packet state */\n            client->packet.stat = MQTT_PK_BEGIN;\n        }\n        FALL_THROUGH;\n\n    #ifdef WOLFMQTT_V5\n        case MQTT_MSG_AUTH:\n    #endif\n        case MQTT_MSG_WAIT:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if packet type and id have already completed */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, (MqttPacketType)wait_type, \n                    wait_packet_id, &pendResp)) {\n                    if (pendResp->packetDone) {\n                        /* pending response is already done, so return */\n                        rc = pendResp->packet_ret;\n                    #ifdef WOLFMQTT_DEBUG_CLIENT\n                        PRINTF(\"PendResp already Done %p: Rc %d\", pendResp, rc);\n                    #endif\n                        MqttClient_RespList_Remove(client, pendResp);\n                        wm_SemUnlock(&client->lockClient);\n                        wm_SemUnlock(&client->lockRecv);\n                        return rc;\n                    }\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            *mms_stat = MQTT_MSG_WAIT;\n\n            /* Wait for packet */\n            rc = MqttPacket_Read(client, client->rx_buf, client->rx_buf_len,\n                    timeout_ms);\n            /* handle failure */\n            if (rc <= 0) {\n                break;\n            }\n\n            /* capture length read */\n            client->packet.buf_len = rc;\n\n            /* Decode Packet - get type and id */\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, NULL, &packet_type, NULL, &packet_id);\n            if (rc < 0) {\n                break;\n            }\n\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"Read Packet: Len %d, Type %d, ID %d\",\n                client->packet.buf_len, packet_type, packet_id);\n        #endif\n\n            *mms_stat = MQTT_MSG_READ;\n        }\n        FALL_THROUGH;\n\n        case MQTT_MSG_READ:\n        case MQTT_MSG_READ_PAYLOAD:\n        {\n            MqttPacketType use_packet_type;\n            void* use_packet_obj;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            readLocked = 1; /* if in this state read is locked */\n        #endif\n\n            /* read payload state only happens for publish messages */\n            if (*mms_stat == MQTT_MSG_READ_PAYLOAD) {\n                packet_type = MQTT_PACKET_TYPE_PUBLISH;\n            }\n\n            /* Determine if we received data for this request */\n            if ((wait_type == MQTT_PACKET_TYPE_ANY ||\n                 wait_type == packet_type ||\n                 (MqttIsPubRespPacket(packet_type) &&\n                  MqttIsPubRespPacket(wait_type))) &&\n                (wait_packet_id == 0 || wait_packet_id == packet_id))\n            {\n                use_packet_obj = packet_obj;\n                waitMatchFound = 1;\n            }\n            else {\n                /* use generic packet object */\n                use_packet_obj = &client->msg;\n            }\n            use_packet_type = packet_type;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if we have a pending response for this packet */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, packet_type, packet_id,\n                                                               &pendResp)) {\n                    /* we found packet match this incoming read packet */\n                    pendResp->packetProcessing = 1;\n                    use_packet_obj = pendResp->packet_obj;\n                    use_packet_type = pendResp->packet_type;\n                    /* req from another thread... not a match */\n                    waitMatchFound = 0;\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            /* Perform packet handling for publish callback and QoS */\n            rc = MqttClient_HandlePacket(client, use_packet_type,\n                use_packet_obj, timeout_ms);\n\n        #ifdef WOLFMQTT_NONBLOCK\n            if (rc == MQTT_CODE_CONTINUE) {\n                /* we have received some data, so keep the recv\n                    mutex lock active and return */\n                return rc;\n            }\n        #endif\n\n            /* handle success case */\n            if (rc >= 0) {\n                rc = MQTT_CODE_SUCCESS;\n            }\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (pendResp) {\n                /* Mark pending response entry done */\n                if (wm_SemLock(&client->lockClient) == 0) {\n                    pendResp->packetDone = 1;\n                    pendResp->packet_ret = rc;\n                #ifdef WOLFMQTT_DEBUG_CLIENT\n                    PRINTF(\"PendResp Done %p\", pendResp);\n                #endif\n                    pendResp = NULL;\n                    wm_SemUnlock(&client->lockClient);\n                }\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n            break;\n        }\n\n        case MQTT_MSG_WRITE:\n        case MQTT_MSG_WRITE_PAYLOAD:\n        default:\n        {\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"MqttClient_WaitType: Invalid state %d!\", *mms_stat);\n        #endif\n            rc = MQTT_CODE_ERROR_STAT;\n            break;\n        }\n    } /* switch (*mms_stat) */\n\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc != MQTT_CODE_CONTINUE)\n#endif\n    {\n        /* reset state */\n        *mms_stat = MQTT_MSG_BEGIN;\n    }\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (readLocked) {\n        wm_SemUnlock(&client->lockRecv);\n    }\n#endif\n    if (rc < 0) {\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_WaitType: Failure: %s (%d)\",\n            MqttClient_ReturnCodeToString(rc), rc);\n    #endif\n        return rc;\n    }\n\n    if (!waitMatchFound) {\n        /* if we get here, then the we are still waiting for a packet */\n        goto wait_again;\n    }\n\n    return rc;\n}\n",
    "target": 0,
    "idx": 2039053
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "static int MqttClient_WaitType(MqttClient *client, void *packet_obj,\n    byte wait_type, word16 wait_packet_id, int timeout_ms)\n{\n    int rc;\n    word16 packet_id;\n    MqttPacketType packet_type;\n#ifdef WOLFMQTT_MULTITHREAD\n    MqttPendResp *pendResp;\n    int readLocked;\n#endif\n    MqttMsgStat* mms_stat;\n    int waitMatchFound;\n\n    if (client == NULL || packet_obj == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    /* all packet type structures must have MqttMsgStat at top */\n    mms_stat = (MqttMsgStat*)packet_obj;\n\nwait_again:\n\n    /* initialize variables */\n    packet_id = 0;\n    packet_type = MQTT_PACKET_TYPE_RESERVED;\n#ifdef WOLFMQTT_MULTITHREAD\n    pendResp = NULL;\n    readLocked = 0;\n#endif\n    waitMatchFound = 0;\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"MqttClient_WaitType: Type %s (%d), ID %d\",\n        MqttPacket_TypeDesc((MqttPacketType)wait_type),\n            wait_type, wait_packet_id);\n#endif\n\n    switch ((int)*mms_stat)\n    {\n        case MQTT_MSG_BEGIN:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Lock recv socket mutex */\n            rc = wm_SemLock(&client->lockRecv);\n            if (rc != 0) {\n                PRINTF(\"MqttClient_WaitType: recv lock error!\");\n                return rc;\n            }\n            readLocked = 1;\n        #endif\n\n            /* reset the packet state */\n            client->packet.stat = MQTT_PK_BEGIN;\n        }\n        FALL_THROUGH;\n\n    #ifdef WOLFMQTT_V5\n        case MQTT_MSG_AUTH:\n    #endif\n        case MQTT_MSG_WAIT:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if packet type and id have already completed */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, (MqttPacketType)wait_type, \n                    wait_packet_id, &pendResp)) {\n                    if (pendResp->packetDone) {\n                        /* pending response is already done, so return */\n                        rc = pendResp->packet_ret;\n                    #ifdef WOLFMQTT_DEBUG_CLIENT\n                        PRINTF(\"PendResp already Done %p: Rc %d\", pendResp, rc);\n                    #endif\n                        MqttClient_RespList_Remove(client, pendResp);\n                        wm_SemUnlock(&client->lockClient);\n                        wm_SemUnlock(&client->lockRecv);\n                        return rc;\n                    }\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            *mms_stat = MQTT_MSG_WAIT;\n\n            /* Wait for packet */\n            rc = MqttPacket_Read(client, client->rx_buf, client->rx_buf_len,\n                    timeout_ms);\n            /* handle failure */\n            if (rc <= 0) {\n                break;\n            }\n\n            /* capture length read */\n            client->packet.buf_len = rc;\n\n            /* Decode Packet - get type and id */\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, NULL, &packet_type, NULL, &packet_id);\n            if (rc < 0) {\n                break;\n            }\n\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"Read Packet: Len %d, Type %d, ID %d\",\n                client->packet.buf_len, packet_type, packet_id);\n        #endif\n\n            *mms_stat = MQTT_MSG_READ;\n        }\n        FALL_THROUGH;\n\n        case MQTT_MSG_READ:\n        case MQTT_MSG_READ_PAYLOAD:\n        {\n            MqttPacketType use_packet_type;\n            void* use_packet_obj;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            readLocked = 1; /* if in this state read is locked */\n        #endif\n\n            /* read payload state only happens for publish messages */\n            if (*mms_stat == MQTT_MSG_READ_PAYLOAD) {\n                packet_type = MQTT_PACKET_TYPE_PUBLISH;\n            }\n\n            /* Determine if we received data for this request */\n            if ((wait_type == MQTT_PACKET_TYPE_ANY ||\n                 wait_type == packet_type ||\n                 (MqttIsPubRespPacket(packet_type) &&\n                  MqttIsPubRespPacket(wait_type))) &&\n                (wait_packet_id == 0 || wait_packet_id == packet_id))\n            {\n                use_packet_obj = packet_obj;\n                waitMatchFound = 1;\n            }\n            else {\n                /* use generic packet object */\n                use_packet_obj = &client->msg;\n            }\n            use_packet_type = packet_type;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if we have a pending response for this packet */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, packet_type, packet_id,\n                                                               &pendResp)) {\n                    /* we found packet match this incoming read packet */\n                    pendResp->packetProcessing = 1;\n                    use_packet_obj = pendResp->packet_obj;\n                    use_packet_type = pendResp->packet_type;\n                    /* req from another thread... not a match */\n                    waitMatchFound = 0;\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            /* Perform packet handling for publish callback and QoS */\n            rc = MqttClient_HandlePacket(client, use_packet_type,\n                use_packet_obj, timeout_ms);\n\n        #ifdef WOLFMQTT_NONBLOCK\n            if (rc == MQTT_CODE_CONTINUE) {\n                /* we have received some data, so keep the recv\n                    mutex lock active and return */\n                return rc;\n            }\n        #endif\n\n            /* handle success case */\n            if (rc >= 0) {\n                rc = MQTT_CODE_SUCCESS;\n            }\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (pendResp) {\n                /* Mark pending response entry done */\n                if (wm_SemLock(&client->lockClient) == 0) {\n                    pendResp->packetDone = 1;\n                    pendResp->packet_ret = rc;\n                #ifdef WOLFMQTT_DEBUG_CLIENT\n                    PRINTF(\"PendResp Done %p\", pendResp);\n                #endif\n                    pendResp = NULL;\n                    wm_SemUnlock(&client->lockClient);\n                }\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n            break;\n        }\n\n        case MQTT_MSG_WRITE:\n        case MQTT_MSG_WRITE_PAYLOAD:\n        default:\n        {\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"MqttClient_WaitType: Invalid state %d!\", *mms_stat);\n        #endif\n            rc = MQTT_CODE_ERROR_STAT;\n            break;\n        }\n    } /* switch (*mms_stat) */\n\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc != MQTT_CODE_CONTINUE)\n#endif\n    {\n        /* reset state */\n        *mms_stat = MQTT_MSG_BEGIN;\n    }\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (readLocked) {\n        wm_SemUnlock(&client->lockRecv);\n    }\n#endif\n    if (rc < 0) {\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_WaitType: Failure: %s (%d)\",\n            MqttClient_ReturnCodeToString(rc), rc);\n    #endif\n        return rc;\n    }\n\n    if (!waitMatchFound) {\n        /* if we get here, then the we are still waiting for a packet */\n        goto wait_again;\n    }\n\n    return rc;\n}\n",
    "target": 0,
    "idx": 2039083
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "static int MqttClient_WaitType(MqttClient *client, void *packet_obj,\n    byte wait_type, word16 wait_packet_id, int timeout_ms)\n{\n    int rc;\n    word16 packet_id;\n    MqttPacketType packet_type;\n#ifdef WOLFMQTT_MULTITHREAD\n    MqttPendResp *pendResp;\n    int readLocked;\n#endif\n    MqttMsgStat* mms_stat;\n    int waitMatchFound;\n\n    if (client == NULL || packet_obj == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    /* all packet type structures must have MqttMsgStat at top */\n    mms_stat = (MqttMsgStat*)packet_obj;\n\nwait_again:\n\n    /* initialize variables */\n    packet_id = 0;\n    packet_type = MQTT_PACKET_TYPE_RESERVED;\n#ifdef WOLFMQTT_MULTITHREAD\n    pendResp = NULL;\n    readLocked = 0;\n#endif\n    waitMatchFound = 0;\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"MqttClient_WaitType: Type %s (%d), ID %d\",\n        MqttPacket_TypeDesc((MqttPacketType)wait_type),\n            wait_type, wait_packet_id);\n#endif\n\n    switch ((int)*mms_stat)\n    {\n        case MQTT_MSG_BEGIN:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Lock recv socket mutex */\n            rc = wm_SemLock(&client->lockRecv);\n            if (rc != 0) {\n                PRINTF(\"MqttClient_WaitType: recv lock error!\");\n                return rc;\n            }\n            readLocked = 1;\n        #endif\n\n            /* reset the packet state */\n            client->packet.stat = MQTT_PK_BEGIN;\n        }\n        FALL_THROUGH;\n\n    #ifdef WOLFMQTT_V5\n        case MQTT_MSG_AUTH:\n    #endif\n        case MQTT_MSG_WAIT:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if packet type and id have already completed */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, (MqttPacketType)wait_type, \n                    wait_packet_id, &pendResp)) {\n                    if (pendResp->packetDone) {\n                        /* pending response is already done, so return */\n                        rc = pendResp->packet_ret;\n                    #ifdef WOLFMQTT_DEBUG_CLIENT\n                        PRINTF(\"PendResp already Done %p: Rc %d\", pendResp, rc);\n                    #endif\n                        MqttClient_RespList_Remove(client, pendResp);\n                        wm_SemUnlock(&client->lockClient);\n                        wm_SemUnlock(&client->lockRecv);\n                        return rc;\n                    }\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            *mms_stat = MQTT_MSG_WAIT;\n\n            /* Wait for packet */\n            rc = MqttPacket_Read(client, client->rx_buf, client->rx_buf_len,\n                    timeout_ms);\n            /* handle failure */\n            if (rc <= 0) {\n                break;\n            }\n\n            /* capture length read */\n            client->packet.buf_len = rc;\n\n            /* Decode Packet - get type and id */\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, NULL, &packet_type, NULL, &packet_id);\n            if (rc < 0) {\n                break;\n            }\n\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"Read Packet: Len %d, Type %d, ID %d\",\n                client->packet.buf_len, packet_type, packet_id);\n        #endif\n\n            *mms_stat = MQTT_MSG_READ;\n        }\n        FALL_THROUGH;\n\n        case MQTT_MSG_READ:\n        case MQTT_MSG_READ_PAYLOAD:\n        {\n            MqttPacketType use_packet_type;\n            void* use_packet_obj;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            readLocked = 1; /* if in this state read is locked */\n        #endif\n\n            /* read payload state only happens for publish messages */\n            if (*mms_stat == MQTT_MSG_READ_PAYLOAD) {\n                packet_type = MQTT_PACKET_TYPE_PUBLISH;\n            }\n\n            /* Determine if we received data for this request */\n            if ((wait_type == MQTT_PACKET_TYPE_ANY ||\n                 wait_type == packet_type ||\n                 (MqttIsPubRespPacket(packet_type) &&\n                  MqttIsPubRespPacket(wait_type))) &&\n                (wait_packet_id == 0 || wait_packet_id == packet_id))\n            {\n                use_packet_obj = packet_obj;\n                waitMatchFound = 1;\n            }\n            else {\n                /* use generic packet object */\n                use_packet_obj = &client->msg;\n            }\n            use_packet_type = packet_type;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if we have a pending response for this packet */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, packet_type, packet_id,\n                                                               &pendResp)) {\n                    /* we found packet match this incoming read packet */\n                    pendResp->packetProcessing = 1;\n                    use_packet_obj = pendResp->packet_obj;\n                    use_packet_type = pendResp->packet_type;\n                    /* req from another thread... not a match */\n                    waitMatchFound = 0;\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            /* Perform packet handling for publish callback and QoS */\n            rc = MqttClient_HandlePacket(client, use_packet_type,\n                use_packet_obj, timeout_ms);\n\n        #ifdef WOLFMQTT_NONBLOCK\n            if (rc == MQTT_CODE_CONTINUE) {\n                /* we have received some data, so keep the recv\n                    mutex lock active and return */\n                return rc;\n            }\n        #endif\n\n            /* handle success case */\n            if (rc >= 0) {\n                rc = MQTT_CODE_SUCCESS;\n            }\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (pendResp) {\n                /* Mark pending response entry done */\n                if (wm_SemLock(&client->lockClient) == 0) {\n                    pendResp->packetDone = 1;\n                    pendResp->packet_ret = rc;\n                #ifdef WOLFMQTT_DEBUG_CLIENT\n                    PRINTF(\"PendResp Done %p\", pendResp);\n                #endif\n                    pendResp = NULL;\n                    wm_SemUnlock(&client->lockClient);\n                }\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n            break;\n        }\n\n        case MQTT_MSG_WRITE:\n        case MQTT_MSG_WRITE_PAYLOAD:\n        default:\n        {\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"MqttClient_WaitType: Invalid state %d!\", *mms_stat);\n        #endif\n            rc = MQTT_CODE_ERROR_STAT;\n            break;\n        }\n    } /* switch (*mms_stat) */\n\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc != MQTT_CODE_CONTINUE)\n#endif\n    {\n        /* reset state */\n        *mms_stat = MQTT_MSG_BEGIN;\n    }\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (readLocked) {\n        wm_SemUnlock(&client->lockRecv);\n    }\n#endif\n    if (rc < 0) {\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_WaitType: Failure: %s (%d)\",\n            MqttClient_ReturnCodeToString(rc), rc);\n    #endif\n        return rc;\n    }\n\n    if (!waitMatchFound) {\n        /* if we get here, then the we are still waiting for a packet */\n        goto wait_again;\n    }\n\n    return rc;\n}\n",
    "target": 0,
    "idx": 2039103
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "MRB_API mrb_value\nmrb_funcall_with_block(mrb_state *mrb, mrb_value self, mrb_sym mid, mrb_int argc, const mrb_value *argv, mrb_value blk)\n{\n  mrb_value val;\n  int ai = mrb_gc_arena_save(mrb);\n\n  if (!mrb->jmp) {\n    struct mrb_jmpbuf c_jmp;\n    ptrdiff_t nth_ci = mrb->c->ci - mrb->c->cibase;\n\n    MRB_TRY(&c_jmp) {\n      mrb->jmp = &c_jmp;\n      /* recursive call */\n      val = mrb_funcall_with_block(mrb, self, mid, argc, argv, blk);\n      mrb->jmp = 0;\n    }\n    MRB_CATCH(&c_jmp) { /* error */\n      while (nth_ci < (mrb->c->ci - mrb->c->cibase)) {\n        cipop(mrb);\n      }\n      mrb->jmp = 0;\n      val = mrb_obj_value(mrb->exc);\n    }\n    MRB_END_EXC(&c_jmp);\n    mrb->jmp = 0;\n  }\n  else {\n    mrb_method_t m;\n    struct RClass *c;\n    mrb_callinfo *ci = mrb->c->ci;\n    mrb_int n = mrb_ci_nregs(ci);\n    ptrdiff_t voff = -1;\n\n    if (!mrb->c->stbase) {\n      stack_init(mrb);\n    }\n    if (ci - mrb->c->cibase > MRB_CALL_LEVEL_MAX) {\n      mrb_exc_raise(mrb, mrb_obj_value(mrb->stack_err));\n    }\n    if (mrb->c->stbase <= argv && argv < mrb->c->stend) {\n      voff = argv - mrb->c->stbase;\n    }\n    if (argc < 0) {\n      mrb_raisef(mrb, E_ARGUMENT_ERROR, \"negative argc for funcall (%i)\", argc);\n    }\n    c = mrb_class(mrb, self);\n    m = mrb_method_search_vm(mrb, &c, mid);\n    mrb_stack_extend(mrb, n + argc + 3);\n    if (MRB_METHOD_UNDEF_P(m) || argc >= 15) {\n      mrb_value args = mrb_ary_new_from_values(mrb, argc, argv);\n\n      ci->stack[n+1] = args;\n      argc = 15;\n    }\n    if (MRB_METHOD_UNDEF_P(m)) {\n      mrb_sym missing = MRB_SYM(method_missing);\n      mrb_value args = ci->stack[n+1];\n\n      m = mrb_method_search_vm(mrb, &c, missing);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        mrb_method_missing(mrb, mid, self, args);\n      }\n      mrb_ary_unshift(mrb, args, mrb_symbol_value(mid));\n      mrb_stack_extend(mrb, n+2);\n      ci->stack[n+1] = args;\n      argc = 15;\n    }\n    ci = cipush(mrb, n, 0, c, NULL, mid, argc);\n    if (MRB_METHOD_PROC_P(m)) {\n      struct RProc *p = MRB_METHOD_PROC(m);\n\n      mrb_vm_ci_proc_set(ci, p);\n      if (!MRB_PROC_CFUNC_P(p)) {\n        mrb_stack_extend(mrb, p->body.irep->nregs + argc);\n      }\n    }\n    if (voff >= 0) {\n      argv = mrb->c->stbase + voff;\n    }\n    ci->stack[0] = self;\n    if (argc < 15) {\n      if (argc > 0)\n        stack_copy(ci->stack+1, argv, argc);\n      ci->stack[argc+1] = blk;\n    }\n    else {\n      ci->stack[2] = blk;\n    }\n\n    if (MRB_METHOD_CFUNC_P(m)) {\n      ci->cci = CINFO_DIRECT;\n      val = MRB_METHOD_CFUNC(m)(mrb, self);\n      cipop(mrb);\n    }\n    else {\n      ci->cci = CINFO_SKIP;\n      val = mrb_run(mrb, MRB_METHOD_PROC(m), self);\n    }\n  }\n  mrb_gc_arena_restore(mrb, ai);\n  mrb_gc_protect(mrb, val);\n  return val;\n}\n",
    "target": 0,
    "idx": 2039940
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "  Status DecodeArrowDense(int num_values, int null_count, const uint8_t* valid_bits,\n                          int64_t valid_bits_offset,\n                          typename EncodingTraits<ByteArrayType>::Accumulator* out,\n                          int* out_num_values) {\n    ArrowBinaryHelper helper(out);\n\n    std::vector<ByteArray> values(num_values);\n    const int num_valid_values = GetInternal(values.data(), num_values - null_count);\n    DCHECK_EQ(num_values - null_count, num_valid_values);\n\n    auto values_ptr = reinterpret_cast<const ByteArray*>(values.data());\n    int value_idx = 0;\n\n    RETURN_NOT_OK(VisitNullBitmapInline(\n        valid_bits, valid_bits_offset, num_values, null_count,\n        [&]() {\n          const auto& val = values_ptr[value_idx];\n          if (ARROW_PREDICT_FALSE(!helper.CanFit(val.len))) {\n            RETURN_NOT_OK(helper.PushChunk());\n          }\n          RETURN_NOT_OK(helper.Append(val.ptr, static_cast<int32_t>(val.len)));\n          ++value_idx;\n          return Status::OK();\n        },\n        [&]() {\n          RETURN_NOT_OK(helper.AppendNull());\n          --null_count;\n          return Status::OK();\n        }));\n\n    DCHECK_EQ(null_count, 0);\n    *out_num_values = num_valid_values;\n    return Status::OK();\n  }\n  int GetInternal(ByteArray* buffer, int max_values) {\n    // Decode up to `max_values` strings into an internal buffer\n    // and reference them into `buffer`.\n    max_values = std::min(max_values, num_valid_values_);\n    if (max_values == 0) {\n      return max_values;\n    }\n\n    suffix_decoder_.Decode(buffer, max_values);\n\n    int64_t data_size = 0;\n    const int32_t* prefix_len_ptr =\n        reinterpret_cast<const int32_t*>(buffered_prefix_length_->data()) +\n        prefix_len_offset_;\n    for (int i = 0; i < max_values; ++i) {\n      if (ARROW_PREDICT_FALSE(prefix_len_ptr[i] < 0)) {\n        throw ParquetException(\"negative prefix length in DELTA_BYTE_ARRAY\");\n      }\n      if (ARROW_PREDICT_FALSE(AddWithOverflow(data_size, prefix_len_ptr[i], &data_size) ||\n                              AddWithOverflow(data_size, buffer[i].len, &data_size))) {\n        throw ParquetException(\"excess expansion in DELTA_BYTE_ARRAY\");\n      }\n    }\n    PARQUET_THROW_NOT_OK(buffered_data_->Resize(data_size));\n\n    string_view prefix{last_value_};\n    uint8_t* data_ptr = buffered_data_->mutable_data();\n    for (int i = 0; i < max_values; ++i) {\n      if (ARROW_PREDICT_FALSE(static_cast<size_t>(prefix_len_ptr[i]) > prefix.length())) {\n        throw ParquetException(\"prefix length too large in DELTA_BYTE_ARRAY\");\n      }\n      memcpy(data_ptr, prefix.data(), prefix_len_ptr[i]);\n      // buffer[i] currently points to the string suffix\n      memcpy(data_ptr + prefix_len_ptr[i], buffer[i].ptr, buffer[i].len);\n      buffer[i].ptr = data_ptr;\n      buffer[i].len += prefix_len_ptr[i];\n      data_ptr += buffer[i].len;\n      prefix = string_view{reinterpret_cast<const char*>(buffer[i].ptr), buffer[i].len};\n    }\n    prefix_len_offset_ += max_values;\n    this->num_values_ -= max_values;\n    num_valid_values_ -= max_values;\n    last_value_ = std::string{prefix};\n\n    if (num_valid_values_ == 0) {\n      last_value_in_previous_page_ = last_value_;\n    }\n    return max_values;\n  }\n",
    "target": 0,
    "idx": 2041221
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "int ndlz4_decompress(const uint8_t *input, int32_t input_len, uint8_t *output, int32_t output_len,\n                    uint8_t meta, blosc2_dparams *dparams) {\n  BLOSC_UNUSED_PARAM(meta);\n  BLOSC_UNUSED_PARAM(dparams);\n\n  uint8_t* ip = (uint8_t*)input;\n  uint8_t* ip_limit = ip + input_len;\n  uint8_t* op = (uint8_t*)output;\n  uint8_t ndim;\n  uint32_t blockshape[2];\n  uint32_t eshape[2];\n  uint8_t* buffercpy;\n  uint8_t local_buffer[16];\n  uint8_t token;\n  if (NDLZ_UNEXPECT_CONDITIONAL(input_len < 8)) {\n    return 0;\n  }\n\n  /* we start with literal copy */\n  ndim = *ip;\n  ip ++;\n  if (ndim != 2) {\n    fprintf(stderr, \"This codec only works for ndim = 2\");\n    return -1;\n  }\n  memcpy(&blockshape[0], ip, 4);\n  ip += 4;\n  memcpy(&blockshape[1], ip, 4);\n  ip += 4;\n  eshape[0] = ((blockshape[0] + 3) / 4) * 4;\n  eshape[1] = ((blockshape[1] + 3) / 4) * 4;\n\n  if (NDLZ_UNEXPECT_CONDITIONAL(output_len < blockshape[0] * blockshape[1])) {\n    return 0;\n  }\n  memset(op, 0, blockshape[0] * blockshape[1]);\n\n  uint32_t i_stop[2];\n  for (int i = 0; i < 2; ++i) {\n    i_stop[i] = eshape[i] / 4;\n  }\n\n\n  /* main loop */\n  uint32_t ii[2];\n  uint32_t padding[2];\n  uint32_t ind;\n  uint8_t cell_aux[16];\n  for (ii[0] = 0; ii[0] < i_stop[0]; ++ii[0]) {\n    for (ii[1] = 0; ii[1] < i_stop[1]; ++ii[1]) {      // for each cell\n      if (NDLZ_UNEXPECT_CONDITIONAL(ip > ip_limit)) {\n        printf(\"Literal copy \\n\");\n        return 0;\n      }\n      if (ii[0] == i_stop[0] - 1) {\n        padding[0] = (blockshape[0] % 4 == 0) ? 4 : blockshape[0] % 4;\n      } else {\n        padding[0] = 4;\n      }\n      if (ii[1] == i_stop[1] - 1) {\n        padding[1] = (blockshape[1] % 4 == 0) ? 4 : blockshape[1] % 4;\n      } else {\n        padding[1] = 4;\n      }\n      token = *ip++;\n      if (token == 0){    // no match\n        buffercpy = ip;\n        ip += padding[0] * padding[1];\n      } else if (token == (uint8_t)((1U << 7U) | (1U << 6U))) {  // cell match\n        uint16_t offset = *((uint16_t*) ip);\n        buffercpy = ip - offset - 1;\n        ip += 2;\n      } else if (token == (uint8_t)(1U << 6U)) { // whole cell of same element\n        buffercpy = cell_aux;\n        memset(buffercpy, *ip, 16);\n        ip++;\n      } else if (token >= 224) { // three rows match\n        buffercpy = local_buffer;\n        uint16_t offset = *((uint16_t*) ip);\n        offset += 3;\n        ip += 2;\n        int i, j, k;\n        if ((token >> 3U) == 28) {\n          i = 1;\n          j = 2;\n          k = 3;\n        } else {\n          i = 0;\n          if ((token >> 3U) < 30) {\n            j = 1;\n            k = 2;\n          } else {\n            k = 3;\n            if ((token >> 3U) == 30) {\n              j = 1;\n            } else {\n              j = 2;\n            }\n          }\n        }\n        memcpy(&buffercpy[i * 4], ip - offset, 4);\n        memcpy(&buffercpy[j * 4], ip - offset + 4, 4);\n        memcpy(&buffercpy[k * 4], ip - offset + 8, 4);\n        for (int l = 0; l < 4; l++) {\n          if ((l != i) && (l != j) && (l != k)) {\n            memcpy(&buffercpy[l * 4], ip, 4);\n            ip += 4;\n            break;\n          }\n        }\n\n      } else if ((token >= 128) && (token <= 191)){ // rows pair match\n        buffercpy = local_buffer;\n        uint16_t offset = *((uint16_t*) ip);\n        offset += 3;\n        ip += 2;\n        int i, j;\n        if (token == 128) {\n          i = 2;\n          j = 3;\n        } else {\n          i = (token - 128) >> 5U;\n          j = ((token - 128) >> 3U) - (i << 2U);\n        }\n        memcpy(&buffercpy[i * 4], ip - offset, 4);\n        memcpy(&buffercpy[j * 4], ip - offset + 4, 4);\n        for (int k = 0; k < 4; k++) {\n          if ((k != i) && (k != j)) {\n            memcpy(&buffercpy[k * 4], ip, 4);\n            ip += 4;\n          }\n        }\n      } else if ((token >= 40) && (token <= 63)) {  // 2 rows pair matches\n        buffercpy = local_buffer;\n        uint16_t offset_1 = *((uint16_t*) ip);\n        offset_1 += 5;\n        ip += 2;\n        uint16_t offset_2 = *((uint16_t*) ip);\n        offset_2 += 5;\n        ip += 2;\n        int i, j, k, l, m;\n        i = 0;\n        j = ((token - 32) >> 3U);\n        l = -1;\n        for (k = 1; k < 4; k++) {\n          if ((k != i) && (k != j)) {\n            if (l == -1) {\n              l = k;\n            } else {\n              m = k;\n            }\n          }\n        }\n        memcpy(&buffercpy[i * 4], ip - offset_1, 4);\n        memcpy(&buffercpy[j * 4], ip - offset_1 + 4, 4);\n        memcpy(&buffercpy[l * 4], ip - offset_2, 4);\n        memcpy(&buffercpy[m * 4], ip - offset_2 + 4, 4);\n\n      } else {\n        printf(\"Invalid token: %u at cell [%d, %d]\\n\", token, ii[0], ii[1]);\n        return 0;\n      }\n      // fill op with buffercpy\n      uint32_t orig = ii[0] * 4 * blockshape[1] + ii[1] * 4;\n      for (uint32_t i = 0; i < 4; i++) {\n        if (i < padding[0]) {\n          ind = orig + i * blockshape[1];\n          memcpy(&op[ind], buffercpy, padding[1]);\n        }\n        buffercpy += padding[1];\n      }\n      if (ind > (uint32_t) output_len) {\n        printf(\"Output size is bigger than max \\n\");\n        return 0;\n      }\n    }\n  }\n  ind += padding[1];\n\n  if (ind != (blockshape[0] * blockshape[1])) {\n    printf(\"Output size is not compatible with embedded blockshape \\n\");\n    return 0;\n  }\n  if (ind > (uint32_t) output_len) {\n    printf(\"Output size is bigger than max \\n\");\n    return 0;\n  }\n\n  return (int)ind;\n}\nint ndlz8_decompress(const uint8_t *input, int32_t input_len, uint8_t *output, int32_t output_len,\n                     uint8_t meta, blosc2_dparams *dparams) {\n  BLOSC_UNUSED_PARAM(meta);\n  BLOSC_UNUSED_PARAM(dparams);\n\n  const int cell_shape = 8;\n  const int cell_size = 64;\n  uint8_t* ip = (uint8_t*)input;\n  uint8_t* ip_limit = ip + input_len;\n  uint8_t* op = (uint8_t*)output;\n  uint8_t ndim;\n  uint32_t blockshape[2];\n  uint32_t eshape[2];\n  uint8_t* buffercpy;\n  uint8_t token;\n  if (NDLZ_UNEXPECT_CONDITIONAL(input_len < 8)) {\n    return 0;\n  }\n\n  /* we start with literal copy */\n  ndim = *ip;\n  ip ++;\n  if (ndim != 2) {\n    fprintf(stderr, \"This codec only works for ndim = 2\");\n    return -1;\n  }\n  memcpy(&blockshape[0], ip, 4);\n  ip += 4;\n  memcpy(&blockshape[1], ip, 4);\n  ip += 4;\n  eshape[0] = ((blockshape[0] + 7) / cell_shape) * cell_shape;\n  eshape[1] = ((blockshape[1] + 7) / cell_shape) * cell_shape;\n\n  if (NDLZ_UNEXPECT_CONDITIONAL(output_len < blockshape[0] * blockshape[1])) {\n    return 0;\n  }\n  memset(op, 0, blockshape[0] * blockshape[1]);\n\n  uint32_t i_stop[2];\n  for (int i = 0; i < 2; ++i) {\n    i_stop[i] = eshape[i] / cell_shape;\n  }\n\n\n  /* main loop */\n  uint32_t ii[2];\n  uint32_t padding[2];\n  uint32_t ind = 0;\n  uint8_t* local_buffer = malloc(cell_size);\n  uint8_t* cell_aux = malloc(cell_size);\n  for (ii[0] = 0; ii[0] < i_stop[0]; ++ii[0]) {\n    for (ii[1] = 0; ii[1] < i_stop[1]; ++ii[1]) {      // for each cell\n      if (NDLZ_UNEXPECT_CONDITIONAL(ip > ip_limit)) {\n        printf(\"Literal copy \\n\");\n        free(local_buffer);\n        free(cell_aux);\n        return 0;\n      }\n      if (ii[0] == i_stop[0] - 1) {\n        padding[0] = (blockshape[0] % cell_shape == 0) ? cell_shape : blockshape[0] % cell_shape;\n      } else {\n        padding[0] = cell_shape;\n      }\n      if (ii[1] == i_stop[1] - 1) {\n        padding[1] = (blockshape[1] % cell_shape == 0) ? cell_shape : blockshape[1] % cell_shape;\n      } else {\n        padding[1] = cell_shape;\n      }\n      token = *ip++;\n      uint8_t match_type = (token >> 3U);\n      if (token == 0){    // no match\n        buffercpy = ip;\n        ip += padding[0] * padding[1];\n      } else if (token == (uint8_t)((1U << 7U) | (1U << 6U))) {  // cell match\n        uint16_t offset = *((uint16_t*) ip);\n        buffercpy = ip - offset - 1;\n        ip += 2;\n      } else if (token == (uint8_t)(1U << 6U)) { // whole cell of same element\n        buffercpy = cell_aux;\n        memset(buffercpy, *ip, cell_size);\n        ip++;\n      } else if (match_type == 21) {    // triple match\n        buffercpy = local_buffer;\n        int row = (int) (token & 7);\n        uint16_t offset = *((uint16_t*) ip);\n        ip += 2;\n        for (int l = 0; l < 3; l++) {\n          memcpy(&buffercpy[(row + l) * cell_shape],\n                 ip - sizeof(token) - sizeof(offset) - offset + l * cell_shape, cell_shape);\n        }\n        for (int l = 0; l < cell_shape; l++) {\n          if ((l < row) || (l > row + 2)) {\n            memcpy(&buffercpy[l * cell_shape], ip, cell_shape);\n            ip += cell_shape;\n          }\n        }\n      } else if (match_type == 17) {    // pair match\n        buffercpy = local_buffer;\n        int row = (int) (token & 7);\n        uint16_t offset = *((uint16_t*) ip);\n        ip += 2;\n        for (int l = 0; l < 2; l++) {\n          memcpy(&buffercpy[(row + l) * cell_shape],\n                 ip - sizeof(token) - sizeof(offset) - offset + l * cell_shape, cell_shape);\n        }\n        for (int l = 0; l < cell_shape; l++) {\n          if ((l < row) || (l > row + 1)) {\n            memcpy(&buffercpy[l * cell_shape], ip, cell_shape);\n            ip += cell_shape;\n          }\n        }\n      } else {\n        printf(\"Invalid token: %u at cell [%d, %d]\\n\", token, ii[0], ii[1]);\n        free(local_buffer);\n        free(cell_aux);\n        return 0;\n      }\n\n      uint32_t orig = ii[0] * cell_shape * blockshape[1] + ii[1] * cell_shape;\n      for (uint32_t i = 0; i < (uint32_t) cell_shape; i++) {\n        if (i < padding[0]) {\n          ind = orig + i * blockshape[1];\n          memcpy(&op[ind], buffercpy, padding[1]);\n        }\n        buffercpy += padding[1];\n      }\n      if (ind > (uint32_t) output_len) {\n        printf(\"Output size is bigger than max \\n\");\n        free(local_buffer);\n        free(cell_aux);\n        return 0;\n      }\n    }\n  }\n  ind += padding[1];\n\n  free(cell_aux);\n  free(local_buffer);\n\n  if (ind != (blockshape[0] * blockshape[1])) {\n    printf(\"Output size is not compatible with embedded blockshape \\n\");\n    return 0;\n  }\n  if (ind > (uint32_t) output_len) {\n    printf(\"Output size is bigger than max \\n\");\n    return 0;\n  }\n\n  return (int)ind;\n}\n",
    "target": 0,
    "idx": 2042131
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "static\nvoid InStringSymbol(cmsIT8* it8)\n{\n    while (isseparator(it8->ch))\n        NextCh(it8);\n\n    if (it8->ch == '\\'' || it8->ch == '\\\"')\n    {\n        int sng;\n\n        sng = it8->ch;\n        StringClear(it8->str);\n\n        NextCh(it8);\n\n        while (it8->ch != sng) {\n\n            if (it8->ch == '\\n' || it8->ch == '\\r' || it8->ch == 0) break;\n            else {\n                StringAppend(it8->str, (char)it8->ch);\n                NextCh(it8);\n            }\n        }\n\n        it8->sy = SSTRING;\n        NextCh(it8);        \n    }\n    else\n        SynError(it8, \"String expected\");\n\n}\n",
    "target": 0,
    "idx": 2042227
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "static size_t generateRandomSequences(FUZZ_dataProducer_t* producer,\n                                      size_t literalsSizeLimit, size_t dictSize,\n                                      size_t windowLog, ZSTD_sequenceFormat_e mode)\n{\n    const uint32_t repCode = 0;  /* not used by sequence ingestion api */\n    const uint32_t windowSize = 1 << windowLog;\n    const uint32_t blockSizeMax = MIN(128 << 10, 1 << windowLog);\n    uint32_t matchLengthMax = ZSTD_FUZZ_MATCHLENGTH_MAXSIZE;\n    uint32_t bytesGenerated = 0;\n    uint32_t nbSeqGenerated = 0;\n    uint32_t isFirstSequence = 1;\n    uint32_t blockSize = 0;\n\n    if (mode == ZSTD_sf_explicitBlockDelimiters) {\n        /* ensure that no sequence can be larger than one block */\n        literalsSizeLimit = MIN(literalsSizeLimit, blockSizeMax/2);\n        matchLengthMax = MIN(matchLengthMax, blockSizeMax/2);\n    }\n\n    while ( nbSeqGenerated < ZSTD_FUZZ_MAX_NBSEQ-2 /* extra room for explicit delimiters */\n         && bytesGenerated < ZSTD_FUZZ_GENERATED_SRC_MAXSIZE\n         && !FUZZ_dataProducer_empty(producer)) {\n        uint32_t matchLength;\n        uint32_t matchBound = matchLengthMax;\n        uint32_t offset;\n        uint32_t offsetBound;\n        const uint32_t minLitLength = (isFirstSequence && (dictSize == 0));\n        const uint32_t litLength = FUZZ_dataProducer_uint32Range(producer, minLitLength, (uint32_t)literalsSizeLimit);\n        bytesGenerated += litLength;\n        if (bytesGenerated > ZSTD_FUZZ_GENERATED_SRC_MAXSIZE) {\n            break;\n        }\n        offsetBound = (bytesGenerated > windowSize) ? windowSize : bytesGenerated + (uint32_t)dictSize;\n        offset = FUZZ_dataProducer_uint32Range(producer, 1, offsetBound);\n        if (dictSize > 0 && bytesGenerated <= windowSize) {\n            /* Prevent match length from being such that it would be associated with an offset too large\n             * from the decoder's perspective. If not possible (match would be too small),\n             * then reduce the offset if necessary.\n             */\n            const size_t bytesToReachWindowSize = windowSize - bytesGenerated;\n            if (bytesToReachWindowSize < ZSTD_MINMATCH_MIN) {\n                const uint32_t newOffsetBound = offsetBound > windowSize ? windowSize : offsetBound;\n                offset = FUZZ_dataProducer_uint32Range(producer, 1, newOffsetBound);\n            } else {\n                matchBound = MIN(matchLengthMax, (uint32_t)bytesToReachWindowSize);\n            }\n        }\n        matchLength = FUZZ_dataProducer_uint32Range(producer, ZSTD_MINMATCH_MIN, matchBound);\n        bytesGenerated += matchLength;\n        if (bytesGenerated > ZSTD_FUZZ_GENERATED_SRC_MAXSIZE) {\n            break;\n        }\n        {   ZSTD_Sequence seq = {offset, litLength, matchLength, repCode};\n            const uint32_t lastLits = FUZZ_dataProducer_uint32Range(producer, 0, litLength);\n            #define SPLITPROB 6000\n            #define SPLITMARK 5234\n            const int split = (FUZZ_dataProducer_uint32Range(producer, 0, SPLITPROB) == SPLITMARK);\n            if (mode == ZSTD_sf_explicitBlockDelimiters) {\n                const size_t seqSize = seq.litLength + seq.matchLength;\n                if (blockSize + seqSize > blockSizeMax) {  /* reaching limit : must end block now */\n                    const ZSTD_Sequence endBlock = {0, 0, 0, 0};\n                    generatedSequences[nbSeqGenerated++] = endBlock;\n                    blockSize = seqSize;\n                }\n                if (split) {\n                    const ZSTD_Sequence endBlock = {0, lastLits, 0, 0};\n                    generatedSequences[nbSeqGenerated++] = endBlock;\n                    assert(lastLits <= seq.litLength);\n                    seq.litLength -= lastLits;\n                    blockSize = seqSize - lastLits;\n                } else {\n                    blockSize += seqSize;\n                }\n            }\n            generatedSequences[nbSeqGenerated++] = seq;\n            isFirstSequence = 0;\n    }   }\n    if (mode == ZSTD_sf_explicitBlockDelimiters) {\n        /* always end sequences with a block delimiter */\n        const ZSTD_Sequence endBlock = {0, 0, 0, 0};\n        assert(nbSeqGenerated < ZSTD_FUZZ_MAX_NBSEQ);\n        generatedSequences[nbSeqGenerated++] = endBlock;\n    }\n\n    return nbSeqGenerated;\n}\n",
    "target": 0,
    "idx": 2044122
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "GF_Err diST_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DIMSScriptTypesBox *p = (GF_DIMSScriptTypesBox *)s;\n\n\tp->content_script_types = gf_malloc(sizeof(char) * (s->size+1));\n\tif (!p->content_script_types) return GF_OUT_OF_MEM;\n\tgf_bs_read_data(bs, p->content_script_types, s->size);\n\tp->content_script_types[s->size] = 0;\n\treturn GF_OK;\n}\n",
    "target": 0,
    "idx": 2044221
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "static int\ncosm_new_file(struct sc_profile *profile, struct sc_card *card,\n\t      unsigned int type, unsigned int num, struct sc_file **out)\n{\n\tstruct sc_file *file = NULL;\n\tconst char *_template = NULL, *desc = NULL;\n\tunsigned int structure = 0xFFFFFFFF;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\tsc_log(card->ctx,  \"type %X; num %i\\n\", type,\n\t\t num);\n\twhile (1) {\n\t\tswitch (type) {\n\t\tcase SC_PKCS15_TYPE_PRKEY_EC:\n\t\t\tdesc = \"EC private key\";\n\t\t\t_template = \"private-key\";\n\t\t\tstructure = SC_CARDCTL_OBERTHUR_KEY_EC_CRT;\n\t\t\tbreak;\n\t\tcase SC_PKCS15_TYPE_PUBKEY_EC:\n\t\t\tdesc = \"EC public key\";\n\t\t\t_template = \"public-key\";\n\t\t\tstructure = SC_CARDCTL_OBERTHUR_KEY_EC_PUBLIC;\n\t\t\tbreak;\n\t\tcase SC_PKCS15_TYPE_PRKEY_RSA:\n\t\t\tdesc = \"RSA private key\";\n\t\t\t_template = \"private-key\";\n\t\t\tstructure = SC_CARDCTL_OBERTHUR_KEY_RSA_CRT;\n\t\t\tbreak;\n\t\tcase SC_PKCS15_TYPE_PUBKEY_RSA:\n\t\t\tdesc = \"RSA public key\";\n\t\t\t_template = \"public-key\";\n\t\t\tstructure = SC_CARDCTL_OBERTHUR_KEY_RSA_PUBLIC;\n\t\t\tbreak;\n\t\tcase SC_PKCS15_TYPE_PRKEY:\n\t\t\tdesc = \"extractable private key\";\n\t\t\t_template = \"extractable-key\";\n\t\t\tbreak;\n\t\tcase SC_PKCS15_TYPE_CERT:\n\t\t\tdesc = \"certificate\";\n\t\t\t_template = \"certificate\";\n\t\t\tbreak;\n\t\tcase SC_PKCS15_TYPE_DATA_OBJECT:\n\t\t\tdesc = \"data object\";\n\t\t\t_template = \"data\";\n\t\t\tbreak;\n\t\t}\n\t\tif (_template)\n\t\t\tbreak;\n\t\t/* If this is a specific type such as\n\t\t * SC_PKCS15_TYPE_CERT_FOOBAR, fall back to\n\t\t * the generic class (SC_PKCS15_TYPE_CERT)\n\t\t */\n\t\tif (!(type & ~SC_PKCS15_TYPE_CLASS_MASK)) {\n\t\t\tsc_log(card->ctx, \n\t\t\t\t \"File type %X not supported by card driver\",\n\t\t\t\t type);\n\t\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t\t}\n\t\ttype &= SC_PKCS15_TYPE_CLASS_MASK;\n\t}\n\n\tsc_log(card->ctx,  \"template %s; num %i\\n\",\n\t\t _template, num);\n\tif (sc_profile_get_file(profile, _template, &file) < 0) {\n\t\tsc_log(card->ctx, \n\t\t\t \"Profile doesn't define %s template '%s'\\n\", desc,\n\t\t\t _template);\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t}\n\n\tif (file->path.len < 1) {\n\t\tsc_file_free(file);\n\t\treturn SC_ERROR_INTERNAL;\n\t}\n\n\tfile->id &= 0xFF00;\n\tfile->id |= (num & 0x00FF);\n\n\tfile->path.value[file->path.len - 1] = (num & 0xFF);\n\tfile->type = SC_FILE_TYPE_INTERNAL_EF;\n\tfile->ef_structure = structure;\n\n\tsc_log(card->ctx, \n\t\t \"file size %\"SC_FORMAT_LEN_SIZE_T\"u; ef type %i/%i; id %04X, path_len %\"SC_FORMAT_LEN_SIZE_T\"u\\n\",\n\t\t file->size, file->type, file->ef_structure, file->id,\n\t\t file->path.len);\n\tsc_log(card->ctx,  \"file path: %s\",\n\t\t sc_print_path(&(file->path)));\n\t*out = file;\n\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_SUCCESS);\n}\n",
    "target": 0,
    "idx": 2046002
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "static int\nmyeid_new_file(sc_profile_t *profile, sc_card_t *card,\n\t\tunsigned int type, unsigned int num,\n\t\tsc_file_t **out) {\n\tsc_file_t *file;\n\tsc_path_t *p;\n\tchar name[64];\n\tconst char *tag = NULL;\n\tint r;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\tswitch (type) {\n\tcase SC_PKCS15_TYPE_PRKEY_RSA:\n\tcase SC_PKCS15_TYPE_PRKEY_EC:\n\t\ttag = \"private-key\";\n\t\tbreak;\n\tcase SC_PKCS15_TYPE_PUBKEY_RSA:\n\tcase SC_PKCS15_TYPE_PUBKEY_EC:\n\t\ttag = \"public-key\";\n\t\tbreak;\n\tcase SC_PKCS15_TYPE_SKEY_GENERIC:\n\tcase SC_PKCS15_TYPE_SKEY_DES:\n\tcase SC_PKCS15_TYPE_SKEY_3DES:\n\t\ttag = \"secret-key\";\n\t\tbreak;\n\tdefault:\n\t\tif ((type & SC_PKCS15_TYPE_CLASS_MASK) == SC_PKCS15_TYPE_CERT)\n\t\t\ttag = \"certificate\";\n\t\telse if ((type & SC_PKCS15_TYPE_CLASS_MASK) == SC_PKCS15_TYPE_DATA_OBJECT)\n\t\t\ttag = \"data\";\n\t\tbreak;\n\t}\n\n\tif (!tag) {\n\t\tsc_log(card->ctx, \"Unsupported file type\");\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\n\t/* Get template from profile  */\n\tsnprintf(name, sizeof (name), \"template-%s\", tag);\n\tif (sc_profile_get_file(profile, name, &file) < 0) {\n\t\tsc_log(card->ctx, \"Profile doesn't define %s\", name);\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t}\n\n\t/* Auto-increment FID for next object */\n\tfile->id += num;\n\tp = &file->path;\n\t*p = profile->df_info->file->path;\n\tif (p->len >= SC_MAX_PATH_SIZE) {\n\t\tsc_log(card->ctx, \"Wrong path length\");\n\t\treturn SC_ERROR_INTERNAL;\n\t}\n\tp->value[p->len++] = (u8) (file->id / 256);\n\tp->value[p->len++] = (u8) (file->id % 256);\n\n\t/* Increment FID until there's no file with such path */\n\tr = sc_select_file(card, p, NULL);\n\twhile (r == 0) {\n\t\tfile->id++;\n\t\tp->value[p->len - 2] = (u8) (file->id / 256);\n\t\tp->value[p->len - 1] = (u8) (file->id % 256);\n\t\tr = sc_select_file(card, p, NULL);\n\t}\n\n\t*out = file;\n\tLOG_FUNC_RETURN(card->ctx, 0);\n}\nstatic int\nmyeid_create_key(struct sc_profile *profile, struct sc_pkcs15_card *p15card,\n\t\tstruct sc_pkcs15_object *object) {\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_card *card = p15card->card;\n\tstruct sc_pkcs15_prkey_info *prkey_info = (struct sc_pkcs15_prkey_info *) object->data;\n\tstruct sc_pkcs15_skey_info *skey_info = (struct sc_pkcs15_skey_info *) object->data;\n\tstruct sc_pkcs15_id *id;\n\tstruct sc_path *path;\n\tint *key_reference;\n\tstruct sc_file *file = NULL;\n\tstruct sc_pkcs15_object *pin_object = NULL;\n\tstruct sc_pkcs15_auth_info *pkcs15_auth_info = NULL;\n\tunsigned char sec_attrs[] = {0xFF, 0xFF, 0xFF};\n\tint r, ef_structure = 0, keybits = 0, pin_reference = -1;\n\tunsigned char prop_info[] = {0x00, 0x00};\n\tint extractable = FALSE;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tswitch (object->type) {\n\t\tcase SC_PKCS15_TYPE_PRKEY_RSA:\n\t\t\tef_structure = SC_CARDCTL_MYEID_KEY_RSA;\n\t\t\tkeybits = prkey_info->modulus_length;\n\t\t\tbreak;\n\t\tcase SC_PKCS15_TYPE_PRKEY_EC:\n\t\t\tef_structure = SC_CARDCTL_MYEID_KEY_EC;\n\t\t\tkeybits = prkey_info->field_length;\n\t\t\tbreak;\n\t\tcase SC_PKCS15_TYPE_SKEY_DES:\n\t\tcase SC_PKCS15_TYPE_SKEY_3DES:\n\t\t\tef_structure = SC_CARDCTL_MYEID_KEY_DES;\n\t\t\tkeybits = skey_info->value_len;\n\t\t\tif ((skey_info->access_flags & SC_PKCS15_PRKEY_ACCESS_EXTRACTABLE) == SC_PKCS15_PRKEY_ACCESS_EXTRACTABLE)\n\t\t\t\textractable = TRUE;\n\t\t\tbreak;\n\t\tcase SC_PKCS15_TYPE_SKEY_GENERIC:\n\t\t\tkeybits = skey_info->value_len;\n\t\t\tif ((skey_info->access_flags & SC_PKCS15_PRKEY_ACCESS_EXTRACTABLE) == SC_PKCS15_PRKEY_ACCESS_EXTRACTABLE)\n\t\t\t\textractable = TRUE;\n\t\t\tswitch (skey_info->key_type) {\n\t\t\tcase CKK_AES:\n\t\t\t\tef_structure = SC_CARDCTL_MYEID_KEY_AES;\n\t\t\t\tbreak;\n\t\t\tcase CKK_DES:\n\t\t\t\tef_structure = SC_CARDCTL_MYEID_KEY_DES;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (object->type == SC_PKCS15_TYPE_SKEY_GENERIC)\n\t\t\t\t\tef_structure = SC_CARDCTL_MYEID_KEY_GENERIC_SECRET;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t}\n\tif (!ef_structure) {\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS,\n\t\t\t\t\"Unsupported key type\");\n\t}\n\n\tmyeid_fixup_supported_algos(profile, p15card, object);\n\n\tif ((object->type & SC_PKCS15_TYPE_CLASS_MASK) == SC_PKCS15_TYPE_PRKEY) {\n\t\tid = &prkey_info->id;\n\t\tpath = &prkey_info->path;\n\t\tkey_reference = &prkey_info->key_reference;\n\t} else {\n\t\tid = &skey_info->id;\n\t\tpath = &skey_info->path;\n\t\tkey_reference = &skey_info->key_reference;\n\t}\n\n\tsc_log(ctx, \"create MyEID key ID:%s\", sc_pkcs15_print_id(id));\n\n\t/* Get the private key file */\n\tr = myeid_new_file(profile, card, object->type, *key_reference, &file);\n\tLOG_TEST_RET(ctx, r, \"Cannot get new MyEID key file\");\n\n\tif (!file || !file->path.len || file->path.len > SC_MAX_PATH_SIZE) {\n\t\tsc_file_free(file);\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, \"Cannot determine key file\");\n\t}\n\n\tsc_log(ctx, \"Key file size %d\", keybits);\n\tfile->size = keybits;\n\tfile->ef_structure = ef_structure;\n\n\tmemcpy(path->value, &file->path.value, file->path.len);\n\t*key_reference = file->path.value[file->path.len - 1] & 0xFF;\n\n\tsc_log(ctx, \"Path of MyEID key file to create %s\",\n\t\t\tsc_print_path(&file->path));\n\n\tif (object->auth_id.len >= 1) {\n\t\tr = sc_pkcs15_find_pin_by_auth_id(p15card, &object->auth_id, &pin_object);\n\n\t\tif (r != SC_SUCCESS)\n\t\t\tsc_file_free(file);\n\t\tLOG_TEST_RET(ctx, r, \"Failed to get pin object by auth_id\");\n\n\t\tif (pin_object->type != SC_PKCS15_TYPE_AUTH_PIN) {\n\t\t\tsc_file_free(file);\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_OBJECT_NOT_VALID, \"Invalid object returned when locating pin object.\");\n\t\t}\n\n\t\tpkcs15_auth_info =  (struct sc_pkcs15_auth_info*) pin_object->data;\n\n\t\tif (pkcs15_auth_info == NULL || pkcs15_auth_info->auth_type != SC_PKCS15_PIN_AUTH_TYPE_PIN) {\n\t\t\tsc_file_free(file);\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_OBJECT_NOT_VALID, \"NULL or invalid sc_pkcs15_auth_info in pin object\");\n\t\t}\n\n\t\tpin_reference = pkcs15_auth_info->attrs.pin.reference;\n\n\t\tif (pin_reference >= 1 && pin_reference < MYEID_MAX_PINS) {\n\t\t\tsec_attrs[0] = (pin_reference << 4 | (pin_reference & 0x0F));\n\t\t\tsec_attrs[1] = (pin_reference << 4 | (pin_reference & 0x0F));\n\t\t\tsc_file_set_sec_attr(file, sec_attrs, sizeof(sec_attrs));\n\t\t}\n\t}\n\telse {\n\t\tsc_file_free(file);\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, \"Invalid AuthID value for a private key.\");\n\t}\n\n\t/* TODO: fill all proprietary attributes here based on the object */\n\n\tif (object->user_consent != 0 && pin_reference >= 1)\n\t    prop_info[0] |= (pin_reference << 4);\n\n\tif (extractable)\n\t    prop_info[1] |= MYEID_PROP_INFO_2_EXCTRACTABLE;\n\n\tif (object->session_object != 0) /* Object will be removed during next reset. */\n\t\tprop_info[1] |= MYEID_PROP_INFO_2_SESSION_OBJECT;\n\n\t/* TODO: add other flags, like CKA_TRUSTED and CKA_WRAP_WITH_TRUSTED */\n\n\tr = sc_file_set_prop_attr(file, prop_info, 2);\n\tLOG_TEST_RET(ctx, r, \"Cannot create MyEID key file\");\n\n\t/* Now create the key file */\n\tr = sc_pkcs15init_create_file(profile, p15card, file);\n\tsc_file_free(file);\n\tLOG_TEST_RET(ctx, r, \"Cannot create MyEID key file\");\n\n\tLOG_FUNC_RETURN(ctx, r);\n}\n",
    "target": 0,
    "idx": 2047769
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "static int simple_str_to_doublestr(const char *from, char *result, int result_len, char **to)\n{\n    char *start = NULL, *end = NULL, *cur = (char *)from;\n\n#if !defined(HAVE_GETNUMBERFORMAT)\n    struct lconv *loc_data = localeconv();\n#endif\n    int i = 0;\n    double dtest;\n\n    /*sanity checks */\n    if (!from || !result) {\n        return 1;\n    }\n\n    /*skip the white spaces at the beginning */\n    while (*cur && isspace((int)*cur))\n        cur++;\n\n    start = cur;\n    /* copy the part that looks like a double into result.\n     * during the copy, we give ourselves a chance to convert the '.'\n     * into the decimal separator of the current locale.\n     */\n    while (*cur && (isdigit((int)*cur) || *cur == '.' || *cur == '+' || *cur == '-')) {\n        ++cur;\n    }\n    end = cur;\n    if (end - start + 1 > result_len) {\n        /*huh hoh, number is too big. getting out */\n        return 1;\n    }\n\n    /* copy the float number string into tmp_buf, and take\n     * care to have the (optional) decimal separator be the one\n     * of the current locale.\n     */\n#if !defined(HAVE_GETNUMBERFORMAT)\n    for (i = 0; i < end - start; ++i) {\n        if (start[i] == '.' && loc_data && loc_data->decimal_point && loc_data->decimal_point[0]\n            && loc_data->decimal_point[0] != '.') {\n            /*replace '.' by the digit separator of the current locale */\n            result[i] = loc_data->decimal_point[0];\n        } else {\n            result[i] = start[i];\n        }\n    }\n#else\n    GetNumberFormat(LOCALE_SYSTEM_DEFAULT, 0, start, NULL, result, result_len);\n#endif\n    if (to) {\n        *to = end;\n    }\n\n    /* now try to convert to a floating point number, to check for validity only */\n    if (sscanf(result, \"%lf\", &dtest) != 1) {\n        return 1;\n    }\n    return 0;\n}\nvoid test_geo_props(void)\n{\n    int estate;\n    icalcomponent *c;\n    icalproperty *p;\n\n    c = icalparser_parse_string(\"BEGIN:VEVENT\\n\" \"GEO:49.42612;7.75473\\n\" \"END:VEVENT\\n\");\n    ok(\"icalparser_parse_string()\", (c != NULL));\n    if (!c) {\n        exit(EXIT_FAILURE);\n    }\n    if (VERBOSE)\n        printf(\"%s\", icalcomponent_as_ical_string(c));\n    p = icalcomponent_get_first_property(c, ICAL_GEO_PROPERTY);\n    str_is(\"icalproperty_get_value_as_string() works\",\n           icalproperty_get_value_as_string(p), \"49.42612;7.75473\");\n    icalcomponent_free(c);\n\n    c = icalparser_parse_string(\"BEGIN:VEVENT\\n\" \"GEO:-0;+0\\n\" \"END:VEVENT\\n\");\n    ok(\"icalparser_parse_string()\", (c != NULL));\n    if (!c) {\n        exit(EXIT_FAILURE);\n    }\n    if (VERBOSE)\n        printf(\"%s\", icalcomponent_as_ical_string(c));\n    p = icalcomponent_get_first_property(c, ICAL_GEO_PROPERTY);\n    str_is(\"icalproperty_get_value_as_string() works\",\n           icalproperty_get_value_as_string(p), \"-0;+0\");\n    icalcomponent_free(c);\n\n    /* failure situations */\n    estate = icalerror_get_errors_are_fatal();\n    icalerror_set_errors_are_fatal(0);\n    c = icalparser_parse_string(\"BEGIN:VEVENT\\n\" \"GEO:-0a;+0\\n\" \"END:VEVENT\\n\");\n    if (!c) {\n        exit(EXIT_FAILURE);\n    }\n    if (VERBOSE)\n        printf(\"%s\", icalcomponent_as_ical_string(c));\n    p = icalcomponent_get_first_property(c, ICAL_GEO_PROPERTY);\n    ok(\"expected fail icalcomponent_get_first_property()\", (p == NULL));\n    icalcomponent_free(c);\n\n    c = icalparser_parse_string(\"BEGIN:VEVENT\\n\" \"GEO:16.815151515151515151;+0\\n\" \"END:VEVENT\\n\");\n    if (!c) {\n        exit(EXIT_FAILURE);\n    }\n    if (VERBOSE)\n        printf(\"%s\", icalcomponent_as_ical_string(c));\n    p = icalcomponent_get_first_property(c, ICAL_GEO_PROPERTY);\n    ok(\"expected fail icalcomponent_get_first_property()\", (p == NULL));\n    icalcomponent_free(c);\n\n    icalerror_set_errors_are_fatal(estate);\n}\nvoid test_zoneinfo_stuff(void)\n{\n#if defined(HAVE_SETENV)\n    setenv(\"TZDIR\", TEST_DATADIR, 1);\n#else\n    char tzdir[256] = {0};\n    strncat(tzdir, \"TZDIR=\" TEST_DATADIR, 255);\n    putenv(tzdir);\n#endif\n    icaltzutil_set_zone_directory(NULL); /*resets to empty */\n    str_is(\"icaltzutil_get_zone_directory by TZDIR\", icaltzutil_get_zone_directory(), TEST_DATADIR);\n    icaltzutil_set_zone_directory(\"foo\");\n    str_is(\"icaltzutil_get_zone_directory\", icaltzutil_get_zone_directory(), \"foo\");\n\n    /* reset the environment */\n#if defined(HAVE_SETENV)\n    unsetenv(\"TZDIR\");\n#else\n    strcpy(tzdir, \"TZDIR=\");\n    putenv(tzdir);\n#endif\n    icaltzutil_set_zone_directory(NULL);\n}\n",
    "target": 0,
    "idx": 2047986
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "void ScaleForFrameNumber(unsigned int frame, unsigned int initial_w,\n                         unsigned int initial_h, unsigned int *w,\n                         unsigned int *h, bool flag_codec,\n                         bool smaller_width_larger_size_) {\n  if (smaller_width_larger_size_) {\n    if (frame < 30) {\n      *w = initial_w;\n      *h = initial_h;\n      return;\n    }\n    if (frame < 100) {\n      *w = initial_w * 7 / 10;\n      *h = initial_h * 16 / 10;\n      return;\n    }\n    return;\n  }\n  if (frame < 10) {\n    *w = initial_w;\n    *h = initial_h;\n    return;\n  }\n  if (frame < 20) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }\n  if (frame < 30) {\n    *w = initial_w / 2;\n    *h = initial_h / 2;\n    return;\n  }\n  if (frame < 40) {\n    *w = initial_w;\n    *h = initial_h;\n    return;\n  }\n  if (frame < 50) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }\n  if (frame < 60) {\n    *w = initial_w / 2;\n    *h = initial_h / 2;\n    return;\n  }\n  if (frame < 70) {\n    *w = initial_w;\n    *h = initial_h;\n    return;\n  }\n  if (frame < 80) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }\n  if (frame < 90) {\n    *w = initial_w / 2;\n    *h = initial_h / 2;\n    return;\n  }\n  if (frame < 100) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }\n  if (frame < 110) {\n    *w = initial_w;\n    *h = initial_h;\n    return;\n  }\n  if (frame < 120) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }\n  if (frame < 130) {\n    *w = initial_w / 2;\n    *h = initial_h / 2;\n    return;\n  }\n  if (frame < 140) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }\n  if (frame < 150) {\n    *w = initial_w;\n    *h = initial_h;\n    return;\n  }\n  if (frame < 160) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }\n  if (frame < 170) {\n    *w = initial_w / 2;\n    *h = initial_h / 2;\n    return;\n  }\n  if (frame < 180) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }\n  if (frame < 190) {\n    *w = initial_w;\n    *h = initial_h;\n    return;\n  }\n  if (frame < 200) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }\n  if (frame < 210) {\n    *w = initial_w / 2;\n    *h = initial_h / 2;\n    return;\n  }\n  if (frame < 220) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }\n  if (frame < 230) {\n    *w = initial_w;\n    *h = initial_h;\n    return;\n  }\n  if (frame < 240) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }\n  if (frame < 250) {\n    *w = initial_w / 2;\n    *h = initial_h / 2;\n    return;\n  }\n  if (frame < 260) {\n    *w = initial_w;\n    *h = initial_h;\n    return;\n  }\n  // Go down very low.\n  if (frame < 270) {\n    *w = initial_w / 4;\n    *h = initial_h / 4;\n    return;\n  }\n  if (flag_codec == 1) {\n    // Cases that only works for VP9.\n    // For VP9: Swap width and height of original.\n    if (frame < 320) {\n      *w = initial_h;\n      *h = initial_w;\n      return;\n    }\n  }\n  *w = initial_w;\n  *h = initial_h;\n}\nint vp9_alloc_context_buffers(VP9_COMMON *cm, int width, int height) {\n  int new_mi_size;\n\n  vp9_set_mb_mi(cm, width, height);\n  new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);\n  if (cm->mi_alloc_size < new_mi_size) {\n    cm->free_mi(cm);\n    if (cm->alloc_mi(cm, new_mi_size)) goto fail;\n  }\n\n  if (cm->seg_map_alloc_size < cm->mi_rows * cm->mi_cols) {\n    // Create the segmentation map structure and set to 0.\n    free_seg_map(cm);\n    if (alloc_seg_map(cm, cm->mi_rows * cm->mi_cols)) goto fail;\n  }\n\n  if (cm->above_context_alloc_cols < cm->mi_cols) {\n    vpx_free(cm->above_context);\n    cm->above_context = (ENTROPY_CONTEXT *)vpx_calloc(\n        2 * mi_cols_aligned_to_sb(cm->mi_cols) * MAX_MB_PLANE,\n        sizeof(*cm->above_context));\n    if (!cm->above_context) goto fail;\n\n    vpx_free(cm->above_seg_context);\n    cm->above_seg_context = (PARTITION_CONTEXT *)vpx_calloc(\n        mi_cols_aligned_to_sb(cm->mi_cols), sizeof(*cm->above_seg_context));\n    if (!cm->above_seg_context) goto fail;\n    cm->above_context_alloc_cols = cm->mi_cols;\n  }\n\n  if (vp9_alloc_loop_filter(cm)) goto fail;\n\n  return 0;\n\nfail:\n  // clear the mi_* values to force a realloc on resync\n  vp9_set_mb_mi(cm, 0, 0);\n  vp9_free_context_buffers(cm);\n  return 1;\n}\n\nvoid vp9_change_config(struct VP9_COMP *cpi, const VP9EncoderConfig *oxcf) {\n  VP9_COMMON *const cm = &cpi->common;\n  RATE_CONTROL *const rc = &cpi->rc;\n  int last_w = cpi->oxcf.width;\n  int last_h = cpi->oxcf.height;\n\n  vp9_init_quantizer(cpi);\n  if (cm->profile != oxcf->profile) cm->profile = oxcf->profile;\n  cm->bit_depth = oxcf->bit_depth;\n  cm->color_space = oxcf->color_space;\n  cm->color_range = oxcf->color_range;\n\n  cpi->target_level = oxcf->target_level;\n  cpi->keep_level_stats = oxcf->target_level != LEVEL_MAX;\n  set_level_constraint(&cpi->level_constraint,\n                       get_level_index(cpi->target_level));\n\n  if (cm->profile <= PROFILE_1)\n    assert(cm->bit_depth == VPX_BITS_8);\n  else\n    assert(cm->bit_depth > VPX_BITS_8);\n\n  cpi->oxcf = *oxcf;\n#if CONFIG_VP9_HIGHBITDEPTH\n  cpi->td.mb.e_mbd.bd = (int)cm->bit_depth;\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n\n  if ((oxcf->pass == 0) && (oxcf->rc_mode == VPX_Q)) {\n    rc->baseline_gf_interval = FIXED_GF_INTERVAL;\n  } else {\n    rc->baseline_gf_interval = (MIN_GF_INTERVAL + MAX_GF_INTERVAL) / 2;\n  }\n\n  cpi->refresh_golden_frame = 0;\n  cpi->refresh_last_frame = 1;\n  cm->refresh_frame_context = 1;\n  cm->reset_frame_context = 0;\n\n  vp9_reset_segment_features(&cm->seg);\n  vp9_set_high_precision_mv(cpi, 0);\n\n  {\n    int i;\n\n    for (i = 0; i < MAX_SEGMENTS; i++)\n      cpi->segment_encode_breakout[i] = cpi->oxcf.encode_breakout;\n  }\n  cpi->encode_breakout = cpi->oxcf.encode_breakout;\n\n  vp9_set_rc_buffer_sizes(cpi);\n\n  // Set up frame rate and related parameters rate control values.\n  vp9_new_framerate(cpi, cpi->framerate);\n\n  // Set absolute upper and lower quality limits\n  rc->worst_quality = cpi->oxcf.worst_allowed_q;\n  rc->best_quality = cpi->oxcf.best_allowed_q;\n\n  cm->interp_filter = cpi->sf.default_interp_filter;\n\n  if (cpi->oxcf.render_width > 0 && cpi->oxcf.render_height > 0) {\n    cm->render_width = cpi->oxcf.render_width;\n    cm->render_height = cpi->oxcf.render_height;\n  } else {\n    cm->render_width = cpi->oxcf.width;\n    cm->render_height = cpi->oxcf.height;\n  }\n  if (last_w != cpi->oxcf.width || last_h != cpi->oxcf.height) {\n    cm->width = cpi->oxcf.width;\n    cm->height = cpi->oxcf.height;\n    cpi->external_resize = 1;\n  }\n\n  if (cpi->initial_width) {\n    int new_mi_size = 0;\n    vp9_set_mb_mi(cm, cm->width, cm->height);\n    new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);\n    if (cm->mi_alloc_size < new_mi_size) {\n      vp9_free_context_buffers(cm);\n      alloc_compressor_data(cpi);\n      realloc_segmentation_maps(cpi);\n      cpi->initial_width = cpi->initial_height = 0;\n      cpi->external_resize = 0;\n    } else if (cm->mi_alloc_size == new_mi_size &&\n               (cpi->oxcf.width > last_w || cpi->oxcf.height > last_h)) {\n      if (vp9_alloc_loop_filter(cm)) {\n        vpx_internal_error(&cm->error, VPX_CODEC_MEM_ERROR,\n                           \"Failed to allocate loop filter data\");\n      }\n    }\n  }\n\n  if (cm->current_video_frame == 0 || last_w != cpi->oxcf.width ||\n      last_h != cpi->oxcf.height)\n    update_frame_size(cpi);\n\n  if (last_w != cpi->oxcf.width || last_h != cpi->oxcf.height) {\n    memset(cpi->consec_zero_mv, 0,\n           cm->mi_rows * cm->mi_cols * sizeof(*cpi->consec_zero_mv));\n    if (cpi->oxcf.aq_mode == CYCLIC_REFRESH_AQ)\n      vp9_cyclic_refresh_reset_resize(cpi);\n    rc->rc_1_frame = 0;\n    rc->rc_2_frame = 0;\n  }\n\n  if ((cpi->svc.number_temporal_layers > 1 && cpi->oxcf.rc_mode == VPX_CBR) ||\n      ((cpi->svc.number_temporal_layers > 1 ||\n        cpi->svc.number_spatial_layers > 1) &&\n       cpi->oxcf.pass != 1)) {\n    vp9_update_layer_context_change_config(cpi,\n                                           (int)cpi->oxcf.target_bandwidth);\n  }\n\n  vp9_check_reset_rc_flag(cpi);\n\n  cpi->alt_ref_source = NULL;\n  rc->is_src_frame_alt_ref = 0;\n\n#if 0\n  // Experimental RD Code\n  cpi->frame_distortion = 0;\n  cpi->last_frame_distortion = 0;\n#endif\n\n  set_tile_limits(cpi);\n\n  cpi->ext_refresh_frame_flags_pending = 0;\n  cpi->ext_refresh_frame_context_pending = 0;\n\n#if CONFIG_VP9_HIGHBITDEPTH\n  highbd_set_var_fns(cpi);\n#endif\n\n  vp9_set_row_mt(cpi);\n}\n",
    "target": 0,
    "idx": 2048609
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "static void\ndynapi_set_helper (void *restrict old, const Dwg_DYNAPI_field *restrict f,\n                   const Dwg_Version_Type dwg_version,\n                   const void *restrict value, const bool is_utf8)\n{\n  // TODO: sanity checks. is_malloc (TF), copy zero's (TFv)\n  // if text strcpy or wcscpy, or do utf8 conversion.\n  //if ((char*)old && f->is_malloc)\n  //  free (old);\n  if (f->is_malloc)\n    {\n      // NULL ptr\n      if (!*(char**)value)\n        memcpy (old, value, sizeof (char*));\n      // fixed length (but not yet TF)\n      else if (strEQc (f->type, \"TFv\"))\n        {\n          char *str = (char *)calloc (f->size, 1);\n          strncpy (str, *(char**)value, f->size);\n          memcpy (old, &str, sizeof (char*)); // size of ptr\n        }\n      // ascii\n      else if (f->is_string && dwg_version < R_2007)\n        {\n          // FIXME: TF size calc is probably wrong\n          char *str = (char *)malloc (strlen (*(char**)value)+1);\n          strcpy (str, *(char**)value);\n          memcpy (old, &str, sizeof (char*)); // size of ptr\n        }\n      // or wide\n      else if (strNE (f->type, \"TF\") && (f->is_string && dwg_version >= R_2007))\n        {\n          BITCODE_TU wstr;\n          if (is_utf8)\n            wstr = bit_utf8_to_TU (*(char **)value, 0);\n          else // source is already TU\n            {\n#if defined(HAVE_WCHAR_H) && defined(SIZEOF_WCHAR_T) && SIZEOF_WCHAR_T == 2\n              wstr = (BITCODE_TU)malloc (2 * (wcslen (*(wchar_t **)value) + 1));\n              wcscpy ((wchar_t *)wstr, *(wchar_t **)value);\n#else\n              int length = 0;\n              for (; (*(BITCODE_TU*)value)[length]; length++)\n                ;\n              length++;\n              wstr = (BITCODE_TU)malloc (2 * length);\n              memcpy (wstr, value, length * 2);\n#endif\n            }\n          memcpy (old, &wstr, sizeof (char*)); // size of ptr\n        }\n      else\n        memcpy (old, value, sizeof (char*));\n    }\n  else\n    memcpy (old, value, f->size);\n}\n",
    "target": 0,
    "idx": 2049613
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "static void\nudiv(mrb_state *mrb, mpz_t *qq, mpz_t *rr, mpz_t *xx, mpz_t *yy)\n{\n  /* simple cases */\n  int cmp = ucmp(xx, yy);\n  if (cmp == 0) {\n    mpz_set_int(mrb, qq, 1);\n    zero(rr);\n    return;\n  }\n  else if (cmp < 0) {\n    zero(qq);\n    mpz_set(mrb, rr, xx);\n    return;\n  }\n\n  mpz_t q, x, y;\n  size_t i;\n\n  mrb_assert(!uzero(yy));       /* divided by zero */\n  mpz_init(mrb, &q);\n  mpz_init(mrb, &x);\n  mpz_init(mrb, &y);\n  mpz_realloc(mrb, &x, xx->sz+1);\n  size_t yd = digits(yy);\n  size_t ns = lzb(yy->p[yd-1]);\n  ulshift(mrb, &x, xx, ns);\n  ulshift(mrb, &y, yy, ns);\n  size_t xd = digits(&x);\n  mpz_realloc(mrb, &q, xd);\n  mp_dbl_limb z = y.p[yd-1];\n  if (xd>=yd) {\n    for (size_t j=xd-yd;; j--) {\n      mp_dbl_limb_signed b=0;\n      mp_dbl_limb qhat;\n\n      if (j+yd == xd)\n        qhat = x.p[j+yd-1] / z;\n      else\n        qhat = (((mp_dbl_limb)x.p[j+yd] << DIG_SIZE) + x.p[j+yd-1]) / z;\n      if (qhat) {\n        for (i=0; i<yd; i++) {\n          mp_dbl_limb zz = qhat * y.p[i];\n          mp_dbl_limb_signed u = LOW(b)+x.p[i+j]-LOW(zz);\n          x.p[i+j] = LOW(u);\n          b = HIGH(b) - HIGH(zz) + HIGH(u);\n        }\n        b += x.p[i+j];\n      }\n      for (; b!=0; qhat--) {\n        mp_dbl_limb c = 0;\n        for (i=0; i<yd; i++) {\n          c += (mp_dbl_limb)x.p[i+j] + (mp_dbl_limb)y.p[i];\n          x.p[i+j] = LOW(c);\n          c = HIGH(c);\n        }\n        b += c;\n      }\n      q.p[j] = (mp_limb)qhat;\n      if (j == 0) break;\n    }\n  }\n  x.sz = yy->sz;\n  urshift(mrb, rr, &x, ns);\n  trim(&q);\n  mpz_move(mrb, qq, &q);\n  mpz_clear(mrb, &x);\n  mpz_clear(mrb, &y);\n}\n",
    "target": 0,
    "idx": 2049763
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "static int write_compression_header(blosc2_context* context, bool extended_header) {\n  blosc_header header;\n  int dont_split;\n  int dict_training = context->use_dict && (context->dict_cdict == NULL);\n\n  context->header_flags = 0;\n\n  if (context->clevel == 0) {\n    /* Compression level 0 means buffer to be memcpy'ed */\n    context->header_flags |= (uint8_t)BLOSC_MEMCPYED;\n  }\n  if (context->sourcesize < BLOSC_MIN_BUFFERSIZE) {\n    /* Buffer is too small.  Try memcpy'ing. */\n    context->header_flags |= (uint8_t)BLOSC_MEMCPYED;\n  }\n\n  bool memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;\n  if (extended_header) {\n    /* Indicate that we are building an extended header */\n    context->header_overhead = BLOSC_EXTENDED_HEADER_LENGTH;\n    context->header_flags |= (BLOSC_DOSHUFFLE | BLOSC_DOBITSHUFFLE);\n    /* Store filter pipeline info at the end of the header */\n    if (dict_training || memcpyed) {\n      context->bstarts = NULL;\n      context->output_bytes = context->header_overhead;\n    } else {\n      context->bstarts = (int32_t*)(context->dest + context->header_overhead);\n      context->output_bytes = context->header_overhead + (int32_t)sizeof(int32_t) * context->nblocks;\n    }\n  } else {\n    // Regular header\n    context->header_overhead = BLOSC_MIN_HEADER_LENGTH;\n    if (memcpyed) {\n      context->bstarts = NULL;\n      context->output_bytes = context->header_overhead;\n    } else {\n      context->bstarts = (int32_t *) (context->dest + context->header_overhead);\n      context->output_bytes = context->header_overhead + (int32_t)sizeof(int32_t) * context->nblocks;\n    }\n  }\n\n  // when memcpyed bit is set, there is no point in dealing with others\n  if (!memcpyed) {\n    if (context->filter_flags & BLOSC_DOSHUFFLE) {\n      /* Byte-shuffle is active */\n      context->header_flags |= BLOSC_DOSHUFFLE;\n    }\n\n    if (context->filter_flags & BLOSC_DOBITSHUFFLE) {\n      /* Bit-shuffle is active */\n      context->header_flags |= BLOSC_DOBITSHUFFLE;\n    }\n\n    if (context->filter_flags & BLOSC_DODELTA) {\n      /* Delta is active */\n      context->header_flags |= BLOSC_DODELTA;\n    }\n\n    dont_split = !split_block(context, context->typesize,\n                              context->blocksize);\n\n    /* dont_split is in bit 4 */\n    context->header_flags |= dont_split << 4;\n    /* codec starts at bit 5 */\n    uint8_t compformat = compcode_to_compformat(context->compcode);\n    context->header_flags |= compformat << 5;\n  }\n\n  // Create blosc header and store to dest\n  blosc2_intialize_header_from_context(context, &header, extended_header);\n\n  memcpy(context->dest, &header, (extended_header) ?\n    BLOSC_EXTENDED_HEADER_LENGTH : BLOSC_MIN_HEADER_LENGTH);\n\n  return 1;\n}\nint main(void) {\n  int64_t *_src;\n  char *result;\n  size_t i;\n\n  blosc2_init();\n  blosc1_set_compressor(\"blosclz\");\n\n  /* Initialize buffers */\n  src = blosc_test_malloc(BUFFER_ALIGN_SIZE, size);\n  srccpy = blosc_test_malloc(BUFFER_ALIGN_SIZE, size);\n  dest = blosc_test_malloc(BUFFER_ALIGN_SIZE, size + BLOSC2_MAX_OVERHEAD);\n  dest2 = blosc_test_malloc(BUFFER_ALIGN_SIZE, size);\n  _src = (int64_t *)src;\n  for (i=0; i < (size / sizeof(int64_t)); i++) {\n    _src[i] = (int64_t)i;\n  }\n  memcpy(srccpy, src, size);\n\n  /* Run all the suite */\n  result = all_tests();\n  if (result != 0) {\n    printf(\" (%s)\\n\", result);\n  }\n  else {\n    printf(\" ALL TESTS PASSED\");\n  }\n  printf(\"\\tTests run: %d\\n\", tests_run);\n\n  blosc_test_free(src);\n  blosc_test_free(srccpy);\n  blosc_test_free(dest);\n  blosc_test_free(dest2);\n\n  blosc2_destroy();\n\n  return result != 0;\n}\n",
    "target": 0,
    "idx": 2050433
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "void QuickTimeVideo::decodeBlock(std::string const& entered_from) {\n  const long bufMinSize = 4;\n  DataBuf buf(bufMinSize + 1);\n  uint64_t size = 0;\n  buf.data()[4] = '\\0';\n\n  io_->read(buf.data(), 4);\n  if (io_->eof()) {\n    continueTraversing_ = false;\n    return;\n  }\n\n  size = buf.read_uint32(0, bigEndian);\n\n  io_->readOrThrow(buf.data(), 4);\n\n  // we have read 2x 4 bytes\n  size_t hdrsize = 8;\n\n  if (size == 1) {\n    // The box size is encoded as a uint64_t, so we need to read another 8 bytes.\n    DataBuf data(8);\n    hdrsize += 8;\n    io_->readOrThrow(data.data(), data.size());\n    size = data.read_uint64(0, bigEndian);\n  } else if (size == 0) {\n    if (entered_from == \"meta\") {\n      size = buf.read_uint32(0, bigEndian);\n      io_->readOrThrow(buf.data(), 4, Exiv2::ErrorCode::kerCorruptedMetadata);\n    }\n  }\n\n  enforce(size >= hdrsize, Exiv2::ErrorCode::kerCorruptedMetadata);\n  enforce(size - hdrsize <= io_->size() - io_->tell(), Exiv2::ErrorCode::kerCorruptedMetadata);\n  enforce(size - hdrsize <= std::numeric_limits<size_t>::max(), Exiv2::ErrorCode::kerCorruptedMetadata);\n\n  // std::cerr<<\"Tag=>\"<<buf.data()<<\"     size=>\"<<size-hdrsize << std::endl;\n  const size_t newsize = static_cast<size_t>(size - hdrsize);\n  if (newsize > buf.size()) {\n    buf.resize(newsize);\n  }\n  tagDecoder(buf, newsize);\n}  // QuickTimeVideo::decodeBlock\nvoid QuickTimeVideo::tagDecoder(Exiv2::DataBuf& buf, size_t size) {\n  assert(buf.size() > 4);\n\n  if (ignoreList(buf))\n    discard(size);\n\n  else if (dataIgnoreList(buf)) {\n    decodeBlock(Exiv2::toString(buf.data()));\n  } else if (equalsQTimeTag(buf, \"ftyp\"))\n    fileTypeDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"trak\"))\n    setMediaStream();\n\n  else if (equalsQTimeTag(buf, \"mvhd\"))\n    movieHeaderDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"tkhd\"))\n    trackHeaderDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"mdhd\"))\n    mediaHeaderDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"hdlr\"))\n    handlerDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"vmhd\"))\n    videoHeaderDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"udta\"))\n    userDataDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"dref\"))\n    multipleEntriesDecoder();\n\n  else if (equalsQTimeTag(buf, \"stsd\"))\n    sampleDesc(size);\n\n  else if (equalsQTimeTag(buf, \"stts\"))\n    timeToSampleDecoder();\n\n  else if (equalsQTimeTag(buf, \"pnot\"))\n    previewTagDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"tapt\"))\n    trackApertureTagDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"keys\"))\n    keysTagDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"url \")) {\n    Exiv2::DataBuf url(size+1);\n    io_->readOrThrow(url.data(), size);\n    url.write_uint8(size, 0);\n    if (currentStream_ == Video)\n      xmpData_[\"Xmp.video.URL\"] = Exiv2::toString(url.data());\n    else if (currentStream_ == Audio)\n      xmpData_[\"Xmp.audio.URL\"] = Exiv2::toString(url.data());\n  }\n\n  else if (equalsQTimeTag(buf, \"urn \")) {\n    Exiv2::DataBuf urn(size+1);\n    io_->readOrThrow(urn.data(), size);\n    urn.write_uint8(size, 0);\n    if (currentStream_ == Video)\n      xmpData_[\"Xmp.video.URN\"] = Exiv2::toString(urn.data());\n    else if (currentStream_ == Audio)\n      xmpData_[\"Xmp.audio.URN\"] = Exiv2::toString(urn.data());\n  }\n\n  else if (equalsQTimeTag(buf, \"dcom\")) {\n    Exiv2::DataBuf dcom(size+1);\n    io_->readOrThrow(dcom.data(), size);\n    dcom.write_uint8(size, 0);\n    xmpData_[\"Xmp.video.Compressor\"] = Exiv2::toString(dcom.data());\n  }\n\n  else if (equalsQTimeTag(buf, \"smhd\")) {\n    io_->readOrThrow(buf.data(), 4);\n    io_->readOrThrow(buf.data(), 4);\n    xmpData_[\"Xmp.audio.Balance\"] = buf.read_uint16(0, bigEndian);\n  }\n\n  else {\n    discard(size);\n  }\n}  // QuickTimeVideo::tagDecoder\n",
    "target": 0,
    "idx": 2050901
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "void QuickTimeVideo::userDataDecoder(size_t size_external) {\n  size_t cur_pos = io_->tell();\n  const TagVocabulary* td;\n  const TagVocabulary *tv, *tv_internal;\n\n  const long bufMinSize = 100;\n  DataBuf buf(bufMinSize);\n  size_t size_internal = size_external;\n  std::memset(buf.data(), 0x0, buf.size());\n\n  while ((size_internal / 4 != 0) && (size_internal > 0)) {\n    buf.data()[4] = '\\0';\n    io_->readOrThrow(buf.data(), 4);\n    const size_t size = buf.read_uint32(0, bigEndian);\n    if (size > size_internal)\n      break;\n    size_internal -= size;\n    io_->readOrThrow(buf.data(), 4);\n\n    if (buf.data()[0] == 169)\n      buf.data()[0] = ' ';\n    td = find(userDatatags, Exiv2::toString(buf.data()));\n\n    tv = find(userDataReferencetags, Exiv2::toString(buf.data()));\n\n    if (size <= 12)\n      break;\n\n    else if (equalsQTimeTag(buf, \"DcMD\") || equalsQTimeTag(buf, \"NCDT\"))\n      userDataDecoder(size - 8);\n\n    else if (equalsQTimeTag(buf, \"NCTG\"))\n      NikonTagsDecoder(size - 8);\n\n    else if (equalsQTimeTag(buf, \"TAGS\"))\n      CameraTagsDecoder(size - 8);\n\n    else if (equalsQTimeTag(buf, \"CNCV\") || equalsQTimeTag(buf, \"CNFV\") || equalsQTimeTag(buf, \"CNMN\") ||\n             equalsQTimeTag(buf, \"NCHD\") || equalsQTimeTag(buf, \"FFMV\")) {\n      io_->readOrThrow(buf.data(), size - 8);\n      xmpData_[exvGettext(tv->label_)] = Exiv2::toString(buf.data());\n    }\n\n    else if (equalsQTimeTag(buf, \"CMbo\") || equalsQTimeTag(buf, \"Cmbo\")) {\n      io_->readOrThrow(buf.data(), 2);\n      buf.data()[2] = '\\0';\n      tv_internal = find(cameraByteOrderTags, Exiv2::toString(buf.data()));\n\n      if (tv_internal)\n        xmpData_[exvGettext(tv->label_)] = exvGettext(tv_internal->label_);\n      else\n        xmpData_[exvGettext(tv->label_)] = Exiv2::toString(buf.data());\n    }\n\n    else if (tv) {\n      const size_t tv_size = size - 12;\n      if (tv_size >= buf.size()) {\n        enforce(tv_size <= io_->size() - io_->tell(), Exiv2::ErrorCode::kerCorruptedMetadata);\n        buf.resize(tv_size + 1);\n      }\n      io_->readOrThrow(buf.data(), 4);\n      io_->readOrThrow(buf.data(), tv_size);\n      buf.write_uint8(tv_size, 0); // nul-terminate string\n      xmpData_[exvGettext(tv->label_)] = Exiv2::toString(buf.data());\n    }\n\n    else if (td)\n      tagDecoder(buf, size - 8);\n  }\n\n  io_->seek(cur_pos + size_external, BasicIo::beg);\n}  // QuickTimeVideo::userDataDecoder\n",
    "target": 0,
    "idx": 2051707
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "static void rx_icmp(struct mip_if *ifp, struct pkt *pkt) {\n  // MG_DEBUG((\"ICMP %d\", (int) len));\n  if (pkt->icmp->type == 8 && pkt->ip != NULL && pkt->ip->dst == ifp->ip) {\n    struct ip *ip = tx_ip(ifp, 1, ifp->ip, pkt->ip->src,\n                          sizeof(struct icmp) + pkt->pay.len);\n    struct icmp *icmp = (struct icmp *) (ip + 1);\n    size_t len = PDIFF(ifp->tx.buf, icmp + 1), left = ifp->tx.len - len;\n    if (left > pkt->pay.len) left = pkt->pay.len;  // Don't overflow TX\n    memset(icmp, 0, sizeof(*icmp));                // Set csum to 0\n    memcpy(icmp + 1, pkt->pay.buf, left);          // Copy RX payload to TX\n    icmp->csum = ipcsum(icmp, sizeof(*icmp) + left);\n    ifp->driver->tx(ifp->tx.buf, len + left, ifp->driver_data);\n  }\n}\nint mg_base64_decode(const char *src, int n, char *dst) {\n  const char *end = src == NULL ? NULL : src + n;  // Cannot add to NULL\n  int len = 0;\n  while (src != NULL && src + 3 < end) {\n    int a = mg_b64rev(src[0]), b = mg_b64rev(src[1]), c = mg_b64rev(src[2]),\n        d = mg_b64rev(src[3]);\n    if (a == 64 || a < 0 || b == 64 || b < 0 || c < 0 || d < 0) return 0;\n    dst[len++] = (char) ((a << 2) | (b >> 4));\n    if (src[2] != '=') {\n      dst[len++] = (char) ((b << 4) | (c >> 2));\n      if (src[3] != '=') dst[len++] = (char) ((c << 6) | d);\n    }\n    src += 4;\n  }\n  dst[len] = '\\0';\n  return len;\n}\nint mg_http_parse(const char *s, size_t len, struct mg_http_message *hm) {\n  int is_response, req_len = mg_http_get_request_len((unsigned char *) s, len);\n  const char *end = s == NULL ? NULL : s + req_len, *qs;  // Cannot add to NULL\n  struct mg_str *cl;\n\n  memset(hm, 0, sizeof(*hm));\n  if (req_len <= 0) return req_len;\n\n  hm->message.ptr = hm->head.ptr = s;\n  hm->body.ptr = end;\n  hm->head.len = (size_t) req_len;\n  hm->chunk.ptr = end;\n  hm->message.len = hm->body.len = (size_t) ~0;  // Set body length to infinite\n\n  // Parse request line\n  s = skip(s, end, \" \", &hm->method);\n  s = skip(s, end, \" \", &hm->uri);\n  s = skip(s, end, \"\\r\\n\", &hm->proto);\n\n  // Sanity check. Allow protocol/reason to be empty\n  if (hm->method.len == 0 || hm->uri.len == 0) return -1;\n\n  // If URI contains '?' character, setup query string\n  if ((qs = (const char *) memchr(hm->uri.ptr, '?', hm->uri.len)) != NULL) {\n    hm->query.ptr = qs + 1;\n    hm->query.len = (size_t) (&hm->uri.ptr[hm->uri.len] - (qs + 1));\n    hm->uri.len = (size_t) (qs - hm->uri.ptr);\n  }\n\n  mg_http_parse_headers(s, end, hm->headers,\n                        sizeof(hm->headers) / sizeof(hm->headers[0]));\n  if ((cl = mg_http_get_header(hm, \"Content-Length\")) != NULL) {\n    hm->body.len = (size_t) mg_to64(*cl);\n    hm->message.len = (size_t) req_len + hm->body.len;\n  }\n\n  // mg_http_parse() is used to parse both HTTP requests and HTTP\n  // responses. If HTTP response does not have Content-Length set, then\n  // body is read until socket is closed, i.e. body.len is infinite (~0).\n  //\n  // For HTTP requests though, according to\n  // http://tools.ietf.org/html/rfc7231#section-8.1.3,\n  // only POST and PUT methods have defined body semantics.\n  // Therefore, if Content-Length is not specified and methods are\n  // not one of PUT or POST, set body length to 0.\n  //\n  // So, if it is HTTP request, and Content-Length is not set,\n  // and method is not (PUT or POST) then reset body length to zero.\n  is_response = mg_ncasecmp(hm->method.ptr, \"HTTP/\", 5) == 0;\n  if (hm->body.len == (size_t) ~0 && !is_response &&\n      mg_vcasecmp(&hm->method, \"PUT\") != 0 &&\n      mg_vcasecmp(&hm->method, \"POST\") != 0) {\n    hm->body.len = 0;\n    hm->message.len = (size_t) req_len;\n  }\n\n  // The 204 (No content) responses also have 0 body length\n  if (hm->body.len == (size_t) ~0 && is_response &&\n      mg_vcasecmp(&hm->uri, \"204\") == 0) {\n    hm->body.len = 0;\n    hm->message.len = (size_t) req_len;\n  }\n\n  return req_len;\n}\nstatic void printdirentry(const char *name, void *userdata) {\n  struct printdirentrydata *d = (struct printdirentrydata *) userdata;\n  struct mg_fs *fs = d->opts->fs == NULL ? &mg_fs_posix : d->opts->fs;\n  size_t size = 0;\n  time_t t = 0;\n  char path[MG_PATH_MAX], sz[40], mod[40];\n  int flags, n = 0;\n\n  // MG_DEBUG((\"[%s] [%s]\", d->dir, name));\n  if (mg_snprintf(path, sizeof(path), \"%s%c%s\", d->dir, '/', name) >\n      sizeof(path)) {\n    MG_ERROR((\"%s truncated\", name));\n  } else if ((flags = fs->st(path, &size, &t)) == 0) {\n    MG_ERROR((\"%lu stat(%s): %d\", d->c->id, path, errno));\n  } else {\n    const char *slash = flags & MG_FS_DIR ? \"/\" : \"\";\n    if (flags & MG_FS_DIR) {\n      mg_snprintf(sz, sizeof(sz), \"%s\", \"[DIR]\");\n    } else {\n      mg_snprintf(sz, sizeof(sz), \"%lld\", (uint64_t) size);\n    }\n#if defined(MG_HTTP_DIRLIST_TIME)\n    char time_str[30];\n    struct tm *time_info = localtime(&t);\n    strftime(time_str, sizeof time_str, \"%Y/%m/%d %H:%M:%S\", time_info);\n    mg_snprintf(mod, sizeof(mod), \"%s\", time_str);\n#elif defined(MG_HTTP_DIRLIST_TIME_UTC)\n    char time_str[30];\n    struct tm *time_info = gmtime(&t);\n    strftime(time_str, sizeof time_str, \"%Y/%m/%d %H:%M:%S\", time_info);\n    mg_snprintf(mod, sizeof(mod), \"%s\", time_str);\n#else\n    mg_snprintf(mod, sizeof(mod), \"%ld\", (unsigned long) t);\n#endif\n    n = (int) mg_url_encode(name, strlen(name), path, sizeof(path));\n    mg_printf(d->c,\n              \"  <tr><td><a href=\\\"%.*s%s\\\">%s%s</a></td>\"\n              \"<td name=%lu>%s</td><td name=%lld>%s</td></tr>\\n\",\n              n, path, slash, name, slash, (unsigned long) t, mod,\n              flags & MG_FS_DIR ? (int64_t) -1 : (int64_t) size, sz);\n  }\n}\nstatic void rx_icmp(struct mip_if *ifp, struct pkt *pkt) {\n  // MG_DEBUG((\"ICMP %d\", (int) len));\n  if (pkt->icmp->type == 8 && pkt->ip != NULL && pkt->ip->dst == ifp->ip) {\n    struct ip *ip = tx_ip(ifp, 1, ifp->ip, pkt->ip->src,\n                          sizeof(struct icmp) + pkt->pay.len);\n    struct icmp *icmp = (struct icmp *) (ip + 1);\n    size_t len = PDIFF(ifp->tx.buf, icmp + 1), left = ifp->tx.len - len;\n    if (left > pkt->pay.len) left = pkt->pay.len;  // Don't overflow TX\n    memset(icmp, 0, sizeof(*icmp));                // Set csum to 0\n    memcpy(icmp + 1, pkt->pay.buf, left);          // Copy RX payload to TX\n    icmp->csum = ipcsum(icmp, sizeof(*icmp) + left);\n    ifp->driver->tx(ifp->tx.buf, len + left, ifp->driver_data);\n  }\n}\nint mg_base64_decode(const char *src, int n, char *dst) {\n  const char *end = src == NULL ? NULL : src + n;  // Cannot add to NULL\n  int len = 0;\n  while (src != NULL && src + 3 < end) {\n    int a = mg_b64rev(src[0]), b = mg_b64rev(src[1]), c = mg_b64rev(src[2]),\n        d = mg_b64rev(src[3]);\n    if (a == 64 || a < 0 || b == 64 || b < 0 || c < 0 || d < 0) return 0;\n    dst[len++] = (char) ((a << 2) | (b >> 4));\n    if (src[2] != '=') {\n      dst[len++] = (char) ((b << 4) | (c >> 2));\n      if (src[3] != '=') dst[len++] = (char) ((c << 6) | d);\n    }\n    src += 4;\n  }\n  dst[len] = '\\0';\n  return len;\n}\nint mg_http_parse(const char *s, size_t len, struct mg_http_message *hm) {\n  int is_response, req_len = mg_http_get_request_len((unsigned char *) s, len);\n  const char *end = s == NULL ? NULL : s + req_len, *qs;  // Cannot add to NULL\n  struct mg_str *cl;\n\n  memset(hm, 0, sizeof(*hm));\n  if (req_len <= 0) return req_len;\n\n  hm->message.ptr = hm->head.ptr = s;\n  hm->body.ptr = end;\n  hm->head.len = (size_t) req_len;\n  hm->chunk.ptr = end;\n  hm->message.len = hm->body.len = (size_t) ~0;  // Set body length to infinite\n\n  // Parse request line\n  s = skip(s, end, \" \", &hm->method);\n  s = skip(s, end, \" \", &hm->uri);\n  s = skip(s, end, \"\\r\\n\", &hm->proto);\n\n  // Sanity check. Allow protocol/reason to be empty\n  if (hm->method.len == 0 || hm->uri.len == 0) return -1;\n\n  // If URI contains '?' character, setup query string\n  if ((qs = (const char *) memchr(hm->uri.ptr, '?', hm->uri.len)) != NULL) {\n    hm->query.ptr = qs + 1;\n    hm->query.len = (size_t) (&hm->uri.ptr[hm->uri.len] - (qs + 1));\n    hm->uri.len = (size_t) (qs - hm->uri.ptr);\n  }\n\n  mg_http_parse_headers(s, end, hm->headers,\n                        sizeof(hm->headers) / sizeof(hm->headers[0]));\n  if ((cl = mg_http_get_header(hm, \"Content-Length\")) != NULL) {\n    hm->body.len = (size_t) mg_to64(*cl);\n    hm->message.len = (size_t) req_len + hm->body.len;\n  }\n\n  // mg_http_parse() is used to parse both HTTP requests and HTTP\n  // responses. If HTTP response does not have Content-Length set, then\n  // body is read until socket is closed, i.e. body.len is infinite (~0).\n  //\n  // For HTTP requests though, according to\n  // http://tools.ietf.org/html/rfc7231#section-8.1.3,\n  // only POST and PUT methods have defined body semantics.\n  // Therefore, if Content-Length is not specified and methods are\n  // not one of PUT or POST, set body length to 0.\n  //\n  // So, if it is HTTP request, and Content-Length is not set,\n  // and method is not (PUT or POST) then reset body length to zero.\n  is_response = mg_ncasecmp(hm->method.ptr, \"HTTP/\", 5) == 0;\n  if (hm->body.len == (size_t) ~0 && !is_response &&\n      mg_vcasecmp(&hm->method, \"PUT\") != 0 &&\n      mg_vcasecmp(&hm->method, \"POST\") != 0) {\n    hm->body.len = 0;\n    hm->message.len = (size_t) req_len;\n  }\n\n  // The 204 (No content) responses also have 0 body length\n  if (hm->body.len == (size_t) ~0 && is_response &&\n      mg_vcasecmp(&hm->uri, \"204\") == 0) {\n    hm->body.len = 0;\n    hm->message.len = (size_t) req_len;\n  }\n\n  return req_len;\n}\nstatic void printdirentry(const char *name, void *userdata) {\n  struct printdirentrydata *d = (struct printdirentrydata *) userdata;\n  struct mg_fs *fs = d->opts->fs == NULL ? &mg_fs_posix : d->opts->fs;\n  size_t size = 0;\n  time_t t = 0;\n  char path[MG_PATH_MAX], sz[40], mod[40];\n  int flags, n = 0;\n\n  // MG_DEBUG((\"[%s] [%s]\", d->dir, name));\n  if (mg_snprintf(path, sizeof(path), \"%s%c%s\", d->dir, '/', name) >\n      sizeof(path)) {\n    MG_ERROR((\"%s truncated\", name));\n  } else if ((flags = fs->st(path, &size, &t)) == 0) {\n    MG_ERROR((\"%lu stat(%s): %d\", d->c->id, path, errno));\n  } else {\n    const char *slash = flags & MG_FS_DIR ? \"/\" : \"\";\n    if (flags & MG_FS_DIR) {\n      mg_snprintf(sz, sizeof(sz), \"%s\", \"[DIR]\");\n    } else {\n      mg_snprintf(sz, sizeof(sz), \"%lld\", (uint64_t) size);\n    }\n#if defined(MG_HTTP_DIRLIST_TIME)\n    char time_str[30];\n    struct tm *time_info = localtime(&t);\n    strftime(time_str, sizeof time_str, \"%Y/%m/%d %H:%M:%S\", time_info);\n    mg_snprintf(mod, sizeof(mod), \"%s\", time_str);\n#elif defined(MG_HTTP_DIRLIST_TIME_UTC)\n    char time_str[30];\n    struct tm *time_info = gmtime(&t);\n    strftime(time_str, sizeof time_str, \"%Y/%m/%d %H:%M:%S\", time_info);\n    mg_snprintf(mod, sizeof(mod), \"%s\", time_str);\n#else\n    mg_snprintf(mod, sizeof(mod), \"%ld\", (unsigned long) t);\n#endif\n    n = (int) mg_url_encode(name, strlen(name), path, sizeof(path));\n    mg_printf(d->c,\n              \"  <tr><td><a href=\\\"%.*s%s\\\">%s%s</a></td>\"\n              \"<td name=%lu>%s</td><td name=%lld>%s</td></tr>\\n\",\n              n, path, slash, name, slash, (unsigned long) t, mod,\n              flags & MG_FS_DIR ? (int64_t) -1 : (int64_t) size, sz);\n  }\n}\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n  mg_log_set(MG_LL_NONE);\n\n  struct mg_dns_message dm;\n  mg_dns_parse(data, size, &dm);\n  mg_dns_parse(NULL, 0, &dm);\n\n  struct mg_http_message hm;\n  mg_http_parse((const char *) data, size, &hm);\n  mg_http_parse(NULL, 0, &hm);\n\n  struct mg_str body = mg_str_n((const char *) data, size);\n  char tmp[256];\n  mg_http_get_var(&body, \"key\", tmp, sizeof(tmp));\n  mg_http_get_var(&body, \"key\", NULL, 0);\n  mg_url_decode((char *) data, size, tmp, sizeof(tmp), 1);\n  mg_url_decode((char *) data, size, tmp, 1, 1);\n  mg_url_decode(NULL, 0, tmp, 1, 1);\n\n  struct mg_mqtt_message mm;\n  mg_mqtt_parse(data, size, 0, &mm);\n  mg_mqtt_parse(NULL, 0, 0, &mm);\n  mg_mqtt_parse(data, size, 5, &mm);\n  mg_mqtt_parse(NULL, 0, 5, &mm);\n\n  mg_sntp_parse(data, size);\n  mg_sntp_parse(NULL, 0);\n\n  char buf[size * 4 / 3 + 5];  // At least 4 chars and nul termination\n  mg_base64_decode((char *) data, (int) size, buf);\n  mg_base64_decode(NULL, 0, buf);\n  mg_base64_encode(data, (int) size, buf);\n  mg_base64_encode(NULL, 0, buf);\n\n  mg_globmatch((char *) data, size, (char *) data, size);\n\n  struct mg_str k, v, s = mg_str_n((char *) data, size);\n  while (mg_commalist(&s, &k, &v)) k.len = v.len = 0;\n\n  int n;\n  mg_json_get(mg_str_n((char *) data, size), \"$\", &n);\n  mg_json_get(mg_str_n((char *) data, size), \"$.a.b\", &n);\n  mg_json_get(mg_str_n((char *) data, size), \"$[0]\", &n);\n\n  if (size > 0) {\n    struct mip_cfg cfg = {0};\n    size_t pktlen = 1540;\n    char t[sizeof(struct mip_if) + pktlen * 2 + 0 /* qlen */];\n    struct mip_if *ifp = (struct mip_if *) t;\n    struct mg_mgr mgr;\n    mg_mgr_init(&mgr);\n    if_init(ifp, &mgr, &cfg, &mip_driver_mock, NULL, pktlen, 0);\n\n    // Make a copy of the random data, in order to modify it\n    uint8_t pkt[size];\n    struct eth *eth = (struct eth *) pkt;\n    memcpy(pkt, data, size);\n    if (size > sizeof(*eth)) {\n      static size_t i;\n      uint16_t eth_types[] = {0x800, 0x800, 0x806, 0x86dd};\n      memcpy(eth->dst, ifp->mac, 6);  // Set valid destination MAC\n      eth->type = mg_htons(eth_types[i++]);\n      if (i >= sizeof(eth_types) / sizeof(eth_types[0])) i = 0;\n    }\n\n    mip_rx(ifp, (void *) pkt, size);\n    mgr.priv = NULL;  // Don't let Mongoose free() ifp\n    mg_mgr_free(&mgr);\n  }\n\n  return 0;\n}\n",
    "target": 0,
    "idx": 2051757
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "void QuickTimeVideo::tagDecoder(Exiv2::DataBuf& buf, size_t size) {\n  assert(buf.size() > 4);\n\n  if (ignoreList(buf))\n    discard(size);\n\n  else if (dataIgnoreList(buf)) {\n    decodeBlock(Exiv2::toString(buf.data()));\n  } else if (equalsQTimeTag(buf, \"ftyp\"))\n    fileTypeDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"trak\"))\n    setMediaStream();\n\n  else if (equalsQTimeTag(buf, \"mvhd\"))\n    movieHeaderDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"tkhd\"))\n    trackHeaderDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"mdhd\"))\n    mediaHeaderDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"hdlr\"))\n    handlerDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"vmhd\"))\n    videoHeaderDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"udta\"))\n    userDataDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"dref\"))\n    multipleEntriesDecoder();\n\n  else if (equalsQTimeTag(buf, \"stsd\"))\n    sampleDesc(size);\n\n  else if (equalsQTimeTag(buf, \"stts\"))\n    timeToSampleDecoder();\n\n  else if (equalsQTimeTag(buf, \"pnot\"))\n    previewTagDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"tapt\"))\n    trackApertureTagDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"keys\"))\n    keysTagDecoder(size);\n\n  else if (equalsQTimeTag(buf, \"url \")) {\n    if (currentStream_ == Video)\n      xmpData_[\"Xmp.video.URL\"] = readString(*io_, size);\n    else if (currentStream_ == Audio)\n      xmpData_[\"Xmp.audio.URL\"] = readString(*io_, size);\n  }\n\n  else if (equalsQTimeTag(buf, \"urn \")) {\n    if (currentStream_ == Video)\n      xmpData_[\"Xmp.video.URN\"] = readString(*io_, size);\n    else if (currentStream_ == Audio)\n      xmpData_[\"Xmp.audio.URN\"] = readString(*io_, size);\n  }\n\n  else if (equalsQTimeTag(buf, \"dcom\")) {\n    xmpData_[\"Xmp.video.Compressor\"] = readString(*io_, size);\n  }\n\n  else if (equalsQTimeTag(buf, \"smhd\")) {\n    io_->readOrThrow(buf.data(), 4);\n    io_->readOrThrow(buf.data(), 4);\n    xmpData_[\"Xmp.audio.Balance\"] = buf.read_uint16(0, bigEndian);\n  }\n\n  else {\n    discard(size);\n  }\n}  // QuickTimeVideo::tagDecoder\nvoid QuickTimeVideo::CameraTagsDecoder(size_t size_external) {\n  size_t cur_pos = io_->tell();\n  DataBuf buf(50), buf2(4);\n  const TagDetails* td;\n\n  io_->readOrThrow(buf.data(), 4);\n  if (equalsQTimeTag(buf, \"NIKO\")) {\n    io_->seek(cur_pos, BasicIo::beg);\n\n    io_->readOrThrow(buf.data(), 24);\n    xmpData_[\"Xmp.video.Make\"] = Exiv2::toString(buf.data());\n    io_->readOrThrow(buf.data(), 14);\n    xmpData_[\"Xmp.video.Model\"] = Exiv2::toString(buf.data());\n    io_->readOrThrow(buf.data(), 4);\n    xmpData_[\"Xmp.video.ExposureTime\"] = \"1/\" + Exiv2::toString(ceil(buf.read_uint32(0, littleEndian) / (double)10));\n    io_->readOrThrow(buf.data(), 4);\n    io_->readOrThrow(buf2.data(), 4);\n    xmpData_[\"Xmp.video.FNumber\"] = buf.read_uint32(0, littleEndian) / (double)buf2.read_uint32(0, littleEndian);\n    io_->readOrThrow(buf.data(), 4);\n    io_->readOrThrow(buf2.data(), 4);\n    xmpData_[\"Xmp.video.ExposureCompensation\"] =\n        buf.read_uint32(0, littleEndian) / (double)buf2.read_uint32(0, littleEndian);\n    io_->readOrThrow(buf.data(), 10);\n    io_->readOrThrow(buf.data(), 4);\n    td = find(whiteBalance, buf.read_uint32(0, littleEndian));\n    if (td)\n      xmpData_[\"Xmp.video.WhiteBalance\"] = exvGettext(td->label_);\n    io_->readOrThrow(buf.data(), 4);\n    io_->readOrThrow(buf2.data(), 4);\n    xmpData_[\"Xmp.video.FocalLength\"] = buf.read_uint32(0, littleEndian) / (double)buf2.read_uint32(0, littleEndian);\n    io_->seek(static_cast<long>(95), BasicIo::cur);\n    io_->readOrThrow(buf.data(), 48);\n    buf.write_uint8(48, 0);\n    xmpData_[\"Xmp.video.Software\"] = Exiv2::toString(buf.data());\n    io_->readOrThrow(buf.data(), 4);\n    xmpData_[\"Xmp.video.ISO\"] = buf.read_uint32(0, littleEndian);\n  }\n\n  io_->seek(cur_pos + size_external, BasicIo::beg);\n}  // QuickTimeVideo::CameraTagsDecoder\nvoid QuickTimeVideo::userDataDecoder(size_t size_external) {\n  size_t cur_pos = io_->tell();\n  const TagVocabulary* td;\n  const TagVocabulary *tv, *tv_internal;\n\n  const long bufMinSize = 100;\n  DataBuf buf(bufMinSize);\n  size_t size_internal = size_external;\n  std::memset(buf.data(), 0x0, buf.size());\n\n  while ((size_internal / 4 != 0) && (size_internal > 0)) {\n    buf.data()[4] = '\\0';\n    io_->readOrThrow(buf.data(), 4);\n    const size_t size = buf.read_uint32(0, bigEndian);\n    if (size > size_internal)\n      break;\n    size_internal -= size;\n    io_->readOrThrow(buf.data(), 4);\n\n    if (buf.data()[0] == 169)\n      buf.data()[0] = ' ';\n    td = find(userDatatags, Exiv2::toString(buf.data()));\n\n    tv = find(userDataReferencetags, Exiv2::toString(buf.data()));\n\n    if (size <= 12)\n      break;\n\n    else if (equalsQTimeTag(buf, \"DcMD\") || equalsQTimeTag(buf, \"NCDT\"))\n      userDataDecoder(size - 8);\n\n    else if (equalsQTimeTag(buf, \"NCTG\"))\n      NikonTagsDecoder(size - 8);\n\n    else if (equalsQTimeTag(buf, \"TAGS\"))\n      CameraTagsDecoder(size - 8);\n\n    else if (equalsQTimeTag(buf, \"CNCV\") || equalsQTimeTag(buf, \"CNFV\") || equalsQTimeTag(buf, \"CNMN\") ||\n             equalsQTimeTag(buf, \"NCHD\") || equalsQTimeTag(buf, \"FFMV\")) {\n      enforce(tv, Exiv2::ErrorCode::kerCorruptedMetadata);\n      xmpData_[exvGettext(tv->label_)] = readString(*io_, size - 8);\n    }\n\n    else if (equalsQTimeTag(buf, \"CMbo\") || equalsQTimeTag(buf, \"Cmbo\")) {\n      io_->readOrThrow(buf.data(), 2);\n      buf.data()[2] = '\\0';\n      tv_internal = find(cameraByteOrderTags, Exiv2::toString(buf.data()));\n\n      if (tv_internal)\n        xmpData_[exvGettext(tv->label_)] = exvGettext(tv_internal->label_);\n      else\n        xmpData_[exvGettext(tv->label_)] = Exiv2::toString(buf.data());\n    }\n\n    else if (tv) {\n      io_->readOrThrow(buf.data(), 4);\n      xmpData_[exvGettext(tv->label_)] = readString(*io_, size - 12);\n    }\n\n    else if (td)\n      tagDecoder(buf, size - 8);\n  }\n\n  io_->seek(cur_pos + size_external, BasicIo::beg);\n}  // QuickTimeVideo::userDataDecoder\n",
    "target": 0,
    "idx": 2052053
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "void LibRaw::kodak_thumb_loader()\n{\n  INT64 est_datasize =\n      T.theight * T.twidth / 3; // is 0.3 bytes per pixel good estimate?\n  if (ID.toffset < 0)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  if (ID.toffset + est_datasize > ID.input->size() + THUMB_READ_BEYOND)\n    throw LIBRAW_EXCEPTION_IO_EOF;\n\n  if(INT64(T.theight) * INT64(T.twidth) > 1024ULL * 1024ULL * LIBRAW_MAX_THUMBNAIL_MB)\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  if (INT64(T.theight) * INT64(T.twidth) < 64ULL)\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  if(T.twidth < 16 || T.twidth > 8192 || T.theight < 16 || T.theight > 8192)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  // some kodak cameras\n  ushort s_height = S.height, s_width = S.width, s_iwidth = S.iwidth,\n         s_iheight = S.iheight;\n  ushort s_flags = libraw_internal_data.unpacker_data.load_flags;\n  libraw_internal_data.unpacker_data.load_flags = 12;\n  int s_colors = P1.colors;\n  unsigned s_filters = P1.filters;\n  ushort(*s_image)[4] = imgdata.image;\n\n  S.height = T.theight;\n  S.width = T.twidth;\n  P1.filters = 0;\n\n#define Tformat libraw_internal_data.unpacker_data.thumb_format\n\n\n  if (Tformat == LIBRAW_INTERNAL_THUMBNAIL_KODAK_YCBCR)\n  {\n    S.height += S.height & 1;\n    S.width += S.width & 1;\n  }\n\n  S.iheight = S.height;\n  S.iwidth = S.width;\n\n  imgdata.image =\n      (ushort(*)[4])calloc(S.iheight * S.iwidth, sizeof(*imgdata.image));\n\n  ID.input->seek(ID.toffset, SEEK_SET);\n  // read kodak thumbnail into T.image[]\n  try\n  {\n      if (Tformat == LIBRAW_INTERNAL_THUMBNAIL_KODAK_YCBCR)\n          kodak_ycbcr_load_raw();\n      else if(Tformat == LIBRAW_INTERNAL_THUMBNAIL_KODAK_RGB)\n        kodak_rgb_load_raw();\n      else if (Tformat == LIBRAW_INTERNAL_THUMBNAIL_KODAK_THUMB)\n        kodak_thumb_load_raw();\n  }\n  catch (...)\n  {\n    free(imgdata.image);\n    imgdata.image = s_image;\n\n    T.twidth = 0;\n    S.width = s_width;\n\n    S.iwidth = s_iwidth;\n    S.iheight = s_iheight;\n\n    T.theight = 0;\n    S.height = s_height;\n\n    T.tcolors = 0;\n    P1.colors = s_colors;\n\n    P1.filters = s_filters;\n    T.tlength = 0;\n    libraw_internal_data.unpacker_data.load_flags = s_flags;\n    return;\n  }\n\n  // from scale_colors\n  {\n    double dmax;\n    float scale_mul[4];\n    int c, val;\n    for (dmax = DBL_MAX, c = 0; c < 3; c++)\n      if (dmax > C.pre_mul[c])\n        dmax = C.pre_mul[c];\n\n    for (c = 0; c < 3; c++)\n      scale_mul[c] = (C.pre_mul[c] / dmax) * 65535.0 / C.maximum;\n    scale_mul[3] = scale_mul[1];\n\n    size_t size = S.height * S.width;\n    for (unsigned i = 0; i < size * 4; i++)\n    {\n      val = imgdata.image[0][i];\n      if (!val)\n        continue;\n      val *= scale_mul[i & 3];\n      imgdata.image[0][i] = CLIP(val);\n    }\n  }\n\n  // from convert_to_rgb\n  ushort *img;\n  int row, col;\n\n  int(*t_hist)[LIBRAW_HISTOGRAM_SIZE] =\n      (int(*)[LIBRAW_HISTOGRAM_SIZE])calloc(sizeof(*t_hist), 4);\n\n  float out[3], out_cam[3][4] = {{2.81761312f, -1.98369181f, 0.166078627f, 0},\n                                 {-0.111855984f, 1.73688626f, -0.625030339f, 0},\n                                 {-0.0379119813f, -0.891268849f, 1.92918086f, 0}};\n\n  for (img = imgdata.image[0], row = 0; row < S.height; row++)\n    for (col = 0; col < S.width; col++, img += 4)\n    {\n      out[0] = out[1] = out[2] = 0;\n      int c;\n      for (c = 0; c < 3; c++)\n      {\n        out[0] += out_cam[0][c] * img[c];\n        out[1] += out_cam[1][c] * img[c];\n        out[2] += out_cam[2][c] * img[c];\n      }\n      for (c = 0; c < 3; c++)\n        img[c] = CLIP((int)out[c]);\n      for (c = 0; c < P1.colors; c++)\n        t_hist[c][img[c] >> 3]++;\n    }\n\n  // from gamma_lut\n  int(*save_hist)[LIBRAW_HISTOGRAM_SIZE] =\n      libraw_internal_data.output_data.histogram;\n  libraw_internal_data.output_data.histogram = t_hist;\n\n  // make curve output curve!\n  ushort *t_curve = (ushort *)calloc(sizeof(C.curve), 1);\n  memmove(t_curve, C.curve, sizeof(C.curve));\n  memset(C.curve, 0, sizeof(C.curve));\n  {\n    int perc, val, total, t_white = 0x2000, c;\n\n    perc = S.width * S.height * 0.01; /* 99th percentile white level */\n    if (IO.fuji_width)\n      perc /= 2;\n    if (!((O.highlight & ~2) || O.no_auto_bright))\n      for (t_white = c = 0; c < P1.colors; c++)\n      {\n        for (val = 0x2000, total = 0; --val > 32;)\n          if ((total += libraw_internal_data.output_data.histogram[c][val]) >\n              perc)\n            break;\n        if (t_white < val)\n          t_white = val;\n      }\n    gamma_curve(O.gamm[0], O.gamm[1], 2, (t_white << 3) / O.bright);\n  }\n\n  libraw_internal_data.output_data.histogram = save_hist;\n  free(t_hist);\n\n  // from write_ppm_tiff - copy pixels into bitmap\n\n  int s_flip = imgdata.sizes.flip;\n  if (imgdata.rawparams.options & LIBRAW_RAWOPTIONS_NO_ROTATE_FOR_KODAK_THUMBNAILS)\n    imgdata.sizes.flip = 0;\n\n  S.iheight = S.height;\n  S.iwidth = S.width;\n  if (S.flip & 4)\n    SWAP(S.height, S.width);\n\n  if (T.thumb)\n    free(T.thumb);\n  T.thumb = (char *)calloc(S.width * S.height, P1.colors);\n  T.tlength = S.width * S.height * P1.colors;\n\n  // from write_tiff_ppm\n  {\n    int soff = flip_index(0, 0);\n    int cstep = flip_index(0, 1) - soff;\n    int rstep = flip_index(1, 0) - flip_index(0, S.width);\n\n    for (int rr = 0; rr < S.height; rr++, soff += rstep)\n    {\n      char *ppm = T.thumb + rr * S.width * P1.colors;\n      for (int cc = 0; cc < S.width; cc++, soff += cstep)\n        for (int c = 0; c < P1.colors; c++)\n          ppm[cc * P1.colors + c] =\n              imgdata.color.curve[imgdata.image[soff][c]] >> 8;\n    }\n  }\n\n  memmove(C.curve, t_curve, sizeof(C.curve));\n  free(t_curve);\n\n  // restore variables\n  free(imgdata.image);\n  imgdata.image = s_image;\n\n  if (imgdata.rawparams.options & LIBRAW_RAWOPTIONS_NO_ROTATE_FOR_KODAK_THUMBNAILS)\n    imgdata.sizes.flip = s_flip;\n\n  T.twidth = S.width;\n  S.width = s_width;\n\n  S.iwidth = s_iwidth;\n  S.iheight = s_iheight;\n\n  T.theight = S.height;\n  S.height = s_height;\n\n  T.tcolors = P1.colors;\n  P1.colors = s_colors;\n\n  P1.filters = s_filters;\n  libraw_internal_data.unpacker_data.load_flags = s_flags;\n}\n",
    "target": 0,
    "idx": 2052579
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "void LibRaw::kodak_thumb_loader()\n{\n  INT64 est_datasize =\n      T.theight * T.twidth / 3; // is 0.3 bytes per pixel good estimate?\n  if (ID.toffset < 0)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  if (ID.toffset + est_datasize > ID.input->size() + THUMB_READ_BEYOND)\n    throw LIBRAW_EXCEPTION_IO_EOF;\n\n  if(INT64(T.theight) * INT64(T.twidth) > 1024ULL * 1024ULL * LIBRAW_MAX_THUMBNAIL_MB)\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  if (INT64(T.theight) * INT64(T.twidth) < 64ULL)\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  if(T.twidth < 16 || T.twidth > 8192 || T.theight < 16 || T.theight > 8192)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  // some kodak cameras\n  ushort s_height = S.height, s_width = S.width, s_iwidth = S.iwidth,\n         s_iheight = S.iheight;\n  ushort s_flags = libraw_internal_data.unpacker_data.load_flags;\n  libraw_internal_data.unpacker_data.load_flags = 12;\n  int s_colors = P1.colors;\n  unsigned s_filters = P1.filters;\n  ushort(*s_image)[4] = imgdata.image;\n\n  S.height = T.theight;\n  S.width = T.twidth;\n  P1.filters = 0;\n\n#define Tformat libraw_internal_data.unpacker_data.thumb_format\n\n\n  if (Tformat == LIBRAW_INTERNAL_THUMBNAIL_KODAK_YCBCR)\n  {\n    S.height += S.height & 1;\n    S.width += S.width & 1;\n  }\n\n  S.iheight = S.height;\n  S.iwidth = S.width;\n\n  imgdata.image =\n      (ushort(*)[4])calloc(S.iheight * S.iwidth, sizeof(*imgdata.image));\n\n  ID.input->seek(ID.toffset, SEEK_SET);\n  // read kodak thumbnail into T.image[]\n  try\n  {\n      if (Tformat == LIBRAW_INTERNAL_THUMBNAIL_KODAK_YCBCR)\n          kodak_ycbcr_load_raw();\n      else if(Tformat == LIBRAW_INTERNAL_THUMBNAIL_KODAK_RGB)\n        kodak_rgb_load_raw();\n      else if (Tformat == LIBRAW_INTERNAL_THUMBNAIL_KODAK_THUMB)\n        kodak_thumb_load_raw();\n  }\n  catch (...)\n  {\n    free(imgdata.image);\n    imgdata.image = s_image;\n\n    T.twidth = 0;\n    S.width = s_width;\n\n    S.iwidth = s_iwidth;\n    S.iheight = s_iheight;\n\n    T.theight = 0;\n    S.height = s_height;\n\n    T.tcolors = 0;\n    P1.colors = s_colors;\n\n    P1.filters = s_filters;\n    T.tlength = 0;\n    libraw_internal_data.unpacker_data.load_flags = s_flags;\n    return;\n  }\n\n  // from scale_colors\n  {\n    double dmax;\n    float scale_mul[4];\n    int c, val;\n    for (dmax = DBL_MAX, c = 0; c < 3; c++)\n      if (dmax > C.pre_mul[c])\n        dmax = C.pre_mul[c];\n\n    for (c = 0; c < 3; c++)\n      scale_mul[c] = (C.pre_mul[c] / dmax) * 65535.0 / C.maximum;\n    scale_mul[3] = scale_mul[1];\n\n    size_t size = S.height * S.width;\n    for (unsigned i = 0; i < size * 4; i++)\n    {\n      val = imgdata.image[0][i];\n      if (!val)\n        continue;\n      val *= scale_mul[i & 3];\n      imgdata.image[0][i] = CLIP(val);\n    }\n  }\n\n  // from convert_to_rgb\n  ushort *img;\n  int row, col;\n\n  int(*t_hist)[LIBRAW_HISTOGRAM_SIZE] =\n      (int(*)[LIBRAW_HISTOGRAM_SIZE])calloc(sizeof(*t_hist), 4);\n\n  float out[3], out_cam[3][4] = {{2.81761312f, -1.98369181f, 0.166078627f, 0},\n                                 {-0.111855984f, 1.73688626f, -0.625030339f, 0},\n                                 {-0.0379119813f, -0.891268849f, 1.92918086f, 0}};\n\n  for (img = imgdata.image[0], row = 0; row < S.height; row++)\n    for (col = 0; col < S.width; col++, img += 4)\n    {\n      out[0] = out[1] = out[2] = 0;\n      int c;\n      for (c = 0; c < 3; c++)\n      {\n        out[0] += out_cam[0][c] * img[c];\n        out[1] += out_cam[1][c] * img[c];\n        out[2] += out_cam[2][c] * img[c];\n      }\n      for (c = 0; c < 3; c++)\n        img[c] = CLIP((int)out[c]);\n      for (c = 0; c < P1.colors; c++)\n        t_hist[c][img[c] >> 3]++;\n    }\n\n  // from gamma_lut\n  int(*save_hist)[LIBRAW_HISTOGRAM_SIZE] =\n      libraw_internal_data.output_data.histogram;\n  libraw_internal_data.output_data.histogram = t_hist;\n\n  // make curve output curve!\n  ushort *t_curve = (ushort *)calloc(sizeof(C.curve), 1);\n  memmove(t_curve, C.curve, sizeof(C.curve));\n  memset(C.curve, 0, sizeof(C.curve));\n  {\n    int perc, val, total, t_white = 0x2000, c;\n\n    perc = S.width * S.height * 0.01; /* 99th percentile white level */\n    if (IO.fuji_width)\n      perc /= 2;\n    if (!((O.highlight & ~2) || O.no_auto_bright))\n      for (t_white = c = 0; c < P1.colors; c++)\n      {\n        for (val = 0x2000, total = 0; --val > 32;)\n          if ((total += libraw_internal_data.output_data.histogram[c][val]) >\n              perc)\n            break;\n        if (t_white < val)\n          t_white = val;\n      }\n    gamma_curve(O.gamm[0], O.gamm[1], 2, (t_white << 3) / O.bright);\n  }\n\n  libraw_internal_data.output_data.histogram = save_hist;\n  free(t_hist);\n\n  // from write_ppm_tiff - copy pixels into bitmap\n\n  int s_flip = imgdata.sizes.flip;\n  if (imgdata.rawparams.options & LIBRAW_RAWOPTIONS_NO_ROTATE_FOR_KODAK_THUMBNAILS)\n    imgdata.sizes.flip = 0;\n\n  S.iheight = S.height;\n  S.iwidth = S.width;\n  if (S.flip & 4)\n    SWAP(S.height, S.width);\n\n  if (T.thumb)\n    free(T.thumb);\n  T.thumb = (char *)calloc(S.width * S.height, P1.colors);\n  T.tlength = S.width * S.height * P1.colors;\n\n  // from write_tiff_ppm\n  {\n    int soff = flip_index(0, 0);\n    int cstep = flip_index(0, 1) - soff;\n    int rstep = flip_index(1, 0) - flip_index(0, S.width);\n\n    for (int rr = 0; rr < S.height; rr++, soff += rstep)\n    {\n      char *ppm = T.thumb + rr * S.width * P1.colors;\n      for (int cc = 0; cc < S.width; cc++, soff += cstep)\n        for (int c = 0; c < P1.colors; c++)\n          ppm[cc * P1.colors + c] =\n              imgdata.color.curve[imgdata.image[soff][c]] >> 8;\n    }\n  }\n\n  memmove(C.curve, t_curve, sizeof(C.curve));\n  free(t_curve);\n\n  // restore variables\n  free(imgdata.image);\n  imgdata.image = s_image;\n\n  if (imgdata.rawparams.options & LIBRAW_RAWOPTIONS_NO_ROTATE_FOR_KODAK_THUMBNAILS)\n    imgdata.sizes.flip = s_flip;\n\n  T.twidth = S.width;\n  S.width = s_width;\n\n  S.iwidth = s_iwidth;\n  S.iheight = s_iheight;\n\n  T.theight = S.height;\n  S.height = s_height;\n\n  T.tcolors = P1.colors;\n  P1.colors = s_colors;\n\n  P1.filters = s_filters;\n  libraw_internal_data.unpacker_data.load_flags = s_flags;\n}\n",
    "target": 0,
    "idx": 2052802
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "static size_t merge_utf16be_ascii(unsigned char *out, size_t out_len, const unsigned char *utf16, const unsigned char *ascii, size_t len)\n{\n\tsize_t o, a, u;\n\n\tfor (o = 0, a = 0, u = 0; u + 1 < len && a < len && o + 1 < out_len; o += 2, a++, u += 2) {\n\t\t/* Surrogate pair with code point above U+FFFF */\n\t\tif (utf16[u] >= 0xD8 && utf16[u] <= 0xDB && u + 3 < len &&\n\t\t    utf16[u + 2] >= 0xDC && utf16[u + 2] <= 0xDF) {\n\t\t\tout[o++] = utf16[u++];\n\t\t\tout[o++] = utf16[u++];\n\t\t}\n\t\t/* Value '_' is replacement for non-representable character */\n\t\tif (ascii[a] == '_') {\n\t\t\tout[o] = utf16[u];\n\t\t\tout[o + 1] = utf16[u + 1];\n\t\t} else if (utf16[u] == 0x00 && utf16[u + 1] == '_') {\n\t\t\tout[o] = 0x00;\n\t\t\tout[o + 1] = ascii[a];\n\t\t} else if (utf16[u] == 0x00 && c_toupper(ascii[a]) == c_toupper(utf16[u + 1])) {\n\t\t\tout[o] = 0x00;\n\t\t\tout[o + 1] = c_isupper(ascii[a]) ? utf16[u + 1] : ascii[a];\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tfor (; a < len && o + 1 < out_len; o += 2, a++) {\n\t\tout[o] = 0x00;\n\t\tout[o + 1] = ascii[a];\n\t}\n\n\treturn o;\n}\nstatic int probe_iso9660(blkid_probe pr, const struct blkid_idmag *mag)\n{\n\tstruct boot_record *boot = NULL;\n\tstruct iso_volume_descriptor *pvd = NULL;\n\tstruct iso_volume_descriptor *joliet = NULL;\n\t/* space for merge_utf16be_ascii(ISO_ID_BUFSIZ bytes) */\n\tunsigned char buf[ISO_MAX_FIELDSIZ * 5 / 2];\n\tsize_t len;\n\tint is_unicode_empty;\n\tint is_ascii_empty;\n\tint i;\n\tuint64_t off;\n\n\tif (blkid_probe_get_hint(pr, mag->hoff, &off) < 0)\n\t\toff = 0;\n\n\tif (off % ISO_SECTOR_SIZE)\n\t\treturn 1;\n\n\tif (strcmp(mag->magic, \"CDROM\") == 0)\n\t\treturn probe_iso9660_hsfs(pr, mag);\n\n\tfor (i = 0, off += ISO_SUPERBLOCK_OFFSET; i < ISO_VD_MAX && (!boot || !pvd || !joliet); i++, off += ISO_SECTOR_SIZE) {\n\t\tunsigned char *desc =\n\t\t\tblkid_probe_get_buffer(pr,\n\t\t\t\t\toff,\n\t\t\t\t\tmax(sizeof(struct boot_record),\n\t\t\t\t\t    sizeof(struct iso_volume_descriptor)));\n\n\t\tif (desc == NULL || desc[0] == ISO_VD_END)\n\t\t\tbreak;\n\t\telse if (!boot && desc[0] == ISO_VD_BOOT_RECORD)\n\t\t\tboot = (struct boot_record *)desc;\n\t\telse if (!pvd && desc[0] == ISO_VD_PRIMARY)\n\t\t\tpvd = (struct iso_volume_descriptor *)desc;\n\t\telse if (!joliet && desc[0] == ISO_VD_SUPPLEMENTARY) {\n\t\t\tjoliet = (struct iso_volume_descriptor *)desc;\n\t\t\tif (memcmp(joliet->escape_sequences, \"%/@\", 3) != 0 &&\n\t\t\t    memcmp(joliet->escape_sequences, \"%/C\", 3) != 0 &&\n\t\t\t    memcmp(joliet->escape_sequences, \"%/E\", 3) != 0)\n\t\t\t\tjoliet = NULL;\n\t\t}\n\t}\n\n\tif (!pvd)\n\t\treturn errno ? -errno : 1;\n\n\tblkid_probe_set_fsblocksize(pr, ISO_SECTOR_SIZE);\n\tblkid_probe_set_block_size(pr, ISO_SECTOR_SIZE);\n\n\tif (joliet && (len = merge_utf16be_ascii(buf, sizeof(buf), joliet->system_id, pvd->system_id, sizeof(pvd->system_id))) != 0)\n\t\tblkid_probe_set_utf8_id_label(pr, \"SYSTEM_ID\", buf, len, UL_ENCODE_UTF16BE);\n\telse if (joliet)\n\t\tblkid_probe_set_utf8_id_label(pr, \"SYSTEM_ID\", joliet->system_id, sizeof(joliet->system_id), UL_ENCODE_UTF16BE);\n\telse\n\t\tblkid_probe_set_id_label(pr, \"SYSTEM_ID\", pvd->system_id, sizeof(pvd->system_id));\n\n\tif (joliet && (len = merge_utf16be_ascii(buf, sizeof(buf), joliet->volume_set_id, pvd->volume_set_id, sizeof(pvd->volume_set_id))) != 0)\n\t\tblkid_probe_set_utf8_id_label(pr, \"VOLUME_SET_ID\", buf, len, UL_ENCODE_UTF16BE);\n\telse if (joliet)\n\t\tblkid_probe_set_utf8_id_label(pr, \"VOLUME_SET_ID\", joliet->volume_set_id, sizeof(joliet->volume_set_id), UL_ENCODE_UTF16BE);\n\telse\n\t\tblkid_probe_set_id_label(pr, \"VOLUME_SET_ID\", pvd->volume_set_id, sizeof(pvd->volume_set_id));\n\n\tis_ascii_empty = (is_str_empty(pvd->publisher_id, sizeof(pvd->publisher_id)) || pvd->publisher_id[0] == '_');\n\tis_unicode_empty = (!joliet || is_utf16be_str_empty(joliet->publisher_id, sizeof(joliet->publisher_id)) || (joliet->publisher_id[0] == 0x00 && joliet->publisher_id[1] == '_'));\n\tif (!is_unicode_empty && !is_ascii_empty && (len = merge_utf16be_ascii(buf, sizeof(buf), joliet->publisher_id, pvd->publisher_id, sizeof(pvd->publisher_id))) != 0)\n\t\tblkid_probe_set_utf8_id_label(pr, \"PUBLISHER_ID\", buf, len, UL_ENCODE_UTF16BE);\n\telse if (!is_unicode_empty)\n\t\tblkid_probe_set_utf8_id_label(pr, \"PUBLISHER_ID\", joliet->publisher_id, sizeof(joliet->publisher_id), UL_ENCODE_UTF16BE);\n\telse if (!is_ascii_empty)\n\t\tblkid_probe_set_id_label(pr, \"PUBLISHER_ID\", pvd->publisher_id, sizeof(pvd->publisher_id));\n\n\tis_ascii_empty = (is_str_empty(pvd->data_preparer_id, sizeof(pvd->data_preparer_id)) || pvd->data_preparer_id[0] == '_');\n\tis_unicode_empty = (!joliet || is_utf16be_str_empty(joliet->data_preparer_id, sizeof(joliet->data_preparer_id)) || (joliet->data_preparer_id[0] == 0x00 && joliet->data_preparer_id[1] == '_'));\n\tif (!is_unicode_empty && !is_ascii_empty && (len = merge_utf16be_ascii(buf, sizeof(buf), joliet->data_preparer_id, pvd->data_preparer_id, sizeof(pvd->data_preparer_id))) != 0)\n\t\tblkid_probe_set_utf8_id_label(pr, \"DATA_PREPARER_ID\", buf, len, UL_ENCODE_UTF16BE);\n\telse if (!is_unicode_empty)\n\t\tblkid_probe_set_utf8_id_label(pr, \"DATA_PREPARER_ID\", joliet->data_preparer_id, sizeof(joliet->data_preparer_id), UL_ENCODE_UTF16BE);\n\telse if (!is_ascii_empty)\n\t\tblkid_probe_set_id_label(pr, \"DATA_PREPARER_ID\", pvd->data_preparer_id, sizeof(pvd->data_preparer_id));\n\n\tis_ascii_empty = (is_str_empty(pvd->application_id, sizeof(pvd->application_id)) || pvd->application_id[0] == '_');\n\tis_unicode_empty = (!joliet || is_utf16be_str_empty(joliet->application_id, sizeof(joliet->application_id)) || (joliet->application_id[0] == 0x00 && joliet->application_id[1] == '_'));\n\tif (!is_unicode_empty && !is_ascii_empty && (len = merge_utf16be_ascii(buf, sizeof(buf), joliet->application_id, pvd->application_id, sizeof(pvd->application_id))) != 0)\n\t\tblkid_probe_set_utf8_id_label(pr, \"APPLICATION_ID\", buf, len, UL_ENCODE_UTF16BE);\n\telse if (!is_unicode_empty)\n\t\tblkid_probe_set_utf8_id_label(pr, \"APPLICATION_ID\", joliet->application_id, sizeof(joliet->application_id), UL_ENCODE_UTF16BE);\n\telse if (!is_ascii_empty)\n\t\tblkid_probe_set_id_label(pr, \"APPLICATION_ID\", pvd->application_id, sizeof(pvd->application_id));\n\n\t/* create an UUID using the modified/created date */\n\tif (! probe_iso9660_set_uuid(pr, &pvd->modified))\n\t\tprobe_iso9660_set_uuid(pr, &pvd->created);\n\n\tif (boot)\n\t\tblkid_probe_set_id_label(pr, \"BOOT_SYSTEM_ID\",\n\t\t\t\t\tboot->boot_system_id,\n\t\t\t\t\tsizeof(boot->boot_system_id));\n\n\tif (joliet)\n\t\tblkid_probe_set_version(pr, \"Joliet Extension\");\n\n\t/* Label in Joliet is UNICODE (UTF16BE) but can contain only 16 characters. Label in PVD is\n\t * subset of ASCII but can contain up to the 32 characters. Non-representable characters are\n\t * stored as replacement character '_'. Label in Joliet is in most cases trimmed but UNICODE\n\t * version of label in PVD. Based on these facts try to reconstruct original label if label\n\t * in Joliet is prefix of the label in PVD (ignoring non-representable characters).\n\t */\n\tif (joliet && (len = merge_utf16be_ascii(buf, sizeof(buf), joliet->volume_id, pvd->volume_id, sizeof(pvd->volume_id))) != 0)\n\t\tblkid_probe_set_utf8label(pr, buf, len, UL_ENCODE_UTF16BE);\n\telse if (joliet)\n\t\tblkid_probe_set_utf8label(pr, joliet->volume_id, sizeof(joliet->volume_id), UL_ENCODE_UTF16BE);\n\telse\n\t\tblkid_probe_set_label(pr, pvd->volume_id, sizeof(pvd->volume_id));\n\n\treturn 0;\n}\n",
    "target": 0,
    "idx": 2053149
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "void LibRaw::uncompressed_fp_dng_load_raw()\n{\n    int iifd = find_ifd_by_offset(libraw_internal_data.unpacker_data.data_offset);\n    if (iifd < 0 || iifd > (int)libraw_internal_data.identify_data.tiff_nifds)\n        throw LIBRAW_EXCEPTION_DECODE_RAW;\n    struct tiff_ifd_t *ifd = &tiff_ifd[iifd];\n\n    float *float_raw_image = 0;\n\n    if (ifd->samples != 1 && ifd->samples != 3 && ifd->samples != 4)\n        throw LIBRAW_EXCEPTION_DECODE_RAW; \n\n    if(imgdata.idata.filters && ifd->samples > 1)\n      throw LIBRAW_EXCEPTION_DECODE_RAW;\n\n    if ((int)libraw_internal_data.unpacker_data.tiff_samples != ifd->samples)\n        throw LIBRAW_EXCEPTION_DECODE_RAW; // Wrong IFD\n\n    int bytesps = (ifd->bps + 7) >> 3; // round to upper value\n\n\tif(bytesps < 1 || bytesps > 4)\n      throw LIBRAW_EXCEPTION_DECODE_RAW;\n\n    tile_stripe_data_t tiles;\n    tiles.init(ifd, imgdata.sizes, libraw_internal_data.unpacker_data, libraw_internal_data.unpacker_data.order,\n        libraw_internal_data.internal_data.input);\n\n\tINT64 allocsz = INT64(tiles.tileCnt) * INT64(tiles.tileWidth) * INT64(tiles.tileHeight) * INT64(ifd->samples) * INT64(sizeof(float));\n\tif (allocsz > INT64(imgdata.rawparams.max_raw_memory_mb) * INT64(1024 * 1024))\n\t\tthrow LIBRAW_EXCEPTION_TOOBIG;\n\n    if (ifd->sample_format == 3)\n        float_raw_image = (float *)calloc(tiles.tileCnt * tiles.tileWidth * tiles.tileHeight *ifd->samples, sizeof(float));\n    else\n        throw LIBRAW_EXCEPTION_DECODE_RAW; // Only float supported\n\n    bool difford = (libraw_internal_data.unpacker_data.order == 0x4949) == (ntohs(0x1234) == 0x1234);\n    float max = 0.f;\n\n    std::vector<uchar> rowbuf(tiles.tileWidth *sizeof(float) * ifd->samples); // line buffer for last tile in tile row\n\n    for (size_t y = 0, t = 0; y < imgdata.sizes.raw_height; y += tiles.tileHeight)\n    {\n        for (unsigned x = 0; x < imgdata.sizes.raw_width  && t < (unsigned)tiles.tileCnt; x += tiles.tileWidth, ++t)\n        {\n            libraw_internal_data.internal_data.input->seek(tiles.tOffsets[t], SEEK_SET);\n            size_t rowsInTile = y + tiles.tileHeight > imgdata.sizes.raw_height ? imgdata.sizes.raw_height - y : tiles.tileHeight;\n            size_t colsInTile = x + tiles.tileWidth > imgdata.sizes.raw_width ? imgdata.sizes.raw_width - x : tiles.tileWidth;\n\n            size_t inrowbytes = colsInTile * bytesps * ifd->samples;\n            int fullrowbytes = tiles.tileWidth *bytesps * ifd->samples;\n            size_t outrowbytes = colsInTile * sizeof(float) * ifd->samples;\n\n            for (size_t row = 0; row < rowsInTile; ++row) // do not process full tile if not needed\n            {\n                unsigned char *dst = fullrowbytes > inrowbytes ? rowbuf.data(): // last tile in row, use buffer\n                    (unsigned char *)&float_raw_image\n                    [((y + row) * imgdata.sizes.raw_width + x) * ifd->samples];\n                libraw_internal_data.internal_data.input->read(dst, 1, fullrowbytes);\n                if (bytesps == 2 && difford)\n                    libraw_swab(dst, fullrowbytes);\n                else if (bytesps == 3 && (libraw_internal_data.unpacker_data.order == 0x4949)) // II-16bit\n                    swap24(dst, fullrowbytes);\n                if (bytesps == 4 && difford)\n                    swap32(dst, fullrowbytes);\n\n                float lmax = expandFloats(\n                    dst,\n                    tiles.tileWidth * ifd->samples,\n                    bytesps);\n                if (fullrowbytes > inrowbytes) // last tile in row: copy buffer to destination\n                    memmove(&float_raw_image[((y + row) * imgdata.sizes.raw_width + x) * ifd->samples], dst, outrowbytes);\n                max = MAX(max, lmax);\n            }\n        }\n    }\n\n    imgdata.color.fmaximum = max;\n\n    // setup outpuf fields\n    imgdata.rawdata.raw_alloc = float_raw_image;\n    if (ifd->samples == 1)\n    {\n        imgdata.rawdata.float_image = float_raw_image;\n        imgdata.rawdata.sizes.raw_pitch = imgdata.sizes.raw_pitch =\n            imgdata.sizes.raw_width * 4;\n    }\n    else if (ifd->samples == 3)\n    {\n        imgdata.rawdata.float3_image = (float(*)[3])float_raw_image;\n        imgdata.rawdata.sizes.raw_pitch = imgdata.sizes.raw_pitch =\n            imgdata.sizes.raw_width * 12;\n    }\n    else if (ifd->samples == 4)\n    {\n        imgdata.rawdata.float4_image = (float(*)[4])float_raw_image;\n        imgdata.rawdata.sizes.raw_pitch = imgdata.sizes.raw_pitch =\n            imgdata.sizes.raw_width * 16;\n    }\n\n    if (imgdata.rawparams.options & LIBRAW_RAWOPTIONS_CONVERTFLOAT_TO_INT)\n        convertFloatToInt();  \n}\n",
    "target": 0,
    "idx": 2053158
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "\n\n  public static void main(String[] argv) {\n\n    try {\n\n      TJScalingFactor scalingFactor = new TJScalingFactor(1, 1);\n      int outSubsamp = -1, outQual = -1;\n      TJTransform xform = new TJTransform();\n      boolean display = false;\n      int flags = 0;\n      int width, height;\n      String inFormat = \"jpg\", outFormat = \"jpg\";\n      BufferedImage img = null;\n      byte[] imgBuf = null;\n\n      if (argv.length < 2)\n        usage();\n\n      if (argv[1].substring(0, 2).equalsIgnoreCase(\"-d\"))\n        display = true;\n\n      /* Parse arguments. */\n      for (int i = 2; i < argv.length; i++) {\n        if (argv[i].length() < 2)\n          continue;\n        else if (argv[i].length() > 2 &&\n                 argv[i].substring(0, 3).equalsIgnoreCase(\"-sc\") &&\n                 i < argv.length - 1) {\n          int match = 0;\n          String[] scaleArg = argv[++i].split(\"/\");\n          if (scaleArg.length == 2) {\n            TJScalingFactor tempsf =\n              new TJScalingFactor(Integer.parseInt(scaleArg[0]),\n                                  Integer.parseInt(scaleArg[1]));\n            for (int j = 0; j < SCALING_FACTORS.length; j++) {\n              if (tempsf.equals(SCALING_FACTORS[j])) {\n                scalingFactor = SCALING_FACTORS[j];\n                match = 1;\n                break;\n              }\n            }\n          }\n          if (match != 1)\n            usage();\n        } else if (argv[i].length() > 2 &&\n                   argv[i].substring(0, 3).equalsIgnoreCase(\"-su\") &&\n                   i < argv.length - 1) {\n          i++;\n          if (argv[i].substring(0, 1).equalsIgnoreCase(\"g\"))\n            outSubsamp = TJ.SAMP_GRAY;\n          else if (argv[i].equals(\"444\"))\n            outSubsamp = TJ.SAMP_444;\n          else if (argv[i].equals(\"422\"))\n            outSubsamp = TJ.SAMP_422;\n          else if (argv[i].equals(\"420\"))\n            outSubsamp = TJ.SAMP_420;\n          else\n            usage();\n        } else if (argv[i].substring(0, 2).equalsIgnoreCase(\"-q\") &&\n                   i < argv.length - 1) {\n          outQual = Integer.parseInt(argv[++i]);\n          if (outQual < 1 || outQual > 100)\n            usage();\n        } else if (argv[i].substring(0, 2).equalsIgnoreCase(\"-g\"))\n          xform.options |= TJTransform.OPT_GRAY;\n        else if (argv[i].equalsIgnoreCase(\"-hflip\"))\n          xform.op = TJTransform.OP_HFLIP;\n        else if (argv[i].equalsIgnoreCase(\"-vflip\"))\n          xform.op = TJTransform.OP_VFLIP;\n        else if (argv[i].equalsIgnoreCase(\"-transpose\"))\n          xform.op = TJTransform.OP_TRANSPOSE;\n        else if (argv[i].equalsIgnoreCase(\"-transverse\"))\n          xform.op = TJTransform.OP_TRANSVERSE;\n        else if (argv[i].equalsIgnoreCase(\"-rot90\"))\n          xform.op = TJTransform.OP_ROT90;\n        else if (argv[i].equalsIgnoreCase(\"-rot180\"))\n          xform.op = TJTransform.OP_ROT180;\n        else if (argv[i].equalsIgnoreCase(\"-rot270\"))\n          xform.op = TJTransform.OP_ROT270;\n        else if (argv[i].equalsIgnoreCase(\"-custom\"))\n          xform.cf = new TJExample();\n        else if (argv[i].length() > 2 &&\n                 argv[i].substring(0, 2).equalsIgnoreCase(\"-c\") &&\n                 i < argv.length - 1) {\n          String[] cropArg = argv[++i].split(\"[x\\\\+]\");\n          if (cropArg.length != 4)\n            usage();\n          xform.width = Integer.parseInt(cropArg[0]);\n          xform.height = Integer.parseInt(cropArg[1]);\n          xform.x = Integer.parseInt(cropArg[2]);\n          xform.y = Integer.parseInt(cropArg[3]);\n          if (xform.x < 0 || xform.y < 0 || xform.width < 1 ||\n              xform.height < 1)\n            usage();\n          xform.options |= TJTransform.OPT_CROP;\n        } else if (argv[i].substring(0, 2).equalsIgnoreCase(\"-d\"))\n          display = true;\n        else if (argv[i].equalsIgnoreCase(\"-fastupsample\")) {\n          System.out.println(\"Using fast upsampling code\");\n          flags |= TJ.FLAG_FASTUPSAMPLE;\n        } else if (argv[i].equalsIgnoreCase(\"-fastdct\")) {\n          System.out.println(\"Using fastest DCT/IDCT algorithm\");\n          flags |= TJ.FLAG_FASTDCT;\n        } else if (argv[i].equalsIgnoreCase(\"-accuratedct\")) {\n          System.out.println(\"Using most accurate DCT/IDCT algorithm\");\n          flags |= TJ.FLAG_ACCURATEDCT;\n        } else usage();\n      }\n\n      /* Determine input and output image formats based on file extensions. */\n      String[] inFileTokens = argv[0].split(\"\\\\.\");\n      if (inFileTokens.length > 1)\n        inFormat = inFileTokens[inFileTokens.length - 1];\n      String[] outFileTokens;\n      if (display)\n        outFormat = \"bmp\";\n      else {\n        outFileTokens = argv[1].split(\"\\\\.\");\n        if (outFileTokens.length > 1)\n          outFormat = outFileTokens[outFileTokens.length - 1];\n      }\n\n      if (inFormat.equalsIgnoreCase(\"jpg\")) {\n        /* Input image is a JPEG image.  Decompress and/or transform it. */\n        boolean doTransform = (xform.op != TJTransform.OP_NONE ||\n                               xform.options != 0 || xform.cf != null);\n\n        /* Read the JPEG file into memory. */\n        File jpegFile = new File(argv[0]);\n        FileInputStream fis = new FileInputStream(jpegFile);\n        int jpegSize = fis.available();\n        if (jpegSize < 1) {\n          System.out.println(\"Input file contains no data\");\n          System.exit(1);\n        }\n        byte[] jpegBuf = new byte[jpegSize];\n        fis.read(jpegBuf);\n        fis.close();\n\n        TJDecompressor tjd;\n        if (doTransform) {\n          /* Transform it. */\n          TJTransformer tjt = new TJTransformer(jpegBuf);\n          TJTransform[] xforms = new TJTransform[1];\n          xforms[0] = xform;\n          xforms[0].options |= TJTransform.OPT_TRIM;\n          TJDecompressor[] tjds = tjt.transform(xforms, 0);\n          tjd = tjds[0];\n          tjt.close();\n        } else\n          tjd = new TJDecompressor(jpegBuf);\n\n        width = tjd.getWidth();\n        height = tjd.getHeight();\n        int inSubsamp = tjd.getSubsamp();\n        int inColorspace = tjd.getColorspace();\n        int inFlags = tjd.getFlags();\n\n        if ((inFlags & TJ.FLAG_LOSSLESS) != 0)\n          scalingFactor = new TJScalingFactor(1, 1);\n\n        System.out.println((doTransform ? \"Transformed\" : \"Input\") +\n                           \" Image (jpg):  \" + width + \" x \" + height +\n                           \" pixels, \" + SUBSAMP_NAME[inSubsamp] +\n                           \" subsampling, \" + COLORSPACE_NAME[inColorspace]);\n\n        if (outFormat.equalsIgnoreCase(\"jpg\") && doTransform &&\n            scalingFactor.isOne() && outSubsamp < 0 && outQual < 0) {\n          /* Input image has been transformed, and no re-compression options\n             have been selected.  Write the transformed image to disk and\n             exit. */\n          File outFile = new File(argv[1]);\n          FileOutputStream fos = new FileOutputStream(outFile);\n          fos.write(tjd.getJPEGBuf(), 0, tjd.getJPEGSize());\n          fos.close();\n          System.exit(0);\n        }\n\n        /* Scaling and/or a non-JPEG output image format and/or compression\n           options have been selected, so we need to decompress the\n           input/transformed image. */\n        width = scalingFactor.getScaled(width);\n        height = scalingFactor.getScaled(height);\n        if (outSubsamp < 0)\n          outSubsamp = inSubsamp;\n\n        if (!outFormat.equalsIgnoreCase(\"jpg\"))\n          img = tjd.decompress(width, height, BufferedImage.TYPE_INT_RGB,\n                               flags);\n        else\n          imgBuf = tjd.decompress(width, 0, height, TJ.PF_BGRX, flags);\n        tjd.close();\n      } else {\n        /* Input image is not a JPEG image.  Load it into memory. */\n        img = ImageIO.read(new File(argv[0]));\n        if (img == null)\n          throw new Exception(\"Input image type not supported.\");\n        width = img.getWidth();\n        height = img.getHeight();\n        if (outSubsamp < 0) {\n          if (img.getType() == BufferedImage.TYPE_BYTE_GRAY)\n            outSubsamp = TJ.SAMP_GRAY;\n          else\n            outSubsamp = DEFAULT_SUBSAMP;\n        }\n        System.out.println(\"Input Image:  \" + width + \" x \" + height +\n                           \" pixels\");\n      }\n      System.gc();\n      if (!display)\n        System.out.print(\"Output Image (\" + outFormat + \"):  \" + width +\n                         \" x \" + height + \" pixels\");\n\n      if (display) {\n        /* Display the uncompressed image */\n        ImageIcon icon = new ImageIcon(img);\n        JLabel label = new JLabel(icon, JLabel.CENTER);\n        JOptionPane.showMessageDialog(null, label, \"Output Image\",\n                                      JOptionPane.PLAIN_MESSAGE);\n      } else if (outFormat.equalsIgnoreCase(\"jpg\")) {\n        /* Output image format is JPEG.  Compress the uncompressed image. */\n        if (outQual < 0)\n          outQual = DEFAULT_QUALITY;\n        System.out.println(\", \" + SUBSAMP_NAME[outSubsamp] +\n                           \" subsampling, quality = \" + outQual);\n\n        TJCompressor tjc = new TJCompressor();\n        tjc.setSubsamp(outSubsamp);\n        tjc.setJPEGQuality(outQual);\n        if (img != null)\n          tjc.setSourceImage(img, 0, 0, 0, 0);\n        else\n          tjc.setSourceImage(imgBuf, 0, 0, width, 0, height, TJ.PF_BGRX);\n        byte[] jpegBuf = tjc.compress(flags);\n        int jpegSize = tjc.getCompressedSize();\n        tjc.close();\n\n        /* Write the JPEG image to disk. */\n        File outFile = new File(argv[1]);\n        FileOutputStream fos = new FileOutputStream(outFile);\n        fos.write(jpegBuf, 0, jpegSize);\n        fos.close();\n      } else {\n        /* Output image format is not JPEG.  Save the uncompressed image\n           directly to disk. */\n        System.out.print(\"\\n\");\n        File outFile = new File(argv[1]);\n        ImageIO.write(img, outFormat, outFile);\n      }\n\n    } catch (Exception e) {\n      e.printStackTrace();\n      System.exit(-1);\n    }\n  }\n  public byte[] getJPEGBuf() {\n    if (jpegBuf == null)\n      throw new IllegalStateException(NO_ASSOC_ERROR);\n    return jpegBuf;\n  }\nstatic int decomp(unsigned char *srcBuf, unsigned char **jpegBuf,\n                  unsigned long *jpegSize, unsigned char *dstBuf, int w, int h,\n                  int subsamp, int jpegQual, char *fileName, int tilew,\n                  int tileh)\n{\n  char tempStr[1024], sizeStr[24] = \"\\0\", qualStr[13] = \"\\0\", *ptr;\n  FILE *file = NULL;\n  tjhandle handle = NULL;\n  int row, col, iter = 0, dstBufAlloc = 0, retval = 0;\n  double elapsed, elapsedDecode;\n  int ps = tjPixelSize[pf];\n  int scaledw, scaledh, pitch;\n  int ntilesw = (w + tilew - 1) / tilew, ntilesh = (h + tileh - 1) / tileh;\n  unsigned char *dstPtr, *dstPtr2, *yuvBuf = NULL;\n\n  if (flags & TJFLAG_LOSSLESS)\n    sf.num = sf.denom = 1;\n\n  scaledw = TJSCALED(w, sf);\n  scaledh = TJSCALED(h, sf);\n  pitch = scaledw * ps;\n\n  if (jpegQual > 0) {\n    SNPRINTF(qualStr, 13, \"_Q%d\", jpegQual);\n    qualStr[12] = 0;\n  }\n\n  if ((handle = tjInitDecompress()) == NULL)\n    THROW_TJ(\"executing tjInitDecompress()\");\n\n  if (dstBuf == NULL) {\n    if ((unsigned long long)pitch * (unsigned long long)scaledh >\n        (unsigned long long)((size_t)-1))\n      THROW(\"allocating destination buffer\", \"Image is too large\");\n    if ((dstBuf = (unsigned char *)malloc((size_t)pitch * scaledh)) == NULL)\n      THROW_UNIX(\"allocating destination buffer\");\n    dstBufAlloc = 1;\n  }\n  /* Set the destination buffer to gray so we know whether the decompressor\n     attempted to write to it */\n  memset(dstBuf, 127, (size_t)pitch * scaledh);\n\n  if (doYUV) {\n    int width = doTile ? tilew : scaledw;\n    int height = doTile ? tileh : scaledh;\n    unsigned long yuvSize = tjBufSizeYUV2(width, yuvPad, height, subsamp);\n\n    if (yuvSize == (unsigned long)-1)\n      THROW_TJ(\"allocating YUV buffer\");\n    if ((yuvBuf = (unsigned char *)malloc(yuvSize)) == NULL)\n      THROW_UNIX(\"allocating YUV buffer\");\n    memset(yuvBuf, 127, yuvSize);\n  }\n\n  /* Benchmark */\n  iter = -1;\n  elapsed = elapsedDecode = 0.;\n  while (1) {\n    int tile = 0;\n    double start = getTime();\n\n    for (row = 0, dstPtr = dstBuf; row < ntilesh;\n         row++, dstPtr += (size_t)pitch * tileh) {\n      for (col = 0, dstPtr2 = dstPtr; col < ntilesw;\n           col++, tile++, dstPtr2 += ps * tilew) {\n        int width = doTile ? min(tilew, w - col * tilew) : scaledw;\n        int height = doTile ? min(tileh, h - row * tileh) : scaledh;\n\n        if (doYUV) {\n          double startDecode;\n\n          if (tjDecompressToYUV2(handle, jpegBuf[tile], jpegSize[tile], yuvBuf,\n                                 width, yuvPad, height, flags) == -1)\n            THROW_TJ(\"executing tjDecompressToYUV2()\");\n          startDecode = getTime();\n          if (tjDecodeYUV(handle, yuvBuf, yuvPad, subsamp, dstPtr2, width,\n                          pitch, height, pf, flags) == -1)\n            THROW_TJ(\"executing tjDecodeYUV()\");\n          if (iter >= 0) elapsedDecode += getTime() - startDecode;\n        } else if (tjDecompress2(handle, jpegBuf[tile], jpegSize[tile],\n                                 dstPtr2, width, pitch, height, pf,\n                                 flags) == -1)\n          THROW_TJ(\"executing tjDecompress2()\");\n      }\n    }\n    elapsed += getTime() - start;\n    if (iter >= 0) {\n      iter++;\n      if (elapsed >= benchTime) break;\n    } else if (elapsed >= warmup) {\n      iter = 0;\n      elapsed = elapsedDecode = 0.;\n    }\n  }\n  if (doYUV) elapsed -= elapsedDecode;\n\n  if (tjDestroy(handle) == -1) THROW_TJ(\"executing tjDestroy()\");\n  handle = NULL;\n\n  if (quiet) {\n    printf(\"%-6s%s\",\n           sigfig((double)(w * h) / 1000000. * (double)iter / elapsed, 4,\n                  tempStr, 1024),\n           quiet == 2 ? \"\\n\" : \"  \");\n    if (doYUV)\n      printf(\"%s\\n\",\n             sigfig((double)(w * h) / 1000000. * (double)iter / elapsedDecode,\n                    4, tempStr, 1024));\n    else if (quiet != 2) printf(\"\\n\");\n  } else {\n    printf(\"%s --> Frame rate:         %f fps\\n\",\n           doYUV ? \"Decomp to YUV\" : \"Decompress   \", (double)iter / elapsed);\n    printf(\"                  Throughput:         %f Megapixels/sec\\n\",\n           (double)(w * h) / 1000000. * (double)iter / elapsed);\n    if (doYUV) {\n      printf(\"YUV Decode    --> Frame rate:         %f fps\\n\",\n             (double)iter / elapsedDecode);\n      printf(\"                  Throughput:         %f Megapixels/sec\\n\",\n             (double)(w * h) / 1000000. * (double)iter / elapsedDecode);\n    }\n  }\n\n  if (!doWrite) goto bailout;\n\n  if (sf.num != 1 || sf.denom != 1)\n    SNPRINTF(sizeStr, 24, \"%d_%d\", sf.num, sf.denom);\n  else if (tilew != w || tileh != h)\n    SNPRINTF(sizeStr, 24, \"%dx%d\", tilew, tileh);\n  else SNPRINTF(sizeStr, 24, \"full\");\n  if (decompOnly)\n    SNPRINTF(tempStr, 1024, \"%s_%s.%s\", fileName, sizeStr, ext);\n  else\n    SNPRINTF(tempStr, 1024, \"%s_%s%s_%s.%s\", fileName, subName[subsamp],\n             qualStr, sizeStr, ext);\n\n  if (tjSaveImage(tempStr, dstBuf, scaledw, 0, scaledh, pf, flags) == -1)\n    THROW_TJG(\"saving bitmap\");\n  ptr = strrchr(tempStr, '.');\n  SNPRINTF(ptr, 1024 - (ptr - tempStr), \"-err.%s\", ext);\n  if (srcBuf && sf.num == 1 && sf.denom == 1) {\n    if (!quiet) printf(\"Compression error written to %s.\\n\", tempStr);\n    if (subsamp == TJ_GRAYSCALE) {\n      unsigned long index, index2;\n\n      for (row = 0, index = 0; row < h; row++, index += pitch) {\n        for (col = 0, index2 = index; col < w; col++, index2 += ps) {\n          unsigned long rindex = index2 + tjRedOffset[pf];\n          unsigned long gindex = index2 + tjGreenOffset[pf];\n          unsigned long bindex = index2 + tjBlueOffset[pf];\n          int y = (int)((double)srcBuf[rindex] * 0.299 +\n                        (double)srcBuf[gindex] * 0.587 +\n                        (double)srcBuf[bindex] * 0.114 + 0.5);\n\n          if (y > 255) y = 255;\n          if (y < 0) y = 0;\n          dstBuf[rindex] = (unsigned char)abs(dstBuf[rindex] - y);\n          dstBuf[gindex] = (unsigned char)abs(dstBuf[gindex] - y);\n          dstBuf[bindex] = (unsigned char)abs(dstBuf[bindex] - y);\n        }\n      }\n    } else {\n      for (row = 0; row < h; row++)\n        for (col = 0; col < w * ps; col++)\n          dstBuf[pitch * row + col] =\n            (unsigned char)abs(dstBuf[pitch * row + col] -\n                               srcBuf[pitch * row + col]);\n    }\n    if (tjSaveImage(tempStr, dstBuf, w, 0, h, pf, flags) == -1)\n      THROW_TJG(\"saving bitmap\");\n  }\n\nbailout:\n  if (file) fclose(file);\n  if (handle) tjDestroy(handle);\n  if (dstBufAlloc) free(dstBuf);\n  free(yuvBuf);\n  return retval;\n}\nstatic int decompTest(char *fileName)\n{\n  FILE *file = NULL;\n  tjhandle handle = NULL;\n  unsigned char **jpegBuf = NULL, *srcBuf = NULL;\n  unsigned long *jpegSize = NULL, srcSize, totalJpegSize;\n  tjtransform *t = NULL;\n  double start, elapsed;\n  int ps = tjPixelSize[pf], tile, row, col, i, iter, retval = 0, decompsrc = 0;\n  char *temp = NULL, tempStr[80], tempStr2[80];\n  /* Original image */\n  int w = 0, h = 0, tilew, tileh, ntilesw = 1, ntilesh = 1, subsamp = -1,\n    cs = -1;\n  /* Transformed image */\n  int tw, th, ttilew, ttileh, tntilesw, tntilesh, tsubsamp, jpegFlags;\n\n  if ((file = fopen(fileName, \"rb\")) == NULL)\n    THROW_UNIX(\"opening file\");\n  if (fseek(file, 0, SEEK_END) < 0 ||\n      (srcSize = ftell(file)) == (unsigned long)-1)\n    THROW_UNIX(\"determining file size\");\n  if ((srcBuf = (unsigned char *)malloc(srcSize)) == NULL)\n    THROW_UNIX(\"allocating memory\");\n  if (fseek(file, 0, SEEK_SET) < 0)\n    THROW_UNIX(\"setting file position\");\n  if (fread(srcBuf, srcSize, 1, file) < 1)\n    THROW_UNIX(\"reading JPEG data\");\n  fclose(file);  file = NULL;\n\n  temp = strrchr(fileName, '.');\n  if (temp != NULL) *temp = '\\0';\n\n  if ((handle = tjInitTransform()) == NULL)\n    THROW_TJ(\"executing tjInitTransform()\");\n  if (tjDecompressHeader4(handle, srcBuf, srcSize, &w, &h, &subsamp, &cs,\n                          &jpegFlags) == -1)\n    THROW_TJ(\"executing tjDecompressHeader4()\");\n  if (w < 1 || h < 1)\n    THROW(\"reading JPEG header\", \"Invalid image dimensions\");\n  if (cs == TJCS_YCCK || cs == TJCS_CMYK) {\n    pf = TJPF_CMYK;  ps = tjPixelSize[pf];\n  }\n  if (jpegFlags & TJFLAG_LOSSLESS)\n    sf.num = sf.denom = 1;\n\n  if (quiet == 1) {\n    printf(\"All performance values in Mpixels/sec\\n\\n\");\n    printf(\"Bitmap     JPEG   JPEG     %s  %s   Xform   Comp    Decomp  \",\n           doTile ? \"Tile \" : \"Image\", doTile ? \"Tile \" : \"Image\");\n    if (doYUV) printf(\"Decode\");\n    printf(\"\\n\");\n    printf(\"Format     CS     Subsamp  Width  Height  Perf    Ratio   Perf    \");\n    if (doYUV) printf(\"Perf\");\n    printf(\"\\n\\n\");\n  } else if (!quiet)\n    printf(\">>>>>  JPEG %s --> %s (%s)  <<<<<\\n\",\n           formatName(subsamp, cs, tempStr), pixFormatStr[pf],\n           (flags & TJFLAG_BOTTOMUP) ? \"Bottom-up\" : \"Top-down\");\n\n  for (tilew = doTile ? 16 : w, tileh = doTile ? 16 : h; ;\n       tilew *= 2, tileh *= 2) {\n    if (tilew > w) tilew = w;\n    if (tileh > h) tileh = h;\n    ntilesw = (w + tilew - 1) / tilew;\n    ntilesh = (h + tileh - 1) / tileh;\n\n    if ((jpegBuf = (unsigned char **)malloc(sizeof(unsigned char *) *\n                                            ntilesw * ntilesh)) == NULL)\n      THROW_UNIX(\"allocating JPEG tile array\");\n    memset(jpegBuf, 0, sizeof(unsigned char *) * ntilesw * ntilesh);\n    if ((jpegSize = (unsigned long *)malloc(sizeof(unsigned long) *\n                                            ntilesw * ntilesh)) == NULL)\n      THROW_UNIX(\"allocating JPEG size array\");\n    memset(jpegSize, 0, sizeof(unsigned long) * ntilesw * ntilesh);\n\n    if ((flags & TJFLAG_NOREALLOC) != 0 &&\n        (doTile || xformOp != TJXOP_NONE || xformOpt != 0 || customFilter))\n      for (i = 0; i < ntilesw * ntilesh; i++) {\n        if (tjBufSize(tilew, tileh, subsamp) > (unsigned long)INT_MAX)\n          THROW(\"getting buffer size\", \"Image is too large\");\n        if ((jpegBuf[i] = (unsigned char *)\n                          tjAlloc(tjBufSize(tilew, tileh, subsamp))) == NULL)\n          THROW_UNIX(\"allocating JPEG tiles\");\n      }\n\n    tw = w;  th = h;  ttilew = tilew;  ttileh = tileh;\n    if (!quiet) {\n      printf(\"\\n%s size: %d x %d\", doTile ? \"Tile\" : \"Image\", ttilew, ttileh);\n      if (sf.num != 1 || sf.denom != 1)\n        printf(\" --> %d x %d\", TJSCALED(tw, sf), TJSCALED(th, sf));\n      printf(\"\\n\");\n    } else if (quiet == 1) {\n      printf(\"%-4s (%s)  %-5s  %-5s    \", pixFormatStr[pf],\n             (flags & TJFLAG_BOTTOMUP) ? \"BU\" : \"TD\", csName[cs],\n             subNameLong[subsamp]);\n      printf(\"%-5d  %-5d   \", tilew, tileh);\n    }\n\n    tsubsamp = subsamp;\n    if (doTile || xformOp != TJXOP_NONE || xformOpt != 0 || customFilter) {\n      if ((t = (tjtransform *)malloc(sizeof(tjtransform) * ntilesw *\n                                     ntilesh)) == NULL)\n        THROW_UNIX(\"allocating image transform array\");\n\n      if (xformOp == TJXOP_TRANSPOSE || xformOp == TJXOP_TRANSVERSE ||\n          xformOp == TJXOP_ROT90 || xformOp == TJXOP_ROT270) {\n        tw = h;  th = w;  ttilew = tileh;  ttileh = tilew;\n      }\n\n      if (xformOpt & TJXOPT_GRAY) tsubsamp = TJ_GRAYSCALE;\n      if (xformOp == TJXOP_HFLIP || xformOp == TJXOP_ROT180)\n        tw = tw - (tw % tjMCUWidth[tsubsamp]);\n      if (xformOp == TJXOP_VFLIP || xformOp == TJXOP_ROT180)\n        th = th - (th % tjMCUHeight[tsubsamp]);\n      if (xformOp == TJXOP_TRANSVERSE || xformOp == TJXOP_ROT90)\n        tw = tw - (tw % tjMCUHeight[tsubsamp]);\n      if (xformOp == TJXOP_TRANSVERSE || xformOp == TJXOP_ROT270)\n        th = th - (th % tjMCUWidth[tsubsamp]);\n      tntilesw = (tw + ttilew - 1) / ttilew;\n      tntilesh = (th + ttileh - 1) / ttileh;\n\n      if (xformOp == TJXOP_TRANSPOSE || xformOp == TJXOP_TRANSVERSE ||\n          xformOp == TJXOP_ROT90 || xformOp == TJXOP_ROT270) {\n        if (tsubsamp == TJSAMP_422) tsubsamp = TJSAMP_440;\n        else if (tsubsamp == TJSAMP_440) tsubsamp = TJSAMP_422;\n      }\n\n      for (row = 0, tile = 0; row < tntilesh; row++) {\n        for (col = 0; col < tntilesw; col++, tile++) {\n          t[tile].r.w = min(ttilew, tw - col * ttilew);\n          t[tile].r.h = min(ttileh, th - row * ttileh);\n          t[tile].r.x = col * ttilew;\n          t[tile].r.y = row * ttileh;\n          t[tile].op = xformOp;\n          t[tile].options = xformOpt | TJXOPT_TRIM;\n          t[tile].customFilter = customFilter;\n          if (t[tile].options & TJXOPT_NOOUTPUT && jpegBuf[tile]) {\n            tjFree(jpegBuf[tile]);  jpegBuf[tile] = NULL;\n          }\n        }\n      }\n\n      iter = -1;\n      elapsed = 0.;\n      while (1) {\n        start = getTime();\n        if (tjTransform(handle, srcBuf, srcSize, tntilesw * tntilesh, jpegBuf,\n                        jpegSize, t, flags) == -1)\n          THROW_TJ(\"executing tjTransform()\");\n        elapsed += getTime() - start;\n        if (iter >= 0) {\n          iter++;\n          if (elapsed >= benchTime) break;\n        } else if (elapsed >= warmup) {\n          iter = 0;\n          elapsed = 0.;\n        }\n      }\n\n      free(t);  t = NULL;\n\n      for (tile = 0, totalJpegSize = 0; tile < tntilesw * tntilesh; tile++)\n        totalJpegSize += jpegSize[tile];\n\n      if (quiet) {\n        printf(\"%-6s%s%-6s%s\",\n               sigfig((double)(w * h) / 1000000. / elapsed, 4, tempStr, 80),\n               quiet == 2 ? \"\\n\" : \"  \",\n               sigfig((double)(w * h * ps) / (double)totalJpegSize, 4,\n                      tempStr2, 80),\n               quiet == 2 ? \"\\n\" : \"  \");\n      } else {\n        printf(\"Transform     --> Frame rate:         %f fps\\n\",\n               1.0 / elapsed);\n        printf(\"                  Output image size:  %lu bytes\\n\",\n               totalJpegSize);\n        printf(\"                  Compression ratio:  %f:1\\n\",\n               (double)(w * h * ps) / (double)totalJpegSize);\n        printf(\"                  Throughput:         %f Megapixels/sec\\n\",\n               (double)(w * h) / 1000000. / elapsed);\n        printf(\"                  Output bit stream:  %f Megabits/sec\\n\",\n               (double)totalJpegSize * 8. / 1000000. / elapsed);\n      }\n    } else {\n      if (quiet == 1) printf(\"N/A     N/A     \");\n      tjFree(jpegBuf[0]);\n      jpegBuf[0] = NULL;\n      decompsrc = 1;\n    }\n\n    if (w == tilew) ttilew = tw;\n    if (h == tileh) ttileh = th;\n    if (!(xformOpt & TJXOPT_NOOUTPUT)) {\n      if (decomp(NULL, decompsrc ? &srcBuf : jpegBuf,\n                 decompsrc ? &srcSize : jpegSize, NULL, tw, th, tsubsamp, 0,\n                 fileName, ttilew, ttileh) == -1)\n        goto bailout;\n    } else if (quiet == 1) printf(\"N/A\\n\");\n\n    for (i = 0; i < ntilesw * ntilesh; i++) {\n      tjFree(jpegBuf[i]);\n      jpegBuf[i] = NULL;\n    }\n    free(jpegBuf);  jpegBuf = NULL;\n    free(jpegSize);  jpegSize = NULL;\n\n    if (tilew == w && tileh == h) break;\n  }\n\nbailout:\n  if (file) fclose(file);\n  if (jpegBuf) {\n    for (i = 0; i < ntilesw * ntilesh; i++)\n      tjFree(jpegBuf[i]);\n  }\n  free(jpegBuf);\n  free(jpegSize);\n  free(srcBuf);\n  free(t);\n  if (handle) { tjDestroy(handle);  handle = NULL; }\n  return retval;\n}\nint main(int argc, char **argv)\n{\n  tjscalingfactor scalingFactor = { 1, 1 };\n  int outSubsamp = -1, outQual = -1;\n  tjtransform xform;\n  int flags = 0;\n  int width, height;\n  char *inFormat, *outFormat;\n  FILE *jpegFile = NULL;\n  unsigned char *imgBuf = NULL, *jpegBuf = NULL;\n  int retval = 0, i, pixelFormat = TJPF_UNKNOWN;\n  tjhandle tjInstance = NULL;\n\n  if ((scalingFactors = tjGetScalingFactors(&numScalingFactors)) == NULL)\n    THROW_TJ(\"getting scaling factors\");\n  memset(&xform, 0, sizeof(tjtransform));\n\n  if (argc < 3)\n    usage(argv[0]);\n\n  /* Parse arguments. */\n  for (i = 3; i < argc; i++) {\n    if (!strncasecmp(argv[i], \"-sc\", 3) && i < argc - 1) {\n      int match = 0, temp1 = 0, temp2 = 0, j;\n\n      if (sscanf(argv[++i], \"%d/%d\", &temp1, &temp2) < 2)\n        usage(argv[0]);\n      for (j = 0; j < numScalingFactors; j++) {\n        if ((double)temp1 / (double)temp2 == (double)scalingFactors[j].num /\n                                             (double)scalingFactors[j].denom) {\n          scalingFactor = scalingFactors[j];\n          match = 1;\n          break;\n        }\n      }\n      if (match != 1)\n        usage(argv[0]);\n    } else if (!strncasecmp(argv[i], \"-su\", 3) && i < argc - 1) {\n      i++;\n      if (!strncasecmp(argv[i], \"g\", 1))\n        outSubsamp = TJSAMP_GRAY;\n      else if (!strcasecmp(argv[i], \"444\"))\n        outSubsamp = TJSAMP_444;\n      else if (!strcasecmp(argv[i], \"422\"))\n        outSubsamp = TJSAMP_422;\n      else if (!strcasecmp(argv[i], \"420\"))\n        outSubsamp = TJSAMP_420;\n      else\n        usage(argv[0]);\n    } else if (!strncasecmp(argv[i], \"-q\", 2) && i < argc - 1) {\n      outQual = atoi(argv[++i]);\n      if (outQual < 1 || outQual > 100)\n        usage(argv[0]);\n    } else if (!strncasecmp(argv[i], \"-g\", 2))\n      xform.options |= TJXOPT_GRAY;\n    else if (!strcasecmp(argv[i], \"-hflip\"))\n      xform.op = TJXOP_HFLIP;\n    else if (!strcasecmp(argv[i], \"-vflip\"))\n      xform.op = TJXOP_VFLIP;\n    else if (!strcasecmp(argv[i], \"-transpose\"))\n      xform.op = TJXOP_TRANSPOSE;\n    else if (!strcasecmp(argv[i], \"-transverse\"))\n      xform.op = TJXOP_TRANSVERSE;\n    else if (!strcasecmp(argv[i], \"-rot90\"))\n      xform.op = TJXOP_ROT90;\n    else if (!strcasecmp(argv[i], \"-rot180\"))\n      xform.op = TJXOP_ROT180;\n    else if (!strcasecmp(argv[i], \"-rot270\"))\n      xform.op = TJXOP_ROT270;\n    else if (!strcasecmp(argv[i], \"-custom\"))\n      xform.customFilter = customFilter;\n    else if (!strncasecmp(argv[i], \"-c\", 2) && i < argc - 1) {\n      if (sscanf(argv[++i], \"%dx%d+%d+%d\", &xform.r.w, &xform.r.h, &xform.r.x,\n                 &xform.r.y) < 4 ||\n          xform.r.x < 0 || xform.r.y < 0 || xform.r.w < 1 || xform.r.h < 1)\n        usage(argv[0]);\n      xform.options |= TJXOPT_CROP;\n    } else if (!strcasecmp(argv[i], \"-fastupsample\")) {\n      printf(\"Using fast upsampling code\\n\");\n      flags |= TJFLAG_FASTUPSAMPLE;\n    } else if (!strcasecmp(argv[i], \"-fastdct\")) {\n      printf(\"Using fastest DCT/IDCT algorithm\\n\");\n      flags |= TJFLAG_FASTDCT;\n    } else if (!strcasecmp(argv[i], \"-accuratedct\")) {\n      printf(\"Using most accurate DCT/IDCT algorithm\\n\");\n      flags |= TJFLAG_ACCURATEDCT;\n    } else usage(argv[0]);\n  }\n\n  /* Determine input and output image formats based on file extensions. */\n  inFormat = strrchr(argv[1], '.');\n  outFormat = strrchr(argv[2], '.');\n  if (inFormat == NULL || outFormat == NULL || strlen(inFormat) < 2 ||\n      strlen(outFormat) < 2)\n    usage(argv[0]);\n  inFormat = &inFormat[1];\n  outFormat = &outFormat[1];\n\n  if (!strcasecmp(inFormat, \"jpg\")) {\n    /* Input image is a JPEG image.  Decompress and/or transform it. */\n    long size;\n    int inSubsamp, inColorspace, inFlags;\n    int doTransform = (xform.op != TJXOP_NONE || xform.options != 0 ||\n                       xform.customFilter != NULL);\n    unsigned long jpegSize;\n\n    /* Read the JPEG file into memory. */\n    if ((jpegFile = fopen(argv[1], \"rb\")) == NULL)\n      THROW_UNIX(\"opening input file\");\n    if (fseek(jpegFile, 0, SEEK_END) < 0 || ((size = ftell(jpegFile)) < 0) ||\n        fseek(jpegFile, 0, SEEK_SET) < 0)\n      THROW_UNIX(\"determining input file size\");\n    if (size == 0)\n      THROW(\"determining input file size\", \"Input file contains no data\");\n    jpegSize = (unsigned long)size;\n    if ((jpegBuf = (unsigned char *)tjAlloc(jpegSize)) == NULL)\n      THROW_UNIX(\"allocating JPEG buffer\");\n    if (fread(jpegBuf, jpegSize, 1, jpegFile) < 1)\n      THROW_UNIX(\"reading input file\");\n    fclose(jpegFile);  jpegFile = NULL;\n\n    if (doTransform) {\n      /* Transform it. */\n      unsigned char *dstBuf = NULL;  /* Dynamically allocate the JPEG buffer */\n      unsigned long dstSize = 0;\n\n      if ((tjInstance = tjInitTransform()) == NULL)\n        THROW_TJ(\"initializing transformer\");\n      xform.options |= TJXOPT_TRIM;\n      if (tjTransform(tjInstance, jpegBuf, jpegSize, 1, &dstBuf, &dstSize,\n                      &xform, flags) < 0) {\n        tjFree(dstBuf);\n        THROW_TJ(\"transforming input image\");\n      }\n      tjFree(jpegBuf);\n      jpegBuf = dstBuf;\n      jpegSize = dstSize;\n    } else {\n      if ((tjInstance = tjInitDecompress()) == NULL)\n        THROW_TJ(\"initializing decompressor\");\n    }\n\n    if (tjDecompressHeader4(tjInstance, jpegBuf, jpegSize, &width, &height,\n                            &inSubsamp, &inColorspace, &inFlags) < 0)\n      THROW_TJ(\"reading JPEG header\");\n\n    if (inFlags & TJFLAG_LOSSLESS)\n      scalingFactor.num = scalingFactor.denom = 1;\n\n    printf(\"%s Image:  %d x %d pixels, %s subsampling, %s colorspace\\n\",\n           (doTransform ? \"Transformed\" : \"Input\"), width, height,\n           subsampName[inSubsamp], colorspaceName[inColorspace]);\n\n    if (!strcasecmp(outFormat, \"jpg\") && doTransform &&\n        scalingFactor.num == 1 && scalingFactor.denom == 1 && outSubsamp < 0 &&\n        outQual < 0) {\n      /* Input image has been transformed, and no re-compression options\n         have been selected.  Write the transformed image to disk and exit. */\n      if ((jpegFile = fopen(argv[2], \"wb\")) == NULL)\n        THROW_UNIX(\"opening output file\");\n      if (fwrite(jpegBuf, jpegSize, 1, jpegFile) < 1)\n        THROW_UNIX(\"writing output file\");\n      fclose(jpegFile);  jpegFile = NULL;\n      goto bailout;\n    }\n\n    /* Scaling and/or a non-JPEG output image format and/or compression options\n       have been selected, so we need to decompress the input/transformed\n       image. */\n    width = TJSCALED(width, scalingFactor);\n    height = TJSCALED(height, scalingFactor);\n    if (outSubsamp < 0)\n      outSubsamp = inSubsamp;\n\n    pixelFormat = TJPF_BGRX;\n    if ((imgBuf = (unsigned char *)tjAlloc(width * height *\n                                           tjPixelSize[pixelFormat])) == NULL)\n      THROW_UNIX(\"allocating uncompressed image buffer\");\n\n    if (tjDecompress2(tjInstance, jpegBuf, jpegSize, imgBuf, width, 0, height,\n                      pixelFormat, flags) < 0)\n      THROW_TJ(\"decompressing JPEG image\");\n    tjFree(jpegBuf);  jpegBuf = NULL;\n    tjDestroy(tjInstance);  tjInstance = NULL;\n  } else {\n    /* Input image is not a JPEG image.  Load it into memory. */\n    if ((imgBuf = tjLoadImage(argv[1], &width, 1, &height, &pixelFormat,\n                              0)) == NULL)\n      THROW_TJ(\"loading input image\");\n    if (outSubsamp < 0) {\n      if (pixelFormat == TJPF_GRAY)\n        outSubsamp = TJSAMP_GRAY;\n      else\n        outSubsamp = TJSAMP_444;\n    }\n    printf(\"Input Image:  %d x %d pixels\\n\", width, height);\n  }\n\n  printf(\"Output Image (%s):  %d x %d pixels\", outFormat, width, height);\n\n  if (!strcasecmp(outFormat, \"jpg\")) {\n    /* Output image format is JPEG.  Compress the uncompressed image. */\n    unsigned long jpegSize = 0;\n\n    jpegBuf = NULL;  /* Dynamically allocate the JPEG buffer */\n\n    if (outQual < 0)\n      outQual = DEFAULT_QUALITY;\n    printf(\", %s subsampling, quality = %d\\n\", subsampName[outSubsamp],\n           outQual);\n\n    if ((tjInstance = tjInitCompress()) == NULL)\n      THROW_TJ(\"initializing compressor\");\n    if (tjCompress2(tjInstance, imgBuf, width, 0, height, pixelFormat,\n                    &jpegBuf, &jpegSize, outSubsamp, outQual, flags) < 0)\n      THROW_TJ(\"compressing image\");\n    tjDestroy(tjInstance);  tjInstance = NULL;\n\n    /* Write the JPEG image to disk. */\n    if ((jpegFile = fopen(argv[2], \"wb\")) == NULL)\n      THROW_UNIX(\"opening output file\");\n    if (fwrite(jpegBuf, jpegSize, 1, jpegFile) < 1)\n      THROW_UNIX(\"writing output file\");\n    tjDestroy(tjInstance);  tjInstance = NULL;\n    fclose(jpegFile);  jpegFile = NULL;\n    tjFree(jpegBuf);  jpegBuf = NULL;\n  } else {\n    /* Output image format is not JPEG.  Save the uncompressed image\n       directly to disk. */\n    printf(\"\\n\");\n    if (tjSaveImage(argv[2], imgBuf, width, 0, height, pixelFormat, 0) < 0)\n      THROW_TJ(\"saving output image\");\n  }\n\nbailout:\n  tjFree(imgBuf);\n  if (tjInstance) tjDestroy(tjInstance);\n  tjFree(jpegBuf);\n  if (jpegFile) fclose(jpegFile);\n  return retval;\n}\nJNIEXPORT void JNICALL Java_org_libjpegturbo_turbojpeg_TJDecompressor_decompressHeader\n  (JNIEnv *env, jobject obj, jbyteArray src, jint jpegSize)\n{\n  tjhandle handle = 0;\n  unsigned char *jpegBuf = NULL;\n  int width = 0, height = 0, jpegSubsamp = -1, jpegColorspace = -1,\n    jpegFlags = -1;\n\n  GET_HANDLE();\n\n  if ((*env)->GetArrayLength(env, src) < jpegSize)\n    THROW_ARG(\"Source buffer is not large enough\");\n\n  BAILIF0NOEC(jpegBuf = (*env)->GetPrimitiveArrayCritical(env, src, 0));\n\n  if (tjDecompressHeader4(handle, jpegBuf, (unsigned long)jpegSize, &width,\n                          &height, &jpegSubsamp, &jpegColorspace,\n                          &jpegFlags) == -1) {\n    SAFE_RELEASE(src, jpegBuf);\n    THROW_TJ();\n  }\n\n  SAFE_RELEASE(src, jpegBuf);\n\n  BAILIF0(_fid = (*env)->GetFieldID(env, _cls, \"jpegSubsamp\", \"I\"));\n  (*env)->SetIntField(env, obj, _fid, jpegSubsamp);\n  if ((_fid = (*env)->GetFieldID(env, _cls, \"jpegColorspace\", \"I\")) == 0)\n    (*env)->ExceptionClear(env);\n  else\n    (*env)->SetIntField(env, obj, _fid, jpegColorspace);\n  if ((_fid = (*env)->GetFieldID(env, _cls, \"jpegFlags\", \"I\")) == 0)\n    (*env)->ExceptionClear(env);\n  else\n    (*env)->SetIntField(env, obj, _fid, jpegFlags);\n  BAILIF0(_fid = (*env)->GetFieldID(env, _cls, \"jpegWidth\", \"I\"));\n  (*env)->SetIntField(env, obj, _fid, width);\n  BAILIF0(_fid = (*env)->GetFieldID(env, _cls, \"jpegHeight\", \"I\"));\n  (*env)->SetIntField(env, obj, _fid, height);\n\nbailout:\n  SAFE_RELEASE(src, jpegBuf);\n}\nDLLEXPORT int tjDecompressHeader3(tjhandle handle,\n                                  const unsigned char *jpegBuf,\n                                  unsigned long jpegSize, int *width,\n                                  int *height, int *jpegSubsamp,\n                                  int *jpegColorspace)\n{\n  int flags;\n\n  return tjDecompressHeader4(handle, jpegBuf, jpegSize, width, height,\n                             jpegSubsamp, jpegColorspace, &flags);\n}\nDLLEXPORT int tjDecompressHeader2(tjhandle handle, unsigned char *jpegBuf,\n                                  unsigned long jpegSize, int *width,\n                                  int *height, int *jpegSubsamp)\n{\n  int jpegColorspace;\n\n  return tjDecompressHeader3(handle, jpegBuf, jpegSize, width, height,\n                             jpegSubsamp, &jpegColorspace);\n}\nDLLEXPORT int tjDecompressHeader(tjhandle handle, unsigned char *jpegBuf,\n                                 unsigned long jpegSize, int *width,\n                                 int *height)\n{\n  int jpegSubsamp;\n\n  return tjDecompressHeader2(handle, jpegBuf, jpegSize, width, height,\n                             &jpegSubsamp);\n}\n",
    "target": 0,
    "idx": 2053499
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "int msc_zero_object(sc_card_t *card, msc_id objectId, size_t dataLength)\n{\n\tu8 zeroBuffer[MSC_MAX_APDU];\n\tsize_t i;\n\tsize_t max_write_unit = MIN(MSC_MAX_APDU, MSC_MAX_SEND - 9); /* - 9 for object ID+length */\n\n\tmemset(zeroBuffer, 0, max_write_unit);\n\tfor(i = 0; i < dataLength; i += max_write_unit) {\n\t\tint r = msc_partial_update_object(card, objectId, i, zeroBuffer, MIN(dataLength - i, max_write_unit));\n\t\tLOG_TEST_RET(card->ctx, r, \"Error in zeroing file update\");\n\t}\n\treturn 0;\n}\n",
    "target": 0,
    "idx": 2053631
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "int\nsc_pkcs15init_rmdir(struct sc_pkcs15_card *p15card, struct sc_profile *profile,\n\t\tstruct sc_file *df)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tunsigned char buffer[1024];\n\tstruct sc_path\tpath;\n\tstruct sc_file\t*file, *parent;\n\tint\t\tr = 0, nfids;\n\n\tif (df == NULL)\n\t\treturn SC_ERROR_INTERNAL;\n\tsc_log(ctx, \"sc_pkcs15init_rmdir(%s)\", sc_print_path(&df->path));\n\n\tif (df->type == SC_FILE_TYPE_DF) {\n\t\tr = sc_pkcs15init_authenticate(profile, p15card, df, SC_AC_OP_LIST_FILES);\n\t\tif (r < 0)\n\t\t\treturn r;\n\t\tr = sc_list_files(p15card->card, buffer, sizeof(buffer));\n\t\tif (r < 0)\n\t\t\treturn r;\n\n\t\tpath = df->path;\n\t\tpath.len += 2;\n\t\tif (path.len > SC_MAX_PATH_SIZE)\n\t\t\treturn SC_ERROR_INTERNAL;\n\n\t\tnfids = r / 2;\n\t\twhile (r >= 0 && nfids--) {\n\t\t\tpath.value[path.len-2] = buffer[2*nfids];\n\t\t\tpath.value[path.len-1] = buffer[2*nfids+1];\n\t\t\tr = sc_select_file(p15card->card, &path, &file);\n\t\t\tif (r < 0) {\n\t\t\t\tif (r == SC_ERROR_FILE_NOT_FOUND)\n\t\t\t\t\tcontinue;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr = sc_pkcs15init_rmdir(p15card, profile, file);\n\t\t\tsc_file_free(file);\n\t\t}\n\n\t\tif (r < 0)\n\t\t\treturn r;\n\t}\n\n\t/* Select the parent DF */\n\tpath = df->path;\n\tpath.len -= 2;\n\tr = sc_select_file(p15card->card, &path, &parent);\n\tif (r < 0)\n\t\treturn r;\n\n\tr = sc_pkcs15init_authenticate(profile, p15card, df, SC_AC_OP_DELETE);\n\tif (r < 0) {\n\t\tsc_file_free(parent);\n\t\treturn r;\n\t}\n\tr = sc_pkcs15init_authenticate(profile, p15card, parent, SC_AC_OP_DELETE);\n\tsc_file_free(parent);\n\tif (r < 0)\n\t\treturn r;\n\n\tmemset(&path, 0, sizeof(path));\n\tpath.type = SC_PATH_TYPE_FILE_ID;\n\tpath.value[0] = df->id >> 8;\n\tpath.value[1] = df->id & 0xFF;\n\tpath.len = 2;\n\n\t/* ensure that the card is in the correct lifecycle */\n\tr = sc_pkcs15init_set_lifecycle(p15card->card, SC_CARDCTRL_LIFECYCLE_ADMIN);\n\tif (r < 0 && r != SC_ERROR_NOT_SUPPORTED)\n\t\treturn r;\n\n\tr = sc_delete_file(p15card->card, &path);\n\treturn r;\n}\n",
    "target": 0,
    "idx": 2053927
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "\n/* Read an ECOFF symbol table.  */\n\nbool\n_bfd_ecoff_slurp_symbol_table (bfd *abfd)\n{\n  const struct ecoff_backend_data * const backend = ecoff_backend (abfd);\n  const bfd_size_type external_ext_size\n    = backend->debug_swap.external_ext_size;\n  const bfd_size_type external_sym_size\n    = backend->debug_swap.external_sym_size;\n  void (* const swap_ext_in) (bfd *, void *, EXTR *)\n    = backend->debug_swap.swap_ext_in;\n  void (* const swap_sym_in) (bfd *, void *, SYMR *)\n    = backend->debug_swap.swap_sym_in;\n  ecoff_symbol_type *internal;\n  ecoff_symbol_type *internal_ptr;\n  char *eraw_src;\n  char *eraw_end;\n  FDR *fdr_ptr;\n  FDR *fdr_end;\n  size_t amt;\n\n  /* If we've already read in the symbol table, do nothing.  */\n  if (ecoff_data (abfd)->canonical_symbols != NULL)\n    return true;\n\n  /* Get the symbolic information.  */\n  if (! _bfd_ecoff_slurp_symbolic_info (abfd, NULL,\n\t\t\t\t\t&ecoff_data (abfd)->debug_info))\n    return false;\n  if (bfd_get_symcount (abfd) == 0)\n    return true;\n\n  if (_bfd_mul_overflow (bfd_get_symcount (abfd),\n\t\t\t sizeof (ecoff_symbol_type), &amt))\n    {\n      bfd_set_error (bfd_error_file_too_big);\n      return false;\n    }\n  internal = (ecoff_symbol_type *) bfd_alloc (abfd, amt);\n  if (internal == NULL)\n    return false;\n\n  internal_ptr = internal;\n  eraw_src = (char *) ecoff_data (abfd)->debug_info.external_ext;\n  eraw_end = (eraw_src\n\t      + (ecoff_data (abfd)->debug_info.symbolic_header.iextMax\n\t\t * external_ext_size));\n  for (; eraw_src < eraw_end; eraw_src += external_ext_size, internal_ptr++)\n    {\n      EXTR internal_esym;\n\n      (*swap_ext_in) (abfd, (void *) eraw_src, &internal_esym);\n\n      /* PR 17512: file: 3372-1000-0.004.  */\n      HDRR *symhdr = &ecoff_data (abfd)->debug_info.symbolic_header;\n      if (internal_esym.asym.iss >= symhdr->issExtMax\n\t  || internal_esym.asym.iss < 0)\n\t{\n\t  bfd_set_error (bfd_error_bad_value);\n\t  return false;\n\t}\n\n      internal_ptr->symbol.name = (ecoff_data (abfd)->debug_info.ssext\n\t\t\t\t   + internal_esym.asym.iss);\n\n      if (!ecoff_set_symbol_info (abfd, &internal_esym.asym,\n\t\t\t\t  &internal_ptr->symbol, 1,\n\t\t\t\t  internal_esym.weakext))\n\treturn false;\n\n      /* The alpha uses a negative ifd field for section symbols.  */\n      /* PR 17512: file: 3372-1983-0.004.  */\n      if (internal_esym.ifd >= symhdr->ifdMax\n\t  || internal_esym.ifd < 0)\n\tinternal_ptr->fdr = NULL;\n      else\n\tinternal_ptr->fdr = (ecoff_data (abfd)->debug_info.fdr\n\t\t\t     + internal_esym.ifd);\n      internal_ptr->local = false;\n      internal_ptr->native = (void *) eraw_src;\n    }\n\n  /* The local symbols must be accessed via the fdr's, because the\n     string and aux indices are relative to the fdr information.  */\n  fdr_ptr = ecoff_data (abfd)->debug_info.fdr;\n  fdr_end = fdr_ptr + ecoff_data (abfd)->debug_info.symbolic_header.ifdMax;\n  for (; fdr_ptr < fdr_end; fdr_ptr++)\n    {\n      char *lraw_src;\n      char *lraw_end;\n\n      lraw_src = ((char *) ecoff_data (abfd)->debug_info.external_sym\n\t\t  + fdr_ptr->isymBase * external_sym_size);\n      lraw_end = lraw_src + fdr_ptr->csym * external_sym_size;\n      for (;\n\t   lraw_src < lraw_end;\n\t   lraw_src += external_sym_size, internal_ptr++)\n\t{\n\t  SYMR internal_sym;\n\n\t  (*swap_sym_in) (abfd, (void *) lraw_src, &internal_sym);\n\n\t  HDRR *symhdr = &ecoff_data (abfd)->debug_info.symbolic_header;\n\t  if (internal_sym.iss >= symhdr->issMax\n\t      || internal_sym.iss < 0)\n\t    {\n\t      bfd_set_error (bfd_error_bad_value);\n\t      return false;\n\t    }\n\t  internal_ptr->symbol.name = (ecoff_data (abfd)->debug_info.ss\n\t\t\t\t       + fdr_ptr->issBase\n\t\t\t\t       + internal_sym.iss);\n\t  if (!ecoff_set_symbol_info (abfd, &internal_sym,\n\t\t\t\t      &internal_ptr->symbol, 0, 0))\n\t    return false;\n\t  internal_ptr->fdr = fdr_ptr;\n\t  internal_ptr->local = true;\n\t  internal_ptr->native = (void *) lraw_src;\n\t}\n    }\n\n  /* PR 17512: file: 3372-3080-0.004.\n     A discrepancy between ecoff_data (abfd)->debug_info.symbolic_header.isymMax\n     and ecoff_data (abfd)->debug_info.symbolic_header.ifdMax can mean that\n     we have fewer symbols than we were expecting.  Allow for this by updating\n     the symbol count and warning the user.  */\n  if (internal_ptr - internal < (ptrdiff_t) bfd_get_symcount (abfd))\n    {\n      abfd->symcount = internal_ptr - internal;\n      _bfd_error_handler\n\t/* xgettext:c-format */\n\t(_(\"%pB: warning: isymMax (%ld) is greater than ifdMax (%ld)\"),\n\t abfd, ecoff_data (abfd)->debug_info.symbolic_header.isymMax,\n\t ecoff_data (abfd)->debug_info.symbolic_header.ifdMax);\n    }\n\n  ecoff_data (abfd)->canonical_symbols = internal;\n",
    "target": 0,
    "idx": 2055933
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "static BOOL freerdp_assistance_crypt_derive_key_sha1(BYTE* hash, size_t hashLength, BYTE* key,\n                                                     size_t keyLength)\n{\n\tBOOL rc = FALSE;\n\tBYTE pad1[64] = { 0 };\n\tBYTE pad2[64] = { 0 };\n\n\tmemset(pad1, 0x36, sizeof(pad1));\n\tmemset(pad2, 0x5C, sizeof(pad2));\n\n\tfor (size_t i = 0; i < hashLength; i++)\n\t{\n\t\tpad1[i] ^= hash[i];\n\t\tpad2[i] ^= hash[i];\n\t}\n\n\tBYTE* buffer = (BYTE*)calloc(hashLength, 2);\n\n\tif (!buffer)\n\t\tgoto fail;\n\n\tif (!winpr_Digest(WINPR_MD_SHA1, pad1, 64, buffer, hashLength))\n\t\tgoto fail;\n\n\tif (!winpr_Digest(WINPR_MD_SHA1, pad2, 64, &buffer[hashLength], hashLength))\n\t\tgoto fail;\n\n\tCopyMemory(key, buffer, keyLength);\n\trc = TRUE;\nfail:\n\tfree(buffer);\n\treturn rc;\n}\n\nstatic BOOL append_address(rdpAssistanceFile* file, const char* host, const char* port)\n{\n\tWINPR_ASSERT(file);\n\n\terrno = 0;\n\tunsigned long p = strtoul(port, NULL, 0);\n\n\tif ((errno != 0) || (p == 0) || (p > UINT16_MAX))\n\t{\n\t\tWLog_ERR(TAG, \"Failed to parse ASSISTANCE file: ConnectionString2 invalid port value %s\",\n\t\t         port);\n\t\treturn FALSE;\n\t}\n\n\tif (!ArrayList_Append(file->MachineAddresses, _strdup(host)))\n\t\treturn FALSE;\n\treturn ArrayList_Append(file->MachinePorts, p);\n}\nstatic BOOL freerdp_assistance_parse_connection_string1(rdpAssistanceFile* file)\n{\n\tchar* tokens[8] = { 0 };\n\tBOOL rc = FALSE;\n\n\tWINPR_ASSERT(file);\n\n\tif (!file->RCTicket)\n\t\treturn FALSE;\n\n\t/**\n\t * <ProtocolVersion>,<protocolType>,<machineAddressList>,<assistantAccountPwd>,\n\t * <RASessionID>,<RASessionName>,<RASessionPwd>,<protocolSpecificParms>\n\t */\n\tchar* str = _strdup(file->RCTicket);\n\n\tif (!str)\n\t\tgoto error;\n\n\tconst size_t length = strlen(str);\n\n\tint count = 1;\n\tfor (size_t i = 0; i < length; i++)\n\t{\n\t\tif (str[i] == ',')\n\t\t\tcount++;\n\t}\n\n\tif (count != 8)\n\t\tgoto error;\n\n\tcount = 0;\n\ttokens[count++] = str;\n\n\tfor (size_t i = 0; i < length; i++)\n\t{\n\t\tif (str[i] == ',')\n\t\t{\n\t\t\tstr[i] = '\\0';\n\t\t\ttokens[count++] = &str[i + 1];\n\t\t}\n\t}\n\n\tif (strcmp(tokens[0], \"65538\") != 0)\n\t\tgoto error;\n\n\tif (strcmp(tokens[1], \"1\") != 0)\n\t\tgoto error;\n\n\tif (strcmp(tokens[3], \"*\") != 0)\n\t\tgoto error;\n\n\tif (strcmp(tokens[5], \"*\") != 0)\n\t\tgoto error;\n\n\tif (strcmp(tokens[6], \"*\") != 0)\n\t\tgoto error;\n\n\tfile->RASessionId = _strdup(tokens[4]);\n\n\tif (!file->RASessionId)\n\t\tgoto error;\n\n\tfile->RASpecificParams = _strdup(tokens[7]);\n\n\tif (!file->RASpecificParams)\n\t\tgoto error;\n\n\tif (!freerdp_assistance_parse_address_list(file, tokens[2]))\n\t\tgoto error;\n\n\trc = TRUE;\nerror:\n\tfree(str);\n\treturn rc;\n}\nstatic BOOL freerdp_assistance_parse_connection_string2(rdpAssistanceFile* file)\n{\n\tBOOL rc = FALSE;\n\n\tWINPR_ASSERT(file);\n\n\tif (!file->ConnectionString2)\n\t\treturn FALSE;\n\n\tchar* str = _strdup(file->ConnectionString2);\n\tif (!str)\n\t\tgoto out_fail;\n\n\tchar* e = NULL;\n\tsize_t elen = 0;\n\tif (!freerdp_assistance_consume_input_and_get_element(str, \"E\", &e, &elen))\n\t\tgoto out_fail;\n\n\tif (!e || (elen == 0))\n\t\tgoto out_fail;\n\n\tchar* a = NULL;\n\tsize_t alen = 0;\n\tif (!freerdp_assistance_get_element(e, elen, \"A\", &a, &alen))\n\t\tgoto out_fail;\n\n\tif (!a || (alen == 0))\n\t\tgoto out_fail;\n\n\tif (!freerdp_assistance_parse_find_elements_of_c(file, e, elen))\n\t\tgoto out_fail;\n\n\t/* '\\0' terminate the detected XML elements so\n\t * the parser can continue with terminated strings\n\t */\n\ta[alen] = '\\0';\n\tif (!freerdp_assistance_parse_attr_str(&file->RASpecificParams, \"KH\", a))\n\t\tgoto out_fail;\n\n\tif (!freerdp_assistance_parse_attr_str(&file->RASpecificParams2, \"KH2\", a))\n\t\tgoto out_fail;\n\n\tif (!freerdp_assistance_parse_attr_str(&file->RASessionId, \"ID\", a))\n\t\tgoto out_fail;\n\n\trc = TRUE;\nout_fail:\n\tfree(str);\n\treturn rc;\n}\nstatic BOOL freerdp_assistance_decrypt2(rdpAssistanceFile* file)\n{\n\tBOOL rc = FALSE;\n\tint status = 0;\n\tsize_t cbPasswordW;\n\tsize_t cchOutW = 0;\n\tWINPR_CIPHER_CTX* aesDec = NULL;\n\tWCHAR* PasswordW = NULL;\n\tBYTE* pbIn = NULL;\n\tBYTE* pbOut = NULL;\n\tsize_t cbOut, cbIn, cbFinal;\n\tBYTE DerivedKey[WINPR_AES_BLOCK_SIZE] = { 0 };\n\tBYTE InitializationVector[WINPR_AES_BLOCK_SIZE] = { 0 };\n\tBYTE PasswordHash[WINPR_SHA1_DIGEST_LENGTH] = { 0 };\n\n\tWINPR_ASSERT(file);\n\n\tif (!file->password)\n\t\treturn FALSE;\n\n\tPasswordW = ConvertUtf8ToWCharAlloc(file->password, &cbPasswordW);\n\tif (!PasswordW)\n\t{\n\t\tWLog_ERR(TAG, \"Failed to parse ASSISTANCE file: Conversion from UCS2 to UTF8 failed\");\n\t\treturn FALSE;\n\t}\n\n\tcbPasswordW = (cbPasswordW) * sizeof(WCHAR);\n\n\tif (!winpr_Digest(WINPR_MD_SHA1, (BYTE*)PasswordW, cbPasswordW, PasswordHash,\n\t                  sizeof(PasswordHash)))\n\t\tgoto fail;\n\n\tif (!freerdp_assistance_crypt_derive_key_sha1(PasswordHash, sizeof(PasswordHash), DerivedKey,\n\t                                              sizeof(DerivedKey)))\n\t\tgoto fail;\n\n\taesDec =\n\t    winpr_Cipher_New(WINPR_CIPHER_AES_128_CBC, WINPR_DECRYPT, DerivedKey, InitializationVector);\n\n\tif (!aesDec)\n\t\tgoto fail;\n\n\tcbOut = cbFinal = 0;\n\tcbIn = (size_t)file->EncryptedLHTicketLength;\n\tpbIn = (BYTE*)file->EncryptedLHTicket;\n\tpbOut = (BYTE*)calloc(1, cbIn + WINPR_AES_BLOCK_SIZE + 2);\n\n\tif (!pbOut)\n\t\tgoto fail;\n\n\tif (!winpr_Cipher_Update(aesDec, pbIn, cbIn, pbOut, &cbOut))\n\t\tgoto fail;\n\n\tif (!winpr_Cipher_Final(aesDec, pbOut + cbOut, &cbFinal))\n\t{\n\t\tWLog_ERR(TAG, \"winpr_Cipher_Final failure\");\n\t\tgoto fail;\n\t}\n\n\tcbOut += cbFinal;\n\tcbFinal = 0;\n\n\tunion\n\t{\n\t\tconst WCHAR* wc;\n\t\tconst BYTE* b;\n\t} cnv;\n\n\tcnv.b = pbOut;\n\tcchOutW = cbOut / sizeof(WCHAR);\n\n\tif (!update_connectionstring2_wchar(file, cnv.wc, cchOutW))\n\t{\n\t\tWLog_ERR(TAG, \"Failed to parse ASSISTANCE file: Conversion from UCS2 to UTF8 failed\");\n\t\tgoto fail;\n\t}\n\n\tif (!freerdp_assistance_parse_connection_string2(file))\n\t\tgoto fail;\n\n\trc = TRUE;\nfail:\n\twinpr_Cipher_Free(aesDec);\n\tfree(PasswordW);\n\tfree(pbOut);\n\tWLog_DBG(TAG, \"freerdp_assistance_parse_connection_string2: %d\", status);\n\treturn rc;\n}\nint freerdp_assistance_parse_file_buffer(rdpAssistanceFile* file, const char* cbuffer, size_t size,\n                                         const char* password)\n{\n\tWINPR_ASSERT(file);\n\tif (!password)\n\t{\n\t\tWLog_WARN(TAG, \"empty password supplied\");\n\t}\n\n\tif (!cbuffer || (size == 0))\n\t{\n\t\tWLog_WARN(TAG, \"no data supplied [%p, %\" PRIuz \"]\", cbuffer, size);\n\t\treturn -1;\n\t}\n\n\tchar* abuffer = strndup(cbuffer, size);\n\tconst size_t len = strnlen(cbuffer, size);\n\tif (len == size)\n\t\tWLog_WARN(TAG, \"Input data not '\\0' terminated\");\n\n\tif (!abuffer)\n\t\treturn -1;\n\n\tconst int rc = freerdp_assistance_parse_file_buffer_int(file, abuffer, len + 1, password);\n\tfree(abuffer);\n\treturn rc;\n}\nint freerdp_assistance_parse_file(rdpAssistanceFile* file, const char* name, const char* password)\n{\n\tint status;\n\tBYTE* buffer;\n\tFILE* fp = NULL;\n\tsize_t readSize;\n\tunion\n\t{\n\t\tINT64 i64;\n\t\tsize_t s;\n\t} fileSize;\n\n\tif (!update_name(file, name))\n\t\treturn -1;\n\n\tfp = winpr_fopen(name, \"r\");\n\n\tif (!fp)\n\t{\n\t\tWLog_ERR(TAG, \"Failed to open ASSISTANCE file %s \", name);\n\t\treturn -1;\n\t}\n\n\t_fseeki64(fp, 0, SEEK_END);\n\tfileSize.i64 = _ftelli64(fp);\n\t_fseeki64(fp, 0, SEEK_SET);\n\n\tif (fileSize.i64 < 1)\n\t{\n\t\tWLog_ERR(TAG, \"Failed to read ASSISTANCE file %s \", name);\n\t\tfclose(fp);\n\t\treturn -1;\n\t}\n\n\tbuffer = (BYTE*)malloc(fileSize.s + 2);\n\n\tif (!buffer)\n\t{\n\t\tfclose(fp);\n\t\treturn -1;\n\t}\n\n\treadSize = fread(buffer, fileSize.s, 1, fp);\n\n\tif (!readSize)\n\t{\n\t\tif (!ferror(fp))\n\t\t\treadSize = fileSize.s;\n\t}\n\n\tfclose(fp);\n\n\tif (readSize < 1)\n\t{\n\t\tWLog_ERR(TAG, \"Failed to read ASSISTANCE file %s \", name);\n\t\tfree(buffer);\n\t\tbuffer = NULL;\n\t\treturn -1;\n\t}\n\n\tbuffer[fileSize.s] = '\\0';\n\tbuffer[fileSize.s + 1] = '\\0';\n\tstatus = freerdp_assistance_parse_file_buffer(file, (char*)buffer, fileSize.s, password);\n\tfree(buffer);\n\treturn status;\n}\nBOOL freerdp_assistance_populate_settings_from_assistance_file(rdpAssistanceFile* file,\n                                                               rdpSettings* settings)\n{\n\tif (!freerdp_settings_set_bool(settings, FreeRDP_RemoteAssistanceMode, TRUE))\n\t\treturn FALSE;\n\n\tif (!file->RASessionId || !file->MachineAddresses)\n\t\treturn FALSE;\n\n\tif (!freerdp_settings_set_string(settings, FreeRDP_RemoteAssistanceSessionId,\n\t                                 file->RASessionId))\n\t\treturn FALSE;\n\n\tif (file->RCTicket)\n\t{\n\t\tif (!freerdp_settings_set_string(settings, FreeRDP_RemoteAssistanceRCTicket,\n\t\t                                 file->RCTicket))\n\t\t\treturn FALSE;\n\t}\n\telse\n\t{\n\t\tif (!freerdp_settings_set_string(settings, FreeRDP_RemoteAssistanceRCTicket,\n\t\t                                 file->ConnectionString2))\n\t\t\treturn FALSE;\n\t}\n\n\tif (file->PassStub)\n\t{\n\t\tif (!freerdp_settings_set_string(settings, FreeRDP_RemoteAssistancePassStub,\n\t\t                                 file->PassStub))\n\t\t\treturn FALSE;\n\t}\n\n\tif (ArrayList_Count(file->MachineAddresses) < 1)\n\t\treturn FALSE;\n\n\tconst char* addr = ArrayList_GetItem(file->MachineAddresses, 0);\n\tif (!freerdp_settings_set_string(settings, FreeRDP_ServerHostname, addr))\n\t\treturn FALSE;\n\n\tif (!freerdp_settings_set_string(settings, FreeRDP_AssistanceFile, file->filename))\n\t\treturn FALSE;\n\n\tif (!freerdp_settings_set_string(settings, FreeRDP_RemoteAssistancePassword, file->password))\n\t\treturn FALSE;\n\n\tif (file->Username)\n\t{\n\t\tif (!freerdp_settings_set_string(settings, FreeRDP_Username, file->Username))\n\t\t\treturn FALSE;\n\t}\n\n\tif (!freerdp_settings_set_bool(settings, FreeRDP_RemoteAssistanceMode, TRUE))\n\t\treturn FALSE;\n\n\tsize_t ports = ArrayList_Count(file->MachinePorts);\n\tif (ports < 1)\n\t\treturn FALSE;\n\n\tconst UINT32 port = (UINT32)ArrayList_GetItem(file->MachinePorts, 0);\n\tif (!freerdp_settings_set_uint32(settings, FreeRDP_ServerPort, port))\n\t\treturn FALSE;\n\n\tif (!freerdp_settings_set_pointer_len(settings, FreeRDP_TargetNetAddresses, NULL, ports))\n\t\treturn FALSE;\n\tif (!freerdp_settings_set_pointer_len(settings, FreeRDP_TargetNetPorts, file->MachinePorts,\n\t                                      ports))\n\t\treturn FALSE;\n\n\tfor (size_t i = 0; i < ArrayList_Count(file->MachineAddresses); i++)\n\t{\n\t\tconst char* addr = ArrayList_GetItem(file->MachineAddresses, i);\n\t\tif (!freerdp_settings_set_pointer_array(settings, FreeRDP_TargetNetAddresses, i, addr))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\nvoid freerdp_assistance_file_free(rdpAssistanceFile* file)\n{\n\tif (!file)\n\t\treturn;\n\n\tupdate_password(file, NULL);\n\tupdate_connectionstring2(file, NULL, 0);\n\tfree(file->filename);\n\tfree(file->Username);\n\tfree(file->LHTicket);\n\tfree(file->RCTicket);\n\tfree(file->PassStub);\n\tfree(file->ConnectionString1);\n\tfree(file->EncryptedLHTicket);\n\tfree(file->RASessionId);\n\tfree(file->RASpecificParams);\n\tfree(file->RASpecificParams2);\n\tfree(file->EncryptedPassStub);\n\n\tArrayList_Free(file->MachineAddresses);\n\tArrayList_Free(file->MachinePorts);\n\tArrayList_Free(file->MachineUris);\n\tfree(file);\n}\nvoid freerdp_assistance_print_file(rdpAssistanceFile* file, wLog* log, DWORD level)\n{\n\tWINPR_ASSERT(file);\n\n\tWLog_Print(log, level, \"Username: %s\", file->Username);\n\tWLog_Print(log, level, \"LHTicket: %s\", file->LHTicket);\n\tWLog_Print(log, level, \"RCTicket: %s\", file->RCTicket);\n\tWLog_Print(log, level, \"RCTicketEncrypted: %\" PRId32, file->RCTicketEncrypted);\n\tWLog_Print(log, level, \"PassStub: %s\", file->PassStub);\n\tWLog_Print(log, level, \"DtStart: %\" PRIu32, file->DtStart);\n\tWLog_Print(log, level, \"DtLength: %\" PRIu32, file->DtLength);\n\tWLog_Print(log, level, \"LowSpeed: %\" PRId32, file->LowSpeed);\n\tWLog_Print(log, level, \"RASessionId: %s\", file->RASessionId);\n\tWLog_Print(log, level, \"RASpecificParams: %s\", file->RASpecificParams);\n\tWLog_Print(log, level, \"RASpecificParams2: %s\", file->RASpecificParams2);\n\n\tfor (size_t x = 0; x < ArrayList_Count(file->MachineAddresses); x++)\n\t{\n\t\tUINT32 port = 0;\n\t\tconst char* uri = NULL;\n\t\tconst char* addr = ArrayList_GetItem(file->MachineAddresses, x);\n\t\tif (x < ArrayList_Count(file->MachinePorts))\n\t\t\tport = (UINT32)ArrayList_GetItem(file->MachinePorts, x);\n\t\tif (x < ArrayList_Count(file->MachineUris))\n\t\t\turi = ArrayList_GetItem(file->MachineUris, x);\n\n\t\tWLog_Print(log, level, \"MachineAddress [%\" PRIdz \": %s\", x, addr);\n\t\tWLog_Print(log, level, \"MachinePort    [%\" PRIdz \": %\" PRIu32, x, port);\n\t\tWLog_Print(log, level, \"MachineURI     [%\" PRIdz \": %s\", x, uri);\n\t}\n}\nBOOL freerdp_assistance_get_encrypted_pass_stub(rdpAssistanceFile* file, const char** pwd,\n                                                size_t* size)\n{\n\tif (!file || !pwd || !size)\n\t\treturn FALSE;\n\n\t*pwd = (const char*)file->EncryptedPassStub;\n\t*size = file->EncryptedPassStubLength;\n\treturn TRUE;\n}\nint freerdp_assistance_set_connection_string2(rdpAssistanceFile* file, const char* string,\n                                              const char* password)\n{\n\tif (!file || !string || !password)\n\t\treturn -1;\n\n\tchar* str = _strdup(string);\n\tif (!str)\n\t\treturn -1;\n\n\tif (!update_connectionstring2_nocopy(file, str))\n\t\treturn -1;\n\tif (!update_password(file, password))\n\t\treturn -1;\n\treturn freerdp_assistance_parse_connection_string2(file);\n}\nstatic BOOL test_msrsc_incident_file_type1(wLog* log)\n{\n\tBOOL rc = FALSE;\n\tint status;\n\tchar* pass = NULL;\n\tchar* expertBlob = NULL;\n\tconst char* EncryptedPassStub;\n\tsize_t EncryptedPassStubLength;\n\trdpAssistanceFile* file = freerdp_assistance_file_new();\n\n\tif (!file)\n\t\treturn -1;\n\n\tstatus = freerdp_assistance_parse_file_buffer(file, TEST_MSRC_INCIDENT_FILE_TYPE1,\n\t                                              sizeof(TEST_MSRC_INCIDENT_FILE_TYPE1),\n\t                                              TEST_MSRC_INCIDENT_PASSWORD_TYPE1);\n\tWLog_Print(log, WLOG_INFO, \"freerdp_assistance_parse_file_buffer: %d\", status);\n\n\tif (status < 0)\n\t\tgoto fail;\n\n\tfreerdp_assistance_print_file(file, WLog_Get(\"foo\"), WLOG_INFO);\n\n\tif (!freerdp_assistance_get_encrypted_pass_stub(file, &EncryptedPassStub,\n\t                                                &EncryptedPassStubLength))\n\t\tgoto fail;\n\n\tpass = freerdp_assistance_bin_to_hex_string(EncryptedPassStub, EncryptedPassStubLength);\n\n\tif (!pass)\n\t\tgoto fail;\n\n\tWLog_Print(log, WLOG_INFO, \"freerdp_assistance_decrypt: %d %s [%\" PRIdz \"]\", status, pass,\n\t           EncryptedPassStubLength);\n\texpertBlob = freerdp_assistance_construct_expert_blob(\"Edgar Olougouna\", pass);\n\tWLog_Print(log, WLOG_INFO, \"expertBlob='%s'\", expertBlob);\n\trc = TRUE;\nfail:\n\tfreerdp_assistance_file_free(file);\n\tfree(pass);\n\tfree(expertBlob);\n\treturn rc;\n}\nstatic BOOL test_msrsc_incident_file_type2(wLog* log)\n{\n\tint status = -1;\n\tchar* pass = NULL;\n\tchar* expertBlob = NULL;\n\tconst char* EncryptedPassStub = NULL;\n\tsize_t EncryptedPassStubLength;\n\trdpAssistanceFile* file = freerdp_assistance_file_new();\n\n\tif (!file)\n\t\treturn -1;\n\n\tstatus = freerdp_assistance_parse_file_buffer(file, connectionstr2, sizeof(connectionstr2),\n\t                                              TEST_MSRC_INCIDENT_PASSWORD_TYPE2);\n\tprintf(\"freerdp_assistance_parse_file_buffer: %d\\n\", status);\n\n\tif (status < 0)\n\t\tgoto fail;\n\n\tstatus = freerdp_assistance_parse_file_buffer(file, TEST_MSRC_INCIDENT_FILE_TYPE2,\n\t                                              sizeof(TEST_MSRC_INCIDENT_FILE_TYPE2),\n\t                                              TEST_MSRC_INCIDENT_PASSWORD_TYPE2);\n\tprintf(\"freerdp_assistance_parse_file_buffer: %d\\n\", status);\n\n\tif (status < 0)\n\t\tgoto fail;\n\n\tfreerdp_assistance_print_file(file, log, WLOG_INFO);\n\tstatus = freerdp_assistance_get_encrypted_pass_stub(file, &EncryptedPassStub,\n\t                                                    &EncryptedPassStubLength);\n\tpass = freerdp_assistance_bin_to_hex_string(EncryptedPassStub, EncryptedPassStubLength);\n\n\tif (!pass)\n\t\tgoto fail;\n\n\tWLog_Print(log, WLOG_INFO, \"freerdp_assistance_decrypt: %d %s [%\" PRIdz \"]\", status, pass,\n\t           EncryptedPassStubLength);\n\n\tif (status < 0)\n\t\tgoto fail;\n\n\texpertBlob = freerdp_assistance_construct_expert_blob(\"Edgar Olougouna\", pass);\n\tWLog_Print(log, WLOG_INFO, \"expertBlob='%s'\", expertBlob);\nfail:\n\tfreerdp_assistance_file_free(file);\n\tfree(expertBlob);\n\tfree(pass);\n\treturn status >= 0 ? TRUE : FALSE;\n}\n",
    "target": 0,
    "idx": 2059682
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "static bool read_plane(BitstreamRange* range,\n                       std::shared_ptr<HeifPixelImage> image, heif_channel channel,\n                       int width, int height, int bit_depth)\n{\n  if (width <= 0 || height <= 0) {\n    return false;\n  }\n  if (std::numeric_limits<size_t>::max()/width/height == 0) {\n    return false;\n  }\n  if (!range->prepare_read(static_cast<size_t>(width) * height)) {\n    return false;\n  }\n  if (!image->add_plane(channel, width, height, bit_depth)) {\n    return false;\n  }\n  int stride;\n  uint8_t* plane = image->get_plane(channel, &stride);\n  assert(stride >= width);\n  auto stream = range->get_istream();\n  for (int y = 0; y < height; y++, plane += stride) {\n    assert(stream->read(plane, width));\n  }\n  return true;\n}\nstatic bool read_plane_interleaved(BitstreamRange* range,\n                                   std::shared_ptr<HeifPixelImage> image, heif_channel channel,\n                                   int width, int height, int bit_depth, int comps)\n{\n  if (width <= 0 || height <= 0) {\n    return false;\n  }\n  if (std::numeric_limits<size_t>::max()/width/height/comps == 0) {\n    return false;\n  }\n  if (!range->prepare_read(static_cast<size_t>(width) * height * comps)) {\n    return false;\n  }\n  if (!image->add_plane(channel, width, height, bit_depth)) {\n    return false;\n  }\n  int stride;\n  uint8_t* plane = image->get_plane(channel, &stride);\n  assert(stride >= width * comps);\n  auto stream = range->get_istream();\n  for (int y = 0; y < height; y++, plane += stride) {\n    assert(stream->read(plane, width * comps));\n  }\n  return true;\n}\n",
    "target": 0,
    "idx": 2059814
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "static void thrift_set_method(struct ndpi_detection_module_struct *ndpi_struct,\n                              struct ndpi_flow_struct *flow,\n                              char const * const method, size_t method_length)\n{\n  if (thrift_validate_method(method, method_length) == 0) {\n    ndpi_set_risk(ndpi_struct, flow, NDPI_INVALID_CHARACTERS, \"Invalid method name\");\n    flow->protos.thrift.method[0] = '\\0';\n  } else {\n    strncpy(flow->protos.thrift.method, method, ndpi_min(sizeof(flow->protos.thrift.method), method_length));\n  }\n}\n",
    "target": 0,
    "idx": 2060070
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "void LibRaw::xtrans_interpolate(int passes)\n{\n  int cstat[4] = {0, 0, 0, 0};\n  int ndir;\n  static const short orth[12] = {1, 0, 0, 1, -1, 0, 0, -1, 1, 0, 0, 1},\n                     patt[2][16] = {{0, 1, 0, -1, 2, 0, -1, 0, 1, 1, 1, -1, 0,\n                                     0, 0, 0},\n                                    {0, 1, 0, -2, 1, 0, -2, 0, 1, 1, -2, -2, 1,\n                                     -1, -1, 1}},\n                     dir[4] = {1, LIBRAW_AHD_TILE, LIBRAW_AHD_TILE + 1,\n                               LIBRAW_AHD_TILE - 1};\n  short allhex[3][3][2][8];\n  ushort sgrow = 0, sgcol = 0;\n\n  if (width < LIBRAW_AHD_TILE || height < LIBRAW_AHD_TILE)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT; // too small image\n                                       /* Check against right pattern */\n  for (int row = 0; row < 6; row++)\n    for (int col = 0; col < 6; col++)\n      cstat[(unsigned)fcol(row, col)]++;\n\n  if (cstat[0] < 6 || cstat[0] > 10 || cstat[1] < 16 || cstat[1] > 24 ||\n      cstat[2] < 6 || cstat[2] > 10 || cstat[3])\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  // Init allhex table to unreasonable values\n  for (int i = 0; i < 3; i++)\n    for (int j = 0; j < 3; j++)\n      for (int k = 0; k < 2; k++)\n        for (int l = 0; l < 8; l++)\n          allhex[i][j][k][l] = 32700;\n\n  cielab(0, 0);\n  ndir = 4 << int(passes > 1);\n\n  int minv = 0, maxv = 0, minh = 0, maxh = 0;\n  /* Map a green hexagon around each non-green pixel and vice versa:\t*/\n  for (int row = 0; row < 3; row++)\n    for (int col = 0; col < 3; col++)\n      for (int ng = 0, d = 0; d < 10; d += 2)\n      {\n        int g = fcol(row, col) == 1;\n        if (fcol(row + orth[d], col + orth[d + 2]) == 1)\n          ng = 0;\n        else\n          ng++;\n        if (ng == 4)\n        {\n          sgrow = row;\n          sgcol = col;\n        }\n        if (ng == g + 1)\n        {\n            int c;\n            FORC(8)\n            {\n                int v = orth[d] * patt[g][c * 2] + orth[d + 1] * patt[g][c * 2 + 1];\n                int h = orth[d + 2] * patt[g][c * 2] + orth[d + 3] * patt[g][c * 2 + 1];\n                minv = MIN(v, minv);\n                maxv = MAX(v, maxv);\n                minh = MIN(v, minh);\n                maxh = MAX(v, maxh);\n                allhex[row][col][0][c ^ (g * 2 & d)] = h + v * width;\n                allhex[row][col][1][c ^ (g * 2 & d)] = h + v * LIBRAW_AHD_TILE;\n            }\n        }\n      }\n\n  // Check allhex table initialization\n  for (int i = 0; i < 3; i++)\n    for (int j = 0; j < 3; j++)\n      for (int k = 0; k < 2; k++)\n        for (int l = 0; l < 8; l++)\n          if (allhex[i][j][k][l] > maxh + maxv * width + 1 ||\n              allhex[i][j][k][l] < minh + minv * width - 1)\n            throw LIBRAW_EXCEPTION_IO_CORRUPT;\n  int retrycount = 0;\n\n  /* Set green1 and green3 to the minimum and maximum allowed values:\t*/\n  for (int row = 2; row < height - 2; row++)\n  {\n      int col;\n      ushort min, max;\n      for (col = 2, max = 0u, min = 0xffffu; col < int(width) - 2; col++)\n      {\n          if (fcol(row, col) == 1 && (min = ~(max = 0)))\n              continue;\n          ushort(*pix)[4];\n          pix = image + row * width + col;\n          short* hex = allhex[row % 3][col % 3][0];\n          if (!max)\n          {\n              int c;\n              FORC(6)\n              {\n                  int val = pix[hex[c]][1];\n                  if (min > val)\n                      min = val;\n                  if (max < val)\n                      max = val;\n              }\n          }\n          pix[0][1] = min;\n          pix[0][3] = max;\n          switch ((row - sgrow) % 3)\n          {\n          case 1:\n              if (row < height - 3)\n              {\n                  row++;\n                  col--;\n              }\n              break;\n          case 2:\n              if ((min = ~(max = 0)) && (col += 2) < width - 3 && row > 2)\n              {\n                  row--;\n                  if (retrycount++ > width * height)\n                      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n              }\n          }\n      }\n  }\n\n  for (int row = 3; row < 9 && row < height - 3; row++)\n\t  for (int col = 3; col < 9 && col < width - 3; col++)\n\t  {\n\t\t  if ((fcol(row, col)) == 1)\n\t\t\t  continue;\n          short* hex = allhex[row % 3][col % 3][0];\n          int c;\n\t\t  FORC(2)\n\t\t  {\n\t\t\t  int idx3 = 3 * hex[4 + c] + row * width + col;\n\t\t\t  int idx4 = -3 * hex[4 + c] + row * width + col;\n\t\t\t  int maxidx = width * height;\n\t\t\t  if (idx3 < 0 || idx3 >= maxidx)\n\t\t\t\t  throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\t\t\t  if (idx4 < 0 || idx4 >= maxidx)\n\t\t\t\t  throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\t\t  }\n\t  }\n\n#if defined(LIBRAW_USE_OPENMP)\n  int buffer_count = omp_get_max_threads();\n#else\n  int buffer_count = 1;\n#endif\n\n  size_t buffer_size = LIBRAW_AHD_TILE * LIBRAW_AHD_TILE * (ndir * 11 + 6);\n  char** buffers = malloc_omp_buffers(buffer_count, buffer_size);\n\n#if defined(LIBRAW_USE_OPENMP)\n# pragma omp parallel for schedule(dynamic) default(none) firstprivate(buffers, allhex, passes, sgrow, sgcol, ndir) shared(dir) \n#endif\n    for (int top = 3; top < height - 19; top += LIBRAW_AHD_TILE - 16)\n    {\n#if defined(LIBRAW_USE_OPENMP)\n        char* buffer = buffers[omp_get_thread_num()];\n#else\n        char* buffer = buffers[0];\n#endif\n\n        ushort(*rgb)[LIBRAW_AHD_TILE][LIBRAW_AHD_TILE][3], (*rix)[3];\n        short(*lab)[LIBRAW_AHD_TILE][3], (*lix)[3];\n        float(*drv)[LIBRAW_AHD_TILE][LIBRAW_AHD_TILE];\n        char(*homo)[LIBRAW_AHD_TILE][LIBRAW_AHD_TILE];\n\n        rgb = (ushort(*)[LIBRAW_AHD_TILE][LIBRAW_AHD_TILE][3])buffer;\n        lab = (short(*)[LIBRAW_AHD_TILE][3])(\n            buffer + LIBRAW_AHD_TILE * LIBRAW_AHD_TILE * (ndir * 6));\n        drv = (float(*)[LIBRAW_AHD_TILE][LIBRAW_AHD_TILE])(\n            buffer + LIBRAW_AHD_TILE * LIBRAW_AHD_TILE * (ndir * 6 + 6));\n        homo = (char(*)[LIBRAW_AHD_TILE][LIBRAW_AHD_TILE])(\n            buffer + LIBRAW_AHD_TILE * LIBRAW_AHD_TILE * (ndir * 10 + 6));\n\n        for (int left = 3; left < width - 19; left += LIBRAW_AHD_TILE - 16)\n        {\n            int mrow = MIN(top + LIBRAW_AHD_TILE, height - 3);\n            int mcol = MIN(left + LIBRAW_AHD_TILE, width - 3);\n            for (int row = top; row < mrow; row++)\n                for (int col = left; col < mcol; col++)\n                    memcpy(rgb[0][row - top][col - left], image[row * width + col], 6);\n            int c;\n            FORC3 memcpy(rgb[c + 1], rgb[0], sizeof * rgb);\n\n            /* Interpolate green horizontally, vertically, and along both diagonals:\n             */\n            int color[3][8];\n            for (int row = top; row < mrow; row++)\n                for (int col = left; col < mcol; col++)\n                {\n                    int f;\n                    if ((f = fcol(row, col)) == 1)\n                        continue;\n                    ushort (*pix)[4] = image + row * width + col;\n                    short* hex = allhex[row % 3][col % 3][0];\n                    color[1][0] = 174 * (pix[hex[1]][1] + pix[hex[0]][1]) -\n                        46 * (pix[2 * hex[1]][1] + pix[2 * hex[0]][1]);\n                    color[1][1] = 223 * pix[hex[3]][1] + pix[hex[2]][1] * 33 +\n                        92 * (pix[0][f] - pix[-hex[2]][f]);\n                    FORC(2)\n                        color[1][2 + c] = 164 * pix[hex[4 + c]][1] +\n                        92 * pix[-2 * hex[4 + c]][1] +\n                        33 * (2 * pix[0][f] - pix[3 * hex[4 + c]][f] -\n                            pix[-3 * hex[4 + c]][f]);\n                    FORC4 rgb[c ^ !((row - sgrow) % 3)][row - top][col - left][1] =\n                        LIM(color[1][c] >> 8, pix[0][1], pix[0][3]);\n                }\n\n            for (int pass = 0; pass < passes; pass++)\n            {\n                if (pass == 1)\n                    memcpy(rgb += 4, buffer, 4 * sizeof * rgb);\n\n                /* Recalculate green from interpolated values of closer pixels:\t*/\n                if (pass)\n                {\n                    for (int row = top + 2; row < mrow - 2; row++)\n                        for (int col = left + 2; col < mcol - 2; col++)\n                        {\n                            int f;\n                            if ((f = fcol(row, col)) == 1)\n                                continue;\n                            ushort(*pix)[4] = image + row * width + col;\n                            short* hex = allhex[row % 3][col % 3][1];\n                            for (int d = 3; d < 6; d++)\n                            {\n                                rix =\n                                    &rgb[(d - 2) ^ !((row - sgrow) % 3)][row - top][col - left];\n                                int val = rix[-2 * hex[d]][1] + 2 * rix[hex[d]][1] -\n                                    rix[-2 * hex[d]][f] - 2 * rix[hex[d]][f] + 3 * rix[0][f];\n                                rix[0][1] = LIM(val / 3, pix[0][1], pix[0][3]);\n                            }\n                        }\n                }\n\n                /* Interpolate red and blue values for solitary green pixels:\t*/\n                for (int row = (top - sgrow + 4) / 3 * 3 + sgrow; row < mrow - 2; row += 3)\n                    for (int col = (left - sgcol + 4) / 3 * 3 + sgcol; col < mcol - 2; col += 3)\n                {\n                    rix = &rgb[0][row - top][col - left];\n                    int h = fcol(row, col + 1);\n\n\t\t\t\t\tif (h == 1) // Incorrect pattern\n                      break;\n\n                    float diff[6];\n                    memset(diff, 0, sizeof diff);\n                    for (int i = 1, d = 0; d < 6; d++, i ^= LIBRAW_AHD_TILE ^ 1, h ^= 2)\n                    {\n                        for (c = 0; c < 2; c++, h ^= 2)\n                        {\n                            int g = 2 * rix[0][1] - rix[i << c][1] - rix[-i << c][1];\n                            color[h][d] = g + rix[i << c][h] + rix[-i << c][h];\n                            if (d > 1)\n                                diff[d] += SQR((float)rix[i << c][1] - (float)rix[-i << c][1] -\n                                    (float)rix[i << c][h] + (float)rix[-i << c][h]) + SQR((float)g);\n                        }\n                        if (d > 1 && (d & 1))\n                            if (diff[d - 1] < diff[d])\n                                FORC(2) color[c * 2][d] = color[c * 2][d - 1];\n                        if (d < 2 || (d & 1))\n                        {\n                            FORC(2) rix[0][c * 2] = CLIP(color[c * 2][d] / 2);\n                            rix += LIBRAW_AHD_TILE * LIBRAW_AHD_TILE;\n                        }\n                    }\n                }\n\n                /* Interpolate red for blue pixels and vice versa:\t\t*/\n                for (int row = top + 3; row < mrow - 3; row++)\n                    for (int col = left + 3; col < mcol - 3; col++)\n                    {\n                        int f;\n                        if ((f = 2 - fcol(row, col)) == 1)\n                            continue;\n                        rix = &rgb[0][row - top][col - left];\n                        c = (row - sgrow) % 3 ? LIBRAW_AHD_TILE : 1;\n                        int h = 3 * (c ^ LIBRAW_AHD_TILE ^ 1);\n                        for (int d = 0; d < 4; d++, rix += LIBRAW_AHD_TILE * LIBRAW_AHD_TILE)\n                        {\n                            int i = d > 1 || ((d ^ c) & 1) ||\n                                ((ABS(rix[0][1] - rix[c][1]) +\n                                    ABS(rix[0][1] - rix[-c][1])) <\n                                    2 * (ABS(rix[0][1] - rix[h][1]) +\n                                        ABS(rix[0][1] - rix[-h][1])))\n                                ? c\n                                : h;\n                            rix[0][f] = CLIP((rix[i][f] + rix[-i][f] + 2 * rix[0][1] -\n                                rix[i][1] - rix[-i][1]) /\n                                2);\n                        }\n                    }\n\n                /* Fill in red and blue for 2x2 blocks of green:\t\t*/\n                for (int row = top + 2; row < mrow - 2; row++)\n                    if ((row - sgrow) % 3)\n                        for (int col = left + 2; col < mcol - 2; col++)\n                            if ((col - sgcol) % 3)\n                            {\n                                rix = &rgb[0][row - top][col - left];\n                                short* hex = allhex[row % 3][col % 3][1];\n                                for (int d = 0; d < 8;\n                                    d += 2, rix += LIBRAW_AHD_TILE * LIBRAW_AHD_TILE)\n                                    if (hex[d] + hex[d + 1])\n                                    {\n                                        int g = 3 * rix[0][1] - 2 * rix[hex[d]][1] - rix[hex[d + 1]][1];\n                                        for (c = 0; c < 4; c += 2)\n                                            rix[0][c] = CLIP(\n                                                (g + 2 * rix[hex[d]][c] + rix[hex[d + 1]][c]) / 3);\n                                    }\n                                    else\n                                    {\n                                        int g = 2 * rix[0][1] - rix[hex[d]][1] - rix[hex[d + 1]][1];\n                                        for (c = 0; c < 4; c += 2)\n                                            rix[0][c] =\n                                            CLIP((g + rix[hex[d]][c] + rix[hex[d + 1]][c]) / 2);\n                                    }\n                            }\n            }\n            rgb = (ushort(*)[LIBRAW_AHD_TILE][LIBRAW_AHD_TILE][3])buffer;\n            mrow -= top;\n            mcol -= left;\n\n            /* Convert to CIELab and differentiate in all directions:\t*/\n            // no effect\n            for (int d = 0; d < ndir; d++)\n            {\n                for (int row = 2; row < mrow - 2; row++)\n                    for (int col = 2; col < mcol - 2; col++)\n                        cielab(rgb[d][row][col], lab[row][col]);\n                for (int f = dir[d & 3], row = 3; row < mrow - 3; row++)\n                    for (int col = 3; col < mcol - 3; col++)\n                    {\n                        lix = &lab[row][col];\n                        int g = 2 * lix[0][0] - lix[f][0] - lix[-f][0];\n                        drv[d][row][col] =\n                            SQR(g) +\n                            SQR((2 * lix[0][1] - lix[f][1] - lix[-f][1] + g * 500 / 232)) +\n                            SQR((2 * lix[0][2] - lix[f][2] - lix[-f][2] - g * 500 / 580));\n                    }\n            }\n\n            /* Build homogeneity maps from the derivatives:\t\t\t*/\n            memset(homo, 0, ndir * LIBRAW_AHD_TILE * LIBRAW_AHD_TILE);\n            for (int row = 4; row < mrow - 4; row++)\n                for (int col = 4; col < mcol - 4; col++)\n                {\n                    int d;\n                    float tr;\n                    for (tr = FLT_MAX, d = 0; d < ndir; d++)\n                        if (tr > drv[d][row][col])\n                            tr = drv[d][row][col];\n                    tr *= 8;\n                    for (int dd = 0; dd < ndir; dd++)\n                        for (int v = -1; v <= 1; v++)\n                            for (int h = -1; h <= 1; h++)\n                                if (drv[dd][row + v][col + h] <= tr)\n                                    homo[dd][row][col]++;\n                }\n\n            /* Average the most homogeneous pixels for the final result:\t*/\n            if (height - top < LIBRAW_AHD_TILE + 4)\n                mrow = height - top + 2;\n            if (width - left < LIBRAW_AHD_TILE + 4)\n                mcol = width - left + 2;\n            for (int row = MIN(top, 8); row < mrow - 8; row++)\n                for (int col = MIN(left, 8); col < mcol - 8; col++)\n                {\n                    int v;\n                    int hm[8];\n                    for (int d = 0; d < ndir; d++)\n                        for (v = -2, hm[d] = 0; v <= 2; v++)\n                            for (int h = -2; h <= 2; h++)\n                                hm[d] += homo[d][row + v][col + h];\n                    for (int d = 0; d < ndir - 4; d++)\n                        if (hm[d] < hm[d + 4])\n                            hm[d] = 0;\n                        else if (hm[d] > hm[d + 4])\n                            hm[d + 4] = 0;\n                    ushort max;\n                    int d;\n                    for (d = 1, max = hm[0]; d < ndir; d++)\n                        if (max < hm[d])\n                            max = hm[d];\n                    max -= max >> 3;\n\n                    int avg[4];\n                    memset(avg, 0, sizeof avg);\n                    for (int dd = 0; dd < ndir; dd++)\n                        if (hm[dd] >= max)\n                        {\n                            FORC3 avg[c] += rgb[dd][row][col][c];\n                            avg[3]++;\n                        }\n                    FORC3 image[(row + top) * width + col + left][c] = avg[c] / avg[3];\n                }\n        }\n    }\n  \n#ifdef LIBRAW_USE_OPENMP\n#pragma omp barrier\n#endif\n\n    free_omp_buffers(buffers, buffer_count);\n\n    border_interpolate(8);\n}\n",
    "target": 0,
    "idx": 2060728
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "\nstatic void\ncomdat_delf (void *ent)\n{\n  struct comdat_hash_entry *e = ent;\n  free (e->comdat_name);\n  free (e->symname);\n  free (e);\n\nstatic bool\nfill_comdat_hash (bfd *abfd)\n{\n  bfd_byte *esymstart, *esym, *esymend;\n\n  /* Unfortunately, the PE format stores essential information in the\n     symbol table, of all places.  We need to extract that information\n     now, so that objdump and the linker will know how to handle the\n     section without worrying about the symbols.  We can't call\n     slurp_symtab, because the linker doesn't want the swapped symbols.  */\n\n  /* COMDAT sections are special.  The first symbol is the section\n     symbol, which tells what kind of COMDAT section it is.  The\n     second symbol is the \"comdat symbol\" - the one with the unique\n     name.  GNU uses the section symbol for the unique name; MS uses\n     \".text\" for every comdat section.  Sigh.  - DJ.  */\n\n  /* This is not mirrored in sec_to_styp_flags(), but there doesn't\n     seem to be a need to, either, and it would at best be rather messy.  */\n\n  if (! _bfd_coff_get_external_symbols (abfd))\n    return true;\n\n  esymstart = esym = (bfd_byte *) obj_coff_external_syms (abfd);\n  esymend = esym + obj_raw_syment_count (abfd) * bfd_coff_symesz (abfd);\n\n  for (struct internal_syment isym;\n       esym < esymend;\n       esym += (isym.n_numaux + 1) * bfd_coff_symesz (abfd))\n    {\n      char buf[SYMNMLEN + 1];\n      const char *symname;\n      flagword sec_flags = SEC_LINK_ONCE;\n\n      bfd_coff_swap_sym_in (abfd, esym, &isym);\n\n      /* According to the MSVC documentation, the first TWO entries\n\t with the section # are both of interest to us.  The first one\n\t is the \"section symbol\" (section name).  The second is the\n\t comdat symbol name.  Here, we've found the first qualifying\n\t entry; we distinguish it from the second with a state flag.\n\n\t In the case of gas-generated (at least until that is fixed)\n\t .o files, it isn't necessarily the second one.  It may be\n\t some other later symbol.\n\n\t Since gas also doesn't follow MS conventions and emits the\n\t section similar to .text$<name>, where <something> is the\n\t name we're looking for, we distinguish the two as follows:\n\n\t If the section name is simply a section name (no $) we\n\t presume it's MS-generated, and look at precisely the second\n\t symbol for the comdat name.  If the section name has a $, we\n\t assume it's gas-generated, and look for <something> (whatever\n\t follows the $) as the comdat symbol.  */\n\n      /* All 3 branches use this.  */\n      symname = _bfd_coff_internal_syment_name (abfd, &isym, buf);\n\n      /* PR 17512 file: 078-11867-0.004  */\n      if (symname == NULL)\n\t{\n\t  _bfd_error_handler (_(\"%pB: unable to load COMDAT section name\"),\n\t\t\t      abfd);\n\t  continue;\n\t}\n\n      union internal_auxent aux;\n\n      struct comdat_hash_entry needle;\n      needle.target_index = isym.n_scnum;\n\n      void **slot\n\t= htab_find_slot (pe_data (abfd)->comdat_hash, &needle, INSERT);\n      if (slot == NULL)\n\treturn false;\n\n      if (*slot == NULL)\n\t{\n\t  if (isym.n_numaux != 1)\n\t    aux.x_scn.x_comdat = 0;\n\t  else\n\t    {\n\t      /* PR 17512: file: e2cfe54f.  */\n\t      if (esym + isym.n_numaux * bfd_coff_symesz (abfd) >= esymend)\n\t\t{\n\t\t  /* xgettext:c-format */\n\t\t  _bfd_error_handler (_(\"%pB: warning: no symbol for\"\n\t\t\t\t\t\" section '%s' found\"),\n\t\t\t\t      abfd, symname);\n\t\t  continue;\n\t\t}\n\t      bfd_coff_swap_aux_in (abfd, (esym + bfd_coff_symesz (abfd)),\n\t\t\t\t    isym.n_type, isym.n_sclass, 0,\n\t\t\t\t    isym.n_numaux, &aux);\n\t    }\n\n\t  /* FIXME: Microsoft uses NODUPLICATES and ASSOCIATIVE, but\n\t     gnu uses ANY and SAME_SIZE.  Unfortunately, gnu doesn't\n\t     do the comdat symbols right.  So, until we can fix it to\n\t     do the right thing, we are temporarily disabling comdats\n\t     for the MS types (they're used in DLLs and C++, but we\n\t     don't support *their* C++ libraries anyway - DJ.  */\n\n\t  /* Cygwin does not follow the MS style, and uses ANY and\n\t     SAME_SIZE where NODUPLICATES and ASSOCIATIVE should be\n\t     used.  For Interix, we just do the right thing up\n\t     front.  */\n\n\t  switch (aux.x_scn.x_comdat)\n\t    {\n\t    case IMAGE_COMDAT_SELECT_NODUPLICATES:\n#ifdef STRICT_PE_FORMAT\n\t      sec_flags |= SEC_LINK_DUPLICATES_ONE_ONLY;\n#else\n\t      sec_flags &= ~SEC_LINK_ONCE;\n#endif\n\t      break;\n\n\t    case IMAGE_COMDAT_SELECT_ANY:\n\t      sec_flags |= SEC_LINK_DUPLICATES_DISCARD;\n\t      break;\n\n\t    case IMAGE_COMDAT_SELECT_SAME_SIZE:\n\t      sec_flags |= SEC_LINK_DUPLICATES_SAME_SIZE;\n\t      break;\n\n\t    case IMAGE_COMDAT_SELECT_EXACT_MATCH:\n\t      /* Not yet fully implemented ??? */\n\t      sec_flags |= SEC_LINK_DUPLICATES_SAME_CONTENTS;\n\t      break;\n\n\t      /* debug$S gets this case; other implications ???  */\n\n\t      /* There may be no symbol.  We'll search the whole\n\t\t table.  Is this the right place to play this game?\n\t\t Or should we do it when reading it in?  */\n\t    case IMAGE_COMDAT_SELECT_ASSOCIATIVE:\n#ifdef STRICT_PE_FORMAT\n\t      /* FIXME: This is not currently implemented.  */\n\t      sec_flags |= SEC_LINK_DUPLICATES_DISCARD;\n#else\n\t      sec_flags &= ~SEC_LINK_ONCE;\n#endif\n\t      break;\n\n\t    default:  /* 0 means \"no symbol\" */\n\t      /* debug$F gets this case; other implications ???  */\n\t      sec_flags |= SEC_LINK_DUPLICATES_DISCARD;\n\t      break;\n\t    }\n\n\t  *slot = bfd_zmalloc (sizeof (struct comdat_hash_entry));\n\t  if (*slot == NULL)\n\t    return false;\n\t  struct comdat_hash_entry *newentry = *slot;\n\t  newentry->sec_flags = sec_flags;\n\t  newentry->symname = bfd_strdup (symname);\n\t  newentry->target_index = isym.n_scnum;\n\t  newentry->isym = isym;\n\t  newentry->comdat_symbol = -1;\n\t}\n      else\n\t{\n\t  struct comdat_hash_entry *entry = *slot;\n\n\t  if (entry->comdat_symbol != -1)\n\t    continue;\n\n\t  char *target_name = strchr (entry->symname, '$');\n\t  if (target_name != NULL)\n\t    {\n\t      /* Gas mode: the first matching on partial name.  */\n\n\t      target_name += 1;\n#ifndef TARGET_UNDERSCORE\n#define TARGET_UNDERSCORE 0\n#endif\n\t      /* Is this the name we're looking for ?  */\n\t      if (strcmp (target_name,\n\t\t\t  symname + (TARGET_UNDERSCORE ? 1 : 0)) != 0)\n\t\t{\n\t\t  /* Not the name we're looking for */\n\t\t  continue;\n\t\t}\n\t    }\n\t  /* MSVC mode: the lexically second symbol (or drop through\n\t     from the above).  */\n\t  /* This must the second symbol with the section #.  It is\n\t     the actual symbol name.  Intel puts the two adjacent, but\n\t     Alpha (at least) spreads them out.  */\n\n\t  entry->comdat_symbol = (esym - esymstart) / bfd_coff_symesz (abfd);\n\t  entry->comdat_name = bfd_strdup (symname);\n\t}\n    }\n\n  return true;\n",
    "target": 0,
    "idx": 2061822
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "void\nxmlParseComment(xmlParserCtxtPtr ctxt) {\n    xmlChar *buf = NULL;\n    size_t size = XML_PARSER_BUFFER_SIZE;\n    size_t len = 0;\n    size_t maxLength = (ctxt->options & XML_PARSE_HUGE) ?\n                       XML_MAX_HUGE_LENGTH :\n                       XML_MAX_TEXT_LENGTH;\n    xmlParserInputState state;\n    const xmlChar *in;\n    size_t nbchar = 0;\n    int ccol;\n    int inputid;\n\n    /*\n     * Check that there is a comment right here.\n     */\n    if ((RAW != '<') || (NXT(1) != '!'))\n        return;\n    SKIP(2);\n    if ((RAW != '-') || (NXT(1) != '-'))\n        return;\n    state = ctxt->instate;\n    ctxt->instate = XML_PARSER_COMMENT;\n    inputid = ctxt->input->id;\n    SKIP(2);\n    GROW;\n\n    /*\n     * Accelerated common case where input don't need to be\n     * modified before passing it to the handler.\n     */\n    in = ctxt->input->cur;\n    do {\n\tif (*in == 0xA) {\n\t    do {\n\t\tctxt->input->line++; ctxt->input->col = 1;\n\t\tin++;\n\t    } while (*in == 0xA);\n\t}\nget_more:\n        ccol = ctxt->input->col;\n\twhile (((*in > '-') && (*in <= 0x7F)) ||\n\t       ((*in >= 0x20) && (*in < '-')) ||\n\t       (*in == 0x09)) {\n\t\t    in++;\n\t\t    ccol++;\n\t}\n\tctxt->input->col = ccol;\n\tif (*in == 0xA) {\n\t    do {\n\t\tctxt->input->line++; ctxt->input->col = 1;\n\t\tin++;\n\t    } while (*in == 0xA);\n\t    goto get_more;\n\t}\n\tnbchar = in - ctxt->input->cur;\n\t/*\n\t * save current set of data\n\t */\n\tif (nbchar > 0) {\n            if (buf == NULL) {\n                if ((*in == '-') && (in[1] == '-'))\n                    size = nbchar + 1;\n                else\n                    size = XML_PARSER_BUFFER_SIZE + nbchar;\n                buf = (xmlChar *) xmlMallocAtomic(size);\n                if (buf == NULL) {\n                    xmlErrMemory(ctxt, NULL);\n                    ctxt->instate = state;\n                    return;\n                }\n                len = 0;\n            } else if (len + nbchar + 1 >= size) {\n                xmlChar *new_buf;\n                size  += len + nbchar + XML_PARSER_BUFFER_SIZE;\n                new_buf = (xmlChar *) xmlRealloc(buf, size);\n                if (new_buf == NULL) {\n                    xmlFree (buf);\n                    xmlErrMemory(ctxt, NULL);\n                    ctxt->instate = state;\n                    return;\n                }\n                buf = new_buf;\n            }\n            memcpy(&buf[len], ctxt->input->cur, nbchar);\n            len += nbchar;\n            buf[len] = 0;\n\t}\n        if (len > maxLength) {\n            xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,\n                         \"Comment too big found\", NULL);\n            xmlFree (buf);\n            return;\n        }\n\tctxt->input->cur = in;\n\tif (*in == 0xA) {\n\t    in++;\n\t    ctxt->input->line++; ctxt->input->col = 1;\n\t}\n\tif (*in == 0xD) {\n\t    in++;\n\t    if (*in == 0xA) {\n\t\tctxt->input->cur = in;\n\t\tin++;\n\t\tctxt->input->line++; ctxt->input->col = 1;\n\t\tgoto get_more;\n\t    }\n\t    in--;\n\t}\n\tSHRINK;\n\tGROW;\n        if (ctxt->instate == XML_PARSER_EOF) {\n            xmlFree(buf);\n            return;\n        }\n\tin = ctxt->input->cur;\n\tif (*in == '-') {\n\t    if (in[1] == '-') {\n\t        if (in[2] == '>') {\n\t\t    if (ctxt->input->id != inputid) {\n\t\t\txmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n\t\t\t               \"comment doesn't start and stop in the\"\n                                       \" same entity\\n\");\n\t\t    }\n\t\t    SKIP(3);\n\t\t    if ((ctxt->sax != NULL) && (ctxt->sax->comment != NULL) &&\n\t\t        (!ctxt->disableSAX)) {\n\t\t\tif (buf != NULL)\n\t\t\t    ctxt->sax->comment(ctxt->userData, buf);\n\t\t\telse\n\t\t\t    ctxt->sax->comment(ctxt->userData, BAD_CAST \"\");\n\t\t    }\n\t\t    if (buf != NULL)\n\t\t        xmlFree(buf);\n\t\t    if (ctxt->instate != XML_PARSER_EOF)\n\t\t\tctxt->instate = state;\n\t\t    return;\n\t\t}\n\t\tif (buf != NULL) {\n\t\t    xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,\n\t\t                      \"Double hyphen within comment: \"\n                                      \"<!--%.50s\\n\",\n\t\t\t\t      buf);\n\t\t} else\n\t\t    xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,\n\t\t                      \"Double hyphen within comment\\n\", NULL);\n                if (ctxt->instate == XML_PARSER_EOF) {\n                    xmlFree(buf);\n                    return;\n                }\n\t\tin++;\n\t\tctxt->input->col++;\n\t    }\n\t    in++;\n\t    ctxt->input->col++;\n\t    goto get_more;\n\t}\n    } while (((*in >= 0x20) && (*in <= 0x7F)) || (*in == 0x09) || (*in == 0x0a));\n    xmlParseCommentComplex(ctxt, buf, len, size);\n    ctxt->instate = state;\n    return;\n}\n",
    "target": 0,
    "idx": 2063082
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "void\nxmlParseComment(xmlParserCtxtPtr ctxt) {\n    xmlChar *buf = NULL;\n    size_t size = XML_PARSER_BUFFER_SIZE;\n    size_t len = 0;\n    size_t maxLength = (ctxt->options & XML_PARSE_HUGE) ?\n                       XML_MAX_HUGE_LENGTH :\n                       XML_MAX_TEXT_LENGTH;\n    xmlParserInputState state;\n    const xmlChar *in;\n    size_t nbchar = 0;\n    int ccol;\n    int inputid;\n\n    /*\n     * Check that there is a comment right here.\n     */\n    if ((RAW != '<') || (NXT(1) != '!'))\n        return;\n    SKIP(2);\n    if ((RAW != '-') || (NXT(1) != '-'))\n        return;\n    state = ctxt->instate;\n    ctxt->instate = XML_PARSER_COMMENT;\n    inputid = ctxt->input->id;\n    SKIP(2);\n    GROW;\n\n    /*\n     * Accelerated common case where input don't need to be\n     * modified before passing it to the handler.\n     */\n    in = ctxt->input->cur;\n    do {\n\tif (*in == 0xA) {\n\t    do {\n\t\tctxt->input->line++; ctxt->input->col = 1;\n\t\tin++;\n\t    } while (*in == 0xA);\n\t}\nget_more:\n        ccol = ctxt->input->col;\n\twhile (((*in > '-') && (*in <= 0x7F)) ||\n\t       ((*in >= 0x20) && (*in < '-')) ||\n\t       (*in == 0x09)) {\n\t\t    in++;\n\t\t    ccol++;\n\t}\n\tctxt->input->col = ccol;\n\tif (*in == 0xA) {\n\t    do {\n\t\tctxt->input->line++; ctxt->input->col = 1;\n\t\tin++;\n\t    } while (*in == 0xA);\n\t    goto get_more;\n\t}\n\tnbchar = in - ctxt->input->cur;\n\t/*\n\t * save current set of data\n\t */\n\tif (nbchar > 0) {\n            if (buf == NULL) {\n                if ((*in == '-') && (in[1] == '-'))\n                    size = nbchar + 1;\n                else\n                    size = XML_PARSER_BUFFER_SIZE + nbchar;\n                buf = (xmlChar *) xmlMallocAtomic(size);\n                if (buf == NULL) {\n                    xmlErrMemory(ctxt, NULL);\n                    ctxt->instate = state;\n                    return;\n                }\n                len = 0;\n            } else if (len + nbchar + 1 >= size) {\n                xmlChar *new_buf;\n                size  += len + nbchar + XML_PARSER_BUFFER_SIZE;\n                new_buf = (xmlChar *) xmlRealloc(buf, size);\n                if (new_buf == NULL) {\n                    xmlFree (buf);\n                    xmlErrMemory(ctxt, NULL);\n                    ctxt->instate = state;\n                    return;\n                }\n                buf = new_buf;\n            }\n            memcpy(&buf[len], ctxt->input->cur, nbchar);\n            len += nbchar;\n            buf[len] = 0;\n\t}\n        if (len > maxLength) {\n            xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,\n                         \"Comment too big found\", NULL);\n            xmlFree (buf);\n            return;\n        }\n\tctxt->input->cur = in;\n\tif (*in == 0xA) {\n\t    in++;\n\t    ctxt->input->line++; ctxt->input->col = 1;\n\t}\n\tif (*in == 0xD) {\n\t    in++;\n\t    if (*in == 0xA) {\n\t\tctxt->input->cur = in;\n\t\tin++;\n\t\tctxt->input->line++; ctxt->input->col = 1;\n\t\tgoto get_more;\n\t    }\n\t    in--;\n\t}\n\tSHRINK;\n\tGROW;\n        if (ctxt->instate == XML_PARSER_EOF) {\n            xmlFree(buf);\n            return;\n        }\n\tin = ctxt->input->cur;\n\tif (*in == '-') {\n\t    if (in[1] == '-') {\n\t        if (in[2] == '>') {\n\t\t    if (ctxt->input->id != inputid) {\n\t\t\txmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n\t\t\t               \"comment doesn't start and stop in the\"\n                                       \" same entity\\n\");\n\t\t    }\n\t\t    SKIP(3);\n\t\t    if ((ctxt->sax != NULL) && (ctxt->sax->comment != NULL) &&\n\t\t        (!ctxt->disableSAX)) {\n\t\t\tif (buf != NULL)\n\t\t\t    ctxt->sax->comment(ctxt->userData, buf);\n\t\t\telse\n\t\t\t    ctxt->sax->comment(ctxt->userData, BAD_CAST \"\");\n\t\t    }\n\t\t    if (buf != NULL)\n\t\t        xmlFree(buf);\n\t\t    if (ctxt->instate != XML_PARSER_EOF)\n\t\t\tctxt->instate = state;\n\t\t    return;\n\t\t}\n\t\tif (buf != NULL) {\n\t\t    xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,\n\t\t                      \"Double hyphen within comment: \"\n                                      \"<!--%.50s\\n\",\n\t\t\t\t      buf);\n\t\t} else\n\t\t    xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,\n\t\t                      \"Double hyphen within comment\\n\", NULL);\n                if (ctxt->instate == XML_PARSER_EOF) {\n                    xmlFree(buf);\n                    return;\n                }\n\t\tin++;\n\t\tctxt->input->col++;\n\t    }\n\t    in++;\n\t    ctxt->input->col++;\n\t    goto get_more;\n\t}\n    } while (((*in >= 0x20) && (*in <= 0x7F)) || (*in == 0x09) || (*in == 0x0a));\n    xmlParseCommentComplex(ctxt, buf, len, size);\n    ctxt->instate = state;\n    return;\n}\n",
    "target": 0,
    "idx": 2063086
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "void\nxmlParseComment(xmlParserCtxtPtr ctxt) {\n    xmlChar *buf = NULL;\n    size_t size = XML_PARSER_BUFFER_SIZE;\n    size_t len = 0;\n    size_t maxLength = (ctxt->options & XML_PARSE_HUGE) ?\n                       XML_MAX_HUGE_LENGTH :\n                       XML_MAX_TEXT_LENGTH;\n    xmlParserInputState state;\n    const xmlChar *in;\n    size_t nbchar = 0;\n    int ccol;\n    int inputid;\n\n    /*\n     * Check that there is a comment right here.\n     */\n    if ((RAW != '<') || (NXT(1) != '!'))\n        return;\n    SKIP(2);\n    if ((RAW != '-') || (NXT(1) != '-'))\n        return;\n    state = ctxt->instate;\n    ctxt->instate = XML_PARSER_COMMENT;\n    inputid = ctxt->input->id;\n    SKIP(2);\n    GROW;\n\n    /*\n     * Accelerated common case where input don't need to be\n     * modified before passing it to the handler.\n     */\n    in = ctxt->input->cur;\n    do {\n\tif (*in == 0xA) {\n\t    do {\n\t\tctxt->input->line++; ctxt->input->col = 1;\n\t\tin++;\n\t    } while (*in == 0xA);\n\t}\nget_more:\n        ccol = ctxt->input->col;\n\twhile (((*in > '-') && (*in <= 0x7F)) ||\n\t       ((*in >= 0x20) && (*in < '-')) ||\n\t       (*in == 0x09)) {\n\t\t    in++;\n\t\t    ccol++;\n\t}\n\tctxt->input->col = ccol;\n\tif (*in == 0xA) {\n\t    do {\n\t\tctxt->input->line++; ctxt->input->col = 1;\n\t\tin++;\n\t    } while (*in == 0xA);\n\t    goto get_more;\n\t}\n\tnbchar = in - ctxt->input->cur;\n\t/*\n\t * save current set of data\n\t */\n\tif (nbchar > 0) {\n            if (buf == NULL) {\n                if ((*in == '-') && (in[1] == '-'))\n                    size = nbchar + 1;\n                else\n                    size = XML_PARSER_BUFFER_SIZE + nbchar;\n                buf = (xmlChar *) xmlMallocAtomic(size);\n                if (buf == NULL) {\n                    xmlErrMemory(ctxt, NULL);\n                    ctxt->instate = state;\n                    return;\n                }\n                len = 0;\n            } else if (len + nbchar + 1 >= size) {\n                xmlChar *new_buf;\n                size  += len + nbchar + XML_PARSER_BUFFER_SIZE;\n                new_buf = (xmlChar *) xmlRealloc(buf, size);\n                if (new_buf == NULL) {\n                    xmlFree (buf);\n                    xmlErrMemory(ctxt, NULL);\n                    ctxt->instate = state;\n                    return;\n                }\n                buf = new_buf;\n            }\n            memcpy(&buf[len], ctxt->input->cur, nbchar);\n            len += nbchar;\n            buf[len] = 0;\n\t}\n        if (len > maxLength) {\n            xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,\n                         \"Comment too big found\", NULL);\n            xmlFree (buf);\n            return;\n        }\n\tctxt->input->cur = in;\n\tif (*in == 0xA) {\n\t    in++;\n\t    ctxt->input->line++; ctxt->input->col = 1;\n\t}\n\tif (*in == 0xD) {\n\t    in++;\n\t    if (*in == 0xA) {\n\t\tctxt->input->cur = in;\n\t\tin++;\n\t\tctxt->input->line++; ctxt->input->col = 1;\n\t\tgoto get_more;\n\t    }\n\t    in--;\n\t}\n\tSHRINK;\n\tGROW;\n        if (ctxt->instate == XML_PARSER_EOF) {\n            xmlFree(buf);\n            return;\n        }\n\tin = ctxt->input->cur;\n\tif (*in == '-') {\n\t    if (in[1] == '-') {\n\t        if (in[2] == '>') {\n\t\t    if (ctxt->input->id != inputid) {\n\t\t\txmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n\t\t\t               \"comment doesn't start and stop in the\"\n                                       \" same entity\\n\");\n\t\t    }\n\t\t    SKIP(3);\n\t\t    if ((ctxt->sax != NULL) && (ctxt->sax->comment != NULL) &&\n\t\t        (!ctxt->disableSAX)) {\n\t\t\tif (buf != NULL)\n\t\t\t    ctxt->sax->comment(ctxt->userData, buf);\n\t\t\telse\n\t\t\t    ctxt->sax->comment(ctxt->userData, BAD_CAST \"\");\n\t\t    }\n\t\t    if (buf != NULL)\n\t\t        xmlFree(buf);\n\t\t    if (ctxt->instate != XML_PARSER_EOF)\n\t\t\tctxt->instate = state;\n\t\t    return;\n\t\t}\n\t\tif (buf != NULL) {\n\t\t    xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,\n\t\t                      \"Double hyphen within comment: \"\n                                      \"<!--%.50s\\n\",\n\t\t\t\t      buf);\n\t\t} else\n\t\t    xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,\n\t\t                      \"Double hyphen within comment\\n\", NULL);\n                if (ctxt->instate == XML_PARSER_EOF) {\n                    xmlFree(buf);\n                    return;\n                }\n\t\tin++;\n\t\tctxt->input->col++;\n\t    }\n\t    in++;\n\t    ctxt->input->col++;\n\t    goto get_more;\n\t}\n    } while (((*in >= 0x20) && (*in <= 0x7F)) || (*in == 0x09) || (*in == 0x0a));\n    xmlParseCommentComplex(ctxt, buf, len, size);\n    ctxt->instate = state;\n    return;\n}\n",
    "target": 0,
    "idx": 2063127
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "int ndpi_serialize_string_int32(ndpi_serializer *_serializer,\n\t\t\t\tconst char *key, int32_t value) {\n#ifdef OPTIMIZE_CSV_SERIALIZATION\n  ndpi_private_serializer *serializer = (ndpi_private_serializer*)_serializer;\n\n  if(serializer->fmt == ndpi_serialization_format_csv) {\n    /* Key is ignored */\n    u_int32_t buff_diff = serializer->buffer.size - serializer->status.buffer.size_used;\n    u_int16_t needed = 12 /* 10 (billion) + CVS separator + \\0 */;\n    int rc;\n\n    if(buff_diff < needed) {\n      if(ndpi_extend_serializer_buffer(&serializer->buffer, needed - buff_diff) < 0)\n\treturn(-1);     \t\n    }\n\n    if(!(serializer->status.flags & NDPI_SERIALIZER_STATUS_HDR_DONE)) {\n      if(ndpi_serializer_header_string(serializer, key, strlen(key)) < 0)\n\treturn(-1);\n    }\n\n    ndpi_serialize_csv_pre(serializer);\n    buff_diff = serializer->buffer.size - serializer->status.buffer.size_used;\n\n    rc = ndpi_snprintf((char*)&serializer->buffer.data[serializer->status.buffer.size_used],\n\t\t       buff_diff, \"%u\", value);\n\n    if(rc < 0 || (u_int)rc >= buff_diff)\n      return(-1);\n    \n    serializer->status.buffer.size_used += rc;\n    \n    return(0);\n  } else\n#endif\n  return(ndpi_serialize_binary_int32(_serializer, key, strlen(key), value));\n}\n",
    "target": 0,
    "idx": 2063179
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "int\nread_config(const char *filename,\n            struct config_line *line_handler, int when)\n{\n    static int      depth = 0;\n    static int      files = 0;\n\n    const char * const prev_filename = curfilename;\n    const unsigned int prev_linecount = linecount;\n\n    FILE           *ifile;\n    char           *line = NULL;  /* current line buffer */\n    size_t          linesize = 0; /* allocated size of line */\n\n    netsnmp_assert(line_handler);\n    netsnmp_assert(line_handler->config_token);\n\n    /* reset file counter when recursion depth is 0 */\n    if (depth == 0)\n        files = 0;\n\n    if ((ifile = fopen(filename, \"r\")) == NULL) {\n#ifdef ENOENT\n        if (errno == ENOENT) {\n            DEBUGMSGTL((\"read_config\", \"%s: %s\\n\", filename,\n                        strerror(errno)));\n        } else\n#endif                          /* ENOENT */\n#ifdef EACCES\n        if (errno == EACCES) {\n            DEBUGMSGTL((\"read_config\", \"%s: %s\\n\", filename,\n                        strerror(errno)));\n        } else\n#endif                          /* EACCES */\n        {\n            snmp_log_perror(filename);\n        }\n        return SNMPERR_GENERR;\n    }\n\n#define CONFIG_MAX_FILES 4096\n    if (files > CONFIG_MAX_FILES) {\n        netsnmp_config_error(\"maximum conf file count (%d) exceeded\\n\",\n                             CONFIG_MAX_FILES);\n\tfclose(ifile);\n        return SNMPERR_GENERR;\n    }\n#define CONFIG_MAX_RECURSE_DEPTH 16\n    if (depth > CONFIG_MAX_RECURSE_DEPTH) {\n        netsnmp_config_error(\"nested include depth > %d\\n\",\n                             CONFIG_MAX_RECURSE_DEPTH);\n\tfclose(ifile);\n        return SNMPERR_GENERR;\n    }\n\n    linecount = 0;\n    curfilename = filename;\n\n    ++files;\n    ++depth;\n\n    DEBUGMSGTL((\"read_config:file\", \"Reading configuration %s (%d)\\n\",\n                filename, when));\n\n    while (ifile) {\n        size_t              linelen = 0; /* strlen of the current line */\n        char               *cptr;\n        struct config_line *lptr = line_handler;\n\n        for (;;) {\n            if (linesize <= linelen + 1) {\n                char *tmp = realloc(line, linesize + 256);\n                if (tmp) {\n                    line = tmp;\n                    linesize += 256;\n                } else {\n                    netsnmp_config_error(\"Failed to allocate memory\\n\");\n                    free(line);\n                    fclose(ifile);\n                    return SNMPERR_GENERR;\n                }\n            }\n            if (fgets(line + linelen, linesize - linelen, ifile) == NULL) {\n                line[linelen] = '\\0';\n                fclose (ifile);\n                ifile = NULL;\n                break;\n            }\n\n            linelen += strlen(line + linelen);\n\n            if (linelen && line[linelen - 1] == '\\n') {\n              line[linelen - 1] = '\\0';\n              break;\n            }\n        }\n\n        ++linecount;\n        DEBUGMSGTL((\"9:read_config:line\", \"%s:%d examining: %s\\n\",\n                    filename, linecount, line));\n        /*\n         * check blank line or # comment \n         */\n        if ((cptr = skip_white(line))) {\n            char token[STRINGMAX];\n\n            cptr = copy_nword(cptr, token, sizeof(token));\n            if (token[0] == '[') {\n                if (token[strlen(token) - 1] != ']') {\n\t\t    netsnmp_config_error(\"no matching ']' for type %s.\",\n\t\t\t\t\t &token[1]);\n                    continue;\n                }\n                token[strlen(token) - 1] = '\\0';\n                lptr = read_config_get_handlers(&token[1]);\n                if (lptr == NULL) {\n\t\t    netsnmp_config_error(\"No handlers registered for type %s.\",\n\t\t\t\t\t &token[1]);\n                    continue;\n                }\n                DEBUGMSGTL((\"read_config:context\",\n                            \"Switching to new context: %s%s\\n\",\n                            ((cptr) ? \"(this line only) \" : \"\"),\n                            &token[1]));\n                if (cptr == NULL) {\n                    /*\n                     * change context permanently \n                     */\n                    line_handler = lptr;\n                    continue;\n                } else {\n                    /*\n                     * the rest of this line only applies. \n                     */\n                    cptr = copy_nword(cptr, token, sizeof(token));\n                }\n            } else if ((token[0] == 'i') && (strncasecmp(token,\"include\", 7 )==0)) {\n                if ( strcasecmp( token, \"include\" )==0) {\n                    if (when != PREMIB_CONFIG && \n\t                !netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, \n\t\t\t\t                NETSNMP_DS_LIB_NO_TOKEN_WARNINGS)) {\n\t                netsnmp_config_warn(\"Ambiguous token '%s' - use 'includeSearch' (or 'includeFile') instead.\", token);\n                    }\n                    continue;\n                } else if ( strcasecmp( token, \"includedir\" )==0) {\n                    DIR *d;\n                    struct dirent *entry;\n                    char  fname[SNMP_MAXPATH];\n                    int   len;\n\n                    if (cptr == NULL) {\n                        if (when != PREMIB_CONFIG)\n\t\t            netsnmp_config_error(\"Blank line following %s token.\", token);\n                        continue;\n                    }\n                    if ((d=opendir(cptr)) == NULL ) {\n                        if (when != PREMIB_CONFIG)\n                            netsnmp_config_error(\"Can't open include dir '%s'.\", cptr);\n                        continue;\n                    }\n                    while ((entry = readdir( d )) != NULL ) {\n                        if ( entry->d_name[0] != '.') {\n                            len = strlen(entry->d_name);\n                            if ((len > 5) && (strcmp(&(entry->d_name[len-5]),\".conf\") == 0)) {\n                                snprintf(fname, SNMP_MAXPATH, \"%s/%s\",\n                                         cptr, entry->d_name);\n                                (void)read_config(fname, line_handler, when);\n                            }\n                        }\n                    }\n                    closedir(d);\n                    continue;\n                } else if ( strcasecmp( token, \"includefile\" )==0) {\n                    char  fname[SNMP_MAXPATH], *cp;\n\n                    if (cptr == NULL) {\n                        if (when != PREMIB_CONFIG)\n\t\t            netsnmp_config_error(\"Blank line following %s token.\", token);\n                        continue;\n                    }\n                    if (strlen(cptr) + 1 >= SNMP_MAXPATH) {\n                        netsnmp_config_error(\"File name '%s' is too long\",\n                                             cptr);\n                        continue;\n                    }\n                    if ( cptr[0] == '/' ) {\n                        strlcpy(fname, cptr, SNMP_MAXPATH);\n                    } else {\n                        strlcpy(fname, filename, SNMP_MAXPATH);\n                        cp = strrchr(fname, '/');\n                        if (!cp)\n                            fname[0] = '\\0';\n                        else\n                            *(++cp) = '\\0';\n                        strlcat(fname, cptr, SNMP_MAXPATH);\n                    }\n                    if (read_config(fname, line_handler, when) !=\n                        SNMPERR_SUCCESS && when != PREMIB_CONFIG)\n                        netsnmp_config_error(\"Included file '%s' not found.\",\n                                             fname);\n                    continue;\n                } else if ( strcasecmp( token, \"includesearch\" )==0) {\n                    struct config_files ctmp;\n                    int len, ret;\n\n                    if (cptr == NULL) {\n                        if (when != PREMIB_CONFIG)\n\t\t            netsnmp_config_error(\"Blank line following %s token.\", token);\n                        continue;\n                    }\n                    len = strlen(cptr);\n                    ctmp.fileHeader = cptr;\n                    ctmp.start = line_handler;\n                    ctmp.next = NULL;\n                    if ((len > 5) && (strcmp(&cptr[len-5],\".conf\") == 0))\n                       cptr[len-5] = 0; /* chop off .conf */\n                    ret = read_config_files_of_type(when,&ctmp);\n                    if ((len > 5) && (cptr[len-5] == 0))\n                       cptr[len-5] = '.'; /* restore .conf */\n                    if (( ret != SNMPERR_SUCCESS ) && (when != PREMIB_CONFIG))\n\t\t        netsnmp_config_error(\"Included config '%s' not found.\", cptr);\n                    continue;\n                } else {\n                    lptr = line_handler;\n                }\n            } else {\n                lptr = line_handler;\n            }\n            if (cptr == NULL) {\n\t\tnetsnmp_config_error(\"Blank line following %s token.\", token);\n            } else {\n                DEBUGMSGTL((\"read_config:line\", \"%s:%d examining: %s\\n\",\n                            filename, linecount, line));\n                run_config_handler(lptr, token, cptr, when);\n            }\n        }\n    }\n    free(line);\n    linecount = prev_linecount;\n    curfilename = prev_filename;\n    --depth;\n    return SNMPERR_SUCCESS;\n\n}                               /* end read_config() */\n",
    "target": 0,
    "idx": 2064315
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "int jvp_number_cmp(jv a, jv b) {\n  assert(JVP_HAS_KIND(a, JV_KIND_NUMBER));\n  assert(JVP_HAS_KIND(b, JV_KIND_NUMBER));\n\n#ifdef USE_DECNUM\n  if (JVP_HAS_FLAGS(a, JVP_FLAGS_NUMBER_LITERAL) && JVP_HAS_FLAGS(b, JVP_FLAGS_NUMBER_LITERAL)) {\n    struct {\n      decNumber number;\n      decNumberUnit units[1];\n    } res;\n\n    decNumberCompare(&res.number,\n                     jvp_dec_number_ptr(a),\n                     jvp_dec_number_ptr(b),\n                     DEC_CONTEXT()\n                     );\n    if (decNumberIsZero(&res.number)) {\n      return 0;\n    } else if (decNumberIsNegative(&res.number)) {\n      return -1;\n    } else {\n      return 1;\n    }\n  }\n#endif\n  double da = jv_number_value(a), db = jv_number_value(b);\n  if (da < db) {\n    return -1;\n  } else if (da == db) {\n    return 0;\n  } else {\n    return 1;\n  }\n}\n",
    "target": 0,
    "idx": 2064771
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "GF_EXPORT\ns32 gf_token_get_line(const char *Buffer, u32 Start, u32 Size, char *LineBuffer, u32 LineBufferSize)\n{\n\tu32 offset;\n\ts32 End, Total;\n\tLineBuffer[0] = 0;\n\tif (Start >= Size) return -1;\n\n\toffset = 2;\n\tEnd = gf_token_find(Buffer, Start, Size, \"\\r\\n\");\n\tif (End<0) {\n\t\tEnd = gf_token_find(Buffer, Start, Size, \"\\r\");\n\t\tif (End<0) End = gf_token_find(Buffer, Start, Size, \"\\n\");\n\t\tif (End < 0) return -1;\n\t\toffset = 1;\n\t}\n\n\tTotal = End - Start + offset;\n\tif ((u32) Total >= LineBufferSize) Total = LineBufferSize-1;\n\tmemcpy(LineBuffer, Buffer + Start, Total);\n\tLineBuffer[Total] = 0;\n\treturn (End + offset);\n}\n",
    "target": 0,
    "idx": 2065264
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "static int\njson_HEADER (Bit_Chain *restrict dat, Dwg_Data *restrict dwg,\n             jsmntokens_t *restrict tokens)\n{\n  const char *section = \"HEADER\";\n  const char *name = section;\n  jsmntok_t *t = &tokens->tokens[tokens->index];\n  // Dwg_Header_Variables *_obj = &dwg->header_vars;\n  Dwg_Object *obj = NULL;\n  int size = t->size;\n\n  if (t->type != JSMN_OBJECT)\n    {\n      LOG_ERROR (\"Unexpected %s at %u of %ld tokens, expected %s OBJECT\",\n                 t_typename[t->type], tokens->index, tokens->num_tokens,\n                 section);\n      json_advance_unknown (dat, tokens, t->type, 0);\n      return DWG_ERR_INVALIDTYPE;\n    }\n  LOG_TRACE (\"\\n%s pos:%d [%d keys]\\n--------------------\\n\", section,\n             tokens->index, t->size);\n  tokens->index++;\n  for (int i = 0; i < size; i++)\n    {\n      char key[80];\n      Dwg_DYNAPI_field *f;\n\n      json_fixed_key (key, dat, tokens);\n      JSON_TOKENS_CHECK_OVERFLOW_ERR\n      t = &tokens->tokens[tokens->index];\n      f = (Dwg_DYNAPI_field *)dwg_dynapi_header_field (key);\n      if (!f)\n        {\n          if (t->type == JSMN_ARRAY && strEQc (key, \"layer_colors\"))\n            {\n              tokens->index++;\n              for (int index = 0; index < MAX (t->size, 128); index++)\n                {\n                  dwg->header_vars.layer_colors[index]\n                      = (BITCODE_RS)json_long (dat, tokens);\n                  LOG_TRACE (\"%s: \" FORMAT_RS \" [RS]\\n\", key,\n                             dwg->header_vars.layer_colors[index]);\n                }\n              JSON_TOKENS_CHECK_OVERFLOW_ERR;\n            }\n          else\n            {\n              LOG_WARN (\"Unknown key HEADER.%s\", key)\n              json_advance_unknown (dat, tokens, t->type, 0);\n              continue;\n            }\n        }\n      else if (t->type == JSMN_PRIMITIVE\n               && (strEQc (f->type, \"BD\") || strEQc (f->type, \"RD\")))\n        {\n          double num = json_float (dat, tokens);\n          LOG_TRACE (\"%s: \" FORMAT_RD \" [%s]\\n\", key, num, f->type)\n          dwg_dynapi_header_set_value (dwg, key, &num, 0);\n        }\n      else if (t->type == JSMN_PRIMITIVE\n               && f->size <= 4  // not a RS[]\n               && (strEQc (f->type, \"RC\") || strEQc (f->type, \"B\")\n                   || strEQc (f->type, \"BB\") || strEQc (f->type, \"RS\")\n                   || strEQc (f->type, \"BS\") || strEQc (f->type, \"RL\")\n                   || strEQc (f->type, \"BL\") || strEQc (f->type, \"RSd\")\n                   || strEQc (f->type, \"BLd\") || strEQc (f->type, \"BSd\")))\n        {\n          long num = json_long (dat, tokens);\n          LOG_TRACE (\"%s: %ld [%s]\\n\", key, num, f->type)\n          dwg_dynapi_header_set_value (dwg, key, &num, 0);\n        }\n      else if (t->type == JSMN_PRIMITIVE\n               && f->size == 8 // not a RLL[]\n               && (strEQc (f->type, \"RLL\") || strEQc (f->type, \"BLL\")))\n        {\n          uint64_t num = json_longlong (dat, tokens);\n          LOG_TRACE (\"%s: \" FORMAT_RLL \" [%s]\\n\", key, num, f->type)\n          dwg_dynapi_header_set_value (dwg, key, &num, 0);\n        }\n      else if (t->type == JSMN_STRING\n               && (strEQc (f->type, \"TV\") || strEQc (f->type, \"T\")))\n        {\n          size_t len;\n          char *str = json_string (dat, tokens);\n          LOG_TRACE (\"%s: \\\"%s\\\" [%s]\\n\", key, str, f->type);\n          if (dwg->header.version < R_13b1 && strEQc (key, \"MENU\")\n              && (len = strlen (str) > 15))\n            { // split into MENU + MENUEXT\n              strncpy ((char *)dwg->header_vars.MENUEXT, &str[15], 45);\n              str[15] = '\\0';\n              dwg->header_vars.MENU = strdup (str);\n              dwg->header_vars.MENUEXT[45] = '\\0';\n            }\n          else\n            dwg_dynapi_header_set_value (dwg, key, &str, 1);\n          free (str);\n        }\n      else if (t->type == JSMN_ARRAY\n               && (strEQc (f->type, \"3BD\") || strEQc (f->type, \"3RD\")\n                   || strEQc (f->type, \"3DPOINT\") || strEQc (f->type, \"BE\")\n                   || strEQc (f->type, \"3BD_1\")))\n        {\n          BITCODE_3DPOINT pt;\n          json_3DPOINT (dat, tokens, name, key, f->type, &pt);\n          dwg_dynapi_header_set_value (dwg, key, &pt, 1);\n        }\n      else if (t->type == JSMN_ARRAY\n               && (strEQc (f->type, \"2BD\") || strEQc (f->type, \"2RD\")\n                   || strEQc (f->type, \"2DPOINT\")\n                   || strEQc (f->type, \"2BD_1\")))\n        {\n          BITCODE_2DPOINT pt;\n          json_2DPOINT (dat, tokens, name, key, f->type, &pt);\n          dwg_dynapi_header_set_value (dwg, key, &pt, 1);\n        }\n      else if (t->type == JSMN_ARRAY\n               && (strEQc (f->type, \"BS\") || strEQc (f->type, \"RS\")))\n        {\n          int size1 = t->size;\n          BITCODE_BS *nums = (BITCODE_BS *)calloc (f->size, 1);\n          tokens->index++;\n          // fail if not malloced or inlined array (but json has an array)\n          if (f->size <= 2 && size1 > 1)\n            {\n              LOG_ERROR (\"Invalid JSON: HEADER.%s array where primitive expected\",\n                         f->name);\n              free (nums);\n              tokens->index += size1;\n              return 0;\n            }\n          for (int k = 0; k < size1; k++)\n            {\n              JSON_TOKENS_CHECK_OVERFLOW_ERR\n              if (k < (f->size / 2))\n                {\n                  nums[k] = (BITCODE_BS)json_long (dat, tokens);\n                  LOG_TRACE (\"%s.%s[%d]: \" FORMAT_BS \" [%s]\\n\", name, key, k,\n                             nums[k], f->type);\n                }\n              else\n                {\n                  LOG_WARN (\"Ignored %s.%s[%d]: %ld [%s]\", name, key, k,\n                             json_long (dat, tokens), f->type);\n                }\n            }\n          if (!size1)\n            LOG_TRACE (\"%s.%s: [%s] empty\\n\", name, key, f->type);\n          if (!f->is_malloc)\n            {\n              dwg_dynapi_header_set_value (dwg, key, nums, 1);\n              free (nums);\n            }\n          else\n            dwg_dynapi_header_set_value (dwg, key, &nums, 1);\n        }\n      else if (strEQc (f->type, \"TIMEBLL\") || strEQc (f->type, \"TIMERLL\"))\n        {\n          BITCODE_TIMEBLL date = { 0 };\n          json_TIMEBLL (dat, tokens, key, &date);\n          dwg_dynapi_header_set_value (dwg, key, &date, 0);\n        }\n      else if (strEQc (f->type, \"CMC\"))\n        {\n          BITCODE_CMC color = { 0 };\n          json_CMC (dat, dwg, tokens, name, key, &color);\n          dwg_dynapi_header_set_value (dwg, key, &color, 0);\n        }\n      else if (t->type == JSMN_ARRAY && strEQc (f->type, \"H\"))\n        {\n          BITCODE_H hdl\n              = json_HANDLE (dat, dwg, tokens, section, key, NULL, -1);\n          if (hdl)\n            dwg_dynapi_header_set_value (dwg, key, &hdl, 0);\n        }\n      //...\n      else if (t->type == JSMN_OBJECT && strEQc (key, \"CLASSES\"))\n        {\n          LOG_WARN (\"Unexpected next section %s\", key)\n          tokens->index--;\n          tokens->index--;\n          return 0;\n        }\n      else\n        {\n          LOG_WARN (\"Unhandled %s [%s] with %s\", key, f->type,\n                    t_typename[t->type])\n          tokens->index++;\n          continue;\n        }\n    }\n  LOG_TRACE (\"End of %s\\n\", section)\n  // the key\n  tokens->index--;\n  return 0;\n}\n",
    "target": 0,
    "idx": 2066046
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "    simdutf_really_inline size_t convert(const char* in, size_t size, char32_t* utf32_output) {\n      size_t pos = 0;\n      char32_t* start{utf32_output};\n      // In the worst case, we have the haswell kernel which can cause an overflow of\n      // 8 bytes when calling convert_masked_utf8_to_utf32. If you skip the last 16 bytes,\n      // and if the data is valid, then it is entirely safe because 16 UTF-8 bytes generate\n      // much more than 8 bytes. However, you cannot generally assume that you have valid\n      // UTF-8 input, so we are going to go back from the end counting 8 leading bytes,\n      // to give us a good margin.\n      size_t leading_byte = 0;\n      size_t margin = size;\n      for(; margin > 0 && leading_byte < 8; margin--) {\n        leading_byte += (int8_t(in[margin-1]) > -65);\n      }\n      // If the input is long enough, then we have that margin-1 is the fourth last leading byte.\n      const size_t safety_margin = size - margin + 1; // to avoid overruns!\n      while(pos + 64 + safety_margin <= size) {\n        simd8x64<int8_t> input(reinterpret_cast<const int8_t *>(in + pos));\n        if(input.is_ascii()) {\n          input.store_ascii_as_utf32(utf32_output);\n          utf32_output += 64;\n          pos += 64;\n        } else {\n          // you might think that a for-loop would work, but under Visual Studio, it is not good enough.\n          static_assert((simd8x64<uint8_t>::NUM_CHUNKS == 2) || (simd8x64<uint8_t>::NUM_CHUNKS == 4),\n              \"We support either two or four chunks per 64-byte block.\");\n          auto zero = simd8<uint8_t>{uint8_t(0)};\n          if(simd8x64<uint8_t>::NUM_CHUNKS == 2) {\n            this->check_utf8_bytes(input.chunks[0], zero);\n            this->check_utf8_bytes(input.chunks[1], input.chunks[0]);\n          } else if(simd8x64<uint8_t>::NUM_CHUNKS == 4) {\n            this->check_utf8_bytes(input.chunks[0], zero);\n            this->check_utf8_bytes(input.chunks[1], input.chunks[0]);\n            this->check_utf8_bytes(input.chunks[2], input.chunks[1]);\n            this->check_utf8_bytes(input.chunks[3], input.chunks[2]);\n          }\n          uint64_t utf8_continuation_mask = input.lt(-65 + 1);\n          uint64_t utf8_leading_mask = ~utf8_continuation_mask;\n          uint64_t utf8_end_of_code_point_mask = utf8_leading_mask>>1;\n          // We process in blocks of up to 12 bytes except possibly\n          // for fast paths which may process up to 16 bytes. For the\n          // slow path to work, we should have at least 12 input bytes left.\n          size_t max_starting_point = (pos + 64) - 12;\n          // Next loop is going to run at least five times.\n          while(pos < max_starting_point) {\n            // Performance note: our ability to compute 'consumed' and\n            // then shift and recompute is critical. If there is a\n            // latency of, say, 4 cycles on getting 'consumed', then\n            // the inner loop might have a total latency of about 6 cycles.\n            // Yet we process between 6 to 12 inputs bytes, thus we get\n            // a speed limit between 1 cycle/byte and 0.5 cycle/byte\n            // for this section of the code. Hence, there is a limit\n            // to how much we can further increase this latency before\n            // it seriously harms performance.\n            size_t consumed = convert_masked_utf8_to_utf32(in + pos,\n                            utf8_end_of_code_point_mask, utf32_output);\n            pos += consumed;\n            utf8_end_of_code_point_mask >>= consumed;\n          }\n          // At this point there may remain between 0 and 12 bytes in the\n          // 64-byte block. These bytes will be processed again. So we have an\n          // 80% efficiency (in the worst case). In practice we expect an\n          // 85% to 90% efficiency.\n        }\n      }\n      if(errors()) { return 0; }\n      if(pos < size) {\n        size_t howmany  = scalar::utf8_to_utf32::convert(in + pos, size - pos, utf32_output);\n        if(howmany == 0) { return 0; }\n        utf32_output += howmany;\n      }\n      return utf32_output - start;\n    }\n    simdutf_really_inline result convert_with_errors(const char* in, size_t size, char32_t* utf32_output) {\n      size_t pos = 0;\n      char32_t* start{utf32_output};\n      // In the worst case, we have the haswell kernel which can cause an overflow of\n      // 8 bytes when calling convert_masked_utf8_to_utf32. If you skip the last 16 bytes,\n      // and if the data is valid, then it is entirely safe because 16 UTF-8 bytes generate\n      // much more than 8 bytes. However, you cannot generally assume that you have valid\n      // UTF-8 input, so we are going to go back from the end counting 8 leading bytes,\n      // to give us a good margin.\n      size_t leading_byte = 0;\n      size_t margin = size;\n      for(; margin > 0 && leading_byte < 8; margin--) {\n        leading_byte += (int8_t(in[margin-1]) > -65);\n      }\n      // If the input is long enough, then we have that margin-1 is the fourth last leading byte.\n      const size_t safety_margin = size - margin + 1; // to avoid overruns!\n      while(pos + 64 + safety_margin <= size) {\n        simd8x64<int8_t> input(reinterpret_cast<const int8_t *>(in + pos));\n        if(input.is_ascii()) {\n          input.store_ascii_as_utf32(utf32_output);\n          utf32_output += 64;\n          pos += 64;\n        } else {\n          // you might think that a for-loop would work, but under Visual Studio, it is not good enough.\n          static_assert((simd8x64<uint8_t>::NUM_CHUNKS == 2) || (simd8x64<uint8_t>::NUM_CHUNKS == 4),\n              \"We support either two or four chunks per 64-byte block.\");\n          auto zero = simd8<uint8_t>{uint8_t(0)};\n          if(simd8x64<uint8_t>::NUM_CHUNKS == 2) {\n            this->check_utf8_bytes(input.chunks[0], zero);\n            this->check_utf8_bytes(input.chunks[1], input.chunks[0]);\n          } else if(simd8x64<uint8_t>::NUM_CHUNKS == 4) {\n            this->check_utf8_bytes(input.chunks[0], zero);\n            this->check_utf8_bytes(input.chunks[1], input.chunks[0]);\n            this->check_utf8_bytes(input.chunks[2], input.chunks[1]);\n            this->check_utf8_bytes(input.chunks[3], input.chunks[2]);\n          }\n          if (errors()) {\n            result res = scalar::utf8_to_utf32::rewind_and_convert_with_errors(pos, in + pos, size - pos, utf32_output);\n            res.count += pos;\n            return res;\n          }\n          uint64_t utf8_continuation_mask = input.lt(-65 + 1);\n          uint64_t utf8_leading_mask = ~utf8_continuation_mask;\n          uint64_t utf8_end_of_code_point_mask = utf8_leading_mask>>1;\n          // We process in blocks of up to 12 bytes except possibly\n          // for fast paths which may process up to 16 bytes. For the\n          // slow path to work, we should have at least 12 input bytes left.\n          size_t max_starting_point = (pos + 64) - 12;\n          // Next loop is going to run at least five times.\n          while(pos < max_starting_point) {\n            // Performance note: our ability to compute 'consumed' and\n            // then shift and recompute is critical. If there is a\n            // latency of, say, 4 cycles on getting 'consumed', then\n            // the inner loop might have a total latency of about 6 cycles.\n            // Yet we process between 6 to 12 inputs bytes, thus we get\n            // a speed limit between 1 cycle/byte and 0.5 cycle/byte\n            // for this section of the code. Hence, there is a limit\n            // to how much we can further increase this latency before\n            // it seriously harms performance.\n            size_t consumed = convert_masked_utf8_to_utf32(in + pos,\n                            utf8_end_of_code_point_mask, utf32_output);\n            pos += consumed;\n            utf8_end_of_code_point_mask >>= consumed;\n          }\n          // At this point there may remain between 0 and 12 bytes in the\n          // 64-byte block. These bytes will be processed again. So we have an\n          // 80% efficiency (in the worst case). In practice we expect an\n          // 85% to 90% efficiency.\n        }\n      }\n      if(errors()) {\n        result res = scalar::utf8_to_utf32::rewind_and_convert_with_errors(pos, in + pos, size - pos, utf32_output);\n        res.count += pos;\n        return res;\n      }\n      if(pos < size) {\n        result res = scalar::utf8_to_utf32::rewind_and_convert_with_errors(pos, in + pos, size - pos, utf32_output);\n        if (res.error) {    // In case of error, we want the error position\n          res.count += pos;\n          return res;\n        } else {    // In case of success, we want the number of word written\n          utf32_output += res.count;\n        }\n      }\n      return result(error_code::SUCCESS, utf32_output - start);\n    }\nTEST(convert_invalid_special_cases) {\n  std::string source(\n      \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n      \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n      \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n      \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n      \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n      \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n      \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n      \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n      \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n      \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n      \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n      \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n      \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x02\\x2e\\x00\\x00\\x00\\x02\\x00\\x00\"\n      \"\\x00\\x0c\\x00\\x02\\x02\\x2e\\x2e\\x00\\x00\\x0b\\x00\\x00\\x00\\x14\\x00\\x0a\\x02\\x6c\"\n      \"\\x6f\\x73\\x74\\x2b\\x66\\x6f\\x75\\x6e\\x64\\x00\\x00\\x0c\\x00\\x00\\x00\\x14\\x00\\x0b\"\n      \"\\x02\\x61\\x5f\\x64\\x69\\x72\\x65\\x63\\x74\\x6f\\x72\\x79\\x00\\x0e\\x00\\x00\\x00\\x18\"\n      \"\\x00\\x0d\\x01\\x70\\x61\\x73\\x73\\x77\\x6f\\x72\\x64\\x73\\x2e\\x74\\x78\\x74\\x00\\x00\"\n      \"\\x00\\x10\\x00\\x00\\x00\\x9c\\x03\\x06\\x07\\x61\\x5f\\x6c\\x69\\x6e\\x6b\\x00\\x00\\x00\"\n      \"\\x00\\x00\\x00\\x00\\x00\\x00\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x02\\x00\\x00\\x00\\x0c\"\n      \"\\x00\\x01\\x02\\x2e\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x0c\\x00\\x02\\x02\\x2e\\x2e\\x00\"\n      \"\\x00\\x0b\\x00\\x00\\x00\\x14\\x00\\x0a\\x02\\x6c\\x6f\\x73\\x74\\x2b\\x66\\x6f\\x75\\x6e\"\n      \"\\x64\\x00\\x00\\x0c\\x00\\x00\\x00\\x14\\x00\\x0b\\x02\\x61\\x5f\\x64\\x69\\x72\\x65\\x63\"\n      \"\\x74\\x6f\\x72\\x79\\x00\\x0e\\x00\\x00\\x00\\x18\\x00\\x0d\\x01\\x70\\x61\\x73\\x73\\x77\"\n      \"\\x6f\\x72\\x64\\x73\\x2e\\x74\\x78\\x74\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x9c\\x03\\x06\"\n      \"\\x07\\x61\\x5f\\x6c\\x69\\x6e\\x6b\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xff\\xff\"\n      \"\\xff\\xff\\xff\\xff\\xff\\x02\\x00\\x00\\x00\\x0c\\x00\\x01\\x02\\x2e\\x00\\x00\\x00\\x02\"\n      \"\\x00\\x00\\x00\\x0c\\x00\\x02\\x02\\x2e\\x2e\\x00\\x00\\x0b\\x00\\x00\\x00\\x14\\x00\\x0a\"\n      \"\\x02\\x6c\\x6f\\x73\\x74\\x2b\\x66\\x6f\\x75\\x6e\\x64\\x00\\x00\\x0c\\x00\\x00\\x00\\x14\"\n      \"\\x00\\x0b\\x02\\x61\\x5f\\x64\\x69\\x72\\x65\\x63\\x74\\x6f\\x72\\x79\\x00\\x0e\\x00\\x00\"\n      \"\\x00\\x18\\x00\\x0d\\x01\\x70\\x61\\x73\\x73\\x77\\x6f\\x72\\x64\\x73\\x2e\\x74\\x78\\x74\"\n      \"\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x9c\\x03\\x06\\x07\\x61\\x5f\\x6c\\x69\\x6e\\x6b\\x00\"\n      \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x02\\x00\\x00\"\n      \"\\x00\\x0c\\x00\\x01\\x02\\x2e\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x0c\\x00\\x02\\x02\\x2e\"\n      \"\\x2e\\x00\\x00\\x0b\\x00\\x00\\x00\\x14\\x00\\x0a\\x02\\x6c\\x6f\\x73\\x74\\x2b\\x66\\x6f\"\n      \"\\x75\\x6e\\x64\\x00\\x00\\x0c\\x00\\x00\\x00\\x14\\x00\\x0b\\x02\\x61\\x5f\\x64\\x69\\x72\"\n      \"\\x65\\x63\\x74\\x6f\\x72\\x79\\x00\\x0e\\x00\\x00\\x00\\x18\\x00\\x00\\x00\\x00\\x00\\x00\"\n      \"\\x00\\x00\\x10\\x72\\x64\\x73\\x2e\\x74\\x78\\x74\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x9c\"\n      \"\\x03\\x06\\x07\\x61\\x5f\\x6c\\x69\\x6e\\x6b\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n      \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x02\\x00\\x00\\x00\\x0c\\x00\\x01\\x02\\x2e\\x00\\x00\"\n      \"\\x00\\x02\\x00\\x00\\x00\\x0c\\x00\\x02\\x02\\x2e\\x2e\\x00\\x00\\x0b\\x00\\x00\\x00\\x14\"\n      \"\\x00\\x0a\\x02\\x6c\\x6f\\x73\\x74\\x2b\\x66\\x6f\\x75\\x6e\\x64\\x00\\x00\\x0c\\x00\\x00\"\n      \"\\x00\\x14\\x00\\x0b\\x02\\x61\\x5f\\x64\\x69\\x72\\x65\\x63\\x74\\x6f\\x72\\x79\\x00\\x0e\"\n      \"\\x00\\x00\\x00\\x18\\x00\\x0d\\x01\\x70\\x61\\x73\\x73\\x77\\x70\\x72\\x64\\x73\\x2e\\x74\"\n      \"\\x78\\x74\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x9c\\x03\\x06\\x07\\x61\\x5f\\x6c\\x69\\x6e\"\n      \"\\x6b\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x02\"\n      \"\\x00\\x00\\x00\\x0c\\x00\\x01\\x02\\x2e\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x0c\\x00\\x02\"\n      \"\\x02\\x2e\\x2e\\x00\\x00\\x0b\\x00\\x00\\x00\\x14\\x00\\x0a\\x02\\x6c\\x6f\\x73\\x74\\x2b\"\n      \"\\x66\\x6f\\x75\\x6e\\x64\\x00\\x00\\x0c\\x00\\x00\\x00\\x14\\x00\\x0b\\x02\\x61\\x5f\\x64\"\n      \"\\x69\\x72\\x65\\x63\\x74\\x6f\\x72\\x79\\x00\\x0e\\x00\\x00\\x00\\x18\\x00\\x0d\\x01\\x70\"\n      \"\\x61\\x73\\x73\\x77\\x6f\\x72\\x64\\x73\\x2e\\x74\\x78\\x74\\x00\\x00\\x00\\x10\\x00\\x00\"\n      \"\\x00\\x9c\\x03\\x06\\x07\\x61\\x5f\\x6c\\x69\\x6e\\x6b\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n      \"\\x00\\x00\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x02\\x00\\x00\\x00\\x0c\\x00\\x01\\x02\\x2e\"\n      \"\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x0c\\x00\\x02\\x02\\x2e\\x2e\\x00\\x00\\x0b\\x00\\x00\"\n      \"\\x00\\x14\\x00\\x0a\\x02\\x6c\\x6f\\x73\\x74\\x2b\\x66\\x6f\\x75\\x6e\\x64\\x00\\x00\\x0c\"\n      \"\\x00\\x00\\x00\\x14\\x00\\x0b\\x02\\x61\\x5f\\x64\\x69\\x72\\x65\\x63\\x74\\x6f\\x72\\x79\"\n      \"\\x00\\x0e\\x00\\x00\\x00\\x18\\x00\\x0d\\x01\\x70\\x61\\x73\\x73\\x77\\x6f\\x72\\x64\\x73\"\n      \"\\x2e\\x74\\x78\\x74\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x9c\\x03\\x06\\x07\\x61\",\n      1024);\n\n  // invalid input!!!\n  size_t expected_utf32words =\n      implementation.utf32_length_from_utf8(source.data(), source.size());\n  std::cout << \"expected output \" << expected_utf32words << std::endl;\n  std::unique_ptr<char32_t[]> utf32_output{new char32_t[expected_utf32words]};\n  size_t utf32words = implementation.convert_utf8_to_utf32(\n      source.c_str(), source.size(), utf32_output.get());\n  ASSERT_TRUE(utf32words == 0);\n}\nint main(int argc, char *argv[]) { return simdutf::test::main(argc, argv); }\n",
    "target": 0,
    "idx": 2066063
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "otError Ip6::RemoveMplOption(Message &aMessage)\n{\n    otError        error = OT_ERROR_NONE;\n    Header         ip6Header;\n    HopByHopHeader hbh;\n    uint16_t       offset;\n    uint16_t       endOffset;\n    uint16_t       mplOffset = 0;\n    uint8_t        mplLength = 0;\n    bool           remove    = false;\n\n    offset = 0;\n    aMessage.Read(offset, sizeof(ip6Header), &ip6Header);\n    offset += sizeof(ip6Header);\n    VerifyOrExit(ip6Header.GetNextHeader() == kProtoHopOpts);\n\n    aMessage.Read(offset, sizeof(hbh), &hbh);\n    endOffset = offset + (hbh.GetLength() + 1) * 8;\n    VerifyOrExit(aMessage.GetLength() >= endOffset, error = OT_ERROR_PARSE);\n\n    offset += sizeof(hbh);\n\n    while (offset < endOffset)\n    {\n        OptionHeader option;\n\n        aMessage.Read(offset, sizeof(option), &option);\n\n        switch (option.GetType())\n        {\n        case OptionMpl::kType:\n            // if multiple MPL options exist, discard packet\n            VerifyOrExit(mplOffset == 0, error = OT_ERROR_PARSE);\n\n            mplOffset = offset;\n            mplLength = option.GetLength();\n\n            VerifyOrExit(mplLength <= sizeof(OptionMpl) - sizeof(OptionHeader), error = OT_ERROR_PARSE);\n\n            if (mplOffset == sizeof(ip6Header) + sizeof(hbh) && hbh.GetLength() == 0)\n            {\n                // first and only IPv6 Option, remove IPv6 HBH Option header\n                remove = true;\n            }\n            else if (mplOffset + 8 == endOffset)\n            {\n                // last IPv6 Option, remove last 8 bytes\n                remove = true;\n            }\n\n            offset += sizeof(option) + option.GetLength();\n            break;\n\n        case OptionPad1::kType:\n            offset += sizeof(OptionPad1);\n            break;\n\n        case OptionPadN::kType:\n            offset += sizeof(option) + option.GetLength();\n            break;\n\n        default:\n            // encountered another option, now just replace MPL Option with PadN\n            remove = false;\n            offset += sizeof(option) + option.GetLength();\n            break;\n        }\n    }\n\n    // verify that IPv6 Options header is properly formed\n    VerifyOrExit(offset == endOffset, error = OT_ERROR_PARSE);\n\n    if (remove)\n    {\n        // last IPv6 Option, shrink HBH Option header\n        uint8_t buf[8];\n\n        offset = endOffset - sizeof(buf);\n\n        while (offset >= sizeof(buf))\n        {\n            aMessage.Read(offset - sizeof(buf), sizeof(buf), buf);\n            aMessage.Write(offset, sizeof(buf), buf);\n            offset -= sizeof(buf);\n        }\n\n        aMessage.RemoveHeader(sizeof(buf));\n\n        if (mplOffset == sizeof(ip6Header) + sizeof(hbh))\n        {\n            // remove entire HBH header\n            ip6Header.SetNextHeader(hbh.GetNextHeader());\n        }\n        else\n        {\n            // update HBH header length\n            hbh.SetLength(hbh.GetLength() - 1);\n            aMessage.Write(sizeof(ip6Header), sizeof(hbh), &hbh);\n        }\n\n        ip6Header.SetPayloadLength(ip6Header.GetPayloadLength() - sizeof(buf));\n        aMessage.Write(0, sizeof(ip6Header), &ip6Header);\n    }\n    else if (mplOffset != 0)\n    {\n        // replace MPL Option with PadN Option\n        OptionPadN padOption;\n\n        padOption.Init(sizeof(OptionHeader) + mplLength);\n        aMessage.Write(mplOffset, padOption.GetTotalLength(), &padOption);\n    }\n\nexit:\n    return error;\n}\nIp6::Ip6(Instance &aInstance)\n    : InstanceLocator(aInstance)\n    , mForwardingEnabled(false)\n    , mIsReceiveIp6FilterEnabled(false)\n    , mReceiveIp6DatagramCallback(NULL)\n    , mReceiveIp6DatagramCallbackContext(NULL)\n    , mNetifListHead(NULL)\n    , mSendQueue()\n    , mSendQueueTask(aInstance, HandleSendQueue, this)\n    , mRoutes(aInstance)\n    , mIcmp(aInstance)\n    , mUdp(aInstance)\n    , mMpl(aInstance)\n{\n}\nIp6::Ip6(Instance &aInstance)\n    : InstanceLocator(aInstance)\n    , mForwardingEnabled(false)\n    , mIsReceiveIp6FilterEnabled(false)\n    , mReceiveIp6DatagramCallback(NULL)\n    , mReceiveIp6DatagramCallbackContext(NULL)\n    , mNetifListHead(NULL)\n    , mSendQueue()\n    , mSendQueueTask(aInstance, HandleSendQueue, this)\n    , mRoutes(aInstance)\n    , mIcmp(aInstance)\n    , mUdp(aInstance)\n    , mMpl(aInstance)\n{\n}\nIp6::Ip6(Instance &aInstance)\n    : InstanceLocator(aInstance)\n    , mForwardingEnabled(false)\n    , mIsReceiveIp6FilterEnabled(false)\n    , mReceiveIp6DatagramCallback(NULL)\n    , mReceiveIp6DatagramCallbackContext(NULL)\n    , mNetifListHead(NULL)\n    , mSendQueue()\n    , mSendQueueTask(aInstance, HandleSendQueue, this)\n    , mRoutes(aInstance)\n    , mIcmp(aInstance)\n    , mUdp(aInstance)\n    , mMpl(aInstance)\n{\n}\nIp6::Ip6(Instance &aInstance)\n    : InstanceLocator(aInstance)\n    , mForwardingEnabled(false)\n    , mIsReceiveIp6FilterEnabled(false)\n    , mReceiveIp6DatagramCallback(NULL)\n    , mReceiveIp6DatagramCallbackContext(NULL)\n    , mNetifListHead(NULL)\n    , mSendQueue()\n    , mSendQueueTask(aInstance, HandleSendQueue, this)\n    , mRoutes(aInstance)\n    , mIcmp(aInstance)\n    , mUdp(aInstance)\n    , mMpl(aInstance)\n{\n}\nvoid TaskletScheduler::ProcessQueuedTasklets(void)\n{\n    Tasklet *tail = mTail;\n    Tasklet *cur;\n\n    while ((cur = PopTasklet()) != NULL)\n    {\n        cur->RunTask();\n\n        // only process tasklets that were queued at the time this method was called\n        if (cur == tail)\n        {\n            if (mHead != NULL)\n            {\n                otTaskletsSignalPending(&mHead->GetInstance());\n            }\n\n            break;\n        }\n    }\n}\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)\n{\n    const otPanId panId = 0xdead;\n\n    otInstance *instance = NULL;\n    uint8_t *   buf      = NULL;\n\n    VerifyOrExit(size <= 65536);\n\n    FuzzerPlatformInit();\n\n    instance = otInstanceInitSingle();\n    otNcpInit(instance);\n    otLinkSetPanId(instance, panId);\n    otIp6SetEnabled(instance, true);\n    otThreadSetEnabled(instance, true);\n    otThreadBecomeLeader(instance);\n\n    buf = static_cast<uint8_t *>(malloc(size));\n\n    memcpy(buf, data, size);\n\n    otPlatUartReceived(buf, (uint16_t)size);\n\n    for (int i = 0; i < MAX_ITERATIONS; i++)\n    {\n        while (otTaskletsArePending(instance))\n        {\n            otTaskletsProcess(instance);\n        }\n\n        FuzzerPlatformProcess(instance);\n    }\n\nexit:\n\n    if (buf != NULL)\n    {\n        free(buf);\n    }\n\n    if (instance != NULL)\n    {\n        otInstanceFinalize(instance);\n    }\n\n    return 0;\n}",
    "target": 0,
    "idx": 2014854
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "int dav1d_decode_frame_init(Dav1dFrameContext *const f) {\n    const Dav1dContext *const c = f->c;\n    int retval = DAV1D_ERR(ENOMEM);\n\n    if (f->sbh > f->lf.start_of_tile_row_sz) {\n        free(f->lf.start_of_tile_row);\n        f->lf.start_of_tile_row = malloc(f->sbh * sizeof(uint8_t));\n        if (!f->lf.start_of_tile_row) {\n            f->lf.start_of_tile_row_sz = 0;\n            goto error;\n        }\n        f->lf.start_of_tile_row_sz = f->sbh;\n    }\n    int sby = 0;\n    for (int tile_row = 0; tile_row < f->frame_hdr->tiling.rows; tile_row++) {\n        f->lf.start_of_tile_row[sby++] = tile_row;\n        while (sby < f->frame_hdr->tiling.row_start_sb[tile_row + 1])\n            f->lf.start_of_tile_row[sby++] = 0;\n    }\n\n    const int n_ts = f->frame_hdr->tiling.cols * f->frame_hdr->tiling.rows;\n    if (n_ts != f->n_ts) {\n        if (c->n_fc > 1) {\n            freep(&f->frame_thread.tile_start_off);\n            f->frame_thread.tile_start_off =\n                malloc(sizeof(*f->frame_thread.tile_start_off) * n_ts);\n            if (!f->frame_thread.tile_start_off) {\n                f->n_ts = 0;\n                goto error;\n            }\n        }\n        Dav1dTileState *ts_new = dav1d_alloc_aligned(sizeof(*f->ts) * n_ts, 32);\n        if (!ts_new) goto error;\n        if (f->ts) {\n            memcpy(ts_new, f->ts, sizeof(*f->ts) * imin(n_ts, f->n_ts));\n            dav1d_free_aligned(f->ts);\n        }\n        f->n_ts = n_ts;\n        f->ts = ts_new;\n    }\n\n    const int a_sz = f->sb128w * f->frame_hdr->tiling.rows * (1 + (c->n_fc > 1 && c->n_tc > 1));\n    if (a_sz != f->a_sz) {\n        freep(&f->a);\n        f->a = malloc(sizeof(*f->a) * a_sz);\n        if (!f->a) {\n            f->a_sz = 0;\n            goto error;\n        }\n        f->a_sz = a_sz;\n    }\n\n    const int num_sb128 = f->sb128w * f->sb128h;\n    const uint8_t *const size_mul = ss_size_mul[f->cur.p.layout];\n    const int hbd = !!f->seq_hdr->hbd;\n    if (c->n_fc > 1) {\n        int tile_idx = 0;\n        for (int tile_row = 0; tile_row < f->frame_hdr->tiling.rows; tile_row++) {\n            int row_off = f->frame_hdr->tiling.row_start_sb[tile_row] *\n                          f->sb_step * 4 * f->sb128w * 128;\n            int b_diff = (f->frame_hdr->tiling.row_start_sb[tile_row + 1] -\n                          f->frame_hdr->tiling.row_start_sb[tile_row]) * f->sb_step * 4;\n            for (int tile_col = 0; tile_col < f->frame_hdr->tiling.cols; tile_col++) {\n                f->frame_thread.tile_start_off[tile_idx++] = row_off + b_diff *\n                    f->frame_hdr->tiling.col_start_sb[tile_col] * f->sb_step * 4;\n            }\n        }\n\n        const int lowest_pixel_mem_sz = f->frame_hdr->tiling.cols * f->sbh;\n        if (lowest_pixel_mem_sz != f->tile_thread.lowest_pixel_mem_sz) {\n            free(f->tile_thread.lowest_pixel_mem);\n            f->tile_thread.lowest_pixel_mem =\n                malloc(lowest_pixel_mem_sz * sizeof(*f->tile_thread.lowest_pixel_mem));\n            if (!f->tile_thread.lowest_pixel_mem) {\n                f->tile_thread.lowest_pixel_mem_sz = 0;\n                goto error;\n            }\n            f->tile_thread.lowest_pixel_mem_sz = lowest_pixel_mem_sz;\n        }\n        int (*lowest_pixel_ptr)[7][2] = f->tile_thread.lowest_pixel_mem;\n        for (int tile_row = 0, tile_row_base = 0; tile_row < f->frame_hdr->tiling.rows;\n             tile_row++, tile_row_base += f->frame_hdr->tiling.cols)\n        {\n            const int tile_row_sb_h = f->frame_hdr->tiling.row_start_sb[tile_row + 1] -\n                                      f->frame_hdr->tiling.row_start_sb[tile_row];\n            for (int tile_col = 0; tile_col < f->frame_hdr->tiling.cols; tile_col++) {\n                f->ts[tile_row_base + tile_col].lowest_pixel = lowest_pixel_ptr;\n                lowest_pixel_ptr += tile_row_sb_h;\n            }\n        }\n\n        const int cf_sz = (num_sb128 * size_mul[0]) << hbd;\n        if (cf_sz != f->frame_thread.cf_sz) {\n            dav1d_freep_aligned(&f->frame_thread.cf);\n            f->frame_thread.cf =\n                dav1d_alloc_aligned((size_t)cf_sz * 128 * 128 / 2, 64);\n            if (!f->frame_thread.cf) {\n                f->frame_thread.cf_sz = 0;\n                goto error;\n            }\n            memset(f->frame_thread.cf, 0, (size_t)cf_sz * 128 * 128 / 2);\n            f->frame_thread.cf_sz = cf_sz;\n        }\n\n        if (f->frame_hdr->allow_screen_content_tools) {\n            if (num_sb128 != f->frame_thread.pal_sz) {\n                dav1d_freep_aligned(&f->frame_thread.pal);\n                f->frame_thread.pal =\n                    dav1d_alloc_aligned(sizeof(*f->frame_thread.pal) *\n                                        num_sb128 * 16 * 16, 64);\n                if (!f->frame_thread.pal) {\n                    f->frame_thread.pal_sz = 0;\n                    goto error;\n                }\n                f->frame_thread.pal_sz = num_sb128;\n            }\n\n            const int pal_idx_sz = num_sb128 * size_mul[1];\n            if (pal_idx_sz != f->frame_thread.pal_idx_sz) {\n                dav1d_freep_aligned(&f->frame_thread.pal_idx);\n                f->frame_thread.pal_idx =\n                    dav1d_alloc_aligned(sizeof(*f->frame_thread.pal_idx) *\n                                        pal_idx_sz * 128 * 128 / 4, 64);\n                if (!f->frame_thread.pal_idx) {\n                    f->frame_thread.pal_idx_sz = 0;\n                    goto error;\n                }\n                f->frame_thread.pal_idx_sz = pal_idx_sz;\n            }\n        } else if (f->frame_thread.pal) {\n            dav1d_freep_aligned(&f->frame_thread.pal);\n            dav1d_freep_aligned(&f->frame_thread.pal_idx);\n            f->frame_thread.pal_sz = f->frame_thread.pal_idx_sz = 0;\n        }\n    }\n\n    // update allocation of block contexts for above\n    ptrdiff_t y_stride = f->cur.stride[0], uv_stride = f->cur.stride[1];\n    const int has_resize = f->frame_hdr->width[0] != f->frame_hdr->width[1];\n    const int need_cdef_lpf_copy = c->n_tc > 1 && has_resize;\n    if (y_stride * f->sbh * 4 != f->lf.cdef_buf_plane_sz[0] ||\n        uv_stride * f->sbh * 8 != f->lf.cdef_buf_plane_sz[1] ||\n        need_cdef_lpf_copy != f->lf.need_cdef_lpf_copy ||\n        f->sbh != f->lf.cdef_buf_sbh)\n    {\n        dav1d_free_aligned(f->lf.cdef_line_buf);\n        size_t alloc_sz = 64;\n        alloc_sz += (size_t)llabs(y_stride) * 4 * f->sbh << need_cdef_lpf_copy;\n        alloc_sz += (size_t)llabs(uv_stride) * 8 * f->sbh << need_cdef_lpf_copy;\n        uint8_t *ptr = f->lf.cdef_line_buf = dav1d_alloc_aligned(alloc_sz, 32);\n        if (!ptr) {\n            f->lf.cdef_buf_plane_sz[0] = f->lf.cdef_buf_plane_sz[1] = 0;\n            goto error;\n        }\n\n        ptr += 32;\n        if (y_stride < 0) {\n            f->lf.cdef_line[0][0] = ptr - y_stride * (f->sbh * 4 - 1);\n            f->lf.cdef_line[1][0] = ptr - y_stride * (f->sbh * 4 - 3);\n        } else {\n            f->lf.cdef_line[0][0] = ptr + y_stride * 0;\n            f->lf.cdef_line[1][0] = ptr + y_stride * 2;\n        }\n        ptr += llabs(y_stride) * f->sbh * 4;\n        if (uv_stride < 0) {\n            f->lf.cdef_line[0][1] = ptr - uv_stride * (f->sbh * 8 - 1);\n            f->lf.cdef_line[0][2] = ptr - uv_stride * (f->sbh * 8 - 3);\n            f->lf.cdef_line[1][1] = ptr - uv_stride * (f->sbh * 8 - 5);\n            f->lf.cdef_line[1][2] = ptr - uv_stride * (f->sbh * 8 - 7);\n        } else {\n            f->lf.cdef_line[0][1] = ptr + uv_stride * 0;\n            f->lf.cdef_line[0][2] = ptr + uv_stride * 2;\n            f->lf.cdef_line[1][1] = ptr + uv_stride * 4;\n            f->lf.cdef_line[1][2] = ptr + uv_stride * 6;\n        }\n\n        if (need_cdef_lpf_copy) {\n            ptr += llabs(uv_stride) * f->sbh * 8;\n            if (y_stride < 0)\n                f->lf.cdef_lpf_line[0] = ptr - y_stride * (f->sbh * 4 - 1);\n            else\n                f->lf.cdef_lpf_line[0] = ptr;\n            ptr += llabs(y_stride) * f->sbh * 4;\n            if (uv_stride < 0) {\n                f->lf.cdef_lpf_line[1] = ptr - uv_stride * (f->sbh * 4 - 1);\n                f->lf.cdef_lpf_line[2] = ptr - uv_stride * (f->sbh * 8 - 1);\n            } else {\n                f->lf.cdef_lpf_line[1] = ptr;\n                f->lf.cdef_lpf_line[2] = ptr + uv_stride * f->sbh * 4;\n            }\n        }\n\n        f->lf.cdef_buf_plane_sz[0] = (int) y_stride * f->sbh * 4;\n        f->lf.cdef_buf_plane_sz[1] = (int) uv_stride * f->sbh * 8;\n        f->lf.need_cdef_lpf_copy = need_cdef_lpf_copy;\n        f->lf.cdef_buf_sbh = f->sbh;\n    }\n\n    const int sb128 = f->seq_hdr->sb128;\n    const int num_lines = c->n_tc > 1 ? f->sbh * 4 << sb128 : 12;\n    y_stride = f->sr_cur.p.stride[0], uv_stride = f->sr_cur.p.stride[1];\n    if (y_stride * num_lines != f->lf.lr_buf_plane_sz[0] ||\n        uv_stride * num_lines * 2 != f->lf.lr_buf_plane_sz[1])\n    {\n        dav1d_free_aligned(f->lf.lr_line_buf);\n        // lr simd may overread the input, so slightly over-allocate the lpf buffer\n        size_t alloc_sz = 64;\n        alloc_sz += (size_t)llabs(y_stride) * num_lines;\n        alloc_sz += (size_t)llabs(uv_stride) * num_lines * 2;\n        uint8_t *ptr = f->lf.lr_line_buf = dav1d_alloc_aligned(alloc_sz, 32);\n        if (!ptr) {\n            f->lf.lr_buf_plane_sz[0] = f->lf.lr_buf_plane_sz[1] = 0;\n            goto error;\n        }\n\n        if (y_stride < 0)\n            f->lf.lr_lpf_line[0] = ptr - y_stride * (num_lines - 1);\n        else\n            f->lf.lr_lpf_line[0] = ptr;\n        ptr += llabs(y_stride) * num_lines;\n        if (uv_stride < 0) {\n            f->lf.lr_lpf_line[1] = ptr - uv_stride * (num_lines * 1 - 1);\n            f->lf.lr_lpf_line[2] = ptr - uv_stride * (num_lines * 2 - 1);\n        } else {\n            f->lf.lr_lpf_line[1] = ptr;\n            f->lf.lr_lpf_line[2] = ptr + uv_stride * num_lines;\n        }\n\n        f->lf.lr_buf_plane_sz[0] = (int) y_stride * num_lines;\n        f->lf.lr_buf_plane_sz[1] = (int) uv_stride * num_lines * 2;\n    }\n\n    // update allocation for loopfilter masks\n    if (num_sb128 != f->lf.mask_sz) {\n        freep(&f->lf.mask);\n        freep(&f->lf.level);\n        f->lf.mask = malloc(sizeof(*f->lf.mask) * num_sb128);\n        // over-allocate by 3 bytes since some of the SIMD implementations\n        // index this from the level type and can thus over-read by up to 3\n        f->lf.level = malloc(sizeof(*f->lf.level) * num_sb128 * 32 * 32 + 3);\n        if (!f->lf.mask || !f->lf.level) {\n            f->lf.mask_sz = 0;\n            goto error;\n        }\n        if (c->n_fc > 1) {\n            freep(&f->frame_thread.b);\n            freep(&f->frame_thread.cbi);\n            f->frame_thread.b = malloc(sizeof(*f->frame_thread.b) *\n                                       num_sb128 * 32 * 32);\n            f->frame_thread.cbi = malloc(sizeof(*f->frame_thread.cbi) *\n                                         num_sb128 * 32 * 32);\n            if (!f->frame_thread.b || !f->frame_thread.cbi) {\n                f->lf.mask_sz = 0;\n                goto error;\n            }\n        }\n        f->lf.mask_sz = num_sb128;\n    }\n\n    f->sr_sb128w = (f->sr_cur.p.p.w + 127) >> 7;\n    const int lr_mask_sz = f->sr_sb128w * f->sb128h;\n    if (lr_mask_sz != f->lf.lr_mask_sz) {\n        freep(&f->lf.lr_mask);\n        f->lf.lr_mask = malloc(sizeof(*f->lf.lr_mask) * lr_mask_sz);\n        if (!f->lf.lr_mask) {\n            f->lf.lr_mask_sz = 0;\n            goto error;\n        }\n        f->lf.lr_mask_sz = lr_mask_sz;\n    }\n    f->lf.restore_planes =\n        ((f->frame_hdr->restoration.type[0] != DAV1D_RESTORATION_NONE) << 0) +\n        ((f->frame_hdr->restoration.type[1] != DAV1D_RESTORATION_NONE) << 1) +\n        ((f->frame_hdr->restoration.type[2] != DAV1D_RESTORATION_NONE) << 2);\n    if (f->frame_hdr->loopfilter.sharpness != f->lf.last_sharpness) {\n        dav1d_calc_eih(&f->lf.lim_lut, f->frame_hdr->loopfilter.sharpness);\n        f->lf.last_sharpness = f->frame_hdr->loopfilter.sharpness;\n    }\n    dav1d_calc_lf_values(f->lf.lvl, f->frame_hdr, (int8_t[4]) { 0, 0, 0, 0 });\n    memset(f->lf.mask, 0, sizeof(*f->lf.mask) * num_sb128);\n\n    const int ipred_edge_sz = f->sbh * f->sb128w << hbd;\n    if (ipred_edge_sz != f->ipred_edge_sz) {\n        dav1d_freep_aligned(&f->ipred_edge[0]);\n        uint8_t *ptr = f->ipred_edge[0] =\n            dav1d_alloc_aligned(ipred_edge_sz * 128 * 3, 64);\n        if (!ptr) {\n            f->ipred_edge_sz = 0;\n            goto error;\n        }\n        f->ipred_edge[1] = ptr + ipred_edge_sz * 128 * 1;\n        f->ipred_edge[2] = ptr + ipred_edge_sz * 128 * 2;\n        f->ipred_edge_sz = ipred_edge_sz;\n    }\n\n    const int re_sz = f->sb128h * f->frame_hdr->tiling.cols;\n    if (re_sz != f->lf.re_sz) {\n        freep(&f->lf.tx_lpf_right_edge[0]);\n        f->lf.tx_lpf_right_edge[0] = malloc(re_sz * 32 * 2);\n        if (!f->lf.tx_lpf_right_edge[0]) {\n            f->lf.re_sz = 0;\n            goto error;\n        }\n        f->lf.tx_lpf_right_edge[1] = f->lf.tx_lpf_right_edge[0] + re_sz * 32;\n        f->lf.re_sz = re_sz;\n    }\n\n    // init ref mvs\n    if (IS_INTER_OR_SWITCH(f->frame_hdr) || f->frame_hdr->allow_intrabc) {\n        const int ret =\n            dav1d_refmvs_init_frame(&f->rf, f->seq_hdr, f->frame_hdr,\n                                    f->refpoc, f->mvs, f->refrefpoc, f->ref_mvs,\n                                    f->c->n_tc, f->c->n_fc);\n        if (ret < 0) goto error;\n    }\n\n    retval = DAV1D_ERR(EINVAL);\n\n    // setup dequant tables\n    init_quant_tables(f->seq_hdr, f->frame_hdr, f->frame_hdr->quant.yac, f->dq);\n    if (f->frame_hdr->quant.qm)\n        for (int i = 0; i < N_RECT_TX_SIZES; i++) {\n            f->qm[i][0] = dav1d_qm_tbl[f->frame_hdr->quant.qm_y][0][i];\n            f->qm[i][1] = dav1d_qm_tbl[f->frame_hdr->quant.qm_u][1][i];\n            f->qm[i][2] = dav1d_qm_tbl[f->frame_hdr->quant.qm_v][1][i];\n        }\n    else\n        memset(f->qm, 0, sizeof(f->qm));\n\n    // setup jnt_comp weights\n    if (f->frame_hdr->switchable_comp_refs) {\n        for (int i = 0; i < 7; i++) {\n            const unsigned ref0poc = f->refp[i].p.frame_hdr->frame_offset;\n\n            for (int j = i + 1; j < 7; j++) {\n                const unsigned ref1poc = f->refp[j].p.frame_hdr->frame_offset;\n\n                const unsigned d1 =\n                    imin(abs(get_poc_diff(f->seq_hdr->order_hint_n_bits, ref0poc,\n                                          f->cur.frame_hdr->frame_offset)), 31);\n                const unsigned d0 =\n                    imin(abs(get_poc_diff(f->seq_hdr->order_hint_n_bits, ref1poc,\n                                          f->cur.frame_hdr->frame_offset)), 31);\n                const int order = d0 <= d1;\n\n                static const uint8_t quant_dist_weight[3][2] = {\n                    { 2, 3 }, { 2, 5 }, { 2, 7 }\n                };\n                static const uint8_t quant_dist_lookup_table[4][2] = {\n                    { 9, 7 }, { 11, 5 }, { 12, 4 }, { 13, 3 }\n                };\n\n                int k;\n                for (k = 0; k < 3; k++) {\n                    const int c0 = quant_dist_weight[k][order];\n                    const int c1 = quant_dist_weight[k][!order];\n                    const int d0_c0 = d0 * c0;\n                    const int d1_c1 = d1 * c1;\n                    if ((d0 > d1 && d0_c0 < d1_c1) || (d0 <= d1 && d0_c0 > d1_c1)) break;\n                }\n\n                f->jnt_weights[i][j] = quant_dist_lookup_table[k][order];\n            }\n        }\n    }\n\n    /* Init loopfilter pointers. Increasing NULL pointers is technically UB,\n     * so just point the chroma pointers in 4:0:0 to the luma plane here to\n     * avoid having additional in-loop branches in various places. We never\n     * dereference those pointers so it doesn't really matter what they\n     * point at, as long as the pointers are valid. */\n    const int has_chroma = f->cur.p.layout != DAV1D_PIXEL_LAYOUT_I400;\n    f->lf.mask_ptr = f->lf.mask;\n    f->lf.p[0] = f->cur.data[0];\n    f->lf.p[1] = f->cur.data[has_chroma ? 1 : 0];\n    f->lf.p[2] = f->cur.data[has_chroma ? 2 : 0];\n    f->lf.sr_p[0] = f->sr_cur.p.data[0];\n    f->lf.sr_p[1] = f->sr_cur.p.data[has_chroma ? 1 : 0];\n    f->lf.sr_p[2] = f->sr_cur.p.data[has_chroma ? 2 : 0];\n\n    if (f->frame_hdr->refresh_context)\n        dav1d_cdf_thread_copy(f->out_cdf.data.cdf, &f->in_cdf);\n\n    // parse individual tiles per tile group\n    int tile_row = 0, tile_col = 0;\n    f->task_thread.update_set = 0;\n    for (int i = 0; i < f->n_tile_data; i++) {\n        const uint8_t *data = f->tile[i].data.data;\n        size_t size = f->tile[i].data.sz;\n\n        for (int j = f->tile[i].start; j <= f->tile[i].end; j++) {\n            size_t tile_sz;\n            if (j == f->tile[i].end) {\n                tile_sz = size;\n            } else {\n                if (f->frame_hdr->tiling.n_bytes > size) goto error;\n                tile_sz = 0;\n                for (unsigned k = 0; k < f->frame_hdr->tiling.n_bytes; k++)\n                    tile_sz |= (unsigned)*data++ << (k * 8);\n                tile_sz++;\n                size -= f->frame_hdr->tiling.n_bytes;\n                if (tile_sz > size) goto error;\n            }\n\n            setup_tile(&f->ts[j], f, data, tile_sz, tile_row, tile_col++,\n                       c->n_fc > 1 ? f->frame_thread.tile_start_off[j] : 0);\n\n            if (tile_col == f->frame_hdr->tiling.cols) {\n                tile_col = 0;\n                tile_row++;\n            }\n            if (j == f->frame_hdr->tiling.update && f->frame_hdr->refresh_context)\n                f->task_thread.update_set = 1;\n            data += tile_sz;\n            size -= tile_sz;\n        }\n    }\n\n    if (c->n_tc > 1) {\n        const int uses_2pass = c->n_fc > 1;\n        for (int n = 0; n < f->sb128w * f->frame_hdr->tiling.rows * (1 + uses_2pass); n++)\n            reset_context(&f->a[n], IS_KEY_OR_INTRA(f->frame_hdr),\n                          uses_2pass ? 1 + (n >= f->sb128w * f->frame_hdr->tiling.rows) : 0);\n    }\n\n    retval = 0;\nerror:\n    return retval;\n}",
    "target": 0,
    "idx": 2040661
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "static int\ndecode_preR13_section (Dwg_Section_Type_r11 id, Bit_Chain *restrict dat,\n                       Dwg_Data *restrict dwg)\n{\n  Dwg_Section *tbl = &dwg->header.section[id];\n  Bit_Chain *hdl_dat = dat;\n  int i;\n  BITCODE_BL vcount;\n  int error = 0;\n  long unsigned int num = dwg->num_objects;\n  long unsigned int pos = tbl->address;\n  BITCODE_RC flag;\n  BITCODE_TF name;\n\n  LOG_TRACE (\"contents table %-8s [%2d]: size:%-4u num:%-3ld (0x%lx-0x%lx)\\n\",\n             tbl->name, id, tbl->size, (long)tbl->number, (unsigned long)tbl->address,\n             (unsigned long)(tbl->address + ((unsigned long long)tbl->number * tbl->size)))\n  dat->byte = tbl->address;\n  dat->bit = 0;\n  if ((unsigned long)(tbl->number * tbl->size) > dat->size - dat->byte)\n    {\n      LOG_ERROR (\"Overlarge table num_entries %ld or size %ld for %-8s [%2d]\",\n                 (long)tbl->number, (long)tbl->size, tbl->name, id);\n      return DWG_ERR_INVALIDDWG;\n    }\n  tbl->objid_r11 = num;\n  if (dwg->num_alloced_objects < dwg->num_objects + tbl->number)\n    {\n      dwg->num_alloced_objects = dwg->num_objects + tbl->number;\n      dwg->object = (Dwg_Object*)realloc (dwg->object,\n          dwg->num_alloced_objects * sizeof (Dwg_Object));\n      dwg->dirty_refs = 1;\n    }\n\n  // TODO: use the dwg.spec instead\n  // MAYBE: move to a spec dwg_r11.spec, and dwg_decode_r11_NAME\n#define PREP_TABLE(token)                                                     \\\n  Dwg_Object *obj;                                                            \\\n  Dwg_Object_##token *_obj;                                                   \\\n  Dwg_Object *ctrl = dwg_get_first_object (dwg, DWG_TYPE_##token##_CONTROL);  \\\n  Dwg_Object_##token##_CONTROL *_ctrl                                         \\\n    = ctrl ? ctrl->tio.object->tio.token##_CONTROL : NULL;                    \\\n  if (!ctrl || dat->byte > dat->size || (num + i) > dwg->num_objects)         \\\n    return DWG_ERR_INVALIDDWG;                                                \\\n  flag = bit_read_RC (dat);                                                   \\\n  name = bit_read_TF (dat, 32);                                               \\\n  _obj = dwg_add_##token (dwg, (const char *)name);                           \\\n  obj = dwg_obj_generic_to_object (_obj, &error);                             \\\n  _ctrl->entries[i] = dwg_add_handleref (dwg, 2, obj->handle.value, obj);     \\\n  obj->size = tbl->size;                                                      \\\n  obj->address = pos;                                                         \\\n  _obj->flag = flag;                                                          \\\n  LOG_TRACE (\"\\n-- table entry \" #token \" [%d]: 0x%lx\\n\", i, pos);            \\\n  LOG_TRACE (\"flag: %u [RC 70]\\n\", flag);                                     \\\n  LOG_TRACE (\"name: \\\"%s\\\" [TF 32 2]\\n\", name);                               \\\n  free (name)\n\n#define CHK_ENDPOS                                                            \\\n  SINCE (R_11) {                                                              \\\n    BITCODE_RS crc16 = bit_read_RS (dat);                                     \\\n    LOG_TRACE (\"crc16: %04X\\n\", crc16);                                       \\\n  }                                                                           \\\n  pos = tbl->address + (long)((i + 1) * tbl->size);                           \\\n  if (pos != dat->byte)                                                       \\\n    {                                                                         \\\n      LOG_ERROR (\"offset %ld\", pos - dat->byte);                              \\\n      /*return DWG_ERR_SECTIONNOTFOUND;*/                                     \\\n    }                                                                         \\\nEXPORT int\ndecode_preR13 (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  BITCODE_RL entities_start = 0, entities_end = 0;\n  BITCODE_RL blocks_start = 0, blocks_size = 0, blocks_end = 0;\n  BITCODE_RL rl1, rl2, blocks_max = 0xFFFFFFFF, num_entities;\n  BITCODE_RS rs2;\n  Dwg_Object *obj = NULL;\n  int tbl_id;\n  int error = 0;\n  int num_sections = 5;\n\n  loglevel = dat->opts & DWG_OPTS_LOGLEVEL;\n#ifndef USE_WRITE\n  fprintf(stderr, \"Cannot create pre-R13 documents with --disable-write\\n\");\n  return DWG_ERR_INTERNALERROR;\n#else\n  {\n    int i;\n    Dwg_Header *_obj = (Dwg_Header *)&dwg->header;\n    Bit_Chain *hdl_dat = dat;\n    dat->byte = 0x06;\n    // clang-format off\n    #include \"header.spec\"\n    // clang-format on\n  }\n  LOG_TRACE (\"@0x%lx\\n\", dat->byte); // 0x14\n\n  // setup all the new control objects\n  error |= dwg_add_Document (dwg, 0);\n\n  // 5 tables + header + block. VIEW = 6\n  if (dwg->header.numheader_vars > 158) // r10\n    num_sections += 3;\n  if (dwg->header.numheader_vars > 160) // r11\n    num_sections += 2;\n  dwg->header.section = (Dwg_Section *)calloc (sizeof (Dwg_Section),\n                                               num_sections + 2);\n  if (!dwg->header.section)\n    {\n      LOG_ERROR (\"Out of memory\");\n      return DWG_ERR_OUTOFMEM;\n    }\n  dwg->header.numsections = num_sections;\n  PRE (R_2_0b) {\n    bit_read_RC (dat); // the 6th zero\n    LOG_TRACE (\"zero[6]: 0 [RC 0]\\n\");\n  }\n  SINCE (R_2_0b) {\n    entities_start = bit_read_RL (dat);\n    LOG_TRACE (\"entities_start: \" FORMAT_RL \" (\" FORMAT_RLx \") [RL]\\n\", entities_start, entities_start);\n    entities_end = bit_read_RL (dat);\n    LOG_TRACE (\"entities_end: \" FORMAT_RL \" (\" FORMAT_RLx \") [RL]\\n\", entities_end, entities_end);\n    blocks_start = bit_read_RL (dat);\n    LOG_TRACE (\"blocks_start: \" FORMAT_RL \" (\" FORMAT_RLx \") [RL]\\n\", blocks_start, blocks_start);\n    blocks_size = bit_read_RL (dat);\n    if (blocks_size >= 0x40000000) {\n      LOG_TRACE (\"blocks_size: 0x40000000 | \" FORMAT_RL \" [RLx]\\n\", blocks_size & 0x3fffffff);\n    }\n    else {\n      LOG_TRACE (\"blocks_size: \" FORMAT_RL \" [RL]\\n\", blocks_size);\n    }\n    blocks_end = bit_read_RL (dat);\n    LOG_TRACE (\"blocks_end: \" FORMAT_RL \" (\" FORMAT_RLx \") [RL]\\n\", blocks_end, blocks_end);\n    blocks_max = bit_read_RL (dat); // 0x80000000\n    LOG_TRACE (\"blocks_max: \" FORMAT_RLx \" [RLx]\\n\", blocks_max);\n    tbl_id = 0;\n    dwg->header.section[0].number = 0;\n    dwg->header.section[0].type = (Dwg_Section_Type)SECTION_HEADER_R11;\n    strcpy (dwg->header.section[0].name, \"HEADER\");\n\n    // The 5 tables (num_sections always 5): 3 RS + 1 RL address\n    LOG_INFO (\"==========================================\\n\")\n    if (decode_preR13_section_hdr (\"BLOCK\", SECTION_BLOCK, dat, dwg)\n        || decode_preR13_section_hdr (\"LAYER\", SECTION_LAYER, dat, dwg)\n        || decode_preR13_section_hdr (\"STYLE\", SECTION_STYLE, dat, dwg)\n        || decode_preR13_section_hdr (\"LTYPE\", SECTION_LTYPE, dat, dwg)\n        || decode_preR13_section_hdr (\"VIEW\", SECTION_VIEW, dat, dwg))\n      return DWG_ERR_INVALIDDWG;\n  }\n  LOG_TRACE (\"@0x%lx\\n\", dat->byte); // 0x5e\n  if (dat->size < 0x1f0) // AC1.50 0x1f9 74 vars\n    {\n      LOG_ERROR (\"DWG too small %zu\", (size_t)dat->size)\n      return DWG_ERR_INVALIDDWG;\n    }\n\n  LOG_INFO (\"==========================================\\n\")\n  error |= decode_preR13_header_variables (dat, dwg);\n  LOG_TRACE (\"@0x%lx\\n\", dat->byte);\n  if (error >= DWG_ERR_CRITICAL)\n    return error;\n  SINCE (R_11)\n    {\n      // crc16 + DWG_SENTINEL_R11_HEADER_END\n      BITCODE_RS crc, crcc;\n      BITCODE_TF r11_sentinel;\n      crcc = bit_calc_CRC (0xC0C1, &dat->chain[0], dat->byte); // from 0 to now\n      crc = bit_read_RS (dat);\n      LOG_TRACE (\"crc: %04X [RSx] from 0-0x%lx\\n\", crc, dat->byte - 2);\n      if (crc != crcc)\n        {\n          LOG_ERROR (\"Header CRC mismatch %04X <=> %04X\", crc, crcc);\n          error |= DWG_ERR_WRONGCRC;\n        }\n      r11_sentinel = bit_read_TF (dat, 16);\n      LOG_TRACE (\"r11_sentinel: \");\n      LOG_TRACE_TF (r11_sentinel, 16) // == C46E6854F86E3330633EC1852ADC9401\n      if (memcmp (r11_sentinel, dwg_sentinel (DWG_SENTINEL_R11_HEADER_END), 16))\n        {\n          LOG_ERROR (\"DWG_SENTINEL_R11_HEADER_END mismatch\");\n          error |= DWG_ERR_WRONGCRC;\n        }\n      free (r11_sentinel);\n    }\n\n  PRE (R_10)\n    num_entities = dwg->header_vars.numentities;\n  else\n    num_entities = 0;\n  PRE (R_2_0b) {\n    entities_start = dat->byte;\n    entities_end = dwg->header_vars.dwg_size;\n  }\n\n  // additional tables mixed-in since r10\n  if (dwg->header.numheader_vars > 158) // r10\n    {\n      dat->byte = 0x3ef;\n      LOG_TRACE (\"@0x%lx\\n\", dat->byte);\n      decode_preR13_section_hdr (\"UCS\", SECTION_UCS, dat, dwg);\n      dat->byte = 0x500;\n      LOG_TRACE (\"@0x%lx\\n\", dat->byte);\n      decode_preR13_section_hdr (\"VPORT\", SECTION_VPORT, dat, dwg);\n      dat->byte = 0x512;\n      LOG_TRACE (\"@0x%lx\\n\", dat->byte);\n      decode_preR13_section_hdr (\"APPID\", SECTION_APPID, dat, dwg);\n      dat->byte = entities_start;\n    }\n  if (dwg->header.numheader_vars > 160) // r11\n    {\n      dat->byte = 0x522;\n      LOG_TRACE (\"@0x%lx\\n\", dat->byte);\n      decode_preR13_section_hdr (\"DIMSTYLE\", SECTION_DIMSTYLE, dat, dwg);\n      dat->byte = 0x69f;\n      LOG_TRACE (\"@0x%lx\\n\", dat->byte);\n      decode_preR13_section_hdr (\"VX\", SECTION_VX, dat, dwg);\n      dat->byte = entities_start;\n    }\n\n  // entities\n  if (dat->byte != entities_start)\n    {\n      LOG_WARN (\"@0x%lx => entities_start 0x%x\", dat->byte, entities_start);\n      if (dat->byte < entities_start)\n        {\n          _DEBUG_HERE (dat->byte - entities_start)\n        }\n      dat->byte = entities_start;\n    }\n  error |= decode_preR13_entities (entities_start, entities_end, num_entities,\n                                   entities_end - entities_start, 0, dat, dwg);\n  if (error >= DWG_ERR_CRITICAL)\n    return error;\n  if (dat->byte != entities_end)\n    {\n      LOG_WARN (\"@0x%lx => entities_end 0x%x\", dat->byte, entities_end);\n      dat->byte = entities_end;\n    }\n  PRE (R_2_0b) {\n    // this has usually some slack at the end.\n    return error;\n  }\n  LOG_INFO (\"==========================================\\n\")\n  //dat->byte += 20; /* crc + sentinel? 20 byte */\n  if (!dwg->next_hdl)\n    dwg_set_next_hdl (dwg, 0x22);\n  error |= decode_preR13_section (SECTION_BLOCK, dat, dwg);\n  error |= decode_preR13_section (SECTION_LAYER, dat, dwg);\n  error |= decode_preR13_section (SECTION_STYLE, dat, dwg);\n  error |= decode_preR13_section (SECTION_LTYPE, dat, dwg);\n  error |= decode_preR13_section (SECTION_VIEW, dat, dwg);\n#if 1\n  if (num_sections > 5) // r10\n    {\n      error |= decode_preR13_section (SECTION_UCS, dat, dwg);\n      error |= decode_preR13_section (SECTION_VPORT, dat, dwg);\n      error |= decode_preR13_section (SECTION_APPID, dat, dwg);\n    }\n  if (num_sections > 8) // r11\n    {\n      error |= decode_preR13_section (SECTION_DIMSTYLE, dat, dwg);\n      error |= decode_preR13_section (SECTION_VX, dat, dwg);\n    }\n#endif\n  if (error >= DWG_ERR_CRITICAL)\n    return error;\n\n  // block entities\n  if (dat->byte != blocks_start)\n    {\n      BITCODE_TF unknown;\n      int len = blocks_start - dat->byte;\n      LOG_WARN (\"\\n@0x%lx => blocks_start 0x%x\", dat->byte, blocks_start);\n      if (dat->byte < blocks_start)\n        {\n          unknown = bit_read_TF (dat, len);\n          LOG_TRACE (\"unknown (%d):\", len);\n          LOG_TRACE_TF (unknown, len);\n          free (unknown);\n        }\n      dat->byte = blocks_start;\n    }\n  num_entities = 0;\n  VERSION (R_11)\n    blocks_end -= 32; // ??\n  error |= decode_preR13_entities (blocks_start, blocks_end,\n                                   num_entities, blocks_size & 0x3FFFFFFF,\n                                   blocks_max, dat, dwg);\n  if (error >= DWG_ERR_CRITICAL)\n    return error;\n\n  PRE (R_11) {\n    return error;\n  }\n  // only since r11 (AC1009)\n  LOG_TRACE (\"AUXHEADER: @0x%lx\\n\", dat->byte);\n  // 36 byte: 9x long\n  rl1 = bit_read_RL (dat);\n  rl2 = bit_read_RL (dat);\n  LOG_TRACE (\"?2long: 0x%x 0x%x %f\\n\", rl1, rl2,\n             (double)dat->chain[dat->byte - 8]);\n  rl1 = bit_read_RL (dat);\n  rl2 = bit_read_RL (dat);\n  LOG_TRACE (\"?2long: 0x%x 0x%x %f\\n\", rl1, rl2,\n             (double)dat->chain[dat->byte - 8]);\n  rl1 = bit_read_RL (dat);\n  rl2 = bit_read_RL (dat);\n  LOG_TRACE (\"?2long: 0x%x 0x%x %f\\n\", rl1, rl2,\n             (double)dat->chain[dat->byte - 8]);\n  rl1 = bit_read_RL (dat);\n  rl2 = bit_read_RL (dat);\n  LOG_TRACE (\"?2long: 0x%x 0x%x %f\\n\", rl1, rl2,\n             (double)dat->chain[dat->byte - 8]);\n  rl1 = bit_read_RL (dat);\n  LOG_TRACE (\"?1long: 0x%x\\n\", rl1);\n\n  LOG_TRACE (\"@0x%lx: 4 block ptrs chk\\n\", dat->byte);\n  if ((rl1 = bit_read_RL (dat)) != entities_start)\n    {\n      LOG_WARN (\"entities_start %x/%x\", rl1, entities_start);\n    }\n  if ((rl1 = bit_read_RL (dat)) != entities_end)\n    {\n      LOG_WARN (\"entities_end %x/%x\", rl1, entities_end);\n    }\n  if ((rl1 = bit_read_RL (dat)) != blocks_start)\n    {\n      LOG_WARN (\"blocks_start %x/%x\", rl1, blocks_start);\n    }\n  if ((rl1 = bit_read_RL (dat)) != blocks_end)\n    {\n      LOG_WARN (\"blocks_end %x/%x\", rl1, blocks_end);\n    }\n  // 12 byte\n  LOG_TRACE (\"@0x%lx\\n\", dat->byte);\n  rl1 = bit_read_RL (dat);\n  rl2 = bit_read_RL (dat);\n  LOG_TRACE (\"?2long: 0x%x 0x%x\\n\", rl1, rl2);\n  rl1 = bit_read_RL (dat);\n  LOG_TRACE (\"?1long: 0x%x\\n\", rl1);\n\n  rl1 = blocks_end + 36 + 4 * 4 + 12; // ??\n  DEBUG_HERE\n  UNKNOWN_UNTIL (rl1);\n  LOG_TRACE (\"@0x%lx\\n\", dat->byte);\n  decode_preR13_section_chk (SECTION_BLOCK, dat, dwg);\n  decode_preR13_section_chk (SECTION_LAYER, dat, dwg);\n  decode_preR13_section_chk (SECTION_STYLE, dat, dwg);\n  decode_preR13_section_chk (SECTION_LTYPE, dat, dwg);\n  decode_preR13_section_chk (SECTION_VIEW, dat, dwg);\n  if (num_sections > 5) // dead code?\n    {\n      decode_preR13_section_chk (SECTION_UCS, dat, dwg);\n      decode_preR13_section_chk (SECTION_VPORT, dat, dwg);\n      decode_preR13_section_chk (SECTION_APPID, dat, dwg);\n      decode_preR13_section_chk (SECTION_DIMSTYLE, dat, dwg);\n      decode_preR13_section_chk (SECTION_VX, dat, dwg);\n    }\n  rl1 = bit_read_RL (dat);\n  LOG_TRACE (\"long 0x%x\\n\", rl1); // address\n  if (dat->byte < dat->size)\n    {\n      int len = dat->size - dat->byte;\n      BITCODE_TF unknown = bit_read_TF (dat, len);\n      LOG_TRACE (\"unknown (%d):\", len);\n      LOG_TRACE_TF (unknown, len);\n      free (unknown);\n    }\n  if (dwg->dirty_refs)\n    dwg_resolve_objectrefs_silent (dwg);\n  return 0;\n#endif // USE_WRITE\n}\nEXPORT int\ndwg_decode (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  int i;\n  char magic[8];\n\n  dwg->num_object_refs = 0;\n  // dwg->num_layers = 0; // see now dwg->layer_control->num_entries\n  dwg->num_entities = 0;\n  dwg->num_objects = 0;\n  dwg->num_classes = 0;\n  dwg->thumbnail.size = 0;\n  dwg->thumbnail.chain = NULL;\n  dwg->header.numsections = 0;\n  dwg->header.section_infohdr.num_desc = 0;\n  dwg->dwg_class = NULL;\n  dwg->object_ref = NULL;\n  dwg->object = NULL;\n  dwg->object_map = hash_new (dat->size / 1000);\n  if (!dwg->object_map)\n    {\n      // whatever, we are obviously on a tiny system\n      dwg->object_map = hash_new (1024);\n      if (!dwg->object_map)\n        {\n          LOG_ERROR (\"Out of memory\");\n          return DWG_ERR_OUTOFMEM;\n        }\n    }\n  dwg->dirty_refs = 1;\n\n  //memset (&dwg->header, 0, sizeof (dwg->header)); // no, needed for magic\n  memset (&dwg->header_vars, 0, sizeof (dwg->header_vars));\n  memset (&dwg->summaryinfo, 0, sizeof (dwg->summaryinfo));\n  memset (&dwg->r2004_header, 0, sizeof (dwg->r2004_header));\n  memset (&dwg->auxheader, 0, sizeof (dwg->auxheader));\n  memset (&dwg->second_header, 0, sizeof (dwg->second_header));\n\n  if (dwg->opts)\n    {\n      loglevel = dwg->opts & DWG_OPTS_LOGLEVEL;\n      dat->opts = dwg->opts;\n    }\n\n#ifdef USE_TRACING\n  /* Before starting, set the logging level, but only do so once.  */\n  if (!env_var_checked_p)\n    {\n      char *probe = getenv (\"LIBREDWG_TRACE\");\n      if (probe)\n        loglevel = atoi (probe);\n      env_var_checked_p = true;\n    }\n#endif /* USE_TRACING */\n\n  /* Version */\n  dat->byte = 0;\n  dat->bit = 0;\n  if (!dat->chain || dat->size < 58) // saw the smallest r2.10 DWG with 1095 bytes\n    {\n      LOG_ERROR (\"dwg too small: %lu bytes\", dat->size);\n      return DWG_ERR_INVALIDDWG;\n    }\n  strncpy (magic, (const char *)dat->chain, 6);\n  if (memcmp (dat->chain, \"AC103-4\", 7) == 0)\n    {\n      magic[6] = '4';\n      magic[7] = '\\0';\n    }\n  else\n    magic[6] = '\\0';\n\n  dwg->header.from_version = dwg_version_hdr_type (magic);\n  if (!dwg->header.from_version)\n    {\n      if (strncmp (magic, \"AC\", 2)) // let's ignore MC0.0 for now\n        {\n          LOG_ERROR (\"Invalid DWG, magic: %s\", magic);\n        }\n      else\n        {\n          LOG_ERROR (\"Invalid or unimplemented DWG version code %s\", magic);\n        }\n      return DWG_ERR_INVALIDDWG;\n    }\n  dat->from_version = dwg->header.from_version;\n  if (!dwg->header.version) // target version not set\n    {\n      dat->version = dwg->header.version = dat->from_version;\n    }\n  LOG_INFO (\"This file's version code is: %s (%s)\\n\", magic,\n            dwg_version_type (dat->from_version))\n\n  PRE (R_13) {\n    Dwg_Object *ctrl;\n    int error = decode_preR13 (dat, dwg);\n    if (error <= DWG_ERR_CRITICAL)\n      {\n        ctrl = &dwg->object[0];\n        dwg->block_control = *ctrl->tio.object->tio.BLOCK_CONTROL;\n      }\n    return error;\n  }\n  VERSIONS (R_13, R_2000) { return decode_R13_R2000 (dat, dwg); }\n  VERSION (R_2004) { return decode_R2004 (dat, dwg); }\n  VERSION (R_2007) { return decode_R2007 (dat, dwg); }\n  SINCE (R_2010)\n  {\n    read_r2007_init (dwg); // sets loglevel only for now\n    return decode_R2004 (dat, dwg);\n  }\n\n  // This line should not be reached\n  LOG_ERROR (\"LibreDWG does not support this DWG version: %s (%s).\",\n\t     magic, dwg_version_type (dat->from_version))\n  return DWG_ERR_INVALIDDWG;\n}\nint LLVMFuzzerTestOneInput(const unsigned char *data, size_t size) {\n    Dwg_Data dwg;\n    Bit_Chain dat = { NULL, 0, 0, 0, 0 };\n    Bit_Chain out_dat = { NULL, 0, 0, 0, 0 };\n    int copied = 0;\n    struct ly_ctx *ctx = NULL;\n    unsigned int possible_outputformats;\n    int out;\n\n    static char tmp_file[256];\n    dat.chain = (unsigned char *)data;\n    dat.size = size;\n    memset (&dwg, 0, sizeof (dwg));\n\n    possible_outputformats =\n#ifdef DISABLE_DXF\n# ifdef DISABLE_JSON\n        1;\n# else\n        3;\n# endif\n#else\n        5;\n#endif\n\n    // Detect the input format: DWG, DXF or JSON\n    if (dat.size > 2 && dat.chain[0] == 'A' && dat.chain[1] == 'C')\n      {\n        if (dwg_decode (&dat, &dwg) >= DWG_ERR_CRITICAL)\n          {\n            dwg_free (&dwg);\n            return 0;\n          }\n      }\n#ifndef DISABLE_JSON\n    else if (dat.size > 1 && dat.chain[0] == '{')\n      {\n        copied = enforce_null_termination(&dat, true);\n        if (dwg_read_json (&dat, &dwg) >= DWG_ERR_CRITICAL)\n          {\n            if (copied)\n              bit_chain_free (&dat);\n            dwg_free (&dwg);\n            return 0;\n          }\n        dat.opts |= DWG_OPTS_INJSON;\n        dwg.opts |= DWG_OPTS_INJSON;\n      }\n#endif\n#ifndef DISABLE_DXF\n    else\n      {\n        copied = enforce_null_termination(&dat, false);\n        if (dwg_read_dxf (&dat, &dwg) >= DWG_ERR_CRITICAL)\n          {\n            if (copied)\n              bit_chain_free (&dat);\n            dwg_free (&dwg);\n            return 0;\n          }\n      }\n#else\n    else\n      return 0;\n#endif\n\n    memset (&out_dat, 0, sizeof (out_dat));\n    bit_chain_set_version (&out_dat, &dat);\n    if (copied)\n      bit_chain_free (&dat);\n\n#if 0\n    snprintf (tmp_file, 255, \"/tmp/llvmfuzzer%d.out\", getpid());\n    tmp_file[255] = '\\0';\n#elif defined _WIN32\n    strcpy (tmp_file, \"NUL\");\n#else\n    strcpy (tmp_file, \"/dev/null\");\n#endif\n    out_dat.fh = fopen(tmp_file, \"w\");\n\n    out = rand () % possible_outputformats;\n#ifdef STANDALONE\n    if (getenv(\"OUT\"))\n      out = strtol (getenv(\"OUT\"), NULL, 10);\n#endif\n    switch (out)\n      {\n      case 0:\n        {\n          int ver = rand() % 6;\n#ifdef STANDALONE\n          if (getenv(\"VER\"))\n            ver = strtol (getenv(\"VER\"), NULL, 10);\n#endif\n          switch (ver)\n            {\n            case 0:\n              out_dat.version = dwg.header.version = R_13;\n              break;\n            case 1:\n              out_dat.version = dwg.header.version = R_13c3;\n              break;\n            case 2:\n              out_dat.version = dwg.header.version = R_14;\n              break;\n            case 3: // favor this one\n            case 4:\n            case 5:\n            default:\n              out_dat.version = dwg.header.version = R_2000;\n              break;\n            }\n          dwg_encode (&dwg, &out_dat);\n          free (out_dat.chain);\n          break;\n        }\n#ifndef DISABLE_DXF\n      case 1:\n          dwg_write_dxf (&out_dat, &dwg);\n          free (out_dat.chain);\n          break;\n      case 2: // experimental\n          dwg_write_dxfb (&out_dat, &dwg);\n          free (out_dat.chain);\n          break;\n# ifndef DISABLE_JSON\n      case 3:\n          dwg_write_json (&out_dat, &dwg);\n          free (out_dat.chain);\n          break;\n      case 4:\n          dwg_write_geojson (&out_dat, &dwg);\n          free (out_dat.chain);\n          break;\n# endif\n#endif\n      default: break;\n      }\n    dwg_free (&dwg);\n    fclose (out_dat.fh);\n    //unlink (tmp_file);\n    return 0;\n}",
    "target": 0,
    "idx": 2054839
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "void pns_decode(ic_stream *ics_left, ic_stream *ics_right,\n                real_t *spec_left, real_t *spec_right, uint16_t frame_len,\n                uint8_t channel_pair, uint8_t object_type,\n                /* RNG states */ uint32_t *__r1, uint32_t *__r2)\n{\n    uint8_t g, sfb, b;\n    uint16_t begin, end;\n\n    uint8_t group = 0;\n    uint16_t nshort = frame_len >> 3;\n\n    uint8_t sub = 0;\n\n#ifdef FIXED_POINT\n    /* IMDCT scaling */\n    if (object_type == LD)\n    {\n        sub = 9 /*9*/;\n    } else {\n        if (ics_left->window_sequence == EIGHT_SHORT_SEQUENCE)\n            sub = 7 /*7*/;\n        else\n            sub = 10 /*10*/;\n    }\n#endif\n\n    for (g = 0; g < ics_left->num_window_groups; g++)\n    {\n        /* Do perceptual noise substitution decoding */\n        for (b = 0; b < ics_left->window_group_length[g]; b++)\n        {\n            uint16_t base = group * nshort;\n            for (sfb = 0; sfb < ics_left->max_sfb; sfb++)\n            {\n                uint32_t r1_dep = 0, r2_dep = 0;\n\n                if (is_noise(ics_left, g, sfb))\n                {\n#ifdef LTP_DEC\n                    /* Simultaneous use of LTP and PNS is not prevented in the\n                       syntax. If both LTP, and PNS are enabled on the same\n                       scalefactor band, PNS takes precedence, and no prediction\n                       is applied to this band.\n                    */\n                    ics_left->ltp.long_used[sfb] = 0;\n                    ics_left->ltp2.long_used[sfb] = 0;\n#endif\n\n#ifdef MAIN_DEC\n                    /* For scalefactor bands coded using PNS the corresponding\n                       predictors are switched to \"off\".\n                    */\n                    ics_left->pred.prediction_used[sfb] = 0;\n#endif\n                    begin = min(base + ics_right->swb_offset[sfb], ics_right->swb_offset_max);\n                    end = min(base + ics_left->swb_offset[sfb+1], ics_left->swb_offset_max);\n\n                    r1_dep = *__r1;\n                    r2_dep = *__r2;\n\n                    /* Generate random vector */\n                    gen_rand_vector(&spec_left[begin],\n                        ics_left->scale_factors[g][sfb], end - begin, sub, __r1, __r2);\n                }\n\n/* From the spec:\n   If the same scalefactor band and group is coded by perceptual noise\n   substitution in both channels of a channel pair, the correlation of\n   the noise signal can be controlled by means of the ms_used field: While\n   the default noise generation process works independently for each channel\n   (separate generation of random vectors), the same random vector is used\n   for both channels if ms_used[] is set for a particular scalefactor band\n   and group. In this case, no M/S stereo coding is carried out (because M/S\n   stereo coding and noise substitution coding are mutually exclusive).\n   If the same scalefactor band and group is coded by perceptual noise\n   substitution in only one channel of a channel pair the setting of ms_used[]\n   is not evaluated.\n*/\n                if ((ics_right != NULL)\n                    && is_noise(ics_right, g, sfb))\n                {\n#ifdef LTP_DEC\n                    /* See comment above. */\n                    ics_right->ltp.long_used[sfb] = 0;\n                    ics_right->ltp2.long_used[sfb] = 0;\n#endif\n#ifdef MAIN_DEC\n                    /* See comment above. */\n                    ics_right->pred.prediction_used[sfb] = 0;\n#endif\n\n                    if (channel_pair && is_noise(ics_left, g, sfb) &&\n                        (((ics_left->ms_mask_present == 1) &&\n                        (ics_left->ms_used[g][sfb])) ||\n                        (ics_left->ms_mask_present == 2)))\n                    {\n                        /*uint16_t c;*/\n\n                        begin = min(base + ics_right->swb_offset[sfb], ics_right->swb_offset_max);\n                        end = min(base + ics_right->swb_offset[sfb+1], ics_right->swb_offset_max);\n\n                        /* Generate random vector dependent on left channel*/\n                        gen_rand_vector(&spec_right[begin],\n                            ics_right->scale_factors[g][sfb], end - begin, sub, &r1_dep, &r2_dep);\n\n                    } else /*if (ics_left->ms_mask_present == 0)*/ {\n                        begin = min(base + ics_right->swb_offset[sfb], ics_right->swb_offset_max);\n                        end = min(base + ics_right->swb_offset[sfb+1], ics_right->swb_offset_max);\n\n                        /* Generate random vector */\n                        gen_rand_vector(&spec_right[begin],\n                            ics_right->scale_factors[g][sfb], end - begin, sub, __r1, __r2);\n                    }\n                }\n            } /* sfb */\n            group++;\n        } /* b */\n    } /* g */\n}\nstatic INLINE void gen_rand_vector(real_t *spec, int16_t scale_factor, uint16_t size,\n                                   uint8_t sub,\n                                   /* RNG states */ uint32_t *__r1, uint32_t *__r2)\n{\n#ifndef FIXED_POINT\n    uint16_t i;\n    real_t energy = 0.0;\n\n    real_t scale = (real_t)1.0/(real_t)size;\n\n    for (i = 0; i < size; i++)\n    {\n        real_t tmp = scale*(real_t)(int32_t)ne_rng(__r1, __r2);\n        spec[i] = tmp;\n        energy += tmp*tmp;\n    }\n\n    scale = (real_t)1.0/(real_t)sqrt(energy);\n    scale *= (real_t)pow(2.0, 0.25 * scale_factor);\n    for (i = 0; i < size; i++)\n    {\n        spec[i] *= scale;\n    }\n#else\n    uint16_t i;\n    real_t energy = 0, scale;\n    int32_t exp, frac;\n\n    for (i = 0; i < size; i++)\n    {\n        /* this can be replaced by a 16 bit random generator!!!! */\n        real_t tmp = (int32_t)ne_rng(__r1, __r2);\n        if (tmp < 0)\n            tmp = -(tmp & ((1<<(REAL_BITS-1))-1));\n        else\n            tmp = (tmp & ((1<<(REAL_BITS-1))-1));\n\n        energy += MUL_R(tmp,tmp);\n\n        spec[i] = tmp;\n    }\n\n    energy = fp_sqrt(energy);\n    if (energy > 0)\n    {\n        scale = DIV(REAL_CONST(1),energy);\n\n        exp = scale_factor >> 2;\n        frac = scale_factor & 3;\n\n        /* IMDCT pre-scaling */\n        exp -= sub;\n\n        if (exp < 0)\n            scale >>= -exp;\n        else\n            scale <<= exp;\n\n        if (frac)\n            scale = MUL_C(scale, pow2_table[frac]);\n\n        for (i = 0; i < size; i++)\n        {\n            spec[i] = MUL_R(spec[i], scale);\n        }\n    }\n#endif\n}\nstatic void decode_cpe(NeAACDecStruct *hDecoder, NeAACDecFrameInfo *hInfo, bitfile *ld,\n                       uint8_t id_syn_ele)\n{\n    uint8_t channels = hDecoder->fr_channels;\n    uint8_t tag = 0;\n\n    if (channels+2 > MAX_CHANNELS)\n    {\n        hInfo->error = 12;\n        return;\n    }\n    if (hDecoder->fr_ch_ele+1 > MAX_SYNTAX_ELEMENTS)\n    {\n        hInfo->error = 13;\n        return;\n    }\n\n    /* for CPE the number of output channels is always 2 */\n    if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] == 0)\n    {\n        /* element_output_channels not set yet */\n        hDecoder->element_output_channels[hDecoder->fr_ch_ele] = 2;\n    } else if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] != 2) {\n        /* element inconsistency */\n        hInfo->error = 21;\n        return;\n    }\n\n    if (hDecoder->element_id[hDecoder->fr_ch_ele] != INVALID_ELEMENT_ID &&\n        hDecoder->element_id[hDecoder->fr_ch_ele] != id_syn_ele)\n    {\n        /* element inconsistency */\n        hInfo->error = 21;\n        return;\n    }\n\n    /* save the syntax element id */\n    hDecoder->element_id[hDecoder->fr_ch_ele] = id_syn_ele;\n\n    /* decode the element */\n    hInfo->error = channel_pair_element(hDecoder, ld, channels, &tag);\n\n    /* map output channel position to internal data channels */\n    if (hDecoder->pce_set)\n    {\n        hDecoder->internal_channel[hDecoder->pce.cpe_channel[tag]] = channels;\n        hDecoder->internal_channel[hDecoder->pce.cpe_channel[tag]+1] = channels+1;\n    } else {\n        hDecoder->internal_channel[channels] = channels;\n        hDecoder->internal_channel[channels+1] = channels+1;\n    }\n\n    hDecoder->fr_channels += 2;\n    hDecoder->fr_ch_ele++;\n}\nvoid raw_data_block(NeAACDecStruct *hDecoder, NeAACDecFrameInfo *hInfo,\n                    bitfile *ld, program_config *pce, drc_info *drc)\n{\n    uint8_t id_syn_ele;\n    uint8_t ele_this_frame = 0;\n\n    hDecoder->fr_channels = 0;\n    hDecoder->fr_ch_ele = 0;\n    hDecoder->first_syn_ele = 25;\n    hDecoder->has_lfe = 0;\n\n#ifdef ERROR_RESILIENCE\n    if (hDecoder->object_type < ER_OBJECT_START)\n    {\n#endif\n        /* Table 4.4.3: raw_data_block() */\n        while ((id_syn_ele = (uint8_t)faad_getbits(ld, LEN_SE_ID\n            DEBUGVAR(1,4,\"NeAACDecDecode(): id_syn_ele\"))) != ID_END)\n        {\n            switch (id_syn_ele) {\n            case ID_SCE:\n                ele_this_frame++;\n                if (hDecoder->first_syn_ele == 25) hDecoder->first_syn_ele = id_syn_ele;\n                decode_sce_lfe(hDecoder, hInfo, ld, id_syn_ele);\n                if (hInfo->error > 0)\n                    return;\n                break;\n            case ID_CPE:\n                ele_this_frame++;\n                if (hDecoder->first_syn_ele == 25) hDecoder->first_syn_ele = id_syn_ele;\n                decode_cpe(hDecoder, hInfo, ld, id_syn_ele);\n                if (hInfo->error > 0)\n                    return;\n                break;\n            case ID_LFE:\n#ifdef DRM\n                hInfo->error = 32;\n#else\n                ele_this_frame++;\n                hDecoder->has_lfe++;\n                decode_sce_lfe(hDecoder, hInfo, ld, id_syn_ele);\n#endif\n                if (hInfo->error > 0)\n                    return;\n                break;\n            case ID_CCE: /* not implemented yet, but skip the bits */\n#ifdef DRM\n                hInfo->error = 32;\n#else\n                ele_this_frame++;\n#ifdef COUPLING_DEC\n                hInfo->error = coupling_channel_element(hDecoder, ld);\n#else\n                hInfo->error = 6;\n#endif\n#endif\n                if (hInfo->error > 0)\n                    return;\n                break;\n            case ID_DSE:\n                ele_this_frame++;\n                data_stream_element(hDecoder, ld);\n                break;\n            case ID_PCE:\n                if (ele_this_frame != 0)\n                {\n                    hInfo->error = 31;\n                    return;\n                }\n                ele_this_frame++;\n                /* 14496-4: 5.6.4.1.2.1.3: */\n                /* program_configuration_element()'s in access units shall be ignored */\n                program_config_element(pce, ld);\n                //if ((hInfo->error = program_config_element(pce, ld)) > 0)\n                //    return;\n                //hDecoder->pce_set = 1;\n                break;\n            case ID_FIL:\n                ele_this_frame++;\n                /* one sbr_info describes a channel_element not a channel! */\n                /* if we encounter SBR data here: error */\n                /* SBR data will be read directly in the SCE/LFE/CPE element */\n                if ((hInfo->error = fill_element(hDecoder, ld, drc\n#ifdef SBR_DEC\n                    , INVALID_SBR_ELEMENT\n#endif\n                    )) > 0)\n                    return;\n                break;\n            }\n            if (ld->error != 0)\n            {\n                hInfo->error = 32;\n                return;\n            }\n        }\n#ifdef ERROR_RESILIENCE\n    } else {\n        /* Table 262: er_raw_data_block() */\n        switch (hDecoder->channelConfiguration)\n        {\n        case 1:\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 2:\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 3:\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            if (hInfo->error > 0)\n                return;\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 4:\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            if (hInfo->error > 0)\n                return;\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 5:\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            if (hInfo->error > 0)\n                return;\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 6:\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            if (hInfo->error > 0)\n                return;\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_LFE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 7: /* 8 channels */\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            if (hInfo->error > 0)\n                return;\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_LFE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        default:\n            hInfo->error = 7;\n            return;\n        }\n#if 0\n        cnt = bits_to_decode() / 8;\n        while (cnt >= 1)\n        {\n            cnt -= extension_payload(cnt);\n        }\n#endif\n    }\n#endif\n\n    /* new in corrigendum 14496-3:2002 */\n#ifdef DRM\n    if (hDecoder->object_type != DRM_ER_LC\n#if 0\n        && !hDecoder->latm_header_present\n#endif\n        )\n#endif\n    {\n        faad_byte_align(ld);\n    }\n\n    return;\n}\nvoid* NeAACDecDecode(NeAACDecHandle hpDecoder,\n                                 NeAACDecFrameInfo *hInfo,\n                                 unsigned char *buffer,\n                                 unsigned long buffer_size)\n{\n    NeAACDecStruct* hDecoder = (NeAACDecStruct*)hpDecoder;\n    return aac_frame_decode(hDecoder, hInfo, buffer, buffer_size, NULL, 0);\n}\nint LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {\n  if (size < 2) return 0;\n  size_t first_part_size = data[0] | (data[1] << 8);\n  data += 2;\n  size -= 2;\n  first_part_size = (first_part_size > size) ? size : first_part_size;\n  size_t second_part_size = size - first_part_size;\n\n  NeAACDecHandle decoder = NeAACDecOpen();\n\n  unsigned char* first_part = (unsigned char *)malloc(first_part_size);\n  memcpy(first_part, data, first_part_size);\n\n  uint64_t sample_rate;\n  unsigned char num_channels;\n  int res =\n      NeAACDecInit(decoder, first_part, first_part_size, &sample_rate, &num_channels);\n  if (res != 0) {\n    NeAACDecClose(decoder);\n    free(first_part);\n    return 0;\n  }\n\n  unsigned char* second_part = (unsigned char *)malloc(second_part_size);\n  memcpy(second_part, data + first_part_size, second_part_size);\n\n  NeAACDecFrameInfo faad_info;\n  NeAACDecDecode(decoder, &faad_info, second_part, second_part_size);\n  NeAACDecClose(decoder);\n  free(first_part);\n  free(second_part);\n\n  return 0;\n}",
    "target": 0,
    "idx": 2058287
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "void\nxmlParseComment(xmlParserCtxtPtr ctxt) {\n    xmlChar *buf = NULL;\n    size_t size = XML_PARSER_BUFFER_SIZE;\n    size_t len = 0;\n    size_t maxLength = (ctxt->options & XML_PARSE_HUGE) ?\n                       XML_MAX_HUGE_LENGTH :\n                       XML_MAX_TEXT_LENGTH;\n    xmlParserInputState state;\n    const xmlChar *in;\n    size_t nbchar = 0;\n    int ccol;\n    int inputid;\n\n    /*\n     * Check that there is a comment right here.\n     */\n    if ((RAW != '<') || (NXT(1) != '!'))\n        return;\n    SKIP(2);\n    if ((RAW != '-') || (NXT(1) != '-'))\n        return;\n    state = ctxt->instate;\n    ctxt->instate = XML_PARSER_COMMENT;\n    inputid = ctxt->input->id;\n    SKIP(2);\n    GROW;\n\n    /*\n     * Accelerated common case where input don't need to be\n     * modified before passing it to the handler.\n     */\n    in = ctxt->input->cur;\n    do {\n\tif (*in == 0xA) {\n\t    do {\n\t\tctxt->input->line++; ctxt->input->col = 1;\n\t\tin++;\n\t    } while (*in == 0xA);\n\t}\nget_more:\n        ccol = ctxt->input->col;\n\twhile (((*in > '-') && (*in <= 0x7F)) ||\n\t       ((*in >= 0x20) && (*in < '-')) ||\n\t       (*in == 0x09)) {\n\t\t    in++;\n\t\t    ccol++;\n\t}\n\tctxt->input->col = ccol;\n\tif (*in == 0xA) {\n\t    do {\n\t\tctxt->input->line++; ctxt->input->col = 1;\n\t\tin++;\n\t    } while (*in == 0xA);\n\t    goto get_more;\n\t}\n\tnbchar = in - ctxt->input->cur;\n\t/*\n\t * save current set of data\n\t */\n\tif (nbchar > 0) {\n            if (buf == NULL) {\n                if ((*in == '-') && (in[1] == '-'))\n                    size = nbchar + 1;\n                else\n                    size = XML_PARSER_BUFFER_SIZE + nbchar;\n                buf = (xmlChar *) xmlMallocAtomic(size);\n                if (buf == NULL) {\n                    xmlErrMemory(ctxt, NULL);\n                    ctxt->instate = state;\n                    return;\n                }\n                len = 0;\n            } else if (len + nbchar + 1 >= size) {\n                xmlChar *new_buf;\n                size  += len + nbchar + XML_PARSER_BUFFER_SIZE;\n                new_buf = (xmlChar *) xmlRealloc(buf, size);\n                if (new_buf == NULL) {\n                    xmlFree (buf);\n                    xmlErrMemory(ctxt, NULL);\n                    ctxt->instate = state;\n                    return;\n                }\n                buf = new_buf;\n            }\n            memcpy(&buf[len], ctxt->input->cur, nbchar);\n            len += nbchar;\n            buf[len] = 0;\n\t}\n        if (len > maxLength) {\n            xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,\n                         \"Comment too big found\", NULL);\n            xmlFree (buf);\n            return;\n        }\n\tctxt->input->cur = in;\n\tif (*in == 0xA) {\n\t    in++;\n\t    ctxt->input->line++; ctxt->input->col = 1;\n\t}\n\tif (*in == 0xD) {\n\t    in++;\n\t    if (*in == 0xA) {\n\t\tctxt->input->cur = in;\n\t\tin++;\n\t\tctxt->input->line++; ctxt->input->col = 1;\n\t\tgoto get_more;\n\t    }\n\t    in--;\n\t}\n\tSHRINK;\n\tGROW;\n        if (ctxt->instate == XML_PARSER_EOF) {\n            xmlFree(buf);\n            return;\n        }\n\tin = ctxt->input->cur;\n\tif (*in == '-') {\n\t    if (in[1] == '-') {\n\t        if (in[2] == '>') {\n\t\t    if (ctxt->input->id != inputid) {\n\t\t\txmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n\t\t\t               \"comment doesn't start and stop in the\"\n                                       \" same entity\\n\");\n\t\t    }\n\t\t    SKIP(3);\n\t\t    if ((ctxt->sax != NULL) && (ctxt->sax->comment != NULL) &&\n\t\t        (!ctxt->disableSAX)) {\n\t\t\tif (buf != NULL)\n\t\t\t    ctxt->sax->comment(ctxt->userData, buf);\n\t\t\telse\n\t\t\t    ctxt->sax->comment(ctxt->userData, BAD_CAST \"\");\n\t\t    }\n\t\t    if (buf != NULL)\n\t\t        xmlFree(buf);\n\t\t    if (ctxt->instate != XML_PARSER_EOF)\n\t\t\tctxt->instate = state;\n\t\t    return;\n\t\t}\n\t\tif (buf != NULL) {\n\t\t    xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,\n\t\t                      \"Double hyphen within comment: \"\n                                      \"<!--%.50s\\n\",\n\t\t\t\t      buf);\n\t\t} else\n\t\t    xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,\n\t\t                      \"Double hyphen within comment\\n\", NULL);\n                if (ctxt->instate == XML_PARSER_EOF) {\n                    xmlFree(buf);\n                    return;\n                }\n\t\tin++;\n\t\tctxt->input->col++;\n\t    }\n\t    in++;\n\t    ctxt->input->col++;\n\t    goto get_more;\n\t}\n    } while (((*in >= 0x20) && (*in <= 0x7F)) || (*in == 0x09) || (*in == 0x0a));\n    xmlParseCommentComplex(ctxt, buf, len, size);\n    ctxt->instate = state;\n    return;\n}\nint\nxmlCopyCharMultiByte(xmlChar *out, int val) {\n    if ((out == NULL) || (val < 0)) return(0);\n    /*\n     * We are supposed to handle UTF8, check it's valid\n     * From rfc2044: encoding of the Unicode values on UTF-8:\n     *\n     * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n     * 0000 0000-0000 007F   0xxxxxxx\n     * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n     * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n     */\n    if  (val >= 0x80) {\n\txmlChar *savedout = out;\n\tint bits;\n\tif (val <   0x800) { *out++= (val >>  6) | 0xC0;  bits=  0; }\n\telse if (val < 0x10000) { *out++= (val >> 12) | 0xE0;  bits=  6;}\n\telse if (val < 0x110000)  { *out++= (val >> 18) | 0xF0;  bits=  12; }\n\telse {\n\t    xmlErrEncodingInt(NULL, XML_ERR_INVALID_CHAR,\n\t\t    \"Internal error, xmlCopyCharMultiByte 0x%X out of bound\\n\",\n\t\t\t      val);\n\t    return(0);\n\t}\n\tfor ( ; bits >= 0; bits-= 6)\n\t    *out++= ((val >> bits) & 0x3F) | 0x80 ;\n\treturn (out - savedout);\n    }\n    *out = val;\n    return 1;\n}\nstatic void\nxmlParseCommentComplex(xmlParserCtxtPtr ctxt, xmlChar *buf,\n                       size_t len, size_t size) {\n    int q, ql;\n    int r, rl;\n    int cur, l;\n    size_t maxLength = (ctxt->options & XML_PARSE_HUGE) ?\n                       XML_MAX_HUGE_LENGTH :\n                       XML_MAX_TEXT_LENGTH;\n    int inputid;\n\n    inputid = ctxt->input->id;\n\n    if (buf == NULL) {\n        len = 0;\n\tsize = XML_PARSER_BUFFER_SIZE;\n\tbuf = (xmlChar *) xmlMallocAtomic(size);\n\tif (buf == NULL) {\n\t    xmlErrMemory(ctxt, NULL);\n\t    return;\n\t}\n    }\n    q = CUR_CHAR(ql);\n    if (q == 0)\n        goto not_terminated;\n    if (!IS_CHAR(q)) {\n        xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,\n                          \"xmlParseComment: invalid xmlChar value %d\\n\",\n\t                  q);\n\txmlFree (buf);\n\treturn;\n    }\n    NEXTL(ql);\n    r = CUR_CHAR(rl);\n    if (r == 0)\n        goto not_terminated;\n    if (!IS_CHAR(r)) {\n        xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,\n                          \"xmlParseComment: invalid xmlChar value %d\\n\",\n\t                  r);\n\txmlFree (buf);\n\treturn;\n    }\n    NEXTL(rl);\n    cur = CUR_CHAR(l);\n    if (cur == 0)\n        goto not_terminated;\n    while (IS_CHAR(cur) && /* checked */\n           ((cur != '>') ||\n\t    (r != '-') || (q != '-'))) {\n\tif ((r == '-') && (q == '-')) {\n\t    xmlFatalErr(ctxt, XML_ERR_HYPHEN_IN_COMMENT, NULL);\n\t}\n\tif (len + 5 >= size) {\n\t    xmlChar *new_buf;\n            size_t new_size;\n\n\t    new_size = size * 2;\n\t    new_buf = (xmlChar *) xmlRealloc(buf, new_size);\n\t    if (new_buf == NULL) {\n\t\txmlFree (buf);\n\t\txmlErrMemory(ctxt, NULL);\n\t\treturn;\n\t    }\n\t    buf = new_buf;\n            size = new_size;\n\t}\n\tCOPY_BUF(ql,buf,len,q);\n        if (len > maxLength) {\n            xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,\n                         \"Comment too big found\", NULL);\n            xmlFree (buf);\n            return;\n        }\n\n\tq = r;\n\tql = rl;\n\tr = cur;\n\trl = l;\n\n\tNEXTL(l);\n\tcur = CUR_CHAR(l);\n\n    }\n    buf[len] = 0;\n    if (ctxt->instate == XML_PARSER_EOF) {\n        xmlFree(buf);\n        return;\n    }\n    if (cur == 0) {\n\txmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,\n\t                     \"Comment not terminated \\n<!--%.50s\\n\", buf);\n    } else if (!IS_CHAR(cur)) {\n        xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,\n                          \"xmlParseComment: invalid xmlChar value %d\\n\",\n\t                  cur);\n    } else {\n\tif (inputid != ctxt->input->id) {\n\t    xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n\t\t           \"Comment doesn't start and stop in the same\"\n                           \" entity\\n\");\n\t}\n        NEXT;\n\tif ((ctxt->sax != NULL) && (ctxt->sax->comment != NULL) &&\n\t    (!ctxt->disableSAX))\n\t    ctxt->sax->comment(ctxt->userData, buf);\n    }\n    xmlFree(buf);\n    return;\nnot_terminated:\n    xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,\n\t\t\t \"Comment not terminated\\n\", NULL);\n    xmlFree(buf);\n    return;\n}\nvoid\nxmlParseMisc(xmlParserCtxtPtr ctxt) {\n    while (ctxt->instate != XML_PARSER_EOF) {\n        SKIP_BLANKS;\n        GROW;\n        if ((RAW == '<') && (NXT(1) == '?')) {\n\t    xmlParsePI(ctxt);\n        } else if (CMP4(CUR_PTR, '<', '!', '-', '-')) {\n\t    xmlParseComment(ctxt);\n        } else {\n            break;\n        }\n    }\n}\nint\nxmlParseDocument(xmlParserCtxtPtr ctxt) {\n    xmlInitParser();\n\n    if ((ctxt == NULL) || (ctxt->input == NULL))\n        return(-1);\n\n    GROW;\n\n    /*\n     * SAX: detecting the level.\n     */\n    xmlDetectSAX2(ctxt);\n\n    /*\n     * SAX: beginning of the document processing.\n     */\n    if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))\n        ctxt->sax->setDocumentLocator(ctxt->userData, &xmlDefaultSAXLocator);\n    if (ctxt->instate == XML_PARSER_EOF)\n\treturn(-1);\n\n    xmlDetectEncoding(ctxt);\n\n    if (CUR == 0) {\n\txmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);\n\treturn(-1);\n    }\n\n    GROW;\n    if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) && (IS_BLANK_CH(NXT(5)))) {\n\n\t/*\n\t * Note that we will switch encoding on the fly.\n\t */\n\txmlParseXMLDecl(ctxt);\n\tif ((ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) ||\n\t    (ctxt->instate == XML_PARSER_EOF)) {\n\t    /*\n\t     * The XML REC instructs us to stop parsing right here\n\t     */\n\t    return(-1);\n\t}\n\tSKIP_BLANKS;\n    } else {\n\tctxt->version = xmlCharStrdup(XML_DEFAULT_VERSION);\n    }\n    if ((ctxt->sax) && (ctxt->sax->startDocument) && (!ctxt->disableSAX))\n        ctxt->sax->startDocument(ctxt->userData);\n    if (ctxt->instate == XML_PARSER_EOF)\n\treturn(-1);\n    if ((ctxt->myDoc != NULL) && (ctxt->input != NULL) &&\n        (ctxt->input->buf != NULL) && (ctxt->input->buf->compressed >= 0)) {\n\tctxt->myDoc->compression = ctxt->input->buf->compressed;\n    }\n\n    /*\n     * The Misc part of the Prolog\n     */\n    xmlParseMisc(ctxt);\n\n    /*\n     * Then possibly doc type declaration(s) and more Misc\n     * (doctypedecl Misc*)?\n     */\n    GROW;\n    if (CMP9(CUR_PTR, '<', '!', 'D', 'O', 'C', 'T', 'Y', 'P', 'E')) {\n\n\tctxt->inSubset = 1;\n\txmlParseDocTypeDecl(ctxt);\n\tif (RAW == '[') {\n\t    ctxt->instate = XML_PARSER_DTD;\n\t    xmlParseInternalSubset(ctxt);\n\t    if (ctxt->instate == XML_PARSER_EOF)\n\t\treturn(-1);\n\t}\n\n\t/*\n\t * Create and update the external subset.\n\t */\n\tctxt->inSubset = 2;\n\tif ((ctxt->sax != NULL) && (ctxt->sax->externalSubset != NULL) &&\n\t    (!ctxt->disableSAX))\n\t    ctxt->sax->externalSubset(ctxt->userData, ctxt->intSubName,\n\t                              ctxt->extSubSystem, ctxt->extSubURI);\n\tif (ctxt->instate == XML_PARSER_EOF)\n\t    return(-1);\n\tctxt->inSubset = 0;\n\n        xmlCleanSpecialAttr(ctxt);\n\n\tctxt->instate = XML_PARSER_PROLOG;\n\txmlParseMisc(ctxt);\n    }\n\n    /*\n     * Time to start parsing the tree itself\n     */\n    GROW;\n    if (RAW != '<') {\n\txmlFatalErrMsg(ctxt, XML_ERR_DOCUMENT_EMPTY,\n\t\t       \"Start tag expected, '<' not found\\n\");\n    } else {\n\tctxt->instate = XML_PARSER_CONTENT;\n\txmlParseElement(ctxt);\n\tctxt->instate = XML_PARSER_EPILOG;\n\n\n\t/*\n\t * The Misc part at the end\n\t */\n\txmlParseMisc(ctxt);\n\n        if (ctxt->input->cur < ctxt->input->end) {\n            if (ctxt->errNo == XML_ERR_OK)\n\t        xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);\n        } else if ((ctxt->input->buf != NULL) &&\n                   (ctxt->input->buf->encoder != NULL) &&\n                   (!xmlBufIsEmpty(ctxt->input->buf->raw))) {\n            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n                           \"Truncated multi-byte sequence at EOF\\n\");\n        }\n\tctxt->instate = XML_PARSER_EOF;\n    }\n\n    /*\n     * SAX: end of the document processing.\n     */\n    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n        ctxt->sax->endDocument(ctxt->userData);\n\n    /*\n     * Remove locally kept entity definitions if the tree was not built\n     */\n    if ((ctxt->myDoc != NULL) &&\n\t(xmlStrEqual(ctxt->myDoc->version, SAX_COMPAT_MODE))) {\n\txmlFreeDoc(ctxt->myDoc);\n\tctxt->myDoc = NULL;\n    }\n\n    if ((ctxt->wellFormed) && (ctxt->myDoc != NULL)) {\n        ctxt->myDoc->properties |= XML_DOC_WELLFORMED;\n\tif (ctxt->valid)\n\t    ctxt->myDoc->properties |= XML_DOC_DTDVALID;\n\tif (ctxt->nsWellFormed)\n\t    ctxt->myDoc->properties |= XML_DOC_NSVALID;\n\tif (ctxt->options & XML_PARSE_OLD10)\n\t    ctxt->myDoc->properties |= XML_DOC_OLD10;\n    }\n    if (! ctxt->wellFormed) {\n\tctxt->valid = 0;\n\treturn(-1);\n    }\n    return(0);\n}\nstatic xmlDocPtr\nxmlDoRead(xmlParserCtxtPtr ctxt, const char *URL, const char *encoding,\n          int options, int reuse)\n{\n    xmlDocPtr ret;\n\n    xmlCtxtUseOptionsInternal(ctxt, options, encoding);\n    if (encoding != NULL) {\n        xmlCharEncodingHandlerPtr hdlr;\n\n        /*\n         * TODO: We should consider to set XML_PARSE_IGNORE_ENC if the\n         * caller provided an encoding. Otherwise, we might switch to\n         * the encoding from the XML declaration which is likely to\n         * break things. Also see xmlSwitchInputEncoding.\n         */\n\thdlr = xmlFindCharEncodingHandler(encoding);\n\tif (hdlr != NULL)\n\t    xmlSwitchToEncoding(ctxt, hdlr);\n    }\n    if ((URL != NULL) && (ctxt->input != NULL) &&\n        (ctxt->input->filename == NULL))\n        ctxt->input->filename = (char *) xmlStrdup((const xmlChar *) URL);\n    xmlParseDocument(ctxt);\n    if ((ctxt->wellFormed) || ctxt->recovery)\n        ret = ctxt->myDoc;\n    else {\n        ret = NULL;\n\tif (ctxt->myDoc != NULL) {\n\t    xmlFreeDoc(ctxt->myDoc);\n\t}\n    }\n    ctxt->myDoc = NULL;\n    if (!reuse) {\n\txmlFreeParserCtxt(ctxt);\n    }\n\n    return (ret);\n}\nxmlDocPtr\nxmlReadMemory(const char *buffer, int size, const char *URL, const char *encoding, int options)\n{\n    xmlParserCtxtPtr ctxt;\n\n    xmlInitParser();\n    ctxt = xmlCreateMemoryParserCtxt(buffer, size);\n    if (ctxt == NULL)\n        return (NULL);\n    return (xmlDoRead(ctxt, URL, encoding, options, 0));\n}\nxmlChar *\nxsltFuzzXslt(const char *data, size_t size) {\n    const char *xsltBuffer, *xsltUrl, *docBuffer, *docUrl;\n    xmlDocPtr xsltDoc = NULL, doc = NULL;\n    xmlDocPtr result = NULL;\n    xmlNodePtr root;\n    xsltStylesheetPtr sheet = NULL;\n    xsltTransformContextPtr ctxt = NULL;\n    xmlChar *ret = NULL;\n    size_t xsltSize, docSize, maxAllocs;\n    int retLen;\n\n    xmlFuzzDataInit(data, size);\n    maxAllocs = xmlFuzzReadInt(4) % (size + 1);\n\n    xmlFuzzReadEntities();\n    xsltBuffer = xmlFuzzMainEntity(&xsltSize);\n    xsltUrl = xmlFuzzMainUrl();\n    docBuffer = xmlFuzzSecondaryEntity(&docSize);\n    docUrl = xmlFuzzSecondaryUrl();\n    if ((xsltBuffer == NULL) || (docBuffer == NULL))\n        goto exit;\n\n    doc = xmlReadMemory(docBuffer, docSize, docUrl, NULL, XSLT_PARSE_OPTIONS);\n    if (doc == NULL)\n        goto exit;\n\n    xsltDoc = xmlReadMemory(xsltBuffer, xsltSize, xsltUrl, NULL,\n                            XSLT_PARSE_OPTIONS);\n    if (xsltDoc == NULL)\n        goto exit;\n    root = xmlDocGetRootElement(xsltDoc);\n    if (root != NULL) {\n        xmlNewNs(root, XSLT_NAMESPACE, BAD_CAST \"x\");\n        xmlNewNs(root, EXSLT_COMMON_NAMESPACE, BAD_CAST \"exsl\");\n        xmlNewNs(root, EXSLT_COMMON_NAMESPACE, BAD_CAST \"exslt\");\n        xmlNewNs(root, EXSLT_CRYPTO_NAMESPACE, BAD_CAST \"crypto\");\n        xmlNewNs(root, EXSLT_DATE_NAMESPACE, BAD_CAST \"date\");\n        xmlNewNs(root, EXSLT_DYNAMIC_NAMESPACE, BAD_CAST \"dyn\");\n        xmlNewNs(root, EXSLT_MATH_NAMESPACE, BAD_CAST \"math\");\n        xmlNewNs(root, EXSLT_SETS_NAMESPACE, BAD_CAST \"set\");\n        xmlNewNs(root, EXSLT_STRINGS_NAMESPACE, BAD_CAST \"str\");\n        xmlNewNs(root, SAXON_NAMESPACE, BAD_CAST \"saxon\");\n    }\n\n    xmlFuzzMemSetLimit(maxAllocs);\n    sheet = xsltNewStylesheet();\n    if (sheet == NULL)\n        goto exit;\n    sheet->xpathCtxt->opLimit = 100000;\n    sheet->xpathCtxt->opCount = 0;\n    if (xsltParseStylesheetUser(sheet, xsltDoc) != 0)\n        goto exit;\n    xsltDoc = NULL;\n\n    root = xmlDocGetRootElement(doc);\n    if (root != NULL) {\n        xmlNewNs(root, BAD_CAST \"a\", BAD_CAST \"a\");\n        xmlNewNs(root, BAD_CAST \"b\", BAD_CAST \"b\");\n        xmlNewNs(root, BAD_CAST \"c\", BAD_CAST \"c\");\n    }\n\n    ctxt = xsltNewTransformContext(sheet, doc);\n    if (ctxt == NULL)\n        goto exit;\n    xsltSetCtxtSecurityPrefs(globalSec, ctxt);\n    ctxt->maxTemplateDepth = 100;\n    ctxt->opLimit = 20000;\n    ctxt->xpathCtxt->opLimit = 100000;\n    ctxt->xpathCtxt->opCount = sheet->xpathCtxt->opCount;\n\n    result = xsltApplyStylesheetUser(sheet, doc, NULL, NULL, NULL, ctxt);\n    if (result != NULL)\n        xsltSaveResultToString(&ret, &retLen, result, sheet);\n\nexit:\n    xmlFuzzMemSetLimit(0);\n    xmlFreeDoc(result);\n    xsltFreeTransformContext(ctxt);\n    xsltFreeStylesheet(sheet);\n    xmlFreeDoc(xsltDoc);\n    xmlFreeDoc(doc);\n    xmlFuzzDataCleanup();\n\n    return ret;\n}\nint\nLLVMFuzzerTestOneInput(const char *data, size_t size) {\n    xmlChar *result = xsltFuzzXslt(data, size);\n    xmlFree(result);\n\n    return 0;\n}",
    "target": 0,
    "idx": 2063124
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "MEM_STATIC size_t\nZSTD_entropyCompressSeqStore_internal(seqStore_t* seqStorePtr,\n                          const ZSTD_entropyCTables_t* prevEntropy,\n                                ZSTD_entropyCTables_t* nextEntropy,\n                          const ZSTD_CCtx_params* cctxParams,\n                                void* dst, size_t dstCapacity,\n                                void* entropyWorkspace, size_t entropyWkspSize,\n                          const int bmi2)\n{\n    const int longOffsets = cctxParams->cParams.windowLog > STREAM_ACCUMULATOR_MIN;\n    ZSTD_strategy const strategy = cctxParams->cParams.strategy;\n    unsigned* count = (unsigned*)entropyWorkspace;\n    FSE_CTable* CTable_LitLength = nextEntropy->fse.litlengthCTable;\n    FSE_CTable* CTable_OffsetBits = nextEntropy->fse.offcodeCTable;\n    FSE_CTable* CTable_MatchLength = nextEntropy->fse.matchlengthCTable;\n    const seqDef* const sequences = seqStorePtr->sequencesStart;\n    const size_t nbSeq = seqStorePtr->sequences - seqStorePtr->sequencesStart;\n    const BYTE* const ofCodeTable = seqStorePtr->ofCode;\n    const BYTE* const llCodeTable = seqStorePtr->llCode;\n    const BYTE* const mlCodeTable = seqStorePtr->mlCode;\n    BYTE* const ostart = (BYTE*)dst;\n    BYTE* const oend = ostart + dstCapacity;\n    BYTE* op = ostart;\n    size_t lastCountSize;\n\n    entropyWorkspace = count + (MaxSeq + 1);\n    entropyWkspSize -= (MaxSeq + 1) * sizeof(*count);\n\n    DEBUGLOG(5, \"ZSTD_entropyCompressSeqStore_internal (nbSeq=%zu, dstCapacity=%zu)\", nbSeq, dstCapacity);\n    ZSTD_STATIC_ASSERT(HUF_WORKSPACE_SIZE >= (1<<MAX(MLFSELog,LLFSELog)));\n    assert(entropyWkspSize >= HUF_WORKSPACE_SIZE);\n\n    /* Compress literals */\n    {   const BYTE* const literals = seqStorePtr->litStart;\n        size_t const numSequences = seqStorePtr->sequences - seqStorePtr->sequencesStart;\n        size_t const numLiterals = seqStorePtr->lit - seqStorePtr->litStart;\n        /* Base suspicion of uncompressibility on ratio of literals to sequences */\n        unsigned const suspectUncompressible = (numSequences == 0) || (numLiterals / numSequences >= SUSPECT_UNCOMPRESSIBLE_LITERAL_RATIO);\n        size_t const litSize = (size_t)(seqStorePtr->lit - literals);\n        size_t const cSize = ZSTD_compressLiterals(\n                                    &prevEntropy->huf, &nextEntropy->huf,\n                                    cctxParams->cParams.strategy,\n                                    ZSTD_literalsCompressionIsDisabled(cctxParams),\n                                    op, dstCapacity,\n                                    literals, litSize,\n                                    entropyWorkspace, entropyWkspSize,\n                                    bmi2, suspectUncompressible);\n        FORWARD_IF_ERROR(cSize, \"ZSTD_compressLiterals failed\");\n        assert(cSize <= dstCapacity);\n        op += cSize;\n    }\n\n    /* Sequences Header */\n    RETURN_ERROR_IF((oend-op) < 3 /*max nbSeq Size*/ + 1 /*seqHead*/,\n                    dstSize_tooSmall, \"Can't fit seq hdr in output buf!\");\n    if (nbSeq < 128) {\n        *op++ = (BYTE)nbSeq;\n    } else if (nbSeq < LONGNBSEQ) {\n        op[0] = (BYTE)((nbSeq>>8) + 0x80);\n        op[1] = (BYTE)nbSeq;\n        op+=2;\n    } else {\n        op[0]=0xFF;\n        MEM_writeLE16(op+1, (U16)(nbSeq - LONGNBSEQ));\n        op+=3;\n    }\n    assert(op <= oend);\n    if (nbSeq==0) {\n        /* Copy the old tables over as if we repeated them */\n        ZSTD_memcpy(&nextEntropy->fse, &prevEntropy->fse, sizeof(prevEntropy->fse));\n        return (size_t)(op - ostart);\n    }\n    {   BYTE* const seqHead = op++;\n        /* build stats for sequences */\n        const ZSTD_symbolEncodingTypeStats_t stats =\n                ZSTD_buildSequencesStatistics(seqStorePtr, nbSeq,\n                                             &prevEntropy->fse, &nextEntropy->fse,\n                                              op, oend,\n                                              strategy, count,\n                                              entropyWorkspace, entropyWkspSize);\n        FORWARD_IF_ERROR(stats.size, \"ZSTD_buildSequencesStatistics failed!\");\n        *seqHead = (BYTE)((stats.LLtype<<6) + (stats.Offtype<<4) + (stats.MLtype<<2));\n        lastCountSize = stats.lastCountSize;\n        op += stats.size;\n    }\n\n    {   size_t const bitstreamSize = ZSTD_encodeSequences(\n                                        op, (size_t)(oend - op),\n                                        CTable_MatchLength, mlCodeTable,\n                                        CTable_OffsetBits, ofCodeTable,\n                                        CTable_LitLength, llCodeTable,\n                                        sequences, nbSeq,\n                                        longOffsets, bmi2);\n        FORWARD_IF_ERROR(bitstreamSize, \"ZSTD_encodeSequences failed\");\n        op += bitstreamSize;\n        assert(op <= oend);\n        /* zstd versions <= 1.3.4 mistakenly report corruption when\n         * FSE_readNCount() receives a buffer < 4 bytes.\n         * Fixed by https://github.com/facebook/zstd/pull/1146.\n         * This can happen when the last set_compressed table present is 2\n         * bytes and the bitstream is only one byte.\n         * In this exceedingly rare case, we will simply emit an uncompressed\n         * block, since it isn't worth optimizing.\n         */\n        if (lastCountSize && (lastCountSize + bitstreamSize) < 4) {\n            /* lastCountSize >= 2 && bitstreamSize > 0 ==> lastCountSize == 3 */\n            assert(lastCountSize + bitstreamSize == 3);\n            DEBUGLOG(5, \"Avoiding bug in zstd decoder in versions <= 1.3.4 by \"\n                        \"emitting an uncompressed block.\");\n            return 0;\n        }\n    }\n\n    DEBUGLOG(5, \"compressed block size : %u\", (unsigned)(op - ostart));\n    return (size_t)(op - ostart);\n}\nMEM_STATIC size_t\nZSTD_entropyCompressSeqStore(seqStore_t* seqStorePtr,\n                       const ZSTD_entropyCTables_t* prevEntropy,\n                             ZSTD_entropyCTables_t* nextEntropy,\n                       const ZSTD_CCtx_params* cctxParams,\n                             void* dst, size_t dstCapacity,\n                             size_t srcSize,\n                             void* entropyWorkspace, size_t entropyWkspSize,\n                             int bmi2)\n{\n    size_t const cSize = ZSTD_entropyCompressSeqStore_internal(\n                            seqStorePtr, prevEntropy, nextEntropy, cctxParams,\n                            dst, dstCapacity,\n                            entropyWorkspace, entropyWkspSize, bmi2);\n    if (cSize == 0) return 0;\n    /* When srcSize <= dstCapacity, there is enough space to write a raw uncompressed block.\n     * Since we ran out of space, block must be not compressible, so fall back to raw uncompressed block.\n     */\n    if ((cSize == ERROR(dstSize_tooSmall)) & (srcSize <= dstCapacity)) {\n        DEBUGLOG(4, \"not enough dstCapacity (%zu) for ZSTD_entropyCompressSeqStore_internal()=> do not compress block\", dstCapacity);\n        return 0;  /* block not compressed */\n    }\n    FORWARD_IF_ERROR(cSize, \"ZSTD_entropyCompressSeqStore_internal failed\");\n\n    /* Check compressibility */\n    {   size_t const maxCSize = srcSize - ZSTD_minGain(srcSize, cctxParams->cParams.strategy);\n        if (cSize >= maxCSize) return 0;  /* block not compressed */\n    }\n    DEBUGLOG(5, \"ZSTD_entropyCompressSeqStore() cSize: %zu\", cSize);\n    return cSize;\n}\nstatic size_t\nZSTD_compressSequences_internal(ZSTD_CCtx* cctx,\n                                void* dst, size_t dstCapacity,\n                          const ZSTD_Sequence* inSeqs, size_t inSeqsSize,\n                          const void* src, size_t srcSize)\n{\n    size_t cSize = 0;\n    size_t remaining = srcSize;\n    ZSTD_sequencePosition seqPos = {0, 0, 0};\n\n    BYTE const* ip = (BYTE const*)src;\n    BYTE* op = (BYTE*)dst;\n    ZSTD_sequenceCopier const sequenceCopier = ZSTD_selectSequenceCopier(cctx->appliedParams.blockDelimiters);\n\n    DEBUGLOG(4, \"ZSTD_compressSequences_internal srcSize: %zu, inSeqsSize: %zu\", srcSize, inSeqsSize);\n    /* Special case: empty frame */\n    if (remaining == 0) {\n        U32 const cBlockHeader24 = 1 /* last block */ + (((U32)bt_raw)<<1);\n        RETURN_ERROR_IF(dstCapacity<4, dstSize_tooSmall, \"No room for empty frame block header\");\n        MEM_writeLE32(op, cBlockHeader24);\n        op += ZSTD_blockHeaderSize;\n        dstCapacity -= ZSTD_blockHeaderSize;\n        cSize += ZSTD_blockHeaderSize;\n    }\n\n    while (remaining) {\n        size_t compressedSeqsSize;\n        size_t cBlockSize;\n        size_t additionalByteAdjustment;\n        size_t blockSize = determine_blockSize(cctx->appliedParams.blockDelimiters,\n                                        cctx->blockSize, remaining,\n                                        inSeqs, inSeqsSize, seqPos);\n        U32 const lastBlock = (blockSize == remaining);\n        FORWARD_IF_ERROR(blockSize, \"Error while trying to determine block size\");\n        assert(blockSize <= remaining);\n        ZSTD_resetSeqStore(&cctx->seqStore);\n        DEBUGLOG(5, \"Working on new block. Blocksize: %zu (total:%zu)\", blockSize, (ip - (const BYTE*)src) + blockSize);\n\n        additionalByteAdjustment = sequenceCopier(cctx, &seqPos, inSeqs, inSeqsSize, ip, blockSize);\n        FORWARD_IF_ERROR(additionalByteAdjustment, \"Bad sequence copy\");\n        blockSize -= additionalByteAdjustment;\n\n        /* If blocks are too small, emit as a nocompress block */\n        if (blockSize < MIN_CBLOCK_SIZE+ZSTD_blockHeaderSize+1) {\n            cBlockSize = ZSTD_noCompressBlock(op, dstCapacity, ip, blockSize, lastBlock);\n            FORWARD_IF_ERROR(cBlockSize, \"Nocompress block failed\");\n            DEBUGLOG(5, \"Block too small, writing out nocompress block: cSize: %zu\", cBlockSize);\n            cSize += cBlockSize;\n            ip += blockSize;\n            op += cBlockSize;\n            remaining -= blockSize;\n            dstCapacity -= cBlockSize;\n            continue;\n        }\n\n        RETURN_ERROR_IF(dstCapacity < ZSTD_blockHeaderSize, dstSize_tooSmall, \"not enough dstCapacity to write a new compressed block\");\n        compressedSeqsSize = ZSTD_entropyCompressSeqStore(&cctx->seqStore,\n                                &cctx->blockState.prevCBlock->entropy, &cctx->blockState.nextCBlock->entropy,\n                                &cctx->appliedParams,\n                                op + ZSTD_blockHeaderSize /* Leave space for block header */, dstCapacity - ZSTD_blockHeaderSize,\n                                blockSize,\n                                cctx->entropyWorkspace, ENTROPY_WORKSPACE_SIZE /* statically allocated in resetCCtx */,\n                                cctx->bmi2);\n        FORWARD_IF_ERROR(compressedSeqsSize, \"Compressing sequences of block failed\");\n        DEBUGLOG(5, \"Compressed sequences size: %zu\", compressedSeqsSize);\n\n        if (!cctx->isFirstBlock &&\n            ZSTD_maybeRLE(&cctx->seqStore) &&\n            ZSTD_isRLE((BYTE const*)src, srcSize)) {\n            /* We don't want to emit our first block as a RLE even if it qualifies because\n            * doing so will cause the decoder (cli only) to throw a \"should consume all input error.\"\n            * This is only an issue for zstd <= v1.4.3\n            */\n            compressedSeqsSize = 1;\n        }\n\n        if (compressedSeqsSize == 0) {\n            /* ZSTD_noCompressBlock writes the block header as well */\n            cBlockSize = ZSTD_noCompressBlock(op, dstCapacity, ip, blockSize, lastBlock);\n            FORWARD_IF_ERROR(cBlockSize, \"ZSTD_noCompressBlock failed\");\n            DEBUGLOG(5, \"Writing out nocompress block, size: %zu\", cBlockSize);\n        } else if (compressedSeqsSize == 1) {\n            cBlockSize = ZSTD_rleCompressBlock(op, dstCapacity, *ip, blockSize, lastBlock);\n            FORWARD_IF_ERROR(cBlockSize, \"ZSTD_rleCompressBlock failed\");\n            DEBUGLOG(5, \"Writing out RLE block, size: %zu\", cBlockSize);\n        } else {\n            U32 cBlockHeader;\n            /* Error checking and repcodes update */\n            ZSTD_blockState_confirmRepcodesAndEntropyTables(&cctx->blockState);\n            if (cctx->blockState.prevCBlock->entropy.fse.offcode_repeatMode == FSE_repeat_valid)\n                cctx->blockState.prevCBlock->entropy.fse.offcode_repeatMode = FSE_repeat_check;\n\n            /* Write block header into beginning of block*/\n            cBlockHeader = lastBlock + (((U32)bt_compressed)<<1) + (U32)(compressedSeqsSize << 3);\n            MEM_writeLE24(op, cBlockHeader);\n            cBlockSize = ZSTD_blockHeaderSize + compressedSeqsSize;\n            DEBUGLOG(5, \"Writing out compressed block, size: %zu\", cBlockSize);\n        }\n\n        cSize += cBlockSize;\n\n        if (lastBlock) {\n            break;\n        } else {\n            ip += blockSize;\n            op += cBlockSize;\n            remaining -= blockSize;\n            dstCapacity -= cBlockSize;\n            cctx->isFirstBlock = 0;\n        }\n        DEBUGLOG(5, \"cSize running total: %zu (remaining dstCapacity=%zu)\", cSize, dstCapacity);\n    }\n\n    DEBUGLOG(4, \"cSize final total: %zu\", cSize);\n    return cSize;\n}\nsize_t ZSTD_compressSequences(ZSTD_CCtx* cctx,\n                              void* dst, size_t dstCapacity,\n                              const ZSTD_Sequence* inSeqs, size_t inSeqsSize,\n                              const void* src, size_t srcSize)\n{\n    BYTE* op = (BYTE*)dst;\n    size_t cSize = 0;\n    size_t compressedBlocksSize = 0;\n    size_t frameHeaderSize = 0;\n\n    /* Transparent initialization stage, same as compressStream2() */\n    DEBUGLOG(4, \"ZSTD_compressSequences (dstCapacity=%zu)\", dstCapacity);\n    assert(cctx != NULL);\n    FORWARD_IF_ERROR(ZSTD_CCtx_init_compressStream2(cctx, ZSTD_e_end, srcSize), \"CCtx initialization failed\");\n    /* Begin writing output, starting with frame header */\n    frameHeaderSize = ZSTD_writeFrameHeader(op, dstCapacity, &cctx->appliedParams, srcSize, cctx->dictID);\n    op += frameHeaderSize;\n    dstCapacity -= frameHeaderSize;\n    cSize += frameHeaderSize;\n    if (cctx->appliedParams.fParams.checksumFlag && srcSize) {\n        XXH64_update(&cctx->xxhState, src, srcSize);\n    }\n    /* cSize includes block header size and compressed sequences size */\n    compressedBlocksSize = ZSTD_compressSequences_internal(cctx,\n                                                           op, dstCapacity,\n                                                           inSeqs, inSeqsSize,\n                                                           src, srcSize);\n    FORWARD_IF_ERROR(compressedBlocksSize, \"Compressing blocks failed!\");\n    cSize += compressedBlocksSize;\n    dstCapacity -= compressedBlocksSize;\n\n    if (cctx->appliedParams.fParams.checksumFlag) {\n        U32 const checksum = (U32) XXH64_digest(&cctx->xxhState);\n        RETURN_ERROR_IF(dstCapacity<4, dstSize_tooSmall, \"no room for checksum\");\n        DEBUGLOG(4, \"Write checksum : %08X\", (unsigned)checksum);\n        MEM_writeLE32((char*)dst + cSize, checksum);\n        cSize += 4;\n    }\n\n    DEBUGLOG(4, \"Final compressed size: %zu\", cSize);\n    return cSize;\n}\nsize_t ZSTD_noCompressLiterals (void* dst, size_t dstCapacity, const void* src, size_t srcSize)\n{\n    BYTE* const ostart = (BYTE*)dst;\n    U32   const flSize = 1 + (srcSize>31) + (srcSize>4095);\n\n    DEBUGLOG(5, \"ZSTD_noCompressLiterals: srcSize=%zu, dstCapacity=%zu\", srcSize, dstCapacity);\n\n    RETURN_ERROR_IF(srcSize + flSize > dstCapacity, dstSize_tooSmall, \"\");\n\n    switch(flSize)\n    {\n        case 1: /* 2 - 1 - 5 */\n            ostart[0] = (BYTE)((U32)set_basic + (srcSize<<3));\n            break;\n        case 2: /* 2 - 2 - 12 */\n            MEM_writeLE16(ostart, (U16)((U32)set_basic + (1<<2) + (srcSize<<4)));\n            break;\n        case 3: /* 2 - 2 - 20 */\n            MEM_writeLE32(ostart, (U32)((U32)set_basic + (3<<2) + (srcSize<<4)));\n            break;\n        default:   /* not necessary : flSize is {1,2,3} */\n            assert(0);\n    }\n\n    ZSTD_memcpy(ostart + flSize, src, srcSize);\n    DEBUGLOG(5, \"Raw (uncompressed) literals: %u -> %u\", (U32)srcSize, (U32)(srcSize + flSize));\n    return srcSize + flSize;\n}\nsize_t ZSTD_compressLiterals (ZSTD_hufCTables_t const* prevHuf,\n                              ZSTD_hufCTables_t* nextHuf,\n                              ZSTD_strategy strategy, int disableLiteralCompression,\n                              void* dst, size_t dstCapacity,\n                        const void* src, size_t srcSize,\n                              void* entropyWorkspace, size_t entropyWorkspaceSize,\n                        const int bmi2,\n                        unsigned suspectUncompressible)\n{\n    size_t const minGain = ZSTD_minGain(srcSize, strategy);\n    size_t const lhSize = 3 + (srcSize >= 1 KB) + (srcSize >= 16 KB);\n    BYTE*  const ostart = (BYTE*)dst;\n    U32 singleStream = srcSize < 256;\n    symbolEncodingType_e hType = set_compressed;\n    size_t cLitSize;\n\n    DEBUGLOG(5,\"ZSTD_compressLiterals (disableLiteralCompression=%i, srcSize=%u, dstCapacity=%zu)\",\n                disableLiteralCompression, (U32)srcSize, dstCapacity);\n\n    DEBUGLOG(6, \"Completed literals listing (%zu bytes)\", showHexa(src, srcSize));\n\n    /* Prepare nextEntropy assuming reusing the existing table */\n    ZSTD_memcpy(nextHuf, prevHuf, sizeof(*prevHuf));\n\n    if (disableLiteralCompression)\n        return ZSTD_noCompressLiterals(dst, dstCapacity, src, srcSize);\n\n    /* small ? don't even attempt compression (speed opt) */\n#   define COMPRESS_LITERALS_SIZE_MIN 63\n    {   size_t const minLitSize = (prevHuf->repeatMode == HUF_repeat_valid) ? 6 : COMPRESS_LITERALS_SIZE_MIN;\n        if (srcSize <= minLitSize) return ZSTD_noCompressLiterals(dst, dstCapacity, src, srcSize);\n    }\n\n    RETURN_ERROR_IF(dstCapacity < lhSize+1, dstSize_tooSmall, \"not enough space for compression\");\n    {   HUF_repeat repeat = prevHuf->repeatMode;\n        int const preferRepeat = (strategy < ZSTD_lazy) ? srcSize <= 1024 : 0;\n        typedef size_t (*huf_compress_f)(void*, size_t, const void*, size_t, unsigned, unsigned, void*, size_t, HUF_CElt*, HUF_repeat*, int, int, unsigned);\n        huf_compress_f huf_compress;\n        if (repeat == HUF_repeat_valid && lhSize == 3) singleStream = 1;\n        huf_compress = singleStream ? HUF_compress1X_repeat : HUF_compress4X_repeat;\n        cLitSize = huf_compress(ostart+lhSize, dstCapacity-lhSize,\n                                src, srcSize,\n                                HUF_SYMBOLVALUE_MAX, LitHufLog,\n                                entropyWorkspace, entropyWorkspaceSize,\n                                (HUF_CElt*)nextHuf->CTable,\n                                &repeat, preferRepeat,\n                                bmi2, suspectUncompressible);\n        if (repeat != HUF_repeat_none) {\n            /* reused the existing table */\n            DEBUGLOG(5, \"Reusing previous huffman table\");\n            hType = set_repeat;\n        }\n    }\n\n    if ((cLitSize==0) || (cLitSize >= srcSize - minGain) || ERR_isError(cLitSize)) {\n        ZSTD_memcpy(nextHuf, prevHuf, sizeof(*prevHuf));\n        return ZSTD_noCompressLiterals(dst, dstCapacity, src, srcSize);\n    }\n    if (cLitSize==1) {\n        ZSTD_memcpy(nextHuf, prevHuf, sizeof(*prevHuf));\n        return ZSTD_compressRleLiteralsBlock(dst, dstCapacity, src, srcSize);\n    }\n\n    if (hType == set_compressed) {\n        /* using a newly constructed table */\n        nextHuf->repeatMode = HUF_repeat_check;\n    }\n\n    /* Build header */\n    switch(lhSize)\n    {\n    case 3: /* 2 - 2 - 10 - 10 */\n        {   U32 const lhc = hType + ((U32)(!singleStream) << 2) + ((U32)srcSize<<4) + ((U32)cLitSize<<14);\n            MEM_writeLE24(ostart, lhc);\n            break;\n        }\n    case 4: /* 2 - 2 - 14 - 14 */\n        {   U32 const lhc = hType + (2 << 2) + ((U32)srcSize<<4) + ((U32)cLitSize<<18);\n            MEM_writeLE32(ostart, lhc);\n            break;\n        }\n    case 5: /* 2 - 2 - 18 - 18 */\n        {   U32 const lhc = hType + (3 << 2) + ((U32)srcSize<<4) + ((U32)cLitSize<<22);\n            MEM_writeLE32(ostart, lhc);\n            ostart[4] = (BYTE)(cLitSize >> 10);\n            break;\n        }\n    default:  /* not possible : lhSize is {3,4,5} */\n        assert(0);\n    }\n    DEBUGLOG(5, \"Compressed literals: %u -> %u\", (U32)srcSize, (U32)(lhSize+cLitSize));\n    return lhSize+cLitSize;\n}\nsize_t ZSTD_noCompressLiterals (void* dst, size_t dstCapacity, const void* src, size_t srcSize)\n{\n    BYTE* const ostart = (BYTE*)dst;\n    U32   const flSize = 1 + (srcSize>31) + (srcSize>4095);\n\n    DEBUGLOG(5, \"ZSTD_noCompressLiterals: srcSize=%zu, dstCapacity=%zu\", srcSize, dstCapacity);\n\n    RETURN_ERROR_IF(srcSize + flSize > dstCapacity, dstSize_tooSmall, \"\");\n\n    switch(flSize)\n    {\n        case 1: /* 2 - 1 - 5 */\n            ostart[0] = (BYTE)((U32)set_basic + (srcSize<<3));\n            break;\n        case 2: /* 2 - 2 - 12 */\n            MEM_writeLE16(ostart, (U16)((U32)set_basic + (1<<2) + (srcSize<<4)));\n            break;\n        case 3: /* 2 - 2 - 20 */\n            MEM_writeLE32(ostart, (U32)((U32)set_basic + (3<<2) + (srcSize<<4)));\n            break;\n        default:   /* not necessary : flSize is {1,2,3} */\n            assert(0);\n    }\n\n    ZSTD_memcpy(ostart + flSize, src, srcSize);\n    DEBUGLOG(5, \"Raw (uncompressed) literals: %u -> %u\", (U32)srcSize, (U32)(srcSize + flSize));\n    return srcSize + flSize;\n}\nsize_t ZSTD_compressLiterals (ZSTD_hufCTables_t const* prevHuf,\n                              ZSTD_hufCTables_t* nextHuf,\n                              ZSTD_strategy strategy, int disableLiteralCompression,\n                              void* dst, size_t dstCapacity,\n                        const void* src, size_t srcSize,\n                              void* entropyWorkspace, size_t entropyWorkspaceSize,\n                        const int bmi2,\n                        unsigned suspectUncompressible)\n{\n    size_t const minGain = ZSTD_minGain(srcSize, strategy);\n    size_t const lhSize = 3 + (srcSize >= 1 KB) + (srcSize >= 16 KB);\n    BYTE*  const ostart = (BYTE*)dst;\n    U32 singleStream = srcSize < 256;\n    symbolEncodingType_e hType = set_compressed;\n    size_t cLitSize;\n\n    DEBUGLOG(5,\"ZSTD_compressLiterals (disableLiteralCompression=%i, srcSize=%u, dstCapacity=%zu)\",\n                disableLiteralCompression, (U32)srcSize, dstCapacity);\n\n    DEBUGLOG(6, \"Completed literals listing (%zu bytes)\", showHexa(src, srcSize));\n\n    /* Prepare nextEntropy assuming reusing the existing table */\n    ZSTD_memcpy(nextHuf, prevHuf, sizeof(*prevHuf));\n\n    if (disableLiteralCompression)\n        return ZSTD_noCompressLiterals(dst, dstCapacity, src, srcSize);\n\n    /* small ? don't even attempt compression (speed opt) */\n#   define COMPRESS_LITERALS_SIZE_MIN 63\n    {   size_t const minLitSize = (prevHuf->repeatMode == HUF_repeat_valid) ? 6 : COMPRESS_LITERALS_SIZE_MIN;\n        if (srcSize <= minLitSize) return ZSTD_noCompressLiterals(dst, dstCapacity, src, srcSize);\n    }\n\n    RETURN_ERROR_IF(dstCapacity < lhSize+1, dstSize_tooSmall, \"not enough space for compression\");\n    {   HUF_repeat repeat = prevHuf->repeatMode;\n        int const preferRepeat = (strategy < ZSTD_lazy) ? srcSize <= 1024 : 0;\n        typedef size_t (*huf_compress_f)(void*, size_t, const void*, size_t, unsigned, unsigned, void*, size_t, HUF_CElt*, HUF_repeat*, int, int, unsigned);\n        huf_compress_f huf_compress;\n        if (repeat == HUF_repeat_valid && lhSize == 3) singleStream = 1;\n        huf_compress = singleStream ? HUF_compress1X_repeat : HUF_compress4X_repeat;\n        cLitSize = huf_compress(ostart+lhSize, dstCapacity-lhSize,\n                                src, srcSize,\n                                HUF_SYMBOLVALUE_MAX, LitHufLog,\n                                entropyWorkspace, entropyWorkspaceSize,\n                                (HUF_CElt*)nextHuf->CTable,\n                                &repeat, preferRepeat,\n                                bmi2, suspectUncompressible);\n        if (repeat != HUF_repeat_none) {\n            /* reused the existing table */\n            DEBUGLOG(5, \"Reusing previous huffman table\");\n            hType = set_repeat;\n        }\n    }\n\n    if ((cLitSize==0) || (cLitSize >= srcSize - minGain) || ERR_isError(cLitSize)) {\n        ZSTD_memcpy(nextHuf, prevHuf, sizeof(*prevHuf));\n        return ZSTD_noCompressLiterals(dst, dstCapacity, src, srcSize);\n    }\n    if (cLitSize==1) {\n        ZSTD_memcpy(nextHuf, prevHuf, sizeof(*prevHuf));\n        return ZSTD_compressRleLiteralsBlock(dst, dstCapacity, src, srcSize);\n    }\n\n    if (hType == set_compressed) {\n        /* using a newly constructed table */\n        nextHuf->repeatMode = HUF_repeat_check;\n    }\n\n    /* Build header */\n    switch(lhSize)\n    {\n    case 3: /* 2 - 2 - 10 - 10 */\n        {   U32 const lhc = hType + ((U32)(!singleStream) << 2) + ((U32)srcSize<<4) + ((U32)cLitSize<<14);\n            MEM_writeLE24(ostart, lhc);\n            break;\n        }\n    case 4: /* 2 - 2 - 14 - 14 */\n        {   U32 const lhc = hType + (2 << 2) + ((U32)srcSize<<4) + ((U32)cLitSize<<18);\n            MEM_writeLE32(ostart, lhc);\n            break;\n        }\n    case 5: /* 2 - 2 - 18 - 18 */\n        {   U32 const lhc = hType + (3 << 2) + ((U32)srcSize<<4) + ((U32)cLitSize<<22);\n            MEM_writeLE32(ostart, lhc);\n            ostart[4] = (BYTE)(cLitSize >> 10);\n            break;\n        }\n    default:  /* not possible : lhSize is {3,4,5} */\n        assert(0);\n    }\n    DEBUGLOG(5, \"Compressed literals: %u -> %u\", (U32)srcSize, (U32)(lhSize+cLitSize));\n    return lhSize+cLitSize;\n}\nMEM_STATIC size_t\nZSTD_entropyCompressSeqStore_internal(seqStore_t* seqStorePtr,\n                          const ZSTD_entropyCTables_t* prevEntropy,\n                                ZSTD_entropyCTables_t* nextEntropy,\n                          const ZSTD_CCtx_params* cctxParams,\n                                void* dst, size_t dstCapacity,\n                                void* entropyWorkspace, size_t entropyWkspSize,\n                          const int bmi2)\n{\n    const int longOffsets = cctxParams->cParams.windowLog > STREAM_ACCUMULATOR_MIN;\n    ZSTD_strategy const strategy = cctxParams->cParams.strategy;\n    unsigned* count = (unsigned*)entropyWorkspace;\n    FSE_CTable* CTable_LitLength = nextEntropy->fse.litlengthCTable;\n    FSE_CTable* CTable_OffsetBits = nextEntropy->fse.offcodeCTable;\n    FSE_CTable* CTable_MatchLength = nextEntropy->fse.matchlengthCTable;\n    const seqDef* const sequences = seqStorePtr->sequencesStart;\n    const size_t nbSeq = seqStorePtr->sequences - seqStorePtr->sequencesStart;\n    const BYTE* const ofCodeTable = seqStorePtr->ofCode;\n    const BYTE* const llCodeTable = seqStorePtr->llCode;\n    const BYTE* const mlCodeTable = seqStorePtr->mlCode;\n    BYTE* const ostart = (BYTE*)dst;\n    BYTE* const oend = ostart + dstCapacity;\n    BYTE* op = ostart;\n    size_t lastCountSize;\n\n    entropyWorkspace = count + (MaxSeq + 1);\n    entropyWkspSize -= (MaxSeq + 1) * sizeof(*count);\n\n    DEBUGLOG(5, \"ZSTD_entropyCompressSeqStore_internal (nbSeq=%zu, dstCapacity=%zu)\", nbSeq, dstCapacity);\n    ZSTD_STATIC_ASSERT(HUF_WORKSPACE_SIZE >= (1<<MAX(MLFSELog,LLFSELog)));\n    assert(entropyWkspSize >= HUF_WORKSPACE_SIZE);\n\n    /* Compress literals */\n    {   const BYTE* const literals = seqStorePtr->litStart;\n        size_t const numSequences = seqStorePtr->sequences - seqStorePtr->sequencesStart;\n        size_t const numLiterals = seqStorePtr->lit - seqStorePtr->litStart;\n        /* Base suspicion of uncompressibility on ratio of literals to sequences */\n        unsigned const suspectUncompressible = (numSequences == 0) || (numLiterals / numSequences >= SUSPECT_UNCOMPRESSIBLE_LITERAL_RATIO);\n        size_t const litSize = (size_t)(seqStorePtr->lit - literals);\n        size_t const cSize = ZSTD_compressLiterals(\n                                    &prevEntropy->huf, &nextEntropy->huf,\n                                    cctxParams->cParams.strategy,\n                                    ZSTD_literalsCompressionIsDisabled(cctxParams),\n                                    op, dstCapacity,\n                                    literals, litSize,\n                                    entropyWorkspace, entropyWkspSize,\n                                    bmi2, suspectUncompressible);\n        FORWARD_IF_ERROR(cSize, \"ZSTD_compressLiterals failed\");\n        assert(cSize <= dstCapacity);\n        op += cSize;\n    }\n\n    /* Sequences Header */\n    RETURN_ERROR_IF((oend-op) < 3 /*max nbSeq Size*/ + 1 /*seqHead*/,\n                    dstSize_tooSmall, \"Can't fit seq hdr in output buf!\");\n    if (nbSeq < 128) {\n        *op++ = (BYTE)nbSeq;\n    } else if (nbSeq < LONGNBSEQ) {\n        op[0] = (BYTE)((nbSeq>>8) + 0x80);\n        op[1] = (BYTE)nbSeq;\n        op+=2;\n    } else {\n        op[0]=0xFF;\n        MEM_writeLE16(op+1, (U16)(nbSeq - LONGNBSEQ));\n        op+=3;\n    }\n    assert(op <= oend);\n    if (nbSeq==0) {\n        /* Copy the old tables over as if we repeated them */\n        ZSTD_memcpy(&nextEntropy->fse, &prevEntropy->fse, sizeof(prevEntropy->fse));\n        return (size_t)(op - ostart);\n    }\n    {   BYTE* const seqHead = op++;\n        /* build stats for sequences */\n        const ZSTD_symbolEncodingTypeStats_t stats =\n                ZSTD_buildSequencesStatistics(seqStorePtr, nbSeq,\n                                             &prevEntropy->fse, &nextEntropy->fse,\n                                              op, oend,\n                                              strategy, count,\n                                              entropyWorkspace, entropyWkspSize);\n        FORWARD_IF_ERROR(stats.size, \"ZSTD_buildSequencesStatistics failed!\");\n        *seqHead = (BYTE)((stats.LLtype<<6) + (stats.Offtype<<4) + (stats.MLtype<<2));\n        lastCountSize = stats.lastCountSize;\n        op += stats.size;\n    }\n\n    {   size_t const bitstreamSize = ZSTD_encodeSequences(\n                                        op, (size_t)(oend - op),\n                                        CTable_MatchLength, mlCodeTable,\n                                        CTable_OffsetBits, ofCodeTable,\n                                        CTable_LitLength, llCodeTable,\n                                        sequences, nbSeq,\n                                        longOffsets, bmi2);\n        FORWARD_IF_ERROR(bitstreamSize, \"ZSTD_encodeSequences failed\");\n        op += bitstreamSize;\n        assert(op <= oend);\n        /* zstd versions <= 1.3.4 mistakenly report corruption when\n         * FSE_readNCount() receives a buffer < 4 bytes.\n         * Fixed by https://github.com/facebook/zstd/pull/1146.\n         * This can happen when the last set_compressed table present is 2\n         * bytes and the bitstream is only one byte.\n         * In this exceedingly rare case, we will simply emit an uncompressed\n         * block, since it isn't worth optimizing.\n         */\n        if (lastCountSize && (lastCountSize + bitstreamSize) < 4) {\n            /* lastCountSize >= 2 && bitstreamSize > 0 ==> lastCountSize == 3 */\n            assert(lastCountSize + bitstreamSize == 3);\n            DEBUGLOG(5, \"Avoiding bug in zstd decoder in versions <= 1.3.4 by \"\n                        \"emitting an uncompressed block.\");\n            return 0;\n        }\n    }\n\n    DEBUGLOG(5, \"compressed block size : %u\", (unsigned)(op - ostart));\n    return (size_t)(op - ostart);\n}\nMEM_STATIC size_t\nZSTD_entropyCompressSeqStore(seqStore_t* seqStorePtr,\n                       const ZSTD_entropyCTables_t* prevEntropy,\n                             ZSTD_entropyCTables_t* nextEntropy,\n                       const ZSTD_CCtx_params* cctxParams,\n                             void* dst, size_t dstCapacity,\n                             size_t srcSize,\n                             void* entropyWorkspace, size_t entropyWkspSize,\n                             int bmi2)\n{\n    size_t const cSize = ZSTD_entropyCompressSeqStore_internal(\n                            seqStorePtr, prevEntropy, nextEntropy, cctxParams,\n                            dst, dstCapacity,\n                            entropyWorkspace, entropyWkspSize, bmi2);\n    if (cSize == 0) return 0;\n    /* When srcSize <= dstCapacity, there is enough space to write a raw uncompressed block.\n     * Since we ran out of space, block must be not compressible, so fall back to raw uncompressed block.\n     */\n    if ((cSize == ERROR(dstSize_tooSmall)) & (srcSize <= dstCapacity)) {\n        DEBUGLOG(4, \"not enough dstCapacity (%zu) for ZSTD_entropyCompressSeqStore_internal()=> do not compress block\", dstCapacity);\n        return 0;  /* block not compressed */\n    }\n    FORWARD_IF_ERROR(cSize, \"ZSTD_entropyCompressSeqStore_internal failed\");\n\n    /* Check compressibility */\n    {   size_t const maxCSize = srcSize - ZSTD_minGain(srcSize, cctxParams->cParams.strategy);\n        if (cSize >= maxCSize) return 0;  /* block not compressed */\n    }\n    DEBUGLOG(5, \"ZSTD_entropyCompressSeqStore() cSize: %zu\", cSize);\n    return cSize;\n}\nstatic size_t\nZSTD_compressSequences_internal(ZSTD_CCtx* cctx,\n                                void* dst, size_t dstCapacity,\n                          const ZSTD_Sequence* inSeqs, size_t inSeqsSize,\n                          const void* src, size_t srcSize)\n{\n    size_t cSize = 0;\n    size_t remaining = srcSize;\n    ZSTD_sequencePosition seqPos = {0, 0, 0};\n\n    BYTE const* ip = (BYTE const*)src;\n    BYTE* op = (BYTE*)dst;\n    ZSTD_sequenceCopier const sequenceCopier = ZSTD_selectSequenceCopier(cctx->appliedParams.blockDelimiters);\n\n    DEBUGLOG(4, \"ZSTD_compressSequences_internal srcSize: %zu, inSeqsSize: %zu\", srcSize, inSeqsSize);\n    /* Special case: empty frame */\n    if (remaining == 0) {\n        U32 const cBlockHeader24 = 1 /* last block */ + (((U32)bt_raw)<<1);\n        RETURN_ERROR_IF(dstCapacity<4, dstSize_tooSmall, \"No room for empty frame block header\");\n        MEM_writeLE32(op, cBlockHeader24);\n        op += ZSTD_blockHeaderSize;\n        dstCapacity -= ZSTD_blockHeaderSize;\n        cSize += ZSTD_blockHeaderSize;\n    }\n\n    while (remaining) {\n        size_t compressedSeqsSize;\n        size_t cBlockSize;\n        size_t additionalByteAdjustment;\n        size_t blockSize = determine_blockSize(cctx->appliedParams.blockDelimiters,\n                                        cctx->blockSize, remaining,\n                                        inSeqs, inSeqsSize, seqPos);\n        U32 const lastBlock = (blockSize == remaining);\n        FORWARD_IF_ERROR(blockSize, \"Error while trying to determine block size\");\n        assert(blockSize <= remaining);\n        ZSTD_resetSeqStore(&cctx->seqStore);\n        DEBUGLOG(5, \"Working on new block. Blocksize: %zu (total:%zu)\", blockSize, (ip - (const BYTE*)src) + blockSize);\n\n        additionalByteAdjustment = sequenceCopier(cctx, &seqPos, inSeqs, inSeqsSize, ip, blockSize);\n        FORWARD_IF_ERROR(additionalByteAdjustment, \"Bad sequence copy\");\n        blockSize -= additionalByteAdjustment;\n\n        /* If blocks are too small, emit as a nocompress block */\n        if (blockSize < MIN_CBLOCK_SIZE+ZSTD_blockHeaderSize+1) {\n            cBlockSize = ZSTD_noCompressBlock(op, dstCapacity, ip, blockSize, lastBlock);\n            FORWARD_IF_ERROR(cBlockSize, \"Nocompress block failed\");\n            DEBUGLOG(5, \"Block too small, writing out nocompress block: cSize: %zu\", cBlockSize);\n            cSize += cBlockSize;\n            ip += blockSize;\n            op += cBlockSize;\n            remaining -= blockSize;\n            dstCapacity -= cBlockSize;\n            continue;\n        }\n\n        RETURN_ERROR_IF(dstCapacity < ZSTD_blockHeaderSize, dstSize_tooSmall, \"not enough dstCapacity to write a new compressed block\");\n        compressedSeqsSize = ZSTD_entropyCompressSeqStore(&cctx->seqStore,\n                                &cctx->blockState.prevCBlock->entropy, &cctx->blockState.nextCBlock->entropy,\n                                &cctx->appliedParams,\n                                op + ZSTD_blockHeaderSize /* Leave space for block header */, dstCapacity - ZSTD_blockHeaderSize,\n                                blockSize,\n                                cctx->entropyWorkspace, ENTROPY_WORKSPACE_SIZE /* statically allocated in resetCCtx */,\n                                cctx->bmi2);\n        FORWARD_IF_ERROR(compressedSeqsSize, \"Compressing sequences of block failed\");\n        DEBUGLOG(5, \"Compressed sequences size: %zu\", compressedSeqsSize);\n\n        if (!cctx->isFirstBlock &&\n            ZSTD_maybeRLE(&cctx->seqStore) &&\n            ZSTD_isRLE((BYTE const*)src, srcSize)) {\n            /* We don't want to emit our first block as a RLE even if it qualifies because\n            * doing so will cause the decoder (cli only) to throw a \"should consume all input error.\"\n            * This is only an issue for zstd <= v1.4.3\n            */\n            compressedSeqsSize = 1;\n        }\n\n        if (compressedSeqsSize == 0) {\n            /* ZSTD_noCompressBlock writes the block header as well */\n            cBlockSize = ZSTD_noCompressBlock(op, dstCapacity, ip, blockSize, lastBlock);\n            FORWARD_IF_ERROR(cBlockSize, \"ZSTD_noCompressBlock failed\");\n            DEBUGLOG(5, \"Writing out nocompress block, size: %zu\", cBlockSize);\n        } else if (compressedSeqsSize == 1) {\n            cBlockSize = ZSTD_rleCompressBlock(op, dstCapacity, *ip, blockSize, lastBlock);\n            FORWARD_IF_ERROR(cBlockSize, \"ZSTD_rleCompressBlock failed\");\n            DEBUGLOG(5, \"Writing out RLE block, size: %zu\", cBlockSize);\n        } else {\n            U32 cBlockHeader;\n            /* Error checking and repcodes update */\n            ZSTD_blockState_confirmRepcodesAndEntropyTables(&cctx->blockState);\n            if (cctx->blockState.prevCBlock->entropy.fse.offcode_repeatMode == FSE_repeat_valid)\n                cctx->blockState.prevCBlock->entropy.fse.offcode_repeatMode = FSE_repeat_check;\n\n            /* Write block header into beginning of block*/\n            cBlockHeader = lastBlock + (((U32)bt_compressed)<<1) + (U32)(compressedSeqsSize << 3);\n            MEM_writeLE24(op, cBlockHeader);\n            cBlockSize = ZSTD_blockHeaderSize + compressedSeqsSize;\n            DEBUGLOG(5, \"Writing out compressed block, size: %zu\", cBlockSize);\n        }\n\n        cSize += cBlockSize;\n\n        if (lastBlock) {\n            break;\n        } else {\n            ip += blockSize;\n            op += cBlockSize;\n            remaining -= blockSize;\n            dstCapacity -= cBlockSize;\n            cctx->isFirstBlock = 0;\n        }\n        DEBUGLOG(5, \"cSize running total: %zu (remaining dstCapacity=%zu)\", cSize, dstCapacity);\n    }\n\n    DEBUGLOG(4, \"cSize final total: %zu\", cSize);\n    return cSize;\n}\nsize_t ZSTD_compressSequences(ZSTD_CCtx* cctx,\n                              void* dst, size_t dstCapacity,\n                              const ZSTD_Sequence* inSeqs, size_t inSeqsSize,\n                              const void* src, size_t srcSize)\n{\n    BYTE* op = (BYTE*)dst;\n    size_t cSize = 0;\n    size_t compressedBlocksSize = 0;\n    size_t frameHeaderSize = 0;\n\n    /* Transparent initialization stage, same as compressStream2() */\n    DEBUGLOG(4, \"ZSTD_compressSequences (dstCapacity=%zu)\", dstCapacity);\n    assert(cctx != NULL);\n    FORWARD_IF_ERROR(ZSTD_CCtx_init_compressStream2(cctx, ZSTD_e_end, srcSize), \"CCtx initialization failed\");\n    /* Begin writing output, starting with frame header */\n    frameHeaderSize = ZSTD_writeFrameHeader(op, dstCapacity, &cctx->appliedParams, srcSize, cctx->dictID);\n    op += frameHeaderSize;\n    dstCapacity -= frameHeaderSize;\n    cSize += frameHeaderSize;\n    if (cctx->appliedParams.fParams.checksumFlag && srcSize) {\n        XXH64_update(&cctx->xxhState, src, srcSize);\n    }\n    /* cSize includes block header size and compressed sequences size */\n    compressedBlocksSize = ZSTD_compressSequences_internal(cctx,\n                                                           op, dstCapacity,\n                                                           inSeqs, inSeqsSize,\n                                                           src, srcSize);\n    FORWARD_IF_ERROR(compressedBlocksSize, \"Compressing blocks failed!\");\n    cSize += compressedBlocksSize;\n    dstCapacity -= compressedBlocksSize;\n\n    if (cctx->appliedParams.fParams.checksumFlag) {\n        U32 const checksum = (U32) XXH64_digest(&cctx->xxhState);\n        RETURN_ERROR_IF(dstCapacity<4, dstSize_tooSmall, \"no room for checksum\");\n        DEBUGLOG(4, \"Write checksum : %08X\", (unsigned)checksum);\n        MEM_writeLE32((char*)dst + cSize, checksum);\n        cSize += 4;\n    }\n\n    DEBUGLOG(4, \"Final compressed size: %zu\", cSize);\n    return cSize;\n}\nstatic size_t roundTripTest(void* result, size_t resultCapacity,\n                            void* compressed, size_t compressedCapacity,\n                            const void* src, size_t srcSize,\n                            const void* dict, size_t dictSize,\n                            const ZSTD_Sequence* seqs, size_t seqSize,\n                            int wLog, int cLevel, unsigned hasDict,\n                            ZSTD_sequenceFormat_e mode)\n{\n    size_t cSize;\n    size_t dSize;\n\n    ZSTD_CCtx_reset(cctx, ZSTD_reset_session_and_parameters);\n    ZSTD_CCtx_setParameter(cctx, ZSTD_c_nbWorkers, 0);\n    ZSTD_CCtx_setParameter(cctx, ZSTD_c_compressionLevel, cLevel);\n    ZSTD_CCtx_setParameter(cctx, ZSTD_c_windowLog, wLog);\n    ZSTD_CCtx_setParameter(cctx, ZSTD_c_minMatch, ZSTD_MINMATCH_MIN);\n    ZSTD_CCtx_setParameter(cctx, ZSTD_c_validateSequences, 1);\n    ZSTD_CCtx_setParameter(cctx, ZSTD_c_blockDelimiters, mode);\n    if (hasDict) {\n        FUZZ_ZASSERT(ZSTD_CCtx_loadDictionary(cctx, dict, dictSize));\n        FUZZ_ZASSERT(ZSTD_DCtx_loadDictionary(dctx, dict, dictSize));\n    }\n\n    cSize = ZSTD_compressSequences(cctx, compressed, compressedCapacity,\n                                   seqs, seqSize,\n                                   src, srcSize);\n    if ( (ZSTD_getErrorCode(cSize) == ZSTD_error_dstSize_tooSmall)\n      && (mode == ZSTD_sf_explicitBlockDelimiters) ) {\n        /* Valid scenario : in explicit delimiter mode,\n         * it might be possible for the compressed size to outgrow dstCapacity.\n         * In which case, it's still a valid fuzzer scenario,\n         * but no roundtrip shall be possible */\n        return 0;\n    }\n    /* round-trip */\n    FUZZ_ZASSERT(cSize);\n    dSize = ZSTD_decompressDCtx(dctx, result, resultCapacity, compressed, cSize);\n    FUZZ_ZASSERT(dSize);\n    FUZZ_ASSERT_MSG(dSize == srcSize, \"Incorrect regenerated size\");\n    FUZZ_ASSERT_MSG(!FUZZ_memcmp(src, result, srcSize), \"Corruption!\");\n    return dSize;\n}\nint LLVMFuzzerTestOneInput(const uint8_t* src, size_t size)\n{\n    void* rBuf;\n    size_t rBufSize;\n    void* cBuf;\n    size_t cBufSize;\n    size_t generatedSrcSize;\n    size_t nbSequences;\n    void* dictBuffer = NULL;\n    size_t dictSize = 0;\n    unsigned hasDict;\n    unsigned wLog;\n    int cLevel;\n    ZSTD_sequenceFormat_e mode;\n\n    FUZZ_dataProducer_t* const producer = FUZZ_dataProducer_create(src, size);\n    FUZZ_ASSERT(producer);\n    if (literalsBuffer == NULL) {\n        literalsBuffer = FUZZ_malloc(ZSTD_FUZZ_GENERATED_LITERALS_SIZE);\n        FUZZ_ASSERT(literalsBuffer);\n        literalsBuffer = generatePseudoRandomString(literalsBuffer, ZSTD_FUZZ_GENERATED_LITERALS_SIZE);\n    }\n\n    hasDict = FUZZ_dataProducer_uint32Range(producer, 0, 1);\n    if (hasDict) {\n        dictSize = FUZZ_dataProducer_uint32Range(producer, 1, ZSTD_FUZZ_GENERATED_DICT_MAXSIZE);\n        dictBuffer = FUZZ_malloc(dictSize);\n        FUZZ_ASSERT(dictBuffer);\n        dictBuffer = generatePseudoRandomString(dictBuffer, dictSize);\n    }\n    /* Generate window log first so we dont generate offsets too large */\n    wLog = FUZZ_dataProducer_uint32Range(producer, ZSTD_WINDOWLOG_MIN, ZSTD_WINDOWLOG_MAX_32);\n    cLevel = FUZZ_dataProducer_int32Range(producer, -3, 22);\n    mode = (ZSTD_sequenceFormat_e)FUZZ_dataProducer_int32Range(producer, 0, 1);\n\n    if (!generatedSequences) {\n        generatedSequences = FUZZ_malloc(sizeof(ZSTD_Sequence)*ZSTD_FUZZ_MAX_NBSEQ);\n    }\n    if (!generatedSrc) {\n        generatedSrc = FUZZ_malloc(ZSTD_FUZZ_GENERATED_SRC_MAXSIZE);\n    }\n    nbSequences = generateRandomSequences(producer, ZSTD_FUZZ_GENERATED_LITERALS_SIZE, dictSize, wLog, mode);\n    generatedSrcSize = decodeSequences(generatedSrc, nbSequences, ZSTD_FUZZ_GENERATED_LITERALS_SIZE, dictBuffer, dictSize, mode);\n    /* Note : in explicit block delimiters mode,\n     * the fuzzer might generate a lot of small blocks.\n     * In which case, the final compressed size might be > ZSTD_compressBound().\n     * This is still a valid scenario fuzzer though, which makes it possible to check under-sized dstCapacity.\n     * The test just doesn't roundtrip. */\n    cBufSize = ZSTD_compressBound(generatedSrcSize);\n    cBuf = FUZZ_malloc(cBufSize);\n\n    rBufSize = generatedSrcSize;\n    rBuf = FUZZ_malloc(rBufSize);\n\n    if (!cctx) {\n        cctx = ZSTD_createCCtx();\n        FUZZ_ASSERT(cctx);\n    }\n    if (!dctx) {\n        dctx = ZSTD_createDCtx();\n        FUZZ_ASSERT(dctx);\n    }\n\n    {   const size_t result = roundTripTest(rBuf, rBufSize,\n                                        cBuf, cBufSize,\n                                        generatedSrc, generatedSrcSize,\n                                        dictBuffer, dictSize,\n                                        generatedSequences, nbSequences,\n                                        (int)wLog, cLevel, hasDict, mode);\n        FUZZ_ASSERT(result <= generatedSrcSize);  /* can be 0 when no round-trip */\n    }\n\n    free(rBuf);\n    free(cBuf);\n    FUZZ_dataProducer_free(producer);\n    if (hasDict) {\n        free(dictBuffer);\n    }\n#ifndef STATEFUL_FUZZING\n    ZSTD_freeCCtx(cctx); cctx = NULL;\n    ZSTD_freeDCtx(dctx); dctx = NULL;\n    free(generatedSequences); generatedSequences = NULL;\n    free(generatedSrc); generatedSrc = NULL;\n    free(literalsBuffer); literalsBuffer = NULL;\n#endif\n    return 0;\n}",
    "target": 0,
    "idx": 2044239
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "static bool LoadTGA(QDataStream &s, const TgaHeader &tga, QImage &img)\n{\n    // Create image.\n    img = QImage(tga.width, tga.height, QImage::Format_RGB32);\n\n    TgaHeaderInfo info(tga);\n\n    // Bits 0-3 are the numbers of alpha bits (can be zero!)\n    const int numAlphaBits = tga.flags & 0xf;\n    // However alpha exists only in the 32 bit format.\n    if ((tga.pixel_size == 32) && (tga.flags & 0xf)) {\n        img = QImage(tga.width, tga.height, QImage::Format_ARGB32);\n\n        if (numAlphaBits > 8) {\n            return false;\n        }\n    }\n\n    uint pixel_size = (tga.pixel_size / 8);\n    qint64 size = qint64(tga.width) * qint64(tga.height) * pixel_size;\n\n    if (size < 1) {\n//          qDebug() << \"This TGA file is broken with size \" << size;\n        return false;\n    }\n\n    // Read palette.\n    char palette[768];\n    if (info.pal) {\n        // @todo Support palettes in other formats!\n        const int size = 3 * tga.colormap_length;\n        const int dataRead = s.readRawData(palette, size);\n        if (dataRead < 0) {\n            return false;\n        }\n        if (dataRead < size) {\n            memset(&palette[dataRead], 0, size - dataRead);\n        }\n    }\n\n    // Allocate image.\n    uchar *const image = reinterpret_cast<uchar*>(malloc(size));\n    if (!image) {\n        return false;\n    }\n\n    bool valid = true;\n\n    if (info.rle) {\n        // Decode image.\n        char *dst = (char *)image;\n        qint64 num = size;\n\n        while (num > 0) {\n            if (s.atEnd()) {\n                valid = false;\n                break;\n            }\n\n            // Get packet header.\n            uchar c;\n            s >> c;\n\n            uint count = (c & 0x7f) + 1;\n            num -= count * pixel_size;\n            if (num < 0) {\n                valid = false;\n                break;\n            }\n\n            if (c & 0x80) {\n                // RLE pixels.\n                assert(pixel_size <= 8);\n                char pixel[8];\n                s.readRawData(pixel, pixel_size);\n                do {\n                    memcpy(dst, pixel, pixel_size);\n                    dst += pixel_size;\n                } while (--count);\n            } else {\n                // Raw pixels.\n                count *= pixel_size;\n                s.readRawData(dst, count);\n                dst += count;\n            }\n        }\n    } else {\n        // Read raw image.\n        const int dataRead = s.readRawData((char *)image, size);\n        if (dataRead < 0) {\n            free(image);\n            return false;\n        }\n        if (dataRead < size) {\n            memset(&image[dataRead], 0, size - dataRead);\n        }\n    }\n\n    if (!valid) {\n        free(image);\n        return false;\n    }\n\n    // Convert image to internal format.\n    int y_start, y_step, y_end;\n    if (tga.flags & TGA_ORIGIN_UPPER) {\n        y_start = 0;\n        y_step = 1;\n        y_end = tga.height;\n    } else {\n        y_start = tga.height - 1;\n        y_step = -1;\n        y_end = -1;\n    }\n\n    uchar *src = image;\n\n    for (int y = y_start; y != y_end; y += y_step) {\n        QRgb *scanline = (QRgb *) img.scanLine(y);\n\n        if (info.pal) {\n            // Paletted.\n            for (int x = 0; x < tga.width; x++) {\n                uchar idx = *src++;\n                scanline[x] = qRgb(palette[3 * idx + 2], palette[3 * idx + 1], palette[3 * idx + 0]);\n            }\n        } else if (info.grey) {\n            // Greyscale.\n            for (int x = 0; x < tga.width; x++) {\n                scanline[x] = qRgb(*src, *src, *src);\n                src++;\n            }\n        } else {\n            // True Color.\n            if (tga.pixel_size == 16) {\n                for (int x = 0; x < tga.width; x++) {\n                    Color555 c = *reinterpret_cast<Color555 *>(src);\n                    scanline[x] = qRgb((c.r << 3) | (c.r >> 2), (c.g << 3) | (c.g >> 2), (c.b << 3) | (c.b >> 2));\n                    src += 2;\n                }\n            } else if (tga.pixel_size == 24) {\n                for (int x = 0; x < tga.width; x++) {\n                    scanline[x] = qRgb(src[2], src[1], src[0]);\n                    src += 3;\n                }\n            } else if (tga.pixel_size == 32) {\n                for (int x = 0; x < tga.width; x++) {\n                    // ### TODO: verify with images having really some alpha data\n                    const uchar alpha = (src[3] << (8 - numAlphaBits));\n                    scanline[x] = qRgba(src[2], src[1], src[0], alpha);\n                    src += 4;\n                }\n            }\n        }\n    }\n\n    // Free image.\n    free(image);\n\n    return true;\n}\nstatic bool IsSupported(const TgaHeader &head)\n{\n    if (head.image_type != TGA_TYPE_INDEXED &&\n            head.image_type != TGA_TYPE_RGB &&\n            head.image_type != TGA_TYPE_GREY &&\n            head.image_type != TGA_TYPE_RLE_INDEXED &&\n            head.image_type != TGA_TYPE_RLE_RGB &&\n            head.image_type != TGA_TYPE_RLE_GREY) {\n        return false;\n    }\n    if (head.image_type == TGA_TYPE_INDEXED ||\n            head.image_type == TGA_TYPE_RLE_INDEXED) {\n        if (head.colormap_length > 256 || head.colormap_size != 24 || head.colormap_type != 1) {\n            return false;\n        }\n    }\n    if (head.image_type == TGA_TYPE_RGB ||\n            head.image_type == TGA_TYPE_GREY ||\n            head.image_type == TGA_TYPE_RLE_RGB ||\n            head.image_type == TGA_TYPE_RLE_GREY) {\n        if (head.colormap_type != 0) {\n            return false;\n        }\n    }\n    if (head.width == 0 || head.height == 0) {\n        return false;\n    }\n    if (head.pixel_size != 8 && head.pixel_size != 16 &&\n            head.pixel_size != 24 && head.pixel_size != 32) {\n        return false;\n    }\n    return true;\n}\nbool TGAHandler::read(QImage *outImage)\n{\n    //qDebug() << \"Loading TGA file!\";\n\n    QDataStream s(device());\n    s.setByteOrder(QDataStream::LittleEndian);\n\n    // Read image header.\n    TgaHeader tga;\n    s >> tga;\n    s.device()->seek(TgaHeader::SIZE + tga.id_length);\n\n    // Check image file format.\n    if (s.atEnd()) {\n//         qDebug() << \"This TGA file is not valid.\";\n        return false;\n    }\n\n    // Check supported file types.\n    if (!IsSupported(tga)) {\n//         qDebug() << \"This TGA file is not supported.\";\n        return false;\n    }\n\n    QImage img;\n    bool result = LoadTGA(s, tga, img);\n\n    if (result == false) {\n//         qDebug() << \"Error loading TGA file.\";\n        return false;\n    }\n\n    *outImage = img;\n    return true;\n}\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)\n{\n    int argc = 0;\n    QCoreApplication a(argc, nullptr);\n\n    const QVector<QImageIOHandler*> handlers = {\n        new PCXHandler(),\n        new SoftimagePICHandler(),\n        new PSDHandler(),\n        new RASHandler(),\n        new RGBHandler(),\n        new TGAHandler(),\n        new XCFHandler()\n    };\n\n    for (QImageIOHandler *h : handlers) {\n        QImage i;\n        QBuffer b;\n        b.setData((const char *)data, size);\n        b.open(QIODevice::ReadOnly);\n        h->setDevice(&b);\n        h->read(&i);\n    }\n    qDeleteAll(handlers);\n\n    return 0;\n}\nint ExecuteFilesOnyByOne(int argc, char **argv) {\n  for (int i = 1; i < argc; i++) {\n    std::ifstream in(argv[i], std::ios::binary);\n    in.seekg(0, in.end);\n    size_t length = in.tellg();\n    in.seekg (0, in.beg);\n    std::cout << \"Reading \" << length << \" bytes from \" << argv[i] << std::endl;\n    // Allocate exactly length bytes so that we reliably catch buffer overflows.\n    std::vector<char> bytes(length);\n    in.read(bytes.data(), bytes.size());\n    assert(in);\n    LLVMFuzzerTestOneInput(reinterpret_cast<const uint8_t *>(bytes.data()),\n                           bytes.size());\n    std::cout << \"Execution successful\" << std::endl;\n  }\n  return 0;\n}\nint main(int argc, char **argv) {\n  fprintf(stderr,\n      \"======================= INFO =========================\\n\"\n      \"This binary is built for AFL-fuzz.\\n\"\n      \"To run the target function on individual input(s) execute this:\\n\"\n      \"  %s < INPUT_FILE\\n\"\n      \"or\\n\"\n      \"  %s INPUT_FILE1 [INPUT_FILE2 ... ]\\n\"\n      \"To fuzz with afl-fuzz execute this:\\n\"\n      \"  afl-fuzz [afl-flags] %s [-N]\\n\"\n      \"afl-fuzz will run N iterations before \"\n      \"re-spawning the process (default: 1000)\\n\"\n      \"======================================================\\n\",\n          argv[0], argv[0], argv[0]);\n  if (LLVMFuzzerInitialize)\n    LLVMFuzzerInitialize(&argc, &argv);\n  // Do any other expensive one-time initialization here.\n\n  maybe_duplicate_stderr();\n\n  if (!getenv(\"AFL_DRIVER_DONT_DEFER\"))\n    __afl_manual_init();\n\n  int N = 1000;\n  if (argc == 2 && argv[1][0] == '-')\n      N = atoi(argv[1] + 1);\n  else if(argc == 2 && (N = atoi(argv[1])) > 0)\n      fprintf(stderr, \"WARNING: using the deprecated call style `%s %d`\\n\",\n              argv[0], N);\n  else if (argc > 1)\n    return ExecuteFilesOnyByOne(argc, argv);\n\n  assert(N > 0);\n\n  // Call LLVMFuzzerTestOneInput here so that coverage caused by initialization\n  // on the first execution of LLVMFuzzerTestOneInput is ignored.\n  uint8_t dummy_input[1] = {0};\n  LLVMFuzzerTestOneInput(dummy_input, 1);\n\n  int num_runs = 0;\n  while (__afl_persistent_loop(N)) {\n    ssize_t n_read = read(0, AflInputBuf, kMaxAflInputSize);\n    if (n_read > 0) {\n      // Copy AflInputBuf into a separate buffer to let asan find buffer\n      // overflows. Don't use unique_ptr/etc to avoid extra dependencies.\n      uint8_t *copy = new uint8_t[n_read];\n      memcpy(copy, AflInputBuf, n_read);\n      num_runs++;\n      LLVMFuzzerTestOneInput(copy, n_read);\n      delete[] copy;\n    }\n  }\n  fprintf(stderr, \"%s: successfully executed %d input(s)\\n\", argv[0], num_runs);\n}",
    "target": 0,
    "idx": 2012818
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "EXPORT ATTRIBUTE_MALLOC char *\nbit_TV_to_utf8 (const char *restrict src, const BITCODE_RS codepage)\n{\n  if (codepage == CP_UTF8)\n    return bit_u_expand ((char *)src);\n  else if (!src)\n    return NULL;\n  {\n    const bool is_asian_cp\n        = dwg_codepage_isasian ((const Dwg_Codepage)codepage);\n    const size_t srclen = strlen (src);\n    size_t destlen = 1 + (is_asian_cp ? srclen * 3 : trunc (srclen * 1.5));\n#ifdef HAVE_ICONV\n    const char *charset = dwg_codepage_iconvstr ((Dwg_Codepage)codepage);\n    const char utf8_cs[] = \"UTF-8//TRANSLIT//IGNORE\";\n    iconv_t cd;\n    size_t nconv = (size_t)-1;\n    char *dest, *odest, *osrc;\n    size_t odestlen = destlen;\n    if (!charset || !srclen)\n      return (char *)src;\n    osrc = (char *)src;\n    odest = dest = (char *)malloc (odestlen);\n    if (!odest || destlen > 0x2FFFE)\n      {\n        loglevel |= 1;\n        LOG_ERROR (\"Out of memory\");\n        if (odest)\n          free (odest);\n        return NULL;\n      }\n    cd = iconv_open (utf8_cs, charset);\n    if (cd == (iconv_t)-1)\n      {\n        if (errno != 22)\n          LOG_WARN (\"iconv_open (\\\"%s\\\", \\\"%s\\\") failed with errno %d\",\n                    utf8_cs, charset, errno);\n        free (odest);\n        return bit_TV_to_utf8_codepage (src, codepage);\n      }\n    while (nconv == (size_t)-1)\n      {\n#ifdef WINICONV_CONST\n        nconv = iconv (cd, (WINICONV_CONST char **restrict)&src, (size_t *)&srclen,\n                       (char **)&dest, (size_t *)&destlen);\n#else\n        nconv = iconv (cd, (char **restrict)&src, (size_t *)&srclen,\n                       (char **)&dest, (size_t *)&destlen);\n#endif\n        if (nconv == (size_t)-1)\n          {\n            if (errno != EINVAL) // probably dest buffer too small\n              {\n                char *dest_new;\n                destlen *= 2;\n                if (destlen > 0x2FFFE)\n                  {\n                    loglevel |= 1;\n                    LOG_ERROR (\"bit_TV_to_utf8: overlarge destlen %zu for %s\",\n                               destlen, src);\n                    iconv_close (cd);\n                    free (odest);\n                    return NULL;\n                  }\n                dest_new = (char *)realloc (odest, destlen);\n                if (dest_new)\n                  {\n                    odest = dest = dest_new;\n                    odestlen = destlen;\n                  }\n                else\n                  {\n                    loglevel |= 1;\n                    LOG_ERROR (\"Out of memory\");\n                    iconv_close (cd);\n                    //free (odest);\n                    return NULL;\n                  }\n              }\n            else\n              {\n                loglevel |= 1;\n                LOG_ERROR (\"iconv \\\"%s\\\" failed with errno %d\", src, errno);\n                iconv_close (cd);\n                free (odest);\n                return bit_u_expand (osrc);\n              }\n          }\n      }\n    // flush the remains\n    iconv (cd, NULL, (size_t *)&srclen, (char **)&dest, (size_t *)&destlen);\n    if (errno == 0 && dest >= odest && dest <= &odest[odestlen])\n      {\n        *dest = '\\0';\n        iconv_close (cd);\n        return bit_u_expand (odest);\n      }\n    else\n      {\n        iconv_close (cd);\n        free (odest);\n        return bit_TV_to_utf8_codepage (src, codepage);\n      }\n#else\n    return bit_TV_to_utf8_codepage (src, codepage);\n#endif\n  }\n}\nchar *\njson_cquote (char *restrict dest, const char *restrict src, const size_t len,\n             const BITCODE_RS codepage)\n{\n  unsigned char c;\n  unsigned char *s = (unsigned char *)src;\n  const char *endp = dest + len;\n  char *d = dest;\n  char *tmp = NULL;\n\n  if (!src)\n    return (char *)\"\";\n  if (codepage > CP_US_ASCII && codepage <= CP_ANSI_1258)\n    {\n      // may malloc\n      tmp = bit_TV_to_utf8 ((char *restrict)src, codepage);\n      if (tmp)\n        s = (unsigned char *)tmp;\n      // else conversion failed. ignore\n    }\n  while ((c = *s++))\n    {\n      if (dest >= endp)\n        {\n          *dest = 0;\n          if (tmp && tmp != src)\n            free (tmp);\n          return d;\n        }\n      if (c == '\"' && dest + 1 < endp)\n        {\n          *dest++ = '\\\\';\n          *dest++ = c;\n        }\n      else if (c == '\\\\' && dest + 2 < endp)\n        {\n          if (dest + 5 < endp && s[0] == 'U' && s[1] == '+' && ishex (s[2])\n              && ishex (s[3]) && ishex (s[4]) && ishex (s[5]))\n            {\n              *dest++ = '\\\\';\n              *dest++ = 'u';\n              s += 2;\n            }\n          else\n            {\n              *dest++ = '\\\\';\n              *dest++ = c;\n            }\n        }\n      else if (c == '\\n' && dest + 1 < endp)\n        {\n          *dest++ = '\\\\';\n          *dest++ = 'n';\n        }\n      else if (c == '\\r' && dest + 1 < endp)\n        {\n          *dest++ = '\\\\';\n          *dest++ = 'r';\n        }\n      else if (c < 0x1f && dest + 5 < endp)\n        {\n          *dest++ = '\\\\';\n          *dest++ = 'u';\n          *dest++ = '0';\n          *dest++ = '0';\n          *dest++ = hex (c >> 4);\n          *dest++ = hex (c & 0xf);\n        }\n      else\n        *dest++ = c;\n    }\n  *dest = 0; // add final delim, skipped above\n  if (tmp && tmp != src)\n    free (tmp);\n  return d;\n}\nstatic int\ndwg_json_object (Bit_Chain *restrict dat, Dwg_Object *restrict obj)\n{\n  int error = 0;\n  unsigned int type;\n\n  if (!obj || !obj->parent)\n    return DWG_ERR_INTERNALERROR;\n  if (dat->version < R_13b1)\n    type = (unsigned int)obj->fixedtype;\n  else\n    {\n      type = obj->type;\n      if (obj->fixedtype == DWG_TYPE_UNKNOWN_ENT)\n        type = DWG_TYPE_UNKNOWN_ENT;\n      if (obj->fixedtype == DWG_TYPE_UNKNOWN_OBJ)\n        type = DWG_TYPE_UNKNOWN_OBJ;\n    }\n\n  switch (type)\n    {\n    case DWG_TYPE_TEXT:\n      return dwg_json_TEXT (dat, obj);\n    case DWG_TYPE_ATTRIB:\n      return dwg_json_ATTRIB (dat, obj);\n    case DWG_TYPE_ATTDEF:\n      return dwg_json_ATTDEF (dat, obj);\n    case DWG_TYPE_BLOCK:\n      return dwg_json_BLOCK (dat, obj);\n    case DWG_TYPE_ENDBLK:\n      return dwg_json_ENDBLK (dat, obj);\n    case DWG_TYPE_SEQEND:\n      return dwg_json_SEQEND (dat, obj);\n    case DWG_TYPE_INSERT:\n      return dwg_json_INSERT (dat, obj);\n    case DWG_TYPE_MINSERT:\n      return dwg_json_MINSERT (dat, obj);\n    case DWG_TYPE_VERTEX_2D:\n      return dwg_json_VERTEX_2D (dat, obj);\n    case DWG_TYPE_VERTEX_3D:\n      return dwg_json_VERTEX_3D (dat, obj);\n    case DWG_TYPE_VERTEX_MESH:\n      return dwg_json_VERTEX_MESH (dat, obj);\n    case DWG_TYPE_VERTEX_PFACE:\n      return dwg_json_VERTEX_PFACE (dat, obj);\n    case DWG_TYPE_VERTEX_PFACE_FACE:\n      return dwg_json_VERTEX_PFACE_FACE (dat, obj);\n    case DWG_TYPE_POLYLINE_2D:\n      return dwg_json_POLYLINE_2D (dat, obj);\n    case DWG_TYPE_POLYLINE_3D:\n      return dwg_json_POLYLINE_3D (dat, obj);\n    case DWG_TYPE_ARC:\n      return dwg_json_ARC (dat, obj);\n    case DWG_TYPE_CIRCLE:\n      return dwg_json_CIRCLE (dat, obj);\n    case DWG_TYPE_LINE:\n      return dwg_json_LINE (dat, obj);\n    case DWG_TYPE_DIMENSION_ORDINATE:\n      return dwg_json_DIMENSION_ORDINATE (dat, obj);\n    case DWG_TYPE_DIMENSION_LINEAR:\n      return dwg_json_DIMENSION_LINEAR (dat, obj);\n    case DWG_TYPE_DIMENSION_ALIGNED:\n      return dwg_json_DIMENSION_ALIGNED (dat, obj);\n    case DWG_TYPE_DIMENSION_ANG3PT:\n      return dwg_json_DIMENSION_ANG3PT (dat, obj);\n    case DWG_TYPE_DIMENSION_ANG2LN:\n      return dwg_json_DIMENSION_ANG2LN (dat, obj);\n    case DWG_TYPE_DIMENSION_RADIUS:\n      return dwg_json_DIMENSION_RADIUS (dat, obj);\n    case DWG_TYPE_DIMENSION_DIAMETER:\n      return dwg_json_DIMENSION_DIAMETER (dat, obj);\n    case DWG_TYPE_POINT:\n      return dwg_json_POINT (dat, obj);\n    case DWG_TYPE__3DFACE:\n      return dwg_json__3DFACE (dat, obj);\n    case DWG_TYPE_POLYLINE_PFACE:\n      return dwg_json_POLYLINE_PFACE (dat, obj);\n    case DWG_TYPE_POLYLINE_MESH:\n      return dwg_json_POLYLINE_MESH (dat, obj);\n    case DWG_TYPE_SOLID:\n      return dwg_json_SOLID (dat, obj);\n    case DWG_TYPE_TRACE:\n      return dwg_json_TRACE (dat, obj);\n    case DWG_TYPE_SHAPE:\n      return dwg_json_SHAPE (dat, obj);\n    case DWG_TYPE_VIEWPORT:\n      return dwg_json_VIEWPORT (dat, obj);\n    case DWG_TYPE_ELLIPSE:\n      return dwg_json_ELLIPSE (dat, obj);\n    case DWG_TYPE_SPLINE:\n      return dwg_json_SPLINE (dat, obj);\n    case DWG_TYPE_REGION:\n      return dwg_json_REGION (dat, obj);\n    case DWG_TYPE__3DSOLID:\n      return dwg_json__3DSOLID (dat, obj);\n    case DWG_TYPE_BODY:\n      return dwg_json_BODY (dat, obj);\n    case DWG_TYPE_RAY:\n      return dwg_json_RAY (dat, obj);\n    case DWG_TYPE_XLINE:\n      return dwg_json_XLINE (dat, obj);\n    case DWG_TYPE_DICTIONARY:\n      return dwg_json_DICTIONARY (dat, obj);\n    case DWG_TYPE_MTEXT:\n      return dwg_json_MTEXT (dat, obj);\n    case DWG_TYPE_LEADER:\n      return dwg_json_LEADER (dat, obj);\n    case DWG_TYPE_TOLERANCE:\n      return dwg_json_TOLERANCE (dat, obj);\n    case DWG_TYPE_MLINE:\n      return dwg_json_MLINE (dat, obj);\n    case DWG_TYPE_BLOCK_CONTROL:\n      return dwg_json_BLOCK_CONTROL (dat, obj);\n    case DWG_TYPE_BLOCK_HEADER:\n      if (dat->version <= R_12\n          && strEQc (obj->tio.object->tio.BLOCK_HEADER->name, \"*MODEL_SPACE\"))\n        {\n          LOG_TRACE (\"Skip *MODEL_SPACE\\n\");\n          return 0;\n        }\n      return dwg_json_BLOCK_HEADER (dat, obj);\n    case DWG_TYPE_LAYER_CONTROL:\n      return dwg_json_LAYER_CONTROL (dat, obj);\n    case DWG_TYPE_LAYER:\n      return dwg_json_LAYER (dat, obj);\n    case DWG_TYPE_STYLE_CONTROL:\n      return dwg_json_STYLE_CONTROL (dat, obj);\n    case DWG_TYPE_STYLE:\n      return dwg_json_STYLE (dat, obj);\n    case DWG_TYPE_LTYPE_CONTROL:\n      return dwg_json_LTYPE_CONTROL (dat, obj);\n    case DWG_TYPE_LTYPE:\n      return dwg_json_LTYPE (dat, obj);\n    case DWG_TYPE_VIEW_CONTROL:\n      return dwg_json_VIEW_CONTROL (dat, obj);\n    case DWG_TYPE_VIEW:\n      return dwg_json_VIEW (dat, obj);\n    case DWG_TYPE_UCS_CONTROL:\n      return dwg_json_UCS_CONTROL (dat, obj);\n    case DWG_TYPE_UCS:\n      return dwg_json_UCS (dat, obj);\n    case DWG_TYPE_VPORT_CONTROL:\n      return dwg_json_VPORT_CONTROL (dat, obj);\n    case DWG_TYPE_VPORT:\n      return dwg_json_VPORT (dat, obj);\n    case DWG_TYPE_APPID_CONTROL:\n      return dwg_json_APPID_CONTROL (dat, obj);\n    case DWG_TYPE_APPID:\n      return dwg_json_APPID (dat, obj);\n    case DWG_TYPE_DIMSTYLE_CONTROL:\n      return dwg_json_DIMSTYLE_CONTROL (dat, obj);\n    case DWG_TYPE_DIMSTYLE:\n      return dwg_json_DIMSTYLE (dat, obj);\n    case DWG_TYPE_VX_CONTROL:\n      return dwg_json_VX_CONTROL (dat, obj);\n    case DWG_TYPE_VX_TABLE_RECORD:\n      return dwg_json_VX_TABLE_RECORD (dat, obj);\n    case DWG_TYPE_GROUP:\n      return dwg_json_GROUP (dat, obj);\n    case DWG_TYPE_MLINESTYLE:\n      return dwg_json_MLINESTYLE (dat, obj);\n    case DWG_TYPE_OLE2FRAME:\n      return dwg_json_OLE2FRAME (dat, obj);\n    case DWG_TYPE_DUMMY:\n      return dwg_json_DUMMY (dat, obj);\n    case DWG_TYPE_LONG_TRANSACTION:\n      return dwg_json_LONG_TRANSACTION (dat, obj);\n    case DWG_TYPE_LWPOLYLINE:\n      return dwg_json_LWPOLYLINE (dat, obj);\n    case DWG_TYPE_HATCH:\n      return dwg_json_HATCH (dat, obj);\n    case DWG_TYPE_XRECORD:\n      return dwg_json_XRECORD (dat, obj);\n    case DWG_TYPE_PLACEHOLDER:\n      return dwg_json_PLACEHOLDER (dat, obj);\n    case DWG_TYPE_PROXY_ENTITY:\n      return dwg_json_PROXY_ENTITY (dat, obj);\n    case DWG_TYPE_PROXY_OBJECT:\n      return dwg_json_PROXY_OBJECT (dat, obj);\n    case DWG_TYPE_OLEFRAME:\n      return dwg_json_OLEFRAME (dat, obj);\n    case DWG_TYPE_VBA_PROJECT:\n      LOG_ERROR (\"Unhandled Object VBA_PROJECT. Has its own section\\n\");\n      // dwg_json_VBA_PROJECT(dat, obj);\n      break;\n    case DWG_TYPE_REPEAT:\n      return dwg_json_REPEAT (dat, obj);\n    case DWG_TYPE_ENDREP:\n      return dwg_json_ENDREP (dat, obj);\n    case DWG_TYPE__3DLINE:\n      return dwg_json__3DLINE (dat, obj);\n    case DWG_TYPE_LOAD:\n      return dwg_json_LOAD (dat, obj);\n    case DWG_TYPE_JUMP:\n      return dwg_json_JUMP (dat, obj);\n    case DWG_TYPE_LAYOUT:\n      return dwg_json_LAYOUT (dat, obj);\n    default:\n      if (obj->type != 0 && obj->type == obj->parent->layout_type)\n        {\n          return dwg_json_LAYOUT (dat, obj);\n        }\n      /* > 500 */\n      else if (DWG_ERR_UNHANDLEDCLASS\n               & (error = dwg_json_variable_type (obj->parent, dat, obj)))\n        {\n          Dwg_Data *dwg = obj->parent;\n          int is_entity = 0;\n          int i = obj->type - 500;\n          Dwg_Class *klass = NULL;\n          int num_bytes = obj->num_unknown_bits / 8;\n          if (obj->num_unknown_bits & 8)\n            num_bytes++;\n\n          if (obj->fixedtype == DWG_TYPE_FREED)\n            goto invalid_type;\n          if (i >= 0 && i < (int)dwg->num_classes\n              && obj->fixedtype < DWG_TYPE_FREED)\n            {\n              klass = &dwg->dwg_class[i];\n              is_entity = dwg_class_is_entity (klass);\n            }\n          else\n            {\n              if (obj->fixedtype == DWG_TYPE_UNKNOWN_ENT)\n                is_entity = 1;\n            }\n          // properly dwg_decode_object/_entity for eed, reactors, xdic\n          if (!is_entity)\n            {\n              error |= dwg_json_UNKNOWN_OBJ (dat, obj);\n              KEY (num_unknown_bits);\n              VALUE_RL (obj->num_unknown_bits, 0);\n              KEY (unknown_bits);\n              VALUE_BINARY (obj->unknown_bits, num_bytes, 0);\n              return error;\n            }\n          else\n            {\n              error |= dwg_json_UNKNOWN_ENT (dat, obj);\n              KEY (num_unknown_bits);\n              VALUE_RL (obj->num_unknown_bits, 0);\n              KEY (unknown_bits);\n              VALUE_BINARY (obj->unknown_bits, num_bytes, 0);\n              return error;\n            }\n        }\n      else\n        return 0;\n    }\ninvalid_type:\n  LOG_WARN (\"Unknown object, skipping eed/reactors/xdic/...\");\n  FIELD_TEXT (object, obj->name);\n  if (obj->dxfname && strNE (obj->dxfname, obj->name))\n    FIELD_TEXT (dxfname, obj->dxfname);\n  _FIELD (index, RL, 0);\n  _FIELD (type, RL, 0);\n  KEY (handle);\n  VALUE_H (obj->handle, 5);\n  _FIELD (size, RL, 0);\n  _FIELD (bitsize, BL, 0);\n  return DWG_ERR_INVALIDTYPE;\n}\nstatic int\njson_objects_write (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  BITCODE_BL i;\n\n  CLEARFIRST;\n  SECTION (OBJECTS);\n  for (i = 0; i < dwg->num_objects; i++)\n    {\n      int error;\n      Dwg_Object *obj = &dwg->object[i];\n      FIRSTPREFIX HASH;\n      error = dwg_json_object (dat, obj);\n      ENDHASH\n      CLEARFIRST;\n    }\n  ENDSEC ();\n  return 0;\n}\nEXPORT int\ndwg_write_json (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  const int minimal = dwg->opts & DWG_OPTS_MINIMAL;\n  Dwg_Header *obj = &dwg->header;\n  int error = 0;\n\n  if (!dat->codepage)\n    dat->codepage = dwg->header.codepage;\n  fprintf (dat->fh, \"{\\n  \\\"created_by\\\": \\\"%s\\\"\", PACKAGE_STRING);\n  dat->bit++; // ident\n\n  if (!minimal)\n    {\n      json_fileheader_write (dat, dwg);\n    }\n\n  // A minimal HEADER requires only $ACADVER, $HANDSEED, and then ENTITIES\n  json_header_write (dat, dwg);\n\n  if (!minimal && dat->version >= R_13b1)\n    {\n      if (json_classes_write (dat, dwg) >= DWG_ERR_CRITICAL)\n        goto fail;\n    }\n  if (!minimal && dat->version < R_13b1 && 0)\n    {\n      if (json_tables_write (dat, dwg) >= DWG_ERR_CRITICAL)\n        goto fail;\n    }\n\n  if (json_objects_write (dat, dwg) >= DWG_ERR_CRITICAL)\n    goto fail;\n\n  if (!minimal && dat->version >= R_13b1)\n    {\n      if (json_thumbnail_write (dat, dwg) >= DWG_ERR_CRITICAL)\n        goto fail;\n      /* the other sections */\n      if (dat->version <= R_2000)\n        {\n          error |= json_section_template (dat, dwg); // i.e. MEASUREMENT\n          error |= json_section_auxheader (dat, dwg);\n          error |= json_section_2ndheader (dat, dwg);\n        }\n      if (dat->version >= R_2004)\n        {\n          if (dat->version == R_2007)\n            error |= json_section_r2007fileheader (dat, dwg);\n          else\n            error |= json_section_r2004fileheader (dat, dwg);\n          if (dwg->header.summaryinfo_address)\n            error |= json_section_summary (dat, dwg);\n          if (dwg->header.vbaproj_address)\n            error |= json_section_vbaproject (dat, dwg);\n          error |= json_section_appinfo (dat, dwg);\n          error |= json_section_appinfohistory (dat, dwg);\n          error |= json_section_filedeplist (dat, dwg);\n          error |= json_section_security (dat, dwg);\n          error |= json_section_revhistory (dat, dwg);\n          error |= json_section_objfreespace (dat, dwg);\n          // error |= json_section_signature (dat, dwg);\n          error |= json_section_template (dat, dwg);\n          error |= json_section_acds (dat, dwg);\n        }\n    }\n\n#if 0\n  /* object map */\n  if (!minimal && dat->version >= R_13b1)\n    {\n      if (json_handles_write (dat, dwg) >= DWG_ERR_CRITICAL)\n        goto fail;\n    }\n#endif\n\n  dat->bit--;\n  fprintf (dat->fh, \"}\\n\");\n  return 0;\nfail:\n  return 1;\n}\nint\nLLVMFuzzerTestOneInput (const unsigned char *data, size_t size)\n{\n  Dwg_Data dwg;\n  Bit_Chain dat = { NULL, 0, 0, 0, 0 };\n  Bit_Chain out_dat = { NULL, 0, 0, 0, 0 };\n  int copied = 0;\n  struct ly_ctx *ctx = NULL;\n  unsigned int possible_outputformats;\n  int out;\n\n  static char tmp_file[256];\n  dat.chain = (unsigned char *)data;\n  dat.size = size;\n  memset (&dwg, 0, sizeof (dwg));\n\n  possible_outputformats =\n#ifdef DISABLE_DXF\n#  ifdef DISABLE_JSON\n      1;\n#  else\n      3;\n#  endif\n#else\n      5;\n#endif\n\n  // Detect the input format: DWG, DXF or JSON\n  if (dat.size > 2 && dat.chain[0] == 'A' && dat.chain[1] == 'C')\n    {\n      if (dwg_decode (&dat, &dwg) >= DWG_ERR_CRITICAL)\n        {\n          dwg_free (&dwg);\n          return 0;\n        }\n    }\n#ifndef DISABLE_JSON\n  else if (dat.size > 1 && dat.chain[0] == '{')\n    {\n      copied = enforce_null_termination (&dat, true);\n      if (dwg_read_json (&dat, &dwg) >= DWG_ERR_CRITICAL)\n        {\n          if (copied)\n            bit_chain_free (&dat);\n          dwg_free (&dwg);\n          return 0;\n        }\n      dat.opts |= DWG_OPTS_INJSON;\n      dwg.opts |= DWG_OPTS_INJSON;\n    }\n#endif\n#ifndef DISABLE_DXF\n  else\n    {\n      copied = enforce_null_termination (&dat, false);\n      if (dwg_read_dxf (&dat, &dwg) >= DWG_ERR_CRITICAL)\n        {\n          if (copied)\n            bit_chain_free (&dat);\n          dwg_free (&dwg);\n          return 0;\n        }\n    }\n#else\n  else\n    return 0;\n#endif\n\n  memset (&out_dat, 0, sizeof (out_dat));\n  bit_chain_set_version (&out_dat, &dat);\n  if (copied)\n    bit_chain_free (&dat);\n\n#if 0\n    snprintf (tmp_file, 255, \"/tmp/llvmfuzzer%d.out\", getpid());\n    tmp_file[255] = '\\0';\n#elif defined _WIN32\n  strcpy (tmp_file, \"NUL\");\n#else\n  strcpy (tmp_file, \"/dev/null\");\n#endif\n  out_dat.fh = fopen (tmp_file, \"w\");\n\n  out = rand () % possible_outputformats;\n#ifdef STANDALONE\n  if (getenv (\"OUT\"))\n    out = strtol (getenv (\"OUT\"), NULL, 10);\n#endif\n  switch (out)\n    {\n    case 0:\n      {\n        int ver = rand () % 6;\n#ifdef STANDALONE\n        if (getenv (\"VER\"))\n          ver = strtol (getenv (\"VER\"), NULL, 10);\n#endif\n        switch (ver)\n          {\n          case 0:\n            out_dat.version = dwg.header.version = R_13;\n            break;\n          case 1:\n            out_dat.version = dwg.header.version = R_13c3;\n            break;\n          case 2:\n            out_dat.version = dwg.header.version = R_14;\n            break;\n          case 3: // favor this one\n          case 4:\n          case 5:\n          default:\n            out_dat.version = dwg.header.version = R_2000;\n            break;\n          }\n        dwg_encode (&dwg, &out_dat);\n        free (out_dat.chain);\n        break;\n      }\n#ifndef DISABLE_DXF\n    case 1:\n      dwg_write_dxf (&out_dat, &dwg);\n      free (out_dat.chain);\n      break;\n    case 2: // experimental\n      dwg_write_dxfb (&out_dat, &dwg);\n      free (out_dat.chain);\n      break;\n#  ifndef DISABLE_JSON\n    case 3:\n      dwg_write_json (&out_dat, &dwg);\n      free (out_dat.chain);\n      break;\n    case 4:\n      dwg_write_geojson (&out_dat, &dwg);\n      free (out_dat.chain);\n      break;\n#  endif\n#endif\n    default:\n      break;\n    }\n  dwg_free (&dwg);\n  fclose (out_dat.fh);\n  // unlink (tmp_file);\n  return 0;\n}",
    "target": 0,
    "idx": 2062363
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "ssize_t fr_tacacs_decode(TALLOC_CTX *ctx, fr_pair_list_t *out, uint8_t const *buffer, size_t buffer_len,\n\t\t\t const uint8_t *original, char const * const secret, size_t secret_len, int *code)\n{\n\tfr_tacacs_packet_t const *pkt;\n\tfr_pair_t\t\t*vp;\n\tuint8_t const  \t\t*p, *body, *argv, *attrs, *end;\n\tuint8_t\t\t\t*decrypted = NULL;\n\n\t/*\n\t * 3.4. The TACACS+ Packet Header\n\t *\n\t * 1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8\n\t * +----------------+----------------+----------------+----------------+\n\t * |major  | minor  |                |                |                |\n\t * |version| version|      type      |     seq_no     |   flags        |\n\t * +----------------+----------------+----------------+----------------+\n\t * |                                                                   |\n\t * |                            session_id                             |\n\t * +----------------+----------------+----------------+----------------+\n\t * |                                                                   |\n\t * |                              length                               |\n\t * +----------------+----------------+----------------+----------------+\n\t */\n\tpkt = (fr_tacacs_packet_t const *) buffer;\n\n\t/*\n\t *\tp\tmiscellaneous pointer for decoding things\n\t *\tbody\tpoints to just past the (randomly sized) per-packet header,\n\t *\t\twhere the various user / server messages are.\n\t *\t\tsometimes this is after \"argv\".\n\t *\targv\tpoints to the array of argv[i] length entries\n\t *\tattrs\tpoints to the attributes we need to decode as \"foo=bar\".\n\t */\n\targv = attrs = NULL;\n\tend = buffer + buffer_len;\n\n\t/*\n\t *\tCheck that we have a full TACACS+ header before\n\t *\tdecoding anything.\n\t */\n\tif (buffer_len < sizeof(pkt->hdr)) {\n\t\tfr_strerror_printf(\"Packet is too small (%zu < 12) to be TACACS+.\", buffer_len);\n\t\treturn -1;\n\t}\n\n\t/*\n\t *\tTACACS major / minor version MUST be 12.0 or 12.1\n\t */\n\tif (!(pkt->hdr.ver.major == 12 && (pkt->hdr.ver.minor == 0 || pkt->hdr.ver.minor == 1))) {\n\t\tfr_strerror_printf(\"Unsupported TACACS+ version %d.%d (%02x)\", pkt->hdr.ver.major, pkt->hdr.ver.minor, buffer[0]);\n\t\treturn -1;\n\t}\n\n\t/*\n\t *\tThere's no reason to accept 64K TACACS+ packets.\n\t *\n\t *\tIn any case, the largest possible packet has the\n\t *\theader, plus 2 16-bit fields, plus 255 8-bit fields,\n\t *\twhich is a bit under 2^18.\n\t */\n\tif ((buffer[8] != 0) || (buffer[9] != 0)) {\n\t\tfr_strerror_const(\"Packet is too large.  Our limit is 64K\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t *\tAs a stream protocol, the TACACS+ packet MUST fit\n\t *\texactly into however many bytes we read.\n\t */\n\tif ((buffer + sizeof(pkt->hdr) + ntohl(pkt->hdr.length)) != end) {\n\t\tfr_strerror_const(\"Packet does not exactly fill buffer\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t *\tThere are only 3 types of packets which are supported.\n\t */\n\tif (!((pkt->hdr.type == FR_TAC_PLUS_AUTHEN) ||\n\t      (pkt->hdr.type == FR_TAC_PLUS_AUTHOR) ||\n\t      (pkt->hdr.type == FR_TAC_PLUS_ACCT))) {\n\t\tfr_strerror_printf(\"Unknown packet type %u\", pkt->hdr.type);\n\t\treturn -1;\n\t}\n\n\t/*\n\t *\tCheck that the session IDs are correct.\n\t */\n\tif (original && (memcmp(original + 4, buffer + 4, 4) != 0)) {\n\t\tfr_strerror_printf(\"Session ID %08x does not match expected number %08x\",\n\t\t\t\t   fr_nbo_to_uint32(buffer + 4), fr_nbo_to_uint32(original + 4));\n\t\treturn -1;\n\t}\n\n\tif (!secret && packet_is_encrypted(pkt)) {\n\t\tfr_strerror_const(\"Packet is encrypted, but there is no secret to decrypt it\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t *\tCall the struct encoder to do the actual work.\n\t */\n\tif (fr_struct_from_network(ctx, out, attr_tacacs_packet, buffer, buffer_len, false, NULL, NULL, NULL) < 0) {\n\t\tfr_strerror_printf(\"Failed decoding TACACS header - %s\", fr_strerror());\n\t\treturn -1;\n\t}\n\n\t/*\n\t *\t3.6. Encryption\n\t *\n\t *\tIf there's a secret, we alway decrypt the packets.\n\t */\n\tif (secret && packet_is_encrypted(pkt)) {\n\t\tsize_t length;\n\n\t\tif (!secret_len) {\n\t\t\tfr_strerror_const(\"Packet should be encrypted, but the secret has zero length\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tlength = ntohl(pkt->hdr.length);\n\n\t\t/*\n\t\t *\tWe need that to decrypt the body content.\n\t\t */\n\t\tdecrypted = talloc_memdup(ctx, buffer, buffer_len);\n\t\tif (!decrypted) {\n\t\t\tfr_strerror_const(\"Out of Memory\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tpkt = (fr_tacacs_packet_t const *) decrypted;\n\t\tend = decrypted + buffer_len;\n\n\t\tif (fr_tacacs_body_xor(pkt, decrypted + sizeof(pkt->hdr), length, secret, secret_len) < 0) {\n\t\tfail:\n\t\t\ttalloc_free(decrypted);\n\t\t\treturn -1;\n\t\t}\n\n\t\tdecrypted[3] |= FR_TAC_PLUS_UNENCRYPTED_FLAG;\n\n\t\tFR_PROTO_HEX_DUMP(decrypted, buffer_len, \"fr_tacacs_packet_t (unencrypted)\");\n\n\t\tif (code) {\n\t\t\t*code = fr_tacacs_packet_to_code((fr_tacacs_packet_t const *) decrypted);\n\t\t\tif (*code < 0) goto fail;\n\t\t}\n\t}\n\n#ifndef NDEBUG\n\tif (fr_debug_lvl >= L_DBG_LVL_4) fr_tacacs_packet_log_hex(&default_log, pkt);\n#endif\n\n\tswitch (pkt->hdr.type) {\n\t\tsize_t data_len;\n\n\tcase FR_TAC_PLUS_AUTHEN:\n\t\tif (packet_is_authen_start_request(pkt)) {\n\t\t\tuint8_t want;\n\t\t\tbool raw;\n\t\t\tfr_dict_attr_t const *da, *challenge;\n\n\t\t\t/**\n\t\t\t * 4.1. The Authentication START Packet Body\n\t\t\t *\n\t\t\t *  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |    action      |    priv_lvl    |  authen_type   | authen_service |\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |    user_len    |    port_len    |  rem_addr_len  |    data_len    |\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |    user ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |    port ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |    rem_addr ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |    data...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t */\n\t\t\tPACKET_HEADER_CHECK(\"Authentication-Start\", pkt->authen_start);\n\n\t\t\tdata_len += p[4] + p[5] + p[6] + p[7];\n\t\t\tif (data_len > (size_t) (end - p)) {\n\t\t\toverflow:\n\t\t\t\tfr_strerror_const(\"Data overflows the packet\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tif (data_len < (size_t) (end - p)) {\n\t\t\tunderflow:\n\t\t\t\tfr_strerror_const(\"Data underflows the packet\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_packet_body_type, FR_PACKET_BODY_TYPE_START);\n\n\t\t\t/*\n\t\t\t *\tDecode 4 octets of various flags.\n\t\t\t */\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_action, pkt->authen_start.action);\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_privilege_level, pkt->authen_start.priv_lvl);\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_authentication_type, pkt->authen_start.authen_type);\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_authentication_service, pkt->authen_start.authen_service);\n\n\t\t\t/*\n\t\t\t *\tDecode 4 fields, based on their \"length\"\n\t\t\t */\n\t\t\tp = body;\n\t\t\tDECODE_FIELD_STRING8(attr_tacacs_user_name, pkt->authen_start.user_len);\n\t\t\tDECODE_FIELD_STRING8(attr_tacacs_client_port, pkt->authen_start.port_len);\n\t\t\tDECODE_FIELD_STRING8(attr_tacacs_remote_address, pkt->authen_start.rem_addr_len);\n\n\t\t\t/*\n\t\t\t *\tCheck the length on the various\n\t\t\t *\tauthentication types.\n\t\t\t */\n\t\t\traw = false;\n\t\t\tchallenge = NULL;\n\n\t\t\tswitch (pkt->authen_start.authen_type) {\n\t\t\tdefault:\n\t\t\t\traw = true;\n\t\t\t\twant = pkt->authen_start.data_len;\n\t\t\t\tda = attr_tacacs_data;\n\t\t\t\tbreak;\n\n\t\t\tcase FR_AUTHENTICATION_TYPE_VALUE_PAP:\n\t\t\t\twant = pkt->authen_start.data_len;\n\t\t\t\tda = attr_tacacs_user_password;\n\t\t\t\tbreak;\n\n\t\t\tcase FR_AUTHENTICATION_TYPE_VALUE_CHAP:\n\t\t\t\twant = 1 + 16; /* id + HOPEFULLY 8 octets of challenge + 16 hash */\n\t\t\t\tda = attr_tacacs_chap_password;\n\t\t\t\tchallenge = attr_tacacs_chap_challenge;\n\t\t\t\tbreak;\n\n\t\t\tcase FR_AUTHENTICATION_TYPE_VALUE_MSCHAP:\n\t\t\t\twant = 1 + 49; /* id + HOPEFULLY 8 octets of challenge + 49 MS-CHAP stuff */\n\t\t\t\tda = attr_tacacs_mschap_response;\n\t\t\t\tchallenge = attr_tacacs_mschap_challenge;\n\t\t\t\tbreak;\n\n\t\t\tcase FR_AUTHENTICATION_TYPE_VALUE_MSCHAPV2:\n\t\t\t\twant = 1 + 49; /* id + HOPEFULLY 16 octets of challenge + 49 MS-CHAP stuff */\n\t\t\t\tda = attr_tacacs_mschap2_response;\n\t\t\t\tchallenge = attr_tacacs_mschap_challenge;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t *\tIf we have enough data, decode it as\n\t\t\t *\tthe claimed authentication type.\n\t\t\t *\n\t\t\t *\tOtherwise, decode the entire field as an unknown\n\t\t\t *\tattribute.\n\t\t\t */\n\t\t\tif (raw || (pkt->authen_start.data_len < want)) {\n\t\t\t\tfr_dict_attr_t *da_unknown;\n\n\t\t\t\tda_unknown = fr_dict_unknown_attr_afrom_da(ctx, attr_tacacs_data);\n\t\t\t\tif (!da_unknown) goto fail;\n\n\t\t\t\tda_unknown->flags.is_raw = 1;\n\t\t\t\twant = pkt->authen_start.data_len;\n\n\t\t\t\tDECODE_FIELD_STRING8(da_unknown, want);\n\t\t\t\ttalloc_free(da_unknown);\n\n\t\t\t} else if (!challenge) {\n\t\t\t\tDECODE_FIELD_STRING8(da, want);\n\n\t\t\t} else if (pkt->authen_start.data_len == want)  {\n\t\t\t\tfr_strerror_printf(\"%s has zero length\", challenge->name);\n\t\t\t\tgoto fail;\n\n\t\t\t} else { /* 1 of ID + ??? of challenge + (want-1) of data */\n\t\t\t\tuint8_t challenge_len = pkt->authen_start.data_len - want;\n\t\t\t\tuint8_t hash[50];\n\n\t\t\t\t/*\n\t\t\t\t *\tRework things to make sense.\n\t\t\t\t */\n\t\t\t\thash[0] = p[0];\n\t\t\t\tmemcpy(hash + 1, p + 1 + challenge_len, want - 1);\n\n\t\t\t\tvp = fr_pair_afrom_da(ctx, da);\n\t\t\t\tif (!vp) goto fail;\n\n\t\t\t\tfr_pair_append(out, vp);\n\n\t\t\t\t/*\n\t\t\t\t *\tID + hash\n\t\t\t\t */\n\t\t\t\tif (fr_pair_value_memdup(vp, hash, want, true) < 0) goto fail;\n\n\t\t\t\t/*\n\t\t\t\t *\tAnd then the challenge.\n\t\t\t\t */\n\t\t\t\tvp = fr_pair_afrom_da(ctx, challenge);\n\t\t\t\tif (!vp) goto fail;\n\n\t\t\t\tfr_pair_append(out, vp);\n\n\t\t\t\tif (fr_pair_value_memdup(vp, p + 1, challenge_len, true) < 0) goto fail;\n\n\t\t\t\tp += pkt->authen_start.data_len;\n\t\t\t}\n\n\t\t} else if (packet_is_authen_continue(pkt)) {\n\t\t\t/*\n\t\t\t * 4.3. The Authentication CONTINUE Packet Body\n\t\t\t *\n\t\t\t * This packet is sent from the client to the server following the receipt of\n\t\t\t * a REPLY packet.\n\t\t\t *\n\t\t\t *  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |          user_msg len           |            data_len             |\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |     flags      |  user_msg ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |    data ...\n\t\t\t * +----------------+\n\t\t\t */\n\n\t\t\t/*\n\t\t\t *\tVersion 1 is ONLY used for PAP / CHAP\n\t\t\t *\t/ MS-CHAP start and reply packets.\n\t\t\t */\n\t\t\tif (pkt->hdr.ver.minor != 0) {\n\t\t\tinvalid_version:\n\t\t\t\tfr_strerror_const(\"Invalid TACACS+ version\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tPACKET_HEADER_CHECK(\"Authentication-Continue\", pkt->authen_cont);\n\t\t\tdata_len += fr_nbo_to_uint16(p) + fr_nbo_to_uint16(p + 2);\n\t\t\tif (data_len > (size_t) (end - p)) goto overflow;\n\t\t\tif (data_len < (size_t) (end - p)) goto underflow;\n\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_packet_body_type, FR_PACKET_BODY_TYPE_CONTINUE);\n\n\t\t\t/*\n\t\t\t *\tDecode 2 fields, based on their \"length\"\n\t\t\t */\n\t\t\tp = body;\n\t\t\tDECODE_FIELD_STRING16(attr_tacacs_user_message, pkt->authen_cont.user_msg_len);\n\t\t\tDECODE_FIELD_STRING16(attr_tacacs_data, pkt->authen_cont.data_len);\n\n\t\t\t/*\n\t\t\t *\tAnd finally the flags.\n\t\t\t */\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_authentication_continue_flags, pkt->authen_cont.flags);\n\n\t\t} else if (packet_is_authen_reply(pkt)) {\n\t\t\t/*\n\t\t\t * 4.2. The Authentication REPLY Packet Body\n\t\t\t *\n\t\t\t * 1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |     status     |      flags     |        server_msg_len           |\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |           data_len              |        server_msg ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |           data ...\n\t\t\t * +----------------+----------------+\n\t\t\t */\n\n\t\t\t/*\n\t\t\t *\tWe don't care about versions for replies.\n\t\t\t *\tWe just echo whatever was sent in the request.\n\t\t\t */\n\t\t\tPACKET_HEADER_CHECK(\"Authentication-Reply\", pkt->authen_reply);\n\t\t\tdata_len += fr_nbo_to_uint16(p + 2) + fr_nbo_to_uint16(p + 4);\n\t\t\tif (data_len > (size_t) (end - p)) goto overflow;\n\t\t\tif (data_len < (size_t) (end - p)) goto underflow;\n\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_packet_body_type, FR_PACKET_BODY_TYPE_REPLY);\n\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_authentication_status, pkt->authen_reply.status);\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_authentication_flags, pkt->authen_reply.flags);\n\n\t\t\t/*\n\t\t\t *\tDecode 2 fields, based on their \"length\"\n\t\t\t */\n\t\t\tp = body;\n\t\t\tDECODE_FIELD_STRING16(attr_tacacs_server_message, pkt->authen_reply.server_msg_len);\n\t\t\tDECODE_FIELD_STRING16(attr_tacacs_data, pkt->authen_reply.data_len);\n\n\t\t} else {\n\t\t\tfr_strerror_const(\"Unknown authentication packet\");\n\t\t\tgoto fail;\n\t\t}\n\t\tbreak;\n\n\tcase FR_TAC_PLUS_AUTHOR:\n\t\tif (packet_is_author_request(pkt)) {\n\t\t\t/*\n\t\t\t * 5.1. The Authorization REQUEST Packet Body\n\t\t\t *\n\t\t\t *  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |  authen_method |    priv_lvl    |  authen_type   | authen_service |\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |    user_len    |    port_len    |  rem_addr_len  |    arg_cnt     |\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   arg_1_len    |   arg_2_len    |      ...       |   arg_N_len    |\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   user ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   port ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   rem_addr ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   arg_1 ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   arg_2 ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   arg_N ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t */\n\n\t\t\tif (pkt->hdr.ver.minor != 0) goto invalid_version;\n\n\t\t\tPACKET_HEADER_CHECK(\"Authorization-Request\", pkt->author_req);\n\t\t\tdata_len += p[4] + p[5] + p[6] + p[7];\n\n\t\t\tARG_COUNT_CHECK(\"Authorization-Request\", pkt->author_req);\n\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_packet_body_type, FR_PACKET_BODY_TYPE_REQUEST);\n\n\t\t\t/*\n\t\t\t *\tDecode 4 octets of various flags.\n\t\t\t */\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_authentication_method, pkt->author_req.authen_method);\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_privilege_level, pkt->author_req.priv_lvl);\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_authentication_type, pkt->author_req.authen_type);\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_authentication_service, pkt->author_req.authen_service);\n\n\t\t\t/*\n\t\t\t *\tDecode 3 fields, based on their \"length\"\n\t\t\t */\n\t\t\tp = body;\n\t\t\tDECODE_FIELD_STRING8(attr_tacacs_user_name, pkt->author_req.user_len);\n\t\t\tDECODE_FIELD_STRING8(attr_tacacs_client_port, pkt->author_req.port_len);\n\t\t\tDECODE_FIELD_STRING8(attr_tacacs_remote_address, pkt->author_req.rem_addr_len);\n\n\t\t\t/*\n\t\t\t *\tDecode 'arg_N' arguments (horrible format)\n\t\t\t */\n\t\t\tif (tacacs_decode_args(ctx, out, attr_tacacs_argument_list,\n\t\t\t\t\t       pkt->author_req.arg_cnt, argv, attrs, end) < 0) goto fail;\n\n\t\t} else if (packet_is_author_reply(pkt)) {\n\t\t\t/*\n\t\t\t * 5.2. The Authorization RESPONSE Packet Body\n\t\t\t *\n\t\t\t *  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |    status      |     arg_cnt    |         server_msg len          |\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * +            data_len             |    arg_1_len   |    arg_2_len   |\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |      ...       |   arg_N_len    |         server_msg ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   data ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   arg_1 ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   arg_2 ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   arg_N ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t */\n\n\t\t\t/*\n\t\t\t *\tWe don't care about versions for replies.\n\t\t\t *\tWe just echo whatever was sent in the request.\n\t\t\t */\n\n\t\t\tPACKET_HEADER_CHECK(\"Authorization-Reply\", pkt->author_reply);\n\t\t\tdata_len += p[1] + fr_nbo_to_uint16(p + 2) + fr_nbo_to_uint16(p + 4);\n\n\t\t\tARG_COUNT_CHECK(\"Authorization-Reply\", pkt->author_reply);\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_packet_body_type, FR_PACKET_BODY_TYPE_RESPONSE);\n\n\t\t\t/*\n\t\t\t *\tDecode 1 octets\n\t\t\t */\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_authorization_status, pkt->author_reply.status);\n\n\t\t\t/*\n\t\t\t *\tDecode 2 fields, based on their \"length\"\n\t\t\t */\n\t\t\tp = body;\n\t\t\tDECODE_FIELD_STRING16(attr_tacacs_server_message, pkt->author_reply.server_msg_len);\n\t\t\tDECODE_FIELD_STRING16(attr_tacacs_data, pkt->author_reply.data_len);\n\n\t\t\t/*\n\t\t\t *\tDecode 'arg_N' arguments (horrible format)\n\t\t\t */\n\t\t\tif (tacacs_decode_args(ctx, out, attr_tacacs_argument_list,\n\t\t\t\t\tpkt->author_reply.arg_cnt, argv, attrs, end) < 0) goto fail;\n\n\t\t} else {\n\t\t\tfr_strerror_const(\"Unknown authorization packet\");\n\t\t\tgoto fail;\n\t\t}\n\t\tbreak;\n\n\tcase FR_TAC_PLUS_ACCT:\n\t\tif (packet_is_acct_request(pkt)) {\n\t\t\t/**\n\t\t\t * 6.1. The Account REQUEST Packet Body\n\t\t\t *\n\t\t\t 1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |      flags     |  authen_method |    priv_lvl    |  authen_type   |\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * | authen_service |    user_len    |    port_len    |  rem_addr_len  |\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |    arg_cnt     |   arg_1_len    |   arg_2_len    |      ...       |\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   arg_N_len    |    user ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   port ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   rem_addr ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   arg_1 ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   arg_2 ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |   arg_N ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t */\n\n\t\t\tif (pkt->hdr.ver.minor != 0) goto invalid_version;\n\n\t\t\tPACKET_HEADER_CHECK(\"Accounting-Request\", pkt->acct_req);\n\t\t\tdata_len += p[5] + p[6] + p[7] + p[8];\n\t\t\tif (data_len > (size_t) (end - p)) goto overflow;\n\t\t\t/* can't check for underflow, as we have argv[argc] */\n\n\t\t\tARG_COUNT_CHECK(\"Accounting-Request\", pkt->acct_req);\n\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_packet_body_type, FR_PACKET_BODY_TYPE_REQUEST);\n\n\t\t\t/*\n\t\t\t *\tDecode 5 octets of various flags.\n\t\t\t */\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_accounting_flags, pkt->acct_req.flags);\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_authentication_method, pkt->acct_req.authen_method);\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_privilege_level, pkt->acct_req.priv_lvl);\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_authentication_type, pkt->acct_req.authen_type);\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_authentication_service, pkt->acct_req.authen_service);\n\n\t\t\t/*\n\t\t\t *\tDecode 3 fields, based on their \"length\"\n\t\t\t */\n\t\t\tp = body;\n\t\t\tDECODE_FIELD_STRING8(attr_tacacs_user_name, pkt->acct_req.user_len);\n\t\t\tDECODE_FIELD_STRING8(attr_tacacs_client_port, pkt->acct_req.port_len);\n\t\t\tDECODE_FIELD_STRING8(attr_tacacs_remote_address, pkt->acct_req.rem_addr_len);\n\n\t\t\t/*\n\t\t\t *\tDecode 'arg_N' arguments (horrible format)\n\t\t\t */\n\t\t\tif (tacacs_decode_args(ctx, out, attr_tacacs_argument_list,\n\t\t\t\t\tpkt->acct_req.arg_cnt, argv, attrs, end) < 0) goto fail;\n\n\t\t} else if (packet_is_acct_reply(pkt)) {\n\t\t\t/**\n\t\t\t * 6.2. The Accounting REPLY Packet Body\n\t\t\t *\n\t\t\t * 1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |         server_msg len          |            data_len             |\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |     status     |         server_msg ...\n\t\t\t * +----------------+----------------+----------------+----------------+\n\t\t\t * |     data ...\n\t\t\t * +----------------+\n\t\t\t */\n\n\t\t\t/*\n\t\t\t *\tWe don't care about versions for replies.\n\t\t\t *\tWe just echo whatever was sent in the request.\n\t\t\t */\n\n\t\t\tPACKET_HEADER_CHECK(\"Accounting-Reply\", pkt->acct_reply);\n\t\t\tdata_len += fr_nbo_to_uint16(p) + fr_nbo_to_uint16(p + 2);\n\t\t\tif (data_len > (size_t) (end - p)) goto overflow;\n\t\t\tif (data_len < (size_t) (end - p)) goto underflow;\n\n\t\t\tp = BODY(acct_reply);\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_packet_body_type, FR_PACKET_BODY_TYPE_REPLY);\n\n\t\t\t/*\n\t\t\t *\tDecode 2 fields, based on their \"length\"\n\t\t\t */\n\t\t\tDECODE_FIELD_STRING16(attr_tacacs_server_message, pkt->acct_reply.server_msg_len);\n\t\t\tDECODE_FIELD_STRING16(attr_tacacs_data, pkt->acct_reply.data_len);\n\n\t\t\t/* Decode 1 octet */\n\t\t\tDECODE_FIELD_UINT8(attr_tacacs_accounting_status, pkt->acct_reply.status);\n\t\t} else {\n\t\t\tfr_strerror_const(\"Unknown accounting packet\");\n\t\t\tgoto fail;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tfr_strerror_printf(\"decode: Unsupported packet type %u\", pkt->hdr.type);\n\t\tgoto fail;\n\t}\n\n\ttalloc_free(decrypted);\n\treturn buffer_len;\n}\nstatic ssize_t fr_tacacs_decode_proto(TALLOC_CTX *ctx, fr_pair_list_t *out, uint8_t const *data, size_t data_len, void *proto_ctx)\n{\n\tfr_tacacs_ctx_t\t*test_ctx = talloc_get_type_abort(proto_ctx, fr_tacacs_ctx_t);\n\n\treturn fr_tacacs_decode(ctx, out, data, data_len, NULL,\n\t\t\t\ttest_ctx->secret, (talloc_array_length(test_ctx->secret)-1), false);\n}\nint LLVMFuzzerTestOneInput(const uint8_t *buf, size_t len)\n{\n\tTALLOC_CTX *   ctx = talloc_init_const(\"fuzzer\");\n\tfr_pair_list_t vps;\n\tvoid *decode_ctx = NULL;\n\n\tfr_pair_list_init(&vps);\n\tif (!init) LLVMFuzzerInitialize(NULL, NULL);\n\n\tif (tp->test_ctx && (tp->test_ctx(&decode_ctx, NULL) < 0)) {\n\t\tfr_perror(\"fuzzer: Failed initializing test point decode_ctx\");\n\t\tfr_exit_now(EXIT_FAILURE);\n\t}\n\n\ttp->func(ctx, &vps, buf, len, decode_ctx);\n\tif (fr_debug_lvl > 3) fr_pair_list_debug(&vps);\n\n\ttalloc_free(decode_ctx);\n\ttalloc_free(ctx);\n\n\t/*\n\t *\tClear error messages from the run.  Clearing these\n\t *\tkeeps malloc/free balanced, which helps to avoid the\n\t *\tfuzzers leak heuristics from firing.\n\t */\n\tfr_strerror_clear();\n\n\treturn 0;\n}",
    "target": 0,
    "idx": 2055982
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "static int fuzz_reader_connect(sc_reader_t *reader)\n{\n    uint16_t chunk_size;\n    const uint8_t *chunk;\n\n    fuzz_get_chunk(reader, &chunk, &chunk_size);\n\n    if (chunk_size > SC_MAX_ATR_SIZE)\n        chunk_size = SC_MAX_ATR_SIZE;\n    else\n        reader->atr.len = chunk_size;\n\n    if (chunk_size > 0)\n        memcpy(reader->atr.value, chunk, chunk_size);\n\n    return SC_SUCCESS;\n}\nint sc_connect_card(sc_reader_t *reader, sc_card_t **card_out)\n{\n\tsc_card_t *card;\n\tsc_context_t *ctx;\n\tstruct sc_card_driver *driver;\n\tint i, r = 0, idx, connected = 0;\n\n\tif (card_out == NULL || reader == NULL)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\tctx = reader->ctx;\n\tSC_FUNC_CALLED(ctx, SC_LOG_DEBUG_VERBOSE);\n\tif (reader->ops->connect == NULL)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_NOT_SUPPORTED);\n\n\tcard = sc_card_new(ctx);\n\tif (card == NULL)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY);\n\tr = reader->ops->connect(reader);\n\tif (r)\n\t\tgoto err;\n\n\tconnected = 1;\n\tcard->reader = reader;\n\tcard->ctx = ctx;\n\n\tif (reader->flags & SC_READER_ENABLE_ESCAPE)\n\t\tsc_detect_escape_cmds(reader);\n\n\tmemcpy(&card->atr, &reader->atr, sizeof(card->atr));\n\tmemcpy(&card->uid, &reader->uid, sizeof(card->uid));\n\n\t_sc_parse_atr(reader);\n\n\t/* See if the ATR matches any ATR specified in the config file */\n\tif ((driver = ctx->forced_driver) == NULL) {\n\t\tsc_log(ctx, \"matching configured ATRs\");\n\t\tfor (i = 0; ctx->card_drivers[i] != NULL; i++) {\n\t\t\tdriver = ctx->card_drivers[i];\n\n\t\t\tif (driver->atr_map == NULL ||\n\t\t\t    !strcmp(driver->short_name, \"default\")) {\n\t\t\t\tdriver = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsc_log(ctx, \"trying driver '%s'\", driver->short_name);\n\t\t\tidx = _sc_match_atr(card, driver->atr_map, NULL);\n\t\t\tif (idx >= 0) {\n\t\t\t\tstruct sc_atr_table *src = &driver->atr_map[idx];\n\n\t\t\t\tsc_log(ctx, \"matched driver '%s'\", driver->name);\n\t\t\t\t/* It's up to card driver to notice these correctly */\n\t\t\t\tcard->name = src->name;\n\t\t\t\tcard->type = src->type;\n\t\t\t\tcard->flags = src->flags;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdriver = NULL;\n\t\t}\n\t}\n\n\tif (driver != NULL) {\n\t\t/* Forced driver, or matched via ATR mapping from config file */\n\t\tcard->driver = driver;\n\n\t\tmemcpy(card->ops, card->driver->ops, sizeof(struct sc_card_operations));\n\t\tif (card->ops->match_card != NULL)\n\t\t\tif (card->ops->match_card(card) != 1)\n\t\t\t\tsc_log(ctx, \"driver '%s' match_card() failed: %s (will continue anyway)\", card->driver->name, sc_strerror(r));\n\n\t\tif (card->ops->init != NULL) {\n\t\t\tr = card->ops->init(card);\n\t\t\tif (r) {\n\t\t\t\tsc_log(ctx, \"driver '%s' init() failed: %s\", card->driver->name, sc_strerror(r));\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tsc_card_t uninitialized = *card;\n\t\tsc_log(ctx, \"matching built-in ATRs\");\n\t\tfor (i = 0; ctx->card_drivers[i] != NULL; i++) {\n\t\t\t/* FIXME If we had a clean API description, we'd propably get a\n\t\t\t * cleaner implementation of the driver's match_card and init,\n\t\t\t * which should normally *not* modify the card object if\n\t\t\t * unsuccessful. However, after years of relentless hacking, reality\n\t\t\t * is different: The card object is changed in virtually every card\n\t\t\t * driver so in order to prevent unwanted interaction, we reset the\n\t\t\t * card object here and hope that the card driver at least doesn't\n\t\t\t * allocate any internal ressources that need to be freed. If we\n\t\t\t * had more time, we should refactor the existing code to not\n\t\t\t * modify sc_card_t until complete success (possibly by combining\n\t\t\t * `match_card()` and `init()`) */\n\t\t\t*card = uninitialized;\n\n\t\t\tstruct sc_card_driver *drv = ctx->card_drivers[i];\n\t\t\tconst struct sc_card_operations *ops = drv->ops;\n\n\t\t\tsc_log(ctx, \"trying driver '%s'\", drv->short_name);\n\t\t\tif (ops == NULL || ops->match_card == NULL)   {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (!(ctx->flags & SC_CTX_FLAG_ENABLE_DEFAULT_DRIVER)\n\t\t\t\t   \t&& !strcmp(\"default\", drv->short_name))   {\n\t\t\t\tsc_log(ctx , \"ignore 'default' card driver\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Needed if match_card() needs to talk with the card (e.g. card-muscle) */\n\t\t\t*card->ops = *ops;\n\t\t\tif (ops->match_card(card) != 1)\n\t\t\t\tcontinue;\n\t\t\tsc_log(ctx, \"matched: %s\", drv->name);\n\t\t\tmemcpy(card->ops, ops, sizeof(struct sc_card_operations));\n\t\t\tcard->driver = drv;\n\t\t\tr = ops->init(card);\n\t\t\tif (r) {\n\t\t\t\tsc_log(ctx, \"driver '%s' init() failed: %s\", drv->name, sc_strerror(r));\n\t\t\t\tif (r == SC_ERROR_INVALID_CARD) {\n\t\t\t\t\tcard->driver = NULL;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (card->driver == NULL) {\n\t\tsc_log(ctx, \"unable to find driver for inserted card\");\n\t\tr = SC_ERROR_INVALID_CARD;\n\t\tgoto err;\n\t}\n\tif (card->name == NULL)\n\t\tcard->name = card->driver->name;\n\n\t/* initialize max_send_size/max_recv_size to a meaningful value */\n\tcard->max_recv_size = sc_get_max_recv_size(card);\n\tcard->max_send_size = sc_get_max_send_size(card);\n\n\tsc_log(ctx,\n\t       \"card info name:'%s', type:%i, flags:0x%lX, max_send/recv_size:%\"SC_FORMAT_LEN_SIZE_T\"u/%\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t       card->name, card->type, card->flags, card->max_send_size,\n\t       card->max_recv_size);\n\n#ifdef ENABLE_SM\n        /* Check, if secure messaging module present. */\n\tr = sc_card_sm_check(card);\n\tif (r)   {\n\t\tsc_log(ctx, \"cannot load secure messaging module\");\n\t\tgoto err;\n\t}\n#endif\n\t*card_out = card;\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\nerr:\n\tif (connected)\n\t\treader->ops->disconnect(reader);\n\tif (card != NULL)\n\t\tsc_card_free(card);\n\tLOG_FUNC_RETURN(ctx, r);\n}\nint LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size)\n{\n    struct sc_context *ctx = NULL;\n    struct sc_card *card = NULL;\n    struct sc_pkcs15_card *p15card = NULL;\n    struct sc_reader *reader;\n    struct sc_pkcs15_object *obj;\n\n    sc_establish_context(&ctx, \"fuzz\");\n    if (!ctx)\n        return 0;\n    /* copied from sc_release_context() */\n    while (list_size(&ctx->readers)) {\n        sc_reader_t *rdr = (sc_reader_t *) list_get_at(&ctx->readers, 0);\n        _sc_delete_reader(ctx, rdr);\n    }\n    if (ctx->reader_driver->ops->finish != NULL)\n        ctx->reader_driver->ops->finish(ctx);\n\n    ctx->reader_driver = sc_get_fuzz_driver();\n\n    fuzz_add_reader(ctx, Data, Size);\n\n    reader = sc_ctx_get_reader(ctx, 0);\n    sc_connect_card(reader, &card);\n    sc_pkcs15_bind(card, NULL, &p15card);\n\n    if (p15card) {\n        const uint8_t *in, *param;\n        uint16_t in_len, param_len;\n        fuzz_get_chunk(reader, &in, &in_len);\n        fuzz_get_chunk(reader, &param, &param_len);\n        for (obj = p15card->obj_list; obj != NULL; obj = obj->next) {\n            u8 buf[0xFFFF];\n            size_t i;\n\n            int decipher_flags[] = {SC_ALGORITHM_RSA_RAW,\n                SC_ALGORITHM_RSA_PAD_PKCS1, SC_ALGORITHM_RSA_PAD_ANSI,\n                SC_ALGORITHM_RSA_PAD_ISO9796};\n            for (i = 0; i < sizeof decipher_flags/sizeof *decipher_flags; i++) {\n                sc_pkcs15_decipher(p15card, obj, decipher_flags[i],\n                        in, in_len, buf, sizeof buf);\n            }\n\n            i = sizeof buf;\n            sc_pkcs15_derive(p15card, obj, 0,\n                    in, in_len, buf, &i);\n\n            int wrap_flags[] = {0, SC_ALGORITHM_AES_ECB, SC_ALGORITHM_AES_CBC_PAD,\n                SC_ALGORITHM_AES_CBC};\n            for (i = 0; i < sizeof wrap_flags/sizeof *wrap_flags; i++) {\n                /* see `pkcs15_create_secret_key` in\n                 * `src/pkcs11/framework-pkc15.c` for creating a temporary\n                 * secret key for wrapping/unwrapping */\n                unsigned long l = sizeof buf;\n                struct sc_pkcs15_object target_key;\n                struct sc_pkcs15_skey_info skey_info;\n                uint16_t len;\n                memset(&target_key, 0, sizeof target_key);\n                memset(&skey_info, 0, sizeof skey_info);\n                target_key.type = SC_PKCS15_TYPE_SKEY;\n                target_key.flags = 2; /* TODO not sure what these mean */\n                target_key.session_object = 1;\n                target_key.data = &skey_info;\n                skey_info.usage = SC_PKCS15_PRKEY_USAGE_UNWRAP | SC_PKCS15_PRKEY_USAGE_WRAP\n                    | SC_PKCS15_PRKEY_USAGE_ENCRYPT | SC_PKCS15_PRKEY_USAGE_DECRYPT;\n                skey_info.native = 0; /* card can not use this */\n                skey_info.access_flags = 0; /* looks like not needed */\n                skey_info.key_type = 0x1fUL; /* CKK_AES */\n                skey_info.value_len = 128;\n                fuzz_get_chunk(reader, (const u8 **) &skey_info.data.value, &len);\n                skey_info.data.len = len;\n\n                sc_pkcs15_unwrap(p15card, obj, &target_key, wrap_flags[i],\n                        in, in_len, param, param_len);\n                sc_pkcs15_wrap(p15card, obj, &target_key, wrap_flags[i],\n                        buf, &l, in, in_len);\n            }\n\n            int signature_flags[] = {SC_ALGORITHM_RSA_RAW,\n                SC_ALGORITHM_RSA_PAD_PKCS1, SC_ALGORITHM_RSA_PAD_ANSI,\n                SC_ALGORITHM_RSA_PAD_ISO9796,\n                SC_ALGORITHM_RSA_PAD_PSS|SC_ALGORITHM_MGF1_SHA1,\n                SC_ALGORITHM_RSA_PAD_PSS|SC_ALGORITHM_MGF1_SHA256,\n                SC_ALGORITHM_RSA_PAD_PSS|SC_ALGORITHM_MGF1_SHA384,\n                SC_ALGORITHM_RSA_PAD_PSS|SC_ALGORITHM_MGF1_SHA512,\n                SC_ALGORITHM_RSA_PAD_PSS|SC_ALGORITHM_MGF1_SHA224,\n                SC_ALGORITHM_ECDSA_RAW, SC_ALGORITHM_ECDSA_HASH_SHA1,\n                SC_ALGORITHM_ECDSA_HASH_SHA224, SC_ALGORITHM_ECDSA_HASH_SHA256,\n                SC_ALGORITHM_ECDSA_HASH_SHA384, SC_ALGORITHM_ECDSA_HASH_SHA512,\n                SC_ALGORITHM_GOSTR3410_RAW, SC_ALGORITHM_GOSTR3410_HASH_GOSTR3411,\n                SC_ALGORITHM_GOSTR3410_HASHES,\n            };\n            for (i = 0; i < sizeof signature_flags/sizeof *signature_flags; i++) {\n                sc_pkcs15_compute_signature(p15card, obj, signature_flags[i],\n                        in, in_len, buf, sizeof buf);\n            }\n\n            if (obj->type == SC_PKCS15_TYPE_AUTH_PIN) {\n                sc_pkcs15_verify_pin(p15card, obj, in, in_len);\n                sc_pkcs15_change_pin(p15card, obj, in, in_len, param, param_len);\n                sc_pkcs15_unblock_pin(p15card, obj, in, in_len, param, param_len);\n                sc_pkcs15_get_pin_info(p15card, obj);\n            }\n        }\n        sc_pkcs15_card_free(p15card);\n    }\n\n    sc_disconnect_card(card);\n    sc_release_context(ctx);\n\n    return 0;\n}",
    "target": 0,
    "idx": 2020188
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "static PIX *\npixReadFromTiffStream(TIFF  *tif)\n{\nchar      *text;\nl_uint8   *linebuf, *data, *rowptr;\nl_uint16   spp, bps, photometry, tiffcomp, orientation, sample_fmt;\nl_uint16  *redmap, *greenmap, *bluemap;\nl_int32    d, wpl, bpl, comptype, i, j, k, ncolors, rval, gval, bval, aval;\nl_int32    xres, yres;\nl_uint32   w, h, tiffbpl, tiffword, read_oriented;\nl_uint32  *line, *ppixel, *tiffdata, *pixdata;\nPIX       *pix, *pix1;\nPIXCMAP   *cmap;\n\n    PROCNAME(\"pixReadFromTiffStream\");\n\n    if (!tif)\n        return (PIX *)ERROR_PTR(\"tif not defined\", procName, NULL);\n\n    read_oriented = 0;\n\n        /* Only accept uint image data:\n         *   SAMPLEFORMAT_UINT = 1;\n         *   SAMPLEFORMAT_INT = 2;\n         *   SAMPLEFORMAT_IEEEFP = 3;\n         *   SAMPLEFORMAT_VOID = 4;   */\n    TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLEFORMAT, &sample_fmt);\n    if (sample_fmt != SAMPLEFORMAT_UINT) {\n        L_ERROR(\"sample format = %d is not uint\\n\", procName, sample_fmt);\n        return NULL;\n    }\n\n        /* Can't read tiff in tiled format. For what is involved, see, e.g:\n         *   https://www.cs.rochester.edu/~nelson/courses/vision/\\\n         *     resources/tiff/libtiff.html#Tiles\n         * A tiled tiff can be converted to a normal (strip) tif:\n         *   tiffcp -s <input-tiled-tif> <output-strip-tif>    */\n    if (TIFFIsTiled(tif)) {\n        L_ERROR(\"tiled format is not supported\\n\", procName);\n        return NULL;\n    }\n\n        /* Use default fields for bps and spp */\n    TIFFGetFieldDefaulted(tif, TIFFTAG_BITSPERSAMPLE, &bps);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &spp);\n    if (bps != 1 && bps != 2 && bps != 4 && bps != 8 && bps != 16) {\n        L_ERROR(\"invalid bps = %d\\n\", procName, bps);\n        return NULL;\n    }\n    if (spp == 2 && bps != 8) {\n        L_WARNING(\"for 2 spp, only handle 8 bps\\n\", procName);\n        return NULL;\n    }\n    if (spp == 1)\n        d = bps;\n    else if (spp == 2)  /* gray plus alpha */\n        d = 32;  /* will convert to RGBA */\n    else if (spp == 3 || spp == 4)\n        d = 32;\n    else\n        return (PIX *)ERROR_PTR(\"spp not in set {1,2,3,4}\", procName, NULL);\n\n    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n    if (w > MaxTiffWidth) {\n        L_ERROR(\"width = %d pixels; too large\\n\", procName, w);\n        return NULL;\n    }\n    if (h > MaxTiffHeight) {\n        L_ERROR(\"height = %d pixels; too large\\n\", procName, h);\n        return NULL;\n    }\n    tiffbpl = TIFFScanlineSize(tif);\n    if (tiffbpl != (bps * spp * w + 7) / 8) {\n        L_ERROR(\"invalid tiffbpl: tiffbpl = %d, bps = %d, spp = %d, w = %d\\n\",\n                procName, tiffbpl, bps, spp, w);\n        return NULL;\n    }\n\n    if ((pix = pixCreate(w, h, d)) == NULL)\n        return (PIX *)ERROR_PTR(\"pix not made\", procName, NULL);\n    pixSetInputFormat(pix, IFF_TIFF);\n    data = (l_uint8 *)pixGetData(pix);\n    wpl = pixGetWpl(pix);\n    bpl = 4 * wpl;\n\n    TIFFGetFieldDefaulted(tif, TIFFTAG_COMPRESSION, &tiffcomp);\n\n        /* Thanks to Jeff Breidenbach, we now support reading 8 bpp\n         * images encoded in the long-deprecated old jpeg format,\n         * COMPRESSION_OJPEG.  TIFFReadScanline() fails on this format,\n         * so we use RGBA reading, which generates a 4 spp image, and\n         * pull out the red component. */\n    if (spp == 1 && tiffcomp != COMPRESSION_OJPEG) {\n        linebuf = (l_uint8 *)LEPT_CALLOC(tiffbpl + 1, sizeof(l_uint8));\n        for (i = 0; i < h; i++) {\n            if (TIFFReadScanline(tif, linebuf, i, 0) < 0) {\n                LEPT_FREE(linebuf);\n                pixDestroy(&pix);\n                return (PIX *)ERROR_PTR(\"line read fail\", procName, NULL);\n            }\n            memcpy(data, linebuf, tiffbpl);\n            data += bpl;\n        }\n        if (bps <= 8)\n            pixEndianByteSwap(pix);\n        else   /* bps == 16 */\n            pixEndianTwoByteSwap(pix);\n        LEPT_FREE(linebuf);\n    } else if (spp == 2 && bps == 8) {  /* gray plus alpha */\n        L_INFO(\"gray+alpha is not supported; converting to RGBA\\n\", procName);\n        pixSetSpp(pix, 4);\n        linebuf = (l_uint8 *)LEPT_CALLOC(tiffbpl + 1, sizeof(l_uint8));\n        pixdata = pixGetData(pix);\n        for (i = 0; i < h; i++) {\n            if (TIFFReadScanline(tif, linebuf, i, 0) < 0) {\n                LEPT_FREE(linebuf);\n                pixDestroy(&pix);\n                return (PIX *)ERROR_PTR(\"line read fail\", procName, NULL);\n            }\n            rowptr = linebuf;\n            ppixel = pixdata + i * wpl;\n            for (j = k = 0; j < w; j++) {\n                    /* Copy gray value into r, g and b */\n                SET_DATA_BYTE(ppixel, COLOR_RED, rowptr[k]);\n                SET_DATA_BYTE(ppixel, COLOR_GREEN, rowptr[k]);\n                SET_DATA_BYTE(ppixel, COLOR_BLUE, rowptr[k++]);\n                SET_DATA_BYTE(ppixel, L_ALPHA_CHANNEL, rowptr[k++]);\n                ppixel++;\n            }\n        }\n        LEPT_FREE(linebuf);\n    } else {  /* rgb, rgba, or old jpeg */\n        if ((tiffdata = (l_uint32 *)LEPT_CALLOC((size_t)w * h,\n                                                 sizeof(l_uint32))) == NULL) {\n            pixDestroy(&pix);\n            return (PIX *)ERROR_PTR(\"calloc fail for tiffdata\", procName, NULL);\n        }\n            /* TIFFReadRGBAImageOriented() converts to 8 bps */\n        if (!TIFFReadRGBAImageOriented(tif, w, h, tiffdata,\n                                       ORIENTATION_TOPLEFT, 0)) {\n            LEPT_FREE(tiffdata);\n            pixDestroy(&pix);\n            return (PIX *)ERROR_PTR(\"failed to read tiffdata\", procName, NULL);\n        } else {\n            read_oriented = 1;\n        }\n\n        if (spp == 1) {  /* 8 bpp, old jpeg format */\n            if (pixGetDepth(pix) != 8) {\n                LEPT_FREE(tiffdata);\n                pixDestroy(&pix);\n                return (PIX *)ERROR_PTR(\"invalid ojpeg file\", procName, NULL);\n            }\n            pixdata = pixGetData(pix);\n            for (i = 0; i < h; i++) {\n                line = pixdata + i * wpl;\n                for (j = 0; j < w; j++) {\n                    tiffword = tiffdata[i * w + j];\n                    rval = TIFFGetR(tiffword);\n                    SET_DATA_BYTE(line, j, rval);\n                }\n            }\n        } else {  /* rgb or rgba */\n            if (spp == 4) pixSetSpp(pix, 4);\n            line = pixGetData(pix);\n            for (i = 0; i < h; i++, line += wpl) {\n                for (j = 0, ppixel = line; j < w; j++) {\n                        /* TIFFGet* are macros */\n                    tiffword = tiffdata[i * w + j];\n                    rval = TIFFGetR(tiffword);\n                    gval = TIFFGetG(tiffword);\n                    bval = TIFFGetB(tiffword);\n                    if (spp == 3) {\n                        composeRGBPixel(rval, gval, bval, ppixel);\n                    } else {  /* spp == 4 */\n                        aval = TIFFGetA(tiffword);\n                        composeRGBAPixel(rval, gval, bval, aval, ppixel);\n                    }\n                    ppixel++;\n                }\n            }\n        }\n        LEPT_FREE(tiffdata);\n    }\n\n    if (getTiffStreamResolution(tif, &xres, &yres) == 0) {\n        pixSetXRes(pix, xres);\n        pixSetYRes(pix, yres);\n    }\n\n        /* Find and save the compression type */\n    TIFFGetFieldDefaulted(tif, TIFFTAG_COMPRESSION, &tiffcomp);\n    comptype = getTiffCompressedFormat(tiffcomp);\n    pixSetInputFormat(pix, comptype);\n\n    if (TIFFGetField(tif, TIFFTAG_COLORMAP, &redmap, &greenmap, &bluemap)) {\n            /* Save the colormap as a pix cmap.  Because the\n             * tiff colormap components are 16 bit unsigned,\n             * and go from black (0) to white (0xffff), the\n             * the pix cmap takes the most significant byte. */\n        if (bps > 8) {\n            pixDestroy(&pix);\n            return (PIX *)ERROR_PTR(\"colormap size > 256\", procName, NULL);\n        }\n        if ((cmap = pixcmapCreate(bps)) == NULL) {\n            pixDestroy(&pix);\n            return (PIX *)ERROR_PTR(\"colormap not made\", procName, NULL);\n        }\n        ncolors = 1 << bps;\n        for (i = 0; i < ncolors; i++)\n            pixcmapAddColor(cmap, redmap[i] >> 8, greenmap[i] >> 8,\n                            bluemap[i] >> 8);\n        pixSetColormap(pix, cmap);\n\n            /* Remove the colormap for 1 bpp. */\n        if (bps == 1) {\n            pix1 = pixRemoveColormap(pix, REMOVE_CMAP_BASED_ON_SRC);\n            pixDestroy(&pix);\n            pix = pix1;\n        }\n    } else {   /* No colormap: check photometry and invert if necessary */\n        if (!TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometry)) {\n                /* Guess default photometry setting.  Assume min_is_white\n                 * if compressed 1 bpp; min_is_black otherwise. */\n            if (tiffcomp == COMPRESSION_CCITTFAX3 ||\n                tiffcomp == COMPRESSION_CCITTFAX4 ||\n                tiffcomp == COMPRESSION_CCITTRLE ||\n                tiffcomp == COMPRESSION_CCITTRLEW) {\n                photometry = PHOTOMETRIC_MINISWHITE;\n            } else {\n                photometry = PHOTOMETRIC_MINISBLACK;\n            }\n        }\n        if ((d == 1 && photometry == PHOTOMETRIC_MINISBLACK) ||\n            (d == 8 && photometry == PHOTOMETRIC_MINISWHITE))\n            pixInvert(pix, pix);\n    }\n\n    if (TIFFGetField(tif, TIFFTAG_ORIENTATION, &orientation)) {\n        if (orientation >= 1 && orientation <= 8) {\n            struct tiff_transform *transform = (read_oriented) ?\n                &tiff_partial_orientation_transforms[orientation - 1] :\n                &tiff_orientation_transforms[orientation - 1];\n            if (transform->vflip) pixFlipTB(pix, pix);\n            if (transform->hflip) pixFlipLR(pix, pix);\n            if (transform->rotate) {\n                PIX *oldpix = pix;\n                pix = pixRotate90(oldpix, transform->rotate);\n                pixDestroy(&oldpix);\n            }\n        }\n    }\n\n    text = NULL;\n    TIFFGetField(tif, TIFFTAG_IMAGEDESCRIPTION, &text);\n    if (text) pixSetText(pix, text);\n    return pix;\n}\nPIX *\npixReadMemTiff(const l_uint8  *cdata,\n               size_t          size,\n               l_int32         n)\n{\nl_uint8  *data;\nl_int32   i;\nPIX      *pix;\nTIFF     *tif;\n\n    PROCNAME(\"pixReadMemTiff\");\n\n    if (!cdata)\n        return (PIX *)ERROR_PTR(\"cdata not defined\", procName, NULL);\n\n    data = (l_uint8 *)cdata;  /* we're really not going to change this */\n    if ((tif = fopenTiffMemstream(\"tifferror\", \"r\", &data, &size)) == NULL)\n        return (PIX *)ERROR_PTR(\"tiff stream not opened\", procName, NULL);\n\n    pix = NULL;\n    for (i = 0; ; i++) {\n        if (i == n) {\n            if ((pix = pixReadFromTiffStream(tif)) == NULL) {\n                TIFFClose(tif);\n                return NULL;\n            }\n            pixSetInputFormat(pix, IFF_TIFF);\n            break;\n        }\n        if (TIFFReadDirectory(tif) == 0)\n            break;\n        if (i == ManyPagesInTiffFile + 1) {\n            L_WARNING(\"big file: more than %d pages\\n\", procName,\n                      ManyPagesInTiffFile);\n        }\n    }\n\n    TIFFClose(tif);\n    return pix;\n}\nPIX *\npixReadMem(const l_uint8  *data,\n           size_t          size)\n{\nl_int32   format, valid;\nPIX      *pix;\nPIXCMAP  *cmap;\n\n    PROCNAME(\"pixReadMem\");\n\n    if (!data)\n        return (PIX *)ERROR_PTR(\"data not defined\", procName, NULL);\n    if (size < 12)\n        return (PIX *)ERROR_PTR(\"size < 12\", procName, NULL);\n    pix = NULL;\n\n    findFileFormatBuffer(data, &format);\n    switch (format)\n    {\n    case IFF_BMP:\n        if ((pix = pixReadMemBmp(data, size)) == NULL )\n            return (PIX *)ERROR_PTR( \"bmp: no pix returned\", procName, NULL);\n        break;\n\n    case IFF_JFIF_JPEG:\n        if ((pix = pixReadMemJpeg(data, size, 0, 1, NULL, 0)) == NULL)\n            return (PIX *)ERROR_PTR( \"jpeg: no pix returned\", procName, NULL);\n        break;\n\n    case IFF_PNG:\n        if ((pix = pixReadMemPng(data, size)) == NULL)\n            return (PIX *)ERROR_PTR(\"png: no pix returned\", procName, NULL);\n        break;\n\n    case IFF_TIFF:\n    case IFF_TIFF_PACKBITS:\n    case IFF_TIFF_RLE:\n    case IFF_TIFF_G3:\n    case IFF_TIFF_G4:\n    case IFF_TIFF_LZW:\n    case IFF_TIFF_ZIP:\n            /* Reading page 0 by default */\n        if ((pix = pixReadMemTiff(data, size, 0)) == NULL)\n            return (PIX *)ERROR_PTR(\"tiff: no pix returned\", procName, NULL);\n        break;\n\n    case IFF_PNM:\n        if ((pix = pixReadMemPnm(data, size)) == NULL)\n            return (PIX *)ERROR_PTR(\"pnm: no pix returned\", procName, NULL);\n        break;\n\n    case IFF_GIF:\n        if ((pix = pixReadMemGif(data, size)) == NULL)\n            return (PIX *)ERROR_PTR(\"gif: no pix returned\", procName, NULL);\n        break;\n\n    case IFF_JP2:\n        if ((pix = pixReadMemJp2k(data, size, 1, NULL, 0, 0)) == NULL)\n            return (PIX *)ERROR_PTR(\"jp2k: no pix returned\", procName, NULL);\n        break;\n\n    case IFF_WEBP:\n        if ((pix = pixReadMemWebP(data, size)) == NULL)\n            return (PIX *)ERROR_PTR(\"webp: no pix returned\", procName, NULL);\n        break;\n\n    case IFF_PS:\n        L_ERROR(\"PostScript reading is not supported\\n\", procName);\n        return NULL;\n\n    case IFF_LPDF:\n        L_ERROR(\"Pdf reading is not supported\\n\", procName);\n        return NULL;\n\n    case IFF_SPIX:\n        if ((pix = pixReadMemSpix(data, size)) == NULL)\n            return (PIX *)ERROR_PTR(\"spix: no pix returned\", procName, NULL);\n        break;\n\n    case IFF_UNKNOWN:\n        return (PIX *)ERROR_PTR(\"Unknown format: no pix returned\",\n                procName, NULL);\n        break;\n    }\n\n        /* Set the input format.  For tiff reading from memory we lose\n         * the actual input format; for 1 bpp, default to G4.  Also\n         * verify that the colormap is valid.  */\n    if (pix) {\n        if (format == IFF_TIFF && pixGetDepth(pix) == 1)\n            format = IFF_TIFF_G4;\n        pixSetInputFormat(pix, format);\n        if ((cmap = pixGetColormap(pix))) {\n            pixcmapIsValid(cmap, &valid);\n            if (!valid) {\n                pixDestroy(&pix);\n                return (PIX *)ERROR_PTR(\"invalid colormap\", procName, NULL);\n            }\n        }\n        pixSetPadBits(pix, 0);\n    }\n    return pix;\n}\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {\n  const int16_t angle = ReadInt16(&data, &size);\n  const int16_t x_center = ReadInt16(&data, &size);\n  const int16_t y_center = ReadInt16(&data, &size);\n\n  // Check for pnm format; this can cause timeouts.\n  // The format checker requires at least 12 bytes.\n  if (size < 12) return EXIT_SUCCESS;\n  int format;\n  findFileFormatBuffer(data, &format);\n  if (format == IFF_PNM) return EXIT_SUCCESS;\n\n  Pix* pix = pixReadMem(reinterpret_cast<const unsigned char*>(data), size);\n  if (pix == nullptr) {\n    return EXIT_SUCCESS;\n  }\n\n  // Never in production\n  if (DebugOutput) {\n    L_INFO(\"w = %d, h = %d, d = %d\\n\", \"fuzzer\",\n           pixGetWidth(pix), pixGetHeight(pix), pixGetDepth(pix));\n  }\n\n  constexpr float deg2rad = M_PI / 180.;\n  Pix* pix_rotated = pixRotateShear(pix, x_center, y_center, deg2rad * angle,\n                                    L_BRING_IN_WHITE);\n  if (pix_rotated) {\n    pixDestroy(&pix_rotated);\n  }\n\n  pixDestroy(&pix);\n  return EXIT_SUCCESS;\n}",
    "target": 0,
    "idx": 2021435
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": true,
    "code": "void LibRaw::kodak_jpeg_load_raw()\n{\n  if (data_size < 1)\n    throw LIBRAW_EXCEPTION_DECODE_JPEG;\n\n  int row, col;\n  struct jpeg_decompress_struct cinfo;\n  struct jpeg_error_mgr pub;\n  cinfo.err = jpeg_std_error(&pub);\n  pub.error_exit = jpegErrorExit_k;\n\n  if (INT64(data_size) >\n          INT64(imgdata.rawparams.max_raw_memory_mb) * INT64(1024 * 1024))\n\t  throw LIBRAW_EXCEPTION_TOOBIG;\n\n  unsigned char *jpg_buf = (unsigned char *)malloc(data_size);\n  std::vector<uchar> pixel_buf(width * 3);\n  jpeg_create_decompress(&cinfo);\n\n  fread(jpg_buf, data_size, 1, ifp);\n  libraw_swab(jpg_buf, data_size);\n  try\n  {\n    jpeg_mem_src(&cinfo, jpg_buf, data_size);\n    int rc = jpeg_read_header(&cinfo, TRUE);\n    if (rc != 1)\n      throw LIBRAW_EXCEPTION_DECODE_JPEG;\n\n    jpeg_start_decompress(&cinfo);\n    if ((cinfo.output_width != width) || (cinfo.output_height * 2 != height) ||\n        (cinfo.output_components != 3))\n    {\n      throw LIBRAW_EXCEPTION_DECODE_JPEG;\n    }\n\n    unsigned char *buf[1];\n    buf[0] = pixel_buf.data();\n\n    while (cinfo.output_scanline < cinfo.output_height)\n    {\n      checkCancel();\n      row = cinfo.output_scanline * 2;\n      jpeg_read_scanlines(&cinfo, buf, 1);\n      unsigned char(*pixel)[3] = (unsigned char(*)[3])buf[0];\n      for (col = 0; col < width; col += 2)\n      {\n        RAW(row + 0, col + 0) = pixel[col + 0][1] << 1;\n        RAW(row + 1, col + 1) = pixel[col + 1][1] << 1;\n        RAW(row + 0, col + 1) = pixel[col][0] + pixel[col + 1][0];\n        RAW(row + 1, col + 0) = pixel[col][2] + pixel[col + 1][2];\n      }\n    }\n  }\n  catch (...)\n  {\n    jpeg_finish_decompress(&cinfo);\n    jpeg_destroy_decompress(&cinfo);\n    free(jpg_buf);\n    throw;\n  }\n  jpeg_finish_decompress(&cinfo);\n  jpeg_destroy_decompress(&cinfo);\n  free(jpg_buf);\n  maximum = 0xff << 1;\n}\nvoid LibRaw::kodak_thumb_loader()\n{\n  INT64 est_datasize =\n      T.theight * T.twidth / 3; // is 0.3 bytes per pixel good estimate?\n  if (ID.toffset < 0)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  if (ID.toffset + est_datasize > ID.input->size() + THUMB_READ_BEYOND)\n    throw LIBRAW_EXCEPTION_IO_EOF;\n\n  if(INT64(T.theight) * INT64(T.twidth) > 1024ULL * 1024ULL * LIBRAW_MAX_THUMBNAIL_MB)\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  if (INT64(T.theight) * INT64(T.twidth) < 64ULL)\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  if(T.twidth < 16 || T.twidth > 8192 || T.theight < 16 || T.theight > 8192)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n  // some kodak cameras\n  ushort s_height = S.height, s_width = S.width, s_iwidth = S.iwidth,\n         s_iheight = S.iheight;\n  ushort s_flags = libraw_internal_data.unpacker_data.load_flags;\n  libraw_internal_data.unpacker_data.load_flags = 12;\n  int s_colors = P1.colors;\n  unsigned s_filters = P1.filters;\n  ushort(*s_image)[4] = imgdata.image;\n\n  S.height = T.theight;\n  S.width = T.twidth;\n  P1.filters = 0;\n\n#define Tformat libraw_internal_data.unpacker_data.thumb_format\n\n\n  if (Tformat == LIBRAW_INTERNAL_THUMBNAIL_KODAK_YCBCR)\n  {\n    S.height += S.height & 1;\n    S.width += S.width & 1;\n  }\n\n  imgdata.image =\n      (ushort(*)[4])calloc(S.iheight * S.iwidth, sizeof(*imgdata.image));\n\n  ID.input->seek(ID.toffset, SEEK_SET);\n  // read kodak thumbnail into T.image[]\n  try\n  {\n      if (Tformat == LIBRAW_INTERNAL_THUMBNAIL_KODAK_YCBCR)\n          kodak_ycbcr_load_raw();\n      else if(Tformat == LIBRAW_INTERNAL_THUMBNAIL_KODAK_RGB)\n        kodak_rgb_load_raw();\n      else if (Tformat == LIBRAW_INTERNAL_THUMBNAIL_KODAK_THUMB)\n        kodak_thumb_load_raw();\n  }\n  catch (...)\n  {\n    free(imgdata.image);\n    imgdata.image = s_image;\n\n    T.twidth = 0;\n    S.width = s_width;\n\n    S.iwidth = s_iwidth;\n    S.iheight = s_iheight;\n\n    T.theight = 0;\n    S.height = s_height;\n\n    T.tcolors = 0;\n    P1.colors = s_colors;\n\n    P1.filters = s_filters;\n    T.tlength = 0;\n    libraw_internal_data.unpacker_data.load_flags = s_flags;\n    return;\n  }\n\n  // from scale_colors\n  {\n    double dmax;\n    float scale_mul[4];\n    int c, val;\n    for (dmax = DBL_MAX, c = 0; c < 3; c++)\n      if (dmax > C.pre_mul[c])\n        dmax = C.pre_mul[c];\n\n    for (c = 0; c < 3; c++)\n      scale_mul[c] = (C.pre_mul[c] / dmax) * 65535.0 / C.maximum;\n    scale_mul[3] = scale_mul[1];\n\n    size_t size = S.height * S.width;\n    for (unsigned i = 0; i < size * 4; i++)\n    {\n      val = imgdata.image[0][i];\n      if (!val)\n        continue;\n      val *= scale_mul[i & 3];\n      imgdata.image[0][i] = CLIP(val);\n    }\n  }\n\n  // from convert_to_rgb\n  ushort *img;\n  int row, col;\n\n  int(*t_hist)[LIBRAW_HISTOGRAM_SIZE] =\n      (int(*)[LIBRAW_HISTOGRAM_SIZE])calloc(sizeof(*t_hist), 4);\n\n  float out[3], out_cam[3][4] = {{2.81761312f, -1.98369181f, 0.166078627f, 0},\n                                 {-0.111855984f, 1.73688626f, -0.625030339f, 0},\n                                 {-0.0379119813f, -0.891268849f, 1.92918086f, 0}};\n\n  for (img = imgdata.image[0], row = 0; row < S.height; row++)\n    for (col = 0; col < S.width; col++, img += 4)\n    {\n      out[0] = out[1] = out[2] = 0;\n      int c;\n      for (c = 0; c < 3; c++)\n      {\n        out[0] += out_cam[0][c] * img[c];\n        out[1] += out_cam[1][c] * img[c];\n        out[2] += out_cam[2][c] * img[c];\n      }\n      for (c = 0; c < 3; c++)\n        img[c] = CLIP((int)out[c]);\n      for (c = 0; c < P1.colors; c++)\n        t_hist[c][img[c] >> 3]++;\n    }\n\n  // from gamma_lut\n  int(*save_hist)[LIBRAW_HISTOGRAM_SIZE] =\n      libraw_internal_data.output_data.histogram;\n  libraw_internal_data.output_data.histogram = t_hist;\n\n  // make curve output curve!\n  ushort *t_curve = (ushort *)calloc(sizeof(C.curve), 1);\n  memmove(t_curve, C.curve, sizeof(C.curve));\n  memset(C.curve, 0, sizeof(C.curve));\n  {\n    int perc, val, total, t_white = 0x2000, c;\n\n    perc = S.width * S.height * 0.01; /* 99th percentile white level */\n    if (IO.fuji_width)\n      perc /= 2;\n    if (!((O.highlight & ~2) || O.no_auto_bright))\n      for (t_white = c = 0; c < P1.colors; c++)\n      {\n        for (val = 0x2000, total = 0; --val > 32;)\n          if ((total += libraw_internal_data.output_data.histogram[c][val]) >\n              perc)\n            break;\n        if (t_white < val)\n          t_white = val;\n      }\n    gamma_curve(O.gamm[0], O.gamm[1], 2, (t_white << 3) / O.bright);\n  }\n\n  libraw_internal_data.output_data.histogram = save_hist;\n  free(t_hist);\n\n  // from write_ppm_tiff - copy pixels into bitmap\n\n  int s_flip = imgdata.sizes.flip;\n  if (imgdata.rawparams.options & LIBRAW_RAWOPTIONS_NO_ROTATE_FOR_KODAK_THUMBNAILS)\n    imgdata.sizes.flip = 0;\n\n  S.iheight = S.height;\n  S.iwidth = S.width;\n  if (S.flip & 4)\n    SWAP(S.height, S.width);\n\n  if (T.thumb)\n    free(T.thumb);\n  T.thumb = (char *)calloc(S.width * S.height, P1.colors);\n  T.tlength = S.width * S.height * P1.colors;\n\n  // from write_tiff_ppm\n  {\n    int soff = flip_index(0, 0);\n    int cstep = flip_index(0, 1) - soff;\n    int rstep = flip_index(1, 0) - flip_index(0, S.width);\n\n    for (int rr = 0; rr < S.height; rr++, soff += rstep)\n    {\n      char *ppm = T.thumb + rr * S.width * P1.colors;\n      for (int cc = 0; cc < S.width; cc++, soff += cstep)\n        for (int c = 0; c < P1.colors; c++)\n          ppm[cc * P1.colors + c] =\n              imgdata.color.curve[imgdata.image[soff][c]] >> 8;\n    }\n  }\n\n  memmove(C.curve, t_curve, sizeof(C.curve));\n  free(t_curve);\n\n  // restore variables\n  free(imgdata.image);\n  imgdata.image = s_image;\n\n  if (imgdata.rawparams.options & LIBRAW_RAWOPTIONS_NO_ROTATE_FOR_KODAK_THUMBNAILS)\n    imgdata.sizes.flip = s_flip;\n\n  T.twidth = S.width;\n  S.width = s_width;\n\n  S.iwidth = s_iwidth;\n  S.iheight = s_iheight;\n\n  T.theight = S.height;\n  S.height = s_height;\n\n  T.tcolors = P1.colors;\n  P1.colors = s_colors;\n\n  P1.filters = s_filters;\n  libraw_internal_data.unpacker_data.load_flags = s_flags;\n}\nvoid LibRaw::kodak_rgb_load_raw()\n{\n  if (!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n  short buf[768], *bp;\n  int row, col, len, c, i, rgb[3], ret;\n  ushort *ip = image[0];\n\n  for (row = 0; row < height; row++)\n  {\n    checkCancel();\n    for (col = 0; col < width; col += 256)\n    {\n      len = MIN(256, width - col);\n      ret = kodak_65000_decode(buf, len * 3);\n      memset(rgb, 0, sizeof rgb);\n      for (bp = buf, i = 0; i < len; i++, ip += 4)\n        if (load_flags == 12)\n          FORC3 ip[c] = ret ? (*bp++) : (rgb[c] += *bp++);\n        else\n          FORC3 if ((ip[c] = ret ? (*bp++) : (rgb[c] += *bp++)) >> 12) derror();\n    }\n  }\n}\nint LibRaw::unpack_thumb(void)\n{\n  CHECK_ORDER_LOW(LIBRAW_PROGRESS_IDENTIFY);\n  CHECK_ORDER_BIT(LIBRAW_PROGRESS_THUMB_LOAD);\n\n#define THUMB_SIZE_CHECKT(A) \\\n  do { \\\n    if (INT64(A) > 1024LL * 1024LL * LIBRAW_MAX_THUMBNAIL_MB) return LIBRAW_UNSUPPORTED_THUMBNAIL; \\\n    if (INT64(A) > 0 &&  INT64(A) < 64LL)        return LIBRAW_NO_THUMBNAIL; \\\n  } while (0)\n\n#define THUMB_SIZE_CHECKTNZ(A) \\\n  do { \\\n    if (INT64(A) > 1024LL * 1024LL * LIBRAW_MAX_THUMBNAIL_MB) return LIBRAW_UNSUPPORTED_THUMBNAIL; \\\n    if (INT64(A) < 64LL)        return LIBRAW_NO_THUMBNAIL; \\\n  } while (0)\n\n\n#define THUMB_SIZE_CHECKWH(W,H) \\\n  do { \\\n    if (INT64(W)*INT64(H) > 1024ULL * 1024ULL * LIBRAW_MAX_THUMBNAIL_MB) return LIBRAW_UNSUPPORTED_THUMBNAIL; \\\n    if (INT64(W)*INT64(H) < 64ULL)        return LIBRAW_NO_THUMBNAIL; \\\n  } while (0)\n\n#define Tformat libraw_internal_data.unpacker_data.thumb_format\n\n  try\n  {\n    if (!libraw_internal_data.internal_data.input)\n      return LIBRAW_INPUT_CLOSED;\n\n    int t_colors = libraw_internal_data.unpacker_data.thumb_misc >> 5 & 7;\n    int t_bytesps = (libraw_internal_data.unpacker_data.thumb_misc & 31) / 8;\n\n    if (!ID.toffset && !(imgdata.thumbnail.tlength > 0 &&\n                         load_raw == &LibRaw::broadcom_load_raw)  // RPi\n#ifdef USE_6BY9RPI\n        && !(imgdata.thumbnail.tlength > 0 && libraw_internal_data.unpacker_data.load_flags & 0x4000\n            && (load_raw == &LibRaw::rpi_load_raw8 || load_raw == &LibRaw::nokia_load_raw ||\n           load_raw == &LibRaw::rpi_load_raw12 || load_raw == &LibRaw::rpi_load_raw14))\n#endif\n    )\n    {\n      return LIBRAW_NO_THUMBNAIL;\n    }\n    else if ((Tformat >= LIBRAW_INTERNAL_THUMBNAIL_KODAK_THUMB)\n\t\t&& ((Tformat <= LIBRAW_INTERNAL_THUMBNAIL_KODAK_RGB)))\n    {\n      kodak_thumb_loader();\n      T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n      SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n      return 0;\n    }\n    else\n    {\n#ifdef USE_X3FTOOLS\n\tif (Tformat == LIBRAW_INTERNAL_THUMBNAIL_X3F)\n      {\n        INT64 tsize = x3f_thumb_size();\n        if (tsize < 2048 || INT64(ID.toffset) + tsize < 1)\n          throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n        if (INT64(ID.toffset) + tsize > ID.input->size() + THUMB_READ_BEYOND)\n          throw LIBRAW_EXCEPTION_IO_EOF;\n        THUMB_SIZE_CHECKT(tsize);\n      }\n#else\n\tif (0) {}\n#endif\n      else\n      {\n        if (INT64(ID.toffset) + INT64(T.tlength) < 1)\n          throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n        if (INT64(ID.toffset) + INT64(T.tlength) >\n            ID.input->size() + THUMB_READ_BEYOND)\n          throw LIBRAW_EXCEPTION_IO_EOF;\n      }\n\n      ID.input->seek(ID.toffset, SEEK_SET);\n      if (Tformat == LIBRAW_INTERNAL_THUMBNAIL_JPEG)\n      {\n        THUMB_SIZE_CHECKTNZ(T.tlength);\n        if (T.thumb)\n          free(T.thumb);\n        T.thumb = (char *)malloc(T.tlength);\n        ID.input->read(T.thumb, 1, T.tlength);\n\t\tunsigned char *tthumb = (unsigned char *)T.thumb;\n\t\tif (load_raw == &LibRaw::crxLoadRaw && T.tlength > 0xE0)\n\t\t{\n\t\t\t// Check if it is canon H.265 preview:  CISZ at bytes 4-6, CISZ prefix is 000n\n\t\t\tif (tthumb[0] == 0 && tthumb[1] == 0 && tthumb[2] == 0 && !memcmp(tthumb + 4, \"CISZ\", 4))\n\t\t\t{\n\t\t\t\tT.tformat = LIBRAW_THUMBNAIL_H265;\n\t\t\t\tSET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n        tthumb[0] = 0xff;\n        tthumb[1] = 0xd8;\n#ifdef NO_JPEG\n        T.tcolors = 3;\n#else\n        {\n          jpegErrorManager jerr;\n          struct jpeg_decompress_struct cinfo;\n          cinfo.err = jpeg_std_error(&jerr.pub);\n          jerr.pub.error_exit = jpegErrorExit;\n          if (setjmp(jerr.setjmp_buffer))\n          {\n          err2:\n            // Error in original JPEG thumb, read it again because\n            // original bytes 0-1 was damaged above\n            jpeg_destroy_decompress(&cinfo);\n            T.tcolors = 3;\n            T.tformat = LIBRAW_THUMBNAIL_UNKNOWN;\n            ID.input->seek(ID.toffset, SEEK_SET);\n            ID.input->read(T.thumb, 1, T.tlength);\n            SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n            return 0;\n          }\n          jpeg_create_decompress(&cinfo);\n          jpeg_mem_src(&cinfo, (unsigned char *)T.thumb, T.tlength);\n          int rc = jpeg_read_header(&cinfo, TRUE);\n          if (rc != 1)\n            goto err2;\n          T.tcolors = (cinfo.num_components > 0 && cinfo.num_components <= 3)\n                          ? cinfo.num_components\n                          : 3;\n          jpeg_destroy_decompress(&cinfo);\n        }\n#endif\n        T.tformat = LIBRAW_THUMBNAIL_JPEG;\n        SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n        return 0;\n      }\n      else if (Tformat == LIBRAW_INTERNAL_THUMBNAIL_LAYER)\n      {\n        int colors = libraw_internal_data.unpacker_data.thumb_misc >> 5 & 7;\n        if (colors != 1 && colors != 3)\n          return LIBRAW_UNSUPPORTED_THUMBNAIL;\n\n        THUMB_SIZE_CHECKWH(T.twidth, T.theight);\n\n        int tlength = T.twidth * T.theight;\n        if (T.thumb)\n          free(T.thumb);\n        T.thumb = (char *)calloc(colors, tlength);\n        unsigned char *tbuf = (unsigned char *)calloc(colors, tlength);\n        // Avoid OOB of tbuf, should use tlength\n        ID.input->read(tbuf, colors, tlength);\n        if (libraw_internal_data.unpacker_data.thumb_misc >> 8 &&\n            colors == 3) // GRB order\n          for (int i = 0; i < tlength; i++)\n          {\n            T.thumb[i * 3] = tbuf[i + tlength];\n            T.thumb[i * 3 + 1] = tbuf[i];\n            T.thumb[i * 3 + 2] = tbuf[i + 2 * tlength];\n          }\n        else if (colors == 3) // RGB or 1-channel\n          for (int i = 0; i < tlength; i++)\n          {\n            T.thumb[i * 3] = tbuf[i];\n            T.thumb[i * 3 + 1] = tbuf[i + tlength];\n            T.thumb[i * 3 + 2] = tbuf[i + 2 * tlength];\n          }\n        else if (colors == 1)\n        {\n          free(T.thumb);\n          T.thumb = (char *)tbuf;\n          tbuf = 0;\n        }\n        if (tbuf)\n          free(tbuf);\n        T.tcolors = colors;\n        T.tlength = colors * tlength;\n        T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n        SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n        return 0;\n      }\n      else if (Tformat == LIBRAW_INTERNAL_THUMBNAIL_ROLLEI)\n      {\n        int i;\n        THUMB_SIZE_CHECKWH(T.twidth, T.theight);\n        int tlength = T.twidth * T.theight;\n        if (T.thumb)\n          free(T.thumb);\n        T.tcolors = 3;\n        T.thumb = (char *)calloc(T.tcolors, tlength);\n        unsigned short *tbuf = (unsigned short *)calloc(2, tlength);\n        read_shorts(tbuf, tlength);\n        for (i = 0; i < tlength; i++)\n        {\n          T.thumb[i * 3] = (tbuf[i] << 3) & 0xff;\n          T.thumb[i * 3 + 1] = (tbuf[i] >> 5 << 2) & 0xff;\n          T.thumb[i * 3 + 2] = (tbuf[i] >> 11 << 3) & 0xff;\n        }\n        free(tbuf);\n        T.tlength = T.tcolors * tlength;\n        T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n        SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n        return 0;\n      }\n      else if (Tformat == LIBRAW_INTERNAL_THUMBNAIL_PPM)\n      {\n        if (t_bytesps > 1)\n          throw LIBRAW_EXCEPTION_IO_CORRUPT; // 8-bit thumb, but parsed for more\n                                             // bits\n        THUMB_SIZE_CHECKWH(T.twidth, T.theight);\n        int t_length = T.twidth * T.theight * t_colors;\n\n        if (T.tlength &&\n            (int)T.tlength < t_length) // try to find tiff ifd with needed offset\n        {\n          int pifd = find_ifd_by_offset(libraw_internal_data.internal_data.toffset);\n          if (pifd >= 0 && tiff_ifd[pifd].strip_offsets_count &&\n              tiff_ifd[pifd].strip_byte_counts_count)\n          {\n            // We found it, calculate final size\n            unsigned total_size = 0;\n            for (int i = 0; i < tiff_ifd[pifd].strip_byte_counts_count; i++)\n              total_size += tiff_ifd[pifd].strip_byte_counts[i];\n            if (total_size != (unsigned)t_length) // recalculate colors\n            {\n              if (total_size == T.twidth * T.tlength * 3)\n                T.tcolors = 3;\n              else if (total_size == T.twidth * T.tlength)\n                T.tcolors = 1;\n            }\n            T.tlength = total_size;\n            THUMB_SIZE_CHECKTNZ(T.tlength);\n            if (T.thumb)\n              free(T.thumb);\n            T.thumb = (char *)malloc(T.tlength);\n\n            char *dest = T.thumb;\n            INT64 pos = ID.input->tell();\n\n            for (int i = 0; i < tiff_ifd[pifd].strip_byte_counts_count &&\n                            i < tiff_ifd[pifd].strip_offsets_count;\n                 i++)\n            {\n              int remain = T.tlength;\n              int sz = tiff_ifd[pifd].strip_byte_counts[i];\n              int off = tiff_ifd[pifd].strip_offsets[i];\n              if (off >= 0 && off + sz <= ID.input->size() && sz <= remain)\n              {\n                ID.input->seek(off, SEEK_SET);\n                ID.input->read(dest, sz, 1);\n                remain -= sz;\n                dest += sz;\n              }\n            }\n            ID.input->seek(pos, SEEK_SET);\n            T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n            SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n            return 0;\n          }\n        }\n\n        if (!T.tlength)\n          T.tlength = t_length;\n        if (T.thumb)\n          free(T.thumb);\n\n        THUMB_SIZE_CHECKTNZ(T.tlength);\n\n        T.thumb = (char *)malloc(T.tlength);\n        if (!T.tcolors)\n          T.tcolors = t_colors;\n\n        ID.input->read(T.thumb, 1, T.tlength);\n\n        T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n        SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n        return 0;\n      }\n      else if (Tformat == LIBRAW_INTERNAL_THUMBNAIL_PPM16)\n      {\n        if (t_bytesps > 2)\n          throw LIBRAW_EXCEPTION_IO_CORRUPT; // 16-bit thumb, but parsed for\n                                             // more bits\n        int o_bps = (imgdata.rawparams.options & LIBRAW_RAWOPTIONS_USE_PPM16_THUMBS) ? 2 : 1;\n        int o_length = T.twidth * T.theight * t_colors * o_bps;\n        int i_length = T.twidth * T.theight * t_colors * 2;\n        if (!T.tlength)\n          T.tlength = o_length;\n        THUMB_SIZE_CHECKTNZ(o_length);\n        THUMB_SIZE_CHECKTNZ(i_length);\n        THUMB_SIZE_CHECKTNZ(T.tlength);\n\n        ushort *t_thumb = (ushort *)calloc(i_length, 1);\n        ID.input->read(t_thumb, 1, i_length);\n        if ((libraw_internal_data.unpacker_data.order == 0x4949) ==\n            (ntohs(0x1234) == 0x1234))\n          libraw_swab(t_thumb, i_length);\n\n        if (T.thumb)\n          free(T.thumb);\n        if ((imgdata.rawparams.options & LIBRAW_RAWOPTIONS_USE_PPM16_THUMBS))\n        {\n          T.thumb = (char *)t_thumb;\n          T.tformat = LIBRAW_THUMBNAIL_BITMAP16;\n        }\n        else\n        {\n          T.thumb = (char *)malloc(o_length);\n          for (int i = 0; i < o_length; i++)\n            T.thumb[i] = t_thumb[i] >> 8;\n          free(t_thumb);\n          T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n        }\n        SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n        return 0;\n      }\n#ifdef USE_X3FTOOLS\n\t  else if (Tformat == LIBRAW_INTERNAL_THUMBNAIL_X3F)\n      {\n        x3f_thumb_loader();\n        SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n        return 0;\n      }\n#endif\n      else\n      {\n        return LIBRAW_UNSUPPORTED_THUMBNAIL;\n      }\n    }\n    // last resort\n    return LIBRAW_UNSUPPORTED_THUMBNAIL; /* warned as unreachable*/\n  }\n  catch (const LibRaw_exceptions& err)\n  {\n    EXCEPTION_HANDLER(err);\n  }\n}\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {\n  // Input less than 15mb\n  if (size > 15000000) {\n    return 0;\n  }\n\n  FuzzedDataProvider fdp(data, size);\n  LibRaw lib_raw;\n\n  for(int i =0; i < 4; i++)\n    lib_raw.output_params_ptr()->aber[i] = fdp.ConsumeFloatingPoint<double>();\n  for(int i =0; i < 4; i++)\n    lib_raw.output_params_ptr()->user_mul[i] = fdp.ConsumeFloatingPoint<float>();\n  for(int i =0; i < 2; i++)\n    lib_raw.output_params_ptr()->gamm[i] = fdp.ConsumeFloatingPoint<double>();\n  lib_raw.output_params_ptr()->bright = fdp.ConsumeFloatingPoint<float>();\n  lib_raw.output_params_ptr()->threshold = fdp.ConsumeFloatingPoint<float>();\n  lib_raw.output_params_ptr()->use_auto_wb = fdp.ConsumeIntegral<int>();\n  lib_raw.output_params_ptr()->output_color = fdp.ConsumeIntegralInRange<int>(0, 6);\n  lib_raw.output_params_ptr()->user_flip = fdp.ConsumeIntegralInRange<int>(0, 7);\n  lib_raw.output_params_ptr()->user_black = fdp.ConsumeIntegral<int>();\n  lib_raw.output_params_ptr()->user_sat = fdp.ConsumeIntegral<int>();\n  lib_raw.output_params_ptr()->auto_bright_thr = fdp.ConsumeFloatingPoint<float>();\n  lib_raw.output_params_ptr()->adjust_maximum_thr = fdp.ConsumeFloatingPointInRange<float>(0.f, 1.f);\n  lib_raw.output_params_ptr()->fbdd_noiserd = fdp.ConsumeIntegralInRange<int>(0, 5);\n\n  std::vector<char> payload = fdp.ConsumeRemainingBytes<char>();\n  int result = lib_raw.open_buffer(payload.data(), payload.size());\n  if (result != LIBRAW_SUCCESS) {\n    return 0;\n  }\n\n  result = lib_raw.unpack();\n  if (result != LIBRAW_SUCCESS) {\n    return 0;\n  }\n\n  result = lib_raw.unpack_thumb();\n  if (result != LIBRAW_SUCCESS) {\n    return 0;\n  }\n\n  result = lib_raw.raw2image();\n  if (result != LIBRAW_SUCCESS) {\n    return 0;\n  }\n  lib_raw.free_image();\n\n  for (int i = 0; i < sizeof(options)/sizeof(*options); i++) {\n    lib_raw.output_params_ptr()->user_qual = static_cast<int>(options[i]);\n\n    result = lib_raw.dcraw_process();\n    if (result != LIBRAW_SUCCESS) {\n      return 0;\n    }\n  }\n\n  return 0;\n}\nstatic int ExecuteFilesOnyByOne(int argc, char **argv) {\n\n  unsigned char *buf = (unsigned char *)malloc(MAX_FILE);\n\n  __asan_poison_memory_region(buf, MAX_FILE);\n  ssize_t prev_length = 0;\n\n  for (int i = 1; i < argc; i++) {\n\n    int fd = 0;\n\n    if (strcmp(argv[i], \"-\") != 0) { fd = open(argv[i], O_RDONLY); }\n\n    if (fd == -1) { continue; }\n\n#ifndef __HAIKU__\n    ssize_t length = syscall(SYS_read, fd, buf, MAX_FILE);\n#else\n    ssize_t length = _kern_read(fd, buf, MAX_FILE);\n#endif  // HAIKU\n\n    if (length > 0) {\n\n      if (length < prev_length) {\n\n        __asan_poison_memory_region(buf + length, prev_length - length);\n\n      } else {\n\n        __asan_unpoison_memory_region(buf + prev_length, length - prev_length);\n\n      }\n\n      prev_length = length;\n\n      printf(\"Reading %zu bytes from %s\\n\", length, argv[i]);\n      LLVMFuzzerTestOneInput(buf, length);\n      printf(\"Execution successful.\\n\");\n\n    }\n\n    if (fd > 0) { close(fd); }\n\n  }\n\n  free(buf);\n  return 0;\n\n}\nint main(int argc, char **argv) {\n\n  if (argc < 2 || strncmp(argv[1], \"-h\", 2) == 0)\n    printf(\n        \"============================== INFO ================================\\n\"\n        \"This binary is built for afl++.\\n\"\n        \"To run the target function on individual input(s) execute:\\n\"\n        \"  %s INPUT_FILE1 [INPUT_FILE2 ... ]\\n\"\n        \"To fuzz with afl-fuzz execute:\\n\"\n        \"  afl-fuzz [afl-flags] -- %s [-N]\\n\"\n        \"afl-fuzz will run N iterations before re-spawning the process \"\n        \"(default: \"\n        \"INT_MAX)\\n\"\n        \"For stdin input processing, pass '-' as single command line option.\\n\"\n        \"For file input processing, pass '@@' as single command line option.\\n\"\n        \"To use with afl-cmin or afl-cmin.bash pass '-' as single command line \"\n        \"option\\n\"\n        \"===================================================================\\n\",\n        argv[0], argv[0]);\n\n  if (getenv(\"AFL_GDB\")) {\n\n    char cmd[64];\n    snprintf(cmd, sizeof(cmd), \"cat /proc/%d/maps\", getpid());\n    system(cmd);\n    fprintf(stderr, \"DEBUG: aflpp_driver pid is %d\\n\", getpid());\n    sleep(1);\n\n  }\n\n  output_file = stderr;\n  maybe_duplicate_stderr();\n  maybe_close_fd_mask();\n  if (LLVMFuzzerInitialize) {\n\n    fprintf(stderr, \"Running LLVMFuzzerInitialize ...\\n\");\n    LLVMFuzzerInitialize(&argc, &argv);\n    fprintf(stderr, \"continue...\\n\");\n\n  }\n\n  // Do any other expensive one-time initialization here.\n\n  uint8_t dummy_input[64] = {0};\n  memcpy(dummy_input, (void *)AFL_PERSISTENT, sizeof(AFL_PERSISTENT));\n  memcpy(dummy_input + 32, (void *)AFL_DEFER_FORKSVR,\n         sizeof(AFL_DEFER_FORKSVR));\n\n  int N = INT_MAX;\n\n  if (argc == 2 && !strcmp(argv[1], \"-\")) {\n\n    __afl_sharedmem_fuzzing = 0;\n    __afl_manual_init();\n    return ExecuteFilesOnyByOne(argc, argv);\n\n  } else if (argc == 2 && argv[1][0] == '-') {\n\n    N = atoi(argv[1] + 1);\n\n  } else if (argc == 2 && (N = atoi(argv[1])) > 0) {\n\n    printf(\"WARNING: using the deprecated call style `%s %d`\\n\", argv[0], N);\n\n  } else if (argc > 1) {\n\n    __afl_sharedmem_fuzzing = 0;\n\n    if (argc == 2) { __afl_manual_init(); }\n\n    return ExecuteFilesOnyByOne(argc, argv);\n\n  }\n\n  assert(N > 0);\n\n  __afl_manual_init();\n\n  // Call LLVMFuzzerTestOneInput here so that coverage caused by initialization\n  // on the first execution of LLVMFuzzerTestOneInput is ignored.\n  LLVMFuzzerTestOneInput(dummy_input, 4);\n\n  __asan_poison_memory_region(__afl_fuzz_ptr, MAX_FILE);\n  size_t prev_length = 0;\n\n  // for speed only insert asan functions if the target is linked with asan\n  if (__asan_region_is_poisoned) {\n\n    while (__afl_persistent_loop(N)) {\n\n      size_t length = *__afl_fuzz_len;\n\n      if (likely(length)) {\n\n        if (length < prev_length) {\n\n          __asan_poison_memory_region(__afl_fuzz_ptr + length,\n                                      prev_length - length);\n\n        } else if (length > prev_length) {\n\n          __asan_unpoison_memory_region(__afl_fuzz_ptr + prev_length,\n                                        length - prev_length);\n\n        }\n\n        prev_length = length;\n        LLVMFuzzerTestOneInput(__afl_fuzz_ptr, length);\n\n      }\n\n    }\n\n  } else {\n\n    while (__afl_persistent_loop(N)) {\n\n      LLVMFuzzerTestOneInput(__afl_fuzz_ptr, *__afl_fuzz_len);\n\n    }\n\n  }\n\n  return 0;\n\n}",
    "target": 0,
    "idx": 2052672
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "int flb_http_do(struct flb_http_client *c, size_t *bytes)\n{\n    int ret;\n    int r_bytes;\n    int crlf = 2;\n    int new_size;\n    ssize_t available;\n    size_t out_size;\n    size_t bytes_header = 0;\n    size_t bytes_body = 0;\n    char *tmp;\n\n    /* Append pending headers */\n    ret = http_headers_compose(c);\n    if (ret == -1) {\n        return -1;\n    }\n\n    /* check enough space for the ending CRLF */\n    if (header_available(c, crlf) != 0) {\n        new_size = c->header_size + 2;\n        tmp = flb_realloc(c->header_buf, new_size);\n        if (!tmp) {\n            return -1;\n        }\n        c->header_buf  = tmp;\n        c->header_size = new_size;\n    }\n\n    /* Append the ending header CRLF */\n    c->header_buf[c->header_len++] = '\\r';\n    c->header_buf[c->header_len++] = '\\n';\n\n#ifdef FLB_HAVE_HTTP_CLIENT_DEBUG\n    /* debug: request_headers callback */\n    flb_http_client_debug_cb(c, \"_debug.http.request_headers\");\n\n    /* debug: request_payload callback */\n    if (c->body_len > 0) {\n        flb_http_client_debug_cb(c, \"_debug.http.request_payload\");\n    }\n#endif\n\n    flb_debug(\"[http_client] header=%s\", c->header_buf);\n    /* Write the header */\n    ret = flb_io_net_write(c->u_conn,\n                           c->header_buf, c->header_len,\n                           &bytes_header);\n    if (ret == -1) {\n        /* errno might be changed from the original call */\n        if (errno != 0) {\n            flb_errno();\n        }\n        return -1;\n    }\n\n    if (c->body_len > 0) {\n        ret = flb_io_net_write(c->u_conn,\n                               c->body_buf, c->body_len,\n                               &bytes_body);\n        if (ret == -1) {\n            flb_errno();\n            return -1;\n        }\n    }\n\n    /* number of sent bytes */\n    *bytes = (bytes_header + bytes_body);\n\n    /* Read the server response, we need at least 19 bytes */\n    c->resp.data_len = 0;\n    while (1) {\n        available = flb_http_buffer_available(c) - 1;\n        if (available <= 1) {\n            /*\n             * If there is no more space available on our buffer, try to\n             * increase it.\n             */\n            ret = flb_http_buffer_increase(c, FLB_HTTP_DATA_CHUNK,\n                                           &out_size);\n            if (ret == -1) {\n                /*\n                 * We could not allocate more space, let the caller handle\n                 * this.\n                 */\n                flb_upstream_conn_recycle(c->u_conn, FLB_FALSE);\n                return 0;\n            }\n            available = flb_http_buffer_available(c) - 1;\n        }\n\n        r_bytes = flb_io_net_read(c->u_conn,\n                                  c->resp.data + c->resp.data_len,\n                                  available);\n        if (r_bytes <= 0) {\n            if (c->flags & FLB_HTTP_10) {\n                break;\n            }\n        }\n\n        /* Always append a NULL byte */\n        if (r_bytes >= 0) {\n            c->resp.data_len += r_bytes;\n            c->resp.data[c->resp.data_len] = '\\0';\n\n            ret = process_data(c);\n            if (ret == FLB_HTTP_ERROR) {\n                return -1;\n            }\n            else if (ret == FLB_HTTP_OK) {\n                break;\n            }\n            else if (ret == FLB_HTTP_MORE) {\n                continue;\n            }\n        }\n        else {\n            flb_error(\"[http_client] broken connection to %s:%i ?\",\n                      c->u_conn->u->tcp_host, c->u_conn->u->tcp_port);\n            return -1;\n        }\n    }\n\n    /* Check 'Connection' response header */\n    ret = check_connection(c);\n    if (ret == FLB_HTTP_OK) {\n        /*\n         * If the server replied that the connection will be closed\n         * and our Upstream connection is in keepalive mode, we must\n         * inactivate the connection.\n         */\n        if (c->resp.connection_close == FLB_TRUE) {\n            /* Do not recycle the connection (no more keepalive) */\n            flb_upstream_conn_recycle(c->u_conn, FLB_FALSE);\n            flb_debug(\"[http_client] server %s:%i will close connection #%i\",\n                      c->u_conn->u->tcp_host, c->u_conn->u->tcp_port,\n                      c->u_conn->fd);\n        }\n    }\n\n#ifdef FLB_HAVE_HTTP_CLIENT_DEBUG\n    flb_http_client_debug_cb(c, \"_debug.http.response_headers\");\n    if (c->resp.payload_size > 0) {\n        flb_http_client_debug_cb(c, \"_debug.http.response_payload\");\n    }\n#endif\n\n    return 0;\n}\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)\n{\n    struct flb_upstream *u;\n    struct flb_upstream_conn *u_conn = NULL;\n    struct flb_http_client *c;\n    struct flb_config *config;\n    char *uri = NULL;\n\n    if (size < 160) {\n        return 0;\n    }\n\n    config = flb_config_init();\n    if (config == NULL) {\n        return 0;\n    }\n\n    u = flb_upstream_create(config, \"127.0.0.1\", 8001, 0, NULL);\n    u_conn = flb_malloc(sizeof(struct flb_upstream_conn));\n    if (u_conn == NULL)\n        return 0;\n    u_conn->u = u;\n\n    char *proxy = NULL;\n    if (GET_MOD_EQ(2,1)) {\n        proxy = get_null_terminated(50, &data, &size);\n    }\n\n    uri = get_null_terminated(20, &data, &size);\n\n    int method = (int)data[0];\n    c = flb_http_client(u_conn, method, uri, NULL, 0,\n                    \"127.0.0.1\", 8001, proxy, 0);\n    if (c != NULL) {\n        char *null_terminated = get_null_terminated(30, &data, &size);\n\n        /* Perform a set of operations on the http_client */\n        flb_http_basic_auth(c, null_terminated, null_terminated);\n        flb_http_set_content_encoding_gzip(c);\n        flb_http_set_keepalive(c);\n        flb_http_strip_port_from_host(c);\n        flb_http_allow_duplicated_headers(c, 0);\n\n        flb_http_buffer_size(c, (*(size_t *)data) & 0xfff);\n        MOVE_INPUT(4)\n        flb_http_add_header(c, \"User-Agent\", 10, \"Fluent-Bit\", 10);\n        flb_http_add_header(c, (char*)data, size, \"Fluent-Bit\", 10);\n        flb_http_buffer_size(c, (int)data[0]);\n        MOVE_INPUT(1)\n        flb_http_buffer_available(c);\n        size_t out_size = 0;\n        flb_http_buffer_increase(c, (*(size_t *)data) & 0xfff, &out_size);\n        MOVE_INPUT(4)\n\n        size_t b_sent;\n        flb_http_do(c, &b_sent);\n\n        /* Now we need to simulate the reading of data */\n        c->resp.status = 200;\n\n        char *new_nulltm = get_null_terminated(30, &data, &size);\n        c->resp.data_len = 30;\n        c->resp.data = new_nulltm;\n        fuzz_process_data(c);\n        fuzz_check_connection(c);\n\n        flb_http_client_destroy(c);\n        flb_free(null_terminated);\n    }\n\n    /* Now try the http_client_proxy_connect function. */\n    flb_http_client_proxy_connect(u_conn);\n\n    flb_free(u_conn);\n    flb_upstream_destroy(u);\n    flb_config_exit(config);\n    if (uri != NULL) {\n        flb_free(uri);\n    }\n    if (proxy != NULL) {\n        flb_free(proxy);\n    }\n\n    return 0;\n}",
    "target": 0,
    "idx": 2028256
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "MRB_API mrb_value\nmrb_funcall_with_block(mrb_state *mrb, mrb_value self, mrb_sym mid, mrb_int argc, const mrb_value *argv, mrb_value blk)\n{\n  mrb_value val;\n  int ai = mrb_gc_arena_save(mrb);\n\n  if (!mrb->jmp) {\n    struct mrb_jmpbuf c_jmp;\n    ptrdiff_t nth_ci = mrb->c->ci - mrb->c->cibase;\n\n    MRB_TRY(&c_jmp) {\n      mrb->jmp = &c_jmp;\n      /* recursive call */\n      val = mrb_funcall_with_block(mrb, self, mid, argc, argv, blk);\n      mrb->jmp = 0;\n    }\n    MRB_CATCH(&c_jmp) { /* error */\n      while (nth_ci < (mrb->c->ci - mrb->c->cibase)) {\n        cipop(mrb);\n      }\n      mrb->jmp = 0;\n      val = mrb_obj_value(mrb->exc);\n    }\n    MRB_END_EXC(&c_jmp);\n    mrb->jmp = 0;\n  }\n  else {\n    mrb_method_t m;\n    struct RClass *c;\n    mrb_callinfo *ci = mrb->c->ci;\n    mrb_int n = mrb_ci_nregs(ci);\n    ptrdiff_t voff = -1;\n\n    if (!mrb->c->stbase) {\n      stack_init(mrb);\n    }\n    if (ci - mrb->c->cibase > MRB_CALL_LEVEL_MAX) {\n      mrb_exc_raise(mrb, mrb_obj_value(mrb->stack_err));\n    }\n    if (mrb->c->stbase <= argv && argv < mrb->c->stend) {\n      voff = argv - mrb->c->stbase;\n    }\n    if (argc < 0) {\n      mrb_raisef(mrb, E_ARGUMENT_ERROR, \"negative argc for funcall (%i)\", argc);\n    }\n    c = mrb_class(mrb, self);\n    m = mrb_method_search_vm(mrb, &c, mid);\n    mrb_stack_extend(mrb, n + argc + 3);\n    if (MRB_METHOD_UNDEF_P(m) || argc >= 15) {\n      mrb_value args = mrb_ary_new_from_values(mrb, argc, argv);\n\n      ci->stack[n+1] = args;\n      argc = 15;\n    }\n    if (MRB_METHOD_UNDEF_P(m)) {\n      mrb_sym missing = MRB_SYM(method_missing);\n      mrb_value args = ci->stack[n+1];\n\n      m = mrb_method_search_vm(mrb, &c, missing);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        mrb_method_missing(mrb, mid, self, args);\n      }\n      mrb_ary_unshift(mrb, args, mrb_symbol_value(mid));\n      mrb_stack_extend(mrb, n+2);\n      ci->stack[n+1] = args;\n      argc = 15;\n    }\n    ci = cipush(mrb, n, 0, c, NULL, mid, argc);\n    if (MRB_METHOD_PROC_P(m)) {\n      struct RProc *p = MRB_METHOD_PROC(m);\n\n      mrb_vm_ci_proc_set(ci, p);\n      if (!MRB_PROC_CFUNC_P(p)) {\n        mrb_stack_extend(mrb, p->body.irep->nregs + argc);\n      }\n    }\n    if (voff >= 0) {\n      argv = mrb->c->stbase + voff;\n    }\n    ci->stack[0] = self;\n    if (argc < 15) {\n      if (argc > 0)\n        stack_copy(ci->stack+1, argv, argc);\n      ci->stack[argc+1] = blk;\n    }\n    else {\n      ci->stack[2] = blk;\n    }\n\n    if (MRB_METHOD_CFUNC_P(m)) {\n      ci->cci = CINFO_DIRECT;\n      val = MRB_METHOD_CFUNC(m)(mrb, self);\n      cipop(mrb);\n    }\n    else {\n      ci->cci = CINFO_SKIP;\n      val = mrb_run(mrb, MRB_METHOD_PROC(m), self);\n    }\n  }\n  mrb_gc_arena_restore(mrb, ai);\n  mrb_gc_protect(mrb, val);\n  return val;\n}\nmrb_value\nmrb_instance_new(mrb_state *mrb, mrb_value cv)\n{\n  mrb_value obj, blk;\n  const mrb_value *argv;\n  mrb_int argc;\n  mrb_sym init;\n\n  mrb_get_args(mrb, \"*!&\", &argv, &argc, &blk);\n  obj = mrb_instance_alloc(mrb, cv);\n  init = MRB_SYM(initialize);\n  if (!mrb_func_basic_p(mrb, obj, init, mrb_bob_init)) {\n    mrb_funcall_with_block(mrb, obj, init, argc, argv, blk);\n  }\n  return obj;\n}\nMRB_API mrb_value\nmrb_funcall_argv(mrb_state *mrb, mrb_value self, mrb_sym mid, mrb_int argc, const mrb_value *argv)\n{\n  return mrb_funcall_with_block(mrb, self, mid, argc, argv, mrb_nil_value());\n}\nMRB_API mrb_value\nmrb_make_exception(mrb_state *mrb, mrb_int argc, const mrb_value *argv)\n{\n  mrb_value mesg;\n  int n;\n\n  mesg = mrb_nil_value();\n  switch (argc) {\n    case 0:\n    break;\n    case 1:\n      if (mrb_nil_p(argv[0]))\n        break;\n      if (mrb_string_p(argv[0])) {\n        mesg = mrb_exc_new_str(mrb, E_RUNTIME_ERROR, argv[0]);\n        break;\n      }\n      n = 0;\n      goto exception_call;\n\n    case 2:\n    case 3:\n      n = 1;\nexception_call:\n      {\n        mrb_sym exc = MRB_SYM(exception);\n        if (mrb_respond_to(mrb, argv[0], exc)) {\n          mesg = mrb_funcall_argv(mrb, argv[0], exc, n, argv+1);\n        }\n        else {\n          /* undef */\n          mrb_raise(mrb, E_TYPE_ERROR, \"exception class/object expected\");\n        }\n      }\n\n      break;\n    default:\n      mrb_argnum_error(mrb, argc, 0, 3);\n      break;\n  }\n  if (argc > 0) {\n    if (!mrb_obj_is_kind_of(mrb, mesg, mrb->eException_class))\n      mrb_raise(mrb, mrb->eException_class, \"exception object expected\");\n    if (argc > 2)\n      set_backtrace(mrb, mesg, argv[2]);\n  }\n\n  return mesg;\n}\nMRB_API mrb_value\nmrb_f_raise(mrb_state *mrb, mrb_value self)\n{\n  mrb_value a[2], exc;\n  mrb_int argc;\n\n  argc = mrb_get_args(mrb, \"|oo\", &a[0], &a[1]);\n  mrb->c->ci->mid = 0;\n  switch (argc) {\n  case 0:\n    mrb_raise(mrb, E_RUNTIME_ERROR, \"\");\n    break;\n  case 1:\n    if (mrb_string_p(a[0])) {\n      a[1] = a[0];\n      argc = 2;\n      a[0] = mrb_obj_value(E_RUNTIME_ERROR);\n    }\n    /* fall through */\n  default:\n    exc = mrb_make_exception(mrb, argc, a);\n    mrb_exc_raise(mrb, exc);\n    break;\n  }\n  return mrb_nil_value();            /* not reached */\n}\nMRB_API mrb_value\nmrb_vm_run(mrb_state *mrb, const struct RProc *proc, mrb_value self, mrb_int stack_keep)\n{\n  const mrb_irep *irep = proc->body.irep;\n  mrb_value result;\n  struct mrb_context *c = mrb->c;\n  ptrdiff_t cioff = c->ci - c->cibase;\n  mrb_int nregs = irep->nregs;\n\n  if (!c->stbase) {\n    stack_init(mrb);\n  }\n  if (stack_keep > nregs)\n    nregs = stack_keep;\n  mrb_stack_extend(mrb, nregs);\n  stack_clear(c->ci->stack + stack_keep, nregs - stack_keep);\n  c->ci->stack[0] = self;\n  result = mrb_vm_exec(mrb, proc, irep->iseq);\n  if (mrb->c != c) {\n    if (mrb->c->fib) {\n      mrb_write_barrier(mrb, (struct RBasic*)mrb->c->fib);\n    }\n    mrb->c = c;\n  }\n  else if (c->ci - c->cibase > cioff) {\n    c->ci = c->cibase + cioff;\n  }\n  return result;\n}\nint FuzzRB(const uint8_t *Data, size_t size) {\n\tmrb_value v;\n\tmrb_state *mrb = mrb_open();\n\tif (!mrb)\n\t\treturn 0;\n\n\tchar *code = (char *)malloc(size+1);\n\tif (!code)\n\t\treturn 0;\n\tmemcpy(code, Data, size);\n\tcode[size] = '\\0';\n\n\tif (const char *dump_path = getenv(\"PROTO_FUZZER_DUMP_PATH\")) {\n\t\t// With libFuzzer binary run this to generate an RB file x.rb:\n\t\t// PROTO_FUZZER_DUMP_PATH=x.rb ./a.out proto-input\n\t\tstd::ofstream of(dump_path);\n\t\tof.write(code, size);\n\t}\n\tv = mrb_load_string(mrb, code);\n\tmrb_close(mrb);\n\n\tfree(code);\n\treturn 0;\n}",
    "target": 0,
    "idx": 2039937
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "static int\nread_file_header (Bit_Chain *restrict dat,\n                  r2007_file_header *restrict file_header)\n{\n  BITCODE_RC data[0x3d8]; // 0x400 - 5 long\n  BITCODE_RC *pedata;\n  uint64_t seqence_crc;\n  uint64_t seqence_key;\n  uint64_t compr_crc;\n  int32_t compr_len, len2;\n  int i;\n  int error = 0, errcount = 0;\n  const int pedata_size = 3 * 239; // size of pedata\n\n  dat->byte = 0x80;\n  LOG_TRACE (\"\\n=== File header ===\\n\")\n  memset (file_header, 0, sizeof (r2007_file_header));\n  memset (data, 0, 0x3d8);\n  bit_read_fixed (dat, data, 0x3d8);\n  pedata = decode_rs (data, 3, 239, 0x3d8);\n  if (!pedata)\n    return DWG_ERR_OUTOFMEM;\n\n  // Note: This is unportable to big-endian\n  seqence_crc = *((uint64_t *)pedata);\n  seqence_key = *((uint64_t *)&pedata[8]);\n  compr_crc = *((uint64_t *)&pedata[16]);\n  compr_len = *((int32_t *)&pedata[24]);\n  len2 = *((int32_t *)&pedata[28]);\n  LOG_TRACE (\"seqence_crc64: %016lX\\n\", (unsigned long)seqence_crc);\n  LOG_TRACE (\"seqence_key:   %016lX\\n\", (unsigned long)seqence_key);\n  LOG_TRACE (\"compr_crc64:   %016lX\\n\", (unsigned long)compr_crc);\n  LOG_TRACE (\"compr_len:     %d\\n\", (int)compr_len); // only this is used\n  LOG_TRACE (\"len2:          %d\\n\", (int)len2);      // 0 when compressed\n\n  if (compr_len > 0)\n    error = decompress_r2007 ((BITCODE_RC *)file_header, sizeof (r2007_file_header),\n                              &pedata[32], MIN (compr_len, pedata_size - 32));\n  else\n    memcpy (file_header, &pedata[32], sizeof (r2007_file_header));\n\n  // check validity, for debugging only\n  if (!error)\n    {\n\n#define VALID_SIZE(var)                                                       \\\n  if (var < 0 || (unsigned)var > dat->size)                                   \\\n    {                                                                         \\\n      errcount++;                                                             \\\n      error |= DWG_ERR_VALUEOUTOFBOUNDS;                                      \\\n      LOG_ERROR (\"%s Invalid %s %ld > MAX_SIZE\", __FUNCTION__, #var,          \\\n                 (long)var)                                                   \\\n      var = 0;                                                                \\\n    }\n#define VALID_COUNT(var)                                                      \\\n  if (var < 0 || (unsigned)var > dat->size)                                   \\\n    {                                                                         \\\n      errcount++;                                                             \\\n      error |= DWG_ERR_VALUEOUTOFBOUNDS;                                      \\\n      LOG_ERROR (\"%s Invalid %s %ld > MAX_COUNT\", __FUNCTION__, #var,         \\\n                 (long)var)                                                   \\\n      var = 0;                                                                \\\n    }\n\n      VALID_SIZE (file_header->header_size);\n      VALID_SIZE (file_header->file_size);\n      VALID_SIZE (file_header->pages_map_offset);\n      VALID_SIZE (file_header->header2_offset);\n      VALID_SIZE (file_header->pages_map_offset);\n      VALID_SIZE (file_header->pages_map_size_comp);\n      VALID_SIZE (file_header->pages_map_size_uncomp);\n      VALID_COUNT (file_header->pages_maxid);\n      VALID_COUNT (file_header->pages_amount);\n      VALID_COUNT (file_header->num_sections);\n    }\n\n  free (pedata);\n  return error;\n}\nstatic void\ncopy_bytes (BITCODE_RC *dst, uint32_t length, uint32_t offset)\n{\n  BITCODE_RC *src = dst - offset;\n\n  while (length-- > 0)\n    *dst++ = *src++;\n}\nstatic int\ndecompress_r2007 (BITCODE_RC *restrict dst, const unsigned dst_size,\n                  BITCODE_RC *restrict src, const unsigned src_size)\n{\n  uint32_t length = 0;\n  uint32_t offset = 0;\n\n  BITCODE_RC *dst_start = dst;\n  BITCODE_RC *dst_end = dst + dst_size;\n  BITCODE_RC *src_end = src + src_size;\n  unsigned char opcode;\n\n  LOG_INSANE (\"decompress_r2007 (%p, %d, %p, %d)\\n\", dst, dst_size, src, src_size);\n  if (!dst || !src || !dst_size || src_size < 2)\n    {\n      LOG_ERROR (\"Invalid argument to %s\\n\", __FUNCTION__);\n      return DWG_ERR_INTERNALERROR;\n    }\n\n  opcode = *src++;\n  if ((opcode & 0xf0) == 0x20)\n    {\n      src += 2;\n      length = *src++ & 0x07;\n      if (length == 0)\n        {\n          LOG_ERROR (\"Decompression error: zero length\")\n          return DWG_ERR_INTERNALERROR;\n        }\n    }\n\n  while (src < src_end)\n    {\n      if (length == 0)\n        length = read_literal_length (&src, opcode);\n\n      if ((dst + length) >= dst_end || (src + length) > src_end)\n        {\n          if (DWG_LOGLEVEL >= DWG_LOGLEVEL_HANDLE)\n            {\n              if ((dst + length) >= dst_end)\n                HANDLER(OUTPUT, \"copy_compressed_bytes: dst %p + %u >= %p\\n\",\n                        dst, (unsigned)length, dst_end);\n              else\n                HANDLER(OUTPUT, \"copy_compressed_bytes: src %p + %u > %p\\n\",\n                        src, (unsigned)length, src_end);\n            }\n          LOG_ERROR (\"Decompression error: length overflow\");\n          return DWG_ERR_INTERNALERROR;\n        }\n\n      LOG_INSANE (\n          \"copy_compressed_bytes (%p, %p, %u). remaining src: %ld, dst: %ld\\n\",\n          dst, src, (unsigned)length, (long)(src_end - src), (long)(dst_end - dst));\n      copy_compressed_bytes (dst, src, length);\n\n      dst += length;\n      src += length;\n\n      length = 0;\n\n      if (src >= src_end)\n        return 0;\n\n      opcode = *src++;\n\n      read_instructions (&src, &opcode, &offset, &length);\n\n      while (1)\n        {\n          if ((dst + length) > dst_end)\n            {\n              LOG_HANDLE(\"copy_bytes: dst %p + %u > %p\\n\", dst, (unsigned)length, dst_end);\n              LOG_ERROR (\"Decompression error: length overflow\");\n              return DWG_ERR_INTERNALERROR;\n            }\n          if (offset > (uint32_t) (dst - dst_start))\n            {\n              LOG_HANDLE(\"copy_bytes: offset %u > %p - %p\\n\", (unsigned)offset, dst, dst_start);\n              LOG_ERROR (\"Decompression error: offset underflow\");\n              return DWG_ERR_INTERNALERROR;\n            }\n          LOG_INSANE (\"copy_bytes (%p, %u, [%u])\\n\", dst, (unsigned)length, (unsigned)offset);\n          copy_bytes (dst, length, offset);\n\n          dst += length;\n          length = (opcode & 7);\n\n          if (length != 0 || src >= src_end)\n            break;\n\n          opcode = *src++;\n\n          if ((opcode >> 4) == 0)\n            break;\n\n          if ((opcode >> 4) == 0x0f)\n            opcode &= 0xf;\n\n          read_instructions ((unsigned char **)&src, &opcode, &offset,\n                             &length);\n        }\n    }\n\n  return 0;\n}\nint\nread_r2007_meta_data (Bit_Chain *dat, Bit_Chain *hdl_dat,\n                      Dwg_Data *restrict dwg)\n{\n  r2007_file_header file_header;\n  r2007_page *restrict pages_map = NULL, *restrict page;\n  r2007_section *restrict sections_map = NULL;\n  int error;\n#ifdef USE_TRACING\n  char *probe;\n#endif\n\n  read_r2007_init (dwg);\n#ifdef USE_TRACING\n  probe = getenv (\"LIBREDWG_TRACE\");\n  if (probe)\n    loglevel = atoi (probe);\n#endif\n  // @ 0x62\n  error = read_file_header (dat, &file_header);\n  if (error >= DWG_ERR_VALUEOUTOFBOUNDS)\n    return error;\n\n  // Pages Map\n  dat->byte += 0x28; // overread check data\n  dat->byte += file_header.pages_map_offset;\n  if ((unsigned long)file_header.pages_map_size_comp\n      > dat->size - dat->byte)\n    {\n      LOG_ERROR (\"%s Invalid pages_map_size_comp %lu > %lu bytes left\",\n                 __FUNCTION__,\n                 (unsigned long)file_header.pages_map_size_comp,\n                 dat->size - dat->byte)\n      error |= DWG_ERR_VALUEOUTOFBOUNDS;\n      goto error;\n    }\n  pages_map = read_pages_map (dat, file_header.pages_map_size_comp,\n                              file_header.pages_map_size_uncomp,\n                              file_header.pages_map_correction);\n  if (!pages_map)\n    return DWG_ERR_PAGENOTFOUND; // Error already logged\n\n  // Sections Map\n  page = get_page (pages_map, file_header.sections_map_id);\n  if (!page)\n    {\n      LOG_ERROR (\"Failed to find sections page map %d\",\n                 (int)file_header.sections_map_id);\n      error |= DWG_ERR_SECTIONNOTFOUND;\n      goto error;\n    }\n  dat->byte = page->offset;\n  if ((unsigned long)file_header.sections_map_size_comp\n      > dat->size - dat->byte)\n    {\n      LOG_ERROR (\"%s Invalid comp_data_size %lu > %lu bytes left\",\n                 __FUNCTION__,\n                 (unsigned long)file_header.sections_map_size_comp,\n                 dat->size - dat->byte)\n      error |= DWG_ERR_VALUEOUTOFBOUNDS;\n      goto error;\n    }\n  sections_map = read_sections_map (dat, file_header.sections_map_size_comp,\n                                    file_header.sections_map_size_uncomp,\n                                    file_header.sections_map_correction);\n  if (!sections_map)\n    goto error;\n\n  error = read_2007_section_header (dat, hdl_dat, dwg, sections_map,\n                                    pages_map);\n  if (dwg->header.summaryinfo_address)\n    error |= read_2007_section_summary (dat, dwg, sections_map, pages_map);\n  error |= read_2007_section_classes (dat, dwg, sections_map, pages_map);\n  error |= read_2007_section_handles (dat, hdl_dat, dwg, sections_map,\n                                      pages_map);\n  error |= read_2007_section_auxheader (dat, dwg, sections_map, pages_map);\n  if (dwg->header.thumbnail_address)\n    error |= read_2007_section_preview (dat, dwg, sections_map, pages_map);\n  error |= read_2007_section_appinfo (dat, dwg, sections_map, pages_map);\n  error |= read_2007_section_appinfohistory (dat, dwg, sections_map, pages_map);\n  error |= read_2007_section_filedeplist (dat, dwg, sections_map, pages_map);\n  error |= read_2007_section_security (dat, dwg, sections_map, pages_map);\n  error |= read_2007_section_revhistory (dat, dwg, sections_map, pages_map);\n  error |= read_2007_section_objfreespace (dat, dwg, sections_map, pages_map);\n  error |= read_2007_section_template (dat, dwg, sections_map, pages_map);\n  if (dwg->header.vbaproj_address)\n    error |= read_2007_section_vbaproject (dat, dwg, sections_map, pages_map);\n  //error |= read_2007_section_signature (dat, dwg, sections_map, pages_map);\n  error |= read_2007_section_acds (dat, dwg, sections_map, pages_map);\n  // read_2007_blocks (dat, hdl_dat, dwg, sections_map, pages_map);\n\nerror:\n  pages_destroy (pages_map);\n  if (sections_map)\n    sections_destroy (sections_map);\n\n  return error;\n}\nstatic int\ndecode_R2007 (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  Bit_Chain hdl_dat = { 0 };\n  int error;\n\n  hdl_dat = *dat;\n  {\n    int i;\n    Dwg_Header *_obj = &dwg->header;\n    Dwg_Object *obj = NULL;\n\n    dat->byte = 0x06;\n    // clang-format off\n    #include \"header.spec\"\n    // clang-format on\n  }\n\n  // this includes classes, header, handles + objects\n  error = read_r2007_meta_data (dat, &hdl_dat, dwg);\n\n  LOG_INFO (\"\\nnum_objects: %lu\\n\", (unsigned long)dwg->num_objects)\n  LOG_TRACE (\"num_object_refs: %lu\\n\", (unsigned long)dwg->num_object_refs)\n  if (error >= DWG_ERR_CRITICAL)\n    {\n      LOG_ERROR (\"Failed to read 2007 meta data\")\n      return error;\n    }\n\n  LOG_TRACE (\"Resolving pointers from ObjectRef vector:\\n\")\n  return error | resolve_objectref_vector (dat, dwg);\n}\nEXPORT int\ndwg_decode (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  int i;\n  char magic[8];\n\n  dwg->num_object_refs = 0;\n  // dwg->num_layers = 0; // see now dwg->layer_control->num_entries\n  dwg->num_entities = 0;\n  dwg->num_objects = 0;\n  dwg->num_classes = 0;\n  dwg->thumbnail.size = 0;\n  dwg->thumbnail.chain = NULL;\n  dwg->header.numsections = 0;\n  dwg->header.section_infohdr.num_desc = 0;\n  dwg->dwg_class = NULL;\n  dwg->object_ref = NULL;\n  dwg->object = NULL;\n  dwg->object_map = hash_new (dat->size / 1000);\n  if (!dwg->object_map)\n    {\n      // whatever, we are obviously on a tiny system\n      dwg->object_map = hash_new (1024);\n      if (!dwg->object_map)\n        {\n          LOG_ERROR (\"Out of memory\");\n          return DWG_ERR_OUTOFMEM;\n        }\n    }\n  dwg->dirty_refs = 1;\n\n  //memset (&dwg->header, 0, sizeof (dwg->header)); // no, needed for magic\n  memset (&dwg->header_vars, 0, sizeof (dwg->header_vars));\n  memset (&dwg->summaryinfo, 0, sizeof (dwg->summaryinfo));\n  memset (&dwg->r2004_header, 0, sizeof (dwg->r2004_header));\n  memset (&dwg->auxheader, 0, sizeof (dwg->auxheader));\n  memset (&dwg->second_header, 0, sizeof (dwg->second_header));\n\n  if (dwg->opts)\n    {\n      loglevel = dwg->opts & DWG_OPTS_LOGLEVEL;\n      dat->opts = dwg->opts;\n    }\n\n#ifdef USE_TRACING\n  /* Before starting, set the logging level, but only do so once.  */\n  if (!env_var_checked_p)\n    {\n      char *probe = getenv (\"LIBREDWG_TRACE\");\n      if (probe)\n        loglevel = atoi (probe);\n      env_var_checked_p = true;\n    }\n#endif /* USE_TRACING */\n\n  /* Version */\n  dat->byte = 0;\n  dat->bit = 0;\n  if (!dat->chain || dat->size < 58) // saw the smallest r2.10 DWG with 1095 bytes\n    {\n      LOG_ERROR (\"dwg too small: %lu bytes\", dat->size);\n      return DWG_ERR_INVALIDDWG;\n    }\n  strncpy (magic, (const char *)dat->chain, 6);\n  if (memcmp (dat->chain, \"AC103-4\", 7) == 0)\n    {\n      magic[6] = '4';\n      magic[7] = '\\0';\n    }\n  else\n    magic[6] = '\\0';\n\n  dwg->header.from_version = dwg_version_hdr_type (magic);\n  if (!dwg->header.from_version)\n    {\n      if (strncmp (magic, \"AC\", 2)) // let's ignore MC0.0 for now\n        {\n          LOG_ERROR (\"Invalid DWG, magic: %s\", magic);\n        }\n      else\n        {\n          LOG_ERROR (\"Invalid or unimplemented DWG version code %s\", magic);\n        }\n      return DWG_ERR_INVALIDDWG;\n    }\n  dat->from_version = dwg->header.from_version;\n  if (!dwg->header.version) // target version not set\n    {\n      dat->version = dwg->header.version = dat->from_version;\n    }\n  LOG_INFO (\"This file's version code is: %s (%s)\\n\", magic,\n            dwg_version_type (dat->from_version))\n\n  PRE (R_13) {\n    Dwg_Object *ctrl;\n    int error = decode_preR13 (dat, dwg);\n    ctrl = &dwg->object[0];\n    dwg->block_control = *ctrl->tio.object->tio.BLOCK_CONTROL;\n    return error;\n  }\n  VERSIONS (R_13, R_2000) { return decode_R13_R2000 (dat, dwg); }\n  VERSION (R_2004) { return decode_R2004 (dat, dwg); }\n  VERSION (R_2007) { return decode_R2007 (dat, dwg); }\n  SINCE (R_2010)\n  {\n    read_r2007_init (dwg); // sets loglevel only for now\n    return decode_R2004 (dat, dwg);\n  }\n\n  // This line should not be reached\n  LOG_ERROR (\"LibreDWG does not support this DWG version: %s (%s).\",\n\t     magic, dwg_version_type (dat->from_version))\n  return DWG_ERR_INVALIDDWG;\n}\nint LLVMFuzzerTestOneInput(const unsigned char *data, size_t size) {\n    Dwg_Data dwg;\n    Bit_Chain dat = { NULL, 0, 0, 0, 0 };\n    Bit_Chain out_dat = { NULL, 0, 0, 0, 0 };\n    int copied = 0;\n    struct ly_ctx *ctx = NULL;\n    unsigned int possible_outputformats;\n    int out;\n\n    static char tmp_file[256];\n    dat.chain = (unsigned char *)data;\n    dat.size = size;\n    memset (&dwg, 0, sizeof (dwg));\n\n    possible_outputformats =\n#ifdef DISABLE_DXF\n# ifdef DISABLE_JSON\n        1;\n# else\n        3;\n# endif\n#else\n        5;\n#endif\n\n    // Detect the input format: DWG, DXF or JSON\n    if (dat.size > 2 && dat.chain[0] == 'A' && dat.chain[1] == 'C')\n      {\n        if (dwg_decode (&dat, &dwg) >= DWG_ERR_CRITICAL)\n          {\n            dwg_free (&dwg);\n            return 0;\n          }\n      }\n#ifndef DISABLE_JSON\n    else if (dat.size > 1 && dat.chain[0] == '{')\n      {\n        copied = enforce_null_termination(&dat, true);\n        if (dwg_read_json (&dat, &dwg) >= DWG_ERR_CRITICAL)\n          {\n            if (copied)\n              bit_chain_free (&dat);\n            dwg_free (&dwg);\n            return 0;\n          }\n        dat.opts |= DWG_OPTS_INJSON;\n        dwg.opts |= DWG_OPTS_INJSON;\n      }\n#endif\n#ifndef DISABLE_DXF\n    else\n      {\n        copied = enforce_null_termination(&dat, false);\n        if (dwg_read_dxf (&dat, &dwg) >= DWG_ERR_CRITICAL)\n          {\n            if (copied)\n              bit_chain_free (&dat);\n            dwg_free (&dwg);\n            return 0;\n          }\n      }\n#else\n    else\n      return 0;\n#endif\n\n    memset (&out_dat, 0, sizeof (out_dat));\n    bit_chain_set_version (&out_dat, &dat);\n    if (copied)\n      bit_chain_free (&dat);\n\n#if 0\n    snprintf (tmp_file, 255, \"/tmp/llvmfuzzer%d.out\", getpid());\n    tmp_file[255] = '\\0';\n#elif defined _WIN32\n    strcpy (tmp_file, \"NUL\");\n#else\n    strcpy (tmp_file, \"/dev/null\");\n#endif\n    out_dat.fh = fopen(tmp_file, \"w\");\n\n    out = rand () % possible_outputformats;\n#ifdef STANDALONE\n    if (getenv(\"OUT\"))\n      out = strtol (getenv(\"OUT\"), NULL, 10);\n#endif\n    switch (out)\n      {\n      case 0:\n        {\n          int ver = rand() % 6;\n#ifdef STANDALONE\n          if (getenv(\"VER\"))\n            ver = strtol (getenv(\"VER\"), NULL, 10);\n#endif\n          switch (ver)\n            {\n            case 0:\n              out_dat.version = dwg.header.version = R_13;\n              break;\n            case 1:\n              out_dat.version = dwg.header.version = R_13c3;\n              break;\n            case 2:\n              out_dat.version = dwg.header.version = R_14;\n              break;\n            case 3: // favor this one\n            case 4:\n            case 5:\n            default:\n              out_dat.version = dwg.header.version = R_2000;\n              break;\n            }\n          dwg_encode (&dwg, &out_dat);\n          free (out_dat.chain);\n          break;\n        }\n#ifndef DISABLE_DXF\n      case 1:\n          dwg_write_dxf (&out_dat, &dwg);\n          free (out_dat.chain);\n          break;\n      case 2: // experimental\n          dwg_write_dxfb (&out_dat, &dwg);\n          free (out_dat.chain);\n          break;\n# ifndef DISABLE_JSON\n      case 3:\n          dwg_write_json (&out_dat, &dwg);\n          free (out_dat.chain);\n          break;\n      case 4:\n          dwg_write_geojson (&out_dat, &dwg);\n          free (out_dat.chain);\n          break;\n# endif\n#endif\n      default: break;\n      }\n    dwg_free (&dwg);\n    fclose (out_dat.fh);\n    //unlink (tmp_file);\n    return 0;\n}",
    "target": 0,
    "idx": 2044432
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "static void\nudiv(mrb_state *mrb, mpz_t *qq, mpz_t *rr, mpz_t *xx, mpz_t *yy)\n{\n  /* simple cases */\n  int cmp = ucmp(xx, yy);\n  if (cmp == 0) {\n    mpz_set_int(mrb, qq, 1);\n    zero(rr);\n    return;\n  }\n  else if (cmp < 0) {\n    zero(qq);\n    mpz_set(mrb, rr, xx);\n    return;\n  }\n\n  mpz_t q, x, y;\n  size_t i;\n\n  mrb_assert(!uzero(yy));       /* divided by zero */\n  mpz_init(mrb, &q);\n  mpz_init(mrb, &x);\n  mpz_init(mrb, &y);\n  mpz_realloc(mrb, &x, xx->sz+1);\n  size_t yd = digits(yy);\n  size_t ns = lzb(yy->p[yd-1]);\n  ulshift(mrb, &x, xx, ns);\n  ulshift(mrb, &y, yy, ns);\n  size_t xd = digits(&x);\n  mpz_realloc(mrb, &q, xd);\n  mp_dbl_limb z = y.p[yd-1];\n  if (xd>=yd) {\n    for (size_t j=xd-yd;; j--) {\n      mp_dbl_limb_signed b=0;\n      mp_dbl_limb qhat;\n\n      if (j+yd == xd)\n        qhat = x.p[j+yd-1] / z;\n      else\n        qhat = (((mp_dbl_limb)x.p[j+yd] << DIG_SIZE) + x.p[j+yd-1]) / z;\n      if (qhat) {\n        for (i=0; i<yd; i++) {\n          mp_dbl_limb zz = qhat * y.p[i];\n          mp_dbl_limb_signed u = LOW(b)+x.p[i+j]-LOW(zz);\n          x.p[i+j] = LOW(u);\n          b = HIGH(b) - HIGH(zz) + HIGH(u);\n        }\n        b += x.p[i+j];\n      }\n      for (; b!=0; qhat--) {\n        mp_dbl_limb c = 0;\n        for (i=0; i<yd; i++) {\n          c += (mp_dbl_limb)x.p[i+j] + (mp_dbl_limb)y.p[i];\n          x.p[i+j] = LOW(c);\n          c = HIGH(c);\n        }\n        b += c;\n      }\n      q.p[j] = (mp_limb)qhat;\n      if (j == 0) break;\n    }\n  }\n  x.sz = yy->sz;\n  urshift(mrb, rr, &x, ns);\n  trim(&q);\n  mpz_move(mrb, qq, &q);\n  mpz_clear(mrb, &x);\n  mpz_clear(mrb, &y);\n}\nstatic void\nmpz_mmod(mrb_state *mrb, mpz_t *r, mpz_t *x, mpz_t *y)\n{\n  mpz_t q;\n  short sn1 = x->sn, sn2 = y->sn, sn3;\n\n  mpz_init(mrb, &q);\n  if (sn1 == 0) {\n    zero(r);\n    return;\n  }\n  udiv(mrb, &q, r, x, y);\n  mpz_clear(mrb, &q);\n  if (uzero(r)) {\n    r->sn = 0;\n    return;\n  }\n  sn3 = sn1*sn2;\n  if (sn3 > 0)\n    r->sn = sn1;\n  else if (sn1 < 0 && sn2 > 0) {\n    r->sn = 1;\n    mpz_sub(mrb, r, y, r);\n  }\n  else {\n    r->sn = 1;\n    mpz_add(mrb, r, y, r);\n  }\n}\nmrb_value\nmrb_bint_mod(mrb_state *mrb, mrb_value x, mrb_value y)\n{\n#ifndef MRB_NO_FLOAT\n  if (mrb_float_p(y)) {\n    mrb_float v1 = mrb_bint_as_float(mrb, x);\n    mrb_float v2 = mrb_float(y);\n    return mrb_float_value(mrb, fmod(v1, v2));\n  }\n#endif\n  if (mrb_integer_p(y) && mrb_integer(y) == 0) {\n    mrb_int_zerodiv(mrb);\n  }\n  y = mrb_as_bint(mrb, y);\n  struct RBigint *b = RBIGINT(x);\n  struct RBigint *b2 = RBIGINT(y);\n  struct RBigint *b3 = bint_new(mrb);\n  if (b2->mp.sn == 0 || uzero(&b2->mp)) {\n    mrb_int_zerodiv(mrb);\n  }\n  mpz_mmod(mrb, &b3->mp, &b->mp, &b2->mp);\n  return bint_norm(mrb, b3);\n}\nstatic mrb_value\nint_mod(mrb_state *mrb, mrb_value x)\n{\n  mrb_value y = mrb_get_arg1(mrb);\n  mrb_int a, b;\n\n#ifdef MRB_USE_BIGINT\n  if (mrb_bigint_p(x)) {\n    return mrb_bint_mod(mrb, x, y);\n  }\n#endif\n  a = mrb_integer(x);\n  if (a == 0) return x;\n  if (mrb_integer_p(y)) {\n    b = mrb_integer(y);\n    if (b == 0) mrb_int_zerodiv(mrb);\n    if (a == MRB_INT_MIN && b == -1) return mrb_fixnum_value(0);\n    mrb_int mod = a % b;\n    if ((a < 0) != (b < 0) && mod != 0) {\n      mod += b;\n    }\n    return mrb_int_value(mrb, mod);\n  }\n#ifdef MRB_NO_FLOAT\n  mrb_raise(mrb, E_TYPE_ERROR, \"non integer modulo\");\n#else\n  mrb_float mod;\n\n  flodivmod(mrb, (mrb_float)a, mrb_as_float(mrb, y), NULL, &mod);\n  return mrb_float_value(mrb, mod);\n#endif\n}\nMRB_API mrb_value\nmrb_vm_run(mrb_state *mrb, const struct RProc *proc, mrb_value self, mrb_int stack_keep)\n{\n  const mrb_irep *irep = proc->body.irep;\n  mrb_value result;\n  struct mrb_context *c = mrb->c;\n  ptrdiff_t cioff = c->ci - c->cibase;\n  mrb_int nregs = irep->nregs;\n\n  if (!c->stbase) {\n    stack_init(mrb);\n  }\n  if (stack_keep > nregs)\n    nregs = stack_keep;\n  mrb_stack_extend(mrb, nregs);\n  stack_clear(c->ci->stack + stack_keep, nregs - stack_keep);\n  c->ci->stack[0] = self;\n  result = mrb_vm_exec(mrb, proc, irep->iseq);\n  if (mrb->c != c) {\n    if (mrb->c->fib) {\n      mrb_write_barrier(mrb, (struct RBasic*)mrb->c->fib);\n    }\n    mrb->c = c;\n  }\n  else if (c->ci - c->cibase > cioff) {\n    c->ci = c->cibase + cioff;\n  }\n  return result;\n}\nint FuzzRB(const uint8_t *Data, size_t size) {\n  mrb_value v;\n  mrb_state *mrb = mrb_open();\n  if (!mrb)\n    return 0;\n\n  char *code = (char *)malloc(size+1);\n  if (!code)\n    return 0;\n  memcpy(code, Data, size);\n  code[size] = '\\0';\n\n  if (const char *dump_path = getenv(\"PROTO_FUZZER_DUMP_PATH\")) {\n    // With libFuzzer binary run this to generate an RB file x.rb:\n    // PROTO_FUZZER_DUMP_PATH=x.rb ./a.out proto-input\n    std::ofstream of(dump_path);\n    of.write(code, size);\n  }\n  std::cout << \"\\n\\n############\\n\" << code << \"\\n############\\n\\n\";\n  v = mrb_load_string(mrb, code);\n  mrb_close(mrb);\n\n  free(code);\n  return 0;\n}",
    "target": 0,
    "idx": 2049845
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "static const char* jvp_literal_number_literal(jv n) {\n  assert(JVP_HAS_FLAGS(n, JVP_FLAGS_NUMBER_LITERAL));\n  decNumber *pdec = jvp_dec_number_ptr(n);\n  jvp_literal_number* plit = jvp_literal_number_ptr(n);\n\n  if (decNumberIsNaN(pdec)) {\n    return \"null\";\n  }\n\n  if (decNumberIsInfinite(pdec)) {\n    // We cannot preserve the literal data of numbers outside the limited\n    // range of exponent. Since `decNumberToString` returns \"Infinity\"\n    // (or \"-Infinity\"), and to reduce stack allocations as possible, we\n    // normalize infinities in the callers instead of printing the maximum\n    // (or minimum) double here.\n    return NULL;\n  }\n\n  if (plit->literal_data == NULL) {\n    int len = jvp_dec_number_ptr(n)->digits + 15 /* 14 + NUL */;\n    plit->literal_data = jv_mem_alloc(len);\n\n    // Preserve the actual precision as we have parsed it\n    // don't do decNumberTrim(pdec);\n\n    decNumberToString(pdec, plit->literal_data);\n  }\n\n  return plit->literal_data;\n}\nchar * decNumberToString(const decNumber *dn, char *string){\n  decToString(dn, string, 0);\n  return string;\n  } // DecNumberToString\nconst char* jv_number_get_literal(jv n) {\n  assert(JVP_HAS_KIND(n, JV_KIND_NUMBER));\n\n  if (JVP_HAS_FLAGS(n, JVP_FLAGS_NUMBER_LITERAL)) {\n    return jvp_literal_number_literal(n);\n  } else {\n    return NULL;\n  }\n}\nint LLVMFuzzerTestOneInput(uint8_t *data, size_t size) {\n  if (size < 8) {\n    return 0;\n  }\n\n  int fuzz_flags = *(int*)data;\n  data += 4;\n  size -= 4;\n  int dump_flags = *(int*)data;\n  data += 4;\n  size -= 4;\n\n  // Creat null-terminated string\n  char *null_terminated = (char *)malloc(size + 1);\n  memcpy(null_terminated, (char *)data, size);\n  null_terminated[size] = '\\0';\n\n  // Fuzzer entrypoint\n  jv res = jv_parse_custom_flags(null_terminated, fuzz_flags);\n  if (jv_is_valid(res)) {\n    jv_dump(res, dump_flags);\n  } else {\n    jv_free(res);\n  }\n\n  // Free the null-terminated string\n  free(null_terminated);\n\n  return 0;\n}",
    "target": 0,
    "idx": 2064574
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "extern int\nonigenc_unicode_get_case_fold_codes_by_str(OnigEncoding enc,\n    OnigCaseFoldType flag, const OnigUChar* p, const OnigUChar* end,\n    OnigCaseFoldCodeItem items[])\n{\n  int n, m, i, j, k, len, lens[3];\n  int index;\n  int fn, ncs[3];\n  OnigCodePoint cs[3][4];\n  OnigCodePoint code, codes[3], orig_codes[3];\n  const struct ByUnfoldKey* buk1;\n\n  n = 0;\n\n  code = ONIGENC_MBC_TO_CODE(enc, p, end);\n  len = enclen(enc, p);\n\n#ifdef USE_UNICODE_CASE_FOLD_TURKISH_AZERI\n  if ((flag & ONIGENC_CASE_FOLD_TURKISH_AZERI) != 0) {\n    if (code == 0x0049) {\n      items[0].byte_len = len;\n      items[0].code_len = 1;\n      items[0].code[0]  = 0x0131;\n      return 1;\n    }\n    else if (code == 0x0130) {\n      items[0].byte_len = len;\n      items[0].code_len = 1;\n      items[0].code[0]  = 0x0069;\n      return 1;\n    }\n    else if (code == 0x0131) {\n      items[0].byte_len = len;\n      items[0].code_len = 1;\n      items[0].code[0]  = 0x0049;\n      return 1;\n    }\n    else if (code == 0x0069) {\n      items[0].byte_len = len;\n      items[0].code_len = 1;\n      items[0].code[0]  = 0x0130;\n      return 1;\n    }\n  }\n#endif\n\n  orig_codes[0] = code;\n  lens[0] = len;\n  p += len;\n\n  buk1 = onigenc_unicode_unfold_key(orig_codes[0]);\n  if (buk1 != 0 && buk1->fold_len == 1) {\n    codes[0] = *FOLDS1_FOLD(buk1->index);\n  }\n  else\n    codes[0] = orig_codes[0];\n\n  if ((flag & INTERNAL_ONIGENC_CASE_FOLD_MULTI_CHAR) == 0)\n    goto fold1;\n\n  if (p < end) {\n    const struct ByUnfoldKey* buk;\n\n    code = ONIGENC_MBC_TO_CODE(enc, p, end);\n    orig_codes[1] = code;\n    len = enclen(enc, p);\n    lens[1] = lens[0] + len;\n    buk = onigenc_unicode_unfold_key(orig_codes[1]);\n    if (buk != 0 && buk->fold_len == 1) {\n      codes[1] = *FOLDS1_FOLD(buk->index);\n    }\n    else\n      codes[1] = orig_codes[1];\n\n    p += len;\n    if (p < end) {\n      code = ONIGENC_MBC_TO_CODE(enc, p, end);\n      orig_codes[2] = code;\n      len = enclen(enc, p);\n      lens[2] = lens[1] + len;\n      buk = onigenc_unicode_unfold_key(orig_codes[2]);\n      if (buk != 0 && buk->fold_len == 1) {\n        codes[2] = *FOLDS1_FOLD(buk->index);\n      }\n      else\n        codes[2] = orig_codes[2];\n\n      index = onigenc_unicode_fold3_key(codes);\n      if (index >= 0) {\n        m = FOLDS3_UNFOLDS_NUM(index);\n        for (i = 0; i < m; i++) {\n          items[n].byte_len = lens[2];\n          items[n].code_len = 1;\n          items[n].code[0]  = FOLDS3_UNFOLDS(index)[i];\n          n++;\n        }\n\n        for (fn = 0; fn < 3; fn++) {\n          int sindex;\n          cs[fn][0] = FOLDS3_FOLD(index)[fn];\n          ncs[fn] = 1;\n          sindex = onigenc_unicode_fold1_key(&cs[fn][0]);\n          if (sindex >= 0) {\n            int m = FOLDS1_UNFOLDS_NUM(sindex);\n            for (i = 0; i < m; i++) {\n              cs[fn][i+1] = FOLDS1_UNFOLDS(sindex)[i];\n            }\n            ncs[fn] += m;\n          }\n        }\n\n        for (i = 0; i < ncs[0]; i++) {\n          for (j = 0; j < ncs[1]; j++) {\n            for (k = 0; k < ncs[2]; k++) {\n              items[n].byte_len = lens[2];\n              items[n].code_len = 3;\n              items[n].code[0]  = cs[0][i];\n              items[n].code[1]  = cs[1][j];\n              items[n].code[2]  = cs[2][k];\n              if (items[n].code[0] == orig_codes[0] &&\n                  items[n].code[1] == orig_codes[1] &&\n                  items[n].code[2] == orig_codes[2])\n                continue;\n              n++;\n            }\n          }\n        }\n\n        return n;\n      }\n    }\n\n    index = onigenc_unicode_fold2_key(codes);\n    if (index >= 0) {\n      m = FOLDS2_UNFOLDS_NUM(index);\n      for (i = 0; i < m; i++) {\n        items[n].byte_len = lens[1];\n        items[n].code_len = 1;\n        items[n].code[0]  = FOLDS2_UNFOLDS(index)[i];\n        n++;\n      }\n\n      for (fn = 0; fn < 2; fn++) {\n        int sindex;\n        cs[fn][0] = FOLDS2_FOLD(index)[fn];\n        ncs[fn] = 1;\n        sindex = onigenc_unicode_fold1_key(&cs[fn][0]);\n        if (sindex >= 0) {\n          int m = FOLDS1_UNFOLDS_NUM(sindex);\n          for (i = 0; i < m; i++) {\n            cs[fn][i+1] = FOLDS1_UNFOLDS(sindex)[i];\n          }\n          ncs[fn] += m;\n        }\n      }\n\n      for (i = 0; i < ncs[0]; i++) {\n        for (j = 0; j < ncs[1]; j++) {\n          if (cs[0][i] == orig_codes[0] && cs[1][j] == orig_codes[1])\n            continue;\n          items[n].byte_len = lens[1];\n          items[n].code_len = 2;\n          items[n].code[0]  = cs[0][i];\n          items[n].code[1]  = cs[1][j];\n          n++;\n        }\n      }\n\n      return n;\n    }\n  }\n\n fold1:\n  if (buk1 != 0) {\n    if (buk1->fold_len == 1) {\n      int un;\n      items[0].byte_len = lens[0];\n      items[0].code_len = 1;\n      items[0].code[0]  = *FOLDS1_FOLD(buk1->index);\n      n++;\n\n      un = FOLDS1_UNFOLDS_NUM(buk1->index);\n      for (i = 0; i < un; i++) {\n        OnigCodePoint unfold = FOLDS1_UNFOLDS(buk1->index)[i];\n        if (unfold != orig_codes[0]) {\n          items[n].byte_len = lens[0];\n          items[n].code_len = 1;\n          items[n].code[0]  = unfold;\n          n++;\n        }\n      }\n    }\n    else if ((flag & INTERNAL_ONIGENC_CASE_FOLD_MULTI_CHAR) != 0) {\n      if (buk1->fold_len == 2) {\n        m = FOLDS2_UNFOLDS_NUM(buk1->index);\n        for (i = 0; i < m; i++) {\n          OnigCodePoint unfold = FOLDS2_UNFOLDS(buk1->index)[i];\n          if (unfold == orig_codes[0]) continue;\n\n          items[n].byte_len = lens[0];\n          items[n].code_len = 1;\n          items[n].code[0]  = unfold;\n          n++;\n        }\n\n        for (fn = 0; fn < 2; fn++) {\n          int index;\n          cs[fn][0] = FOLDS2_FOLD(buk1->index)[fn];\n          ncs[fn] = 1;\n          index = onigenc_unicode_fold1_key(&cs[fn][0]);\n          if (index >= 0) {\n            int m = FOLDS1_UNFOLDS_NUM(index);\n            for (i = 0; i < m; i++) {\n              cs[fn][i+1] = FOLDS1_UNFOLDS(index)[i];\n            }\n            ncs[fn] += m;\n          }\n        }\n\n        for (i = 0; i < ncs[0]; i++) {\n          for (j = 0; j < ncs[1]; j++) {\n            items[n].byte_len = lens[0];\n            items[n].code_len = 2;\n            items[n].code[0]  = cs[0][i];\n            items[n].code[1]  = cs[1][j];\n            n++;\n          }\n        }\n      }\n      else { /* fold_len == 3 */\n        m = FOLDS3_UNFOLDS_NUM(buk1->index);\n        for (i = 0; i < m; i++) {\n          OnigCodePoint unfold = FOLDS3_UNFOLDS(buk1->index)[i];\n          if (unfold == orig_codes[0]) continue;\n\n          items[n].byte_len = lens[0];\n          items[n].code_len = 1;\n          items[n].code[0]  = unfold;\n          n++;\n        }\n\n        for (fn = 0; fn < 3; fn++) {\n          int index;\n          cs[fn][0] = FOLDS3_FOLD(buk1->index)[fn];\n          ncs[fn] = 1;\n          index = onigenc_unicode_fold1_key(&cs[fn][0]);\n          if (index >= 0) {\n            int m = FOLDS1_UNFOLDS_NUM(index);\n            for (i = 0; i < m; i++) {\n              cs[fn][i+1] = FOLDS1_UNFOLDS(index)[i];\n            }\n            ncs[fn] += m;\n          }\n        }\n\n        for (i = 0; i < ncs[0]; i++) {\n          for (j = 0; j < ncs[1]; j++) {\n            for (k = 0; k < ncs[2]; k++) {\n              items[n].byte_len = lens[0];\n              items[n].code_len = 3;\n              items[n].code[0]  = cs[0][i];\n              items[n].code[1]  = cs[1][j];\n              items[n].code[2]  = cs[2][k];\n              n++;\n            }\n          }\n        }\n      }\n    }\n  }\n  else {\n    int index = onigenc_unicode_fold1_key(orig_codes);\n    if (index >= 0) {\n      int m = FOLDS1_UNFOLDS_NUM(index);\n      for (i = 0; i < m; i++) {\n        items[n].byte_len = lens[0];\n        items[n].code_len = 1;\n        items[n].code[0]  = FOLDS1_UNFOLDS(index)[i];\n        n++;\n      }\n    }\n  }\n\n  return n;\n}\nstatic int\nutf16be_get_case_fold_codes_by_str(OnigCaseFoldType flag,\n    const OnigUChar* p, const OnigUChar* end, OnigCaseFoldCodeItem items[])\n{\n  return onigenc_unicode_get_case_fold_codes_by_str(ONIG_ENCODING_UTF16_BE,\n                                                    flag, p, end, items);\n}\nstatic int\nunravel_case_fold_string(Node* node, regex_t* reg, int state)\n{\n  int r, n, in_look_behind;\n  OnigLen min_len, max_len, one_len;\n  UChar *start, *end, *p, *q;\n  StrNode* snode;\n  Node *sn, *list;\n  OnigEncoding enc;\n  OnigCaseFoldCodeItem items[ONIGENC_GET_CASE_FOLD_CODES_MAX_NUM];\n\n  if (NODE_STRING_IS_CASE_EXPANDED(node)) return 0;\n\n  NODE_STATUS_REMOVE(node, IGNORECASE);\n  snode = STR_(node);\n  start = snode->s;\n  end   = snode->end;\n  if (start >= end) return 0;\n\n  in_look_behind = (state & IN_LOOK_BEHIND) != 0;\n  enc = reg->enc;\n\n  list = sn = NULL_NODE;\n  p = start;\n  while (p < end) {\n    n = ONIGENC_GET_CASE_FOLD_CODES_BY_STR(enc, reg->case_fold_flag, p, end,\n                                           items);\n    if (n < 0) {\n      r = n;\n      goto err;\n    }\n\n    one_len = (OnigLen )enclen(enc, p);\n    if (n == 0) {\n      q = p + one_len;\n      if (q > end) q = end;\n      r = unravel_cf_string_add(&list, &sn, p, q, 0 /* flag */);\n      if (r != 0) goto err;\n    }\n    else {\n      if (in_look_behind != 0) {\n        q = p + one_len;\n        if (items[0].byte_len != one_len) {\n          r = ONIGENC_GET_CASE_FOLD_CODES_BY_STR(enc, reg->case_fold_flag, p, q,\n                                                 items);\n          if (r < 0) goto err;\n          n = r;\n        }\n        r = unravel_cf_look_behind_add(&list, &sn, n, items, enc, p, one_len);\n        if (r != 0) goto err;\n      }\n      else {\n        get_min_max_byte_len_case_fold_items(n, items, &min_len, &max_len);\n        if (min_len != max_len) {\n          r = ONIGERR_PARSER_BUG;\n          goto err;\n        }\n\n        q = p + max_len;\n        r = unravel_cf_string_alt_or_cc_add(&list, n, items, enc,\n                                            reg->case_fold_flag, p, q);\n        if (r != 0) goto err;\n        sn = NULL_NODE;\n      }\n    }\n\n    p = q;\n  }\n\n  if (IS_NOT_NULL(list)) {\n    if (node_list_len(list) == 1) {\n      node_swap(node, NODE_CAR(list));\n    }\n    else {\n      node_swap(node, list);\n    }\n    onig_node_free(list);\n  }\n  else {\n    node_swap(node, sn);\n    onig_node_free(sn);\n  }\n  return 0;\n\n err:\n  if (IS_NOT_NULL(list))\n    onig_node_free(list);\n  else if (IS_NOT_NULL(sn))\n    onig_node_free(sn);\n\n  return r;\n}\nstatic int\ntune_tree(Node* node, regex_t* reg, int state, ScanEnv* env)\n{\n  int r = 0;\n\n  switch (NODE_TYPE(node)) {\n  case NODE_LIST:\n    {\n      Node* prev = NULL_NODE;\n      do {\n        r = tune_tree(NODE_CAR(node), reg, state, env);\n        if (IS_NOT_NULL(prev) && r == 0) {\n          r = tune_next(prev, NODE_CAR(node), reg);\n        }\n        prev = NODE_CAR(node);\n      } while (r == 0 && IS_NOT_NULL(node = NODE_CDR(node)));\n    }\n    break;\n\n  case NODE_ALT:\n    do {\n      r = tune_tree(NODE_CAR(node), reg, (state | IN_ALT), env);\n    } while (r == 0 && IS_NOT_NULL(node = NODE_CDR(node)));\n    break;\n\n  case NODE_STRING:\n    if (NODE_IS_IGNORECASE(node) && ! NODE_STRING_IS_CRUDE(node)) {\n      r = unravel_case_fold_string(node, reg, state);\n    }\n    break;\n\n  case NODE_BACKREF:\n    {\n      int i;\n      int* p;\n      BackRefNode* br = BACKREF_(node);\n      p = BACKREFS_P(br);\n      for (i = 0; i < br->back_num; i++) {\n        if (p[i] > env->num_mem)  return ONIGERR_INVALID_BACKREF;\n        MEM_STATUS_ON(env->backrefed_mem, p[i]);\n#if 0\n#ifdef USE_BACKREF_WITH_LEVEL\n        if (NODE_IS_NEST_LEVEL(node)) {\n          MEM_STATUS_ON(env->backtrack_mem, p[i]);\n        }\n#endif\n#else\n        /* More precisely, it should be checked whether alt/repeat exists before\n           the subject capture node, and then this backreference position\n           exists before (or in) the capture node. */\n        MEM_STATUS_ON(env->backtrack_mem, p[i]);\n#endif\n      }\n    }\n    break;\n\n  case NODE_BAG:\n    {\n      BagNode* en = BAG_(node);\n\n      switch (en->type) {\n      case BAG_OPTION:\n        {\n          OnigOptionType options = reg->options;\n          reg->options = BAG_(node)->o.options;\n          r = tune_tree(NODE_BODY(node), reg, state, env);\n          reg->options = options;\n        }\n        break;\n\n      case BAG_MEMORY:\n#ifdef USE_CALL\n        state |= en->m.called_state;\n#endif\n\n        if ((state & (IN_ALT | IN_NOT | IN_VAR_REPEAT | IN_MULTI_ENTRY)) != 0\n            || NODE_IS_RECURSION(node)) {\n          MEM_STATUS_ON(env->backtrack_mem, en->m.regnum);\n        }\n        r = tune_tree(NODE_BODY(node), reg, state, env);\n        break;\n\n      case BAG_STOP_BACKTRACK:\n        {\n          Node* target = NODE_BODY(node);\n          r = tune_tree(target, reg, state, env);\n          if (NODE_TYPE(target) == NODE_QUANT) {\n            QuantNode* tqn = QUANT_(target);\n            if (IS_INFINITE_REPEAT(tqn->upper) && tqn->lower <= 1 &&\n                tqn->greedy != 0) {  /* (?>a*), a*+ etc... */\n              if (is_strict_real_node(NODE_BODY(target)))\n                NODE_STATUS_ADD(node, STRICT_REAL_REPEAT);\n            }\n          }\n        }\n        break;\n\n      case BAG_IF_ELSE:\n        r = tune_tree(NODE_BODY(node), reg, (state | IN_ALT), env);\n        if (r != 0) return r;\n        if (IS_NOT_NULL(en->te.Then)) {\n          r = tune_tree(en->te.Then, reg, (state | IN_ALT), env);\n          if (r != 0) return r;\n        }\n        if (IS_NOT_NULL(en->te.Else))\n          r = tune_tree(en->te.Else, reg, (state | IN_ALT), env);\n        break;\n      }\n    }\n    break;\n\n  case NODE_QUANT:\n    r = tune_quant(node, reg, state, env);\n    break;\n\n  case NODE_ANCHOR:\n    r = tune_anchor(node, reg, state, env);\n    break;\n\n#ifdef USE_CALL\n  case NODE_CALL:\n#endif\n  case NODE_CTYPE:\n  case NODE_CCLASS:\n  case NODE_GIMMICK:\n  default:\n    break;\n  }\n\n  return r;\n}\nextern int\nonig_compile(regex_t* reg, const UChar* pattern, const UChar* pattern_end,\n             OnigErrorInfo* einfo)\n{\n  int r;\n  Node*  root;\n  ScanEnv  scan_env;\n#ifdef USE_CALL\n  UnsetAddrList  uslist = {0};\n#endif\n\n  root = 0;\n  if (IS_NOT_NULL(einfo)) {\n    einfo->enc = reg->enc;\n    einfo->par = (UChar* )NULL;\n  }\n\n#ifdef ONIG_DEBUG\n  fprintf(DBGFP, \"\\nPATTERN: /\");\n  print_enc_string(DBGFP, reg->enc, pattern, pattern_end);\n#endif\n\n  if (reg->ops_alloc == 0) {\n    r = ops_init(reg, OPS_INIT_SIZE);\n    if (r != 0) goto end;\n  }\n  else\n    reg->ops_used = 0;\n\n  r = onig_parse_tree(&root, pattern, pattern_end, reg, &scan_env);\n  if (r != 0) goto err;\n\n  r = reduce_string_list(root, reg->enc);\n  if (r != 0) goto err;\n\n  /* mixed use named group and no-named group */\n  if (scan_env.num_named > 0 &&\n      IS_SYNTAX_BV(scan_env.syntax, ONIG_SYN_CAPTURE_ONLY_NAMED_GROUP) &&\n      ! OPTON_CAPTURE_GROUP(reg->options)) {\n    if (scan_env.num_named != scan_env.num_mem)\n      r = disable_noname_group_capture(&root, reg, &scan_env);\n    else\n      r = numbered_ref_check(root);\n\n    if (r != 0) goto err;\n  }\n\n  r = check_backrefs(root, &scan_env);\n  if (r != 0) goto err;\n\n#ifdef USE_CALL\n  if (scan_env.num_call > 0) {\n    r = unset_addr_list_init(&uslist, scan_env.num_call);\n    if (r != 0) goto err;\n    scan_env.unset_addr_list = &uslist;\n    r = tune_call(root, &scan_env, 0);\n    if (r != 0) goto err_unset;\n    r = tune_call2(root);\n    if (r != 0) goto err_unset;\n    r = recursive_call_check_trav(root, &scan_env, 0);\n    if (r  < 0) goto err_unset;\n    r = infinite_recursive_call_check_trav(root, &scan_env);\n    if (r != 0) goto err_unset;\n\n    tune_called_state(root, 0);\n  }\n\n  reg->num_call = scan_env.num_call;\n#endif\n\n#ifdef ONIG_DEBUG_PARSE\n  fprintf(DBGFP, \"MAX PARSE DEPTH: %d\\n\", scan_env.max_parse_depth);\n  fprintf(DBGFP, \"TREE (parsed)\\n\");\n  print_tree(DBGFP, root);\n  fprintf(DBGFP, \"\\n\");\n#endif\n\n  r = tune_tree(root, reg, 0, &scan_env);\n  if (r != 0) goto err_unset;\n\n  if (scan_env.backref_num != 0) {\n    set_parent_node_trav(root, NULL_NODE);\n    r = set_empty_repeat_node_trav(root, NULL_NODE, &scan_env);\n    if (r != 0) goto err_unset;\n    set_empty_status_check_trav(root, &scan_env);\n  }\n\n#ifdef ONIG_DEBUG_PARSE\n  fprintf(DBGFP, \"TREE (after tune)\\n\");\n  print_tree(DBGFP, root);\n  fprintf(DBGFP, \"\\n\");\n#endif\n\n  reg->capture_history = scan_env.cap_history;\n  reg->push_mem_start  = scan_env.backtrack_mem | scan_env.cap_history;\n\n#ifdef USE_CALLOUT\n  if (IS_NOT_NULL(reg->extp) && reg->extp->callout_num != 0) {\n    reg->push_mem_end = reg->push_mem_start;\n  }\n  else {\n    if (MEM_STATUS_IS_ALL_ON(reg->push_mem_start))\n      reg->push_mem_end = scan_env.backrefed_mem | scan_env.cap_history;\n    else\n      reg->push_mem_end = reg->push_mem_start &\n                        (scan_env.backrefed_mem | scan_env.cap_history);\n  }\n#else\n  if (MEM_STATUS_IS_ALL_ON(reg->push_mem_start))\n    reg->push_mem_end = scan_env.backrefed_mem | scan_env.cap_history;\n  else\n    reg->push_mem_end = reg->push_mem_start &\n                      (scan_env.backrefed_mem | scan_env.cap_history);\n#endif\n\n  clear_optimize_info(reg);\n#ifndef ONIG_DONT_OPTIMIZE\n  r = set_optimize_info_from_tree(root, reg, &scan_env);\n  if (r != 0) goto err_unset;\n#endif\n\n  if (IS_NOT_NULL(scan_env.mem_env_dynamic)) {\n    xfree(scan_env.mem_env_dynamic);\n    scan_env.mem_env_dynamic = (MemEnv* )NULL;\n  }\n\n  r = compile_tree(root, reg, &scan_env);\n  if (r == 0) {\n    if (scan_env.keep_num > 0) {\n      r = add_op(reg, OP_UPDATE_VAR);\n      if (r != 0) goto err;\n\n      COP(reg)->update_var.type = UPDATE_VAR_KEEP_FROM_STACK_LAST;\n      COP(reg)->update_var.id   = 0; /* not used */\n      COP(reg)->update_var.clear = FALSE;\n    }\n\n    r = add_op(reg, OP_END);\n    if (r != 0) goto err;\n\n#ifdef USE_CALL\n    if (scan_env.num_call > 0) {\n      r = fix_unset_addr_list(&uslist, reg);\n      unset_addr_list_end(&uslist);\n      if (r != 0) goto err;\n    }\n#endif\n\n    set_addr_in_repeat_range(reg);\n\n    if ((reg->push_mem_end != 0)\n#ifdef USE_REPEAT_AND_EMPTY_CHECK_LOCAL_VAR\n        || (reg->num_repeat      != 0)\n        || (reg->num_empty_check != 0)\n#endif\n#ifdef USE_CALLOUT\n        || (IS_NOT_NULL(reg->extp) && reg->extp->callout_num != 0)\n#endif\n#ifdef USE_CALL\n        || scan_env.num_call > 0\n#endif\n        )\n      reg->stack_pop_level = STACK_POP_LEVEL_ALL;\n    else {\n      if (reg->push_mem_start != 0)\n        reg->stack_pop_level = STACK_POP_LEVEL_MEM_START;\n      else\n        reg->stack_pop_level = STACK_POP_LEVEL_FREE;\n    }\n\n    r = ops_make_string_pool(reg);\n    if (r != 0) goto err;\n  }\n#ifdef USE_CALL\n  else if (scan_env.num_call > 0) {\n    unset_addr_list_end(&uslist);\n  }\n#endif\n  onig_node_free(root);\n\n#ifdef ONIG_DEBUG_COMPILE\n  onig_print_names(DBGFP, reg);\n  onig_print_compiled_byte_code_list(DBGFP, reg);\n#endif\n\n#ifdef USE_DIRECT_THREADED_CODE\n  /* opcode -> opaddr */\n  onig_init_for_match_at(reg);\n#endif\n\n end:\n  return r;\n\n err_unset:\n#ifdef USE_CALL\n  if (scan_env.num_call > 0) {\n    unset_addr_list_end(&uslist);\n  }\n#endif\n err:\n  if (IS_NOT_NULL(scan_env.error)) {\n    if (IS_NOT_NULL(einfo)) {\n      einfo->par     = scan_env.error;\n      einfo->par_end = scan_env.error_end;\n    }\n  }\n\n  onig_node_free(root);\n  if (IS_NOT_NULL(scan_env.mem_env_dynamic))\n      xfree(scan_env.mem_env_dynamic);\n  return r;\n}\nextern int\nonig_new(regex_t** reg, const UChar* pattern, const UChar* pattern_end,\n         OnigOptionType option, OnigEncoding enc, OnigSyntaxType* syntax,\n         OnigErrorInfo* einfo)\n{\n  int r;\n\n  *reg = (regex_t* )xmalloc(sizeof(regex_t));\n  if (IS_NULL(*reg)) return ONIGERR_MEMORY;\n\n  r = onig_reg_init(*reg, option, ONIGENC_CASE_FOLD_DEFAULT, enc, syntax);\n  if (r != 0) {\n    xfree(*reg);\n    *reg = NULL;\n    return r;\n  }\n\n  r = onig_compile(*reg, pattern, pattern_end, einfo);\n  if (r != 0) {\n    onig_free(*reg);\n    *reg = NULL;\n  }\n  return r;\n}\nstatic int\nexec(OnigEncoding enc, OnigOptionType options, OnigSyntaxType* syntax,\n     char* apattern, char* apattern_end, char* astr, UChar* end, int backward,\n     int sl)\n{\n  int r;\n  regex_t* reg;\n  OnigErrorInfo einfo;\n  UChar* pattern = (UChar* )apattern;\n  UChar* str     = (UChar* )astr;\n  UChar* pattern_end = (UChar* )apattern_end;\n\n  EXEC_COUNT++;\n  EXEC_COUNT_INTERVAL++;\n\n  onig_initialize(&enc, 1);\n#ifdef PARSE_DEPTH_LIMIT\n  onig_set_parse_depth_limit(PARSE_DEPTH_LIMIT);\n#endif\n  onig_set_subexp_call_max_nest_level(CALL_MAX_NEST_LEVEL);\n\n  r = onig_new(&reg, pattern, pattern_end,\n               (options & OPTIONS_AT_COMPILE), enc, syntax, &einfo);\n  if (r != ONIG_NORMAL) {\n    char s[ONIG_MAX_ERROR_MESSAGE_LEN];\n    onig_error_code_to_str((UChar* )s, r, &einfo);\n#ifdef STANDALONE\n    fprintf(stdout, \"ERROR: %s\\n\", s);\n#endif\n    onig_end();\n\n    if (r == ONIGERR_PARSER_BUG ||\n        r == ONIGERR_STACK_BUG  ||\n        r == ONIGERR_UNDEFINED_BYTECODE ||\n        r == ONIGERR_UNEXPECTED_BYTECODE) {\n      return -2;\n    }\n    else\n      return -1;\n  }\n  REGEX_SUCCESS_COUNT++;\n\n  r = search(reg, pattern, pattern_end, options, backward, sl);\n  if (r == -2) return -2;\n\n  if (onigenc_is_valid_mbc_string(enc, str, end) != 0) {\n    VALID_STRING_COUNT++;\n    r = search(reg, str, end, options, backward, sl);\n    if (r == -2) return -2;\n  }\n\n  onig_free(reg);\n  onig_end();\n  return 0;\n}\nstatic int\nalloc_exec(OnigEncoding enc, OnigOptionType options, OnigSyntaxType* syntax,\n           int backward, int pattern_size, size_t rem_size, unsigned char *data)\n{\n  extern int onig_detect_can_be_slow_pattern(const UChar* pattern, const UChar* pattern_end, OnigOptionType option, OnigEncoding enc, OnigSyntaxType* syntax);\n\n  int r;\n  int sl;\n  unsigned char *pattern;\n  unsigned char *pattern_end;\n  unsigned char *str_null_end;\n\n  pattern = (unsigned char *)malloc(pattern_size != 0 ? pattern_size : 1);\n  memcpy(pattern, data, pattern_size);\n  pattern_end = pattern + pattern_size;\n  data += pattern_size;\n  rem_size -= pattern_size;\n\n  if (rem_size > MAX_REM_SIZE) rem_size = MAX_REM_SIZE;\n\n  sl = onig_detect_can_be_slow_pattern(pattern, pattern_end, options, enc, syntax);\n  if (sl > 0) {\n    if (rem_size > MAX_SLOW_REM_SIZE)\n      rem_size = MAX_SLOW_REM_SIZE;\n  }\n\n  ADJUST_LEN(enc, rem_size);\n#ifdef STANDALONE\n  fprintf(stdout, \"rem_size: %ld\\n\", rem_size);\n#endif\n\n  unsigned char *str = (unsigned char*)malloc(rem_size != 0 ? rem_size : 1);\n  memcpy(str, data, rem_size);\n  str_null_end = str + rem_size;\n\n  r = exec(enc, options, syntax,\n           (char *)pattern, (char *)pattern_end,\n           (char *)str, str_null_end, backward, sl);\n\n  free(pattern);\n  free(str);\n  return r;\n}\nint LLVMFuzzerTestOneInput(const uint8_t * Data, size_t Size)\n{\n#if !defined(UTF16_BE) && !defined(UTF16_LE)\n  static OnigEncoding encodings[] = {\n    ONIG_ENCODING_UTF8,\n    ONIG_ENCODING_UTF8,\n    ONIG_ENCODING_UTF8,\n    ONIG_ENCODING_UTF8,\n    ONIG_ENCODING_UTF8,\n    ONIG_ENCODING_UTF8,\n    ONIG_ENCODING_UTF8,\n    ONIG_ENCODING_UTF8,\n    ONIG_ENCODING_ASCII,\n    ONIG_ENCODING_EUC_JP,\n    ONIG_ENCODING_EUC_TW,\n    ONIG_ENCODING_EUC_KR,\n    ONIG_ENCODING_EUC_CN,\n    ONIG_ENCODING_SJIS,\n    ONIG_ENCODING_KOI8_R,\n    ONIG_ENCODING_CP1251,\n    ONIG_ENCODING_BIG5,\n    ONIG_ENCODING_GB18030,\n    ONIG_ENCODING_UTF16_BE,\n    ONIG_ENCODING_UTF16_LE,\n    ONIG_ENCODING_UTF16_BE,\n    ONIG_ENCODING_UTF16_LE,\n    ONIG_ENCODING_UTF32_BE,\n    ONIG_ENCODING_UTF32_LE,\n    ONIG_ENCODING_UTF32_BE,\n    ONIG_ENCODING_UTF32_LE,\n    ONIG_ENCODING_ISO_8859_1,\n    ONIG_ENCODING_ISO_8859_2,\n    ONIG_ENCODING_ISO_8859_3,\n    ONIG_ENCODING_ISO_8859_4,\n    ONIG_ENCODING_ISO_8859_5,\n    ONIG_ENCODING_ISO_8859_6,\n    ONIG_ENCODING_ISO_8859_7,\n    ONIG_ENCODING_ISO_8859_8,\n    ONIG_ENCODING_ISO_8859_9,\n    ONIG_ENCODING_ISO_8859_10,\n    ONIG_ENCODING_ISO_8859_11,\n    ONIG_ENCODING_ISO_8859_13,\n    ONIG_ENCODING_ISO_8859_14,\n    ONIG_ENCODING_ISO_8859_15,\n    ONIG_ENCODING_ISO_8859_16\n  };\n  unsigned char encoding_choice;\n#endif\n\n#ifdef SYNTAX_TEST\n  static OnigSyntaxType* syntaxes[] = {\n    ONIG_SYNTAX_POSIX_EXTENDED,\n    ONIG_SYNTAX_EMACS,\n    ONIG_SYNTAX_GREP,\n    ONIG_SYNTAX_GNU_REGEX,\n    ONIG_SYNTAX_JAVA,\n    ONIG_SYNTAX_PERL_NG,\n    ONIG_SYNTAX_ONIGURUMA\n  };\n\n#ifdef STANDALONE\n  static char* syntax_names[] = {\n    \"Posix Extended\",\n    \"Emacs\",\n    \"Grep\",\n    \"GNU Regex\",\n    \"Java\",\n    \"Perl+NG\",\n    \"Oniguruma\"\n  };\n#endif\n\n  unsigned char syntax_choice;\n#endif\n\n  int r;\n  int backward;\n  int pattern_size;\n  size_t rem_size;\n  unsigned char *data;\n  unsigned char pattern_size_choice;\n  OnigOptionType  options;\n  OnigEncoding    enc;\n  OnigSyntaxType* syntax;\n\n#ifndef STANDALONE\n  static FILE* STAT_FP;\n#endif\n\n  INPUT_COUNT++;\n\n#ifdef DUMP_DATA_INTERVAL\n  if (INPUT_COUNT % DUMP_DATA_INTERVAL == 0) {\n    char path[20];\n    sprintf(path, \"dump-%ld\", INPUT_COUNT);\n    dump_file(path, (unsigned char* )Data, Size);\n  }\n#endif\n\n  if (Size < NUM_CONTROL_BYTES) return 0;\n\n  rem_size = Size;\n  data = (unsigned char* )(Data);\n\n#ifdef UTF16_BE\n  enc = ONIG_ENCODING_UTF16_BE;\n#else\n#ifdef UTF16_LE\n  enc = ONIG_ENCODING_UTF16_LE;\n#else\n  encoding_choice = data[0];\n  data++;\n  rem_size--;\n\n  int num_encodings = sizeof(encodings)/sizeof(encodings[0]);\n  enc = encodings[encoding_choice % num_encodings];\n#endif\n#endif\n\n#ifdef SYNTAX_TEST\n  syntax_choice = data[0];\n  data++;\n  rem_size--;\n\n  int num_syntaxes = sizeof(syntaxes)/sizeof(syntaxes[0]);\n  syntax = syntaxes[syntax_choice % num_syntaxes];\n#else\n  syntax = ONIG_SYNTAX_DEFAULT;\n#endif\n\n  if ((data[2] & 0xc0) == 0)\n    options = data[0] | (data[1] << 8) | (data[2] << 16);\n  else\n    options = data[0] & ONIG_OPTION_IGNORECASE;\n\n  data++; rem_size--;\n  data++; rem_size--;\n  data++; rem_size--;\n\n  pattern_size_choice = data[0];\n  data++; rem_size--;\n\n  backward = (data[0] == 0xbb);\n  data++; rem_size--;\n\n  if (backward != 0) {\n    options = options & ~ONIG_OPTION_FIND_LONGEST;\n  }\n\n  if (rem_size == 0)\n    pattern_size = 0;\n  else {\n    pattern_size = (int )pattern_size_choice % rem_size;\n    ADJUST_LEN(enc, pattern_size);\n  }\n\n#ifdef STANDALONE\n  dump_data(stdout, data, pattern_size);\n#ifdef SYNTAX_TEST\n  fprintf(stdout,\n          \"enc: %s, syntax: %s, options: %u, pattern_size: %d, back:%d\\n\",\n          ONIGENC_NAME(enc),\n          syntax_names[syntax_choice % num_syntaxes],\n          options,\n          pattern_size, backward);\n#else\n  fprintf(stdout, \"enc: %s, options: %u, pattern_size: %d, back:%d\\n\",\n          ONIGENC_NAME(enc), options, pattern_size, backward);\n#endif\n#endif\n\n#ifdef DUMP_INPUT\n  dump_input((unsigned char* )Data, Size);\n#endif\n\n  r = alloc_exec(enc, options, syntax, backward, pattern_size,\n                 rem_size, data);\n  if (r == -2) exit(-2);\n\n#ifndef STANDALONE\n#ifdef EXEC_PRINT_INTERVAL\n  if (EXEC_COUNT_INTERVAL == EXEC_PRINT_INTERVAL) {\n    float fexec, freg, fvalid;\n\n    if (STAT_FP == 0) {\n#ifdef STAT_PATH\n      STAT_FP = fopen(STAT_PATH, \"a\");\n#else\n      STAT_FP = stdout;\n#endif\n    }\n\n    output_current_time(STAT_FP);\n\n    if (INPUT_COUNT != 0) { // overflow check\n      fexec  = (float )EXEC_COUNT / INPUT_COUNT;\n      freg   = (float )REGEX_SUCCESS_COUNT / INPUT_COUNT;\n      fvalid = (float )VALID_STRING_COUNT / INPUT_COUNT;\n\n      fprintf(STAT_FP, \": %ld: EXEC:%.2f, REG:%.2f, VALID:%.2f\\n\",\n              EXEC_COUNT, fexec, freg, fvalid);\n      fflush(STAT_FP);\n    }\n    else {\n      fprintf(STAT_FP, \": ignore (input count overflow)\\n\");\n    }\n\n    EXEC_COUNT_INTERVAL = 0;\n  }\n  else if (EXEC_COUNT == 1) {\n    output_current_time(stdout);\n    fprintf(stdout, \": ------------ START ------------\\n\");\n  }\n#endif\n#endif\n\n  return r;\n}\nstatic int ExecuteFilesOnyByOne(int argc, char **argv) {\n  for (int i = 1; i < argc; i++) {\n    std::ifstream in(argv[i], std::ios::binary);\n    in.seekg(0, in.end);\n    size_t length = in.tellg();\n    in.seekg (0, in.beg);\n    std::cout << \"Reading \" << length << \" bytes from \" << argv[i] << std::endl;\n    // Allocate exactly length bytes so that we reliably catch buffer overflows.\n    std::vector<char> bytes(length);\n    in.read(bytes.data(), bytes.size());\n    assert(in);\n    LLVMFuzzerTestOneInput(reinterpret_cast<const uint8_t *>(bytes.data()),\n                           bytes.size());\n    std::cout << \"Execution successful\" << std::endl;\n  }\n  return 0;\n}\nint main(int argc, char **argv) {\n  Printf(\n      \"======================= INFO =========================\\n\"\n      \"This binary is built for AFL-fuzz.\\n\"\n      \"To run the target function on individual input(s) execute this:\\n\"\n      \"  %s < INPUT_FILE\\n\"\n      \"or\\n\"\n      \"  %s INPUT_FILE1 [INPUT_FILE2 ... ]\\n\"\n      \"To fuzz with afl-fuzz execute this:\\n\"\n      \"  afl-fuzz [afl-flags] %s [-N]\\n\"\n      \"afl-fuzz will run N iterations before \"\n      \"re-spawning the process (default: 1000)\\n\"\n      \"======================================================\\n\",\n          argv[0], argv[0], argv[0]);\n\n  maybe_duplicate_stderr();\n  maybe_close_fd_mask();\n  if (LLVMFuzzerInitialize)\n    LLVMFuzzerInitialize(&argc, &argv);\n  // Do any other expensive one-time initialization here.\n\n  if (!getenv(\"AFL_DRIVER_DONT_DEFER\"))\n    __afl_manual_init();\n\n  int N = 1000;\n  if (argc == 2 && argv[1][0] == '-')\n      N = atoi(argv[1] + 1);\n  else if(argc == 2 && (N = atoi(argv[1])) > 0)\n      Printf(\"WARNING: using the deprecated call style `%s %d`\\n\", argv[0], N);\n  else if (argc > 1)\n    return ExecuteFilesOnyByOne(argc, argv);\n\n  assert(N > 0);\n\n  // Call LLVMFuzzerTestOneInput here so that coverage caused by initialization\n  // on the first execution of LLVMFuzzerTestOneInput is ignored.\n  uint8_t dummy_input[1] = {0};\n  LLVMFuzzerTestOneInput(dummy_input, 1);\n\n  int num_runs = 0;\n  while (__afl_persistent_loop(N)) {\n    ssize_t n_read = read(0, AflInputBuf, kMaxAflInputSize);\n    if (n_read > 0) {\n      // Copy AflInputBuf into a separate buffer to let asan find buffer\n      // overflows. Don't use unique_ptr/etc to avoid extra dependencies.\n      uint8_t *copy = new uint8_t[n_read];\n      memcpy(copy, AflInputBuf, n_read);\n      num_runs++;\n      LLVMFuzzerTestOneInput(copy, n_read);\n      delete[] copy;\n    }\n  }\n  Printf(\"%s: successfully executed %d input(s)\\n\", argv[0], num_runs);\n}",
    "target": 0,
    "idx": 2025893
  },
  {
    "CWE_ID": [
      "CWE-787"
    ],
    "language": "c",
    "dataset": "oss-fuzz",
    "RELATED_CWE": [
      "CWE-125",
      "CWE-416",
      "CWE-415"
    ],
    "if_multi_func": false,
    "code": "static bool parse_headers(struct lwan_request_parser_helper *helper,\n                          char *buffer)\n{\n    char *buffer_end = helper->buffer->value + helper->buffer->len;\n    char **header_start = helper->header_start;\n    size_t n_headers = 0;\n    char *p;\n\n    for (p = buffer + 1;;) {\n        char *next_chr = p;\n        char *next_hdr = memchr(next_chr, '\\r', (size_t)(buffer_end - p));\n\n        if (!next_hdr)\n            break;\n\n        if (next_chr == next_hdr) {\n            if (buffer_end - next_chr > 2) {\n                STRING_SWITCH_SMALL (next_hdr) {\n                case MULTICHAR_CONSTANT_SMALL('\\r', '\\n'):\n                    helper->next_request = next_hdr + 2;\n                }\n            }\n            break;\n        }\n\n        header_start[n_headers++] = next_chr;\n        header_start[n_headers++] = next_hdr;\n\n        p = next_hdr + 2;\n\n        if (n_headers >= N_HEADER_START || p >= buffer_end) {\n            helper->n_header_start = 0;\n            return false;\n        }\n    }\n\n    for (size_t i = 0; i < n_headers; i += 2) {\n        char *end = header_start[i + 1];\n\n        p = header_start[i];\n\n        STRING_SWITCH_L (p) {\n        case MULTICHAR_CONSTANT_L('A', 'c', 'c', 'e'):\n            p += HEADER_LENGTH(\"Accept\");\n\n            STRING_SWITCH_L (p) {\n            case MULTICHAR_CONSTANT_L('-', 'E', 'n', 'c'):\n                helper->accept_encoding = HEADER(\"-Encoding\");\n                break;\n            }\n            break;\n        case MULTICHAR_CONSTANT_L('A', 'u', 't', 'h'):\n            helper->authorization = HEADER(\"Authorization\");\n            break;\n        case MULTICHAR_CONSTANT_L('C', 'o', 'n', 'n'):\n            helper->connection = HEADER(\"Connection\");\n            break;\n        case MULTICHAR_CONSTANT_L('C', 'o', 'n', 't'):\n            p += HEADER_LENGTH(\"Content\");\n\n            STRING_SWITCH_L (p) {\n            case MULTICHAR_CONSTANT_L('-', 'T', 'y', 'p'):\n                helper->content_type = HEADER(\"-Type\");\n                break;\n            case MULTICHAR_CONSTANT_L('-', 'L', 'e', 'n'):\n                helper->content_length = HEADER(\"-Length\");\n                break;\n            }\n            break;\n        case MULTICHAR_CONSTANT_L('C', 'o', 'o', 'k'):\n            helper->cookie = HEADER(\"Cookie\");\n            break;\n        case MULTICHAR_CONSTANT_L('I', 'f', '-', 'M'):\n            helper->if_modified_since.raw = HEADER(\"If-Modified-Since\");\n            break;\n        case MULTICHAR_CONSTANT_L('R', 'a', 'n', 'g'):\n            helper->range.raw = HEADER(\"Range\");\n            break;\n        }\n    }\n\n    helper->n_header_start = n_headers;\n    return true;\n}\n__attribute__((used)) int fuzz_parse_http_request(const uint8_t *data,\n                                                  size_t length)\n{\n    static struct coro_switcher switcher;\n    static struct coro *coro;\n    static char *header_start[N_HEADER_START];\n    static char data_copy[32767] = {0};\n\n    if (length > sizeof(data_copy))\n        length = sizeof(data_copy);\n    memcpy(data_copy, data, length);\n\n    if (!coro)\n        coro = coro_new(&switcher, useless_coro_for_fuzzing, NULL);\n\n    struct lwan_request_parser_helper helper = {\n        .buffer = &(struct lwan_value){.value = data_copy, .len = length},\n        .header_start = header_start,\n        .error_when_n_packets = 2,\n    };\n    struct lwan_connection conn = {.coro = coro};\n    struct lwan_proxy proxy = {};\n    struct lwan_request request = {\n        .helper = &helper,\n        .conn = &conn,\n        .flags = REQUEST_ALLOW_PROXY_REQS,\n        .proxy = &proxy,\n    };\n\n    /* If the finalizer isn't happy with a request, there's no point in\n     * going any further with parsing it. */\n    if (read_request_finalizer(length, sizeof(data_copy), &request, 1) !=\n        FINALIZER_DONE)\n        return 0;\n\n    if (parse_http_request(&request) == HTTP_OK) {\n        size_t gen = coro_deferred_get_generation(coro);\n\n        /* Only pointers were set in helper struct; actually parse them here. */\n        parse_post_data(&request);\n        parse_query_string(&request);\n        parse_cookies(&request);\n        parse_accept_encoding(&request);\n        parse_if_modified_since(&helper);\n        parse_range(&helper);\n\n        coro_deferred_run(coro, gen);\n    }\n\n    return 0;\n}\n__attribute__((used)) int fuzz_parse_http_request(const uint8_t *data,\n                                                  size_t length)\n{\n    static struct coro_switcher switcher;\n    static struct coro *coro;\n    static char *header_start[N_HEADER_START];\n    static char data_copy[32767] = {0};\n\n    if (length > sizeof(data_copy))\n        length = sizeof(data_copy);\n    memcpy(data_copy, data, length);\n\n    if (!coro)\n        coro = coro_new(&switcher, useless_coro_for_fuzzing, NULL);\n\n    struct lwan_request_parser_helper helper = {\n        .buffer = &(struct lwan_value){.value = data_copy, .len = length},\n        .header_start = header_start,\n        .error_when_n_packets = 2,\n    };\n    struct lwan_connection conn = {.coro = coro};\n    struct lwan_proxy proxy = {};\n    struct lwan_request request = {\n        .helper = &helper,\n        .conn = &conn,\n        .flags = REQUEST_ALLOW_PROXY_REQS,\n        .proxy = &proxy,\n    };\n\n    /* If the finalizer isn't happy with a request, there's no point in\n     * going any further with parsing it. */\n    if (read_request_finalizer(length, sizeof(data_copy), &request, 1) !=\n        FINALIZER_DONE)\n        return 0;\n\n    if (parse_http_request(&request) == HTTP_OK) {\n        size_t gen = coro_deferred_get_generation(coro);\n\n        /* Only pointers were set in helper struct; actually parse them here. */\n        parse_post_data(&request);\n        parse_query_string(&request);\n        parse_cookies(&request);\n        parse_accept_encoding(&request);\n        parse_if_modified_since(&helper);\n        parse_range(&helper);\n\n        coro_deferred_run(coro, gen);\n    }\n\n    return 0;\n}",
    "target": 0,
    "idx": 2014529
  }
]