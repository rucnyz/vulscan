[
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "void dd_save_binary(struct dump_dir* dd, const char* name, const char* data, unsigned size)\n{\n    if (!dd->locked)\n        error_msg_and_die(\"dump_dir is not opened\"); /* bug */\n\n    char *full_path = concat_path_file(dd->dd_dirname, name);\n    save_binary_file(full_path, data, size, dd->dd_uid, dd->dd_gid, dd->mode);\n    free(full_path);\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149582,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "void dd_save_binary(struct dump_dir* dd, const char* name, const char* data, unsigned size)\n{\n    if (!dd->locked)\n        error_msg_and_die(\"dump_dir is not opened\"); /* bug */\n\n    if (!str_is_correct_filename(name))\n        error_msg_and_die(\"Cannot save binary. '%s' is not a valid file name\", name);\n\n    char *full_path = concat_path_file(dd->dd_dirname, name);\n    save_binary_file(full_path, data, size, dd->dd_uid, dd->dd_gid, dd->mode);\n    free(full_path);\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149583,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "cleanup_pathname(struct archive_write_disk *a)\n{\n\tchar *dest, *src;\n\tchar separator = '\\0';\n\n\tdest = src = a->name;\n\tif (*src == '\\0') {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"Invalid empty pathname\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n#if defined(__CYGWIN__)\n\tcleanup_pathname_win(a);\n#endif\n\t/* Skip leading '/'. */\n\tif (*src == '/')\n\t\tseparator = *src++;\n\n\t/* Scan the pathname one element at a time. */\n\tfor (;;) {\n\t\t/* src points to first char after '/' */\n\t\tif (src[0] == '\\0') {\n\t\t\tbreak;\n\t\t} else if (src[0] == '/') {\n\t\t\t/* Found '//', ignore second one. */\n\t\t\tsrc++;\n\t\t\tcontinue;\n\t\t} else if (src[0] == '.') {\n\t\t\tif (src[1] == '\\0') {\n\t\t\t\t/* Ignore trailing '.' */\n\t\t\t\tbreak;\n\t\t\t} else if (src[1] == '/') {\n\t\t\t\t/* Skip './'. */\n\t\t\t\tsrc += 2;\n\t\t\t\tcontinue;\n\t\t\t} else if (src[1] == '.') {\n\t\t\t\tif (src[2] == '/' || src[2] == '\\0') {\n\t\t\t\t\t/* Conditionally warn about '..' */\n\t\t\t\t\tif (a->flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {\n\t\t\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t\t\t\t    \"Path contains '..'\");\n\t\t\t\t\t\treturn (ARCHIVE_FAILED);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Note: Under no circumstances do we\n\t\t\t\t * remove '..' elements.  In\n\t\t\t\t * particular, restoring\n\t\t\t\t * '/foo/../bar/' should create the\n\t\t\t\t * 'foo' dir as a side-effect.\n\t\t\t\t */\n\t\t\t}\n\t\t}\n\n\t\t/* Copy current element, including leading '/'. */\n\t\tif (separator)\n\t\t\t*dest++ = '/';\n\t\twhile (*src != '\\0' && *src != '/') {\n\t\t\t*dest++ = *src++;\n\t\t}\n\n\t\tif (*src == '\\0')\n\t\t\tbreak;\n\n\t\t/* Skip '/' separator. */\n\t\tseparator = *src++;\n\t}\n\t/*\n\t * We've just copied zero or more path elements, not including the\n\t * final '/'.\n\t */\n\tif (dest == a->name) {\n\t\t/*\n\t\t * Nothing got copied.  The path must have been something\n\t\t * like '.' or '/' or './' or '/././././/./'.\n\t\t */\n\t\tif (separator)\n\t\t\t*dest++ = '/';\n\t\telse\n\t\t\t*dest++ = '.';\n\t}\n\t/* Terminate the result. */\n\t*dest = '\\0';\n\treturn (ARCHIVE_OK);\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149584,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "cleanup_pathname(struct archive_write_disk *a)\n{\n\tchar *dest, *src;\n\tchar separator = '\\0';\n\n\tdest = src = a->name;\n\tif (*src == '\\0') {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"Invalid empty pathname\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n#if defined(__CYGWIN__)\n\tcleanup_pathname_win(a);\n#endif\n\t/* Skip leading '/'. */\n\tif (*src == '/') {\n\t\tif (a->flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t                  \"Path is absolute\");\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\n\t\tseparator = *src++;\n\t}\n\n\t/* Scan the pathname one element at a time. */\n\tfor (;;) {\n\t\t/* src points to first char after '/' */\n\t\tif (src[0] == '\\0') {\n\t\t\tbreak;\n\t\t} else if (src[0] == '/') {\n\t\t\t/* Found '//', ignore second one. */\n\t\t\tsrc++;\n\t\t\tcontinue;\n\t\t} else if (src[0] == '.') {\n\t\t\tif (src[1] == '\\0') {\n\t\t\t\t/* Ignore trailing '.' */\n\t\t\t\tbreak;\n\t\t\t} else if (src[1] == '/') {\n\t\t\t\t/* Skip './'. */\n\t\t\t\tsrc += 2;\n\t\t\t\tcontinue;\n\t\t\t} else if (src[1] == '.') {\n\t\t\t\tif (src[2] == '/' || src[2] == '\\0') {\n\t\t\t\t\t/* Conditionally warn about '..' */\n\t\t\t\t\tif (a->flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {\n\t\t\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t\t\t\t    \"Path contains '..'\");\n\t\t\t\t\t\treturn (ARCHIVE_FAILED);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Note: Under no circumstances do we\n\t\t\t\t * remove '..' elements.  In\n\t\t\t\t * particular, restoring\n\t\t\t\t * '/foo/../bar/' should create the\n\t\t\t\t * 'foo' dir as a side-effect.\n\t\t\t\t */\n\t\t\t}\n\t\t}\n\n\t\t/* Copy current element, including leading '/'. */\n\t\tif (separator)\n\t\t\t*dest++ = '/';\n\t\twhile (*src != '\\0' && *src != '/') {\n\t\t\t*dest++ = *src++;\n\t\t}\n\n\t\tif (*src == '\\0')\n\t\t\tbreak;\n\n\t\t/* Skip '/' separator. */\n\t\tseparator = *src++;\n\t}\n\t/*\n\t * We've just copied zero or more path elements, not including the\n\t * final '/'.\n\t */\n\tif (dest == a->name) {\n\t\t/*\n\t\t * Nothing got copied.  The path must have been something\n\t\t * like '.' or '/' or './' or '/././././/./'.\n\t\t */\n\t\tif (separator)\n\t\t\t*dest++ = '/';\n\t\telse\n\t\t\t*dest++ = '.';\n\t}\n\t/* Terminate the result. */\n\t*dest = '\\0';\n\treturn (ARCHIVE_OK);\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149585,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "struct dump_dir *create_dump_dir_from_problem_data(problem_data_t *problem_data, const char *base_dir_name)\n{\n    INITIALIZE_LIBREPORT();\n\n    char *type = problem_data_get_content_or_NULL(problem_data, FILENAME_ANALYZER);\n\n    if (!type)\n    {\n        error_msg(_(\"Missing required item: '%s'\"), FILENAME_ANALYZER);\n        return NULL;\n    }\n\n    uid_t uid = (uid_t)-1L;\n    char *uid_str = problem_data_get_content_or_NULL(problem_data, FILENAME_UID);\n\n    if (uid_str)\n    {\n        char *endptr;\n        errno = 0;\n        long val = strtol(uid_str, &endptr, 10);\n\n        if (errno != 0 || endptr == uid_str || *endptr != '\\0' || INT_MAX < val)\n        {\n            error_msg(_(\"uid value is not valid: '%s'\"), uid_str);\n            return NULL;\n        }\n\n        uid = (uid_t)val;\n    }\n\n    struct timeval tv;\n    if (gettimeofday(&tv, NULL) < 0)\n    {\n        perror_msg(\"gettimeofday()\");\n        return NULL;\n    }\n\n    char *problem_id = xasprintf(\"%s-%s.%ld-%lu\"NEW_PD_SUFFIX, type, iso_date_string(&(tv.tv_sec)), (long)tv.tv_usec, (long)getpid());\n\n    log_info(\"Saving to %s/%s with uid %d\", base_dir_name, problem_id, uid);\n\n    struct dump_dir *dd;\n    if (base_dir_name)\n        dd = try_dd_create(base_dir_name, problem_id, uid);\n    else\n    {\n        /* Try /var/run/abrt */\n        dd = try_dd_create(LOCALSTATEDIR\"/run/abrt\", problem_id, uid);\n        /* Try $HOME/tmp */\n        if (!dd)\n        {\n            char *home = getenv(\"HOME\");\n            if (home && home[0])\n            {\n                home = concat_path_file(home, \"tmp\");\n                /*mkdir(home, 0777); - do we want this? */\n                dd = try_dd_create(home, problem_id, uid);\n                free(home);\n            }\n        }\n//TODO: try user's home dir obtained by getpwuid(getuid())?\n        /* Try system temporary directory */\n        if (!dd)\n            dd = try_dd_create(LARGE_DATA_TMP_DIR, problem_id, uid);\n    }\n\n    if (!dd) /* try_dd_create() already emitted the error message */\n        goto ret;\n\n    GHashTableIter iter;\n    char *name;\n    struct problem_item *value;\n    g_hash_table_iter_init(&iter, problem_data);\n    while (g_hash_table_iter_next(&iter, (void**)&name, (void**)&value))\n    {\n        if (value->flags & CD_FLAG_BIN)\n        {\n            char *dest = concat_path_file(dd->dd_dirname, name);\n            log_info(\"copying '%s' to '%s'\", value->content, dest);\n            off_t copied = copy_file(value->content, dest, DEFAULT_DUMP_DIR_MODE | S_IROTH);\n            if (copied < 0)\n                error_msg(\"Can't copy %s to %s\", value->content, dest);\n            else\n                log_info(\"copied %li bytes\", (unsigned long)copied);\n            free(dest);\n\n            continue;\n        }\n\n        /* only files should contain '/' and those are handled earlier */\n        if (name[0] == '.' || strchr(name, '/'))\n        {\n            error_msg(\"Problem data field name contains disallowed chars: '%s'\", name);\n            continue;\n        }\n\n        dd_save_text(dd, name, value->content);\n    }\n\n    /* need to create basic files AFTER we save the pd to dump_dir\n     * otherwise we can't skip already created files like in case when\n     * reporting from anaconda where we can't read /etc/{system,redhat}-release\n     * and os_release is taken from anaconda\n     */\n    dd_create_basic_files(dd, uid, NULL);\n\n    problem_id[strlen(problem_id) - strlen(NEW_PD_SUFFIX)] = '\\0';\n    char* new_path = concat_path_file(base_dir_name, problem_id);\n    log_info(\"Renaming from '%s' to '%s'\", dd->dd_dirname, new_path);\n    dd_rename(dd, new_path);\n\n ret:\n    free(problem_id);\n    return dd;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149586,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "struct dump_dir *create_dump_dir_from_problem_data(problem_data_t *problem_data, const char *base_dir_name)\n{\n    INITIALIZE_LIBREPORT();\n\n    char *type = problem_data_get_content_or_NULL(problem_data, FILENAME_ANALYZER);\n\n    if (!type)\n    {\n        error_msg(_(\"Missing required item: '%s'\"), FILENAME_ANALYZER);\n        return NULL;\n    }\n\n    if (!str_is_correct_filename(type))\n    {\n        error_msg(_(\"'%s' is not correct file name\"), FILENAME_ANALYZER);\n        return NULL;\n    }\n\n    uid_t uid = (uid_t)-1L;\n    char *uid_str = problem_data_get_content_or_NULL(problem_data, FILENAME_UID);\n\n    if (uid_str)\n    {\n        char *endptr;\n        errno = 0;\n        long val = strtol(uid_str, &endptr, 10);\n\n        if (errno != 0 || endptr == uid_str || *endptr != '\\0' || INT_MAX < val)\n        {\n            error_msg(_(\"uid value is not valid: '%s'\"), uid_str);\n            return NULL;\n        }\n\n        uid = (uid_t)val;\n    }\n\n    struct timeval tv;\n    if (gettimeofday(&tv, NULL) < 0)\n    {\n        perror_msg(\"gettimeofday()\");\n        return NULL;\n    }\n\n    char *problem_id = xasprintf(\"%s-%s.%ld-%lu\"NEW_PD_SUFFIX, type, iso_date_string(&(tv.tv_sec)), (long)tv.tv_usec, (long)getpid());\n\n    log_info(\"Saving to %s/%s with uid %d\", base_dir_name, problem_id, uid);\n\n    struct dump_dir *dd;\n    if (base_dir_name)\n        dd = try_dd_create(base_dir_name, problem_id, uid);\n    else\n    {\n        /* Try /var/run/abrt */\n        dd = try_dd_create(LOCALSTATEDIR\"/run/abrt\", problem_id, uid);\n        /* Try $HOME/tmp */\n        if (!dd)\n        {\n            char *home = getenv(\"HOME\");\n            if (home && home[0])\n            {\n                home = concat_path_file(home, \"tmp\");\n                /*mkdir(home, 0777); - do we want this? */\n                dd = try_dd_create(home, problem_id, uid);\n                free(home);\n            }\n        }\n//TODO: try user's home dir obtained by getpwuid(getuid())?\n        /* Try system temporary directory */\n        if (!dd)\n            dd = try_dd_create(LARGE_DATA_TMP_DIR, problem_id, uid);\n    }\n\n    if (!dd) /* try_dd_create() already emitted the error message */\n        goto ret;\n\n    GHashTableIter iter;\n    char *name;\n    struct problem_item *value;\n    g_hash_table_iter_init(&iter, problem_data);\n    while (g_hash_table_iter_next(&iter, (void**)&name, (void**)&value))\n    {\n        if (!str_is_correct_filename(name))\n        {\n            error_msg(\"Problem data field name contains disallowed chars: '%s'\", name);\n            continue;\n        }\n\n        if (value->flags & CD_FLAG_BIN)\n        {\n            char *dest = concat_path_file(dd->dd_dirname, name);\n            log_info(\"copying '%s' to '%s'\", value->content, dest);\n            off_t copied = copy_file(value->content, dest, DEFAULT_DUMP_DIR_MODE | S_IROTH);\n            if (copied < 0)\n                error_msg(\"Can't copy %s to %s\", value->content, dest);\n            else\n                log_info(\"copied %li bytes\", (unsigned long)copied);\n            free(dest);\n\n            continue;\n        }\n\n        dd_save_text(dd, name, value->content);\n    }\n\n    /* need to create basic files AFTER we save the pd to dump_dir\n     * otherwise we can't skip already created files like in case when\n     * reporting from anaconda where we can't read /etc/{system,redhat}-release\n     * and os_release is taken from anaconda\n     */\n    dd_create_basic_files(dd, uid, NULL);\n\n    problem_id[strlen(problem_id) - strlen(NEW_PD_SUFFIX)] = '\\0';\n    char* new_path = concat_path_file(base_dir_name, problem_id);\n    log_info(\"Renaming from '%s' to '%s'\", dd->dd_dirname, new_path);\n    dd_rename(dd, new_path);\n\n ret:\n    free(problem_id);\n    return dd;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149587,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "local void process(char *path)\n{\n    int method = -1;                /* get_header() return value */\n    size_t len;                     /* length of base name (minus suffix) */\n    struct stat st;                 /* to get file type and mod time */\n    /* all compressed suffixes for decoding search, in length order */\n    static char *sufs[] = {\".z\", \"-z\", \"_z\", \".Z\", \".gz\", \"-gz\", \".zz\", \"-zz\",\n                           \".zip\", \".ZIP\", \".tgz\", NULL};\n\n    /* open input file with name in, descriptor ind -- set name and mtime */\n    if (path == NULL) {\n        strcpy(g.inf, \"<stdin>\");\n        g.ind = 0;\n        g.name = NULL;\n        g.mtime = g.headis & 2 ?\n                  (fstat(g.ind, &st) ? time(NULL) : st.st_mtime) : 0;\n        len = 0;\n    }\n    else {\n        /* set input file name (already set if recursed here) */\n        if (path != g.inf) {\n            strncpy(g.inf, path, sizeof(g.inf));\n            if (g.inf[sizeof(g.inf) - 1])\n                bail(\"name too long: \", path);\n        }\n        len = strlen(g.inf);\n\n        /* try to stat input file -- if not there and decoding, look for that\n           name with compressed suffixes */\n        if (lstat(g.inf, &st)) {\n            if (errno == ENOENT && (g.list || g.decode)) {\n                char **try = sufs;\n                do {\n                    if (*try == NULL || len + strlen(*try) >= sizeof(g.inf))\n                        break;\n                    strcpy(g.inf + len, *try++);\n                    errno = 0;\n                } while (lstat(g.inf, &st) && errno == ENOENT);\n            }\n#ifdef EOVERFLOW\n            if (errno == EOVERFLOW || errno == EFBIG)\n                bail(g.inf,\n                    \" too large -- not compiled with large file support\");\n#endif\n            if (errno) {\n                g.inf[len] = 0;\n                complain(\"%s does not exist -- skipping\", g.inf);\n                return;\n            }\n            len = strlen(g.inf);\n        }\n\n        /* only process regular files, but allow symbolic links if -f,\n           recurse into directory if -r */\n        if ((st.st_mode & S_IFMT) != S_IFREG &&\n            (st.st_mode & S_IFMT) != S_IFLNK &&\n            (st.st_mode & S_IFMT) != S_IFDIR) {\n            complain(\"%s is a special file or device -- skipping\", g.inf);\n            return;\n        }\n        if ((st.st_mode & S_IFMT) == S_IFLNK && !g.force && !g.pipeout) {\n            complain(\"%s is a symbolic link -- skipping\", g.inf);\n            return;\n        }\n        if ((st.st_mode & S_IFMT) == S_IFDIR && !g.recurse) {\n            complain(\"%s is a directory -- skipping\", g.inf);\n            return;\n        }\n\n        /* recurse into directory (assumes Unix) */\n        if ((st.st_mode & S_IFMT) == S_IFDIR) {\n            char *roll, *item, *cut, *base, *bigger;\n            size_t len, hold;\n            DIR *here;\n            struct dirent *next;\n\n            /* accumulate list of entries (need to do this, since readdir()\n               behavior not defined if directory modified between calls) */\n            here = opendir(g.inf);\n            if (here == NULL)\n                return;\n            hold = 512;\n            roll = MALLOC(hold);\n            if (roll == NULL)\n                bail(\"not enough memory\", \"\");\n            *roll = 0;\n            item = roll;\n            while ((next = readdir(here)) != NULL) {\n                if (next->d_name[0] == 0 ||\n                    (next->d_name[0] == '.' && (next->d_name[1] == 0 ||\n                     (next->d_name[1] == '.' && next->d_name[2] == 0))))\n                    continue;\n                len = strlen(next->d_name) + 1;\n                if (item + len + 1 > roll + hold) {\n                    do {                    /* make roll bigger */\n                        hold <<= 1;\n                    } while (item + len + 1 > roll + hold);\n                    bigger = REALLOC(roll, hold);\n                    if (bigger == NULL) {\n                        FREE(roll);\n                        bail(\"not enough memory\", \"\");\n                    }\n                    item = bigger + (item - roll);\n                    roll = bigger;\n                }\n                strcpy(item, next->d_name);\n                item += len;\n                *item = 0;\n            }\n            closedir(here);\n\n            /* run process() for each entry in the directory */\n            cut = base = g.inf + strlen(g.inf);\n            if (base > g.inf && base[-1] != (unsigned char)'/') {\n                if ((size_t)(base - g.inf) >= sizeof(g.inf))\n                    bail(\"path too long\", g.inf);\n                *base++ = '/';\n            }\n            item = roll;\n            while (*item) {\n                strncpy(base, item, sizeof(g.inf) - (base - g.inf));\n                if (g.inf[sizeof(g.inf) - 1]) {\n                    strcpy(g.inf + (sizeof(g.inf) - 4), \"...\");\n                    bail(\"path too long: \", g.inf);\n                }\n                process(g.inf);\n                item += strlen(item) + 1;\n            }\n            *cut = 0;\n\n            /* release list of entries */\n            FREE(roll);\n            return;\n        }\n\n        /* don't compress .gz (or provided suffix) files, unless -f */\n        if (!(g.force || g.list || g.decode) && len >= strlen(g.sufx) &&\n                strcmp(g.inf + len - strlen(g.sufx), g.sufx) == 0) {\n            complain(\"%s ends with %s -- skipping\", g.inf, g.sufx);\n            return;\n        }\n\n        /* create output file only if input file has compressed suffix */\n        if (g.decode == 1 && !g.pipeout && !g.list) {\n            int suf = compressed_suffix(g.inf);\n            if (suf == 0) {\n                complain(\"%s does not have compressed suffix -- skipping\",\n                         g.inf);\n                return;\n            }\n            len -= suf;\n        }\n\n        /* open input file */\n        g.ind = open(g.inf, O_RDONLY, 0);\n        if (g.ind < 0)\n            bail(\"read error on \", g.inf);\n\n        /* prepare gzip header information for compression */\n        g.name = g.headis & 1 ? justname(g.inf) : NULL;\n        g.mtime = g.headis & 2 ? st.st_mtime : 0;\n    }\n    SET_BINARY_MODE(g.ind);\n\n    /* if decoding or testing, try to read gzip header */\n    g.hname = NULL;\n    if (g.decode) {\n        in_init();\n        method = get_header(1);\n        if (method != 8 && method != 257 &&\n                /* gzip -cdf acts like cat on uncompressed input */\n                !(method == -2 && g.force && g.pipeout && g.decode != 2 &&\n                  !g.list)) {\n            RELEASE(g.hname);\n            if (g.ind != 0)\n                close(g.ind);\n            if (method != -1)\n                complain(method < 0 ? \"%s is not compressed -- skipping\" :\n                         \"%s has unknown compression method -- skipping\",\n                         g.inf);\n            return;\n        }\n\n        /* if requested, test input file (possibly a special list) */\n        if (g.decode == 2) {\n            if (method == 8)\n                infchk();\n            else {\n                unlzw();\n                if (g.list) {\n                    g.in_tot -= 3;\n                    show_info(method, 0, g.out_tot, 0);\n                }\n            }\n            RELEASE(g.hname);\n            if (g.ind != 0)\n                close(g.ind);\n            return;\n        }\n    }\n\n    /* if requested, just list information about input file */\n    if (g.list) {\n        list_info();\n        RELEASE(g.hname);\n        if (g.ind != 0)\n            close(g.ind);\n        return;\n    }\n\n    /* create output file out, descriptor outd */\n    if (path == NULL || g.pipeout) {\n        /* write to stdout */\n        g.outf = MALLOC(strlen(\"<stdout>\") + 1);\n        if (g.outf == NULL)\n            bail(\"not enough memory\", \"\");\n        strcpy(g.outf, \"<stdout>\");\n        g.outd = 1;\n        if (!g.decode && !g.force && isatty(g.outd))\n            bail(\"trying to write compressed data to a terminal\",\n                 \" (use -f to force)\");\n    }\n    else {\n        char *to, *repl;\n\n        /* use header name for output when decompressing with -N */\n        to = g.inf;\n        if (g.decode && (g.headis & 1) != 0 && g.hname != NULL) {\n            to = g.hname;\n            len = strlen(g.hname);\n        }\n\n        /* replace .tgz with .tar when decoding */\n        repl = g.decode && strcmp(to + len, \".tgz\") ? \"\" : \".tar\";\n\n        /* create output file and open to write */\n        g.outf = MALLOC(len + (g.decode ? strlen(repl) : strlen(g.sufx)) + 1);\n        if (g.outf == NULL)\n            bail(\"not enough memory\", \"\");\n        memcpy(g.outf, to, len);\n        strcpy(g.outf + len, g.decode ? repl : g.sufx);\n        g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY |\n                             (g.force ? 0 : O_EXCL), 0600);\n\n        /* if exists and not -f, give user a chance to overwrite */\n        if (g.outd < 0 && errno == EEXIST && isatty(0) && g.verbosity) {\n            int ch, reply;\n\n            fprintf(stderr, \"%s exists -- overwrite (y/n)? \", g.outf);\n            fflush(stderr);\n            reply = -1;\n            do {\n                ch = getchar();\n                if (reply < 0 && ch != ' ' && ch != '\\t')\n                    reply = ch == 'y' || ch == 'Y' ? 1 : 0;\n            } while (ch != EOF && ch != '\\n' && ch != '\\r');\n            if (reply == 1)\n                g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY,\n                              0600);\n        }\n\n        /* if exists and no overwrite, report and go on to next */\n        if (g.outd < 0 && errno == EEXIST) {\n            complain(\"%s exists -- skipping\", g.outf);\n            RELEASE(g.outf);\n            RELEASE(g.hname);\n            if (g.ind != 0)\n                close(g.ind);\n            return;\n        }\n\n        /* if some other error, give up */\n        if (g.outd < 0)\n            bail(\"write error on \", g.outf);\n    }\n    SET_BINARY_MODE(g.outd);\n    RELEASE(g.hname);\n\n    /* process ind to outd */\n    if (g.verbosity > 1)\n        fprintf(stderr, \"%s to %s \", g.inf, g.outf);\n    if (g.decode) {\n        if (method == 8)\n            infchk();\n        else if (method == 257)\n            unlzw();\n        else\n            cat();\n    }\n#ifndef NOTHREAD\n    else if (g.procs > 1)\n        parallel_compress();\n#endif\n    else\n        single_compress(0);\n    if (g.verbosity > 1) {\n        putc('\\n', stderr);\n        fflush(stderr);\n    }\n\n    /* finish up, copy attributes, set times, delete original */\n    if (g.ind != 0)\n        close(g.ind);\n    if (g.outd != 1) {\n        if (close(g.outd))\n            bail(\"write error on \", g.outf);\n        g.outd = -1;            /* now prevent deletion on interrupt */\n        if (g.ind != 0) {\n            copymeta(g.inf, g.outf);\n            if (!g.keep)\n                unlink(g.inf);\n        }\n        if (g.decode && (g.headis & 2) != 0 && g.stamp)\n            touch(g.outf, g.stamp);\n    }\n    RELEASE(g.outf);\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149588,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "local void process(char *path)\n{\n    int method = -1;                /* get_header() return value */\n    size_t len;                     /* length of base name (minus suffix) */\n    struct stat st;                 /* to get file type and mod time */\n    /* all compressed suffixes for decoding search, in length order */\n    static char *sufs[] = {\".z\", \"-z\", \"_z\", \".Z\", \".gz\", \"-gz\", \".zz\", \"-zz\",\n                           \".zip\", \".ZIP\", \".tgz\", NULL};\n\n    /* open input file with name in, descriptor ind -- set name and mtime */\n    if (path == NULL) {\n        strcpy(g.inf, \"<stdin>\");\n        g.ind = 0;\n        g.name = NULL;\n        g.mtime = g.headis & 2 ?\n                  (fstat(g.ind, &st) ? time(NULL) : st.st_mtime) : 0;\n        len = 0;\n    }\n    else {\n        /* set input file name (already set if recursed here) */\n        if (path != g.inf) {\n            strncpy(g.inf, path, sizeof(g.inf));\n            if (g.inf[sizeof(g.inf) - 1])\n                bail(\"name too long: \", path);\n        }\n        len = strlen(g.inf);\n\n        /* try to stat input file -- if not there and decoding, look for that\n           name with compressed suffixes */\n        if (lstat(g.inf, &st)) {\n            if (errno == ENOENT && (g.list || g.decode)) {\n                char **try = sufs;\n                do {\n                    if (*try == NULL || len + strlen(*try) >= sizeof(g.inf))\n                        break;\n                    strcpy(g.inf + len, *try++);\n                    errno = 0;\n                } while (lstat(g.inf, &st) && errno == ENOENT);\n            }\n#ifdef EOVERFLOW\n            if (errno == EOVERFLOW || errno == EFBIG)\n                bail(g.inf,\n                    \" too large -- not compiled with large file support\");\n#endif\n            if (errno) {\n                g.inf[len] = 0;\n                complain(\"%s does not exist -- skipping\", g.inf);\n                return;\n            }\n            len = strlen(g.inf);\n        }\n\n        /* only process regular files, but allow symbolic links if -f,\n           recurse into directory if -r */\n        if ((st.st_mode & S_IFMT) != S_IFREG &&\n            (st.st_mode & S_IFMT) != S_IFLNK &&\n            (st.st_mode & S_IFMT) != S_IFDIR) {\n            complain(\"%s is a special file or device -- skipping\", g.inf);\n            return;\n        }\n        if ((st.st_mode & S_IFMT) == S_IFLNK && !g.force && !g.pipeout) {\n            complain(\"%s is a symbolic link -- skipping\", g.inf);\n            return;\n        }\n        if ((st.st_mode & S_IFMT) == S_IFDIR && !g.recurse) {\n            complain(\"%s is a directory -- skipping\", g.inf);\n            return;\n        }\n\n        /* recurse into directory (assumes Unix) */\n        if ((st.st_mode & S_IFMT) == S_IFDIR) {\n            char *roll, *item, *cut, *base, *bigger;\n            size_t len, hold;\n            DIR *here;\n            struct dirent *next;\n\n            /* accumulate list of entries (need to do this, since readdir()\n               behavior not defined if directory modified between calls) */\n            here = opendir(g.inf);\n            if (here == NULL)\n                return;\n            hold = 512;\n            roll = MALLOC(hold);\n            if (roll == NULL)\n                bail(\"not enough memory\", \"\");\n            *roll = 0;\n            item = roll;\n            while ((next = readdir(here)) != NULL) {\n                if (next->d_name[0] == 0 ||\n                    (next->d_name[0] == '.' && (next->d_name[1] == 0 ||\n                     (next->d_name[1] == '.' && next->d_name[2] == 0))))\n                    continue;\n                len = strlen(next->d_name) + 1;\n                if (item + len + 1 > roll + hold) {\n                    do {                    /* make roll bigger */\n                        hold <<= 1;\n                    } while (item + len + 1 > roll + hold);\n                    bigger = REALLOC(roll, hold);\n                    if (bigger == NULL) {\n                        FREE(roll);\n                        bail(\"not enough memory\", \"\");\n                    }\n                    item = bigger + (item - roll);\n                    roll = bigger;\n                }\n                strcpy(item, next->d_name);\n                item += len;\n                *item = 0;\n            }\n            closedir(here);\n\n            /* run process() for each entry in the directory */\n            cut = base = g.inf + strlen(g.inf);\n            if (base > g.inf && base[-1] != (unsigned char)'/') {\n                if ((size_t)(base - g.inf) >= sizeof(g.inf))\n                    bail(\"path too long\", g.inf);\n                *base++ = '/';\n            }\n            item = roll;\n            while (*item) {\n                strncpy(base, item, sizeof(g.inf) - (base - g.inf));\n                if (g.inf[sizeof(g.inf) - 1]) {\n                    strcpy(g.inf + (sizeof(g.inf) - 4), \"...\");\n                    bail(\"path too long: \", g.inf);\n                }\n                process(g.inf);\n                item += strlen(item) + 1;\n            }\n            *cut = 0;\n\n            /* release list of entries */\n            FREE(roll);\n            return;\n        }\n\n        /* don't compress .gz (or provided suffix) files, unless -f */\n        if (!(g.force || g.list || g.decode) && len >= strlen(g.sufx) &&\n                strcmp(g.inf + len - strlen(g.sufx), g.sufx) == 0) {\n            complain(\"%s ends with %s -- skipping\", g.inf, g.sufx);\n            return;\n        }\n\n        /* create output file only if input file has compressed suffix */\n        if (g.decode == 1 && !g.pipeout && !g.list) {\n            int suf = compressed_suffix(g.inf);\n            if (suf == 0) {\n                complain(\"%s does not have compressed suffix -- skipping\",\n                         g.inf);\n                return;\n            }\n            len -= suf;\n        }\n\n        /* open input file */\n        g.ind = open(g.inf, O_RDONLY, 0);\n        if (g.ind < 0)\n            bail(\"read error on \", g.inf);\n\n        /* prepare gzip header information for compression */\n        g.name = g.headis & 1 ? justname(g.inf) : NULL;\n        g.mtime = g.headis & 2 ? st.st_mtime : 0;\n    }\n    SET_BINARY_MODE(g.ind);\n\n    /* if decoding or testing, try to read gzip header */\n    g.hname = NULL;\n    if (g.decode) {\n        in_init();\n        method = get_header(1);\n        if (method != 8 && method != 257 &&\n                /* gzip -cdf acts like cat on uncompressed input */\n                !(method == -2 && g.force && g.pipeout && g.decode != 2 &&\n                  !g.list)) {\n            RELEASE(g.hname);\n            if (g.ind != 0)\n                close(g.ind);\n            if (method != -1)\n                complain(method < 0 ? \"%s is not compressed -- skipping\" :\n                         \"%s has unknown compression method -- skipping\",\n                         g.inf);\n            return;\n        }\n\n        /* if requested, test input file (possibly a special list) */\n        if (g.decode == 2) {\n            if (method == 8)\n                infchk();\n            else {\n                unlzw();\n                if (g.list) {\n                    g.in_tot -= 3;\n                    show_info(method, 0, g.out_tot, 0);\n                }\n            }\n            RELEASE(g.hname);\n            if (g.ind != 0)\n                close(g.ind);\n            return;\n        }\n    }\n\n    /* if requested, just list information about input file */\n    if (g.list) {\n        list_info();\n        RELEASE(g.hname);\n        if (g.ind != 0)\n            close(g.ind);\n        return;\n    }\n\n    /* create output file out, descriptor outd */\n    if (path == NULL || g.pipeout) {\n        /* write to stdout */\n        g.outf = MALLOC(strlen(\"<stdout>\") + 1);\n        if (g.outf == NULL)\n            bail(\"not enough memory\", \"\");\n        strcpy(g.outf, \"<stdout>\");\n        g.outd = 1;\n        if (!g.decode && !g.force && isatty(g.outd))\n            bail(\"trying to write compressed data to a terminal\",\n                 \" (use -f to force)\");\n    }\n    else {\n        char *to = g.inf, *sufx = \"\";\n        size_t pre = 0;\n\n        /* select parts of the output file name */\n        if (g.decode) {\n            /* for -dN or -dNT, use the path from the input file and the name\n               from the header, stripping any path in the header name */\n            if ((g.headis & 1) != 0 && g.hname != NULL) {\n                pre = justname(g.inf) - g.inf;\n                to = justname(g.hname);\n                len = strlen(to);\n            }\n            /* for -d or -dNn, replace abbreviated suffixes */\n            else if (strcmp(to + len, \".tgz\") == 0)\n                sufx = \".tar\";\n        }\n        else\n            /* add appropriate suffix when compressing */\n            sufx = g.sufx;\n\n        /* create output file and open to write */\n        g.outf = MALLOC(pre + len + strlen(sufx) + 1);\n        if (g.outf == NULL)\n            bail(\"not enough memory\", \"\");\n        memcpy(g.outf, g.inf, pre);\n        memcpy(g.outf + pre, to, len);\n        strcpy(g.outf + pre + len, sufx);\n        g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY |\n                              (g.force ? 0 : O_EXCL), 0600);\n\n        /* if exists and not -f, give user a chance to overwrite */\n        if (g.outd < 0 && errno == EEXIST && isatty(0) && g.verbosity) {\n            int ch, reply;\n\n            fprintf(stderr, \"%s exists -- overwrite (y/n)? \", g.outf);\n            fflush(stderr);\n            reply = -1;\n            do {\n                ch = getchar();\n                if (reply < 0 && ch != ' ' && ch != '\\t')\n                    reply = ch == 'y' || ch == 'Y' ? 1 : 0;\n            } while (ch != EOF && ch != '\\n' && ch != '\\r');\n            if (reply == 1)\n                g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY,\n                              0600);\n        }\n\n        /* if exists and no overwrite, report and go on to next */\n        if (g.outd < 0 && errno == EEXIST) {\n            complain(\"%s exists -- skipping\", g.outf);\n            RELEASE(g.outf);\n            RELEASE(g.hname);\n            if (g.ind != 0)\n                close(g.ind);\n            return;\n        }\n\n        /* if some other error, give up */\n        if (g.outd < 0)\n            bail(\"write error on \", g.outf);\n    }\n    SET_BINARY_MODE(g.outd);\n    RELEASE(g.hname);\n\n    /* process ind to outd */\n    if (g.verbosity > 1)\n        fprintf(stderr, \"%s to %s \", g.inf, g.outf);\n    if (g.decode) {\n        if (method == 8)\n            infchk();\n        else if (method == 257)\n            unlzw();\n        else\n            cat();\n    }\n#ifndef NOTHREAD\n    else if (g.procs > 1)\n        parallel_compress();\n#endif\n    else\n        single_compress(0);\n    if (g.verbosity > 1) {\n        putc('\\n', stderr);\n        fflush(stderr);\n    }\n\n    /* finish up, copy attributes, set times, delete original */\n    if (g.ind != 0)\n        close(g.ind);\n    if (g.outd != 1) {\n        if (close(g.outd))\n            bail(\"write error on \", g.outf);\n        g.outd = -1;            /* now prevent deletion on interrupt */\n        if (g.ind != 0) {\n            copymeta(g.inf, g.outf);\n            if (!g.keep)\n                unlink(g.inf);\n        }\n        if (g.decode && (g.headis & 2) != 0 && g.stamp)\n            touch(g.outf, g.stamp);\n    }\n    RELEASE(g.outf);\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149589,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "header_cache_t *imap_hcache_open(struct ImapData *idata, const char *path)\n{\n  struct ImapMbox mx;\n  struct Url url;\n  char cachepath[PATH_MAX];\n  char mbox[PATH_MAX];\n\n  if (path)\n    imap_cachepath(idata, path, mbox, sizeof(mbox));\n  else\n  {\n    if (!idata->ctx || imap_parse_path(idata->ctx->path, &mx) < 0)\n      return NULL;\n\n    imap_cachepath(idata, mx.mbox, mbox, sizeof(mbox));\n    FREE(&mx.mbox);\n  }\n\n  mutt_account_tourl(&idata->conn->account, &url);\n  url.path = mbox;\n  url_tostring(&url, cachepath, sizeof(cachepath), U_PATH);\n\n  return mutt_hcache_open(HeaderCache, cachepath, imap_hcache_namer);\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149590,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "header_cache_t *imap_hcache_open(struct ImapData *idata, const char *path)\n{\n  struct ImapMbox mx;\n  struct Url url;\n  char cachepath[PATH_MAX];\n  char mbox[PATH_MAX];\n\n  if (path)\n    imap_cachepath(idata, path, mbox, sizeof(mbox));\n  else\n  {\n    if (!idata->ctx || imap_parse_path(idata->ctx->path, &mx) < 0)\n      return NULL;\n\n    imap_cachepath(idata, mx.mbox, mbox, sizeof(mbox));\n    FREE(&mx.mbox);\n  }\n\n  if (strstr(mbox, \"/../\") || (strcmp(mbox, \"..\") == 0) || (strncmp(mbox, \"../\", 3) == 0))\n    return NULL;\n  size_t len = strlen(mbox);\n  if ((len > 3) && (strcmp(mbox + len - 3, \"/..\") == 0))\n    return NULL;\n\n  mutt_account_tourl(&idata->conn->account, &url);\n  url.path = mbox;\n  url_tostring(&url, cachepath, sizeof(cachepath), U_PATH);\n\n  return mutt_hcache_open(HeaderCache, cachepath, imap_hcache_namer);\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149591,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "char* dd_load_text_ext(const struct dump_dir *dd, const char *name, unsigned flags)\n{\n//    if (!dd->locked)\n//        error_msg_and_die(\"dump_dir is not opened\"); /* bug */\n\n    /* Compat with old abrt dumps. Remove in abrt-2.1 */\n    if (strcmp(name, \"release\") == 0)\n        name = FILENAME_OS_RELEASE;\n\n    char *full_path = concat_path_file(dd->dd_dirname, name);\n    char *ret = load_text_file(full_path, flags);\n    free(full_path);\n\n    return ret;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149592,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "char* dd_load_text_ext(const struct dump_dir *dd, const char *name, unsigned flags)\n{\n//    if (!dd->locked)\n//        error_msg_and_die(\"dump_dir is not opened\"); /* bug */\n\n    if (!str_is_correct_filename(name))\n    {\n        error_msg(\"Cannot load text. '%s' is not a valid file name\", name);\n        if (!(flags & DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE))\n            xfunc_die();\n    }\n\n    /* Compat with old abrt dumps. Remove in abrt-2.1 */\n    if (strcmp(name, \"release\") == 0)\n        name = FILENAME_OS_RELEASE;\n\n    char *full_path = concat_path_file(dd->dd_dirname, name);\n    char *ret = load_text_file(full_path, flags);\n    free(full_path);\n\n    return ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149593,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "wiki_handle_rest_call(HttpRequest  *req, \n\t\t      HttpResponse *res,\n\t\t      char         *func)\n{\n\n  if (func != NULL && *func != '\\0')\n    {\n      if (!strcmp(func, \"page/get\"))\n\t{\n\t  char *page = http_request_param_get(req, \"page\");\n\n\t  if (page == NULL)\n\t    page = http_request_get_query_string(req);\n\n\t  if (page && (access(page, R_OK) == 0)) \n\t    {\n\t      http_response_printf(res, \"%s\", file_read(page));\n\t      http_response_send(res);\n\t      return;\n\t    }  \n\t}\n      else if (!strcmp(func, \"page/set\"))\n\t{\n\t  char *wikitext = NULL, *page = NULL;\n\t  if( ( (wikitext = http_request_param_get(req, \"text\")) != NULL)\n\t      && ( (page = http_request_param_get(req, \"page\")) != NULL))\n\t    {\n\t      file_write(page, wikitext);\t      \n\t      http_response_printf(res, \"success\");\n\t      http_response_send(res);\n\t      return;\n\t    }\n\t}\n      else if (!strcmp(func, \"page/delete\"))\n\t{\n\t  char *page = http_request_param_get(req, \"page\");\n\n\t  if (page == NULL)\n\t    page = http_request_get_query_string(req);\n\n\t  if (page && (unlink(page) > 0))\n\t    {\n\t      http_response_printf(res, \"success\");\n\t      http_response_send(res);\n\t      return;  \n\t    }\n\t}\n      else if (!strcmp(func, \"page/exists\"))\n\t{\n\t  char *page = http_request_param_get(req, \"page\");\n\n\t  if (page == NULL)\n\t    page = http_request_get_query_string(req);\n\n\t  if (page && (access(page, R_OK) == 0)) \n\t    {\n\t      http_response_printf(res, \"success\");\n\t      http_response_send(res);\n\t      return;  \n\t    }\n\t}\n      else if (!strcmp(func, \"pages\") || !strcmp(func, \"search\"))\n\t{\n\t  WikiPageList **pages = NULL;\n\t  int            n_pages, i;\n\t  char          *expr = http_request_param_get(req, \"expr\");\n\n\t  if (expr == NULL)\n\t    expr = http_request_get_query_string(req);\n\t  \n\t  pages = wiki_get_pages(&n_pages, expr);\n\n\t  if (pages)\n\t    {\n\t      for (i=0; i<n_pages; i++)\n\t\t{\n\t\t  struct tm   *pTm;\n\t\t  char   datebuf[64];\n\t\t  \n\t\t  pTm = localtime(&pages[i]->mtime);\n\t\t  strftime(datebuf, sizeof(datebuf), \"%Y-%m-%d %H:%M\", pTm);\n\t\t  http_response_printf(res, \"%s\\t%s\\n\", pages[i]->name, datebuf);\n\t\t}\n\n\t      http_response_send(res);\n\t      return;  \n\t    }\n\t}\n    }\n\n  http_response_set_status(res, 500, \"Error\");\n  http_response_printf(res, \"<html><body>Failed</body></html>\\n\");\n  http_response_send(res);\n\n  return;  \n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149596,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "wiki_handle_rest_call(HttpRequest  *req, \n\t\t      HttpResponse *res,\n\t\t      char         *func)\n{\n\n  if (func != NULL && *func != '\\0')\n    {\n      if (!strcmp(func, \"page/get\"))\n\t{\n\t  char *page = http_request_param_get(req, \"page\");\n\n\t  if (page == NULL)\n\t    page = http_request_get_query_string(req);\n\n\t  if (page && page_name_is_good(page) && (access(page, R_OK) == 0))\n\t    {\n\t      http_response_printf(res, \"%s\", file_read(page));\n\t      http_response_send(res);\n\t      return;\n\t    }  \n\t}\n      else if (!strcmp(func, \"page/set\"))\n\t{\n\t  char *wikitext = NULL, *page = NULL;\n\t  if( ( (wikitext = http_request_param_get(req, \"text\")) != NULL)\n\t      && ( (page = http_request_param_get(req, \"page\")) != NULL))\n\t    {\n\t  if (page_name_is_good(page))\n\t    {\n\t      file_write(page, wikitext);\n\t      http_response_printf(res, \"success\");\n\t      http_response_send(res);\n\t      return;\n\t    }\n\t    }\n\t}\n      else if (!strcmp(func, \"page/delete\"))\n\t{\n\t  char *page = http_request_param_get(req, \"page\");\n\n\t  if (page == NULL)\n\t    page = http_request_get_query_string(req);\n\n\t  if (page && page_name_is_good(page) && (unlink(page) > 0))\n\t    {\n\t      http_response_printf(res, \"success\");\n\t      http_response_send(res);\n\t      return;  \n\t    }\n\t}\n      else if (!strcmp(func, \"page/exists\"))\n\t{\n\t  char *page = http_request_param_get(req, \"page\");\n\n\t  if (page == NULL)\n\t    page = http_request_get_query_string(req);\n\n\t  if (page && page_name_is_good(page) && (access(page, R_OK) == 0))\n\t    {\n\t      http_response_printf(res, \"success\");\n\t      http_response_send(res);\n\t      return;  \n\t    }\n\t}\n      else if (!strcmp(func, \"pages\") || !strcmp(func, \"search\"))\n\t{\n\t  WikiPageList **pages = NULL;\n\t  int            n_pages, i;\n\t  char          *expr = http_request_param_get(req, \"expr\");\n\n\t  if (expr == NULL)\n\t    expr = http_request_get_query_string(req);\n\t  \n\t  pages = wiki_get_pages(&n_pages, expr);\n\n\t  if (pages)\n\t    {\n\t      for (i=0; i<n_pages; i++)\n\t\t{\n\t\t  struct tm   *pTm;\n\t\t  char   datebuf[64];\n\t\t  \n\t\t  pTm = localtime(&pages[i]->mtime);\n\t\t  strftime(datebuf, sizeof(datebuf), \"%Y-%m-%d %H:%M\", pTm);\n\t\t  http_response_printf(res, \"%s\\t%s\\n\", pages[i]->name, datebuf);\n\t\t}\n\n\t      http_response_send(res);\n\t      return;  \n\t    }\n\t}\n    }\n\n  http_response_set_status(res, 500, \"Error\");\n  http_response_printf(res, \"<html><body>Failed</body></html>\\n\");\n  http_response_send(res);\n\n  return;  \n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149597,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "static void handle_method_call(GDBusConnection *connection,\n                        const gchar *caller,\n                        const gchar *object_path,\n                        const gchar *interface_name,\n                        const gchar *method_name,\n                        GVariant    *parameters,\n                        GDBusMethodInvocation *invocation,\n                        gpointer    user_data)\n{\n    reset_timeout();\n\n    uid_t caller_uid;\n    GVariant *response;\n\n    caller_uid = get_caller_uid(connection, invocation, caller);\n\n    log_notice(\"caller_uid:%ld method:'%s'\", (long)caller_uid, method_name);\n\n    if (caller_uid == (uid_t) -1)\n        return;\n\n    if (g_strcmp0(method_name, \"NewProblem\") == 0)\n    {\n        char *error = NULL;\n        char *problem_id = handle_new_problem(g_variant_get_child_value(parameters, 0), caller_uid, &error);\n        if (!problem_id)\n        {\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                                      \"org.freedesktop.problems.Failure\",\n                                                      error);\n            free(error);\n            return;\n        }\n        /* else */\n        response = g_variant_new(\"(s)\", problem_id);\n        g_dbus_method_invocation_return_value(invocation, response);\n        free(problem_id);\n\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetProblems\") == 0)\n    {\n        GList *dirs = get_problem_dirs_for_uid(caller_uid, g_settings_dump_location);\n        response = variant_from_string_list(dirs);\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        //I was told that g_dbus_method frees the response\n        //g_variant_unref(response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetAllProblems\") == 0)\n    {\n        /*\n        - so, we have UID,\n        - if it's 0, then we don't have to check anything and just return all directories\n        - if uid != 0 then we want to ask for authorization\n        */\n        if (caller_uid != 0)\n        {\n            if (polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") == PolkitYes)\n                caller_uid = 0;\n        }\n\n        GList * dirs = get_problem_dirs_for_uid(caller_uid, g_settings_dump_location);\n        response = variant_from_string_list(dirs);\n\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetForeignProblems\") == 0)\n    {\n        GList * dirs = get_problem_dirs_not_accessible_by_uid(caller_uid, g_settings_dump_location);\n        response = variant_from_string_list(dirs);\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"ChownProblemDir\") == 0)\n    {\n        const gchar *problem_dir;\n        g_variant_get(parameters, \"(&s)\", &problem_dir);\n        log_notice(\"problem_dir:'%s'\", problem_dir);\n\n        if (!allowed_problem_dir(problem_dir))\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int dir_fd = dd_openfd(problem_dir);\n        if (dir_fd < 0)\n        {\n            perror_msg(\"can't open problem directory '%s'\", problem_dir);\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int ddstat = fdump_dir_stat_for_uid(dir_fd, caller_uid);\n        if (ddstat < 0)\n        {\n            if (errno == ENOTDIR)\n            {\n                log_notice(\"requested directory does not exist '%s'\", problem_dir);\n            }\n            else\n            {\n                perror_msg(\"can't get stat of '%s'\", problem_dir);\n            }\n\n            return_InvalidProblemDir_error(invocation, problem_dir);\n\n            close(dir_fd);\n            return;\n        }\n\n        if (ddstat & DD_STAT_OWNED_BY_UID)\n        {   //caller seems to be in group with access to this dir, so no action needed\n            log_notice(\"caller has access to the requested directory %s\", problem_dir);\n            g_dbus_method_invocation_return_value(invocation, NULL);\n            close(dir_fd);\n            return;\n        }\n\n        if ((ddstat & DD_STAT_ACCESSIBLE_BY_UID) == 0 &&\n                polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") != PolkitYes)\n        {\n            log_notice(\"not authorized\");\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.AuthFailure\",\n                                              _(\"Not Authorized\"));\n            close(dir_fd);\n            return;\n        }\n\n        struct dump_dir *dd = dd_fdopendir(dir_fd, problem_dir, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES);\n        if (!dd)\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int chown_res = dd_chown(dd, caller_uid);\n        if (chown_res != 0)\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.ChownError\",\n                                              _(\"Chowning directory failed. Check system logs for more details.\"));\n        else\n            g_dbus_method_invocation_return_value(invocation, NULL);\n\n        dd_close(dd);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetInfo\") == 0)\n    {\n        /* Parameter tuple is (sas) */\n\n\t/* Get 1st param - problem dir name */\n        const gchar *problem_dir;\n        g_variant_get_child(parameters, 0, \"&s\", &problem_dir);\n        log_notice(\"problem_dir:'%s'\", problem_dir);\n\n        if (!allowed_problem_dir(problem_dir))\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int dir_fd = dd_openfd(problem_dir);\n        if (dir_fd < 0)\n        {\n            perror_msg(\"can't open problem directory '%s'\", problem_dir);\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        if (!fdump_dir_accessible_by_uid(dir_fd, caller_uid))\n        {\n            if (errno == ENOTDIR)\n            {\n                log_notice(\"Requested directory does not exist '%s'\", problem_dir);\n                return_InvalidProblemDir_error(invocation, problem_dir);\n                close(dir_fd);\n                return;\n            }\n\n            if (polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") != PolkitYes)\n            {\n                log_notice(\"not authorized\");\n                g_dbus_method_invocation_return_dbus_error(invocation,\n                                                  \"org.freedesktop.problems.AuthFailure\",\n                                                  _(\"Not Authorized\"));\n                close(dir_fd);\n                return;\n            }\n        }\n\n        struct dump_dir *dd = dd_fdopendir(dir_fd, problem_dir, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES);\n        if (!dd)\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n\t/* Get 2nd param - vector of element names */\n        GVariant *array = g_variant_get_child_value(parameters, 1);\n        GList *elements = string_list_from_variant(array);\n        g_variant_unref(array);\n\n        GVariantBuilder *builder = NULL;\n        for (GList *l = elements; l; l = l->next)\n        {\n            const char *element_name = (const char*)l->data;\n            char *value = dd_load_text_ext(dd, element_name, 0\n                                                | DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE\n                                                | DD_FAIL_QUIETLY_ENOENT\n                                                | DD_FAIL_QUIETLY_EACCES);\n            log_notice(\"element '%s' %s\", element_name, value ? \"fetched\" : \"not found\");\n            if (value)\n            {\n                if (!builder)\n                    builder = g_variant_builder_new(G_VARIANT_TYPE_ARRAY);\n\n                /* g_variant_builder_add makes a copy. No need to xstrdup here */\n                g_variant_builder_add(builder, \"{ss}\", element_name, value);\n                free(value);\n            }\n        }\n        list_free_with_free(elements);\n        dd_close(dd);\n        /* It is OK to call g_variant_new(\"(a{ss})\", NULL) because */\n        /* G_VARIANT_TYPE_TUPLE allows NULL value */\n        GVariant *response = g_variant_new(\"(a{ss})\", builder);\n\n        if (builder)\n            g_variant_builder_unref(builder);\n\n        log_info(\"GetInfo: returning value for '%s'\", problem_dir);\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"SetElement\") == 0)\n    {\n        const char *problem_id;\n        const char *element;\n        const char *value;\n\n        g_variant_get(parameters, \"(&s&s&s)\", &problem_id, &element, &value);\n\n        if (element == NULL || element[0] == '\\0' || strlen(element) > 64)\n        {\n            log_notice(\"'%s' is not a valid element name of '%s'\", element, problem_id);\n            char *error = xasprintf(_(\"'%s' is not a valid element name\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.InvalidElement\",\n                                              error);\n\n            free(error);\n            return;\n        }\n\n        struct dump_dir *dd = open_directory_for_modification_of_element(\n                                    invocation, caller_uid, problem_id, element);\n        if (!dd)\n            /* Already logged from open_directory_for_modification_of_element() */\n            return;\n\n        /* Is it  idea to make it static? Is it possible to change the max size while a single run? */\n        const double max_dir_size = g_settings_nMaxCrashReportsSize * (1024 * 1024);\n        const long item_size = dd_get_item_size(dd, element);\n        if (item_size < 0)\n        {\n            log_notice(\"Can't get size of '%s/%s'\", problem_id, element);\n            char *error = xasprintf(_(\"Can't get size of '%s'\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                                      \"org.freedesktop.problems.Failure\",\n                                                      error);\n            return;\n        }\n\n        const double requested_size = (double)strlen(value) - item_size;\n        /* Don't want to check the size limit in case of reducing of size */\n        if (requested_size > 0\n            && requested_size > (max_dir_size - get_dirsize(g_settings_dump_location)))\n        {\n            log_notice(\"No problem space left in '%s' (requested Bytes %f)\", problem_id, requested_size);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                                      \"org.freedesktop.problems.Failure\",\n                                                      _(\"No problem space left\"));\n        }\n        else\n        {\n            dd_save_text(dd, element, value);\n            g_dbus_method_invocation_return_value(invocation, NULL);\n        }\n\n        dd_close(dd);\n\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"DeleteElement\") == 0)\n    {\n        const char *problem_id;\n        const char *element;\n\n        g_variant_get(parameters, \"(&s&s)\", &problem_id, &element);\n\n        struct dump_dir *dd = open_directory_for_modification_of_element(\n                                    invocation, caller_uid, problem_id, element);\n        if (!dd)\n            /* Already logged from open_directory_for_modification_of_element() */\n            return;\n\n        const int res = dd_delete_item(dd, element);\n        dd_close(dd);\n\n        if (res != 0)\n        {\n            log_notice(\"Can't delete the element '%s' from the problem directory '%s'\", element, problem_id);\n            char *error = xasprintf(_(\"Can't delete the element '%s' from the problem directory '%s'\"), element, problem_id);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                          \"org.freedesktop.problems.Failure\",\n                                          error);\n            free(error);\n            return;\n        }\n\n\n        g_dbus_method_invocation_return_value(invocation, NULL);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"DeleteProblem\") == 0)\n    {\n        /* Dbus parameters are always tuples.\n         * In this case, it's (as) - a tuple of one element (array of strings).\n         * Need to fetch the array:\n         */\n        GVariant *array = g_variant_get_child_value(parameters, 0);\n        GList *problem_dirs = string_list_from_variant(array);\n        g_variant_unref(array);\n\n        for (GList *l = problem_dirs; l; l = l->next)\n        {\n            const char *dir_name = (const char*)l->data;\n            log_notice(\"dir_name:'%s'\", dir_name);\n            if (!allowed_problem_dir(dir_name))\n            {\n                return_InvalidProblemDir_error(invocation, dir_name);\n                goto ret;\n            }\n        }\n\n        for (GList *l = problem_dirs; l; l = l->next)\n        {\n            const char *dir_name = (const char*)l->data;\n\n            int dir_fd = dd_openfd(dir_name);\n            if (dir_fd < 0)\n            {\n                perror_msg(\"can't open problem directory '%s'\", dir_name);\n                return_InvalidProblemDir_error(invocation, dir_name);\n                return;\n            }\n\n            if (!fdump_dir_accessible_by_uid(dir_fd, caller_uid))\n            {\n                if (errno == ENOTDIR)\n                {\n                    log_notice(\"Requested directory does not exist '%s'\", dir_name);\n                    close(dir_fd);\n                    continue;\n                }\n\n                if (polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") != PolkitYes)\n                { // if user didn't provide correct credentials, just move to the next dir\n                    close(dir_fd);\n                    continue;\n                }\n            }\n\n            struct dump_dir *dd = dd_fdopendir(dir_fd, dir_name, /*flags:*/ 0);\n            if (dd)\n            {\n                if (dd_delete(dd) != 0)\n                {\n                    error_msg(\"Failed to delete problem directory '%s'\", dir_name);\n                    dd_close(dd);\n                }\n            }\n        }\n\n        g_dbus_method_invocation_return_value(invocation, NULL);\n ret:\n        list_free_with_free(problem_dirs);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"FindProblemByElementInTimeRange\") == 0)\n    {\n        const gchar *element;\n        const gchar *value;\n        glong timestamp_from;\n        glong timestamp_to;\n        gboolean all;\n\n        g_variant_get_child(parameters, 0, \"&s\", &element);\n        g_variant_get_child(parameters, 1, \"&s\", &value);\n        g_variant_get_child(parameters, 2, \"x\", &timestamp_from);\n        g_variant_get_child(parameters, 3, \"x\", &timestamp_to);\n        g_variant_get_child(parameters, 4, \"b\", &all);\n\n        if (all && polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") == PolkitYes)\n            caller_uid = 0;\n\n        GList *dirs = get_problem_dirs_for_element_in_time(caller_uid, element, value, timestamp_from,\n                                                        timestamp_to);\n        response = variant_from_string_list(dirs);\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"Quit\") == 0)\n    {\n        g_dbus_method_invocation_return_value(invocation, NULL);\n        g_main_loop_quit(loop);\n        return;\n    }\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149598,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "static void handle_method_call(GDBusConnection *connection,\n                        const gchar *caller,\n                        const gchar *object_path,\n                        const gchar *interface_name,\n                        const gchar *method_name,\n                        GVariant    *parameters,\n                        GDBusMethodInvocation *invocation,\n                        gpointer    user_data)\n{\n    reset_timeout();\n\n    uid_t caller_uid;\n    GVariant *response;\n\n    caller_uid = get_caller_uid(connection, invocation, caller);\n\n    log_notice(\"caller_uid:%ld method:'%s'\", (long)caller_uid, method_name);\n\n    if (caller_uid == (uid_t) -1)\n        return;\n\n    if (g_strcmp0(method_name, \"NewProblem\") == 0)\n    {\n        char *error = NULL;\n        char *problem_id = handle_new_problem(g_variant_get_child_value(parameters, 0), caller_uid, &error);\n        if (!problem_id)\n        {\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                                      \"org.freedesktop.problems.Failure\",\n                                                      error);\n            free(error);\n            return;\n        }\n        /* else */\n        response = g_variant_new(\"(s)\", problem_id);\n        g_dbus_method_invocation_return_value(invocation, response);\n        free(problem_id);\n\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetProblems\") == 0)\n    {\n        GList *dirs = get_problem_dirs_for_uid(caller_uid, g_settings_dump_location);\n        response = variant_from_string_list(dirs);\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        //I was told that g_dbus_method frees the response\n        //g_variant_unref(response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetAllProblems\") == 0)\n    {\n        /*\n        - so, we have UID,\n        - if it's 0, then we don't have to check anything and just return all directories\n        - if uid != 0 then we want to ask for authorization\n        */\n        if (caller_uid != 0)\n        {\n            if (polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") == PolkitYes)\n                caller_uid = 0;\n        }\n\n        GList * dirs = get_problem_dirs_for_uid(caller_uid, g_settings_dump_location);\n        response = variant_from_string_list(dirs);\n\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetForeignProblems\") == 0)\n    {\n        GList * dirs = get_problem_dirs_not_accessible_by_uid(caller_uid, g_settings_dump_location);\n        response = variant_from_string_list(dirs);\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"ChownProblemDir\") == 0)\n    {\n        const gchar *problem_dir;\n        g_variant_get(parameters, \"(&s)\", &problem_dir);\n        log_notice(\"problem_dir:'%s'\", problem_dir);\n\n        if (!allowed_problem_dir(problem_dir))\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int dir_fd = dd_openfd(problem_dir);\n        if (dir_fd < 0)\n        {\n            perror_msg(\"can't open problem directory '%s'\", problem_dir);\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int ddstat = fdump_dir_stat_for_uid(dir_fd, caller_uid);\n        if (ddstat < 0)\n        {\n            if (errno == ENOTDIR)\n            {\n                log_notice(\"requested directory does not exist '%s'\", problem_dir);\n            }\n            else\n            {\n                perror_msg(\"can't get stat of '%s'\", problem_dir);\n            }\n\n            return_InvalidProblemDir_error(invocation, problem_dir);\n\n            close(dir_fd);\n            return;\n        }\n\n        if (ddstat & DD_STAT_OWNED_BY_UID)\n        {   //caller seems to be in group with access to this dir, so no action needed\n            log_notice(\"caller has access to the requested directory %s\", problem_dir);\n            g_dbus_method_invocation_return_value(invocation, NULL);\n            close(dir_fd);\n            return;\n        }\n\n        if ((ddstat & DD_STAT_ACCESSIBLE_BY_UID) == 0 &&\n                polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") != PolkitYes)\n        {\n            log_notice(\"not authorized\");\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.AuthFailure\",\n                                              _(\"Not Authorized\"));\n            close(dir_fd);\n            return;\n        }\n\n        struct dump_dir *dd = dd_fdopendir(dir_fd, problem_dir, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES);\n        if (!dd)\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int chown_res = dd_chown(dd, caller_uid);\n        if (chown_res != 0)\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.ChownError\",\n                                              _(\"Chowning directory failed. Check system logs for more details.\"));\n        else\n            g_dbus_method_invocation_return_value(invocation, NULL);\n\n        dd_close(dd);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetInfo\") == 0)\n    {\n        /* Parameter tuple is (sas) */\n\n\t/* Get 1st param - problem dir name */\n        const gchar *problem_dir;\n        g_variant_get_child(parameters, 0, \"&s\", &problem_dir);\n        log_notice(\"problem_dir:'%s'\", problem_dir);\n\n        if (!allowed_problem_dir(problem_dir))\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int dir_fd = dd_openfd(problem_dir);\n        if (dir_fd < 0)\n        {\n            perror_msg(\"can't open problem directory '%s'\", problem_dir);\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        if (!fdump_dir_accessible_by_uid(dir_fd, caller_uid))\n        {\n            if (errno == ENOTDIR)\n            {\n                log_notice(\"Requested directory does not exist '%s'\", problem_dir);\n                return_InvalidProblemDir_error(invocation, problem_dir);\n                close(dir_fd);\n                return;\n            }\n\n            if (polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") != PolkitYes)\n            {\n                log_notice(\"not authorized\");\n                g_dbus_method_invocation_return_dbus_error(invocation,\n                                                  \"org.freedesktop.problems.AuthFailure\",\n                                                  _(\"Not Authorized\"));\n                close(dir_fd);\n                return;\n            }\n        }\n\n        struct dump_dir *dd = dd_fdopendir(dir_fd, problem_dir, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES);\n        if (!dd)\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n\t/* Get 2nd param - vector of element names */\n        GVariant *array = g_variant_get_child_value(parameters, 1);\n        GList *elements = string_list_from_variant(array);\n        g_variant_unref(array);\n\n        GVariantBuilder *builder = NULL;\n        for (GList *l = elements; l; l = l->next)\n        {\n            const char *element_name = (const char*)l->data;\n            char *value = dd_load_text_ext(dd, element_name, 0\n                                                | DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE\n                                                | DD_FAIL_QUIETLY_ENOENT\n                                                | DD_FAIL_QUIETLY_EACCES);\n            log_notice(\"element '%s' %s\", element_name, value ? \"fetched\" : \"not found\");\n            if (value)\n            {\n                if (!builder)\n                    builder = g_variant_builder_new(G_VARIANT_TYPE_ARRAY);\n\n                /* g_variant_builder_add makes a copy. No need to xstrdup here */\n                g_variant_builder_add(builder, \"{ss}\", element_name, value);\n                free(value);\n            }\n        }\n        list_free_with_free(elements);\n        dd_close(dd);\n        /* It is OK to call g_variant_new(\"(a{ss})\", NULL) because */\n        /* G_VARIANT_TYPE_TUPLE allows NULL value */\n        GVariant *response = g_variant_new(\"(a{ss})\", builder);\n\n        if (builder)\n            g_variant_builder_unref(builder);\n\n        log_info(\"GetInfo: returning value for '%s'\", problem_dir);\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"SetElement\") == 0)\n    {\n        const char *problem_id;\n        const char *element;\n        const char *value;\n\n        g_variant_get(parameters, \"(&s&s&s)\", &problem_id, &element, &value);\n\n        if (!str_is_correct_filename(element))\n        {\n            log_notice(\"'%s' is not a valid element name of '%s'\", element, problem_id);\n            char *error = xasprintf(_(\"'%s' is not a valid element name\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.InvalidElement\",\n                                              error);\n\n            free(error);\n            return;\n        }\n\n        struct dump_dir *dd = open_directory_for_modification_of_element(\n                                    invocation, caller_uid, problem_id, element);\n        if (!dd)\n            /* Already logged from open_directory_for_modification_of_element() */\n            return;\n\n        /* Is it  idea to make it static? Is it possible to change the max size while a single run? */\n        const double max_dir_size = g_settings_nMaxCrashReportsSize * (1024 * 1024);\n        const long item_size = dd_get_item_size(dd, element);\n        if (item_size < 0)\n        {\n            log_notice(\"Can't get size of '%s/%s'\", problem_id, element);\n            char *error = xasprintf(_(\"Can't get size of '%s'\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                                      \"org.freedesktop.problems.Failure\",\n                                                      error);\n            return;\n        }\n\n        const double requested_size = (double)strlen(value) - item_size;\n        /* Don't want to check the size limit in case of reducing of size */\n        if (requested_size > 0\n            && requested_size > (max_dir_size - get_dirsize(g_settings_dump_location)))\n        {\n            log_notice(\"No problem space left in '%s' (requested Bytes %f)\", problem_id, requested_size);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                                      \"org.freedesktop.problems.Failure\",\n                                                      _(\"No problem space left\"));\n        }\n        else\n        {\n            dd_save_text(dd, element, value);\n            g_dbus_method_invocation_return_value(invocation, NULL);\n        }\n\n        dd_close(dd);\n\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"DeleteElement\") == 0)\n    {\n        const char *problem_id;\n        const char *element;\n\n        g_variant_get(parameters, \"(&s&s)\", &problem_id, &element);\n\n        if (!str_is_correct_filename(element))\n        {\n            log_notice(\"'%s' is not a valid element name of '%s'\", element, problem_id);\n            char *error = xasprintf(_(\"'%s' is not a valid element name\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.InvalidElement\",\n                                              error);\n\n            free(error);\n            return;\n        }\n\n        struct dump_dir *dd = open_directory_for_modification_of_element(\n                                    invocation, caller_uid, problem_id, element);\n        if (!dd)\n            /* Already logged from open_directory_for_modification_of_element() */\n            return;\n\n        const int res = dd_delete_item(dd, element);\n        dd_close(dd);\n\n        if (res != 0)\n        {\n            log_notice(\"Can't delete the element '%s' from the problem directory '%s'\", element, problem_id);\n            char *error = xasprintf(_(\"Can't delete the element '%s' from the problem directory '%s'\"), element, problem_id);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                          \"org.freedesktop.problems.Failure\",\n                                          error);\n            free(error);\n            return;\n        }\n\n\n        g_dbus_method_invocation_return_value(invocation, NULL);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"DeleteProblem\") == 0)\n    {\n        /* Dbus parameters are always tuples.\n         * In this case, it's (as) - a tuple of one element (array of strings).\n         * Need to fetch the array:\n         */\n        GVariant *array = g_variant_get_child_value(parameters, 0);\n        GList *problem_dirs = string_list_from_variant(array);\n        g_variant_unref(array);\n\n        for (GList *l = problem_dirs; l; l = l->next)\n        {\n            const char *dir_name = (const char*)l->data;\n            log_notice(\"dir_name:'%s'\", dir_name);\n            if (!allowed_problem_dir(dir_name))\n            {\n                return_InvalidProblemDir_error(invocation, dir_name);\n                goto ret;\n            }\n        }\n\n        for (GList *l = problem_dirs; l; l = l->next)\n        {\n            const char *dir_name = (const char*)l->data;\n\n            int dir_fd = dd_openfd(dir_name);\n            if (dir_fd < 0)\n            {\n                perror_msg(\"can't open problem directory '%s'\", dir_name);\n                return_InvalidProblemDir_error(invocation, dir_name);\n                return;\n            }\n\n            if (!fdump_dir_accessible_by_uid(dir_fd, caller_uid))\n            {\n                if (errno == ENOTDIR)\n                {\n                    log_notice(\"Requested directory does not exist '%s'\", dir_name);\n                    close(dir_fd);\n                    continue;\n                }\n\n                if (polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") != PolkitYes)\n                { // if user didn't provide correct credentials, just move to the next dir\n                    close(dir_fd);\n                    continue;\n                }\n            }\n\n            struct dump_dir *dd = dd_fdopendir(dir_fd, dir_name, /*flags:*/ 0);\n            if (dd)\n            {\n                if (dd_delete(dd) != 0)\n                {\n                    error_msg(\"Failed to delete problem directory '%s'\", dir_name);\n                    dd_close(dd);\n                }\n            }\n        }\n\n        g_dbus_method_invocation_return_value(invocation, NULL);\n ret:\n        list_free_with_free(problem_dirs);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"FindProblemByElementInTimeRange\") == 0)\n    {\n        const gchar *element;\n        const gchar *value;\n        glong timestamp_from;\n        glong timestamp_to;\n        gboolean all;\n\n        g_variant_get_child(parameters, 0, \"&s\", &element);\n        g_variant_get_child(parameters, 1, \"&s\", &value);\n        g_variant_get_child(parameters, 2, \"x\", &timestamp_from);\n        g_variant_get_child(parameters, 3, \"x\", &timestamp_to);\n        g_variant_get_child(parameters, 4, \"b\", &all);\n\n        if (all && polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") == PolkitYes)\n            caller_uid = 0;\n\n        GList *dirs = get_problem_dirs_for_element_in_time(caller_uid, element, value, timestamp_from,\n                                                        timestamp_to);\n        response = variant_from_string_list(dirs);\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"Quit\") == 0)\n    {\n        g_dbus_method_invocation_return_value(invocation, NULL);\n        g_main_loop_quit(loop);\n        return;\n    }\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149599,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "char *compose_path(ctrl_t *ctrl, char *path)\n{\n\tstruct stat st;\n\tstatic char rpath[PATH_MAX];\n\tchar *name, *ptr;\n\tchar dir[PATH_MAX] = { 0 };\n\n\tstrlcpy(dir, ctrl->cwd, sizeof(dir));\n\tDBG(\"Compose path from cwd: %s, arg: %s\", ctrl->cwd, path ?: \"\");\n\tif (!path || !strlen(path))\n\t\tgoto check;\n\n\tif (path) {\n\t\tif (path[0] != '/') {\n\t\t\tif (dir[strlen(dir) - 1] != '/')\n\t\t\t\tstrlcat(dir, \"/\", sizeof(dir));\n\t\t}\n\t\tstrlcat(dir, path, sizeof(dir));\n\t}\n\ncheck:\n\twhile ((ptr = strstr(dir, \"//\")))\n\t\tmemmove(ptr, &ptr[1], strlen(&ptr[1]) + 1);\n\n\tif (!chrooted) {\n\t\tsize_t len = strlen(home);\n\n\t\tDBG(\"Server path from CWD: %s\", dir);\n\t\tif (len > 0 && home[len - 1] == '/')\n\t\t\tlen--;\n\t\tmemmove(dir + len, dir, strlen(dir) + 1);\n\t\tmemcpy(dir, home, len);\n\t\tDBG(\"Resulting non-chroot path: %s\", dir);\n\t}\n\n\t/*\n\t * Handle directories slightly differently, since dirname() on a\n\t * directory returns the parent directory.  So, just squash ..\n\t */\n\tif (!stat(dir, &st) && S_ISDIR(st.st_mode)) {\n\t\tif (!realpath(dir, rpath))\n\t\t\treturn NULL;\n\t} else {\n\t\t/*\n\t\t * Check realpath() of directory containing the file, a\n\t\t * STOR may want to save a new file.  Then append the\n\t\t * file and return it.\n\t\t */\n\t\tname = basename(path);\n\t\tptr = dirname(dir);\n\n\t\tmemset(rpath, 0, sizeof(rpath));\n\t\tif (!realpath(ptr, rpath)) {\n\t\t\tINFO(\"Failed realpath(%s): %m\", ptr);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (rpath[1] != 0)\n\t\t\tstrlcat(rpath, \"/\", sizeof(rpath));\n\t\tstrlcat(rpath, name, sizeof(rpath));\n\t}\n\n\tif (!chrooted && strncmp(dir, home, strlen(home))) {\n\t\tDBG(\"Failed non-chroot dir:%s vs home:%s\", dir, home);\n\t\treturn NULL;\n\t}\n\n\treturn rpath;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149602,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "char *compose_path(ctrl_t *ctrl, char *path)\n{\n\tstruct stat st;\n\tstatic char rpath[PATH_MAX];\n\tchar *name, *ptr;\n\tchar dir[PATH_MAX] = { 0 };\n\n\tstrlcpy(dir, ctrl->cwd, sizeof(dir));\n\tDBG(\"Compose path from cwd: %s, arg: %s\", ctrl->cwd, path ?: \"\");\n\tif (!path || !strlen(path))\n\t\tgoto check;\n\n\tif (path) {\n\t\tif (path[0] != '/') {\n\t\t\tif (dir[strlen(dir) - 1] != '/')\n\t\t\t\tstrlcat(dir, \"/\", sizeof(dir));\n\t\t}\n\t\tstrlcat(dir, path, sizeof(dir));\n\t}\n\ncheck:\n\twhile ((ptr = strstr(dir, \"//\")))\n\t\tmemmove(ptr, &ptr[1], strlen(&ptr[1]) + 1);\n\n\tif (!chrooted) {\n\t\tsize_t len = strlen(home);\n\n\t\tDBG(\"Server path from CWD: %s\", dir);\n\t\tif (len > 0 && home[len - 1] == '/')\n\t\t\tlen--;\n\t\tmemmove(dir + len, dir, strlen(dir) + 1);\n\t\tmemcpy(dir, home, len);\n\t\tDBG(\"Resulting non-chroot path: %s\", dir);\n\t}\n\n\t/*\n\t * Handle directories slightly differently, since dirname() on a\n\t * directory returns the parent directory.  So, just squash ..\n\t */\n\tif (!stat(dir, &st) && S_ISDIR(st.st_mode)) {\n\t\tif (!realpath(dir, rpath))\n\t\t\treturn NULL;\n\t} else {\n\t\t/*\n\t\t * Check realpath() of directory containing the file, a\n\t\t * STOR may want to save a new file.  Then append the\n\t\t * file and return it.\n\t\t */\n\t\tname = basename(path);\n\t\tptr = dirname(dir);\n\n\t\tmemset(rpath, 0, sizeof(rpath));\n\t\tif (!realpath(ptr, rpath)) {\n\t\t\tINFO(\"Failed realpath(%s): %m\", ptr);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (rpath[1] != 0)\n\t\t\tstrlcat(rpath, \"/\", sizeof(rpath));\n\t\tstrlcat(rpath, name, sizeof(rpath));\n\t}\n\n\tif (!chrooted && strncmp(rpath, home, strlen(home))) {\n\t\tDBG(\"Failed non-chroot dir:%s vs home:%s\", dir, home);\n\t\treturn NULL;\n\t}\n\n\treturn rpath;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149603,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "int dd_exist(const struct dump_dir *dd, const char *path)\n{\n    char *full_path = concat_path_file(dd->dd_dirname, path);\n    int ret = exist_file_dir(full_path);\n    free(full_path);\n    return ret;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149604,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "int dd_exist(const struct dump_dir *dd, const char *path)\n{\n    if (!str_is_correct_filename(path))\n        error_msg_and_die(\"Cannot test existence. '%s' is not a valid file name\", path);\n\n    char *full_path = concat_path_file(dd->dd_dirname, path);\n    int ret = exist_file_dir(full_path);\n    free(full_path);\n    return ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149605,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "static MagickBooleanType GetMagickModulePath(const char *filename,\n  MagickModuleType module_type,char *path,ExceptionInfo *exception)\n{\n  char\n    *module_path;\n\n  assert(filename != (const char *) NULL);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",filename);\n  assert(path != (char *) NULL);\n  assert(exception != (ExceptionInfo *) NULL);\n  (void) CopyMagickString(path,filename,MaxTextExtent);\n  module_path=(char *) NULL;\n  switch (module_type)\n  {\n    case MagickImageCoderModule:\n    default:\n    {\n      (void) LogMagickEvent(ModuleEvent,GetMagickModule(),\n        \"Searching for coder module file \\\"%s\\\" ...\",filename);\n      module_path=GetEnvironmentValue(\"MAGICK_CODER_MODULE_PATH\");\n#if defined(MAGICKCORE_CODER_PATH)\n      if (module_path == (char *) NULL)\n        module_path=AcquireString(MAGICKCORE_CODER_PATH);\n#endif\n      break;\n    }\n    case MagickImageFilterModule:\n    {\n      (void) LogMagickEvent(ModuleEvent,GetMagickModule(),\n        \"Searching for filter module file \\\"%s\\\" ...\",filename);\n      module_path=GetEnvironmentValue(\"MAGICK_CODER_FILTER_PATH\");\n#if defined(MAGICKCORE_FILTER_PATH)\n      if (module_path == (char *) NULL)\n        module_path=AcquireString(MAGICKCORE_FILTER_PATH);\n#endif\n      break;\n    }\n  }\n  if (module_path != (char *) NULL)\n    {\n      register char\n        *p,\n        *q;\n\n      for (p=module_path-1; p != (char *) NULL; )\n      {\n        (void) CopyMagickString(path,p+1,MaxTextExtent);\n        q=strchr(path,DirectoryListSeparator);\n        if (q != (char *) NULL)\n          *q='\\0';\n        q=path+strlen(path)-1;\n        if ((q >= path) && (*q != *DirectorySeparator))\n          (void) ConcatenateMagickString(path,DirectorySeparator,MaxTextExtent);\n        (void) ConcatenateMagickString(path,filename,MaxTextExtent);\n        if (IsPathAccessible(path) != MagickFalse)\n          {\n            module_path=DestroyString(module_path);\n            return(MagickTrue);\n          }\n        p=strchr(p+1,DirectoryListSeparator);\n      }\n      module_path=DestroyString(module_path);\n    }\n#if defined(MAGICKCORE_INSTALLED_SUPPORT)\n  else\n#if defined(MAGICKCORE_CODER_PATH)\n    {\n      const char\n        *directory;\n\n      /*\n        Search hard coded paths.\n      */\n      switch (module_type)\n      {\n        case MagickImageCoderModule:\n        default:\n        {\n          directory=MAGICKCORE_CODER_PATH;\n          break;\n        }\n        case MagickImageFilterModule:\n        {\n          directory=MAGICKCORE_FILTER_PATH;\n          break;\n        }\n      }\n      (void) FormatLocaleString(path,MaxTextExtent,\"%s%s\",directory,filename);\n      if (IsPathAccessible(path) == MagickFalse)\n        {\n          ThrowFileException(exception,ConfigureWarning,\n            \"UnableToOpenModuleFile\",path);\n          return(MagickFalse);\n        }\n      return(MagickTrue);\n    }\n#else\n#if defined(MAGICKCORE_WINDOWS_SUPPORT)\n    {\n      const char\n        *registery_key;\n\n      unsigned char\n        *key_value;\n\n      /*\n        Locate path via registry key.\n      */\n      switch (module_type)\n      {\n        case MagickImageCoderModule:\n        default:\n        {\n          registery_key=\"CoderModulesPath\";\n          break;\n        }\n        case MagickImageFilterModule:\n        {\n          registery_key=\"FilterModulesPath\";\n          break;\n        }\n      }\n      key_value=NTRegistryKeyLookup(registery_key);\n      if (key_value == (unsigned char *) NULL)\n        {\n          ThrowMagickException(exception,GetMagickModule(),ConfigureError,\n            \"RegistryKeyLookupFailed\",\"`%s'\",registery_key);\n          return(MagickFalse);\n        }\n      (void) FormatLocaleString(path,MaxTextExtent,\"%s%s%s\",(char *) key_value,\n        DirectorySeparator,filename);\n      key_value=(unsigned char *) RelinquishMagickMemory(key_value);\n      if (IsPathAccessible(path) == MagickFalse)\n        {\n          ThrowFileException(exception,ConfigureWarning,\n            \"UnableToOpenModuleFile\",path);\n          return(MagickFalse);\n        }\n      return(MagickTrue);\n    }\n#endif\n#endif\n#if !defined(MAGICKCORE_CODER_PATH) && !defined(MAGICKCORE_WINDOWS_SUPPORT)\n# error MAGICKCORE_CODER_PATH or MAGICKCORE_WINDOWS_SUPPORT must be defined when MAGICKCORE_INSTALLED_SUPPORT is defined\n#endif\n#else\n  {\n    char\n      *home;\n\n    home=GetEnvironmentValue(\"MAGICK_HOME\");\n    if (home != (char *) NULL)\n      {\n        /*\n          Search MAGICK_HOME.\n        */\n#if !defined(MAGICKCORE_POSIX_SUPPORT)\n        (void) FormatLocaleString(path,MaxTextExtent,\"%s%s%s\",home,\n          DirectorySeparator,filename);\n#else\n        const char\n          *directory;\n\n        switch (module_type)\n        {\n          case MagickImageCoderModule:\n          default:\n          {\n            directory=MAGICKCORE_CODER_RELATIVE_PATH;\n            break;\n          }\n          case MagickImageFilterModule:\n          {\n            directory=MAGICKCORE_FILTER_RELATIVE_PATH;\n            break;\n          }\n        }\n        (void) FormatLocaleString(path,MaxTextExtent,\"%s/lib/%s/%s\",home,\n          directory,filename);\n#endif\n        home=DestroyString(home);\n        if (IsPathAccessible(path) != MagickFalse)\n          return(MagickTrue);\n      }\n  }\n  if (*GetClientPath() != '\\0')\n    {\n      /*\n        Search based on executable directory.\n      */\n#if !defined(MAGICKCORE_POSIX_SUPPORT)\n      (void) FormatLocaleString(path,MaxTextExtent,\"%s%s%s\",GetClientPath(),\n        DirectorySeparator,filename);\n#else\n      char\n        prefix[MaxTextExtent];\n\n      const char\n        *directory;\n\n      switch (module_type)\n      {\n        case MagickImageCoderModule:\n        default:\n        {\n          directory=\"coders\";\n          break;\n        }\n        case MagickImageFilterModule:\n        {\n          directory=\"filters\";\n          break;\n        }\n      }\n      (void) CopyMagickString(prefix,GetClientPath(),MaxTextExtent);\n      ChopPathComponents(prefix,1);\n      (void) FormatLocaleString(path,MaxTextExtent,\"%s/lib/%s/%s/%s\",prefix,\n        MAGICKCORE_MODULES_RELATIVE_PATH,directory,filename);\n#endif\n      if (IsPathAccessible(path) != MagickFalse)\n        return(MagickTrue);\n    }\n#if defined(MAGICKCORE_WINDOWS_SUPPORT)\n  {\n    /*\n      Search module path.\n    */\n    if ((NTGetModulePath(\"CORE_RL_magick_.dll\",path) != MagickFalse) ||\n        (NTGetModulePath(\"CORE_DB_magick_.dll\",path) != MagickFalse) ||\n        (NTGetModulePath(\"Magick.dll\",path) != MagickFalse))\n      {\n        (void) ConcatenateMagickString(path,DirectorySeparator,MaxTextExtent);\n        (void) ConcatenateMagickString(path,filename,MaxTextExtent);\n        if (IsPathAccessible(path) != MagickFalse)\n          return(MagickTrue);\n      }\n  }\n#endif\n  {\n    char\n      *home;\n\n    home=GetEnvironmentValue(\"XDG_CONFIG_HOME\");\n    if (home == (char *) NULL)\n      home=GetEnvironmentValue(\"LOCALAPPDATA\");\n    if (home == (char *) NULL)\n      home=GetEnvironmentValue(\"APPDATA\");\n    if (home == (char *) NULL)\n      home=GetEnvironmentValue(\"USERPROFILE\");\n    if (home != (char *) NULL)\n      {\n        /*\n          Search $XDG_CONFIG_HOME/ImageMagick.\n        */\n        (void) FormatLocaleString(path,MaxTextExtent,\"%s%sImageMagick%s%s\",\n          home,DirectorySeparator,DirectorySeparator,filename);\n        home=DestroyString(home);\n        if (IsPathAccessible(path) != MagickFalse)\n          return(MagickTrue);\n      }\n    home=GetEnvironmentValue(\"HOME\");\n    if (home != (char *) NULL)\n      {\n        /*\n          Search $HOME/.config/ImageMagick.\n        */\n        (void) FormatLocaleString(path,MaxTextExtent,\n          \"%s%s.config%sImageMagick%s%s\",home,DirectorySeparator,\n          DirectorySeparator,DirectorySeparator,filename);\n        if (IsPathAccessible(path) != MagickFalse)\n          {\n            home=DestroyString(home);\n            return(MagickTrue);\n          }\n        /*\n          Search $HOME/.magick.\n        */\n        (void) FormatLocaleString(path,MaxTextExtent,\"%s%s.magick%s%s\",home,\n          DirectorySeparator,DirectorySeparator,filename);\n        home=DestroyString(home);\n        if (IsPathAccessible(path) != MagickFalse)\n          return(MagickTrue);\n      }\n  }\n  /*\n    Search current directory.\n  */\n  if (IsPathAccessible(path) != MagickFalse)\n    return(MagickTrue);\n  if (exception->severity < ConfigureError)\n    ThrowFileException(exception,ConfigureWarning,\"UnableToOpenModuleFile\",\n      path);\n#endif\n  return(MagickFalse);\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 150320,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "static MagickBooleanType GetMagickModulePath(const char *filename,\n  MagickModuleType module_type,char *path,ExceptionInfo *exception)\n{\n  char\n    *module_path;\n\n  assert(filename != (const char *) NULL);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",filename);\n  assert(path != (char *) NULL);\n  assert(exception != (ExceptionInfo *) NULL);\n  (void) CopyMagickString(path,filename,MaxTextExtent);\n#if defined(MAGICKCORE_INSTALLED_SUPPORT)\n  if (strstr(path,\"../\") != (char *) NULL)\n    {\n      errno=EPERM;\n      (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,\n        \"NotAuthorized\",\"`%s'\",path);\n      return(MagickFalse);\n    }\n#endif\n  module_path=(char *) NULL;\n  switch (module_type)\n  {\n    case MagickImageCoderModule:\n    default:\n    {\n      (void) LogMagickEvent(ModuleEvent,GetMagickModule(),\n        \"Searching for coder module file \\\"%s\\\" ...\",filename);\n      module_path=GetEnvironmentValue(\"MAGICK_CODER_MODULE_PATH\");\n#if defined(MAGICKCORE_CODER_PATH)\n      if (module_path == (char *) NULL)\n        module_path=AcquireString(MAGICKCORE_CODER_PATH);\n#endif\n      break;\n    }\n    case MagickImageFilterModule:\n    {\n      (void) LogMagickEvent(ModuleEvent,GetMagickModule(),\n        \"Searching for filter module file \\\"%s\\\" ...\",filename);\n      module_path=GetEnvironmentValue(\"MAGICK_CODER_FILTER_PATH\");\n#if defined(MAGICKCORE_FILTER_PATH)\n      if (module_path == (char *) NULL)\n        module_path=AcquireString(MAGICKCORE_FILTER_PATH);\n#endif\n      break;\n    }\n  }\n  if (module_path != (char *) NULL)\n    {\n      register char\n        *p,\n        *q;\n\n      for (p=module_path-1; p != (char *) NULL; )\n      {\n        (void) CopyMagickString(path,p+1,MaxTextExtent);\n        q=strchr(path,DirectoryListSeparator);\n        if (q != (char *) NULL)\n          *q='\\0';\n        q=path+strlen(path)-1;\n        if ((q >= path) && (*q != *DirectorySeparator))\n          (void) ConcatenateMagickString(path,DirectorySeparator,MaxTextExtent);\n        (void) ConcatenateMagickString(path,filename,MaxTextExtent);\n        if (IsPathAccessible(path) != MagickFalse)\n          {\n            module_path=DestroyString(module_path);\n            return(MagickTrue);\n          }\n        p=strchr(p+1,DirectoryListSeparator);\n      }\n      module_path=DestroyString(module_path);\n    }\n#if defined(MAGICKCORE_INSTALLED_SUPPORT)\n  else\n#if defined(MAGICKCORE_CODER_PATH)\n    {\n      const char\n        *directory;\n\n      /*\n        Search hard coded paths.\n      */\n      switch (module_type)\n      {\n        case MagickImageCoderModule:\n        default:\n        {\n          directory=MAGICKCORE_CODER_PATH;\n          break;\n        }\n        case MagickImageFilterModule:\n        {\n          directory=MAGICKCORE_FILTER_PATH;\n          break;\n        }\n      }\n      (void) FormatLocaleString(path,MaxTextExtent,\"%s%s\",directory,filename);\n      if (IsPathAccessible(path) == MagickFalse)\n        {\n          ThrowFileException(exception,ConfigureWarning,\n            \"UnableToOpenModuleFile\",path);\n          return(MagickFalse);\n        }\n      return(MagickTrue);\n    }\n#else\n#if defined(MAGICKCORE_WINDOWS_SUPPORT)\n    {\n      const char\n        *registery_key;\n\n      unsigned char\n        *key_value;\n\n      /*\n        Locate path via registry key.\n      */\n      switch (module_type)\n      {\n        case MagickImageCoderModule:\n        default:\n        {\n          registery_key=\"CoderModulesPath\";\n          break;\n        }\n        case MagickImageFilterModule:\n        {\n          registery_key=\"FilterModulesPath\";\n          break;\n        }\n      }\n      key_value=NTRegistryKeyLookup(registery_key);\n      if (key_value == (unsigned char *) NULL)\n        {\n          ThrowMagickException(exception,GetMagickModule(),ConfigureError,\n            \"RegistryKeyLookupFailed\",\"`%s'\",registery_key);\n          return(MagickFalse);\n        }\n      (void) FormatLocaleString(path,MaxTextExtent,\"%s%s%s\",(char *) key_value,\n        DirectorySeparator,filename);\n      key_value=(unsigned char *) RelinquishMagickMemory(key_value);\n      if (IsPathAccessible(path) == MagickFalse)\n        {\n          ThrowFileException(exception,ConfigureWarning,\n            \"UnableToOpenModuleFile\",path);\n          return(MagickFalse);\n        }\n      return(MagickTrue);\n    }\n#endif\n#endif\n#if !defined(MAGICKCORE_CODER_PATH) && !defined(MAGICKCORE_WINDOWS_SUPPORT)\n# error MAGICKCORE_CODER_PATH or MAGICKCORE_WINDOWS_SUPPORT must be defined when MAGICKCORE_INSTALLED_SUPPORT is defined\n#endif\n#else\n  {\n    char\n      *home;\n\n    home=GetEnvironmentValue(\"MAGICK_HOME\");\n    if (home != (char *) NULL)\n      {\n        /*\n          Search MAGICK_HOME.\n        */\n#if !defined(MAGICKCORE_POSIX_SUPPORT)\n        (void) FormatLocaleString(path,MaxTextExtent,\"%s%s%s\",home,\n          DirectorySeparator,filename);\n#else\n        const char\n          *directory;\n\n        switch (module_type)\n        {\n          case MagickImageCoderModule:\n          default:\n          {\n            directory=MAGICKCORE_CODER_RELATIVE_PATH;\n            break;\n          }\n          case MagickImageFilterModule:\n          {\n            directory=MAGICKCORE_FILTER_RELATIVE_PATH;\n            break;\n          }\n        }\n        (void) FormatLocaleString(path,MaxTextExtent,\"%s/lib/%s/%s\",home,\n          directory,filename);\n#endif\n        home=DestroyString(home);\n        if (IsPathAccessible(path) != MagickFalse)\n          return(MagickTrue);\n      }\n  }\n  if (*GetClientPath() != '\\0')\n    {\n      /*\n        Search based on executable directory.\n      */\n#if !defined(MAGICKCORE_POSIX_SUPPORT)\n      (void) FormatLocaleString(path,MaxTextExtent,\"%s%s%s\",GetClientPath(),\n        DirectorySeparator,filename);\n#else\n      char\n        prefix[MaxTextExtent];\n\n      const char\n        *directory;\n\n      switch (module_type)\n      {\n        case MagickImageCoderModule:\n        default:\n        {\n          directory=\"coders\";\n          break;\n        }\n        case MagickImageFilterModule:\n        {\n          directory=\"filters\";\n          break;\n        }\n      }\n      (void) CopyMagickString(prefix,GetClientPath(),MaxTextExtent);\n      ChopPathComponents(prefix,1);\n      (void) FormatLocaleString(path,MaxTextExtent,\"%s/lib/%s/%s/%s\",prefix,\n        MAGICKCORE_MODULES_RELATIVE_PATH,directory,filename);\n#endif\n      if (IsPathAccessible(path) != MagickFalse)\n        return(MagickTrue);\n    }\n#if defined(MAGICKCORE_WINDOWS_SUPPORT)\n  {\n    /*\n      Search module path.\n    */\n    if ((NTGetModulePath(\"CORE_RL_magick_.dll\",path) != MagickFalse) ||\n        (NTGetModulePath(\"CORE_DB_magick_.dll\",path) != MagickFalse) ||\n        (NTGetModulePath(\"Magick.dll\",path) != MagickFalse))\n      {\n        (void) ConcatenateMagickString(path,DirectorySeparator,MaxTextExtent);\n        (void) ConcatenateMagickString(path,filename,MaxTextExtent);\n        if (IsPathAccessible(path) != MagickFalse)\n          return(MagickTrue);\n      }\n  }\n#endif\n  {\n    char\n      *home;\n\n    home=GetEnvironmentValue(\"XDG_CONFIG_HOME\");\n    if (home == (char *) NULL)\n      home=GetEnvironmentValue(\"LOCALAPPDATA\");\n    if (home == (char *) NULL)\n      home=GetEnvironmentValue(\"APPDATA\");\n    if (home == (char *) NULL)\n      home=GetEnvironmentValue(\"USERPROFILE\");\n    if (home != (char *) NULL)\n      {\n        /*\n          Search $XDG_CONFIG_HOME/ImageMagick.\n        */\n        (void) FormatLocaleString(path,MaxTextExtent,\"%s%sImageMagick%s%s\",\n          home,DirectorySeparator,DirectorySeparator,filename);\n        home=DestroyString(home);\n        if (IsPathAccessible(path) != MagickFalse)\n          return(MagickTrue);\n      }\n    home=GetEnvironmentValue(\"HOME\");\n    if (home != (char *) NULL)\n      {\n        /*\n          Search $HOME/.config/ImageMagick.\n        */\n        (void) FormatLocaleString(path,MaxTextExtent,\n          \"%s%s.config%sImageMagick%s%s\",home,DirectorySeparator,\n          DirectorySeparator,DirectorySeparator,filename);\n        if (IsPathAccessible(path) != MagickFalse)\n          {\n            home=DestroyString(home);\n            return(MagickTrue);\n          }\n        /*\n          Search $HOME/.magick.\n        */\n        (void) FormatLocaleString(path,MaxTextExtent,\"%s%s.magick%s%s\",home,\n          DirectorySeparator,DirectorySeparator,filename);\n        home=DestroyString(home);\n        if (IsPathAccessible(path) != MagickFalse)\n          return(MagickTrue);\n      }\n  }\n  /*\n    Search current directory.\n  */\n  if (IsPathAccessible(path) != MagickFalse)\n    return(MagickTrue);\n  if (exception->severity < ConfigureError)\n    ThrowFileException(exception,ConfigureWarning,\"UnableToOpenModuleFile\",\n      path);\n#endif\n  return(MagickFalse);\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 150321,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "user_change_icon_file_authorized_cb (Daemon                *daemon,\n                                     User                  *user,\n                                     GDBusMethodInvocation *context,\n                                     gpointer               data)\n\n{\n        g_autofree gchar *filename = NULL;\n        g_autoptr(GFile) file = NULL;\n        g_autoptr(GFileInfo) info = NULL;\n        guint32 mode;\n        GFileType type;\n        guint64 size;\n\n        filename = g_strdup (data);\n\n        if (filename == NULL ||\n            *filename == '\\0') {\n                g_autofree gchar *dest_path = NULL;\n                g_autoptr(GFile) dest = NULL;\n                g_autoptr(GError) error = NULL;\n\n                g_clear_pointer (&filename, g_free);\n\n                dest_path = g_build_filename (ICONDIR, accounts_user_get_user_name (ACCOUNTS_USER (user)), NULL);\n                dest = g_file_new_for_path (dest_path);\n\n                if (!g_file_delete (dest, NULL, &error) &&\n                    !g_error_matches (error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {\n                        throw_error (context, ERROR_FAILED, \"failed to remove user icon, %s\", error->message);\n                        return;\n                }\n                goto icon_saved;\n         }\n \n         file = g_file_new_for_path (filename);\n         info = g_file_query_info (file, G_FILE_ATTRIBUTE_UNIX_MODE \",\"\n                                         G_FILE_ATTRIBUTE_STANDARD_TYPE \",\"\n                                         G_FILE_ATTRIBUTE_STANDARD_SIZE,\n                return;\n        }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141427,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "user_change_icon_file_authorized_cb (Daemon                *daemon,\n                                     User                  *user,\n                                     GDBusMethodInvocation *context,\n                                     gpointer               data)\n\n{\n        g_autofree gchar *filename = NULL;\n        g_autoptr(GFile) file = NULL;\n        g_autoptr(GFileInfo) info = NULL;\n        guint32 mode;\n        GFileType type;\n        guint64 size;\n\n        filename = g_strdup (data);\n\n        if (filename == NULL ||\n            *filename == '\\0') {\n                g_autofree gchar *dest_path = NULL;\n                g_autoptr(GFile) dest = NULL;\n                g_autoptr(GError) error = NULL;\n\n                g_clear_pointer (&filename, g_free);\n\n                dest_path = g_build_filename (ICONDIR, accounts_user_get_user_name (ACCOUNTS_USER (user)), NULL);\n                dest = g_file_new_for_path (dest_path);\n\n                if (!g_file_delete (dest, NULL, &error) &&\n                    !g_error_matches (error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {\n                        throw_error (context, ERROR_FAILED, \"failed to remove user icon, %s\", error->message);\n                        return;\n                }\n                goto icon_saved;\n         }\n \n         file = g_file_new_for_path (filename);\n        g_clear_pointer (&filename, g_free);\n\n        /* Canonicalize path so we can call g_str_has_prefix on it\n         * below without concern for ../ path components moving outside\n         * the prefix\n         */\n        filename = g_file_get_path (file);\n\n         info = g_file_query_info (file, G_FILE_ATTRIBUTE_UNIX_MODE \",\"\n                                         G_FILE_ATTRIBUTE_STANDARD_TYPE \",\"\n                                         G_FILE_ATTRIBUTE_STANDARD_SIZE,\n                return;\n        }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141428,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": " create_response(const char *nurl, const char *method, unsigned int *rp_code)\n {\n       char *page, *fpath;\n        struct MHD_Response *resp = NULL;\n \n        if (!strncmp(nurl, URL_BASE_API_1_1, strlen(URL_BASE_API_1_1))) {\n                resp = create_response_api(nurl, method, rp_code);\n        } else {\n                fpath = get_path(nurl, server_data.www_dir);\n \n               resp = create_response_file(nurl, method, rp_code, fpath);\n \n                free(fpath);\n        }\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141663,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": " create_response(const char *nurl, const char *method, unsigned int *rp_code)\n {\n       char *page, *fpath, *rpath;\n        struct MHD_Response *resp = NULL;\n       int n;\n \n        if (!strncmp(nurl, URL_BASE_API_1_1, strlen(URL_BASE_API_1_1))) {\n                resp = create_response_api(nurl, method, rp_code);\n        } else {\n                fpath = get_path(nurl, server_data.www_dir);\n \n               rpath = realpath(fpath, NULL);\n               if (rpath) {\n                       n = strlen(server_data.www_dir);\n                       if (!strncmp(server_data.www_dir, rpath, n))\n                               resp = create_response_file(nurl,\n                                                           method,\n                                                           rp_code,\n                                                           fpath);\n                       free(rpath);\n               }\n \n                free(fpath);\n        }\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141664,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "set_interface_var(const char *iface,\n\t\t  const char *var, const char *name,\n\t\t  uint32_t val)\n{\n\tFILE *fp;\n\tchar spath[64+IFNAMSIZ];\t/* XXX: magic constant */\n \tif (snprintf(spath, sizeof(spath), var, iface) >= sizeof(spath))\n \t\treturn -1;\n \n \tif (access(spath, F_OK) != 0)\n \t\treturn -1;\n \n\tfp = fopen(spath, \"w\");\n\tif (!fp) {\n\t\tif (name)\n\t\t\tflog(LOG_ERR, \"failed to set %s (%u) for %s: %s\",\n\t\t\t     name, val, iface, strerror(errno));\n\t\treturn -1;\n\t}\n\tfprintf(fp, \"%u\", val);\n\tfclose(fp);\n\n\treturn 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141949,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "set_interface_var(const char *iface,\n\t\t  const char *var, const char *name,\n\t\t  uint32_t val)\n{\n\tFILE *fp;\n\tchar spath[64+IFNAMSIZ];\t/* XXX: magic constant */\n \tif (snprintf(spath, sizeof(spath), var, iface) >= sizeof(spath))\n \t\treturn -1;\n \n\t/* No path traversal */\n\tif (strstr(name, \"..\") || strchr(name, '/'))\n\t\treturn -1;\n\n \tif (access(spath, F_OK) != 0)\n \t\treturn -1;\n \n\tfp = fopen(spath, \"w\");\n\tif (!fp) {\n\t\tif (name)\n\t\t\tflog(LOG_ERR, \"failed to set %s (%u) for %s: %s\",\n\t\t\t     name, val, iface, strerror(errno));\n\t\treturn -1;\n\t}\n\tfprintf(fp, \"%u\", val);\n\tfclose(fp);\n\n\treturn 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141950,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "MagickExport XMLTreeInfo *NewXMLTree(const char *xml,ExceptionInfo *exception)\n{\n  char\n    **attribute,\n    **attributes,\n    *tag,\n    *utf8;\n\n  int\n    c,\n    terminal;\n\n  MagickBooleanType\n    status;\n\n  register char\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    ignore_depth,\n    length;\n\n  ssize_t\n    j,\n    l;\n\n  XMLTreeRoot\n    *root;\n\n  /*\n    Convert xml-string to UTF8.\n  */\n  if ((xml == (const char *) NULL) || (strlen(xml) == 0))\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n        \"ParseError\",\"root tag missing\");\n      return((XMLTreeInfo *) NULL);\n    }\n  root=(XMLTreeRoot *) NewXMLTreeTag((char *) NULL);\n  length=strlen(xml);\n  utf8=ConvertUTF16ToUTF8(xml,&length);\n  if (utf8 == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n        \"ParseError\",\"UTF16 to UTF8 failed\");\n      return((XMLTreeInfo *) NULL);\n    }\n  terminal=utf8[length-1];\n  utf8[length-1]='\\0';\n  p=utf8;\n  while ((*p != '\\0') && (*p != '<'))\n    p++;\n  if (*p == '\\0')\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n        \"ParseError\",\"root tag missing\");\n      utf8=DestroyString(utf8);\n      return((XMLTreeInfo *) NULL);\n    }\n  attribute=(char **) NULL;\n  l=0;\n  ignore_depth=0;\n  for (p++; ; p++)\n  {\n    attributes=(char **) sentinel;\n    tag=p;\n    c=(*p);\n    if ((isalpha((int) ((unsigned char) *p)) !=0) || (*p == '_') ||\n        (*p == ':') || (c < '\\0'))\n      {\n        /*\n          Tag.\n        */\n        if (root->node == (XMLTreeInfo *) NULL)\n          {\n            (void) ThrowMagickException(exception,GetMagickModule(),\n              OptionWarning,\"ParseError\",\"root tag missing\");\n            utf8=DestroyString(utf8);\n            return(&root->root);\n          }\n        p+=strcspn(p,XMLWhitespace \"/>\");\n        while (isspace((int) ((unsigned char) *p)) != 0)\n          *p++='\\0';\n        if (ignore_depth == 0)\n          {\n            if ((*p != '\\0') && (*p != '/') && (*p != '>'))\n              {\n                /*\n                  Find tag in default attributes list.\n                */\n                i=0;\n                while ((root->attributes[i] != (char **) NULL) &&\n                       (strcmp(root->attributes[i][0],tag) != 0))\n                  i++;\n                attribute=root->attributes[i];\n              }\n            for (l=0; (*p != '\\0') && (*p != '/') && (*p != '>'); l+=2)\n            {\n              /*\n                Attribute.\n              */\n              if (l == 0)\n                attributes=(char **) AcquireQuantumMemory(4,\n                  sizeof(*attributes));\n              else\n                attributes=(char **) ResizeQuantumMemory(attributes,\n                  (size_t) (l+4),sizeof(*attributes));\n              if (attributes == (char **) NULL)\n                {\n                  (void) ThrowMagickException(exception,GetMagickModule(),\n                    ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n                  utf8=DestroyString(utf8);\n                  return(&root->root);\n                }\n              attributes[l+2]=(char *) NULL;\n              attributes[l+1]=(char *) NULL;\n              attributes[l]=p;\n              p+=strcspn(p,XMLWhitespace \"=/>\");\n              if ((*p != '=') && (isspace((int) ((unsigned char) *p)) == 0))\n                attributes[l]=ConstantString(\"\");\n              else\n                {\n                  *p++='\\0';\n                  p+=strspn(p,XMLWhitespace \"=\");\n                  c=(*p);\n                  if ((c == '\"') || (c == '\\''))\n                    {\n                      /*\n                        Attributes value.\n                      */\n                      p++;\n                      attributes[l+1]=p;\n                      while ((*p != '\\0') && (*p != c))\n                        p++;\n                      if (*p != '\\0')\n                        *p++='\\0';\n                      else\n                        {\n                          attributes[l]=ConstantString(\"\");\n                          attributes[l+1]=ConstantString(\"\");\n                          (void) DestroyXMLTreeAttributes(attributes);\n                          (void) ThrowMagickException(exception,\n                            GetMagickModule(),OptionWarning,\"ParseError\",\n                            \"missing %c\",c);\n                          utf8=DestroyString(utf8);\n                          return(&root->root);\n                        }\n                      j=1;\n                      while ((attribute != (char **) NULL) &&\n                             (attribute[j] != (char *) NULL) &&\n                             (strcmp(attribute[j],attributes[l]) != 0))\n                        j+=3;\n                      attributes[l+1]=ParseEntities(attributes[l+1],\n                        root->entities,(attribute != (char **) NULL) &&\n                        (attribute[j] != (char *) NULL) ? *attribute[j+2] :\n                        ' ');\n                    }\n                  attributes[l]=ConstantString(attributes[l]);\n                }\n              while (isspace((int) ((unsigned char) *p)) != 0)\n                p++;\n            }\n          }\n        else\n          {\n            while((*p != '\\0') && (*p != '/') && (*p != '>'))\n              p++;\n          }\n        if (*p == '/')\n          {\n            /*\n              Self closing tag.\n            */\n            *p++='\\0';\n            if (((*p != '\\0') && (*p != '>')) ||\n                ((*p == '\\0') && (terminal != '>')))\n              {\n                if (l != 0)\n                  (void) DestroyXMLTreeAttributes(attributes);\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  OptionWarning,\"ParseError\",\"missing >\");\n                utf8=DestroyString(utf8);\n                return(&root->root);\n              }\n            if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))\n              {\n                ParseOpenTag(root,tag,attributes);\n                (void) ParseCloseTag(root,tag,exception);\n              }\n          }\n        else\n          {\n            c=(*p);\n            if ((*p == '>') || ((*p == '\\0') && (terminal == '>')))\n              {\n                *p='\\0';\n                 if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))\n                   ParseOpenTag(root,tag,attributes);\n                 else\n                  ignore_depth++;\n                 *p=c;\n               }\n             else\n              {\n                if (l != 0)\n                  (void) DestroyXMLTreeAttributes(attributes);\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  OptionWarning,\"ParseError\",\"missing >\");\n                utf8=DestroyString(utf8);\n                return(&root->root);\n              }\n          }\n      }\n    else\n      if (*p == '/')\n        {\n          /*\n            Close tag.\n          */\n          tag=p+1;\n          p+=strcspn(tag,XMLWhitespace \">\")+1;\n          c=(*p);\n          if ((c == '\\0') && (terminal != '>'))\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                OptionWarning,\"ParseError\",\"missing >\");\n              utf8=DestroyString(utf8);\n              return(&root->root);\n            }\n          *p='\\0';\n          if (ignore_depth == 0 && ParseCloseTag(root,tag,exception) !=\n              (XMLTreeInfo *) NULL)\n            {\n              utf8=DestroyString(utf8);\n              return(&root->root);\n            }\n          if (ignore_depth > 0)\n            ignore_depth--;\n          *p=c;\n          if (isspace((int) ((unsigned char) *p)) != 0)\n            p+=strspn(p,XMLWhitespace);\n        }\n      else\n        if (strncmp(p,\"!--\",3) == 0)\n          {\n            /*\n              Comment.\n            */\n            p=strstr(p+3,\"--\");\n            if ((p == (char *) NULL) || ((*(p+=2) != '>') && (*p != '\\0')) ||\n                ((*p == '\\0') && (terminal != '>')))\n              {\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  OptionWarning,\"ParseError\",\"unclosed <!--\");\n                utf8=DestroyString(utf8);\n                return(&root->root);\n              }\n          }\n        else\n          if (strncmp(p,\"![CDATA[\",8) == 0)\n            {\n              /*\n                Cdata.\n              */\n              p=strstr(p,\"]]>\");\n              if (p != (char *) NULL)\n                {\n                  p+=2;\n                  if (ignore_depth == 0)\n                    ParseCharacterContent(root,tag+8,(size_t) (p-tag-10),'c');\n                }\n              else\n                {\n                  (void) ThrowMagickException(exception,GetMagickModule(),\n                    OptionWarning,\"ParseError\",\"unclosed <![CDATA[\");\n                  utf8=DestroyString(utf8);\n                  return(&root->root);\n                }\n            }\n          else\n            if (strncmp(p,\"!DOCTYPE\",8) == 0)\n              {\n                /*\n                  DTD.\n                */\n                for (l=0; (*p != '\\0') && (((l == 0) && (*p != '>')) ||\n                     ((l != 0) && ((*p != ']') ||\n                     (*(p+strspn(p+1,XMLWhitespace)+1) != '>'))));\n                  l=(ssize_t) ((*p == '[') ? 1 : l))\n                p+=strcspn(p+1,\"[]>\")+1;\n                if ((*p == '\\0') && (terminal != '>'))\n                  {\n                    (void) ThrowMagickException(exception,GetMagickModule(),\n                      OptionWarning,\"ParseError\",\"unclosed <!DOCTYPE\");\n                    utf8=DestroyString(utf8);\n                    return(&root->root);\n                  }\n                if (l != 0)\n                  tag=strchr(tag,'[')+1;\n                if (l != 0)\n                  {\n                    status=ParseInternalDoctype(root,tag,(size_t) (p-tag),\n                      exception);\n                    if (status == MagickFalse)\n                      {\n                        utf8=DestroyString(utf8);\n                        return(&root->root);\n                      }\n                    p++;\n                  }\n              }\n            else\n              if (*p == '?')\n                {\n                  /*\n                    Processing instructions.\n                  */\n                  do\n                  {\n                    p=strchr(p,'?');\n                    if (p == (char *) NULL)\n                      break;\n                    p++;\n                  } while ((*p != '\\0') && (*p != '>'));\n                  if ((p == (char *) NULL) || ((*p == '\\0') &&\n                      (terminal != '>')))\n                    {\n                      (void) ThrowMagickException(exception,GetMagickModule(),\n                        OptionWarning,\"ParseError\",\"unclosed <?\");\n                      utf8=DestroyString(utf8);\n                      return(&root->root);\n                    }\n                  ParseProcessingInstructions(root,tag+1,(size_t) (p-tag-2));\n                }\n              else\n                {\n                  (void) ThrowMagickException(exception,GetMagickModule(),\n                    OptionWarning,\"ParseError\",\"unexpected <\");\n                  utf8=DestroyString(utf8);\n                  return(&root->root);\n                }\n     if ((p == (char *) NULL) || (*p == '\\0'))\n       break;\n     *p++='\\0';\n     tag=p;\n     if ((*p != '\\0') && (*p != '<'))\n       {\n        /*\n          Tag character content.\n        */\n        while ((*p != '\\0') && (*p != '<'))\n          p++;\n        if (*p == '\\0')\n          break;\n        if (ignore_depth == 0)\n          ParseCharacterContent(root,tag,(size_t) (p-tag),'&');\n      }\n    else\n      if (*p == '\\0')\n        break;\n  }\n  utf8=DestroyString(utf8);\n  if (root->node == (XMLTreeInfo *) NULL)\n    return(&root->root);\n  if (root->node->tag == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n        \"ParseError\",\"root tag missing\");\n      return(&root->root);\n    }\n  (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n    \"ParseError\",\"unclosed tag: `%s'\",root->node->tag);\n  return(&root->root);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142751,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "MagickExport XMLTreeInfo *NewXMLTree(const char *xml,ExceptionInfo *exception)\n{\n  char\n    **attribute,\n    **attributes,\n    *tag,\n    *utf8;\n\n  int\n    c,\n    terminal;\n\n  MagickBooleanType\n    status;\n\n  register char\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    ignore_depth,\n    length;\n\n  ssize_t\n    j,\n    l;\n\n  XMLTreeRoot\n    *root;\n\n  /*\n    Convert xml-string to UTF8.\n  */\n  if ((xml == (const char *) NULL) || (strlen(xml) == 0))\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n        \"ParseError\",\"root tag missing\");\n      return((XMLTreeInfo *) NULL);\n    }\n  root=(XMLTreeRoot *) NewXMLTreeTag((char *) NULL);\n  length=strlen(xml);\n  utf8=ConvertUTF16ToUTF8(xml,&length);\n  if (utf8 == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n        \"ParseError\",\"UTF16 to UTF8 failed\");\n      return((XMLTreeInfo *) NULL);\n    }\n  terminal=utf8[length-1];\n  utf8[length-1]='\\0';\n  p=utf8;\n  while ((*p != '\\0') && (*p != '<'))\n    p++;\n  if (*p == '\\0')\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n        \"ParseError\",\"root tag missing\");\n      utf8=DestroyString(utf8);\n      return((XMLTreeInfo *) NULL);\n    }\n  attribute=(char **) NULL;\n  l=0;\n  ignore_depth=0;\n  for (p++; ; p++)\n  {\n    attributes=(char **) sentinel;\n    tag=p;\n    c=(*p);\n    if ((isalpha((int) ((unsigned char) *p)) !=0) || (*p == '_') ||\n        (*p == ':') || (c < '\\0'))\n      {\n        /*\n          Tag.\n        */\n        if (root->node == (XMLTreeInfo *) NULL)\n          {\n            (void) ThrowMagickException(exception,GetMagickModule(),\n              OptionWarning,\"ParseError\",\"root tag missing\");\n            utf8=DestroyString(utf8);\n            return(&root->root);\n          }\n        p+=strcspn(p,XMLWhitespace \"/>\");\n        while (isspace((int) ((unsigned char) *p)) != 0)\n          *p++='\\0';\n        if (ignore_depth == 0)\n          {\n            if ((*p != '\\0') && (*p != '/') && (*p != '>'))\n              {\n                /*\n                  Find tag in default attributes list.\n                */\n                i=0;\n                while ((root->attributes[i] != (char **) NULL) &&\n                       (strcmp(root->attributes[i][0],tag) != 0))\n                  i++;\n                attribute=root->attributes[i];\n              }\n            for (l=0; (*p != '\\0') && (*p != '/') && (*p != '>'); l+=2)\n            {\n              /*\n                Attribute.\n              */\n              if (l == 0)\n                attributes=(char **) AcquireQuantumMemory(4,\n                  sizeof(*attributes));\n              else\n                attributes=(char **) ResizeQuantumMemory(attributes,\n                  (size_t) (l+4),sizeof(*attributes));\n              if (attributes == (char **) NULL)\n                {\n                  (void) ThrowMagickException(exception,GetMagickModule(),\n                    ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n                  utf8=DestroyString(utf8);\n                  return(&root->root);\n                }\n              attributes[l+2]=(char *) NULL;\n              attributes[l+1]=(char *) NULL;\n              attributes[l]=p;\n              p+=strcspn(p,XMLWhitespace \"=/>\");\n              if ((*p != '=') && (isspace((int) ((unsigned char) *p)) == 0))\n                attributes[l]=ConstantString(\"\");\n              else\n                {\n                  *p++='\\0';\n                  p+=strspn(p,XMLWhitespace \"=\");\n                  c=(*p);\n                  if ((c == '\"') || (c == '\\''))\n                    {\n                      /*\n                        Attributes value.\n                      */\n                      p++;\n                      attributes[l+1]=p;\n                      while ((*p != '\\0') && (*p != c))\n                        p++;\n                      if (*p != '\\0')\n                        *p++='\\0';\n                      else\n                        {\n                          attributes[l]=ConstantString(\"\");\n                          attributes[l+1]=ConstantString(\"\");\n                          (void) DestroyXMLTreeAttributes(attributes);\n                          (void) ThrowMagickException(exception,\n                            GetMagickModule(),OptionWarning,\"ParseError\",\n                            \"missing %c\",c);\n                          utf8=DestroyString(utf8);\n                          return(&root->root);\n                        }\n                      j=1;\n                      while ((attribute != (char **) NULL) &&\n                             (attribute[j] != (char *) NULL) &&\n                             (strcmp(attribute[j],attributes[l]) != 0))\n                        j+=3;\n                      attributes[l+1]=ParseEntities(attributes[l+1],\n                        root->entities,(attribute != (char **) NULL) &&\n                        (attribute[j] != (char *) NULL) ? *attribute[j+2] :\n                        ' ');\n                    }\n                  attributes[l]=ConstantString(attributes[l]);\n                }\n              while (isspace((int) ((unsigned char) *p)) != 0)\n                p++;\n            }\n          }\n        else\n          {\n            while((*p != '\\0') && (*p != '/') && (*p != '>'))\n              p++;\n          }\n        if (*p == '/')\n          {\n            /*\n              Self closing tag.\n            */\n            *p++='\\0';\n            if (((*p != '\\0') && (*p != '>')) ||\n                ((*p == '\\0') && (terminal != '>')))\n              {\n                if (l != 0)\n                  (void) DestroyXMLTreeAttributes(attributes);\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  OptionWarning,\"ParseError\",\"missing >\");\n                utf8=DestroyString(utf8);\n                return(&root->root);\n              }\n            if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))\n              {\n                ParseOpenTag(root,tag,attributes);\n                (void) ParseCloseTag(root,tag,exception);\n              }\n          }\n        else\n          {\n            c=(*p);\n            if ((*p == '>') || ((*p == '\\0') && (terminal == '>')))\n              {\n                *p='\\0';\n                 if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))\n                   ParseOpenTag(root,tag,attributes);\n                 else\n                  {\n                    ignore_depth++;\n                    (void) DestroyXMLTreeAttributes(attributes);\n                  }\n                 *p=c;\n               }\n             else\n              {\n                if (l != 0)\n                  (void) DestroyXMLTreeAttributes(attributes);\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  OptionWarning,\"ParseError\",\"missing >\");\n                utf8=DestroyString(utf8);\n                return(&root->root);\n              }\n          }\n      }\n    else\n      if (*p == '/')\n        {\n          /*\n            Close tag.\n          */\n          tag=p+1;\n          p+=strcspn(tag,XMLWhitespace \">\")+1;\n          c=(*p);\n          if ((c == '\\0') && (terminal != '>'))\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                OptionWarning,\"ParseError\",\"missing >\");\n              utf8=DestroyString(utf8);\n              return(&root->root);\n            }\n          *p='\\0';\n          if (ignore_depth == 0 && ParseCloseTag(root,tag,exception) !=\n              (XMLTreeInfo *) NULL)\n            {\n              utf8=DestroyString(utf8);\n              return(&root->root);\n            }\n          if (ignore_depth > 0)\n            ignore_depth--;\n          *p=c;\n          if (isspace((int) ((unsigned char) *p)) != 0)\n            p+=strspn(p,XMLWhitespace);\n        }\n      else\n        if (strncmp(p,\"!--\",3) == 0)\n          {\n            /*\n              Comment.\n            */\n            p=strstr(p+3,\"--\");\n            if ((p == (char *) NULL) || ((*(p+=2) != '>') && (*p != '\\0')) ||\n                ((*p == '\\0') && (terminal != '>')))\n              {\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  OptionWarning,\"ParseError\",\"unclosed <!--\");\n                utf8=DestroyString(utf8);\n                return(&root->root);\n              }\n          }\n        else\n          if (strncmp(p,\"![CDATA[\",8) == 0)\n            {\n              /*\n                Cdata.\n              */\n              p=strstr(p,\"]]>\");\n              if (p != (char *) NULL)\n                {\n                  p+=2;\n                  if (ignore_depth == 0)\n                    ParseCharacterContent(root,tag+8,(size_t) (p-tag-10),'c');\n                }\n              else\n                {\n                  (void) ThrowMagickException(exception,GetMagickModule(),\n                    OptionWarning,\"ParseError\",\"unclosed <![CDATA[\");\n                  utf8=DestroyString(utf8);\n                  return(&root->root);\n                }\n            }\n          else\n            if (strncmp(p,\"!DOCTYPE\",8) == 0)\n              {\n                /*\n                  DTD.\n                */\n                for (l=0; (*p != '\\0') && (((l == 0) && (*p != '>')) ||\n                     ((l != 0) && ((*p != ']') ||\n                     (*(p+strspn(p+1,XMLWhitespace)+1) != '>'))));\n                  l=(ssize_t) ((*p == '[') ? 1 : l))\n                p+=strcspn(p+1,\"[]>\")+1;\n                if ((*p == '\\0') && (terminal != '>'))\n                  {\n                    (void) ThrowMagickException(exception,GetMagickModule(),\n                      OptionWarning,\"ParseError\",\"unclosed <!DOCTYPE\");\n                    utf8=DestroyString(utf8);\n                    return(&root->root);\n                  }\n                if (l != 0)\n                  tag=strchr(tag,'[')+1;\n                if (l != 0)\n                  {\n                    status=ParseInternalDoctype(root,tag,(size_t) (p-tag),\n                      exception);\n                    if (status == MagickFalse)\n                      {\n                        utf8=DestroyString(utf8);\n                        return(&root->root);\n                      }\n                    p++;\n                  }\n              }\n            else\n              if (*p == '?')\n                {\n                  /*\n                    Processing instructions.\n                  */\n                  do\n                  {\n                    p=strchr(p,'?');\n                    if (p == (char *) NULL)\n                      break;\n                    p++;\n                  } while ((*p != '\\0') && (*p != '>'));\n                  if ((p == (char *) NULL) || ((*p == '\\0') &&\n                      (terminal != '>')))\n                    {\n                      (void) ThrowMagickException(exception,GetMagickModule(),\n                        OptionWarning,\"ParseError\",\"unclosed <?\");\n                      utf8=DestroyString(utf8);\n                      return(&root->root);\n                    }\n                  ParseProcessingInstructions(root,tag+1,(size_t) (p-tag-2));\n                }\n              else\n                {\n                  (void) ThrowMagickException(exception,GetMagickModule(),\n                    OptionWarning,\"ParseError\",\"unexpected <\");\n                  utf8=DestroyString(utf8);\n                  return(&root->root);\n                }\n     if ((p == (char *) NULL) || (*p == '\\0'))\n       break;\n     *p++='\\0';\n     tag=p;\n     if ((*p != '\\0') && (*p != '<'))\n       {\n        /*\n          Tag character content.\n        */\n        while ((*p != '\\0') && (*p != '<'))\n          p++;\n        if (*p == '\\0')\n          break;\n        if (ignore_depth == 0)\n          ParseCharacterContent(root,tag,(size_t) (p-tag),'&');\n      }\n    else\n      if (*p == '\\0')\n        break;\n  }\n  utf8=DestroyString(utf8);\n  if (root->node == (XMLTreeInfo *) NULL)\n    return(&root->root);\n  if (root->node->tag == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n        \"ParseError\",\"root tag missing\");\n      return(&root->root);\n    }\n  (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n    \"ParseError\",\"unclosed tag: `%s'\",root->node->tag);\n  return(&root->root);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142752,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "PHYSICALPATH_FUNC(mod_alias_physical_handler) {\n\tplugin_data *p = p_d;\n\tint uri_len, basedir_len;\n\tchar *uri_ptr;\n\tsize_t k;\n\n\tif (buffer_is_empty(con->physical.path)) return HANDLER_GO_ON;\n\n\tmod_alias_patch_connection(srv, con, p);\n\n\t/* not to include the tailing slash */\n\tbasedir_len = buffer_string_length(con->physical.basedir);\n\tif ('/' == con->physical.basedir->ptr[basedir_len-1]) --basedir_len;\n\turi_len = buffer_string_length(con->physical.path) - basedir_len;\n\turi_ptr = con->physical.path->ptr + basedir_len;\n\n\tfor (k = 0; k < p->conf.alias->used; k++) {\n\t\tdata_string *ds = (data_string *)p->conf.alias->data[k];\n\t\tint alias_len = buffer_string_length(ds->key);\n\n\t\tif (alias_len > uri_len) continue;\n\t\tif (buffer_is_empty(ds->key)) continue;\n\n\t\tif (0 == (con->conf.force_lowercase_filenames ?\n\t\t\t\t\tstrncasecmp(uri_ptr, ds->key->ptr, alias_len) :\n \t\t\t\t\tstrncmp(uri_ptr, ds->key->ptr, alias_len))) {\n \t\t\t/* matched */\n \n \t\t\tbuffer_copy_buffer(con->physical.basedir, ds->value);\n \t\t\tbuffer_copy_buffer(srv->tmp_buf, ds->value);\n \t\t\tbuffer_append_string(srv->tmp_buf, uri_ptr + alias_len);\n\t\t\tbuffer_copy_buffer(con->physical.path, srv->tmp_buf);\n\n\t\t\treturn HANDLER_GO_ON;\n\t\t}\n\t}\n\n\t/* not found */\n\treturn HANDLER_GO_ON;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142879,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "PHYSICALPATH_FUNC(mod_alias_physical_handler) {\n\tplugin_data *p = p_d;\n\tint uri_len, basedir_len;\n\tchar *uri_ptr;\n\tsize_t k;\n\n\tif (buffer_is_empty(con->physical.path)) return HANDLER_GO_ON;\n\n\tmod_alias_patch_connection(srv, con, p);\n\n\t/* not to include the tailing slash */\n\tbasedir_len = buffer_string_length(con->physical.basedir);\n\tif ('/' == con->physical.basedir->ptr[basedir_len-1]) --basedir_len;\n\turi_len = buffer_string_length(con->physical.path) - basedir_len;\n\turi_ptr = con->physical.path->ptr + basedir_len;\n\n\tfor (k = 0; k < p->conf.alias->used; k++) {\n\t\tdata_string *ds = (data_string *)p->conf.alias->data[k];\n\t\tint alias_len = buffer_string_length(ds->key);\n\n\t\tif (alias_len > uri_len) continue;\n\t\tif (buffer_is_empty(ds->key)) continue;\n\n\t\tif (0 == (con->conf.force_lowercase_filenames ?\n\t\t\t\t\tstrncasecmp(uri_ptr, ds->key->ptr, alias_len) :\n \t\t\t\t\tstrncmp(uri_ptr, ds->key->ptr, alias_len))) {\n \t\t\t/* matched */\n \n\t\t\t/* check for path traversal in url-path following alias if key\n\t\t\t * does not end in slash, but replacement value ends in slash */\n\t\t\tif (uri_ptr[alias_len] == '.') {\n\t\t\t\tchar *s = uri_ptr + alias_len + 1;\n\t\t\t\tif (*s == '.') ++s;\n\t\t\t\tif (*s == '/' || *s == '\\0') {\n\t\t\t\t\tsize_t vlen = buffer_string_length(ds->value);\n\t\t\t\t\tif (0 != alias_len && ds->key->ptr[alias_len-1] != '/'\n\t\t\t\t\t    && 0 != vlen && ds->value->ptr[vlen-1] == '/') {\n\t\t\t\t\t\tcon->http_status = 403;\n\t\t\t\t\t\treturn HANDLER_FINISHED;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n \t\t\tbuffer_copy_buffer(con->physical.basedir, ds->value);\n \t\t\tbuffer_copy_buffer(srv->tmp_buf, ds->value);\n \t\t\tbuffer_append_string(srv->tmp_buf, uri_ptr + alias_len);\n\t\t\tbuffer_copy_buffer(con->physical.path, srv->tmp_buf);\n\n\t\t\treturn HANDLER_GO_ON;\n\t\t}\n\t}\n\n\t/* not found */\n\treturn HANDLER_GO_ON;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142880,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": " static int nntp_hcache_namer(const char *path, char *dest, size_t destlen)\n {\n  return snprintf(dest, destlen, \"%s.hcache\", path);\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142963,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "static int pop_hcache_namer(const char *path, char *dest, size_t destlen)\n{\n  return snprintf(dest, destlen, \"%s.\" HC_FEXT, path);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142964,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "void DateTimeChooserImpl::writeDocument(SharedBuffer* data)\n{\n    String stepString = String::number(m_parameters.step);\n    String stepBaseString = String::number(m_parameters.stepBase, 11, WTF::TruncateTrailingZeros);\n    IntRect anchorRectInScreen = m_chromeClient->rootViewToScreen(m_parameters.anchorRectInRootView);\n    String todayLabelString;\n    String otherDateLabelString;\n    if (m_parameters.type == InputTypeNames::month) {\n        todayLabelString = locale().queryString(WebLocalizedString::ThisMonthButtonLabel);\n        otherDateLabelString = locale().queryString(WebLocalizedString::OtherMonthLabel);\n    } else if (m_parameters.type == InputTypeNames::week) {\n        todayLabelString = locale().queryString(WebLocalizedString::ThisWeekButtonLabel);\n        otherDateLabelString = locale().queryString(WebLocalizedString::OtherWeekLabel);\n    } else {\n        todayLabelString = locale().queryString(WebLocalizedString::CalendarToday);\n        otherDateLabelString = locale().queryString(WebLocalizedString::OtherDateLabel);\n    }\n\n    addString(\"<!DOCTYPE html><head><meta charset='UTF-8'><style>\\n\", data);\n    data->append(Platform::current()->loadResource(\"pickerCommon.css\"));\n    data->append(Platform::current()->loadResource(\"pickerButton.css\"));\n    data->append(Platform::current()->loadResource(\"suggestionPicker.css\"));\n    data->append(Platform::current()->loadResource(\"calendarPicker.css\"));\n    addString(\"</style></head><body><div id=main>Loading...</div><script>\\n\"\n        \"window.dialogArguments = {\\n\", data);\n    addProperty(\"anchorRectInScreen\", anchorRectInScreen, data);\n    addProperty(\"min\", valueToDateTimeString(m_parameters.minimum, m_parameters.type), data);\n    addProperty(\"max\", valueToDateTimeString(m_parameters.maximum, m_parameters.type), data);\n    addProperty(\"step\", stepString, data);\n    addProperty(\"stepBase\", stepBaseString, data);\n    addProperty(\"required\", m_parameters.required, data);\n    addProperty(\"currentValue\", valueToDateTimeString(m_parameters.doubleValue, m_parameters.type), data);\n    addProperty(\"locale\", m_parameters.locale.string(), data);\n     addProperty(\"todayLabel\", todayLabelString, data);\n     addProperty(\"clearLabel\", locale().queryString(WebLocalizedString::CalendarClear), data);\n     addProperty(\"weekLabel\", locale().queryString(WebLocalizedString::WeekNumberLabel), data);\n     addProperty(\"weekStartDay\", m_locale->firstDayOfWeek(), data);\n     addProperty(\"shortMonthLabels\", m_locale->shortMonthLabels(), data);\n     addProperty(\"dayLabels\", m_locale->weekDayShortLabels(), data);\n    addProperty(\"isLocaleRTL\", m_locale->isRTL(), data);\n    addProperty(\"isRTL\", m_parameters.isAnchorElementRTL, data);\n    addProperty(\"mode\", m_parameters.type.string(), data);\n    if (m_parameters.suggestions.size()) {\n        Vector<String> suggestionValues;\n        Vector<String> localizedSuggestionValues;\n        Vector<String> suggestionLabels;\n        for (unsigned i = 0; i < m_parameters.suggestions.size(); i++) {\n            suggestionValues.append(valueToDateTimeString(m_parameters.suggestions[i].value, m_parameters.type));\n            localizedSuggestionValues.append(m_parameters.suggestions[i].localizedValue);\n            suggestionLabels.append(m_parameters.suggestions[i].label);\n        }\n        addProperty(\"suggestionValues\", suggestionValues, data);\n        addProperty(\"localizedSuggestionValues\", localizedSuggestionValues, data);\n        addProperty(\"suggestionLabels\", suggestionLabels, data);\n        addProperty(\"inputWidth\", static_cast<unsigned>(m_parameters.anchorRectInRootView.width()), data);\n        addProperty(\"showOtherDateEntry\", RenderTheme::theme().supportsCalendarPicker(m_parameters.type), data);\n        addProperty(\"otherDateLabel\", otherDateLabelString, data);\n        addProperty(\"suggestionHighlightColor\", RenderTheme::theme().activeListBoxSelectionBackgroundColor().serialized(), data);\n        addProperty(\"suggestionHighlightTextColor\", RenderTheme::theme().activeListBoxSelectionForegroundColor().serialized(), data);\n    }\n    addString(\"}\\n\", data);\n\n    data->append(Platform::current()->loadResource(\"pickerCommon.js\"));\n    data->append(Platform::current()->loadResource(\"suggestionPicker.js\"));\n    data->append(Platform::current()->loadResource(\"calendarPicker.js\"));\n    addString(\"</script></body>\\n\", data);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143567,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "void DateTimeChooserImpl::writeDocument(SharedBuffer* data)\n{\n    String stepString = String::number(m_parameters.step);\n    String stepBaseString = String::number(m_parameters.stepBase, 11, WTF::TruncateTrailingZeros);\n    IntRect anchorRectInScreen = m_chromeClient->rootViewToScreen(m_parameters.anchorRectInRootView);\n    String todayLabelString;\n    String otherDateLabelString;\n    if (m_parameters.type == InputTypeNames::month) {\n        todayLabelString = locale().queryString(WebLocalizedString::ThisMonthButtonLabel);\n        otherDateLabelString = locale().queryString(WebLocalizedString::OtherMonthLabel);\n    } else if (m_parameters.type == InputTypeNames::week) {\n        todayLabelString = locale().queryString(WebLocalizedString::ThisWeekButtonLabel);\n        otherDateLabelString = locale().queryString(WebLocalizedString::OtherWeekLabel);\n    } else {\n        todayLabelString = locale().queryString(WebLocalizedString::CalendarToday);\n        otherDateLabelString = locale().queryString(WebLocalizedString::OtherDateLabel);\n    }\n\n    addString(\"<!DOCTYPE html><head><meta charset='UTF-8'><style>\\n\", data);\n    data->append(Platform::current()->loadResource(\"pickerCommon.css\"));\n    data->append(Platform::current()->loadResource(\"pickerButton.css\"));\n    data->append(Platform::current()->loadResource(\"suggestionPicker.css\"));\n    data->append(Platform::current()->loadResource(\"calendarPicker.css\"));\n    addString(\"</style></head><body><div id=main>Loading...</div><script>\\n\"\n        \"window.dialogArguments = {\\n\", data);\n    addProperty(\"anchorRectInScreen\", anchorRectInScreen, data);\n    addProperty(\"min\", valueToDateTimeString(m_parameters.minimum, m_parameters.type), data);\n    addProperty(\"max\", valueToDateTimeString(m_parameters.maximum, m_parameters.type), data);\n    addProperty(\"step\", stepString, data);\n    addProperty(\"stepBase\", stepBaseString, data);\n    addProperty(\"required\", m_parameters.required, data);\n    addProperty(\"currentValue\", valueToDateTimeString(m_parameters.doubleValue, m_parameters.type), data);\n    addProperty(\"locale\", m_parameters.locale.string(), data);\n     addProperty(\"todayLabel\", todayLabelString, data);\n     addProperty(\"clearLabel\", locale().queryString(WebLocalizedString::CalendarClear), data);\n     addProperty(\"weekLabel\", locale().queryString(WebLocalizedString::WeekNumberLabel), data);\n    addProperty(\"axShowMonthSelector\", locale().queryString(WebLocalizedString::AXCalendarShowMonthSelector), data);\n    addProperty(\"axShowNextMonth\", locale().queryString(WebLocalizedString::AXCalendarShowNextMonth), data);\n    addProperty(\"axShowPreviousMonth\", locale().queryString(WebLocalizedString::AXCalendarShowPreviousMonth), data);\n     addProperty(\"weekStartDay\", m_locale->firstDayOfWeek(), data);\n     addProperty(\"shortMonthLabels\", m_locale->shortMonthLabels(), data);\n     addProperty(\"dayLabels\", m_locale->weekDayShortLabels(), data);\n    addProperty(\"isLocaleRTL\", m_locale->isRTL(), data);\n    addProperty(\"isRTL\", m_parameters.isAnchorElementRTL, data);\n    addProperty(\"mode\", m_parameters.type.string(), data);\n    if (m_parameters.suggestions.size()) {\n        Vector<String> suggestionValues;\n        Vector<String> localizedSuggestionValues;\n        Vector<String> suggestionLabels;\n        for (unsigned i = 0; i < m_parameters.suggestions.size(); i++) {\n            suggestionValues.append(valueToDateTimeString(m_parameters.suggestions[i].value, m_parameters.type));\n            localizedSuggestionValues.append(m_parameters.suggestions[i].localizedValue);\n            suggestionLabels.append(m_parameters.suggestions[i].label);\n        }\n        addProperty(\"suggestionValues\", suggestionValues, data);\n        addProperty(\"localizedSuggestionValues\", localizedSuggestionValues, data);\n        addProperty(\"suggestionLabels\", suggestionLabels, data);\n        addProperty(\"inputWidth\", static_cast<unsigned>(m_parameters.anchorRectInRootView.width()), data);\n        addProperty(\"showOtherDateEntry\", RenderTheme::theme().supportsCalendarPicker(m_parameters.type), data);\n        addProperty(\"otherDateLabel\", otherDateLabelString, data);\n        addProperty(\"suggestionHighlightColor\", RenderTheme::theme().activeListBoxSelectionBackgroundColor().serialized(), data);\n        addProperty(\"suggestionHighlightTextColor\", RenderTheme::theme().activeListBoxSelectionForegroundColor().serialized(), data);\n    }\n    addString(\"}\\n\", data);\n\n    data->append(Platform::current()->loadResource(\"pickerCommon.js\"));\n    data->append(Platform::current()->loadResource(\"suggestionPicker.js\"));\n    data->append(Platform::current()->loadResource(\"calendarPicker.js\"));\n    addString(\"</script></body>\\n\", data);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143568,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "bool CopyDirectory(const FilePath& from_path,\n                   const FilePath& to_path,\n                   bool recursive) {\n  base::ThreadRestrictions::AssertIOAllowed();\n  DCHECK(to_path.value().find('*') == std::string::npos);\n  DCHECK(from_path.value().find('*') == std::string::npos);\n\n  char top_dir[PATH_MAX];\n  if (base::strlcpy(top_dir, from_path.value().c_str(),\n                    arraysize(top_dir)) >= arraysize(top_dir)) {\n    return false;\n  }\n\n  FilePath real_to_path = to_path;\n  if (PathExists(real_to_path)) {\n    if (!AbsolutePath(&real_to_path))\n      return false;\n  } else {\n    real_to_path = real_to_path.DirName();\n    if (!AbsolutePath(&real_to_path))\n      return false;\n  }\n  FilePath real_from_path = from_path;\n  if (!AbsolutePath(&real_from_path))\n    return false;\n  if (real_to_path.value().size() >= real_from_path.value().size() &&\n      real_to_path.value().compare(0, real_from_path.value().size(),\n      real_from_path.value()) == 0)\n    return false;\n\n  bool success = true;\n  int traverse_type = FileEnumerator::FILES | FileEnumerator::SHOW_SYM_LINKS;\n  if (recursive)\n    traverse_type |= FileEnumerator::DIRECTORIES;\n  FileEnumerator traversal(from_path, recursive, traverse_type);\n\n  FileEnumerator::FindInfo info;\n  FilePath current = from_path;\n  if (stat(from_path.value().c_str(), &info.stat) < 0) {\n    DLOG(ERROR) << \"CopyDirectory() couldn't stat source directory: \"\n                << from_path.value() << \" errno = \" << errno;\n    success = false;\n  }\n  struct stat to_path_stat;\n  FilePath from_path_base = from_path;\n  if (recursive && stat(to_path.value().c_str(), &to_path_stat) == 0 &&\n      S_ISDIR(to_path_stat.st_mode)) {\n    from_path_base = from_path.DirName();\n  }\n\n   DCHECK(recursive || S_ISDIR(info.stat.st_mode));\n \n   while (success && !current.empty()) {\n    std::string suffix(&current.value().c_str()[from_path_base.value().size()]);\n    if (!suffix.empty()) {\n      DCHECK_EQ('/', suffix[0]);\n      suffix.erase(0, 1);\n     }\n    const FilePath target_path = to_path.Append(suffix);\n \n     if (S_ISDIR(info.stat.st_mode)) {\n       if (mkdir(target_path.value().c_str(), info.stat.st_mode & 01777) != 0 &&\n          errno != EEXIST) {\n        DLOG(ERROR) << \"CopyDirectory() couldn't create directory: \"\n                    << target_path.value() << \" errno = \" << errno;\n        success = false;\n      }\n    } else if (S_ISREG(info.stat.st_mode)) {\n      if (!CopyFile(current, target_path)) {\n        DLOG(ERROR) << \"CopyDirectory() couldn't create file: \"\n                    << target_path.value();\n        success = false;\n      }\n    } else {\n      DLOG(WARNING) << \"CopyDirectory() skipping non-regular file: \"\n                    << current.value();\n    }\n\n    current = traversal.Next();\n    traversal.GetFindInfo(&info);\n  }\n\n  return success;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143583,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "bool CopyDirectory(const FilePath& from_path,\n                   const FilePath& to_path,\n                   bool recursive) {\n  base::ThreadRestrictions::AssertIOAllowed();\n  DCHECK(to_path.value().find('*') == std::string::npos);\n  DCHECK(from_path.value().find('*') == std::string::npos);\n\n  char top_dir[PATH_MAX];\n  if (base::strlcpy(top_dir, from_path.value().c_str(),\n                    arraysize(top_dir)) >= arraysize(top_dir)) {\n    return false;\n  }\n\n  FilePath real_to_path = to_path;\n  if (PathExists(real_to_path)) {\n    if (!AbsolutePath(&real_to_path))\n      return false;\n  } else {\n    real_to_path = real_to_path.DirName();\n    if (!AbsolutePath(&real_to_path))\n      return false;\n  }\n  FilePath real_from_path = from_path;\n  if (!AbsolutePath(&real_from_path))\n    return false;\n  if (real_to_path.value().size() >= real_from_path.value().size() &&\n      real_to_path.value().compare(0, real_from_path.value().size(),\n      real_from_path.value()) == 0)\n    return false;\n\n  bool success = true;\n  int traverse_type = FileEnumerator::FILES | FileEnumerator::SHOW_SYM_LINKS;\n  if (recursive)\n    traverse_type |= FileEnumerator::DIRECTORIES;\n  FileEnumerator traversal(from_path, recursive, traverse_type);\n\n  FileEnumerator::FindInfo info;\n  FilePath current = from_path;\n  if (stat(from_path.value().c_str(), &info.stat) < 0) {\n    DLOG(ERROR) << \"CopyDirectory() couldn't stat source directory: \"\n                << from_path.value() << \" errno = \" << errno;\n    success = false;\n  }\n  struct stat to_path_stat;\n  FilePath from_path_base = from_path;\n  if (recursive && stat(to_path.value().c_str(), &to_path_stat) == 0 &&\n      S_ISDIR(to_path_stat.st_mode)) {\n    from_path_base = from_path.DirName();\n  }\n\n   DCHECK(recursive || S_ISDIR(info.stat.st_mode));\n \n   while (success && !current.empty()) {\n    // current is the source path, including from_path, so append\n    // the suffix after from_path to to_path to create the target_path.\n    FilePath target_path(to_path);\n    if (from_path_base != current) {\n      if (!from_path_base.AppendRelativePath(current, &target_path)) {\n        success = false;\n        break;\n      }\n     }\n \n     if (S_ISDIR(info.stat.st_mode)) {\n       if (mkdir(target_path.value().c_str(), info.stat.st_mode & 01777) != 0 &&\n          errno != EEXIST) {\n        DLOG(ERROR) << \"CopyDirectory() couldn't create directory: \"\n                    << target_path.value() << \" errno = \" << errno;\n        success = false;\n      }\n    } else if (S_ISREG(info.stat.st_mode)) {\n      if (!CopyFile(current, target_path)) {\n        DLOG(ERROR) << \"CopyDirectory() couldn't create file: \"\n                    << target_path.value();\n        success = false;\n      }\n    } else {\n      DLOG(WARNING) << \"CopyDirectory() skipping non-regular file: \"\n                    << current.value();\n    }\n\n    current = traversal.Next();\n    traversal.GetFindInfo(&info);\n  }\n\n  return success;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143584,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "local void process(char *path)\n{\n    int method = -1;                /* get_header() return value */\n    size_t len;                     /* length of base name (minus suffix) */\n    struct stat st;                 /* to get file type and mod time */\n    /* all compressed suffixes for decoding search, in length order */\n    static char *sufs[] = {\".z\", \"-z\", \"_z\", \".Z\", \".gz\", \"-gz\", \".zz\", \"-zz\",\n                           \".zip\", \".ZIP\", \".tgz\", NULL};\n\n    /* open input file with name in, descriptor ind -- set name and mtime */\n    if (path == NULL) {\n        strcpy(g.inf, \"<stdin>\");\n        g.ind = 0;\n        g.name = NULL;\n        g.mtime = g.headis & 2 ?\n                  (fstat(g.ind, &st) ? time(NULL) : st.st_mtime) : 0;\n        len = 0;\n    }\n    else {\n        /* set input file name (already set if recursed here) */\n        if (path != g.inf) {\n            strncpy(g.inf, path, sizeof(g.inf));\n            if (g.inf[sizeof(g.inf) - 1])\n                bail(\"name too long: \", path);\n        }\n        len = strlen(g.inf);\n\n        /* try to stat input file -- if not there and decoding, look for that\n           name with compressed suffixes */\n        if (lstat(g.inf, &st)) {\n            if (errno == ENOENT && (g.list || g.decode)) {\n                char **try = sufs;\n                do {\n                    if (*try == NULL || len + strlen(*try) >= sizeof(g.inf))\n                        break;\n                    strcpy(g.inf + len, *try++);\n                    errno = 0;\n                } while (lstat(g.inf, &st) && errno == ENOENT);\n            }\n#ifdef EOVERFLOW\n            if (errno == EOVERFLOW || errno == EFBIG)\n                bail(g.inf,\n                    \" too large -- not compiled with large file support\");\n#endif\n            if (errno) {\n                g.inf[len] = 0;\n                complain(\"%s does not exist -- skipping\", g.inf);\n                return;\n            }\n            len = strlen(g.inf);\n        }\n\n        /* only process regular files, but allow symbolic links if -f,\n           recurse into directory if -r */\n        if ((st.st_mode & S_IFMT) != S_IFREG &&\n            (st.st_mode & S_IFMT) != S_IFLNK &&\n            (st.st_mode & S_IFMT) != S_IFDIR) {\n            complain(\"%s is a special file or device -- skipping\", g.inf);\n            return;\n        }\n        if ((st.st_mode & S_IFMT) == S_IFLNK && !g.force && !g.pipeout) {\n            complain(\"%s is a symbolic link -- skipping\", g.inf);\n            return;\n        }\n        if ((st.st_mode & S_IFMT) == S_IFDIR && !g.recurse) {\n            complain(\"%s is a directory -- skipping\", g.inf);\n            return;\n        }\n\n        /* recurse into directory (assumes Unix) */\n        if ((st.st_mode & S_IFMT) == S_IFDIR) {\n            char *roll, *item, *cut, *base, *bigger;\n            size_t len, hold;\n            DIR *here;\n            struct dirent *next;\n\n            /* accumulate list of entries (need to do this, since readdir()\n               behavior not defined if directory modified between calls) */\n            here = opendir(g.inf);\n            if (here == NULL)\n                return;\n            hold = 512;\n            roll = MALLOC(hold);\n            if (roll == NULL)\n                bail(\"not enough memory\", \"\");\n            *roll = 0;\n            item = roll;\n            while ((next = readdir(here)) != NULL) {\n                if (next->d_name[0] == 0 ||\n                    (next->d_name[0] == '.' && (next->d_name[1] == 0 ||\n                     (next->d_name[1] == '.' && next->d_name[2] == 0))))\n                    continue;\n                len = strlen(next->d_name) + 1;\n                if (item + len + 1 > roll + hold) {\n                    do {                    /* make roll bigger */\n                        hold <<= 1;\n                    } while (item + len + 1 > roll + hold);\n                    bigger = REALLOC(roll, hold);\n                    if (bigger == NULL) {\n                        FREE(roll);\n                        bail(\"not enough memory\", \"\");\n                    }\n                    item = bigger + (item - roll);\n                    roll = bigger;\n                }\n                strcpy(item, next->d_name);\n                item += len;\n                *item = 0;\n            }\n            closedir(here);\n\n            /* run process() for each entry in the directory */\n            cut = base = g.inf + strlen(g.inf);\n            if (base > g.inf && base[-1] != (unsigned char)'/') {\n                if ((size_t)(base - g.inf) >= sizeof(g.inf))\n                    bail(\"path too long\", g.inf);\n                *base++ = '/';\n            }\n            item = roll;\n            while (*item) {\n                strncpy(base, item, sizeof(g.inf) - (base - g.inf));\n                if (g.inf[sizeof(g.inf) - 1]) {\n                    strcpy(g.inf + (sizeof(g.inf) - 4), \"...\");\n                    bail(\"path too long: \", g.inf);\n                }\n                process(g.inf);\n                item += strlen(item) + 1;\n            }\n            *cut = 0;\n\n            /* release list of entries */\n            FREE(roll);\n            return;\n        }\n\n        /* don't compress .gz (or provided suffix) files, unless -f */\n        if (!(g.force || g.list || g.decode) && len >= strlen(g.sufx) &&\n                strcmp(g.inf + len - strlen(g.sufx), g.sufx) == 0) {\n            complain(\"%s ends with %s -- skipping\", g.inf, g.sufx);\n            return;\n        }\n\n        /* create output file only if input file has compressed suffix */\n        if (g.decode == 1 && !g.pipeout && !g.list) {\n            int suf = compressed_suffix(g.inf);\n            if (suf == 0) {\n                complain(\"%s does not have compressed suffix -- skipping\",\n                         g.inf);\n                return;\n            }\n            len -= suf;\n        }\n\n        /* open input file */\n        g.ind = open(g.inf, O_RDONLY, 0);\n        if (g.ind < 0)\n            bail(\"read error on \", g.inf);\n\n        /* prepare gzip header information for compression */\n        g.name = g.headis & 1 ? justname(g.inf) : NULL;\n        g.mtime = g.headis & 2 ? st.st_mtime : 0;\n    }\n    SET_BINARY_MODE(g.ind);\n\n    /* if decoding or testing, try to read gzip header */\n    g.hname = NULL;\n    if (g.decode) {\n        in_init();\n        method = get_header(1);\n        if (method != 8 && method != 257 &&\n                /* gzip -cdf acts like cat on uncompressed input */\n                !(method == -2 && g.force && g.pipeout && g.decode != 2 &&\n                  !g.list)) {\n            RELEASE(g.hname);\n            if (g.ind != 0)\n                close(g.ind);\n            if (method != -1)\n                complain(method < 0 ? \"%s is not compressed -- skipping\" :\n                         \"%s has unknown compression method -- skipping\",\n                         g.inf);\n            return;\n        }\n\n        /* if requested, test input file (possibly a special list) */\n        if (g.decode == 2) {\n            if (method == 8)\n                infchk();\n            else {\n                unlzw();\n                if (g.list) {\n                    g.in_tot -= 3;\n                    show_info(method, 0, g.out_tot, 0);\n                }\n            }\n            RELEASE(g.hname);\n            if (g.ind != 0)\n                close(g.ind);\n            return;\n        }\n    }\n\n    /* if requested, just list information about input file */\n    if (g.list) {\n        list_info();\n        RELEASE(g.hname);\n        if (g.ind != 0)\n            close(g.ind);\n        return;\n    }\n\n    /* create output file out, descriptor outd */\n    if (path == NULL || g.pipeout) {\n        /* write to stdout */\n        g.outf = MALLOC(strlen(\"<stdout>\") + 1);\n        if (g.outf == NULL)\n            bail(\"not enough memory\", \"\");\n        strcpy(g.outf, \"<stdout>\");\n        g.outd = 1;\n        if (!g.decode && !g.force && isatty(g.outd))\n            bail(\"trying to write compressed data to a terminal\",\n                  \" (use -f to force)\");\n     }\n     else {\n        char *to, *repl;\n        /* use header name for output when decompressing with -N */\n        to = g.inf;\n        if (g.decode && (g.headis & 1) != 0 && g.hname != NULL) {\n            to = g.hname;\n            len = strlen(g.hname);\n         }\n        /* replace .tgz with .tar when decoding */\n        repl = g.decode && strcmp(to + len, \".tgz\") ? \"\" : \".tar\";\n \n         /* create output file and open to write */\n        g.outf = MALLOC(len + (g.decode ? strlen(repl) : strlen(g.sufx)) + 1);\n         if (g.outf == NULL)\n             bail(\"not enough memory\", \"\");\n        memcpy(g.outf, to, len);\n        strcpy(g.outf + len, g.decode ? repl : g.sufx);\n         g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY |\n                             (g.force ? 0 : O_EXCL), 0600);\n \n         /* if exists and not -f, give user a chance to overwrite */\n         if (g.outd < 0 && errno == EEXIST && isatty(0) && g.verbosity) {\n            int ch, reply;\n\n            fprintf(stderr, \"%s exists -- overwrite (y/n)? \", g.outf);\n            fflush(stderr);\n            reply = -1;\n            do {\n                ch = getchar();\n                if (reply < 0 && ch != ' ' && ch != '\\t')\n                    reply = ch == 'y' || ch == 'Y' ? 1 : 0;\n            } while (ch != EOF && ch != '\\n' && ch != '\\r');\n            if (reply == 1)\n                g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY,\n                              0600);\n        }\n\n        /* if exists and no overwrite, report and go on to next */\n        if (g.outd < 0 && errno == EEXIST) {\n            complain(\"%s exists -- skipping\", g.outf);\n            RELEASE(g.outf);\n            RELEASE(g.hname);\n            if (g.ind != 0)\n                close(g.ind);\n            return;\n        }\n\n        /* if some other error, give up */\n        if (g.outd < 0)\n            bail(\"write error on \", g.outf);\n    }\n    SET_BINARY_MODE(g.outd);\n    RELEASE(g.hname);\n\n    /* process ind to outd */\n    if (g.verbosity > 1)\n        fprintf(stderr, \"%s to %s \", g.inf, g.outf);\n    if (g.decode) {\n        if (method == 8)\n            infchk();\n        else if (method == 257)\n            unlzw();\n        else\n            cat();\n    }\n#ifndef NOTHREAD\n    else if (g.procs > 1)\n        parallel_compress();\n#endif\n    else\n        single_compress(0);\n    if (g.verbosity > 1) {\n        putc('\\n', stderr);\n        fflush(stderr);\n    }\n\n    /* finish up, copy attributes, set times, delete original */\n    if (g.ind != 0)\n        close(g.ind);\n    if (g.outd != 1) {\n        if (close(g.outd))\n            bail(\"write error on \", g.outf);\n        g.outd = -1;            /* now prevent deletion on interrupt */\n        if (g.ind != 0) {\n            copymeta(g.inf, g.outf);\n            if (!g.keep)\n                unlink(g.inf);\n        }\n        if (g.decode && (g.headis & 2) != 0 && g.stamp)\n            touch(g.outf, g.stamp);\n    }\n    RELEASE(g.outf);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144039,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "local void process(char *path)\n{\n    int method = -1;                /* get_header() return value */\n    size_t len;                     /* length of base name (minus suffix) */\n    struct stat st;                 /* to get file type and mod time */\n    /* all compressed suffixes for decoding search, in length order */\n    static char *sufs[] = {\".z\", \"-z\", \"_z\", \".Z\", \".gz\", \"-gz\", \".zz\", \"-zz\",\n                           \".zip\", \".ZIP\", \".tgz\", NULL};\n\n    /* open input file with name in, descriptor ind -- set name and mtime */\n    if (path == NULL) {\n        strcpy(g.inf, \"<stdin>\");\n        g.ind = 0;\n        g.name = NULL;\n        g.mtime = g.headis & 2 ?\n                  (fstat(g.ind, &st) ? time(NULL) : st.st_mtime) : 0;\n        len = 0;\n    }\n    else {\n        /* set input file name (already set if recursed here) */\n        if (path != g.inf) {\n            strncpy(g.inf, path, sizeof(g.inf));\n            if (g.inf[sizeof(g.inf) - 1])\n                bail(\"name too long: \", path);\n        }\n        len = strlen(g.inf);\n\n        /* try to stat input file -- if not there and decoding, look for that\n           name with compressed suffixes */\n        if (lstat(g.inf, &st)) {\n            if (errno == ENOENT && (g.list || g.decode)) {\n                char **try = sufs;\n                do {\n                    if (*try == NULL || len + strlen(*try) >= sizeof(g.inf))\n                        break;\n                    strcpy(g.inf + len, *try++);\n                    errno = 0;\n                } while (lstat(g.inf, &st) && errno == ENOENT);\n            }\n#ifdef EOVERFLOW\n            if (errno == EOVERFLOW || errno == EFBIG)\n                bail(g.inf,\n                    \" too large -- not compiled with large file support\");\n#endif\n            if (errno) {\n                g.inf[len] = 0;\n                complain(\"%s does not exist -- skipping\", g.inf);\n                return;\n            }\n            len = strlen(g.inf);\n        }\n\n        /* only process regular files, but allow symbolic links if -f,\n           recurse into directory if -r */\n        if ((st.st_mode & S_IFMT) != S_IFREG &&\n            (st.st_mode & S_IFMT) != S_IFLNK &&\n            (st.st_mode & S_IFMT) != S_IFDIR) {\n            complain(\"%s is a special file or device -- skipping\", g.inf);\n            return;\n        }\n        if ((st.st_mode & S_IFMT) == S_IFLNK && !g.force && !g.pipeout) {\n            complain(\"%s is a symbolic link -- skipping\", g.inf);\n            return;\n        }\n        if ((st.st_mode & S_IFMT) == S_IFDIR && !g.recurse) {\n            complain(\"%s is a directory -- skipping\", g.inf);\n            return;\n        }\n\n        /* recurse into directory (assumes Unix) */\n        if ((st.st_mode & S_IFMT) == S_IFDIR) {\n            char *roll, *item, *cut, *base, *bigger;\n            size_t len, hold;\n            DIR *here;\n            struct dirent *next;\n\n            /* accumulate list of entries (need to do this, since readdir()\n               behavior not defined if directory modified between calls) */\n            here = opendir(g.inf);\n            if (here == NULL)\n                return;\n            hold = 512;\n            roll = MALLOC(hold);\n            if (roll == NULL)\n                bail(\"not enough memory\", \"\");\n            *roll = 0;\n            item = roll;\n            while ((next = readdir(here)) != NULL) {\n                if (next->d_name[0] == 0 ||\n                    (next->d_name[0] == '.' && (next->d_name[1] == 0 ||\n                     (next->d_name[1] == '.' && next->d_name[2] == 0))))\n                    continue;\n                len = strlen(next->d_name) + 1;\n                if (item + len + 1 > roll + hold) {\n                    do {                    /* make roll bigger */\n                        hold <<= 1;\n                    } while (item + len + 1 > roll + hold);\n                    bigger = REALLOC(roll, hold);\n                    if (bigger == NULL) {\n                        FREE(roll);\n                        bail(\"not enough memory\", \"\");\n                    }\n                    item = bigger + (item - roll);\n                    roll = bigger;\n                }\n                strcpy(item, next->d_name);\n                item += len;\n                *item = 0;\n            }\n            closedir(here);\n\n            /* run process() for each entry in the directory */\n            cut = base = g.inf + strlen(g.inf);\n            if (base > g.inf && base[-1] != (unsigned char)'/') {\n                if ((size_t)(base - g.inf) >= sizeof(g.inf))\n                    bail(\"path too long\", g.inf);\n                *base++ = '/';\n            }\n            item = roll;\n            while (*item) {\n                strncpy(base, item, sizeof(g.inf) - (base - g.inf));\n                if (g.inf[sizeof(g.inf) - 1]) {\n                    strcpy(g.inf + (sizeof(g.inf) - 4), \"...\");\n                    bail(\"path too long: \", g.inf);\n                }\n                process(g.inf);\n                item += strlen(item) + 1;\n            }\n            *cut = 0;\n\n            /* release list of entries */\n            FREE(roll);\n            return;\n        }\n\n        /* don't compress .gz (or provided suffix) files, unless -f */\n        if (!(g.force || g.list || g.decode) && len >= strlen(g.sufx) &&\n                strcmp(g.inf + len - strlen(g.sufx), g.sufx) == 0) {\n            complain(\"%s ends with %s -- skipping\", g.inf, g.sufx);\n            return;\n        }\n\n        /* create output file only if input file has compressed suffix */\n        if (g.decode == 1 && !g.pipeout && !g.list) {\n            int suf = compressed_suffix(g.inf);\n            if (suf == 0) {\n                complain(\"%s does not have compressed suffix -- skipping\",\n                         g.inf);\n                return;\n            }\n            len -= suf;\n        }\n\n        /* open input file */\n        g.ind = open(g.inf, O_RDONLY, 0);\n        if (g.ind < 0)\n            bail(\"read error on \", g.inf);\n\n        /* prepare gzip header information for compression */\n        g.name = g.headis & 1 ? justname(g.inf) : NULL;\n        g.mtime = g.headis & 2 ? st.st_mtime : 0;\n    }\n    SET_BINARY_MODE(g.ind);\n\n    /* if decoding or testing, try to read gzip header */\n    g.hname = NULL;\n    if (g.decode) {\n        in_init();\n        method = get_header(1);\n        if (method != 8 && method != 257 &&\n                /* gzip -cdf acts like cat on uncompressed input */\n                !(method == -2 && g.force && g.pipeout && g.decode != 2 &&\n                  !g.list)) {\n            RELEASE(g.hname);\n            if (g.ind != 0)\n                close(g.ind);\n            if (method != -1)\n                complain(method < 0 ? \"%s is not compressed -- skipping\" :\n                         \"%s has unknown compression method -- skipping\",\n                         g.inf);\n            return;\n        }\n\n        /* if requested, test input file (possibly a special list) */\n        if (g.decode == 2) {\n            if (method == 8)\n                infchk();\n            else {\n                unlzw();\n                if (g.list) {\n                    g.in_tot -= 3;\n                    show_info(method, 0, g.out_tot, 0);\n                }\n            }\n            RELEASE(g.hname);\n            if (g.ind != 0)\n                close(g.ind);\n            return;\n        }\n    }\n\n    /* if requested, just list information about input file */\n    if (g.list) {\n        list_info();\n        RELEASE(g.hname);\n        if (g.ind != 0)\n            close(g.ind);\n        return;\n    }\n\n    /* create output file out, descriptor outd */\n    if (path == NULL || g.pipeout) {\n        /* write to stdout */\n        g.outf = MALLOC(strlen(\"<stdout>\") + 1);\n        if (g.outf == NULL)\n            bail(\"not enough memory\", \"\");\n        strcpy(g.outf, \"<stdout>\");\n        g.outd = 1;\n        if (!g.decode && !g.force && isatty(g.outd))\n            bail(\"trying to write compressed data to a terminal\",\n                  \" (use -f to force)\");\n     }\n     else {\n        char *to = g.inf, *sufx = \"\";\n        size_t pre = 0;\n\n        /* select parts of the output file name */\n        if (g.decode) {\n            /* for -dN or -dNT, use the path from the input file and the name\n               from the header, stripping any path in the header name */\n            if ((g.headis & 1) != 0 && g.hname != NULL) {\n                pre = justname(g.inf) - g.inf;\n                to = justname(g.hname);\n                len = strlen(to);\n            }\n            /* for -d or -dNn, replace abbreviated suffixes */\n            else if (strcmp(to + len, \".tgz\") == 0)\n                sufx = \".tar\";\n         }\n        else\n            /* add appropriate suffix when compressing */\n            sufx = g.sufx;\n \n         /* create output file and open to write */\n        g.outf = MALLOC(pre + len + strlen(sufx) + 1);\n         if (g.outf == NULL)\n             bail(\"not enough memory\", \"\");\n        memcpy(g.outf, g.inf, pre);\n        memcpy(g.outf + pre, to, len);\n        strcpy(g.outf + pre + len, sufx);\n         g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY |\n                              (g.force ? 0 : O_EXCL), 0600);\n \n         /* if exists and not -f, give user a chance to overwrite */\n         if (g.outd < 0 && errno == EEXIST && isatty(0) && g.verbosity) {\n            int ch, reply;\n\n            fprintf(stderr, \"%s exists -- overwrite (y/n)? \", g.outf);\n            fflush(stderr);\n            reply = -1;\n            do {\n                ch = getchar();\n                if (reply < 0 && ch != ' ' && ch != '\\t')\n                    reply = ch == 'y' || ch == 'Y' ? 1 : 0;\n            } while (ch != EOF && ch != '\\n' && ch != '\\r');\n            if (reply == 1)\n                g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY,\n                              0600);\n        }\n\n        /* if exists and no overwrite, report and go on to next */\n        if (g.outd < 0 && errno == EEXIST) {\n            complain(\"%s exists -- skipping\", g.outf);\n            RELEASE(g.outf);\n            RELEASE(g.hname);\n            if (g.ind != 0)\n                close(g.ind);\n            return;\n        }\n\n        /* if some other error, give up */\n        if (g.outd < 0)\n            bail(\"write error on \", g.outf);\n    }\n    SET_BINARY_MODE(g.outd);\n    RELEASE(g.hname);\n\n    /* process ind to outd */\n    if (g.verbosity > 1)\n        fprintf(stderr, \"%s to %s \", g.inf, g.outf);\n    if (g.decode) {\n        if (method == 8)\n            infchk();\n        else if (method == 257)\n            unlzw();\n        else\n            cat();\n    }\n#ifndef NOTHREAD\n    else if (g.procs > 1)\n        parallel_compress();\n#endif\n    else\n        single_compress(0);\n    if (g.verbosity > 1) {\n        putc('\\n', stderr);\n        fflush(stderr);\n    }\n\n    /* finish up, copy attributes, set times, delete original */\n    if (g.ind != 0)\n        close(g.ind);\n    if (g.outd != 1) {\n        if (close(g.outd))\n            bail(\"write error on \", g.outf);\n        g.outd = -1;            /* now prevent deletion on interrupt */\n        if (g.ind != 0) {\n            copymeta(g.inf, g.outf);\n            if (!g.keep)\n                unlink(g.inf);\n        }\n        if (g.decode && (g.headis & 2) != 0 && g.stamp)\n            touch(g.outf, g.stamp);\n    }\n    RELEASE(g.outf);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144040,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "flatpak_context_merge (FlatpakContext *context,\n                       FlatpakContext *other)\n{\n  GHashTableIter iter;\n  gpointer key, value;\n\n  context->shares &= ~other->shares_valid;\n  context->shares |= other->shares;\n  context->shares_valid |= other->shares_valid;\n  context->sockets &= ~other->sockets_valid;\n  context->sockets |= other->sockets;\n  context->sockets_valid |= other->sockets_valid;\n  context->devices &= ~other->devices_valid;\n  context->devices |= other->devices;\n  context->devices_valid |= other->devices_valid;\n  context->features &= ~other->features_valid;\n  context->features |= other->features;\n  context->features_valid |= other->features_valid;\n\n  g_hash_table_iter_init (&iter, other->env_vars);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->env_vars, g_strdup (key), g_strdup (value));\n\n  g_hash_table_iter_init (&iter, other->persistent);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->persistent, g_strdup (key), value);\n\n  g_hash_table_iter_init (&iter, other->filesystems);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->filesystems, g_strdup (key), value);\n\n  g_hash_table_iter_init (&iter, other->session_bus_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->session_bus_policy, g_strdup (key), value);\n\n  g_hash_table_iter_init (&iter, other->system_bus_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->system_bus_policy, g_strdup (key), value);\n\n  g_hash_table_iter_init (&iter, other->system_bus_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->system_bus_policy, g_strdup (key), value);\n\n  g_hash_table_iter_init (&iter, other->generic_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    {\n      const char **policy_values = (const char **) value;\n      int i;\n\n      for (i = 0; policy_values[i] != NULL; i++)\n        flatpak_context_apply_generic_policy (context, (char *) key, policy_values[i]);\n    }\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144701,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "flatpak_context_merge (FlatpakContext *context,\n                       FlatpakContext *other)\n{\n  GHashTableIter iter;\n  gpointer key, value;\n  gboolean no_home = FALSE;\n  gboolean no_host = FALSE;\n\n  context->shares &= ~other->shares_valid;\n  context->shares |= other->shares;\n  context->shares_valid |= other->shares_valid;\n  context->sockets &= ~other->sockets_valid;\n  context->sockets |= other->sockets;\n  context->sockets_valid |= other->sockets_valid;\n  context->devices &= ~other->devices_valid;\n  context->devices |= other->devices;\n  context->devices_valid |= other->devices_valid;\n  context->features &= ~other->features_valid;\n  context->features |= other->features;\n  context->features_valid |= other->features_valid;\n\n  g_hash_table_iter_init (&iter, other->env_vars);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->env_vars, g_strdup (key), g_strdup (value));\n\n  g_hash_table_iter_init (&iter, other->persistent);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->persistent, g_strdup (key), value);\n\n  /* We first handle all negative home and host as they override other\n     keys than themselves from the parent */\n  if (g_hash_table_lookup_extended (other->filesystems,\n                                    \"host\",\n                                    NULL, &value))\n    {\n      FlatpakFilesystemMode host_mode = GPOINTER_TO_INT (value);\n      if (host_mode == FLATPAK_FILESYSTEM_MODE_NONE)\n        no_host = TRUE;\n    }\n\n  if (g_hash_table_lookup_extended (other->filesystems,\n                                    \"home\",\n                                    NULL, &value))\n    {\n      FlatpakFilesystemMode home_mode = GPOINTER_TO_INT (value);\n      if (home_mode == FLATPAK_FILESYSTEM_MODE_NONE)\n        no_home = TRUE;\n    }\n\n  if (no_host)\n    {\n      g_hash_table_remove_all (context->filesystems);\n    }\n  else if (no_home)\n    {\n      g_hash_table_iter_init (&iter, context->filesystems);\n      while (g_hash_table_iter_next (&iter, &key, &value))\n        {\n          if (flatpak_filesystem_key_in_home ((const char *)key))\n            g_hash_table_iter_remove (&iter);\n        }\n    }\n\n  /* Then set the new ones, which includes propagating the nohost and nohome ones. */\n  g_hash_table_iter_init (&iter, other->filesystems);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->filesystems, g_strdup (key), value);\n\n  g_hash_table_iter_init (&iter, other->session_bus_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->session_bus_policy, g_strdup (key), value);\n\n  g_hash_table_iter_init (&iter, other->system_bus_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->system_bus_policy, g_strdup (key), value);\n\n  g_hash_table_iter_init (&iter, other->system_bus_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->system_bus_policy, g_strdup (key), value);\n\n  g_hash_table_iter_init (&iter, other->generic_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    {\n      const char **policy_values = (const char **) value;\n      int i;\n\n      for (i = 0; policy_values[i] != NULL; i++)\n        flatpak_context_apply_generic_policy (context, (char *) key, policy_values[i]);\n    }\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144702,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "header_cache_t *imap_hcache_open(struct ImapData *idata, const char *path)\n{\n  struct ImapMbox mx;\n  struct Url url;\n  char cachepath[PATH_MAX];\n  char mbox[PATH_MAX];\n\n  if (path)\n    imap_cachepath(idata, path, mbox, sizeof(mbox));\n  else\n  {\n    if (!idata->ctx || imap_parse_path(idata->ctx->path, &mx) < 0)\n      return NULL;\n\n    imap_cachepath(idata, mx.mbox, mbox, sizeof(mbox));\n    FREE(&mx.mbox);\n  }\n\n  mutt_account_tourl(&idata->conn->account, &url);\n  url.path = mbox;\n  url_tostring(&url, cachepath, sizeof(cachepath), U_PATH);\n\n  return mutt_hcache_open(HeaderCache, cachepath, imap_hcache_namer);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144870,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "header_cache_t *imap_hcache_open(struct ImapData *idata, const char *path)\n{\n  struct ImapMbox mx;\n  struct Url url;\n  char cachepath[PATH_MAX];\n  char mbox[PATH_MAX];\n\n  if (path)\n    imap_cachepath(idata, path, mbox, sizeof(mbox));\n  else\n  {\n    if (!idata->ctx || imap_parse_path(idata->ctx->path, &mx) < 0)\n      return NULL;\n\n    imap_cachepath(idata, mx.mbox, mbox, sizeof(mbox));\n    FREE(&mx.mbox);\n  }\n\n  if (strstr(mbox, \"/../\") || (strcmp(mbox, \"..\") == 0) || (strncmp(mbox, \"../\", 3) == 0))\n    return NULL;\n  size_t len = strlen(mbox);\n  if ((len > 3) && (strcmp(mbox + len - 3, \"/..\") == 0))\n    return NULL;\n\n  mutt_account_tourl(&idata->conn->account, &url);\n  url.path = mbox;\n  url_tostring(&url, cachepath, sizeof(cachepath), U_PATH);\n\n  return mutt_hcache_open(HeaderCache, cachepath, imap_hcache_namer);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144871,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "static bool extractFileTo(zip* zip, const std::string &file, std::string& to,\n                          char* buf, size_t len) {\n  auto sep = file.rfind('/');\n  if (sep != std::string::npos) {\n    auto path = to + file.substr(0, sep);\n    if (!HHVM_FN(is_dir)(path) && !HHVM_FN(mkdir)(path, 0777, true)) {\n      return false;\n    }\n\n    if (sep == file.length() - 1) {\n      return true;\n    }\n  }\n\n  to.append(file);\n  struct zip_stat zipStat;\n  if (zip_stat(zip, file.c_str(), 0, &zipStat) != 0) {\n    return false;\n  }\n\n  auto zipFile = zip_fopen_index(zip, zipStat.index, 0);\n  FAIL_IF_INVALID_PTR(zipFile);\n\n  auto outFile = fopen(to.c_str(), \"wb\");\n  if (outFile == nullptr) {\n    zip_fclose(zipFile);\n    return false;\n  }\n\n  for (auto n = zip_fread(zipFile, buf, len); n != 0;\n       n = zip_fread(zipFile, buf, len)) {\n    if (n < 0 || fwrite(buf, sizeof(char), n, outFile) != n) {\n      zip_fclose(zipFile);\n      fclose(outFile);\n      remove(to.c_str());\n      return false;\n    }\n  }\n\n  zip_fclose(zipFile);\n  if (fclose(outFile) != 0) {\n    return false;\n  }\n\n  return true;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145010,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "static bool extractFileTo(zip* zip, const std::string &file, std::string& to,\n                          char* buf, size_t len) {\n\n  struct zip_stat zipStat;\n  // Verify the file to be extracted is actually in the zip file\n  if (zip_stat(zip, file.c_str(), 0, &zipStat) != 0) {\n    return false;\n  }\n\n  auto clean_file = file;\n  auto sep = std::string::npos;\n  // Normally would just use std::string::rfind here, but if we want to be\n  // consistent between Windows and Linux, even if techincally Linux won't use\n  // backslash for a separator, we are checking for both types.\n  int idx = file.length() - 1;\n  while (idx >= 0) {\n    if (FileUtil::isDirSeparator(file[idx])) {\n      sep = idx;\n      break;\n    }\n    idx--;\n  }\n  if (sep != std::string::npos) {\n    // make_relative_path so we do not try to put files or dirs in bad\n    // places. This securely \"cleans\" the file.\n    clean_file = make_relative_path(file);\n    std::string path = to + clean_file;\n    bool is_dir_only = true;\n    if (sep < file.length() - 1) { // not just a directory\n      auto clean_file_dir = HHVM_FN(dirname)(clean_file);\n      path = to + clean_file_dir.toCppString();\n      is_dir_only = false;\n    }\n\n    // Make sure the directory path to extract to exists or can be created\n    if (!HHVM_FN(is_dir)(path) && !HHVM_FN(mkdir)(path, 0777, true)) {\n      return false;\n    }\n\n    // If we have a good directory to extract to above, we now check whether\n    // the \"file\" parameter passed in is a directory or actually a file.\n    if (is_dir_only) { // directory, like /usr/bin/\n      return true;\n    }\n    // otherwise file is actually a file, so we actually extract.\n  }\n\n  // We have ensured that clean_file will be added to a relative path by the\n  // time we get here.\n  to.append(clean_file);\n\n  auto zipFile = zip_fopen_index(zip, zipStat.index, 0);\n  FAIL_IF_INVALID_PTR(zipFile);\n\n  auto outFile = fopen(to.c_str(), \"wb\");\n  if (outFile == nullptr) {\n    zip_fclose(zipFile);\n    return false;\n  }\n\n  for (auto n = zip_fread(zipFile, buf, len); n != 0;\n       n = zip_fread(zipFile, buf, len)) {\n    if (n < 0 || fwrite(buf, sizeof(char), n, outFile) != n) {\n      zip_fclose(zipFile);\n      fclose(outFile);\n      remove(to.c_str());\n      return false;\n    }\n  }\n\n  zip_fclose(zipFile);\n  if (fclose(outFile) != 0) {\n    return false;\n  }\n\n  return true;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145011,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "char *compose_path(ctrl_t *ctrl, char *path)\n{\n\tstruct stat st;\n\tstatic char rpath[PATH_MAX];\n\tchar *name, *ptr;\n\tchar dir[PATH_MAX] = { 0 };\n\n\tstrlcpy(dir, ctrl->cwd, sizeof(dir));\n\tDBG(\"Compose path from cwd: %s, arg: %s\", ctrl->cwd, path ?: \"\");\n\tif (!path || !strlen(path))\n\t\tgoto check;\n\n\tif (path) {\n\t\tif (path[0] != '/') {\n\t\t\tif (dir[strlen(dir) - 1] != '/')\n\t\t\t\tstrlcat(dir, \"/\", sizeof(dir));\n\t\t}\n\t\tstrlcat(dir, path, sizeof(dir));\n\t}\n\ncheck:\n\twhile ((ptr = strstr(dir, \"//\")))\n\t\tmemmove(ptr, &ptr[1], strlen(&ptr[1]) + 1);\n\n\tif (!chrooted) {\n\t\tsize_t len = strlen(home);\n\n\t\tDBG(\"Server path from CWD: %s\", dir);\n\t\tif (len > 0 && home[len - 1] == '/')\n\t\t\tlen--;\n\t\tmemmove(dir + len, dir, strlen(dir) + 1);\n\t\tmemcpy(dir, home, len);\n\t\tDBG(\"Resulting non-chroot path: %s\", dir);\n\t}\n\n\t/*\n\t * Handle directories slightly differently, since dirname() on a\n\t * directory returns the parent directory.  So, just squash ..\n\t */\n\tif (!stat(dir, &st) && S_ISDIR(st.st_mode)) {\n\t\tif (!realpath(dir, rpath))\n\t\t\treturn NULL;\n\t} else {\n\t\t/*\n\t\t * Check realpath() of directory containing the file, a\n\t\t * STOR may want to save a new file.  Then append the\n\t\t * file and return it.\n\t\t */\n\t\tname = basename(path);\n\t\tptr = dirname(dir);\n\n\t\tmemset(rpath, 0, sizeof(rpath));\n\t\tif (!realpath(ptr, rpath)) {\n\t\t\tINFO(\"Failed realpath(%s): %m\", ptr);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (rpath[1] != 0)\n\t\t\tstrlcat(rpath, \"/\", sizeof(rpath));\n\t\tstrlcat(rpath, name, sizeof(rpath));\n\t}\n\n\tif (!chrooted && strncmp(dir, home, strlen(home))) {\n\t\tDBG(\"Failed non-chroot dir:%s vs home:%s\", dir, home);\n\t\treturn NULL;\n\t}\n\n\treturn rpath;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145026,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "char *compose_path(ctrl_t *ctrl, char *path)\n{\n\tstruct stat st;\n\tstatic char rpath[PATH_MAX];\n\tchar *name, *ptr;\n\tchar dir[PATH_MAX] = { 0 };\n\n\tstrlcpy(dir, ctrl->cwd, sizeof(dir));\n\tDBG(\"Compose path from cwd: %s, arg: %s\", ctrl->cwd, path ?: \"\");\n\tif (!path || !strlen(path))\n\t\tgoto check;\n\n\tif (path) {\n\t\tif (path[0] != '/') {\n\t\t\tif (dir[strlen(dir) - 1] != '/')\n\t\t\t\tstrlcat(dir, \"/\", sizeof(dir));\n\t\t}\n\t\tstrlcat(dir, path, sizeof(dir));\n\t}\n\ncheck:\n\twhile ((ptr = strstr(dir, \"//\")))\n\t\tmemmove(ptr, &ptr[1], strlen(&ptr[1]) + 1);\n\n\tif (!chrooted) {\n\t\tsize_t len = strlen(home);\n\n\t\tDBG(\"Server path from CWD: %s\", dir);\n\t\tif (len > 0 && home[len - 1] == '/')\n\t\t\tlen--;\n\t\tmemmove(dir + len, dir, strlen(dir) + 1);\n\t\tmemcpy(dir, home, len);\n\t\tDBG(\"Resulting non-chroot path: %s\", dir);\n\t}\n\n\t/*\n\t * Handle directories slightly differently, since dirname() on a\n\t * directory returns the parent directory.  So, just squash ..\n\t */\n\tif (!stat(dir, &st) && S_ISDIR(st.st_mode)) {\n\t\tif (!realpath(dir, rpath))\n\t\t\treturn NULL;\n\t} else {\n\t\t/*\n\t\t * Check realpath() of directory containing the file, a\n\t\t * STOR may want to save a new file.  Then append the\n\t\t * file and return it.\n\t\t */\n\t\tname = basename(path);\n\t\tptr = dirname(dir);\n\n\t\tmemset(rpath, 0, sizeof(rpath));\n\t\tif (!realpath(ptr, rpath)) {\n\t\t\tINFO(\"Failed realpath(%s): %m\", ptr);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (rpath[1] != 0)\n\t\t\tstrlcat(rpath, \"/\", sizeof(rpath));\n\t\tstrlcat(rpath, name, sizeof(rpath));\n\t}\n\n\tif (!chrooted && strncmp(rpath, home, strlen(home))) {\n\t\tDBG(\"Failed non-chroot dir:%s vs home:%s\", dir, home);\n\t\treturn NULL;\n\t}\n\n\treturn rpath;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145027,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "BYTE *DecompressRTF(variableLength *p, int *size) {\n  BYTE *dst; // destination for uncompressed bytes\n  BYTE *src;\n  unsigned int in;\n  unsigned int out;\n  variableLength comp_Prebuf;\n  ULONG compressedSize, uncompressedSize, magic;\n\n  comp_Prebuf.size = strlen(RTF_PREBUF);\n  comp_Prebuf.data = calloc(comp_Prebuf.size+1, 1);\n  ALLOCCHECK_CHAR(comp_Prebuf.data);\n  memcpy(comp_Prebuf.data, RTF_PREBUF, comp_Prebuf.size);\n\n  src = p->data;\n  in = 0;\n\n  if (p->size < 20) {\n    printf(\"File too small\\n\");\n    return(NULL);\n  }\n  compressedSize = (ULONG)SwapDWord((BYTE*)src + in, 4);\n  in += 4;\n  uncompressedSize = (ULONG)SwapDWord((BYTE*)src + in, 4);\n  in += 4;\n  magic = SwapDWord((BYTE*)src + in, 4);\n  in += 4;\n  in += 4;\n\n  // check size excluding the size field itself\n  if (compressedSize != p->size - 4) {\n    printf(\" Size Mismatch: %u != %i\\n\", compressedSize, p->size - 4);\n    free(comp_Prebuf.data);\n    return NULL;\n  }\n\n  // process the data\n  if (magic == 0x414c454d) {\n    // magic number that identifies the stream as a uncompressed stream\n    dst = calloc(uncompressedSize, 1);\n    ALLOCCHECK_CHAR(dst);\n    memcpy(dst, src + 4, uncompressedSize);\n  } else if (magic == 0x75465a4c) {\n    // magic number that identifies the stream as a compressed stream\n    int flagCount = 0;\n    int flags = 0;\n    // Prevent overflow on 32 Bit Systems\n    if (comp_Prebuf.size >= INT_MAX - uncompressedSize) {\n       printf(\"Corrupted file\\n\");\n       exit(-1);\n    }\n    dst = calloc(comp_Prebuf.size + uncompressedSize, 1);\n    ALLOCCHECK_CHAR(dst);\n    memcpy(dst, comp_Prebuf.data, comp_Prebuf.size);\n    out = comp_Prebuf.size;\n    while (out < (comp_Prebuf.size + uncompressedSize)) {\n      // each flag byte flags 8 literals/references, 1 per bit\n      flags = (flagCount++ % 8 == 0) ? src[in++] : flags >> 1;\n      if ((flags & 1) == 1) { // each flag bit is 1 for reference, 0 for literal\n        unsigned int offset = src[in++];\n        unsigned int length = src[in++];\n        unsigned int end;\n        offset = (offset << 4) | (length >> 4); // the offset relative to block start\n        length = (length & 0xF) + 2; // the number of bytes to copy\n        // the decompression buffer is supposed to wrap around back\n        // to the beginning when the end is reached. we save the\n        // need for such a buffer by pointing straight into the data\n        // buffer, and simulating this behaviour by modifying the\n        // pointers appropriately.\n        offset = (out / 4096) * 4096 + offset;\n        if (offset >= out) // take from previous block\n          offset -= 4096;\n        // note: can't use System.arraycopy, because the referenced\n        // bytes can cross through the current out position.\n        end = offset + length;\n        while ((offset < end) && (out < (comp_Prebuf.size + uncompressedSize))\n             && (offset < (comp_Prebuf.size + uncompressedSize)))\n          dst[out++] = dst[offset++];\n      } else { // literal\n        if ((out >= (comp_Prebuf.size + uncompressedSize)) ||\n            (in >= p->size)) {\n          printf(\"Corrupted stream\\n\");\n          exit(-1);\n        }\n        dst[out++] = src[in++];\n      }\n    }\n    // copy it back without the prebuffered data\n    src = dst;\n    dst = calloc(uncompressedSize, 1);\n    ALLOCCHECK_CHAR(dst);\n    memcpy(dst, src + comp_Prebuf.size, uncompressedSize);\n    free(src);\n    *size = uncompressedSize;\n    free(comp_Prebuf.data);\n    return dst;\n  } else { // unknown magic number\n    printf(\"Unknown compression type (magic number %x)\\n\", magic);\n  }\n  free(comp_Prebuf.data);\n  return NULL;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145096,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "BYTE *DecompressRTF(variableLength *p, int *size) {\n  BYTE *dst; // destination for uncompressed bytes\n  BYTE *src;\n  unsigned int in;\n  unsigned int out;\n  variableLength comp_Prebuf;\n  ULONG compressedSize, uncompressedSize, magic;\n\n  comp_Prebuf.size = strlen(RTF_PREBUF);\n  comp_Prebuf.data = calloc(comp_Prebuf.size+1, 1);\n  ALLOCCHECK_CHAR(comp_Prebuf.data);\n  memcpy(comp_Prebuf.data, RTF_PREBUF, comp_Prebuf.size);\n\n  src = p->data;\n  in = 0;\n\n  if (p->size < 20) {\n    printf(\"File too small\\n\");\n    return(NULL);\n  }\n  compressedSize = (ULONG)SwapDWord((BYTE*)src + in, 4);\n  in += 4;\n  uncompressedSize = (ULONG)SwapDWord((BYTE*)src + in, 4);\n  in += 4;\n  magic = SwapDWord((BYTE*)src + in, 4);\n  in += 4;\n  in += 4;\n\n  // check size excluding the size field itself\n  if (compressedSize != p->size - 4) {\n    printf(\" Size Mismatch: %u != %i\\n\", compressedSize, p->size - 4);\n    free(comp_Prebuf.data);\n    return NULL;\n  }\n\n  // process the data\n  if (magic == 0x414c454d) {\n    // magic number that identifies the stream as a uncompressed stream\n    dst = calloc(uncompressedSize, 1);\n    ALLOCCHECK_CHAR(dst);\n    memcpy(dst, src + 4, uncompressedSize);\n  } else if (magic == 0x75465a4c) {\n    // magic number that identifies the stream as a compressed stream\n    int flagCount = 0;\n    int flags = 0;\n    // Prevent overflow on 32 Bit Systems\n    if (comp_Prebuf.size >= INT_MAX - uncompressedSize) {\n       printf(\"Corrupted file\\n\");\n       exit(-1);\n    }\n    dst = calloc(comp_Prebuf.size + uncompressedSize, 1);\n    ALLOCCHECK_CHAR(dst);\n    memcpy(dst, comp_Prebuf.data, comp_Prebuf.size);\n    out = comp_Prebuf.size;\n    while ((out < (comp_Prebuf.size + uncompressedSize)) && (in < p->size)) {\n      // each flag byte flags 8 literals/references, 1 per bit\n      flags = (flagCount++ % 8 == 0) ? src[in++] : flags >> 1;\n      if ((flags & 1) == 1) { // each flag bit is 1 for reference, 0 for literal\n        unsigned int offset = src[in++];\n        unsigned int length = src[in++];\n        unsigned int end;\n        offset = (offset << 4) | (length >> 4); // the offset relative to block start\n        length = (length & 0xF) + 2; // the number of bytes to copy\n        // the decompression buffer is supposed to wrap around back\n        // to the beginning when the end is reached. we save the\n        // need for such a buffer by pointing straight into the data\n        // buffer, and simulating this behaviour by modifying the\n        // pointers appropriately.\n        offset = (out / 4096) * 4096 + offset;\n        if (offset >= out) // take from previous block\n          offset -= 4096;\n        // note: can't use System.arraycopy, because the referenced\n        // bytes can cross through the current out position.\n        end = offset + length;\n        while ((offset < end) && (out < (comp_Prebuf.size + uncompressedSize))\n             && (offset < (comp_Prebuf.size + uncompressedSize)))\n          dst[out++] = dst[offset++];\n      } else { // literal\n        if ((out >= (comp_Prebuf.size + uncompressedSize)) ||\n            (in >= p->size)) {\n          printf(\"Corrupted stream\\n\");\n          exit(-1);\n        }\n        dst[out++] = src[in++];\n      }\n    }\n    // copy it back without the prebuffered data\n    src = dst;\n    dst = calloc(uncompressedSize, 1);\n    ALLOCCHECK_CHAR(dst);\n    memcpy(dst, src + comp_Prebuf.size, uncompressedSize);\n    free(src);\n    *size = uncompressedSize;\n    free(comp_Prebuf.data);\n    return dst;\n  } else { // unknown magic number\n    printf(\"Unknown compression type (magic number %x)\\n\", magic);\n  }\n  free(comp_Prebuf.data);\n  return NULL;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145097,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "bool ZipCommon::isValidPath(const std::string& path)\n{\n\tif (path == \"..\")\n\t\treturn false;\n\tif (path.compare(0, 3, \"../\") == 0)\n\t\treturn false;\n\tif (path.compare(0, 3, \"..\\\\\") == 0)\n\t\treturn false;\n\tif (path.find(\"/..\") != std::string::npos)\n\t\treturn false;\n\tif (path.find(\"\\\\..\") != std::string::npos)\n\t\treturn false;\n\treturn true;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145290,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "bool ZipCommon::isValidPath(const std::string& path)\n{\n\ttry\n\t{\n\t\tif (Path(path, Path::PATH_UNIX).isAbsolute() || Path(path, Path::PATH_WINDOWS).isAbsolute())\n\t\t\treturn false;\n\t}\n\tcatch (...)\n\t{\n\t\treturn false;\n\t}\n\n\tif (path == \"..\")\n\t\treturn false;\n\tif ((path.size() >= 3) && path.compare(0, 3, \"../\") == 0)\n\t\treturn false;\n\tif ((path.size() >= 3) && path.compare(0, 3, \"..\\\\\") == 0)\n\t\treturn false;\n\tif (path.find(\"/../\") != std::string::npos)\n\t\treturn false;\n\tif (path.find(\"\\\\..\\\\\") != std::string::npos)\n\t\treturn false;\n\tif (path.find(\"/..\\\\\") != std::string::npos)\n\t\treturn false;\n\tif (path.find(\"\\\\../\") != std::string::npos)\n\t\treturn false;\n\tif ((path.size() >= 2) && path.compare(0, 2, \"~/\") == 0)\n\t\treturn false;\n\n\treturn true;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145291,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "sanitize_filename (const char *file_name)\n{\n\tsize_t      prefix_len;\n\tchar const *p;\n\n\tif (file_name == NULL)\n\t\treturn NULL;\n\n\tprefix_len = 0;\n\tfor (p = file_name; *p; ) {\n\t\tif (ISDOT (p[0]) && ISDOT (p[1]) && (ISSLASH (p[2]) || !p[2]))\n\t\t\tprefix_len = p + 2 - file_name;\n\n\t\tdo {\n\t\t\tchar c = *p++;\n\t\t\tif (ISSLASH (c))\n\t\t\t\tbreak;\n\t\t}\n\t\twhile (*p);\n\t}\n\n\tp = file_name + prefix_len;\n\twhile (ISSLASH (*p))\n\t\tp++;\n\n\treturn p;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145452,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "sanitize_filename (const char *file_name)\n{\n\tsize_t      prefix_len;\n\tchar const *p;\n\n\tif (file_name == NULL)\n\t\treturn NULL;\n\n\tprefix_len = 0;\n\tfor (p = file_name; *p; ) {\n\t\tif (ISDOT (p[0]) && ISDOT (p[1]) && (ISSLASH (p[2]) || !p[2]))\n\t\t\treturn NULL;\n\n\t\tdo {\n\t\t\tchar c = *p++;\n\t\t\tif (ISSLASH (c))\n\t\t\t\tbreak;\n\t\t}\n\t\twhile (*p);\n\t}\n\n\tp = file_name + prefix_len;\n\twhile (ISSLASH (*p))\n\t\tp++;\n\n\treturn p;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145453,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "scrollback_get_filename (session *sess)\n{\n\tchar *net, *chan, *buf, *ret = NULL;\n\n\tnet = server_get_network (sess->server, FALSE);\n\tif (!net)\n\t\treturn NULL;\n\n\tbuf = g_strdup_printf (\"%s\" G_DIR_SEPARATOR_S \"scrollback\" G_DIR_SEPARATOR_S \"%s\" G_DIR_SEPARATOR_S \"%s.txt\", get_xdir (), net, \"\");\n\tmkdir_p (buf);\n\tg_free (buf);\n\n\tchan = log_create_filename (sess->channel);\n\tif (chan[0])\n\t\tbuf = g_strdup_printf (\"%s\" G_DIR_SEPARATOR_S \"scrollback\" G_DIR_SEPARATOR_S \"%s\" G_DIR_SEPARATOR_S \"%s.txt\", get_xdir (), net, chan);\n\telse\n\t\tbuf = NULL;\n\tg_free (chan);\n\n\tif (buf)\n\t{\n\t\tret = g_filename_from_utf8 (buf, -1, NULL, NULL, NULL);\n\t\tg_free (buf);\n\t}\n\n\treturn ret;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145474,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "scrollback_get_filename (session *sess)\n{\n\tchar *net, *chan, *buf, *ret = NULL;\n\n\tnet = server_get_network (sess->server, FALSE);\n\tif (!net)\n\t\treturn NULL;\n\n\tnet = log_create_filename (net);\n\tbuf = g_strdup_printf (\"%s\" G_DIR_SEPARATOR_S \"scrollback\" G_DIR_SEPARATOR_S \"%s\" G_DIR_SEPARATOR_S \"%s.txt\", get_xdir (), net, \"\");\n\tmkdir_p (buf);\n\tg_free (buf);\n\n\tchan = log_create_filename (sess->channel);\n\tif (chan[0])\n\t\tbuf = g_strdup_printf (\"%s\" G_DIR_SEPARATOR_S \"scrollback\" G_DIR_SEPARATOR_S \"%s\" G_DIR_SEPARATOR_S \"%s.txt\", get_xdir (), net, chan);\n\telse\n\t\tbuf = NULL;\n\tg_free (chan);\n\tg_free (net);\n\n\tif (buf)\n\t{\n\t\tret = g_filename_from_utf8 (buf, -1, NULL, NULL, NULL);\n\t\tg_free (buf);\n\t}\n\n\treturn ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145475,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "header_cache_t* imap_hcache_open (IMAP_DATA* idata, const char* path)\n{\n  IMAP_MBOX mx;\n  ciss_url_t url;\n  char cachepath[LONG_STRING];\n  char mbox[LONG_STRING];\n\n  if (path)\n    imap_cachepath (idata, path, mbox, sizeof (mbox));\n  else\n  {\n    if (!idata->ctx || imap_parse_path (idata->ctx->path, &mx) < 0)\n      return NULL;\n\n    imap_cachepath (idata, mx.mbox, mbox, sizeof (mbox));\n    FREE (&mx.mbox);\n  }\n\n  mutt_account_tourl (&idata->conn->account, &url);\n  url.path = mbox;\n  url_ciss_tostring (&url, cachepath, sizeof (cachepath), U_PATH);\n\n  return mutt_hcache_open (HeaderCache, cachepath, imap_hcache_namer);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145886,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "header_cache_t* imap_hcache_open (IMAP_DATA* idata, const char* path)\n{\n  IMAP_MBOX mx;\n  ciss_url_t url;\n  char cachepath[LONG_STRING];\n  char mbox[LONG_STRING];\n  size_t len;\n\n  if (path)\n    imap_cachepath (idata, path, mbox, sizeof (mbox));\n  else\n  {\n    if (!idata->ctx || imap_parse_path (idata->ctx->path, &mx) < 0)\n      return NULL;\n\n    imap_cachepath (idata, mx.mbox, mbox, sizeof (mbox));\n    FREE (&mx.mbox);\n  }\n\n  if (strstr(mbox, \"/../\") || (strcmp(mbox, \"..\") == 0) || (strncmp(mbox, \"../\", 3) == 0))\n    return NULL;\n  len = strlen(mbox);\n  if ((len > 3) && (strcmp(mbox + len - 3, \"/..\") == 0))\n    return NULL;\n\n  mutt_account_tourl (&idata->conn->account, &url);\n  url.path = mbox;\n  url_ciss_tostring (&url, cachepath, sizeof (cachepath), U_PATH);\n\n  return mutt_hcache_open (HeaderCache, cachepath, imap_hcache_namer);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145887,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "save_config(\n\tstruct recvbuf *rbufp,\n\tint restrict_mask\n\t)\n{\n\tchar reply[128];\n#ifdef SAVECONFIG\n\tchar filespec[128];\n\tchar filename[128];\n\tchar fullpath[512];\n\tconst char savedconfig_eq[] = \"savedconfig=\";\n\tchar savedconfig[sizeof(savedconfig_eq) + sizeof(filename)];\n\ttime_t now;\n\tint fd;\n\tFILE *fptr;\n#endif\n\n\tif (RES_NOMODIFY & restrict_mask) {\n\t\tsnprintf(reply, sizeof(reply),\n\t\t\t \"saveconfig prohibited by restrict ... nomodify\");\n\t\tctl_putdata(reply, strlen(reply), 0);\n\t\tctl_flushpkt(0);\n\t\tNLOG(NLOG_SYSINFO)\n\t\t\tmsyslog(LOG_NOTICE,\n\t\t\t\t\"saveconfig from %s rejected due to nomodify restriction\",\n\t\t\t\tstoa(&rbufp->recv_srcadr));\n\t\tsys_restricted++;\n\t\treturn;\n\t}\n\n#ifdef SAVECONFIG\n\tif (NULL == saveconfigdir) {\n\t\tsnprintf(reply, sizeof(reply),\n\t\t\t \"saveconfig prohibited, no saveconfigdir configured\");\n\t\tctl_putdata(reply, strlen(reply), 0);\n\t\tctl_flushpkt(0);\n\t\tNLOG(NLOG_SYSINFO)\n\t\t\tmsyslog(LOG_NOTICE,\n\t\t\t\t\"saveconfig from %s rejected, no saveconfigdir\",\n\t\t\t\tstoa(&rbufp->recv_srcadr));\n\t\treturn;\n\t}\n\n\tif (0 == reqend - reqpt)\n\t\treturn;\n\n\tstrlcpy(filespec, reqpt, sizeof(filespec));\n\ttime(&now);\n\n\t/*\n\t * allow timestamping of the saved config filename with\n\t * strftime() format such as:\n\t *   ntpq -c \"saveconfig ntp-%Y%m%d-%H%M%S.conf\"\n\t * XXX: Nice feature, but not too safe.\n\t */\n\tif (0 == strftime(filename, sizeof(filename), filespec,\n\t\t\t       localtime(&now)))\n\t\tstrlcpy(filename, filespec, sizeof(filename));\n\n\t/*\n\t * Conceptually we should be searching for DIRSEP in filename,\n\t * however Windows actually recognizes both forward and\n\t * backslashes as equivalent directory separators at the API\n\t * level.  On POSIX systems we could allow '\\\\' but such\n\t * filenames are tricky to manipulate from a shell, so just\n\t * reject both types of slashes on all platforms.\n\t */\n\tif (strchr(filename, '\\\\') || strchr(filename, '/')) {\n\t\tsnprintf(reply, sizeof(reply),\n\t\t\t \"saveconfig does not allow directory in filename\");\n\t\tctl_putdata(reply, strlen(reply), 0);\n\t\tctl_flushpkt(0);\n\t\tmsyslog(LOG_NOTICE,\n\t\t\t\"saveconfig with path from %s rejected\",\n\t\t\tstoa(&rbufp->recv_srcadr));\n\t\treturn;\n\t}\n\n\tsnprintf(fullpath, sizeof(fullpath), \"%s%s\",\n\t\t saveconfigdir, filename);\n\n\tfd = open(fullpath, O_CREAT | O_TRUNC | O_WRONLY,\n\t\t  S_IRUSR | S_IWUSR);\n\tif (-1 == fd)\n\t\tfptr = NULL;\n\telse\n\t\tfptr = fdopen(fd, \"w\");\n\n\tif (NULL == fptr || -1 == dump_all_config_trees(fptr, 1)) {\n\t\tsnprintf(reply, sizeof(reply),\n\t\t\t \"Unable to save configuration to file %s\",\n\t\t\t filename);\n\t\tmsyslog(LOG_ERR,\n\t\t\t\"saveconfig %s from %s failed\", filename,\n\t\t\tstoa(&rbufp->recv_srcadr));\n\t} else {\n\t\tsnprintf(reply, sizeof(reply),\n\t\t\t \"Configuration saved to %s\", filename);\n\t\tmsyslog(LOG_NOTICE,\n\t\t\t\"Configuration saved to %s (requested by %s)\",\n\t\t\tfullpath, stoa(&rbufp->recv_srcadr));\n\t\t/*\n\t\t * save the output filename in system variable\n\t\t * savedconfig, retrieved with:\n\t\t *   ntpq -c \"rv 0 savedconfig\"\n\t\t */\n\t\tsnprintf(savedconfig, sizeof(savedconfig), \"%s%s\",\n\t\t\t savedconfig_eq, filename);\n\t\tset_sys_var(savedconfig, strlen(savedconfig) + 1, RO);\n\t}\n\n\tif (NULL != fptr)\n\t\tfclose(fptr);\n#else\t/* !SAVECONFIG follows */\n\tsnprintf(reply, sizeof(reply),\n\t\t \"saveconfig unavailable, configured with --disable-saveconfig\");\n#endif\n\n\tctl_putdata(reply, strlen(reply), 0);\n\tctl_flushpkt(0);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146514,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "save_config(\n\tstruct recvbuf *rbufp,\n\tint restrict_mask\n\t)\n{\n\t/* block directory traversal by searching for characters that\n\t * indicate directory components in a file path.\n\t *\n\t * Conceptually we should be searching for DIRSEP in filename,\n\t * however Windows actually recognizes both forward and\n\t * backslashes as equivalent directory separators at the API\n\t * level.  On POSIX systems we could allow '\\\\' but such\n\t * filenames are tricky to manipulate from a shell, so just\n\t * reject both types of slashes on all platforms.\n\t */\t\n\t/* TALOS-CAN-0062: block directory traversal for VMS, too */\n\tstatic const char * illegal_in_filename =\n#if defined(VMS)\n\t    \":[]\"\t/* do not allow drive and path components here */\n#elif defined(SYS_WINNT)\n\t    \":\\\\/\"\t/* path and drive separators */\n#else\n\t    \"\\\\/\"\t/* separator and critical char for POSIX */\n#endif\n\t    ;\n\n\n\tchar reply[128];\n#ifdef SAVECONFIG\n\tchar filespec[128];\n\tchar filename[128];\n\tchar fullpath[512];\n\tconst char savedconfig_eq[] = \"savedconfig=\";\n\tchar savedconfig[sizeof(savedconfig_eq) + sizeof(filename)];\n\ttime_t now;\n\tint fd;\n\tFILE *fptr;\n#endif\n\n\tif (RES_NOMODIFY & restrict_mask) {\n\t\tsnprintf(reply, sizeof(reply),\n\t\t\t \"saveconfig prohibited by restrict ... nomodify\");\n\t\tctl_putdata(reply, strlen(reply), 0);\n\t\tctl_flushpkt(0);\n\t\tNLOG(NLOG_SYSINFO)\n\t\t\tmsyslog(LOG_NOTICE,\n\t\t\t\t\"saveconfig from %s rejected due to nomodify restriction\",\n\t\t\t\tstoa(&rbufp->recv_srcadr));\n\t\tsys_restricted++;\n\t\treturn;\n\t}\n\n#ifdef SAVECONFIG\n\tif (NULL == saveconfigdir) {\n\t\tsnprintf(reply, sizeof(reply),\n\t\t\t \"saveconfig prohibited, no saveconfigdir configured\");\n\t\tctl_putdata(reply, strlen(reply), 0);\n\t\tctl_flushpkt(0);\n\t\tNLOG(NLOG_SYSINFO)\n\t\t\tmsyslog(LOG_NOTICE,\n\t\t\t\t\"saveconfig from %s rejected, no saveconfigdir\",\n\t\t\t\tstoa(&rbufp->recv_srcadr));\n\t\treturn;\n\t}\n\n\tif (0 == reqend - reqpt)\n\t\treturn;\n\n\tstrlcpy(filespec, reqpt, sizeof(filespec));\n\ttime(&now);\n\n\t/*\n\t * allow timestamping of the saved config filename with\n\t * strftime() format such as:\n\t *   ntpq -c \"saveconfig ntp-%Y%m%d-%H%M%S.conf\"\n\t * XXX: Nice feature, but not too safe.\n\t */\n\tif (0 == strftime(filename, sizeof(filename), filespec,\n\t\t\t       localtime(&now)))\n\t\tstrlcpy(filename, filespec, sizeof(filename));\n\n\t/* block directory/drive traversal */\n\t/* TALOS-CAN-0062: block directory traversal for VMS, too */\n\tif (NULL != strpbrk(filename, illegal_in_filename)) {\n\t\tsnprintf(reply, sizeof(reply),\n\t\t\t \"saveconfig does not allow directory in filename\");\n\t\tctl_putdata(reply, strlen(reply), 0);\n\t\tctl_flushpkt(0);\n\t\tmsyslog(LOG_NOTICE,\n\t\t\t\"saveconfig with path from %s rejected\",\n\t\t\tstoa(&rbufp->recv_srcadr));\n\t\treturn;\n\t}\n\n\tsnprintf(fullpath, sizeof(fullpath), \"%s%s\",\n\t\t saveconfigdir, filename);\n\n\tfd = open(fullpath, O_CREAT | O_TRUNC | O_WRONLY,\n\t\t  S_IRUSR | S_IWUSR);\n\tif (-1 == fd)\n\t\tfptr = NULL;\n\telse\n\t\tfptr = fdopen(fd, \"w\");\n\n\tif (NULL == fptr || -1 == dump_all_config_trees(fptr, 1)) {\n\t\tsnprintf(reply, sizeof(reply),\n\t\t\t \"Unable to save configuration to file %s\",\n\t\t\t filename);\n\t\tmsyslog(LOG_ERR,\n\t\t\t\"saveconfig %s from %s failed\", filename,\n\t\t\tstoa(&rbufp->recv_srcadr));\n\t} else {\n\t\tsnprintf(reply, sizeof(reply),\n\t\t\t \"Configuration saved to %s\", filename);\n\t\tmsyslog(LOG_NOTICE,\n\t\t\t\"Configuration saved to %s (requested by %s)\",\n\t\t\tfullpath, stoa(&rbufp->recv_srcadr));\n\t\t/*\n\t\t * save the output filename in system variable\n\t\t * savedconfig, retrieved with:\n\t\t *   ntpq -c \"rv 0 savedconfig\"\n\t\t */\n\t\tsnprintf(savedconfig, sizeof(savedconfig), \"%s%s\",\n\t\t\t savedconfig_eq, filename);\n\t\tset_sys_var(savedconfig, strlen(savedconfig) + 1, RO);\n\t}\n\n\tif (NULL != fptr)\n\t\tfclose(fptr);\n#else\t/* !SAVECONFIG follows */\n\tsnprintf(reply, sizeof(reply),\n\t\t \"saveconfig unavailable, configured with --disable-saveconfig\");\n#endif\n\n\tctl_putdata(reply, strlen(reply), 0);\n\tctl_flushpkt(0);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146515,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "bool Utility::UnZip(const QString &zippath, const QString &destpath)\n{\n    int res = 0;\n    QDir dir(destpath);\n    if (!cp437) {\n        cp437 = new QCodePage437Codec();\n    }\n#ifdef Q_OS_WIN32\n    zlib_filefunc64_def ffunc;\n    fill_win32_filefunc64W(&ffunc);\n    unzFile zfile = unzOpen2_64(Utility::QStringToStdWString(QDir::toNativeSeparators(zippath)).c_str(), &ffunc);\n#else\n    unzFile zfile = unzOpen64(QDir::toNativeSeparators(zippath).toUtf8().constData());\n#endif\n\n    if ((zfile == NULL) || (!IsFileReadable(zippath)) || (!dir.exists())) {\n        return false;\n    }\n\n    res = unzGoToFirstFile(zfile);\n\n    if (res == UNZ_OK) {\n        do {\n            // Get the name of the file in the archive.\n            char file_name[MAX_PATH] = {0};\n            unz_file_info64 file_info;\n            unzGetCurrentFileInfo64(zfile, &file_info, file_name, MAX_PATH, NULL, 0, NULL, 0);\n            QString qfile_name;\n            QString cp437_file_name;\n            qfile_name = QString::fromUtf8(file_name);\n            if (!(file_info.flag & (1<<11))) {\n                // General purpose bit 11 says the filename is utf-8 encoded. If not set then\n                // IBM 437 encoding might be used.\n                cp437_file_name = cp437->toUnicode(file_name);\n            }\n\n            // If there is no file name then we can't do anything with it.\n            if (!qfile_name.isEmpty()) {\n                // We use the dir object to create the path in the temporary directory.\n                // Unfortunately, we need a dir ojbect to do this as it's not a static function.\n                // Full file path in the temporary directory.\n                QString file_path = destpath + \"/\" + qfile_name;\n                QFileInfo qfile_info(file_path);\n\n                // Is this entry a directory?\n                if (file_info.uncompressed_size == 0 && qfile_name.endsWith('/')) {\n                    dir.mkpath(qfile_name);\n                    continue;\n                } else {\n                    dir.mkpath(qfile_info.path());\n                }\n\n                // Open the file entry in the archive for reading.\n                if (unzOpenCurrentFile(zfile) != UNZ_OK) {\n                    unzClose(zfile);\n                    return false;\n                }\n\n                // Open the file on disk to write the entry in the archive to.\n                QFile entry(file_path);\n\n                if (!entry.open(QIODevice::WriteOnly | QIODevice::Truncate)) {\n                    unzCloseCurrentFile(zfile);\n                    unzClose(zfile);\n                    return false;\n                }\n\n                // Buffered reading and writing.\n                char buff[BUFF_SIZE] = {0};\n                int read = 0;\n\n                while ((read = unzReadCurrentFile(zfile, buff, BUFF_SIZE)) > 0) {\n                    entry.write(buff, read);\n                }\n\n                entry.close();\n\n                // Read errors are marked by a negative read amount.\n                if (read < 0) {\n                    unzCloseCurrentFile(zfile);\n                    unzClose(zfile);\n                    return false;\n                }\n\n                // The file was read but the CRC did not match.\n                // We don't check the read file size vs the uncompressed file size\n                // because if they're different there should be a CRC error.\n                if (unzCloseCurrentFile(zfile) == UNZ_CRCERROR) {\n                    unzClose(zfile);\n                    return false;\n                }\n\n                if (!cp437_file_name.isEmpty() && cp437_file_name != qfile_name) {\n                    QString cp437_file_path = destpath + \"/\" + cp437_file_name;\n                    QFile::copy(file_path, cp437_file_path);\n                }\n            }\n        } while ((res = unzGoToNextFile(zfile)) == UNZ_OK);\n    }\n\n    if (res != UNZ_END_OF_LIST_OF_FILE) {\n        unzClose(zfile);\n        return false;\n    }\n\n    unzClose(zfile);\n    return true;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146548,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "bool Utility::UnZip(const QString &zippath, const QString &destpath)\n{\n    int res = 0;\n    QDir dir(destpath);\n    if (!cp437) {\n        cp437 = new QCodePage437Codec();\n    }\n#ifdef Q_OS_WIN32\n    zlib_filefunc64_def ffunc;\n    fill_win32_filefunc64W(&ffunc);\n    unzFile zfile = unzOpen2_64(Utility::QStringToStdWString(QDir::toNativeSeparators(zippath)).c_str(), &ffunc);\n#else\n    unzFile zfile = unzOpen64(QDir::toNativeSeparators(zippath).toUtf8().constData());\n#endif\n\n    if ((zfile == NULL) || (!IsFileReadable(zippath)) || (!dir.exists())) {\n        return false;\n    }\n\n    res = unzGoToFirstFile(zfile);\n\n    if (res == UNZ_OK) {\n        do {\n            // Get the name of the file in the archive.\n            char file_name[MAX_PATH] = {0};\n            unz_file_info64 file_info;\n            unzGetCurrentFileInfo64(zfile, &file_info, file_name, MAX_PATH, NULL, 0, NULL, 0);\n            QString qfile_name;\n            QString cp437_file_name;\n            qfile_name = QString::fromUtf8(file_name);\n            if (!(file_info.flag & (1<<11))) {\n                // General purpose bit 11 says the filename is utf-8 encoded. If not set then\n                // IBM 437 encoding might be used.\n                cp437_file_name = cp437->toUnicode(file_name);\n            }\n\n            // If there is no file name then we can't do anything with it.\n            if (!qfile_name.isEmpty()) {\n\n\t        // for security reasons against maliciously crafted zip archives\n\t        // we need the file path to always be inside the target folder \n\t        // and not outside, so we will remove all illegal backslashes\n\t        // and all relative upward paths segments \"/../\" from the zip's local \n\t        // file name/path before prepending the target folder to create \n\t        // the final path\n\n\t        QString original_path = qfile_name;\n\t        bool evil_or_corrupt_epub = false;\n\n\t        if (qfile_name.contains(\"\\\\\")) evil_or_corrupt_epub = true; \n\t        qfile_name = \"/\" + qfile_name.replace(\"\\\\\",\"\");\n\n\t        if (qfile_name.contains(\"/../\")) evil_or_corrupt_epub = true;\n\t        qfile_name = qfile_name.replace(\"/../\",\"/\");\n\n\t        while(qfile_name.startsWith(\"/\")) { \n\t\t  qfile_name = qfile_name.remove(0,1);\n\t        }\n                \n\t        if (cp437_file_name.contains(\"\\\\\")) evil_or_corrupt_epub = true; \n\t        cp437_file_name = \"/\" + cp437_file_name.replace(\"\\\\\",\"\");\n\n\t        if (cp437_file_name.contains(\"/../\")) evil_or_corrupt_epub = true;\n\t        cp437_file_name = cp437_file_name.replace(\"/../\",\"/\");\n\n\t        while(cp437_file_name.startsWith(\"/\")) { \n\t\t  cp437_file_name = cp437_file_name.remove(0,1);\n\t        }\n\n\t        if (evil_or_corrupt_epub) {\n\t\t    unzCloseCurrentFile(zfile);\n\t\t    unzClose(zfile);\n\t\t    // throw (UNZIPLoadParseError(QString(QObject::tr(\"Possible evil or corrupt zip file name: %1\")).arg(original_path).toStdString()));\n                    return false;\n\t        }\n\n                // We use the dir object to create the path in the temporary directory.\n                // Unfortunately, we need a dir ojbect to do this as it's not a static function.\n                // Full file path in the temporary directory.\n                QString file_path = destpath + \"/\" + qfile_name;\n                QFileInfo qfile_info(file_path);\n\n                // Is this entry a directory?\n                if (file_info.uncompressed_size == 0 && qfile_name.endsWith('/')) {\n                    dir.mkpath(qfile_name);\n                    continue;\n                } else {\n                    dir.mkpath(qfile_info.path());\n                }\n\n                // Open the file entry in the archive for reading.\n                if (unzOpenCurrentFile(zfile) != UNZ_OK) {\n                    unzClose(zfile);\n                    return false;\n                }\n\n                // Open the file on disk to write the entry in the archive to.\n                QFile entry(file_path);\n\n                if (!entry.open(QIODevice::WriteOnly | QIODevice::Truncate)) {\n                    unzCloseCurrentFile(zfile);\n                    unzClose(zfile);\n                    return false;\n                }\n\n                // Buffered reading and writing.\n                char buff[BUFF_SIZE] = {0};\n                int read = 0;\n\n                while ((read = unzReadCurrentFile(zfile, buff, BUFF_SIZE)) > 0) {\n                    entry.write(buff, read);\n                }\n\n                entry.close();\n\n                // Read errors are marked by a negative read amount.\n                if (read < 0) {\n                    unzCloseCurrentFile(zfile);\n                    unzClose(zfile);\n                    return false;\n                }\n\n                // The file was read but the CRC did not match.\n                // We don't check the read file size vs the uncompressed file size\n                // because if they're different there should be a CRC error.\n                if (unzCloseCurrentFile(zfile) == UNZ_CRCERROR) {\n                    unzClose(zfile);\n                    return false;\n                }\n\n                if (!cp437_file_name.isEmpty() && cp437_file_name != qfile_name) {\n                    QString cp437_file_path = destpath + \"/\" + cp437_file_name;\n                    QFile::copy(file_path, cp437_file_path);\n                }\n            }\n        } while ((res = unzGoToNextFile(zfile)) == UNZ_OK);\n    }\n\n    if (res != UNZ_END_OF_LIST_OF_FILE) {\n        unzClose(zfile);\n        return false;\n    }\n\n    unzClose(zfile);\n    return true;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146549,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "LoadPage::LoadPage():\n\tjsdelay(200),\n\twindowStatus(\"\"),\n\tzoomFactor(1.0),\n\trepeatCustomHeaders(false),\n\tblockLocalFileAccess(false),\n\tstopSlowScripts(true),\n\tdebugJavascript(false),\n\tloadErrorHandling(abort),\n\tmediaLoadErrorHandling(ignore),\n\tcacheDir(\"\"),\n\tproxyHostNameLookup(false) {};",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146630,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "LoadPage::LoadPage():\n\tjsdelay(200),\n\twindowStatus(\"\"),\n\tzoomFactor(1.0),\n\trepeatCustomHeaders(false),\n\tblockLocalFileAccess(true),\n\tstopSlowScripts(true),\n\tdebugJavascript(false),\n\tloadErrorHandling(abort),\n\tmediaLoadErrorHandling(ignore),\n\tcacheDir(\"\"),\n\tproxyHostNameLookup(false) {};",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146631,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "static void handle_method_call(GDBusConnection *connection,\n                        const gchar *caller,\n                        const gchar *object_path,\n                        const gchar *interface_name,\n                        const gchar *method_name,\n                        GVariant    *parameters,\n                        GDBusMethodInvocation *invocation,\n                        gpointer    user_data)\n{\n    reset_timeout();\n\n    uid_t caller_uid;\n    GVariant *response;\n\n    caller_uid = get_caller_uid(connection, invocation, caller);\n\n    log_notice(\"caller_uid:%ld method:'%s'\", (long)caller_uid, method_name);\n\n    if (caller_uid == (uid_t) -1)\n        return;\n\n    if (g_strcmp0(method_name, \"NewProblem\") == 0)\n    {\n        char *error = NULL;\n        char *problem_id = handle_new_problem(g_variant_get_child_value(parameters, 0), caller_uid, &error);\n        if (!problem_id)\n        {\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                                      \"org.freedesktop.problems.Failure\",\n                                                      error);\n            free(error);\n            return;\n        }\n        /* else */\n        response = g_variant_new(\"(s)\", problem_id);\n        g_dbus_method_invocation_return_value(invocation, response);\n        free(problem_id);\n\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetProblems\") == 0)\n    {\n        GList *dirs = get_problem_dirs_for_uid(caller_uid, g_settings_dump_location);\n        response = variant_from_string_list(dirs);\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        //I was told that g_dbus_method frees the response\n        //g_variant_unref(response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetAllProblems\") == 0)\n    {\n        /*\n        - so, we have UID,\n        - if it's 0, then we don't have to check anything and just return all directories\n        - if uid != 0 then we want to ask for authorization\n        */\n        if (caller_uid != 0)\n        {\n            if (polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") == PolkitYes)\n                caller_uid = 0;\n        }\n\n        GList * dirs = get_problem_dirs_for_uid(caller_uid, g_settings_dump_location);\n        response = variant_from_string_list(dirs);\n\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetForeignProblems\") == 0)\n    {\n        GList * dirs = get_problem_dirs_not_accessible_by_uid(caller_uid, g_settings_dump_location);\n        response = variant_from_string_list(dirs);\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"ChownProblemDir\") == 0)\n    {\n        const gchar *problem_dir;\n        g_variant_get(parameters, \"(&s)\", &problem_dir);\n        log_notice(\"problem_dir:'%s'\", problem_dir);\n\n        if (!allowed_problem_dir(problem_dir))\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int dir_fd = dd_openfd(problem_dir);\n        if (dir_fd < 0)\n        {\n            perror_msg(\"can't open problem directory '%s'\", problem_dir);\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int ddstat = fdump_dir_stat_for_uid(dir_fd, caller_uid);\n        if (ddstat < 0)\n        {\n            if (errno == ENOTDIR)\n            {\n                log_notice(\"requested directory does not exist '%s'\", problem_dir);\n            }\n            else\n            {\n                perror_msg(\"can't get stat of '%s'\", problem_dir);\n            }\n\n            return_InvalidProblemDir_error(invocation, problem_dir);\n\n            close(dir_fd);\n            return;\n        }\n\n        if (ddstat & DD_STAT_OWNED_BY_UID)\n        {   //caller seems to be in group with access to this dir, so no action needed\n            log_notice(\"caller has access to the requested directory %s\", problem_dir);\n            g_dbus_method_invocation_return_value(invocation, NULL);\n            close(dir_fd);\n            return;\n        }\n\n        if ((ddstat & DD_STAT_ACCESSIBLE_BY_UID) == 0 &&\n                polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") != PolkitYes)\n        {\n            log_notice(\"not authorized\");\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.AuthFailure\",\n                                              _(\"Not Authorized\"));\n            close(dir_fd);\n            return;\n        }\n\n        struct dump_dir *dd = dd_fdopendir(dir_fd, problem_dir, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES);\n        if (!dd)\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int chown_res = dd_chown(dd, caller_uid);\n        if (chown_res != 0)\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.ChownError\",\n                                              _(\"Chowning directory failed. Check system logs for more details.\"));\n        else\n            g_dbus_method_invocation_return_value(invocation, NULL);\n\n        dd_close(dd);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetInfo\") == 0)\n    {\n        /* Parameter tuple is (sas) */\n\n\t/* Get 1st param - problem dir name */\n        const gchar *problem_dir;\n        g_variant_get_child(parameters, 0, \"&s\", &problem_dir);\n        log_notice(\"problem_dir:'%s'\", problem_dir);\n\n        if (!allowed_problem_dir(problem_dir))\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int dir_fd = dd_openfd(problem_dir);\n        if (dir_fd < 0)\n        {\n            perror_msg(\"can't open problem directory '%s'\", problem_dir);\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        if (!fdump_dir_accessible_by_uid(dir_fd, caller_uid))\n        {\n            if (errno == ENOTDIR)\n            {\n                log_notice(\"Requested directory does not exist '%s'\", problem_dir);\n                return_InvalidProblemDir_error(invocation, problem_dir);\n                close(dir_fd);\n                return;\n            }\n\n            if (polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") != PolkitYes)\n            {\n                log_notice(\"not authorized\");\n                g_dbus_method_invocation_return_dbus_error(invocation,\n                                                  \"org.freedesktop.problems.AuthFailure\",\n                                                  _(\"Not Authorized\"));\n                close(dir_fd);\n                return;\n            }\n        }\n\n        struct dump_dir *dd = dd_fdopendir(dir_fd, problem_dir, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES);\n        if (!dd)\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n\t/* Get 2nd param - vector of element names */\n        GVariant *array = g_variant_get_child_value(parameters, 1);\n        GList *elements = string_list_from_variant(array);\n        g_variant_unref(array);\n\n        GVariantBuilder *builder = NULL;\n        for (GList *l = elements; l; l = l->next)\n        {\n            const char *element_name = (const char*)l->data;\n            char *value = dd_load_text_ext(dd, element_name, 0\n                                                | DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE\n                                                | DD_FAIL_QUIETLY_ENOENT\n                                                | DD_FAIL_QUIETLY_EACCES);\n            log_notice(\"element '%s' %s\", element_name, value ? \"fetched\" : \"not found\");\n            if (value)\n            {\n                if (!builder)\n                    builder = g_variant_builder_new(G_VARIANT_TYPE_ARRAY);\n\n                /* g_variant_builder_add makes a copy. No need to xstrdup here */\n                g_variant_builder_add(builder, \"{ss}\", element_name, value);\n                free(value);\n            }\n        }\n        list_free_with_free(elements);\n        dd_close(dd);\n        /* It is OK to call g_variant_new(\"(a{ss})\", NULL) because */\n        /* G_VARIANT_TYPE_TUPLE allows NULL value */\n        GVariant *response = g_variant_new(\"(a{ss})\", builder);\n\n        if (builder)\n            g_variant_builder_unref(builder);\n\n        log_info(\"GetInfo: returning value for '%s'\", problem_dir);\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"SetElement\") == 0)\n    {\n        const char *problem_id;\n        const char *element;\n        const char *value;\n\n        g_variant_get(parameters, \"(&s&s&s)\", &problem_id, &element, &value);\n\n        if (!str_is_correct_filename(element))\n        {\n            log_notice(\"'%s' is not a valid element name of '%s'\", element, problem_id);\n            char *error = xasprintf(_(\"'%s' is not a valid element name\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.InvalidElement\",\n                                              error);\n\n            free(error);\n            return;\n        }\n\n        struct dump_dir *dd = open_directory_for_modification_of_element(\n                                    invocation, caller_uid, problem_id, element);\n        if (!dd)\n            /* Already logged from open_directory_for_modification_of_element() */\n            return;\n\n        /* Is it good idea to make it static? Is it possible to change the max size while a single run? */\n        const double max_dir_size = g_settings_nMaxCrashReportsSize * (1024 * 1024);\n        const long item_size = dd_get_item_size(dd, element);\n        if (item_size < 0)\n        {\n            log_notice(\"Can't get size of '%s/%s'\", problem_id, element);\n            char *error = xasprintf(_(\"Can't get size of '%s'\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                                      \"org.freedesktop.problems.Failure\",\n                                                      error);\n            return;\n        }\n\n        const double requested_size = (double)strlen(value) - item_size;\n        /* Don't want to check the size limit in case of reducing of size */\n        if (requested_size > 0\n            && requested_size > (max_dir_size - get_dirsize(g_settings_dump_location)))\n        {\n            log_notice(\"No problem space left in '%s' (requested Bytes %f)\", problem_id, requested_size);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                                      \"org.freedesktop.problems.Failure\",\n                                                      _(\"No problem space left\"));\n        }\n        else\n        {\n            dd_save_text(dd, element, value);\n            g_dbus_method_invocation_return_value(invocation, NULL);\n        }\n\n        dd_close(dd);\n\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"DeleteElement\") == 0)\n    {\n        const char *problem_id;\n        const char *element;\n\n        g_variant_get(parameters, \"(&s&s)\", &problem_id, &element);\n\n        if (!str_is_correct_filename(element))\n        {\n            log_notice(\"'%s' is not a valid element name of '%s'\", element, problem_id);\n            char *error = xasprintf(_(\"'%s' is not a valid element name\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.InvalidElement\",\n                                              error);\n\n            free(error);\n            return;\n        }\n\n        struct dump_dir *dd = open_directory_for_modification_of_element(\n                                    invocation, caller_uid, problem_id, element);\n        if (!dd)\n            /* Already logged from open_directory_for_modification_of_element() */\n            return;\n\n        const int res = dd_delete_item(dd, element);\n        dd_close(dd);\n\n        if (res != 0)\n        {\n            log_notice(\"Can't delete the element '%s' from the problem directory '%s'\", element, problem_id);\n            char *error = xasprintf(_(\"Can't delete the element '%s' from the problem directory '%s'\"), element, problem_id);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                          \"org.freedesktop.problems.Failure\",\n                                          error);\n            free(error);\n            return;\n        }\n\n\n        g_dbus_method_invocation_return_value(invocation, NULL);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"DeleteProblem\") == 0)\n    {\n        /* Dbus parameters are always tuples.\n         * In this case, it's (as) - a tuple of one element (array of strings).\n         * Need to fetch the array:\n         */\n        GVariant *array = g_variant_get_child_value(parameters, 0);\n        GList *problem_dirs = string_list_from_variant(array);\n        g_variant_unref(array);\n\n        for (GList *l = problem_dirs; l; l = l->next)\n        {\n            const char *dir_name = (const char*)l->data;\n            log_notice(\"dir_name:'%s'\", dir_name);\n            if (!allowed_problem_dir(dir_name))\n            {\n                return_InvalidProblemDir_error(invocation, dir_name);\n                goto ret;\n            }\n        }\n\n        for (GList *l = problem_dirs; l; l = l->next)\n        {\n            const char *dir_name = (const char*)l->data;\n\n            int dir_fd = dd_openfd(dir_name);\n            if (dir_fd < 0)\n            {\n                perror_msg(\"can't open problem directory '%s'\", dir_name);\n                return_InvalidProblemDir_error(invocation, dir_name);\n                return;\n            }\n\n            if (!fdump_dir_accessible_by_uid(dir_fd, caller_uid))\n            {\n                if (errno == ENOTDIR)\n                {\n                    log_notice(\"Requested directory does not exist '%s'\", dir_name);\n                    close(dir_fd);\n                    continue;\n                }\n\n                if (polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") != PolkitYes)\n                { // if user didn't provide correct credentials, just move to the next dir\n                    close(dir_fd);\n                    continue;\n                }\n            }\n\n            struct dump_dir *dd = dd_fdopendir(dir_fd, dir_name, /*flags:*/ 0);\n            if (dd)\n            {\n                if (dd_delete(dd) != 0)\n                {\n                    error_msg(\"Failed to delete problem directory '%s'\", dir_name);\n                    dd_close(dd);\n                }\n            }\n        }\n\n        g_dbus_method_invocation_return_value(invocation, NULL);\n ret:\n        list_free_with_free(problem_dirs);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"FindProblemByElementInTimeRange\") == 0)\n    {\n        const gchar *element;\n        const gchar *value;\n        glong timestamp_from;\n        glong timestamp_to;\n        gboolean all;\n\n        g_variant_get_child(parameters, 0, \"&s\", &element);\n        g_variant_get_child(parameters, 1, \"&s\", &value);\n        g_variant_get_child(parameters, 2, \"x\", &timestamp_from);\n        g_variant_get_child(parameters, 3, \"x\", &timestamp_to);\n        g_variant_get_child(parameters, 4, \"b\", &all);\n\n        if (all && polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") == PolkitYes)\n            caller_uid = 0;\n\n        GList *dirs = get_problem_dirs_for_element_in_time(caller_uid, element, value, timestamp_from,\n                                                        timestamp_to);\n        response = variant_from_string_list(dirs);\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"Quit\") == 0)\n    {\n        g_dbus_method_invocation_return_value(invocation, NULL);\n        g_main_loop_quit(loop);\n        return;\n    }\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146802,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "static void handle_method_call(GDBusConnection *connection,\n                        const gchar *caller,\n                        const gchar *object_path,\n                        const gchar *interface_name,\n                        const gchar *method_name,\n                        GVariant    *parameters,\n                        GDBusMethodInvocation *invocation,\n                        gpointer    user_data)\n{\n    reset_timeout();\n\n    uid_t caller_uid;\n    GVariant *response;\n\n    caller_uid = get_caller_uid(connection, invocation, caller);\n\n    log_notice(\"caller_uid:%ld method:'%s'\", (long)caller_uid, method_name);\n\n    if (caller_uid == (uid_t) -1)\n        return;\n\n    if (g_strcmp0(method_name, \"NewProblem\") == 0)\n    {\n        char *error = NULL;\n        char *problem_id = handle_new_problem(g_variant_get_child_value(parameters, 0), caller_uid, &error);\n        if (!problem_id)\n        {\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                                      \"org.freedesktop.problems.Failure\",\n                                                      error);\n            free(error);\n            return;\n        }\n        /* else */\n        response = g_variant_new(\"(s)\", problem_id);\n        g_dbus_method_invocation_return_value(invocation, response);\n        free(problem_id);\n\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetProblems\") == 0)\n    {\n        GList *dirs = get_problem_dirs_for_uid(caller_uid, g_settings_dump_location);\n        response = variant_from_string_list(dirs);\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        //I was told that g_dbus_method frees the response\n        //g_variant_unref(response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetAllProblems\") == 0)\n    {\n        /*\n        - so, we have UID,\n        - if it's 0, then we don't have to check anything and just return all directories\n        - if uid != 0 then we want to ask for authorization\n        */\n        if (caller_uid != 0)\n        {\n            if (polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") == PolkitYes)\n                caller_uid = 0;\n        }\n\n        GList * dirs = get_problem_dirs_for_uid(caller_uid, g_settings_dump_location);\n        response = variant_from_string_list(dirs);\n\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetForeignProblems\") == 0)\n    {\n        GList * dirs = get_problem_dirs_not_accessible_by_uid(caller_uid, g_settings_dump_location);\n        response = variant_from_string_list(dirs);\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"ChownProblemDir\") == 0)\n    {\n        const gchar *problem_dir;\n        g_variant_get(parameters, \"(&s)\", &problem_dir);\n        log_notice(\"problem_dir:'%s'\", problem_dir);\n\n        if (!allowed_problem_dir(problem_dir))\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int dir_fd = dd_openfd(problem_dir);\n        if (dir_fd < 0)\n        {\n            perror_msg(\"can't open problem directory '%s'\", problem_dir);\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int ddstat = fdump_dir_stat_for_uid(dir_fd, caller_uid);\n        if (ddstat < 0)\n        {\n            if (errno == ENOTDIR)\n            {\n                log_notice(\"requested directory does not exist '%s'\", problem_dir);\n            }\n            else\n            {\n                perror_msg(\"can't get stat of '%s'\", problem_dir);\n            }\n\n            return_InvalidProblemDir_error(invocation, problem_dir);\n\n            close(dir_fd);\n            return;\n        }\n\n        if (ddstat & DD_STAT_OWNED_BY_UID)\n        {   //caller seems to be in group with access to this dir, so no action needed\n            log_notice(\"caller has access to the requested directory %s\", problem_dir);\n            g_dbus_method_invocation_return_value(invocation, NULL);\n            close(dir_fd);\n            return;\n        }\n\n        if ((ddstat & DD_STAT_ACCESSIBLE_BY_UID) == 0 &&\n                polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") != PolkitYes)\n        {\n            log_notice(\"not authorized\");\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.AuthFailure\",\n                                              _(\"Not Authorized\"));\n            close(dir_fd);\n            return;\n        }\n\n        struct dump_dir *dd = dd_fdopendir(dir_fd, problem_dir, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES);\n        if (!dd)\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int chown_res = dd_chown(dd, caller_uid);\n        if (chown_res != 0)\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.ChownError\",\n                                              _(\"Chowning directory failed. Check system logs for more details.\"));\n        else\n            g_dbus_method_invocation_return_value(invocation, NULL);\n\n        dd_close(dd);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetInfo\") == 0)\n    {\n        /* Parameter tuple is (sas) */\n\n\t/* Get 1st param - problem dir name */\n        const gchar *problem_dir;\n        g_variant_get_child(parameters, 0, \"&s\", &problem_dir);\n        log_notice(\"problem_dir:'%s'\", problem_dir);\n\n        if (!allowed_problem_dir(problem_dir))\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int dir_fd = dd_openfd(problem_dir);\n        if (dir_fd < 0)\n        {\n            perror_msg(\"can't open problem directory '%s'\", problem_dir);\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        if (!fdump_dir_accessible_by_uid(dir_fd, caller_uid))\n        {\n            if (errno == ENOTDIR)\n            {\n                log_notice(\"Requested directory does not exist '%s'\", problem_dir);\n                return_InvalidProblemDir_error(invocation, problem_dir);\n                close(dir_fd);\n                return;\n            }\n\n            if (polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") != PolkitYes)\n            {\n                log_notice(\"not authorized\");\n                g_dbus_method_invocation_return_dbus_error(invocation,\n                                                  \"org.freedesktop.problems.AuthFailure\",\n                                                  _(\"Not Authorized\"));\n                close(dir_fd);\n                return;\n            }\n        }\n\n        struct dump_dir *dd = dd_fdopendir(dir_fd, problem_dir, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES);\n        if (!dd)\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n\t/* Get 2nd param - vector of element names */\n        GVariant *array = g_variant_get_child_value(parameters, 1);\n        GList *elements = string_list_from_variant(array);\n        g_variant_unref(array);\n\n        GVariantBuilder *builder = NULL;\n        for (GList *l = elements; l; l = l->next)\n        {\n            const char *element_name = (const char*)l->data;\n            char *value = dd_load_text_ext(dd, element_name, 0\n                                                | DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE\n                                                | DD_FAIL_QUIETLY_ENOENT\n                                                | DD_FAIL_QUIETLY_EACCES);\n            log_notice(\"element '%s' %s\", element_name, value ? \"fetched\" : \"not found\");\n            if (value)\n            {\n                if (!builder)\n                    builder = g_variant_builder_new(G_VARIANT_TYPE_ARRAY);\n\n                /* g_variant_builder_add makes a copy. No need to xstrdup here */\n                g_variant_builder_add(builder, \"{ss}\", element_name, value);\n                free(value);\n            }\n        }\n        list_free_with_free(elements);\n        dd_close(dd);\n        /* It is OK to call g_variant_new(\"(a{ss})\", NULL) because */\n        /* G_VARIANT_TYPE_TUPLE allows NULL value */\n        GVariant *response = g_variant_new(\"(a{ss})\", builder);\n\n        if (builder)\n            g_variant_builder_unref(builder);\n\n        log_info(\"GetInfo: returning value for '%s'\", problem_dir);\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"SetElement\") == 0)\n    {\n        const char *problem_id;\n        const char *element;\n        const char *value;\n\n        g_variant_get(parameters, \"(&s&s&s)\", &problem_id, &element, &value);\n\n        if (!allowed_problem_dir(problem_id))\n        {\n            return_InvalidProblemDir_error(invocation, problem_id);\n            return;\n        }\n\n        if (!str_is_correct_filename(element))\n        {\n            log_notice(\"'%s' is not a valid element name of '%s'\", element, problem_id);\n            char *error = xasprintf(_(\"'%s' is not a valid element name\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.InvalidElement\",\n                                              error);\n\n            free(error);\n            return;\n        }\n\n        struct dump_dir *dd = open_directory_for_modification_of_element(\n                                    invocation, caller_uid, problem_id, element);\n        if (!dd)\n            /* Already logged from open_directory_for_modification_of_element() */\n            return;\n\n        /* Is it good idea to make it static? Is it possible to change the max size while a single run? */\n        const double max_dir_size = g_settings_nMaxCrashReportsSize * (1024 * 1024);\n        const long item_size = dd_get_item_size(dd, element);\n        if (item_size < 0)\n        {\n            log_notice(\"Can't get size of '%s/%s'\", problem_id, element);\n            char *error = xasprintf(_(\"Can't get size of '%s'\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                                      \"org.freedesktop.problems.Failure\",\n                                                      error);\n            return;\n        }\n\n        const double requested_size = (double)strlen(value) - item_size;\n        /* Don't want to check the size limit in case of reducing of size */\n        if (requested_size > 0\n            && requested_size > (max_dir_size - get_dirsize(g_settings_dump_location)))\n        {\n            log_notice(\"No problem space left in '%s' (requested Bytes %f)\", problem_id, requested_size);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                                      \"org.freedesktop.problems.Failure\",\n                                                      _(\"No problem space left\"));\n        }\n        else\n        {\n            dd_save_text(dd, element, value);\n            g_dbus_method_invocation_return_value(invocation, NULL);\n        }\n\n        dd_close(dd);\n\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"DeleteElement\") == 0)\n    {\n        const char *problem_id;\n        const char *element;\n\n        g_variant_get(parameters, \"(&s&s)\", &problem_id, &element);\n\n        if (!allowed_problem_dir(problem_id))\n        {\n            return_InvalidProblemDir_error(invocation, problem_id);\n            return;\n        }\n\n        if (!str_is_correct_filename(element))\n        {\n            log_notice(\"'%s' is not a valid element name of '%s'\", element, problem_id);\n            char *error = xasprintf(_(\"'%s' is not a valid element name\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.InvalidElement\",\n                                              error);\n\n            free(error);\n            return;\n        }\n\n        struct dump_dir *dd = open_directory_for_modification_of_element(\n                                    invocation, caller_uid, problem_id, element);\n        if (!dd)\n            /* Already logged from open_directory_for_modification_of_element() */\n            return;\n\n        const int res = dd_delete_item(dd, element);\n        dd_close(dd);\n\n        if (res != 0)\n        {\n            log_notice(\"Can't delete the element '%s' from the problem directory '%s'\", element, problem_id);\n            char *error = xasprintf(_(\"Can't delete the element '%s' from the problem directory '%s'\"), element, problem_id);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                          \"org.freedesktop.problems.Failure\",\n                                          error);\n            free(error);\n            return;\n        }\n\n\n        g_dbus_method_invocation_return_value(invocation, NULL);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"DeleteProblem\") == 0)\n    {\n        /* Dbus parameters are always tuples.\n         * In this case, it's (as) - a tuple of one element (array of strings).\n         * Need to fetch the array:\n         */\n        GVariant *array = g_variant_get_child_value(parameters, 0);\n        GList *problem_dirs = string_list_from_variant(array);\n        g_variant_unref(array);\n\n        for (GList *l = problem_dirs; l; l = l->next)\n        {\n            const char *dir_name = (const char*)l->data;\n            log_notice(\"dir_name:'%s'\", dir_name);\n            if (!allowed_problem_dir(dir_name))\n            {\n                return_InvalidProblemDir_error(invocation, dir_name);\n                goto ret;\n            }\n        }\n\n        for (GList *l = problem_dirs; l; l = l->next)\n        {\n            const char *dir_name = (const char*)l->data;\n\n            int dir_fd = dd_openfd(dir_name);\n            if (dir_fd < 0)\n            {\n                perror_msg(\"can't open problem directory '%s'\", dir_name);\n                return_InvalidProblemDir_error(invocation, dir_name);\n                return;\n            }\n\n            if (!fdump_dir_accessible_by_uid(dir_fd, caller_uid))\n            {\n                if (errno == ENOTDIR)\n                {\n                    log_notice(\"Requested directory does not exist '%s'\", dir_name);\n                    close(dir_fd);\n                    continue;\n                }\n\n                if (polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") != PolkitYes)\n                { // if user didn't provide correct credentials, just move to the next dir\n                    close(dir_fd);\n                    continue;\n                }\n            }\n\n            struct dump_dir *dd = dd_fdopendir(dir_fd, dir_name, /*flags:*/ 0);\n            if (dd)\n            {\n                if (dd_delete(dd) != 0)\n                {\n                    error_msg(\"Failed to delete problem directory '%s'\", dir_name);\n                    dd_close(dd);\n                }\n            }\n        }\n\n        g_dbus_method_invocation_return_value(invocation, NULL);\n ret:\n        list_free_with_free(problem_dirs);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"FindProblemByElementInTimeRange\") == 0)\n    {\n        const gchar *element;\n        const gchar *value;\n        glong timestamp_from;\n        glong timestamp_to;\n        gboolean all;\n\n        g_variant_get_child(parameters, 0, \"&s\", &element);\n        g_variant_get_child(parameters, 1, \"&s\", &value);\n        g_variant_get_child(parameters, 2, \"x\", &timestamp_from);\n        g_variant_get_child(parameters, 3, \"x\", &timestamp_to);\n        g_variant_get_child(parameters, 4, \"b\", &all);\n\n        if (!str_is_correct_filename(element))\n        {\n            log_notice(\"'%s' is not a valid element name\", element);\n            char *error = xasprintf(_(\"'%s' is not a valid element name\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.InvalidElement\",\n                                              error);\n\n            free(error);\n            return;\n        }\n\n        if (all && polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") == PolkitYes)\n            caller_uid = 0;\n\n        GList *dirs = get_problem_dirs_for_element_in_time(caller_uid, element, value, timestamp_from,\n                                                        timestamp_to);\n        response = variant_from_string_list(dirs);\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"Quit\") == 0)\n    {\n        g_dbus_method_invocation_return_value(invocation, NULL);\n        g_main_loop_quit(loop);\n        return;\n    }\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146803,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "void ImportEPUB::ExtractContainer()\n{\n    int res = 0;\n    if (!cp437) {\n        cp437 = new QCodePage437Codec();\n    }\n#ifdef Q_OS_WIN32\n    zlib_filefunc64_def ffunc;\n    fill_win32_filefunc64W(&ffunc);\n    unzFile zfile = unzOpen2_64(Utility::QStringToStdWString(QDir::toNativeSeparators(m_FullFilePath)).c_str(), &ffunc);\n#else\n    unzFile zfile = unzOpen64(QDir::toNativeSeparators(m_FullFilePath).toUtf8().constData());\n#endif\n\n    if (zfile == NULL) {\n        throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot unzip EPUB: %1\")).arg(QDir::toNativeSeparators(m_FullFilePath)).toStdString()));\n    }\n\n    res = unzGoToFirstFile(zfile);\n\n    if (res == UNZ_OK) {\n        do {\n            // Get the name of the file in the archive.\n            char file_name[MAX_PATH] = {0};\n            unz_file_info64 file_info;\n            unzGetCurrentFileInfo64(zfile, &file_info, file_name, MAX_PATH, NULL, 0, NULL, 0);\n            QString qfile_name;\n            QString cp437_file_name;\n            qfile_name = QString::fromUtf8(file_name);\n            if (!(file_info.flag & (1<<11))) {\n                // General purpose bit 11 says the filename is utf-8 encoded. If not set then\n                // IBM 437 encoding might be used.\n                cp437_file_name = cp437->toUnicode(file_name);\n            }\n\n            // If there is no file name then we can't do anything with it.\n            if (!qfile_name.isEmpty()) {\n\n\t        // for security reasons we need the file path to always be inside the \n                // target folder and not outside, so we will remove all relative upward \n                // paths segments \"..\" from the file path before prepending the target \n                // folder to create the final target path\n\t        qfile_name = qfile_name.replace(\"../\",\"\");\n                cp437_file_name = cp437_file_name.replace(\"../\",\"\");\n\n                // We use the dir object to create the path in the temporary directory.\n                // Unfortunately, we need a dir ojbect to do this as it's not a static function.\n                QDir dir(m_ExtractedFolderPath);\n                // Full file path in the temporary directory.\n                QString file_path = m_ExtractedFolderPath + \"/\" + qfile_name;\n                QFileInfo qfile_info(file_path);\n\n                // Is this entry a directory?\n                if (file_info.uncompressed_size == 0 && qfile_name.endsWith('/')) {\n                    dir.mkpath(qfile_name);\n                    continue;\n                } else {\n                    dir.mkpath(qfile_info.path());\n\t\t    // add it to the list of files found inside the zip\n\t\t    if (cp437_file_name.isEmpty()) {\n\t\t        m_ZipFilePaths << qfile_name;\n\t\t    } else {\n                        m_ZipFilePaths << cp437_file_name;\n\t\t    }\n                }\n\n                // Open the file entry in the archive for reading.\n                if (unzOpenCurrentFile(zfile) != UNZ_OK) {\n                    unzClose(zfile);\n                    throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot extract file: %1\")).arg(qfile_name).toStdString()));\n                }\n\n                // Open the file on disk to write the entry in the archive to.\n                QFile entry(file_path);\n\n                if (!entry.open(QIODevice::WriteOnly | QIODevice::Truncate)) {\n                    unzCloseCurrentFile(zfile);\n                    unzClose(zfile);\n                    throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot extract file: %1\")).arg(qfile_name).toStdString()));\n                }\n\n                // Buffered reading and writing.\n                char buff[BUFF_SIZE] = {0};\n                int read = 0;\n\n                while ((read = unzReadCurrentFile(zfile, buff, BUFF_SIZE)) > 0) {\n                    entry.write(buff, read);\n                }\n\n                entry.close();\n\n                // Read errors are marked by a negative read amount.\n                if (read < 0) {\n                    unzCloseCurrentFile(zfile);\n                    unzClose(zfile);\n                    throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot extract file: %1\")).arg(qfile_name).toStdString()));\n                }\n\n                // The file was read but the CRC did not match.\n                // We don't check the read file size vs the uncompressed file size\n                // because if they're different there should be a CRC error.\n                if (unzCloseCurrentFile(zfile) == UNZ_CRCERROR) {\n                    unzClose(zfile);\n                    throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot extract file: %1\")).arg(qfile_name).toStdString()));\n                }\n                if (!cp437_file_name.isEmpty() && cp437_file_name != qfile_name) {\n                    QString cp437_file_path = m_ExtractedFolderPath + \"/\" + cp437_file_name;\n                    QFile::copy(file_path, cp437_file_path);\n                }\n            }\n        } while ((res = unzGoToNextFile(zfile)) == UNZ_OK);\n    }\n\n    if (res != UNZ_END_OF_LIST_OF_FILE) {\n        unzClose(zfile);\n        throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot open EPUB: %1\")).arg(QDir::toNativeSeparators(m_FullFilePath)).toStdString()));\n    }\n\n    unzClose(zfile);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147118,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "void ImportEPUB::ExtractContainer()\n{\n    int res = 0;\n    if (!cp437) {\n        cp437 = new QCodePage437Codec();\n    }\n#ifdef Q_OS_WIN32\n    zlib_filefunc64_def ffunc;\n    fill_win32_filefunc64W(&ffunc);\n    unzFile zfile = unzOpen2_64(Utility::QStringToStdWString(QDir::toNativeSeparators(m_FullFilePath)).c_str(), &ffunc);\n#else\n    unzFile zfile = unzOpen64(QDir::toNativeSeparators(m_FullFilePath).toUtf8().constData());\n#endif\n\n    if (zfile == NULL) {\n        throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot unzip EPUB: %1\")).arg(QDir::toNativeSeparators(m_FullFilePath)).toStdString()));\n    }\n\n    res = unzGoToFirstFile(zfile);\n\n    if (res == UNZ_OK) {\n        do {\n            // Get the name of the file in the archive.\n            char file_name[MAX_PATH] = {0};\n            unz_file_info64 file_info;\n            unzGetCurrentFileInfo64(zfile, &file_info, file_name, MAX_PATH, NULL, 0, NULL, 0);\n            QString qfile_name;\n            QString cp437_file_name;\n            qfile_name = QString::fromUtf8(file_name);\n            if (!(file_info.flag & (1<<11))) {\n                // General purpose bit 11 says the filename is utf-8 encoded. If not set then\n                // IBM 437 encoding might be used.\n                cp437_file_name = cp437->toUnicode(file_name);\n            }\n\n            // If there is no file name then we can't do anything with it.\n            if (!qfile_name.isEmpty()) {\n\n\t        // for security reasons against maliciously crafted zip archives\n                // we need the file path to always be inside the target folder \n                // and not outside, so we will remove all illegal backslashes\n                // and all relative upward paths segments \"/../\" from the zip's local \n                // file name/path before prepending the target folder to create \n                // the final path\n\n\t        QString original_path = qfile_name;\n\t        bool evil_or_corrupt_epub = false;\n\n                if (qfile_name.contains(\"\\\\\")) evil_or_corrupt_epub = true; \n\t        qfile_name = \"/\" + qfile_name.replace(\"\\\\\",\"\");\n\n                if (qfile_name.contains(\"/../\")) evil_or_corrupt_epub = true;\n\t        qfile_name = qfile_name.replace(\"/../\",\"/\");\n\n                while(qfile_name.startsWith(\"/\")) { \n\t\t    qfile_name = qfile_name.remove(0,1);\n\t\t}\n\n                if (cp437_file_name.contains(\"\\\\\")) evil_or_corrupt_epub = true; \n                cp437_file_name = \"/\" + cp437_file_name.replace(\"\\\\\",\"\");\n\n                if (cp437_file_name.contains(\"/../\")) evil_or_corrupt_epub = true;\n\t        cp437_file_name = cp437_file_name.replace(\"/../\",\"/\");\n\n                while(cp437_file_name.startsWith(\"/\")) { \n\t\t    cp437_file_name = cp437_file_name.remove(0,1);\n\t\t}\n\n                if (evil_or_corrupt_epub) {\n                    unzCloseCurrentFile(zfile);\n                    unzClose(zfile);\n                    throw (EPUBLoadParseError(QString(QObject::tr(\"Possible evil or corrupt epub file name: %1\")).arg(original_path).toStdString()));\n                }\n\n                // We use the dir object to create the path in the temporary directory.\n                // Unfortunately, we need a dir ojbect to do this as it's not a static function.\n                QDir dir(m_ExtractedFolderPath);\n                // Full file path in the temporary directory.\n                QString file_path = m_ExtractedFolderPath + \"/\" + qfile_name;\n                QFileInfo qfile_info(file_path);\n\n                // Is this entry a directory?\n                if (file_info.uncompressed_size == 0 && qfile_name.endsWith('/')) {\n                    dir.mkpath(qfile_name);\n                    continue;\n                } else {\n                    dir.mkpath(qfile_info.path());\n\t\t    // add it to the list of files found inside the zip\n\t\t    if (cp437_file_name.isEmpty()) {\n\t\t        m_ZipFilePaths << qfile_name;\n\t\t    } else {\n                        m_ZipFilePaths << cp437_file_name;\n\t\t    }\n                }\n\n                // Open the file entry in the archive for reading.\n                if (unzOpenCurrentFile(zfile) != UNZ_OK) {\n                    unzClose(zfile);\n                    throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot extract file: %1\")).arg(qfile_name).toStdString()));\n                }\n\n                // Open the file on disk to write the entry in the archive to.\n                QFile entry(file_path);\n\n                if (!entry.open(QIODevice::WriteOnly | QIODevice::Truncate)) {\n                    unzCloseCurrentFile(zfile);\n                    unzClose(zfile);\n                    throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot extract file: %1\")).arg(qfile_name).toStdString()));\n                }\n\n                // Buffered reading and writing.\n                char buff[BUFF_SIZE] = {0};\n                int read = 0;\n\n                while ((read = unzReadCurrentFile(zfile, buff, BUFF_SIZE)) > 0) {\n                    entry.write(buff, read);\n                }\n\n                entry.close();\n\n                // Read errors are marked by a negative read amount.\n                if (read < 0) {\n                    unzCloseCurrentFile(zfile);\n                    unzClose(zfile);\n                    throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot extract file: %1\")).arg(qfile_name).toStdString()));\n                }\n\n                // The file was read but the CRC did not match.\n                // We don't check the read file size vs the uncompressed file size\n                // because if they're different there should be a CRC error.\n                if (unzCloseCurrentFile(zfile) == UNZ_CRCERROR) {\n                    unzClose(zfile);\n                    throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot extract file: %1\")).arg(qfile_name).toStdString()));\n                }\n                if (!cp437_file_name.isEmpty() && cp437_file_name != qfile_name) {\n                    QString cp437_file_path = m_ExtractedFolderPath + \"/\" + cp437_file_name;\n                    QFile::copy(file_path, cp437_file_path);\n                }\n            }\n        } while ((res = unzGoToNextFile(zfile)) == UNZ_OK);\n    }\n\n    if (res != UNZ_END_OF_LIST_OF_FILE) {\n        unzClose(zfile);\n        throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot open EPUB: %1\")).arg(QDir::toNativeSeparators(m_FullFilePath)).toStdString()));\n    }\n\n    unzClose(zfile);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147119,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "extract_archive_thread (GSimpleAsyncResult *result,\n\t\t\tGObject            *object,\n\t\t\tGCancellable       *cancellable)\n{\n\tExtractData          *extract_data;\n\tLoadData             *load_data;\n\tGHashTable           *checked_folders;\n\tGHashTable           *created_files;\n\tGHashTable           *folders_created_during_extraction;\n\tstruct archive       *a;\n\tstruct archive_entry *entry;\n\tint                   r;\n\n\textract_data = g_simple_async_result_get_op_res_gpointer (result);\n\tload_data = LOAD_DATA (extract_data);\n\n\tr = create_read_object (load_data, &a);\n\tif (r != ARCHIVE_OK) {\n\t\tarchive_read_free(a);\n\t\treturn;\n\t}\n\n\tchecked_folders = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\tcreated_files = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, g_object_unref);\n\tfolders_created_during_extraction = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\tfr_archive_progress_set_total_files (load_data->archive, extract_data->n_files_to_extract);\n\n\twhile ((r = archive_read_next_header (a, &entry)) == ARCHIVE_OK) {\n\t\tconst char    *pathname;\n\t\tchar          *fullpath;\n\t\tconst char    *relative_path;\n\t\tGFile         *file;\n\t\tGFile         *parent;\n\t\tGOutputStream *ostream;\n\t\tconst void    *buffer;\n\t\tsize_t         buffer_size;\n\t\tint64_t        target_offset, actual_offset;\n\t\tGError        *local_error = NULL;\n\t\t__LA_MODE_T    filetype;\n\n\t\tif (g_cancellable_is_cancelled (cancellable))\n\t\t\tbreak;\n\n\t\tpathname = archive_entry_pathname (entry);\n\t\tif (! extract_data_get_extraction_requested (extract_data, pathname)) {\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfullpath = (*pathname == '/') ? g_strdup (pathname) : g_strconcat (\"/\", pathname, NULL);\n\t\trelative_path = _g_path_get_relative_basename_safe (fullpath, extract_data->base_dir, extract_data->junk_paths);\n\t\tif (relative_path == NULL) {\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfile = g_file_get_child (extract_data->destination, relative_path);\n\n\t\t/* honor the skip_older and overwrite options */\n\n\t\tif ((g_hash_table_lookup (folders_created_during_extraction, file) == NULL)\n\t\t    && (extract_data->skip_older || ! extract_data->overwrite))\n\t\t{\n\t\t\tGFileInfo *info;\n\n\t\t\tinfo = g_file_query_info (file,\n\t\t\t\t\t\t  G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME \",\" G_FILE_ATTRIBUTE_TIME_MODIFIED,\n\t\t\t\t\t\t  G_FILE_QUERY_INFO_NONE,\n\t\t\t\t\t\t  cancellable,\n\t\t\t\t\t\t  &local_error);\n\t\t\tif (info != NULL) {\n\t\t\t\tgboolean skip = FALSE;\n\n\t\t\t\tif (! extract_data->overwrite) {\n\t\t\t\t\tskip = TRUE;\n\t\t\t\t}\n\t\t\t\telse if (extract_data->skip_older) {\n\t\t\t\t\tGTimeVal modification_time;\n\n\t\t\t\t\tg_file_info_get_modification_time (info, &modification_time);\n\t\t\t\t\tif (archive_entry_mtime (entry) < modification_time.tv_sec)\n\t\t\t\t\t\tskip = TRUE;\n\t\t\t\t}\n\n\t\t\t\tg_object_unref (info);\n\n\t\t\t\tif (skip) {\n\t\t\t\t\tg_object_unref (file);\n\n\t\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0);\n\n\t\t\t\t\tif ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) {\n\t\t\t\t\t\tr = ARCHIVE_EOF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {\n\t\t\t\t\tload_data->error = local_error;\n\t\t\t\t\tg_object_unref (info);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tg_clear_error (&local_error);\n\t\t\t}\n\t\t}\n\n\t\tfr_archive_progress_inc_completed_files (load_data->archive, 1);\n\n\t\t/* create the file parents */\n\n\t\tparent = g_file_get_parent (file);\n\n\t\tif ((parent != NULL)\n\t\t    && (g_hash_table_lookup (checked_folders, parent) == NULL)\n\t\t    && ! g_file_query_exists (parent, cancellable))\n\t\t{\n\t\t\tif (! _g_file_make_directory_with_parents (parent,\n\t\t\t\t\t\t\t\t   folders_created_during_extraction,\n\t\t\t\t\t\t\t\t   cancellable,\n\t\t\t\t\t\t\t\t   &local_error))\n\t\t\t{\n\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\tload_data->error = local_error;\n\t\t\t\telse\n\t\t\t\t\tg_clear_error (&local_error);\n\t\t\t}\n\n\t\t\tif (load_data->error == NULL) {\n\t\t\t\tGFile *grandparent;\n\n\t\t\t\tgrandparent = g_object_ref (parent);\n\t\t\t\twhile (grandparent != NULL) {\n\t\t\t\t\tif (g_hash_table_lookup (checked_folders, grandparent) == NULL)\n\t\t\t\t\t\tg_hash_table_insert (checked_folders, grandparent, GINT_TO_POINTER (1));\n\t\t\t\t\tgrandparent = g_file_get_parent (grandparent);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tg_object_unref (parent);\n\n\t\t/* create the file */\n\n\t\tfiletype = archive_entry_filetype (entry);\n\n\t\tif (load_data->error == NULL) {\n\t\t\tconst char  *linkname;\n\n\t\t\tlinkname = archive_entry_hardlink (entry);\n\t\t\tif (linkname != NULL) {\n\t\t\t\tchar        *link_fullpath;\n\t\t\t\tconst char  *relative_path;\n\t\t\t\tGFile       *link_file;\n\t\t\t\tchar        *oldname;\n\t\t\t\tchar        *newname;\n\t\t\t\tint          r;\n\n\t\t\t\tlink_fullpath = (*linkname == '/') ? g_strdup (linkname) : g_strconcat (\"/\", linkname, NULL);\n\t\t\t\trelative_path = _g_path_get_relative_basename_safe (link_fullpath, extract_data->base_dir, extract_data->junk_paths);\n\t\t\t\tif (relative_path == NULL) {\n\t\t\t\t\tg_free (link_fullpath);\n\t\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlink_file = g_file_get_child (extract_data->destination, relative_path);\n\t\t\t\toldname = g_file_get_path (link_file);\n\t\t\t\tnewname = g_file_get_path (file);\n\n\t\t\t\tif ((oldname != NULL) && (newname != NULL))\n\t\t\t\t\tr = link (oldname, newname);\n\t\t\t\telse\n\t\t\t\t\tr = -1;\n\n\t\t\t\tif (r == 0) {\n\t\t\t\t\t__LA_INT64_T filesize;\n\n\t\t\t\t\tif (archive_entry_size_is_set (entry))\n\t\t\t\t\t\tfilesize = archive_entry_size (entry);\n\t\t\t\t\telse\n\t\t\t\t\t\tfilesize = -1;\n\n\t\t\t\t\tif (filesize > 0)\n\t\t\t\t\t\tfiletype = AE_IFREG; /* treat as a regular file to save the data */\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchar *uri;\n\t\t\t\t\tchar *msg;\n\n\t\t\t\t\turi = g_file_get_uri (file);\n\t\t\t\t\tmsg = g_strdup_printf (\"Could not create the hard link %s\", uri);\n\t\t\t\t\tload_data->error = g_error_new_literal (G_IO_ERROR, G_IO_ERROR_FAILED, msg);\n\n\t\t\t\t\tg_free (msg);\n\t\t\t\t\tg_free (uri);\n\t\t\t\t}\n\n\t\t\t\tg_free (newname);\n\t\t\t\tg_free (oldname);\n\t\t\t\tg_object_unref (link_file);\n\t\t\t\tg_free (link_fullpath);\n\t\t\t}\n\t\t}\n\n\t\tif (load_data->error == NULL) {\n\t\t\tswitch (filetype) {\n\t\t\tcase AE_IFDIR:\n\t\t\t\tif (! g_file_make_directory (file, cancellable, &local_error)) {\n\t\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n\t\t\t\t\tg_clear_error (&local_error);\n\t\t\t\t}\n\t\t\t\tif (load_data->error == NULL)\n\t\t\t\t\tg_hash_table_insert (created_files, g_object_ref (file), _g_file_info_create_from_entry (entry, extract_data));\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\n\t\t\tcase AE_IFREG:\n\t\t\t\tostream = (GOutputStream *) g_file_replace (file, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, cancellable, &load_data->error);\n\t\t\t\tif (ostream == NULL)\n\t\t\t\t\tbreak;\n\n\t\t\t\tactual_offset = 0;\n\t\t\t\twhile ((r = archive_read_data_block (a, &buffer, &buffer_size, &target_offset)) == ARCHIVE_OK) {\n\t\t\t\t\tgsize bytes_written;\n\n\t\t\t\t\tif (target_offset > actual_offset) {\n\t\t\t\t\t\tif (! _g_output_stream_add_padding (extract_data, ostream, target_offset, actual_offset, cancellable, &load_data->error))\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, target_offset - actual_offset);\n\t\t\t\t\t\tactual_offset = target_offset;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (! g_output_stream_write_all (ostream, buffer, buffer_size, &bytes_written, cancellable, &load_data->error))\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tactual_offset += bytes_written;\n\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, bytes_written);\n\t\t\t\t}\n\n\t\t\t\tif ((r == ARCHIVE_EOF) && (target_offset > actual_offset))\n\t\t\t\t\t_g_output_stream_add_padding (extract_data, ostream, target_offset, actual_offset, cancellable, &load_data->error);\n\n\t\t\t\t_g_object_unref (ostream);\n\n\t\t\t\tif (r != ARCHIVE_EOF)\n\t\t\t\t\tload_data->error = _g_error_new_from_archive_error (archive_error_string (a));\n\t\t\t\telse\n\t\t\t\t\tg_hash_table_insert (created_files, g_object_ref (file), _g_file_info_create_from_entry (entry, extract_data));\n\t\t\t\tbreak;\n\n\t\t\tcase AE_IFLNK:\n\t\t\t\tif (! g_file_make_symbolic_link (file, archive_entry_symlink (entry), cancellable, &local_error)) {\n\t\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n\t\t\t\t\tg_clear_error (&local_error);\n\t\t\t\t}\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tg_object_unref (file);\n\t\tg_free (fullpath);\n\n\t\tif (load_data->error != NULL)\n\t\t\tbreak;\n\n\t\tif ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) {\n\t\t\tr = ARCHIVE_EOF;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (load_data->error == NULL)\n\t\trestore_original_file_attributes (created_files, cancellable);\n\n\tif ((load_data->error == NULL) && (r != ARCHIVE_EOF))\n\t\tload_data->error = _g_error_new_from_archive_error (archive_error_string (a));\n\tif (load_data->error == NULL)\n\t\tg_cancellable_set_error_if_cancelled (cancellable, &load_data->error);\n\tif (load_data->error != NULL)\n\t\tg_simple_async_result_set_from_error (result, load_data->error);\n\n\tg_hash_table_unref (folders_created_during_extraction);\n\tg_hash_table_unref (created_files);\n\tg_hash_table_unref (checked_folders);\n\tarchive_read_free (a);\n\textract_data_free (extract_data);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147368,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "extract_archive_thread (GSimpleAsyncResult *result,\n\t\t\tGObject            *object,\n\t\t\tGCancellable       *cancellable)\n{\n\tExtractData          *extract_data;\n\tLoadData             *load_data;\n\tGHashTable           *checked_folders;\n\tGHashTable           *created_files;\n\tGHashTable           *folders_created_during_extraction;\n\tGHashTable           *external_links;\n\tstruct archive       *a;\n\tstruct archive_entry *entry;\n\tint                   r;\n\n\textract_data = g_simple_async_result_get_op_res_gpointer (result);\n\tload_data = LOAD_DATA (extract_data);\n\n\tr = create_read_object (load_data, &a);\n\tif (r != ARCHIVE_OK) {\n\t\tarchive_read_free(a);\n\t\treturn;\n\t}\n\n\tchecked_folders = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\tcreated_files = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, g_object_unref);\n\tfolders_created_during_extraction = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\texternal_links = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\tfr_archive_progress_set_total_files (load_data->archive, extract_data->n_files_to_extract);\n\n\twhile ((r = archive_read_next_header (a, &entry)) == ARCHIVE_OK) {\n\t\tconst char    *pathname;\n\t\tchar          *fullpath;\n\t\tconst char    *relative_path;\n\t\tGFile         *file;\n\t\tGFile         *parent;\n\t\tGOutputStream *ostream;\n\t\tconst void    *buffer;\n\t\tsize_t         buffer_size;\n\t\tint64_t        target_offset, actual_offset;\n\t\tGError        *local_error = NULL;\n\t\t__LA_MODE_T    filetype;\n\n\t\tif (g_cancellable_is_cancelled (cancellable))\n\t\t\tbreak;\n\n\t\tpathname = archive_entry_pathname (entry);\n\t\tif (! extract_data_get_extraction_requested (extract_data, pathname)) {\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfullpath = (*pathname == '/') ? g_strdup (pathname) : g_strconcat (\"/\", pathname, NULL);\n\t\trelative_path = _g_path_get_relative_basename_safe (fullpath, extract_data->base_dir, extract_data->junk_paths);\n\t\tif (relative_path == NULL) {\n\t\t\tfr_archive_progress_inc_completed_files (load_data->archive, 1);\n\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0);\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (_g_path_is_external_to_destination (relative_path, extract_data->destination, external_links)) {\n\t\t\tfr_archive_progress_inc_completed_files (load_data->archive, 1);\n\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0);\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfile = g_file_get_child (extract_data->destination, relative_path);\n\n\t\t/* honor the skip_older and overwrite options */\n\n\t\tif ((g_hash_table_lookup (folders_created_during_extraction, file) == NULL)\n\t\t    && (extract_data->skip_older || ! extract_data->overwrite))\n\t\t{\n\t\t\tGFileInfo *info;\n\n\t\t\tinfo = g_file_query_info (file,\n\t\t\t\t\t\t  G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME \",\" G_FILE_ATTRIBUTE_TIME_MODIFIED,\n\t\t\t\t\t\t  G_FILE_QUERY_INFO_NONE,\n\t\t\t\t\t\t  cancellable,\n\t\t\t\t\t\t  &local_error);\n\t\t\tif (info != NULL) {\n\t\t\t\tgboolean skip = FALSE;\n\n\t\t\t\tif (! extract_data->overwrite) {\n\t\t\t\t\tskip = TRUE;\n\t\t\t\t}\n\t\t\t\telse if (extract_data->skip_older) {\n\t\t\t\t\tGTimeVal modification_time;\n\n\t\t\t\t\tg_file_info_get_modification_time (info, &modification_time);\n\t\t\t\t\tif (archive_entry_mtime (entry) < modification_time.tv_sec)\n\t\t\t\t\t\tskip = TRUE;\n\t\t\t\t}\n\n\t\t\t\tg_object_unref (info);\n\n\t\t\t\tif (skip) {\n\t\t\t\t\tg_object_unref (file);\n\n\t\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0);\n\n\t\t\t\t\tif ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) {\n\t\t\t\t\t\tr = ARCHIVE_EOF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {\n\t\t\t\t\tload_data->error = local_error;\n\t\t\t\t\tg_object_unref (info);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tg_clear_error (&local_error);\n\t\t\t}\n\t\t}\n\n\t\tfr_archive_progress_inc_completed_files (load_data->archive, 1);\n\n\t\t/* create the file parents */\n\n\t\tparent = g_file_get_parent (file);\n\n\t\tif ((parent != NULL)\n\t\t    && (g_hash_table_lookup (checked_folders, parent) == NULL)\n\t\t    && ! g_file_query_exists (parent, cancellable))\n\t\t{\n\t\t\tif (! _g_file_make_directory_with_parents (parent,\n\t\t\t\t\t\t\t\t   folders_created_during_extraction,\n\t\t\t\t\t\t\t\t   cancellable,\n\t\t\t\t\t\t\t\t   &local_error))\n\t\t\t{\n\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\tload_data->error = local_error;\n\t\t\t\telse\n\t\t\t\t\tg_clear_error (&local_error);\n\t\t\t}\n\n\t\t\tif (load_data->error == NULL) {\n\t\t\t\tGFile *grandparent;\n\n\t\t\t\tgrandparent = g_object_ref (parent);\n\t\t\t\twhile (grandparent != NULL) {\n\t\t\t\t\tif (g_hash_table_lookup (checked_folders, grandparent) == NULL)\n\t\t\t\t\t\tg_hash_table_insert (checked_folders, grandparent, GINT_TO_POINTER (1));\n\t\t\t\t\tgrandparent = g_file_get_parent (grandparent);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tg_object_unref (parent);\n\n\t\t/* create the file */\n\n\t\tfiletype = archive_entry_filetype (entry);\n\n\t\tif (load_data->error == NULL) {\n\t\t\tconst char  *linkname;\n\n\t\t\tlinkname = archive_entry_hardlink (entry);\n\t\t\tif (linkname != NULL) {\n\t\t\t\tchar        *link_fullpath;\n\t\t\t\tconst char  *relative_path;\n\t\t\t\tGFile       *link_file;\n\t\t\t\tchar        *oldname;\n\t\t\t\tchar        *newname;\n\t\t\t\tint          r;\n\n\t\t\t\tlink_fullpath = (*linkname == '/') ? g_strdup (linkname) : g_strconcat (\"/\", linkname, NULL);\n\t\t\t\trelative_path = _g_path_get_relative_basename_safe (link_fullpath, extract_data->base_dir, extract_data->junk_paths);\n\t\t\t\tif (relative_path == NULL) {\n\t\t\t\t\tg_free (link_fullpath);\n\t\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlink_file = g_file_get_child (extract_data->destination, relative_path);\n\t\t\t\toldname = g_file_get_path (link_file);\n\t\t\t\tnewname = g_file_get_path (file);\n\n\t\t\t\tif ((oldname != NULL) && (newname != NULL))\n\t\t\t\t\tr = link (oldname, newname);\n\t\t\t\telse\n\t\t\t\t\tr = -1;\n\n\t\t\t\tif (r == 0) {\n\t\t\t\t\t__LA_INT64_T filesize;\n\n\t\t\t\t\tif (archive_entry_size_is_set (entry))\n\t\t\t\t\t\tfilesize = archive_entry_size (entry);\n\t\t\t\t\telse\n\t\t\t\t\t\tfilesize = -1;\n\n\t\t\t\t\tif (filesize > 0)\n\t\t\t\t\t\tfiletype = AE_IFREG; /* treat as a regular file to save the data */\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchar *uri;\n\t\t\t\t\tchar *msg;\n\n\t\t\t\t\turi = g_file_get_uri (file);\n\t\t\t\t\tmsg = g_strdup_printf (\"Could not create the hard link %s\", uri);\n\t\t\t\t\tload_data->error = g_error_new_literal (G_IO_ERROR, G_IO_ERROR_FAILED, msg);\n\n\t\t\t\t\tg_free (msg);\n\t\t\t\t\tg_free (uri);\n\t\t\t\t}\n\n\t\t\t\tg_free (newname);\n\t\t\t\tg_free (oldname);\n\t\t\t\tg_object_unref (link_file);\n\t\t\t\tg_free (link_fullpath);\n\t\t\t}\n\t\t}\n\n\t\tif (load_data->error == NULL) {\n\t\t\tswitch (filetype) {\n\t\t\tcase AE_IFDIR:\n\t\t\t\tif (! g_file_make_directory (file, cancellable, &local_error)) {\n\t\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n\t\t\t\t\tg_clear_error (&local_error);\n\t\t\t\t}\n\t\t\t\tif (load_data->error == NULL)\n\t\t\t\t\tg_hash_table_insert (created_files, g_object_ref (file), _g_file_info_create_from_entry (entry, extract_data));\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\n\t\t\tcase AE_IFREG:\n\t\t\t\tostream = (GOutputStream *) g_file_replace (file, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, cancellable, &load_data->error);\n\t\t\t\tif (ostream == NULL)\n\t\t\t\t\tbreak;\n\n\t\t\t\tactual_offset = 0;\n\t\t\t\twhile ((r = archive_read_data_block (a, &buffer, &buffer_size, &target_offset)) == ARCHIVE_OK) {\n\t\t\t\t\tgsize bytes_written;\n\n\t\t\t\t\tif (target_offset > actual_offset) {\n\t\t\t\t\t\tif (! _g_output_stream_add_padding (extract_data, ostream, target_offset, actual_offset, cancellable, &load_data->error))\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, target_offset - actual_offset);\n\t\t\t\t\t\tactual_offset = target_offset;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (! g_output_stream_write_all (ostream, buffer, buffer_size, &bytes_written, cancellable, &load_data->error))\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tactual_offset += bytes_written;\n\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, bytes_written);\n\t\t\t\t}\n\n\t\t\t\tif ((r == ARCHIVE_EOF) && (target_offset > actual_offset))\n\t\t\t\t\t_g_output_stream_add_padding (extract_data, ostream, target_offset, actual_offset, cancellable, &load_data->error);\n\n\t\t\t\t_g_object_unref (ostream);\n\n\t\t\t\tif (r != ARCHIVE_EOF)\n\t\t\t\t\tload_data->error = _g_error_new_from_archive_error (archive_error_string (a));\n\t\t\t\telse\n\t\t\t\t\tg_hash_table_insert (created_files, g_object_ref (file), _g_file_info_create_from_entry (entry, extract_data));\n\t\t\t\tbreak;\n\n\t\t\tcase AE_IFLNK:\n\t\t\t\tif (! g_file_make_symbolic_link (file, archive_entry_symlink (entry), cancellable, &local_error)) {\n\t\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n\t\t\t\t\tg_clear_error (&local_error);\n\t\t\t\t}\n\t\t\t\telse if (_symlink_is_external_to_destination (file, archive_entry_symlink (entry), extract_data->destination, external_links))\n\t\t\t\t\tg_hash_table_insert (external_links, g_object_ref (file), GINT_TO_POINTER (1));\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tg_object_unref (file);\n\t\tg_free (fullpath);\n\n\t\tif (load_data->error != NULL)\n\t\t\tbreak;\n\n\t\tif ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) {\n\t\t\tr = ARCHIVE_EOF;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (load_data->error == NULL)\n\t\trestore_original_file_attributes (created_files, cancellable);\n\n\tif ((load_data->error == NULL) && (r != ARCHIVE_EOF))\n\t\tload_data->error = _g_error_new_from_archive_error (archive_error_string (a));\n\tif (load_data->error == NULL)\n\t\tg_cancellable_set_error_if_cancelled (cancellable, &load_data->error);\n\tif (load_data->error != NULL)\n\t\tg_simple_async_result_set_from_error (result, load_data->error);\n\n\tg_hash_table_unref (folders_created_during_extraction);\n\tg_hash_table_unref (created_files);\n\tg_hash_table_unref (checked_folders);\n\tg_hash_table_unref (external_links);\n\tarchive_read_free (a);\n\textract_data_free (extract_data);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147369,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "initialise_banding(fz_context *ctx, render_details *render, int color)\n{\n\tsize_t min_band_mem;\n\tint bpp, h, w, reps;\n\n\trender->colorspace = output_cs;\n\trender->format = output_format;\n#if GREY_FALLBACK != 0\n\tif (color == 0)\n\t{\n\t\tif (render->colorspace == CS_RGB)\n\t\t{\n\t\t\t/* Fallback from PPM to PGM */\n\t\t\trender->colorspace = CS_GRAY;\n\t\t\trender->format = OUT_PGM;\n\t\t}\n\t\telse if (render->colorspace == CS_CMYK)\n\t\t{\n\t\t\trender->colorspace = CS_GRAY;\n\t\t\tif (render->format == OUT_PKM)\n\t\t\t\trender->format = OUT_PBM;\n\t\t\telse\n\t\t\t\trender->format = OUT_PGM;\n\t\t}\n\t}\n#endif\n\n\tswitch (render->colorspace)\n\t{\n\tcase CS_GRAY:\n\t\tbpp = 1;\n\t\tbreak;\n\tcase CS_RGB:\n\t\tbpp = 2;\n\t\tbreak;\n\tdefault:\n\tcase CS_CMYK:\n\t\tbpp = 3;\n\t\tbreak;\n\t}\n\n\tw = render->ibounds.x1 - render->ibounds.x0;\n\tmin_band_mem = (size_t)bpp * w * min_band_height;\n\treps = (int)(max_band_memory / min_band_mem);\n\tif (reps < 1)\n\t\treps = 1;\n\n\t/* Adjust reps to even out the work between threads */\n\tif (render->num_workers > 0)\n\t{\n\t\tint runs, num_bands;\n\t\th = render->ibounds.y1 - render->ibounds.y0;\n\t\tnum_bands = (h + min_band_height - 1) / min_band_height;\n\t\t/* num_bands = number of min_band_height bands */\n\t\truns = (num_bands + reps-1) / reps;\n\t\t/* runs = number of worker runs of reps min_band_height bands */\n\t\truns = ((runs + render->num_workers - 1) / render->num_workers) * render->num_workers;\n\t\t/* runs = number of worker runs rounded up to make use of all our threads */\n\t\treps = (num_bands + runs - 1) / runs;\n\t}\n\n\trender->band_height_multiple = reps;\n\trender->bands_rendered = 0;\n\n\tif (output_format == OUT_PGM || output_format == OUT_PPM)\n\t{\n\t\trender->bander = fz_new_pnm_band_writer(ctx, out);\n\t\trender->n = output_format == OUT_PGM ? 1 : 3;\n\t}\n\telse if (output_format == OUT_PAM)\n\t{\n\t\trender->bander = fz_new_pam_band_writer(ctx, out);\n\t\trender->n = 4;\n\t}\n\telse if (output_format == OUT_PBM)\n\t{\n\t\trender->bander = fz_new_pbm_band_writer(ctx, out);\n\t\trender->n = 1;\n\t}\n\telse if (output_format == OUT_PKM)\n\t{\n\t\trender->bander = fz_new_pkm_band_writer(ctx, out);\n\t\trender->n = 4;\n\t}\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147442,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "initialise_banding(fz_context *ctx, render_details *render, int color)\n{\n\tsize_t min_band_mem;\n\tint bpp, h, w, reps;\n\n\trender->colorspace = output_cs;\n\trender->format = output_format;\n#if GREY_FALLBACK != 0\n\tif (color == 0)\n\t{\n\t\tif (render->colorspace == CS_RGB)\n\t\t{\n\t\t\t/* Fallback from PPM to PGM */\n\t\t\trender->colorspace = CS_GRAY;\n\t\t\trender->format = OUT_PGM;\n\t\t}\n\t\telse if (render->colorspace == CS_CMYK)\n\t\t{\n\t\t\trender->colorspace = CS_GRAY;\n\t\t\tif (render->format == OUT_PKM)\n\t\t\t\trender->format = OUT_PBM;\n\t\t\telse\n\t\t\t\trender->format = OUT_PGM;\n\t\t}\n\t}\n#endif\n\n\tswitch (render->colorspace)\n\t{\n\tcase CS_GRAY:\n\t\tbpp = 1;\n\t\tbreak;\n\tcase CS_RGB:\n\t\tbpp = 2;\n\t\tbreak;\n\tdefault:\n\tcase CS_CMYK:\n\t\tbpp = 3;\n\t\tbreak;\n\t}\n\n\tw = render->ibounds.x1 - render->ibounds.x0;\n\tmin_band_mem = (size_t)bpp * w * min_band_height;\n\tif (min_band_mem > 0)\n\t\treps = (int)(max_band_memory / min_band_mem);\n\tif (min_band_mem == 0 || reps < 1)\n\t\treps = 1;\n\n\t/* Adjust reps to even out the work between threads */\n\tif (render->num_workers > 0)\n\t{\n\t\tint runs, num_bands;\n\t\th = render->ibounds.y1 - render->ibounds.y0;\n\t\tnum_bands = (h + min_band_height - 1) / min_band_height;\n\t\t/* num_bands = number of min_band_height bands */\n\t\truns = (num_bands + reps-1) / reps;\n\t\t/* runs = number of worker runs of reps min_band_height bands */\n\t\truns = ((runs + render->num_workers - 1) / render->num_workers) * render->num_workers;\n\t\t/* runs = number of worker runs rounded up to make use of all our threads */\n\t\treps = (num_bands + runs - 1) / runs;\n\t}\n\n\trender->band_height_multiple = reps;\n\trender->bands_rendered = 0;\n\n\tif (output_format == OUT_PGM || output_format == OUT_PPM)\n\t{\n\t\trender->bander = fz_new_pnm_band_writer(ctx, out);\n\t\trender->n = output_format == OUT_PGM ? 1 : 3;\n\t}\n\telse if (output_format == OUT_PAM)\n\t{\n\t\trender->bander = fz_new_pam_band_writer(ctx, out);\n\t\trender->n = 4;\n\t}\n\telse if (output_format == OUT_PBM)\n\t{\n\t\trender->bander = fz_new_pbm_band_writer(ctx, out);\n\t\trender->n = 1;\n\t}\n\telse if (output_format == OUT_PKM)\n\t{\n\t\trender->bander = fz_new_pkm_band_writer(ctx, out);\n\t\trender->n = 4;\n\t}\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147443,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "strip_leading_slashes (char *name, int strip_leading)\n{\n  int s = strip_leading;\n  char *p, *n;\n\n  for (p = n = name;  *p;  p++)\n    {\n      if (ISSLASH (*p))\n\t{\n\t  while (ISSLASH (p[1]))\n\t    p++;\n\t  if (strip_leading < 0 || --s >= 0)\n\t      n = p+1;\n\t}\n    }\n  if ((strip_leading < 0 || s <= 0) && *n)\n    {\n      memmove (name, n, strlen (n) + 1);\n      return true;\n    }\n  else\n    return false;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147612,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "strip_leading_slashes (char *name, int strip_leading)\n{\n  int s = strip_leading;\n  char *p, *n;\n\n  for (p = n = name;  *p;  p++)\n    {\n      if (ISSLASH (*p))\n\t{\n\t  while (ISSLASH (p[1]))\n\t    p++;\n\t  if (strip_leading < 0 || --s >= 0)\n\t      n = p+1;\n\t}\n    }\n  if (IS_ABSOLUTE_FILE_NAME (n))\n    fatal (\"rejecting absolute file name: %s\", quotearg (n));\n  for (p = n; *p; )\n    {\n      if (*p == '.' && *++p == '.' && ( ! *++p || ISSLASH (*p)))\n\tfatal (\"rejecting file name with \\\"..\\\" component: %s\", quotearg (n));\n      while (*p && ! ISSLASH (*p))\n\tp++;\n      while (ISSLASH (*p))\n\tp++;\n    }\n  if ((strip_leading < 0 || s <= 0) && *n)\n    {\n      memmove (name, n, strlen (n) + 1);\n      return true;\n    }\n  else\n    return false;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147613,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "defaults (void)\n{\n  char *tmp;\n\n  /* Most of the default values are 0 (and 0.0, NULL, and false).\n     Just reset everything, and fill in the non-zero values.  Note\n     that initializing pointers to NULL this way is technically\n     illegal, but porting Wget to a machine where NULL is not all-zero\n     bit pattern will be the least of the implementors' worries.  */\n  xzero (opt);\n\n  opt.cookies = true;\n  opt.verbose = -1;\n  opt.ntry = 20;\n  opt.reclevel = 5;\n  opt.add_hostdir = true;\n  opt.netrc = true;\n  opt.ftp_glob = true;\n  opt.htmlify = true;\n  opt.http_keep_alive = true;\n  opt.use_proxy = true;\n  tmp = getenv (\"no_proxy\");\n  if (tmp)\n    opt.no_proxy = sepstring (tmp);\n  opt.prefer_family = prefer_none;\n  opt.allow_cache = true;\n\n  opt.read_timeout = 900;\n  opt.use_robots = true;\n\n  opt.remove_listing = true;\n\n  opt.dot_bytes = 1024;\n  opt.dot_spacing = 10;\n  opt.dots_in_line = 50;\n\n  opt.dns_cache = true;\n  opt.ftp_pasv = true;\n\n#ifdef HAVE_SSL\n  opt.check_cert = true;\n#endif\n\n  /* The default for file name restriction defaults to the OS type. */\n#if defined(WINDOWS) || defined(MSDOS) || defined(__CYGWIN__)\n  opt.restrict_files_os = restrict_windows;\n#else\n  opt.restrict_files_os = restrict_unix;\n#endif\n  opt.restrict_files_ctrl = true;\n  opt.restrict_files_nonascii = false;\n  opt.restrict_files_case = restrict_no_case_restriction;\n\n  opt.regex_type = regex_type_posix;\n\n  opt.max_redirect = 20;\n\n  opt.waitretry = 10;\n\n#ifdef ENABLE_IRI\n  opt.enable_iri = true;\n#else\n  opt.enable_iri = false;\n#endif\n  opt.locale = NULL;\n  opt.encoding_remote = NULL;\n\n  opt.useservertimestamps = true;\n  opt.show_all_dns_entries = false;\n\n  opt.warc_maxsize = 0; /* 1024 * 1024 * 1024; */\n#ifdef HAVE_LIBZ\n  opt.warc_compression_enabled = true;\n#else\n  opt.warc_compression_enabled = false;\n#endif\n  opt.warc_digests_enabled = true;\n  opt.warc_cdx_enabled = false;\n  opt.warc_cdx_dedup_filename = NULL;\n  opt.warc_tempdir = NULL;\n  opt.warc_keep_log = true;\n\n  /* Use a negative value to mark the absence of --start-pos option */\n  opt.start_pos = -1;\n  opt.show_progress = false;\n  opt.noscroll = false;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147642,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "defaults (void)\n{\n  char *tmp;\n\n  /* Most of the default values are 0 (and 0.0, NULL, and false).\n     Just reset everything, and fill in the non-zero values.  Note\n     that initializing pointers to NULL this way is technically\n     illegal, but porting Wget to a machine where NULL is not all-zero\n     bit pattern will be the least of the implementors' worries.  */\n  xzero (opt);\n\n  opt.cookies = true;\n  opt.verbose = -1;\n  opt.ntry = 20;\n  opt.reclevel = 5;\n  opt.add_hostdir = true;\n  opt.netrc = true;\n  opt.ftp_glob = true;\n  opt.htmlify = true;\n  opt.http_keep_alive = true;\n  opt.use_proxy = true;\n  tmp = getenv (\"no_proxy\");\n  if (tmp)\n    opt.no_proxy = sepstring (tmp);\n  opt.prefer_family = prefer_none;\n  opt.allow_cache = true;\n\n  opt.read_timeout = 900;\n  opt.use_robots = true;\n\n  opt.remove_listing = true;\n\n  opt.dot_bytes = 1024;\n  opt.dot_spacing = 10;\n  opt.dots_in_line = 50;\n\n  opt.dns_cache = true;\n  opt.ftp_pasv = true;\n  /* 2014-09-07  Darshit Shah  <darnir@gmail.com>\n   * opt.retr_symlinks is set to true by default. Creating symbolic links on the\n   * local filesystem pose a security threat by malicious FTP Servers that\n   * server a specially crafted .listing file akin to this:\n   *\n   * lrwxrwxrwx   1 root     root           33 Dec 25  2012 JoCxl6d8rFU -> /\n   * drwxrwxr-x  15 1024     106          4096 Aug 28 02:02 JoCxl6d8rFU\n   *\n   * A .listing file in this fashion makes Wget susceptiple to a symlink attack\n   * wherein the attacker is able to create arbitrary files, directories and\n   * symbolic links on the target system and even set permissions.\n   *\n   * Hence, by default Wget attempts to retrieve the pointed-to files and does\n   * not create the symbolic links locally.\n   */\n  opt.retr_symlinks = true;\n\n#ifdef HAVE_SSL\n  opt.check_cert = true;\n#endif\n\n  /* The default for file name restriction defaults to the OS type. */\n#if defined(WINDOWS) || defined(MSDOS) || defined(__CYGWIN__)\n  opt.restrict_files_os = restrict_windows;\n#else\n  opt.restrict_files_os = restrict_unix;\n#endif\n  opt.restrict_files_ctrl = true;\n  opt.restrict_files_nonascii = false;\n  opt.restrict_files_case = restrict_no_case_restriction;\n\n  opt.regex_type = regex_type_posix;\n\n  opt.max_redirect = 20;\n\n  opt.waitretry = 10;\n\n#ifdef ENABLE_IRI\n  opt.enable_iri = true;\n#else\n  opt.enable_iri = false;\n#endif\n  opt.locale = NULL;\n  opt.encoding_remote = NULL;\n\n  opt.useservertimestamps = true;\n  opt.show_all_dns_entries = false;\n\n  opt.warc_maxsize = 0; /* 1024 * 1024 * 1024; */\n#ifdef HAVE_LIBZ\n  opt.warc_compression_enabled = true;\n#else\n  opt.warc_compression_enabled = false;\n#endif\n  opt.warc_digests_enabled = true;\n  opt.warc_cdx_enabled = false;\n  opt.warc_cdx_dedup_filename = NULL;\n  opt.warc_tempdir = NULL;\n  opt.warc_keep_log = true;\n\n  /* Use a negative value to mark the absence of --start-pos option */\n  opt.start_pos = -1;\n  opt.show_progress = false;\n  opt.noscroll = false;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147643,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "ftp_retrieve_glob (struct url *u, ccon *con, int action)\n{\n  struct fileinfo *f, *start;\n  uerr_t res;\n\n  con->cmd |= LEAVE_PENDING;\n\n  res = ftp_get_listing (u, con, &start);\n  if (res != RETROK)\n    return res;\n  /* First: weed out that do not conform the global rules given in\n     opt.accepts and opt.rejects.  */\n  if (opt.accepts || opt.rejects)\n    {\n      f = start;\n      while (f)\n        {\n          if (f->type != FT_DIRECTORY && !acceptable (f->name))\n            {\n              logprintf (LOG_VERBOSE, _(\"Rejecting %s.\\n\"),\n                         quote (f->name));\n              f = delelement (f, &start);\n            }\n          else\n            f = f->next;\n        }\n    }\n  /* Remove all files with possible harmful names */\n  f = start;\n  while (f)\n    {\n      if (has_insecure_name_p (f->name))\n        {\n          logprintf (LOG_VERBOSE, _(\"Rejecting %s.\\n\"),\n                     quote (f->name));\n          f = delelement (f, &start);\n        }\n      else\n        f = f->next;\n    }\n  /* Now weed out the files that do not match our globbing pattern.\n     If we are dealing with a globbing pattern, that is.  */\n  if (*u->file)\n    {\n      if (action == GLOB_GLOBALL)\n        {\n          int (*matcher) (const char *, const char *, int)\n            = opt.ignore_case ? fnmatch_nocase : fnmatch;\n          int matchres = 0;\n\n          f = start;\n          while (f)\n            {\n              matchres = matcher (u->file, f->name, 0);\n              if (matchres == -1)\n                {\n                  logprintf (LOG_NOTQUIET, _(\"Error matching %s against %s: %s\\n\"),\n                             u->file, quotearg_style (escape_quoting_style, f->name),\n                             strerror (errno));\n                  break;\n                }\n              if (matchres == FNM_NOMATCH)\n                f = delelement (f, &start); /* delete the element from the list */\n              else\n                f = f->next;        /* leave the element in the list */\n            }\n          if (matchres == -1)\n            {\n              freefileinfo (start);\n              return RETRBADPATTERN;\n            }\n        }\n      else if (action == GLOB_GETONE)\n        {\n#ifdef __VMS\n          /* 2009-09-09 SMS.\n           * Odd-ball compiler (\"HP C V7.3-009 on OpenVMS Alpha V7.3-2\")\n           * bug causes spurious %CC-E-BADCONDIT complaint with this\n           * \"?:\" statement.  (Different linkage attributes for strcmp()\n           * and strcasecmp().)  Converting to \"if\" changes the\n           * complaint to %CC-W-PTRMISMATCH on \"cmp = strcmp;\".  Adding\n           * the senseless type cast clears the complaint, and looks\n           * harmless.\n           */\n          int (*cmp) (const char *, const char *)\n            = opt.ignore_case ? strcasecmp : (int (*)())strcmp;\n#else /* def __VMS */\n          int (*cmp) (const char *, const char *)\n            = opt.ignore_case ? strcasecmp : strcmp;\n#endif /* def __VMS [else] */\n          f = start;\n          while (f)\n            {\n              if (0 != cmp(u->file, f->name))\n                f = delelement (f, &start);\n              else\n                f = f->next;\n            }\n        }\n    }\n  if (start)\n    {\n      /* Just get everything.  */\n      res = ftp_retrieve_list (u, start, con);\n    }\n  else\n    {\n      if (action == GLOB_GLOBALL)\n        {\n          /* No luck.  */\n          /* #### This message SUCKS.  We should see what was the\n             reason that nothing was retrieved.  */\n          logprintf (LOG_VERBOSE, _(\"No matches on pattern %s.\\n\"),\n                     quote (u->file));\n        }\n      else if (action == GLOB_GETONE) /* GLOB_GETONE or GLOB_GETALL */\n        {\n          /* Let's try retrieving it anyway.  */\n          con->st |= ON_YOUR_OWN;\n          res = ftp_loop_internal (u, NULL, con, NULL);\n          return res;\n        }\n\n      /* If action == GLOB_GETALL, and the file list is empty, there's\n         no point in trying to download anything or in complaining about\n         it.  (An empty directory should not cause complaints.)\n      */\n    }\n  freefileinfo (start);\n  if (opt.quota && total_downloaded_bytes > opt.quota)\n    return QUOTEXC;\n  else\n    return res;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147644,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "ftp_retrieve_glob (struct url *u, ccon *con, int action)\n{\n  struct fileinfo *f, *start;\n  uerr_t res;\n\n  con->cmd |= LEAVE_PENDING;\n\n  res = ftp_get_listing (u, con, &start);\n  if (res != RETROK)\n    return res;\n  /* First: weed out that do not conform the global rules given in\n     opt.accepts and opt.rejects.  */\n  if (opt.accepts || opt.rejects)\n    {\n      f = start;\n      while (f)\n        {\n          if (f->type != FT_DIRECTORY && !acceptable (f->name))\n            {\n              logprintf (LOG_VERBOSE, _(\"Rejecting %s.\\n\"),\n                         quote (f->name));\n              f = delelement (f, &start);\n            }\n          else\n            f = f->next;\n        }\n    }\n  /* Remove all files with possible harmful names or invalid entries. */\n  f = start;\n  while (f)\n    {\n      if (has_insecure_name_p (f->name) || is_invalid_entry (f))\n        {\n          logprintf (LOG_VERBOSE, _(\"Rejecting %s.\\n\"),\n                     quote (f->name));\n          f = delelement (f, &start);\n        }\n      else\n        f = f->next;\n    }\n  /* Now weed out the files that do not match our globbing pattern.\n     If we are dealing with a globbing pattern, that is.  */\n  if (*u->file)\n    {\n      if (action == GLOB_GLOBALL)\n        {\n          int (*matcher) (const char *, const char *, int)\n            = opt.ignore_case ? fnmatch_nocase : fnmatch;\n          int matchres = 0;\n\n          f = start;\n          while (f)\n            {\n              matchres = matcher (u->file, f->name, 0);\n              if (matchres == -1)\n                {\n                  logprintf (LOG_NOTQUIET, _(\"Error matching %s against %s: %s\\n\"),\n                             u->file, quotearg_style (escape_quoting_style, f->name),\n                             strerror (errno));\n                  break;\n                }\n              if (matchres == FNM_NOMATCH)\n                f = delelement (f, &start); /* delete the element from the list */\n              else\n                f = f->next;        /* leave the element in the list */\n            }\n          if (matchres == -1)\n            {\n              freefileinfo (start);\n              return RETRBADPATTERN;\n            }\n        }\n      else if (action == GLOB_GETONE)\n        {\n#ifdef __VMS\n          /* 2009-09-09 SMS.\n           * Odd-ball compiler (\"HP C V7.3-009 on OpenVMS Alpha V7.3-2\")\n           * bug causes spurious %CC-E-BADCONDIT complaint with this\n           * \"?:\" statement.  (Different linkage attributes for strcmp()\n           * and strcasecmp().)  Converting to \"if\" changes the\n           * complaint to %CC-W-PTRMISMATCH on \"cmp = strcmp;\".  Adding\n           * the senseless type cast clears the complaint, and looks\n           * harmless.\n           */\n          int (*cmp) (const char *, const char *)\n            = opt.ignore_case ? strcasecmp : (int (*)())strcmp;\n#else /* def __VMS */\n          int (*cmp) (const char *, const char *)\n            = opt.ignore_case ? strcasecmp : strcmp;\n#endif /* def __VMS [else] */\n          f = start;\n          while (f)\n            {\n              if (0 != cmp(u->file, f->name))\n                f = delelement (f, &start);\n              else\n                f = f->next;\n            }\n        }\n    }\n  if (start)\n    {\n      /* Just get everything.  */\n      res = ftp_retrieve_list (u, start, con);\n    }\n  else\n    {\n      if (action == GLOB_GLOBALL)\n        {\n          /* No luck.  */\n          /* #### This message SUCKS.  We should see what was the\n             reason that nothing was retrieved.  */\n          logprintf (LOG_VERBOSE, _(\"No matches on pattern %s.\\n\"),\n                     quote (u->file));\n        }\n      else if (action == GLOB_GETONE) /* GLOB_GETONE or GLOB_GETALL */\n        {\n          /* Let's try retrieving it anyway.  */\n          con->st |= ON_YOUR_OWN;\n          res = ftp_loop_internal (u, NULL, con, NULL);\n          return res;\n        }\n\n      /* If action == GLOB_GETALL, and the file list is empty, there's\n         no point in trying to download anything or in complaining about\n         it.  (An empty directory should not cause complaints.)\n      */\n    }\n  freefileinfo (start);\n  if (opt.quota && total_downloaded_bytes > opt.quota)\n    return QUOTEXC;\n  else\n    return res;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147645,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "std::string TarFileReader::extract(const string &_path) {\n  if (_path.empty()) THROW(\"path cannot be empty\");\n  if (!hasMore()) THROW(\"No more tar files\");\n\n  string path = _path;\n  if (SystemUtilities::isDirectory(path)) path += \"/\" + getFilename();\n\n  LOG_DEBUG(5, \"Extracting: \" << path);\n\n  return extract(*SystemUtilities::oopen(path));\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147866,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "std::string TarFileReader::extract(const string &_path) {\n  if (_path.empty()) THROW(\"path cannot be empty\");\n  if (!hasMore()) THROW(\"No more tar files\");\n\n  string path = _path;\n  if (SystemUtilities::isDirectory(path)) {\n    path += \"/\" + getFilename();\n\n    // Check that path is under the target directory\n    string a = SystemUtilities::getCanonicalPath(_path);\n    string b = SystemUtilities::getCanonicalPath(path);\n    if (!String::startsWith(b, a))\n      THROW(\"Tar path points outside of the extraction directory: \" << path);\n  }\n\n  LOG_DEBUG(5, \"Extracting: \" << path);\n\n  switch (getType()) {\n  case NORMAL_FILE: case CONTIGUOUS_FILE:\n    return extract(*SystemUtilities::oopen(path));\n  case DIRECTORY: SystemUtilities::ensureDirectory(path); break;\n  default: THROW(\"Unsupported tar file type \" << getType());\n  }\n\n  return getFilename();\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147867,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "PLT_HttpServer::ServeFile(const NPT_HttpRequest&        request, \n                          const NPT_HttpRequestContext& context,\n                          NPT_HttpResponse&             response,\n                          NPT_String                    file_path) \n{\n    NPT_InputStreamReference stream;\n    NPT_File                 file(file_path);\n    NPT_FileInfo             file_info;\n    \n    // prevent hackers from accessing files outside of our root\n    if ((file_path.Find(\"/..\") >= 0) || (file_path.Find(\"\\\\..\") >= 0) ||\n        NPT_FAILED(NPT_File::GetInfo(file_path, &file_info))) {\n        return NPT_ERROR_NO_SUCH_ITEM;\n    }\n    \n    // check for range requests\n    const NPT_String* range_spec = request.GetHeaders().GetHeaderValue(NPT_HTTP_HEADER_RANGE);\n    \n    // handle potential 304 only if range header not set\n    NPT_DateTime  date;\n    NPT_TimeStamp timestamp;\n    if (NPT_SUCCEEDED(PLT_UPnPMessageHelper::GetIfModifiedSince((NPT_HttpMessage&)request, date)) &&\n        !range_spec) {\n        date.ToTimeStamp(timestamp);\n        \n        NPT_LOG_INFO_5(\"File %s timestamps: request=%d (%s) vs file=%d (%s)\", \n                       (const char*)request.GetUrl().GetPath(),\n                       (NPT_UInt32)timestamp.ToSeconds(),\n                       (const char*)date.ToString(),\n                       (NPT_UInt32)file_info.m_ModificationTime,\n                       (const char*)NPT_DateTime(file_info.m_ModificationTime).ToString());\n        \n        if (timestamp >= file_info.m_ModificationTime) {\n            // it's a match\n            NPT_LOG_FINE_1(\"Returning 304 for %s\", request.GetUrl().GetPath().GetChars());\n            response.SetStatus(304, \"Not Modified\", NPT_HTTP_PROTOCOL_1_1);\n            return NPT_SUCCESS;\n        }\n    }\n    \n    // open file\n    if (NPT_FAILED(file.Open(NPT_FILE_OPEN_MODE_READ)) || \n        NPT_FAILED(file.GetInputStream(stream))        ||\n        stream.IsNull()) {\n        return NPT_ERROR_NO_SUCH_ITEM;\n    }\n    \n    // set Last-Modified and Cache-Control headers\n    if (file_info.m_ModificationTime) {\n        NPT_DateTime last_modified = NPT_DateTime(file_info.m_ModificationTime);\n        response.GetHeaders().SetHeader(\"Last-Modified\", last_modified.ToString(NPT_DateTime::FORMAT_RFC_1123), true);\n        response.GetHeaders().SetHeader(\"Cache-Control\", \"max-age=0,must-revalidate\", true);\n        //response.GetHeaders().SetHeader(\"Cache-Control\", \"max-age=1800\", true);\n    }\n    \n    PLT_HttpRequestContext tmp_context(request, context);\n    return ServeStream(request, context, response, stream, PLT_MimeType::GetMimeType(file_path, &tmp_context));\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147870,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "PLT_HttpServer::ServeFile(const NPT_HttpRequest&        request, \n                          const NPT_HttpRequestContext& context,\n                          NPT_HttpResponse&             response,\n                          NPT_String                    file_path) \n{\n    NPT_InputStreamReference stream;\n    NPT_File                 file(file_path);\n    NPT_FileInfo             file_info;\n    \n    // prevent hackers from accessing files outside of our root\n    if ((file_path.Find(\"../\") >= 0) || (file_path.Find(\"..\\\\\") >= 0) ||\n        NPT_FAILED(NPT_File::GetInfo(file_path, &file_info))) {\n        return NPT_ERROR_NO_SUCH_ITEM;\n    }\n    \n    // check for range requests\n    const NPT_String* range_spec = request.GetHeaders().GetHeaderValue(NPT_HTTP_HEADER_RANGE);\n    \n    // handle potential 304 only if range header not set\n    NPT_DateTime  date;\n    NPT_TimeStamp timestamp;\n    if (NPT_SUCCEEDED(PLT_UPnPMessageHelper::GetIfModifiedSince((NPT_HttpMessage&)request, date)) &&\n        !range_spec) {\n        date.ToTimeStamp(timestamp);\n        \n        NPT_LOG_INFO_5(\"File %s timestamps: request=%d (%s) vs file=%d (%s)\", \n                       (const char*)request.GetUrl().GetPath(),\n                       (NPT_UInt32)timestamp.ToSeconds(),\n                       (const char*)date.ToString(),\n                       (NPT_UInt32)file_info.m_ModificationTime,\n                       (const char*)NPT_DateTime(file_info.m_ModificationTime).ToString());\n        \n        if (timestamp >= file_info.m_ModificationTime) {\n            // it's a match\n            NPT_LOG_FINE_1(\"Returning 304 for %s\", request.GetUrl().GetPath().GetChars());\n            response.SetStatus(304, \"Not Modified\", NPT_HTTP_PROTOCOL_1_1);\n            return NPT_SUCCESS;\n        }\n    }\n    \n    // open file\n    if (NPT_FAILED(file.Open(NPT_FILE_OPEN_MODE_READ)) || \n        NPT_FAILED(file.GetInputStream(stream))        ||\n        stream.IsNull()) {\n        return NPT_ERROR_NO_SUCH_ITEM;\n    }\n    \n    // set Last-Modified and Cache-Control headers\n    if (file_info.m_ModificationTime) {\n        NPT_DateTime last_modified = NPT_DateTime(file_info.m_ModificationTime);\n        response.GetHeaders().SetHeader(\"Last-Modified\", last_modified.ToString(NPT_DateTime::FORMAT_RFC_1123), true);\n        response.GetHeaders().SetHeader(\"Cache-Control\", \"max-age=0,must-revalidate\", true);\n        //response.GetHeaders().SetHeader(\"Cache-Control\", \"max-age=1800\", true);\n    }\n    \n    PLT_HttpRequestContext tmp_context(request, context);\n    return ServeStream(request, context, response, stream, PLT_MimeType::GetMimeType(file_path, &tmp_context));\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147871,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "CString CWebSock::GetSkinPath(const CString& sSkinName) {\n    CString sRet = CZNC::Get().GetZNCPath() + \"/webskins/\" + sSkinName;\n\n    if (!CFile::IsDir(sRet)) {\n        sRet = CZNC::Get().GetCurPath() + \"/webskins/\" + sSkinName;\n\n        if (!CFile::IsDir(sRet)) {\n            sRet = CString(_SKINDIR_) + \"/\" + sSkinName;\n        }\n    }\n\n    return sRet + \"/\";\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148086,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "CString CWebSock::GetSkinPath(const CString& sSkinName) {\n    const CString sSkin = sSkinName.Replace_n(\"/\", \"_\").Replace_n(\".\", \"_\");\n\n    CString sRet = CZNC::Get().GetZNCPath() + \"/webskins/\" + sSkin;\n\n    if (!CFile::IsDir(sRet)) {\n        sRet = CZNC::Get().GetCurPath() + \"/webskins/\" + sSkin;\n\n        if (!CFile::IsDir(sRet)) {\n            sRet = CString(_SKINDIR_) + \"/\" + sSkin;\n        }\n    }\n\n    return sRet + \"/\";\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148087,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "prepare_repo_download_targets(LrHandle *handle,\n                              LrYumRepo *repo,\n                              LrYumRepoMd *repomd,\n                              LrMetadataTarget *mdtarget,\n                              GSList **targets,\n                              GSList **cbdata_list,\n                              GError **err)\n{\n    char *destdir;  /* Destination dir */\n\n    destdir = handle->destdir;\n    assert(destdir);\n    assert(strlen(destdir));\n    assert(!err || *err == NULL);\n\n    if(handle->cachedir) {\n        lr_yum_switch_to_zchunk(handle, repomd);\n        repo->use_zchunk = TRUE;\n    } else {\n        g_debug(\"%s: Cache directory not set, disabling zchunk\", __func__);\n        repo->use_zchunk = FALSE;\n    }\n\n    for (GSList *elem = repomd->records; elem; elem = g_slist_next(elem)) {\n        int fd;\n        char *path;\n        LrDownloadTarget *target;\n        LrYumRepoMdRecord *record = elem->data;\n        CbData *cbdata = NULL;\n        void *user_cbdata = NULL;\n        LrEndCb endcb = NULL;\n\n        if (mdtarget != NULL) {\n            user_cbdata = mdtarget->cbdata;\n            endcb = mdtarget->endcb;\n        }\n\n        assert(record);\n\n        if (!lr_yum_repomd_record_enabled(handle, record->type, repomd->records))\n            continue;\n\n        char *location_href = record->location_href;\n        gboolean is_zchunk = FALSE;\n        #ifdef WITH_ZCHUNK\n        if (handle->cachedir && record->header_checksum)\n            is_zchunk = TRUE;\n        #endif /* WITH_ZCHUNK */\n\n        GSList *checksums = NULL;\n        if (is_zchunk) {\n            #ifdef WITH_ZCHUNK\n            if(!prepare_repo_download_zck_target(handle, record, &path, &fd,\n                                                 &checksums, targets, err))\n                return FALSE;\n            #endif /* WITH_ZCHUNK */\n        } else {\n            if(!prepare_repo_download_std_target(handle, record, &path, &fd,\n                                                 &checksums, targets, err))\n                return FALSE;\n        }\n\n        if (handle->user_cb || handle->hmfcb) {\n            cbdata = cbdata_new(handle->user_data,\n                                user_cbdata,\n                                handle->user_cb,\n                                handle->hmfcb,\n                                record->type);\n            *cbdata_list = g_slist_append(*cbdata_list, cbdata);\n        }\n\n        target = lr_downloadtarget_new(handle,\n                                       location_href,\n                                       record->location_base,\n                                       fd,\n                                       NULL,\n                                       checksums,\n                                       0,\n                                       0,\n                                       NULL,\n                                       cbdata,\n                                       endcb,\n                                       NULL,\n                                       NULL,\n                                       0,\n                                       0,\n                                       NULL,\n                                       FALSE,\n                                       is_zchunk);\n\n        if(is_zchunk) {\n            #ifdef WITH_ZCHUNK\n            target->expectedsize = record->size_header;\n            target->zck_header_size = record->size_header;\n            #endif /* WITH_ZCHUNK */\n        }\n\n        if (mdtarget != NULL)\n            mdtarget->repomd_records_to_download++;\n        *targets = g_slist_append(*targets, target);\n\n        /* Because path may already exists in repo (while update) */\n        lr_yum_repo_update(repo, record->type, path);\n        lr_free(path);\n    }\n\n    return TRUE;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148430,
    "human": "Correct. With CWE-22",
    "reason": "There's no explicit checks that location_href (the partial path) is inside handle->destdir.",
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "prepare_repo_download_targets(LrHandle *handle,\n                              LrYumRepo *repo,\n                              LrYumRepoMd *repomd,\n                              LrMetadataTarget *mdtarget,\n                              GSList **targets,\n                              GSList **cbdata_list,\n                              GError **err)\n{\n    char *destdir;  /* Destination dir */\n\n    destdir = handle->destdir;\n    assert(destdir);\n    assert(strlen(destdir));\n    assert(!err || *err == NULL);\n\n    if(handle->cachedir) {\n        lr_yum_switch_to_zchunk(handle, repomd);\n        repo->use_zchunk = TRUE;\n    } else {\n        g_debug(\"%s: Cache directory not set, disabling zchunk\", __func__);\n        repo->use_zchunk = FALSE;\n    }\n\n    for (GSList *elem = repomd->records; elem; elem = g_slist_next(elem)) {\n        int fd;\n        char *path;\n        LrDownloadTarget *target;\n        LrYumRepoMdRecord *record = elem->data;\n        CbData *cbdata = NULL;\n        void *user_cbdata = NULL;\n        LrEndCb endcb = NULL;\n\n        if (mdtarget != NULL) {\n            user_cbdata = mdtarget->cbdata;\n            endcb = mdtarget->endcb;\n        }\n\n        assert(record);\n\n        if (!lr_yum_repomd_record_enabled(handle, record->type, repomd->records))\n            continue;\n\n        char *location_href = record->location_href;\n\n        char *dest_dir = realpath(handle->destdir, NULL);\n        path = lr_pathconcat(handle->destdir, record->location_href, NULL);\n        char *requested_dir = realpath(dirname(path), NULL);\n        lr_free(path);\n        if (!g_str_has_prefix(requested_dir, dest_dir)) {\n            g_debug(\"%s: Invalid path: %s\", __func__, location_href);\n            g_set_error(err, LR_YUM_ERROR, LRE_IO, \"Invalid path: %s\", location_href);\n            g_slist_free_full(*targets, (GDestroyNotify) lr_downloadtarget_free);\n            free(requested_dir);\n            free(dest_dir);\n            return FALSE;\n        }\n        free(requested_dir);\n        free(dest_dir);\n\n        gboolean is_zchunk = FALSE;\n        #ifdef WITH_ZCHUNK\n        if (handle->cachedir && record->header_checksum)\n            is_zchunk = TRUE;\n        #endif /* WITH_ZCHUNK */\n\n        GSList *checksums = NULL;\n        if (is_zchunk) {\n            #ifdef WITH_ZCHUNK\n            if(!prepare_repo_download_zck_target(handle, record, &path, &fd,\n                                                 &checksums, targets, err))\n                return FALSE;\n            #endif /* WITH_ZCHUNK */\n        } else {\n            if(!prepare_repo_download_std_target(handle, record, &path, &fd,\n                                                 &checksums, targets, err))\n                return FALSE;\n        }\n\n        if (handle->user_cb || handle->hmfcb) {\n            cbdata = cbdata_new(handle->user_data,\n                                user_cbdata,\n                                handle->user_cb,\n                                handle->hmfcb,\n                                record->type);\n            *cbdata_list = g_slist_append(*cbdata_list, cbdata);\n        }\n\n        target = lr_downloadtarget_new(handle,\n                                       location_href,\n                                       record->location_base,\n                                       fd,\n                                       NULL,\n                                       checksums,\n                                       0,\n                                       0,\n                                       NULL,\n                                       cbdata,\n                                       endcb,\n                                       NULL,\n                                       NULL,\n                                       0,\n                                       0,\n                                       NULL,\n                                       FALSE,\n                                       is_zchunk);\n\n        if(is_zchunk) {\n            #ifdef WITH_ZCHUNK\n            target->expectedsize = record->size_header;\n            target->zck_header_size = record->size_header;\n            #endif /* WITH_ZCHUNK */\n        }\n\n        if (mdtarget != NULL)\n            mdtarget->repomd_records_to_download++;\n        *targets = g_slist_append(*targets, target);\n\n        /* Because path may already exists in repo (while update) */\n        lr_yum_repo_update(repo, record->type, path);\n        lr_free(path);\n    }\n\n    return TRUE;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148431,
    "human": "Correct. Without CWE-22",
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "check_tty(const char *tty)\n{\n\t/* Check that we're not being set up to take a fall. */\n\tif ((tty == NULL) || (strlen(tty) == 0)) {\n\t\treturn NULL;\n\t}\n\t/* Pull out the meaningful part of the tty's name. */\n\tif (strchr(tty, '/') != NULL) {\n\t\tif (strncmp(tty, \"/dev/\", 5) != 0) {\n\t\t\t/* Make sure the device node is actually in /dev/,\n\t\t\t * noted by Michal Zalewski. */\n\t\t\treturn NULL;\n\t\t}\n\t\ttty = strrchr(tty, '/') + 1;\n\t}\n\t/* Make sure the tty wasn't actually a directory (no basename). */\n\tif (strlen(tty) == 0) {\n\t\treturn NULL;\n\t}\n\treturn tty;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148552,
    "human": "Correct. With CWE-22",
    "reason": "This code has basic validation but fails to check for special directory names ('.' or '..') and encoded path traversal patterns.",
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "check_tty(const char *tty)\n{\n\t/* Check that we're not being set up to take a fall. */\n\tif ((tty == NULL) || (strlen(tty) == 0)) {\n\t\treturn NULL;\n\t}\n\t/* Pull out the meaningful part of the tty's name. */\n\tif (strchr(tty, '/') != NULL) {\n\t\tif (strncmp(tty, \"/dev/\", 5) != 0) {\n\t\t\t/* Make sure the device node is actually in /dev/,\n\t\t\t * noted by Michal Zalewski. */\n\t\t\treturn NULL;\n\t\t}\n\t\ttty = strrchr(tty, '/') + 1;\n\t}\n\t/* Make sure the tty wasn't actually a directory (no basename). */\n\tif (!strlen(tty) || !strcmp(tty, \".\") || !strcmp(tty, \"..\")) {\n\t\treturn NULL;\n\t}\n\treturn tty;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148553,
    "human": "Correct. Without CWE-22",
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "get_ruser(pam_handle_t *pamh, char *ruserbuf, size_t ruserbuflen)\n{\n\tconst void *ruser;\n\tstruct passwd *pwd;\n\n\tif (ruserbuf == NULL || ruserbuflen < 1)\n\t\treturn -2;\n\t/* Get the name of the source user. */\n\tif (pam_get_item(pamh, PAM_RUSER, &ruser) != PAM_SUCCESS) {\n\t\truser = NULL;\n\t}\n\tif ((ruser == NULL) || (strlen(ruser) == 0)) {\n\t\t/* Barring that, use the current RUID. */\n\t\tpwd = pam_modutil_getpwuid(pamh, getuid());\n\t\tif (pwd != NULL) {\n\t\t\truser = pwd->pw_name;\n\t\t}\n\t}\n\tif (ruser == NULL || strlen(ruser) >= ruserbuflen) {\n\t\t*ruserbuf = '\\0';\n\t\treturn -1;\n\t}\n\tstrcpy(ruserbuf, ruser);\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148554,
    "human": "Correct. With CWE-22",
    "reason": "Vulnerable to path traversal since ruser is used unchecked in pathname construction.",
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "get_ruser(pam_handle_t *pamh, char *ruserbuf, size_t ruserbuflen)\n{\n\tconst void *ruser;\n\tstruct passwd *pwd;\n\n\tif (ruserbuf == NULL || ruserbuflen < 1)\n\t\treturn -2;\n\t/* Get the name of the source user. */\n\tif (pam_get_item(pamh, PAM_RUSER, &ruser) != PAM_SUCCESS) {\n\t\truser = NULL;\n\t}\n\tif ((ruser == NULL) || (strlen(ruser) == 0)) {\n\t\t/* Barring that, use the current RUID. */\n\t\tpwd = pam_modutil_getpwuid(pamh, getuid());\n\t\tif (pwd != NULL) {\n\t\t\truser = pwd->pw_name;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * This ruser is used by format_timestamp_name as a component\n\t\t * of constructed timestamp pathname, so \".\", \"..\", and '/'\n\t\t * are disallowed to avoid potential path traversal issues.\n\t\t */\n\t\tif (!strcmp(ruser, \".\") ||\n\t\t    !strcmp(ruser, \"..\") ||\n\t\t    strchr(ruser, '/')) {\n\t\t\truser = NULL;\n\t\t}\n\t}\n\tif (ruser == NULL || strlen(ruser) >= ruserbuflen) {\n\t\t*ruserbuf = '\\0';\n\t\treturn -1;\n\t}\n\tstrcpy(ruserbuf, ruser);\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148555,
    "human": "Correct. Without CWE-22",
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "long dd_get_item_size(struct dump_dir *dd, const char *name)\n{\n    long size = -1;\n    char *iname = concat_path_file(dd->dd_dirname, name);\n    struct stat statbuf;\n\n    if (lstat(iname, &statbuf) == 0 && S_ISREG(statbuf.st_mode))\n        size = statbuf.st_size;\n    else\n    {\n        if (errno == ENOENT)\n            size = 0;\n        else\n            perror_msg(\"Can't get size of file '%s'\", iname);\n    }\n\n    free(iname);\n\n    return size;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149562,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "long dd_get_item_size(struct dump_dir *dd, const char *name)\n{\n    if (!str_is_correct_filename(name))\n        error_msg_and_die(\"Cannot get item size. '%s' is not a valid file name\", name);\n\n    long size = -1;\n    char *iname = concat_path_file(dd->dd_dirname, name);\n    struct stat statbuf;\n\n    if (lstat(iname, &statbuf) == 0 && S_ISREG(statbuf.st_mode))\n        size = statbuf.st_size;\n    else\n    {\n        if (errno == ENOENT)\n            size = 0;\n        else\n            perror_msg(\"Can't get size of file '%s'\", iname);\n    }\n\n    free(iname);\n\n    return size;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149563,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "static int nntp_hcache_namer(const char *path, char *dest, size_t destlen)\n{\n  return snprintf(dest, destlen, \"%s.hcache\", path);\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149564,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "static int nntp_hcache_namer(const char *path, char *dest, size_t destlen)\n{\n  int count = snprintf(dest, destlen, \"%s.hcache\", path);\n\n  /* Strip out any directories in the path */\n  char *first = strchr(dest, '/');\n  char *last = strrchr(dest, '/');\n  if (first && last && (last > first))\n  {\n    memmove(first, last, strlen(last) + 1);\n    count -= (last - first);\n  }\n\n  return count;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149565,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "static void handle_method_call(GDBusConnection *connection,\n                        const gchar *caller,\n                        const gchar *object_path,\n                        const gchar *interface_name,\n                        const gchar *method_name,\n                        GVariant    *parameters,\n                        GDBusMethodInvocation *invocation,\n                        gpointer    user_data)\n{\n    reset_timeout();\n\n    uid_t caller_uid;\n    GVariant *response;\n\n    caller_uid = get_caller_uid(connection, invocation, caller);\n\n    log_notice(\"caller_uid:%ld method:'%s'\", (long)caller_uid, method_name);\n\n    if (caller_uid == (uid_t) -1)\n        return;\n\n    if (g_strcmp0(method_name, \"NewProblem\") == 0)\n    {\n        char *error = NULL;\n        char *problem_id = handle_new_problem(g_variant_get_child_value(parameters, 0), caller_uid, &error);\n        if (!problem_id)\n        {\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                                      \"org.freedesktop.problems.Failure\",\n                                                      error);\n            free(error);\n            return;\n        }\n        /* else */\n        response = g_variant_new(\"(s)\", problem_id);\n        g_dbus_method_invocation_return_value(invocation, response);\n        free(problem_id);\n\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetProblems\") == 0)\n    {\n        GList *dirs = get_problem_dirs_for_uid(caller_uid, g_settings_dump_location);\n        response = variant_from_string_list(dirs);\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        //I was told that g_dbus_method frees the response\n        //g_variant_unref(response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetAllProblems\") == 0)\n    {\n        /*\n        - so, we have UID,\n        - if it's 0, then we don't have to check anything and just return all directories\n        - if uid != 0 then we want to ask for authorization\n        */\n        if (caller_uid != 0)\n        {\n            if (polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") == PolkitYes)\n                caller_uid = 0;\n        }\n\n        GList * dirs = get_problem_dirs_for_uid(caller_uid, g_settings_dump_location);\n        response = variant_from_string_list(dirs);\n\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetForeignProblems\") == 0)\n    {\n        GList * dirs = get_problem_dirs_not_accessible_by_uid(caller_uid, g_settings_dump_location);\n        response = variant_from_string_list(dirs);\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"ChownProblemDir\") == 0)\n    {\n        const gchar *problem_dir;\n        g_variant_get(parameters, \"(&s)\", &problem_dir);\n        log_notice(\"problem_dir:'%s'\", problem_dir);\n\n        if (!allowed_problem_dir(problem_dir))\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int dir_fd = dd_openfd(problem_dir);\n        if (dir_fd < 0)\n        {\n            perror_msg(\"can't open problem directory '%s'\", problem_dir);\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int ddstat = fdump_dir_stat_for_uid(dir_fd, caller_uid);\n        if (ddstat < 0)\n        {\n            if (errno == ENOTDIR)\n            {\n                log_notice(\"requested directory does not exist '%s'\", problem_dir);\n            }\n            else\n            {\n                perror_msg(\"can't get stat of '%s'\", problem_dir);\n            }\n\n            return_InvalidProblemDir_error(invocation, problem_dir);\n\n            close(dir_fd);\n            return;\n        }\n\n        if (ddstat & DD_STAT_OWNED_BY_UID)\n        {   //caller seems to be in group with access to this dir, so no action needed\n            log_notice(\"caller has access to the requested directory %s\", problem_dir);\n            g_dbus_method_invocation_return_value(invocation, NULL);\n            close(dir_fd);\n            return;\n        }\n\n        if ((ddstat & DD_STAT_ACCESSIBLE_BY_UID) == 0 &&\n                polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") != PolkitYes)\n        {\n            log_notice(\"not authorized\");\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.AuthFailure\",\n                                              _(\"Not Authorized\"));\n            close(dir_fd);\n            return;\n        }\n\n        struct dump_dir *dd = dd_fdopendir(dir_fd, problem_dir, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES);\n        if (!dd)\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int chown_res = dd_chown(dd, caller_uid);\n        if (chown_res != 0)\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.ChownError\",\n                                              _(\"Chowning directory failed. Check system logs for more details.\"));\n        else\n            g_dbus_method_invocation_return_value(invocation, NULL);\n\n        dd_close(dd);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetInfo\") == 0)\n    {\n        /* Parameter tuple is (sas) */\n\n\t/* Get 1st param - problem dir name */\n        const gchar *problem_dir;\n        g_variant_get_child(parameters, 0, \"&s\", &problem_dir);\n        log_notice(\"problem_dir:'%s'\", problem_dir);\n\n        if (!allowed_problem_dir(problem_dir))\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int dir_fd = dd_openfd(problem_dir);\n        if (dir_fd < 0)\n        {\n            perror_msg(\"can't open problem directory '%s'\", problem_dir);\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        if (!fdump_dir_accessible_by_uid(dir_fd, caller_uid))\n        {\n            if (errno == ENOTDIR)\n            {\n                log_notice(\"Requested directory does not exist '%s'\", problem_dir);\n                return_InvalidProblemDir_error(invocation, problem_dir);\n                close(dir_fd);\n                return;\n            }\n\n            if (polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") != PolkitYes)\n            {\n                log_notice(\"not authorized\");\n                g_dbus_method_invocation_return_dbus_error(invocation,\n                                                  \"org.freedesktop.problems.AuthFailure\",\n                                                  _(\"Not Authorized\"));\n                close(dir_fd);\n                return;\n            }\n        }\n\n        struct dump_dir *dd = dd_fdopendir(dir_fd, problem_dir, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES);\n        if (!dd)\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n\t/* Get 2nd param - vector of element names */\n        GVariant *array = g_variant_get_child_value(parameters, 1);\n        GList *elements = string_list_from_variant(array);\n        g_variant_unref(array);\n\n        GVariantBuilder *builder = NULL;\n        for (GList *l = elements; l; l = l->next)\n        {\n            const char *element_name = (const char*)l->data;\n            char *value = dd_load_text_ext(dd, element_name, 0\n                                                | DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE\n                                                | DD_FAIL_QUIETLY_ENOENT\n                                                | DD_FAIL_QUIETLY_EACCES);\n            log_notice(\"element '%s' %s\", element_name, value ? \"fetched\" : \"not found\");\n            if (value)\n            {\n                if (!builder)\n                    builder = g_variant_builder_new(G_VARIANT_TYPE_ARRAY);\n\n                /* g_variant_builder_add makes a copy. No need to xstrdup here */\n                g_variant_builder_add(builder, \"{ss}\", element_name, value);\n                free(value);\n            }\n        }\n        list_free_with_free(elements);\n        dd_close(dd);\n        /* It is OK to call g_variant_new(\"(a{ss})\", NULL) because */\n        /* G_VARIANT_TYPE_TUPLE allows NULL value */\n        GVariant *response = g_variant_new(\"(a{ss})\", builder);\n\n        if (builder)\n            g_variant_builder_unref(builder);\n\n        log_info(\"GetInfo: returning value for '%s'\", problem_dir);\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"SetElement\") == 0)\n    {\n        const char *problem_id;\n        const char *element;\n        const char *value;\n\n        g_variant_get(parameters, \"(&s&s&s)\", &problem_id, &element, &value);\n\n        if (!str_is_correct_filename(element))\n        {\n            log_notice(\"'%s' is not a valid element name of '%s'\", element, problem_id);\n            char *error = xasprintf(_(\"'%s' is not a valid element name\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.InvalidElement\",\n                                              error);\n\n            free(error);\n            return;\n        }\n\n        struct dump_dir *dd = open_directory_for_modification_of_element(\n                                    invocation, caller_uid, problem_id, element);\n        if (!dd)\n            /* Already logged from open_directory_for_modification_of_element() */\n            return;\n\n        /* Is it good idea to make it static? Is it possible to change the max size while a single run? */\n        const double max_dir_size = g_settings_nMaxCrashReportsSize * (1024 * 1024);\n        const long item_size = dd_get_item_size(dd, element);\n        if (item_size < 0)\n        {\n            log_notice(\"Can't get size of '%s/%s'\", problem_id, element);\n            char *error = xasprintf(_(\"Can't get size of '%s'\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                                      \"org.freedesktop.problems.Failure\",\n                                                      error);\n            return;\n        }\n\n        const double requested_size = (double)strlen(value) - item_size;\n        /* Don't want to check the size limit in case of reducing of size */\n        if (requested_size > 0\n            && requested_size > (max_dir_size - get_dirsize(g_settings_dump_location)))\n        {\n            log_notice(\"No problem space left in '%s' (requested Bytes %f)\", problem_id, requested_size);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                                      \"org.freedesktop.problems.Failure\",\n                                                      _(\"No problem space left\"));\n        }\n        else\n        {\n            dd_save_text(dd, element, value);\n            g_dbus_method_invocation_return_value(invocation, NULL);\n        }\n\n        dd_close(dd);\n\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"DeleteElement\") == 0)\n    {\n        const char *problem_id;\n        const char *element;\n\n        g_variant_get(parameters, \"(&s&s)\", &problem_id, &element);\n\n        if (!str_is_correct_filename(element))\n        {\n            log_notice(\"'%s' is not a valid element name of '%s'\", element, problem_id);\n            char *error = xasprintf(_(\"'%s' is not a valid element name\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.InvalidElement\",\n                                              error);\n\n            free(error);\n            return;\n        }\n\n        struct dump_dir *dd = open_directory_for_modification_of_element(\n                                    invocation, caller_uid, problem_id, element);\n        if (!dd)\n            /* Already logged from open_directory_for_modification_of_element() */\n            return;\n\n        const int res = dd_delete_item(dd, element);\n        dd_close(dd);\n\n        if (res != 0)\n        {\n            log_notice(\"Can't delete the element '%s' from the problem directory '%s'\", element, problem_id);\n            char *error = xasprintf(_(\"Can't delete the element '%s' from the problem directory '%s'\"), element, problem_id);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                          \"org.freedesktop.problems.Failure\",\n                                          error);\n            free(error);\n            return;\n        }\n\n\n        g_dbus_method_invocation_return_value(invocation, NULL);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"DeleteProblem\") == 0)\n    {\n        /* Dbus parameters are always tuples.\n         * In this case, it's (as) - a tuple of one element (array of strings).\n         * Need to fetch the array:\n         */\n        GVariant *array = g_variant_get_child_value(parameters, 0);\n        GList *problem_dirs = string_list_from_variant(array);\n        g_variant_unref(array);\n\n        for (GList *l = problem_dirs; l; l = l->next)\n        {\n            const char *dir_name = (const char*)l->data;\n            log_notice(\"dir_name:'%s'\", dir_name);\n            if (!allowed_problem_dir(dir_name))\n            {\n                return_InvalidProblemDir_error(invocation, dir_name);\n                goto ret;\n            }\n        }\n\n        for (GList *l = problem_dirs; l; l = l->next)\n        {\n            const char *dir_name = (const char*)l->data;\n\n            int dir_fd = dd_openfd(dir_name);\n            if (dir_fd < 0)\n            {\n                perror_msg(\"can't open problem directory '%s'\", dir_name);\n                return_InvalidProblemDir_error(invocation, dir_name);\n                return;\n            }\n\n            if (!fdump_dir_accessible_by_uid(dir_fd, caller_uid))\n            {\n                if (errno == ENOTDIR)\n                {\n                    log_notice(\"Requested directory does not exist '%s'\", dir_name);\n                    close(dir_fd);\n                    continue;\n                }\n\n                if (polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") != PolkitYes)\n                { // if user didn't provide correct credentials, just move to the next dir\n                    close(dir_fd);\n                    continue;\n                }\n            }\n\n            struct dump_dir *dd = dd_fdopendir(dir_fd, dir_name, /*flags:*/ 0);\n            if (dd)\n            {\n                if (dd_delete(dd) != 0)\n                {\n                    error_msg(\"Failed to delete problem directory '%s'\", dir_name);\n                    dd_close(dd);\n                }\n            }\n        }\n\n        g_dbus_method_invocation_return_value(invocation, NULL);\n ret:\n        list_free_with_free(problem_dirs);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"FindProblemByElementInTimeRange\") == 0)\n    {\n        const gchar *element;\n        const gchar *value;\n        glong timestamp_from;\n        glong timestamp_to;\n        gboolean all;\n\n        g_variant_get_child(parameters, 0, \"&s\", &element);\n        g_variant_get_child(parameters, 1, \"&s\", &value);\n        g_variant_get_child(parameters, 2, \"x\", &timestamp_from);\n        g_variant_get_child(parameters, 3, \"x\", &timestamp_to);\n        g_variant_get_child(parameters, 4, \"b\", &all);\n\n        if (all && polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") == PolkitYes)\n            caller_uid = 0;\n\n        GList *dirs = get_problem_dirs_for_element_in_time(caller_uid, element, value, timestamp_from,\n                                                        timestamp_to);\n        response = variant_from_string_list(dirs);\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"Quit\") == 0)\n    {\n        g_dbus_method_invocation_return_value(invocation, NULL);\n        g_main_loop_quit(loop);\n        return;\n    }\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149568,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "static void handle_method_call(GDBusConnection *connection,\n                        const gchar *caller,\n                        const gchar *object_path,\n                        const gchar *interface_name,\n                        const gchar *method_name,\n                        GVariant    *parameters,\n                        GDBusMethodInvocation *invocation,\n                        gpointer    user_data)\n{\n    reset_timeout();\n\n    uid_t caller_uid;\n    GVariant *response;\n\n    caller_uid = get_caller_uid(connection, invocation, caller);\n\n    log_notice(\"caller_uid:%ld method:'%s'\", (long)caller_uid, method_name);\n\n    if (caller_uid == (uid_t) -1)\n        return;\n\n    if (g_strcmp0(method_name, \"NewProblem\") == 0)\n    {\n        char *error = NULL;\n        char *problem_id = handle_new_problem(g_variant_get_child_value(parameters, 0), caller_uid, &error);\n        if (!problem_id)\n        {\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                                      \"org.freedesktop.problems.Failure\",\n                                                      error);\n            free(error);\n            return;\n        }\n        /* else */\n        response = g_variant_new(\"(s)\", problem_id);\n        g_dbus_method_invocation_return_value(invocation, response);\n        free(problem_id);\n\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetProblems\") == 0)\n    {\n        GList *dirs = get_problem_dirs_for_uid(caller_uid, g_settings_dump_location);\n        response = variant_from_string_list(dirs);\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        //I was told that g_dbus_method frees the response\n        //g_variant_unref(response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetAllProblems\") == 0)\n    {\n        /*\n        - so, we have UID,\n        - if it's 0, then we don't have to check anything and just return all directories\n        - if uid != 0 then we want to ask for authorization\n        */\n        if (caller_uid != 0)\n        {\n            if (polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") == PolkitYes)\n                caller_uid = 0;\n        }\n\n        GList * dirs = get_problem_dirs_for_uid(caller_uid, g_settings_dump_location);\n        response = variant_from_string_list(dirs);\n\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetForeignProblems\") == 0)\n    {\n        GList * dirs = get_problem_dirs_not_accessible_by_uid(caller_uid, g_settings_dump_location);\n        response = variant_from_string_list(dirs);\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"ChownProblemDir\") == 0)\n    {\n        const gchar *problem_dir;\n        g_variant_get(parameters, \"(&s)\", &problem_dir);\n        log_notice(\"problem_dir:'%s'\", problem_dir);\n\n        if (!allowed_problem_dir(problem_dir))\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int dir_fd = dd_openfd(problem_dir);\n        if (dir_fd < 0)\n        {\n            perror_msg(\"can't open problem directory '%s'\", problem_dir);\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int ddstat = fdump_dir_stat_for_uid(dir_fd, caller_uid);\n        if (ddstat < 0)\n        {\n            if (errno == ENOTDIR)\n            {\n                log_notice(\"requested directory does not exist '%s'\", problem_dir);\n            }\n            else\n            {\n                perror_msg(\"can't get stat of '%s'\", problem_dir);\n            }\n\n            return_InvalidProblemDir_error(invocation, problem_dir);\n\n            close(dir_fd);\n            return;\n        }\n\n        if (ddstat & DD_STAT_OWNED_BY_UID)\n        {   //caller seems to be in group with access to this dir, so no action needed\n            log_notice(\"caller has access to the requested directory %s\", problem_dir);\n            g_dbus_method_invocation_return_value(invocation, NULL);\n            close(dir_fd);\n            return;\n        }\n\n        if ((ddstat & DD_STAT_ACCESSIBLE_BY_UID) == 0 &&\n                polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") != PolkitYes)\n        {\n            log_notice(\"not authorized\");\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.AuthFailure\",\n                                              _(\"Not Authorized\"));\n            close(dir_fd);\n            return;\n        }\n\n        struct dump_dir *dd = dd_fdopendir(dir_fd, problem_dir, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES);\n        if (!dd)\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int chown_res = dd_chown(dd, caller_uid);\n        if (chown_res != 0)\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.ChownError\",\n                                              _(\"Chowning directory failed. Check system logs for more details.\"));\n        else\n            g_dbus_method_invocation_return_value(invocation, NULL);\n\n        dd_close(dd);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetInfo\") == 0)\n    {\n        /* Parameter tuple is (sas) */\n\n\t/* Get 1st param - problem dir name */\n        const gchar *problem_dir;\n        g_variant_get_child(parameters, 0, \"&s\", &problem_dir);\n        log_notice(\"problem_dir:'%s'\", problem_dir);\n\n        if (!allowed_problem_dir(problem_dir))\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int dir_fd = dd_openfd(problem_dir);\n        if (dir_fd < 0)\n        {\n            perror_msg(\"can't open problem directory '%s'\", problem_dir);\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        if (!fdump_dir_accessible_by_uid(dir_fd, caller_uid))\n        {\n            if (errno == ENOTDIR)\n            {\n                log_notice(\"Requested directory does not exist '%s'\", problem_dir);\n                return_InvalidProblemDir_error(invocation, problem_dir);\n                close(dir_fd);\n                return;\n            }\n\n            if (polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") != PolkitYes)\n            {\n                log_notice(\"not authorized\");\n                g_dbus_method_invocation_return_dbus_error(invocation,\n                                                  \"org.freedesktop.problems.AuthFailure\",\n                                                  _(\"Not Authorized\"));\n                close(dir_fd);\n                return;\n            }\n        }\n\n        struct dump_dir *dd = dd_fdopendir(dir_fd, problem_dir, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES);\n        if (!dd)\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n\t/* Get 2nd param - vector of element names */\n        GVariant *array = g_variant_get_child_value(parameters, 1);\n        GList *elements = string_list_from_variant(array);\n        g_variant_unref(array);\n\n        GVariantBuilder *builder = NULL;\n        for (GList *l = elements; l; l = l->next)\n        {\n            const char *element_name = (const char*)l->data;\n            char *value = dd_load_text_ext(dd, element_name, 0\n                                                | DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE\n                                                | DD_FAIL_QUIETLY_ENOENT\n                                                | DD_FAIL_QUIETLY_EACCES);\n            log_notice(\"element '%s' %s\", element_name, value ? \"fetched\" : \"not found\");\n            if (value)\n            {\n                if (!builder)\n                    builder = g_variant_builder_new(G_VARIANT_TYPE_ARRAY);\n\n                /* g_variant_builder_add makes a copy. No need to xstrdup here */\n                g_variant_builder_add(builder, \"{ss}\", element_name, value);\n                free(value);\n            }\n        }\n        list_free_with_free(elements);\n        dd_close(dd);\n        /* It is OK to call g_variant_new(\"(a{ss})\", NULL) because */\n        /* G_VARIANT_TYPE_TUPLE allows NULL value */\n        GVariant *response = g_variant_new(\"(a{ss})\", builder);\n\n        if (builder)\n            g_variant_builder_unref(builder);\n\n        log_info(\"GetInfo: returning value for '%s'\", problem_dir);\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"SetElement\") == 0)\n    {\n        const char *problem_id;\n        const char *element;\n        const char *value;\n\n        g_variant_get(parameters, \"(&s&s&s)\", &problem_id, &element, &value);\n\n        if (!allowed_problem_dir(problem_id))\n        {\n            return_InvalidProblemDir_error(invocation, problem_id);\n            return;\n        }\n\n        if (!str_is_correct_filename(element))\n        {\n            log_notice(\"'%s' is not a valid element name of '%s'\", element, problem_id);\n            char *error = xasprintf(_(\"'%s' is not a valid element name\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.InvalidElement\",\n                                              error);\n\n            free(error);\n            return;\n        }\n\n        struct dump_dir *dd = open_directory_for_modification_of_element(\n                                    invocation, caller_uid, problem_id, element);\n        if (!dd)\n            /* Already logged from open_directory_for_modification_of_element() */\n            return;\n\n        /* Is it good idea to make it static? Is it possible to change the max size while a single run? */\n        const double max_dir_size = g_settings_nMaxCrashReportsSize * (1024 * 1024);\n        const long item_size = dd_get_item_size(dd, element);\n        if (item_size < 0)\n        {\n            log_notice(\"Can't get size of '%s/%s'\", problem_id, element);\n            char *error = xasprintf(_(\"Can't get size of '%s'\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                                      \"org.freedesktop.problems.Failure\",\n                                                      error);\n            return;\n        }\n\n        const double requested_size = (double)strlen(value) - item_size;\n        /* Don't want to check the size limit in case of reducing of size */\n        if (requested_size > 0\n            && requested_size > (max_dir_size - get_dirsize(g_settings_dump_location)))\n        {\n            log_notice(\"No problem space left in '%s' (requested Bytes %f)\", problem_id, requested_size);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                                      \"org.freedesktop.problems.Failure\",\n                                                      _(\"No problem space left\"));\n        }\n        else\n        {\n            dd_save_text(dd, element, value);\n            g_dbus_method_invocation_return_value(invocation, NULL);\n        }\n\n        dd_close(dd);\n\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"DeleteElement\") == 0)\n    {\n        const char *problem_id;\n        const char *element;\n\n        g_variant_get(parameters, \"(&s&s)\", &problem_id, &element);\n\n        if (!allowed_problem_dir(problem_id))\n        {\n            return_InvalidProblemDir_error(invocation, problem_id);\n            return;\n        }\n\n        if (!str_is_correct_filename(element))\n        {\n            log_notice(\"'%s' is not a valid element name of '%s'\", element, problem_id);\n            char *error = xasprintf(_(\"'%s' is not a valid element name\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.InvalidElement\",\n                                              error);\n\n            free(error);\n            return;\n        }\n\n        struct dump_dir *dd = open_directory_for_modification_of_element(\n                                    invocation, caller_uid, problem_id, element);\n        if (!dd)\n            /* Already logged from open_directory_for_modification_of_element() */\n            return;\n\n        const int res = dd_delete_item(dd, element);\n        dd_close(dd);\n\n        if (res != 0)\n        {\n            log_notice(\"Can't delete the element '%s' from the problem directory '%s'\", element, problem_id);\n            char *error = xasprintf(_(\"Can't delete the element '%s' from the problem directory '%s'\"), element, problem_id);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                          \"org.freedesktop.problems.Failure\",\n                                          error);\n            free(error);\n            return;\n        }\n\n\n        g_dbus_method_invocation_return_value(invocation, NULL);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"DeleteProblem\") == 0)\n    {\n        /* Dbus parameters are always tuples.\n         * In this case, it's (as) - a tuple of one element (array of strings).\n         * Need to fetch the array:\n         */\n        GVariant *array = g_variant_get_child_value(parameters, 0);\n        GList *problem_dirs = string_list_from_variant(array);\n        g_variant_unref(array);\n\n        for (GList *l = problem_dirs; l; l = l->next)\n        {\n            const char *dir_name = (const char*)l->data;\n            log_notice(\"dir_name:'%s'\", dir_name);\n            if (!allowed_problem_dir(dir_name))\n            {\n                return_InvalidProblemDir_error(invocation, dir_name);\n                goto ret;\n            }\n        }\n\n        for (GList *l = problem_dirs; l; l = l->next)\n        {\n            const char *dir_name = (const char*)l->data;\n\n            int dir_fd = dd_openfd(dir_name);\n            if (dir_fd < 0)\n            {\n                perror_msg(\"can't open problem directory '%s'\", dir_name);\n                return_InvalidProblemDir_error(invocation, dir_name);\n                return;\n            }\n\n            if (!fdump_dir_accessible_by_uid(dir_fd, caller_uid))\n            {\n                if (errno == ENOTDIR)\n                {\n                    log_notice(\"Requested directory does not exist '%s'\", dir_name);\n                    close(dir_fd);\n                    continue;\n                }\n\n                if (polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") != PolkitYes)\n                { // if user didn't provide correct credentials, just move to the next dir\n                    close(dir_fd);\n                    continue;\n                }\n            }\n\n            struct dump_dir *dd = dd_fdopendir(dir_fd, dir_name, /*flags:*/ 0);\n            if (dd)\n            {\n                if (dd_delete(dd) != 0)\n                {\n                    error_msg(\"Failed to delete problem directory '%s'\", dir_name);\n                    dd_close(dd);\n                }\n            }\n        }\n\n        g_dbus_method_invocation_return_value(invocation, NULL);\n ret:\n        list_free_with_free(problem_dirs);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"FindProblemByElementInTimeRange\") == 0)\n    {\n        const gchar *element;\n        const gchar *value;\n        glong timestamp_from;\n        glong timestamp_to;\n        gboolean all;\n\n        g_variant_get_child(parameters, 0, \"&s\", &element);\n        g_variant_get_child(parameters, 1, \"&s\", &value);\n        g_variant_get_child(parameters, 2, \"x\", &timestamp_from);\n        g_variant_get_child(parameters, 3, \"x\", &timestamp_to);\n        g_variant_get_child(parameters, 4, \"b\", &all);\n\n        if (!str_is_correct_filename(element))\n        {\n            log_notice(\"'%s' is not a valid element name\", element);\n            char *error = xasprintf(_(\"'%s' is not a valid element name\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.InvalidElement\",\n                                              error);\n\n            free(error);\n            return;\n        }\n\n        if (all && polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") == PolkitYes)\n            caller_uid = 0;\n\n        GList *dirs = get_problem_dirs_for_element_in_time(caller_uid, element, value, timestamp_from,\n                                                        timestamp_to);\n        response = variant_from_string_list(dirs);\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"Quit\") == 0)\n    {\n        g_dbus_method_invocation_return_value(invocation, NULL);\n        g_main_loop_quit(loop);\n        return;\n    }\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149569,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "set_interface_var(const char *iface,\n\t\t  const char *var, const char *name,\n\t\t  uint32_t val)\n{\n\tFILE *fp;\n\tchar spath[64+IFNAMSIZ];\t/* XXX: magic constant */\n\tif (snprintf(spath, sizeof(spath), var, iface) >= sizeof(spath))\n\t\treturn -1;\n\n\tif (access(spath, F_OK) != 0)\n\t\treturn -1;\n\n\tfp = fopen(spath, \"w\");\n\tif (!fp) {\n\t\tif (name)\n\t\t\tflog(LOG_ERR, \"failed to set %s (%u) for %s: %s\",\n\t\t\t     name, val, iface, strerror(errno));\n\t\treturn -1;\n\t}\n\tfprintf(fp, \"%u\", val);\n\tfclose(fp);\n\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149570,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "set_interface_var(const char *iface,\n\t\t  const char *var, const char *name,\n\t\t  uint32_t val)\n{\n\tFILE *fp;\n\tchar spath[64+IFNAMSIZ];\t/* XXX: magic constant */\n\tif (snprintf(spath, sizeof(spath), var, iface) >= sizeof(spath))\n\t\treturn -1;\n\n\t/* No path traversal */\n\tif (strstr(name, \"..\") || strchr(name, '/'))\n\t\treturn -1;\n\n\tif (access(spath, F_OK) != 0)\n\t\treturn -1;\n\n\tfp = fopen(spath, \"w\");\n\tif (!fp) {\n\t\tif (name)\n\t\t\tflog(LOG_ERR, \"failed to set %s (%u) for %s: %s\",\n\t\t\t     name, val, iface, strerror(errno));\n\t\treturn -1;\n\t}\n\tfprintf(fp, \"%u\", val);\n\tfclose(fp);\n\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149571,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "wiki_handle_http_request(HttpRequest *req)\n{\n  HttpResponse *res      = http_response_new(req);\n  char         *page     = http_request_get_path_info(req); \n  char         *command  = http_request_get_query_string(req); \n  char         *wikitext = \"\";\n\n  util_dehttpize(page); \t/* remove any encoding on the requested\n\t\t\t\t   page name.                           */\n\n  if (!strcmp(page, \"/\"))\n    {\n      if (access(\"WikiHome\", R_OK) != 0)\n\twiki_redirect(res, \"/WikiHome?create\");\n      page = \"/WikiHome\";\n    }\n\n  if (!strcmp(page, \"/styles.css\"))\n    {\n      /*  Return CSS page */\n      http_response_set_content_type(res, \"text/css\");\n      http_response_printf(res, \"%s\", CssData);\n      http_response_send(res);\n      exit(0);\n    }\n\n  if (!strcmp(page, \"/favicon.ico\"))\n    {\n      /*  Return favicon */\n      http_response_set_content_type(res, \"image/ico\");\n      http_response_set_data(res, FaviconData, FaviconDataLen);\n      http_response_send(res);\n      exit(0);\n    }\n\n\n  page = page + 1; \t\t/* skip slash */\n\n  if (!strncmp(page, \"api/\", 4))\n    {\n      char *p;\n\n      page += 4; \n      for (p=page; *p != '\\0'; p++)\n\tif (*p=='?') { *p ='\\0'; break; }\n      \n      wiki_handle_rest_call(req, res, page); \n      exit(0);\n    }\n\n  /* A little safety. issue a malformed request for any paths,\n   * There shouldn't need to be any..\n   */\n  if (strchr(page, '/'))\n    {\n      http_response_set_status(res, 404, \"Not Found\");\n      http_response_printf(res, \"<html><body>404 Not Found</body></html>\\n\");\n      http_response_send(res);\n      exit(0);\n    }\n\n  if (!strcmp(page, \"Changes\"))\n    {\n      wiki_show_changes_page(res);\n    }\n  else if (!strcmp(page, \"ChangesRss\"))\n    {\n      wiki_show_changes_page_rss(res);\n    }\n  else if (!strcmp(page, \"Search\"))\n    {\n      wiki_show_search_results_page(res, http_request_param_get(req, \"expr\"));\n    }\n  else if (!strcmp(page, \"Create\"))\n    {\n      if ( (wikitext = http_request_param_get(req, \"title\")) != NULL)\n\t{\n\t  /* create page and redirect */\n\t  wiki_redirect(res, http_request_param_get(req, \"title\"));\n\t}\n      else\n\t{\n\t   /* show create page form  */\n\t  wiki_show_create_page(res);\n\t}\n    }\n  else\n    {\n      /* TODO: dont blindly write wikitext data to disk */\n      if ( (wikitext = http_request_param_get(req, \"wikitext\")) != NULL)\n\t{\n\t  file_write(page, wikitext);\t      \n\t}\n\n      if (access(page, R_OK) == 0) \t/* page exists */\n\t{\n\t  wikitext = file_read(page);\n\t  \n\t  if (!strcmp(command, \"edit\"))\n\t    {\n\t      /* print edit page */\n\t      wiki_show_edit_page(res, wikitext, page);\n\t    }\n\t  else\n\t    {\n\t      wiki_show_page(res, wikitext, page);\n\t    }\n\t}\n      else\n\t{\n\t  if (!strcmp(command, \"create\"))\n\t    {\n\t      wiki_show_edit_page(res, NULL, page);\n\t    }\n\t  else\n\t    {\n\t      char buf[1024];\n\t      snprintf(buf, 1024, \"%s?create\", page);\n\t      wiki_redirect(res, buf);\n\t    }\n\t}\n    }\n\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149572,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "wiki_handle_http_request(HttpRequest *req)\n{\n  HttpResponse *res      = http_response_new(req);\n  char         *page     = http_request_get_path_info(req); \n  char         *command  = http_request_get_query_string(req); \n  char         *wikitext = \"\";\n\n  util_dehttpize(page); \t/* remove any encoding on the requested\n\t\t\t\t   page name.                           */\n\n  if (!strcmp(page, \"/\"))\n    {\n      if (access(\"WikiHome\", R_OK) != 0)\n\twiki_redirect(res, \"/WikiHome?create\");\n      page = \"/WikiHome\";\n    }\n\n  if (!strcmp(page, \"/styles.css\"))\n    {\n      /*  Return CSS page */\n      http_response_set_content_type(res, \"text/css\");\n      http_response_printf(res, \"%s\", CssData);\n      http_response_send(res);\n      exit(0);\n    }\n\n  if (!strcmp(page, \"/favicon.ico\"))\n    {\n      /*  Return favicon */\n      http_response_set_content_type(res, \"image/ico\");\n      http_response_set_data(res, FaviconData, FaviconDataLen);\n      http_response_send(res);\n      exit(0);\n    }\n\n\n  page = page + 1; \t\t/* skip slash */\n\n  if (!strncmp(page, \"api/\", 4))\n    {\n      char *p;\n\n      page += 4; \n      for (p=page; *p != '\\0'; p++)\n\tif (*p=='?') { *p ='\\0'; break; }\n      \n      wiki_handle_rest_call(req, res, page); \n      exit(0);\n    }\n\n  /* A little safety. issue a malformed request for any paths,\n   * There shouldn't need to be any..\n   */\n  if (!page_name_is_good(page))\n    {\n      http_response_set_status(res, 404, \"Not Found\");\n      http_response_printf(res, \"<html><body>404 Not Found</body></html>\\n\");\n      http_response_send(res);\n      exit(0);\n    }\n\n  if (!strcmp(page, \"Changes\"))\n    {\n      wiki_show_changes_page(res);\n    }\n  else if (!strcmp(page, \"ChangesRss\"))\n    {\n      wiki_show_changes_page_rss(res);\n    }\n  else if (!strcmp(page, \"Search\"))\n    {\n      wiki_show_search_results_page(res, http_request_param_get(req, \"expr\"));\n    }\n  else if (!strcmp(page, \"Create\"))\n    {\n      if ( (wikitext = http_request_param_get(req, \"title\")) != NULL)\n\t{\n\t  /* create page and redirect */\n\t  wiki_redirect(res, http_request_param_get(req, \"title\"));\n\t}\n      else\n\t{\n\t   /* show create page form  */\n\t  wiki_show_create_page(res);\n\t}\n    }\n  else\n    {\n      /* TODO: dont blindly write wikitext data to disk */\n      if ( (wikitext = http_request_param_get(req, \"wikitext\")) != NULL)\n\t{\n\t  file_write(page, wikitext);\t      \n\t}\n\n      if (access(page, R_OK) == 0) \t/* page exists */\n\t{\n\t  wikitext = file_read(page);\n\t  \n\t  if (!strcmp(command, \"edit\"))\n\t    {\n\t      /* print edit page */\n\t      wiki_show_edit_page(res, wikitext, page);\n\t    }\n\t  else\n\t    {\n\t      wiki_show_page(res, wikitext, page);\n\t    }\n\t}\n      else\n\t{\n\t  if (!strcmp(command, \"create\"))\n\t    {\n\t      wiki_show_edit_page(res, NULL, page);\n\t    }\n\t  else\n\t    {\n\t      char buf[1024];\n\t      snprintf(buf, 1024, \"%s?create\", page);\n\t      wiki_redirect(res, buf);\n\t    }\n\t}\n    }\n\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149573,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "PHYSICALPATH_FUNC(mod_alias_physical_handler) {\n\tplugin_data *p = p_d;\n\tint uri_len, basedir_len;\n\tchar *uri_ptr;\n\tsize_t k;\n\n\tif (buffer_is_empty(con->physical.path)) return HANDLER_GO_ON;\n\n\tmod_alias_patch_connection(srv, con, p);\n\n\t/* not to include the tailing slash */\n\tbasedir_len = buffer_string_length(con->physical.basedir);\n\tif ('/' == con->physical.basedir->ptr[basedir_len-1]) --basedir_len;\n\turi_len = buffer_string_length(con->physical.path) - basedir_len;\n\turi_ptr = con->physical.path->ptr + basedir_len;\n\n\tfor (k = 0; k < p->conf.alias->used; k++) {\n\t\tdata_string *ds = (data_string *)p->conf.alias->data[k];\n\t\tint alias_len = buffer_string_length(ds->key);\n\n\t\tif (alias_len > uri_len) continue;\n\t\tif (buffer_is_empty(ds->key)) continue;\n\n\t\tif (0 == (con->conf.force_lowercase_filenames ?\n\t\t\t\t\tstrncasecmp(uri_ptr, ds->key->ptr, alias_len) :\n\t\t\t\t\tstrncmp(uri_ptr, ds->key->ptr, alias_len))) {\n\t\t\t/* matched */\n\n\t\t\tbuffer_copy_buffer(con->physical.basedir, ds->value);\n\t\t\tbuffer_copy_buffer(srv->tmp_buf, ds->value);\n\t\t\tbuffer_append_string(srv->tmp_buf, uri_ptr + alias_len);\n\t\t\tbuffer_copy_buffer(con->physical.path, srv->tmp_buf);\n\n\t\t\treturn HANDLER_GO_ON;\n\t\t}\n\t}\n\n\t/* not found */\n\treturn HANDLER_GO_ON;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149574,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "PHYSICALPATH_FUNC(mod_alias_physical_handler) {\n\tplugin_data *p = p_d;\n\tint uri_len, basedir_len;\n\tchar *uri_ptr;\n\tsize_t k;\n\n\tif (buffer_is_empty(con->physical.path)) return HANDLER_GO_ON;\n\n\tmod_alias_patch_connection(srv, con, p);\n\n\t/* not to include the tailing slash */\n\tbasedir_len = buffer_string_length(con->physical.basedir);\n\tif ('/' == con->physical.basedir->ptr[basedir_len-1]) --basedir_len;\n\turi_len = buffer_string_length(con->physical.path) - basedir_len;\n\turi_ptr = con->physical.path->ptr + basedir_len;\n\n\tfor (k = 0; k < p->conf.alias->used; k++) {\n\t\tdata_string *ds = (data_string *)p->conf.alias->data[k];\n\t\tint alias_len = buffer_string_length(ds->key);\n\n\t\tif (alias_len > uri_len) continue;\n\t\tif (buffer_is_empty(ds->key)) continue;\n\n\t\tif (0 == (con->conf.force_lowercase_filenames ?\n\t\t\t\t\tstrncasecmp(uri_ptr, ds->key->ptr, alias_len) :\n\t\t\t\t\tstrncmp(uri_ptr, ds->key->ptr, alias_len))) {\n\t\t\t/* matched */\n\n\t\t\t/* check for path traversal in url-path following alias if key\n\t\t\t * does not end in slash, but replacement value ends in slash */\n\t\t\tif (uri_ptr[alias_len] == '.') {\n\t\t\t\tchar *s = uri_ptr + alias_len + 1;\n\t\t\t\tif (*s == '.') ++s;\n\t\t\t\tif (*s == '/' || *s == '\\0') {\n\t\t\t\t\tsize_t vlen = buffer_string_length(ds->value);\n\t\t\t\t\tif (0 != alias_len && ds->key->ptr[alias_len-1] != '/'\n\t\t\t\t\t    && 0 != vlen && ds->value->ptr[vlen-1] == '/') {\n\t\t\t\t\t\tcon->http_status = 403;\n\t\t\t\t\t\treturn HANDLER_FINISHED;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbuffer_copy_buffer(con->physical.basedir, ds->value);\n\t\t\tbuffer_copy_buffer(srv->tmp_buf, ds->value);\n\t\t\tbuffer_append_string(srv->tmp_buf, uri_ptr + alias_len);\n\t\t\tbuffer_copy_buffer(con->physical.path, srv->tmp_buf);\n\n\t\t\treturn HANDLER_GO_ON;\n\t\t}\n\t}\n\n\t/* not found */\n\treturn HANDLER_GO_ON;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149575,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "int dd_delete_item(struct dump_dir *dd, const char *name)\n{\n    if (!dd->locked)\n        error_msg_and_die(\"dump_dir is not opened\"); /* bug */\n\n    char *path = concat_path_file(dd->dd_dirname, name);\n    int res = unlink(path);\n\n    if (res < 0)\n    {\n        if (errno == ENOENT)\n            errno = res = 0;\n        else\n            perror_msg(\"Can't delete file '%s'\", path);\n    }\n\n    free(path);\n    return res;\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149576,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "int dd_delete_item(struct dump_dir *dd, const char *name)\n{\n    if (!dd->locked)\n        error_msg_and_die(\"dump_dir is not opened\"); /* bug */\n\n    if (!str_is_correct_filename(name))\n        error_msg_and_die(\"Cannot delete item. '%s' is not a valid file name\", name);\n\n    char *path = concat_path_file(dd->dd_dirname, name);\n    int res = unlink(path);\n\n    if (res < 0)\n    {\n        if (errno == ENOENT)\n            errno = res = 0;\n        else\n            perror_msg(\"Can't delete file '%s'\", path);\n    }\n\n    free(path);\n    return res;\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149577,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "void dd_save_text(struct dump_dir *dd, const char *name, const char *data)\n{\n    if (!dd->locked)\n        error_msg_and_die(\"dump_dir is not opened\"); /* bug */\n\n    char *full_path = concat_path_file(dd->dd_dirname, name);\n    save_binary_file(full_path, data, strlen(data), dd->dd_uid, dd->dd_gid, dd->mode);\n    free(full_path);\n}",
    "target": 1,
    "language": "c",
    "dataset": "sven",
    "idx": 149580,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  },
  {
    "CWE_ID": [
      "CWE-22"
    ],
    "code": "void dd_save_text(struct dump_dir *dd, const char *name, const char *data)\n{\n    if (!dd->locked)\n        error_msg_and_die(\"dump_dir is not opened\"); /* bug */\n\n    if (!str_is_correct_filename(name))\n        error_msg_and_die(\"Cannot save text. '%s' is not a valid file name\", name);\n\n    char *full_path = concat_path_file(dd->dd_dirname, name);\n    save_binary_file(full_path, data, strlen(data), dd->dd_uid, dd->dd_gid, dd->mode);\n    free(full_path);\n}",
    "target": 0,
    "language": "c",
    "dataset": "sven",
    "idx": 149581,
    "RELATED_CWE": [
      "CWE-59",
      "CWE-426",
      "CWE-552"
    ]
  }
]