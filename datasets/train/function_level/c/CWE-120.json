[
  {
    "CWE_ID": [
      "CWE-120"
    ],
    "code": "static s32 svc_parse_slice(GF_BitStream *bs, AVCState *avc, AVCSliceInfo *si)\n{\n\ts32 pps_id;\n\n\t/*s->current_picture.reference= h->nal_ref_idc != 0;*/\n\tgf_bs_read_ue_log(bs, \"first_mb_in_slice\");\n\tsi->slice_type = gf_bs_read_ue_log(bs, \"slice_type\");\n\tif (si->slice_type > 9) return -1;\n\n\tpps_id = gf_bs_read_ue_log(bs, \"pps_id\");\n\tif ((pps_id<0) || (pps_id > 255))\n\t\treturn -1;\n\tsi->pps = &avc->pps[pps_id];\n\tsi->pps->id = pps_id;\n\tif (!si->pps->slice_group_count)\n\t\treturn -2;\n\tsi->sps = &avc->sps[si->pps->sps_id + GF_SVC_SSPS_ID_SHIFT];\n\tif (!si->sps->log2_max_frame_num)\n\t\treturn -2;\n\n\tsi->frame_num = gf_bs_read_int_log(bs, si->sps->log2_max_frame_num, \"frame_num\");\n\n\tsi->field_pic_flag = 0;\n\tif (si->sps->frame_mbs_only_flag) {\n\t\t/*s->picture_structure= PICT_FRAME;*/\n\t}\n\telse {\n\t\tsi->field_pic_flag = gf_bs_read_int_log(bs, 1, \"field_pic_flag\");\n\t\tif (si->field_pic_flag) si->bottom_field_flag = gf_bs_read_int_log(bs, 1, \"bottom_field_flag\");\n\t}\n\tif (si->nal_unit_type == GF_AVC_NALU_IDR_SLICE || si->NalHeader.idr_pic_flag)\n\t\tsi->idr_pic_id = gf_bs_read_ue_log(bs, \"idr_pic_id\");\n\n\tif (si->sps->poc_type == 0) {\n\t\tsi->poc_lsb = gf_bs_read_int_log(bs, si->sps->log2_max_poc_lsb, \"poc_lsb\");\n\t\tif (si->pps->pic_order_present && !si->field_pic_flag) {\n\t\t\tsi->delta_poc_bottom = gf_bs_read_se_log(bs, \"delta_poc_bottom\");\n\t\t}\n\t}\n\telse if ((si->sps->poc_type == 1) && !si->sps->delta_pic_order_always_zero_flag) {\n\t\tsi->delta_poc[0] = gf_bs_read_se_log(bs, \"delta_poc0\");\n\t\tif ((si->pps->pic_order_present == 1) && !si->field_pic_flag)\n\t\t\tsi->delta_poc[1] = gf_bs_read_se_log(bs, \"delta_poc1\");\n\t}\n\tif (si->pps->redundant_pic_cnt_present) {\n\t\tsi->redundant_pic_cnt = gf_bs_read_ue_log(bs, \"redundant_pic_cnt\");\n\t}\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 39,
    "RELATED_CWE": [
      "CWE-124",
      "CWE-415",
      "CWE-416"
    ]
  },
  {
    "CWE_ID": [
      "CWE-120"
    ],
    "code": "static ssize_t remove_slot_store(struct kobject *kobj,\n\t\t\t\t struct kobj_attribute *attr,\n\t\t\t\t const char *buf, size_t nbytes)\n{\n\tchar drc_name[MAX_DRC_NAME_LEN];\n\tint rc;\n\tchar *end;\n\n\tif (nbytes >= MAX_DRC_NAME_LEN)\n\t\treturn 0;\n\n\tstrscpy(drc_name, buf, nbytes + 1);\n\n\tend = strchr(drc_name, '\\n');\n\tif (end)\n\t\t*end = '\\0';\n\n\trc = dlpar_remove_slot(drc_name);\n\tif (rc)\n\t\treturn rc;\n\n\treturn nbytes;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 528,
    "RELATED_CWE": [
      "CWE-124",
      "CWE-415",
      "CWE-416"
    ]
  },
  {
    "CWE_ID": [
      "CWE-120"
    ],
    "code": "static ssize_t add_slot_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t      const char *buf, size_t nbytes)\n{\n\tchar drc_name[MAX_DRC_NAME_LEN];\n\tchar *end;\n\tint rc;\n\n\tif (nbytes >= MAX_DRC_NAME_LEN)\n\t\treturn 0;\n\n\tstrscpy(drc_name, buf, nbytes + 1);\n\n\tend = strchr(drc_name, '\\n');\n\tif (end)\n\t\t*end = '\\0';\n\n\trc = dlpar_add_slot(drc_name);\n\tif (rc)\n\t\treturn rc;\n\n\treturn nbytes;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 530,
    "RELATED_CWE": [
      "CWE-124",
      "CWE-415",
      "CWE-416"
    ]
  },
  {
    "CWE_ID": [
      "CWE-120"
    ],
    "code": "jetp3852_print_page(gx_device_printer *pdev, gp_file *prn_stream)\n{\n#define DATA_SIZE (LINE_SIZE * 8)\n\n    unsigned int cnt_2prn;\n    unsigned int count,tempcnt;\n    unsigned char vtp,cntc1,cntc2;\n    int line_size_color_plane;\n\n    byte data[DATA_SIZE];\n    byte plane_data[LINE_SIZE * 3];\n\n    /* Initialise data to zeros, otherwise later on, uninitialised bytes in\n    dp[] can be greater than 7, which breaks spr8[dp[]]. */\n    memset(data, 0x00, DATA_SIZE);\n\n    /* Set initial condition for printer */\n    gp_fputs(\"\\033@\",prn_stream);\n\n    /* Send each scan line in turn */\n    {\n        int lnum;\n        int line_size = gdev_mem_bytes_per_scan_line((gx_device *)pdev);\n        int num_blank_lines = 0;\n\n        if (line_size > DATA_SIZE) {\n            emprintf2(pdev->memory, \"invalid resolution and/or width gives line_size = %d, max. is %d\\n\",\n                      line_size, DATA_SIZE);\n            return_error(gs_error_rangecheck);\n        }\n\n        for ( lnum = 0; lnum < pdev->height; lnum++ ) {\n            byte *end_data = data + line_size;\n            gdev_prn_copy_scan_lines(pdev, lnum,\n                                     (byte *)data, line_size);\n            /* Remove trailing 0s. */\n            while ( end_data > data && end_data[-1] == 0 )\n                end_data--;\n            if ( end_data == data ) {\n                /* Blank line */\n                num_blank_lines++;\n            } else {\n                int i;\n                byte *odp;\n                byte *row;\n\n                /* Transpose the data to get pixel planes. */\n                for ( i = 0, odp = plane_data; i < DATA_SIZE;\n                      i += 8, odp++\n                    ) { /* The following is for 16-bit machines */\n#define spread3(c)\\\n { 0, c, c*0x100, c*0x101, c*0x10000L, c*0x10001L, c*0x10100L, c*0x10101L }\n                    static ulong spr40[8] = spread3(0x40);\n                    static ulong spr8[8] = spread3(8);\n                    static ulong spr2[8] = spread3(2);\n                    register byte *dp = data + i;\n                    register ulong pword =\n                                     (spr40[dp[0]] << 1) +\n                                     (spr40[dp[1]]) +\n                                     (spr40[dp[2]] >> 1) +\n                                     (spr8[dp[3]] << 1) +\n                                     (spr8[dp[4]]) +\n                                     (spr8[dp[5]] >> 1) +\n                                     (spr2[dp[6]]) +\n                                     (spr2[dp[7]] >> 1);\n                    odp[0] = (byte)(pword >> 16);\n                    odp[LINE_SIZE] = (byte)(pword >> 8);\n                    odp[LINE_SIZE*2] = (byte)(pword);\n                }\n                /* Skip blank lines if any */\n                if ( num_blank_lines > 0 ) {\n                    /* Do \"dot skips\" */\n                    while(num_blank_lines > 255) {\n                        gp_fputs(\"\\033e\\377\",prn_stream);\n                        num_blank_lines -= 255;\n                    }\n                    vtp = num_blank_lines;\n                    gp_fprintf(prn_stream,\"\\033e%c\",vtp);\n                    num_blank_lines = 0;\n                }\n\n                /* Transfer raster graphics in the order R, G, B. */\n                /* Apparently it is stored in B, G, R */\n                /* Calculate the amount of data to send by what */\n                /* Ghostscript tells us the scan line_size in (bytes) */\n\n                count = line_size / 3;\n                line_size_color_plane = count / 3;\n                cnt_2prn = line_size_color_plane * 3 + 5;\n                tempcnt = cnt_2prn;\n                cntc1 = (tempcnt & 0xFF00) >> 8;\n                cntc2 = (tempcnt & 0x00FF);\n                gp_fprintf(prn_stream, \"\\033[O%c%c\\200\\037\",cntc2,cntc1);\n                gp_fputc('\\000',prn_stream);\n                gp_fputs(\"\\124\\124\",prn_stream);\n\n                for ( row = plane_data + LINE_SIZE * 2, i = 0;\n                      i < 3; row -= LINE_SIZE, i++ ) {\n                    int jj;\n                    byte ctemp;\n                    odp = row;\n                    /* Complement bytes */\n                    for (jj=0; jj< line_size_color_plane; jj++) {\n                        ctemp = *odp;\n                        *odp++ = ~ctemp;\n                    }\n                    gp_fwrite(row, sizeof(byte),\n                              line_size_color_plane, prn_stream);\n                }\n            }\n        }\n    }\n\n    /* eject page */\n    gp_fputs(\"\\014\", prn_stream);\n\n    return 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 622,
    "RELATED_CWE": [
      "CWE-124",
      "CWE-415",
      "CWE-416"
    ]
  },
  {
    "CWE_ID": [
      "CWE-120"
    ],
    "code": "int st21nfca_connectivity_event_received(struct nfc_hci_dev *hdev, u8 host,\n\t\t\t\tu8 event, struct sk_buff *skb)\n{\n\tint r = 0;\n\tstruct device *dev = &hdev->ndev->dev;\n\tstruct nfc_evt_transaction *transaction;\n\n\tpr_debug(\"connectivity gate event: %x\\n\", event);\n\n\tswitch (event) {\n\tcase ST21NFCA_EVT_CONNECTIVITY:\n\t\tr = nfc_se_connectivity(hdev->ndev, host);\n\tbreak;\n\tcase ST21NFCA_EVT_TRANSACTION:\n\t\t/*\n\t\t * According to specification etsi 102 622\n\t\t * 11.2.2.4 EVT_TRANSACTION Table 52\n\t\t * Description\tTag\tLength\n\t\t * AID\t\t81\t5 to 16\n\t\t * PARAMETERS\t82\t0 to 255\n\t\t */\n\t\tif (skb->len < NFC_MIN_AID_LENGTH + 2 &&\n\t\t    skb->data[0] != NFC_EVT_TRANSACTION_AID_TAG)\n\t\t\treturn -EPROTO;\n\n\t\ttransaction = devm_kzalloc(dev, skb->len - 2, GFP_KERNEL);\n\t\tif (!transaction)\n\t\t\treturn -ENOMEM;\n\n\t\ttransaction->aid_len = skb->data[1];\n\n\t\t/* Checking if the length of the AID is valid */\n\t\tif (transaction->aid_len > sizeof(transaction->aid))\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(transaction->aid, &skb->data[2],\n\t\t       transaction->aid_len);\n\n\t\t/* Check next byte is PARAMETERS tag (82) */\n\t\tif (skb->data[transaction->aid_len + 2] !=\n\t\t    NFC_EVT_TRANSACTION_PARAMS_TAG)\n\t\t\treturn -EPROTO;\n\n\t\ttransaction->params_len = skb->data[transaction->aid_len + 3];\n\n\t\t/* Total size is allocated (skb->len - 2) minus fixed array members */\n\t\tif (transaction->params_len > ((skb->len - 2) - sizeof(struct nfc_evt_transaction)))\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(transaction->params, skb->data +\n\t\t       transaction->aid_len + 4, transaction->params_len);\n\n\t\tr = nfc_se_transaction(hdev->ndev, host, transaction);\n\tbreak;\n\tdefault:\n\t\tnfc_err(&hdev->ndev->dev, \"Unexpected event on connectivity gate\\n\");\n\t\treturn 1;\n\t}\n\tkfree_skb(skb);\n\treturn r;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 692,
    "RELATED_CWE": [
      "CWE-124",
      "CWE-415",
      "CWE-416"
    ]
  },
  {
    "CWE_ID": [
      "CWE-120"
    ],
    "code": "STATIC SSize_t\nS_study_chunk(pTHX_ RExC_state_t *pRExC_state, regnode **scanp,\n                        SSize_t *minlenp, SSize_t *deltap,\n\t\t\tregnode *last,\n\t\t\tscan_data_t *data,\n\t\t\tI32 stopparen,\n                        U32 recursed_depth,\n\t\t\tregnode_ssc *and_withp,\n\t\t\tU32 flags, U32 depth, bool was_mutate_ok)\n\t\t\t/* scanp: Start here (read-write). */\n\t\t\t/* deltap: Write maxlen-minlen here. */\n\t\t\t/* last: Stop before this one. */\n\t\t\t/* data: string data about the pattern */\n\t\t\t/* stopparen: treat close N as END */\n\t\t\t/* recursed: which subroutines have we recursed into */\n\t\t\t/* and_withp: Valid if flags & SCF_DO_STCLASS_OR */\n{\n    dVAR;\n    /* There must be at least this number of characters to match */\n    SSize_t min = 0;\n    I32 pars = 0, code;\n    regnode *scan = *scanp, *next;\n    SSize_t delta = 0;\n    int is_inf = (flags & SCF_DO_SUBSTR) && (data->flags & SF_IS_INF);\n    int is_inf_internal = 0;\t\t/* The studied chunk is infinite */\n    I32 is_par = OP(scan) == OPEN ? ARG(scan) : 0;\n    scan_data_t data_fake;\n    SV *re_trie_maxbuff = NULL;\n    regnode *first_non_open = scan;\n    SSize_t stopmin = SSize_t_MAX;\n    scan_frame *frame = NULL;\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_STUDY_CHUNK;\n    RExC_study_started= 1;\n\n    Zero(&data_fake, 1, scan_data_t);\n\n    if ( depth == 0 ) {\n        while (first_non_open && OP(first_non_open) == OPEN)\n            first_non_open=regnext(first_non_open);\n    }\n\n\n  fake_study_recurse:\n    DEBUG_r(\n        RExC_study_chunk_recursed_count++;\n    );\n    DEBUG_OPTIMISE_MORE_r(\n    {\n        Perl_re_indentf( aTHX_  \"study_chunk stopparen=%ld recursed_count=%lu depth=%lu recursed_depth=%lu scan=%p last=%p\",\n            depth, (long)stopparen,\n            (unsigned long)RExC_study_chunk_recursed_count,\n            (unsigned long)depth, (unsigned long)recursed_depth,\n            scan,\n            last);\n        if (recursed_depth) {\n            U32 i;\n            U32 j;\n            for ( j = 0 ; j < recursed_depth ; j++ ) {\n                for ( i = 0 ; i < (U32)RExC_total_parens ; i++ ) {\n                    if (\n                        PAREN_TEST(RExC_study_chunk_recursed +\n                                   ( j * RExC_study_chunk_recursed_bytes), i )\n                        && (\n                            !j ||\n                            !PAREN_TEST(RExC_study_chunk_recursed +\n                                   (( j - 1 ) * RExC_study_chunk_recursed_bytes), i)\n                        )\n                    ) {\n                        Perl_re_printf( aTHX_ \" %d\",(int)i);\n                        break;\n                    }\n                }\n                if ( j + 1 < recursed_depth ) {\n                    Perl_re_printf( aTHX_  \",\");\n                }\n            }\n        }\n        Perl_re_printf( aTHX_ \"\\n\");\n    }\n    );\n    while ( scan && OP(scan) != END && scan < last ){\n        UV min_subtract = 0;    /* How mmany chars to subtract from the minimum\n                                   node length to get a real minimum (because\n                                   the folded version may be shorter) */\n\tbool unfolded_multi_char = FALSE;\n        /* avoid mutating ops if we are anywhere within the recursed or\n         * enframed handling for a GOSUB: the outermost level will handle it.\n         */\n        bool mutate_ok = was_mutate_ok && !(frame && frame->in_gosub);\n\t/* Peephole optimizer: */\n        DEBUG_STUDYDATA(\"Peep\", data, depth, is_inf);\n        DEBUG_PEEP(\"Peep\", scan, depth, flags);\n\n\n        /* The reason we do this here is that we need to deal with things like\n         * /(?:f)(?:o)(?:o)/ which cant be dealt with by the normal EXACT\n         * parsing code, as each (?:..) is handled by a different invocation of\n         * reg() -- Yves\n         */\n        if (mutate_ok)\n            JOIN_EXACT(scan,&min_subtract, &unfolded_multi_char, 0);\n\n        /* Follow the next-chain of the current node and optimize\n           away all the NOTHINGs from it.\n         */\n        rck_elide_nothing(scan);\n\n\t/* The principal pseudo-switch.  Cannot be a switch, since we\n\t   look into several different things.  */\n        if ( OP(scan) == DEFINEP ) {\n            SSize_t minlen = 0;\n            SSize_t deltanext = 0;\n            SSize_t fake_last_close = 0;\n            I32 f = SCF_IN_DEFINE;\n\n            StructCopy(&zero_scan_data, &data_fake, scan_data_t);\n            scan = regnext(scan);\n            assert( OP(scan) == IFTHEN );\n            DEBUG_PEEP(\"expect IFTHEN\", scan, depth, flags);\n\n            data_fake.last_closep= &fake_last_close;\n            minlen = *minlenp;\n            next = regnext(scan);\n            scan = NEXTOPER(NEXTOPER(scan));\n            DEBUG_PEEP(\"scan\", scan, depth, flags);\n            DEBUG_PEEP(\"next\", next, depth, flags);\n\n            /* we suppose the run is continuous, last=next...\n             * NOTE we dont use the return here! */\n            /* DEFINEP study_chunk() recursion */\n            (void)study_chunk(pRExC_state, &scan, &minlen,\n                              &deltanext, next, &data_fake, stopparen,\n                              recursed_depth, NULL, f, depth+1, mutate_ok);\n\n            scan = next;\n        } else\n        if (\n            OP(scan) == BRANCH  ||\n            OP(scan) == BRANCHJ ||\n            OP(scan) == IFTHEN\n        ) {\n\t    next = regnext(scan);\n\t    code = OP(scan);\n\n            /* The op(next)==code check below is to see if we\n             * have \"BRANCH-BRANCH\", \"BRANCHJ-BRANCHJ\", \"IFTHEN-IFTHEN\"\n             * IFTHEN is special as it might not appear in pairs.\n             * Not sure whether BRANCH-BRANCHJ is possible, regardless\n             * we dont handle it cleanly. */\n\t    if (OP(next) == code || code == IFTHEN) {\n                /* NOTE - There is similar code to this block below for\n                 * handling TRIE nodes on a re-study.  If you change stuff here\n                 * check there too. */\n\t\tSSize_t max1 = 0, min1 = SSize_t_MAX, num = 0;\n\t\tregnode_ssc accum;\n\t\tregnode * const startbranch=scan;\n\n                if (flags & SCF_DO_SUBSTR) {\n                    /* Cannot merge strings after this. */\n                    scan_commit(pRExC_state, data, minlenp, is_inf);\n                }\n\n                if (flags & SCF_DO_STCLASS)\n\t\t    ssc_init_zero(pRExC_state, &accum);\n\n\t\twhile (OP(scan) == code) {\n\t\t    SSize_t deltanext, minnext, fake;\n\t\t    I32 f = 0;\n\t\t    regnode_ssc this_class;\n\n                    DEBUG_PEEP(\"Branch\", scan, depth, flags);\n\n\t\t    num++;\n                    StructCopy(&zero_scan_data, &data_fake, scan_data_t);\n\t\t    if (data) {\n\t\t\tdata_fake.whilem_c = data->whilem_c;\n\t\t\tdata_fake.last_closep = data->last_closep;\n\t\t    }\n\t\t    else\n\t\t\tdata_fake.last_closep = &fake;\n\n\t\t    data_fake.pos_delta = delta;\n\t\t    next = regnext(scan);\n\n                    scan = NEXTOPER(scan); /* everything */\n                    if (code != BRANCH)    /* everything but BRANCH */\n\t\t\tscan = NEXTOPER(scan);\n\n\t\t    if (flags & SCF_DO_STCLASS) {\n\t\t\tssc_init(pRExC_state, &this_class);\n\t\t\tdata_fake.start_class = &this_class;\n\t\t\tf = SCF_DO_STCLASS_AND;\n\t\t    }\n\t\t    if (flags & SCF_WHILEM_VISITED_POS)\n\t\t\tf |= SCF_WHILEM_VISITED_POS;\n\n\t\t    /* we suppose the run is continuous, last=next...*/\n                    /* recurse study_chunk() for each BRANCH in an alternation */\n\t\t    minnext = study_chunk(pRExC_state, &scan, minlenp,\n                                      &deltanext, next, &data_fake, stopparen,\n                                      recursed_depth, NULL, f, depth+1,\n                                      mutate_ok);\n\n\t\t    if (min1 > minnext)\n\t\t\tmin1 = minnext;\n\t\t    if (deltanext == SSize_t_MAX) {\n\t\t\tis_inf = is_inf_internal = 1;\n\t\t\tmax1 = SSize_t_MAX;\n\t\t    } else if (max1 < minnext + deltanext)\n\t\t\tmax1 = minnext + deltanext;\n\t\t    scan = next;\n\t\t    if (data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))\n\t\t\tpars++;\n\t            if (data_fake.flags & SCF_SEEN_ACCEPT) {\n\t                if ( stopmin > minnext)\n\t                    stopmin = min + min1;\n\t                flags &= ~SCF_DO_SUBSTR;\n\t                if (data)\n\t                    data->flags |= SCF_SEEN_ACCEPT;\n\t            }\n\t\t    if (data) {\n\t\t\tif (data_fake.flags & SF_HAS_EVAL)\n\t\t\t    data->flags |= SF_HAS_EVAL;\n\t\t\tdata->whilem_c = data_fake.whilem_c;\n\t\t    }\n\t\t    if (flags & SCF_DO_STCLASS)\n\t\t\tssc_or(pRExC_state, &accum, (regnode_charclass*)&this_class);\n\t\t}\n\t\tif (code == IFTHEN && num < 2) /* Empty ELSE branch */\n\t\t    min1 = 0;\n\t\tif (flags & SCF_DO_SUBSTR) {\n\t\t    data->pos_min += min1;\n\t\t    if (data->pos_delta >= SSize_t_MAX - (max1 - min1))\n\t\t        data->pos_delta = SSize_t_MAX;\n\t\t    else\n\t\t        data->pos_delta += max1 - min1;\n\t\t    if (max1 != min1 || is_inf)\n\t\t\tdata->cur_is_floating = 1;\n\t\t}\n\t\tmin += min1;\n\t\tif (delta == SSize_t_MAX\n\t\t || SSize_t_MAX - delta - (max1 - min1) < 0)\n\t\t    delta = SSize_t_MAX;\n\t\telse\n\t\t    delta += max1 - min1;\n\t\tif (flags & SCF_DO_STCLASS_OR) {\n\t\t    ssc_or(pRExC_state, data->start_class, (regnode_charclass*) &accum);\n\t\t    if (min1) {\n\t\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n\t\t\tflags &= ~SCF_DO_STCLASS;\n\t\t    }\n\t\t}\n\t\telse if (flags & SCF_DO_STCLASS_AND) {\n\t\t    if (min1) {\n\t\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) &accum);\n\t\t\tflags &= ~SCF_DO_STCLASS;\n\t\t    }\n\t\t    else {\n\t\t\t/* Switch to OR mode: cache the old value of\n\t\t\t * data->start_class */\n\t\t\tINIT_AND_WITHP;\n\t\t\tStructCopy(data->start_class, and_withp, regnode_ssc);\n\t\t\tflags &= ~SCF_DO_STCLASS_AND;\n\t\t\tStructCopy(&accum, data->start_class, regnode_ssc);\n\t\t\tflags |= SCF_DO_STCLASS_OR;\n\t\t    }\n\t\t}\n\n                if (PERL_ENABLE_TRIE_OPTIMISATION\n                    && OP(startbranch) == BRANCH\n                    && mutate_ok\n                ) {\n\t\t/* demq.\n\n                   Assuming this was/is a branch we are dealing with: 'scan'\n                   now points at the item that follows the branch sequence,\n                   whatever it is. We now start at the beginning of the\n                   sequence and look for subsequences of\n\n\t\t   BRANCH->EXACT=>x1\n\t\t   BRANCH->EXACT=>x2\n\t\t   tail\n\n                   which would be constructed from a pattern like\n                   /A|LIST|OF|WORDS/\n\n\t\t   If we can find such a subsequence we need to turn the first\n\t\t   element into a trie and then add the subsequent branch exact\n\t\t   strings to the trie.\n\n\t\t   We have two cases\n\n                     1. patterns where the whole set of branches can be\n                        converted.\n\n\t\t     2. patterns where only a subset can be converted.\n\n\t\t   In case 1 we can replace the whole set with a single regop\n\t\t   for the trie. In case 2 we need to keep the start and end\n\t\t   branches so\n\n\t\t     'BRANCH EXACT; BRANCH EXACT; BRANCH X'\n\t\t     becomes BRANCH TRIE; BRANCH X;\n\n\t\t  There is an additional case, that being where there is a\n\t\t  common prefix, which gets split out into an EXACT like node\n\t\t  preceding the TRIE node.\n\n\t\t  If x(1..n)==tail then we can do a simple trie, if not we make\n\t\t  a \"jump\" trie, such that when we match the appropriate word\n\t\t  we \"jump\" to the appropriate tail node. Essentially we turn\n\t\t  a nested if into a case structure of sorts.\n\n\t\t*/\n\n\t\t    int made=0;\n\t\t    if (!re_trie_maxbuff) {\n\t\t\tre_trie_maxbuff = get_sv(RE_TRIE_MAXBUF_NAME, 1);\n\t\t\tif (!SvIOK(re_trie_maxbuff))\n\t\t\t    sv_setiv(re_trie_maxbuff, RE_TRIE_MAXBUF_INIT);\n\t\t    }\n                    if ( SvIV(re_trie_maxbuff)>=0  ) {\n                        regnode *cur;\n                        regnode *first = (regnode *)NULL;\n                        regnode *last = (regnode *)NULL;\n                        regnode *tail = scan;\n                        U8 trietype = 0;\n                        U32 count=0;\n\n                        /* var tail is used because there may be a TAIL\n                           regop in the way. Ie, the exacts will point to the\n                           thing following the TAIL, but the last branch will\n                           point at the TAIL. So we advance tail. If we\n                           have nested (?:) we may have to move through several\n                           tails.\n                         */\n\n                        while ( OP( tail ) == TAIL ) {\n                            /* this is the TAIL generated by (?:) */\n                            tail = regnext( tail );\n                        }\n\n\n                        DEBUG_TRIE_COMPILE_r({\n                            regprop(RExC_rx, RExC_mysv, tail, NULL, pRExC_state);\n                            Perl_re_indentf( aTHX_  \"%s %\" UVuf \":%s\\n\",\n                              depth+1,\n                              \"Looking for TRIE'able sequences. Tail node is \",\n                              (UV) REGNODE_OFFSET(tail),\n                              SvPV_nolen_const( RExC_mysv )\n                            );\n                        });\n\n                        /*\n\n                            Step through the branches\n                                cur represents each branch,\n                                noper is the first thing to be matched as part\n                                      of that branch\n                                noper_next is the regnext() of that node.\n\n                            We normally handle a case like this\n                            /FOO[xyz]|BAR[pqr]/ via a \"jump trie\" but we also\n                            support building with NOJUMPTRIE, which restricts\n                            the trie logic to structures like /FOO|BAR/.\n\n                            If noper is a trieable nodetype then the branch is\n                            a possible optimization target. If we are building\n                            under NOJUMPTRIE then we require that noper_next is\n                            the same as scan (our current position in the regex\n                            program).\n\n                            Once we have two or more consecutive such branches\n                            we can create a trie of the EXACT's contents and\n                            stitch it in place into the program.\n\n                            If the sequence represents all of the branches in\n                            the alternation we replace the entire thing with a\n                            single TRIE node.\n\n                            Otherwise when it is a subsequence we need to\n                            stitch it in place and replace only the relevant\n                            branches. This means the first branch has to remain\n                            as it is used by the alternation logic, and its\n                            next pointer, and needs to be repointed at the item\n                            on the branch chain following the last branch we\n                            have optimized away.\n\n                            This could be either a BRANCH, in which case the\n                            subsequence is internal, or it could be the item\n                            following the branch sequence in which case the\n                            subsequence is at the end (which does not\n                            necessarily mean the first node is the start of the\n                            alternation).\n\n                            TRIE_TYPE(X) is a define which maps the optype to a\n                            trietype.\n\n                                optype          |  trietype\n                                ----------------+-----------\n                                NOTHING         | NOTHING\n                                EXACT           | EXACT\n                                EXACT_ONLY8     | EXACT\n                                EXACTFU         | EXACTFU\n                                EXACTFU_ONLY8   | EXACTFU\n                                EXACTFUP        | EXACTFU\n                                EXACTFAA        | EXACTFAA\n                                EXACTL          | EXACTL\n                                EXACTFLU8       | EXACTFLU8\n\n\n                        */\n#define TRIE_TYPE(X) ( ( NOTHING == (X) )                                   \\\n                       ? NOTHING                                            \\\n                       : ( EXACT == (X) || EXACT_ONLY8 == (X) )             \\\n                         ? EXACT                                            \\\n                         : (     EXACTFU == (X)                             \\\n                              || EXACTFU_ONLY8 == (X)                       \\\n                              || EXACTFUP == (X) )                          \\\n                           ? EXACTFU                                        \\\n                           : ( EXACTFAA == (X) )                            \\\n                             ? EXACTFAA                                     \\\n                             : ( EXACTL == (X) )                            \\\n                               ? EXACTL                                     \\\n                               : ( EXACTFLU8 == (X) )                       \\\n                                 ? EXACTFLU8                                \\\n                                 : 0 )\n\n                        /* dont use tail as the end marker for this traverse */\n                        for ( cur = startbranch ; cur != scan ; cur = regnext( cur ) ) {\n                            regnode * const noper = NEXTOPER( cur );\n                            U8 noper_type = OP( noper );\n                            U8 noper_trietype = TRIE_TYPE( noper_type );\n#if defined(DEBUGGING) || defined(NOJUMPTRIE)\n                            regnode * const noper_next = regnext( noper );\n                            U8 noper_next_type = (noper_next && noper_next < tail) ? OP(noper_next) : 0;\n                            U8 noper_next_trietype = (noper_next && noper_next < tail) ? TRIE_TYPE( noper_next_type ) :0;\n#endif\n\n                            DEBUG_TRIE_COMPILE_r({\n                                regprop(RExC_rx, RExC_mysv, cur, NULL, pRExC_state);\n                                Perl_re_indentf( aTHX_  \"- %d:%s (%d)\",\n                                   depth+1,\n                                   REG_NODE_NUM(cur), SvPV_nolen_const( RExC_mysv ), REG_NODE_NUM(cur) );\n\n                                regprop(RExC_rx, RExC_mysv, noper, NULL, pRExC_state);\n                                Perl_re_printf( aTHX_  \" -> %d:%s\",\n                                    REG_NODE_NUM(noper), SvPV_nolen_const(RExC_mysv));\n\n                                if ( noper_next ) {\n                                  regprop(RExC_rx, RExC_mysv, noper_next, NULL, pRExC_state);\n                                  Perl_re_printf( aTHX_ \"\\t=> %d:%s\\t\",\n                                    REG_NODE_NUM(noper_next), SvPV_nolen_const(RExC_mysv));\n                                }\n                                Perl_re_printf( aTHX_  \"(First==%d,Last==%d,Cur==%d,tt==%s,ntt==%s,nntt==%s)\\n\",\n                                   REG_NODE_NUM(first), REG_NODE_NUM(last), REG_NODE_NUM(cur),\n\t\t\t\t   PL_reg_name[trietype], PL_reg_name[noper_trietype], PL_reg_name[noper_next_trietype]\n\t\t\t\t);\n                            });\n\n                            /* Is noper a trieable nodetype that can be merged\n                             * with the current trie (if there is one)? */\n                            if ( noper_trietype\n                                  &&\n                                  (\n                                        ( noper_trietype == NOTHING )\n                                        || ( trietype == NOTHING )\n                                        || ( trietype == noper_trietype )\n                                  )\n#ifdef NOJUMPTRIE\n                                  && noper_next >= tail\n#endif\n                                  && count < U16_MAX)\n                            {\n                                /* Handle mergable triable node Either we are\n                                 * the first node in a new trieable sequence,\n                                 * in which case we do some bookkeeping,\n                                 * otherwise we update the end pointer. */\n                                if ( !first ) {\n                                    first = cur;\n\t\t\t\t    if ( noper_trietype == NOTHING ) {\n#if !defined(DEBUGGING) && !defined(NOJUMPTRIE)\n\t\t\t\t\tregnode * const noper_next = regnext( noper );\n                                        U8 noper_next_type = (noper_next && noper_next < tail) ? OP(noper_next) : 0;\n\t\t\t\t\tU8 noper_next_trietype = noper_next_type ? TRIE_TYPE( noper_next_type ) :0;\n#endif\n\n                                        if ( noper_next_trietype ) {\n\t\t\t\t\t    trietype = noper_next_trietype;\n                                        } else if (noper_next_type)  {\n                                            /* a NOTHING regop is 1 regop wide.\n                                             * We need at least two for a trie\n                                             * so we can't merge this in */\n                                            first = NULL;\n                                        }\n                                    } else {\n                                        trietype = noper_trietype;\n                                    }\n                                } else {\n                                    if ( trietype == NOTHING )\n                                        trietype = noper_trietype;\n                                    last = cur;\n                                }\n\t\t\t\tif (first)\n\t\t\t\t    count++;\n                            } /* end handle mergable triable node */\n                            else {\n                                /* handle unmergable node -\n                                 * noper may either be a triable node which can\n                                 * not be tried together with the current trie,\n                                 * or a non triable node */\n                                if ( last ) {\n                                    /* If last is set and trietype is not\n                                     * NOTHING then we have found at least two\n                                     * triable branch sequences in a row of a\n                                     * similar trietype so we can turn them\n                                     * into a trie. If/when we allow NOTHING to\n                                     * start a trie sequence this condition\n                                     * will be required, and it isn't expensive\n                                     * so we leave it in for now. */\n                                    if ( trietype && trietype != NOTHING )\n                                        make_trie( pRExC_state,\n                                                startbranch, first, cur, tail,\n                                                count, trietype, depth+1 );\n                                    last = NULL; /* note: we clear/update\n                                                    first, trietype etc below,\n                                                    so we dont do it here */\n                                }\n                                if ( noper_trietype\n#ifdef NOJUMPTRIE\n                                     && noper_next >= tail\n#endif\n                                ){\n                                    /* noper is triable, so we can start a new\n                                     * trie sequence */\n                                    count = 1;\n                                    first = cur;\n                                    trietype = noper_trietype;\n                                } else if (first) {\n                                    /* if we already saw a first but the\n                                     * current node is not triable then we have\n                                     * to reset the first information. */\n                                    count = 0;\n                                    first = NULL;\n                                    trietype = 0;\n                                }\n                            } /* end handle unmergable node */\n                        } /* loop over branches */\n                        DEBUG_TRIE_COMPILE_r({\n                            regprop(RExC_rx, RExC_mysv, cur, NULL, pRExC_state);\n                            Perl_re_indentf( aTHX_  \"- %s (%d) <SCAN FINISHED> \",\n                              depth+1, SvPV_nolen_const( RExC_mysv ), REG_NODE_NUM(cur));\n                            Perl_re_printf( aTHX_  \"(First==%d, Last==%d, Cur==%d, tt==%s)\\n\",\n                               REG_NODE_NUM(first), REG_NODE_NUM(last), REG_NODE_NUM(cur),\n                               PL_reg_name[trietype]\n                            );\n\n                        });\n                        if ( last && trietype ) {\n                            if ( trietype != NOTHING ) {\n                                /* the last branch of the sequence was part of\n                                 * a trie, so we have to construct it here\n                                 * outside of the loop */\n                                made= make_trie( pRExC_state, startbranch,\n                                                 first, scan, tail, count,\n                                                 trietype, depth+1 );\n#ifdef TRIE_STUDY_OPT\n                                if ( ((made == MADE_EXACT_TRIE &&\n                                     startbranch == first)\n                                     || ( first_non_open == first )) &&\n                                     depth==0 ) {\n                                    flags |= SCF_TRIE_RESTUDY;\n                                    if ( startbranch == first\n                                         && scan >= tail )\n                                    {\n                                        RExC_seen &=~REG_TOP_LEVEL_BRANCHES_SEEN;\n                                    }\n                                }\n#endif\n                            } else {\n                                /* at this point we know whatever we have is a\n                                 * NOTHING sequence/branch AND if 'startbranch'\n                                 * is 'first' then we can turn the whole thing\n                                 * into a NOTHING\n                                 */\n                                if ( startbranch == first ) {\n                                    regnode *opt;\n                                    /* the entire thing is a NOTHING sequence,\n                                     * something like this: (?:|) So we can\n                                     * turn it into a plain NOTHING op. */\n                                    DEBUG_TRIE_COMPILE_r({\n                                        regprop(RExC_rx, RExC_mysv, cur, NULL, pRExC_state);\n                                        Perl_re_indentf( aTHX_  \"- %s (%d) <NOTHING BRANCH SEQUENCE>\\n\",\n                                          depth+1,\n                                          SvPV_nolen_const( RExC_mysv ), REG_NODE_NUM(cur));\n\n                                    });\n                                    OP(startbranch)= NOTHING;\n                                    NEXT_OFF(startbranch)= tail - startbranch;\n                                    for ( opt= startbranch + 1; opt < tail ; opt++ )\n                                        OP(opt)= OPTIMIZED;\n                                }\n                            }\n                        } /* end if ( last) */\n                    } /* TRIE_MAXBUF is non zero */\n\n                } /* do trie */\n\n\t    }\n\t    else if ( code == BRANCHJ ) {  /* single branch is optimized. */\n\t\tscan = NEXTOPER(NEXTOPER(scan));\n\t    } else\t\t\t/* single branch is optimized. */\n\t\tscan = NEXTOPER(scan);\n\t    continue;\n        } else if (OP(scan) == SUSPEND || OP(scan) == GOSUB) {\n            I32 paren = 0;\n            regnode *start = NULL;\n            regnode *end = NULL;\n            U32 my_recursed_depth= recursed_depth;\n\n            if (OP(scan) != SUSPEND) { /* GOSUB */\n                /* Do setup, note this code has side effects beyond\n                 * the rest of this block. Specifically setting\n                 * RExC_recurse[] must happen at least once during\n                 * study_chunk(). */\n                paren = ARG(scan);\n                RExC_recurse[ARG2L(scan)] = scan;\n                start = REGNODE_p(RExC_open_parens[paren]);\n                end   = REGNODE_p(RExC_close_parens[paren]);\n\n                /* NOTE we MUST always execute the above code, even\n                 * if we do nothing with a GOSUB */\n                if (\n                    ( flags & SCF_IN_DEFINE )\n                    ||\n                    (\n                        (is_inf_internal || is_inf || (data && data->flags & SF_IS_INF))\n                        &&\n                        ( (flags & (SCF_DO_STCLASS | SCF_DO_SUBSTR)) == 0 )\n                    )\n                ) {\n                    /* no need to do anything here if we are in a define. */\n                    /* or we are after some kind of infinite construct\n                     * so we can skip recursing into this item.\n                     * Since it is infinite we will not change the maxlen\n                     * or delta, and if we miss something that might raise\n                     * the minlen it will merely pessimise a little.\n                     *\n                     * Iow /(?(DEFINE)(?<foo>foo|food))a+(?&foo)/\n                     * might result in a minlen of 1 and not of 4,\n                     * but this doesn't make us mismatch, just try a bit\n                     * harder than we should.\n                     * */\n                    scan= regnext(scan);\n                    continue;\n                }\n\n                if (\n                    !recursed_depth\n                    ||\n                    !PAREN_TEST(RExC_study_chunk_recursed + ((recursed_depth-1) * RExC_study_chunk_recursed_bytes), paren)\n                ) {\n                    /* it is quite possible that there are more efficient ways\n                     * to do this. We maintain a bitmap per level of recursion\n                     * of which patterns we have entered so we can detect if a\n                     * pattern creates a possible infinite loop. When we\n                     * recurse down a level we copy the previous levels bitmap\n                     * down. When we are at recursion level 0 we zero the top\n                     * level bitmap. It would be nice to implement a different\n                     * more efficient way of doing this. In particular the top\n                     * level bitmap may be unnecessary.\n                     */\n                    if (!recursed_depth) {\n                        Zero(RExC_study_chunk_recursed, RExC_study_chunk_recursed_bytes, U8);\n                    } else {\n                        Copy(RExC_study_chunk_recursed + ((recursed_depth-1) * RExC_study_chunk_recursed_bytes),\n                             RExC_study_chunk_recursed + (recursed_depth * RExC_study_chunk_recursed_bytes),\n                             RExC_study_chunk_recursed_bytes, U8);\n                    }\n                    /* we havent recursed into this paren yet, so recurse into it */\n                    DEBUG_STUDYDATA(\"gosub-set\", data, depth, is_inf);\n                    PAREN_SET(RExC_study_chunk_recursed + (recursed_depth * RExC_study_chunk_recursed_bytes), paren);\n                    my_recursed_depth= recursed_depth + 1;\n                } else {\n                    DEBUG_STUDYDATA(\"gosub-inf\", data, depth, is_inf);\n                    /* some form of infinite recursion, assume infinite length\n                     * */\n                    if (flags & SCF_DO_SUBSTR) {\n                        scan_commit(pRExC_state, data, minlenp, is_inf);\n                        data->cur_is_floating = 1;\n                    }\n                    is_inf = is_inf_internal = 1;\n                    if (flags & SCF_DO_STCLASS_OR) /* Allow everything */\n                        ssc_anything(data->start_class);\n                    flags &= ~SCF_DO_STCLASS;\n\n                    start= NULL; /* reset start so we dont recurse later on. */\n\t        }\n            } else {\n\t        paren = stopparen;\n                start = scan + 2;\n\t        end = regnext(scan);\n\t    }\n            if (start) {\n                scan_frame *newframe;\n                assert(end);\n                if (!RExC_frame_last) {\n                    Newxz(newframe, 1, scan_frame);\n                    SAVEDESTRUCTOR_X(S_unwind_scan_frames, newframe);\n                    RExC_frame_head= newframe;\n                    RExC_frame_count++;\n                } else if (!RExC_frame_last->next_frame) {\n                    Newxz(newframe, 1, scan_frame);\n                    RExC_frame_last->next_frame= newframe;\n                    newframe->prev_frame= RExC_frame_last;\n                    RExC_frame_count++;\n                } else {\n                    newframe= RExC_frame_last->next_frame;\n                }\n                RExC_frame_last= newframe;\n\n                newframe->next_regnode = regnext(scan);\n                newframe->last_regnode = last;\n                newframe->stopparen = stopparen;\n                newframe->prev_recursed_depth = recursed_depth;\n                newframe->this_prev_frame= frame;\n                newframe->in_gosub = (\n                    (frame && frame->in_gosub) || OP(scan) == GOSUB\n                );\n\n                DEBUG_STUDYDATA(\"frame-new\", data, depth, is_inf);\n                DEBUG_PEEP(\"fnew\", scan, depth, flags);\n\n\t        frame = newframe;\n\t        scan =  start;\n\t        stopparen = paren;\n\t        last = end;\n                depth = depth + 1;\n                recursed_depth= my_recursed_depth;\n\n\t        continue;\n\t    }\n\t}\n\telse if (   OP(scan) == EXACT\n                 || OP(scan) == EXACT_ONLY8\n                 || OP(scan) == EXACTL)\n        {\n\t    SSize_t l = STR_LEN(scan);\n\t    UV uc;\n            assert(l);\n\t    if (UTF) {\n\t\tconst U8 * const s = (U8*)STRING(scan);\n\t\tuc = utf8_to_uvchr_buf(s, s + l, NULL);\n\t\tl = utf8_length(s, s + l);\n\t    } else {\n\t\tuc = *((U8*)STRING(scan));\n\t    }\n\t    min += l;\n\t    if (flags & SCF_DO_SUBSTR) { /* Update longest substr. */\n\t\t/* The code below prefers earlier match for fixed\n\t\t   offset, later match for variable offset.  */\n\t\tif (data->last_end == -1) { /* Update the start info. */\n\t\t    data->last_start_min = data->pos_min;\n \t\t    data->last_start_max = is_inf\n \t\t\t? SSize_t_MAX : data->pos_min + data->pos_delta;\n\t\t}\n\t\tsv_catpvn(data->last_found, STRING(scan), STR_LEN(scan));\n\t\tif (UTF)\n\t\t    SvUTF8_on(data->last_found);\n\t\t{\n\t\t    SV * const sv = data->last_found;\n\t\t    MAGIC * const mg = SvUTF8(sv) && SvMAGICAL(sv) ?\n\t\t\tmg_find(sv, PERL_MAGIC_utf8) : NULL;\n\t\t    if (mg && mg->mg_len >= 0)\n\t\t\tmg->mg_len += utf8_length((U8*)STRING(scan),\n                                              (U8*)STRING(scan)+STR_LEN(scan));\n\t\t}\n\t\tdata->last_end = data->pos_min + l;\n\t\tdata->pos_min += l; /* As in the first entry. */\n\t\tdata->flags &= ~SF_BEFORE_EOL;\n\t    }\n\n            /* ANDing the code point leaves at most it, and not in locale, and\n             * can't match null string */\n\t    if (flags & SCF_DO_STCLASS_AND) {\n                ssc_cp_and(data->start_class, uc);\n                ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;\n                ssc_clear_locale(data->start_class);\n\t    }\n\t    else if (flags & SCF_DO_STCLASS_OR) {\n                ssc_add_cp(data->start_class, uc);\n\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n\n                /* See commit msg 749e076fceedeb708a624933726e7989f2302f6a */\n                ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;\n\t    }\n\t    flags &= ~SCF_DO_STCLASS;\n\t}\n        else if (PL_regkind[OP(scan)] == EXACT) {\n            /* But OP != EXACT!, so is EXACTFish */\n\t    SSize_t l = STR_LEN(scan);\n            const U8 * s = (U8*)STRING(scan);\n\n\t    /* Search for fixed substrings supports EXACT only. */\n\t    if (flags & SCF_DO_SUBSTR) {\n\t\tassert(data);\n                scan_commit(pRExC_state, data, minlenp, is_inf);\n\t    }\n\t    if (UTF) {\n\t\tl = utf8_length(s, s + l);\n\t    }\n\t    if (unfolded_multi_char) {\n                RExC_seen |= REG_UNFOLDED_MULTI_SEEN;\n\t    }\n\t    min += l - min_subtract;\n            assert (min >= 0);\n            delta += min_subtract;\n\t    if (flags & SCF_DO_SUBSTR) {\n\t\tdata->pos_min += l - min_subtract;\n\t\tif (data->pos_min < 0) {\n                    data->pos_min = 0;\n                }\n                data->pos_delta += min_subtract;\n\t\tif (min_subtract) {\n\t\t    data->cur_is_floating = 1; /* float */\n\t\t}\n\t    }\n\n            if (flags & SCF_DO_STCLASS) {\n                SV* EXACTF_invlist = _make_exactf_invlist(pRExC_state, scan);\n\n                assert(EXACTF_invlist);\n                if (flags & SCF_DO_STCLASS_AND) {\n                    if (OP(scan) != EXACTFL)\n                        ssc_clear_locale(data->start_class);\n                    ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;\n                    ANYOF_POSIXL_ZERO(data->start_class);\n                    ssc_intersection(data->start_class, EXACTF_invlist, FALSE);\n                }\n                else {  /* SCF_DO_STCLASS_OR */\n                    ssc_union(data->start_class, EXACTF_invlist, FALSE);\n                    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n\n                    /* See commit msg 749e076fceedeb708a624933726e7989f2302f6a */\n                    ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;\n                }\n                flags &= ~SCF_DO_STCLASS;\n                SvREFCNT_dec(EXACTF_invlist);\n            }\n\t}\n\telse if (REGNODE_VARIES(OP(scan))) {\n\t    SSize_t mincount, maxcount, minnext, deltanext, pos_before = 0;\n\t    I32 fl = 0, f = flags;\n\t    regnode * const oscan = scan;\n\t    regnode_ssc this_class;\n\t    regnode_ssc *oclass = NULL;\n\t    I32 next_is_eval = 0;\n\n\t    switch (PL_regkind[OP(scan)]) {\n\t    case WHILEM:\t\t/* End of (?:...)* . */\n\t\tscan = NEXTOPER(scan);\n\t\tgoto finish;\n\t    case PLUS:\n\t\tif (flags & (SCF_DO_SUBSTR | SCF_DO_STCLASS)) {\n\t\t    next = NEXTOPER(scan);\n\t\t    if (   OP(next) == EXACT\n                        || OP(next) == EXACT_ONLY8\n                        || OP(next) == EXACTL\n                        || (flags & SCF_DO_STCLASS))\n                    {\n\t\t\tmincount = 1;\n\t\t\tmaxcount = REG_INFTY;\n\t\t\tnext = regnext(scan);\n\t\t\tscan = NEXTOPER(scan);\n\t\t\tgoto do_curly;\n\t\t    }\n\t\t}\n\t\tif (flags & SCF_DO_SUBSTR)\n\t\t    data->pos_min++;\n\t\tmin++;\n\t\t/* FALLTHROUGH */\n\t    case STAR:\n                next = NEXTOPER(scan);\n\n                /* This temporary node can now be turned into EXACTFU, and\n                 * must, as regexec.c doesn't handle it */\n                if (OP(next) == EXACTFU_S_EDGE && mutate_ok) {\n                    OP(next) = EXACTFU;\n                }\n\n                if (     STR_LEN(next) == 1\n                    &&   isALPHA_A(* STRING(next))\n                    && (         OP(next) == EXACTFAA\n                        || (     OP(next) == EXACTFU\n                            && ! HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE(* STRING(next))))\n                    &&   mutate_ok\n                ) {\n                    /* These differ in just one bit */\n                    U8 mask = ~ ('A' ^ 'a');\n\n                    assert(isALPHA_A(* STRING(next)));\n\n                    /* Then replace it by an ANYOFM node, with\n                    * the mask set to the complement of the\n                    * bit that differs between upper and lower\n                    * case, and the lowest code point of the\n                    * pair (which the '&' forces) */\n                    OP(next) = ANYOFM;\n                    ARG_SET(next, *STRING(next) & mask);\n                    FLAGS(next) = mask;\n                }\n\n\t\tif (flags & SCF_DO_STCLASS) {\n\t\t    mincount = 0;\n\t\t    maxcount = REG_INFTY;\n\t\t    next = regnext(scan);\n\t\t    scan = NEXTOPER(scan);\n\t\t    goto do_curly;\n\t\t}\n\t\tif (flags & SCF_DO_SUBSTR) {\n                    scan_commit(pRExC_state, data, minlenp, is_inf);\n                    /* Cannot extend fixed substrings */\n\t\t    data->cur_is_floating = 1; /* float */\n\t\t}\n                is_inf = is_inf_internal = 1;\n                scan = regnext(scan);\n\t\tgoto optimize_curly_tail;\n\t    case CURLY:\n\t        if (stopparen>0 && (OP(scan)==CURLYN || OP(scan)==CURLYM)\n\t            && (scan->flags == stopparen))\n\t\t{\n\t\t    mincount = 1;\n\t\t    maxcount = 1;\n\t\t} else {\n\t\t    mincount = ARG1(scan);\n\t\t    maxcount = ARG2(scan);\n\t\t}\n\t\tnext = regnext(scan);\n\t\tif (OP(scan) == CURLYX) {\n\t\t    I32 lp = (data ? *(data->last_closep) : 0);\n\t\t    scan->flags = ((lp <= (I32)U8_MAX) ? (U8)lp : U8_MAX);\n\t\t}\n\t\tscan = NEXTOPER(scan) + EXTRA_STEP_2ARGS;\n\t\tnext_is_eval = (OP(scan) == EVAL);\n\t      do_curly:\n\t\tif (flags & SCF_DO_SUBSTR) {\n                    if (mincount == 0)\n                        scan_commit(pRExC_state, data, minlenp, is_inf);\n                    /* Cannot extend fixed substrings */\n\t\t    pos_before = data->pos_min;\n\t\t}\n\t\tif (data) {\n\t\t    fl = data->flags;\n\t\t    data->flags &= ~(SF_HAS_PAR|SF_IN_PAR|SF_HAS_EVAL);\n\t\t    if (is_inf)\n\t\t\tdata->flags |= SF_IS_INF;\n\t\t}\n\t\tif (flags & SCF_DO_STCLASS) {\n\t\t    ssc_init(pRExC_state, &this_class);\n\t\t    oclass = data->start_class;\n\t\t    data->start_class = &this_class;\n\t\t    f |= SCF_DO_STCLASS_AND;\n\t\t    f &= ~SCF_DO_STCLASS_OR;\n\t\t}\n\t        /* Exclude from super-linear cache processing any {n,m}\n\t\t   regops for which the combination of input pos and regex\n\t\t   pos is not enough information to determine if a match\n\t\t   will be possible.\n\n\t\t   For example, in the regex /foo(bar\\s*){4,8}baz/ with the\n\t\t   regex pos at the \\s*, the prospects for a match depend not\n\t\t   only on the input position but also on how many (bar\\s*)\n\t\t   repeats into the {4,8} we are. */\n               if ((mincount > 1) || (maxcount > 1 && maxcount != REG_INFTY))\n\t\t    f &= ~SCF_WHILEM_VISITED_POS;\n\n\t\t/* This will finish on WHILEM, setting scan, or on NULL: */\n                /* recurse study_chunk() on loop bodies */\n\t\tminnext = study_chunk(pRExC_state, &scan, minlenp, &deltanext,\n                                  last, data, stopparen, recursed_depth, NULL,\n                                  (mincount == 0\n                                   ? (f & ~SCF_DO_SUBSTR)\n                                   : f)\n                                  , depth+1, mutate_ok);\n\n\t\tif (flags & SCF_DO_STCLASS)\n\t\t    data->start_class = oclass;\n\t\tif (mincount == 0 || minnext == 0) {\n\t\t    if (flags & SCF_DO_STCLASS_OR) {\n\t\t\tssc_or(pRExC_state, data->start_class, (regnode_charclass *) &this_class);\n\t\t    }\n\t\t    else if (flags & SCF_DO_STCLASS_AND) {\n\t\t\t/* Switch to OR mode: cache the old value of\n\t\t\t * data->start_class */\n\t\t\tINIT_AND_WITHP;\n\t\t\tStructCopy(data->start_class, and_withp, regnode_ssc);\n\t\t\tflags &= ~SCF_DO_STCLASS_AND;\n\t\t\tStructCopy(&this_class, data->start_class, regnode_ssc);\n\t\t\tflags |= SCF_DO_STCLASS_OR;\n                        ANYOF_FLAGS(data->start_class)\n                                                |= SSC_MATCHES_EMPTY_STRING;\n\t\t    }\n\t\t} else {\t\t/* Non-zero len */\n\t\t    if (flags & SCF_DO_STCLASS_OR) {\n\t\t\tssc_or(pRExC_state, data->start_class, (regnode_charclass *) &this_class);\n\t\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n\t\t    }\n\t\t    else if (flags & SCF_DO_STCLASS_AND)\n\t\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) &this_class);\n\t\t    flags &= ~SCF_DO_STCLASS;\n\t\t}\n\t\tif (!scan) \t\t/* It was not CURLYX, but CURLY. */\n\t\t    scan = next;\n\t\tif (((flags & (SCF_TRIE_DOING_RESTUDY|SCF_DO_SUBSTR))==SCF_DO_SUBSTR)\n\t\t    /* ? quantifier ok, except for (?{ ... }) */\n\t\t    && (next_is_eval || !(mincount == 0 && maxcount == 1))\n\t\t    && (minnext == 0) && (deltanext == 0)\n\t\t    && data && !(data->flags & (SF_HAS_PAR|SF_IN_PAR))\n                    && maxcount <= REG_INFTY/3) /* Complement check for big\n                                                   count */\n\t\t{\n\t\t    _WARN_HELPER(RExC_precomp_end, packWARN(WARN_REGEXP),\n                        Perl_ck_warner(aTHX_ packWARN(WARN_REGEXP),\n                            \"Quantifier unexpected on zero-length expression \"\n                            \"in regex m/%\" UTF8f \"/\",\n\t\t\t     UTF8fARG(UTF, RExC_precomp_end - RExC_precomp,\n\t\t\t\t  RExC_precomp)));\n                }\n\n                if ( ( minnext > 0 && mincount >= SSize_t_MAX / minnext )\n                    || min >= SSize_t_MAX - minnext * mincount )\n                {\n                    FAIL(\"Regexp out of space\");\n                }\n\n\t\tmin += minnext * mincount;\n\t\tis_inf_internal |= deltanext == SSize_t_MAX\n                         || (maxcount == REG_INFTY && minnext + deltanext > 0);\n\t\tis_inf |= is_inf_internal;\n                if (is_inf) {\n\t\t    delta = SSize_t_MAX;\n                } else {\n\t\t    delta += (minnext + deltanext) * maxcount\n                             - minnext * mincount;\n                }\n\t\t/* Try powerful optimization CURLYX => CURLYN. */\n\t\tif (  OP(oscan) == CURLYX && data\n\t\t      && data->flags & SF_IN_PAR\n\t\t      && !(data->flags & SF_HAS_EVAL)\n\t\t      && !deltanext && minnext == 1\n                      && mutate_ok\n                ) {\n\t\t    /* Try to optimize to CURLYN.  */\n\t\t    regnode *nxt = NEXTOPER(oscan) + EXTRA_STEP_2ARGS;\n\t\t    regnode * const nxt1 = nxt;\n#ifdef DEBUGGING\n\t\t    regnode *nxt2;\n#endif\n\n\t\t    /* Skip open. */\n\t\t    nxt = regnext(nxt);\n\t\t    if (!REGNODE_SIMPLE(OP(nxt))\n\t\t\t&& !(PL_regkind[OP(nxt)] == EXACT\n\t\t\t     && STR_LEN(nxt) == 1))\n\t\t\tgoto nogo;\n#ifdef DEBUGGING\n\t\t    nxt2 = nxt;\n#endif\n\t\t    nxt = regnext(nxt);\n\t\t    if (OP(nxt) != CLOSE)\n\t\t\tgoto nogo;\n\t\t    if (RExC_open_parens) {\n\n                        /*open->CURLYM*/\n                        RExC_open_parens[ARG(nxt1)] = REGNODE_OFFSET(oscan);\n\n                        /*close->while*/\n                        RExC_close_parens[ARG(nxt1)] = REGNODE_OFFSET(nxt) + 2;\n\t\t    }\n\t\t    /* Now we know that nxt2 is the only contents: */\n\t\t    oscan->flags = (U8)ARG(nxt);\n\t\t    OP(oscan) = CURLYN;\n\t\t    OP(nxt1) = NOTHING;\t/* was OPEN. */\n\n#ifdef DEBUGGING\n\t\t    OP(nxt1 + 1) = OPTIMIZED; /* was count. */\n\t\t    NEXT_OFF(nxt1+ 1) = 0; /* just for consistency. */\n\t\t    NEXT_OFF(nxt2) = 0;\t/* just for consistency with CURLY. */\n\t\t    OP(nxt) = OPTIMIZED;\t/* was CLOSE. */\n\t\t    OP(nxt + 1) = OPTIMIZED; /* was count. */\n\t\t    NEXT_OFF(nxt+ 1) = 0; /* just for consistency. */\n#endif\n\t\t}\n\t      nogo:\n\n\t\t/* Try optimization CURLYX => CURLYM. */\n\t\tif (  OP(oscan) == CURLYX && data\n\t\t      && !(data->flags & SF_HAS_PAR)\n\t\t      && !(data->flags & SF_HAS_EVAL)\n\t\t      && !deltanext\t/* atom is fixed width */\n\t\t      && minnext != 0\t/* CURLYM can't handle zero width */\n                         /* Nor characters whose fold at run-time may be\n                          * multi-character */\n                      && ! (RExC_seen & REG_UNFOLDED_MULTI_SEEN)\n                      && mutate_ok\n\t\t) {\n\t\t    /* XXXX How to optimize if data == 0? */\n\t\t    /* Optimize to a simpler form.  */\n\t\t    regnode *nxt = NEXTOPER(oscan) + EXTRA_STEP_2ARGS; /* OPEN */\n\t\t    regnode *nxt2;\n\n\t\t    OP(oscan) = CURLYM;\n\t\t    while ( (nxt2 = regnext(nxt)) /* skip over embedded stuff*/\n\t\t\t    && (OP(nxt2) != WHILEM))\n\t\t\tnxt = nxt2;\n\t\t    OP(nxt2)  = SUCCEED; /* Whas WHILEM */\n\t\t    /* Need to optimize away parenths. */\n\t\t    if ((data->flags & SF_IN_PAR) && OP(nxt) == CLOSE) {\n\t\t\t/* Set the parenth number.  */\n\t\t\tregnode *nxt1 = NEXTOPER(oscan) + EXTRA_STEP_2ARGS; /* OPEN*/\n\n\t\t\toscan->flags = (U8)ARG(nxt);\n\t\t\tif (RExC_open_parens) {\n                             /*open->CURLYM*/\n                            RExC_open_parens[ARG(nxt1)] = REGNODE_OFFSET(oscan);\n\n                            /*close->NOTHING*/\n                            RExC_close_parens[ARG(nxt1)] = REGNODE_OFFSET(nxt2)\n                                                         + 1;\n\t\t\t}\n\t\t\tOP(nxt1) = OPTIMIZED;\t/* was OPEN. */\n\t\t\tOP(nxt) = OPTIMIZED;\t/* was CLOSE. */\n\n#ifdef DEBUGGING\n\t\t\tOP(nxt1 + 1) = OPTIMIZED; /* was count. */\n\t\t\tOP(nxt + 1) = OPTIMIZED; /* was count. */\n\t\t\tNEXT_OFF(nxt1 + 1) = 0; /* just for consistency. */\n\t\t\tNEXT_OFF(nxt + 1) = 0; /* just for consistency. */\n#endif\n#if 0\n\t\t\twhile ( nxt1 && (OP(nxt1) != WHILEM)) {\n\t\t\t    regnode *nnxt = regnext(nxt1);\n\t\t\t    if (nnxt == nxt) {\n\t\t\t\tif (reg_off_by_arg[OP(nxt1)])\n\t\t\t\t    ARG_SET(nxt1, nxt2 - nxt1);\n\t\t\t\telse if (nxt2 - nxt1 < U16_MAX)\n\t\t\t\t    NEXT_OFF(nxt1) = nxt2 - nxt1;\n\t\t\t\telse\n\t\t\t\t    OP(nxt) = NOTHING;\t/* Cannot beautify */\n\t\t\t    }\n\t\t\t    nxt1 = nnxt;\n\t\t\t}\n#endif\n\t\t\t/* Optimize again: */\n                        /* recurse study_chunk() on optimised CURLYX => CURLYM */\n\t\t\tstudy_chunk(pRExC_state, &nxt1, minlenp, &deltanext, nxt,\n                                    NULL, stopparen, recursed_depth, NULL, 0,\n                                    depth+1, mutate_ok);\n\t\t    }\n\t\t    else\n\t\t\toscan->flags = 0;\n\t\t}\n\t\telse if ((OP(oscan) == CURLYX)\n\t\t\t && (flags & SCF_WHILEM_VISITED_POS)\n\t\t\t /* See the comment on a similar expression above.\n\t\t\t    However, this time it's not a subexpression\n\t\t\t    we care about, but the expression itself. */\n\t\t\t && (maxcount == REG_INFTY)\n\t\t\t && data) {\n\t\t    /* This stays as CURLYX, we can put the count/of pair. */\n\t\t    /* Find WHILEM (as in regexec.c) */\n\t\t    regnode *nxt = oscan + NEXT_OFF(oscan);\n\n\t\t    if (OP(PREVOPER(nxt)) == NOTHING) /* LONGJMP */\n\t\t\tnxt += ARG(nxt);\n                    nxt = PREVOPER(nxt);\n                    if (nxt->flags & 0xf) {\n                        /* we've already set whilem count on this node */\n                    } else if (++data->whilem_c < 16) {\n                        assert(data->whilem_c <= RExC_whilem_seen);\n                        nxt->flags = (U8)(data->whilem_c\n                            | (RExC_whilem_seen << 4)); /* On WHILEM */\n                    }\n\t\t}\n\t\tif (data && fl & (SF_HAS_PAR|SF_IN_PAR))\n\t\t    pars++;\n\t\tif (flags & SCF_DO_SUBSTR) {\n\t\t    SV *last_str = NULL;\n                    STRLEN last_chrs = 0;\n\t\t    int counted = mincount != 0;\n\n                    if (data->last_end > 0 && mincount != 0) { /* Ends with a\n                                                                  string. */\n\t\t\tSSize_t b = pos_before >= data->last_start_min\n\t\t\t    ? pos_before : data->last_start_min;\n\t\t\tSTRLEN l;\n\t\t\tconst char * const s = SvPV_const(data->last_found, l);\n\t\t\tSSize_t old = b - data->last_start_min;\n                        assert(old >= 0);\n\n\t\t\tif (UTF)\n\t\t\t    old = utf8_hop_forward((U8*)s, old,\n                                               (U8 *) SvEND(data->last_found))\n                                - (U8*)s;\n\t\t\tl -= old;\n\t\t\t/* Get the added string: */\n\t\t\tlast_str = newSVpvn_utf8(s  + old, l, UTF);\n                        last_chrs = UTF ? utf8_length((U8*)(s + old),\n                                            (U8*)(s + old + l)) : l;\n\t\t\tif (deltanext == 0 && pos_before == b) {\n\t\t\t    /* What was added is a constant string */\n\t\t\t    if (mincount > 1) {\n\n\t\t\t\tSvGROW(last_str, (mincount * l) + 1);\n\t\t\t\trepeatcpy(SvPVX(last_str) + l,\n\t\t\t\t\t  SvPVX_const(last_str), l,\n                                          mincount - 1);\n\t\t\t\tSvCUR_set(last_str, SvCUR(last_str) * mincount);\n\t\t\t\t/* Add additional parts. */\n\t\t\t\tSvCUR_set(data->last_found,\n\t\t\t\t\t  SvCUR(data->last_found) - l);\n\t\t\t\tsv_catsv(data->last_found, last_str);\n\t\t\t\t{\n\t\t\t\t    SV * sv = data->last_found;\n\t\t\t\t    MAGIC *mg =\n\t\t\t\t\tSvUTF8(sv) && SvMAGICAL(sv) ?\n\t\t\t\t\tmg_find(sv, PERL_MAGIC_utf8) : NULL;\n\t\t\t\t    if (mg && mg->mg_len >= 0)\n\t\t\t\t\tmg->mg_len += last_chrs * (mincount-1);\n\t\t\t\t}\n                                last_chrs *= mincount;\n\t\t\t\tdata->last_end += l * (mincount - 1);\n\t\t\t    }\n\t\t\t} else {\n\t\t\t    /* start offset must point into the last copy */\n\t\t\t    data->last_start_min += minnext * (mincount - 1);\n\t\t\t    data->last_start_max =\n                              is_inf\n                               ? SSize_t_MAX\n\t\t\t       : data->last_start_max +\n                                 (maxcount - 1) * (minnext + data->pos_delta);\n\t\t\t}\n\t\t    }\n\t\t    /* It is counted once already... */\n\t\t    data->pos_min += minnext * (mincount - counted);\n#if 0\nPerl_re_printf( aTHX_  \"counted=%\" UVuf \" deltanext=%\" UVuf\n                              \" SSize_t_MAX=%\" UVuf \" minnext=%\" UVuf\n                              \" maxcount=%\" UVuf \" mincount=%\" UVuf \"\\n\",\n    (UV)counted, (UV)deltanext, (UV)SSize_t_MAX, (UV)minnext, (UV)maxcount,\n    (UV)mincount);\nif (deltanext != SSize_t_MAX)\nPerl_re_printf( aTHX_  \"LHS=%\" UVuf \" RHS=%\" UVuf \"\\n\",\n    (UV)(-counted * deltanext + (minnext + deltanext) * maxcount\n          - minnext * mincount), (UV)(SSize_t_MAX - data->pos_delta));\n#endif\n\t\t    if (deltanext == SSize_t_MAX\n                        || -counted * deltanext + (minnext + deltanext) * maxcount - minnext * mincount >= SSize_t_MAX - data->pos_delta)\n\t\t        data->pos_delta = SSize_t_MAX;\n\t\t    else\n\t\t        data->pos_delta += - counted * deltanext +\n\t\t\t(minnext + deltanext) * maxcount - minnext * mincount;\n\t\t    if (mincount != maxcount) {\n\t\t\t /* Cannot extend fixed substrings found inside\n\t\t\t    the group.  */\n                        scan_commit(pRExC_state, data, minlenp, is_inf);\n\t\t\tif (mincount && last_str) {\n\t\t\t    SV * const sv = data->last_found;\n\t\t\t    MAGIC * const mg = SvUTF8(sv) && SvMAGICAL(sv) ?\n\t\t\t\tmg_find(sv, PERL_MAGIC_utf8) : NULL;\n\n\t\t\t    if (mg)\n\t\t\t\tmg->mg_len = -1;\n\t\t\t    sv_setsv(sv, last_str);\n\t\t\t    data->last_end = data->pos_min;\n\t\t\t    data->last_start_min = data->pos_min - last_chrs;\n\t\t\t    data->last_start_max = is_inf\n\t\t\t\t? SSize_t_MAX\n\t\t\t\t: data->pos_min + data->pos_delta - last_chrs;\n\t\t\t}\n\t\t\tdata->cur_is_floating = 1; /* float */\n\t\t    }\n\t\t    SvREFCNT_dec(last_str);\n\t\t}\n\t\tif (data && (fl & SF_HAS_EVAL))\n\t\t    data->flags |= SF_HAS_EVAL;\n\t      optimize_curly_tail:\n\t\trck_elide_nothing(oscan);\n\t\tcontinue;\n\n\t    default:\n#ifdef DEBUGGING\n                Perl_croak(aTHX_ \"panic: unexpected varying REx opcode %d\",\n                                                                    OP(scan));\n#endif\n            case REF:\n            case CLUMP:\n\t\tif (flags & SCF_DO_SUBSTR) {\n                    /* Cannot expect anything... */\n                    scan_commit(pRExC_state, data, minlenp, is_inf);\n\t\t    data->cur_is_floating = 1; /* float */\n\t\t}\n\t\tis_inf = is_inf_internal = 1;\n\t\tif (flags & SCF_DO_STCLASS_OR) {\n                    if (OP(scan) == CLUMP) {\n                        /* Actually is any start char, but very few code points\n                         * aren't start characters */\n                        ssc_match_all_cp(data->start_class);\n                    }\n                    else {\n                        ssc_anything(data->start_class);\n                    }\n                }\n\t\tflags &= ~SCF_DO_STCLASS;\n\t\tbreak;\n\t    }\n\t}\n\telse if (OP(scan) == LNBREAK) {\n\t    if (flags & SCF_DO_STCLASS) {\n    \t        if (flags & SCF_DO_STCLASS_AND) {\n                    ssc_intersection(data->start_class,\n                                    PL_XPosix_ptrs[_CC_VERTSPACE], FALSE);\n                    ssc_clear_locale(data->start_class);\n                    ANYOF_FLAGS(data->start_class)\n                                                &= ~SSC_MATCHES_EMPTY_STRING;\n                }\n                else if (flags & SCF_DO_STCLASS_OR) {\n                    ssc_union(data->start_class,\n                              PL_XPosix_ptrs[_CC_VERTSPACE],\n                              FALSE);\n\t\t    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n\n                    /* See commit msg for\n                     * 749e076fceedeb708a624933726e7989f2302f6a */\n                    ANYOF_FLAGS(data->start_class)\n                                                &= ~SSC_MATCHES_EMPTY_STRING;\n                }\n\t\tflags &= ~SCF_DO_STCLASS;\n            }\n\t    min++;\n            if (delta != SSize_t_MAX)\n                delta++;    /* Because of the 2 char string cr-lf */\n            if (flags & SCF_DO_SUBSTR) {\n                /* Cannot expect anything... */\n                scan_commit(pRExC_state, data, minlenp, is_inf);\n    \t        data->pos_min += 1;\n                if (data->pos_delta != SSize_t_MAX) {\n                    data->pos_delta += 1;\n                }\n\t\tdata->cur_is_floating = 1; /* float */\n    \t    }\n\t}\n\telse if (REGNODE_SIMPLE(OP(scan))) {\n\n\t    if (flags & SCF_DO_SUBSTR) {\n                scan_commit(pRExC_state, data, minlenp, is_inf);\n\t\tdata->pos_min++;\n\t    }\n\t    min++;\n\t    if (flags & SCF_DO_STCLASS) {\n                bool invert = 0;\n                SV* my_invlist = NULL;\n                U8 namedclass;\n\n                /* See commit msg 749e076fceedeb708a624933726e7989f2302f6a */\n                ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;\n\n\t\t/* Some of the logic below assumes that switching\n\t\t   locale on will only add false positives. */\n\t\tswitch (OP(scan)) {\n\n\t\tdefault:\n#ifdef DEBUGGING\n                   Perl_croak(aTHX_ \"panic: unexpected simple REx opcode %d\",\n                                                                     OP(scan));\n#endif\n\t\tcase SANY:\n\t\t    if (flags & SCF_DO_STCLASS_OR) /* Allow everything */\n\t\t\tssc_match_all_cp(data->start_class);\n\t\t    break;\n\n\t\tcase REG_ANY:\n                    {\n                        SV* REG_ANY_invlist = _new_invlist(2);\n                        REG_ANY_invlist = add_cp_to_invlist(REG_ANY_invlist,\n                                                            '\\n');\n                        if (flags & SCF_DO_STCLASS_OR) {\n                            ssc_union(data->start_class,\n                                      REG_ANY_invlist,\n                                      TRUE /* TRUE => invert, hence all but \\n\n                                            */\n                                      );\n                        }\n                        else if (flags & SCF_DO_STCLASS_AND) {\n                            ssc_intersection(data->start_class,\n                                             REG_ANY_invlist,\n                                             TRUE  /* TRUE => invert */\n                                             );\n                            ssc_clear_locale(data->start_class);\n                        }\n                        SvREFCNT_dec_NN(REG_ANY_invlist);\n\t\t    }\n\t\t    break;\n\n                case ANYOFD:\n                case ANYOFL:\n                case ANYOFPOSIXL:\n                case ANYOFH:\n                case ANYOF:\n\t\t    if (flags & SCF_DO_STCLASS_AND)\n\t\t\tssc_and(pRExC_state, data->start_class,\n                                (regnode_charclass *) scan);\n\t\t    else\n\t\t\tssc_or(pRExC_state, data->start_class,\n                                                          (regnode_charclass *) scan);\n\t\t    break;\n\n                case NANYOFM:\n                case ANYOFM:\n                  {\n                    SV* cp_list = get_ANYOFM_contents(scan);\n\n                    if (flags & SCF_DO_STCLASS_OR) {\n                        ssc_union(data->start_class, cp_list, invert);\n                    }\n                    else if (flags & SCF_DO_STCLASS_AND) {\n                        ssc_intersection(data->start_class, cp_list, invert);\n                    }\n\n                    SvREFCNT_dec_NN(cp_list);\n                    break;\n                  }\n\n\t\tcase NPOSIXL:\n                    invert = 1;\n                    /* FALLTHROUGH */\n\n\t\tcase POSIXL:\n                    namedclass = classnum_to_namedclass(FLAGS(scan)) + invert;\n                    if (flags & SCF_DO_STCLASS_AND) {\n                        bool was_there = cBOOL(\n                                          ANYOF_POSIXL_TEST(data->start_class,\n                                                                 namedclass));\n                        ANYOF_POSIXL_ZERO(data->start_class);\n                        if (was_there) {    /* Do an AND */\n                            ANYOF_POSIXL_SET(data->start_class, namedclass);\n                        }\n                        /* No individual code points can now match */\n                        data->start_class->invlist\n                                                = sv_2mortal(_new_invlist(0));\n                    }\n                    else {\n                        int complement = namedclass + ((invert) ? -1 : 1);\n\n                        assert(flags & SCF_DO_STCLASS_OR);\n\n                        /* If the complement of this class was already there,\n                         * the result is that they match all code points,\n                         * (\\d + \\D == everything).  Remove the classes from\n                         * future consideration.  Locale is not relevant in\n                         * this case */\n                        if (ANYOF_POSIXL_TEST(data->start_class, complement)) {\n                            ssc_match_all_cp(data->start_class);\n                            ANYOF_POSIXL_CLEAR(data->start_class, namedclass);\n                            ANYOF_POSIXL_CLEAR(data->start_class, complement);\n                        }\n                        else {  /* The usual case; just add this class to the\n                                   existing set */\n                            ANYOF_POSIXL_SET(data->start_class, namedclass);\n                        }\n                    }\n                    break;\n\n                case NPOSIXA:   /* For these, we always know the exact set of\n                                   what's matched */\n                    invert = 1;\n                    /* FALLTHROUGH */\n\t\tcase POSIXA:\n                    my_invlist = invlist_clone(PL_Posix_ptrs[FLAGS(scan)], NULL);\n                    goto join_posix_and_ascii;\n\n\t\tcase NPOSIXD:\n\t\tcase NPOSIXU:\n                    invert = 1;\n                    /* FALLTHROUGH */\n\t\tcase POSIXD:\n\t\tcase POSIXU:\n                    my_invlist = invlist_clone(PL_XPosix_ptrs[FLAGS(scan)], NULL);\n\n                    /* NPOSIXD matches all upper Latin1 code points unless the\n                     * target string being matched is UTF-8, which is\n                     * unknowable until match time.  Since we are going to\n                     * invert, we want to get rid of all of them so that the\n                     * inversion will match all */\n                    if (OP(scan) == NPOSIXD) {\n                        _invlist_subtract(my_invlist, PL_UpperLatin1,\n                                          &my_invlist);\n                    }\n\n                  join_posix_and_ascii:\n\n                    if (flags & SCF_DO_STCLASS_AND) {\n                        ssc_intersection(data->start_class, my_invlist, invert);\n                        ssc_clear_locale(data->start_class);\n                    }\n                    else {\n                        assert(flags & SCF_DO_STCLASS_OR);\n                        ssc_union(data->start_class, my_invlist, invert);\n                    }\n                    SvREFCNT_dec(my_invlist);\n\t\t}\n\t\tif (flags & SCF_DO_STCLASS_OR)\n\t\t    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n\t\tflags &= ~SCF_DO_STCLASS;\n\t    }\n\t}\n\telse if (PL_regkind[OP(scan)] == EOL && flags & SCF_DO_SUBSTR) {\n\t    data->flags |= (OP(scan) == MEOL\n\t\t\t    ? SF_BEFORE_MEOL\n\t\t\t    : SF_BEFORE_SEOL);\n            scan_commit(pRExC_state, data, minlenp, is_inf);\n\n\t}\n\telse if (  PL_regkind[OP(scan)] == BRANCHJ\n\t\t /* Lookbehind, or need to calculate parens/evals/stclass: */\n\t\t   && (scan->flags || data || (flags & SCF_DO_STCLASS))\n\t\t   && (OP(scan) == IFMATCH || OP(scan) == UNLESSM))\n        {\n            if ( !PERL_ENABLE_POSITIVE_ASSERTION_STUDY\n                || OP(scan) == UNLESSM )\n            {\n                /* Negative Lookahead/lookbehind\n                   In this case we can't do fixed string optimisation.\n                */\n\n                SSize_t deltanext, minnext, fake = 0;\n                regnode *nscan;\n                regnode_ssc intrnl;\n                int f = 0;\n\n                StructCopy(&zero_scan_data, &data_fake, scan_data_t);\n                if (data) {\n                    data_fake.whilem_c = data->whilem_c;\n                    data_fake.last_closep = data->last_closep;\n\t\t}\n                else\n                    data_fake.last_closep = &fake;\n\t\tdata_fake.pos_delta = delta;\n                if ( flags & SCF_DO_STCLASS && !scan->flags\n                     && OP(scan) == IFMATCH ) { /* Lookahead */\n                    ssc_init(pRExC_state, &intrnl);\n                    data_fake.start_class = &intrnl;\n                    f |= SCF_DO_STCLASS_AND;\n\t\t}\n                if (flags & SCF_WHILEM_VISITED_POS)\n                    f |= SCF_WHILEM_VISITED_POS;\n                next = regnext(scan);\n                nscan = NEXTOPER(NEXTOPER(scan));\n\n                /* recurse study_chunk() for lookahead body */\n                minnext = study_chunk(pRExC_state, &nscan, minlenp, &deltanext,\n                                      last, &data_fake, stopparen,\n                                      recursed_depth, NULL, f, depth+1,\n                                      mutate_ok);\n                if (scan->flags) {\n                    if (   deltanext < 0\n                        || deltanext > (I32) U8_MAX\n                        || minnext > (I32)U8_MAX\n                        || minnext + deltanext > (I32)U8_MAX)\n                    {\n\t\t\tFAIL2(\"Lookbehind longer than %\" UVuf \" not implemented\",\n                              (UV)U8_MAX);\n                    }\n\n                    /* The 'next_off' field has been repurposed to count the\n                     * additional starting positions to try beyond the initial\n                     * one.  (This leaves it at 0 for non-variable length\n                     * matches to avoid breakage for those not using this\n                     * extension) */\n                    if (deltanext) {\n                        scan->next_off = deltanext;\n                        ckWARNexperimental(RExC_parse,\n                            WARN_EXPERIMENTAL__VLB,\n                            \"Variable length lookbehind is experimental\");\n                    }\n                    scan->flags = (U8)minnext + deltanext;\n                }\n                if (data) {\n                    if (data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))\n                        pars++;\n                    if (data_fake.flags & SF_HAS_EVAL)\n                        data->flags |= SF_HAS_EVAL;\n                    data->whilem_c = data_fake.whilem_c;\n                }\n                if (f & SCF_DO_STCLASS_AND) {\n\t\t    if (flags & SCF_DO_STCLASS_OR) {\n\t\t\t/* OR before, AND after: ideally we would recurse with\n\t\t\t * data_fake to get the AND applied by study of the\n\t\t\t * remainder of the pattern, and then derecurse;\n\t\t\t * *** HACK *** for now just treat as \"no information\".\n\t\t\t * See [perl #56690].\n\t\t\t */\n\t\t\tssc_init(pRExC_state, data->start_class);\n\t\t    }  else {\n                        /* AND before and after: combine and continue.  These\n                         * assertions are zero-length, so can match an EMPTY\n                         * string */\n\t\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) &intrnl);\n                        ANYOF_FLAGS(data->start_class)\n                                                   |= SSC_MATCHES_EMPTY_STRING;\n\t\t    }\n                }\n\t    }\n#if PERL_ENABLE_POSITIVE_ASSERTION_STUDY\n            else {\n                /* Positive Lookahead/lookbehind\n                   In this case we can do fixed string optimisation,\n                   but we must be careful about it. Note in the case of\n                   lookbehind the positions will be offset by the minimum\n                   length of the pattern, something we won't know about\n                   until after the recurse.\n                */\n                SSize_t deltanext, fake = 0;\n                regnode *nscan;\n                regnode_ssc intrnl;\n                int f = 0;\n                /* We use SAVEFREEPV so that when the full compile\n                    is finished perl will clean up the allocated\n                    minlens when it's all done. This way we don't\n                    have to worry about freeing them when we know\n                    they wont be used, which would be a pain.\n                 */\n                SSize_t *minnextp;\n                Newx( minnextp, 1, SSize_t );\n                SAVEFREEPV(minnextp);\n\n                if (data) {\n                    StructCopy(data, &data_fake, scan_data_t);\n                    if ((flags & SCF_DO_SUBSTR) && data->last_found) {\n                        f |= SCF_DO_SUBSTR;\n                        if (scan->flags)\n                            scan_commit(pRExC_state, &data_fake, minlenp, is_inf);\n                        data_fake.last_found=newSVsv(data->last_found);\n                    }\n                }\n                else\n                    data_fake.last_closep = &fake;\n                data_fake.flags = 0;\n                data_fake.substrs[0].flags = 0;\n                data_fake.substrs[1].flags = 0;\n\t\tdata_fake.pos_delta = delta;\n                if (is_inf)\n\t            data_fake.flags |= SF_IS_INF;\n                if ( flags & SCF_DO_STCLASS && !scan->flags\n                     && OP(scan) == IFMATCH ) { /* Lookahead */\n                    ssc_init(pRExC_state, &intrnl);\n                    data_fake.start_class = &intrnl;\n                    f |= SCF_DO_STCLASS_AND;\n                }\n                if (flags & SCF_WHILEM_VISITED_POS)\n                    f |= SCF_WHILEM_VISITED_POS;\n                next = regnext(scan);\n                nscan = NEXTOPER(NEXTOPER(scan));\n\n                /* positive lookahead study_chunk() recursion */\n                *minnextp = study_chunk(pRExC_state, &nscan, minnextp,\n                                        &deltanext, last, &data_fake,\n                                        stopparen, recursed_depth, NULL,\n                                        f, depth+1, mutate_ok);\n                if (scan->flags) {\n                    assert(0);  /* This code has never been tested since this\n                                   is normally not compiled */\n                    if (   deltanext < 0\n                        || deltanext > (I32) U8_MAX\n                        || *minnextp > (I32)U8_MAX\n                        || *minnextp + deltanext > (I32)U8_MAX)\n                    {\n\t\t\tFAIL2(\"Lookbehind longer than %\" UVuf \" not implemented\",\n                              (UV)U8_MAX);\n                    }\n\n                    if (deltanext) {\n                        scan->next_off = deltanext;\n                    }\n                    scan->flags = (U8)*minnextp + deltanext;\n                }\n\n                *minnextp += min;\n\n                if (f & SCF_DO_STCLASS_AND) {\n                    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) &intrnl);\n                    ANYOF_FLAGS(data->start_class) |= SSC_MATCHES_EMPTY_STRING;\n                }\n                if (data) {\n                    if (data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))\n                        pars++;\n                    if (data_fake.flags & SF_HAS_EVAL)\n                        data->flags |= SF_HAS_EVAL;\n                    data->whilem_c = data_fake.whilem_c;\n                    if ((flags & SCF_DO_SUBSTR) && data_fake.last_found) {\n                        int i;\n                        if (RExC_rx->minlen<*minnextp)\n                            RExC_rx->minlen=*minnextp;\n                        scan_commit(pRExC_state, &data_fake, minnextp, is_inf);\n                        SvREFCNT_dec_NN(data_fake.last_found);\n\n                        for (i = 0; i < 2; i++) {\n                            if (data_fake.substrs[i].minlenp != minlenp) {\n                                data->substrs[i].min_offset =\n                                            data_fake.substrs[i].min_offset;\n                                data->substrs[i].max_offset =\n                                            data_fake.substrs[i].max_offset;\n                                data->substrs[i].minlenp =\n                                            data_fake.substrs[i].minlenp;\n                                data->substrs[i].lookbehind += scan->flags;\n                            }\n                        }\n                    }\n                }\n\t    }\n#endif\n\t}\n\n\telse if (OP(scan) == OPEN) {\n\t    if (stopparen != (I32)ARG(scan))\n\t        pars++;\n\t}\n\telse if (OP(scan) == CLOSE) {\n\t    if (stopparen == (I32)ARG(scan)) {\n\t        break;\n\t    }\n\t    if ((I32)ARG(scan) == is_par) {\n\t\tnext = regnext(scan);\n\n\t\tif ( next && (OP(next) != WHILEM) && next < last)\n\t\t    is_par = 0;\t\t/* Disable optimization */\n\t    }\n\t    if (data)\n\t\t*(data->last_closep) = ARG(scan);\n\t}\n\telse if (OP(scan) == EVAL) {\n\t\tif (data)\n\t\t    data->flags |= SF_HAS_EVAL;\n\t}\n\telse if ( PL_regkind[OP(scan)] == ENDLIKE ) {\n\t    if (flags & SCF_DO_SUBSTR) {\n                scan_commit(pRExC_state, data, minlenp, is_inf);\n\t\tflags &= ~SCF_DO_SUBSTR;\n\t    }\n\t    if (data && OP(scan)==ACCEPT) {\n\t        data->flags |= SCF_SEEN_ACCEPT;\n\t        if (stopmin > min)\n\t            stopmin = min;\n\t    }\n\t}\n\telse if (OP(scan) == LOGICAL && scan->flags == 2) /* Embedded follows */\n\t{\n\t\tif (flags & SCF_DO_SUBSTR) {\n                    scan_commit(pRExC_state, data, minlenp, is_inf);\n\t\t    data->cur_is_floating = 1; /* float */\n\t\t}\n\t\tis_inf = is_inf_internal = 1;\n\t\tif (flags & SCF_DO_STCLASS_OR) /* Allow everything */\n\t\t    ssc_anything(data->start_class);\n\t\tflags &= ~SCF_DO_STCLASS;\n\t}\n\telse if (OP(scan) == GPOS) {\n            if (!(RExC_rx->intflags & PREGf_GPOS_FLOAT) &&\n\t        !(delta || is_inf || (data && data->pos_delta)))\n\t    {\n                if (!(RExC_rx->intflags & PREGf_ANCH) && (flags & SCF_DO_SUBSTR))\n                    RExC_rx->intflags |= PREGf_ANCH_GPOS;\n\t        if (RExC_rx->gofs < (STRLEN)min)\n\t\t    RExC_rx->gofs = min;\n            } else {\n                RExC_rx->intflags |= PREGf_GPOS_FLOAT;\n                RExC_rx->gofs = 0;\n            }\n\t}\n#ifdef TRIE_STUDY_OPT\n#ifdef FULL_TRIE_STUDY\n        else if (PL_regkind[OP(scan)] == TRIE) {\n            /* NOTE - There is similar code to this block above for handling\n               BRANCH nodes on the initial study.  If you change stuff here\n               check there too. */\n            regnode *trie_node= scan;\n            regnode *tail= regnext(scan);\n            reg_trie_data *trie = (reg_trie_data*)RExC_rxi->data->data[ ARG(scan) ];\n            SSize_t max1 = 0, min1 = SSize_t_MAX;\n            regnode_ssc accum;\n\n            if (flags & SCF_DO_SUBSTR) { /* XXXX Add !SUSPEND? */\n                /* Cannot merge strings after this. */\n                scan_commit(pRExC_state, data, minlenp, is_inf);\n            }\n            if (flags & SCF_DO_STCLASS)\n                ssc_init_zero(pRExC_state, &accum);\n\n            if (!trie->jump) {\n                min1= trie->minlen;\n                max1= trie->maxlen;\n            } else {\n                const regnode *nextbranch= NULL;\n                U32 word;\n\n                for ( word=1 ; word <= trie->wordcount ; word++)\n                {\n                    SSize_t deltanext=0, minnext=0, f = 0, fake;\n                    regnode_ssc this_class;\n\n                    StructCopy(&zero_scan_data, &data_fake, scan_data_t);\n                    if (data) {\n                        data_fake.whilem_c = data->whilem_c;\n                        data_fake.last_closep = data->last_closep;\n                    }\n                    else\n                        data_fake.last_closep = &fake;\n\t\t    data_fake.pos_delta = delta;\n                    if (flags & SCF_DO_STCLASS) {\n                        ssc_init(pRExC_state, &this_class);\n                        data_fake.start_class = &this_class;\n                        f = SCF_DO_STCLASS_AND;\n                    }\n                    if (flags & SCF_WHILEM_VISITED_POS)\n                        f |= SCF_WHILEM_VISITED_POS;\n\n                    if (trie->jump[word]) {\n                        if (!nextbranch)\n                            nextbranch = trie_node + trie->jump[0];\n                        scan= trie_node + trie->jump[word];\n                        /* We go from the jump point to the branch that follows\n                           it. Note this means we need the vestigal unused\n                           branches even though they arent otherwise used. */\n                        /* optimise study_chunk() for TRIE */\n                        minnext = study_chunk(pRExC_state, &scan, minlenp,\n                            &deltanext, (regnode *)nextbranch, &data_fake,\n                            stopparen, recursed_depth, NULL, f, depth+1,\n                            mutate_ok);\n                    }\n                    if (nextbranch && PL_regkind[OP(nextbranch)]==BRANCH)\n                        nextbranch= regnext((regnode*)nextbranch);\n\n                    if (min1 > (SSize_t)(minnext + trie->minlen))\n                        min1 = minnext + trie->minlen;\n                    if (deltanext == SSize_t_MAX) {\n                        is_inf = is_inf_internal = 1;\n                        max1 = SSize_t_MAX;\n                    } else if (max1 < (SSize_t)(minnext + deltanext + trie->maxlen))\n                        max1 = minnext + deltanext + trie->maxlen;\n\n                    if (data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))\n                        pars++;\n                    if (data_fake.flags & SCF_SEEN_ACCEPT) {\n                        if ( stopmin > min + min1)\n\t                    stopmin = min + min1;\n\t                flags &= ~SCF_DO_SUBSTR;\n\t                if (data)\n\t                    data->flags |= SCF_SEEN_ACCEPT;\n\t            }\n                    if (data) {\n                        if (data_fake.flags & SF_HAS_EVAL)\n                            data->flags |= SF_HAS_EVAL;\n                        data->whilem_c = data_fake.whilem_c;\n                    }\n                    if (flags & SCF_DO_STCLASS)\n                        ssc_or(pRExC_state, &accum, (regnode_charclass *) &this_class);\n                }\n            }\n            if (flags & SCF_DO_SUBSTR) {\n                data->pos_min += min1;\n                data->pos_delta += max1 - min1;\n                if (max1 != min1 || is_inf)\n                    data->cur_is_floating = 1; /* float */\n            }\n            min += min1;\n            if (delta != SSize_t_MAX) {\n                if (SSize_t_MAX - (max1 - min1) >= delta)\n                    delta += max1 - min1;\n                else\n                    delta = SSize_t_MAX;\n            }\n            if (flags & SCF_DO_STCLASS_OR) {\n                ssc_or(pRExC_state, data->start_class, (regnode_charclass *) &accum);\n                if (min1) {\n                    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n                    flags &= ~SCF_DO_STCLASS;\n                }\n            }\n            else if (flags & SCF_DO_STCLASS_AND) {\n                if (min1) {\n                    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) &accum);\n                    flags &= ~SCF_DO_STCLASS;\n                }\n                else {\n                    /* Switch to OR mode: cache the old value of\n                     * data->start_class */\n\t\t    INIT_AND_WITHP;\n                    StructCopy(data->start_class, and_withp, regnode_ssc);\n                    flags &= ~SCF_DO_STCLASS_AND;\n                    StructCopy(&accum, data->start_class, regnode_ssc);\n                    flags |= SCF_DO_STCLASS_OR;\n                }\n            }\n            scan= tail;\n            continue;\n        }\n#else\n\telse if (PL_regkind[OP(scan)] == TRIE) {\n\t    reg_trie_data *trie = (reg_trie_data*)RExC_rxi->data->data[ ARG(scan) ];\n\t    U8*bang=NULL;\n\n\t    min += trie->minlen;\n\t    delta += (trie->maxlen - trie->minlen);\n\t    flags &= ~SCF_DO_STCLASS; /* xxx */\n            if (flags & SCF_DO_SUBSTR) {\n                /* Cannot expect anything... */\n                scan_commit(pRExC_state, data, minlenp, is_inf);\n    \t        data->pos_min += trie->minlen;\n    \t        data->pos_delta += (trie->maxlen - trie->minlen);\n\t\tif (trie->maxlen != trie->minlen)\n\t\t    data->cur_is_floating = 1; /* float */\n    \t    }\n    \t    if (trie->jump) /* no more substrings -- for now /grr*/\n               flags &= ~SCF_DO_SUBSTR;\n\t}\n#endif /* old or new */\n#endif /* TRIE_STUDY_OPT */\n\n\t/* Else: zero-length, ignore. */\n\tscan = regnext(scan);\n    }\n\n  finish:\n    if (frame) {\n        /* we need to unwind recursion. */\n        depth = depth - 1;\n\n        DEBUG_STUDYDATA(\"frame-end\", data, depth, is_inf);\n        DEBUG_PEEP(\"fend\", scan, depth, flags);\n\n        /* restore previous context */\n        last = frame->last_regnode;\n        scan = frame->next_regnode;\n        stopparen = frame->stopparen;\n        recursed_depth = frame->prev_recursed_depth;\n\n        RExC_frame_last = frame->prev_frame;\n        frame = frame->this_prev_frame;\n        goto fake_study_recurse;\n    }\n\n    assert(!frame);\n    DEBUG_STUDYDATA(\"pre-fin\", data, depth, is_inf);\n\n    *scanp = scan;\n    *deltap = is_inf_internal ? SSize_t_MAX : delta;\n\n    if (flags & SCF_DO_SUBSTR && is_inf)\n\tdata->pos_delta = SSize_t_MAX - data->pos_min;\n    if (is_par > (I32)U8_MAX)\n\tis_par = 0;\n    if (is_par && pars==1 && data) {\n\tdata->flags |= SF_IN_PAR;\n\tdata->flags &= ~SF_HAS_PAR;\n    }\n    else if (pars && data) {\n\tdata->flags |= SF_HAS_PAR;\n\tdata->flags &= ~SF_IN_PAR;\n    }\n    if (flags & SCF_DO_STCLASS_OR)\n\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n    if (flags & SCF_TRIE_RESTUDY)\n        data->flags |= \tSCF_TRIE_RESTUDY;\n\n    DEBUG_STUDYDATA(\"post-fin\", data, depth, is_inf);\n\n    {\n        SSize_t final_minlen= min < stopmin ? min : stopmin;\n\n        if (!(RExC_seen & REG_UNBOUNDED_QUANTIFIER_SEEN)) {\n            if (final_minlen > SSize_t_MAX - delta)\n                RExC_maxlen = SSize_t_MAX;\n            else if (RExC_maxlen < final_minlen + delta)\n                RExC_maxlen = final_minlen + delta;\n        }\n        return final_minlen;\n    }\n    NOT_REACHED; /* NOTREACHED */",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 792,
    "RELATED_CWE": [
      "CWE-124",
      "CWE-415",
      "CWE-416"
    ]
  },
  {
    "CWE_ID": [
      "CWE-120"
    ],
    "code": "int64_t GmfOpenMesh(const char *FilNam, int mod, ...)\n{\n   int      KwdCod, res, *PtrVer, *PtrDim, err;\n   int64_t  MshIdx;\n   char     str[ GmfStrSiz ];\n   va_list  VarArg;\n   GmfMshSct *msh;\n\n   /*---------------------*/\n   /* MESH STRUCTURE INIT */\n   /*---------------------*/\n\n   if(!(msh = calloc(1, sizeof(GmfMshSct))))\n      return(0);\n\n   MshIdx = (int64_t)msh;\n\n   // Save the current stack environment for longjmp\n   if( (err = setjmp(msh->err)) != 0)\n   {\n#ifdef GMFDEBUG\n      printf(\"libMeshb : mesh %p : error %d\\n\", msh, err);\n#endif\n      if(msh->hdl != NULL)\n         fclose(msh->hdl);\n\n      if(msh->FilDes != 0)\n#ifdef GMF_WINDOWS\n         _close(msh->FilDes);\n#else\n         close(msh->FilDes);\n#endif\n\n      free(msh);\n      return(0);\n   }\n\n   // Copy the FilNam into the structure\n   if(strlen(FilNam) + 7 >= GmfStrSiz)\n      longjmp(msh->err, -4);\n\n   strcpy(msh->FilNam, FilNam);\n\n   // Store the opening mod (read or write) and guess\n   // the filetype (binary or ascii) depending on the extension\n   msh->mod = mod;\n   msh->buf = (void *)msh->DblBuf;\n   msh->FltBuf = (void *)msh->DblBuf;\n   msh->IntBuf = (void *)msh->DblBuf;\n\n   if(strstr(msh->FilNam, \".meshb\"))\n      msh->typ |= (Bin | MshFil);\n   else if(strstr(msh->FilNam, \".mesh\"))\n      msh->typ |= (Asc | MshFil);\n   else if(strstr(msh->FilNam, \".solb\"))\n      msh->typ |= (Bin | SolFil);\n   else if(strstr(msh->FilNam, \".sol\"))\n      msh->typ |= (Asc | SolFil);\n   else\n      longjmp(msh->err, -5);\n\n   // Open the file in the required mod and initialize the mesh structure\n   if(msh->mod == GmfRead)\n   {\n\n      /*-----------------------*/\n      /* OPEN FILE FOR READING */\n      /*-----------------------*/\n\n      va_start(VarArg, mod);\n      PtrVer = va_arg(VarArg, int *);\n      PtrDim = va_arg(VarArg, int *);\n      va_end(VarArg);\n\n      // Read the endian coding tag, the mesh version\n      // and the mesh dimension (mandatory kwd)\n      if(msh->typ & Bin)\n      {\n         // Create the name string and open the file\n#ifdef WITH_GMF_AIO\n         // [Bruno] added binary flag (necessary under Windows)\n         msh->FilDes = open(msh->FilNam, OPEN_READ_FLAGS, OPEN_READ_MODE);\n\n         if(msh->FilDes <= 0)\n            longjmp(msh->err, -6);\n\n         // Read the endian coding tag\n         if(read(msh->FilDes, &msh->cod, WrdSiz) != WrdSiz)\n            longjmp(msh->err, -7);\n#else\n         // [Bruno] added binary flag (necessary under Windows)\n         if(!(msh->hdl = fopen(msh->FilNam, \"rb\")))\n            longjmp(msh->err, -8);\n\n         // Read the endian coding tag\n         safe_fread(&msh->cod, WrdSiz, 1, msh->hdl, msh->err);\n#endif\n\n         // Read the mesh version and the mesh dimension (mandatory kwd)\n         if( (msh->cod != 1) && (msh->cod != 16777216) )\n            longjmp(msh->err, -9);\n\n         ScaWrd(msh, (unsigned char *)&msh->ver);\n\n         if( (msh->ver < 1) || (msh->ver > 4) )\n            longjmp(msh->err, -10);\n\n         if( (msh->ver >= 3) && (sizeof(int64_t) != 8) )\n            longjmp(msh->err, -11);\n\n         ScaWrd(msh, (unsigned char *)&KwdCod);\n\n         if(KwdCod != GmfDimension)\n            longjmp(msh->err, -12);\n\n         GetPos(msh);\n         ScaWrd(msh, (unsigned char *)&msh->dim);\n      }\n      else\n      {\n         // Create the name string and open the file\n         if(!(msh->hdl = fopen(msh->FilNam, \"rb\")))\n            longjmp(msh->err, -13);\n\n         do\n         {\n            res = fscanf(msh->hdl, \"%100s\", str);\n         }while( (res != EOF) && strcmp(str, \"MeshVersionFormatted\") );\n\n         if(res == EOF)\n            longjmp(msh->err, -14);\n\n         safe_fscanf(msh->hdl, \"%d\", &msh->ver, msh->err);\n\n         if( (msh->ver < 1) || (msh->ver > 4) )\n            longjmp(msh->err, -15);\n\n         do\n         {\n            res = fscanf(msh->hdl, \"%100s\", str);\n         }while( (res != EOF) && strcmp(str, \"Dimension\") );\n\n         if(res == EOF)\n            longjmp(msh->err, -16);\n\n         safe_fscanf(msh->hdl, \"%d\", &msh->dim, msh->err);\n      }\n\n      if( (msh->dim != 2) && (msh->dim != 3) )\n         longjmp(msh->err, -17);\n\n      (*PtrVer) = msh->ver;\n      (*PtrDim) = msh->dim;\n\n      // Set default real numbers size\n      if(msh->ver == 1)\n         msh->FltSiz = 32;\n      else\n         msh->FltSiz = 64;\n\n      /*------------*/\n      /* KW READING */\n      /*------------*/\n\n      // Read the list of kw present in the file\n      if(!ScaKwdTab(msh))\n         return(0);\n\n      return(MshIdx);\n   }\n   else if(msh->mod == GmfWrite)\n   {\n\n      /*-----------------------*/\n      /* OPEN FILE FOR WRITING */\n      /*-----------------------*/\n\n      msh->cod = 1;\n\n      // Check if the user provided a valid version number and dimension\n      va_start(VarArg, mod);\n      msh->ver = va_arg(VarArg, int);\n      msh->dim = va_arg(VarArg, int);\n      va_end(VarArg);\n\n      if( (msh->ver < 1) || (msh->ver > 4) )\n         longjmp(msh->err, -18);\n\n      if( (msh->ver >= 3) && (sizeof(int64_t) != 8) )\n         longjmp(msh->err, -19);\n\n      if( (msh->dim != 2) && (msh->dim != 3) )\n         longjmp(msh->err, -20);\n\n      // Set default real numbers size\n      if(msh->ver == 1)\n         msh->FltSiz = 32;\n      else\n         msh->FltSiz = 64;\n\n      // Create the mesh file\n      if(msh->typ & Bin) \n      {\n         /* \n          * [Bruno] replaced previous call to creat():\n          * with a call to open(), because Windows needs the\n          * binary flag to be specified.\n          */\n#ifdef WITH_GMF_AIO\n         msh->FilDes = open(msh->FilNam, OPEN_WRITE_FLAGS, OPEN_WRITE_MODE);\n\n         if(msh->FilDes <= 0)\n            longjmp(msh->err, -21);\n#else\n         if(!(msh->hdl = fopen(msh->FilNam, \"wb\")))\n            longjmp(msh->err, -22);\n#endif\n      }\n      else if(!(msh->hdl = fopen(msh->FilNam, \"wb\")))\n         longjmp(msh->err, -23);\n\n\n      /*------------*/\n      /* KW WRITING */\n      /*------------*/\n\n      // Write the mesh version and dimension\n      if(msh->typ & Asc)\n      {\n         fprintf(msh->hdl, \"%s %d\\n\\n\",\n               GmfKwdFmt[ GmfVersionFormatted ][0], msh->ver);\n         fprintf(msh->hdl, \"%s %d\\n\",\n               GmfKwdFmt[ GmfDimension ][0], msh->dim);\n      }\n      else\n      {\n         RecWrd(msh, (unsigned char *)&msh->cod);\n         RecWrd(msh, (unsigned char *)&msh->ver);\n         GmfSetKwd(MshIdx, GmfDimension, 0);\n         RecWrd(msh, (unsigned char *)&msh->dim);\n      }\n\n      return(MshIdx);\n   }\n   else\n   {\n      free(msh);\n      return(0);\n   }\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 840,
    "RELATED_CWE": [
      "CWE-124",
      "CWE-415",
      "CWE-416"
    ]
  }
]