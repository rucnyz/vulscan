[
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "getftp (struct url *u, wgint passed_expected_bytes, wgint *qtyread,\n        wgint restval, ccon *con, int count, wgint *last_expected_bytes,\n        FILE *warc_tmp)\n{\n  int csock, dtsock, local_sock, res;\n  uerr_t err = RETROK;          /* appease the compiler */\n  FILE *fp;\n   char *respline, *tms;\n   const char *user, *passwd, *tmrate;\n   int cmd = con->cmd;\n  bool pasv_mode_open = false;\n   wgint expected_bytes = 0;\n   bool got_expected_bytes = false;\n   bool rest_failed = false;\n  bool rest_failed = false;\n  int flags;\n  wgint rd_size, previous_rd_size = 0;\n  char type_char;\n  bool try_again;\n  bool list_a_used = false;\n\n  assert (con != NULL);\n  assert (con->target != NULL);\n\n  /* Debug-check of the sanity of the request by making sure that LIST\n     and RETR are never both requested (since we can handle only one\n     at a time.  */\n  assert (!((cmd & DO_LIST) && (cmd & DO_RETR)));\n  /* Make sure that at least *something* is requested.  */\n  assert ((cmd & (DO_LIST | DO_CWD | DO_RETR | DO_LOGIN)) != 0);\n\n  *qtyread = restval;\n\n  user = u->user;\n  passwd = u->passwd;\n  search_netrc (u->host, (const char **)&user, (const char **)&passwd, 1);\n  user = user ? user : (opt.ftp_user ? opt.ftp_user : opt.user);\n  if (!user) user = \"anonymous\";\n  passwd = passwd ? passwd : (opt.ftp_passwd ? opt.ftp_passwd : opt.passwd);\n  if (!passwd) passwd = \"-wget@\";\n\n  dtsock = -1;\n  local_sock = -1;\n  con->dltime = 0;\n\n  if (!(cmd & DO_LOGIN))\n    csock = con->csock;\n  else                          /* cmd & DO_LOGIN */\n    {\n      char    *host = con->proxy ? con->proxy->host : u->host;\n      int      port = con->proxy ? con->proxy->port : u->port;\n\n      /* Login to the server: */\n\n      /* First: Establish the control connection.  */\n\n      csock = connect_to_host (host, port);\n      if (csock == E_HOST)\n          return HOSTERR;\n      else if (csock < 0)\n          return (retryable_socket_connect_error (errno)\n                  ? CONERROR : CONIMPOSSIBLE);\n\n      if (cmd & LEAVE_PENDING)\n        con->csock = csock;\n      else\n        con->csock = -1;\n\n      /* Second: Login with proper USER/PASS sequence.  */\n      logprintf (LOG_VERBOSE, _(\"Logging in as %s ... \"),\n                 quotearg_style (escape_quoting_style, user));\n      if (opt.server_response)\n        logputs (LOG_ALWAYS, \"\\n\");\n      if (con->proxy)\n        {\n          /* If proxy is in use, log in as username@target-site. */\n          char *logname = concat_strings (user, \"@\", u->host, (char *) 0);\n          err = ftp_login (csock, logname, passwd);\n          xfree (logname);\n        }\n      else\n        err = ftp_login (csock, user, passwd);\n\n      /* FTPRERR, FTPSRVERR, WRITEFAILED, FTPLOGREFUSED, FTPLOGINC */\n      switch (err)\n        {\n        case FTPRERR:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logputs (LOG_NOTQUIET, _(\"\\\nError in server response, closing control connection.\\n\"));\n          fd_close (csock);\n          con->csock = -1;\n          return err;\n        case FTPSRVERR:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logputs (LOG_NOTQUIET, _(\"Error in server greeting.\\n\"));\n          fd_close (csock);\n          con->csock = -1;\n          return err;\n        case WRITEFAILED:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logputs (LOG_NOTQUIET,\n                   _(\"Write failed, closing control connection.\\n\"));\n          fd_close (csock);\n          con->csock = -1;\n          return err;\n        case FTPLOGREFUSED:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logputs (LOG_NOTQUIET, _(\"The server refuses login.\\n\"));\n          fd_close (csock);\n          con->csock = -1;\n          return FTPLOGREFUSED;\n        case FTPLOGINC:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logputs (LOG_NOTQUIET, _(\"Login incorrect.\\n\"));\n          fd_close (csock);\n          con->csock = -1;\n          return FTPLOGINC;\n        case FTPOK:\n          if (!opt.server_response)\n            logputs (LOG_VERBOSE, _(\"Logged in!\\n\"));\n          break;\n        default:\n          abort ();\n        }\n      /* Third: Get the system type */\n      if (!opt.server_response)\n        logprintf (LOG_VERBOSE, \"==> SYST ... \");\n      err = ftp_syst (csock, &con->rs, &con->rsu);\n      /* FTPRERR */\n      switch (err)\n        {\n        case FTPRERR:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logputs (LOG_NOTQUIET, _(\"\\\nError in server response, closing control connection.\\n\"));\n          fd_close (csock);\n          con->csock = -1;\n          return err;\n        case FTPSRVERR:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logputs (LOG_NOTQUIET,\n                   _(\"Server error, can't determine system type.\\n\"));\n          break;\n        case FTPOK:\n          /* Everything is OK.  */\n          break;\n        default:\n          abort ();\n        }\n      if (!opt.server_response && err != FTPSRVERR)\n        logputs (LOG_VERBOSE, _(\"done.    \"));\n\n      /* 2013-10-17 Andrea Urbani (matfanjol)\n         According to the system type I choose which\n         list command will be used.\n         If I don't know that system, I will try, the\n         first time of each session, \"LIST -a\" and\n         \"LIST\". (see __LIST_A_EXPLANATION__ below) */\n      switch (con->rs)\n        {\n        case ST_VMS:\n          /* About ST_VMS there is an old note:\n             2008-01-29  SMS.  For a VMS FTP server, where \"LIST -a\" may not\n             fail, but will never do what is desired here,\n             skip directly to the simple \"LIST\" command\n             (assumed to be the last one in the list).  */\n          DEBUGP ((\"\\nVMS: I know it and I will use \\\"LIST\\\" as standard list command\\n\"));\n          con->st |= LIST_AFTER_LIST_A_CHECK_DONE;\n          con->st |= AVOID_LIST_A;\n          break;\n        case ST_UNIX:\n          if (con->rsu == UST_MULTINET)\n            {\n              DEBUGP ((\"\\nUNIX MultiNet: I know it and I will use \\\"LIST\\\" \"\n                       \"as standard list command\\n\"));\n              con->st |= LIST_AFTER_LIST_A_CHECK_DONE;\n              con->st |= AVOID_LIST_A;\n            }\n          else if (con->rsu == UST_TYPE_L8)\n            {\n              DEBUGP ((\"\\nUNIX TYPE L8: I know it and I will use \\\"LIST -a\\\" \"\n                       \"as standard list command\\n\"));\n              con->st |= LIST_AFTER_LIST_A_CHECK_DONE;\n              con->st |= AVOID_LIST;\n            }\n          break;\n        default:\n          break;\n        }\n\n      /* Fourth: Find the initial ftp directory */\n\n      if (!opt.server_response)\n        logprintf (LOG_VERBOSE, \"==> PWD ... \");\n      err = ftp_pwd (csock, &con->id);\n      /* FTPRERR */\n      switch (err)\n        {\n        case FTPRERR:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logputs (LOG_NOTQUIET, _(\"\\\nError in server response, closing control connection.\\n\"));\n          fd_close (csock);\n          con->csock = -1;\n          return err;\n        case FTPSRVERR :\n          /* PWD unsupported -- assume \"/\". */\n          xfree (con->id);\n          con->id = xstrdup (\"/\");\n          break;\n        case FTPOK:\n          /* Everything is OK.  */\n          break;\n        default:\n          abort ();\n        }\n\n#if 0\n      /* 2004-09-17 SMS.\n         Don't help me out.  Please.\n         A reasonably recent VMS FTP server will cope just fine with\n         UNIX file specifications.  This code just spoils things.\n         Discarding the device name, for example, is not a wise move.\n         This code was disabled but left in as an example of what not\n         to do.\n      */\n\n      /* VMS will report something like \"PUB$DEVICE:[INITIAL.FOLDER]\".\n         Convert it to \"/INITIAL/FOLDER\" */\n      if (con->rs == ST_VMS)\n        {\n          char *path = strchr (con->id, '[');\n          char *pathend = path ? strchr (path + 1, ']') : NULL;\n          if (!path || !pathend)\n            DEBUGP ((\"Initial VMS directory not in the form [...]!\\n\"));\n          else\n            {\n              char *idir = con->id;\n              DEBUGP ((\"Preprocessing the initial VMS directory\\n\"));\n              DEBUGP ((\"  old = '%s'\\n\", con->id));\n              /* We do the conversion in-place by copying the stuff\n                 between [ and ] to the beginning, and changing dots\n                 to slashes at the same time.  */\n              *idir++ = '/';\n              for (++path; path < pathend; path++, idir++)\n                *idir = *path == '.' ? '/' : *path;\n              *idir = '\\0';\n              DEBUGP ((\"  new = '%s'\\n\\n\", con->id));\n            }\n        }\n#endif /* 0 */\n\n      if (!opt.server_response)\n        logputs (LOG_VERBOSE, _(\"done.\\n\"));\n\n      /* Fifth: Set the FTP type.  */\n      type_char = ftp_process_type (u->params);\n      if (!opt.server_response)\n        logprintf (LOG_VERBOSE, \"==> TYPE %c ... \", type_char);\n      err = ftp_type (csock, type_char);\n      /* FTPRERR, WRITEFAILED, FTPUNKNOWNTYPE */\n      switch (err)\n        {\n        case FTPRERR:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logputs (LOG_NOTQUIET, _(\"\\\nError in server response, closing control connection.\\n\"));\n          fd_close (csock);\n          con->csock = -1;\n          return err;\n        case WRITEFAILED:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logputs (LOG_NOTQUIET,\n                   _(\"Write failed, closing control connection.\\n\"));\n          fd_close (csock);\n          con->csock = -1;\n          return err;\n        case FTPUNKNOWNTYPE:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logprintf (LOG_NOTQUIET,\n                     _(\"Unknown type `%c', closing control connection.\\n\"),\n                     type_char);\n          fd_close (csock);\n          con->csock = -1;\n          return err;\n        case FTPOK:\n          /* Everything is OK.  */\n          break;\n        default:\n          abort ();\n        }\n      if (!opt.server_response)\n        logputs (LOG_VERBOSE, _(\"done.  \"));\n    } /* do login */\n\n  if (cmd & DO_CWD)\n    {\n      if (!*u->dir)\n        logputs (LOG_VERBOSE, _(\"==> CWD not needed.\\n\"));\n      else\n        {\n          const char *targ = NULL;\n          int cwd_count;\n          int cwd_end;\n          int cwd_start;\n\n          char *target = u->dir;\n\n          DEBUGP ((\"changing working directory\\n\"));\n\n          /* Change working directory.  To change to a non-absolute\n             Unix directory, we need to prepend initial directory\n             (con->id) to it.  Absolute directories \"just work\".\n\n             A relative directory is one that does not begin with '/'\n             and, on non-Unix OS'es, one that doesn't begin with\n             \"[a-z]:\".\n\n             This is not done for OS400, which doesn't use\n             \"/\"-delimited directories, nor does it support directory\n             hierarchies.  \"CWD foo\" followed by \"CWD bar\" leaves us\n             in \"bar\", not in \"foo/bar\", as would be customary\n             elsewhere.  */\n\n            /* 2004-09-20 SMS.\n               Why is this wise even on UNIX?  It certainly fouls VMS.\n               See below for a more reliable, more universal method.\n            */\n\n            /* 2008-04-22 MJC.\n               I'm not crazy about it either. I'm informed it's useful\n               for misconfigured servers that have some dirs in the path\n               with +x but -r, but this method is not RFC-conformant. I\n               understand the need to deal with crappy server\n               configurations, but it's far better to use the canonical\n               method first, and fall back to kludges second.\n            */\n\n          if (target[0] != '/'\n              && !(con->rs != ST_UNIX\n                   && c_isalpha (target[0])\n                   && target[1] == ':')\n              && (con->rs != ST_OS400)\n              && (con->rs != ST_VMS))\n            {\n              int idlen = strlen (con->id);\n              char *ntarget, *p;\n\n              /* Strip trailing slash(es) from con->id. */\n              while (idlen > 0 && con->id[idlen - 1] == '/')\n                --idlen;\n              p = ntarget = (char *)alloca (idlen + 1 + strlen (u->dir) + 1);\n              memcpy (p, con->id, idlen);\n              p += idlen;\n              *p++ = '/';\n              strcpy (p, target);\n\n              DEBUGP ((\"Prepended initial PWD to relative path:\\n\"));\n              DEBUGP ((\"   pwd: '%s'\\n   old: '%s'\\n  new: '%s'\\n\",\n                       con->id, target, ntarget));\n              target = ntarget;\n            }\n\n#if 0\n          /* 2004-09-17 SMS.\n             Don't help me out.  Please.\n             A reasonably recent VMS FTP server will cope just fine with\n             UNIX file specifications.  This code just spoils things.\n             Discarding the device name, for example, is not a wise\n             move.\n             This code was disabled but left in as an example of what\n             not to do.\n          */\n\n          /* If the FTP host runs VMS, we will have to convert the absolute\n             directory path in UNIX notation to absolute directory path in\n             VMS notation as VMS FTP servers do not like UNIX notation of\n             absolute paths.  \"VMS notation\" is [dir.subdir.subsubdir]. */\n\n          if (con->rs == ST_VMS)\n            {\n              char *tmpp;\n              char *ntarget = (char *)alloca (strlen (target) + 2);\n              /* We use a converted initial dir, so directories in\n                 TARGET will be separated with slashes, something like\n                 \"/INITIAL/FOLDER/DIR/SUBDIR\".  Convert that to\n                 \"[INITIAL.FOLDER.DIR.SUBDIR]\".  */\n              strcpy (ntarget, target);\n              assert (*ntarget == '/');\n              *ntarget = '[';\n              for (tmpp = ntarget + 1; *tmpp; tmpp++)\n                if (*tmpp == '/')\n                  *tmpp = '.';\n              *tmpp++ = ']';\n              *tmpp = '\\0';\n              DEBUGP ((\"Changed file name to VMS syntax:\\n\"));\n              DEBUGP ((\"  Unix: '%s'\\n  VMS: '%s'\\n\", target, ntarget));\n              target = ntarget;\n            }\n#endif /* 0 */\n\n          /* 2004-09-20 SMS.\n             A relative directory is relative to the initial directory.\n             Thus, what _is_ useful on VMS (and probably elsewhere) is\n             to CWD to the initial directory (ideally, whatever the\n             server reports, _exactly_, NOT badly UNIX-ixed), and then\n             CWD to the (new) relative directory.  This should probably\n             be restructured as a function, called once or twice, but\n             I'm lazy enough to take the badly indented loop short-cut\n             for now.\n          */\n\n          /* Decide on one pass (absolute) or two (relative).\n             The VMS restriction may be relaxed when the squirrely code\n             above is reformed.\n          */\n          if ((con->rs == ST_VMS) && (target[0] != '/'))\n            {\n              cwd_start = 0;\n              DEBUGP ((\"Using two-step CWD for relative path.\\n\"));\n            }\n          else\n            {\n              /* Go straight to the target. */\n              cwd_start = 1;\n            }\n\n          /* At least one VMS FTP server (TCPware V5.6-2) can switch to\n             a UNIX emulation mode when given a UNIX-like directory\n             specification (like \"a/b/c\").  If allowed to continue this\n             way, LIST interpretation will be confused, because the\n             system type (SYST response) will not be re-checked, and\n             future UNIX-format directory listings (for multiple URLs or\n             \"-r\") will be horribly misinterpreted.\n\n             The cheap and nasty work-around is to do a \"CWD []\" after a\n             UNIX-like directory specification is used.  (A single-level\n             directory is harmless.)  This puts the TCPware server back\n             into VMS mode, and does no harm on other servers.\n\n             Unlike the rest of this block, this particular behavior\n             _is_ VMS-specific, so it gets its own VMS test.\n          */\n          if ((con->rs == ST_VMS) && (strchr( target, '/') != NULL))\n            {\n              cwd_end = 3;\n              DEBUGP ((\"Using extra \\\"CWD []\\\" step for VMS server.\\n\"));\n            }\n          else\n            {\n              cwd_end = 2;\n            }\n\n          /* 2004-09-20 SMS. */\n          /* Sorry about the deviant indenting.  Laziness. */\n\n          for (cwd_count = cwd_start; cwd_count < cwd_end; cwd_count++)\n            {\n              switch (cwd_count)\n                {\n                  case 0:\n                    /* Step one (optional): Go to the initial directory,\n                       exactly as reported by the server.\n                    */\n                    targ = con->id;\n                    break;\n\n                  case 1:\n                    /* Step two: Go to the target directory.  (Absolute or\n                       relative will work now.)\n                    */\n                    targ = target;\n                    break;\n\n                  case 2:\n                    /* Step three (optional): \"CWD []\" to restore server\n                       VMS-ness.\n                    */\n                    targ = \"[]\";\n                    break;\n\n                  default:\n                    logprintf (LOG_ALWAYS, _(\"Logically impossible section reached in getftp()\"));\n                    logprintf (LOG_ALWAYS, _(\"cwd_count: %d\\ncwd_start: %d\\ncwd_end: %d\\n\"),\n                                             cwd_count, cwd_start, cwd_end);\n                    abort ();\n                }\n\n              if (!opt.server_response)\n                logprintf (LOG_VERBOSE, \"==> CWD (%d) %s ... \", cwd_count,\n                           quotearg_style (escape_quoting_style, target));\n\n              err = ftp_cwd (csock, targ);\n\n              /* FTPRERR, WRITEFAILED, FTPNSFOD */\n              switch (err)\n                {\n                  case FTPRERR:\n                    logputs (LOG_VERBOSE, \"\\n\");\n                    logputs (LOG_NOTQUIET, _(\"\\\nError in server response, closing control connection.\\n\"));\n                    fd_close (csock);\n                    con->csock = -1;\n                    return err;\n                  case WRITEFAILED:\n                    logputs (LOG_VERBOSE, \"\\n\");\n                    logputs (LOG_NOTQUIET,\n                             _(\"Write failed, closing control connection.\\n\"));\n                    fd_close (csock);\n                    con->csock = -1;\n                    return err;\n                  case FTPNSFOD:\n                    logputs (LOG_VERBOSE, \"\\n\");\n                    logprintf (LOG_NOTQUIET, _(\"No such directory %s.\\n\\n\"),\n                               quote (u->dir));\n                    fd_close (csock);\n                    con->csock = -1;\n                    return err;\n                  case FTPOK:\n                    break;\n                  default:\n                    abort ();\n                }\n\n              if (!opt.server_response)\n                logputs (LOG_VERBOSE, _(\"done.\\n\"));\n\n            } /* for */\n\n          /* 2004-09-20 SMS. */\n\n        } /* else */\n    }\n  else /* do not CWD */\n    logputs (LOG_VERBOSE, _(\"==> CWD not required.\\n\"));\n\n  if ((cmd & DO_RETR) && passed_expected_bytes == 0)\n    {\n      if (opt.verbose)\n        {\n          if (!opt.server_response)\n            logprintf (LOG_VERBOSE, \"==> SIZE %s ... \",\n                       quotearg_style (escape_quoting_style, u->file));\n        }\n\n      err = ftp_size (csock, u->file, &expected_bytes);\n      /* FTPRERR */\n      switch (err)\n        {\n        case FTPRERR:\n        case FTPSRVERR:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logputs (LOG_NOTQUIET, _(\"\\\nError in server response, closing control connection.\\n\"));\n          fd_close (csock);\n          con->csock = -1;\n          return err;\n        case FTPOK:\n          got_expected_bytes = true;\n          /* Everything is OK.  */\n          break;\n        default:\n          abort ();\n        }\n        if (!opt.server_response)\n          {\n            logprintf (LOG_VERBOSE, \"%s\\n\",\n                    expected_bytes ?\n                    number_to_static_string (expected_bytes) :\n                    _(\"done.\\n\"));\n          }\n    }\n\n  if (cmd & DO_RETR && restval > 0 && restval == expected_bytes)\n    {\n      /* Server confirms that file has length restval. We should stop now.\n         Some servers (f.e. NcFTPd) return error when receive REST 0 */\n      logputs (LOG_VERBOSE, _(\"File has already been retrieved.\\n\"));\n      fd_close (csock);\n      con->csock = -1;\n      return RETRFINISHED;\n    }\n\n  do\n  {\n  try_again = false;\n  /* If anything is to be retrieved, PORT (or PASV) must be sent.  */\n  if (cmd & (DO_LIST | DO_RETR))\n    {\n      if (opt.ftp_pasv)\n        {\n          ip_address passive_addr;\n          int        passive_port;\n          err = ftp_do_pasv (csock, &passive_addr, &passive_port);\n          /* FTPRERR, WRITEFAILED, FTPNOPASV, FTPINVPASV */\n          switch (err)\n            {\n            case FTPRERR:\n              logputs (LOG_VERBOSE, \"\\n\");\n              logputs (LOG_NOTQUIET, _(\"\\\nError in server response, closing control connection.\\n\"));\n              fd_close (csock);\n              con->csock = -1;\n              return err;\n            case WRITEFAILED:\n              logputs (LOG_VERBOSE, \"\\n\");\n              logputs (LOG_NOTQUIET,\n                       _(\"Write failed, closing control connection.\\n\"));\n              fd_close (csock);\n              con->csock = -1;\n              return err;\n            case FTPNOPASV:\n              logputs (LOG_VERBOSE, \"\\n\");\n              logputs (LOG_NOTQUIET, _(\"Cannot initiate PASV transfer.\\n\"));\n              break;\n            case FTPINVPASV:\n              logputs (LOG_VERBOSE, \"\\n\");\n              logputs (LOG_NOTQUIET, _(\"Cannot parse PASV response.\\n\"));\n              break;\n            case FTPOK:\n              break;\n            default:\n              abort ();\n            }   /* switch (err) */\n          if (err==FTPOK)\n            {\n              DEBUGP ((\"trying to connect to %s port %d\\n\",\n                      print_address (&passive_addr), passive_port));\n              dtsock = connect_to_ip (&passive_addr, passive_port, NULL);\n              if (dtsock < 0)\n                {\n                  int save_errno = errno;\n                  fd_close (csock);\n                  con->csock = -1;\n                  logprintf (LOG_VERBOSE, _(\"couldn't connect to %s port %d: %s\\n\"),\n                             print_address (&passive_addr), passive_port,\n                             strerror (save_errno));\n                           ? CONERROR : CONIMPOSSIBLE);\n                 }\n \n              pasv_mode_open = true;  /* Flag to avoid accept port */\n               if (!opt.server_response)\n                 logputs (LOG_VERBOSE, _(\"done.    \"));\n            } /* err==FTP_OK */\n        }\n \n      if (!pasv_mode_open)   /* Try to use a port command if PASV failed */\n         {\n           err = ftp_do_port (csock, &local_sock);\n           /* FTPRERR, WRITEFAILED, bindport (FTPSYSERR), HOSTERR,\n              logputs (LOG_NOTQUIET, _(\"\\\nError in server response, closing control connection.\\n\"));\n              fd_close (csock);\n              con->csock = -1;\n              fd_close (dtsock);\n              fd_close (local_sock);\n              return err;\n            case WRITEFAILED:\n              logputs (LOG_VERBOSE, \"\\n\");\n              logputs (LOG_NOTQUIET,\n                       _(\"Write failed, closing control connection.\\n\"));\n              fd_close (csock);\n              con->csock = -1;\n              fd_close (dtsock);\n              fd_close (local_sock);\n              return err;\n            case CONSOCKERR:\n              logputs (LOG_VERBOSE, \"\\n\");\n              logprintf (LOG_NOTQUIET, \"socket: %s\\n\", strerror (errno));\n              fd_close (csock);\n              con->csock = -1;\n              fd_close (dtsock);\n              fd_close (local_sock);\n              return err;\n            case FTPSYSERR:\n              logputs (LOG_VERBOSE, \"\\n\");\n              logprintf (LOG_NOTQUIET, _(\"Bind error (%s).\\n\"),\n                         strerror (errno));\n              fd_close (dtsock);\n              return err;\n            case FTPPORTERR:\n              logputs (LOG_VERBOSE, \"\\n\");\n              logputs (LOG_NOTQUIET, _(\"Invalid PORT.\\n\"));\n              fd_close (csock);\n              con->csock = -1;\n              fd_close (dtsock);\n              fd_close (local_sock);\n              return err;\n            case FTPOK:\n              break;\n            default:\n              abort ();\n            } /* port switch */\n          if (!opt.server_response)\n            logputs (LOG_VERBOSE, _(\"done.    \"));\n        } /* dtsock == -1 */\n    } /* cmd & (DO_LIST | DO_RETR) */\n\n  /* Restart if needed.  */\n  if (restval && (cmd & DO_RETR))\n    {\n      if (!opt.server_response)\n        logprintf (LOG_VERBOSE, \"==> REST %s ... \",\n                   number_to_static_string (restval));\n      err = ftp_rest (csock, restval);\n\n      /* FTPRERR, WRITEFAILED, FTPRESTFAIL */\n      switch (err)\n        {\n        case FTPRERR:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logputs (LOG_NOTQUIET, _(\"\\\nError in server response, closing control connection.\\n\"));\n          fd_close (csock);\n          con->csock = -1;\n          fd_close (dtsock);\n          fd_close (local_sock);\n          return err;\n        case WRITEFAILED:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logputs (LOG_NOTQUIET,\n                   _(\"Write failed, closing control connection.\\n\"));\n          fd_close (csock);\n          con->csock = -1;\n          fd_close (dtsock);\n          fd_close (local_sock);\n          return err;\n        case FTPRESTFAIL:\n          logputs (LOG_VERBOSE, _(\"\\nREST failed, starting from scratch.\\n\"));\n          rest_failed = true;\n          break;\n        case FTPOK:\n          break;\n        default:\n          abort ();\n        }\n      if (err != FTPRESTFAIL && !opt.server_response)\n        logputs (LOG_VERBOSE, _(\"done.    \"));\n    } /* restval && cmd & DO_RETR */\n\n  if (cmd & DO_RETR)\n    {\n      /* If we're in spider mode, don't really retrieve anything except\n         the directory listing and verify whether the given \"file\" exists.  */\n      if (opt.spider)\n        {\n          bool exists = false;\n          struct fileinfo *f;\n          uerr_t _res = ftp_get_listing (u, con, &f);\n          /* Set the DO_RETR command flag again, because it gets unset when\n             calling ftp_get_listing() and would otherwise cause an assertion\n             failure earlier on when this function gets repeatedly called\n             (e.g., when recursing).  */\n          con->cmd |= DO_RETR;\n          if (_res == RETROK)\n            {\n              while (f)\n                {\n                  if (!strcmp (f->name, u->file))\n                    {\n                      exists = true;\n                      break;\n                    }\n                  f = f->next;\n                }\n              if (exists)\n                {\n                  logputs (LOG_VERBOSE, \"\\n\");\n                  logprintf (LOG_NOTQUIET, _(\"File %s exists.\\n\"),\n                             quote (u->file));\n                }\n              else\n                {\n                  logputs (LOG_VERBOSE, \"\\n\");\n                  logprintf (LOG_NOTQUIET, _(\"No such file %s.\\n\"),\n                             quote (u->file));\n                }\n            }\n          fd_close (csock);\n          con->csock = -1;\n          fd_close (dtsock);\n          fd_close (local_sock);\n          return RETRFINISHED;\n        }\n\n      if (opt.verbose)\n        {\n          if (!opt.server_response)\n            {\n              if (restval)\n                logputs (LOG_VERBOSE, \"\\n\");\n              logprintf (LOG_VERBOSE, \"==> RETR %s ... \",\n                         quotearg_style (escape_quoting_style, u->file));\n            }\n        }\n\n      err = ftp_retr (csock, u->file);\n      /* FTPRERR, WRITEFAILED, FTPNSFOD */\n      switch (err)\n        {\n        case FTPRERR:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logputs (LOG_NOTQUIET, _(\"\\\nError in server response, closing control connection.\\n\"));\n          fd_close (csock);\n          con->csock = -1;\n          fd_close (dtsock);\n          fd_close (local_sock);\n          return err;\n        case WRITEFAILED:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logputs (LOG_NOTQUIET,\n                   _(\"Write failed, closing control connection.\\n\"));\n          fd_close (csock);\n          con->csock = -1;\n          fd_close (dtsock);\n          fd_close (local_sock);\n          return err;\n        case FTPNSFOD:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logprintf (LOG_NOTQUIET, _(\"No such file %s.\\n\\n\"),\n                     quote (u->file));\n          fd_close (dtsock);\n          fd_close (local_sock);\n          return err;\n        case FTPOK:\n          break;\n        default:\n          abort ();\n        }\n\n      if (!opt.server_response)\n        logputs (LOG_VERBOSE, _(\"done.\\n\"));\n\n      if (! got_expected_bytes)\n        expected_bytes = *last_expected_bytes;\n    } /* do retrieve */\n\n  if (cmd & DO_LIST)\n    {\n      if (!opt.server_response)\n        logputs (LOG_VERBOSE, \"==> LIST ... \");\n      /* As Maciej W. Rozycki (macro@ds2.pg.gda.pl) says, `LIST'\n         without arguments is better than `LIST .'; confirmed by\n         RFC959.  */\n      err = ftp_list (csock, NULL, con->st&AVOID_LIST_A, con->st&AVOID_LIST, &list_a_used);\n\n      /* FTPRERR, WRITEFAILED */\n      switch (err)\n        {\n        case FTPRERR:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logputs (LOG_NOTQUIET, _(\"\\\nError in server response, closing control connection.\\n\"));\n          fd_close (csock);\n          con->csock = -1;\n          fd_close (dtsock);\n          fd_close (local_sock);\n          return err;\n        case WRITEFAILED:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logputs (LOG_NOTQUIET,\n                   _(\"Write failed, closing control connection.\\n\"));\n          fd_close (csock);\n          con->csock = -1;\n          fd_close (dtsock);\n          fd_close (local_sock);\n          return err;\n        case FTPNSFOD:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logprintf (LOG_NOTQUIET, _(\"No such file or directory %s.\\n\\n\"),\n                     quote (\".\"));\n          fd_close (dtsock);\n          fd_close (local_sock);\n          return err;\n        case FTPOK:\n          break;\n        default:\n          abort ();\n        }\n      if (!opt.server_response)\n        logputs (LOG_VERBOSE, _(\"done.\\n\"));\n\n      if (! got_expected_bytes)\n        expected_bytes = *last_expected_bytes;\n    } /* cmd & DO_LIST */\n\n  if (!(cmd & (DO_LIST | DO_RETR)) || (opt.spider && !(cmd & DO_LIST)))\n    return RETRFINISHED;\n\n  /* Some FTP servers return the total length of file after REST\n     command, others just return the remaining size. */\n  if (passed_expected_bytes && restval && expected_bytes\n      && (expected_bytes == passed_expected_bytes - restval))\n    {\n      DEBUGP ((\"Lying FTP server found, adjusting.\\n\"));\n      expected_bytes = passed_expected_bytes;\n    }\n\n  /* If no transmission was required, then everything is OK.  */\n  if (!pasv_mode_open)  /* we are not using pasive mode so we need\n                              to accept */\n     }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141347,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "getftp (struct url *u, wgint passed_expected_bytes, wgint *qtyread,\n        wgint restval, ccon *con, int count, wgint *last_expected_bytes,\n        FILE *warc_tmp)\n{\n  int csock, dtsock, local_sock, res;\n  uerr_t err = RETROK;          /* appease the compiler */\n  FILE *fp;\n   char *respline, *tms;\n   const char *user, *passwd, *tmrate;\n   int cmd = con->cmd;\n   wgint expected_bytes = 0;\n   bool got_expected_bytes = false;\n   bool rest_failed = false;\n  bool rest_failed = false;\n  int flags;\n  wgint rd_size, previous_rd_size = 0;\n  char type_char;\n  bool try_again;\n  bool list_a_used = false;\n\n  assert (con != NULL);\n  assert (con->target != NULL);\n\n  /* Debug-check of the sanity of the request by making sure that LIST\n     and RETR are never both requested (since we can handle only one\n     at a time.  */\n  assert (!((cmd & DO_LIST) && (cmd & DO_RETR)));\n  /* Make sure that at least *something* is requested.  */\n  assert ((cmd & (DO_LIST | DO_CWD | DO_RETR | DO_LOGIN)) != 0);\n\n  *qtyread = restval;\n\n  user = u->user;\n  passwd = u->passwd;\n  search_netrc (u->host, (const char **)&user, (const char **)&passwd, 1);\n  user = user ? user : (opt.ftp_user ? opt.ftp_user : opt.user);\n  if (!user) user = \"anonymous\";\n  passwd = passwd ? passwd : (opt.ftp_passwd ? opt.ftp_passwd : opt.passwd);\n  if (!passwd) passwd = \"-wget@\";\n\n  dtsock = -1;\n  local_sock = -1;\n  con->dltime = 0;\n\n  if (!(cmd & DO_LOGIN))\n    csock = con->csock;\n  else                          /* cmd & DO_LOGIN */\n    {\n      char    *host = con->proxy ? con->proxy->host : u->host;\n      int      port = con->proxy ? con->proxy->port : u->port;\n\n      /* Login to the server: */\n\n      /* First: Establish the control connection.  */\n\n      csock = connect_to_host (host, port);\n      if (csock == E_HOST)\n          return HOSTERR;\n      else if (csock < 0)\n          return (retryable_socket_connect_error (errno)\n                  ? CONERROR : CONIMPOSSIBLE);\n\n      if (cmd & LEAVE_PENDING)\n        con->csock = csock;\n      else\n        con->csock = -1;\n\n      /* Second: Login with proper USER/PASS sequence.  */\n      logprintf (LOG_VERBOSE, _(\"Logging in as %s ... \"),\n                 quotearg_style (escape_quoting_style, user));\n      if (opt.server_response)\n        logputs (LOG_ALWAYS, \"\\n\");\n      if (con->proxy)\n        {\n          /* If proxy is in use, log in as username@target-site. */\n          char *logname = concat_strings (user, \"@\", u->host, (char *) 0);\n          err = ftp_login (csock, logname, passwd);\n          xfree (logname);\n        }\n      else\n        err = ftp_login (csock, user, passwd);\n\n      /* FTPRERR, FTPSRVERR, WRITEFAILED, FTPLOGREFUSED, FTPLOGINC */\n      switch (err)\n        {\n        case FTPRERR:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logputs (LOG_NOTQUIET, _(\"\\\nError in server response, closing control connection.\\n\"));\n          fd_close (csock);\n          con->csock = -1;\n          return err;\n        case FTPSRVERR:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logputs (LOG_NOTQUIET, _(\"Error in server greeting.\\n\"));\n          fd_close (csock);\n          con->csock = -1;\n          return err;\n        case WRITEFAILED:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logputs (LOG_NOTQUIET,\n                   _(\"Write failed, closing control connection.\\n\"));\n          fd_close (csock);\n          con->csock = -1;\n          return err;\n        case FTPLOGREFUSED:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logputs (LOG_NOTQUIET, _(\"The server refuses login.\\n\"));\n          fd_close (csock);\n          con->csock = -1;\n          return FTPLOGREFUSED;\n        case FTPLOGINC:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logputs (LOG_NOTQUIET, _(\"Login incorrect.\\n\"));\n          fd_close (csock);\n          con->csock = -1;\n          return FTPLOGINC;\n        case FTPOK:\n          if (!opt.server_response)\n            logputs (LOG_VERBOSE, _(\"Logged in!\\n\"));\n          break;\n        default:\n          abort ();\n        }\n      /* Third: Get the system type */\n      if (!opt.server_response)\n        logprintf (LOG_VERBOSE, \"==> SYST ... \");\n      err = ftp_syst (csock, &con->rs, &con->rsu);\n      /* FTPRERR */\n      switch (err)\n        {\n        case FTPRERR:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logputs (LOG_NOTQUIET, _(\"\\\nError in server response, closing control connection.\\n\"));\n          fd_close (csock);\n          con->csock = -1;\n          return err;\n        case FTPSRVERR:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logputs (LOG_NOTQUIET,\n                   _(\"Server error, can't determine system type.\\n\"));\n          break;\n        case FTPOK:\n          /* Everything is OK.  */\n          break;\n        default:\n          abort ();\n        }\n      if (!opt.server_response && err != FTPSRVERR)\n        logputs (LOG_VERBOSE, _(\"done.    \"));\n\n      /* 2013-10-17 Andrea Urbani (matfanjol)\n         According to the system type I choose which\n         list command will be used.\n         If I don't know that system, I will try, the\n         first time of each session, \"LIST -a\" and\n         \"LIST\". (see __LIST_A_EXPLANATION__ below) */\n      switch (con->rs)\n        {\n        case ST_VMS:\n          /* About ST_VMS there is an old note:\n             2008-01-29  SMS.  For a VMS FTP server, where \"LIST -a\" may not\n             fail, but will never do what is desired here,\n             skip directly to the simple \"LIST\" command\n             (assumed to be the last one in the list).  */\n          DEBUGP ((\"\\nVMS: I know it and I will use \\\"LIST\\\" as standard list command\\n\"));\n          con->st |= LIST_AFTER_LIST_A_CHECK_DONE;\n          con->st |= AVOID_LIST_A;\n          break;\n        case ST_UNIX:\n          if (con->rsu == UST_MULTINET)\n            {\n              DEBUGP ((\"\\nUNIX MultiNet: I know it and I will use \\\"LIST\\\" \"\n                       \"as standard list command\\n\"));\n              con->st |= LIST_AFTER_LIST_A_CHECK_DONE;\n              con->st |= AVOID_LIST_A;\n            }\n          else if (con->rsu == UST_TYPE_L8)\n            {\n              DEBUGP ((\"\\nUNIX TYPE L8: I know it and I will use \\\"LIST -a\\\" \"\n                       \"as standard list command\\n\"));\n              con->st |= LIST_AFTER_LIST_A_CHECK_DONE;\n              con->st |= AVOID_LIST;\n            }\n          break;\n        default:\n          break;\n        }\n\n      /* Fourth: Find the initial ftp directory */\n\n      if (!opt.server_response)\n        logprintf (LOG_VERBOSE, \"==> PWD ... \");\n      err = ftp_pwd (csock, &con->id);\n      /* FTPRERR */\n      switch (err)\n        {\n        case FTPRERR:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logputs (LOG_NOTQUIET, _(\"\\\nError in server response, closing control connection.\\n\"));\n          fd_close (csock);\n          con->csock = -1;\n          return err;\n        case FTPSRVERR :\n          /* PWD unsupported -- assume \"/\". */\n          xfree (con->id);\n          con->id = xstrdup (\"/\");\n          break;\n        case FTPOK:\n          /* Everything is OK.  */\n          break;\n        default:\n          abort ();\n        }\n\n#if 0\n      /* 2004-09-17 SMS.\n         Don't help me out.  Please.\n         A reasonably recent VMS FTP server will cope just fine with\n         UNIX file specifications.  This code just spoils things.\n         Discarding the device name, for example, is not a wise move.\n         This code was disabled but left in as an example of what not\n         to do.\n      */\n\n      /* VMS will report something like \"PUB$DEVICE:[INITIAL.FOLDER]\".\n         Convert it to \"/INITIAL/FOLDER\" */\n      if (con->rs == ST_VMS)\n        {\n          char *path = strchr (con->id, '[');\n          char *pathend = path ? strchr (path + 1, ']') : NULL;\n          if (!path || !pathend)\n            DEBUGP ((\"Initial VMS directory not in the form [...]!\\n\"));\n          else\n            {\n              char *idir = con->id;\n              DEBUGP ((\"Preprocessing the initial VMS directory\\n\"));\n              DEBUGP ((\"  old = '%s'\\n\", con->id));\n              /* We do the conversion in-place by copying the stuff\n                 between [ and ] to the beginning, and changing dots\n                 to slashes at the same time.  */\n              *idir++ = '/';\n              for (++path; path < pathend; path++, idir++)\n                *idir = *path == '.' ? '/' : *path;\n              *idir = '\\0';\n              DEBUGP ((\"  new = '%s'\\n\\n\", con->id));\n            }\n        }\n#endif /* 0 */\n\n      if (!opt.server_response)\n        logputs (LOG_VERBOSE, _(\"done.\\n\"));\n\n      /* Fifth: Set the FTP type.  */\n      type_char = ftp_process_type (u->params);\n      if (!opt.server_response)\n        logprintf (LOG_VERBOSE, \"==> TYPE %c ... \", type_char);\n      err = ftp_type (csock, type_char);\n      /* FTPRERR, WRITEFAILED, FTPUNKNOWNTYPE */\n      switch (err)\n        {\n        case FTPRERR:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logputs (LOG_NOTQUIET, _(\"\\\nError in server response, closing control connection.\\n\"));\n          fd_close (csock);\n          con->csock = -1;\n          return err;\n        case WRITEFAILED:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logputs (LOG_NOTQUIET,\n                   _(\"Write failed, closing control connection.\\n\"));\n          fd_close (csock);\n          con->csock = -1;\n          return err;\n        case FTPUNKNOWNTYPE:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logprintf (LOG_NOTQUIET,\n                     _(\"Unknown type `%c', closing control connection.\\n\"),\n                     type_char);\n          fd_close (csock);\n          con->csock = -1;\n          return err;\n        case FTPOK:\n          /* Everything is OK.  */\n          break;\n        default:\n          abort ();\n        }\n      if (!opt.server_response)\n        logputs (LOG_VERBOSE, _(\"done.  \"));\n    } /* do login */\n\n  if (cmd & DO_CWD)\n    {\n      if (!*u->dir)\n        logputs (LOG_VERBOSE, _(\"==> CWD not needed.\\n\"));\n      else\n        {\n          const char *targ = NULL;\n          int cwd_count;\n          int cwd_end;\n          int cwd_start;\n\n          char *target = u->dir;\n\n          DEBUGP ((\"changing working directory\\n\"));\n\n          /* Change working directory.  To change to a non-absolute\n             Unix directory, we need to prepend initial directory\n             (con->id) to it.  Absolute directories \"just work\".\n\n             A relative directory is one that does not begin with '/'\n             and, on non-Unix OS'es, one that doesn't begin with\n             \"[a-z]:\".\n\n             This is not done for OS400, which doesn't use\n             \"/\"-delimited directories, nor does it support directory\n             hierarchies.  \"CWD foo\" followed by \"CWD bar\" leaves us\n             in \"bar\", not in \"foo/bar\", as would be customary\n             elsewhere.  */\n\n            /* 2004-09-20 SMS.\n               Why is this wise even on UNIX?  It certainly fouls VMS.\n               See below for a more reliable, more universal method.\n            */\n\n            /* 2008-04-22 MJC.\n               I'm not crazy about it either. I'm informed it's useful\n               for misconfigured servers that have some dirs in the path\n               with +x but -r, but this method is not RFC-conformant. I\n               understand the need to deal with crappy server\n               configurations, but it's far better to use the canonical\n               method first, and fall back to kludges second.\n            */\n\n          if (target[0] != '/'\n              && !(con->rs != ST_UNIX\n                   && c_isalpha (target[0])\n                   && target[1] == ':')\n              && (con->rs != ST_OS400)\n              && (con->rs != ST_VMS))\n            {\n              int idlen = strlen (con->id);\n              char *ntarget, *p;\n\n              /* Strip trailing slash(es) from con->id. */\n              while (idlen > 0 && con->id[idlen - 1] == '/')\n                --idlen;\n              p = ntarget = (char *)alloca (idlen + 1 + strlen (u->dir) + 1);\n              memcpy (p, con->id, idlen);\n              p += idlen;\n              *p++ = '/';\n              strcpy (p, target);\n\n              DEBUGP ((\"Prepended initial PWD to relative path:\\n\"));\n              DEBUGP ((\"   pwd: '%s'\\n   old: '%s'\\n  new: '%s'\\n\",\n                       con->id, target, ntarget));\n              target = ntarget;\n            }\n\n#if 0\n          /* 2004-09-17 SMS.\n             Don't help me out.  Please.\n             A reasonably recent VMS FTP server will cope just fine with\n             UNIX file specifications.  This code just spoils things.\n             Discarding the device name, for example, is not a wise\n             move.\n             This code was disabled but left in as an example of what\n             not to do.\n          */\n\n          /* If the FTP host runs VMS, we will have to convert the absolute\n             directory path in UNIX notation to absolute directory path in\n             VMS notation as VMS FTP servers do not like UNIX notation of\n             absolute paths.  \"VMS notation\" is [dir.subdir.subsubdir]. */\n\n          if (con->rs == ST_VMS)\n            {\n              char *tmpp;\n              char *ntarget = (char *)alloca (strlen (target) + 2);\n              /* We use a converted initial dir, so directories in\n                 TARGET will be separated with slashes, something like\n                 \"/INITIAL/FOLDER/DIR/SUBDIR\".  Convert that to\n                 \"[INITIAL.FOLDER.DIR.SUBDIR]\".  */\n              strcpy (ntarget, target);\n              assert (*ntarget == '/');\n              *ntarget = '[';\n              for (tmpp = ntarget + 1; *tmpp; tmpp++)\n                if (*tmpp == '/')\n                  *tmpp = '.';\n              *tmpp++ = ']';\n              *tmpp = '\\0';\n              DEBUGP ((\"Changed file name to VMS syntax:\\n\"));\n              DEBUGP ((\"  Unix: '%s'\\n  VMS: '%s'\\n\", target, ntarget));\n              target = ntarget;\n            }\n#endif /* 0 */\n\n          /* 2004-09-20 SMS.\n             A relative directory is relative to the initial directory.\n             Thus, what _is_ useful on VMS (and probably elsewhere) is\n             to CWD to the initial directory (ideally, whatever the\n             server reports, _exactly_, NOT badly UNIX-ixed), and then\n             CWD to the (new) relative directory.  This should probably\n             be restructured as a function, called once or twice, but\n             I'm lazy enough to take the badly indented loop short-cut\n             for now.\n          */\n\n          /* Decide on one pass (absolute) or two (relative).\n             The VMS restriction may be relaxed when the squirrely code\n             above is reformed.\n          */\n          if ((con->rs == ST_VMS) && (target[0] != '/'))\n            {\n              cwd_start = 0;\n              DEBUGP ((\"Using two-step CWD for relative path.\\n\"));\n            }\n          else\n            {\n              /* Go straight to the target. */\n              cwd_start = 1;\n            }\n\n          /* At least one VMS FTP server (TCPware V5.6-2) can switch to\n             a UNIX emulation mode when given a UNIX-like directory\n             specification (like \"a/b/c\").  If allowed to continue this\n             way, LIST interpretation will be confused, because the\n             system type (SYST response) will not be re-checked, and\n             future UNIX-format directory listings (for multiple URLs or\n             \"-r\") will be horribly misinterpreted.\n\n             The cheap and nasty work-around is to do a \"CWD []\" after a\n             UNIX-like directory specification is used.  (A single-level\n             directory is harmless.)  This puts the TCPware server back\n             into VMS mode, and does no harm on other servers.\n\n             Unlike the rest of this block, this particular behavior\n             _is_ VMS-specific, so it gets its own VMS test.\n          */\n          if ((con->rs == ST_VMS) && (strchr( target, '/') != NULL))\n            {\n              cwd_end = 3;\n              DEBUGP ((\"Using extra \\\"CWD []\\\" step for VMS server.\\n\"));\n            }\n          else\n            {\n              cwd_end = 2;\n            }\n\n          /* 2004-09-20 SMS. */\n          /* Sorry about the deviant indenting.  Laziness. */\n\n          for (cwd_count = cwd_start; cwd_count < cwd_end; cwd_count++)\n            {\n              switch (cwd_count)\n                {\n                  case 0:\n                    /* Step one (optional): Go to the initial directory,\n                       exactly as reported by the server.\n                    */\n                    targ = con->id;\n                    break;\n\n                  case 1:\n                    /* Step two: Go to the target directory.  (Absolute or\n                       relative will work now.)\n                    */\n                    targ = target;\n                    break;\n\n                  case 2:\n                    /* Step three (optional): \"CWD []\" to restore server\n                       VMS-ness.\n                    */\n                    targ = \"[]\";\n                    break;\n\n                  default:\n                    logprintf (LOG_ALWAYS, _(\"Logically impossible section reached in getftp()\"));\n                    logprintf (LOG_ALWAYS, _(\"cwd_count: %d\\ncwd_start: %d\\ncwd_end: %d\\n\"),\n                                             cwd_count, cwd_start, cwd_end);\n                    abort ();\n                }\n\n              if (!opt.server_response)\n                logprintf (LOG_VERBOSE, \"==> CWD (%d) %s ... \", cwd_count,\n                           quotearg_style (escape_quoting_style, target));\n\n              err = ftp_cwd (csock, targ);\n\n              /* FTPRERR, WRITEFAILED, FTPNSFOD */\n              switch (err)\n                {\n                  case FTPRERR:\n                    logputs (LOG_VERBOSE, \"\\n\");\n                    logputs (LOG_NOTQUIET, _(\"\\\nError in server response, closing control connection.\\n\"));\n                    fd_close (csock);\n                    con->csock = -1;\n                    return err;\n                  case WRITEFAILED:\n                    logputs (LOG_VERBOSE, \"\\n\");\n                    logputs (LOG_NOTQUIET,\n                             _(\"Write failed, closing control connection.\\n\"));\n                    fd_close (csock);\n                    con->csock = -1;\n                    return err;\n                  case FTPNSFOD:\n                    logputs (LOG_VERBOSE, \"\\n\");\n                    logprintf (LOG_NOTQUIET, _(\"No such directory %s.\\n\\n\"),\n                               quote (u->dir));\n                    fd_close (csock);\n                    con->csock = -1;\n                    return err;\n                  case FTPOK:\n                    break;\n                  default:\n                    abort ();\n                }\n\n              if (!opt.server_response)\n                logputs (LOG_VERBOSE, _(\"done.\\n\"));\n\n            } /* for */\n\n          /* 2004-09-20 SMS. */\n\n        } /* else */\n    }\n  else /* do not CWD */\n    logputs (LOG_VERBOSE, _(\"==> CWD not required.\\n\"));\n\n  if ((cmd & DO_RETR) && passed_expected_bytes == 0)\n    {\n      if (opt.verbose)\n        {\n          if (!opt.server_response)\n            logprintf (LOG_VERBOSE, \"==> SIZE %s ... \",\n                       quotearg_style (escape_quoting_style, u->file));\n        }\n\n      err = ftp_size (csock, u->file, &expected_bytes);\n      /* FTPRERR */\n      switch (err)\n        {\n        case FTPRERR:\n        case FTPSRVERR:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logputs (LOG_NOTQUIET, _(\"\\\nError in server response, closing control connection.\\n\"));\n          fd_close (csock);\n          con->csock = -1;\n          return err;\n        case FTPOK:\n          got_expected_bytes = true;\n          /* Everything is OK.  */\n          break;\n        default:\n          abort ();\n        }\n        if (!opt.server_response)\n          {\n            logprintf (LOG_VERBOSE, \"%s\\n\",\n                    expected_bytes ?\n                    number_to_static_string (expected_bytes) :\n                    _(\"done.\\n\"));\n          }\n    }\n\n  if (cmd & DO_RETR && restval > 0 && restval == expected_bytes)\n    {\n      /* Server confirms that file has length restval. We should stop now.\n         Some servers (f.e. NcFTPd) return error when receive REST 0 */\n      logputs (LOG_VERBOSE, _(\"File has already been retrieved.\\n\"));\n      fd_close (csock);\n      con->csock = -1;\n      return RETRFINISHED;\n    }\n\n  do\n  {\n  try_again = false;\n  /* If anything is to be retrieved, PORT (or PASV) must be sent.  */\n  if (cmd & (DO_LIST | DO_RETR))\n    {\n      if (opt.ftp_pasv)\n        {\n          ip_address passive_addr;\n          int        passive_port;\n          err = ftp_do_pasv (csock, &passive_addr, &passive_port);\n          /* FTPRERR, WRITEFAILED, FTPNOPASV, FTPINVPASV */\n          switch (err)\n            {\n            case FTPRERR:\n              logputs (LOG_VERBOSE, \"\\n\");\n              logputs (LOG_NOTQUIET, _(\"\\\nError in server response, closing control connection.\\n\"));\n              fd_close (csock);\n              con->csock = -1;\n              return err;\n            case WRITEFAILED:\n              logputs (LOG_VERBOSE, \"\\n\");\n              logputs (LOG_NOTQUIET,\n                       _(\"Write failed, closing control connection.\\n\"));\n              fd_close (csock);\n              con->csock = -1;\n              return err;\n            case FTPNOPASV:\n              logputs (LOG_VERBOSE, \"\\n\");\n              logputs (LOG_NOTQUIET, _(\"Cannot initiate PASV transfer.\\n\"));\n              break;\n            case FTPINVPASV:\n              logputs (LOG_VERBOSE, \"\\n\");\n              logputs (LOG_NOTQUIET, _(\"Cannot parse PASV response.\\n\"));\n              break;\n            case FTPOK:\n              break;\n            default:\n              abort ();\n            }   /* switch (err) */\n          if (err==FTPOK)\n            {\n              DEBUGP ((\"trying to connect to %s port %d\\n\",\n                      print_address (&passive_addr), passive_port));\n              dtsock = connect_to_ip (&passive_addr, passive_port, NULL);\n              if (dtsock < 0)\n                {\n                  int save_errno = errno;\n                  fd_close (csock);\n                  con->csock = -1;\n                  logprintf (LOG_VERBOSE, _(\"couldn't connect to %s port %d: %s\\n\"),\n                             print_address (&passive_addr), passive_port,\n                             strerror (save_errno));\n                           ? CONERROR : CONIMPOSSIBLE);\n                 }\n \n               if (!opt.server_response)\n                 logputs (LOG_VERBOSE, _(\"done.    \"));\n            }\n          else\n            return err;\n \n          /*\n           * We do not want to fall back from PASSIVE mode to ACTIVE mode !\n           * The reason is the PORT command exposes the client's real IP address\n           * to the server. Bad for someone who relies on privacy via a ftp proxy.\n           */\n        }\n      else\n         {\n           err = ftp_do_port (csock, &local_sock);\n           /* FTPRERR, WRITEFAILED, bindport (FTPSYSERR), HOSTERR,\n              logputs (LOG_NOTQUIET, _(\"\\\nError in server response, closing control connection.\\n\"));\n              fd_close (csock);\n              con->csock = -1;\n              fd_close (dtsock);\n              fd_close (local_sock);\n              return err;\n            case WRITEFAILED:\n              logputs (LOG_VERBOSE, \"\\n\");\n              logputs (LOG_NOTQUIET,\n                       _(\"Write failed, closing control connection.\\n\"));\n              fd_close (csock);\n              con->csock = -1;\n              fd_close (dtsock);\n              fd_close (local_sock);\n              return err;\n            case CONSOCKERR:\n              logputs (LOG_VERBOSE, \"\\n\");\n              logprintf (LOG_NOTQUIET, \"socket: %s\\n\", strerror (errno));\n              fd_close (csock);\n              con->csock = -1;\n              fd_close (dtsock);\n              fd_close (local_sock);\n              return err;\n            case FTPSYSERR:\n              logputs (LOG_VERBOSE, \"\\n\");\n              logprintf (LOG_NOTQUIET, _(\"Bind error (%s).\\n\"),\n                         strerror (errno));\n              fd_close (dtsock);\n              return err;\n            case FTPPORTERR:\n              logputs (LOG_VERBOSE, \"\\n\");\n              logputs (LOG_NOTQUIET, _(\"Invalid PORT.\\n\"));\n              fd_close (csock);\n              con->csock = -1;\n              fd_close (dtsock);\n              fd_close (local_sock);\n              return err;\n            case FTPOK:\n              break;\n            default:\n              abort ();\n            } /* port switch */\n          if (!opt.server_response)\n            logputs (LOG_VERBOSE, _(\"done.    \"));\n        } /* dtsock == -1 */\n    } /* cmd & (DO_LIST | DO_RETR) */\n\n  /* Restart if needed.  */\n  if (restval && (cmd & DO_RETR))\n    {\n      if (!opt.server_response)\n        logprintf (LOG_VERBOSE, \"==> REST %s ... \",\n                   number_to_static_string (restval));\n      err = ftp_rest (csock, restval);\n\n      /* FTPRERR, WRITEFAILED, FTPRESTFAIL */\n      switch (err)\n        {\n        case FTPRERR:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logputs (LOG_NOTQUIET, _(\"\\\nError in server response, closing control connection.\\n\"));\n          fd_close (csock);\n          con->csock = -1;\n          fd_close (dtsock);\n          fd_close (local_sock);\n          return err;\n        case WRITEFAILED:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logputs (LOG_NOTQUIET,\n                   _(\"Write failed, closing control connection.\\n\"));\n          fd_close (csock);\n          con->csock = -1;\n          fd_close (dtsock);\n          fd_close (local_sock);\n          return err;\n        case FTPRESTFAIL:\n          logputs (LOG_VERBOSE, _(\"\\nREST failed, starting from scratch.\\n\"));\n          rest_failed = true;\n          break;\n        case FTPOK:\n          break;\n        default:\n          abort ();\n        }\n      if (err != FTPRESTFAIL && !opt.server_response)\n        logputs (LOG_VERBOSE, _(\"done.    \"));\n    } /* restval && cmd & DO_RETR */\n\n  if (cmd & DO_RETR)\n    {\n      /* If we're in spider mode, don't really retrieve anything except\n         the directory listing and verify whether the given \"file\" exists.  */\n      if (opt.spider)\n        {\n          bool exists = false;\n          struct fileinfo *f;\n          uerr_t _res = ftp_get_listing (u, con, &f);\n          /* Set the DO_RETR command flag again, because it gets unset when\n             calling ftp_get_listing() and would otherwise cause an assertion\n             failure earlier on when this function gets repeatedly called\n             (e.g., when recursing).  */\n          con->cmd |= DO_RETR;\n          if (_res == RETROK)\n            {\n              while (f)\n                {\n                  if (!strcmp (f->name, u->file))\n                    {\n                      exists = true;\n                      break;\n                    }\n                  f = f->next;\n                }\n              if (exists)\n                {\n                  logputs (LOG_VERBOSE, \"\\n\");\n                  logprintf (LOG_NOTQUIET, _(\"File %s exists.\\n\"),\n                             quote (u->file));\n                }\n              else\n                {\n                  logputs (LOG_VERBOSE, \"\\n\");\n                  logprintf (LOG_NOTQUIET, _(\"No such file %s.\\n\"),\n                             quote (u->file));\n                }\n            }\n          fd_close (csock);\n          con->csock = -1;\n          fd_close (dtsock);\n          fd_close (local_sock);\n          return RETRFINISHED;\n        }\n\n      if (opt.verbose)\n        {\n          if (!opt.server_response)\n            {\n              if (restval)\n                logputs (LOG_VERBOSE, \"\\n\");\n              logprintf (LOG_VERBOSE, \"==> RETR %s ... \",\n                         quotearg_style (escape_quoting_style, u->file));\n            }\n        }\n\n      err = ftp_retr (csock, u->file);\n      /* FTPRERR, WRITEFAILED, FTPNSFOD */\n      switch (err)\n        {\n        case FTPRERR:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logputs (LOG_NOTQUIET, _(\"\\\nError in server response, closing control connection.\\n\"));\n          fd_close (csock);\n          con->csock = -1;\n          fd_close (dtsock);\n          fd_close (local_sock);\n          return err;\n        case WRITEFAILED:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logputs (LOG_NOTQUIET,\n                   _(\"Write failed, closing control connection.\\n\"));\n          fd_close (csock);\n          con->csock = -1;\n          fd_close (dtsock);\n          fd_close (local_sock);\n          return err;\n        case FTPNSFOD:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logprintf (LOG_NOTQUIET, _(\"No such file %s.\\n\\n\"),\n                     quote (u->file));\n          fd_close (dtsock);\n          fd_close (local_sock);\n          return err;\n        case FTPOK:\n          break;\n        default:\n          abort ();\n        }\n\n      if (!opt.server_response)\n        logputs (LOG_VERBOSE, _(\"done.\\n\"));\n\n      if (! got_expected_bytes)\n        expected_bytes = *last_expected_bytes;\n    } /* do retrieve */\n\n  if (cmd & DO_LIST)\n    {\n      if (!opt.server_response)\n        logputs (LOG_VERBOSE, \"==> LIST ... \");\n      /* As Maciej W. Rozycki (macro@ds2.pg.gda.pl) says, `LIST'\n         without arguments is better than `LIST .'; confirmed by\n         RFC959.  */\n      err = ftp_list (csock, NULL, con->st&AVOID_LIST_A, con->st&AVOID_LIST, &list_a_used);\n\n      /* FTPRERR, WRITEFAILED */\n      switch (err)\n        {\n        case FTPRERR:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logputs (LOG_NOTQUIET, _(\"\\\nError in server response, closing control connection.\\n\"));\n          fd_close (csock);\n          con->csock = -1;\n          fd_close (dtsock);\n          fd_close (local_sock);\n          return err;\n        case WRITEFAILED:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logputs (LOG_NOTQUIET,\n                   _(\"Write failed, closing control connection.\\n\"));\n          fd_close (csock);\n          con->csock = -1;\n          fd_close (dtsock);\n          fd_close (local_sock);\n          return err;\n        case FTPNSFOD:\n          logputs (LOG_VERBOSE, \"\\n\");\n          logprintf (LOG_NOTQUIET, _(\"No such file or directory %s.\\n\\n\"),\n                     quote (\".\"));\n          fd_close (dtsock);\n          fd_close (local_sock);\n          return err;\n        case FTPOK:\n          break;\n        default:\n          abort ();\n        }\n      if (!opt.server_response)\n        logputs (LOG_VERBOSE, _(\"done.\\n\"));\n\n      if (! got_expected_bytes)\n        expected_bytes = *last_expected_bytes;\n    } /* cmd & DO_LIST */\n\n  if (!(cmd & (DO_LIST | DO_RETR)) || (opt.spider && !(cmd & DO_LIST)))\n    return RETRFINISHED;\n\n  /* Some FTP servers return the total length of file after REST\n     command, others just return the remaining size. */\n  if (passed_expected_bytes && restval && expected_bytes\n      && (expected_bytes == passed_expected_bytes - restval))\n    {\n      DEBUGP ((\"Lying FTP server found, adjusting.\\n\"));\n      expected_bytes = passed_expected_bytes;\n    }\n\n  /* If no transmission was required, then everything is OK.  */\n  if (!pasv_mode_open)  /* we are not using pasive mode so we need\n                              to accept */\n     }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141348,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "_PUBLIC_ codepoint_t next_codepoint_handle_ext(\n\t\t\tstruct smb_iconv_handle *ic,\n\t\t\tconst char *str, size_t len,\n\t\t\tcharset_t src_charset,\n\t\t\tsize_t *bytes_consumed)\n{\n\t/* it cannot occupy more than 4 bytes in UTF16 format */\n\tuint8_t buf[4];\n\tsmb_iconv_t descriptor;\n\tsize_t ilen_orig;\n\tsize_t ilen;\n        size_t olen;\n        char *outbuf;\n \n       if ((str[0] & 0x80) == 0) {\n                *bytes_consumed = 1;\n                return (codepoint_t)str[0];\n        }\n\t * This is OK as we only support codepoints up to 1M (U+100000)\n\t */\n\tilen_orig = MIN(len, 5);\n\tilen = ilen_orig;\n\n\tdescriptor = get_conv_handle(ic, src_charset, CH_UTF16);\n\tif (descriptor == (smb_iconv_t)-1) {\n\t\t*bytes_consumed = 1;\n\t\treturn INVALID_CODEPOINT;\n\t}\n\n\t/*\n\t * this looks a little strange, but it is needed to cope with\n\t * codepoints above 64k (U+1000) which are encoded as per RFC2781.\n\t */\n\tolen = 2;\n\toutbuf = (char *)buf;\n\tsmb_iconv(descriptor, &str, &ilen, &outbuf, &olen);\n\tif (olen == 2) {\n\t\tolen = 4;\n\t\toutbuf = (char *)buf;\n\t\tsmb_iconv(descriptor,  &str, &ilen, &outbuf, &olen);\n\t\tif (olen == 4) {\n\t\t\t/* we didn't convert any bytes */\n\t\t\t*bytes_consumed = 1;\n\t\t\treturn INVALID_CODEPOINT;\n\t\t}\n\t\tolen = 4 - olen;\n\t} else {\n\t\tolen = 2 - olen;\n\t}\n\n\t*bytes_consumed = ilen_orig - ilen;\n\n\tif (olen == 2) {\n\t\treturn (codepoint_t)SVAL(buf, 0);\n\t}\n\tif (olen == 4) {\n\t\t/* decode a 4 byte UTF16 character manually */\n\t\treturn (codepoint_t)0x10000 +\n\t\t\t(buf[2] | ((buf[3] & 0x3)<<8) |\n\t\t\t (buf[0]<<10) | ((buf[1] & 0x3)<<18));\n\t}\n\n\t/* no other length is valid */\n\treturn INVALID_CODEPOINT;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141381,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "_PUBLIC_ codepoint_t next_codepoint_handle_ext(\n\t\t\tstruct smb_iconv_handle *ic,\n\t\t\tconst char *str, size_t len,\n\t\t\tcharset_t src_charset,\n\t\t\tsize_t *bytes_consumed)\n{\n\t/* it cannot occupy more than 4 bytes in UTF16 format */\n\tuint8_t buf[4];\n\tsmb_iconv_t descriptor;\n\tsize_t ilen_orig;\n\tsize_t ilen;\n        size_t olen;\n        char *outbuf;\n \n\n       if (((str[0] & 0x80) == 0) && (src_charset == CH_DOS ||\n                                      src_charset == CH_UNIX ||\n                                      src_charset == CH_UTF8)) {\n                *bytes_consumed = 1;\n                return (codepoint_t)str[0];\n        }\n\t * This is OK as we only support codepoints up to 1M (U+100000)\n\t */\n\tilen_orig = MIN(len, 5);\n\tilen = ilen_orig;\n\n\tdescriptor = get_conv_handle(ic, src_charset, CH_UTF16);\n\tif (descriptor == (smb_iconv_t)-1) {\n\t\t*bytes_consumed = 1;\n\t\treturn INVALID_CODEPOINT;\n\t}\n\n\t/*\n\t * this looks a little strange, but it is needed to cope with\n\t * codepoints above 64k (U+1000) which are encoded as per RFC2781.\n\t */\n\tolen = 2;\n\toutbuf = (char *)buf;\n\tsmb_iconv(descriptor, &str, &ilen, &outbuf, &olen);\n\tif (olen == 2) {\n\t\tolen = 4;\n\t\toutbuf = (char *)buf;\n\t\tsmb_iconv(descriptor,  &str, &ilen, &outbuf, &olen);\n\t\tif (olen == 4) {\n\t\t\t/* we didn't convert any bytes */\n\t\t\t*bytes_consumed = 1;\n\t\t\treturn INVALID_CODEPOINT;\n\t\t}\n\t\tolen = 4 - olen;\n\t} else {\n\t\tolen = 2 - olen;\n\t}\n\n\t*bytes_consumed = ilen_orig - ilen;\n\n\tif (olen == 2) {\n\t\treturn (codepoint_t)SVAL(buf, 0);\n\t}\n\tif (olen == 4) {\n\t\t/* decode a 4 byte UTF16 character manually */\n\t\treturn (codepoint_t)0x10000 +\n\t\t\t(buf[2] | ((buf[3] & 0x3)<<8) |\n\t\t\t (buf[0]<<10) | ((buf[1] & 0x3)<<18));\n\t}\n\n\t/* no other length is valid */\n\treturn INVALID_CODEPOINT;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141382,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": " static int ldb_dn_escape_internal(char *dst, const char *src, int len)\n {\n       const char *p, *s;\n        char *d;\n       size_t l;\n       p = s = src;\n        d = dst;\n \n       while (p - src < len) {\n               p += strcspn(p, \",=\\n\\r+<>#;\\\\\\\" \");\n               if (p - src == len) /* found no escapable chars */\n                       break;\n               /* copy the part of the string before the stop */\n               memcpy(d, s, p - s);\n               d += (p - s); /* move to current position */\n               switch (*p) {\n                case ' ':\n                       if (p == src || (p-src)==(len-1)) {\n                                /* if at the beginning or end\n                                 * of the string then escape */\n                                *d++ = '\\\\';\n                               *d++ = *p++;                                     \n                        } else {\n                                /* otherwise don't escape */\n                               *d++ = *p++;\n                        }\n                        break;\n \n\t\t\t\t/* if at the beginning or end\n\t\t\t\t * of the string then escape */\n\t\t\t\t*d++ = '\\\\';\n\t\t\t\t*d++ = *p++;\t\t\t\t\t \n\t\t\t} else {\n\t\t\t\t/* otherwise don't escape */\n\t\t\t\t*d++ = *p++;\n\t\t\t}\n\t\t\tbreak;\n                case '?':\n                        /* these must be escaped using \\c form */\n                        *d++ = '\\\\';\n                       *d++ = *p++;\n                        break;\n \n               default: {\n                        /* any others get \\XX form */\n                        unsigned char v;\n                        const char *hexbytes = \"0123456789ABCDEF\";\n                       v = *(const unsigned char *)p;\n                        *d++ = '\\\\';\n                        *d++ = hexbytes[v>>4];\n                        *d++ = hexbytes[v&0xF];\n                       p++;\n                        break;\n                }\n                }\n               s = p; /* move forward */\n        }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141383,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": " static int ldb_dn_escape_internal(char *dst, const char *src, int len)\n {\n       char c;\n        char *d;\n       int i;\n        d = dst;\n \n       for (i = 0; i < len; i++){\n               c = src[i];\n               switch (c) {\n                case ' ':\n                       if (i == 0 || i == len - 1) {\n                                /* if at the beginning or end\n                                 * of the string then escape */\n                                *d++ = '\\\\';\n                               *d++ = c;\n                        } else {\n                                /* otherwise don't escape */\n                               *d++ = c;\n                        }\n                        break;\n \n\t\t\t\t/* if at the beginning or end\n\t\t\t\t * of the string then escape */\n\t\t\t\t*d++ = '\\\\';\n\t\t\t\t*d++ = *p++;\t\t\t\t\t \n\t\t\t} else {\n\t\t\t\t/* otherwise don't escape */\n\t\t\t\t*d++ = *p++;\n\t\t\t}\n\t\t\tbreak;\n                case '?':\n                        /* these must be escaped using \\c form */\n                        *d++ = '\\\\';\n                       *d++ = c;\n                        break;\n \n               case ';':\n               case '\\r':\n               case '\\n':\n               case '=':\n               case '\\0': {\n                        /* any others get \\XX form */\n                        unsigned char v;\n                        const char *hexbytes = \"0123456789ABCDEF\";\n                       v = (const unsigned char)c;\n                        *d++ = '\\\\';\n                        *d++ = hexbytes[v>>4];\n                        *d++ = hexbytes[v&0xF];\n                        break;\n                }\n               default:\n                       *d++ = c;\n                }\n        }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141384,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "_PUBLIC_ char *strupper_talloc_n_handle(struct smb_iconv_handle *iconv_handle,\n\t\t\t\t\tTALLOC_CTX *ctx, const char *src, size_t n)\n{\n\tsize_t size=0;\n\tchar *dest;\n\n\tif (!src) {\n\t\treturn NULL;\n\t}\n\n\t/* this takes advantage of the fact that upper/lower can't\n\t   change the length of a character by more than 1 byte */\n\tdest = talloc_array(ctx, char, 2*(n+1));\n\tif (dest == NULL) {\n                return NULL;\n        }\n \n       while (n-- && *src) {\n                size_t c_size;\n                codepoint_t c = next_codepoint_handle_ext(iconv_handle, src, n,\n                                                          CH_UNIX, &c_size);\n                src += c_size;\n \n                c = toupper_m(c);\n\t\tif (c_size == -1) {\n\t\t\ttalloc_free(dest);\n\t\t\treturn NULL;\n\t\t}\n\t\tsize += c_size;\n\t}\n\n\tdest[size] = 0;\n\n\t/* trim it so talloc_append_string() works */\n\tdest = talloc_realloc(ctx, dest, char, size+1);\n\n\ttalloc_set_name_const(dest, dest);\n\n\treturn dest;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141385,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "_PUBLIC_ char *strupper_talloc_n_handle(struct smb_iconv_handle *iconv_handle,\n\t\t\t\t\tTALLOC_CTX *ctx, const char *src, size_t n)\n{\n\tsize_t size=0;\n\tchar *dest;\n\n\tif (!src) {\n\t\treturn NULL;\n\t}\n\n\t/* this takes advantage of the fact that upper/lower can't\n\t   change the length of a character by more than 1 byte */\n\tdest = talloc_array(ctx, char, 2*(n+1));\n\tif (dest == NULL) {\n                return NULL;\n        }\n \n       while (n && *src) {\n                size_t c_size;\n                codepoint_t c = next_codepoint_handle_ext(iconv_handle, src, n,\n                                                          CH_UNIX, &c_size);\n                src += c_size;\n               n -= c_size;\n \n                c = toupper_m(c);\n\t\tif (c_size == -1) {\n\t\t\ttalloc_free(dest);\n\t\t\treturn NULL;\n\t\t}\n\t\tsize += c_size;\n\t}\n\n\tdest[size] = 0;\n\n\t/* trim it so talloc_append_string() works */\n\tdest = talloc_realloc(ctx, dest, char, size+1);\n\n\ttalloc_set_name_const(dest, dest);\n\n\treturn dest;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141386,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static bool ldb_dn_explode(struct ldb_dn *dn)\n{\n\tchar *p, *ex_name = NULL, *ex_value = NULL, *data, *d, *dt, *t;\n\tbool trim = true;\n\tbool in_extended = true;\n\tbool in_ex_name = false;\n\tbool in_ex_value = false;\n\tbool in_attr = false;\n\tbool in_value = false;\n\tbool in_quote = false;\n\tbool is_oid = false;\n\tbool escape = false;\n\tunsigned int x;\n\tsize_t l = 0;\n\tint ret;\n\tchar *parse_dn;\n\tbool is_index;\n\n\tif ( ! dn || dn->invalid) return false;\n\n\tif (dn->components) {\n\t\treturn true;\n\t}\n\n\tif (dn->ext_linearized) {\n\t\tparse_dn = dn->ext_linearized;\n\t} else {\n\t\tparse_dn = dn->linearized;\n\t}\n\n\tif ( ! parse_dn ) {\n\t\treturn false;\n\t}\n\n\tis_index = (strncmp(parse_dn, \"DN=@INDEX:\", 10) == 0);\n\n\t/* Empty DNs */\n\tif (parse_dn[0] == '\\0') {\n\t\treturn true;\n\t}\n\n\t/* Special DNs case */\n\tif (dn->special) {\n\t\treturn true;\n\t}\n\n\t/* make sure we free this if allocated previously before replacing */\n\tLDB_FREE(dn->components);\n\tdn->comp_num = 0;\n\n\tLDB_FREE(dn->ext_components);\n\tdn->ext_comp_num = 0;\n\n\t/* in the common case we have 3 or more components */\n\t/* make sure all components are zeroed, other functions depend on it */\n\tdn->components = talloc_zero_array(dn, struct ldb_dn_component, 3);\n\tif ( ! dn->components) {\n\t\treturn false;\n\t}\n\n\t/* Components data space is allocated here once */\n\tdata = talloc_array(dn->components, char, strlen(parse_dn) + 1);\n\tif (!data) {\n\t\treturn false;\n\t}\n\n\tp = parse_dn;\n\tt = NULL;\n\td = dt = data;\n\n\twhile (*p) {\n\t\tif (in_extended) {\n\n\t\t\tif (!in_ex_name && !in_ex_value) {\n\n\t\t\t\tif (p[0] == '<') {\n\t\t\t\t\tp++;\n\t\t\t\t\tex_name = d;\n\t\t\t\t\tin_ex_name = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (p[0] == '\\0') {\n\t\t\t\t\tp++;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tin_extended = false;\n\t\t\t\t\tin_attr = true;\n\t\t\t\t\tdt = d;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (in_ex_name && *p == '=') {\n\t\t\t\t*d++ = '\\0';\n\t\t\t\tp++;\n\t\t\t\tex_value = d;\n\t\t\t\tin_ex_name = false;\n\t\t\t\tin_ex_value = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (in_ex_value && *p == '>') {\n\t\t\t\tconst struct ldb_dn_extended_syntax *ext_syntax;\n\t\t\t\tstruct ldb_val ex_val = {\n\t\t\t\t\t.data = (uint8_t *)ex_value,\n\t\t\t\t\t.length = d - ex_value\n\t\t\t\t};\n\n\t\t\t\t*d++ = '\\0';\n\t\t\t\tp++;\n\t\t\t\tin_ex_value = false;\n\n\t\t\t\t/* Process name and ex_value */\n\n\t\t\t\tdn->ext_components = talloc_realloc(dn,\n\t\t\t\t\t\t\t\t    dn->ext_components,\n\t\t\t\t\t\t\t\t    struct ldb_dn_ext_component,\n\t\t\t\t\t\t\t\t    dn->ext_comp_num + 1);\n\t\t\t\tif ( ! dn->ext_components) {\n\t\t\t\t\t/* ouch ! */\n\t\t\t\t\tgoto failed;\n\t\t\t\t}\n\n\t\t\t\text_syntax = ldb_dn_extended_syntax_by_name(dn->ldb, ex_name);\n\t\t\t\tif (!ext_syntax) {\n\t\t\t\t\t/* We don't know about this type of extended DN */\n\t\t\t\t\tgoto failed;\n\t\t\t\t}\n\n\t\t\t\tdn->ext_components[dn->ext_comp_num].name = talloc_strdup(dn->ext_components, ex_name);\n\t\t\t\tif (!dn->ext_components[dn->ext_comp_num].name) {\n\t\t\t\t\t/* ouch */\n\t\t\t\t\tgoto failed;\n\t\t\t\t}\n\t\t\t\tret = ext_syntax->read_fn(dn->ldb, dn->ext_components,\n\t\t\t\t\t\t\t  &ex_val, &dn->ext_components[dn->ext_comp_num].value);\n\t\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\t\tldb_dn_mark_invalid(dn);\n\t\t\t\t\tgoto failed;\n\t\t\t\t}\n\n\t\t\t\tdn->ext_comp_num++;\n\n\t\t\t\tif (*p == '\\0') {\n\t\t\t\t\t/* We have reached the end (extended component only)! */\n\t\t\t\t\ttalloc_free(data);\n\t\t\t\t\treturn true;\n\n\t\t\t\t} else if (*p == ';') {\n\t\t\t\t\tp++;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tldb_dn_mark_invalid(dn);\n\t\t\t\t\tgoto failed;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t*d++ = *p++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (in_attr) {\n\t\t\tif (trim) {\n\t\t\t\tif (*p == ' ') {\n\t\t\t\t\tp++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/* first char */\n\t\t\t\ttrim = false;\n\n\t\t\t\tif (!isascii(*p)) {\n\t\t\t\t\t/* attr names must be ascii only */\n\t\t\t\t\tldb_dn_mark_invalid(dn);\n\t\t\t\t\tgoto failed;\n\t\t\t\t}\n\n\t\t\t\tif (isdigit(*p)) {\n\t\t\t\t\tis_oid = true;\n\t\t\t\t} else\n\t\t\t\tif ( ! isalpha(*p)) {\n\t\t\t\t\t/* not a digit nor an alpha,\n \t\t\t\t\t * invalid attribute name */\n\t\t\t\t\tldb_dn_mark_invalid(dn);\n\t\t\t\t\tgoto failed;\n\t\t\t\t}\n\n\t\t\t\t/* Copy this character across from parse_dn,\n\t\t\t\t * now we have trimmed out spaces */\n\t\t\t\t*d++ = *p++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (*p == ' ') {\n\t\t\t\tp++;\n\t\t\t\t/* valid only if we are at the end */\n\t\t\t\ttrim = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (trim && (*p != '=')) {\n\t\t\t\t/* spaces/tabs are not allowed */\n\t\t\t\tldb_dn_mark_invalid(dn);\n\t\t\t\tgoto failed;\n\t\t\t}\n\n\t\t\tif (*p == '=') {\n\t\t\t\t/* attribute terminated */\n\t\t\t\tin_attr = false;\n\t\t\t\tin_value = true;\n\t\t\t\ttrim = true;\n\t\t\t\tl = 0;\n\n\t\t\t\t/* Terminate this string in d\n\t\t\t\t * (which is a copy of parse_dn\n\t\t\t\t *  with spaces trimmed) */\n\t\t\t\t*d++ = '\\0';\n\t\t\t\tdn->components[dn->comp_num].name = talloc_strdup(dn->components, dt);\n\t\t\t\tif ( ! dn->components[dn->comp_num].name) {\n\t\t\t\t\t/* ouch */\n\t\t\t\t\tgoto failed;\n\t\t\t\t}\n\n\t\t\t\tdt = d;\n\n\t\t\t\tp++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!isascii(*p)) {\n\t\t\t\t/* attr names must be ascii only */\n\t\t\t\tldb_dn_mark_invalid(dn);\n\t\t\t\tgoto failed;\n\t\t\t}\n\n\t\t\tif (is_oid && ( ! (isdigit(*p) || (*p == '.')))) {\n\t\t\t\t/* not a digit nor a dot,\n\t\t\t\t * invalid attribute oid */\n\t\t\t\tldb_dn_mark_invalid(dn);\n\t\t\t\tgoto failed;\n\t\t\t} else\n\t\t\tif ( ! (isalpha(*p) || isdigit(*p) || (*p == '-'))) {\n\t\t\t\t/* not ALPHA, DIGIT or HYPHEN */\n\t\t\t\tldb_dn_mark_invalid(dn);\n\t\t\t\tgoto failed;\n\t\t\t}\n\n\t\t\t*d++ = *p++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (in_value) {\n\t\t\tif (in_quote) {\n\t\t\t\tif (*p == '\\\"') {\n\t\t\t\t\tif (p[-1] != '\\\\') {\n\t\t\t\t\t\tp++;\n\t\t\t\t\t\tin_quote = false;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t*d++ = *p++;\n\t\t\t\tl++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (trim) {\n\t\t\t\tif (*p == ' ') {\n\t\t\t\t\tp++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/* first char */\n\t\t\t\ttrim = false;\n\n\t\t\t\tif (*p == '\\\"') {\n\t\t\t\t\tin_quote = true;\n\t\t\t\t\tp++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tswitch (*p) {\n\n\t\t\t/* TODO: support ber encoded values\n\t\t\tcase '#':\n\t\t\t*/\n\n\t\t\tcase ',':\n\t\t\t\tif (escape) {\n\t\t\t\t\t*d++ = *p++;\n\t\t\t\t\tl++;\n\t\t\t\t\tescape = false;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* ok found value terminator */\n\n\t\t\t\tif ( t ) {\n\t\t\t\t\t/* trim back */\n\t\t\t\t\td -= (p - t);\n\t\t\t\t\tl -= (p - t);\n\t\t\t\t}\n\n\t\t\t\tin_attr = true;\n\t\t\t\tin_value = false;\n\t\t\t\ttrim = true;\n \n                                p++;\n                                *d++ = '\\0';\n                               dn->components[dn->comp_num].value.data = (uint8_t *)talloc_strdup(dn->components, dt);\n                                dn->components[dn->comp_num].value.length = l;\n                                if ( ! dn->components[dn->comp_num].value.data) {\n                                        /* ouch ! */\n                                        goto failed;\n                                }\n \n                                dt = d;\n \n\t\t\t\t\t\t\t\t\tdn->components,\n\t\t\t\t\t\t\t\t\tstruct ldb_dn_component,\n\t\t\t\t\t\t\t\t\tdn->comp_num + 1);\n\t\t\t\t\tif ( ! dn->components) {\n\t\t\t\t\t\t/* ouch ! */\n\t\t\t\t\t\tgoto failed;\n\t\t\t\t\t}\n\t\t\t\t\t/* make sure all components are zeroed, other functions depend on this */\n\t\t\t\t\tmemset(&dn->components[dn->comp_num], '\\0', sizeof(struct ldb_dn_component));\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\n\t\t\tcase '+':\n\t\t\tcase '=':\n\t\t\t\t/* to main compatibility with earlier\n\t\t\t\tversions of ldb indexing, we have to\n\t\t\t\taccept the base64 encoded binary index\n\t\t\t\tvalues, which contain a '+' or '='\n\t\t\t\twhich should normally be escaped */\n\t\t\t\tif (is_index) {\n\t\t\t\t\tif ( t ) t = NULL;\n\t\t\t\t\t*d++ = *p++;\n\t\t\t\t\tl++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* fall through */\n\t\t\tcase '\\\"':\n\t\t\tcase '<':\n\t\t\tcase '>':\n\t\t\tcase ';':\n\t\t\t\t/* a string with not escaped specials is invalid (tested) */\n\t\t\t\tif ( ! escape) {\n\t\t\t\t\tldb_dn_mark_invalid(dn);\n\t\t\t\t\tgoto failed;\n\t\t\t\t}\n\t\t\t\tescape = false;\n\n\t\t\t\t*d++ = *p++;\n\t\t\t\tl++;\n\n\t\t\t\tif ( t ) t = NULL;\n\t\t\t\tbreak;\n\n\t\t\tcase '\\\\':\n\t\t\t\tif ( ! escape) {\n\t\t\t\t\tescape = true;\n\t\t\t\t\tp++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tescape = false;\n\n\t\t\t\t*d++ = *p++;\n\t\t\t\tl++;\n\n\t\t\t\tif ( t ) t = NULL;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tif (escape) {\n\t\t\t\t\tif (isxdigit(p[0]) && isxdigit(p[1])) {\n\t\t\t\t\t\tif (sscanf(p, \"%02x\", &x) != 1) {\n\t\t\t\t\t\t\t/* invalid escaping sequence */\n\t\t\t\t\t\t\tldb_dn_mark_invalid(dn);\n\t\t\t\t\t\t\tgoto failed;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tp += 2;\n\t\t\t\t\t\t*d++ = (unsigned char)x;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t*d++ = *p++;\n\t\t\t\t\t}\n\n\t\t\t\t\tescape = false;\n\t\t\t\t\tl++;\n\t\t\t\t\tif ( t ) t = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (*p == ' ') {\n\t\t\t\t\tif ( ! t) t = p;\n\t\t\t\t} else {\n\t\t\t\t\tif ( t ) t = NULL;\n\t\t\t\t}\n\n\t\t\t\t*d++ = *p++;\n\t\t\t\tl++;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\t}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141387,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static bool ldb_dn_explode(struct ldb_dn *dn)\n{\n\tchar *p, *ex_name = NULL, *ex_value = NULL, *data, *d, *dt, *t;\n\tbool trim = true;\n\tbool in_extended = true;\n\tbool in_ex_name = false;\n\tbool in_ex_value = false;\n\tbool in_attr = false;\n\tbool in_value = false;\n\tbool in_quote = false;\n\tbool is_oid = false;\n\tbool escape = false;\n\tunsigned int x;\n\tsize_t l = 0;\n\tint ret;\n\tchar *parse_dn;\n\tbool is_index;\n\n\tif ( ! dn || dn->invalid) return false;\n\n\tif (dn->components) {\n\t\treturn true;\n\t}\n\n\tif (dn->ext_linearized) {\n\t\tparse_dn = dn->ext_linearized;\n\t} else {\n\t\tparse_dn = dn->linearized;\n\t}\n\n\tif ( ! parse_dn ) {\n\t\treturn false;\n\t}\n\n\tis_index = (strncmp(parse_dn, \"DN=@INDEX:\", 10) == 0);\n\n\t/* Empty DNs */\n\tif (parse_dn[0] == '\\0') {\n\t\treturn true;\n\t}\n\n\t/* Special DNs case */\n\tif (dn->special) {\n\t\treturn true;\n\t}\n\n\t/* make sure we free this if allocated previously before replacing */\n\tLDB_FREE(dn->components);\n\tdn->comp_num = 0;\n\n\tLDB_FREE(dn->ext_components);\n\tdn->ext_comp_num = 0;\n\n\t/* in the common case we have 3 or more components */\n\t/* make sure all components are zeroed, other functions depend on it */\n\tdn->components = talloc_zero_array(dn, struct ldb_dn_component, 3);\n\tif ( ! dn->components) {\n\t\treturn false;\n\t}\n\n\t/* Components data space is allocated here once */\n\tdata = talloc_array(dn->components, char, strlen(parse_dn) + 1);\n\tif (!data) {\n\t\treturn false;\n\t}\n\n\tp = parse_dn;\n\tt = NULL;\n\td = dt = data;\n\n\twhile (*p) {\n\t\tif (in_extended) {\n\n\t\t\tif (!in_ex_name && !in_ex_value) {\n\n\t\t\t\tif (p[0] == '<') {\n\t\t\t\t\tp++;\n\t\t\t\t\tex_name = d;\n\t\t\t\t\tin_ex_name = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (p[0] == '\\0') {\n\t\t\t\t\tp++;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tin_extended = false;\n\t\t\t\t\tin_attr = true;\n\t\t\t\t\tdt = d;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (in_ex_name && *p == '=') {\n\t\t\t\t*d++ = '\\0';\n\t\t\t\tp++;\n\t\t\t\tex_value = d;\n\t\t\t\tin_ex_name = false;\n\t\t\t\tin_ex_value = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (in_ex_value && *p == '>') {\n\t\t\t\tconst struct ldb_dn_extended_syntax *ext_syntax;\n\t\t\t\tstruct ldb_val ex_val = {\n\t\t\t\t\t.data = (uint8_t *)ex_value,\n\t\t\t\t\t.length = d - ex_value\n\t\t\t\t};\n\n\t\t\t\t*d++ = '\\0';\n\t\t\t\tp++;\n\t\t\t\tin_ex_value = false;\n\n\t\t\t\t/* Process name and ex_value */\n\n\t\t\t\tdn->ext_components = talloc_realloc(dn,\n\t\t\t\t\t\t\t\t    dn->ext_components,\n\t\t\t\t\t\t\t\t    struct ldb_dn_ext_component,\n\t\t\t\t\t\t\t\t    dn->ext_comp_num + 1);\n\t\t\t\tif ( ! dn->ext_components) {\n\t\t\t\t\t/* ouch ! */\n\t\t\t\t\tgoto failed;\n\t\t\t\t}\n\n\t\t\t\text_syntax = ldb_dn_extended_syntax_by_name(dn->ldb, ex_name);\n\t\t\t\tif (!ext_syntax) {\n\t\t\t\t\t/* We don't know about this type of extended DN */\n\t\t\t\t\tgoto failed;\n\t\t\t\t}\n\n\t\t\t\tdn->ext_components[dn->ext_comp_num].name = talloc_strdup(dn->ext_components, ex_name);\n\t\t\t\tif (!dn->ext_components[dn->ext_comp_num].name) {\n\t\t\t\t\t/* ouch */\n\t\t\t\t\tgoto failed;\n\t\t\t\t}\n\t\t\t\tret = ext_syntax->read_fn(dn->ldb, dn->ext_components,\n\t\t\t\t\t\t\t  &ex_val, &dn->ext_components[dn->ext_comp_num].value);\n\t\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\t\tldb_dn_mark_invalid(dn);\n\t\t\t\t\tgoto failed;\n\t\t\t\t}\n\n\t\t\t\tdn->ext_comp_num++;\n\n\t\t\t\tif (*p == '\\0') {\n\t\t\t\t\t/* We have reached the end (extended component only)! */\n\t\t\t\t\ttalloc_free(data);\n\t\t\t\t\treturn true;\n\n\t\t\t\t} else if (*p == ';') {\n\t\t\t\t\tp++;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tldb_dn_mark_invalid(dn);\n\t\t\t\t\tgoto failed;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t*d++ = *p++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (in_attr) {\n\t\t\tif (trim) {\n\t\t\t\tif (*p == ' ') {\n\t\t\t\t\tp++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/* first char */\n\t\t\t\ttrim = false;\n\n\t\t\t\tif (!isascii(*p)) {\n\t\t\t\t\t/* attr names must be ascii only */\n\t\t\t\t\tldb_dn_mark_invalid(dn);\n\t\t\t\t\tgoto failed;\n\t\t\t\t}\n\n\t\t\t\tif (isdigit(*p)) {\n\t\t\t\t\tis_oid = true;\n\t\t\t\t} else\n\t\t\t\tif ( ! isalpha(*p)) {\n\t\t\t\t\t/* not a digit nor an alpha,\n \t\t\t\t\t * invalid attribute name */\n\t\t\t\t\tldb_dn_mark_invalid(dn);\n\t\t\t\t\tgoto failed;\n\t\t\t\t}\n\n\t\t\t\t/* Copy this character across from parse_dn,\n\t\t\t\t * now we have trimmed out spaces */\n\t\t\t\t*d++ = *p++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (*p == ' ') {\n\t\t\t\tp++;\n\t\t\t\t/* valid only if we are at the end */\n\t\t\t\ttrim = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (trim && (*p != '=')) {\n\t\t\t\t/* spaces/tabs are not allowed */\n\t\t\t\tldb_dn_mark_invalid(dn);\n\t\t\t\tgoto failed;\n\t\t\t}\n\n\t\t\tif (*p == '=') {\n\t\t\t\t/* attribute terminated */\n\t\t\t\tin_attr = false;\n\t\t\t\tin_value = true;\n\t\t\t\ttrim = true;\n\t\t\t\tl = 0;\n\n\t\t\t\t/* Terminate this string in d\n\t\t\t\t * (which is a copy of parse_dn\n\t\t\t\t *  with spaces trimmed) */\n\t\t\t\t*d++ = '\\0';\n\t\t\t\tdn->components[dn->comp_num].name = talloc_strdup(dn->components, dt);\n\t\t\t\tif ( ! dn->components[dn->comp_num].name) {\n\t\t\t\t\t/* ouch */\n\t\t\t\t\tgoto failed;\n\t\t\t\t}\n\n\t\t\t\tdt = d;\n\n\t\t\t\tp++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!isascii(*p)) {\n\t\t\t\t/* attr names must be ascii only */\n\t\t\t\tldb_dn_mark_invalid(dn);\n\t\t\t\tgoto failed;\n\t\t\t}\n\n\t\t\tif (is_oid && ( ! (isdigit(*p) || (*p == '.')))) {\n\t\t\t\t/* not a digit nor a dot,\n\t\t\t\t * invalid attribute oid */\n\t\t\t\tldb_dn_mark_invalid(dn);\n\t\t\t\tgoto failed;\n\t\t\t} else\n\t\t\tif ( ! (isalpha(*p) || isdigit(*p) || (*p == '-'))) {\n\t\t\t\t/* not ALPHA, DIGIT or HYPHEN */\n\t\t\t\tldb_dn_mark_invalid(dn);\n\t\t\t\tgoto failed;\n\t\t\t}\n\n\t\t\t*d++ = *p++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (in_value) {\n\t\t\tif (in_quote) {\n\t\t\t\tif (*p == '\\\"') {\n\t\t\t\t\tif (p[-1] != '\\\\') {\n\t\t\t\t\t\tp++;\n\t\t\t\t\t\tin_quote = false;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t*d++ = *p++;\n\t\t\t\tl++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (trim) {\n\t\t\t\tif (*p == ' ') {\n\t\t\t\t\tp++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/* first char */\n\t\t\t\ttrim = false;\n\n\t\t\t\tif (*p == '\\\"') {\n\t\t\t\t\tin_quote = true;\n\t\t\t\t\tp++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tswitch (*p) {\n\n\t\t\t/* TODO: support ber encoded values\n\t\t\tcase '#':\n\t\t\t*/\n\n\t\t\tcase ',':\n\t\t\t\tif (escape) {\n\t\t\t\t\t*d++ = *p++;\n\t\t\t\t\tl++;\n\t\t\t\t\tescape = false;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* ok found value terminator */\n\n\t\t\t\tif ( t ) {\n\t\t\t\t\t/* trim back */\n\t\t\t\t\td -= (p - t);\n\t\t\t\t\tl -= (p - t);\n\t\t\t\t}\n\n\t\t\t\tin_attr = true;\n\t\t\t\tin_value = false;\n\t\t\t\ttrim = true;\n \n                                p++;\n                                *d++ = '\\0';\n                               dn->components[dn->comp_num].value.data = \\\n                                       (uint8_t *)talloc_memdup(dn->components, dt, l + 1);\n                                dn->components[dn->comp_num].value.length = l;\n                                if ( ! dn->components[dn->comp_num].value.data) {\n                                        /* ouch ! */\n                                        goto failed;\n                                }\n                               talloc_set_name_const(dn->components[dn->comp_num].value.data,\n                                                     (const char *)dn->components[dn->comp_num].value.data);\n \n                                dt = d;\n \n\t\t\t\t\t\t\t\t\tdn->components,\n\t\t\t\t\t\t\t\t\tstruct ldb_dn_component,\n\t\t\t\t\t\t\t\t\tdn->comp_num + 1);\n\t\t\t\t\tif ( ! dn->components) {\n\t\t\t\t\t\t/* ouch ! */\n\t\t\t\t\t\tgoto failed;\n\t\t\t\t\t}\n\t\t\t\t\t/* make sure all components are zeroed, other functions depend on this */\n\t\t\t\t\tmemset(&dn->components[dn->comp_num], '\\0', sizeof(struct ldb_dn_component));\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\n\t\t\tcase '+':\n\t\t\tcase '=':\n\t\t\t\t/* to main compatibility with earlier\n\t\t\t\tversions of ldb indexing, we have to\n\t\t\t\taccept the base64 encoded binary index\n\t\t\t\tvalues, which contain a '+' or '='\n\t\t\t\twhich should normally be escaped */\n\t\t\t\tif (is_index) {\n\t\t\t\t\tif ( t ) t = NULL;\n\t\t\t\t\t*d++ = *p++;\n\t\t\t\t\tl++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* fall through */\n\t\t\tcase '\\\"':\n\t\t\tcase '<':\n\t\t\tcase '>':\n\t\t\tcase ';':\n\t\t\t\t/* a string with not escaped specials is invalid (tested) */\n\t\t\t\tif ( ! escape) {\n\t\t\t\t\tldb_dn_mark_invalid(dn);\n\t\t\t\t\tgoto failed;\n\t\t\t\t}\n\t\t\t\tescape = false;\n\n\t\t\t\t*d++ = *p++;\n\t\t\t\tl++;\n\n\t\t\t\tif ( t ) t = NULL;\n\t\t\t\tbreak;\n\n\t\t\tcase '\\\\':\n\t\t\t\tif ( ! escape) {\n\t\t\t\t\tescape = true;\n\t\t\t\t\tp++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tescape = false;\n\n\t\t\t\t*d++ = *p++;\n\t\t\t\tl++;\n\n\t\t\t\tif ( t ) t = NULL;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tif (escape) {\n\t\t\t\t\tif (isxdigit(p[0]) && isxdigit(p[1])) {\n\t\t\t\t\t\tif (sscanf(p, \"%02x\", &x) != 1) {\n\t\t\t\t\t\t\t/* invalid escaping sequence */\n\t\t\t\t\t\t\tldb_dn_mark_invalid(dn);\n\t\t\t\t\t\t\tgoto failed;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tp += 2;\n\t\t\t\t\t\t*d++ = (unsigned char)x;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t*d++ = *p++;\n\t\t\t\t\t}\n\n\t\t\t\t\tescape = false;\n\t\t\t\t\tl++;\n\t\t\t\t\tif ( t ) t = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (*p == ' ') {\n\t\t\t\t\tif ( ! t) t = p;\n\t\t\t\t} else {\n\t\t\t\t\tif ( t ) t = NULL;\n\t\t\t\t}\n\n\t\t\t\t*d++ = *p++;\n\t\t\t\tl++;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\t}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141388,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "destroy_one_secret (gpointer data)\n{\n \tchar *secret = (char *) data;\n \n \t/* Don't leave the secret lying around in memory */\ng_message (\"%s: destroying %s\", __func__, secret);\n \tmemset (secret, 0, strlen (secret));\n \tg_free (secret);\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141399,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "destroy_one_secret (gpointer data)\n{\n \tchar *secret = (char *) data;\n \n \t/* Don't leave the secret lying around in memory */\n \tmemset (secret, 0, strlen (secret));\n \tg_free (secret);\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141400,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "int ASN1_item_ex_d2i(ASN1_VALUE **pval, const unsigned char **in, long len,\n                     const ASN1_ITEM *it,\n                     int tag, int aclass, char opt, ASN1_TLC *ctx)\n{\n    const ASN1_TEMPLATE *tt, *errtt = NULL;\n    const ASN1_COMPAT_FUNCS *cf;\n    const ASN1_EXTERN_FUNCS *ef;\n    const ASN1_AUX *aux = it->funcs;\n    ASN1_aux_cb *asn1_cb;\n    const unsigned char *p = NULL, *q;\n    unsigned char *wp = NULL;   /* BIG FAT WARNING! BREAKS CONST WHERE USED */\n    unsigned char imphack = 0, oclass;\n    char seq_eoc, seq_nolen, cst, isopt;\n    long tmplen;\n    int i;\n     int otag;\n     int ret = 0;\n     ASN1_VALUE **pchptr, *ptmpval;\n     if (!pval)\n         return 0;\n     if (aux && aux->asn1_cb)\n        asn1_cb = 0;\n\n    switch (it->itype) {\n    case ASN1_ITYPE_PRIMITIVE:\n        if (it->templates) {\n            /*\n             * tagging or OPTIONAL is currently illegal on an item template\n             * because the flags can't get passed down. In practice this\n             * isn't a problem: we include the relevant flags from the item\n             * template in the template itself.\n             */\n            if ((tag != -1) || opt) {\n                ASN1err(ASN1_F_ASN1_ITEM_EX_D2I,\n                        ASN1_R_ILLEGAL_OPTIONS_ON_ITEM_TEMPLATE);\n                goto err;\n            }\n            return asn1_template_ex_d2i(pval, in, len,\n                                        it->templates, opt, ctx);\n        }\n        return asn1_d2i_ex_primitive(pval, in, len, it,\n                                     tag, aclass, opt, ctx);\n        break;\n\n    case ASN1_ITYPE_MSTRING:\n        p = *in;\n        /* Just read in tag and class */\n        ret = asn1_check_tlen(NULL, &otag, &oclass, NULL, NULL,\n                              &p, len, -1, 0, 1, ctx);\n        if (!ret) {\n            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);\n            goto err;\n        }\n\n        /* Must be UNIVERSAL class */\n        if (oclass != V_ASN1_UNIVERSAL) {\n            /* If OPTIONAL, assume this is OK */\n            if (opt)\n                return -1;\n            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_MSTRING_NOT_UNIVERSAL);\n            goto err;\n        }\n        /* Check tag matches bit map */\n        if (!(ASN1_tag2bit(otag) & it->utype)) {\n            /* If OPTIONAL, assume this is OK */\n            if (opt)\n                return -1;\n            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_MSTRING_WRONG_TAG);\n            goto err;\n        }\n        return asn1_d2i_ex_primitive(pval, in, len, it, otag, 0, 0, ctx);\n\n    case ASN1_ITYPE_EXTERN:\n        /* Use new style d2i */\n        ef = it->funcs;\n        return ef->asn1_ex_d2i(pval, in, len, it, tag, aclass, opt, ctx);\n\n    case ASN1_ITYPE_COMPAT:\n        /* we must resort to old style evil hackery */\n        cf = it->funcs;\n\n        /* If OPTIONAL see if it is there */\n        if (opt) {\n            int exptag;\n            p = *in;\n            if (tag == -1)\n                exptag = it->utype;\n            else\n                exptag = tag;\n            /*\n             * Don't care about anything other than presence of expected tag\n             */\n\n            ret = asn1_check_tlen(NULL, NULL, NULL, NULL, NULL,\n                                  &p, len, exptag, aclass, 1, ctx);\n            if (!ret) {\n                ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);\n                goto err;\n            }\n            if (ret == -1)\n                return -1;\n        }\n\n        /*\n         * This is the old style evil hack IMPLICIT handling: since the\n         * underlying code is expecting a tag and class other than the one\n         * present we change the buffer temporarily then change it back\n         * afterwards. This doesn't and never did work for tags > 30. Yes\n         * this is *horrible* but it is only needed for old style d2i which\n         * will hopefully not be around for much longer. FIXME: should copy\n         * the buffer then modify it so the input buffer can be const: we\n         * should *always* copy because the old style d2i might modify the\n         * buffer.\n         */\n\n        if (tag != -1) {\n            wp = *(unsigned char **)in;\n            imphack = *wp;\n            if (p == NULL) {\n                ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);\n                goto err;\n            }\n            *wp = (unsigned char)((*p & V_ASN1_CONSTRUCTED)\n                                  | it->utype);\n        }\n\n        ptmpval = cf->asn1_d2i(pval, in, len);\n\n        if (tag != -1)\n            *wp = imphack;\n\n        if (ptmpval)\n            return 1;\n\n        ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);\n        goto err;\n\n    case ASN1_ITYPE_CHOICE:\n        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it, NULL))\n            goto auxerr;\n        if (*pval) {\n            /* Free up and zero CHOICE value if initialised */\n            i = asn1_get_choice_selector(pval, it);\n            if ((i >= 0) && (i < it->tcount)) {\n                tt = it->templates + i;\n                pchptr = asn1_get_field_ptr(pval, tt);\n                ASN1_template_free(pchptr, tt);\n                asn1_set_choice_selector(pval, -1, it);\n            }\n        } else if (!ASN1_item_ex_new(pval, it)) {\n            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);\n            goto err;\n        }\n        /* CHOICE type, try each possibility in turn */\n        p = *in;\n        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {\n            pchptr = asn1_get_field_ptr(pval, tt);\n            /*\n             * We mark field as OPTIONAL so its absence can be recognised.\n             */\n            ret = asn1_template_ex_d2i(pchptr, &p, len, tt, 1, ctx);\n            /* If field not present, try the next one */\n            if (ret == -1)\n                continue;\n            /* If positive return, read OK, break loop */\n            if (ret > 0)\n                break;\n            /* Otherwise must be an ASN1 parsing error */\n            errtt = tt;\n            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);\n            goto err;\n        }\n\n        /* Did we fall off the end without reading anything? */\n        if (i == it->tcount) {\n            /* If OPTIONAL, this is OK */\n            if (opt) {\n                /* Free and zero it */\n                ASN1_item_ex_free(pval, it);\n                return -1;\n            }\n            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_NO_MATCHING_CHOICE_TYPE);\n            goto err;\n        }\n\n        asn1_set_choice_selector(pval, i, it);\n        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it, NULL))\n            goto auxerr;\n        *in = p;\n        return 1;\n\n    case ASN1_ITYPE_NDEF_SEQUENCE:\n    case ASN1_ITYPE_SEQUENCE:\n        p = *in;\n        tmplen = len;\n\n        /* If no IMPLICIT tagging set to SEQUENCE, UNIVERSAL */\n        if (tag == -1) {\n            tag = V_ASN1_SEQUENCE;\n            aclass = V_ASN1_UNIVERSAL;\n        }\n        /* Get SEQUENCE length and update len, p */\n        ret = asn1_check_tlen(&len, NULL, NULL, &seq_eoc, &cst,\n                              &p, len, tag, aclass, opt, ctx);\n        if (!ret) {\n            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);\n            goto err;\n        } else if (ret == -1)\n            return -1;\n        if (aux && (aux->flags & ASN1_AFLG_BROKEN)) {\n            len = tmplen - (p - *in);\n            seq_nolen = 1;\n        }\n        /* If indefinite we don't do a length check */\n        else\n            seq_nolen = seq_eoc;\n        if (!cst) {\n            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_SEQUENCE_NOT_CONSTRUCTED);\n            goto err;\n        }\n\n        if (!*pval && !ASN1_item_ex_new(pval, it)) {\n            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);\n            goto err;\n        }\n\n        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it, NULL))\n            goto auxerr;\n\n        /* Free up and zero any ADB found */\n        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {\n            if (tt->flags & ASN1_TFLG_ADB_MASK) {\n                const ASN1_TEMPLATE *seqtt;\n                ASN1_VALUE **pseqval;\n                seqtt = asn1_do_adb(pval, tt, 1);\n                pseqval = asn1_get_field_ptr(pval, seqtt);\n                ASN1_template_free(pseqval, seqtt);\n            }\n        }\n\n        /* Get each field entry */\n        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {\n            const ASN1_TEMPLATE *seqtt;\n            ASN1_VALUE **pseqval;\n            seqtt = asn1_do_adb(pval, tt, 1);\n            if (!seqtt)\n                goto err;\n            pseqval = asn1_get_field_ptr(pval, seqtt);\n            /* Have we ran out of data? */\n            if (!len)\n                break;\n            q = p;\n            if (asn1_check_eoc(&p, len)) {\n                if (!seq_eoc) {\n                    ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_UNEXPECTED_EOC);\n                    goto err;\n                }\n                len -= p - q;\n                seq_eoc = 0;\n                q = p;\n                break;\n            }\n            /*\n             * This determines the OPTIONAL flag value. The field cannot be\n             * omitted if it is the last of a SEQUENCE and there is still\n             * data to be read. This isn't strictly necessary but it\n             * increases efficiency in some cases.\n             */\n            if (i == (it->tcount - 1))\n                isopt = 0;\n            else\n                isopt = (char)(seqtt->flags & ASN1_TFLG_OPTIONAL);\n            /*\n             * attempt to read in field, allowing each to be OPTIONAL\n             */\n\n            ret = asn1_template_ex_d2i(pseqval, &p, len, seqtt, isopt, ctx);\n            if (!ret) {\n                errtt = seqtt;\n                goto err;\n            } else if (ret == -1) {\n                /*\n                 * OPTIONAL component absent. Free and zero the field.\n                 */\n                ASN1_template_free(pseqval, seqtt);\n                continue;\n            }\n            /* Update length */\n            len -= p - q;\n        }\n\n        /* Check for EOC if expecting one */\n        if (seq_eoc && !asn1_check_eoc(&p, len)) {\n            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_MISSING_EOC);\n            goto err;\n        }\n        /* Check all data read */\n        if (!seq_nolen && len) {\n            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_SEQUENCE_LENGTH_MISMATCH);\n            goto err;\n        }\n\n        /*\n         * If we get here we've got no more data in the SEQUENCE, however we\n         * may not have read all fields so check all remaining are OPTIONAL\n         * and clear any that are.\n         */\n        for (; i < it->tcount; tt++, i++) {\n            const ASN1_TEMPLATE *seqtt;\n            seqtt = asn1_do_adb(pval, tt, 1);\n            if (!seqtt)\n                goto err;\n            if (seqtt->flags & ASN1_TFLG_OPTIONAL) {\n                ASN1_VALUE **pseqval;\n                pseqval = asn1_get_field_ptr(pval, seqtt);\n                ASN1_template_free(pseqval, seqtt);\n            } else {\n                errtt = seqtt;\n                ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_FIELD_MISSING);\n                goto err;\n            }\n        }\n        /* Save encoding */\n        if (!asn1_enc_save(pval, *in, p - *in, it))\n            goto auxerr;\n        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it, NULL))\n            goto auxerr;\n        *in = p;\n        return 1;\n\n    default:\n        return 0;\n    }\n auxerr:\n    ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_AUX_ERROR);\n  auxerr:\n     ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_AUX_ERROR);\n  err:\n    ASN1_item_ex_free(pval, it);\n     if (errtt)\n         ERR_add_error_data(4, \"Field=\", errtt->field_name,\n                            \", Type=\", it->sname);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141415,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "int ASN1_item_ex_d2i(ASN1_VALUE **pval, const unsigned char **in, long len,\n                     const ASN1_ITEM *it,\n                     int tag, int aclass, char opt, ASN1_TLC *ctx)\n{\n    const ASN1_TEMPLATE *tt, *errtt = NULL;\n    const ASN1_COMPAT_FUNCS *cf;\n    const ASN1_EXTERN_FUNCS *ef;\n    const ASN1_AUX *aux = it->funcs;\n    ASN1_aux_cb *asn1_cb;\n    const unsigned char *p = NULL, *q;\n    unsigned char *wp = NULL;   /* BIG FAT WARNING! BREAKS CONST WHERE USED */\n    unsigned char imphack = 0, oclass;\n    char seq_eoc, seq_nolen, cst, isopt;\n    long tmplen;\n    int i;\n     int otag;\n     int ret = 0;\n     ASN1_VALUE **pchptr, *ptmpval;\n    int combine = aclass & ASN1_TFLG_COMBINE;\n    aclass &= ~ASN1_TFLG_COMBINE;\n     if (!pval)\n         return 0;\n     if (aux && aux->asn1_cb)\n        asn1_cb = 0;\n\n    switch (it->itype) {\n    case ASN1_ITYPE_PRIMITIVE:\n        if (it->templates) {\n            /*\n             * tagging or OPTIONAL is currently illegal on an item template\n             * because the flags can't get passed down. In practice this\n             * isn't a problem: we include the relevant flags from the item\n             * template in the template itself.\n             */\n            if ((tag != -1) || opt) {\n                ASN1err(ASN1_F_ASN1_ITEM_EX_D2I,\n                        ASN1_R_ILLEGAL_OPTIONS_ON_ITEM_TEMPLATE);\n                goto err;\n            }\n            return asn1_template_ex_d2i(pval, in, len,\n                                        it->templates, opt, ctx);\n        }\n        return asn1_d2i_ex_primitive(pval, in, len, it,\n                                     tag, aclass, opt, ctx);\n        break;\n\n    case ASN1_ITYPE_MSTRING:\n        p = *in;\n        /* Just read in tag and class */\n        ret = asn1_check_tlen(NULL, &otag, &oclass, NULL, NULL,\n                              &p, len, -1, 0, 1, ctx);\n        if (!ret) {\n            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);\n            goto err;\n        }\n\n        /* Must be UNIVERSAL class */\n        if (oclass != V_ASN1_UNIVERSAL) {\n            /* If OPTIONAL, assume this is OK */\n            if (opt)\n                return -1;\n            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_MSTRING_NOT_UNIVERSAL);\n            goto err;\n        }\n        /* Check tag matches bit map */\n        if (!(ASN1_tag2bit(otag) & it->utype)) {\n            /* If OPTIONAL, assume this is OK */\n            if (opt)\n                return -1;\n            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_MSTRING_WRONG_TAG);\n            goto err;\n        }\n        return asn1_d2i_ex_primitive(pval, in, len, it, otag, 0, 0, ctx);\n\n    case ASN1_ITYPE_EXTERN:\n        /* Use new style d2i */\n        ef = it->funcs;\n        return ef->asn1_ex_d2i(pval, in, len, it, tag, aclass, opt, ctx);\n\n    case ASN1_ITYPE_COMPAT:\n        /* we must resort to old style evil hackery */\n        cf = it->funcs;\n\n        /* If OPTIONAL see if it is there */\n        if (opt) {\n            int exptag;\n            p = *in;\n            if (tag == -1)\n                exptag = it->utype;\n            else\n                exptag = tag;\n            /*\n             * Don't care about anything other than presence of expected tag\n             */\n\n            ret = asn1_check_tlen(NULL, NULL, NULL, NULL, NULL,\n                                  &p, len, exptag, aclass, 1, ctx);\n            if (!ret) {\n                ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);\n                goto err;\n            }\n            if (ret == -1)\n                return -1;\n        }\n\n        /*\n         * This is the old style evil hack IMPLICIT handling: since the\n         * underlying code is expecting a tag and class other than the one\n         * present we change the buffer temporarily then change it back\n         * afterwards. This doesn't and never did work for tags > 30. Yes\n         * this is *horrible* but it is only needed for old style d2i which\n         * will hopefully not be around for much longer. FIXME: should copy\n         * the buffer then modify it so the input buffer can be const: we\n         * should *always* copy because the old style d2i might modify the\n         * buffer.\n         */\n\n        if (tag != -1) {\n            wp = *(unsigned char **)in;\n            imphack = *wp;\n            if (p == NULL) {\n                ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);\n                goto err;\n            }\n            *wp = (unsigned char)((*p & V_ASN1_CONSTRUCTED)\n                                  | it->utype);\n        }\n\n        ptmpval = cf->asn1_d2i(pval, in, len);\n\n        if (tag != -1)\n            *wp = imphack;\n\n        if (ptmpval)\n            return 1;\n\n        ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);\n        goto err;\n\n    case ASN1_ITYPE_CHOICE:\n        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it, NULL))\n            goto auxerr;\n        if (*pval) {\n            /* Free up and zero CHOICE value if initialised */\n            i = asn1_get_choice_selector(pval, it);\n            if ((i >= 0) && (i < it->tcount)) {\n                tt = it->templates + i;\n                pchptr = asn1_get_field_ptr(pval, tt);\n                ASN1_template_free(pchptr, tt);\n                asn1_set_choice_selector(pval, -1, it);\n            }\n        } else if (!ASN1_item_ex_new(pval, it)) {\n            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);\n            goto err;\n        }\n        /* CHOICE type, try each possibility in turn */\n        p = *in;\n        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {\n            pchptr = asn1_get_field_ptr(pval, tt);\n            /*\n             * We mark field as OPTIONAL so its absence can be recognised.\n             */\n            ret = asn1_template_ex_d2i(pchptr, &p, len, tt, 1, ctx);\n            /* If field not present, try the next one */\n            if (ret == -1)\n                continue;\n            /* If positive return, read OK, break loop */\n            if (ret > 0)\n                break;\n            /* Otherwise must be an ASN1 parsing error */\n            errtt = tt;\n            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);\n            goto err;\n        }\n\n        /* Did we fall off the end without reading anything? */\n        if (i == it->tcount) {\n            /* If OPTIONAL, this is OK */\n            if (opt) {\n                /* Free and zero it */\n                ASN1_item_ex_free(pval, it);\n                return -1;\n            }\n            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_NO_MATCHING_CHOICE_TYPE);\n            goto err;\n        }\n\n        asn1_set_choice_selector(pval, i, it);\n        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it, NULL))\n            goto auxerr;\n        *in = p;\n        return 1;\n\n    case ASN1_ITYPE_NDEF_SEQUENCE:\n    case ASN1_ITYPE_SEQUENCE:\n        p = *in;\n        tmplen = len;\n\n        /* If no IMPLICIT tagging set to SEQUENCE, UNIVERSAL */\n        if (tag == -1) {\n            tag = V_ASN1_SEQUENCE;\n            aclass = V_ASN1_UNIVERSAL;\n        }\n        /* Get SEQUENCE length and update len, p */\n        ret = asn1_check_tlen(&len, NULL, NULL, &seq_eoc, &cst,\n                              &p, len, tag, aclass, opt, ctx);\n        if (!ret) {\n            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);\n            goto err;\n        } else if (ret == -1)\n            return -1;\n        if (aux && (aux->flags & ASN1_AFLG_BROKEN)) {\n            len = tmplen - (p - *in);\n            seq_nolen = 1;\n        }\n        /* If indefinite we don't do a length check */\n        else\n            seq_nolen = seq_eoc;\n        if (!cst) {\n            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_SEQUENCE_NOT_CONSTRUCTED);\n            goto err;\n        }\n\n        if (!*pval && !ASN1_item_ex_new(pval, it)) {\n            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);\n            goto err;\n        }\n\n        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it, NULL))\n            goto auxerr;\n\n        /* Free up and zero any ADB found */\n        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {\n            if (tt->flags & ASN1_TFLG_ADB_MASK) {\n                const ASN1_TEMPLATE *seqtt;\n                ASN1_VALUE **pseqval;\n                seqtt = asn1_do_adb(pval, tt, 1);\n                pseqval = asn1_get_field_ptr(pval, seqtt);\n                ASN1_template_free(pseqval, seqtt);\n            }\n        }\n\n        /* Get each field entry */\n        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {\n            const ASN1_TEMPLATE *seqtt;\n            ASN1_VALUE **pseqval;\n            seqtt = asn1_do_adb(pval, tt, 1);\n            if (!seqtt)\n                goto err;\n            pseqval = asn1_get_field_ptr(pval, seqtt);\n            /* Have we ran out of data? */\n            if (!len)\n                break;\n            q = p;\n            if (asn1_check_eoc(&p, len)) {\n                if (!seq_eoc) {\n                    ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_UNEXPECTED_EOC);\n                    goto err;\n                }\n                len -= p - q;\n                seq_eoc = 0;\n                q = p;\n                break;\n            }\n            /*\n             * This determines the OPTIONAL flag value. The field cannot be\n             * omitted if it is the last of a SEQUENCE and there is still\n             * data to be read. This isn't strictly necessary but it\n             * increases efficiency in some cases.\n             */\n            if (i == (it->tcount - 1))\n                isopt = 0;\n            else\n                isopt = (char)(seqtt->flags & ASN1_TFLG_OPTIONAL);\n            /*\n             * attempt to read in field, allowing each to be OPTIONAL\n             */\n\n            ret = asn1_template_ex_d2i(pseqval, &p, len, seqtt, isopt, ctx);\n            if (!ret) {\n                errtt = seqtt;\n                goto err;\n            } else if (ret == -1) {\n                /*\n                 * OPTIONAL component absent. Free and zero the field.\n                 */\n                ASN1_template_free(pseqval, seqtt);\n                continue;\n            }\n            /* Update length */\n            len -= p - q;\n        }\n\n        /* Check for EOC if expecting one */\n        if (seq_eoc && !asn1_check_eoc(&p, len)) {\n            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_MISSING_EOC);\n            goto err;\n        }\n        /* Check all data read */\n        if (!seq_nolen && len) {\n            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_SEQUENCE_LENGTH_MISMATCH);\n            goto err;\n        }\n\n        /*\n         * If we get here we've got no more data in the SEQUENCE, however we\n         * may not have read all fields so check all remaining are OPTIONAL\n         * and clear any that are.\n         */\n        for (; i < it->tcount; tt++, i++) {\n            const ASN1_TEMPLATE *seqtt;\n            seqtt = asn1_do_adb(pval, tt, 1);\n            if (!seqtt)\n                goto err;\n            if (seqtt->flags & ASN1_TFLG_OPTIONAL) {\n                ASN1_VALUE **pseqval;\n                pseqval = asn1_get_field_ptr(pval, seqtt);\n                ASN1_template_free(pseqval, seqtt);\n            } else {\n                errtt = seqtt;\n                ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_FIELD_MISSING);\n                goto err;\n            }\n        }\n        /* Save encoding */\n        if (!asn1_enc_save(pval, *in, p - *in, it))\n            goto auxerr;\n        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it, NULL))\n            goto auxerr;\n        *in = p;\n        return 1;\n\n    default:\n        return 0;\n    }\n auxerr:\n    ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_AUX_ERROR);\n  auxerr:\n     ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_AUX_ERROR);\n  err:\n    if (combine == 0)\n        ASN1_item_ex_free(pval, it);\n     if (errtt)\n         ERR_add_error_data(4, \"Field=\", errtt->field_name,\n                            \", Type=\", it->sname);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141416,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "int test_mod_exp(BIO *bp, BN_CTX *ctx)\n{\n    BIGNUM *a, *b, *c, *d, *e;\n    int i;\n\n    a = BN_new();\n    b = BN_new();\n    c = BN_new();\n    d = BN_new();\n    e = BN_new();\n\n    BN_one(a);\n    BN_one(b);\n    BN_zero(c);\n    if (BN_mod_exp(d, a, b, c, ctx)) {\n        fprintf(stderr, \"BN_mod_exp with zero modulus succeeded!\\n\");\n        return 0;\n    }\n\n    BN_bntest_rand(c, 30, 0, 1); /* must be odd for montgomery */\n    for (i = 0; i < num2; i++) {\n        BN_bntest_rand(a, 20 + i * 5, 0, 0);\n        BN_bntest_rand(b, 2 + i, 0, 0);\n\n        if (!BN_mod_exp(d, a, b, c, ctx))\n            return (0);\n\n        if (bp != NULL) {\n            if (!results) {\n                BN_print(bp, a);\n                BIO_puts(bp, \" ^ \");\n                BN_print(bp, b);\n                BIO_puts(bp, \" % \");\n                BN_print(bp, c);\n                BIO_puts(bp, \" - \");\n            }\n            BN_print(bp, d);\n            BIO_puts(bp, \"\\n\");\n        }\n        BN_exp(e, a, b, ctx);\n        BN_sub(e, e, d);\n        BN_div(a, b, e, c, ctx);\n        if (!BN_is_zero(b)) {\n            fprintf(stderr, \"Modulo exponentiation test failed!\\n\");\n             return 0;\n         }\n     }\n     BN_free(a);\n     BN_free(b);\n     BN_free(c);\n    BN_zero(c);\n    if (BN_mod_exp_mont_consttime(d, a, b, c, ctx, NULL)) {\n        fprintf(stderr, \"BN_mod_exp_mont_consttime with zero modulus \"\n                \"succeeded\\n\");\n        return 0;\n    }\n\n    BN_set_word(c, 16);\n    if (BN_mod_exp_mont_consttime(d, a, b, c, ctx, NULL)) {\n        fprintf(stderr, \"BN_mod_exp_mont_consttime with even modulus \"\n                \"succeeded\\n\");\n        return 0;\n    }\n\n    BN_bntest_rand(c, 30, 0, 1); /* must be odd for montgomery */\n    for (i = 0; i < num2; i++) {\n        BN_bntest_rand(a, 20 + i * 5, 0, 0);\n        BN_bntest_rand(b, 2 + i, 0, 0);\n\n        if (!BN_mod_exp_mont_consttime(d, a, b, c, ctx, NULL))\n            return (00);\n\n        if (bp != NULL) {\n            if (!results) {\n                BN_print(bp, a);\n                BIO_puts(bp, \" ^ \");\n                BN_print(bp, b);\n                BIO_puts(bp, \" % \");\n                BN_print(bp, c);\n                BIO_puts(bp, \" - \");\n            }\n            BN_print(bp, d);\n            BIO_puts(bp, \"\\n\");\n        }\n        BN_exp(e, a, b, ctx);\n        BN_sub(e, e, d);\n        BN_div(a, b, e, c, ctx);\n        if (!BN_is_zero(b)) {\n            fprintf(stderr, \"Modulo exponentiation test failed!\\n\");\n            return 0;\n        }\n    }\n    BN_free(a);\n    BN_free(b);\n    BN_free(c);\n    BN_free(d);\n    BN_free(e);\n    return (1);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141421,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "int test_mod_exp(BIO *bp, BN_CTX *ctx)\n{\n    BIGNUM *a, *b, *c, *d, *e;\n    int i;\n\n    a = BN_new();\n    b = BN_new();\n    c = BN_new();\n    d = BN_new();\n    e = BN_new();\n\n    BN_one(a);\n    BN_one(b);\n    BN_zero(c);\n    if (BN_mod_exp(d, a, b, c, ctx)) {\n        fprintf(stderr, \"BN_mod_exp with zero modulus succeeded!\\n\");\n        return 0;\n    }\n\n    BN_bntest_rand(c, 30, 0, 1); /* must be odd for montgomery */\n    for (i = 0; i < num2; i++) {\n        BN_bntest_rand(a, 20 + i * 5, 0, 0);\n        BN_bntest_rand(b, 2 + i, 0, 0);\n\n        if (!BN_mod_exp(d, a, b, c, ctx))\n            return (0);\n\n        if (bp != NULL) {\n            if (!results) {\n                BN_print(bp, a);\n                BIO_puts(bp, \" ^ \");\n                BN_print(bp, b);\n                BIO_puts(bp, \" % \");\n                BN_print(bp, c);\n                BIO_puts(bp, \" - \");\n            }\n            BN_print(bp, d);\n            BIO_puts(bp, \"\\n\");\n        }\n        BN_exp(e, a, b, ctx);\n        BN_sub(e, e, d);\n        BN_div(a, b, e, c, ctx);\n        if (!BN_is_zero(b)) {\n            fprintf(stderr, \"Modulo exponentiation test failed!\\n\");\n             return 0;\n         }\n     }\n\n    /* Regression test for carry propagation bug in sqr8x_reduction */\n    BN_hex2bn(&a, \"050505050505\");\n    BN_hex2bn(&b, \"02\");\n    BN_hex2bn(&c,\n        \"4141414141414141414141274141414141414141414141414141414141414141\"\n        \"4141414141414141414141414141414141414141414141414141414141414141\"\n        \"4141414141414141414141800000000000000000000000000000000000000000\"\n        \"0000000000000000000000000000000000000000000000000000000000000000\"\n        \"0000000000000000000000000000000000000000000000000000000000000000\"\n        \"0000000000000000000000000000000000000000000000000000000001\");\n    BN_mod_exp(d, a, b, c, ctx);\n    BN_mul(e, a, a, ctx);\n    if (BN_cmp(d, e)) {\n        fprintf(stderr, \"BN_mod_exp and BN_mul produce different results!\\n\");\n        return 0;\n    }\n\n     BN_free(a);\n     BN_free(b);\n     BN_free(c);\n    BN_zero(c);\n    if (BN_mod_exp_mont_consttime(d, a, b, c, ctx, NULL)) {\n        fprintf(stderr, \"BN_mod_exp_mont_consttime with zero modulus \"\n                \"succeeded\\n\");\n        return 0;\n    }\n\n    BN_set_word(c, 16);\n    if (BN_mod_exp_mont_consttime(d, a, b, c, ctx, NULL)) {\n        fprintf(stderr, \"BN_mod_exp_mont_consttime with even modulus \"\n                \"succeeded\\n\");\n        return 0;\n    }\n\n    BN_bntest_rand(c, 30, 0, 1); /* must be odd for montgomery */\n    for (i = 0; i < num2; i++) {\n        BN_bntest_rand(a, 20 + i * 5, 0, 0);\n        BN_bntest_rand(b, 2 + i, 0, 0);\n\n        if (!BN_mod_exp_mont_consttime(d, a, b, c, ctx, NULL))\n            return (00);\n\n        if (bp != NULL) {\n            if (!results) {\n                BN_print(bp, a);\n                BIO_puts(bp, \" ^ \");\n                BN_print(bp, b);\n                BIO_puts(bp, \" % \");\n                BN_print(bp, c);\n                BIO_puts(bp, \" - \");\n            }\n            BN_print(bp, d);\n            BIO_puts(bp, \"\\n\");\n        }\n        BN_exp(e, a, b, ctx);\n        BN_sub(e, e, d);\n        BN_div(a, b, e, c, ctx);\n        if (!BN_is_zero(b)) {\n            fprintf(stderr, \"Modulo exponentiation test failed!\\n\");\n            return 0;\n        }\n    }\n    BN_free(a);\n    BN_free(b);\n    BN_free(c);\n    BN_free(d);\n    BN_free(e);\n    return (1);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141422,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "void check_request_for_cacheability(struct stream *s, struct channel *chn)\n{\n\tstruct http_txn *txn = s->txn;\n\tchar *p1, *p2;\n\tchar *cur_ptr, *cur_end, *cur_next;\n\tint pragma_found;\n\tint cc_found;\n\tint cur_idx;\n\n\tif ((txn->flags & (TX_CACHEABLE|TX_CACHE_IGNORE)) == TX_CACHE_IGNORE)\n\t\treturn; /* nothing more to do here */\n\n\tcur_idx = 0;\n\tpragma_found = cc_found = 0;\n\tcur_next = chn->buf->p + hdr_idx_first_pos(&txn->hdr_idx);\n\n\twhile ((cur_idx = txn->hdr_idx.v[cur_idx].next)) {\n\t\tstruct hdr_idx_elem *cur_hdr;\n\t\tint val;\n\n\t\tcur_hdr  = &txn->hdr_idx.v[cur_idx];\n\t\tcur_ptr  = cur_next;\n\t\tcur_end  = cur_ptr + cur_hdr->len;\n\t\tcur_next = cur_end + cur_hdr->cr + 1;\n\n\t\t/* We have one full header between cur_ptr and cur_end, and the\n\t\t * next header starts at cur_next.\n\t\t */\n\n\t\tval = http_header_match2(cur_ptr, cur_end, \"Pragma\", 6);\n\t\tif (val) {\n\t\t\tif ((cur_end - (cur_ptr + val) >= 8) &&\n\t\t\t    strncasecmp(cur_ptr + val, \"no-cache\", 8) == 0) {\n\t\t\t\tpragma_found = 1;\n\t\t\t\tcontinue;\n                        }\n                }\n \n                val = http_header_match2(cur_ptr, cur_end, \"Cache-control\", 13);\n                if (!val)\n                        continue;\n\t\tp2 = p1;\n\t\twhile (p2 < cur_end && *p2 != '=' && *p2 != ',' && !isspace((unsigned char)*p2))\n\t\t\tp2++;\n\n\t\t/* we have a complete value between p1 and p2. We don't check the\n\t\t * values after max-age, max-stale nor min-fresh, we simply don't\n\t\t * use the cache when they're specified.\n\t\t */\n\t\tif (((p2 - p1 == 7) && strncasecmp(p1, \"max-age\",   7) == 0) ||\n\t\t    ((p2 - p1 == 8) && strncasecmp(p1, \"no-cache\",  8) == 0) ||\n\t\t    ((p2 - p1 == 9) && strncasecmp(p1, \"max-stale\", 9) == 0) ||\n\t\t    ((p2 - p1 == 9) && strncasecmp(p1, \"min-fresh\", 9) == 0)) {\n\t\t\ttxn->flags |= TX_CACHE_IGNORE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((p2 - p1 == 8) && strncasecmp(p1, \"no-store\", 8) == 0) {\n\t\t\ttxn->flags &= ~TX_CACHEABLE & ~TX_CACHE_COOK;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\t/* RFC7234#5.4:\n\t *   When the Cache-Control header field is also present and\n\t *   understood in a request, Pragma is ignored.\n\t *   When the Cache-Control header field is not present in a\n\t *   request, caches MUST consider the no-cache request\n\t *   pragma-directive as having the same effect as if\n\t *   \"Cache-Control: no-cache\" were present.\n\t */\n\tif (!cc_found && pragma_found)\n\t\ttxn->flags |= TX_CACHE_IGNORE;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141459,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "void check_request_for_cacheability(struct stream *s, struct channel *chn)\n{\n\tstruct http_txn *txn = s->txn;\n\tchar *p1, *p2;\n\tchar *cur_ptr, *cur_end, *cur_next;\n\tint pragma_found;\n\tint cc_found;\n\tint cur_idx;\n\n\tif ((txn->flags & (TX_CACHEABLE|TX_CACHE_IGNORE)) == TX_CACHE_IGNORE)\n\t\treturn; /* nothing more to do here */\n\n\tcur_idx = 0;\n\tpragma_found = cc_found = 0;\n\tcur_next = chn->buf->p + hdr_idx_first_pos(&txn->hdr_idx);\n\n\twhile ((cur_idx = txn->hdr_idx.v[cur_idx].next)) {\n\t\tstruct hdr_idx_elem *cur_hdr;\n\t\tint val;\n\n\t\tcur_hdr  = &txn->hdr_idx.v[cur_idx];\n\t\tcur_ptr  = cur_next;\n\t\tcur_end  = cur_ptr + cur_hdr->len;\n\t\tcur_next = cur_end + cur_hdr->cr + 1;\n\n\t\t/* We have one full header between cur_ptr and cur_end, and the\n\t\t * next header starts at cur_next.\n\t\t */\n\n\t\tval = http_header_match2(cur_ptr, cur_end, \"Pragma\", 6);\n\t\tif (val) {\n\t\t\tif ((cur_end - (cur_ptr + val) >= 8) &&\n\t\t\t    strncasecmp(cur_ptr + val, \"no-cache\", 8) == 0) {\n\t\t\t\tpragma_found = 1;\n\t\t\t\tcontinue;\n                        }\n                }\n \n               /* Don't use the cache and don't try to store if we found the\n                * Authorization header */\n               val = http_header_match2(cur_ptr, cur_end, \"Authorization\", 13);\n               if (val) {\n                       txn->flags &= ~TX_CACHEABLE & ~TX_CACHE_COOK;\n                       txn->flags |= TX_CACHE_IGNORE;\n                       continue;\n               }\n\n                val = http_header_match2(cur_ptr, cur_end, \"Cache-control\", 13);\n                if (!val)\n                        continue;\n\t\tp2 = p1;\n\t\twhile (p2 < cur_end && *p2 != '=' && *p2 != ',' && !isspace((unsigned char)*p2))\n\t\t\tp2++;\n\n\t\t/* we have a complete value between p1 and p2. We don't check the\n\t\t * values after max-age, max-stale nor min-fresh, we simply don't\n\t\t * use the cache when they're specified.\n\t\t */\n\t\tif (((p2 - p1 == 7) && strncasecmp(p1, \"max-age\",   7) == 0) ||\n\t\t    ((p2 - p1 == 8) && strncasecmp(p1, \"no-cache\",  8) == 0) ||\n\t\t    ((p2 - p1 == 9) && strncasecmp(p1, \"max-stale\", 9) == 0) ||\n\t\t    ((p2 - p1 == 9) && strncasecmp(p1, \"min-fresh\", 9) == 0)) {\n\t\t\ttxn->flags |= TX_CACHE_IGNORE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((p2 - p1 == 8) && strncasecmp(p1, \"no-store\", 8) == 0) {\n\t\t\ttxn->flags &= ~TX_CACHEABLE & ~TX_CACHE_COOK;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\t/* RFC7234#5.4:\n\t *   When the Cache-Control header field is also present and\n\t *   understood in a request, Pragma is ignored.\n\t *   When the Cache-Control header field is not present in a\n\t *   request, caches MUST consider the no-cache request\n\t *   pragma-directive as having the same effect as if\n\t *   \"Cache-Control: no-cache\" were present.\n\t */\n\tif (!cc_found && pragma_found)\n\t\ttxn->flags |= TX_CACHE_IGNORE;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141460,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "uint NotificationsEngine::Notify(const QString &app_name, uint replaces_id,\n                                 const QString &app_icon, const QString &summary, const QString &body,\n                                 const QStringList &actions, const QVariantMap &hints, int timeout)\n{\n    uint partOf = 0;\n    const QString appRealName = hints[QStringLiteral(\"x-kde-appname\")].toString();\n    const QString eventId = hints[QStringLiteral(\"x-kde-eventId\")].toString();\n    const bool skipGrouping = hints[QStringLiteral(\"x-kde-skipGrouping\")].toBool();\n\n    if (!replaces_id && m_activeNotifications.values().contains(app_name + summary) && !skipGrouping && !m_alwaysReplaceAppsList.contains(app_name)) {\n        partOf = m_activeNotifications.key(app_name + summary).midRef(13).toUInt();\n    }\n\n     qDebug() << \"Currrent active notifications:\" << m_activeNotifications;\n     qDebug() << \"Guessing partOf as:\" << partOf;\n     qDebug() << \" New Notification: \" << summary << body << timeout << \"& Part of:\" << partOf;\n    QString _body;\n \n     if (partOf > 0) {\n         const QString source = QStringLiteral(\"notification %1\").arg(partOf);\n         Plasma::DataContainer *container = containerForSource(source);\n         if (container) {\n            _body = container->data()[QStringLiteral(\"body\")].toString();\n            if (_body != body) {\n                _body.append(\"\\n\").append(body);\n            } else {\n                _body = body;\n             }\n \n             replaces_id = partOf;\n            CloseNotification(partOf);\n        }\n    }\n\n    uint id = replaces_id ? replaces_id : m_nextId++;\n\n    if (m_alwaysReplaceAppsList.contains(app_name)) {\n        if (m_notificationsFromReplaceableApp.contains(app_name)) {\n            id = m_notificationsFromReplaceableApp.value(app_name);\n        } else {\n            m_notificationsFromReplaceableApp.insert(app_name, id);\n        }\n    }\n\n    QString appname_str = app_name;\n    if (appname_str.isEmpty()) {\n        appname_str = i18n(\"Unknown Application\");\n    }\n\n    bool isPersistent = timeout == 0;\n\n \n     const int AVERAGE_WORD_LENGTH = 6;\n     const int WORD_PER_MINUTE = 250;\n    int count = summary.length() + body.length();\n \n        timeout = 60000 * count / AVERAGE_WORD_LENGTH / WORD_PER_MINUTE;\n\n        timeout = 2000 + qMax(timeout, 3000);\n    }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141537,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "uint NotificationsEngine::Notify(const QString &app_name, uint replaces_id,\n                                 const QString &app_icon, const QString &summary, const QString &body,\n                                 const QStringList &actions, const QVariantMap &hints, int timeout)\n{\n    uint partOf = 0;\n    const QString appRealName = hints[QStringLiteral(\"x-kde-appname\")].toString();\n    const QString eventId = hints[QStringLiteral(\"x-kde-eventId\")].toString();\n    const bool skipGrouping = hints[QStringLiteral(\"x-kde-skipGrouping\")].toBool();\n\n    if (!replaces_id && m_activeNotifications.values().contains(app_name + summary) && !skipGrouping && !m_alwaysReplaceAppsList.contains(app_name)) {\n        partOf = m_activeNotifications.key(app_name + summary).midRef(13).toUInt();\n    }\n\n     qDebug() << \"Currrent active notifications:\" << m_activeNotifications;\n     qDebug() << \"Guessing partOf as:\" << partOf;\n     qDebug() << \" New Notification: \" << summary << body << timeout << \"& Part of:\" << partOf;\n    QString bodyFinal = NotificationSanitizer::parse(body);\n \n     if (partOf > 0) {\n         const QString source = QStringLiteral(\"notification %1\").arg(partOf);\n         Plasma::DataContainer *container = containerForSource(source);\n         if (container) {\n            const QString previousBody = container->data()[QStringLiteral(\"body\")].toString();\n            if (previousBody != bodyFinal) {\n                // FIXME: This will just append the entire old XML document to another one, leading to:\n                // <?xml><html>old</html><br><?xml><html>new</html>\n                // It works but is not very clean.\n                bodyFinal = previousBody + QStringLiteral(\"<br/>\") + bodyFinal;\n             }\n \n             replaces_id = partOf;\n            CloseNotification(partOf);\n        }\n    }\n\n    uint id = replaces_id ? replaces_id : m_nextId++;\n\n    if (m_alwaysReplaceAppsList.contains(app_name)) {\n        if (m_notificationsFromReplaceableApp.contains(app_name)) {\n            id = m_notificationsFromReplaceableApp.value(app_name);\n        } else {\n            m_notificationsFromReplaceableApp.insert(app_name, id);\n        }\n    }\n\n    QString appname_str = app_name;\n    if (appname_str.isEmpty()) {\n        appname_str = i18n(\"Unknown Application\");\n    }\n\n    bool isPersistent = timeout == 0;\n\n \n     const int AVERAGE_WORD_LENGTH = 6;\n     const int WORD_PER_MINUTE = 250;\n    int count = summary.length() + body.length() - strlen(\"<?xml version=\\\"1.0\\\"><html></html>\");\n \n        timeout = 60000 * count / AVERAGE_WORD_LENGTH / WORD_PER_MINUTE;\n\n        timeout = 2000 + qMax(timeout, 3000);\n    }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141538,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "uint NotificationsEngine::Notify(const QString &app_name, uint replaces_id,\n                                 const QString &app_icon, const QString &summary, const QString &body,\n                                 const QStringList &actions, const QVariantMap &hints, int timeout)\n{\n    uint partOf = 0;\n    const QString appRealName = hints[QStringLiteral(\"x-kde-appname\")].toString();\n    const QString eventId = hints[QStringLiteral(\"x-kde-eventId\")].toString();\n    const bool skipGrouping = hints[QStringLiteral(\"x-kde-skipGrouping\")].toBool();\n\n    if (!replaces_id && m_activeNotifications.values().contains(app_name + summary) && !skipGrouping && !m_alwaysReplaceAppsList.contains(app_name)) {\n        partOf = m_activeNotifications.key(app_name + summary).midRef(13).toUInt();\n    }\n\n    qDebug() << \"Currrent active notifications:\" << m_activeNotifications;\n    qDebug() << \"Guessing partOf as:\" << partOf;\n    qDebug() << \" New Notification: \" << summary << body << timeout << \"& Part of:\" << partOf;\n    QString _body;\n\n    if (partOf > 0) {\n        const QString source = QStringLiteral(\"notification %1\").arg(partOf);\n        Plasma::DataContainer *container = containerForSource(source);\n        if (container) {\n            _body = container->data()[QStringLiteral(\"body\")].toString();\n            if (_body != body) {\n                _body.append(\"\\n\").append(body);\n            } else {\n                _body = body;\n            }\n\n            replaces_id = partOf;\n\n            CloseNotification(partOf);\n        }\n    }\n\n    uint id = replaces_id ? replaces_id : m_nextId++;\n\n    if (m_alwaysReplaceAppsList.contains(app_name)) {\n        if (m_notificationsFromReplaceableApp.contains(app_name)) {\n            id = m_notificationsFromReplaceableApp.value(app_name);\n        } else {\n            m_notificationsFromReplaceableApp.insert(app_name, id);\n        }\n    }\n\n    QString appname_str = app_name;\n    if (appname_str.isEmpty()) {\n        appname_str = i18n(\"Unknown Application\");\n    }\n\n    bool isPersistent = timeout == 0;\n\n    const int AVERAGE_WORD_LENGTH = 6;\n    const int WORD_PER_MINUTE = 250;\n    int count = summary.length() + body.length();\n\n    if (timeout <= 0) {\n        timeout = 60000 * count / AVERAGE_WORD_LENGTH / WORD_PER_MINUTE;\n\n        timeout = 2000 + qMax(timeout, 3000);\n    }\n\n    const QString source = QStringLiteral(\"notification %1\").arg(id);\n     const QString source = QStringLiteral(\"notification %1\").arg(id);\n \n     QString bodyFinal = (partOf == 0 ? body : _body);\n    bodyFinal = bodyFinal.trimmed();\n    bodyFinal = bodyFinal.replace(QLatin1String(\"\\n\"), QLatin1String(\"<br/>\"));\n    bodyFinal = bodyFinal.simplified();\n    bodyFinal.replace(QRegularExpression(QStringLiteral(\"<br/>\\\\s*<br/>(\\\\s|<br/>)*\")), QLatin1String(\"<br/>\"));\n    bodyFinal.replace(QRegularExpression(QStringLiteral(\"&(?!(?:apos|quot|[gl]t|amp);|#)\")), QLatin1String(\"&amp;\"));\n    bodyFinal.replace(QLatin1String(\"&apos;\"), QChar('\\''));\n \n     Plasma::DataEngine::Data notificationData;\n     notificationData.insert(QStringLiteral(\"id\"), QString::number(id));\n    bodyFinal = bodyFinal.simplified();\n    bodyFinal.replace(QRegularExpression(QStringLiteral(\"<br/>\\\\s*<br/>(\\\\s|<br/>)*\")), QLatin1String(\"<br/>\"));\n    bodyFinal.replace(QRegularExpression(QStringLiteral(\"&(?!(?:apos|quot|[gl]t|amp);|#)\")), QLatin1String(\"&amp;\"));\n    bodyFinal.replace(QLatin1String(\"&apos;\"), QChar('\\''));\n\n    Plasma::DataEngine::Data notificationData;\n    notificationData.insert(QStringLiteral(\"id\"), QString::number(id));\n    notificationData.insert(QStringLiteral(\"eventId\"), eventId);\n    notificationData.insert(QStringLiteral(\"appName\"), appname_str);\n    notificationData.insert(QStringLiteral(\"appIcon\"), app_icon);\n    notificationData.insert(QStringLiteral(\"summary\"), summary);\n    notificationData.insert(QStringLiteral(\"body\"), bodyFinal);\n    notificationData.insert(QStringLiteral(\"actions\"), actions);\n    notificationData.insert(QStringLiteral(\"isPersistent\"), isPersistent);\n    notificationData.insert(QStringLiteral(\"expireTimeout\"), timeout);\n\n    bool configurable = false;\n    if (!appRealName.isEmpty()) {\n\n        if (m_configurableApplications.contains(appRealName)) {\n            configurable = m_configurableApplications.value(appRealName);\n        } else {\n            QScopedPointer<KConfig> config(new KConfig(appRealName + QStringLiteral(\".notifyrc\"), KConfig::NoGlobals));\n            config->addConfigSources(QStandardPaths::locateAll(QStandardPaths::GenericDataLocation,\n                                     QStringLiteral(\"knotifications5/\") + appRealName + QStringLiteral(\".notifyrc\")));\n\n            const QRegularExpression regexp(QStringLiteral(\"^Event/([^/]*)$\"));\n            configurable = !config->groupList().filter(regexp).isEmpty();\n            m_configurableApplications.insert(appRealName, configurable);\n        }\n    }\n    notificationData.insert(QStringLiteral(\"appRealName\"), appRealName);\n    notificationData.insert(QStringLiteral(\"configurable\"), configurable);\n\n    QImage image;\n    if (hints.contains(QStringLiteral(\"image-data\"))) {\n        QDBusArgument arg = hints[QStringLiteral(\"image-data\")].value<QDBusArgument>();\n        image = decodeNotificationSpecImageHint(arg);\n    } else if (hints.contains(QStringLiteral(\"image_data\"))) {\n        QDBusArgument arg = hints[QStringLiteral(\"image_data\")].value<QDBusArgument>();\n        image = decodeNotificationSpecImageHint(arg);\n    } else if (hints.contains(QStringLiteral(\"image-path\"))) {\n        QString path = findImageForSpecImagePath(hints[QStringLiteral(\"image-path\")].toString());\n        if (!path.isEmpty()) {\n            image.load(path);\n        }\n    } else if (hints.contains(QStringLiteral(\"image_path\"))) {\n        QString path = findImageForSpecImagePath(hints[QStringLiteral(\"image_path\")].toString());\n        if (!path.isEmpty()) {\n            image.load(path);\n        }\n    } else if (hints.contains(QStringLiteral(\"icon_data\"))) {\n        QDBusArgument arg = hints[QStringLiteral(\"icon_data\")].value<QDBusArgument>();\n        image = decodeNotificationSpecImageHint(arg);\n    }\n    notificationData.insert(QStringLiteral(\"image\"), image.isNull() ? QVariant() : image);\n\n    if (hints.contains(QStringLiteral(\"urgency\"))) {\n        notificationData.insert(QStringLiteral(\"urgency\"), hints[QStringLiteral(\"urgency\")].toInt());\n    }\n\n    setData(source, notificationData);\n\n    m_activeNotifications.insert(source, app_name + summary);\n\n    return id;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141539,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "uint NotificationsEngine::Notify(const QString &app_name, uint replaces_id,\n                                 const QString &app_icon, const QString &summary, const QString &body,\n                                 const QStringList &actions, const QVariantMap &hints, int timeout)\n{\n    uint partOf = 0;\n    const QString appRealName = hints[QStringLiteral(\"x-kde-appname\")].toString();\n    const QString eventId = hints[QStringLiteral(\"x-kde-eventId\")].toString();\n    const bool skipGrouping = hints[QStringLiteral(\"x-kde-skipGrouping\")].toBool();\n\n    if (!replaces_id && m_activeNotifications.values().contains(app_name + summary) && !skipGrouping && !m_alwaysReplaceAppsList.contains(app_name)) {\n        partOf = m_activeNotifications.key(app_name + summary).midRef(13).toUInt();\n    }\n\n    qDebug() << \"Currrent active notifications:\" << m_activeNotifications;\n    qDebug() << \"Guessing partOf as:\" << partOf;\n    qDebug() << \" New Notification: \" << summary << body << timeout << \"& Part of:\" << partOf;\n    QString _body;\n\n    if (partOf > 0) {\n        const QString source = QStringLiteral(\"notification %1\").arg(partOf);\n        Plasma::DataContainer *container = containerForSource(source);\n        if (container) {\n            _body = container->data()[QStringLiteral(\"body\")].toString();\n            if (_body != body) {\n                _body.append(\"\\n\").append(body);\n            } else {\n                _body = body;\n            }\n\n            replaces_id = partOf;\n\n            CloseNotification(partOf);\n        }\n    }\n\n    uint id = replaces_id ? replaces_id : m_nextId++;\n\n    if (m_alwaysReplaceAppsList.contains(app_name)) {\n        if (m_notificationsFromReplaceableApp.contains(app_name)) {\n            id = m_notificationsFromReplaceableApp.value(app_name);\n        } else {\n            m_notificationsFromReplaceableApp.insert(app_name, id);\n        }\n    }\n\n    QString appname_str = app_name;\n    if (appname_str.isEmpty()) {\n        appname_str = i18n(\"Unknown Application\");\n    }\n\n    bool isPersistent = timeout == 0;\n\n    const int AVERAGE_WORD_LENGTH = 6;\n    const int WORD_PER_MINUTE = 250;\n    int count = summary.length() + body.length();\n\n    if (timeout <= 0) {\n        timeout = 60000 * count / AVERAGE_WORD_LENGTH / WORD_PER_MINUTE;\n\n        timeout = 2000 + qMax(timeout, 3000);\n    }\n\n    const QString source = QStringLiteral(\"notification %1\").arg(id);\n     const QString source = QStringLiteral(\"notification %1\").arg(id);\n \n     QString bodyFinal = (partOf == 0 ? body : _body);\n    bodyFinal = NotificationSanitizer::parse(bodyFinal);\n \n     Plasma::DataEngine::Data notificationData;\n     notificationData.insert(QStringLiteral(\"id\"), QString::number(id));\n    bodyFinal = bodyFinal.simplified();\n    bodyFinal.replace(QRegularExpression(QStringLiteral(\"<br/>\\\\s*<br/>(\\\\s|<br/>)*\")), QLatin1String(\"<br/>\"));\n    bodyFinal.replace(QRegularExpression(QStringLiteral(\"&(?!(?:apos|quot|[gl]t|amp);|#)\")), QLatin1String(\"&amp;\"));\n    bodyFinal.replace(QLatin1String(\"&apos;\"), QChar('\\''));\n\n    Plasma::DataEngine::Data notificationData;\n    notificationData.insert(QStringLiteral(\"id\"), QString::number(id));\n    notificationData.insert(QStringLiteral(\"eventId\"), eventId);\n    notificationData.insert(QStringLiteral(\"appName\"), appname_str);\n    notificationData.insert(QStringLiteral(\"appIcon\"), app_icon);\n    notificationData.insert(QStringLiteral(\"summary\"), summary);\n    notificationData.insert(QStringLiteral(\"body\"), bodyFinal);\n    notificationData.insert(QStringLiteral(\"actions\"), actions);\n    notificationData.insert(QStringLiteral(\"isPersistent\"), isPersistent);\n    notificationData.insert(QStringLiteral(\"expireTimeout\"), timeout);\n\n    bool configurable = false;\n    if (!appRealName.isEmpty()) {\n\n        if (m_configurableApplications.contains(appRealName)) {\n            configurable = m_configurableApplications.value(appRealName);\n        } else {\n            QScopedPointer<KConfig> config(new KConfig(appRealName + QStringLiteral(\".notifyrc\"), KConfig::NoGlobals));\n            config->addConfigSources(QStandardPaths::locateAll(QStandardPaths::GenericDataLocation,\n                                     QStringLiteral(\"knotifications5/\") + appRealName + QStringLiteral(\".notifyrc\")));\n\n            const QRegularExpression regexp(QStringLiteral(\"^Event/([^/]*)$\"));\n            configurable = !config->groupList().filter(regexp).isEmpty();\n            m_configurableApplications.insert(appRealName, configurable);\n        }\n    }\n    notificationData.insert(QStringLiteral(\"appRealName\"), appRealName);\n    notificationData.insert(QStringLiteral(\"configurable\"), configurable);\n\n    QImage image;\n    if (hints.contains(QStringLiteral(\"image-data\"))) {\n        QDBusArgument arg = hints[QStringLiteral(\"image-data\")].value<QDBusArgument>();\n        image = decodeNotificationSpecImageHint(arg);\n    } else if (hints.contains(QStringLiteral(\"image_data\"))) {\n        QDBusArgument arg = hints[QStringLiteral(\"image_data\")].value<QDBusArgument>();\n        image = decodeNotificationSpecImageHint(arg);\n    } else if (hints.contains(QStringLiteral(\"image-path\"))) {\n        QString path = findImageForSpecImagePath(hints[QStringLiteral(\"image-path\")].toString());\n        if (!path.isEmpty()) {\n            image.load(path);\n        }\n    } else if (hints.contains(QStringLiteral(\"image_path\"))) {\n        QString path = findImageForSpecImagePath(hints[QStringLiteral(\"image_path\")].toString());\n        if (!path.isEmpty()) {\n            image.load(path);\n        }\n    } else if (hints.contains(QStringLiteral(\"icon_data\"))) {\n        QDBusArgument arg = hints[QStringLiteral(\"icon_data\")].value<QDBusArgument>();\n        image = decodeNotificationSpecImageHint(arg);\n    }\n    notificationData.insert(QStringLiteral(\"image\"), image.isNull() ? QVariant() : image);\n\n    if (hints.contains(QStringLiteral(\"urgency\"))) {\n        notificationData.insert(QStringLiteral(\"urgency\"), hints[QStringLiteral(\"urgency\")].toInt());\n    }\n\n    setData(source, notificationData);\n\n    m_activeNotifications.insert(source, app_name + summary);\n\n    return id;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141540,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "int OBJ_obj2txt(char *buf, int buf_len, const ASN1_OBJECT *a, int no_name)\n{\n\tint i,n=0,len,nid, first, use_bn;\n\tBIGNUM *bl;\n\tunsigned long l;\n        const unsigned char *p;\n        char tbuf[DECIMAL_SIZE(i)+DECIMAL_SIZE(l)+2];\n \n       if ((a == NULL) || (a->data == NULL)) {\n               buf[0]='\\0';\n               return(0);\n       }\n \n \n        if (!no_name && (nid=OBJ_obj2nid(a)) != NID_undef)\n                {\n\t\ts=OBJ_nid2ln(nid);\n\t\tif (s == NULL)\n\t\t\ts=OBJ_nid2sn(nid);\n\t\tif (s)\n\t\t\t{\n\t\t\tif (buf)\n\t\t\t\tBUF_strlcpy(buf,s,buf_len);\n\t\t\tn=strlen(s);\n\t\t\treturn n;\n\t\t\t}\n\t\t}\n\n\n\tlen=a->length;\n\tp=a->data;\n\n\tfirst = 1;\n\tbl = NULL;\n\n\twhile (len > 0)\n\t\t{\n\t\tl=0;\n\t\tuse_bn = 0;\n\t\tfor (;;)\n\t\t\t{\n\t\t\tunsigned char c = *p++;\n\t\t\tlen--;\n\t\t\tif ((len == 0) && (c & 0x80))\n\t\t\t\tgoto err;\n\t\t\tif (use_bn)\n\t\t\t\t{\n\t\t\t\tif (!BN_add_word(bl, c & 0x7f))\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tl |= c  & 0x7f;\n\t\t\tif (!(c & 0x80))\n\t\t\t\tbreak;\n\t\t\tif (!use_bn && (l > (ULONG_MAX >> 7L)))\n\t\t\t\t{\n\t\t\t\tif (!bl && !(bl = BN_new()))\n\t\t\t\t\tgoto err;\n\t\t\t\tif (!BN_set_word(bl, l))\n\t\t\t\t\tgoto err;\n\t\t\t\tuse_bn = 1;\n\t\t\t\t}\n\t\t\tif (use_bn)\n\t\t\t\t{\n\t\t\t\tif (!BN_lshift(bl, bl, 7))\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tl<<=7L;\n\t\t\t}\n\n\t\tif (first)\n\t\t\t{\n\t\t\tfirst = 0;\n\t\t\tif (l >= 80)\n\t\t\t\t{\n\t\t\t\ti = 2;\n\t\t\t\tif (use_bn)\n\t\t\t\t\t{\n\t\t\t\t\tif (!BN_sub_word(bl, 80))\n\t\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tl -= 80;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\ti=(int)(l/40);\n                                i=(int)(l/40);\n                                l-=(long)(i*40);\n                                }\n                       if (buf && (buf_len > 0))\n                                {\n                                *buf++ = i + '0';\n                                buf_len--;\n                                }\n                        n++;\n\t\tif (use_bn)\n\t\t\t{\n\t\t\tchar *bndec;\n\t\t\tbndec = BN_bn2dec(bl);\n\t\t\tif (!bndec)\n\t\t\t\tgoto err;\n\t\t\ti = strlen(bndec);\n\t\t\tif (buf)\n                        i = strlen(bndec);\n                        if (buf)\n                                {\n                               if (buf_len > 0)\n                                        {\n                                        *buf++ = '.';\n                                        buf_len--;\n                                        }\n                                BUF_strlcpy(buf,bndec,buf_len);\n\t\t\t\t\tbuf_len = 0;\n\t\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\tbuf+=i;\n\t\t\t\t\tbuf_len-=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tn++;\n\t\t\tn += i;\n\t\t\tOPENSSL_free(bndec);\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tBIO_snprintf(tbuf,sizeof tbuf,\".%lu\",l);\n\t\t\ti=strlen(tbuf);\n\t\t\tif (buf && (buf_len > 0))\n\t\t\t\t{\n\t\t\t\tBUF_strlcpy(buf,tbuf,buf_len);\n\t\t\t\tif (i > buf_len)\n\t\t\t\t\t{\n\t\t\t\t\tbuf += buf_len;\n\t\t\t\t\tbuf_len = 0;\n\t\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\tbuf+=i;\n\t\t\t\t\tbuf_len-=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tn+=i;\n\t\t\tl=0;\n\t\t\t}\n\t\t}\n\n\tif (bl)\n\t\tBN_free(bl);\n\treturn n;\n\n\terr:\n\tif (bl)\n\t\tBN_free(bl);\n\treturn -1;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141561,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "int OBJ_obj2txt(char *buf, int buf_len, const ASN1_OBJECT *a, int no_name)\n{\n\tint i,n=0,len,nid, first, use_bn;\n\tBIGNUM *bl;\n\tunsigned long l;\n        const unsigned char *p;\n        char tbuf[DECIMAL_SIZE(i)+DECIMAL_SIZE(l)+2];\n \n       /* Ensure that, at every state, |buf| is NUL-terminated. */\n       if (buf && buf_len > 0)\n               buf[0] = '\\0';\n \n       if ((a == NULL) || (a->data == NULL))\n               return(0);\n \n        if (!no_name && (nid=OBJ_obj2nid(a)) != NID_undef)\n                {\n\t\ts=OBJ_nid2ln(nid);\n\t\tif (s == NULL)\n\t\t\ts=OBJ_nid2sn(nid);\n\t\tif (s)\n\t\t\t{\n\t\t\tif (buf)\n\t\t\t\tBUF_strlcpy(buf,s,buf_len);\n\t\t\tn=strlen(s);\n\t\t\treturn n;\n\t\t\t}\n\t\t}\n\n\n\tlen=a->length;\n\tp=a->data;\n\n\tfirst = 1;\n\tbl = NULL;\n\n\twhile (len > 0)\n\t\t{\n\t\tl=0;\n\t\tuse_bn = 0;\n\t\tfor (;;)\n\t\t\t{\n\t\t\tunsigned char c = *p++;\n\t\t\tlen--;\n\t\t\tif ((len == 0) && (c & 0x80))\n\t\t\t\tgoto err;\n\t\t\tif (use_bn)\n\t\t\t\t{\n\t\t\t\tif (!BN_add_word(bl, c & 0x7f))\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tl |= c  & 0x7f;\n\t\t\tif (!(c & 0x80))\n\t\t\t\tbreak;\n\t\t\tif (!use_bn && (l > (ULONG_MAX >> 7L)))\n\t\t\t\t{\n\t\t\t\tif (!bl && !(bl = BN_new()))\n\t\t\t\t\tgoto err;\n\t\t\t\tif (!BN_set_word(bl, l))\n\t\t\t\t\tgoto err;\n\t\t\t\tuse_bn = 1;\n\t\t\t\t}\n\t\t\tif (use_bn)\n\t\t\t\t{\n\t\t\t\tif (!BN_lshift(bl, bl, 7))\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tl<<=7L;\n\t\t\t}\n\n\t\tif (first)\n\t\t\t{\n\t\t\tfirst = 0;\n\t\t\tif (l >= 80)\n\t\t\t\t{\n\t\t\t\ti = 2;\n\t\t\t\tif (use_bn)\n\t\t\t\t\t{\n\t\t\t\t\tif (!BN_sub_word(bl, 80))\n\t\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tl -= 80;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\ti=(int)(l/40);\n                                i=(int)(l/40);\n                                l-=(long)(i*40);\n                                }\n                       if (buf && (buf_len > 1))\n                                {\n                                *buf++ = i + '0';\n                               *buf = '\\0';\n                                buf_len--;\n                                }\n                        n++;\n\t\tif (use_bn)\n\t\t\t{\n\t\t\tchar *bndec;\n\t\t\tbndec = BN_bn2dec(bl);\n\t\t\tif (!bndec)\n\t\t\t\tgoto err;\n\t\t\ti = strlen(bndec);\n\t\t\tif (buf)\n                        i = strlen(bndec);\n                        if (buf)\n                                {\n                               if (buf_len > 1)\n                                        {\n                                        *buf++ = '.';\n                                       *buf = '\\0';\n                                        buf_len--;\n                                        }\n                                BUF_strlcpy(buf,bndec,buf_len);\n\t\t\t\t\tbuf_len = 0;\n\t\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\tbuf+=i;\n\t\t\t\t\tbuf_len-=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tn++;\n\t\t\tn += i;\n\t\t\tOPENSSL_free(bndec);\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tBIO_snprintf(tbuf,sizeof tbuf,\".%lu\",l);\n\t\t\ti=strlen(tbuf);\n\t\t\tif (buf && (buf_len > 0))\n\t\t\t\t{\n\t\t\t\tBUF_strlcpy(buf,tbuf,buf_len);\n\t\t\t\tif (i > buf_len)\n\t\t\t\t\t{\n\t\t\t\t\tbuf += buf_len;\n\t\t\t\t\tbuf_len = 0;\n\t\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\tbuf+=i;\n\t\t\t\t\tbuf_len-=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tn+=i;\n\t\t\tl=0;\n\t\t\t}\n\t\t}\n\n\tif (bl)\n\t\tBN_free(bl);\n\treturn n;\n\n\terr:\n\tif (bl)\n\t\tBN_free(bl);\n\treturn -1;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141562,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "ecc_decrypt_raw (gcry_sexp_t *r_plain, gcry_sexp_t s_data, gcry_sexp_t keyparms)\n{\n  unsigned int nbits;\n  gpg_err_code_t rc;\n  struct pk_encoding_ctx ctx;\n  gcry_sexp_t l1 = NULL;\n  gcry_mpi_t data_e = NULL;\n  ECC_secret_key sk;\n  gcry_mpi_t mpi_g = NULL;\n  char *curvename = NULL;\n  mpi_ec_t ec = NULL;\n  mpi_point_struct kG;\n  mpi_point_struct R;\n  gcry_mpi_t r = NULL;\n  int flags = 0;\n\n  memset (&sk, 0, sizeof sk);\n  point_init (&kG);\n  point_init (&R);\n\n  _gcry_pk_util_init_encoding_ctx (&ctx, PUBKEY_OP_DECRYPT,\n                                   (nbits = ecc_get_nbits (keyparms)));\n\n  /* Look for flags. */\n  l1 = sexp_find_token (keyparms, \"flags\", 0);\n  if (l1)\n    {\n      rc = _gcry_pk_util_parse_flaglist (l1, &flags, NULL);\n      if (rc)\n        goto leave;\n    }\n  sexp_release (l1);\n  l1 = NULL;\n\n  /*\n   * Extract the data.\n   */\n  rc = _gcry_pk_util_preparse_encval (s_data, ecc_names, &l1, &ctx);\n  if (rc)\n    goto leave;\n  rc = sexp_extract_param (l1, NULL, \"e\", &data_e, NULL);\n  if (rc)\n    goto leave;\n  if (DBG_CIPHER)\n    log_printmpi (\"ecc_decrypt  d_e\", data_e);\n  if (mpi_is_opaque (data_e))\n    {\n      rc = GPG_ERR_INV_DATA;\n      goto leave;\n    }\n\n  /*\n   * Extract the key.\n   */\n  rc = sexp_extract_param (keyparms, NULL, \"-p?a?b?g?n?h?+d\",\n                           &sk.E.p, &sk.E.a, &sk.E.b, &mpi_g, &sk.E.n,\n                           &sk.E.h, &sk.d, NULL);\n  if (rc)\n    goto leave;\n  if (mpi_g)\n    {\n      point_init (&sk.E.G);\n      rc = _gcry_ecc_os2ec (&sk.E.G, mpi_g);\n      if (rc)\n        goto leave;\n    }\n  /* Add missing parameters using the optional curve parameter.  */\n  sexp_release (l1);\n  l1 = sexp_find_token (keyparms, \"curve\", 5);\n  if (l1)\n    {\n      curvename = sexp_nth_string (l1, 1);\n      if (curvename)\n        {\n          rc = _gcry_ecc_fill_in_curve (0, curvename, &sk.E, NULL);\n          if (rc)\n            goto leave;\n        }\n    }\n  /* Guess required fields if a curve parameter has not been given.  */\n  if (!curvename)\n    {\n      sk.E.model = MPI_EC_WEIERSTRASS;\n      sk.E.dialect = ECC_DIALECT_STANDARD;\n      if (!sk.E.h)\n\tsk.E.h = mpi_const (MPI_C_ONE);\n    }\n  if (DBG_CIPHER)\n    {\n      log_debug (\"ecc_decrypt info: %s/%s\\n\",\n                 _gcry_ecc_model2str (sk.E.model),\n                 _gcry_ecc_dialect2str (sk.E.dialect));\n      if (sk.E.name)\n        log_debug  (\"ecc_decrypt name: %s\\n\", sk.E.name);\n      log_printmpi (\"ecc_decrypt    p\", sk.E.p);\n      log_printmpi (\"ecc_decrypt    a\", sk.E.a);\n      log_printmpi (\"ecc_decrypt    b\", sk.E.b);\n      log_printpnt (\"ecc_decrypt  g\",   &sk.E.G, NULL);\n      log_printmpi (\"ecc_decrypt    n\", sk.E.n);\n      log_printmpi (\"ecc_decrypt    h\", sk.E.h);\n      if (!fips_mode ())\n        log_printmpi (\"ecc_decrypt    d\", sk.d);\n    }\n  if (!sk.E.p || !sk.E.a || !sk.E.b || !sk.E.G.x || !sk.E.n || !sk.E.h || !sk.d)\n    {\n      rc = GPG_ERR_NO_OBJ;\n      goto leave;\n    }\n\n\n  ec = _gcry_mpi_ec_p_internal_new (sk.E.model, sk.E.dialect, flags,\n                                    sk.E.p, sk.E.a, sk.E.b);\n\n  /*\n   * Compute the plaintext.\n   */\n  if (ec->model == MPI_EC_MONTGOMERY)\n    rc = _gcry_ecc_mont_decodepoint (data_e, ec, &kG);\n  else\n    rc = _gcry_ecc_os2ec (&kG, data_e);\n  if (rc)\n    goto leave;\n\n   if (DBG_CIPHER)\n     log_printpnt (\"ecc_decrypt    kG\", &kG, NULL);\n \n  if (!(flags & PUBKEY_FLAG_DJB_TWEAK)\n       /* For X25519, by its definition, validation should not be done.  */\n      && !_gcry_mpi_ec_curve_point (&kG, ec))\n     {\n       rc = GPG_ERR_INV_DATA;\n       goto leave;\n      y = mpi_new (0);\n\n    if (_gcry_mpi_ec_get_affine (x, y, &R, ec))\n      {\n        rc = GPG_ERR_INV_DATA;\n        goto leave;\n        /*\n         * Note for X25519.\n         *\n         * By the definition of X25519, this is the case where X25519\n         * returns 0, mapping infinity to zero.  However, we\n         * deliberately let it return an error.\n         *\n         * For X25519 ECDH, comming here means that it might be\n         * decrypted by anyone with the shared secret of 0 (the result\n         * of this function could be always 0 by other scalar values,\n         * other than the private key of SK.D).\n         *\n         * So, it looks like an encrypted message but it can be\n         * decrypted by anyone, or at least something wrong\n         * happens.  Recipient should not proceed as if it were\n         * properly encrypted message.\n         *\n         * This handling is needed for our major usage of GnuPG,\n         * where it does the One-Pass Diffie-Hellman method,\n         * C(1, 1, ECC CDH), with an ephemeral key.\n         */\n      }\n\n    if (y)\n      r = _gcry_ecc_ec2os (x, y, sk.E.p);\n    else\n      {\n        unsigned char *rawmpi;\n        unsigned int rawmpilen;\n\n        rawmpi = _gcry_mpi_get_buffer_extra (x, nbits/8, -1,\n                                             &rawmpilen, NULL);\n        if (!rawmpi)\n          {\n            rc = gpg_err_code_from_syserror ();\n            goto leave;\n          }\n        else\n          {\n            rawmpi[0] = 0x40;\n            rawmpilen++;\n            r = mpi_new (0);\n            mpi_set_opaque (r, rawmpi, rawmpilen*8);\n          }\n      }\n    if (!r)\n      rc = gpg_err_code_from_syserror ();\n    else\n      rc = 0;\n    mpi_free (x);\n    mpi_free (y);\n  }\n  if (DBG_CIPHER)\n    log_printmpi (\"ecc_decrypt  res\", r);\n\n  if (!rc)\n    rc = sexp_build (r_plain, NULL, \"(value %m)\", r);\n\n leave:\n  point_free (&R);\n  point_free (&kG);\n  _gcry_mpi_release (r);\n  _gcry_mpi_release (sk.E.p);\n  _gcry_mpi_release (sk.E.a);\n  _gcry_mpi_release (sk.E.b);\n  _gcry_mpi_release (mpi_g);\n  point_free (&sk.E.G);\n  _gcry_mpi_release (sk.E.n);\n  _gcry_mpi_release (sk.E.h);\n  _gcry_mpi_release (sk.d);\n  _gcry_mpi_release (data_e);\n  xfree (curvename);\n  sexp_release (l1);\n  _gcry_mpi_ec_free (ec);\n  _gcry_pk_util_free_encoding_ctx (&ctx);\n  if (DBG_CIPHER)\n    log_debug (\"ecc_decrypt    => %s\\n\", gpg_strerror (rc));\n  return rc;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141575,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "ecc_decrypt_raw (gcry_sexp_t *r_plain, gcry_sexp_t s_data, gcry_sexp_t keyparms)\n{\n  unsigned int nbits;\n  gpg_err_code_t rc;\n  struct pk_encoding_ctx ctx;\n  gcry_sexp_t l1 = NULL;\n  gcry_mpi_t data_e = NULL;\n  ECC_secret_key sk;\n  gcry_mpi_t mpi_g = NULL;\n  char *curvename = NULL;\n  mpi_ec_t ec = NULL;\n  mpi_point_struct kG;\n  mpi_point_struct R;\n  gcry_mpi_t r = NULL;\n  int flags = 0;\n\n  memset (&sk, 0, sizeof sk);\n  point_init (&kG);\n  point_init (&R);\n\n  _gcry_pk_util_init_encoding_ctx (&ctx, PUBKEY_OP_DECRYPT,\n                                   (nbits = ecc_get_nbits (keyparms)));\n\n  /* Look for flags. */\n  l1 = sexp_find_token (keyparms, \"flags\", 0);\n  if (l1)\n    {\n      rc = _gcry_pk_util_parse_flaglist (l1, &flags, NULL);\n      if (rc)\n        goto leave;\n    }\n  sexp_release (l1);\n  l1 = NULL;\n\n  /*\n   * Extract the data.\n   */\n  rc = _gcry_pk_util_preparse_encval (s_data, ecc_names, &l1, &ctx);\n  if (rc)\n    goto leave;\n  rc = sexp_extract_param (l1, NULL, \"e\", &data_e, NULL);\n  if (rc)\n    goto leave;\n  if (DBG_CIPHER)\n    log_printmpi (\"ecc_decrypt  d_e\", data_e);\n  if (mpi_is_opaque (data_e))\n    {\n      rc = GPG_ERR_INV_DATA;\n      goto leave;\n    }\n\n  /*\n   * Extract the key.\n   */\n  rc = sexp_extract_param (keyparms, NULL, \"-p?a?b?g?n?h?+d\",\n                           &sk.E.p, &sk.E.a, &sk.E.b, &mpi_g, &sk.E.n,\n                           &sk.E.h, &sk.d, NULL);\n  if (rc)\n    goto leave;\n  if (mpi_g)\n    {\n      point_init (&sk.E.G);\n      rc = _gcry_ecc_os2ec (&sk.E.G, mpi_g);\n      if (rc)\n        goto leave;\n    }\n  /* Add missing parameters using the optional curve parameter.  */\n  sexp_release (l1);\n  l1 = sexp_find_token (keyparms, \"curve\", 5);\n  if (l1)\n    {\n      curvename = sexp_nth_string (l1, 1);\n      if (curvename)\n        {\n          rc = _gcry_ecc_fill_in_curve (0, curvename, &sk.E, NULL);\n          if (rc)\n            goto leave;\n        }\n    }\n  /* Guess required fields if a curve parameter has not been given.  */\n  if (!curvename)\n    {\n      sk.E.model = MPI_EC_WEIERSTRASS;\n      sk.E.dialect = ECC_DIALECT_STANDARD;\n      if (!sk.E.h)\n\tsk.E.h = mpi_const (MPI_C_ONE);\n    }\n  if (DBG_CIPHER)\n    {\n      log_debug (\"ecc_decrypt info: %s/%s\\n\",\n                 _gcry_ecc_model2str (sk.E.model),\n                 _gcry_ecc_dialect2str (sk.E.dialect));\n      if (sk.E.name)\n        log_debug  (\"ecc_decrypt name: %s\\n\", sk.E.name);\n      log_printmpi (\"ecc_decrypt    p\", sk.E.p);\n      log_printmpi (\"ecc_decrypt    a\", sk.E.a);\n      log_printmpi (\"ecc_decrypt    b\", sk.E.b);\n      log_printpnt (\"ecc_decrypt  g\",   &sk.E.G, NULL);\n      log_printmpi (\"ecc_decrypt    n\", sk.E.n);\n      log_printmpi (\"ecc_decrypt    h\", sk.E.h);\n      if (!fips_mode ())\n        log_printmpi (\"ecc_decrypt    d\", sk.d);\n    }\n  if (!sk.E.p || !sk.E.a || !sk.E.b || !sk.E.G.x || !sk.E.n || !sk.E.h || !sk.d)\n    {\n      rc = GPG_ERR_NO_OBJ;\n      goto leave;\n    }\n\n\n  ec = _gcry_mpi_ec_p_internal_new (sk.E.model, sk.E.dialect, flags,\n                                    sk.E.p, sk.E.a, sk.E.b);\n\n  /*\n   * Compute the plaintext.\n   */\n  if (ec->model == MPI_EC_MONTGOMERY)\n    rc = _gcry_ecc_mont_decodepoint (data_e, ec, &kG);\n  else\n    rc = _gcry_ecc_os2ec (&kG, data_e);\n  if (rc)\n    goto leave;\n\n   if (DBG_CIPHER)\n     log_printpnt (\"ecc_decrypt    kG\", &kG, NULL);\n \n  if ((flags & PUBKEY_FLAG_DJB_TWEAK))\n    {\n       /* For X25519, by its definition, validation should not be done.  */\n      /* (Instead, we do output check.)\n       *\n       * However, to mitigate secret key leak from our implementation,\n       * we also do input validation here.  For constant-time\n       * implementation, we can remove this input validation.\n       */\n      if (_gcry_mpi_ec_bad_point (&kG, ec))\n        {\n          rc = GPG_ERR_INV_DATA;\n          goto leave;\n        }\n    }\n  else if (!_gcry_mpi_ec_curve_point (&kG, ec))\n     {\n       rc = GPG_ERR_INV_DATA;\n       goto leave;\n      y = mpi_new (0);\n\n    if (_gcry_mpi_ec_get_affine (x, y, &R, ec))\n      {\n        rc = GPG_ERR_INV_DATA;\n        goto leave;\n        /*\n         * Note for X25519.\n         *\n         * By the definition of X25519, this is the case where X25519\n         * returns 0, mapping infinity to zero.  However, we\n         * deliberately let it return an error.\n         *\n         * For X25519 ECDH, comming here means that it might be\n         * decrypted by anyone with the shared secret of 0 (the result\n         * of this function could be always 0 by other scalar values,\n         * other than the private key of SK.D).\n         *\n         * So, it looks like an encrypted message but it can be\n         * decrypted by anyone, or at least something wrong\n         * happens.  Recipient should not proceed as if it were\n         * properly encrypted message.\n         *\n         * This handling is needed for our major usage of GnuPG,\n         * where it does the One-Pass Diffie-Hellman method,\n         * C(1, 1, ECC CDH), with an ephemeral key.\n         */\n      }\n\n    if (y)\n      r = _gcry_ecc_ec2os (x, y, sk.E.p);\n    else\n      {\n        unsigned char *rawmpi;\n        unsigned int rawmpilen;\n\n        rawmpi = _gcry_mpi_get_buffer_extra (x, nbits/8, -1,\n                                             &rawmpilen, NULL);\n        if (!rawmpi)\n          {\n            rc = gpg_err_code_from_syserror ();\n            goto leave;\n          }\n        else\n          {\n            rawmpi[0] = 0x40;\n            rawmpilen++;\n            r = mpi_new (0);\n            mpi_set_opaque (r, rawmpi, rawmpilen*8);\n          }\n      }\n    if (!r)\n      rc = gpg_err_code_from_syserror ();\n    else\n      rc = 0;\n    mpi_free (x);\n    mpi_free (y);\n  }\n  if (DBG_CIPHER)\n    log_printmpi (\"ecc_decrypt  res\", r);\n\n  if (!rc)\n    rc = sexp_build (r_plain, NULL, \"(value %m)\", r);\n\n leave:\n  point_free (&R);\n  point_free (&kG);\n  _gcry_mpi_release (r);\n  _gcry_mpi_release (sk.E.p);\n  _gcry_mpi_release (sk.E.a);\n  _gcry_mpi_release (sk.E.b);\n  _gcry_mpi_release (mpi_g);\n  point_free (&sk.E.G);\n  _gcry_mpi_release (sk.E.n);\n  _gcry_mpi_release (sk.E.h);\n  _gcry_mpi_release (sk.d);\n  _gcry_mpi_release (data_e);\n  xfree (curvename);\n  sexp_release (l1);\n  _gcry_mpi_ec_free (ec);\n  _gcry_pk_util_free_encoding_ctx (&ctx);\n  if (DBG_CIPHER)\n    log_debug (\"ecc_decrypt    => %s\\n\", gpg_strerror (rc));\n  return rc;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141576,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": " static int MOD_EXP_CTIME_COPY_TO_PREBUF(const BIGNUM *b, int top,\n                                         unsigned char *buf, int idx,\n                                        int width)\n {\n    size_t i, j;\n \n     if (top > b->top)\n         top = b->top;           /* this works because 'buf' is explicitly\n                                  * zeroed */\n    for (i = 0, j = idx; i < top * sizeof b->d[0]; i++, j += width) {\n        buf[j] = ((unsigned char *)b->d)[i];\n     }\n \n     return 1;\n                                          unsigned char *buf, int idx,\n \n static int MOD_EXP_CTIME_COPY_FROM_PREBUF(BIGNUM *b, int top,\n                                           unsigned char *buf, int idx,\n                                          int width)\n {\n    size_t i, j;\n \n     if (bn_wexpand(b, top) == NULL)\n         return 0;\n \n    for (i = 0, j = idx; i < top * sizeof b->d[0]; i++, j += width) {\n        ((unsigned char *)b->d)[i] = buf[j];\n     }\n \n     b->top = top;\n    if (!BN_is_odd(m)) {\n        BNerr(BN_F_BN_MOD_EXP_MONT_CONSTTIME, BN_R_CALLED_WITH_EVEN_MODULUS);\n        return (0);\n    }\n\n    top = m->top;\n\n    bits = BN_num_bits(p);\n    if (bits == 0) {\n        /* x**0 mod 1 is still zero. */\n        if (BN_is_one(m)) {\n            ret = 1;\n            BN_zero(rr);\n        } else {\n            ret = BN_one(rr);\n        }\n        return ret;\n    }\n\n    BN_CTX_start(ctx);\n\n    /*\n     * Allocate a montgomery context if it was not supplied by the caller. If\n     * this is not done, things will break in the montgomery part.\n     */\n    if (in_mont != NULL)\n        mont = in_mont;\n    else {\n        if ((mont = BN_MONT_CTX_new()) == NULL)\n            goto err;\n        if (!BN_MONT_CTX_set(mont, m, ctx))\n            goto err;\n    }\n\n#ifdef RSAZ_ENABLED\n    /*\n     * If the size of the operands allow it, perform the optimized\n     * RSAZ exponentiation. For further information see\n     * crypto/bn/rsaz_exp.c and accompanying assembly modules.\n     */\n    if ((16 == a->top) && (16 == p->top) && (BN_num_bits(m) == 1024)\n        && rsaz_avx2_eligible()) {\n        if (NULL == bn_wexpand(rr, 16))\n            goto err;\n        RSAZ_1024_mod_exp_avx2(rr->d, a->d, p->d, m->d, mont->RR.d,\n                               mont->n0[0]);\n        rr->top = 16;\n        rr->neg = 0;\n        bn_correct_top(rr);\n        ret = 1;\n        goto err;\n    } else if ((8 == a->top) && (8 == p->top) && (BN_num_bits(m) == 512)) {\n        if (NULL == bn_wexpand(rr, 8))\n            goto err;\n        RSAZ_512_mod_exp(rr->d, a->d, p->d, m->d, mont->n0[0], mont->RR.d);\n        rr->top = 8;\n        rr->neg = 0;\n        bn_correct_top(rr);\n        ret = 1;\n        goto err;\n    }\n#endif\n\n    /* Get the window size to use with size of p. */\n    window = BN_window_bits_for_ctime_exponent_size(bits);\n#if defined(SPARC_T4_MONT)\n    if (window >= 5 && (top & 15) == 0 && top <= 64 &&\n        (OPENSSL_sparcv9cap_P[1] & (CFR_MONTMUL | CFR_MONTSQR)) ==\n        (CFR_MONTMUL | CFR_MONTSQR) && (t4 = OPENSSL_sparcv9cap_P[0]))\n        window = 5;\n    else\n#endif\n#if defined(OPENSSL_BN_ASM_MONT5)\n    if (window >= 5) {\n        window = 5;             /* ~5% improvement for RSA2048 sign, and even\n                                 * for RSA4096 */\n        if ((top & 7) == 0)\n            powerbufLen += 2 * top * sizeof(m->d[0]);\n    }\n#endif\n    (void)0;\n\n    /*\n     * Allocate a buffer large enough to hold all of the pre-computed powers\n     * of am, am itself and tmp.\n     */\n    numPowers = 1 << window;\n    powerbufLen += sizeof(m->d[0]) * (top * numPowers +\n                                      ((2 * top) >\n                                       numPowers ? (2 * top) : numPowers));\n#ifdef alloca\n    if (powerbufLen < 3072)\n        powerbufFree =\n            alloca(powerbufLen + MOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH);\n    else\n#endif\n        if ((powerbufFree =\n             (unsigned char *)OPENSSL_malloc(powerbufLen +\n                                             MOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH))\n            == NULL)\n        goto err;\n\n    powerbuf = MOD_EXP_CTIME_ALIGN(powerbufFree);\n    memset(powerbuf, 0, powerbufLen);\n\n#ifdef alloca\n    if (powerbufLen < 3072)\n        powerbufFree = NULL;\n#endif\n\n    /* lay down tmp and am right after powers table */\n    tmp.d = (BN_ULONG *)(powerbuf + sizeof(m->d[0]) * top * numPowers);\n    am.d = tmp.d + top;\n    tmp.top = am.top = 0;\n    tmp.dmax = am.dmax = top;\n    tmp.neg = am.neg = 0;\n    tmp.flags = am.flags = BN_FLG_STATIC_DATA;\n\n    /* prepare a^0 in Montgomery domain */\n#if 1                           /* by Shay Gueron's suggestion */\n    if (m->d[top - 1] & (((BN_ULONG)1) << (BN_BITS2 - 1))) {\n        /* 2^(top*BN_BITS2) - m */\n        tmp.d[0] = (0 - m->d[0]) & BN_MASK2;\n        for (i = 1; i < top; i++)\n            tmp.d[i] = (~m->d[i]) & BN_MASK2;\n        tmp.top = top;\n    } else\n#endif\n    if (!BN_to_montgomery(&tmp, BN_value_one(), mont, ctx))\n        goto err;\n\n    /* prepare a^1 in Montgomery domain */\n    if (a->neg || BN_ucmp(a, m) >= 0) {\n        if (!BN_mod(&am, a, m, ctx))\n            goto err;\n        if (!BN_to_montgomery(&am, &am, mont, ctx))\n            goto err;\n    } else if (!BN_to_montgomery(&am, a, mont, ctx))\n        goto err;\n\n#if defined(SPARC_T4_MONT)\n    if (t4) {\n        typedef int (*bn_pwr5_mont_f) (BN_ULONG *tp, const BN_ULONG *np,\n                                       const BN_ULONG *n0, const void *table,\n                                       int power, int bits);\n        int bn_pwr5_mont_t4_8(BN_ULONG *tp, const BN_ULONG *np,\n                              const BN_ULONG *n0, const void *table,\n                              int power, int bits);\n        int bn_pwr5_mont_t4_16(BN_ULONG *tp, const BN_ULONG *np,\n                               const BN_ULONG *n0, const void *table,\n                               int power, int bits);\n        int bn_pwr5_mont_t4_24(BN_ULONG *tp, const BN_ULONG *np,\n                               const BN_ULONG *n0, const void *table,\n                               int power, int bits);\n        int bn_pwr5_mont_t4_32(BN_ULONG *tp, const BN_ULONG *np,\n                               const BN_ULONG *n0, const void *table,\n                               int power, int bits);\n        static const bn_pwr5_mont_f pwr5_funcs[4] = {\n            bn_pwr5_mont_t4_8, bn_pwr5_mont_t4_16,\n            bn_pwr5_mont_t4_24, bn_pwr5_mont_t4_32\n        };\n        bn_pwr5_mont_f pwr5_worker = pwr5_funcs[top / 16 - 1];\n\n        typedef int (*bn_mul_mont_f) (BN_ULONG *rp, const BN_ULONG *ap,\n                                      const void *bp, const BN_ULONG *np,\n                                      const BN_ULONG *n0);\n        int bn_mul_mont_t4_8(BN_ULONG *rp, const BN_ULONG *ap, const void *bp,\n                             const BN_ULONG *np, const BN_ULONG *n0);\n        int bn_mul_mont_t4_16(BN_ULONG *rp, const BN_ULONG *ap,\n                              const void *bp, const BN_ULONG *np,\n                              const BN_ULONG *n0);\n        int bn_mul_mont_t4_24(BN_ULONG *rp, const BN_ULONG *ap,\n                              const void *bp, const BN_ULONG *np,\n                              const BN_ULONG *n0);\n        int bn_mul_mont_t4_32(BN_ULONG *rp, const BN_ULONG *ap,\n                              const void *bp, const BN_ULONG *np,\n                              const BN_ULONG *n0);\n        static const bn_mul_mont_f mul_funcs[4] = {\n            bn_mul_mont_t4_8, bn_mul_mont_t4_16,\n            bn_mul_mont_t4_24, bn_mul_mont_t4_32\n        };\n        bn_mul_mont_f mul_worker = mul_funcs[top / 16 - 1];\n\n        void bn_mul_mont_vis3(BN_ULONG *rp, const BN_ULONG *ap,\n                              const void *bp, const BN_ULONG *np,\n                              const BN_ULONG *n0, int num);\n        void bn_mul_mont_t4(BN_ULONG *rp, const BN_ULONG *ap,\n                            const void *bp, const BN_ULONG *np,\n                            const BN_ULONG *n0, int num);\n        void bn_mul_mont_gather5_t4(BN_ULONG *rp, const BN_ULONG *ap,\n                                    const void *table, const BN_ULONG *np,\n                                    const BN_ULONG *n0, int num, int power);\n        void bn_flip_n_scatter5_t4(const BN_ULONG *inp, size_t num,\n                                   void *table, size_t power);\n        void bn_gather5_t4(BN_ULONG *out, size_t num,\n                           void *table, size_t power);\n        void bn_flip_t4(BN_ULONG *dst, BN_ULONG *src, size_t num);\n\n        BN_ULONG *np = mont->N.d, *n0 = mont->n0;\n        int stride = 5 * (6 - (top / 16 - 1)); /* multiple of 5, but less\n                                                * than 32 */\n\n        /*\n         * BN_to_montgomery can contaminate words above .top [in\n         * BN_DEBUG[_DEBUG] build]...\n         */\n        for (i = am.top; i < top; i++)\n            am.d[i] = 0;\n        for (i = tmp.top; i < top; i++)\n            tmp.d[i] = 0;\n\n        bn_flip_n_scatter5_t4(tmp.d, top, powerbuf, 0);\n        bn_flip_n_scatter5_t4(am.d, top, powerbuf, 1);\n        if (!(*mul_worker) (tmp.d, am.d, am.d, np, n0) &&\n            !(*mul_worker) (tmp.d, am.d, am.d, np, n0))\n            bn_mul_mont_vis3(tmp.d, am.d, am.d, np, n0, top);\n        bn_flip_n_scatter5_t4(tmp.d, top, powerbuf, 2);\n\n        for (i = 3; i < 32; i++) {\n            /* Calculate a^i = a^(i-1) * a */\n            if (!(*mul_worker) (tmp.d, tmp.d, am.d, np, n0) &&\n                !(*mul_worker) (tmp.d, tmp.d, am.d, np, n0))\n                bn_mul_mont_vis3(tmp.d, tmp.d, am.d, np, n0, top);\n            bn_flip_n_scatter5_t4(tmp.d, top, powerbuf, i);\n        }\n\n        /* switch to 64-bit domain */\n        np = alloca(top * sizeof(BN_ULONG));\n        top /= 2;\n        bn_flip_t4(np, mont->N.d, top);\n\n        bits--;\n        for (wvalue = 0, i = bits % 5; i >= 0; i--, bits--)\n            wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);\n        bn_gather5_t4(tmp.d, top, powerbuf, wvalue);\n\n        /*\n         * Scan the exponent one window at a time starting from the most\n         * significant bits.\n         */\n        while (bits >= 0) {\n            if (bits < stride)\n                stride = bits + 1;\n            bits -= stride;\n            wvalue = bn_get_bits(p, bits + 1);\n\n            if ((*pwr5_worker) (tmp.d, np, n0, powerbuf, wvalue, stride))\n                continue;\n            /* retry once and fall back */\n            if ((*pwr5_worker) (tmp.d, np, n0, powerbuf, wvalue, stride))\n                continue;\n\n            bits += stride - 5;\n            wvalue >>= stride - 5;\n            wvalue &= 31;\n            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);\n            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);\n            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);\n            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);\n            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);\n            bn_mul_mont_gather5_t4(tmp.d, tmp.d, powerbuf, np, n0, top,\n                                   wvalue);\n        }\n\n        bn_flip_t4(tmp.d, tmp.d, top);\n        top *= 2;\n        /* back to 32-bit domain */\n        tmp.top = top;\n        bn_correct_top(&tmp);\n        OPENSSL_cleanse(np, top * sizeof(BN_ULONG));\n    } else\n#endif\n#if defined(OPENSSL_BN_ASM_MONT5)\n    if (window == 5 && top > 1) {\n        /*\n         * This optimization uses ideas from http://eprint.iacr.org/2011/239,\n         * specifically optimization of cache-timing attack countermeasures\n         * and pre-computation optimization.\n         */\n\n        /*\n         * Dedicated window==4 case improves 512-bit RSA sign by ~15%, but as\n         * 512-bit RSA is hardly relevant, we omit it to spare size...\n         */\n        void bn_mul_mont_gather5(BN_ULONG *rp, const BN_ULONG *ap,\n                                 const void *table, const BN_ULONG *np,\n                                 const BN_ULONG *n0, int num, int power);\n        void bn_scatter5(const BN_ULONG *inp, size_t num,\n                         void *table, size_t power);\n        void bn_gather5(BN_ULONG *out, size_t num, void *table, size_t power);\n        void bn_power5(BN_ULONG *rp, const BN_ULONG *ap,\n                       const void *table, const BN_ULONG *np,\n                       const BN_ULONG *n0, int num, int power);\n        int bn_get_bits5(const BN_ULONG *ap, int off);\n        int bn_from_montgomery(BN_ULONG *rp, const BN_ULONG *ap,\n                               const BN_ULONG *not_used, const BN_ULONG *np,\n                               const BN_ULONG *n0, int num);\n\n        BN_ULONG *np = mont->N.d, *n0 = mont->n0, *np2;\n\n        /*\n         * BN_to_montgomery can contaminate words above .top [in\n         * BN_DEBUG[_DEBUG] build]...\n         */\n        for (i = am.top; i < top; i++)\n            am.d[i] = 0;\n        for (i = tmp.top; i < top; i++)\n            tmp.d[i] = 0;\n\n        if (top & 7)\n            np2 = np;\n        else\n            for (np2 = am.d + top, i = 0; i < top; i++)\n                np2[2 * i] = np[i];\n\n        bn_scatter5(tmp.d, top, powerbuf, 0);\n        bn_scatter5(am.d, am.top, powerbuf, 1);\n        bn_mul_mont(tmp.d, am.d, am.d, np, n0, top);\n        bn_scatter5(tmp.d, top, powerbuf, 2);\n\n# if 0\n        for (i = 3; i < 32; i++) {\n            /* Calculate a^i = a^(i-1) * a */\n            bn_mul_mont_gather5(tmp.d, am.d, powerbuf, np2, n0, top, i - 1);\n            bn_scatter5(tmp.d, top, powerbuf, i);\n        }\n# else\n        /* same as above, but uses squaring for 1/2 of operations */\n        for (i = 4; i < 32; i *= 2) {\n            bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\n            bn_scatter5(tmp.d, top, powerbuf, i);\n        }\n        for (i = 3; i < 8; i += 2) {\n            int j;\n            bn_mul_mont_gather5(tmp.d, am.d, powerbuf, np2, n0, top, i - 1);\n            bn_scatter5(tmp.d, top, powerbuf, i);\n            for (j = 2 * i; j < 32; j *= 2) {\n                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\n                bn_scatter5(tmp.d, top, powerbuf, j);\n            }\n        }\n        for (; i < 16; i += 2) {\n            bn_mul_mont_gather5(tmp.d, am.d, powerbuf, np2, n0, top, i - 1);\n            bn_scatter5(tmp.d, top, powerbuf, i);\n            bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\n            bn_scatter5(tmp.d, top, powerbuf, 2 * i);\n        }\n        for (; i < 32; i += 2) {\n            bn_mul_mont_gather5(tmp.d, am.d, powerbuf, np2, n0, top, i - 1);\n            bn_scatter5(tmp.d, top, powerbuf, i);\n        }\n# endif\n        bits--;\n        for (wvalue = 0, i = bits % 5; i >= 0; i--, bits--)\n            wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);\n        bn_gather5(tmp.d, top, powerbuf, wvalue);\n\n        /*\n         * Scan the exponent one window at a time starting from the most\n         * significant bits.\n         */\n        if (top & 7)\n            while (bits >= 0) {\n                for (wvalue = 0, i = 0; i < 5; i++, bits--)\n                    wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);\n\n                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\n                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\n                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\n                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\n                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\n                bn_mul_mont_gather5(tmp.d, tmp.d, powerbuf, np, n0, top,\n                                    wvalue);\n        } else {\n            while (bits >= 0) {\n                wvalue = bn_get_bits5(p->d, bits - 4);\n                bits -= 5;\n                bn_power5(tmp.d, tmp.d, powerbuf, np2, n0, top, wvalue);\n            }\n        }\n\n        ret = bn_from_montgomery(tmp.d, tmp.d, NULL, np2, n0, top);\n        tmp.top = top;\n        bn_correct_top(&tmp);\n        if (ret) {\n            if (!BN_copy(rr, &tmp))\n                ret = 0;\n            goto err;           /* non-zero ret means it's not error */\n        }\n    } else\n#endif\n    {\n        if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, 0, numPowers))\n            goto err;\n        if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&am, top, powerbuf, 1, numPowers))\n            goto err;\n\n        /*\n         * If the window size is greater than 1, then calculate\n         * val[i=2..2^winsize-1]. Powers are computed as a*a^(i-1) (even\n         * powers could instead be computed as (a^(i/2))^2 to use the slight\n         * performance advantage of sqr over mul).\n         */\n        if (window > 1) {\n            if (!BN_mod_mul_montgomery(&tmp, &am, &am, mont, ctx))\n                goto err;\n            if (!MOD_EXP_CTIME_COPY_TO_PREBUF\n                (&tmp, top, powerbuf, 2, numPowers))\n                goto err;\n            for (i = 3; i < numPowers; i++) {\n                /* Calculate a^i = a^(i-1) * a */\n                if (!BN_mod_mul_montgomery(&tmp, &am, &tmp, mont, ctx))\n                    goto err;\n                if (!MOD_EXP_CTIME_COPY_TO_PREBUF\n                    (&tmp, top, powerbuf, i, numPowers))\n                    goto err;\n            }\n        }\n\n        bits--;\n        for (wvalue = 0, i = bits % window; i >= 0; i--, bits--)\n            wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);\n        if (!MOD_EXP_CTIME_COPY_FROM_PREBUF\n            (&tmp, top, powerbuf, wvalue, numPowers))\n            goto err;\n\n        /*\n         * Scan the exponent one window at a time starting from the most\n     } else\n #endif\n     {\n        if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, 0, numPowers))\n             goto err;\n        if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&am, top, powerbuf, 1, numPowers))\n             goto err;\n \n         /*\n                wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);\n            }\n\n            /*\n             * Fetch the appropriate pre-computed value from the pre-buf\n         if (window > 1) {\n             if (!BN_mod_mul_montgomery(&tmp, &am, &am, mont, ctx))\n                 goto err;\n            if (!MOD_EXP_CTIME_COPY_TO_PREBUF\n                (&tmp, top, powerbuf, 2, numPowers))\n                 goto err;\n             for (i = 3; i < numPowers; i++) {\n                 /* Calculate a^i = a^(i-1) * a */\n                 if (!BN_mod_mul_montgomery(&tmp, &am, &tmp, mont, ctx))\n                     goto err;\n                if (!MOD_EXP_CTIME_COPY_TO_PREBUF\n                    (&tmp, top, powerbuf, i, numPowers))\n                     goto err;\n             }\n         }\n        for (i = 1; i < top; i++)\n         bits--;\n         for (wvalue = 0, i = bits % window; i >= 0; i--, bits--)\n             wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);\n        if (!MOD_EXP_CTIME_COPY_FROM_PREBUF\n            (&tmp, top, powerbuf, wvalue, numPowers))\n             goto err;\n \n         /*\n err:\n    if ((in_mont == NULL) && (mont != NULL))\n        BN_MONT_CTX_free(mont);\n    if (powerbuf != NULL) {\n        OPENSSL_cleanse(powerbuf, powerbufLen);\n        if (powerbufFree)\n            OPENSSL_free(powerbufFree);\n    }\n    BN_CTX_end(ctx);\n    return (ret);\n}\n\nint BN_mod_exp_mont_word(BIGNUM *rr, BN_ULONG a, const BIGNUM *p,\n             /*\n              * Fetch the appropriate pre-computed value from the pre-buf\n              */\n            if (!MOD_EXP_CTIME_COPY_FROM_PREBUF\n                (&am, top, powerbuf, wvalue, numPowers))\n                 goto err;\n \n             /* Multiply the result into the intermediate result */\n#define BN_MOD_MUL_WORD(r, w, m) \\\n                (BN_mul_word(r, (w)) && \\\n                (/* BN_ucmp(r, (m)) < 0 ? 1 :*/  \\\n                        (BN_mod(t, r, m, ctx) && (swap_tmp = r, r = t, t = swap_tmp, 1))))\n    /*\n     * BN_MOD_MUL_WORD is only used with 'w' large, so the BN_ucmp test is\n     * probably more overhead than always using BN_mod (which uses BN_copy if\n     * a similar test returns true).\n     */\n    /*\n     * We can use BN_mod and do not need BN_nnmod because our accumulator is\n     * never negative (the result of BN_mod does not depend on the sign of\n     * the modulus).\n     */\n#define BN_TO_MONTGOMERY_WORD(r, w, mont) \\\n                (BN_set_word(r, (w)) && BN_to_montgomery(r, r, (mont), ctx))\n\n    if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0) {\n        /* BN_FLG_CONSTTIME only supported by BN_mod_exp_mont() */\n        BNerr(BN_F_BN_MOD_EXP_MONT_WORD, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n        return -1;\n    }\n\n    bn_check_top(p);\n    bn_check_top(m);\n\n    if (!BN_is_odd(m)) {\n        BNerr(BN_F_BN_MOD_EXP_MONT_WORD, BN_R_CALLED_WITH_EVEN_MODULUS);\n        return (0);\n    }\n    if (m->top == 1)\n        a %= m->d[0];           /* make sure that 'a' is reduced */\n\n    bits = BN_num_bits(p);\n    if (bits == 0) {\n        /* x**0 mod 1 is still zero. */\n        if (BN_is_one(m)) {\n            ret = 1;\n            BN_zero(rr);\n        } else {\n            ret = BN_one(rr);\n        }\n        return ret;\n    }\n    if (a == 0) {\n        BN_zero(rr);\n        ret = 1;\n        return ret;\n    }\n\n    BN_CTX_start(ctx);\n    d = BN_CTX_get(ctx);\n    r = BN_CTX_get(ctx);\n    t = BN_CTX_get(ctx);\n    if (d == NULL || r == NULL || t == NULL)\n        goto err;\n\n    if (in_mont != NULL)\n        mont = in_mont;\n    else {\n        if ((mont = BN_MONT_CTX_new()) == NULL)\n            goto err;\n        if (!BN_MONT_CTX_set(mont, m, ctx))\n            goto err;\n    }\n\n    r_is_one = 1;               /* except for Montgomery factor */\n\n    /* bits-1 >= 0 */\n\n    /* The result is accumulated in the product r*w. */\n    w = a;                      /* bit 'bits-1' of 'p' is always set */\n    for (b = bits - 2; b >= 0; b--) {\n        /* First, square r*w. */\n        next_w = w * w;\n        if ((next_w / w) != w) { /* overflow */\n            if (r_is_one) {\n                if (!BN_TO_MONTGOMERY_WORD(r, w, mont))\n                    goto err;\n                r_is_one = 0;\n            } else {\n                if (!BN_MOD_MUL_WORD(r, w, m))\n                    goto err;\n            }\n            next_w = 1;\n        }\n        w = next_w;\n        if (!r_is_one) {\n            if (!BN_mod_mul_montgomery(r, r, r, mont, ctx))\n                goto err;\n        }\n\n        /* Second, multiply r*w by 'a' if exponent bit is set. */\n        if (BN_is_bit_set(p, b)) {\n            next_w = w * a;\n            if ((next_w / a) != w) { /* overflow */\n                if (r_is_one) {\n                    if (!BN_TO_MONTGOMERY_WORD(r, w, mont))\n                        goto err;\n                    r_is_one = 0;\n                } else {\n                    if (!BN_MOD_MUL_WORD(r, w, m))\n                        goto err;\n                }\n                next_w = a;\n            }\n            w = next_w;\n        }\n    }\n\n    /* Finally, set r:=r*w. */\n    if (w != 1) {\n        if (r_is_one) {\n            if (!BN_TO_MONTGOMERY_WORD(r, w, mont))\n                goto err;\n            r_is_one = 0;\n        } else {\n            if (!BN_MOD_MUL_WORD(r, w, m))\n                goto err;\n        }\n    }\n\n    if (r_is_one) {             /* can happen only if a == 1 */\n        if (!BN_one(rr))\n            goto err;\n    } else {\n        if (!BN_from_montgomery(rr, r, mont, ctx))\n            goto err;\n    }\n    ret = 1;\n err:\n    if ((in_mont == NULL) && (mont != NULL))\n        BN_MONT_CTX_free(mont);\n    BN_CTX_end(ctx);\n    bn_check_top(rr);\n    return (ret);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141595,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": " static int MOD_EXP_CTIME_COPY_TO_PREBUF(const BIGNUM *b, int top,\n                                         unsigned char *buf, int idx,\n                                        int window)\n {\n    int i, j;\n    int width = 1 << window;\n    BN_ULONG *table = (BN_ULONG *)buf;\n \n     if (top > b->top)\n         top = b->top;           /* this works because 'buf' is explicitly\n                                  * zeroed */\n    for (i = 0, j = idx; i < top; i++, j += width) {\n        table[j] = b->d[i];\n     }\n \n     return 1;\n                                          unsigned char *buf, int idx,\n \n static int MOD_EXP_CTIME_COPY_FROM_PREBUF(BIGNUM *b, int top,\n                                           unsigned char *buf, int idx,\n                                          int window)\n {\n    int i, j;\n    int width = 1 << window;\n    volatile BN_ULONG *table = (volatile BN_ULONG *)buf;\n \n     if (bn_wexpand(b, top) == NULL)\n         return 0;\n \n    if (window <= 3) {\n        for (i = 0; i < top; i++, table += width) {\n            BN_ULONG acc = 0;\n\n            for (j = 0; j < width; j++) {\n                acc |= table[j] &\n                       ((BN_ULONG)0 - (constant_time_eq_int(j,idx)&1));\n            }\n\n            b->d[i] = acc;\n        }\n    } else {\n        int xstride = 1 << (window - 2);\n        BN_ULONG y0, y1, y2, y3;\n\n        i = idx >> (window - 2);        /* equivalent of idx / xstride */\n        idx &= xstride - 1;             /* equivalent of idx % xstride */\n\n        y0 = (BN_ULONG)0 - (constant_time_eq_int(i,0)&1);\n        y1 = (BN_ULONG)0 - (constant_time_eq_int(i,1)&1);\n        y2 = (BN_ULONG)0 - (constant_time_eq_int(i,2)&1);\n        y3 = (BN_ULONG)0 - (constant_time_eq_int(i,3)&1);\n\n        for (i = 0; i < top; i++, table += width) {\n            BN_ULONG acc = 0;\n\n            for (j = 0; j < xstride; j++) {\n                acc |= ( (table[j + 0 * xstride] & y0) |\n                         (table[j + 1 * xstride] & y1) |\n                         (table[j + 2 * xstride] & y2) |\n                         (table[j + 3 * xstride] & y3) )\n                       & ((BN_ULONG)0 - (constant_time_eq_int(j,idx)&1));\n            }\n\n            b->d[i] = acc;\n        }\n     }\n \n     b->top = top;\n    if (!BN_is_odd(m)) {\n        BNerr(BN_F_BN_MOD_EXP_MONT_CONSTTIME, BN_R_CALLED_WITH_EVEN_MODULUS);\n        return (0);\n    }\n\n    top = m->top;\n\n    bits = BN_num_bits(p);\n    if (bits == 0) {\n        /* x**0 mod 1 is still zero. */\n        if (BN_is_one(m)) {\n            ret = 1;\n            BN_zero(rr);\n        } else {\n            ret = BN_one(rr);\n        }\n        return ret;\n    }\n\n    BN_CTX_start(ctx);\n\n    /*\n     * Allocate a montgomery context if it was not supplied by the caller. If\n     * this is not done, things will break in the montgomery part.\n     */\n    if (in_mont != NULL)\n        mont = in_mont;\n    else {\n        if ((mont = BN_MONT_CTX_new()) == NULL)\n            goto err;\n        if (!BN_MONT_CTX_set(mont, m, ctx))\n            goto err;\n    }\n\n#ifdef RSAZ_ENABLED\n    /*\n     * If the size of the operands allow it, perform the optimized\n     * RSAZ exponentiation. For further information see\n     * crypto/bn/rsaz_exp.c and accompanying assembly modules.\n     */\n    if ((16 == a->top) && (16 == p->top) && (BN_num_bits(m) == 1024)\n        && rsaz_avx2_eligible()) {\n        if (NULL == bn_wexpand(rr, 16))\n            goto err;\n        RSAZ_1024_mod_exp_avx2(rr->d, a->d, p->d, m->d, mont->RR.d,\n                               mont->n0[0]);\n        rr->top = 16;\n        rr->neg = 0;\n        bn_correct_top(rr);\n        ret = 1;\n        goto err;\n    } else if ((8 == a->top) && (8 == p->top) && (BN_num_bits(m) == 512)) {\n        if (NULL == bn_wexpand(rr, 8))\n            goto err;\n        RSAZ_512_mod_exp(rr->d, a->d, p->d, m->d, mont->n0[0], mont->RR.d);\n        rr->top = 8;\n        rr->neg = 0;\n        bn_correct_top(rr);\n        ret = 1;\n        goto err;\n    }\n#endif\n\n    /* Get the window size to use with size of p. */\n    window = BN_window_bits_for_ctime_exponent_size(bits);\n#if defined(SPARC_T4_MONT)\n    if (window >= 5 && (top & 15) == 0 && top <= 64 &&\n        (OPENSSL_sparcv9cap_P[1] & (CFR_MONTMUL | CFR_MONTSQR)) ==\n        (CFR_MONTMUL | CFR_MONTSQR) && (t4 = OPENSSL_sparcv9cap_P[0]))\n        window = 5;\n    else\n#endif\n#if defined(OPENSSL_BN_ASM_MONT5)\n    if (window >= 5) {\n        window = 5;             /* ~5% improvement for RSA2048 sign, and even\n                                 * for RSA4096 */\n        if ((top & 7) == 0)\n            powerbufLen += 2 * top * sizeof(m->d[0]);\n    }\n#endif\n    (void)0;\n\n    /*\n     * Allocate a buffer large enough to hold all of the pre-computed powers\n     * of am, am itself and tmp.\n     */\n    numPowers = 1 << window;\n    powerbufLen += sizeof(m->d[0]) * (top * numPowers +\n                                      ((2 * top) >\n                                       numPowers ? (2 * top) : numPowers));\n#ifdef alloca\n    if (powerbufLen < 3072)\n        powerbufFree =\n            alloca(powerbufLen + MOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH);\n    else\n#endif\n        if ((powerbufFree =\n             (unsigned char *)OPENSSL_malloc(powerbufLen +\n                                             MOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH))\n            == NULL)\n        goto err;\n\n    powerbuf = MOD_EXP_CTIME_ALIGN(powerbufFree);\n    memset(powerbuf, 0, powerbufLen);\n\n#ifdef alloca\n    if (powerbufLen < 3072)\n        powerbufFree = NULL;\n#endif\n\n    /* lay down tmp and am right after powers table */\n    tmp.d = (BN_ULONG *)(powerbuf + sizeof(m->d[0]) * top * numPowers);\n    am.d = tmp.d + top;\n    tmp.top = am.top = 0;\n    tmp.dmax = am.dmax = top;\n    tmp.neg = am.neg = 0;\n    tmp.flags = am.flags = BN_FLG_STATIC_DATA;\n\n    /* prepare a^0 in Montgomery domain */\n#if 1                           /* by Shay Gueron's suggestion */\n    if (m->d[top - 1] & (((BN_ULONG)1) << (BN_BITS2 - 1))) {\n        /* 2^(top*BN_BITS2) - m */\n        tmp.d[0] = (0 - m->d[0]) & BN_MASK2;\n        for (i = 1; i < top; i++)\n            tmp.d[i] = (~m->d[i]) & BN_MASK2;\n        tmp.top = top;\n    } else\n#endif\n    if (!BN_to_montgomery(&tmp, BN_value_one(), mont, ctx))\n        goto err;\n\n    /* prepare a^1 in Montgomery domain */\n    if (a->neg || BN_ucmp(a, m) >= 0) {\n        if (!BN_mod(&am, a, m, ctx))\n            goto err;\n        if (!BN_to_montgomery(&am, &am, mont, ctx))\n            goto err;\n    } else if (!BN_to_montgomery(&am, a, mont, ctx))\n        goto err;\n\n#if defined(SPARC_T4_MONT)\n    if (t4) {\n        typedef int (*bn_pwr5_mont_f) (BN_ULONG *tp, const BN_ULONG *np,\n                                       const BN_ULONG *n0, const void *table,\n                                       int power, int bits);\n        int bn_pwr5_mont_t4_8(BN_ULONG *tp, const BN_ULONG *np,\n                              const BN_ULONG *n0, const void *table,\n                              int power, int bits);\n        int bn_pwr5_mont_t4_16(BN_ULONG *tp, const BN_ULONG *np,\n                               const BN_ULONG *n0, const void *table,\n                               int power, int bits);\n        int bn_pwr5_mont_t4_24(BN_ULONG *tp, const BN_ULONG *np,\n                               const BN_ULONG *n0, const void *table,\n                               int power, int bits);\n        int bn_pwr5_mont_t4_32(BN_ULONG *tp, const BN_ULONG *np,\n                               const BN_ULONG *n0, const void *table,\n                               int power, int bits);\n        static const bn_pwr5_mont_f pwr5_funcs[4] = {\n            bn_pwr5_mont_t4_8, bn_pwr5_mont_t4_16,\n            bn_pwr5_mont_t4_24, bn_pwr5_mont_t4_32\n        };\n        bn_pwr5_mont_f pwr5_worker = pwr5_funcs[top / 16 - 1];\n\n        typedef int (*bn_mul_mont_f) (BN_ULONG *rp, const BN_ULONG *ap,\n                                      const void *bp, const BN_ULONG *np,\n                                      const BN_ULONG *n0);\n        int bn_mul_mont_t4_8(BN_ULONG *rp, const BN_ULONG *ap, const void *bp,\n                             const BN_ULONG *np, const BN_ULONG *n0);\n        int bn_mul_mont_t4_16(BN_ULONG *rp, const BN_ULONG *ap,\n                              const void *bp, const BN_ULONG *np,\n                              const BN_ULONG *n0);\n        int bn_mul_mont_t4_24(BN_ULONG *rp, const BN_ULONG *ap,\n                              const void *bp, const BN_ULONG *np,\n                              const BN_ULONG *n0);\n        int bn_mul_mont_t4_32(BN_ULONG *rp, const BN_ULONG *ap,\n                              const void *bp, const BN_ULONG *np,\n                              const BN_ULONG *n0);\n        static const bn_mul_mont_f mul_funcs[4] = {\n            bn_mul_mont_t4_8, bn_mul_mont_t4_16,\n            bn_mul_mont_t4_24, bn_mul_mont_t4_32\n        };\n        bn_mul_mont_f mul_worker = mul_funcs[top / 16 - 1];\n\n        void bn_mul_mont_vis3(BN_ULONG *rp, const BN_ULONG *ap,\n                              const void *bp, const BN_ULONG *np,\n                              const BN_ULONG *n0, int num);\n        void bn_mul_mont_t4(BN_ULONG *rp, const BN_ULONG *ap,\n                            const void *bp, const BN_ULONG *np,\n                            const BN_ULONG *n0, int num);\n        void bn_mul_mont_gather5_t4(BN_ULONG *rp, const BN_ULONG *ap,\n                                    const void *table, const BN_ULONG *np,\n                                    const BN_ULONG *n0, int num, int power);\n        void bn_flip_n_scatter5_t4(const BN_ULONG *inp, size_t num,\n                                   void *table, size_t power);\n        void bn_gather5_t4(BN_ULONG *out, size_t num,\n                           void *table, size_t power);\n        void bn_flip_t4(BN_ULONG *dst, BN_ULONG *src, size_t num);\n\n        BN_ULONG *np = mont->N.d, *n0 = mont->n0;\n        int stride = 5 * (6 - (top / 16 - 1)); /* multiple of 5, but less\n                                                * than 32 */\n\n        /*\n         * BN_to_montgomery can contaminate words above .top [in\n         * BN_DEBUG[_DEBUG] build]...\n         */\n        for (i = am.top; i < top; i++)\n            am.d[i] = 0;\n        for (i = tmp.top; i < top; i++)\n            tmp.d[i] = 0;\n\n        bn_flip_n_scatter5_t4(tmp.d, top, powerbuf, 0);\n        bn_flip_n_scatter5_t4(am.d, top, powerbuf, 1);\n        if (!(*mul_worker) (tmp.d, am.d, am.d, np, n0) &&\n            !(*mul_worker) (tmp.d, am.d, am.d, np, n0))\n            bn_mul_mont_vis3(tmp.d, am.d, am.d, np, n0, top);\n        bn_flip_n_scatter5_t4(tmp.d, top, powerbuf, 2);\n\n        for (i = 3; i < 32; i++) {\n            /* Calculate a^i = a^(i-1) * a */\n            if (!(*mul_worker) (tmp.d, tmp.d, am.d, np, n0) &&\n                !(*mul_worker) (tmp.d, tmp.d, am.d, np, n0))\n                bn_mul_mont_vis3(tmp.d, tmp.d, am.d, np, n0, top);\n            bn_flip_n_scatter5_t4(tmp.d, top, powerbuf, i);\n        }\n\n        /* switch to 64-bit domain */\n        np = alloca(top * sizeof(BN_ULONG));\n        top /= 2;\n        bn_flip_t4(np, mont->N.d, top);\n\n        bits--;\n        for (wvalue = 0, i = bits % 5; i >= 0; i--, bits--)\n            wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);\n        bn_gather5_t4(tmp.d, top, powerbuf, wvalue);\n\n        /*\n         * Scan the exponent one window at a time starting from the most\n         * significant bits.\n         */\n        while (bits >= 0) {\n            if (bits < stride)\n                stride = bits + 1;\n            bits -= stride;\n            wvalue = bn_get_bits(p, bits + 1);\n\n            if ((*pwr5_worker) (tmp.d, np, n0, powerbuf, wvalue, stride))\n                continue;\n            /* retry once and fall back */\n            if ((*pwr5_worker) (tmp.d, np, n0, powerbuf, wvalue, stride))\n                continue;\n\n            bits += stride - 5;\n            wvalue >>= stride - 5;\n            wvalue &= 31;\n            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);\n            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);\n            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);\n            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);\n            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);\n            bn_mul_mont_gather5_t4(tmp.d, tmp.d, powerbuf, np, n0, top,\n                                   wvalue);\n        }\n\n        bn_flip_t4(tmp.d, tmp.d, top);\n        top *= 2;\n        /* back to 32-bit domain */\n        tmp.top = top;\n        bn_correct_top(&tmp);\n        OPENSSL_cleanse(np, top * sizeof(BN_ULONG));\n    } else\n#endif\n#if defined(OPENSSL_BN_ASM_MONT5)\n    if (window == 5 && top > 1) {\n        /*\n         * This optimization uses ideas from http://eprint.iacr.org/2011/239,\n         * specifically optimization of cache-timing attack countermeasures\n         * and pre-computation optimization.\n         */\n\n        /*\n         * Dedicated window==4 case improves 512-bit RSA sign by ~15%, but as\n         * 512-bit RSA is hardly relevant, we omit it to spare size...\n         */\n        void bn_mul_mont_gather5(BN_ULONG *rp, const BN_ULONG *ap,\n                                 const void *table, const BN_ULONG *np,\n                                 const BN_ULONG *n0, int num, int power);\n        void bn_scatter5(const BN_ULONG *inp, size_t num,\n                         void *table, size_t power);\n        void bn_gather5(BN_ULONG *out, size_t num, void *table, size_t power);\n        void bn_power5(BN_ULONG *rp, const BN_ULONG *ap,\n                       const void *table, const BN_ULONG *np,\n                       const BN_ULONG *n0, int num, int power);\n        int bn_get_bits5(const BN_ULONG *ap, int off);\n        int bn_from_montgomery(BN_ULONG *rp, const BN_ULONG *ap,\n                               const BN_ULONG *not_used, const BN_ULONG *np,\n                               const BN_ULONG *n0, int num);\n\n        BN_ULONG *np = mont->N.d, *n0 = mont->n0, *np2;\n\n        /*\n         * BN_to_montgomery can contaminate words above .top [in\n         * BN_DEBUG[_DEBUG] build]...\n         */\n        for (i = am.top; i < top; i++)\n            am.d[i] = 0;\n        for (i = tmp.top; i < top; i++)\n            tmp.d[i] = 0;\n\n        if (top & 7)\n            np2 = np;\n        else\n            for (np2 = am.d + top, i = 0; i < top; i++)\n                np2[2 * i] = np[i];\n\n        bn_scatter5(tmp.d, top, powerbuf, 0);\n        bn_scatter5(am.d, am.top, powerbuf, 1);\n        bn_mul_mont(tmp.d, am.d, am.d, np, n0, top);\n        bn_scatter5(tmp.d, top, powerbuf, 2);\n\n# if 0\n        for (i = 3; i < 32; i++) {\n            /* Calculate a^i = a^(i-1) * a */\n            bn_mul_mont_gather5(tmp.d, am.d, powerbuf, np2, n0, top, i - 1);\n            bn_scatter5(tmp.d, top, powerbuf, i);\n        }\n# else\n        /* same as above, but uses squaring for 1/2 of operations */\n        for (i = 4; i < 32; i *= 2) {\n            bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\n            bn_scatter5(tmp.d, top, powerbuf, i);\n        }\n        for (i = 3; i < 8; i += 2) {\n            int j;\n            bn_mul_mont_gather5(tmp.d, am.d, powerbuf, np2, n0, top, i - 1);\n            bn_scatter5(tmp.d, top, powerbuf, i);\n            for (j = 2 * i; j < 32; j *= 2) {\n                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\n                bn_scatter5(tmp.d, top, powerbuf, j);\n            }\n        }\n        for (; i < 16; i += 2) {\n            bn_mul_mont_gather5(tmp.d, am.d, powerbuf, np2, n0, top, i - 1);\n            bn_scatter5(tmp.d, top, powerbuf, i);\n            bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\n            bn_scatter5(tmp.d, top, powerbuf, 2 * i);\n        }\n        for (; i < 32; i += 2) {\n            bn_mul_mont_gather5(tmp.d, am.d, powerbuf, np2, n0, top, i - 1);\n            bn_scatter5(tmp.d, top, powerbuf, i);\n        }\n# endif\n        bits--;\n        for (wvalue = 0, i = bits % 5; i >= 0; i--, bits--)\n            wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);\n        bn_gather5(tmp.d, top, powerbuf, wvalue);\n\n        /*\n         * Scan the exponent one window at a time starting from the most\n         * significant bits.\n         */\n        if (top & 7)\n            while (bits >= 0) {\n                for (wvalue = 0, i = 0; i < 5; i++, bits--)\n                    wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);\n\n                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\n                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\n                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\n                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\n                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\n                bn_mul_mont_gather5(tmp.d, tmp.d, powerbuf, np, n0, top,\n                                    wvalue);\n        } else {\n            while (bits >= 0) {\n                wvalue = bn_get_bits5(p->d, bits - 4);\n                bits -= 5;\n                bn_power5(tmp.d, tmp.d, powerbuf, np2, n0, top, wvalue);\n            }\n        }\n\n        ret = bn_from_montgomery(tmp.d, tmp.d, NULL, np2, n0, top);\n        tmp.top = top;\n        bn_correct_top(&tmp);\n        if (ret) {\n            if (!BN_copy(rr, &tmp))\n                ret = 0;\n            goto err;           /* non-zero ret means it's not error */\n        }\n    } else\n#endif\n    {\n        if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, 0, numPowers))\n            goto err;\n        if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&am, top, powerbuf, 1, numPowers))\n            goto err;\n\n        /*\n         * If the window size is greater than 1, then calculate\n         * val[i=2..2^winsize-1]. Powers are computed as a*a^(i-1) (even\n         * powers could instead be computed as (a^(i/2))^2 to use the slight\n         * performance advantage of sqr over mul).\n         */\n        if (window > 1) {\n            if (!BN_mod_mul_montgomery(&tmp, &am, &am, mont, ctx))\n                goto err;\n            if (!MOD_EXP_CTIME_COPY_TO_PREBUF\n                (&tmp, top, powerbuf, 2, numPowers))\n                goto err;\n            for (i = 3; i < numPowers; i++) {\n                /* Calculate a^i = a^(i-1) * a */\n                if (!BN_mod_mul_montgomery(&tmp, &am, &tmp, mont, ctx))\n                    goto err;\n                if (!MOD_EXP_CTIME_COPY_TO_PREBUF\n                    (&tmp, top, powerbuf, i, numPowers))\n                    goto err;\n            }\n        }\n\n        bits--;\n        for (wvalue = 0, i = bits % window; i >= 0; i--, bits--)\n            wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);\n        if (!MOD_EXP_CTIME_COPY_FROM_PREBUF\n            (&tmp, top, powerbuf, wvalue, numPowers))\n            goto err;\n\n        /*\n         * Scan the exponent one window at a time starting from the most\n     } else\n #endif\n     {\n        if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, 0, window))\n             goto err;\n        if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&am, top, powerbuf, 1, window))\n             goto err;\n \n         /*\n                wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);\n            }\n\n            /*\n             * Fetch the appropriate pre-computed value from the pre-buf\n         if (window > 1) {\n             if (!BN_mod_mul_montgomery(&tmp, &am, &am, mont, ctx))\n                 goto err;\n            if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, 2,\n                                              window))\n                 goto err;\n             for (i = 3; i < numPowers; i++) {\n                 /* Calculate a^i = a^(i-1) * a */\n                 if (!BN_mod_mul_montgomery(&tmp, &am, &tmp, mont, ctx))\n                     goto err;\n                if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, i,\n                                                  window))\n                     goto err;\n             }\n         }\n        for (i = 1; i < top; i++)\n         bits--;\n         for (wvalue = 0, i = bits % window; i >= 0; i--, bits--)\n             wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);\n        if (!MOD_EXP_CTIME_COPY_FROM_PREBUF(&tmp, top, powerbuf, wvalue,\n                                            window))\n             goto err;\n \n         /*\n err:\n    if ((in_mont == NULL) && (mont != NULL))\n        BN_MONT_CTX_free(mont);\n    if (powerbuf != NULL) {\n        OPENSSL_cleanse(powerbuf, powerbufLen);\n        if (powerbufFree)\n            OPENSSL_free(powerbufFree);\n    }\n    BN_CTX_end(ctx);\n    return (ret);\n}\n\nint BN_mod_exp_mont_word(BIGNUM *rr, BN_ULONG a, const BIGNUM *p,\n             /*\n              * Fetch the appropriate pre-computed value from the pre-buf\n              */\n            if (!MOD_EXP_CTIME_COPY_FROM_PREBUF(&am, top, powerbuf, wvalue,\n                                                window))\n                 goto err;\n \n             /* Multiply the result into the intermediate result */\n#define BN_MOD_MUL_WORD(r, w, m) \\\n                (BN_mul_word(r, (w)) && \\\n                (/* BN_ucmp(r, (m)) < 0 ? 1 :*/  \\\n                        (BN_mod(t, r, m, ctx) && (swap_tmp = r, r = t, t = swap_tmp, 1))))\n    /*\n     * BN_MOD_MUL_WORD is only used with 'w' large, so the BN_ucmp test is\n     * probably more overhead than always using BN_mod (which uses BN_copy if\n     * a similar test returns true).\n     */\n    /*\n     * We can use BN_mod and do not need BN_nnmod because our accumulator is\n     * never negative (the result of BN_mod does not depend on the sign of\n     * the modulus).\n     */\n#define BN_TO_MONTGOMERY_WORD(r, w, mont) \\\n                (BN_set_word(r, (w)) && BN_to_montgomery(r, r, (mont), ctx))\n\n    if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0) {\n        /* BN_FLG_CONSTTIME only supported by BN_mod_exp_mont() */\n        BNerr(BN_F_BN_MOD_EXP_MONT_WORD, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n        return -1;\n    }\n\n    bn_check_top(p);\n    bn_check_top(m);\n\n    if (!BN_is_odd(m)) {\n        BNerr(BN_F_BN_MOD_EXP_MONT_WORD, BN_R_CALLED_WITH_EVEN_MODULUS);\n        return (0);\n    }\n    if (m->top == 1)\n        a %= m->d[0];           /* make sure that 'a' is reduced */\n\n    bits = BN_num_bits(p);\n    if (bits == 0) {\n        /* x**0 mod 1 is still zero. */\n        if (BN_is_one(m)) {\n            ret = 1;\n            BN_zero(rr);\n        } else {\n            ret = BN_one(rr);\n        }\n        return ret;\n    }\n    if (a == 0) {\n        BN_zero(rr);\n        ret = 1;\n        return ret;\n    }\n\n    BN_CTX_start(ctx);\n    d = BN_CTX_get(ctx);\n    r = BN_CTX_get(ctx);\n    t = BN_CTX_get(ctx);\n    if (d == NULL || r == NULL || t == NULL)\n        goto err;\n\n    if (in_mont != NULL)\n        mont = in_mont;\n    else {\n        if ((mont = BN_MONT_CTX_new()) == NULL)\n            goto err;\n        if (!BN_MONT_CTX_set(mont, m, ctx))\n            goto err;\n    }\n\n    r_is_one = 1;               /* except for Montgomery factor */\n\n    /* bits-1 >= 0 */\n\n    /* The result is accumulated in the product r*w. */\n    w = a;                      /* bit 'bits-1' of 'p' is always set */\n    for (b = bits - 2; b >= 0; b--) {\n        /* First, square r*w. */\n        next_w = w * w;\n        if ((next_w / w) != w) { /* overflow */\n            if (r_is_one) {\n                if (!BN_TO_MONTGOMERY_WORD(r, w, mont))\n                    goto err;\n                r_is_one = 0;\n            } else {\n                if (!BN_MOD_MUL_WORD(r, w, m))\n                    goto err;\n            }\n            next_w = 1;\n        }\n        w = next_w;\n        if (!r_is_one) {\n            if (!BN_mod_mul_montgomery(r, r, r, mont, ctx))\n                goto err;\n        }\n\n        /* Second, multiply r*w by 'a' if exponent bit is set. */\n        if (BN_is_bit_set(p, b)) {\n            next_w = w * a;\n            if ((next_w / a) != w) { /* overflow */\n                if (r_is_one) {\n                    if (!BN_TO_MONTGOMERY_WORD(r, w, mont))\n                        goto err;\n                    r_is_one = 0;\n                } else {\n                    if (!BN_MOD_MUL_WORD(r, w, m))\n                        goto err;\n                }\n                next_w = a;\n            }\n            w = next_w;\n        }\n    }\n\n    /* Finally, set r:=r*w. */\n    if (w != 1) {\n        if (r_is_one) {\n            if (!BN_TO_MONTGOMERY_WORD(r, w, mont))\n                goto err;\n            r_is_one = 0;\n        } else {\n            if (!BN_MOD_MUL_WORD(r, w, m))\n                goto err;\n        }\n    }\n\n    if (r_is_one) {             /* can happen only if a == 1 */\n        if (!BN_one(rr))\n            goto err;\n    } else {\n        if (!BN_from_montgomery(rr, r, mont, ctx))\n            goto err;\n    }\n    ret = 1;\n err:\n    if ((in_mont == NULL) && (mont != NULL))\n        BN_MONT_CTX_free(mont);\n    BN_CTX_end(ctx);\n    bn_check_top(rr);\n    return (ret);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141596,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": " int DH_check_pub_key(const DH *dh, const BIGNUM *pub_key, int *ret)\n {\n     int ok = 0;\n    BIGNUM *q = NULL;\n \n     *ret = 0;\n    q = BN_new();\n    if (q == NULL)\n         goto err;\n    BN_set_word(q, 1);\n    if (BN_cmp(pub_key, q) <= 0)\n         *ret |= DH_CHECK_PUBKEY_TOO_SMALL;\n    BN_copy(q, dh->p);\n    BN_sub_word(q, 1);\n    if (BN_cmp(pub_key, q) >= 0)\n         *ret |= DH_CHECK_PUBKEY_TOO_LARGE;\n \n     ok = 1;\n  err:\n    if (q != NULL)\n        BN_free(q);\n     return (ok);\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141597,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": " int DH_check_pub_key(const DH *dh, const BIGNUM *pub_key, int *ret)\n {\n     int ok = 0;\n    BIGNUM *tmp = NULL;\n    BN_CTX *ctx = NULL;\n \n     *ret = 0;\n    ctx = BN_CTX_new();\n    if (ctx == NULL)\n         goto err;\n    BN_CTX_start(ctx);\n    tmp = BN_CTX_get(ctx);\n    if (tmp == NULL)\n        goto err;\n    BN_set_word(tmp, 1);\n    if (BN_cmp(pub_key, tmp) <= 0)\n         *ret |= DH_CHECK_PUBKEY_TOO_SMALL;\n    BN_copy(tmp, dh->p);\n    BN_sub_word(tmp, 1);\n    if (BN_cmp(pub_key, tmp) >= 0)\n         *ret |= DH_CHECK_PUBKEY_TOO_LARGE;\n \n    if (dh->q != NULL) {\n        /* Check pub_key^q == 1 mod p */\n        if (!BN_mod_exp(tmp, pub_key, dh->q, dh->p, ctx))\n            goto err;\n        if (!BN_is_one(tmp))\n            *ret |= DH_CHECK_PUBKEY_INVALID;\n    }\n\n     ok = 1;\n  err:\n    if (ctx != NULL) {\n        BN_CTX_end(ctx);\n        BN_CTX_free(ctx);\n    }\n     return (ok);\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141598,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "lib_file_open(gs_file_path_ptr  lib_path, const gs_memory_t *mem, i_ctx_t *i_ctx_p,\n                       const char *fname, uint flen, char *buffer, int blen, uint *pclen, ref *pfile)\n{   /* i_ctx_p is NULL running arg (@) files.\n     * lib_path and mem are never NULL\n     */\n    bool starting_arg_file = (i_ctx_p == NULL) ? true : i_ctx_p->starting_arg_file;\n    bool search_with_no_combine = false;\n    bool search_with_combine = false;\n    char fmode[2] = { 'r', 0};\n    gx_io_device *iodev = iodev_default(mem);\n     gs_main_instance *minst = get_minst_from_memory(mem);\n     int code;\n \n     /* when starting arg files (@ files) iodev_default is not yet set */\n     if (iodev == 0)\n         iodev = (gx_io_device *)gx_io_device_table[0];\n       search_with_combine = false;\n    } else {\n       search_with_no_combine = starting_arg_file;\n       search_with_combine = true;\n    }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141603,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "lib_file_open(gs_file_path_ptr  lib_path, const gs_memory_t *mem, i_ctx_t *i_ctx_p,\n                       const char *fname, uint flen, char *buffer, int blen, uint *pclen, ref *pfile)\n{   /* i_ctx_p is NULL running arg (@) files.\n     * lib_path and mem are never NULL\n     */\n    bool starting_arg_file = (i_ctx_p == NULL) ? true : i_ctx_p->starting_arg_file;\n    bool search_with_no_combine = false;\n    bool search_with_combine = false;\n    char fmode[2] = { 'r', 0};\n    gx_io_device *iodev = iodev_default(mem);\n     gs_main_instance *minst = get_minst_from_memory(mem);\n     int code;\n \n    if (i_ctx_p && starting_arg_file)\n        i_ctx_p->starting_arg_file = false;\n\n     /* when starting arg files (@ files) iodev_default is not yet set */\n     if (iodev == 0)\n         iodev = (gx_io_device *)gx_io_device_table[0];\n       search_with_combine = false;\n    } else {\n       search_with_no_combine = starting_arg_file;\n       search_with_combine = true;\n    }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141604,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "polkit_backend_interactive_authority_check_authorization (PolkitBackendAuthority         *authority,\n                                                          PolkitSubject                  *caller,\n                                                          PolkitSubject                  *subject,\n                                                          const gchar                    *action_id,\n                                                          PolkitDetails                  *details,\n                                                          PolkitCheckAuthorizationFlags   flags,\n                                                          GCancellable                   *cancellable,\n                                                          GAsyncReadyCallback             callback,\n                                                          gpointer                        user_data)\n{\n  PolkitBackendInteractiveAuthority *interactive_authority;\n  PolkitBackendInteractiveAuthorityPrivate *priv;\n  gchar *caller_str;\n   gchar *subject_str;\n   PolkitIdentity *user_of_caller;\n   PolkitIdentity *user_of_subject;\n   gchar *user_of_caller_str;\n   gchar *user_of_subject_str;\n   PolkitAuthorizationResult *result;\n  GError *error;\n  GSimpleAsyncResult *simple;\n  gboolean has_details;\n  gchar **detail_keys;\n\n  interactive_authority = POLKIT_BACKEND_INTERACTIVE_AUTHORITY (authority);\n  priv = POLKIT_BACKEND_INTERACTIVE_AUTHORITY_GET_PRIVATE (interactive_authority);\n\n  error = NULL;\n  caller_str = NULL;\n  subject_str = NULL;\n  user_of_caller = NULL;\n  user_of_subject = NULL;\n  user_of_caller_str = NULL;\n  user_of_subject_str = NULL;\n  result = NULL;\n\n  simple = g_simple_async_result_new (G_OBJECT (authority),\n                                      callback,\n                                      user_data,\n                                      polkit_backend_interactive_authority_check_authorization);\n\n  /* handle being called from ourselves */\n  if (caller == NULL)\n    {\n      /* TODO: this is kind of a hack */\n      GDBusConnection *system_bus;\n      system_bus = g_bus_get_sync (G_BUS_TYPE_SYSTEM, NULL, NULL);\n      caller = polkit_system_bus_name_new (g_dbus_connection_get_unique_name (system_bus));\n      g_object_unref (system_bus);\n    }\n\n  caller_str = polkit_subject_to_string (caller);\n  subject_str = polkit_subject_to_string (subject);\n\n  g_debug (\"%s is inquiring whether %s is authorized for %s\",\n           caller_str,\n           subject_str,\n           action_id);\n            action_id);\n \n   user_of_caller = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor,\n                                                                        caller,\n                                                                         &error);\n   if (error != NULL)\n     {\n      g_simple_async_result_complete (simple);\n      g_object_unref (simple);\n      g_error_free (error);\n      goto out;\n    }\n\n  user_of_caller_str = polkit_identity_to_string (user_of_caller);\n  g_debug (\" user of caller is %s\", user_of_caller_str);\n   g_debug (\" user of caller is %s\", user_of_caller_str);\n \n   user_of_subject = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor,\n                                                                         subject,\n                                                                          &error);\n   if (error != NULL)\n     {\n      g_simple_async_result_complete (simple);\n      g_object_unref (simple);\n      g_error_free (error);\n      goto out;\n    }\n\n  user_of_subject_str = polkit_identity_to_string (user_of_subject);\n  g_debug (\" user of subject is %s\", user_of_subject_str);\n\n  has_details = FALSE;\n  if (details != NULL)\n    {\n      detail_keys = polkit_details_get_keys (details);\n      if (detail_keys != NULL)\n        {\n          if (g_strv_length (detail_keys) > 0)\n            has_details = TRUE;\n          g_strfreev (detail_keys);\n        }\n    }\n\n  /* Not anyone is allowed to check that process XYZ is allowed to do ABC.\n   * We only allow this if, and only if,\n    * We only allow this if, and only if,\n    *\n    *  - processes may check for another process owned by the *same* user but not\n   *    if details are passed (otherwise you'd be able to spoof the dialog)\n    *\n    *  - processes running as uid 0 may check anything and pass any details\n    *\n  if (!polkit_identity_equal (user_of_caller, user_of_subject) || has_details)\n    *    then any uid referenced by that annotation is also allowed to check\n    *    to check anything and pass any details\n    */\n  if (!polkit_identity_equal (user_of_caller, user_of_subject) || has_details)\n     {\n       if (!may_identity_check_authorization (interactive_authority, action_id, user_of_caller))\n         {\n                                               \"pass details\");\n            }\n          else\n            {\n              g_simple_async_result_set_error (simple,\n                                               POLKIT_ERROR,\n                                               POLKIT_ERROR_NOT_AUTHORIZED,\n                                               \"Only trusted callers (e.g. uid 0 or an action owner) can use CheckAuthorization() for \"\n                                               \"subjects belonging to other identities\");\n            }\n          g_simple_async_result_complete (simple);\n          g_object_unref (simple);\n          goto out;\n        }\n    }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141613,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "polkit_backend_interactive_authority_check_authorization (PolkitBackendAuthority         *authority,\n                                                          PolkitSubject                  *caller,\n                                                          PolkitSubject                  *subject,\n                                                          const gchar                    *action_id,\n                                                          PolkitDetails                  *details,\n                                                          PolkitCheckAuthorizationFlags   flags,\n                                                          GCancellable                   *cancellable,\n                                                          GAsyncReadyCallback             callback,\n                                                          gpointer                        user_data)\n{\n  PolkitBackendInteractiveAuthority *interactive_authority;\n  PolkitBackendInteractiveAuthorityPrivate *priv;\n  gchar *caller_str;\n   gchar *subject_str;\n   PolkitIdentity *user_of_caller;\n   PolkitIdentity *user_of_subject;\n  gboolean user_of_subject_matches;\n   gchar *user_of_caller_str;\n   gchar *user_of_subject_str;\n   PolkitAuthorizationResult *result;\n  GError *error;\n  GSimpleAsyncResult *simple;\n  gboolean has_details;\n  gchar **detail_keys;\n\n  interactive_authority = POLKIT_BACKEND_INTERACTIVE_AUTHORITY (authority);\n  priv = POLKIT_BACKEND_INTERACTIVE_AUTHORITY_GET_PRIVATE (interactive_authority);\n\n  error = NULL;\n  caller_str = NULL;\n  subject_str = NULL;\n  user_of_caller = NULL;\n  user_of_subject = NULL;\n  user_of_caller_str = NULL;\n  user_of_subject_str = NULL;\n  result = NULL;\n\n  simple = g_simple_async_result_new (G_OBJECT (authority),\n                                      callback,\n                                      user_data,\n                                      polkit_backend_interactive_authority_check_authorization);\n\n  /* handle being called from ourselves */\n  if (caller == NULL)\n    {\n      /* TODO: this is kind of a hack */\n      GDBusConnection *system_bus;\n      system_bus = g_bus_get_sync (G_BUS_TYPE_SYSTEM, NULL, NULL);\n      caller = polkit_system_bus_name_new (g_dbus_connection_get_unique_name (system_bus));\n      g_object_unref (system_bus);\n    }\n\n  caller_str = polkit_subject_to_string (caller);\n  subject_str = polkit_subject_to_string (subject);\n\n  g_debug (\"%s is inquiring whether %s is authorized for %s\",\n           caller_str,\n           subject_str,\n           action_id);\n            action_id);\n \n   user_of_caller = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor,\n                                                                        caller, NULL,\n                                                                         &error);\n   if (error != NULL)\n     {\n      g_simple_async_result_complete (simple);\n      g_object_unref (simple);\n      g_error_free (error);\n      goto out;\n    }\n\n  user_of_caller_str = polkit_identity_to_string (user_of_caller);\n  g_debug (\" user of caller is %s\", user_of_caller_str);\n   g_debug (\" user of caller is %s\", user_of_caller_str);\n \n   user_of_subject = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor,\n                                                                         subject, &user_of_subject_matches,\n                                                                          &error);\n   if (error != NULL)\n     {\n      g_simple_async_result_complete (simple);\n      g_object_unref (simple);\n      g_error_free (error);\n      goto out;\n    }\n\n  user_of_subject_str = polkit_identity_to_string (user_of_subject);\n  g_debug (\" user of subject is %s\", user_of_subject_str);\n\n  has_details = FALSE;\n  if (details != NULL)\n    {\n      detail_keys = polkit_details_get_keys (details);\n      if (detail_keys != NULL)\n        {\n          if (g_strv_length (detail_keys) > 0)\n            has_details = TRUE;\n          g_strfreev (detail_keys);\n        }\n    }\n\n  /* Not anyone is allowed to check that process XYZ is allowed to do ABC.\n   * We only allow this if, and only if,\n    * We only allow this if, and only if,\n    *\n    *  - processes may check for another process owned by the *same* user but not\n   *    if details are passed (otherwise you'd be able to spoof the dialog);\n   *    the caller supplies the user_of_subject value, so we additionally\n   *    require it to match at least at one point in time (via\n   *    user_of_subject_matches).\n    *\n    *  - processes running as uid 0 may check anything and pass any details\n    *\n  if (!polkit_identity_equal (user_of_caller, user_of_subject) || has_details)\n    *    then any uid referenced by that annotation is also allowed to check\n    *    to check anything and pass any details\n    */\n  if (!user_of_subject_matches\n      || !polkit_identity_equal (user_of_caller, user_of_subject)\n      || has_details)\n     {\n       if (!may_identity_check_authorization (interactive_authority, action_id, user_of_caller))\n         {\n                                               \"pass details\");\n            }\n          else\n            {\n              g_simple_async_result_set_error (simple,\n                                               POLKIT_ERROR,\n                                               POLKIT_ERROR_NOT_AUTHORIZED,\n                                               \"Only trusted callers (e.g. uid 0 or an action owner) can use CheckAuthorization() for \"\n                                               \"subjects belonging to other identities\");\n            }\n          g_simple_async_result_complete (simple);\n          g_object_unref (simple);\n          goto out;\n        }\n    }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141614,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "_gcry_ecc_ecdsa_sign (gcry_mpi_t input, ECC_secret_key *skey,\n                      gcry_mpi_t r, gcry_mpi_t s,\n                      int flags, int hashalgo)\n{\n  gpg_err_code_t rc = 0;\n  int extraloops = 0;\n  gcry_mpi_t k, dr, sum, k_1, x;\n  mpi_point_struct I;\n  gcry_mpi_t hash;\n   const void *abuf;\n   unsigned int abits, qbits;\n   mpi_ec_t ctx;\n \n   if (DBG_CIPHER)\n     log_mpidump (\"ecdsa sign hash  \", input );\n\n  /* Convert the INPUT into an MPI if needed.  */\n  rc = _gcry_dsa_normalize_hash (input, &hash, qbits);\n  if (rc)\n    return rc;\n   if (rc)\n     return rc;\n \n   k = NULL;\n   dr = mpi_alloc (0);\n   sum = mpi_alloc (0);\n    {\n      do\n        {\n          mpi_free (k);\n          k = NULL;\n          if ((flags & PUBKEY_FLAG_RFC6979) && hashalgo)\n            {\n              /* Use Pornin's method for deterministic DSA.  If this\n                 flag is set, it is expected that HASH is an opaque\n                 MPI with the to be signed hash.  That hash is also\n                 used as h1 from 3.2.a.  */\n              if (!mpi_is_opaque (input))\n                {\n                  rc = GPG_ERR_CONFLICT;\n                  goto leave;\n                }\n\n              abuf = mpi_get_opaque (input, &abits);\n              rc = _gcry_dsa_gen_rfc6979_k (&k, skey->E.n, skey->d,\n                                            abuf, (abits+7)/8,\n                                            hashalgo, extraloops);\n              if (rc)\n                goto leave;\n              extraloops++;\n            }\n          else\n            k = _gcry_dsa_gen_k (skey->E.n, GCRY_STRONG_RANDOM);\n\n          _gcry_mpi_ec_mul_point (&I, k, &skey->E.G, ctx);\n          if (_gcry_mpi_ec_get_affine (x, NULL, &I, ctx))\n            {\n              if (DBG_CIPHER)\n                log_debug (\"ecc sign: Failed to get affine coordinates\\n\");\n              rc = GPG_ERR_BAD_SIGNATURE;\n              goto leave;\n            }\n          mpi_mod (r, x, skey->E.n);  /* r = x mod n */\n        }\n      while (!mpi_cmp_ui (r, 0));\n\n      mpi_mulm (dr, skey->d, r, skey->E.n); /* dr = d*r mod n  */\n      mpi_addm (sum, hash, dr, skey->E.n);  /* sum = hash + (d*r) mod n  */\n      mpi_invm (k_1, k, skey->E.n);         /* k_1 = k^(-1) mod n  */\n      mpi_mulm (s, k_1, sum, skey->E.n);    /* s = k^(-1)*(hash+(d*r)) mod n */\n    }\n  while (!mpi_cmp_ui (s, 0));\n\n  if (DBG_CIPHER)\n         }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141631,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "_gcry_ecc_ecdsa_sign (gcry_mpi_t input, ECC_secret_key *skey,\n                      gcry_mpi_t r, gcry_mpi_t s,\n                      int flags, int hashalgo)\n{\n  gpg_err_code_t rc = 0;\n  int extraloops = 0;\n  gcry_mpi_t k, dr, sum, k_1, x;\n  mpi_point_struct I;\n  gcry_mpi_t hash;\n   const void *abuf;\n   unsigned int abits, qbits;\n   mpi_ec_t ctx;\n  gcry_mpi_t b;                /* Random number needed for blinding.  */\n  gcry_mpi_t bi;               /* multiplicative inverse of B.        */\n \n   if (DBG_CIPHER)\n     log_mpidump (\"ecdsa sign hash  \", input );\n\n  /* Convert the INPUT into an MPI if needed.  */\n  rc = _gcry_dsa_normalize_hash (input, &hash, qbits);\n  if (rc)\n    return rc;\n   if (rc)\n     return rc;\n \n  b  = mpi_snew (qbits);\n  bi = mpi_snew (qbits);\n  do\n    {\n      _gcry_mpi_randomize (b, qbits, GCRY_WEAK_RANDOM);\n      mpi_mod (b, b, skey->E.n);\n    }\n  while (!mpi_invm (bi, b, skey->E.n));\n\n   k = NULL;\n   dr = mpi_alloc (0);\n   sum = mpi_alloc (0);\n    {\n      do\n        {\n          mpi_free (k);\n          k = NULL;\n          if ((flags & PUBKEY_FLAG_RFC6979) && hashalgo)\n            {\n              /* Use Pornin's method for deterministic DSA.  If this\n                 flag is set, it is expected that HASH is an opaque\n                 MPI with the to be signed hash.  That hash is also\n                 used as h1 from 3.2.a.  */\n              if (!mpi_is_opaque (input))\n                {\n                  rc = GPG_ERR_CONFLICT;\n                  goto leave;\n                }\n\n              abuf = mpi_get_opaque (input, &abits);\n              rc = _gcry_dsa_gen_rfc6979_k (&k, skey->E.n, skey->d,\n                                            abuf, (abits+7)/8,\n                                            hashalgo, extraloops);\n              if (rc)\n                goto leave;\n              extraloops++;\n            }\n          else\n            k = _gcry_dsa_gen_k (skey->E.n, GCRY_STRONG_RANDOM);\n\n          _gcry_mpi_ec_mul_point (&I, k, &skey->E.G, ctx);\n          if (_gcry_mpi_ec_get_affine (x, NULL, &I, ctx))\n            {\n              if (DBG_CIPHER)\n                log_debug (\"ecc sign: Failed to get affine coordinates\\n\");\n              rc = GPG_ERR_BAD_SIGNATURE;\n              goto leave;\n            }\n          mpi_mod (r, x, skey->E.n);  /* r = x mod n */\n        }\n      while (!mpi_cmp_ui (r, 0));\n\n      mpi_mulm (dr, skey->d, r, skey->E.n); /* dr = d*r mod n  */\n      mpi_addm (sum, hash, dr, skey->E.n);  /* sum = hash + (d*r) mod n  */\n      mpi_invm (k_1, k, skey->E.n);         /* k_1 = k^(-1) mod n  */\n      mpi_mulm (s, k_1, sum, skey->E.n);    /* s = k^(-1)*(hash+(d*r)) mod n */\n    }\n  while (!mpi_cmp_ui (s, 0));\n\n  if (DBG_CIPHER)\n         }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141632,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": " static int mp_get_count(struct sb_uart_state *state, struct serial_icounter_struct *icnt)\n {\n\tstruct serial_icounter_struct icount;\n \tstruct sb_uart_icount cnow;\n \tstruct sb_uart_port *port = state->port;\n \n\tspin_lock_irq(&port->lock);\n\tmemcpy(&cnow, &port->icount, sizeof(struct sb_uart_icount));\n\tspin_unlock_irq(&port->lock);\n\n\ticount.cts         = cnow.cts;\n\ticount.dsr         = cnow.dsr;\n\ticount.rng         = cnow.rng;\n\ticount.dcd         = cnow.dcd;\n\ticount.rx          = cnow.rx;\n\ticount.tx          = cnow.tx;\n\ticount.frame       = cnow.frame;\n\ticount.overrun     = cnow.overrun;\n\ticount.parity      = cnow.parity;\n\ticount.brk         = cnow.brk;\n\ticount.buf_overrun = cnow.buf_overrun;\n\n\treturn copy_to_user(icnt, &icount, sizeof(icount)) ? -EFAULT : 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141739,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": " static int mp_get_count(struct sb_uart_state *state, struct serial_icounter_struct *icnt)\n {\n\tstruct serial_icounter_struct icount = {};\n \tstruct sb_uart_icount cnow;\n \tstruct sb_uart_port *port = state->port;\n \n\tspin_lock_irq(&port->lock);\n\tmemcpy(&cnow, &port->icount, sizeof(struct sb_uart_icount));\n\tspin_unlock_irq(&port->lock);\n\n\ticount.cts         = cnow.cts;\n\ticount.dsr         = cnow.dsr;\n\ticount.rng         = cnow.rng;\n\ticount.dcd         = cnow.dcd;\n\ticount.rx          = cnow.rx;\n\ticount.tx          = cnow.tx;\n\ticount.frame       = cnow.frame;\n\ticount.overrun     = cnow.overrun;\n\ticount.parity      = cnow.parity;\n\ticount.brk         = cnow.brk;\n\ticount.buf_overrun = cnow.buf_overrun;\n\n\treturn copy_to_user(icnt, &icount, sizeof(icount)) ? -EFAULT : 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141740,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static long bcm_char_ioctl(struct file *filp, UINT cmd, ULONG arg)\n{\n\tstruct bcm_tarang_data *pTarang = filp->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\tstruct bcm_mini_adapter *Adapter = pTarang->Adapter;\n\tINT Status = STATUS_FAILURE;\n\tint timeout = 0;\n\tstruct bcm_ioctl_buffer IoBuffer;\n\tint bytes;\n\n\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Parameters Passed to control IOCTL cmd=0x%X arg=0x%lX\", cmd, arg);\n\n\tif (_IOC_TYPE(cmd) != BCM_IOCTL)\n\t\treturn -EFAULT;\n\tif (_IOC_DIR(cmd) & _IOC_READ)\n\t\tStatus = !access_ok(VERIFY_WRITE, argp, _IOC_SIZE(cmd));\n\telse if (_IOC_DIR(cmd) & _IOC_WRITE)\n\t\tStatus = !access_ok(VERIFY_READ, argp, _IOC_SIZE(cmd));\n\telse if (_IOC_NONE == (_IOC_DIR(cmd) & _IOC_NONE))\n\t\tStatus = STATUS_SUCCESS;\n\n\tif (Status)\n\t\treturn -EFAULT;\n\n\tif (Adapter->device_removed)\n\t\treturn -EFAULT;\n\n\tif (FALSE == Adapter->fw_download_done) {\n\t\tswitch (cmd) {\n\t\tcase IOCTL_MAC_ADDR_REQ:\n\t\tcase IOCTL_LINK_REQ:\n\t\tcase IOCTL_CM_REQUEST:\n\t\tcase IOCTL_SS_INFO_REQ:\n\t\tcase IOCTL_SEND_CONTROL_MESSAGE:\n\t\tcase IOCTL_IDLE_REQ:\n\t\tcase IOCTL_BCM_GPIO_SET_REQUEST:\n\t\tcase IOCTL_BCM_GPIO_STATUS_REQUEST:\n\t\t\treturn -EACCES;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tStatus = vendorextnIoctl(Adapter, cmd, arg);\n\tif (Status != CONTINUE_COMMON_PATH)\n\t\treturn Status;\n\n\tswitch (cmd) {\n\t/* Rdms for Swin Idle... */\n\tcase IOCTL_BCM_REGISTER_READ_PRIVATE: {\n\t\tstruct bcm_rdm_buffer sRdmBuffer = {0};\n\t\tPCHAR temp_buff;\n\t\tUINT Bufflen;\n\t\tu16 temp_value;\n\n\t\t/* Copy Ioctl Buffer structure */\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (IoBuffer.InputLength > sizeof(sRdmBuffer))\n\t\t\treturn -EINVAL;\n\n\t\tif (copy_from_user(&sRdmBuffer, IoBuffer.InputBuffer, IoBuffer.InputLength))\n\t\t\treturn -EFAULT;\n\n\t\tif (IoBuffer.OutputLength > USHRT_MAX ||\n\t\t\tIoBuffer.OutputLength == 0) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tBufflen = IoBuffer.OutputLength;\n\t\ttemp_value = 4 - (Bufflen % 4);\n\t\tBufflen += temp_value % 4;\n\n\t\ttemp_buff = kmalloc(Bufflen, GFP_KERNEL);\n\t\tif (!temp_buff)\n\t\t\treturn -ENOMEM;\n\n\t\tbytes = rdmalt(Adapter, (UINT)sRdmBuffer.Register,\n\t\t\t\t(PUINT)temp_buff, Bufflen);\n\t\tif (bytes > 0) {\n\t\t\tStatus = STATUS_SUCCESS;\n\t\t\tif (copy_to_user(IoBuffer.OutputBuffer, temp_buff, bytes)) {\n\t\t\t\tkfree(temp_buff);\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t} else {\n\t\t\tStatus = bytes;\n\t\t}\n\n\t\tkfree(temp_buff);\n\t\tbreak;\n\t}\n\n\tcase IOCTL_BCM_REGISTER_WRITE_PRIVATE: {\n\t\tstruct bcm_wrm_buffer sWrmBuffer = {0};\n\t\tUINT uiTempVar = 0;\n\t\t/* Copy Ioctl Buffer structure */\n\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (IoBuffer.InputLength > sizeof(sWrmBuffer))\n\t\t\treturn -EINVAL;\n\n\t\t/* Get WrmBuffer structure */\n\t\tif (copy_from_user(&sWrmBuffer, IoBuffer.InputBuffer, IoBuffer.InputLength))\n\t\t\treturn -EFAULT;\n\n\t\tuiTempVar = sWrmBuffer.Register & EEPROM_REJECT_MASK;\n\t\tif (!((Adapter->pstargetparams->m_u32Customize) & VSG_MODE) &&\n\t\t\t((uiTempVar == EEPROM_REJECT_REG_1) ||\n\t\t\t\t(uiTempVar == EEPROM_REJECT_REG_2) ||\n\t\t\t\t(uiTempVar == EEPROM_REJECT_REG_3) ||\n\t\t\t\t(uiTempVar == EEPROM_REJECT_REG_4))) {\n\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"EEPROM Access Denied, not in VSG Mode\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tStatus = wrmalt(Adapter, (UINT)sWrmBuffer.Register,\n\t\t\t\t(PUINT)sWrmBuffer.Data, sizeof(ULONG));\n\n\t\tif (Status == STATUS_SUCCESS) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"WRM Done\\n\");\n\t\t} else {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"WRM Failed\\n\");\n\t\t\tStatus = -EFAULT;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase IOCTL_BCM_REGISTER_READ:\n\tcase IOCTL_BCM_EEPROM_REGISTER_READ: {\n\t\tstruct bcm_rdm_buffer sRdmBuffer = {0};\n\t\tPCHAR temp_buff = NULL;\n\t\tUINT uiTempVar = 0;\n\t\tif ((Adapter->IdleMode == TRUE) ||\n\t\t\t(Adapter->bShutStatus == TRUE) ||\n\t\t\t(Adapter->bPreparingForLowPowerMode == TRUE)) {\n\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Device in Idle Mode, Blocking Rdms\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\t/* Copy Ioctl Buffer structure */\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (IoBuffer.InputLength > sizeof(sRdmBuffer))\n\t\t\treturn -EINVAL;\n\n\t\tif (copy_from_user(&sRdmBuffer, IoBuffer.InputBuffer, IoBuffer.InputLength))\n\t\t\treturn -EFAULT;\n\n\t\tif (IoBuffer.OutputLength > USHRT_MAX ||\n\t\t\tIoBuffer.OutputLength == 0) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\ttemp_buff = kmalloc(IoBuffer.OutputLength, GFP_KERNEL);\n\t\tif (!temp_buff)\n\t\t\treturn STATUS_FAILURE;\n\n\t\tif ((((ULONG)sRdmBuffer.Register & 0x0F000000) != 0x0F000000) ||\n\t\t\t((ULONG)sRdmBuffer.Register & 0x3)) {\n\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"RDM Done On invalid Address : %x Access Denied.\\n\",\n\t\t\t\t\t(int)sRdmBuffer.Register);\n\n\t\t\tkfree(temp_buff);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tuiTempVar = sRdmBuffer.Register & EEPROM_REJECT_MASK;\n\t\tbytes = rdmaltWithLock(Adapter, (UINT)sRdmBuffer.Register, (PUINT)temp_buff, IoBuffer.OutputLength);\n\n\t\tif (bytes > 0) {\n\t\t\tStatus = STATUS_SUCCESS;\n\t\t\tif (copy_to_user(IoBuffer.OutputBuffer, temp_buff, bytes)) {\n\t\t\t\tkfree(temp_buff);\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t} else {\n\t\t\tStatus = bytes;\n\t\t}\n\n\t\tkfree(temp_buff);\n\t\tbreak;\n\t}\n\tcase IOCTL_BCM_REGISTER_WRITE:\n\tcase IOCTL_BCM_EEPROM_REGISTER_WRITE: {\n\t\tstruct bcm_wrm_buffer sWrmBuffer = {0};\n\t\tUINT uiTempVar = 0;\n\n\t\tif ((Adapter->IdleMode == TRUE) ||\n\t\t\t(Adapter->bShutStatus == TRUE) ||\n\t\t\t(Adapter->bPreparingForLowPowerMode == TRUE)) {\n\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Device in Idle Mode, Blocking Wrms\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\t/* Copy Ioctl Buffer structure */\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (IoBuffer.InputLength > sizeof(sWrmBuffer))\n\t\t\treturn -EINVAL;\n\n\t\t/* Get WrmBuffer structure */\n\t\tif (copy_from_user(&sWrmBuffer, IoBuffer.InputBuffer, IoBuffer.InputLength))\n\t\t\treturn -EFAULT;\n\n\t\tif ((((ULONG)sWrmBuffer.Register & 0x0F000000) != 0x0F000000) ||\n\t\t\t((ULONG)sWrmBuffer.Register & 0x3)) {\n\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"WRM Done On invalid Address : %x Access Denied.\\n\", (int)sWrmBuffer.Register);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tuiTempVar = sWrmBuffer.Register & EEPROM_REJECT_MASK;\n\t\tif (!((Adapter->pstargetparams->m_u32Customize) & VSG_MODE) &&\n\t\t\t\t((uiTempVar == EEPROM_REJECT_REG_1) ||\n\t\t\t\t(uiTempVar == EEPROM_REJECT_REG_2) ||\n\t\t\t\t(uiTempVar == EEPROM_REJECT_REG_3) ||\n\t\t\t\t(uiTempVar == EEPROM_REJECT_REG_4)) &&\n\t\t\t\t(cmd == IOCTL_BCM_REGISTER_WRITE)) {\n\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"EEPROM Access Denied, not in VSG Mode\\n\");\n\t\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tStatus = wrmaltWithLock(Adapter, (UINT)sWrmBuffer.Register,\n\t\t\t\t\t(PUINT)sWrmBuffer.Data, sWrmBuffer.Length);\n\n\t\tif (Status == STATUS_SUCCESS) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, OSAL_DBG, DBG_LVL_ALL, \"WRM Done\\n\");\n\t\t} else {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"WRM Failed\\n\");\n\t\t\tStatus = -EFAULT;\n\t\t}\n\t\tbreak;\n\t}\n\tcase IOCTL_BCM_GPIO_SET_REQUEST: {\n\t\tUCHAR ucResetValue[4];\n\t\tUINT value = 0;\n\t\tUINT uiBit = 0;\n\t\tUINT uiOperation = 0;\n\t\tstruct bcm_gpio_info gpio_info = {0};\n\n\t\tif ((Adapter->IdleMode == TRUE) ||\n\t\t\t(Adapter->bShutStatus == TRUE) ||\n\t\t\t(Adapter->bPreparingForLowPowerMode == TRUE)) {\n\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"GPIO Can't be set/clear in Low power Mode\");\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (IoBuffer.InputLength > sizeof(gpio_info))\n\t\t\treturn -EINVAL;\n\n\t\tif (copy_from_user(&gpio_info, IoBuffer.InputBuffer, IoBuffer.InputLength))\n\t\t\treturn -EFAULT;\n\n\t\tuiBit  = gpio_info.uiGpioNumber;\n\t\tuiOperation = gpio_info.uiGpioValue;\n\t\tvalue = (1<<uiBit);\n\n\t\tif (IsReqGpioIsLedInNVM(Adapter, value) == FALSE) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Sorry, Requested GPIO<0x%X> is not correspond to LED !!!\", value);\n\t\t\tStatus = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Set - setting 1 */\n\t\tif (uiOperation) {\n\t\t\t/* Set the gpio output register */\n\t\t\tStatus = wrmaltWithLock(Adapter, BCM_GPIO_OUTPUT_SET_REG, (PUINT)(&value), sizeof(UINT));\n\n\t\t\tif (Status == STATUS_SUCCESS) {\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Set the GPIO bit\\n\");\n\t\t\t} else {\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Failed to set the %dth GPIO\\n\", uiBit);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t/* Set the gpio output register */\n\t\t\tStatus = wrmaltWithLock(Adapter, BCM_GPIO_OUTPUT_CLR_REG, (PUINT)(&value), sizeof(UINT));\n\n\t\t\tif (Status == STATUS_SUCCESS) {\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Set the GPIO bit\\n\");\n\t\t\t} else {\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Failed to clear the %dth GPIO\\n\", uiBit);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tbytes = rdmaltWithLock(Adapter, (UINT)GPIO_MODE_REGISTER, (PUINT)ucResetValue, sizeof(UINT));\n\t\tif (bytes < 0) {\n\t\t\tStatus = bytes;\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,\n\t\t\t\t\t\"GPIO_MODE_REGISTER read failed\");\n\t\t\tbreak;\n\t\t} else {\n\t\t\tStatus = STATUS_SUCCESS;\n\t\t}\n\n\t\t/* Set the gpio mode register to output */\n\t\t*(UINT *)ucResetValue |= (1<<uiBit);\n\t\tStatus = wrmaltWithLock(Adapter, GPIO_MODE_REGISTER,\n\t\t\t\t\t(PUINT)ucResetValue, sizeof(UINT));\n\n\t\tif (Status == STATUS_SUCCESS) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Set the GPIO to output Mode\\n\");\n\t\t} else {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Failed to put GPIO in Output Mode\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\tbreak;\n\n\tcase BCM_LED_THREAD_STATE_CHANGE_REQ: {\n\t\tstruct bcm_user_thread_req threadReq = {0};\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"User made LED thread InActive\");\n\n\t\tif ((Adapter->IdleMode == TRUE) ||\n\t\t\t(Adapter->bShutStatus == TRUE) ||\n\t\t\t(Adapter->bPreparingForLowPowerMode == TRUE)) {\n\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"GPIO Can't be set/clear in Low power Mode\");\n\t\t\tStatus = -EACCES;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (IoBuffer.InputLength > sizeof(threadReq))\n\t\t\treturn -EINVAL;\n\n\t\tif (copy_from_user(&threadReq, IoBuffer.InputBuffer, IoBuffer.InputLength))\n\t\t\treturn -EFAULT;\n\n\t\t/* if LED thread is running(Actively or Inactively) set it state to make inactive */\n\t\tif (Adapter->LEDInfo.led_thread_running) {\n\t\t\tif (threadReq.ThreadState == LED_THREAD_ACTIVATION_REQ) {\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Activating thread req\");\n\t\t\t\tAdapter->DriverState = LED_THREAD_ACTIVE;\n\t\t\t} else {\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"DeActivating Thread req.....\");\n\t\t\t\tAdapter->DriverState = LED_THREAD_INACTIVE;\n\t\t\t}\n\n\t\t\t/* signal thread. */\n\t\t\twake_up(&Adapter->LEDInfo.notify_led_event);\n\t\t}\n\t}\n\tbreak;\n\n\tcase IOCTL_BCM_GPIO_STATUS_REQUEST: {\n\t\tULONG uiBit = 0;\n\t\tUCHAR ucRead[4];\n\t\tstruct bcm_gpio_info gpio_info = {0};\n\n\t\tif ((Adapter->IdleMode == TRUE) ||\n\t\t\t(Adapter->bShutStatus == TRUE) ||\n\t\t\t(Adapter->bPreparingForLowPowerMode == TRUE))\n\t\t\treturn -EACCES;\n\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (IoBuffer.InputLength > sizeof(gpio_info))\n\t\t\treturn -EINVAL;\n\n\t\tif (copy_from_user(&gpio_info, IoBuffer.InputBuffer, IoBuffer.InputLength))\n\t\t\treturn -EFAULT;\n\n\t\tuiBit = gpio_info.uiGpioNumber;\n\n\t\t/* Set the gpio output register */\n\t\tbytes = rdmaltWithLock(Adapter, (UINT)GPIO_PIN_STATE_REGISTER,\n\t\t\t\t\t(PUINT)ucRead, sizeof(UINT));\n\n\t\tif (bytes < 0) {\n\t\t\tStatus = bytes;\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"RDM Failed\\n\");\n\t\t\treturn Status;\n\t\t} else {\n\t\t\tStatus = STATUS_SUCCESS;\n\t\t}\n\t}\n\tbreak;\n\n\tcase IOCTL_BCM_GPIO_MULTI_REQUEST: {\n\t\tUCHAR ucResetValue[4];\n\t\tstruct bcm_gpio_multi_info gpio_multi_info[MAX_IDX];\n\t\tstruct bcm_gpio_multi_info *pgpio_multi_info = (struct bcm_gpio_multi_info *)gpio_multi_info;\n\n\t\tmemset(pgpio_multi_info, 0, MAX_IDX * sizeof(struct bcm_gpio_multi_info));\n\n\t\tif ((Adapter->IdleMode == TRUE) ||\n\t\t\t(Adapter->bShutStatus == TRUE) ||\n\t\t\t(Adapter->bPreparingForLowPowerMode == TRUE))\n\t\t\treturn -EINVAL;\n\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (IoBuffer.InputLength > sizeof(gpio_multi_info))\n\t\t\treturn -EINVAL;\n\n\t\tif (copy_from_user(&gpio_multi_info, IoBuffer.InputBuffer, IoBuffer.InputLength))\n\t\t\treturn -EFAULT;\n\n\t\tif (IsReqGpioIsLedInNVM(Adapter, pgpio_multi_info[WIMAX_IDX].uiGPIOMask) == FALSE) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,\n\t\t\t\t\t\"Sorry, Requested GPIO<0x%X> is not correspond to NVM LED bit map<0x%X>!!!\",\n\t\t\t\t\tpgpio_multi_info[WIMAX_IDX].uiGPIOMask, Adapter->gpioBitMap);\n\t\t\tStatus = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Set the gpio output register */\n\t\tif ((pgpio_multi_info[WIMAX_IDX].uiGPIOMask) &\n\t\t\t(pgpio_multi_info[WIMAX_IDX].uiGPIOCommand)) {\n\t\t\t/* Set 1's in GPIO OUTPUT REGISTER */\n\t\t\t*(UINT *)ucResetValue =  pgpio_multi_info[WIMAX_IDX].uiGPIOMask &\n\t\t\t\tpgpio_multi_info[WIMAX_IDX].uiGPIOCommand &\n\t\t\t\tpgpio_multi_info[WIMAX_IDX].uiGPIOValue;\n\n\t\t\tif (*(UINT *) ucResetValue)\n\t\t\t\tStatus = wrmaltWithLock(Adapter, BCM_GPIO_OUTPUT_SET_REG,\n\t\t\t\t\t\t\t(PUINT)ucResetValue, sizeof(ULONG));\n\n\t\t\tif (Status != STATUS_SUCCESS) {\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"WRM to BCM_GPIO_OUTPUT_SET_REG Failed.\");\n\t\t\t\treturn Status;\n\t\t\t}\n\n\t\t\t/* Clear to 0's in GPIO OUTPUT REGISTER */\n\t\t\t*(UINT *)ucResetValue = (pgpio_multi_info[WIMAX_IDX].uiGPIOMask &\n\t\t\t\t\t\tpgpio_multi_info[WIMAX_IDX].uiGPIOCommand &\n\t\t\t\t\t\t(~(pgpio_multi_info[WIMAX_IDX].uiGPIOValue)));\n\n\t\t\tif (*(UINT *) ucResetValue)\n\t\t\t\tStatus = wrmaltWithLock(Adapter, BCM_GPIO_OUTPUT_CLR_REG, (PUINT)ucResetValue, sizeof(ULONG));\n\n\t\t\tif (Status != STATUS_SUCCESS) {\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"WRM to BCM_GPIO_OUTPUT_CLR_REG Failed.\");\n\t\t\t\treturn Status;\n\t\t\t}\n\t\t}\n\n\t\tif (pgpio_multi_info[WIMAX_IDX].uiGPIOMask) {\n\t\t\tbytes = rdmaltWithLock(Adapter, (UINT)GPIO_PIN_STATE_REGISTER, (PUINT)ucResetValue, sizeof(UINT));\n\n\t\t\tif (bytes < 0) {\n\t\t\t\tStatus = bytes;\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"RDM to GPIO_PIN_STATE_REGISTER Failed.\");\n\t\t\t\treturn Status;\n\t\t\t} else {\n\t\t\t\tStatus = STATUS_SUCCESS;\n\t\t\t}\n\n\t\t\tpgpio_multi_info[WIMAX_IDX].uiGPIOValue = (*(UINT *)ucResetValue &\n\t\t\t\t\t\t\t\tpgpio_multi_info[WIMAX_IDX].uiGPIOMask);\n\t\t}\n\n\t\tStatus = copy_to_user(IoBuffer.OutputBuffer, &gpio_multi_info, IoBuffer.OutputLength);\n\t\tif (Status) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,\n\t\t\t\t\t\"Failed while copying Content to IOBufer for user space err:%d\", Status);\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\tbreak;\n\n\tcase IOCTL_BCM_GPIO_MODE_REQUEST: {\n\t\tUCHAR ucResetValue[4];\n\t\tstruct bcm_gpio_multi_mode gpio_multi_mode[MAX_IDX];\n\t\tstruct bcm_gpio_multi_mode *pgpio_multi_mode = (struct bcm_gpio_multi_mode *)gpio_multi_mode;\n\n\t\tif ((Adapter->IdleMode == TRUE) ||\n\t\t\t(Adapter->bShutStatus == TRUE) ||\n\t\t\t(Adapter->bPreparingForLowPowerMode == TRUE))\n\t\t\treturn -EINVAL;\n\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (IoBuffer.InputLength > sizeof(gpio_multi_mode))\n\t\t\treturn -EINVAL;\n\n\t\tif (copy_from_user(&gpio_multi_mode, IoBuffer.InputBuffer, IoBuffer.InputLength))\n\t\t\treturn -EFAULT;\n\n\t\tbytes = rdmaltWithLock(Adapter, (UINT)GPIO_MODE_REGISTER, (PUINT)ucResetValue, sizeof(UINT));\n\n\t\tif (bytes < 0) {\n\t\t\tStatus = bytes;\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Read of GPIO_MODE_REGISTER failed\");\n\t\t\treturn Status;\n\t\t} else {\n\t\t\tStatus = STATUS_SUCCESS;\n\t\t}\n\n\t\t/* Validating the request */\n\t\tif (IsReqGpioIsLedInNVM(Adapter, pgpio_multi_mode[WIMAX_IDX].uiGPIOMask) == FALSE) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,\n\t\t\t\t\t\"Sorry, Requested GPIO<0x%X> is not correspond to NVM LED bit map<0x%X>!!!\",\n\t\t\t\t\tpgpio_multi_mode[WIMAX_IDX].uiGPIOMask, Adapter->gpioBitMap);\n\t\t\tStatus = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (pgpio_multi_mode[WIMAX_IDX].uiGPIOMask) {\n\t\t\t/* write all OUT's (1's) */\n\t\t\t*(UINT *) ucResetValue |= (pgpio_multi_mode[WIMAX_IDX].uiGPIOMode &\n\t\t\t\t\t\tpgpio_multi_mode[WIMAX_IDX].uiGPIOMask);\n\n\t\t\t/* write all IN's (0's) */\n\t\t\t*(UINT *) ucResetValue &= ~((~pgpio_multi_mode[WIMAX_IDX].uiGPIOMode) &\n\t\t\t\t\t\tpgpio_multi_mode[WIMAX_IDX].uiGPIOMask);\n\n\t\t\t/* Currently implemented return the modes of all GPIO's\n\t\t\t * else needs to bit AND with  mask\n\t\t\t */\n\t\t\tpgpio_multi_mode[WIMAX_IDX].uiGPIOMode = *(UINT *)ucResetValue;\n\n\t\t\tStatus = wrmaltWithLock(Adapter, GPIO_MODE_REGISTER, (PUINT)ucResetValue, sizeof(ULONG));\n\t\t\tif (Status == STATUS_SUCCESS) {\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,\n\t\t\t\t\t\t\"WRM to GPIO_MODE_REGISTER Done\");\n\t\t\t} else {\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,\n\t\t\t\t\t\t\"WRM to GPIO_MODE_REGISTER Failed\");\n\t\t\t\tStatus = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n/* if uiGPIOMask is 0 then return mode register configuration */\n\t\t\tpgpio_multi_mode[WIMAX_IDX].uiGPIOMode = *(UINT *)ucResetValue;\n\t\t}\n\n\t\tStatus = copy_to_user(IoBuffer.OutputBuffer, &gpio_multi_mode, IoBuffer.OutputLength);\n\t\tif (Status) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,\n\t\t\t\t\t\"Failed while copying Content to IOBufer for user space err:%d\", Status);\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\tbreak;\n\n\tcase IOCTL_MAC_ADDR_REQ:\n\tcase IOCTL_LINK_REQ:\n\tcase IOCTL_CM_REQUEST:\n\tcase IOCTL_SS_INFO_REQ:\n\tcase IOCTL_SEND_CONTROL_MESSAGE:\n\tcase IOCTL_IDLE_REQ: {\n\t\tPVOID pvBuffer = NULL;\n\n\t\t/* Copy Ioctl Buffer structure */\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (IoBuffer.InputLength < sizeof(struct bcm_link_request))\n\t\t\treturn -EINVAL;\n\n\t\tif (IoBuffer.InputLength > MAX_CNTL_PKT_SIZE)\n\t\t\treturn -EINVAL;\n\n\t\tpvBuffer = memdup_user(IoBuffer.InputBuffer,\n\t\t\t\t       IoBuffer.InputLength);\n\t\tif (IS_ERR(pvBuffer))\n\t\t\treturn PTR_ERR(pvBuffer);\n\n\t\tdown(&Adapter->LowPowerModeSync);\n\t\tStatus = wait_event_interruptible_timeout(Adapter->lowpower_mode_wait_queue,\n\t\t\t\t\t\t\t!Adapter->bPreparingForLowPowerMode,\n\t\t\t\t\t\t\t(1 * HZ));\n\t\tif (Status == -ERESTARTSYS)\n\t\t\tgoto cntrlEnd;\n\n\t\tif (Adapter->bPreparingForLowPowerMode) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,\n\t\t\t\t\t\"Preparing Idle Mode is still True - Hence Rejecting control message\\n\");\n\t\t\tStatus = STATUS_FAILURE;\n\t\t\tgoto cntrlEnd;\n\t\t}\n\t\tStatus = CopyBufferToControlPacket(Adapter, (PVOID)pvBuffer);\n\ncntrlEnd:\n\t\tup(&Adapter->LowPowerModeSync);\n\t\tkfree(pvBuffer);\n\t\tbreak;\n\t}\n\n\tcase IOCTL_BCM_BUFFER_DOWNLOAD_START: {\n\t\tif (down_trylock(&Adapter->NVMRdmWrmLock)) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,\n\t\t\t\t\t\"IOCTL_BCM_CHIP_RESET not allowed as EEPROM Read/Write is in progress\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,\n\t\t\t\t\"Starting the firmware download PID =0x%x!!!!\\n\", current->pid);\n\n\t\tif (down_trylock(&Adapter->fw_download_sema))\n\t\t\treturn -EBUSY;\n\n\t\tAdapter->bBinDownloaded = FALSE;\n\t\tAdapter->fw_download_process_pid = current->pid;\n\t\tAdapter->bCfgDownloaded = FALSE;\n\t\tAdapter->fw_download_done = FALSE;\n\t\tnetif_carrier_off(Adapter->dev);\n\t\tnetif_stop_queue(Adapter->dev);\n\t\tStatus = reset_card_proc(Adapter);\n\t\tif (Status) {\n\t\t\tpr_err(PFX \"%s: reset_card_proc Failed!\\n\", Adapter->dev->name);\n\t\t\tup(&Adapter->fw_download_sema);\n\t\t\tup(&Adapter->NVMRdmWrmLock);\n\t\t\treturn Status;\n\t\t}\n\t\tmdelay(10);\n\n\t\tup(&Adapter->NVMRdmWrmLock);\n\t\treturn Status;\n\t}\n\n\tcase IOCTL_BCM_BUFFER_DOWNLOAD: {\n\t\tstruct bcm_firmware_info *psFwInfo = NULL;\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Starting the firmware download PID =0x%x!!!!\\n\", current->pid);\n\n\t\tif (!down_trylock(&Adapter->fw_download_sema)) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,\n\t\t\t\t\t\"Invalid way to download buffer. Use Start and then call this!!!\\n\");\n\t\t\tup(&Adapter->fw_download_sema);\n\t\t\tStatus = -EINVAL;\n\t\t\treturn Status;\n\t\t}\n\n\t\t/* Copy Ioctl Buffer structure */\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer))) {\n\t\t\tup(&Adapter->fw_download_sema);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,\n\t\t\t\t\"Length for FW DLD is : %lx\\n\", IoBuffer.InputLength);\n\n\t\tif (IoBuffer.InputLength > sizeof(struct bcm_firmware_info)) {\n\t\t\tup(&Adapter->fw_download_sema);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tpsFwInfo = kmalloc(sizeof(*psFwInfo), GFP_KERNEL);\n\t\tif (!psFwInfo) {\n\t\t\tup(&Adapter->fw_download_sema);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (copy_from_user(psFwInfo, IoBuffer.InputBuffer, IoBuffer.InputLength)) {\n\t\t\tup(&Adapter->fw_download_sema);\n\t\t\tkfree(psFwInfo);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tif (!psFwInfo->pvMappedFirmwareAddress ||\n\t\t\t(psFwInfo->u32FirmwareLength == 0)) {\n\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Something else is wrong %lu\\n\",\n\t\t\t\t\tpsFwInfo->u32FirmwareLength);\n\t\t\tup(&Adapter->fw_download_sema);\n\t\t\tkfree(psFwInfo);\n\t\t\tStatus = -EINVAL;\n\t\t\treturn Status;\n\t\t}\n\n\t\tStatus = bcm_ioctl_fw_download(Adapter, psFwInfo);\n\n\t\tif (Status != STATUS_SUCCESS) {\n\t\t\tif (psFwInfo->u32StartingAddress == CONFIG_BEGIN_ADDR)\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"IOCTL: Configuration File Upload Failed\\n\");\n\t\t\telse\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,\t\"IOCTL: Firmware File Upload Failed\\n\");\n\n\t\t\t/* up(&Adapter->fw_download_sema); */\n\n\t\t\tif (Adapter->LEDInfo.led_thread_running & BCM_LED_THREAD_RUNNING_ACTIVELY) {\n\t\t\t\tAdapter->DriverState = DRIVER_INIT;\n\t\t\t\tAdapter->LEDInfo.bLedInitDone = FALSE;\n\t\t\t\twake_up(&Adapter->LEDInfo.notify_led_event);\n\t\t\t}\n\t\t}\n\n\t\tif (Status != STATUS_SUCCESS)\n\t\t\tup(&Adapter->fw_download_sema);\n\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, OSAL_DBG, DBG_LVL_ALL, \"IOCTL: Firmware File Uploaded\\n\");\n\t\tkfree(psFwInfo);\n\t\treturn Status;\n\t}\n\n\tcase IOCTL_BCM_BUFFER_DOWNLOAD_STOP: {\n\t\tif (!down_trylock(&Adapter->fw_download_sema)) {\n\t\t\tup(&Adapter->fw_download_sema);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (down_trylock(&Adapter->NVMRdmWrmLock)) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,\n\t\t\t\t\t\"FW download blocked as EEPROM Read/Write is in progress\\n\");\n\t\t\tup(&Adapter->fw_download_sema);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tAdapter->bBinDownloaded = TRUE;\n\t\tAdapter->bCfgDownloaded = TRUE;\n\t\tatomic_set(&Adapter->CurrNumFreeTxDesc, 0);\n\t\tAdapter->CurrNumRecvDescs = 0;\n\t\tAdapter->downloadDDR = 0;\n\n\t\t/* setting the Mips to Run */\n\t\tStatus = run_card_proc(Adapter);\n\n\t\tif (Status) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Firm Download Failed\\n\");\n\t\t\tup(&Adapter->fw_download_sema);\n\t\t\tup(&Adapter->NVMRdmWrmLock);\n\t\t\treturn Status;\n\t\t} else {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG,\n\t\t\t\t\tDBG_LVL_ALL, \"Firm Download Over...\\n\");\n\t\t}\n\n\t\tmdelay(10);\n\n\t\t/* Wait for MailBox Interrupt */\n\t\tif (StartInterruptUrb((struct bcm_interface_adapter *)Adapter->pvInterfaceAdapter))\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Unable to send interrupt...\\n\");\n\n\t\ttimeout = 5*HZ;\n\t\tAdapter->waiting_to_fw_download_done = FALSE;\n\t\twait_event_timeout(Adapter->ioctl_fw_dnld_wait_queue,\n\t\t\t\tAdapter->waiting_to_fw_download_done, timeout);\n\t\tAdapter->fw_download_process_pid = INVALID_PID;\n\t\tAdapter->fw_download_done = TRUE;\n\t\tatomic_set(&Adapter->CurrNumFreeTxDesc, 0);\n\t\tAdapter->CurrNumRecvDescs = 0;\n\t\tAdapter->PrevNumRecvDescs = 0;\n\t\tatomic_set(&Adapter->cntrlpktCnt, 0);\n\t\tAdapter->LinkUpStatus = 0;\n\t\tAdapter->LinkStatus = 0;\n\n\t\tif (Adapter->LEDInfo.led_thread_running & BCM_LED_THREAD_RUNNING_ACTIVELY) {\n\t\t\tAdapter->DriverState = FW_DOWNLOAD_DONE;\n\t\t\twake_up(&Adapter->LEDInfo.notify_led_event);\n\t\t}\n\n\t\tif (!timeout)\n\t\t\tStatus = -ENODEV;\n\n\t\tup(&Adapter->fw_download_sema);\n\t\tup(&Adapter->NVMRdmWrmLock);\n\t\treturn Status;\n\t}\n\n\tcase IOCTL_BE_BUCKET_SIZE:\n\t\tStatus = 0;\n\t\tif (get_user(Adapter->BEBucketSize, (unsigned long __user *)arg))\n\t\t\tStatus = -EFAULT;\n\t\tbreak;\n\n\tcase IOCTL_RTPS_BUCKET_SIZE:\n\t\tStatus = 0;\n\t\tif (get_user(Adapter->rtPSBucketSize, (unsigned long __user *)arg))\n\t\t\tStatus = -EFAULT;\n\t\tbreak;\n\n\tcase IOCTL_CHIP_RESET: {\n\t\tINT NVMAccess = down_trylock(&Adapter->NVMRdmWrmLock);\n\t\tif (NVMAccess) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \" IOCTL_BCM_CHIP_RESET not allowed as EEPROM Read/Write is in progress\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tdown(&Adapter->RxAppControlQueuelock);\n\t\tStatus = reset_card_proc(Adapter);\n\t\tflushAllAppQ();\n\t\tup(&Adapter->RxAppControlQueuelock);\n\t\tup(&Adapter->NVMRdmWrmLock);\n\t\tResetCounters(Adapter);\n\t\tbreak;\n\t}\n\n\tcase IOCTL_QOS_THRESHOLD: {\n\t\tUSHORT uiLoopIndex;\n\n\t\tStatus = 0;\n\t\tfor (uiLoopIndex = 0; uiLoopIndex < NO_OF_QUEUES; uiLoopIndex++) {\n\t\t\tif (get_user(Adapter->PackInfo[uiLoopIndex].uiThreshold,\n\t\t\t\t\t(unsigned long __user *)arg)) {\n\t\t\t\tStatus = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase IOCTL_DUMP_PACKET_INFO:\n\t\tDumpPackInfo(Adapter);\n\t\tDumpPhsRules(&Adapter->stBCMPhsContext);\n\t\tStatus = STATUS_SUCCESS;\n\t\tbreak;\n\n\tcase IOCTL_GET_PACK_INFO:\n\t\tif (copy_to_user(argp, &Adapter->PackInfo, sizeof(struct bcm_packet_info)*NO_OF_QUEUES))\n\t\t\treturn -EFAULT;\n\t\tStatus = STATUS_SUCCESS;\n\t\tbreak;\n\n\tcase IOCTL_BCM_SWITCH_TRANSFER_MODE: {\n\t\tUINT uiData = 0;\n\t\tif (copy_from_user(&uiData, argp, sizeof(UINT)))\n\t\t\treturn -EFAULT;\n\n\t\tif (uiData) {\n\t\t\t/* Allow All Packets */\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"IOCTL_BCM_SWITCH_TRANSFER_MODE: ETH_PACKET_TUNNELING_MODE\\n\");\n\t\t\t\tAdapter->TransferMode = ETH_PACKET_TUNNELING_MODE;\n\t\t} else {\n\t\t\t/* Allow IP only Packets */\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"IOCTL_BCM_SWITCH_TRANSFER_MODE: IP_PACKET_ONLY_MODE\\n\");\n\t\t\tAdapter->TransferMode = IP_PACKET_ONLY_MODE;\n\t\t}\n\t\tStatus = STATUS_SUCCESS;\n\t\tbreak;\n\t}\n\n\tcase IOCTL_BCM_GET_DRIVER_VERSION: {\n\t\tulong len;\n\n\t\t/* Copy Ioctl Buffer structure */\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tlen = min_t(ulong, IoBuffer.OutputLength, strlen(DRV_VERSION) + 1);\n\n\t\tif (copy_to_user(IoBuffer.OutputBuffer, DRV_VERSION, len))\n\t\t\treturn -EFAULT;\n\t\tStatus = STATUS_SUCCESS;\n\t\tbreak;\n\t}\n\n\tcase IOCTL_BCM_GET_CURRENT_STATUS: {\n\t\tstruct bcm_link_state link_state;\n\n\t\t/* Copy Ioctl Buffer structure */\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer))) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"copy_from_user failed..\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tif (IoBuffer.OutputLength != sizeof(link_state)) {\n\t\t\tStatus = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tmemset(&link_state, 0, sizeof(link_state));\n\t\tlink_state.bIdleMode = Adapter->IdleMode;\n\t\tlink_state.bShutdownMode = Adapter->bShutStatus;\n\t\tlink_state.ucLinkStatus = Adapter->LinkStatus;\n\n\t\tif (copy_to_user(IoBuffer.OutputBuffer, &link_state, min_t(size_t, sizeof(link_state), IoBuffer.OutputLength))) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Copy_to_user Failed..\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tStatus = STATUS_SUCCESS;\n\t\tbreak;\n\t}\n\n\tcase IOCTL_BCM_SET_MAC_TRACING: {\n\t\tUINT  tracing_flag;\n\n\t\t/* copy ioctl Buffer structure */\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (copy_from_user(&tracing_flag, IoBuffer.InputBuffer, sizeof(UINT)))\n\t\t\treturn -EFAULT;\n\n\t\tif (tracing_flag)\n\t\t\tAdapter->pTarangs->MacTracingEnabled = TRUE;\n\t\telse\n\t\t\tAdapter->pTarangs->MacTracingEnabled = FALSE;\n\t\tbreak;\n\t}\n\n\tcase IOCTL_BCM_GET_DSX_INDICATION: {\n\t\tULONG ulSFId = 0;\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (IoBuffer.OutputLength < sizeof(struct bcm_add_indication_alt)) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,\n\t\t\t\t\t\"Mismatch req: %lx needed is =0x%zx!!!\",\n\t\t\t\t\tIoBuffer.OutputLength, sizeof(struct bcm_add_indication_alt));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (copy_from_user(&ulSFId, IoBuffer.InputBuffer, sizeof(ulSFId)))\n\t\t\treturn -EFAULT;\n\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Get DSX Data SF ID is =%lx\\n\", ulSFId);\n\t\tget_dsx_sf_data_to_application(Adapter, ulSFId, IoBuffer.OutputBuffer);\n\t\tStatus = STATUS_SUCCESS;\n\t}\n\tbreak;\n\n\tcase IOCTL_BCM_GET_HOST_MIBS: {\n\t\tPVOID temp_buff;\n\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (IoBuffer.OutputLength != sizeof(struct bcm_host_stats_mibs)) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,\n\t\t\t\t\t\"Length Check failed %lu %zd\\n\",\n\t\t\t\t\tIoBuffer.OutputLength, sizeof(struct bcm_host_stats_mibs));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* FIXME: HOST_STATS are too big for kmalloc (122048)! */\n\t\ttemp_buff = kzalloc(sizeof(struct bcm_host_stats_mibs), GFP_KERNEL);\n\t\tif (!temp_buff)\n\t\t\treturn STATUS_FAILURE;\n\n\t\tStatus = ProcessGetHostMibs(Adapter, temp_buff);\n\t\tGetDroppedAppCntrlPktMibs(temp_buff, pTarang);\n\n\t\tif (Status != STATUS_FAILURE)\n\t\t\tif (copy_to_user(IoBuffer.OutputBuffer, temp_buff, sizeof(struct bcm_host_stats_mibs))) {\n\t\t\t\tkfree(temp_buff);\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\n\t\tkfree(temp_buff);\n\t\tbreak;\n\t}\n\n\tcase IOCTL_BCM_WAKE_UP_DEVICE_FROM_IDLE:\n\t\tif ((FALSE == Adapter->bTriedToWakeUpFromlowPowerMode) && (TRUE == Adapter->IdleMode)) {\n\t\t\tAdapter->usIdleModePattern = ABORT_IDLE_MODE;\n\t\t\tAdapter->bWakeUpDevice = TRUE;\n\t\t\twake_up(&Adapter->process_rx_cntrlpkt);\n\t\t}\n\n\t\tStatus = STATUS_SUCCESS;\n\t\tbreak;\n\n\tcase IOCTL_BCM_BULK_WRM: {\n\t\tstruct bcm_bulk_wrm_buffer *pBulkBuffer;\n\t\tUINT uiTempVar = 0;\n\t\tPCHAR pvBuffer = NULL;\n\n\t\tif ((Adapter->IdleMode == TRUE) ||\n\t\t\t(Adapter->bShutStatus == TRUE) ||\n\t\t\t(Adapter->bPreparingForLowPowerMode == TRUE)) {\n\n\t\t\tBCM_DEBUG_PRINT (Adapter, DBG_TYPE_PRINTK, 0, 0, \"Device in Idle/Shutdown Mode, Blocking Wrms\\n\");\n\t\t\tStatus = -EACCES;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Copy Ioctl Buffer structure */\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (IoBuffer.InputLength < sizeof(ULONG) * 2)\n\t\t\treturn -EINVAL;\n\n\t\tpvBuffer = memdup_user(IoBuffer.InputBuffer,\n\t\t\t\t       IoBuffer.InputLength);\n\t\tif (IS_ERR(pvBuffer))\n\t\t\treturn PTR_ERR(pvBuffer);\n\n\t\tpBulkBuffer = (struct bcm_bulk_wrm_buffer *)pvBuffer;\n\n\t\tif (((ULONG)pBulkBuffer->Register & 0x0F000000) != 0x0F000000 ||\n\t\t\t((ULONG)pBulkBuffer->Register & 0x3)) {\n\t\t\tBCM_DEBUG_PRINT (Adapter, DBG_TYPE_PRINTK, 0, 0, \"WRM Done On invalid Address : %x Access Denied.\\n\", (int)pBulkBuffer->Register);\n\t\t\tkfree(pvBuffer);\n\t\t\tStatus = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tuiTempVar = pBulkBuffer->Register & EEPROM_REJECT_MASK;\n\t\tif (!((Adapter->pstargetparams->m_u32Customize)&VSG_MODE) &&\n\t\t\t((uiTempVar == EEPROM_REJECT_REG_1) ||\n\t\t\t\t(uiTempVar == EEPROM_REJECT_REG_2) ||\n\t\t\t\t(uiTempVar == EEPROM_REJECT_REG_3) ||\n\t\t\t\t(uiTempVar == EEPROM_REJECT_REG_4)) &&\n\t\t\t(cmd == IOCTL_BCM_REGISTER_WRITE)) {\n\n\t\t\tkfree(pvBuffer);\n\t\t\tBCM_DEBUG_PRINT (Adapter, DBG_TYPE_PRINTK, 0, 0, \"EEPROM Access Denied, not in VSG Mode\\n\");\n\t\t\tStatus = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (pBulkBuffer->SwapEndian == FALSE)\n\t\t\tStatus = wrmWithLock(Adapter, (UINT)pBulkBuffer->Register, (PCHAR)pBulkBuffer->Values, IoBuffer.InputLength - 2*sizeof(ULONG));\n\t\telse\n\t\t\tStatus = wrmaltWithLock(Adapter, (UINT)pBulkBuffer->Register, (PUINT)pBulkBuffer->Values, IoBuffer.InputLength - 2*sizeof(ULONG));\n\n\t\tif (Status != STATUS_SUCCESS)\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"WRM Failed\\n\");\n\n\t\tkfree(pvBuffer);\n\t\tbreak;\n\t}\n\n\tcase IOCTL_BCM_GET_NVM_SIZE:\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (Adapter->eNVMType == NVM_EEPROM || Adapter->eNVMType == NVM_FLASH) {\n\t\t\tif (copy_to_user(IoBuffer.OutputBuffer, &Adapter->uiNVMDSDSize, sizeof(UINT)))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tStatus = STATUS_SUCCESS;\n\t\tbreak;\n\n\tcase IOCTL_BCM_CAL_INIT: {\n\t\tUINT uiSectorSize = 0 ;\n\t\tif (Adapter->eNVMType == NVM_FLASH) {\n\t\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tif (copy_from_user(&uiSectorSize, IoBuffer.InputBuffer, sizeof(UINT)))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tif ((uiSectorSize < MIN_SECTOR_SIZE) || (uiSectorSize > MAX_SECTOR_SIZE)) {\n\t\t\t\tif (copy_to_user(IoBuffer.OutputBuffer, &Adapter->uiSectorSize,\n\t\t\t\t\t\t\tsizeof(UINT)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t} else {\n\t\t\t\tif (IsFlash2x(Adapter)) {\n\t\t\t\t\tif (copy_to_user(IoBuffer.OutputBuffer,\t&Adapter->uiSectorSize, sizeof(UINT)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t} else {\n\t\t\t\t\tif ((TRUE == Adapter->bShutStatus) || (TRUE == Adapter->IdleMode)) {\n\t\t\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Device is in Idle/Shutdown Mode\\n\");\n\t\t\t\t\t\treturn -EACCES;\n\t\t\t\t\t}\n\n\t\t\t\t\tAdapter->uiSectorSize = uiSectorSize;\n\t\t\t\t\tBcmUpdateSectorSize(Adapter, Adapter->uiSectorSize);\n\t\t\t\t}\n\t\t\t}\n\t\t\tStatus = STATUS_SUCCESS;\n\t\t} else {\n\t\t\tStatus = STATUS_FAILURE;\n\t\t}\n\t}\n\tbreak;\n\n\tcase IOCTL_BCM_SET_DEBUG:\n#ifdef DEBUG\n\t{\n\t\tstruct bcm_user_debug_state sUserDebugState;\n\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"In SET_DEBUG ioctl\\n\");\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (copy_from_user(&sUserDebugState, IoBuffer.InputBuffer, sizeof(struct bcm_user_debug_state)))\n\t\t\treturn -EFAULT;\n\n\t\tBCM_DEBUG_PRINT (Adapter, DBG_TYPE_PRINTK, 0, 0, \"IOCTL_BCM_SET_DEBUG: OnOff=%d Type = 0x%x \",\n\t\t\t\tsUserDebugState.OnOff, sUserDebugState.Type);\n\t\t/* sUserDebugState.Subtype <<= 1; */\n\t\tsUserDebugState.Subtype = 1 << sUserDebugState.Subtype;\n\t\tBCM_DEBUG_PRINT (Adapter, DBG_TYPE_PRINTK, 0, 0, \"actual Subtype=0x%x\\n\", sUserDebugState.Subtype);\n\n\t\t/* Update new 'DebugState' in the Adapter */\n\t\tAdapter->stDebugState.type |= sUserDebugState.Type;\n\t\t/* Subtype: A bitmap of 32 bits for Subtype per Type.\n\t\t * Valid indexes in 'subtype' array: 1,2,4,8\n\t\t * corresponding to valid Type values. Hence we can use the 'Type' field\n\t\t * as the index value, ignoring the array entries 0,3,5,6,7 !\n\t\t */\n\t\tif (sUserDebugState.OnOff)\n\t\t\tAdapter->stDebugState.subtype[sUserDebugState.Type] |= sUserDebugState.Subtype;\n\t\telse\n\t\t\tAdapter->stDebugState.subtype[sUserDebugState.Type] &= ~sUserDebugState.Subtype;\n\n\t\tBCM_SHOW_DEBUG_BITMAP(Adapter);\n\t}\n#endif\n\tbreak;\n\n\tcase IOCTL_BCM_NVM_READ:\n\tcase IOCTL_BCM_NVM_WRITE: {\n\t\tstruct bcm_nvm_readwrite stNVMReadWrite;\n\t\tPUCHAR pReadData = NULL;\n\t\tULONG ulDSDMagicNumInUsrBuff = 0;\n\t\tstruct timeval tv0, tv1;\n\t\tmemset(&tv0, 0, sizeof(struct timeval));\n\t\tmemset(&tv1, 0, sizeof(struct timeval));\n\t\tif ((Adapter->eNVMType == NVM_FLASH) && (Adapter->uiFlashLayoutMajorVersion == 0)) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"The Flash Control Section is Corrupted. Hence Rejection on NVM Read/Write\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tif (IsFlash2x(Adapter)) {\n\t\t\tif ((Adapter->eActiveDSD != DSD0) &&\n\t\t\t\t(Adapter->eActiveDSD != DSD1) &&\n\t\t\t\t(Adapter->eActiveDSD != DSD2)) {\n\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"No DSD is active..hence NVM Command is blocked\");\n\t\t\t\treturn STATUS_FAILURE;\n\t\t\t}\n\t\t}\n\n\t\t/* Copy Ioctl Buffer structure */\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (copy_from_user(&stNVMReadWrite,\n\t\t\t\t\t(IOCTL_BCM_NVM_READ == cmd) ? IoBuffer.OutputBuffer : IoBuffer.InputBuffer,\n\t\t\t\t\tsizeof(struct bcm_nvm_readwrite)))\n\t\t\treturn -EFAULT;\n\n\t\t/*\n\t\t * Deny the access if the offset crosses the cal area limit.\n\t\t */\n\t\tif (stNVMReadWrite.uiNumBytes > Adapter->uiNVMDSDSize)\n\t\t\treturn STATUS_FAILURE;\n\n\t\tif (stNVMReadWrite.uiOffset > Adapter->uiNVMDSDSize - stNVMReadWrite.uiNumBytes) {\n\t\t\t/* BCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,\"Can't allow access beyond NVM Size: 0x%x 0x%x\\n\", stNVMReadWrite.uiOffset, stNVMReadWrite.uiNumBytes); */\n\t\t\treturn STATUS_FAILURE;\n\t\t}\n\n\t\tpReadData = memdup_user(stNVMReadWrite.pBuffer,\n\t\t\t\t\tstNVMReadWrite.uiNumBytes);\n\t\tif (IS_ERR(pReadData))\n\t\t\treturn PTR_ERR(pReadData);\n\n\t\tdo_gettimeofday(&tv0);\n\t\tif (IOCTL_BCM_NVM_READ == cmd) {\n\t\t\tdown(&Adapter->NVMRdmWrmLock);\n\n\t\t\tif ((Adapter->IdleMode == TRUE) ||\n\t\t\t\t(Adapter->bShutStatus == TRUE) ||\n\t\t\t\t(Adapter->bPreparingForLowPowerMode == TRUE)) {\n\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Device is in Idle/Shutdown Mode\\n\");\n\t\t\t\tup(&Adapter->NVMRdmWrmLock);\n\t\t\t\tkfree(pReadData);\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\n\t\t\tStatus = BeceemNVMRead(Adapter, (PUINT)pReadData, stNVMReadWrite.uiOffset, stNVMReadWrite.uiNumBytes);\n\t\t\tup(&Adapter->NVMRdmWrmLock);\n\n\t\t\tif (Status != STATUS_SUCCESS) {\n\t\t\t\tkfree(pReadData);\n\t\t\t\treturn Status;\n\t\t\t}\n\n\t\t\tif (copy_to_user(stNVMReadWrite.pBuffer, pReadData, stNVMReadWrite.uiNumBytes)) {\n\t\t\t\tkfree(pReadData);\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t} else {\n\t\t\tdown(&Adapter->NVMRdmWrmLock);\n\n\t\t\tif ((Adapter->IdleMode == TRUE) ||\n\t\t\t\t(Adapter->bShutStatus == TRUE) ||\n\t\t\t\t(Adapter->bPreparingForLowPowerMode == TRUE)) {\n\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Device is in Idle/Shutdown Mode\\n\");\n\t\t\t\tup(&Adapter->NVMRdmWrmLock);\n\t\t\t\tkfree(pReadData);\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\n\t\t\tAdapter->bHeaderChangeAllowed = TRUE;\n\t\t\tif (IsFlash2x(Adapter)) {\n\t\t\t\t/*\n\t\t\t\t *\t\t\tNew Requirement:-\n\t\t\t\t *\t\t\tDSD section updation will be allowed in two case:-\n\t\t\t\t *\t\t\t1.  if DSD sig is present in DSD header means dongle is ok and updation is fruitfull\n\t\t\t\t *\t\t\t2.  if point 1 failes then user buff should have DSD sig. this point ensures that if dongle is\n\t\t\t\t *\t\t\t      corrupted then user space program first modify the DSD header with valid DSD sig so\n\t\t\t\t *\t\t\t      that this as well as further write may be worthwhile.\n\t\t\t\t *\n\t\t\t\t *\t\t\t This restriction has been put assuming that if DSD sig is corrupted, DSD\n\t\t\t\t *\t\t\t data won't be considered valid.\n\t\t\t\t */\n\n\t\t\t\tStatus = BcmFlash2xCorruptSig(Adapter, Adapter->eActiveDSD);\n\t\t\t\tif (Status != STATUS_SUCCESS) {\n\t\t\t\t\tif (((stNVMReadWrite.uiOffset + stNVMReadWrite.uiNumBytes) != Adapter->uiNVMDSDSize) ||\n\t\t\t\t\t\t(stNVMReadWrite.uiNumBytes < SIGNATURE_SIZE)) {\n\n\t\t\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"DSD Sig is present neither in Flash nor User provided Input..\");\n\t\t\t\t\t\tup(&Adapter->NVMRdmWrmLock);\n\t\t\t\t\t\tkfree(pReadData);\n\t\t\t\t\t\treturn Status;\n\t\t\t\t\t}\n\n\t\t\t\t\tulDSDMagicNumInUsrBuff = ntohl(*(PUINT)(pReadData + stNVMReadWrite.uiNumBytes - SIGNATURE_SIZE));\n\t\t\t\t\tif (ulDSDMagicNumInUsrBuff != DSD_IMAGE_MAGIC_NUMBER) {\n\t\t\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"DSD Sig is present neither in Flash nor User provided Input..\");\n\t\t\t\t\t\tup(&Adapter->NVMRdmWrmLock);\n\t\t\t\t\t\tkfree(pReadData);\n\t\t\t\t\t\treturn Status;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tStatus = BeceemNVMWrite(Adapter, (PUINT)pReadData, stNVMReadWrite.uiOffset, stNVMReadWrite.uiNumBytes, stNVMReadWrite.bVerify);\n\t\t\tif (IsFlash2x(Adapter))\n\t\t\t\tBcmFlash2xWriteSig(Adapter, Adapter->eActiveDSD);\n\n\t\t\tAdapter->bHeaderChangeAllowed = FALSE;\n\n\t\t\tup(&Adapter->NVMRdmWrmLock);\n\n\t\t\tif (Status != STATUS_SUCCESS) {\n\t\t\t\tkfree(pReadData);\n\t\t\t\treturn Status;\n\t\t\t}\n\t\t}\n\n\t\tdo_gettimeofday(&tv1);\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \" timetaken by Write/read :%ld msec\\n\", (tv1.tv_sec - tv0.tv_sec)*1000 + (tv1.tv_usec - tv0.tv_usec)/1000);\n\n\t\tkfree(pReadData);\n\t\treturn STATUS_SUCCESS;\n\t}\n\n\tcase IOCTL_BCM_FLASH2X_SECTION_READ: {\n\t\tstruct bcm_flash2x_readwrite sFlash2xRead = {0};\n\t\tPUCHAR pReadBuff = NULL ;\n\t\tUINT NOB = 0;\n\t\tUINT BuffSize = 0;\n\t\tUINT ReadBytes = 0;\n\t\tUINT ReadOffset = 0;\n\t\tvoid __user *OutPutBuff;\n\n\t\tif (IsFlash2x(Adapter) != TRUE)\t{\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Flash Does not have 2.x map\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"IOCTL_BCM_FLASH2X_SECTION_READ Called\");\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\t/* Reading FLASH 2.x READ structure */\n\t\tif (copy_from_user(&sFlash2xRead, IoBuffer.InputBuffer, sizeof(struct bcm_flash2x_readwrite)))\n\t\t\treturn -EFAULT;\n\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"\\nsFlash2xRead.Section :%x\", sFlash2xRead.Section);\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"\\nsFlash2xRead.offset :%x\", sFlash2xRead.offset);\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"\\nsFlash2xRead.numOfBytes :%x\", sFlash2xRead.numOfBytes);\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"\\nsFlash2xRead.bVerify :%x\\n\", sFlash2xRead.bVerify);\n\n\t\t/* This was internal to driver for raw read. now it has ben exposed to user space app. */\n\t\tif (validateFlash2xReadWrite(Adapter, &sFlash2xRead) == FALSE)\n\t\t\treturn STATUS_FAILURE;\n\n\t\tNOB = sFlash2xRead.numOfBytes;\n\t\tif (NOB > Adapter->uiSectorSize)\n\t\t\tBuffSize = Adapter->uiSectorSize;\n\t\telse\n\t\t\tBuffSize = NOB;\n\n\t\tReadOffset = sFlash2xRead.offset ;\n\t\tOutPutBuff = IoBuffer.OutputBuffer;\n\t\tpReadBuff = (PCHAR)kzalloc(BuffSize , GFP_KERNEL);\n\n\t\tif (pReadBuff == NULL) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Memory allocation failed for Flash 2.x Read Structure\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tdown(&Adapter->NVMRdmWrmLock);\n\n\t\tif ((Adapter->IdleMode == TRUE) ||\n\t\t\t(Adapter->bShutStatus == TRUE) ||\n\t\t\t(Adapter->bPreparingForLowPowerMode == TRUE)) {\n\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Device is in Idle/Shutdown Mode\\n\");\n\t\t\tup(&Adapter->NVMRdmWrmLock);\n\t\t\tkfree(pReadBuff);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\twhile (NOB) {\n\t\t\tif (NOB > Adapter->uiSectorSize)\n\t\t\t\tReadBytes = Adapter->uiSectorSize;\n\t\t\telse\n\t\t\t\tReadBytes = NOB;\n\n\t\t\t/* Reading the data from Flash 2.x */\n\t\t\tStatus = BcmFlash2xBulkRead(Adapter, (PUINT)pReadBuff, sFlash2xRead.Section, ReadOffset, ReadBytes);\n\t\t\tif (Status) {\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Flash 2x read err with Status :%d\", Status);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tBCM_DEBUG_PRINT_BUFFER(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, pReadBuff, ReadBytes);\n\n\t\t\tStatus = copy_to_user(OutPutBuff, pReadBuff, ReadBytes);\n\t\t\tif (Status) {\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Copy to use failed with status :%d\", Status);\n\t\t\t\tup(&Adapter->NVMRdmWrmLock);\n\t\t\t\tkfree(pReadBuff);\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t\tNOB = NOB - ReadBytes;\n\t\t\tif (NOB) {\n\t\t\t\tReadOffset = ReadOffset + ReadBytes;\n\t\t\t\tOutPutBuff = OutPutBuff + ReadBytes ;\n\t\t\t}\n\t\t}\n\n\t\tup(&Adapter->NVMRdmWrmLock);\n\t\tkfree(pReadBuff);\n\t}\n\tbreak;\n\n\tcase IOCTL_BCM_FLASH2X_SECTION_WRITE: {\n\t\tstruct bcm_flash2x_readwrite sFlash2xWrite = {0};\n\t\tPUCHAR pWriteBuff;\n\t\tvoid __user *InputAddr;\n\t\tUINT NOB = 0;\n\t\tUINT BuffSize = 0;\n\t\tUINT WriteOffset = 0;\n\t\tUINT WriteBytes = 0;\n\n\t\tif (IsFlash2x(Adapter) != TRUE) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Flash Does not have 2.x map\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* First make this False so that we can enable the Sector Permission Check in BeceemFlashBulkWrite */\n\t\tAdapter->bAllDSDWriteAllow = FALSE;\n\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"IOCTL_BCM_FLASH2X_SECTION_WRITE Called\");\n\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\t/* Reading FLASH 2.x READ structure */\n\t\tif (copy_from_user(&sFlash2xWrite, IoBuffer.InputBuffer, sizeof(struct bcm_flash2x_readwrite)))\n\t\t\treturn -EFAULT;\n\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"\\nsFlash2xRead.Section :%x\", sFlash2xWrite.Section);\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"\\nsFlash2xRead.offset :%d\", sFlash2xWrite.offset);\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"\\nsFlash2xRead.numOfBytes :%x\", sFlash2xWrite.numOfBytes);\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"\\nsFlash2xRead.bVerify :%x\\n\", sFlash2xWrite.bVerify);\n\n\t\tif ((sFlash2xWrite.Section != VSA0) && (sFlash2xWrite.Section != VSA1) && (sFlash2xWrite.Section != VSA2)) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Only VSA write is allowed\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (validateFlash2xReadWrite(Adapter, &sFlash2xWrite) == FALSE)\n\t\t\treturn STATUS_FAILURE;\n\n\t\tInputAddr = sFlash2xWrite.pDataBuff;\n\t\tWriteOffset = sFlash2xWrite.offset;\n\t\tNOB = sFlash2xWrite.numOfBytes;\n\n\t\tif (NOB > Adapter->uiSectorSize)\n\t\t\tBuffSize = Adapter->uiSectorSize;\n\t\telse\n\t\t\tBuffSize = NOB ;\n\n\t\tpWriteBuff = kmalloc(BuffSize, GFP_KERNEL);\n\n\t\tif (pWriteBuff == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\t/* extracting the remainder of the given offset. */\n\t\tWriteBytes = Adapter->uiSectorSize;\n\t\tif (WriteOffset % Adapter->uiSectorSize)\n\t\t\tWriteBytes = Adapter->uiSectorSize - (WriteOffset % Adapter->uiSectorSize);\n\n\t\tif (NOB < WriteBytes)\n\t\t\tWriteBytes = NOB;\n\n\t\tdown(&Adapter->NVMRdmWrmLock);\n\n\t\tif ((Adapter->IdleMode == TRUE) ||\n\t\t\t(Adapter->bShutStatus == TRUE) ||\n\t\t\t(Adapter->bPreparingForLowPowerMode == TRUE)) {\n\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Device is in Idle/Shutdown Mode\\n\");\n\t\t\tup(&Adapter->NVMRdmWrmLock);\n\t\t\tkfree(pWriteBuff);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tBcmFlash2xCorruptSig(Adapter, sFlash2xWrite.Section);\n\t\tdo {\n\t\t\tStatus = copy_from_user(pWriteBuff, InputAddr, WriteBytes);\n\t\t\tif (Status) {\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Copy to user failed with status :%d\", Status);\n\t\t\t\tup(&Adapter->NVMRdmWrmLock);\n\t\t\t\tkfree(pWriteBuff);\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t\tBCM_DEBUG_PRINT_BUFFER(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, pWriteBuff, WriteBytes);\n\n\t\t\t/* Writing the data from Flash 2.x */\n\t\t\tStatus = BcmFlash2xBulkWrite(Adapter, (PUINT)pWriteBuff, sFlash2xWrite.Section, WriteOffset, WriteBytes, sFlash2xWrite.bVerify);\n\n\t\t\tif (Status) {\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Flash 2x read err with Status :%d\", Status);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tNOB = NOB - WriteBytes;\n\t\t\tif (NOB) {\n\t\t\t\tWriteOffset = WriteOffset + WriteBytes;\n\t\t\t\tInputAddr = InputAddr + WriteBytes;\n\t\t\t\tif (NOB > Adapter->uiSectorSize)\n\t\t\t\t\tWriteBytes = Adapter->uiSectorSize;\n\t\t\t\telse\n\t\t\t\t\tWriteBytes = NOB;\n\t\t\t}\n\t\t} while (NOB > 0);\n\n\t\tBcmFlash2xWriteSig(Adapter, sFlash2xWrite.Section);\n\t\tup(&Adapter->NVMRdmWrmLock);\n\t\tkfree(pWriteBuff);\n\t}\n\tbreak;\n\n\tcase IOCTL_BCM_GET_FLASH2X_SECTION_BITMAP: {\n\t\tstruct bcm_flash2x_bitmap *psFlash2xBitMap;\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"IOCTL_BCM_GET_FLASH2X_SECTION_BITMAP Called\");\n\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (IoBuffer.OutputLength != sizeof(struct bcm_flash2x_bitmap))\n\t\t\treturn -EINVAL;\n\n\t\tpsFlash2xBitMap = kzalloc(sizeof(struct bcm_flash2x_bitmap), GFP_KERNEL);\n\t\tif (psFlash2xBitMap == NULL) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Memory is not available\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\t/* Reading the Flash Sectio Bit map */\n\t\tdown(&Adapter->NVMRdmWrmLock);\n\n\t\tif ((Adapter->IdleMode == TRUE) ||\n\t\t\t(Adapter->bShutStatus == TRUE) ||\n\t\t\t(Adapter->bPreparingForLowPowerMode == TRUE)) {\n\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Device is in Idle/Shutdown Mode\\n\");\n\t\t\tup(&Adapter->NVMRdmWrmLock);\n\t\t\tkfree(psFlash2xBitMap);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tBcmGetFlash2xSectionalBitMap(Adapter, psFlash2xBitMap);\n\t\tup(&Adapter->NVMRdmWrmLock);\n\t\tif (copy_to_user(IoBuffer.OutputBuffer, psFlash2xBitMap, sizeof(struct bcm_flash2x_bitmap))) {\n\t\t\tkfree(psFlash2xBitMap);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tkfree(psFlash2xBitMap);\n\t}\n\tbreak;\n\n\tcase IOCTL_BCM_SET_ACTIVE_SECTION: {\n\t\tenum bcm_flash2x_section_val eFlash2xSectionVal = 0;\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"IOCTL_BCM_SET_ACTIVE_SECTION Called\");\n\n\t\tif (IsFlash2x(Adapter) != TRUE) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Flash Does not have 2.x map\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tStatus = copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer));\n\t\tif (Status) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Copy of IOCTL BUFFER failed\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tStatus = copy_from_user(&eFlash2xSectionVal, IoBuffer.InputBuffer, sizeof(INT));\n\t\tif (Status) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Copy of flash section val failed\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tdown(&Adapter->NVMRdmWrmLock);\n\n\t\tif ((Adapter->IdleMode == TRUE) ||\n\t\t\t(Adapter->bShutStatus == TRUE) ||\n\t\t\t(Adapter->bPreparingForLowPowerMode == TRUE)) {\n\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Device is in Idle/Shutdown Mode\\n\");\n\t\t\tup(&Adapter->NVMRdmWrmLock);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tStatus = BcmSetActiveSection(Adapter, eFlash2xSectionVal);\n\t\tif (Status)\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Failed to make it's priority Highest. Status %d\", Status);\n\n\t\tup(&Adapter->NVMRdmWrmLock);\n\t}\n\tbreak;\n\n\tcase IOCTL_BCM_IDENTIFY_ACTIVE_SECTION: {\n\t\t/* Right Now we are taking care of only DSD */\n\t\tAdapter->bAllDSDWriteAllow = FALSE;\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"IOCTL_BCM_IDENTIFY_ACTIVE_SECTION called\");\n\t\tStatus = STATUS_SUCCESS;\n\t}\n\tbreak;\n\n\tcase IOCTL_BCM_COPY_SECTION: {\n\t\tstruct bcm_flash2x_copy_section sCopySectStrut = {0};\n\t\tStatus = STATUS_SUCCESS;\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"IOCTL_BCM_COPY_SECTION  Called\");\n\n\t\tAdapter->bAllDSDWriteAllow = FALSE;\n\t\tif (IsFlash2x(Adapter) != TRUE) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Flash Does not have 2.x map\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tStatus = copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer));\n\t\tif (Status) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Copy of IOCTL BUFFER failed Status :%d\", Status);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tStatus = copy_from_user(&sCopySectStrut, IoBuffer.InputBuffer, sizeof(struct bcm_flash2x_copy_section));\n\t\tif (Status) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Copy of Copy_Section_Struct failed with Status :%d\", Status);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Source SEction :%x\", sCopySectStrut.SrcSection);\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Destination SEction :%x\", sCopySectStrut.DstSection);\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"offset :%x\", sCopySectStrut.offset);\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"NOB :%x\", sCopySectStrut.numOfBytes);\n\n\t\tif (IsSectionExistInFlash(Adapter, sCopySectStrut.SrcSection) == FALSE) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Source Section<%x> does not exixt in Flash \", sCopySectStrut.SrcSection);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (IsSectionExistInFlash(Adapter, sCopySectStrut.DstSection) == FALSE) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Destinatio Section<%x> does not exixt in Flash \", sCopySectStrut.DstSection);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (sCopySectStrut.SrcSection == sCopySectStrut.DstSection) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Source and Destination section should be different\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdown(&Adapter->NVMRdmWrmLock);\n\n\t\tif ((Adapter->IdleMode == TRUE) ||\n\t\t\t(Adapter->bShutStatus == TRUE) ||\n\t\t\t(Adapter->bPreparingForLowPowerMode == TRUE)) {\n\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Device is in Idle/Shutdown Mode\\n\");\n\t\t\tup(&Adapter->NVMRdmWrmLock);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (sCopySectStrut.SrcSection == ISO_IMAGE1 || sCopySectStrut.SrcSection == ISO_IMAGE2) {\n\t\t\tif (IsNonCDLessDevice(Adapter)) {\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Device is Non-CDLess hence won't have ISO !!\");\n\t\t\t\tStatus = -EINVAL;\n\t\t\t} else if (sCopySectStrut.numOfBytes == 0) {\n\t\t\t\tStatus = BcmCopyISO(Adapter, sCopySectStrut);\n\t\t\t} else {\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Partial Copy of ISO section is not Allowed..\");\n\t\t\t\tStatus = STATUS_FAILURE;\n\t\t\t}\n\t\t\tup(&Adapter->NVMRdmWrmLock);\n\t\t\treturn Status;\n\t\t}\n\n\t\tStatus = BcmCopySection(Adapter, sCopySectStrut.SrcSection,\n\t\t\t\t\tsCopySectStrut.DstSection, sCopySectStrut.offset, sCopySectStrut.numOfBytes);\n\t\tup(&Adapter->NVMRdmWrmLock);\n\t}\n\tbreak;\n\n\tcase IOCTL_BCM_GET_FLASH_CS_INFO: {\n\t\tStatus = STATUS_SUCCESS;\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \" IOCTL_BCM_GET_FLASH_CS_INFO Called\");\n\n\t\tStatus = copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer));\n\t\tif (Status) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Copy of IOCTL BUFFER failed\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tif (Adapter->eNVMType != NVM_FLASH) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Connected device does not have flash\");\n\t\t\tStatus = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (IsFlash2x(Adapter) == TRUE) {\n\t\t\tif (IoBuffer.OutputLength < sizeof(struct bcm_flash2x_cs_info))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (copy_to_user(IoBuffer.OutputBuffer, Adapter->psFlash2xCSInfo, sizeof(struct bcm_flash2x_cs_info)))\n\t\t\t\treturn -EFAULT;\n\t\t} else {\n\t\t\tif (IoBuffer.OutputLength < sizeof(struct bcm_flash_cs_info))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (copy_to_user(IoBuffer.OutputBuffer, Adapter->psFlashCSInfo, sizeof(struct bcm_flash_cs_info)))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\tbreak;\n\n\tcase IOCTL_BCM_SELECT_DSD: {\n\t\tUINT SectOfset = 0;\n\t\tenum bcm_flash2x_section_val eFlash2xSectionVal;\n\t\teFlash2xSectionVal = NO_SECTION_VAL;\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"IOCTL_BCM_SELECT_DSD Called\");\n\n\t\tif (IsFlash2x(Adapter) != TRUE) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Flash Does not have 2.x map\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tStatus = copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer));\n\t\tif (Status) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Copy of IOCTL BUFFER failed\");\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tStatus = copy_from_user(&eFlash2xSectionVal, IoBuffer.InputBuffer, sizeof(INT));\n\t\tif (Status) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Copy of flash section val failed\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Read Section :%d\", eFlash2xSectionVal);\n\t\tif ((eFlash2xSectionVal != DSD0) &&\n\t\t\t(eFlash2xSectionVal != DSD1) &&\n\t\t\t(eFlash2xSectionVal != DSD2)) {\n\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Passed section<%x> is not DSD section\", eFlash2xSectionVal);\n\t\t\treturn STATUS_FAILURE;\n\t\t}\n\n\t\tSectOfset = BcmGetSectionValStartOffset(Adapter, eFlash2xSectionVal);\n\t\tif (SectOfset == INVALID_OFFSET) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Provided Section val <%d> does not exixt in Flash 2.x\", eFlash2xSectionVal);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tAdapter->bAllDSDWriteAllow = TRUE;\n\t\tAdapter->ulFlashCalStart = SectOfset;\n\t\tAdapter->eActiveDSD = eFlash2xSectionVal;\n\t}\n\tStatus = STATUS_SUCCESS;\n\tbreak;\n\n\tcase IOCTL_BCM_NVM_RAW_READ: {\n\t\tstruct bcm_nvm_readwrite stNVMRead;\n\t\tINT NOB ;\n\t\tINT BuffSize ;\n\t\tINT ReadOffset = 0;\n\t\tUINT ReadBytes = 0 ;\n\t\tPUCHAR pReadBuff;\n\t\tvoid __user *OutPutBuff;\n\n\t\tif (Adapter->eNVMType != NVM_FLASH) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"NVM TYPE is not Flash\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* Copy Ioctl Buffer structure */\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer))) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"copy_from_user 1 failed\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tif (copy_from_user(&stNVMRead, IoBuffer.OutputBuffer, sizeof(struct bcm_nvm_readwrite)))\n\t\t\treturn -EFAULT;\n\n\t\tNOB = stNVMRead.uiNumBytes;\n\t\t/* In Raw-Read max Buff size : 64MB */\n\n\t\tif (NOB > DEFAULT_BUFF_SIZE)\n\t\t\tBuffSize = DEFAULT_BUFF_SIZE;\n\t\telse\n\t\t\tBuffSize = NOB;\n\n\t\tReadOffset = stNVMRead.uiOffset;\n\t\tOutPutBuff = stNVMRead.pBuffer;\n\n\t\tpReadBuff = kzalloc(BuffSize , GFP_KERNEL);\n\t\tif (pReadBuff == NULL) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Memory allocation failed for Flash 2.x Read Structure\");\n\t\t\tStatus = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\tdown(&Adapter->NVMRdmWrmLock);\n\n\t\tif ((Adapter->IdleMode == TRUE) ||\n\t\t\t(Adapter->bShutStatus == TRUE) ||\n\t\t\t(Adapter->bPreparingForLowPowerMode == TRUE)) {\n\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Device is in Idle/Shutdown Mode\\n\");\n\t\t\tkfree(pReadBuff);\n\t\t\tup(&Adapter->NVMRdmWrmLock);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tAdapter->bFlashRawRead = TRUE;\n\n\t\twhile (NOB) {\n\t\t\tif (NOB > DEFAULT_BUFF_SIZE)\n\t\t\t\tReadBytes = DEFAULT_BUFF_SIZE;\n\t\t\telse\n\t\t\t\tReadBytes = NOB;\n\n\t\t\t/* Reading the data from Flash 2.x */\n\t\t\tStatus = BeceemNVMRead(Adapter, (PUINT)pReadBuff, ReadOffset, ReadBytes);\n\t\t\tif (Status) {\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Flash 2x read err with Status :%d\", Status);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tBCM_DEBUG_PRINT_BUFFER(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, pReadBuff, ReadBytes);\n\n\t\t\tStatus = copy_to_user(OutPutBuff, pReadBuff, ReadBytes);\n\t\t\tif (Status) {\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Copy to use failed with status :%d\", Status);\n\t\t\t\tup(&Adapter->NVMRdmWrmLock);\n\t\t\t\tkfree(pReadBuff);\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t\tNOB = NOB - ReadBytes;\n\t\t\tif (NOB) {\n\t\t\t\tReadOffset = ReadOffset + ReadBytes;\n\t\t\t\tOutPutBuff = OutPutBuff + ReadBytes;\n\t\t\t}\n\t\t}\n\t\tAdapter->bFlashRawRead = FALSE;\n\t\tup(&Adapter->NVMRdmWrmLock);\n\t\tkfree(pReadBuff);\n\t\tbreak;\n\t}\n\n\tcase IOCTL_BCM_CNTRLMSG_MASK: {\n\t\tULONG RxCntrlMsgBitMask = 0;\n\n\t\t/* Copy Ioctl Buffer structure */\n\t\tStatus = copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer));\n\t\tif (Status) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"copy of Ioctl buffer is failed from user space\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tif (IoBuffer.InputLength != sizeof(unsigned long)) {\n\t\t\tStatus = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tStatus = copy_from_user(&RxCntrlMsgBitMask, IoBuffer.InputBuffer, IoBuffer.InputLength);\n\t\tif (Status) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"copy of control bit mask failed from user space\");\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"\\n Got user defined cntrl msg bit mask :%lx\", RxCntrlMsgBitMask);\n\t\tpTarang->RxCntrlMsgBitMask = RxCntrlMsgBitMask;\n\t}\n\tbreak;\n\n\tcase IOCTL_BCM_GET_DEVICE_DRIVER_INFO: {\n\t\tstruct bcm_driver_info DevInfo;\n \n \t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Called IOCTL_BCM_GET_DEVICE_DRIVER_INFO\\n\");\n \n \t\tDevInfo.MaxRDMBufferSize = BUFFER_4K;\n \t\tDevInfo.u32DSDStartOffset = EEPROM_CALPARAM_START;\n \t\tDevInfo.u32RxAlignmentCorrection = 0;\n\t\tDevInfo.u32NVMType = Adapter->eNVMType;\n\t\tDevInfo.u32InterfaceType = BCM_USB;\n\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (IoBuffer.OutputLength < sizeof(DevInfo))\n\t\t\treturn -EINVAL;\n\n\t\tif (copy_to_user(IoBuffer.OutputBuffer, &DevInfo, sizeof(DevInfo)))\n\t\t\treturn -EFAULT;\n\t}\n\tbreak;\n\n\tcase IOCTL_BCM_TIME_SINCE_NET_ENTRY: {\n\t\tstruct bcm_time_elapsed stTimeElapsedSinceNetEntry = {0};\n\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"IOCTL_BCM_TIME_SINCE_NET_ENTRY called\");\n\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (IoBuffer.OutputLength < sizeof(struct bcm_time_elapsed))\n\t\t\treturn -EINVAL;\n\n\t\tstTimeElapsedSinceNetEntry.ul64TimeElapsedSinceNetEntry = get_seconds() - Adapter->liTimeSinceLastNetEntry;\n\n\t\tif (copy_to_user(IoBuffer.OutputBuffer, &stTimeElapsedSinceNetEntry, sizeof(struct bcm_time_elapsed)))\n\t\t\treturn -EFAULT;\n\t}\n\tbreak;\n\n\tcase IOCTL_CLOSE_NOTIFICATION:\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"IOCTL_CLOSE_NOTIFICATION\");\n\t\tbreak;\n\n\tdefault:\n\t\tpr_info(DRV_NAME \": unknown ioctl cmd=%#x\\n\", cmd);\n\t\tStatus = STATUS_FAILURE;\n\t\tbreak;\n\t}\n\treturn Status;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141741,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static long bcm_char_ioctl(struct file *filp, UINT cmd, ULONG arg)\n{\n\tstruct bcm_tarang_data *pTarang = filp->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\tstruct bcm_mini_adapter *Adapter = pTarang->Adapter;\n\tINT Status = STATUS_FAILURE;\n\tint timeout = 0;\n\tstruct bcm_ioctl_buffer IoBuffer;\n\tint bytes;\n\n\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Parameters Passed to control IOCTL cmd=0x%X arg=0x%lX\", cmd, arg);\n\n\tif (_IOC_TYPE(cmd) != BCM_IOCTL)\n\t\treturn -EFAULT;\n\tif (_IOC_DIR(cmd) & _IOC_READ)\n\t\tStatus = !access_ok(VERIFY_WRITE, argp, _IOC_SIZE(cmd));\n\telse if (_IOC_DIR(cmd) & _IOC_WRITE)\n\t\tStatus = !access_ok(VERIFY_READ, argp, _IOC_SIZE(cmd));\n\telse if (_IOC_NONE == (_IOC_DIR(cmd) & _IOC_NONE))\n\t\tStatus = STATUS_SUCCESS;\n\n\tif (Status)\n\t\treturn -EFAULT;\n\n\tif (Adapter->device_removed)\n\t\treturn -EFAULT;\n\n\tif (FALSE == Adapter->fw_download_done) {\n\t\tswitch (cmd) {\n\t\tcase IOCTL_MAC_ADDR_REQ:\n\t\tcase IOCTL_LINK_REQ:\n\t\tcase IOCTL_CM_REQUEST:\n\t\tcase IOCTL_SS_INFO_REQ:\n\t\tcase IOCTL_SEND_CONTROL_MESSAGE:\n\t\tcase IOCTL_IDLE_REQ:\n\t\tcase IOCTL_BCM_GPIO_SET_REQUEST:\n\t\tcase IOCTL_BCM_GPIO_STATUS_REQUEST:\n\t\t\treturn -EACCES;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tStatus = vendorextnIoctl(Adapter, cmd, arg);\n\tif (Status != CONTINUE_COMMON_PATH)\n\t\treturn Status;\n\n\tswitch (cmd) {\n\t/* Rdms for Swin Idle... */\n\tcase IOCTL_BCM_REGISTER_READ_PRIVATE: {\n\t\tstruct bcm_rdm_buffer sRdmBuffer = {0};\n\t\tPCHAR temp_buff;\n\t\tUINT Bufflen;\n\t\tu16 temp_value;\n\n\t\t/* Copy Ioctl Buffer structure */\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (IoBuffer.InputLength > sizeof(sRdmBuffer))\n\t\t\treturn -EINVAL;\n\n\t\tif (copy_from_user(&sRdmBuffer, IoBuffer.InputBuffer, IoBuffer.InputLength))\n\t\t\treturn -EFAULT;\n\n\t\tif (IoBuffer.OutputLength > USHRT_MAX ||\n\t\t\tIoBuffer.OutputLength == 0) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tBufflen = IoBuffer.OutputLength;\n\t\ttemp_value = 4 - (Bufflen % 4);\n\t\tBufflen += temp_value % 4;\n\n\t\ttemp_buff = kmalloc(Bufflen, GFP_KERNEL);\n\t\tif (!temp_buff)\n\t\t\treturn -ENOMEM;\n\n\t\tbytes = rdmalt(Adapter, (UINT)sRdmBuffer.Register,\n\t\t\t\t(PUINT)temp_buff, Bufflen);\n\t\tif (bytes > 0) {\n\t\t\tStatus = STATUS_SUCCESS;\n\t\t\tif (copy_to_user(IoBuffer.OutputBuffer, temp_buff, bytes)) {\n\t\t\t\tkfree(temp_buff);\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t} else {\n\t\t\tStatus = bytes;\n\t\t}\n\n\t\tkfree(temp_buff);\n\t\tbreak;\n\t}\n\n\tcase IOCTL_BCM_REGISTER_WRITE_PRIVATE: {\n\t\tstruct bcm_wrm_buffer sWrmBuffer = {0};\n\t\tUINT uiTempVar = 0;\n\t\t/* Copy Ioctl Buffer structure */\n\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (IoBuffer.InputLength > sizeof(sWrmBuffer))\n\t\t\treturn -EINVAL;\n\n\t\t/* Get WrmBuffer structure */\n\t\tif (copy_from_user(&sWrmBuffer, IoBuffer.InputBuffer, IoBuffer.InputLength))\n\t\t\treturn -EFAULT;\n\n\t\tuiTempVar = sWrmBuffer.Register & EEPROM_REJECT_MASK;\n\t\tif (!((Adapter->pstargetparams->m_u32Customize) & VSG_MODE) &&\n\t\t\t((uiTempVar == EEPROM_REJECT_REG_1) ||\n\t\t\t\t(uiTempVar == EEPROM_REJECT_REG_2) ||\n\t\t\t\t(uiTempVar == EEPROM_REJECT_REG_3) ||\n\t\t\t\t(uiTempVar == EEPROM_REJECT_REG_4))) {\n\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"EEPROM Access Denied, not in VSG Mode\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tStatus = wrmalt(Adapter, (UINT)sWrmBuffer.Register,\n\t\t\t\t(PUINT)sWrmBuffer.Data, sizeof(ULONG));\n\n\t\tif (Status == STATUS_SUCCESS) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"WRM Done\\n\");\n\t\t} else {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"WRM Failed\\n\");\n\t\t\tStatus = -EFAULT;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase IOCTL_BCM_REGISTER_READ:\n\tcase IOCTL_BCM_EEPROM_REGISTER_READ: {\n\t\tstruct bcm_rdm_buffer sRdmBuffer = {0};\n\t\tPCHAR temp_buff = NULL;\n\t\tUINT uiTempVar = 0;\n\t\tif ((Adapter->IdleMode == TRUE) ||\n\t\t\t(Adapter->bShutStatus == TRUE) ||\n\t\t\t(Adapter->bPreparingForLowPowerMode == TRUE)) {\n\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Device in Idle Mode, Blocking Rdms\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\t/* Copy Ioctl Buffer structure */\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (IoBuffer.InputLength > sizeof(sRdmBuffer))\n\t\t\treturn -EINVAL;\n\n\t\tif (copy_from_user(&sRdmBuffer, IoBuffer.InputBuffer, IoBuffer.InputLength))\n\t\t\treturn -EFAULT;\n\n\t\tif (IoBuffer.OutputLength > USHRT_MAX ||\n\t\t\tIoBuffer.OutputLength == 0) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\ttemp_buff = kmalloc(IoBuffer.OutputLength, GFP_KERNEL);\n\t\tif (!temp_buff)\n\t\t\treturn STATUS_FAILURE;\n\n\t\tif ((((ULONG)sRdmBuffer.Register & 0x0F000000) != 0x0F000000) ||\n\t\t\t((ULONG)sRdmBuffer.Register & 0x3)) {\n\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"RDM Done On invalid Address : %x Access Denied.\\n\",\n\t\t\t\t\t(int)sRdmBuffer.Register);\n\n\t\t\tkfree(temp_buff);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tuiTempVar = sRdmBuffer.Register & EEPROM_REJECT_MASK;\n\t\tbytes = rdmaltWithLock(Adapter, (UINT)sRdmBuffer.Register, (PUINT)temp_buff, IoBuffer.OutputLength);\n\n\t\tif (bytes > 0) {\n\t\t\tStatus = STATUS_SUCCESS;\n\t\t\tif (copy_to_user(IoBuffer.OutputBuffer, temp_buff, bytes)) {\n\t\t\t\tkfree(temp_buff);\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t} else {\n\t\t\tStatus = bytes;\n\t\t}\n\n\t\tkfree(temp_buff);\n\t\tbreak;\n\t}\n\tcase IOCTL_BCM_REGISTER_WRITE:\n\tcase IOCTL_BCM_EEPROM_REGISTER_WRITE: {\n\t\tstruct bcm_wrm_buffer sWrmBuffer = {0};\n\t\tUINT uiTempVar = 0;\n\n\t\tif ((Adapter->IdleMode == TRUE) ||\n\t\t\t(Adapter->bShutStatus == TRUE) ||\n\t\t\t(Adapter->bPreparingForLowPowerMode == TRUE)) {\n\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Device in Idle Mode, Blocking Wrms\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\t/* Copy Ioctl Buffer structure */\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (IoBuffer.InputLength > sizeof(sWrmBuffer))\n\t\t\treturn -EINVAL;\n\n\t\t/* Get WrmBuffer structure */\n\t\tif (copy_from_user(&sWrmBuffer, IoBuffer.InputBuffer, IoBuffer.InputLength))\n\t\t\treturn -EFAULT;\n\n\t\tif ((((ULONG)sWrmBuffer.Register & 0x0F000000) != 0x0F000000) ||\n\t\t\t((ULONG)sWrmBuffer.Register & 0x3)) {\n\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"WRM Done On invalid Address : %x Access Denied.\\n\", (int)sWrmBuffer.Register);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tuiTempVar = sWrmBuffer.Register & EEPROM_REJECT_MASK;\n\t\tif (!((Adapter->pstargetparams->m_u32Customize) & VSG_MODE) &&\n\t\t\t\t((uiTempVar == EEPROM_REJECT_REG_1) ||\n\t\t\t\t(uiTempVar == EEPROM_REJECT_REG_2) ||\n\t\t\t\t(uiTempVar == EEPROM_REJECT_REG_3) ||\n\t\t\t\t(uiTempVar == EEPROM_REJECT_REG_4)) &&\n\t\t\t\t(cmd == IOCTL_BCM_REGISTER_WRITE)) {\n\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"EEPROM Access Denied, not in VSG Mode\\n\");\n\t\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tStatus = wrmaltWithLock(Adapter, (UINT)sWrmBuffer.Register,\n\t\t\t\t\t(PUINT)sWrmBuffer.Data, sWrmBuffer.Length);\n\n\t\tif (Status == STATUS_SUCCESS) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, OSAL_DBG, DBG_LVL_ALL, \"WRM Done\\n\");\n\t\t} else {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"WRM Failed\\n\");\n\t\t\tStatus = -EFAULT;\n\t\t}\n\t\tbreak;\n\t}\n\tcase IOCTL_BCM_GPIO_SET_REQUEST: {\n\t\tUCHAR ucResetValue[4];\n\t\tUINT value = 0;\n\t\tUINT uiBit = 0;\n\t\tUINT uiOperation = 0;\n\t\tstruct bcm_gpio_info gpio_info = {0};\n\n\t\tif ((Adapter->IdleMode == TRUE) ||\n\t\t\t(Adapter->bShutStatus == TRUE) ||\n\t\t\t(Adapter->bPreparingForLowPowerMode == TRUE)) {\n\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"GPIO Can't be set/clear in Low power Mode\");\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (IoBuffer.InputLength > sizeof(gpio_info))\n\t\t\treturn -EINVAL;\n\n\t\tif (copy_from_user(&gpio_info, IoBuffer.InputBuffer, IoBuffer.InputLength))\n\t\t\treturn -EFAULT;\n\n\t\tuiBit  = gpio_info.uiGpioNumber;\n\t\tuiOperation = gpio_info.uiGpioValue;\n\t\tvalue = (1<<uiBit);\n\n\t\tif (IsReqGpioIsLedInNVM(Adapter, value) == FALSE) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Sorry, Requested GPIO<0x%X> is not correspond to LED !!!\", value);\n\t\t\tStatus = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Set - setting 1 */\n\t\tif (uiOperation) {\n\t\t\t/* Set the gpio output register */\n\t\t\tStatus = wrmaltWithLock(Adapter, BCM_GPIO_OUTPUT_SET_REG, (PUINT)(&value), sizeof(UINT));\n\n\t\t\tif (Status == STATUS_SUCCESS) {\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Set the GPIO bit\\n\");\n\t\t\t} else {\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Failed to set the %dth GPIO\\n\", uiBit);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t/* Set the gpio output register */\n\t\t\tStatus = wrmaltWithLock(Adapter, BCM_GPIO_OUTPUT_CLR_REG, (PUINT)(&value), sizeof(UINT));\n\n\t\t\tif (Status == STATUS_SUCCESS) {\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Set the GPIO bit\\n\");\n\t\t\t} else {\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Failed to clear the %dth GPIO\\n\", uiBit);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tbytes = rdmaltWithLock(Adapter, (UINT)GPIO_MODE_REGISTER, (PUINT)ucResetValue, sizeof(UINT));\n\t\tif (bytes < 0) {\n\t\t\tStatus = bytes;\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,\n\t\t\t\t\t\"GPIO_MODE_REGISTER read failed\");\n\t\t\tbreak;\n\t\t} else {\n\t\t\tStatus = STATUS_SUCCESS;\n\t\t}\n\n\t\t/* Set the gpio mode register to output */\n\t\t*(UINT *)ucResetValue |= (1<<uiBit);\n\t\tStatus = wrmaltWithLock(Adapter, GPIO_MODE_REGISTER,\n\t\t\t\t\t(PUINT)ucResetValue, sizeof(UINT));\n\n\t\tif (Status == STATUS_SUCCESS) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Set the GPIO to output Mode\\n\");\n\t\t} else {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Failed to put GPIO in Output Mode\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\tbreak;\n\n\tcase BCM_LED_THREAD_STATE_CHANGE_REQ: {\n\t\tstruct bcm_user_thread_req threadReq = {0};\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"User made LED thread InActive\");\n\n\t\tif ((Adapter->IdleMode == TRUE) ||\n\t\t\t(Adapter->bShutStatus == TRUE) ||\n\t\t\t(Adapter->bPreparingForLowPowerMode == TRUE)) {\n\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"GPIO Can't be set/clear in Low power Mode\");\n\t\t\tStatus = -EACCES;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (IoBuffer.InputLength > sizeof(threadReq))\n\t\t\treturn -EINVAL;\n\n\t\tif (copy_from_user(&threadReq, IoBuffer.InputBuffer, IoBuffer.InputLength))\n\t\t\treturn -EFAULT;\n\n\t\t/* if LED thread is running(Actively or Inactively) set it state to make inactive */\n\t\tif (Adapter->LEDInfo.led_thread_running) {\n\t\t\tif (threadReq.ThreadState == LED_THREAD_ACTIVATION_REQ) {\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Activating thread req\");\n\t\t\t\tAdapter->DriverState = LED_THREAD_ACTIVE;\n\t\t\t} else {\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"DeActivating Thread req.....\");\n\t\t\t\tAdapter->DriverState = LED_THREAD_INACTIVE;\n\t\t\t}\n\n\t\t\t/* signal thread. */\n\t\t\twake_up(&Adapter->LEDInfo.notify_led_event);\n\t\t}\n\t}\n\tbreak;\n\n\tcase IOCTL_BCM_GPIO_STATUS_REQUEST: {\n\t\tULONG uiBit = 0;\n\t\tUCHAR ucRead[4];\n\t\tstruct bcm_gpio_info gpio_info = {0};\n\n\t\tif ((Adapter->IdleMode == TRUE) ||\n\t\t\t(Adapter->bShutStatus == TRUE) ||\n\t\t\t(Adapter->bPreparingForLowPowerMode == TRUE))\n\t\t\treturn -EACCES;\n\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (IoBuffer.InputLength > sizeof(gpio_info))\n\t\t\treturn -EINVAL;\n\n\t\tif (copy_from_user(&gpio_info, IoBuffer.InputBuffer, IoBuffer.InputLength))\n\t\t\treturn -EFAULT;\n\n\t\tuiBit = gpio_info.uiGpioNumber;\n\n\t\t/* Set the gpio output register */\n\t\tbytes = rdmaltWithLock(Adapter, (UINT)GPIO_PIN_STATE_REGISTER,\n\t\t\t\t\t(PUINT)ucRead, sizeof(UINT));\n\n\t\tif (bytes < 0) {\n\t\t\tStatus = bytes;\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"RDM Failed\\n\");\n\t\t\treturn Status;\n\t\t} else {\n\t\t\tStatus = STATUS_SUCCESS;\n\t\t}\n\t}\n\tbreak;\n\n\tcase IOCTL_BCM_GPIO_MULTI_REQUEST: {\n\t\tUCHAR ucResetValue[4];\n\t\tstruct bcm_gpio_multi_info gpio_multi_info[MAX_IDX];\n\t\tstruct bcm_gpio_multi_info *pgpio_multi_info = (struct bcm_gpio_multi_info *)gpio_multi_info;\n\n\t\tmemset(pgpio_multi_info, 0, MAX_IDX * sizeof(struct bcm_gpio_multi_info));\n\n\t\tif ((Adapter->IdleMode == TRUE) ||\n\t\t\t(Adapter->bShutStatus == TRUE) ||\n\t\t\t(Adapter->bPreparingForLowPowerMode == TRUE))\n\t\t\treturn -EINVAL;\n\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (IoBuffer.InputLength > sizeof(gpio_multi_info))\n\t\t\treturn -EINVAL;\n\n\t\tif (copy_from_user(&gpio_multi_info, IoBuffer.InputBuffer, IoBuffer.InputLength))\n\t\t\treturn -EFAULT;\n\n\t\tif (IsReqGpioIsLedInNVM(Adapter, pgpio_multi_info[WIMAX_IDX].uiGPIOMask) == FALSE) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,\n\t\t\t\t\t\"Sorry, Requested GPIO<0x%X> is not correspond to NVM LED bit map<0x%X>!!!\",\n\t\t\t\t\tpgpio_multi_info[WIMAX_IDX].uiGPIOMask, Adapter->gpioBitMap);\n\t\t\tStatus = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Set the gpio output register */\n\t\tif ((pgpio_multi_info[WIMAX_IDX].uiGPIOMask) &\n\t\t\t(pgpio_multi_info[WIMAX_IDX].uiGPIOCommand)) {\n\t\t\t/* Set 1's in GPIO OUTPUT REGISTER */\n\t\t\t*(UINT *)ucResetValue =  pgpio_multi_info[WIMAX_IDX].uiGPIOMask &\n\t\t\t\tpgpio_multi_info[WIMAX_IDX].uiGPIOCommand &\n\t\t\t\tpgpio_multi_info[WIMAX_IDX].uiGPIOValue;\n\n\t\t\tif (*(UINT *) ucResetValue)\n\t\t\t\tStatus = wrmaltWithLock(Adapter, BCM_GPIO_OUTPUT_SET_REG,\n\t\t\t\t\t\t\t(PUINT)ucResetValue, sizeof(ULONG));\n\n\t\t\tif (Status != STATUS_SUCCESS) {\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"WRM to BCM_GPIO_OUTPUT_SET_REG Failed.\");\n\t\t\t\treturn Status;\n\t\t\t}\n\n\t\t\t/* Clear to 0's in GPIO OUTPUT REGISTER */\n\t\t\t*(UINT *)ucResetValue = (pgpio_multi_info[WIMAX_IDX].uiGPIOMask &\n\t\t\t\t\t\tpgpio_multi_info[WIMAX_IDX].uiGPIOCommand &\n\t\t\t\t\t\t(~(pgpio_multi_info[WIMAX_IDX].uiGPIOValue)));\n\n\t\t\tif (*(UINT *) ucResetValue)\n\t\t\t\tStatus = wrmaltWithLock(Adapter, BCM_GPIO_OUTPUT_CLR_REG, (PUINT)ucResetValue, sizeof(ULONG));\n\n\t\t\tif (Status != STATUS_SUCCESS) {\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"WRM to BCM_GPIO_OUTPUT_CLR_REG Failed.\");\n\t\t\t\treturn Status;\n\t\t\t}\n\t\t}\n\n\t\tif (pgpio_multi_info[WIMAX_IDX].uiGPIOMask) {\n\t\t\tbytes = rdmaltWithLock(Adapter, (UINT)GPIO_PIN_STATE_REGISTER, (PUINT)ucResetValue, sizeof(UINT));\n\n\t\t\tif (bytes < 0) {\n\t\t\t\tStatus = bytes;\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"RDM to GPIO_PIN_STATE_REGISTER Failed.\");\n\t\t\t\treturn Status;\n\t\t\t} else {\n\t\t\t\tStatus = STATUS_SUCCESS;\n\t\t\t}\n\n\t\t\tpgpio_multi_info[WIMAX_IDX].uiGPIOValue = (*(UINT *)ucResetValue &\n\t\t\t\t\t\t\t\tpgpio_multi_info[WIMAX_IDX].uiGPIOMask);\n\t\t}\n\n\t\tStatus = copy_to_user(IoBuffer.OutputBuffer, &gpio_multi_info, IoBuffer.OutputLength);\n\t\tif (Status) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,\n\t\t\t\t\t\"Failed while copying Content to IOBufer for user space err:%d\", Status);\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\tbreak;\n\n\tcase IOCTL_BCM_GPIO_MODE_REQUEST: {\n\t\tUCHAR ucResetValue[4];\n\t\tstruct bcm_gpio_multi_mode gpio_multi_mode[MAX_IDX];\n\t\tstruct bcm_gpio_multi_mode *pgpio_multi_mode = (struct bcm_gpio_multi_mode *)gpio_multi_mode;\n\n\t\tif ((Adapter->IdleMode == TRUE) ||\n\t\t\t(Adapter->bShutStatus == TRUE) ||\n\t\t\t(Adapter->bPreparingForLowPowerMode == TRUE))\n\t\t\treturn -EINVAL;\n\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (IoBuffer.InputLength > sizeof(gpio_multi_mode))\n\t\t\treturn -EINVAL;\n\n\t\tif (copy_from_user(&gpio_multi_mode, IoBuffer.InputBuffer, IoBuffer.InputLength))\n\t\t\treturn -EFAULT;\n\n\t\tbytes = rdmaltWithLock(Adapter, (UINT)GPIO_MODE_REGISTER, (PUINT)ucResetValue, sizeof(UINT));\n\n\t\tif (bytes < 0) {\n\t\t\tStatus = bytes;\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Read of GPIO_MODE_REGISTER failed\");\n\t\t\treturn Status;\n\t\t} else {\n\t\t\tStatus = STATUS_SUCCESS;\n\t\t}\n\n\t\t/* Validating the request */\n\t\tif (IsReqGpioIsLedInNVM(Adapter, pgpio_multi_mode[WIMAX_IDX].uiGPIOMask) == FALSE) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,\n\t\t\t\t\t\"Sorry, Requested GPIO<0x%X> is not correspond to NVM LED bit map<0x%X>!!!\",\n\t\t\t\t\tpgpio_multi_mode[WIMAX_IDX].uiGPIOMask, Adapter->gpioBitMap);\n\t\t\tStatus = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (pgpio_multi_mode[WIMAX_IDX].uiGPIOMask) {\n\t\t\t/* write all OUT's (1's) */\n\t\t\t*(UINT *) ucResetValue |= (pgpio_multi_mode[WIMAX_IDX].uiGPIOMode &\n\t\t\t\t\t\tpgpio_multi_mode[WIMAX_IDX].uiGPIOMask);\n\n\t\t\t/* write all IN's (0's) */\n\t\t\t*(UINT *) ucResetValue &= ~((~pgpio_multi_mode[WIMAX_IDX].uiGPIOMode) &\n\t\t\t\t\t\tpgpio_multi_mode[WIMAX_IDX].uiGPIOMask);\n\n\t\t\t/* Currently implemented return the modes of all GPIO's\n\t\t\t * else needs to bit AND with  mask\n\t\t\t */\n\t\t\tpgpio_multi_mode[WIMAX_IDX].uiGPIOMode = *(UINT *)ucResetValue;\n\n\t\t\tStatus = wrmaltWithLock(Adapter, GPIO_MODE_REGISTER, (PUINT)ucResetValue, sizeof(ULONG));\n\t\t\tif (Status == STATUS_SUCCESS) {\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,\n\t\t\t\t\t\t\"WRM to GPIO_MODE_REGISTER Done\");\n\t\t\t} else {\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,\n\t\t\t\t\t\t\"WRM to GPIO_MODE_REGISTER Failed\");\n\t\t\t\tStatus = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n/* if uiGPIOMask is 0 then return mode register configuration */\n\t\t\tpgpio_multi_mode[WIMAX_IDX].uiGPIOMode = *(UINT *)ucResetValue;\n\t\t}\n\n\t\tStatus = copy_to_user(IoBuffer.OutputBuffer, &gpio_multi_mode, IoBuffer.OutputLength);\n\t\tif (Status) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,\n\t\t\t\t\t\"Failed while copying Content to IOBufer for user space err:%d\", Status);\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\tbreak;\n\n\tcase IOCTL_MAC_ADDR_REQ:\n\tcase IOCTL_LINK_REQ:\n\tcase IOCTL_CM_REQUEST:\n\tcase IOCTL_SS_INFO_REQ:\n\tcase IOCTL_SEND_CONTROL_MESSAGE:\n\tcase IOCTL_IDLE_REQ: {\n\t\tPVOID pvBuffer = NULL;\n\n\t\t/* Copy Ioctl Buffer structure */\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (IoBuffer.InputLength < sizeof(struct bcm_link_request))\n\t\t\treturn -EINVAL;\n\n\t\tif (IoBuffer.InputLength > MAX_CNTL_PKT_SIZE)\n\t\t\treturn -EINVAL;\n\n\t\tpvBuffer = memdup_user(IoBuffer.InputBuffer,\n\t\t\t\t       IoBuffer.InputLength);\n\t\tif (IS_ERR(pvBuffer))\n\t\t\treturn PTR_ERR(pvBuffer);\n\n\t\tdown(&Adapter->LowPowerModeSync);\n\t\tStatus = wait_event_interruptible_timeout(Adapter->lowpower_mode_wait_queue,\n\t\t\t\t\t\t\t!Adapter->bPreparingForLowPowerMode,\n\t\t\t\t\t\t\t(1 * HZ));\n\t\tif (Status == -ERESTARTSYS)\n\t\t\tgoto cntrlEnd;\n\n\t\tif (Adapter->bPreparingForLowPowerMode) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,\n\t\t\t\t\t\"Preparing Idle Mode is still True - Hence Rejecting control message\\n\");\n\t\t\tStatus = STATUS_FAILURE;\n\t\t\tgoto cntrlEnd;\n\t\t}\n\t\tStatus = CopyBufferToControlPacket(Adapter, (PVOID)pvBuffer);\n\ncntrlEnd:\n\t\tup(&Adapter->LowPowerModeSync);\n\t\tkfree(pvBuffer);\n\t\tbreak;\n\t}\n\n\tcase IOCTL_BCM_BUFFER_DOWNLOAD_START: {\n\t\tif (down_trylock(&Adapter->NVMRdmWrmLock)) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,\n\t\t\t\t\t\"IOCTL_BCM_CHIP_RESET not allowed as EEPROM Read/Write is in progress\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,\n\t\t\t\t\"Starting the firmware download PID =0x%x!!!!\\n\", current->pid);\n\n\t\tif (down_trylock(&Adapter->fw_download_sema))\n\t\t\treturn -EBUSY;\n\n\t\tAdapter->bBinDownloaded = FALSE;\n\t\tAdapter->fw_download_process_pid = current->pid;\n\t\tAdapter->bCfgDownloaded = FALSE;\n\t\tAdapter->fw_download_done = FALSE;\n\t\tnetif_carrier_off(Adapter->dev);\n\t\tnetif_stop_queue(Adapter->dev);\n\t\tStatus = reset_card_proc(Adapter);\n\t\tif (Status) {\n\t\t\tpr_err(PFX \"%s: reset_card_proc Failed!\\n\", Adapter->dev->name);\n\t\t\tup(&Adapter->fw_download_sema);\n\t\t\tup(&Adapter->NVMRdmWrmLock);\n\t\t\treturn Status;\n\t\t}\n\t\tmdelay(10);\n\n\t\tup(&Adapter->NVMRdmWrmLock);\n\t\treturn Status;\n\t}\n\n\tcase IOCTL_BCM_BUFFER_DOWNLOAD: {\n\t\tstruct bcm_firmware_info *psFwInfo = NULL;\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Starting the firmware download PID =0x%x!!!!\\n\", current->pid);\n\n\t\tif (!down_trylock(&Adapter->fw_download_sema)) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,\n\t\t\t\t\t\"Invalid way to download buffer. Use Start and then call this!!!\\n\");\n\t\t\tup(&Adapter->fw_download_sema);\n\t\t\tStatus = -EINVAL;\n\t\t\treturn Status;\n\t\t}\n\n\t\t/* Copy Ioctl Buffer structure */\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer))) {\n\t\t\tup(&Adapter->fw_download_sema);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,\n\t\t\t\t\"Length for FW DLD is : %lx\\n\", IoBuffer.InputLength);\n\n\t\tif (IoBuffer.InputLength > sizeof(struct bcm_firmware_info)) {\n\t\t\tup(&Adapter->fw_download_sema);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tpsFwInfo = kmalloc(sizeof(*psFwInfo), GFP_KERNEL);\n\t\tif (!psFwInfo) {\n\t\t\tup(&Adapter->fw_download_sema);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (copy_from_user(psFwInfo, IoBuffer.InputBuffer, IoBuffer.InputLength)) {\n\t\t\tup(&Adapter->fw_download_sema);\n\t\t\tkfree(psFwInfo);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tif (!psFwInfo->pvMappedFirmwareAddress ||\n\t\t\t(psFwInfo->u32FirmwareLength == 0)) {\n\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Something else is wrong %lu\\n\",\n\t\t\t\t\tpsFwInfo->u32FirmwareLength);\n\t\t\tup(&Adapter->fw_download_sema);\n\t\t\tkfree(psFwInfo);\n\t\t\tStatus = -EINVAL;\n\t\t\treturn Status;\n\t\t}\n\n\t\tStatus = bcm_ioctl_fw_download(Adapter, psFwInfo);\n\n\t\tif (Status != STATUS_SUCCESS) {\n\t\t\tif (psFwInfo->u32StartingAddress == CONFIG_BEGIN_ADDR)\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"IOCTL: Configuration File Upload Failed\\n\");\n\t\t\telse\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,\t\"IOCTL: Firmware File Upload Failed\\n\");\n\n\t\t\t/* up(&Adapter->fw_download_sema); */\n\n\t\t\tif (Adapter->LEDInfo.led_thread_running & BCM_LED_THREAD_RUNNING_ACTIVELY) {\n\t\t\t\tAdapter->DriverState = DRIVER_INIT;\n\t\t\t\tAdapter->LEDInfo.bLedInitDone = FALSE;\n\t\t\t\twake_up(&Adapter->LEDInfo.notify_led_event);\n\t\t\t}\n\t\t}\n\n\t\tif (Status != STATUS_SUCCESS)\n\t\t\tup(&Adapter->fw_download_sema);\n\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, OSAL_DBG, DBG_LVL_ALL, \"IOCTL: Firmware File Uploaded\\n\");\n\t\tkfree(psFwInfo);\n\t\treturn Status;\n\t}\n\n\tcase IOCTL_BCM_BUFFER_DOWNLOAD_STOP: {\n\t\tif (!down_trylock(&Adapter->fw_download_sema)) {\n\t\t\tup(&Adapter->fw_download_sema);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (down_trylock(&Adapter->NVMRdmWrmLock)) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,\n\t\t\t\t\t\"FW download blocked as EEPROM Read/Write is in progress\\n\");\n\t\t\tup(&Adapter->fw_download_sema);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tAdapter->bBinDownloaded = TRUE;\n\t\tAdapter->bCfgDownloaded = TRUE;\n\t\tatomic_set(&Adapter->CurrNumFreeTxDesc, 0);\n\t\tAdapter->CurrNumRecvDescs = 0;\n\t\tAdapter->downloadDDR = 0;\n\n\t\t/* setting the Mips to Run */\n\t\tStatus = run_card_proc(Adapter);\n\n\t\tif (Status) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Firm Download Failed\\n\");\n\t\t\tup(&Adapter->fw_download_sema);\n\t\t\tup(&Adapter->NVMRdmWrmLock);\n\t\t\treturn Status;\n\t\t} else {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG,\n\t\t\t\t\tDBG_LVL_ALL, \"Firm Download Over...\\n\");\n\t\t}\n\n\t\tmdelay(10);\n\n\t\t/* Wait for MailBox Interrupt */\n\t\tif (StartInterruptUrb((struct bcm_interface_adapter *)Adapter->pvInterfaceAdapter))\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Unable to send interrupt...\\n\");\n\n\t\ttimeout = 5*HZ;\n\t\tAdapter->waiting_to_fw_download_done = FALSE;\n\t\twait_event_timeout(Adapter->ioctl_fw_dnld_wait_queue,\n\t\t\t\tAdapter->waiting_to_fw_download_done, timeout);\n\t\tAdapter->fw_download_process_pid = INVALID_PID;\n\t\tAdapter->fw_download_done = TRUE;\n\t\tatomic_set(&Adapter->CurrNumFreeTxDesc, 0);\n\t\tAdapter->CurrNumRecvDescs = 0;\n\t\tAdapter->PrevNumRecvDescs = 0;\n\t\tatomic_set(&Adapter->cntrlpktCnt, 0);\n\t\tAdapter->LinkUpStatus = 0;\n\t\tAdapter->LinkStatus = 0;\n\n\t\tif (Adapter->LEDInfo.led_thread_running & BCM_LED_THREAD_RUNNING_ACTIVELY) {\n\t\t\tAdapter->DriverState = FW_DOWNLOAD_DONE;\n\t\t\twake_up(&Adapter->LEDInfo.notify_led_event);\n\t\t}\n\n\t\tif (!timeout)\n\t\t\tStatus = -ENODEV;\n\n\t\tup(&Adapter->fw_download_sema);\n\t\tup(&Adapter->NVMRdmWrmLock);\n\t\treturn Status;\n\t}\n\n\tcase IOCTL_BE_BUCKET_SIZE:\n\t\tStatus = 0;\n\t\tif (get_user(Adapter->BEBucketSize, (unsigned long __user *)arg))\n\t\t\tStatus = -EFAULT;\n\t\tbreak;\n\n\tcase IOCTL_RTPS_BUCKET_SIZE:\n\t\tStatus = 0;\n\t\tif (get_user(Adapter->rtPSBucketSize, (unsigned long __user *)arg))\n\t\t\tStatus = -EFAULT;\n\t\tbreak;\n\n\tcase IOCTL_CHIP_RESET: {\n\t\tINT NVMAccess = down_trylock(&Adapter->NVMRdmWrmLock);\n\t\tif (NVMAccess) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \" IOCTL_BCM_CHIP_RESET not allowed as EEPROM Read/Write is in progress\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tdown(&Adapter->RxAppControlQueuelock);\n\t\tStatus = reset_card_proc(Adapter);\n\t\tflushAllAppQ();\n\t\tup(&Adapter->RxAppControlQueuelock);\n\t\tup(&Adapter->NVMRdmWrmLock);\n\t\tResetCounters(Adapter);\n\t\tbreak;\n\t}\n\n\tcase IOCTL_QOS_THRESHOLD: {\n\t\tUSHORT uiLoopIndex;\n\n\t\tStatus = 0;\n\t\tfor (uiLoopIndex = 0; uiLoopIndex < NO_OF_QUEUES; uiLoopIndex++) {\n\t\t\tif (get_user(Adapter->PackInfo[uiLoopIndex].uiThreshold,\n\t\t\t\t\t(unsigned long __user *)arg)) {\n\t\t\t\tStatus = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase IOCTL_DUMP_PACKET_INFO:\n\t\tDumpPackInfo(Adapter);\n\t\tDumpPhsRules(&Adapter->stBCMPhsContext);\n\t\tStatus = STATUS_SUCCESS;\n\t\tbreak;\n\n\tcase IOCTL_GET_PACK_INFO:\n\t\tif (copy_to_user(argp, &Adapter->PackInfo, sizeof(struct bcm_packet_info)*NO_OF_QUEUES))\n\t\t\treturn -EFAULT;\n\t\tStatus = STATUS_SUCCESS;\n\t\tbreak;\n\n\tcase IOCTL_BCM_SWITCH_TRANSFER_MODE: {\n\t\tUINT uiData = 0;\n\t\tif (copy_from_user(&uiData, argp, sizeof(UINT)))\n\t\t\treturn -EFAULT;\n\n\t\tif (uiData) {\n\t\t\t/* Allow All Packets */\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"IOCTL_BCM_SWITCH_TRANSFER_MODE: ETH_PACKET_TUNNELING_MODE\\n\");\n\t\t\t\tAdapter->TransferMode = ETH_PACKET_TUNNELING_MODE;\n\t\t} else {\n\t\t\t/* Allow IP only Packets */\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"IOCTL_BCM_SWITCH_TRANSFER_MODE: IP_PACKET_ONLY_MODE\\n\");\n\t\t\tAdapter->TransferMode = IP_PACKET_ONLY_MODE;\n\t\t}\n\t\tStatus = STATUS_SUCCESS;\n\t\tbreak;\n\t}\n\n\tcase IOCTL_BCM_GET_DRIVER_VERSION: {\n\t\tulong len;\n\n\t\t/* Copy Ioctl Buffer structure */\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tlen = min_t(ulong, IoBuffer.OutputLength, strlen(DRV_VERSION) + 1);\n\n\t\tif (copy_to_user(IoBuffer.OutputBuffer, DRV_VERSION, len))\n\t\t\treturn -EFAULT;\n\t\tStatus = STATUS_SUCCESS;\n\t\tbreak;\n\t}\n\n\tcase IOCTL_BCM_GET_CURRENT_STATUS: {\n\t\tstruct bcm_link_state link_state;\n\n\t\t/* Copy Ioctl Buffer structure */\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer))) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"copy_from_user failed..\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tif (IoBuffer.OutputLength != sizeof(link_state)) {\n\t\t\tStatus = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tmemset(&link_state, 0, sizeof(link_state));\n\t\tlink_state.bIdleMode = Adapter->IdleMode;\n\t\tlink_state.bShutdownMode = Adapter->bShutStatus;\n\t\tlink_state.ucLinkStatus = Adapter->LinkStatus;\n\n\t\tif (copy_to_user(IoBuffer.OutputBuffer, &link_state, min_t(size_t, sizeof(link_state), IoBuffer.OutputLength))) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Copy_to_user Failed..\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tStatus = STATUS_SUCCESS;\n\t\tbreak;\n\t}\n\n\tcase IOCTL_BCM_SET_MAC_TRACING: {\n\t\tUINT  tracing_flag;\n\n\t\t/* copy ioctl Buffer structure */\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (copy_from_user(&tracing_flag, IoBuffer.InputBuffer, sizeof(UINT)))\n\t\t\treturn -EFAULT;\n\n\t\tif (tracing_flag)\n\t\t\tAdapter->pTarangs->MacTracingEnabled = TRUE;\n\t\telse\n\t\t\tAdapter->pTarangs->MacTracingEnabled = FALSE;\n\t\tbreak;\n\t}\n\n\tcase IOCTL_BCM_GET_DSX_INDICATION: {\n\t\tULONG ulSFId = 0;\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (IoBuffer.OutputLength < sizeof(struct bcm_add_indication_alt)) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,\n\t\t\t\t\t\"Mismatch req: %lx needed is =0x%zx!!!\",\n\t\t\t\t\tIoBuffer.OutputLength, sizeof(struct bcm_add_indication_alt));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (copy_from_user(&ulSFId, IoBuffer.InputBuffer, sizeof(ulSFId)))\n\t\t\treturn -EFAULT;\n\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Get DSX Data SF ID is =%lx\\n\", ulSFId);\n\t\tget_dsx_sf_data_to_application(Adapter, ulSFId, IoBuffer.OutputBuffer);\n\t\tStatus = STATUS_SUCCESS;\n\t}\n\tbreak;\n\n\tcase IOCTL_BCM_GET_HOST_MIBS: {\n\t\tPVOID temp_buff;\n\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (IoBuffer.OutputLength != sizeof(struct bcm_host_stats_mibs)) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,\n\t\t\t\t\t\"Length Check failed %lu %zd\\n\",\n\t\t\t\t\tIoBuffer.OutputLength, sizeof(struct bcm_host_stats_mibs));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* FIXME: HOST_STATS are too big for kmalloc (122048)! */\n\t\ttemp_buff = kzalloc(sizeof(struct bcm_host_stats_mibs), GFP_KERNEL);\n\t\tif (!temp_buff)\n\t\t\treturn STATUS_FAILURE;\n\n\t\tStatus = ProcessGetHostMibs(Adapter, temp_buff);\n\t\tGetDroppedAppCntrlPktMibs(temp_buff, pTarang);\n\n\t\tif (Status != STATUS_FAILURE)\n\t\t\tif (copy_to_user(IoBuffer.OutputBuffer, temp_buff, sizeof(struct bcm_host_stats_mibs))) {\n\t\t\t\tkfree(temp_buff);\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\n\t\tkfree(temp_buff);\n\t\tbreak;\n\t}\n\n\tcase IOCTL_BCM_WAKE_UP_DEVICE_FROM_IDLE:\n\t\tif ((FALSE == Adapter->bTriedToWakeUpFromlowPowerMode) && (TRUE == Adapter->IdleMode)) {\n\t\t\tAdapter->usIdleModePattern = ABORT_IDLE_MODE;\n\t\t\tAdapter->bWakeUpDevice = TRUE;\n\t\t\twake_up(&Adapter->process_rx_cntrlpkt);\n\t\t}\n\n\t\tStatus = STATUS_SUCCESS;\n\t\tbreak;\n\n\tcase IOCTL_BCM_BULK_WRM: {\n\t\tstruct bcm_bulk_wrm_buffer *pBulkBuffer;\n\t\tUINT uiTempVar = 0;\n\t\tPCHAR pvBuffer = NULL;\n\n\t\tif ((Adapter->IdleMode == TRUE) ||\n\t\t\t(Adapter->bShutStatus == TRUE) ||\n\t\t\t(Adapter->bPreparingForLowPowerMode == TRUE)) {\n\n\t\t\tBCM_DEBUG_PRINT (Adapter, DBG_TYPE_PRINTK, 0, 0, \"Device in Idle/Shutdown Mode, Blocking Wrms\\n\");\n\t\t\tStatus = -EACCES;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Copy Ioctl Buffer structure */\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (IoBuffer.InputLength < sizeof(ULONG) * 2)\n\t\t\treturn -EINVAL;\n\n\t\tpvBuffer = memdup_user(IoBuffer.InputBuffer,\n\t\t\t\t       IoBuffer.InputLength);\n\t\tif (IS_ERR(pvBuffer))\n\t\t\treturn PTR_ERR(pvBuffer);\n\n\t\tpBulkBuffer = (struct bcm_bulk_wrm_buffer *)pvBuffer;\n\n\t\tif (((ULONG)pBulkBuffer->Register & 0x0F000000) != 0x0F000000 ||\n\t\t\t((ULONG)pBulkBuffer->Register & 0x3)) {\n\t\t\tBCM_DEBUG_PRINT (Adapter, DBG_TYPE_PRINTK, 0, 0, \"WRM Done On invalid Address : %x Access Denied.\\n\", (int)pBulkBuffer->Register);\n\t\t\tkfree(pvBuffer);\n\t\t\tStatus = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tuiTempVar = pBulkBuffer->Register & EEPROM_REJECT_MASK;\n\t\tif (!((Adapter->pstargetparams->m_u32Customize)&VSG_MODE) &&\n\t\t\t((uiTempVar == EEPROM_REJECT_REG_1) ||\n\t\t\t\t(uiTempVar == EEPROM_REJECT_REG_2) ||\n\t\t\t\t(uiTempVar == EEPROM_REJECT_REG_3) ||\n\t\t\t\t(uiTempVar == EEPROM_REJECT_REG_4)) &&\n\t\t\t(cmd == IOCTL_BCM_REGISTER_WRITE)) {\n\n\t\t\tkfree(pvBuffer);\n\t\t\tBCM_DEBUG_PRINT (Adapter, DBG_TYPE_PRINTK, 0, 0, \"EEPROM Access Denied, not in VSG Mode\\n\");\n\t\t\tStatus = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (pBulkBuffer->SwapEndian == FALSE)\n\t\t\tStatus = wrmWithLock(Adapter, (UINT)pBulkBuffer->Register, (PCHAR)pBulkBuffer->Values, IoBuffer.InputLength - 2*sizeof(ULONG));\n\t\telse\n\t\t\tStatus = wrmaltWithLock(Adapter, (UINT)pBulkBuffer->Register, (PUINT)pBulkBuffer->Values, IoBuffer.InputLength - 2*sizeof(ULONG));\n\n\t\tif (Status != STATUS_SUCCESS)\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"WRM Failed\\n\");\n\n\t\tkfree(pvBuffer);\n\t\tbreak;\n\t}\n\n\tcase IOCTL_BCM_GET_NVM_SIZE:\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (Adapter->eNVMType == NVM_EEPROM || Adapter->eNVMType == NVM_FLASH) {\n\t\t\tif (copy_to_user(IoBuffer.OutputBuffer, &Adapter->uiNVMDSDSize, sizeof(UINT)))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tStatus = STATUS_SUCCESS;\n\t\tbreak;\n\n\tcase IOCTL_BCM_CAL_INIT: {\n\t\tUINT uiSectorSize = 0 ;\n\t\tif (Adapter->eNVMType == NVM_FLASH) {\n\t\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tif (copy_from_user(&uiSectorSize, IoBuffer.InputBuffer, sizeof(UINT)))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tif ((uiSectorSize < MIN_SECTOR_SIZE) || (uiSectorSize > MAX_SECTOR_SIZE)) {\n\t\t\t\tif (copy_to_user(IoBuffer.OutputBuffer, &Adapter->uiSectorSize,\n\t\t\t\t\t\t\tsizeof(UINT)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t} else {\n\t\t\t\tif (IsFlash2x(Adapter)) {\n\t\t\t\t\tif (copy_to_user(IoBuffer.OutputBuffer,\t&Adapter->uiSectorSize, sizeof(UINT)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t} else {\n\t\t\t\t\tif ((TRUE == Adapter->bShutStatus) || (TRUE == Adapter->IdleMode)) {\n\t\t\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Device is in Idle/Shutdown Mode\\n\");\n\t\t\t\t\t\treturn -EACCES;\n\t\t\t\t\t}\n\n\t\t\t\t\tAdapter->uiSectorSize = uiSectorSize;\n\t\t\t\t\tBcmUpdateSectorSize(Adapter, Adapter->uiSectorSize);\n\t\t\t\t}\n\t\t\t}\n\t\t\tStatus = STATUS_SUCCESS;\n\t\t} else {\n\t\t\tStatus = STATUS_FAILURE;\n\t\t}\n\t}\n\tbreak;\n\n\tcase IOCTL_BCM_SET_DEBUG:\n#ifdef DEBUG\n\t{\n\t\tstruct bcm_user_debug_state sUserDebugState;\n\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"In SET_DEBUG ioctl\\n\");\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (copy_from_user(&sUserDebugState, IoBuffer.InputBuffer, sizeof(struct bcm_user_debug_state)))\n\t\t\treturn -EFAULT;\n\n\t\tBCM_DEBUG_PRINT (Adapter, DBG_TYPE_PRINTK, 0, 0, \"IOCTL_BCM_SET_DEBUG: OnOff=%d Type = 0x%x \",\n\t\t\t\tsUserDebugState.OnOff, sUserDebugState.Type);\n\t\t/* sUserDebugState.Subtype <<= 1; */\n\t\tsUserDebugState.Subtype = 1 << sUserDebugState.Subtype;\n\t\tBCM_DEBUG_PRINT (Adapter, DBG_TYPE_PRINTK, 0, 0, \"actual Subtype=0x%x\\n\", sUserDebugState.Subtype);\n\n\t\t/* Update new 'DebugState' in the Adapter */\n\t\tAdapter->stDebugState.type |= sUserDebugState.Type;\n\t\t/* Subtype: A bitmap of 32 bits for Subtype per Type.\n\t\t * Valid indexes in 'subtype' array: 1,2,4,8\n\t\t * corresponding to valid Type values. Hence we can use the 'Type' field\n\t\t * as the index value, ignoring the array entries 0,3,5,6,7 !\n\t\t */\n\t\tif (sUserDebugState.OnOff)\n\t\t\tAdapter->stDebugState.subtype[sUserDebugState.Type] |= sUserDebugState.Subtype;\n\t\telse\n\t\t\tAdapter->stDebugState.subtype[sUserDebugState.Type] &= ~sUserDebugState.Subtype;\n\n\t\tBCM_SHOW_DEBUG_BITMAP(Adapter);\n\t}\n#endif\n\tbreak;\n\n\tcase IOCTL_BCM_NVM_READ:\n\tcase IOCTL_BCM_NVM_WRITE: {\n\t\tstruct bcm_nvm_readwrite stNVMReadWrite;\n\t\tPUCHAR pReadData = NULL;\n\t\tULONG ulDSDMagicNumInUsrBuff = 0;\n\t\tstruct timeval tv0, tv1;\n\t\tmemset(&tv0, 0, sizeof(struct timeval));\n\t\tmemset(&tv1, 0, sizeof(struct timeval));\n\t\tif ((Adapter->eNVMType == NVM_FLASH) && (Adapter->uiFlashLayoutMajorVersion == 0)) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"The Flash Control Section is Corrupted. Hence Rejection on NVM Read/Write\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tif (IsFlash2x(Adapter)) {\n\t\t\tif ((Adapter->eActiveDSD != DSD0) &&\n\t\t\t\t(Adapter->eActiveDSD != DSD1) &&\n\t\t\t\t(Adapter->eActiveDSD != DSD2)) {\n\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"No DSD is active..hence NVM Command is blocked\");\n\t\t\t\treturn STATUS_FAILURE;\n\t\t\t}\n\t\t}\n\n\t\t/* Copy Ioctl Buffer structure */\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (copy_from_user(&stNVMReadWrite,\n\t\t\t\t\t(IOCTL_BCM_NVM_READ == cmd) ? IoBuffer.OutputBuffer : IoBuffer.InputBuffer,\n\t\t\t\t\tsizeof(struct bcm_nvm_readwrite)))\n\t\t\treturn -EFAULT;\n\n\t\t/*\n\t\t * Deny the access if the offset crosses the cal area limit.\n\t\t */\n\t\tif (stNVMReadWrite.uiNumBytes > Adapter->uiNVMDSDSize)\n\t\t\treturn STATUS_FAILURE;\n\n\t\tif (stNVMReadWrite.uiOffset > Adapter->uiNVMDSDSize - stNVMReadWrite.uiNumBytes) {\n\t\t\t/* BCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,\"Can't allow access beyond NVM Size: 0x%x 0x%x\\n\", stNVMReadWrite.uiOffset, stNVMReadWrite.uiNumBytes); */\n\t\t\treturn STATUS_FAILURE;\n\t\t}\n\n\t\tpReadData = memdup_user(stNVMReadWrite.pBuffer,\n\t\t\t\t\tstNVMReadWrite.uiNumBytes);\n\t\tif (IS_ERR(pReadData))\n\t\t\treturn PTR_ERR(pReadData);\n\n\t\tdo_gettimeofday(&tv0);\n\t\tif (IOCTL_BCM_NVM_READ == cmd) {\n\t\t\tdown(&Adapter->NVMRdmWrmLock);\n\n\t\t\tif ((Adapter->IdleMode == TRUE) ||\n\t\t\t\t(Adapter->bShutStatus == TRUE) ||\n\t\t\t\t(Adapter->bPreparingForLowPowerMode == TRUE)) {\n\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Device is in Idle/Shutdown Mode\\n\");\n\t\t\t\tup(&Adapter->NVMRdmWrmLock);\n\t\t\t\tkfree(pReadData);\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\n\t\t\tStatus = BeceemNVMRead(Adapter, (PUINT)pReadData, stNVMReadWrite.uiOffset, stNVMReadWrite.uiNumBytes);\n\t\t\tup(&Adapter->NVMRdmWrmLock);\n\n\t\t\tif (Status != STATUS_SUCCESS) {\n\t\t\t\tkfree(pReadData);\n\t\t\t\treturn Status;\n\t\t\t}\n\n\t\t\tif (copy_to_user(stNVMReadWrite.pBuffer, pReadData, stNVMReadWrite.uiNumBytes)) {\n\t\t\t\tkfree(pReadData);\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t} else {\n\t\t\tdown(&Adapter->NVMRdmWrmLock);\n\n\t\t\tif ((Adapter->IdleMode == TRUE) ||\n\t\t\t\t(Adapter->bShutStatus == TRUE) ||\n\t\t\t\t(Adapter->bPreparingForLowPowerMode == TRUE)) {\n\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Device is in Idle/Shutdown Mode\\n\");\n\t\t\t\tup(&Adapter->NVMRdmWrmLock);\n\t\t\t\tkfree(pReadData);\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\n\t\t\tAdapter->bHeaderChangeAllowed = TRUE;\n\t\t\tif (IsFlash2x(Adapter)) {\n\t\t\t\t/*\n\t\t\t\t *\t\t\tNew Requirement:-\n\t\t\t\t *\t\t\tDSD section updation will be allowed in two case:-\n\t\t\t\t *\t\t\t1.  if DSD sig is present in DSD header means dongle is ok and updation is fruitfull\n\t\t\t\t *\t\t\t2.  if point 1 failes then user buff should have DSD sig. this point ensures that if dongle is\n\t\t\t\t *\t\t\t      corrupted then user space program first modify the DSD header with valid DSD sig so\n\t\t\t\t *\t\t\t      that this as well as further write may be worthwhile.\n\t\t\t\t *\n\t\t\t\t *\t\t\t This restriction has been put assuming that if DSD sig is corrupted, DSD\n\t\t\t\t *\t\t\t data won't be considered valid.\n\t\t\t\t */\n\n\t\t\t\tStatus = BcmFlash2xCorruptSig(Adapter, Adapter->eActiveDSD);\n\t\t\t\tif (Status != STATUS_SUCCESS) {\n\t\t\t\t\tif (((stNVMReadWrite.uiOffset + stNVMReadWrite.uiNumBytes) != Adapter->uiNVMDSDSize) ||\n\t\t\t\t\t\t(stNVMReadWrite.uiNumBytes < SIGNATURE_SIZE)) {\n\n\t\t\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"DSD Sig is present neither in Flash nor User provided Input..\");\n\t\t\t\t\t\tup(&Adapter->NVMRdmWrmLock);\n\t\t\t\t\t\tkfree(pReadData);\n\t\t\t\t\t\treturn Status;\n\t\t\t\t\t}\n\n\t\t\t\t\tulDSDMagicNumInUsrBuff = ntohl(*(PUINT)(pReadData + stNVMReadWrite.uiNumBytes - SIGNATURE_SIZE));\n\t\t\t\t\tif (ulDSDMagicNumInUsrBuff != DSD_IMAGE_MAGIC_NUMBER) {\n\t\t\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"DSD Sig is present neither in Flash nor User provided Input..\");\n\t\t\t\t\t\tup(&Adapter->NVMRdmWrmLock);\n\t\t\t\t\t\tkfree(pReadData);\n\t\t\t\t\t\treturn Status;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tStatus = BeceemNVMWrite(Adapter, (PUINT)pReadData, stNVMReadWrite.uiOffset, stNVMReadWrite.uiNumBytes, stNVMReadWrite.bVerify);\n\t\t\tif (IsFlash2x(Adapter))\n\t\t\t\tBcmFlash2xWriteSig(Adapter, Adapter->eActiveDSD);\n\n\t\t\tAdapter->bHeaderChangeAllowed = FALSE;\n\n\t\t\tup(&Adapter->NVMRdmWrmLock);\n\n\t\t\tif (Status != STATUS_SUCCESS) {\n\t\t\t\tkfree(pReadData);\n\t\t\t\treturn Status;\n\t\t\t}\n\t\t}\n\n\t\tdo_gettimeofday(&tv1);\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \" timetaken by Write/read :%ld msec\\n\", (tv1.tv_sec - tv0.tv_sec)*1000 + (tv1.tv_usec - tv0.tv_usec)/1000);\n\n\t\tkfree(pReadData);\n\t\treturn STATUS_SUCCESS;\n\t}\n\n\tcase IOCTL_BCM_FLASH2X_SECTION_READ: {\n\t\tstruct bcm_flash2x_readwrite sFlash2xRead = {0};\n\t\tPUCHAR pReadBuff = NULL ;\n\t\tUINT NOB = 0;\n\t\tUINT BuffSize = 0;\n\t\tUINT ReadBytes = 0;\n\t\tUINT ReadOffset = 0;\n\t\tvoid __user *OutPutBuff;\n\n\t\tif (IsFlash2x(Adapter) != TRUE)\t{\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Flash Does not have 2.x map\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"IOCTL_BCM_FLASH2X_SECTION_READ Called\");\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\t/* Reading FLASH 2.x READ structure */\n\t\tif (copy_from_user(&sFlash2xRead, IoBuffer.InputBuffer, sizeof(struct bcm_flash2x_readwrite)))\n\t\t\treturn -EFAULT;\n\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"\\nsFlash2xRead.Section :%x\", sFlash2xRead.Section);\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"\\nsFlash2xRead.offset :%x\", sFlash2xRead.offset);\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"\\nsFlash2xRead.numOfBytes :%x\", sFlash2xRead.numOfBytes);\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"\\nsFlash2xRead.bVerify :%x\\n\", sFlash2xRead.bVerify);\n\n\t\t/* This was internal to driver for raw read. now it has ben exposed to user space app. */\n\t\tif (validateFlash2xReadWrite(Adapter, &sFlash2xRead) == FALSE)\n\t\t\treturn STATUS_FAILURE;\n\n\t\tNOB = sFlash2xRead.numOfBytes;\n\t\tif (NOB > Adapter->uiSectorSize)\n\t\t\tBuffSize = Adapter->uiSectorSize;\n\t\telse\n\t\t\tBuffSize = NOB;\n\n\t\tReadOffset = sFlash2xRead.offset ;\n\t\tOutPutBuff = IoBuffer.OutputBuffer;\n\t\tpReadBuff = (PCHAR)kzalloc(BuffSize , GFP_KERNEL);\n\n\t\tif (pReadBuff == NULL) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Memory allocation failed for Flash 2.x Read Structure\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tdown(&Adapter->NVMRdmWrmLock);\n\n\t\tif ((Adapter->IdleMode == TRUE) ||\n\t\t\t(Adapter->bShutStatus == TRUE) ||\n\t\t\t(Adapter->bPreparingForLowPowerMode == TRUE)) {\n\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Device is in Idle/Shutdown Mode\\n\");\n\t\t\tup(&Adapter->NVMRdmWrmLock);\n\t\t\tkfree(pReadBuff);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\twhile (NOB) {\n\t\t\tif (NOB > Adapter->uiSectorSize)\n\t\t\t\tReadBytes = Adapter->uiSectorSize;\n\t\t\telse\n\t\t\t\tReadBytes = NOB;\n\n\t\t\t/* Reading the data from Flash 2.x */\n\t\t\tStatus = BcmFlash2xBulkRead(Adapter, (PUINT)pReadBuff, sFlash2xRead.Section, ReadOffset, ReadBytes);\n\t\t\tif (Status) {\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Flash 2x read err with Status :%d\", Status);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tBCM_DEBUG_PRINT_BUFFER(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, pReadBuff, ReadBytes);\n\n\t\t\tStatus = copy_to_user(OutPutBuff, pReadBuff, ReadBytes);\n\t\t\tif (Status) {\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Copy to use failed with status :%d\", Status);\n\t\t\t\tup(&Adapter->NVMRdmWrmLock);\n\t\t\t\tkfree(pReadBuff);\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t\tNOB = NOB - ReadBytes;\n\t\t\tif (NOB) {\n\t\t\t\tReadOffset = ReadOffset + ReadBytes;\n\t\t\t\tOutPutBuff = OutPutBuff + ReadBytes ;\n\t\t\t}\n\t\t}\n\n\t\tup(&Adapter->NVMRdmWrmLock);\n\t\tkfree(pReadBuff);\n\t}\n\tbreak;\n\n\tcase IOCTL_BCM_FLASH2X_SECTION_WRITE: {\n\t\tstruct bcm_flash2x_readwrite sFlash2xWrite = {0};\n\t\tPUCHAR pWriteBuff;\n\t\tvoid __user *InputAddr;\n\t\tUINT NOB = 0;\n\t\tUINT BuffSize = 0;\n\t\tUINT WriteOffset = 0;\n\t\tUINT WriteBytes = 0;\n\n\t\tif (IsFlash2x(Adapter) != TRUE) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Flash Does not have 2.x map\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* First make this False so that we can enable the Sector Permission Check in BeceemFlashBulkWrite */\n\t\tAdapter->bAllDSDWriteAllow = FALSE;\n\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"IOCTL_BCM_FLASH2X_SECTION_WRITE Called\");\n\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\t/* Reading FLASH 2.x READ structure */\n\t\tif (copy_from_user(&sFlash2xWrite, IoBuffer.InputBuffer, sizeof(struct bcm_flash2x_readwrite)))\n\t\t\treturn -EFAULT;\n\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"\\nsFlash2xRead.Section :%x\", sFlash2xWrite.Section);\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"\\nsFlash2xRead.offset :%d\", sFlash2xWrite.offset);\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"\\nsFlash2xRead.numOfBytes :%x\", sFlash2xWrite.numOfBytes);\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"\\nsFlash2xRead.bVerify :%x\\n\", sFlash2xWrite.bVerify);\n\n\t\tif ((sFlash2xWrite.Section != VSA0) && (sFlash2xWrite.Section != VSA1) && (sFlash2xWrite.Section != VSA2)) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Only VSA write is allowed\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (validateFlash2xReadWrite(Adapter, &sFlash2xWrite) == FALSE)\n\t\t\treturn STATUS_FAILURE;\n\n\t\tInputAddr = sFlash2xWrite.pDataBuff;\n\t\tWriteOffset = sFlash2xWrite.offset;\n\t\tNOB = sFlash2xWrite.numOfBytes;\n\n\t\tif (NOB > Adapter->uiSectorSize)\n\t\t\tBuffSize = Adapter->uiSectorSize;\n\t\telse\n\t\t\tBuffSize = NOB ;\n\n\t\tpWriteBuff = kmalloc(BuffSize, GFP_KERNEL);\n\n\t\tif (pWriteBuff == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\t/* extracting the remainder of the given offset. */\n\t\tWriteBytes = Adapter->uiSectorSize;\n\t\tif (WriteOffset % Adapter->uiSectorSize)\n\t\t\tWriteBytes = Adapter->uiSectorSize - (WriteOffset % Adapter->uiSectorSize);\n\n\t\tif (NOB < WriteBytes)\n\t\t\tWriteBytes = NOB;\n\n\t\tdown(&Adapter->NVMRdmWrmLock);\n\n\t\tif ((Adapter->IdleMode == TRUE) ||\n\t\t\t(Adapter->bShutStatus == TRUE) ||\n\t\t\t(Adapter->bPreparingForLowPowerMode == TRUE)) {\n\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Device is in Idle/Shutdown Mode\\n\");\n\t\t\tup(&Adapter->NVMRdmWrmLock);\n\t\t\tkfree(pWriteBuff);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tBcmFlash2xCorruptSig(Adapter, sFlash2xWrite.Section);\n\t\tdo {\n\t\t\tStatus = copy_from_user(pWriteBuff, InputAddr, WriteBytes);\n\t\t\tif (Status) {\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Copy to user failed with status :%d\", Status);\n\t\t\t\tup(&Adapter->NVMRdmWrmLock);\n\t\t\t\tkfree(pWriteBuff);\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t\tBCM_DEBUG_PRINT_BUFFER(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, pWriteBuff, WriteBytes);\n\n\t\t\t/* Writing the data from Flash 2.x */\n\t\t\tStatus = BcmFlash2xBulkWrite(Adapter, (PUINT)pWriteBuff, sFlash2xWrite.Section, WriteOffset, WriteBytes, sFlash2xWrite.bVerify);\n\n\t\t\tif (Status) {\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Flash 2x read err with Status :%d\", Status);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tNOB = NOB - WriteBytes;\n\t\t\tif (NOB) {\n\t\t\t\tWriteOffset = WriteOffset + WriteBytes;\n\t\t\t\tInputAddr = InputAddr + WriteBytes;\n\t\t\t\tif (NOB > Adapter->uiSectorSize)\n\t\t\t\t\tWriteBytes = Adapter->uiSectorSize;\n\t\t\t\telse\n\t\t\t\t\tWriteBytes = NOB;\n\t\t\t}\n\t\t} while (NOB > 0);\n\n\t\tBcmFlash2xWriteSig(Adapter, sFlash2xWrite.Section);\n\t\tup(&Adapter->NVMRdmWrmLock);\n\t\tkfree(pWriteBuff);\n\t}\n\tbreak;\n\n\tcase IOCTL_BCM_GET_FLASH2X_SECTION_BITMAP: {\n\t\tstruct bcm_flash2x_bitmap *psFlash2xBitMap;\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"IOCTL_BCM_GET_FLASH2X_SECTION_BITMAP Called\");\n\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (IoBuffer.OutputLength != sizeof(struct bcm_flash2x_bitmap))\n\t\t\treturn -EINVAL;\n\n\t\tpsFlash2xBitMap = kzalloc(sizeof(struct bcm_flash2x_bitmap), GFP_KERNEL);\n\t\tif (psFlash2xBitMap == NULL) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Memory is not available\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\t/* Reading the Flash Sectio Bit map */\n\t\tdown(&Adapter->NVMRdmWrmLock);\n\n\t\tif ((Adapter->IdleMode == TRUE) ||\n\t\t\t(Adapter->bShutStatus == TRUE) ||\n\t\t\t(Adapter->bPreparingForLowPowerMode == TRUE)) {\n\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Device is in Idle/Shutdown Mode\\n\");\n\t\t\tup(&Adapter->NVMRdmWrmLock);\n\t\t\tkfree(psFlash2xBitMap);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tBcmGetFlash2xSectionalBitMap(Adapter, psFlash2xBitMap);\n\t\tup(&Adapter->NVMRdmWrmLock);\n\t\tif (copy_to_user(IoBuffer.OutputBuffer, psFlash2xBitMap, sizeof(struct bcm_flash2x_bitmap))) {\n\t\t\tkfree(psFlash2xBitMap);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tkfree(psFlash2xBitMap);\n\t}\n\tbreak;\n\n\tcase IOCTL_BCM_SET_ACTIVE_SECTION: {\n\t\tenum bcm_flash2x_section_val eFlash2xSectionVal = 0;\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"IOCTL_BCM_SET_ACTIVE_SECTION Called\");\n\n\t\tif (IsFlash2x(Adapter) != TRUE) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Flash Does not have 2.x map\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tStatus = copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer));\n\t\tif (Status) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Copy of IOCTL BUFFER failed\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tStatus = copy_from_user(&eFlash2xSectionVal, IoBuffer.InputBuffer, sizeof(INT));\n\t\tif (Status) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Copy of flash section val failed\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tdown(&Adapter->NVMRdmWrmLock);\n\n\t\tif ((Adapter->IdleMode == TRUE) ||\n\t\t\t(Adapter->bShutStatus == TRUE) ||\n\t\t\t(Adapter->bPreparingForLowPowerMode == TRUE)) {\n\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Device is in Idle/Shutdown Mode\\n\");\n\t\t\tup(&Adapter->NVMRdmWrmLock);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tStatus = BcmSetActiveSection(Adapter, eFlash2xSectionVal);\n\t\tif (Status)\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Failed to make it's priority Highest. Status %d\", Status);\n\n\t\tup(&Adapter->NVMRdmWrmLock);\n\t}\n\tbreak;\n\n\tcase IOCTL_BCM_IDENTIFY_ACTIVE_SECTION: {\n\t\t/* Right Now we are taking care of only DSD */\n\t\tAdapter->bAllDSDWriteAllow = FALSE;\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"IOCTL_BCM_IDENTIFY_ACTIVE_SECTION called\");\n\t\tStatus = STATUS_SUCCESS;\n\t}\n\tbreak;\n\n\tcase IOCTL_BCM_COPY_SECTION: {\n\t\tstruct bcm_flash2x_copy_section sCopySectStrut = {0};\n\t\tStatus = STATUS_SUCCESS;\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"IOCTL_BCM_COPY_SECTION  Called\");\n\n\t\tAdapter->bAllDSDWriteAllow = FALSE;\n\t\tif (IsFlash2x(Adapter) != TRUE) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Flash Does not have 2.x map\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tStatus = copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer));\n\t\tif (Status) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Copy of IOCTL BUFFER failed Status :%d\", Status);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tStatus = copy_from_user(&sCopySectStrut, IoBuffer.InputBuffer, sizeof(struct bcm_flash2x_copy_section));\n\t\tif (Status) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Copy of Copy_Section_Struct failed with Status :%d\", Status);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Source SEction :%x\", sCopySectStrut.SrcSection);\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Destination SEction :%x\", sCopySectStrut.DstSection);\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"offset :%x\", sCopySectStrut.offset);\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"NOB :%x\", sCopySectStrut.numOfBytes);\n\n\t\tif (IsSectionExistInFlash(Adapter, sCopySectStrut.SrcSection) == FALSE) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Source Section<%x> does not exixt in Flash \", sCopySectStrut.SrcSection);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (IsSectionExistInFlash(Adapter, sCopySectStrut.DstSection) == FALSE) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Destinatio Section<%x> does not exixt in Flash \", sCopySectStrut.DstSection);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (sCopySectStrut.SrcSection == sCopySectStrut.DstSection) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Source and Destination section should be different\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdown(&Adapter->NVMRdmWrmLock);\n\n\t\tif ((Adapter->IdleMode == TRUE) ||\n\t\t\t(Adapter->bShutStatus == TRUE) ||\n\t\t\t(Adapter->bPreparingForLowPowerMode == TRUE)) {\n\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Device is in Idle/Shutdown Mode\\n\");\n\t\t\tup(&Adapter->NVMRdmWrmLock);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (sCopySectStrut.SrcSection == ISO_IMAGE1 || sCopySectStrut.SrcSection == ISO_IMAGE2) {\n\t\t\tif (IsNonCDLessDevice(Adapter)) {\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Device is Non-CDLess hence won't have ISO !!\");\n\t\t\t\tStatus = -EINVAL;\n\t\t\t} else if (sCopySectStrut.numOfBytes == 0) {\n\t\t\t\tStatus = BcmCopyISO(Adapter, sCopySectStrut);\n\t\t\t} else {\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Partial Copy of ISO section is not Allowed..\");\n\t\t\t\tStatus = STATUS_FAILURE;\n\t\t\t}\n\t\t\tup(&Adapter->NVMRdmWrmLock);\n\t\t\treturn Status;\n\t\t}\n\n\t\tStatus = BcmCopySection(Adapter, sCopySectStrut.SrcSection,\n\t\t\t\t\tsCopySectStrut.DstSection, sCopySectStrut.offset, sCopySectStrut.numOfBytes);\n\t\tup(&Adapter->NVMRdmWrmLock);\n\t}\n\tbreak;\n\n\tcase IOCTL_BCM_GET_FLASH_CS_INFO: {\n\t\tStatus = STATUS_SUCCESS;\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \" IOCTL_BCM_GET_FLASH_CS_INFO Called\");\n\n\t\tStatus = copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer));\n\t\tif (Status) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Copy of IOCTL BUFFER failed\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tif (Adapter->eNVMType != NVM_FLASH) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Connected device does not have flash\");\n\t\t\tStatus = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (IsFlash2x(Adapter) == TRUE) {\n\t\t\tif (IoBuffer.OutputLength < sizeof(struct bcm_flash2x_cs_info))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (copy_to_user(IoBuffer.OutputBuffer, Adapter->psFlash2xCSInfo, sizeof(struct bcm_flash2x_cs_info)))\n\t\t\t\treturn -EFAULT;\n\t\t} else {\n\t\t\tif (IoBuffer.OutputLength < sizeof(struct bcm_flash_cs_info))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (copy_to_user(IoBuffer.OutputBuffer, Adapter->psFlashCSInfo, sizeof(struct bcm_flash_cs_info)))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\tbreak;\n\n\tcase IOCTL_BCM_SELECT_DSD: {\n\t\tUINT SectOfset = 0;\n\t\tenum bcm_flash2x_section_val eFlash2xSectionVal;\n\t\teFlash2xSectionVal = NO_SECTION_VAL;\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"IOCTL_BCM_SELECT_DSD Called\");\n\n\t\tif (IsFlash2x(Adapter) != TRUE) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Flash Does not have 2.x map\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tStatus = copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer));\n\t\tif (Status) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Copy of IOCTL BUFFER failed\");\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tStatus = copy_from_user(&eFlash2xSectionVal, IoBuffer.InputBuffer, sizeof(INT));\n\t\tif (Status) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Copy of flash section val failed\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Read Section :%d\", eFlash2xSectionVal);\n\t\tif ((eFlash2xSectionVal != DSD0) &&\n\t\t\t(eFlash2xSectionVal != DSD1) &&\n\t\t\t(eFlash2xSectionVal != DSD2)) {\n\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Passed section<%x> is not DSD section\", eFlash2xSectionVal);\n\t\t\treturn STATUS_FAILURE;\n\t\t}\n\n\t\tSectOfset = BcmGetSectionValStartOffset(Adapter, eFlash2xSectionVal);\n\t\tif (SectOfset == INVALID_OFFSET) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Provided Section val <%d> does not exixt in Flash 2.x\", eFlash2xSectionVal);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tAdapter->bAllDSDWriteAllow = TRUE;\n\t\tAdapter->ulFlashCalStart = SectOfset;\n\t\tAdapter->eActiveDSD = eFlash2xSectionVal;\n\t}\n\tStatus = STATUS_SUCCESS;\n\tbreak;\n\n\tcase IOCTL_BCM_NVM_RAW_READ: {\n\t\tstruct bcm_nvm_readwrite stNVMRead;\n\t\tINT NOB ;\n\t\tINT BuffSize ;\n\t\tINT ReadOffset = 0;\n\t\tUINT ReadBytes = 0 ;\n\t\tPUCHAR pReadBuff;\n\t\tvoid __user *OutPutBuff;\n\n\t\tif (Adapter->eNVMType != NVM_FLASH) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"NVM TYPE is not Flash\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* Copy Ioctl Buffer structure */\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer))) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"copy_from_user 1 failed\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tif (copy_from_user(&stNVMRead, IoBuffer.OutputBuffer, sizeof(struct bcm_nvm_readwrite)))\n\t\t\treturn -EFAULT;\n\n\t\tNOB = stNVMRead.uiNumBytes;\n\t\t/* In Raw-Read max Buff size : 64MB */\n\n\t\tif (NOB > DEFAULT_BUFF_SIZE)\n\t\t\tBuffSize = DEFAULT_BUFF_SIZE;\n\t\telse\n\t\t\tBuffSize = NOB;\n\n\t\tReadOffset = stNVMRead.uiOffset;\n\t\tOutPutBuff = stNVMRead.pBuffer;\n\n\t\tpReadBuff = kzalloc(BuffSize , GFP_KERNEL);\n\t\tif (pReadBuff == NULL) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Memory allocation failed for Flash 2.x Read Structure\");\n\t\t\tStatus = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\tdown(&Adapter->NVMRdmWrmLock);\n\n\t\tif ((Adapter->IdleMode == TRUE) ||\n\t\t\t(Adapter->bShutStatus == TRUE) ||\n\t\t\t(Adapter->bPreparingForLowPowerMode == TRUE)) {\n\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Device is in Idle/Shutdown Mode\\n\");\n\t\t\tkfree(pReadBuff);\n\t\t\tup(&Adapter->NVMRdmWrmLock);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tAdapter->bFlashRawRead = TRUE;\n\n\t\twhile (NOB) {\n\t\t\tif (NOB > DEFAULT_BUFF_SIZE)\n\t\t\t\tReadBytes = DEFAULT_BUFF_SIZE;\n\t\t\telse\n\t\t\t\tReadBytes = NOB;\n\n\t\t\t/* Reading the data from Flash 2.x */\n\t\t\tStatus = BeceemNVMRead(Adapter, (PUINT)pReadBuff, ReadOffset, ReadBytes);\n\t\t\tif (Status) {\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Flash 2x read err with Status :%d\", Status);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tBCM_DEBUG_PRINT_BUFFER(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, pReadBuff, ReadBytes);\n\n\t\t\tStatus = copy_to_user(OutPutBuff, pReadBuff, ReadBytes);\n\t\t\tif (Status) {\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Copy to use failed with status :%d\", Status);\n\t\t\t\tup(&Adapter->NVMRdmWrmLock);\n\t\t\t\tkfree(pReadBuff);\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t\tNOB = NOB - ReadBytes;\n\t\t\tif (NOB) {\n\t\t\t\tReadOffset = ReadOffset + ReadBytes;\n\t\t\t\tOutPutBuff = OutPutBuff + ReadBytes;\n\t\t\t}\n\t\t}\n\t\tAdapter->bFlashRawRead = FALSE;\n\t\tup(&Adapter->NVMRdmWrmLock);\n\t\tkfree(pReadBuff);\n\t\tbreak;\n\t}\n\n\tcase IOCTL_BCM_CNTRLMSG_MASK: {\n\t\tULONG RxCntrlMsgBitMask = 0;\n\n\t\t/* Copy Ioctl Buffer structure */\n\t\tStatus = copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer));\n\t\tif (Status) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"copy of Ioctl buffer is failed from user space\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tif (IoBuffer.InputLength != sizeof(unsigned long)) {\n\t\t\tStatus = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tStatus = copy_from_user(&RxCntrlMsgBitMask, IoBuffer.InputBuffer, IoBuffer.InputLength);\n\t\tif (Status) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"copy of control bit mask failed from user space\");\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"\\n Got user defined cntrl msg bit mask :%lx\", RxCntrlMsgBitMask);\n\t\tpTarang->RxCntrlMsgBitMask = RxCntrlMsgBitMask;\n\t}\n\tbreak;\n\n\tcase IOCTL_BCM_GET_DEVICE_DRIVER_INFO: {\n\t\tstruct bcm_driver_info DevInfo;\n \n \t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Called IOCTL_BCM_GET_DEVICE_DRIVER_INFO\\n\");\n \n\t\tmemset(&DevInfo, 0, sizeof(DevInfo));\n \t\tDevInfo.MaxRDMBufferSize = BUFFER_4K;\n \t\tDevInfo.u32DSDStartOffset = EEPROM_CALPARAM_START;\n \t\tDevInfo.u32RxAlignmentCorrection = 0;\n\t\tDevInfo.u32NVMType = Adapter->eNVMType;\n\t\tDevInfo.u32InterfaceType = BCM_USB;\n\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (IoBuffer.OutputLength < sizeof(DevInfo))\n\t\t\treturn -EINVAL;\n\n\t\tif (copy_to_user(IoBuffer.OutputBuffer, &DevInfo, sizeof(DevInfo)))\n\t\t\treturn -EFAULT;\n\t}\n\tbreak;\n\n\tcase IOCTL_BCM_TIME_SINCE_NET_ENTRY: {\n\t\tstruct bcm_time_elapsed stTimeElapsedSinceNetEntry = {0};\n\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"IOCTL_BCM_TIME_SINCE_NET_ENTRY called\");\n\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (IoBuffer.OutputLength < sizeof(struct bcm_time_elapsed))\n\t\t\treturn -EINVAL;\n\n\t\tstTimeElapsedSinceNetEntry.ul64TimeElapsedSinceNetEntry = get_seconds() - Adapter->liTimeSinceLastNetEntry;\n\n\t\tif (copy_to_user(IoBuffer.OutputBuffer, &stTimeElapsedSinceNetEntry, sizeof(struct bcm_time_elapsed)))\n\t\t\treturn -EFAULT;\n\t}\n\tbreak;\n\n\tcase IOCTL_CLOSE_NOTIFICATION:\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"IOCTL_CLOSE_NOTIFICATION\");\n\t\tbreak;\n\n\tdefault:\n\t\tpr_info(DRV_NAME \": unknown ioctl cmd=%#x\\n\", cmd);\n\t\tStatus = STATUS_FAILURE;\n\t\tbreak;\n\t}\n\treturn Status;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141742,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int l2tp_ip6_recvmsg(struct kiocb *iocb, struct sock *sk,\n\t\t\t    struct msghdr *msg, size_t len, int noblock,\n\t\t\t    int flags, int *addr_len)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sockaddr_l2tpip6 *lsa = (struct sockaddr_l2tpip6 *)msg->msg_name;\n\tsize_t copied = 0;\n\tint err = -EOPNOTSUPP;\n\tstruct sk_buff *skb;\n\n\tif (flags & MSG_OOB)\n\t\tgoto out;\n\n\tif (addr_len)\n\t\t*addr_len = sizeof(*lsa);\n\n\tif (flags & MSG_ERRQUEUE)\n\t\treturn ipv6_recv_error(sk, msg, len);\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb)\n\t\tgoto out;\n\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err)\n\t\tgoto done;\n\n\tsock_recv_timestamp(msg, sk, skb);\n\n\t/* Copy the address. */\n\tif (lsa) {\n\t\tlsa->l2tp_family = AF_INET6;\n\t\tlsa->l2tp_unused = 0;\n \t\tlsa->l2tp_addr = ipv6_hdr(skb)->saddr;\n \t\tlsa->l2tp_flowinfo = 0;\n \t\tlsa->l2tp_scope_id = 0;\n \t\tif (ipv6_addr_type(&lsa->l2tp_addr) & IPV6_ADDR_LINKLOCAL)\n \t\t\tlsa->l2tp_scope_id = IP6CB(skb)->iif;\n \t}\n\n\tif (np->rxopt.all)\n\t\tip6_datagram_recv_ctl(sk, msg, skb);\n\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skb->len;\ndone:\n\tskb_free_datagram(sk, skb);\nout:\n\treturn err ? err : copied;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141767,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int l2tp_ip6_recvmsg(struct kiocb *iocb, struct sock *sk,\n\t\t\t    struct msghdr *msg, size_t len, int noblock,\n\t\t\t    int flags, int *addr_len)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sockaddr_l2tpip6 *lsa = (struct sockaddr_l2tpip6 *)msg->msg_name;\n\tsize_t copied = 0;\n\tint err = -EOPNOTSUPP;\n\tstruct sk_buff *skb;\n\n\tif (flags & MSG_OOB)\n\t\tgoto out;\n\n\tif (addr_len)\n\t\t*addr_len = sizeof(*lsa);\n\n\tif (flags & MSG_ERRQUEUE)\n\t\treturn ipv6_recv_error(sk, msg, len);\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb)\n\t\tgoto out;\n\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err)\n\t\tgoto done;\n\n\tsock_recv_timestamp(msg, sk, skb);\n\n\t/* Copy the address. */\n\tif (lsa) {\n\t\tlsa->l2tp_family = AF_INET6;\n\t\tlsa->l2tp_unused = 0;\n \t\tlsa->l2tp_addr = ipv6_hdr(skb)->saddr;\n \t\tlsa->l2tp_flowinfo = 0;\n \t\tlsa->l2tp_scope_id = 0;\n\t\tlsa->l2tp_conn_id = 0;\n \t\tif (ipv6_addr_type(&lsa->l2tp_addr) & IPV6_ADDR_LINKLOCAL)\n \t\t\tlsa->l2tp_scope_id = IP6CB(skb)->iif;\n \t}\n\n\tif (np->rxopt.all)\n\t\tip6_datagram_recv_ctl(sk, msg, skb);\n\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skb->len;\ndone:\n\tskb_free_datagram(sk, skb);\nout:\n\treturn err ? err : copied;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141768,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int iucv_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t     struct msghdr *msg, size_t len, int flags)\n{\n\tint noblock = flags & MSG_DONTWAIT;\n\tstruct sock *sk = sock->sk;\n\tstruct iucv_sock *iucv = iucv_sk(sk);\n\tunsigned int copied, rlen;\n \tstruct sk_buff *skb, *rskb, *cskb;\n \tint err = 0;\n \n \tif ((sk->sk_state == IUCV_DISCONN) &&\n \t    skb_queue_empty(&iucv->backlog_skb_q) &&\n \t    skb_queue_empty(&sk->sk_receive_queue) &&\n\t    list_empty(&iucv->message_q.list))\n\t\treturn 0;\n\n\tif (flags & (MSG_OOB))\n\t\treturn -EOPNOTSUPP;\n\n\t/* receive/dequeue next skb:\n\t * the function understands MSG_PEEK and, thus, does not dequeue skb */\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb) {\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\treturn 0;\n\t\treturn err;\n\t}\n\n\trlen   = skb->len;\t\t/* real length of skb */\n\tcopied = min_t(unsigned int, rlen, len);\n\tif (!rlen)\n\t\tsk->sk_shutdown = sk->sk_shutdown | RCV_SHUTDOWN;\n\n\tcskb = skb;\n\tif (skb_copy_datagram_iovec(cskb, 0, msg->msg_iov, copied)) {\n\t\tif (!(flags & MSG_PEEK))\n\t\t\tskb_queue_head(&sk->sk_receive_queue, skb);\n\t\treturn -EFAULT;\n\t}\n\n\t/* SOCK_SEQPACKET: set MSG_TRUNC if recv buf size is too small */\n\tif (sk->sk_type == SOCK_SEQPACKET) {\n\t\tif (copied < rlen)\n\t\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\t/* each iucv message contains a complete record */\n\t\tmsg->msg_flags |= MSG_EOR;\n\t}\n\n\t/* create control message to store iucv msg target class:\n\t * get the trgcls from the control buffer of the skb due to\n\t * fragmentation of original iucv message. */\n\terr = put_cmsg(msg, SOL_IUCV, SCM_IUCV_TRGCLS,\n\t\t\tCB_TRGCLS_LEN, CB_TRGCLS(skb));\n\tif (err) {\n\t\tif (!(flags & MSG_PEEK))\n\t\t\tskb_queue_head(&sk->sk_receive_queue, skb);\n\t\treturn err;\n\t}\n\n\t/* Mark read part of skb as used */\n\tif (!(flags & MSG_PEEK)) {\n\n\t\t/* SOCK_STREAM: re-queue skb if it contains unreceived data */\n\t\tif (sk->sk_type == SOCK_STREAM) {\n\t\t\tskb_pull(skb, copied);\n\t\t\tif (skb->len) {\n\t\t\t\tskb_queue_head(&sk->sk_receive_queue, skb);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\n\t\tkfree_skb(skb);\n\t\tif (iucv->transport == AF_IUCV_TRANS_HIPER) {\n\t\t\tatomic_inc(&iucv->msg_recv);\n\t\t\tif (atomic_read(&iucv->msg_recv) > iucv->msglimit) {\n\t\t\t\tWARN_ON(1);\n\t\t\t\tiucv_sock_close(sk);\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t}\n\n\t\t/* Queue backlog skbs */\n\t\tspin_lock_bh(&iucv->message_q.lock);\n\t\trskb = skb_dequeue(&iucv->backlog_skb_q);\n\t\twhile (rskb) {\n\t\t\tif (sock_queue_rcv_skb(sk, rskb)) {\n\t\t\t\tskb_queue_head(&iucv->backlog_skb_q,\n\t\t\t\t\t\trskb);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\trskb = skb_dequeue(&iucv->backlog_skb_q);\n\t\t\t}\n\t\t}\n\t\tif (skb_queue_empty(&iucv->backlog_skb_q)) {\n\t\t\tif (!list_empty(&iucv->message_q.list))\n\t\t\t\tiucv_process_message_q(sk);\n\t\t\tif (atomic_read(&iucv->msg_recv) >=\n\t\t\t\t\t\t\tiucv->msglimit / 2) {\n\t\t\t\terr = iucv_send_ctrl(sk, AF_IUCV_FLAG_WIN);\n\t\t\t\tif (err) {\n\t\t\t\t\tsk->sk_state = IUCV_DISCONN;\n\t\t\t\t\tsk->sk_state_change(sk);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tspin_unlock_bh(&iucv->message_q.lock);\n\t}\n\ndone:\n\t/* SOCK_SEQPACKET: return real length if MSG_TRUNC is set */\n\tif (sk->sk_type == SOCK_SEQPACKET && (flags & MSG_TRUNC))\n\t\tcopied = rlen;\n\n\treturn copied;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141769,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int iucv_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t     struct msghdr *msg, size_t len, int flags)\n{\n\tint noblock = flags & MSG_DONTWAIT;\n\tstruct sock *sk = sock->sk;\n\tstruct iucv_sock *iucv = iucv_sk(sk);\n\tunsigned int copied, rlen;\n \tstruct sk_buff *skb, *rskb, *cskb;\n \tint err = 0;\n \n\tmsg->msg_namelen = 0;\n\n \tif ((sk->sk_state == IUCV_DISCONN) &&\n \t    skb_queue_empty(&iucv->backlog_skb_q) &&\n \t    skb_queue_empty(&sk->sk_receive_queue) &&\n\t    list_empty(&iucv->message_q.list))\n\t\treturn 0;\n\n\tif (flags & (MSG_OOB))\n\t\treturn -EOPNOTSUPP;\n\n\t/* receive/dequeue next skb:\n\t * the function understands MSG_PEEK and, thus, does not dequeue skb */\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb) {\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\treturn 0;\n\t\treturn err;\n\t}\n\n\trlen   = skb->len;\t\t/* real length of skb */\n\tcopied = min_t(unsigned int, rlen, len);\n\tif (!rlen)\n\t\tsk->sk_shutdown = sk->sk_shutdown | RCV_SHUTDOWN;\n\n\tcskb = skb;\n\tif (skb_copy_datagram_iovec(cskb, 0, msg->msg_iov, copied)) {\n\t\tif (!(flags & MSG_PEEK))\n\t\t\tskb_queue_head(&sk->sk_receive_queue, skb);\n\t\treturn -EFAULT;\n\t}\n\n\t/* SOCK_SEQPACKET: set MSG_TRUNC if recv buf size is too small */\n\tif (sk->sk_type == SOCK_SEQPACKET) {\n\t\tif (copied < rlen)\n\t\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\t/* each iucv message contains a complete record */\n\t\tmsg->msg_flags |= MSG_EOR;\n\t}\n\n\t/* create control message to store iucv msg target class:\n\t * get the trgcls from the control buffer of the skb due to\n\t * fragmentation of original iucv message. */\n\terr = put_cmsg(msg, SOL_IUCV, SCM_IUCV_TRGCLS,\n\t\t\tCB_TRGCLS_LEN, CB_TRGCLS(skb));\n\tif (err) {\n\t\tif (!(flags & MSG_PEEK))\n\t\t\tskb_queue_head(&sk->sk_receive_queue, skb);\n\t\treturn err;\n\t}\n\n\t/* Mark read part of skb as used */\n\tif (!(flags & MSG_PEEK)) {\n\n\t\t/* SOCK_STREAM: re-queue skb if it contains unreceived data */\n\t\tif (sk->sk_type == SOCK_STREAM) {\n\t\t\tskb_pull(skb, copied);\n\t\t\tif (skb->len) {\n\t\t\t\tskb_queue_head(&sk->sk_receive_queue, skb);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\n\t\tkfree_skb(skb);\n\t\tif (iucv->transport == AF_IUCV_TRANS_HIPER) {\n\t\t\tatomic_inc(&iucv->msg_recv);\n\t\t\tif (atomic_read(&iucv->msg_recv) > iucv->msglimit) {\n\t\t\t\tWARN_ON(1);\n\t\t\t\tiucv_sock_close(sk);\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t}\n\n\t\t/* Queue backlog skbs */\n\t\tspin_lock_bh(&iucv->message_q.lock);\n\t\trskb = skb_dequeue(&iucv->backlog_skb_q);\n\t\twhile (rskb) {\n\t\t\tif (sock_queue_rcv_skb(sk, rskb)) {\n\t\t\t\tskb_queue_head(&iucv->backlog_skb_q,\n\t\t\t\t\t\trskb);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\trskb = skb_dequeue(&iucv->backlog_skb_q);\n\t\t\t}\n\t\t}\n\t\tif (skb_queue_empty(&iucv->backlog_skb_q)) {\n\t\t\tif (!list_empty(&iucv->message_q.list))\n\t\t\t\tiucv_process_message_q(sk);\n\t\t\tif (atomic_read(&iucv->msg_recv) >=\n\t\t\t\t\t\t\tiucv->msglimit / 2) {\n\t\t\t\terr = iucv_send_ctrl(sk, AF_IUCV_FLAG_WIN);\n\t\t\t\tif (err) {\n\t\t\t\t\tsk->sk_state = IUCV_DISCONN;\n\t\t\t\t\tsk->sk_state_change(sk);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tspin_unlock_bh(&iucv->message_q.lock);\n\t}\n\ndone:\n\t/* SOCK_SEQPACKET: return real length if MSG_TRUNC is set */\n\tif (sk->sk_type == SOCK_SEQPACKET && (flags & MSG_TRUNC))\n\t\tcopied = rlen;\n\n\treturn copied;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141770,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "int bt_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t\tstruct msghdr *msg, size_t len, int flags)\n{\n\tint noblock = flags & MSG_DONTWAIT;\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tsize_t copied;\n\tint err;\n\n\tBT_DBG(\"sock %p sk %p len %zu\", sock, sk, len);\n\n \tif (flags & (MSG_OOB))\n \t\treturn -EOPNOTSUPP;\n \n \tskb = skb_recv_datagram(sk, flags, noblock, &err);\n \tif (!skb) {\n \t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n \t\t\treturn 0;\n \t\treturn err;\n \t}\n \n\tmsg->msg_namelen = 0;\n \tcopied = skb->len;\n \tif (len < copied) {\n \t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\tskb_reset_transport_header(skb);\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err == 0)\n\t\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\tskb_free_datagram(sk, skb);\n\n\treturn err ? : copied;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141771,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "int bt_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t\tstruct msghdr *msg, size_t len, int flags)\n{\n\tint noblock = flags & MSG_DONTWAIT;\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tsize_t copied;\n\tint err;\n\n\tBT_DBG(\"sock %p sk %p len %zu\", sock, sk, len);\n\n \tif (flags & (MSG_OOB))\n \t\treturn -EOPNOTSUPP;\n \n\tmsg->msg_namelen = 0;\n\n \tskb = skb_recv_datagram(sk, flags, noblock, &err);\n \tif (!skb) {\n \t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n \t\t\treturn 0;\n \t\treturn err;\n \t}\n \n \tcopied = skb->len;\n \tif (len < copied) {\n \t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\tskb_reset_transport_header(skb);\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err == 0)\n\t\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\tskb_free_datagram(sk, skb);\n\n\treturn err ? : copied;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141772,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "openvpn_decrypt (struct buffer *buf, struct buffer work,\n\t\t const struct crypto_options *opt,\n\t\t const struct frame* frame)\n{\n  static const char error_prefix[] = \"Authenticate/Decrypt packet error\";\n  struct gc_arena gc;\n  gc_init (&gc);\n\n  if (buf->len > 0 && opt->key_ctx_bi)\n    {\n      struct key_ctx *ctx = &opt->key_ctx_bi->decrypt;\n      struct packet_id_net pin;\n      bool have_pin = false;\n\n      /* Verify the HMAC */\n      if (ctx->hmac)\n\t{\n\t  int hmac_len;\n\t  uint8_t local_hmac[MAX_HMAC_KEY_LENGTH]; /* HMAC of ciphertext computed locally */\n\n\t  hmac_ctx_reset(ctx->hmac);\n\n\t  /* Assume the length of the input HMAC */\n\t  hmac_len = hmac_ctx_size (ctx->hmac);\n\n\t  /* Authentication fails if insufficient data in packet for HMAC */\n\t  if (buf->len < hmac_len)\n\t    CRYPT_ERROR (\"missing authentication info\");\n\n\t  hmac_ctx_update (ctx->hmac, BPTR (buf) + hmac_len, BLEN (buf) - hmac_len);\n \t  hmac_ctx_final (ctx->hmac, local_hmac);\n \n \t  /* Compare locally computed HMAC with packet HMAC */\n\t  if (memcmp (local_hmac, BPTR (buf), hmac_len))\n \t    CRYPT_ERROR (\"packet HMAC authentication failed\");\n \n \t  ASSERT (buf_advance (buf, hmac_len));\n\t}\n\n      /* Decrypt packet ID + payload */\n\n      if (ctx->cipher)\n\t{\n\t  const unsigned int mode = cipher_ctx_mode (ctx->cipher);\n\t  const int iv_size = cipher_ctx_iv_length (ctx->cipher);\n\t  uint8_t iv_buf[OPENVPN_MAX_IV_LENGTH];\n\t  int outlen;\n\n\t  /* initialize work buffer with FRAME_HEADROOM bytes of prepend capacity */\n\t  ASSERT (buf_init (&work, FRAME_HEADROOM_ADJ (frame, FRAME_HEADROOM_MARKER_DECRYPT)));\n\n\t  /* use IV if user requested it */\n\t  CLEAR (iv_buf);\n\t  if (opt->flags & CO_USE_IV)\n\t    {\n\t      if (buf->len < iv_size)\n\t\tCRYPT_ERROR (\"missing IV info\");\n\t      memcpy (iv_buf, BPTR (buf), iv_size);\n\t      ASSERT (buf_advance (buf, iv_size));\n\t    }\n\n\t  /* show the IV's initial state */\n\t  if (opt->flags & CO_USE_IV)\n\t    dmsg (D_PACKET_CONTENT, \"DECRYPT IV: %s\", format_hex (iv_buf, iv_size, 0, &gc));\n\n\t  if (buf->len < 1)\n\t    CRYPT_ERROR (\"missing payload\");\n\n\t  /* ctx->cipher was already initialized with key & keylen */\n\t  if (!cipher_ctx_reset (ctx->cipher, iv_buf))\n\t    CRYPT_ERROR (\"cipher init failed\");\n\n\t  /* Buffer overflow check (should never happen) */\n\t  if (!buf_safe (&work, buf->len))\n\t    CRYPT_ERROR (\"buffer overflow\");\n\n\t  /* Decrypt packet ID, payload */\n\t  if (!cipher_ctx_update (ctx->cipher, BPTR (&work), &outlen, BPTR (buf), BLEN (buf)))\n\t    CRYPT_ERROR (\"cipher update failed\");\n\t  work.len += outlen;\n\n\t  /* Flush the decryption buffer */\n\t  if (!cipher_ctx_final (ctx->cipher, BPTR (&work) + outlen, &outlen))\n\t    CRYPT_ERROR (\"cipher final failed\");\n\t  work.len += outlen;\n\n\t  dmsg (D_PACKET_CONTENT, \"DECRYPT TO: %s\",\n\t       format_hex (BPTR (&work), BLEN (&work), 80, &gc));\n\n\t  /* Get packet ID from plaintext buffer or IV, depending on cipher mode */\n\t  {\n\t    if (mode == OPENVPN_MODE_CBC)\n\t      {\n\t\tif (opt->packet_id)\n\t\t  {\n\t\t    if (!packet_id_read (&pin, &work, BOOL_CAST (opt->flags & CO_PACKET_ID_LONG_FORM)))\n\t\t      CRYPT_ERROR (\"error reading CBC packet-id\");\n\t\t    have_pin = true;\n\t\t  }\n\t      }\n\t    else if (mode == OPENVPN_MODE_CFB || mode == OPENVPN_MODE_OFB)\n\t      {\n\t\tstruct buffer b;\n\n\t\tASSERT (opt->flags & CO_USE_IV);    /* IV and packet-ID required */\n\t\tASSERT (opt->packet_id); /*  for this mode. */\n\n\t\tbuf_set_read (&b, iv_buf, iv_size);\n\t\tif (!packet_id_read (&pin, &b, true))\n\t\t  CRYPT_ERROR (\"error reading CFB/OFB packet-id\");\n\t\thave_pin = true;\n\t      }\n\t    else /* We only support CBC, CFB, or OFB modes right now */\n\t      {\n\t\tASSERT (0);\n\t      }\n\t  }\n\t}\n      else\n\t{\n\t  work = *buf;\n\t  if (opt->packet_id)\n\t    {\n\t      if (!packet_id_read (&pin, &work, BOOL_CAST (opt->flags & CO_PACKET_ID_LONG_FORM)))\n\t\tCRYPT_ERROR (\"error reading packet-id\");\n\t      have_pin = !BOOL_CAST (opt->flags & CO_IGNORE_PACKET_ID);\n\t    }\n\t}\n      \n      if (have_pin)\n\t{\n\t  packet_id_reap_test (&opt->packet_id->rec);\n\t  if (packet_id_test (&opt->packet_id->rec, &pin))\n\t    {\n\t      packet_id_add (&opt->packet_id->rec, &pin);\n\t      if (opt->pid_persist && (opt->flags & CO_PACKET_ID_LONG_FORM))\n\t\tpacket_id_persist_save_obj (opt->pid_persist, opt->packet_id);\n\t    }\n\t  else\n\t    {\n\t      if (!(opt->flags & CO_MUTE_REPLAY_WARNINGS))\n\t      msg (D_REPLAY_ERRORS, \"%s: bad packet ID (may be a replay): %s -- see the man page entry for --no-replay and --replay-window for more info or silence this warning with --mute-replay-warnings\",\n\t\t   error_prefix, packet_id_net_print (&pin, true, &gc));\n\t      goto error_exit;\n\t    }\n\t}\n      *buf = work;\n    }\n\n  gc_free (&gc);\n  return true;\n\n error_exit:\n  crypto_clear_error();\n  buf->len = 0;\n  gc_free (&gc);\n  return false;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141781,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "openvpn_decrypt (struct buffer *buf, struct buffer work,\n\t\t const struct crypto_options *opt,\n\t\t const struct frame* frame)\n{\n  static const char error_prefix[] = \"Authenticate/Decrypt packet error\";\n  struct gc_arena gc;\n  gc_init (&gc);\n\n  if (buf->len > 0 && opt->key_ctx_bi)\n    {\n      struct key_ctx *ctx = &opt->key_ctx_bi->decrypt;\n      struct packet_id_net pin;\n      bool have_pin = false;\n\n      /* Verify the HMAC */\n      if (ctx->hmac)\n\t{\n\t  int hmac_len;\n\t  uint8_t local_hmac[MAX_HMAC_KEY_LENGTH]; /* HMAC of ciphertext computed locally */\n\n\t  hmac_ctx_reset(ctx->hmac);\n\n\t  /* Assume the length of the input HMAC */\n\t  hmac_len = hmac_ctx_size (ctx->hmac);\n\n\t  /* Authentication fails if insufficient data in packet for HMAC */\n\t  if (buf->len < hmac_len)\n\t    CRYPT_ERROR (\"missing authentication info\");\n\n\t  hmac_ctx_update (ctx->hmac, BPTR (buf) + hmac_len, BLEN (buf) - hmac_len);\n \t  hmac_ctx_final (ctx->hmac, local_hmac);\n \n \t  /* Compare locally computed HMAC with packet HMAC */\n\t  if (memcmp_constant_time (local_hmac, BPTR (buf), hmac_len))\n \t    CRYPT_ERROR (\"packet HMAC authentication failed\");\n \n \t  ASSERT (buf_advance (buf, hmac_len));\n\t}\n\n      /* Decrypt packet ID + payload */\n\n      if (ctx->cipher)\n\t{\n\t  const unsigned int mode = cipher_ctx_mode (ctx->cipher);\n\t  const int iv_size = cipher_ctx_iv_length (ctx->cipher);\n\t  uint8_t iv_buf[OPENVPN_MAX_IV_LENGTH];\n\t  int outlen;\n\n\t  /* initialize work buffer with FRAME_HEADROOM bytes of prepend capacity */\n\t  ASSERT (buf_init (&work, FRAME_HEADROOM_ADJ (frame, FRAME_HEADROOM_MARKER_DECRYPT)));\n\n\t  /* use IV if user requested it */\n\t  CLEAR (iv_buf);\n\t  if (opt->flags & CO_USE_IV)\n\t    {\n\t      if (buf->len < iv_size)\n\t\tCRYPT_ERROR (\"missing IV info\");\n\t      memcpy (iv_buf, BPTR (buf), iv_size);\n\t      ASSERT (buf_advance (buf, iv_size));\n\t    }\n\n\t  /* show the IV's initial state */\n\t  if (opt->flags & CO_USE_IV)\n\t    dmsg (D_PACKET_CONTENT, \"DECRYPT IV: %s\", format_hex (iv_buf, iv_size, 0, &gc));\n\n\t  if (buf->len < 1)\n\t    CRYPT_ERROR (\"missing payload\");\n\n\t  /* ctx->cipher was already initialized with key & keylen */\n\t  if (!cipher_ctx_reset (ctx->cipher, iv_buf))\n\t    CRYPT_ERROR (\"cipher init failed\");\n\n\t  /* Buffer overflow check (should never happen) */\n\t  if (!buf_safe (&work, buf->len))\n\t    CRYPT_ERROR (\"buffer overflow\");\n\n\t  /* Decrypt packet ID, payload */\n\t  if (!cipher_ctx_update (ctx->cipher, BPTR (&work), &outlen, BPTR (buf), BLEN (buf)))\n\t    CRYPT_ERROR (\"cipher update failed\");\n\t  work.len += outlen;\n\n\t  /* Flush the decryption buffer */\n\t  if (!cipher_ctx_final (ctx->cipher, BPTR (&work) + outlen, &outlen))\n\t    CRYPT_ERROR (\"cipher final failed\");\n\t  work.len += outlen;\n\n\t  dmsg (D_PACKET_CONTENT, \"DECRYPT TO: %s\",\n\t       format_hex (BPTR (&work), BLEN (&work), 80, &gc));\n\n\t  /* Get packet ID from plaintext buffer or IV, depending on cipher mode */\n\t  {\n\t    if (mode == OPENVPN_MODE_CBC)\n\t      {\n\t\tif (opt->packet_id)\n\t\t  {\n\t\t    if (!packet_id_read (&pin, &work, BOOL_CAST (opt->flags & CO_PACKET_ID_LONG_FORM)))\n\t\t      CRYPT_ERROR (\"error reading CBC packet-id\");\n\t\t    have_pin = true;\n\t\t  }\n\t      }\n\t    else if (mode == OPENVPN_MODE_CFB || mode == OPENVPN_MODE_OFB)\n\t      {\n\t\tstruct buffer b;\n\n\t\tASSERT (opt->flags & CO_USE_IV);    /* IV and packet-ID required */\n\t\tASSERT (opt->packet_id); /*  for this mode. */\n\n\t\tbuf_set_read (&b, iv_buf, iv_size);\n\t\tif (!packet_id_read (&pin, &b, true))\n\t\t  CRYPT_ERROR (\"error reading CFB/OFB packet-id\");\n\t\thave_pin = true;\n\t      }\n\t    else /* We only support CBC, CFB, or OFB modes right now */\n\t      {\n\t\tASSERT (0);\n\t      }\n\t  }\n\t}\n      else\n\t{\n\t  work = *buf;\n\t  if (opt->packet_id)\n\t    {\n\t      if (!packet_id_read (&pin, &work, BOOL_CAST (opt->flags & CO_PACKET_ID_LONG_FORM)))\n\t\tCRYPT_ERROR (\"error reading packet-id\");\n\t      have_pin = !BOOL_CAST (opt->flags & CO_IGNORE_PACKET_ID);\n\t    }\n\t}\n      \n      if (have_pin)\n\t{\n\t  packet_id_reap_test (&opt->packet_id->rec);\n\t  if (packet_id_test (&opt->packet_id->rec, &pin))\n\t    {\n\t      packet_id_add (&opt->packet_id->rec, &pin);\n\t      if (opt->pid_persist && (opt->flags & CO_PACKET_ID_LONG_FORM))\n\t\tpacket_id_persist_save_obj (opt->pid_persist, opt->packet_id);\n\t    }\n\t  else\n\t    {\n\t      if (!(opt->flags & CO_MUTE_REPLAY_WARNINGS))\n\t      msg (D_REPLAY_ERRORS, \"%s: bad packet ID (may be a replay): %s -- see the man page entry for --no-replay and --replay-window for more info or silence this warning with --mute-replay-warnings\",\n\t\t   error_prefix, packet_id_net_print (&pin, true, &gc));\n\t      goto error_exit;\n\t    }\n\t}\n      *buf = work;\n    }\n\n  gc_free (&gc);\n  return true;\n\n error_exit:\n  crypto_clear_error();\n  buf->len = 0;\n  gc_free (&gc);\n  return false;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141782,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int do_video_set_spu_palette(unsigned int fd, unsigned int cmd,\n\t\tstruct compat_video_spu_palette __user *up)\n{\n\tstruct video_spu_palette __user *up_native;\n\tcompat_uptr_t palp;\n\tint length, err;\n \n \terr  = get_user(palp, &up->palette);\n \terr |= get_user(length, &up->length);\n \n \tup_native = compat_alloc_user_space(sizeof(struct video_spu_palette));\n \terr  = put_user(compat_ptr(palp), &up_native->palette);\n\terr |= put_user(length, &up_native->length);\n\tif (err)\n\t\treturn -EFAULT;\n\n\terr = sys_ioctl(fd, cmd, (unsigned long) up_native);\n\n\treturn err;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141787,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int do_video_set_spu_palette(unsigned int fd, unsigned int cmd,\n\t\tstruct compat_video_spu_palette __user *up)\n{\n\tstruct video_spu_palette __user *up_native;\n\tcompat_uptr_t palp;\n\tint length, err;\n \n \terr  = get_user(palp, &up->palette);\n \terr |= get_user(length, &up->length);\n\tif (err)\n\t\treturn -EFAULT;\n \n \tup_native = compat_alloc_user_space(sizeof(struct video_spu_palette));\n \terr  = put_user(compat_ptr(palp), &up_native->palette);\n\terr |= put_user(length, &up_native->length);\n\tif (err)\n\t\treturn -EFAULT;\n\n\terr = sys_ioctl(fd, cmd, (unsigned long) up_native);\n\n\treturn err;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141788,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int hidp_setup_hid(struct hidp_session *session,\n\t\t\t\tstruct hidp_connadd_req *req)\n{\n\tstruct hid_device *hid;\n\tint err;\n\n\tsession->rd_data = kzalloc(req->rd_size, GFP_KERNEL);\n\tif (!session->rd_data)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(session->rd_data, req->rd_data, req->rd_size)) {\n\t\terr = -EFAULT;\n\t\tgoto fault;\n\t}\n\tsession->rd_size = req->rd_size;\n\n\thid = hid_allocate_device();\n\tif (IS_ERR(hid)) {\n\t\terr = PTR_ERR(hid);\n\t\tgoto fault;\n\t}\n\n\tsession->hid = hid;\n\n\thid->driver_data = session;\n\n\thid->bus     = BUS_BLUETOOTH;\n\thid->vendor  = req->vendor;\n\thid->product = req->product;\n \thid->version = req->version;\n \thid->country = req->country;\n \n\tstrncpy(hid->name, req->name, 128);\n \n \tsnprintf(hid->phys, sizeof(hid->phys), \"%pMR\",\n \t\t &bt_sk(session->ctrl_sock->sk)->src);\n\n\tsnprintf(hid->uniq, sizeof(hid->uniq), \"%pMR\",\n\t\t &bt_sk(session->ctrl_sock->sk)->dst);\n\n\thid->dev.parent = &session->conn->dev;\n\thid->ll_driver = &hidp_hid_driver;\n\n\thid->hid_get_raw_report = hidp_get_raw_report;\n\thid->hid_output_raw_report = hidp_output_raw_report;\n\n\t/* True if device is blacklisted in drivers/hid/hid-core.c */\n\tif (hid_ignore(hid)) {\n\t\thid_destroy_device(session->hid);\n\t\tsession->hid = NULL;\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n\nfault:\n\tkfree(session->rd_data);\n\tsession->rd_data = NULL;\n\n\treturn err;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141805,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int hidp_setup_hid(struct hidp_session *session,\n\t\t\t\tstruct hidp_connadd_req *req)\n{\n\tstruct hid_device *hid;\n\tint err;\n\n\tsession->rd_data = kzalloc(req->rd_size, GFP_KERNEL);\n\tif (!session->rd_data)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(session->rd_data, req->rd_data, req->rd_size)) {\n\t\terr = -EFAULT;\n\t\tgoto fault;\n\t}\n\tsession->rd_size = req->rd_size;\n\n\thid = hid_allocate_device();\n\tif (IS_ERR(hid)) {\n\t\terr = PTR_ERR(hid);\n\t\tgoto fault;\n\t}\n\n\tsession->hid = hid;\n\n\thid->driver_data = session;\n\n\thid->bus     = BUS_BLUETOOTH;\n\thid->vendor  = req->vendor;\n\thid->product = req->product;\n \thid->version = req->version;\n \thid->country = req->country;\n \n\tstrncpy(hid->name, req->name, sizeof(req->name) - 1);\n \n \tsnprintf(hid->phys, sizeof(hid->phys), \"%pMR\",\n \t\t &bt_sk(session->ctrl_sock->sk)->src);\n\n\tsnprintf(hid->uniq, sizeof(hid->uniq), \"%pMR\",\n\t\t &bt_sk(session->ctrl_sock->sk)->dst);\n\n\thid->dev.parent = &session->conn->dev;\n\thid->ll_driver = &hidp_hid_driver;\n\n\thid->hid_get_raw_report = hidp_get_raw_report;\n\thid->hid_output_raw_report = hidp_output_raw_report;\n\n\t/* True if device is blacklisted in drivers/hid/hid-core.c */\n\tif (hid_ignore(hid)) {\n\t\thid_destroy_device(session->hid);\n\t\tsession->hid = NULL;\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n\nfault:\n\tkfree(session->rd_data);\n\tsession->rd_data = NULL;\n\n\treturn err;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141806,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "isofs_export_encode_fh(struct inode *inode,\n\t\t       __u32 *fh32,\n\t\t       int *max_len,\n\t\t       struct inode *parent)\n{\n\tstruct iso_inode_info * ei = ISOFS_I(inode);\n\tint len = *max_len;\n\tint type = 1;\n\t__u16 *fh16 = (__u16*)fh32;\n\n\t/*\n\t * WARNING: max_len is 5 for NFSv2.  Because of this\n\t * limitation, we use the lower 16 bits of fh32[1] to hold the\n\t * offset of the inode and the upper 16 bits of fh32[1] to\n\t * hold the offset of the parent.\n\t */\n\tif (parent && (len < 5)) {\n\t\t*max_len = 5;\n\t\treturn 255;\n\t} else if (len < 3) {\n\t\t*max_len = 3;\n\t\treturn 255;\n\t}\n\n \tlen = 3;\n \tfh32[0] = ei->i_iget5_block;\n  \tfh16[2] = (__u16)ei->i_iget5_offset;  /* fh16 [sic] */\n \tfh32[2] = inode->i_generation;\n \tif (parent) {\n \t\tstruct iso_inode_info *eparent;\n\t\teparent = ISOFS_I(parent);\n\t\tfh32[3] = eparent->i_iget5_block;\n\t\tfh16[3] = (__u16)eparent->i_iget5_offset;  /* fh16 [sic] */\n\t\tfh32[4] = parent->i_generation;\n\t\tlen = 5;\n\t\ttype = 2;\n\t}\n\t*max_len = len;\n\treturn type;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141813,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "isofs_export_encode_fh(struct inode *inode,\n\t\t       __u32 *fh32,\n\t\t       int *max_len,\n\t\t       struct inode *parent)\n{\n\tstruct iso_inode_info * ei = ISOFS_I(inode);\n\tint len = *max_len;\n\tint type = 1;\n\t__u16 *fh16 = (__u16*)fh32;\n\n\t/*\n\t * WARNING: max_len is 5 for NFSv2.  Because of this\n\t * limitation, we use the lower 16 bits of fh32[1] to hold the\n\t * offset of the inode and the upper 16 bits of fh32[1] to\n\t * hold the offset of the parent.\n\t */\n\tif (parent && (len < 5)) {\n\t\t*max_len = 5;\n\t\treturn 255;\n\t} else if (len < 3) {\n\t\t*max_len = 3;\n\t\treturn 255;\n\t}\n\n \tlen = 3;\n \tfh32[0] = ei->i_iget5_block;\n  \tfh16[2] = (__u16)ei->i_iget5_offset;  /* fh16 [sic] */\n\tfh16[3] = 0;  /* avoid leaking uninitialized data */\n \tfh32[2] = inode->i_generation;\n \tif (parent) {\n \t\tstruct iso_inode_info *eparent;\n\t\teparent = ISOFS_I(parent);\n\t\tfh32[3] = eparent->i_iget5_block;\n\t\tfh16[3] = (__u16)eparent->i_iget5_offset;  /* fh16 [sic] */\n\t\tfh32[4] = parent->i_generation;\n\t\tlen = 5;\n\t\ttype = 2;\n\t}\n\t*max_len = len;\n\treturn type;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141814,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int udf_encode_fh(struct inode *inode, __u32 *fh, int *lenp,\n\t\t\t struct inode *parent)\n{\n\tint len = *lenp;\n\tstruct kernel_lb_addr location = UDF_I(inode)->i_location;\n\tstruct fid *fid = (struct fid *)fh;\n\tint type = FILEID_UDF_WITHOUT_PARENT;\n\n\tif (parent && (len < 5)) {\n\t\t*lenp = 5;\n\t\treturn 255;\n\t} else if (len < 3) {\n\t\t*lenp = 3;\n\t\treturn 255;\n\t}\n\n \t*lenp = 3;\n \tfid->udf.block = location.logicalBlockNum;\n \tfid->udf.partref = location.partitionReferenceNum;\n \tfid->udf.generation = inode->i_generation;\n \n \tif (parent) {\n\t\tlocation = UDF_I(parent)->i_location;\n\t\tfid->udf.parent_block = location.logicalBlockNum;\n\t\tfid->udf.parent_partref = location.partitionReferenceNum;\n\t\tfid->udf.parent_generation = inode->i_generation;\n\t\t*lenp = 5;\n\t\ttype = FILEID_UDF_WITH_PARENT;\n\t}\n\n\treturn type;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141815,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int udf_encode_fh(struct inode *inode, __u32 *fh, int *lenp,\n\t\t\t struct inode *parent)\n{\n\tint len = *lenp;\n\tstruct kernel_lb_addr location = UDF_I(inode)->i_location;\n\tstruct fid *fid = (struct fid *)fh;\n\tint type = FILEID_UDF_WITHOUT_PARENT;\n\n\tif (parent && (len < 5)) {\n\t\t*lenp = 5;\n\t\treturn 255;\n\t} else if (len < 3) {\n\t\t*lenp = 3;\n\t\treturn 255;\n\t}\n\n \t*lenp = 3;\n \tfid->udf.block = location.logicalBlockNum;\n \tfid->udf.partref = location.partitionReferenceNum;\n\tfid->udf.parent_partref = 0;\n \tfid->udf.generation = inode->i_generation;\n \n \tif (parent) {\n\t\tlocation = UDF_I(parent)->i_location;\n\t\tfid->udf.parent_block = location.logicalBlockNum;\n\t\tfid->udf.parent_partref = location.partitionReferenceNum;\n\t\tfid->udf.parent_generation = inode->i_generation;\n\t\t*lenp = 5;\n\t\ttype = FILEID_UDF_WITH_PARENT;\n\t}\n\n\treturn type;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141816,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static long __tun_chr_ioctl(struct file *file, unsigned int cmd,\n\t\t\t    unsigned long arg, int ifreq_len)\n{\n\tstruct tun_file *tfile = file->private_data;\n\tstruct tun_struct *tun;\n\tvoid __user* argp = (void __user*)arg;\n\tstruct sock_fprog fprog;\n\tstruct ifreq ifr;\n\tint sndbuf;\n \tint vnet_hdr_sz;\n \tint ret;\n \n\tif (cmd == TUNSETIFF || _IOC_TYPE(cmd) == 0x89)\n \t\tif (copy_from_user(&ifr, argp, ifreq_len))\n \t\t\treturn -EFAULT;\n \n \tif (cmd == TUNGETFEATURES) {\n \t\t/* Currently this just means: \"what IFF flags are valid?\".\n\t\t * This is needed because we never checked for invalid flags on\n\t\t * TUNSETIFF. */\n\t\treturn put_user(IFF_TUN | IFF_TAP | IFF_NO_PI | IFF_ONE_QUEUE |\n\t\t\t\tIFF_VNET_HDR,\n\t\t\t\t(unsigned int __user*)argp);\n\t}\n\n\trtnl_lock();\n\n\ttun = __tun_get(tfile);\n\tif (cmd == TUNSETIFF && !tun) {\n\t\tifr.ifr_name[IFNAMSIZ-1] = '\\0';\n\n\t\tret = tun_set_iff(tfile->net, file, &ifr);\n\n\t\tif (ret)\n\t\t\tgoto unlock;\n\n\t\tif (copy_to_user(argp, &ifr, ifreq_len))\n\t\t\tret = -EFAULT;\n\t\tgoto unlock;\n\t}\n\n\tret = -EBADFD;\n\tif (!tun)\n\t\tgoto unlock;\n\n\ttun_debug(KERN_INFO, tun, \"tun_chr_ioctl cmd %d\\n\", cmd);\n\n\tret = 0;\n\tswitch (cmd) {\n\tcase TUNGETIFF:\n\t\tret = tun_get_iff(current->nsproxy->net_ns, tun, &ifr);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (copy_to_user(argp, &ifr, ifreq_len))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\n\tcase TUNSETNOCSUM:\n\t\t/* Disable/Enable checksum */\n\n\t\t/* [unimplemented] */\n\t\ttun_debug(KERN_INFO, tun, \"ignored: set checksum %s\\n\",\n\t\t\t  arg ? \"disabled\" : \"enabled\");\n\t\tbreak;\n\n\tcase TUNSETPERSIST:\n\t\t/* Disable/Enable persist mode */\n\t\tif (arg)\n\t\t\ttun->flags |= TUN_PERSIST;\n\t\telse\n\t\t\ttun->flags &= ~TUN_PERSIST;\n\n\t\ttun_debug(KERN_INFO, tun, \"persist %s\\n\",\n\t\t\t  arg ? \"enabled\" : \"disabled\");\n\t\tbreak;\n\n\tcase TUNSETOWNER:\n\t\t/* Set owner of the device */\n\t\ttun->owner = (uid_t) arg;\n\n\t\ttun_debug(KERN_INFO, tun, \"owner set to %d\\n\", tun->owner);\n\t\tbreak;\n\n\tcase TUNSETGROUP:\n\t\t/* Set group of the device */\n\t\ttun->group= (gid_t) arg;\n\n\t\ttun_debug(KERN_INFO, tun, \"group set to %d\\n\", tun->group);\n\t\tbreak;\n\n\tcase TUNSETLINK:\n\t\t/* Only allow setting the type when the interface is down */\n\t\tif (tun->dev->flags & IFF_UP) {\n\t\t\ttun_debug(KERN_INFO, tun,\n\t\t\t\t  \"Linktype set failed because interface is up\\n\");\n\t\t\tret = -EBUSY;\n\t\t} else {\n\t\t\ttun->dev->type = (int) arg;\n\t\t\ttun_debug(KERN_INFO, tun, \"linktype set to %d\\n\",\n\t\t\t\t  tun->dev->type);\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\n#ifdef TUN_DEBUG\n\tcase TUNSETDEBUG:\n\t\ttun->debug = arg;\n\t\tbreak;\n#endif\n\tcase TUNSETOFFLOAD:\n\t\tret = set_offload(tun, arg);\n\t\tbreak;\n\n\tcase TUNSETTXFILTER:\n\t\t/* Can be set only for TAPs */\n\t\tret = -EINVAL;\n\t\tif ((tun->flags & TUN_TYPE_MASK) != TUN_TAP_DEV)\n\t\t\tbreak;\n\t\tret = update_filter(&tun->txflt, (void __user *)arg);\n\t\tbreak;\n\n\tcase SIOCGIFHWADDR:\n\t\t/* Get hw address */\n\t\tmemcpy(ifr.ifr_hwaddr.sa_data, tun->dev->dev_addr, ETH_ALEN);\n\t\tifr.ifr_hwaddr.sa_family = tun->dev->type;\n\t\tif (copy_to_user(argp, &ifr, ifreq_len))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\n\tcase SIOCSIFHWADDR:\n\t\t/* Set hw address */\n\t\ttun_debug(KERN_DEBUG, tun, \"set hw address: %pM\\n\",\n\t\t\t  ifr.ifr_hwaddr.sa_data);\n\n\t\tret = dev_set_mac_address(tun->dev, &ifr.ifr_hwaddr);\n\t\tbreak;\n\n\tcase TUNGETSNDBUF:\n\t\tsndbuf = tun->socket.sk->sk_sndbuf;\n\t\tif (copy_to_user(argp, &sndbuf, sizeof(sndbuf)))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\n\tcase TUNSETSNDBUF:\n\t\tif (copy_from_user(&sndbuf, argp, sizeof(sndbuf))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\ttun->socket.sk->sk_sndbuf = sndbuf;\n\t\tbreak;\n\n\tcase TUNGETVNETHDRSZ:\n\t\tvnet_hdr_sz = tun->vnet_hdr_sz;\n\t\tif (copy_to_user(argp, &vnet_hdr_sz, sizeof(vnet_hdr_sz)))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\n\tcase TUNSETVNETHDRSZ:\n\t\tif (copy_from_user(&vnet_hdr_sz, argp, sizeof(vnet_hdr_sz))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (vnet_hdr_sz < (int)sizeof(struct virtio_net_hdr)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\ttun->vnet_hdr_sz = vnet_hdr_sz;\n\t\tbreak;\n\n\tcase TUNATTACHFILTER:\n\t\t/* Can be set only for TAPs */\n\t\tret = -EINVAL;\n\t\tif ((tun->flags & TUN_TYPE_MASK) != TUN_TAP_DEV)\n\t\t\tbreak;\n\t\tret = -EFAULT;\n\t\tif (copy_from_user(&fprog, argp, sizeof(fprog)))\n\t\t\tbreak;\n\n\t\tret = sk_attach_filter(&fprog, tun->socket.sk);\n\t\tbreak;\n\n\tcase TUNDETACHFILTER:\n\t\t/* Can be set only for TAPs */\n\t\tret = -EINVAL;\n\t\tif ((tun->flags & TUN_TYPE_MASK) != TUN_TAP_DEV)\n\t\t\tbreak;\n\t\tret = sk_detach_filter(tun->socket.sk);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\nunlock:\n\trtnl_unlock();\n\tif (tun)\n\t\ttun_put(tun);\n\treturn ret;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141817,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static long __tun_chr_ioctl(struct file *file, unsigned int cmd,\n\t\t\t    unsigned long arg, int ifreq_len)\n{\n\tstruct tun_file *tfile = file->private_data;\n\tstruct tun_struct *tun;\n\tvoid __user* argp = (void __user*)arg;\n\tstruct sock_fprog fprog;\n\tstruct ifreq ifr;\n\tint sndbuf;\n \tint vnet_hdr_sz;\n \tint ret;\n \n\tif (cmd == TUNSETIFF || _IOC_TYPE(cmd) == 0x89) {\n \t\tif (copy_from_user(&ifr, argp, ifreq_len))\n \t\t\treturn -EFAULT;\n\t} else\n\t\tmemset(&ifr, 0, sizeof(ifr));\n \n \tif (cmd == TUNGETFEATURES) {\n \t\t/* Currently this just means: \"what IFF flags are valid?\".\n\t\t * This is needed because we never checked for invalid flags on\n\t\t * TUNSETIFF. */\n\t\treturn put_user(IFF_TUN | IFF_TAP | IFF_NO_PI | IFF_ONE_QUEUE |\n\t\t\t\tIFF_VNET_HDR,\n\t\t\t\t(unsigned int __user*)argp);\n\t}\n\n\trtnl_lock();\n\n\ttun = __tun_get(tfile);\n\tif (cmd == TUNSETIFF && !tun) {\n\t\tifr.ifr_name[IFNAMSIZ-1] = '\\0';\n\n\t\tret = tun_set_iff(tfile->net, file, &ifr);\n\n\t\tif (ret)\n\t\t\tgoto unlock;\n\n\t\tif (copy_to_user(argp, &ifr, ifreq_len))\n\t\t\tret = -EFAULT;\n\t\tgoto unlock;\n\t}\n\n\tret = -EBADFD;\n\tif (!tun)\n\t\tgoto unlock;\n\n\ttun_debug(KERN_INFO, tun, \"tun_chr_ioctl cmd %d\\n\", cmd);\n\n\tret = 0;\n\tswitch (cmd) {\n\tcase TUNGETIFF:\n\t\tret = tun_get_iff(current->nsproxy->net_ns, tun, &ifr);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (copy_to_user(argp, &ifr, ifreq_len))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\n\tcase TUNSETNOCSUM:\n\t\t/* Disable/Enable checksum */\n\n\t\t/* [unimplemented] */\n\t\ttun_debug(KERN_INFO, tun, \"ignored: set checksum %s\\n\",\n\t\t\t  arg ? \"disabled\" : \"enabled\");\n\t\tbreak;\n\n\tcase TUNSETPERSIST:\n\t\t/* Disable/Enable persist mode */\n\t\tif (arg)\n\t\t\ttun->flags |= TUN_PERSIST;\n\t\telse\n\t\t\ttun->flags &= ~TUN_PERSIST;\n\n\t\ttun_debug(KERN_INFO, tun, \"persist %s\\n\",\n\t\t\t  arg ? \"enabled\" : \"disabled\");\n\t\tbreak;\n\n\tcase TUNSETOWNER:\n\t\t/* Set owner of the device */\n\t\ttun->owner = (uid_t) arg;\n\n\t\ttun_debug(KERN_INFO, tun, \"owner set to %d\\n\", tun->owner);\n\t\tbreak;\n\n\tcase TUNSETGROUP:\n\t\t/* Set group of the device */\n\t\ttun->group= (gid_t) arg;\n\n\t\ttun_debug(KERN_INFO, tun, \"group set to %d\\n\", tun->group);\n\t\tbreak;\n\n\tcase TUNSETLINK:\n\t\t/* Only allow setting the type when the interface is down */\n\t\tif (tun->dev->flags & IFF_UP) {\n\t\t\ttun_debug(KERN_INFO, tun,\n\t\t\t\t  \"Linktype set failed because interface is up\\n\");\n\t\t\tret = -EBUSY;\n\t\t} else {\n\t\t\ttun->dev->type = (int) arg;\n\t\t\ttun_debug(KERN_INFO, tun, \"linktype set to %d\\n\",\n\t\t\t\t  tun->dev->type);\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\n#ifdef TUN_DEBUG\n\tcase TUNSETDEBUG:\n\t\ttun->debug = arg;\n\t\tbreak;\n#endif\n\tcase TUNSETOFFLOAD:\n\t\tret = set_offload(tun, arg);\n\t\tbreak;\n\n\tcase TUNSETTXFILTER:\n\t\t/* Can be set only for TAPs */\n\t\tret = -EINVAL;\n\t\tif ((tun->flags & TUN_TYPE_MASK) != TUN_TAP_DEV)\n\t\t\tbreak;\n\t\tret = update_filter(&tun->txflt, (void __user *)arg);\n\t\tbreak;\n\n\tcase SIOCGIFHWADDR:\n\t\t/* Get hw address */\n\t\tmemcpy(ifr.ifr_hwaddr.sa_data, tun->dev->dev_addr, ETH_ALEN);\n\t\tifr.ifr_hwaddr.sa_family = tun->dev->type;\n\t\tif (copy_to_user(argp, &ifr, ifreq_len))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\n\tcase SIOCSIFHWADDR:\n\t\t/* Set hw address */\n\t\ttun_debug(KERN_DEBUG, tun, \"set hw address: %pM\\n\",\n\t\t\t  ifr.ifr_hwaddr.sa_data);\n\n\t\tret = dev_set_mac_address(tun->dev, &ifr.ifr_hwaddr);\n\t\tbreak;\n\n\tcase TUNGETSNDBUF:\n\t\tsndbuf = tun->socket.sk->sk_sndbuf;\n\t\tif (copy_to_user(argp, &sndbuf, sizeof(sndbuf)))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\n\tcase TUNSETSNDBUF:\n\t\tif (copy_from_user(&sndbuf, argp, sizeof(sndbuf))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\ttun->socket.sk->sk_sndbuf = sndbuf;\n\t\tbreak;\n\n\tcase TUNGETVNETHDRSZ:\n\t\tvnet_hdr_sz = tun->vnet_hdr_sz;\n\t\tif (copy_to_user(argp, &vnet_hdr_sz, sizeof(vnet_hdr_sz)))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\n\tcase TUNSETVNETHDRSZ:\n\t\tif (copy_from_user(&vnet_hdr_sz, argp, sizeof(vnet_hdr_sz))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (vnet_hdr_sz < (int)sizeof(struct virtio_net_hdr)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\ttun->vnet_hdr_sz = vnet_hdr_sz;\n\t\tbreak;\n\n\tcase TUNATTACHFILTER:\n\t\t/* Can be set only for TAPs */\n\t\tret = -EINVAL;\n\t\tif ((tun->flags & TUN_TYPE_MASK) != TUN_TAP_DEV)\n\t\t\tbreak;\n\t\tret = -EFAULT;\n\t\tif (copy_from_user(&fprog, argp, sizeof(fprog)))\n\t\t\tbreak;\n\n\t\tret = sk_attach_filter(&fprog, tun->socket.sk);\n\t\tbreak;\n\n\tcase TUNDETACHFILTER:\n\t\t/* Can be set only for TAPs */\n\t\tret = -EINVAL;\n\t\tif ((tun->flags & TUN_TYPE_MASK) != TUN_TAP_DEV)\n\t\t\tbreak;\n\t\tret = sk_detach_filter(tun->socket.sk);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\nunlock:\n\trtnl_unlock();\n\tif (tun)\n\t\ttun_put(tun);\n\treturn ret;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141818,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int ccid3_hc_tx_getsockopt(struct sock *sk, const int optname, int len,\n\t\t\t\t  u32 __user *optval, int __user *optlen)\n{\n\tconst struct ccid3_hc_tx_sock *hc = ccid3_hc_tx_sk(sk);\n\tstruct tfrc_tx_info tfrc;\n\tconst void *val;\n\n\tswitch (optname) {\n \tcase DCCP_SOCKOPT_CCID_TX_INFO:\n \t\tif (len < sizeof(tfrc))\n \t\t\treturn -EINVAL;\n \t\ttfrc.tfrctx_x\t   = hc->tx_x;\n \t\ttfrc.tfrctx_x_recv = hc->tx_x_recv;\n \t\ttfrc.tfrctx_x_calc = hc->tx_x_calc;\n\t\ttfrc.tfrctx_rtt\t   = hc->tx_rtt;\n\t\ttfrc.tfrctx_p\t   = hc->tx_p;\n\t\ttfrc.tfrctx_rto\t   = hc->tx_t_rto;\n\t\ttfrc.tfrctx_ipi\t   = hc->tx_t_ipi;\n\t\tlen = sizeof(tfrc);\n\t\tval = &tfrc;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\n\tif (put_user(len, optlen) || copy_to_user(optval, val, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141819,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int ccid3_hc_tx_getsockopt(struct sock *sk, const int optname, int len,\n\t\t\t\t  u32 __user *optval, int __user *optlen)\n{\n\tconst struct ccid3_hc_tx_sock *hc = ccid3_hc_tx_sk(sk);\n\tstruct tfrc_tx_info tfrc;\n\tconst void *val;\n\n\tswitch (optname) {\n \tcase DCCP_SOCKOPT_CCID_TX_INFO:\n \t\tif (len < sizeof(tfrc))\n \t\t\treturn -EINVAL;\n\t\tmemset(&tfrc, 0, sizeof(tfrc));\n \t\ttfrc.tfrctx_x\t   = hc->tx_x;\n \t\ttfrc.tfrctx_x_recv = hc->tx_x_recv;\n \t\ttfrc.tfrctx_x_calc = hc->tx_x_calc;\n\t\ttfrc.tfrctx_rtt\t   = hc->tx_rtt;\n\t\ttfrc.tfrctx_p\t   = hc->tx_p;\n\t\ttfrc.tfrctx_rto\t   = hc->tx_t_rto;\n\t\ttfrc.tfrctx_ipi\t   = hc->tx_t_ipi;\n\t\tlen = sizeof(tfrc);\n\t\tval = &tfrc;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\n\tif (put_user(len, optlen) || copy_to_user(optval, val, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141820,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "do_ip_vs_get_ctl(struct sock *sk, int cmd, void __user *user, int *len)\n{\n\tunsigned char arg[128];\n\tint ret = 0;\n\tunsigned int copylen;\n\tstruct net *net = sock_net(sk);\n\tstruct netns_ipvs *ipvs = net_ipvs(net);\n\n\tBUG_ON(!net);\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_GET_MAX)\n\t\treturn -EINVAL;\n\n\tif (*len < get_arglen[GET_CMDID(cmd)]) {\n\t\tpr_err(\"get_ctl: len %u < %u\\n\",\n\t\t       *len, get_arglen[GET_CMDID(cmd)]);\n\t\treturn -EINVAL;\n\t}\n\n\tcopylen = get_arglen[GET_CMDID(cmd)];\n\tif (copylen > 128)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(arg, user, copylen) != 0)\n\t\treturn -EFAULT;\n\t/*\n\t * Handle daemons first since it has its own locking\n\t */\n\tif (cmd == IP_VS_SO_GET_DAEMON) {\n\t\tstruct ip_vs_daemon_user d[2];\n\n\t\tmemset(&d, 0, sizeof(d));\n\t\tif (mutex_lock_interruptible(&ipvs->sync_mutex))\n\t\t\treturn -ERESTARTSYS;\n\n\t\tif (ipvs->sync_state & IP_VS_STATE_MASTER) {\n\t\t\td[0].state = IP_VS_STATE_MASTER;\n\t\t\tstrlcpy(d[0].mcast_ifn, ipvs->master_mcast_ifn,\n\t\t\t\tsizeof(d[0].mcast_ifn));\n\t\t\td[0].syncid = ipvs->master_syncid;\n\t\t}\n\t\tif (ipvs->sync_state & IP_VS_STATE_BACKUP) {\n\t\t\td[1].state = IP_VS_STATE_BACKUP;\n\t\t\tstrlcpy(d[1].mcast_ifn, ipvs->backup_mcast_ifn,\n\t\t\t\tsizeof(d[1].mcast_ifn));\n\t\t\td[1].syncid = ipvs->backup_syncid;\n\t\t}\n\t\tif (copy_to_user(user, &d, sizeof(d)) != 0)\n\t\t\tret = -EFAULT;\n\t\tmutex_unlock(&ipvs->sync_mutex);\n\t\treturn ret;\n\t}\n\n\tif (mutex_lock_interruptible(&__ip_vs_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tswitch (cmd) {\n\tcase IP_VS_SO_GET_VERSION:\n\t{\n\t\tchar buf[64];\n\n\t\tsprintf(buf, \"IP Virtual Server version %d.%d.%d (size=%d)\",\n\t\t\tNVERSION(IP_VS_VERSION_CODE), ip_vs_conn_tab_size);\n\t\tif (copy_to_user(user, buf, strlen(buf)+1) != 0) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\t*len = strlen(buf)+1;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_INFO:\n\t{\n\t\tstruct ip_vs_getinfo info;\n\t\tinfo.version = IP_VS_VERSION_CODE;\n\t\tinfo.size = ip_vs_conn_tab_size;\n\t\tinfo.num_services = ipvs->num_services;\n\t\tif (copy_to_user(user, &info, sizeof(info)) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_SERVICES:\n\t{\n\t\tstruct ip_vs_get_services *get;\n\t\tint size;\n\n\t\tget = (struct ip_vs_get_services *)arg;\n\t\tsize = sizeof(*get) +\n\t\t\tsizeof(struct ip_vs_service_entry) * get->num_services;\n\t\tif (*len != size) {\n\t\t\tpr_err(\"length: %u != %u\\n\", *len, size);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tret = __ip_vs_get_service_entries(net, get, user);\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_SERVICE:\n\t{\n\t\tstruct ip_vs_service_entry *entry;\n\t\tstruct ip_vs_service *svc;\n\t\tunion nf_inet_addr addr;\n\n\t\tentry = (struct ip_vs_service_entry *)arg;\n\t\taddr.ip = entry->addr;\n\t\tif (entry->fwmark)\n\t\t\tsvc = __ip_vs_svc_fwm_find(net, AF_INET, entry->fwmark);\n\t\telse\n\t\t\tsvc = __ip_vs_service_find(net, AF_INET,\n\t\t\t\t\t\t   entry->protocol, &addr,\n\t\t\t\t\t\t   entry->port);\n\t\tif (svc) {\n\t\t\tip_vs_copy_service(entry, svc);\n\t\t\tif (copy_to_user(user, entry, sizeof(*entry)) != 0)\n\t\t\t\tret = -EFAULT;\n\t\t} else\n\t\t\tret = -ESRCH;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_DESTS:\n\t{\n\t\tstruct ip_vs_get_dests *get;\n\t\tint size;\n\n\t\tget = (struct ip_vs_get_dests *)arg;\n\t\tsize = sizeof(*get) +\n\t\t\tsizeof(struct ip_vs_dest_entry) * get->num_dests;\n\t\tif (*len != size) {\n\t\t\tpr_err(\"length: %u != %u\\n\", *len, size);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tret = __ip_vs_get_dest_entries(net, get, user);\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_TIMEOUT:\n \t{\n \t\tstruct ip_vs_timeout_user t;\n \n \t\t__ip_vs_get_timeouts(net, &t);\n \t\tif (copy_to_user(user, &t, sizeof(t)) != 0)\n \t\t\tret = -EFAULT;\n\t}\n\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\nout:\n\tmutex_unlock(&__ip_vs_mutex);\n\treturn ret;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141821,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "do_ip_vs_get_ctl(struct sock *sk, int cmd, void __user *user, int *len)\n{\n\tunsigned char arg[128];\n\tint ret = 0;\n\tunsigned int copylen;\n\tstruct net *net = sock_net(sk);\n\tstruct netns_ipvs *ipvs = net_ipvs(net);\n\n\tBUG_ON(!net);\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_GET_MAX)\n\t\treturn -EINVAL;\n\n\tif (*len < get_arglen[GET_CMDID(cmd)]) {\n\t\tpr_err(\"get_ctl: len %u < %u\\n\",\n\t\t       *len, get_arglen[GET_CMDID(cmd)]);\n\t\treturn -EINVAL;\n\t}\n\n\tcopylen = get_arglen[GET_CMDID(cmd)];\n\tif (copylen > 128)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(arg, user, copylen) != 0)\n\t\treturn -EFAULT;\n\t/*\n\t * Handle daemons first since it has its own locking\n\t */\n\tif (cmd == IP_VS_SO_GET_DAEMON) {\n\t\tstruct ip_vs_daemon_user d[2];\n\n\t\tmemset(&d, 0, sizeof(d));\n\t\tif (mutex_lock_interruptible(&ipvs->sync_mutex))\n\t\t\treturn -ERESTARTSYS;\n\n\t\tif (ipvs->sync_state & IP_VS_STATE_MASTER) {\n\t\t\td[0].state = IP_VS_STATE_MASTER;\n\t\t\tstrlcpy(d[0].mcast_ifn, ipvs->master_mcast_ifn,\n\t\t\t\tsizeof(d[0].mcast_ifn));\n\t\t\td[0].syncid = ipvs->master_syncid;\n\t\t}\n\t\tif (ipvs->sync_state & IP_VS_STATE_BACKUP) {\n\t\t\td[1].state = IP_VS_STATE_BACKUP;\n\t\t\tstrlcpy(d[1].mcast_ifn, ipvs->backup_mcast_ifn,\n\t\t\t\tsizeof(d[1].mcast_ifn));\n\t\t\td[1].syncid = ipvs->backup_syncid;\n\t\t}\n\t\tif (copy_to_user(user, &d, sizeof(d)) != 0)\n\t\t\tret = -EFAULT;\n\t\tmutex_unlock(&ipvs->sync_mutex);\n\t\treturn ret;\n\t}\n\n\tif (mutex_lock_interruptible(&__ip_vs_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tswitch (cmd) {\n\tcase IP_VS_SO_GET_VERSION:\n\t{\n\t\tchar buf[64];\n\n\t\tsprintf(buf, \"IP Virtual Server version %d.%d.%d (size=%d)\",\n\t\t\tNVERSION(IP_VS_VERSION_CODE), ip_vs_conn_tab_size);\n\t\tif (copy_to_user(user, buf, strlen(buf)+1) != 0) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\t*len = strlen(buf)+1;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_INFO:\n\t{\n\t\tstruct ip_vs_getinfo info;\n\t\tinfo.version = IP_VS_VERSION_CODE;\n\t\tinfo.size = ip_vs_conn_tab_size;\n\t\tinfo.num_services = ipvs->num_services;\n\t\tif (copy_to_user(user, &info, sizeof(info)) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_SERVICES:\n\t{\n\t\tstruct ip_vs_get_services *get;\n\t\tint size;\n\n\t\tget = (struct ip_vs_get_services *)arg;\n\t\tsize = sizeof(*get) +\n\t\t\tsizeof(struct ip_vs_service_entry) * get->num_services;\n\t\tif (*len != size) {\n\t\t\tpr_err(\"length: %u != %u\\n\", *len, size);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tret = __ip_vs_get_service_entries(net, get, user);\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_SERVICE:\n\t{\n\t\tstruct ip_vs_service_entry *entry;\n\t\tstruct ip_vs_service *svc;\n\t\tunion nf_inet_addr addr;\n\n\t\tentry = (struct ip_vs_service_entry *)arg;\n\t\taddr.ip = entry->addr;\n\t\tif (entry->fwmark)\n\t\t\tsvc = __ip_vs_svc_fwm_find(net, AF_INET, entry->fwmark);\n\t\telse\n\t\t\tsvc = __ip_vs_service_find(net, AF_INET,\n\t\t\t\t\t\t   entry->protocol, &addr,\n\t\t\t\t\t\t   entry->port);\n\t\tif (svc) {\n\t\t\tip_vs_copy_service(entry, svc);\n\t\t\tif (copy_to_user(user, entry, sizeof(*entry)) != 0)\n\t\t\t\tret = -EFAULT;\n\t\t} else\n\t\t\tret = -ESRCH;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_DESTS:\n\t{\n\t\tstruct ip_vs_get_dests *get;\n\t\tint size;\n\n\t\tget = (struct ip_vs_get_dests *)arg;\n\t\tsize = sizeof(*get) +\n\t\t\tsizeof(struct ip_vs_dest_entry) * get->num_dests;\n\t\tif (*len != size) {\n\t\t\tpr_err(\"length: %u != %u\\n\", *len, size);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tret = __ip_vs_get_dest_entries(net, get, user);\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_TIMEOUT:\n \t{\n \t\tstruct ip_vs_timeout_user t;\n \n\t\tmemset(&t, 0, sizeof(t));\n \t\t__ip_vs_get_timeouts(net, &t);\n \t\tif (copy_to_user(user, &t, sizeof(t)) != 0)\n \t\t\tret = -EFAULT;\n\t}\n\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\nout:\n\tmutex_unlock(&__ip_vs_mutex);\n\treturn ret;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141822,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": " static void copy_to_user_state(struct xfrm_state *x, struct xfrm_usersa_info *p)\n {\n \tmemcpy(&p->id, &x->id, sizeof(p->id));\n \tmemcpy(&p->sel, &x->sel, sizeof(p->sel));\n \tmemcpy(&p->lft, &x->lft, sizeof(p->lft));\n\tmemcpy(&p->curlft, &x->curlft, sizeof(p->curlft));\n\tmemcpy(&p->stats, &x->stats, sizeof(p->stats));\n\tmemcpy(&p->saddr, &x->props.saddr, sizeof(p->saddr));\n\tp->mode = x->props.mode;\n\tp->replay_window = x->props.replay_window;\n\tp->reqid = x->props.reqid;\n\tp->family = x->props.family;\n\tp->flags = x->props.flags;\n\tp->seq = x->km.seq;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141823,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": " static void copy_to_user_state(struct xfrm_state *x, struct xfrm_usersa_info *p)\n {\n\tmemset(p, 0, sizeof(*p));\n \tmemcpy(&p->id, &x->id, sizeof(p->id));\n \tmemcpy(&p->sel, &x->sel, sizeof(p->sel));\n \tmemcpy(&p->lft, &x->lft, sizeof(p->lft));\n\tmemcpy(&p->curlft, &x->curlft, sizeof(p->curlft));\n\tmemcpy(&p->stats, &x->stats, sizeof(p->stats));\n\tmemcpy(&p->saddr, &x->props.saddr, sizeof(p->saddr));\n\tp->mode = x->props.mode;\n\tp->replay_window = x->props.replay_window;\n\tp->reqid = x->props.reqid;\n\tp->family = x->props.family;\n\tp->flags = x->props.flags;\n\tp->seq = x->km.seq;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141824,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int load_script(struct linux_binprm *bprm)\n{\n\tconst char *i_arg, *i_name;\n\tchar *cp;\n\tstruct file *file;\n\tchar interp[BINPRM_BUF_SIZE];\n\tint retval;\n\n\tif ((bprm->buf[0] != '#') || (bprm->buf[1] != '!'))\n\t\treturn -ENOEXEC;\n\t/*\n\t * This section does the #! interpretation.\n\t * Sorta complicated, but hopefully it will work.  -TYT\n\t */\n\n\tallow_write_access(bprm->file);\n\tfput(bprm->file);\n\tbprm->file = NULL;\n\n\tbprm->buf[BINPRM_BUF_SIZE - 1] = '\\0';\n\tif ((cp = strchr(bprm->buf, '\\n')) == NULL)\n\t\tcp = bprm->buf+BINPRM_BUF_SIZE-1;\n\t*cp = '\\0';\n\twhile (cp > bprm->buf) {\n\t\tcp--;\n\t\tif ((*cp == ' ') || (*cp == '\\t'))\n\t\t\t*cp = '\\0';\n\t\telse\n\t\t\tbreak;\n\t}\n\tfor (cp = bprm->buf+2; (*cp == ' ') || (*cp == '\\t'); cp++);\n\tif (*cp == '\\0') \n\t\treturn -ENOEXEC; /* No interpreter name found */\n\ti_name = cp;\n\ti_arg = NULL;\n\tfor ( ; *cp && (*cp != ' ') && (*cp != '\\t'); cp++)\n\t\t/* nothing */ ;\n\twhile ((*cp == ' ') || (*cp == '\\t'))\n\t\t*cp++ = '\\0';\n\tif (*cp)\n\t\ti_arg = cp;\n\tstrcpy (interp, i_name);\n\t/*\n\t * OK, we've parsed out the interpreter name and\n\t * (optional) argument.\n\t * Splice in (1) the interpreter's name for argv[0]\n\t *           (2) (optional) argument to interpreter\n\t *           (3) filename of shell script (replace argv[0])\n\t *\n\t * This is done in reverse order, because of how the\n\t * user environment and arguments are stored.\n\t */\n\tretval = remove_arg_zero(bprm);\n\tif (retval)\n\t\treturn retval;\n\tretval = copy_strings_kernel(1, &bprm->interp, bprm);\n\tif (retval < 0) return retval; \n\tbprm->argc++;\n\tif (i_arg) {\n\t\tretval = copy_strings_kernel(1, &i_arg, bprm);\n\t\tif (retval < 0) return retval; \n\t\tbprm->argc++;\n\t}\n \tretval = copy_strings_kernel(1, &i_name, bprm);\n \tif (retval) return retval; \n \tbprm->argc++;\n\tbprm->interp = interp;\n \n \t/*\n \t * OK, now restart the process with the interpreter's dentry.\n\t */\n\tfile = open_exec(interp);\n\tif (IS_ERR(file))\n\t\treturn PTR_ERR(file);\n\n\tbprm->file = file;\n\tretval = prepare_binprm(bprm);\n\tif (retval < 0)\n\t\treturn retval;\n\treturn search_binary_handler(bprm);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141825,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int load_script(struct linux_binprm *bprm)\n{\n\tconst char *i_arg, *i_name;\n\tchar *cp;\n\tstruct file *file;\n\tchar interp[BINPRM_BUF_SIZE];\n\tint retval;\n\n\tif ((bprm->buf[0] != '#') || (bprm->buf[1] != '!'))\n\t\treturn -ENOEXEC;\n\t/*\n\t * This section does the #! interpretation.\n\t * Sorta complicated, but hopefully it will work.  -TYT\n\t */\n\n\tallow_write_access(bprm->file);\n\tfput(bprm->file);\n\tbprm->file = NULL;\n\n\tbprm->buf[BINPRM_BUF_SIZE - 1] = '\\0';\n\tif ((cp = strchr(bprm->buf, '\\n')) == NULL)\n\t\tcp = bprm->buf+BINPRM_BUF_SIZE-1;\n\t*cp = '\\0';\n\twhile (cp > bprm->buf) {\n\t\tcp--;\n\t\tif ((*cp == ' ') || (*cp == '\\t'))\n\t\t\t*cp = '\\0';\n\t\telse\n\t\t\tbreak;\n\t}\n\tfor (cp = bprm->buf+2; (*cp == ' ') || (*cp == '\\t'); cp++);\n\tif (*cp == '\\0') \n\t\treturn -ENOEXEC; /* No interpreter name found */\n\ti_name = cp;\n\ti_arg = NULL;\n\tfor ( ; *cp && (*cp != ' ') && (*cp != '\\t'); cp++)\n\t\t/* nothing */ ;\n\twhile ((*cp == ' ') || (*cp == '\\t'))\n\t\t*cp++ = '\\0';\n\tif (*cp)\n\t\ti_arg = cp;\n\tstrcpy (interp, i_name);\n\t/*\n\t * OK, we've parsed out the interpreter name and\n\t * (optional) argument.\n\t * Splice in (1) the interpreter's name for argv[0]\n\t *           (2) (optional) argument to interpreter\n\t *           (3) filename of shell script (replace argv[0])\n\t *\n\t * This is done in reverse order, because of how the\n\t * user environment and arguments are stored.\n\t */\n\tretval = remove_arg_zero(bprm);\n\tif (retval)\n\t\treturn retval;\n\tretval = copy_strings_kernel(1, &bprm->interp, bprm);\n\tif (retval < 0) return retval; \n\tbprm->argc++;\n\tif (i_arg) {\n\t\tretval = copy_strings_kernel(1, &i_arg, bprm);\n\t\tif (retval < 0) return retval; \n\t\tbprm->argc++;\n\t}\n \tretval = copy_strings_kernel(1, &i_name, bprm);\n \tif (retval) return retval; \n \tbprm->argc++;\n\tretval = bprm_change_interp(interp, bprm);\n\tif (retval < 0)\n\t\treturn retval;\n \n \t/*\n \t * OK, now restart the process with the interpreter's dentry.\n\t */\n\tfile = open_exec(interp);\n\tif (IS_ERR(file))\n\t\treturn PTR_ERR(file);\n\n\tbprm->file = file;\n\tretval = prepare_binprm(bprm);\n\tif (retval < 0)\n\t\treturn retval;\n\treturn search_binary_handler(bprm);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141826,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "__switch_to(struct task_struct *prev_p, struct task_struct *next_p)\n{\n\tstruct thread_struct *prev = &prev_p->thread;\n\tstruct thread_struct *next = &next_p->thread;\n\tint cpu = smp_processor_id();\n\tstruct tss_struct *tss = &per_cpu(init_tss, cpu);\n\tunsigned fsindex, gsindex;\n\tfpu_switch_t fpu;\n \n \tfpu = switch_fpu_prepare(prev_p, next_p, cpu);\n \n\t/*\n\t * Reload esp0, LDT and the page table pointer:\n\t */\n \tload_sp0(tss, next);\n \n\t/*\n\t * Switch DS and ES.\n\t * This won't pick up thread selector changes, but I guess that is ok.\n\t */\n\tsavesegment(es, prev->es);\n\tif (unlikely(next->es | prev->es))\n\t\tloadsegment(es, next->es);\n\tsavesegment(ds, prev->ds);\n\tif (unlikely(next->ds | prev->ds))\n\t\tloadsegment(ds, next->ds);\n \t/* We must save %fs and %gs before load_TLS() because\n \t * %fs and %gs may be cleared by load_TLS().\n \t *\n\t * (e.g. xen_load_tls())\n\t */\n \tsavesegment(fs, fsindex);\n \tsavesegment(gs, gsindex);\n \n \tload_TLS(next, cpu);\n \n \t/*\n\t * Leave lazy mode, flushing any hypercalls made here.\n\t * This must be done before restoring TLS segments so\n\t * the GDT and LDT are properly updated, and must be\n\t * done before math_state_restore, so the TS bit is up\n\t * to date.\n \t */\n \tarch_end_context_switch(next_p);\n \n \t/*\n \t * Switch FS and GS.\n \t *\n\t * Segment register != 0 always requires a reload.  Also\n\t * reload when it has changed.  When prev process used 64bit\n\t * base always reload to avoid an information leak.\n \t */\n \tif (unlikely(fsindex | next->fsindex | prev->fs)) {\n \t\tloadsegment(fs, next->fsindex);\n \t\t/*\n\t\t * Check if the user used a selector != 0; if yes\n\t\t *  clear 64bit base, since overloaded base is always\n\t\t *  mapped to the Null selector\n \t\t */\n \t\tif (fsindex)\n \t\t\tprev->fs = 0;\n \t}\n\t/* when next process has a 64bit base use it */\n \tif (next->fs)\n \t\twrmsrl(MSR_FS_BASE, next->fs);\n \tprev->fsindex = fsindex;\n \n \tif (unlikely(gsindex | next->gsindex | prev->gs)) {\n \t\tload_gs_index(next->gsindex);\n \t\tif (gsindex)\n \t\t\tprev->gs = 0;\n \t}\n\tif (next->gs)\n\t\twrmsrl(MSR_KERNEL_GS_BASE, next->gs);\n\tprev->gsindex = gsindex;\n\n\tswitch_fpu_finish(next_p, fpu);\n\n\t/*\n\t * Switch the PDA and FPU contexts.\n\t */\n\tprev->usersp = this_cpu_read(old_rsp);\n\tthis_cpu_write(old_rsp, next->usersp);\n\tthis_cpu_write(current_task, next_p);\n\n\t/*\n\t * If it were not for PREEMPT_ACTIVE we could guarantee that the\n\t * preempt_count of all tasks was equal here and this would not be\n\t * needed.\n\t */\n\ttask_thread_info(prev_p)->saved_preempt_count = this_cpu_read(__preempt_count);\n\tthis_cpu_write(__preempt_count, task_thread_info(next_p)->saved_preempt_count);\n\n\tthis_cpu_write(kernel_stack,\n\t\t  (unsigned long)task_stack_page(next_p) +\n\t\t  THREAD_SIZE - KERNEL_STACK_OFFSET);\n\n\t/*\n\t * Now maybe reload the debug registers and handle I/O bitmaps\n\t */\n\tif (unlikely(task_thread_info(next_p)->flags & _TIF_WORK_CTXSW_NEXT ||\n\t\t     task_thread_info(prev_p)->flags & _TIF_WORK_CTXSW_PREV))\n\t\t__switch_to_xtra(prev_p, next_p, tss);\n\n\treturn prev_p;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141843,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "__switch_to(struct task_struct *prev_p, struct task_struct *next_p)\n{\n\tstruct thread_struct *prev = &prev_p->thread;\n\tstruct thread_struct *next = &next_p->thread;\n\tint cpu = smp_processor_id();\n\tstruct tss_struct *tss = &per_cpu(init_tss, cpu);\n\tunsigned fsindex, gsindex;\n\tfpu_switch_t fpu;\n \n \tfpu = switch_fpu_prepare(prev_p, next_p, cpu);\n \n\t/* Reload esp0 and ss1. */\n \tload_sp0(tss, next);\n \n \t/* We must save %fs and %gs before load_TLS() because\n \t * %fs and %gs may be cleared by load_TLS().\n \t *\n\t * (e.g. xen_load_tls())\n\t */\n \tsavesegment(fs, fsindex);\n \tsavesegment(gs, gsindex);\n \n\t/*\n\t * Load TLS before restoring any segments so that segment loads\n\t * reference the correct GDT entries.\n\t */\n \tload_TLS(next, cpu);\n \n \t/*\n\t * Leave lazy mode, flushing any hypercalls made here.  This\n\t * must be done after loading TLS entries in the GDT but before\n\t * loading segments that might reference them, and and it must\n\t * be done before math_state_restore, so the TS bit is up to\n\t * date.\n \t */\n \tarch_end_context_switch(next_p);\n \n\t/* Switch DS and ES.\n\t *\n\t * Reading them only returns the selectors, but writing them (if\n\t * nonzero) loads the full descriptor from the GDT or LDT.  The\n\t * LDT for next is loaded in switch_mm, and the GDT is loaded\n\t * above.\n\t *\n\t * We therefore need to write new values to the segment\n\t * registers on every context switch unless both the new and old\n\t * values are zero.\n\t *\n\t * Note that we don't need to do anything for CS and SS, as\n\t * those are saved and restored as part of pt_regs.\n\t */\n\tsavesegment(es, prev->es);\n\tif (unlikely(next->es | prev->es))\n\t\tloadsegment(es, next->es);\n\n\tsavesegment(ds, prev->ds);\n\tif (unlikely(next->ds | prev->ds))\n\t\tloadsegment(ds, next->ds);\n\n \t/*\n \t * Switch FS and GS.\n \t *\n\t * These are even more complicated than FS and GS: they have\n\t * 64-bit bases are that controlled by arch_prctl.  Those bases\n\t * only differ from the values in the GDT or LDT if the selector\n\t * is 0.\n\t *\n\t * Loading the segment register resets the hidden base part of\n\t * the register to 0 or the value from the GDT / LDT.  If the\n\t * next base address zero, writing 0 to the segment register is\n\t * much faster than using wrmsr to explicitly zero the base.\n\t *\n\t * The thread_struct.fs and thread_struct.gs values are 0\n\t * if the fs and gs bases respectively are not overridden\n\t * from the values implied by fsindex and gsindex.  They\n\t * are nonzero, and store the nonzero base addresses, if\n\t * the bases are overridden.\n\t *\n\t * (fs != 0 && fsindex != 0) || (gs != 0 && gsindex != 0) should\n\t * be impossible.\n\t *\n\t * Therefore we need to reload the segment registers if either\n\t * the old or new selector is nonzero, and we need to override\n\t * the base address if next thread expects it to be overridden.\n\t *\n\t * This code is unnecessarily slow in the case where the old and\n\t * new indexes are zero and the new base is nonzero -- it will\n\t * unnecessarily write 0 to the selector before writing the new\n\t * base address.\n\t *\n\t * Note: This all depends on arch_prctl being the only way that\n\t * user code can override the segment base.  Once wrfsbase and\n\t * wrgsbase are enabled, most of this code will need to change.\n \t */\n \tif (unlikely(fsindex | next->fsindex | prev->fs)) {\n \t\tloadsegment(fs, next->fsindex);\n\n \t\t/*\n\t\t * If user code wrote a nonzero value to FS, then it also\n\t\t * cleared the overridden base address.\n\t\t *\n\t\t * XXX: if user code wrote 0 to FS and cleared the base\n\t\t * address itself, we won't notice and we'll incorrectly\n\t\t * restore the prior base address next time we reschdule\n\t\t * the process.\n \t\t */\n \t\tif (fsindex)\n \t\t\tprev->fs = 0;\n \t}\n \tif (next->fs)\n \t\twrmsrl(MSR_FS_BASE, next->fs);\n \tprev->fsindex = fsindex;\n \n \tif (unlikely(gsindex | next->gsindex | prev->gs)) {\n \t\tload_gs_index(next->gsindex);\n\n\t\t/* This works (and fails) the same way as fsindex above. */\n \t\tif (gsindex)\n \t\t\tprev->gs = 0;\n \t}\n\tif (next->gs)\n\t\twrmsrl(MSR_KERNEL_GS_BASE, next->gs);\n\tprev->gsindex = gsindex;\n\n\tswitch_fpu_finish(next_p, fpu);\n\n\t/*\n\t * Switch the PDA and FPU contexts.\n\t */\n\tprev->usersp = this_cpu_read(old_rsp);\n\tthis_cpu_write(old_rsp, next->usersp);\n\tthis_cpu_write(current_task, next_p);\n\n\t/*\n\t * If it were not for PREEMPT_ACTIVE we could guarantee that the\n\t * preempt_count of all tasks was equal here and this would not be\n\t * needed.\n\t */\n\ttask_thread_info(prev_p)->saved_preempt_count = this_cpu_read(__preempt_count);\n\tthis_cpu_write(__preempt_count, task_thread_info(next_p)->saved_preempt_count);\n\n\tthis_cpu_write(kernel_stack,\n\t\t  (unsigned long)task_stack_page(next_p) +\n\t\t  THREAD_SIZE - KERNEL_STACK_OFFSET);\n\n\t/*\n\t * Now maybe reload the debug registers and handle I/O bitmaps\n\t */\n\tif (unlikely(task_thread_info(next_p)->flags & _TIF_WORK_CTXSW_NEXT ||\n\t\t     task_thread_info(prev_p)->flags & _TIF_WORK_CTXSW_PREV))\n\t\t__switch_to_xtra(prev_p, next_p, tss);\n\n\treturn prev_p;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141844,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static long media_device_enum_entities(struct media_device *mdev,\n\t\t\t\t       struct media_entity_desc __user *uent)\n{\n \tstruct media_entity *ent;\n \tstruct media_entity_desc u_ent;\n \n \tif (copy_from_user(&u_ent.id, &uent->id, sizeof(u_ent.id)))\n \t\treturn -EFAULT;\n \n\tent = find_entity(mdev, u_ent.id);\n\n\tif (ent == NULL)\n\t\treturn -EINVAL;\n\n\tu_ent.id = ent->id;\n\tif (ent->name) {\n\t\tstrncpy(u_ent.name, ent->name, sizeof(u_ent.name));\n\t\tu_ent.name[sizeof(u_ent.name) - 1] = '\\0';\n\t} else {\n\t\tmemset(u_ent.name, 0, sizeof(u_ent.name));\n\t}\n\tu_ent.type = ent->type;\n\tu_ent.revision = ent->revision;\n\tu_ent.flags = ent->flags;\n\tu_ent.group_id = ent->group_id;\n\tu_ent.pads = ent->num_pads;\n\tu_ent.links = ent->num_links - ent->num_backlinks;\n\tmemcpy(&u_ent.raw, &ent->info, sizeof(ent->info));\n\tif (copy_to_user(uent, &u_ent, sizeof(u_ent)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141907,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static long media_device_enum_entities(struct media_device *mdev,\n\t\t\t\t       struct media_entity_desc __user *uent)\n{\n \tstruct media_entity *ent;\n \tstruct media_entity_desc u_ent;\n \n\tmemset(&u_ent, 0, sizeof(u_ent));\n \tif (copy_from_user(&u_ent.id, &uent->id, sizeof(u_ent.id)))\n \t\treturn -EFAULT;\n \n\tent = find_entity(mdev, u_ent.id);\n\n\tif (ent == NULL)\n\t\treturn -EINVAL;\n\n\tu_ent.id = ent->id;\n\tif (ent->name) {\n\t\tstrncpy(u_ent.name, ent->name, sizeof(u_ent.name));\n\t\tu_ent.name[sizeof(u_ent.name) - 1] = '\\0';\n\t} else {\n\t\tmemset(u_ent.name, 0, sizeof(u_ent.name));\n\t}\n\tu_ent.type = ent->type;\n\tu_ent.revision = ent->revision;\n\tu_ent.flags = ent->flags;\n\tu_ent.group_id = ent->group_id;\n\tu_ent.pads = ent->num_pads;\n\tu_ent.links = ent->num_links - ent->num_backlinks;\n\tmemcpy(&u_ent.raw, &ent->info, sizeof(ent->info));\n\tif (copy_to_user(uent, &u_ent, sizeof(u_ent)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141908,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int dgram_recvmsg(struct kiocb *iocb, struct sock *sk,\n\t\tstruct msghdr *msg, size_t len, int noblock, int flags,\n\t\tint *addr_len)\n{\n\tsize_t copied = 0;\n\tint err = -EOPNOTSUPP;\n\tstruct sk_buff *skb;\n\tstruct sockaddr_ieee802154 *saddr;\n\n\tsaddr = (struct sockaddr_ieee802154 *)msg->msg_name;\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb)\n\t\tgoto out;\n\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\t/* FIXME: skip headers if necessary ?! */\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err)\n\t\tgoto done;\n\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\n \tif (saddr) {\n \t\tsaddr->family = AF_IEEE802154;\n \t\tsaddr->addr = mac_cb(skb)->sa;\n\t}\n\tif (addr_len)\n \t\t*addr_len = sizeof(*saddr);\n \n \tif (flags & MSG_TRUNC)\n \t\tcopied = skb->len;\ndone:\n\tskb_free_datagram(sk, skb);\nout:\n\tif (err)\n\t\treturn err;\n\treturn copied;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141923,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int dgram_recvmsg(struct kiocb *iocb, struct sock *sk,\n\t\tstruct msghdr *msg, size_t len, int noblock, int flags,\n\t\tint *addr_len)\n{\n\tsize_t copied = 0;\n\tint err = -EOPNOTSUPP;\n\tstruct sk_buff *skb;\n\tstruct sockaddr_ieee802154 *saddr;\n\n\tsaddr = (struct sockaddr_ieee802154 *)msg->msg_name;\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb)\n\t\tgoto out;\n\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\t/* FIXME: skip headers if necessary ?! */\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err)\n\t\tgoto done;\n\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\n \tif (saddr) {\n \t\tsaddr->family = AF_IEEE802154;\n \t\tsaddr->addr = mac_cb(skb)->sa;\n \t\t*addr_len = sizeof(*saddr);\n\t}\n \n \tif (flags & MSG_TRUNC)\n \t\tcopied = skb->len;\ndone:\n\tskb_free_datagram(sk, skb);\nout:\n\tif (err)\n\t\treturn err;\n\treturn copied;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141924,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int l2tp_ip_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n\t\t\t   size_t len, int noblock, int flags, int *addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tsize_t copied = 0;\n\tint err = -EOPNOTSUPP;\n\tstruct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;\n\tstruct sk_buff *skb;\n\n \tif (flags & MSG_OOB)\n \t\tgoto out;\n \n\tif (addr_len)\n\t\t*addr_len = sizeof(*sin);\n \tskb = skb_recv_datagram(sk, flags, noblock, &err);\n \tif (!skb)\n \t\tgoto out;\n\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err)\n\t\tgoto done;\n\n\tsock_recv_timestamp(msg, sk, skb);\n\n\t/* Copy the address. */\n\tif (sin) {\n\t\tsin->sin_family = AF_INET;\n \t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n \t\tsin->sin_port = 0;\n \t\tmemset(&sin->sin_zero, 0, sizeof(sin->sin_zero));\n \t}\n \tif (inet->cmsg_flags)\n \t\tip_cmsg_recv(msg, skb);\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skb->len;\ndone:\n\tskb_free_datagram(sk, skb);\nout:\n\treturn err ? err : copied;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141925,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int l2tp_ip_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n\t\t\t   size_t len, int noblock, int flags, int *addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tsize_t copied = 0;\n\tint err = -EOPNOTSUPP;\n\tstruct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;\n\tstruct sk_buff *skb;\n\n \tif (flags & MSG_OOB)\n \t\tgoto out;\n \n \tskb = skb_recv_datagram(sk, flags, noblock, &err);\n \tif (!skb)\n \t\tgoto out;\n\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err)\n\t\tgoto done;\n\n\tsock_recv_timestamp(msg, sk, skb);\n\n\t/* Copy the address. */\n\tif (sin) {\n\t\tsin->sin_family = AF_INET;\n \t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n \t\tsin->sin_port = 0;\n \t\tmemset(&sin->sin_zero, 0, sizeof(sin->sin_zero));\n\t\t*addr_len = sizeof(*sin);\n \t}\n \tif (inet->cmsg_flags)\n \t\tip_cmsg_recv(msg, skb);\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skb->len;\ndone:\n\tskb_free_datagram(sk, skb);\nout:\n\treturn err ? err : copied;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141926,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int pn_recvmsg(struct kiocb *iocb, struct sock *sk,\n\t\t\tstruct msghdr *msg, size_t len, int noblock,\n\t\t\tint flags, int *addr_len)\n{\n\tstruct sk_buff *skb = NULL;\n\tstruct sockaddr_pn sa;\n\tint rval = -EOPNOTSUPP;\n\tint copylen;\n\n\tif (flags & ~(MSG_PEEK|MSG_TRUNC|MSG_DONTWAIT|MSG_NOSIGNAL|\n \t\t\tMSG_CMSG_COMPAT))\n \t\tgoto out_nofree;\n \n\tif (addr_len)\n\t\t*addr_len = sizeof(sa);\n \tskb = skb_recv_datagram(sk, flags, noblock, &rval);\n \tif (skb == NULL)\n \t\tgoto out_nofree;\n\n\tpn_skb_get_src_sockaddr(skb, &sa);\n\n\tcopylen = skb->len;\n\tif (len < copylen) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopylen = len;\n\t}\n\n\trval = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copylen);\n\tif (rval) {\n\t\trval = -EFAULT;\n\t\tgoto out;\n\t}\n \n \trval = (flags & MSG_TRUNC) ? skb->len : copylen;\n \n\tif (msg->msg_name != NULL)\n\t\tmemcpy(msg->msg_name, &sa, sizeof(struct sockaddr_pn));\n \n out:\n \tskb_free_datagram(sk, skb);\n\nout_nofree:\n\treturn rval;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141927,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int pn_recvmsg(struct kiocb *iocb, struct sock *sk,\n\t\t\tstruct msghdr *msg, size_t len, int noblock,\n\t\t\tint flags, int *addr_len)\n{\n\tstruct sk_buff *skb = NULL;\n\tstruct sockaddr_pn sa;\n\tint rval = -EOPNOTSUPP;\n\tint copylen;\n\n\tif (flags & ~(MSG_PEEK|MSG_TRUNC|MSG_DONTWAIT|MSG_NOSIGNAL|\n \t\t\tMSG_CMSG_COMPAT))\n \t\tgoto out_nofree;\n \n \tskb = skb_recv_datagram(sk, flags, noblock, &rval);\n \tif (skb == NULL)\n \t\tgoto out_nofree;\n\n\tpn_skb_get_src_sockaddr(skb, &sa);\n\n\tcopylen = skb->len;\n\tif (len < copylen) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopylen = len;\n\t}\n\n\trval = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copylen);\n\tif (rval) {\n\t\trval = -EFAULT;\n\t\tgoto out;\n\t}\n \n \trval = (flags & MSG_TRUNC) ? skb->len : copylen;\n \n\tif (msg->msg_name != NULL) {\n\t\tmemcpy(msg->msg_name, &sa, sizeof(sa));\n\t\t*addr_len = sizeof(sa);\n\t}\n \n out:\n \tskb_free_datagram(sk, skb);\n\nout_nofree:\n\treturn rval;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141928,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int do_devinfo_ioctl(struct comedi_device *dev,\n\t\t\t    struct comedi_devinfo __user *arg,\n\t\t\t    struct file *file)\n{\n\tstruct comedi_devinfo devinfo;\n\tconst unsigned minor = iminor(file->f_dentry->d_inode);\n\tstruct comedi_device_file_info *dev_file_info =\n\t    comedi_get_device_file_info(minor);\n\tstruct comedi_subdevice *read_subdev =\n\t    comedi_get_read_subdevice(dev_file_info);\n\tstruct comedi_subdevice *write_subdev =\n\t    comedi_get_write_subdevice(dev_file_info);\n\n\tmemset(&devinfo, 0, sizeof(devinfo));\n\n \t/* fill devinfo structure */\n \tdevinfo.version_code = COMEDI_VERSION_CODE;\n \tdevinfo.n_subdevs = dev->n_subdevices;\n\tmemcpy(devinfo.driver_name, dev->driver->driver_name, COMEDI_NAMELEN);\n\tmemcpy(devinfo.board_name, dev->board_name, COMEDI_NAMELEN);\n \n \tif (read_subdev)\n \t\tdevinfo.read_subdevice = read_subdev - dev->subdevices;\n\telse\n\t\tdevinfo.read_subdevice = -1;\n\n\tif (write_subdev)\n\t\tdevinfo.write_subdevice = write_subdev - dev->subdevices;\n\telse\n\t\tdevinfo.write_subdevice = -1;\n\n\tif (copy_to_user(arg, &devinfo, sizeof(struct comedi_devinfo)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141951,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int do_devinfo_ioctl(struct comedi_device *dev,\n\t\t\t    struct comedi_devinfo __user *arg,\n\t\t\t    struct file *file)\n{\n\tstruct comedi_devinfo devinfo;\n\tconst unsigned minor = iminor(file->f_dentry->d_inode);\n\tstruct comedi_device_file_info *dev_file_info =\n\t    comedi_get_device_file_info(minor);\n\tstruct comedi_subdevice *read_subdev =\n\t    comedi_get_read_subdevice(dev_file_info);\n\tstruct comedi_subdevice *write_subdev =\n\t    comedi_get_write_subdevice(dev_file_info);\n\n\tmemset(&devinfo, 0, sizeof(devinfo));\n\n \t/* fill devinfo structure */\n \tdevinfo.version_code = COMEDI_VERSION_CODE;\n \tdevinfo.n_subdevs = dev->n_subdevices;\n\tstrlcpy(devinfo.driver_name, dev->driver->driver_name, COMEDI_NAMELEN);\n\tstrlcpy(devinfo.board_name, dev->board_name, COMEDI_NAMELEN);\n \n \tif (read_subdev)\n \t\tdevinfo.read_subdevice = read_subdev - dev->subdevices;\n\telse\n\t\tdevinfo.read_subdevice = -1;\n\n\tif (write_subdev)\n\t\tdevinfo.write_subdevice = write_subdev - dev->subdevices;\n\telse\n\t\tdevinfo.write_subdevice = -1;\n\n\tif (copy_to_user(arg, &devinfo, sizeof(struct comedi_devinfo)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141952,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "long dgnc_mgmt_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tunsigned long flags;\n\tvoid __user *uarg = (void __user *)arg;\n\n\tswitch (cmd) {\n\tcase DIGI_GETDD:\n\t{\n\t\t/*\n\t\t * This returns the total number of boards\n\t\t * in the system, as well as driver version\n\t\t * and has space for a reserved entry\n\t\t */\n\t\tstruct digi_dinfo ddi;\n \n \t\tspin_lock_irqsave(&dgnc_global_lock, flags);\n \n \t\tddi.dinfo_nboards = dgnc_NumBoards;\n \t\tsprintf(ddi.dinfo_version, \"%s\", DG_PART);\n \n\t\tspin_unlock_irqrestore(&dgnc_global_lock, flags);\n\n\t\tif (copy_to_user(uarg, &ddi, sizeof(ddi)))\n\t\t\treturn -EFAULT;\n\n\t\tbreak;\n\t}\n\n\tcase DIGI_GETBD:\n\t{\n\t\tint brd;\n\n\t\tstruct digi_info di;\n\n\t\tif (copy_from_user(&brd, uarg, sizeof(int)))\n\t\t\treturn -EFAULT;\n\n\t\tif (brd < 0 || brd >= dgnc_NumBoards)\n\t\t\treturn -ENODEV;\n\n\t\tmemset(&di, 0, sizeof(di));\n\n\t\tdi.info_bdnum = brd;\n\n\t\tspin_lock_irqsave(&dgnc_Board[brd]->bd_lock, flags);\n\n\t\tdi.info_bdtype = dgnc_Board[brd]->dpatype;\n\t\tdi.info_bdstate = dgnc_Board[brd]->dpastatus;\n\t\tdi.info_ioport = 0;\n\t\tdi.info_physaddr = (ulong)dgnc_Board[brd]->membase;\n\t\tdi.info_physsize = (ulong)dgnc_Board[brd]->membase\n\t\t\t- dgnc_Board[brd]->membase_end;\n\t\tif (dgnc_Board[brd]->state != BOARD_FAILED)\n\t\t\tdi.info_nports = dgnc_Board[brd]->nasync;\n\t\telse\n\t\t\tdi.info_nports = 0;\n\n\t\tspin_unlock_irqrestore(&dgnc_Board[brd]->bd_lock, flags);\n\n\t\tif (copy_to_user(uarg, &di, sizeof(di)))\n\t\t\treturn -EFAULT;\n\n\t\tbreak;\n\t}\n\n\tcase DIGI_GET_NI_INFO:\n\t{\n\t\tstruct channel_t *ch;\n\t\tstruct ni_info ni;\n\t\tunsigned char mstat = 0;\n\t\tuint board = 0;\n\t\tuint channel = 0;\n\n\t\tif (copy_from_user(&ni, uarg, sizeof(ni)))\n\t\t\treturn -EFAULT;\n\n\t\tboard = ni.board;\n\t\tchannel = ni.channel;\n\n\t\t/* Verify boundaries on board */\n\t\tif (board >= dgnc_NumBoards)\n\t\t\treturn -ENODEV;\n\n\t\t/* Verify boundaries on channel */\n\t\tif (channel >= dgnc_Board[board]->nasync)\n\t\t\treturn -ENODEV;\n\n\t\tch = dgnc_Board[board]->channels[channel];\n\n\t\tif (!ch || ch->magic != DGNC_CHANNEL_MAGIC)\n\t\t\treturn -ENODEV;\n\n\t\tmemset(&ni, 0, sizeof(ni));\n\t\tni.board = board;\n\t\tni.channel = channel;\n\n\t\tspin_lock_irqsave(&ch->ch_lock, flags);\n\n\t\tmstat = (ch->ch_mostat | ch->ch_mistat);\n\n\t\tif (mstat & UART_MCR_DTR) {\n\t\t\tni.mstat |= TIOCM_DTR;\n\t\t\tni.dtr = TIOCM_DTR;\n\t\t}\n\t\tif (mstat & UART_MCR_RTS) {\n\t\t\tni.mstat |= TIOCM_RTS;\n\t\t\tni.rts = TIOCM_RTS;\n\t\t}\n\t\tif (mstat & UART_MSR_CTS) {\n\t\t\tni.mstat |= TIOCM_CTS;\n\t\t\tni.cts = TIOCM_CTS;\n\t\t}\n\t\tif (mstat & UART_MSR_RI) {\n\t\t\tni.mstat |= TIOCM_RI;\n\t\t\tni.ri = TIOCM_RI;\n\t\t}\n\t\tif (mstat & UART_MSR_DCD) {\n\t\t\tni.mstat |= TIOCM_CD;\n\t\t\tni.dcd = TIOCM_CD;\n\t\t}\n\t\tif (mstat & UART_MSR_DSR)\n\t\t\tni.mstat |= TIOCM_DSR;\n\n\t\tni.iflag = ch->ch_c_iflag;\n\t\tni.oflag = ch->ch_c_oflag;\n\t\tni.cflag = ch->ch_c_cflag;\n\t\tni.lflag = ch->ch_c_lflag;\n\n\t\tif (ch->ch_digi.digi_flags & CTSPACE ||\n\t\t    ch->ch_c_cflag & CRTSCTS)\n\t\t\tni.hflow = 1;\n\t\telse\n\t\t\tni.hflow = 0;\n\n\t\tif ((ch->ch_flags & CH_STOPI) ||\n\t\t    (ch->ch_flags & CH_FORCED_STOPI))\n\t\t\tni.recv_stopped = 1;\n\t\telse\n\t\t\tni.recv_stopped = 0;\n\n\t\tif ((ch->ch_flags & CH_STOP) || (ch->ch_flags & CH_FORCED_STOP))\n\t\t\tni.xmit_stopped = 1;\n\t\telse\n\t\t\tni.xmit_stopped = 0;\n\n\t\tni.curtx = ch->ch_txcount;\n\t\tni.currx = ch->ch_rxcount;\n\n\t\tni.baud = ch->ch_old_baud;\n\n\t\tspin_unlock_irqrestore(&ch->ch_lock, flags);\n\n\t\tif (copy_to_user(uarg, &ni, sizeof(ni)))\n\t\t\treturn -EFAULT;\n\n\t\tbreak;\n\t}\n\t}\n\n\treturn 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141955,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "long dgnc_mgmt_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tunsigned long flags;\n\tvoid __user *uarg = (void __user *)arg;\n\n\tswitch (cmd) {\n\tcase DIGI_GETDD:\n\t{\n\t\t/*\n\t\t * This returns the total number of boards\n\t\t * in the system, as well as driver version\n\t\t * and has space for a reserved entry\n\t\t */\n\t\tstruct digi_dinfo ddi;\n \n \t\tspin_lock_irqsave(&dgnc_global_lock, flags);\n \n\t\tmemset(&ddi, 0, sizeof(ddi));\n \t\tddi.dinfo_nboards = dgnc_NumBoards;\n \t\tsprintf(ddi.dinfo_version, \"%s\", DG_PART);\n \n\t\tspin_unlock_irqrestore(&dgnc_global_lock, flags);\n\n\t\tif (copy_to_user(uarg, &ddi, sizeof(ddi)))\n\t\t\treturn -EFAULT;\n\n\t\tbreak;\n\t}\n\n\tcase DIGI_GETBD:\n\t{\n\t\tint brd;\n\n\t\tstruct digi_info di;\n\n\t\tif (copy_from_user(&brd, uarg, sizeof(int)))\n\t\t\treturn -EFAULT;\n\n\t\tif (brd < 0 || brd >= dgnc_NumBoards)\n\t\t\treturn -ENODEV;\n\n\t\tmemset(&di, 0, sizeof(di));\n\n\t\tdi.info_bdnum = brd;\n\n\t\tspin_lock_irqsave(&dgnc_Board[brd]->bd_lock, flags);\n\n\t\tdi.info_bdtype = dgnc_Board[brd]->dpatype;\n\t\tdi.info_bdstate = dgnc_Board[brd]->dpastatus;\n\t\tdi.info_ioport = 0;\n\t\tdi.info_physaddr = (ulong)dgnc_Board[brd]->membase;\n\t\tdi.info_physsize = (ulong)dgnc_Board[brd]->membase\n\t\t\t- dgnc_Board[brd]->membase_end;\n\t\tif (dgnc_Board[brd]->state != BOARD_FAILED)\n\t\t\tdi.info_nports = dgnc_Board[brd]->nasync;\n\t\telse\n\t\t\tdi.info_nports = 0;\n\n\t\tspin_unlock_irqrestore(&dgnc_Board[brd]->bd_lock, flags);\n\n\t\tif (copy_to_user(uarg, &di, sizeof(di)))\n\t\t\treturn -EFAULT;\n\n\t\tbreak;\n\t}\n\n\tcase DIGI_GET_NI_INFO:\n\t{\n\t\tstruct channel_t *ch;\n\t\tstruct ni_info ni;\n\t\tunsigned char mstat = 0;\n\t\tuint board = 0;\n\t\tuint channel = 0;\n\n\t\tif (copy_from_user(&ni, uarg, sizeof(ni)))\n\t\t\treturn -EFAULT;\n\n\t\tboard = ni.board;\n\t\tchannel = ni.channel;\n\n\t\t/* Verify boundaries on board */\n\t\tif (board >= dgnc_NumBoards)\n\t\t\treturn -ENODEV;\n\n\t\t/* Verify boundaries on channel */\n\t\tif (channel >= dgnc_Board[board]->nasync)\n\t\t\treturn -ENODEV;\n\n\t\tch = dgnc_Board[board]->channels[channel];\n\n\t\tif (!ch || ch->magic != DGNC_CHANNEL_MAGIC)\n\t\t\treturn -ENODEV;\n\n\t\tmemset(&ni, 0, sizeof(ni));\n\t\tni.board = board;\n\t\tni.channel = channel;\n\n\t\tspin_lock_irqsave(&ch->ch_lock, flags);\n\n\t\tmstat = (ch->ch_mostat | ch->ch_mistat);\n\n\t\tif (mstat & UART_MCR_DTR) {\n\t\t\tni.mstat |= TIOCM_DTR;\n\t\t\tni.dtr = TIOCM_DTR;\n\t\t}\n\t\tif (mstat & UART_MCR_RTS) {\n\t\t\tni.mstat |= TIOCM_RTS;\n\t\t\tni.rts = TIOCM_RTS;\n\t\t}\n\t\tif (mstat & UART_MSR_CTS) {\n\t\t\tni.mstat |= TIOCM_CTS;\n\t\t\tni.cts = TIOCM_CTS;\n\t\t}\n\t\tif (mstat & UART_MSR_RI) {\n\t\t\tni.mstat |= TIOCM_RI;\n\t\t\tni.ri = TIOCM_RI;\n\t\t}\n\t\tif (mstat & UART_MSR_DCD) {\n\t\t\tni.mstat |= TIOCM_CD;\n\t\t\tni.dcd = TIOCM_CD;\n\t\t}\n\t\tif (mstat & UART_MSR_DSR)\n\t\t\tni.mstat |= TIOCM_DSR;\n\n\t\tni.iflag = ch->ch_c_iflag;\n\t\tni.oflag = ch->ch_c_oflag;\n\t\tni.cflag = ch->ch_c_cflag;\n\t\tni.lflag = ch->ch_c_lflag;\n\n\t\tif (ch->ch_digi.digi_flags & CTSPACE ||\n\t\t    ch->ch_c_cflag & CRTSCTS)\n\t\t\tni.hflow = 1;\n\t\telse\n\t\t\tni.hflow = 0;\n\n\t\tif ((ch->ch_flags & CH_STOPI) ||\n\t\t    (ch->ch_flags & CH_FORCED_STOPI))\n\t\t\tni.recv_stopped = 1;\n\t\telse\n\t\t\tni.recv_stopped = 0;\n\n\t\tif ((ch->ch_flags & CH_STOP) || (ch->ch_flags & CH_FORCED_STOP))\n\t\t\tni.xmit_stopped = 1;\n\t\telse\n\t\t\tni.xmit_stopped = 0;\n\n\t\tni.curtx = ch->ch_txcount;\n\t\tni.currx = ch->ch_rxcount;\n\n\t\tni.baud = ch->ch_old_baud;\n\n\t\tspin_unlock_irqrestore(&ch->ch_lock, flags);\n\n\t\tif (copy_to_user(uarg, &ni, sizeof(ni)))\n\t\t\treturn -EFAULT;\n\n\t\tbreak;\n\t}\n\t}\n\n\treturn 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141956,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int vivid_fb_ioctl(struct fb_info *info, unsigned cmd, unsigned long arg)\n{\n\tstruct vivid_dev *dev = (struct vivid_dev *)info->par;\n\n\tswitch (cmd) {\n \tcase FBIOGET_VBLANK: {\n \t\tstruct fb_vblank vblank;\n \n \t\tvblank.flags = FB_VBLANK_HAVE_COUNT | FB_VBLANK_HAVE_VCOUNT |\n \t\t\tFB_VBLANK_HAVE_VSYNC;\n \t\tvblank.count = 0;\n\t\tvblank.vcount = 0;\n\t\tvblank.hcount = 0;\n\t\tif (copy_to_user((void __user *)arg, &vblank, sizeof(vblank)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\tdefault:\n\t\tdprintk(dev, 1, \"Unknown ioctl %08x\\n\", cmd);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141957,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int vivid_fb_ioctl(struct fb_info *info, unsigned cmd, unsigned long arg)\n{\n\tstruct vivid_dev *dev = (struct vivid_dev *)info->par;\n\n\tswitch (cmd) {\n \tcase FBIOGET_VBLANK: {\n \t\tstruct fb_vblank vblank;\n \n\t\tmemset(&vblank, 0, sizeof(vblank));\n \t\tvblank.flags = FB_VBLANK_HAVE_COUNT | FB_VBLANK_HAVE_VCOUNT |\n \t\t\tFB_VBLANK_HAVE_VSYNC;\n \t\tvblank.count = 0;\n\t\tvblank.vcount = 0;\n\t\tvblank.hcount = 0;\n\t\tif (copy_to_user((void __user *)arg, &vblank, sizeof(vblank)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\tdefault:\n\t\tdprintk(dev, 1, \"Unknown ioctl %08x\\n\", cmd);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141958,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int get_bitmap_file(struct mddev *mddev, void __user * arg)\n{\n\tmdu_bitmap_file_t *file = NULL; /* too big for stack allocation */\n \tchar *ptr;\n \tint err;\n \n\tfile = kmalloc(sizeof(*file), GFP_NOIO);\n \tif (!file)\n \t\treturn -ENOMEM;\n \n\terr = 0;\n\tspin_lock(&mddev->lock);\n\t/* bitmap disabled, zero the first byte and copy out */\n\tif (!mddev->bitmap_info.file)\n\t\tfile->pathname[0] = '\\0';\n\telse if ((ptr = file_path(mddev->bitmap_info.file,\n\t\t\t       file->pathname, sizeof(file->pathname))),\n\t\t IS_ERR(ptr))\n\t\terr = PTR_ERR(ptr);\n\telse\n\t\tmemmove(file->pathname, ptr,\n\t\t\tsizeof(file->pathname)-(ptr-file->pathname));\n\tspin_unlock(&mddev->lock);\n\n\tif (err == 0 &&\n\t    copy_to_user(arg, file, sizeof(*file)))\n\t\terr = -EFAULT;\n\n\tkfree(file);\n\treturn err;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141971,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int get_bitmap_file(struct mddev *mddev, void __user * arg)\n{\n\tmdu_bitmap_file_t *file = NULL; /* too big for stack allocation */\n \tchar *ptr;\n \tint err;\n \n\tfile = kzalloc(sizeof(*file), GFP_NOIO);\n \tif (!file)\n \t\treturn -ENOMEM;\n \n\terr = 0;\n\tspin_lock(&mddev->lock);\n\t/* bitmap disabled, zero the first byte and copy out */\n\tif (!mddev->bitmap_info.file)\n\t\tfile->pathname[0] = '\\0';\n\telse if ((ptr = file_path(mddev->bitmap_info.file,\n\t\t\t       file->pathname, sizeof(file->pathname))),\n\t\t IS_ERR(ptr))\n\t\terr = PTR_ERR(ptr);\n\telse\n\t\tmemmove(file->pathname, ptr,\n\t\t\tsizeof(file->pathname)-(ptr-file->pathname));\n\tspin_unlock(&mddev->lock);\n\n\tif (err == 0 &&\n\t    copy_to_user(arg, file, sizeof(*file)))\n\t\terr = -EFAULT;\n\n\tkfree(file);\n\treturn err;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141972,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "int get_rock_ridge_filename(struct iso_directory_record *de,\n\t\t\t    char *retname, struct inode *inode)\n{\n\tstruct rock_state rs;\n\tstruct rock_ridge *rr;\n\tint sig;\n \tint retnamlen = 0;\n \tint truncate = 0;\n \tint ret = 0;\n \n \tif (!ISOFS_SB(inode->i_sb)->s_rock)\n \t\treturn 0;\n\t*retname = 0;\n\n\tinit_rock_state(&rs, inode);\n\tsetup_rock_ridge(de, inode, &rs);\nrepeat:\n\n\twhile (rs.len > 2) { /* There may be one byte for padding somewhere */\n\t\trr = (struct rock_ridge *)rs.chr;\n\t\t/*\n\t\t * Ignore rock ridge info if rr->len is out of range, but\n\t\t * don't return -EIO because that would make the file\n\t\t * invisible.\n\t\t */\n\t\tif (rr->len < 3)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\t\tsig = isonum_721(rs.chr);\n\t\tif (rock_check_overflow(&rs, sig))\n\t\t\tgoto eio;\n\t\trs.chr += rr->len;\n\t\trs.len -= rr->len;\n\t\t/*\n\t\t * As above, just ignore the rock ridge info if rr->len\n\t\t * is bogus.\n\t\t */\n\t\tif (rs.len < 0)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\n\t\tswitch (sig) {\n\t\tcase SIG('R', 'R'):\n\t\t\tif ((rr->u.RR.flags[0] & RR_NM) == 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('S', 'P'):\n\t\t\tif (check_sp(rr, inode))\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('C', 'E'):\n\t\t\trs.cont_extent = isonum_733(rr->u.CE.extent);\n\t\t\trs.cont_offset = isonum_733(rr->u.CE.offset);\n\t\t\trs.cont_size = isonum_733(rr->u.CE.size);\n\t\t\tbreak;\n\t\tcase SIG('N', 'M'):\n\t\t\tif (truncate)\n\t\t\t\tbreak;\n\t\t\tif (rr->len < 5)\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * If the flags are 2 or 4, this indicates '.' or '..'.\n\t\t\t * We don't want to do anything with this, because it\n\t\t\t * screws up the code that calls us.  We don't really\n\t\t\t * care anyways, since we can just use the non-RR\n\t\t\t * name.\n\t\t\t */\n\t\t\tif (rr->u.NM.flags & 6)\n\t\t\t\tbreak;\n\n\t\t\tif (rr->u.NM.flags & ~1) {\n\t\t\t\tprintk(\"Unsupported NM flag settings (%d)\\n\",\n \t\t\t\t\trr->u.NM.flags);\n \t\t\t\tbreak;\n \t\t\t}\n\t\t\tif ((strlen(retname) + rr->len - 5) >= 254) {\n \t\t\t\ttruncate = 1;\n \t\t\t\tbreak;\n \t\t\t}\n\t\t\tstrncat(retname, rr->u.NM.name, rr->len - 5);\n\t\t\tretnamlen += rr->len - 5;\n \t\t\tbreak;\n \t\tcase SIG('R', 'E'):\n \t\t\tkfree(rs.buffer);\n\t\t\treturn -1;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tret = rock_continue(&rs);\n\tif (ret == 0)\n\t\tgoto repeat;\n\tif (ret == 1)\n\t\treturn retnamlen; /* If 0, this file did not have a NM field */\nout:\n\tkfree(rs.buffer);\n\treturn ret;\neio:\n\tret = -EIO;\n\tgoto out;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142119,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "int get_rock_ridge_filename(struct iso_directory_record *de,\n\t\t\t    char *retname, struct inode *inode)\n{\n\tstruct rock_state rs;\n\tstruct rock_ridge *rr;\n\tint sig;\n \tint retnamlen = 0;\n \tint truncate = 0;\n \tint ret = 0;\n\tchar *p;\n\tint len;\n \n \tif (!ISOFS_SB(inode->i_sb)->s_rock)\n \t\treturn 0;\n\t*retname = 0;\n\n\tinit_rock_state(&rs, inode);\n\tsetup_rock_ridge(de, inode, &rs);\nrepeat:\n\n\twhile (rs.len > 2) { /* There may be one byte for padding somewhere */\n\t\trr = (struct rock_ridge *)rs.chr;\n\t\t/*\n\t\t * Ignore rock ridge info if rr->len is out of range, but\n\t\t * don't return -EIO because that would make the file\n\t\t * invisible.\n\t\t */\n\t\tif (rr->len < 3)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\t\tsig = isonum_721(rs.chr);\n\t\tif (rock_check_overflow(&rs, sig))\n\t\t\tgoto eio;\n\t\trs.chr += rr->len;\n\t\trs.len -= rr->len;\n\t\t/*\n\t\t * As above, just ignore the rock ridge info if rr->len\n\t\t * is bogus.\n\t\t */\n\t\tif (rs.len < 0)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\n\t\tswitch (sig) {\n\t\tcase SIG('R', 'R'):\n\t\t\tif ((rr->u.RR.flags[0] & RR_NM) == 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('S', 'P'):\n\t\t\tif (check_sp(rr, inode))\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('C', 'E'):\n\t\t\trs.cont_extent = isonum_733(rr->u.CE.extent);\n\t\t\trs.cont_offset = isonum_733(rr->u.CE.offset);\n\t\t\trs.cont_size = isonum_733(rr->u.CE.size);\n\t\t\tbreak;\n\t\tcase SIG('N', 'M'):\n\t\t\tif (truncate)\n\t\t\t\tbreak;\n\t\t\tif (rr->len < 5)\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * If the flags are 2 or 4, this indicates '.' or '..'.\n\t\t\t * We don't want to do anything with this, because it\n\t\t\t * screws up the code that calls us.  We don't really\n\t\t\t * care anyways, since we can just use the non-RR\n\t\t\t * name.\n\t\t\t */\n\t\t\tif (rr->u.NM.flags & 6)\n\t\t\t\tbreak;\n\n\t\t\tif (rr->u.NM.flags & ~1) {\n\t\t\t\tprintk(\"Unsupported NM flag settings (%d)\\n\",\n \t\t\t\t\trr->u.NM.flags);\n \t\t\t\tbreak;\n \t\t\t}\n\t\t\tlen = rr->len - 5;\n\t\t\tif (retnamlen + len >= 254) {\n \t\t\t\ttruncate = 1;\n \t\t\t\tbreak;\n \t\t\t}\n\t\t\tp = memchr(rr->u.NM.name, '\\0', len);\n\t\t\tif (unlikely(p))\n\t\t\t\tlen = p - rr->u.NM.name;\n\t\t\tmemcpy(retname + retnamlen, rr->u.NM.name, len);\n\t\t\tretnamlen += len;\n\t\t\tretname[retnamlen] = '\\0';\n \t\t\tbreak;\n \t\tcase SIG('R', 'E'):\n \t\t\tkfree(rs.buffer);\n\t\t\treturn -1;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tret = rock_continue(&rs);\n\tif (ret == 0)\n\t\tgoto repeat;\n\tif (ret == 1)\n\t\treturn retnamlen; /* If 0, this file did not have a NM field */\nout:\n\tkfree(rs.buffer);\n\treturn ret;\neio:\n\tret = -EIO;\n\tgoto out;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142120,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "int x25_negotiate_facilities(struct sk_buff *skb, struct sock *sk,\n\t\tstruct x25_facilities *new, struct x25_dte_facilities *dte)\n{\n\tstruct x25_sock *x25 = x25_sk(sk);\n\tstruct x25_facilities *ours = &x25->facilities;\n\tstruct x25_facilities theirs;\n\tint len;\n \n \tmemset(&theirs, 0, sizeof(theirs));\n \tmemcpy(new, ours, sizeof(*new));\n \n \tlen = x25_parse_facilities(skb, &theirs, dte, &x25->vc_facil_mask);\n \tif (len < 0)\n\t\treturn len;\n\n\t/*\n\t *\tThey want reverse charging, we won't accept it.\n\t */\n\tif ((theirs.reverse & 0x01 ) && (ours->reverse & 0x01)) {\n\t\tSOCK_DEBUG(sk, \"X.25: rejecting reverse charging request\\n\");\n\t\treturn -1;\n\t}\n\n\tnew->reverse = theirs.reverse;\n\n\tif (theirs.throughput) {\n\t\tint theirs_in =  theirs.throughput & 0x0f;\n\t\tint theirs_out = theirs.throughput & 0xf0;\n\t\tint ours_in  = ours->throughput & 0x0f;\n\t\tint ours_out = ours->throughput & 0xf0;\n\t\tif (!ours_in || theirs_in < ours_in) {\n\t\t\tSOCK_DEBUG(sk, \"X.25: inbound throughput negotiated\\n\");\n\t\t\tnew->throughput = (new->throughput & 0xf0) | theirs_in;\n\t\t}\n\t\tif (!ours_out || theirs_out < ours_out) {\n\t\t\tSOCK_DEBUG(sk,\n\t\t\t\t\"X.25: outbound throughput negotiated\\n\");\n\t\t\tnew->throughput = (new->throughput & 0x0f) | theirs_out;\n\t\t}\n\t}\n\n\tif (theirs.pacsize_in && theirs.pacsize_out) {\n\t\tif (theirs.pacsize_in < ours->pacsize_in) {\n\t\t\tSOCK_DEBUG(sk, \"X.25: packet size inwards negotiated down\\n\");\n\t\t\tnew->pacsize_in = theirs.pacsize_in;\n\t\t}\n\t\tif (theirs.pacsize_out < ours->pacsize_out) {\n\t\t\tSOCK_DEBUG(sk, \"X.25: packet size outwards negotiated down\\n\");\n\t\t\tnew->pacsize_out = theirs.pacsize_out;\n\t\t}\n\t}\n\n\tif (theirs.winsize_in && theirs.winsize_out) {\n\t\tif (theirs.winsize_in < ours->winsize_in) {\n\t\t\tSOCK_DEBUG(sk, \"X.25: window size inwards negotiated down\\n\");\n\t\t\tnew->winsize_in = theirs.winsize_in;\n\t\t}\n\t\tif (theirs.winsize_out < ours->winsize_out) {\n\t\t\tSOCK_DEBUG(sk, \"X.25: window size outwards negotiated down\\n\");\n\t\t\tnew->winsize_out = theirs.winsize_out;\n\t\t}\n\t}\n\n\treturn len;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142127,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "int x25_negotiate_facilities(struct sk_buff *skb, struct sock *sk,\n\t\tstruct x25_facilities *new, struct x25_dte_facilities *dte)\n{\n\tstruct x25_sock *x25 = x25_sk(sk);\n\tstruct x25_facilities *ours = &x25->facilities;\n\tstruct x25_facilities theirs;\n\tint len;\n \n \tmemset(&theirs, 0, sizeof(theirs));\n \tmemcpy(new, ours, sizeof(*new));\n\tmemset(dte, 0, sizeof(*dte));\n \n \tlen = x25_parse_facilities(skb, &theirs, dte, &x25->vc_facil_mask);\n \tif (len < 0)\n\t\treturn len;\n\n\t/*\n\t *\tThey want reverse charging, we won't accept it.\n\t */\n\tif ((theirs.reverse & 0x01 ) && (ours->reverse & 0x01)) {\n\t\tSOCK_DEBUG(sk, \"X.25: rejecting reverse charging request\\n\");\n\t\treturn -1;\n\t}\n\n\tnew->reverse = theirs.reverse;\n\n\tif (theirs.throughput) {\n\t\tint theirs_in =  theirs.throughput & 0x0f;\n\t\tint theirs_out = theirs.throughput & 0xf0;\n\t\tint ours_in  = ours->throughput & 0x0f;\n\t\tint ours_out = ours->throughput & 0xf0;\n\t\tif (!ours_in || theirs_in < ours_in) {\n\t\t\tSOCK_DEBUG(sk, \"X.25: inbound throughput negotiated\\n\");\n\t\t\tnew->throughput = (new->throughput & 0xf0) | theirs_in;\n\t\t}\n\t\tif (!ours_out || theirs_out < ours_out) {\n\t\t\tSOCK_DEBUG(sk,\n\t\t\t\t\"X.25: outbound throughput negotiated\\n\");\n\t\t\tnew->throughput = (new->throughput & 0x0f) | theirs_out;\n\t\t}\n\t}\n\n\tif (theirs.pacsize_in && theirs.pacsize_out) {\n\t\tif (theirs.pacsize_in < ours->pacsize_in) {\n\t\t\tSOCK_DEBUG(sk, \"X.25: packet size inwards negotiated down\\n\");\n\t\t\tnew->pacsize_in = theirs.pacsize_in;\n\t\t}\n\t\tif (theirs.pacsize_out < ours->pacsize_out) {\n\t\t\tSOCK_DEBUG(sk, \"X.25: packet size outwards negotiated down\\n\");\n\t\t\tnew->pacsize_out = theirs.pacsize_out;\n\t\t}\n\t}\n\n\tif (theirs.winsize_in && theirs.winsize_out) {\n\t\tif (theirs.winsize_in < ours->winsize_in) {\n\t\t\tSOCK_DEBUG(sk, \"X.25: window size inwards negotiated down\\n\");\n\t\t\tnew->winsize_in = theirs.winsize_in;\n\t\t}\n\t\tif (theirs.winsize_out < ours->winsize_out) {\n\t\t\tSOCK_DEBUG(sk, \"X.25: window size outwards negotiated down\\n\");\n\t\t\tnew->winsize_out = theirs.winsize_out;\n\t\t}\n\t}\n\n\treturn len;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142128,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": " static int proc_connectinfo(struct usb_dev_state *ps, void __user *arg)\n {\n\tstruct usbdevfs_connectinfo ci = {\n\t\t.devnum = ps->dev->devnum,\n\t\t.slow = ps->dev->speed == USB_SPEED_LOW\n\t};\n \n \tif (copy_to_user(arg, &ci, sizeof(ci)))\n \t\treturn -EFAULT;\n\treturn 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142135,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": " static int proc_connectinfo(struct usb_dev_state *ps, void __user *arg)\n {\n\tstruct usbdevfs_connectinfo ci;\n\n\tmemset(&ci, 0, sizeof(ci));\n\tci.devnum = ps->dev->devnum;\n\tci.slow = ps->dev->speed == USB_SPEED_LOW;\n \n \tif (copy_to_user(arg, &ci, sizeof(ci)))\n \t\treturn -EFAULT;\n\treturn 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142136,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int atl2_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct net_device *netdev;\n\tstruct atl2_adapter *adapter;\n\tstatic int cards_found;\n\tunsigned long mmio_start;\n\tint mmio_len;\n\tint err;\n\n\tcards_found = 0;\n\n\terr = pci_enable_device(pdev);\n\tif (err)\n\t\treturn err;\n\n\t/*\n\t * atl2 is a shared-high-32-bit device, so we're stuck with 32-bit DMA\n\t * until the kernel has the proper infrastructure to support 64-bit DMA\n\t * on these devices.\n\t */\n\tif (pci_set_dma_mask(pdev, DMA_BIT_MASK(32)) &&\n\t\tpci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32))) {\n\t\tprintk(KERN_ERR \"atl2: No usable DMA configuration, aborting\\n\");\n\t\tgoto err_dma;\n\t}\n\n\t/* Mark all PCI regions associated with PCI device\n\t * pdev as being reserved by owner atl2_driver_name */\n\terr = pci_request_regions(pdev, atl2_driver_name);\n\tif (err)\n\t\tgoto err_pci_reg;\n\n\t/* Enables bus-mastering on the device and calls\n\t * pcibios_set_master to do the needed arch specific settings */\n\tpci_set_master(pdev);\n\n\terr = -ENOMEM;\n\tnetdev = alloc_etherdev(sizeof(struct atl2_adapter));\n\tif (!netdev)\n\t\tgoto err_alloc_etherdev;\n\n\tSET_NETDEV_DEV(netdev, &pdev->dev);\n\n\tpci_set_drvdata(pdev, netdev);\n\tadapter = netdev_priv(netdev);\n\tadapter->netdev = netdev;\n\tadapter->pdev = pdev;\n\tadapter->hw.back = adapter;\n\n\tmmio_start = pci_resource_start(pdev, 0x0);\n\tmmio_len = pci_resource_len(pdev, 0x0);\n\n\tadapter->hw.mem_rang = (u32)mmio_len;\n\tadapter->hw.hw_addr = ioremap(mmio_start, mmio_len);\n\tif (!adapter->hw.hw_addr) {\n\t\terr = -EIO;\n\t\tgoto err_ioremap;\n\t}\n\n\tatl2_setup_pcicmd(pdev);\n\n\tnetdev->netdev_ops = &atl2_netdev_ops;\n\tnetdev->ethtool_ops = &atl2_ethtool_ops;\n\tnetdev->watchdog_timeo = 5 * HZ;\n\tstrncpy(netdev->name, pci_name(pdev), sizeof(netdev->name) - 1);\n\n\tnetdev->mem_start = mmio_start;\n\tnetdev->mem_end = mmio_start + mmio_len;\n\tadapter->bd_number = cards_found;\n\tadapter->pci_using_64 = false;\n\n\t/* setup the private structure */\n\terr = atl2_sw_init(adapter);\n\tif (err)\n\t\tgoto err_sw_init;\n \n \terr = -EIO;\n \n\tnetdev->hw_features = NETIF_F_SG | NETIF_F_HW_VLAN_CTAG_RX;\n \tnetdev->features |= (NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX);\n \n \t/* Init PHY as early as possible due to power saving issue  */\n\tatl2_phy_init(&adapter->hw);\n\n\t/* reset the controller to\n\t * put the device in a known good starting state */\n\n\tif (atl2_reset_hw(&adapter->hw)) {\n\t\terr = -EIO;\n\t\tgoto err_reset;\n\t}\n\n\t/* copy the MAC address out of the EEPROM */\n\tatl2_read_mac_addr(&adapter->hw);\n\tmemcpy(netdev->dev_addr, adapter->hw.mac_addr, netdev->addr_len);\n\tif (!is_valid_ether_addr(netdev->dev_addr)) {\n\t\terr = -EIO;\n\t\tgoto err_eeprom;\n\t}\n\n\tatl2_check_options(adapter);\n\n\tsetup_timer(&adapter->watchdog_timer, atl2_watchdog,\n\t\t    (unsigned long)adapter);\n\n\tsetup_timer(&adapter->phy_config_timer, atl2_phy_config,\n\t\t    (unsigned long)adapter);\n\n\tINIT_WORK(&adapter->reset_task, atl2_reset_task);\n\tINIT_WORK(&adapter->link_chg_task, atl2_link_chg_task);\n\n\tstrcpy(netdev->name, \"eth%d\"); /* ?? */\n\terr = register_netdev(netdev);\n\tif (err)\n\t\tgoto err_register;\n\n\t/* assume we have no link for now */\n\tnetif_carrier_off(netdev);\n\tnetif_stop_queue(netdev);\n\n\tcards_found++;\n\n\treturn 0;\n\nerr_reset:\nerr_register:\nerr_sw_init:\nerr_eeprom:\n\tiounmap(adapter->hw.hw_addr);\nerr_ioremap:\n\tfree_netdev(netdev);\nerr_alloc_etherdev:\n\tpci_release_regions(pdev);\nerr_pci_reg:\nerr_dma:\n\tpci_disable_device(pdev);\n\treturn err;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142189,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int atl2_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct net_device *netdev;\n\tstruct atl2_adapter *adapter;\n\tstatic int cards_found;\n\tunsigned long mmio_start;\n\tint mmio_len;\n\tint err;\n\n\tcards_found = 0;\n\n\terr = pci_enable_device(pdev);\n\tif (err)\n\t\treturn err;\n\n\t/*\n\t * atl2 is a shared-high-32-bit device, so we're stuck with 32-bit DMA\n\t * until the kernel has the proper infrastructure to support 64-bit DMA\n\t * on these devices.\n\t */\n\tif (pci_set_dma_mask(pdev, DMA_BIT_MASK(32)) &&\n\t\tpci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32))) {\n\t\tprintk(KERN_ERR \"atl2: No usable DMA configuration, aborting\\n\");\n\t\tgoto err_dma;\n\t}\n\n\t/* Mark all PCI regions associated with PCI device\n\t * pdev as being reserved by owner atl2_driver_name */\n\terr = pci_request_regions(pdev, atl2_driver_name);\n\tif (err)\n\t\tgoto err_pci_reg;\n\n\t/* Enables bus-mastering on the device and calls\n\t * pcibios_set_master to do the needed arch specific settings */\n\tpci_set_master(pdev);\n\n\terr = -ENOMEM;\n\tnetdev = alloc_etherdev(sizeof(struct atl2_adapter));\n\tif (!netdev)\n\t\tgoto err_alloc_etherdev;\n\n\tSET_NETDEV_DEV(netdev, &pdev->dev);\n\n\tpci_set_drvdata(pdev, netdev);\n\tadapter = netdev_priv(netdev);\n\tadapter->netdev = netdev;\n\tadapter->pdev = pdev;\n\tadapter->hw.back = adapter;\n\n\tmmio_start = pci_resource_start(pdev, 0x0);\n\tmmio_len = pci_resource_len(pdev, 0x0);\n\n\tadapter->hw.mem_rang = (u32)mmio_len;\n\tadapter->hw.hw_addr = ioremap(mmio_start, mmio_len);\n\tif (!adapter->hw.hw_addr) {\n\t\terr = -EIO;\n\t\tgoto err_ioremap;\n\t}\n\n\tatl2_setup_pcicmd(pdev);\n\n\tnetdev->netdev_ops = &atl2_netdev_ops;\n\tnetdev->ethtool_ops = &atl2_ethtool_ops;\n\tnetdev->watchdog_timeo = 5 * HZ;\n\tstrncpy(netdev->name, pci_name(pdev), sizeof(netdev->name) - 1);\n\n\tnetdev->mem_start = mmio_start;\n\tnetdev->mem_end = mmio_start + mmio_len;\n\tadapter->bd_number = cards_found;\n\tadapter->pci_using_64 = false;\n\n\t/* setup the private structure */\n\terr = atl2_sw_init(adapter);\n\tif (err)\n\t\tgoto err_sw_init;\n \n \terr = -EIO;\n \n\tnetdev->hw_features = NETIF_F_HW_VLAN_CTAG_RX;\n \tnetdev->features |= (NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX);\n \n \t/* Init PHY as early as possible due to power saving issue  */\n\tatl2_phy_init(&adapter->hw);\n\n\t/* reset the controller to\n\t * put the device in a known good starting state */\n\n\tif (atl2_reset_hw(&adapter->hw)) {\n\t\terr = -EIO;\n\t\tgoto err_reset;\n\t}\n\n\t/* copy the MAC address out of the EEPROM */\n\tatl2_read_mac_addr(&adapter->hw);\n\tmemcpy(netdev->dev_addr, adapter->hw.mac_addr, netdev->addr_len);\n\tif (!is_valid_ether_addr(netdev->dev_addr)) {\n\t\terr = -EIO;\n\t\tgoto err_eeprom;\n\t}\n\n\tatl2_check_options(adapter);\n\n\tsetup_timer(&adapter->watchdog_timer, atl2_watchdog,\n\t\t    (unsigned long)adapter);\n\n\tsetup_timer(&adapter->phy_config_timer, atl2_phy_config,\n\t\t    (unsigned long)adapter);\n\n\tINIT_WORK(&adapter->reset_task, atl2_reset_task);\n\tINIT_WORK(&adapter->link_chg_task, atl2_link_chg_task);\n\n\tstrcpy(netdev->name, \"eth%d\"); /* ?? */\n\terr = register_netdev(netdev);\n\tif (err)\n\t\tgoto err_register;\n\n\t/* assume we have no link for now */\n\tnetif_carrier_off(netdev);\n\tnetif_stop_queue(netdev);\n\n\tcards_found++;\n\n\treturn 0;\n\nerr_reset:\nerr_register:\nerr_sw_init:\nerr_eeprom:\n\tiounmap(adapter->hw.hw_addr);\nerr_ioremap:\n\tfree_netdev(netdev);\nerr_alloc_etherdev:\n\tpci_release_regions(pdev);\nerr_pci_reg:\nerr_dma:\n\tpci_disable_device(pdev);\n\treturn err;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142190,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": " static int pagemap_open(struct inode *inode, struct file *file)\n {\n \tpr_warn_once(\"Bits 55-60 of /proc/PID/pagemap entries are about \"\n \t\t\t\"to stop being page-shift some time soon. See the \"\n \t\t\t\"linux/Documentation/vm/pagemap.txt for details.\\n\");\n\treturn 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142197,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": " static int pagemap_open(struct inode *inode, struct file *file)\n {\n\t/* do not disclose physical addresses: attack vector */\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n \tpr_warn_once(\"Bits 55-60 of /proc/PID/pagemap entries are about \"\n \t\t\t\"to stop being page-shift some time soon. See the \"\n \t\t\t\"linux/Documentation/vm/pagemap.txt for details.\\n\");\n\treturn 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142198,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int sched_read_attr(struct sched_attr __user *uattr,\n\t\t\t   struct sched_attr *attr,\n\t\t\t   unsigned int usize)\n{\n\tint ret;\n\n\tif (!access_ok(VERIFY_WRITE, uattr, usize))\n\t\treturn -EFAULT;\n\n\t/*\n\t * If we're handed a smaller struct than we know of,\n\t * ensure all the unknown bits are 0 - i.e. old\n\t * user-space does not get uncomplete information.\n\t */\n\tif (usize < sizeof(*attr)) {\n\t\tunsigned char *addr;\n\t\tunsigned char *end;\n\n\t\taddr = (void *)attr + usize;\n\t\tend  = (void *)attr + sizeof(*attr);\n\n\t\tfor (; addr < end; addr++) {\n\t\t\tif (*addr)\n\t\t\t\tgoto err_size;\n\t\t}\n\n \t\tattr->size = usize;\n \t}\n \n\tret = copy_to_user(uattr, attr, usize);\n \tif (ret)\n \t\treturn -EFAULT;\n \nout:\n\treturn ret;\n\nerr_size:\n\tret = -E2BIG;\n\tgoto out;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142235,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int sched_read_attr(struct sched_attr __user *uattr,\n\t\t\t   struct sched_attr *attr,\n\t\t\t   unsigned int usize)\n{\n\tint ret;\n\n\tif (!access_ok(VERIFY_WRITE, uattr, usize))\n\t\treturn -EFAULT;\n\n\t/*\n\t * If we're handed a smaller struct than we know of,\n\t * ensure all the unknown bits are 0 - i.e. old\n\t * user-space does not get uncomplete information.\n\t */\n\tif (usize < sizeof(*attr)) {\n\t\tunsigned char *addr;\n\t\tunsigned char *end;\n\n\t\taddr = (void *)attr + usize;\n\t\tend  = (void *)attr + sizeof(*attr);\n\n\t\tfor (; addr < end; addr++) {\n\t\t\tif (*addr)\n\t\t\t\tgoto err_size;\n\t\t}\n\n \t\tattr->size = usize;\n \t}\n \n\tret = copy_to_user(uattr, attr, attr->size);\n \tif (ret)\n \t\treturn -EFAULT;\n \nout:\n\treturn ret;\n\nerr_size:\n\tret = -E2BIG;\n\tgoto out;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142236,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int snd_timer_user_tselect(struct file *file,\n\t\t\t\t  struct snd_timer_select __user *_tselect)\n{\n\tstruct snd_timer_user *tu;\n\tstruct snd_timer_select tselect;\n\tchar str[32];\n\tint err = 0;\n\n\ttu = file->private_data;\n\tif (tu->timeri) {\n\t\tsnd_timer_close(tu->timeri);\n\t\ttu->timeri = NULL;\n\t}\n\tif (copy_from_user(&tselect, _tselect, sizeof(tselect))) {\n\t\terr = -EFAULT;\n\t\tgoto __err;\n\t}\n\tsprintf(str, \"application %i\", current->pid);\n\tif (tselect.id.dev_class != SNDRV_TIMER_CLASS_SLAVE)\n\t\ttselect.id.dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION;\n\terr = snd_timer_open(&tu->timeri, str, &tselect.id, current->pid);\n \tif (err < 0)\n \t\tgoto __err;\n \n \tkfree(tu->queue);\n \ttu->queue = NULL;\n \tkfree(tu->tqueue);\n\ttu->tqueue = NULL;\n\tif (tu->tread) {\n\t\ttu->tqueue = kmalloc(tu->queue_size * sizeof(struct snd_timer_tread),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (tu->tqueue == NULL)\n\t\t\terr = -ENOMEM;\n\t} else {\n\t\ttu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),\n\t\t\t\t    GFP_KERNEL);\n\t\tif (tu->queue == NULL)\n\t\t\terr = -ENOMEM;\n\t}\n\n      \tif (err < 0) {\n\t\tsnd_timer_close(tu->timeri);\n      \t\ttu->timeri = NULL;\n      \t} else {\n\t\ttu->timeri->flags |= SNDRV_TIMER_IFLG_FAST;\n\t\ttu->timeri->callback = tu->tread\n\t\t\t? snd_timer_user_tinterrupt : snd_timer_user_interrupt;\n\t\ttu->timeri->ccallback = snd_timer_user_ccallback;\n\t\ttu->timeri->callback_data = (void *)tu;\n\t\ttu->timeri->disconnect = snd_timer_user_disconnect;\n\t}\n\n      __err:\n\treturn err;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142245,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int snd_timer_user_tselect(struct file *file,\n\t\t\t\t  struct snd_timer_select __user *_tselect)\n{\n\tstruct snd_timer_user *tu;\n\tstruct snd_timer_select tselect;\n\tchar str[32];\n\tint err = 0;\n\n\ttu = file->private_data;\n\tif (tu->timeri) {\n\t\tsnd_timer_close(tu->timeri);\n\t\ttu->timeri = NULL;\n\t}\n\tif (copy_from_user(&tselect, _tselect, sizeof(tselect))) {\n\t\terr = -EFAULT;\n\t\tgoto __err;\n\t}\n\tsprintf(str, \"application %i\", current->pid);\n\tif (tselect.id.dev_class != SNDRV_TIMER_CLASS_SLAVE)\n\t\ttselect.id.dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION;\n\terr = snd_timer_open(&tu->timeri, str, &tselect.id, current->pid);\n \tif (err < 0)\n \t\tgoto __err;\n \n\ttu->qhead = tu->qtail = tu->qused = 0;\n \tkfree(tu->queue);\n \ttu->queue = NULL;\n \tkfree(tu->tqueue);\n\ttu->tqueue = NULL;\n\tif (tu->tread) {\n\t\ttu->tqueue = kmalloc(tu->queue_size * sizeof(struct snd_timer_tread),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (tu->tqueue == NULL)\n\t\t\terr = -ENOMEM;\n\t} else {\n\t\ttu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),\n\t\t\t\t    GFP_KERNEL);\n\t\tif (tu->queue == NULL)\n\t\t\terr = -ENOMEM;\n\t}\n\n      \tif (err < 0) {\n\t\tsnd_timer_close(tu->timeri);\n      \t\ttu->timeri = NULL;\n      \t} else {\n\t\ttu->timeri->flags |= SNDRV_TIMER_IFLG_FAST;\n\t\ttu->timeri->callback = tu->tread\n\t\t\t? snd_timer_user_tinterrupt : snd_timer_user_interrupt;\n\t\ttu->timeri->ccallback = snd_timer_user_ccallback;\n\t\ttu->timeri->callback_data = (void *)tu;\n\t\ttu->timeri->disconnect = snd_timer_user_disconnect;\n\t}\n\n      __err:\n\treturn err;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142246,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int walk_hugetlb_range(unsigned long addr, unsigned long end,\n\t\t\t      struct mm_walk *walk)\n{\n\tstruct vm_area_struct *vma = walk->vma;\n\tstruct hstate *h = hstate_vma(vma);\n\tunsigned long next;\n\tunsigned long hmask = huge_page_mask(h);\n\tunsigned long sz = huge_page_size(h);\n\tpte_t *pte;\n\tint err = 0;\n\n \tdo {\n \t\tnext = hugetlb_entry_end(h, addr, end);\n \t\tpte = huge_pte_offset(walk->mm, addr & hmask, sz);\n\t\tif (pte && walk->hugetlb_entry)\n \t\t\terr = walk->hugetlb_entry(pte, hmask, addr, next, walk);\n \t\tif (err)\n \t\t\tbreak;\n \t} while (addr = next, addr != end);\n\n\treturn err;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142271,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int walk_hugetlb_range(unsigned long addr, unsigned long end,\n\t\t\t      struct mm_walk *walk)\n{\n\tstruct vm_area_struct *vma = walk->vma;\n\tstruct hstate *h = hstate_vma(vma);\n\tunsigned long next;\n\tunsigned long hmask = huge_page_mask(h);\n\tunsigned long sz = huge_page_size(h);\n\tpte_t *pte;\n\tint err = 0;\n\n \tdo {\n \t\tnext = hugetlb_entry_end(h, addr, end);\n \t\tpte = huge_pte_offset(walk->mm, addr & hmask, sz);\n\n\t\tif (pte)\n \t\t\terr = walk->hugetlb_entry(pte, hmask, addr, next, walk);\n\t\telse if (walk->pte_hole)\n\t\t\terr = walk->pte_hole(addr, next, walk);\n\n \t\tif (err)\n \t\t\tbreak;\n \t} while (addr = next, addr != end);\n\n\treturn err;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142272,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "int xstateregs_set(struct task_struct *target, const struct user_regset *regset,\n\t\t  unsigned int pos, unsigned int count,\n\t\t  const void *kbuf, const void __user *ubuf)\n{\n\tstruct fpu *fpu = &target->thread.fpu;\n\tstruct xregs_state *xsave;\n\tint ret;\n\n\tif (!boot_cpu_has(X86_FEATURE_XSAVE))\n\t\treturn -ENODEV;\n\n\t/*\n\t * A whole standard-format XSAVE buffer is needed:\n\t */\n\tif ((pos != 0) || (count < fpu_user_xstate_size))\n\t\treturn -EFAULT;\n\n\txsave = &fpu->state.xsave;\n\n\tfpu__activate_fpstate_write(fpu);\n\n\tif (boot_cpu_has(X86_FEATURE_XSAVES)) {\n\t\tif (kbuf)\n\t\t\tret = copy_kernel_to_xstate(xsave, kbuf);\n\t\telse\n \t\t\tret = copy_user_to_xstate(xsave, ubuf);\n \t} else {\n \t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, xsave, 0, -1);\n \t}\n \n \t/*\n\t * In case of failure, mark all states as init:\n\t */\n\tif (ret)\n\t\tfpstate_init(&fpu->state);\n\n\t/*\n\t * mxcsr reserved bits must be masked to zero for security reasons.\n\t */\n\txsave->i387.mxcsr &= mxcsr_feature_mask;\n\txsave->header.xfeatures &= xfeatures_mask;\n\t/*\n\t * These bits must be zero.\n\t */\n\tmemset(&xsave->header.reserved, 0, 48);\n\n\treturn ret;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142303,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "int xstateregs_set(struct task_struct *target, const struct user_regset *regset,\n\t\t  unsigned int pos, unsigned int count,\n\t\t  const void *kbuf, const void __user *ubuf)\n{\n\tstruct fpu *fpu = &target->thread.fpu;\n\tstruct xregs_state *xsave;\n\tint ret;\n\n\tif (!boot_cpu_has(X86_FEATURE_XSAVE))\n\t\treturn -ENODEV;\n\n\t/*\n\t * A whole standard-format XSAVE buffer is needed:\n\t */\n\tif ((pos != 0) || (count < fpu_user_xstate_size))\n\t\treturn -EFAULT;\n\n\txsave = &fpu->state.xsave;\n\n\tfpu__activate_fpstate_write(fpu);\n\n\tif (boot_cpu_has(X86_FEATURE_XSAVES)) {\n\t\tif (kbuf)\n\t\t\tret = copy_kernel_to_xstate(xsave, kbuf);\n\t\telse\n \t\t\tret = copy_user_to_xstate(xsave, ubuf);\n \t} else {\n \t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, xsave, 0, -1);\n\n\t\t/* xcomp_bv must be 0 when using uncompacted format */\n\t\tif (!ret && xsave->header.xcomp_bv)\n\t\t\tret = -EINVAL;\n \t}\n \n \t/*\n\t * In case of failure, mark all states as init:\n\t */\n\tif (ret)\n\t\tfpstate_init(&fpu->state);\n\n\t/*\n\t * mxcsr reserved bits must be masked to zero for security reasons.\n\t */\n\txsave->i387.mxcsr &= mxcsr_feature_mask;\n\txsave->header.xfeatures &= xfeatures_mask;\n\t/*\n\t * These bits must be zero.\n\t */\n\tmemset(&xsave->header.reserved, 0, 48);\n\n\treturn ret;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142304,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int __fpu__restore_sig(void __user *buf, void __user *buf_fx, int size)\n{\n\tint ia32_fxstate = (buf != buf_fx);\n\tstruct task_struct *tsk = current;\n\tstruct fpu *fpu = &tsk->thread.fpu;\n\tint state_size = fpu_kernel_xstate_size;\n\tu64 xfeatures = 0;\n\tint fx_only = 0;\n\n\tia32_fxstate &= (IS_ENABLED(CONFIG_X86_32) ||\n\t\t\t IS_ENABLED(CONFIG_IA32_EMULATION));\n\n\tif (!buf) {\n\t\tfpu__clear(fpu);\n\t\treturn 0;\n\t}\n\n\tif (!access_ok(VERIFY_READ, buf, size))\n\t\treturn -EACCES;\n\n\tfpu__activate_curr(fpu);\n\n\tif (!static_cpu_has(X86_FEATURE_FPU))\n\t\treturn fpregs_soft_set(current, NULL,\n\t\t\t\t       0, sizeof(struct user_i387_ia32_struct),\n\t\t\t\t       NULL, buf) != 0;\n\n\tif (use_xsave()) {\n\t\tstruct _fpx_sw_bytes fx_sw_user;\n\t\tif (unlikely(check_for_xstate(buf_fx, buf_fx, &fx_sw_user))) {\n\t\t\t/*\n\t\t\t * Couldn't find the extended state information in the\n\t\t\t * memory layout. Restore just the FP/SSE and init all\n\t\t\t * the other extended state.\n\t\t\t */\n\t\t\tstate_size = sizeof(struct fxregs_state);\n\t\t\tfx_only = 1;\n\t\t\ttrace_x86_fpu_xstate_check_failed(fpu);\n\t\t} else {\n\t\t\tstate_size = fx_sw_user.xstate_size;\n\t\t\txfeatures = fx_sw_user.xfeatures;\n\t\t}\n\t}\n\n\tif (ia32_fxstate) {\n\t\t/*\n\t\t * For 32-bit frames with fxstate, copy the user state to the\n\t\t * thread's fpu state, reconstruct fxstate from the fsave\n\t\t * header. Sanitize the copied state etc.\n\t\t */\n\t\tstruct fpu *fpu = &tsk->thread.fpu;\n\t\tstruct user_i387_ia32_struct env;\n\t\tint err = 0;\n\n\t\t/*\n\t\t * Drop the current fpu which clears fpu->fpstate_active. This ensures\n\t\t * that any context-switch during the copy of the new state,\n\t\t * avoids the intermediate state from getting restored/saved.\n\t\t * Thus avoiding the new restored state from getting corrupted.\n\t\t * We will be ready to restore/save the state only after\n\t\t * fpu->fpstate_active is again set.\n \t\t */\n \t\tfpu__drop(fpu);\n \n\t\tif (using_compacted_format())\n \t\t\terr = copy_user_to_xstate(&fpu->state.xsave, buf_fx);\n\t\telse\n \t\t\terr = __copy_from_user(&fpu->state.xsave, buf_fx, state_size);\n \n \t\tif (err || __copy_from_user(&env, buf, sizeof(env))) {\n \t\t\tfpstate_init(&fpu->state);\n \t\t\ttrace_x86_fpu_init_state(fpu);\n\t\t\terr = -1;\n\t\t} else {\n\t\t\tsanitize_restored_xstate(tsk, &env, xfeatures, fx_only);\n\t\t}\n\n\t\tfpu->fpstate_active = 1;\n\t\tpreempt_disable();\n\t\tfpu__restore(fpu);\n\t\tpreempt_enable();\n\n\t\treturn err;\n\t} else {\n\t\t/*\n\t\t * For 64-bit frames and 32-bit fsave frames, restore the user\n\t\t * state to the registers directly (with exceptions handled).\n\t\t */\n\t\tuser_fpu_begin();\n\t\tif (copy_user_to_fpregs_zeroing(buf_fx, xfeatures, fx_only)) {\n\t\t\tfpu__clear(fpu);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142305,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int __fpu__restore_sig(void __user *buf, void __user *buf_fx, int size)\n{\n\tint ia32_fxstate = (buf != buf_fx);\n\tstruct task_struct *tsk = current;\n\tstruct fpu *fpu = &tsk->thread.fpu;\n\tint state_size = fpu_kernel_xstate_size;\n\tu64 xfeatures = 0;\n\tint fx_only = 0;\n\n\tia32_fxstate &= (IS_ENABLED(CONFIG_X86_32) ||\n\t\t\t IS_ENABLED(CONFIG_IA32_EMULATION));\n\n\tif (!buf) {\n\t\tfpu__clear(fpu);\n\t\treturn 0;\n\t}\n\n\tif (!access_ok(VERIFY_READ, buf, size))\n\t\treturn -EACCES;\n\n\tfpu__activate_curr(fpu);\n\n\tif (!static_cpu_has(X86_FEATURE_FPU))\n\t\treturn fpregs_soft_set(current, NULL,\n\t\t\t\t       0, sizeof(struct user_i387_ia32_struct),\n\t\t\t\t       NULL, buf) != 0;\n\n\tif (use_xsave()) {\n\t\tstruct _fpx_sw_bytes fx_sw_user;\n\t\tif (unlikely(check_for_xstate(buf_fx, buf_fx, &fx_sw_user))) {\n\t\t\t/*\n\t\t\t * Couldn't find the extended state information in the\n\t\t\t * memory layout. Restore just the FP/SSE and init all\n\t\t\t * the other extended state.\n\t\t\t */\n\t\t\tstate_size = sizeof(struct fxregs_state);\n\t\t\tfx_only = 1;\n\t\t\ttrace_x86_fpu_xstate_check_failed(fpu);\n\t\t} else {\n\t\t\tstate_size = fx_sw_user.xstate_size;\n\t\t\txfeatures = fx_sw_user.xfeatures;\n\t\t}\n\t}\n\n\tif (ia32_fxstate) {\n\t\t/*\n\t\t * For 32-bit frames with fxstate, copy the user state to the\n\t\t * thread's fpu state, reconstruct fxstate from the fsave\n\t\t * header. Sanitize the copied state etc.\n\t\t */\n\t\tstruct fpu *fpu = &tsk->thread.fpu;\n\t\tstruct user_i387_ia32_struct env;\n\t\tint err = 0;\n\n\t\t/*\n\t\t * Drop the current fpu which clears fpu->fpstate_active. This ensures\n\t\t * that any context-switch during the copy of the new state,\n\t\t * avoids the intermediate state from getting restored/saved.\n\t\t * Thus avoiding the new restored state from getting corrupted.\n\t\t * We will be ready to restore/save the state only after\n\t\t * fpu->fpstate_active is again set.\n \t\t */\n \t\tfpu__drop(fpu);\n \n\t\tif (using_compacted_format()) {\n \t\t\terr = copy_user_to_xstate(&fpu->state.xsave, buf_fx);\n\t\t} else {\n \t\t\terr = __copy_from_user(&fpu->state.xsave, buf_fx, state_size);\n \n\t\t\t/* xcomp_bv must be 0 when using uncompacted format */\n\t\t\tif (!err && state_size > offsetof(struct xregs_state, header) && fpu->state.xsave.header.xcomp_bv)\n\t\t\t\terr = -EINVAL;\n\t\t}\n\n \t\tif (err || __copy_from_user(&env, buf, sizeof(env))) {\n \t\t\tfpstate_init(&fpu->state);\n \t\t\ttrace_x86_fpu_init_state(fpu);\n\t\t\terr = -1;\n\t\t} else {\n\t\t\tsanitize_restored_xstate(tsk, &env, xfeatures, fx_only);\n\t\t}\n\n\t\tfpu->fpstate_active = 1;\n\t\tpreempt_disable();\n\t\tfpu__restore(fpu);\n\t\tpreempt_enable();\n\n\t\treturn err;\n\t} else {\n\t\t/*\n\t\t * For 64-bit frames and 32-bit fsave frames, restore the user\n\t\t * state to the registers directly (with exceptions handled).\n\t\t */\n\t\tuser_fpu_begin();\n\t\tif (copy_user_to_fpregs_zeroing(buf_fx, xfeatures, fx_only)) {\n\t\t\tfpu__clear(fpu);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142306,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static Image *ReadGIFImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define BitSet(byte,bit)  (((byte) & (bit)) == (bit))\n#define LSBFirstOrder(x,y)  (((y) << 8) | (x))\n\n  Image\n    *image,\n    *meta_image;\n\n  int\n    number_extensionss=0;\n\n  MagickBooleanType\n    status;\n\n  RectangleInfo\n    page;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    delay,\n    dispose,\n    duration,\n    global_colors,\n    image_count,\n    iterations,\n    one;\n\n  ssize_t\n    count,\n    opacity;\n\n  unsigned char\n    background,\n    c,\n    flag,\n    *global_colormap,\n    buffer[257];\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Determine if this a GIF file.\n  */\n  count=ReadBlob(image,6,buffer);\n  if ((count != 6) || ((LocaleNCompare((char *) buffer,\"GIF87\",5) != 0) &&\n      (LocaleNCompare((char *) buffer,\"GIF89\",5) != 0)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  page.width=ReadBlobLSBShort(image);\n  page.height=ReadBlobLSBShort(image);\n  flag=(unsigned char) ReadBlobByte(image);\n  background=(unsigned char) ReadBlobByte(image);\n  c=(unsigned char) ReadBlobByte(image);  /* reserved */\n  one=1;\n  global_colors=one << (((size_t) flag & 0x07)+1);\n  global_colormap=(unsigned char *) AcquireQuantumMemory((size_t)\n     MagickMax(global_colors,256),3UL*sizeof(*global_colormap));\n   if (global_colormap == (unsigned char *) NULL)\n     ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n   if (BitSet((int) flag,0x80) != 0)\n     {\n       count=ReadBlob(image,(size_t) (3*global_colors),global_colormap);\n      if (count != (ssize_t) (3*global_colors))\n        {\n          global_colormap=(unsigned char *) RelinquishMagickMemory(\n            global_colormap);\n          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n        }\n    }\n  delay=0;\n  dispose=0;\n  duration=0;\n  iterations=1;\n  opacity=(-1);\n  image_count=0;\n  meta_image=AcquireImage(image_info,exception);  /* metadata container */\n  for ( ; ; )\n  {\n    count=ReadBlob(image,1,&c);\n    if (count != 1)\n      break;\n    if (c == (unsigned char) ';')\n      break;  /* terminator */\n    if (c == (unsigned char) '!')\n      {\n        /*\n          GIF Extension block.\n        */\n        count=ReadBlob(image,1,&c);\n        if (count != 1)\n          {\n            global_colormap=(unsigned char *) RelinquishMagickMemory(\n              global_colormap);\n            meta_image=DestroyImage(meta_image);\n            ThrowReaderException(CorruptImageError,\n              \"UnableToReadExtensionBlock\");\n          }\n        switch (c)\n        {\n          case 0xf9:\n          {\n            /*\n              Read graphics control extension.\n            */\n            while (ReadBlobBlock(image,buffer) != 0) ;\n            dispose=(size_t) (buffer[0] >> 2);\n            delay=(size_t) ((buffer[2] << 8) | buffer[1]);\n            if ((ssize_t) (buffer[0] & 0x01) == 0x01)\n              opacity=(ssize_t) buffer[3];\n            break;\n          }\n          case 0xfe:\n          {\n            char\n              *comments;\n\n            size_t\n              length;\n\n            /*\n              Read comment extension.\n            */\n            comments=AcquireString((char *) NULL);\n            for (length=0; ; length+=count)\n            {\n              count=(ssize_t) ReadBlobBlock(image,buffer);\n              if (count == 0)\n                break;\n              buffer[count]='\\0';\n              (void) ConcatenateString(&comments,(const char *) buffer);\n            }\n            (void) SetImageProperty(meta_image,\"comment\",comments,exception);\n            comments=DestroyString(comments);\n            break;\n          }\n          case 0xff:\n          {\n            MagickBooleanType\n              loop;\n\n            /*\n              Read Netscape Loop extension.\n            */\n            loop=MagickFalse;\n            if (ReadBlobBlock(image,buffer) != 0)\n              loop=LocaleNCompare((char *) buffer,\"NETSCAPE2.0\",11) == 0 ?\n                MagickTrue : MagickFalse;\n            if (loop != MagickFalse)\n              {\n                while (ReadBlobBlock(image,buffer) != 0)\n                  iterations=(size_t) ((buffer[2] << 8) | buffer[1]);\n                break;\n              }\n            else\n              {\n                char\n                  name[MagickPathExtent];\n\n                int\n                  block_length,\n                  info_length,\n                  reserved_length;\n\n                MagickBooleanType\n                  i8bim,\n                  icc,\n                  iptc,\n                  magick;\n\n                StringInfo\n                  *profile;\n\n                unsigned char\n                  *info;\n\n                /*\n                  Store GIF application extension as a generic profile.\n                */\n                icc=LocaleNCompare((char *) buffer,\"ICCRGBG1012\",11) == 0 ?\n                  MagickTrue : MagickFalse;\n                magick=LocaleNCompare((char *) buffer,\"ImageMagick\",11) == 0 ?\n                  MagickTrue : MagickFalse;\n                i8bim=LocaleNCompare((char *) buffer,\"MGK8BIM0000\",11) == 0 ?\n                  MagickTrue : MagickFalse;\n                iptc=LocaleNCompare((char *) buffer,\"MGKIPTC0000\",11) == 0 ?\n                  MagickTrue : MagickFalse;\n                number_extensionss++;\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    Reading GIF application extension\");\n                info=(unsigned char *) AcquireQuantumMemory(255UL,\n                  sizeof(*info));\n                if (info == (unsigned char *) NULL)\n                  {\n                    meta_image=DestroyImage(meta_image);\n                    ThrowReaderException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                  }\n                reserved_length=255;\n                for (info_length=0; ; )\n                {\n                  block_length=(int) ReadBlobBlock(image,&info[info_length]);\n                  if (block_length == 0)\n                    break;\n                  info_length+=block_length;\n                  if (info_length > (reserved_length-255))\n                    {\n                      reserved_length+=4096;\n                      info=(unsigned char *) ResizeQuantumMemory(info,(size_t)\n                        reserved_length,sizeof(*info));\n                      if (info == (unsigned char *) NULL)\n                        {\n                          meta_image=DestroyImage(meta_image);\n                          ThrowReaderException(ResourceLimitError,\n                            \"MemoryAllocationFailed\");\n                        }\n                    }\n                }\n                profile=BlobToStringInfo(info,(size_t) info_length);\n                if (profile == (StringInfo *) NULL)\n                  {\n                    meta_image=DestroyImage(meta_image);\n                    ThrowReaderException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                  }\n                if (i8bim != MagickFalse)\n                  (void) CopyMagickString(name,\"8bim\",sizeof(name));\n                else if (icc != MagickFalse)\n                  (void) CopyMagickString(name,\"icc\",sizeof(name));\n                else if (iptc != MagickFalse)\n                  (void) CopyMagickString(name,\"iptc\",sizeof(name));\n                else if (magick != MagickFalse)\n                  {\n                    (void) CopyMagickString(name,\"magick\",sizeof(name));\n                    meta_image->gamma=StringToDouble((char *) info+6,\n                      (char **) NULL);\n                  }\n                else\n                  (void) FormatLocaleString(name,sizeof(name),\"gif:%.11s\",\n                    buffer);\n                info=(unsigned char *) RelinquishMagickMemory(info);\n                if (magick == MagickFalse)\n                  (void) SetImageProfile(meta_image,name,profile,exception);\n                profile=DestroyStringInfo(profile);\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      profile name=%s\",name);\n              }\n            break;\n          }\n          default:\n          {\n            while (ReadBlobBlock(image,buffer) != 0) ;\n            break;\n          }\n        }\n      }\n    if (c != (unsigned char) ',')\n      continue;\n    if (image_count != 0)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            global_colormap=(unsigned char *) RelinquishMagickMemory(\n              global_colormap);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n      }\n    image_count++;\n    /*\n      Read image attributes.\n    */\n    meta_image->scene=image->scene;\n    (void) CloneImageProperties(image,meta_image);\n    DestroyImageProperties(meta_image);\n    (void) CloneImageProfiles(image,meta_image);\n    DestroyImageProfiles(meta_image);\n    image->storage_class=PseudoClass;\n    image->compression=LZWCompression;\n    page.x=(ssize_t) ReadBlobLSBShort(image);\n    page.y=(ssize_t) ReadBlobLSBShort(image);\n    image->columns=ReadBlobLSBShort(image);\n    image->rows=ReadBlobLSBShort(image);\n    image->depth=8;\n    flag=(unsigned char) ReadBlobByte(image);\n    image->interlace=BitSet((int) flag,0x40) != 0 ? GIFInterlace : NoInterlace;\n    image->colors=BitSet((int) flag,0x80) == 0 ? global_colors : one <<\n      ((size_t) (flag & 0x07)+1);\n    if (opacity >= (ssize_t) image->colors)\n      opacity=(-1);\n    image->page.width=page.width;\n    image->page.height=page.height;\n    image->page.y=page.y;\n    image->page.x=page.x;\n    image->delay=delay;\n    image->ticks_per_second=100;\n    image->dispose=(DisposeType) dispose;\n    image->iterations=iterations;\n    image->alpha_trait=opacity >= 0 ? BlendPixelTrait : UndefinedPixelTrait;\n    delay=0;\n    dispose=0;\n    if ((image->columns == 0) || (image->rows == 0))\n      {\n        global_colormap=(unsigned char *) RelinquishMagickMemory(\n          global_colormap);\n        meta_image=DestroyImage(meta_image);\n        ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n      }\n    /*\n      Inititialize colormap.\n    */\n    if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n      {\n        global_colormap=(unsigned char *) RelinquishMagickMemory(\n          global_colormap);\n        meta_image=DestroyImage(meta_image);\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    if (BitSet((int) flag,0x80) == 0)\n      {\n        /*\n          Use global colormap.\n        */\n        p=global_colormap;\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          image->colormap[i].red=(double) ScaleCharToQuantum(*p++);\n          image->colormap[i].green=(double) ScaleCharToQuantum(*p++);\n          image->colormap[i].blue=(double) ScaleCharToQuantum(*p++);\n          if (i == opacity)\n            {\n              image->colormap[i].alpha=(double) TransparentAlpha;\n              image->transparent_color=image->colormap[opacity];\n            }\n        }\n        image->background_color=image->colormap[MagickMin((ssize_t) background,\n          (ssize_t) image->colors-1)];\n      }\n    else\n      {\n        unsigned char\n          *colormap;\n\n        /*\n          Read local colormap.\n        */\n        colormap=(unsigned char *) AcquireQuantumMemory(image->colors,3*\n          sizeof(*colormap));\n        if (colormap == (unsigned char *) NULL)\n          {\n            global_colormap=(unsigned char *) RelinquishMagickMemory(\n              global_colormap);\n            meta_image=DestroyImage(meta_image);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        count=ReadBlob(image,(3*image->colors)*sizeof(*colormap),colormap);\n        if (count != (ssize_t) (3*image->colors))\n          {\n            global_colormap=(unsigned char *) RelinquishMagickMemory(\n              global_colormap);\n            colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n            meta_image=DestroyImage(meta_image);\n            ThrowReaderException(CorruptImageError,\n              \"InsufficientImageDataInFile\");\n          }\n        p=colormap;\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          image->colormap[i].red=(double) ScaleCharToQuantum(*p++);\n          image->colormap[i].green=(double) ScaleCharToQuantum(*p++);\n          image->colormap[i].blue=(double) ScaleCharToQuantum(*p++);\n          if (i == opacity)\n            image->colormap[i].alpha=(double) TransparentAlpha;\n        }\n        colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n      }\n    if (image->gamma == 1.0)\n      {\n        for (i=0; i < (ssize_t) image->colors; i++)\n          if (IsPixelInfoGray(image->colormap+i) == MagickFalse)\n            break;\n        (void) SetImageColorspace(image,i == (ssize_t) image->colors ? \n          GRAYColorspace : RGBColorspace,exception);\n      }\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    /*\n      Decode image.\n    */\n    if (image_info->ping != MagickFalse)\n      status=PingGIFImage(image,exception);\n    else\n      status=DecodeImage(image,opacity,exception);\n    if ((image_info->ping == MagickFalse) && (status == MagickFalse))\n      {\n        global_colormap=(unsigned char *) RelinquishMagickMemory(\n          global_colormap);\n        meta_image=DestroyImage(meta_image);\n        ThrowReaderException(CorruptImageError,\"CorruptImage\");\n      }\n    duration+=image->delay*image->iterations;\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    opacity=(-1);\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) image->scene-\n      1,image->scene);\n    if (status == MagickFalse)\n      break;\n  }\n  image->duration=duration;\n  meta_image=DestroyImage(meta_image);\n  global_colormap=(unsigned char *) RelinquishMagickMemory(global_colormap);\n  if ((image->columns == 0) || (image->rows == 0))\n    ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142309,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static Image *ReadGIFImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define BitSet(byte,bit)  (((byte) & (bit)) == (bit))\n#define LSBFirstOrder(x,y)  (((y) << 8) | (x))\n\n  Image\n    *image,\n    *meta_image;\n\n  int\n    number_extensionss=0;\n\n  MagickBooleanType\n    status;\n\n  RectangleInfo\n    page;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    delay,\n    dispose,\n    duration,\n    global_colors,\n    image_count,\n    iterations,\n    one;\n\n  ssize_t\n    count,\n    opacity;\n\n  unsigned char\n    background,\n    c,\n    flag,\n    *global_colormap,\n    buffer[257];\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Determine if this a GIF file.\n  */\n  count=ReadBlob(image,6,buffer);\n  if ((count != 6) || ((LocaleNCompare((char *) buffer,\"GIF87\",5) != 0) &&\n      (LocaleNCompare((char *) buffer,\"GIF89\",5) != 0)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  page.width=ReadBlobLSBShort(image);\n  page.height=ReadBlobLSBShort(image);\n  flag=(unsigned char) ReadBlobByte(image);\n  background=(unsigned char) ReadBlobByte(image);\n  c=(unsigned char) ReadBlobByte(image);  /* reserved */\n  one=1;\n  global_colors=one << (((size_t) flag & 0x07)+1);\n  global_colormap=(unsigned char *) AcquireQuantumMemory((size_t)\n     MagickMax(global_colors,256),3UL*sizeof(*global_colormap));\n   if (global_colormap == (unsigned char *) NULL)\n     ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(global_colormap,0,3*MagickMax(global_colors,256)*\n    sizeof(*global_colormap));\n   if (BitSet((int) flag,0x80) != 0)\n     {\n       count=ReadBlob(image,(size_t) (3*global_colors),global_colormap);\n      if (count != (ssize_t) (3*global_colors))\n        {\n          global_colormap=(unsigned char *) RelinquishMagickMemory(\n            global_colormap);\n          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n        }\n    }\n  delay=0;\n  dispose=0;\n  duration=0;\n  iterations=1;\n  opacity=(-1);\n  image_count=0;\n  meta_image=AcquireImage(image_info,exception);  /* metadata container */\n  for ( ; ; )\n  {\n    count=ReadBlob(image,1,&c);\n    if (count != 1)\n      break;\n    if (c == (unsigned char) ';')\n      break;  /* terminator */\n    if (c == (unsigned char) '!')\n      {\n        /*\n          GIF Extension block.\n        */\n        count=ReadBlob(image,1,&c);\n        if (count != 1)\n          {\n            global_colormap=(unsigned char *) RelinquishMagickMemory(\n              global_colormap);\n            meta_image=DestroyImage(meta_image);\n            ThrowReaderException(CorruptImageError,\n              \"UnableToReadExtensionBlock\");\n          }\n        switch (c)\n        {\n          case 0xf9:\n          {\n            /*\n              Read graphics control extension.\n            */\n            while (ReadBlobBlock(image,buffer) != 0) ;\n            dispose=(size_t) (buffer[0] >> 2);\n            delay=(size_t) ((buffer[2] << 8) | buffer[1]);\n            if ((ssize_t) (buffer[0] & 0x01) == 0x01)\n              opacity=(ssize_t) buffer[3];\n            break;\n          }\n          case 0xfe:\n          {\n            char\n              *comments;\n\n            size_t\n              length;\n\n            /*\n              Read comment extension.\n            */\n            comments=AcquireString((char *) NULL);\n            for (length=0; ; length+=count)\n            {\n              count=(ssize_t) ReadBlobBlock(image,buffer);\n              if (count == 0)\n                break;\n              buffer[count]='\\0';\n              (void) ConcatenateString(&comments,(const char *) buffer);\n            }\n            (void) SetImageProperty(meta_image,\"comment\",comments,exception);\n            comments=DestroyString(comments);\n            break;\n          }\n          case 0xff:\n          {\n            MagickBooleanType\n              loop;\n\n            /*\n              Read Netscape Loop extension.\n            */\n            loop=MagickFalse;\n            if (ReadBlobBlock(image,buffer) != 0)\n              loop=LocaleNCompare((char *) buffer,\"NETSCAPE2.0\",11) == 0 ?\n                MagickTrue : MagickFalse;\n            if (loop != MagickFalse)\n              {\n                while (ReadBlobBlock(image,buffer) != 0)\n                  iterations=(size_t) ((buffer[2] << 8) | buffer[1]);\n                break;\n              }\n            else\n              {\n                char\n                  name[MagickPathExtent];\n\n                int\n                  block_length,\n                  info_length,\n                  reserved_length;\n\n                MagickBooleanType\n                  i8bim,\n                  icc,\n                  iptc,\n                  magick;\n\n                StringInfo\n                  *profile;\n\n                unsigned char\n                  *info;\n\n                /*\n                  Store GIF application extension as a generic profile.\n                */\n                icc=LocaleNCompare((char *) buffer,\"ICCRGBG1012\",11) == 0 ?\n                  MagickTrue : MagickFalse;\n                magick=LocaleNCompare((char *) buffer,\"ImageMagick\",11) == 0 ?\n                  MagickTrue : MagickFalse;\n                i8bim=LocaleNCompare((char *) buffer,\"MGK8BIM0000\",11) == 0 ?\n                  MagickTrue : MagickFalse;\n                iptc=LocaleNCompare((char *) buffer,\"MGKIPTC0000\",11) == 0 ?\n                  MagickTrue : MagickFalse;\n                number_extensionss++;\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    Reading GIF application extension\");\n                info=(unsigned char *) AcquireQuantumMemory(255UL,\n                  sizeof(*info));\n                if (info == (unsigned char *) NULL)\n                  {\n                    meta_image=DestroyImage(meta_image);\n                    ThrowReaderException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                  }\n                reserved_length=255;\n                for (info_length=0; ; )\n                {\n                  block_length=(int) ReadBlobBlock(image,&info[info_length]);\n                  if (block_length == 0)\n                    break;\n                  info_length+=block_length;\n                  if (info_length > (reserved_length-255))\n                    {\n                      reserved_length+=4096;\n                      info=(unsigned char *) ResizeQuantumMemory(info,(size_t)\n                        reserved_length,sizeof(*info));\n                      if (info == (unsigned char *) NULL)\n                        {\n                          meta_image=DestroyImage(meta_image);\n                          ThrowReaderException(ResourceLimitError,\n                            \"MemoryAllocationFailed\");\n                        }\n                    }\n                }\n                profile=BlobToStringInfo(info,(size_t) info_length);\n                if (profile == (StringInfo *) NULL)\n                  {\n                    meta_image=DestroyImage(meta_image);\n                    ThrowReaderException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                  }\n                if (i8bim != MagickFalse)\n                  (void) CopyMagickString(name,\"8bim\",sizeof(name));\n                else if (icc != MagickFalse)\n                  (void) CopyMagickString(name,\"icc\",sizeof(name));\n                else if (iptc != MagickFalse)\n                  (void) CopyMagickString(name,\"iptc\",sizeof(name));\n                else if (magick != MagickFalse)\n                  {\n                    (void) CopyMagickString(name,\"magick\",sizeof(name));\n                    meta_image->gamma=StringToDouble((char *) info+6,\n                      (char **) NULL);\n                  }\n                else\n                  (void) FormatLocaleString(name,sizeof(name),\"gif:%.11s\",\n                    buffer);\n                info=(unsigned char *) RelinquishMagickMemory(info);\n                if (magick == MagickFalse)\n                  (void) SetImageProfile(meta_image,name,profile,exception);\n                profile=DestroyStringInfo(profile);\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"      profile name=%s\",name);\n              }\n            break;\n          }\n          default:\n          {\n            while (ReadBlobBlock(image,buffer) != 0) ;\n            break;\n          }\n        }\n      }\n    if (c != (unsigned char) ',')\n      continue;\n    if (image_count != 0)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            global_colormap=(unsigned char *) RelinquishMagickMemory(\n              global_colormap);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n      }\n    image_count++;\n    /*\n      Read image attributes.\n    */\n    meta_image->scene=image->scene;\n    (void) CloneImageProperties(image,meta_image);\n    DestroyImageProperties(meta_image);\n    (void) CloneImageProfiles(image,meta_image);\n    DestroyImageProfiles(meta_image);\n    image->storage_class=PseudoClass;\n    image->compression=LZWCompression;\n    page.x=(ssize_t) ReadBlobLSBShort(image);\n    page.y=(ssize_t) ReadBlobLSBShort(image);\n    image->columns=ReadBlobLSBShort(image);\n    image->rows=ReadBlobLSBShort(image);\n    image->depth=8;\n    flag=(unsigned char) ReadBlobByte(image);\n    image->interlace=BitSet((int) flag,0x40) != 0 ? GIFInterlace : NoInterlace;\n    image->colors=BitSet((int) flag,0x80) == 0 ? global_colors : one <<\n      ((size_t) (flag & 0x07)+1);\n    if (opacity >= (ssize_t) image->colors)\n      opacity=(-1);\n    image->page.width=page.width;\n    image->page.height=page.height;\n    image->page.y=page.y;\n    image->page.x=page.x;\n    image->delay=delay;\n    image->ticks_per_second=100;\n    image->dispose=(DisposeType) dispose;\n    image->iterations=iterations;\n    image->alpha_trait=opacity >= 0 ? BlendPixelTrait : UndefinedPixelTrait;\n    delay=0;\n    dispose=0;\n    if ((image->columns == 0) || (image->rows == 0))\n      {\n        global_colormap=(unsigned char *) RelinquishMagickMemory(\n          global_colormap);\n        meta_image=DestroyImage(meta_image);\n        ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n      }\n    /*\n      Inititialize colormap.\n    */\n    if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n      {\n        global_colormap=(unsigned char *) RelinquishMagickMemory(\n          global_colormap);\n        meta_image=DestroyImage(meta_image);\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    if (BitSet((int) flag,0x80) == 0)\n      {\n        /*\n          Use global colormap.\n        */\n        p=global_colormap;\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          image->colormap[i].red=(double) ScaleCharToQuantum(*p++);\n          image->colormap[i].green=(double) ScaleCharToQuantum(*p++);\n          image->colormap[i].blue=(double) ScaleCharToQuantum(*p++);\n          if (i == opacity)\n            {\n              image->colormap[i].alpha=(double) TransparentAlpha;\n              image->transparent_color=image->colormap[opacity];\n            }\n        }\n        image->background_color=image->colormap[MagickMin((ssize_t) background,\n          (ssize_t) image->colors-1)];\n      }\n    else\n      {\n        unsigned char\n          *colormap;\n\n        /*\n          Read local colormap.\n        */\n        colormap=(unsigned char *) AcquireQuantumMemory(image->colors,3*\n          sizeof(*colormap));\n        if (colormap == (unsigned char *) NULL)\n          {\n            global_colormap=(unsigned char *) RelinquishMagickMemory(\n              global_colormap);\n            meta_image=DestroyImage(meta_image);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        count=ReadBlob(image,(3*image->colors)*sizeof(*colormap),colormap);\n        if (count != (ssize_t) (3*image->colors))\n          {\n            global_colormap=(unsigned char *) RelinquishMagickMemory(\n              global_colormap);\n            colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n            meta_image=DestroyImage(meta_image);\n            ThrowReaderException(CorruptImageError,\n              \"InsufficientImageDataInFile\");\n          }\n        p=colormap;\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          image->colormap[i].red=(double) ScaleCharToQuantum(*p++);\n          image->colormap[i].green=(double) ScaleCharToQuantum(*p++);\n          image->colormap[i].blue=(double) ScaleCharToQuantum(*p++);\n          if (i == opacity)\n            image->colormap[i].alpha=(double) TransparentAlpha;\n        }\n        colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n      }\n    if (image->gamma == 1.0)\n      {\n        for (i=0; i < (ssize_t) image->colors; i++)\n          if (IsPixelInfoGray(image->colormap+i) == MagickFalse)\n            break;\n        (void) SetImageColorspace(image,i == (ssize_t) image->colors ? \n          GRAYColorspace : RGBColorspace,exception);\n      }\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    /*\n      Decode image.\n    */\n    if (image_info->ping != MagickFalse)\n      status=PingGIFImage(image,exception);\n    else\n      status=DecodeImage(image,opacity,exception);\n    if ((image_info->ping == MagickFalse) && (status == MagickFalse))\n      {\n        global_colormap=(unsigned char *) RelinquishMagickMemory(\n          global_colormap);\n        meta_image=DestroyImage(meta_image);\n        ThrowReaderException(CorruptImageError,\"CorruptImage\");\n      }\n    duration+=image->delay*image->iterations;\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    opacity=(-1);\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) image->scene-\n      1,image->scene);\n    if (status == MagickFalse)\n      break;\n  }\n  image->duration=duration;\n  meta_image=DestroyImage(meta_image);\n  global_colormap=(unsigned char *) RelinquishMagickMemory(global_colormap);\n  if ((image->columns == 0) || (image->rows == 0))\n    ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142310,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "SYSCALL_DEFINE6(move_pages, pid_t, pid, unsigned long, nr_pages,\n\t\tconst void __user * __user *, pages,\n \t\tconst int __user *, nodes,\n \t\tint __user *, status, int, flags)\n {\n\tconst struct cred *cred = current_cred(), *tcred;\n \tstruct task_struct *task;\n \tstruct mm_struct *mm;\n \tint err;\n\tnodemask_t task_nodes;\n\n\t/* Check flags */\n\tif (flags & ~(MPOL_MF_MOVE|MPOL_MF_MOVE_ALL))\n\t\treturn -EINVAL;\n\n\tif ((flags & MPOL_MF_MOVE_ALL) && !capable(CAP_SYS_NICE))\n\t\treturn -EPERM;\n\n\t/* Find the mm_struct */\n\trcu_read_lock();\n\ttask = pid ? find_task_by_vpid(pid) : current;\n\tif (!task) {\n\t\trcu_read_unlock();\n\t\treturn -ESRCH;\n\t}\n\tget_task_struct(task);\n \n \t/*\n \t * Check if this process has the right to modify the specified\n\t * process. The right exists if the process has administrative\n\t * capabilities, superuser privileges or the same\n\t * userid as the target process.\n \t */\n\ttcred = __task_cred(task);\n\tif (!uid_eq(cred->euid, tcred->suid) && !uid_eq(cred->euid, tcred->uid) &&\n\t    !uid_eq(cred->uid,  tcred->suid) && !uid_eq(cred->uid,  tcred->uid) &&\n\t    !capable(CAP_SYS_NICE)) {\n \t\trcu_read_unlock();\n \t\terr = -EPERM;\n \t\tgoto out;\n\t}\n\trcu_read_unlock();\n\n \terr = security_task_movememory(task);\n \tif (err)\n\t\tgoto out;\n\n\ttask_nodes = cpuset_mems_allowed(task);\n\tmm = get_task_mm(task);\n\tput_task_struct(task);\n\n\tif (!mm)\n\t\treturn -EINVAL;\n\n\tif (nodes)\n\t\terr = do_pages_move(mm, task_nodes, nr_pages, pages,\n\t\t\t\t    nodes, status, flags);\n\telse\n\t\terr = do_pages_stat(mm, nr_pages, pages, status);\n\n\tmmput(mm);\n\treturn err;\n\nout:\n\tput_task_struct(task);\n\treturn err;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142341,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "SYSCALL_DEFINE6(move_pages, pid_t, pid, unsigned long, nr_pages,\n\t\tconst void __user * __user *, pages,\n \t\tconst int __user *, nodes,\n \t\tint __user *, status, int, flags)\n {\n \tstruct task_struct *task;\n \tstruct mm_struct *mm;\n \tint err;\n\tnodemask_t task_nodes;\n\n\t/* Check flags */\n\tif (flags & ~(MPOL_MF_MOVE|MPOL_MF_MOVE_ALL))\n\t\treturn -EINVAL;\n\n\tif ((flags & MPOL_MF_MOVE_ALL) && !capable(CAP_SYS_NICE))\n\t\treturn -EPERM;\n\n\t/* Find the mm_struct */\n\trcu_read_lock();\n\ttask = pid ? find_task_by_vpid(pid) : current;\n\tif (!task) {\n\t\trcu_read_unlock();\n\t\treturn -ESRCH;\n\t}\n\tget_task_struct(task);\n \n \t/*\n \t * Check if this process has the right to modify the specified\n\t * process. Use the regular \"ptrace_may_access()\" checks.\n \t */\n\tif (!ptrace_may_access(task, PTRACE_MODE_READ_REALCREDS)) {\n \t\trcu_read_unlock();\n \t\terr = -EPERM;\n \t\tgoto out;\n\t}\n\trcu_read_unlock();\n\n \terr = security_task_movememory(task);\n \tif (err)\n\t\tgoto out;\n\n\ttask_nodes = cpuset_mems_allowed(task);\n\tmm = get_task_mm(task);\n\tput_task_struct(task);\n\n\tif (!mm)\n\t\treturn -EINVAL;\n\n\tif (nodes)\n\t\terr = do_pages_move(mm, task_nodes, nr_pages, pages,\n\t\t\t\t    nodes, status, flags);\n\telse\n\t\terr = do_pages_stat(mm, nr_pages, pages, status);\n\n\tmmput(mm);\n\treturn err;\n\nout:\n\tput_task_struct(task);\n\treturn err;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142342,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "AcpiNsEvaluate (\n    ACPI_EVALUATE_INFO      *Info)\n{\n    ACPI_STATUS             Status;\n\n\n    ACPI_FUNCTION_TRACE (NsEvaluate);\n\n\n    if (!Info)\n    {\n        return_ACPI_STATUS (AE_BAD_PARAMETER);\n    }\n\n    if (!Info->Node)\n    {\n        /*\n         * Get the actual namespace node for the target object if we\n         * need to. Handles these cases:\n         *\n         * 1) Null node, valid pathname from root (absolute path)\n         * 2) Node and valid pathname (path relative to Node)\n         * 3) Node, Null pathname\n         */\n        Status = AcpiNsGetNode (Info->PrefixNode, Info->RelativePathname,\n            ACPI_NS_NO_UPSEARCH, &Info->Node);\n        if (ACPI_FAILURE (Status))\n        {\n            return_ACPI_STATUS (Status);\n        }\n    }\n\n    /*\n     * For a method alias, we must grab the actual method node so that\n     * proper scoping context will be established before execution.\n     */\n    if (AcpiNsGetType (Info->Node) == ACPI_TYPE_LOCAL_METHOD_ALIAS)\n    {\n        Info->Node = ACPI_CAST_PTR (\n            ACPI_NAMESPACE_NODE, Info->Node->Object);\n    }\n\n    /* Complete the info block initialization */\n\n    Info->ReturnObject = NULL;\n    Info->NodeFlags = Info->Node->Flags;\n    Info->ObjDesc = AcpiNsGetAttachedObject (Info->Node);\n\n    ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, \"%s [%p] Value %p\\n\",\n        Info->RelativePathname, Info->Node,\n        AcpiNsGetAttachedObject (Info->Node)));\n\n    /* Get info if we have a predefined name (_HID, etc.) */\n\n    Info->Predefined = AcpiUtMatchPredefinedMethod (Info->Node->Name.Ascii);\n\n    /* Get the full pathname to the object, for use in warning messages */\n\n    Info->FullPathname = AcpiNsGetNormalizedPathname (Info->Node, TRUE);\n    if (!Info->FullPathname)\n    {\n        return_ACPI_STATUS (AE_NO_MEMORY);\n    }\n\n    /* Count the number of arguments being passed in */\n\n    Info->ParamCount = 0;\n    if (Info->Parameters)\n    {\n        while (Info->Parameters[Info->ParamCount])\n        {\n            Info->ParamCount++;\n        }\n\n        /* Warn on impossible argument count */\n\n        if (Info->ParamCount > ACPI_METHOD_NUM_ARGS)\n        {\n            ACPI_WARN_PREDEFINED ((AE_INFO, Info->FullPathname, ACPI_WARN_ALWAYS,\n                \"Excess arguments (%u) - using only %u\",\n                Info->ParamCount, ACPI_METHOD_NUM_ARGS));\n\n            Info->ParamCount = ACPI_METHOD_NUM_ARGS;\n        }\n    }\n\n    /*\n     * For predefined names: Check that the declared argument count\n     * matches the ACPI spec -- otherwise this is a BIOS error.\n     */\n    AcpiNsCheckAcpiCompliance (Info->FullPathname, Info->Node,\n        Info->Predefined);\n\n    /*\n     * For all names: Check that the incoming argument count for\n     * this method/object matches the actual ASL/AML definition.\n     */\n    AcpiNsCheckArgumentCount (Info->FullPathname, Info->Node,\n        Info->ParamCount, Info->Predefined);\n\n    /* For predefined names: Typecheck all incoming arguments */\n\n    AcpiNsCheckArgumentTypes (Info);\n\n    /*\n     * Three major evaluation cases:\n     *\n     * 1) Object types that cannot be evaluated by definition\n     * 2) The object is a control method -- execute it\n     * 3) The object is not a method -- just return it's current value\n     */\n    switch (AcpiNsGetType (Info->Node))\n    {\n    case ACPI_TYPE_DEVICE:\n    case ACPI_TYPE_EVENT:\n    case ACPI_TYPE_MUTEX:\n    case ACPI_TYPE_REGION:\n    case ACPI_TYPE_THERMAL:\n    case ACPI_TYPE_LOCAL_SCOPE:\n        /*\n         * 1) Disallow evaluation of certain object types. For these,\n         *    object evaluation is undefined and not supported.\n         */\n        ACPI_ERROR ((AE_INFO,\n            \"%s: Evaluation of object type [%s] is not supported\",\n            Info->FullPathname,\n            AcpiUtGetTypeName (Info->Node->Type)));\n\n        Status = AE_TYPE;\n        goto Cleanup;\n\n    case ACPI_TYPE_METHOD:\n        /*\n         * 2) Object is a control method - execute it\n         */\n\n        /* Verify that there is a method object associated with this node */\n\n        if (!Info->ObjDesc)\n        {\n            ACPI_ERROR ((AE_INFO, \"%s: Method has no attached sub-object\",\n                Info->FullPathname));\n            Status = AE_NULL_OBJECT;\n            goto Cleanup;\n        }\n\n        ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,\n            \"**** Execute method [%s] at AML address %p length %X\\n\",\n            Info->FullPathname,\n            Info->ObjDesc->Method.AmlStart + 1,\n            Info->ObjDesc->Method.AmlLength - 1));\n\n        /*\n         * Any namespace deletion must acquire both the namespace and\n         * interpreter locks to ensure that no thread is using the portion of\n         * the namespace that is being deleted.\n         *\n         * Execute the method via the interpreter. The interpreter is locked\n         * here before calling into the AML parser\n         */\n        AcpiExEnterInterpreter ();\n        Status = AcpiPsExecuteMethod (Info);\n        AcpiExExitInterpreter ();\n        break;\n\n    default:\n        /*\n         * 3) All other non-method objects -- get the current object value\n         */\n\n        /*\n         * Some objects require additional resolution steps (e.g., the Node\n         * may be a field that must be read, etc.) -- we can't just grab\n         * the object out of the node.\n         *\n         * Use ResolveNodeToValue() to get the associated value.\n         *\n         * NOTE: we can get away with passing in NULL for a walk state because\n         * the Node is guaranteed to not be a reference to either a method\n         * local or a method argument (because this interface is never called\n         * from a running method.)\n         *\n         * Even though we do not directly invoke the interpreter for object\n         * resolution, we must lock it because we could access an OpRegion.\n         * The OpRegion access code assumes that the interpreter is locked.\n         */\n        AcpiExEnterInterpreter ();\n\n        /* TBD: ResolveNodeToValue has a strange interface, fix */\n\n        Info->ReturnObject = ACPI_CAST_PTR (ACPI_OPERAND_OBJECT, Info->Node);\n\n        Status = AcpiExResolveNodeToValue (ACPI_CAST_INDIRECT_PTR (\n            ACPI_NAMESPACE_NODE, &Info->ReturnObject), NULL);\n        AcpiExExitInterpreter ();\n\n        if (ACPI_FAILURE (Status))\n        {\n            Info->ReturnObject = NULL;\n            goto Cleanup;\n        }\n\n        ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, \"Returned object %p [%s]\\n\",\n            Info->ReturnObject,\n            AcpiUtGetObjectTypeName (Info->ReturnObject)));\n\n        Status = AE_CTRL_RETURN_VALUE; /* Always has a \"return value\" */\n        break;\n    }\n\n    /*\n     * For predefined names, check the return value against the ACPI\n     * specification. Some incorrect return value types are repaired.\n     */\n    (void) AcpiNsCheckReturnValue (Info->Node, Info, Info->ParamCount,\n        Status, &Info->ReturnObject);\n\n    /* Check if there is a return value that must be dealt with */\n\n    if (Status == AE_CTRL_RETURN_VALUE)\n    {\n        /* If caller does not want the return value, delete it */\n\n        if (Info->Flags & ACPI_IGNORE_RETURN_VALUE)\n        {\n            AcpiUtRemoveReference (Info->ReturnObject);\n            Info->ReturnObject = NULL;\n        }\n\n        /* Map AE_CTRL_RETURN_VALUE to AE_OK, we are done with it */\n \n         Status = AE_OK;\n     }\n \n     ACPI_DEBUG_PRINT ((ACPI_DB_NAMES,\n         \"*** Completed evaluation of object %s ***\\n\",\n        Info->RelativePathname));\n\nCleanup:\n    /*\n     * Namespace was unlocked by the handling AcpiNs* function, so we\n     * just free the pathname and return\n     */\n    ACPI_FREE (Info->FullPathname);\n    Info->FullPathname = NULL;\n    return_ACPI_STATUS (Status);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142361,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "AcpiNsEvaluate (\n    ACPI_EVALUATE_INFO      *Info)\n{\n    ACPI_STATUS             Status;\n\n\n    ACPI_FUNCTION_TRACE (NsEvaluate);\n\n\n    if (!Info)\n    {\n        return_ACPI_STATUS (AE_BAD_PARAMETER);\n    }\n\n    if (!Info->Node)\n    {\n        /*\n         * Get the actual namespace node for the target object if we\n         * need to. Handles these cases:\n         *\n         * 1) Null node, valid pathname from root (absolute path)\n         * 2) Node and valid pathname (path relative to Node)\n         * 3) Node, Null pathname\n         */\n        Status = AcpiNsGetNode (Info->PrefixNode, Info->RelativePathname,\n            ACPI_NS_NO_UPSEARCH, &Info->Node);\n        if (ACPI_FAILURE (Status))\n        {\n            return_ACPI_STATUS (Status);\n        }\n    }\n\n    /*\n     * For a method alias, we must grab the actual method node so that\n     * proper scoping context will be established before execution.\n     */\n    if (AcpiNsGetType (Info->Node) == ACPI_TYPE_LOCAL_METHOD_ALIAS)\n    {\n        Info->Node = ACPI_CAST_PTR (\n            ACPI_NAMESPACE_NODE, Info->Node->Object);\n    }\n\n    /* Complete the info block initialization */\n\n    Info->ReturnObject = NULL;\n    Info->NodeFlags = Info->Node->Flags;\n    Info->ObjDesc = AcpiNsGetAttachedObject (Info->Node);\n\n    ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, \"%s [%p] Value %p\\n\",\n        Info->RelativePathname, Info->Node,\n        AcpiNsGetAttachedObject (Info->Node)));\n\n    /* Get info if we have a predefined name (_HID, etc.) */\n\n    Info->Predefined = AcpiUtMatchPredefinedMethod (Info->Node->Name.Ascii);\n\n    /* Get the full pathname to the object, for use in warning messages */\n\n    Info->FullPathname = AcpiNsGetNormalizedPathname (Info->Node, TRUE);\n    if (!Info->FullPathname)\n    {\n        return_ACPI_STATUS (AE_NO_MEMORY);\n    }\n\n    /* Count the number of arguments being passed in */\n\n    Info->ParamCount = 0;\n    if (Info->Parameters)\n    {\n        while (Info->Parameters[Info->ParamCount])\n        {\n            Info->ParamCount++;\n        }\n\n        /* Warn on impossible argument count */\n\n        if (Info->ParamCount > ACPI_METHOD_NUM_ARGS)\n        {\n            ACPI_WARN_PREDEFINED ((AE_INFO, Info->FullPathname, ACPI_WARN_ALWAYS,\n                \"Excess arguments (%u) - using only %u\",\n                Info->ParamCount, ACPI_METHOD_NUM_ARGS));\n\n            Info->ParamCount = ACPI_METHOD_NUM_ARGS;\n        }\n    }\n\n    /*\n     * For predefined names: Check that the declared argument count\n     * matches the ACPI spec -- otherwise this is a BIOS error.\n     */\n    AcpiNsCheckAcpiCompliance (Info->FullPathname, Info->Node,\n        Info->Predefined);\n\n    /*\n     * For all names: Check that the incoming argument count for\n     * this method/object matches the actual ASL/AML definition.\n     */\n    AcpiNsCheckArgumentCount (Info->FullPathname, Info->Node,\n        Info->ParamCount, Info->Predefined);\n\n    /* For predefined names: Typecheck all incoming arguments */\n\n    AcpiNsCheckArgumentTypes (Info);\n\n    /*\n     * Three major evaluation cases:\n     *\n     * 1) Object types that cannot be evaluated by definition\n     * 2) The object is a control method -- execute it\n     * 3) The object is not a method -- just return it's current value\n     */\n    switch (AcpiNsGetType (Info->Node))\n    {\n    case ACPI_TYPE_DEVICE:\n    case ACPI_TYPE_EVENT:\n    case ACPI_TYPE_MUTEX:\n    case ACPI_TYPE_REGION:\n    case ACPI_TYPE_THERMAL:\n    case ACPI_TYPE_LOCAL_SCOPE:\n        /*\n         * 1) Disallow evaluation of certain object types. For these,\n         *    object evaluation is undefined and not supported.\n         */\n        ACPI_ERROR ((AE_INFO,\n            \"%s: Evaluation of object type [%s] is not supported\",\n            Info->FullPathname,\n            AcpiUtGetTypeName (Info->Node->Type)));\n\n        Status = AE_TYPE;\n        goto Cleanup;\n\n    case ACPI_TYPE_METHOD:\n        /*\n         * 2) Object is a control method - execute it\n         */\n\n        /* Verify that there is a method object associated with this node */\n\n        if (!Info->ObjDesc)\n        {\n            ACPI_ERROR ((AE_INFO, \"%s: Method has no attached sub-object\",\n                Info->FullPathname));\n            Status = AE_NULL_OBJECT;\n            goto Cleanup;\n        }\n\n        ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,\n            \"**** Execute method [%s] at AML address %p length %X\\n\",\n            Info->FullPathname,\n            Info->ObjDesc->Method.AmlStart + 1,\n            Info->ObjDesc->Method.AmlLength - 1));\n\n        /*\n         * Any namespace deletion must acquire both the namespace and\n         * interpreter locks to ensure that no thread is using the portion of\n         * the namespace that is being deleted.\n         *\n         * Execute the method via the interpreter. The interpreter is locked\n         * here before calling into the AML parser\n         */\n        AcpiExEnterInterpreter ();\n        Status = AcpiPsExecuteMethod (Info);\n        AcpiExExitInterpreter ();\n        break;\n\n    default:\n        /*\n         * 3) All other non-method objects -- get the current object value\n         */\n\n        /*\n         * Some objects require additional resolution steps (e.g., the Node\n         * may be a field that must be read, etc.) -- we can't just grab\n         * the object out of the node.\n         *\n         * Use ResolveNodeToValue() to get the associated value.\n         *\n         * NOTE: we can get away with passing in NULL for a walk state because\n         * the Node is guaranteed to not be a reference to either a method\n         * local or a method argument (because this interface is never called\n         * from a running method.)\n         *\n         * Even though we do not directly invoke the interpreter for object\n         * resolution, we must lock it because we could access an OpRegion.\n         * The OpRegion access code assumes that the interpreter is locked.\n         */\n        AcpiExEnterInterpreter ();\n\n        /* TBD: ResolveNodeToValue has a strange interface, fix */\n\n        Info->ReturnObject = ACPI_CAST_PTR (ACPI_OPERAND_OBJECT, Info->Node);\n\n        Status = AcpiExResolveNodeToValue (ACPI_CAST_INDIRECT_PTR (\n            ACPI_NAMESPACE_NODE, &Info->ReturnObject), NULL);\n        AcpiExExitInterpreter ();\n\n        if (ACPI_FAILURE (Status))\n        {\n            Info->ReturnObject = NULL;\n            goto Cleanup;\n        }\n\n        ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, \"Returned object %p [%s]\\n\",\n            Info->ReturnObject,\n            AcpiUtGetObjectTypeName (Info->ReturnObject)));\n\n        Status = AE_CTRL_RETURN_VALUE; /* Always has a \"return value\" */\n        break;\n    }\n\n    /*\n     * For predefined names, check the return value against the ACPI\n     * specification. Some incorrect return value types are repaired.\n     */\n    (void) AcpiNsCheckReturnValue (Info->Node, Info, Info->ParamCount,\n        Status, &Info->ReturnObject);\n\n    /* Check if there is a return value that must be dealt with */\n\n    if (Status == AE_CTRL_RETURN_VALUE)\n    {\n        /* If caller does not want the return value, delete it */\n\n        if (Info->Flags & ACPI_IGNORE_RETURN_VALUE)\n        {\n            AcpiUtRemoveReference (Info->ReturnObject);\n            Info->ReturnObject = NULL;\n        }\n\n        /* Map AE_CTRL_RETURN_VALUE to AE_OK, we are done with it */\n \n         Status = AE_OK;\n     }\n    else if (ACPI_FAILURE(Status)) \n    {\n        /* If ReturnObject exists, delete it */\n\n        if (Info->ReturnObject) \n        {\n            AcpiUtRemoveReference (Info->ReturnObject);\n            Info->ReturnObject = NULL;\n        }\n    }\n \n     ACPI_DEBUG_PRINT ((ACPI_DB_NAMES,\n         \"*** Completed evaluation of object %s ***\\n\",\n        Info->RelativePathname));\n\nCleanup:\n    /*\n     * Namespace was unlocked by the handling AcpiNs* function, so we\n     * just free the pathname and return\n     */\n    ACPI_FREE (Info->FullPathname);\n    Info->FullPathname = NULL;\n    return_ACPI_STATUS (Status);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142362,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "AcpiPsCompleteFinalOp (\n    ACPI_WALK_STATE         *WalkState,\n     ACPI_PARSE_OBJECT       *Op,\n     ACPI_STATUS             Status)\n {\n    ACPI_STATUS             Status2;\n \n \n     ACPI_FUNCTION_TRACE_PTR (PsCompleteFinalOp, WalkState);\n\n\n    /*\n     * Complete the last Op (if not completed), and clear the scope stack.\n     * It is easily possible to end an AML \"package\" with an unbounded number\n     * of open scopes (such as when several ASL blocks are closed with\n     * sequential closing braces). We want to terminate each one cleanly.\n     */\n    ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, \"AML package complete at Op %p\\n\", Op));\n    do\n     {\n         if (Op)\n         {\n            if (WalkState->AscendingCallback != NULL)\n             {\n                 WalkState->Op = Op;\n                 WalkState->OpInfo = AcpiPsGetOpcodeInfo (Op->Common.AmlOpcode);\n                WalkState->Opcode = Op->Common.AmlOpcode;\n\n                Status = WalkState->AscendingCallback (WalkState);\n                Status = AcpiPsNextParseState (WalkState, Op, Status);\n                if (Status == AE_CTRL_PENDING)\n                {\n                    Status = AcpiPsCompleteOp (WalkState, &Op, AE_OK);\n                    if (ACPI_FAILURE (Status))\n                    {\n                        return_ACPI_STATUS (Status);\n                    }\n                }\n \n                 if (Status == AE_CTRL_TERMINATE)\n                 {\n                    Status = AE_OK;\n                    /* Clean up */\n                    do\n                    {\n                        if (Op)\n                        {\n                            Status2 = AcpiPsCompleteThisOp (WalkState, Op);\n                            if (ACPI_FAILURE (Status2))\n                            {\n                                return_ACPI_STATUS (Status2);\n                            }\n                        }\n                        AcpiPsPopScope (&(WalkState->ParserState), &Op,\n                            &WalkState->ArgTypes, &WalkState->ArgCount);\n                    } while (Op);\n                    return_ACPI_STATUS (Status);\n                 }\n \n                 else if (ACPI_FAILURE (Status))\n                 {\n                     /* First error is most important */\n \n                    (void) AcpiPsCompleteThisOp (WalkState, Op);\n                    return_ACPI_STATUS (Status);\n                 }\n             }\n \n            Status2 = AcpiPsCompleteThisOp (WalkState, Op);\n            if (ACPI_FAILURE (Status2))\n             {\n                return_ACPI_STATUS (Status2);\n             }\n         }\n \n        AcpiPsPopScope (&(WalkState->ParserState), &Op, &WalkState->ArgTypes,\n            &WalkState->ArgCount);\n \n     } while (Op);\n \n    return_ACPI_STATUS (Status);\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142363,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "AcpiPsCompleteFinalOp (\n    ACPI_WALK_STATE         *WalkState,\n     ACPI_PARSE_OBJECT       *Op,\n     ACPI_STATUS             Status)\n {\n    ACPI_STATUS             ReturnStatus = AE_OK;\n    BOOLEAN                 Ascending = TRUE;\n \n \n     ACPI_FUNCTION_TRACE_PTR (PsCompleteFinalOp, WalkState);\n\n\n    /*\n     * Complete the last Op (if not completed), and clear the scope stack.\n     * It is easily possible to end an AML \"package\" with an unbounded number\n     * of open scopes (such as when several ASL blocks are closed with\n     * sequential closing braces). We want to terminate each one cleanly.\n     */\n    ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, \"AML package complete at Op %p\\n\", Op));\n    do\n     {\n         if (Op)\n         {\n            if (Ascending && WalkState->AscendingCallback != NULL)\n             {\n                 WalkState->Op = Op;\n                 WalkState->OpInfo = AcpiPsGetOpcodeInfo (Op->Common.AmlOpcode);\n                WalkState->Opcode = Op->Common.AmlOpcode;\n\n                Status = WalkState->AscendingCallback (WalkState);\n                Status = AcpiPsNextParseState (WalkState, Op, Status);\n                if (Status == AE_CTRL_PENDING)\n                {\n                    Status = AcpiPsCompleteOp (WalkState, &Op, AE_OK);\n                    if (ACPI_FAILURE (Status))\n                    {\n                        return_ACPI_STATUS (Status);\n                    }\n                }\n \n                 if (Status == AE_CTRL_TERMINATE)\n                 {\n                    Ascending = FALSE;\n                    ReturnStatus = AE_CTRL_TERMINATE;\n                 }\n \n                 else if (ACPI_FAILURE (Status))\n                 {\n                     /* First error is most important */\n \n                    Ascending = FALSE;\n                    ReturnStatus = Status;\n                 }\n             }\n \n            Status = AcpiPsCompleteThisOp (WalkState, Op);\n            if (ACPI_FAILURE (Status))\n             {\n                Ascending = FALSE;\n                if (ACPI_SUCCESS (ReturnStatus) ||\n                    ReturnStatus == AE_CTRL_TERMINATE)\n                {\n                    ReturnStatus = Status;\n                }\n             }\n         }\n \n        AcpiPsPopScope (&(WalkState->ParserState), &Op, &WalkState->ArgTypes,\n            &WalkState->ArgCount);\n \n     } while (Op);\n \n    return_ACPI_STATUS (ReturnStatus);\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142364,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "AcpiDsCreateOperands (\n    ACPI_WALK_STATE         *WalkState,\n    ACPI_PARSE_OBJECT       *FirstArg)\n{\n    ACPI_STATUS             Status = AE_OK;\n    ACPI_PARSE_OBJECT       *Arg;\n     ACPI_PARSE_OBJECT       *Arguments[ACPI_OBJ_NUM_OPERANDS];\n     UINT32                  ArgCount = 0;\n     UINT32                  Index = WalkState->NumOperands;\n     UINT32                  i;\n \n \n    ACPI_FUNCTION_TRACE_PTR (DsCreateOperands, FirstArg);\n\n\n    /* Get all arguments in the list */\n\n    Arg = FirstArg;\n    while (Arg)\n    {\n        if (Index >= ACPI_OBJ_NUM_OPERANDS)\n        {\n            return_ACPI_STATUS (AE_BAD_DATA);\n        }\n\n        Arguments[Index] = Arg;\n        WalkState->Operands [Index] = NULL;\n\n        /* Move on to next argument, if any */\n\n        Arg = Arg->Common.Next;\n        ArgCount++;\n        Index++;\n    }\n\n    ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,\n        \"NumOperands %d, ArgCount %d, Index %d\\n\",\n        WalkState->NumOperands, ArgCount, Index));\n \n     /* Create the interpreter arguments, in reverse order */\n \n     Index--;\n     for (i = 0; i < ArgCount; i++)\n     {\n        Arg = Arguments[Index];\n        WalkState->OperandIndex = (UINT8) Index;\n\n        Status = AcpiDsCreateOperand (WalkState, Arg, Index);\n        if (ACPI_FAILURE (Status))\n        {\n            goto Cleanup;\n        }\n\n        ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,\n            \"Created Arg #%u (%p) %u args total\\n\",\n            Index, Arg, ArgCount));\n        Index--;\n    }\n\n    return_ACPI_STATUS (Status);\n\n\nCleanup:\n    /*\n     * We must undo everything done above; meaning that we must\n      * pop everything off of the operand stack and delete those\n      * objects\n      */\n    AcpiDsObjStackPopAndDelete (ArgCount, WalkState);\n \n     ACPI_EXCEPTION ((AE_INFO, Status, \"While creating Arg %u\", Index));\n     return_ACPI_STATUS (Status);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142365,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "AcpiDsCreateOperands (\n    ACPI_WALK_STATE         *WalkState,\n    ACPI_PARSE_OBJECT       *FirstArg)\n{\n    ACPI_STATUS             Status = AE_OK;\n    ACPI_PARSE_OBJECT       *Arg;\n     ACPI_PARSE_OBJECT       *Arguments[ACPI_OBJ_NUM_OPERANDS];\n     UINT32                  ArgCount = 0;\n     UINT32                  Index = WalkState->NumOperands;\n    UINT32                  PrevNumOperands = WalkState->NumOperands;\n    UINT32                  NewNumOperands;\n     UINT32                  i;\n \n \n    ACPI_FUNCTION_TRACE_PTR (DsCreateOperands, FirstArg);\n\n\n    /* Get all arguments in the list */\n\n    Arg = FirstArg;\n    while (Arg)\n    {\n        if (Index >= ACPI_OBJ_NUM_OPERANDS)\n        {\n            return_ACPI_STATUS (AE_BAD_DATA);\n        }\n\n        Arguments[Index] = Arg;\n        WalkState->Operands [Index] = NULL;\n\n        /* Move on to next argument, if any */\n\n        Arg = Arg->Common.Next;\n        ArgCount++;\n        Index++;\n    }\n\n    ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,\n        \"NumOperands %d, ArgCount %d, Index %d\\n\",\n        WalkState->NumOperands, ArgCount, Index));\n \n     /* Create the interpreter arguments, in reverse order */\n \n    NewNumOperands = Index;\n     Index--;\n     for (i = 0; i < ArgCount; i++)\n     {\n        Arg = Arguments[Index];\n        WalkState->OperandIndex = (UINT8) Index;\n\n        Status = AcpiDsCreateOperand (WalkState, Arg, Index);\n        if (ACPI_FAILURE (Status))\n        {\n            goto Cleanup;\n        }\n\n        ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,\n            \"Created Arg #%u (%p) %u args total\\n\",\n            Index, Arg, ArgCount));\n        Index--;\n    }\n\n    return_ACPI_STATUS (Status);\n\n\nCleanup:\n    /*\n     * We must undo everything done above; meaning that we must\n      * pop everything off of the operand stack and delete those\n      * objects\n      */\n    WalkState->NumOperands = i;\n    AcpiDsObjStackPopAndDelete (NewNumOperands, WalkState);\n\n    /* Restore operand count */\n    WalkState->NumOperands = PrevNumOperands;\n \n     ACPI_EXCEPTION ((AE_INFO, Status, \"While creating Arg %u\", Index));\n     return_ACPI_STATUS (Status);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142366,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  register Quantum *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  image = AcquireImage(image_info,exception);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  clone_info=CloneImageInfo(image_info);\n  if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n      MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\nMATLAB_KO: ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = DecompressBlock(image,MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           (void) ReadBlobXXXLong(image2);\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n            ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n         break;\n      default: ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\n    NEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        image->type=GrayscaleType;\n        SetImageColorspace(image,GRAYColorspace,exception);\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n\n  /* ----- Load raster data ----- */\n     BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n     if (BImgBuff == NULL)\n       ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n \n     MinVal = 0;\n     MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(image,q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\n    quantum_info=DestroyQuantumInfo(quantum_info);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow(image, (double *)BImgBuff, i, MinVal, MaxVal,\n            exception);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow(image,(float *)BImgBuff,i,MinVal,MaxVal,\n            exception);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image,exception);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n    if ((image2!=NULL) && (image2!=image))   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n          }\n        }\n        }\n  }\n\n  RelinquishMagickMemory(BImgBuff);\nEND_OF_READING:\n  clone_info=DestroyImageInfo(clone_info);\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if(image==NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  return (image);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142375,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  register Quantum *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  image = AcquireImage(image_info,exception);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  clone_info=CloneImageInfo(image_info);\n  if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n      MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\nMATLAB_KO: ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = DecompressBlock(image,MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           (void) ReadBlobXXXLong(image2);\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n            ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n         break;\n      default: ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\n    NEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        image->type=GrayscaleType;\n        SetImageColorspace(image,GRAYColorspace,exception);\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n\n  /* ----- Load raster data ----- */\n     BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n     if (BImgBuff == NULL)\n       ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n \n     MinVal = 0;\n     MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(image,q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\n    quantum_info=DestroyQuantumInfo(quantum_info);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow(image, (double *)BImgBuff, i, MinVal, MaxVal,\n            exception);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow(image,(float *)BImgBuff,i,MinVal,MaxVal,\n            exception);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image,exception);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n    if ((image2!=NULL) && (image2!=image))   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n          }\n        }\n        }\n  }\n\n  RelinquishMagickMemory(BImgBuff);\nEND_OF_READING:\n  clone_info=DestroyImageInfo(clone_info);\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if(image==NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  return (image);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142376,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static Image *ReadJPEGImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    value[MaxTextExtent];\n\n  const char\n    *option;\n\n  ErrorManager\n    error_manager;\n\n  Image\n    *image;\n\n  IndexPacket\n    index;\n\n  JSAMPLE\n    *volatile jpeg_pixels;\n\n  JSAMPROW\n    scanline[1];\n\n  MagickBooleanType\n    debug,\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  MemoryInfo\n    *memory_info;\n\n  register ssize_t\n    i;\n\n  struct jpeg_decompress_struct\n    jpeg_info;\n\n  struct jpeg_error_mgr\n    jpeg_error;\n\n  register JSAMPLE\n    *p;\n\n  size_t\n    units;\n\n  ssize_t\n    y;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  debug=IsEventLogging();\n  (void) debug;\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Verify that file size large enough to contain a JPEG datastream.\n  */\n  if (GetBlobSize(image) < 107)\n    ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n  /*\n    Initialize JPEG parameters.\n  */\n  (void) ResetMagickMemory(&error_manager,0,sizeof(error_manager));\n  (void) ResetMagickMemory(&jpeg_info,0,sizeof(jpeg_info));\n  (void) ResetMagickMemory(&jpeg_error,0,sizeof(jpeg_error));\n  jpeg_info.err=jpeg_std_error(&jpeg_error);\n  jpeg_info.err->emit_message=(void (*)(j_common_ptr,int)) JPEGWarningHandler;\n  jpeg_info.err->error_exit=(void (*)(j_common_ptr)) JPEGErrorHandler;\n  memory_info=(MemoryInfo *) NULL;\n  error_manager.image=image;\n  if (setjmp(error_manager.error_recovery) != 0)\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      if (error_manager.profile != (StringInfo *) NULL)\n        error_manager.profile=DestroyStringInfo(error_manager.profile);\n      (void) CloseBlob(image);\n      number_pixels=(MagickSizeType) image->columns*image->rows;\n      if (number_pixels != 0)\n        return(GetFirstImageInList(image));\n      InheritException(exception,&image->exception);\n      return(DestroyImage(image));\n    }\n  jpeg_info.client_data=(void *) &error_manager;\n  jpeg_create_decompress(&jpeg_info);\n  JPEGSourceManager(&jpeg_info,image);\n  jpeg_set_marker_processor(&jpeg_info,JPEG_COM,ReadComment);\n  option=GetImageOption(image_info,\"profile:skip\");\n  if (IsOptionMember(\"ICC\",option) == MagickFalse)\n    jpeg_set_marker_processor(&jpeg_info,ICC_MARKER,ReadICCProfile);\n  if (IsOptionMember(\"IPTC\",option) == MagickFalse)\n    jpeg_set_marker_processor(&jpeg_info,IPTC_MARKER,ReadIPTCProfile);\n  for (i=1; i < 16; i++)\n    if ((i != 2) && (i != 13) && (i != 14))\n      if (IsOptionMember(\"APP\",option) == MagickFalse)\n        jpeg_set_marker_processor(&jpeg_info,(int) (JPEG_APP0+i),ReadProfile);\n  i=(ssize_t) jpeg_read_header(&jpeg_info,TRUE);\n  if ((image_info->colorspace == YCbCrColorspace) ||\n      (image_info->colorspace == Rec601YCbCrColorspace) ||\n      (image_info->colorspace == Rec709YCbCrColorspace))\n    jpeg_info.out_color_space=JCS_YCbCr;\n  /*\n    Set image resolution.\n  */\n  units=0;\n  if ((jpeg_info.saw_JFIF_marker != 0) && (jpeg_info.X_density != 1) &&\n      (jpeg_info.Y_density != 1))\n    {\n      image->x_resolution=(double) jpeg_info.X_density;\n      image->y_resolution=(double) jpeg_info.Y_density;\n      units=(size_t) jpeg_info.density_unit;\n    }\n  if (units == 1)\n    image->units=PixelsPerInchResolution;\n  if (units == 2)\n    image->units=PixelsPerCentimeterResolution;\n  number_pixels=(MagickSizeType) image->columns*image->rows;\n  option=GetImageOption(image_info,\"jpeg:size\");\n  if ((option != (const char *) NULL) &&\n      (jpeg_info.out_color_space != JCS_YCbCr))\n    {\n      double\n        scale_factor;\n\n      GeometryInfo\n        geometry_info;\n\n      MagickStatusType\n        flags;\n\n      /*\n        Scale the image.\n      */\n      flags=ParseGeometry(option,&geometry_info);\n      if ((flags & SigmaValue) == 0)\n        geometry_info.sigma=geometry_info.rho;\n      jpeg_calc_output_dimensions(&jpeg_info);\n      image->magick_columns=jpeg_info.output_width;\n      image->magick_rows=jpeg_info.output_height;\n      scale_factor=1.0;\n      if (geometry_info.rho != 0.0)\n        scale_factor=jpeg_info.output_width/geometry_info.rho;\n      if ((geometry_info.sigma != 0.0) &&\n          (scale_factor > (jpeg_info.output_height/geometry_info.sigma)))\n        scale_factor=jpeg_info.output_height/geometry_info.sigma;\n      jpeg_info.scale_num=1U;\n      jpeg_info.scale_denom=(unsigned int) scale_factor;\n      jpeg_calc_output_dimensions(&jpeg_info);\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Scale factor: %.20g\",(double) scale_factor);\n    }\n#if (JPEG_LIB_VERSION >= 61) && defined(D_PROGRESSIVE_SUPPORTED)\n#if defined(D_LOSSLESS_SUPPORTED)\n  image->interlace=jpeg_info.process == JPROC_PROGRESSIVE ?\n    JPEGInterlace : NoInterlace;\n  image->compression=jpeg_info.process == JPROC_LOSSLESS ?\n    LosslessJPEGCompression : JPEGCompression;\n  if (jpeg_info.data_precision > 8)\n    (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n      \"12-bit JPEG not supported. Reducing pixel data to 8 bits\",\"`%s'\",\n      image->filename);\n  if (jpeg_info.data_precision == 16)\n    jpeg_info.data_precision=12;\n#else\n  image->interlace=jpeg_info.progressive_mode != 0 ? JPEGInterlace :\n    NoInterlace;\n  image->compression=JPEGCompression;\n#endif\n#else\n  image->compression=JPEGCompression;\n  image->interlace=JPEGInterlace;\n#endif\n  option=GetImageOption(image_info,\"jpeg:colors\");\n  if (option != (const char *) NULL)\n    {\n      /*\n        Let the JPEG library quantize for us.\n      */\n      jpeg_info.quantize_colors=TRUE;\n      jpeg_info.desired_number_of_colors=(int) StringToUnsignedLong(option);\n    }\n  option=GetImageOption(image_info,\"jpeg:block-smoothing\");\n  if (option != (const char *) NULL)\n    jpeg_info.do_block_smoothing=IsStringTrue(option) != MagickFalse ? TRUE :\n      FALSE;\n  jpeg_info.dct_method=JDCT_FLOAT;\n  option=GetImageOption(image_info,\"jpeg:dct-method\");\n  if (option != (const char *) NULL)\n    switch (*option)\n    {\n      case 'D':\n      case 'd':\n      {\n        if (LocaleCompare(option,\"default\") == 0)\n          jpeg_info.dct_method=JDCT_DEFAULT;\n        break;\n      }\n      case 'F':\n      case 'f':\n      {\n        if (LocaleCompare(option,\"fastest\") == 0)\n          jpeg_info.dct_method=JDCT_FASTEST;\n        if (LocaleCompare(option,\"float\") == 0)\n          jpeg_info.dct_method=JDCT_FLOAT;\n        break;\n      }\n      case 'I':\n      case 'i':\n      {\n        if (LocaleCompare(option,\"ifast\") == 0)\n          jpeg_info.dct_method=JDCT_IFAST;\n        if (LocaleCompare(option,\"islow\") == 0)\n          jpeg_info.dct_method=JDCT_ISLOW;\n        break;\n      }\n    }\n  option=GetImageOption(image_info,\"jpeg:fancy-upsampling\");\n  if (option != (const char *) NULL)\n    jpeg_info.do_fancy_upsampling=IsStringTrue(option) != MagickFalse ? TRUE :\n      FALSE;\n  (void) jpeg_start_decompress(&jpeg_info);\n  image->columns=jpeg_info.output_width;\n  image->rows=jpeg_info.output_height;\n  image->depth=(size_t) jpeg_info.data_precision;\n  switch (jpeg_info.out_color_space)\n  {\n    case JCS_RGB:\n    default:\n    {\n      (void) SetImageColorspace(image,sRGBColorspace);\n      break;\n    }\n    case JCS_GRAYSCALE:\n    {\n      (void) SetImageColorspace(image,GRAYColorspace);\n      break;\n    }\n    case JCS_YCbCr:\n    {\n      (void) SetImageColorspace(image,YCbCrColorspace);\n      break;\n    }\n    case JCS_CMYK:\n    {\n      (void) SetImageColorspace(image,CMYKColorspace);\n      break;\n    }\n  }\n  if (IsITUFaxImage(image) != MagickFalse)\n    {\n      (void) SetImageColorspace(image,LabColorspace);\n      jpeg_info.out_color_space=JCS_YCbCr;\n    }\n  option=GetImageOption(image_info,\"jpeg:colors\");\n  if (option != (const char *) NULL)\n    if (AcquireImageColormap(image,StringToUnsignedLong(option)) == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n  if ((jpeg_info.output_components == 1) && (jpeg_info.quantize_colors == 0))\n    {\n      size_t\n        colors;\n\n      colors=(size_t) GetQuantumRange(image->depth)+1;\n      if (AcquireImageColormap(image,colors) == MagickFalse)\n        {\n          InheritException(exception,&image->exception);\n          return(DestroyImageList(image));\n        }\n    }\n  if (image->debug != MagickFalse)\n    {\n      if (image->interlace != NoInterlace)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Interlace: progressive\");\n      else\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Interlace: nonprogressive\");\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Data precision: %d\",\n        (int) jpeg_info.data_precision);\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Geometry: %dx%d\",\n        (int) jpeg_info.output_width,(int) jpeg_info.output_height);\n    }\n  JPEGSetImageQuality(&jpeg_info,image);\n  JPEGSetImageSamplingFactor(&jpeg_info,image);\n  (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n    jpeg_info.out_color_space);\n  (void) SetImageProperty(image,\"jpeg:colorspace\",value);\n  if (image_info->ping != MagickFalse)\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  if ((jpeg_info.output_components != 1) &&\n      (jpeg_info.output_components != 3) && (jpeg_info.output_components != 4))\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      ThrowReaderException(CorruptImageError,\"ImageTypeNotSupported\");\n    }\n  memory_info=AcquireVirtualMemory((size_t) image->columns,\n    jpeg_info.output_components*sizeof(*jpeg_pixels));\n  if (memory_info == (MemoryInfo *) NULL)\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n       ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n     }\n   jpeg_pixels=(JSAMPLE *) GetVirtualMemoryBlob(memory_info);\n   /*\n     Convert JPEG pixels to pixel packets.\n   */\n  if (setjmp(error_manager.error_recovery) != 0)\n    {\n      if (memory_info != (MemoryInfo *) NULL)\n        memory_info=RelinquishVirtualMemory(memory_info);\n      jpeg_destroy_decompress(&jpeg_info);\n      (void) CloseBlob(image);\n      number_pixels=(MagickSizeType) image->columns*image->rows;\n      if (number_pixels != 0)\n        return(GetFirstImageInList(image));\n      return(DestroyImage(image));\n    }\n  if (jpeg_info.quantize_colors != 0)\n    {\n      image->colors=(size_t) jpeg_info.actual_number_of_colors;\n      if (jpeg_info.out_color_space == JCS_GRAYSCALE)\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          image->colormap[i].red=ScaleCharToQuantum(jpeg_info.colormap[0][i]);\n          image->colormap[i].green=image->colormap[i].red;\n          image->colormap[i].blue=image->colormap[i].red;\n          image->colormap[i].opacity=OpaqueOpacity;\n        }\n      else\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          image->colormap[i].red=ScaleCharToQuantum(jpeg_info.colormap[0][i]);\n          image->colormap[i].green=ScaleCharToQuantum(jpeg_info.colormap[1][i]);\n          image->colormap[i].blue=ScaleCharToQuantum(jpeg_info.colormap[2][i]);\n          image->colormap[i].opacity=OpaqueOpacity;\n        }\n    }\n  scanline[0]=(JSAMPROW) jpeg_pixels;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register IndexPacket\n      *magick_restrict indexes;\n\n    register ssize_t\n      x;\n\n    register PixelPacket\n      *magick_restrict q;\n\n    if (jpeg_read_scanlines(&jpeg_info,scanline,1) != 1)\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          CorruptImageWarning,\"SkipToSyncByte\",\"`%s'\",image->filename);\n        continue;\n      }\n    p=jpeg_pixels;\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      break;\n    indexes=GetAuthenticIndexQueue(image);\n    if (jpeg_info.data_precision > 8)\n      {\n        unsigned short\n          scale;\n\n        scale=65535/(unsigned short) GetQuantumRange((size_t)\n          jpeg_info.data_precision);\n        if (jpeg_info.output_components == 1)\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            size_t\n              pixel;\n\n            pixel=(size_t) (scale*GETJSAMPLE(*p));\n            index=ConstrainColormapIndex(image,pixel);\n            SetPixelIndex(indexes+x,index);\n            SetPixelRGBO(q,image->colormap+(ssize_t) index);\n            p++;\n            q++;\n          }\n        else\n          if (image->colorspace != CMYKColorspace)\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelRed(q,ScaleShortToQuantum((unsigned short)\n                (scale*GETJSAMPLE(*p++))));\n              SetPixelGreen(q,ScaleShortToQuantum((unsigned short)\n                (scale*GETJSAMPLE(*p++))));\n              SetPixelBlue(q,ScaleShortToQuantum((unsigned short)\n                (scale*GETJSAMPLE(*p++))));\n              SetPixelOpacity(q,OpaqueOpacity);\n              q++;\n            }\n          else\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelCyan(q,QuantumRange-ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))));\n              SetPixelMagenta(q,QuantumRange-ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))));\n              SetPixelYellow(q,QuantumRange-ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))));\n              SetPixelBlack(indexes+x,QuantumRange-ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))));\n              SetPixelOpacity(q,OpaqueOpacity);\n              q++;\n            }\n      }\n    else\n      if (jpeg_info.output_components == 1)\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          index=ConstrainColormapIndex(image,(size_t) GETJSAMPLE(*p));\n          SetPixelIndex(indexes+x,index);\n          SetPixelRGBO(q,image->colormap+(ssize_t) index);\n          p++;\n          q++;\n        }\n      else\n        if (image->colorspace != CMYKColorspace)\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(q,ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)));\n            SetPixelGreen(q,ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)));\n            SetPixelBlue(q,ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)));\n            SetPixelOpacity(q,OpaqueOpacity);\n            q++;\n          }\n        else\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelCyan(q,QuantumRange-ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)));\n            SetPixelMagenta(q,QuantumRange-ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)));\n            SetPixelYellow(q,QuantumRange-ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)));\n            SetPixelBlack(indexes+x,QuantumRange-ScaleCharToQuantum(\n              (unsigned char) GETJSAMPLE(*p++)));\n            SetPixelOpacity(q,OpaqueOpacity);\n            q++;\n          }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      {\n        jpeg_abort_decompress(&jpeg_info);\n        break;\n      }\n  }\n  if (status != MagickFalse)\n    {\n      error_manager.finished=MagickTrue;\n      if (setjmp(error_manager.error_recovery) == 0)\n        (void) jpeg_finish_decompress(&jpeg_info);\n    }\n  /*\n    Free jpeg resources.\n  */\n  jpeg_destroy_decompress(&jpeg_info);\n  memory_info=RelinquishVirtualMemory(memory_info);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142479,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static Image *ReadJPEGImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    value[MaxTextExtent];\n\n  const char\n    *option;\n\n  ErrorManager\n    error_manager;\n\n  Image\n    *image;\n\n  IndexPacket\n    index;\n\n  JSAMPLE\n    *volatile jpeg_pixels;\n\n  JSAMPROW\n    scanline[1];\n\n  MagickBooleanType\n    debug,\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  MemoryInfo\n    *memory_info;\n\n  register ssize_t\n    i;\n\n  struct jpeg_decompress_struct\n    jpeg_info;\n\n  struct jpeg_error_mgr\n    jpeg_error;\n\n  register JSAMPLE\n    *p;\n\n  size_t\n    units;\n\n  ssize_t\n    y;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  debug=IsEventLogging();\n  (void) debug;\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Verify that file size large enough to contain a JPEG datastream.\n  */\n  if (GetBlobSize(image) < 107)\n    ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n  /*\n    Initialize JPEG parameters.\n  */\n  (void) ResetMagickMemory(&error_manager,0,sizeof(error_manager));\n  (void) ResetMagickMemory(&jpeg_info,0,sizeof(jpeg_info));\n  (void) ResetMagickMemory(&jpeg_error,0,sizeof(jpeg_error));\n  jpeg_info.err=jpeg_std_error(&jpeg_error);\n  jpeg_info.err->emit_message=(void (*)(j_common_ptr,int)) JPEGWarningHandler;\n  jpeg_info.err->error_exit=(void (*)(j_common_ptr)) JPEGErrorHandler;\n  memory_info=(MemoryInfo *) NULL;\n  error_manager.image=image;\n  if (setjmp(error_manager.error_recovery) != 0)\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      if (error_manager.profile != (StringInfo *) NULL)\n        error_manager.profile=DestroyStringInfo(error_manager.profile);\n      (void) CloseBlob(image);\n      number_pixels=(MagickSizeType) image->columns*image->rows;\n      if (number_pixels != 0)\n        return(GetFirstImageInList(image));\n      InheritException(exception,&image->exception);\n      return(DestroyImage(image));\n    }\n  jpeg_info.client_data=(void *) &error_manager;\n  jpeg_create_decompress(&jpeg_info);\n  JPEGSourceManager(&jpeg_info,image);\n  jpeg_set_marker_processor(&jpeg_info,JPEG_COM,ReadComment);\n  option=GetImageOption(image_info,\"profile:skip\");\n  if (IsOptionMember(\"ICC\",option) == MagickFalse)\n    jpeg_set_marker_processor(&jpeg_info,ICC_MARKER,ReadICCProfile);\n  if (IsOptionMember(\"IPTC\",option) == MagickFalse)\n    jpeg_set_marker_processor(&jpeg_info,IPTC_MARKER,ReadIPTCProfile);\n  for (i=1; i < 16; i++)\n    if ((i != 2) && (i != 13) && (i != 14))\n      if (IsOptionMember(\"APP\",option) == MagickFalse)\n        jpeg_set_marker_processor(&jpeg_info,(int) (JPEG_APP0+i),ReadProfile);\n  i=(ssize_t) jpeg_read_header(&jpeg_info,TRUE);\n  if ((image_info->colorspace == YCbCrColorspace) ||\n      (image_info->colorspace == Rec601YCbCrColorspace) ||\n      (image_info->colorspace == Rec709YCbCrColorspace))\n    jpeg_info.out_color_space=JCS_YCbCr;\n  /*\n    Set image resolution.\n  */\n  units=0;\n  if ((jpeg_info.saw_JFIF_marker != 0) && (jpeg_info.X_density != 1) &&\n      (jpeg_info.Y_density != 1))\n    {\n      image->x_resolution=(double) jpeg_info.X_density;\n      image->y_resolution=(double) jpeg_info.Y_density;\n      units=(size_t) jpeg_info.density_unit;\n    }\n  if (units == 1)\n    image->units=PixelsPerInchResolution;\n  if (units == 2)\n    image->units=PixelsPerCentimeterResolution;\n  number_pixels=(MagickSizeType) image->columns*image->rows;\n  option=GetImageOption(image_info,\"jpeg:size\");\n  if ((option != (const char *) NULL) &&\n      (jpeg_info.out_color_space != JCS_YCbCr))\n    {\n      double\n        scale_factor;\n\n      GeometryInfo\n        geometry_info;\n\n      MagickStatusType\n        flags;\n\n      /*\n        Scale the image.\n      */\n      flags=ParseGeometry(option,&geometry_info);\n      if ((flags & SigmaValue) == 0)\n        geometry_info.sigma=geometry_info.rho;\n      jpeg_calc_output_dimensions(&jpeg_info);\n      image->magick_columns=jpeg_info.output_width;\n      image->magick_rows=jpeg_info.output_height;\n      scale_factor=1.0;\n      if (geometry_info.rho != 0.0)\n        scale_factor=jpeg_info.output_width/geometry_info.rho;\n      if ((geometry_info.sigma != 0.0) &&\n          (scale_factor > (jpeg_info.output_height/geometry_info.sigma)))\n        scale_factor=jpeg_info.output_height/geometry_info.sigma;\n      jpeg_info.scale_num=1U;\n      jpeg_info.scale_denom=(unsigned int) scale_factor;\n      jpeg_calc_output_dimensions(&jpeg_info);\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Scale factor: %.20g\",(double) scale_factor);\n    }\n#if (JPEG_LIB_VERSION >= 61) && defined(D_PROGRESSIVE_SUPPORTED)\n#if defined(D_LOSSLESS_SUPPORTED)\n  image->interlace=jpeg_info.process == JPROC_PROGRESSIVE ?\n    JPEGInterlace : NoInterlace;\n  image->compression=jpeg_info.process == JPROC_LOSSLESS ?\n    LosslessJPEGCompression : JPEGCompression;\n  if (jpeg_info.data_precision > 8)\n    (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n      \"12-bit JPEG not supported. Reducing pixel data to 8 bits\",\"`%s'\",\n      image->filename);\n  if (jpeg_info.data_precision == 16)\n    jpeg_info.data_precision=12;\n#else\n  image->interlace=jpeg_info.progressive_mode != 0 ? JPEGInterlace :\n    NoInterlace;\n  image->compression=JPEGCompression;\n#endif\n#else\n  image->compression=JPEGCompression;\n  image->interlace=JPEGInterlace;\n#endif\n  option=GetImageOption(image_info,\"jpeg:colors\");\n  if (option != (const char *) NULL)\n    {\n      /*\n        Let the JPEG library quantize for us.\n      */\n      jpeg_info.quantize_colors=TRUE;\n      jpeg_info.desired_number_of_colors=(int) StringToUnsignedLong(option);\n    }\n  option=GetImageOption(image_info,\"jpeg:block-smoothing\");\n  if (option != (const char *) NULL)\n    jpeg_info.do_block_smoothing=IsStringTrue(option) != MagickFalse ? TRUE :\n      FALSE;\n  jpeg_info.dct_method=JDCT_FLOAT;\n  option=GetImageOption(image_info,\"jpeg:dct-method\");\n  if (option != (const char *) NULL)\n    switch (*option)\n    {\n      case 'D':\n      case 'd':\n      {\n        if (LocaleCompare(option,\"default\") == 0)\n          jpeg_info.dct_method=JDCT_DEFAULT;\n        break;\n      }\n      case 'F':\n      case 'f':\n      {\n        if (LocaleCompare(option,\"fastest\") == 0)\n          jpeg_info.dct_method=JDCT_FASTEST;\n        if (LocaleCompare(option,\"float\") == 0)\n          jpeg_info.dct_method=JDCT_FLOAT;\n        break;\n      }\n      case 'I':\n      case 'i':\n      {\n        if (LocaleCompare(option,\"ifast\") == 0)\n          jpeg_info.dct_method=JDCT_IFAST;\n        if (LocaleCompare(option,\"islow\") == 0)\n          jpeg_info.dct_method=JDCT_ISLOW;\n        break;\n      }\n    }\n  option=GetImageOption(image_info,\"jpeg:fancy-upsampling\");\n  if (option != (const char *) NULL)\n    jpeg_info.do_fancy_upsampling=IsStringTrue(option) != MagickFalse ? TRUE :\n      FALSE;\n  (void) jpeg_start_decompress(&jpeg_info);\n  image->columns=jpeg_info.output_width;\n  image->rows=jpeg_info.output_height;\n  image->depth=(size_t) jpeg_info.data_precision;\n  switch (jpeg_info.out_color_space)\n  {\n    case JCS_RGB:\n    default:\n    {\n      (void) SetImageColorspace(image,sRGBColorspace);\n      break;\n    }\n    case JCS_GRAYSCALE:\n    {\n      (void) SetImageColorspace(image,GRAYColorspace);\n      break;\n    }\n    case JCS_YCbCr:\n    {\n      (void) SetImageColorspace(image,YCbCrColorspace);\n      break;\n    }\n    case JCS_CMYK:\n    {\n      (void) SetImageColorspace(image,CMYKColorspace);\n      break;\n    }\n  }\n  if (IsITUFaxImage(image) != MagickFalse)\n    {\n      (void) SetImageColorspace(image,LabColorspace);\n      jpeg_info.out_color_space=JCS_YCbCr;\n    }\n  option=GetImageOption(image_info,\"jpeg:colors\");\n  if (option != (const char *) NULL)\n    if (AcquireImageColormap(image,StringToUnsignedLong(option)) == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n  if ((jpeg_info.output_components == 1) && (jpeg_info.quantize_colors == 0))\n    {\n      size_t\n        colors;\n\n      colors=(size_t) GetQuantumRange(image->depth)+1;\n      if (AcquireImageColormap(image,colors) == MagickFalse)\n        {\n          InheritException(exception,&image->exception);\n          return(DestroyImageList(image));\n        }\n    }\n  if (image->debug != MagickFalse)\n    {\n      if (image->interlace != NoInterlace)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Interlace: progressive\");\n      else\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Interlace: nonprogressive\");\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Data precision: %d\",\n        (int) jpeg_info.data_precision);\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Geometry: %dx%d\",\n        (int) jpeg_info.output_width,(int) jpeg_info.output_height);\n    }\n  JPEGSetImageQuality(&jpeg_info,image);\n  JPEGSetImageSamplingFactor(&jpeg_info,image);\n  (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n    jpeg_info.out_color_space);\n  (void) SetImageProperty(image,\"jpeg:colorspace\",value);\n  if (image_info->ping != MagickFalse)\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  if ((jpeg_info.output_components != 1) &&\n      (jpeg_info.output_components != 3) && (jpeg_info.output_components != 4))\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      ThrowReaderException(CorruptImageError,\"ImageTypeNotSupported\");\n    }\n  memory_info=AcquireVirtualMemory((size_t) image->columns,\n    jpeg_info.output_components*sizeof(*jpeg_pixels));\n  if (memory_info == (MemoryInfo *) NULL)\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n       ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n     }\n   jpeg_pixels=(JSAMPLE *) GetVirtualMemoryBlob(memory_info);\n  (void) ResetMagickMemory(jpeg_pixels,0,image->columns* \n    jpeg_info.output_components*sizeof(*jpeg_pixels));\n   /*\n     Convert JPEG pixels to pixel packets.\n   */\n  if (setjmp(error_manager.error_recovery) != 0)\n    {\n      if (memory_info != (MemoryInfo *) NULL)\n        memory_info=RelinquishVirtualMemory(memory_info);\n      jpeg_destroy_decompress(&jpeg_info);\n      (void) CloseBlob(image);\n      number_pixels=(MagickSizeType) image->columns*image->rows;\n      if (number_pixels != 0)\n        return(GetFirstImageInList(image));\n      return(DestroyImage(image));\n    }\n  if (jpeg_info.quantize_colors != 0)\n    {\n      image->colors=(size_t) jpeg_info.actual_number_of_colors;\n      if (jpeg_info.out_color_space == JCS_GRAYSCALE)\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          image->colormap[i].red=ScaleCharToQuantum(jpeg_info.colormap[0][i]);\n          image->colormap[i].green=image->colormap[i].red;\n          image->colormap[i].blue=image->colormap[i].red;\n          image->colormap[i].opacity=OpaqueOpacity;\n        }\n      else\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          image->colormap[i].red=ScaleCharToQuantum(jpeg_info.colormap[0][i]);\n          image->colormap[i].green=ScaleCharToQuantum(jpeg_info.colormap[1][i]);\n          image->colormap[i].blue=ScaleCharToQuantum(jpeg_info.colormap[2][i]);\n          image->colormap[i].opacity=OpaqueOpacity;\n        }\n    }\n  scanline[0]=(JSAMPROW) jpeg_pixels;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register IndexPacket\n      *magick_restrict indexes;\n\n    register ssize_t\n      x;\n\n    register PixelPacket\n      *magick_restrict q;\n\n    if (jpeg_read_scanlines(&jpeg_info,scanline,1) != 1)\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          CorruptImageWarning,\"SkipToSyncByte\",\"`%s'\",image->filename);\n        continue;\n      }\n    p=jpeg_pixels;\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      break;\n    indexes=GetAuthenticIndexQueue(image);\n    if (jpeg_info.data_precision > 8)\n      {\n        unsigned short\n          scale;\n\n        scale=65535/(unsigned short) GetQuantumRange((size_t)\n          jpeg_info.data_precision);\n        if (jpeg_info.output_components == 1)\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            size_t\n              pixel;\n\n            pixel=(size_t) (scale*GETJSAMPLE(*p));\n            index=ConstrainColormapIndex(image,pixel);\n            SetPixelIndex(indexes+x,index);\n            SetPixelRGBO(q,image->colormap+(ssize_t) index);\n            p++;\n            q++;\n          }\n        else\n          if (image->colorspace != CMYKColorspace)\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelRed(q,ScaleShortToQuantum((unsigned short)\n                (scale*GETJSAMPLE(*p++))));\n              SetPixelGreen(q,ScaleShortToQuantum((unsigned short)\n                (scale*GETJSAMPLE(*p++))));\n              SetPixelBlue(q,ScaleShortToQuantum((unsigned short)\n                (scale*GETJSAMPLE(*p++))));\n              SetPixelOpacity(q,OpaqueOpacity);\n              q++;\n            }\n          else\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelCyan(q,QuantumRange-ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))));\n              SetPixelMagenta(q,QuantumRange-ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))));\n              SetPixelYellow(q,QuantumRange-ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))));\n              SetPixelBlack(indexes+x,QuantumRange-ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))));\n              SetPixelOpacity(q,OpaqueOpacity);\n              q++;\n            }\n      }\n    else\n      if (jpeg_info.output_components == 1)\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          index=ConstrainColormapIndex(image,(size_t) GETJSAMPLE(*p));\n          SetPixelIndex(indexes+x,index);\n          SetPixelRGBO(q,image->colormap+(ssize_t) index);\n          p++;\n          q++;\n        }\n      else\n        if (image->colorspace != CMYKColorspace)\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(q,ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)));\n            SetPixelGreen(q,ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)));\n            SetPixelBlue(q,ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)));\n            SetPixelOpacity(q,OpaqueOpacity);\n            q++;\n          }\n        else\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelCyan(q,QuantumRange-ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)));\n            SetPixelMagenta(q,QuantumRange-ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)));\n            SetPixelYellow(q,QuantumRange-ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)));\n            SetPixelBlack(indexes+x,QuantumRange-ScaleCharToQuantum(\n              (unsigned char) GETJSAMPLE(*p++)));\n            SetPixelOpacity(q,OpaqueOpacity);\n            q++;\n          }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      {\n        jpeg_abort_decompress(&jpeg_info);\n        break;\n      }\n  }\n  if (status != MagickFalse)\n    {\n      error_manager.finished=MagickTrue;\n      if (setjmp(error_manager.error_recovery) == 0)\n        (void) jpeg_finish_decompress(&jpeg_info);\n    }\n  /*\n    Free jpeg resources.\n  */\n  jpeg_destroy_decompress(&jpeg_info);\n  memory_info=RelinquishVirtualMemory(memory_info);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142480,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": " static void make_response(struct xen_blkif_ring *ring, u64 id,\n \t\t\t  unsigned short op, int st)\n {\n\tstruct blkif_response  resp;\n \tunsigned long     flags;\n \tunion blkif_back_rings *blk_rings;\n \tint notify;\n \n\tresp.id        = id;\n\tresp.operation = op;\n\tresp.status    = st;\n \tspin_lock_irqsave(&ring->blk_ring_lock, flags);\n \tblk_rings = &ring->blk_rings;\n \t/* Place on the response ring for the relevant domain. */\n \tswitch (ring->blkif->blk_protocol) {\n \tcase BLKIF_PROTOCOL_NATIVE:\n\t\tmemcpy(RING_GET_RESPONSE(&blk_rings->native, blk_rings->native.rsp_prod_pvt),\n\t\t       &resp, sizeof(resp));\n \t\tbreak;\n \tcase BLKIF_PROTOCOL_X86_32:\n\t\tmemcpy(RING_GET_RESPONSE(&blk_rings->x86_32, blk_rings->x86_32.rsp_prod_pvt),\n\t\t       &resp, sizeof(resp));\n \t\tbreak;\n \tcase BLKIF_PROTOCOL_X86_64:\n\t\tmemcpy(RING_GET_RESPONSE(&blk_rings->x86_64, blk_rings->x86_64.rsp_prod_pvt),\n\t\t       &resp, sizeof(resp));\n \t\tbreak;\n \tdefault:\n \t\tBUG();\n \t}\n \tblk_rings->common.rsp_prod_pvt++;\n \tRING_PUSH_RESPONSES_AND_CHECK_NOTIFY(&blk_rings->common, notify);\n \tspin_unlock_irqrestore(&ring->blk_ring_lock, flags);\n\tif (notify)\n\t\tnotify_remote_via_irq(ring->irq);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142493,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": " static void make_response(struct xen_blkif_ring *ring, u64 id,\n \t\t\t  unsigned short op, int st)\n {\n\tstruct blkif_response *resp;\n \tunsigned long     flags;\n \tunion blkif_back_rings *blk_rings;\n \tint notify;\n \n \tspin_lock_irqsave(&ring->blk_ring_lock, flags);\n \tblk_rings = &ring->blk_rings;\n \t/* Place on the response ring for the relevant domain. */\n \tswitch (ring->blkif->blk_protocol) {\n \tcase BLKIF_PROTOCOL_NATIVE:\n\t\tresp = RING_GET_RESPONSE(&blk_rings->native,\n\t\t\t\t\t blk_rings->native.rsp_prod_pvt);\n \t\tbreak;\n \tcase BLKIF_PROTOCOL_X86_32:\n\t\tresp = RING_GET_RESPONSE(&blk_rings->x86_32,\n\t\t\t\t\t blk_rings->x86_32.rsp_prod_pvt);\n \t\tbreak;\n \tcase BLKIF_PROTOCOL_X86_64:\n\t\tresp = RING_GET_RESPONSE(&blk_rings->x86_64,\n\t\t\t\t\t blk_rings->x86_64.rsp_prod_pvt);\n \t\tbreak;\n \tdefault:\n \t\tBUG();\n \t}\n\n\tresp->id        = id;\n\tresp->operation = op;\n\tresp->status    = st;\n\n \tblk_rings->common.rsp_prod_pvt++;\n \tRING_PUSH_RESPONSES_AND_CHECK_NOTIFY(&blk_rings->common, notify);\n \tspin_unlock_irqrestore(&ring->blk_ring_lock, flags);\n\tif (notify)\n\t\tnotify_remote_via_irq(ring->irq);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142494,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int read_gab2_sub(AVFormatContext *s, AVStream *st, AVPacket *pkt)\n{\n    if (pkt->size >= 7 &&\n        pkt->size < INT_MAX - AVPROBE_PADDING_SIZE &&\n        !strcmp(pkt->data, \"GAB2\") && AV_RL16(pkt->data + 5) == 2) {\n        uint8_t desc[256];\n        int score      = AVPROBE_SCORE_EXTENSION, ret;\n        AVIStream *ast = st->priv_data;\n        AVInputFormat *sub_demuxer;\n        AVRational time_base;\n        int size;\n        AVIOContext *pb = avio_alloc_context(pkt->data + 7,\n                                             pkt->size - 7,\n                                             0, NULL, NULL, NULL, NULL);\n        AVProbeData pd;\n        unsigned int desc_len = avio_rl32(pb);\n\n        if (desc_len > pb->buf_end - pb->buf_ptr)\n            goto error;\n\n        ret = avio_get_str16le(pb, desc_len, desc, sizeof(desc));\n        avio_skip(pb, desc_len - ret);\n        if (*desc)\n            av_dict_set(&st->metadata, \"title\", desc, 0);\n\n        avio_rl16(pb);   /* flags? */\n        avio_rl32(pb);   /* data size */\n\n        size = pb->buf_end - pb->buf_ptr;\n        pd = (AVProbeData) { .buf      = av_mallocz(size + AVPROBE_PADDING_SIZE),\n                             .buf_size = size };\n        if (!pd.buf)\n            goto error;\n        memcpy(pd.buf, pb->buf_ptr, size);\n        sub_demuxer = av_probe_input_format2(&pd, 1, &score);\n        av_freep(&pd.buf);\n         if (!sub_demuxer)\n             goto error;\n \n         if (!(ast->sub_ctx = avformat_alloc_context()))\n             goto error;\n \n        ast->sub_ctx->pb = pb;\n\n        if (ff_copy_whiteblacklists(ast->sub_ctx, s) < 0)\n            goto error;\n\n        if (!avformat_open_input(&ast->sub_ctx, \"\", sub_demuxer, NULL)) {\n            if (ast->sub_ctx->nb_streams != 1)\n                goto error;\n            ff_read_packet(ast->sub_ctx, &ast->sub_pkt);\n            avcodec_parameters_copy(st->codecpar, ast->sub_ctx->streams[0]->codecpar);\n            time_base = ast->sub_ctx->streams[0]->time_base;\n            avpriv_set_pts_info(st, 64, time_base.num, time_base.den);\n        }\n        ast->sub_buffer = pkt->data;\n        memset(pkt, 0, sizeof(*pkt));\n        return 1;\n\nerror:\n        av_freep(&ast->sub_ctx);\n        av_freep(&pb);\n    }\n    return 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142503,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int read_gab2_sub(AVFormatContext *s, AVStream *st, AVPacket *pkt)\n{\n    if (pkt->size >= 7 &&\n        pkt->size < INT_MAX - AVPROBE_PADDING_SIZE &&\n        !strcmp(pkt->data, \"GAB2\") && AV_RL16(pkt->data + 5) == 2) {\n        uint8_t desc[256];\n        int score      = AVPROBE_SCORE_EXTENSION, ret;\n        AVIStream *ast = st->priv_data;\n        AVInputFormat *sub_demuxer;\n        AVRational time_base;\n        int size;\n        AVIOContext *pb = avio_alloc_context(pkt->data + 7,\n                                             pkt->size - 7,\n                                             0, NULL, NULL, NULL, NULL);\n        AVProbeData pd;\n        unsigned int desc_len = avio_rl32(pb);\n\n        if (desc_len > pb->buf_end - pb->buf_ptr)\n            goto error;\n\n        ret = avio_get_str16le(pb, desc_len, desc, sizeof(desc));\n        avio_skip(pb, desc_len - ret);\n        if (*desc)\n            av_dict_set(&st->metadata, \"title\", desc, 0);\n\n        avio_rl16(pb);   /* flags? */\n        avio_rl32(pb);   /* data size */\n\n        size = pb->buf_end - pb->buf_ptr;\n        pd = (AVProbeData) { .buf      = av_mallocz(size + AVPROBE_PADDING_SIZE),\n                             .buf_size = size };\n        if (!pd.buf)\n            goto error;\n        memcpy(pd.buf, pb->buf_ptr, size);\n        sub_demuxer = av_probe_input_format2(&pd, 1, &score);\n        av_freep(&pd.buf);\n         if (!sub_demuxer)\n             goto error;\n \n        if (strcmp(sub_demuxer->name, \"srt\") && strcmp(sub_demuxer->name, \"ass\"))\n            goto error;\n\n         if (!(ast->sub_ctx = avformat_alloc_context()))\n             goto error;\n \n        ast->sub_ctx->pb = pb;\n\n        if (ff_copy_whiteblacklists(ast->sub_ctx, s) < 0)\n            goto error;\n\n        if (!avformat_open_input(&ast->sub_ctx, \"\", sub_demuxer, NULL)) {\n            if (ast->sub_ctx->nb_streams != 1)\n                goto error;\n            ff_read_packet(ast->sub_ctx, &ast->sub_pkt);\n            avcodec_parameters_copy(st->codecpar, ast->sub_ctx->streams[0]->codecpar);\n            time_base = ast->sub_ctx->streams[0]->time_base;\n            avpriv_set_pts_info(st, 64, time_base.num, time_base.den);\n        }\n        ast->sub_buffer = pkt->data;\n        memset(pkt, 0, sizeof(*pkt));\n        return 1;\n\nerror:\n        av_freep(&ast->sub_ctx);\n        av_freep(&pb);\n    }\n    return 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142504,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "int vmw_gb_surface_define_ioctl(struct drm_device *dev, void *data,\n\t\t\t\tstruct drm_file *file_priv)\n{\n\tstruct vmw_private *dev_priv = vmw_priv(dev);\n\tstruct vmw_user_surface *user_srf;\n\tstruct vmw_surface *srf;\n\tstruct vmw_resource *res;\n\tstruct vmw_resource *tmp;\n\tunion drm_vmw_gb_surface_create_arg *arg =\n\t    (union drm_vmw_gb_surface_create_arg *)data;\n\tstruct drm_vmw_gb_surface_create_req *req = &arg->req;\n\tstruct drm_vmw_gb_surface_create_rep *rep = &arg->rep;\n \tstruct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;\n \tint ret;\n \tuint32_t size;\n\tuint32_t backup_handle;\n \n \tif (req->multisample_count != 0)\n \t\treturn -EINVAL;\n\n\tif (req->mip_levels > DRM_VMW_MAX_MIP_LEVELS)\n\t\treturn -EINVAL;\n\n\tif (unlikely(vmw_user_surface_size == 0))\n\t\tvmw_user_surface_size = ttm_round_pot(sizeof(*user_srf)) +\n\t\t\t128;\n\n\tsize = vmw_user_surface_size + 128;\n\n\t/* Define a surface based on the parameters. */\n\tret = vmw_surface_gb_priv_define(dev,\n\t\t\tsize,\n\t\t\treq->svga3d_flags,\n\t\t\treq->format,\n\t\t\treq->drm_surface_flags & drm_vmw_surface_flag_scanout,\n\t\t\treq->mip_levels,\n\t\t\treq->multisample_count,\n\t\t\treq->array_size,\n\t\t\treq->base_size,\n\t\t\t&srf);\n\tif (unlikely(ret != 0))\n\t\treturn ret;\n\n\tuser_srf = container_of(srf, struct vmw_user_surface, srf);\n\tif (drm_is_primary_client(file_priv))\n\t\tuser_srf->master = drm_master_get(file_priv->master);\n\n\tret = ttm_read_lock(&dev_priv->reservation_sem, true);\n\tif (unlikely(ret != 0))\n\t\treturn ret;\n\n\tres = &user_srf->srf.res;\n\n\n\tif (req->buffer_handle != SVGA3D_INVALID_ID) {\n \t\tret = vmw_user_dmabuf_lookup(tfile, req->buffer_handle,\n \t\t\t\t\t     &res->backup,\n \t\t\t\t\t     &user_srf->backup_base);\n\t\tif (ret == 0 && res->backup->base.num_pages * PAGE_SIZE <\n\t\t    res->backup_size) {\n\t\t\tDRM_ERROR(\"Surface backup buffer is too small.\\n\");\n\t\t\tvmw_dmabuf_unreference(&res->backup);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_unlock;\n \t\t}\n \t} else if (req->drm_surface_flags & drm_vmw_surface_flag_create_buffer)\n \t\tret = vmw_user_dmabuf_alloc(dev_priv, tfile,\n\t\t\t\t\t    res->backup_size,\n\t\t\t\t\t    req->drm_surface_flags &\n\t\t\t\t\t    drm_vmw_surface_flag_shareable,\n\t\t\t\t\t    &backup_handle,\n\t\t\t\t\t    &res->backup,\n\t\t\t\t\t    &user_srf->backup_base);\n\n\tif (unlikely(ret != 0)) {\n\t\tvmw_resource_unreference(&res);\n\t\tgoto out_unlock;\n\t}\n\n\ttmp = vmw_resource_reference(res);\n\tret = ttm_prime_object_init(tfile, res->backup_size, &user_srf->prime,\n\t\t\t\t    req->drm_surface_flags &\n\t\t\t\t    drm_vmw_surface_flag_shareable,\n\t\t\t\t    VMW_RES_SURFACE,\n\t\t\t\t    &vmw_user_surface_base_release, NULL);\n\n\tif (unlikely(ret != 0)) {\n\t\tvmw_resource_unreference(&tmp);\n\t\tvmw_resource_unreference(&res);\n\t\tgoto out_unlock;\n\t}\n\n\trep->handle      = user_srf->prime.base.hash.key;\n\trep->backup_size = res->backup_size;\n\tif (res->backup) {\n\t\trep->buffer_map_handle =\n\t\t\tdrm_vma_node_offset_addr(&res->backup->base.vma_node);\n\t\trep->buffer_size = res->backup->base.num_pages * PAGE_SIZE;\n\t\trep->buffer_handle = backup_handle;\n\t} else {\n\t\trep->buffer_map_handle = 0;\n\t\trep->buffer_size = 0;\n\t\trep->buffer_handle = SVGA3D_INVALID_ID;\n\t}\n\n\tvmw_resource_unreference(&res);\n\nout_unlock:\n\tttm_read_unlock(&dev_priv->reservation_sem);\n\treturn ret;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142517,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "int vmw_gb_surface_define_ioctl(struct drm_device *dev, void *data,\n\t\t\t\tstruct drm_file *file_priv)\n{\n\tstruct vmw_private *dev_priv = vmw_priv(dev);\n\tstruct vmw_user_surface *user_srf;\n\tstruct vmw_surface *srf;\n\tstruct vmw_resource *res;\n\tstruct vmw_resource *tmp;\n\tunion drm_vmw_gb_surface_create_arg *arg =\n\t    (union drm_vmw_gb_surface_create_arg *)data;\n\tstruct drm_vmw_gb_surface_create_req *req = &arg->req;\n\tstruct drm_vmw_gb_surface_create_rep *rep = &arg->rep;\n \tstruct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;\n \tint ret;\n \tuint32_t size;\n\tuint32_t backup_handle = 0;\n \n \tif (req->multisample_count != 0)\n \t\treturn -EINVAL;\n\n\tif (req->mip_levels > DRM_VMW_MAX_MIP_LEVELS)\n\t\treturn -EINVAL;\n\n\tif (unlikely(vmw_user_surface_size == 0))\n\t\tvmw_user_surface_size = ttm_round_pot(sizeof(*user_srf)) +\n\t\t\t128;\n\n\tsize = vmw_user_surface_size + 128;\n\n\t/* Define a surface based on the parameters. */\n\tret = vmw_surface_gb_priv_define(dev,\n\t\t\tsize,\n\t\t\treq->svga3d_flags,\n\t\t\treq->format,\n\t\t\treq->drm_surface_flags & drm_vmw_surface_flag_scanout,\n\t\t\treq->mip_levels,\n\t\t\treq->multisample_count,\n\t\t\treq->array_size,\n\t\t\treq->base_size,\n\t\t\t&srf);\n\tif (unlikely(ret != 0))\n\t\treturn ret;\n\n\tuser_srf = container_of(srf, struct vmw_user_surface, srf);\n\tif (drm_is_primary_client(file_priv))\n\t\tuser_srf->master = drm_master_get(file_priv->master);\n\n\tret = ttm_read_lock(&dev_priv->reservation_sem, true);\n\tif (unlikely(ret != 0))\n\t\treturn ret;\n\n\tres = &user_srf->srf.res;\n\n\n\tif (req->buffer_handle != SVGA3D_INVALID_ID) {\n \t\tret = vmw_user_dmabuf_lookup(tfile, req->buffer_handle,\n \t\t\t\t\t     &res->backup,\n \t\t\t\t\t     &user_srf->backup_base);\n\t\tif (ret == 0) {\n\t\t\tif (res->backup->base.num_pages * PAGE_SIZE <\n\t\t\t    res->backup_size) {\n\t\t\t\tDRM_ERROR(\"Surface backup buffer is too small.\\n\");\n\t\t\t\tvmw_dmabuf_unreference(&res->backup);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out_unlock;\n\t\t\t} else {\n\t\t\t\tbackup_handle = req->buffer_handle;\n\t\t\t}\n \t\t}\n \t} else if (req->drm_surface_flags & drm_vmw_surface_flag_create_buffer)\n \t\tret = vmw_user_dmabuf_alloc(dev_priv, tfile,\n\t\t\t\t\t    res->backup_size,\n\t\t\t\t\t    req->drm_surface_flags &\n\t\t\t\t\t    drm_vmw_surface_flag_shareable,\n\t\t\t\t\t    &backup_handle,\n\t\t\t\t\t    &res->backup,\n\t\t\t\t\t    &user_srf->backup_base);\n\n\tif (unlikely(ret != 0)) {\n\t\tvmw_resource_unreference(&res);\n\t\tgoto out_unlock;\n\t}\n\n\ttmp = vmw_resource_reference(res);\n\tret = ttm_prime_object_init(tfile, res->backup_size, &user_srf->prime,\n\t\t\t\t    req->drm_surface_flags &\n\t\t\t\t    drm_vmw_surface_flag_shareable,\n\t\t\t\t    VMW_RES_SURFACE,\n\t\t\t\t    &vmw_user_surface_base_release, NULL);\n\n\tif (unlikely(ret != 0)) {\n\t\tvmw_resource_unreference(&tmp);\n\t\tvmw_resource_unreference(&res);\n\t\tgoto out_unlock;\n\t}\n\n\trep->handle      = user_srf->prime.base.hash.key;\n\trep->backup_size = res->backup_size;\n\tif (res->backup) {\n\t\trep->buffer_map_handle =\n\t\t\tdrm_vma_node_offset_addr(&res->backup->base.vma_node);\n\t\trep->buffer_size = res->backup->base.num_pages * PAGE_SIZE;\n\t\trep->buffer_handle = backup_handle;\n\t} else {\n\t\trep->buffer_map_handle = 0;\n\t\trep->buffer_size = 0;\n\t\trep->buffer_handle = SVGA3D_INVALID_ID;\n\t}\n\n\tvmw_resource_unreference(&res);\n\nout_unlock:\n\tttm_read_unlock(&dev_priv->reservation_sem);\n\treturn ret;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142518,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int do_check(struct bpf_verifier_env *env)\n{\n\tstruct bpf_verifier_state *state = &env->cur_state;\n\tstruct bpf_insn *insns = env->prog->insnsi;\n\tstruct bpf_reg_state *regs = state->regs;\n\tint insn_cnt = env->prog->len;\n\tint insn_idx, prev_insn_idx = 0;\n\tint insn_processed = 0;\n\tbool do_print_state = false;\n\n\tinit_reg_state(regs);\n\tinsn_idx = 0;\n\tenv->varlen_map_value_access = false;\n\tfor (;;) {\n\t\tstruct bpf_insn *insn;\n\t\tu8 class;\n\t\tint err;\n\n\t\tif (insn_idx >= insn_cnt) {\n\t\t\tverbose(\"invalid insn idx %d insn_cnt %d\\n\",\n\t\t\t\tinsn_idx, insn_cnt);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tinsn = &insns[insn_idx];\n\t\tclass = BPF_CLASS(insn->code);\n\n\t\tif (++insn_processed > BPF_COMPLEXITY_LIMIT_INSNS) {\n\t\t\tverbose(\"BPF program is too large. Processed %d insn\\n\",\n\t\t\t\tinsn_processed);\n\t\t\treturn -E2BIG;\n\t\t}\n\n\t\terr = is_state_visited(env, insn_idx);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (err == 1) {\n\t\t\t/* found equivalent state, can prune the search */\n\t\t\tif (log_level) {\n\t\t\t\tif (do_print_state)\n\t\t\t\t\tverbose(\"\\nfrom %d to %d: safe\\n\",\n\t\t\t\t\t\tprev_insn_idx, insn_idx);\n\t\t\t\telse\n\t\t\t\t\tverbose(\"%d: safe\\n\", insn_idx);\n\t\t\t}\n\t\t\tgoto process_bpf_exit;\n\t\t}\n\n\t\tif (log_level && do_print_state) {\n\t\t\tverbose(\"\\nfrom %d to %d:\", prev_insn_idx, insn_idx);\n\t\t\tprint_verifier_state(&env->cur_state);\n\t\t\tdo_print_state = false;\n\t\t}\n \n \t\tif (log_level) {\n \t\t\tverbose(\"%d: \", insn_idx);\n\t\t\tprint_bpf_insn(insn);\n \t\t}\n \n \t\terr = ext_analyzer_insn_hook(env, insn_idx, prev_insn_idx);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (class == BPF_ALU || class == BPF_ALU64) {\n\t\t\terr = check_alu_op(env, insn);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t} else if (class == BPF_LDX) {\n\t\t\tenum bpf_reg_type *prev_src_type, src_reg_type;\n\n\t\t\t/* check for reserved fields is already done */\n\n\t\t\t/* check src operand */\n\t\t\terr = check_reg_arg(regs, insn->src_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\terr = check_reg_arg(regs, insn->dst_reg, DST_OP_NO_MARK);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tsrc_reg_type = regs[insn->src_reg].type;\n\n\t\t\t/* check that memory (src_reg + off) is readable,\n\t\t\t * the state of dst_reg will be updated by this func\n\t\t\t */\n\t\t\terr = check_mem_access(env, insn->src_reg, insn->off,\n\t\t\t\t\t       BPF_SIZE(insn->code), BPF_READ,\n\t\t\t\t\t       insn->dst_reg);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tif (BPF_SIZE(insn->code) != BPF_W &&\n\t\t\t    BPF_SIZE(insn->code) != BPF_DW) {\n\t\t\t\tinsn_idx++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tprev_src_type = &env->insn_aux_data[insn_idx].ptr_type;\n\n\t\t\tif (*prev_src_type == NOT_INIT) {\n\t\t\t\t/* saw a valid insn\n\t\t\t\t * dst_reg = *(u32 *)(src_reg + off)\n\t\t\t\t * save type to validate intersecting paths\n\t\t\t\t */\n\t\t\t\t*prev_src_type = src_reg_type;\n\n\t\t\t} else if (src_reg_type != *prev_src_type &&\n\t\t\t\t   (src_reg_type == PTR_TO_CTX ||\n\t\t\t\t    *prev_src_type == PTR_TO_CTX)) {\n\t\t\t\t/* ABuser program is trying to use the same insn\n\t\t\t\t * dst_reg = *(u32*) (src_reg + off)\n\t\t\t\t * with different pointer types:\n\t\t\t\t * src_reg == ctx in one branch and\n\t\t\t\t * src_reg == stack|map in some other branch.\n\t\t\t\t * Reject it.\n\t\t\t\t */\n\t\t\t\tverbose(\"same insn cannot be used with different pointers\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t} else if (class == BPF_STX) {\n\t\t\tenum bpf_reg_type *prev_dst_type, dst_reg_type;\n\n\t\t\tif (BPF_MODE(insn->code) == BPF_XADD) {\n\t\t\t\terr = check_xadd(env, insn);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\tinsn_idx++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* check src1 operand */\n\t\t\terr = check_reg_arg(regs, insn->src_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\t/* check src2 operand */\n\t\t\terr = check_reg_arg(regs, insn->dst_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tdst_reg_type = regs[insn->dst_reg].type;\n\n\t\t\t/* check that memory (dst_reg + off) is writeable */\n\t\t\terr = check_mem_access(env, insn->dst_reg, insn->off,\n\t\t\t\t\t       BPF_SIZE(insn->code), BPF_WRITE,\n\t\t\t\t\t       insn->src_reg);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tprev_dst_type = &env->insn_aux_data[insn_idx].ptr_type;\n\n\t\t\tif (*prev_dst_type == NOT_INIT) {\n\t\t\t\t*prev_dst_type = dst_reg_type;\n\t\t\t} else if (dst_reg_type != *prev_dst_type &&\n\t\t\t\t   (dst_reg_type == PTR_TO_CTX ||\n\t\t\t\t    *prev_dst_type == PTR_TO_CTX)) {\n\t\t\t\tverbose(\"same insn cannot be used with different pointers\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t} else if (class == BPF_ST) {\n\t\t\tif (BPF_MODE(insn->code) != BPF_MEM ||\n\t\t\t    insn->src_reg != BPF_REG_0) {\n\t\t\t\tverbose(\"BPF_ST uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t/* check src operand */\n\t\t\terr = check_reg_arg(regs, insn->dst_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\t/* check that memory (dst_reg + off) is writeable */\n\t\t\terr = check_mem_access(env, insn->dst_reg, insn->off,\n\t\t\t\t\t       BPF_SIZE(insn->code), BPF_WRITE,\n\t\t\t\t\t       -1);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t} else if (class == BPF_JMP) {\n\t\t\tu8 opcode = BPF_OP(insn->code);\n\n\t\t\tif (opcode == BPF_CALL) {\n\t\t\t\tif (BPF_SRC(insn->code) != BPF_K ||\n\t\t\t\t    insn->off != 0 ||\n\t\t\t\t    insn->src_reg != BPF_REG_0 ||\n\t\t\t\t    insn->dst_reg != BPF_REG_0) {\n\t\t\t\t\tverbose(\"BPF_CALL uses reserved fields\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\terr = check_call(env, insn->imm, insn_idx);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t} else if (opcode == BPF_JA) {\n\t\t\t\tif (BPF_SRC(insn->code) != BPF_K ||\n\t\t\t\t    insn->imm != 0 ||\n\t\t\t\t    insn->src_reg != BPF_REG_0 ||\n\t\t\t\t    insn->dst_reg != BPF_REG_0) {\n\t\t\t\t\tverbose(\"BPF_JA uses reserved fields\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tinsn_idx += insn->off + 1;\n\t\t\t\tcontinue;\n\n\t\t\t} else if (opcode == BPF_EXIT) {\n\t\t\t\tif (BPF_SRC(insn->code) != BPF_K ||\n\t\t\t\t    insn->imm != 0 ||\n\t\t\t\t    insn->src_reg != BPF_REG_0 ||\n\t\t\t\t    insn->dst_reg != BPF_REG_0) {\n\t\t\t\t\tverbose(\"BPF_EXIT uses reserved fields\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\t/* eBPF calling convetion is such that R0 is used\n\t\t\t\t * to return the value from eBPF program.\n\t\t\t\t * Make sure that it's readable at this time\n\t\t\t\t * of bpf_exit, which means that program wrote\n\t\t\t\t * something into it earlier\n\t\t\t\t */\n\t\t\t\terr = check_reg_arg(regs, BPF_REG_0, SRC_OP);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\tif (is_pointer_value(env, BPF_REG_0)) {\n\t\t\t\t\tverbose(\"R0 leaks addr as return value\\n\");\n\t\t\t\t\treturn -EACCES;\n\t\t\t\t}\n\nprocess_bpf_exit:\n\t\t\t\tinsn_idx = pop_stack(env, &prev_insn_idx);\n\t\t\t\tif (insn_idx < 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tdo_print_state = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terr = check_cond_jmp_op(env, insn, &insn_idx);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t} else if (class == BPF_LD) {\n\t\t\tu8 mode = BPF_MODE(insn->code);\n\n\t\t\tif (mode == BPF_ABS || mode == BPF_IND) {\n\t\t\t\terr = check_ld_abs(env, insn);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t} else if (mode == BPF_IMM) {\n\t\t\t\terr = check_ld_imm(env, insn);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\tinsn_idx++;\n\t\t\t} else {\n\t\t\t\tverbose(\"invalid BPF_LD mode\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\treset_reg_range_values(regs, insn->dst_reg);\n\t\t} else {\n\t\t\tverbose(\"unknown insn class %d\\n\", class);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tinsn_idx++;\n\t}\n\n\tverbose(\"processed %d insns\\n\", insn_processed);\n\treturn 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142539,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int do_check(struct bpf_verifier_env *env)\n{\n\tstruct bpf_verifier_state *state = &env->cur_state;\n\tstruct bpf_insn *insns = env->prog->insnsi;\n\tstruct bpf_reg_state *regs = state->regs;\n\tint insn_cnt = env->prog->len;\n\tint insn_idx, prev_insn_idx = 0;\n\tint insn_processed = 0;\n\tbool do_print_state = false;\n\n\tinit_reg_state(regs);\n\tinsn_idx = 0;\n\tenv->varlen_map_value_access = false;\n\tfor (;;) {\n\t\tstruct bpf_insn *insn;\n\t\tu8 class;\n\t\tint err;\n\n\t\tif (insn_idx >= insn_cnt) {\n\t\t\tverbose(\"invalid insn idx %d insn_cnt %d\\n\",\n\t\t\t\tinsn_idx, insn_cnt);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tinsn = &insns[insn_idx];\n\t\tclass = BPF_CLASS(insn->code);\n\n\t\tif (++insn_processed > BPF_COMPLEXITY_LIMIT_INSNS) {\n\t\t\tverbose(\"BPF program is too large. Processed %d insn\\n\",\n\t\t\t\tinsn_processed);\n\t\t\treturn -E2BIG;\n\t\t}\n\n\t\terr = is_state_visited(env, insn_idx);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (err == 1) {\n\t\t\t/* found equivalent state, can prune the search */\n\t\t\tif (log_level) {\n\t\t\t\tif (do_print_state)\n\t\t\t\t\tverbose(\"\\nfrom %d to %d: safe\\n\",\n\t\t\t\t\t\tprev_insn_idx, insn_idx);\n\t\t\t\telse\n\t\t\t\t\tverbose(\"%d: safe\\n\", insn_idx);\n\t\t\t}\n\t\t\tgoto process_bpf_exit;\n\t\t}\n\n\t\tif (log_level && do_print_state) {\n\t\t\tverbose(\"\\nfrom %d to %d:\", prev_insn_idx, insn_idx);\n\t\t\tprint_verifier_state(&env->cur_state);\n\t\t\tdo_print_state = false;\n\t\t}\n \n \t\tif (log_level) {\n \t\t\tverbose(\"%d: \", insn_idx);\n\t\t\tprint_bpf_insn(env, insn);\n \t\t}\n \n \t\terr = ext_analyzer_insn_hook(env, insn_idx, prev_insn_idx);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (class == BPF_ALU || class == BPF_ALU64) {\n\t\t\terr = check_alu_op(env, insn);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t} else if (class == BPF_LDX) {\n\t\t\tenum bpf_reg_type *prev_src_type, src_reg_type;\n\n\t\t\t/* check for reserved fields is already done */\n\n\t\t\t/* check src operand */\n\t\t\terr = check_reg_arg(regs, insn->src_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\terr = check_reg_arg(regs, insn->dst_reg, DST_OP_NO_MARK);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tsrc_reg_type = regs[insn->src_reg].type;\n\n\t\t\t/* check that memory (src_reg + off) is readable,\n\t\t\t * the state of dst_reg will be updated by this func\n\t\t\t */\n\t\t\terr = check_mem_access(env, insn->src_reg, insn->off,\n\t\t\t\t\t       BPF_SIZE(insn->code), BPF_READ,\n\t\t\t\t\t       insn->dst_reg);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tif (BPF_SIZE(insn->code) != BPF_W &&\n\t\t\t    BPF_SIZE(insn->code) != BPF_DW) {\n\t\t\t\tinsn_idx++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tprev_src_type = &env->insn_aux_data[insn_idx].ptr_type;\n\n\t\t\tif (*prev_src_type == NOT_INIT) {\n\t\t\t\t/* saw a valid insn\n\t\t\t\t * dst_reg = *(u32 *)(src_reg + off)\n\t\t\t\t * save type to validate intersecting paths\n\t\t\t\t */\n\t\t\t\t*prev_src_type = src_reg_type;\n\n\t\t\t} else if (src_reg_type != *prev_src_type &&\n\t\t\t\t   (src_reg_type == PTR_TO_CTX ||\n\t\t\t\t    *prev_src_type == PTR_TO_CTX)) {\n\t\t\t\t/* ABuser program is trying to use the same insn\n\t\t\t\t * dst_reg = *(u32*) (src_reg + off)\n\t\t\t\t * with different pointer types:\n\t\t\t\t * src_reg == ctx in one branch and\n\t\t\t\t * src_reg == stack|map in some other branch.\n\t\t\t\t * Reject it.\n\t\t\t\t */\n\t\t\t\tverbose(\"same insn cannot be used with different pointers\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t} else if (class == BPF_STX) {\n\t\t\tenum bpf_reg_type *prev_dst_type, dst_reg_type;\n\n\t\t\tif (BPF_MODE(insn->code) == BPF_XADD) {\n\t\t\t\terr = check_xadd(env, insn);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\tinsn_idx++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* check src1 operand */\n\t\t\terr = check_reg_arg(regs, insn->src_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\t/* check src2 operand */\n\t\t\terr = check_reg_arg(regs, insn->dst_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tdst_reg_type = regs[insn->dst_reg].type;\n\n\t\t\t/* check that memory (dst_reg + off) is writeable */\n\t\t\terr = check_mem_access(env, insn->dst_reg, insn->off,\n\t\t\t\t\t       BPF_SIZE(insn->code), BPF_WRITE,\n\t\t\t\t\t       insn->src_reg);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tprev_dst_type = &env->insn_aux_data[insn_idx].ptr_type;\n\n\t\t\tif (*prev_dst_type == NOT_INIT) {\n\t\t\t\t*prev_dst_type = dst_reg_type;\n\t\t\t} else if (dst_reg_type != *prev_dst_type &&\n\t\t\t\t   (dst_reg_type == PTR_TO_CTX ||\n\t\t\t\t    *prev_dst_type == PTR_TO_CTX)) {\n\t\t\t\tverbose(\"same insn cannot be used with different pointers\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t} else if (class == BPF_ST) {\n\t\t\tif (BPF_MODE(insn->code) != BPF_MEM ||\n\t\t\t    insn->src_reg != BPF_REG_0) {\n\t\t\t\tverbose(\"BPF_ST uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t/* check src operand */\n\t\t\terr = check_reg_arg(regs, insn->dst_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\t/* check that memory (dst_reg + off) is writeable */\n\t\t\terr = check_mem_access(env, insn->dst_reg, insn->off,\n\t\t\t\t\t       BPF_SIZE(insn->code), BPF_WRITE,\n\t\t\t\t\t       -1);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t} else if (class == BPF_JMP) {\n\t\t\tu8 opcode = BPF_OP(insn->code);\n\n\t\t\tif (opcode == BPF_CALL) {\n\t\t\t\tif (BPF_SRC(insn->code) != BPF_K ||\n\t\t\t\t    insn->off != 0 ||\n\t\t\t\t    insn->src_reg != BPF_REG_0 ||\n\t\t\t\t    insn->dst_reg != BPF_REG_0) {\n\t\t\t\t\tverbose(\"BPF_CALL uses reserved fields\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\terr = check_call(env, insn->imm, insn_idx);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t} else if (opcode == BPF_JA) {\n\t\t\t\tif (BPF_SRC(insn->code) != BPF_K ||\n\t\t\t\t    insn->imm != 0 ||\n\t\t\t\t    insn->src_reg != BPF_REG_0 ||\n\t\t\t\t    insn->dst_reg != BPF_REG_0) {\n\t\t\t\t\tverbose(\"BPF_JA uses reserved fields\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tinsn_idx += insn->off + 1;\n\t\t\t\tcontinue;\n\n\t\t\t} else if (opcode == BPF_EXIT) {\n\t\t\t\tif (BPF_SRC(insn->code) != BPF_K ||\n\t\t\t\t    insn->imm != 0 ||\n\t\t\t\t    insn->src_reg != BPF_REG_0 ||\n\t\t\t\t    insn->dst_reg != BPF_REG_0) {\n\t\t\t\t\tverbose(\"BPF_EXIT uses reserved fields\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\t/* eBPF calling convetion is such that R0 is used\n\t\t\t\t * to return the value from eBPF program.\n\t\t\t\t * Make sure that it's readable at this time\n\t\t\t\t * of bpf_exit, which means that program wrote\n\t\t\t\t * something into it earlier\n\t\t\t\t */\n\t\t\t\terr = check_reg_arg(regs, BPF_REG_0, SRC_OP);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\tif (is_pointer_value(env, BPF_REG_0)) {\n\t\t\t\t\tverbose(\"R0 leaks addr as return value\\n\");\n\t\t\t\t\treturn -EACCES;\n\t\t\t\t}\n\nprocess_bpf_exit:\n\t\t\t\tinsn_idx = pop_stack(env, &prev_insn_idx);\n\t\t\t\tif (insn_idx < 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tdo_print_state = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terr = check_cond_jmp_op(env, insn, &insn_idx);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t} else if (class == BPF_LD) {\n\t\t\tu8 mode = BPF_MODE(insn->code);\n\n\t\t\tif (mode == BPF_ABS || mode == BPF_IND) {\n\t\t\t\terr = check_ld_abs(env, insn);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t} else if (mode == BPF_IMM) {\n\t\t\t\terr = check_ld_imm(env, insn);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\tinsn_idx++;\n\t\t\t} else {\n\t\t\t\tverbose(\"invalid BPF_LD mode\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\treset_reg_range_values(regs, insn->dst_reg);\n\t\t} else {\n\t\t\tverbose(\"unknown insn class %d\\n\", class);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tinsn_idx++;\n\t}\n\n\tverbose(\"processed %d insns\\n\", insn_processed);\n\treturn 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142540,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static void print_bpf_insn(struct bpf_insn *insn)\n {\n \tu8 class = BPF_CLASS(insn->code);\n \n\tif (class == BPF_ALU || class == BPF_ALU64) {\n\t\tif (BPF_SRC(insn->code) == BPF_X)\n\t\t\tverbose(\"(%02x) %sr%d %s %sr%d\\n\",\n\t\t\t\tinsn->code, class == BPF_ALU ? \"(u32) \" : \"\",\n\t\t\t\tinsn->dst_reg,\n\t\t\t\tbpf_alu_string[BPF_OP(insn->code) >> 4],\n\t\t\t\tclass == BPF_ALU ? \"(u32) \" : \"\",\n\t\t\t\tinsn->src_reg);\n\t\telse\n\t\t\tverbose(\"(%02x) %sr%d %s %s%d\\n\",\n\t\t\t\tinsn->code, class == BPF_ALU ? \"(u32) \" : \"\",\n\t\t\t\tinsn->dst_reg,\n\t\t\t\tbpf_alu_string[BPF_OP(insn->code) >> 4],\n\t\t\t\tclass == BPF_ALU ? \"(u32) \" : \"\",\n\t\t\t\tinsn->imm);\n\t} else if (class == BPF_STX) {\n\t\tif (BPF_MODE(insn->code) == BPF_MEM)\n\t\t\tverbose(\"(%02x) *(%s *)(r%d %+d) = r%d\\n\",\n\t\t\t\tinsn->code,\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->dst_reg,\n\t\t\t\tinsn->off, insn->src_reg);\n\t\telse if (BPF_MODE(insn->code) == BPF_XADD)\n\t\t\tverbose(\"(%02x) lock *(%s *)(r%d %+d) += r%d\\n\",\n\t\t\t\tinsn->code,\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->dst_reg, insn->off,\n\t\t\t\tinsn->src_reg);\n\t\telse\n\t\t\tverbose(\"BUG_%02x\\n\", insn->code);\n\t} else if (class == BPF_ST) {\n\t\tif (BPF_MODE(insn->code) != BPF_MEM) {\n\t\t\tverbose(\"BUG_st_%02x\\n\", insn->code);\n\t\t\treturn;\n\t\t}\n\t\tverbose(\"(%02x) *(%s *)(r%d %+d) = %d\\n\",\n\t\t\tinsn->code,\n\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\tinsn->dst_reg,\n\t\t\tinsn->off, insn->imm);\n\t} else if (class == BPF_LDX) {\n\t\tif (BPF_MODE(insn->code) != BPF_MEM) {\n\t\t\tverbose(\"BUG_ldx_%02x\\n\", insn->code);\n\t\t\treturn;\n\t\t}\n\t\tverbose(\"(%02x) r%d = *(%s *)(r%d %+d)\\n\",\n\t\t\tinsn->code, insn->dst_reg,\n\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\tinsn->src_reg, insn->off);\n\t} else if (class == BPF_LD) {\n\t\tif (BPF_MODE(insn->code) == BPF_ABS) {\n\t\t\tverbose(\"(%02x) r0 = *(%s *)skb[%d]\\n\",\n\t\t\t\tinsn->code,\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->imm);\n\t\t} else if (BPF_MODE(insn->code) == BPF_IND) {\n\t\t\tverbose(\"(%02x) r0 = *(%s *)skb[r%d + %d]\\n\",\n \t\t\t\tinsn->code,\n \t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n \t\t\t\tinsn->src_reg, insn->imm);\n\t\t} else if (BPF_MODE(insn->code) == BPF_IMM) {\n\t\t\tverbose(\"(%02x) r%d = 0x%x\\n\",\n\t\t\t\tinsn->code, insn->dst_reg, insn->imm);\n \t\t} else {\n \t\t\tverbose(\"BUG_ld_%02x\\n\", insn->code);\n \t\t\treturn;\n\t\t}\n\t} else if (class == BPF_JMP) {\n\t\tu8 opcode = BPF_OP(insn->code);\n\n\t\tif (opcode == BPF_CALL) {\n\t\t\tverbose(\"(%02x) call %s#%d\\n\", insn->code,\n\t\t\t\tfunc_id_name(insn->imm), insn->imm);\n\t\t} else if (insn->code == (BPF_JMP | BPF_JA)) {\n\t\t\tverbose(\"(%02x) goto pc%+d\\n\",\n\t\t\t\tinsn->code, insn->off);\n\t\t} else if (insn->code == (BPF_JMP | BPF_EXIT)) {\n\t\t\tverbose(\"(%02x) exit\\n\", insn->code);\n\t\t} else if (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tverbose(\"(%02x) if r%d %s r%d goto pc%+d\\n\",\n\t\t\t\tinsn->code, insn->dst_reg,\n\t\t\t\tbpf_jmp_string[BPF_OP(insn->code) >> 4],\n\t\t\t\tinsn->src_reg, insn->off);\n\t\t} else {\n\t\t\tverbose(\"(%02x) if r%d %s 0x%x goto pc%+d\\n\",\n\t\t\t\tinsn->code, insn->dst_reg,\n\t\t\t\tbpf_jmp_string[BPF_OP(insn->code) >> 4],\n\t\t\t\tinsn->imm, insn->off);\n\t\t}\n\t} else {\n\t\tverbose(\"(%02x) %s\\n\", insn->code, bpf_class_string[class]);\n\t}\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142541,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static void print_bpf_insn(struct bpf_insn *insn)\nstatic void print_bpf_insn(const struct bpf_verifier_env *env,\n\t\t\t   const struct bpf_insn *insn)\n {\n \tu8 class = BPF_CLASS(insn->code);\n \n\tif (class == BPF_ALU || class == BPF_ALU64) {\n\t\tif (BPF_SRC(insn->code) == BPF_X)\n\t\t\tverbose(\"(%02x) %sr%d %s %sr%d\\n\",\n\t\t\t\tinsn->code, class == BPF_ALU ? \"(u32) \" : \"\",\n\t\t\t\tinsn->dst_reg,\n\t\t\t\tbpf_alu_string[BPF_OP(insn->code) >> 4],\n\t\t\t\tclass == BPF_ALU ? \"(u32) \" : \"\",\n\t\t\t\tinsn->src_reg);\n\t\telse\n\t\t\tverbose(\"(%02x) %sr%d %s %s%d\\n\",\n\t\t\t\tinsn->code, class == BPF_ALU ? \"(u32) \" : \"\",\n\t\t\t\tinsn->dst_reg,\n\t\t\t\tbpf_alu_string[BPF_OP(insn->code) >> 4],\n\t\t\t\tclass == BPF_ALU ? \"(u32) \" : \"\",\n\t\t\t\tinsn->imm);\n\t} else if (class == BPF_STX) {\n\t\tif (BPF_MODE(insn->code) == BPF_MEM)\n\t\t\tverbose(\"(%02x) *(%s *)(r%d %+d) = r%d\\n\",\n\t\t\t\tinsn->code,\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->dst_reg,\n\t\t\t\tinsn->off, insn->src_reg);\n\t\telse if (BPF_MODE(insn->code) == BPF_XADD)\n\t\t\tverbose(\"(%02x) lock *(%s *)(r%d %+d) += r%d\\n\",\n\t\t\t\tinsn->code,\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->dst_reg, insn->off,\n\t\t\t\tinsn->src_reg);\n\t\telse\n\t\t\tverbose(\"BUG_%02x\\n\", insn->code);\n\t} else if (class == BPF_ST) {\n\t\tif (BPF_MODE(insn->code) != BPF_MEM) {\n\t\t\tverbose(\"BUG_st_%02x\\n\", insn->code);\n\t\t\treturn;\n\t\t}\n\t\tverbose(\"(%02x) *(%s *)(r%d %+d) = %d\\n\",\n\t\t\tinsn->code,\n\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\tinsn->dst_reg,\n\t\t\tinsn->off, insn->imm);\n\t} else if (class == BPF_LDX) {\n\t\tif (BPF_MODE(insn->code) != BPF_MEM) {\n\t\t\tverbose(\"BUG_ldx_%02x\\n\", insn->code);\n\t\t\treturn;\n\t\t}\n\t\tverbose(\"(%02x) r%d = *(%s *)(r%d %+d)\\n\",\n\t\t\tinsn->code, insn->dst_reg,\n\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\tinsn->src_reg, insn->off);\n\t} else if (class == BPF_LD) {\n\t\tif (BPF_MODE(insn->code) == BPF_ABS) {\n\t\t\tverbose(\"(%02x) r0 = *(%s *)skb[%d]\\n\",\n\t\t\t\tinsn->code,\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->imm);\n\t\t} else if (BPF_MODE(insn->code) == BPF_IND) {\n\t\t\tverbose(\"(%02x) r0 = *(%s *)skb[r%d + %d]\\n\",\n \t\t\t\tinsn->code,\n \t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n \t\t\t\tinsn->src_reg, insn->imm);\n\t\t} else if (BPF_MODE(insn->code) == BPF_IMM &&\n\t\t\t   BPF_SIZE(insn->code) == BPF_DW) {\n\t\t\t/* At this point, we already made sure that the second\n\t\t\t * part of the ldimm64 insn is accessible.\n\t\t\t */\n\t\t\tu64 imm = ((u64)(insn + 1)->imm << 32) | (u32)insn->imm;\n\t\t\tbool map_ptr = insn->src_reg == BPF_PSEUDO_MAP_FD;\n\n\t\t\tif (map_ptr && !env->allow_ptr_leaks)\n\t\t\t\timm = 0;\n\n\t\t\tverbose(\"(%02x) r%d = 0x%llx\\n\", insn->code,\n\t\t\t\tinsn->dst_reg, (unsigned long long)imm);\n \t\t} else {\n \t\t\tverbose(\"BUG_ld_%02x\\n\", insn->code);\n \t\t\treturn;\n\t\t}\n\t} else if (class == BPF_JMP) {\n\t\tu8 opcode = BPF_OP(insn->code);\n\n\t\tif (opcode == BPF_CALL) {\n\t\t\tverbose(\"(%02x) call %s#%d\\n\", insn->code,\n\t\t\t\tfunc_id_name(insn->imm), insn->imm);\n\t\t} else if (insn->code == (BPF_JMP | BPF_JA)) {\n\t\t\tverbose(\"(%02x) goto pc%+d\\n\",\n\t\t\t\tinsn->code, insn->off);\n\t\t} else if (insn->code == (BPF_JMP | BPF_EXIT)) {\n\t\t\tverbose(\"(%02x) exit\\n\", insn->code);\n\t\t} else if (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tverbose(\"(%02x) if r%d %s r%d goto pc%+d\\n\",\n\t\t\t\tinsn->code, insn->dst_reg,\n\t\t\t\tbpf_jmp_string[BPF_OP(insn->code) >> 4],\n\t\t\t\tinsn->src_reg, insn->off);\n\t\t} else {\n\t\t\tverbose(\"(%02x) if r%d %s 0x%x goto pc%+d\\n\",\n\t\t\t\tinsn->code, insn->dst_reg,\n\t\t\t\tbpf_jmp_string[BPF_OP(insn->code) >> 4],\n\t\t\t\tinsn->imm, insn->off);\n\t\t}\n\t} else {\n\t\tverbose(\"(%02x) %s\\n\", insn->code, bpf_class_string[class]);\n\t}\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142542,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define SkipLinesOp  0x01\n#define SetColorOp  0x02\n#define SkipPixelsOp  0x03\n#define ByteDataOp  0x05\n#define RunDataOp  0x06\n#define EOFOp  0x07\n\n  char\n    magick[12];\n\n  Image\n    *image;\n\n  int\n    opcode,\n    operand,\n    status;\n\n  MagickStatusType\n    flags;\n\n  MagickSizeType\n    number_pixels;\n\n  MemoryInfo\n    *pixel_info;\n\n  Quantum\n    index;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bits_per_pixel,\n    map_length,\n    number_colormaps,\n    number_planes,\n    number_planes_filled,\n    one,\n    pixel_info_length;\n\n  ssize_t\n    count,\n    offset,\n    y;\n\n  unsigned char\n    background_color[256],\n    *colormap,\n    pixel,\n    plane,\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Determine if this a RLE file.\n  */\n  count=ReadBlob(image,2,(unsigned char *) magick);\n  if ((count != 2) || (memcmp(magick,\"\\122\\314\",2) != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  do\n  {\n    /*\n      Read image header.\n    */\n    image->page.x=ReadBlobLSBShort(image);\n    image->page.y=ReadBlobLSBShort(image);\n    image->columns=ReadBlobLSBShort(image);\n    image->rows=ReadBlobLSBShort(image);\n    flags=(MagickStatusType) ReadBlobByte(image);\n    image->alpha_trait=flags & 0x04 ? BlendPixelTrait : UndefinedPixelTrait;\n    number_planes=(size_t) ReadBlobByte(image);\n    bits_per_pixel=(size_t) ReadBlobByte(image);\n    number_colormaps=(size_t) ReadBlobByte(image);\n    map_length=(unsigned char) ReadBlobByte(image);\n    if (map_length >= 22)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    one=1;\n    map_length=one << map_length;\n    if ((number_planes == 0) || (number_planes == 2) ||\n        ((flags & 0x04) && (number_colormaps > 254)) || (bits_per_pixel != 8) ||\n        (image->columns == 0))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if (flags & 0x02)\n      {\n        /*\n          No background color-- initialize to black.\n        */\n        for (i=0; i < (ssize_t) number_planes; i++)\n          background_color[i]=0;\n        (void) ReadBlobByte(image);\n      }\n    else\n      {\n        /*\n          Initialize background color.\n        */\n        p=background_color;\n        for (i=0; i < (ssize_t) number_planes; i++)\n          *p++=(unsigned char) ReadBlobByte(image);\n      }\n    if ((number_planes & 0x01) == 0)\n      (void) ReadBlobByte(image);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    colormap=(unsigned char *) NULL;\n    if (number_colormaps != 0)\n      {\n        /*\n          Read image colormaps.\n        */\n        colormap=(unsigned char *) AcquireQuantumMemory(number_colormaps,\n          3*map_length*sizeof(*colormap));\n        if (colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        p=colormap;\n        for (i=0; i < (ssize_t) number_colormaps; i++)\n          for (x=0; x < (ssize_t) map_length; x++)\n            *p++=(unsigned char) ScaleShortToQuantum(ReadBlobLSBShort(image));\n      }\n    if ((flags & 0x08) != 0)\n      {\n        char\n          *comment;\n\n        size_t\n          length;\n\n        /*\n          Read image comment.\n        */\n        length=ReadBlobLSBShort(image);\n        if (length != 0)\n          {\n            comment=(char *) AcquireQuantumMemory(length,sizeof(*comment));\n            if (comment == (char *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            count=ReadBlob(image,length-1,(unsigned char *) comment);\n            comment[length-1]='\\0';\n            (void) SetImageProperty(image,\"comment\",comment,exception);\n            comment=DestroyString(comment);\n            if ((length & 0x01) == 0)\n              (void) ReadBlobByte(image);\n          }\n      }\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    /*\n      Allocate RLE pixels.\n    */\n    if (image->alpha_trait != UndefinedPixelTrait)\n      number_planes++;\n    number_pixels=(MagickSizeType) image->columns*image->rows;\n    number_planes_filled=(number_planes % 2 == 0) ? number_planes :\n      number_planes+1;\n    if ((number_pixels*number_planes_filled) != (size_t) (number_pixels*\n         number_planes_filled))\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixel_info=AcquireVirtualMemory(image->columns,image->rows*\n      MagickMax(number_planes_filled,4)*sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n     pixel_info_length=image->columns*image->rows*\n       MagickMax(number_planes_filled,4);\n     pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n     if ((flags & 0x01) && !(flags & 0x02))\n       {\n         ssize_t\n          j;\n\n        /*\n          Set background color.\n        */\n        p=pixels;\n        for (i=0; i < (ssize_t) number_pixels; i++)\n        {\n          if (image->alpha_trait == UndefinedPixelTrait)\n            for (j=0; j < (ssize_t) number_planes; j++)\n              *p++=background_color[j];\n          else\n            {\n              for (j=0; j < (ssize_t) (number_planes-1); j++)\n                *p++=background_color[j];\n              *p++=0;  /* initialize matte channel */\n            }\n        }\n      }\n    /*\n      Read runlength-encoded image.\n    */\n    plane=0;\n    x=0;\n    y=0;\n    opcode=ReadBlobByte(image);\n    do\n    {\n      switch (opcode & 0x3f)\n      {\n        case SkipLinesOp:\n        {\n          operand=ReadBlobByte(image);\n          if (opcode & 0x40)\n            operand=ReadBlobLSBSignedShort(image);\n          x=0;\n          y+=operand;\n          break;\n        }\n        case SetColorOp:\n        {\n          operand=ReadBlobByte(image);\n          plane=(unsigned char) operand;\n          if (plane == 255)\n            plane=(unsigned char) (number_planes-1);\n          x=0;\n          break;\n        }\n        case SkipPixelsOp:\n        {\n          operand=ReadBlobByte(image);\n          if (opcode & 0x40)\n            operand=ReadBlobLSBSignedShort(image);\n          x+=operand;\n          break;\n        }\n        case ByteDataOp:\n        {\n          operand=ReadBlobByte(image);\n          if (opcode & 0x40)\n            operand=ReadBlobLSBSignedShort(image);\n          offset=((image->rows-y-1)*image->columns*number_planes)+x*\n            number_planes+plane;\n          operand++;\n          if ((offset < 0) ||\n              (offset+((size_t) operand*number_planes) > pixel_info_length))\n            {\n              if (number_colormaps != 0)\n                colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n              pixel_info=RelinquishVirtualMemory(pixel_info);\n              ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n            }\n          p=pixels+offset;\n          for (i=0; i < (ssize_t) operand; i++)\n          {\n            pixel=(unsigned char) ReadBlobByte(image);\n            if ((y < (ssize_t) image->rows) &&\n                ((x+i) < (ssize_t) image->columns))\n              *p=pixel;\n            p+=number_planes;\n          }\n          if (operand & 0x01)\n            (void) ReadBlobByte(image);\n          x+=operand;\n          break;\n        }\n        case RunDataOp:\n        {\n          operand=ReadBlobByte(image);\n          if (opcode & 0x40)\n            operand=ReadBlobLSBSignedShort(image);\n          pixel=(unsigned char) ReadBlobByte(image);\n          (void) ReadBlobByte(image);\n          offset=((image->rows-y-1)*image->columns*number_planes)+x*\n            number_planes+plane;\n          operand++;\n          if ((offset < 0) ||\n              (offset+((size_t) operand*number_planes) > pixel_info_length))\n            {\n              if (number_colormaps != 0)\n                colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n              pixel_info=RelinquishVirtualMemory(pixel_info);\n              ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n            }\n          p=pixels+offset;\n          for (i=0; i < (ssize_t) operand; i++)\n          {\n            if ((y < (ssize_t) image->rows) &&\n                ((x+i) < (ssize_t) image->columns))\n              *p=pixel;\n            p+=number_planes;\n          }\n          x+=operand;\n          break;\n        }\n        default:\n          break;\n      }\n      opcode=ReadBlobByte(image);\n    } while (((opcode & 0x3f) != EOFOp) && (opcode != EOF));\n    if (number_colormaps != 0)\n      {\n        MagickStatusType\n          mask;\n\n        /*\n          Apply colormap affineation to image.\n        */\n        mask=(MagickStatusType) (map_length-1);\n        p=pixels;\n        x=(ssize_t) number_planes;\n        if (number_colormaps == 1)\n          for (i=0; i < (ssize_t) number_pixels; i++)\n          {\n            ValidateColormapValue(image,*p & mask,&index,exception);\n            *p=colormap[(ssize_t) index];\n            p++;\n          }\n        else\n          if ((number_planes >= 3) && (number_colormaps >= 3))\n            for (i=0; i < (ssize_t) number_pixels; i++)\n              for (x=0; x < (ssize_t) number_planes; x++)\n              {\n                ValidateColormapValue(image,(size_t) (x*map_length+\n                    (*p & mask)),&index,exception);\n                *p=colormap[(ssize_t) index];\n                p++;\n              }\n        if ((i < (ssize_t) number_pixels) || (x < (ssize_t) number_planes))\n          {\n            colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n          }\n      }\n    /*\n      Initialize image structure.\n    */\n    if (number_planes >= 3)\n      {\n        /*\n          Convert raster image to DirectClass pixel packets.\n        */\n        p=pixels;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n            SetPixelGreen(image,ScaleCharToQuantum(*p++),q);\n            SetPixelBlue(image,ScaleCharToQuantum(*p++),q);\n            if (image->alpha_trait != UndefinedPixelTrait)\n              SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n    else\n      {\n        /*\n          Create colormap.\n        */\n        if (number_colormaps == 0)\n          map_length=256;\n        if (AcquireImageColormap(image,map_length,exception) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        p=colormap;\n        if (number_colormaps == 1)\n          for (i=0; i < (ssize_t) image->colors; i++)\n          {\n            /*\n              Pseudocolor.\n            */\n            image->colormap[i].red=(MagickRealType)\n              ScaleCharToQuantum((unsigned char) i);\n            image->colormap[i].green=(MagickRealType)\n              ScaleCharToQuantum((unsigned char) i);\n            image->colormap[i].blue=(MagickRealType)\n              ScaleCharToQuantum((unsigned char) i);\n          }\n        else\n          if (number_colormaps > 1)\n            for (i=0; i < (ssize_t) image->colors; i++)\n            {\n              image->colormap[i].red=(MagickRealType)\n                ScaleCharToQuantum(*p);\n              image->colormap[i].green=(MagickRealType)\n                ScaleCharToQuantum(*(p+map_length));\n              image->colormap[i].blue=(MagickRealType)\n                ScaleCharToQuantum(*(p+map_length*2));\n              p++;\n            }\n        p=pixels;\n        if (image->alpha_trait == UndefinedPixelTrait)\n          {\n            /*\n              Convert raster image to PseudoClass pixel packets.\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelIndex(image,*p++,q);\n                q+=GetPixelChannels(image);\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            (void) SyncImage(image,exception);\n          }\n        else\n          {\n            /*\n              Image has a matte channel-- promote to DirectClass.\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                ValidateColormapValue(image,(ssize_t) *p++,&index,exception);\n                SetPixelRed(image,ClampToQuantum(image->colormap[(ssize_t)\n                  index].red),q);\n                ValidateColormapValue(image,(ssize_t) *p++,&index,exception);\n                SetPixelGreen(image,ClampToQuantum(image->colormap[(ssize_t)\n                  index].green),q);\n                ValidateColormapValue(image,(ssize_t) *p++,&index,exception);\n                SetPixelBlue(image,ClampToQuantum(image->colormap[(ssize_t)\n                  index].blue),q);\n                SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);\n                q+=GetPixelChannels(image);\n              }\n              if (x < (ssize_t) image->columns)\n                break;\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            image->colormap=(PixelInfo *) RelinquishMagickMemory(\n              image->colormap);\n            image->storage_class=DirectClass;\n            image->colors=0;\n          }\n      }\n    if (number_colormaps != 0)\n      colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    (void) ReadBlobByte(image);\n    count=ReadBlob(image,2,(unsigned char *) magick);\n    if ((count != 0) && (memcmp(magick,\"\\122\\314\",2) == 0))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while ((count != 0) && (memcmp(magick,\"\\122\\314\",2) == 0));\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142551,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define SkipLinesOp  0x01\n#define SetColorOp  0x02\n#define SkipPixelsOp  0x03\n#define ByteDataOp  0x05\n#define RunDataOp  0x06\n#define EOFOp  0x07\n\n  char\n    magick[12];\n\n  Image\n    *image;\n\n  int\n    opcode,\n    operand,\n    status;\n\n  MagickStatusType\n    flags;\n\n  MagickSizeType\n    number_pixels;\n\n  MemoryInfo\n    *pixel_info;\n\n  Quantum\n    index;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bits_per_pixel,\n    map_length,\n    number_colormaps,\n    number_planes,\n    number_planes_filled,\n    one,\n    pixel_info_length;\n\n  ssize_t\n    count,\n    offset,\n    y;\n\n  unsigned char\n    background_color[256],\n    *colormap,\n    pixel,\n    plane,\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Determine if this a RLE file.\n  */\n  count=ReadBlob(image,2,(unsigned char *) magick);\n  if ((count != 2) || (memcmp(magick,\"\\122\\314\",2) != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  do\n  {\n    /*\n      Read image header.\n    */\n    image->page.x=ReadBlobLSBShort(image);\n    image->page.y=ReadBlobLSBShort(image);\n    image->columns=ReadBlobLSBShort(image);\n    image->rows=ReadBlobLSBShort(image);\n    flags=(MagickStatusType) ReadBlobByte(image);\n    image->alpha_trait=flags & 0x04 ? BlendPixelTrait : UndefinedPixelTrait;\n    number_planes=(size_t) ReadBlobByte(image);\n    bits_per_pixel=(size_t) ReadBlobByte(image);\n    number_colormaps=(size_t) ReadBlobByte(image);\n    map_length=(unsigned char) ReadBlobByte(image);\n    if (map_length >= 22)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    one=1;\n    map_length=one << map_length;\n    if ((number_planes == 0) || (number_planes == 2) ||\n        ((flags & 0x04) && (number_colormaps > 254)) || (bits_per_pixel != 8) ||\n        (image->columns == 0))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if (flags & 0x02)\n      {\n        /*\n          No background color-- initialize to black.\n        */\n        for (i=0; i < (ssize_t) number_planes; i++)\n          background_color[i]=0;\n        (void) ReadBlobByte(image);\n      }\n    else\n      {\n        /*\n          Initialize background color.\n        */\n        p=background_color;\n        for (i=0; i < (ssize_t) number_planes; i++)\n          *p++=(unsigned char) ReadBlobByte(image);\n      }\n    if ((number_planes & 0x01) == 0)\n      (void) ReadBlobByte(image);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    colormap=(unsigned char *) NULL;\n    if (number_colormaps != 0)\n      {\n        /*\n          Read image colormaps.\n        */\n        colormap=(unsigned char *) AcquireQuantumMemory(number_colormaps,\n          3*map_length*sizeof(*colormap));\n        if (colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        p=colormap;\n        for (i=0; i < (ssize_t) number_colormaps; i++)\n          for (x=0; x < (ssize_t) map_length; x++)\n            *p++=(unsigned char) ScaleShortToQuantum(ReadBlobLSBShort(image));\n      }\n    if ((flags & 0x08) != 0)\n      {\n        char\n          *comment;\n\n        size_t\n          length;\n\n        /*\n          Read image comment.\n        */\n        length=ReadBlobLSBShort(image);\n        if (length != 0)\n          {\n            comment=(char *) AcquireQuantumMemory(length,sizeof(*comment));\n            if (comment == (char *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            count=ReadBlob(image,length-1,(unsigned char *) comment);\n            comment[length-1]='\\0';\n            (void) SetImageProperty(image,\"comment\",comment,exception);\n            comment=DestroyString(comment);\n            if ((length & 0x01) == 0)\n              (void) ReadBlobByte(image);\n          }\n      }\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    /*\n      Allocate RLE pixels.\n    */\n    if (image->alpha_trait != UndefinedPixelTrait)\n      number_planes++;\n    number_pixels=(MagickSizeType) image->columns*image->rows;\n    number_planes_filled=(number_planes % 2 == 0) ? number_planes :\n      number_planes+1;\n    if ((number_pixels*number_planes_filled) != (size_t) (number_pixels*\n         number_planes_filled))\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixel_info=AcquireVirtualMemory(image->columns,image->rows*\n      MagickMax(number_planes_filled,4)*sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n     pixel_info_length=image->columns*image->rows*\n       MagickMax(number_planes_filled,4);\n     pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    (void) ResetMagickMemory(pixels,0,pixel_info_length);\n     if ((flags & 0x01) && !(flags & 0x02))\n       {\n         ssize_t\n          j;\n\n        /*\n          Set background color.\n        */\n        p=pixels;\n        for (i=0; i < (ssize_t) number_pixels; i++)\n        {\n          if (image->alpha_trait == UndefinedPixelTrait)\n            for (j=0; j < (ssize_t) number_planes; j++)\n              *p++=background_color[j];\n          else\n            {\n              for (j=0; j < (ssize_t) (number_planes-1); j++)\n                *p++=background_color[j];\n              *p++=0;  /* initialize matte channel */\n            }\n        }\n      }\n    /*\n      Read runlength-encoded image.\n    */\n    plane=0;\n    x=0;\n    y=0;\n    opcode=ReadBlobByte(image);\n    do\n    {\n      switch (opcode & 0x3f)\n      {\n        case SkipLinesOp:\n        {\n          operand=ReadBlobByte(image);\n          if (opcode & 0x40)\n            operand=ReadBlobLSBSignedShort(image);\n          x=0;\n          y+=operand;\n          break;\n        }\n        case SetColorOp:\n        {\n          operand=ReadBlobByte(image);\n          plane=(unsigned char) operand;\n          if (plane == 255)\n            plane=(unsigned char) (number_planes-1);\n          x=0;\n          break;\n        }\n        case SkipPixelsOp:\n        {\n          operand=ReadBlobByte(image);\n          if (opcode & 0x40)\n            operand=ReadBlobLSBSignedShort(image);\n          x+=operand;\n          break;\n        }\n        case ByteDataOp:\n        {\n          operand=ReadBlobByte(image);\n          if (opcode & 0x40)\n            operand=ReadBlobLSBSignedShort(image);\n          offset=((image->rows-y-1)*image->columns*number_planes)+x*\n            number_planes+plane;\n          operand++;\n          if ((offset < 0) ||\n              (offset+((size_t) operand*number_planes) > pixel_info_length))\n            {\n              if (number_colormaps != 0)\n                colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n              pixel_info=RelinquishVirtualMemory(pixel_info);\n              ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n            }\n          p=pixels+offset;\n          for (i=0; i < (ssize_t) operand; i++)\n          {\n            pixel=(unsigned char) ReadBlobByte(image);\n            if ((y < (ssize_t) image->rows) &&\n                ((x+i) < (ssize_t) image->columns))\n              *p=pixel;\n            p+=number_planes;\n          }\n          if (operand & 0x01)\n            (void) ReadBlobByte(image);\n          x+=operand;\n          break;\n        }\n        case RunDataOp:\n        {\n          operand=ReadBlobByte(image);\n          if (opcode & 0x40)\n            operand=ReadBlobLSBSignedShort(image);\n          pixel=(unsigned char) ReadBlobByte(image);\n          (void) ReadBlobByte(image);\n          offset=((image->rows-y-1)*image->columns*number_planes)+x*\n            number_planes+plane;\n          operand++;\n          if ((offset < 0) ||\n              (offset+((size_t) operand*number_planes) > pixel_info_length))\n            {\n              if (number_colormaps != 0)\n                colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n              pixel_info=RelinquishVirtualMemory(pixel_info);\n              ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n            }\n          p=pixels+offset;\n          for (i=0; i < (ssize_t) operand; i++)\n          {\n            if ((y < (ssize_t) image->rows) &&\n                ((x+i) < (ssize_t) image->columns))\n              *p=pixel;\n            p+=number_planes;\n          }\n          x+=operand;\n          break;\n        }\n        default:\n          break;\n      }\n      opcode=ReadBlobByte(image);\n    } while (((opcode & 0x3f) != EOFOp) && (opcode != EOF));\n    if (number_colormaps != 0)\n      {\n        MagickStatusType\n          mask;\n\n        /*\n          Apply colormap affineation to image.\n        */\n        mask=(MagickStatusType) (map_length-1);\n        p=pixels;\n        x=(ssize_t) number_planes;\n        if (number_colormaps == 1)\n          for (i=0; i < (ssize_t) number_pixels; i++)\n          {\n            ValidateColormapValue(image,*p & mask,&index,exception);\n            *p=colormap[(ssize_t) index];\n            p++;\n          }\n        else\n          if ((number_planes >= 3) && (number_colormaps >= 3))\n            for (i=0; i < (ssize_t) number_pixels; i++)\n              for (x=0; x < (ssize_t) number_planes; x++)\n              {\n                ValidateColormapValue(image,(size_t) (x*map_length+\n                    (*p & mask)),&index,exception);\n                *p=colormap[(ssize_t) index];\n                p++;\n              }\n        if ((i < (ssize_t) number_pixels) || (x < (ssize_t) number_planes))\n          {\n            colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n          }\n      }\n    /*\n      Initialize image structure.\n    */\n    if (number_planes >= 3)\n      {\n        /*\n          Convert raster image to DirectClass pixel packets.\n        */\n        p=pixels;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n            SetPixelGreen(image,ScaleCharToQuantum(*p++),q);\n            SetPixelBlue(image,ScaleCharToQuantum(*p++),q);\n            if (image->alpha_trait != UndefinedPixelTrait)\n              SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n    else\n      {\n        /*\n          Create colormap.\n        */\n        if (number_colormaps == 0)\n          map_length=256;\n        if (AcquireImageColormap(image,map_length,exception) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        p=colormap;\n        if (number_colormaps == 1)\n          for (i=0; i < (ssize_t) image->colors; i++)\n          {\n            /*\n              Pseudocolor.\n            */\n            image->colormap[i].red=(MagickRealType)\n              ScaleCharToQuantum((unsigned char) i);\n            image->colormap[i].green=(MagickRealType)\n              ScaleCharToQuantum((unsigned char) i);\n            image->colormap[i].blue=(MagickRealType)\n              ScaleCharToQuantum((unsigned char) i);\n          }\n        else\n          if (number_colormaps > 1)\n            for (i=0; i < (ssize_t) image->colors; i++)\n            {\n              image->colormap[i].red=(MagickRealType)\n                ScaleCharToQuantum(*p);\n              image->colormap[i].green=(MagickRealType)\n                ScaleCharToQuantum(*(p+map_length));\n              image->colormap[i].blue=(MagickRealType)\n                ScaleCharToQuantum(*(p+map_length*2));\n              p++;\n            }\n        p=pixels;\n        if (image->alpha_trait == UndefinedPixelTrait)\n          {\n            /*\n              Convert raster image to PseudoClass pixel packets.\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelIndex(image,*p++,q);\n                q+=GetPixelChannels(image);\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            (void) SyncImage(image,exception);\n          }\n        else\n          {\n            /*\n              Image has a matte channel-- promote to DirectClass.\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                ValidateColormapValue(image,(ssize_t) *p++,&index,exception);\n                SetPixelRed(image,ClampToQuantum(image->colormap[(ssize_t)\n                  index].red),q);\n                ValidateColormapValue(image,(ssize_t) *p++,&index,exception);\n                SetPixelGreen(image,ClampToQuantum(image->colormap[(ssize_t)\n                  index].green),q);\n                ValidateColormapValue(image,(ssize_t) *p++,&index,exception);\n                SetPixelBlue(image,ClampToQuantum(image->colormap[(ssize_t)\n                  index].blue),q);\n                SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);\n                q+=GetPixelChannels(image);\n              }\n              if (x < (ssize_t) image->columns)\n                break;\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            image->colormap=(PixelInfo *) RelinquishMagickMemory(\n              image->colormap);\n            image->storage_class=DirectClass;\n            image->colors=0;\n          }\n      }\n    if (number_colormaps != 0)\n      colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    (void) ReadBlobByte(image);\n    count=ReadBlob(image,2,(unsigned char *) magick);\n    if ((count != 0) && (memcmp(magick,\"\\122\\314\",2) == 0))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while ((count != 0) && (memcmp(magick,\"\\122\\314\",2) == 0));\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142552,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": " int hashbin_delete( hashbin_t* hashbin, FREE_FUNC free_func)\n {\n \tirda_queue_t* queue;\n\tunsigned long flags = 0;\n\tint i;\n\n\tIRDA_ASSERT(hashbin != NULL, return -1;);\n \tIRDA_ASSERT(hashbin->magic == HB_MAGIC, return -1;);\n \n \t/* Synchronize */\n\tif ( hashbin->hb_type & HB_LOCK ) {\n\t\tspin_lock_irqsave_nested(&hashbin->hb_spinlock, flags,\n\t\t\t\t\t hashbin_lock_depth++);\n\t}\n \n \t/*\n \t *  Free the entries in the hashbin, TODO: use hashbin_clear when\n \t *  it has been shown to work\n \t */\n \tfor (i = 0; i < HASHBIN_SIZE; i ++ ) {\n\t\tqueue = dequeue_first((irda_queue_t**) &hashbin->hb_queue[i]);\n\t\twhile (queue ) {\n\t\t\tif (free_func)\n\t\t\t\t(*free_func)(queue);\n\t\t\tqueue = dequeue_first(\n\t\t\t\t(irda_queue_t**) &hashbin->hb_queue[i]);\n \t\t}\n \t}\n \n\t/* Cleanup local data */\n\thashbin->hb_current = NULL;\n \thashbin->magic = ~HB_MAGIC;\n \n \t/* Release lock */\n\tif ( hashbin->hb_type & HB_LOCK) {\n \t\tspin_unlock_irqrestore(&hashbin->hb_spinlock, flags);\n#ifdef CONFIG_LOCKDEP\n\t\thashbin_lock_depth--;\n#endif\n\t}\n \n \t/*\n \t *  Free the hashbin structure\n\t */\n\tkfree(hashbin);\n\n\treturn 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142633,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": " int hashbin_delete( hashbin_t* hashbin, FREE_FUNC free_func)\n {\n \tirda_queue_t* queue;\n\tunsigned long flags = 0;\n\tint i;\n\n\tIRDA_ASSERT(hashbin != NULL, return -1;);\n \tIRDA_ASSERT(hashbin->magic == HB_MAGIC, return -1;);\n \n \t/* Synchronize */\n\tif (hashbin->hb_type & HB_LOCK)\n\t\tspin_lock_irqsave(&hashbin->hb_spinlock, flags);\n \n \t/*\n \t *  Free the entries in the hashbin, TODO: use hashbin_clear when\n \t *  it has been shown to work\n \t */\n \tfor (i = 0; i < HASHBIN_SIZE; i ++ ) {\n\t\twhile (1) {\n\t\t\tqueue = dequeue_first((irda_queue_t**) &hashbin->hb_queue[i]);\n\n\t\t\tif (!queue)\n\t\t\t\tbreak;\n\n\t\t\tif (free_func) {\n\t\t\t\tif (hashbin->hb_type & HB_LOCK)\n\t\t\t\t\tspin_unlock_irqrestore(&hashbin->hb_spinlock, flags);\n\t\t\t\tfree_func(queue);\n\t\t\t\tif (hashbin->hb_type & HB_LOCK)\n\t\t\t\t\tspin_lock_irqsave(&hashbin->hb_spinlock, flags);\n\t\t\t}\n \t\t}\n \t}\n \n\t/* Cleanup local data */\n\thashbin->hb_current = NULL;\n \thashbin->magic = ~HB_MAGIC;\n \n \t/* Release lock */\n\tif (hashbin->hb_type & HB_LOCK)\n \t\tspin_unlock_irqrestore(&hashbin->hb_spinlock, flags);\n \n \t/*\n \t *  Free the hashbin structure\n\t */\n\tkfree(hashbin);\n\n\treturn 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142634,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": " static void pipe_advance(struct iov_iter *i, size_t size)\n {\n \tstruct pipe_inode_info *pipe = i->pipe;\n\tstruct pipe_buffer *buf;\n\tint idx = i->idx;\n\tsize_t off = i->iov_offset, orig_sz;\n \tif (unlikely(i->count < size))\n \t\tsize = i->count;\n\torig_sz = size;\n \tif (size) {\n \t\tif (off) /* make it relative to the beginning of buffer */\n\t\t\tsize += off - pipe->bufs[idx].offset;\n \t\twhile (1) {\n \t\t\tbuf = &pipe->bufs[idx];\n\t\t\tif (size <= buf->len)\n \t\t\t\tbreak;\n\t\t\tsize -= buf->len;\n \t\t\tidx = next_idx(idx, pipe);\n \t\t}\n\t\tbuf->len = size;\n \t\ti->idx = idx;\n\t\toff = i->iov_offset = buf->offset + size;\n\t}\n\tif (off)\n\t\tidx = next_idx(idx, pipe);\n\tif (pipe->nrbufs) {\n\t\tint unused = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);\n\t\t/* [curbuf,unused) is in use.  Free [idx,unused) */\n\t\twhile (idx != unused) {\n\t\t\tpipe_buf_release(pipe, &pipe->bufs[idx]);\n\t\t\tidx = next_idx(idx, pipe);\n\t\t\tpipe->nrbufs--;\n\t\t}\n \t}\n\ti->count -= orig_sz;\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142655,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": " static void pipe_advance(struct iov_iter *i, size_t size)\n {\n \tstruct pipe_inode_info *pipe = i->pipe;\n \tif (unlikely(i->count < size))\n \t\tsize = i->count;\n \tif (size) {\n\t\tstruct pipe_buffer *buf;\n\t\tsize_t off = i->iov_offset, left = size;\n\t\tint idx = i->idx;\n \t\tif (off) /* make it relative to the beginning of buffer */\n\t\t\tleft += off - pipe->bufs[idx].offset;\n \t\twhile (1) {\n \t\t\tbuf = &pipe->bufs[idx];\n\t\t\tif (left <= buf->len)\n \t\t\t\tbreak;\n\t\t\tleft -= buf->len;\n \t\t\tidx = next_idx(idx, pipe);\n \t\t}\n \t\ti->idx = idx;\n\t\ti->iov_offset = buf->offset + left;\n \t}\n\ti->count -= size;\n\t/* ... and discard everything past that point */\n\tpipe_truncate(i);\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142656,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "entry_guard_obeys_restriction(const entry_guard_t *guard,\n                              const entry_guard_restriction_t *rst)\n{\n  tor_assert(guard);\n   if (! rst)\n     return 1; // No restriction?  No problem.\n \n   return tor_memneq(guard->identity, rst->exclude_id, DIGEST_LEN);\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142679,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "entry_guard_obeys_restriction(const entry_guard_t *guard,\n                              const entry_guard_restriction_t *rst)\n{\n  tor_assert(guard);\n   if (! rst)\n     return 1; // No restriction?  No problem.\n \n  // Only one kind of restriction exists right now: excluding an exit\n  // ID and all of its family.\n  const node_t *node = node_get_by_id((const char*)rst->exclude_id);\n  if (node && guard_in_node_family(guard, node))\n    return 0;\n\n   return tor_memneq(guard->identity, rst->exclude_id, DIGEST_LEN);\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142680,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int ipddp_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n        struct ipddp_route __user *rt = ifr->ifr_data;\n        struct ipddp_route rcp, rcp2, *rp;\n\n        if(!capable(CAP_NET_ADMIN))\n                return -EPERM;\n\n\tif(copy_from_user(&rcp, rt, sizeof(rcp)))\n\t\treturn -EFAULT;\n\n        switch(cmd)\n        {\n\t\tcase SIOCADDIPDDPRT:\n                        return ipddp_create(&rcp);\n\n                 case SIOCFINDIPDDPRT:\n \t\t\tspin_lock_bh(&ipddp_route_lock);\n \t\t\trp = __ipddp_find_route(&rcp);\n\t\t\tif (rp)\n\t\t\t\tmemcpy(&rcp2, rp, sizeof(rcp2));\n \t\t\tspin_unlock_bh(&ipddp_route_lock);\n \n \t\t\tif (rp) {\n\t\t\t\tif (copy_to_user(rt, &rcp2,\n\t\t\t\t\t\t sizeof(struct ipddp_route)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\treturn -ENOENT;\n\n                case SIOCDELIPDDPRT:\n                        return ipddp_delete(&rcp);\n\n                default:\n                        return -EINVAL;\n        }\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142861,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int ipddp_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n        struct ipddp_route __user *rt = ifr->ifr_data;\n        struct ipddp_route rcp, rcp2, *rp;\n\n        if(!capable(CAP_NET_ADMIN))\n                return -EPERM;\n\n\tif(copy_from_user(&rcp, rt, sizeof(rcp)))\n\t\treturn -EFAULT;\n\n        switch(cmd)\n        {\n\t\tcase SIOCADDIPDDPRT:\n                        return ipddp_create(&rcp);\n\n                 case SIOCFINDIPDDPRT:\n \t\t\tspin_lock_bh(&ipddp_route_lock);\n \t\t\trp = __ipddp_find_route(&rcp);\n\t\t\tif (rp) {\n\t\t\t\tmemset(&rcp2, 0, sizeof(rcp2));\n\t\t\t\trcp2.ip    = rp->ip;\n\t\t\t\trcp2.at    = rp->at;\n\t\t\t\trcp2.flags = rp->flags;\n\t\t\t}\n \t\t\tspin_unlock_bh(&ipddp_route_lock);\n \n \t\t\tif (rp) {\n\t\t\t\tif (copy_to_user(rt, &rcp2,\n\t\t\t\t\t\t sizeof(struct ipddp_route)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\treturn -ENOENT;\n\n                case SIOCDELIPDDPRT:\n                        return ipddp_delete(&rcp);\n\n                default:\n                        return -EINVAL;\n        }\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142862,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "int config__parse_args(struct mosquitto_db *db, struct mosquitto__config *config, int argc, char *argv[])\n{\n\tint i;\n\tint port_tmp;\n\n\tfor(i=1; i<argc; i++){\n\t\tif(!strcmp(argv[i], \"-c\") || !strcmp(argv[i], \"--config-file\")){\n\t\t\tif(i<argc-1){\n\t\t\t\tdb->config_file = argv[i+1];\n\n\t\t\t\tif(config__read(db, config, false)){\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Unable to open configuration file.\");\n\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: -c argument given, but no config file specified.\");\n\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t}\n\t\t\ti++;\n\t\t}else if(!strcmp(argv[i], \"-d\") || !strcmp(argv[i], \"--daemon\")){\n\t\t\tconfig->daemon = true;\n\t\t}else if(!strcmp(argv[i], \"-h\") || !strcmp(argv[i], \"--help\")){\n\t\t\tprint_usage();\n\t\t\treturn MOSQ_ERR_INVAL;\n\t\t}else if(!strcmp(argv[i], \"-p\") || !strcmp(argv[i], \"--port\")){\n\t\t\tif(i<argc-1){\n\t\t\t\tport_tmp = atoi(argv[i+1]);\n\t\t\t\tif(port_tmp<1 || port_tmp>65535){\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid port specified (%d).\", port_tmp);\n\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t}else{\n\t\t\t\t\tif(config->default_listener.port){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Default listener port specified multiple times. Only the latest will be used.\");\n\t\t\t\t\t}\n\t\t\t\t\tconfig->default_listener.port = port_tmp;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: -p argument given, but no port specified.\");\n\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t}\n\t\t\ti++;\n\t\t}else if(!strcmp(argv[i], \"-v\") || !strcmp(argv[i], \"--verbose\")){\n\t\t\tdb->verbose = true;\n\t\t}else{\n\t\t\tfprintf(stderr, \"Error: Unknown option '%s'.\\n\",argv[i]);\n\t\t\tprint_usage();\n\t\t\treturn MOSQ_ERR_INVAL;\n\t\t}\n\t}\n\n\tif(config->listener_count == 0\n#ifdef WITH_TLS\n\t\t\t|| config->default_listener.cafile\n\t\t\t|| config->default_listener.capath\n\t\t\t|| config->default_listener.certfile\n\t\t\t|| config->default_listener.keyfile\n\t\t\t|| config->default_listener.ciphers\n\t\t\t|| config->default_listener.psk_hint\n\t\t\t|| config->default_listener.require_certificate\n\t\t\t|| config->default_listener.crlfile\n\t\t\t|| config->default_listener.use_identity_as_username\n\t\t\t|| config->default_listener.use_subject_as_username\n#endif\n\t\t\t|| config->default_listener.use_username_as_clientid\n\t\t\t|| config->default_listener.host\n\t\t\t|| config->default_listener.port\n\t\t\t|| config->default_listener.max_connections != -1\n\t\t\t|| config->default_listener.mount_point\n\t\t\t|| config->default_listener.protocol != mp_mqtt\n\t\t\t|| config->default_listener.socket_domain\n\t\t\t|| config->default_listener.security_options.password_file\n\t\t\t|| config->default_listener.security_options.psk_file\n\t\t\t|| config->default_listener.security_options.auth_plugin_config_count\n\t\t\t|| config->default_listener.security_options.allow_anonymous != -1\n\t\t\t){\n\n\t\tconfig->listener_count++;\n\t\tconfig->listeners = mosquitto__realloc(config->listeners, sizeof(struct mosquitto__listener)*config->listener_count);\n\t\tif(!config->listeners){\n\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t}\n\t\tmemset(&config->listeners[config->listener_count-1], 0, sizeof(struct mosquitto__listener));\n\t\tif(config->default_listener.port){\n\t\t\tconfig->listeners[config->listener_count-1].port = config->default_listener.port;\n\t\t}else{\n\t\t\tconfig->listeners[config->listener_count-1].port = 1883;\n\t\t}\n\t\tif(config->default_listener.host){\n\t\t\tconfig->listeners[config->listener_count-1].host = config->default_listener.host;\n\t\t}else{\n\t\t\tconfig->listeners[config->listener_count-1].host = NULL;\n\t\t}\n\t\tif(config->default_listener.mount_point){\n\t\t\tconfig->listeners[config->listener_count-1].mount_point = config->default_listener.mount_point;\n\t\t}else{\n\t\t\tconfig->listeners[config->listener_count-1].mount_point = NULL;\n\t\t}\n\t\tconfig->listeners[config->listener_count-1].max_connections = config->default_listener.max_connections;\n\t\tconfig->listeners[config->listener_count-1].protocol = config->default_listener.protocol;\n\t\tconfig->listeners[config->listener_count-1].socket_domain = config->default_listener.socket_domain;\n\t\tconfig->listeners[config->listener_count-1].client_count = 0;\n\t\tconfig->listeners[config->listener_count-1].socks = NULL;\n\t\tconfig->listeners[config->listener_count-1].sock_count = 0;\n\t\tconfig->listeners[config->listener_count-1].client_count = 0;\n\t\tconfig->listeners[config->listener_count-1].use_username_as_clientid = config->default_listener.use_username_as_clientid;\n#ifdef WITH_TLS\n\t\tconfig->listeners[config->listener_count-1].tls_version = config->default_listener.tls_version;\n\t\tconfig->listeners[config->listener_count-1].cafile = config->default_listener.cafile;\n\t\tconfig->listeners[config->listener_count-1].capath = config->default_listener.capath;\n\t\tconfig->listeners[config->listener_count-1].certfile = config->default_listener.certfile;\n\t\tconfig->listeners[config->listener_count-1].keyfile = config->default_listener.keyfile;\n\t\tconfig->listeners[config->listener_count-1].ciphers = config->default_listener.ciphers;\n\t\tconfig->listeners[config->listener_count-1].psk_hint = config->default_listener.psk_hint;\n\t\tconfig->listeners[config->listener_count-1].require_certificate = config->default_listener.require_certificate;\n\t\tconfig->listeners[config->listener_count-1].ssl_ctx = NULL;\n\t\tconfig->listeners[config->listener_count-1].crlfile = config->default_listener.crlfile;\n \t\tconfig->listeners[config->listener_count-1].use_identity_as_username = config->default_listener.use_identity_as_username;\n \t\tconfig->listeners[config->listener_count-1].use_subject_as_username = config->default_listener.use_subject_as_username;\n #endif\n \t\tconfig->listeners[config->listener_count-1].security_options.password_file = config->default_listener.security_options.password_file;\n \t\tconfig->listeners[config->listener_count-1].security_options.psk_file = config->default_listener.security_options.psk_file;\n \t\tconfig->listeners[config->listener_count-1].security_options.auth_plugin_configs = config->default_listener.security_options.auth_plugin_configs;\n\t\tconfig->listeners[config->listener_count-1].security_options.auth_plugin_config_count = config->default_listener.security_options.auth_plugin_config_count;\n\t\tconfig->listeners[config->listener_count-1].security_options.allow_anonymous = config->default_listener.security_options.allow_anonymous;\n\t}\n\n\t/* Default to drop to mosquitto user if we are privileged and no user specified. */\n\tif(!config->user){\n\t\tconfig->user = \"mosquitto\";\n\t}\n\tif(db->verbose){\n\t\tconfig->log_type = INT_MAX;\n\t}\n\treturn config__check(config);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142865,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "int config__parse_args(struct mosquitto_db *db, struct mosquitto__config *config, int argc, char *argv[])\n{\n\tint i;\n\tint port_tmp;\n\n\tfor(i=1; i<argc; i++){\n\t\tif(!strcmp(argv[i], \"-c\") || !strcmp(argv[i], \"--config-file\")){\n\t\t\tif(i<argc-1){\n\t\t\t\tdb->config_file = argv[i+1];\n\n\t\t\t\tif(config__read(db, config, false)){\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Unable to open configuration file.\");\n\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: -c argument given, but no config file specified.\");\n\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t}\n\t\t\ti++;\n\t\t}else if(!strcmp(argv[i], \"-d\") || !strcmp(argv[i], \"--daemon\")){\n\t\t\tconfig->daemon = true;\n\t\t}else if(!strcmp(argv[i], \"-h\") || !strcmp(argv[i], \"--help\")){\n\t\t\tprint_usage();\n\t\t\treturn MOSQ_ERR_INVAL;\n\t\t}else if(!strcmp(argv[i], \"-p\") || !strcmp(argv[i], \"--port\")){\n\t\t\tif(i<argc-1){\n\t\t\t\tport_tmp = atoi(argv[i+1]);\n\t\t\t\tif(port_tmp<1 || port_tmp>65535){\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid port specified (%d).\", port_tmp);\n\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t}else{\n\t\t\t\t\tif(config->default_listener.port){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Default listener port specified multiple times. Only the latest will be used.\");\n\t\t\t\t\t}\n\t\t\t\t\tconfig->default_listener.port = port_tmp;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: -p argument given, but no port specified.\");\n\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t}\n\t\t\ti++;\n\t\t}else if(!strcmp(argv[i], \"-v\") || !strcmp(argv[i], \"--verbose\")){\n\t\t\tdb->verbose = true;\n\t\t}else{\n\t\t\tfprintf(stderr, \"Error: Unknown option '%s'.\\n\",argv[i]);\n\t\t\tprint_usage();\n\t\t\treturn MOSQ_ERR_INVAL;\n\t\t}\n\t}\n\n\tif(config->listener_count == 0\n#ifdef WITH_TLS\n\t\t\t|| config->default_listener.cafile\n\t\t\t|| config->default_listener.capath\n\t\t\t|| config->default_listener.certfile\n\t\t\t|| config->default_listener.keyfile\n\t\t\t|| config->default_listener.ciphers\n\t\t\t|| config->default_listener.psk_hint\n\t\t\t|| config->default_listener.require_certificate\n\t\t\t|| config->default_listener.crlfile\n\t\t\t|| config->default_listener.use_identity_as_username\n\t\t\t|| config->default_listener.use_subject_as_username\n#endif\n\t\t\t|| config->default_listener.use_username_as_clientid\n\t\t\t|| config->default_listener.host\n\t\t\t|| config->default_listener.port\n\t\t\t|| config->default_listener.max_connections != -1\n\t\t\t|| config->default_listener.mount_point\n\t\t\t|| config->default_listener.protocol != mp_mqtt\n\t\t\t|| config->default_listener.socket_domain\n\t\t\t|| config->default_listener.security_options.password_file\n\t\t\t|| config->default_listener.security_options.psk_file\n\t\t\t|| config->default_listener.security_options.auth_plugin_config_count\n\t\t\t|| config->default_listener.security_options.allow_anonymous != -1\n\t\t\t){\n\n\t\tconfig->listener_count++;\n\t\tconfig->listeners = mosquitto__realloc(config->listeners, sizeof(struct mosquitto__listener)*config->listener_count);\n\t\tif(!config->listeners){\n\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t}\n\t\tmemset(&config->listeners[config->listener_count-1], 0, sizeof(struct mosquitto__listener));\n\t\tif(config->default_listener.port){\n\t\t\tconfig->listeners[config->listener_count-1].port = config->default_listener.port;\n\t\t}else{\n\t\t\tconfig->listeners[config->listener_count-1].port = 1883;\n\t\t}\n\t\tif(config->default_listener.host){\n\t\t\tconfig->listeners[config->listener_count-1].host = config->default_listener.host;\n\t\t}else{\n\t\t\tconfig->listeners[config->listener_count-1].host = NULL;\n\t\t}\n\t\tif(config->default_listener.mount_point){\n\t\t\tconfig->listeners[config->listener_count-1].mount_point = config->default_listener.mount_point;\n\t\t}else{\n\t\t\tconfig->listeners[config->listener_count-1].mount_point = NULL;\n\t\t}\n\t\tconfig->listeners[config->listener_count-1].max_connections = config->default_listener.max_connections;\n\t\tconfig->listeners[config->listener_count-1].protocol = config->default_listener.protocol;\n\t\tconfig->listeners[config->listener_count-1].socket_domain = config->default_listener.socket_domain;\n\t\tconfig->listeners[config->listener_count-1].client_count = 0;\n\t\tconfig->listeners[config->listener_count-1].socks = NULL;\n\t\tconfig->listeners[config->listener_count-1].sock_count = 0;\n\t\tconfig->listeners[config->listener_count-1].client_count = 0;\n\t\tconfig->listeners[config->listener_count-1].use_username_as_clientid = config->default_listener.use_username_as_clientid;\n#ifdef WITH_TLS\n\t\tconfig->listeners[config->listener_count-1].tls_version = config->default_listener.tls_version;\n\t\tconfig->listeners[config->listener_count-1].cafile = config->default_listener.cafile;\n\t\tconfig->listeners[config->listener_count-1].capath = config->default_listener.capath;\n\t\tconfig->listeners[config->listener_count-1].certfile = config->default_listener.certfile;\n\t\tconfig->listeners[config->listener_count-1].keyfile = config->default_listener.keyfile;\n\t\tconfig->listeners[config->listener_count-1].ciphers = config->default_listener.ciphers;\n\t\tconfig->listeners[config->listener_count-1].psk_hint = config->default_listener.psk_hint;\n\t\tconfig->listeners[config->listener_count-1].require_certificate = config->default_listener.require_certificate;\n\t\tconfig->listeners[config->listener_count-1].ssl_ctx = NULL;\n\t\tconfig->listeners[config->listener_count-1].crlfile = config->default_listener.crlfile;\n \t\tconfig->listeners[config->listener_count-1].use_identity_as_username = config->default_listener.use_identity_as_username;\n \t\tconfig->listeners[config->listener_count-1].use_subject_as_username = config->default_listener.use_subject_as_username;\n #endif\n\t\tconfig->listeners[config->listener_count-1].security_options.acl_file = config->default_listener.security_options.acl_file;\n \t\tconfig->listeners[config->listener_count-1].security_options.password_file = config->default_listener.security_options.password_file;\n \t\tconfig->listeners[config->listener_count-1].security_options.psk_file = config->default_listener.security_options.psk_file;\n \t\tconfig->listeners[config->listener_count-1].security_options.auth_plugin_configs = config->default_listener.security_options.auth_plugin_configs;\n\t\tconfig->listeners[config->listener_count-1].security_options.auth_plugin_config_count = config->default_listener.security_options.auth_plugin_config_count;\n\t\tconfig->listeners[config->listener_count-1].security_options.allow_anonymous = config->default_listener.security_options.allow_anonymous;\n\t}\n\n\t/* Default to drop to mosquitto user if we are privileged and no user specified. */\n\tif(!config->user){\n\t\tconfig->user = \"mosquitto\";\n\t}\n\tif(db->verbose){\n\t\tconfig->log_type = INT_MAX;\n\t}\n\treturn config__check(config);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142866,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": " static int crypto_report_one(struct crypto_alg *alg,\n \t\t\t     struct crypto_user_alg *ualg, struct sk_buff *skb)\n {\n\tstrlcpy(ualg->cru_name, alg->cra_name, sizeof(ualg->cru_name));\n\tstrlcpy(ualg->cru_driver_name, alg->cra_driver_name,\n \t\tsizeof(ualg->cru_driver_name));\n\tstrlcpy(ualg->cru_module_name, module_name(alg->cra_module),\n \t\tsizeof(ualg->cru_module_name));\n \n \tualg->cru_type = 0;\n\tualg->cru_mask = 0;\n\tualg->cru_flags = alg->cra_flags;\n\tualg->cru_refcnt = refcount_read(&alg->cra_refcnt);\n\n\tif (nla_put_u32(skb, CRYPTOCFGA_PRIORITY_VAL, alg->cra_priority))\n\t\tgoto nla_put_failure;\n \tif (alg->cra_flags & CRYPTO_ALG_LARVAL) {\n \t\tstruct crypto_report_larval rl;\n \n\t\tstrlcpy(rl.type, \"larval\", sizeof(rl.type));\n \t\tif (nla_put(skb, CRYPTOCFGA_REPORT_LARVAL,\n \t\t\t    sizeof(struct crypto_report_larval), &rl))\n \t\t\tgoto nla_put_failure;\n\t\tgoto out;\n\t}\n\n\tif (alg->cra_type && alg->cra_type->report) {\n\t\tif (alg->cra_type->report(skb, alg))\n\t\t\tgoto nla_put_failure;\n\n\t\tgoto out;\n\t}\n\n\tswitch (alg->cra_flags & (CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_LARVAL)) {\n\tcase CRYPTO_ALG_TYPE_CIPHER:\n\t\tif (crypto_report_cipher(skb, alg))\n\t\t\tgoto nla_put_failure;\n\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_COMPRESS:\n\t\tif (crypto_report_comp(skb, alg))\n\t\t\tgoto nla_put_failure;\n\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_ACOMPRESS:\n\t\tif (crypto_report_acomp(skb, alg))\n\t\t\tgoto nla_put_failure;\n\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_AKCIPHER:\n\t\tif (crypto_report_akcipher(skb, alg))\n\t\t\tgoto nla_put_failure;\n\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_KPP:\n\t\tif (crypto_report_kpp(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\t}\n\nout:\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142867,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": " static int crypto_report_one(struct crypto_alg *alg,\n \t\t\t     struct crypto_user_alg *ualg, struct sk_buff *skb)\n {\n\tstrncpy(ualg->cru_name, alg->cra_name, sizeof(ualg->cru_name));\n\tstrncpy(ualg->cru_driver_name, alg->cra_driver_name,\n \t\tsizeof(ualg->cru_driver_name));\n\tstrncpy(ualg->cru_module_name, module_name(alg->cra_module),\n \t\tsizeof(ualg->cru_module_name));\n \n \tualg->cru_type = 0;\n\tualg->cru_mask = 0;\n\tualg->cru_flags = alg->cra_flags;\n\tualg->cru_refcnt = refcount_read(&alg->cra_refcnt);\n\n\tif (nla_put_u32(skb, CRYPTOCFGA_PRIORITY_VAL, alg->cra_priority))\n\t\tgoto nla_put_failure;\n \tif (alg->cra_flags & CRYPTO_ALG_LARVAL) {\n \t\tstruct crypto_report_larval rl;\n \n\t\tstrncpy(rl.type, \"larval\", sizeof(rl.type));\n \t\tif (nla_put(skb, CRYPTOCFGA_REPORT_LARVAL,\n \t\t\t    sizeof(struct crypto_report_larval), &rl))\n \t\t\tgoto nla_put_failure;\n\t\tgoto out;\n\t}\n\n\tif (alg->cra_type && alg->cra_type->report) {\n\t\tif (alg->cra_type->report(skb, alg))\n\t\t\tgoto nla_put_failure;\n\n\t\tgoto out;\n\t}\n\n\tswitch (alg->cra_flags & (CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_LARVAL)) {\n\tcase CRYPTO_ALG_TYPE_CIPHER:\n\t\tif (crypto_report_cipher(skb, alg))\n\t\t\tgoto nla_put_failure;\n\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_COMPRESS:\n\t\tif (crypto_report_comp(skb, alg))\n\t\t\tgoto nla_put_failure;\n\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_ACOMPRESS:\n\t\tif (crypto_report_acomp(skb, alg))\n\t\t\tgoto nla_put_failure;\n\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_AKCIPHER:\n\t\tif (crypto_report_akcipher(skb, alg))\n\t\t\tgoto nla_put_failure;\n\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_KPP:\n\t\tif (crypto_report_kpp(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\t}\n\nout:\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142868,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int cdrom_ioctl_select_disc(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_SELECT_DISC\\n\");\n\n\tif (!CDROM_CAN(CDC_SELECT_DISC))\n \t\treturn -ENOSYS;\n \n \tif (arg != CDSL_CURRENT && arg != CDSL_NONE) {\n\t\tif ((int)arg >= cdi->capacity)\n \t\t\treturn -EINVAL;\n \t}\n \n\t/*\n\t * ->select_disc is a hook to allow a driver-specific way of\n\t * seleting disc.  However, since there is no equivalent hook for\n\t * cdrom_slot_status this may not actually be useful...\n\t */\n\tif (cdi->ops->select_disc)\n\t\treturn cdi->ops->select_disc(cdi, arg);\n\n\tcd_dbg(CD_CHANGER, \"Using generic cdrom_select_disc()\\n\");\n\treturn cdrom_select_disc(cdi, arg);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142883,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int cdrom_ioctl_select_disc(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_SELECT_DISC\\n\");\n\n\tif (!CDROM_CAN(CDC_SELECT_DISC))\n \t\treturn -ENOSYS;\n \n \tif (arg != CDSL_CURRENT && arg != CDSL_NONE) {\n\t\tif (arg >= cdi->capacity)\n \t\t\treturn -EINVAL;\n \t}\n \n\t/*\n\t * ->select_disc is a hook to allow a driver-specific way of\n\t * seleting disc.  However, since there is no equivalent hook for\n\t * cdrom_slot_status this may not actually be useful...\n\t */\n\tif (cdi->ops->select_disc)\n\t\treturn cdi->ops->select_disc(cdi, arg);\n\n\tcd_dbg(CD_CHANGER, \"Using generic cdrom_select_disc()\\n\");\n\treturn cdrom_select_disc(cdi, arg);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142884,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "userauth_hostbased(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tstruct sshbuf *b;\n\tstruct sshkey *key = NULL;\n\tchar *pkalg, *cuser, *chost;\n\tu_char *pkblob, *sig;\n \tsize_t alen, blen, slen;\n \tint r, pktype, authenticated = 0;\n \n\tif (!authctxt->valid) {\n\t\tdebug2(\"%s: disabled because of invalid user\", __func__);\n\t\treturn 0;\n\t}\n \t/* XXX use sshkey_froms() */\n \tif ((r = sshpkt_get_cstring(ssh, &pkalg, &alen)) != 0 ||\n \t    (r = sshpkt_get_string(ssh, &pkblob, &blen)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, &chost, NULL)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, &cuser, NULL)) != 0 ||\n\t    (r = sshpkt_get_string(ssh, &sig, &slen)) != 0)\n\t\tfatal(\"%s: packet parsing: %s\", __func__, ssh_err(r));\n\n\tdebug(\"%s: cuser %s chost %s pkalg %s slen %zu\", __func__,\n\t    cuser, chost, pkalg, slen);\n#ifdef DEBUG_PK\n\tdebug(\"signature:\");\n\tsshbuf_dump_data(sig, siglen, stderr);\n#endif\n\tpktype = sshkey_type_from_name(pkalg);\n\tif (pktype == KEY_UNSPEC) {\n\t\t/* this is perfectly legal */\n\t\tlogit(\"%s: unsupported public key algorithm: %s\",\n\t\t    __func__, pkalg);\n\t\tgoto done;\n\t}\n\tif ((r = sshkey_from_blob(pkblob, blen, &key)) != 0) {\n\t\terror(\"%s: key_from_blob: %s\", __func__, ssh_err(r));\n\t\tgoto done;\n\t}\n\tif (key == NULL) {\n\t\terror(\"%s: cannot decode key: %s\", __func__, pkalg);\n\t\tgoto done;\n\t}\n\tif (key->type != pktype) {\n\t\terror(\"%s: type mismatch for decoded key \"\n\t\t    \"(received %d, expected %d)\", __func__, key->type, pktype);\n\t\tgoto done;\n\t}\n\tif (sshkey_type_plain(key->type) == KEY_RSA &&\n\t    (ssh->compat & SSH_BUG_RSASIGMD5) != 0) {\n\t\terror(\"Refusing RSA key because peer uses unsafe \"\n\t\t    \"signature format\");\n\t\tgoto done;\n\t}\n\tif (match_pattern_list(pkalg, options.hostbased_key_types, 0) != 1) {\n\t\tlogit(\"%s: key type %s not in HostbasedAcceptedKeyTypes\",\n\t\t    __func__, sshkey_type(key));\n \t\tgoto done;\n \t}\n \n \tif ((b = sshbuf_new()) == NULL)\n \t\tfatal(\"%s: sshbuf_new failed\", __func__);\n \t/* reconstruct packet */\n\tif ((r = sshbuf_put_string(b, session_id2, session_id2_len)) != 0 ||\n\t    (r = sshbuf_put_u8(b, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, authctxt->user)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, authctxt->service)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, \"hostbased\")) != 0 ||\n\t    (r = sshbuf_put_string(b, pkalg, alen)) != 0 ||\n\t    (r = sshbuf_put_string(b, pkblob, blen)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, chost)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, cuser)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n#ifdef DEBUG_PK\n\tsshbuf_dump(b, stderr);\n#endif\n\n\tauth2_record_info(authctxt,\n\t    \"client user \\\"%.100s\\\", client host \\\"%.100s\\\"\", cuser, chost);\n\n\t/* test for allowed key and correct signature */\n\tauthenticated = 0;\n\tif (PRIVSEP(hostbased_key_allowed(authctxt->pw, cuser, chost, key)) &&\n\t    PRIVSEP(sshkey_verify(key, sig, slen,\n\t    sshbuf_ptr(b), sshbuf_len(b), pkalg, ssh->compat)) == 0)\n\t\tauthenticated = 1;\n\n\tauth2_record_key(authctxt, authenticated, key);\n\tsshbuf_free(b);\ndone:\n\tdebug2(\"%s: authenticated %d\", __func__, authenticated);\n\tsshkey_free(key);\n\tfree(pkalg);\n\tfree(pkblob);\n\tfree(cuser);\n\tfree(chost);\n\tfree(sig);\n\treturn authenticated;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142949,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "userauth_hostbased(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tstruct sshbuf *b;\n\tstruct sshkey *key = NULL;\n\tchar *pkalg, *cuser, *chost;\n\tu_char *pkblob, *sig;\n \tsize_t alen, blen, slen;\n \tint r, pktype, authenticated = 0;\n \n \t/* XXX use sshkey_froms() */\n \tif ((r = sshpkt_get_cstring(ssh, &pkalg, &alen)) != 0 ||\n \t    (r = sshpkt_get_string(ssh, &pkblob, &blen)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, &chost, NULL)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, &cuser, NULL)) != 0 ||\n\t    (r = sshpkt_get_string(ssh, &sig, &slen)) != 0)\n\t\tfatal(\"%s: packet parsing: %s\", __func__, ssh_err(r));\n\n\tdebug(\"%s: cuser %s chost %s pkalg %s slen %zu\", __func__,\n\t    cuser, chost, pkalg, slen);\n#ifdef DEBUG_PK\n\tdebug(\"signature:\");\n\tsshbuf_dump_data(sig, siglen, stderr);\n#endif\n\tpktype = sshkey_type_from_name(pkalg);\n\tif (pktype == KEY_UNSPEC) {\n\t\t/* this is perfectly legal */\n\t\tlogit(\"%s: unsupported public key algorithm: %s\",\n\t\t    __func__, pkalg);\n\t\tgoto done;\n\t}\n\tif ((r = sshkey_from_blob(pkblob, blen, &key)) != 0) {\n\t\terror(\"%s: key_from_blob: %s\", __func__, ssh_err(r));\n\t\tgoto done;\n\t}\n\tif (key == NULL) {\n\t\terror(\"%s: cannot decode key: %s\", __func__, pkalg);\n\t\tgoto done;\n\t}\n\tif (key->type != pktype) {\n\t\terror(\"%s: type mismatch for decoded key \"\n\t\t    \"(received %d, expected %d)\", __func__, key->type, pktype);\n\t\tgoto done;\n\t}\n\tif (sshkey_type_plain(key->type) == KEY_RSA &&\n\t    (ssh->compat & SSH_BUG_RSASIGMD5) != 0) {\n\t\terror(\"Refusing RSA key because peer uses unsafe \"\n\t\t    \"signature format\");\n\t\tgoto done;\n\t}\n\tif (match_pattern_list(pkalg, options.hostbased_key_types, 0) != 1) {\n\t\tlogit(\"%s: key type %s not in HostbasedAcceptedKeyTypes\",\n\t\t    __func__, sshkey_type(key));\n \t\tgoto done;\n \t}\n \n\tif (!authctxt->valid || authctxt->user == NULL) {\n\t\tdebug2(\"%s: disabled because of invalid user\", __func__);\n\t\tgoto done;\n\t}\n\n \tif ((b = sshbuf_new()) == NULL)\n \t\tfatal(\"%s: sshbuf_new failed\", __func__);\n \t/* reconstruct packet */\n\tif ((r = sshbuf_put_string(b, session_id2, session_id2_len)) != 0 ||\n\t    (r = sshbuf_put_u8(b, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, authctxt->user)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, authctxt->service)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, \"hostbased\")) != 0 ||\n\t    (r = sshbuf_put_string(b, pkalg, alen)) != 0 ||\n\t    (r = sshbuf_put_string(b, pkblob, blen)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, chost)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, cuser)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n#ifdef DEBUG_PK\n\tsshbuf_dump(b, stderr);\n#endif\n\n\tauth2_record_info(authctxt,\n\t    \"client user \\\"%.100s\\\", client host \\\"%.100s\\\"\", cuser, chost);\n\n\t/* test for allowed key and correct signature */\n\tauthenticated = 0;\n\tif (PRIVSEP(hostbased_key_allowed(authctxt->pw, cuser, chost, key)) &&\n\t    PRIVSEP(sshkey_verify(key, sig, slen,\n\t    sshbuf_ptr(b), sshbuf_len(b), pkalg, ssh->compat)) == 0)\n\t\tauthenticated = 1;\n\n\tauth2_record_key(authctxt, authenticated, key);\n\tsshbuf_free(b);\ndone:\n\tdebug2(\"%s: authenticated %d\", __func__, authenticated);\n\tsshkey_free(key);\n\tfree(pkalg);\n\tfree(pkblob);\n\tfree(cuser);\n\tfree(chost);\n\tfree(sig);\n\treturn authenticated;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142950,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "userauth_pubkey(struct ssh *ssh)\n {\n \tAuthctxt *authctxt = ssh->authctxt;\n \tstruct passwd *pw = authctxt->pw;\n\tstruct sshbuf *b;\n \tstruct sshkey *key = NULL;\n\tchar *pkalg, *userstyle = NULL, *key_s = NULL, *ca_s = NULL;\n\tu_char *pkblob, *sig, have_sig;\n \tsize_t blen, slen;\n \tint r, pktype;\n \tint authenticated = 0;\n \tstruct sshauthopt *authopts = NULL;\n \n\tif (!authctxt->valid) {\n\t\tdebug2(\"%s: disabled because of invalid user\", __func__);\n\t\treturn 0;\n\t}\n \tif ((r = sshpkt_get_u8(ssh, &have_sig)) != 0 ||\n \t    (r = sshpkt_get_cstring(ssh, &pkalg, NULL)) != 0 ||\n \t    (r = sshpkt_get_string(ssh, &pkblob, &blen)) != 0)\n\t\tfatal(\"%s: parse request failed: %s\", __func__, ssh_err(r));\n\tpktype = sshkey_type_from_name(pkalg);\n\tif (pktype == KEY_UNSPEC) {\n\t\t/* this is perfectly legal */\n\t\tverbose(\"%s: unsupported public key algorithm: %s\",\n\t\t    __func__, pkalg);\n\t\tgoto done;\n\t}\n\tif ((r = sshkey_from_blob(pkblob, blen, &key)) != 0) {\n\t\terror(\"%s: could not parse key: %s\", __func__, ssh_err(r));\n\t\tgoto done;\n\t}\n\tif (key == NULL) {\n\t\terror(\"%s: cannot decode key: %s\", __func__, pkalg);\n\t\tgoto done;\n\t}\n\tif (key->type != pktype) {\n\t\terror(\"%s: type mismatch for decoded key \"\n\t\t    \"(received %d, expected %d)\", __func__, key->type, pktype);\n\t\tgoto done;\n\t}\n\tif (sshkey_type_plain(key->type) == KEY_RSA &&\n\t    (ssh->compat & SSH_BUG_RSASIGMD5) != 0) {\n\t\tlogit(\"Refusing RSA key because client uses unsafe \"\n\t\t    \"signature scheme\");\n\t\tgoto done;\n\t}\n\tif (auth2_key_already_used(authctxt, key)) {\n\t\tlogit(\"refusing previously-used %s key\", sshkey_type(key));\n\t\tgoto done;\n\t}\n\tif (match_pattern_list(pkalg, options.pubkey_key_types, 0) != 1) {\n\t\tlogit(\"%s: key type %s not in PubkeyAcceptedKeyTypes\",\n\t\t    __func__, sshkey_ssh_name(key));\n\t\tgoto done;\n\t}\n\n\tkey_s = format_key(key);\n\tif (sshkey_is_cert(key))\n\t\tca_s = format_key(key->cert->signature_key);\n\n\tif (have_sig) {\n\t\tdebug3(\"%s: have %s signature for %s%s%s\",\n\t\t    __func__, pkalg, key_s,\n\t\t    ca_s == NULL ? \"\" : \" CA \",\n\t\t    ca_s == NULL ? \"\" : ca_s);\n\t\tif ((r = sshpkt_get_string(ssh, &sig, &slen)) != 0 ||\n\t\t    (r = sshpkt_get_end(ssh)) != 0)\n\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\t\tif ((b = sshbuf_new()) == NULL)\n\t\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\t\tif (ssh->compat & SSH_OLD_SESSIONID) {\n\t\t\tif ((r = sshbuf_put(b, session_id2,\n\t\t\t    session_id2_len)) != 0)\n\t\t\t\tfatal(\"%s: sshbuf_put session id: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t} else {\n\t\t\tif ((r = sshbuf_put_string(b, session_id2,\n\t\t\t    session_id2_len)) != 0)\n \t\t\t\tfatal(\"%s: sshbuf_put_string session id: %s\",\n \t\t\t\t    __func__, ssh_err(r));\n \t\t}\n \t\t/* reconstruct packet */\n \t\txasprintf(&userstyle, \"%s%s%s\", authctxt->user,\n \t\t    authctxt->style ? \":\" : \"\",\n\t\t    authctxt->style ? authctxt->style : \"\");\n\t\tif ((r = sshbuf_put_u8(b, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, userstyle)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, authctxt->service)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, \"publickey\")) != 0 ||\n\t\t    (r = sshbuf_put_u8(b, have_sig)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, pkalg) != 0) ||\n\t\t    (r = sshbuf_put_string(b, pkblob, blen)) != 0)\n\t\t\tfatal(\"%s: build packet failed: %s\",\n\t\t\t    __func__, ssh_err(r));\n #ifdef DEBUG_PK\n \t\tsshbuf_dump(b, stderr);\n #endif\n \t\t/* test for correct signature */\n \t\tauthenticated = 0;\n \t\tif (PRIVSEP(user_key_allowed(ssh, pw, key, 1, &authopts)) &&\n\t\t    PRIVSEP(sshkey_verify(key, sig, slen,\n\t\t    sshbuf_ptr(b), sshbuf_len(b),\n\t\t    (ssh->compat & SSH_BUG_SIGTYPE) == 0 ? pkalg : NULL,\n\t\t    ssh->compat)) == 0) {\n \t\t\tauthenticated = 1;\n \t\t}\n \t\tsshbuf_free(b);\n\t\tfree(sig);\n \t\tauth2_record_key(authctxt, authenticated, key);\n \t} else {\n \t\tdebug(\"%s: test pkalg %s pkblob %s%s%s\",\n\t\t    __func__, pkalg, key_s,\n\t\t    ca_s == NULL ? \"\" : \" CA \",\n\t\t    ca_s == NULL ? \"\" : ca_s);\n\n \t\tif ((r = sshpkt_get_end(ssh)) != 0)\n \t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n \n \t\t/* XXX fake reply and always send PK_OK ? */\n \t\t/*\n \t\t * XXX this allows testing whether a user is allowed\n\t\t * to login: if you happen to have a valid pubkey this\n\t\t * message is sent. the message is NEVER sent at all\n\t\t * if a user is not allowed to login. is this an\n\t\t * issue? -markus\n\t\t */\n\t\tif (PRIVSEP(user_key_allowed(ssh, pw, key, 0, NULL))) {\n\t\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_PK_OK))\n\t\t\t    != 0 ||\n\t\t\t    (r = sshpkt_put_cstring(ssh, pkalg)) != 0 ||\n\t\t\t    (r = sshpkt_put_string(ssh, pkblob, blen)) != 0 ||\n\t\t\t    (r = sshpkt_send(ssh)) != 0 ||\n\t\t\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\t\t\tauthctxt->postponed = 1;\n\t\t}\n\t}\ndone:\n\tif (authenticated == 1 && auth_activate_options(ssh, authopts) != 0) {\n\t\tdebug(\"%s: key options inconsistent with existing\", __func__);\n\t\tauthenticated = 0;\n\t}\n\tdebug2(\"%s: authenticated %d pkalg %s\", __func__, authenticated, pkalg);\n\n\tsshauthopt_free(authopts);\n\tsshkey_free(key);\n\tfree(userstyle);\n\tfree(pkalg);\n \tfree(pkblob);\n \tfree(key_s);\n \tfree(ca_s);\n \treturn authenticated;\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142951,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "userauth_pubkey(struct ssh *ssh)\n {\n \tAuthctxt *authctxt = ssh->authctxt;\n \tstruct passwd *pw = authctxt->pw;\n\tstruct sshbuf *b = NULL;\n \tstruct sshkey *key = NULL;\n\tchar *pkalg = NULL, *userstyle = NULL, *key_s = NULL, *ca_s = NULL;\n\tu_char *pkblob = NULL, *sig = NULL, have_sig;\n \tsize_t blen, slen;\n \tint r, pktype;\n \tint authenticated = 0;\n \tstruct sshauthopt *authopts = NULL;\n \n \tif ((r = sshpkt_get_u8(ssh, &have_sig)) != 0 ||\n \t    (r = sshpkt_get_cstring(ssh, &pkalg, NULL)) != 0 ||\n \t    (r = sshpkt_get_string(ssh, &pkblob, &blen)) != 0)\n\t\tfatal(\"%s: parse request failed: %s\", __func__, ssh_err(r));\n\tpktype = sshkey_type_from_name(pkalg);\n\tif (pktype == KEY_UNSPEC) {\n\t\t/* this is perfectly legal */\n\t\tverbose(\"%s: unsupported public key algorithm: %s\",\n\t\t    __func__, pkalg);\n\t\tgoto done;\n\t}\n\tif ((r = sshkey_from_blob(pkblob, blen, &key)) != 0) {\n\t\terror(\"%s: could not parse key: %s\", __func__, ssh_err(r));\n\t\tgoto done;\n\t}\n\tif (key == NULL) {\n\t\terror(\"%s: cannot decode key: %s\", __func__, pkalg);\n\t\tgoto done;\n\t}\n\tif (key->type != pktype) {\n\t\terror(\"%s: type mismatch for decoded key \"\n\t\t    \"(received %d, expected %d)\", __func__, key->type, pktype);\n\t\tgoto done;\n\t}\n\tif (sshkey_type_plain(key->type) == KEY_RSA &&\n\t    (ssh->compat & SSH_BUG_RSASIGMD5) != 0) {\n\t\tlogit(\"Refusing RSA key because client uses unsafe \"\n\t\t    \"signature scheme\");\n\t\tgoto done;\n\t}\n\tif (auth2_key_already_used(authctxt, key)) {\n\t\tlogit(\"refusing previously-used %s key\", sshkey_type(key));\n\t\tgoto done;\n\t}\n\tif (match_pattern_list(pkalg, options.pubkey_key_types, 0) != 1) {\n\t\tlogit(\"%s: key type %s not in PubkeyAcceptedKeyTypes\",\n\t\t    __func__, sshkey_ssh_name(key));\n\t\tgoto done;\n\t}\n\n\tkey_s = format_key(key);\n\tif (sshkey_is_cert(key))\n\t\tca_s = format_key(key->cert->signature_key);\n\n\tif (have_sig) {\n\t\tdebug3(\"%s: have %s signature for %s%s%s\",\n\t\t    __func__, pkalg, key_s,\n\t\t    ca_s == NULL ? \"\" : \" CA \",\n\t\t    ca_s == NULL ? \"\" : ca_s);\n\t\tif ((r = sshpkt_get_string(ssh, &sig, &slen)) != 0 ||\n\t\t    (r = sshpkt_get_end(ssh)) != 0)\n\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\t\tif ((b = sshbuf_new()) == NULL)\n\t\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\t\tif (ssh->compat & SSH_OLD_SESSIONID) {\n\t\t\tif ((r = sshbuf_put(b, session_id2,\n\t\t\t    session_id2_len)) != 0)\n\t\t\t\tfatal(\"%s: sshbuf_put session id: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t} else {\n\t\t\tif ((r = sshbuf_put_string(b, session_id2,\n\t\t\t    session_id2_len)) != 0)\n \t\t\t\tfatal(\"%s: sshbuf_put_string session id: %s\",\n \t\t\t\t    __func__, ssh_err(r));\n \t\t}\n\t\tif (!authctxt->valid || authctxt->user == NULL) {\n\t\t\tdebug2(\"%s: disabled because of invalid user\",\n\t\t\t    __func__);\n\t\t\tgoto done;\n\t\t}\n \t\t/* reconstruct packet */\n \t\txasprintf(&userstyle, \"%s%s%s\", authctxt->user,\n \t\t    authctxt->style ? \":\" : \"\",\n\t\t    authctxt->style ? authctxt->style : \"\");\n\t\tif ((r = sshbuf_put_u8(b, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, userstyle)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, authctxt->service)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, \"publickey\")) != 0 ||\n\t\t    (r = sshbuf_put_u8(b, have_sig)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, pkalg) != 0) ||\n\t\t    (r = sshbuf_put_string(b, pkblob, blen)) != 0)\n\t\t\tfatal(\"%s: build packet failed: %s\",\n\t\t\t    __func__, ssh_err(r));\n #ifdef DEBUG_PK\n \t\tsshbuf_dump(b, stderr);\n #endif\n \t\t/* test for correct signature */\n \t\tauthenticated = 0;\n \t\tif (PRIVSEP(user_key_allowed(ssh, pw, key, 1, &authopts)) &&\n\t\t    PRIVSEP(sshkey_verify(key, sig, slen,\n\t\t    sshbuf_ptr(b), sshbuf_len(b),\n\t\t    (ssh->compat & SSH_BUG_SIGTYPE) == 0 ? pkalg : NULL,\n\t\t    ssh->compat)) == 0) {\n \t\t\tauthenticated = 1;\n \t\t}\n \t\tsshbuf_free(b);\n \t\tauth2_record_key(authctxt, authenticated, key);\n \t} else {\n \t\tdebug(\"%s: test pkalg %s pkblob %s%s%s\",\n\t\t    __func__, pkalg, key_s,\n\t\t    ca_s == NULL ? \"\" : \" CA \",\n\t\t    ca_s == NULL ? \"\" : ca_s);\n\n \t\tif ((r = sshpkt_get_end(ssh)) != 0)\n \t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n \n\t\tif (!authctxt->valid || authctxt->user == NULL) {\n\t\t\tdebug2(\"%s: disabled because of invalid user\",\n\t\t\t    __func__);\n\t\t\tgoto done;\n\t\t}\n \t\t/* XXX fake reply and always send PK_OK ? */\n \t\t/*\n \t\t * XXX this allows testing whether a user is allowed\n\t\t * to login: if you happen to have a valid pubkey this\n\t\t * message is sent. the message is NEVER sent at all\n\t\t * if a user is not allowed to login. is this an\n\t\t * issue? -markus\n\t\t */\n\t\tif (PRIVSEP(user_key_allowed(ssh, pw, key, 0, NULL))) {\n\t\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_PK_OK))\n\t\t\t    != 0 ||\n\t\t\t    (r = sshpkt_put_cstring(ssh, pkalg)) != 0 ||\n\t\t\t    (r = sshpkt_put_string(ssh, pkblob, blen)) != 0 ||\n\t\t\t    (r = sshpkt_send(ssh)) != 0 ||\n\t\t\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\t\t\tauthctxt->postponed = 1;\n\t\t}\n\t}\ndone:\n\tif (authenticated == 1 && auth_activate_options(ssh, authopts) != 0) {\n\t\tdebug(\"%s: key options inconsistent with existing\", __func__);\n\t\tauthenticated = 0;\n\t}\n\tdebug2(\"%s: authenticated %d pkalg %s\", __func__, authenticated, pkalg);\n\n\tsshauthopt_free(authopts);\n\tsshkey_free(key);\n\tfree(userstyle);\n\tfree(pkalg);\n \tfree(pkblob);\n \tfree(key_s);\n \tfree(ca_s);\n\tfree(sig);\n \treturn authenticated;\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142952,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "userauth_gssapi(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tgss_OID_desc goid = {0, NULL};\n\tGssctxt *ctxt = NULL;\n\tint r, present;\n\tu_int mechs;\n\tOM_uint32 ms;\n \tsize_t len;\n \tu_char *doid = NULL;\n \n\tif (!authctxt->valid || authctxt->user == NULL)\n\t\treturn (0);\n \tif ((r = sshpkt_get_u32(ssh, &mechs)) != 0)\n \t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n \n\tif (mechs == 0) {\n\t\tdebug(\"Mechanism negotiation is not supported\");\n\t\treturn (0);\n\t}\n\n\tdo {\n\t\tmechs--;\n\n\t\tfree(doid);\n\n\t\tpresent = 0;\n\t\tif ((r = sshpkt_get_string(ssh, &doid, &len)) != 0)\n\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\n\t\tif (len > 2 && doid[0] == SSH_GSS_OIDTYPE &&\n\t\t    doid[1] == len - 2) {\n\t\t\tgoid.elements = doid + 2;\n\t\t\tgoid.length   = len - 2;\n\t\t\tssh_gssapi_test_oid_supported(&ms, &goid, &present);\n\t\t} else {\n\t\t\tlogit(\"Badly formed OID received\");\n\t\t}\n\t} while (mechs > 0 && !present);\n\n\tif (!present) {\n\t\tfree(doid);\n\t\tauthctxt->server_caused_failure = 1;\n \t\treturn (0);\n \t}\n \n \tif (GSS_ERROR(PRIVSEP(ssh_gssapi_server_ctx(&ctxt, &goid)))) {\n \t\tif (ctxt != NULL)\n \t\t\tssh_gssapi_delete_ctx(&ctxt);\n\t\tfree(doid);\n\t\tauthctxt->server_caused_failure = 1;\n\t\treturn (0);\n\t}\n\n\tauthctxt->methoddata = (void *)ctxt;\n\n\t/* Return the OID that we received */\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_GSSAPI_RESPONSE)) != 0 ||\n\t    (r = sshpkt_put_string(ssh, doid, len)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\n\tfree(doid);\n\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_TOKEN, &input_gssapi_token);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_ERRTOK, &input_gssapi_errtok);\n\tauthctxt->postponed = 1;\n\n\treturn (0);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142953,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "userauth_gssapi(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tgss_OID_desc goid = {0, NULL};\n\tGssctxt *ctxt = NULL;\n\tint r, present;\n\tu_int mechs;\n\tOM_uint32 ms;\n \tsize_t len;\n \tu_char *doid = NULL;\n \n \tif ((r = sshpkt_get_u32(ssh, &mechs)) != 0)\n \t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n \n\tif (mechs == 0) {\n\t\tdebug(\"Mechanism negotiation is not supported\");\n\t\treturn (0);\n\t}\n\n\tdo {\n\t\tmechs--;\n\n\t\tfree(doid);\n\n\t\tpresent = 0;\n\t\tif ((r = sshpkt_get_string(ssh, &doid, &len)) != 0)\n\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\n\t\tif (len > 2 && doid[0] == SSH_GSS_OIDTYPE &&\n\t\t    doid[1] == len - 2) {\n\t\t\tgoid.elements = doid + 2;\n\t\t\tgoid.length   = len - 2;\n\t\t\tssh_gssapi_test_oid_supported(&ms, &goid, &present);\n\t\t} else {\n\t\t\tlogit(\"Badly formed OID received\");\n\t\t}\n\t} while (mechs > 0 && !present);\n\n\tif (!present) {\n\t\tfree(doid);\n\t\tauthctxt->server_caused_failure = 1;\n \t\treturn (0);\n \t}\n \n\tif (!authctxt->valid || authctxt->user == NULL) {\n\t\tdebug2(\"%s: disabled because of invalid user\", __func__);\n\t\tfree(doid);\n\t\treturn (0);\n\t}\n\n \tif (GSS_ERROR(PRIVSEP(ssh_gssapi_server_ctx(&ctxt, &goid)))) {\n \t\tif (ctxt != NULL)\n \t\t\tssh_gssapi_delete_ctx(&ctxt);\n\t\tfree(doid);\n\t\tauthctxt->server_caused_failure = 1;\n\t\treturn (0);\n\t}\n\n\tauthctxt->methoddata = (void *)ctxt;\n\n\t/* Return the OID that we received */\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_GSSAPI_RESPONSE)) != 0 ||\n\t    (r = sshpkt_put_string(ssh, doid, len)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\n\tfree(doid);\n\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_TOKEN, &input_gssapi_token);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_ERRTOK, &input_gssapi_errtok);\n\tauthctxt->postponed = 1;\n\n\treturn (0);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142954,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": " PHP_FUNCTION(linkinfo)\n {\n \tchar *link;\n \tsize_t link_len;\n \tzend_stat_t sb;\n \tint ret;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"p\", &link, &link_len) == FAILURE) {\n \t\treturn;\n \t}\n \n \tret = VCWD_STAT(link, &sb);\n \tif (ret == -1) {\n \t\tphp_error_docref(NULL, E_WARNING, \"%s\", strerror(errno));\n \t\tRETURN_LONG(Z_L(-1));\n \t}\n \n \tRETURN_LONG((zend_long) sb.st_dev);\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142955,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": " PHP_FUNCTION(linkinfo)\n {\n \tchar *link;\n\tchar *dirname;\n \tsize_t link_len;\n \tzend_stat_t sb;\n \tint ret;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"p\", &link, &link_len) == FAILURE) {\n \t\treturn;\n \t}\n \n\tdirname = estrndup(link, link_len);\n\tphp_dirname(dirname, link_len);\n\n\tif (php_check_open_basedir(dirname)) {\n\t\tefree(dirname);\n\t\tRETURN_FALSE;\n\t}\n\n \tret = VCWD_STAT(link, &sb);\n \tif (ret == -1) {\n \t\tphp_error_docref(NULL, E_WARNING, \"%s\", strerror(errno));\n\t\tefree(dirname);\n \t\tRETURN_LONG(Z_L(-1));\n \t}\n \n\tefree(dirname);\n \tRETURN_LONG((zend_long) sb.st_dev);\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142956,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "int compat_get_timex(struct timex *txc, const struct compat_timex __user *utp)\n {\n \tstruct compat_timex tx32;\n \n \tif (copy_from_user(&tx32, utp, sizeof(struct compat_timex)))\n \t\treturn -EFAULT;\n \n\ttxc->modes = tx32.modes;\n\ttxc->offset = tx32.offset;\n\ttxc->freq = tx32.freq;\n\ttxc->maxerror = tx32.maxerror;\n\ttxc->esterror = tx32.esterror;\n\ttxc->status = tx32.status;\n\ttxc->constant = tx32.constant;\n\ttxc->precision = tx32.precision;\n\ttxc->tolerance = tx32.tolerance;\n\ttxc->time.tv_sec = tx32.time.tv_sec;\n\ttxc->time.tv_usec = tx32.time.tv_usec;\n\ttxc->tick = tx32.tick;\n\ttxc->ppsfreq = tx32.ppsfreq;\n\ttxc->jitter = tx32.jitter;\n\ttxc->shift = tx32.shift;\n\ttxc->stabil = tx32.stabil;\n\ttxc->jitcnt = tx32.jitcnt;\n\ttxc->calcnt = tx32.calcnt;\n\ttxc->errcnt = tx32.errcnt;\n\ttxc->stbcnt = tx32.stbcnt;\n\n\treturn 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143015,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "int compat_get_timex(struct timex *txc, const struct compat_timex __user *utp)\n {\n \tstruct compat_timex tx32;\n \n\tmemset(txc, 0, sizeof(struct timex));\n \tif (copy_from_user(&tx32, utp, sizeof(struct compat_timex)))\n \t\treturn -EFAULT;\n \n\ttxc->modes = tx32.modes;\n\ttxc->offset = tx32.offset;\n\ttxc->freq = tx32.freq;\n\ttxc->maxerror = tx32.maxerror;\n\ttxc->esterror = tx32.esterror;\n\ttxc->status = tx32.status;\n\ttxc->constant = tx32.constant;\n\ttxc->precision = tx32.precision;\n\ttxc->tolerance = tx32.tolerance;\n\ttxc->time.tv_sec = tx32.time.tv_sec;\n\ttxc->time.tv_usec = tx32.time.tv_usec;\n\ttxc->tick = tx32.tick;\n\ttxc->ppsfreq = tx32.ppsfreq;\n\ttxc->jitter = tx32.jitter;\n\ttxc->shift = tx32.shift;\n\ttxc->stabil = tx32.stabil;\n\ttxc->jitcnt = tx32.jitcnt;\n\ttxc->calcnt = tx32.calcnt;\n\ttxc->errcnt = tx32.errcnt;\n\ttxc->stbcnt = tx32.stbcnt;\n\n\treturn 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143016,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "check_user_token (const char *authfile,\n\t\t  const char *username,\n\t\t  const char *otp_id,\n\t\t  int verbose,\n                  FILE *debug_file)\n{\n  char buf[1024];\n  char *s_user, *s_token;\n  int retval = AUTH_ERROR;\n  int fd;\n  struct stat st;\n  FILE *opwfile;\n\n  fd = open(authfile, O_RDONLY, 0);\n  if (fd < 0) {\n      if(verbose)\n\t  D (debug_file, \"Cannot open file: %s (%s)\", authfile, strerror(errno));\n      return retval;\n  }\n\n  if (fstat(fd, &st) < 0) {\n      if(verbose)\n\t  D (debug_file, \"Cannot stat file: %s (%s)\", authfile, strerror(errno));\n      close(fd);\n      return retval;\n  }\n\n  if (!S_ISREG(st.st_mode)) {\n      if(verbose)\n\t  D (debug_file, \"%s is not a regular file\", authfile);\n      close(fd);\n      return retval;\n  }\n\n  opwfile = fdopen(fd, \"r\");\n  if (opwfile == NULL) {\n      if(verbose)\n\t  D (debug_file, \"fdopen: %s\", strerror(errno));\n      close(fd);\n      return retval;\n  }\n\n  retval = AUTH_NO_TOKENS;\n  while (fgets (buf, 1024, opwfile))\n    {\n      char *saveptr = NULL;\n      if (buf[strlen (buf) - 1] == '\\n')\n\tbuf[strlen (buf) - 1] = '\\0';\n      if (buf[0] == '#') {\n          /* This is a comment and we may skip it. */\n          if(verbose)\n              D (debug_file, \"Skipping comment line: %s\", buf);\n          continue;\n      }\n      if(verbose)\n\t  D (debug_file, \"Authorization line: %s\", buf);\n      s_user = strtok_r (buf, \":\", &saveptr);\n      if (s_user && strcmp (username, s_user) == 0)\n\t{\n\t  if(verbose)\n\t      D (debug_file, \"Matched user: %s\", s_user);\n      retval = AUTH_NOT_FOUND; /* We found at least one line for the user */\n\t  do\n\t    {\n\t      s_token = strtok_r (NULL, \":\", &saveptr);\n\t      if(verbose)\n\t\t  D (debug_file, \"Authorization token: %s\", s_token);\n\t      if (s_token && otp_id && strcmp (otp_id, s_token) == 0)\n \t\t{\n \t\t  if(verbose)\n \t\t      D (debug_file, \"Match user/token as %s/%s\", username, otp_id);\n \t\t  return AUTH_FOUND;\n \t\t}\n \t    }\n\t  while (s_token != NULL);\n\t}\n    }\n\n  fclose (opwfile);\n\n  return retval;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143049,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "check_user_token (const char *authfile,\n\t\t  const char *username,\n\t\t  const char *otp_id,\n\t\t  int verbose,\n                  FILE *debug_file)\n{\n  char buf[1024];\n  char *s_user, *s_token;\n  int retval = AUTH_ERROR;\n  int fd;\n  struct stat st;\n  FILE *opwfile;\n\n  fd = open(authfile, O_RDONLY, 0);\n  if (fd < 0) {\n      if(verbose)\n\t  D (debug_file, \"Cannot open file: %s (%s)\", authfile, strerror(errno));\n      return retval;\n  }\n\n  if (fstat(fd, &st) < 0) {\n      if(verbose)\n\t  D (debug_file, \"Cannot stat file: %s (%s)\", authfile, strerror(errno));\n      close(fd);\n      return retval;\n  }\n\n  if (!S_ISREG(st.st_mode)) {\n      if(verbose)\n\t  D (debug_file, \"%s is not a regular file\", authfile);\n      close(fd);\n      return retval;\n  }\n\n  opwfile = fdopen(fd, \"r\");\n  if (opwfile == NULL) {\n      if(verbose)\n\t  D (debug_file, \"fdopen: %s\", strerror(errno));\n      close(fd);\n      return retval;\n  }\n\n  retval = AUTH_NO_TOKENS;\n  while (fgets (buf, 1024, opwfile))\n    {\n      char *saveptr = NULL;\n      if (buf[strlen (buf) - 1] == '\\n')\n\tbuf[strlen (buf) - 1] = '\\0';\n      if (buf[0] == '#') {\n          /* This is a comment and we may skip it. */\n          if(verbose)\n              D (debug_file, \"Skipping comment line: %s\", buf);\n          continue;\n      }\n      if(verbose)\n\t  D (debug_file, \"Authorization line: %s\", buf);\n      s_user = strtok_r (buf, \":\", &saveptr);\n      if (s_user && strcmp (username, s_user) == 0)\n\t{\n\t  if(verbose)\n\t      D (debug_file, \"Matched user: %s\", s_user);\n      retval = AUTH_NOT_FOUND; /* We found at least one line for the user */\n\t  do\n\t    {\n\t      s_token = strtok_r (NULL, \":\", &saveptr);\n\t      if(verbose)\n\t\t  D (debug_file, \"Authorization token: %s\", s_token);\n\t      if (s_token && otp_id && strcmp (otp_id, s_token) == 0)\n \t\t{\n \t\t  if(verbose)\n \t\t      D (debug_file, \"Match user/token as %s/%s\", username, otp_id);\n\n\t\t  fclose(opwfile);\n \t\t  return AUTH_FOUND;\n \t\t}\n \t    }\n\t  while (s_token != NULL);\n\t}\n    }\n\n  fclose (opwfile);\n\n  return retval;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143050,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "void rds6_inc_info_copy(struct rds_incoming *inc,\n\t\t\tstruct rds_info_iterator *iter,\n\t\t\tstruct in6_addr *saddr, struct in6_addr *daddr,\n\t\t\tint flip)\n{\n\tstruct rds6_info_message minfo6;\n \n \tminfo6.seq = be64_to_cpu(inc->i_hdr.h_sequence);\n \tminfo6.len = be32_to_cpu(inc->i_hdr.h_len);\n \n \tif (flip) {\n \t\tminfo6.laddr = *daddr;\n\t\tminfo6.faddr = *saddr;\n\t\tminfo6.lport = inc->i_hdr.h_dport;\n\t\tminfo6.fport = inc->i_hdr.h_sport;\n\t} else {\n\t\tminfo6.laddr = *saddr;\n\t\tminfo6.faddr = *daddr;\n\t\tminfo6.lport = inc->i_hdr.h_sport;\n \t\tminfo6.fport = inc->i_hdr.h_dport;\n \t}\n \n \trds_info_copy(iter, &minfo6, sizeof(minfo6));\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143175,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "void rds6_inc_info_copy(struct rds_incoming *inc,\n\t\t\tstruct rds_info_iterator *iter,\n\t\t\tstruct in6_addr *saddr, struct in6_addr *daddr,\n\t\t\tint flip)\n{\n\tstruct rds6_info_message minfo6;\n \n \tminfo6.seq = be64_to_cpu(inc->i_hdr.h_sequence);\n \tminfo6.len = be32_to_cpu(inc->i_hdr.h_len);\n\tminfo6.tos = inc->i_conn->c_tos;\n \n \tif (flip) {\n \t\tminfo6.laddr = *daddr;\n\t\tminfo6.faddr = *saddr;\n\t\tminfo6.lport = inc->i_hdr.h_dport;\n\t\tminfo6.fport = inc->i_hdr.h_sport;\n\t} else {\n\t\tminfo6.laddr = *saddr;\n\t\tminfo6.faddr = *daddr;\n\t\tminfo6.lport = inc->i_hdr.h_sport;\n \t\tminfo6.fport = inc->i_hdr.h_dport;\n \t}\n \n\tminfo6.flags = 0;\n\n \trds_info_copy(iter, &minfo6, sizeof(minfo6));\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143176,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static __net_init int setup_net(struct net *net, struct user_namespace *user_ns)\n{\n\t/* Must be called with pernet_ops_rwsem held */\n\tconst struct pernet_operations *ops, *saved_ops;\n\tint error = 0;\n\tLIST_HEAD(net_exit_list);\n \n \trefcount_set(&net->count, 1);\n \trefcount_set(&net->passive, 1);\n \tnet->dev_base_seq = 1;\n \tnet->user_ns = user_ns;\n \tidr_init(&net->netns_ids);\n\tspin_lock_init(&net->nsid_lock);\n\tmutex_init(&net->ipv4.ra_mutex);\n\n\tlist_for_each_entry(ops, &pernet_list, list) {\n\t\terror = ops_init(ops, net);\n\t\tif (error < 0)\n\t\t\tgoto out_undo;\n\t}\n\tdown_write(&net_rwsem);\n\tlist_add_tail_rcu(&net->list, &net_namespace_list);\n\tup_write(&net_rwsem);\nout:\n\treturn error;\n\nout_undo:\n\t/* Walk through the list backwards calling the exit functions\n\t * for the pernet modules whose init functions did not fail.\n\t */\n\tlist_add(&net->exit_list, &net_exit_list);\n\tsaved_ops = ops;\n\tlist_for_each_entry_continue_reverse(ops, &pernet_list, list)\n\t\tops_exit_list(ops, &net_exit_list);\n\n\tops = saved_ops;\n\tlist_for_each_entry_continue_reverse(ops, &pernet_list, list)\n\t\tops_free_list(ops, &net_exit_list);\n\n\trcu_barrier();\n\tgoto out;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143287,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static __net_init int setup_net(struct net *net, struct user_namespace *user_ns)\n{\n\t/* Must be called with pernet_ops_rwsem held */\n\tconst struct pernet_operations *ops, *saved_ops;\n\tint error = 0;\n\tLIST_HEAD(net_exit_list);\n \n \trefcount_set(&net->count, 1);\n \trefcount_set(&net->passive, 1);\n\tget_random_bytes(&net->hash_mix, sizeof(u32));\n \tnet->dev_base_seq = 1;\n \tnet->user_ns = user_ns;\n \tidr_init(&net->netns_ids);\n\tspin_lock_init(&net->nsid_lock);\n\tmutex_init(&net->ipv4.ra_mutex);\n\n\tlist_for_each_entry(ops, &pernet_list, list) {\n\t\terror = ops_init(ops, net);\n\t\tif (error < 0)\n\t\t\tgoto out_undo;\n\t}\n\tdown_write(&net_rwsem);\n\tlist_add_tail_rcu(&net->list, &net_namespace_list);\n\tup_write(&net_rwsem);\nout:\n\treturn error;\n\nout_undo:\n\t/* Walk through the list backwards calling the exit functions\n\t * for the pernet modules whose init functions did not fail.\n\t */\n\tlist_add(&net->exit_list, &net_exit_list);\n\tsaved_ops = ops;\n\tlist_for_each_entry_continue_reverse(ops, &pernet_list, list)\n\t\tops_exit_list(ops, &net_exit_list);\n\n\tops = saved_ops;\n\tlist_for_each_entry_continue_reverse(ops, &pernet_list, list)\n\t\tops_free_list(ops, &net_exit_list);\n\n\trcu_barrier();\n\tgoto out;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143288,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int pvc_getname(struct socket *sock, struct sockaddr *sockaddr,\n\t\t       int *sockaddr_len, int peer)\n{\n\tstruct sockaddr_atmpvc *addr;\n\tstruct atm_vcc *vcc = ATM_SD(sock);\n\n\tif (!vcc->dev || !test_bit(ATM_VF_ADDR, &vcc->flags))\n \t\treturn -ENOTCONN;\n \t*sockaddr_len = sizeof(struct sockaddr_atmpvc);\n \taddr = (struct sockaddr_atmpvc *)sockaddr;\n \taddr->sap_family = AF_ATMPVC;\n \taddr->sap_addr.itf = vcc->dev->number;\n \taddr->sap_addr.vpi = vcc->vpi;\n\taddr->sap_addr.vci = vcc->vci;\n\treturn 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143415,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int pvc_getname(struct socket *sock, struct sockaddr *sockaddr,\n\t\t       int *sockaddr_len, int peer)\n{\n\tstruct sockaddr_atmpvc *addr;\n\tstruct atm_vcc *vcc = ATM_SD(sock);\n\n\tif (!vcc->dev || !test_bit(ATM_VF_ADDR, &vcc->flags))\n \t\treturn -ENOTCONN;\n \t*sockaddr_len = sizeof(struct sockaddr_atmpvc);\n \taddr = (struct sockaddr_atmpvc *)sockaddr;\n\tmemset(addr, 0, sizeof(*addr));\n \taddr->sap_family = AF_ATMPVC;\n \taddr->sap_addr.itf = vcc->dev->number;\n \taddr->sap_addr.vpi = vcc->vpi;\n\taddr->sap_addr.vci = vcc->vci;\n\treturn 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143416,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int l2cap_sock_getname(struct socket *sock, struct sockaddr *addr, int *len, int peer)\n{\n\tstruct sockaddr_l2 *la = (struct sockaddr_l2 *) addr;\n\tstruct sock *sk = sock->sk;\n\tstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\n \n \tBT_DBG(\"sock %p, sk %p\", sock, sk);\n \n \taddr->sa_family = AF_BLUETOOTH;\n \t*len = sizeof(struct sockaddr_l2);\n \n\tif (peer) {\n\t\tla->l2_psm = chan->psm;\n\t\tbacpy(&la->l2_bdaddr, &bt_sk(sk)->dst);\n\t\tla->l2_cid = cpu_to_le16(chan->dcid);\n\t} else {\n\t\tla->l2_psm = chan->sport;\n\t\tbacpy(&la->l2_bdaddr, &bt_sk(sk)->src);\n\t\tla->l2_cid = cpu_to_le16(chan->scid);\n\t}\n\n\treturn 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143417,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int l2cap_sock_getname(struct socket *sock, struct sockaddr *addr, int *len, int peer)\n{\n\tstruct sockaddr_l2 *la = (struct sockaddr_l2 *) addr;\n\tstruct sock *sk = sock->sk;\n\tstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\n \n \tBT_DBG(\"sock %p, sk %p\", sock, sk);\n \n\tmemset(la, 0, sizeof(struct sockaddr_l2));\n \taddr->sa_family = AF_BLUETOOTH;\n \t*len = sizeof(struct sockaddr_l2);\n \n\tif (peer) {\n\t\tla->l2_psm = chan->psm;\n\t\tbacpy(&la->l2_bdaddr, &bt_sk(sk)->dst);\n\t\tla->l2_cid = cpu_to_le16(chan->dcid);\n\t} else {\n\t\tla->l2_psm = chan->sport;\n\t\tbacpy(&la->l2_bdaddr, &bt_sk(sk)->src);\n\t\tla->l2_cid = cpu_to_le16(chan->scid);\n\t}\n\n\treturn 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143418,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int hci_sock_getname(struct socket *sock, struct sockaddr *addr,\n\t\t\t    int *addr_len, int peer)\n{\n\tstruct sockaddr_hci *haddr = (struct sockaddr_hci *) addr;\n\tstruct sock *sk = sock->sk;\n\tstruct hci_dev *hdev = hci_pi(sk)->hdev;\n\n\tBT_DBG(\"sock %p sk %p\", sock, sk);\n\n\tif (!hdev)\n\t\treturn -EBADFD;\n\n\tlock_sock(sk);\n\n \t*addr_len = sizeof(*haddr);\n \thaddr->hci_family = AF_BLUETOOTH;\n \thaddr->hci_dev    = hdev->id;\n \n \trelease_sock(sk);\n \treturn 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143419,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int hci_sock_getname(struct socket *sock, struct sockaddr *addr,\n\t\t\t    int *addr_len, int peer)\n{\n\tstruct sockaddr_hci *haddr = (struct sockaddr_hci *) addr;\n\tstruct sock *sk = sock->sk;\n\tstruct hci_dev *hdev = hci_pi(sk)->hdev;\n\n\tBT_DBG(\"sock %p sk %p\", sock, sk);\n\n\tif (!hdev)\n\t\treturn -EBADFD;\n\n\tlock_sock(sk);\n\n \t*addr_len = sizeof(*haddr);\n \thaddr->hci_family = AF_BLUETOOTH;\n \thaddr->hci_dev    = hdev->id;\n\thaddr->hci_channel= 0;\n \n \trelease_sock(sk);\n \treturn 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143420,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "int ShellBrowserMain(const content::MainFunctionParams& parameters) {\n  bool layout_test_mode =\n      CommandLine::ForCurrentProcess()->HasSwitch(switches::kDumpRenderTree);\n  base::ScopedTempDir browser_context_path_for_layout_tests;\n\n  if (layout_test_mode) {\n    CHECK(browser_context_path_for_layout_tests.CreateUniqueTempDir());\n    CHECK(!browser_context_path_for_layout_tests.path().MaybeAsASCII().empty());\n    CommandLine::ForCurrentProcess()->AppendSwitchASCII(\n        switches::kContentShellDataPath,\n        browser_context_path_for_layout_tests.path().MaybeAsASCII());\n  }\n\n  scoped_ptr<content::BrowserMainRunner> main_runner_(\n      content::BrowserMainRunner::Create());\n\n  int exit_code = main_runner_->Initialize(parameters);\n\n  if (exit_code >= 0)\n    return exit_code;\n\n  if (CommandLine::ForCurrentProcess()->HasSwitch(\n        switches::kCheckLayoutTestSysDeps)) {\n    MessageLoop::current()->PostTask(FROM_HERE, MessageLoop::QuitClosure());\n    main_runner_->Run();\n    main_runner_->Shutdown();\n    return 0;\n  }\n\n  if (layout_test_mode) {\n    content::WebKitTestController test_controller;\n    std::string test_string;\n    CommandLine::StringVector args =\n        CommandLine::ForCurrentProcess()->GetArgs();\n    size_t command_line_position = 0;\n    bool ran_at_least_once = false;\n\n#if defined(OS_ANDROID)\n    std::cout << \"#READY\\n\";\n     std::cout.flush();\n #endif\n \n     while (GetNextTest(args, &command_line_position, &test_string)) {\n       if (test_string.empty())\n         continue;\n      if (test_string == \"QUIT\")\n        break;\n\n      bool enable_pixel_dumps;\n      std::string pixel_hash;\n      FilePath cwd;\n      GURL test_url = GetURLForLayoutTest(\n          test_string, &cwd, &enable_pixel_dumps, &pixel_hash);\n      if (!content::WebKitTestController::Get()->PrepareForLayoutTest(\n              test_url, cwd, enable_pixel_dumps, pixel_hash)) {\n        break;\n      }\n\n       ran_at_least_once = true;\n       main_runner_->Run();\n \n       if (!content::WebKitTestController::Get()->ResetAfterLayoutTest())\n         break;\n     }\n    if (!ran_at_least_once) {\n      MessageLoop::current()->PostTask(FROM_HERE, MessageLoop::QuitClosure());\n      main_runner_->Run();\n    }\n    exit_code = 0;\n  } else {\n    exit_code = main_runner_->Run();\n  }\n\n  main_runner_->Shutdown();\n\n  return exit_code;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143591,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "int ShellBrowserMain(const content::MainFunctionParams& parameters) {\n  bool layout_test_mode =\n      CommandLine::ForCurrentProcess()->HasSwitch(switches::kDumpRenderTree);\n  base::ScopedTempDir browser_context_path_for_layout_tests;\n\n  if (layout_test_mode) {\n    CHECK(browser_context_path_for_layout_tests.CreateUniqueTempDir());\n    CHECK(!browser_context_path_for_layout_tests.path().MaybeAsASCII().empty());\n    CommandLine::ForCurrentProcess()->AppendSwitchASCII(\n        switches::kContentShellDataPath,\n        browser_context_path_for_layout_tests.path().MaybeAsASCII());\n  }\n\n  scoped_ptr<content::BrowserMainRunner> main_runner_(\n      content::BrowserMainRunner::Create());\n\n  int exit_code = main_runner_->Initialize(parameters);\n\n  if (exit_code >= 0)\n    return exit_code;\n\n  if (CommandLine::ForCurrentProcess()->HasSwitch(\n        switches::kCheckLayoutTestSysDeps)) {\n    MessageLoop::current()->PostTask(FROM_HERE, MessageLoop::QuitClosure());\n    main_runner_->Run();\n    main_runner_->Shutdown();\n    return 0;\n  }\n\n  if (layout_test_mode) {\n    content::WebKitTestController test_controller;\n    std::string test_string;\n    CommandLine::StringVector args =\n        CommandLine::ForCurrentProcess()->GetArgs();\n    size_t command_line_position = 0;\n    bool ran_at_least_once = false;\n\n#if defined(OS_ANDROID)\n    std::cout << \"#READY\\n\";\n     std::cout.flush();\n #endif\n \n    FilePath original_cwd;\n    {\n      // We're outside of the message loop here, and this is a test.\n      base::ThreadRestrictions::ScopedAllowIO allow_io;\n      file_util::GetCurrentDirectory(&original_cwd);\n    }\n\n     while (GetNextTest(args, &command_line_position, &test_string)) {\n       if (test_string.empty())\n         continue;\n      if (test_string == \"QUIT\")\n        break;\n\n      bool enable_pixel_dumps;\n      std::string pixel_hash;\n      FilePath cwd;\n      GURL test_url = GetURLForLayoutTest(\n          test_string, &cwd, &enable_pixel_dumps, &pixel_hash);\n      if (!content::WebKitTestController::Get()->PrepareForLayoutTest(\n              test_url, cwd, enable_pixel_dumps, pixel_hash)) {\n        break;\n      }\n\n       ran_at_least_once = true;\n       main_runner_->Run();\n \n      {\n        // We're outside of the message loop here, and this is a test.\n        base::ThreadRestrictions::ScopedAllowIO allow_io;\n        file_util::SetCurrentDirectory(original_cwd);\n      }\n\n       if (!content::WebKitTestController::Get()->ResetAfterLayoutTest())\n         break;\n     }\n    if (!ran_at_least_once) {\n      MessageLoop::current()->PostTask(FROM_HERE, MessageLoop::QuitClosure());\n      main_runner_->Run();\n    }\n    exit_code = 0;\n  } else {\n    exit_code = main_runner_->Run();\n  }\n\n  main_runner_->Shutdown();\n\n  return exit_code;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143592,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static void JNI_WebApkUpdateManager_StoreWebApkUpdateRequestToFile(\n    JNIEnv* env,\n    const JavaParamRef<jstring>& java_update_request_path,\n    const JavaParamRef<jstring>& java_start_url,\n    const JavaParamRef<jstring>& java_scope,\n    const JavaParamRef<jstring>& java_name,\n    const JavaParamRef<jstring>& java_short_name,\n    const JavaParamRef<jstring>& java_primary_icon_url,\n    const JavaParamRef<jobject>& java_primary_icon_bitmap,\n    const JavaParamRef<jstring>& java_badge_icon_url,\n    const JavaParamRef<jobject>& java_badge_icon_bitmap,\n    const JavaParamRef<jobjectArray>& java_icon_urls,\n    const JavaParamRef<jobjectArray>& java_icon_hashes,\n    jint java_display_mode,\n     jint java_orientation,\n     jlong java_theme_color,\n     jlong java_background_color,\n     const JavaParamRef<jstring>& java_web_manifest_url,\n     const JavaParamRef<jstring>& java_webapk_package,\n     jint java_webapk_version,\n    jboolean java_is_manifest_stale,\n    jint java_update_reason,\n    const JavaParamRef<jobject>& java_callback) {\n  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n\n  std::string update_request_path =\n      ConvertJavaStringToUTF8(env, java_update_request_path);\n\n  ShortcutInfo info(GURL(ConvertJavaStringToUTF8(env, java_start_url)));\n  info.scope = GURL(ConvertJavaStringToUTF8(env, java_scope));\n  info.name = ConvertJavaStringToUTF16(env, java_name);\n  info.short_name = ConvertJavaStringToUTF16(env, java_short_name);\n  info.user_title = info.short_name;\n  info.display = static_cast<blink::WebDisplayMode>(java_display_mode);\n  info.orientation =\n      static_cast<blink::WebScreenOrientationLockType>(java_orientation);\n  info.theme_color = (int64_t)java_theme_color;\n  info.background_color = (int64_t)java_background_color;\n  info.best_primary_icon_url =\n      GURL(ConvertJavaStringToUTF8(env, java_primary_icon_url));\n  info.best_badge_icon_url =\n       GURL(ConvertJavaStringToUTF8(env, java_badge_icon_url));\n   info.manifest_url = GURL(ConvertJavaStringToUTF8(env, java_web_manifest_url));\n \n   base::android::AppendJavaStringArrayToStringVector(env, java_icon_urls,\n                                                      &info.icon_urls);\n \n  std::vector<std::string> icon_hashes;\n  base::android::AppendJavaStringArrayToStringVector(env, java_icon_hashes,\n                                                     &icon_hashes);\n\n  std::map<std::string, std::string> icon_url_to_murmur2_hash;\n  for (size_t i = 0; i < info.icon_urls.size(); ++i)\n    icon_url_to_murmur2_hash[info.icon_urls[i]] = icon_hashes[i];\n\n  gfx::JavaBitmap java_primary_icon_bitmap_lock(java_primary_icon_bitmap);\n  SkBitmap primary_icon =\n      gfx::CreateSkBitmapFromJavaBitmap(java_primary_icon_bitmap_lock);\n  primary_icon.setImmutable();\n\n  SkBitmap badge_icon;\n  if (!java_badge_icon_bitmap.is_null()) {\n    gfx::JavaBitmap java_badge_icon_bitmap_lock(java_badge_icon_bitmap);\n    gfx::CreateSkBitmapFromJavaBitmap(java_badge_icon_bitmap_lock);\n    badge_icon.setImmutable();\n  }\n\n  std::string webapk_package;\n  ConvertJavaStringToUTF8(env, java_webapk_package, &webapk_package);\n\n  WebApkUpdateReason update_reason =\n      static_cast<WebApkUpdateReason>(java_update_reason);\n\n  WebApkInstaller::StoreUpdateRequestToFile(\n      base::FilePath(update_request_path), info, primary_icon, badge_icon,\n      webapk_package, std::to_string(java_webapk_version),\n      icon_url_to_murmur2_hash, java_is_manifest_stale, update_reason,\n      base::BindOnce(&base::android::RunBooleanCallbackAndroid,\n                     ScopedJavaGlobalRef<jobject>(java_callback)));\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143625,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static void JNI_WebApkUpdateManager_StoreWebApkUpdateRequestToFile(\n    JNIEnv* env,\n    const JavaParamRef<jstring>& java_update_request_path,\n    const JavaParamRef<jstring>& java_start_url,\n    const JavaParamRef<jstring>& java_scope,\n    const JavaParamRef<jstring>& java_name,\n    const JavaParamRef<jstring>& java_short_name,\n    const JavaParamRef<jstring>& java_primary_icon_url,\n    const JavaParamRef<jobject>& java_primary_icon_bitmap,\n    const JavaParamRef<jstring>& java_badge_icon_url,\n    const JavaParamRef<jobject>& java_badge_icon_bitmap,\n    const JavaParamRef<jobjectArray>& java_icon_urls,\n    const JavaParamRef<jobjectArray>& java_icon_hashes,\n    jint java_display_mode,\n     jint java_orientation,\n     jlong java_theme_color,\n     jlong java_background_color,\n    const JavaParamRef<jstring>& java_share_target_action,\n    const JavaParamRef<jstring>& java_share_target_param_title,\n    const JavaParamRef<jstring>& java_share_target_param_text,\n    const JavaParamRef<jstring>& java_share_target_param_url,\n     const JavaParamRef<jstring>& java_web_manifest_url,\n     const JavaParamRef<jstring>& java_webapk_package,\n     jint java_webapk_version,\n    jboolean java_is_manifest_stale,\n    jint java_update_reason,\n    const JavaParamRef<jobject>& java_callback) {\n  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n\n  std::string update_request_path =\n      ConvertJavaStringToUTF8(env, java_update_request_path);\n\n  ShortcutInfo info(GURL(ConvertJavaStringToUTF8(env, java_start_url)));\n  info.scope = GURL(ConvertJavaStringToUTF8(env, java_scope));\n  info.name = ConvertJavaStringToUTF16(env, java_name);\n  info.short_name = ConvertJavaStringToUTF16(env, java_short_name);\n  info.user_title = info.short_name;\n  info.display = static_cast<blink::WebDisplayMode>(java_display_mode);\n  info.orientation =\n      static_cast<blink::WebScreenOrientationLockType>(java_orientation);\n  info.theme_color = (int64_t)java_theme_color;\n  info.background_color = (int64_t)java_background_color;\n  info.best_primary_icon_url =\n      GURL(ConvertJavaStringToUTF8(env, java_primary_icon_url));\n  info.best_badge_icon_url =\n       GURL(ConvertJavaStringToUTF8(env, java_badge_icon_url));\n   info.manifest_url = GURL(ConvertJavaStringToUTF8(env, java_web_manifest_url));\n \n  GURL share_target_action =\n      GURL(ConvertJavaStringToUTF8(env, java_share_target_action));\n  if (!share_target_action.is_empty()) {\n    info.share_target = ShareTarget();\n    info.share_target->action = share_target_action;\n    info.share_target->params.title =\n        ConvertJavaStringToUTF16(java_share_target_param_title);\n    info.share_target->params.text =\n        ConvertJavaStringToUTF16(java_share_target_param_text);\n    info.share_target->params.url =\n        ConvertJavaStringToUTF16(java_share_target_param_url);\n  }\n\n   base::android::AppendJavaStringArrayToStringVector(env, java_icon_urls,\n                                                      &info.icon_urls);\n \n  std::vector<std::string> icon_hashes;\n  base::android::AppendJavaStringArrayToStringVector(env, java_icon_hashes,\n                                                     &icon_hashes);\n\n  std::map<std::string, std::string> icon_url_to_murmur2_hash;\n  for (size_t i = 0; i < info.icon_urls.size(); ++i)\n    icon_url_to_murmur2_hash[info.icon_urls[i]] = icon_hashes[i];\n\n  gfx::JavaBitmap java_primary_icon_bitmap_lock(java_primary_icon_bitmap);\n  SkBitmap primary_icon =\n      gfx::CreateSkBitmapFromJavaBitmap(java_primary_icon_bitmap_lock);\n  primary_icon.setImmutable();\n\n  SkBitmap badge_icon;\n  if (!java_badge_icon_bitmap.is_null()) {\n    gfx::JavaBitmap java_badge_icon_bitmap_lock(java_badge_icon_bitmap);\n    gfx::CreateSkBitmapFromJavaBitmap(java_badge_icon_bitmap_lock);\n    badge_icon.setImmutable();\n  }\n\n  std::string webapk_package;\n  ConvertJavaStringToUTF8(env, java_webapk_package, &webapk_package);\n\n  WebApkUpdateReason update_reason =\n      static_cast<WebApkUpdateReason>(java_update_reason);\n\n  WebApkInstaller::StoreUpdateRequestToFile(\n      base::FilePath(update_request_path), info, primary_icon, badge_icon,\n      webapk_package, std::to_string(java_webapk_version),\n      icon_url_to_murmur2_hash, java_is_manifest_stale, update_reason,\n      base::BindOnce(&base::android::RunBooleanCallbackAndroid,\n                     ScopedJavaGlobalRef<jobject>(java_callback)));\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143626,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "v8::Local<v8::Object> V8SchemaRegistry::GetSchema(const std::string& api) {\n  if (schema_cache_ != NULL) {\n    v8::Local<v8::Object> cached_schema = schema_cache_->Get(api);\n    if (!cached_schema.IsEmpty()) {\n      return cached_schema;\n    }\n  }\n\n\n  v8::Isolate* isolate = v8::Isolate::GetCurrent();\n  v8::EscapableHandleScope handle_scope(isolate);\n  v8::Local<v8::Context> context = GetOrCreateContext(isolate);\n  v8::Context::Scope context_scope(context);\n\n  const base::DictionaryValue* schema =\n      ExtensionAPI::GetSharedInstance()->GetSchema(api);\n  CHECK(schema) << api;\n  std::unique_ptr<V8ValueConverter> v8_value_converter(\n      V8ValueConverter::create());\n  v8::Local<v8::Value> value = v8_value_converter->ToV8Value(schema, context);\n   CHECK(!value.IsEmpty());\n \n   v8::Local<v8::Object> v8_schema(v8::Local<v8::Object>::Cast(value));\n  v8_schema->SetIntegrityLevel(context, v8::IntegrityLevel::kFrozen);\n   schema_cache_->Set(api, v8_schema);\n \n   return handle_scope.Escape(v8_schema);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143637,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "v8::Local<v8::Object> V8SchemaRegistry::GetSchema(const std::string& api) {\n  if (schema_cache_ != NULL) {\n    v8::Local<v8::Object> cached_schema = schema_cache_->Get(api);\n    if (!cached_schema.IsEmpty()) {\n      return cached_schema;\n    }\n  }\n\n\n  v8::Isolate* isolate = v8::Isolate::GetCurrent();\n  v8::EscapableHandleScope handle_scope(isolate);\n  v8::Local<v8::Context> context = GetOrCreateContext(isolate);\n  v8::Context::Scope context_scope(context);\n\n  const base::DictionaryValue* schema =\n      ExtensionAPI::GetSharedInstance()->GetSchema(api);\n  CHECK(schema) << api;\n  std::unique_ptr<V8ValueConverter> v8_value_converter(\n      V8ValueConverter::create());\n  v8::Local<v8::Value> value = v8_value_converter->ToV8Value(schema, context);\n   CHECK(!value.IsEmpty());\n \n   v8::Local<v8::Object> v8_schema(v8::Local<v8::Object>::Cast(value));\n  DeepFreeze(v8_schema, context);\n   schema_cache_->Set(api, v8_schema);\n \n   return handle_scope.Escape(v8_schema);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143638,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": " bool OmniboxViewViews::ShouldShowPlaceholderText() const {\n   return Textfield::ShouldShowPlaceholderText() &&\n         !model()->is_caret_visible() && !model()->is_keyword_selected();\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143667,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": " bool OmniboxViewViews::ShouldShowPlaceholderText() const {\n  bool show_with_caret = base::FeatureList::IsEnabled(\n      omnibox::kUIExperimentShowPlaceholderWhenCaretShowing);\n   return Textfield::ShouldShowPlaceholderText() &&\n         (show_with_caret || !model()->is_caret_visible()) &&\n         !model()->is_keyword_selected();\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143668,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "void TopSitesImpl::SetTopSites(const MostVisitedURLList& new_top_sites,\n                               const CallLocation location) {\n  DCHECK(thread_checker_.CalledOnValidThread());\n\n  MostVisitedURLList top_sites(new_top_sites);\n  size_t num_forced_urls = MergeCachedForcedURLs(&top_sites);\n  AddPrepopulatedPages(&top_sites, num_forced_urls);\n\n  TopSitesDelta delta;\n  DiffMostVisited(cache_->top_sites(), top_sites, &delta);\n\n  TopSitesBackend::RecordHistogram record_or_not =\n      TopSitesBackend::RECORD_HISTOGRAM_NO;\n\n  if (location == CALL_LOCATION_FROM_ON_GOT_MOST_VISITED_THUMBNAILS &&\n      !histogram_recorded_) {\n    size_t delta_size =\n        delta.deleted.size() + delta.added.size() + delta.moved.size();\n    UMA_HISTOGRAM_COUNTS_100(\"History.FirstSetTopSitesDeltaSize\", delta_size);\n    record_or_not = TopSitesBackend::RECORD_HISTOGRAM_YES;\n    histogram_recorded_ = true;\n  }\n\n  bool should_notify_observers = false;\n  if (!delta.deleted.empty() || !delta.added.empty() || !delta.moved.empty()) {\n    backend_->UpdateTopSites(delta, record_or_not);\n    should_notify_observers = true;\n  }\n  if (!should_notify_observers)\n    should_notify_observers = DoTitlesDiffer(cache_->top_sites(), top_sites);\n\n   cache_->SetTopSites(top_sites);\n \n  if (!temp_images_.empty()) {\n    for (const MostVisitedURL& mv : top_sites) {\n      const GURL& canonical_url = cache_->GetCanonicalURL(mv.url);\n      for (TempImages::iterator it = temp_images_.begin();\n           it != temp_images_.end(); ++it) {\n        if (canonical_url == cache_->GetCanonicalURL(it->first)) {\n          bool success = SetPageThumbnailEncoded(\n              mv.url, it->second.thumbnail.get(), it->second.thumbnail_score);\n          if (success) {\n            UMA_HISTOGRAM_ENUMERATION(\"Thumbnails.AddedToTopSites\",\n                                      THUMBNAIL_PROMOTED_TEMP_TO_REGULAR,\n                                      THUMBNAIL_EVENT_COUNT);\n          }\n          temp_images_.erase(it);\n          break;\n        }\n      }\n    }\n  }\n\n  if (top_sites.size() - num_forced_urls >= kNonForcedTopSitesNumber)\n    temp_images_.clear();\n\n  ResetThreadSafeCache();\n  ResetThreadSafeImageCache();\n\n  if (should_notify_observers) {\n    if (location == CALL_LOCATION_FROM_FORCED_URLS)\n      NotifyTopSitesChanged(TopSitesObserver::ChangeReason::FORCED_URL);\n    else\n      NotifyTopSitesChanged(TopSitesObserver::ChangeReason::MOST_VISITED);\n  }\n\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143715,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "void TopSitesImpl::SetTopSites(const MostVisitedURLList& new_top_sites,\n                               const CallLocation location) {\n  DCHECK(thread_checker_.CalledOnValidThread());\n\n  MostVisitedURLList top_sites(new_top_sites);\n  size_t num_forced_urls = MergeCachedForcedURLs(&top_sites);\n  AddPrepopulatedPages(&top_sites, num_forced_urls);\n\n  TopSitesDelta delta;\n  DiffMostVisited(cache_->top_sites(), top_sites, &delta);\n\n  TopSitesBackend::RecordHistogram record_or_not =\n      TopSitesBackend::RECORD_HISTOGRAM_NO;\n\n  if (location == CALL_LOCATION_FROM_ON_GOT_MOST_VISITED_THUMBNAILS &&\n      !histogram_recorded_) {\n    size_t delta_size =\n        delta.deleted.size() + delta.added.size() + delta.moved.size();\n    UMA_HISTOGRAM_COUNTS_100(\"History.FirstSetTopSitesDeltaSize\", delta_size);\n    record_or_not = TopSitesBackend::RECORD_HISTOGRAM_YES;\n    histogram_recorded_ = true;\n  }\n\n  bool should_notify_observers = false;\n  if (!delta.deleted.empty() || !delta.added.empty() || !delta.moved.empty()) {\n    backend_->UpdateTopSites(delta, record_or_not);\n    should_notify_observers = true;\n  }\n  if (!should_notify_observers)\n    should_notify_observers = DoTitlesDiffer(cache_->top_sites(), top_sites);\n\n   cache_->SetTopSites(top_sites);\n  cache_->ClearUnreferencedThumbnails();\n \n  if (!temp_images_.empty()) {\n    for (const MostVisitedURL& mv : top_sites) {\n      const GURL& canonical_url = cache_->GetCanonicalURL(mv.url);\n      for (TempImages::iterator it = temp_images_.begin();\n           it != temp_images_.end(); ++it) {\n        if (canonical_url == cache_->GetCanonicalURL(it->first)) {\n          bool success = SetPageThumbnailEncoded(\n              mv.url, it->second.thumbnail.get(), it->second.thumbnail_score);\n          if (success) {\n            UMA_HISTOGRAM_ENUMERATION(\"Thumbnails.AddedToTopSites\",\n                                      THUMBNAIL_PROMOTED_TEMP_TO_REGULAR,\n                                      THUMBNAIL_EVENT_COUNT);\n          }\n          temp_images_.erase(it);\n          break;\n        }\n      }\n    }\n  }\n\n  if (top_sites.size() - num_forced_urls >= kNonForcedTopSitesNumber)\n    temp_images_.clear();\n\n  ResetThreadSafeCache();\n  ResetThreadSafeImageCache();\n\n  if (should_notify_observers) {\n    if (location == CALL_LOCATION_FROM_FORCED_URLS)\n      NotifyTopSitesChanged(TopSitesObserver::ChangeReason::FORCED_URL);\n    else\n      NotifyTopSitesChanged(TopSitesObserver::ChangeReason::MOST_VISITED);\n  }\n\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143716,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "void AddPasswordsAndFormsStrings(content::WebUIDataSource* html_source) {\n  LocalizedString localized_strings[] = {\n      {\"passwordsAndAutofillPageTitle\",\n       IDS_SETTINGS_PASSWORDS_AND_AUTOFILL_PAGE_TITLE},\n       {\"autofill\", IDS_SETTINGS_AUTOFILL},\n       {\"googlePayments\", IDS_SETTINGS_GOOGLE_PAYMENTS},\n       {\"googlePaymentsCached\", IDS_SETTINGS_GOOGLE_PAYMENTS_CACHED},\n       {\"addresses\", IDS_SETTINGS_AUTOFILL_ADDRESSES_HEADING},\n       {\"addAddressTitle\", IDS_SETTINGS_AUTOFILL_ADDRESSES_ADD_TITLE},\n       {\"editAddressTitle\", IDS_SETTINGS_AUTOFILL_ADDRESSES_EDIT_TITLE},\n      {\"addressCountry\", IDS_SETTINGS_AUTOFILL_ADDRESSES_COUNTRY},\n      {\"addressPhone\", IDS_SETTINGS_AUTOFILL_ADDRESSES_PHONE},\n      {\"addressEmail\", IDS_SETTINGS_AUTOFILL_ADDRESSES_EMAIL},\n      {\"removeAddress\", IDS_SETTINGS_ADDRESS_REMOVE},\n      {\"creditCards\", IDS_SETTINGS_AUTOFILL_CREDIT_CARD_HEADING},\n      {\"removeCreditCard\", IDS_SETTINGS_CREDIT_CARD_REMOVE},\n      {\"clearCreditCard\", IDS_SETTINGS_CREDIT_CARD_CLEAR},\n      {\"creditCardType\", IDS_SETTINGS_AUTOFILL_CREDIT_CARD_TYPE_COLUMN_LABEL},\n      {\"creditCardExpiration\", IDS_SETTINGS_CREDIT_CARD_EXPIRATION_DATE},\n      {\"creditCardName\", IDS_SETTINGS_NAME_ON_CREDIT_CARD},\n      {\"creditCardNumber\", IDS_SETTINGS_CREDIT_CARD_NUMBER},\n      {\"creditCardExpirationMonth\", IDS_SETTINGS_CREDIT_CARD_EXPIRATION_MONTH},\n      {\"creditCardExpirationYear\", IDS_SETTINGS_CREDIT_CARD_EXPIRATION_YEAR},\n      {\"creditCardExpired\", IDS_SETTINGS_CREDIT_CARD_EXPIRED},\n      {\"editCreditCardTitle\", IDS_SETTINGS_EDIT_CREDIT_CARD_TITLE},\n       {\"addCreditCardTitle\", IDS_SETTINGS_ADD_CREDIT_CARD_TITLE},\n       {\"autofillDetail\", IDS_SETTINGS_AUTOFILL_DETAIL},\n       {\"passwords\", IDS_SETTINGS_PASSWORDS},\n       {\"passwordsAutosigninLabel\",\n        IDS_SETTINGS_PASSWORDS_AUTOSIGNIN_CHECKBOX_LABEL},\n       {\"passwordsAutosigninDescription\",\n       IDS_SETTINGS_PASSWORDS_AUTOSIGNIN_CHECKBOX_DESC},\n      {\"passwordsDetail\", IDS_SETTINGS_PASSWORDS_DETAIL},\n      {\"savedPasswordsHeading\", IDS_SETTINGS_PASSWORDS_SAVED_HEADING},\n      {\"passwordExceptionsHeading\", IDS_SETTINGS_PASSWORDS_EXCEPTIONS_HEADING},\n      {\"deletePasswordException\", IDS_SETTINGS_PASSWORDS_DELETE_EXCEPTION},\n      {\"removePassword\", IDS_SETTINGS_PASSWORD_REMOVE},\n      {\"searchPasswords\", IDS_SETTINGS_PASSWORD_SEARCH},\n      {\"showPassword\", IDS_SETTINGS_PASSWORD_SHOW},\n      {\"hidePassword\", IDS_SETTINGS_PASSWORD_HIDE},\n      {\"passwordDetailsTitle\", IDS_SETTINGS_PASSWORDS_VIEW_DETAILS_TITLE},\n      {\"passwordViewDetails\", IDS_SETTINGS_PASSWORD_DETAILS},\n      {\"editPasswordWebsiteLabel\", IDS_SETTINGS_PASSWORDS_WEBSITE},\n      {\"editPasswordUsernameLabel\", IDS_SETTINGS_PASSWORDS_USERNAME},\n      {\"editPasswordPasswordLabel\", IDS_SETTINGS_PASSWORDS_PASSWORD},\n      {\"noAddressesFound\", IDS_SETTINGS_ADDRESS_NONE},\n      {\"noCreditCardsFound\", IDS_SETTINGS_CREDIT_CARD_NONE},\n      {\"noCreditCardsPolicy\", IDS_SETTINGS_CREDIT_CARD_DISABLED},\n      {\"noPasswordsFound\", IDS_SETTINGS_PASSWORDS_NONE},\n      {\"noExceptionsFound\", IDS_SETTINGS_PASSWORDS_EXCEPTIONS_NONE},\n      {\"import\", IDS_PASSWORD_MANAGER_IMPORT_BUTTON},\n      {\"exportMenuItem\", IDS_SETTINGS_PASSWORDS_EXPORT_MENU_ITEM},\n      {\"undoRemovePassword\", IDS_SETTINGS_PASSWORD_UNDO},\n      {\"passwordDeleted\", IDS_SETTINGS_PASSWORD_DELETED_PASSWORD},\n      {\"exportPasswordsTitle\", IDS_SETTINGS_PASSWORDS_EXPORT_TITLE},\n      {\"exportPasswordsDescription\", IDS_SETTINGS_PASSWORDS_EXPORT_DESCRIPTION},\n      {\"exportPasswords\", IDS_SETTINGS_PASSWORDS_EXPORT},\n      {\"exportingPasswordsTitle\", IDS_SETTINGS_PASSWORDS_EXPORTING_TITLE},\n      {\"exportPasswordsTryAgain\", IDS_SETTINGS_PASSWORDS_EXPORT_TRY_AGAIN},\n      {\"exportPasswordsFailTitle\",\n       IDS_SETTINGS_PASSWORDS_EXPORTING_FAILURE_TITLE},\n      {\"exportPasswordsFailTips\",\n       IDS_SETTINGS_PASSWORDS_EXPORTING_FAILURE_TIPS},\n      {\"exportPasswordsFailTipsEnoughSpace\",\n       IDS_SETTINGS_PASSWORDS_EXPORTING_FAILURE_TIP_ENOUGH_SPACE},\n      {\"exportPasswordsFailTipsAnotherFolder\",\n       IDS_SETTINGS_PASSWORDS_EXPORTING_FAILURE_TIP_ANOTHER_FOLDER}};\n\n  html_source->AddString(\n      \"managePasswordsLabel\",\n      l10n_util::GetStringFUTF16(\n          IDS_SETTINGS_PASSWORDS_MANAGE_PASSWORDS,\n          base::ASCIIToUTF16(\n              password_manager::kPasswordManagerAccountDashboardURL)));\n  html_source->AddString(\"passwordManagerLearnMoreURL\",\n                         chrome::kPasswordManagerLearnMoreURL);\n  html_source->AddString(\"manageAddressesUrl\",\n                         autofill::payments::GetManageAddressesUrl(0).spec());\n  html_source->AddString(\"manageCreditCardsUrl\",\n                         autofill::payments::GetManageInstrumentsUrl(0).spec());\n\n  AddLocalizedStringsBulk(html_source, localized_strings,\n                          arraysize(localized_strings));\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143729,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "void AddPasswordsAndFormsStrings(content::WebUIDataSource* html_source) {\n  LocalizedString localized_strings[] = {\n      {\"passwordsAndAutofillPageTitle\",\n       IDS_SETTINGS_PASSWORDS_AND_AUTOFILL_PAGE_TITLE},\n       {\"autofill\", IDS_SETTINGS_AUTOFILL},\n       {\"googlePayments\", IDS_SETTINGS_GOOGLE_PAYMENTS},\n       {\"googlePaymentsCached\", IDS_SETTINGS_GOOGLE_PAYMENTS_CACHED},\n      {\"autofillFormsLabel\", IDS_SETTINGS_AUTOFILL_TOGGLE_LABEL},\n       {\"addresses\", IDS_SETTINGS_AUTOFILL_ADDRESSES_HEADING},\n       {\"addAddressTitle\", IDS_SETTINGS_AUTOFILL_ADDRESSES_ADD_TITLE},\n       {\"editAddressTitle\", IDS_SETTINGS_AUTOFILL_ADDRESSES_EDIT_TITLE},\n      {\"addressCountry\", IDS_SETTINGS_AUTOFILL_ADDRESSES_COUNTRY},\n      {\"addressPhone\", IDS_SETTINGS_AUTOFILL_ADDRESSES_PHONE},\n      {\"addressEmail\", IDS_SETTINGS_AUTOFILL_ADDRESSES_EMAIL},\n      {\"removeAddress\", IDS_SETTINGS_ADDRESS_REMOVE},\n      {\"creditCards\", IDS_SETTINGS_AUTOFILL_CREDIT_CARD_HEADING},\n      {\"removeCreditCard\", IDS_SETTINGS_CREDIT_CARD_REMOVE},\n      {\"clearCreditCard\", IDS_SETTINGS_CREDIT_CARD_CLEAR},\n      {\"creditCardType\", IDS_SETTINGS_AUTOFILL_CREDIT_CARD_TYPE_COLUMN_LABEL},\n      {\"creditCardExpiration\", IDS_SETTINGS_CREDIT_CARD_EXPIRATION_DATE},\n      {\"creditCardName\", IDS_SETTINGS_NAME_ON_CREDIT_CARD},\n      {\"creditCardNumber\", IDS_SETTINGS_CREDIT_CARD_NUMBER},\n      {\"creditCardExpirationMonth\", IDS_SETTINGS_CREDIT_CARD_EXPIRATION_MONTH},\n      {\"creditCardExpirationYear\", IDS_SETTINGS_CREDIT_CARD_EXPIRATION_YEAR},\n      {\"creditCardExpired\", IDS_SETTINGS_CREDIT_CARD_EXPIRED},\n      {\"editCreditCardTitle\", IDS_SETTINGS_EDIT_CREDIT_CARD_TITLE},\n       {\"addCreditCardTitle\", IDS_SETTINGS_ADD_CREDIT_CARD_TITLE},\n       {\"autofillDetail\", IDS_SETTINGS_AUTOFILL_DETAIL},\n       {\"passwords\", IDS_SETTINGS_PASSWORDS},\n      {\"passwordsSavePasswordsLabel\",\n       IDS_SETTINGS_PASSWORDS_SAVE_PASSWORDS_TOGGLE_LABEL},\n       {\"passwordsAutosigninLabel\",\n        IDS_SETTINGS_PASSWORDS_AUTOSIGNIN_CHECKBOX_LABEL},\n       {\"passwordsAutosigninDescription\",\n       IDS_SETTINGS_PASSWORDS_AUTOSIGNIN_CHECKBOX_DESC},\n      {\"passwordsDetail\", IDS_SETTINGS_PASSWORDS_DETAIL},\n      {\"savedPasswordsHeading\", IDS_SETTINGS_PASSWORDS_SAVED_HEADING},\n      {\"passwordExceptionsHeading\", IDS_SETTINGS_PASSWORDS_EXCEPTIONS_HEADING},\n      {\"deletePasswordException\", IDS_SETTINGS_PASSWORDS_DELETE_EXCEPTION},\n      {\"removePassword\", IDS_SETTINGS_PASSWORD_REMOVE},\n      {\"searchPasswords\", IDS_SETTINGS_PASSWORD_SEARCH},\n      {\"showPassword\", IDS_SETTINGS_PASSWORD_SHOW},\n      {\"hidePassword\", IDS_SETTINGS_PASSWORD_HIDE},\n      {\"passwordDetailsTitle\", IDS_SETTINGS_PASSWORDS_VIEW_DETAILS_TITLE},\n      {\"passwordViewDetails\", IDS_SETTINGS_PASSWORD_DETAILS},\n      {\"editPasswordWebsiteLabel\", IDS_SETTINGS_PASSWORDS_WEBSITE},\n      {\"editPasswordUsernameLabel\", IDS_SETTINGS_PASSWORDS_USERNAME},\n      {\"editPasswordPasswordLabel\", IDS_SETTINGS_PASSWORDS_PASSWORD},\n      {\"noAddressesFound\", IDS_SETTINGS_ADDRESS_NONE},\n      {\"noCreditCardsFound\", IDS_SETTINGS_CREDIT_CARD_NONE},\n      {\"noCreditCardsPolicy\", IDS_SETTINGS_CREDIT_CARD_DISABLED},\n      {\"noPasswordsFound\", IDS_SETTINGS_PASSWORDS_NONE},\n      {\"noExceptionsFound\", IDS_SETTINGS_PASSWORDS_EXCEPTIONS_NONE},\n      {\"import\", IDS_PASSWORD_MANAGER_IMPORT_BUTTON},\n      {\"exportMenuItem\", IDS_SETTINGS_PASSWORDS_EXPORT_MENU_ITEM},\n      {\"undoRemovePassword\", IDS_SETTINGS_PASSWORD_UNDO},\n      {\"passwordDeleted\", IDS_SETTINGS_PASSWORD_DELETED_PASSWORD},\n      {\"exportPasswordsTitle\", IDS_SETTINGS_PASSWORDS_EXPORT_TITLE},\n      {\"exportPasswordsDescription\", IDS_SETTINGS_PASSWORDS_EXPORT_DESCRIPTION},\n      {\"exportPasswords\", IDS_SETTINGS_PASSWORDS_EXPORT},\n      {\"exportingPasswordsTitle\", IDS_SETTINGS_PASSWORDS_EXPORTING_TITLE},\n      {\"exportPasswordsTryAgain\", IDS_SETTINGS_PASSWORDS_EXPORT_TRY_AGAIN},\n      {\"exportPasswordsFailTitle\",\n       IDS_SETTINGS_PASSWORDS_EXPORTING_FAILURE_TITLE},\n      {\"exportPasswordsFailTips\",\n       IDS_SETTINGS_PASSWORDS_EXPORTING_FAILURE_TIPS},\n      {\"exportPasswordsFailTipsEnoughSpace\",\n       IDS_SETTINGS_PASSWORDS_EXPORTING_FAILURE_TIP_ENOUGH_SPACE},\n      {\"exportPasswordsFailTipsAnotherFolder\",\n       IDS_SETTINGS_PASSWORDS_EXPORTING_FAILURE_TIP_ANOTHER_FOLDER}};\n\n  html_source->AddString(\n      \"managePasswordsLabel\",\n      l10n_util::GetStringFUTF16(\n          IDS_SETTINGS_PASSWORDS_MANAGE_PASSWORDS,\n          base::ASCIIToUTF16(\n              password_manager::kPasswordManagerAccountDashboardURL)));\n  html_source->AddString(\"passwordManagerLearnMoreURL\",\n                         chrome::kPasswordManagerLearnMoreURL);\n  html_source->AddString(\"manageAddressesUrl\",\n                         autofill::payments::GetManageAddressesUrl(0).spec());\n  html_source->AddString(\"manageCreditCardsUrl\",\n                         autofill::payments::GetManageInstrumentsUrl(0).spec());\n\n  AddLocalizedStringsBulk(html_source, localized_strings,\n                          arraysize(localized_strings));\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143730,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "bool SetExtendedFileAttribute(const char* path,\n                              const char* name,\n                               const char* value,\n                               size_t value_size,\n                               int flags) {\n//// On Chrome OS, there is no component that can validate these extended\n//// attributes so there is no need to set them.\n   base::ScopedBlockingCall scoped_blocking_call(base::BlockingType::MAY_BLOCK);\n   int result = setxattr(path, name, value, value_size, flags);\n   if (result) {\n     DPLOG(ERROR) << \"Could not set extended attribute \" << name << \" on file \"\n                  << path;\n     return false;\n   }\n   return true;\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143773,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "bool SetExtendedFileAttribute(const char* path,\n                              const char* name,\n                               const char* value,\n                               size_t value_size,\n                               int flags) {\n//// On Chrome OS, there is no component that can validate these extended\n//// attributes so there is no need to set them.\n#if !defined(OS_CHROMEOS)\n   base::ScopedBlockingCall scoped_blocking_call(base::BlockingType::MAY_BLOCK);\n   int result = setxattr(path, name, value, value_size, flags);\n   if (result) {\n     DPLOG(ERROR) << \"Could not set extended attribute \" << name << \" on file \"\n                  << path;\n     return false;\n   }\n#endif  // !defined(OS_CHROMEOS)\n   return true;\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143774,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "bool Performance::PassesTimingAllowCheck(\n    const ResourceResponse& response,\n     const SecurityOrigin& initiator_security_origin,\n     const AtomicString& original_timing_allow_origin,\n     ExecutionContext* context) {\n   scoped_refptr<const SecurityOrigin> resource_origin =\n      SecurityOrigin::Create(response.Url());\n   if (resource_origin->IsSameSchemeHostPort(&initiator_security_origin))\n     return true;\n \n  const AtomicString& timing_allow_origin_string =\n      original_timing_allow_origin.IsEmpty()\n          ? response.HttpHeaderField(HTTPNames::Timing_Allow_Origin)\n          : original_timing_allow_origin;\n  if (timing_allow_origin_string.IsEmpty() ||\n      EqualIgnoringASCIICase(timing_allow_origin_string, \"null\"))\n    return false;\n\n  if (timing_allow_origin_string == \"*\") {\n    UseCounter::Count(context, WebFeature::kStarInTimingAllowOrigin);\n    return true;\n  }\n\n  const String& security_origin = initiator_security_origin.ToString();\n  Vector<String> timing_allow_origins;\n  timing_allow_origin_string.GetString().Split(',', timing_allow_origins);\n  if (timing_allow_origins.size() > 1) {\n    UseCounter::Count(context, WebFeature::kMultipleOriginsInTimingAllowOrigin);\n  } else if (timing_allow_origins.size() == 1 &&\n             timing_allow_origin_string != \"*\") {\n    UseCounter::Count(context, WebFeature::kSingleOriginInTimingAllowOrigin);\n  }\n  for (const String& allow_origin : timing_allow_origins) {\n    const String allow_origin_stripped = allow_origin.StripWhiteSpace();\n    if (allow_origin_stripped == security_origin ||\n        allow_origin_stripped == \"*\") {\n      return true;\n    }\n  }\n\n  return false;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143775,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "bool Performance::PassesTimingAllowCheck(\n    const ResourceResponse& response,\n     const SecurityOrigin& initiator_security_origin,\n     const AtomicString& original_timing_allow_origin,\n     ExecutionContext* context) {\n  const KURL& response_url = response.WasFetchedViaServiceWorker()\n                                 ? response.OriginalURLViaServiceWorker()\n                                 : response.Url();\n   scoped_refptr<const SecurityOrigin> resource_origin =\n      SecurityOrigin::Create(response_url);\n   if (resource_origin->IsSameSchemeHostPort(&initiator_security_origin))\n     return true;\n \n  const AtomicString& timing_allow_origin_string =\n      original_timing_allow_origin.IsEmpty()\n          ? response.HttpHeaderField(HTTPNames::Timing_Allow_Origin)\n          : original_timing_allow_origin;\n  if (timing_allow_origin_string.IsEmpty() ||\n      EqualIgnoringASCIICase(timing_allow_origin_string, \"null\"))\n    return false;\n\n  if (timing_allow_origin_string == \"*\") {\n    UseCounter::Count(context, WebFeature::kStarInTimingAllowOrigin);\n    return true;\n  }\n\n  const String& security_origin = initiator_security_origin.ToString();\n  Vector<String> timing_allow_origins;\n  timing_allow_origin_string.GetString().Split(',', timing_allow_origins);\n  if (timing_allow_origins.size() > 1) {\n    UseCounter::Count(context, WebFeature::kMultipleOriginsInTimingAllowOrigin);\n  } else if (timing_allow_origins.size() == 1 &&\n             timing_allow_origin_string != \"*\") {\n    UseCounter::Count(context, WebFeature::kSingleOriginInTimingAllowOrigin);\n  }\n  for (const String& allow_origin : timing_allow_origins) {\n    const String allow_origin_stripped = allow_origin.StripWhiteSpace();\n    if (allow_origin_stripped == security_origin ||\n        allow_origin_stripped == \"*\") {\n      return true;\n    }\n  }\n\n  return false;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143776,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "void FetchManager::Loader::Start() {\n\n\n\n\n\n  if (!ContentSecurityPolicy::ShouldBypassMainWorld(execution_context_) &&\n      !execution_context_->GetContentSecurityPolicy()->AllowConnectToSource(\n          fetch_request_data_->Url())) {\n    PerformNetworkError(\n        \"Refused to connect to '\" + fetch_request_data_->Url().ElidedString() +\n        \"' because it violates the document's Content Security Policy.\");\n    return;\n  }\n\n  if ((SecurityOrigin::Create(fetch_request_data_->Url())\n           ->IsSameSchemeHostPort(fetch_request_data_->Origin().get())) ||\n      (fetch_request_data_->Url().ProtocolIsData() &&\n       fetch_request_data_->SameOriginDataURLFlag()) ||\n      (fetch_request_data_->Mode() == FetchRequestMode::kNavigate)) {\n    PerformSchemeFetch();\n    return;\n  }\n\n  if (fetch_request_data_->Mode() == FetchRequestMode::kSameOrigin) {\n    PerformNetworkError(\"Fetch API cannot load \" +\n                        fetch_request_data_->Url().GetString() +\n                        \". Request mode is \\\"same-origin\\\" but the URL\\'s \"\n                        \"origin is not same as the request origin \" +\n                        fetch_request_data_->Origin()->ToString() + \".\");\n    return;\n  }\n \n   if (fetch_request_data_->Mode() == FetchRequestMode::kNoCORS) {\n     fetch_request_data_->SetResponseTainting(FetchRequestData::kOpaqueTainting);\n    PerformSchemeFetch();\n    return;\n  }\n\n  if (!SchemeRegistry::ShouldTreatURLSchemeAsSupportingFetchAPI(\n          fetch_request_data_->Url().Protocol())) {\n    PerformNetworkError(\n        \"Fetch API cannot load \" + fetch_request_data_->Url().GetString() +\n        \". URL scheme must be \\\"http\\\" or \\\"https\\\" for CORS request.\");\n    return;\n  }\n\n  fetch_request_data_->SetResponseTainting(FetchRequestData::kCORSTainting);\n\n  PerformHTTPFetch();\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143781,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "void FetchManager::Loader::Start() {\n\n\n\n\n\n  if (!ContentSecurityPolicy::ShouldBypassMainWorld(execution_context_) &&\n      !execution_context_->GetContentSecurityPolicy()->AllowConnectToSource(\n          fetch_request_data_->Url())) {\n    PerformNetworkError(\n        \"Refused to connect to '\" + fetch_request_data_->Url().ElidedString() +\n        \"' because it violates the document's Content Security Policy.\");\n    return;\n  }\n\n  if ((SecurityOrigin::Create(fetch_request_data_->Url())\n           ->IsSameSchemeHostPort(fetch_request_data_->Origin().get())) ||\n      (fetch_request_data_->Url().ProtocolIsData() &&\n       fetch_request_data_->SameOriginDataURLFlag()) ||\n      (fetch_request_data_->Mode() == FetchRequestMode::kNavigate)) {\n    PerformSchemeFetch();\n    return;\n  }\n\n  if (fetch_request_data_->Mode() == FetchRequestMode::kSameOrigin) {\n    PerformNetworkError(\"Fetch API cannot load \" +\n                        fetch_request_data_->Url().GetString() +\n                        \". Request mode is \\\"same-origin\\\" but the URL\\'s \"\n                        \"origin is not same as the request origin \" +\n                        fetch_request_data_->Origin()->ToString() + \".\");\n    return;\n  }\n \n   if (fetch_request_data_->Mode() == FetchRequestMode::kNoCORS) {\n    // \"If |request|'s redirect mode is not |follow|, then return a network\n    // error.\n    if (fetch_request_data_->Redirect() != FetchRedirectMode::kFollow) {\n      PerformNetworkError(\"Fetch API cannot load \" +\n                          fetch_request_data_->Url().GetString() +\n                          \". Request mode is \\\"no-cors\\\" but the redirect mode \"\n                          \" is not \\\"follow\\\".\");\n      return;\n    }\n\n     fetch_request_data_->SetResponseTainting(FetchRequestData::kOpaqueTainting);\n    PerformSchemeFetch();\n    return;\n  }\n\n  if (!SchemeRegistry::ShouldTreatURLSchemeAsSupportingFetchAPI(\n          fetch_request_data_->Url().Protocol())) {\n    PerformNetworkError(\n        \"Fetch API cannot load \" + fetch_request_data_->Url().GetString() +\n        \". URL scheme must be \\\"http\\\" or \\\"https\\\" for CORS request.\");\n    return;\n  }\n\n  fetch_request_data_->SetResponseTainting(FetchRequestData::kCORSTainting);\n\n  PerformHTTPFetch();\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143782,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "void OnSuggestionModelAdded(UiScene* scene,\n                            UiBrowserInterface* browser,\n                            Model* model,\n                            SuggestionBinding* element_binding) {\n  auto icon = base::MakeUnique<VectorIcon>(100);\n  icon->SetDrawPhase(kPhaseForeground);\n  icon->SetType(kTypeOmniboxSuggestionIcon);\n  icon->set_hit_testable(false);\n  icon->SetSize(kSuggestionIconSizeDMM, kSuggestionIconSizeDMM);\n  BindColor(model, icon.get(), &ColorScheme::omnibox_icon,\n            &VectorIcon::SetColor);\n  VectorIcon* p_icon = icon.get();\n\n  auto icon_box = base::MakeUnique<UiElement>();\n  icon_box->SetDrawPhase(kPhaseNone);\n  icon_box->SetType(kTypeOmniboxSuggestionIconField);\n  icon_box->SetSize(kSuggestionIconFieldWidthDMM, kSuggestionHeightDMM);\n  icon_box->AddChild(std::move(icon));\n\n  auto content_text = base::MakeUnique<Text>(kSuggestionContentTextHeightDMM);\n  content_text->SetDrawPhase(kPhaseForeground);\n  content_text->SetType(kTypeOmniboxSuggestionContentText);\n  content_text->set_hit_testable(false);\n  content_text->SetTextLayoutMode(TextLayoutMode::kSingleLineFixedWidth);\n  content_text->SetSize(kSuggestionTextFieldWidthDMM, 0);\n  content_text->SetTextAlignment(UiTexture::kTextAlignmentLeft);\n  BindColor(model, content_text.get(), &ColorScheme::omnibox_suggestion_content,\n            &Text::SetColor);\n  Text* p_content_text = content_text.get();\n\n  auto description_text =\n      base::MakeUnique<Text>(kSuggestionDescriptionTextHeightDMM);\n   description_text->SetDrawPhase(kPhaseForeground);\n   description_text->SetType(kTypeOmniboxSuggestionDescriptionText);\n   description_text->set_hit_testable(false);\n  content_text->SetTextLayoutMode(TextLayoutMode::kSingleLineFixedWidth);\n   description_text->SetSize(kSuggestionTextFieldWidthDMM, 0);\n   description_text->SetTextAlignment(UiTexture::kTextAlignmentLeft);\n   BindColor(model, description_text.get(),\n            &ColorScheme::omnibox_suggestion_description, &Text::SetColor);\n  Text* p_description_text = description_text.get();\n\n  auto text_layout = base::MakeUnique<LinearLayout>(LinearLayout::kDown);\n  text_layout->SetType(kTypeOmniboxSuggestionTextLayout);\n  text_layout->set_hit_testable(false);\n  text_layout->set_margin(kSuggestionLineGapDMM);\n  text_layout->AddChild(std::move(content_text));\n  text_layout->AddChild(std::move(description_text));\n\n  auto right_margin = base::MakeUnique<UiElement>();\n  right_margin->SetDrawPhase(kPhaseNone);\n  right_margin->SetSize(kSuggestionRightMarginDMM, kSuggestionHeightDMM);\n\n  auto suggestion_layout = base::MakeUnique<LinearLayout>(LinearLayout::kRight);\n  suggestion_layout->SetType(kTypeOmniboxSuggestionLayout);\n  suggestion_layout->set_hit_testable(false);\n  suggestion_layout->AddChild(std::move(icon_box));\n  suggestion_layout->AddChild(std::move(text_layout));\n  suggestion_layout->AddChild(std::move(right_margin));\n\n  auto background = Create<Button>(\n      kNone, kPhaseForeground,\n      base::BindRepeating(\n          [](UiBrowserInterface* b, Model* m, SuggestionBinding* e) {\n            b->Navigate(e->model()->destination);\n            m->omnibox_input_active = false;\n          },\n          base::Unretained(browser), base::Unretained(model),\n          base::Unretained(element_binding)));\n\n  background->SetType(kTypeOmniboxSuggestionBackground);\n  background->set_hit_testable(true);\n  background->set_bubble_events(true);\n  background->set_bounds_contain_children(true);\n  background->set_hover_offset(0.0);\n  BindButtonColors(model, background.get(),\n                   &ColorScheme::suggestion_button_colors,\n                   &Button::SetButtonColors);\n  background->AddChild(std::move(suggestion_layout));\n\n  element_binding->bindings().push_back(\n      VR_BIND_FUNC(base::string16, SuggestionBinding, element_binding,\n                   model()->content, Text, p_content_text, SetText));\n  element_binding->bindings().push_back(\n      base::MakeUnique<Binding<base::string16>>(\n          base::BindRepeating(\n              [](SuggestionBinding* m) { return m->model()->description; },\n              base::Unretained(element_binding)),\n          base::BindRepeating(\n              [](Text* v, const base::string16& text) {\n                v->SetVisibleImmediately(!text.empty());\n                v->set_requires_layout(!text.empty());\n                if (!text.empty()) {\n                  v->SetText(text);\n                }\n              },\n              base::Unretained(p_description_text))));\n  element_binding->bindings().push_back(\n      VR_BIND(AutocompleteMatch::Type, SuggestionBinding, element_binding,\n              model()->type, VectorIcon, p_icon,\n              SetIcon(AutocompleteMatch::TypeToVectorIcon(value))));\n  element_binding->set_view(background.get());\n  scene->AddUiElement(kOmniboxSuggestions, std::move(background));\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143791,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "void OnSuggestionModelAdded(UiScene* scene,\n                            UiBrowserInterface* browser,\n                            Model* model,\n                            SuggestionBinding* element_binding) {\n  auto icon = base::MakeUnique<VectorIcon>(100);\n  icon->SetDrawPhase(kPhaseForeground);\n  icon->SetType(kTypeOmniboxSuggestionIcon);\n  icon->set_hit_testable(false);\n  icon->SetSize(kSuggestionIconSizeDMM, kSuggestionIconSizeDMM);\n  BindColor(model, icon.get(), &ColorScheme::omnibox_icon,\n            &VectorIcon::SetColor);\n  VectorIcon* p_icon = icon.get();\n\n  auto icon_box = base::MakeUnique<UiElement>();\n  icon_box->SetDrawPhase(kPhaseNone);\n  icon_box->SetType(kTypeOmniboxSuggestionIconField);\n  icon_box->SetSize(kSuggestionIconFieldWidthDMM, kSuggestionHeightDMM);\n  icon_box->AddChild(std::move(icon));\n\n  auto content_text = base::MakeUnique<Text>(kSuggestionContentTextHeightDMM);\n  content_text->SetDrawPhase(kPhaseForeground);\n  content_text->SetType(kTypeOmniboxSuggestionContentText);\n  content_text->set_hit_testable(false);\n  content_text->SetTextLayoutMode(TextLayoutMode::kSingleLineFixedWidth);\n  content_text->SetSize(kSuggestionTextFieldWidthDMM, 0);\n  content_text->SetTextAlignment(UiTexture::kTextAlignmentLeft);\n  BindColor(model, content_text.get(), &ColorScheme::omnibox_suggestion_content,\n            &Text::SetColor);\n  Text* p_content_text = content_text.get();\n\n  auto description_text =\n      base::MakeUnique<Text>(kSuggestionDescriptionTextHeightDMM);\n   description_text->SetDrawPhase(kPhaseForeground);\n   description_text->SetType(kTypeOmniboxSuggestionDescriptionText);\n   description_text->set_hit_testable(false);\n  description_text->SetTextLayoutMode(TextLayoutMode::kSingleLineFixedWidth);\n   description_text->SetSize(kSuggestionTextFieldWidthDMM, 0);\n   description_text->SetTextAlignment(UiTexture::kTextAlignmentLeft);\n   BindColor(model, description_text.get(),\n            &ColorScheme::omnibox_suggestion_description, &Text::SetColor);\n  Text* p_description_text = description_text.get();\n\n  auto text_layout = base::MakeUnique<LinearLayout>(LinearLayout::kDown);\n  text_layout->SetType(kTypeOmniboxSuggestionTextLayout);\n  text_layout->set_hit_testable(false);\n  text_layout->set_margin(kSuggestionLineGapDMM);\n  text_layout->AddChild(std::move(content_text));\n  text_layout->AddChild(std::move(description_text));\n\n  auto right_margin = base::MakeUnique<UiElement>();\n  right_margin->SetDrawPhase(kPhaseNone);\n  right_margin->SetSize(kSuggestionRightMarginDMM, kSuggestionHeightDMM);\n\n  auto suggestion_layout = base::MakeUnique<LinearLayout>(LinearLayout::kRight);\n  suggestion_layout->SetType(kTypeOmniboxSuggestionLayout);\n  suggestion_layout->set_hit_testable(false);\n  suggestion_layout->AddChild(std::move(icon_box));\n  suggestion_layout->AddChild(std::move(text_layout));\n  suggestion_layout->AddChild(std::move(right_margin));\n\n  auto background = Create<Button>(\n      kNone, kPhaseForeground,\n      base::BindRepeating(\n          [](UiBrowserInterface* b, Model* m, SuggestionBinding* e) {\n            b->Navigate(e->model()->destination);\n            m->omnibox_input_active = false;\n          },\n          base::Unretained(browser), base::Unretained(model),\n          base::Unretained(element_binding)));\n\n  background->SetType(kTypeOmniboxSuggestionBackground);\n  background->set_hit_testable(true);\n  background->set_bubble_events(true);\n  background->set_bounds_contain_children(true);\n  background->set_hover_offset(0.0);\n  BindButtonColors(model, background.get(),\n                   &ColorScheme::suggestion_button_colors,\n                   &Button::SetButtonColors);\n  background->AddChild(std::move(suggestion_layout));\n\n  element_binding->bindings().push_back(\n      VR_BIND_FUNC(base::string16, SuggestionBinding, element_binding,\n                   model()->content, Text, p_content_text, SetText));\n  element_binding->bindings().push_back(\n      base::MakeUnique<Binding<base::string16>>(\n          base::BindRepeating(\n              [](SuggestionBinding* m) { return m->model()->description; },\n              base::Unretained(element_binding)),\n          base::BindRepeating(\n              [](Text* v, const base::string16& text) {\n                v->SetVisibleImmediately(!text.empty());\n                v->set_requires_layout(!text.empty());\n                if (!text.empty()) {\n                  v->SetText(text);\n                }\n              },\n              base::Unretained(p_description_text))));\n  element_binding->bindings().push_back(\n      VR_BIND(AutocompleteMatch::Type, SuggestionBinding, element_binding,\n              model()->type, VectorIcon, p_icon,\n              SetIcon(AutocompleteMatch::TypeToVectorIcon(value))));\n  element_binding->set_view(background.get());\n  scene->AddUiElement(kOmniboxSuggestions, std::move(background));\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143792,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "PerformanceNavigationTiming::PerformanceNavigationTiming(\n    LocalFrame* frame,\n     ResourceTimingInfo* info,\n     TimeTicks time_origin,\n     const WebVector<WebServerTimingInfo>& server_timing)\n    : PerformanceResourceTiming(info ? info->InitialURL().GetString() : \"\",\n                                \"navigation\",\n                                time_origin,\n                                server_timing),\n       ContextClient(frame),\n       resource_timing_info_(info) {\n   DCHECK(frame);\n  DCHECK(info);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143793,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "PerformanceNavigationTiming::PerformanceNavigationTiming(\n    LocalFrame* frame,\n     ResourceTimingInfo* info,\n     TimeTicks time_origin,\n     const WebVector<WebServerTimingInfo>& server_timing)\n    : PerformanceResourceTiming(\n          info ? info->FinalResponse().Url().GetString() : \"\",\n          \"navigation\",\n          time_origin,\n          server_timing),\n       ContextClient(frame),\n       resource_timing_info_(info) {\n   DCHECK(frame);\n  DCHECK(info);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143794,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": " scoped_refptr<Image> CSSPaintValue::GetImage(\n     const ImageResourceObserver& client,\n     const Document& document,\n    const ComputedStyle&,\n     const FloatSize& target_size) {\n   if (!generator_) {\n     generator_ = CSSPaintImageGenerator::Create(\n         GetName(), document, paint_image_generator_observer_);\n  }\n\n  if (!ParseInputArguments(document))\n    return nullptr;\n\n  return generator_->Paint(client, RoundedIntSize(target_size),\n                           parsed_input_arguments_);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143795,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": " scoped_refptr<Image> CSSPaintValue::GetImage(\n     const ImageResourceObserver& client,\n     const Document& document,\n    const ComputedStyle& style,\n     const FloatSize& target_size) {\n  // https://crbug.com/835589: early exit when paint target is associated with\n  // a link.\n  if (style.InsideLink() != EInsideLink::kNotInsideLink)\n    return nullptr;\n\n   if (!generator_) {\n     generator_ = CSSPaintImageGenerator::Create(\n         GetName(), document, paint_image_generator_observer_);\n  }\n\n  if (!ParseInputArguments(document))\n    return nullptr;\n\n  return generator_->Paint(client, RoundedIntSize(target_size),\n                           parsed_input_arguments_);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143796,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "status_t SampleIterator::seekTo(uint32_t sampleIndex) {\n    ALOGV(\"seekTo(%d)\", sampleIndex);\n\n if (sampleIndex >= mTable->mNumSampleSizes) {\n return ERROR_END_OF_STREAM;\n }\n\n if (mTable->mSampleToChunkOffset < 0\n || mTable->mChunkOffsetOffset < 0\n || mTable->mSampleSizeOffset < 0\n || mTable->mTimeToSampleCount == 0) {\n\n return ERROR_MALFORMED;\n }\n\n if (mInitialized && mCurrentSampleIndex == sampleIndex) {\n return OK;\n }\n\n if (!mInitialized || sampleIndex < mFirstChunkSampleIndex) {\n        reset();\n }\n\n if (sampleIndex >= mStopChunkSampleIndex) {\n status_t err;\n if ((err = findChunkRange(sampleIndex)) != OK) {\n            ALOGE(\"findChunkRange failed\");\n return err;\n }\n }\n\n    CHECK(sampleIndex < mStopChunkSampleIndex);\n\n if (mSamplesPerChunk == 0) {\n        ALOGE(\"b/22802344\");\n return ERROR_MALFORMED;\n }\n\n uint32_t chunk =\n (sampleIndex - mFirstChunkSampleIndex) / mSamplesPerChunk\n\n         + mFirstChunk;\n \n     if (!mInitialized || chunk != mCurrentChunkIndex) {\n        mCurrentChunkIndex = chunk;\n         status_t err;\n         if ((err = getChunkOffset(chunk, &mCurrentChunkOffset)) != OK) {\n             ALOGE(\"getChunkOffset return error\");\n return err;\n }\n\n        mCurrentChunkSampleSizes.clear();\n\n \n         uint32_t firstChunkSampleIndex =\n             mFirstChunkSampleIndex\n                + mSamplesPerChunk * (mCurrentChunkIndex - mFirstChunk);\n \n         for (uint32_t i = 0; i < mSamplesPerChunk; ++i) {\n             size_t sampleSize;\n             if ((err = getSampleSizeDirect(\n                             firstChunkSampleIndex + i, &sampleSize)) != OK) {\n                 ALOGE(\"getSampleSizeDirect return error\");\n                 return err;\n             }\n \n             mCurrentChunkSampleSizes.push(sampleSize);\n         }\n     }\n \n     uint32_t chunkRelativeSampleIndex =\n (sampleIndex - mFirstChunkSampleIndex) % mSamplesPerChunk;\n\n    mCurrentSampleOffset = mCurrentChunkOffset;\n for (uint32_t i = 0; i < chunkRelativeSampleIndex; ++i) {\n        mCurrentSampleOffset += mCurrentChunkSampleSizes[i];\n }\n\n    mCurrentSampleSize = mCurrentChunkSampleSizes[chunkRelativeSampleIndex];\n if (sampleIndex < mTTSSampleIndex) {\n        mTimeToSampleIndex = 0;\n        mTTSSampleIndex = 0;\n        mTTSSampleTime = 0;\n        mTTSCount = 0;\n        mTTSDuration = 0;\n }\n\n status_t err;\n if ((err = findSampleTimeAndDuration(\n            sampleIndex, &mCurrentSampleTime, &mCurrentSampleDuration)) != OK) {\n        ALOGE(\"findSampleTime return error\");\n return err;\n }\n\n    mCurrentSampleIndex = sampleIndex;\n\n    mInitialized = true;\n\n return OK;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143811,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "status_t SampleIterator::seekTo(uint32_t sampleIndex) {\n    ALOGV(\"seekTo(%d)\", sampleIndex);\n\n if (sampleIndex >= mTable->mNumSampleSizes) {\n return ERROR_END_OF_STREAM;\n }\n\n if (mTable->mSampleToChunkOffset < 0\n || mTable->mChunkOffsetOffset < 0\n || mTable->mSampleSizeOffset < 0\n || mTable->mTimeToSampleCount == 0) {\n\n return ERROR_MALFORMED;\n }\n\n if (mInitialized && mCurrentSampleIndex == sampleIndex) {\n return OK;\n }\n\n if (!mInitialized || sampleIndex < mFirstChunkSampleIndex) {\n        reset();\n }\n\n if (sampleIndex >= mStopChunkSampleIndex) {\n status_t err;\n if ((err = findChunkRange(sampleIndex)) != OK) {\n            ALOGE(\"findChunkRange failed\");\n return err;\n }\n }\n\n    CHECK(sampleIndex < mStopChunkSampleIndex);\n\n if (mSamplesPerChunk == 0) {\n        ALOGE(\"b/22802344\");\n return ERROR_MALFORMED;\n }\n\n uint32_t chunk =\n (sampleIndex - mFirstChunkSampleIndex) / mSamplesPerChunk\n\n         + mFirstChunk;\n \n     if (!mInitialized || chunk != mCurrentChunkIndex) {\n         status_t err;\n         if ((err = getChunkOffset(chunk, &mCurrentChunkOffset)) != OK) {\n             ALOGE(\"getChunkOffset return error\");\n return err;\n }\n\n        mCurrentChunkSampleSizes.clear();\n\n \n         uint32_t firstChunkSampleIndex =\n             mFirstChunkSampleIndex\n                + mSamplesPerChunk * (chunk - mFirstChunk);\n \n         for (uint32_t i = 0; i < mSamplesPerChunk; ++i) {\n             size_t sampleSize;\n             if ((err = getSampleSizeDirect(\n                             firstChunkSampleIndex + i, &sampleSize)) != OK) {\n                 ALOGE(\"getSampleSizeDirect return error\");\n                mCurrentChunkSampleSizes.clear();\n                 return err;\n             }\n \n             mCurrentChunkSampleSizes.push(sampleSize);\n         }\n\n        mCurrentChunkIndex = chunk;\n     }\n \n     uint32_t chunkRelativeSampleIndex =\n (sampleIndex - mFirstChunkSampleIndex) % mSamplesPerChunk;\n\n    mCurrentSampleOffset = mCurrentChunkOffset;\n for (uint32_t i = 0; i < chunkRelativeSampleIndex; ++i) {\n        mCurrentSampleOffset += mCurrentChunkSampleSizes[i];\n }\n\n    mCurrentSampleSize = mCurrentChunkSampleSizes[chunkRelativeSampleIndex];\n if (sampleIndex < mTTSSampleIndex) {\n        mTimeToSampleIndex = 0;\n        mTTSSampleIndex = 0;\n        mTTSSampleTime = 0;\n        mTTSCount = 0;\n        mTTSDuration = 0;\n }\n\n status_t err;\n if ((err = findSampleTimeAndDuration(\n            sampleIndex, &mCurrentSampleTime, &mCurrentSampleDuration)) != OK) {\n        ALOGE(\"findSampleTime return error\");\n return err;\n }\n\n    mCurrentSampleIndex = sampleIndex;\n\n    mInitialized = true;\n\n return OK;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143812,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": " status_t AudioFlinger::EffectModule::command(uint32_t cmdCode,\n                                              uint32_t cmdSize,\n                                              void *pCmdData,\n uint32_t *replySize,\n void *pReplyData)\n{\n Mutex::Autolock _l(mLock);\n    ALOGVV(\"command(), cmdCode: %d, mEffectInterface: %p\", cmdCode, mEffectInterface);\n\n if (mState == DESTROYED || mEffectInterface == NULL) {\n return NO_INIT;\n }\n if (mStatus != NO_ERROR) {\n return mStatus;\n }\n if (cmdCode == EFFECT_CMD_GET_PARAM &&\n (*replySize < sizeof(effect_param_t) ||\n ((effect_param_t *)pCmdData)->psize > *replySize - sizeof(effect_param_t))) {\n\n         android_errorWriteLog(0x534e4554, \"29251553\");\n         return -EINVAL;\n     }\n     status_t status = (*mEffectInterface)->command(mEffectInterface,\n                                                    cmdCode,\n                                                    cmdSize,\n                                                   pCmdData,\n                                                   replySize,\n                                                   pReplyData);\n if (cmdCode != EFFECT_CMD_GET_PARAM && status == NO_ERROR) {\n uint32_t size = (replySize == NULL) ? 0 : *replySize;\n for (size_t i = 1; i < mHandles.size(); i++) {\n EffectHandle *h = mHandles[i];\n if (h != NULL && !h->destroyed_l()) {\n                h->commandExecuted(cmdCode, cmdSize, pCmdData, size, pReplyData);\n }\n }\n }\n return status;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143817,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": " status_t AudioFlinger::EffectModule::command(uint32_t cmdCode,\n                                              uint32_t cmdSize,\n                                              void *pCmdData,\n uint32_t *replySize,\n void *pReplyData)\n{\n Mutex::Autolock _l(mLock);\n    ALOGVV(\"command(), cmdCode: %d, mEffectInterface: %p\", cmdCode, mEffectInterface);\n\n if (mState == DESTROYED || mEffectInterface == NULL) {\n return NO_INIT;\n }\n if (mStatus != NO_ERROR) {\n return mStatus;\n }\n if (cmdCode == EFFECT_CMD_GET_PARAM &&\n (*replySize < sizeof(effect_param_t) ||\n ((effect_param_t *)pCmdData)->psize > *replySize - sizeof(effect_param_t))) {\n\n         android_errorWriteLog(0x534e4554, \"29251553\");\n         return -EINVAL;\n     }\n    if ((cmdCode == EFFECT_CMD_SET_PARAM\n            || cmdCode == EFFECT_CMD_SET_PARAM_DEFERRED) &&  // DEFERRED not generally used\n        (sizeof(effect_param_t) > cmdSize\n            || ((effect_param_t *)pCmdData)->psize > cmdSize\n                                                     - sizeof(effect_param_t)\n            || ((effect_param_t *)pCmdData)->vsize > cmdSize\n                                                     - sizeof(effect_param_t)\n                                                     - ((effect_param_t *)pCmdData)->psize\n            || roundUpDelta(((effect_param_t *)pCmdData)->psize, (uint32_t)sizeof(int)) >\n                                                     cmdSize\n                                                     - sizeof(effect_param_t)\n                                                     - ((effect_param_t *)pCmdData)->psize\n                                                     - ((effect_param_t *)pCmdData)->vsize)) {\n        android_errorWriteLog(0x534e4554, \"30204301\");\n        return -EINVAL;\n    }\n     status_t status = (*mEffectInterface)->command(mEffectInterface,\n                                                    cmdCode,\n                                                    cmdSize,\n                                                   pCmdData,\n                                                   replySize,\n                                                   pReplyData);\n if (cmdCode != EFFECT_CMD_GET_PARAM && status == NO_ERROR) {\n uint32_t size = (replySize == NULL) ? 0 : *replySize;\n for (size_t i = 1; i < mHandles.size(); i++) {\n EffectHandle *h = mHandles[i];\n if (h != NULL && !h->destroyed_l()) {\n                h->commandExecuted(cmdCode, cmdSize, pCmdData, size, pReplyData);\n }\n }\n }\n return status;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143818,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": " static byte parseHexByte(const char * &str) {\n     byte b = parseHexChar(str[0]);\n    if (str[1] == ':' || str[1] == '\\0') {\n        str += 2;\n        return b;\n     } else {\n         b = b << 4 | parseHexChar(str[1]);\n        str += 3;\n        return b;\n     }\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143829,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": " static byte parseHexByte(const char * &str) {\n    if (str[0] == '\\0') {\n        ALOGE(\"Passed an empty string\");\n        return 0;\n    }\n     byte b = parseHexChar(str[0]);\n    if (str[1] == '\\0' || str[1] == ':') {\n        str ++;\n     } else {\n         b = b << 4 | parseHexChar(str[1]);\n        str += 2;\n     }\n\n    // Skip trailing delimiter if not at the end of the string.\n    if (str[0] != '\\0') {\n        str++;\n    }\n    return b;\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143830,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": " INLINE void impeg2d_bit_stream_flush(void* pv_ctxt, UWORD32 u4_no_of_bits)\n {\n     stream_t *ps_stream = (stream_t *)pv_ctxt;\n    if (ps_stream->u4_offset < ps_stream->u4_max_offset)\n     {\n         FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)\n     }\n     return;\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143839,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": " INLINE void impeg2d_bit_stream_flush(void* pv_ctxt, UWORD32 u4_no_of_bits)\n {\n     stream_t *ps_stream = (stream_t *)pv_ctxt;\n    if ((ps_stream->u4_offset + 64) < ps_stream->u4_max_offset)\n     {\n         FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)\n     }\n    else\n    {\n        UWORD32     u4_temp;\n\n        if (((ps_stream->u4_offset & 0x1f) + u4_no_of_bits) >= 32)\n        {\n            ps_stream->u4_buf              = ps_stream->u4_buf_nxt;\n            ps_stream->u4_buf_nxt          = 0;\n        }\n        ps_stream->u4_offset += u4_no_of_bits;\n    }\n     return;\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143840,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "AudioSource::AudioSource(\n audio_source_t inputSource, const String16 &opPackageName,\n uint32_t sampleRate, uint32_t channelCount, uint32_t outSampleRate)\n\n     : mStarted(false),\n       mSampleRate(sampleRate),\n       mOutSampleRate(outSampleRate > 0 ? outSampleRate : sampleRate),\n       mPrevSampleTimeUs(0),\n       mFirstSampleTimeUs(-1ll),\n       mNumFramesReceived(0),\n       mNumClientOwnedBuffers(0) {\n     ALOGV(\"sampleRate: %u, outSampleRate: %u, channelCount: %u\",\n            sampleRate, outSampleRate, channelCount);\n    CHECK(channelCount == 1 || channelCount == 2);\n    CHECK(sampleRate > 0);\n\n size_t minFrameCount;\n status_t status = AudioRecord::getMinFrameCount(&minFrameCount,\n                                           sampleRate,\n                                           AUDIO_FORMAT_PCM_16_BIT,\n                                           audio_channel_in_mask_from_count(channelCount));\n if (status == OK) {\n uint32_t frameCount = kMaxBufferSize / sizeof(int16_t) / channelCount;\n\n size_t bufCount = 2;\n while ((bufCount * frameCount) < minFrameCount) {\n            bufCount++;\n }\n\n        mRecord = new AudioRecord(\n                    inputSource, sampleRate, AUDIO_FORMAT_PCM_16_BIT,\n                    audio_channel_in_mask_from_count(channelCount),\n                    opPackageName,\n (size_t) (bufCount * frameCount),\n AudioRecordCallbackFunction,\n this,\n                    frameCount /*notificationFrames*/);\n        mInitCheck = mRecord->initCheck();\n if (mInitCheck != OK) {\n            mRecord.clear();\n }\n } else {\n        mInitCheck = status;\n }\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143853,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "AudioSource::AudioSource(\n audio_source_t inputSource, const String16 &opPackageName,\n uint32_t sampleRate, uint32_t channelCount, uint32_t outSampleRate)\n\n     : mStarted(false),\n       mSampleRate(sampleRate),\n       mOutSampleRate(outSampleRate > 0 ? outSampleRate : sampleRate),\n      mTrackMaxAmplitude(false),\n      mStartTimeUs(0),\n      mMaxAmplitude(0),\n       mPrevSampleTimeUs(0),\n       mFirstSampleTimeUs(-1ll),\n      mInitialReadTimeUs(0),\n       mNumFramesReceived(0),\n       mNumClientOwnedBuffers(0) {\n     ALOGV(\"sampleRate: %u, outSampleRate: %u, channelCount: %u\",\n            sampleRate, outSampleRate, channelCount);\n    CHECK(channelCount == 1 || channelCount == 2);\n    CHECK(sampleRate > 0);\n\n size_t minFrameCount;\n status_t status = AudioRecord::getMinFrameCount(&minFrameCount,\n                                           sampleRate,\n                                           AUDIO_FORMAT_PCM_16_BIT,\n                                           audio_channel_in_mask_from_count(channelCount));\n if (status == OK) {\n uint32_t frameCount = kMaxBufferSize / sizeof(int16_t) / channelCount;\n\n size_t bufCount = 2;\n while ((bufCount * frameCount) < minFrameCount) {\n            bufCount++;\n }\n\n        mRecord = new AudioRecord(\n                    inputSource, sampleRate, AUDIO_FORMAT_PCM_16_BIT,\n                    audio_channel_in_mask_from_count(channelCount),\n                    opPackageName,\n (size_t) (bufCount * frameCount),\n AudioRecordCallbackFunction,\n this,\n                    frameCount /*notificationFrames*/);\n        mInitCheck = mRecord->initCheck();\n if (mInitCheck != OK) {\n            mRecord.clear();\n }\n } else {\n        mInitCheck = status;\n }\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143854,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "status_t BnCrypto::onTransact(\n uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {\n switch (code) {\n case INIT_CHECK:\n {\n            CHECK_INTERFACE(ICrypto, data, reply);\n            reply->writeInt32(initCheck());\n\n return OK;\n }\n\n case IS_CRYPTO_SUPPORTED:\n {\n            CHECK_INTERFACE(ICrypto, data, reply);\n uint8_t uuid[16];\n            data.read(uuid, sizeof(uuid));\n            reply->writeInt32(isCryptoSchemeSupported(uuid));\n\n return OK;\n }\n\n case CREATE_PLUGIN:\n {\n            CHECK_INTERFACE(ICrypto, data, reply);\n\n uint8_t uuid[16];\n            data.read(uuid, sizeof(uuid));\n\n size_t opaqueSize = data.readInt32();\n void *opaqueData = NULL;\n\n if (opaqueSize > 0) {\n                opaqueData = malloc(opaqueSize);\n                data.read(opaqueData, opaqueSize);\n }\n\n            reply->writeInt32(createPlugin(uuid, opaqueData, opaqueSize));\n\n if (opaqueData != NULL) {\n                free(opaqueData);\n                opaqueData = NULL;\n }\n\n return OK;\n }\n\n case DESTROY_PLUGIN:\n {\n            CHECK_INTERFACE(ICrypto, data, reply);\n            reply->writeInt32(destroyPlugin());\n\n return OK;\n }\n\n case REQUIRES_SECURE_COMPONENT:\n {\n            CHECK_INTERFACE(ICrypto, data, reply);\n\n const char *mime = data.readCString();\n            reply->writeInt32(requiresSecureDecoderComponent(mime));\n\n return OK;\n }\n\n case DECRYPT:\n {\n            CHECK_INTERFACE(ICrypto, data, reply);\n\n bool secure = data.readInt32() != 0;\n CryptoPlugin::Mode mode = (CryptoPlugin::Mode)data.readInt32();\n\n uint8_t key[16];\n            data.read(key, sizeof(key));\n\n uint8_t iv[16];\n            data.read(iv, sizeof(iv));\n\n size_t totalSize = data.readInt32();\n            sp<IMemory> sharedBuffer =\n                interface_cast<IMemory>(data.readStrongBinder());\n int32_t offset = data.readInt32();\n\n int32_t numSubSamples = data.readInt32();\n\n CryptoPlugin::SubSample *subSamples =\n new CryptoPlugin::SubSample[numSubSamples];\n\n            data.read(\n                    subSamples,\n sizeof(CryptoPlugin::SubSample) * numSubSamples);\n\n void *secureBufferId, *dstPtr;\n if (secure) {\n                secureBufferId = reinterpret_cast<void *>(static_cast<uintptr_t>(data.readInt64()));\n } else {\n                dstPtr = calloc(1, totalSize);\n }\n\n AString errorDetailMsg;\n ssize_t result;\n\n size_t sumSubsampleSizes = 0;\n bool overflow = false;\n for (int32_t i = 0; i < numSubSamples; ++i) {\n CryptoPlugin::SubSample &ss = subSamples[i];\n if (sumSubsampleSizes <= SIZE_MAX - ss.mNumBytesOfEncryptedData) {\n                    sumSubsampleSizes += ss.mNumBytesOfEncryptedData;\n } else {\n                    overflow = true;\n }\n if (sumSubsampleSizes <= SIZE_MAX - ss.mNumBytesOfClearData) {\n                    sumSubsampleSizes += ss.mNumBytesOfClearData;\n } else {\n                    overflow = true;\n }\n }\n\n \n             if (overflow || sumSubsampleSizes != totalSize) {\n                 result = -EINVAL;\n            } else if (offset + totalSize > sharedBuffer->size()) {\n                 result = -EINVAL;\n             } else {\n                 result = decrypt(\n                    secure,\n                    key,\n                    iv,\n                    mode,\n                    sharedBuffer, offset,\n                    subSamples, numSubSamples,\n                    secure ? secureBufferId : dstPtr,\n &errorDetailMsg);\n }\n\n            reply->writeInt32(result);\n\n if (isCryptoError(result)) {\n                reply->writeCString(errorDetailMsg.c_str());\n }\n\n if (!secure) {\n if (result >= 0) {\n                    CHECK_LE(result, static_cast<ssize_t>(totalSize));\n                    reply->write(dstPtr, result);\n }\n                free(dstPtr);\n                dstPtr = NULL;\n }\n\n delete[] subSamples;\n            subSamples = NULL;\n\n return OK;\n }\n\n case NOTIFY_RESOLUTION:\n {\n            CHECK_INTERFACE(ICrypto, data, reply);\n\n int32_t width = data.readInt32();\n int32_t height = data.readInt32();\n            notifyResolution(width, height);\n\n return OK;\n }\n\n case SET_MEDIADRM_SESSION:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n Vector<uint8_t> sessionId;\n            readVector(data, sessionId);\n            reply->writeInt32(setMediaDrmSession(sessionId));\n return OK;\n }\n\n default:\n return BBinder::onTransact(code, data, reply, flags);\n }\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143871,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "status_t BnCrypto::onTransact(\n uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {\n switch (code) {\n case INIT_CHECK:\n {\n            CHECK_INTERFACE(ICrypto, data, reply);\n            reply->writeInt32(initCheck());\n\n return OK;\n }\n\n case IS_CRYPTO_SUPPORTED:\n {\n            CHECK_INTERFACE(ICrypto, data, reply);\n uint8_t uuid[16];\n            data.read(uuid, sizeof(uuid));\n            reply->writeInt32(isCryptoSchemeSupported(uuid));\n\n return OK;\n }\n\n case CREATE_PLUGIN:\n {\n            CHECK_INTERFACE(ICrypto, data, reply);\n\n uint8_t uuid[16];\n            data.read(uuid, sizeof(uuid));\n\n size_t opaqueSize = data.readInt32();\n void *opaqueData = NULL;\n\n if (opaqueSize > 0) {\n                opaqueData = malloc(opaqueSize);\n                data.read(opaqueData, opaqueSize);\n }\n\n            reply->writeInt32(createPlugin(uuid, opaqueData, opaqueSize));\n\n if (opaqueData != NULL) {\n                free(opaqueData);\n                opaqueData = NULL;\n }\n\n return OK;\n }\n\n case DESTROY_PLUGIN:\n {\n            CHECK_INTERFACE(ICrypto, data, reply);\n            reply->writeInt32(destroyPlugin());\n\n return OK;\n }\n\n case REQUIRES_SECURE_COMPONENT:\n {\n            CHECK_INTERFACE(ICrypto, data, reply);\n\n const char *mime = data.readCString();\n            reply->writeInt32(requiresSecureDecoderComponent(mime));\n\n return OK;\n }\n\n case DECRYPT:\n {\n            CHECK_INTERFACE(ICrypto, data, reply);\n\n bool secure = data.readInt32() != 0;\n CryptoPlugin::Mode mode = (CryptoPlugin::Mode)data.readInt32();\n\n uint8_t key[16];\n            data.read(key, sizeof(key));\n\n uint8_t iv[16];\n            data.read(iv, sizeof(iv));\n\n size_t totalSize = data.readInt32();\n            sp<IMemory> sharedBuffer =\n                interface_cast<IMemory>(data.readStrongBinder());\n int32_t offset = data.readInt32();\n\n int32_t numSubSamples = data.readInt32();\n\n CryptoPlugin::SubSample *subSamples =\n new CryptoPlugin::SubSample[numSubSamples];\n\n            data.read(\n                    subSamples,\n sizeof(CryptoPlugin::SubSample) * numSubSamples);\n\n void *secureBufferId, *dstPtr;\n if (secure) {\n                secureBufferId = reinterpret_cast<void *>(static_cast<uintptr_t>(data.readInt64()));\n } else {\n                dstPtr = calloc(1, totalSize);\n }\n\n AString errorDetailMsg;\n ssize_t result;\n\n size_t sumSubsampleSizes = 0;\n bool overflow = false;\n for (int32_t i = 0; i < numSubSamples; ++i) {\n CryptoPlugin::SubSample &ss = subSamples[i];\n if (sumSubsampleSizes <= SIZE_MAX - ss.mNumBytesOfEncryptedData) {\n                    sumSubsampleSizes += ss.mNumBytesOfEncryptedData;\n } else {\n                    overflow = true;\n }\n if (sumSubsampleSizes <= SIZE_MAX - ss.mNumBytesOfClearData) {\n                    sumSubsampleSizes += ss.mNumBytesOfClearData;\n } else {\n                    overflow = true;\n }\n }\n\n \n             if (overflow || sumSubsampleSizes != totalSize) {\n                 result = -EINVAL;\n            } else if (totalSize > sharedBuffer->size()) {\n                result = -EINVAL;\n            } else if ((size_t)offset > sharedBuffer->size() - totalSize) {\n                 result = -EINVAL;\n             } else {\n                 result = decrypt(\n                    secure,\n                    key,\n                    iv,\n                    mode,\n                    sharedBuffer, offset,\n                    subSamples, numSubSamples,\n                    secure ? secureBufferId : dstPtr,\n &errorDetailMsg);\n }\n\n            reply->writeInt32(result);\n\n if (isCryptoError(result)) {\n                reply->writeCString(errorDetailMsg.c_str());\n }\n\n if (!secure) {\n if (result >= 0) {\n                    CHECK_LE(result, static_cast<ssize_t>(totalSize));\n                    reply->write(dstPtr, result);\n }\n                free(dstPtr);\n                dstPtr = NULL;\n }\n\n delete[] subSamples;\n            subSamples = NULL;\n\n return OK;\n }\n\n case NOTIFY_RESOLUTION:\n {\n            CHECK_INTERFACE(ICrypto, data, reply);\n\n int32_t width = data.readInt32();\n int32_t height = data.readInt32();\n            notifyResolution(width, height);\n\n return OK;\n }\n\n case SET_MEDIADRM_SESSION:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n Vector<uint8_t> sessionId;\n            readVector(data, sessionId);\n            reply->writeInt32(setMediaDrmSession(sessionId));\n return OK;\n }\n\n default:\n return BBinder::onTransact(code, data, reply, flags);\n }\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143872,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static void debugCallback (int fd, short flags, void *param) {\n int acceptFD, option;\n struct sockaddr_un peeraddr;\n socklen_t socklen = sizeof (peeraddr);\n\n     int data;\n     unsigned int qxdm_data[6];\n     const char *deactData[1] = {\"1\"};\n    char *actData[1];\n     RIL_Dial dialData;\n     int hangupData[1] = {1};\n     int number;\n     char **args;\n     RIL_SOCKET_ID socket_id = RIL_SOCKET_1;\n     int sim_id = 0;\n \n     RLOGI(\"debugCallback for socket %s\", rilSocketIdToString(socket_id));\n\n    acceptFD = accept (fd, (sockaddr *) &peeraddr, &socklen);\n\n if (acceptFD < 0) {\n        RLOGE (\"error accepting on debug port: %d\\n\", errno);\n return;\n }\n\n if (recv(acceptFD, &number, sizeof(int), 0) != sizeof(int)) {\n        RLOGE (\"error reading on socket: number of Args: \\n\");\n        close(acceptFD);\n return;\n }\n\n if (number < 0) {\n        RLOGE (\"Invalid number of arguments: \\n\");\n        close(acceptFD);\n return;\n }\n\n    args = (char **) calloc(number, sizeof(char*));\n if (args == NULL) {\n        RLOGE(\"Memory allocation failed for debug args\");\n        close(acceptFD);\n return;\n }\n\n for (int i = 0; i < number; i++) {\n int len;\n if (recv(acceptFD, &len, sizeof(int), 0) != sizeof(int)) {\n            RLOGE (\"error reading on socket: Len of Args: \\n\");\n            freeDebugCallbackArgs(i, args);\n            close(acceptFD);\n return;\n }\n if (len == INT_MAX || len < 0) {\n            RLOGE(\"Invalid value of len: \\n\");\n            freeDebugCallbackArgs(i, args);\n            close(acceptFD);\n return;\n }\n\n        args[i] = (char *) calloc(len + 1, sizeof(char));\n if (args[i] == NULL) {\n            RLOGE(\"Memory allocation failed for debug args\");\n            freeDebugCallbackArgs(i, args);\n            close(acceptFD);\n return;\n }\n if (recv(acceptFD, args[i], sizeof(char) * len, 0)\n != (int)sizeof(char) * len) {\n            RLOGE (\"error reading on socket: Args[%d] \\n\", i);\n            freeDebugCallbackArgs(i, args);\n            close(acceptFD);\n return;\n }\n char * buf = args[i];\n        buf[len] = 0;\n if ((i+1) == number) {\n /* The last argument should be sim id 0(SIM1)~3(SIM4) */\n            sim_id = atoi(args[i]);\n switch (sim_id) {\n case 0:\n                    socket_id = RIL_SOCKET_1;\n break;\n #if (SIM_COUNT >= 2)\n case 1:\n                    socket_id = RIL_SOCKET_2;\n break;\n #endif\n #if (SIM_COUNT >= 3)\n case 2:\n                    socket_id = RIL_SOCKET_3;\n break;\n #endif\n #if (SIM_COUNT >= 4)\n case 3:\n                    socket_id = RIL_SOCKET_4;\n break;\n #endif\n default:\n                    socket_id = RIL_SOCKET_1;\n break;\n }\n }\n }\n\n switch (atoi(args[0])) {\n case 0:\n            RLOGI (\"Connection on debug port: issuing reset.\");\n            issueLocalRequest(RIL_REQUEST_RESET_RADIO, NULL, 0, socket_id);\n break;\n case 1:\n            RLOGI (\"Connection on debug port: issuing radio power off.\");\n            data = 0;\n            issueLocalRequest(RIL_REQUEST_RADIO_POWER, &data, sizeof(int), socket_id);\n if (socket_id == RIL_SOCKET_1 && s_ril_param_socket.fdCommand > 0) {\n                close(s_ril_param_socket.fdCommand);\n                s_ril_param_socket.fdCommand = -1;\n }\n #if (SIM_COUNT == 2)\n else if (socket_id == RIL_SOCKET_2 && s_ril_param_socket2.fdCommand > 0) {\n                close(s_ril_param_socket2.fdCommand);\n                s_ril_param_socket2.fdCommand = -1;\n }\n #endif\n break;\n case 2:\n            RLOGI (\"Debug port: issuing unsolicited voice network change.\");\n            RIL_UNSOL_RESPONSE(RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED, NULL, 0, socket_id);\n break;\n case 3:\n            RLOGI (\"Debug port: QXDM log enable.\");\n            qxdm_data[0] = 65536; // head.func_tag\n            qxdm_data[1] = 16; // head.len\n            qxdm_data[2] = 1; // mode: 1 for 'start logging'\n            qxdm_data[3] = 32; // log_file_size: 32megabytes\n            qxdm_data[4] = 0; // log_mask\n            qxdm_data[5] = 8; // log_max_fileindex\n            issueLocalRequest(RIL_REQUEST_OEM_HOOK_RAW, qxdm_data,\n 6 * sizeof(int), socket_id);\n break;\n case 4:\n            RLOGI (\"Debug port: QXDM log disable.\");\n            qxdm_data[0] = 65536;\n            qxdm_data[1] = 16;\n            qxdm_data[2] = 0; // mode: 0 for 'stop logging'\n            qxdm_data[3] = 32;\n            qxdm_data[4] = 0;\n            qxdm_data[5] = 8;\n            issueLocalRequest(RIL_REQUEST_OEM_HOOK_RAW, qxdm_data,\n 6 * sizeof(int), socket_id);\n break;\n case 5:\n            RLOGI(\"Debug port: Radio On\");\n            data = 1;\n            issueLocalRequest(RIL_REQUEST_RADIO_POWER, &data, sizeof(int), socket_id);\n            sleep(2);\n\n             issueLocalRequest(RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC, NULL, 0, socket_id);\n             break;\n        case 6:\n            RLOGI(\"Debug port: Setup Data Call, Apn :%s\\n\", args[1]);\n            actData[0] = args[1];\n            issueLocalRequest(RIL_REQUEST_SETUP_DATA_CALL, &actData,\n                              sizeof(actData), socket_id);\n            break;\n         case 7:\n             RLOGI(\"Debug port: Deactivate Data Call\");\n             issueLocalRequest(RIL_REQUEST_DEACTIVATE_DATA_CALL, &deactData,\n sizeof(deactData), socket_id);\n break;\n\n         case 8:\n             RLOGI(\"Debug port: Dial Call\");\n             dialData.clir = 0;\n             dialData.address = args[1];\n             issueLocalRequest(RIL_REQUEST_DIAL, &dialData, sizeof(dialData), socket_id);\n             break;\n case 9:\n            RLOGI(\"Debug port: Answer Call\");\n            issueLocalRequest(RIL_REQUEST_ANSWER, NULL, 0, socket_id);\n break;\n case 10:\n            RLOGI(\"Debug port: End Call\");\n            issueLocalRequest(RIL_REQUEST_HANGUP, &hangupData,\n sizeof(hangupData), socket_id);\n break;\n default:\n            RLOGE (\"Invalid request\");\n break;\n }\n    freeDebugCallbackArgs(number, args);\n    close(acceptFD);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143875,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static void debugCallback (int fd, short flags, void *param) {\n int acceptFD, option;\n struct sockaddr_un peeraddr;\n socklen_t socklen = sizeof (peeraddr);\n\n     int data;\n     unsigned int qxdm_data[6];\n     const char *deactData[1] = {\"1\"};\n     RIL_Dial dialData;\n     int hangupData[1] = {1};\n     int number;\n     char **args;\n     RIL_SOCKET_ID socket_id = RIL_SOCKET_1;\n    int MAX_DIAL_ADDRESS = 128;\n     int sim_id = 0;\n \n     RLOGI(\"debugCallback for socket %s\", rilSocketIdToString(socket_id));\n\n    acceptFD = accept (fd, (sockaddr *) &peeraddr, &socklen);\n\n if (acceptFD < 0) {\n        RLOGE (\"error accepting on debug port: %d\\n\", errno);\n return;\n }\n\n if (recv(acceptFD, &number, sizeof(int), 0) != sizeof(int)) {\n        RLOGE (\"error reading on socket: number of Args: \\n\");\n        close(acceptFD);\n return;\n }\n\n if (number < 0) {\n        RLOGE (\"Invalid number of arguments: \\n\");\n        close(acceptFD);\n return;\n }\n\n    args = (char **) calloc(number, sizeof(char*));\n if (args == NULL) {\n        RLOGE(\"Memory allocation failed for debug args\");\n        close(acceptFD);\n return;\n }\n\n for (int i = 0; i < number; i++) {\n int len;\n if (recv(acceptFD, &len, sizeof(int), 0) != sizeof(int)) {\n            RLOGE (\"error reading on socket: Len of Args: \\n\");\n            freeDebugCallbackArgs(i, args);\n            close(acceptFD);\n return;\n }\n if (len == INT_MAX || len < 0) {\n            RLOGE(\"Invalid value of len: \\n\");\n            freeDebugCallbackArgs(i, args);\n            close(acceptFD);\n return;\n }\n\n        args[i] = (char *) calloc(len + 1, sizeof(char));\n if (args[i] == NULL) {\n            RLOGE(\"Memory allocation failed for debug args\");\n            freeDebugCallbackArgs(i, args);\n            close(acceptFD);\n return;\n }\n if (recv(acceptFD, args[i], sizeof(char) * len, 0)\n != (int)sizeof(char) * len) {\n            RLOGE (\"error reading on socket: Args[%d] \\n\", i);\n            freeDebugCallbackArgs(i, args);\n            close(acceptFD);\n return;\n }\n char * buf = args[i];\n        buf[len] = 0;\n if ((i+1) == number) {\n /* The last argument should be sim id 0(SIM1)~3(SIM4) */\n            sim_id = atoi(args[i]);\n switch (sim_id) {\n case 0:\n                    socket_id = RIL_SOCKET_1;\n break;\n #if (SIM_COUNT >= 2)\n case 1:\n                    socket_id = RIL_SOCKET_2;\n break;\n #endif\n #if (SIM_COUNT >= 3)\n case 2:\n                    socket_id = RIL_SOCKET_3;\n break;\n #endif\n #if (SIM_COUNT >= 4)\n case 3:\n                    socket_id = RIL_SOCKET_4;\n break;\n #endif\n default:\n                    socket_id = RIL_SOCKET_1;\n break;\n }\n }\n }\n\n switch (atoi(args[0])) {\n case 0:\n            RLOGI (\"Connection on debug port: issuing reset.\");\n            issueLocalRequest(RIL_REQUEST_RESET_RADIO, NULL, 0, socket_id);\n break;\n case 1:\n            RLOGI (\"Connection on debug port: issuing radio power off.\");\n            data = 0;\n            issueLocalRequest(RIL_REQUEST_RADIO_POWER, &data, sizeof(int), socket_id);\n if (socket_id == RIL_SOCKET_1 && s_ril_param_socket.fdCommand > 0) {\n                close(s_ril_param_socket.fdCommand);\n                s_ril_param_socket.fdCommand = -1;\n }\n #if (SIM_COUNT == 2)\n else if (socket_id == RIL_SOCKET_2 && s_ril_param_socket2.fdCommand > 0) {\n                close(s_ril_param_socket2.fdCommand);\n                s_ril_param_socket2.fdCommand = -1;\n }\n #endif\n break;\n case 2:\n            RLOGI (\"Debug port: issuing unsolicited voice network change.\");\n            RIL_UNSOL_RESPONSE(RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED, NULL, 0, socket_id);\n break;\n case 3:\n            RLOGI (\"Debug port: QXDM log enable.\");\n            qxdm_data[0] = 65536; // head.func_tag\n            qxdm_data[1] = 16; // head.len\n            qxdm_data[2] = 1; // mode: 1 for 'start logging'\n            qxdm_data[3] = 32; // log_file_size: 32megabytes\n            qxdm_data[4] = 0; // log_mask\n            qxdm_data[5] = 8; // log_max_fileindex\n            issueLocalRequest(RIL_REQUEST_OEM_HOOK_RAW, qxdm_data,\n 6 * sizeof(int), socket_id);\n break;\n case 4:\n            RLOGI (\"Debug port: QXDM log disable.\");\n            qxdm_data[0] = 65536;\n            qxdm_data[1] = 16;\n            qxdm_data[2] = 0; // mode: 0 for 'stop logging'\n            qxdm_data[3] = 32;\n            qxdm_data[4] = 0;\n            qxdm_data[5] = 8;\n            issueLocalRequest(RIL_REQUEST_OEM_HOOK_RAW, qxdm_data,\n 6 * sizeof(int), socket_id);\n break;\n case 5:\n            RLOGI(\"Debug port: Radio On\");\n            data = 1;\n            issueLocalRequest(RIL_REQUEST_RADIO_POWER, &data, sizeof(int), socket_id);\n            sleep(2);\n\n             issueLocalRequest(RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC, NULL, 0, socket_id);\n             break;\n         case 7:\n             RLOGI(\"Debug port: Deactivate Data Call\");\n             issueLocalRequest(RIL_REQUEST_DEACTIVATE_DATA_CALL, &deactData,\n sizeof(deactData), socket_id);\n break;\n\n         case 8:\n             RLOGI(\"Debug port: Dial Call\");\n             dialData.clir = 0;\n            if (strlen(args[1]) > MAX_DIAL_ADDRESS) {\n                RLOGE(\"Debug port: Error calling Dial\");\n                freeDebugCallbackArgs(number, args);\n                close(acceptFD);\n                return;\n            }\n             dialData.address = args[1];\n             issueLocalRequest(RIL_REQUEST_DIAL, &dialData, sizeof(dialData), socket_id);\n             break;\n case 9:\n            RLOGI(\"Debug port: Answer Call\");\n            issueLocalRequest(RIL_REQUEST_ANSWER, NULL, 0, socket_id);\n break;\n case 10:\n            RLOGI(\"Debug port: End Call\");\n            issueLocalRequest(RIL_REQUEST_HANGUP, &hangupData,\n sizeof(hangupData), socket_id);\n break;\n default:\n            RLOGE (\"Invalid request\");\n break;\n }\n    freeDebugCallbackArgs(number, args);\n    close(acceptFD);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143876,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "IMPEG2D_ERROR_CODES_T impeg2d_vld_decode(\n dec_state_t *ps_dec,\n    WORD16      *pi2_outAddr, /*!< Address where decoded symbols will be stored */\n const UWORD8 *pu1_scan, /*!< Scan table to be used */\n    UWORD8      *pu1_pos, /*!< Scan table to be used */\n    UWORD16     u2_intra_flag, /*!< Intra Macroblock or not */\n    UWORD16     u2_chroma_flag, /*!< Chroma Block or not */\n    UWORD16     u2_d_picture, /*!< D Picture or not */\n    UWORD16     u2_intra_vlc_format, /*!< Intra VLC format */\n    UWORD16     u2_mpeg2, /*!< MPEG-2 or not */\n    WORD32      *pi4_num_coeffs /*!< Returns the number of coeffs in block */\n )\n{\n\n    UWORD32 u4_sym_len;\n\n    UWORD32 u4_decoded_value;\n    UWORD32 u4_level_first_byte;\n    WORD32  u4_level;\n    UWORD32 u4_run, u4_numCoeffs;\n    UWORD32 u4_buf;\n    UWORD32 u4_buf_nxt;\n    UWORD32 u4_offset;\n    UWORD32 *pu4_buf_aligned;\n    UWORD32 u4_bits;\n stream_t *ps_stream = &ps_dec->s_bit_stream;\n    WORD32  u4_pos;\n    UWORD32 u4_nz_cols;\n    UWORD32 u4_nz_rows;\n\n *pi4_num_coeffs = 0;\n\n    ps_dec->u4_non_zero_cols = 0;\n    ps_dec->u4_non_zero_rows = 0;\n    u4_nz_cols = ps_dec->u4_non_zero_cols;\n    u4_nz_rows = ps_dec->u4_non_zero_rows;\n\n    GET_TEMP_STREAM_DATA(u4_buf,u4_buf_nxt,u4_offset,pu4_buf_aligned,ps_stream)\n /**************************************************************************/\n /* Decode the DC coefficient in case of Intra block                       */\n /**************************************************************************/\n if(u2_intra_flag)\n {\n        WORD32 dc_size;\n        WORD32 dc_diff;\n        WORD32 maxLen;\n        WORD32 idx;\n\n\n        maxLen = MPEG2_DCT_DC_SIZE_LEN;\n        idx = 0;\n if(u2_chroma_flag != 0)\n {\n            maxLen += 1;\n            idx++;\n }\n\n\n {\n            WORD16  end = 0;\n            UWORD32 maxLen_tmp = maxLen;\n            UWORD16 m_iBit;\n\n\n /* Get the maximum number of bits needed to decode a symbol */\n            IBITS_NXT(u4_buf,u4_buf_nxt,u4_offset,u4_bits,maxLen)\n do\n {\n                maxLen_tmp--;\n /* Read one bit at a time from the variable to decode the huffman code */\n                m_iBit = (UWORD8)((u4_bits >> maxLen_tmp) & 0x1);\n\n /* Get the next node pointer or the symbol from the tree */\n                end = gai2_impeg2d_dct_dc_size[idx][end][m_iBit];\n }while(end > 0);\n            dc_size = end + MPEG2_DCT_DC_SIZE_OFFSET;\n\n /* Flush the appropriate number of bits from the stream */\n            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,(maxLen - maxLen_tmp),pu4_buf_aligned)\n\n }\n\n\n\n if (dc_size != 0)\n {\n            UWORD32 u4_bits;\n\n            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned, dc_size)\n            dc_diff = u4_bits;\n\n if ((dc_diff & (1 << (dc_size - 1))) == 0) //v Probably the prediction algo?\n                dc_diff -= (1 << dc_size) - 1;\n }\n else\n {\n            dc_diff = 0;\n }\n\n\n        pi2_outAddr[*pi4_num_coeffs] = dc_diff;\n /* This indicates the position of the coefficient. Since this is the DC\n         * coefficient, we put the position as 0.\n         */\n        pu1_pos[*pi4_num_coeffs] = pu1_scan[0];\n (*pi4_num_coeffs)++;\n\n if (0 != dc_diff)\n {\n            u4_nz_cols |= 0x01;\n            u4_nz_rows |= 0x01;\n }\n\n        u4_numCoeffs = 1;\n }\n /**************************************************************************/\n /* Decoding of first AC coefficient in case of non Intra block            */\n /**************************************************************************/\n else\n {\n /* First symbol can be 1s */\n        UWORD32 u4_bits;\n\n        IBITS_NXT(u4_buf,u4_buf_nxt,u4_offset,u4_bits,1)\n\n if(u4_bits == 1)\n {\n\n            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,1, pu4_buf_aligned)\n            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned, 1)\n if(u4_bits == 1)\n {\n                pi2_outAddr[*pi4_num_coeffs] = -1;\n }\n else\n {\n                pi2_outAddr[*pi4_num_coeffs] = 1;\n }\n\n /* This indicates the position of the coefficient. Since this is the DC\n             * coefficient, we put the position as 0.\n             */\n            pu1_pos[*pi4_num_coeffs] = pu1_scan[0];\n (*pi4_num_coeffs)++;\n            u4_numCoeffs = 1;\n\n            u4_nz_cols |= 0x01;\n            u4_nz_rows |= 0x01;\n }\n else\n {\n            u4_numCoeffs = 0;\n }\n }\n if (1 == u2_d_picture)\n {\n        PUT_TEMP_STREAM_DATA(u4_buf, u4_buf_nxt, u4_offset, pu4_buf_aligned, ps_stream)\n        ps_dec->u4_non_zero_cols  = u4_nz_cols;\n        ps_dec->u4_non_zero_rows  = u4_nz_rows;\n return ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE);\n }\n\n\n\n if (1 == u2_intra_vlc_format && u2_intra_flag)\n {\n\n while(1)\n {\n\n                UWORD32 lead_zeros;\n                WORD16 DecodedValue;\n\n\n                 u4_sym_len = 17;\n                 IBITS_NXT(u4_buf,u4_buf_nxt,u4_offset,u4_bits,u4_sym_len)\n \n                 DecodedValue = gau2_impeg2d_tab_one_1_9[u4_bits >> 8];\n                 u4_sym_len = (DecodedValue & 0xf);\n                 u4_level = DecodedValue >> 9;\n /* One table lookup */\n if(0 != u4_level)\n {\n                    u4_run = ((DecodedValue >> 4) & 0x1f);\n                    u4_numCoeffs       += u4_run;\n                    u4_pos             = pu1_scan[u4_numCoeffs++ & 63];\n                    pu1_pos[*pi4_num_coeffs] = u4_pos;\n\n                    FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)\n                    pi2_outAddr[*pi4_num_coeffs] = u4_level;\n\n (*pi4_num_coeffs)++;\n }\n else\n {\n if (DecodedValue == END_OF_BLOCK_ONE)\n {\n                        u4_sym_len = 4;\n\n break;\n }\n else\n {\n /*Second table lookup*/\n                        lead_zeros = CLZ(u4_bits) - 20;/* -16 since we are dealing with WORD32 */\n if (0 != lead_zeros)\n {\n\n                            u4_bits         = (u4_bits >> (6 - lead_zeros)) & 0x001F;\n\n /* Flush the number of bits */\n if (1 == lead_zeros)\n {\n                                u4_sym_len         = ((u4_bits & 0x18) >> 3) == 2 ? 11:10;\n }\n else\n {\n                                u4_sym_len         = 11 + lead_zeros;\n }\n /* flushing */\n                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)\n\n /* Calculate the address */\n                            u4_bits         = ((lead_zeros - 1) << 5) + u4_bits;\n\n DecodedValue = gau2_impeg2d_tab_one_10_16[u4_bits];\n\n                            u4_run = BITS(DecodedValue, 8,4);\n                            u4_level = ((WORD16) DecodedValue) >> 9;\n\n                            u4_numCoeffs       += u4_run;\n                            u4_pos             = pu1_scan[u4_numCoeffs++ & 63];\n                            pu1_pos[*pi4_num_coeffs] = u4_pos;\n                            pi2_outAddr[*pi4_num_coeffs] = u4_level;\n (*pi4_num_coeffs)++;\n }\n /*********************************************************************/\n /* MPEG2 Escape Code                                                 */\n /*********************************************************************/\n else if(u2_mpeg2 == 1)\n {\n                            u4_sym_len         = 6;\n                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)\n                                IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,18)\n                                u4_decoded_value    = u4_bits;\n                            u4_run             = (u4_decoded_value >> 12);\n                            u4_level           = (u4_decoded_value & 0x0FFF);\n\n if (u4_level)\n                                u4_level = (u4_level - ((u4_level & 0x0800) << 1));\n\n                            u4_numCoeffs       += u4_run;\n                            u4_pos             = pu1_scan[u4_numCoeffs++ & 63];\n                            pu1_pos[*pi4_num_coeffs] = u4_pos;\n                            pi2_outAddr[*pi4_num_coeffs] = u4_level;\n (*pi4_num_coeffs)++;\n }\n /*********************************************************************/\n /* MPEG1 Escape Code                                                 */\n /*********************************************************************/\n else\n {\n /*-----------------------------------------------------------\n                            * MPEG-1 Stream\n                            *\n                            * <See D.9.3 of MPEG-2> Run-level escape syntax\n                            * Run-level values that cannot be coded with a VLC are coded\n                            * by the escape code '0000 01' followed by\n                            * either a 14-bit FLC (127 <= level <= 127),\n                            * or a 22-bit FLC (255 <= level <= 255).\n                            * This is described in Annex B,B.5f of MPEG-1.standard\n                            *-----------------------------------------------------------*/\n\n /*-----------------------------------------------------------\n                            * First 6 bits are the value of the Run. Next is First 8 bits\n                            * of Level. These bits decide whether it is 14 bit FLC or\n                            * 22-bit FLC.\n                            *\n                            * If( first 8 bits of Level == '1000000' or '00000000')\n                            *      then its is 22-bit FLC.\n                            * else\n                            *      it is 14-bit FLC.\n                            *-----------------------------------------------------------*/\n                            u4_sym_len         = 6;\n                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)\n                                IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,14)\n                                u4_decoded_value     = u4_bits;\n                            u4_run              = (u4_decoded_value >> 8);\n                            u4_level_first_byte = (u4_decoded_value & 0x0FF);\n if(u4_level_first_byte & 0x7F)\n {\n /*-------------------------------------------------------\n                                * First 8 bits of level are neither 1000000 nor 00000000\n                                * Hence 14-bit FLC (Last 8 bits are used to get level)\n                                *\n                                *  Level = (msb of Level_First_Byte is 1)?\n                                *          Level_First_Byte - 256 : Level_First_Byte\n                                *-------------------------------------------------------*/\n                                u4_level = (u4_level_first_byte -\n ((u4_level_first_byte & 0x80) << 1));\n }\n else\n {\n /*-------------------------------------------------------\n                                * Next 8 bits are either 1000000 or 00000000\n                                * Hence 22-bit FLC (Last 16 bits are used to get level)\n                                *\n                                *  Level = (msb of Level_First_Byte is 1)?\n                                *          Level_Second_Byte - 256 : Level_Second_Byte\n                                *-------------------------------------------------------*/\n                                IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,8)\n                                    u4_level = u4_bits;\n                                u4_level = (u4_level - (u4_level_first_byte << 1));\n }\n                            u4_numCoeffs += u4_run;\n\n                            u4_pos = pu1_scan[u4_numCoeffs++ & 63];\n\n                            pu1_pos[*pi4_num_coeffs] = u4_pos;\n                            pi2_outAddr[*pi4_num_coeffs] = u4_level;\n (*pi4_num_coeffs)++;\n }\n }\n }\n\n                u4_nz_cols |= 1 << (u4_pos & 0x7);\n                u4_nz_rows |= 1 << (u4_pos >> 0x3);\n\n if (u4_numCoeffs > 64)\n {\n return IMPEG2D_MB_TEX_DECODE_ERR;\n }\n\n }\n            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,u4_sym_len)\n }\n else\n {\n while(1)\n {\n\n                UWORD32 lead_zeros;\n                UWORD16 DecodedValue;\n\n\n                 u4_sym_len = 17;\n                 IBITS_NXT(u4_buf, u4_buf_nxt, u4_offset, u4_bits, u4_sym_len)\n \n \n                 DecodedValue = gau2_impeg2d_tab_zero_1_9[u4_bits >> 8];\n                 u4_sym_len = BITS(DecodedValue, 3, 0);\n                u4_level = ((WORD16) DecodedValue) >> 9;\n\n if (0 != u4_level)\n {\n                    u4_run = BITS(DecodedValue, 8,4);\n\n                    u4_numCoeffs       += u4_run;\n\n                    u4_pos                 = pu1_scan[u4_numCoeffs++ & 63];\n                    pu1_pos[*pi4_num_coeffs] = u4_pos;\n\n                    FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)\n                    pi2_outAddr[*pi4_num_coeffs] = u4_level;\n (*pi4_num_coeffs)++;\n }\n else\n {\n if(DecodedValue == END_OF_BLOCK_ZERO)\n {\n                        u4_sym_len = 2;\n\n break;\n }\n else\n {\n                        lead_zeros = CLZ(u4_bits) - 20;/* -15 since we are dealing with WORD32 */\n /*Second table lookup*/\n if (0 != lead_zeros)\n {\n                            u4_bits         = (u4_bits >> (6 - lead_zeros)) & 0x001F;\n\n /* Flush the number of bits */\n                            u4_sym_len         = 11 + lead_zeros;\n\n /* Calculate the address */\n                            u4_bits         = ((lead_zeros - 1) << 5) + u4_bits;\n\n DecodedValue = gau2_impeg2d_tab_zero_10_16[u4_bits];\n\n                            u4_run = BITS(DecodedValue, 8,4);\n                            u4_level = ((WORD16) DecodedValue) >> 9;\n\n                            u4_numCoeffs       += u4_run;\n\n                            u4_pos                 = pu1_scan[u4_numCoeffs++ & 63];\n                            pu1_pos[*pi4_num_coeffs] = u4_pos;\n if (1 == lead_zeros)\n                                u4_sym_len--;\n /* flushing */\n                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)\n                            pi2_outAddr[*pi4_num_coeffs] = u4_level;\n\n (*pi4_num_coeffs)++;\n }\n /*Escape Sequence*/\n else if(u2_mpeg2 == 1)\n {\n                            u4_sym_len         = 6;\n                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)\n                            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,18)\n                            u4_decoded_value    = u4_bits;\n                            u4_run             = (u4_decoded_value >> 12);\n                            u4_level           = (u4_decoded_value & 0x0FFF);\n\n if (u4_level)\n                                u4_level = (u4_level - ((u4_level & 0x0800) << 1));\n\n                            u4_numCoeffs           += u4_run;\n\n                            u4_pos                 = pu1_scan[u4_numCoeffs++ & 63];\n                            pu1_pos[*pi4_num_coeffs] = u4_pos;\n                            pi2_outAddr[*pi4_num_coeffs] = u4_level;\n\n (*pi4_num_coeffs)++;\n }\n /*********************************************************************/\n /* MPEG1 Escape Code                                                 */\n /*********************************************************************/\n else\n {\n /*-----------------------------------------------------------\n                            * MPEG-1 Stream\n                            *\n                            * <See D.9.3 of MPEG-2> Run-level escape syntax\n                            * Run-level values that cannot be coded with a VLC are coded\n                            * by the escape code '0000 01' followed by\n                            * either a 14-bit FLC (127 <= level <= 127),\n                            * or a 22-bit FLC (255 <= level <= 255).\n                            * This is described in Annex B,B.5f of MPEG-1.standard\n                            *-----------------------------------------------------------*/\n\n /*-----------------------------------------------------------\n                            * First 6 bits are the value of the Run. Next is First 8 bits\n                            * of Level. These bits decide whether it is 14 bit FLC or\n                            * 22-bit FLC.\n                            *\n                            * If( first 8 bits of Level == '1000000' or '00000000')\n                            *      then its is 22-bit FLC.\n                            * else\n                            *      it is 14-bit FLC.\n                            *-----------------------------------------------------------*/\n                            u4_sym_len             = 6;\n                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)\n                            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,14)\n                            u4_decoded_value        = u4_bits;\n                            u4_run                 = (u4_decoded_value >> 8);\n                            u4_level_first_byte    = (u4_decoded_value & 0x0FF);\n if(u4_level_first_byte & 0x7F)\n {\n /*-------------------------------------------------------\n                                * First 8 bits of level are neither 1000000 nor 00000000\n                                * Hence 14-bit FLC (Last 8 bits are used to get level)\n                                *\n                                *  Level = (msb of Level_First_Byte is 1)?\n                                *          Level_First_Byte - 256 : Level_First_Byte\n                                *-------------------------------------------------------*/\n                                u4_level = (u4_level_first_byte -\n ((u4_level_first_byte & 0x80) << 1));\n }\n else\n {\n /*-------------------------------------------------------\n                                * Next 8 bits are either 1000000 or 00000000\n                                * Hence 22-bit FLC (Last 16 bits are used to get level)\n                                *\n                                *  Level = (msb of Level_First_Byte is 1)?\n                                *          Level_Second_Byte - 256 : Level_Second_Byte\n                                *-------------------------------------------------------*/\n                                IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,8)\n                                u4_level = u4_bits;\n                                u4_level = (u4_level - (u4_level_first_byte << 1));\n }\n                            u4_numCoeffs           += u4_run;\n\n                            u4_pos                 = pu1_scan[u4_numCoeffs++ & 63];\n                            pu1_pos[*pi4_num_coeffs] = u4_pos;\n                            pi2_outAddr[*pi4_num_coeffs] = u4_level;\n\n (*pi4_num_coeffs)++;\n }\n }\n }\n\n                u4_nz_cols |= 1 << (u4_pos & 0x7);\n                u4_nz_rows |= 1 << (u4_pos >> 0x3);\n if (u4_numCoeffs > 64)\n {\n return IMPEG2D_MB_TEX_DECODE_ERR;\n }\n\n }\n\n            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,u4_sym_len)\n\n }\n\n        PUT_TEMP_STREAM_DATA(u4_buf, u4_buf_nxt, u4_offset, pu4_buf_aligned, ps_stream)\n\n        ps_dec->u4_non_zero_cols  = u4_nz_cols;\n        ps_dec->u4_non_zero_rows  = u4_nz_rows;\n\n return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143895,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "IMPEG2D_ERROR_CODES_T impeg2d_vld_decode(\n dec_state_t *ps_dec,\n    WORD16      *pi2_outAddr, /*!< Address where decoded symbols will be stored */\n const UWORD8 *pu1_scan, /*!< Scan table to be used */\n    UWORD8      *pu1_pos, /*!< Scan table to be used */\n    UWORD16     u2_intra_flag, /*!< Intra Macroblock or not */\n    UWORD16     u2_chroma_flag, /*!< Chroma Block or not */\n    UWORD16     u2_d_picture, /*!< D Picture or not */\n    UWORD16     u2_intra_vlc_format, /*!< Intra VLC format */\n    UWORD16     u2_mpeg2, /*!< MPEG-2 or not */\n    WORD32      *pi4_num_coeffs /*!< Returns the number of coeffs in block */\n )\n{\n\n    UWORD32 u4_sym_len;\n\n    UWORD32 u4_decoded_value;\n    UWORD32 u4_level_first_byte;\n    WORD32  u4_level;\n    UWORD32 u4_run, u4_numCoeffs;\n    UWORD32 u4_buf;\n    UWORD32 u4_buf_nxt;\n    UWORD32 u4_offset;\n    UWORD32 *pu4_buf_aligned;\n    UWORD32 u4_bits;\n stream_t *ps_stream = &ps_dec->s_bit_stream;\n    WORD32  u4_pos;\n    UWORD32 u4_nz_cols;\n    UWORD32 u4_nz_rows;\n\n *pi4_num_coeffs = 0;\n\n    ps_dec->u4_non_zero_cols = 0;\n    ps_dec->u4_non_zero_rows = 0;\n    u4_nz_cols = ps_dec->u4_non_zero_cols;\n    u4_nz_rows = ps_dec->u4_non_zero_rows;\n\n    GET_TEMP_STREAM_DATA(u4_buf,u4_buf_nxt,u4_offset,pu4_buf_aligned,ps_stream)\n /**************************************************************************/\n /* Decode the DC coefficient in case of Intra block                       */\n /**************************************************************************/\n if(u2_intra_flag)\n {\n        WORD32 dc_size;\n        WORD32 dc_diff;\n        WORD32 maxLen;\n        WORD32 idx;\n\n\n        maxLen = MPEG2_DCT_DC_SIZE_LEN;\n        idx = 0;\n if(u2_chroma_flag != 0)\n {\n            maxLen += 1;\n            idx++;\n }\n\n\n {\n            WORD16  end = 0;\n            UWORD32 maxLen_tmp = maxLen;\n            UWORD16 m_iBit;\n\n\n /* Get the maximum number of bits needed to decode a symbol */\n            IBITS_NXT(u4_buf,u4_buf_nxt,u4_offset,u4_bits,maxLen)\n do\n {\n                maxLen_tmp--;\n /* Read one bit at a time from the variable to decode the huffman code */\n                m_iBit = (UWORD8)((u4_bits >> maxLen_tmp) & 0x1);\n\n /* Get the next node pointer or the symbol from the tree */\n                end = gai2_impeg2d_dct_dc_size[idx][end][m_iBit];\n }while(end > 0);\n            dc_size = end + MPEG2_DCT_DC_SIZE_OFFSET;\n\n /* Flush the appropriate number of bits from the stream */\n            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,(maxLen - maxLen_tmp),pu4_buf_aligned)\n\n }\n\n\n\n if (dc_size != 0)\n {\n            UWORD32 u4_bits;\n\n            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned, dc_size)\n            dc_diff = u4_bits;\n\n if ((dc_diff & (1 << (dc_size - 1))) == 0) //v Probably the prediction algo?\n                dc_diff -= (1 << dc_size) - 1;\n }\n else\n {\n            dc_diff = 0;\n }\n\n\n        pi2_outAddr[*pi4_num_coeffs] = dc_diff;\n /* This indicates the position of the coefficient. Since this is the DC\n         * coefficient, we put the position as 0.\n         */\n        pu1_pos[*pi4_num_coeffs] = pu1_scan[0];\n (*pi4_num_coeffs)++;\n\n if (0 != dc_diff)\n {\n            u4_nz_cols |= 0x01;\n            u4_nz_rows |= 0x01;\n }\n\n        u4_numCoeffs = 1;\n }\n /**************************************************************************/\n /* Decoding of first AC coefficient in case of non Intra block            */\n /**************************************************************************/\n else\n {\n /* First symbol can be 1s */\n        UWORD32 u4_bits;\n\n        IBITS_NXT(u4_buf,u4_buf_nxt,u4_offset,u4_bits,1)\n\n if(u4_bits == 1)\n {\n\n            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,1, pu4_buf_aligned)\n            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned, 1)\n if(u4_bits == 1)\n {\n                pi2_outAddr[*pi4_num_coeffs] = -1;\n }\n else\n {\n                pi2_outAddr[*pi4_num_coeffs] = 1;\n }\n\n /* This indicates the position of the coefficient. Since this is the DC\n             * coefficient, we put the position as 0.\n             */\n            pu1_pos[*pi4_num_coeffs] = pu1_scan[0];\n (*pi4_num_coeffs)++;\n            u4_numCoeffs = 1;\n\n            u4_nz_cols |= 0x01;\n            u4_nz_rows |= 0x01;\n }\n else\n {\n            u4_numCoeffs = 0;\n }\n }\n if (1 == u2_d_picture)\n {\n        PUT_TEMP_STREAM_DATA(u4_buf, u4_buf_nxt, u4_offset, pu4_buf_aligned, ps_stream)\n        ps_dec->u4_non_zero_cols  = u4_nz_cols;\n        ps_dec->u4_non_zero_rows  = u4_nz_rows;\n return ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE);\n }\n\n\n\n if (1 == u2_intra_vlc_format && u2_intra_flag)\n {\n\n while(1)\n {\n\n                UWORD32 lead_zeros;\n                WORD16 DecodedValue;\n\n\n                 u4_sym_len = 17;\n                 IBITS_NXT(u4_buf,u4_buf_nxt,u4_offset,u4_bits,u4_sym_len)\n \n                /* There cannot be more than 11 leading zeros in the decoded\n                 * symbol. The symbol is only 17 bits long, so we subtract 15.\n                 */\n                lead_zeros = CLZ(u4_bits) - 15;\n                if (lead_zeros > 11)\n                {\n                    return IMPEG2D_MB_DATA_DECODE_ERR;\n                }\n\n                 DecodedValue = gau2_impeg2d_tab_one_1_9[u4_bits >> 8];\n                 u4_sym_len = (DecodedValue & 0xf);\n                 u4_level = DecodedValue >> 9;\n /* One table lookup */\n if(0 != u4_level)\n {\n                    u4_run = ((DecodedValue >> 4) & 0x1f);\n                    u4_numCoeffs       += u4_run;\n                    u4_pos             = pu1_scan[u4_numCoeffs++ & 63];\n                    pu1_pos[*pi4_num_coeffs] = u4_pos;\n\n                    FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)\n                    pi2_outAddr[*pi4_num_coeffs] = u4_level;\n\n (*pi4_num_coeffs)++;\n }\n else\n {\n if (DecodedValue == END_OF_BLOCK_ONE)\n {\n                        u4_sym_len = 4;\n\n break;\n }\n else\n {\n /*Second table lookup*/\n                        lead_zeros = CLZ(u4_bits) - 20;/* -16 since we are dealing with WORD32 */\n if (0 != lead_zeros)\n {\n\n                            u4_bits         = (u4_bits >> (6 - lead_zeros)) & 0x001F;\n\n /* Flush the number of bits */\n if (1 == lead_zeros)\n {\n                                u4_sym_len         = ((u4_bits & 0x18) >> 3) == 2 ? 11:10;\n }\n else\n {\n                                u4_sym_len         = 11 + lead_zeros;\n }\n /* flushing */\n                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)\n\n /* Calculate the address */\n                            u4_bits         = ((lead_zeros - 1) << 5) + u4_bits;\n\n DecodedValue = gau2_impeg2d_tab_one_10_16[u4_bits];\n\n                            u4_run = BITS(DecodedValue, 8,4);\n                            u4_level = ((WORD16) DecodedValue) >> 9;\n\n                            u4_numCoeffs       += u4_run;\n                            u4_pos             = pu1_scan[u4_numCoeffs++ & 63];\n                            pu1_pos[*pi4_num_coeffs] = u4_pos;\n                            pi2_outAddr[*pi4_num_coeffs] = u4_level;\n (*pi4_num_coeffs)++;\n }\n /*********************************************************************/\n /* MPEG2 Escape Code                                                 */\n /*********************************************************************/\n else if(u2_mpeg2 == 1)\n {\n                            u4_sym_len         = 6;\n                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)\n                                IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,18)\n                                u4_decoded_value    = u4_bits;\n                            u4_run             = (u4_decoded_value >> 12);\n                            u4_level           = (u4_decoded_value & 0x0FFF);\n\n if (u4_level)\n                                u4_level = (u4_level - ((u4_level & 0x0800) << 1));\n\n                            u4_numCoeffs       += u4_run;\n                            u4_pos             = pu1_scan[u4_numCoeffs++ & 63];\n                            pu1_pos[*pi4_num_coeffs] = u4_pos;\n                            pi2_outAddr[*pi4_num_coeffs] = u4_level;\n (*pi4_num_coeffs)++;\n }\n /*********************************************************************/\n /* MPEG1 Escape Code                                                 */\n /*********************************************************************/\n else\n {\n /*-----------------------------------------------------------\n                            * MPEG-1 Stream\n                            *\n                            * <See D.9.3 of MPEG-2> Run-level escape syntax\n                            * Run-level values that cannot be coded with a VLC are coded\n                            * by the escape code '0000 01' followed by\n                            * either a 14-bit FLC (127 <= level <= 127),\n                            * or a 22-bit FLC (255 <= level <= 255).\n                            * This is described in Annex B,B.5f of MPEG-1.standard\n                            *-----------------------------------------------------------*/\n\n /*-----------------------------------------------------------\n                            * First 6 bits are the value of the Run. Next is First 8 bits\n                            * of Level. These bits decide whether it is 14 bit FLC or\n                            * 22-bit FLC.\n                            *\n                            * If( first 8 bits of Level == '1000000' or '00000000')\n                            *      then its is 22-bit FLC.\n                            * else\n                            *      it is 14-bit FLC.\n                            *-----------------------------------------------------------*/\n                            u4_sym_len         = 6;\n                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)\n                                IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,14)\n                                u4_decoded_value     = u4_bits;\n                            u4_run              = (u4_decoded_value >> 8);\n                            u4_level_first_byte = (u4_decoded_value & 0x0FF);\n if(u4_level_first_byte & 0x7F)\n {\n /*-------------------------------------------------------\n                                * First 8 bits of level are neither 1000000 nor 00000000\n                                * Hence 14-bit FLC (Last 8 bits are used to get level)\n                                *\n                                *  Level = (msb of Level_First_Byte is 1)?\n                                *          Level_First_Byte - 256 : Level_First_Byte\n                                *-------------------------------------------------------*/\n                                u4_level = (u4_level_first_byte -\n ((u4_level_first_byte & 0x80) << 1));\n }\n else\n {\n /*-------------------------------------------------------\n                                * Next 8 bits are either 1000000 or 00000000\n                                * Hence 22-bit FLC (Last 16 bits are used to get level)\n                                *\n                                *  Level = (msb of Level_First_Byte is 1)?\n                                *          Level_Second_Byte - 256 : Level_Second_Byte\n                                *-------------------------------------------------------*/\n                                IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,8)\n                                    u4_level = u4_bits;\n                                u4_level = (u4_level - (u4_level_first_byte << 1));\n }\n                            u4_numCoeffs += u4_run;\n\n                            u4_pos = pu1_scan[u4_numCoeffs++ & 63];\n\n                            pu1_pos[*pi4_num_coeffs] = u4_pos;\n                            pi2_outAddr[*pi4_num_coeffs] = u4_level;\n (*pi4_num_coeffs)++;\n }\n }\n }\n\n                u4_nz_cols |= 1 << (u4_pos & 0x7);\n                u4_nz_rows |= 1 << (u4_pos >> 0x3);\n\n if (u4_numCoeffs > 64)\n {\n return IMPEG2D_MB_TEX_DECODE_ERR;\n }\n\n }\n            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,u4_sym_len)\n }\n else\n {\n while(1)\n {\n\n                UWORD32 lead_zeros;\n                UWORD16 DecodedValue;\n\n\n                 u4_sym_len = 17;\n                 IBITS_NXT(u4_buf, u4_buf_nxt, u4_offset, u4_bits, u4_sym_len)\n \n                /* There cannot be more than 11 leading zeros in the decoded\n                 * symbol. The symbol is only 17 bits long, so we subtract 15.\n                 */\n                lead_zeros = CLZ(u4_bits) - 15;\n                if (lead_zeros > 11)\n                {\n                    return IMPEG2D_MB_DATA_DECODE_ERR;\n                }\n \n                 DecodedValue = gau2_impeg2d_tab_zero_1_9[u4_bits >> 8];\n                 u4_sym_len = BITS(DecodedValue, 3, 0);\n                u4_level = ((WORD16) DecodedValue) >> 9;\n\n if (0 != u4_level)\n {\n                    u4_run = BITS(DecodedValue, 8,4);\n\n                    u4_numCoeffs       += u4_run;\n\n                    u4_pos                 = pu1_scan[u4_numCoeffs++ & 63];\n                    pu1_pos[*pi4_num_coeffs] = u4_pos;\n\n                    FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)\n                    pi2_outAddr[*pi4_num_coeffs] = u4_level;\n (*pi4_num_coeffs)++;\n }\n else\n {\n if(DecodedValue == END_OF_BLOCK_ZERO)\n {\n                        u4_sym_len = 2;\n\n break;\n }\n else\n {\n                        lead_zeros = CLZ(u4_bits) - 20;/* -15 since we are dealing with WORD32 */\n /*Second table lookup*/\n if (0 != lead_zeros)\n {\n                            u4_bits         = (u4_bits >> (6 - lead_zeros)) & 0x001F;\n\n /* Flush the number of bits */\n                            u4_sym_len         = 11 + lead_zeros;\n\n /* Calculate the address */\n                            u4_bits         = ((lead_zeros - 1) << 5) + u4_bits;\n\n DecodedValue = gau2_impeg2d_tab_zero_10_16[u4_bits];\n\n                            u4_run = BITS(DecodedValue, 8,4);\n                            u4_level = ((WORD16) DecodedValue) >> 9;\n\n                            u4_numCoeffs       += u4_run;\n\n                            u4_pos                 = pu1_scan[u4_numCoeffs++ & 63];\n                            pu1_pos[*pi4_num_coeffs] = u4_pos;\n if (1 == lead_zeros)\n                                u4_sym_len--;\n /* flushing */\n                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)\n                            pi2_outAddr[*pi4_num_coeffs] = u4_level;\n\n (*pi4_num_coeffs)++;\n }\n /*Escape Sequence*/\n else if(u2_mpeg2 == 1)\n {\n                            u4_sym_len         = 6;\n                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)\n                            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,18)\n                            u4_decoded_value    = u4_bits;\n                            u4_run             = (u4_decoded_value >> 12);\n                            u4_level           = (u4_decoded_value & 0x0FFF);\n\n if (u4_level)\n                                u4_level = (u4_level - ((u4_level & 0x0800) << 1));\n\n                            u4_numCoeffs           += u4_run;\n\n                            u4_pos                 = pu1_scan[u4_numCoeffs++ & 63];\n                            pu1_pos[*pi4_num_coeffs] = u4_pos;\n                            pi2_outAddr[*pi4_num_coeffs] = u4_level;\n\n (*pi4_num_coeffs)++;\n }\n /*********************************************************************/\n /* MPEG1 Escape Code                                                 */\n /*********************************************************************/\n else\n {\n /*-----------------------------------------------------------\n                            * MPEG-1 Stream\n                            *\n                            * <See D.9.3 of MPEG-2> Run-level escape syntax\n                            * Run-level values that cannot be coded with a VLC are coded\n                            * by the escape code '0000 01' followed by\n                            * either a 14-bit FLC (127 <= level <= 127),\n                            * or a 22-bit FLC (255 <= level <= 255).\n                            * This is described in Annex B,B.5f of MPEG-1.standard\n                            *-----------------------------------------------------------*/\n\n /*-----------------------------------------------------------\n                            * First 6 bits are the value of the Run. Next is First 8 bits\n                            * of Level. These bits decide whether it is 14 bit FLC or\n                            * 22-bit FLC.\n                            *\n                            * If( first 8 bits of Level == '1000000' or '00000000')\n                            *      then its is 22-bit FLC.\n                            * else\n                            *      it is 14-bit FLC.\n                            *-----------------------------------------------------------*/\n                            u4_sym_len             = 6;\n                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)\n                            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,14)\n                            u4_decoded_value        = u4_bits;\n                            u4_run                 = (u4_decoded_value >> 8);\n                            u4_level_first_byte    = (u4_decoded_value & 0x0FF);\n if(u4_level_first_byte & 0x7F)\n {\n /*-------------------------------------------------------\n                                * First 8 bits of level are neither 1000000 nor 00000000\n                                * Hence 14-bit FLC (Last 8 bits are used to get level)\n                                *\n                                *  Level = (msb of Level_First_Byte is 1)?\n                                *          Level_First_Byte - 256 : Level_First_Byte\n                                *-------------------------------------------------------*/\n                                u4_level = (u4_level_first_byte -\n ((u4_level_first_byte & 0x80) << 1));\n }\n else\n {\n /*-------------------------------------------------------\n                                * Next 8 bits are either 1000000 or 00000000\n                                * Hence 22-bit FLC (Last 16 bits are used to get level)\n                                *\n                                *  Level = (msb of Level_First_Byte is 1)?\n                                *          Level_Second_Byte - 256 : Level_Second_Byte\n                                *-------------------------------------------------------*/\n                                IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,8)\n                                u4_level = u4_bits;\n                                u4_level = (u4_level - (u4_level_first_byte << 1));\n }\n                            u4_numCoeffs           += u4_run;\n\n                            u4_pos                 = pu1_scan[u4_numCoeffs++ & 63];\n                            pu1_pos[*pi4_num_coeffs] = u4_pos;\n                            pi2_outAddr[*pi4_num_coeffs] = u4_level;\n\n (*pi4_num_coeffs)++;\n }\n }\n }\n\n                u4_nz_cols |= 1 << (u4_pos & 0x7);\n                u4_nz_rows |= 1 << (u4_pos >> 0x3);\n if (u4_numCoeffs > 64)\n {\n return IMPEG2D_MB_TEX_DECODE_ERR;\n }\n\n }\n\n            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,u4_sym_len)\n\n }\n\n        PUT_TEMP_STREAM_DATA(u4_buf, u4_buf_nxt, u4_offset, pu4_buf_aligned, ps_stream)\n\n        ps_dec->u4_non_zero_cols  = u4_nz_cols;\n        ps_dec->u4_non_zero_rows  = u4_nz_rows;\n\n return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143896,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "IMPEG2D_ERROR_CODES_T impeg2d_dec_seq_hdr(dec_state_t *ps_dec)\n{\n stream_t *ps_stream;\n    ps_stream = &ps_dec->s_bit_stream;\n    UWORD16 u2_height;\n    UWORD16 u2_width;\n\n if (impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != SEQUENCE_HEADER_CODE)\n {\n        impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n return IMPEG2D_FRM_HDR_START_CODE_NOT_FOUND;\n\n }\n    impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n\n    u2_width    = impeg2d_bit_stream_get(ps_stream,12);\n    u2_height   = impeg2d_bit_stream_get(ps_stream,12);\n\n if ((u2_width != ps_dec->u2_horizontal_size)\n || (u2_height != ps_dec->u2_vertical_size))\n {\n if (0 == ps_dec->u2_header_done)\n {\n /* This is the first time we are reading the resolution */\n            ps_dec->u2_horizontal_size = u2_width;\n            ps_dec->u2_vertical_size = u2_height;\n if (0 == ps_dec->u4_frm_buf_stride)\n {\n                ps_dec->u4_frm_buf_stride  = (UWORD32) ALIGN16(u2_width);\n }\n }\n else\n {\n if((u2_width > ps_dec->u2_create_max_width)\n || (u2_height > ps_dec->u2_create_max_height))\n {\n                IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS;\n\n                ps_dec->u2_reinit_max_height   = u2_height;\n                ps_dec->u2_reinit_max_width    = u2_width;\n\n return e_error;\n }\n else\n {\n /* The resolution has changed */\n return (IMPEG2D_ERROR_CODES_T)IVD_RES_CHANGED;\n }\n }\n }\n\n if((ps_dec->u2_horizontal_size > ps_dec->u2_create_max_width)\n || (ps_dec->u2_vertical_size > ps_dec->u2_create_max_height))\n {\n        IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS;\n return SET_IVD_FATAL_ERROR(e_error);\n }\n\n\n /*------------------------------------------------------------------------*/\n /* Flush the following as they are not being used                         */\n /* aspect_ratio_info (4 bits)                                             */\n /*------------------------------------------------------------------------*/\n    ps_dec->u2_aspect_ratio_info = impeg2d_bit_stream_get(ps_stream,4);\n\n /*------------------------------------------------------------------------*/\n\n     /* Frame rate code(4 bits)                                                */\n     /*------------------------------------------------------------------------*/\n     ps_dec->u2_frame_rate_code = impeg2d_bit_stream_get(ps_stream,4);\n     /*------------------------------------------------------------------------*/\n     /* Flush the following as they are not being used                         */\n     /* bit_rate_value (18 bits)                                               */\n /*------------------------------------------------------------------------*/\n    impeg2d_bit_stream_flush(ps_stream,18);\n    GET_MARKER_BIT(ps_dec,ps_stream);\n /*------------------------------------------------------------------------*/\n /* Flush the following as they are not being used                         */\n /* vbv_buffer_size_value(10 bits), constrained_parameter_flag (1 bit)     */\n /*------------------------------------------------------------------------*/\n    impeg2d_bit_stream_flush(ps_stream,11);\n\n /*------------------------------------------------------------------------*/\n /* Quantization matrix for the intra blocks                               */\n /*------------------------------------------------------------------------*/\n if(impeg2d_bit_stream_get_bit(ps_stream) == 1)\n {\n        UWORD16 i;\n for(i = 0; i < NUM_PELS_IN_BLOCK; i++)\n {\n            ps_dec->au1_intra_quant_matrix[gau1_impeg2_inv_scan_zig_zag[i]] = (UWORD8)impeg2d_bit_stream_get(ps_stream,8);\n }\n\n }\n else\n {\n        memcpy(ps_dec->au1_intra_quant_matrix,gau1_impeg2_intra_quant_matrix_default,\n                NUM_PELS_IN_BLOCK);\n }\n\n /*------------------------------------------------------------------------*/\n /* Quantization matrix for the inter blocks                               */\n /*------------------------------------------------------------------------*/\n if(impeg2d_bit_stream_get_bit(ps_stream) == 1)\n {\n        UWORD16 i;\n for(i = 0; i < NUM_PELS_IN_BLOCK; i++)\n {\n            ps_dec->au1_inter_quant_matrix[gau1_impeg2_inv_scan_zig_zag[i]] = (UWORD8)impeg2d_bit_stream_get(ps_stream,8);\n }\n }\n else\n {\n        memcpy(ps_dec->au1_inter_quant_matrix,gau1_impeg2_inter_quant_matrix_default,\n            NUM_PELS_IN_BLOCK);\n }\n    impeg2d_next_start_code(ps_dec);\n\n return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143897,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "IMPEG2D_ERROR_CODES_T impeg2d_dec_seq_hdr(dec_state_t *ps_dec)\n{\n stream_t *ps_stream;\n    ps_stream = &ps_dec->s_bit_stream;\n    UWORD16 u2_height;\n    UWORD16 u2_width;\n\n if (impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != SEQUENCE_HEADER_CODE)\n {\n        impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n return IMPEG2D_FRM_HDR_START_CODE_NOT_FOUND;\n\n }\n    impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n\n    u2_width    = impeg2d_bit_stream_get(ps_stream,12);\n    u2_height   = impeg2d_bit_stream_get(ps_stream,12);\n\n if ((u2_width != ps_dec->u2_horizontal_size)\n || (u2_height != ps_dec->u2_vertical_size))\n {\n if (0 == ps_dec->u2_header_done)\n {\n /* This is the first time we are reading the resolution */\n            ps_dec->u2_horizontal_size = u2_width;\n            ps_dec->u2_vertical_size = u2_height;\n if (0 == ps_dec->u4_frm_buf_stride)\n {\n                ps_dec->u4_frm_buf_stride  = (UWORD32) ALIGN16(u2_width);\n }\n }\n else\n {\n if((u2_width > ps_dec->u2_create_max_width)\n || (u2_height > ps_dec->u2_create_max_height))\n {\n                IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS;\n\n                ps_dec->u2_reinit_max_height   = u2_height;\n                ps_dec->u2_reinit_max_width    = u2_width;\n\n return e_error;\n }\n else\n {\n /* The resolution has changed */\n return (IMPEG2D_ERROR_CODES_T)IVD_RES_CHANGED;\n }\n }\n }\n\n if((ps_dec->u2_horizontal_size > ps_dec->u2_create_max_width)\n || (ps_dec->u2_vertical_size > ps_dec->u2_create_max_height))\n {\n        IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS;\n return SET_IVD_FATAL_ERROR(e_error);\n }\n\n\n /*------------------------------------------------------------------------*/\n /* Flush the following as they are not being used                         */\n /* aspect_ratio_info (4 bits)                                             */\n /*------------------------------------------------------------------------*/\n    ps_dec->u2_aspect_ratio_info = impeg2d_bit_stream_get(ps_stream,4);\n\n /*------------------------------------------------------------------------*/\n\n     /* Frame rate code(4 bits)                                                */\n     /*------------------------------------------------------------------------*/\n     ps_dec->u2_frame_rate_code = impeg2d_bit_stream_get(ps_stream,4);\n    if (ps_dec->u2_frame_rate_code > MPEG2_MAX_FRAME_RATE_CODE)\n    {\n        return IMPEG2D_FRM_HDR_DECODE_ERR;\n    }\n     /*------------------------------------------------------------------------*/\n     /* Flush the following as they are not being used                         */\n     /* bit_rate_value (18 bits)                                               */\n /*------------------------------------------------------------------------*/\n    impeg2d_bit_stream_flush(ps_stream,18);\n    GET_MARKER_BIT(ps_dec,ps_stream);\n /*------------------------------------------------------------------------*/\n /* Flush the following as they are not being used                         */\n /* vbv_buffer_size_value(10 bits), constrained_parameter_flag (1 bit)     */\n /*------------------------------------------------------------------------*/\n    impeg2d_bit_stream_flush(ps_stream,11);\n\n /*------------------------------------------------------------------------*/\n /* Quantization matrix for the intra blocks                               */\n /*------------------------------------------------------------------------*/\n if(impeg2d_bit_stream_get_bit(ps_stream) == 1)\n {\n        UWORD16 i;\n for(i = 0; i < NUM_PELS_IN_BLOCK; i++)\n {\n            ps_dec->au1_intra_quant_matrix[gau1_impeg2_inv_scan_zig_zag[i]] = (UWORD8)impeg2d_bit_stream_get(ps_stream,8);\n }\n\n }\n else\n {\n        memcpy(ps_dec->au1_intra_quant_matrix,gau1_impeg2_intra_quant_matrix_default,\n                NUM_PELS_IN_BLOCK);\n }\n\n /*------------------------------------------------------------------------*/\n /* Quantization matrix for the inter blocks                               */\n /*------------------------------------------------------------------------*/\n if(impeg2d_bit_stream_get_bit(ps_stream) == 1)\n {\n        UWORD16 i;\n for(i = 0; i < NUM_PELS_IN_BLOCK; i++)\n {\n            ps_dec->au1_inter_quant_matrix[gau1_impeg2_inv_scan_zig_zag[i]] = (UWORD8)impeg2d_bit_stream_get(ps_stream,8);\n }\n }\n else\n {\n        memcpy(ps_dec->au1_inter_quant_matrix,gau1_impeg2_inter_quant_matrix_default,\n            NUM_PELS_IN_BLOCK);\n }\n    impeg2d_next_start_code(ps_dec);\n\n return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143898,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "status_t BnHDCP::onTransact(\n uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {\n switch (code) {\n case HDCP_SET_OBSERVER:\n {\n            CHECK_INTERFACE(IHDCP, data, reply);\n\n            sp<IHDCPObserver> observer =\n                interface_cast<IHDCPObserver>(data.readStrongBinder());\n\n            reply->writeInt32(setObserver(observer));\n return OK;\n }\n\n case HDCP_INIT_ASYNC:\n {\n            CHECK_INTERFACE(IHDCP, data, reply);\n\n const char *host = data.readCString();\n unsigned port = data.readInt32();\n\n            reply->writeInt32(initAsync(host, port));\n return OK;\n }\n\n case HDCP_SHUTDOWN_ASYNC:\n {\n            CHECK_INTERFACE(IHDCP, data, reply);\n\n            reply->writeInt32(shutdownAsync());\n return OK;\n }\n\n case HDCP_GET_CAPS:\n {\n            CHECK_INTERFACE(IHDCP, data, reply);\n\n            reply->writeInt32(getCaps());\n return OK;\n }\n\n\n         case HDCP_ENCRYPT:\n         {\n             size_t size = data.readInt32();\n            size_t bufSize = 2 * size;\n            if (bufSize > size) {\n                inData = malloc(bufSize);\n             }\n             if (inData == NULL) {\n                 reply->writeInt32(ERROR_OUT_OF_RANGE);\n                 return OK;\n }\n\n \n             void *outData = (uint8_t *)inData + size;\n \n            data.read(inData, size);\n \n             uint32_t streamCTR = data.readInt32();\n             uint64_t inputCTR;\n            status_t err = encrypt(inData, size, streamCTR, &inputCTR, outData);\n \n             reply->writeInt32(err);\n \n if (err == OK) {\n                reply->writeInt64(inputCTR);\n                reply->write(outData, size);\n }\n\n            free(inData);\n            inData = outData = NULL;\n\n return OK;\n }\n\n case HDCP_ENCRYPT_NATIVE:\n {\n            CHECK_INTERFACE(IHDCP, data, reply);\n\n            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();\n            data.read(*graphicBuffer);\n size_t offset = data.readInt32();\n size_t size = data.readInt32();\n uint32_t streamCTR = data.readInt32();\n void *outData = malloc(size);\n uint64_t inputCTR;\n\n status_t err = encryptNative(graphicBuffer, offset, size,\n                                         streamCTR, &inputCTR, outData);\n\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeInt64(inputCTR);\n                reply->write(outData, size);\n }\n\n            free(outData);\n            outData = NULL;\n\n return OK;\n }\n\n case HDCP_DECRYPT:\n {\n size_t size = data.readInt32();\n size_t bufSize = 2 * size;\n\n void *inData = NULL;\n if (bufSize > size) {\n                inData = malloc(bufSize);\n }\n\n if (inData == NULL) {\n                reply->writeInt32(ERROR_OUT_OF_RANGE);\n return OK;\n }\n\n void *outData = (uint8_t *)inData + size;\n\n            data.read(inData, size);\n\n uint32_t streamCTR = data.readInt32();\n uint64_t inputCTR = data.readInt64();\n status_t err = decrypt(inData, size, streamCTR, inputCTR, outData);\n\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->write(outData, size);\n }\n\n            free(inData);\n            inData = outData = NULL;\n\n return OK;\n }\n\n default:\n return BBinder::onTransact(code, data, reply, flags);\n }\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143899,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "status_t BnHDCP::onTransact(\n uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {\n switch (code) {\n case HDCP_SET_OBSERVER:\n {\n            CHECK_INTERFACE(IHDCP, data, reply);\n\n            sp<IHDCPObserver> observer =\n                interface_cast<IHDCPObserver>(data.readStrongBinder());\n\n            reply->writeInt32(setObserver(observer));\n return OK;\n }\n\n case HDCP_INIT_ASYNC:\n {\n            CHECK_INTERFACE(IHDCP, data, reply);\n\n const char *host = data.readCString();\n unsigned port = data.readInt32();\n\n            reply->writeInt32(initAsync(host, port));\n return OK;\n }\n\n case HDCP_SHUTDOWN_ASYNC:\n {\n            CHECK_INTERFACE(IHDCP, data, reply);\n\n            reply->writeInt32(shutdownAsync());\n return OK;\n }\n\n case HDCP_GET_CAPS:\n {\n            CHECK_INTERFACE(IHDCP, data, reply);\n\n            reply->writeInt32(getCaps());\n return OK;\n }\n\n\n         case HDCP_ENCRYPT:\n         {\n             size_t size = data.readInt32();\n            // watch out for overflow\n            if (size <= SIZE_MAX / 2) {\n                inData = malloc(2 * size);\n             }\n             if (inData == NULL) {\n                 reply->writeInt32(ERROR_OUT_OF_RANGE);\n                 return OK;\n }\n\n \n             void *outData = (uint8_t *)inData + size;\n \n            status_t err = data.read(inData, size);\n            if (err != OK) {\n                free(inData);\n                reply->writeInt32(err);\n                return OK;\n            }\n \n             uint32_t streamCTR = data.readInt32();\n             uint64_t inputCTR;\n            err = encrypt(inData, size, streamCTR, &inputCTR, outData);\n \n             reply->writeInt32(err);\n \n if (err == OK) {\n                reply->writeInt64(inputCTR);\n                reply->write(outData, size);\n }\n\n            free(inData);\n            inData = outData = NULL;\n\n return OK;\n }\n\n case HDCP_ENCRYPT_NATIVE:\n {\n            CHECK_INTERFACE(IHDCP, data, reply);\n\n            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();\n            data.read(*graphicBuffer);\n size_t offset = data.readInt32();\n size_t size = data.readInt32();\n uint32_t streamCTR = data.readInt32();\n void *outData = malloc(size);\n uint64_t inputCTR;\n\n status_t err = encryptNative(graphicBuffer, offset, size,\n                                         streamCTR, &inputCTR, outData);\n\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeInt64(inputCTR);\n                reply->write(outData, size);\n }\n\n            free(outData);\n            outData = NULL;\n\n return OK;\n }\n\n case HDCP_DECRYPT:\n {\n size_t size = data.readInt32();\n size_t bufSize = 2 * size;\n\n void *inData = NULL;\n if (bufSize > size) {\n                inData = malloc(bufSize);\n }\n\n if (inData == NULL) {\n                reply->writeInt32(ERROR_OUT_OF_RANGE);\n return OK;\n }\n\n void *outData = (uint8_t *)inData + size;\n\n            data.read(inData, size);\n\n uint32_t streamCTR = data.readInt32();\n uint64_t inputCTR = data.readInt64();\n status_t err = decrypt(inData, size, streamCTR, inputCTR, outData);\n\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->write(outData, size);\n }\n\n            free(inData);\n            inData = outData = NULL;\n\n return OK;\n }\n\n default:\n return BBinder::onTransact(code, data, reply, flags);\n }\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143900,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "int Visualizer_command(effect_handle_t self, uint32_t cmdCode, uint32_t cmdSize,\n void *pCmdData, uint32_t *replySize, void *pReplyData) {\n\n VisualizerContext * pContext = (VisualizerContext *)self;\n int retsize;\n\n if (pContext == NULL || pContext->mState == VISUALIZER_STATE_UNINITIALIZED) {\n return -EINVAL;\n }\n\n\n switch (cmdCode) {\n case EFFECT_CMD_INIT:\n if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {\n return -EINVAL;\n }\n *(int *) pReplyData = Visualizer_init(pContext);\n break;\n case EFFECT_CMD_SET_CONFIG:\n if (pCmdData == NULL || cmdSize != sizeof(effect_config_t)\n || pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {\n return -EINVAL;\n }\n *(int *) pReplyData = Visualizer_setConfig(pContext,\n (effect_config_t *) pCmdData);\n break;\n case EFFECT_CMD_GET_CONFIG:\n if (pReplyData == NULL || replySize == NULL ||\n *replySize != sizeof(effect_config_t)) {\n return -EINVAL;\n }\n Visualizer_getConfig(pContext, (effect_config_t *)pReplyData);\n break;\n case EFFECT_CMD_RESET:\n Visualizer_reset(pContext);\n break;\n case EFFECT_CMD_ENABLE:\n if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {\n return -EINVAL;\n }\n if (pContext->mState != VISUALIZER_STATE_INITIALIZED) {\n return -ENOSYS;\n }\n        pContext->mState = VISUALIZER_STATE_ACTIVE;\n        ALOGV(\"EFFECT_CMD_ENABLE() OK\");\n *(int *)pReplyData = 0;\n break;\n case EFFECT_CMD_DISABLE:\n if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {\n return -EINVAL;\n }\n if (pContext->mState != VISUALIZER_STATE_ACTIVE) {\n return -ENOSYS;\n }\n        pContext->mState = VISUALIZER_STATE_INITIALIZED;\n        ALOGV(\"EFFECT_CMD_DISABLE() OK\");\n *(int *)pReplyData = 0;\n break;\n case EFFECT_CMD_GET_PARAM: {\n if (pCmdData == NULL ||\n            cmdSize != (int)(sizeof(effect_param_t) + sizeof(uint32_t)) ||\n            pReplyData == NULL || replySize == NULL ||\n *replySize < (int)(sizeof(effect_param_t) + sizeof(uint32_t) + sizeof(uint32_t))) {\n return -EINVAL;\n }\n        memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + sizeof(uint32_t));\n effect_param_t *p = (effect_param_t *)pReplyData;\n        p->status = 0;\n *replySize = sizeof(effect_param_t) + sizeof(uint32_t);\n if (p->psize != sizeof(uint32_t)) {\n            p->status = -EINVAL;\n break;\n }\n switch (*(uint32_t *)p->data) {\n case VISUALIZER_PARAM_CAPTURE_SIZE:\n            ALOGV(\"get mCaptureSize = %\" PRIu32, pContext->mCaptureSize);\n *((uint32_t *)p->data + 1) = pContext->mCaptureSize;\n            p->vsize = sizeof(uint32_t);\n *replySize += sizeof(uint32_t);\n break;\n case VISUALIZER_PARAM_SCALING_MODE:\n            ALOGV(\"get mScalingMode = %\" PRIu32, pContext->mScalingMode);\n *((uint32_t *)p->data + 1) = pContext->mScalingMode;\n            p->vsize = sizeof(uint32_t);\n *replySize += sizeof(uint32_t);\n break;\n case VISUALIZER_PARAM_MEASUREMENT_MODE:\n            ALOGV(\"get mMeasurementMode = %\" PRIu32, pContext->mMeasurementMode);\n *((uint32_t *)p->data + 1) = pContext->mMeasurementMode;\n            p->vsize = sizeof(uint32_t);\n *replySize += sizeof(uint32_t);\n break;\n default:\n            p->status = -EINVAL;\n }\n } break;\n case EFFECT_CMD_SET_PARAM: {\n if (pCmdData == NULL ||\n            cmdSize != (int)(sizeof(effect_param_t) + sizeof(uint32_t) + sizeof(uint32_t)) ||\n            pReplyData == NULL || replySize == NULL || *replySize != sizeof(int32_t)) {\n return -EINVAL;\n }\n *(int32_t *)pReplyData = 0;\n effect_param_t *p = (effect_param_t *)pCmdData;\n if (p->psize != sizeof(uint32_t) || p->vsize != sizeof(uint32_t)) {\n *(int32_t *)pReplyData = -EINVAL;\n\n             break;\n         }\n         switch (*(uint32_t *)p->data) {\n        case VISUALIZER_PARAM_CAPTURE_SIZE:\n            pContext->mCaptureSize = *((uint32_t *)p->data + 1);\n            ALOGV(\"set mCaptureSize = %\" PRIu32, pContext->mCaptureSize);\n            break;\n         case VISUALIZER_PARAM_SCALING_MODE:\n             pContext->mScalingMode = *((uint32_t *)p->data + 1);\n             ALOGV(\"set mScalingMode = %\" PRIu32, pContext->mScalingMode);\n             break;\n        case VISUALIZER_PARAM_LATENCY:\n            pContext->mLatency = *((uint32_t *)p->data + 1);\n            ALOGV(\"set mLatency = %\" PRIu32, pContext->mLatency);\n            break;\n         case VISUALIZER_PARAM_MEASUREMENT_MODE:\n             pContext->mMeasurementMode = *((uint32_t *)p->data + 1);\n             ALOGV(\"set mMeasurementMode = %\" PRIu32, pContext->mMeasurementMode);\n break;\n default:\n *(int32_t *)pReplyData = -EINVAL;\n }\n } break;\n case EFFECT_CMD_SET_DEVICE:\n case EFFECT_CMD_SET_VOLUME:\n case EFFECT_CMD_SET_AUDIO_MODE:\n break;\n\n\n case VISUALIZER_CMD_CAPTURE: {\n uint32_t captureSize = pContext->mCaptureSize;\n if (pReplyData == NULL || replySize == NULL || *replySize != captureSize) {\n            ALOGV(\"VISUALIZER_CMD_CAPTURE() error *replySize %\" PRIu32 \" captureSize %\" PRIu32,\n *replySize, captureSize);\n return -EINVAL;\n }\n if (pContext->mState == VISUALIZER_STATE_ACTIVE) {\n const uint32_t deltaMs = Visualizer_getDeltaTimeMsFromUpdatedTime(pContext);\n\n if ((pContext->mLastCaptureIdx == pContext->mCaptureIdx) &&\n (pContext->mBufferUpdateTime.tv_sec != 0) &&\n (deltaMs > MAX_STALL_TIME_MS)) {\n                    ALOGV(\"capture going to idle\");\n                    pContext->mBufferUpdateTime.tv_sec = 0;\n                    memset(pReplyData, 0x80, captureSize);\n } else {\n int32_t latencyMs = pContext->mLatency;\n                latencyMs -= deltaMs;\n\n                 if (latencyMs < 0) {\n                     latencyMs = 0;\n                 }\n                const uint32_t deltaSmpl =\n                    pContext->mConfig.inputCfg.samplingRate * latencyMs / 1000;\n                int32_t capturePoint = pContext->mCaptureIdx - captureSize - deltaSmpl;\n \n                 if (capturePoint < 0) {\n                     uint32_t size = -capturePoint;\n                     if (size > captureSize) {\n                        size = captureSize;\n }\n                    memcpy(pReplyData,\n                           pContext->mCaptureBuf + CAPTURE_BUF_SIZE + capturePoint,\n                           size);\n                    pReplyData = (char *)pReplyData + size;\n                    captureSize -= size;\n                    capturePoint = 0;\n }\n                memcpy(pReplyData,\n                       pContext->mCaptureBuf + capturePoint,\n                       captureSize);\n }\n\n            pContext->mLastCaptureIdx = pContext->mCaptureIdx;\n } else {\n            memset(pReplyData, 0x80, captureSize);\n }\n\n } break;\n\n case VISUALIZER_CMD_MEASURE: {\n if (pReplyData == NULL || replySize == NULL ||\n *replySize < (sizeof(int32_t) * MEASUREMENT_COUNT)) {\n if (replySize == NULL) {\n                ALOGV(\"VISUALIZER_CMD_MEASURE() error replySize NULL\");\n } else {\n                ALOGV(\"VISUALIZER_CMD_MEASURE() error *replySize %\" PRIu32\n \" < (sizeof(int32_t) * MEASUREMENT_COUNT) %\" PRIu32,\n *replySize,\n uint32_t(sizeof(int32_t)) * MEASUREMENT_COUNT);\n }\n            android_errorWriteLog(0x534e4554, \"30229821\");\n return -EINVAL;\n }\n uint16_t peakU16 = 0;\n float sumRmsSquared = 0.0f;\n uint8_t nbValidMeasurements = 0;\n const int32_t delayMs = Visualizer_getDeltaTimeMsFromUpdatedTime(pContext);\n if (delayMs > DISCARD_MEASUREMENTS_TIME_MS) {\n            ALOGV(\"Discarding measurements, last measurement is %\" PRId32 \"ms old\", delayMs);\n for (uint32_t i=0 ; i<pContext->mMeasurementWindowSizeInBuffers ; i++) {\n                pContext->mPastMeasurements[i].mIsValid = false;\n                pContext->mPastMeasurements[i].mPeakU16 = 0;\n                pContext->mPastMeasurements[i].mRmsSquared = 0;\n }\n            pContext->mMeasurementBufferIdx = 0;\n } else {\n for (uint32_t i=0 ; i < pContext->mMeasurementWindowSizeInBuffers ; i++) {\n if (pContext->mPastMeasurements[i].mIsValid) {\n if (pContext->mPastMeasurements[i].mPeakU16 > peakU16) {\n                        peakU16 = pContext->mPastMeasurements[i].mPeakU16;\n }\n                    sumRmsSquared += pContext->mPastMeasurements[i].mRmsSquared;\n                    nbValidMeasurements++;\n }\n }\n }\n float rms = nbValidMeasurements == 0 ? 0.0f : sqrtf(sumRmsSquared / nbValidMeasurements);\n int32_t* pIntReplyData = (int32_t*)pReplyData;\n if (rms < 0.000016f) {\n            pIntReplyData[MEASUREMENT_IDX_RMS] = -9600; //-96dB\n } else {\n            pIntReplyData[MEASUREMENT_IDX_RMS] = (int32_t) (2000 * log10(rms / 32767.0f));\n }\n if (peakU16 == 0) {\n            pIntReplyData[MEASUREMENT_IDX_PEAK] = -9600; //-96dB\n } else {\n            pIntReplyData[MEASUREMENT_IDX_PEAK] = (int32_t) (2000 * log10(peakU16 / 32767.0f));\n }\n        ALOGV(\"VISUALIZER_CMD_MEASURE peak=%\" PRIu16 \" (%\" PRId32 \"mB), rms=%.1f (%\" PRId32 \"mB)\",\n                peakU16, pIntReplyData[MEASUREMENT_IDX_PEAK],\n                rms, pIntReplyData[MEASUREMENT_IDX_RMS]);\n }\n break;\n\n default:\n        ALOGW(\"Visualizer_command invalid command %\" PRIu32, cmdCode);\n return -EINVAL;\n }\n\n return 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143907,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "int Visualizer_command(effect_handle_t self, uint32_t cmdCode, uint32_t cmdSize,\n void *pCmdData, uint32_t *replySize, void *pReplyData) {\n\n VisualizerContext * pContext = (VisualizerContext *)self;\n int retsize;\n\n if (pContext == NULL || pContext->mState == VISUALIZER_STATE_UNINITIALIZED) {\n return -EINVAL;\n }\n\n\n switch (cmdCode) {\n case EFFECT_CMD_INIT:\n if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {\n return -EINVAL;\n }\n *(int *) pReplyData = Visualizer_init(pContext);\n break;\n case EFFECT_CMD_SET_CONFIG:\n if (pCmdData == NULL || cmdSize != sizeof(effect_config_t)\n || pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {\n return -EINVAL;\n }\n *(int *) pReplyData = Visualizer_setConfig(pContext,\n (effect_config_t *) pCmdData);\n break;\n case EFFECT_CMD_GET_CONFIG:\n if (pReplyData == NULL || replySize == NULL ||\n *replySize != sizeof(effect_config_t)) {\n return -EINVAL;\n }\n Visualizer_getConfig(pContext, (effect_config_t *)pReplyData);\n break;\n case EFFECT_CMD_RESET:\n Visualizer_reset(pContext);\n break;\n case EFFECT_CMD_ENABLE:\n if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {\n return -EINVAL;\n }\n if (pContext->mState != VISUALIZER_STATE_INITIALIZED) {\n return -ENOSYS;\n }\n        pContext->mState = VISUALIZER_STATE_ACTIVE;\n        ALOGV(\"EFFECT_CMD_ENABLE() OK\");\n *(int *)pReplyData = 0;\n break;\n case EFFECT_CMD_DISABLE:\n if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {\n return -EINVAL;\n }\n if (pContext->mState != VISUALIZER_STATE_ACTIVE) {\n return -ENOSYS;\n }\n        pContext->mState = VISUALIZER_STATE_INITIALIZED;\n        ALOGV(\"EFFECT_CMD_DISABLE() OK\");\n *(int *)pReplyData = 0;\n break;\n case EFFECT_CMD_GET_PARAM: {\n if (pCmdData == NULL ||\n            cmdSize != (int)(sizeof(effect_param_t) + sizeof(uint32_t)) ||\n            pReplyData == NULL || replySize == NULL ||\n *replySize < (int)(sizeof(effect_param_t) + sizeof(uint32_t) + sizeof(uint32_t))) {\n return -EINVAL;\n }\n        memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + sizeof(uint32_t));\n effect_param_t *p = (effect_param_t *)pReplyData;\n        p->status = 0;\n *replySize = sizeof(effect_param_t) + sizeof(uint32_t);\n if (p->psize != sizeof(uint32_t)) {\n            p->status = -EINVAL;\n break;\n }\n switch (*(uint32_t *)p->data) {\n case VISUALIZER_PARAM_CAPTURE_SIZE:\n            ALOGV(\"get mCaptureSize = %\" PRIu32, pContext->mCaptureSize);\n *((uint32_t *)p->data + 1) = pContext->mCaptureSize;\n            p->vsize = sizeof(uint32_t);\n *replySize += sizeof(uint32_t);\n break;\n case VISUALIZER_PARAM_SCALING_MODE:\n            ALOGV(\"get mScalingMode = %\" PRIu32, pContext->mScalingMode);\n *((uint32_t *)p->data + 1) = pContext->mScalingMode;\n            p->vsize = sizeof(uint32_t);\n *replySize += sizeof(uint32_t);\n break;\n case VISUALIZER_PARAM_MEASUREMENT_MODE:\n            ALOGV(\"get mMeasurementMode = %\" PRIu32, pContext->mMeasurementMode);\n *((uint32_t *)p->data + 1) = pContext->mMeasurementMode;\n            p->vsize = sizeof(uint32_t);\n *replySize += sizeof(uint32_t);\n break;\n default:\n            p->status = -EINVAL;\n }\n } break;\n case EFFECT_CMD_SET_PARAM: {\n if (pCmdData == NULL ||\n            cmdSize != (int)(sizeof(effect_param_t) + sizeof(uint32_t) + sizeof(uint32_t)) ||\n            pReplyData == NULL || replySize == NULL || *replySize != sizeof(int32_t)) {\n return -EINVAL;\n }\n *(int32_t *)pReplyData = 0;\n effect_param_t *p = (effect_param_t *)pCmdData;\n if (p->psize != sizeof(uint32_t) || p->vsize != sizeof(uint32_t)) {\n *(int32_t *)pReplyData = -EINVAL;\n\n             break;\n         }\n         switch (*(uint32_t *)p->data) {\n        case VISUALIZER_PARAM_CAPTURE_SIZE: {\n            const uint32_t captureSize = *((uint32_t *)p->data + 1);\n            if (captureSize > VISUALIZER_CAPTURE_SIZE_MAX) {\n                android_errorWriteLog(0x534e4554, \"31781965\");\n                *(int32_t *)pReplyData = -EINVAL;\n                ALOGW(\"set mCaptureSize = %u > %u\", captureSize, VISUALIZER_CAPTURE_SIZE_MAX);\n            } else {\n                pContext->mCaptureSize = captureSize;\n                ALOGV(\"set mCaptureSize = %u\", captureSize);\n            }\n            } break;\n         case VISUALIZER_PARAM_SCALING_MODE:\n             pContext->mScalingMode = *((uint32_t *)p->data + 1);\n             ALOGV(\"set mScalingMode = %\" PRIu32, pContext->mScalingMode);\n             break;\n        case VISUALIZER_PARAM_LATENCY: {\n            uint32_t latency = *((uint32_t *)p->data + 1);\n            if (latency > MAX_LATENCY_MS) {\n                latency = MAX_LATENCY_MS; // clamp latency b/31781965\n            }\n            pContext->mLatency = latency;\n            ALOGV(\"set mLatency = %u\", latency);\n            } break;\n         case VISUALIZER_PARAM_MEASUREMENT_MODE:\n             pContext->mMeasurementMode = *((uint32_t *)p->data + 1);\n             ALOGV(\"set mMeasurementMode = %\" PRIu32, pContext->mMeasurementMode);\n break;\n default:\n *(int32_t *)pReplyData = -EINVAL;\n }\n } break;\n case EFFECT_CMD_SET_DEVICE:\n case EFFECT_CMD_SET_VOLUME:\n case EFFECT_CMD_SET_AUDIO_MODE:\n break;\n\n\n case VISUALIZER_CMD_CAPTURE: {\n uint32_t captureSize = pContext->mCaptureSize;\n if (pReplyData == NULL || replySize == NULL || *replySize != captureSize) {\n            ALOGV(\"VISUALIZER_CMD_CAPTURE() error *replySize %\" PRIu32 \" captureSize %\" PRIu32,\n *replySize, captureSize);\n return -EINVAL;\n }\n if (pContext->mState == VISUALIZER_STATE_ACTIVE) {\n const uint32_t deltaMs = Visualizer_getDeltaTimeMsFromUpdatedTime(pContext);\n\n if ((pContext->mLastCaptureIdx == pContext->mCaptureIdx) &&\n (pContext->mBufferUpdateTime.tv_sec != 0) &&\n (deltaMs > MAX_STALL_TIME_MS)) {\n                    ALOGV(\"capture going to idle\");\n                    pContext->mBufferUpdateTime.tv_sec = 0;\n                    memset(pReplyData, 0x80, captureSize);\n } else {\n int32_t latencyMs = pContext->mLatency;\n                latencyMs -= deltaMs;\n\n                 if (latencyMs < 0) {\n                     latencyMs = 0;\n                 }\n                uint32_t deltaSmpl = captureSize\n                        + pContext->mConfig.inputCfg.samplingRate * latencyMs / 1000;\n \n                // large sample rate, latency, or capture size, could cause overflow.\n                // do not offset more than the size of buffer.\n                if (deltaSmpl > CAPTURE_BUF_SIZE) {\n                    android_errorWriteLog(0x534e4554, \"31781965\");\n                    deltaSmpl = CAPTURE_BUF_SIZE;\n                }\n\n                int32_t capturePoint = pContext->mCaptureIdx - deltaSmpl;\n                // a negative capturePoint means we wrap the buffer.\n                 if (capturePoint < 0) {\n                     uint32_t size = -capturePoint;\n                     if (size > captureSize) {\n                        size = captureSize;\n }\n                    memcpy(pReplyData,\n                           pContext->mCaptureBuf + CAPTURE_BUF_SIZE + capturePoint,\n                           size);\n                    pReplyData = (char *)pReplyData + size;\n                    captureSize -= size;\n                    capturePoint = 0;\n }\n                memcpy(pReplyData,\n                       pContext->mCaptureBuf + capturePoint,\n                       captureSize);\n }\n\n            pContext->mLastCaptureIdx = pContext->mCaptureIdx;\n } else {\n            memset(pReplyData, 0x80, captureSize);\n }\n\n } break;\n\n case VISUALIZER_CMD_MEASURE: {\n if (pReplyData == NULL || replySize == NULL ||\n *replySize < (sizeof(int32_t) * MEASUREMENT_COUNT)) {\n if (replySize == NULL) {\n                ALOGV(\"VISUALIZER_CMD_MEASURE() error replySize NULL\");\n } else {\n                ALOGV(\"VISUALIZER_CMD_MEASURE() error *replySize %\" PRIu32\n \" < (sizeof(int32_t) * MEASUREMENT_COUNT) %\" PRIu32,\n *replySize,\n uint32_t(sizeof(int32_t)) * MEASUREMENT_COUNT);\n }\n            android_errorWriteLog(0x534e4554, \"30229821\");\n return -EINVAL;\n }\n uint16_t peakU16 = 0;\n float sumRmsSquared = 0.0f;\n uint8_t nbValidMeasurements = 0;\n const int32_t delayMs = Visualizer_getDeltaTimeMsFromUpdatedTime(pContext);\n if (delayMs > DISCARD_MEASUREMENTS_TIME_MS) {\n            ALOGV(\"Discarding measurements, last measurement is %\" PRId32 \"ms old\", delayMs);\n for (uint32_t i=0 ; i<pContext->mMeasurementWindowSizeInBuffers ; i++) {\n                pContext->mPastMeasurements[i].mIsValid = false;\n                pContext->mPastMeasurements[i].mPeakU16 = 0;\n                pContext->mPastMeasurements[i].mRmsSquared = 0;\n }\n            pContext->mMeasurementBufferIdx = 0;\n } else {\n for (uint32_t i=0 ; i < pContext->mMeasurementWindowSizeInBuffers ; i++) {\n if (pContext->mPastMeasurements[i].mIsValid) {\n if (pContext->mPastMeasurements[i].mPeakU16 > peakU16) {\n                        peakU16 = pContext->mPastMeasurements[i].mPeakU16;\n }\n                    sumRmsSquared += pContext->mPastMeasurements[i].mRmsSquared;\n                    nbValidMeasurements++;\n }\n }\n }\n float rms = nbValidMeasurements == 0 ? 0.0f : sqrtf(sumRmsSquared / nbValidMeasurements);\n int32_t* pIntReplyData = (int32_t*)pReplyData;\n if (rms < 0.000016f) {\n            pIntReplyData[MEASUREMENT_IDX_RMS] = -9600; //-96dB\n } else {\n            pIntReplyData[MEASUREMENT_IDX_RMS] = (int32_t) (2000 * log10(rms / 32767.0f));\n }\n if (peakU16 == 0) {\n            pIntReplyData[MEASUREMENT_IDX_PEAK] = -9600; //-96dB\n } else {\n            pIntReplyData[MEASUREMENT_IDX_PEAK] = (int32_t) (2000 * log10(peakU16 / 32767.0f));\n }\n        ALOGV(\"VISUALIZER_CMD_MEASURE peak=%\" PRIu16 \" (%\" PRId32 \"mB), rms=%.1f (%\" PRId32 \"mB)\",\n                peakU16, pIntReplyData[MEASUREMENT_IDX_PEAK],\n                rms, pIntReplyData[MEASUREMENT_IDX_RMS]);\n }\n break;\n\n default:\n        ALOGW(\"Visualizer_command invalid command %\" PRIu32, cmdCode);\n return -EINVAL;\n }\n\n return 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143908,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": " void BnCrypto::readVector(const Parcel &data, Vector<uint8_t> &vector) const {\n     uint32_t size = data.readInt32();\n    vector.insertAt((size_t)0, size);\n    data.read(vector.editArray(), size);\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143917,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": " void BnCrypto::readVector(const Parcel &data, Vector<uint8_t> &vector) const {\n     uint32_t size = data.readInt32();\n    if (vector.insertAt((size_t)0, size) < 0) {\n        vector.clear();\n    }\n    if (data.read(vector.editArray(), size) != NO_ERROR) {\n        vector.clear();\n        android_errorWriteWithInfoLog(0x534e4554, \"62872384\", -1, NULL, 0);\n    }\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143918,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "bool ID3::removeUnsynchronizationV2_4(bool iTunesHack) {\n size_t oldSize = mSize;\n\n size_t offset = 0;\n while (mSize >= 10 && offset <= mSize - 10) {\n if (!memcmp(&mData[offset], \"\\0\\0\\0\\0\", 4)) {\n break;\n }\n\n size_t dataSize;\n if (iTunesHack) {\n            dataSize = U32_AT(&mData[offset + 4]);\n } else if (!ParseSyncsafeInteger(&mData[offset + 4], &dataSize)) {\n return false;\n }\n\n if (dataSize > mSize - 10 - offset) {\n return false;\n }\n\n uint16_t flags = U16_AT(&mData[offset + 8]);\n uint16_t prevFlags = flags;\n\n if (flags & 1) {\n\n if (mSize < 14 || mSize - 14 < offset || dataSize < 4) {\n return false;\n }\n            memmove(&mData[offset + 10], &mData[offset + 14], mSize - offset - 14);\n            mSize -= 4;\n            dataSize -= 4;\n\n            flags &= ~1;\n }\n\n if ((flags & 2) && (dataSize >= 2)) {\n\n size_t readOffset = offset + 11;\n size_t writeOffset = offset + 11;\n for (size_t i = 0; i + 1 < dataSize; ++i) {\n if (mData[readOffset - 1] == 0xff\n && mData[readOffset] == 0x00) {\n ++readOffset;\n\n                     --mSize;\n                     --dataSize;\n                 }\n                mData[writeOffset++] = mData[readOffset++];\n             }\n             if (readOffset <= oldSize) {\n                memmove(&mData[writeOffset], &mData[readOffset], oldSize - readOffset);\n } else {\n                ALOGE(\"b/34618607 (%zu %zu %zu %zu)\", readOffset, writeOffset, oldSize, mSize);\n                android_errorWriteLog(0x534e4554, \"34618607\");\n }\n\n }\n        flags &= ~2;\n if (flags != prevFlags || iTunesHack) {\n WriteSyncsafeInteger(&mData[offset + 4], dataSize);\n            mData[offset + 8] = flags >> 8;\n            mData[offset + 9] = flags & 0xff;\n }\n\n        offset += 10 + dataSize;\n }\n\n    memset(&mData[mSize], 0, oldSize - mSize);\n\n return true;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143927,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "bool ID3::removeUnsynchronizationV2_4(bool iTunesHack) {\n size_t oldSize = mSize;\n\n size_t offset = 0;\n while (mSize >= 10 && offset <= mSize - 10) {\n if (!memcmp(&mData[offset], \"\\0\\0\\0\\0\", 4)) {\n break;\n }\n\n size_t dataSize;\n if (iTunesHack) {\n            dataSize = U32_AT(&mData[offset + 4]);\n } else if (!ParseSyncsafeInteger(&mData[offset + 4], &dataSize)) {\n return false;\n }\n\n if (dataSize > mSize - 10 - offset) {\n return false;\n }\n\n uint16_t flags = U16_AT(&mData[offset + 8]);\n uint16_t prevFlags = flags;\n\n if (flags & 1) {\n\n if (mSize < 14 || mSize - 14 < offset || dataSize < 4) {\n return false;\n }\n            memmove(&mData[offset + 10], &mData[offset + 14], mSize - offset - 14);\n            mSize -= 4;\n            dataSize -= 4;\n\n            flags &= ~1;\n }\n\n if ((flags & 2) && (dataSize >= 2)) {\n\n size_t readOffset = offset + 11;\n size_t writeOffset = offset + 11;\n for (size_t i = 0; i + 1 < dataSize; ++i) {\n if (mData[readOffset - 1] == 0xff\n && mData[readOffset] == 0x00) {\n ++readOffset;\n\n                     --mSize;\n                     --dataSize;\n                 }\n                if (i + 1 < dataSize) {\n                    // Only move data if there's actually something to move.\n                    // This handles the special case of the data being only [0xff, 0x00]\n                    // which should be converted to just 0xff if unsynchronization is on.\n                    mData[writeOffset++] = mData[readOffset++];\n                }\n             }\n             if (readOffset <= oldSize) {\n                memmove(&mData[writeOffset], &mData[readOffset], oldSize - readOffset);\n } else {\n                ALOGE(\"b/34618607 (%zu %zu %zu %zu)\", readOffset, writeOffset, oldSize, mSize);\n                android_errorWriteLog(0x534e4554, \"34618607\");\n }\n\n }\n        flags &= ~2;\n if (flags != prevFlags || iTunesHack) {\n WriteSyncsafeInteger(&mData[offset + 4], dataSize);\n            mData[offset + 8] = flags >> 8;\n            mData[offset + 9] = flags & 0xff;\n }\n\n        offset += 10 + dataSize;\n }\n\n    memset(&mData[mSize], 0, oldSize - mSize);\n\n return true;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143928,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "IHEVCD_ERROR_T ihevcd_parse_slice_header(codec_t *ps_codec,\n nal_header_t *ps_nal)\n{\n    IHEVCD_ERROR_T ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;\n    WORD32 value;\n    WORD32 i, j;\n    WORD32 sps_id;\n\n pps_t *ps_pps;\n sps_t *ps_sps;\n slice_header_t *ps_slice_hdr;\n    WORD32 disable_deblocking_filter_flag;\n bitstrm_t *ps_bitstrm = &ps_codec->s_parse.s_bitstrm;\n    WORD32 idr_pic_flag;\n    WORD32 pps_id;\n    WORD32 first_slice_in_pic_flag;\n    WORD32 no_output_of_prior_pics_flag = 0;\n\n     WORD8 i1_nal_unit_type = ps_nal->i1_nal_unit_type;\n     WORD32 num_poc_total_curr = 0;\n     WORD32 slice_address;\n \n     if(ps_codec->i4_slice_error == 1)\n         return ret;\n\n    idr_pic_flag = (NAL_IDR_W_LP == i1_nal_unit_type) ||\n (NAL_IDR_N_LP == i1_nal_unit_type);\n\n\n    BITS_PARSE(\"first_slice_in_pic_flag\", first_slice_in_pic_flag, ps_bitstrm, 1);\n if((NAL_BLA_W_LP <= i1_nal_unit_type) &&\n (NAL_RSV_RAP_VCL23          >= i1_nal_unit_type))\n {\n        BITS_PARSE(\"no_output_of_prior_pics_flag\", no_output_of_prior_pics_flag, ps_bitstrm, 1);\n }\n    UEV_PARSE(\"pic_parameter_set_id\", pps_id, ps_bitstrm);\n    pps_id = CLIP3(pps_id, 0, MAX_PPS_CNT - 2);\n\n /* Get the current PPS structure */\n    ps_pps = ps_codec->s_parse.ps_pps_base + pps_id;\n if(0 == ps_pps->i1_pps_valid)\n {\n pps_t *ps_pps_ref = ps_codec->ps_pps_base;\n while(0 == ps_pps_ref->i1_pps_valid)\n {\n            ps_pps_ref++;\n if((ps_pps_ref - ps_codec->ps_pps_base >= MAX_PPS_CNT - 1))\n return IHEVCD_INVALID_HEADER;\n }\n\n        ihevcd_copy_pps(ps_codec, pps_id, ps_pps_ref->i1_pps_id);\n }\n\n /* Get SPS id for the current PPS */\n    sps_id = ps_pps->i1_sps_id;\n\n /* Get the current SPS structure */\n    ps_sps = ps_codec->s_parse.ps_sps_base + sps_id;\n\n /* When the current slice is the first in a pic,\n     *  check whether the previous frame is complete\n     *  If the previous frame is incomplete -\n     *  treat the remaining CTBs as skip */\n if((0 != ps_codec->u4_pic_cnt || ps_codec->i4_pic_present) &&\n                    first_slice_in_pic_flag)\n {\n if(ps_codec->i4_pic_present)\n {\n slice_header_t *ps_slice_hdr_next;\n            ps_codec->i4_slice_error = 1;\n            ps_codec->s_parse.i4_cur_slice_idx--;\n if(ps_codec->s_parse.i4_cur_slice_idx < 0)\n                ps_codec->s_parse.i4_cur_slice_idx = 0;\n\n            ps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + ((ps_codec->s_parse.i4_cur_slice_idx + 1) & (MAX_SLICE_HDR_CNT - 1));\n            ps_slice_hdr_next->i2_ctb_x = 0;\n            ps_slice_hdr_next->i2_ctb_y = ps_codec->s_parse.ps_sps->i2_pic_ht_in_ctb;\n return ret;\n }\n else\n {\n            ps_codec->i4_slice_error = 0;\n }\n }\n\n if(first_slice_in_pic_flag)\n {\n        ps_codec->s_parse.i4_cur_slice_idx = 0;\n }\n else\n {\n /* If the current slice is not the first slice in the pic,\n         * but the first one to be parsed, set the current slice indx to 1\n         * Treat the first slice to be missing and copy the current slice header\n         * to the first one */\n if(0 == ps_codec->i4_pic_present)\n            ps_codec->s_parse.i4_cur_slice_idx = 1;\n }\n\n    ps_slice_hdr = ps_codec->s_parse.ps_slice_hdr_base + (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1));\n\n\n if((ps_pps->i1_dependent_slice_enabled_flag) &&\n (!first_slice_in_pic_flag))\n {\n        BITS_PARSE(\"dependent_slice_flag\", value, ps_bitstrm, 1);\n\n /* If dependendent slice, copy slice header from previous slice */\n if(value && (ps_codec->s_parse.i4_cur_slice_idx > 0))\n {\n            ihevcd_copy_slice_hdr(ps_codec,\n (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1)),\n ((ps_codec->s_parse.i4_cur_slice_idx - 1) & (MAX_SLICE_HDR_CNT - 1)));\n }\n        ps_slice_hdr->i1_dependent_slice_flag = value;\n }\n else\n {\n        ps_slice_hdr->i1_dependent_slice_flag = 0;\n }\n    ps_slice_hdr->i1_nal_unit_type = i1_nal_unit_type;\n    ps_slice_hdr->i1_pps_id = pps_id;\n    ps_slice_hdr->i1_first_slice_in_pic_flag = first_slice_in_pic_flag;\n\n    ps_slice_hdr->i1_no_output_of_prior_pics_flag = 1;\n if((NAL_BLA_W_LP <= i1_nal_unit_type) &&\n (NAL_RSV_RAP_VCL23          >= i1_nal_unit_type))\n {\n        ps_slice_hdr->i1_no_output_of_prior_pics_flag = no_output_of_prior_pics_flag;\n }\n    ps_slice_hdr->i1_pps_id = pps_id;\n\n if(!ps_slice_hdr->i1_first_slice_in_pic_flag)\n {\n        WORD32 num_bits;\n\n /* Use CLZ to compute Ceil( Log2( PicSizeInCtbsY ) ) */\n        num_bits = 32 - CLZ(ps_sps->i4_pic_size_in_ctb - 1);\n        BITS_PARSE(\"slice_address\", value, ps_bitstrm, num_bits);\n\n        slice_address = value;\n /* If slice address is greater than the number of CTBs in a picture,\n         * ignore the slice */\n if(value >= ps_sps->i4_pic_size_in_ctb)\n return IHEVCD_IGNORE_SLICE;\n }\n else\n {\n        slice_address = 0;\n }\n\n if(!ps_slice_hdr->i1_dependent_slice_flag)\n {\n        ps_slice_hdr->i1_pic_output_flag = 1;\n        ps_slice_hdr->i4_pic_order_cnt_lsb = 0;\n        ps_slice_hdr->i1_num_long_term_sps = 0;\n        ps_slice_hdr->i1_num_long_term_pics = 0;\n\n for(i = 0; i < ps_pps->i1_num_extra_slice_header_bits; i++)\n {\n            BITS_PARSE(\"slice_reserved_undetermined_flag[ i ]\", value, ps_bitstrm, 1);\n }\n        UEV_PARSE(\"slice_type\", value, ps_bitstrm);\n        ps_slice_hdr->i1_slice_type = value;\n\n /* If the picture is IRAP, slice type must be equal to ISLICE */\n if((ps_slice_hdr->i1_nal_unit_type >= NAL_BLA_W_LP) &&\n (ps_slice_hdr->i1_nal_unit_type <= NAL_RSV_RAP_VCL23))\n            ps_slice_hdr->i1_slice_type = ISLICE;\n\n if((ps_slice_hdr->i1_slice_type < 0) ||\n (ps_slice_hdr->i1_slice_type > 2))\n return IHEVCD_IGNORE_SLICE;\n\n if(ps_pps->i1_output_flag_present_flag)\n {\n            BITS_PARSE(\"pic_output_flag\", value, ps_bitstrm, 1);\n            ps_slice_hdr->i1_pic_output_flag = value;\n }\n        ps_slice_hdr->i1_colour_plane_id = 0;\n if(1 == ps_sps->i1_separate_colour_plane_flag)\n {\n            BITS_PARSE(\"colour_plane_id\", value, ps_bitstrm, 2);\n            ps_slice_hdr->i1_colour_plane_id = value;\n }\n        ps_slice_hdr->i1_slice_temporal_mvp_enable_flag = 0;\n\n if(!idr_pic_flag)\n {\n\n            WORD32 st_rps_idx;\n            WORD32 num_neg_pics;\n            WORD32 num_pos_pics;\n            WORD8 *pi1_used;\n\n            BITS_PARSE(\"pic_order_cnt_lsb\", value, ps_bitstrm, ps_sps->i1_log2_max_pic_order_cnt_lsb);\n            ps_slice_hdr->i4_pic_order_cnt_lsb = value;\n\n            BITS_PARSE(\"short_term_ref_pic_set_sps_flag\", value, ps_bitstrm, 1);\n            ps_slice_hdr->i1_short_term_ref_pic_set_sps_flag = value;\n\n if(1 == ps_slice_hdr->i1_short_term_ref_pic_set_sps_flag)\n {\n                WORD32 numbits;\n\n                ps_slice_hdr->i1_short_term_ref_pic_set_idx = 0;\n if(ps_sps->i1_num_short_term_ref_pic_sets > 1)\n {\n                    numbits = 32 - CLZ(ps_sps->i1_num_short_term_ref_pic_sets - 1);\n                    BITS_PARSE(\"short_term_ref_pic_set_idx\", value, ps_bitstrm, numbits);\n                    ps_slice_hdr->i1_short_term_ref_pic_set_idx = value;\n }\n\n                st_rps_idx = ps_slice_hdr->i1_short_term_ref_pic_set_idx;\n                num_neg_pics = ps_sps->as_stref_picset[st_rps_idx].i1_num_neg_pics;\n                num_pos_pics = ps_sps->as_stref_picset[st_rps_idx].i1_num_pos_pics;\n                pi1_used = ps_sps->as_stref_picset[st_rps_idx].ai1_used;\n }\n else\n {\n                ihevcd_short_term_ref_pic_set(ps_bitstrm,\n &ps_sps->as_stref_picset[0],\n                                              ps_sps->i1_num_short_term_ref_pic_sets,\n                                              ps_sps->i1_num_short_term_ref_pic_sets,\n &ps_slice_hdr->s_stref_picset);\n\n                st_rps_idx = ps_sps->i1_num_short_term_ref_pic_sets;\n                num_neg_pics = ps_slice_hdr->s_stref_picset.i1_num_neg_pics;\n                num_pos_pics = ps_slice_hdr->s_stref_picset.i1_num_pos_pics;\n                pi1_used = ps_slice_hdr->s_stref_picset.ai1_used;\n }\n\n if(ps_sps->i1_long_term_ref_pics_present_flag)\n {\n if(ps_sps->i1_num_long_term_ref_pics_sps > 0)\n {\n                    UEV_PARSE(\"num_long_term_sps\", value, ps_bitstrm);\n                    ps_slice_hdr->i1_num_long_term_sps = value;\n\n                    ps_slice_hdr->i1_num_long_term_sps = CLIP3(ps_slice_hdr->i1_num_long_term_sps,\n 0, MAX_DPB_SIZE - num_neg_pics - num_pos_pics);\n }\n                UEV_PARSE(\"num_long_term_pics\", value, ps_bitstrm);\n                ps_slice_hdr->i1_num_long_term_pics = value;\n                ps_slice_hdr->i1_num_long_term_pics = CLIP3(ps_slice_hdr->i1_num_long_term_pics,\n 0, MAX_DPB_SIZE - num_neg_pics - num_pos_pics -\n                                                            ps_slice_hdr->i1_num_long_term_sps);\n\n for(i = 0; i < (ps_slice_hdr->i1_num_long_term_sps +\n                                ps_slice_hdr->i1_num_long_term_pics); i++)\n {\n if(i < ps_slice_hdr->i1_num_long_term_sps)\n {\n /* Use CLZ to compute Ceil( Log2( num_long_term_ref_pics_sps ) ) */\n if (ps_sps->i1_num_long_term_ref_pics_sps > 1)\n {\n                            WORD32 num_bits = 32 - CLZ(ps_sps->i1_num_long_term_ref_pics_sps - 1);\n                            BITS_PARSE(\"lt_idx_sps[ i ]\", value, ps_bitstrm, num_bits);\n }\n else\n {\n                            value = 0;\n }\n                        ps_slice_hdr->ai4_poc_lsb_lt[i] = ps_sps->au2_lt_ref_pic_poc_lsb_sps[value];\n                        ps_slice_hdr->ai1_used_by_curr_pic_lt_flag[i] = ps_sps->ai1_used_by_curr_pic_lt_sps_flag[value];\n\n }\n else\n {\n                        BITS_PARSE(\"poc_lsb_lt[ i ]\", value, ps_bitstrm, ps_sps->i1_log2_max_pic_order_cnt_lsb);\n                        ps_slice_hdr->ai4_poc_lsb_lt[i] = value;\n\n                        BITS_PARSE(\"used_by_curr_pic_lt_flag[ i ]\", value, ps_bitstrm, 1);\n                        ps_slice_hdr->ai1_used_by_curr_pic_lt_flag[i] = value;\n\n }\n                    BITS_PARSE(\"delta_poc_msb_present_flag[ i ]\", value, ps_bitstrm, 1);\n                    ps_slice_hdr->ai1_delta_poc_msb_present_flag[i] = value;\n\n\n                    ps_slice_hdr->ai1_delta_poc_msb_cycle_lt[i] = 0;\n if(ps_slice_hdr->ai1_delta_poc_msb_present_flag[i])\n {\n\n                        UEV_PARSE(\"delata_poc_msb_cycle_lt[ i ]\", value, ps_bitstrm);\n                        ps_slice_hdr->ai1_delta_poc_msb_cycle_lt[i] = value;\n }\n\n if((i != 0) && (i != ps_slice_hdr->i1_num_long_term_sps))\n {\n                        ps_slice_hdr->ai1_delta_poc_msb_cycle_lt[i] += ps_slice_hdr->ai1_delta_poc_msb_cycle_lt[i - 1];\n }\n\n }\n }\n\n for(i = 0; i < num_neg_pics + num_pos_pics; i++)\n {\n if(pi1_used[i])\n {\n                    num_poc_total_curr++;\n }\n }\n for(i = 0; i < ps_slice_hdr->i1_num_long_term_sps + ps_slice_hdr->i1_num_long_term_pics; i++)\n {\n if(ps_slice_hdr->ai1_used_by_curr_pic_lt_flag[i])\n {\n                    num_poc_total_curr++;\n }\n }\n\n\n if(ps_sps->i1_sps_temporal_mvp_enable_flag)\n {\n                BITS_PARSE(\"enable_temporal_mvp_flag\", value, ps_bitstrm, 1);\n                ps_slice_hdr->i1_slice_temporal_mvp_enable_flag = value;\n }\n\n }\n        ps_slice_hdr->i1_slice_sao_luma_flag = 0;\n        ps_slice_hdr->i1_slice_sao_chroma_flag = 0;\n if(ps_sps->i1_sample_adaptive_offset_enabled_flag)\n {\n            BITS_PARSE(\"slice_sao_luma_flag\", value, ps_bitstrm, 1);\n            ps_slice_hdr->i1_slice_sao_luma_flag = value;\n\n            BITS_PARSE(\"slice_sao_chroma_flag\", value, ps_bitstrm, 1);\n            ps_slice_hdr->i1_slice_sao_chroma_flag = value;\n\n }\n\n        ps_slice_hdr->i1_max_num_merge_cand = 1;\n        ps_slice_hdr->i1_cabac_init_flag = 0;\n\n        ps_slice_hdr->i1_num_ref_idx_l0_active = 0;\n        ps_slice_hdr->i1_num_ref_idx_l1_active = 0;\n        ps_slice_hdr->i1_slice_cb_qp_offset = 0;\n        ps_slice_hdr->i1_slice_cr_qp_offset = 0;\n if((PSLICE == ps_slice_hdr->i1_slice_type) ||\n (BSLICE == ps_slice_hdr->i1_slice_type))\n {\n            BITS_PARSE(\"num_ref_idx_active_override_flag\", value, ps_bitstrm, 1);\n            ps_slice_hdr->i1_num_ref_idx_active_override_flag = value;\n\n if(ps_slice_hdr->i1_num_ref_idx_active_override_flag)\n {\n                UEV_PARSE(\"num_ref_idx_l0_active_minus1\", value, ps_bitstrm);\n                ps_slice_hdr->i1_num_ref_idx_l0_active = value + 1;\n\n if(BSLICE == ps_slice_hdr->i1_slice_type)\n {\n                    UEV_PARSE(\"num_ref_idx_l1_active_minus1\", value, ps_bitstrm);\n                    ps_slice_hdr->i1_num_ref_idx_l1_active = value + 1;\n }\n\n }\n else\n {\n                ps_slice_hdr->i1_num_ref_idx_l0_active = ps_pps->i1_num_ref_idx_l0_default_active;\n\n if(BSLICE == ps_slice_hdr->i1_slice_type)\n {\n                    ps_slice_hdr->i1_num_ref_idx_l1_active = ps_pps->i1_num_ref_idx_l1_default_active;\n }\n }\n\n            ps_slice_hdr->i1_num_ref_idx_l0_active = CLIP3(ps_slice_hdr->i1_num_ref_idx_l0_active, 0, MAX_DPB_SIZE - 1);\n            ps_slice_hdr->i1_num_ref_idx_l1_active = CLIP3(ps_slice_hdr->i1_num_ref_idx_l1_active, 0, MAX_DPB_SIZE - 1);\n\n if(0 == num_poc_total_curr)\n return IHEVCD_IGNORE_SLICE;\n if((ps_pps->i1_lists_modification_present_flag) && (num_poc_total_curr > 1))\n {\n                ihevcd_ref_pic_list_modification(ps_bitstrm,\n                                                 ps_slice_hdr, num_poc_total_curr);\n }\n else\n {\n                ps_slice_hdr->s_rplm.i1_ref_pic_list_modification_flag_l0 = 0;\n                ps_slice_hdr->s_rplm.i1_ref_pic_list_modification_flag_l1 = 0;\n }\n\n if(BSLICE == ps_slice_hdr->i1_slice_type)\n {\n                BITS_PARSE(\"mvd_l1_zero_flag\", value, ps_bitstrm, 1);\n                ps_slice_hdr->i1_mvd_l1_zero_flag = value;\n }\n\n            ps_slice_hdr->i1_cabac_init_flag = 0;\n if(ps_pps->i1_cabac_init_present_flag)\n {\n                BITS_PARSE(\"cabac_init_flag\", value, ps_bitstrm, 1);\n                ps_slice_hdr->i1_cabac_init_flag = value;\n\n }\n            ps_slice_hdr->i1_collocated_from_l0_flag = 1;\n            ps_slice_hdr->i1_collocated_ref_idx = 0;\n if(ps_slice_hdr->i1_slice_temporal_mvp_enable_flag)\n {\n if(BSLICE == ps_slice_hdr->i1_slice_type)\n {\n                    BITS_PARSE(\"collocated_from_l0_flag\", value, ps_bitstrm, 1);\n                    ps_slice_hdr->i1_collocated_from_l0_flag = value;\n }\n\n if((ps_slice_hdr->i1_collocated_from_l0_flag  && (ps_slice_hdr->i1_num_ref_idx_l0_active > 1)) ||\n (!ps_slice_hdr->i1_collocated_from_l0_flag  && (ps_slice_hdr->i1_num_ref_idx_l1_active > 1)))\n {\n                    UEV_PARSE(\"collocated_ref_idx\", value, ps_bitstrm);\n                    ps_slice_hdr->i1_collocated_ref_idx = value;\n }\n\n }\n            ps_slice_hdr->i1_collocated_ref_idx = CLIP3(ps_slice_hdr->i1_collocated_ref_idx, 0, MAX_DPB_SIZE - 1);\n\n if((ps_pps->i1_weighted_pred_flag  && (PSLICE == ps_slice_hdr->i1_slice_type)) ||\n (ps_pps->i1_weighted_bipred_flag  && (BSLICE == ps_slice_hdr->i1_slice_type)))\n {\n                ihevcd_parse_pred_wt_ofst(ps_bitstrm, ps_sps, ps_pps, ps_slice_hdr);\n }\n            UEV_PARSE(\"five_minus_max_num_merge_cand\", value, ps_bitstrm);\n            ps_slice_hdr->i1_max_num_merge_cand = 5 - value;\n\n }\n        ps_slice_hdr->i1_max_num_merge_cand = CLIP3(ps_slice_hdr->i1_max_num_merge_cand, 1, 5);\n        SEV_PARSE(\"slice_qp_delta\", value, ps_bitstrm);\n        ps_slice_hdr->i1_slice_qp_delta = value;\n\n if(ps_pps->i1_pic_slice_level_chroma_qp_offsets_present_flag)\n {\n            SEV_PARSE(\"slice_cb_qp_offset\", value, ps_bitstrm);\n            ps_slice_hdr->i1_slice_cb_qp_offset = value;\n\n            SEV_PARSE(\"slice_cr_qp_offset\", value, ps_bitstrm);\n            ps_slice_hdr->i1_slice_cr_qp_offset = value;\n\n }\n        ps_slice_hdr->i1_deblocking_filter_override_flag = 0;\n        ps_slice_hdr->i1_slice_disable_deblocking_filter_flag  = ps_pps->i1_pic_disable_deblocking_filter_flag;\n        ps_slice_hdr->i1_beta_offset_div2 = ps_pps->i1_beta_offset_div2;\n        ps_slice_hdr->i1_tc_offset_div2 = ps_pps->i1_tc_offset_div2;\n\n        disable_deblocking_filter_flag = ps_pps->i1_pic_disable_deblocking_filter_flag;\n\n if(ps_pps->i1_deblocking_filter_control_present_flag)\n {\n\n if(ps_pps->i1_deblocking_filter_override_enabled_flag)\n {\n                BITS_PARSE(\"deblocking_filter_override_flag\", value, ps_bitstrm, 1);\n                ps_slice_hdr->i1_deblocking_filter_override_flag = value;\n }\n\n if(ps_slice_hdr->i1_deblocking_filter_override_flag)\n {\n                BITS_PARSE(\"slice_disable_deblocking_filter_flag\", value, ps_bitstrm, 1);\n                ps_slice_hdr->i1_slice_disable_deblocking_filter_flag = value;\n                disable_deblocking_filter_flag = ps_slice_hdr->i1_slice_disable_deblocking_filter_flag;\n\n if(!ps_slice_hdr->i1_slice_disable_deblocking_filter_flag)\n {\n                    SEV_PARSE(\"beta_offset_div2\", value, ps_bitstrm);\n                    ps_slice_hdr->i1_beta_offset_div2 = value;\n\n                    SEV_PARSE(\"tc_offset_div2\", value, ps_bitstrm);\n                    ps_slice_hdr->i1_tc_offset_div2 = value;\n\n }\n }\n }\n\n        ps_slice_hdr->i1_slice_loop_filter_across_slices_enabled_flag = ps_pps->i1_loop_filter_across_slices_enabled_flag;\n if(ps_pps->i1_loop_filter_across_slices_enabled_flag  &&\n (ps_slice_hdr->i1_slice_sao_luma_flag  ||  ps_slice_hdr->i1_slice_sao_chroma_flag  || !disable_deblocking_filter_flag))\n {\n            BITS_PARSE(\"slice_loop_filter_across_slices_enabled_flag\", value, ps_bitstrm, 1);\n            ps_slice_hdr->i1_slice_loop_filter_across_slices_enabled_flag = value;\n }\n\n }\n\n /* Check sanity of slice */\n if((!first_slice_in_pic_flag) &&\n (ps_codec->i4_pic_present))\n {\n slice_header_t *ps_slice_hdr_base = ps_codec->ps_slice_hdr_base;\n\n\n /* According to the standard, the above conditions must be satisfied - But for error resilience,\n         * only the following conditions are checked */\n if((ps_slice_hdr_base->i1_pps_id != ps_slice_hdr->i1_pps_id) ||\n (ps_slice_hdr_base->i4_pic_order_cnt_lsb != ps_slice_hdr->i4_pic_order_cnt_lsb))\n {\n return IHEVCD_IGNORE_SLICE;\n }\n\n }\n\n\n if(0 == ps_codec->i4_pic_present)\n {\n        ps_slice_hdr->i4_abs_pic_order_cnt = ihevcd_calc_poc(ps_codec, ps_nal, ps_sps->i1_log2_max_pic_order_cnt_lsb, ps_slice_hdr->i4_pic_order_cnt_lsb);\n }\n else\n {\n        ps_slice_hdr->i4_abs_pic_order_cnt = ps_codec->s_parse.i4_abs_pic_order_cnt;\n }\n\n\n if(!first_slice_in_pic_flag)\n {\n /* Check if the current slice belongs to the same pic (Pic being parsed) */\n if(ps_codec->s_parse.i4_abs_pic_order_cnt == ps_slice_hdr->i4_abs_pic_order_cnt)\n {\n\n /* If the Next CTB's index is less than the slice address,\n             * the previous slice is incomplete.\n             * Indicate slice error, and treat the remaining CTBs as skip */\n if(slice_address > ps_codec->s_parse.i4_next_ctb_indx)\n\n             {\n                 if(ps_codec->i4_pic_present)\n                 {\n                    slice_header_t *ps_slice_hdr_next;\n                    ps_codec->i4_slice_error = 1;\n                    ps_codec->s_parse.i4_cur_slice_idx--;\n                    if(ps_codec->s_parse.i4_cur_slice_idx < 0)\n                        ps_codec->s_parse.i4_cur_slice_idx = 0;\n                    ps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + ((ps_codec->s_parse.i4_cur_slice_idx + 1) & (MAX_SLICE_HDR_CNT - 1));\n                    ps_slice_hdr_next->i2_ctb_x = slice_address % ps_sps->i2_pic_wd_in_ctb;\n                    ps_slice_hdr_next->i2_ctb_y = slice_address / ps_sps->i2_pic_wd_in_ctb;\n                    return ret;\n                 }\n                 else\n                 {\n return IHEVCD_IGNORE_SLICE;\n }\n }\n /* If the slice address is less than the next CTB's index,\n             * extra CTBs have been decoded in the previous slice.\n             * Ignore the current slice. Treat it as incomplete */\n else if(slice_address < ps_codec->s_parse.i4_next_ctb_indx)\n {\n return IHEVCD_IGNORE_SLICE;\n }\n else\n {\n                ps_codec->i4_slice_error = 0;\n }\n }\n\n /* The current slice does not belong to the pic that is being parsed */\n else\n {\n /* The previous pic is incomplete.\n             * Treat the remaining CTBs as skip */\n if(ps_codec->i4_pic_present)\n {\n slice_header_t *ps_slice_hdr_next;\n                ps_codec->i4_slice_error = 1;\n                ps_codec->s_parse.i4_cur_slice_idx--;\n if(ps_codec->s_parse.i4_cur_slice_idx < 0)\n                    ps_codec->s_parse.i4_cur_slice_idx = 0;\n\n                ps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + ((ps_codec->s_parse.i4_cur_slice_idx + 1) & (MAX_SLICE_HDR_CNT - 1));\n                ps_slice_hdr_next->i2_ctb_x = 0;\n                ps_slice_hdr_next->i2_ctb_y = ps_codec->s_parse.ps_sps->i2_pic_ht_in_ctb;\n return ret;\n }\n\n /* If the previous pic is complete,\n             * return if the current slice is dependant\n             * otherwise, update the parse context's POC */\n else\n {\n if(ps_slice_hdr->i1_dependent_slice_flag)\n return IHEVCD_IGNORE_SLICE;\n\n                ps_codec->s_parse.i4_abs_pic_order_cnt = ps_slice_hdr->i4_abs_pic_order_cnt;\n }\n }\n }\n\n /* If the slice is the first slice in the pic, update the parse context's POC */\n else\n {\n /* If the first slice is repeated, ignore the second occurrence\n         * If any other slice is repeated, the CTB addr will be greater than the slice addr,\n         * and hence the second occurrence is ignored */\n if(ps_codec->s_parse.i4_abs_pic_order_cnt == ps_slice_hdr->i4_abs_pic_order_cnt)\n return IHEVCD_IGNORE_SLICE;\n\n        ps_codec->s_parse.i4_abs_pic_order_cnt = ps_slice_hdr->i4_abs_pic_order_cnt;\n }\n\n    ps_slice_hdr->i4_num_entry_point_offsets = 0;\n if((ps_pps->i1_tiles_enabled_flag) ||\n (ps_pps->i1_entropy_coding_sync_enabled_flag))\n {\n        UEV_PARSE(\"num_entry_point_offsets\", value, ps_bitstrm);\n        ps_slice_hdr->i4_num_entry_point_offsets = value;\n\n {\n            WORD32 max_num_entry_point_offsets;\n if((ps_pps->i1_tiles_enabled_flag) &&\n (ps_pps->i1_entropy_coding_sync_enabled_flag))\n {\n                max_num_entry_point_offsets = ps_pps->i1_num_tile_columns * (ps_sps->i2_pic_ht_in_ctb - 1);\n }\n else if(ps_pps->i1_tiles_enabled_flag)\n {\n                max_num_entry_point_offsets = ps_pps->i1_num_tile_columns * ps_pps->i1_num_tile_rows;\n }\n else\n {\n                max_num_entry_point_offsets = (ps_sps->i2_pic_ht_in_ctb - 1);\n }\n\n            ps_slice_hdr->i4_num_entry_point_offsets = CLIP3(ps_slice_hdr->i4_num_entry_point_offsets,\n 0, max_num_entry_point_offsets);\n }\n\n if(ps_slice_hdr->i4_num_entry_point_offsets > 0)\n {\n            UEV_PARSE(\"offset_len_minus1\", value, ps_bitstrm);\n            ps_slice_hdr->i1_offset_len = value + 1;\n\n for(i = 0; i < ps_slice_hdr->i4_num_entry_point_offsets; i++)\n {\n                BITS_PARSE(\"entry_point_offset\", value, ps_bitstrm, ps_slice_hdr->i1_offset_len);\n\n /* TODO: pu4_entry_point_offset needs to be initialized */\n }\n\n }\n }\n\n if(ps_pps->i1_slice_header_extension_present_flag)\n {\n        UEV_PARSE(\"slice_header_extension_length\", value, ps_bitstrm);\n        ps_slice_hdr->i2_slice_header_extension_length = value;\n\n\n for(i = 0; i < ps_slice_hdr->i2_slice_header_extension_length; i++)\n {\n            BITS_PARSE(\"slice_header_extension_data_byte\", value, ps_bitstrm, 8);\n }\n\n }\n\n    ihevcd_bits_flush_to_byte_boundary(ps_bitstrm);\n\n if((UWORD8 *)ps_bitstrm->pu4_buf > ps_bitstrm->pu1_buf_max)\n return IHEVCD_INVALID_PARAMETER;\n\n {\n dpb_mgr_t *ps_dpb_mgr = (dpb_mgr_t *)ps_codec->pv_dpb_mgr;\n        WORD32 r_idx;\n\n if((NAL_IDR_W_LP == ps_slice_hdr->i1_nal_unit_type) ||\n (NAL_IDR_N_LP == ps_slice_hdr->i1_nal_unit_type) ||\n (NAL_BLA_N_LP == ps_slice_hdr->i1_nal_unit_type) ||\n (NAL_BLA_W_DLP == ps_slice_hdr->i1_nal_unit_type) ||\n (NAL_BLA_W_LP == ps_slice_hdr->i1_nal_unit_type) ||\n (0 == ps_codec->u4_pic_cnt))\n {\n for(i = 0; i < MAX_DPB_BUFS; i++)\n {\n if(ps_dpb_mgr->as_dpb_info[i].ps_pic_buf)\n {\n pic_buf_t *ps_pic_buf = ps_dpb_mgr->as_dpb_info[i].ps_pic_buf;\n mv_buf_t *ps_mv_buf;\n\n /* Long term index is set to MAX_DPB_BUFS to ensure it is not added as LT */\n                    ihevc_dpb_mgr_del_ref((dpb_mgr_t *)ps_codec->pv_dpb_mgr, (buf_mgr_t *)ps_codec->pv_pic_buf_mgr, ps_pic_buf->i4_abs_poc);\n /* Find buffer id of the MV bank corresponding to the buffer being freed (Buffer with POC of u4_abs_poc) */\n                    ps_mv_buf = (mv_buf_t *)ps_codec->ps_mv_buf;\n for(j = 0; j < ps_codec->i4_max_dpb_size; j++)\n {\n if(ps_mv_buf && ps_mv_buf->i4_abs_poc == ps_pic_buf->i4_abs_poc)\n {\n                            ihevc_buf_mgr_release((buf_mgr_t *)ps_codec->pv_mv_buf_mgr, j, BUF_MGR_REF);\n break;\n }\n                        ps_mv_buf++;\n }\n\n }\n\n }\n\n /* Initialize the reference lists to NULL\n             * This is done to take care of the cases where the first pic is not IDR\n             * but the reference list is not created for the first pic because\n             * pic count is zero leaving the reference list uninitialised  */\n for(r_idx = 0; r_idx < MAX_DPB_SIZE; r_idx++)\n {\n                ps_slice_hdr->as_ref_pic_list0[r_idx].pv_pic_buf = NULL;\n                ps_slice_hdr->as_ref_pic_list0[r_idx].pv_mv_buf = NULL;\n\n                ps_slice_hdr->as_ref_pic_list1[r_idx].pv_pic_buf = NULL;\n                ps_slice_hdr->as_ref_pic_list1[r_idx].pv_mv_buf = NULL;\n }\n\n }\n else\n {\n            ret = ihevcd_ref_list(ps_codec, ps_pps, ps_sps, ps_slice_hdr);\n if ((WORD32)IHEVCD_SUCCESS != ret)\n {\n return ret;\n }\n\n }\n\n }\n\n /* Fill the remaining entries of the reference lists with the nearest POC\n     * This is done to handle cases where there is a corruption in the reference index */\n if(ps_codec->i4_pic_present)\n {\n pic_buf_t *ps_pic_buf_ref;\n mv_buf_t *ps_mv_buf_ref;\n        WORD32 r_idx;\n dpb_mgr_t *ps_dpb_mgr = (dpb_mgr_t *)ps_codec->pv_dpb_mgr;\n buf_mgr_t *ps_mv_buf_mgr = (buf_mgr_t *)ps_codec->pv_mv_buf_mgr;\n\n        ps_pic_buf_ref = ihevc_dpb_mgr_get_ref_by_nearest_poc(ps_dpb_mgr, ps_slice_hdr->i4_abs_pic_order_cnt);\n if(NULL == ps_pic_buf_ref)\n {\n            ps_pic_buf_ref = ps_codec->as_process[0].ps_cur_pic;\n            ps_mv_buf_ref = ps_codec->s_parse.ps_cur_mv_buf;\n }\n else\n {\n            ps_mv_buf_ref = ihevcd_mv_mgr_get_poc(ps_mv_buf_mgr, ps_pic_buf_ref->i4_abs_poc);\n }\n\n for(r_idx = 0; r_idx < ps_slice_hdr->i1_num_ref_idx_l0_active; r_idx++)\n {\n if(NULL == ps_slice_hdr->as_ref_pic_list0[r_idx].pv_pic_buf)\n {\n                ps_slice_hdr->as_ref_pic_list0[r_idx].pv_pic_buf = (void *)ps_pic_buf_ref;\n                ps_slice_hdr->as_ref_pic_list0[r_idx].pv_mv_buf = (void *)ps_mv_buf_ref;\n }\n }\n\n for(r_idx = ps_slice_hdr->i1_num_ref_idx_l0_active; r_idx < MAX_DPB_SIZE; r_idx++)\n {\n            ps_slice_hdr->as_ref_pic_list0[r_idx].pv_pic_buf = (void *)ps_pic_buf_ref;\n            ps_slice_hdr->as_ref_pic_list0[r_idx].pv_mv_buf = (void *)ps_mv_buf_ref;\n }\n\n for(r_idx = 0; r_idx < ps_slice_hdr->i1_num_ref_idx_l1_active; r_idx++)\n {\n if(NULL == ps_slice_hdr->as_ref_pic_list1[r_idx].pv_pic_buf)\n {\n                ps_slice_hdr->as_ref_pic_list1[r_idx].pv_pic_buf = (void *)ps_pic_buf_ref;\n                ps_slice_hdr->as_ref_pic_list1[r_idx].pv_mv_buf = (void *)ps_mv_buf_ref;\n }\n }\n\n for(r_idx = ps_slice_hdr->i1_num_ref_idx_l1_active; r_idx < MAX_DPB_SIZE; r_idx++)\n {\n            ps_slice_hdr->as_ref_pic_list1[r_idx].pv_pic_buf = (void *)ps_pic_buf_ref;\n            ps_slice_hdr->as_ref_pic_list1[r_idx].pv_mv_buf = (void *)ps_mv_buf_ref;\n }\n }\n\n /* Update slice address in the header */\n if(!ps_slice_hdr->i1_first_slice_in_pic_flag)\n {\n        ps_slice_hdr->i2_ctb_x = slice_address % ps_sps->i2_pic_wd_in_ctb;\n        ps_slice_hdr->i2_ctb_y = slice_address / ps_sps->i2_pic_wd_in_ctb;\n\n if(!ps_slice_hdr->i1_dependent_slice_flag)\n {\n            ps_slice_hdr->i2_independent_ctb_x = ps_slice_hdr->i2_ctb_x;\n            ps_slice_hdr->i2_independent_ctb_y = ps_slice_hdr->i2_ctb_y;\n }\n }\n else\n {\n        ps_slice_hdr->i2_ctb_x = 0;\n        ps_slice_hdr->i2_ctb_y = 0;\n\n        ps_slice_hdr->i2_independent_ctb_x = 0;\n        ps_slice_hdr->i2_independent_ctb_y = 0;\n }\n\n /* If the first slice in the pic is missing, copy the current slice header to\n     * the first slice's header */\n if((!first_slice_in_pic_flag) &&\n (0 == ps_codec->i4_pic_present))\n {\n\n         slice_header_t *ps_slice_hdr_prev = ps_codec->s_parse.ps_slice_hdr_base;\n         ihevcd_copy_slice_hdr(ps_codec, 0, (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1)));\n \n        ps_codec->i4_slice_error = 1;\n \n         ps_slice_hdr_prev->i2_ctb_x = 0;\n         ps_slice_hdr_prev->i2_ctb_y = 0;\n\n        ps_codec->s_parse.i4_ctb_x = 0;\n        ps_codec->s_parse.i4_ctb_y = 0;\n\n        ps_codec->s_parse.i4_cur_slice_idx = 0;\n\n if((ps_slice_hdr->i2_ctb_x == 0) &&\n (ps_slice_hdr->i2_ctb_y == 0))\n {\n            ps_slice_hdr->i2_ctb_x++;\n }\n }\n\n {\n /* If skip B is enabled,\n         * ignore pictures that are non-reference\n         * TODO: (i1_nal_unit_type < NAL_BLA_W_LP) && (i1_nal_unit_type % 2 == 0) only says it is\n         * sub-layer non-reference slice. May need to find a way to detect actual non-reference pictures*/\n\n if((i1_nal_unit_type < NAL_BLA_W_LP) &&\n (i1_nal_unit_type % 2 == 0))\n {\n if(IVD_SKIP_B == ps_codec->e_pic_skip_mode)\n return IHEVCD_IGNORE_SLICE;\n }\n\n /* If skip PB is enabled,\n         * decode only I slices */\n if((IVD_SKIP_PB == ps_codec->e_pic_skip_mode) &&\n (ISLICE != ps_slice_hdr->i1_slice_type))\n {\n return IHEVCD_IGNORE_SLICE;\n\n         }\n     }\n \n     return ret;\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143937,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "IHEVCD_ERROR_T ihevcd_parse_slice_header(codec_t *ps_codec,\n nal_header_t *ps_nal)\n{\n    IHEVCD_ERROR_T ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;\n    WORD32 value;\n    WORD32 i, j;\n    WORD32 sps_id;\n\n pps_t *ps_pps;\n sps_t *ps_sps;\n slice_header_t *ps_slice_hdr;\n    WORD32 disable_deblocking_filter_flag;\n bitstrm_t *ps_bitstrm = &ps_codec->s_parse.s_bitstrm;\n    WORD32 idr_pic_flag;\n    WORD32 pps_id;\n    WORD32 first_slice_in_pic_flag;\n    WORD32 no_output_of_prior_pics_flag = 0;\n\n     WORD8 i1_nal_unit_type = ps_nal->i1_nal_unit_type;\n     WORD32 num_poc_total_curr = 0;\n     WORD32 slice_address;\n    WORD32 prev_slice_incomplete_flag = 0;\n \n     if(ps_codec->i4_slice_error == 1)\n         return ret;\n\n    idr_pic_flag = (NAL_IDR_W_LP == i1_nal_unit_type) ||\n (NAL_IDR_N_LP == i1_nal_unit_type);\n\n\n    BITS_PARSE(\"first_slice_in_pic_flag\", first_slice_in_pic_flag, ps_bitstrm, 1);\n if((NAL_BLA_W_LP <= i1_nal_unit_type) &&\n (NAL_RSV_RAP_VCL23          >= i1_nal_unit_type))\n {\n        BITS_PARSE(\"no_output_of_prior_pics_flag\", no_output_of_prior_pics_flag, ps_bitstrm, 1);\n }\n    UEV_PARSE(\"pic_parameter_set_id\", pps_id, ps_bitstrm);\n    pps_id = CLIP3(pps_id, 0, MAX_PPS_CNT - 2);\n\n /* Get the current PPS structure */\n    ps_pps = ps_codec->s_parse.ps_pps_base + pps_id;\n if(0 == ps_pps->i1_pps_valid)\n {\n pps_t *ps_pps_ref = ps_codec->ps_pps_base;\n while(0 == ps_pps_ref->i1_pps_valid)\n {\n            ps_pps_ref++;\n if((ps_pps_ref - ps_codec->ps_pps_base >= MAX_PPS_CNT - 1))\n return IHEVCD_INVALID_HEADER;\n }\n\n        ihevcd_copy_pps(ps_codec, pps_id, ps_pps_ref->i1_pps_id);\n }\n\n /* Get SPS id for the current PPS */\n    sps_id = ps_pps->i1_sps_id;\n\n /* Get the current SPS structure */\n    ps_sps = ps_codec->s_parse.ps_sps_base + sps_id;\n\n /* When the current slice is the first in a pic,\n     *  check whether the previous frame is complete\n     *  If the previous frame is incomplete -\n     *  treat the remaining CTBs as skip */\n if((0 != ps_codec->u4_pic_cnt || ps_codec->i4_pic_present) &&\n                    first_slice_in_pic_flag)\n {\n if(ps_codec->i4_pic_present)\n {\n slice_header_t *ps_slice_hdr_next;\n            ps_codec->i4_slice_error = 1;\n            ps_codec->s_parse.i4_cur_slice_idx--;\n if(ps_codec->s_parse.i4_cur_slice_idx < 0)\n                ps_codec->s_parse.i4_cur_slice_idx = 0;\n\n            ps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + ((ps_codec->s_parse.i4_cur_slice_idx + 1) & (MAX_SLICE_HDR_CNT - 1));\n            ps_slice_hdr_next->i2_ctb_x = 0;\n            ps_slice_hdr_next->i2_ctb_y = ps_codec->s_parse.ps_sps->i2_pic_ht_in_ctb;\n return ret;\n }\n else\n {\n            ps_codec->i4_slice_error = 0;\n }\n }\n\n if(first_slice_in_pic_flag)\n {\n        ps_codec->s_parse.i4_cur_slice_idx = 0;\n }\n else\n {\n /* If the current slice is not the first slice in the pic,\n         * but the first one to be parsed, set the current slice indx to 1\n         * Treat the first slice to be missing and copy the current slice header\n         * to the first one */\n if(0 == ps_codec->i4_pic_present)\n            ps_codec->s_parse.i4_cur_slice_idx = 1;\n }\n\n    ps_slice_hdr = ps_codec->s_parse.ps_slice_hdr_base + (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1));\n\n\n if((ps_pps->i1_dependent_slice_enabled_flag) &&\n (!first_slice_in_pic_flag))\n {\n        BITS_PARSE(\"dependent_slice_flag\", value, ps_bitstrm, 1);\n\n /* If dependendent slice, copy slice header from previous slice */\n if(value && (ps_codec->s_parse.i4_cur_slice_idx > 0))\n {\n            ihevcd_copy_slice_hdr(ps_codec,\n (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1)),\n ((ps_codec->s_parse.i4_cur_slice_idx - 1) & (MAX_SLICE_HDR_CNT - 1)));\n }\n        ps_slice_hdr->i1_dependent_slice_flag = value;\n }\n else\n {\n        ps_slice_hdr->i1_dependent_slice_flag = 0;\n }\n    ps_slice_hdr->i1_nal_unit_type = i1_nal_unit_type;\n    ps_slice_hdr->i1_pps_id = pps_id;\n    ps_slice_hdr->i1_first_slice_in_pic_flag = first_slice_in_pic_flag;\n\n    ps_slice_hdr->i1_no_output_of_prior_pics_flag = 1;\n if((NAL_BLA_W_LP <= i1_nal_unit_type) &&\n (NAL_RSV_RAP_VCL23          >= i1_nal_unit_type))\n {\n        ps_slice_hdr->i1_no_output_of_prior_pics_flag = no_output_of_prior_pics_flag;\n }\n    ps_slice_hdr->i1_pps_id = pps_id;\n\n if(!ps_slice_hdr->i1_first_slice_in_pic_flag)\n {\n        WORD32 num_bits;\n\n /* Use CLZ to compute Ceil( Log2( PicSizeInCtbsY ) ) */\n        num_bits = 32 - CLZ(ps_sps->i4_pic_size_in_ctb - 1);\n        BITS_PARSE(\"slice_address\", value, ps_bitstrm, num_bits);\n\n        slice_address = value;\n /* If slice address is greater than the number of CTBs in a picture,\n         * ignore the slice */\n if(value >= ps_sps->i4_pic_size_in_ctb)\n return IHEVCD_IGNORE_SLICE;\n }\n else\n {\n        slice_address = 0;\n }\n\n if(!ps_slice_hdr->i1_dependent_slice_flag)\n {\n        ps_slice_hdr->i1_pic_output_flag = 1;\n        ps_slice_hdr->i4_pic_order_cnt_lsb = 0;\n        ps_slice_hdr->i1_num_long_term_sps = 0;\n        ps_slice_hdr->i1_num_long_term_pics = 0;\n\n for(i = 0; i < ps_pps->i1_num_extra_slice_header_bits; i++)\n {\n            BITS_PARSE(\"slice_reserved_undetermined_flag[ i ]\", value, ps_bitstrm, 1);\n }\n        UEV_PARSE(\"slice_type\", value, ps_bitstrm);\n        ps_slice_hdr->i1_slice_type = value;\n\n /* If the picture is IRAP, slice type must be equal to ISLICE */\n if((ps_slice_hdr->i1_nal_unit_type >= NAL_BLA_W_LP) &&\n (ps_slice_hdr->i1_nal_unit_type <= NAL_RSV_RAP_VCL23))\n            ps_slice_hdr->i1_slice_type = ISLICE;\n\n if((ps_slice_hdr->i1_slice_type < 0) ||\n (ps_slice_hdr->i1_slice_type > 2))\n return IHEVCD_IGNORE_SLICE;\n\n if(ps_pps->i1_output_flag_present_flag)\n {\n            BITS_PARSE(\"pic_output_flag\", value, ps_bitstrm, 1);\n            ps_slice_hdr->i1_pic_output_flag = value;\n }\n        ps_slice_hdr->i1_colour_plane_id = 0;\n if(1 == ps_sps->i1_separate_colour_plane_flag)\n {\n            BITS_PARSE(\"colour_plane_id\", value, ps_bitstrm, 2);\n            ps_slice_hdr->i1_colour_plane_id = value;\n }\n        ps_slice_hdr->i1_slice_temporal_mvp_enable_flag = 0;\n\n if(!idr_pic_flag)\n {\n\n            WORD32 st_rps_idx;\n            WORD32 num_neg_pics;\n            WORD32 num_pos_pics;\n            WORD8 *pi1_used;\n\n            BITS_PARSE(\"pic_order_cnt_lsb\", value, ps_bitstrm, ps_sps->i1_log2_max_pic_order_cnt_lsb);\n            ps_slice_hdr->i4_pic_order_cnt_lsb = value;\n\n            BITS_PARSE(\"short_term_ref_pic_set_sps_flag\", value, ps_bitstrm, 1);\n            ps_slice_hdr->i1_short_term_ref_pic_set_sps_flag = value;\n\n if(1 == ps_slice_hdr->i1_short_term_ref_pic_set_sps_flag)\n {\n                WORD32 numbits;\n\n                ps_slice_hdr->i1_short_term_ref_pic_set_idx = 0;\n if(ps_sps->i1_num_short_term_ref_pic_sets > 1)\n {\n                    numbits = 32 - CLZ(ps_sps->i1_num_short_term_ref_pic_sets - 1);\n                    BITS_PARSE(\"short_term_ref_pic_set_idx\", value, ps_bitstrm, numbits);\n                    ps_slice_hdr->i1_short_term_ref_pic_set_idx = value;\n }\n\n                st_rps_idx = ps_slice_hdr->i1_short_term_ref_pic_set_idx;\n                num_neg_pics = ps_sps->as_stref_picset[st_rps_idx].i1_num_neg_pics;\n                num_pos_pics = ps_sps->as_stref_picset[st_rps_idx].i1_num_pos_pics;\n                pi1_used = ps_sps->as_stref_picset[st_rps_idx].ai1_used;\n }\n else\n {\n                ihevcd_short_term_ref_pic_set(ps_bitstrm,\n &ps_sps->as_stref_picset[0],\n                                              ps_sps->i1_num_short_term_ref_pic_sets,\n                                              ps_sps->i1_num_short_term_ref_pic_sets,\n &ps_slice_hdr->s_stref_picset);\n\n                st_rps_idx = ps_sps->i1_num_short_term_ref_pic_sets;\n                num_neg_pics = ps_slice_hdr->s_stref_picset.i1_num_neg_pics;\n                num_pos_pics = ps_slice_hdr->s_stref_picset.i1_num_pos_pics;\n                pi1_used = ps_slice_hdr->s_stref_picset.ai1_used;\n }\n\n if(ps_sps->i1_long_term_ref_pics_present_flag)\n {\n if(ps_sps->i1_num_long_term_ref_pics_sps > 0)\n {\n                    UEV_PARSE(\"num_long_term_sps\", value, ps_bitstrm);\n                    ps_slice_hdr->i1_num_long_term_sps = value;\n\n                    ps_slice_hdr->i1_num_long_term_sps = CLIP3(ps_slice_hdr->i1_num_long_term_sps,\n 0, MAX_DPB_SIZE - num_neg_pics - num_pos_pics);\n }\n                UEV_PARSE(\"num_long_term_pics\", value, ps_bitstrm);\n                ps_slice_hdr->i1_num_long_term_pics = value;\n                ps_slice_hdr->i1_num_long_term_pics = CLIP3(ps_slice_hdr->i1_num_long_term_pics,\n 0, MAX_DPB_SIZE - num_neg_pics - num_pos_pics -\n                                                            ps_slice_hdr->i1_num_long_term_sps);\n\n for(i = 0; i < (ps_slice_hdr->i1_num_long_term_sps +\n                                ps_slice_hdr->i1_num_long_term_pics); i++)\n {\n if(i < ps_slice_hdr->i1_num_long_term_sps)\n {\n /* Use CLZ to compute Ceil( Log2( num_long_term_ref_pics_sps ) ) */\n if (ps_sps->i1_num_long_term_ref_pics_sps > 1)\n {\n                            WORD32 num_bits = 32 - CLZ(ps_sps->i1_num_long_term_ref_pics_sps - 1);\n                            BITS_PARSE(\"lt_idx_sps[ i ]\", value, ps_bitstrm, num_bits);\n }\n else\n {\n                            value = 0;\n }\n                        ps_slice_hdr->ai4_poc_lsb_lt[i] = ps_sps->au2_lt_ref_pic_poc_lsb_sps[value];\n                        ps_slice_hdr->ai1_used_by_curr_pic_lt_flag[i] = ps_sps->ai1_used_by_curr_pic_lt_sps_flag[value];\n\n }\n else\n {\n                        BITS_PARSE(\"poc_lsb_lt[ i ]\", value, ps_bitstrm, ps_sps->i1_log2_max_pic_order_cnt_lsb);\n                        ps_slice_hdr->ai4_poc_lsb_lt[i] = value;\n\n                        BITS_PARSE(\"used_by_curr_pic_lt_flag[ i ]\", value, ps_bitstrm, 1);\n                        ps_slice_hdr->ai1_used_by_curr_pic_lt_flag[i] = value;\n\n }\n                    BITS_PARSE(\"delta_poc_msb_present_flag[ i ]\", value, ps_bitstrm, 1);\n                    ps_slice_hdr->ai1_delta_poc_msb_present_flag[i] = value;\n\n\n                    ps_slice_hdr->ai1_delta_poc_msb_cycle_lt[i] = 0;\n if(ps_slice_hdr->ai1_delta_poc_msb_present_flag[i])\n {\n\n                        UEV_PARSE(\"delata_poc_msb_cycle_lt[ i ]\", value, ps_bitstrm);\n                        ps_slice_hdr->ai1_delta_poc_msb_cycle_lt[i] = value;\n }\n\n if((i != 0) && (i != ps_slice_hdr->i1_num_long_term_sps))\n {\n                        ps_slice_hdr->ai1_delta_poc_msb_cycle_lt[i] += ps_slice_hdr->ai1_delta_poc_msb_cycle_lt[i - 1];\n }\n\n }\n }\n\n for(i = 0; i < num_neg_pics + num_pos_pics; i++)\n {\n if(pi1_used[i])\n {\n                    num_poc_total_curr++;\n }\n }\n for(i = 0; i < ps_slice_hdr->i1_num_long_term_sps + ps_slice_hdr->i1_num_long_term_pics; i++)\n {\n if(ps_slice_hdr->ai1_used_by_curr_pic_lt_flag[i])\n {\n                    num_poc_total_curr++;\n }\n }\n\n\n if(ps_sps->i1_sps_temporal_mvp_enable_flag)\n {\n                BITS_PARSE(\"enable_temporal_mvp_flag\", value, ps_bitstrm, 1);\n                ps_slice_hdr->i1_slice_temporal_mvp_enable_flag = value;\n }\n\n }\n        ps_slice_hdr->i1_slice_sao_luma_flag = 0;\n        ps_slice_hdr->i1_slice_sao_chroma_flag = 0;\n if(ps_sps->i1_sample_adaptive_offset_enabled_flag)\n {\n            BITS_PARSE(\"slice_sao_luma_flag\", value, ps_bitstrm, 1);\n            ps_slice_hdr->i1_slice_sao_luma_flag = value;\n\n            BITS_PARSE(\"slice_sao_chroma_flag\", value, ps_bitstrm, 1);\n            ps_slice_hdr->i1_slice_sao_chroma_flag = value;\n\n }\n\n        ps_slice_hdr->i1_max_num_merge_cand = 1;\n        ps_slice_hdr->i1_cabac_init_flag = 0;\n\n        ps_slice_hdr->i1_num_ref_idx_l0_active = 0;\n        ps_slice_hdr->i1_num_ref_idx_l1_active = 0;\n        ps_slice_hdr->i1_slice_cb_qp_offset = 0;\n        ps_slice_hdr->i1_slice_cr_qp_offset = 0;\n if((PSLICE == ps_slice_hdr->i1_slice_type) ||\n (BSLICE == ps_slice_hdr->i1_slice_type))\n {\n            BITS_PARSE(\"num_ref_idx_active_override_flag\", value, ps_bitstrm, 1);\n            ps_slice_hdr->i1_num_ref_idx_active_override_flag = value;\n\n if(ps_slice_hdr->i1_num_ref_idx_active_override_flag)\n {\n                UEV_PARSE(\"num_ref_idx_l0_active_minus1\", value, ps_bitstrm);\n                ps_slice_hdr->i1_num_ref_idx_l0_active = value + 1;\n\n if(BSLICE == ps_slice_hdr->i1_slice_type)\n {\n                    UEV_PARSE(\"num_ref_idx_l1_active_minus1\", value, ps_bitstrm);\n                    ps_slice_hdr->i1_num_ref_idx_l1_active = value + 1;\n }\n\n }\n else\n {\n                ps_slice_hdr->i1_num_ref_idx_l0_active = ps_pps->i1_num_ref_idx_l0_default_active;\n\n if(BSLICE == ps_slice_hdr->i1_slice_type)\n {\n                    ps_slice_hdr->i1_num_ref_idx_l1_active = ps_pps->i1_num_ref_idx_l1_default_active;\n }\n }\n\n            ps_slice_hdr->i1_num_ref_idx_l0_active = CLIP3(ps_slice_hdr->i1_num_ref_idx_l0_active, 0, MAX_DPB_SIZE - 1);\n            ps_slice_hdr->i1_num_ref_idx_l1_active = CLIP3(ps_slice_hdr->i1_num_ref_idx_l1_active, 0, MAX_DPB_SIZE - 1);\n\n if(0 == num_poc_total_curr)\n return IHEVCD_IGNORE_SLICE;\n if((ps_pps->i1_lists_modification_present_flag) && (num_poc_total_curr > 1))\n {\n                ihevcd_ref_pic_list_modification(ps_bitstrm,\n                                                 ps_slice_hdr, num_poc_total_curr);\n }\n else\n {\n                ps_slice_hdr->s_rplm.i1_ref_pic_list_modification_flag_l0 = 0;\n                ps_slice_hdr->s_rplm.i1_ref_pic_list_modification_flag_l1 = 0;\n }\n\n if(BSLICE == ps_slice_hdr->i1_slice_type)\n {\n                BITS_PARSE(\"mvd_l1_zero_flag\", value, ps_bitstrm, 1);\n                ps_slice_hdr->i1_mvd_l1_zero_flag = value;\n }\n\n            ps_slice_hdr->i1_cabac_init_flag = 0;\n if(ps_pps->i1_cabac_init_present_flag)\n {\n                BITS_PARSE(\"cabac_init_flag\", value, ps_bitstrm, 1);\n                ps_slice_hdr->i1_cabac_init_flag = value;\n\n }\n            ps_slice_hdr->i1_collocated_from_l0_flag = 1;\n            ps_slice_hdr->i1_collocated_ref_idx = 0;\n if(ps_slice_hdr->i1_slice_temporal_mvp_enable_flag)\n {\n if(BSLICE == ps_slice_hdr->i1_slice_type)\n {\n                    BITS_PARSE(\"collocated_from_l0_flag\", value, ps_bitstrm, 1);\n                    ps_slice_hdr->i1_collocated_from_l0_flag = value;\n }\n\n if((ps_slice_hdr->i1_collocated_from_l0_flag  && (ps_slice_hdr->i1_num_ref_idx_l0_active > 1)) ||\n (!ps_slice_hdr->i1_collocated_from_l0_flag  && (ps_slice_hdr->i1_num_ref_idx_l1_active > 1)))\n {\n                    UEV_PARSE(\"collocated_ref_idx\", value, ps_bitstrm);\n                    ps_slice_hdr->i1_collocated_ref_idx = value;\n }\n\n }\n            ps_slice_hdr->i1_collocated_ref_idx = CLIP3(ps_slice_hdr->i1_collocated_ref_idx, 0, MAX_DPB_SIZE - 1);\n\n if((ps_pps->i1_weighted_pred_flag  && (PSLICE == ps_slice_hdr->i1_slice_type)) ||\n (ps_pps->i1_weighted_bipred_flag  && (BSLICE == ps_slice_hdr->i1_slice_type)))\n {\n                ihevcd_parse_pred_wt_ofst(ps_bitstrm, ps_sps, ps_pps, ps_slice_hdr);\n }\n            UEV_PARSE(\"five_minus_max_num_merge_cand\", value, ps_bitstrm);\n            ps_slice_hdr->i1_max_num_merge_cand = 5 - value;\n\n }\n        ps_slice_hdr->i1_max_num_merge_cand = CLIP3(ps_slice_hdr->i1_max_num_merge_cand, 1, 5);\n        SEV_PARSE(\"slice_qp_delta\", value, ps_bitstrm);\n        ps_slice_hdr->i1_slice_qp_delta = value;\n\n if(ps_pps->i1_pic_slice_level_chroma_qp_offsets_present_flag)\n {\n            SEV_PARSE(\"slice_cb_qp_offset\", value, ps_bitstrm);\n            ps_slice_hdr->i1_slice_cb_qp_offset = value;\n\n            SEV_PARSE(\"slice_cr_qp_offset\", value, ps_bitstrm);\n            ps_slice_hdr->i1_slice_cr_qp_offset = value;\n\n }\n        ps_slice_hdr->i1_deblocking_filter_override_flag = 0;\n        ps_slice_hdr->i1_slice_disable_deblocking_filter_flag  = ps_pps->i1_pic_disable_deblocking_filter_flag;\n        ps_slice_hdr->i1_beta_offset_div2 = ps_pps->i1_beta_offset_div2;\n        ps_slice_hdr->i1_tc_offset_div2 = ps_pps->i1_tc_offset_div2;\n\n        disable_deblocking_filter_flag = ps_pps->i1_pic_disable_deblocking_filter_flag;\n\n if(ps_pps->i1_deblocking_filter_control_present_flag)\n {\n\n if(ps_pps->i1_deblocking_filter_override_enabled_flag)\n {\n                BITS_PARSE(\"deblocking_filter_override_flag\", value, ps_bitstrm, 1);\n                ps_slice_hdr->i1_deblocking_filter_override_flag = value;\n }\n\n if(ps_slice_hdr->i1_deblocking_filter_override_flag)\n {\n                BITS_PARSE(\"slice_disable_deblocking_filter_flag\", value, ps_bitstrm, 1);\n                ps_slice_hdr->i1_slice_disable_deblocking_filter_flag = value;\n                disable_deblocking_filter_flag = ps_slice_hdr->i1_slice_disable_deblocking_filter_flag;\n\n if(!ps_slice_hdr->i1_slice_disable_deblocking_filter_flag)\n {\n                    SEV_PARSE(\"beta_offset_div2\", value, ps_bitstrm);\n                    ps_slice_hdr->i1_beta_offset_div2 = value;\n\n                    SEV_PARSE(\"tc_offset_div2\", value, ps_bitstrm);\n                    ps_slice_hdr->i1_tc_offset_div2 = value;\n\n }\n }\n }\n\n        ps_slice_hdr->i1_slice_loop_filter_across_slices_enabled_flag = ps_pps->i1_loop_filter_across_slices_enabled_flag;\n if(ps_pps->i1_loop_filter_across_slices_enabled_flag  &&\n (ps_slice_hdr->i1_slice_sao_luma_flag  ||  ps_slice_hdr->i1_slice_sao_chroma_flag  || !disable_deblocking_filter_flag))\n {\n            BITS_PARSE(\"slice_loop_filter_across_slices_enabled_flag\", value, ps_bitstrm, 1);\n            ps_slice_hdr->i1_slice_loop_filter_across_slices_enabled_flag = value;\n }\n\n }\n\n /* Check sanity of slice */\n if((!first_slice_in_pic_flag) &&\n (ps_codec->i4_pic_present))\n {\n slice_header_t *ps_slice_hdr_base = ps_codec->ps_slice_hdr_base;\n\n\n /* According to the standard, the above conditions must be satisfied - But for error resilience,\n         * only the following conditions are checked */\n if((ps_slice_hdr_base->i1_pps_id != ps_slice_hdr->i1_pps_id) ||\n (ps_slice_hdr_base->i4_pic_order_cnt_lsb != ps_slice_hdr->i4_pic_order_cnt_lsb))\n {\n return IHEVCD_IGNORE_SLICE;\n }\n\n }\n\n\n if(0 == ps_codec->i4_pic_present)\n {\n        ps_slice_hdr->i4_abs_pic_order_cnt = ihevcd_calc_poc(ps_codec, ps_nal, ps_sps->i1_log2_max_pic_order_cnt_lsb, ps_slice_hdr->i4_pic_order_cnt_lsb);\n }\n else\n {\n        ps_slice_hdr->i4_abs_pic_order_cnt = ps_codec->s_parse.i4_abs_pic_order_cnt;\n }\n\n\n if(!first_slice_in_pic_flag)\n {\n /* Check if the current slice belongs to the same pic (Pic being parsed) */\n if(ps_codec->s_parse.i4_abs_pic_order_cnt == ps_slice_hdr->i4_abs_pic_order_cnt)\n {\n\n /* If the Next CTB's index is less than the slice address,\n             * the previous slice is incomplete.\n             * Indicate slice error, and treat the remaining CTBs as skip */\n if(slice_address > ps_codec->s_parse.i4_next_ctb_indx)\n\n             {\n                 if(ps_codec->i4_pic_present)\n                 {\n                    prev_slice_incomplete_flag = 1;\n                 }\n                 else\n                 {\n return IHEVCD_IGNORE_SLICE;\n }\n }\n /* If the slice address is less than the next CTB's index,\n             * extra CTBs have been decoded in the previous slice.\n             * Ignore the current slice. Treat it as incomplete */\n else if(slice_address < ps_codec->s_parse.i4_next_ctb_indx)\n {\n return IHEVCD_IGNORE_SLICE;\n }\n else\n {\n                ps_codec->i4_slice_error = 0;\n }\n }\n\n /* The current slice does not belong to the pic that is being parsed */\n else\n {\n /* The previous pic is incomplete.\n             * Treat the remaining CTBs as skip */\n if(ps_codec->i4_pic_present)\n {\n slice_header_t *ps_slice_hdr_next;\n                ps_codec->i4_slice_error = 1;\n                ps_codec->s_parse.i4_cur_slice_idx--;\n if(ps_codec->s_parse.i4_cur_slice_idx < 0)\n                    ps_codec->s_parse.i4_cur_slice_idx = 0;\n\n                ps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + ((ps_codec->s_parse.i4_cur_slice_idx + 1) & (MAX_SLICE_HDR_CNT - 1));\n                ps_slice_hdr_next->i2_ctb_x = 0;\n                ps_slice_hdr_next->i2_ctb_y = ps_codec->s_parse.ps_sps->i2_pic_ht_in_ctb;\n return ret;\n }\n\n /* If the previous pic is complete,\n             * return if the current slice is dependant\n             * otherwise, update the parse context's POC */\n else\n {\n if(ps_slice_hdr->i1_dependent_slice_flag)\n return IHEVCD_IGNORE_SLICE;\n\n                ps_codec->s_parse.i4_abs_pic_order_cnt = ps_slice_hdr->i4_abs_pic_order_cnt;\n }\n }\n }\n\n /* If the slice is the first slice in the pic, update the parse context's POC */\n else\n {\n /* If the first slice is repeated, ignore the second occurrence\n         * If any other slice is repeated, the CTB addr will be greater than the slice addr,\n         * and hence the second occurrence is ignored */\n if(ps_codec->s_parse.i4_abs_pic_order_cnt == ps_slice_hdr->i4_abs_pic_order_cnt)\n return IHEVCD_IGNORE_SLICE;\n\n        ps_codec->s_parse.i4_abs_pic_order_cnt = ps_slice_hdr->i4_abs_pic_order_cnt;\n }\n\n    ps_slice_hdr->i4_num_entry_point_offsets = 0;\n if((ps_pps->i1_tiles_enabled_flag) ||\n (ps_pps->i1_entropy_coding_sync_enabled_flag))\n {\n        UEV_PARSE(\"num_entry_point_offsets\", value, ps_bitstrm);\n        ps_slice_hdr->i4_num_entry_point_offsets = value;\n\n {\n            WORD32 max_num_entry_point_offsets;\n if((ps_pps->i1_tiles_enabled_flag) &&\n (ps_pps->i1_entropy_coding_sync_enabled_flag))\n {\n                max_num_entry_point_offsets = ps_pps->i1_num_tile_columns * (ps_sps->i2_pic_ht_in_ctb - 1);\n }\n else if(ps_pps->i1_tiles_enabled_flag)\n {\n                max_num_entry_point_offsets = ps_pps->i1_num_tile_columns * ps_pps->i1_num_tile_rows;\n }\n else\n {\n                max_num_entry_point_offsets = (ps_sps->i2_pic_ht_in_ctb - 1);\n }\n\n            ps_slice_hdr->i4_num_entry_point_offsets = CLIP3(ps_slice_hdr->i4_num_entry_point_offsets,\n 0, max_num_entry_point_offsets);\n }\n\n if(ps_slice_hdr->i4_num_entry_point_offsets > 0)\n {\n            UEV_PARSE(\"offset_len_minus1\", value, ps_bitstrm);\n            ps_slice_hdr->i1_offset_len = value + 1;\n\n for(i = 0; i < ps_slice_hdr->i4_num_entry_point_offsets; i++)\n {\n                BITS_PARSE(\"entry_point_offset\", value, ps_bitstrm, ps_slice_hdr->i1_offset_len);\n\n /* TODO: pu4_entry_point_offset needs to be initialized */\n }\n\n }\n }\n\n if(ps_pps->i1_slice_header_extension_present_flag)\n {\n        UEV_PARSE(\"slice_header_extension_length\", value, ps_bitstrm);\n        ps_slice_hdr->i2_slice_header_extension_length = value;\n\n\n for(i = 0; i < ps_slice_hdr->i2_slice_header_extension_length; i++)\n {\n            BITS_PARSE(\"slice_header_extension_data_byte\", value, ps_bitstrm, 8);\n }\n\n }\n\n    ihevcd_bits_flush_to_byte_boundary(ps_bitstrm);\n\n if((UWORD8 *)ps_bitstrm->pu4_buf > ps_bitstrm->pu1_buf_max)\n return IHEVCD_INVALID_PARAMETER;\n\n {\n dpb_mgr_t *ps_dpb_mgr = (dpb_mgr_t *)ps_codec->pv_dpb_mgr;\n        WORD32 r_idx;\n\n if((NAL_IDR_W_LP == ps_slice_hdr->i1_nal_unit_type) ||\n (NAL_IDR_N_LP == ps_slice_hdr->i1_nal_unit_type) ||\n (NAL_BLA_N_LP == ps_slice_hdr->i1_nal_unit_type) ||\n (NAL_BLA_W_DLP == ps_slice_hdr->i1_nal_unit_type) ||\n (NAL_BLA_W_LP == ps_slice_hdr->i1_nal_unit_type) ||\n (0 == ps_codec->u4_pic_cnt))\n {\n for(i = 0; i < MAX_DPB_BUFS; i++)\n {\n if(ps_dpb_mgr->as_dpb_info[i].ps_pic_buf)\n {\n pic_buf_t *ps_pic_buf = ps_dpb_mgr->as_dpb_info[i].ps_pic_buf;\n mv_buf_t *ps_mv_buf;\n\n /* Long term index is set to MAX_DPB_BUFS to ensure it is not added as LT */\n                    ihevc_dpb_mgr_del_ref((dpb_mgr_t *)ps_codec->pv_dpb_mgr, (buf_mgr_t *)ps_codec->pv_pic_buf_mgr, ps_pic_buf->i4_abs_poc);\n /* Find buffer id of the MV bank corresponding to the buffer being freed (Buffer with POC of u4_abs_poc) */\n                    ps_mv_buf = (mv_buf_t *)ps_codec->ps_mv_buf;\n for(j = 0; j < ps_codec->i4_max_dpb_size; j++)\n {\n if(ps_mv_buf && ps_mv_buf->i4_abs_poc == ps_pic_buf->i4_abs_poc)\n {\n                            ihevc_buf_mgr_release((buf_mgr_t *)ps_codec->pv_mv_buf_mgr, j, BUF_MGR_REF);\n break;\n }\n                        ps_mv_buf++;\n }\n\n }\n\n }\n\n /* Initialize the reference lists to NULL\n             * This is done to take care of the cases where the first pic is not IDR\n             * but the reference list is not created for the first pic because\n             * pic count is zero leaving the reference list uninitialised  */\n for(r_idx = 0; r_idx < MAX_DPB_SIZE; r_idx++)\n {\n                ps_slice_hdr->as_ref_pic_list0[r_idx].pv_pic_buf = NULL;\n                ps_slice_hdr->as_ref_pic_list0[r_idx].pv_mv_buf = NULL;\n\n                ps_slice_hdr->as_ref_pic_list1[r_idx].pv_pic_buf = NULL;\n                ps_slice_hdr->as_ref_pic_list1[r_idx].pv_mv_buf = NULL;\n }\n\n }\n else\n {\n            ret = ihevcd_ref_list(ps_codec, ps_pps, ps_sps, ps_slice_hdr);\n if ((WORD32)IHEVCD_SUCCESS != ret)\n {\n return ret;\n }\n\n }\n\n }\n\n /* Fill the remaining entries of the reference lists with the nearest POC\n     * This is done to handle cases where there is a corruption in the reference index */\n if(ps_codec->i4_pic_present)\n {\n pic_buf_t *ps_pic_buf_ref;\n mv_buf_t *ps_mv_buf_ref;\n        WORD32 r_idx;\n dpb_mgr_t *ps_dpb_mgr = (dpb_mgr_t *)ps_codec->pv_dpb_mgr;\n buf_mgr_t *ps_mv_buf_mgr = (buf_mgr_t *)ps_codec->pv_mv_buf_mgr;\n\n        ps_pic_buf_ref = ihevc_dpb_mgr_get_ref_by_nearest_poc(ps_dpb_mgr, ps_slice_hdr->i4_abs_pic_order_cnt);\n if(NULL == ps_pic_buf_ref)\n {\n            ps_pic_buf_ref = ps_codec->as_process[0].ps_cur_pic;\n            ps_mv_buf_ref = ps_codec->s_parse.ps_cur_mv_buf;\n }\n else\n {\n            ps_mv_buf_ref = ihevcd_mv_mgr_get_poc(ps_mv_buf_mgr, ps_pic_buf_ref->i4_abs_poc);\n }\n\n for(r_idx = 0; r_idx < ps_slice_hdr->i1_num_ref_idx_l0_active; r_idx++)\n {\n if(NULL == ps_slice_hdr->as_ref_pic_list0[r_idx].pv_pic_buf)\n {\n                ps_slice_hdr->as_ref_pic_list0[r_idx].pv_pic_buf = (void *)ps_pic_buf_ref;\n                ps_slice_hdr->as_ref_pic_list0[r_idx].pv_mv_buf = (void *)ps_mv_buf_ref;\n }\n }\n\n for(r_idx = ps_slice_hdr->i1_num_ref_idx_l0_active; r_idx < MAX_DPB_SIZE; r_idx++)\n {\n            ps_slice_hdr->as_ref_pic_list0[r_idx].pv_pic_buf = (void *)ps_pic_buf_ref;\n            ps_slice_hdr->as_ref_pic_list0[r_idx].pv_mv_buf = (void *)ps_mv_buf_ref;\n }\n\n for(r_idx = 0; r_idx < ps_slice_hdr->i1_num_ref_idx_l1_active; r_idx++)\n {\n if(NULL == ps_slice_hdr->as_ref_pic_list1[r_idx].pv_pic_buf)\n {\n                ps_slice_hdr->as_ref_pic_list1[r_idx].pv_pic_buf = (void *)ps_pic_buf_ref;\n                ps_slice_hdr->as_ref_pic_list1[r_idx].pv_mv_buf = (void *)ps_mv_buf_ref;\n }\n }\n\n for(r_idx = ps_slice_hdr->i1_num_ref_idx_l1_active; r_idx < MAX_DPB_SIZE; r_idx++)\n {\n            ps_slice_hdr->as_ref_pic_list1[r_idx].pv_pic_buf = (void *)ps_pic_buf_ref;\n            ps_slice_hdr->as_ref_pic_list1[r_idx].pv_mv_buf = (void *)ps_mv_buf_ref;\n }\n }\n\n /* Update slice address in the header */\n if(!ps_slice_hdr->i1_first_slice_in_pic_flag)\n {\n        ps_slice_hdr->i2_ctb_x = slice_address % ps_sps->i2_pic_wd_in_ctb;\n        ps_slice_hdr->i2_ctb_y = slice_address / ps_sps->i2_pic_wd_in_ctb;\n\n if(!ps_slice_hdr->i1_dependent_slice_flag)\n {\n            ps_slice_hdr->i2_independent_ctb_x = ps_slice_hdr->i2_ctb_x;\n            ps_slice_hdr->i2_independent_ctb_y = ps_slice_hdr->i2_ctb_y;\n }\n }\n else\n {\n        ps_slice_hdr->i2_ctb_x = 0;\n        ps_slice_hdr->i2_ctb_y = 0;\n\n        ps_slice_hdr->i2_independent_ctb_x = 0;\n        ps_slice_hdr->i2_independent_ctb_y = 0;\n }\n\n /* If the first slice in the pic is missing, copy the current slice header to\n     * the first slice's header */\n if((!first_slice_in_pic_flag) &&\n (0 == ps_codec->i4_pic_present))\n {\n\n         slice_header_t *ps_slice_hdr_prev = ps_codec->s_parse.ps_slice_hdr_base;\n         ihevcd_copy_slice_hdr(ps_codec, 0, (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1)));\n \n        prev_slice_incomplete_flag = 1;\n        ASSERT(ps_codec->s_parse.i4_cur_slice_idx == 1);\n \n         ps_slice_hdr_prev->i2_ctb_x = 0;\n         ps_slice_hdr_prev->i2_ctb_y = 0;\n\n        ps_codec->s_parse.i4_ctb_x = 0;\n        ps_codec->s_parse.i4_ctb_y = 0;\n\n        ps_codec->s_parse.i4_cur_slice_idx = 0;\n\n if((ps_slice_hdr->i2_ctb_x == 0) &&\n (ps_slice_hdr->i2_ctb_y == 0))\n {\n            ps_slice_hdr->i2_ctb_x++;\n }\n }\n\n {\n /* If skip B is enabled,\n         * ignore pictures that are non-reference\n         * TODO: (i1_nal_unit_type < NAL_BLA_W_LP) && (i1_nal_unit_type % 2 == 0) only says it is\n         * sub-layer non-reference slice. May need to find a way to detect actual non-reference pictures*/\n\n if((i1_nal_unit_type < NAL_BLA_W_LP) &&\n (i1_nal_unit_type % 2 == 0))\n {\n if(IVD_SKIP_B == ps_codec->e_pic_skip_mode)\n return IHEVCD_IGNORE_SLICE;\n }\n\n /* If skip PB is enabled,\n         * decode only I slices */\n if((IVD_SKIP_PB == ps_codec->e_pic_skip_mode) &&\n (ISLICE != ps_slice_hdr->i1_slice_type))\n {\n return IHEVCD_IGNORE_SLICE;\n\n         }\n     }\n \n    if(prev_slice_incomplete_flag)\n    {\n        ps_codec->i4_slice_error = 1;\n        ps_codec->s_parse.i4_cur_slice_idx--;\n        if(ps_codec->s_parse.i4_cur_slice_idx < 0)\n            ps_codec->s_parse.i4_cur_slice_idx = 0;\n    }\n\n     return ret;\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143938,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "IHEVCD_ERROR_T ihevcd_parse_slice_data(codec_t *ps_codec)\n{\n\n    IHEVCD_ERROR_T ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;\n    WORD32 end_of_slice_flag = 0;\n sps_t *ps_sps;\n pps_t *ps_pps;\n slice_header_t *ps_slice_hdr;\n    WORD32 end_of_pic;\n tile_t *ps_tile, *ps_tile_prev;\n    WORD32 i;\n    WORD32 ctb_addr;\n    WORD32 tile_idx;\n    WORD32 cabac_init_idc;\n    WORD32 ctb_size;\n    WORD32 num_ctb_in_row;\n    WORD32 num_min4x4_in_ctb;\n    WORD32 slice_qp;\n    WORD32 slice_start_ctb_idx;\n    WORD32 tile_start_ctb_idx;\n\n\n    ps_slice_hdr = ps_codec->s_parse.ps_slice_hdr_base;\n    ps_pps = ps_codec->s_parse.ps_pps_base;\n    ps_sps = ps_codec->s_parse.ps_sps_base;\n\n /* Get current slice header, pps and sps */\n    ps_slice_hdr += (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1));\n    ps_pps  += ps_slice_hdr->i1_pps_id;\n    ps_sps  += ps_pps->i1_sps_id;\n\n if(0 != ps_codec->s_parse.i4_cur_slice_idx)\n {\n if(!ps_slice_hdr->i1_dependent_slice_flag)\n {\n            ps_codec->s_parse.i4_cur_independent_slice_idx++;\n if(MAX_SLICE_HDR_CNT == ps_codec->s_parse.i4_cur_independent_slice_idx)\n                ps_codec->s_parse.i4_cur_independent_slice_idx = 0;\n }\n }\n\n\n    ctb_size = 1 << ps_sps->i1_log2_ctb_size;\n    num_min4x4_in_ctb = (ctb_size / 4) * (ctb_size / 4);\n    num_ctb_in_row = ps_sps->i2_pic_wd_in_ctb;\n\n /* Update the parse context */\n if(0 == ps_codec->i4_slice_error)\n {\n        ps_codec->s_parse.i4_ctb_x = ps_slice_hdr->i2_ctb_x;\n        ps_codec->s_parse.i4_ctb_y = ps_slice_hdr->i2_ctb_y;\n }\n    ps_codec->s_parse.ps_pps = ps_pps;\n    ps_codec->s_parse.ps_sps = ps_sps;\n    ps_codec->s_parse.ps_slice_hdr = ps_slice_hdr;\n\n /* Derive Tile positions for the current CTB */\n /* Change this to lookup if required */\n    ihevcd_get_tile_pos(ps_pps, ps_sps, ps_codec->s_parse.i4_ctb_x,\n                        ps_codec->s_parse.i4_ctb_y,\n &ps_codec->s_parse.i4_ctb_tile_x,\n &ps_codec->s_parse.i4_ctb_tile_y,\n &tile_idx);\n    ps_codec->s_parse.ps_tile = ps_pps->ps_tile + tile_idx;\n    ps_codec->s_parse.i4_cur_tile_idx = tile_idx;\n    ps_tile = ps_codec->s_parse.ps_tile;\n if(tile_idx)\n        ps_tile_prev = ps_tile - 1;\n else\n        ps_tile_prev = ps_tile;\n\n /* If the present slice is dependent, then store the previous\n     * independent slices' ctb x and y values for decoding process */\n if(0 == ps_codec->i4_slice_error)\n {\n if(1 == ps_slice_hdr->i1_dependent_slice_flag)\n {\n /*If slice is present at the start of a new tile*/\n if((0 == ps_codec->s_parse.i4_ctb_tile_x) && (0 == ps_codec->s_parse.i4_ctb_tile_y))\n {\n                ps_codec->s_parse.i4_ctb_slice_x = 0;\n                ps_codec->s_parse.i4_ctb_slice_y = 0;\n }\n }\n\n if(!ps_slice_hdr->i1_dependent_slice_flag)\n {\n            ps_codec->s_parse.i4_ctb_slice_x = 0;\n            ps_codec->s_parse.i4_ctb_slice_y = 0;\n }\n }\n\n /* Frame level initializations */\n if((0 == ps_codec->s_parse.i4_ctb_y) &&\n (0 == ps_codec->s_parse.i4_ctb_x))\n {\n        ret = ihevcd_parse_pic_init(ps_codec);\n        RETURN_IF((ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS), ret);\n\n        ps_codec->s_parse.pu4_pic_tu_idx[0] = 0;\n        ps_codec->s_parse.pu4_pic_pu_idx[0] = 0;\n        ps_codec->s_parse.i4_cur_independent_slice_idx = 0;\n        ps_codec->s_parse.i4_ctb_tile_x = 0;\n        ps_codec->s_parse.i4_ctb_tile_y = 0;\n }\n\n {\n /* Updating the poc list of current slice to ps_mv_buf */\n mv_buf_t *ps_mv_buf = ps_codec->s_parse.ps_cur_mv_buf;\n\n if(ps_slice_hdr->i1_num_ref_idx_l1_active != 0)\n {\n for(i = 0; i < ps_slice_hdr->i1_num_ref_idx_l1_active; i++)\n {\n                ps_mv_buf->l1_collocated_poc[(ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1))][i] = ((pic_buf_t *)ps_slice_hdr->as_ref_pic_list1[i].pv_pic_buf)->i4_abs_poc;\n                ps_mv_buf->u1_l1_collocated_poc_lt[(ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1))][i] = ((pic_buf_t *)ps_slice_hdr->as_ref_pic_list1[i].pv_pic_buf)->u1_used_as_ref;\n }\n }\n\n if(ps_slice_hdr->i1_num_ref_idx_l0_active != 0)\n {\n for(i = 0; i < ps_slice_hdr->i1_num_ref_idx_l0_active; i++)\n {\n                ps_mv_buf->l0_collocated_poc[(ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1))][i] = ((pic_buf_t *)ps_slice_hdr->as_ref_pic_list0[i].pv_pic_buf)->i4_abs_poc;\n                ps_mv_buf->u1_l0_collocated_poc_lt[(ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1))][i] = ((pic_buf_t *)ps_slice_hdr->as_ref_pic_list0[i].pv_pic_buf)->u1_used_as_ref;\n }\n }\n }\n\n /*Initialize the low delay flag at the beginning of every slice*/\n if((0 == ps_codec->s_parse.i4_ctb_slice_x) || (0 == ps_codec->s_parse.i4_ctb_slice_y))\n {\n /* Lowdelay flag */\n        WORD32 cur_poc, ref_list_poc, flag = 1;\n        cur_poc = ps_slice_hdr->i4_abs_pic_order_cnt;\n for(i = 0; i < ps_slice_hdr->i1_num_ref_idx_l0_active; i++)\n {\n            ref_list_poc = ((mv_buf_t *)ps_slice_hdr->as_ref_pic_list0[i].pv_mv_buf)->i4_abs_poc;\n if(ref_list_poc > cur_poc)\n {\n                flag = 0;\n break;\n }\n }\n if(flag && (ps_slice_hdr->i1_slice_type == BSLICE))\n {\n for(i = 0; i < ps_slice_hdr->i1_num_ref_idx_l1_active; i++)\n {\n                ref_list_poc = ((mv_buf_t *)ps_slice_hdr->as_ref_pic_list1[i].pv_mv_buf)->i4_abs_poc;\n if(ref_list_poc > cur_poc)\n {\n                    flag = 0;\n break;\n }\n }\n }\n        ps_slice_hdr->i1_low_delay_flag = flag;\n }\n\n /* initialize the cabac init idc based on slice type */\n if(ps_slice_hdr->i1_slice_type == ISLICE)\n {\n        cabac_init_idc = 0;\n }\n else if(ps_slice_hdr->i1_slice_type == PSLICE)\n {\n        cabac_init_idc = ps_slice_hdr->i1_cabac_init_flag ? 2 : 1;\n }\n else\n {\n        cabac_init_idc = ps_slice_hdr->i1_cabac_init_flag ? 1 : 2;\n }\n\n    slice_qp = ps_slice_hdr->i1_slice_qp_delta + ps_pps->i1_pic_init_qp;\n    slice_qp = CLIP3(slice_qp, 0, 51);\n\n /*Update QP value for every indepndent slice or for every dependent slice that begins at the start of a new tile*/\n if((0 == ps_slice_hdr->i1_dependent_slice_flag) ||\n ((1 == ps_slice_hdr->i1_dependent_slice_flag) && ((0 == ps_codec->s_parse.i4_ctb_tile_x) && (0 == ps_codec->s_parse.i4_ctb_tile_y))))\n {\n        ps_codec->s_parse.u4_qp = slice_qp;\n }\n\n /*Cabac init at the beginning of a slice*/\n if((1 == ps_slice_hdr->i1_dependent_slice_flag) && (!((ps_codec->s_parse.i4_ctb_tile_x == 0) && (ps_codec->s_parse.i4_ctb_tile_y == 0))))\n {\n if((0 == ps_pps->i1_entropy_coding_sync_enabled_flag) || (ps_pps->i1_entropy_coding_sync_enabled_flag && (0 != ps_codec->s_parse.i4_ctb_x)))\n {\n            ihevcd_cabac_reset(&ps_codec->s_parse.s_cabac,\n &ps_codec->s_parse.s_bitstrm);\n }\n }\n else if((0 == ps_pps->i1_entropy_coding_sync_enabled_flag) || (ps_pps->i1_entropy_coding_sync_enabled_flag && (0 != ps_codec->s_parse.i4_ctb_x)))\n {\n        ret = ihevcd_cabac_init(&ps_codec->s_parse.s_cabac,\n &ps_codec->s_parse.s_bitstrm,\n                                slice_qp,\n                                cabac_init_idc,\n &gau1_ihevc_cab_ctxts[cabac_init_idc][slice_qp][0]);\n if(ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)\n {\n            ps_codec->i4_slice_error = 1;\n            end_of_slice_flag = 1;\n            ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;\n }\n }\n\n\n do\n {\n\n {\n            WORD32 cur_ctb_idx = ps_codec->s_parse.i4_ctb_x\n + ps_codec->s_parse.i4_ctb_y * (ps_sps->i2_pic_wd_in_ctb);\n if(1 == ps_codec->i4_num_cores && 0 == cur_ctb_idx % RESET_TU_BUF_NCTB)\n {\n                ps_codec->s_parse.ps_tu = ps_codec->s_parse.ps_pic_tu;\n                ps_codec->s_parse.i4_pic_tu_idx = 0;\n }\n }\n\n        end_of_pic = 0;\n /* Section:7.3.7 Coding tree unit syntax */\n /* coding_tree_unit() inlined here */\n /* If number of cores is greater than 1, then add job to the queue */\n /* At the start of ctb row parsing in a tile, queue a job for processing the current tile row */\n        ps_codec->s_parse.i4_ctb_num_pcm_blks = 0;\n\n\n /*At the beginning of each tile-which is not the beginning of a slice, cabac context must be initialized.\n         * Hence, check for the tile beginning here */\n if(((0 == ps_codec->s_parse.i4_ctb_tile_x) && (0 == ps_codec->s_parse.i4_ctb_tile_y))\n && (!((ps_tile->u1_pos_x == 0) && (ps_tile->u1_pos_y == 0)))\n && (!((0 == ps_codec->s_parse.i4_ctb_slice_x) && (0 == ps_codec->s_parse.i4_ctb_slice_y))))\n {\n            slice_qp = ps_slice_hdr->i1_slice_qp_delta + ps_pps->i1_pic_init_qp;\n            slice_qp = CLIP3(slice_qp, 0, 51);\n            ps_codec->s_parse.u4_qp = slice_qp;\n\n            ihevcd_get_tile_pos(ps_pps, ps_sps, ps_codec->s_parse.i4_ctb_x,\n                                ps_codec->s_parse.i4_ctb_y,\n &ps_codec->s_parse.i4_ctb_tile_x,\n &ps_codec->s_parse.i4_ctb_tile_y,\n &tile_idx);\n\n            ps_codec->s_parse.ps_tile = ps_pps->ps_tile + tile_idx;\n            ps_codec->s_parse.i4_cur_tile_idx = tile_idx;\n            ps_tile_prev = ps_tile - 1;\n\n            tile_start_ctb_idx = ps_tile->u1_pos_x\n + ps_tile->u1_pos_y * (ps_sps->i2_pic_wd_in_ctb);\n\n            slice_start_ctb_idx =  ps_slice_hdr->i2_ctb_x\n + ps_slice_hdr->i2_ctb_y * (ps_sps->i2_pic_wd_in_ctb);\n\n /*For slices that span across multiple tiles*/\n if(slice_start_ctb_idx < tile_start_ctb_idx)\n { /* 2 Cases\n             * 1 - slice spans across frame-width- but does not start from 1st column\n             * 2 - Slice spans across multiple tiles anywhere is a frame\n             */\n                ps_codec->s_parse.i4_ctb_slice_y = ps_tile->u1_pos_y - ps_slice_hdr->i2_ctb_y;\n if(!(((ps_slice_hdr->i2_ctb_x + ps_tile_prev->u2_wd) % ps_sps->i2_pic_wd_in_ctb) == ps_tile->u1_pos_x)) //Case 2\n {\n if(ps_slice_hdr->i2_ctb_y <= ps_tile->u1_pos_y)\n {\n if(ps_slice_hdr->i2_ctb_x > ps_tile->u1_pos_x)\n {\n                            ps_codec->s_parse.i4_ctb_slice_y -= 1;\n }\n }\n }\n /*ps_codec->s_parse.i4_ctb_slice_y = ps_tile->u1_pos_y - ps_slice_hdr->i2_ctb_y;\n                if (ps_slice_hdr->i2_ctb_y <= ps_tile->u1_pos_y)\n                {\n                    if (ps_slice_hdr->i2_ctb_x > ps_tile->u1_pos_x )\n                    {\n                        ps_codec->s_parse.i4_ctb_slice_y -= 1 ;\n                    }\n                }*/\n }\n\n if(!ps_slice_hdr->i1_dependent_slice_flag)\n {\n                ret = ihevcd_cabac_init(&ps_codec->s_parse.s_cabac,\n &ps_codec->s_parse.s_bitstrm,\n                                        slice_qp,\n                                        cabac_init_idc,\n &gau1_ihevc_cab_ctxts[cabac_init_idc][slice_qp][0]);\n if(ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)\n {\n                    ps_codec->i4_slice_error = 1;\n                    end_of_slice_flag = 1;\n                    ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;\n }\n\n }\n }\n /* If number of cores is greater than 1, then add job to the queue */\n /* At the start of ctb row parsing in a tile, queue a job for processing the current tile row */\n\n if(0 == ps_codec->s_parse.i4_ctb_tile_x)\n {\n\n if(1 < ps_codec->i4_num_cores)\n {\n proc_job_t s_job;\n                IHEVCD_ERROR_T ret;\n                s_job.i4_cmd    = CMD_PROCESS;\n                s_job.i2_ctb_cnt = (WORD16)ps_tile->u2_wd;\n                s_job.i2_ctb_x = (WORD16)ps_codec->s_parse.i4_ctb_x;\n                s_job.i2_ctb_y = (WORD16)ps_codec->s_parse.i4_ctb_y;\n                s_job.i2_slice_idx = (WORD16)ps_codec->s_parse.i4_cur_slice_idx;\n                s_job.i4_tu_coeff_data_ofst = (UWORD8 *)ps_codec->s_parse.pv_tu_coeff_data -\n (UWORD8 *)ps_codec->s_parse.pv_pic_tu_coeff_data;\n                ret = ihevcd_jobq_queue((jobq_t *)ps_codec->s_parse.pv_proc_jobq, &s_job, sizeof(proc_job_t), 1);\n\n if(ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)\n return ret;\n }\n else\n {\n process_ctxt_t *ps_proc = &ps_codec->as_process[0];\n                WORD32 tu_coeff_data_ofst = (UWORD8 *)ps_codec->s_parse.pv_tu_coeff_data -\n (UWORD8 *)ps_codec->s_parse.pv_pic_tu_coeff_data;\n\n /* If the codec is running in single core mode,\n                 * initialize zeroth process context\n                 * TODO: Dual core mode might need a different implementation instead of jobq\n                 */\n\n                ps_proc->i4_ctb_cnt = ps_tile->u2_wd;\n                ps_proc->i4_ctb_x   = ps_codec->s_parse.i4_ctb_x;\n                ps_proc->i4_ctb_y   = ps_codec->s_parse.i4_ctb_y;\n                ps_proc->i4_cur_slice_idx = ps_codec->s_parse.i4_cur_slice_idx;\n\n                ihevcd_init_proc_ctxt(ps_proc, tu_coeff_data_ofst);\n }\n }\n\n\n /* Restore cabac context model from top right CTB if entropy sync is enabled */\n if(ps_pps->i1_entropy_coding_sync_enabled_flag)\n {\n /*TODO Handle single CTB and top-right belonging to a different slice */\n if(0 == ps_codec->s_parse.i4_ctb_x)\n {\n                WORD32 default_ctxt = 0;\n\n if((0 == ps_codec->s_parse.i4_ctb_slice_y) && (!ps_slice_hdr->i1_dependent_slice_flag))\n                    default_ctxt = 1;\n if(1 == ps_sps->i2_pic_wd_in_ctb)\n                    default_ctxt = 1;\n\n                ps_codec->s_parse.u4_qp = slice_qp;\n if(default_ctxt)\n {\n                    ret = ihevcd_cabac_init(&ps_codec->s_parse.s_cabac,\n &ps_codec->s_parse.s_bitstrm,\n                                            slice_qp,\n                                            cabac_init_idc,\n &gau1_ihevc_cab_ctxts[cabac_init_idc][slice_qp][0]);\n\n if(ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)\n {\n                        ps_codec->i4_slice_error = 1;\n                        end_of_slice_flag = 1;\n                        ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;\n }\n }\n else\n {\n                    ret = ihevcd_cabac_init(&ps_codec->s_parse.s_cabac,\n &ps_codec->s_parse.s_bitstrm,\n                                            slice_qp,\n                                            cabac_init_idc,\n (const UWORD8 *)&ps_codec->s_parse.s_cabac.au1_ctxt_models_sync);\n\n if(ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)\n {\n                        ps_codec->i4_slice_error = 1;\n                        end_of_slice_flag = 1;\n                        ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;\n }\n }\n }\n }\n\n\n\n if(0 == ps_codec->i4_slice_error)\n {\n if(ps_slice_hdr->i1_slice_sao_luma_flag || ps_slice_hdr->i1_slice_sao_chroma_flag)\n                ihevcd_parse_sao(ps_codec);\n }\n else\n {\n sao_t *ps_sao = ps_codec->s_parse.ps_pic_sao +\n                            ps_codec->s_parse.i4_ctb_x +\n                            ps_codec->s_parse.i4_ctb_y * ps_sps->i2_pic_wd_in_ctb;\n\n /* Default values */\n            ps_sao->b3_y_type_idx = 0;\n            ps_sao->b3_cb_type_idx = 0;\n            ps_sao->b3_cr_type_idx = 0;\n }\n\n\n {\n            WORD32 ctb_indx;\n            ctb_indx = ps_codec->s_parse.i4_ctb_x + ps_sps->i2_pic_wd_in_ctb * ps_codec->s_parse.i4_ctb_y;\n            ps_codec->s_parse.s_bs_ctxt.pu1_pic_qp_const_in_ctb[ctb_indx >> 3] |= (1 << (ctb_indx & 7));\n {\n                UWORD16 *pu1_slice_idx = ps_codec->s_parse.pu1_slice_idx;\n                pu1_slice_idx[ctb_indx] = ps_codec->s_parse.i4_cur_independent_slice_idx;\n }\n }\n\n if(0 == ps_codec->i4_slice_error)\n {\n tu_t *ps_tu = ps_codec->s_parse.ps_tu;\n            WORD32 i4_tu_cnt = ps_codec->s_parse.s_cu.i4_tu_cnt;\n            WORD32 i4_pic_tu_idx = ps_codec->s_parse.i4_pic_tu_idx;\n\n pu_t *ps_pu = ps_codec->s_parse.ps_pu;\n            WORD32 i4_pic_pu_idx = ps_codec->s_parse.i4_pic_pu_idx;\n\n            UWORD8 *pu1_tu_coeff_data = (UWORD8 *)ps_codec->s_parse.pv_tu_coeff_data;\n\n            ret = ihevcd_parse_coding_quadtree(ps_codec,\n (ps_codec->s_parse.i4_ctb_x << ps_sps->i1_log2_ctb_size),\n (ps_codec->s_parse.i4_ctb_y << ps_sps->i1_log2_ctb_size),\n                                               ps_sps->i1_log2_ctb_size,\n 0);\n /* Check for error */\n\n             if (ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)\n             {\n                 /* Reset tu and pu parameters, and signal current ctb as skip */\n                WORD32 pu_skip_wd, pu_skip_ht;\n                WORD32 rows_remaining, cols_remaining;\n                 WORD32 tu_coeff_data_reset_size;\n \n                /* Set pu wd and ht based on whether the ctb is complete or not */\n                rows_remaining = ps_sps->i2_pic_height_in_luma_samples\n                                - (ps_codec->s_parse.i4_ctb_y << ps_sps->i1_log2_ctb_size);\n                pu_skip_ht = MIN(ctb_size, rows_remaining);\n                cols_remaining = ps_sps->i2_pic_width_in_luma_samples\n                                - (ps_codec->s_parse.i4_ctb_x << ps_sps->i1_log2_ctb_size);\n                pu_skip_wd = MIN(ctb_size, cols_remaining);\n                 ps_codec->s_parse.ps_tu = ps_tu;\n                 ps_codec->s_parse.s_cu.i4_tu_cnt = i4_tu_cnt;\n                 ps_codec->s_parse.i4_pic_tu_idx = i4_pic_tu_idx;\n\n\n                 ps_codec->s_parse.ps_pu = ps_pu;\n                 ps_codec->s_parse.i4_pic_pu_idx = i4_pic_pu_idx;\n \n                ps_tu->b1_cb_cbf = 0;\n                ps_tu->b1_cr_cbf = 0;\n                ps_tu->b1_y_cbf = 0;\n                ps_tu->b4_pos_x = 0;\n                ps_tu->b4_pos_y = 0;\n                ps_tu->b1_transquant_bypass = 0;\n                ps_tu->b3_size = (ps_sps->i1_log2_ctb_size - 2);\n                ps_tu->b7_qp = ps_codec->s_parse.u4_qp;\n                ps_tu->b3_chroma_intra_mode_idx = INTRA_PRED_CHROMA_IDX_NONE;\n                ps_tu->b6_luma_intra_mode   = INTRA_PRED_NONE;\n                ps_tu->b1_first_tu_in_cu = 1;\n                 tu_coeff_data_reset_size = (UWORD8 *)ps_codec->s_parse.pv_tu_coeff_data - pu1_tu_coeff_data;\n                 memset(pu1_tu_coeff_data, 0, tu_coeff_data_reset_size);\n                 ps_codec->s_parse.pv_tu_coeff_data = (void *)pu1_tu_coeff_data;\n \n                ps_codec->s_parse.ps_tu++;\n                ps_codec->s_parse.s_cu.i4_tu_cnt++;\n                ps_codec->s_parse.i4_pic_tu_idx++;\n                ps_codec->s_parse.s_cu.i4_pred_mode = PRED_MODE_SKIP;\n                ps_codec->s_parse.s_cu.i4_part_mode = PART_2Nx2N;\n                ps_pu->b2_part_idx = 0;\n                ps_pu->b4_pos_x = 0;\n                ps_pu->b4_pos_y = 0;\n                ps_pu->b4_wd = (pu_skip_wd >> 2) - 1;\n                ps_pu->b4_ht = (pu_skip_ht >> 2) - 1;\n                ps_pu->b1_intra_flag = 0;\n                ps_pu->b3_part_mode = ps_codec->s_parse.s_cu.i4_part_mode;\n                ps_pu->b1_merge_flag = 1;\n                ps_pu->b3_merge_idx = 0;\n                ps_codec->s_parse.ps_pu++;\n                ps_codec->s_parse.i4_pic_pu_idx++;\n \n                 /* Set slice error to suppress further parsing and\n                  * signal end of slice.\n                 */\n                ps_codec->i4_slice_error = 1;\n                end_of_slice_flag = 1;\n                ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;\n }\n\n         }\n         else\n         {\n            tu_t *ps_tu = ps_codec->s_parse.ps_tu;\n            pu_t *ps_pu = ps_codec->s_parse.ps_pu;\n            WORD32 pu_skip_wd, pu_skip_ht;\n            WORD32 rows_remaining, cols_remaining;\n            /* Set pu wd and ht based on whether the ctb is complete or not */\n            rows_remaining = ps_sps->i2_pic_height_in_luma_samples\n                            - (ps_codec->s_parse.i4_ctb_y << ps_sps->i1_log2_ctb_size);\n            pu_skip_ht = MIN(ctb_size, rows_remaining);\n            cols_remaining = ps_sps->i2_pic_width_in_luma_samples\n                            - (ps_codec->s_parse.i4_ctb_x << ps_sps->i1_log2_ctb_size);\n            pu_skip_wd = MIN(ctb_size, cols_remaining);\n            ps_tu->b1_cb_cbf = 0;\n            ps_tu->b1_cr_cbf = 0;\n            ps_tu->b1_y_cbf = 0;\n            ps_tu->b4_pos_x = 0;\n            ps_tu->b4_pos_y = 0;\n            ps_tu->b1_transquant_bypass = 0;\n            ps_tu->b3_size = (ps_sps->i1_log2_ctb_size - 2);\n            ps_tu->b7_qp = ps_codec->s_parse.u4_qp;\n            ps_tu->b3_chroma_intra_mode_idx = INTRA_PRED_CHROMA_IDX_NONE;\n            ps_tu->b6_luma_intra_mode   = INTRA_PRED_NONE;\n            ps_tu->b1_first_tu_in_cu = 1;\n            ps_codec->s_parse.ps_tu++;\n            ps_codec->s_parse.s_cu.i4_tu_cnt++;\n            ps_codec->s_parse.i4_pic_tu_idx++;\n            ps_codec->s_parse.s_cu.i4_pred_mode = PRED_MODE_SKIP;\n            ps_codec->s_parse.s_cu.i4_part_mode = PART_2Nx2N;\n            ps_pu->b2_part_idx = 0;\n            ps_pu->b4_pos_x = 0;\n            ps_pu->b4_pos_y = 0;\n            ps_pu->b4_wd = (pu_skip_wd >> 2) - 1;\n            ps_pu->b4_ht = (pu_skip_ht >> 2) - 1;\n            ps_pu->b1_intra_flag = 0;\n            ps_pu->b3_part_mode = ps_codec->s_parse.s_cu.i4_part_mode;\n            ps_pu->b1_merge_flag = 1;\n            ps_pu->b3_merge_idx = 0;\n            ps_codec->s_parse.ps_pu++;\n            ps_codec->s_parse.i4_pic_pu_idx++;\n         }\n \n         if(0 == ps_codec->i4_slice_error)\n            end_of_slice_flag = ihevcd_cabac_decode_terminate(&ps_codec->s_parse.s_cabac, &ps_codec->s_parse.s_bitstrm);\n\n        AEV_TRACE(\"end_of_slice_flag\", end_of_slice_flag, ps_codec->s_parse.s_cabac.u4_range);\n\n\n /* In case of tiles or entropy sync, terminate cabac and copy cabac context backed up at the end of top-right CTB */\n if(ps_pps->i1_tiles_enabled_flag || ps_pps->i1_entropy_coding_sync_enabled_flag)\n {\n            WORD32 end_of_tile = 0;\n            WORD32 end_of_tile_row = 0;\n\n /* Take a back up of cabac context models if entropy sync is enabled */\n if(ps_pps->i1_entropy_coding_sync_enabled_flag || ps_pps->i1_tiles_enabled_flag)\n {\n if(1 == ps_codec->s_parse.i4_ctb_x)\n {\n                    WORD32 size = sizeof(ps_codec->s_parse.s_cabac.au1_ctxt_models);\n                    memcpy(&ps_codec->s_parse.s_cabac.au1_ctxt_models_sync, &ps_codec->s_parse.s_cabac.au1_ctxt_models, size);\n }\n }\n\n /* Since tiles and entropy sync are not enabled simultaneously, the following will not result in any problems */\n if((ps_codec->s_parse.i4_ctb_tile_x + 1) == (ps_tile->u2_wd))\n {\n                end_of_tile_row = 1;\n if((ps_codec->s_parse.i4_ctb_tile_y + 1) == ps_tile->u2_ht)\n                    end_of_tile = 1;\n }\n if((0 == end_of_slice_flag) &&\n ((ps_pps->i1_tiles_enabled_flag && end_of_tile) ||\n (ps_pps->i1_entropy_coding_sync_enabled_flag && end_of_tile_row)))\n {\n                WORD32 end_of_sub_stream_one_bit;\n                end_of_sub_stream_one_bit = ihevcd_cabac_decode_terminate(&ps_codec->s_parse.s_cabac, &ps_codec->s_parse.s_bitstrm);\n                AEV_TRACE(\"end_of_sub_stream_one_bit\", end_of_sub_stream_one_bit, ps_codec->s_parse.s_cabac.u4_range);\n\n /* TODO: Remove the check for offset when HM is updated to include a byte unconditionally even for aligned location */\n /* For Ittiam streams this check should not be there, for HM9.1 streams this should be there */\n if(ps_codec->s_parse.s_bitstrm.u4_bit_ofst % 8)\n                    ihevcd_bits_flush_to_byte_boundary(&ps_codec->s_parse.s_bitstrm);\n\n                UNUSED(end_of_sub_stream_one_bit);\n }\n }\n {\n            WORD32 ctb_indx;\n\n            ctb_addr = ps_codec->s_parse.i4_ctb_y * num_ctb_in_row + ps_codec->s_parse.i4_ctb_x;\n\n            ctb_indx = ++ctb_addr;\n\n /* Store pu_idx for next CTB in frame level pu_idx array */\n\n if((ps_tile->u2_wd == (ps_codec->s_parse.i4_ctb_tile_x + 1)) && (ps_tile->u2_wd != ps_sps->i2_pic_wd_in_ctb))\n {\n                ctb_indx = (ps_sps->i2_pic_wd_in_ctb * (ps_codec->s_parse.i4_ctb_tile_y + 1 + ps_tile->u1_pos_y)) + ps_tile->u1_pos_x; //idx is the beginning of next row in current tile.\n if(ps_tile->u2_ht == (ps_codec->s_parse.i4_ctb_tile_y + 1))\n {\n if((ps_tile->u2_wd + ps_tile->u1_pos_x == ps_sps->i2_pic_wd_in_ctb) && ((ps_tile->u2_ht + ps_tile->u1_pos_y == ps_sps->i2_pic_ht_in_ctb)))\n {\n                        ctb_indx = ctb_addr; //Next continuous ctb address\n }\n else //Not last tile's end , but a tile end\n {\n tile_t *ps_next_tile = ps_codec->s_parse.ps_tile + 1;\n                        ctb_indx = ps_next_tile->u1_pos_x + (ps_next_tile->u1_pos_y * ps_sps->i2_pic_wd_in_ctb); //idx is the beginning of first row in next tile.\n }\n }\n }\n\n            ps_codec->s_parse.pu4_pic_pu_idx[ctb_indx] = ps_codec->s_parse.i4_pic_pu_idx;\n            ps_codec->s_parse.i4_next_pu_ctb_cnt = ctb_indx;\n\n            ps_codec->s_parse.pu1_pu_map += num_min4x4_in_ctb;\n\n /* Store tu_idx for next CTB in frame level tu_idx array */\n if(1 == ps_codec->i4_num_cores)\n {\n                ctb_indx = (0 == ctb_addr % RESET_TU_BUF_NCTB) ?\n                                RESET_TU_BUF_NCTB : ctb_addr % RESET_TU_BUF_NCTB;\n\n if((ps_tile->u2_wd == (ps_codec->s_parse.i4_ctb_tile_x + 1)) && (ps_tile->u2_wd != ps_sps->i2_pic_wd_in_ctb))\n {\n                    ctb_indx = (ps_sps->i2_pic_wd_in_ctb * (ps_codec->s_parse.i4_ctb_tile_y + 1 + ps_tile->u1_pos_y)) + ps_tile->u1_pos_x; //idx is the beginning of next row in current tile.\n if(ps_tile->u2_ht == (ps_codec->s_parse.i4_ctb_tile_y + 1))\n {\n if((ps_tile->u2_wd + ps_tile->u1_pos_x == ps_sps->i2_pic_wd_in_ctb) && ((ps_tile->u2_ht + ps_tile->u1_pos_y == ps_sps->i2_pic_ht_in_ctb)))\n {\n                            ctb_indx = (0 == ctb_addr % RESET_TU_BUF_NCTB) ?\n                                            RESET_TU_BUF_NCTB : ctb_addr % RESET_TU_BUF_NCTB;\n }\n else //Not last tile's end , but a tile end\n {\n tile_t *ps_next_tile = ps_codec->s_parse.ps_tile + 1;\n                            ctb_indx =  ps_next_tile->u1_pos_x + (ps_next_tile->u1_pos_y * ps_sps->i2_pic_wd_in_ctb); //idx is the beginning of first row in next tile.\n }\n }\n }\n                ps_codec->s_parse.i4_next_tu_ctb_cnt = ctb_indx;\n                ps_codec->s_parse.pu4_pic_tu_idx[ctb_indx] = ps_codec->s_parse.i4_pic_tu_idx;\n }\n else\n {\n                ctb_indx = ctb_addr;\n if((ps_tile->u2_wd == (ps_codec->s_parse.i4_ctb_tile_x + 1)) && (ps_tile->u2_wd != ps_sps->i2_pic_wd_in_ctb))\n {\n                    ctb_indx = (ps_sps->i2_pic_wd_in_ctb * (ps_codec->s_parse.i4_ctb_tile_y + 1 + ps_tile->u1_pos_y)) + ps_tile->u1_pos_x; //idx is the beginning of next row in current tile.\n if(ps_tile->u2_ht == (ps_codec->s_parse.i4_ctb_tile_y + 1))\n {\n if((ps_tile->u2_wd + ps_tile->u1_pos_x == ps_sps->i2_pic_wd_in_ctb) && ((ps_tile->u2_ht + ps_tile->u1_pos_y == ps_sps->i2_pic_ht_in_ctb)))\n {\n                            ctb_indx = ctb_addr;\n }\n else //Not last tile's end , but a tile end\n {\n tile_t *ps_next_tile = ps_codec->s_parse.ps_tile + 1;\n                            ctb_indx =  ps_next_tile->u1_pos_x + (ps_next_tile->u1_pos_y * ps_sps->i2_pic_wd_in_ctb); //idx is the beginning of first row in next tile.\n }\n }\n }\n                ps_codec->s_parse.i4_next_tu_ctb_cnt = ctb_indx;\n                ps_codec->s_parse.pu4_pic_tu_idx[ctb_indx] = ps_codec->s_parse.i4_pic_tu_idx;\n }\n            ps_codec->s_parse.pu1_tu_map += num_min4x4_in_ctb;\n }\n\n\n if(ps_codec->i4_num_cores <= MV_PRED_NUM_CORES_THRESHOLD)\n {\n /*************************************************/\n /****************   MV pred **********************/\n /*************************************************/\n            WORD8 u1_top_ctb_avail = 1;\n            WORD8 u1_left_ctb_avail = 1;\n            WORD8 u1_top_lt_ctb_avail = 1;\n            WORD8 u1_top_rt_ctb_avail = 1;\n            WORD16 i2_wd_in_ctb;\n\n            tile_start_ctb_idx = ps_tile->u1_pos_x\n + ps_tile->u1_pos_y * (ps_sps->i2_pic_wd_in_ctb);\n\n            slice_start_ctb_idx =  ps_slice_hdr->i2_ctb_x\n + ps_slice_hdr->i2_ctb_y * (ps_sps->i2_pic_wd_in_ctb);\n\n if((slice_start_ctb_idx < tile_start_ctb_idx))\n {\n                i2_wd_in_ctb = ps_sps->i2_pic_wd_in_ctb;\n }\n else\n {\n                i2_wd_in_ctb = ps_tile->u2_wd;\n }\n /* slice and tile boundaries */\n if((0 == ps_codec->s_parse.i4_ctb_y) || (0 == ps_codec->s_parse.i4_ctb_tile_y))\n {\n                u1_top_ctb_avail = 0;\n                u1_top_lt_ctb_avail = 0;\n                u1_top_rt_ctb_avail = 0;\n }\n\n if((0 == ps_codec->s_parse.i4_ctb_x) || (0 == ps_codec->s_parse.i4_ctb_tile_x))\n {\n                u1_left_ctb_avail = 0;\n                u1_top_lt_ctb_avail = 0;\n if((0 == ps_codec->s_parse.i4_ctb_slice_y) || (0 == ps_codec->s_parse.i4_ctb_tile_y))\n {\n                    u1_top_ctb_avail = 0;\n if((i2_wd_in_ctb - 1) != ps_codec->s_parse.i4_ctb_slice_x) //TODO: For tile, not implemented\n {\n                        u1_top_rt_ctb_avail = 0;\n }\n }\n }\n /*For slices not beginning at start of a ctb row*/\n else if(ps_codec->s_parse.i4_ctb_x > 0)\n {\n if((0 == ps_codec->s_parse.i4_ctb_slice_y) || (0 == ps_codec->s_parse.i4_ctb_tile_y))\n {\n                    u1_top_ctb_avail = 0;\n                    u1_top_lt_ctb_avail = 0;\n if(0 == ps_codec->s_parse.i4_ctb_slice_x)\n {\n                        u1_left_ctb_avail = 0;\n }\n if((i2_wd_in_ctb - 1) != ps_codec->s_parse.i4_ctb_slice_x)\n {\n                        u1_top_rt_ctb_avail = 0;\n }\n }\n else if((1 == ps_codec->s_parse.i4_ctb_slice_y) && (0 == ps_codec->s_parse.i4_ctb_slice_x))\n {\n                    u1_top_lt_ctb_avail = 0;\n }\n }\n\n if(((ps_sps->i2_pic_wd_in_ctb - 1) == ps_codec->s_parse.i4_ctb_x) || ((ps_tile->u2_wd - 1) == ps_codec->s_parse.i4_ctb_tile_x))\n {\n                u1_top_rt_ctb_avail = 0;\n }\n\n if(PSLICE == ps_slice_hdr->i1_slice_type\n || BSLICE == ps_slice_hdr->i1_slice_type)\n {\n mv_ctxt_t s_mv_ctxt;\n process_ctxt_t *ps_proc;\n                UWORD32 *pu4_ctb_top_pu_idx;\n                UWORD32 *pu4_ctb_left_pu_idx;\n                UWORD32 *pu4_ctb_top_left_pu_idx;\n                WORD32 i4_ctb_pu_cnt;\n                WORD32 cur_ctb_idx;\n                WORD32 next_ctb_idx;\n                WORD32 cur_pu_idx;\n                ps_proc = &ps_codec->as_process[(ps_codec->i4_num_cores == 1) ? 1 : (ps_codec->i4_num_cores - 1)];\n                cur_ctb_idx = ps_codec->s_parse.i4_ctb_x\n + ps_codec->s_parse.i4_ctb_y * (ps_sps->i2_pic_wd_in_ctb);\n                next_ctb_idx = ps_codec->s_parse.i4_next_pu_ctb_cnt;\n                i4_ctb_pu_cnt = ps_codec->s_parse.pu4_pic_pu_idx[next_ctb_idx]\n - ps_codec->s_parse.pu4_pic_pu_idx[cur_ctb_idx];\n\n                cur_pu_idx = ps_codec->s_parse.pu4_pic_pu_idx[cur_ctb_idx];\n\n                pu4_ctb_top_pu_idx = ps_proc->pu4_pic_pu_idx_top\n + (ps_codec->s_parse.i4_ctb_x * ctb_size / MIN_PU_SIZE);\n                pu4_ctb_left_pu_idx = ps_proc->pu4_pic_pu_idx_left;\n                pu4_ctb_top_left_pu_idx = &ps_proc->u4_ctb_top_left_pu_idx;\n\n /* Initializing s_mv_ctxt */\n {\n                    s_mv_ctxt.ps_pps = ps_pps;\n                    s_mv_ctxt.ps_sps = ps_sps;\n                    s_mv_ctxt.ps_slice_hdr = ps_slice_hdr;\n                    s_mv_ctxt.i4_ctb_x = ps_codec->s_parse.i4_ctb_x;\n                    s_mv_ctxt.i4_ctb_y = ps_codec->s_parse.i4_ctb_y;\n                    s_mv_ctxt.ps_pu = &ps_codec->s_parse.ps_pic_pu[cur_pu_idx];\n                    s_mv_ctxt.ps_pic_pu = ps_codec->s_parse.ps_pic_pu;\n                    s_mv_ctxt.ps_tile = ps_tile;\n                    s_mv_ctxt.pu4_pic_pu_idx_map = ps_proc->pu4_pic_pu_idx_map;\n                    s_mv_ctxt.pu4_pic_pu_idx = ps_codec->s_parse.pu4_pic_pu_idx;\n                    s_mv_ctxt.pu1_pic_pu_map = ps_codec->s_parse.pu1_pic_pu_map;\n                    s_mv_ctxt.i4_ctb_pu_cnt = i4_ctb_pu_cnt;\n                    s_mv_ctxt.i4_ctb_start_pu_idx = cur_pu_idx;\n                    s_mv_ctxt.u1_top_ctb_avail = u1_top_ctb_avail;\n                    s_mv_ctxt.u1_top_rt_ctb_avail = u1_top_rt_ctb_avail;\n                    s_mv_ctxt.u1_top_lt_ctb_avail = u1_top_lt_ctb_avail;\n                    s_mv_ctxt.u1_left_ctb_avail = u1_left_ctb_avail;\n }\n\n                ihevcd_get_mv_ctb(&s_mv_ctxt, pu4_ctb_top_pu_idx,\n                                  pu4_ctb_left_pu_idx, pu4_ctb_top_left_pu_idx);\n\n }\n else\n {\n                WORD32 num_minpu_in_ctb = (ctb_size / MIN_PU_SIZE) * (ctb_size / MIN_PU_SIZE);\n                UWORD8 *pu1_pic_pu_map_ctb = ps_codec->s_parse.pu1_pic_pu_map +\n (ps_codec->s_parse.i4_ctb_x + ps_codec->s_parse.i4_ctb_y * ps_sps->i2_pic_wd_in_ctb) * num_minpu_in_ctb;\n process_ctxt_t *ps_proc = &ps_codec->as_process[(ps_codec->i4_num_cores == 1) ? 1 : (ps_codec->i4_num_cores - 1)];\n                WORD32 row, col;\n                WORD32 pu_cnt;\n                WORD32 num_pu_per_ctb;\n                WORD32 cur_ctb_idx;\n                WORD32 next_ctb_idx;\n                WORD32 ctb_start_pu_idx;\n                UWORD32 *pu4_nbr_pu_idx = ps_proc->pu4_pic_pu_idx_map;\n                WORD32 nbr_pu_idx_strd = MAX_CTB_SIZE / MIN_PU_SIZE + 2;\n pu_t *ps_pu;\n\n for(row = 0; row < ctb_size / MIN_PU_SIZE; row++)\n {\n for(col = 0; col < ctb_size / MIN_PU_SIZE; col++)\n {\n                        pu1_pic_pu_map_ctb[row * ctb_size / MIN_PU_SIZE + col] = 0;\n }\n }\n\n\n /* Neighbor PU idx update inside CTB */\n /* 1byte per 4x4. Indicates the PU idx that 4x4 block belongs to */\n\n                cur_ctb_idx = ps_codec->s_parse.i4_ctb_x\n + ps_codec->s_parse.i4_ctb_y * (ps_sps->i2_pic_wd_in_ctb);\n                next_ctb_idx = ps_codec->s_parse.i4_next_pu_ctb_cnt;\n                num_pu_per_ctb = ps_codec->s_parse.pu4_pic_pu_idx[next_ctb_idx]\n - ps_codec->s_parse.pu4_pic_pu_idx[cur_ctb_idx];\n                ctb_start_pu_idx = ps_codec->s_parse.pu4_pic_pu_idx[cur_ctb_idx];\n                ps_pu = &ps_codec->s_parse.ps_pic_pu[ctb_start_pu_idx];\n\n for(pu_cnt = 0; pu_cnt < num_pu_per_ctb; pu_cnt++, ps_pu++)\n {\n                    UWORD32 cur_pu_idx;\n                    WORD32 pu_ht = (ps_pu->b4_ht + 1) << 2;\n                    WORD32 pu_wd = (ps_pu->b4_wd + 1) << 2;\n\n                    cur_pu_idx = ctb_start_pu_idx + pu_cnt;\n\n for(row = 0; row < pu_ht / MIN_PU_SIZE; row++)\n for(col = 0; col < pu_wd / MIN_PU_SIZE; col++)\n                            pu4_nbr_pu_idx[(1 + ps_pu->b4_pos_x + col)\n + (1 + ps_pu->b4_pos_y + row)\n * nbr_pu_idx_strd] =\n                                            cur_pu_idx;\n }\n\n /* Updating Top and Left pointers */\n {\n                    WORD32 rows_remaining = ps_sps->i2_pic_height_in_luma_samples\n - (ps_codec->s_parse.i4_ctb_y << ps_sps->i1_log2_ctb_size);\n                    WORD32 ctb_size_left = MIN(ctb_size, rows_remaining);\n\n /* Top Left */\n /* saving top left before updating top ptr, as updating top ptr will overwrite the top left for the next ctb */\n                    ps_proc->u4_ctb_top_left_pu_idx = ps_proc->pu4_pic_pu_idx_top[(ps_codec->s_parse.i4_ctb_x * ctb_size / MIN_PU_SIZE) + ctb_size / MIN_PU_SIZE - 1];\n for(i = 0; i < ctb_size / MIN_PU_SIZE; i++)\n {\n /* Left */\n /* Last column of au4_nbr_pu_idx */\n                        ps_proc->pu4_pic_pu_idx_left[i] = pu4_nbr_pu_idx[(ctb_size / MIN_PU_SIZE)\n + (i + 1) * nbr_pu_idx_strd];\n /* Top */\n /* Last row of au4_nbr_pu_idx */\n                        ps_proc->pu4_pic_pu_idx_top[(ps_codec->s_parse.i4_ctb_x * ctb_size / MIN_PU_SIZE) + i] =\n                                        pu4_nbr_pu_idx[(ctb_size_left / MIN_PU_SIZE) * nbr_pu_idx_strd + i + 1];\n\n }\n }\n }\n\n /*************************************************/\n /******************  BS, QP  *********************/\n /*************************************************/\n /* Check if deblock is disabled for the current slice or if it is disabled for the current picture\n             * because of disable deblock api\n             */\n if(0 == ps_codec->i4_disable_deblk_pic)\n {\n if((0 == ps_slice_hdr->i1_slice_disable_deblocking_filter_flag) &&\n (0 == ps_codec->i4_slice_error))\n {\n                    WORD32 i4_ctb_tu_cnt;\n                    WORD32 cur_ctb_idx, next_ctb_idx;\n                    WORD32 cur_pu_idx;\n                    WORD32 cur_tu_idx;\n process_ctxt_t *ps_proc;\n\n                    ps_proc = &ps_codec->as_process[(ps_codec->i4_num_cores == 1) ? 1 : (ps_codec->i4_num_cores - 1)];\n                    cur_ctb_idx = ps_codec->s_parse.i4_ctb_x\n + ps_codec->s_parse.i4_ctb_y * (ps_sps->i2_pic_wd_in_ctb);\n\n                    cur_pu_idx = ps_codec->s_parse.pu4_pic_pu_idx[cur_ctb_idx];\n                    next_ctb_idx = ps_codec->s_parse.i4_next_tu_ctb_cnt;\n if(1 == ps_codec->i4_num_cores)\n {\n                        i4_ctb_tu_cnt = ps_codec->s_parse.pu4_pic_tu_idx[next_ctb_idx] -\n                                        ps_codec->s_parse.pu4_pic_tu_idx[cur_ctb_idx % RESET_TU_BUF_NCTB];\n\n                        cur_tu_idx = ps_codec->s_parse.pu4_pic_tu_idx[cur_ctb_idx % RESET_TU_BUF_NCTB];\n }\n else\n {\n                        i4_ctb_tu_cnt = ps_codec->s_parse.pu4_pic_tu_idx[next_ctb_idx] -\n                                        ps_codec->s_parse.pu4_pic_tu_idx[cur_ctb_idx];\n\n                        cur_tu_idx = ps_codec->s_parse.pu4_pic_tu_idx[cur_ctb_idx];\n }\n\n                    ps_codec->s_parse.s_bs_ctxt.ps_pps = ps_codec->s_parse.ps_pps;\n                    ps_codec->s_parse.s_bs_ctxt.ps_sps = ps_codec->s_parse.ps_sps;\n                    ps_codec->s_parse.s_bs_ctxt.ps_codec = ps_codec;\n                    ps_codec->s_parse.s_bs_ctxt.i4_ctb_tu_cnt = i4_ctb_tu_cnt;\n                    ps_codec->s_parse.s_bs_ctxt.i4_ctb_x = ps_codec->s_parse.i4_ctb_x;\n                    ps_codec->s_parse.s_bs_ctxt.i4_ctb_y = ps_codec->s_parse.i4_ctb_y;\n                    ps_codec->s_parse.s_bs_ctxt.i4_ctb_tile_x = ps_codec->s_parse.i4_ctb_tile_x;\n                    ps_codec->s_parse.s_bs_ctxt.i4_ctb_tile_y = ps_codec->s_parse.i4_ctb_tile_y;\n                    ps_codec->s_parse.s_bs_ctxt.i4_ctb_slice_x = ps_codec->s_parse.i4_ctb_slice_x;\n                    ps_codec->s_parse.s_bs_ctxt.i4_ctb_slice_y = ps_codec->s_parse.i4_ctb_slice_y;\n                    ps_codec->s_parse.s_bs_ctxt.ps_tu = &ps_codec->s_parse.ps_pic_tu[cur_tu_idx];\n                    ps_codec->s_parse.s_bs_ctxt.ps_pu = &ps_codec->s_parse.ps_pic_pu[cur_pu_idx];\n                    ps_codec->s_parse.s_bs_ctxt.pu4_pic_pu_idx_map = ps_proc->pu4_pic_pu_idx_map;\n                    ps_codec->s_parse.s_bs_ctxt.i4_next_pu_ctb_cnt = ps_codec->s_parse.i4_next_pu_ctb_cnt;\n                    ps_codec->s_parse.s_bs_ctxt.i4_next_tu_ctb_cnt = ps_codec->s_parse.i4_next_tu_ctb_cnt;\n                    ps_codec->s_parse.s_bs_ctxt.pu1_slice_idx = ps_codec->s_parse.pu1_slice_idx;\n                    ps_codec->s_parse.s_bs_ctxt.ps_slice_hdr = ps_codec->s_parse.ps_slice_hdr;\n                    ps_codec->s_parse.s_bs_ctxt.ps_tile = ps_codec->s_parse.ps_tile;\n\n if(ISLICE == ps_slice_hdr->i1_slice_type)\n {\n                        ihevcd_ctb_boundary_strength_islice(&ps_codec->s_parse.s_bs_ctxt);\n }\n else\n {\n                        ihevcd_ctb_boundary_strength_pbslice(&ps_codec->s_parse.s_bs_ctxt);\n }\n }\n else\n {\n                    WORD32 bs_strd = (ps_sps->i2_pic_wd_in_ctb + 1) * (ctb_size * ctb_size / 8 / 16);\n\n                    UWORD32 *pu4_vert_bs = (UWORD32 *)((UWORD8 *)ps_codec->s_parse.s_bs_ctxt.pu4_pic_vert_bs +\n                                    ps_codec->s_parse.i4_ctb_x * (ctb_size * ctb_size / 8 / 16) +\n                                    ps_codec->s_parse.i4_ctb_y * bs_strd);\n                    UWORD32 *pu4_horz_bs = (UWORD32 *)((UWORD8 *)ps_codec->s_parse.s_bs_ctxt.pu4_pic_horz_bs +\n                                    ps_codec->s_parse.i4_ctb_x * (ctb_size * ctb_size / 8 / 16) +\n                                    ps_codec->s_parse.i4_ctb_y * bs_strd);\n\n                    memset(pu4_vert_bs, 0, (ctb_size / 8 + 1) * (ctb_size / 4) / 8 * 2);\n                    memset(pu4_horz_bs, 0, (ctb_size / 8) * (ctb_size / 4) / 8 * 2);\n\n }\n }\n\n }\n\n\n /* Update the parse status map */\n {\n sps_t *ps_sps = ps_codec->s_parse.ps_sps;\n            UWORD8 *pu1_buf;\n            WORD32 idx;\n            idx = (ps_codec->s_parse.i4_ctb_x);\n            idx += ((ps_codec->s_parse.i4_ctb_y) * ps_sps->i2_pic_wd_in_ctb);\n            pu1_buf = (ps_codec->pu1_parse_map + idx);\n *pu1_buf = 1;\n }\n\n /* Increment CTB x and y positions */\n        ps_codec->s_parse.i4_ctb_tile_x++;\n        ps_codec->s_parse.i4_ctb_x++;\n        ps_codec->s_parse.i4_ctb_slice_x++;\n\n /*If tiles are enabled, handle the slice counters differently*/\n if(ps_pps->i1_tiles_enabled_flag)\n {\n            tile_start_ctb_idx = ps_tile->u1_pos_x\n + ps_tile->u1_pos_y * (ps_sps->i2_pic_wd_in_ctb);\n\n            slice_start_ctb_idx =  ps_slice_hdr->i2_ctb_x\n + ps_slice_hdr->i2_ctb_y * (ps_sps->i2_pic_wd_in_ctb);\n\n if((slice_start_ctb_idx < tile_start_ctb_idx))\n {\n if(ps_codec->s_parse.i4_ctb_slice_x == (ps_tile->u1_pos_x + ps_tile->u2_wd))\n {\n /* Reached end of slice row within a tile /frame */\n                    ps_codec->s_parse.i4_ctb_slice_y++;\n                    ps_codec->s_parse.i4_ctb_slice_x = ps_tile->u1_pos_x; //todo:Check\n }\n }\n else if(ps_codec->s_parse.i4_ctb_slice_x == (ps_tile->u2_wd))\n {\n                ps_codec->s_parse.i4_ctb_slice_y++;\n                ps_codec->s_parse.i4_ctb_slice_x = 0;\n }\n }\n else\n {\n if(ps_codec->s_parse.i4_ctb_slice_x == ps_tile->u2_wd)\n {\n /* Reached end of slice row within a tile /frame */\n                ps_codec->s_parse.i4_ctb_slice_y++;\n                ps_codec->s_parse.i4_ctb_slice_x = 0;\n }\n }\n\n\n if(ps_codec->s_parse.i4_ctb_tile_x == (ps_tile->u2_wd))\n {\n /* Reached end of tile row */\n            ps_codec->s_parse.i4_ctb_tile_x = 0;\n            ps_codec->s_parse.i4_ctb_x = ps_tile->u1_pos_x;\n\n            ps_codec->s_parse.i4_ctb_tile_y++;\n            ps_codec->s_parse.i4_ctb_y++;\n\n if(ps_codec->s_parse.i4_ctb_tile_y == (ps_tile->u2_ht))\n {\n /* Reached End of Tile */\n                ps_codec->s_parse.i4_ctb_tile_y = 0;\n                ps_codec->s_parse.i4_ctb_tile_x = 0;\n                ps_codec->s_parse.ps_tile++;\n\n if((ps_tile->u2_ht + ps_tile->u1_pos_y  ==  ps_sps->i2_pic_ht_in_ctb) && (ps_tile->u2_wd + ps_tile->u1_pos_x  ==  ps_sps->i2_pic_wd_in_ctb))\n {\n /* Reached end of frame */\n                    end_of_pic = 1;\n                    ps_codec->s_parse.i4_ctb_x = 0;\n                    ps_codec->s_parse.i4_ctb_y = ps_sps->i2_pic_ht_in_ctb;\n }\n else\n {\n /* Initialize ctb_x and ctb_y to start of next tile */\n                    ps_tile = ps_codec->s_parse.ps_tile;\n                    ps_codec->s_parse.i4_ctb_x = ps_tile->u1_pos_x;\n                    ps_codec->s_parse.i4_ctb_y = ps_tile->u1_pos_y;\n                    ps_codec->s_parse.i4_ctb_tile_y = 0;\n                    ps_codec->s_parse.i4_ctb_tile_x = 0;\n                    ps_codec->s_parse.i4_ctb_slice_x = ps_tile->u1_pos_x;\n                    ps_codec->s_parse.i4_ctb_slice_y = ps_tile->u1_pos_y;\n\n }\n }\n\n }\n\n        ps_codec->s_parse.i4_next_ctb_indx = ps_codec->s_parse.i4_ctb_x +\n                        ps_codec->s_parse.i4_ctb_y * ps_sps->i2_pic_wd_in_ctb;\n\n /* If the current slice is in error, check if the next slice's address\n         * is reached and mark the end_of_slice flag */\n if(ps_codec->i4_slice_error)\n {\n slice_header_t *ps_slice_hdr_next = ps_slice_hdr + 1;\n            WORD32 next_slice_addr = ps_slice_hdr_next->i2_ctb_x +\n                            ps_slice_hdr_next->i2_ctb_y * ps_sps->i2_pic_wd_in_ctb;\n\n if(ps_codec->s_parse.i4_next_ctb_indx == next_slice_addr)\n                end_of_slice_flag = 1;\n }\n\n /* If the codec is running in single core mode\n         * then call process function for current CTB\n         */\n if((1 == ps_codec->i4_num_cores) && (ps_codec->s_parse.i4_ctb_tile_x == 0))\n {\n process_ctxt_t *ps_proc = &ps_codec->as_process[0];\n            ps_proc->i4_ctb_cnt = ps_proc->ps_tile->u2_wd;\n            ihevcd_process(ps_proc);\n }\n\n /* If the bytes for the current slice are exhausted\n         * set end_of_slice flag to 1\n         * This slice will be treated as incomplete */\n if((UWORD8 *)ps_codec->s_parse.s_bitstrm.pu1_buf_max + BITSTRM_OFF_THRS <\n ((UWORD8 *)ps_codec->s_parse.s_bitstrm.pu4_buf + (ps_codec->s_parse.s_bitstrm.u4_bit_ofst / 8)))\n {\n\n if(0 == ps_codec->i4_slice_error)\n                end_of_slice_flag = 1;\n }\n\n\n if(end_of_pic)\n break;\n } while(!end_of_slice_flag);\n\n /* Reset slice error */\n    ps_codec->i4_slice_error = 0;\n\n /* Increment the slice index for parsing next slice */\n if(0 == end_of_pic)\n {\n while(1)\n {\n\n            WORD32 parse_slice_idx;\n            parse_slice_idx = ps_codec->s_parse.i4_cur_slice_idx;\n            parse_slice_idx++;\n\n {\n /* If the next slice header is not initialized, update cur_slice_idx and break */\n if((1 == ps_codec->i4_num_cores) || (0 != (parse_slice_idx & (MAX_SLICE_HDR_CNT - 1))))\n {\n                    ps_codec->s_parse.i4_cur_slice_idx = parse_slice_idx;\n break;\n }\n\n /* If the next slice header is initialised, wait for the parsed slices to be processed */\n else\n {\n                    WORD32 ctb_indx = 0;\n\n while(ctb_indx != ps_sps->i4_pic_size_in_ctb)\n {\n                        WORD32 parse_status = *(ps_codec->pu1_parse_map + ctb_indx);\n volatile WORD32 proc_status = *(ps_codec->pu1_proc_map + ctb_indx) & 1;\n\n if(parse_status == proc_status)\n                            ctb_indx++;\n }\n                    ps_codec->s_parse.i4_cur_slice_idx = parse_slice_idx;\n break;\n }\n\n }\n }\n\n }\n else\n {\n#if FRAME_ILF_PAD\n if(FRAME_ILF_PAD && 1 == ps_codec->i4_num_cores)\n {\n if(ps_slice_hdr->i4_abs_pic_order_cnt == 0)\n {\n                DUMP_PRE_ILF(ps_codec->as_process[0].pu1_cur_pic_luma,\n                             ps_codec->as_process[0].pu1_cur_pic_chroma,\n                             ps_sps->i2_pic_width_in_luma_samples,\n                             ps_sps->i2_pic_height_in_luma_samples,\n                             ps_codec->i4_strd);\n\n                DUMP_BS(ps_codec->as_process[0].s_bs_ctxt.pu4_pic_vert_bs,\n                        ps_codec->as_process[0].s_bs_ctxt.pu4_pic_horz_bs,\n                        ps_sps->i2_pic_wd_in_ctb * (ctb_size * ctb_size / 8 / 16) * ps_sps->i2_pic_ht_in_ctb,\n (ps_sps->i2_pic_wd_in_ctb + 1) * (ctb_size * ctb_size / 8 / 16) * ps_sps->i2_pic_ht_in_ctb);\n\n                DUMP_QP(ps_codec->as_process[0].s_bs_ctxt.pu1_pic_qp,\n (ps_sps->i2_pic_height_in_luma_samples * ps_sps->i2_pic_width_in_luma_samples) / (MIN_CU_SIZE * MIN_CU_SIZE));\n\n                DUMP_QP_CONST_IN_CTB(ps_codec->as_process[0].s_bs_ctxt.pu1_pic_qp_const_in_ctb,\n (ps_sps->i2_pic_height_in_luma_samples * ps_sps->i2_pic_width_in_luma_samples) / (MIN_CTB_SIZE * MIN_CTB_SIZE) / 8);\n\n                DUMP_NO_LOOP_FILTER(ps_codec->as_process[0].pu1_pic_no_loop_filter_flag,\n (ps_sps->i2_pic_width_in_luma_samples / MIN_CU_SIZE) * (ps_sps->i2_pic_height_in_luma_samples / MIN_CU_SIZE) / 8);\n\n                DUMP_OFFSETS(ps_slice_hdr->i1_beta_offset_div2,\n                             ps_slice_hdr->i1_tc_offset_div2,\n                             ps_pps->i1_pic_cb_qp_offset,\n                             ps_pps->i1_pic_cr_qp_offset);\n }\n            ps_codec->s_parse.s_deblk_ctxt.ps_pps = ps_codec->s_parse.ps_pps;\n            ps_codec->s_parse.s_deblk_ctxt.ps_sps = ps_codec->s_parse.ps_sps;\n            ps_codec->s_parse.s_deblk_ctxt.ps_codec = ps_codec;\n            ps_codec->s_parse.s_deblk_ctxt.ps_slice_hdr = ps_codec->s_parse.ps_slice_hdr;\n            ps_codec->s_parse.s_deblk_ctxt.is_chroma_yuv420sp_vu = (ps_codec->e_ref_chroma_fmt == IV_YUV_420SP_VU);\n\n            ps_codec->s_parse.s_sao_ctxt.ps_pps = ps_codec->s_parse.ps_pps;\n            ps_codec->s_parse.s_sao_ctxt.ps_sps = ps_codec->s_parse.ps_sps;\n            ps_codec->s_parse.s_sao_ctxt.ps_codec = ps_codec;\n            ps_codec->s_parse.s_sao_ctxt.ps_slice_hdr = ps_codec->s_parse.ps_slice_hdr;\n\n            ihevcd_ilf_pad_frame(&ps_codec->s_parse.s_deblk_ctxt, &ps_codec->s_parse.s_sao_ctxt);\n\n }\n#endif\n        ps_codec->s_parse.i4_end_of_frame = 1;\n }\n return ret;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143939,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "IHEVCD_ERROR_T ihevcd_parse_slice_data(codec_t *ps_codec)\n{\n\n    IHEVCD_ERROR_T ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;\n    WORD32 end_of_slice_flag = 0;\n sps_t *ps_sps;\n pps_t *ps_pps;\n slice_header_t *ps_slice_hdr;\n    WORD32 end_of_pic;\n tile_t *ps_tile, *ps_tile_prev;\n    WORD32 i;\n    WORD32 ctb_addr;\n    WORD32 tile_idx;\n    WORD32 cabac_init_idc;\n    WORD32 ctb_size;\n    WORD32 num_ctb_in_row;\n    WORD32 num_min4x4_in_ctb;\n    WORD32 slice_qp;\n    WORD32 slice_start_ctb_idx;\n    WORD32 tile_start_ctb_idx;\n\n\n    ps_slice_hdr = ps_codec->s_parse.ps_slice_hdr_base;\n    ps_pps = ps_codec->s_parse.ps_pps_base;\n    ps_sps = ps_codec->s_parse.ps_sps_base;\n\n /* Get current slice header, pps and sps */\n    ps_slice_hdr += (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1));\n    ps_pps  += ps_slice_hdr->i1_pps_id;\n    ps_sps  += ps_pps->i1_sps_id;\n\n if(0 != ps_codec->s_parse.i4_cur_slice_idx)\n {\n if(!ps_slice_hdr->i1_dependent_slice_flag)\n {\n            ps_codec->s_parse.i4_cur_independent_slice_idx++;\n if(MAX_SLICE_HDR_CNT == ps_codec->s_parse.i4_cur_independent_slice_idx)\n                ps_codec->s_parse.i4_cur_independent_slice_idx = 0;\n }\n }\n\n\n    ctb_size = 1 << ps_sps->i1_log2_ctb_size;\n    num_min4x4_in_ctb = (ctb_size / 4) * (ctb_size / 4);\n    num_ctb_in_row = ps_sps->i2_pic_wd_in_ctb;\n\n /* Update the parse context */\n if(0 == ps_codec->i4_slice_error)\n {\n        ps_codec->s_parse.i4_ctb_x = ps_slice_hdr->i2_ctb_x;\n        ps_codec->s_parse.i4_ctb_y = ps_slice_hdr->i2_ctb_y;\n }\n    ps_codec->s_parse.ps_pps = ps_pps;\n    ps_codec->s_parse.ps_sps = ps_sps;\n    ps_codec->s_parse.ps_slice_hdr = ps_slice_hdr;\n\n /* Derive Tile positions for the current CTB */\n /* Change this to lookup if required */\n    ihevcd_get_tile_pos(ps_pps, ps_sps, ps_codec->s_parse.i4_ctb_x,\n                        ps_codec->s_parse.i4_ctb_y,\n &ps_codec->s_parse.i4_ctb_tile_x,\n &ps_codec->s_parse.i4_ctb_tile_y,\n &tile_idx);\n    ps_codec->s_parse.ps_tile = ps_pps->ps_tile + tile_idx;\n    ps_codec->s_parse.i4_cur_tile_idx = tile_idx;\n    ps_tile = ps_codec->s_parse.ps_tile;\n if(tile_idx)\n        ps_tile_prev = ps_tile - 1;\n else\n        ps_tile_prev = ps_tile;\n\n /* If the present slice is dependent, then store the previous\n     * independent slices' ctb x and y values for decoding process */\n if(0 == ps_codec->i4_slice_error)\n {\n if(1 == ps_slice_hdr->i1_dependent_slice_flag)\n {\n /*If slice is present at the start of a new tile*/\n if((0 == ps_codec->s_parse.i4_ctb_tile_x) && (0 == ps_codec->s_parse.i4_ctb_tile_y))\n {\n                ps_codec->s_parse.i4_ctb_slice_x = 0;\n                ps_codec->s_parse.i4_ctb_slice_y = 0;\n }\n }\n\n if(!ps_slice_hdr->i1_dependent_slice_flag)\n {\n            ps_codec->s_parse.i4_ctb_slice_x = 0;\n            ps_codec->s_parse.i4_ctb_slice_y = 0;\n }\n }\n\n /* Frame level initializations */\n if((0 == ps_codec->s_parse.i4_ctb_y) &&\n (0 == ps_codec->s_parse.i4_ctb_x))\n {\n        ret = ihevcd_parse_pic_init(ps_codec);\n        RETURN_IF((ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS), ret);\n\n        ps_codec->s_parse.pu4_pic_tu_idx[0] = 0;\n        ps_codec->s_parse.pu4_pic_pu_idx[0] = 0;\n        ps_codec->s_parse.i4_cur_independent_slice_idx = 0;\n        ps_codec->s_parse.i4_ctb_tile_x = 0;\n        ps_codec->s_parse.i4_ctb_tile_y = 0;\n }\n\n {\n /* Updating the poc list of current slice to ps_mv_buf */\n mv_buf_t *ps_mv_buf = ps_codec->s_parse.ps_cur_mv_buf;\n\n if(ps_slice_hdr->i1_num_ref_idx_l1_active != 0)\n {\n for(i = 0; i < ps_slice_hdr->i1_num_ref_idx_l1_active; i++)\n {\n                ps_mv_buf->l1_collocated_poc[(ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1))][i] = ((pic_buf_t *)ps_slice_hdr->as_ref_pic_list1[i].pv_pic_buf)->i4_abs_poc;\n                ps_mv_buf->u1_l1_collocated_poc_lt[(ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1))][i] = ((pic_buf_t *)ps_slice_hdr->as_ref_pic_list1[i].pv_pic_buf)->u1_used_as_ref;\n }\n }\n\n if(ps_slice_hdr->i1_num_ref_idx_l0_active != 0)\n {\n for(i = 0; i < ps_slice_hdr->i1_num_ref_idx_l0_active; i++)\n {\n                ps_mv_buf->l0_collocated_poc[(ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1))][i] = ((pic_buf_t *)ps_slice_hdr->as_ref_pic_list0[i].pv_pic_buf)->i4_abs_poc;\n                ps_mv_buf->u1_l0_collocated_poc_lt[(ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1))][i] = ((pic_buf_t *)ps_slice_hdr->as_ref_pic_list0[i].pv_pic_buf)->u1_used_as_ref;\n }\n }\n }\n\n /*Initialize the low delay flag at the beginning of every slice*/\n if((0 == ps_codec->s_parse.i4_ctb_slice_x) || (0 == ps_codec->s_parse.i4_ctb_slice_y))\n {\n /* Lowdelay flag */\n        WORD32 cur_poc, ref_list_poc, flag = 1;\n        cur_poc = ps_slice_hdr->i4_abs_pic_order_cnt;\n for(i = 0; i < ps_slice_hdr->i1_num_ref_idx_l0_active; i++)\n {\n            ref_list_poc = ((mv_buf_t *)ps_slice_hdr->as_ref_pic_list0[i].pv_mv_buf)->i4_abs_poc;\n if(ref_list_poc > cur_poc)\n {\n                flag = 0;\n break;\n }\n }\n if(flag && (ps_slice_hdr->i1_slice_type == BSLICE))\n {\n for(i = 0; i < ps_slice_hdr->i1_num_ref_idx_l1_active; i++)\n {\n                ref_list_poc = ((mv_buf_t *)ps_slice_hdr->as_ref_pic_list1[i].pv_mv_buf)->i4_abs_poc;\n if(ref_list_poc > cur_poc)\n {\n                    flag = 0;\n break;\n }\n }\n }\n        ps_slice_hdr->i1_low_delay_flag = flag;\n }\n\n /* initialize the cabac init idc based on slice type */\n if(ps_slice_hdr->i1_slice_type == ISLICE)\n {\n        cabac_init_idc = 0;\n }\n else if(ps_slice_hdr->i1_slice_type == PSLICE)\n {\n        cabac_init_idc = ps_slice_hdr->i1_cabac_init_flag ? 2 : 1;\n }\n else\n {\n        cabac_init_idc = ps_slice_hdr->i1_cabac_init_flag ? 1 : 2;\n }\n\n    slice_qp = ps_slice_hdr->i1_slice_qp_delta + ps_pps->i1_pic_init_qp;\n    slice_qp = CLIP3(slice_qp, 0, 51);\n\n /*Update QP value for every indepndent slice or for every dependent slice that begins at the start of a new tile*/\n if((0 == ps_slice_hdr->i1_dependent_slice_flag) ||\n ((1 == ps_slice_hdr->i1_dependent_slice_flag) && ((0 == ps_codec->s_parse.i4_ctb_tile_x) && (0 == ps_codec->s_parse.i4_ctb_tile_y))))\n {\n        ps_codec->s_parse.u4_qp = slice_qp;\n }\n\n /*Cabac init at the beginning of a slice*/\n if((1 == ps_slice_hdr->i1_dependent_slice_flag) && (!((ps_codec->s_parse.i4_ctb_tile_x == 0) && (ps_codec->s_parse.i4_ctb_tile_y == 0))))\n {\n if((0 == ps_pps->i1_entropy_coding_sync_enabled_flag) || (ps_pps->i1_entropy_coding_sync_enabled_flag && (0 != ps_codec->s_parse.i4_ctb_x)))\n {\n            ihevcd_cabac_reset(&ps_codec->s_parse.s_cabac,\n &ps_codec->s_parse.s_bitstrm);\n }\n }\n else if((0 == ps_pps->i1_entropy_coding_sync_enabled_flag) || (ps_pps->i1_entropy_coding_sync_enabled_flag && (0 != ps_codec->s_parse.i4_ctb_x)))\n {\n        ret = ihevcd_cabac_init(&ps_codec->s_parse.s_cabac,\n &ps_codec->s_parse.s_bitstrm,\n                                slice_qp,\n                                cabac_init_idc,\n &gau1_ihevc_cab_ctxts[cabac_init_idc][slice_qp][0]);\n if(ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)\n {\n            ps_codec->i4_slice_error = 1;\n            end_of_slice_flag = 1;\n            ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;\n }\n }\n\n\n do\n {\n\n {\n            WORD32 cur_ctb_idx = ps_codec->s_parse.i4_ctb_x\n + ps_codec->s_parse.i4_ctb_y * (ps_sps->i2_pic_wd_in_ctb);\n if(1 == ps_codec->i4_num_cores && 0 == cur_ctb_idx % RESET_TU_BUF_NCTB)\n {\n                ps_codec->s_parse.ps_tu = ps_codec->s_parse.ps_pic_tu;\n                ps_codec->s_parse.i4_pic_tu_idx = 0;\n }\n }\n\n        end_of_pic = 0;\n /* Section:7.3.7 Coding tree unit syntax */\n /* coding_tree_unit() inlined here */\n /* If number of cores is greater than 1, then add job to the queue */\n /* At the start of ctb row parsing in a tile, queue a job for processing the current tile row */\n        ps_codec->s_parse.i4_ctb_num_pcm_blks = 0;\n\n\n /*At the beginning of each tile-which is not the beginning of a slice, cabac context must be initialized.\n         * Hence, check for the tile beginning here */\n if(((0 == ps_codec->s_parse.i4_ctb_tile_x) && (0 == ps_codec->s_parse.i4_ctb_tile_y))\n && (!((ps_tile->u1_pos_x == 0) && (ps_tile->u1_pos_y == 0)))\n && (!((0 == ps_codec->s_parse.i4_ctb_slice_x) && (0 == ps_codec->s_parse.i4_ctb_slice_y))))\n {\n            slice_qp = ps_slice_hdr->i1_slice_qp_delta + ps_pps->i1_pic_init_qp;\n            slice_qp = CLIP3(slice_qp, 0, 51);\n            ps_codec->s_parse.u4_qp = slice_qp;\n\n            ihevcd_get_tile_pos(ps_pps, ps_sps, ps_codec->s_parse.i4_ctb_x,\n                                ps_codec->s_parse.i4_ctb_y,\n &ps_codec->s_parse.i4_ctb_tile_x,\n &ps_codec->s_parse.i4_ctb_tile_y,\n &tile_idx);\n\n            ps_codec->s_parse.ps_tile = ps_pps->ps_tile + tile_idx;\n            ps_codec->s_parse.i4_cur_tile_idx = tile_idx;\n            ps_tile_prev = ps_tile - 1;\n\n            tile_start_ctb_idx = ps_tile->u1_pos_x\n + ps_tile->u1_pos_y * (ps_sps->i2_pic_wd_in_ctb);\n\n            slice_start_ctb_idx =  ps_slice_hdr->i2_ctb_x\n + ps_slice_hdr->i2_ctb_y * (ps_sps->i2_pic_wd_in_ctb);\n\n /*For slices that span across multiple tiles*/\n if(slice_start_ctb_idx < tile_start_ctb_idx)\n { /* 2 Cases\n             * 1 - slice spans across frame-width- but does not start from 1st column\n             * 2 - Slice spans across multiple tiles anywhere is a frame\n             */\n                ps_codec->s_parse.i4_ctb_slice_y = ps_tile->u1_pos_y - ps_slice_hdr->i2_ctb_y;\n if(!(((ps_slice_hdr->i2_ctb_x + ps_tile_prev->u2_wd) % ps_sps->i2_pic_wd_in_ctb) == ps_tile->u1_pos_x)) //Case 2\n {\n if(ps_slice_hdr->i2_ctb_y <= ps_tile->u1_pos_y)\n {\n if(ps_slice_hdr->i2_ctb_x > ps_tile->u1_pos_x)\n {\n                            ps_codec->s_parse.i4_ctb_slice_y -= 1;\n }\n }\n }\n /*ps_codec->s_parse.i4_ctb_slice_y = ps_tile->u1_pos_y - ps_slice_hdr->i2_ctb_y;\n                if (ps_slice_hdr->i2_ctb_y <= ps_tile->u1_pos_y)\n                {\n                    if (ps_slice_hdr->i2_ctb_x > ps_tile->u1_pos_x )\n                    {\n                        ps_codec->s_parse.i4_ctb_slice_y -= 1 ;\n                    }\n                }*/\n }\n\n if(!ps_slice_hdr->i1_dependent_slice_flag)\n {\n                ret = ihevcd_cabac_init(&ps_codec->s_parse.s_cabac,\n &ps_codec->s_parse.s_bitstrm,\n                                        slice_qp,\n                                        cabac_init_idc,\n &gau1_ihevc_cab_ctxts[cabac_init_idc][slice_qp][0]);\n if(ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)\n {\n                    ps_codec->i4_slice_error = 1;\n                    end_of_slice_flag = 1;\n                    ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;\n }\n\n }\n }\n /* If number of cores is greater than 1, then add job to the queue */\n /* At the start of ctb row parsing in a tile, queue a job for processing the current tile row */\n\n if(0 == ps_codec->s_parse.i4_ctb_tile_x)\n {\n\n if(1 < ps_codec->i4_num_cores)\n {\n proc_job_t s_job;\n                IHEVCD_ERROR_T ret;\n                s_job.i4_cmd    = CMD_PROCESS;\n                s_job.i2_ctb_cnt = (WORD16)ps_tile->u2_wd;\n                s_job.i2_ctb_x = (WORD16)ps_codec->s_parse.i4_ctb_x;\n                s_job.i2_ctb_y = (WORD16)ps_codec->s_parse.i4_ctb_y;\n                s_job.i2_slice_idx = (WORD16)ps_codec->s_parse.i4_cur_slice_idx;\n                s_job.i4_tu_coeff_data_ofst = (UWORD8 *)ps_codec->s_parse.pv_tu_coeff_data -\n (UWORD8 *)ps_codec->s_parse.pv_pic_tu_coeff_data;\n                ret = ihevcd_jobq_queue((jobq_t *)ps_codec->s_parse.pv_proc_jobq, &s_job, sizeof(proc_job_t), 1);\n\n if(ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)\n return ret;\n }\n else\n {\n process_ctxt_t *ps_proc = &ps_codec->as_process[0];\n                WORD32 tu_coeff_data_ofst = (UWORD8 *)ps_codec->s_parse.pv_tu_coeff_data -\n (UWORD8 *)ps_codec->s_parse.pv_pic_tu_coeff_data;\n\n /* If the codec is running in single core mode,\n                 * initialize zeroth process context\n                 * TODO: Dual core mode might need a different implementation instead of jobq\n                 */\n\n                ps_proc->i4_ctb_cnt = ps_tile->u2_wd;\n                ps_proc->i4_ctb_x   = ps_codec->s_parse.i4_ctb_x;\n                ps_proc->i4_ctb_y   = ps_codec->s_parse.i4_ctb_y;\n                ps_proc->i4_cur_slice_idx = ps_codec->s_parse.i4_cur_slice_idx;\n\n                ihevcd_init_proc_ctxt(ps_proc, tu_coeff_data_ofst);\n }\n }\n\n\n /* Restore cabac context model from top right CTB if entropy sync is enabled */\n if(ps_pps->i1_entropy_coding_sync_enabled_flag)\n {\n /*TODO Handle single CTB and top-right belonging to a different slice */\n if(0 == ps_codec->s_parse.i4_ctb_x)\n {\n                WORD32 default_ctxt = 0;\n\n if((0 == ps_codec->s_parse.i4_ctb_slice_y) && (!ps_slice_hdr->i1_dependent_slice_flag))\n                    default_ctxt = 1;\n if(1 == ps_sps->i2_pic_wd_in_ctb)\n                    default_ctxt = 1;\n\n                ps_codec->s_parse.u4_qp = slice_qp;\n if(default_ctxt)\n {\n                    ret = ihevcd_cabac_init(&ps_codec->s_parse.s_cabac,\n &ps_codec->s_parse.s_bitstrm,\n                                            slice_qp,\n                                            cabac_init_idc,\n &gau1_ihevc_cab_ctxts[cabac_init_idc][slice_qp][0]);\n\n if(ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)\n {\n                        ps_codec->i4_slice_error = 1;\n                        end_of_slice_flag = 1;\n                        ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;\n }\n }\n else\n {\n                    ret = ihevcd_cabac_init(&ps_codec->s_parse.s_cabac,\n &ps_codec->s_parse.s_bitstrm,\n                                            slice_qp,\n                                            cabac_init_idc,\n (const UWORD8 *)&ps_codec->s_parse.s_cabac.au1_ctxt_models_sync);\n\n if(ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)\n {\n                        ps_codec->i4_slice_error = 1;\n                        end_of_slice_flag = 1;\n                        ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;\n }\n }\n }\n }\n\n\n\n if(0 == ps_codec->i4_slice_error)\n {\n if(ps_slice_hdr->i1_slice_sao_luma_flag || ps_slice_hdr->i1_slice_sao_chroma_flag)\n                ihevcd_parse_sao(ps_codec);\n }\n else\n {\n sao_t *ps_sao = ps_codec->s_parse.ps_pic_sao +\n                            ps_codec->s_parse.i4_ctb_x +\n                            ps_codec->s_parse.i4_ctb_y * ps_sps->i2_pic_wd_in_ctb;\n\n /* Default values */\n            ps_sao->b3_y_type_idx = 0;\n            ps_sao->b3_cb_type_idx = 0;\n            ps_sao->b3_cr_type_idx = 0;\n }\n\n\n {\n            WORD32 ctb_indx;\n            ctb_indx = ps_codec->s_parse.i4_ctb_x + ps_sps->i2_pic_wd_in_ctb * ps_codec->s_parse.i4_ctb_y;\n            ps_codec->s_parse.s_bs_ctxt.pu1_pic_qp_const_in_ctb[ctb_indx >> 3] |= (1 << (ctb_indx & 7));\n {\n                UWORD16 *pu1_slice_idx = ps_codec->s_parse.pu1_slice_idx;\n                pu1_slice_idx[ctb_indx] = ps_codec->s_parse.i4_cur_independent_slice_idx;\n }\n }\n\n if(0 == ps_codec->i4_slice_error)\n {\n tu_t *ps_tu = ps_codec->s_parse.ps_tu;\n            WORD32 i4_tu_cnt = ps_codec->s_parse.s_cu.i4_tu_cnt;\n            WORD32 i4_pic_tu_idx = ps_codec->s_parse.i4_pic_tu_idx;\n\n pu_t *ps_pu = ps_codec->s_parse.ps_pu;\n            WORD32 i4_pic_pu_idx = ps_codec->s_parse.i4_pic_pu_idx;\n\n            UWORD8 *pu1_tu_coeff_data = (UWORD8 *)ps_codec->s_parse.pv_tu_coeff_data;\n\n            ret = ihevcd_parse_coding_quadtree(ps_codec,\n (ps_codec->s_parse.i4_ctb_x << ps_sps->i1_log2_ctb_size),\n (ps_codec->s_parse.i4_ctb_y << ps_sps->i1_log2_ctb_size),\n                                               ps_sps->i1_log2_ctb_size,\n 0);\n /* Check for error */\n\n             if (ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)\n             {\n                 /* Reset tu and pu parameters, and signal current ctb as skip */\n                 WORD32 tu_coeff_data_reset_size;\n \n                 ps_codec->s_parse.ps_tu = ps_tu;\n                 ps_codec->s_parse.s_cu.i4_tu_cnt = i4_tu_cnt;\n                 ps_codec->s_parse.i4_pic_tu_idx = i4_pic_tu_idx;\n\n\n                 ps_codec->s_parse.ps_pu = ps_pu;\n                 ps_codec->s_parse.i4_pic_pu_idx = i4_pic_pu_idx;\n \n                 tu_coeff_data_reset_size = (UWORD8 *)ps_codec->s_parse.pv_tu_coeff_data - pu1_tu_coeff_data;\n                 memset(pu1_tu_coeff_data, 0, tu_coeff_data_reset_size);\n                 ps_codec->s_parse.pv_tu_coeff_data = (void *)pu1_tu_coeff_data;\n \n                ihevcd_set_ctb_skip(ps_codec);\n \n                 /* Set slice error to suppress further parsing and\n                  * signal end of slice.\n                 */\n                ps_codec->i4_slice_error = 1;\n                end_of_slice_flag = 1;\n                ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;\n }\n\n         }\n         else\n         {\n            ihevcd_set_ctb_skip(ps_codec);\n         }\n \n         if(0 == ps_codec->i4_slice_error)\n            end_of_slice_flag = ihevcd_cabac_decode_terminate(&ps_codec->s_parse.s_cabac, &ps_codec->s_parse.s_bitstrm);\n\n        AEV_TRACE(\"end_of_slice_flag\", end_of_slice_flag, ps_codec->s_parse.s_cabac.u4_range);\n\n\n /* In case of tiles or entropy sync, terminate cabac and copy cabac context backed up at the end of top-right CTB */\n if(ps_pps->i1_tiles_enabled_flag || ps_pps->i1_entropy_coding_sync_enabled_flag)\n {\n            WORD32 end_of_tile = 0;\n            WORD32 end_of_tile_row = 0;\n\n /* Take a back up of cabac context models if entropy sync is enabled */\n if(ps_pps->i1_entropy_coding_sync_enabled_flag || ps_pps->i1_tiles_enabled_flag)\n {\n if(1 == ps_codec->s_parse.i4_ctb_x)\n {\n                    WORD32 size = sizeof(ps_codec->s_parse.s_cabac.au1_ctxt_models);\n                    memcpy(&ps_codec->s_parse.s_cabac.au1_ctxt_models_sync, &ps_codec->s_parse.s_cabac.au1_ctxt_models, size);\n }\n }\n\n /* Since tiles and entropy sync are not enabled simultaneously, the following will not result in any problems */\n if((ps_codec->s_parse.i4_ctb_tile_x + 1) == (ps_tile->u2_wd))\n {\n                end_of_tile_row = 1;\n if((ps_codec->s_parse.i4_ctb_tile_y + 1) == ps_tile->u2_ht)\n                    end_of_tile = 1;\n }\n if((0 == end_of_slice_flag) &&\n ((ps_pps->i1_tiles_enabled_flag && end_of_tile) ||\n (ps_pps->i1_entropy_coding_sync_enabled_flag && end_of_tile_row)))\n {\n                WORD32 end_of_sub_stream_one_bit;\n                end_of_sub_stream_one_bit = ihevcd_cabac_decode_terminate(&ps_codec->s_parse.s_cabac, &ps_codec->s_parse.s_bitstrm);\n                AEV_TRACE(\"end_of_sub_stream_one_bit\", end_of_sub_stream_one_bit, ps_codec->s_parse.s_cabac.u4_range);\n\n /* TODO: Remove the check for offset when HM is updated to include a byte unconditionally even for aligned location */\n /* For Ittiam streams this check should not be there, for HM9.1 streams this should be there */\n if(ps_codec->s_parse.s_bitstrm.u4_bit_ofst % 8)\n                    ihevcd_bits_flush_to_byte_boundary(&ps_codec->s_parse.s_bitstrm);\n\n                UNUSED(end_of_sub_stream_one_bit);\n }\n }\n {\n            WORD32 ctb_indx;\n\n            ctb_addr = ps_codec->s_parse.i4_ctb_y * num_ctb_in_row + ps_codec->s_parse.i4_ctb_x;\n\n            ctb_indx = ++ctb_addr;\n\n /* Store pu_idx for next CTB in frame level pu_idx array */\n\n if((ps_tile->u2_wd == (ps_codec->s_parse.i4_ctb_tile_x + 1)) && (ps_tile->u2_wd != ps_sps->i2_pic_wd_in_ctb))\n {\n                ctb_indx = (ps_sps->i2_pic_wd_in_ctb * (ps_codec->s_parse.i4_ctb_tile_y + 1 + ps_tile->u1_pos_y)) + ps_tile->u1_pos_x; //idx is the beginning of next row in current tile.\n if(ps_tile->u2_ht == (ps_codec->s_parse.i4_ctb_tile_y + 1))\n {\n if((ps_tile->u2_wd + ps_tile->u1_pos_x == ps_sps->i2_pic_wd_in_ctb) && ((ps_tile->u2_ht + ps_tile->u1_pos_y == ps_sps->i2_pic_ht_in_ctb)))\n {\n                        ctb_indx = ctb_addr; //Next continuous ctb address\n }\n else //Not last tile's end , but a tile end\n {\n tile_t *ps_next_tile = ps_codec->s_parse.ps_tile + 1;\n                        ctb_indx = ps_next_tile->u1_pos_x + (ps_next_tile->u1_pos_y * ps_sps->i2_pic_wd_in_ctb); //idx is the beginning of first row in next tile.\n }\n }\n }\n\n            ps_codec->s_parse.pu4_pic_pu_idx[ctb_indx] = ps_codec->s_parse.i4_pic_pu_idx;\n            ps_codec->s_parse.i4_next_pu_ctb_cnt = ctb_indx;\n\n            ps_codec->s_parse.pu1_pu_map += num_min4x4_in_ctb;\n\n /* Store tu_idx for next CTB in frame level tu_idx array */\n if(1 == ps_codec->i4_num_cores)\n {\n                ctb_indx = (0 == ctb_addr % RESET_TU_BUF_NCTB) ?\n                                RESET_TU_BUF_NCTB : ctb_addr % RESET_TU_BUF_NCTB;\n\n if((ps_tile->u2_wd == (ps_codec->s_parse.i4_ctb_tile_x + 1)) && (ps_tile->u2_wd != ps_sps->i2_pic_wd_in_ctb))\n {\n                    ctb_indx = (ps_sps->i2_pic_wd_in_ctb * (ps_codec->s_parse.i4_ctb_tile_y + 1 + ps_tile->u1_pos_y)) + ps_tile->u1_pos_x; //idx is the beginning of next row in current tile.\n if(ps_tile->u2_ht == (ps_codec->s_parse.i4_ctb_tile_y + 1))\n {\n if((ps_tile->u2_wd + ps_tile->u1_pos_x == ps_sps->i2_pic_wd_in_ctb) && ((ps_tile->u2_ht + ps_tile->u1_pos_y == ps_sps->i2_pic_ht_in_ctb)))\n {\n                            ctb_indx = (0 == ctb_addr % RESET_TU_BUF_NCTB) ?\n                                            RESET_TU_BUF_NCTB : ctb_addr % RESET_TU_BUF_NCTB;\n }\n else //Not last tile's end , but a tile end\n {\n tile_t *ps_next_tile = ps_codec->s_parse.ps_tile + 1;\n                            ctb_indx =  ps_next_tile->u1_pos_x + (ps_next_tile->u1_pos_y * ps_sps->i2_pic_wd_in_ctb); //idx is the beginning of first row in next tile.\n }\n }\n }\n                ps_codec->s_parse.i4_next_tu_ctb_cnt = ctb_indx;\n                ps_codec->s_parse.pu4_pic_tu_idx[ctb_indx] = ps_codec->s_parse.i4_pic_tu_idx;\n }\n else\n {\n                ctb_indx = ctb_addr;\n if((ps_tile->u2_wd == (ps_codec->s_parse.i4_ctb_tile_x + 1)) && (ps_tile->u2_wd != ps_sps->i2_pic_wd_in_ctb))\n {\n                    ctb_indx = (ps_sps->i2_pic_wd_in_ctb * (ps_codec->s_parse.i4_ctb_tile_y + 1 + ps_tile->u1_pos_y)) + ps_tile->u1_pos_x; //idx is the beginning of next row in current tile.\n if(ps_tile->u2_ht == (ps_codec->s_parse.i4_ctb_tile_y + 1))\n {\n if((ps_tile->u2_wd + ps_tile->u1_pos_x == ps_sps->i2_pic_wd_in_ctb) && ((ps_tile->u2_ht + ps_tile->u1_pos_y == ps_sps->i2_pic_ht_in_ctb)))\n {\n                            ctb_indx = ctb_addr;\n }\n else //Not last tile's end , but a tile end\n {\n tile_t *ps_next_tile = ps_codec->s_parse.ps_tile + 1;\n                            ctb_indx =  ps_next_tile->u1_pos_x + (ps_next_tile->u1_pos_y * ps_sps->i2_pic_wd_in_ctb); //idx is the beginning of first row in next tile.\n }\n }\n }\n                ps_codec->s_parse.i4_next_tu_ctb_cnt = ctb_indx;\n                ps_codec->s_parse.pu4_pic_tu_idx[ctb_indx] = ps_codec->s_parse.i4_pic_tu_idx;\n }\n            ps_codec->s_parse.pu1_tu_map += num_min4x4_in_ctb;\n }\n\n\n if(ps_codec->i4_num_cores <= MV_PRED_NUM_CORES_THRESHOLD)\n {\n /*************************************************/\n /****************   MV pred **********************/\n /*************************************************/\n            WORD8 u1_top_ctb_avail = 1;\n            WORD8 u1_left_ctb_avail = 1;\n            WORD8 u1_top_lt_ctb_avail = 1;\n            WORD8 u1_top_rt_ctb_avail = 1;\n            WORD16 i2_wd_in_ctb;\n\n            tile_start_ctb_idx = ps_tile->u1_pos_x\n + ps_tile->u1_pos_y * (ps_sps->i2_pic_wd_in_ctb);\n\n            slice_start_ctb_idx =  ps_slice_hdr->i2_ctb_x\n + ps_slice_hdr->i2_ctb_y * (ps_sps->i2_pic_wd_in_ctb);\n\n if((slice_start_ctb_idx < tile_start_ctb_idx))\n {\n                i2_wd_in_ctb = ps_sps->i2_pic_wd_in_ctb;\n }\n else\n {\n                i2_wd_in_ctb = ps_tile->u2_wd;\n }\n /* slice and tile boundaries */\n if((0 == ps_codec->s_parse.i4_ctb_y) || (0 == ps_codec->s_parse.i4_ctb_tile_y))\n {\n                u1_top_ctb_avail = 0;\n                u1_top_lt_ctb_avail = 0;\n                u1_top_rt_ctb_avail = 0;\n }\n\n if((0 == ps_codec->s_parse.i4_ctb_x) || (0 == ps_codec->s_parse.i4_ctb_tile_x))\n {\n                u1_left_ctb_avail = 0;\n                u1_top_lt_ctb_avail = 0;\n if((0 == ps_codec->s_parse.i4_ctb_slice_y) || (0 == ps_codec->s_parse.i4_ctb_tile_y))\n {\n                    u1_top_ctb_avail = 0;\n if((i2_wd_in_ctb - 1) != ps_codec->s_parse.i4_ctb_slice_x) //TODO: For tile, not implemented\n {\n                        u1_top_rt_ctb_avail = 0;\n }\n }\n }\n /*For slices not beginning at start of a ctb row*/\n else if(ps_codec->s_parse.i4_ctb_x > 0)\n {\n if((0 == ps_codec->s_parse.i4_ctb_slice_y) || (0 == ps_codec->s_parse.i4_ctb_tile_y))\n {\n                    u1_top_ctb_avail = 0;\n                    u1_top_lt_ctb_avail = 0;\n if(0 == ps_codec->s_parse.i4_ctb_slice_x)\n {\n                        u1_left_ctb_avail = 0;\n }\n if((i2_wd_in_ctb - 1) != ps_codec->s_parse.i4_ctb_slice_x)\n {\n                        u1_top_rt_ctb_avail = 0;\n }\n }\n else if((1 == ps_codec->s_parse.i4_ctb_slice_y) && (0 == ps_codec->s_parse.i4_ctb_slice_x))\n {\n                    u1_top_lt_ctb_avail = 0;\n }\n }\n\n if(((ps_sps->i2_pic_wd_in_ctb - 1) == ps_codec->s_parse.i4_ctb_x) || ((ps_tile->u2_wd - 1) == ps_codec->s_parse.i4_ctb_tile_x))\n {\n                u1_top_rt_ctb_avail = 0;\n }\n\n if(PSLICE == ps_slice_hdr->i1_slice_type\n || BSLICE == ps_slice_hdr->i1_slice_type)\n {\n mv_ctxt_t s_mv_ctxt;\n process_ctxt_t *ps_proc;\n                UWORD32 *pu4_ctb_top_pu_idx;\n                UWORD32 *pu4_ctb_left_pu_idx;\n                UWORD32 *pu4_ctb_top_left_pu_idx;\n                WORD32 i4_ctb_pu_cnt;\n                WORD32 cur_ctb_idx;\n                WORD32 next_ctb_idx;\n                WORD32 cur_pu_idx;\n                ps_proc = &ps_codec->as_process[(ps_codec->i4_num_cores == 1) ? 1 : (ps_codec->i4_num_cores - 1)];\n                cur_ctb_idx = ps_codec->s_parse.i4_ctb_x\n + ps_codec->s_parse.i4_ctb_y * (ps_sps->i2_pic_wd_in_ctb);\n                next_ctb_idx = ps_codec->s_parse.i4_next_pu_ctb_cnt;\n                i4_ctb_pu_cnt = ps_codec->s_parse.pu4_pic_pu_idx[next_ctb_idx]\n - ps_codec->s_parse.pu4_pic_pu_idx[cur_ctb_idx];\n\n                cur_pu_idx = ps_codec->s_parse.pu4_pic_pu_idx[cur_ctb_idx];\n\n                pu4_ctb_top_pu_idx = ps_proc->pu4_pic_pu_idx_top\n + (ps_codec->s_parse.i4_ctb_x * ctb_size / MIN_PU_SIZE);\n                pu4_ctb_left_pu_idx = ps_proc->pu4_pic_pu_idx_left;\n                pu4_ctb_top_left_pu_idx = &ps_proc->u4_ctb_top_left_pu_idx;\n\n /* Initializing s_mv_ctxt */\n {\n                    s_mv_ctxt.ps_pps = ps_pps;\n                    s_mv_ctxt.ps_sps = ps_sps;\n                    s_mv_ctxt.ps_slice_hdr = ps_slice_hdr;\n                    s_mv_ctxt.i4_ctb_x = ps_codec->s_parse.i4_ctb_x;\n                    s_mv_ctxt.i4_ctb_y = ps_codec->s_parse.i4_ctb_y;\n                    s_mv_ctxt.ps_pu = &ps_codec->s_parse.ps_pic_pu[cur_pu_idx];\n                    s_mv_ctxt.ps_pic_pu = ps_codec->s_parse.ps_pic_pu;\n                    s_mv_ctxt.ps_tile = ps_tile;\n                    s_mv_ctxt.pu4_pic_pu_idx_map = ps_proc->pu4_pic_pu_idx_map;\n                    s_mv_ctxt.pu4_pic_pu_idx = ps_codec->s_parse.pu4_pic_pu_idx;\n                    s_mv_ctxt.pu1_pic_pu_map = ps_codec->s_parse.pu1_pic_pu_map;\n                    s_mv_ctxt.i4_ctb_pu_cnt = i4_ctb_pu_cnt;\n                    s_mv_ctxt.i4_ctb_start_pu_idx = cur_pu_idx;\n                    s_mv_ctxt.u1_top_ctb_avail = u1_top_ctb_avail;\n                    s_mv_ctxt.u1_top_rt_ctb_avail = u1_top_rt_ctb_avail;\n                    s_mv_ctxt.u1_top_lt_ctb_avail = u1_top_lt_ctb_avail;\n                    s_mv_ctxt.u1_left_ctb_avail = u1_left_ctb_avail;\n }\n\n                ihevcd_get_mv_ctb(&s_mv_ctxt, pu4_ctb_top_pu_idx,\n                                  pu4_ctb_left_pu_idx, pu4_ctb_top_left_pu_idx);\n\n }\n else\n {\n                WORD32 num_minpu_in_ctb = (ctb_size / MIN_PU_SIZE) * (ctb_size / MIN_PU_SIZE);\n                UWORD8 *pu1_pic_pu_map_ctb = ps_codec->s_parse.pu1_pic_pu_map +\n (ps_codec->s_parse.i4_ctb_x + ps_codec->s_parse.i4_ctb_y * ps_sps->i2_pic_wd_in_ctb) * num_minpu_in_ctb;\n process_ctxt_t *ps_proc = &ps_codec->as_process[(ps_codec->i4_num_cores == 1) ? 1 : (ps_codec->i4_num_cores - 1)];\n                WORD32 row, col;\n                WORD32 pu_cnt;\n                WORD32 num_pu_per_ctb;\n                WORD32 cur_ctb_idx;\n                WORD32 next_ctb_idx;\n                WORD32 ctb_start_pu_idx;\n                UWORD32 *pu4_nbr_pu_idx = ps_proc->pu4_pic_pu_idx_map;\n                WORD32 nbr_pu_idx_strd = MAX_CTB_SIZE / MIN_PU_SIZE + 2;\n pu_t *ps_pu;\n\n for(row = 0; row < ctb_size / MIN_PU_SIZE; row++)\n {\n for(col = 0; col < ctb_size / MIN_PU_SIZE; col++)\n {\n                        pu1_pic_pu_map_ctb[row * ctb_size / MIN_PU_SIZE + col] = 0;\n }\n }\n\n\n /* Neighbor PU idx update inside CTB */\n /* 1byte per 4x4. Indicates the PU idx that 4x4 block belongs to */\n\n                cur_ctb_idx = ps_codec->s_parse.i4_ctb_x\n + ps_codec->s_parse.i4_ctb_y * (ps_sps->i2_pic_wd_in_ctb);\n                next_ctb_idx = ps_codec->s_parse.i4_next_pu_ctb_cnt;\n                num_pu_per_ctb = ps_codec->s_parse.pu4_pic_pu_idx[next_ctb_idx]\n - ps_codec->s_parse.pu4_pic_pu_idx[cur_ctb_idx];\n                ctb_start_pu_idx = ps_codec->s_parse.pu4_pic_pu_idx[cur_ctb_idx];\n                ps_pu = &ps_codec->s_parse.ps_pic_pu[ctb_start_pu_idx];\n\n for(pu_cnt = 0; pu_cnt < num_pu_per_ctb; pu_cnt++, ps_pu++)\n {\n                    UWORD32 cur_pu_idx;\n                    WORD32 pu_ht = (ps_pu->b4_ht + 1) << 2;\n                    WORD32 pu_wd = (ps_pu->b4_wd + 1) << 2;\n\n                    cur_pu_idx = ctb_start_pu_idx + pu_cnt;\n\n for(row = 0; row < pu_ht / MIN_PU_SIZE; row++)\n for(col = 0; col < pu_wd / MIN_PU_SIZE; col++)\n                            pu4_nbr_pu_idx[(1 + ps_pu->b4_pos_x + col)\n + (1 + ps_pu->b4_pos_y + row)\n * nbr_pu_idx_strd] =\n                                            cur_pu_idx;\n }\n\n /* Updating Top and Left pointers */\n {\n                    WORD32 rows_remaining = ps_sps->i2_pic_height_in_luma_samples\n - (ps_codec->s_parse.i4_ctb_y << ps_sps->i1_log2_ctb_size);\n                    WORD32 ctb_size_left = MIN(ctb_size, rows_remaining);\n\n /* Top Left */\n /* saving top left before updating top ptr, as updating top ptr will overwrite the top left for the next ctb */\n                    ps_proc->u4_ctb_top_left_pu_idx = ps_proc->pu4_pic_pu_idx_top[(ps_codec->s_parse.i4_ctb_x * ctb_size / MIN_PU_SIZE) + ctb_size / MIN_PU_SIZE - 1];\n for(i = 0; i < ctb_size / MIN_PU_SIZE; i++)\n {\n /* Left */\n /* Last column of au4_nbr_pu_idx */\n                        ps_proc->pu4_pic_pu_idx_left[i] = pu4_nbr_pu_idx[(ctb_size / MIN_PU_SIZE)\n + (i + 1) * nbr_pu_idx_strd];\n /* Top */\n /* Last row of au4_nbr_pu_idx */\n                        ps_proc->pu4_pic_pu_idx_top[(ps_codec->s_parse.i4_ctb_x * ctb_size / MIN_PU_SIZE) + i] =\n                                        pu4_nbr_pu_idx[(ctb_size_left / MIN_PU_SIZE) * nbr_pu_idx_strd + i + 1];\n\n }\n }\n }\n\n /*************************************************/\n /******************  BS, QP  *********************/\n /*************************************************/\n /* Check if deblock is disabled for the current slice or if it is disabled for the current picture\n             * because of disable deblock api\n             */\n if(0 == ps_codec->i4_disable_deblk_pic)\n {\n if((0 == ps_slice_hdr->i1_slice_disable_deblocking_filter_flag) &&\n (0 == ps_codec->i4_slice_error))\n {\n                    WORD32 i4_ctb_tu_cnt;\n                    WORD32 cur_ctb_idx, next_ctb_idx;\n                    WORD32 cur_pu_idx;\n                    WORD32 cur_tu_idx;\n process_ctxt_t *ps_proc;\n\n                    ps_proc = &ps_codec->as_process[(ps_codec->i4_num_cores == 1) ? 1 : (ps_codec->i4_num_cores - 1)];\n                    cur_ctb_idx = ps_codec->s_parse.i4_ctb_x\n + ps_codec->s_parse.i4_ctb_y * (ps_sps->i2_pic_wd_in_ctb);\n\n                    cur_pu_idx = ps_codec->s_parse.pu4_pic_pu_idx[cur_ctb_idx];\n                    next_ctb_idx = ps_codec->s_parse.i4_next_tu_ctb_cnt;\n if(1 == ps_codec->i4_num_cores)\n {\n                        i4_ctb_tu_cnt = ps_codec->s_parse.pu4_pic_tu_idx[next_ctb_idx] -\n                                        ps_codec->s_parse.pu4_pic_tu_idx[cur_ctb_idx % RESET_TU_BUF_NCTB];\n\n                        cur_tu_idx = ps_codec->s_parse.pu4_pic_tu_idx[cur_ctb_idx % RESET_TU_BUF_NCTB];\n }\n else\n {\n                        i4_ctb_tu_cnt = ps_codec->s_parse.pu4_pic_tu_idx[next_ctb_idx] -\n                                        ps_codec->s_parse.pu4_pic_tu_idx[cur_ctb_idx];\n\n                        cur_tu_idx = ps_codec->s_parse.pu4_pic_tu_idx[cur_ctb_idx];\n }\n\n                    ps_codec->s_parse.s_bs_ctxt.ps_pps = ps_codec->s_parse.ps_pps;\n                    ps_codec->s_parse.s_bs_ctxt.ps_sps = ps_codec->s_parse.ps_sps;\n                    ps_codec->s_parse.s_bs_ctxt.ps_codec = ps_codec;\n                    ps_codec->s_parse.s_bs_ctxt.i4_ctb_tu_cnt = i4_ctb_tu_cnt;\n                    ps_codec->s_parse.s_bs_ctxt.i4_ctb_x = ps_codec->s_parse.i4_ctb_x;\n                    ps_codec->s_parse.s_bs_ctxt.i4_ctb_y = ps_codec->s_parse.i4_ctb_y;\n                    ps_codec->s_parse.s_bs_ctxt.i4_ctb_tile_x = ps_codec->s_parse.i4_ctb_tile_x;\n                    ps_codec->s_parse.s_bs_ctxt.i4_ctb_tile_y = ps_codec->s_parse.i4_ctb_tile_y;\n                    ps_codec->s_parse.s_bs_ctxt.i4_ctb_slice_x = ps_codec->s_parse.i4_ctb_slice_x;\n                    ps_codec->s_parse.s_bs_ctxt.i4_ctb_slice_y = ps_codec->s_parse.i4_ctb_slice_y;\n                    ps_codec->s_parse.s_bs_ctxt.ps_tu = &ps_codec->s_parse.ps_pic_tu[cur_tu_idx];\n                    ps_codec->s_parse.s_bs_ctxt.ps_pu = &ps_codec->s_parse.ps_pic_pu[cur_pu_idx];\n                    ps_codec->s_parse.s_bs_ctxt.pu4_pic_pu_idx_map = ps_proc->pu4_pic_pu_idx_map;\n                    ps_codec->s_parse.s_bs_ctxt.i4_next_pu_ctb_cnt = ps_codec->s_parse.i4_next_pu_ctb_cnt;\n                    ps_codec->s_parse.s_bs_ctxt.i4_next_tu_ctb_cnt = ps_codec->s_parse.i4_next_tu_ctb_cnt;\n                    ps_codec->s_parse.s_bs_ctxt.pu1_slice_idx = ps_codec->s_parse.pu1_slice_idx;\n                    ps_codec->s_parse.s_bs_ctxt.ps_slice_hdr = ps_codec->s_parse.ps_slice_hdr;\n                    ps_codec->s_parse.s_bs_ctxt.ps_tile = ps_codec->s_parse.ps_tile;\n\n if(ISLICE == ps_slice_hdr->i1_slice_type)\n {\n                        ihevcd_ctb_boundary_strength_islice(&ps_codec->s_parse.s_bs_ctxt);\n }\n else\n {\n                        ihevcd_ctb_boundary_strength_pbslice(&ps_codec->s_parse.s_bs_ctxt);\n }\n }\n else\n {\n                    WORD32 bs_strd = (ps_sps->i2_pic_wd_in_ctb + 1) * (ctb_size * ctb_size / 8 / 16);\n\n                    UWORD32 *pu4_vert_bs = (UWORD32 *)((UWORD8 *)ps_codec->s_parse.s_bs_ctxt.pu4_pic_vert_bs +\n                                    ps_codec->s_parse.i4_ctb_x * (ctb_size * ctb_size / 8 / 16) +\n                                    ps_codec->s_parse.i4_ctb_y * bs_strd);\n                    UWORD32 *pu4_horz_bs = (UWORD32 *)((UWORD8 *)ps_codec->s_parse.s_bs_ctxt.pu4_pic_horz_bs +\n                                    ps_codec->s_parse.i4_ctb_x * (ctb_size * ctb_size / 8 / 16) +\n                                    ps_codec->s_parse.i4_ctb_y * bs_strd);\n\n                    memset(pu4_vert_bs, 0, (ctb_size / 8 + 1) * (ctb_size / 4) / 8 * 2);\n                    memset(pu4_horz_bs, 0, (ctb_size / 8) * (ctb_size / 4) / 8 * 2);\n\n }\n }\n\n }\n\n\n /* Update the parse status map */\n {\n sps_t *ps_sps = ps_codec->s_parse.ps_sps;\n            UWORD8 *pu1_buf;\n            WORD32 idx;\n            idx = (ps_codec->s_parse.i4_ctb_x);\n            idx += ((ps_codec->s_parse.i4_ctb_y) * ps_sps->i2_pic_wd_in_ctb);\n            pu1_buf = (ps_codec->pu1_parse_map + idx);\n *pu1_buf = 1;\n }\n\n /* Increment CTB x and y positions */\n        ps_codec->s_parse.i4_ctb_tile_x++;\n        ps_codec->s_parse.i4_ctb_x++;\n        ps_codec->s_parse.i4_ctb_slice_x++;\n\n /*If tiles are enabled, handle the slice counters differently*/\n if(ps_pps->i1_tiles_enabled_flag)\n {\n            tile_start_ctb_idx = ps_tile->u1_pos_x\n + ps_tile->u1_pos_y * (ps_sps->i2_pic_wd_in_ctb);\n\n            slice_start_ctb_idx =  ps_slice_hdr->i2_ctb_x\n + ps_slice_hdr->i2_ctb_y * (ps_sps->i2_pic_wd_in_ctb);\n\n if((slice_start_ctb_idx < tile_start_ctb_idx))\n {\n if(ps_codec->s_parse.i4_ctb_slice_x == (ps_tile->u1_pos_x + ps_tile->u2_wd))\n {\n /* Reached end of slice row within a tile /frame */\n                    ps_codec->s_parse.i4_ctb_slice_y++;\n                    ps_codec->s_parse.i4_ctb_slice_x = ps_tile->u1_pos_x; //todo:Check\n }\n }\n else if(ps_codec->s_parse.i4_ctb_slice_x == (ps_tile->u2_wd))\n {\n                ps_codec->s_parse.i4_ctb_slice_y++;\n                ps_codec->s_parse.i4_ctb_slice_x = 0;\n }\n }\n else\n {\n if(ps_codec->s_parse.i4_ctb_slice_x == ps_tile->u2_wd)\n {\n /* Reached end of slice row within a tile /frame */\n                ps_codec->s_parse.i4_ctb_slice_y++;\n                ps_codec->s_parse.i4_ctb_slice_x = 0;\n }\n }\n\n\n if(ps_codec->s_parse.i4_ctb_tile_x == (ps_tile->u2_wd))\n {\n /* Reached end of tile row */\n            ps_codec->s_parse.i4_ctb_tile_x = 0;\n            ps_codec->s_parse.i4_ctb_x = ps_tile->u1_pos_x;\n\n            ps_codec->s_parse.i4_ctb_tile_y++;\n            ps_codec->s_parse.i4_ctb_y++;\n\n if(ps_codec->s_parse.i4_ctb_tile_y == (ps_tile->u2_ht))\n {\n /* Reached End of Tile */\n                ps_codec->s_parse.i4_ctb_tile_y = 0;\n                ps_codec->s_parse.i4_ctb_tile_x = 0;\n                ps_codec->s_parse.ps_tile++;\n\n if((ps_tile->u2_ht + ps_tile->u1_pos_y  ==  ps_sps->i2_pic_ht_in_ctb) && (ps_tile->u2_wd + ps_tile->u1_pos_x  ==  ps_sps->i2_pic_wd_in_ctb))\n {\n /* Reached end of frame */\n                    end_of_pic = 1;\n                    ps_codec->s_parse.i4_ctb_x = 0;\n                    ps_codec->s_parse.i4_ctb_y = ps_sps->i2_pic_ht_in_ctb;\n }\n else\n {\n /* Initialize ctb_x and ctb_y to start of next tile */\n                    ps_tile = ps_codec->s_parse.ps_tile;\n                    ps_codec->s_parse.i4_ctb_x = ps_tile->u1_pos_x;\n                    ps_codec->s_parse.i4_ctb_y = ps_tile->u1_pos_y;\n                    ps_codec->s_parse.i4_ctb_tile_y = 0;\n                    ps_codec->s_parse.i4_ctb_tile_x = 0;\n                    ps_codec->s_parse.i4_ctb_slice_x = ps_tile->u1_pos_x;\n                    ps_codec->s_parse.i4_ctb_slice_y = ps_tile->u1_pos_y;\n\n }\n }\n\n }\n\n        ps_codec->s_parse.i4_next_ctb_indx = ps_codec->s_parse.i4_ctb_x +\n                        ps_codec->s_parse.i4_ctb_y * ps_sps->i2_pic_wd_in_ctb;\n\n /* If the current slice is in error, check if the next slice's address\n         * is reached and mark the end_of_slice flag */\n if(ps_codec->i4_slice_error)\n {\n slice_header_t *ps_slice_hdr_next = ps_slice_hdr + 1;\n            WORD32 next_slice_addr = ps_slice_hdr_next->i2_ctb_x +\n                            ps_slice_hdr_next->i2_ctb_y * ps_sps->i2_pic_wd_in_ctb;\n\n if(ps_codec->s_parse.i4_next_ctb_indx == next_slice_addr)\n                end_of_slice_flag = 1;\n }\n\n /* If the codec is running in single core mode\n         * then call process function for current CTB\n         */\n if((1 == ps_codec->i4_num_cores) && (ps_codec->s_parse.i4_ctb_tile_x == 0))\n {\n process_ctxt_t *ps_proc = &ps_codec->as_process[0];\n            ps_proc->i4_ctb_cnt = ps_proc->ps_tile->u2_wd;\n            ihevcd_process(ps_proc);\n }\n\n /* If the bytes for the current slice are exhausted\n         * set end_of_slice flag to 1\n         * This slice will be treated as incomplete */\n if((UWORD8 *)ps_codec->s_parse.s_bitstrm.pu1_buf_max + BITSTRM_OFF_THRS <\n ((UWORD8 *)ps_codec->s_parse.s_bitstrm.pu4_buf + (ps_codec->s_parse.s_bitstrm.u4_bit_ofst / 8)))\n {\n\n if(0 == ps_codec->i4_slice_error)\n                end_of_slice_flag = 1;\n }\n\n\n if(end_of_pic)\n break;\n } while(!end_of_slice_flag);\n\n /* Reset slice error */\n    ps_codec->i4_slice_error = 0;\n\n /* Increment the slice index for parsing next slice */\n if(0 == end_of_pic)\n {\n while(1)\n {\n\n            WORD32 parse_slice_idx;\n            parse_slice_idx = ps_codec->s_parse.i4_cur_slice_idx;\n            parse_slice_idx++;\n\n {\n /* If the next slice header is not initialized, update cur_slice_idx and break */\n if((1 == ps_codec->i4_num_cores) || (0 != (parse_slice_idx & (MAX_SLICE_HDR_CNT - 1))))\n {\n                    ps_codec->s_parse.i4_cur_slice_idx = parse_slice_idx;\n break;\n }\n\n /* If the next slice header is initialised, wait for the parsed slices to be processed */\n else\n {\n                    WORD32 ctb_indx = 0;\n\n while(ctb_indx != ps_sps->i4_pic_size_in_ctb)\n {\n                        WORD32 parse_status = *(ps_codec->pu1_parse_map + ctb_indx);\n volatile WORD32 proc_status = *(ps_codec->pu1_proc_map + ctb_indx) & 1;\n\n if(parse_status == proc_status)\n                            ctb_indx++;\n }\n                    ps_codec->s_parse.i4_cur_slice_idx = parse_slice_idx;\n break;\n }\n\n }\n }\n\n }\n else\n {\n#if FRAME_ILF_PAD\n if(FRAME_ILF_PAD && 1 == ps_codec->i4_num_cores)\n {\n if(ps_slice_hdr->i4_abs_pic_order_cnt == 0)\n {\n                DUMP_PRE_ILF(ps_codec->as_process[0].pu1_cur_pic_luma,\n                             ps_codec->as_process[0].pu1_cur_pic_chroma,\n                             ps_sps->i2_pic_width_in_luma_samples,\n                             ps_sps->i2_pic_height_in_luma_samples,\n                             ps_codec->i4_strd);\n\n                DUMP_BS(ps_codec->as_process[0].s_bs_ctxt.pu4_pic_vert_bs,\n                        ps_codec->as_process[0].s_bs_ctxt.pu4_pic_horz_bs,\n                        ps_sps->i2_pic_wd_in_ctb * (ctb_size * ctb_size / 8 / 16) * ps_sps->i2_pic_ht_in_ctb,\n (ps_sps->i2_pic_wd_in_ctb + 1) * (ctb_size * ctb_size / 8 / 16) * ps_sps->i2_pic_ht_in_ctb);\n\n                DUMP_QP(ps_codec->as_process[0].s_bs_ctxt.pu1_pic_qp,\n (ps_sps->i2_pic_height_in_luma_samples * ps_sps->i2_pic_width_in_luma_samples) / (MIN_CU_SIZE * MIN_CU_SIZE));\n\n                DUMP_QP_CONST_IN_CTB(ps_codec->as_process[0].s_bs_ctxt.pu1_pic_qp_const_in_ctb,\n (ps_sps->i2_pic_height_in_luma_samples * ps_sps->i2_pic_width_in_luma_samples) / (MIN_CTB_SIZE * MIN_CTB_SIZE) / 8);\n\n                DUMP_NO_LOOP_FILTER(ps_codec->as_process[0].pu1_pic_no_loop_filter_flag,\n (ps_sps->i2_pic_width_in_luma_samples / MIN_CU_SIZE) * (ps_sps->i2_pic_height_in_luma_samples / MIN_CU_SIZE) / 8);\n\n                DUMP_OFFSETS(ps_slice_hdr->i1_beta_offset_div2,\n                             ps_slice_hdr->i1_tc_offset_div2,\n                             ps_pps->i1_pic_cb_qp_offset,\n                             ps_pps->i1_pic_cr_qp_offset);\n }\n            ps_codec->s_parse.s_deblk_ctxt.ps_pps = ps_codec->s_parse.ps_pps;\n            ps_codec->s_parse.s_deblk_ctxt.ps_sps = ps_codec->s_parse.ps_sps;\n            ps_codec->s_parse.s_deblk_ctxt.ps_codec = ps_codec;\n            ps_codec->s_parse.s_deblk_ctxt.ps_slice_hdr = ps_codec->s_parse.ps_slice_hdr;\n            ps_codec->s_parse.s_deblk_ctxt.is_chroma_yuv420sp_vu = (ps_codec->e_ref_chroma_fmt == IV_YUV_420SP_VU);\n\n            ps_codec->s_parse.s_sao_ctxt.ps_pps = ps_codec->s_parse.ps_pps;\n            ps_codec->s_parse.s_sao_ctxt.ps_sps = ps_codec->s_parse.ps_sps;\n            ps_codec->s_parse.s_sao_ctxt.ps_codec = ps_codec;\n            ps_codec->s_parse.s_sao_ctxt.ps_slice_hdr = ps_codec->s_parse.ps_slice_hdr;\n\n            ihevcd_ilf_pad_frame(&ps_codec->s_parse.s_deblk_ctxt, &ps_codec->s_parse.s_sao_ctxt);\n\n }\n#endif\n        ps_codec->s_parse.i4_end_of_frame = 1;\n }\n return ret;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143940,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "status_t OMXNodeInstance::allocateBufferWithBackup(\n        OMX_U32 portIndex, const sp<IMemory> &params,\n        OMX::buffer_id *buffer, OMX_U32 allottedSize) {\n if (params == NULL || buffer == NULL) {\n        ALOGE(\"b/25884056\");\n return BAD_VALUE;\n }\n\n Mutex::Autolock autoLock(mLock);\n if (allottedSize > params->size() || portIndex >= NELEM(mNumPortBuffers)) {\n return BAD_VALUE;\n }\n\n bool copy = mMetadataType[portIndex] == kMetadataBufferTypeInvalid;\n\n BufferMeta *buffer_meta = new BufferMeta(\n            params, portIndex,\n (portIndex == kPortIndexInput) && copy /* copyToOmx */,\n (portIndex == kPortIndexOutput) && copy /* copyFromOmx */,\n            NULL /* data */);\n\n    OMX_BUFFERHEADERTYPE *header;\n\n    OMX_ERRORTYPE err = OMX_AllocateBuffer(\n            mHandle, &header, portIndex, buffer_meta, allottedSize);\n if (err != OMX_ErrorNone) {\n        CLOG_ERROR(allocateBufferWithBackup, err,\n                SIMPLE_BUFFER(portIndex, (size_t)allottedSize, params->pointer()));\n delete buffer_meta;\n        buffer_meta = NULL;\n\n *buffer = 0;\n\n return StatusFromOMXError(err);\n\n     }\n \n     CHECK_EQ(header->pAppPrivate, buffer_meta);\n    memset(header->pBuffer, 0, header->nAllocLen);\n \n     *buffer = makeBufferID(header);\n \n    addActiveBuffer(portIndex, *buffer);\n\n    sp<GraphicBufferSource> bufferSource(getGraphicBufferSource());\n if (bufferSource != NULL && portIndex == kPortIndexInput) {\n        bufferSource->addCodecBuffer(header);\n }\n\n    CLOG_BUFFER(allocateBufferWithBackup, NEW_BUFFER_FMT(*buffer, portIndex, \"%zu@%p :> %u@%p\",\n            params->size(), params->pointer(), allottedSize, header->pBuffer));\n\n return OK;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143945,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "status_t OMXNodeInstance::allocateBufferWithBackup(\n        OMX_U32 portIndex, const sp<IMemory> &params,\n        OMX::buffer_id *buffer, OMX_U32 allottedSize) {\n if (params == NULL || buffer == NULL) {\n        ALOGE(\"b/25884056\");\n return BAD_VALUE;\n }\n\n Mutex::Autolock autoLock(mLock);\n if (allottedSize > params->size() || portIndex >= NELEM(mNumPortBuffers)) {\n return BAD_VALUE;\n }\n\n bool copy = mMetadataType[portIndex] == kMetadataBufferTypeInvalid;\n\n BufferMeta *buffer_meta = new BufferMeta(\n            params, portIndex,\n (portIndex == kPortIndexInput) && copy /* copyToOmx */,\n (portIndex == kPortIndexOutput) && copy /* copyFromOmx */,\n            NULL /* data */);\n\n    OMX_BUFFERHEADERTYPE *header;\n\n    OMX_ERRORTYPE err = OMX_AllocateBuffer(\n            mHandle, &header, portIndex, buffer_meta, allottedSize);\n if (err != OMX_ErrorNone) {\n        CLOG_ERROR(allocateBufferWithBackup, err,\n                SIMPLE_BUFFER(portIndex, (size_t)allottedSize, params->pointer()));\n delete buffer_meta;\n        buffer_meta = NULL;\n\n *buffer = 0;\n\n return StatusFromOMXError(err);\n\n     }\n \n     CHECK_EQ(header->pAppPrivate, buffer_meta);\n \n     *buffer = makeBufferID(header);\n \n    addActiveBuffer(portIndex, *buffer);\n\n    sp<GraphicBufferSource> bufferSource(getGraphicBufferSource());\n if (bufferSource != NULL && portIndex == kPortIndexInput) {\n        bufferSource->addCodecBuffer(header);\n }\n\n    CLOG_BUFFER(allocateBufferWithBackup, NEW_BUFFER_FMT(*buffer, portIndex, \"%zu@%p :> %u@%p\",\n            params->size(), params->pointer(), allottedSize, header->pBuffer));\n\n return OK;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143946,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "int equalizer_get_parameter(effect_context_t *context, effect_param_t *p,\n uint32_t *size)\n{\n equalizer_context_t *eq_ctxt = (equalizer_context_t *)context;\n int voffset = ((p->psize - 1) / sizeof(int32_t) + 1) * sizeof(int32_t);\n int32_t *param_tmp = (int32_t *)p->data;\n int32_t param = *param_tmp++;\n int32_t param2;\n char *name;\n void *value = p->data + voffset;\n int i;\n\n    ALOGV(\"%s\", __func__);\n\n    p->status = 0;\n\n switch (param) {\n case EQ_PARAM_NUM_BANDS:\n case EQ_PARAM_CUR_PRESET:\n case EQ_PARAM_GET_NUM_OF_PRESETS:\n case EQ_PARAM_BAND_LEVEL:\n case EQ_PARAM_GET_BAND:\n if (p->vsize < sizeof(int16_t))\n           p->status = -EINVAL;\n        p->vsize = sizeof(int16_t);\n break;\n\n case EQ_PARAM_LEVEL_RANGE:\n if (p->vsize < 2 * sizeof(int16_t))\n            p->status = -EINVAL;\n        p->vsize = 2 * sizeof(int16_t);\n break;\n case EQ_PARAM_BAND_FREQ_RANGE:\n if (p->vsize < 2 * sizeof(int32_t))\n            p->status = -EINVAL;\n        p->vsize = 2 * sizeof(int32_t);\n break;\n\n case EQ_PARAM_CENTER_FREQ:\n if (p->vsize < sizeof(int32_t))\n            p->status = -EINVAL;\n        p->vsize = sizeof(int32_t);\n break;\n\n case EQ_PARAM_GET_PRESET_NAME:\n break;\n\n case EQ_PARAM_PROPERTIES:\n if (p->vsize < (2 + NUM_EQ_BANDS) * sizeof(uint16_t))\n            p->status = -EINVAL;\n        p->vsize = (2 + NUM_EQ_BANDS) * sizeof(uint16_t);\n break;\n\n default:\n        p->status = -EINVAL;\n }\n\n *size = sizeof(effect_param_t) + voffset + p->vsize;\n\n if (p->status != 0)\n return 0;\n\n switch (param) {\n case EQ_PARAM_NUM_BANDS:\n\tALOGV(\"%s: EQ_PARAM_NUM_BANDS\", __func__);\n *(uint16_t *)value = (uint16_t)NUM_EQ_BANDS;\n break;\n\n case EQ_PARAM_LEVEL_RANGE:\n\tALOGV(\"%s: EQ_PARAM_LEVEL_RANGE\", __func__);\n *(int16_t *)value = -1500;\n *((int16_t *)value + 1) = 1500;\n break;\n\n\n     case EQ_PARAM_BAND_LEVEL:\n \tALOGV(\"%s: EQ_PARAM_BAND_LEVEL\", __func__);\n         param2 = *param_tmp;\n        if (param2 >= NUM_EQ_BANDS) {\n             p->status = -EINVAL;\n             break;\n         }\n         *(int16_t *)value = (int16_t)equalizer_get_band_level(eq_ctxt, param2);\n break;\n\n\n     case EQ_PARAM_CENTER_FREQ:\n \tALOGV(\"%s: EQ_PARAM_CENTER_FREQ\", __func__);\n         param2 = *param_tmp;\n        if (param2 >= NUM_EQ_BANDS) {\n           p->status = -EINVAL;\n             break;\n         }\n         *(int32_t *)value = equalizer_get_center_frequency(eq_ctxt, param2);\n break;\n\n\n     case EQ_PARAM_BAND_FREQ_RANGE:\n \tALOGV(\"%s: EQ_PARAM_BAND_FREQ_RANGE\", __func__);\n         param2 = *param_tmp;\n        if (param2 >= NUM_EQ_BANDS) {\n             p->status = -EINVAL;\n            break;\n         }\n        equalizer_get_band_freq_range(eq_ctxt, param2, (uint32_t *)value,\n ((uint32_t *)value + 1));\n break;\n\n case EQ_PARAM_GET_BAND:\n\tALOGV(\"%s: EQ_PARAM_GET_BAND\", __func__);\n        param2 = *param_tmp;\n *(uint16_t *)value = (uint16_t)equalizer_get_band(eq_ctxt, param2);\n break;\n\n case EQ_PARAM_CUR_PRESET:\n\tALOGV(\"%s: EQ_PARAM_CUR_PRESET\", __func__);\n *(uint16_t *)value = (uint16_t)equalizer_get_preset(eq_ctxt);\n break;\n\n case EQ_PARAM_GET_NUM_OF_PRESETS:\n\tALOGV(\"%s: EQ_PARAM_GET_NUM_OF_PRESETS\", __func__);\n *(uint16_t *)value = (uint16_t)equalizer_get_num_presets(eq_ctxt);\n break;\n\n case EQ_PARAM_GET_PRESET_NAME:\n\tALOGV(\"%s: EQ_PARAM_GET_PRESET_NAME\", __func__);\n        param2 = *param_tmp;\n\tALOGV(\"param2: %d\", param2);\n if (param2 >= equalizer_get_num_presets(eq_ctxt)) {\n            p->status = -EINVAL;\n break;\n }\n        name = (char *)value;\n        strlcpy(name, equalizer_get_preset_name(eq_ctxt, param2), p->vsize - 1);\n        name[p->vsize - 1] = 0;\n        p->vsize = strlen(name) + 1;\n break;\n\n case EQ_PARAM_PROPERTIES: {\n\tALOGV(\"%s: EQ_PARAM_PROPERTIES\", __func__);\n int16_t *prop = (int16_t *)value;\n        prop[0] = (int16_t)equalizer_get_preset(eq_ctxt);\n        prop[1] = (int16_t)NUM_EQ_BANDS;\n for (i = 0; i < NUM_EQ_BANDS; i++) {\n            prop[2 + i] = (int16_t)equalizer_get_band_level(eq_ctxt, i);\n }\n } break;\n\n default:\n        p->status = -EINVAL;\n break;\n }\n\n return 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143963,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "int equalizer_get_parameter(effect_context_t *context, effect_param_t *p,\n uint32_t *size)\n{\n equalizer_context_t *eq_ctxt = (equalizer_context_t *)context;\n int voffset = ((p->psize - 1) / sizeof(int32_t) + 1) * sizeof(int32_t);\n int32_t *param_tmp = (int32_t *)p->data;\n int32_t param = *param_tmp++;\n int32_t param2;\n char *name;\n void *value = p->data + voffset;\n int i;\n\n    ALOGV(\"%s\", __func__);\n\n    p->status = 0;\n\n switch (param) {\n case EQ_PARAM_NUM_BANDS:\n case EQ_PARAM_CUR_PRESET:\n case EQ_PARAM_GET_NUM_OF_PRESETS:\n case EQ_PARAM_BAND_LEVEL:\n case EQ_PARAM_GET_BAND:\n if (p->vsize < sizeof(int16_t))\n           p->status = -EINVAL;\n        p->vsize = sizeof(int16_t);\n break;\n\n case EQ_PARAM_LEVEL_RANGE:\n if (p->vsize < 2 * sizeof(int16_t))\n            p->status = -EINVAL;\n        p->vsize = 2 * sizeof(int16_t);\n break;\n case EQ_PARAM_BAND_FREQ_RANGE:\n if (p->vsize < 2 * sizeof(int32_t))\n            p->status = -EINVAL;\n        p->vsize = 2 * sizeof(int32_t);\n break;\n\n case EQ_PARAM_CENTER_FREQ:\n if (p->vsize < sizeof(int32_t))\n            p->status = -EINVAL;\n        p->vsize = sizeof(int32_t);\n break;\n\n case EQ_PARAM_GET_PRESET_NAME:\n break;\n\n case EQ_PARAM_PROPERTIES:\n if (p->vsize < (2 + NUM_EQ_BANDS) * sizeof(uint16_t))\n            p->status = -EINVAL;\n        p->vsize = (2 + NUM_EQ_BANDS) * sizeof(uint16_t);\n break;\n\n default:\n        p->status = -EINVAL;\n }\n\n *size = sizeof(effect_param_t) + voffset + p->vsize;\n\n if (p->status != 0)\n return 0;\n\n switch (param) {\n case EQ_PARAM_NUM_BANDS:\n\tALOGV(\"%s: EQ_PARAM_NUM_BANDS\", __func__);\n *(uint16_t *)value = (uint16_t)NUM_EQ_BANDS;\n break;\n\n case EQ_PARAM_LEVEL_RANGE:\n\tALOGV(\"%s: EQ_PARAM_LEVEL_RANGE\", __func__);\n *(int16_t *)value = -1500;\n *((int16_t *)value + 1) = 1500;\n break;\n\n\n     case EQ_PARAM_BAND_LEVEL:\n \tALOGV(\"%s: EQ_PARAM_BAND_LEVEL\", __func__);\n         param2 = *param_tmp;\n        if (param2 < 0 || param2 >= NUM_EQ_BANDS) {\n             p->status = -EINVAL;\n            if (param2 < 0) {\n                android_errorWriteLog(0x534e4554, \"32438598\");\n                ALOGW(\"\\tERROR EQ_PARAM_BAND_LEVEL band %d\", param2);\n            }\n             break;\n         }\n         *(int16_t *)value = (int16_t)equalizer_get_band_level(eq_ctxt, param2);\n break;\n\n\n     case EQ_PARAM_CENTER_FREQ:\n \tALOGV(\"%s: EQ_PARAM_CENTER_FREQ\", __func__);\n         param2 = *param_tmp;\n        if (param2 < 0 || param2 >= NUM_EQ_BANDS) {\n            p->status = -EINVAL;\n            if (param2 < 0) {\n                android_errorWriteLog(0x534e4554, \"32436341\");\n                ALOGW(\"\\tERROR EQ_PARAM_CENTER_FREQ band %d\", param2);\n            }\n             break;\n         }\n         *(int32_t *)value = equalizer_get_center_frequency(eq_ctxt, param2);\n break;\n\n\n     case EQ_PARAM_BAND_FREQ_RANGE:\n \tALOGV(\"%s: EQ_PARAM_BAND_FREQ_RANGE\", __func__);\n         param2 = *param_tmp;\n        if (param2 < 0 || param2 >= NUM_EQ_BANDS) {\n             p->status = -EINVAL;\n            if (param2 < 0) {\n                android_errorWriteLog(0x534e4554, \"32247948\");\n                ALOGW(\"\\tERROR EQ_PARAM_BAND_FREQ_RANGE band %d\", param2);\n            }\n            break;\n         }\n        equalizer_get_band_freq_range(eq_ctxt, param2, (uint32_t *)value,\n ((uint32_t *)value + 1));\n break;\n\n case EQ_PARAM_GET_BAND:\n\tALOGV(\"%s: EQ_PARAM_GET_BAND\", __func__);\n        param2 = *param_tmp;\n *(uint16_t *)value = (uint16_t)equalizer_get_band(eq_ctxt, param2);\n break;\n\n case EQ_PARAM_CUR_PRESET:\n\tALOGV(\"%s: EQ_PARAM_CUR_PRESET\", __func__);\n *(uint16_t *)value = (uint16_t)equalizer_get_preset(eq_ctxt);\n break;\n\n case EQ_PARAM_GET_NUM_OF_PRESETS:\n\tALOGV(\"%s: EQ_PARAM_GET_NUM_OF_PRESETS\", __func__);\n *(uint16_t *)value = (uint16_t)equalizer_get_num_presets(eq_ctxt);\n break;\n\n case EQ_PARAM_GET_PRESET_NAME:\n\tALOGV(\"%s: EQ_PARAM_GET_PRESET_NAME\", __func__);\n        param2 = *param_tmp;\n\tALOGV(\"param2: %d\", param2);\n if (param2 >= equalizer_get_num_presets(eq_ctxt)) {\n            p->status = -EINVAL;\n break;\n }\n        name = (char *)value;\n        strlcpy(name, equalizer_get_preset_name(eq_ctxt, param2), p->vsize - 1);\n        name[p->vsize - 1] = 0;\n        p->vsize = strlen(name) + 1;\n break;\n\n case EQ_PARAM_PROPERTIES: {\n\tALOGV(\"%s: EQ_PARAM_PROPERTIES\", __func__);\n int16_t *prop = (int16_t *)value;\n        prop[0] = (int16_t)equalizer_get_preset(eq_ctxt);\n        prop[1] = (int16_t)NUM_EQ_BANDS;\n for (i = 0; i < NUM_EQ_BANDS; i++) {\n            prop[2 + i] = (int16_t)equalizer_get_band_level(eq_ctxt, i);\n }\n } break;\n\n default:\n        p->status = -EINVAL;\n break;\n }\n\n return 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143964,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": " char *ldb_dn_escape_value(TALLOC_CTX *mem_ctx, struct ldb_val value)\n {\n        char *dst;\n        if (!value.length)\n                return NULL;\n \n\t/* allocate destination string, it will be at most 3 times the source */\n\tdst = talloc_array(mem_ctx, char, value.length * 3 + 1);\n\tif ( ! dst) {\n\t\ttalloc_free(dst);\n                return NULL;\n        }\n \n       ldb_dn_escape_internal(dst, (const char *)value.data, value.length);\n       dst = talloc_realloc(mem_ctx, dst, char, strlen(dst) + 1);\n \n        return dst;\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143969,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": " char *ldb_dn_escape_value(TALLOC_CTX *mem_ctx, struct ldb_val value)\n {\n        char *dst;\n       size_t len;\n        if (!value.length)\n                return NULL;\n \n\t/* allocate destination string, it will be at most 3 times the source */\n\tdst = talloc_array(mem_ctx, char, value.length * 3 + 1);\n\tif ( ! dst) {\n\t\ttalloc_free(dst);\n                return NULL;\n        }\n \n       len = ldb_dn_escape_internal(dst, (const char *)value.data, value.length);\n \n       dst = talloc_realloc(mem_ctx, dst, char, len + 1);\n       if ( ! dst) {\n               talloc_free(dst);\n               return NULL;\n       }\n       dst[len] = '\\0';\n        return dst;\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143970,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "int tpm_open(struct inode *inode, struct file *file)\n{\n\tint minor = iminor(inode);\n\tstruct tpm_chip *chip = NULL, *pos;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pos, &tpm_chip_list, list) {\n\t\tif (pos->vendor.miscdev.minor == minor) {\n\t\t\tchip = pos;\n\t\t\tget_device(chip->dev);\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (!chip)\n\t\treturn -ENODEV;\n\n\tif (test_and_set_bit(0, &chip->is_open)) {\n\t\tdev_dbg(chip->dev, \"Another process owns this TPM\\n\");\n\t\tput_device(chip->dev);\n \t\treturn -EBUSY;\n \t}\n \n\tchip->data_buffer = kmalloc(TPM_BUFSIZE * sizeof(u8), GFP_KERNEL);\n \tif (chip->data_buffer == NULL) {\n \t\tclear_bit(0, &chip->is_open);\n \t\tput_device(chip->dev);\n\t\treturn -ENOMEM;\n\t}\n\n\tatomic_set(&chip->data_pending, 0);\n\n\tfile->private_data = chip;\n\treturn 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144013,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "int tpm_open(struct inode *inode, struct file *file)\n{\n\tint minor = iminor(inode);\n\tstruct tpm_chip *chip = NULL, *pos;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pos, &tpm_chip_list, list) {\n\t\tif (pos->vendor.miscdev.minor == minor) {\n\t\t\tchip = pos;\n\t\t\tget_device(chip->dev);\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (!chip)\n\t\treturn -ENODEV;\n\n\tif (test_and_set_bit(0, &chip->is_open)) {\n\t\tdev_dbg(chip->dev, \"Another process owns this TPM\\n\");\n\t\tput_device(chip->dev);\n \t\treturn -EBUSY;\n \t}\n \n\tchip->data_buffer = kzalloc(TPM_BUFSIZE, GFP_KERNEL);\n \tif (chip->data_buffer == NULL) {\n \t\tclear_bit(0, &chip->is_open);\n \t\tput_device(chip->dev);\n\t\treturn -ENOMEM;\n\t}\n\n\tatomic_set(&chip->data_pending, 0);\n\n\tfile->private_data = chip;\n\treturn 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144014,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int sco_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sco_pinfo *pi = sco_pi(sk);\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state == BT_CONNECT2 &&\n \t    test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags)) {\n \t\thci_conn_accept(pi->conn->hcon, 0);\n \t\tsk->sk_state = BT_CONFIG;\n \n \t\trelease_sock(sk);\n \t\treturn 0;\n\t}\n\n\trelease_sock(sk);\n\n\treturn bt_sock_recvmsg(iocb, sock, msg, len, flags);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144017,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int sco_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sco_pinfo *pi = sco_pi(sk);\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state == BT_CONNECT2 &&\n \t    test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags)) {\n \t\thci_conn_accept(pi->conn->hcon, 0);\n \t\tsk->sk_state = BT_CONFIG;\n\t\tmsg->msg_namelen = 0;\n \n \t\trelease_sock(sk);\n \t\treturn 0;\n\t}\n\n\trelease_sock(sk);\n\n\treturn bt_sock_recvmsg(iocb, sock, msg, len, flags);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144018,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static long aio_read_events_ring(struct kioctx *ctx,\n\t\t\t\t struct io_event __user *event, long nr)\n{\n\tstruct aio_ring *ring;\n\tunsigned head, tail, pos;\n\tlong ret = 0;\n\tint copy_ret;\n\n\tmutex_lock(&ctx->ring_lock);\n\n\t/* Access to ->ring_pages here is protected by ctx->ring_lock. */\n\tring = kmap_atomic(ctx->ring_pages[0]);\n\thead = ring->head;\n\ttail = ring->tail;\n\tkunmap_atomic(ring);\n\n\tpr_debug(\"h%u t%u m%u\\n\", head, tail, ctx->nr_events);\n\n \tif (head == tail)\n \t\tgoto out;\n \n \twhile (ret < nr) {\n \t\tlong avail;\n \t\tstruct io_event *ev;\n\t\tstruct page *page;\n\n\t\tavail = (head <= tail ?  tail : ctx->nr_events) - head;\n\t\tif (head == tail)\n\t\t\tbreak;\n\n\t\tavail = min(avail, nr - ret);\n\t\tavail = min_t(long, avail, AIO_EVENTS_PER_PAGE -\n\t\t\t    ((head + AIO_EVENTS_OFFSET) % AIO_EVENTS_PER_PAGE));\n\n\t\tpos = head + AIO_EVENTS_OFFSET;\n\t\tpage = ctx->ring_pages[pos / AIO_EVENTS_PER_PAGE];\n\t\tpos %= AIO_EVENTS_PER_PAGE;\n\n\t\tev = kmap(page);\n\t\tcopy_ret = copy_to_user(event + ret, ev + pos,\n\t\t\t\t\tsizeof(*ev) * avail);\n\t\tkunmap(page);\n\n\t\tif (unlikely(copy_ret)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret += avail;\n\t\thead += avail;\n\t\thead %= ctx->nr_events;\n\t}\n\n\tring = kmap_atomic(ctx->ring_pages[0]);\n\tring->head = head;\n\tkunmap_atomic(ring);\n\tflush_dcache_page(ctx->ring_pages[0]);\n\n\tpr_debug(\"%li  h%u t%u\\n\", ret, head, tail);\nout:\n\tmutex_unlock(&ctx->ring_lock);\n\n\treturn ret;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144029,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static long aio_read_events_ring(struct kioctx *ctx,\n\t\t\t\t struct io_event __user *event, long nr)\n{\n\tstruct aio_ring *ring;\n\tunsigned head, tail, pos;\n\tlong ret = 0;\n\tint copy_ret;\n\n\tmutex_lock(&ctx->ring_lock);\n\n\t/* Access to ->ring_pages here is protected by ctx->ring_lock. */\n\tring = kmap_atomic(ctx->ring_pages[0]);\n\thead = ring->head;\n\ttail = ring->tail;\n\tkunmap_atomic(ring);\n\n\tpr_debug(\"h%u t%u m%u\\n\", head, tail, ctx->nr_events);\n\n \tif (head == tail)\n \t\tgoto out;\n \n\thead %= ctx->nr_events;\n\ttail %= ctx->nr_events;\n\n \twhile (ret < nr) {\n \t\tlong avail;\n \t\tstruct io_event *ev;\n\t\tstruct page *page;\n\n\t\tavail = (head <= tail ?  tail : ctx->nr_events) - head;\n\t\tif (head == tail)\n\t\t\tbreak;\n\n\t\tavail = min(avail, nr - ret);\n\t\tavail = min_t(long, avail, AIO_EVENTS_PER_PAGE -\n\t\t\t    ((head + AIO_EVENTS_OFFSET) % AIO_EVENTS_PER_PAGE));\n\n\t\tpos = head + AIO_EVENTS_OFFSET;\n\t\tpage = ctx->ring_pages[pos / AIO_EVENTS_PER_PAGE];\n\t\tpos %= AIO_EVENTS_PER_PAGE;\n\n\t\tev = kmap(page);\n\t\tcopy_ret = copy_to_user(event + ret, ev + pos,\n\t\t\t\t\tsizeof(*ev) * avail);\n\t\tkunmap(page);\n\n\t\tif (unlikely(copy_ret)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret += avail;\n\t\thead += avail;\n\t\thead %= ctx->nr_events;\n\t}\n\n\tring = kmap_atomic(ctx->ring_pages[0]);\n\tring->head = head;\n\tkunmap_atomic(ring);\n\tflush_dcache_page(ctx->ring_pages[0]);\n\n\tpr_debug(\"%li  h%u t%u\\n\", ret, head, tail);\nout:\n\tmutex_unlock(&ctx->ring_lock);\n\n\treturn ret;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144030,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "int btrfs_truncate_inode_items(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root,\n\t\t\t       struct inode *inode,\n\t\t\t       u64 new_size, u32 min_type)\n{\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tu64 extent_start = 0;\n\tu64 extent_num_bytes = 0;\n\tu64 extent_offset = 0;\n\tu64 item_end = 0;\n\tu64 last_size = new_size;\n\tu32 found_type = (u8)-1;\n\tint found_extent;\n\tint del_item;\n\tint pending_del_nr = 0;\n\tint pending_del_slot = 0;\n\tint extent_type = -1;\n\tint ret;\n\tint err = 0;\n\tu64 ino = btrfs_ino(inode);\n\tu64 bytes_deleted = 0;\n\tbool be_nice = 0;\n\tbool should_throttle = 0;\n\tbool should_end = 0;\n\n\tBUG_ON(new_size > 0 && min_type != BTRFS_EXTENT_DATA_KEY);\n\n\t/*\n\t * for non-free space inodes and ref cows, we want to back off from\n\t * time to time\n\t */\n\tif (!btrfs_is_free_space_inode(inode) &&\n\t    test_bit(BTRFS_ROOT_REF_COWS, &root->state))\n\t\tbe_nice = 1;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->reada = -1;\n\n\t/*\n\t * We want to drop from the next block forward in case this new size is\n\t * not block aligned since we will be keeping the last block of the\n\t * extent just the way it is.\n\t */\n\tif (test_bit(BTRFS_ROOT_REF_COWS, &root->state) ||\n\t    root == root->fs_info->tree_root)\n\t\tbtrfs_drop_extent_cache(inode, ALIGN(new_size,\n\t\t\t\t\troot->sectorsize), (u64)-1, 0);\n\n\t/*\n\t * This function is also used to drop the items in the log tree before\n\t * we relog the inode, so if root != BTRFS_I(inode)->root, it means\n\t * it is used to drop the loged items. So we shouldn't kill the delayed\n\t * items.\n\t */\n\tif (min_type == 0 && root == BTRFS_I(inode)->root)\n\t\tbtrfs_kill_delayed_inode_items(inode);\n\n\tkey.objectid = ino;\n\tkey.offset = (u64)-1;\n\tkey.type = (u8)-1;\n\nsearch_again:\n\t/*\n\t * with a 16K leaf size and 128MB extents, you can actually queue\n\t * up a huge file in a single leaf.  Most of the time that\n\t * bytes_deleted is > 0, it will be huge by the time we get here\n\t */\n\tif (be_nice && bytes_deleted > 32 * 1024 * 1024) {\n\t\tif (btrfs_should_end_transaction(trans, root)) {\n\t\t\terr = -EAGAIN;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\n\tpath->leave_spinning = 1;\n\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\tif (ret < 0) {\n\t\terr = ret;\n\t\tgoto out;\n\t}\n\n\tif (ret > 0) {\n\t\t/* there are no items in the tree for us to truncate, we're\n\t\t * done\n\t\t */\n\t\tif (path->slots[0] == 0)\n\t\t\tgoto out;\n\t\tpath->slots[0]--;\n\t}\n\n\twhile (1) {\n\t\tfi = NULL;\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\t\tfound_type = found_key.type;\n\n\t\tif (found_key.objectid != ino)\n\t\t\tbreak;\n\n\t\tif (found_type < min_type)\n\t\t\tbreak;\n\n\t\titem_end = found_key.offset;\n\t\tif (found_type == BTRFS_EXTENT_DATA_KEY) {\n\t\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\t\t\textent_type = btrfs_file_extent_type(leaf, fi);\n\t\t\tif (extent_type != BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\titem_end +=\n\t\t\t\t    btrfs_file_extent_num_bytes(leaf, fi);\n\t\t\t} else if (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\titem_end += btrfs_file_extent_inline_len(leaf,\n\t\t\t\t\t\t\t path->slots[0], fi);\n\t\t\t}\n\t\t\titem_end--;\n\t\t}\n\t\tif (found_type > min_type) {\n\t\t\tdel_item = 1;\n\t\t} else {\n\t\t\tif (item_end < new_size)\n\t\t\t\tbreak;\n\t\t\tif (found_key.offset >= new_size)\n\t\t\t\tdel_item = 1;\n\t\t\telse\n\t\t\t\tdel_item = 0;\n\t\t}\n\t\tfound_extent = 0;\n\t\t/* FIXME, shrink the extent if the ref count is only 1 */\n\t\tif (found_type != BTRFS_EXTENT_DATA_KEY)\n\t\t\tgoto delete;\n\n\t\tif (del_item)\n\t\t\tlast_size = found_key.offset;\n\t\telse\n\t\t\tlast_size = new_size;\n\n\t\tif (extent_type != BTRFS_FILE_EXTENT_INLINE) {\n\t\t\tu64 num_dec;\n\t\t\textent_start = btrfs_file_extent_disk_bytenr(leaf, fi);\n\t\t\tif (!del_item) {\n\t\t\t\tu64 orig_num_bytes =\n\t\t\t\t\tbtrfs_file_extent_num_bytes(leaf, fi);\n\t\t\t\textent_num_bytes = ALIGN(new_size -\n\t\t\t\t\t\tfound_key.offset,\n\t\t\t\t\t\troot->sectorsize);\n\t\t\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\t\t extent_num_bytes);\n\t\t\t\tnum_dec = (orig_num_bytes -\n\t\t\t\t\t   extent_num_bytes);\n\t\t\t\tif (test_bit(BTRFS_ROOT_REF_COWS,\n\t\t\t\t\t     &root->state) &&\n\t\t\t\t    extent_start != 0)\n\t\t\t\t\tinode_sub_bytes(inode, num_dec);\n\t\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t\t} else {\n\t\t\t\textent_num_bytes =\n\t\t\t\t\tbtrfs_file_extent_disk_num_bytes(leaf,\n\t\t\t\t\t\t\t\t\t fi);\n\t\t\t\textent_offset = found_key.offset -\n\t\t\t\t\tbtrfs_file_extent_offset(leaf, fi);\n\n\t\t\t\t/* FIXME blocksize != 4096 */\n\t\t\t\tnum_dec = btrfs_file_extent_num_bytes(leaf, fi);\n\t\t\t\tif (extent_start != 0) {\n\t\t\t\t\tfound_extent = 1;\n\t\t\t\t\tif (test_bit(BTRFS_ROOT_REF_COWS,\n\t\t\t\t\t\t     &root->state))\n\t\t\t\t\t\tinode_sub_bytes(inode, num_dec);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t/*\n\t\t\t * we can't truncate inline items that have had\n \t\t\t * special encodings\n \t\t\t */\n \t\t\tif (!del_item &&\n\t\t\t    btrfs_file_extent_compression(leaf, fi) == 0 &&\n \t\t\t    btrfs_file_extent_encryption(leaf, fi) == 0 &&\n \t\t\t    btrfs_file_extent_other_encoding(leaf, fi) == 0) {\n\t\t\t\tu32 size = new_size - found_key.offset;\n\t\t\t\tif (test_bit(BTRFS_ROOT_REF_COWS, &root->state))\n\t\t\t\t\tinode_sub_bytes(inode, item_end + 1 -\n\t\t\t\t\t\t\tnew_size);\n \n \t\t\t\t/*\n\t\t\t\t * update the ram bytes to properly reflect\n\t\t\t\t * the new size of our item\n \t\t\t\t */\n\t\t\t\tbtrfs_set_file_extent_ram_bytes(leaf, fi, size);\n\t\t\t\tsize =\n\t\t\t\t    btrfs_file_extent_calc_inline_size(size);\n\t\t\t\tbtrfs_truncate_item(root, path, size, 1);\n \t\t\t} else if (test_bit(BTRFS_ROOT_REF_COWS,\n \t\t\t\t\t    &root->state)) {\n\t\t\t\tinode_sub_bytes(inode, item_end + 1 -\n\t\t\t\t\t\tfound_key.offset);\n \t\t\t}\n \t\t}\n delete:\n\t\tif (del_item) {\n\t\t\tif (!pending_del_nr) {\n\t\t\t\t/* no pending yet, add ourselves */\n\t\t\t\tpending_del_slot = path->slots[0];\n\t\t\t\tpending_del_nr = 1;\n\t\t\t} else if (pending_del_nr &&\n\t\t\t\t   path->slots[0] + 1 == pending_del_slot) {\n\t\t\t\t/* hop on the pending chunk */\n\t\t\t\tpending_del_nr++;\n\t\t\t\tpending_del_slot = path->slots[0];\n\t\t\t} else {\n\t\t\t\tBUG();\n\t\t\t}\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t\tshould_throttle = 0;\n\n\t\tif (found_extent &&\n\t\t    (test_bit(BTRFS_ROOT_REF_COWS, &root->state) ||\n\t\t     root == root->fs_info->tree_root)) {\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tbytes_deleted += extent_num_bytes;\n\t\t\tret = btrfs_free_extent(trans, root, extent_start,\n\t\t\t\t\t\textent_num_bytes, 0,\n\t\t\t\t\t\tbtrfs_header_owner(leaf),\n\t\t\t\t\t\tino, extent_offset, 0);\n\t\t\tBUG_ON(ret);\n\t\t\tif (btrfs_should_throttle_delayed_refs(trans, root))\n\t\t\t\tbtrfs_async_run_delayed_refs(root,\n\t\t\t\t\ttrans->delayed_ref_updates * 2, 0);\n\t\t\tif (be_nice) {\n\t\t\t\tif (truncate_space_check(trans, root,\n\t\t\t\t\t\t\t extent_num_bytes)) {\n\t\t\t\t\tshould_end = 1;\n\t\t\t\t}\n\t\t\t\tif (btrfs_should_throttle_delayed_refs(trans,\n\t\t\t\t\t\t\t\t       root)) {\n\t\t\t\t\tshould_throttle = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (found_type == BTRFS_INODE_ITEM_KEY)\n\t\t\tbreak;\n\n\t\tif (path->slots[0] == 0 ||\n\t\t    path->slots[0] != pending_del_slot ||\n\t\t    should_throttle || should_end) {\n\t\t\tif (pending_del_nr) {\n\t\t\t\tret = btrfs_del_items(trans, root, path,\n\t\t\t\t\t\tpending_del_slot,\n\t\t\t\t\t\tpending_del_nr);\n\t\t\t\tif (ret) {\n\t\t\t\t\tbtrfs_abort_transaction(trans,\n\t\t\t\t\t\t\t\troot, ret);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tpending_del_nr = 0;\n\t\t\t}\n\t\t\tbtrfs_release_path(path);\n\t\t\tif (should_throttle) {\n\t\t\t\tunsigned long updates = trans->delayed_ref_updates;\n\t\t\t\tif (updates) {\n\t\t\t\t\ttrans->delayed_ref_updates = 0;\n\t\t\t\t\tret = btrfs_run_delayed_refs(trans, root, updates * 2);\n\t\t\t\t\tif (ret && !err)\n\t\t\t\t\t\terr = ret;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\t * if we failed to refill our space rsv, bail out\n\t\t\t * and let the transaction restart\n\t\t\t */\n\t\t\tif (should_end) {\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto search_again;\n\t\t} else {\n\t\t\tpath->slots[0]--;\n\t\t}\n\t}\nout:\n\tif (pending_del_nr) {\n\t\tret = btrfs_del_items(trans, root, path, pending_del_slot,\n\t\t\t\t      pending_del_nr);\n\t\tif (ret)\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t}\nerror:\n\tif (root->root_key.objectid != BTRFS_TREE_LOG_OBJECTID)\n\t\tbtrfs_ordered_update_i_size(inode, last_size, NULL);\n\n\tbtrfs_free_path(path);\n\n\tif (be_nice && bytes_deleted > 32 * 1024 * 1024) {\n\t\tunsigned long updates = trans->delayed_ref_updates;\n\t\tif (updates) {\n\t\t\ttrans->delayed_ref_updates = 0;\n\t\t\tret = btrfs_run_delayed_refs(trans, root, updates * 2);\n\t\t\tif (ret && !err)\n\t\t\t\terr = ret;\n\t\t}\n\t}\n\treturn err;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144035,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "int btrfs_truncate_inode_items(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root,\n\t\t\t       struct inode *inode,\n\t\t\t       u64 new_size, u32 min_type)\n{\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tu64 extent_start = 0;\n\tu64 extent_num_bytes = 0;\n\tu64 extent_offset = 0;\n\tu64 item_end = 0;\n\tu64 last_size = new_size;\n\tu32 found_type = (u8)-1;\n\tint found_extent;\n\tint del_item;\n\tint pending_del_nr = 0;\n\tint pending_del_slot = 0;\n\tint extent_type = -1;\n\tint ret;\n\tint err = 0;\n\tu64 ino = btrfs_ino(inode);\n\tu64 bytes_deleted = 0;\n\tbool be_nice = 0;\n\tbool should_throttle = 0;\n\tbool should_end = 0;\n\n\tBUG_ON(new_size > 0 && min_type != BTRFS_EXTENT_DATA_KEY);\n\n\t/*\n\t * for non-free space inodes and ref cows, we want to back off from\n\t * time to time\n\t */\n\tif (!btrfs_is_free_space_inode(inode) &&\n\t    test_bit(BTRFS_ROOT_REF_COWS, &root->state))\n\t\tbe_nice = 1;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->reada = -1;\n\n\t/*\n\t * We want to drop from the next block forward in case this new size is\n\t * not block aligned since we will be keeping the last block of the\n\t * extent just the way it is.\n\t */\n\tif (test_bit(BTRFS_ROOT_REF_COWS, &root->state) ||\n\t    root == root->fs_info->tree_root)\n\t\tbtrfs_drop_extent_cache(inode, ALIGN(new_size,\n\t\t\t\t\troot->sectorsize), (u64)-1, 0);\n\n\t/*\n\t * This function is also used to drop the items in the log tree before\n\t * we relog the inode, so if root != BTRFS_I(inode)->root, it means\n\t * it is used to drop the loged items. So we shouldn't kill the delayed\n\t * items.\n\t */\n\tif (min_type == 0 && root == BTRFS_I(inode)->root)\n\t\tbtrfs_kill_delayed_inode_items(inode);\n\n\tkey.objectid = ino;\n\tkey.offset = (u64)-1;\n\tkey.type = (u8)-1;\n\nsearch_again:\n\t/*\n\t * with a 16K leaf size and 128MB extents, you can actually queue\n\t * up a huge file in a single leaf.  Most of the time that\n\t * bytes_deleted is > 0, it will be huge by the time we get here\n\t */\n\tif (be_nice && bytes_deleted > 32 * 1024 * 1024) {\n\t\tif (btrfs_should_end_transaction(trans, root)) {\n\t\t\terr = -EAGAIN;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\n\tpath->leave_spinning = 1;\n\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\tif (ret < 0) {\n\t\terr = ret;\n\t\tgoto out;\n\t}\n\n\tif (ret > 0) {\n\t\t/* there are no items in the tree for us to truncate, we're\n\t\t * done\n\t\t */\n\t\tif (path->slots[0] == 0)\n\t\t\tgoto out;\n\t\tpath->slots[0]--;\n\t}\n\n\twhile (1) {\n\t\tfi = NULL;\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\t\tfound_type = found_key.type;\n\n\t\tif (found_key.objectid != ino)\n\t\t\tbreak;\n\n\t\tif (found_type < min_type)\n\t\t\tbreak;\n\n\t\titem_end = found_key.offset;\n\t\tif (found_type == BTRFS_EXTENT_DATA_KEY) {\n\t\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\t\t\textent_type = btrfs_file_extent_type(leaf, fi);\n\t\t\tif (extent_type != BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\titem_end +=\n\t\t\t\t    btrfs_file_extent_num_bytes(leaf, fi);\n\t\t\t} else if (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\titem_end += btrfs_file_extent_inline_len(leaf,\n\t\t\t\t\t\t\t path->slots[0], fi);\n\t\t\t}\n\t\t\titem_end--;\n\t\t}\n\t\tif (found_type > min_type) {\n\t\t\tdel_item = 1;\n\t\t} else {\n\t\t\tif (item_end < new_size)\n\t\t\t\tbreak;\n\t\t\tif (found_key.offset >= new_size)\n\t\t\t\tdel_item = 1;\n\t\t\telse\n\t\t\t\tdel_item = 0;\n\t\t}\n\t\tfound_extent = 0;\n\t\t/* FIXME, shrink the extent if the ref count is only 1 */\n\t\tif (found_type != BTRFS_EXTENT_DATA_KEY)\n\t\t\tgoto delete;\n\n\t\tif (del_item)\n\t\t\tlast_size = found_key.offset;\n\t\telse\n\t\t\tlast_size = new_size;\n\n\t\tif (extent_type != BTRFS_FILE_EXTENT_INLINE) {\n\t\t\tu64 num_dec;\n\t\t\textent_start = btrfs_file_extent_disk_bytenr(leaf, fi);\n\t\t\tif (!del_item) {\n\t\t\t\tu64 orig_num_bytes =\n\t\t\t\t\tbtrfs_file_extent_num_bytes(leaf, fi);\n\t\t\t\textent_num_bytes = ALIGN(new_size -\n\t\t\t\t\t\tfound_key.offset,\n\t\t\t\t\t\troot->sectorsize);\n\t\t\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\t\t extent_num_bytes);\n\t\t\t\tnum_dec = (orig_num_bytes -\n\t\t\t\t\t   extent_num_bytes);\n\t\t\t\tif (test_bit(BTRFS_ROOT_REF_COWS,\n\t\t\t\t\t     &root->state) &&\n\t\t\t\t    extent_start != 0)\n\t\t\t\t\tinode_sub_bytes(inode, num_dec);\n\t\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t\t} else {\n\t\t\t\textent_num_bytes =\n\t\t\t\t\tbtrfs_file_extent_disk_num_bytes(leaf,\n\t\t\t\t\t\t\t\t\t fi);\n\t\t\t\textent_offset = found_key.offset -\n\t\t\t\t\tbtrfs_file_extent_offset(leaf, fi);\n\n\t\t\t\t/* FIXME blocksize != 4096 */\n\t\t\t\tnum_dec = btrfs_file_extent_num_bytes(leaf, fi);\n\t\t\t\tif (extent_start != 0) {\n\t\t\t\t\tfound_extent = 1;\n\t\t\t\t\tif (test_bit(BTRFS_ROOT_REF_COWS,\n\t\t\t\t\t\t     &root->state))\n\t\t\t\t\t\tinode_sub_bytes(inode, num_dec);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t/*\n\t\t\t * we can't truncate inline items that have had\n \t\t\t * special encodings\n \t\t\t */\n \t\t\tif (!del_item &&\n \t\t\t    btrfs_file_extent_encryption(leaf, fi) == 0 &&\n \t\t\t    btrfs_file_extent_other_encoding(leaf, fi) == 0) {\n \n \t\t\t\t/*\n\t\t\t\t * Need to release path in order to truncate a\n\t\t\t\t * compressed extent. So delete any accumulated\n\t\t\t\t * extent items so far.\n \t\t\t\t */\n\t\t\t\tif (btrfs_file_extent_compression(leaf, fi) !=\n\t\t\t\t    BTRFS_COMPRESS_NONE && pending_del_nr) {\n\t\t\t\t\terr = btrfs_del_items(trans, root, path,\n\t\t\t\t\t\t\t      pending_del_slot,\n\t\t\t\t\t\t\t      pending_del_nr);\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tbtrfs_abort_transaction(trans,\n\t\t\t\t\t\t\t\t\troot,\n\t\t\t\t\t\t\t\t\terr);\n\t\t\t\t\t\tgoto error;\n\t\t\t\t\t}\n\t\t\t\t\tpending_del_nr = 0;\n\t\t\t\t}\n\n\t\t\t\terr = truncate_inline_extent(inode, path,\n\t\t\t\t\t\t\t     &found_key,\n\t\t\t\t\t\t\t     item_end,\n\t\t\t\t\t\t\t     new_size);\n\t\t\t\tif (err) {\n\t\t\t\t\tbtrfs_abort_transaction(trans,\n\t\t\t\t\t\t\t\troot, err);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n \t\t\t} else if (test_bit(BTRFS_ROOT_REF_COWS,\n \t\t\t\t\t    &root->state)) {\n\t\t\t\tinode_sub_bytes(inode, item_end + 1 - new_size);\n \t\t\t}\n \t\t}\n delete:\n\t\tif (del_item) {\n\t\t\tif (!pending_del_nr) {\n\t\t\t\t/* no pending yet, add ourselves */\n\t\t\t\tpending_del_slot = path->slots[0];\n\t\t\t\tpending_del_nr = 1;\n\t\t\t} else if (pending_del_nr &&\n\t\t\t\t   path->slots[0] + 1 == pending_del_slot) {\n\t\t\t\t/* hop on the pending chunk */\n\t\t\t\tpending_del_nr++;\n\t\t\t\tpending_del_slot = path->slots[0];\n\t\t\t} else {\n\t\t\t\tBUG();\n\t\t\t}\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t\tshould_throttle = 0;\n\n\t\tif (found_extent &&\n\t\t    (test_bit(BTRFS_ROOT_REF_COWS, &root->state) ||\n\t\t     root == root->fs_info->tree_root)) {\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tbytes_deleted += extent_num_bytes;\n\t\t\tret = btrfs_free_extent(trans, root, extent_start,\n\t\t\t\t\t\textent_num_bytes, 0,\n\t\t\t\t\t\tbtrfs_header_owner(leaf),\n\t\t\t\t\t\tino, extent_offset, 0);\n\t\t\tBUG_ON(ret);\n\t\t\tif (btrfs_should_throttle_delayed_refs(trans, root))\n\t\t\t\tbtrfs_async_run_delayed_refs(root,\n\t\t\t\t\ttrans->delayed_ref_updates * 2, 0);\n\t\t\tif (be_nice) {\n\t\t\t\tif (truncate_space_check(trans, root,\n\t\t\t\t\t\t\t extent_num_bytes)) {\n\t\t\t\t\tshould_end = 1;\n\t\t\t\t}\n\t\t\t\tif (btrfs_should_throttle_delayed_refs(trans,\n\t\t\t\t\t\t\t\t       root)) {\n\t\t\t\t\tshould_throttle = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (found_type == BTRFS_INODE_ITEM_KEY)\n\t\t\tbreak;\n\n\t\tif (path->slots[0] == 0 ||\n\t\t    path->slots[0] != pending_del_slot ||\n\t\t    should_throttle || should_end) {\n\t\t\tif (pending_del_nr) {\n\t\t\t\tret = btrfs_del_items(trans, root, path,\n\t\t\t\t\t\tpending_del_slot,\n\t\t\t\t\t\tpending_del_nr);\n\t\t\t\tif (ret) {\n\t\t\t\t\tbtrfs_abort_transaction(trans,\n\t\t\t\t\t\t\t\troot, ret);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tpending_del_nr = 0;\n\t\t\t}\n\t\t\tbtrfs_release_path(path);\n\t\t\tif (should_throttle) {\n\t\t\t\tunsigned long updates = trans->delayed_ref_updates;\n\t\t\t\tif (updates) {\n\t\t\t\t\ttrans->delayed_ref_updates = 0;\n\t\t\t\t\tret = btrfs_run_delayed_refs(trans, root, updates * 2);\n\t\t\t\t\tif (ret && !err)\n\t\t\t\t\t\terr = ret;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\t * if we failed to refill our space rsv, bail out\n\t\t\t * and let the transaction restart\n\t\t\t */\n\t\t\tif (should_end) {\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto search_again;\n\t\t} else {\n\t\t\tpath->slots[0]--;\n\t\t}\n\t}\nout:\n\tif (pending_del_nr) {\n\t\tret = btrfs_del_items(trans, root, path, pending_del_slot,\n\t\t\t\t      pending_del_nr);\n\t\tif (ret)\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t}\nerror:\n\tif (root->root_key.objectid != BTRFS_TREE_LOG_OBJECTID)\n\t\tbtrfs_ordered_update_i_size(inode, last_size, NULL);\n\n\tbtrfs_free_path(path);\n\n\tif (be_nice && bytes_deleted > 32 * 1024 * 1024) {\n\t\tunsigned long updates = trans->delayed_ref_updates;\n\t\tif (updates) {\n\t\t\ttrans->delayed_ref_updates = 0;\n\t\t\tret = btrfs_run_delayed_refs(trans, root, updates * 2);\n\t\t\tif (ret && !err)\n\t\t\t\terr = ret;\n\t\t}\n\t}\n\treturn err;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144036,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "svcauth_gss_accept_sec_context(struct svc_req *rqst,\n\t\t\t       struct rpc_gss_init_res *gr)\n{\n\tstruct svc_rpc_gss_data\t*gd;\n\tstruct rpc_gss_cred\t*gc;\n\tgss_buffer_desc\t\t recv_tok, seqbuf;\n\tgss_OID\t\t\t mech;\n\tOM_uint32\t\t maj_stat = 0, min_stat = 0, ret_flags, seq;\n\n\tlog_debug(\"in svcauth_gss_accept_context()\");\n\n\tgd = SVCAUTH_PRIVATE(rqst->rq_xprt->xp_auth);\n\tgc = (struct rpc_gss_cred *)rqst->rq_clntcred;\n\tmemset(gr, 0, sizeof(*gr));\n\n\t/* Deserialize arguments. */\n\tmemset(&recv_tok, 0, sizeof(recv_tok));\n\n\tif (!svc_getargs(rqst->rq_xprt, xdr_rpc_gss_init_args,\n\t\t\t (caddr_t)&recv_tok))\n\t\treturn (FALSE);\n\n\tgr->gr_major = gss_accept_sec_context(&gr->gr_minor,\n\t\t\t\t\t      &gd->ctx,\n\t\t\t\t\t      svcauth_gss_creds,\n\t\t\t\t\t      &recv_tok,\n\t\t\t\t\t      GSS_C_NO_CHANNEL_BINDINGS,\n\t\t\t\t\t      &gd->client_name,\n\t\t\t\t\t      &mech,\n\t\t\t\t\t      &gr->gr_token,\n\t\t\t\t\t      &ret_flags,\n\t\t\t\t\t      NULL,\n\t\t\t\t\t      NULL);\n\n\tsvc_freeargs(rqst->rq_xprt, xdr_rpc_gss_init_args, (caddr_t)&recv_tok);\n\n\tlog_status(\"accept_sec_context\", gr->gr_major, gr->gr_minor);\n\tif (gr->gr_major != GSS_S_COMPLETE &&\n\t    gr->gr_major != GSS_S_CONTINUE_NEEDED) {\n\t\tbadauth(gr->gr_major, gr->gr_minor, rqst->rq_xprt);\n \t\tgd->ctx = GSS_C_NO_CONTEXT;\n \t\tgoto errout;\n \t}\n\t/*\n\t * ANDROS: krb5 mechglue returns ctx of size 8 - two pointers,\n\t * one to the mechanism oid, one to the internal_ctx_id\n\t */\n\tif ((gr->gr_ctx.value = mem_alloc(sizeof(gss_union_ctx_id_desc))) == NULL) {\n\t\tfprintf(stderr, \"svcauth_gss_accept_context: out of memory\\n\");\n\t\tgoto errout;\n\t}\n\tmemcpy(gr->gr_ctx.value, gd->ctx, sizeof(gss_union_ctx_id_desc));\n\tgr->gr_ctx.length = sizeof(gss_union_ctx_id_desc);\n \n \t/* gr->gr_win = 0x00000005; ANDROS: for debugging linux kernel version...  */\n \tgr->gr_win = sizeof(gd->seqmask) * 8;\n\n\t/* Save client info. */\n\tgd->sec.mech = mech;\n\tgd->sec.qop = GSS_C_QOP_DEFAULT;\n\tgd->sec.svc = gc->gc_svc;\n\tgd->seq = gc->gc_seq;\n\tgd->win = gr->gr_win;\n\n\tif (gr->gr_major == GSS_S_COMPLETE) {\n#ifdef SPKM\n\t\t/* spkm3: no src_name (anonymous) */\n\t\tif(!g_OID_equal(gss_mech_spkm3, mech)) {\n#endif\n\t\t    maj_stat = gss_display_name(&min_stat, gd->client_name,\n\t\t\t\t\t    &gd->cname, &gd->sec.mech);\n#ifdef SPKM\n\t\t}\n#endif\n\t\tif (maj_stat != GSS_S_COMPLETE) {\n\t\t\tlog_status(\"display_name\", maj_stat, min_stat);\n\t\t\tgoto errout;\n\t\t}\n#ifdef DEBUG\n#ifdef HAVE_HEIMDAL\n\t\tlog_debug(\"accepted context for %.*s with \"\n\t\t\t  \"<mech {}, qop %d, svc %d>\",\n\t\t\t  gd->cname.length, (char *)gd->cname.value,\n\t\t\t  gd->sec.qop, gd->sec.svc);\n#else\n\t\t{\n\t\t\tgss_buffer_desc mechname;\n\n\t\t\tgss_oid_to_str(&min_stat, mech, &mechname);\n\n\t\t\tlog_debug(\"accepted context for %.*s with \"\n\t\t\t\t  \"<mech %.*s, qop %d, svc %d>\",\n\t\t\t\t  gd->cname.length, (char *)gd->cname.value,\n\t\t\t\t  mechname.length, (char *)mechname.value,\n\t\t\t\t  gd->sec.qop, gd->sec.svc);\n\n\t\t\tgss_release_buffer(&min_stat, &mechname);\n\t\t}\n#endif\n#endif /* DEBUG */\n\t\tseq = htonl(gr->gr_win);\n\t\tseqbuf.value = &seq;\n\t\tseqbuf.length = sizeof(seq);\n\n\t\tgss_release_buffer(&min_stat, &gd->checksum);\n\t\tmaj_stat = gss_sign(&min_stat, gd->ctx, GSS_C_QOP_DEFAULT,\n\t\t\t\t    &seqbuf, &gd->checksum);\n\n\t\tif (maj_stat != GSS_S_COMPLETE) {\n\t\t\tgoto errout;\n\t\t}\n\n\n\t\trqst->rq_xprt->xp_verf.oa_flavor = RPCSEC_GSS;\n\t\trqst->rq_xprt->xp_verf.oa_base = gd->checksum.value;\n\t\trqst->rq_xprt->xp_verf.oa_length = gd->checksum.length;\n\t}\n\treturn (TRUE);\nerrout:\n\tgss_release_buffer(&min_stat, &gr->gr_token);\n\treturn (FALSE);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144043,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "svcauth_gss_accept_sec_context(struct svc_req *rqst,\n\t\t\t       struct rpc_gss_init_res *gr)\n{\n\tstruct svc_rpc_gss_data\t*gd;\n\tstruct rpc_gss_cred\t*gc;\n\tgss_buffer_desc\t\t recv_tok, seqbuf;\n\tgss_OID\t\t\t mech;\n\tOM_uint32\t\t maj_stat = 0, min_stat = 0, ret_flags, seq;\n\n\tlog_debug(\"in svcauth_gss_accept_context()\");\n\n\tgd = SVCAUTH_PRIVATE(rqst->rq_xprt->xp_auth);\n\tgc = (struct rpc_gss_cred *)rqst->rq_clntcred;\n\tmemset(gr, 0, sizeof(*gr));\n\n\t/* Deserialize arguments. */\n\tmemset(&recv_tok, 0, sizeof(recv_tok));\n\n\tif (!svc_getargs(rqst->rq_xprt, xdr_rpc_gss_init_args,\n\t\t\t (caddr_t)&recv_tok))\n\t\treturn (FALSE);\n\n\tgr->gr_major = gss_accept_sec_context(&gr->gr_minor,\n\t\t\t\t\t      &gd->ctx,\n\t\t\t\t\t      svcauth_gss_creds,\n\t\t\t\t\t      &recv_tok,\n\t\t\t\t\t      GSS_C_NO_CHANNEL_BINDINGS,\n\t\t\t\t\t      &gd->client_name,\n\t\t\t\t\t      &mech,\n\t\t\t\t\t      &gr->gr_token,\n\t\t\t\t\t      &ret_flags,\n\t\t\t\t\t      NULL,\n\t\t\t\t\t      NULL);\n\n\tsvc_freeargs(rqst->rq_xprt, xdr_rpc_gss_init_args, (caddr_t)&recv_tok);\n\n\tlog_status(\"accept_sec_context\", gr->gr_major, gr->gr_minor);\n\tif (gr->gr_major != GSS_S_COMPLETE &&\n\t    gr->gr_major != GSS_S_CONTINUE_NEEDED) {\n\t\tbadauth(gr->gr_major, gr->gr_minor, rqst->rq_xprt);\n \t\tgd->ctx = GSS_C_NO_CONTEXT;\n \t\tgoto errout;\n \t}\n\tgr->gr_ctx.value = \"xxxx\";\n\tgr->gr_ctx.length = 4;\n \n \t/* gr->gr_win = 0x00000005; ANDROS: for debugging linux kernel version...  */\n \tgr->gr_win = sizeof(gd->seqmask) * 8;\n\n\t/* Save client info. */\n\tgd->sec.mech = mech;\n\tgd->sec.qop = GSS_C_QOP_DEFAULT;\n\tgd->sec.svc = gc->gc_svc;\n\tgd->seq = gc->gc_seq;\n\tgd->win = gr->gr_win;\n\n\tif (gr->gr_major == GSS_S_COMPLETE) {\n#ifdef SPKM\n\t\t/* spkm3: no src_name (anonymous) */\n\t\tif(!g_OID_equal(gss_mech_spkm3, mech)) {\n#endif\n\t\t    maj_stat = gss_display_name(&min_stat, gd->client_name,\n\t\t\t\t\t    &gd->cname, &gd->sec.mech);\n#ifdef SPKM\n\t\t}\n#endif\n\t\tif (maj_stat != GSS_S_COMPLETE) {\n\t\t\tlog_status(\"display_name\", maj_stat, min_stat);\n\t\t\tgoto errout;\n\t\t}\n#ifdef DEBUG\n#ifdef HAVE_HEIMDAL\n\t\tlog_debug(\"accepted context for %.*s with \"\n\t\t\t  \"<mech {}, qop %d, svc %d>\",\n\t\t\t  gd->cname.length, (char *)gd->cname.value,\n\t\t\t  gd->sec.qop, gd->sec.svc);\n#else\n\t\t{\n\t\t\tgss_buffer_desc mechname;\n\n\t\t\tgss_oid_to_str(&min_stat, mech, &mechname);\n\n\t\t\tlog_debug(\"accepted context for %.*s with \"\n\t\t\t\t  \"<mech %.*s, qop %d, svc %d>\",\n\t\t\t\t  gd->cname.length, (char *)gd->cname.value,\n\t\t\t\t  mechname.length, (char *)mechname.value,\n\t\t\t\t  gd->sec.qop, gd->sec.svc);\n\n\t\t\tgss_release_buffer(&min_stat, &mechname);\n\t\t}\n#endif\n#endif /* DEBUG */\n\t\tseq = htonl(gr->gr_win);\n\t\tseqbuf.value = &seq;\n\t\tseqbuf.length = sizeof(seq);\n\n\t\tgss_release_buffer(&min_stat, &gd->checksum);\n\t\tmaj_stat = gss_sign(&min_stat, gd->ctx, GSS_C_QOP_DEFAULT,\n\t\t\t\t    &seqbuf, &gd->checksum);\n\n\t\tif (maj_stat != GSS_S_COMPLETE) {\n\t\t\tgoto errout;\n\t\t}\n\n\n\t\trqst->rq_xprt->xp_verf.oa_flavor = RPCSEC_GSS;\n\t\trqst->rq_xprt->xp_verf.oa_base = gd->checksum.value;\n\t\trqst->rq_xprt->xp_verf.oa_length = gd->checksum.length;\n\t}\n\treturn (TRUE);\nerrout:\n\tgss_release_buffer(&min_stat, &gr->gr_token);\n\treturn (FALSE);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144044,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "int sbusfb_ioctl_helper(unsigned long cmd, unsigned long arg,\n\t\t\tstruct fb_info *info,\n\t\t\tint type, int fb_depth, unsigned long fb_size)\n{\n\tswitch(cmd) {\n\tcase FBIOGTYPE: {\n\t\tstruct fbtype __user *f = (struct fbtype __user *) arg;\n\n\t\tif (put_user(type, &f->fb_type) ||\n\t\t    __put_user(info->var.yres, &f->fb_height) ||\n\t\t    __put_user(info->var.xres, &f->fb_width) ||\n\t\t    __put_user(fb_depth, &f->fb_depth) ||\n\t\t    __put_user(0, &f->fb_cmsize) ||\n\t\t    __put_user(fb_size, &f->fb_cmsize))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\tcase FBIOPUTCMAP_SPARC: {\n\t\tstruct fbcmap __user *c = (struct fbcmap __user *) arg;\n\t\tstruct fb_cmap cmap;\n\t\tu16 red, green, blue;\n\t\tu8 red8, green8, blue8;\n \t\tunsigned char __user *ured;\n \t\tunsigned char __user *ugreen;\n \t\tunsigned char __user *ublue;\n\t\tint index, count, i;\n \n \t\tif (get_user(index, &c->index) ||\n \t\t    __get_user(count, &c->count) ||\n\t\t    __get_user(ured, &c->red) ||\n\t\t    __get_user(ugreen, &c->green) ||\n\t\t    __get_user(ublue, &c->blue))\n\t\t\treturn -EFAULT;\n\n\t\tcmap.len = 1;\n\t\tcmap.red = &red;\n\t\tcmap.green = &green;\n\t\tcmap.blue = &blue;\n\t\tcmap.transp = NULL;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tint err;\n\n\t\t\tif (get_user(red8, &ured[i]) ||\n\t\t\t    get_user(green8, &ugreen[i]) ||\n\t\t\t    get_user(blue8, &ublue[i]))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tred = red8 << 8;\n\t\t\tgreen = green8 << 8;\n\t\t\tblue = blue8 << 8;\n\n\t\t\tcmap.start = index + i;\n\t\t\terr = fb_set_cmap(&cmap, info);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\treturn 0;\n\t}\n\tcase FBIOGETCMAP_SPARC: {\n\t\tstruct fbcmap __user *c = (struct fbcmap __user *) arg;\n\t\tunsigned char __user *ured;\n \t\tunsigned char __user *ugreen;\n \t\tunsigned char __user *ublue;\n \t\tstruct fb_cmap *cmap = &info->cmap;\n\t\tint index, count, i;\n \t\tu8 red, green, blue;\n \n \t\tif (get_user(index, &c->index) ||\n\t\t    __get_user(count, &c->count) ||\n\t\t    __get_user(ured, &c->red) ||\n\t\t    __get_user(ugreen, &c->green) ||\n\t\t    __get_user(ublue, &c->blue))\n\t\t\treturn -EFAULT;\n\n\t\tif (index + count > cmap->len)\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tred = cmap->red[index + i] >> 8;\n\t\t\tgreen = cmap->green[index + i] >> 8;\n\t\t\tblue = cmap->blue[index + i] >> 8;\n\t\t\tif (put_user(red, &ured[i]) ||\n\t\t\t    put_user(green, &ugreen[i]) ||\n\t\t\t    put_user(blue, &ublue[i]))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t\treturn 0;\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144159,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "int sbusfb_ioctl_helper(unsigned long cmd, unsigned long arg,\n\t\t\tstruct fb_info *info,\n\t\t\tint type, int fb_depth, unsigned long fb_size)\n{\n\tswitch(cmd) {\n\tcase FBIOGTYPE: {\n\t\tstruct fbtype __user *f = (struct fbtype __user *) arg;\n\n\t\tif (put_user(type, &f->fb_type) ||\n\t\t    __put_user(info->var.yres, &f->fb_height) ||\n\t\t    __put_user(info->var.xres, &f->fb_width) ||\n\t\t    __put_user(fb_depth, &f->fb_depth) ||\n\t\t    __put_user(0, &f->fb_cmsize) ||\n\t\t    __put_user(fb_size, &f->fb_cmsize))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\tcase FBIOPUTCMAP_SPARC: {\n\t\tstruct fbcmap __user *c = (struct fbcmap __user *) arg;\n\t\tstruct fb_cmap cmap;\n\t\tu16 red, green, blue;\n\t\tu8 red8, green8, blue8;\n \t\tunsigned char __user *ured;\n \t\tunsigned char __user *ugreen;\n \t\tunsigned char __user *ublue;\n\t\tunsigned int index, count, i;\n \n \t\tif (get_user(index, &c->index) ||\n \t\t    __get_user(count, &c->count) ||\n\t\t    __get_user(ured, &c->red) ||\n\t\t    __get_user(ugreen, &c->green) ||\n\t\t    __get_user(ublue, &c->blue))\n\t\t\treturn -EFAULT;\n\n\t\tcmap.len = 1;\n\t\tcmap.red = &red;\n\t\tcmap.green = &green;\n\t\tcmap.blue = &blue;\n\t\tcmap.transp = NULL;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tint err;\n\n\t\t\tif (get_user(red8, &ured[i]) ||\n\t\t\t    get_user(green8, &ugreen[i]) ||\n\t\t\t    get_user(blue8, &ublue[i]))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tred = red8 << 8;\n\t\t\tgreen = green8 << 8;\n\t\t\tblue = blue8 << 8;\n\n\t\t\tcmap.start = index + i;\n\t\t\terr = fb_set_cmap(&cmap, info);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\treturn 0;\n\t}\n\tcase FBIOGETCMAP_SPARC: {\n\t\tstruct fbcmap __user *c = (struct fbcmap __user *) arg;\n\t\tunsigned char __user *ured;\n \t\tunsigned char __user *ugreen;\n \t\tunsigned char __user *ublue;\n \t\tstruct fb_cmap *cmap = &info->cmap;\n\t\tunsigned int index, count, i;\n \t\tu8 red, green, blue;\n \n \t\tif (get_user(index, &c->index) ||\n\t\t    __get_user(count, &c->count) ||\n\t\t    __get_user(ured, &c->red) ||\n\t\t    __get_user(ugreen, &c->green) ||\n\t\t    __get_user(ublue, &c->blue))\n\t\t\treturn -EFAULT;\n\n\t\tif (index + count > cmap->len)\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tred = cmap->red[index + i] >> 8;\n\t\t\tgreen = cmap->green[index + i] >> 8;\n\t\t\tblue = cmap->blue[index + i] >> 8;\n\t\t\tif (put_user(red, &ured[i]) ||\n\t\t\t    put_user(green, &ugreen[i]) ||\n\t\t\t    put_user(blue, &ublue[i]))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t\treturn 0;\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144160,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static void upnp_event_prepare(struct upnp_event_notify * obj)\n{\n\tstatic const char notifymsg[] =\n\t\t\"NOTIFY %s HTTP/1.1\\r\\n\"\n\t\t\"Host: %s%s\\r\\n\"\n#if (UPNP_VERSION_MAJOR == 1) && (UPNP_VERSION_MINOR == 0)\n\t\t\"Content-Type: text/xml\\r\\n\"\t/* UDA v1.0 */\n#else\n\t\t\"Content-Type: text/xml; charset=\\\"utf-8\\\"\\r\\n\"\t/* UDA v1.1 or later */\n#endif\n\t\t\"Content-Length: %d\\r\\n\"\n\t\t\"NT: upnp:event\\r\\n\"\n\t\t\"NTS: upnp:propchange\\r\\n\"\n\t\t\"SID: %s\\r\\n\"\n\t\t\"SEQ: %u\\r\\n\"\n\t\t\"Connection: close\\r\\n\"\n\t\t\"Cache-Control: no-cache\\r\\n\"\n\t\t\"\\r\\n\"\n\t\t\"%.*s\\r\\n\";\n\tchar * xml;\n\tint l;\n\tif(obj->sub == NULL) {\n\t\tobj->state = EError;\n\t\treturn;\n\t}\n\tswitch(obj->sub->service) {\n\tcase EWanCFG:\n\t\txml = getVarsWANCfg(&l);\n\t\tbreak;\n\tcase EWanIPC:\n\t\txml = getVarsWANIPCn(&l);\n\t\tbreak;\n#ifdef ENABLE_L3F_SERVICE\n\tcase EL3F:\n\t\txml = getVarsL3F(&l);\n\t\tbreak;\n#endif\n#ifdef ENABLE_6FC_SERVICE\n\tcase E6FC:\n\t\txml = getVars6FC(&l);\n\t\tbreak;\n#endif\n#ifdef ENABLE_DP_SERVICE\n\tcase EDP:\n\t\txml = getVarsDP(&l);\n\t\tbreak;\n#endif\n\tdefault:\n\t\txml = NULL;\n \t\tl = 0;\n \t}\n \tobj->buffersize = 1024;\n\tobj->buffer = malloc(obj->buffersize);\n\tif(!obj->buffer) {\n\t\tsyslog(LOG_ERR, \"%s: malloc returned NULL\", \"upnp_event_prepare\");\n\t\tif(xml) {\n\t\t\tfree(xml);\n \t\t}\n\t\tobj->state = EError;\n\t\treturn;\n \t}\n\tobj->tosend = snprintf(obj->buffer, obj->buffersize, notifymsg,\n\t                       obj->path, obj->addrstr, obj->portstr, l+2,\n\t                       obj->sub->uuid, obj->sub->seq,\n\t                       l, xml);\n \tif(xml) {\n \t\tfree(xml);\n \t\txml = NULL;\n\t}\n\tobj->state = ESending;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144181,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static void upnp_event_prepare(struct upnp_event_notify * obj)\n{\n\tstatic const char notifymsg[] =\n\t\t\"NOTIFY %s HTTP/1.1\\r\\n\"\n\t\t\"Host: %s%s\\r\\n\"\n#if (UPNP_VERSION_MAJOR == 1) && (UPNP_VERSION_MINOR == 0)\n\t\t\"Content-Type: text/xml\\r\\n\"\t/* UDA v1.0 */\n#else\n\t\t\"Content-Type: text/xml; charset=\\\"utf-8\\\"\\r\\n\"\t/* UDA v1.1 or later */\n#endif\n\t\t\"Content-Length: %d\\r\\n\"\n\t\t\"NT: upnp:event\\r\\n\"\n\t\t\"NTS: upnp:propchange\\r\\n\"\n\t\t\"SID: %s\\r\\n\"\n\t\t\"SEQ: %u\\r\\n\"\n\t\t\"Connection: close\\r\\n\"\n\t\t\"Cache-Control: no-cache\\r\\n\"\n\t\t\"\\r\\n\"\n\t\t\"%.*s\\r\\n\";\n\tchar * xml;\n\tint l;\n\tif(obj->sub == NULL) {\n\t\tobj->state = EError;\n\t\treturn;\n\t}\n\tswitch(obj->sub->service) {\n\tcase EWanCFG:\n\t\txml = getVarsWANCfg(&l);\n\t\tbreak;\n\tcase EWanIPC:\n\t\txml = getVarsWANIPCn(&l);\n\t\tbreak;\n#ifdef ENABLE_L3F_SERVICE\n\tcase EL3F:\n\t\txml = getVarsL3F(&l);\n\t\tbreak;\n#endif\n#ifdef ENABLE_6FC_SERVICE\n\tcase E6FC:\n\t\txml = getVars6FC(&l);\n\t\tbreak;\n#endif\n#ifdef ENABLE_DP_SERVICE\n\tcase EDP:\n\t\txml = getVarsDP(&l);\n\t\tbreak;\n#endif\n\tdefault:\n\t\txml = NULL;\n \t\tl = 0;\n \t}\n \tobj->buffersize = 1024;\n\tfor (;;) {\n\t\tobj->buffer = malloc(obj->buffersize);\n\t\tif(!obj->buffer) {\n\t\t\tsyslog(LOG_ERR, \"%s: malloc returned NULL\", \"upnp_event_prepare\");\n\t\t\tif(xml) {\n\t\t\t\tfree(xml);\n\t\t\t}\n\t\t\tobj->state = EError;\n\t\t\treturn;\n \t\t}\n\t\tobj->tosend = snprintf(obj->buffer, obj->buffersize, notifymsg,\n\t\t                       obj->path, obj->addrstr, obj->portstr, l+2,\n\t\t                       obj->sub->uuid, obj->sub->seq,\n\t\t                       l, xml);\n\t\tif (obj->tosend < 0) {\n\t\t\tsyslog(LOG_ERR, \"%s: snprintf() failed\", \"upnp_event_prepare\");\n\t\t\tif(xml) {\n\t\t\t\tfree(xml);\n\t\t\t}\n\t\t\tobj->state = EError;\n\t\t\treturn;\n\t\t} else if (obj->tosend < obj->buffersize) {\n\t\t\tbreak; /* the buffer was large enough */\n\t\t}\n\t\t/* Try again with a buffer big enough */\n\t\tfree(obj->buffer);\n\t\tobj->buffersize = obj->tosend + 1;\t/* reserve space for the final 0 */\n \t}\n \tif(xml) {\n \t\tfree(xml);\n \t\txml = NULL;\n\t}\n\tobj->state = ESending;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144182,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int rfcomm_get_dev_list(void __user *arg)\n{\n\tstruct rfcomm_dev *dev;\n\tstruct rfcomm_dev_list_req *dl;\n\tstruct rfcomm_dev_info *di;\n\tint n = 0, size, err;\n\tu16 dev_num;\n\n\tBT_DBG(\"\");\n\n\tif (get_user(dev_num, (u16 __user *) arg))\n\t\treturn -EFAULT;\n\n\tif (!dev_num || dev_num > (PAGE_SIZE * 4) / sizeof(*di))\n\t\treturn -EINVAL;\n \n \tsize = sizeof(*dl) + dev_num * sizeof(*di);\n \n\tdl = kmalloc(size, GFP_KERNEL);\n \tif (!dl)\n \t\treturn -ENOMEM;\n \n\tdi = dl->dev_info;\n\n\tspin_lock(&rfcomm_dev_lock);\n\n\tlist_for_each_entry(dev, &rfcomm_dev_list, list) {\n\t\tif (test_bit(RFCOMM_TTY_RELEASED, &dev->flags))\n\t\t\tcontinue;\n\t\t(di + n)->id      = dev->id;\n\t\t(di + n)->flags   = dev->flags;\n\t\t(di + n)->state   = dev->dlc->state;\n\t\t(di + n)->channel = dev->channel;\n\t\tbacpy(&(di + n)->src, &dev->src);\n\t\tbacpy(&(di + n)->dst, &dev->dst);\n\t\tif (++n >= dev_num)\n\t\t\tbreak;\n\t}\n\n\tspin_unlock(&rfcomm_dev_lock);\n\n\tdl->dev_num = n;\n\tsize = sizeof(*dl) + n * sizeof(*di);\n\n\terr = copy_to_user(arg, dl, size);\n\tkfree(dl);\n\n\treturn err ? -EFAULT : 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144191,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int rfcomm_get_dev_list(void __user *arg)\n{\n\tstruct rfcomm_dev *dev;\n\tstruct rfcomm_dev_list_req *dl;\n\tstruct rfcomm_dev_info *di;\n\tint n = 0, size, err;\n\tu16 dev_num;\n\n\tBT_DBG(\"\");\n\n\tif (get_user(dev_num, (u16 __user *) arg))\n\t\treturn -EFAULT;\n\n\tif (!dev_num || dev_num > (PAGE_SIZE * 4) / sizeof(*di))\n\t\treturn -EINVAL;\n \n \tsize = sizeof(*dl) + dev_num * sizeof(*di);\n \n\tdl = kzalloc(size, GFP_KERNEL);\n \tif (!dl)\n \t\treturn -ENOMEM;\n \n\tdi = dl->dev_info;\n\n\tspin_lock(&rfcomm_dev_lock);\n\n\tlist_for_each_entry(dev, &rfcomm_dev_list, list) {\n\t\tif (test_bit(RFCOMM_TTY_RELEASED, &dev->flags))\n\t\t\tcontinue;\n\t\t(di + n)->id      = dev->id;\n\t\t(di + n)->flags   = dev->flags;\n\t\t(di + n)->state   = dev->dlc->state;\n\t\t(di + n)->channel = dev->channel;\n\t\tbacpy(&(di + n)->src, &dev->src);\n\t\tbacpy(&(di + n)->dst, &dev->dst);\n\t\tif (++n >= dev_num)\n\t\t\tbreak;\n\t}\n\n\tspin_unlock(&rfcomm_dev_lock);\n\n\tdl->dev_num = n;\n\tsize = sizeof(*dl) + n * sizeof(*di);\n\n\terr = copy_to_user(arg, dl, size);\n\tkfree(dl);\n\n\treturn err ? -EFAULT : 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144192,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "OMX_ERRORTYPE SimpleSoftOMXComponent::useBuffer(\n        OMX_BUFFERHEADERTYPE **header,\n        OMX_U32 portIndex,\n        OMX_PTR appPrivate,\n        OMX_U32 size,\n        OMX_U8 *ptr) {\n\n     Mutex::Autolock autoLock(mLock);\n     CHECK_LT(portIndex, mPorts.size());\n \n     *header = new OMX_BUFFERHEADERTYPE;\n     (*header)->nSize = sizeof(OMX_BUFFERHEADERTYPE);\n     (*header)->nVersion.s.nVersionMajor = 1;\n (*header)->nVersion.s.nVersionMinor = 0;\n (*header)->nVersion.s.nRevision = 0;\n (*header)->nVersion.s.nStep = 0;\n (*header)->pBuffer = ptr;\n (*header)->nAllocLen = size;\n (*header)->nFilledLen = 0;\n (*header)->nOffset = 0;\n (*header)->pAppPrivate = appPrivate;\n (*header)->pPlatformPrivate = NULL;\n (*header)->pInputPortPrivate = NULL;\n (*header)->pOutputPortPrivate = NULL;\n (*header)->hMarkTargetComponent = NULL;\n (*header)->pMarkData = NULL;\n (*header)->nTickCount = 0;\n (*header)->nTimeStamp = 0;\n (*header)->nFlags = 0;\n\n     (*header)->nOutputPortIndex = portIndex;\n     (*header)->nInputPortIndex = portIndex;\n \n    PortInfo *port = &mPorts.editItemAt(portIndex);\n     CHECK(mState == OMX_StateLoaded || port->mDef.bEnabled == OMX_FALSE);\n \n     CHECK_LT(port->mBuffers.size(), port->mDef.nBufferCountActual);\n\n    port->mBuffers.push();\n\n BufferInfo *buffer =\n &port->mBuffers.editItemAt(port->mBuffers.size() - 1);\n\n    buffer->mHeader = *header;\n    buffer->mOwnedByUs = false;\n\n if (port->mBuffers.size() == port->mDef.nBufferCountActual) {\n        port->mDef.bPopulated = OMX_TRUE;\n        checkTransitions();\n }\n\n return OMX_ErrorNone;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144261,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "OMX_ERRORTYPE SimpleSoftOMXComponent::useBuffer(\n        OMX_BUFFERHEADERTYPE **header,\n        OMX_U32 portIndex,\n        OMX_PTR appPrivate,\n        OMX_U32 size,\n        OMX_U8 *ptr) {\n\n     Mutex::Autolock autoLock(mLock);\n     CHECK_LT(portIndex, mPorts.size());\n \n    PortInfo *port = &mPorts.editItemAt(portIndex);\n    if (size < port->mDef.nBufferSize) {\n        ALOGE(\"b/63522430, Buffer size is too small.\");\n        android_errorWriteLog(0x534e4554, \"63522430\");\n        return OMX_ErrorBadParameter;\n    }\n\n     *header = new OMX_BUFFERHEADERTYPE;\n     (*header)->nSize = sizeof(OMX_BUFFERHEADERTYPE);\n     (*header)->nVersion.s.nVersionMajor = 1;\n (*header)->nVersion.s.nVersionMinor = 0;\n (*header)->nVersion.s.nRevision = 0;\n (*header)->nVersion.s.nStep = 0;\n (*header)->pBuffer = ptr;\n (*header)->nAllocLen = size;\n (*header)->nFilledLen = 0;\n (*header)->nOffset = 0;\n (*header)->pAppPrivate = appPrivate;\n (*header)->pPlatformPrivate = NULL;\n (*header)->pInputPortPrivate = NULL;\n (*header)->pOutputPortPrivate = NULL;\n (*header)->hMarkTargetComponent = NULL;\n (*header)->pMarkData = NULL;\n (*header)->nTickCount = 0;\n (*header)->nTimeStamp = 0;\n (*header)->nFlags = 0;\n\n     (*header)->nOutputPortIndex = portIndex;\n     (*header)->nInputPortIndex = portIndex;\n \n     CHECK(mState == OMX_StateLoaded || port->mDef.bEnabled == OMX_FALSE);\n \n     CHECK_LT(port->mBuffers.size(), port->mDef.nBufferCountActual);\n\n    port->mBuffers.push();\n\n BufferInfo *buffer =\n &port->mBuffers.editItemAt(port->mBuffers.size() - 1);\n\n    buffer->mHeader = *header;\n    buffer->mOwnedByUs = false;\n\n if (port->mBuffers.size() == port->mDef.nBufferCountActual) {\n        port->mDef.bPopulated = OMX_TRUE;\n        checkTransitions();\n }\n\n return OMX_ErrorNone;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144262,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "WORD32 ih264d_parse_sps(dec_struct_t *ps_dec, dec_bit_stream_t *ps_bitstrm)\n\n {\n     UWORD8 i;\n     dec_seq_params_t *ps_seq = NULL;\n    UWORD8 u1_profile_idc, u1_level_idc, u1_seq_parameter_set_id;\n     UWORD16 i2_max_frm_num;\n     UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;\n     UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;\n    UWORD8 u1_frm, uc_constraint_set0_flag, uc_constraint_set1_flag;\n    WORD32 i4_cropped_ht, i4_cropped_wd;\n    UWORD32 u4_temp;\n    WORD32 pic_height_in_map_units_minus1 = 0;\n    UWORD32 u2_pic_wd = 0;\n    UWORD32 u2_pic_ht = 0;\n    UWORD32 u2_frm_wd_y = 0;\n    UWORD32 u2_frm_ht_y = 0;\n    UWORD32 u2_frm_wd_uv = 0;\n    UWORD32 u2_frm_ht_uv = 0;\n    UWORD32 u2_crop_offset_y = 0;\n    UWORD32 u2_crop_offset_uv = 0;\n    WORD32 ret;\n    UWORD32 u4_num_reorder_frames;\n /* High profile related syntax element */\n    WORD32 i4_i;\n /* G050 */\n    UWORD8 u1_frame_cropping_flag, u1_frame_cropping_rect_left_ofst,\n                    u1_frame_cropping_rect_right_ofst,\n                    u1_frame_cropping_rect_top_ofst,\n                    u1_frame_cropping_rect_bottom_ofst;\n /* G050 */\n /*--------------------------------------------------------------------*/\n /* Decode seq_parameter_set_id and profile and level values           */\n /*--------------------------------------------------------------------*/\n    SWITCHONTRACE;\n    u1_profile_idc = ih264d_get_bits_h264(ps_bitstrm, 8);\n    COPYTHECONTEXT(\"SPS: profile_idc\",u1_profile_idc);\n\n /* G050 */\n    uc_constraint_set0_flag = ih264d_get_bit_h264(ps_bitstrm);\n    uc_constraint_set1_flag = ih264d_get_bit_h264(ps_bitstrm);\n    ih264d_get_bit_h264(ps_bitstrm);\n\n /*****************************************************/\n /* Read 5 bits for uc_constraint_set3_flag (1 bit)   */\n /* and reserved_zero_4bits (4 bits) - Sushant        */\n /*****************************************************/\n    ih264d_get_bits_h264(ps_bitstrm, 5);\n /* G050 */\n\n /* Check whether particular profile is suported or not */\n /* Check whether particular profile is suported or not */\n if((u1_profile_idc != MAIN_PROFILE_IDC) &&\n\n (u1_profile_idc != BASE_PROFILE_IDC) &&\n\n (u1_profile_idc != HIGH_PROFILE_IDC)\n\n )\n {\n\n /* Apart from Baseline, main and high profile,\n         * only extended profile is supported provided\n         * uc_constraint_set0_flag or uc_constraint_set1_flag are set to 1\n         */\n if((u1_profile_idc != EXTENDED_PROFILE_IDC) ||\n ((uc_constraint_set1_flag != 1) && (uc_constraint_set0_flag != 1)))\n {\n return (ERROR_FEATURE_UNAVAIL);\n }\n }\n\n    u1_level_idc = ih264d_get_bits_h264(ps_bitstrm, 8);\n\n\n\n    COPYTHECONTEXT(\"SPS: u4_level_idc\",u1_level_idc);\n\n    u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);\n if(u4_temp & MASK_ERR_SEQ_SET_ID)\n return ERROR_INV_SPS_PPS_T;\n    u1_seq_parameter_set_id = u4_temp;\n    COPYTHECONTEXT(\"SPS: seq_parameter_set_id\",\n                    u1_seq_parameter_set_id);\n\n /*--------------------------------------------------------------------*/\n /* Find an seq param entry in seqparam array of decStruct             */\n /*--------------------------------------------------------------------*/\n\n    ps_seq = ps_dec->pv_scratch_sps_pps;\n if(ps_dec->i4_header_decoded & 1)\n {\n *ps_seq = *ps_dec->ps_cur_sps;\n }\n\n\n if((ps_dec->i4_header_decoded & 1) && (ps_seq->u1_profile_idc != u1_profile_idc))\n {\n        ps_dec->u1_res_changed = 1;\n return IVD_RES_CHANGED;\n }\n\n if((ps_dec->i4_header_decoded & 1) && (ps_seq->u1_level_idc != u1_level_idc))\n {\n        ps_dec->u1_res_changed = 1;\n return IVD_RES_CHANGED;\n }\n\n    ps_seq->u1_profile_idc = u1_profile_idc;\n    ps_seq->u1_level_idc = u1_level_idc;\n    ps_seq->u1_seq_parameter_set_id = u1_seq_parameter_set_id;\n\n /*******************************************************************/\n /* Initializations for high profile - Sushant                      */\n /*******************************************************************/\n    ps_seq->i4_chroma_format_idc = 1;\n    ps_seq->i4_bit_depth_luma_minus8 = 0;\n    ps_seq->i4_bit_depth_chroma_minus8 = 0;\n    ps_seq->i4_qpprime_y_zero_transform_bypass_flag = 0;\n    ps_seq->i4_seq_scaling_matrix_present_flag = 0;\n if(u1_profile_idc == HIGH_PROFILE_IDC)\n {\n\n /* reading chroma_format_idc   */\n        ps_seq->i4_chroma_format_idc = ih264d_uev(pu4_bitstrm_ofst,\n                                                  pu4_bitstrm_buf);\n\n /* Monochrome is not supported */\n if(ps_seq->i4_chroma_format_idc != 1)\n {\n return ERROR_INV_SPS_PPS_T;\n }\n\n /* reading bit_depth_luma_minus8   */\n        ps_seq->i4_bit_depth_luma_minus8 = ih264d_uev(pu4_bitstrm_ofst,\n                                                      pu4_bitstrm_buf);\n\n if(ps_seq->i4_bit_depth_luma_minus8 != 0)\n {\n return ERROR_INV_SPS_PPS_T;\n }\n\n /* reading bit_depth_chroma_minus8   */\n        ps_seq->i4_bit_depth_chroma_minus8 = ih264d_uev(pu4_bitstrm_ofst,\n                                                        pu4_bitstrm_buf);\n\n if(ps_seq->i4_bit_depth_chroma_minus8 != 0)\n {\n return ERROR_INV_SPS_PPS_T;\n }\n\n /* reading qpprime_y_zero_transform_bypass_flag   */\n        ps_seq->i4_qpprime_y_zero_transform_bypass_flag =\n (WORD32)ih264d_get_bit_h264(ps_bitstrm);\n\n if(ps_seq->i4_qpprime_y_zero_transform_bypass_flag != 0)\n {\n return ERROR_INV_SPS_PPS_T;\n }\n\n /* reading seq_scaling_matrix_present_flag   */\n        ps_seq->i4_seq_scaling_matrix_present_flag =\n (WORD32)ih264d_get_bit_h264(ps_bitstrm);\n\n if(ps_seq->i4_seq_scaling_matrix_present_flag)\n {\n for(i4_i = 0; i4_i < 8; i4_i++)\n {\n                ps_seq->u1_seq_scaling_list_present_flag[i4_i] =\n                                ih264d_get_bit_h264(ps_bitstrm);\n\n /* initialize u1_use_default_scaling_matrix_flag[i4_i] to zero */\n /* before calling scaling list                             */\n                ps_seq->u1_use_default_scaling_matrix_flag[i4_i] = 0;\n\n if(ps_seq->u1_seq_scaling_list_present_flag[i4_i])\n {\n if(i4_i < 6)\n {\n                        ih264d_scaling_list(\n                                        ps_seq->i2_scalinglist4x4[i4_i],\n 16,\n &ps_seq->u1_use_default_scaling_matrix_flag[i4_i],\n                                        ps_bitstrm);\n }\n else\n {\n                        ih264d_scaling_list(\n                                        ps_seq->i2_scalinglist8x8[i4_i - 6],\n 64,\n &ps_seq->u1_use_default_scaling_matrix_flag[i4_i],\n                                        ps_bitstrm);\n }\n }\n }\n }\n }\n /*--------------------------------------------------------------------*/\n /* Decode MaxFrameNum                                                 */\n /*--------------------------------------------------------------------*/\n    u4_temp = 4 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);\n if(u4_temp > MAX_BITS_IN_FRAME_NUM)\n {\n return ERROR_INV_SPS_PPS_T;\n }\n    ps_seq->u1_bits_in_frm_num = u4_temp;\n    COPYTHECONTEXT(\"SPS: log2_max_frame_num_minus4\",\n (ps_seq->u1_bits_in_frm_num - 4));\n\n    i2_max_frm_num = (1 << (ps_seq->u1_bits_in_frm_num));\n    ps_seq->u2_u4_max_pic_num_minus1 = i2_max_frm_num - 1;\n /*--------------------------------------------------------------------*/\n /* Decode picture order count and related values                      */\n /*--------------------------------------------------------------------*/\n    u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);\n\n if(u4_temp > MAX_PIC_ORDER_CNT_TYPE)\n {\n return ERROR_INV_POC_TYPE_T;\n }\n    ps_seq->u1_pic_order_cnt_type = u4_temp;\n    COPYTHECONTEXT(\"SPS: pic_order_cnt_type\",ps_seq->u1_pic_order_cnt_type);\n\n    ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle = 1;\n if(ps_seq->u1_pic_order_cnt_type == 0)\n {\n        u4_temp = 4 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);\n if(u4_temp > MAX_BITS_IN_POC_LSB)\n {\n return ERROR_INV_SPS_PPS_T;\n }\n        ps_seq->u1_log2_max_pic_order_cnt_lsb_minus = u4_temp;\n        ps_seq->i4_max_pic_order_cntLsb = (1 << u4_temp);\n        COPYTHECONTEXT(\"SPS: log2_max_pic_order_cnt_lsb_minus4\",(u4_temp - 4));\n }\n else if(ps_seq->u1_pic_order_cnt_type == 1)\n {\n        ps_seq->u1_delta_pic_order_always_zero_flag = ih264d_get_bit_h264(\n                        ps_bitstrm);\n        COPYTHECONTEXT(\"SPS: delta_pic_order_always_zero_flag\",\n                        ps_seq->u1_delta_pic_order_always_zero_flag);\n\n        ps_seq->i4_ofst_for_non_ref_pic = ih264d_sev(pu4_bitstrm_ofst,\n                                                     pu4_bitstrm_buf);\n        COPYTHECONTEXT(\"SPS: offset_for_non_ref_pic\",\n                        ps_seq->i4_ofst_for_non_ref_pic);\n\n        ps_seq->i4_ofst_for_top_to_bottom_field = ih264d_sev(\n                        pu4_bitstrm_ofst, pu4_bitstrm_buf);\n        COPYTHECONTEXT(\"SPS: offset_for_top_to_bottom_field\",\n                        ps_seq->i4_ofst_for_top_to_bottom_field);\n\n        u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);\n if(u4_temp > 255)\n return ERROR_INV_SPS_PPS_T;\n        ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle = u4_temp;\n        COPYTHECONTEXT(\"SPS: num_ref_frames_in_pic_order_cnt_cycle\",\n                        ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle);\n\n for(i = 0; i < ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle; i++)\n {\n            ps_seq->i4_ofst_for_ref_frame[i] = ih264d_sev(\n                            pu4_bitstrm_ofst, pu4_bitstrm_buf);\n            COPYTHECONTEXT(\"SPS: offset_for_ref_frame\",\n                            ps_seq->i4_ofst_for_ref_frame[i]);\n }\n }\n\n    u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);\n\n if((u4_temp > H264_MAX_REF_PICS))\n {\n return ERROR_NUM_REF;\n }\n\n /* Compare with older num_ref_frames is header is already once */\n if((ps_dec->i4_header_decoded & 1) && (ps_seq->u1_num_ref_frames != u4_temp))\n {\n        ps_dec->u1_res_changed = 1;\n return IVD_RES_CHANGED;\n }\n\n    ps_seq->u1_num_ref_frames = u4_temp;\n    COPYTHECONTEXT(\"SPS: num_ref_frames\",ps_seq->u1_num_ref_frames);\n\n    ps_seq->u1_gaps_in_frame_num_value_allowed_flag = ih264d_get_bit_h264(\n                    ps_bitstrm);\n    COPYTHECONTEXT(\"SPS: gaps_in_frame_num_value_allowed_flag\",\n                    ps_seq->u1_gaps_in_frame_num_value_allowed_flag);\n\n /*--------------------------------------------------------------------*/\n /* Decode FrameWidth and FrameHeight and related values               */\n /*--------------------------------------------------------------------*/\n    ps_seq->u2_frm_wd_in_mbs = 1\n + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);\n    COPYTHECONTEXT(\"SPS: pic_width_in_mbs_minus1\",\n                    ps_seq->u2_frm_wd_in_mbs - 1);\n    u2_pic_wd = (ps_seq->u2_frm_wd_in_mbs << 4);\n\n    pic_height_in_map_units_minus1 = ih264d_uev(pu4_bitstrm_ofst,\n                                                pu4_bitstrm_buf);\n    ps_seq->u2_frm_ht_in_mbs = 1 + pic_height_in_map_units_minus1;\n\n    u2_pic_ht = (ps_seq->u2_frm_ht_in_mbs << 4);\n\n /*--------------------------------------------------------------------*/\n /* Get the value of MaxMbAddress and Number of bits needed for it     */\n /*--------------------------------------------------------------------*/\n    ps_seq->u2_max_mb_addr = (ps_seq->u2_frm_wd_in_mbs\n * ps_seq->u2_frm_ht_in_mbs) - 1;\n\n    ps_seq->u2_total_num_of_mbs = ps_seq->u2_max_mb_addr + 1;\n\n    ps_seq->u1_level_idc = ih264d_correct_level_idc(\n                    u1_level_idc, ps_seq->u2_total_num_of_mbs);\n\n    u1_frm = ih264d_get_bit_h264(ps_bitstrm);\n if((ps_dec->i4_header_decoded & 1) && (ps_seq->u1_frame_mbs_only_flag != u1_frm))\n {\n        ps_dec->u1_res_changed = 1;\n return IVD_RES_CHANGED;\n }\n\n    ps_seq->u1_frame_mbs_only_flag = u1_frm;\n\n\n     COPYTHECONTEXT(\"SPS: frame_mbs_only_flag\", u1_frm);\n \n     if(!u1_frm)\n     {\n         u2_pic_ht <<= 1;\n        ps_seq->u1_mb_aff_flag = ih264d_get_bit_h264(ps_bitstrm);\n         COPYTHECONTEXT(\"SPS: mb_adaptive_frame_field_flag\",\n                         ps_seq->u1_mb_aff_flag);\n \n }\n else\n        ps_seq->u1_mb_aff_flag = 0;\n\n    ps_seq->u1_direct_8x8_inference_flag = ih264d_get_bit_h264(ps_bitstrm);\n\n    COPYTHECONTEXT(\"SPS: direct_8x8_inference_flag\",\n                    ps_seq->u1_direct_8x8_inference_flag);\n\n /* G050 */\n    u1_frame_cropping_flag = ih264d_get_bit_h264(ps_bitstrm);\n    COPYTHECONTEXT(\"SPS: frame_cropping_flag\",u1_frame_cropping_flag);\n\n if(u1_frame_cropping_flag)\n {\n        u1_frame_cropping_rect_left_ofst = ih264d_uev(pu4_bitstrm_ofst,\n                                                      pu4_bitstrm_buf);\n        COPYTHECONTEXT(\"SPS: frame_cropping_rect_left_offset\",\n                        u1_frame_cropping_rect_left_ofst);\n        u1_frame_cropping_rect_right_ofst = ih264d_uev(pu4_bitstrm_ofst,\n                                                       pu4_bitstrm_buf);\n        COPYTHECONTEXT(\"SPS: frame_cropping_rect_right_offset\",\n                        u1_frame_cropping_rect_right_ofst);\n        u1_frame_cropping_rect_top_ofst = ih264d_uev(pu4_bitstrm_ofst,\n                                                     pu4_bitstrm_buf);\n        COPYTHECONTEXT(\"SPS: frame_cropping_rect_top_offset\",\n                        u1_frame_cropping_rect_top_ofst);\n        u1_frame_cropping_rect_bottom_ofst = ih264d_uev(pu4_bitstrm_ofst,\n                                                        pu4_bitstrm_buf);\n        COPYTHECONTEXT(\"SPS: frame_cropping_rect_bottom_offset\",\n                        u1_frame_cropping_rect_bottom_ofst);\n }\n /* G050 */\n\n    ps_seq->u1_vui_parameters_present_flag = ih264d_get_bit_h264(ps_bitstrm);\n    COPYTHECONTEXT(\"SPS: vui_parameters_present_flag\",\n                    ps_seq->u1_vui_parameters_present_flag);\n\n    u2_frm_wd_y = u2_pic_wd + (UWORD8)(PAD_LEN_Y_H << 1);\n if(1 == ps_dec->u4_share_disp_buf)\n {\n if(ps_dec->u4_app_disp_width > u2_frm_wd_y)\n            u2_frm_wd_y = ps_dec->u4_app_disp_width;\n }\n\n    u2_frm_ht_y = u2_pic_ht + (UWORD8)(PAD_LEN_Y_V << 2);\n    u2_frm_wd_uv = u2_pic_wd + (UWORD8)(PAD_LEN_UV_H << 2);\n    u2_frm_wd_uv = MAX(u2_frm_wd_uv, u2_frm_wd_y);\n\n    u2_frm_ht_uv = (u2_pic_ht >> 1) + (UWORD8)(PAD_LEN_UV_V << 2);\n    u2_frm_ht_uv = MAX(u2_frm_ht_uv, (u2_frm_ht_y >> 1));\n\n\n /* Calculate display picture width, height and start u4_ofst from YUV420 */\n /* pictute buffers as per cropping information parsed above             */\n {\n        UWORD16 u2_rgt_ofst = 0;\n        UWORD16 u2_lft_ofst = 0;\n        UWORD16 u2_top_ofst = 0;\n        UWORD16 u2_btm_ofst = 0;\n        UWORD8 u1_frm_mbs_flag;\n        UWORD8 u1_vert_mult_factor;\n\n if(u1_frame_cropping_flag)\n {\n /* Calculate right and left u4_ofst for cropped picture           */\n            u2_rgt_ofst = u1_frame_cropping_rect_right_ofst << 1;\n            u2_lft_ofst = u1_frame_cropping_rect_left_ofst << 1;\n\n /* Know frame MBs only u4_flag                                      */\n            u1_frm_mbs_flag = (1 == ps_seq->u1_frame_mbs_only_flag);\n\n /* Simplify the vertical u4_ofst calculation from field/frame     */\n            u1_vert_mult_factor = (2 - u1_frm_mbs_flag);\n\n /* Calculate bottom and top u4_ofst for cropped  picture          */\n            u2_btm_ofst = (u1_frame_cropping_rect_bottom_ofst\n << u1_vert_mult_factor);\n            u2_top_ofst = (u1_frame_cropping_rect_top_ofst\n << u1_vert_mult_factor);\n }\n\n /* Calculate u4_ofst from start of YUV 420 picture buffer to start of*/\n /* cropped picture buffer                                           */\n        u2_crop_offset_y = (u2_frm_wd_y * u2_top_ofst) + (u2_lft_ofst);\n        u2_crop_offset_uv = (u2_frm_wd_uv * (u2_top_ofst >> 1))\n + (u2_lft_ofst >> 1) * YUV420SP_FACTOR;\n /* Calculate the display picture width and height based on crop      */\n /* information                                                       */\n        i4_cropped_ht = u2_pic_ht - (u2_btm_ofst + u2_top_ofst);\n        i4_cropped_wd = u2_pic_wd - (u2_rgt_ofst + u2_lft_ofst);\n\n if((i4_cropped_ht < MB_SIZE) || (i4_cropped_wd < MB_SIZE))\n {\n return ERROR_INV_SPS_PPS_T;\n }\n\n if((ps_dec->i4_header_decoded & 1) && (ps_dec->u2_pic_wd != u2_pic_wd))\n {\n            ps_dec->u1_res_changed = 1;\n return IVD_RES_CHANGED;\n }\n if((ps_dec->i4_header_decoded & 1) && (ps_dec->u2_pic_ht != u2_pic_ht))\n {\n            ps_dec->u1_res_changed = 1;\n return IVD_RES_CHANGED;\n }\n\n /* Check for unsupported resolutions */\n if((u2_pic_wd > H264_MAX_FRAME_WIDTH) || (u2_pic_ht > H264_MAX_FRAME_HEIGHT)\n || (u2_pic_wd < H264_MIN_FRAME_WIDTH) || (u2_pic_ht < H264_MIN_FRAME_HEIGHT)\n || (u2_pic_wd * (UWORD32)u2_pic_ht > H264_MAX_FRAME_SIZE))\n {\n return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED;\n }\n\n /* If MBAff is enabled, decoder support is limited to streams with\n         * width less than half of H264_MAX_FRAME_WIDTH.\n         * In case of MBAff decoder processes two rows at a time\n         */\n if((u2_pic_wd << ps_seq->u1_mb_aff_flag) > H264_MAX_FRAME_WIDTH)\n {\n return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED;\n }\n\n }\n\n /* Backup u4_num_reorder_frames if header is already decoded */\n if((ps_dec->i4_header_decoded & 1) &&\n (1 == ps_seq->u1_vui_parameters_present_flag) &&\n (1 == ps_seq->s_vui.u1_bitstream_restriction_flag))\n {\n        u4_num_reorder_frames =  ps_seq->s_vui.u4_num_reorder_frames;\n }\n else\n {\n        u4_num_reorder_frames = -1;\n }\n if(1 == ps_seq->u1_vui_parameters_present_flag)\n {\n        ret = ih264d_parse_vui_parametres(&ps_seq->s_vui, ps_bitstrm);\n if(ret != OK)\n return ret;\n }\n\n /* Compare older u4_num_reorder_frames with the new one if header is already decoded */\n if((ps_dec->i4_header_decoded & 1) &&\n (-1 != (WORD32)u4_num_reorder_frames) &&\n (1 == ps_seq->u1_vui_parameters_present_flag) &&\n (1 == ps_seq->s_vui.u1_bitstream_restriction_flag) &&\n (ps_seq->s_vui.u4_num_reorder_frames != u4_num_reorder_frames))\n {\n        ps_dec->u1_res_changed = 1;\n return IVD_RES_CHANGED;\n }\n\n /* In case bitstream read has exceeded the filled size, then\n     return an error */\n if (ps_bitstrm->u4_ofst > ps_bitstrm->u4_max_ofst)\n {\n return ERROR_INV_SPS_PPS_T;\n }\n\n /*--------------------------------------------------------------------*/\n /* All initializations to ps_dec are beyond this point                */\n /*--------------------------------------------------------------------*/\n    ps_dec->u2_disp_height = i4_cropped_ht;\n    ps_dec->u2_disp_width = i4_cropped_wd;\n\n    ps_dec->u2_pic_wd = u2_pic_wd;\n    ps_dec->u2_pic_ht = u2_pic_ht;\n\n /* Determining the Width and Height of Frame from that of Picture */\n    ps_dec->u2_frm_wd_y = u2_frm_wd_y;\n    ps_dec->u2_frm_ht_y = u2_frm_ht_y;\n\n    ps_dec->u2_frm_wd_uv = u2_frm_wd_uv;\n    ps_dec->u2_frm_ht_uv = u2_frm_ht_uv;\n    ps_dec->s_pad_mgr.u1_pad_len_y_v = (UWORD8)(PAD_LEN_Y_V << (1 - u1_frm));\n    ps_dec->s_pad_mgr.u1_pad_len_cr_v = (UWORD8)(PAD_LEN_UV_V << (1 - u1_frm));\n\n    ps_dec->u2_frm_wd_in_mbs = ps_seq->u2_frm_wd_in_mbs;\n    ps_dec->u2_frm_ht_in_mbs = ps_seq->u2_frm_ht_in_mbs;\n\n    ps_dec->u2_crop_offset_y = u2_crop_offset_y;\n    ps_dec->u2_crop_offset_uv = u2_crop_offset_uv;\n\n    ps_seq->u1_is_valid = TRUE;\n    ps_dec->ps_sps[u1_seq_parameter_set_id] = *ps_seq;\n    ps_dec->ps_cur_sps = &ps_dec->ps_sps[u1_seq_parameter_set_id];\n\n return OK;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144271,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "WORD32 ih264d_parse_sps(dec_struct_t *ps_dec, dec_bit_stream_t *ps_bitstrm)\n\n {\n     UWORD8 i;\n     dec_seq_params_t *ps_seq = NULL;\n    UWORD8 u1_profile_idc, u1_level_idc, u1_seq_parameter_set_id, u1_mb_aff_flag = 0;\n     UWORD16 i2_max_frm_num;\n     UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;\n     UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;\n    UWORD8 u1_frm, uc_constraint_set0_flag, uc_constraint_set1_flag;\n    WORD32 i4_cropped_ht, i4_cropped_wd;\n    UWORD32 u4_temp;\n    WORD32 pic_height_in_map_units_minus1 = 0;\n    UWORD32 u2_pic_wd = 0;\n    UWORD32 u2_pic_ht = 0;\n    UWORD32 u2_frm_wd_y = 0;\n    UWORD32 u2_frm_ht_y = 0;\n    UWORD32 u2_frm_wd_uv = 0;\n    UWORD32 u2_frm_ht_uv = 0;\n    UWORD32 u2_crop_offset_y = 0;\n    UWORD32 u2_crop_offset_uv = 0;\n    WORD32 ret;\n    UWORD32 u4_num_reorder_frames;\n /* High profile related syntax element */\n    WORD32 i4_i;\n /* G050 */\n    UWORD8 u1_frame_cropping_flag, u1_frame_cropping_rect_left_ofst,\n                    u1_frame_cropping_rect_right_ofst,\n                    u1_frame_cropping_rect_top_ofst,\n                    u1_frame_cropping_rect_bottom_ofst;\n /* G050 */\n /*--------------------------------------------------------------------*/\n /* Decode seq_parameter_set_id and profile and level values           */\n /*--------------------------------------------------------------------*/\n    SWITCHONTRACE;\n    u1_profile_idc = ih264d_get_bits_h264(ps_bitstrm, 8);\n    COPYTHECONTEXT(\"SPS: profile_idc\",u1_profile_idc);\n\n /* G050 */\n    uc_constraint_set0_flag = ih264d_get_bit_h264(ps_bitstrm);\n    uc_constraint_set1_flag = ih264d_get_bit_h264(ps_bitstrm);\n    ih264d_get_bit_h264(ps_bitstrm);\n\n /*****************************************************/\n /* Read 5 bits for uc_constraint_set3_flag (1 bit)   */\n /* and reserved_zero_4bits (4 bits) - Sushant        */\n /*****************************************************/\n    ih264d_get_bits_h264(ps_bitstrm, 5);\n /* G050 */\n\n /* Check whether particular profile is suported or not */\n /* Check whether particular profile is suported or not */\n if((u1_profile_idc != MAIN_PROFILE_IDC) &&\n\n (u1_profile_idc != BASE_PROFILE_IDC) &&\n\n (u1_profile_idc != HIGH_PROFILE_IDC)\n\n )\n {\n\n /* Apart from Baseline, main and high profile,\n         * only extended profile is supported provided\n         * uc_constraint_set0_flag or uc_constraint_set1_flag are set to 1\n         */\n if((u1_profile_idc != EXTENDED_PROFILE_IDC) ||\n ((uc_constraint_set1_flag != 1) && (uc_constraint_set0_flag != 1)))\n {\n return (ERROR_FEATURE_UNAVAIL);\n }\n }\n\n    u1_level_idc = ih264d_get_bits_h264(ps_bitstrm, 8);\n\n\n\n    COPYTHECONTEXT(\"SPS: u4_level_idc\",u1_level_idc);\n\n    u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);\n if(u4_temp & MASK_ERR_SEQ_SET_ID)\n return ERROR_INV_SPS_PPS_T;\n    u1_seq_parameter_set_id = u4_temp;\n    COPYTHECONTEXT(\"SPS: seq_parameter_set_id\",\n                    u1_seq_parameter_set_id);\n\n /*--------------------------------------------------------------------*/\n /* Find an seq param entry in seqparam array of decStruct             */\n /*--------------------------------------------------------------------*/\n\n    ps_seq = ps_dec->pv_scratch_sps_pps;\n if(ps_dec->i4_header_decoded & 1)\n {\n *ps_seq = *ps_dec->ps_cur_sps;\n }\n\n\n if((ps_dec->i4_header_decoded & 1) && (ps_seq->u1_profile_idc != u1_profile_idc))\n {\n        ps_dec->u1_res_changed = 1;\n return IVD_RES_CHANGED;\n }\n\n if((ps_dec->i4_header_decoded & 1) && (ps_seq->u1_level_idc != u1_level_idc))\n {\n        ps_dec->u1_res_changed = 1;\n return IVD_RES_CHANGED;\n }\n\n    ps_seq->u1_profile_idc = u1_profile_idc;\n    ps_seq->u1_level_idc = u1_level_idc;\n    ps_seq->u1_seq_parameter_set_id = u1_seq_parameter_set_id;\n\n /*******************************************************************/\n /* Initializations for high profile - Sushant                      */\n /*******************************************************************/\n    ps_seq->i4_chroma_format_idc = 1;\n    ps_seq->i4_bit_depth_luma_minus8 = 0;\n    ps_seq->i4_bit_depth_chroma_minus8 = 0;\n    ps_seq->i4_qpprime_y_zero_transform_bypass_flag = 0;\n    ps_seq->i4_seq_scaling_matrix_present_flag = 0;\n if(u1_profile_idc == HIGH_PROFILE_IDC)\n {\n\n /* reading chroma_format_idc   */\n        ps_seq->i4_chroma_format_idc = ih264d_uev(pu4_bitstrm_ofst,\n                                                  pu4_bitstrm_buf);\n\n /* Monochrome is not supported */\n if(ps_seq->i4_chroma_format_idc != 1)\n {\n return ERROR_INV_SPS_PPS_T;\n }\n\n /* reading bit_depth_luma_minus8   */\n        ps_seq->i4_bit_depth_luma_minus8 = ih264d_uev(pu4_bitstrm_ofst,\n                                                      pu4_bitstrm_buf);\n\n if(ps_seq->i4_bit_depth_luma_minus8 != 0)\n {\n return ERROR_INV_SPS_PPS_T;\n }\n\n /* reading bit_depth_chroma_minus8   */\n        ps_seq->i4_bit_depth_chroma_minus8 = ih264d_uev(pu4_bitstrm_ofst,\n                                                        pu4_bitstrm_buf);\n\n if(ps_seq->i4_bit_depth_chroma_minus8 != 0)\n {\n return ERROR_INV_SPS_PPS_T;\n }\n\n /* reading qpprime_y_zero_transform_bypass_flag   */\n        ps_seq->i4_qpprime_y_zero_transform_bypass_flag =\n (WORD32)ih264d_get_bit_h264(ps_bitstrm);\n\n if(ps_seq->i4_qpprime_y_zero_transform_bypass_flag != 0)\n {\n return ERROR_INV_SPS_PPS_T;\n }\n\n /* reading seq_scaling_matrix_present_flag   */\n        ps_seq->i4_seq_scaling_matrix_present_flag =\n (WORD32)ih264d_get_bit_h264(ps_bitstrm);\n\n if(ps_seq->i4_seq_scaling_matrix_present_flag)\n {\n for(i4_i = 0; i4_i < 8; i4_i++)\n {\n                ps_seq->u1_seq_scaling_list_present_flag[i4_i] =\n                                ih264d_get_bit_h264(ps_bitstrm);\n\n /* initialize u1_use_default_scaling_matrix_flag[i4_i] to zero */\n /* before calling scaling list                             */\n                ps_seq->u1_use_default_scaling_matrix_flag[i4_i] = 0;\n\n if(ps_seq->u1_seq_scaling_list_present_flag[i4_i])\n {\n if(i4_i < 6)\n {\n                        ih264d_scaling_list(\n                                        ps_seq->i2_scalinglist4x4[i4_i],\n 16,\n &ps_seq->u1_use_default_scaling_matrix_flag[i4_i],\n                                        ps_bitstrm);\n }\n else\n {\n                        ih264d_scaling_list(\n                                        ps_seq->i2_scalinglist8x8[i4_i - 6],\n 64,\n &ps_seq->u1_use_default_scaling_matrix_flag[i4_i],\n                                        ps_bitstrm);\n }\n }\n }\n }\n }\n /*--------------------------------------------------------------------*/\n /* Decode MaxFrameNum                                                 */\n /*--------------------------------------------------------------------*/\n    u4_temp = 4 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);\n if(u4_temp > MAX_BITS_IN_FRAME_NUM)\n {\n return ERROR_INV_SPS_PPS_T;\n }\n    ps_seq->u1_bits_in_frm_num = u4_temp;\n    COPYTHECONTEXT(\"SPS: log2_max_frame_num_minus4\",\n (ps_seq->u1_bits_in_frm_num - 4));\n\n    i2_max_frm_num = (1 << (ps_seq->u1_bits_in_frm_num));\n    ps_seq->u2_u4_max_pic_num_minus1 = i2_max_frm_num - 1;\n /*--------------------------------------------------------------------*/\n /* Decode picture order count and related values                      */\n /*--------------------------------------------------------------------*/\n    u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);\n\n if(u4_temp > MAX_PIC_ORDER_CNT_TYPE)\n {\n return ERROR_INV_POC_TYPE_T;\n }\n    ps_seq->u1_pic_order_cnt_type = u4_temp;\n    COPYTHECONTEXT(\"SPS: pic_order_cnt_type\",ps_seq->u1_pic_order_cnt_type);\n\n    ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle = 1;\n if(ps_seq->u1_pic_order_cnt_type == 0)\n {\n        u4_temp = 4 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);\n if(u4_temp > MAX_BITS_IN_POC_LSB)\n {\n return ERROR_INV_SPS_PPS_T;\n }\n        ps_seq->u1_log2_max_pic_order_cnt_lsb_minus = u4_temp;\n        ps_seq->i4_max_pic_order_cntLsb = (1 << u4_temp);\n        COPYTHECONTEXT(\"SPS: log2_max_pic_order_cnt_lsb_minus4\",(u4_temp - 4));\n }\n else if(ps_seq->u1_pic_order_cnt_type == 1)\n {\n        ps_seq->u1_delta_pic_order_always_zero_flag = ih264d_get_bit_h264(\n                        ps_bitstrm);\n        COPYTHECONTEXT(\"SPS: delta_pic_order_always_zero_flag\",\n                        ps_seq->u1_delta_pic_order_always_zero_flag);\n\n        ps_seq->i4_ofst_for_non_ref_pic = ih264d_sev(pu4_bitstrm_ofst,\n                                                     pu4_bitstrm_buf);\n        COPYTHECONTEXT(\"SPS: offset_for_non_ref_pic\",\n                        ps_seq->i4_ofst_for_non_ref_pic);\n\n        ps_seq->i4_ofst_for_top_to_bottom_field = ih264d_sev(\n                        pu4_bitstrm_ofst, pu4_bitstrm_buf);\n        COPYTHECONTEXT(\"SPS: offset_for_top_to_bottom_field\",\n                        ps_seq->i4_ofst_for_top_to_bottom_field);\n\n        u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);\n if(u4_temp > 255)\n return ERROR_INV_SPS_PPS_T;\n        ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle = u4_temp;\n        COPYTHECONTEXT(\"SPS: num_ref_frames_in_pic_order_cnt_cycle\",\n                        ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle);\n\n for(i = 0; i < ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle; i++)\n {\n            ps_seq->i4_ofst_for_ref_frame[i] = ih264d_sev(\n                            pu4_bitstrm_ofst, pu4_bitstrm_buf);\n            COPYTHECONTEXT(\"SPS: offset_for_ref_frame\",\n                            ps_seq->i4_ofst_for_ref_frame[i]);\n }\n }\n\n    u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);\n\n if((u4_temp > H264_MAX_REF_PICS))\n {\n return ERROR_NUM_REF;\n }\n\n /* Compare with older num_ref_frames is header is already once */\n if((ps_dec->i4_header_decoded & 1) && (ps_seq->u1_num_ref_frames != u4_temp))\n {\n        ps_dec->u1_res_changed = 1;\n return IVD_RES_CHANGED;\n }\n\n    ps_seq->u1_num_ref_frames = u4_temp;\n    COPYTHECONTEXT(\"SPS: num_ref_frames\",ps_seq->u1_num_ref_frames);\n\n    ps_seq->u1_gaps_in_frame_num_value_allowed_flag = ih264d_get_bit_h264(\n                    ps_bitstrm);\n    COPYTHECONTEXT(\"SPS: gaps_in_frame_num_value_allowed_flag\",\n                    ps_seq->u1_gaps_in_frame_num_value_allowed_flag);\n\n /*--------------------------------------------------------------------*/\n /* Decode FrameWidth and FrameHeight and related values               */\n /*--------------------------------------------------------------------*/\n    ps_seq->u2_frm_wd_in_mbs = 1\n + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);\n    COPYTHECONTEXT(\"SPS: pic_width_in_mbs_minus1\",\n                    ps_seq->u2_frm_wd_in_mbs - 1);\n    u2_pic_wd = (ps_seq->u2_frm_wd_in_mbs << 4);\n\n    pic_height_in_map_units_minus1 = ih264d_uev(pu4_bitstrm_ofst,\n                                                pu4_bitstrm_buf);\n    ps_seq->u2_frm_ht_in_mbs = 1 + pic_height_in_map_units_minus1;\n\n    u2_pic_ht = (ps_seq->u2_frm_ht_in_mbs << 4);\n\n /*--------------------------------------------------------------------*/\n /* Get the value of MaxMbAddress and Number of bits needed for it     */\n /*--------------------------------------------------------------------*/\n    ps_seq->u2_max_mb_addr = (ps_seq->u2_frm_wd_in_mbs\n * ps_seq->u2_frm_ht_in_mbs) - 1;\n\n    ps_seq->u2_total_num_of_mbs = ps_seq->u2_max_mb_addr + 1;\n\n    ps_seq->u1_level_idc = ih264d_correct_level_idc(\n                    u1_level_idc, ps_seq->u2_total_num_of_mbs);\n\n    u1_frm = ih264d_get_bit_h264(ps_bitstrm);\n if((ps_dec->i4_header_decoded & 1) && (ps_seq->u1_frame_mbs_only_flag != u1_frm))\n {\n        ps_dec->u1_res_changed = 1;\n return IVD_RES_CHANGED;\n }\n\n    ps_seq->u1_frame_mbs_only_flag = u1_frm;\n\n\n     COPYTHECONTEXT(\"SPS: frame_mbs_only_flag\", u1_frm);\n \n     if(!u1_frm)\n        u1_mb_aff_flag = ih264d_get_bit_h264(ps_bitstrm);\n\n    if((ps_dec->i4_header_decoded & 1)\n                    && (ps_seq->u1_mb_aff_flag != u1_mb_aff_flag))\n    {\n        ps_dec->u1_res_changed = 1;\n        return IVD_RES_CHANGED;\n    }\n\n    if(!u1_frm)\n     {\n         u2_pic_ht <<= 1;\n        ps_seq->u1_mb_aff_flag = u1_mb_aff_flag;\n         COPYTHECONTEXT(\"SPS: mb_adaptive_frame_field_flag\",\n                         ps_seq->u1_mb_aff_flag);\n \n }\n else\n        ps_seq->u1_mb_aff_flag = 0;\n\n    ps_seq->u1_direct_8x8_inference_flag = ih264d_get_bit_h264(ps_bitstrm);\n\n    COPYTHECONTEXT(\"SPS: direct_8x8_inference_flag\",\n                    ps_seq->u1_direct_8x8_inference_flag);\n\n /* G050 */\n    u1_frame_cropping_flag = ih264d_get_bit_h264(ps_bitstrm);\n    COPYTHECONTEXT(\"SPS: frame_cropping_flag\",u1_frame_cropping_flag);\n\n if(u1_frame_cropping_flag)\n {\n        u1_frame_cropping_rect_left_ofst = ih264d_uev(pu4_bitstrm_ofst,\n                                                      pu4_bitstrm_buf);\n        COPYTHECONTEXT(\"SPS: frame_cropping_rect_left_offset\",\n                        u1_frame_cropping_rect_left_ofst);\n        u1_frame_cropping_rect_right_ofst = ih264d_uev(pu4_bitstrm_ofst,\n                                                       pu4_bitstrm_buf);\n        COPYTHECONTEXT(\"SPS: frame_cropping_rect_right_offset\",\n                        u1_frame_cropping_rect_right_ofst);\n        u1_frame_cropping_rect_top_ofst = ih264d_uev(pu4_bitstrm_ofst,\n                                                     pu4_bitstrm_buf);\n        COPYTHECONTEXT(\"SPS: frame_cropping_rect_top_offset\",\n                        u1_frame_cropping_rect_top_ofst);\n        u1_frame_cropping_rect_bottom_ofst = ih264d_uev(pu4_bitstrm_ofst,\n                                                        pu4_bitstrm_buf);\n        COPYTHECONTEXT(\"SPS: frame_cropping_rect_bottom_offset\",\n                        u1_frame_cropping_rect_bottom_ofst);\n }\n /* G050 */\n\n    ps_seq->u1_vui_parameters_present_flag = ih264d_get_bit_h264(ps_bitstrm);\n    COPYTHECONTEXT(\"SPS: vui_parameters_present_flag\",\n                    ps_seq->u1_vui_parameters_present_flag);\n\n    u2_frm_wd_y = u2_pic_wd + (UWORD8)(PAD_LEN_Y_H << 1);\n if(1 == ps_dec->u4_share_disp_buf)\n {\n if(ps_dec->u4_app_disp_width > u2_frm_wd_y)\n            u2_frm_wd_y = ps_dec->u4_app_disp_width;\n }\n\n    u2_frm_ht_y = u2_pic_ht + (UWORD8)(PAD_LEN_Y_V << 2);\n    u2_frm_wd_uv = u2_pic_wd + (UWORD8)(PAD_LEN_UV_H << 2);\n    u2_frm_wd_uv = MAX(u2_frm_wd_uv, u2_frm_wd_y);\n\n    u2_frm_ht_uv = (u2_pic_ht >> 1) + (UWORD8)(PAD_LEN_UV_V << 2);\n    u2_frm_ht_uv = MAX(u2_frm_ht_uv, (u2_frm_ht_y >> 1));\n\n\n /* Calculate display picture width, height and start u4_ofst from YUV420 */\n /* pictute buffers as per cropping information parsed above             */\n {\n        UWORD16 u2_rgt_ofst = 0;\n        UWORD16 u2_lft_ofst = 0;\n        UWORD16 u2_top_ofst = 0;\n        UWORD16 u2_btm_ofst = 0;\n        UWORD8 u1_frm_mbs_flag;\n        UWORD8 u1_vert_mult_factor;\n\n if(u1_frame_cropping_flag)\n {\n /* Calculate right and left u4_ofst for cropped picture           */\n            u2_rgt_ofst = u1_frame_cropping_rect_right_ofst << 1;\n            u2_lft_ofst = u1_frame_cropping_rect_left_ofst << 1;\n\n /* Know frame MBs only u4_flag                                      */\n            u1_frm_mbs_flag = (1 == ps_seq->u1_frame_mbs_only_flag);\n\n /* Simplify the vertical u4_ofst calculation from field/frame     */\n            u1_vert_mult_factor = (2 - u1_frm_mbs_flag);\n\n /* Calculate bottom and top u4_ofst for cropped  picture          */\n            u2_btm_ofst = (u1_frame_cropping_rect_bottom_ofst\n << u1_vert_mult_factor);\n            u2_top_ofst = (u1_frame_cropping_rect_top_ofst\n << u1_vert_mult_factor);\n }\n\n /* Calculate u4_ofst from start of YUV 420 picture buffer to start of*/\n /* cropped picture buffer                                           */\n        u2_crop_offset_y = (u2_frm_wd_y * u2_top_ofst) + (u2_lft_ofst);\n        u2_crop_offset_uv = (u2_frm_wd_uv * (u2_top_ofst >> 1))\n + (u2_lft_ofst >> 1) * YUV420SP_FACTOR;\n /* Calculate the display picture width and height based on crop      */\n /* information                                                       */\n        i4_cropped_ht = u2_pic_ht - (u2_btm_ofst + u2_top_ofst);\n        i4_cropped_wd = u2_pic_wd - (u2_rgt_ofst + u2_lft_ofst);\n\n if((i4_cropped_ht < MB_SIZE) || (i4_cropped_wd < MB_SIZE))\n {\n return ERROR_INV_SPS_PPS_T;\n }\n\n if((ps_dec->i4_header_decoded & 1) && (ps_dec->u2_pic_wd != u2_pic_wd))\n {\n            ps_dec->u1_res_changed = 1;\n return IVD_RES_CHANGED;\n }\n if((ps_dec->i4_header_decoded & 1) && (ps_dec->u2_pic_ht != u2_pic_ht))\n {\n            ps_dec->u1_res_changed = 1;\n return IVD_RES_CHANGED;\n }\n\n /* Check for unsupported resolutions */\n if((u2_pic_wd > H264_MAX_FRAME_WIDTH) || (u2_pic_ht > H264_MAX_FRAME_HEIGHT)\n || (u2_pic_wd < H264_MIN_FRAME_WIDTH) || (u2_pic_ht < H264_MIN_FRAME_HEIGHT)\n || (u2_pic_wd * (UWORD32)u2_pic_ht > H264_MAX_FRAME_SIZE))\n {\n return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED;\n }\n\n /* If MBAff is enabled, decoder support is limited to streams with\n         * width less than half of H264_MAX_FRAME_WIDTH.\n         * In case of MBAff decoder processes two rows at a time\n         */\n if((u2_pic_wd << ps_seq->u1_mb_aff_flag) > H264_MAX_FRAME_WIDTH)\n {\n return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED;\n }\n\n }\n\n /* Backup u4_num_reorder_frames if header is already decoded */\n if((ps_dec->i4_header_decoded & 1) &&\n (1 == ps_seq->u1_vui_parameters_present_flag) &&\n (1 == ps_seq->s_vui.u1_bitstream_restriction_flag))\n {\n        u4_num_reorder_frames =  ps_seq->s_vui.u4_num_reorder_frames;\n }\n else\n {\n        u4_num_reorder_frames = -1;\n }\n if(1 == ps_seq->u1_vui_parameters_present_flag)\n {\n        ret = ih264d_parse_vui_parametres(&ps_seq->s_vui, ps_bitstrm);\n if(ret != OK)\n return ret;\n }\n\n /* Compare older u4_num_reorder_frames with the new one if header is already decoded */\n if((ps_dec->i4_header_decoded & 1) &&\n (-1 != (WORD32)u4_num_reorder_frames) &&\n (1 == ps_seq->u1_vui_parameters_present_flag) &&\n (1 == ps_seq->s_vui.u1_bitstream_restriction_flag) &&\n (ps_seq->s_vui.u4_num_reorder_frames != u4_num_reorder_frames))\n {\n        ps_dec->u1_res_changed = 1;\n return IVD_RES_CHANGED;\n }\n\n /* In case bitstream read has exceeded the filled size, then\n     return an error */\n if (ps_bitstrm->u4_ofst > ps_bitstrm->u4_max_ofst)\n {\n return ERROR_INV_SPS_PPS_T;\n }\n\n /*--------------------------------------------------------------------*/\n /* All initializations to ps_dec are beyond this point                */\n /*--------------------------------------------------------------------*/\n    ps_dec->u2_disp_height = i4_cropped_ht;\n    ps_dec->u2_disp_width = i4_cropped_wd;\n\n    ps_dec->u2_pic_wd = u2_pic_wd;\n    ps_dec->u2_pic_ht = u2_pic_ht;\n\n /* Determining the Width and Height of Frame from that of Picture */\n    ps_dec->u2_frm_wd_y = u2_frm_wd_y;\n    ps_dec->u2_frm_ht_y = u2_frm_ht_y;\n\n    ps_dec->u2_frm_wd_uv = u2_frm_wd_uv;\n    ps_dec->u2_frm_ht_uv = u2_frm_ht_uv;\n    ps_dec->s_pad_mgr.u1_pad_len_y_v = (UWORD8)(PAD_LEN_Y_V << (1 - u1_frm));\n    ps_dec->s_pad_mgr.u1_pad_len_cr_v = (UWORD8)(PAD_LEN_UV_V << (1 - u1_frm));\n\n    ps_dec->u2_frm_wd_in_mbs = ps_seq->u2_frm_wd_in_mbs;\n    ps_dec->u2_frm_ht_in_mbs = ps_seq->u2_frm_ht_in_mbs;\n\n    ps_dec->u2_crop_offset_y = u2_crop_offset_y;\n    ps_dec->u2_crop_offset_uv = u2_crop_offset_uv;\n\n    ps_seq->u1_is_valid = TRUE;\n    ps_dec->ps_sps[u1_seq_parameter_set_id] = *ps_seq;\n    ps_dec->ps_cur_sps = &ps_dec->ps_sps[u1_seq_parameter_set_id];\n\n return OK;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144272,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "xmlDocPtr soap_xmlParseFile(const char *filename TSRMLS_DC)\n{\n\txmlParserCtxtPtr ctxt = NULL;\n\txmlDocPtr ret;\n\tzend_bool old_allow_url_fopen;\n\n/*\n\txmlInitParser();\n*/\n\n\told_allow_url_fopen = PG(allow_url_fopen);\n\tPG(allow_url_fopen) = 1;\n\tctxt = xmlCreateFileParserCtxt(filename);\n        PG(allow_url_fopen) = old_allow_url_fopen;\n        if (ctxt) {\n                ctxt->keepBlanks = 0;\n               ctxt->options -= XML_PARSE_DTDLOAD;\n                ctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;\n                ctxt->sax->comment = soap_Comment;\n                ctxt->sax->warning = NULL;\n\t\tctxt->sax->error = NULL;\n\t\t/*ctxt->sax->fatalError = NULL;*/\n\t\txmlParseDocument(ctxt);\n\t\tif (ctxt->wellFormed) {\n\t\t\tret = ctxt->myDoc;\n\t\t\tif (ret->URL == NULL && ctxt->directory != NULL) {\n\t\t\t\tret->URL = xmlCharStrdup(ctxt->directory);\n\t\t\t}\n\t\t} else {\n\t\t\tret = NULL;\n\t\t\txmlFreeDoc(ctxt->myDoc);\n\t\t\tctxt->myDoc = NULL;\n\t\t}\n\t\txmlFreeParserCtxt(ctxt);\n\t} else {\n\t\tret = NULL;\n\t}\n\n/*\n\txmlCleanupParser();\n*/\n\n\tif (ret) {\n\t\tcleanup_xml_node((xmlNodePtr)ret);\n\t}\n\treturn ret;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144283,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "xmlDocPtr soap_xmlParseFile(const char *filename TSRMLS_DC)\n{\n\txmlParserCtxtPtr ctxt = NULL;\n\txmlDocPtr ret;\n\tzend_bool old_allow_url_fopen;\n\n/*\n\txmlInitParser();\n*/\n\n\told_allow_url_fopen = PG(allow_url_fopen);\n\tPG(allow_url_fopen) = 1;\n\tctxt = xmlCreateFileParserCtxt(filename);\n        PG(allow_url_fopen) = old_allow_url_fopen;\n        if (ctxt) {\n                ctxt->keepBlanks = 0;\n               ctxt->options &= ~XML_PARSE_DTDLOAD;\n                ctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;\n                ctxt->sax->comment = soap_Comment;\n                ctxt->sax->warning = NULL;\n\t\tctxt->sax->error = NULL;\n\t\t/*ctxt->sax->fatalError = NULL;*/\n\t\txmlParseDocument(ctxt);\n\t\tif (ctxt->wellFormed) {\n\t\t\tret = ctxt->myDoc;\n\t\t\tif (ret->URL == NULL && ctxt->directory != NULL) {\n\t\t\t\tret->URL = xmlCharStrdup(ctxt->directory);\n\t\t\t}\n\t\t} else {\n\t\t\tret = NULL;\n\t\t\txmlFreeDoc(ctxt->myDoc);\n\t\t\tctxt->myDoc = NULL;\n\t\t}\n\t\txmlFreeParserCtxt(ctxt);\n\t} else {\n\t\tret = NULL;\n\t}\n\n/*\n\txmlCleanupParser();\n*/\n\n\tif (ret) {\n\t\tcleanup_xml_node((xmlNodePtr)ret);\n\t}\n\treturn ret;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144284,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "xmlDocPtr soap_xmlParseMemory(const void *buf, size_t buf_size)\n{\n\txmlParserCtxtPtr ctxt = NULL;\n\txmlDocPtr ret;\n\n/*\n\txmlInitParser();\n */\n        ctxt = xmlCreateMemoryParserCtxt(buf, buf_size);\n        if (ctxt) {\n               ctxt->options -= XML_PARSE_DTDLOAD;\n                ctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;\n                ctxt->sax->comment = soap_Comment;\n                ctxt->sax->warning = NULL;\n\t\tctxt->sax->error = NULL;\n\t\t/*ctxt->sax->fatalError = NULL;*/\n#if LIBXML_VERSION >= 20703\n\t\tctxt->options |= XML_PARSE_HUGE;\n#endif\n\t\txmlParseDocument(ctxt);\n\t\tif (ctxt->wellFormed) {\n\t\t\tret = ctxt->myDoc;\n\t\t\tif (ret->URL == NULL && ctxt->directory != NULL) {\n\t\t\t\tret->URL = xmlCharStrdup(ctxt->directory);\n\t\t\t}\n\t\t} else {\n\t\t\tret = NULL;\n\t\t\txmlFreeDoc(ctxt->myDoc);\n\t\t\tctxt->myDoc = NULL;\n\t\t}\n\t\txmlFreeParserCtxt(ctxt);\n\t} else {\n\t\tret = NULL;\n\t}\n\n/*\n\txmlCleanupParser();\n*/\n\n/*\n\tif (ret) {\n\t\tcleanup_xml_node((xmlNodePtr)ret);\n\t}\n*/\n\treturn ret;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144285,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "xmlDocPtr soap_xmlParseMemory(const void *buf, size_t buf_size)\n{\n\txmlParserCtxtPtr ctxt = NULL;\n\txmlDocPtr ret;\n\n/*\n\txmlInitParser();\n */\n        ctxt = xmlCreateMemoryParserCtxt(buf, buf_size);\n        if (ctxt) {\n               ctxt->options &= ~XML_PARSE_DTDLOAD;\n                ctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;\n                ctxt->sax->comment = soap_Comment;\n                ctxt->sax->warning = NULL;\n\t\tctxt->sax->error = NULL;\n\t\t/*ctxt->sax->fatalError = NULL;*/\n#if LIBXML_VERSION >= 20703\n\t\tctxt->options |= XML_PARSE_HUGE;\n#endif\n\t\txmlParseDocument(ctxt);\n\t\tif (ctxt->wellFormed) {\n\t\t\tret = ctxt->myDoc;\n\t\t\tif (ret->URL == NULL && ctxt->directory != NULL) {\n\t\t\t\tret->URL = xmlCharStrdup(ctxt->directory);\n\t\t\t}\n\t\t} else {\n\t\t\tret = NULL;\n\t\t\txmlFreeDoc(ctxt->myDoc);\n\t\t\tctxt->myDoc = NULL;\n\t\t}\n\t\txmlFreeParserCtxt(ctxt);\n\t} else {\n\t\tret = NULL;\n\t}\n\n/*\n\txmlCleanupParser();\n*/\n\n/*\n\tif (ret) {\n\t\tcleanup_xml_node((xmlNodePtr)ret);\n\t}\n*/\n\treturn ret;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144286,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "xmlDocPtr soap_xmlParseFile(const char *filename TSRMLS_DC)\n{\n\txmlParserCtxtPtr ctxt = NULL;\n\txmlDocPtr ret;\n\tzend_bool old_allow_url_fopen;\n\n/*\n\txmlInitParser();\n*/\n\n\told_allow_url_fopen = PG(allow_url_fopen);\n\tPG(allow_url_fopen) = 1;\n\tctxt = xmlCreateFileParserCtxt(filename);\n        PG(allow_url_fopen) = old_allow_url_fopen;\n        if (ctxt) {\n                ctxt->keepBlanks = 0;\n                ctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;\n                ctxt->sax->comment = soap_Comment;\n                ctxt->sax->warning = NULL;\n\t\t/*ctxt->sax->fatalError = NULL;*/\n\t\txmlParseDocument(ctxt);\n\t\tif (ctxt->wellFormed) {\n\t\t\tret = ctxt->myDoc;\n\t\t\tif (ret->URL == NULL && ctxt->directory != NULL) {\n\t\t\t\tret->URL = xmlCharStrdup(ctxt->directory);\n\t\t\t}\n\t\t} else {\n\t\t\tret = NULL;\n\t\t\txmlFreeDoc(ctxt->myDoc);\n\t\t\tctxt->myDoc = NULL;\n\t\t}\n\t\txmlFreeParserCtxt(ctxt);\n\t} else {\n\t\tret = NULL;\n\t}\n\n/*\n\txmlCleanupParser();\n*/\n\n\tif (ret) {\n\t\tcleanup_xml_node((xmlNodePtr)ret);\n\t}\n\treturn ret;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144287,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "xmlDocPtr soap_xmlParseFile(const char *filename TSRMLS_DC)\n{\n\txmlParserCtxtPtr ctxt = NULL;\n\txmlDocPtr ret;\n\tzend_bool old_allow_url_fopen;\n\n/*\n\txmlInitParser();\n*/\n\n\told_allow_url_fopen = PG(allow_url_fopen);\n\tPG(allow_url_fopen) = 1;\n\tctxt = xmlCreateFileParserCtxt(filename);\n        PG(allow_url_fopen) = old_allow_url_fopen;\n        if (ctxt) {\n                ctxt->keepBlanks = 0;\n               ctxt->options -= XML_PARSE_DTDLOAD;\n                ctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;\n                ctxt->sax->comment = soap_Comment;\n                ctxt->sax->warning = NULL;\n\t\t/*ctxt->sax->fatalError = NULL;*/\n\t\txmlParseDocument(ctxt);\n\t\tif (ctxt->wellFormed) {\n\t\t\tret = ctxt->myDoc;\n\t\t\tif (ret->URL == NULL && ctxt->directory != NULL) {\n\t\t\t\tret->URL = xmlCharStrdup(ctxt->directory);\n\t\t\t}\n\t\t} else {\n\t\t\tret = NULL;\n\t\t\txmlFreeDoc(ctxt->myDoc);\n\t\t\tctxt->myDoc = NULL;\n\t\t}\n\t\txmlFreeParserCtxt(ctxt);\n\t} else {\n\t\tret = NULL;\n\t}\n\n/*\n\txmlCleanupParser();\n*/\n\n\tif (ret) {\n\t\tcleanup_xml_node((xmlNodePtr)ret);\n\t}\n\treturn ret;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144288,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "xmlDocPtr soap_xmlParseMemory(const void *buf, size_t buf_size)\n{\n\txmlParserCtxtPtr ctxt = NULL;\n\txmlDocPtr ret;\n\n/*\n\txmlInitParser();\n*/\n */\n        ctxt = xmlCreateMemoryParserCtxt(buf, buf_size);\n        if (ctxt) {\n                ctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;\n                ctxt->sax->comment = soap_Comment;\n                ctxt->sax->warning = NULL;\n#if LIBXML_VERSION >= 20703\n\t\tctxt->options |= XML_PARSE_HUGE;\n#endif\n\t\txmlParseDocument(ctxt);\n\t\tif (ctxt->wellFormed) {\n\t\t\tret = ctxt->myDoc;\n\t\t\tif (ret->URL == NULL && ctxt->directory != NULL) {\n\t\t\t\tret->URL = xmlCharStrdup(ctxt->directory);\n\t\t\t}\n\t\t} else {\n\t\t\tret = NULL;\n\t\t\txmlFreeDoc(ctxt->myDoc);\n\t\t\tctxt->myDoc = NULL;\n\t\t}\n\t\txmlFreeParserCtxt(ctxt);\n\t} else {\n\t\tret = NULL;\n\t}\n\n/*\n\txmlCleanupParser();\n*/\n\n/*\n\tif (ret) {\n\t\tcleanup_xml_node((xmlNodePtr)ret);\n\t}\n*/\n\treturn ret;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144289,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "xmlDocPtr soap_xmlParseMemory(const void *buf, size_t buf_size)\n{\n\txmlParserCtxtPtr ctxt = NULL;\n\txmlDocPtr ret;\n\n/*\n\txmlInitParser();\n*/\n */\n        ctxt = xmlCreateMemoryParserCtxt(buf, buf_size);\n        if (ctxt) {\n               ctxt->options -= XML_PARSE_DTDLOAD;\n                ctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;\n                ctxt->sax->comment = soap_Comment;\n                ctxt->sax->warning = NULL;\n#if LIBXML_VERSION >= 20703\n\t\tctxt->options |= XML_PARSE_HUGE;\n#endif\n\t\txmlParseDocument(ctxt);\n\t\tif (ctxt->wellFormed) {\n\t\t\tret = ctxt->myDoc;\n\t\t\tif (ret->URL == NULL && ctxt->directory != NULL) {\n\t\t\t\tret->URL = xmlCharStrdup(ctxt->directory);\n\t\t\t}\n\t\t} else {\n\t\t\tret = NULL;\n\t\t\txmlFreeDoc(ctxt->myDoc);\n\t\t\tctxt->myDoc = NULL;\n\t\t}\n\t\txmlFreeParserCtxt(ctxt);\n\t} else {\n\t\tret = NULL;\n\t}\n\n/*\n\txmlCleanupParser();\n*/\n\n/*\n\tif (ret) {\n\t\tcleanup_xml_node((xmlNodePtr)ret);\n\t}\n*/\n\treturn ret;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144290,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static PHP_GINIT_FUNCTION(libxml)\n{\n        libxml_globals->stream_context = NULL;\n        libxml_globals->error_buffer.c = NULL;\n        libxml_globals->error_list = NULL;\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144291,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static PHP_GINIT_FUNCTION(libxml)\n{\n        libxml_globals->stream_context = NULL;\n        libxml_globals->error_buffer.c = NULL;\n        libxml_globals->error_list = NULL;\n       libxml_globals->entity_loader_disabled = 0;\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144292,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "PHP_FUNCTION(openssl_encrypt)\n{\n\tzend_bool raw_output = 0;\n\tchar *data, *method, *password, *iv = \"\";\n        int data_len, method_len, password_len, iv_len = 0, max_iv_len;\n        const EVP_CIPHER *cipher_type;\n        EVP_CIPHER_CTX cipher_ctx;\n       int i, outlen, keylen;\n        unsigned char *outbuf, *key;\n        zend_bool free_iv;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"sss|bs\", &data, &data_len, &method, &method_len, &password, &password_len, &raw_output, &iv, &iv_len) == FAILURE) {\n\t\treturn;\n\t}\n\tcipher_type = EVP_get_cipherbyname(method);\n\tif (!cipher_type) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unknown cipher algorithm\");\n\t\tRETURN_FALSE;\n\t}\n\n\tkeylen = EVP_CIPHER_key_length(cipher_type);\n\tif (keylen > password_len) {\n\t\tkey = emalloc(keylen);\n\t\tmemset(key, 0, keylen);\n\t\tmemcpy(key, password, password_len);\n\t} else {\n\t\tkey = (unsigned char*)password;\n\t}\n\n\tmax_iv_len = EVP_CIPHER_iv_length(cipher_type);\n\tif (iv_len <= 0 && max_iv_len > 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Using an empty Initialization Vector (iv) is potentially insecure and not recommended\");\n\t}\n\tfree_iv = php_openssl_validate_iv(&iv, &iv_len, max_iv_len TSRMLS_CC);\n\n\toutlen = data_len + EVP_CIPHER_block_size(cipher_type);\n\toutbuf = emalloc(outlen + 1);\n\n\tEVP_EncryptInit(&cipher_ctx, cipher_type, NULL, NULL);\n\tif (password_len > keylen) {\n\t\tEVP_CIPHER_CTX_set_key_length(&cipher_ctx, password_len);\n\t}\n\tEVP_EncryptInit_ex(&cipher_ctx, NULL, NULL, key, (unsigned char *)iv);\n\tif (data_len > 0) {\n\t\tEVP_EncryptUpdate(&cipher_ctx, outbuf, &i, (unsigned char *)data, data_len);\n\t}\n\toutlen = i;\n\tif (EVP_EncryptFinal(&cipher_ctx, (unsigned char *)outbuf + i, &i)) {\n\t\toutlen += i;\n\t\tif (raw_output) {\n\t\t\toutbuf[outlen] = '\\0';\n\t\t\tRETVAL_STRINGL((char *)outbuf, outlen, 0);\n\t\t} else {\n\t\t\tint base64_str_len;\n\t\t\tchar *base64_str;\n\n\t\t\tbase64_str = (char*)php_base64_encode(outbuf, outlen, &base64_str_len);\n\t\t\tefree(outbuf);\n\t\t\tRETVAL_STRINGL(base64_str, base64_str_len, 0);\n\t\t}\n\t} else {\n\t\tefree(outbuf);\n\t\tRETVAL_FALSE;\n\t}\n\tif (key != (unsigned char*)password) {\n\t\tefree(key);\n\t}\n\tif (free_iv) {\n\t\tefree(iv);\n\t}\n\tEVP_CIPHER_CTX_cleanup(&cipher_ctx);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144309,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "PHP_FUNCTION(openssl_x509_parse)\n{\n\tzval ** zcert;\n\tX509 * cert = NULL;\n\tlong certresource = -1;\n\tint i;\n\tzend_bool useshortnames = 1;\n\tchar * tmpstr;\n\tzval * subitem;\n\tX509_EXTENSION *extension;\n\tchar *extname;\n\tBIO  *bio_out;\n\tBUF_MEM *bio_buf;\n\tchar buf[256];\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"Z|b\", &zcert, &useshortnames) == FAILURE) {\n\t\treturn;\n\t}\n\tcert = php_openssl_x509_from_zval(zcert, 0, &certresource TSRMLS_CC);\n\tif (cert == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tarray_init(return_value);\n\n\tif (cert->name) {\n\t\tadd_assoc_string(return_value, \"name\", cert->name, 1);\n\t}\n/*\tadd_assoc_bool(return_value, \"valid\", cert->valid); */\n\n\tadd_assoc_name_entry(return_value, \"subject\", \t\tX509_get_subject_name(cert), useshortnames TSRMLS_CC);\n\t/* hash as used in CA directories to lookup cert by subject name */\n\t{\n\t\tchar buf[32];\n\t\tsnprintf(buf, sizeof(buf), \"%08lx\", X509_subject_name_hash(cert));\n\t\tadd_assoc_string(return_value, \"hash\", buf, 1);\n\t}\n\t\n\tadd_assoc_name_entry(return_value, \"issuer\", \t\tX509_get_issuer_name(cert), useshortnames TSRMLS_CC);\n\tadd_assoc_long(return_value, \"version\", \t\t\tX509_get_version(cert));\n\n\tadd_assoc_string(return_value, \"serialNumber\", i2s_ASN1_INTEGER(NULL, X509_get_serialNumber(cert)), 1); \n\n\tadd_assoc_asn1_string(return_value, \"validFrom\", \tX509_get_notBefore(cert));\n\tadd_assoc_asn1_string(return_value, \"validTo\", \t\tX509_get_notAfter(cert));\n\n\tadd_assoc_long(return_value, \"validFrom_time_t\", \tasn1_time_to_time_t(X509_get_notBefore(cert) TSRMLS_CC));\n\tadd_assoc_long(return_value, \"validTo_time_t\", \t\tasn1_time_to_time_t(X509_get_notAfter(cert) TSRMLS_CC));\n\n\ttmpstr = (char *)X509_alias_get0(cert, NULL);\n\tif (tmpstr) {\n\t\tadd_assoc_string(return_value, \"alias\", tmpstr, 1);\n\t}\n/*\n\tadd_assoc_long(return_value, \"signaturetypeLONG\", X509_get_signature_type(cert));\n\tadd_assoc_string(return_value, \"signaturetype\", OBJ_nid2sn(X509_get_signature_type(cert)), 1);\n\tadd_assoc_string(return_value, \"signaturetypeLN\", OBJ_nid2ln(X509_get_signature_type(cert)), 1);\n*/\n\tMAKE_STD_ZVAL(subitem);\n\tarray_init(subitem);\n\n\t/* NOTE: the purposes are added as integer keys - the keys match up to the X509_PURPOSE_SSL_XXX defines\n\t   in x509v3.h */\n\tfor (i = 0; i < X509_PURPOSE_get_count(); i++) {\n\t\tint id, purpset;\n\t\tchar * pname;\n\t\tX509_PURPOSE * purp;\n\t\tzval * subsub;\n\n\t\tMAKE_STD_ZVAL(subsub);\n\t\tarray_init(subsub);\n\n\t\tpurp = X509_PURPOSE_get0(i);\n\t\tid = X509_PURPOSE_get_id(purp);\n\n\t\tpurpset = X509_check_purpose(cert, id, 0);\n\t\tadd_index_bool(subsub, 0, purpset);\n\n\t\tpurpset = X509_check_purpose(cert, id, 1);\n\t\tadd_index_bool(subsub, 1, purpset);\n\n\t\tpname = useshortnames ? X509_PURPOSE_get0_sname(purp) : X509_PURPOSE_get0_name(purp);\n\t\tadd_index_string(subsub, 2, pname, 1);\n\n\t\t/* NOTE: if purpset > 1 then it's a warning - we should mention it ? */\n\n\t\tadd_index_zval(subitem, id, subsub);\n\t}\n\tadd_assoc_zval(return_value, \"purposes\", subitem);\n\n\tMAKE_STD_ZVAL(subitem);\n\tarray_init(subitem);\n\n\n\tfor (i = 0; i < X509_get_ext_count(cert); i++) {\n\t\textension = X509_get_ext(cert, i);\n\t\tif (OBJ_obj2nid(X509_EXTENSION_get_object(extension)) != NID_undef) {\n\t\t\textname = (char *)OBJ_nid2sn(OBJ_obj2nid(X509_EXTENSION_get_object(extension)));\n\t\t} else {\n\t\t\tOBJ_obj2txt(buf, sizeof(buf)-1, X509_EXTENSION_get_object(extension), 1);\n\t\t\textname = buf;\n\t\t}\n\t\tbio_out = BIO_new(BIO_s_mem());\n\t\tif (X509V3_EXT_print(bio_out, extension, 0, 0)) {\n\t\t\tBIO_get_mem_ptr(bio_out, &bio_buf);\n\t\t\tadd_assoc_stringl(subitem, extname, bio_buf->data, bio_buf->length, 1);\n\t\t} else {\n\t\t\tadd_assoc_asn1_string(subitem, extname, X509_EXTENSION_get_data(extension));\n\t\t}\n\t\tBIO_free(bio_out);\n\t}\n\tadd_assoc_zval(return_value, \"extensions\", subitem);\n\n\tif (certresource == -1 && cert) {\n\t\tX509_free(cert);\n\t}\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144310,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static void vmxnet3_complete_packet(VMXNET3State *s, int qidx, uint32_t tx_ridx)\n{\n    struct Vmxnet3_TxCompDesc txcq_descr;\n    PCIDevice *d = PCI_DEVICE(s);\n \n     VMXNET3_RING_DUMP(VMW_RIPRN, \"TXC\", qidx, &s->txq_descr[qidx].comp_ring);\n \n     txcq_descr.txdIdx = tx_ridx;\n     txcq_descr.gen = vmxnet3_ring_curr_gen(&s->txq_descr[qidx].comp_ring);\n\n    /* Flush changes in TX descriptor before changing the counter value */\n    smp_wmb();\n\n    vmxnet3_inc_tx_completion_counter(s, qidx);\n    vmxnet3_trigger_interrupt(s, s->txq_descr[qidx].intr_idx);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144333,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static void vmxnet3_complete_packet(VMXNET3State *s, int qidx, uint32_t tx_ridx)\n{\n    struct Vmxnet3_TxCompDesc txcq_descr;\n    PCIDevice *d = PCI_DEVICE(s);\n \n     VMXNET3_RING_DUMP(VMW_RIPRN, \"TXC\", qidx, &s->txq_descr[qidx].comp_ring);\n \n    memset(&txcq_descr, 0, sizeof(txcq_descr));\n     txcq_descr.txdIdx = tx_ridx;\n     txcq_descr.gen = vmxnet3_ring_curr_gen(&s->txq_descr[qidx].comp_ring);\n\n    /* Flush changes in TX descriptor before changing the counter value */\n    smp_wmb();\n\n    vmxnet3_inc_tx_completion_counter(s, qidx);\n    vmxnet3_trigger_interrupt(s, s->txq_descr[qidx].intr_idx);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144334,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static void patch_instruction(VAPICROMState *s, X86CPU *cpu, target_ulong ip)\n{\n    CPUState *cs = CPU(cpu);\n     CPUX86State *env = &cpu->env;\n     VAPICHandlers *handlers;\n     uint8_t opcode[2];\n    uint32_t imm32;\n     target_ulong current_pc = 0;\n     target_ulong current_cs_base = 0;\n     uint32_t current_flags = 0;\n\n    if (smp_cpus == 1) {\n        handlers = &s->rom_state.up;\n    } else {\n        handlers = &s->rom_state.mp;\n    }\n\n    if (!kvm_enabled()) {\n        cpu_get_tb_cpu_state(env, &current_pc, &current_cs_base,\n                             &current_flags);\n    }\n\n    pause_all_vcpus();\n\n    cpu_memory_rw_debug(cs, ip, opcode, sizeof(opcode), 0);\n\n    switch (opcode[0]) {\n    case 0x89: /* mov r32 to r/m32 */\n        patch_byte(cpu, ip, 0x50 + modrm_reg(opcode[1]));  /* push reg */\n        patch_call(s, cpu, ip + 1, handlers->set_tpr);\n        break;\n    case 0x8b: /* mov r/m32 to r32 */\n        patch_byte(cpu, ip, 0x90);\n        patch_call(s, cpu, ip + 1, handlers->get_tpr[modrm_reg(opcode[1])]);\n        break;\n    case 0xa1: /* mov abs to eax */\n        patch_call(s, cpu, ip, handlers->get_tpr[0]);\n        break;\n    case 0xa3: /* mov eax to abs */\n        patch_call(s, cpu, ip, handlers->set_tpr_eax);\n        break;\n    case 0xc7: /* mov imm32, r/m32 (c7/0) */\n        patch_byte(cpu, ip, 0x68);  /* push imm32 */\n        cpu_memory_rw_debug(cs, ip + 6, (void *)&imm32, sizeof(imm32), 0);\n        cpu_memory_rw_debug(cs, ip + 1, (void *)&imm32, sizeof(imm32), 1);\n        patch_call(s, cpu, ip + 5, handlers->set_tpr);\n        break;\n    case 0xff: /* push r/m32 */\n        patch_byte(cpu, ip, 0x50); /* push eax */\n        patch_call(s, cpu, ip + 1, handlers->get_tpr_stack);\n        break;\n    default:\n        abort();\n    }\n\n    resume_all_vcpus();\n\n    if (!kvm_enabled()) {\n        tb_gen_code(cs, current_pc, current_cs_base, current_flags, 1);\n        cpu_resume_from_signal(cs, NULL);\n    }\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144359,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static void patch_instruction(VAPICROMState *s, X86CPU *cpu, target_ulong ip)\n{\n    CPUState *cs = CPU(cpu);\n     CPUX86State *env = &cpu->env;\n     VAPICHandlers *handlers;\n     uint8_t opcode[2];\n    uint32_t imm32 = 0;\n     target_ulong current_pc = 0;\n     target_ulong current_cs_base = 0;\n     uint32_t current_flags = 0;\n\n    if (smp_cpus == 1) {\n        handlers = &s->rom_state.up;\n    } else {\n        handlers = &s->rom_state.mp;\n    }\n\n    if (!kvm_enabled()) {\n        cpu_get_tb_cpu_state(env, &current_pc, &current_cs_base,\n                             &current_flags);\n    }\n\n    pause_all_vcpus();\n\n    cpu_memory_rw_debug(cs, ip, opcode, sizeof(opcode), 0);\n\n    switch (opcode[0]) {\n    case 0x89: /* mov r32 to r/m32 */\n        patch_byte(cpu, ip, 0x50 + modrm_reg(opcode[1]));  /* push reg */\n        patch_call(s, cpu, ip + 1, handlers->set_tpr);\n        break;\n    case 0x8b: /* mov r/m32 to r32 */\n        patch_byte(cpu, ip, 0x90);\n        patch_call(s, cpu, ip + 1, handlers->get_tpr[modrm_reg(opcode[1])]);\n        break;\n    case 0xa1: /* mov abs to eax */\n        patch_call(s, cpu, ip, handlers->get_tpr[0]);\n        break;\n    case 0xa3: /* mov eax to abs */\n        patch_call(s, cpu, ip, handlers->set_tpr_eax);\n        break;\n    case 0xc7: /* mov imm32, r/m32 (c7/0) */\n        patch_byte(cpu, ip, 0x68);  /* push imm32 */\n        cpu_memory_rw_debug(cs, ip + 6, (void *)&imm32, sizeof(imm32), 0);\n        cpu_memory_rw_debug(cs, ip + 1, (void *)&imm32, sizeof(imm32), 1);\n        patch_call(s, cpu, ip + 5, handlers->set_tpr);\n        break;\n    case 0xff: /* push r/m32 */\n        patch_byte(cpu, ip, 0x50); /* push eax */\n        patch_call(s, cpu, ip + 1, handlers->get_tpr_stack);\n        break;\n    default:\n        abort();\n    }\n\n    resume_all_vcpus();\n\n    if (!kvm_enabled()) {\n        tb_gen_code(cs, current_pc, current_cs_base, current_flags, 1);\n        cpu_resume_from_signal(cs, NULL);\n    }\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144360,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "int pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc,\n                        const char **argv) {\n\n  struct passwd *pw = NULL, pw_s;\n  const char *user = NULL;\n\n  cfg_t cfg_st;\n  cfg_t *cfg = &cfg_st;\n  char buffer[BUFSIZE];\n  char *buf = NULL;\n  char *authfile_dir;\n  size_t authfile_dir_len;\n  int pgu_ret, gpn_ret;\n   int retval = PAM_IGNORE;\n   device_t *devices = NULL;\n   unsigned n_devices = 0;\n  int openasuser;\n   int should_free_origin = 0;\n   int should_free_appid = 0;\n   int should_free_auth_file = 0;\n   int should_free_authpending_file = 0;\n \n   parse_cfg(flags, argc, argv, cfg);\n \n  if (!cfg->origin) {\n    strcpy(buffer, DEFAULT_ORIGIN_PREFIX);\n\n    if (gethostname(buffer + strlen(DEFAULT_ORIGIN_PREFIX),\n                    BUFSIZE - strlen(DEFAULT_ORIGIN_PREFIX)) == -1) {\n      DBG(\"Unable to get host name\");\n      goto done;\n    }\n    DBG(\"Origin not specified, using \\\"%s\\\"\", buffer);\n    cfg->origin = strdup(buffer);\n    if (!cfg->origin) {\n      DBG(\"Unable to allocate memory\");\n      goto done;\n    } else {\n      should_free_origin = 1;\n    }\n  }\n\n  if (!cfg->appid) {\n    DBG(\"Appid not specified, using the same value of origin (%s)\",\n         cfg->origin);\n    cfg->appid = strdup(cfg->origin);\n    if (!cfg->appid) {\n      DBG(\"Unable to allocate memory\")\n      goto done;\n    } else {\n      should_free_appid = 1;\n    }\n  }\n\n  if (cfg->max_devs == 0) {\n    DBG(\"Maximum devices number not set. Using default (%d)\", MAX_DEVS);\n    cfg->max_devs = MAX_DEVS;\n  }\n\n  devices = malloc(sizeof(device_t) * cfg->max_devs);\n  if (!devices) {\n    DBG(\"Unable to allocate memory\");\n    retval = PAM_IGNORE;\n    goto done;\n  }\n\n  pgu_ret = pam_get_user(pamh, &user, NULL);\n  if (pgu_ret != PAM_SUCCESS || user == NULL) {\n    DBG(\"Unable to access user %s\", user);\n    retval = PAM_CONV_ERR;\n    goto done;\n  }\n\n  DBG(\"Requesting authentication for user %s\", user);\n\n  gpn_ret = getpwnam_r(user, &pw_s, buffer, sizeof(buffer), &pw);\n  if (gpn_ret != 0 || pw == NULL || pw->pw_dir == NULL ||\n      pw->pw_dir[0] != '/') {\n    DBG(\"Unable to retrieve credentials for user %s, (%s)\", user,\n         strerror(errno));\n    retval = PAM_USER_UNKNOWN;\n    goto done;\n  }\n\n  DBG(\"Found user %s\", user);\n  DBG(\"Home directory for %s is %s\", user, pw->pw_dir);\n\n  if (!cfg->auth_file) {\n    buf = NULL;\n    authfile_dir = secure_getenv(DEFAULT_AUTHFILE_DIR_VAR);\n    if (!authfile_dir) {\n      DBG(\"Variable %s is not set. Using default value ($HOME/.config/)\",\n           DEFAULT_AUTHFILE_DIR_VAR);\n      authfile_dir_len =\n        strlen(pw->pw_dir) + strlen(\"/.config\") + strlen(DEFAULT_AUTHFILE) + 1;\n      buf = malloc(sizeof(char) * (authfile_dir_len));\n\n      if (!buf) {\n        DBG(\"Unable to allocate memory\");\n        retval = PAM_IGNORE;\n         goto done;\n       }\n \n       snprintf(buf, authfile_dir_len,\n                \"%s/.config%s\", pw->pw_dir, DEFAULT_AUTHFILE);\n     } else {\n      DBG(\"Variable %s set to %s\", DEFAULT_AUTHFILE_DIR_VAR, authfile_dir);\n      authfile_dir_len = strlen(authfile_dir) + strlen(DEFAULT_AUTHFILE) + 1;\n      buf = malloc(sizeof(char) * (authfile_dir_len));\n\n      if (!buf) {\n        DBG(\"Unable to allocate memory\");\n        retval = PAM_IGNORE;\n        goto done;\n      }\n \n       snprintf(buf, authfile_dir_len,\n                \"%s%s\", authfile_dir, DEFAULT_AUTHFILE);\n     }\n \n    DBG(\"Using default authentication file %s\", buf);\n \n     cfg->auth_file = buf; /* cfg takes ownership */\n     should_free_auth_file = 1;\n    buf = NULL;\n  } else {\n     DBG(\"Using authentication file %s\", cfg->auth_file);\n   }\n \n  openasuser = geteuid() == 0 && cfg->openasuser;\n   if (openasuser) {\n    if (seteuid(pw_s.pw_uid)) {\n      DBG(\"Unable to switch user to uid %i\", pw_s.pw_uid);\n       retval = PAM_IGNORE;\n       goto done;\n     }\n    DBG(\"Switched to uid %i\", pw_s.pw_uid);\n   }\n   retval = get_devices_from_authfile(cfg->auth_file, user, cfg->max_devs,\n                                      cfg->debug, cfg->debug_file,\n                                      devices, &n_devices);\n   if (openasuser) {\n    if (seteuid(0)) {\n      DBG(\"Unable to switch back to uid 0\");\n       retval = PAM_IGNORE;\n       goto done;\n     }\n    DBG(\"Switched back to uid 0\");\n   }\n \n   if (retval != 1) {\n    n_devices = 0;\n  }\n\n  if (n_devices == 0) {\n    if (cfg->nouserok) {\n      DBG(\"Found no devices but nouserok specified. Skipping authentication\");\n      retval = PAM_SUCCESS;\n      goto done;\n    } else if (retval != 1) {\n      DBG(\"Unable to get devices from file %s\", cfg->auth_file);\n      retval = PAM_AUTHINFO_UNAVAIL;\n      goto done;\n    } else {\n      DBG(\"Found no devices. Aborting.\");\n      retval = PAM_AUTHINFO_UNAVAIL;\n      goto done;\n    }\n  }\n\n  if (!cfg->authpending_file) {\n    int actual_size = snprintf(buffer, BUFSIZE, DEFAULT_AUTHPENDING_FILE_PATH, getuid());\n    if (actual_size >= 0 && actual_size < BUFSIZE) {\n      cfg->authpending_file = strdup(buffer);\n    }\n    if (!cfg->authpending_file) {\n      DBG(\"Unable to allocate memory for the authpending_file, touch request notifications will not be emitted\");\n    } else {\n      should_free_authpending_file = 1;\n    }\n  } else {\n    if (strlen(cfg->authpending_file) == 0) {\n      DBG(\"authpending_file is set to an empty value, touch request notifications will be disabled\");\n      cfg->authpending_file = NULL;\n    }\n  }\n\n  int authpending_file_descriptor = -1;\n  if (cfg->authpending_file) {\n    DBG(\"Using file '%s' for emitting touch request notifications\", cfg->authpending_file);\n\n    authpending_file_descriptor =\n      open(cfg->authpending_file, O_RDONLY | O_CREAT | O_CLOEXEC | O_NOFOLLOW | O_NOCTTY, 0664);\n    if (authpending_file_descriptor < 0) {\n      DBG(\"Unable to emit 'authentication started' notification by opening the file '%s', (%s)\",\n          cfg->authpending_file, strerror(errno));\n    }\n  }\n\n  if (cfg->manual == 0) {\n    if (cfg->interactive) {\n      converse(pamh, PAM_PROMPT_ECHO_ON,\n               cfg->prompt != NULL ? cfg->prompt : DEFAULT_PROMPT);\n    }\n\n    retval = do_authentication(cfg, devices, n_devices, pamh);\n  } else {\n    retval = do_manual_authentication(cfg, devices, n_devices, pamh);\n  }\n\n  if (authpending_file_descriptor >= 0) {\n    if (close(authpending_file_descriptor) < 0) {\n      DBG(\"Unable to emit 'authentication stopped' notification by closing the file '%s', (%s)\",\n          cfg->authpending_file, strerror(errno));\n    }\n  }\n\n  if (retval != 1) {\n    DBG(\"do_authentication returned %d\", retval);\n    retval = PAM_AUTH_ERR;\n    goto done;\n  }\n\n  retval = PAM_SUCCESS;\n\ndone:\n  free_devices(devices, n_devices);\n\n  if (buf) {\n    free(buf);\n    buf = NULL;\n  }\n\n  if (should_free_origin) {\n    free((char *) cfg->origin);\n    cfg->origin = NULL;\n  }\n\n  if (should_free_appid) {\n    free((char *) cfg->appid);\n    cfg->appid = NULL;\n  }\n\n  if (should_free_auth_file) {\n    free((char *) cfg->auth_file);\n    cfg->auth_file = NULL;\n  }\n\n  if (should_free_authpending_file) {\n    free((char *) cfg->authpending_file);\n    cfg->authpending_file = NULL;\n  }\n\n  if (cfg->alwaysok && retval != PAM_SUCCESS) {\n    DBG(\"alwaysok needed (otherwise return with %d)\", retval);\n    retval = PAM_SUCCESS;\n  }\n  DBG(\"done. [%s]\", pam_strerror(pamh, retval));\n\n  if (cfg->is_custom_debug_file) {\n    fclose(cfg->debug_file);\n  }\n\n  return retval;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144465,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "int pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc,\n                        const char **argv) {\n\n  struct passwd *pw = NULL, pw_s;\n  const char *user = NULL;\n\n  cfg_t cfg_st;\n  cfg_t *cfg = &cfg_st;\n  char buffer[BUFSIZE];\n  char *buf = NULL;\n  char *authfile_dir;\n  size_t authfile_dir_len;\n  int pgu_ret, gpn_ret;\n   int retval = PAM_IGNORE;\n   device_t *devices = NULL;\n   unsigned n_devices = 0;\n  int openasuser = 0;\n   int should_free_origin = 0;\n   int should_free_appid = 0;\n   int should_free_auth_file = 0;\n   int should_free_authpending_file = 0;\n  PAM_MODUTIL_DEF_PRIVS(privs);\n \n   parse_cfg(flags, argc, argv, cfg);\n \n  if (!cfg->origin) {\n    strcpy(buffer, DEFAULT_ORIGIN_PREFIX);\n\n    if (gethostname(buffer + strlen(DEFAULT_ORIGIN_PREFIX),\n                    BUFSIZE - strlen(DEFAULT_ORIGIN_PREFIX)) == -1) {\n      DBG(\"Unable to get host name\");\n      goto done;\n    }\n    DBG(\"Origin not specified, using \\\"%s\\\"\", buffer);\n    cfg->origin = strdup(buffer);\n    if (!cfg->origin) {\n      DBG(\"Unable to allocate memory\");\n      goto done;\n    } else {\n      should_free_origin = 1;\n    }\n  }\n\n  if (!cfg->appid) {\n    DBG(\"Appid not specified, using the same value of origin (%s)\",\n         cfg->origin);\n    cfg->appid = strdup(cfg->origin);\n    if (!cfg->appid) {\n      DBG(\"Unable to allocate memory\")\n      goto done;\n    } else {\n      should_free_appid = 1;\n    }\n  }\n\n  if (cfg->max_devs == 0) {\n    DBG(\"Maximum devices number not set. Using default (%d)\", MAX_DEVS);\n    cfg->max_devs = MAX_DEVS;\n  }\n\n  devices = malloc(sizeof(device_t) * cfg->max_devs);\n  if (!devices) {\n    DBG(\"Unable to allocate memory\");\n    retval = PAM_IGNORE;\n    goto done;\n  }\n\n  pgu_ret = pam_get_user(pamh, &user, NULL);\n  if (pgu_ret != PAM_SUCCESS || user == NULL) {\n    DBG(\"Unable to access user %s\", user);\n    retval = PAM_CONV_ERR;\n    goto done;\n  }\n\n  DBG(\"Requesting authentication for user %s\", user);\n\n  gpn_ret = getpwnam_r(user, &pw_s, buffer, sizeof(buffer), &pw);\n  if (gpn_ret != 0 || pw == NULL || pw->pw_dir == NULL ||\n      pw->pw_dir[0] != '/') {\n    DBG(\"Unable to retrieve credentials for user %s, (%s)\", user,\n         strerror(errno));\n    retval = PAM_USER_UNKNOWN;\n    goto done;\n  }\n\n  DBG(\"Found user %s\", user);\n  DBG(\"Home directory for %s is %s\", user, pw->pw_dir);\n\n  if (!cfg->auth_file) {\n    buf = NULL;\n    authfile_dir = secure_getenv(DEFAULT_AUTHFILE_DIR_VAR);\n    if (!authfile_dir) {\n      DBG(\"Variable %s is not set. Using default value ($HOME/.config/)\",\n           DEFAULT_AUTHFILE_DIR_VAR);\n      authfile_dir_len =\n        strlen(pw->pw_dir) + strlen(\"/.config\") + strlen(DEFAULT_AUTHFILE) + 1;\n      buf = malloc(sizeof(char) * (authfile_dir_len));\n\n      if (!buf) {\n        DBG(\"Unable to allocate memory\");\n        retval = PAM_IGNORE;\n         goto done;\n       }\n \n      /* Opening a file in a users $HOME, need to drop privs for security */\n      openasuser = geteuid() == 0 ? 1 : 0;\n\n       snprintf(buf, authfile_dir_len,\n                \"%s/.config%s\", pw->pw_dir, DEFAULT_AUTHFILE);\n     } else {\n      DBG(\"Variable %s set to %s\", DEFAULT_AUTHFILE_DIR_VAR, authfile_dir);\n      authfile_dir_len = strlen(authfile_dir) + strlen(DEFAULT_AUTHFILE) + 1;\n      buf = malloc(sizeof(char) * (authfile_dir_len));\n\n      if (!buf) {\n        DBG(\"Unable to allocate memory\");\n        retval = PAM_IGNORE;\n        goto done;\n      }\n \n       snprintf(buf, authfile_dir_len,\n                \"%s%s\", authfile_dir, DEFAULT_AUTHFILE);\n\n      if (!openasuser) {\n\tDBG(\"WARNING: not dropping privileges when reading %s, please \"\n\t    \"consider setting openasuser=1 in the module configuration\", buf);\n      }\n     }\n \n    DBG(\"Using authentication file %s\", buf);\n \n     cfg->auth_file = buf; /* cfg takes ownership */\n     should_free_auth_file = 1;\n    buf = NULL;\n  } else {\n     DBG(\"Using authentication file %s\", cfg->auth_file);\n   }\n \n  if (!openasuser) {\n    openasuser = geteuid() == 0 && cfg->openasuser;\n  }\n   if (openasuser) {\n    DBG(\"Dropping privileges\");\n    if (pam_modutil_drop_priv(pamh, &privs, pw)) {\n      DBG(\"Unable to switch user to uid %i\", pw->pw_uid);\n       retval = PAM_IGNORE;\n       goto done;\n     }\n    DBG(\"Switched to uid %i\", pw->pw_uid);\n   }\n   retval = get_devices_from_authfile(cfg->auth_file, user, cfg->max_devs,\n                                      cfg->debug, cfg->debug_file,\n                                      devices, &n_devices);\n   if (openasuser) {\n    if (pam_modutil_regain_priv(pamh, &privs)) {\n      DBG(\"could not restore privileges\");\n       retval = PAM_IGNORE;\n       goto done;\n     }\n    DBG(\"Restored privileges\");\n   }\n \n   if (retval != 1) {\n    n_devices = 0;\n  }\n\n  if (n_devices == 0) {\n    if (cfg->nouserok) {\n      DBG(\"Found no devices but nouserok specified. Skipping authentication\");\n      retval = PAM_SUCCESS;\n      goto done;\n    } else if (retval != 1) {\n      DBG(\"Unable to get devices from file %s\", cfg->auth_file);\n      retval = PAM_AUTHINFO_UNAVAIL;\n      goto done;\n    } else {\n      DBG(\"Found no devices. Aborting.\");\n      retval = PAM_AUTHINFO_UNAVAIL;\n      goto done;\n    }\n  }\n\n  if (!cfg->authpending_file) {\n    int actual_size = snprintf(buffer, BUFSIZE, DEFAULT_AUTHPENDING_FILE_PATH, getuid());\n    if (actual_size >= 0 && actual_size < BUFSIZE) {\n      cfg->authpending_file = strdup(buffer);\n    }\n    if (!cfg->authpending_file) {\n      DBG(\"Unable to allocate memory for the authpending_file, touch request notifications will not be emitted\");\n    } else {\n      should_free_authpending_file = 1;\n    }\n  } else {\n    if (strlen(cfg->authpending_file) == 0) {\n      DBG(\"authpending_file is set to an empty value, touch request notifications will be disabled\");\n      cfg->authpending_file = NULL;\n    }\n  }\n\n  int authpending_file_descriptor = -1;\n  if (cfg->authpending_file) {\n    DBG(\"Using file '%s' for emitting touch request notifications\", cfg->authpending_file);\n\n    authpending_file_descriptor =\n      open(cfg->authpending_file, O_RDONLY | O_CREAT | O_CLOEXEC | O_NOFOLLOW | O_NOCTTY, 0664);\n    if (authpending_file_descriptor < 0) {\n      DBG(\"Unable to emit 'authentication started' notification by opening the file '%s', (%s)\",\n          cfg->authpending_file, strerror(errno));\n    }\n  }\n\n  if (cfg->manual == 0) {\n    if (cfg->interactive) {\n      converse(pamh, PAM_PROMPT_ECHO_ON,\n               cfg->prompt != NULL ? cfg->prompt : DEFAULT_PROMPT);\n    }\n\n    retval = do_authentication(cfg, devices, n_devices, pamh);\n  } else {\n    retval = do_manual_authentication(cfg, devices, n_devices, pamh);\n  }\n\n  if (authpending_file_descriptor >= 0) {\n    if (close(authpending_file_descriptor) < 0) {\n      DBG(\"Unable to emit 'authentication stopped' notification by closing the file '%s', (%s)\",\n          cfg->authpending_file, strerror(errno));\n    }\n  }\n\n  if (retval != 1) {\n    DBG(\"do_authentication returned %d\", retval);\n    retval = PAM_AUTH_ERR;\n    goto done;\n  }\n\n  retval = PAM_SUCCESS;\n\ndone:\n  free_devices(devices, n_devices);\n\n  if (buf) {\n    free(buf);\n    buf = NULL;\n  }\n\n  if (should_free_origin) {\n    free((char *) cfg->origin);\n    cfg->origin = NULL;\n  }\n\n  if (should_free_appid) {\n    free((char *) cfg->appid);\n    cfg->appid = NULL;\n  }\n\n  if (should_free_auth_file) {\n    free((char *) cfg->auth_file);\n    cfg->auth_file = NULL;\n  }\n\n  if (should_free_authpending_file) {\n    free((char *) cfg->authpending_file);\n    cfg->authpending_file = NULL;\n  }\n\n  if (cfg->alwaysok && retval != PAM_SUCCESS) {\n    DBG(\"alwaysok needed (otherwise return with %d)\", retval);\n    retval = PAM_SUCCESS;\n  }\n  DBG(\"done. [%s]\", pam_strerror(pamh, retval));\n\n  if (cfg->is_custom_debug_file) {\n    fclose(cfg->debug_file);\n  }\n\n  return retval;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144466,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int megasas_ctrl_get_info(MegasasState *s, MegasasCmd *cmd)\n{\n    PCIDevice *pci_dev = PCI_DEVICE(s);\n    PCIDeviceClass *pci_class = PCI_DEVICE_GET_CLASS(pci_dev);\n    MegasasBaseClass *base_class = MEGASAS_DEVICE_GET_CLASS(s);\n    struct mfi_ctrl_info info;\n    size_t dcmd_size = sizeof(info);\n    BusChild *kid;\n    int num_pd_disks = 0;\n\n    memset(&info, 0x0, dcmd_size);\n    if (cmd->iov_size < dcmd_size) {\n        trace_megasas_dcmd_invalid_xfer_len(cmd->index, cmd->iov_size,\n                                            dcmd_size);\n        return MFI_STAT_INVALID_PARAMETER;\n    }\n\n    info.pci.vendor = cpu_to_le16(pci_class->vendor_id);\n    info.pci.device = cpu_to_le16(pci_class->device_id);\n    info.pci.subvendor = cpu_to_le16(pci_class->subsystem_vendor_id);\n    info.pci.subdevice = cpu_to_le16(pci_class->subsystem_id);\n\n    /*\n     * For some reason the firmware supports\n     * only up to 8 device ports.\n     * Despite supporting a far larger number\n     * of devices for the physical devices.\n     * So just display the first 8 devices\n     * in the device port list, independent\n     * of how many logical devices are actually\n     * present.\n     */\n    info.host.type = MFI_INFO_HOST_PCIE;\n    info.device.type = MFI_INFO_DEV_SAS3G;\n    info.device.port_count = 8;\n    QTAILQ_FOREACH(kid, &s->bus.qbus.children, sibling) {\n        SCSIDevice *sdev = SCSI_DEVICE(kid->child);\n        uint16_t pd_id;\n\n        if (num_pd_disks < 8) {\n            pd_id = ((sdev->id & 0xFF) << 8) | (sdev->lun & 0xFF);\n            info.device.port_addr[num_pd_disks] =\n                cpu_to_le64(megasas_get_sata_addr(pd_id));\n        }\n        num_pd_disks++;\n    }\n\n    memcpy(info.product_name, base_class->product_name, 24);\n    snprintf(info.serial_number, 32, \"%s\", s->hba_serial);\n    snprintf(info.package_version, 0x60, \"%s-QEMU\", qemu_hw_version());\n    memcpy(info.image_component[0].name, \"APP\", 3);\n    snprintf(info.image_component[0].version, 10, \"%s-QEMU\",\n             base_class->product_version);\n    memcpy(info.image_component[0].build_date, \"Apr  1 2014\", 11);\n    memcpy(info.image_component[0].build_time, \"12:34:56\", 8);\n    info.image_component_count = 1;\n    if (pci_dev->has_rom) {\n        uint8_t biosver[32];\n        uint8_t *ptr;\n\n        ptr = memory_region_get_ram_ptr(&pci_dev->rom);\n        memcpy(biosver, ptr + 0x41, 31);\n        memcpy(info.image_component[1].name, \"BIOS\", 4);\n        memcpy(info.image_component[1].version, biosver,\n               strlen((const char *)biosver));\n        info.image_component_count++;\n    }\n    info.current_fw_time = cpu_to_le32(megasas_fw_time());\n    info.max_arms = 32;\n    info.max_spans = 8;\n    info.max_arrays = MEGASAS_MAX_ARRAYS;\n    info.max_lds = MFI_MAX_LD;\n    info.max_cmds = cpu_to_le16(s->fw_cmds);\n    info.max_sg_elements = cpu_to_le16(s->fw_sge);\n    info.max_request_size = cpu_to_le32(MEGASAS_MAX_SECTORS);\n    if (!megasas_is_jbod(s))\n        info.lds_present = cpu_to_le16(num_pd_disks);\n    info.pd_present = cpu_to_le16(num_pd_disks);\n    info.pd_disks_present = cpu_to_le16(num_pd_disks);\n    info.hw_present = cpu_to_le32(MFI_INFO_HW_NVRAM |\n                                   MFI_INFO_HW_MEM |\n                                   MFI_INFO_HW_FLASH);\n    info.memory_size = cpu_to_le16(512);\n    info.nvram_size = cpu_to_le16(32);\n    info.flash_size = cpu_to_le16(16);\n    info.raid_levels = cpu_to_le32(MFI_INFO_RAID_0);\n    info.adapter_ops = cpu_to_le32(MFI_INFO_AOPS_RBLD_RATE |\n                                    MFI_INFO_AOPS_SELF_DIAGNOSTIC |\n                                    MFI_INFO_AOPS_MIXED_ARRAY);\n    info.ld_ops = cpu_to_le32(MFI_INFO_LDOPS_DISK_CACHE_POLICY |\n                               MFI_INFO_LDOPS_ACCESS_POLICY |\n                               MFI_INFO_LDOPS_IO_POLICY |\n                               MFI_INFO_LDOPS_WRITE_POLICY |\n                               MFI_INFO_LDOPS_READ_POLICY);\n    info.max_strips_per_io = cpu_to_le16(s->fw_sge);\n    info.stripe_sz_ops.min = 3;\n    info.stripe_sz_ops.max = ctz32(MEGASAS_MAX_SECTORS + 1);\n    info.properties.pred_fail_poll_interval = cpu_to_le16(300);\n    info.properties.intr_throttle_cnt = cpu_to_le16(16);\n    info.properties.intr_throttle_timeout = cpu_to_le16(50);\n    info.properties.rebuild_rate = 30;\n    info.properties.patrol_read_rate = 30;\n    info.properties.bgi_rate = 30;\n    info.properties.cc_rate = 30;\n    info.properties.recon_rate = 30;\n    info.properties.cache_flush_interval = 4;\n    info.properties.spinup_drv_cnt = 2;\n    info.properties.spinup_delay = 6;\n    info.properties.ecc_bucket_size = 15;\n    info.properties.ecc_bucket_leak_rate = cpu_to_le16(1440);\n    info.properties.expose_encl_devices = 1;\n    info.properties.OnOffProperties = cpu_to_le32(MFI_CTRL_PROP_EnableJBOD);\n    info.pd_ops = cpu_to_le32(MFI_INFO_PDOPS_FORCE_ONLINE |\n                               MFI_INFO_PDOPS_FORCE_OFFLINE);\n    info.pd_mix_support = cpu_to_le32(MFI_INFO_PDMIX_SAS |\n                                       MFI_INFO_PDMIX_SATA |\n                                       MFI_INFO_PDMIX_LD);\n\n    cmd->iov_size -= dma_buf_read((uint8_t *)&info, dcmd_size, &cmd->qsg);\n    return MFI_STAT_OK;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144519,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int megasas_ctrl_get_info(MegasasState *s, MegasasCmd *cmd)\n{\n    PCIDevice *pci_dev = PCI_DEVICE(s);\n    PCIDeviceClass *pci_class = PCI_DEVICE_GET_CLASS(pci_dev);\n    MegasasBaseClass *base_class = MEGASAS_DEVICE_GET_CLASS(s);\n    struct mfi_ctrl_info info;\n    size_t dcmd_size = sizeof(info);\n    BusChild *kid;\n    int num_pd_disks = 0;\n\n    memset(&info, 0x0, dcmd_size);\n    if (cmd->iov_size < dcmd_size) {\n        trace_megasas_dcmd_invalid_xfer_len(cmd->index, cmd->iov_size,\n                                            dcmd_size);\n        return MFI_STAT_INVALID_PARAMETER;\n    }\n\n    info.pci.vendor = cpu_to_le16(pci_class->vendor_id);\n    info.pci.device = cpu_to_le16(pci_class->device_id);\n    info.pci.subvendor = cpu_to_le16(pci_class->subsystem_vendor_id);\n    info.pci.subdevice = cpu_to_le16(pci_class->subsystem_id);\n\n    /*\n     * For some reason the firmware supports\n     * only up to 8 device ports.\n     * Despite supporting a far larger number\n     * of devices for the physical devices.\n     * So just display the first 8 devices\n     * in the device port list, independent\n     * of how many logical devices are actually\n     * present.\n     */\n    info.host.type = MFI_INFO_HOST_PCIE;\n    info.device.type = MFI_INFO_DEV_SAS3G;\n    info.device.port_count = 8;\n    QTAILQ_FOREACH(kid, &s->bus.qbus.children, sibling) {\n        SCSIDevice *sdev = SCSI_DEVICE(kid->child);\n        uint16_t pd_id;\n\n        if (num_pd_disks < 8) {\n            pd_id = ((sdev->id & 0xFF) << 8) | (sdev->lun & 0xFF);\n            info.device.port_addr[num_pd_disks] =\n                cpu_to_le64(megasas_get_sata_addr(pd_id));\n        }\n        num_pd_disks++;\n    }\n\n    memcpy(info.product_name, base_class->product_name, 24);\n    snprintf(info.serial_number, 32, \"%s\", s->hba_serial);\n    snprintf(info.package_version, 0x60, \"%s-QEMU\", qemu_hw_version());\n    memcpy(info.image_component[0].name, \"APP\", 3);\n    snprintf(info.image_component[0].version, 10, \"%s-QEMU\",\n             base_class->product_version);\n    memcpy(info.image_component[0].build_date, \"Apr  1 2014\", 11);\n    memcpy(info.image_component[0].build_time, \"12:34:56\", 8);\n    info.image_component_count = 1;\n    if (pci_dev->has_rom) {\n        uint8_t biosver[32];\n        uint8_t *ptr;\n \n         ptr = memory_region_get_ram_ptr(&pci_dev->rom);\n         memcpy(biosver, ptr + 0x41, 31);\n        biosver[31] = 0;\n         memcpy(info.image_component[1].name, \"BIOS\", 4);\n         memcpy(info.image_component[1].version, biosver,\n                strlen((const char *)biosver));\n    }\n    info.current_fw_time = cpu_to_le32(megasas_fw_time());\n    info.max_arms = 32;\n    info.max_spans = 8;\n    info.max_arrays = MEGASAS_MAX_ARRAYS;\n    info.max_lds = MFI_MAX_LD;\n    info.max_cmds = cpu_to_le16(s->fw_cmds);\n    info.max_sg_elements = cpu_to_le16(s->fw_sge);\n    info.max_request_size = cpu_to_le32(MEGASAS_MAX_SECTORS);\n    if (!megasas_is_jbod(s))\n        info.lds_present = cpu_to_le16(num_pd_disks);\n    info.pd_present = cpu_to_le16(num_pd_disks);\n    info.pd_disks_present = cpu_to_le16(num_pd_disks);\n    info.hw_present = cpu_to_le32(MFI_INFO_HW_NVRAM |\n                                   MFI_INFO_HW_MEM |\n                                   MFI_INFO_HW_FLASH);\n    info.memory_size = cpu_to_le16(512);\n    info.nvram_size = cpu_to_le16(32);\n    info.flash_size = cpu_to_le16(16);\n    info.raid_levels = cpu_to_le32(MFI_INFO_RAID_0);\n    info.adapter_ops = cpu_to_le32(MFI_INFO_AOPS_RBLD_RATE |\n                                    MFI_INFO_AOPS_SELF_DIAGNOSTIC |\n                                    MFI_INFO_AOPS_MIXED_ARRAY);\n    info.ld_ops = cpu_to_le32(MFI_INFO_LDOPS_DISK_CACHE_POLICY |\n                               MFI_INFO_LDOPS_ACCESS_POLICY |\n                               MFI_INFO_LDOPS_IO_POLICY |\n                               MFI_INFO_LDOPS_WRITE_POLICY |\n                               MFI_INFO_LDOPS_READ_POLICY);\n    info.max_strips_per_io = cpu_to_le16(s->fw_sge);\n    info.stripe_sz_ops.min = 3;\n    info.stripe_sz_ops.max = ctz32(MEGASAS_MAX_SECTORS + 1);\n    info.properties.pred_fail_poll_interval = cpu_to_le16(300);\n    info.properties.intr_throttle_cnt = cpu_to_le16(16);\n    info.properties.intr_throttle_timeout = cpu_to_le16(50);\n    info.properties.rebuild_rate = 30;\n    info.properties.patrol_read_rate = 30;\n    info.properties.bgi_rate = 30;\n    info.properties.cc_rate = 30;\n    info.properties.recon_rate = 30;\n    info.properties.cache_flush_interval = 4;\n    info.properties.spinup_drv_cnt = 2;\n    info.properties.spinup_delay = 6;\n    info.properties.ecc_bucket_size = 15;\n    info.properties.ecc_bucket_leak_rate = cpu_to_le16(1440);\n    info.properties.expose_encl_devices = 1;\n    info.properties.OnOffProperties = cpu_to_le32(MFI_CTRL_PROP_EnableJBOD);\n    info.pd_ops = cpu_to_le32(MFI_INFO_PDOPS_FORCE_ONLINE |\n                               MFI_INFO_PDOPS_FORCE_OFFLINE);\n    info.pd_mix_support = cpu_to_le32(MFI_INFO_PDMIX_SAS |\n                                       MFI_INFO_PDMIX_SATA |\n                                       MFI_INFO_PDMIX_LD);\n\n    cmd->iov_size -= dma_buf_read((uint8_t *)&info, dcmd_size, &cmd->qsg);\n    return MFI_STAT_OK;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144520,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "inline int web_client_api_request_v1_data(RRDHOST *host, struct web_client *w, char *url) {\n    debug(D_WEB_CLIENT, \"%llu: API v1 data with URL '%s'\", w->id, url);\n\n    int ret = 400;\n    BUFFER *dimensions = NULL;\n\n    buffer_flush(w->response.data);\n\n    char    *google_version = \"0.6\",\n            *google_reqId = \"0\",\n            *google_sig = \"0\",\n            *google_out = \"json\",\n            *responseHandler = NULL,\n            *outFileName = NULL;\n\n    time_t last_timestamp_in_data = 0, google_timestamp = 0;\n\n    char *chart = NULL\n    , *before_str = NULL\n    , *after_str = NULL\n    , *group_time_str = NULL\n    , *points_str = NULL;\n\n    int group = RRDR_GROUPING_AVERAGE;\n    uint32_t format = DATASOURCE_JSON;\n    uint32_t options = 0x00000000;\n\n    while(url) {\n        char *value = mystrsep(&url, \"?&\");\n        if(!value || !*value) continue;\n\n        char *name = mystrsep(&value, \"=\");\n        if(!name || !*name) continue;\n        if(!value || !*value) continue;\n\n        debug(D_WEB_CLIENT, \"%llu: API v1 data query param '%s' with value '%s'\", w->id, name, value);\n\n        // name and value are now the parameters\n        // they are not null and not empty\n\n        if(!strcmp(name, \"chart\")) chart = value;\n        else if(!strcmp(name, \"dimension\") || !strcmp(name, \"dim\") || !strcmp(name, \"dimensions\") || !strcmp(name, \"dims\")) {\n            if(!dimensions) dimensions = buffer_create(100);\n            buffer_strcat(dimensions, \"|\");\n            buffer_strcat(dimensions, value);\n        }\n        else if(!strcmp(name, \"after\")) after_str = value;\n        else if(!strcmp(name, \"before\")) before_str = value;\n        else if(!strcmp(name, \"points\")) points_str = value;\n        else if(!strcmp(name, \"gtime\")) group_time_str = value;\n        else if(!strcmp(name, \"group\")) {\n            group = web_client_api_request_v1_data_group(value, RRDR_GROUPING_AVERAGE);\n        }\n        else if(!strcmp(name, \"format\")) {\n            format = web_client_api_request_v1_data_format(value);\n        }\n        else if(!strcmp(name, \"options\")) {\n            options |= web_client_api_request_v1_data_options(value);\n        }\n        else if(!strcmp(name, \"callback\")) {\n            responseHandler = value;\n        }\n        else if(!strcmp(name, \"filename\")) {\n            outFileName = value;\n        }\n        else if(!strcmp(name, \"tqx\")) {\n            // parse Google Visualization API options\n            // https://developers.google.com/chart/interactive/docs/dev/implementing_data_source\n            char *tqx_name, *tqx_value;\n\n            while(value) {\n                tqx_value = mystrsep(&value, \";\");\n                if(!tqx_value || !*tqx_value) continue;\n\n                tqx_name = mystrsep(&tqx_value, \":\");\n                if(!tqx_name || !*tqx_name) continue;\n                if(!tqx_value || !*tqx_value) continue;\n\n                if(!strcmp(tqx_name, \"version\"))\n                    google_version = tqx_value;\n                else if(!strcmp(tqx_name, \"reqId\"))\n                    google_reqId = tqx_value;\n                else if(!strcmp(tqx_name, \"sig\")) {\n                    google_sig = tqx_value;\n                    google_timestamp = strtoul(google_sig, NULL, 0);\n                }\n                else if(!strcmp(tqx_name, \"out\")) {\n                    google_out = tqx_value;\n                    format = web_client_api_request_v1_data_google_format(google_out);\n                }\n                else if(!strcmp(tqx_name, \"responseHandler\"))\n                    responseHandler = tqx_value;\n                else if(!strcmp(tqx_name, \"outFileName\"))\n                    outFileName = tqx_value;\n            }\n        }\n    }\n\n    if(!chart || !*chart) {\n        buffer_sprintf(w->response.data, \"No chart id is given at the request.\");\n        goto cleanup;\n    }\n\n    RRDSET *st = rrdset_find(host, chart);\n    if(!st) st = rrdset_find_byname(host, chart);\n    if(!st) {\n        buffer_strcat(w->response.data, \"Chart is not found: \");\n        buffer_strcat_htmlescape(w->response.data, chart);\n        ret = 404;\n        goto cleanup;\n    }\n    st->last_accessed_time = now_realtime_sec();\n\n    long long before = (before_str && *before_str)?str2l(before_str):0;\n    long long after  = (after_str  && *after_str) ?str2l(after_str):0;\n    int       points = (points_str && *points_str)?str2i(points_str):0;\n    long      group_time = (group_time_str && *group_time_str)?str2l(group_time_str):0;\n\n    debug(D_WEB_CLIENT, \"%llu: API command 'data' for chart '%s', dimensions '%s', after '%lld', before '%lld', points '%d', group '%d', format '%u', options '0x%08x'\"\n          , w->id\n          , chart\n          , (dimensions)?buffer_tostring(dimensions):\"\"\n          , after\n          , before\n          , points\n          , group\n          , format\n          , options\n    );\n\n    if(outFileName && *outFileName) {\n        buffer_sprintf(w->response.header, \"Content-Disposition: attachment; filename=\\\"%s\\\"\\r\\n\", outFileName);\n        debug(D_WEB_CLIENT, \"%llu: generating outfilename header: '%s'\", w->id, outFileName);\n    }\n\n    if(format == DATASOURCE_DATATABLE_JSONP) {\n        if(responseHandler == NULL)\n            responseHandler = \"google.visualization.Query.setResponse\";\n\n        debug(D_WEB_CLIENT_ACCESS, \"%llu: GOOGLE JSON/JSONP: version = '%s', reqId = '%s', sig = '%s', out = '%s', responseHandler = '%s', outFileName = '%s'\",\n                w->id, google_version, google_reqId, google_sig, google_out, responseHandler, outFileName\n        );\n\n        buffer_sprintf(w->response.data,\n                \"%s({version:'%s',reqId:'%s',status:'ok',sig:'%ld',table:\",\n                responseHandler, google_version, google_reqId, st->last_updated.tv_sec);\n    }\n    else if(format == DATASOURCE_JSONP) {\n        if(responseHandler == NULL)\n            responseHandler = \"callback\";\n\n        buffer_strcat(w->response.data, responseHandler);\n        buffer_strcat(w->response.data, \"(\");\n    }\n\n    ret = rrdset2anything_api_v1(st, w->response.data, dimensions, format, points, after, before, group, group_time\n                                 , options, &last_timestamp_in_data);\n\n    if(format == DATASOURCE_DATATABLE_JSONP) {\n        if(google_timestamp < last_timestamp_in_data)\n            buffer_strcat(w->response.data, \"});\");\n\n        else {\n            // the client already has the latest data\n            buffer_flush(w->response.data);\n            buffer_sprintf(w->response.data,\n                    \"%s({version:'%s',reqId:'%s',status:'error',errors:[{reason:'not_modified',message:'Data not modified'}]});\",\n                    responseHandler, google_version, google_reqId);\n        }\n    }\n    else if(format == DATASOURCE_JSONP)\n        buffer_strcat(w->response.data, \");\");\n\n    cleanup:\n    buffer_free(dimensions);\n    return ret;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144585,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": " inline int web_client_api_request_v1_data(RRDHOST *host, struct web_client *w, char *url) {\n     debug(D_WEB_CLIENT, \"%llu: API v1 data with URL '%s'\", w->id, url);\n\n    int ret = 400;\n    BUFFER *dimensions = NULL;\n\n    buffer_flush(w->response.data);\n\n    char    *google_version = \"0.6\",\n            *google_reqId = \"0\",\n            *google_sig = \"0\",\n            *google_out = \"json\",\n            *responseHandler = NULL,\n            *outFileName = NULL;\n\n    time_t last_timestamp_in_data = 0, google_timestamp = 0;\n\n    char *chart = NULL\n    , *before_str = NULL\n    , *after_str = NULL\n    , *group_time_str = NULL\n    , *points_str = NULL;\n\n    int group = RRDR_GROUPING_AVERAGE;\n    uint32_t format = DATASOURCE_JSON;\n    uint32_t options = 0x00000000;\n\n    while(url) {\n        char *value = mystrsep(&url, \"?&\");\n        if(!value || !*value) continue;\n\n        char *name = mystrsep(&value, \"=\");\n        if(!name || !*name) continue;\n        if(!value || !*value) continue;\n\n        debug(D_WEB_CLIENT, \"%llu: API v1 data query param '%s' with value '%s'\", w->id, name, value);\n\n\n        if(!strcmp(name, \"chart\")) chart = value;\n        else if(!strcmp(name, \"dimension\") || !strcmp(name, \"dim\") || !strcmp(name, \"dimensions\") || !strcmp(name, \"dims\")) {\n            if(!dimensions) dimensions = buffer_create(100);\n            buffer_strcat(dimensions, \"|\");\n            buffer_strcat(dimensions, value);\n        }\n        else if(!strcmp(name, \"after\")) after_str = value;\n        else if(!strcmp(name, \"before\")) before_str = value;\n        else if(!strcmp(name, \"points\")) points_str = value;\n        else if(!strcmp(name, \"gtime\")) group_time_str = value;\n        else if(!strcmp(name, \"group\")) {\n            group = web_client_api_request_v1_data_group(value, RRDR_GROUPING_AVERAGE);\n        }\n        else if(!strcmp(name, \"format\")) {\n            format = web_client_api_request_v1_data_format(value);\n        }\n        else if(!strcmp(name, \"options\")) {\n            options |= web_client_api_request_v1_data_options(value);\n        }\n        else if(!strcmp(name, \"callback\")) {\n            responseHandler = value;\n        }\n        else if(!strcmp(name, \"filename\")) {\n            outFileName = value;\n        }\n        else if(!strcmp(name, \"tqx\")) {\n            char *tqx_name, *tqx_value;\n\n            while(value) {\n                tqx_value = mystrsep(&value, \";\");\n                if(!tqx_value || !*tqx_value) continue;\n\n                tqx_name = mystrsep(&tqx_value, \":\");\n                if(!tqx_name || !*tqx_name) continue;\n                if(!tqx_value || !*tqx_value) continue;\n\n                if(!strcmp(tqx_name, \"version\"))\n                    google_version = tqx_value;\n                else if(!strcmp(tqx_name, \"reqId\"))\n                    google_reqId = tqx_value;\n                else if(!strcmp(tqx_name, \"sig\")) {\n                    google_sig = tqx_value;\n                    google_timestamp = strtoul(google_sig, NULL, 0);\n                }\n                else if(!strcmp(tqx_name, \"out\")) {\n                    google_out = tqx_value;\n                    format = web_client_api_request_v1_data_google_format(google_out);\n                }\n                else if(!strcmp(tqx_name, \"responseHandler\"))\n                    responseHandler = tqx_value;\n                else if(!strcmp(tqx_name, \"outFileName\"))\n                    outFileName = tqx_value;\n            }\n         }\n     }\n \n    // validate the google parameters given\n    fix_google_param(google_out);\n    fix_google_param(google_sig);\n    fix_google_param(google_reqId);\n    fix_google_param(google_version);\n    fix_google_param(responseHandler);\n    fix_google_param(outFileName);\n\n     if(!chart || !*chart) {\n         buffer_sprintf(w->response.data, \"No chart id is given at the request.\");\n         goto cleanup;\n    }\n\n    RRDSET *st = rrdset_find(host, chart);\n    if(!st) st = rrdset_find_byname(host, chart);\n    if(!st) {\n        buffer_strcat(w->response.data, \"Chart is not found: \");\n        buffer_strcat_htmlescape(w->response.data, chart);\n        ret = 404;\n        goto cleanup;\n    }\n    st->last_accessed_time = now_realtime_sec();\n\n    long long before = (before_str && *before_str)?str2l(before_str):0;\n    long long after  = (after_str  && *after_str) ?str2l(after_str):0;\n    int       points = (points_str && *points_str)?str2i(points_str):0;\n    long      group_time = (group_time_str && *group_time_str)?str2l(group_time_str):0;\n\n    debug(D_WEB_CLIENT, \"%llu: API command 'data' for chart '%s', dimensions '%s', after '%lld', before '%lld', points '%d', group '%d', format '%u', options '0x%08x'\"\n          , w->id\n          , chart\n          , (dimensions)?buffer_tostring(dimensions):\"\"\n          , after\n          , before\n          , points\n          , group\n          , format\n          , options\n    );\n\n    if(outFileName && *outFileName) {\n        buffer_sprintf(w->response.header, \"Content-Disposition: attachment; filename=\\\"%s\\\"\\r\\n\", outFileName);\n        debug(D_WEB_CLIENT, \"%llu: generating outfilename header: '%s'\", w->id, outFileName);\n    }\n\n    if(format == DATASOURCE_DATATABLE_JSONP) {\n        if(responseHandler == NULL)\n            responseHandler = \"google.visualization.Query.setResponse\";\n\n        debug(D_WEB_CLIENT_ACCESS, \"%llu: GOOGLE JSON/JSONP: version = '%s', reqId = '%s', sig = '%s', out = '%s', responseHandler = '%s', outFileName = '%s'\",\n                w->id, google_version, google_reqId, google_sig, google_out, responseHandler, outFileName\n        );\n\n        buffer_sprintf(w->response.data,\n                \"%s({version:'%s',reqId:'%s',status:'ok',sig:'%ld',table:\",\n                responseHandler, google_version, google_reqId, st->last_updated.tv_sec);\n    }\n    else if(format == DATASOURCE_JSONP) {\n        if(responseHandler == NULL)\n            responseHandler = \"callback\";\n\n        buffer_strcat(w->response.data, responseHandler);\n        buffer_strcat(w->response.data, \"(\");\n    }\n\n    ret = rrdset2anything_api_v1(st, w->response.data, dimensions, format, points, after, before, group, group_time\n                                 , options, &last_timestamp_in_data);\n\n    if(format == DATASOURCE_DATATABLE_JSONP) {\n        if(google_timestamp < last_timestamp_in_data)\n            buffer_strcat(w->response.data, \"});\");\n\n        else {\n            buffer_flush(w->response.data);\n            buffer_sprintf(w->response.data,\n                    \"%s({version:'%s',reqId:'%s',status:'error',errors:[{reason:'not_modified',message:'Data not modified'}]});\",\n                    responseHandler, google_version, google_reqId);\n        }\n    }\n    else if(format == DATASOURCE_JSONP)\n        buffer_strcat(w->response.data, \");\");\n\n    cleanup:\n    buffer_free(dimensions);\n    return ret;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144586,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "FastCGIServer::FastCGIServer(const std::string &address,\n                             int port,\n                             int workers,\n                             bool useFileSocket)\n  : Server(address, port),\n    m_worker(&m_eventBaseManager),\n    m_dispatcher(workers, workers,\n                 RuntimeOption::ServerThreadDropCacheTimeoutSeconds,\n                 RuntimeOption::ServerThreadDropStack,\n                 this,\n                 RuntimeOption::ServerThreadJobLIFOSwitchThreshold,\n                 RuntimeOption::ServerThreadJobMaxQueuingMilliSeconds,\n                 RequestPriority::k_numPriorities) {\n  folly::SocketAddress sock_addr;\n  if (useFileSocket) {\n    sock_addr.setFromPath(address);\n  } else if (address.empty()) {\n    sock_addr.setFromLocalPort(port);\n  } else {\n    sock_addr.setFromHostPort(address, port);\n  }\n  m_socketConfig.bindAddress = sock_addr;\n  m_socketConfig.acceptBacklog = RuntimeOption::ServerBacklog;\n  std::chrono::seconds timeout;\n  if (RuntimeOption::ConnectionTimeoutSeconds >= 0) {\n    timeout = std::chrono::seconds(RuntimeOption::ConnectionTimeoutSeconds);\n  } else {\n    // default to 2 minutes\n    timeout = std::chrono::seconds(120);\n  }\n  m_socketConfig.connectionIdleTimeout = timeout;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144759,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "FastCGIServer::FastCGIServer(const std::string &address,\n                             int port,\n                             int workers,\n                             bool useFileSocket)\n  : Server(address, port),\n    m_worker(&m_eventBaseManager),\n    m_dispatcher(workers, workers,\n                 RuntimeOption::ServerThreadDropCacheTimeoutSeconds,\n                 RuntimeOption::ServerThreadDropStack,\n                 this,\n                 RuntimeOption::ServerThreadJobLIFOSwitchThreshold,\n                 RuntimeOption::ServerThreadJobMaxQueuingMilliSeconds,\n                 RequestPriority::k_numPriorities) {\n  folly::SocketAddress sock_addr;\n  if (useFileSocket) {\n    sock_addr.setFromPath(address);\n  } else if (address.empty()) {\n    sock_addr.setFromHostPort(\"localhost\", port);\n    assert(sock_addr.isLoopbackAddress());\n  } else {\n    sock_addr.setFromHostPort(address, port);\n  }\n  m_socketConfig.bindAddress = sock_addr;\n  m_socketConfig.acceptBacklog = RuntimeOption::ServerBacklog;\n  std::chrono::seconds timeout;\n  if (RuntimeOption::ConnectionTimeoutSeconds >= 0) {\n    timeout = std::chrono::seconds(RuntimeOption::ConnectionTimeoutSeconds);\n  } else {\n    // default to 2 minutes\n    timeout = std::chrono::seconds(120);\n  }\n  m_socketConfig.connectionIdleTimeout = timeout;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144760,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "  explicit HashContext(const HashContext* ctx) {\n    assert(ctx->ops);\n    assert(ctx->ops->context_size >= 0);\n    ops = ctx->ops;\n    context = malloc(ops->context_size);\n    ops->hash_copy(context, ctx->context);\n    options = ctx->options;\n    key = ctx->key ? strdup(ctx->key) : nullptr;\n  }",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144763,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "  explicit HashContext(const HashContext* ctx) {\n    assert(ctx->ops);\n    assert(ctx->ops->context_size >= 0);\n    ops = ctx->ops;\n    context = malloc(ops->context_size);\n    ops->hash_copy(context, ctx->context);\n    options = ctx->options;\n    if (ctx->key) {\n      key = static_cast<char*>(malloc(ops->block_size));\n      memcpy(key, ctx->key, ops->block_size);\n    } else {\n      key = nullptr;\n    }\n  }",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144764,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "bool IsBlacklistedArg(const base::CommandLine::CharType* arg) {\n#if defined(OS_WIN)\n  const auto converted = base::WideToUTF8(arg);\n  const char* a = converted.c_str();\n#else\n  const char* a = arg;\n#endif\n\n  static const char* prefixes[] = {\"--\", \"-\", \"/\"};\n\n  int prefix_length = 0;\n  for (auto& prefix : prefixes) {\n    if (base::StartsWith(a, prefix, base::CompareCase::SENSITIVE)) {\n      prefix_length = strlen(prefix);\n      break;\n    }\n  }\n\n  if (prefix_length > 0) {\n    a += prefix_length;\n    std::string switch_name(a, strcspn(a, \"=\"));\n    auto* iter = std::lower_bound(std::begin(kBlacklist), std::end(kBlacklist),\n                                  switch_name);\n    if (iter != std::end(kBlacklist) && switch_name == *iter) {\n      return true;\n    }\n  }\n\n  return false;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144789,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "bool IsBlacklistedArg(const base::CommandLine::CharType* arg) {\n#if defined(OS_WIN)\n  const auto converted = base::WideToUTF8(arg);\n  const char* a = converted.c_str();\n#else\n  const char* a = arg;\n#endif\n\n  static const char* prefixes[] = {\"--\", \"-\", \"/\"};\n\n  int prefix_length = 0;\n  for (auto& prefix : prefixes) {\n    if (base::StartsWith(a, prefix, base::CompareCase::SENSITIVE)) {\n      prefix_length = strlen(prefix);\n      break;\n    }\n  }\n\n  if (prefix_length > 0) {\n    a += prefix_length;\n    std::string switch_name =\n        base::ToLowerASCII(base::StringPiece(a, strcspn(a, \"=\")));\n    auto* iter = std::lower_bound(std::begin(kBlacklist), std::end(kBlacklist),\n                                  switch_name);\n    if (iter != std::end(kBlacklist) && switch_name == *iter) {\n      return true;\n    }\n  }\n\n  return false;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144790,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "int wc_SignatureGenerateHash(\n    enum wc_HashType hash_type, enum wc_SignatureType sig_type,\n    const byte* hash_data, word32 hash_len,\n    byte* sig, word32 *sig_len,\n    const void* key, word32 key_len, WC_RNG* rng)\n{\n    int ret;\n\n    /* Suppress possible unused arg if all signature types are disabled */\n    (void)rng;\n\n    /* Check arguments */\n    if (hash_data == NULL || hash_len <= 0 ||\n        sig == NULL || sig_len == NULL || *sig_len <= 0 ||\n        key == NULL || key_len <= 0) {\n        return BAD_FUNC_ARG;\n    }\n\n    /* Validate signature len (needs to be at least max) */\n    if ((int)*sig_len < wc_SignatureGetSize(sig_type, key, key_len)) {\n        WOLFSSL_MSG(\"wc_SignatureGenerate: Invalid sig type/len\");\n        return BAD_FUNC_ARG;\n    }\n\n    /* Validate hash size */\n    ret = wc_HashGetDigestSize(hash_type);\n    if (ret < 0) {\n        WOLFSSL_MSG(\"wc_SignatureGenerate: Invalid hash type/len\");\n        return ret;\n    }\n    ret = 0;\n\n    /* Create signature using hash as data */\n    switch (sig_type) {\n        case WC_SIGNATURE_TYPE_ECC:\n#if defined(HAVE_ECC) && defined(HAVE_ECC_SIGN)\n            /* Create signature using provided ECC key */\n            do {\n            #ifdef WOLFSSL_ASYNC_CRYPT\n                ret = wc_AsyncWait(ret, &((ecc_key*)key)->asyncDev,\n                    WC_ASYNC_FLAG_CALL_AGAIN);\n            #endif\n            if (ret >= 0)\n                ret = wc_ecc_sign_hash(hash_data, hash_len, sig, sig_len,\n                    rng, (ecc_key*)key);\n            } while (ret == WC_PENDING_E);\n#else\n            ret = SIG_TYPE_E;\n#endif\n            break;\n\n        case WC_SIGNATURE_TYPE_RSA_W_ENC:\n        case WC_SIGNATURE_TYPE_RSA:\n#if !defined(NO_RSA) && !defined(WOLFSSL_RSA_PUBLIC_ONLY)\n            /* Create signature using provided RSA key */\n            do {\n            #ifdef WOLFSSL_ASYNC_CRYPT\n                ret = wc_AsyncWait(ret, &((RsaKey*)key)->asyncDev,\n                    WC_ASYNC_FLAG_CALL_AGAIN);\n            #endif\n                if (ret >= 0)\n                    ret = wc_RsaSSL_Sign(hash_data, hash_len, sig, *sig_len,\n                        (RsaKey*)key, rng);\n            } while (ret == WC_PENDING_E);\n            if (ret >= 0) {\n                *sig_len = ret;\n                ret = 0; /* Success */\n            }\n#else\n            ret = SIG_TYPE_E;\n#endif\n            break;\n\n        case WC_SIGNATURE_TYPE_NONE:\n        default:\n            ret = BAD_FUNC_ARG;\n            break;\n    }\n\n    return ret;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144823,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "int wc_SignatureGenerateHash_ex(\n    enum wc_HashType hash_type, enum wc_SignatureType sig_type,\n    const byte* hash_data, word32 hash_len,\n    byte* sig, word32 *sig_len,\n    const void* key, word32 key_len, WC_RNG* rng, int verify)\n{\n    int ret;\n\n    /* Suppress possible unused arg if all signature types are disabled */\n    (void)rng;\n\n    /* Check arguments */\n    if (hash_data == NULL || hash_len <= 0 ||\n        sig == NULL || sig_len == NULL || *sig_len <= 0 ||\n        key == NULL || key_len <= 0) {\n        return BAD_FUNC_ARG;\n    }\n\n    /* Validate signature len (needs to be at least max) */\n    if ((int)*sig_len < wc_SignatureGetSize(sig_type, key, key_len)) {\n        WOLFSSL_MSG(\"wc_SignatureGenerate: Invalid sig type/len\");\n        return BAD_FUNC_ARG;\n    }\n\n    /* Validate hash size */\n    ret = wc_HashGetDigestSize(hash_type);\n    if (ret < 0) {\n        WOLFSSL_MSG(\"wc_SignatureGenerate: Invalid hash type/len\");\n        return ret;\n    }\n    ret = 0;\n\n    /* Create signature using hash as data */\n    switch (sig_type) {\n        case WC_SIGNATURE_TYPE_ECC:\n#if defined(HAVE_ECC) && defined(HAVE_ECC_SIGN)\n            /* Create signature using provided ECC key */\n            do {\n            #ifdef WOLFSSL_ASYNC_CRYPT\n                ret = wc_AsyncWait(ret, &((ecc_key*)key)->asyncDev,\n                    WC_ASYNC_FLAG_CALL_AGAIN);\n            #endif\n            if (ret >= 0)\n                ret = wc_ecc_sign_hash(hash_data, hash_len, sig, sig_len,\n                    rng, (ecc_key*)key);\n            } while (ret == WC_PENDING_E);\n#else\n            ret = SIG_TYPE_E;\n#endif\n            break;\n\n        case WC_SIGNATURE_TYPE_RSA_W_ENC:\n        case WC_SIGNATURE_TYPE_RSA:\n#if !defined(NO_RSA) && !defined(WOLFSSL_RSA_PUBLIC_ONLY)\n            /* Create signature using provided RSA key */\n            do {\n            #ifdef WOLFSSL_ASYNC_CRYPT\n                ret = wc_AsyncWait(ret, &((RsaKey*)key)->asyncDev,\n                    WC_ASYNC_FLAG_CALL_AGAIN);\n            #endif\n                if (ret >= 0)\n                    ret = wc_RsaSSL_Sign(hash_data, hash_len, sig, *sig_len,\n                        (RsaKey*)key, rng);\n            } while (ret == WC_PENDING_E);\n            if (ret >= 0) {\n                *sig_len = ret;\n                ret = 0; /* Success */\n            }\n#else\n            ret = SIG_TYPE_E;\n#endif\n            break;\n\n        case WC_SIGNATURE_TYPE_NONE:\n        default:\n            ret = BAD_FUNC_ARG;\n            break;\n    }\n\n    if (ret == 0 && verify) {\n        ret = wc_SignatureVerifyHash(hash_type, sig_type, hash_data, hash_len,\n            sig, *sig_len, key, key_len);\n    }\n\n    return ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144824,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "sixel_dither_new(\n    sixel_dither_t    /* out */ **ppdither, /* dither object to be created */\n    int               /* in */  ncolors,    /* required colors */\n    sixel_allocator_t /* in */  *allocator) /* allocator, null if you use\n                                               default allocator */\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n    size_t headsize;\n    size_t datasize;\n    size_t wholesize;\n    int quality_mode;\n\n    if (ppdither == NULL) {\n        sixel_helper_set_additional_message(\n            \"sixel_dither_new: ppdither is null.\");\n        status = SIXEL_BAD_ARGUMENT;\n        goto end;\n    }\n\n    if (allocator == NULL) {\n        status = sixel_allocator_new(&allocator, NULL, NULL, NULL, NULL);\n        if (SIXEL_FAILED(status)) {\n            *ppdither = NULL;\n            goto end;\n        }\n    } else {\n        sixel_allocator_ref(allocator);\n    }\n\n    if (ncolors < 0) {\n        ncolors = 256;\n        quality_mode = SIXEL_QUALITY_HIGHCOLOR;\n    } else {\n        if (ncolors > SIXEL_PALETTE_MAX) {\n            ncolors = 256;\n        } else if (ncolors < 2) {\n            ncolors = 2;\n        }\n        quality_mode = SIXEL_QUALITY_LOW;\n    }\n    headsize = sizeof(sixel_dither_t);\n    datasize = (size_t)(ncolors * 3);\n    wholesize = headsize + datasize;\n\n    *ppdither = (sixel_dither_t *)sixel_allocator_malloc(allocator, wholesize);\n    if (*ppdither == NULL) {\n        sixel_allocator_unref(allocator);\n        sixel_helper_set_additional_message(\n            \"sixel_dither_new: sixel_allocator_malloc() failed.\");\n        status = SIXEL_BAD_ALLOCATION;\n        goto end;\n    }\n\n    (*ppdither)->ref = 1;\n    (*ppdither)->palette = (unsigned char*)(*ppdither + 1);\n    (*ppdither)->cachetable = NULL;\n    (*ppdither)->reqcolors = ncolors;\n    (*ppdither)->ncolors = ncolors;\n    (*ppdither)->origcolors = (-1);\n    (*ppdither)->keycolor = (-1);\n    (*ppdither)->optimized = 0;\n    (*ppdither)->optimize_palette = 0;\n    (*ppdither)->complexion = 1;\n    (*ppdither)->bodyonly = 0;\n    (*ppdither)->method_for_largest = SIXEL_LARGE_NORM;\n    (*ppdither)->method_for_rep = SIXEL_REP_CENTER_BOX;\n    (*ppdither)->method_for_diffuse = SIXEL_DIFFUSE_FS;\n    (*ppdither)->quality_mode = quality_mode;\n    (*ppdither)->pixelformat = SIXEL_PIXELFORMAT_RGB888;\n    (*ppdither)->allocator = allocator;\n\n    status = SIXEL_OK;\n\nend:\n    return status;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145058,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "sixel_dither_new(\n    sixel_dither_t    /* out */ **ppdither, /* dither object to be created */\n    int               /* in */  ncolors,    /* required colors */\n    sixel_allocator_t /* in */  *allocator) /* allocator, null if you use\n                                               default allocator */\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n    size_t headsize;\n    size_t datasize;\n    size_t wholesize;\n    int quality_mode;\n\n    if (ppdither == NULL) {\n        sixel_helper_set_additional_message(\n            \"sixel_dither_new: ppdither is null.\");\n        status = SIXEL_BAD_ARGUMENT;\n        goto end;\n    }\n\n    if (allocator == NULL) {\n        status = sixel_allocator_new(&allocator, NULL, NULL, NULL, NULL);\n        if (SIXEL_FAILED(status)) {\n            *ppdither = NULL;\n            goto end;\n        }\n    } else {\n        sixel_allocator_ref(allocator);\n    }\n\n    if (ncolors < 0) {\n        ncolors = 256;\n        quality_mode = SIXEL_QUALITY_HIGHCOLOR;\n    } else {\n        if (ncolors > SIXEL_PALETTE_MAX) {\n            status = SIXEL_BAD_INPUT;\n            ncolors = 256;\n        } else if (ncolors < 1) {\n            status = SIXEL_BAD_INPUT;\n            sixel_helper_set_additional_message(\n                \"sixel_dither_new: palette colors must be more than 0\");\n            goto end;\n        }\n        quality_mode = SIXEL_QUALITY_LOW;\n    }\n    headsize = sizeof(sixel_dither_t);\n    datasize = (size_t)(ncolors * 3);\n    wholesize = headsize + datasize;\n\n    *ppdither = (sixel_dither_t *)sixel_allocator_malloc(allocator, wholesize);\n    if (*ppdither == NULL) {\n        sixel_allocator_unref(allocator);\n        sixel_helper_set_additional_message(\n            \"sixel_dither_new: sixel_allocator_malloc() failed.\");\n        status = SIXEL_BAD_ALLOCATION;\n        goto end;\n    }\n\n    (*ppdither)->ref = 1;\n    (*ppdither)->palette = (unsigned char*)(*ppdither + 1);\n    (*ppdither)->cachetable = NULL;\n    (*ppdither)->reqcolors = ncolors;\n    (*ppdither)->ncolors = ncolors;\n    (*ppdither)->origcolors = (-1);\n    (*ppdither)->keycolor = (-1);\n    (*ppdither)->optimized = 0;\n    (*ppdither)->optimize_palette = 0;\n    (*ppdither)->complexion = 1;\n    (*ppdither)->bodyonly = 0;\n    (*ppdither)->method_for_largest = SIXEL_LARGE_NORM;\n    (*ppdither)->method_for_rep = SIXEL_REP_CENTER_BOX;\n    (*ppdither)->method_for_diffuse = SIXEL_DIFFUSE_FS;\n    (*ppdither)->quality_mode = quality_mode;\n    (*ppdither)->pixelformat = SIXEL_PIXELFORMAT_RGB888;\n    (*ppdither)->allocator = allocator;\n\n    status = SIXEL_OK;\n\nend:\n    return status;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145059,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "bool ContentSettingsObserver::AllowScript(bool enabled_per_settings) {\n  if (!enabled_per_settings)\n    return false;\n  if (IsScriptDisabledForPreview(render_frame()))\n    return false;\n  if (is_interstitial_page_)\n    return true;\n\n  blink::WebLocalFrame* frame = render_frame()->GetWebFrame();\n  const auto it = cached_script_permissions_.find(frame);\n  if (it != cached_script_permissions_.end())\n    return it->second;\n\n  // Evaluate the content setting rules before\n  // IsWhitelistedForContentSettings(); if there is only the default rule\n  // allowing all scripts, it's quicker this way.\n  bool allow = true;\n  if (content_setting_rules_) {\n    ContentSetting setting = GetContentSettingFromRules(\n        content_setting_rules_->script_rules, frame,\n        url::Origin(frame->GetDocument().GetSecurityOrigin()).GetURL());\n    allow = setting != CONTENT_SETTING_BLOCK;\n  }\n  allow = allow || IsWhitelistedForContentSettings();\n\n  cached_script_permissions_[frame] = allow;\n  return allow;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145068,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "bool ContentSettingsObserver::AllowScript(bool enabled_per_settings) {\n  if (!enabled_per_settings)\n    return false;\n  if (IsScriptDisabledForPreview(render_frame()))\n    return false;\n  if (is_interstitial_page_)\n    return true;\n\n  blink::WebLocalFrame* frame = render_frame()->GetWebFrame();\n  const auto it = cached_script_permissions_.find(frame);\n  if (it != cached_script_permissions_.end())\n    return it->second;\n\n  // Evaluate the content setting rules before\n  // IsWhitelistedForContentSettings(); if there is only the default rule\n  // allowing all scripts, it's quicker this way.\n  bool allow = true;\n  if (content_settings_manager_->content_settings()) {\n    allow =\n        content_settings_manager_->GetSetting(\n          ContentSettingsManager::GetOriginOrURL(render_frame()->GetWebFrame()),\n          url::Origin(frame->GetDocument().GetSecurityOrigin()).GetURL(),\n          \"javascript\",\n          allow) != CONTENT_SETTING_BLOCK;\n  }\n  allow = allow || IsWhitelistedForContentSettings();\n\n  cached_script_permissions_[frame] = allow;\n  return allow;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145069,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "int linenoiseHistorySave(const char* filename) {\n    FILE* fp = fopen(filename, \"wt\");\n    if (fp == NULL) {\n        return -1;\n    }\n\n    for (int j = 0; j < historyLen; ++j) {\n        if (history[j][0] != '\\0') {\n            fprintf(fp, \"%s\\n\", history[j]);\n        }\n    }\n    fclose(fp);\n    return 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145128,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "int linenoiseHistorySave(const char* filename) {\n    FILE* fp;\n#if _POSIX_C_SOURCE >= 1 || _XOPEN_SOURCE || _POSIX_SOURCE\n    int fd = open(filename, O_CREAT, S_IRUSR | S_IWUSR);\n    if (fd == -1) {\n        // report errno somehow?\n        return -1;\n    }\n    fp = fdopen(fd, \"wt\");\n#else\n    fp = fopen(filename, \"wt\");\n#endif  // _POSIX_C_SOURCE >= 1 || _XOPEN_SOURCE || _POSIX_SOURCE\n    if (fp == NULL) {\n        return -1;\n    }\n\n    for (int j = 0; j < historyLen; ++j) {\n        if (history[j][0] != '\\0') {\n            fprintf(fp, \"%s\\n\", history[j]);\n        }\n    }\n    fclose(fp);  // Also causes fd to be closed.\n    return 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145129,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "void ourWriteOut(CURL *curl, struct OutStruct *outs, const char *writeinfo)\n{\n  FILE *stream = stdout;\n  const char *ptr = writeinfo;\n  char *stringp = NULL;\n  long longinfo;\n  double doubleinfo;\n\n  while(ptr && *ptr) {\n    if('%' == *ptr) {\n      if('%' == ptr[1]) {\n        /* an escaped %-letter */\n        fputc('%', stream);\n        ptr += 2;\n      }\n      else {\n        /* this is meant as a variable to output */\n        char *end;\n        char keepit;\n        int i;\n        if('{' == ptr[1]) {\n          bool match = FALSE;\n          end = strchr(ptr, '}');\n          ptr += 2; /* pass the % and the { */\n          if(!end) {\n            fputs(\"%{\", stream);\n            continue;\n          }\n          keepit = *end;\n          *end = 0; /* zero terminate */\n          for(i = 0; replacements[i].name; i++) {\n            if(curl_strequal(ptr, replacements[i].name)) {\n              match = TRUE;\n              switch(replacements[i].id) {\n              case VAR_EFFECTIVE_URL:\n                if((CURLE_OK ==\n                    curl_easy_getinfo(curl, CURLINFO_EFFECTIVE_URL, &stringp))\n                   && stringp)\n                  fputs(stringp, stream);\n                break;\n              case VAR_HTTP_CODE:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &longinfo))\n                  fprintf(stream, \"%03ld\", longinfo);\n                break;\n              case VAR_HTTP_CODE_PROXY:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_HTTP_CONNECTCODE,\n                                     &longinfo))\n                  fprintf(stream, \"%03ld\", longinfo);\n                break;\n              case VAR_HEADER_SIZE:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_HEADER_SIZE, &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_REQUEST_SIZE:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_REQUEST_SIZE, &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_NUM_CONNECTS:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_NUM_CONNECTS, &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_REDIRECT_COUNT:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_REDIRECT_COUNT, &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_REDIRECT_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_REDIRECT_TIME,\n                                     &doubleinfo))\n                  fprintf(stream, \"%.6f\", doubleinfo);\n                break;\n              case VAR_TOTAL_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_TOTAL_TIME, &doubleinfo))\n                  fprintf(stream, \"%.6f\", doubleinfo);\n                break;\n              case VAR_NAMELOOKUP_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_NAMELOOKUP_TIME,\n                                     &doubleinfo))\n                  fprintf(stream, \"%.6f\", doubleinfo);\n                break;\n              case VAR_CONNECT_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_CONNECT_TIME, &doubleinfo))\n                  fprintf(stream, \"%.6f\", doubleinfo);\n                break;\n              case VAR_APPCONNECT_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_APPCONNECT_TIME,\n                                     &doubleinfo))\n                  fprintf(stream, \"%.6f\", doubleinfo);\n                break;\n              case VAR_PRETRANSFER_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_PRETRANSFER_TIME,\n                                     &doubleinfo))\n                  fprintf(stream, \"%.6f\", doubleinfo);\n                break;\n              case VAR_STARTTRANSFER_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_STARTTRANSFER_TIME,\n                                     &doubleinfo))\n                  fprintf(stream, \"%.6f\", doubleinfo);\n                break;\n              case VAR_SIZE_UPLOAD:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_SIZE_UPLOAD, &doubleinfo))\n                  fprintf(stream, \"%.0f\", doubleinfo);\n                break;\n              case VAR_SIZE_DOWNLOAD:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_SIZE_DOWNLOAD,\n                                     &doubleinfo))\n                  fprintf(stream, \"%.0f\", doubleinfo);\n                break;\n              case VAR_SPEED_DOWNLOAD:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_SPEED_DOWNLOAD,\n                                     &doubleinfo))\n                  fprintf(stream, \"%.3f\", doubleinfo);\n                break;\n              case VAR_SPEED_UPLOAD:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_SPEED_UPLOAD, &doubleinfo))\n                  fprintf(stream, \"%.3f\", doubleinfo);\n                break;\n              case VAR_CONTENT_TYPE:\n                if((CURLE_OK ==\n                    curl_easy_getinfo(curl, CURLINFO_CONTENT_TYPE, &stringp))\n                   && stringp)\n                  fputs(stringp, stream);\n                break;\n              case VAR_FTP_ENTRY_PATH:\n                if((CURLE_OK ==\n                    curl_easy_getinfo(curl, CURLINFO_FTP_ENTRY_PATH, &stringp))\n                   && stringp)\n                  fputs(stringp, stream);\n                break;\n              case VAR_REDIRECT_URL:\n                if((CURLE_OK ==\n                    curl_easy_getinfo(curl, CURLINFO_REDIRECT_URL, &stringp))\n                   && stringp)\n                  fputs(stringp, stream);\n                break;\n              case VAR_SSL_VERIFY_RESULT:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_SSL_VERIFYRESULT,\n                                     &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_PROXY_SSL_VERIFY_RESULT:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_PROXY_SSL_VERIFYRESULT,\n                                     &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_EFFECTIVE_FILENAME:\n                if(outs->filename)\n                  fprintf(stream, \"%s\", outs->filename);\n                break;\n              case VAR_PRIMARY_IP:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_PRIMARY_IP,\n                                     &stringp))\n                  fprintf(stream, \"%s\", stringp);\n                break;\n              case VAR_PRIMARY_PORT:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_PRIMARY_PORT,\n                                     &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_LOCAL_IP:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_LOCAL_IP,\n                                     &stringp))\n                  fprintf(stream, \"%s\", stringp);\n                break;\n              case VAR_LOCAL_PORT:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_LOCAL_PORT,\n                                     &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_HTTP_VERSION:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_HTTP_VERSION,\n                                     &longinfo)) {\n                  const char *version = \"0\";\n                  switch(longinfo) {\n                  case CURL_HTTP_VERSION_1_0:\n                    version = \"1.0\";\n                    break;\n                  case CURL_HTTP_VERSION_1_1:\n                    version = \"1.1\";\n                    break;\n                  case CURL_HTTP_VERSION_2_0:\n                    version = \"2\";\n                    break;\n                  }\n\n                  fprintf(stream, version);\n                }\n                break;\n              case VAR_SCHEME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_SCHEME,\n                                     &stringp))\n                  fprintf(stream, \"%s\", stringp);\n                break;\n              default:\n                break;\n              }\n              break;\n            }\n          }\n          if(!match) {\n            fprintf(stderr, \"curl: unknown --write-out variable: '%s'\\n\", ptr);\n          }\n          ptr = end + 1; /* pass the end */\n          *end = keepit;\n        }\n        else {\n          /* illegal syntax, then just output the characters that are used */\n          fputc('%', stream);\n          fputc(ptr[1], stream);\n          ptr += 2;\n        }\n      }\n    }\n    else if('\\\\' == *ptr) {\n      switch(ptr[1]) {\n      case 'r':\n        fputc('\\r', stream);\n        break;\n      case 'n':\n        fputc('\\n', stream);\n        break;\n      case 't':\n        fputc('\\t', stream);\n        break;\n      default:\n        /* unknown, just output this */\n        fputc(*ptr, stream);\n        fputc(ptr[1], stream);\n        break;\n      }\n      ptr += 2;\n    }\n    else {\n      fputc(*ptr, stream);\n      ptr++;\n    }\n  }\n\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145136,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "void ourWriteOut(CURL *curl, struct OutStruct *outs, const char *writeinfo)\n{\n  FILE *stream = stdout;\n  const char *ptr = writeinfo;\n  char *stringp = NULL;\n  long longinfo;\n  double doubleinfo;\n\n  while(ptr && *ptr) {\n    if('%' == *ptr && ptr[1]) {\n      if('%' == ptr[1]) {\n        /* an escaped %-letter */\n        fputc('%', stream);\n        ptr += 2;\n      }\n      else {\n        /* this is meant as a variable to output */\n        char *end;\n        char keepit;\n        int i;\n        if('{' == ptr[1]) {\n          bool match = FALSE;\n          end = strchr(ptr, '}');\n          ptr += 2; /* pass the % and the { */\n          if(!end) {\n            fputs(\"%{\", stream);\n            continue;\n          }\n          keepit = *end;\n          *end = 0; /* zero terminate */\n          for(i = 0; replacements[i].name; i++) {\n            if(curl_strequal(ptr, replacements[i].name)) {\n              match = TRUE;\n              switch(replacements[i].id) {\n              case VAR_EFFECTIVE_URL:\n                if((CURLE_OK ==\n                    curl_easy_getinfo(curl, CURLINFO_EFFECTIVE_URL, &stringp))\n                   && stringp)\n                  fputs(stringp, stream);\n                break;\n              case VAR_HTTP_CODE:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &longinfo))\n                  fprintf(stream, \"%03ld\", longinfo);\n                break;\n              case VAR_HTTP_CODE_PROXY:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_HTTP_CONNECTCODE,\n                                     &longinfo))\n                  fprintf(stream, \"%03ld\", longinfo);\n                break;\n              case VAR_HEADER_SIZE:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_HEADER_SIZE, &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_REQUEST_SIZE:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_REQUEST_SIZE, &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_NUM_CONNECTS:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_NUM_CONNECTS, &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_REDIRECT_COUNT:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_REDIRECT_COUNT, &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_REDIRECT_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_REDIRECT_TIME,\n                                     &doubleinfo))\n                  fprintf(stream, \"%.6f\", doubleinfo);\n                break;\n              case VAR_TOTAL_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_TOTAL_TIME, &doubleinfo))\n                  fprintf(stream, \"%.6f\", doubleinfo);\n                break;\n              case VAR_NAMELOOKUP_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_NAMELOOKUP_TIME,\n                                     &doubleinfo))\n                  fprintf(stream, \"%.6f\", doubleinfo);\n                break;\n              case VAR_CONNECT_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_CONNECT_TIME, &doubleinfo))\n                  fprintf(stream, \"%.6f\", doubleinfo);\n                break;\n              case VAR_APPCONNECT_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_APPCONNECT_TIME,\n                                     &doubleinfo))\n                  fprintf(stream, \"%.6f\", doubleinfo);\n                break;\n              case VAR_PRETRANSFER_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_PRETRANSFER_TIME,\n                                     &doubleinfo))\n                  fprintf(stream, \"%.6f\", doubleinfo);\n                break;\n              case VAR_STARTTRANSFER_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_STARTTRANSFER_TIME,\n                                     &doubleinfo))\n                  fprintf(stream, \"%.6f\", doubleinfo);\n                break;\n              case VAR_SIZE_UPLOAD:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_SIZE_UPLOAD, &doubleinfo))\n                  fprintf(stream, \"%.0f\", doubleinfo);\n                break;\n              case VAR_SIZE_DOWNLOAD:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_SIZE_DOWNLOAD,\n                                     &doubleinfo))\n                  fprintf(stream, \"%.0f\", doubleinfo);\n                break;\n              case VAR_SPEED_DOWNLOAD:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_SPEED_DOWNLOAD,\n                                     &doubleinfo))\n                  fprintf(stream, \"%.3f\", doubleinfo);\n                break;\n              case VAR_SPEED_UPLOAD:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_SPEED_UPLOAD, &doubleinfo))\n                  fprintf(stream, \"%.3f\", doubleinfo);\n                break;\n              case VAR_CONTENT_TYPE:\n                if((CURLE_OK ==\n                    curl_easy_getinfo(curl, CURLINFO_CONTENT_TYPE, &stringp))\n                   && stringp)\n                  fputs(stringp, stream);\n                break;\n              case VAR_FTP_ENTRY_PATH:\n                if((CURLE_OK ==\n                    curl_easy_getinfo(curl, CURLINFO_FTP_ENTRY_PATH, &stringp))\n                   && stringp)\n                  fputs(stringp, stream);\n                break;\n              case VAR_REDIRECT_URL:\n                if((CURLE_OK ==\n                    curl_easy_getinfo(curl, CURLINFO_REDIRECT_URL, &stringp))\n                   && stringp)\n                  fputs(stringp, stream);\n                break;\n              case VAR_SSL_VERIFY_RESULT:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_SSL_VERIFYRESULT,\n                                     &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_PROXY_SSL_VERIFY_RESULT:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_PROXY_SSL_VERIFYRESULT,\n                                     &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_EFFECTIVE_FILENAME:\n                if(outs->filename)\n                  fprintf(stream, \"%s\", outs->filename);\n                break;\n              case VAR_PRIMARY_IP:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_PRIMARY_IP,\n                                     &stringp))\n                  fprintf(stream, \"%s\", stringp);\n                break;\n              case VAR_PRIMARY_PORT:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_PRIMARY_PORT,\n                                     &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_LOCAL_IP:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_LOCAL_IP,\n                                     &stringp))\n                  fprintf(stream, \"%s\", stringp);\n                break;\n              case VAR_LOCAL_PORT:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_LOCAL_PORT,\n                                     &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_HTTP_VERSION:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_HTTP_VERSION,\n                                     &longinfo)) {\n                  const char *version = \"0\";\n                  switch(longinfo) {\n                  case CURL_HTTP_VERSION_1_0:\n                    version = \"1.0\";\n                    break;\n                  case CURL_HTTP_VERSION_1_1:\n                    version = \"1.1\";\n                    break;\n                  case CURL_HTTP_VERSION_2_0:\n                    version = \"2\";\n                    break;\n                  }\n\n                  fprintf(stream, version);\n                }\n                break;\n              case VAR_SCHEME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_SCHEME,\n                                     &stringp))\n                  fprintf(stream, \"%s\", stringp);\n                break;\n              default:\n                break;\n              }\n              break;\n            }\n          }\n          if(!match) {\n            fprintf(stderr, \"curl: unknown --write-out variable: '%s'\\n\", ptr);\n          }\n          ptr = end + 1; /* pass the end */\n          *end = keepit;\n        }\n        else {\n          /* illegal syntax, then just output the characters that are used */\n          fputc('%', stream);\n          fputc(ptr[1], stream);\n          ptr += 2;\n        }\n      }\n    }\n    else if('\\\\' == *ptr) {\n      switch(ptr[1]) {\n      case 'r':\n        fputc('\\r', stream);\n        break;\n      case 'n':\n        fputc('\\n', stream);\n        break;\n      case 't':\n        fputc('\\t', stream);\n        break;\n      default:\n        /* unknown, just output this */\n        fputc(*ptr, stream);\n        fputc(ptr[1], stream);\n        break;\n      }\n      ptr += 2;\n    }\n    else {\n      fputc(*ptr, stream);\n      ptr++;\n    }\n  }\n\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145137,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "bool OpenConnectionTask::handleStateHelper(const Imap::Responses::State *const resp)\n{\n    if (_dead) {\n        _failed(\"Asked to die\");\n        return true;\n    }\n    using namespace Imap::Responses;\n\n    if (model->accessParser(parser).connState == CONN_STATE_CONNECTED_PRETLS_PRECAPS) {\n        if (!resp->tag.isEmpty()) {\n            throw Imap::UnexpectedResponseReceived(\"Waiting for initial OK/BYE/PREAUTH, but got tagged response instead\", *resp);\n        }\n    } else if (model->accessParser(parser).connState > CONN_STATE_CONNECTED_PRETLS_PRECAPS) {\n        if (resp->tag.isEmpty()) {\n            return false;\n        }\n    }\n\n    switch (model->accessParser(parser).connState) {\n\n    case CONN_STATE_AUTHENTICATED:\n    case CONN_STATE_SELECTING:\n    case CONN_STATE_SYNCING:\n    case CONN_STATE_SELECTED:\n    case CONN_STATE_FETCHING_PART:\n    case CONN_STATE_FETCHING_MSG_METADATA:\n    case CONN_STATE_LOGOUT:\n    {\n        QByteArray message = \"No response expected by the OpenConnectionTask in state \" +\n                Imap::connectionStateToString(model->accessParser(parser).connState).toUtf8();\n        // These shall not ever be reached by this code\n        throw Imap::UnexpectedResponseReceived(message.constData(), *resp);\n    }\n\n    case CONN_STATE_NONE:\n    case CONN_STATE_HOST_LOOKUP:\n    case CONN_STATE_CONNECTING:\n        // Looks like the corresponding stateChanged() signal could be delayed, at least with QProcess-based sockets\n    case CONN_STATE_CONNECTED_PRETLS_PRECAPS:\n        // We're connected now -- this is our initial state.\n    {\n        switch (resp->kind) {\n        case PREAUTH:\n            // Cool, we're already authenticated. Now, let's see if we have to issue CAPABILITY or if we already know that\n            if (model->accessParser(parser).capabilitiesFresh) {\n                // We're alsmost done here, apart from compression\n                if (TROJITA_COMPRESS_DEFLATE && model->accessParser(parser).capabilities.contains(QLatin1String(\"COMPRESS=DEFLATE\"))) {\n                    compressCmd = parser->compressDeflate();\n                    model->changeConnectionState(parser, CONN_STATE_COMPRESS_DEFLATE);\n                } else {\n                    // really done\n                    model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n                    onComplete();\n                }\n            } else {\n                model->changeConnectionState(parser, CONN_STATE_POSTAUTH_PRECAPS);\n                capabilityCmd = parser->capability();\n            }\n            return true;\n\n        case OK:\n            if (!model->accessParser(parser).capabilitiesFresh) {\n                model->changeConnectionState(parser, CONN_STATE_CONNECTED_PRETLS);\n                capabilityCmd = parser->capability();\n            } else {\n                startTlsOrLoginNow();\n            }\n            return true;\n\n        case BYE:\n            logout(tr(\"Server has closed the connection\"));\n            return true;\n\n        case BAD:\n            model->changeConnectionState(parser, CONN_STATE_LOGOUT);\n            // If it was an ALERT, we've already warned the user\n            if (resp->respCode != ALERT) {\n                emit model->alertReceived(tr(\"The server replied with the following BAD response:\\n%1\").arg(resp->message));\n            }\n            logout(tr(\"Server has greeted us with a BAD response\"));\n            return true;\n\n        default:\n            throw Imap::UnexpectedResponseReceived(\"Waiting for initial OK/BYE/BAD/PREAUTH, but got this instead\", *resp);\n        }\n        break;\n    }\n\n    case CONN_STATE_CONNECTED_PRETLS:\n        // We've asked for capabilities upon the initial interaction\n    {\n        bool wasCaps = checkCapabilitiesResult(resp);\n        if (wasCaps && !_finished) {\n            startTlsOrLoginNow();\n        }\n        return wasCaps;\n    }\n\n    case CONN_STATE_STARTTLS_ISSUED:\n    {\n        if (resp->tag == startTlsCmd) {\n            if (resp->kind == OK) {\n                model->changeConnectionState(parser, CONN_STATE_STARTTLS_HANDSHAKE);\n                if (!model->m_startTls) {\n                    // The model was not configured to perform STARTTLS, but we still did that for some reason.\n                    // As suggested by Mike Cardwell on the trojita ML (http://article.gmane.org/gmane.mail.trojita.general/299),\n                    // it makes sense to make this settings permanent, so that a user is not tricked into revealing their\n                    // password when a MITM removes the LOGINDISABLED in future.\n                    EMIT_LATER_NOARG(model, requireStartTlsInFuture);\n                }\n            } else {\n                logout(tr(\"STARTTLS failed: %1\").arg(resp->message));\n            }\n            return true;\n        }\n        return false;\n    }\n\n    case CONN_STATE_SSL_HANDSHAKE:\n    case CONN_STATE_STARTTLS_HANDSHAKE:\n        // nothing should really arrive at this point; the Parser is expected to wait for encryption and only after that\n        // send the data\n        Q_ASSERT(false);\n        return false;\n\n    case CONN_STATE_STARTTLS_VERIFYING:\n    case CONN_STATE_SSL_VERIFYING:\n    {\n        // We're waiting for a decision based on a policy, so we do not really expect any network IO at this point\n        // FIXME: an assert(false) here?\n        qDebug() << \"OpenConnectionTask: ignoring response, we're still waiting for SSL policy decision\";\n        return false;\n    }\n\n    case CONN_STATE_ESTABLISHED_PRECAPS:\n        // Connection is established and we're waiting for updated capabilities\n    {\n        bool wasCaps = checkCapabilitiesResult(resp);\n        if (wasCaps && !_finished) {\n            if (model->accessParser(parser).capabilities.contains(QLatin1String(\"LOGINDISABLED\"))) {\n                logout(tr(\"Capabilities still contain LOGINDISABLED even after STARTTLS\"));\n            } else {\n                model->changeConnectionState(parser, CONN_STATE_LOGIN);\n                askForAuth();\n            }\n        }\n        return wasCaps;\n    }\n\n    case CONN_STATE_LOGIN:\n        // Check the result of the LOGIN command\n    {\n        if (resp->tag == loginCmd) {\n            loginCmd.clear();\n            // The LOGIN command is finished\n            if (resp->kind == OK) {\n                if (resp->respCode == CAPABILITIES || model->accessParser(parser).capabilitiesFresh) {\n                    // Capabilities are already known\n                    if (TROJITA_COMPRESS_DEFLATE && model->accessParser(parser).capabilities.contains(QLatin1String(\"COMPRESS=DEFLATE\"))) {\n                        compressCmd = parser->compressDeflate();\n                        model->changeConnectionState(parser, CONN_STATE_COMPRESS_DEFLATE);\n                    } else {\n                        model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n                        onComplete();\n                    }\n                } else {\n                    // Got to ask for the capabilities\n                    model->changeConnectionState(parser, CONN_STATE_POSTAUTH_PRECAPS);\n                    capabilityCmd = parser->capability();\n                }\n            } else {\n                // Login failed\n                QString message;\n                switch (resp->respCode) {\n                case Responses::UNAVAILABLE:\n                    message = tr(\"Temporary failure because a subsystem is down.\");\n                    break;\n                case Responses::AUTHENTICATIONFAILED:\n                    message = tr(\"Authentication failed.  This often happens due to bad password or wrong user name.\");\n                    break;\n                case Responses::AUTHORIZATIONFAILED:\n                    message = tr(\"Authentication succeeded in using the authentication identity, \"\n                                 \"but the server cannot or will not allow the authentication \"\n                                 \"identity to act as the requested authorization identity.\");\n                    break;\n                case Responses::EXPIRED:\n                    message = tr(\"Either authentication succeeded or the server no longer had the \"\n                                 \"necessary data; either way, access is no longer permitted using \"\n                                 \"that passphrase.  You should get a new passphrase.\");\n                    break;\n                case Responses::PRIVACYREQUIRED:\n                    message = tr(\"The operation is not permitted due to a lack of privacy.\");\n                    break;\n                case Responses::CONTACTADMIN:\n                    message = tr(\"You should contact the system administrator or support desk.\");\n                    break;\n                default:\n                    break;\n                }\n\n                if (message.isEmpty()) {\n                    message = tr(\"Login failed: %1\").arg(resp->message);\n                } else {\n                    message = tr(\"%1\\n\\n%2\").arg(message, resp->message);\n                }\n                EMIT_LATER(model, authAttemptFailed, Q_ARG(QString, message));\n                model->m_imapPassword.clear();\n                model->m_hasImapPassword = false;\n                if (model->accessParser(parser).connState == CONN_STATE_LOGOUT) {\n                    // The server has closed the conenction\n                    _failed(QLatin1String(\"Connection closed after a failed login\"));\n                    return true;\n                }\n                askForAuth();\n            }\n            return true;\n        }\n        return false;\n    }\n\n    case CONN_STATE_POSTAUTH_PRECAPS:\n    {\n        bool wasCaps = checkCapabilitiesResult(resp);\n        if (wasCaps && !_finished) {\n            model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n            onComplete();\n        }\n        return wasCaps;\n    }\n\n    case CONN_STATE_COMPRESS_DEFLATE:\n        if (resp->tag == compressCmd) {\n            model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n            onComplete();\n            return true;\n        } else {\n            return false;\n        }\n        break;\n\n    }\n\n    // Required catch-all for OpenSuSE's build service (Tumbleweed, 2012-04-03)\n    Q_ASSERT(false);\n    return false;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145176,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "bool OpenConnectionTask::handleStateHelper(const Imap::Responses::State *const resp)\n{\n    if (_dead) {\n        _failed(\"Asked to die\");\n        return true;\n    }\n    using namespace Imap::Responses;\n\n    if (model->accessParser(parser).connState == CONN_STATE_CONNECTED_PRETLS_PRECAPS) {\n        if (!resp->tag.isEmpty()) {\n            throw Imap::UnexpectedResponseReceived(\"Waiting for initial OK/BYE/PREAUTH, but got tagged response instead\", *resp);\n        }\n    } else if (model->accessParser(parser).connState > CONN_STATE_CONNECTED_PRETLS_PRECAPS) {\n        if (resp->tag.isEmpty()) {\n            return false;\n        }\n    }\n\n    switch (model->accessParser(parser).connState) {\n\n    case CONN_STATE_AUTHENTICATED:\n    case CONN_STATE_SELECTING:\n    case CONN_STATE_SYNCING:\n    case CONN_STATE_SELECTED:\n    case CONN_STATE_FETCHING_PART:\n    case CONN_STATE_FETCHING_MSG_METADATA:\n    case CONN_STATE_LOGOUT:\n    {\n        QByteArray message = \"No response expected by the OpenConnectionTask in state \" +\n                Imap::connectionStateToString(model->accessParser(parser).connState).toUtf8();\n        // These shall not ever be reached by this code\n        throw Imap::UnexpectedResponseReceived(message.constData(), *resp);\n    }\n\n    case CONN_STATE_NONE:\n    case CONN_STATE_HOST_LOOKUP:\n    case CONN_STATE_CONNECTING:\n        // Looks like the corresponding stateChanged() signal could be delayed, at least with QProcess-based sockets\n    case CONN_STATE_CONNECTED_PRETLS_PRECAPS:\n        // We're connected now -- this is our initial state.\n    {\n        switch (resp->kind) {\n        case PREAUTH:\n            if (model->m_startTls) {\n                // Oops, we cannot send STARTTLS when the connection is already authenticated.\n                // This is serious enough to warrant an error; an attacker might be going after a plaintext\n                // of a message we're going to APPEND, etc.\n                // Thanks to Arnt Gulbrandsen on the imap-protocol ML for asking what happens when we're configured\n                // to request STARTTLS and a PREAUTH is received, and to Michael M Slusarz for starting that discussion.\n                logout(tr(\"Configuration requires sending STARTTLS, but the IMAP server greets us with PREAUTH. \"\n                          \"Encryption cannot be established. If this configuration worked previously, someone \"\n                          \"is after your data and they are pretty smart.\"));\n                return true;\n            }\n            // Cool, we're already authenticated. Now, let's see if we have to issue CAPABILITY or if we already know that\n            if (model->accessParser(parser).capabilitiesFresh) {\n                // We're alsmost done here, apart from compression\n                if (TROJITA_COMPRESS_DEFLATE && model->accessParser(parser).capabilities.contains(QLatin1String(\"COMPRESS=DEFLATE\"))) {\n                    compressCmd = parser->compressDeflate();\n                    model->changeConnectionState(parser, CONN_STATE_COMPRESS_DEFLATE);\n                } else {\n                    // really done\n                    model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n                    onComplete();\n                }\n            } else {\n                model->changeConnectionState(parser, CONN_STATE_POSTAUTH_PRECAPS);\n                capabilityCmd = parser->capability();\n            }\n            return true;\n\n        case OK:\n            if (!model->accessParser(parser).capabilitiesFresh) {\n                model->changeConnectionState(parser, CONN_STATE_CONNECTED_PRETLS);\n                capabilityCmd = parser->capability();\n            } else {\n                startTlsOrLoginNow();\n            }\n            return true;\n\n        case BYE:\n            logout(tr(\"Server has closed the connection\"));\n            return true;\n\n        case BAD:\n            model->changeConnectionState(parser, CONN_STATE_LOGOUT);\n            // If it was an ALERT, we've already warned the user\n            if (resp->respCode != ALERT) {\n                emit model->alertReceived(tr(\"The server replied with the following BAD response:\\n%1\").arg(resp->message));\n            }\n            logout(tr(\"Server has greeted us with a BAD response\"));\n            return true;\n\n        default:\n            throw Imap::UnexpectedResponseReceived(\"Waiting for initial OK/BYE/BAD/PREAUTH, but got this instead\", *resp);\n        }\n        break;\n    }\n\n    case CONN_STATE_CONNECTED_PRETLS:\n        // We've asked for capabilities upon the initial interaction\n    {\n        bool wasCaps = checkCapabilitiesResult(resp);\n        if (wasCaps && !_finished) {\n            startTlsOrLoginNow();\n        }\n        return wasCaps;\n    }\n\n    case CONN_STATE_STARTTLS_ISSUED:\n    {\n        if (resp->tag == startTlsCmd) {\n            if (resp->kind == OK) {\n                model->changeConnectionState(parser, CONN_STATE_STARTTLS_HANDSHAKE);\n                if (!model->m_startTls) {\n                    // The model was not configured to perform STARTTLS, but we still did that for some reason.\n                    // As suggested by Mike Cardwell on the trojita ML (http://article.gmane.org/gmane.mail.trojita.general/299),\n                    // it makes sense to make this settings permanent, so that a user is not tricked into revealing their\n                    // password when a MITM removes the LOGINDISABLED in future.\n                    EMIT_LATER_NOARG(model, requireStartTlsInFuture);\n                }\n            } else {\n                logout(tr(\"STARTTLS failed: %1\").arg(resp->message));\n            }\n            return true;\n        }\n        return false;\n    }\n\n    case CONN_STATE_SSL_HANDSHAKE:\n    case CONN_STATE_STARTTLS_HANDSHAKE:\n        // nothing should really arrive at this point; the Parser is expected to wait for encryption and only after that\n        // send the data\n        Q_ASSERT(false);\n        return false;\n\n    case CONN_STATE_STARTTLS_VERIFYING:\n    case CONN_STATE_SSL_VERIFYING:\n    {\n        // We're waiting for a decision based on a policy, so we do not really expect any network IO at this point\n        // FIXME: an assert(false) here?\n        qDebug() << \"OpenConnectionTask: ignoring response, we're still waiting for SSL policy decision\";\n        return false;\n    }\n\n    case CONN_STATE_ESTABLISHED_PRECAPS:\n        // Connection is established and we're waiting for updated capabilities\n    {\n        bool wasCaps = checkCapabilitiesResult(resp);\n        if (wasCaps && !_finished) {\n            if (model->accessParser(parser).capabilities.contains(QLatin1String(\"LOGINDISABLED\"))) {\n                logout(tr(\"Capabilities still contain LOGINDISABLED even after STARTTLS\"));\n            } else {\n                model->changeConnectionState(parser, CONN_STATE_LOGIN);\n                askForAuth();\n            }\n        }\n        return wasCaps;\n    }\n\n    case CONN_STATE_LOGIN:\n        // Check the result of the LOGIN command\n    {\n        if (resp->tag == loginCmd) {\n            loginCmd.clear();\n            // The LOGIN command is finished\n            if (resp->kind == OK) {\n                if (resp->respCode == CAPABILITIES || model->accessParser(parser).capabilitiesFresh) {\n                    // Capabilities are already known\n                    if (TROJITA_COMPRESS_DEFLATE && model->accessParser(parser).capabilities.contains(QLatin1String(\"COMPRESS=DEFLATE\"))) {\n                        compressCmd = parser->compressDeflate();\n                        model->changeConnectionState(parser, CONN_STATE_COMPRESS_DEFLATE);\n                    } else {\n                        model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n                        onComplete();\n                    }\n                } else {\n                    // Got to ask for the capabilities\n                    model->changeConnectionState(parser, CONN_STATE_POSTAUTH_PRECAPS);\n                    capabilityCmd = parser->capability();\n                }\n            } else {\n                // Login failed\n                QString message;\n                switch (resp->respCode) {\n                case Responses::UNAVAILABLE:\n                    message = tr(\"Temporary failure because a subsystem is down.\");\n                    break;\n                case Responses::AUTHENTICATIONFAILED:\n                    message = tr(\"Authentication failed.  This often happens due to bad password or wrong user name.\");\n                    break;\n                case Responses::AUTHORIZATIONFAILED:\n                    message = tr(\"Authentication succeeded in using the authentication identity, \"\n                                 \"but the server cannot or will not allow the authentication \"\n                                 \"identity to act as the requested authorization identity.\");\n                    break;\n                case Responses::EXPIRED:\n                    message = tr(\"Either authentication succeeded or the server no longer had the \"\n                                 \"necessary data; either way, access is no longer permitted using \"\n                                 \"that passphrase.  You should get a new passphrase.\");\n                    break;\n                case Responses::PRIVACYREQUIRED:\n                    message = tr(\"The operation is not permitted due to a lack of privacy.\");\n                    break;\n                case Responses::CONTACTADMIN:\n                    message = tr(\"You should contact the system administrator or support desk.\");\n                    break;\n                default:\n                    break;\n                }\n\n                if (message.isEmpty()) {\n                    message = tr(\"Login failed: %1\").arg(resp->message);\n                } else {\n                    message = tr(\"%1\\n\\n%2\").arg(message, resp->message);\n                }\n                EMIT_LATER(model, authAttemptFailed, Q_ARG(QString, message));\n                model->m_imapPassword.clear();\n                model->m_hasImapPassword = false;\n                if (model->accessParser(parser).connState == CONN_STATE_LOGOUT) {\n                    // The server has closed the conenction\n                    _failed(QLatin1String(\"Connection closed after a failed login\"));\n                    return true;\n                }\n                askForAuth();\n            }\n            return true;\n        }\n        return false;\n    }\n\n    case CONN_STATE_POSTAUTH_PRECAPS:\n    {\n        bool wasCaps = checkCapabilitiesResult(resp);\n        if (wasCaps && !_finished) {\n            model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n            onComplete();\n        }\n        return wasCaps;\n    }\n\n    case CONN_STATE_COMPRESS_DEFLATE:\n        if (resp->tag == compressCmd) {\n            model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n            onComplete();\n            return true;\n        } else {\n            return false;\n        }\n        break;\n\n    }\n\n    // Required catch-all for OpenSuSE's build service (Tumbleweed, 2012-04-03)\n    Q_ASSERT(false);\n    return false;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145177,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int aac_send_raw_srb(struct aac_dev* dev, void __user * arg)\n{\n\tstruct fib* srbfib;\n\tint status;\n\tstruct aac_srb *srbcmd = NULL;\n\tstruct aac_hba_cmd_req *hbacmd = NULL;\n\tstruct user_aac_srb *user_srbcmd = NULL;\n\tstruct user_aac_srb __user *user_srb = arg;\n\tstruct aac_srb_reply __user *user_reply;\n\tu32 chn;\n\tu32 fibsize = 0;\n\tu32 flags = 0;\n\ts32 rcode = 0;\n\tu32 data_dir;\n\tvoid __user *sg_user[HBA_MAX_SG_EMBEDDED];\n\tvoid *sg_list[HBA_MAX_SG_EMBEDDED];\n\tu32 sg_count[HBA_MAX_SG_EMBEDDED];\n\tu32 sg_indx = 0;\n\tu32 byte_count = 0;\n\tu32 actual_fibsize64, actual_fibsize = 0;\n\tint i;\n\tint is_native_device;\n\tu64 address;\n\n\n\tif (dev->in_reset) {\n\t\tdprintk((KERN_DEBUG\"aacraid: send raw srb -EBUSY\\n\"));\n\t\treturn -EBUSY;\n\t}\n\tif (!capable(CAP_SYS_ADMIN)){\n\t\tdprintk((KERN_DEBUG\"aacraid: No permission to send raw srb\\n\"));\n\t\treturn -EPERM;\n\t}\n\t/*\n\t *\tAllocate and initialize a Fib then setup a SRB command\n\t */\n\tif (!(srbfib = aac_fib_alloc(dev))) {\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(sg_list, 0, sizeof(sg_list)); /* cleanup may take issue */\n\tif(copy_from_user(&fibsize, &user_srb->count,sizeof(u32))){\n\t\tdprintk((KERN_DEBUG\"aacraid: Could not copy data size from user\\n\"));\n\t\trcode = -EFAULT;\n\t\tgoto cleanup;\n\t}\n\n\tif ((fibsize < (sizeof(struct user_aac_srb) - sizeof(struct user_sgentry))) ||\n\t    (fibsize > (dev->max_fib_size - sizeof(struct aac_fibhdr)))) {\n\t\trcode = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\n\tuser_srbcmd = kmalloc(fibsize, GFP_KERNEL);\n\tif (!user_srbcmd) {\n\t\tdprintk((KERN_DEBUG\"aacraid: Could not make a copy of the srb\\n\"));\n\t\trcode = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\tif(copy_from_user(user_srbcmd, user_srb,fibsize)){\n\t\tdprintk((KERN_DEBUG\"aacraid: Could not copy srb from user\\n\"));\n\t\trcode = -EFAULT;\n\t\tgoto cleanup;\n\t}\n\n\tflags = user_srbcmd->flags; /* from user in cpu order */\n\tswitch (flags & (SRB_DataIn | SRB_DataOut)) {\n\tcase SRB_DataOut:\n\t\tdata_dir = DMA_TO_DEVICE;\n\t\tbreak;\n\tcase (SRB_DataIn | SRB_DataOut):\n\t\tdata_dir = DMA_BIDIRECTIONAL;\n\t\tbreak;\n\tcase SRB_DataIn:\n\t\tdata_dir = DMA_FROM_DEVICE;\n\t\tbreak;\n\tdefault:\n\t\tdata_dir = DMA_NONE;\n\t}\n\tif (user_srbcmd->sg.count > ARRAY_SIZE(sg_list)) {\n\t\tdprintk((KERN_DEBUG\"aacraid: too many sg entries %d\\n\",\n\t\t\tuser_srbcmd->sg.count));\n\t\trcode = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\tif ((data_dir == DMA_NONE) && user_srbcmd->sg.count) {\n\t\tdprintk((KERN_DEBUG\"aacraid:SG with no direction specified\\n\"));\n\t\trcode = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\tactual_fibsize = sizeof(struct aac_srb) - sizeof(struct sgentry) +\n\t\t((user_srbcmd->sg.count & 0xff) * sizeof(struct sgentry));\n\tactual_fibsize64 = actual_fibsize + (user_srbcmd->sg.count & 0xff) *\n\t  (sizeof(struct sgentry64) - sizeof(struct sgentry));\n\t/* User made a mistake - should not continue */\n\tif ((actual_fibsize != fibsize) && (actual_fibsize64 != fibsize)) {\n\t\tdprintk((KERN_DEBUG\"aacraid: Bad Size specified in \"\n\t\t  \"Raw SRB command calculated fibsize=%lu;%lu \"\n\t\t  \"user_srbcmd->sg.count=%d aac_srb=%lu sgentry=%lu;%lu \"\n\t\t  \"issued fibsize=%d\\n\",\n\t\t  actual_fibsize, actual_fibsize64, user_srbcmd->sg.count,\n\t\t  sizeof(struct aac_srb), sizeof(struct sgentry),\n\t\t  sizeof(struct sgentry64), fibsize));\n\t\trcode = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\n\tchn = user_srbcmd->channel;\n\tif (chn < AAC_MAX_BUSES && user_srbcmd->id < AAC_MAX_TARGETS &&\n\t\tdev->hba_map[chn][user_srbcmd->id].devtype ==\n\t\tAAC_DEVTYPE_NATIVE_RAW) {\n\t\tis_native_device = 1;\n\t\thbacmd = (struct aac_hba_cmd_req *)srbfib->hw_fib_va;\n\t\tmemset(hbacmd, 0, 96);\t/* sizeof(*hbacmd) is not necessary */\n\n\t\t/* iu_type is a parameter of aac_hba_send */\n\t\tswitch (data_dir) {\n\t\tcase DMA_TO_DEVICE:\n\t\t\thbacmd->byte1 = 2;\n\t\t\tbreak;\n\t\tcase DMA_FROM_DEVICE:\n\t\tcase DMA_BIDIRECTIONAL:\n\t\t\thbacmd->byte1 = 1;\n\t\t\tbreak;\n\t\tcase DMA_NONE:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\thbacmd->lun[1] = cpu_to_le32(user_srbcmd->lun);\n\t\thbacmd->it_nexus = dev->hba_map[chn][user_srbcmd->id].rmw_nexus;\n\n\t\t/*\n\t\t * we fill in reply_qid later in aac_src_deliver_message\n\t\t * we fill in iu_type, request_id later in aac_hba_send\n\t\t * we fill in emb_data_desc_count, data_length later\n\t\t * in sg list build\n\t\t */\n\n\t\tmemcpy(hbacmd->cdb, user_srbcmd->cdb, sizeof(hbacmd->cdb));\n\n\t\taddress = (u64)srbfib->hw_error_pa;\n\t\thbacmd->error_ptr_hi = cpu_to_le32((u32)(address >> 32));\n\t\thbacmd->error_ptr_lo = cpu_to_le32((u32)(address & 0xffffffff));\n\t\thbacmd->error_length = cpu_to_le32(FW_ERROR_BUFFER_SIZE);\n\t\thbacmd->emb_data_desc_count =\n\t\t\t\t\tcpu_to_le32(user_srbcmd->sg.count);\n\t\tsrbfib->hbacmd_size = 64 +\n\t\t\tuser_srbcmd->sg.count * sizeof(struct aac_hba_sgl);\n\n\t} else {\n\t\tis_native_device = 0;\n\t\taac_fib_init(srbfib);\n\n\t\t/* raw_srb FIB is not FastResponseCapable */\n\t\tsrbfib->hw_fib_va->header.XferState &=\n\t\t\t~cpu_to_le32(FastResponseCapable);\n\n\t\tsrbcmd = (struct aac_srb *) fib_data(srbfib);\n\n\t\t// Fix up srb for endian and force some values\n\n\t\tsrbcmd->function = cpu_to_le32(SRBF_ExecuteScsi); // Force this\n\t\tsrbcmd->channel\t = cpu_to_le32(user_srbcmd->channel);\n\t\tsrbcmd->id\t = cpu_to_le32(user_srbcmd->id);\n\t\tsrbcmd->lun\t = cpu_to_le32(user_srbcmd->lun);\n\t\tsrbcmd->timeout\t = cpu_to_le32(user_srbcmd->timeout);\n\t\tsrbcmd->flags\t = cpu_to_le32(flags);\n\t\tsrbcmd->retry_limit = 0; // Obsolete parameter\n\t\tsrbcmd->cdb_size = cpu_to_le32(user_srbcmd->cdb_size);\n\t\tmemcpy(srbcmd->cdb, user_srbcmd->cdb, sizeof(srbcmd->cdb));\n\t}\n\n\tbyte_count = 0;\n\tif (is_native_device) {\n\t\tstruct user_sgmap *usg32 = &user_srbcmd->sg;\n\t\tstruct user_sgmap64 *usg64 =\n\t\t\t(struct user_sgmap64 *)&user_srbcmd->sg;\n\n\t\tfor (i = 0; i < usg32->count; i++) {\n\t\t\tvoid *p;\n\t\t\tu64 addr;\n\n\t\t\tsg_count[i] = (actual_fibsize64 == fibsize) ?\n\t\t\t\tusg64->sg[i].count : usg32->sg[i].count;\n\t\t\tif (sg_count[i] >\n\t\t\t\t(dev->scsi_host_ptr->max_sectors << 9)) {\n\t\t\t\tpr_err(\"aacraid: upsg->sg[%d].count=%u>%u\\n\",\n\t\t\t\t\ti, sg_count[i],\n\t\t\t\t\tdev->scsi_host_ptr->max_sectors << 9);\n\t\t\t\trcode = -EINVAL;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\n\t\t\tp = kmalloc(sg_count[i], GFP_KERNEL);\n\t\t\tif (!p) {\n\t\t\t\trcode = -ENOMEM;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\n\t\t\tif (actual_fibsize64 == fibsize) {\n\t\t\t\taddr = (u64)usg64->sg[i].addr[0];\n\t\t\t\taddr += ((u64)usg64->sg[i].addr[1]) << 32;\n\t\t\t} else {\n\t\t\t\taddr = (u64)usg32->sg[i].addr;\n\t\t\t}\n\n\t\t\tsg_user[i] = (void __user *)(uintptr_t)addr;\n\t\t\tsg_list[i] = p; // save so we can clean up later\n\t\t\tsg_indx = i;\n\n\t\t\tif (flags & SRB_DataOut) {\n\t\t\t\tif (copy_from_user(p, sg_user[i],\n\t\t\t\t\tsg_count[i])) {\n\t\t\t\t\trcode = -EFAULT;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t}\n\t\t\taddr = pci_map_single(dev->pdev, p, sg_count[i],\n\t\t\t\t\t\tdata_dir);\n\t\t\thbacmd->sge[i].addr_hi = cpu_to_le32((u32)(addr>>32));\n\t\t\thbacmd->sge[i].addr_lo = cpu_to_le32(\n\t\t\t\t\t\t(u32)(addr & 0xffffffff));\n\t\t\thbacmd->sge[i].len = cpu_to_le32(sg_count[i]);\n\t\t\thbacmd->sge[i].flags = 0;\n\t\t\tbyte_count += sg_count[i];\n\t\t}\n\n\t\tif (usg32->count > 0)\t/* embedded sglist */\n\t\t\thbacmd->sge[usg32->count-1].flags =\n\t\t\t\tcpu_to_le32(0x40000000);\n\t\thbacmd->data_length = cpu_to_le32(byte_count);\n\n\t\tstatus = aac_hba_send(HBA_IU_TYPE_SCSI_CMD_REQ, srbfib,\n\t\t\t\t\tNULL, NULL);\n\n\t} else if (dev->adapter_info.options & AAC_OPT_SGMAP_HOST64) {\n\t\tstruct user_sgmap64* upsg = (struct user_sgmap64*)&user_srbcmd->sg;\n\t\tstruct sgmap64* psg = (struct sgmap64*)&srbcmd->sg;\n\n\t\t/*\n\t\t * This should also catch if user used the 32 bit sgmap\n\t\t */\n\t\tif (actual_fibsize64 == fibsize) {\n\t\t\tactual_fibsize = actual_fibsize64;\n\t\t\tfor (i = 0; i < upsg->count; i++) {\n\t\t\t\tu64 addr;\n\t\t\t\tvoid* p;\n\n\t\t\t\tsg_count[i] = upsg->sg[i].count;\n\t\t\t\tif (sg_count[i] >\n\t\t\t\t    ((dev->adapter_info.options &\n\t\t\t\t     AAC_OPT_NEW_COMM) ?\n\t\t\t\t      (dev->scsi_host_ptr->max_sectors << 9) :\n\t\t\t\t      65536)) {\n\t\t\t\t\trcode = -EINVAL;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\n\t\t\t\tp = kmalloc(sg_count[i], GFP_KERNEL);\n\t\t\t\tif(!p) {\n\t\t\t\t\tdprintk((KERN_DEBUG\"aacraid: Could not allocate SG buffer - size = %d buffer number %d of %d\\n\",\n\t\t\t\t\t  sg_count[i], i, upsg->count));\n\t\t\t\t\trcode = -ENOMEM;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\taddr = (u64)upsg->sg[i].addr[0];\n\t\t\t\taddr += ((u64)upsg->sg[i].addr[1]) << 32;\n\t\t\t\tsg_user[i] = (void __user *)(uintptr_t)addr;\n\t\t\t\tsg_list[i] = p; // save so we can clean up later\n\t\t\t\tsg_indx = i;\n\n\t\t\t\tif (flags & SRB_DataOut) {\n\t\t\t\t\tif (copy_from_user(p, sg_user[i],\n\t\t\t\t\t\tsg_count[i])){\n\t\t\t\t\t\tdprintk((KERN_DEBUG\"aacraid: Could not copy sg data from user\\n\"));\n\t\t\t\t\t\trcode = -EFAULT;\n\t\t\t\t\t\tgoto cleanup;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taddr = pci_map_single(dev->pdev, p,\n\t\t\t\t\t\t\tsg_count[i], data_dir);\n\n\t\t\t\tpsg->sg[i].addr[0] = cpu_to_le32(addr & 0xffffffff);\n\t\t\t\tpsg->sg[i].addr[1] = cpu_to_le32(addr>>32);\n\t\t\t\tbyte_count += sg_count[i];\n\t\t\t\tpsg->sg[i].count = cpu_to_le32(sg_count[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tstruct user_sgmap* usg;\n\t\t\tusg = kmemdup(upsg,\n\t\t\t\t      actual_fibsize - sizeof(struct aac_srb)\n\t\t\t\t      + sizeof(struct sgmap), GFP_KERNEL);\n\t\t\tif (!usg) {\n\t\t\t\tdprintk((KERN_DEBUG\"aacraid: Allocation error in Raw SRB command\\n\"));\n\t\t\t\trcode = -ENOMEM;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tactual_fibsize = actual_fibsize64;\n\n\t\t\tfor (i = 0; i < usg->count; i++) {\n\t\t\t\tu64 addr;\n\t\t\t\tvoid* p;\n\n\t\t\t\tsg_count[i] = usg->sg[i].count;\n\t\t\t\tif (sg_count[i] >\n\t\t\t\t    ((dev->adapter_info.options &\n\t\t\t\t     AAC_OPT_NEW_COMM) ?\n\t\t\t\t      (dev->scsi_host_ptr->max_sectors << 9) :\n\t\t\t\t      65536)) {\n\t\t\t\t\tkfree(usg);\n\t\t\t\t\trcode = -EINVAL;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\n\t\t\t\tp = kmalloc(sg_count[i], GFP_KERNEL);\n\t\t\t\tif(!p) {\n\t\t\t\t\tdprintk((KERN_DEBUG \"aacraid: Could not allocate SG buffer - size = %d buffer number %d of %d\\n\",\n\t\t\t\t\t\tsg_count[i], i, usg->count));\n\t\t\t\t\tkfree(usg);\n\t\t\t\t\trcode = -ENOMEM;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tsg_user[i] = (void __user *)(uintptr_t)usg->sg[i].addr;\n\t\t\t\tsg_list[i] = p; // save so we can clean up later\n\t\t\t\tsg_indx = i;\n\n\t\t\t\tif (flags & SRB_DataOut) {\n\t\t\t\t\tif (copy_from_user(p, sg_user[i],\n\t\t\t\t\t\tsg_count[i])) {\n\t\t\t\t\t\tkfree (usg);\n\t\t\t\t\t\tdprintk((KERN_DEBUG\"aacraid: Could not copy sg data from user\\n\"));\n\t\t\t\t\t\trcode = -EFAULT;\n\t\t\t\t\t\tgoto cleanup;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taddr = pci_map_single(dev->pdev, p,\n\t\t\t\t\t\t\tsg_count[i], data_dir);\n\n\t\t\t\tpsg->sg[i].addr[0] = cpu_to_le32(addr & 0xffffffff);\n\t\t\t\tpsg->sg[i].addr[1] = cpu_to_le32(addr>>32);\n\t\t\t\tbyte_count += sg_count[i];\n\t\t\t\tpsg->sg[i].count = cpu_to_le32(sg_count[i]);\n\t\t\t}\n\t\t\tkfree (usg);\n\t\t}\n\t\tsrbcmd->count = cpu_to_le32(byte_count);\n\t\tif (user_srbcmd->sg.count)\n\t\t\tpsg->count = cpu_to_le32(sg_indx+1);\n\t\telse\n\t\t\tpsg->count = 0;\n\t\tstatus = aac_fib_send(ScsiPortCommand64, srbfib, actual_fibsize, FsaNormal, 1, 1,NULL,NULL);\n\t} else {\n\t\tstruct user_sgmap* upsg = &user_srbcmd->sg;\n\t\tstruct sgmap* psg = &srbcmd->sg;\n\n\t\tif (actual_fibsize64 == fibsize) {\n\t\t\tstruct user_sgmap64* usg = (struct user_sgmap64 *)upsg;\n\t\t\tfor (i = 0; i < upsg->count; i++) {\n\t\t\t\tuintptr_t addr;\n\t\t\t\tvoid* p;\n\n\t\t\t\tsg_count[i] = usg->sg[i].count;\n\t\t\t\tif (sg_count[i] >\n\t\t\t\t    ((dev->adapter_info.options &\n\t\t\t\t     AAC_OPT_NEW_COMM) ?\n\t\t\t\t      (dev->scsi_host_ptr->max_sectors << 9) :\n\t\t\t\t      65536)) {\n\t\t\t\t\trcode = -EINVAL;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tp = kmalloc(sg_count[i], GFP_KERNEL|GFP_DMA32);\n\t\t\t\tif (!p) {\n\t\t\t\t\tdprintk((KERN_DEBUG\"aacraid: Could not allocate SG buffer - size = %d buffer number %d of %d\\n\",\n\t\t\t\t\t\tsg_count[i], i, usg->count));\n\t\t\t\t\trcode = -ENOMEM;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\taddr = (u64)usg->sg[i].addr[0];\n\t\t\t\taddr += ((u64)usg->sg[i].addr[1]) << 32;\n\t\t\t\tsg_user[i] = (void __user *)addr;\n\t\t\t\tsg_list[i] = p; // save so we can clean up later\n\t\t\t\tsg_indx = i;\n\n\t\t\t\tif (flags & SRB_DataOut) {\n\t\t\t\t\tif (copy_from_user(p, sg_user[i],\n\t\t\t\t\t\tsg_count[i])){\n\t\t\t\t\t\tdprintk((KERN_DEBUG\"aacraid: Could not copy sg data from user\\n\"));\n\t\t\t\t\t\trcode = -EFAULT;\n\t\t\t\t\t\tgoto cleanup;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taddr = pci_map_single(dev->pdev, p, usg->sg[i].count, data_dir);\n\n\t\t\t\tpsg->sg[i].addr = cpu_to_le32(addr & 0xffffffff);\n\t\t\t\tbyte_count += usg->sg[i].count;\n\t\t\t\tpsg->sg[i].count = cpu_to_le32(sg_count[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i = 0; i < upsg->count; i++) {\n\t\t\t\tdma_addr_t addr;\n\t\t\t\tvoid* p;\n\n\t\t\t\tsg_count[i] = upsg->sg[i].count;\n\t\t\t\tif (sg_count[i] >\n\t\t\t\t    ((dev->adapter_info.options &\n\t\t\t\t     AAC_OPT_NEW_COMM) ?\n\t\t\t\t      (dev->scsi_host_ptr->max_sectors << 9) :\n\t\t\t\t      65536)) {\n\t\t\t\t\trcode = -EINVAL;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tp = kmalloc(sg_count[i], GFP_KERNEL|GFP_DMA32);\n\t\t\t\tif (!p) {\n\t\t\t\t\tdprintk((KERN_DEBUG\"aacraid: Could not allocate SG buffer - size = %d buffer number %d of %d\\n\",\n\t\t\t\t\t  sg_count[i], i, upsg->count));\n\t\t\t\t\trcode = -ENOMEM;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tsg_user[i] = (void __user *)(uintptr_t)upsg->sg[i].addr;\n\t\t\t\tsg_list[i] = p; // save so we can clean up later\n\t\t\t\tsg_indx = i;\n\n\t\t\t\tif (flags & SRB_DataOut) {\n\t\t\t\t\tif (copy_from_user(p, sg_user[i],\n\t\t\t\t\t\tsg_count[i])) {\n\t\t\t\t\t\tdprintk((KERN_DEBUG\"aacraid: Could not copy sg data from user\\n\"));\n\t\t\t\t\t\trcode = -EFAULT;\n\t\t\t\t\t\tgoto cleanup;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taddr = pci_map_single(dev->pdev, p,\n\t\t\t\t\tsg_count[i], data_dir);\n\n\t\t\t\tpsg->sg[i].addr = cpu_to_le32(addr);\n\t\t\t\tbyte_count += sg_count[i];\n\t\t\t\tpsg->sg[i].count = cpu_to_le32(sg_count[i]);\n\t\t\t}\n\t\t}\n\t\tsrbcmd->count = cpu_to_le32(byte_count);\n\t\tif (user_srbcmd->sg.count)\n\t\t\tpsg->count = cpu_to_le32(sg_indx+1);\n\t\telse\n\t\t\tpsg->count = 0;\n\t\tstatus = aac_fib_send(ScsiPortCommand, srbfib, actual_fibsize, FsaNormal, 1, 1, NULL, NULL);\n\t}\n\n\tif (status == -ERESTARTSYS) {\n\t\trcode = -ERESTARTSYS;\n\t\tgoto cleanup;\n\t}\n\n\tif (status != 0) {\n\t\tdprintk((KERN_DEBUG\"aacraid: Could not send raw srb fib to hba\\n\"));\n\t\trcode = -ENXIO;\n\t\tgoto cleanup;\n\t}\n\n\tif (flags & SRB_DataIn) {\n\t\tfor(i = 0 ; i <= sg_indx; i++){\n\t\t\tif (copy_to_user(sg_user[i], sg_list[i], sg_count[i])) {\n\t\t\t\tdprintk((KERN_DEBUG\"aacraid: Could not copy sg data to user\\n\"));\n\t\t\t\trcode = -EFAULT;\n\t\t\t\tgoto cleanup;\n\n\t\t\t}\n\t\t}\n\t}\n\n\tuser_reply = arg + fibsize;\n\tif (is_native_device) {\n\t\tstruct aac_hba_resp *err =\n\t\t\t&((struct aac_native_hba *)srbfib->hw_fib_va)->resp.err;\n\t\tstruct aac_srb_reply reply;\n\n\t\treply.status = ST_OK;\n\t\tif (srbfib->flags & FIB_CONTEXT_FLAG_FASTRESP) {\n\t\t\t/* fast response */\n\t\t\treply.srb_status = SRB_STATUS_SUCCESS;\n\t\t\treply.scsi_status = 0;\n\t\t\treply.data_xfer_length = byte_count;\n\t\t\treply.sense_data_size = 0;\n\t\t\tmemset(reply.sense_data, 0, AAC_SENSE_BUFFERSIZE);\n\t\t} else {\n\t\t\treply.srb_status = err->service_response;\n\t\t\treply.scsi_status = err->status;\n\t\t\treply.data_xfer_length = byte_count -\n\t\t\t\tle32_to_cpu(err->residual_count);\n\t\t\treply.sense_data_size = err->sense_response_data_len;\n\t\t\tmemcpy(reply.sense_data, err->sense_response_buf,\n\t\t\t\tAAC_SENSE_BUFFERSIZE);\n\t\t}\n\t\tif (copy_to_user(user_reply, &reply,\n\t\t\tsizeof(struct aac_srb_reply))) {\n\t\t\tdprintk((KERN_DEBUG\"aacraid: Copy to user failed\\n\"));\n\t\t\trcode = -EFAULT;\n\t\t\tgoto cleanup;\n\t\t}\n\t} else {\n\t\tstruct aac_srb_reply *reply;\n\n\t\treply = (struct aac_srb_reply *) fib_data(srbfib);\n\t\tif (copy_to_user(user_reply, reply,\n\t\t\tsizeof(struct aac_srb_reply))) {\n\t\t\tdprintk((KERN_DEBUG\"aacraid: Copy to user failed\\n\"));\n\t\t\trcode = -EFAULT;\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\ncleanup:\n\tkfree(user_srbcmd);\n\tif (rcode != -ERESTARTSYS) {\n\t\tfor (i = 0; i <= sg_indx; i++)\n\t\t\tkfree(sg_list[i]);\n\t\taac_fib_complete(srbfib);\n\t\taac_fib_free(srbfib);\n\t}\n\n\treturn rcode;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145192,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int aac_send_raw_srb(struct aac_dev* dev, void __user * arg)\n{\n\tstruct fib* srbfib;\n\tint status;\n\tstruct aac_srb *srbcmd = NULL;\n\tstruct aac_hba_cmd_req *hbacmd = NULL;\n\tstruct user_aac_srb *user_srbcmd = NULL;\n\tstruct user_aac_srb __user *user_srb = arg;\n\tstruct aac_srb_reply __user *user_reply;\n\tu32 chn;\n\tu32 fibsize = 0;\n\tu32 flags = 0;\n\ts32 rcode = 0;\n\tu32 data_dir;\n\tvoid __user *sg_user[HBA_MAX_SG_EMBEDDED];\n\tvoid *sg_list[HBA_MAX_SG_EMBEDDED];\n\tu32 sg_count[HBA_MAX_SG_EMBEDDED];\n\tu32 sg_indx = 0;\n\tu32 byte_count = 0;\n\tu32 actual_fibsize64, actual_fibsize = 0;\n\tint i;\n\tint is_native_device;\n\tu64 address;\n\n\n\tif (dev->in_reset) {\n\t\tdprintk((KERN_DEBUG\"aacraid: send raw srb -EBUSY\\n\"));\n\t\treturn -EBUSY;\n\t}\n\tif (!capable(CAP_SYS_ADMIN)){\n\t\tdprintk((KERN_DEBUG\"aacraid: No permission to send raw srb\\n\"));\n\t\treturn -EPERM;\n\t}\n\t/*\n\t *\tAllocate and initialize a Fib then setup a SRB command\n\t */\n\tif (!(srbfib = aac_fib_alloc(dev))) {\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(sg_list, 0, sizeof(sg_list)); /* cleanup may take issue */\n\tif(copy_from_user(&fibsize, &user_srb->count,sizeof(u32))){\n\t\tdprintk((KERN_DEBUG\"aacraid: Could not copy data size from user\\n\"));\n\t\trcode = -EFAULT;\n\t\tgoto cleanup;\n\t}\n\n\tif ((fibsize < (sizeof(struct user_aac_srb) - sizeof(struct user_sgentry))) ||\n\t    (fibsize > (dev->max_fib_size - sizeof(struct aac_fibhdr)))) {\n\t\trcode = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\n\tuser_srbcmd = kmalloc(fibsize, GFP_KERNEL);\n\tif (!user_srbcmd) {\n\t\tdprintk((KERN_DEBUG\"aacraid: Could not make a copy of the srb\\n\"));\n\t\trcode = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\tif(copy_from_user(user_srbcmd, user_srb,fibsize)){\n\t\tdprintk((KERN_DEBUG\"aacraid: Could not copy srb from user\\n\"));\n\t\trcode = -EFAULT;\n\t\tgoto cleanup;\n\t}\n\n\tflags = user_srbcmd->flags; /* from user in cpu order */\n\tswitch (flags & (SRB_DataIn | SRB_DataOut)) {\n\tcase SRB_DataOut:\n\t\tdata_dir = DMA_TO_DEVICE;\n\t\tbreak;\n\tcase (SRB_DataIn | SRB_DataOut):\n\t\tdata_dir = DMA_BIDIRECTIONAL;\n\t\tbreak;\n\tcase SRB_DataIn:\n\t\tdata_dir = DMA_FROM_DEVICE;\n\t\tbreak;\n\tdefault:\n\t\tdata_dir = DMA_NONE;\n\t}\n\tif (user_srbcmd->sg.count > ARRAY_SIZE(sg_list)) {\n\t\tdprintk((KERN_DEBUG\"aacraid: too many sg entries %d\\n\",\n\t\t\tuser_srbcmd->sg.count));\n\t\trcode = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\tif ((data_dir == DMA_NONE) && user_srbcmd->sg.count) {\n\t\tdprintk((KERN_DEBUG\"aacraid:SG with no direction specified\\n\"));\n\t\trcode = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\tactual_fibsize = sizeof(struct aac_srb) - sizeof(struct sgentry) +\n\t\t((user_srbcmd->sg.count & 0xff) * sizeof(struct sgentry));\n\tactual_fibsize64 = actual_fibsize + (user_srbcmd->sg.count & 0xff) *\n\t  (sizeof(struct sgentry64) - sizeof(struct sgentry));\n\t/* User made a mistake - should not continue */\n\tif ((actual_fibsize != fibsize) && (actual_fibsize64 != fibsize)) {\n\t\tdprintk((KERN_DEBUG\"aacraid: Bad Size specified in \"\n\t\t  \"Raw SRB command calculated fibsize=%lu;%lu \"\n\t\t  \"user_srbcmd->sg.count=%d aac_srb=%lu sgentry=%lu;%lu \"\n\t\t  \"issued fibsize=%d\\n\",\n\t\t  actual_fibsize, actual_fibsize64, user_srbcmd->sg.count,\n\t\t  sizeof(struct aac_srb), sizeof(struct sgentry),\n\t\t  sizeof(struct sgentry64), fibsize));\n\t\trcode = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\n\tchn = user_srbcmd->channel;\n\tif (chn < AAC_MAX_BUSES && user_srbcmd->id < AAC_MAX_TARGETS &&\n\t\tdev->hba_map[chn][user_srbcmd->id].devtype ==\n\t\tAAC_DEVTYPE_NATIVE_RAW) {\n\t\tis_native_device = 1;\n\t\thbacmd = (struct aac_hba_cmd_req *)srbfib->hw_fib_va;\n\t\tmemset(hbacmd, 0, 96);\t/* sizeof(*hbacmd) is not necessary */\n\n\t\t/* iu_type is a parameter of aac_hba_send */\n\t\tswitch (data_dir) {\n\t\tcase DMA_TO_DEVICE:\n\t\t\thbacmd->byte1 = 2;\n\t\t\tbreak;\n\t\tcase DMA_FROM_DEVICE:\n\t\tcase DMA_BIDIRECTIONAL:\n\t\t\thbacmd->byte1 = 1;\n\t\t\tbreak;\n\t\tcase DMA_NONE:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\thbacmd->lun[1] = cpu_to_le32(user_srbcmd->lun);\n\t\thbacmd->it_nexus = dev->hba_map[chn][user_srbcmd->id].rmw_nexus;\n\n\t\t/*\n\t\t * we fill in reply_qid later in aac_src_deliver_message\n\t\t * we fill in iu_type, request_id later in aac_hba_send\n\t\t * we fill in emb_data_desc_count, data_length later\n\t\t * in sg list build\n\t\t */\n\n\t\tmemcpy(hbacmd->cdb, user_srbcmd->cdb, sizeof(hbacmd->cdb));\n\n\t\taddress = (u64)srbfib->hw_error_pa;\n\t\thbacmd->error_ptr_hi = cpu_to_le32((u32)(address >> 32));\n\t\thbacmd->error_ptr_lo = cpu_to_le32((u32)(address & 0xffffffff));\n\t\thbacmd->error_length = cpu_to_le32(FW_ERROR_BUFFER_SIZE);\n\t\thbacmd->emb_data_desc_count =\n\t\t\t\t\tcpu_to_le32(user_srbcmd->sg.count);\n\t\tsrbfib->hbacmd_size = 64 +\n\t\t\tuser_srbcmd->sg.count * sizeof(struct aac_hba_sgl);\n\n\t} else {\n\t\tis_native_device = 0;\n\t\taac_fib_init(srbfib);\n\n\t\t/* raw_srb FIB is not FastResponseCapable */\n\t\tsrbfib->hw_fib_va->header.XferState &=\n\t\t\t~cpu_to_le32(FastResponseCapable);\n\n\t\tsrbcmd = (struct aac_srb *) fib_data(srbfib);\n\n\t\t// Fix up srb for endian and force some values\n\n\t\tsrbcmd->function = cpu_to_le32(SRBF_ExecuteScsi); // Force this\n\t\tsrbcmd->channel\t = cpu_to_le32(user_srbcmd->channel);\n\t\tsrbcmd->id\t = cpu_to_le32(user_srbcmd->id);\n\t\tsrbcmd->lun\t = cpu_to_le32(user_srbcmd->lun);\n\t\tsrbcmd->timeout\t = cpu_to_le32(user_srbcmd->timeout);\n\t\tsrbcmd->flags\t = cpu_to_le32(flags);\n\t\tsrbcmd->retry_limit = 0; // Obsolete parameter\n\t\tsrbcmd->cdb_size = cpu_to_le32(user_srbcmd->cdb_size);\n\t\tmemcpy(srbcmd->cdb, user_srbcmd->cdb, sizeof(srbcmd->cdb));\n\t}\n\n\tbyte_count = 0;\n\tif (is_native_device) {\n\t\tstruct user_sgmap *usg32 = &user_srbcmd->sg;\n\t\tstruct user_sgmap64 *usg64 =\n\t\t\t(struct user_sgmap64 *)&user_srbcmd->sg;\n\n\t\tfor (i = 0; i < usg32->count; i++) {\n\t\t\tvoid *p;\n\t\t\tu64 addr;\n\n\t\t\tsg_count[i] = (actual_fibsize64 == fibsize) ?\n\t\t\t\tusg64->sg[i].count : usg32->sg[i].count;\n\t\t\tif (sg_count[i] >\n\t\t\t\t(dev->scsi_host_ptr->max_sectors << 9)) {\n\t\t\t\tpr_err(\"aacraid: upsg->sg[%d].count=%u>%u\\n\",\n\t\t\t\t\ti, sg_count[i],\n\t\t\t\t\tdev->scsi_host_ptr->max_sectors << 9);\n\t\t\t\trcode = -EINVAL;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\n\t\t\tp = kmalloc(sg_count[i], GFP_KERNEL);\n\t\t\tif (!p) {\n\t\t\t\trcode = -ENOMEM;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\n\t\t\tif (actual_fibsize64 == fibsize) {\n\t\t\t\taddr = (u64)usg64->sg[i].addr[0];\n\t\t\t\taddr += ((u64)usg64->sg[i].addr[1]) << 32;\n\t\t\t} else {\n\t\t\t\taddr = (u64)usg32->sg[i].addr;\n\t\t\t}\n\n\t\t\tsg_user[i] = (void __user *)(uintptr_t)addr;\n\t\t\tsg_list[i] = p; // save so we can clean up later\n\t\t\tsg_indx = i;\n\n\t\t\tif (flags & SRB_DataOut) {\n\t\t\t\tif (copy_from_user(p, sg_user[i],\n\t\t\t\t\tsg_count[i])) {\n\t\t\t\t\trcode = -EFAULT;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t}\n\t\t\taddr = pci_map_single(dev->pdev, p, sg_count[i],\n\t\t\t\t\t\tdata_dir);\n\t\t\thbacmd->sge[i].addr_hi = cpu_to_le32((u32)(addr>>32));\n\t\t\thbacmd->sge[i].addr_lo = cpu_to_le32(\n\t\t\t\t\t\t(u32)(addr & 0xffffffff));\n\t\t\thbacmd->sge[i].len = cpu_to_le32(sg_count[i]);\n\t\t\thbacmd->sge[i].flags = 0;\n\t\t\tbyte_count += sg_count[i];\n\t\t}\n\n\t\tif (usg32->count > 0)\t/* embedded sglist */\n\t\t\thbacmd->sge[usg32->count-1].flags =\n\t\t\t\tcpu_to_le32(0x40000000);\n\t\thbacmd->data_length = cpu_to_le32(byte_count);\n\n\t\tstatus = aac_hba_send(HBA_IU_TYPE_SCSI_CMD_REQ, srbfib,\n\t\t\t\t\tNULL, NULL);\n\n\t} else if (dev->adapter_info.options & AAC_OPT_SGMAP_HOST64) {\n\t\tstruct user_sgmap64* upsg = (struct user_sgmap64*)&user_srbcmd->sg;\n\t\tstruct sgmap64* psg = (struct sgmap64*)&srbcmd->sg;\n\n\t\t/*\n\t\t * This should also catch if user used the 32 bit sgmap\n\t\t */\n\t\tif (actual_fibsize64 == fibsize) {\n\t\t\tactual_fibsize = actual_fibsize64;\n\t\t\tfor (i = 0; i < upsg->count; i++) {\n\t\t\t\tu64 addr;\n\t\t\t\tvoid* p;\n\n\t\t\t\tsg_count[i] = upsg->sg[i].count;\n\t\t\t\tif (sg_count[i] >\n\t\t\t\t    ((dev->adapter_info.options &\n\t\t\t\t     AAC_OPT_NEW_COMM) ?\n\t\t\t\t      (dev->scsi_host_ptr->max_sectors << 9) :\n\t\t\t\t      65536)) {\n\t\t\t\t\trcode = -EINVAL;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\n\t\t\t\tp = kmalloc(sg_count[i], GFP_KERNEL);\n\t\t\t\tif(!p) {\n\t\t\t\t\tdprintk((KERN_DEBUG\"aacraid: Could not allocate SG buffer - size = %d buffer number %d of %d\\n\",\n\t\t\t\t\t  sg_count[i], i, upsg->count));\n\t\t\t\t\trcode = -ENOMEM;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\taddr = (u64)upsg->sg[i].addr[0];\n\t\t\t\taddr += ((u64)upsg->sg[i].addr[1]) << 32;\n\t\t\t\tsg_user[i] = (void __user *)(uintptr_t)addr;\n\t\t\t\tsg_list[i] = p; // save so we can clean up later\n\t\t\t\tsg_indx = i;\n\n\t\t\t\tif (flags & SRB_DataOut) {\n\t\t\t\t\tif (copy_from_user(p, sg_user[i],\n\t\t\t\t\t\tsg_count[i])){\n\t\t\t\t\t\tdprintk((KERN_DEBUG\"aacraid: Could not copy sg data from user\\n\"));\n\t\t\t\t\t\trcode = -EFAULT;\n\t\t\t\t\t\tgoto cleanup;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taddr = pci_map_single(dev->pdev, p,\n\t\t\t\t\t\t\tsg_count[i], data_dir);\n\n\t\t\t\tpsg->sg[i].addr[0] = cpu_to_le32(addr & 0xffffffff);\n\t\t\t\tpsg->sg[i].addr[1] = cpu_to_le32(addr>>32);\n\t\t\t\tbyte_count += sg_count[i];\n\t\t\t\tpsg->sg[i].count = cpu_to_le32(sg_count[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tstruct user_sgmap* usg;\n\t\t\tusg = kmemdup(upsg,\n\t\t\t\t      actual_fibsize - sizeof(struct aac_srb)\n\t\t\t\t      + sizeof(struct sgmap), GFP_KERNEL);\n\t\t\tif (!usg) {\n\t\t\t\tdprintk((KERN_DEBUG\"aacraid: Allocation error in Raw SRB command\\n\"));\n\t\t\t\trcode = -ENOMEM;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tactual_fibsize = actual_fibsize64;\n\n\t\t\tfor (i = 0; i < usg->count; i++) {\n\t\t\t\tu64 addr;\n\t\t\t\tvoid* p;\n\n\t\t\t\tsg_count[i] = usg->sg[i].count;\n\t\t\t\tif (sg_count[i] >\n\t\t\t\t    ((dev->adapter_info.options &\n\t\t\t\t     AAC_OPT_NEW_COMM) ?\n\t\t\t\t      (dev->scsi_host_ptr->max_sectors << 9) :\n\t\t\t\t      65536)) {\n\t\t\t\t\tkfree(usg);\n\t\t\t\t\trcode = -EINVAL;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\n\t\t\t\tp = kmalloc(sg_count[i], GFP_KERNEL);\n\t\t\t\tif(!p) {\n\t\t\t\t\tdprintk((KERN_DEBUG \"aacraid: Could not allocate SG buffer - size = %d buffer number %d of %d\\n\",\n\t\t\t\t\t\tsg_count[i], i, usg->count));\n\t\t\t\t\tkfree(usg);\n\t\t\t\t\trcode = -ENOMEM;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tsg_user[i] = (void __user *)(uintptr_t)usg->sg[i].addr;\n\t\t\t\tsg_list[i] = p; // save so we can clean up later\n\t\t\t\tsg_indx = i;\n\n\t\t\t\tif (flags & SRB_DataOut) {\n\t\t\t\t\tif (copy_from_user(p, sg_user[i],\n\t\t\t\t\t\tsg_count[i])) {\n\t\t\t\t\t\tkfree (usg);\n\t\t\t\t\t\tdprintk((KERN_DEBUG\"aacraid: Could not copy sg data from user\\n\"));\n\t\t\t\t\t\trcode = -EFAULT;\n\t\t\t\t\t\tgoto cleanup;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taddr = pci_map_single(dev->pdev, p,\n\t\t\t\t\t\t\tsg_count[i], data_dir);\n\n\t\t\t\tpsg->sg[i].addr[0] = cpu_to_le32(addr & 0xffffffff);\n\t\t\t\tpsg->sg[i].addr[1] = cpu_to_le32(addr>>32);\n\t\t\t\tbyte_count += sg_count[i];\n\t\t\t\tpsg->sg[i].count = cpu_to_le32(sg_count[i]);\n\t\t\t}\n\t\t\tkfree (usg);\n\t\t}\n\t\tsrbcmd->count = cpu_to_le32(byte_count);\n\t\tif (user_srbcmd->sg.count)\n\t\t\tpsg->count = cpu_to_le32(sg_indx+1);\n\t\telse\n\t\t\tpsg->count = 0;\n\t\tstatus = aac_fib_send(ScsiPortCommand64, srbfib, actual_fibsize, FsaNormal, 1, 1,NULL,NULL);\n\t} else {\n\t\tstruct user_sgmap* upsg = &user_srbcmd->sg;\n\t\tstruct sgmap* psg = &srbcmd->sg;\n\n\t\tif (actual_fibsize64 == fibsize) {\n\t\t\tstruct user_sgmap64* usg = (struct user_sgmap64 *)upsg;\n\t\t\tfor (i = 0; i < upsg->count; i++) {\n\t\t\t\tuintptr_t addr;\n\t\t\t\tvoid* p;\n\n\t\t\t\tsg_count[i] = usg->sg[i].count;\n\t\t\t\tif (sg_count[i] >\n\t\t\t\t    ((dev->adapter_info.options &\n\t\t\t\t     AAC_OPT_NEW_COMM) ?\n\t\t\t\t      (dev->scsi_host_ptr->max_sectors << 9) :\n\t\t\t\t      65536)) {\n\t\t\t\t\trcode = -EINVAL;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tp = kmalloc(sg_count[i], GFP_KERNEL|GFP_DMA32);\n\t\t\t\tif (!p) {\n\t\t\t\t\tdprintk((KERN_DEBUG\"aacraid: Could not allocate SG buffer - size = %d buffer number %d of %d\\n\",\n\t\t\t\t\t\tsg_count[i], i, usg->count));\n\t\t\t\t\trcode = -ENOMEM;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\taddr = (u64)usg->sg[i].addr[0];\n\t\t\t\taddr += ((u64)usg->sg[i].addr[1]) << 32;\n\t\t\t\tsg_user[i] = (void __user *)addr;\n\t\t\t\tsg_list[i] = p; // save so we can clean up later\n\t\t\t\tsg_indx = i;\n\n\t\t\t\tif (flags & SRB_DataOut) {\n\t\t\t\t\tif (copy_from_user(p, sg_user[i],\n\t\t\t\t\t\tsg_count[i])){\n\t\t\t\t\t\tdprintk((KERN_DEBUG\"aacraid: Could not copy sg data from user\\n\"));\n\t\t\t\t\t\trcode = -EFAULT;\n\t\t\t\t\t\tgoto cleanup;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taddr = pci_map_single(dev->pdev, p, usg->sg[i].count, data_dir);\n\n\t\t\t\tpsg->sg[i].addr = cpu_to_le32(addr & 0xffffffff);\n\t\t\t\tbyte_count += usg->sg[i].count;\n\t\t\t\tpsg->sg[i].count = cpu_to_le32(sg_count[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i = 0; i < upsg->count; i++) {\n\t\t\t\tdma_addr_t addr;\n\t\t\t\tvoid* p;\n\n\t\t\t\tsg_count[i] = upsg->sg[i].count;\n\t\t\t\tif (sg_count[i] >\n\t\t\t\t    ((dev->adapter_info.options &\n\t\t\t\t     AAC_OPT_NEW_COMM) ?\n\t\t\t\t      (dev->scsi_host_ptr->max_sectors << 9) :\n\t\t\t\t      65536)) {\n\t\t\t\t\trcode = -EINVAL;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tp = kmalloc(sg_count[i], GFP_KERNEL|GFP_DMA32);\n\t\t\t\tif (!p) {\n\t\t\t\t\tdprintk((KERN_DEBUG\"aacraid: Could not allocate SG buffer - size = %d buffer number %d of %d\\n\",\n\t\t\t\t\t  sg_count[i], i, upsg->count));\n\t\t\t\t\trcode = -ENOMEM;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tsg_user[i] = (void __user *)(uintptr_t)upsg->sg[i].addr;\n\t\t\t\tsg_list[i] = p; // save so we can clean up later\n\t\t\t\tsg_indx = i;\n\n\t\t\t\tif (flags & SRB_DataOut) {\n\t\t\t\t\tif (copy_from_user(p, sg_user[i],\n\t\t\t\t\t\tsg_count[i])) {\n\t\t\t\t\t\tdprintk((KERN_DEBUG\"aacraid: Could not copy sg data from user\\n\"));\n\t\t\t\t\t\trcode = -EFAULT;\n\t\t\t\t\t\tgoto cleanup;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taddr = pci_map_single(dev->pdev, p,\n\t\t\t\t\tsg_count[i], data_dir);\n\n\t\t\t\tpsg->sg[i].addr = cpu_to_le32(addr);\n\t\t\t\tbyte_count += sg_count[i];\n\t\t\t\tpsg->sg[i].count = cpu_to_le32(sg_count[i]);\n\t\t\t}\n\t\t}\n\t\tsrbcmd->count = cpu_to_le32(byte_count);\n\t\tif (user_srbcmd->sg.count)\n\t\t\tpsg->count = cpu_to_le32(sg_indx+1);\n\t\telse\n\t\t\tpsg->count = 0;\n\t\tstatus = aac_fib_send(ScsiPortCommand, srbfib, actual_fibsize, FsaNormal, 1, 1, NULL, NULL);\n\t}\n\n\tif (status == -ERESTARTSYS) {\n\t\trcode = -ERESTARTSYS;\n\t\tgoto cleanup;\n\t}\n\n\tif (status != 0) {\n\t\tdprintk((KERN_DEBUG\"aacraid: Could not send raw srb fib to hba\\n\"));\n\t\trcode = -ENXIO;\n\t\tgoto cleanup;\n\t}\n\n\tif (flags & SRB_DataIn) {\n\t\tfor(i = 0 ; i <= sg_indx; i++){\n\t\t\tif (copy_to_user(sg_user[i], sg_list[i], sg_count[i])) {\n\t\t\t\tdprintk((KERN_DEBUG\"aacraid: Could not copy sg data to user\\n\"));\n\t\t\t\trcode = -EFAULT;\n\t\t\t\tgoto cleanup;\n\n\t\t\t}\n\t\t}\n\t}\n\n\tuser_reply = arg + fibsize;\n\tif (is_native_device) {\n\t\tstruct aac_hba_resp *err =\n\t\t\t&((struct aac_native_hba *)srbfib->hw_fib_va)->resp.err;\n\t\tstruct aac_srb_reply reply;\n\n\t\tmemset(&reply, 0, sizeof(reply));\n\t\treply.status = ST_OK;\n\t\tif (srbfib->flags & FIB_CONTEXT_FLAG_FASTRESP) {\n\t\t\t/* fast response */\n\t\t\treply.srb_status = SRB_STATUS_SUCCESS;\n\t\t\treply.scsi_status = 0;\n\t\t\treply.data_xfer_length = byte_count;\n\t\t\treply.sense_data_size = 0;\n\t\t\tmemset(reply.sense_data, 0, AAC_SENSE_BUFFERSIZE);\n\t\t} else {\n\t\t\treply.srb_status = err->service_response;\n\t\t\treply.scsi_status = err->status;\n\t\t\treply.data_xfer_length = byte_count -\n\t\t\t\tle32_to_cpu(err->residual_count);\n\t\t\treply.sense_data_size = err->sense_response_data_len;\n\t\t\tmemcpy(reply.sense_data, err->sense_response_buf,\n\t\t\t\tAAC_SENSE_BUFFERSIZE);\n\t\t}\n\t\tif (copy_to_user(user_reply, &reply,\n\t\t\tsizeof(struct aac_srb_reply))) {\n\t\t\tdprintk((KERN_DEBUG\"aacraid: Copy to user failed\\n\"));\n\t\t\trcode = -EFAULT;\n\t\t\tgoto cleanup;\n\t\t}\n\t} else {\n\t\tstruct aac_srb_reply *reply;\n\n\t\treply = (struct aac_srb_reply *) fib_data(srbfib);\n\t\tif (copy_to_user(user_reply, reply,\n\t\t\tsizeof(struct aac_srb_reply))) {\n\t\t\tdprintk((KERN_DEBUG\"aacraid: Copy to user failed\\n\"));\n\t\t\trcode = -EFAULT;\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\ncleanup:\n\tkfree(user_srbcmd);\n\tif (rcode != -ERESTARTSYS) {\n\t\tfor (i = 0; i <= sg_indx; i++)\n\t\t\tkfree(sg_list[i]);\n\t\taac_fib_complete(srbfib);\n\t\taac_fib_free(srbfib);\n\t}\n\n\treturn rcode;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145193,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "int imap_open_connection (IMAP_DATA* idata)\n{\n  if (mutt_socket_open (idata->conn) < 0)\n    return -1;\n\n  idata->state = IMAP_CONNECTED;\n\n  if (imap_cmd_step (idata) != IMAP_CMD_OK)\n  {\n    imap_close_connection (idata);\n    return -1;\n  }\n\n  if (ascii_strncasecmp (\"* OK\", idata->buf, 4) == 0)\n  {\n    if (ascii_strncasecmp (\"* OK [CAPABILITY\", idata->buf, 16)\n        && imap_check_capabilities (idata))\n      goto bail;\n#if defined(USE_SSL)\n    /* Attempt STARTTLS if available and desired. */\n    if (!idata->conn->ssf && (option(OPTSSLFORCETLS) ||\n                              mutt_bit_isset (idata->capabilities, STARTTLS)))\n    {\n      int rc;\n\n      if (option(OPTSSLFORCETLS))\n        rc = MUTT_YES;\n      else if ((rc = query_quadoption (OPT_SSLSTARTTLS,\n                                       _(\"Secure connection with TLS?\"))) == -1)\n\tgoto err_close_conn;\n      if (rc == MUTT_YES)\n      {\n\tif ((rc = imap_exec (idata, \"STARTTLS\", IMAP_CMD_FAIL_OK)) == -1)\n\t  goto bail;\n\tif (rc != -2)\n\t{\n\t  if (mutt_ssl_starttls (idata->conn))\n\t  {\n\t    mutt_error (_(\"Could not negotiate TLS connection\"));\n\t    mutt_sleep (1);\n\t    goto err_close_conn;\n\t  }\n\t  else\n\t  {\n\t    /* RFC 2595 demands we recheck CAPABILITY after TLS completes. */\n\t    if (imap_exec (idata, \"CAPABILITY\", 0))\n\t      goto bail;\n\t  }\n\t}\n      }\n    }\n\n    if (option(OPTSSLFORCETLS) && ! idata->conn->ssf)\n    {\n      mutt_error _(\"Encrypted connection unavailable\");\n      mutt_sleep (1);\n      goto err_close_conn;\n    }\n#endif\n  }\n  else if (ascii_strncasecmp (\"* PREAUTH\", idata->buf, 9) == 0)\n  {\n    idata->state = IMAP_AUTHENTICATED;\n    if (imap_check_capabilities (idata) != 0)\n      goto bail;\n    FREE (&idata->capstr);\n  }\n  else\n  {\n    imap_error (\"imap_open_connection()\", idata->buf);\n    goto bail;\n  }\n\n  return 0;\n\n#if defined(USE_SSL)\nerr_close_conn:\n  imap_close_connection (idata);\n#endif\nbail:\n  FREE (&idata->capstr);\n  return -1;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145330,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "int imap_open_connection (IMAP_DATA* idata)\n{\n  if (mutt_socket_open (idata->conn) < 0)\n    return -1;\n\n  idata->state = IMAP_CONNECTED;\n\n  if (imap_cmd_step (idata) != IMAP_CMD_OK)\n  {\n    imap_close_connection (idata);\n    return -1;\n  }\n\n  if (ascii_strncasecmp (\"* OK\", idata->buf, 4) == 0)\n  {\n    if (ascii_strncasecmp (\"* OK [CAPABILITY\", idata->buf, 16)\n        && imap_check_capabilities (idata))\n      goto bail;\n#if defined(USE_SSL)\n    /* Attempt STARTTLS if available and desired. */\n    if (!idata->conn->ssf && (option(OPTSSLFORCETLS) ||\n                              mutt_bit_isset (idata->capabilities, STARTTLS)))\n    {\n      int rc;\n\n      if (option(OPTSSLFORCETLS))\n        rc = MUTT_YES;\n      else if ((rc = query_quadoption (OPT_SSLSTARTTLS,\n                                       _(\"Secure connection with TLS?\"))) == -1)\n\tgoto err_close_conn;\n      if (rc == MUTT_YES)\n      {\n\tif ((rc = imap_exec (idata, \"STARTTLS\", IMAP_CMD_FAIL_OK)) == -1)\n\t  goto bail;\n\tif (rc != -2)\n\t{\n\t  if (mutt_ssl_starttls (idata->conn))\n\t  {\n\t    mutt_error (_(\"Could not negotiate TLS connection\"));\n\t    mutt_sleep (1);\n\t    goto err_close_conn;\n\t  }\n\t  else\n\t  {\n\t    /* RFC 2595 demands we recheck CAPABILITY after TLS completes. */\n\t    if (imap_exec (idata, \"CAPABILITY\", 0))\n\t      goto bail;\n\t  }\n\t}\n      }\n    }\n\n    if (option(OPTSSLFORCETLS) && ! idata->conn->ssf)\n    {\n      mutt_error _(\"Encrypted connection unavailable\");\n      mutt_sleep (1);\n      goto err_close_conn;\n    }\n#endif\n  }\n  else if (ascii_strncasecmp (\"* PREAUTH\", idata->buf, 9) == 0)\n  {\n#if defined(USE_SSL)\n    /* An unencrypted PREAUTH response is most likely a MITM attack.\n     * Require a confirmation. */\n    if (!idata->conn->ssf)\n    {\n      if (option(OPTSSLFORCETLS) ||\n          (query_quadoption (OPT_SSLSTARTTLS,\n                             _(\"Abort unencrypted PREAUTH connection?\")) != MUTT_NO))\n      {\n        mutt_error _(\"Encrypted connection unavailable\");\n        mutt_sleep (1);\n        goto err_close_conn;\n      }\n    }\n#endif\n\n    idata->state = IMAP_AUTHENTICATED;\n    if (imap_check_capabilities (idata) != 0)\n      goto bail;\n    FREE (&idata->capstr);\n  }\n  else\n  {\n    imap_error (\"imap_open_connection()\", idata->buf);\n    goto bail;\n  }\n\n  return 0;\n\n#if defined(USE_SSL)\nerr_close_conn:\n  imap_close_connection (idata);\n#endif\nbail:\n  FREE (&idata->capstr);\n  return -1;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145331,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int vt_k_ioctl(struct tty_struct *tty, unsigned int cmd,\n\t\tunsigned long arg, bool perm)\n{\n\tstruct vc_data *vc = tty->driver_data;\n\tvoid __user *up = (void __user *)arg;\n\tunsigned int console = vc->vc_num;\n\tint ret;\n\n\tswitch (cmd) {\n\tcase KIOCSOUND:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\t/*\n\t\t * The use of PIT_TICK_RATE is historic, it used to be\n\t\t * the platform-dependent CLOCK_TICK_RATE between 2.6.12\n\t\t * and 2.6.36, which was a minor but unfortunate ABI\n\t\t * change. kd_mksound is locked by the input layer.\n\t\t */\n\t\tif (arg)\n\t\t\targ = PIT_TICK_RATE / arg;\n\t\tkd_mksound(arg, 0);\n\t\tbreak;\n\n\tcase KDMKTONE:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t{\n\t\tunsigned int ticks, count;\n\n\t\t/*\n\t\t * Generate the tone for the appropriate number of ticks.\n\t\t * If the time is zero, turn off sound ourselves.\n\t\t */\n\t\tticks = msecs_to_jiffies((arg >> 16) & 0xffff);\n\t\tcount = ticks ? (arg & 0xffff) : 0;\n\t\tif (count)\n\t\t\tcount = PIT_TICK_RATE / count;\n\t\tkd_mksound(count, ticks);\n\t\tbreak;\n\t}\n\n\tcase KDGKBTYPE:\n\t\t/*\n\t\t * this is na\u00efve.\n\t\t */\n\t\treturn put_user(KB_101, (char __user *)arg);\n\n\t\t/*\n\t\t * These cannot be implemented on any machine that implements\n\t\t * ioperm() in user level (such as Alpha PCs) or not at all.\n\t\t *\n\t\t * XXX: you should never use these, just call ioperm directly..\n\t\t */\n#ifdef CONFIG_X86\n\tcase KDADDIO:\n\tcase KDDELIO:\n\t\t/*\n\t\t * KDADDIO and KDDELIO may be able to add ports beyond what\n\t\t * we reject here, but to be safe...\n\t\t *\n\t\t * These are locked internally via sys_ioperm\n\t\t */\n\t\tif (arg < GPFIRST || arg > GPLAST)\n\t\t\treturn -EINVAL;\n\n\t\treturn ksys_ioperm(arg, 1, (cmd == KDADDIO)) ? -ENXIO : 0;\n\n\tcase KDENABIO:\n\tcase KDDISABIO:\n\t\treturn ksys_ioperm(GPFIRST, GPNUM,\n\t\t\t\t  (cmd == KDENABIO)) ? -ENXIO : 0;\n#endif\n\n\t/* Linux m68k/i386 interface for setting the keyboard delay/repeat rate */\n\n\tcase KDKBDREP:\n\t{\n\t\tstruct kbd_repeat kbrep;\n\n\t\tif (!capable(CAP_SYS_TTY_CONFIG))\n\t\t\treturn -EPERM;\n\n\t\tif (copy_from_user(&kbrep, up, sizeof(struct kbd_repeat)))\n\t\t\treturn -EFAULT;\n\n\t\tret = kbd_rate(&kbrep);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (copy_to_user(up, &kbrep, sizeof(struct kbd_repeat)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\t}\n\n\tcase KDSETMODE:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\n\t\treturn vt_kdsetmode(vc, arg);\n\n\tcase KDGETMODE:\n\t\treturn put_user(vc->vc_mode, (int __user *)arg);\n\n\tcase KDMAPDISP:\n\tcase KDUNMAPDISP:\n\t\t/*\n\t\t * these work like a combination of mmap and KDENABIO.\n\t\t * this could be easily finished.\n\t\t */\n\t\treturn -EINVAL;\n\n\tcase KDSKBMODE:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\tret = vt_do_kdskbmode(console, arg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\ttty_ldisc_flush(tty);\n\t\tbreak;\n\n\tcase KDGKBMODE:\n\t\treturn put_user(vt_do_kdgkbmode(console), (int __user *)arg);\n\n\t/* this could be folded into KDSKBMODE, but for compatibility\n\t   reasons it is not so easy to fold KDGKBMETA into KDGKBMODE */\n\tcase KDSKBMETA:\n\t\treturn vt_do_kdskbmeta(console, arg);\n\n\tcase KDGKBMETA:\n\t\t/* FIXME: should review whether this is worth locking */\n\t\treturn put_user(vt_do_kdgkbmeta(console), (int __user *)arg);\n\n\tcase KDGETKEYCODE:\n\tcase KDSETKEYCODE:\n\t\tif(!capable(CAP_SYS_TTY_CONFIG))\n\t\t\tperm = 0;\n\t\treturn vt_do_kbkeycode_ioctl(cmd, up, perm);\n\n\tcase KDGKBENT:\n\tcase KDSKBENT:\n\t\treturn vt_do_kdsk_ioctl(cmd, up, perm, console);\n\n\tcase KDGKBSENT:\n\tcase KDSKBSENT:\n\t\treturn vt_do_kdgkb_ioctl(cmd, up, perm);\n\n\t/* Diacritical processing. Handled in keyboard.c as it has\n\t   to operate on the keyboard locks and structures */\n\tcase KDGKBDIACR:\n\tcase KDGKBDIACRUC:\n\tcase KDSKBDIACR:\n\tcase KDSKBDIACRUC:\n\t\treturn vt_do_diacrit(cmd, up, perm);\n\n\t/* the ioctls below read/set the flags usually shown in the leds */\n\t/* don't use them - they will go away without warning */\n\tcase KDGKBLED:\n\tcase KDSKBLED:\n\tcase KDGETLED:\n\tcase KDSETLED:\n\t\treturn vt_do_kdskled(console, cmd, arg, perm);\n\n\t/*\n\t * A process can indicate its willingness to accept signals\n\t * generated by pressing an appropriate key combination.\n\t * Thus, one can have a daemon that e.g. spawns a new console\n\t * upon a keypress and then changes to it.\n\t * See also the kbrequest field of inittab(5).\n\t */\n\tcase KDSIGACCEPT:\n\t\tif (!perm || !capable(CAP_KILL))\n\t\t\treturn -EPERM;\n\t\tif (!valid_signal(arg) || arg < 1 || arg == SIGKILL)\n\t\t\treturn -EINVAL;\n\n\t\tspin_lock_irq(&vt_spawn_con.lock);\n\t\tput_pid(vt_spawn_con.pid);\n\t\tvt_spawn_con.pid = get_pid(task_pid(current));\n\t\tvt_spawn_con.sig = arg;\n\t\tspin_unlock_irq(&vt_spawn_con.lock);\n\t\tbreak;\n\n\tcase KDFONTOP: {\n\t\tstruct console_font_op op;\n\n\t\tif (copy_from_user(&op, up, sizeof(op)))\n\t\t\treturn -EFAULT;\n\t\tif (!perm && op.op != KD_FONT_OP_GET)\n\t\t\treturn -EPERM;\n\t\tret = con_font_op(vc, &op);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (copy_to_user(up, &op, sizeof(op)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145378,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int vt_k_ioctl(struct tty_struct *tty, unsigned int cmd,\n\t\tunsigned long arg, bool perm)\n{\n\tstruct vc_data *vc = tty->driver_data;\n\tvoid __user *up = (void __user *)arg;\n\tunsigned int console = vc->vc_num;\n\tint ret;\n\n\tswitch (cmd) {\n\tcase KIOCSOUND:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\t/*\n\t\t * The use of PIT_TICK_RATE is historic, it used to be\n\t\t * the platform-dependent CLOCK_TICK_RATE between 2.6.12\n\t\t * and 2.6.36, which was a minor but unfortunate ABI\n\t\t * change. kd_mksound is locked by the input layer.\n\t\t */\n\t\tif (arg)\n\t\t\targ = PIT_TICK_RATE / arg;\n\t\tkd_mksound(arg, 0);\n\t\tbreak;\n\n\tcase KDMKTONE:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t{\n\t\tunsigned int ticks, count;\n\n\t\t/*\n\t\t * Generate the tone for the appropriate number of ticks.\n\t\t * If the time is zero, turn off sound ourselves.\n\t\t */\n\t\tticks = msecs_to_jiffies((arg >> 16) & 0xffff);\n\t\tcount = ticks ? (arg & 0xffff) : 0;\n\t\tif (count)\n\t\t\tcount = PIT_TICK_RATE / count;\n\t\tkd_mksound(count, ticks);\n\t\tbreak;\n\t}\n\n\tcase KDGKBTYPE:\n\t\t/*\n\t\t * this is na\u00efve.\n\t\t */\n\t\treturn put_user(KB_101, (char __user *)arg);\n\n\t\t/*\n\t\t * These cannot be implemented on any machine that implements\n\t\t * ioperm() in user level (such as Alpha PCs) or not at all.\n\t\t *\n\t\t * XXX: you should never use these, just call ioperm directly..\n\t\t */\n#ifdef CONFIG_X86\n\tcase KDADDIO:\n\tcase KDDELIO:\n\t\t/*\n\t\t * KDADDIO and KDDELIO may be able to add ports beyond what\n\t\t * we reject here, but to be safe...\n\t\t *\n\t\t * These are locked internally via sys_ioperm\n\t\t */\n\t\tif (arg < GPFIRST || arg > GPLAST)\n\t\t\treturn -EINVAL;\n\n\t\treturn ksys_ioperm(arg, 1, (cmd == KDADDIO)) ? -ENXIO : 0;\n\n\tcase KDENABIO:\n\tcase KDDISABIO:\n\t\treturn ksys_ioperm(GPFIRST, GPNUM,\n\t\t\t\t  (cmd == KDENABIO)) ? -ENXIO : 0;\n#endif\n\n\t/* Linux m68k/i386 interface for setting the keyboard delay/repeat rate */\n\n\tcase KDKBDREP:\n\t{\n\t\tstruct kbd_repeat kbrep;\n\n\t\tif (!capable(CAP_SYS_TTY_CONFIG))\n\t\t\treturn -EPERM;\n\n\t\tif (copy_from_user(&kbrep, up, sizeof(struct kbd_repeat)))\n\t\t\treturn -EFAULT;\n\n\t\tret = kbd_rate(&kbrep);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (copy_to_user(up, &kbrep, sizeof(struct kbd_repeat)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\t}\n\n\tcase KDSETMODE:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\n\t\tconsole_lock();\n\t\tret = vt_kdsetmode(vc, arg);\n\t\tconsole_unlock();\n\t\treturn ret;\n\n\tcase KDGETMODE:\n\t\treturn put_user(vc->vc_mode, (int __user *)arg);\n\n\tcase KDMAPDISP:\n\tcase KDUNMAPDISP:\n\t\t/*\n\t\t * these work like a combination of mmap and KDENABIO.\n\t\t * this could be easily finished.\n\t\t */\n\t\treturn -EINVAL;\n\n\tcase KDSKBMODE:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\tret = vt_do_kdskbmode(console, arg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\ttty_ldisc_flush(tty);\n\t\tbreak;\n\n\tcase KDGKBMODE:\n\t\treturn put_user(vt_do_kdgkbmode(console), (int __user *)arg);\n\n\t/* this could be folded into KDSKBMODE, but for compatibility\n\t   reasons it is not so easy to fold KDGKBMETA into KDGKBMODE */\n\tcase KDSKBMETA:\n\t\treturn vt_do_kdskbmeta(console, arg);\n\n\tcase KDGKBMETA:\n\t\t/* FIXME: should review whether this is worth locking */\n\t\treturn put_user(vt_do_kdgkbmeta(console), (int __user *)arg);\n\n\tcase KDGETKEYCODE:\n\tcase KDSETKEYCODE:\n\t\tif(!capable(CAP_SYS_TTY_CONFIG))\n\t\t\tperm = 0;\n\t\treturn vt_do_kbkeycode_ioctl(cmd, up, perm);\n\n\tcase KDGKBENT:\n\tcase KDSKBENT:\n\t\treturn vt_do_kdsk_ioctl(cmd, up, perm, console);\n\n\tcase KDGKBSENT:\n\tcase KDSKBSENT:\n\t\treturn vt_do_kdgkb_ioctl(cmd, up, perm);\n\n\t/* Diacritical processing. Handled in keyboard.c as it has\n\t   to operate on the keyboard locks and structures */\n\tcase KDGKBDIACR:\n\tcase KDGKBDIACRUC:\n\tcase KDSKBDIACR:\n\tcase KDSKBDIACRUC:\n\t\treturn vt_do_diacrit(cmd, up, perm);\n\n\t/* the ioctls below read/set the flags usually shown in the leds */\n\t/* don't use them - they will go away without warning */\n\tcase KDGKBLED:\n\tcase KDSKBLED:\n\tcase KDGETLED:\n\tcase KDSETLED:\n\t\treturn vt_do_kdskled(console, cmd, arg, perm);\n\n\t/*\n\t * A process can indicate its willingness to accept signals\n\t * generated by pressing an appropriate key combination.\n\t * Thus, one can have a daemon that e.g. spawns a new console\n\t * upon a keypress and then changes to it.\n\t * See also the kbrequest field of inittab(5).\n\t */\n\tcase KDSIGACCEPT:\n\t\tif (!perm || !capable(CAP_KILL))\n\t\t\treturn -EPERM;\n\t\tif (!valid_signal(arg) || arg < 1 || arg == SIGKILL)\n\t\t\treturn -EINVAL;\n\n\t\tspin_lock_irq(&vt_spawn_con.lock);\n\t\tput_pid(vt_spawn_con.pid);\n\t\tvt_spawn_con.pid = get_pid(task_pid(current));\n\t\tvt_spawn_con.sig = arg;\n\t\tspin_unlock_irq(&vt_spawn_con.lock);\n\t\tbreak;\n\n\tcase KDFONTOP: {\n\t\tstruct console_font_op op;\n\n\t\tif (copy_from_user(&op, up, sizeof(op)))\n\t\t\treturn -EFAULT;\n\t\tif (!perm && op.op != KD_FONT_OP_GET)\n\t\t\treturn -EPERM;\n\t\tret = con_font_op(vc, &op);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (copy_to_user(up, &op, sizeof(op)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145379,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int btrfs_clone(struct inode *src, struct inode *inode,\n\t\t       const u64 off, const u64 olen, const u64 olen_aligned,\n\t\t       const u64 destoff, int no_time_update)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_path *path = NULL;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_trans_handle *trans;\n\tchar *buf = NULL;\n\tstruct btrfs_key key;\n\tu32 nritems;\n\tint slot;\n\tint ret;\n\tint no_quota;\n\tconst u64 len = olen_aligned;\n\tu64 last_disko = 0;\n\tu64 last_dest_end = destoff;\n\n\tret = -ENOMEM;\n\tbuf = vmalloc(root->nodesize);\n\tif (!buf)\n\t\treturn ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tvfree(buf);\n\t\treturn ret;\n\t}\n\n\tpath->reada = 2;\n\t/* clone data */\n\tkey.objectid = btrfs_ino(src);\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = off;\n\n\twhile (1) {\n\t\tu64 next_key_min_offset = key.offset + 1;\n\n\t\t/*\n\t\t * note the key will change type as we walk through the\n\t\t * tree.\n\t\t */\n\t\tpath->leave_spinning = 1;\n\t\tret = btrfs_search_slot(NULL, BTRFS_I(src)->root, &key, path,\n\t\t\t\t0, 0);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\t/*\n\t\t * First search, if no extent item that starts at offset off was\n\t\t * found but the previous item is an extent item, it's possible\n\t\t * it might overlap our target range, therefore process it.\n\t\t */\n\t\tif (key.offset == off && ret > 0 && path->slots[0] > 0) {\n\t\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key,\n\t\t\t\t\t      path->slots[0] - 1);\n\t\t\tif (key.type == BTRFS_EXTENT_DATA_KEY)\n\t\t\t\tpath->slots[0]--;\n\t\t}\n\n\t\tnritems = btrfs_header_nritems(path->nodes[0]);\nprocess_slot:\n\t\tno_quota = 1;\n\t\tif (path->slots[0] >= nritems) {\n\t\t\tret = btrfs_next_leaf(BTRFS_I(src)->root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret > 0)\n\t\t\t\tbreak;\n\t\t\tnritems = btrfs_header_nritems(path->nodes[0]);\n\t\t}\n\t\tleaf = path->nodes[0];\n\t\tslot = path->slots[0];\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\t\tif (key.type > BTRFS_EXTENT_DATA_KEY ||\n\t\t    key.objectid != btrfs_ino(src))\n\t\t\tbreak;\n\n\t\tif (key.type == BTRFS_EXTENT_DATA_KEY) {\n\t\t\tstruct btrfs_file_extent_item *extent;\n\t\t\tint type;\n\t\t\tu32 size;\n\t\t\tstruct btrfs_key new_key;\n\t\t\tu64 disko = 0, diskl = 0;\n\t\t\tu64 datao = 0, datal = 0;\n\t\t\tu8 comp;\n\t\t\tu64 drop_start;\n\n\t\t\textent = btrfs_item_ptr(leaf, slot,\n\t\t\t\t\t\tstruct btrfs_file_extent_item);\n\t\t\tcomp = btrfs_file_extent_compression(leaf, extent);\n\t\t\ttype = btrfs_file_extent_type(leaf, extent);\n\t\t\tif (type == BTRFS_FILE_EXTENT_REG ||\n\t\t\t    type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\t\t\tdisko = btrfs_file_extent_disk_bytenr(leaf,\n\t\t\t\t\t\t\t\t      extent);\n\t\t\t\tdiskl = btrfs_file_extent_disk_num_bytes(leaf,\n\t\t\t\t\t\t\t\t extent);\n\t\t\t\tdatao = btrfs_file_extent_offset(leaf, extent);\n\t\t\t\tdatal = btrfs_file_extent_num_bytes(leaf,\n\t\t\t\t\t\t\t\t    extent);\n\t\t\t} else if (type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\t/* take upper bound, may be compressed */\n\t\t\t\tdatal = btrfs_file_extent_ram_bytes(leaf,\n\t\t\t\t\t\t\t\t    extent);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The first search might have left us at an extent\n\t\t\t * item that ends before our target range's start, can\n\t\t\t * happen if we have holes and NO_HOLES feature enabled.\n\t\t\t */\n\t\t\tif (key.offset + datal <= off) {\n\t\t\t\tpath->slots[0]++;\n\t\t\t\tgoto process_slot;\n\t\t\t} else if (key.offset >= off + len) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnext_key_min_offset = key.offset + datal;\n\t\t\tsize = btrfs_item_size_nr(leaf, slot);\n\t\t\tread_extent_buffer(leaf, buf,\n\t\t\t\t\t   btrfs_item_ptr_offset(leaf, slot),\n\t\t\t\t\t   size);\n\n\t\t\tbtrfs_release_path(path);\n\t\t\tpath->leave_spinning = 0;\n\n\t\t\tmemcpy(&new_key, &key, sizeof(new_key));\n\t\t\tnew_key.objectid = btrfs_ino(inode);\n\t\t\tif (off <= key.offset)\n\t\t\t\tnew_key.offset = key.offset + destoff - off;\n\t\t\telse\n\t\t\t\tnew_key.offset = destoff;\n\n\t\t\t/*\n\t\t\t * Deal with a hole that doesn't have an extent item\n\t\t\t * that represents it (NO_HOLES feature enabled).\n\t\t\t * This hole is either in the middle of the cloning\n\t\t\t * range or at the beginning (fully overlaps it or\n\t\t\t * partially overlaps it).\n\t\t\t */\n\t\t\tif (new_key.offset != last_dest_end)\n\t\t\t\tdrop_start = last_dest_end;\n\t\t\telse\n\t\t\t\tdrop_start = new_key.offset;\n\n\t\t\t/*\n\t\t\t * 1 - adjusting old extent (we may have to split it)\n\t\t\t * 1 - add new extent\n\t\t\t * 1 - inode update\n\t\t\t */\n\t\t\ttrans = btrfs_start_transaction(root, 3);\n\t\t\tif (IS_ERR(trans)) {\n\t\t\t\tret = PTR_ERR(trans);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (type == BTRFS_FILE_EXTENT_REG ||\n\t\t\t    type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\t\t\t/*\n\t\t\t\t *    a  | --- range to clone ---|  b\n\t\t\t\t * | ------------- extent ------------- |\n\t\t\t\t */\n\n\t\t\t\t/* subtract range b */\n\t\t\t\tif (key.offset + datal > off + len)\n\t\t\t\t\tdatal = off + len - key.offset;\n\n\t\t\t\t/* subtract range a */\n\t\t\t\tif (off > key.offset) {\n\t\t\t\t\tdatao += off - key.offset;\n\t\t\t\t\tdatal -= off - key.offset;\n\t\t\t\t}\n\n\t\t\t\tret = btrfs_drop_extents(trans, root, inode,\n\t\t\t\t\t\t\t drop_start,\n\t\t\t\t\t\t\t new_key.offset + datal,\n\t\t\t\t\t\t\t 1);\n\t\t\t\tif (ret) {\n\t\t\t\t\tif (ret != -EOPNOTSUPP)\n\t\t\t\t\t\tbtrfs_abort_transaction(trans,\n\t\t\t\t\t\t\t\troot, ret);\n\t\t\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tret = btrfs_insert_empty_item(trans, root, path,\n\t\t\t\t\t\t\t      &new_key, size);\n\t\t\t\tif (ret) {\n\t\t\t\t\tbtrfs_abort_transaction(trans, root,\n\t\t\t\t\t\t\t\tret);\n\t\t\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tleaf = path->nodes[0];\n\t\t\t\tslot = path->slots[0];\n\t\t\t\twrite_extent_buffer(leaf, buf,\n\t\t\t\t\t    btrfs_item_ptr_offset(leaf, slot),\n\t\t\t\t\t    size);\n\n\t\t\t\textent = btrfs_item_ptr(leaf, slot,\n\t\t\t\t\t\tstruct btrfs_file_extent_item);\n\n\t\t\t\t/* disko == 0 means it's a hole */\n\t\t\t\tif (!disko)\n\t\t\t\t\tdatao = 0;\n\n\t\t\t\tbtrfs_set_file_extent_offset(leaf, extent,\n\t\t\t\t\t\t\t     datao);\n\t\t\t\tbtrfs_set_file_extent_num_bytes(leaf, extent,\n\t\t\t\t\t\t\t\tdatal);\n\n\t\t\t\t/*\n\t\t\t\t * We need to look up the roots that point at\n\t\t\t\t * this bytenr and see if the new root does.  If\n\t\t\t\t * it does not we need to make sure we update\n\t\t\t\t * quotas appropriately.\n\t\t\t\t */\n\t\t\t\tif (disko && root != BTRFS_I(src)->root &&\n\t\t\t\t    disko != last_disko) {\n\t\t\t\t\tno_quota = check_ref(trans, root,\n\t\t\t\t\t\t\t     disko);\n\t\t\t\t\tif (no_quota < 0) {\n\t\t\t\t\t\tbtrfs_abort_transaction(trans,\n\t\t\t\t\t\t\t\t\troot,\n\t\t\t\t\t\t\t\t\tret);\n\t\t\t\t\t\tbtrfs_end_transaction(trans,\n\t\t\t\t\t\t\t\t      root);\n\t\t\t\t\t\tret = no_quota;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (disko) {\n\t\t\t\t\tinode_add_bytes(inode, datal);\n\t\t\t\t\tret = btrfs_inc_extent_ref(trans, root,\n\t\t\t\t\t\t\tdisko, diskl, 0,\n\t\t\t\t\t\t\troot->root_key.objectid,\n\t\t\t\t\t\t\tbtrfs_ino(inode),\n\t\t\t\t\t\t\tnew_key.offset - datao,\n\t\t\t\t\t\t\tno_quota);\n\t\t\t\t\tif (ret) {\n\t\t\t\t\t\tbtrfs_abort_transaction(trans,\n\t\t\t\t\t\t\t\t\troot,\n\t\t\t\t\t\t\t\t\tret);\n\t\t\t\t\t\tbtrfs_end_transaction(trans,\n\t\t\t\t\t\t\t\t      root);\n\t\t\t\t\t\tgoto out;\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tu64 skip = 0;\n\t\t\t\tu64 trim = 0;\n\t\t\t\tu64 aligned_end = 0;\n\n\t\t\t\t/*\n\t\t\t\t * Don't copy an inline extent into an offset\n\t\t\t\t * greater than zero. Having an inline extent\n\t\t\t\t * at such an offset results in chaos as btrfs\n\t\t\t\t * isn't prepared for such cases. Just skip\n\t\t\t\t * this case for the same reasons as commented\n\t\t\t\t * at btrfs_ioctl_clone().\n\t\t\t\t */\n\t\t\t\tif (last_dest_end > 0) {\n\t\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tif (off > key.offset) {\n\t\t\t\t\tskip = off - key.offset;\n\t\t\t\t\tnew_key.offset += skip;\n\t\t\t\t}\n\n\t\t\t\tif (key.offset + datal > off + len)\n\t\t\t\t\ttrim = key.offset + datal - (off + len);\n\n\t\t\t\tif (comp && (skip || trim)) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tsize -= skip + trim;\n\t\t\t\tdatal -= skip + trim;\n\n\t\t\t\taligned_end = ALIGN(new_key.offset + datal,\n\t\t\t\t\t\t    root->sectorsize);\n\t\t\t\tret = btrfs_drop_extents(trans, root, inode,\n\t\t\t\t\t\t\t drop_start,\n\t\t\t\t\t\t\t aligned_end,\n\t\t\t\t\t\t\t 1);\n\t\t\t\tif (ret) {\n\t\t\t\t\tif (ret != -EOPNOTSUPP)\n\t\t\t\t\t\tbtrfs_abort_transaction(trans,\n\t\t\t\t\t\t\troot, ret);\n\t\t\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tret = btrfs_insert_empty_item(trans, root, path,\n\t\t\t\t\t\t\t      &new_key, size);\n\t\t\t\tif (ret) {\n\t\t\t\t\tbtrfs_abort_transaction(trans, root,\n\t\t\t\t\t\t\t\tret);\n\t\t\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tif (skip) {\n\t\t\t\t\tu32 start =\n\t\t\t\t\t  btrfs_file_extent_calc_inline_size(0);\n\t\t\t\t\tmemmove(buf+start, buf+start+skip,\n\t\t\t\t\t\tdatal);\n\t\t\t\t}\n\n\t\t\t\tleaf = path->nodes[0];\n\t\t\t\tslot = path->slots[0];\n\t\t\t\twrite_extent_buffer(leaf, buf,\n\t\t\t\t\t    btrfs_item_ptr_offset(leaf, slot),\n\t\t\t\t\t    size);\n\t\t\t\tinode_add_bytes(inode, datal);\n\t\t\t}\n\n\t\t\t/* If we have an implicit hole (NO_HOLES feature). */\n\t\t\tif (drop_start < new_key.offset)\n\t\t\t\tclone_update_extent_map(inode, trans,\n\t\t\t\t\t\tNULL, drop_start,\n\t\t\t\t\t\tnew_key.offset - drop_start);\n\n\t\t\tclone_update_extent_map(inode, trans, path, 0, 0);\n\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t\tbtrfs_release_path(path);\n\n\t\t\tlast_dest_end = ALIGN(new_key.offset + datal,\n\t\t\t\t\t      root->sectorsize);\n\t\t\tret = clone_finish_inode_update(trans, inode,\n\t\t\t\t\t\t\tlast_dest_end,\n\t\t\t\t\t\t\tdestoff, olen,\n\t\t\t\t\t\t\tno_time_update);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tif (new_key.offset + datal >= destoff + len)\n\t\t\t\tbreak;\n\t\t}\n\t\tbtrfs_release_path(path);\n\t\tkey.offset = next_key_min_offset;\n\t}\n\tret = 0;\n\n\tif (last_dest_end < destoff + len) {\n\t\t/*\n\t\t * We have an implicit hole (NO_HOLES feature is enabled) that\n\t\t * fully or partially overlaps our cloning range at its end.\n\t\t */\n\t\tbtrfs_release_path(path);\n\n\t\t/*\n\t\t * 1 - remove extent(s)\n\t\t * 1 - inode update\n\t\t */\n\t\ttrans = btrfs_start_transaction(root, 2);\n\t\tif (IS_ERR(trans)) {\n\t\t\tret = PTR_ERR(trans);\n\t\t\tgoto out;\n\t\t}\n\t\tret = btrfs_drop_extents(trans, root, inode,\n\t\t\t\t\t last_dest_end, destoff + len, 1);\n\t\tif (ret) {\n\t\t\tif (ret != -EOPNOTSUPP)\n\t\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\tgoto out;\n\t\t}\n\t\tclone_update_extent_map(inode, trans, NULL, last_dest_end,\n\t\t\t\t\tdestoff + len - last_dest_end);\n\t\tret = clone_finish_inode_update(trans, inode, destoff + len,\n\t\t\t\t\t\tdestoff, olen, no_time_update);\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\tvfree(buf);\n\treturn ret;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145436,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int btrfs_clone(struct inode *src, struct inode *inode,\n\t\t       const u64 off, const u64 olen, const u64 olen_aligned,\n\t\t       const u64 destoff, int no_time_update)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_path *path = NULL;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_trans_handle *trans;\n\tchar *buf = NULL;\n\tstruct btrfs_key key;\n\tu32 nritems;\n\tint slot;\n\tint ret;\n\tint no_quota;\n\tconst u64 len = olen_aligned;\n\tu64 last_disko = 0;\n\tu64 last_dest_end = destoff;\n\n\tret = -ENOMEM;\n\tbuf = vmalloc(root->nodesize);\n\tif (!buf)\n\t\treturn ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tvfree(buf);\n\t\treturn ret;\n\t}\n\n\tpath->reada = 2;\n\t/* clone data */\n\tkey.objectid = btrfs_ino(src);\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = off;\n\n\twhile (1) {\n\t\tu64 next_key_min_offset = key.offset + 1;\n\n\t\t/*\n\t\t * note the key will change type as we walk through the\n\t\t * tree.\n\t\t */\n\t\tpath->leave_spinning = 1;\n\t\tret = btrfs_search_slot(NULL, BTRFS_I(src)->root, &key, path,\n\t\t\t\t0, 0);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\t/*\n\t\t * First search, if no extent item that starts at offset off was\n\t\t * found but the previous item is an extent item, it's possible\n\t\t * it might overlap our target range, therefore process it.\n\t\t */\n\t\tif (key.offset == off && ret > 0 && path->slots[0] > 0) {\n\t\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key,\n\t\t\t\t\t      path->slots[0] - 1);\n\t\t\tif (key.type == BTRFS_EXTENT_DATA_KEY)\n\t\t\t\tpath->slots[0]--;\n\t\t}\n\n\t\tnritems = btrfs_header_nritems(path->nodes[0]);\nprocess_slot:\n\t\tno_quota = 1;\n\t\tif (path->slots[0] >= nritems) {\n\t\t\tret = btrfs_next_leaf(BTRFS_I(src)->root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret > 0)\n\t\t\t\tbreak;\n\t\t\tnritems = btrfs_header_nritems(path->nodes[0]);\n\t\t}\n\t\tleaf = path->nodes[0];\n\t\tslot = path->slots[0];\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\t\tif (key.type > BTRFS_EXTENT_DATA_KEY ||\n\t\t    key.objectid != btrfs_ino(src))\n\t\t\tbreak;\n\n\t\tif (key.type == BTRFS_EXTENT_DATA_KEY) {\n\t\t\tstruct btrfs_file_extent_item *extent;\n\t\t\tint type;\n\t\t\tu32 size;\n\t\t\tstruct btrfs_key new_key;\n\t\t\tu64 disko = 0, diskl = 0;\n\t\t\tu64 datao = 0, datal = 0;\n\t\t\tu8 comp;\n\t\t\tu64 drop_start;\n\n\t\t\textent = btrfs_item_ptr(leaf, slot,\n\t\t\t\t\t\tstruct btrfs_file_extent_item);\n\t\t\tcomp = btrfs_file_extent_compression(leaf, extent);\n\t\t\ttype = btrfs_file_extent_type(leaf, extent);\n\t\t\tif (type == BTRFS_FILE_EXTENT_REG ||\n\t\t\t    type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\t\t\tdisko = btrfs_file_extent_disk_bytenr(leaf,\n\t\t\t\t\t\t\t\t      extent);\n\t\t\t\tdiskl = btrfs_file_extent_disk_num_bytes(leaf,\n\t\t\t\t\t\t\t\t extent);\n\t\t\t\tdatao = btrfs_file_extent_offset(leaf, extent);\n\t\t\t\tdatal = btrfs_file_extent_num_bytes(leaf,\n\t\t\t\t\t\t\t\t    extent);\n\t\t\t} else if (type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\t/* take upper bound, may be compressed */\n\t\t\t\tdatal = btrfs_file_extent_ram_bytes(leaf,\n\t\t\t\t\t\t\t\t    extent);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The first search might have left us at an extent\n\t\t\t * item that ends before our target range's start, can\n\t\t\t * happen if we have holes and NO_HOLES feature enabled.\n\t\t\t */\n\t\t\tif (key.offset + datal <= off) {\n\t\t\t\tpath->slots[0]++;\n\t\t\t\tgoto process_slot;\n\t\t\t} else if (key.offset >= off + len) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnext_key_min_offset = key.offset + datal;\n\t\t\tsize = btrfs_item_size_nr(leaf, slot);\n\t\t\tread_extent_buffer(leaf, buf,\n\t\t\t\t\t   btrfs_item_ptr_offset(leaf, slot),\n\t\t\t\t\t   size);\n\n\t\t\tbtrfs_release_path(path);\n\t\t\tpath->leave_spinning = 0;\n\n\t\t\tmemcpy(&new_key, &key, sizeof(new_key));\n\t\t\tnew_key.objectid = btrfs_ino(inode);\n\t\t\tif (off <= key.offset)\n\t\t\t\tnew_key.offset = key.offset + destoff - off;\n\t\t\telse\n\t\t\t\tnew_key.offset = destoff;\n\n\t\t\t/*\n\t\t\t * Deal with a hole that doesn't have an extent item\n\t\t\t * that represents it (NO_HOLES feature enabled).\n\t\t\t * This hole is either in the middle of the cloning\n\t\t\t * range or at the beginning (fully overlaps it or\n\t\t\t * partially overlaps it).\n\t\t\t */\n\t\t\tif (new_key.offset != last_dest_end)\n\t\t\t\tdrop_start = last_dest_end;\n\t\t\telse\n\t\t\t\tdrop_start = new_key.offset;\n\n\t\t\t/*\n\t\t\t * 1 - adjusting old extent (we may have to split it)\n\t\t\t * 1 - add new extent\n\t\t\t * 1 - inode update\n\t\t\t */\n\t\t\ttrans = btrfs_start_transaction(root, 3);\n\t\t\tif (IS_ERR(trans)) {\n\t\t\t\tret = PTR_ERR(trans);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (type == BTRFS_FILE_EXTENT_REG ||\n\t\t\t    type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\t\t\t/*\n\t\t\t\t *    a  | --- range to clone ---|  b\n\t\t\t\t * | ------------- extent ------------- |\n\t\t\t\t */\n\n\t\t\t\t/* subtract range b */\n\t\t\t\tif (key.offset + datal > off + len)\n\t\t\t\t\tdatal = off + len - key.offset;\n\n\t\t\t\t/* subtract range a */\n\t\t\t\tif (off > key.offset) {\n\t\t\t\t\tdatao += off - key.offset;\n\t\t\t\t\tdatal -= off - key.offset;\n\t\t\t\t}\n\n\t\t\t\tret = btrfs_drop_extents(trans, root, inode,\n\t\t\t\t\t\t\t drop_start,\n\t\t\t\t\t\t\t new_key.offset + datal,\n\t\t\t\t\t\t\t 1);\n\t\t\t\tif (ret) {\n\t\t\t\t\tif (ret != -EOPNOTSUPP)\n\t\t\t\t\t\tbtrfs_abort_transaction(trans,\n\t\t\t\t\t\t\t\troot, ret);\n\t\t\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tret = btrfs_insert_empty_item(trans, root, path,\n\t\t\t\t\t\t\t      &new_key, size);\n\t\t\t\tif (ret) {\n\t\t\t\t\tbtrfs_abort_transaction(trans, root,\n\t\t\t\t\t\t\t\tret);\n\t\t\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tleaf = path->nodes[0];\n\t\t\t\tslot = path->slots[0];\n\t\t\t\twrite_extent_buffer(leaf, buf,\n\t\t\t\t\t    btrfs_item_ptr_offset(leaf, slot),\n\t\t\t\t\t    size);\n\n\t\t\t\textent = btrfs_item_ptr(leaf, slot,\n\t\t\t\t\t\tstruct btrfs_file_extent_item);\n\n\t\t\t\t/* disko == 0 means it's a hole */\n\t\t\t\tif (!disko)\n\t\t\t\t\tdatao = 0;\n\n\t\t\t\tbtrfs_set_file_extent_offset(leaf, extent,\n\t\t\t\t\t\t\t     datao);\n\t\t\t\tbtrfs_set_file_extent_num_bytes(leaf, extent,\n\t\t\t\t\t\t\t\tdatal);\n\n\t\t\t\t/*\n\t\t\t\t * We need to look up the roots that point at\n\t\t\t\t * this bytenr and see if the new root does.  If\n\t\t\t\t * it does not we need to make sure we update\n\t\t\t\t * quotas appropriately.\n\t\t\t\t */\n\t\t\t\tif (disko && root != BTRFS_I(src)->root &&\n\t\t\t\t    disko != last_disko) {\n\t\t\t\t\tno_quota = check_ref(trans, root,\n\t\t\t\t\t\t\t     disko);\n\t\t\t\t\tif (no_quota < 0) {\n\t\t\t\t\t\tbtrfs_abort_transaction(trans,\n\t\t\t\t\t\t\t\t\troot,\n\t\t\t\t\t\t\t\t\tret);\n\t\t\t\t\t\tbtrfs_end_transaction(trans,\n\t\t\t\t\t\t\t\t      root);\n\t\t\t\t\t\tret = no_quota;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (disko) {\n\t\t\t\t\tinode_add_bytes(inode, datal);\n\t\t\t\t\tret = btrfs_inc_extent_ref(trans, root,\n\t\t\t\t\t\t\tdisko, diskl, 0,\n\t\t\t\t\t\t\troot->root_key.objectid,\n\t\t\t\t\t\t\tbtrfs_ino(inode),\n\t\t\t\t\t\t\tnew_key.offset - datao,\n\t\t\t\t\t\t\tno_quota);\n\t\t\t\t\tif (ret) {\n\t\t\t\t\t\tbtrfs_abort_transaction(trans,\n\t\t\t\t\t\t\t\t\troot,\n\t\t\t\t\t\t\t\t\tret);\n\t\t\t\t\t\tbtrfs_end_transaction(trans,\n\t\t\t\t\t\t\t\t      root);\n\t\t\t\t\t\tgoto out;\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tu64 skip = 0;\n\t\t\t\tu64 trim = 0;\n\n\t\t\t\tif (off > key.offset) {\n\t\t\t\t\tskip = off - key.offset;\n\t\t\t\t\tnew_key.offset += skip;\n\t\t\t\t}\n\n\t\t\t\tif (key.offset + datal > off + len)\n\t\t\t\t\ttrim = key.offset + datal - (off + len);\n\n\t\t\t\tif (comp && (skip || trim)) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tsize -= skip + trim;\n\t\t\t\tdatal -= skip + trim;\n\n\t\t\t\tret = clone_copy_inline_extent(src, inode,\n\t\t\t\t\t\t\t       trans, path,\n\t\t\t\t\t\t\t       &new_key,\n\t\t\t\t\t\t\t       drop_start,\n\t\t\t\t\t\t\t       datal,\n\t\t\t\t\t\t\t       skip, size, buf);\n\t\t\t\tif (ret) {\n\t\t\t\t\tif (ret != -EOPNOTSUPP)\n\t\t\t\t\t\tbtrfs_abort_transaction(trans,\n\t\t\t\t\t\t\t\t\troot,\n\t\t\t\t\t\t\t\t\tret);\n\t\t\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tleaf = path->nodes[0];\n\t\t\t\tslot = path->slots[0];\n\t\t\t}\n\n\t\t\t/* If we have an implicit hole (NO_HOLES feature). */\n\t\t\tif (drop_start < new_key.offset)\n\t\t\t\tclone_update_extent_map(inode, trans,\n\t\t\t\t\t\tNULL, drop_start,\n\t\t\t\t\t\tnew_key.offset - drop_start);\n\n\t\t\tclone_update_extent_map(inode, trans, path, 0, 0);\n\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t\tbtrfs_release_path(path);\n\n\t\t\tlast_dest_end = ALIGN(new_key.offset + datal,\n\t\t\t\t\t      root->sectorsize);\n\t\t\tret = clone_finish_inode_update(trans, inode,\n\t\t\t\t\t\t\tlast_dest_end,\n\t\t\t\t\t\t\tdestoff, olen,\n\t\t\t\t\t\t\tno_time_update);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tif (new_key.offset + datal >= destoff + len)\n\t\t\t\tbreak;\n\t\t}\n\t\tbtrfs_release_path(path);\n\t\tkey.offset = next_key_min_offset;\n\t}\n\tret = 0;\n\n\tif (last_dest_end < destoff + len) {\n\t\t/*\n\t\t * We have an implicit hole (NO_HOLES feature is enabled) that\n\t\t * fully or partially overlaps our cloning range at its end.\n\t\t */\n\t\tbtrfs_release_path(path);\n\n\t\t/*\n\t\t * 1 - remove extent(s)\n\t\t * 1 - inode update\n\t\t */\n\t\ttrans = btrfs_start_transaction(root, 2);\n\t\tif (IS_ERR(trans)) {\n\t\t\tret = PTR_ERR(trans);\n\t\t\tgoto out;\n\t\t}\n\t\tret = btrfs_drop_extents(trans, root, inode,\n\t\t\t\t\t last_dest_end, destoff + len, 1);\n\t\tif (ret) {\n\t\t\tif (ret != -EOPNOTSUPP)\n\t\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\tgoto out;\n\t\t}\n\t\tclone_update_extent_map(inode, trans, NULL, last_dest_end,\n\t\t\t\t\tdestoff + len - last_dest_end);\n\t\tret = clone_finish_inode_update(trans, inode, destoff + len,\n\t\t\t\t\t\tdestoff, olen, no_time_update);\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\tvfree(buf);\n\treturn ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145437,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "Try<JWT, JWTError> JWT::parse(const string& token, const string& secret)\n{\n  const vector<string> components = strings::split(token, \".\");\n\n  if (components.size() != 3) {\n    return JWTError(\n        \"Expected 3 components in token, got \" + stringify(components.size()),\n        JWTError::Type::INVALID_TOKEN);\n  }\n\n  Try<JWT::Header> header = parse_header(components[0]);\n\n  if (header.isError()) {\n    return JWTError(header.error(), JWTError::Type::INVALID_TOKEN);\n  }\n\n  if (header->alg != JWT::Alg::HS256) {\n    return JWTError(\n        \"Token 'alg' value \\\"\" + stringify(header->alg) +\n        \"\\\" does not match, expected \\\"HS256\\\"\",\n        JWTError::Type::INVALID_TOKEN);\n  }\n\n  Try<JSON::Object> payload = parse_payload(components[1]);\n\n  if (payload.isError()) {\n    return JWTError(payload.error(), JWTError::Type::INVALID_TOKEN);\n  }\n\n  const Try<string> signature = base64::decode_url_safe(components[2]);\n\n  if (signature.isError()) {\n    return JWTError(\n        \"Failed to base64url-decode token signature: \" + signature.error(),\n        JWTError::Type::INVALID_TOKEN);\n  }\n\n  // Validate HMAC SHA256 signature.\n\n  Try<string> hmac = generate_hmac_sha256(\n      components[0] + \".\" + components[1],\n      secret);\n\n  if (hmac.isError()) {\n    return JWTError(\n        \"Failed to generate HMAC signature: \" + hmac.error(),\n        JWTError::Type::UNKNOWN);\n  }\n\n  const bool valid = hmac.get() == signature.get();\n\n  if (!valid) {\n    return JWTError(\n        \"Token signature does not match\",\n        JWTError::Type::INVALID_TOKEN);\n  }\n\n  return JWT(header.get(), payload.get(), signature.get());\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145444,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "Try<JWT, JWTError> JWT::parse(const string& token, const string& secret)\n{\n  const vector<string> components = strings::split(token, \".\");\n\n  if (components.size() != 3) {\n    return JWTError(\n        \"Expected 3 components in token, got \" + stringify(components.size()),\n        JWTError::Type::INVALID_TOKEN);\n  }\n\n  Try<JWT::Header> header = parse_header(components[0]);\n\n  if (header.isError()) {\n    return JWTError(header.error(), JWTError::Type::INVALID_TOKEN);\n  }\n\n  if (header->alg != JWT::Alg::HS256) {\n    return JWTError(\n        \"Token 'alg' value \\\"\" + stringify(header->alg) +\n        \"\\\" does not match, expected \\\"HS256\\\"\",\n        JWTError::Type::INVALID_TOKEN);\n  }\n\n  Try<JSON::Object> payload = parse_payload(components[1]);\n\n  if (payload.isError()) {\n    return JWTError(payload.error(), JWTError::Type::INVALID_TOKEN);\n  }\n\n  const Try<string> signature = base64::decode_url_safe(components[2]);\n\n  if (signature.isError()) {\n    return JWTError(\n        \"Failed to base64url-decode token signature: \" + signature.error(),\n        JWTError::Type::INVALID_TOKEN);\n  }\n\n  // Validate HMAC SHA256 signature.\n\n  Try<string> hmac = generate_hmac_sha256(\n      components[0] + \".\" + components[1],\n      secret);\n\n  if (hmac.isError()) {\n    return JWTError(\n        \"Failed to generate HMAC signature: \" + hmac.error(),\n        JWTError::Type::UNKNOWN);\n  }\n\n  if (!constantTimeEquals(hmac.get(), signature.get())) {\n    return JWTError(\n        \"Token signature does not match\",\n        JWTError::Type::INVALID_TOKEN);\n  }\n\n  return JWT(header.get(), payload.get(), signature.get());\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145445,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "ReadNextFunctionHandle(mat_t *mat, matvar_t *matvar)\n{\n    int err;\n    size_t nelems = 1;\n\n    err = Mat_MulDims(matvar, &nelems);\n    matvar->data_size = sizeof(matvar_t *);\n    err |= Mul(&matvar->nbytes, nelems, matvar->data_size);\n    if ( err )\n        return 0;\n\n    matvar->data = malloc(matvar->nbytes);\n    if ( matvar->data != NULL ) {\n        size_t i;\n        matvar_t **functions = (matvar_t **)matvar->data;\n        for ( i = 0; i < nelems; i++ ) {\n            functions[i] = Mat_VarReadNextInfo(mat);\n            err = NULL == functions[i];\n            if ( err )\n                break;\n        }\n        if ( err ) {\n            free(matvar->data);\n            matvar->data = NULL;\n            matvar->data_size = 0;\n            matvar->nbytes = 0;\n        }\n    } else {\n        matvar->data_size = 0;\n        matvar->nbytes = 0;\n    }\n\n    return 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145520,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "ReadNextFunctionHandle(mat_t *mat, matvar_t *matvar)\n{\n    int err;\n    size_t nelems = 1;\n\n    err = Mat_MulDims(matvar, &nelems);\n    matvar->data_size = sizeof(matvar_t *);\n    err |= Mul(&matvar->nbytes, nelems, matvar->data_size);\n    if ( err )\n        return 0;\n\n    matvar->data = malloc(matvar->nbytes);\n    if ( matvar->data != NULL ) {\n        size_t i;\n        matvar_t **functions = (matvar_t **)matvar->data;\n        for ( i = 0; i < nelems; i++ ) {\n            functions[i] = Mat_VarReadNextInfo(mat);\n            err = NULL == functions[i];\n            if ( err )\n                break;\n        }\n        if ( err ) {\n            size_t j;\n            for ( j = 0; j < i; j++ ) {\n                free(functions[j]);\n            }\n            free(matvar->data);\n            matvar->data = NULL;\n            matvar->data_size = 0;\n            matvar->nbytes = 0;\n        }\n    } else {\n        matvar->data_size = 0;\n        matvar->nbytes = 0;\n    }\n\n    return 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145521,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "std::string get_wml_location(const std::string &filename, const std::string &current_dir)\n{\n\tDBG_FS << \"Looking for '\" << filename << \"'.\\n\";\n\n\tstd::string result;\n\n\tif (filename.empty()) {\n\t\tLOG_FS << \"  invalid filename\\n\";\n\t\treturn result;\n\t}\n\n\tif (filename.find(\"..\") != std::string::npos) {\n\t\tERR_FS << \"Illegal path '\" << filename << \"' (\\\"..\\\" not allowed).\\n\";\n\t\treturn result;\n\t}\n\n\tbool already_found = false;\n\n\tif (filename[0] == '~')\n\t{\n\t\t// If the filename starts with '~', look in the user data directory.\n\t\tresult = get_user_data_dir() + \"/data/\" + filename.substr(1);\n\t\tDBG_FS << \"  trying '\" << result << \"'\\n\";\n\n\t\talready_found = file_exists(result) || is_directory(result);\n\t}\n\telse if (filename.size() >= 2 && filename[0] == '.' && filename[1] == '/')\n\t{\n\t\t// If the filename begins with a \"./\", look in the same directory\n\t\t// as the file currrently being preprocessed.\n\t\tresult = current_dir + filename.substr(2);\n\t}\n\telse if (!game_config::path.empty())\n\t\tresult = game_config::path + \"/data/\" + filename;\n\n\tDBG_FS << \"  trying '\" << result << \"'\\n\";\n\n\tif (result.empty() ||\n\t    (!already_found && !file_exists(result) && !is_directory(result)))\n\t{\n\t\tDBG_FS << \"  not found\\n\";\n\t\tresult.clear();\n\t}\n\telse\n\t\tDBG_FS << \"  found: '\" << result << \"'\\n\";\n\n\treturn result;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145584,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "std::string get_wml_location(const std::string &filename, const std::string &current_dir)\n{\n\tDBG_FS << \"Looking for '\" << filename << \"'.\\n\";\n\n\tstd::string result;\n\n\tif (filename.empty()) {\n\t\tLOG_FS << \"  invalid filename\\n\";\n\t\treturn result;\n\t}\n\n\tif (filename.find(\"..\") != std::string::npos) {\n\t\tERR_FS << \"Illegal path '\" << filename << \"' (\\\"..\\\" not allowed).\\n\";\n\t\treturn result;\n\t}\n\n\tbool already_found = false;\n\n\tif (filename[0] == '~')\n\t{\n\t\t// If the filename starts with '~', look in the user data directory.\n\t\tresult = get_user_data_dir() + \"/data/\" + filename.substr(1);\n\t\tDBG_FS << \"  trying '\" << result << \"'\\n\";\n\n\t\talready_found = file_exists(result) || is_directory(result);\n\t}\n\telse if (filename.size() >= 2 && filename[0] == '.' && filename[1] == '/')\n\t{\n\t\t// If the filename begins with a \"./\", look in the same directory\n\t\t// as the file currently being preprocessed.\n\n\t\tif (!current_dir.empty())\n\t\t{\n\t\t\tresult = current_dir;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = game_config::path;\n\t\t}\n\n\t\tresult += filename.substr(2);\n\t}\n\telse if (!game_config::path.empty())\n\t\tresult = game_config::path + \"/data/\" + filename;\n\n\tDBG_FS << \"  trying '\" << result << \"'\\n\";\n\n\tif (result.empty() ||\n\t    (!already_found && !file_exists(result) && !is_directory(result)))\n\t{\n\t\tDBG_FS << \"  not found\\n\";\n\t\tresult.clear();\n\t}\n\telse\n\t\tDBG_FS << \"  found: '\" << result << \"'\\n\";\n\n\treturn result;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145585,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int acpi_smbus_hc_add(struct acpi_device *device)\n{\n\tint status;\n\tunsigned long long val;\n\tstruct acpi_smb_hc *hc;\n\n\tif (!device)\n\t\treturn -EINVAL;\n\n\tstatus = acpi_evaluate_integer(device->handle, \"_EC\", NULL, &val);\n\tif (ACPI_FAILURE(status)) {\n\t\tprintk(KERN_ERR PREFIX \"error obtaining _EC.\\n\");\n\t\treturn -EIO;\n\t}\n\n\tstrcpy(acpi_device_name(device), ACPI_SMB_HC_DEVICE_NAME);\n\tstrcpy(acpi_device_class(device), ACPI_SMB_HC_CLASS);\n\n\thc = kzalloc(sizeof(struct acpi_smb_hc), GFP_KERNEL);\n\tif (!hc)\n\t\treturn -ENOMEM;\n\tmutex_init(&hc->lock);\n\tinit_waitqueue_head(&hc->wait);\n\n\thc->ec = acpi_driver_data(device->parent);\n\thc->offset = (val >> 8) & 0xff;\n\thc->query_bit = val & 0xff;\n\tdevice->driver_data = hc;\n\n\tacpi_ec_add_query_handler(hc->ec, hc->query_bit, NULL, smbus_alarm, hc);\n\tprintk(KERN_INFO PREFIX \"SBS HC: EC = 0x%p, offset = 0x%0x, query_bit = 0x%0x\\n\",\n\t\thc->ec, hc->offset, hc->query_bit);\n\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145592,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int acpi_smbus_hc_add(struct acpi_device *device)\n{\n\tint status;\n\tunsigned long long val;\n\tstruct acpi_smb_hc *hc;\n\n\tif (!device)\n\t\treturn -EINVAL;\n\n\tstatus = acpi_evaluate_integer(device->handle, \"_EC\", NULL, &val);\n\tif (ACPI_FAILURE(status)) {\n\t\tprintk(KERN_ERR PREFIX \"error obtaining _EC.\\n\");\n\t\treturn -EIO;\n\t}\n\n\tstrcpy(acpi_device_name(device), ACPI_SMB_HC_DEVICE_NAME);\n\tstrcpy(acpi_device_class(device), ACPI_SMB_HC_CLASS);\n\n\thc = kzalloc(sizeof(struct acpi_smb_hc), GFP_KERNEL);\n\tif (!hc)\n\t\treturn -ENOMEM;\n\tmutex_init(&hc->lock);\n\tinit_waitqueue_head(&hc->wait);\n\n\thc->ec = acpi_driver_data(device->parent);\n\thc->offset = (val >> 8) & 0xff;\n\thc->query_bit = val & 0xff;\n\tdevice->driver_data = hc;\n\n\tacpi_ec_add_query_handler(hc->ec, hc->query_bit, NULL, smbus_alarm, hc);\n\tdev_info(&device->dev, \"SBS HC: offset = 0x%0x, query_bit = 0x%0x\\n\",\n\t\t hc->offset, hc->query_bit);\n\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145593,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int Adapter_output(AdapterObject *self, const char *data, int length,\n                          int exception_when_aborted)\n{\n    int i = 0;\n    int n = 0;\n    apr_status_t rv;\n    request_rec *r;\n\n#if defined(MOD_WSGI_WITH_DAEMONS)\n    if (wsgi_inactivity_timeout) {\n        apr_thread_mutex_lock(wsgi_shutdown_lock);\n        wsgi_inactivity_shutdown_time = apr_time_now();\n        wsgi_inactivity_shutdown_time += wsgi_inactivity_timeout;\n        apr_thread_mutex_unlock(wsgi_shutdown_lock);\n    }\n#endif\n\n    if (!self->status_line) {\n        PyErr_SetString(PyExc_RuntimeError, \"response has not been started\");\n        return 0;\n    }\n\n    r = self->r;\n\n    /* Have response headers yet been sent. */\n\n    if (self->headers) {\n        /*\n         * Apache prior to Apache 2.2.8 has a bug in it\n         * whereby it doesn't force '100 Continue'\n         * response before responding with headers if no\n         * read. So, force a zero length read before\n         * sending the headers if haven't yet attempted\n         * to read anything. This will ensure that if no\n         * request content has been read that any '100\n         * Continue' response will be flushed and sent\n         * back to the client if client was expecting\n         * one. Only want to do this for 2xx and 3xx\n         * status values. Note that even though Apple\n         * supplied version of Apache on MacOS X Leopard\n         * is newer than version 2.2.8, the header file\n         * has never been patched when they make updates\n         * and so anything compiled against it thinks it\n         * is older.\n         */\n\n#if (AP_SERVER_MAJORVERSION_NUMBER == 1) || \\\n    (AP_SERVER_MAJORVERSION_NUMBER == 2 && \\\n     AP_SERVER_MINORVERSION_NUMBER < 2) || \\\n    (AP_SERVER_MAJORVERSION_NUMBER == 2 && \\\n     AP_SERVER_MINORVERSION_NUMBER == 2 && \\\n     AP_SERVER_PATCHLEVEL_NUMBER < 8)\n\n        if (!self->input->init) {\n            if (self->status >= 200 && self->status < 400) {\n                PyObject *args = NULL;\n                PyObject *result = NULL;\n                args = Py_BuildValue(\"(i)\", 0);\n                result = Input_read(self->input, args);\n                if (PyErr_Occurred())\n                    PyErr_Clear();\n                Py_DECREF(args);\n                Py_XDECREF(result);\n            }\n        }\n\n#endif\n\n        /* Now setup response headers in request object. */\n\n        r->status = self->status;\n        r->status_line = self->status_line;\n\n        for (i = 0; i < PyList_Size(self->headers); i++) {\n            PyObject *tuple = NULL;\n\n            PyObject *object1 = NULL;\n            PyObject *object2 = NULL;\n\n            char *name = NULL;\n            char *value = NULL;\n\n            tuple = PyList_GetItem(self->headers, i);\n\n            if (!PyTuple_Check(tuple)) {\n                PyErr_Format(PyExc_TypeError, \"list of tuple values \"\n                             \"expected, value of type %.200s found\",\n                             tuple->ob_type->tp_name);\n                return 0;\n            }\n\n            if (PyTuple_Size(tuple) != 2) {\n                PyErr_Format(PyExc_ValueError, \"tuple of length 2 \"\n                             \"expected, length is %d\",\n                             (int)PyTuple_Size(tuple));\n                return 0;\n            }\n\n            object1 = PyTuple_GetItem(tuple, 0);\n            object2 = PyTuple_GetItem(tuple, 1);\n\n            if (PyString_Check(object1)) {\n                name = PyString_AsString(object1);\n            }\n#if PY_MAJOR_VERSION >= 3\n            else if (PyUnicode_Check(object1)) {\n                PyObject *latin_object;\n                latin_object = PyUnicode_AsLatin1String(object1);\n                if (!latin_object) {\n                    PyErr_Format(PyExc_TypeError, \"header name \"\n                                 \"contained non 'latin-1' characters \");\n                    return 0;\n                }\n\n                name = apr_pstrdup(r->pool, PyString_AsString(latin_object));\n                Py_DECREF(latin_object);\n            }\n#endif\n            else {\n                PyErr_Format(PyExc_TypeError, \"expected byte string object \"\n                             \"for header name, value of type %.200s \"\n                             \"found\", object1->ob_type->tp_name);\n                return 0;\n            }\n\n            if (PyString_Check(object2)) {\n                value = PyString_AsString(object2);\n            }\n#if PY_MAJOR_VERSION >= 3\n            else if (PyUnicode_Check(object2)) {\n                PyObject *latin_object;\n                latin_object = PyUnicode_AsLatin1String(object2);\n                if (!latin_object) {\n                    PyErr_Format(PyExc_TypeError, \"header value \"\n                                 \"contained non 'latin-1' characters \");\n                    return 0;\n                }\n\n                value = apr_pstrdup(r->pool, PyString_AsString(latin_object));\n                Py_DECREF(latin_object);\n            }\n#endif\n            else {\n                PyErr_Format(PyExc_TypeError, \"expected byte string object \"\n                             \"for header value, value of type %.200s \"\n                             \"found\", object2->ob_type->tp_name);\n                return 0;\n            }\n\n            if (strchr(name, '\\n') != 0 || strchr(value, '\\n') != 0) {\n                PyErr_Format(PyExc_ValueError, \"embedded newline in \"\n                             \"response header with name '%s' and value '%s'\",\n                             name, value);\n                return 0;\n            }\n\n            if (!strcasecmp(name, \"Content-Type\")) {\n#if AP_SERVER_MAJORVERSION_NUMBER < 2\n                r->content_type = apr_pstrdup(r->pool, value);\n#else\n                /*\n                 * In a daemon child process we cannot call the\n                 * function ap_set_content_type() as want to\n                 * avoid adding any output filters based on the\n                 * type of file being served as this will be\n                 * done in the main Apache child process which\n                 * proxied the request to the daemon process.\n                 */\n\n                if (*self->config->process_group)\n                    r->content_type = apr_pstrdup(r->pool, value);\n                else\n                    ap_set_content_type(r, value);\n#endif\n            }\n            else if (!strcasecmp(name, \"Content-Length\")) {\n                char *v = value;\n                long l = 0;\n\n                errno = 0;\n                l = strtol(v, &v, 10);\n                if (*v || errno == ERANGE || l < 0) {\n                    PyErr_SetString(PyExc_ValueError,\n                                    \"invalid content length\");\n                    return 0;\n                }\n\n                ap_set_content_length(r, l);\n\n                self->content_length_set = 1;\n                self->content_length = l;\n            }\n            else if (!strcasecmp(name, \"WWW-Authenticate\")) {\n                apr_table_add(r->err_headers_out, name, value);\n            }\n            else {\n                apr_table_add(r->headers_out, name, value);\n            }\n        }\n\n        /* Need to force output of headers when using Apache 1.3. */\n\n        Py_BEGIN_ALLOW_THREADS\n        ap_send_http_header(r);\n        Py_END_ALLOW_THREADS\n\n        /*\n         * Reset flag indicating whether '100 Continue' response\n         * expected. If we don't do this then if an attempt to read\n         * input for the first time is after headers have been\n         * sent, then Apache is wrongly generate the '100 Continue'\n         * response into the response content. Not sure if this is\n         * a bug in Apache, or that it truly believes that input\n         * will never be read after the response headers have been\n         * sent.\n         */\n\n        r->expecting_100 = 0;\n\n        /* No longer need headers now that they have been sent. */\n\n        Py_DECREF(self->headers);\n        self->headers = NULL;\n    }\n\n    /*\n     * If content length was specified, ensure that we don't\n     * actually output more data than was specified as being\n     * sent as otherwise technically in violation of HTTP RFC.\n     */\n\n    if (length) {\n        int output_length = length;\n\n        if (self->content_length_set) {\n            if (self->output_length < self->content_length) {\n                if (self->output_length + length > self->content_length) {\n                    length = self->content_length - self->output_length;\n                }\n            }\n            else\n                length = 0;\n        }\n\n        self->output_length += output_length;\n    }\n\n    /* Now output any data. */\n\n    if (length) {\n#if defined(MOD_WSGI_WITH_BUCKETS)\n        apr_bucket *b;\n\n        /*\n         * When using Apache 2.X can use lower level\n         * bucket brigade APIs. This is preferred as\n         * ap_rwrite()/ap_rflush() will grow memory in\n         * the request pool on each call, which will\n         * result in an increase in memory use over time\n         * when streaming of data is being performed.\n         * The memory is still reclaimed, but only at\n         * the end of the request. Using bucket brigade\n         * API avoids this, and also avoids any copying\n         * of response data due to buffering performed\n         * by ap_rwrite().\n         */\n\n        if (r->connection->aborted) {\n            if (!exception_when_aborted) {\n                ap_log_rerror(APLOG_MARK, WSGI_LOG_DEBUG(0), self->r,\n                              \"mod_wsgi (pid=%d): Client closed connection.\",\n                              getpid());\n            }\n            else\n                PyErr_SetString(PyExc_IOError, \"client connection closed\");\n\n            return 0;\n        }\n\n        if (!self->bb) {\n            self->bb = apr_brigade_create(r->pool,\n                                          r->connection->bucket_alloc);\n        }\n\n        b = apr_bucket_transient_create(data, length,\n                                        r->connection->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(self->bb, b);\n\n        b = apr_bucket_flush_create(r->connection->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(self->bb, b);\n\n        Py_BEGIN_ALLOW_THREADS\n        rv = ap_pass_brigade(r->output_filters, self->bb);\n        Py_END_ALLOW_THREADS\n\n        if (rv != APR_SUCCESS) {\n            PyErr_SetString(PyExc_IOError, \"failed to write data\");\n            return 0;\n        }\n\n        Py_BEGIN_ALLOW_THREADS\n        apr_brigade_cleanup(self->bb);\n        Py_END_ALLOW_THREADS\n#else\n        /*\n         * In Apache 1.3, the bucket brigade system doesn't exist,\n         * so have no choice but to use ap_rwrite()/ap_rflush().\n         * It is not believed that Apache 1.3 suffers the memory\n         * accumulation problem when streaming lots of data.\n         */\n\n        Py_BEGIN_ALLOW_THREADS\n        n = ap_rwrite(data, length, r);\n        Py_END_ALLOW_THREADS\n\n        if (n == -1) {\n            PyErr_SetString(PyExc_IOError, \"failed to write data\");\n            return 0;\n        }\n\n        Py_BEGIN_ALLOW_THREADS\n        n = ap_rflush(r);\n        Py_END_ALLOW_THREADS\n\n        if (n == -1) {\n            PyErr_SetString(PyExc_IOError, \"failed to flush data\");\n            return 0;\n        }\n#endif\n    }\n\n    /*\n     * Check whether aborted connection was found when data\n     * being written, otherwise will not be flagged until next\n     * time that data is being written. Early detection is\n     * better as it may have been the last data block being\n     * written and application may think that data has all\n     * been written. In a streaming application, we also want\n     * to avoid any additional data processing to generate any\n     * successive data.\n     */\n\n    if (r->connection->aborted) {\n        if (!exception_when_aborted) {\n            ap_log_rerror(APLOG_MARK, WSGI_LOG_DEBUG(0), self->r,\n                          \"mod_wsgi (pid=%d): Client closed connection.\",\n                          getpid());\n        }\n        else\n            PyErr_SetString(PyExc_IOError, \"client connection closed\");\n\n        return 0;\n    }\n\n    return 1;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145622,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int Adapter_output(AdapterObject *self, const char *data, int length,\n                          int exception_when_aborted)\n{\n    int i = 0;\n    int n = 0;\n    apr_status_t rv;\n    request_rec *r;\n\n#if defined(MOD_WSGI_WITH_DAEMONS)\n    if (wsgi_inactivity_timeout) {\n        apr_thread_mutex_lock(wsgi_shutdown_lock);\n        wsgi_inactivity_shutdown_time = apr_time_now();\n        wsgi_inactivity_shutdown_time += wsgi_inactivity_timeout;\n        apr_thread_mutex_unlock(wsgi_shutdown_lock);\n    }\n#endif\n\n    if (!self->status_line) {\n        PyErr_SetString(PyExc_RuntimeError, \"response has not been started\");\n        return 0;\n    }\n\n    r = self->r;\n\n    /* Have response headers yet been sent. */\n\n    if (self->headers) {\n        /*\n         * Apache prior to Apache 2.2.8 has a bug in it\n         * whereby it doesn't force '100 Continue'\n         * response before responding with headers if no\n         * read. So, force a zero length read before\n         * sending the headers if haven't yet attempted\n         * to read anything. This will ensure that if no\n         * request content has been read that any '100\n         * Continue' response will be flushed and sent\n         * back to the client if client was expecting\n         * one. Only want to do this for 2xx and 3xx\n         * status values. Note that even though Apple\n         * supplied version of Apache on MacOS X Leopard\n         * is newer than version 2.2.8, the header file\n         * has never been patched when they make updates\n         * and so anything compiled against it thinks it\n         * is older.\n         */\n\n#if (AP_SERVER_MAJORVERSION_NUMBER == 1) || \\\n    (AP_SERVER_MAJORVERSION_NUMBER == 2 && \\\n     AP_SERVER_MINORVERSION_NUMBER < 2) || \\\n    (AP_SERVER_MAJORVERSION_NUMBER == 2 && \\\n     AP_SERVER_MINORVERSION_NUMBER == 2 && \\\n     AP_SERVER_PATCHLEVEL_NUMBER < 8)\n\n        if (!self->input->init) {\n            if (self->status >= 200 && self->status < 400) {\n                PyObject *args = NULL;\n                PyObject *result = NULL;\n                args = Py_BuildValue(\"(i)\", 0);\n                result = Input_read(self->input, args);\n                if (PyErr_Occurred())\n                    PyErr_Clear();\n                Py_DECREF(args);\n                Py_XDECREF(result);\n            }\n        }\n\n#endif\n\n        /* Now setup response headers in request object. */\n\n        r->status = self->status;\n        r->status_line = self->status_line;\n\n        for (i = 0; i < PyList_Size(self->headers); i++) {\n            PyObject *tuple = NULL;\n\n            PyObject *object1 = NULL;\n            PyObject *object2 = NULL;\n\n            char *name = NULL;\n            char *value = NULL;\n\n            tuple = PyList_GetItem(self->headers, i);\n\n            if (!PyTuple_Check(tuple)) {\n                PyErr_Format(PyExc_TypeError, \"list of tuple values \"\n                             \"expected, value of type %.200s found\",\n                             tuple->ob_type->tp_name);\n                return 0;\n            }\n\n            if (PyTuple_Size(tuple) != 2) {\n                PyErr_Format(PyExc_ValueError, \"tuple of length 2 \"\n                             \"expected, length is %d\",\n                             (int)PyTuple_Size(tuple));\n                return 0;\n            }\n\n            object1 = PyTuple_GetItem(tuple, 0);\n            object2 = PyTuple_GetItem(tuple, 1);\n\n            if (PyString_Check(object1)) {\n                name = PyString_AsString(object1);\n            }\n#if PY_MAJOR_VERSION >= 3\n            else if (PyUnicode_Check(object1)) {\n                PyObject *latin_object;\n                latin_object = PyUnicode_AsLatin1String(object1);\n                if (!latin_object) {\n                    PyErr_Format(PyExc_TypeError, \"header name \"\n                                 \"contained non 'latin-1' characters \");\n                    return 0;\n                }\n\n                name = apr_pstrdup(r->pool, PyString_AsString(latin_object));\n                Py_DECREF(latin_object);\n            }\n#endif\n            else {\n                PyErr_Format(PyExc_TypeError, \"expected byte string object \"\n                             \"for header name, value of type %.200s \"\n                             \"found\", object1->ob_type->tp_name);\n                return 0;\n            }\n\n            if (PyString_Check(object2)) {\n                value = PyString_AsString(object2);\n            }\n#if PY_MAJOR_VERSION >= 3\n            else if (PyUnicode_Check(object2)) {\n                PyObject *latin_object;\n                latin_object = PyUnicode_AsLatin1String(object2);\n                if (!latin_object) {\n                    PyErr_Format(PyExc_TypeError, \"header value \"\n                                 \"contained non 'latin-1' characters \");\n                    return 0;\n                }\n\n                value = apr_pstrdup(r->pool, PyString_AsString(latin_object));\n                Py_DECREF(latin_object);\n            }\n#endif\n            else {\n                PyErr_Format(PyExc_TypeError, \"expected byte string object \"\n                             \"for header value, value of type %.200s \"\n                             \"found\", object2->ob_type->tp_name);\n                return 0;\n            }\n\n            if (strchr(name, '\\n') != 0 || strchr(value, '\\n') != 0) {\n                PyErr_Format(PyExc_ValueError, \"embedded newline in \"\n                             \"response header with name '%s' and value '%s'\",\n                             name, value);\n                return 0;\n            }\n\n            if (!strcasecmp(name, \"Content-Type\")) {\n#if AP_SERVER_MAJORVERSION_NUMBER < 2\n                r->content_type = apr_pstrdup(r->pool, value);\n#else\n                /*\n                 * In a daemon child process we cannot call the\n                 * function ap_set_content_type() as want to\n                 * avoid adding any output filters based on the\n                 * type of file being served as this will be\n                 * done in the main Apache child process which\n                 * proxied the request to the daemon process.\n                 */\n\n                if (*self->config->process_group)\n                    r->content_type = apr_pstrdup(r->pool, value);\n                else\n                    ap_set_content_type(r, apr_pstrdup(r->pool, value));\n#endif\n            }\n            else if (!strcasecmp(name, \"Content-Length\")) {\n                char *v = value;\n                long l = 0;\n\n                errno = 0;\n                l = strtol(v, &v, 10);\n                if (*v || errno == ERANGE || l < 0) {\n                    PyErr_SetString(PyExc_ValueError,\n                                    \"invalid content length\");\n                    return 0;\n                }\n\n                ap_set_content_length(r, l);\n\n                self->content_length_set = 1;\n                self->content_length = l;\n            }\n            else if (!strcasecmp(name, \"WWW-Authenticate\")) {\n                apr_table_add(r->err_headers_out, name, value);\n            }\n            else {\n                apr_table_add(r->headers_out, name, value);\n            }\n        }\n\n        /* Need to force output of headers when using Apache 1.3. */\n\n        Py_BEGIN_ALLOW_THREADS\n        ap_send_http_header(r);\n        Py_END_ALLOW_THREADS\n\n        /*\n         * Reset flag indicating whether '100 Continue' response\n         * expected. If we don't do this then if an attempt to read\n         * input for the first time is after headers have been\n         * sent, then Apache is wrongly generate the '100 Continue'\n         * response into the response content. Not sure if this is\n         * a bug in Apache, or that it truly believes that input\n         * will never be read after the response headers have been\n         * sent.\n         */\n\n        r->expecting_100 = 0;\n\n        /* No longer need headers now that they have been sent. */\n\n        Py_DECREF(self->headers);\n        self->headers = NULL;\n    }\n\n    /*\n     * If content length was specified, ensure that we don't\n     * actually output more data than was specified as being\n     * sent as otherwise technically in violation of HTTP RFC.\n     */\n\n    if (length) {\n        int output_length = length;\n\n        if (self->content_length_set) {\n            if (self->output_length < self->content_length) {\n                if (self->output_length + length > self->content_length) {\n                    length = self->content_length - self->output_length;\n                }\n            }\n            else\n                length = 0;\n        }\n\n        self->output_length += output_length;\n    }\n\n    /* Now output any data. */\n\n    if (length) {\n#if defined(MOD_WSGI_WITH_BUCKETS)\n        apr_bucket *b;\n\n        /*\n         * When using Apache 2.X can use lower level\n         * bucket brigade APIs. This is preferred as\n         * ap_rwrite()/ap_rflush() will grow memory in\n         * the request pool on each call, which will\n         * result in an increase in memory use over time\n         * when streaming of data is being performed.\n         * The memory is still reclaimed, but only at\n         * the end of the request. Using bucket brigade\n         * API avoids this, and also avoids any copying\n         * of response data due to buffering performed\n         * by ap_rwrite().\n         */\n\n        if (r->connection->aborted) {\n            if (!exception_when_aborted) {\n                ap_log_rerror(APLOG_MARK, WSGI_LOG_DEBUG(0), self->r,\n                              \"mod_wsgi (pid=%d): Client closed connection.\",\n                              getpid());\n            }\n            else\n                PyErr_SetString(PyExc_IOError, \"client connection closed\");\n\n            return 0;\n        }\n\n        if (!self->bb) {\n            self->bb = apr_brigade_create(r->pool,\n                                          r->connection->bucket_alloc);\n        }\n\n        b = apr_bucket_transient_create(data, length,\n                                        r->connection->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(self->bb, b);\n\n        b = apr_bucket_flush_create(r->connection->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(self->bb, b);\n\n        Py_BEGIN_ALLOW_THREADS\n        rv = ap_pass_brigade(r->output_filters, self->bb);\n        Py_END_ALLOW_THREADS\n\n        if (rv != APR_SUCCESS) {\n            PyErr_SetString(PyExc_IOError, \"failed to write data\");\n            return 0;\n        }\n\n        Py_BEGIN_ALLOW_THREADS\n        apr_brigade_cleanup(self->bb);\n        Py_END_ALLOW_THREADS\n#else\n        /*\n         * In Apache 1.3, the bucket brigade system doesn't exist,\n         * so have no choice but to use ap_rwrite()/ap_rflush().\n         * It is not believed that Apache 1.3 suffers the memory\n         * accumulation problem when streaming lots of data.\n         */\n\n        Py_BEGIN_ALLOW_THREADS\n        n = ap_rwrite(data, length, r);\n        Py_END_ALLOW_THREADS\n\n        if (n == -1) {\n            PyErr_SetString(PyExc_IOError, \"failed to write data\");\n            return 0;\n        }\n\n        Py_BEGIN_ALLOW_THREADS\n        n = ap_rflush(r);\n        Py_END_ALLOW_THREADS\n\n        if (n == -1) {\n            PyErr_SetString(PyExc_IOError, \"failed to flush data\");\n            return 0;\n        }\n#endif\n    }\n\n    /*\n     * Check whether aborted connection was found when data\n     * being written, otherwise will not be flagged until next\n     * time that data is being written. Early detection is\n     * better as it may have been the last data block being\n     * written and application may think that data has all\n     * been written. In a streaming application, we also want\n     * to avoid any additional data processing to generate any\n     * successive data.\n     */\n\n    if (r->connection->aborted) {\n        if (!exception_when_aborted) {\n            ap_log_rerror(APLOG_MARK, WSGI_LOG_DEBUG(0), self->r,\n                          \"mod_wsgi (pid=%d): Client closed connection.\",\n                          getpid());\n        }\n        else\n            PyErr_SetString(PyExc_IOError, \"client connection closed\");\n\n        return 0;\n    }\n\n    return 1;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145623,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "int sudo_process_init(TALLOC_CTX *mem_ctx,\n                      struct tevent_context *ev,\n                      struct confdb_ctx *cdb)\n{\n    struct resp_ctx *rctx;\n    struct sss_cmd_table *sudo_cmds;\n    struct sudo_ctx *sudo_ctx;\n    struct be_conn *iter;\n    int ret;\n    int max_retries;\n\n    sudo_cmds = get_sudo_cmds();\n    ret = sss_process_init(mem_ctx, ev, cdb,\n                           sudo_cmds,\n                           SSS_SUDO_SOCKET_NAME, -1, NULL, -1,\n                           CONFDB_SUDO_CONF_ENTRY,\n                           SSS_SUDO_SBUS_SERVICE_NAME,\n                           SSS_SUDO_SBUS_SERVICE_VERSION,\n                           &monitor_sudo_methods,\n                           \"SUDO\",\n                           NULL,\n                           sss_connection_setup,\n                           &rctx);\n    if (ret != EOK) {\n        DEBUG(SSSDBG_FATAL_FAILURE, \"sss_process_init() failed\\n\");\n        return ret;\n    }\n\n    sudo_ctx = talloc_zero(rctx, struct sudo_ctx);\n    if (!sudo_ctx) {\n        DEBUG(SSSDBG_FATAL_FAILURE, \"fatal error initializing sudo_ctx\\n\");\n        ret = ENOMEM;\n        goto fail;\n    }\n\n    sudo_ctx->rctx = rctx;\n    sudo_ctx->rctx->pvt_ctx = sudo_ctx;\n\n    sss_ncache_prepopulate(sudo_ctx->rctx->ncache, sudo_ctx->rctx->cdb, rctx);\n    if (ret != EOK) {\n        DEBUG(SSSDBG_FATAL_FAILURE,\n              \"failed to set ncache for sudo's filter_users\\n\");\n        goto fail;\n    }\n\n    /* Enable automatic reconnection to the Data Provider */\n    ret = confdb_get_int(sudo_ctx->rctx->cdb,\n                         CONFDB_SUDO_CONF_ENTRY,\n                         CONFDB_SERVICE_RECON_RETRIES,\n                         3, &max_retries);\n    if (ret != EOK) {\n        DEBUG(SSSDBG_FATAL_FAILURE,\n              \"Failed to set up automatic reconnection\\n\");\n        goto fail;\n    }\n\n    for (iter = sudo_ctx->rctx->be_conns; iter; iter = iter->next) {\n        sbus_reconnect_init(iter->conn, max_retries,\n                            sudo_dp_reconnect_init, iter);\n    }\n\n    /* Get sudo_timed option */\n    ret = confdb_get_bool(sudo_ctx->rctx->cdb,\n                          CONFDB_SUDO_CONF_ENTRY, CONFDB_SUDO_TIMED,\n                          CONFDB_DEFAULT_SUDO_TIMED,\n                          &sudo_ctx->timed);\n    if (ret != EOK) {\n        DEBUG(SSSDBG_FATAL_FAILURE, \"Error reading from confdb (%d) [%s]\\n\",\n              ret, strerror(ret));\n        goto fail;\n    }\n\n    /* Get sudo_inverse_order option */\n    ret = confdb_get_bool(sudo_ctx->rctx->cdb,\n                          CONFDB_SUDO_CONF_ENTRY, CONFDB_SUDO_INVERSE_ORDER,\n                          CONFDB_DEFAULT_SUDO_INVERSE_ORDER,\n                          &sudo_ctx->inverse_order);\n    if (ret != EOK) {\n        DEBUG(SSSDBG_FATAL_FAILURE, \"Error reading from confdb (%d) [%s]\\n\",\n              ret, strerror(ret));\n        goto fail;\n    }\n\n    /* Get sudo_inverse_order option */\n    ret = confdb_get_int(sudo_ctx->rctx->cdb,\n                         CONFDB_SUDO_CONF_ENTRY, CONFDB_SUDO_THRESHOLD,\n                         CONFDB_DEFAULT_SUDO_THRESHOLD,\n                         &sudo_ctx->threshold);\n    if (ret != EOK) {\n        DEBUG(SSSDBG_FATAL_FAILURE, \"Error reading from confdb (%d) [%s]\\n\",\n              ret, strerror(ret));\n        goto fail;\n    }\n\n    ret = schedule_get_domains_task(rctx, rctx->ev, rctx, NULL);\n    if (ret != EOK) {\n        DEBUG(SSSDBG_FATAL_FAILURE, \"schedule_get_domains_tasks failed.\\n\");\n        goto fail;\n    }\n\n    DEBUG(SSSDBG_TRACE_FUNC, \"SUDO Initialization complete\\n\");\n\n    return EOK;\n\nfail:\n    talloc_free(rctx);\n    return ret;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145632,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "int sudo_process_init(TALLOC_CTX *mem_ctx,\n                      struct tevent_context *ev,\n                      struct confdb_ctx *cdb)\n{\n    struct resp_ctx *rctx;\n    struct sss_cmd_table *sudo_cmds;\n    struct sudo_ctx *sudo_ctx;\n    struct be_conn *iter;\n    int ret;\n    int max_retries;\n\n    sudo_cmds = get_sudo_cmds();\n    ret = sss_process_init(mem_ctx, ev, cdb,\n                           sudo_cmds,\n                           NULL, -1,                   /* No public socket */\n                           SSS_SUDO_SOCKET_NAME, -1,   /* Private socket only */\n                           CONFDB_SUDO_CONF_ENTRY,\n                           SSS_SUDO_SBUS_SERVICE_NAME,\n                           SSS_SUDO_SBUS_SERVICE_VERSION,\n                           &monitor_sudo_methods,\n                           \"SUDO\",\n                           NULL,\n                           sss_connection_setup,\n                           &rctx);\n    if (ret != EOK) {\n        DEBUG(SSSDBG_FATAL_FAILURE, \"sss_process_init() failed\\n\");\n        return ret;\n    }\n\n    sudo_ctx = talloc_zero(rctx, struct sudo_ctx);\n    if (!sudo_ctx) {\n        DEBUG(SSSDBG_FATAL_FAILURE, \"fatal error initializing sudo_ctx\\n\");\n        ret = ENOMEM;\n        goto fail;\n    }\n\n    sudo_ctx->rctx = rctx;\n    sudo_ctx->rctx->pvt_ctx = sudo_ctx;\n\n    sss_ncache_prepopulate(sudo_ctx->rctx->ncache, sudo_ctx->rctx->cdb, rctx);\n    if (ret != EOK) {\n        DEBUG(SSSDBG_FATAL_FAILURE,\n              \"failed to set ncache for sudo's filter_users\\n\");\n        goto fail;\n    }\n\n    /* Enable automatic reconnection to the Data Provider */\n    ret = confdb_get_int(sudo_ctx->rctx->cdb,\n                         CONFDB_SUDO_CONF_ENTRY,\n                         CONFDB_SERVICE_RECON_RETRIES,\n                         3, &max_retries);\n    if (ret != EOK) {\n        DEBUG(SSSDBG_FATAL_FAILURE,\n              \"Failed to set up automatic reconnection\\n\");\n        goto fail;\n    }\n\n    for (iter = sudo_ctx->rctx->be_conns; iter; iter = iter->next) {\n        sbus_reconnect_init(iter->conn, max_retries,\n                            sudo_dp_reconnect_init, iter);\n    }\n\n    /* Get sudo_timed option */\n    ret = confdb_get_bool(sudo_ctx->rctx->cdb,\n                          CONFDB_SUDO_CONF_ENTRY, CONFDB_SUDO_TIMED,\n                          CONFDB_DEFAULT_SUDO_TIMED,\n                          &sudo_ctx->timed);\n    if (ret != EOK) {\n        DEBUG(SSSDBG_FATAL_FAILURE, \"Error reading from confdb (%d) [%s]\\n\",\n              ret, strerror(ret));\n        goto fail;\n    }\n\n    /* Get sudo_inverse_order option */\n    ret = confdb_get_bool(sudo_ctx->rctx->cdb,\n                          CONFDB_SUDO_CONF_ENTRY, CONFDB_SUDO_INVERSE_ORDER,\n                          CONFDB_DEFAULT_SUDO_INVERSE_ORDER,\n                          &sudo_ctx->inverse_order);\n    if (ret != EOK) {\n        DEBUG(SSSDBG_FATAL_FAILURE, \"Error reading from confdb (%d) [%s]\\n\",\n              ret, strerror(ret));\n        goto fail;\n    }\n\n    /* Get sudo_inverse_order option */\n    ret = confdb_get_int(sudo_ctx->rctx->cdb,\n                         CONFDB_SUDO_CONF_ENTRY, CONFDB_SUDO_THRESHOLD,\n                         CONFDB_DEFAULT_SUDO_THRESHOLD,\n                         &sudo_ctx->threshold);\n    if (ret != EOK) {\n        DEBUG(SSSDBG_FATAL_FAILURE, \"Error reading from confdb (%d) [%s]\\n\",\n              ret, strerror(ret));\n        goto fail;\n    }\n\n    ret = schedule_get_domains_task(rctx, rctx->ev, rctx, NULL);\n    if (ret != EOK) {\n        DEBUG(SSSDBG_FATAL_FAILURE, \"schedule_get_domains_tasks failed.\\n\");\n        goto fail;\n    }\n\n    DEBUG(SSSDBG_TRACE_FUNC, \"SUDO Initialization complete\\n\");\n\n    return EOK;\n\nfail:\n    talloc_free(rctx);\n    return ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145633,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "FILE *fopen_safe(const char *path, const char *mode)\n{\n\tint fd;\n\tFILE *file;\n\tint flags = O_NOFOLLOW | O_CREAT;\n\tint sav_errno;\n\n\tif (mode[0] == 'r')\n\t\treturn fopen(path, mode);\n\n\tif ((mode[0] != 'a' && mode[0] != 'w') ||\n\t    (mode[1] &&\n\t     (mode[1] != '+' || mode[2]))) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (mode[0] == 'w')\n\t\tflags |= O_TRUNC;\n\telse\n\t\tflags |= O_APPEND;\n\n\tif (mode[1])\n\t\tflags |= O_RDWR;\n\telse\n\t\tflags |= O_WRONLY;\n\n\tif (mode[0] == 'w') {\n\t\t/* Ensure that any existing file isn't currently opened for read by a non-privileged user.\n\t\t * We do this by unlinking the file, so that the open() below will create a new file. */\n\t\tif (unlink(path) && errno != ENOENT) {\n\t\t\tlog_message(LOG_INFO, \"Failed to remove existing file '%s' prior to write\", path);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\telse {\n\t\t/* Only allow append mode if debugging features requiring append are enabled. Since we\n\t\t * can't unlink the file, there may be a non privileged user who already has the file open\n\t\t * for read (e.g. tail -f). If these debug option aren't enabled, there is no potential\n\t\t * security risk. */\n#ifndef ENABLE_LOG_FILE_APPEND\n\t\tlog_message(LOG_INFO, \"BUG - shouldn't be opening file for append with current build options\");\n\t\terrno = EINVAL;\n\t\treturn NULL;\n#endif\n\t}\n\n\tfd = open(path, flags, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);\n\tif (fd == -1)\n\t\treturn NULL;\n\n\t/* Change file ownership to root */\n\tif (fchown(fd, 0, 0)) {\n\t\tsav_errno = errno;\n\t\tlog_message(LOG_INFO, \"Unable to change file ownership of %s- errno %d (%m)\", path, errno);\n\t\tclose(fd);\n\t\terrno = sav_errno;\n\t\treturn NULL;\n\t}\n\n\t/* Set file mode to rw------- */\n\tif (fchmod(fd, S_IRUSR | S_IWUSR)) {\n\t\tsav_errno = errno;\n\t\tlog_message(LOG_INFO, \"Unable to change file permission of %s - errno %d (%m)\", path, errno);\n\t\tclose(fd);\n\t\terrno = sav_errno;\n\t\treturn NULL;\n\t}\n\n\tfile = fdopen (fd, \"w\");\n\tif (!file) {\n\t\tsav_errno = errno;\n\t\tlog_message(LOG_INFO, \"fdopen(\\\"%s\\\") failed - errno %d (%m)\", path, errno);\n\t\tclose(fd);\n\t\terrno = sav_errno;\n\t\treturn NULL;\n\t}\n\n\treturn file;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145864,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "FILE *fopen_safe(const char *path, const char *mode)\n{\n\tint fd;\n\tFILE *file;\n\tint flags = O_NOFOLLOW | O_CREAT | O_CLOEXEC;\n\tint sav_errno;\n\tchar file_tmp_name[] = \"/tmp/keepalivedXXXXXX\";\n\n\tif (mode[0] == 'r')\n\t\treturn fopen(path, mode);\n\n\tif ((mode[0] != 'a' && mode[0] != 'w') ||\n\t    (mode[1] &&\n\t     (mode[1] != '+' || mode[2]))) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (mode[0] == 'w') {\n\t\t/* If we truncate an existing file, any non-privileged user who already has the file\n\t\t * open would be able to read what we write, even though the file access mode is changed.\n\t\t *\n\t\t * If we unlink an existing file and the desired file is subsequently created via open,\n\t\t * it leaves a window for someone else to create the same file between the unlink and the open.\n\t\t *\n\t\t * The solution is to create a temporary file that we will rename to the desired file name.\n\t\t * Since the temporary file is created owned by root with the only file access persmissions being\n\t\t * owner read and write, no non root user will have access to the file. Further, the rename to\n\t\t * the requested filename is atomic, and so there is no window when someone else could create\n\t\t * another file of the same name.\n\t\t */\n\t\tfd = mkostemp(file_tmp_name, O_CLOEXEC);\n\t} else {\n\t\t/* Only allow append mode if debugging features requiring append are enabled. Since we\n\t\t * can't unlink the file, there may be a non privileged user who already has the file open\n\t\t * for read (e.g. tail -f). If these debug option aren't enabled, there is no potential\n\t\t * security risk in that respect. */\n#ifndef ENABLE_LOG_FILE_APPEND\n\t\tlog_message(LOG_INFO, \"BUG - shouldn't be opening file for append with current build options\");\n\t\terrno = EINVAL;\n\t\treturn NULL;\n#else\n\t\tflags = O_NOFOLLOW | O_CREAT | O_CLOEXEC | O_APPEND;\n\n\t\tif (mode[1])\n\t\t\tflags |= O_RDWR;\n\t\telse\n\t\t\tflags |= O_WRONLY;\n\n\t\tfd = open(path, flags, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);\n#endif\n\t}\n\n\tif (fd == -1) {\n\t\tsav_errno = errno;\n\t\tlog_message(LOG_INFO, \"Unable to open '%s' - errno %d (%m)\", path, errno);\n\t\terrno = sav_errno;\n\t\treturn NULL;\n\t}\n\n#ifndef ENABLE_LOG_FILE_APPEND\n\t/* Change file ownership to root */\n\tif (mode[0] == 'a' && fchown(fd, 0, 0)) {\n\t\tsav_errno = errno;\n\t\tlog_message(LOG_INFO, \"Unable to change file ownership of %s- errno %d (%m)\", path, errno);\n\t\tclose(fd);\n\t\terrno = sav_errno;\n\t\treturn NULL;\n\t}\n#endif\n\n\t/* Set file mode to rw------- */\n\tif (fchmod(fd, S_IRUSR | S_IWUSR)) {\n\t\tsav_errno = errno;\n\t\tlog_message(LOG_INFO, \"Unable to change file permission of %s - errno %d (%m)\", path, errno);\n\t\tclose(fd);\n\t\terrno = sav_errno;\n\t\treturn NULL;\n\t}\n\n\tif (mode[0] == 'w') {\n\t\t/* Rename the temporary file to the one we want */\n\t\tif (rename(file_tmp_name, path)) {\n\t\t\tsav_errno = errno;\n\t\t\tlog_message(LOG_INFO, \"Failed to rename %s to %s - errno %d (%m)\", file_tmp_name, path, errno);\n\t\t\tclose(fd);\n\t\t\terrno = sav_errno;\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tfile = fdopen (fd, \"w\");\n\tif (!file) {\n\t\tsav_errno = errno;\n\t\tlog_message(LOG_INFO, \"fdopen(\\\"%s\\\") failed - errno %d (%m)\", path, errno);\n\t\tclose(fd);\n\t\terrno = sav_errno;\n\t\treturn NULL;\n\t}\n\n\treturn file;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145865,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static void do_client_disconnect(void)\n{\n    if (client_connected) {\n        udscs_server_write_all(server, VDAGENTD_CLIENT_DISCONNECTED, 0, 0,\n                               NULL, 0);\n        client_connected = false;\n    }\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145884,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static void do_client_disconnect(void)\n{\n    g_hash_table_remove_all(active_xfers);\n    if (client_connected) {\n        udscs_server_write_all(server, VDAGENTD_CLIENT_DISCONNECTED, 0, 0,\n                               NULL, 0);\n        client_connected = false;\n    }\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145885,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "mix_pool(byte *pool)\n{\n    char *hashbuf = pool + POOLSIZE;\n    char *p, *pend;\n    int i, n;\n    RMD160_CONTEXT md;\n\n    rmd160_init( &md );\n#if DIGESTLEN != 20\n#error must have a digest length of 20 for ripe-md-160\n#endif\n    /* loop over the pool */\n    pend = pool + POOLSIZE;\n    memcpy(hashbuf, pend - DIGESTLEN, DIGESTLEN );\n    memcpy(hashbuf+DIGESTLEN, pool, BLOCKLEN-DIGESTLEN);\n    rmd160_mixblock( &md, hashbuf);\n    memcpy(pool, hashbuf, DIGESTLEN);\n\n    p = pool;\n    for( n=1; n < POOLBLOCKS; n++ ) {\n\tmemcpy(hashbuf, p, DIGESTLEN );\n\n\tp += DIGESTLEN;\n\tif( p+DIGESTLEN+BLOCKLEN < pend )\n\t    memcpy(hashbuf+DIGESTLEN, p+DIGESTLEN, BLOCKLEN-DIGESTLEN);\n\telse {\n\t    char *pp = p+DIGESTLEN;\n\t    for(i=DIGESTLEN; i < BLOCKLEN; i++ ) {\n\t\tif( pp >= pend )\n\t\t    pp = pool;\n\t\thashbuf[i] = *pp++;\n\t    }\n\t}\n\n\trmd160_mixblock( &md, hashbuf);\n\tmemcpy(p, hashbuf, DIGESTLEN);\n    }\n    burn_stack (384); /* for the rmd160_mixblock() */\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145992,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "mix_pool(byte *pool)\n{\n    char *hashbuf = pool + POOLSIZE;\n    char *p, *pend;\n    int i, n;\n    RMD160_CONTEXT md;\n\n    rmd160_init( &md );\n#if DIGESTLEN != 20\n#error must have a digest length of 20 for ripe-md-160\n#endif\n    /* pool -> pool' */\n    pend = pool + POOLSIZE;\n    memcpy(hashbuf, pend - DIGESTLEN, DIGESTLEN );\n    memcpy(hashbuf+DIGESTLEN, pool, BLOCKLEN-DIGESTLEN);\n    rmd160_mixblock( &md, hashbuf);\n    memcpy(pool, hashbuf, DIGESTLEN);\n\n    /* Loop for the remaining iterations.  */\n    p = pool;\n    for( n=1; n < POOLBLOCKS; n++ ) {\n\tif( p + BLOCKLEN < pend )\n\t    memcpy(hashbuf, p, BLOCKLEN);\n\telse {\n\t    char *pp = p;\n\t    for(i=0; i < BLOCKLEN; i++ ) {\n\t\tif( pp >= pend )\n\t\t    pp = pool;\n\t\thashbuf[i] = *pp++;\n\t    }\n\t}\n\n\trmd160_mixblock( &md, hashbuf);\n        p += DIGESTLEN;\n\tmemcpy(p, hashbuf, DIGESTLEN);\n    }\n    burn_stack (384); /* for the rmd160_mixblock() */\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145993,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "print_timer(struct seq_file *m, struct hrtimer *taddr, struct hrtimer *timer,\n\t    int idx, u64 now)\n{\n#ifdef CONFIG_TIMER_STATS\n\tchar tmp[TASK_COMM_LEN + 1];\n#endif\n\tSEQ_printf(m, \" #%d: \", idx);\n\tprint_name_offset(m, taddr);\n\tSEQ_printf(m, \", \");\n\tprint_name_offset(m, timer->function);\n\tSEQ_printf(m, \", S:%02x\", timer->state);\n#ifdef CONFIG_TIMER_STATS\n\tSEQ_printf(m, \", \");\n\tprint_name_offset(m, timer->start_site);\n\tmemcpy(tmp, timer->start_comm, TASK_COMM_LEN);\n\ttmp[TASK_COMM_LEN] = 0;\n\tSEQ_printf(m, \", %s/%d\", tmp, timer->start_pid);\n#endif\n\tSEQ_printf(m, \"\\n\");\n\tSEQ_printf(m, \" # expires at %Lu-%Lu nsecs [in %Ld to %Ld nsecs]\\n\",\n\t\t(unsigned long long)ktime_to_ns(hrtimer_get_softexpires(timer)),\n\t\t(unsigned long long)ktime_to_ns(hrtimer_get_expires(timer)),\n\t\t(long long)(ktime_to_ns(hrtimer_get_softexpires(timer)) - now),\n\t\t(long long)(ktime_to_ns(hrtimer_get_expires(timer)) - now));\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146012,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "print_timer(struct seq_file *m, struct hrtimer *taddr, struct hrtimer *timer,\n\t    int idx, u64 now)\n{\n\tSEQ_printf(m, \" #%d: \", idx);\n\tprint_name_offset(m, taddr);\n\tSEQ_printf(m, \", \");\n\tprint_name_offset(m, timer->function);\n\tSEQ_printf(m, \", S:%02x\", timer->state);\n\tSEQ_printf(m, \"\\n\");\n\tSEQ_printf(m, \" # expires at %Lu-%Lu nsecs [in %Ld to %Ld nsecs]\\n\",\n\t\t(unsigned long long)ktime_to_ns(hrtimer_get_softexpires(timer)),\n\t\t(unsigned long long)ktime_to_ns(hrtimer_get_expires(timer)),\n\t\t(long long)(ktime_to_ns(hrtimer_get_softexpires(timer)) - now),\n\t\t(long long)(ktime_to_ns(hrtimer_get_expires(timer)) - now));\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146013,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int diffie_hellman_sha256(LIBSSH2_SESSION *session,\n                                 _libssh2_bn *g,\n                                 _libssh2_bn *p,\n                                 int group_order,\n                                 unsigned char packet_type_init,\n                                 unsigned char packet_type_reply,\n                                 unsigned char *midhash,\n                                 unsigned long midhash_len,\n                                 kmdhgGPshakex_state_t *exchange_state)\n{\n    int ret = 0;\n    int rc;\n    libssh2_sha256_ctx exchange_hash_ctx;\n\n    if (exchange_state->state == libssh2_NB_state_idle) {\n        /* Setup initial values */\n        exchange_state->e_packet = NULL;\n        exchange_state->s_packet = NULL;\n        exchange_state->k_value = NULL;\n        exchange_state->ctx = _libssh2_bn_ctx_new();\n        exchange_state->x = _libssh2_bn_init(); /* Random from client */\n        exchange_state->e = _libssh2_bn_init(); /* g^x mod p */\n        exchange_state->f = _libssh2_bn_init_from_bin(); /* g^(Random from server) mod p */\n        exchange_state->k = _libssh2_bn_init(); /* The shared secret: f^x mod p */\n\n        /* Zero the whole thing out */\n        memset(&exchange_state->req_state, 0, sizeof(packet_require_state_t));\n\n        /* Generate x and e */\n        _libssh2_bn_rand(exchange_state->x, group_order, 0, -1);\n        _libssh2_bn_mod_exp(exchange_state->e, g, exchange_state->x, p,\n                            exchange_state->ctx);\n\n        /* Send KEX init */\n        /* packet_type(1) + String Length(4) + leading 0(1) */\n        exchange_state->e_packet_len =\n            _libssh2_bn_bytes(exchange_state->e) + 6;\n        if (_libssh2_bn_bits(exchange_state->e) % 8) {\n            /* Leading 00 not needed */\n            exchange_state->e_packet_len--;\n        }\n\n        exchange_state->e_packet =\n            LIBSSH2_ALLOC(session, exchange_state->e_packet_len);\n        if (!exchange_state->e_packet) {\n            ret = _libssh2_error(session, LIBSSH2_ERROR_ALLOC,\n                                 \"Out of memory error\");\n            goto clean_exit;\n        }\n        exchange_state->e_packet[0] = packet_type_init;\n        _libssh2_htonu32(exchange_state->e_packet + 1,\n                         exchange_state->e_packet_len - 5);\n        if (_libssh2_bn_bits(exchange_state->e) % 8) {\n            _libssh2_bn_to_bin(exchange_state->e,\n                               exchange_state->e_packet + 5);\n        } else {\n            exchange_state->e_packet[5] = 0;\n            _libssh2_bn_to_bin(exchange_state->e,\n                               exchange_state->e_packet + 6);\n        }\n\n        _libssh2_debug(session, LIBSSH2_TRACE_KEX, \"Sending KEX packet %d\",\n                       (int) packet_type_init);\n        exchange_state->state = libssh2_NB_state_created;\n    }\n\n    if (exchange_state->state == libssh2_NB_state_created) {\n        rc = _libssh2_transport_send(session, exchange_state->e_packet,\n                                     exchange_state->e_packet_len,\n                                     NULL, 0);\n        if (rc == LIBSSH2_ERROR_EAGAIN) {\n            return rc;\n        } else if (rc) {\n            ret = _libssh2_error(session, rc,\n                                 \"Unable to send KEX init message\");\n            goto clean_exit;\n        }\n        exchange_state->state = libssh2_NB_state_sent;\n    }\n\n    if (exchange_state->state == libssh2_NB_state_sent) {\n        if (session->burn_optimistic_kexinit) {\n            /* The first KEX packet to come along will be the guess initially\n             * sent by the server.  That guess turned out to be wrong so we\n             * need to silently ignore it */\n            int burn_type;\n\n            _libssh2_debug(session, LIBSSH2_TRACE_KEX,\n                           \"Waiting for badly guessed KEX packet (to be ignored)\");\n            burn_type =\n                _libssh2_packet_burn(session, &exchange_state->burn_state);\n            if (burn_type == LIBSSH2_ERROR_EAGAIN) {\n                return burn_type;\n            } else if (burn_type <= 0) {\n                /* Failed to receive a packet */\n                ret = burn_type;\n                goto clean_exit;\n            }\n            session->burn_optimistic_kexinit = 0;\n\n            _libssh2_debug(session, LIBSSH2_TRACE_KEX,\n                           \"Burnt packet of type: %02x\",\n                           (unsigned int) burn_type);\n        }\n\n        exchange_state->state = libssh2_NB_state_sent1;\n    }\n\n    if (exchange_state->state == libssh2_NB_state_sent1) {\n        /* Wait for KEX reply */\n        rc = _libssh2_packet_require(session, packet_type_reply,\n                                     &exchange_state->s_packet,\n                                     &exchange_state->s_packet_len, 0, NULL,\n                                     0, &exchange_state->req_state);\n        if (rc == LIBSSH2_ERROR_EAGAIN) {\n            return rc;\n        }\n        if (rc) {\n            ret = _libssh2_error(session, LIBSSH2_ERROR_TIMEOUT,\n                                 \"Timed out waiting for KEX reply\");\n            goto clean_exit;\n        }\n\n        /* Parse KEXDH_REPLY */\n        exchange_state->s = exchange_state->s_packet + 1;\n\n        session->server_hostkey_len = _libssh2_ntohu32(exchange_state->s);\n        exchange_state->s += 4;\n\n        if (session->server_hostkey)\n            LIBSSH2_FREE(session, session->server_hostkey);\n\n        session->server_hostkey =\n            LIBSSH2_ALLOC(session, session->server_hostkey_len);\n        if (!session->server_hostkey) {\n            ret = _libssh2_error(session, LIBSSH2_ERROR_ALLOC,\n                                 \"Unable to allocate memory for a copy \"\n                                 \"of the host key\");\n            goto clean_exit;\n        }\n        memcpy(session->server_hostkey, exchange_state->s,\n               session->server_hostkey_len);\n        exchange_state->s += session->server_hostkey_len;\n\n#if LIBSSH2_MD5\n        {\n            libssh2_md5_ctx fingerprint_ctx;\n\n            if (libssh2_md5_init(&fingerprint_ctx)) {\n                libssh2_md5_update(fingerprint_ctx, session->server_hostkey,\n                                   session->server_hostkey_len);\n                libssh2_md5_final(fingerprint_ctx,\n                                  session->server_hostkey_md5);\n                session->server_hostkey_md5_valid = TRUE;\n            }\n            else {\n                session->server_hostkey_md5_valid = FALSE;\n            }\n        }\n#ifdef LIBSSH2DEBUG\n        {\n            char fingerprint[50], *fprint = fingerprint;\n            int i;\n            for(i = 0; i < 16; i++, fprint += 3) {\n                snprintf(fprint, 4, \"%02x:\", session->server_hostkey_md5[i]);\n            }\n            *(--fprint) = '\\0';\n            _libssh2_debug(session, LIBSSH2_TRACE_KEX,\n                           \"Server's MD5 Fingerprint: %s\", fingerprint);\n        }\n#endif /* LIBSSH2DEBUG */\n#endif /* ! LIBSSH2_MD5 */\n\n        {\n            libssh2_sha1_ctx fingerprint_ctx;\n\n            if (libssh2_sha1_init(&fingerprint_ctx)) {\n                libssh2_sha1_update(fingerprint_ctx, session->server_hostkey,\n                                    session->server_hostkey_len);\n                libssh2_sha1_final(fingerprint_ctx,\n                                   session->server_hostkey_sha1);\n                session->server_hostkey_sha1_valid = TRUE;\n            }\n            else {\n                session->server_hostkey_sha1_valid = FALSE;\n            }\n        }\n#ifdef LIBSSH2DEBUG\n        {\n            char fingerprint[64], *fprint = fingerprint;\n            int i;\n\n            for(i = 0; i < 20; i++, fprint += 3) {\n                snprintf(fprint, 4, \"%02x:\", session->server_hostkey_sha1[i]);\n            }\n            *(--fprint) = '\\0';\n            _libssh2_debug(session, LIBSSH2_TRACE_KEX,\n                           \"Server's SHA1 Fingerprint: %s\", fingerprint);\n        }\n#endif /* LIBSSH2DEBUG */\n\n        if (session->hostkey->init(session, session->server_hostkey,\n                                   session->server_hostkey_len,\n                                   &session->server_hostkey_abstract)) {\n            ret = _libssh2_error(session, LIBSSH2_ERROR_HOSTKEY_INIT,\n                                 \"Unable to initialize hostkey importer\");\n            goto clean_exit;\n        }\n\n        exchange_state->f_value_len = _libssh2_ntohu32(exchange_state->s);\n        exchange_state->s += 4;\n        exchange_state->f_value = exchange_state->s;\n        exchange_state->s += exchange_state->f_value_len;\n        _libssh2_bn_from_bin(exchange_state->f, exchange_state->f_value_len,\n                             exchange_state->f_value);\n\n        exchange_state->h_sig_len = _libssh2_ntohu32(exchange_state->s);\n        exchange_state->s += 4;\n        exchange_state->h_sig = exchange_state->s;\n\n        /* Compute the shared secret */\n        _libssh2_bn_mod_exp(exchange_state->k, exchange_state->f,\n                            exchange_state->x, p, exchange_state->ctx);\n        exchange_state->k_value_len = _libssh2_bn_bytes(exchange_state->k) + 5;\n        if (_libssh2_bn_bits(exchange_state->k) % 8) {\n            /* don't need leading 00 */\n            exchange_state->k_value_len--;\n        }\n        exchange_state->k_value =\n            LIBSSH2_ALLOC(session, exchange_state->k_value_len);\n        if (!exchange_state->k_value) {\n            ret = _libssh2_error(session, LIBSSH2_ERROR_ALLOC,\n                                 \"Unable to allocate buffer for K\");\n            goto clean_exit;\n        }\n        _libssh2_htonu32(exchange_state->k_value,\n                         exchange_state->k_value_len - 4);\n        if (_libssh2_bn_bits(exchange_state->k) % 8) {\n            _libssh2_bn_to_bin(exchange_state->k, exchange_state->k_value + 4);\n        } else {\n            exchange_state->k_value[4] = 0;\n            _libssh2_bn_to_bin(exchange_state->k, exchange_state->k_value + 5);\n        }\n\n        exchange_state->exchange_hash = (void*)&exchange_hash_ctx;\n        libssh2_sha256_init(&exchange_hash_ctx);\n\n        if (session->local.banner) {\n            _libssh2_htonu32(exchange_state->h_sig_comp,\n                             strlen((char *) session->local.banner) - 2);\n            libssh2_sha256_update(exchange_hash_ctx,\n                                  exchange_state->h_sig_comp, 4);\n            libssh2_sha256_update(exchange_hash_ctx,\n                                  (char *) session->local.banner,\n                                  strlen((char *) session->local.banner) - 2);\n        } else {\n            _libssh2_htonu32(exchange_state->h_sig_comp,\n                             sizeof(LIBSSH2_SSH_DEFAULT_BANNER) - 1);\n            libssh2_sha256_update(exchange_hash_ctx,\n                                  exchange_state->h_sig_comp, 4);\n            libssh2_sha256_update(exchange_hash_ctx,\n                                  LIBSSH2_SSH_DEFAULT_BANNER,\n                                  sizeof(LIBSSH2_SSH_DEFAULT_BANNER) - 1);\n        }\n\n        _libssh2_htonu32(exchange_state->h_sig_comp,\n                         strlen((char *) session->remote.banner));\n        libssh2_sha256_update(exchange_hash_ctx,\n                              exchange_state->h_sig_comp, 4);\n        libssh2_sha256_update(exchange_hash_ctx,\n                              session->remote.banner,\n                              strlen((char *) session->remote.banner));\n\n        _libssh2_htonu32(exchange_state->h_sig_comp,\n                         session->local.kexinit_len);\n        libssh2_sha256_update(exchange_hash_ctx,\n                              exchange_state->h_sig_comp, 4);\n        libssh2_sha256_update(exchange_hash_ctx,\n                              session->local.kexinit,\n                              session->local.kexinit_len);\n\n        _libssh2_htonu32(exchange_state->h_sig_comp,\n                         session->remote.kexinit_len);\n        libssh2_sha256_update(exchange_hash_ctx,\n                              exchange_state->h_sig_comp, 4);\n        libssh2_sha256_update(exchange_hash_ctx,\n                              session->remote.kexinit,\n                              session->remote.kexinit_len);\n\n        _libssh2_htonu32(exchange_state->h_sig_comp,\n                         session->server_hostkey_len);\n        libssh2_sha256_update(exchange_hash_ctx,\n                              exchange_state->h_sig_comp, 4);\n        libssh2_sha256_update(exchange_hash_ctx,\n                              session->server_hostkey,\n                              session->server_hostkey_len);\n\n        if (packet_type_init == SSH_MSG_KEX_DH_GEX_INIT) {\n            /* diffie-hellman-group-exchange hashes additional fields */\n#ifdef LIBSSH2_DH_GEX_NEW\n            _libssh2_htonu32(exchange_state->h_sig_comp,\n                             LIBSSH2_DH_GEX_MINGROUP);\n            _libssh2_htonu32(exchange_state->h_sig_comp + 4,\n                             LIBSSH2_DH_GEX_OPTGROUP);\n            _libssh2_htonu32(exchange_state->h_sig_comp + 8,\n                             LIBSSH2_DH_GEX_MAXGROUP);\n            libssh2_sha256_update(exchange_hash_ctx,\n                                  exchange_state->h_sig_comp, 12);\n#else\n            _libssh2_htonu32(exchange_state->h_sig_comp,\n                             LIBSSH2_DH_GEX_OPTGROUP);\n            libssh2_sha256_update(exchange_hash_ctx,\n                                  exchange_state->h_sig_comp, 4);\n#endif\n        }\n\n        if (midhash) {\n            libssh2_sha256_update(exchange_hash_ctx, midhash,\n                                  midhash_len);\n        }\n\n        libssh2_sha256_update(exchange_hash_ctx,\n                              exchange_state->e_packet + 1,\n                              exchange_state->e_packet_len - 1);\n\n        _libssh2_htonu32(exchange_state->h_sig_comp,\n                         exchange_state->f_value_len);\n        libssh2_sha256_update(exchange_hash_ctx,\n                              exchange_state->h_sig_comp, 4);\n        libssh2_sha256_update(exchange_hash_ctx,\n                              exchange_state->f_value,\n                              exchange_state->f_value_len);\n\n        libssh2_sha256_update(exchange_hash_ctx,\n                              exchange_state->k_value,\n                              exchange_state->k_value_len);\n\n        libssh2_sha256_final(exchange_hash_ctx,\n                             exchange_state->h_sig_comp);\n\n        if (session->hostkey->\n            sig_verify(session, exchange_state->h_sig,\n                       exchange_state->h_sig_len, exchange_state->h_sig_comp,\n                       SHA256_DIGEST_LENGTH, &session->server_hostkey_abstract)) {\n            ret = _libssh2_error(session, LIBSSH2_ERROR_HOSTKEY_SIGN,\n                                 \"Unable to verify hostkey signature\");\n            goto clean_exit;\n        }\n\n\n\n        _libssh2_debug(session, LIBSSH2_TRACE_KEX, \"Sending NEWKEYS message\");\n        exchange_state->c = SSH_MSG_NEWKEYS;\n\n        exchange_state->state = libssh2_NB_state_sent2;\n    }\n\n    if (exchange_state->state == libssh2_NB_state_sent2) {\n        rc = _libssh2_transport_send(session, &exchange_state->c, 1, NULL, 0);\n        if (rc == LIBSSH2_ERROR_EAGAIN) {\n            return rc;\n        } else if (rc) {\n            ret = _libssh2_error(session, rc, \"Unable to send NEWKEYS message\");\n            goto clean_exit;\n        }\n\n        exchange_state->state = libssh2_NB_state_sent3;\n    }\n\n    if (exchange_state->state == libssh2_NB_state_sent3) {\n        rc = _libssh2_packet_require(session, SSH_MSG_NEWKEYS,\n                                     &exchange_state->tmp,\n                                     &exchange_state->tmp_len, 0, NULL, 0,\n                                     &exchange_state->req_state);\n        if (rc == LIBSSH2_ERROR_EAGAIN) {\n            return rc;\n        } else if (rc) {\n            ret = _libssh2_error(session, rc, \"Timed out waiting for NEWKEYS\");\n            goto clean_exit;\n        }\n        /* The first key exchange has been performed,\n           switch to active crypt/comp/mac mode */\n        session->state |= LIBSSH2_STATE_NEWKEYS;\n        _libssh2_debug(session, LIBSSH2_TRACE_KEX, \"Received NEWKEYS message\");\n\n        /* This will actually end up being just packet_type(1)\n           for this packet type anyway */\n        LIBSSH2_FREE(session, exchange_state->tmp);\n\n        if (!session->session_id) {\n            session->session_id = LIBSSH2_ALLOC(session, SHA256_DIGEST_LENGTH);\n            if (!session->session_id) {\n                ret = _libssh2_error(session, LIBSSH2_ERROR_ALLOC,\n                                     \"Unable to allocate buffer for SHA digest\");\n                goto clean_exit;\n            }\n            memcpy(session->session_id, exchange_state->h_sig_comp,\n                   SHA256_DIGEST_LENGTH);\n            session->session_id_len = SHA256_DIGEST_LENGTH;\n            _libssh2_debug(session, LIBSSH2_TRACE_KEX, \"session_id calculated\");\n        }\n\n        /* Cleanup any existing cipher */\n        if (session->local.crypt->dtor) {\n            session->local.crypt->dtor(session,\n                                       &session->local.crypt_abstract);\n        }\n\n        /* Calculate IV/Secret/Key for each direction */\n        if (session->local.crypt->init) {\n            unsigned char *iv = NULL, *secret = NULL;\n            int free_iv = 0, free_secret = 0;\n\n            LIBSSH2_KEX_METHOD_DIFFIE_HELLMAN_SHA256_HASH(iv,\n                                                          session->local.crypt->\n                                                          iv_len, \"A\");\n            if (!iv) {\n                ret = -1;\n                goto clean_exit;\n            }\n            LIBSSH2_KEX_METHOD_DIFFIE_HELLMAN_SHA256_HASH(secret,\n                                                          session->local.crypt->\n                                                          secret_len, \"C\");\n            if (!secret) {\n                LIBSSH2_FREE(session, iv);\n                ret = LIBSSH2_ERROR_KEX_FAILURE;\n                goto clean_exit;\n            }\n            if (session->local.crypt->\n                init(session, session->local.crypt, iv, &free_iv, secret,\n                     &free_secret, 1, &session->local.crypt_abstract)) {\n                LIBSSH2_FREE(session, iv);\n                LIBSSH2_FREE(session, secret);\n                ret = LIBSSH2_ERROR_KEX_FAILURE;\n                goto clean_exit;\n            }\n\n            if (free_iv) {\n                memset(iv, 0, session->local.crypt->iv_len);\n                LIBSSH2_FREE(session, iv);\n            }\n\n            if (free_secret) {\n                memset(secret, 0, session->local.crypt->secret_len);\n                LIBSSH2_FREE(session, secret);\n            }\n        }\n        _libssh2_debug(session, LIBSSH2_TRACE_KEX,\n                       \"Client to Server IV and Key calculated\");\n\n        if (session->remote.crypt->dtor) {\n            /* Cleanup any existing cipher */\n            session->remote.crypt->dtor(session,\n                                        &session->remote.crypt_abstract);\n        }\n\n        if (session->remote.crypt->init) {\n            unsigned char *iv = NULL, *secret = NULL;\n            int free_iv = 0, free_secret = 0;\n\n            LIBSSH2_KEX_METHOD_DIFFIE_HELLMAN_SHA256_HASH(iv,\n                                                          session->remote.crypt->\n                                                          iv_len, \"B\");\n            if (!iv) {\n                ret = LIBSSH2_ERROR_KEX_FAILURE;\n                goto clean_exit;\n            }\n            LIBSSH2_KEX_METHOD_DIFFIE_HELLMAN_SHA256_HASH(secret,\n                                                          session->remote.crypt->\n                                                          secret_len, \"D\");\n            if (!secret) {\n                LIBSSH2_FREE(session, iv);\n                ret = LIBSSH2_ERROR_KEX_FAILURE;\n                goto clean_exit;\n            }\n            if (session->remote.crypt->\n                init(session, session->remote.crypt, iv, &free_iv, secret,\n                     &free_secret, 0, &session->remote.crypt_abstract)) {\n                LIBSSH2_FREE(session, iv);\n                LIBSSH2_FREE(session, secret);\n                ret = LIBSSH2_ERROR_KEX_FAILURE;\n                goto clean_exit;\n            }\n\n            if (free_iv) {\n                memset(iv, 0, session->remote.crypt->iv_len);\n                LIBSSH2_FREE(session, iv);\n            }\n\n            if (free_secret) {\n                memset(secret, 0, session->remote.crypt->secret_len);\n                LIBSSH2_FREE(session, secret);\n            }\n        }\n        _libssh2_debug(session, LIBSSH2_TRACE_KEX,\n                       \"Server to Client IV and Key calculated\");\n\n        if (session->local.mac->dtor) {\n            session->local.mac->dtor(session, &session->local.mac_abstract);\n        }\n\n        if (session->local.mac->init) {\n            unsigned char *key = NULL;\n            int free_key = 0;\n\n            LIBSSH2_KEX_METHOD_DIFFIE_HELLMAN_SHA256_HASH(key,\n                                                          session->local.mac->\n                                                          key_len, \"E\");\n            if (!key) {\n                ret = LIBSSH2_ERROR_KEX_FAILURE;\n                goto clean_exit;\n            }\n            session->local.mac->init(session, key, &free_key,\n                                     &session->local.mac_abstract);\n\n            if (free_key) {\n                memset(key, 0, session->local.mac->key_len);\n                LIBSSH2_FREE(session, key);\n            }\n        }\n        _libssh2_debug(session, LIBSSH2_TRACE_KEX,\n                       \"Client to Server HMAC Key calculated\");\n\n        if (session->remote.mac->dtor) {\n            session->remote.mac->dtor(session, &session->remote.mac_abstract);\n        }\n\n        if (session->remote.mac->init) {\n            unsigned char *key = NULL;\n            int free_key = 0;\n\n            LIBSSH2_KEX_METHOD_DIFFIE_HELLMAN_SHA256_HASH(key,\n                                                          session->remote.mac->\n                                                          key_len, \"F\");\n            if (!key) {\n                ret = LIBSSH2_ERROR_KEX_FAILURE;\n                goto clean_exit;\n            }\n            session->remote.mac->init(session, key, &free_key,\n                                      &session->remote.mac_abstract);\n\n            if (free_key) {\n                memset(key, 0, session->remote.mac->key_len);\n                LIBSSH2_FREE(session, key);\n            }\n        }\n        _libssh2_debug(session, LIBSSH2_TRACE_KEX,\n                       \"Server to Client HMAC Key calculated\");\n\n        /* Initialize compression for each direction */\n\n        /* Cleanup any existing compression */\n        if (session->local.comp && session->local.comp->dtor) {\n            session->local.comp->dtor(session, 1,\n                                      &session->local.comp_abstract);\n        }\n\n        if (session->local.comp && session->local.comp->init) {\n            if (session->local.comp->init(session, 1,\n                                          &session->local.comp_abstract)) {\n                ret = LIBSSH2_ERROR_KEX_FAILURE;\n                goto clean_exit;\n            }\n        }\n        _libssh2_debug(session, LIBSSH2_TRACE_KEX,\n                       \"Client to Server compression initialized\");\n\n        if (session->remote.comp && session->remote.comp->dtor) {\n            session->remote.comp->dtor(session, 0,\n                                       &session->remote.comp_abstract);\n        }\n\n        if (session->remote.comp && session->remote.comp->init) {\n            if (session->remote.comp->init(session, 0,\n                                           &session->remote.comp_abstract)) {\n                ret = LIBSSH2_ERROR_KEX_FAILURE;\n                goto clean_exit;\n            }\n        }\n        _libssh2_debug(session, LIBSSH2_TRACE_KEX,\n                       \"Server to Client compression initialized\");\n\n    }\n\n  clean_exit:\n    _libssh2_bn_free(exchange_state->x);\n    exchange_state->x = NULL;\n    _libssh2_bn_free(exchange_state->e);\n    exchange_state->e = NULL;\n    _libssh2_bn_free(exchange_state->f);\n    exchange_state->f = NULL;\n    _libssh2_bn_free(exchange_state->k);\n    exchange_state->k = NULL;\n    _libssh2_bn_ctx_free(exchange_state->ctx);\n    exchange_state->ctx = NULL;\n\n    if (exchange_state->e_packet) {\n        LIBSSH2_FREE(session, exchange_state->e_packet);\n        exchange_state->e_packet = NULL;\n    }\n\n    if (exchange_state->s_packet) {\n        LIBSSH2_FREE(session, exchange_state->s_packet);\n        exchange_state->s_packet = NULL;\n    }\n\n    if (exchange_state->k_value) {\n        LIBSSH2_FREE(session, exchange_state->k_value);\n        exchange_state->k_value = NULL;\n    }\n\n    exchange_state->state = libssh2_NB_state_idle;\n\n    return ret;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146274,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int diffie_hellman_sha1(LIBSSH2_SESSION *session,\n                               _libssh2_bn *g,\n                               _libssh2_bn *p,\n                               int group_order,\n                               unsigned char packet_type_init,\n                               unsigned char packet_type_reply,\n                               unsigned char *midhash,\n                               unsigned long midhash_len,\n                               kmdhgGPshakex_state_t *exchange_state)\n{\n    int ret = 0;\n    int rc;\n    libssh2_sha1_ctx exchange_hash_ctx;\n\n    if (exchange_state->state == libssh2_NB_state_idle) {\n        /* Setup initial values */\n        exchange_state->e_packet = NULL;\n        exchange_state->s_packet = NULL;\n        exchange_state->k_value = NULL;\n        exchange_state->ctx = _libssh2_bn_ctx_new();\n        exchange_state->x = _libssh2_bn_init(); /* Random from client */\n        exchange_state->e = _libssh2_bn_init(); /* g^x mod p */\n        exchange_state->f = _libssh2_bn_init_from_bin(); /* g^(Random from server) mod p */\n        exchange_state->k = _libssh2_bn_init(); /* The shared secret: f^x mod p */\n\n        /* Zero the whole thing out */\n        memset(&exchange_state->req_state, 0, sizeof(packet_require_state_t));\n\n        /* Generate x and e */\n        _libssh2_bn_rand(exchange_state->x, group_order, 0, -1);\n        _libssh2_bn_mod_exp(exchange_state->e, g, exchange_state->x, p,\n                            exchange_state->ctx);\n\n        /* Send KEX init */\n        /* packet_type(1) + String Length(4) + leading 0(1) */\n        exchange_state->e_packet_len =\n            _libssh2_bn_bytes(exchange_state->e) + 6;\n        if (_libssh2_bn_bits(exchange_state->e) % 8) {\n            /* Leading 00 not needed */\n            exchange_state->e_packet_len--;\n        }\n\n        exchange_state->e_packet =\n            LIBSSH2_ALLOC(session, exchange_state->e_packet_len);\n        if (!exchange_state->e_packet) {\n            ret = _libssh2_error(session, LIBSSH2_ERROR_ALLOC,\n                                 \"Out of memory error\");\n            goto clean_exit;\n        }\n        exchange_state->e_packet[0] = packet_type_init;\n        _libssh2_htonu32(exchange_state->e_packet + 1,\n                         exchange_state->e_packet_len - 5);\n        if (_libssh2_bn_bits(exchange_state->e) % 8) {\n            _libssh2_bn_to_bin(exchange_state->e,\n                               exchange_state->e_packet + 5);\n        } else {\n            exchange_state->e_packet[5] = 0;\n            _libssh2_bn_to_bin(exchange_state->e,\n                               exchange_state->e_packet + 6);\n        }\n\n        _libssh2_debug(session, LIBSSH2_TRACE_KEX, \"Sending KEX packet %d\",\n                       (int) packet_type_init);\n        exchange_state->state = libssh2_NB_state_created;\n    }\n\n    if (exchange_state->state == libssh2_NB_state_created) {\n        rc = _libssh2_transport_send(session, exchange_state->e_packet,\n                                     exchange_state->e_packet_len,\n                                     NULL, 0);\n        if (rc == LIBSSH2_ERROR_EAGAIN) {\n            return rc;\n        } else if (rc) {\n            ret = _libssh2_error(session, rc,\n                                 \"Unable to send KEX init message\");\n            goto clean_exit;\n        }\n        exchange_state->state = libssh2_NB_state_sent;\n    }\n\n    if (exchange_state->state == libssh2_NB_state_sent) {\n        if (session->burn_optimistic_kexinit) {\n            /* The first KEX packet to come along will be the guess initially\n             * sent by the server.  That guess turned out to be wrong so we\n             * need to silently ignore it */\n            int burn_type;\n\n            _libssh2_debug(session, LIBSSH2_TRACE_KEX,\n                           \"Waiting for badly guessed KEX packet (to be ignored)\");\n            burn_type =\n                _libssh2_packet_burn(session, &exchange_state->burn_state);\n            if (burn_type == LIBSSH2_ERROR_EAGAIN) {\n                return burn_type;\n            } else if (burn_type <= 0) {\n                /* Failed to receive a packet */\n                ret = burn_type;\n                goto clean_exit;\n            }\n            session->burn_optimistic_kexinit = 0;\n\n            _libssh2_debug(session, LIBSSH2_TRACE_KEX,\n                           \"Burnt packet of type: %02x\",\n                           (unsigned int) burn_type);\n        }\n\n        exchange_state->state = libssh2_NB_state_sent1;\n    }\n\n    if (exchange_state->state == libssh2_NB_state_sent1) {\n        /* Wait for KEX reply */\n        rc = _libssh2_packet_require(session, packet_type_reply,\n                                     &exchange_state->s_packet,\n                                     &exchange_state->s_packet_len, 0, NULL,\n                                     0, &exchange_state->req_state);\n        if (rc == LIBSSH2_ERROR_EAGAIN) {\n            return rc;\n        }\n        if (rc) {\n            ret = _libssh2_error(session, LIBSSH2_ERROR_TIMEOUT,\n                                 \"Timed out waiting for KEX reply\");\n            goto clean_exit;\n        }\n\n        /* Parse KEXDH_REPLY */\n        exchange_state->s = exchange_state->s_packet + 1;\n\n        session->server_hostkey_len = _libssh2_ntohu32(exchange_state->s);\n        exchange_state->s += 4;\n\n        if (session->server_hostkey)\n            LIBSSH2_FREE(session, session->server_hostkey);\n\n        session->server_hostkey =\n            LIBSSH2_ALLOC(session, session->server_hostkey_len);\n        if (!session->server_hostkey) {\n            ret = _libssh2_error(session, LIBSSH2_ERROR_ALLOC,\n                                 \"Unable to allocate memory for a copy \"\n                                 \"of the host key\");\n            goto clean_exit;\n        }\n        memcpy(session->server_hostkey, exchange_state->s,\n               session->server_hostkey_len);\n        exchange_state->s += session->server_hostkey_len;\n\n#if LIBSSH2_MD5\n        {\n            libssh2_md5_ctx fingerprint_ctx;\n\n            if (libssh2_md5_init(&fingerprint_ctx)) {\n                libssh2_md5_update(fingerprint_ctx, session->server_hostkey,\n                                   session->server_hostkey_len);\n                libssh2_md5_final(fingerprint_ctx,\n                                  session->server_hostkey_md5);\n                session->server_hostkey_md5_valid = TRUE;\n            }\n            else {\n                session->server_hostkey_md5_valid = FALSE;\n            }\n        }\n#ifdef LIBSSH2DEBUG\n        {\n            char fingerprint[50], *fprint = fingerprint;\n            int i;\n            for(i = 0; i < 16; i++, fprint += 3) {\n                snprintf(fprint, 4, \"%02x:\", session->server_hostkey_md5[i]);\n            }\n            *(--fprint) = '\\0';\n            _libssh2_debug(session, LIBSSH2_TRACE_KEX,\n                           \"Server's MD5 Fingerprint: %s\", fingerprint);\n        }\n#endif /* LIBSSH2DEBUG */\n#endif /* ! LIBSSH2_MD5 */\n\n        {\n            libssh2_sha1_ctx fingerprint_ctx;\n\n            if (libssh2_sha1_init(&fingerprint_ctx)) {\n                libssh2_sha1_update(fingerprint_ctx, session->server_hostkey,\n                                    session->server_hostkey_len);\n                libssh2_sha1_final(fingerprint_ctx,\n                                   session->server_hostkey_sha1);\n                session->server_hostkey_sha1_valid = TRUE;\n            }\n            else {\n                session->server_hostkey_sha1_valid = FALSE;\n            }\n        }\n#ifdef LIBSSH2DEBUG\n        {\n            char fingerprint[64], *fprint = fingerprint;\n            int i;\n\n            for(i = 0; i < 20; i++, fprint += 3) {\n                snprintf(fprint, 4, \"%02x:\", session->server_hostkey_sha1[i]);\n            }\n            *(--fprint) = '\\0';\n            _libssh2_debug(session, LIBSSH2_TRACE_KEX,\n                           \"Server's SHA1 Fingerprint: %s\", fingerprint);\n        }\n#endif /* LIBSSH2DEBUG */\n\n        if (session->hostkey->init(session, session->server_hostkey,\n                                   session->server_hostkey_len,\n                                   &session->server_hostkey_abstract)) {\n            ret = _libssh2_error(session, LIBSSH2_ERROR_HOSTKEY_INIT,\n                                 \"Unable to initialize hostkey importer\");\n            goto clean_exit;\n        }\n\n        exchange_state->f_value_len = _libssh2_ntohu32(exchange_state->s);\n        exchange_state->s += 4;\n        exchange_state->f_value = exchange_state->s;\n        exchange_state->s += exchange_state->f_value_len;\n        _libssh2_bn_from_bin(exchange_state->f, exchange_state->f_value_len,\n                             exchange_state->f_value);\n\n        exchange_state->h_sig_len = _libssh2_ntohu32(exchange_state->s);\n        exchange_state->s += 4;\n        exchange_state->h_sig = exchange_state->s;\n\n        /* Compute the shared secret */\n        _libssh2_bn_mod_exp(exchange_state->k, exchange_state->f,\n                            exchange_state->x, p, exchange_state->ctx);\n        exchange_state->k_value_len = _libssh2_bn_bytes(exchange_state->k) + 5;\n        if (_libssh2_bn_bits(exchange_state->k) % 8) {\n            /* don't need leading 00 */\n            exchange_state->k_value_len--;\n        }\n        exchange_state->k_value =\n            LIBSSH2_ALLOC(session, exchange_state->k_value_len);\n        if (!exchange_state->k_value) {\n            ret = _libssh2_error(session, LIBSSH2_ERROR_ALLOC,\n                                 \"Unable to allocate buffer for K\");\n            goto clean_exit;\n        }\n        _libssh2_htonu32(exchange_state->k_value,\n                         exchange_state->k_value_len - 4);\n        if (_libssh2_bn_bits(exchange_state->k) % 8) {\n            _libssh2_bn_to_bin(exchange_state->k, exchange_state->k_value + 4);\n        } else {\n            exchange_state->k_value[4] = 0;\n            _libssh2_bn_to_bin(exchange_state->k, exchange_state->k_value + 5);\n        }\n\n        exchange_state->exchange_hash = (void*)&exchange_hash_ctx;\n        libssh2_sha1_init(&exchange_hash_ctx);\n\n        if (session->local.banner) {\n            _libssh2_htonu32(exchange_state->h_sig_comp,\n                             strlen((char *) session->local.banner) - 2);\n            libssh2_sha1_update(exchange_hash_ctx,\n                                exchange_state->h_sig_comp, 4);\n            libssh2_sha1_update(exchange_hash_ctx,\n                                (char *) session->local.banner,\n                                strlen((char *) session->local.banner) - 2);\n        } else {\n            _libssh2_htonu32(exchange_state->h_sig_comp,\n                             sizeof(LIBSSH2_SSH_DEFAULT_BANNER) - 1);\n            libssh2_sha1_update(exchange_hash_ctx,\n                                exchange_state->h_sig_comp, 4);\n            libssh2_sha1_update(exchange_hash_ctx,\n                                LIBSSH2_SSH_DEFAULT_BANNER,\n                                sizeof(LIBSSH2_SSH_DEFAULT_BANNER) - 1);\n        }\n\n        _libssh2_htonu32(exchange_state->h_sig_comp,\n                         strlen((char *) session->remote.banner));\n        libssh2_sha1_update(exchange_hash_ctx,\n                            exchange_state->h_sig_comp, 4);\n        libssh2_sha1_update(exchange_hash_ctx,\n                            session->remote.banner,\n                            strlen((char *) session->remote.banner));\n\n        _libssh2_htonu32(exchange_state->h_sig_comp,\n                         session->local.kexinit_len);\n        libssh2_sha1_update(exchange_hash_ctx,\n                            exchange_state->h_sig_comp, 4);\n        libssh2_sha1_update(exchange_hash_ctx,\n                            session->local.kexinit,\n                            session->local.kexinit_len);\n\n        _libssh2_htonu32(exchange_state->h_sig_comp,\n                         session->remote.kexinit_len);\n        libssh2_sha1_update(exchange_hash_ctx,\n                            exchange_state->h_sig_comp, 4);\n        libssh2_sha1_update(exchange_hash_ctx,\n                            session->remote.kexinit,\n                            session->remote.kexinit_len);\n\n        _libssh2_htonu32(exchange_state->h_sig_comp,\n                         session->server_hostkey_len);\n        libssh2_sha1_update(exchange_hash_ctx,\n                            exchange_state->h_sig_comp, 4);\n        libssh2_sha1_update(exchange_hash_ctx,\n                            session->server_hostkey,\n                            session->server_hostkey_len);\n\n        if (packet_type_init == SSH_MSG_KEX_DH_GEX_INIT) {\n            /* diffie-hellman-group-exchange hashes additional fields */\n#ifdef LIBSSH2_DH_GEX_NEW\n            _libssh2_htonu32(exchange_state->h_sig_comp,\n                             LIBSSH2_DH_GEX_MINGROUP);\n            _libssh2_htonu32(exchange_state->h_sig_comp + 4,\n                             LIBSSH2_DH_GEX_OPTGROUP);\n            _libssh2_htonu32(exchange_state->h_sig_comp + 8,\n                             LIBSSH2_DH_GEX_MAXGROUP);\n            libssh2_sha1_update(exchange_hash_ctx,\n                                exchange_state->h_sig_comp, 12);\n#else\n            _libssh2_htonu32(exchange_state->h_sig_comp,\n                             LIBSSH2_DH_GEX_OPTGROUP);\n            libssh2_sha1_update(exchange_hash_ctx,\n                                exchange_state->h_sig_comp, 4);\n#endif\n        }\n\n        if (midhash) {\n            libssh2_sha1_update(exchange_hash_ctx, midhash,\n                                midhash_len);\n        }\n\n        libssh2_sha1_update(exchange_hash_ctx,\n                            exchange_state->e_packet + 1,\n                            exchange_state->e_packet_len - 1);\n\n        _libssh2_htonu32(exchange_state->h_sig_comp,\n                         exchange_state->f_value_len);\n        libssh2_sha1_update(exchange_hash_ctx,\n                            exchange_state->h_sig_comp, 4);\n        libssh2_sha1_update(exchange_hash_ctx,\n                            exchange_state->f_value,\n                            exchange_state->f_value_len);\n\n        libssh2_sha1_update(exchange_hash_ctx,\n                            exchange_state->k_value,\n                            exchange_state->k_value_len);\n\n        libssh2_sha1_final(exchange_hash_ctx,\n                           exchange_state->h_sig_comp);\n\n        if (session->hostkey->\n            sig_verify(session, exchange_state->h_sig,\n                       exchange_state->h_sig_len, exchange_state->h_sig_comp,\n                       20, &session->server_hostkey_abstract)) {\n            ret = _libssh2_error(session, LIBSSH2_ERROR_HOSTKEY_SIGN,\n                                 \"Unable to verify hostkey signature\");\n            goto clean_exit;\n        }\n\n        _libssh2_debug(session, LIBSSH2_TRACE_KEX, \"Sending NEWKEYS message\");\n        exchange_state->c = SSH_MSG_NEWKEYS;\n\n        exchange_state->state = libssh2_NB_state_sent2;\n    }\n\n    if (exchange_state->state == libssh2_NB_state_sent2) {\n        rc = _libssh2_transport_send(session, &exchange_state->c, 1, NULL, 0);\n        if (rc == LIBSSH2_ERROR_EAGAIN) {\n            return rc;\n        } else if (rc) {\n            ret = _libssh2_error(session, rc, \"Unable to send NEWKEYS message\");\n            goto clean_exit;\n        }\n\n        exchange_state->state = libssh2_NB_state_sent3;\n    }\n\n    if (exchange_state->state == libssh2_NB_state_sent3) {\n        rc = _libssh2_packet_require(session, SSH_MSG_NEWKEYS,\n                                     &exchange_state->tmp,\n                                     &exchange_state->tmp_len, 0, NULL, 0,\n                                     &exchange_state->req_state);\n        if (rc == LIBSSH2_ERROR_EAGAIN) {\n            return rc;\n        } else if (rc) {\n            ret = _libssh2_error(session, rc, \"Timed out waiting for NEWKEYS\");\n            goto clean_exit;\n        }\n        /* The first key exchange has been performed,\n           switch to active crypt/comp/mac mode */\n        session->state |= LIBSSH2_STATE_NEWKEYS;\n        _libssh2_debug(session, LIBSSH2_TRACE_KEX, \"Received NEWKEYS message\");\n\n        /* This will actually end up being just packet_type(1)\n           for this packet type anyway */\n        LIBSSH2_FREE(session, exchange_state->tmp);\n\n        if (!session->session_id) {\n            session->session_id = LIBSSH2_ALLOC(session, SHA_DIGEST_LENGTH);\n            if (!session->session_id) {\n                ret = _libssh2_error(session, LIBSSH2_ERROR_ALLOC,\n                                     \"Unable to allocate buffer for SHA digest\");\n                goto clean_exit;\n            }\n            memcpy(session->session_id, exchange_state->h_sig_comp,\n                   SHA_DIGEST_LENGTH);\n            session->session_id_len = SHA_DIGEST_LENGTH;\n            _libssh2_debug(session, LIBSSH2_TRACE_KEX, \"session_id calculated\");\n        }\n\n        /* Cleanup any existing cipher */\n        if (session->local.crypt->dtor) {\n            session->local.crypt->dtor(session,\n                                       &session->local.crypt_abstract);\n        }\n\n        /* Calculate IV/Secret/Key for each direction */\n        if (session->local.crypt->init) {\n            unsigned char *iv = NULL, *secret = NULL;\n            int free_iv = 0, free_secret = 0;\n\n            LIBSSH2_KEX_METHOD_DIFFIE_HELLMAN_SHA1_HASH(iv,\n                                                        session->local.crypt->\n                                                        iv_len, \"A\");\n            if (!iv) {\n                ret = -1;\n                goto clean_exit;\n            }\n            LIBSSH2_KEX_METHOD_DIFFIE_HELLMAN_SHA1_HASH(secret,\n                                                        session->local.crypt->\n                                                        secret_len, \"C\");\n            if (!secret) {\n                LIBSSH2_FREE(session, iv);\n                ret = LIBSSH2_ERROR_KEX_FAILURE;\n                goto clean_exit;\n            }\n            if (session->local.crypt->\n                init(session, session->local.crypt, iv, &free_iv, secret,\n                     &free_secret, 1, &session->local.crypt_abstract)) {\n                LIBSSH2_FREE(session, iv);\n                LIBSSH2_FREE(session, secret);\n                ret = LIBSSH2_ERROR_KEX_FAILURE;\n                goto clean_exit;\n            }\n\n            if (free_iv) {\n                memset(iv, 0, session->local.crypt->iv_len);\n                LIBSSH2_FREE(session, iv);\n            }\n\n            if (free_secret) {\n                memset(secret, 0, session->local.crypt->secret_len);\n                LIBSSH2_FREE(session, secret);\n            }\n        }\n        _libssh2_debug(session, LIBSSH2_TRACE_KEX,\n                       \"Client to Server IV and Key calculated\");\n\n        if (session->remote.crypt->dtor) {\n            /* Cleanup any existing cipher */\n            session->remote.crypt->dtor(session,\n                                        &session->remote.crypt_abstract);\n        }\n\n        if (session->remote.crypt->init) {\n            unsigned char *iv = NULL, *secret = NULL;\n            int free_iv = 0, free_secret = 0;\n\n            LIBSSH2_KEX_METHOD_DIFFIE_HELLMAN_SHA1_HASH(iv,\n                                                        session->remote.crypt->\n                                                        iv_len, \"B\");\n            if (!iv) {\n                ret = LIBSSH2_ERROR_KEX_FAILURE;\n                goto clean_exit;\n            }\n            LIBSSH2_KEX_METHOD_DIFFIE_HELLMAN_SHA1_HASH(secret,\n                                                        session->remote.crypt->\n                                                        secret_len, \"D\");\n            if (!secret) {\n                LIBSSH2_FREE(session, iv);\n                ret = LIBSSH2_ERROR_KEX_FAILURE;\n                goto clean_exit;\n            }\n            if (session->remote.crypt->\n                init(session, session->remote.crypt, iv, &free_iv, secret,\n                     &free_secret, 0, &session->remote.crypt_abstract)) {\n                LIBSSH2_FREE(session, iv);\n                LIBSSH2_FREE(session, secret);\n                ret = LIBSSH2_ERROR_KEX_FAILURE;\n                goto clean_exit;\n            }\n\n            if (free_iv) {\n                memset(iv, 0, session->remote.crypt->iv_len);\n                LIBSSH2_FREE(session, iv);\n            }\n\n            if (free_secret) {\n                memset(secret, 0, session->remote.crypt->secret_len);\n                LIBSSH2_FREE(session, secret);\n            }\n        }\n        _libssh2_debug(session, LIBSSH2_TRACE_KEX,\n                       \"Server to Client IV and Key calculated\");\n\n        if (session->local.mac->dtor) {\n            session->local.mac->dtor(session, &session->local.mac_abstract);\n        }\n\n        if (session->local.mac->init) {\n            unsigned char *key = NULL;\n            int free_key = 0;\n\n            LIBSSH2_KEX_METHOD_DIFFIE_HELLMAN_SHA1_HASH(key,\n                                                        session->local.mac->\n                                                        key_len, \"E\");\n            if (!key) {\n                ret = LIBSSH2_ERROR_KEX_FAILURE;\n                goto clean_exit;\n            }\n            session->local.mac->init(session, key, &free_key,\n                                     &session->local.mac_abstract);\n\n            if (free_key) {\n                memset(key, 0, session->local.mac->key_len);\n                LIBSSH2_FREE(session, key);\n            }\n        }\n        _libssh2_debug(session, LIBSSH2_TRACE_KEX,\n                       \"Client to Server HMAC Key calculated\");\n\n        if (session->remote.mac->dtor) {\n            session->remote.mac->dtor(session, &session->remote.mac_abstract);\n        }\n\n        if (session->remote.mac->init) {\n            unsigned char *key = NULL;\n            int free_key = 0;\n\n            LIBSSH2_KEX_METHOD_DIFFIE_HELLMAN_SHA1_HASH(key,\n                                                        session->remote.mac->\n                                                        key_len, \"F\");\n            if (!key) {\n                ret = LIBSSH2_ERROR_KEX_FAILURE;\n                goto clean_exit;\n            }\n            session->remote.mac->init(session, key, &free_key,\n                                      &session->remote.mac_abstract);\n\n            if (free_key) {\n                memset(key, 0, session->remote.mac->key_len);\n                LIBSSH2_FREE(session, key);\n            }\n        }\n        _libssh2_debug(session, LIBSSH2_TRACE_KEX,\n                       \"Server to Client HMAC Key calculated\");\n\n        /* Initialize compression for each direction */\n\n        /* Cleanup any existing compression */\n        if (session->local.comp && session->local.comp->dtor) {\n            session->local.comp->dtor(session, 1,\n                                      &session->local.comp_abstract);\n        }\n\n        if (session->local.comp && session->local.comp->init) {\n            if (session->local.comp->init(session, 1,\n                                          &session->local.comp_abstract)) {\n                ret = LIBSSH2_ERROR_KEX_FAILURE;\n                goto clean_exit;\n            }\n        }\n        _libssh2_debug(session, LIBSSH2_TRACE_KEX,\n                       \"Client to Server compression initialized\");\n\n        if (session->remote.comp && session->remote.comp->dtor) {\n            session->remote.comp->dtor(session, 0,\n                                       &session->remote.comp_abstract);\n        }\n\n        if (session->remote.comp && session->remote.comp->init) {\n            if (session->remote.comp->init(session, 0,\n                                           &session->remote.comp_abstract)) {\n                ret = LIBSSH2_ERROR_KEX_FAILURE;\n                goto clean_exit;\n            }\n        }\n        _libssh2_debug(session, LIBSSH2_TRACE_KEX,\n                       \"Server to Client compression initialized\");\n\n    }\n\n  clean_exit:\n    _libssh2_bn_free(exchange_state->x);\n    exchange_state->x = NULL;\n    _libssh2_bn_free(exchange_state->e);\n    exchange_state->e = NULL;\n    _libssh2_bn_free(exchange_state->f);\n    exchange_state->f = NULL;\n    _libssh2_bn_free(exchange_state->k);\n    exchange_state->k = NULL;\n    _libssh2_bn_ctx_free(exchange_state->ctx);\n    exchange_state->ctx = NULL;\n\n    if (exchange_state->e_packet) {\n        LIBSSH2_FREE(session, exchange_state->e_packet);\n        exchange_state->e_packet = NULL;\n    }\n\n    if (exchange_state->s_packet) {\n        LIBSSH2_FREE(session, exchange_state->s_packet);\n        exchange_state->s_packet = NULL;\n    }\n\n    if (exchange_state->k_value) {\n        LIBSSH2_FREE(session, exchange_state->k_value);\n        exchange_state->k_value = NULL;\n    }\n\n    exchange_state->state = libssh2_NB_state_idle;\n\n    return ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146275,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static char *ptr_to_id(char *buf, char *end, void *ptr, struct printf_spec spec)\n{\n\tunsigned long hashval;\n\n\tif (unlikely(!have_filled_random_ptr_key)) {\n\t\tspec.field_width = 2 * sizeof(ptr);\n\t\t/* string length must be less than default_width */\n\t\treturn string(buf, end, \"(ptrval)\", spec);\n\t}\n\n#ifdef CONFIG_64BIT\n\thashval = (unsigned long)siphash_1u64((u64)ptr, &ptr_key);\n\t/*\n\t * Mask off the first 32 bits, this makes explicit that we have\n\t * modified the address (and 32 bits is plenty for a unique ID).\n\t */\n\thashval = hashval & 0xffffffff;\n#else\n\thashval = (unsigned long)siphash_1u32((u32)ptr, &ptr_key);\n#endif\n\treturn pointer_string(buf, end, (const void *)hashval, spec);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146320,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static char *ptr_to_id(char *buf, char *end, void *ptr, struct printf_spec spec)\n{\n\tconst char *str = sizeof(ptr) == 8 ? \"(____ptrval____)\" : \"(ptrval)\";\n\tunsigned long hashval;\n\n\tif (unlikely(!have_filled_random_ptr_key)) {\n\t\tspec.field_width = 2 * sizeof(ptr);\n\t\t/* string length must be less than default_width */\n\t\treturn string(buf, end, str, spec);\n\t}\n\n#ifdef CONFIG_64BIT\n\thashval = (unsigned long)siphash_1u64((u64)ptr, &ptr_key);\n\t/*\n\t * Mask off the first 32 bits, this makes explicit that we have\n\t * modified the address (and 32 bits is plenty for a unique ID).\n\t */\n\thashval = hashval & 0xffffffff;\n#else\n\thashval = (unsigned long)siphash_1u32((u32)ptr, &ptr_key);\n#endif\n\treturn pointer_string(buf, end, (const void *)hashval, spec);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146321,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "std::string get_wml_location(const std::string &filename, const std::string &current_dir)\n{\n\tDBG_FS << \"Looking for '\" << filename << \"'.\" << std::endl;\n\n\tassert(game_config::path.empty() == false);\n\n\tstd::string result;\n\n\tif (filename.empty()) {\n\t\tLOG_FS << \"  invalid filename\" << std::endl;\n\t\treturn result;\n\t}\n\n\tif (filename.find(\"..\") != std::string::npos) {\n\t\tERR_FS << \"Illegal path '\" << filename << \"' (\\\"..\\\" not allowed).\" << std::endl;\n\t\treturn result;\n\t}\n\n\tbool already_found = false;\n\n\tif (filename[0] == '~')\n\t{\n\t\t// If the filename starts with '~', look in the user data directory.\n\t\tresult = get_user_data_dir() + \"/data/\" + filename.substr(1);\n\t\tDBG_FS << \"  trying '\" << result << \"'\" << std::endl;\n\n\t\talready_found = file_exists(result) || is_directory(result);\n\t}\n\telse if (filename.size() >= 2 && filename[0] == '.' && filename[1] == '/')\n\t{\n\t\t// If the filename begins with a \"./\", look in the same directory\n\t\t// as the file currently being preprocessed.\n\n\t\tif (!current_dir.empty())\n\t\t{\n\t\t\tresult = current_dir;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = game_config::path;\n\t\t}\n\n\t\tresult += filename.substr(2);\n\t}\n\telse if (!game_config::path.empty())\n\t\tresult = game_config::path + \"/data/\" + filename;\n\n\tDBG_FS << \"  trying '\" << result << \"'\" << std::endl;\n\n\tif (result.empty() ||\n\t    (!already_found && !file_exists(result) && !is_directory(result)))\n\t{\n\t\tDBG_FS << \"  not found\" << std::endl;\n\t\tresult.clear();\n\t}\n\telse\n\t\tDBG_FS << \"  found: '\" << result << \"'\" << std::endl;\n\n\treturn result;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146452,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "std::string get_wml_location(const std::string &filename, const std::string &current_dir)\n{\n\tif (!is_legal_file(filename))\n\t\treturn std::string();\n\n\tassert(game_config::path.empty() == false);\n\n\tpath fpath(filename);\n\tpath result;\n\n\tif (filename[0] == '~')\n\t{\n\t\tresult /= get_user_data_path() / \"data\" / filename.substr(1);\n\t\tDBG_FS << \"  trying '\" << result.string() << \"'\\n\";\n\t} else if (*fpath.begin() == \".\") {\n\t\tif (!current_dir.empty()) {\n\t\t\tresult /= path(current_dir);\n\t\t} else {\n\t\t\tresult /= path(game_config::path) / \"data\";\n\t\t}\n\n\t\tresult /= filename;\n\t} else if (!game_config::path.empty()) {\n\t\tresult /= path(game_config::path) / \"data\" / filename;\n\t}\n\tif (result.empty() || !file_exists(result)) {\n\t\tDBG_FS << \"  not found\\n\";\n\t\tresult.clear();\n\t} else\n\t\tDBG_FS << \"  found: '\" << result.string() << \"'\\n\";\n\n\treturn result.string();\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146453,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "CURLcode Curl_follow(struct Curl_easy *data,\n                     char *newurl,    /* the Location: string */\n                     followtype type) /* see transfer.h */\n{\n#ifdef CURL_DISABLE_HTTP\n  (void)data;\n  (void)newurl;\n  (void)type;\n  /* Location: following will not happen when HTTP is disabled */\n  return CURLE_TOO_MANY_REDIRECTS;\n#else\n\n  /* Location: redirect */\n  bool disallowport = FALSE;\n  bool reachedmax = FALSE;\n  CURLUcode uc;\n\n  DEBUGASSERT(type != FOLLOW_NONE);\n\n  if(type == FOLLOW_REDIR) {\n    if((data->set.maxredirs != -1) &&\n       (data->state.followlocation >= data->set.maxredirs)) {\n      reachedmax = TRUE;\n      type = FOLLOW_FAKE; /* switch to fake to store the would-be-redirected\n                             to URL */\n    }\n    else {\n      /* mark the next request as a followed location: */\n      data->state.this_is_a_follow = TRUE;\n\n      data->state.followlocation++; /* count location-followers */\n\n      if(data->set.http_auto_referer) {\n        /* We are asked to automatically set the previous URL as the referer\n           when we get the next URL. We pick the ->url field, which may or may\n           not be 100% correct */\n\n        if(data->state.referer_alloc) {\n          Curl_safefree(data->state.referer);\n          data->state.referer_alloc = FALSE;\n        }\n\n        data->state.referer = strdup(data->state.url);\n        if(!data->state.referer)\n          return CURLE_OUT_OF_MEMORY;\n        data->state.referer_alloc = TRUE; /* yes, free this later */\n      }\n    }\n  }\n\n  if((type != FOLLOW_RETRY) &&\n     (data->req.httpcode != 401) && (data->req.httpcode != 407) &&\n     Curl_is_absolute_url(newurl, NULL, MAX_SCHEME_LEN))\n    /* If this is not redirect due to a 401 or 407 response and an absolute\n       URL: don't allow a custom port number */\n    disallowport = TRUE;\n\n  DEBUGASSERT(data->state.uh);\n  uc = curl_url_set(data->state.uh, CURLUPART_URL, newurl,\n                    (type == FOLLOW_FAKE) ? CURLU_NON_SUPPORT_SCHEME :\n                    ((type == FOLLOW_REDIR) ? CURLU_URLENCODE : 0) );\n  if(uc) {\n    if(type != FOLLOW_FAKE)\n      return Curl_uc_to_curlcode(uc);\n\n    /* the URL could not be parsed for some reason, but since this is FAKE\n       mode, just duplicate the field as-is */\n    newurl = strdup(newurl);\n    if(!newurl)\n      return CURLE_OUT_OF_MEMORY;\n  }\n  else {\n\n    uc = curl_url_get(data->state.uh, CURLUPART_URL, &newurl, 0);\n    if(uc)\n      return Curl_uc_to_curlcode(uc);\n  }\n\n  if(type == FOLLOW_FAKE) {\n    /* we're only figuring out the new url if we would've followed locations\n       but now we're done so we can get out! */\n    data->info.wouldredirect = newurl;\n\n    if(reachedmax) {\n      failf(data, \"Maximum (%ld) redirects followed\", data->set.maxredirs);\n      return CURLE_TOO_MANY_REDIRECTS;\n    }\n    return CURLE_OK;\n  }\n\n  if(disallowport)\n    data->state.allow_port = FALSE;\n\n  if(data->state.url_alloc)\n    Curl_safefree(data->state.url);\n\n  data->state.url = newurl;\n  data->state.url_alloc = TRUE;\n\n  infof(data, \"Issue another request to this URL: '%s'\\n\", data->state.url);\n\n  /*\n   * We get here when the HTTP code is 300-399 (and 401). We need to perform\n   * differently based on exactly what return code there was.\n   *\n   * News from 7.10.6: we can also get here on a 401 or 407, in case we act on\n   * a HTTP (proxy-) authentication scheme other than Basic.\n   */\n  switch(data->info.httpcode) {\n    /* 401 - Act on a WWW-Authenticate, we keep on moving and do the\n       Authorization: XXXX header in the HTTP request code snippet */\n    /* 407 - Act on a Proxy-Authenticate, we keep on moving and do the\n       Proxy-Authorization: XXXX header in the HTTP request code snippet */\n    /* 300 - Multiple Choices */\n    /* 306 - Not used */\n    /* 307 - Temporary Redirect */\n  default:  /* for all above (and the unknown ones) */\n    /* Some codes are explicitly mentioned since I've checked RFC2616 and they\n     * seem to be OK to POST to.\n     */\n    break;\n  case 301: /* Moved Permanently */\n    /* (quote from RFC7231, section 6.4.2)\n     *\n     * Note: For historical reasons, a user agent MAY change the request\n     * method from POST to GET for the subsequent request.  If this\n     * behavior is undesired, the 307 (Temporary Redirect) status code\n     * can be used instead.\n     *\n     * ----\n     *\n     * Many webservers expect this, so these servers often answers to a POST\n     * request with an error page. To be sure that libcurl gets the page that\n     * most user agents would get, libcurl has to force GET.\n     *\n     * This behavior is forbidden by RFC1945 and the obsolete RFC2616, and\n     * can be overridden with CURLOPT_POSTREDIR.\n     */\n    if((data->state.httpreq == HTTPREQ_POST\n        || data->state.httpreq == HTTPREQ_POST_FORM\n        || data->state.httpreq == HTTPREQ_POST_MIME)\n       && !(data->set.keep_post & CURL_REDIR_POST_301)) {\n      infof(data, \"Switch from POST to GET\\n\");\n      data->state.httpreq = HTTPREQ_GET;\n    }\n    break;\n  case 302: /* Found */\n    /* (quote from RFC7231, section 6.4.3)\n     *\n     * Note: For historical reasons, a user agent MAY change the request\n     * method from POST to GET for the subsequent request.  If this\n     * behavior is undesired, the 307 (Temporary Redirect) status code\n     * can be used instead.\n     *\n     * ----\n     *\n     * Many webservers expect this, so these servers often answers to a POST\n     * request with an error page. To be sure that libcurl gets the page that\n     * most user agents would get, libcurl has to force GET.\n     *\n     * This behavior is forbidden by RFC1945 and the obsolete RFC2616, and\n     * can be overridden with CURLOPT_POSTREDIR.\n     */\n    if((data->state.httpreq == HTTPREQ_POST\n        || data->state.httpreq == HTTPREQ_POST_FORM\n        || data->state.httpreq == HTTPREQ_POST_MIME)\n       && !(data->set.keep_post & CURL_REDIR_POST_302)) {\n      infof(data, \"Switch from POST to GET\\n\");\n      data->state.httpreq = HTTPREQ_GET;\n    }\n    break;\n\n  case 303: /* See Other */\n    /* 'See Other' location is not the resource but a substitute for the\n     * resource. In this case we switch the method to GET/HEAD, unless the\n     * method is POST and the user specified to keep it as POST.\n     * https://github.com/curl/curl/issues/5237#issuecomment-614641049\n     */\n    if(data->state.httpreq != HTTPREQ_GET &&\n       ((data->state.httpreq != HTTPREQ_POST &&\n         data->state.httpreq != HTTPREQ_POST_FORM &&\n         data->state.httpreq != HTTPREQ_POST_MIME) ||\n        !(data->set.keep_post & CURL_REDIR_POST_303))) {\n      data->state.httpreq = HTTPREQ_GET;\n      data->set.upload = false;\n      infof(data, \"Switch to %s\\n\",\n            data->set.opt_no_body?\"HEAD\":\"GET\");\n    }\n    break;\n  case 304: /* Not Modified */\n    /* 304 means we did a conditional request and it was \"Not modified\".\n     * We shouldn't get any Location: header in this response!\n     */\n    break;\n  case 305: /* Use Proxy */\n    /* (quote from RFC2616, section 10.3.6):\n     * \"The requested resource MUST be accessed through the proxy given\n     * by the Location field. The Location field gives the URI of the\n     * proxy.  The recipient is expected to repeat this single request\n     * via the proxy. 305 responses MUST only be generated by origin\n     * servers.\"\n     */\n    break;\n  }\n  Curl_pgrsTime(data, TIMER_REDIRECT);\n  Curl_pgrsResetTransferSizes(data);\n\n  return CURLE_OK;\n#endif /* CURL_DISABLE_HTTP */\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146584,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "CURLcode Curl_follow(struct Curl_easy *data,\n                     char *newurl,    /* the Location: string */\n                     followtype type) /* see transfer.h */\n{\n#ifdef CURL_DISABLE_HTTP\n  (void)data;\n  (void)newurl;\n  (void)type;\n  /* Location: following will not happen when HTTP is disabled */\n  return CURLE_TOO_MANY_REDIRECTS;\n#else\n\n  /* Location: redirect */\n  bool disallowport = FALSE;\n  bool reachedmax = FALSE;\n  CURLUcode uc;\n\n  DEBUGASSERT(type != FOLLOW_NONE);\n\n  if(type == FOLLOW_REDIR) {\n    if((data->set.maxredirs != -1) &&\n       (data->state.followlocation >= data->set.maxredirs)) {\n      reachedmax = TRUE;\n      type = FOLLOW_FAKE; /* switch to fake to store the would-be-redirected\n                             to URL */\n    }\n    else {\n      /* mark the next request as a followed location: */\n      data->state.this_is_a_follow = TRUE;\n\n      data->state.followlocation++; /* count location-followers */\n\n      if(data->set.http_auto_referer) {\n        CURLU *u;\n        char *referer;\n\n        /* We are asked to automatically set the previous URL as the referer\n           when we get the next URL. We pick the ->url field, which may or may\n           not be 100% correct */\n\n        if(data->state.referer_alloc) {\n          Curl_safefree(data->state.referer);\n          data->state.referer_alloc = FALSE;\n        }\n\n        /* Make a copy of the URL without crenditals and fragment */\n        u = curl_url();\n        if(!u)\n          return CURLE_OUT_OF_MEMORY;\n\n        uc = curl_url_set(u, CURLUPART_URL, data->state.url, 0);\n        if(!uc)\n          uc = curl_url_set(u, CURLUPART_FRAGMENT, NULL, 0);\n        if(!uc)\n          uc = curl_url_set(u, CURLUPART_USER, NULL, 0);\n        if(!uc)\n          uc = curl_url_set(u, CURLUPART_PASSWORD, NULL, 0);\n        if(!uc)\n          uc = curl_url_get(u, CURLUPART_URL, &referer, 0);\n\n        curl_url_cleanup(u);\n\n        if(uc || referer == NULL)\n          return CURLE_OUT_OF_MEMORY;\n\n        data->state.referer = referer;\n        data->state.referer_alloc = TRUE; /* yes, free this later */\n      }\n    }\n  }\n\n  if((type != FOLLOW_RETRY) &&\n     (data->req.httpcode != 401) && (data->req.httpcode != 407) &&\n     Curl_is_absolute_url(newurl, NULL, MAX_SCHEME_LEN))\n    /* If this is not redirect due to a 401 or 407 response and an absolute\n       URL: don't allow a custom port number */\n    disallowport = TRUE;\n\n  DEBUGASSERT(data->state.uh);\n  uc = curl_url_set(data->state.uh, CURLUPART_URL, newurl,\n                    (type == FOLLOW_FAKE) ? CURLU_NON_SUPPORT_SCHEME :\n                    ((type == FOLLOW_REDIR) ? CURLU_URLENCODE : 0) );\n  if(uc) {\n    if(type != FOLLOW_FAKE)\n      return Curl_uc_to_curlcode(uc);\n\n    /* the URL could not be parsed for some reason, but since this is FAKE\n       mode, just duplicate the field as-is */\n    newurl = strdup(newurl);\n    if(!newurl)\n      return CURLE_OUT_OF_MEMORY;\n  }\n  else {\n\n    uc = curl_url_get(data->state.uh, CURLUPART_URL, &newurl, 0);\n    if(uc)\n      return Curl_uc_to_curlcode(uc);\n  }\n\n  if(type == FOLLOW_FAKE) {\n    /* we're only figuring out the new url if we would've followed locations\n       but now we're done so we can get out! */\n    data->info.wouldredirect = newurl;\n\n    if(reachedmax) {\n      failf(data, \"Maximum (%ld) redirects followed\", data->set.maxredirs);\n      return CURLE_TOO_MANY_REDIRECTS;\n    }\n    return CURLE_OK;\n  }\n\n  if(disallowport)\n    data->state.allow_port = FALSE;\n\n  if(data->state.url_alloc)\n    Curl_safefree(data->state.url);\n\n  data->state.url = newurl;\n  data->state.url_alloc = TRUE;\n\n  infof(data, \"Issue another request to this URL: '%s'\\n\", data->state.url);\n\n  /*\n   * We get here when the HTTP code is 300-399 (and 401). We need to perform\n   * differently based on exactly what return code there was.\n   *\n   * News from 7.10.6: we can also get here on a 401 or 407, in case we act on\n   * a HTTP (proxy-) authentication scheme other than Basic.\n   */\n  switch(data->info.httpcode) {\n    /* 401 - Act on a WWW-Authenticate, we keep on moving and do the\n       Authorization: XXXX header in the HTTP request code snippet */\n    /* 407 - Act on a Proxy-Authenticate, we keep on moving and do the\n       Proxy-Authorization: XXXX header in the HTTP request code snippet */\n    /* 300 - Multiple Choices */\n    /* 306 - Not used */\n    /* 307 - Temporary Redirect */\n  default:  /* for all above (and the unknown ones) */\n    /* Some codes are explicitly mentioned since I've checked RFC2616 and they\n     * seem to be OK to POST to.\n     */\n    break;\n  case 301: /* Moved Permanently */\n    /* (quote from RFC7231, section 6.4.2)\n     *\n     * Note: For historical reasons, a user agent MAY change the request\n     * method from POST to GET for the subsequent request.  If this\n     * behavior is undesired, the 307 (Temporary Redirect) status code\n     * can be used instead.\n     *\n     * ----\n     *\n     * Many webservers expect this, so these servers often answers to a POST\n     * request with an error page. To be sure that libcurl gets the page that\n     * most user agents would get, libcurl has to force GET.\n     *\n     * This behavior is forbidden by RFC1945 and the obsolete RFC2616, and\n     * can be overridden with CURLOPT_POSTREDIR.\n     */\n    if((data->state.httpreq == HTTPREQ_POST\n        || data->state.httpreq == HTTPREQ_POST_FORM\n        || data->state.httpreq == HTTPREQ_POST_MIME)\n       && !(data->set.keep_post & CURL_REDIR_POST_301)) {\n      infof(data, \"Switch from POST to GET\\n\");\n      data->state.httpreq = HTTPREQ_GET;\n    }\n    break;\n  case 302: /* Found */\n    /* (quote from RFC7231, section 6.4.3)\n     *\n     * Note: For historical reasons, a user agent MAY change the request\n     * method from POST to GET for the subsequent request.  If this\n     * behavior is undesired, the 307 (Temporary Redirect) status code\n     * can be used instead.\n     *\n     * ----\n     *\n     * Many webservers expect this, so these servers often answers to a POST\n     * request with an error page. To be sure that libcurl gets the page that\n     * most user agents would get, libcurl has to force GET.\n     *\n     * This behavior is forbidden by RFC1945 and the obsolete RFC2616, and\n     * can be overridden with CURLOPT_POSTREDIR.\n     */\n    if((data->state.httpreq == HTTPREQ_POST\n        || data->state.httpreq == HTTPREQ_POST_FORM\n        || data->state.httpreq == HTTPREQ_POST_MIME)\n       && !(data->set.keep_post & CURL_REDIR_POST_302)) {\n      infof(data, \"Switch from POST to GET\\n\");\n      data->state.httpreq = HTTPREQ_GET;\n    }\n    break;\n\n  case 303: /* See Other */\n    /* 'See Other' location is not the resource but a substitute for the\n     * resource. In this case we switch the method to GET/HEAD, unless the\n     * method is POST and the user specified to keep it as POST.\n     * https://github.com/curl/curl/issues/5237#issuecomment-614641049\n     */\n    if(data->state.httpreq != HTTPREQ_GET &&\n       ((data->state.httpreq != HTTPREQ_POST &&\n         data->state.httpreq != HTTPREQ_POST_FORM &&\n         data->state.httpreq != HTTPREQ_POST_MIME) ||\n        !(data->set.keep_post & CURL_REDIR_POST_303))) {\n      data->state.httpreq = HTTPREQ_GET;\n      data->set.upload = false;\n      infof(data, \"Switch to %s\\n\",\n            data->set.opt_no_body?\"HEAD\":\"GET\");\n    }\n    break;\n  case 304: /* Not Modified */\n    /* 304 means we did a conditional request and it was \"Not modified\".\n     * We shouldn't get any Location: header in this response!\n     */\n    break;\n  case 305: /* Use Proxy */\n    /* (quote from RFC2616, section 10.3.6):\n     * \"The requested resource MUST be accessed through the proxy given\n     * by the Location field. The Location field gives the URI of the\n     * proxy.  The recipient is expected to repeat this single request\n     * via the proxy. 305 responses MUST only be generated by origin\n     * servers.\"\n     */\n    break;\n  }\n  Curl_pgrsTime(data, TIMER_REDIRECT);\n  Curl_pgrsResetTransferSizes(data);\n\n  return CURLE_OK;\n#endif /* CURL_DISABLE_HTTP */\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146585,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int exif_process_IFD_in_TIFF(image_info_type *ImageInfo, size_t dir_offset, int section_index TSRMLS_DC)\n{\n\tint i, sn, num_entries, sub_section_index = 0;\n\tunsigned char *dir_entry;\n\tchar tagname[64];\n\tsize_t ifd_size, dir_size, entry_offset, next_offset, entry_length, entry_value=0, fgot;\n\tint entry_tag , entry_type;\n\ttag_table_type tag_table = exif_get_tag_table(section_index);\n\n\tif (ImageInfo->ifd_nesting_level > MAX_IFD_NESTING_LEVEL) {\n                return FALSE;\n        }\n\n\tif (ImageInfo->FileSize >= dir_offset+2) {\n\t\tsn = exif_file_sections_add(ImageInfo, M_PSEUDO, 2, NULL);\n#ifdef EXIF_DEBUG\n\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Read from TIFF: filesize(x%04X), IFD dir(x%04X + x%04X)\", ImageInfo->FileSize, dir_offset, 2);\n#endif\n\t\tphp_stream_seek(ImageInfo->infile, dir_offset, SEEK_SET); /* we do not know the order of sections */\n\t\tphp_stream_read(ImageInfo->infile, (char*)ImageInfo->file.list[sn].data, 2);\n\t\tnum_entries = php_ifd_get16u(ImageInfo->file.list[sn].data, ImageInfo->motorola_intel);\n\t\tdir_size = 2/*num dir entries*/ +12/*length of entry*/*num_entries +4/* offset to next ifd (points to thumbnail or NULL)*/;\n\t\tif (ImageInfo->FileSize >= dir_offset+dir_size) {\n#ifdef EXIF_DEBUG\n\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Read from TIFF: filesize(x%04X), IFD dir(x%04X + x%04X), IFD entries(%d)\", ImageInfo->FileSize, dir_offset+2, dir_size-2, num_entries);\n#endif\n\t\t\tif (exif_file_sections_realloc(ImageInfo, sn, dir_size TSRMLS_CC)) {\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\tphp_stream_read(ImageInfo->infile, (char*)(ImageInfo->file.list[sn].data+2), dir_size-2);\n\t\t\t/*exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Dump: %s\", exif_char_dump(ImageInfo->file.list[sn].data, dir_size, 0));*/\n\t\t\tnext_offset = php_ifd_get32u(ImageInfo->file.list[sn].data + dir_size - 4, ImageInfo->motorola_intel);\n#ifdef EXIF_DEBUG\n\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Read from TIFF done, next offset x%04X\", next_offset);\n#endif\n\t\t\t/* now we have the directory we can look how long it should be */\n\t\t\tifd_size = dir_size;\n\t\t\tfor(i=0;i<num_entries;i++) {\n\t\t\t\tdir_entry \t = ImageInfo->file.list[sn].data+2+i*12;\n\t\t\t\tentry_tag    = php_ifd_get16u(dir_entry+0, ImageInfo->motorola_intel);\n\t\t\t\tentry_type   = php_ifd_get16u(dir_entry+2, ImageInfo->motorola_intel);\n\t\t\t\tif (entry_type > NUM_FORMATS) {\n\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Read from TIFF: tag(0x%04X,%12s): Illegal format code 0x%04X, switching to BYTE\", entry_tag, exif_get_tagname(entry_tag, tagname, -12, tag_table TSRMLS_CC), entry_type);\n\t\t\t\t\t/* Since this is repeated in exif_process_IFD_TAG make it a notice here */\n\t\t\t\t\t/* and make it a warning in the exif_process_IFD_TAG which is called    */\n\t\t\t\t\t/* elsewhere. */\n\t\t\t\t\tentry_type = TAG_FMT_BYTE;\n\t\t\t\t\t/*The next line would break the image on writeback: */\n\t\t\t\t\t/* php_ifd_set16u(dir_entry+2, entry_type, ImageInfo->motorola_intel);*/\n\t\t\t\t}\n\t\t\t\tentry_length = php_ifd_get32u(dir_entry+4, ImageInfo->motorola_intel) * php_tiff_bytes_per_format[entry_type];\n\t\t\t\tif (entry_length <= 4) {\n\t\t\t\t\tswitch(entry_type) {\n\t\t\t\t\t\tcase TAG_FMT_USHORT:\n\t\t\t\t\t\t\tentry_value  = php_ifd_get16u(dir_entry+8, ImageInfo->motorola_intel);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase TAG_FMT_SSHORT:\n\t\t\t\t\t\t\tentry_value  = php_ifd_get16s(dir_entry+8, ImageInfo->motorola_intel);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase TAG_FMT_ULONG:\n\t\t\t\t\t\t\tentry_value  = php_ifd_get32u(dir_entry+8, ImageInfo->motorola_intel);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase TAG_FMT_SLONG:\n\t\t\t\t\t\t\tentry_value  = php_ifd_get32s(dir_entry+8, ImageInfo->motorola_intel);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tswitch(entry_tag) {\n\t\t\t\t\t\tcase TAG_IMAGEWIDTH:\n\t\t\t\t\t\tcase TAG_COMP_IMAGE_WIDTH:\n\t\t\t\t\t\t\tImageInfo->Width  = entry_value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase TAG_IMAGEHEIGHT:\n\t\t\t\t\t\tcase TAG_COMP_IMAGE_HEIGHT:\n\t\t\t\t\t\t\tImageInfo->Height = entry_value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase TAG_PHOTOMETRIC_INTERPRETATION:\n\t\t\t\t\t\t\tswitch (entry_value) {\n\t\t\t\t\t\t\t\tcase PMI_BLACK_IS_ZERO:\n\t\t\t\t\t\t\t\tcase PMI_WHITE_IS_ZERO:\n\t\t\t\t\t\t\t\tcase PMI_TRANSPARENCY_MASK:\n\t\t\t\t\t\t\t\t\tImageInfo->IsColor = 0;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase PMI_RGB:\n\t\t\t\t\t\t\t\tcase PMI_PALETTE_COLOR:\n\t\t\t\t\t\t\t\tcase PMI_SEPARATED:\n\t\t\t\t\t\t\t\tcase PMI_YCBCR:\n\t\t\t\t\t\t\t\tcase PMI_CIELAB:\n\t\t\t\t\t\t\t\t\tImageInfo->IsColor = 1;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tentry_offset = php_ifd_get32u(dir_entry+8, ImageInfo->motorola_intel);\n\t\t\t\t\t/* if entry needs expading ifd cache and entry is at end of current ifd cache. */\n\t\t\t\t\t/* otherwise there may be huge holes between two entries */\n\t\t\t\t\tif (entry_offset + entry_length > dir_offset + ifd_size\n\t\t\t\t\t  && entry_offset == dir_offset + ifd_size) {\n\t\t\t\t\t\tifd_size = entry_offset + entry_length - dir_offset;\n#ifdef EXIF_DEBUG\n\t\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Resize struct: x%04X + x%04X - x%04X = x%04X\", entry_offset, entry_length, dir_offset, ifd_size);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ImageInfo->FileSize >= dir_offset + ImageInfo->file.list[sn].size) {\n\t\t\t\tif (ifd_size > dir_size) {\n\t\t\t\t\tif (dir_offset + ifd_size > ImageInfo->FileSize) {\n\t\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, \"Error in TIFF: filesize(x%04X) less than size of IFD(x%04X + x%04X)\", ImageInfo->FileSize, dir_offset, ifd_size);\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\t}\n\t\t\t\t\tif (exif_file_sections_realloc(ImageInfo, sn, ifd_size TSRMLS_CC)) {\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\t}\n\t\t\t\t\t/* read values not stored in directory itself */\n#ifdef EXIF_DEBUG\n\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Read from TIFF: filesize(x%04X), IFD(x%04X + x%04X)\", ImageInfo->FileSize, dir_offset, ifd_size);\n#endif\n\t\t\t\t\tphp_stream_read(ImageInfo->infile, (char*)(ImageInfo->file.list[sn].data+dir_size), ifd_size-dir_size);\n#ifdef EXIF_DEBUG\n\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Read from TIFF, done\");\n#endif\n\t\t\t\t}\n\t\t\t\t/* now process the tags */\n\t\t\t\tfor(i=0;i<num_entries;i++) {\n\t\t\t\t\tdir_entry \t = ImageInfo->file.list[sn].data+2+i*12;\n\t\t\t\t\tentry_tag    = php_ifd_get16u(dir_entry+0, ImageInfo->motorola_intel);\n\t\t\t\t\tentry_type   = php_ifd_get16u(dir_entry+2, ImageInfo->motorola_intel);\n\t\t\t\t\t/*entry_length = php_ifd_get32u(dir_entry+4, ImageInfo->motorola_intel);*/\n\t\t\t\t\tif (entry_tag == TAG_EXIF_IFD_POINTER ||\n\t\t\t\t\t\tentry_tag == TAG_INTEROP_IFD_POINTER ||\n\t\t\t\t\t\tentry_tag == TAG_GPS_IFD_POINTER ||\n\t\t\t\t\t\tentry_tag == TAG_SUB_IFD\n\t\t\t\t\t) {\n\t\t\t\t\t\tswitch(entry_tag) {\n\t\t\t\t\t\t\tcase TAG_EXIF_IFD_POINTER:\n\t\t\t\t\t\t\t\tImageInfo->sections_found |= FOUND_EXIF;\n\t\t\t\t\t\t\t\tsub_section_index = SECTION_EXIF;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TAG_GPS_IFD_POINTER:\n\t\t\t\t\t\t\t\tImageInfo->sections_found |= FOUND_GPS;\n\t\t\t\t\t\t\t\tsub_section_index = SECTION_GPS;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TAG_INTEROP_IFD_POINTER:\n\t\t\t\t\t\t\t\tImageInfo->sections_found |= FOUND_INTEROP;\n\t\t\t\t\t\t\t\tsub_section_index = SECTION_INTEROP;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TAG_SUB_IFD:\n\t\t\t\t\t\t\t\tImageInfo->sections_found |= FOUND_THUMBNAIL;\n\t\t\t\t\t\t\t\tsub_section_index = SECTION_THUMBNAIL;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tentry_offset = php_ifd_get32u(dir_entry+8, ImageInfo->motorola_intel);\n#ifdef EXIF_DEBUG\n\t\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Next IFD: %s @x%04X\", exif_get_sectionname(sub_section_index), entry_offset);\n#endif\n\t\t\t\t\t\tImageInfo->ifd_nesting_level++;\n\t\t\t\t\t\texif_process_IFD_in_TIFF(ImageInfo, entry_offset, sub_section_index TSRMLS_CC);\n\t\t\t\t\t\tif (section_index!=SECTION_THUMBNAIL && entry_tag==TAG_SUB_IFD) {\n\t\t\t\t\t\t\tif (ImageInfo->Thumbnail.filetype != IMAGE_FILETYPE_UNKNOWN\n\t\t\t\t\t\t\t&&  ImageInfo->Thumbnail.size\n\t\t\t\t\t\t\t&&  ImageInfo->Thumbnail.offset\n\t\t\t\t\t\t\t&&  ImageInfo->read_thumbnail\n\t\t\t\t\t\t\t) {\n#ifdef EXIF_DEBUG\n\t\t\t\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"%s THUMBNAIL @0x%04X + 0x%04X\", ImageInfo->Thumbnail.data ? \"Ignore\" : \"Read\", ImageInfo->Thumbnail.offset, ImageInfo->Thumbnail.size);\n#endif\n\t\t\t\t\t\t\t\tif (!ImageInfo->Thumbnail.data) {\n\t\t\t\t\t\t\t\t\tImageInfo->Thumbnail.data = safe_emalloc(ImageInfo->Thumbnail.size, 1, 0);\n\t\t\t\t\t\t\t\t\tphp_stream_seek(ImageInfo->infile, ImageInfo->Thumbnail.offset, SEEK_SET);\n\t\t\t\t\t\t\t\t\tfgot = php_stream_read(ImageInfo->infile, ImageInfo->Thumbnail.data, ImageInfo->Thumbnail.size);\n\t\t\t\t\t\t\t\t\tif (fgot < ImageInfo->Thumbnail.size) {\n\t\t\t\t\t\t\t\t\t\tEXIF_ERRLOG_THUMBEOF(ImageInfo)\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\texif_thumbnail_build(ImageInfo TSRMLS_CC);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n#ifdef EXIF_DEBUG\n\t\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Next IFD: %s done\", exif_get_sectionname(sub_section_index));\n#endif\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!exif_process_IFD_TAG(ImageInfo, (char*)dir_entry,\n\t\t\t\t\t\t\t\t\t\t\t\t  (char*)(ImageInfo->file.list[sn].data-dir_offset),\n\t\t\t\t\t\t\t\t\t\t\t\t  ifd_size, 0, section_index, 0, tag_table TSRMLS_CC)) {\n\t\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* If we had a thumbnail in a SUB_IFD we have ANOTHER image in NEXT IFD */\n\t\t\t\tif (next_offset && section_index != SECTION_THUMBNAIL) {\n\t\t\t\t\t/* this should be a thumbnail IFD */\n\t\t\t\t\t/* the thumbnail itself is stored at Tag=StripOffsets */\n#ifdef EXIF_DEBUG\n\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Read next IFD (THUMBNAIL) at x%04X\", next_offset);\n#endif\n\t\t\t\t\tImageInfo->ifd_nesting_level++;\n\t\t\t\t\texif_process_IFD_in_TIFF(ImageInfo, next_offset, SECTION_THUMBNAIL TSRMLS_CC);\n#ifdef EXIF_DEBUG\n\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"%s THUMBNAIL @0x%04X + 0x%04X\", ImageInfo->Thumbnail.data ? \"Ignore\" : \"Read\", ImageInfo->Thumbnail.offset, ImageInfo->Thumbnail.size);\n#endif\n\t\t\t\t\tif (!ImageInfo->Thumbnail.data && ImageInfo->Thumbnail.offset && ImageInfo->Thumbnail.size && ImageInfo->read_thumbnail) {\n\t\t\t\t\t\tImageInfo->Thumbnail.data = safe_emalloc(ImageInfo->Thumbnail.size, 1, 0);\n\t\t\t\t\t\tphp_stream_seek(ImageInfo->infile, ImageInfo->Thumbnail.offset, SEEK_SET);\n\t\t\t\t\t\tfgot = php_stream_read(ImageInfo->infile, ImageInfo->Thumbnail.data, ImageInfo->Thumbnail.size);\n\t\t\t\t\t\tif (fgot < ImageInfo->Thumbnail.size) {\n\t\t\t\t\t\t\tEXIF_ERRLOG_THUMBEOF(ImageInfo)\n\t\t\t\t\t\t}\n\t\t\t\t\t\texif_thumbnail_build(ImageInfo TSRMLS_CC);\n\t\t\t\t\t}\n#ifdef EXIF_DEBUG\n\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Read next IFD (THUMBNAIL) done\");\n#endif\n\t\t\t\t}\n\t\t\t\treturn TRUE;\n\t\t\t} else {\n\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, \"Error in TIFF: filesize(x%04X) less than size of IFD(x%04X)\", ImageInfo->FileSize, dir_offset+ImageInfo->file.list[sn].size);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t} else {\n\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, \"Error in TIFF: filesize(x%04X) less than size of IFD dir(x%04X)\", ImageInfo->FileSize, dir_offset+dir_size);\n\t\t\treturn FALSE;\n\t\t}\n\t} else {\n\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, \"Error in TIFF: filesize(x%04X) less than start of IFD dir(x%04X)\", ImageInfo->FileSize, dir_offset+2);\n\t\treturn FALSE;\n\t}\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146620,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int exif_process_IFD_in_TIFF(image_info_type *ImageInfo, size_t dir_offset, int section_index TSRMLS_DC)\n{\n\tint i, sn, num_entries, sub_section_index = 0;\n\tunsigned char *dir_entry;\n\tchar tagname[64];\n\tsize_t ifd_size, dir_size, entry_offset, next_offset, entry_length, entry_value=0, fgot;\n\tint entry_tag , entry_type;\n\ttag_table_type tag_table = exif_get_tag_table(section_index);\n\n\tif (ImageInfo->ifd_nesting_level > MAX_IFD_NESTING_LEVEL) {\n                return FALSE;\n        }\n\n\tif (ImageInfo->FileSize >= dir_offset+2) {\n\t\tsn = exif_file_sections_add(ImageInfo, M_PSEUDO, 2, NULL);\n#ifdef EXIF_DEBUG\n\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Read from TIFF: filesize(x%04X), IFD dir(x%04X + x%04X)\", ImageInfo->FileSize, dir_offset, 2);\n#endif\n\t\tphp_stream_seek(ImageInfo->infile, dir_offset, SEEK_SET); /* we do not know the order of sections */\n\t\tphp_stream_read(ImageInfo->infile, (char*)ImageInfo->file.list[sn].data, 2);\n\t\tnum_entries = php_ifd_get16u(ImageInfo->file.list[sn].data, ImageInfo->motorola_intel);\n\t\tdir_size = 2/*num dir entries*/ +12/*length of entry*/*num_entries +4/* offset to next ifd (points to thumbnail or NULL)*/;\n\t\tif (ImageInfo->FileSize >= dir_offset+dir_size) {\n#ifdef EXIF_DEBUG\n\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Read from TIFF: filesize(x%04X), IFD dir(x%04X + x%04X), IFD entries(%d)\", ImageInfo->FileSize, dir_offset+2, dir_size-2, num_entries);\n#endif\n\t\t\tif (exif_file_sections_realloc(ImageInfo, sn, dir_size TSRMLS_CC)) {\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\tphp_stream_read(ImageInfo->infile, (char*)(ImageInfo->file.list[sn].data+2), dir_size-2);\n\t\t\t/*exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Dump: %s\", exif_char_dump(ImageInfo->file.list[sn].data, dir_size, 0));*/\n\t\t\tnext_offset = php_ifd_get32u(ImageInfo->file.list[sn].data + dir_size - 4, ImageInfo->motorola_intel);\n#ifdef EXIF_DEBUG\n\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Read from TIFF done, next offset x%04X\", next_offset);\n#endif\n\t\t\t/* now we have the directory we can look how long it should be */\n\t\t\tifd_size = dir_size;\n\t\t\tfor(i=0;i<num_entries;i++) {\n\t\t\t\tdir_entry \t = ImageInfo->file.list[sn].data+2+i*12;\n\t\t\t\tentry_tag    = php_ifd_get16u(dir_entry+0, ImageInfo->motorola_intel);\n\t\t\t\tentry_type   = php_ifd_get16u(dir_entry+2, ImageInfo->motorola_intel);\n\t\t\t\tif (entry_type > NUM_FORMATS) {\n\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Read from TIFF: tag(0x%04X,%12s): Illegal format code 0x%04X, switching to BYTE\", entry_tag, exif_get_tagname(entry_tag, tagname, -12, tag_table TSRMLS_CC), entry_type);\n\t\t\t\t\t/* Since this is repeated in exif_process_IFD_TAG make it a notice here */\n\t\t\t\t\t/* and make it a warning in the exif_process_IFD_TAG which is called    */\n\t\t\t\t\t/* elsewhere. */\n\t\t\t\t\tentry_type = TAG_FMT_BYTE;\n\t\t\t\t\t/*The next line would break the image on writeback: */\n\t\t\t\t\t/* php_ifd_set16u(dir_entry+2, entry_type, ImageInfo->motorola_intel);*/\n\t\t\t\t}\n\t\t\t\tentry_length = php_ifd_get32u(dir_entry+4, ImageInfo->motorola_intel) * php_tiff_bytes_per_format[entry_type];\n\t\t\t\tif (entry_length <= 4) {\n\t\t\t\t\tswitch(entry_type) {\n\t\t\t\t\t\tcase TAG_FMT_USHORT:\n\t\t\t\t\t\t\tentry_value  = php_ifd_get16u(dir_entry+8, ImageInfo->motorola_intel);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase TAG_FMT_SSHORT:\n\t\t\t\t\t\t\tentry_value  = php_ifd_get16s(dir_entry+8, ImageInfo->motorola_intel);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase TAG_FMT_ULONG:\n\t\t\t\t\t\t\tentry_value  = php_ifd_get32u(dir_entry+8, ImageInfo->motorola_intel);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase TAG_FMT_SLONG:\n\t\t\t\t\t\t\tentry_value  = php_ifd_get32s(dir_entry+8, ImageInfo->motorola_intel);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tswitch(entry_tag) {\n\t\t\t\t\t\tcase TAG_IMAGEWIDTH:\n\t\t\t\t\t\tcase TAG_COMP_IMAGE_WIDTH:\n\t\t\t\t\t\t\tImageInfo->Width  = entry_value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase TAG_IMAGEHEIGHT:\n\t\t\t\t\t\tcase TAG_COMP_IMAGE_HEIGHT:\n\t\t\t\t\t\t\tImageInfo->Height = entry_value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase TAG_PHOTOMETRIC_INTERPRETATION:\n\t\t\t\t\t\t\tswitch (entry_value) {\n\t\t\t\t\t\t\t\tcase PMI_BLACK_IS_ZERO:\n\t\t\t\t\t\t\t\tcase PMI_WHITE_IS_ZERO:\n\t\t\t\t\t\t\t\tcase PMI_TRANSPARENCY_MASK:\n\t\t\t\t\t\t\t\t\tImageInfo->IsColor = 0;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase PMI_RGB:\n\t\t\t\t\t\t\t\tcase PMI_PALETTE_COLOR:\n\t\t\t\t\t\t\t\tcase PMI_SEPARATED:\n\t\t\t\t\t\t\t\tcase PMI_YCBCR:\n\t\t\t\t\t\t\t\tcase PMI_CIELAB:\n\t\t\t\t\t\t\t\t\tImageInfo->IsColor = 1;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tentry_offset = php_ifd_get32u(dir_entry+8, ImageInfo->motorola_intel);\n\t\t\t\t\t/* if entry needs expading ifd cache and entry is at end of current ifd cache. */\n\t\t\t\t\t/* otherwise there may be huge holes between two entries */\n\t\t\t\t\tif (entry_offset + entry_length > dir_offset + ifd_size\n\t\t\t\t\t  && entry_offset == dir_offset + ifd_size) {\n\t\t\t\t\t\tifd_size = entry_offset + entry_length - dir_offset;\n#ifdef EXIF_DEBUG\n\t\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Resize struct: x%04X + x%04X - x%04X = x%04X\", entry_offset, entry_length, dir_offset, ifd_size);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ImageInfo->FileSize >= dir_offset + ImageInfo->file.list[sn].size) {\n\t\t\t\tif (ifd_size > dir_size) {\n\t\t\t\t\tif (dir_offset + ifd_size > ImageInfo->FileSize) {\n\t\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, \"Error in TIFF: filesize(x%04X) less than size of IFD(x%04X + x%04X)\", ImageInfo->FileSize, dir_offset, ifd_size);\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\t}\n\t\t\t\t\tif (exif_file_sections_realloc(ImageInfo, sn, ifd_size TSRMLS_CC)) {\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\t}\n\t\t\t\t\t/* read values not stored in directory itself */\n#ifdef EXIF_DEBUG\n\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Read from TIFF: filesize(x%04X), IFD(x%04X + x%04X)\", ImageInfo->FileSize, dir_offset, ifd_size);\n#endif\n\t\t\t\t\tphp_stream_read(ImageInfo->infile, (char*)(ImageInfo->file.list[sn].data+dir_size), ifd_size-dir_size);\n#ifdef EXIF_DEBUG\n\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Read from TIFF, done\");\n#endif\n\t\t\t\t}\n\t\t\t\t/* now process the tags */\n\t\t\t\tfor(i=0;i<num_entries;i++) {\n\t\t\t\t\tdir_entry \t = ImageInfo->file.list[sn].data+2+i*12;\n\t\t\t\t\tentry_tag    = php_ifd_get16u(dir_entry+0, ImageInfo->motorola_intel);\n\t\t\t\t\tentry_type   = php_ifd_get16u(dir_entry+2, ImageInfo->motorola_intel);\n\t\t\t\t\t/*entry_length = php_ifd_get32u(dir_entry+4, ImageInfo->motorola_intel);*/\n\t\t\t\t\tif (entry_tag == TAG_EXIF_IFD_POINTER ||\n\t\t\t\t\t\tentry_tag == TAG_INTEROP_IFD_POINTER ||\n\t\t\t\t\t\tentry_tag == TAG_GPS_IFD_POINTER ||\n\t\t\t\t\t\tentry_tag == TAG_SUB_IFD\n\t\t\t\t\t) {\n\t\t\t\t\t\tswitch(entry_tag) {\n\t\t\t\t\t\t\tcase TAG_EXIF_IFD_POINTER:\n\t\t\t\t\t\t\t\tImageInfo->sections_found |= FOUND_EXIF;\n\t\t\t\t\t\t\t\tsub_section_index = SECTION_EXIF;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TAG_GPS_IFD_POINTER:\n\t\t\t\t\t\t\t\tImageInfo->sections_found |= FOUND_GPS;\n\t\t\t\t\t\t\t\tsub_section_index = SECTION_GPS;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TAG_INTEROP_IFD_POINTER:\n\t\t\t\t\t\t\t\tImageInfo->sections_found |= FOUND_INTEROP;\n\t\t\t\t\t\t\t\tsub_section_index = SECTION_INTEROP;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TAG_SUB_IFD:\n\t\t\t\t\t\t\t\tImageInfo->sections_found |= FOUND_THUMBNAIL;\n\t\t\t\t\t\t\t\tsub_section_index = SECTION_THUMBNAIL;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tentry_offset = php_ifd_get32u(dir_entry+8, ImageInfo->motorola_intel);\n#ifdef EXIF_DEBUG\n\t\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Next IFD: %s @x%04X\", exif_get_sectionname(sub_section_index), entry_offset);\n#endif\n\t\t\t\t\t\tImageInfo->ifd_nesting_level++;\n\t\t\t\t\t\texif_process_IFD_in_TIFF(ImageInfo, entry_offset, sub_section_index TSRMLS_CC);\n\t\t\t\t\t\tif (section_index!=SECTION_THUMBNAIL && entry_tag==TAG_SUB_IFD) {\n\t\t\t\t\t\t\tif (ImageInfo->Thumbnail.filetype != IMAGE_FILETYPE_UNKNOWN\n\t\t\t\t\t\t\t&&  ImageInfo->Thumbnail.size\n\t\t\t\t\t\t\t&&  ImageInfo->Thumbnail.offset\n\t\t\t\t\t\t\t&&  ImageInfo->read_thumbnail\n\t\t\t\t\t\t\t) {\n#ifdef EXIF_DEBUG\n\t\t\t\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"%s THUMBNAIL @0x%04X + 0x%04X\", ImageInfo->Thumbnail.data ? \"Ignore\" : \"Read\", ImageInfo->Thumbnail.offset, ImageInfo->Thumbnail.size);\n#endif\n\t\t\t\t\t\t\t\tif (!ImageInfo->Thumbnail.data) {\n\t\t\t\t\t\t\t\t\tImageInfo->Thumbnail.data = safe_emalloc(ImageInfo->Thumbnail.size, 1, 0);\n\t\t\t\t\t\t\t\t\tphp_stream_seek(ImageInfo->infile, ImageInfo->Thumbnail.offset, SEEK_SET);\n\t\t\t\t\t\t\t\t\tfgot = php_stream_read(ImageInfo->infile, ImageInfo->Thumbnail.data, ImageInfo->Thumbnail.size);\n\t\t\t\t\t\t\t\t\tif (fgot < ImageInfo->Thumbnail.size) {\n\t\t\t\t\t\t\t\t\t\tEXIF_ERRLOG_THUMBEOF(ImageInfo)\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\texif_thumbnail_build(ImageInfo TSRMLS_CC);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n#ifdef EXIF_DEBUG\n\t\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Next IFD: %s done\", exif_get_sectionname(sub_section_index));\n#endif\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!exif_process_IFD_TAG(ImageInfo, (char*)dir_entry,\n\t\t\t\t\t\t\t\t\t\t\t\t  (char*)(ImageInfo->file.list[sn].data-dir_offset),\n\t\t\t\t\t\t\t\t\t\t\t\t  ifd_size, 0, section_index, 0, tag_table TSRMLS_CC)) {\n\t\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* If we had a thumbnail in a SUB_IFD we have ANOTHER image in NEXT IFD */\n\t\t\t\tif (next_offset && section_index != SECTION_THUMBNAIL) {\n\t\t\t\t\t/* this should be a thumbnail IFD */\n\t\t\t\t\t/* the thumbnail itself is stored at Tag=StripOffsets */\n#ifdef EXIF_DEBUG\n\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Read next IFD (THUMBNAIL) at x%04X\", next_offset);\n#endif\n\t\t\t\t\tImageInfo->ifd_nesting_level++;\n\t\t\t\t\texif_process_IFD_in_TIFF(ImageInfo, next_offset, SECTION_THUMBNAIL TSRMLS_CC);\n#ifdef EXIF_DEBUG\n\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"%s THUMBNAIL @0x%04X + 0x%04X\", ImageInfo->Thumbnail.data ? \"Ignore\" : \"Read\", ImageInfo->Thumbnail.offset, ImageInfo->Thumbnail.size);\n#endif\n\t\t\t\t\tif (!ImageInfo->Thumbnail.data && ImageInfo->Thumbnail.offset && ImageInfo->Thumbnail.size && ImageInfo->read_thumbnail) {\n\t\t\t\t\t\tImageInfo->Thumbnail.data = safe_emalloc(ImageInfo->Thumbnail.size, 1, 0);\n\t\t\t\t\t\tphp_stream_seek(ImageInfo->infile, ImageInfo->Thumbnail.offset, SEEK_SET);\n\t\t\t\t\t\tfgot = php_stream_read(ImageInfo->infile, ImageInfo->Thumbnail.data, ImageInfo->Thumbnail.size);\n\t\t\t\t\t\tif (fgot < ImageInfo->Thumbnail.size) {\n\t\t\t\t\t\t\tEXIF_ERRLOG_THUMBEOF(ImageInfo)\n\t\t\t\t\t\t\tefree(ImageInfo->Thumbnail.data);\n\t\t\t\t\t\t\tImageInfo->Thumbnail.data = NULL;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\texif_thumbnail_build(ImageInfo TSRMLS_CC);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#ifdef EXIF_DEBUG\n\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Read next IFD (THUMBNAIL) done\");\n#endif\n\t\t\t\t}\n\t\t\t\treturn TRUE;\n\t\t\t} else {\n\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, \"Error in TIFF: filesize(x%04X) less than size of IFD(x%04X)\", ImageInfo->FileSize, dir_offset+ImageInfo->file.list[sn].size);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t} else {\n\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, \"Error in TIFF: filesize(x%04X) less than size of IFD dir(x%04X)\", ImageInfo->FileSize, dir_offset+dir_size);\n\t\t\treturn FALSE;\n\t\t}\n\t} else {\n\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, \"Error in TIFF: filesize(x%04X) less than start of IFD dir(x%04X)\", ImageInfo->FileSize, dir_offset+2);\n\t\treturn FALSE;\n\t}\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146621,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "mix_pool(unsigned char *pool)\n{\n  static unsigned char failsafe_digest[DIGESTLEN];\n  static int failsafe_digest_valid;\n\n  unsigned char *hashbuf = pool + POOLSIZE;\n  unsigned char *p, *pend;\n  int i, n;\n  SHA1_CONTEXT md;\n  unsigned int nburn;\n\n#if DIGESTLEN != 20\n#error must have a digest length of 20 for SHA-1\n#endif\n\n  gcry_assert (pool_is_locked);\n  _gcry_sha1_mixblock_init (&md);\n\n  /* Loop over the pool.  */\n  pend = pool + POOLSIZE;\n  memcpy (hashbuf, pend - DIGESTLEN, DIGESTLEN );\n  memcpy (hashbuf+DIGESTLEN, pool, BLOCKLEN-DIGESTLEN);\n  nburn = _gcry_sha1_mixblock (&md, hashbuf);\n  memcpy (pool, hashbuf, DIGESTLEN);\n\n  if (failsafe_digest_valid && pool == rndpool)\n    {\n      for (i=0; i < DIGESTLEN; i++)\n        pool[i] ^= failsafe_digest[i];\n    }\n\n  p = pool;\n  for (n=1; n < POOLBLOCKS; n++)\n    {\n      memcpy (hashbuf, p, DIGESTLEN);\n\n      p += DIGESTLEN;\n      if (p+DIGESTLEN+BLOCKLEN < pend)\n        memcpy (hashbuf+DIGESTLEN, p+DIGESTLEN, BLOCKLEN-DIGESTLEN);\n      else\n        {\n          unsigned char *pp = p + DIGESTLEN;\n\n          for (i=DIGESTLEN; i < BLOCKLEN; i++ )\n            {\n              if ( pp >= pend )\n                pp = pool;\n              hashbuf[i] = *pp++;\n\t    }\n\t}\n\n      _gcry_sha1_mixblock (&md, hashbuf);\n      memcpy(p, hashbuf, DIGESTLEN);\n    }\n\n  /* Our hash implementation does only leave small parts (64 bytes)\n     of the pool on the stack, so it is okay not to require secure\n     memory here.  Before we use this pool, it will be copied to the\n     help buffer anyway. */\n  if ( pool == rndpool)\n    {\n      _gcry_sha1_hash_buffer (failsafe_digest, pool, POOLSIZE);\n      failsafe_digest_valid = 1;\n    }\n\n  _gcry_burn_stack (nburn);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146662,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "mix_pool(unsigned char *pool)\n{\n  static unsigned char failsafe_digest[DIGESTLEN];\n  static int failsafe_digest_valid;\n\n  unsigned char *hashbuf = pool + POOLSIZE;\n  unsigned char *p, *pend;\n  int i, n;\n  SHA1_CONTEXT md;\n  unsigned int nburn;\n\n#if DIGESTLEN != 20\n#error must have a digest length of 20 for SHA-1\n#endif\n\n  gcry_assert (pool_is_locked);\n  _gcry_sha1_mixblock_init (&md);\n\n  /* pool_0 -> pool'.  */\n  pend = pool + POOLSIZE;\n  memcpy (hashbuf, pend - DIGESTLEN, DIGESTLEN);\n  memcpy (hashbuf+DIGESTLEN, pool, BLOCKLEN-DIGESTLEN);\n  nburn = _gcry_sha1_mixblock (&md, hashbuf);\n  memcpy (pool, hashbuf, DIGESTLEN);\n\n  if (failsafe_digest_valid && pool == rndpool)\n    {\n      for (i=0; i < DIGESTLEN; i++)\n        pool[i] ^= failsafe_digest[i];\n    }\n\n  /* Loop for the remaining iterations.  */\n  p = pool;\n  for (n=1; n < POOLBLOCKS; n++)\n    {\n      if (p + BLOCKLEN < pend)\n        memcpy (hashbuf, p, BLOCKLEN);\n      else\n        {\n          unsigned char *pp = p;\n\n          for (i=0; i < BLOCKLEN; i++ )\n            {\n              if ( pp >= pend )\n                pp = pool;\n              hashbuf[i] = *pp++;\n\t    }\n\t}\n\n      _gcry_sha1_mixblock (&md, hashbuf);\n      p += DIGESTLEN;\n      memcpy (p, hashbuf, DIGESTLEN);\n    }\n\n  /* Our hash implementation does only leave small parts (64 bytes)\n     of the pool on the stack, so it is okay not to require secure\n     memory here.  Before we use this pool, it will be copied to the\n     help buffer anyway. */\n  if ( pool == rndpool)\n    {\n      _gcry_sha1_hash_buffer (failsafe_digest, pool, POOLSIZE);\n      failsafe_digest_valid = 1;\n    }\n\n  _gcry_burn_stack (nburn);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146663,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "int main(int argc, char **argv)\n{\n\tint c, rc = 0, all = 0, recursive = 0;\n\tstruct libmnt_context *cxt;\n\tchar *types = NULL;\n\n\tenum {\n\t\tUMOUNT_OPT_FAKE = CHAR_MAX + 1,\n\t};\n\n\tstatic const struct option longopts[] = {\n\t\t{ \"all\", 0, 0, 'a' },\n\t\t{ \"detach-loop\", 0, 0, 'd' },\n\t\t{ \"fake\", 0, 0, UMOUNT_OPT_FAKE },\n\t\t{ \"force\", 0, 0, 'f' },\n\t\t{ \"help\", 0, 0, 'h' },\n\t\t{ \"internal-only\", 0, 0, 'i' },\n\t\t{ \"lazy\", 0, 0, 'l' },\n\t\t{ \"no-canonicalize\", 0, 0, 'c' },\n\t\t{ \"no-mtab\", 0, 0, 'n' },\n\t\t{ \"read-only\", 0, 0, 'r' },\n\t\t{ \"recursive\", 0, 0, 'R' },\n\t\t{ \"test-opts\", 1, 0, 'O' },\n\t\t{ \"types\", 1, 0, 't' },\n\t\t{ \"verbose\", 0, 0, 'v' },\n\t\t{ \"version\", 0, 0, 'V' },\n\t\t{ NULL, 0, 0, 0 }\n\t};\n\n\tstatic const ul_excl_t excl[] = {       /* rows and cols in in ASCII order */\n\t\t{ 'R','a' },\t\t\t/* recursive,all */\n\t\t{ 'O','R','t'},\t\t\t/* options,recursive,types */\n\t\t{ 'R','r' },\t\t\t/* recursive,read-only */\n\t\t{ 0 }\n\t};\n\tint excl_st[ARRAY_SIZE(excl)] = UL_EXCL_STATUS_INIT;\n\n\tsanitize_env();\n\tsetlocale(LC_ALL, \"\");\n\tbindtextdomain(PACKAGE, LOCALEDIR);\n\ttextdomain(PACKAGE);\n\tatexit(close_stdout);\n\n\tmnt_init_debug(0);\n\tcxt = mnt_new_context();\n\tif (!cxt)\n\t\terr(MOUNT_EX_SYSERR, _(\"libmount context allocation failed\"));\n\n\tmnt_context_set_tables_errcb(cxt, table_parser_errcb);\n\n\twhile ((c = getopt_long(argc, argv, \"acdfhilnRrO:t:vV\",\n\t\t\t\t\tlongopts, NULL)) != -1) {\n\n\n\t\t/* only few options are allowed for non-root users */\n\t\tif (mnt_context_is_restricted(cxt) && !strchr(\"hdilVv\", c))\n\t\t\texit_non_root(option_to_longopt(c, longopts));\n\n\t\terr_exclusive_options(c, longopts, excl, excl_st);\n\n\t\tswitch(c) {\n\t\tcase 'a':\n\t\t\tall = 1;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tmnt_context_disable_canonicalize(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tmnt_context_enable_loopdel(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase UMOUNT_OPT_FAKE:\n\t\t\tmnt_context_enable_fake(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tmnt_context_enable_force(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage(stdout);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tmnt_context_disable_helpers(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tmnt_context_enable_lazy(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tmnt_context_disable_mtab(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tmnt_context_enable_rdonly_umount(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\trecursive = TRUE;\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tif (mnt_context_set_options_pattern(cxt, optarg))\n\t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to set options pattern\"));\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\ttypes = optarg;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tmnt_context_enable_verbose(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tprint_version();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage(stderr);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\tif (all) {\n\t\tif (!types)\n\t\t\ttypes = \"noproc,nodevfs,nodevpts,nosysfs,norpc_pipefs,nonfsd\";\n\n\t\tmnt_context_set_fstype_pattern(cxt, types);\n\t\trc = umount_all(cxt);\n\n\t} else if (argc < 1) {\n\t\tusage(stderr);\n\n\t} else if (recursive) {\n\t\twhile (argc--)\n\t\t\trc += umount_recursive(cxt, *argv++);\n\t} else {\n\t\twhile (argc--)\n\t\t\trc += umount_one(cxt, *argv++);\n\t}\n\n\tmnt_free_context(cxt);\n\treturn rc;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146692,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "int main(int argc, char **argv)\n{\n\tint c, rc = 0, all = 0, recursive = 0;\n\tstruct libmnt_context *cxt;\n\tchar *types = NULL;\n\n\tenum {\n\t\tUMOUNT_OPT_FAKE = CHAR_MAX + 1,\n\t};\n\n\tstatic const struct option longopts[] = {\n\t\t{ \"all\", 0, 0, 'a' },\n\t\t{ \"detach-loop\", 0, 0, 'd' },\n\t\t{ \"fake\", 0, 0, UMOUNT_OPT_FAKE },\n\t\t{ \"force\", 0, 0, 'f' },\n\t\t{ \"help\", 0, 0, 'h' },\n\t\t{ \"internal-only\", 0, 0, 'i' },\n\t\t{ \"lazy\", 0, 0, 'l' },\n\t\t{ \"no-canonicalize\", 0, 0, 'c' },\n\t\t{ \"no-mtab\", 0, 0, 'n' },\n\t\t{ \"read-only\", 0, 0, 'r' },\n\t\t{ \"recursive\", 0, 0, 'R' },\n\t\t{ \"test-opts\", 1, 0, 'O' },\n\t\t{ \"types\", 1, 0, 't' },\n\t\t{ \"verbose\", 0, 0, 'v' },\n\t\t{ \"version\", 0, 0, 'V' },\n\t\t{ NULL, 0, 0, 0 }\n\t};\n\n\tstatic const ul_excl_t excl[] = {       /* rows and cols in in ASCII order */\n\t\t{ 'R','a' },\t\t\t/* recursive,all */\n\t\t{ 'O','R','t'},\t\t\t/* options,recursive,types */\n\t\t{ 'R','r' },\t\t\t/* recursive,read-only */\n\t\t{ 0 }\n\t};\n\tint excl_st[ARRAY_SIZE(excl)] = UL_EXCL_STATUS_INIT;\n\n\tsanitize_env();\n\tsetlocale(LC_ALL, \"\");\n\tbindtextdomain(PACKAGE, LOCALEDIR);\n\ttextdomain(PACKAGE);\n\tatexit(close_stdout);\n\n\tmnt_init_debug(0);\n\tcxt = mnt_new_context();\n\tif (!cxt)\n\t\terr(MOUNT_EX_SYSERR, _(\"libmount context allocation failed\"));\n\n\tmnt_context_set_tables_errcb(cxt, table_parser_errcb);\n\n\twhile ((c = getopt_long(argc, argv, \"acdfhilnRrO:t:vV\",\n\t\t\t\t\tlongopts, NULL)) != -1) {\n\n\n\t\t/* only few options are allowed for non-root users */\n\t\tif (mnt_context_is_restricted(cxt) && !strchr(\"hdilVv\", c))\n\t\t\texit_non_root(option_to_longopt(c, longopts));\n\n\t\terr_exclusive_options(c, longopts, excl, excl_st);\n\n\t\tswitch(c) {\n\t\tcase 'a':\n\t\t\tall = 1;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tmnt_context_disable_canonicalize(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tmnt_context_enable_loopdel(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase UMOUNT_OPT_FAKE:\n\t\t\tmnt_context_enable_fake(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tmnt_context_enable_force(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage(stdout);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tmnt_context_disable_helpers(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tmnt_context_enable_lazy(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tmnt_context_disable_mtab(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tmnt_context_enable_rdonly_umount(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\trecursive = TRUE;\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tif (mnt_context_set_options_pattern(cxt, optarg))\n\t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to set options pattern\"));\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\ttypes = optarg;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tmnt_context_enable_verbose(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tprint_version();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage(stderr);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\tif (all) {\n\t\tif (!types)\n\t\t\ttypes = \"noproc,nodevfs,nodevpts,nosysfs,norpc_pipefs,nonfsd\";\n\n\t\tmnt_context_set_fstype_pattern(cxt, types);\n\t\trc = umount_all(cxt);\n\n\t} else if (argc < 1) {\n\t\tusage(stderr);\n\n\t} else if (recursive) {\n\t\twhile (argc--)\n\t\t\trc += umount_recursive(cxt, *argv++);\n\t} else {\n\t\twhile (argc--) {\n\t\t\tchar *path = *argv++;\n\n\t\t\tif (mnt_context_is_restricted(cxt))\n\t\t\t\tpath = sanitize_path(path);\n\n\t\t\trc += umount_one(cxt, path);\n\n\t\t\tif (mnt_context_is_restricted(cxt))\n\t\t\t\tfree(path);\n\t\t}\n\t}\n\n\tmnt_free_context(cxt);\n\treturn rc;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146693,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int open_cred_file(char *file_name,\n\t\t\tstruct parsed_mount_info *parsed_info)\n{\n\tchar *line_buf = NULL;\n\tchar *temp_val = NULL;\n\tFILE *fs = NULL;\n\tint i;\n\tconst int line_buf_size = 4096;\n\tconst int min_non_white = 10;\n\n\ti = toggle_dac_capability(0, 1);\n\tif (i)\n\t\tgoto return_i;\n\n\ti = access(file_name, R_OK);\n\tif (i) {\n\t\ttoggle_dac_capability(0, 0);\n\t\ti = errno;\n\t\tgoto return_i;\n\t}\n\n\tfs = fopen(file_name, \"r\");\n\tif (fs == NULL) {\n\t\ttoggle_dac_capability(0, 0);\n\t\ti = errno;\n\t\tgoto return_i;\n\t}\n\n\ti = toggle_dac_capability(0, 0);\n\tif (i)\n\t\tgoto return_i;\n\n\tline_buf = (char *)malloc(line_buf_size);\n\tif (line_buf == NULL) {\n\t\ti = EX_SYSERR;\n\t\tgoto return_i;\n\t}\n\n\t/* parse line from credentials file */\n\twhile (fgets(line_buf, line_buf_size, fs)) {\n\t\t/* eat leading white space */\n\t\tfor (i = 0; i < line_buf_size - min_non_white + 1; i++) {\n\t\t\tif ((line_buf[i] != ' ') && (line_buf[i] != '\\t'))\n\t\t\t\tbreak;\n\t\t}\n\t\tnull_terminate_endl(line_buf);\n\n\t\t/* parse next token */\n\t\tswitch (parse_cred_line(line_buf + i, &temp_val)) {\n\t\tcase CRED_USER:\n\t\t\tstrlcpy(parsed_info->username, temp_val,\n\t\t\t\tsizeof(parsed_info->username));\n\t\t\tparsed_info->got_user = 1;\n\t\t\tbreak;\n\t\tcase CRED_PASS:\n\t\t\ti = set_password(parsed_info, temp_val);\n\t\t\tif (i)\n\t\t\t\tgoto return_i;\n\t\t\tbreak;\n\t\tcase CRED_DOM:\n\t\t\tif (parsed_info->verboseflag)\n\t\t\t\tfprintf(stderr, \"domain=%s\\n\",\n\t\t\t\t\ttemp_val);\n\t\t\tstrlcpy(parsed_info->domain, temp_val,\n\t\t\t\tsizeof(parsed_info->domain));\n\t\t\tbreak;\n\t\tcase CRED_UNPARSEABLE:\n\t\t\tif (parsed_info->verboseflag)\n\t\t\t\tfprintf(stderr, \"Credential formatted \"\n\t\t\t\t\t\"incorrectly: %s\\n\",\n\t\t\t\t\ttemp_val ? temp_val : \"(null)\");\n\t\t\tbreak;\n\t\t}\n\t}\n\ti = 0;\nreturn_i:\n\tif (fs != NULL)\n\t\tfclose(fs);\n\n\t/* make sure passwords are scrubbed from memory */\n\tif (line_buf != NULL)\n\t\tmemset(line_buf, 0, line_buf_size);\n\tfree(line_buf);\n\treturn i;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146720,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int open_cred_file(char *file_name,\n\t\t\tstruct parsed_mount_info *parsed_info)\n{\n\tchar *line_buf = NULL;\n\tchar *temp_val = NULL;\n\tFILE *fs = NULL;\n\tint i;\n\tconst int line_buf_size = 4096;\n\tconst int min_non_white = 10;\n\n\ti = toggle_dac_capability(0, 1);\n\tif (i)\n\t\tgoto return_i;\n\n\ti = access(file_name, R_OK);\n\tif (i) {\n\t\ttoggle_dac_capability(0, 0);\n\t\ti = errno;\n\t\tgoto return_i;\n\t}\n\n\tfs = fopen(file_name, \"r\");\n\tif (fs == NULL) {\n\t\ttoggle_dac_capability(0, 0);\n\t\ti = errno;\n\t\tgoto return_i;\n\t}\n\n\ti = toggle_dac_capability(0, 0);\n\tif (i)\n\t\tgoto return_i;\n\n\tline_buf = (char *)malloc(line_buf_size);\n\tif (line_buf == NULL) {\n\t\ti = EX_SYSERR;\n\t\tgoto return_i;\n\t}\n\n\t/* parse line from credentials file */\n\twhile (fgets(line_buf, line_buf_size, fs)) {\n\t\t/* eat leading white space */\n\t\tfor (i = 0; i < line_buf_size - min_non_white + 1; i++) {\n\t\t\tif ((line_buf[i] != ' ') && (line_buf[i] != '\\t'))\n\t\t\t\tbreak;\n\t\t}\n\t\tnull_terminate_endl(line_buf);\n\n\t\t/* parse next token */\n\t\tswitch (parse_cred_line(line_buf + i, &temp_val)) {\n\t\tcase CRED_USER:\n\t\t\tstrlcpy(parsed_info->username, temp_val,\n\t\t\t\tsizeof(parsed_info->username));\n\t\t\tparsed_info->got_user = 1;\n\t\t\tbreak;\n\t\tcase CRED_PASS:\n\t\t\ti = set_password(parsed_info, temp_val);\n\t\t\tif (i)\n\t\t\t\tgoto return_i;\n\t\t\tbreak;\n\t\tcase CRED_DOM:\n\t\t\tstrlcpy(parsed_info->domain, temp_val,\n\t\t\t\tsizeof(parsed_info->domain));\n\t\t\tbreak;\n\t\tcase CRED_UNPARSEABLE:\n\t\t\tif (parsed_info->verboseflag)\n\t\t\t\tfprintf(stderr, \"Credential formatted \"\n\t\t\t\t\t\"incorrectly\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\ti = 0;\nreturn_i:\n\tif (fs != NULL)\n\t\tfclose(fs);\n\n\t/* make sure passwords are scrubbed from memory */\n\tif (line_buf != NULL)\n\t\tmemset(line_buf, 0, line_buf_size);\n\tfree(line_buf);\n\treturn i;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146721,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int rndis_set_response(struct rndis_params *params,\n\t\t\t      rndis_set_msg_type *buf)\n{\n\tu32 BufLength, BufOffset;\n\trndis_set_cmplt_type *resp;\n\trndis_resp_t *r;\n\n\tr = rndis_add_response(params, sizeof(rndis_set_cmplt_type));\n\tif (!r)\n\t\treturn -ENOMEM;\n\tresp = (rndis_set_cmplt_type *)r->buf;\n\n\tBufLength = le32_to_cpu(buf->InformationBufferLength);\n\tBufOffset = le32_to_cpu(buf->InformationBufferOffset);\n\n#ifdef\tVERBOSE_DEBUG\n\tpr_debug(\"%s: Length: %d\\n\", __func__, BufLength);\n\tpr_debug(\"%s: Offset: %d\\n\", __func__, BufOffset);\n\tpr_debug(\"%s: InfoBuffer: \", __func__);\n\n\tfor (i = 0; i < BufLength; i++) {\n\t\tpr_debug(\"%02x \", *(((u8 *) buf) + i + 8 + BufOffset));\n\t}\n\n\tpr_debug(\"\\n\");\n#endif\n\n\tresp->MessageType = cpu_to_le32(RNDIS_MSG_SET_C);\n\tresp->MessageLength = cpu_to_le32(16);\n\tresp->RequestID = buf->RequestID; /* Still LE in msg buffer */\n\tif (gen_ndis_set_resp(params, le32_to_cpu(buf->OID),\n\t\t\t((u8 *)buf) + 8 + BufOffset, BufLength, r))\n\t\tresp->Status = cpu_to_le32(RNDIS_STATUS_NOT_SUPPORTED);\n\telse\n\t\tresp->Status = cpu_to_le32(RNDIS_STATUS_SUCCESS);\n\n\tparams->resp_avail(params->v);\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146724,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int rndis_set_response(struct rndis_params *params,\n\t\t\t      rndis_set_msg_type *buf)\n{\n\tu32 BufLength, BufOffset;\n\trndis_set_cmplt_type *resp;\n\trndis_resp_t *r;\n\n\tBufLength = le32_to_cpu(buf->InformationBufferLength);\n\tBufOffset = le32_to_cpu(buf->InformationBufferOffset);\n\tif ((BufLength > RNDIS_MAX_TOTAL_SIZE) ||\n\t    (BufOffset + 8 >= RNDIS_MAX_TOTAL_SIZE))\n\t\t    return -EINVAL;\n\n\tr = rndis_add_response(params, sizeof(rndis_set_cmplt_type));\n\tif (!r)\n\t\treturn -ENOMEM;\n\tresp = (rndis_set_cmplt_type *)r->buf;\n\n#ifdef\tVERBOSE_DEBUG\n\tpr_debug(\"%s: Length: %d\\n\", __func__, BufLength);\n\tpr_debug(\"%s: Offset: %d\\n\", __func__, BufOffset);\n\tpr_debug(\"%s: InfoBuffer: \", __func__);\n\n\tfor (i = 0; i < BufLength; i++) {\n\t\tpr_debug(\"%02x \", *(((u8 *) buf) + i + 8 + BufOffset));\n\t}\n\n\tpr_debug(\"\\n\");\n#endif\n\n\tresp->MessageType = cpu_to_le32(RNDIS_MSG_SET_C);\n\tresp->MessageLength = cpu_to_le32(16);\n\tresp->RequestID = buf->RequestID; /* Still LE in msg buffer */\n\tif (gen_ndis_set_resp(params, le32_to_cpu(buf->OID),\n\t\t\t((u8 *)buf) + 8 + BufOffset, BufLength, r))\n\t\tresp->Status = cpu_to_le32(RNDIS_STATUS_NOT_SUPPORTED);\n\telse\n\t\tresp->Status = cpu_to_le32(RNDIS_STATUS_SUCCESS);\n\n\tparams->resp_avail(params->v);\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146725,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static void do_client_file_xfer(VirtioPort *vport,\n                                VDAgentMessage *message_header,\n                                uint8_t *data)\n{\n    uint32_t msg_type, id;\n    UdscsConnection *conn;\n\n    switch (message_header->type) {\n    case VD_AGENT_FILE_XFER_START: {\n        VDAgentFileXferStartMessage *s = (VDAgentFileXferStartMessage *)data;\n        if (!active_session_conn) {\n            send_file_xfer_status(vport,\n               \"Could not find an agent connection belonging to the \"\n               \"active session, cancelling client file-xfer request %u\",\n               s->id, VD_AGENT_FILE_XFER_STATUS_VDAGENT_NOT_CONNECTED, NULL, 0);\n            return;\n        } else if (session_info_session_is_locked(session_info)) {\n            syslog(LOG_DEBUG, \"Session is locked, skipping file-xfer-start\");\n            send_file_xfer_status(vport,\n               \"User's session is locked and cannot start file transfer. \"\n               \"Cancelling client file-xfer request %u\",\n               s->id, VD_AGENT_FILE_XFER_STATUS_SESSION_LOCKED, NULL, 0);\n            return;\n        } else if (g_hash_table_size(active_xfers) >= MAX_ACTIVE_TRANSFERS) {\n            VDAgentFileXferStatusError error = {\n                GUINT32_TO_LE(VD_AGENT_FILE_XFER_STATUS_ERROR_GLIB_IO),\n                GUINT32_TO_LE(G_IO_ERROR_TOO_MANY_OPEN_FILES),\n            };\n            size_t detail_size = sizeof(error);\n            if (!VD_AGENT_HAS_CAPABILITY(capabilities, capabilities_size,\n                                         VD_AGENT_CAP_FILE_XFER_DETAILED_ERRORS)) {\n                detail_size = 0;\n            }\n            send_file_xfer_status(vport,\n               \"Too many transfers ongoing. \"\n               \"Cancelling client file-xfer request %u\",\n               s->id, VD_AGENT_FILE_XFER_STATUS_ERROR, (void*) &error, detail_size);\n            return;\n        }\n        msg_type = VDAGENTD_FILE_XFER_START;\n        id = s->id;\n        // associate the id with the active connection\n        g_hash_table_insert(active_xfers, GUINT_TO_POINTER(id), active_session_conn);\n        break;\n    }\n    case VD_AGENT_FILE_XFER_STATUS: {\n        VDAgentFileXferStatusMessage *s = (VDAgentFileXferStatusMessage *)data;\n        msg_type = VDAGENTD_FILE_XFER_STATUS;\n        id = s->id;\n        break;\n    }\n    case VD_AGENT_FILE_XFER_DATA: {\n        VDAgentFileXferDataMessage *d = (VDAgentFileXferDataMessage *)data;\n        msg_type = VDAGENTD_FILE_XFER_DATA;\n        id = d->id;\n        break;\n    }\n    default:\n        g_return_if_reached(); /* quiet uninitialized variable warning */\n    }\n\n    conn = g_hash_table_lookup(active_xfers, GUINT_TO_POINTER(id));\n    if (!conn) {\n        if (debug)\n            syslog(LOG_DEBUG, \"Could not find file-xfer %u (cancelled?)\", id);\n        return;\n    }\n    udscs_write(conn, msg_type, 0, 0, data, message_header->size);\n\n    // client told that transfer is ended, agents too stop the transfer\n    // and release resources\n    if (message_header->type == VD_AGENT_FILE_XFER_STATUS) {\n        g_hash_table_remove(active_xfers, GUINT_TO_POINTER(id));\n    }\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146838,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static void do_client_file_xfer(VirtioPort *vport,\n                                VDAgentMessage *message_header,\n                                uint8_t *data)\n{\n    uint32_t msg_type, id;\n    UdscsConnection *conn;\n\n    switch (message_header->type) {\n    case VD_AGENT_FILE_XFER_START: {\n        VDAgentFileXferStartMessage *s = (VDAgentFileXferStartMessage *)data;\n        if (!active_session_conn) {\n            send_file_xfer_status(vport,\n               \"Could not find an agent connection belonging to the \"\n               \"active session, cancelling client file-xfer request %u\",\n               s->id, VD_AGENT_FILE_XFER_STATUS_VDAGENT_NOT_CONNECTED, NULL, 0);\n            return;\n        } else if (session_info_session_is_locked(session_info)) {\n            syslog(LOG_DEBUG, \"Session is locked, skipping file-xfer-start\");\n            send_file_xfer_status(vport,\n               \"User's session is locked and cannot start file transfer. \"\n               \"Cancelling client file-xfer request %u\",\n               s->id, VD_AGENT_FILE_XFER_STATUS_SESSION_LOCKED, NULL, 0);\n            return;\n        } else if (g_hash_table_size(active_xfers) >= MAX_ACTIVE_TRANSFERS) {\n            VDAgentFileXferStatusError error = {\n                GUINT32_TO_LE(VD_AGENT_FILE_XFER_STATUS_ERROR_GLIB_IO),\n                GUINT32_TO_LE(G_IO_ERROR_TOO_MANY_OPEN_FILES),\n            };\n            size_t detail_size = sizeof(error);\n            if (!VD_AGENT_HAS_CAPABILITY(capabilities, capabilities_size,\n                                         VD_AGENT_CAP_FILE_XFER_DETAILED_ERRORS)) {\n                detail_size = 0;\n            }\n            send_file_xfer_status(vport,\n               \"Too many transfers ongoing. \"\n               \"Cancelling client file-xfer request %u\",\n               s->id, VD_AGENT_FILE_XFER_STATUS_ERROR, (void*) &error, detail_size);\n            return;\n        } else if (g_hash_table_lookup(active_xfers, GUINT_TO_POINTER(s->id)) != NULL) {\n            // id is already used -- client is confused\n            send_file_xfer_status(vport,\n               \"File transfer ID is already used. \"\n               \"Cancelling client file-xfer request %u\",\n               s->id, VD_AGENT_FILE_XFER_STATUS_ERROR, NULL, 0);\n            return;\n        }\n        msg_type = VDAGENTD_FILE_XFER_START;\n        id = s->id;\n        // associate the id with the active connection\n        g_hash_table_insert(active_xfers, GUINT_TO_POINTER(id), active_session_conn);\n        break;\n    }\n    case VD_AGENT_FILE_XFER_STATUS: {\n        VDAgentFileXferStatusMessage *s = (VDAgentFileXferStatusMessage *)data;\n        msg_type = VDAGENTD_FILE_XFER_STATUS;\n        id = s->id;\n        break;\n    }\n    case VD_AGENT_FILE_XFER_DATA: {\n        VDAgentFileXferDataMessage *d = (VDAgentFileXferDataMessage *)data;\n        msg_type = VDAGENTD_FILE_XFER_DATA;\n        id = d->id;\n        break;\n    }\n    default:\n        g_return_if_reached(); /* quiet uninitialized variable warning */\n    }\n\n    conn = g_hash_table_lookup(active_xfers, GUINT_TO_POINTER(id));\n    if (!conn) {\n        if (debug)\n            syslog(LOG_DEBUG, \"Could not find file-xfer %u (cancelled?)\", id);\n        return;\n    }\n    udscs_write(conn, msg_type, 0, 0, data, message_header->size);\n\n    // client told that transfer is ended, agents too stop the transfer\n    // and release resources\n    if (message_header->type == VD_AGENT_FILE_XFER_STATUS) {\n        g_hash_table_remove(active_xfers, GUINT_TO_POINTER(id));\n    }\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146839,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "_gcry_mpi_ec_mul_point (mpi_point_t result,\n                        gcry_mpi_t scalar, mpi_point_t point,\n                        mpi_ec_t ctx)\n{\n  gcry_mpi_t x1, y1, z1, k, h, yy;\n  unsigned int i, loops;\n  mpi_point_struct p1, p2, p1inv;\n\n  if (ctx->model == MPI_EC_EDWARDS)\n    {\n      /* Simple left to right binary method.  GECC Algorithm 3.27 */\n      unsigned int nbits;\n      int j;\n\n      nbits = mpi_get_nbits (scalar);\n      mpi_set_ui (result->x, 0);\n      mpi_set_ui (result->y, 1);\n      mpi_set_ui (result->z, 1);\n\n      if (mpi_is_secure (scalar))\n        {\n          /* If SCALAR is in secure memory we assume that it is the\n             secret key we use constant time operation.  */\n          mpi_point_struct tmppnt;\n\n          point_init (&tmppnt);\n          point_resize (result, ctx);\n          point_resize (&tmppnt, ctx);\n          for (j=nbits-1; j >= 0; j--)\n            {\n              _gcry_mpi_ec_dup_point (result, result, ctx);\n              _gcry_mpi_ec_add_points (&tmppnt, result, point, ctx);\n              point_swap_cond (result, &tmppnt, mpi_test_bit (scalar, j), ctx);\n            }\n          point_free (&tmppnt);\n        }\n      else\n        {\n          for (j=nbits-1; j >= 0; j--)\n            {\n              _gcry_mpi_ec_dup_point (result, result, ctx);\n              if (mpi_test_bit (scalar, j))\n                _gcry_mpi_ec_add_points (result, result, point, ctx);\n            }\n        }\n      return;\n    }\n  else if (ctx->model == MPI_EC_MONTGOMERY)\n    {\n      unsigned int nbits;\n      int j;\n      mpi_point_struct p1_, p2_;\n      mpi_point_t q1, q2, prd, sum;\n      unsigned long sw;\n\n      /* Compute scalar point multiplication with Montgomery Ladder.\n         Note that we don't use Y-coordinate in the points at all.\n         RESULT->Y will be filled by zero.  */\n\n      nbits = mpi_get_nbits (scalar);\n      point_init (&p1);\n      point_init (&p2);\n      point_init (&p1_);\n      point_init (&p2_);\n      mpi_set_ui (p1.x, 1);\n      mpi_free (p2.x);\n      p2.x  = mpi_copy (point->x);\n      mpi_set_ui (p2.z, 1);\n\n      point_resize (&p1, ctx);\n      point_resize (&p2, ctx);\n      point_resize (&p1_, ctx);\n      point_resize (&p2_, ctx);\n\n      q1 = &p1;\n      q2 = &p2;\n      prd = &p1_;\n      sum = &p2_;\n\n      for (j=nbits-1; j >= 0; j--)\n        {\n          mpi_point_t t;\n\n          sw = mpi_test_bit (scalar, j);\n          point_swap_cond (q1, q2, sw, ctx);\n          montgomery_ladder (prd, sum, q1, q2, point->x, ctx);\n          point_swap_cond (prd, sum, sw, ctx);\n          t = q1;  q1 = prd;  prd = t;\n          t = q2;  q2 = sum;  sum = t;\n        }\n\n      mpi_clear (result->y);\n      sw = (nbits & 1);\n      point_swap_cond (&p1, &p1_, sw, ctx);\n\n      if (p1.z->nlimbs == 0)\n        {\n          mpi_set_ui (result->x, 1);\n          mpi_set_ui (result->z, 0);\n        }\n      else\n        {\n          z1 = mpi_new (0);\n          ec_invm (z1, p1.z, ctx);\n          ec_mulm (result->x, p1.x, z1, ctx);\n          mpi_set_ui (result->z, 1);\n          mpi_free (z1);\n        }\n\n      point_free (&p1);\n      point_free (&p2);\n      point_free (&p1_);\n      point_free (&p2_);\n      return;\n    }\n\n  x1 = mpi_alloc_like (ctx->p);\n  y1 = mpi_alloc_like (ctx->p);\n  h  = mpi_alloc_like (ctx->p);\n  k  = mpi_copy (scalar);\n  yy = mpi_copy (point->y);\n\n  if ( mpi_has_sign (k) )\n    {\n      k->sign = 0;\n      ec_invm (yy, yy, ctx);\n    }\n\n  if (!mpi_cmp_ui (point->z, 1))\n    {\n      mpi_set (x1, point->x);\n      mpi_set (y1, yy);\n    }\n  else\n    {\n      gcry_mpi_t z2, z3;\n\n      z2 = mpi_alloc_like (ctx->p);\n      z3 = mpi_alloc_like (ctx->p);\n      ec_mulm (z2, point->z, point->z, ctx);\n      ec_mulm (z3, point->z, z2, ctx);\n      ec_invm (z2, z2, ctx);\n      ec_mulm (x1, point->x, z2, ctx);\n      ec_invm (z3, z3, ctx);\n      ec_mulm (y1, yy, z3, ctx);\n      mpi_free (z2);\n      mpi_free (z3);\n    }\n  z1 = mpi_copy (mpi_const (MPI_C_ONE));\n\n  mpi_mul (h, k, mpi_const (MPI_C_THREE)); /* h = 3k */\n  loops = mpi_get_nbits (h);\n  if (loops < 2)\n    {\n      /* If SCALAR is zero, the above mpi_mul sets H to zero and thus\n         LOOPs will be zero.  To avoid an underflow of I in the main\n         loop we set LOOP to 2 and the result to (0,0,0).  */\n      loops = 2;\n      mpi_clear (result->x);\n      mpi_clear (result->y);\n      mpi_clear (result->z);\n    }\n  else\n    {\n      mpi_set (result->x, point->x);\n      mpi_set (result->y, yy);\n      mpi_set (result->z, point->z);\n    }\n  mpi_free (yy); yy = NULL;\n\n  p1.x = x1; x1 = NULL;\n  p1.y = y1; y1 = NULL;\n  p1.z = z1; z1 = NULL;\n  point_init (&p2);\n  point_init (&p1inv);\n\n  for (i=loops-2; i > 0; i--)\n    {\n      _gcry_mpi_ec_dup_point (result, result, ctx);\n      if (mpi_test_bit (h, i) == 1 && mpi_test_bit (k, i) == 0)\n        {\n          point_set (&p2, result);\n          _gcry_mpi_ec_add_points (result, &p2, &p1, ctx);\n        }\n      if (mpi_test_bit (h, i) == 0 && mpi_test_bit (k, i) == 1)\n        {\n          point_set (&p2, result);\n          /* Invert point: y = p - y mod p  */\n          point_set (&p1inv, &p1);\n          ec_subm (p1inv.y, ctx->p, p1inv.y, ctx);\n          _gcry_mpi_ec_add_points (result, &p2, &p1inv, ctx);\n        }\n    }\n\n  point_free (&p1);\n  point_free (&p2);\n  point_free (&p1inv);\n  mpi_free (h);\n  mpi_free (k);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146928,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "_gcry_mpi_ec_mul_point (mpi_point_t result,\n                        gcry_mpi_t scalar, mpi_point_t point,\n                        mpi_ec_t ctx)\n{\n  gcry_mpi_t x1, y1, z1, k, h, yy;\n  unsigned int i, loops;\n  mpi_point_struct p1, p2, p1inv;\n\n  if (ctx->model == MPI_EC_EDWARDS\n      || (ctx->model == MPI_EC_WEIERSTRASS\n          && mpi_is_secure (scalar)))\n    {\n      /* Simple left to right binary method.  GECC Algorithm 3.27 */\n      unsigned int nbits;\n      int j;\n\n      nbits = mpi_get_nbits (scalar);\n      if (ctx->model == MPI_EC_WEIERSTRASS)\n        {\n          mpi_set_ui (result->x, 1);\n          mpi_set_ui (result->y, 1);\n          mpi_set_ui (result->z, 0);\n        }\n      else\n        {\n          mpi_set_ui (result->x, 0);\n          mpi_set_ui (result->y, 1);\n          mpi_set_ui (result->z, 1);\n        }\n\n      if (mpi_is_secure (scalar))\n        {\n          /* If SCALAR is in secure memory we assume that it is the\n             secret key we use constant time operation.  */\n          mpi_point_struct tmppnt;\n\n          point_init (&tmppnt);\n          point_resize (result, ctx);\n          point_resize (&tmppnt, ctx);\n          for (j=nbits-1; j >= 0; j--)\n            {\n              _gcry_mpi_ec_dup_point (result, result, ctx);\n              _gcry_mpi_ec_add_points (&tmppnt, result, point, ctx);\n              point_swap_cond (result, &tmppnt, mpi_test_bit (scalar, j), ctx);\n            }\n          point_free (&tmppnt);\n        }\n      else\n        {\n          for (j=nbits-1; j >= 0; j--)\n            {\n              _gcry_mpi_ec_dup_point (result, result, ctx);\n              if (mpi_test_bit (scalar, j))\n                _gcry_mpi_ec_add_points (result, result, point, ctx);\n            }\n        }\n      return;\n    }\n  else if (ctx->model == MPI_EC_MONTGOMERY)\n    {\n      unsigned int nbits;\n      int j;\n      mpi_point_struct p1_, p2_;\n      mpi_point_t q1, q2, prd, sum;\n      unsigned long sw;\n\n      /* Compute scalar point multiplication with Montgomery Ladder.\n         Note that we don't use Y-coordinate in the points at all.\n         RESULT->Y will be filled by zero.  */\n\n      nbits = mpi_get_nbits (scalar);\n      point_init (&p1);\n      point_init (&p2);\n      point_init (&p1_);\n      point_init (&p2_);\n      mpi_set_ui (p1.x, 1);\n      mpi_free (p2.x);\n      p2.x  = mpi_copy (point->x);\n      mpi_set_ui (p2.z, 1);\n\n      point_resize (&p1, ctx);\n      point_resize (&p2, ctx);\n      point_resize (&p1_, ctx);\n      point_resize (&p2_, ctx);\n\n      q1 = &p1;\n      q2 = &p2;\n      prd = &p1_;\n      sum = &p2_;\n\n      for (j=nbits-1; j >= 0; j--)\n        {\n          mpi_point_t t;\n\n          sw = mpi_test_bit (scalar, j);\n          point_swap_cond (q1, q2, sw, ctx);\n          montgomery_ladder (prd, sum, q1, q2, point->x, ctx);\n          point_swap_cond (prd, sum, sw, ctx);\n          t = q1;  q1 = prd;  prd = t;\n          t = q2;  q2 = sum;  sum = t;\n        }\n\n      mpi_clear (result->y);\n      sw = (nbits & 1);\n      point_swap_cond (&p1, &p1_, sw, ctx);\n\n      if (p1.z->nlimbs == 0)\n        {\n          mpi_set_ui (result->x, 1);\n          mpi_set_ui (result->z, 0);\n        }\n      else\n        {\n          z1 = mpi_new (0);\n          ec_invm (z1, p1.z, ctx);\n          ec_mulm (result->x, p1.x, z1, ctx);\n          mpi_set_ui (result->z, 1);\n          mpi_free (z1);\n        }\n\n      point_free (&p1);\n      point_free (&p2);\n      point_free (&p1_);\n      point_free (&p2_);\n      return;\n    }\n\n  x1 = mpi_alloc_like (ctx->p);\n  y1 = mpi_alloc_like (ctx->p);\n  h  = mpi_alloc_like (ctx->p);\n  k  = mpi_copy (scalar);\n  yy = mpi_copy (point->y);\n\n  if ( mpi_has_sign (k) )\n    {\n      k->sign = 0;\n      ec_invm (yy, yy, ctx);\n    }\n\n  if (!mpi_cmp_ui (point->z, 1))\n    {\n      mpi_set (x1, point->x);\n      mpi_set (y1, yy);\n    }\n  else\n    {\n      gcry_mpi_t z2, z3;\n\n      z2 = mpi_alloc_like (ctx->p);\n      z3 = mpi_alloc_like (ctx->p);\n      ec_mulm (z2, point->z, point->z, ctx);\n      ec_mulm (z3, point->z, z2, ctx);\n      ec_invm (z2, z2, ctx);\n      ec_mulm (x1, point->x, z2, ctx);\n      ec_invm (z3, z3, ctx);\n      ec_mulm (y1, yy, z3, ctx);\n      mpi_free (z2);\n      mpi_free (z3);\n    }\n  z1 = mpi_copy (mpi_const (MPI_C_ONE));\n\n  mpi_mul (h, k, mpi_const (MPI_C_THREE)); /* h = 3k */\n  loops = mpi_get_nbits (h);\n  if (loops < 2)\n    {\n      /* If SCALAR is zero, the above mpi_mul sets H to zero and thus\n         LOOPs will be zero.  To avoid an underflow of I in the main\n         loop we set LOOP to 2 and the result to (0,0,0).  */\n      loops = 2;\n      mpi_clear (result->x);\n      mpi_clear (result->y);\n      mpi_clear (result->z);\n    }\n  else\n    {\n      mpi_set (result->x, point->x);\n      mpi_set (result->y, yy);\n      mpi_set (result->z, point->z);\n    }\n  mpi_free (yy); yy = NULL;\n\n  p1.x = x1; x1 = NULL;\n  p1.y = y1; y1 = NULL;\n  p1.z = z1; z1 = NULL;\n  point_init (&p2);\n  point_init (&p1inv);\n\n  for (i=loops-2; i > 0; i--)\n    {\n      _gcry_mpi_ec_dup_point (result, result, ctx);\n      if (mpi_test_bit (h, i) == 1 && mpi_test_bit (k, i) == 0)\n        {\n          point_set (&p2, result);\n          _gcry_mpi_ec_add_points (result, &p2, &p1, ctx);\n        }\n      if (mpi_test_bit (h, i) == 0 && mpi_test_bit (k, i) == 1)\n        {\n          point_set (&p2, result);\n          /* Invert point: y = p - y mod p  */\n          point_set (&p1inv, &p1);\n          ec_subm (p1inv.y, ctx->p, p1inv.y, ctx);\n          _gcry_mpi_ec_add_points (result, &p2, &p1inv, ctx);\n        }\n    }\n\n  point_free (&p1);\n  point_free (&p2);\n  point_free (&p1inv);\n  mpi_free (h);\n  mpi_free (k);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146929,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": " */\nPHPAPI void php_print_info(int flag TSRMLS_DC)\n{\n\tchar **env, *tmp1, *tmp2;\n\tchar *php_uname;\n\n\tif (!sapi_module.phpinfo_as_text) {\n\t\tphp_print_info_htmlhead(TSRMLS_C);\n\t} else {\n\t\tphp_info_print(\"phpinfo()\\n\");\n\t}\n\n\tif (flag & PHP_INFO_GENERAL) {\n\t\tchar *zend_version = get_zend_version();\n\t\tchar temp_api[10];\n\n\t\tphp_uname = php_get_uname('a');\n\n\t\tif (!sapi_module.phpinfo_as_text) {\n\t\t\tphp_info_print_box_start(1);\n\t\t}\n\n\t\tif (!sapi_module.phpinfo_as_text) {\n\t        time_t the_time;\n\t        struct tm *ta, tmbuf;\n\n\t        the_time = time(NULL);\n\t        ta = php_localtime_r(&the_time, &tmbuf);\n\n            php_info_print(\"<a href=\\\"http://www.php.net/\\\"><img border=\\\"0\\\" src=\\\"\");\n\t        if (ta && (ta->tm_mon==3) && (ta->tm_mday==1)) {\n\t\t        php_info_print(PHP_EGG_LOGO_DATA_URI \"\\\" alt=\\\"PHP logo\\\" /></a>\");\n\t        } else {\n\t\t        php_info_print(PHP_LOGO_DATA_URI \"\\\" alt=\\\"PHP logo\\\" /></a>\");\n\t\t\t}\n\t\t}\n\n\t\tif (!sapi_module.phpinfo_as_text) {\n\t\t\tphp_info_printf(\"<h1 class=\\\"p\\\">PHP Version %s</h1>\\n\", PHP_VERSION);\n\t\t} else {\n\t\t\tphp_info_print_table_row(2, \"PHP Version\", PHP_VERSION);\n\t\t}\n\t\tphp_info_print_box_end();\n\t\tphp_info_print_table_start();\n\t\tphp_info_print_table_row(2, \"System\", php_uname );\n\t\tphp_info_print_table_row(2, \"Build Date\", __DATE__ \" \" __TIME__ );\n#ifdef COMPILER\n\t\tphp_info_print_table_row(2, \"Compiler\", COMPILER);\n#endif\n#ifdef ARCHITECTURE\n\t\tphp_info_print_table_row(2, \"Architecture\", ARCHITECTURE);\n#endif\n#ifdef CONFIGURE_COMMAND\n\t\tphp_info_print_table_row(2, \"Configure Command\", CONFIGURE_COMMAND );\n#endif\n\n\t\tif (sapi_module.pretty_name) {\n\t\t\tphp_info_print_table_row(2, \"Server API\", sapi_module.pretty_name );\n\t\t}\n\n#ifdef VIRTUAL_DIR\n\t\tphp_info_print_table_row(2, \"Virtual Directory Support\", \"enabled\" );\n#else\n\t\tphp_info_print_table_row(2, \"Virtual Directory Support\", \"disabled\" );\n#endif\n\n\t\tphp_info_print_table_row(2, \"Configuration File (php.ini) Path\", PHP_CONFIG_FILE_PATH);\n\t\tphp_info_print_table_row(2, \"Loaded Configuration File\", php_ini_opened_path ? php_ini_opened_path : \"(none)\");\n\t\tphp_info_print_table_row(2, \"Scan this dir for additional .ini files\", php_ini_scanned_path ? php_ini_scanned_path : \"(none)\");\n\t\tphp_info_print_table_row(2, \"Additional .ini files parsed\", php_ini_scanned_files ? php_ini_scanned_files : \"(none)\");\n\n\t\tsnprintf(temp_api, sizeof(temp_api), \"%d\", PHP_API_VERSION);\n\t\tphp_info_print_table_row(2, \"PHP API\", temp_api);\n\n\t\tsnprintf(temp_api, sizeof(temp_api), \"%d\", ZEND_MODULE_API_NO);\n\t\tphp_info_print_table_row(2, \"PHP Extension\", temp_api);\n\n\t\tsnprintf(temp_api, sizeof(temp_api), \"%d\", ZEND_EXTENSION_API_NO);\n\t\tphp_info_print_table_row(2, \"Zend Extension\", temp_api);\n\n\t\tphp_info_print_table_row(2, \"Zend Extension Build\", ZEND_EXTENSION_BUILD_ID);\n\t\tphp_info_print_table_row(2, \"PHP Extension Build\", ZEND_MODULE_BUILD_ID);\n\n#if ZEND_DEBUG\n\t\tphp_info_print_table_row(2, \"Debug Build\", \"yes\" );\n#else\n\t\tphp_info_print_table_row(2, \"Debug Build\", \"no\" );\n#endif\n\n#ifdef ZTS\n\t\tphp_info_print_table_row(2, \"Thread Safety\", \"enabled\" );\n#else\n\t\tphp_info_print_table_row(2, \"Thread Safety\", \"disabled\" );\n#endif\n\n#ifdef ZEND_SIGNALS\n\t\tphp_info_print_table_row(2, \"Zend Signal Handling\", \"enabled\" );\n#else\n\t\tphp_info_print_table_row(2, \"Zend Signal Handling\", \"disabled\" );\n#endif\n\n\t\tphp_info_print_table_row(2, \"Zend Memory Manager\", is_zend_mm(TSRMLS_C) ? \"enabled\" : \"disabled\" );\n\n\t\t{\n\t\t\tconst zend_multibyte_functions *functions = zend_multibyte_get_functions(TSRMLS_C);\n\t\t\tchar *descr;\n\t\t\tif (functions) {\n\t\t\t\tspprintf(&descr, 0, \"provided by %s\", functions->provider_name);\n\t\t\t} else {\n\t\t\t\tdescr = estrdup(\"disabled\");\n\t\t\t}\n            php_info_print_table_row(2, \"Zend Multibyte Support\", descr);\n\t\t\tefree(descr);\n\t\t}\n\n#if HAVE_IPV6\n\t\tphp_info_print_table_row(2, \"IPv6 Support\", \"enabled\" );\n#else\n\t\tphp_info_print_table_row(2, \"IPv6 Support\", \"disabled\" );\n#endif\n\n#if HAVE_DTRACE\n\t\tphp_info_print_table_row(2, \"DTrace Support\", \"enabled\" );\n#else\n\t\tphp_info_print_table_row(2, \"DTrace Support\", \"disabled\" );\n#endif\n\n\t\tphp_info_print_stream_hash(\"PHP Streams\",  php_stream_get_url_stream_wrappers_hash() TSRMLS_CC);\n\t\tphp_info_print_stream_hash(\"Stream Socket Transports\", php_stream_xport_get_hash() TSRMLS_CC);\n\t\tphp_info_print_stream_hash(\"Stream Filters\", php_get_stream_filters_hash() TSRMLS_CC);\n\n\t\tphp_info_print_table_end();\n\n\t\t/* Zend Engine */\n\t\tphp_info_print_box_start(0);\n\t\tif (!sapi_module.phpinfo_as_text) {\n\t\t\tphp_info_print(\"<a href=\\\"http://www.zend.com/\\\"><img border=\\\"0\\\" src=\\\"\");\n\t\t\tphp_info_print(ZEND_LOGO_DATA_URI \"\\\" alt=\\\"Zend logo\\\" /></a>\\n\");\n\t\t}\n\t\tphp_info_print(\"This program makes use of the Zend Scripting Language Engine:\");\n\t\tphp_info_print(!sapi_module.phpinfo_as_text?\"<br />\":\"\\n\");\n\t\tif (sapi_module.phpinfo_as_text) {\n\t\t\tphp_info_print(zend_version);\n\t\t} else {\n\t\t\tzend_html_puts(zend_version, strlen(zend_version) TSRMLS_CC);\n\t\t}\n\t\tphp_info_print_box_end();\n\t\tefree(php_uname);\n\t}\n\n\tzend_ini_sort_entries(TSRMLS_C);\n\n\tif (flag & PHP_INFO_CONFIGURATION) {\n\t\tphp_info_print_hr();\n\t\tif (!sapi_module.phpinfo_as_text) {\n\t\t\tphp_info_print(\"<h1>Configuration</h1>\\n\");\n\t\t} else {\n\t\t\tSECTION(\"Configuration\");\n\t\t}\n\t\tif (!(flag & PHP_INFO_MODULES)) {\n\t\t\tSECTION(\"PHP Core\");\n\t\t\tdisplay_ini_entries(NULL);\n\t\t}\n\t}\n\n\tif (flag & PHP_INFO_MODULES) {\n\t\tHashTable sorted_registry;\n\t\tzend_module_entry tmp;\n\n\t\tzend_hash_init(&sorted_registry, zend_hash_num_elements(&module_registry), NULL, NULL, 1);\n\t\tzend_hash_copy(&sorted_registry, &module_registry, NULL, &tmp, sizeof(zend_module_entry));\n\t\tzend_hash_sort(&sorted_registry, zend_qsort, module_name_cmp, 0 TSRMLS_CC);\n\n\t\tzend_hash_apply(&sorted_registry, (apply_func_t) _display_module_info_func TSRMLS_CC);\n\n\t\tSECTION(\"Additional Modules\");\n\t\tphp_info_print_table_start();\n\t\tphp_info_print_table_header(1, \"Module Name\");\n\t\tzend_hash_apply(&sorted_registry, (apply_func_t) _display_module_info_def TSRMLS_CC);\n\t\tphp_info_print_table_end();\n\n\t\tzend_hash_destroy(&sorted_registry);\n\t}\n\n\tif (flag & PHP_INFO_ENVIRONMENT) {\n\t\tSECTION(\"Environment\");\n\t\tphp_info_print_table_start();\n\t\tphp_info_print_table_header(2, \"Variable\", \"Value\");\n\t\tfor (env=environ; env!=NULL && *env !=NULL; env++) {\n\t\t\ttmp1 = estrdup(*env);\n\t\t\tif (!(tmp2=strchr(tmp1,'='))) { /* malformed entry? */\n\t\t\t\tefree(tmp1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t*tmp2 = 0;\n\t\t\ttmp2++;\n\t\t\tphp_info_print_table_row(2, tmp1, tmp2);\n\t\t\tefree(tmp1);\n\t\t}\n\t\tphp_info_print_table_end();\n\t}\n\n\tif (flag & PHP_INFO_VARIABLES) {\n\t\tzval **data;\n\n\t\tSECTION(\"PHP Variables\");\n\n\t\tphp_info_print_table_start();\n\t\tphp_info_print_table_header(2, \"Variable\", \"Value\");\n\t\tif (zend_hash_find(&EG(symbol_table), \"PHP_SELF\", sizeof(\"PHP_SELF\"), (void **) &data) != FAILURE) {\n\t\t\tphp_info_print_table_row(2, \"PHP_SELF\", Z_STRVAL_PP(data));\n\t\t}\n\t\tif (zend_hash_find(&EG(symbol_table), \"PHP_AUTH_TYPE\", sizeof(\"PHP_AUTH_TYPE\"), (void **) &data) != FAILURE) {\n\t\t\tphp_info_print_table_row(2, \"PHP_AUTH_TYPE\", Z_STRVAL_PP(data));\n\t\t}\n\t\tif (zend_hash_find(&EG(symbol_table), \"PHP_AUTH_USER\", sizeof(\"PHP_AUTH_USER\"), (void **) &data) != FAILURE) {\n\t\t\tphp_info_print_table_row(2, \"PHP_AUTH_USER\", Z_STRVAL_PP(data));\n\t\t}\n\t\tif (zend_hash_find(&EG(symbol_table), \"PHP_AUTH_PW\", sizeof(\"PHP_AUTH_PW\"), (void **) &data) != FAILURE) {\n\t\t\tphp_info_print_table_row(2, \"PHP_AUTH_PW\", Z_STRVAL_PP(data));\n\t\t}\n\t\tphp_print_gpcse_array(ZEND_STRL(\"_REQUEST\") TSRMLS_CC);\n\t\tphp_print_gpcse_array(ZEND_STRL(\"_GET\") TSRMLS_CC);\n\t\tphp_print_gpcse_array(ZEND_STRL(\"_POST\") TSRMLS_CC);\n\t\tphp_print_gpcse_array(ZEND_STRL(\"_FILES\") TSRMLS_CC);\n\t\tphp_print_gpcse_array(ZEND_STRL(\"_COOKIE\") TSRMLS_CC);\n\t\tphp_print_gpcse_array(ZEND_STRL(\"_SERVER\") TSRMLS_CC);\n\t\tphp_print_gpcse_array(ZEND_STRL(\"_ENV\") TSRMLS_CC);\n\t\tphp_info_print_table_end();\n\t}\n\n\n\tif ((flag & PHP_INFO_CREDITS) && !sapi_module.phpinfo_as_text) {\n\t\tphp_info_print_hr();\n\t\tphp_print_credits(PHP_CREDITS_ALL & ~PHP_CREDITS_FULLPAGE TSRMLS_CC);\n\t}\n\n\tif (flag & PHP_INFO_LICENSE) {\n\t\tif (!sapi_module.phpinfo_as_text) {\n\t\t\tSECTION(\"PHP License\");\n\t\t\tphp_info_print_box_start(0);\n\t\t\tphp_info_print(\"<p>\\n\");\n\t\t\tphp_info_print(\"This program is free software; you can redistribute it and/or modify \");\n\t\t\tphp_info_print(\"it under the terms of the PHP License as published by the PHP Group \");\n\t\t\tphp_info_print(\"and included in the distribution in the file:  LICENSE\\n\");\n\t\t\tphp_info_print(\"</p>\\n\");\n\t\t\tphp_info_print(\"<p>\");\n\t\t\tphp_info_print(\"This program is distributed in the hope that it will be useful, \");\n\t\t\tphp_info_print(\"but WITHOUT ANY WARRANTY; without even the implied warranty of \");\n\t\t\tphp_info_print(\"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n\");\n\t\t\tphp_info_print(\"</p>\\n\");\n\t\t\tphp_info_print(\"<p>\");\n\t\t\tphp_info_print(\"If you did not receive a copy of the PHP license, or have any questions about \");\n\t\t\tphp_info_print(\"PHP licensing, please contact license@php.net.\\n\");\n\t\t\tphp_info_print(\"</p>\\n\");\n\t\t\tphp_info_print_box_end();\n\t\t} else {\n\t\t\tphp_info_print(\"\\nPHP License\\n\");\n\t\t\tphp_info_print(\"This program is free software; you can redistribute it and/or modify\\n\");\n\t\t\tphp_info_print(\"it under the terms of the PHP License as published by the PHP Group\\n\");\n\t\t\tphp_info_print(\"and included in the distribution in the file:  LICENSE\\n\");\n\t\t\tphp_info_print(\"\\n\");\n\t\t\tphp_info_print(\"This program is distributed in the hope that it will be useful,\\n\");\n\t\t\tphp_info_print(\"but WITHOUT ANY WARRANTY; without even the implied warranty of\\n\");\n\t\t\tphp_info_print(\"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n\");\n\t\t\tphp_info_print(\"\\n\");\n\t\t\tphp_info_print(\"If you did not receive a copy of the PHP license, or have any\\n\");\n\t\t\tphp_info_print(\"questions about PHP licensing, please contact license@php.net.\\n\");\n\t\t}\n\t}\n\n\tif (!sapi_module.phpinfo_as_text) {\n\t\tphp_info_print(\"</div></body></html>\");\n\t}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147060,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": " */\nPHPAPI void php_print_info(int flag TSRMLS_DC)\n{\n\tchar **env, *tmp1, *tmp2;\n\tchar *php_uname;\n\n\tif (!sapi_module.phpinfo_as_text) {\n\t\tphp_print_info_htmlhead(TSRMLS_C);\n\t} else {\n\t\tphp_info_print(\"phpinfo()\\n\");\n\t}\n\n\tif (flag & PHP_INFO_GENERAL) {\n\t\tchar *zend_version = get_zend_version();\n\t\tchar temp_api[10];\n\n\t\tphp_uname = php_get_uname('a');\n\n\t\tif (!sapi_module.phpinfo_as_text) {\n\t\t\tphp_info_print_box_start(1);\n\t\t}\n\n\t\tif (!sapi_module.phpinfo_as_text) {\n\t        time_t the_time;\n\t        struct tm *ta, tmbuf;\n\n\t        the_time = time(NULL);\n\t        ta = php_localtime_r(&the_time, &tmbuf);\n\n            php_info_print(\"<a href=\\\"http://www.php.net/\\\"><img border=\\\"0\\\" src=\\\"\");\n\t        if (ta && (ta->tm_mon==3) && (ta->tm_mday==1)) {\n\t\t        php_info_print(PHP_EGG_LOGO_DATA_URI \"\\\" alt=\\\"PHP logo\\\" /></a>\");\n\t        } else {\n\t\t        php_info_print(PHP_LOGO_DATA_URI \"\\\" alt=\\\"PHP logo\\\" /></a>\");\n\t\t\t}\n\t\t}\n\n\t\tif (!sapi_module.phpinfo_as_text) {\n\t\t\tphp_info_printf(\"<h1 class=\\\"p\\\">PHP Version %s</h1>\\n\", PHP_VERSION);\n\t\t} else {\n\t\t\tphp_info_print_table_row(2, \"PHP Version\", PHP_VERSION);\n\t\t}\n\t\tphp_info_print_box_end();\n\t\tphp_info_print_table_start();\n\t\tphp_info_print_table_row(2, \"System\", php_uname );\n\t\tphp_info_print_table_row(2, \"Build Date\", __DATE__ \" \" __TIME__ );\n#ifdef COMPILER\n\t\tphp_info_print_table_row(2, \"Compiler\", COMPILER);\n#endif\n#ifdef ARCHITECTURE\n\t\tphp_info_print_table_row(2, \"Architecture\", ARCHITECTURE);\n#endif\n#ifdef CONFIGURE_COMMAND\n\t\tphp_info_print_table_row(2, \"Configure Command\", CONFIGURE_COMMAND );\n#endif\n\n\t\tif (sapi_module.pretty_name) {\n\t\t\tphp_info_print_table_row(2, \"Server API\", sapi_module.pretty_name );\n\t\t}\n\n#ifdef VIRTUAL_DIR\n\t\tphp_info_print_table_row(2, \"Virtual Directory Support\", \"enabled\" );\n#else\n\t\tphp_info_print_table_row(2, \"Virtual Directory Support\", \"disabled\" );\n#endif\n\n\t\tphp_info_print_table_row(2, \"Configuration File (php.ini) Path\", PHP_CONFIG_FILE_PATH);\n\t\tphp_info_print_table_row(2, \"Loaded Configuration File\", php_ini_opened_path ? php_ini_opened_path : \"(none)\");\n\t\tphp_info_print_table_row(2, \"Scan this dir for additional .ini files\", php_ini_scanned_path ? php_ini_scanned_path : \"(none)\");\n\t\tphp_info_print_table_row(2, \"Additional .ini files parsed\", php_ini_scanned_files ? php_ini_scanned_files : \"(none)\");\n\n\t\tsnprintf(temp_api, sizeof(temp_api), \"%d\", PHP_API_VERSION);\n\t\tphp_info_print_table_row(2, \"PHP API\", temp_api);\n\n\t\tsnprintf(temp_api, sizeof(temp_api), \"%d\", ZEND_MODULE_API_NO);\n\t\tphp_info_print_table_row(2, \"PHP Extension\", temp_api);\n\n\t\tsnprintf(temp_api, sizeof(temp_api), \"%d\", ZEND_EXTENSION_API_NO);\n\t\tphp_info_print_table_row(2, \"Zend Extension\", temp_api);\n\n\t\tphp_info_print_table_row(2, \"Zend Extension Build\", ZEND_EXTENSION_BUILD_ID);\n\t\tphp_info_print_table_row(2, \"PHP Extension Build\", ZEND_MODULE_BUILD_ID);\n\n#if ZEND_DEBUG\n\t\tphp_info_print_table_row(2, \"Debug Build\", \"yes\" );\n#else\n\t\tphp_info_print_table_row(2, \"Debug Build\", \"no\" );\n#endif\n\n#ifdef ZTS\n\t\tphp_info_print_table_row(2, \"Thread Safety\", \"enabled\" );\n#else\n\t\tphp_info_print_table_row(2, \"Thread Safety\", \"disabled\" );\n#endif\n\n#ifdef ZEND_SIGNALS\n\t\tphp_info_print_table_row(2, \"Zend Signal Handling\", \"enabled\" );\n#else\n\t\tphp_info_print_table_row(2, \"Zend Signal Handling\", \"disabled\" );\n#endif\n\n\t\tphp_info_print_table_row(2, \"Zend Memory Manager\", is_zend_mm(TSRMLS_C) ? \"enabled\" : \"disabled\" );\n\n\t\t{\n\t\t\tconst zend_multibyte_functions *functions = zend_multibyte_get_functions(TSRMLS_C);\n\t\t\tchar *descr;\n\t\t\tif (functions) {\n\t\t\t\tspprintf(&descr, 0, \"provided by %s\", functions->provider_name);\n\t\t\t} else {\n\t\t\t\tdescr = estrdup(\"disabled\");\n\t\t\t}\n            php_info_print_table_row(2, \"Zend Multibyte Support\", descr);\n\t\t\tefree(descr);\n\t\t}\n\n#if HAVE_IPV6\n\t\tphp_info_print_table_row(2, \"IPv6 Support\", \"enabled\" );\n#else\n\t\tphp_info_print_table_row(2, \"IPv6 Support\", \"disabled\" );\n#endif\n\n#if HAVE_DTRACE\n\t\tphp_info_print_table_row(2, \"DTrace Support\", \"enabled\" );\n#else\n\t\tphp_info_print_table_row(2, \"DTrace Support\", \"disabled\" );\n#endif\n\n\t\tphp_info_print_stream_hash(\"PHP Streams\",  php_stream_get_url_stream_wrappers_hash() TSRMLS_CC);\n\t\tphp_info_print_stream_hash(\"Stream Socket Transports\", php_stream_xport_get_hash() TSRMLS_CC);\n\t\tphp_info_print_stream_hash(\"Stream Filters\", php_get_stream_filters_hash() TSRMLS_CC);\n\n\t\tphp_info_print_table_end();\n\n\t\t/* Zend Engine */\n\t\tphp_info_print_box_start(0);\n\t\tif (!sapi_module.phpinfo_as_text) {\n\t\t\tphp_info_print(\"<a href=\\\"http://www.zend.com/\\\"><img border=\\\"0\\\" src=\\\"\");\n\t\t\tphp_info_print(ZEND_LOGO_DATA_URI \"\\\" alt=\\\"Zend logo\\\" /></a>\\n\");\n\t\t}\n\t\tphp_info_print(\"This program makes use of the Zend Scripting Language Engine:\");\n\t\tphp_info_print(!sapi_module.phpinfo_as_text?\"<br />\":\"\\n\");\n\t\tif (sapi_module.phpinfo_as_text) {\n\t\t\tphp_info_print(zend_version);\n\t\t} else {\n\t\t\tzend_html_puts(zend_version, strlen(zend_version) TSRMLS_CC);\n\t\t}\n\t\tphp_info_print_box_end();\n\t\tefree(php_uname);\n\t}\n\n\tzend_ini_sort_entries(TSRMLS_C);\n\n\tif (flag & PHP_INFO_CONFIGURATION) {\n\t\tphp_info_print_hr();\n\t\tif (!sapi_module.phpinfo_as_text) {\n\t\t\tphp_info_print(\"<h1>Configuration</h1>\\n\");\n\t\t} else {\n\t\t\tSECTION(\"Configuration\");\n\t\t}\n\t\tif (!(flag & PHP_INFO_MODULES)) {\n\t\t\tSECTION(\"PHP Core\");\n\t\t\tdisplay_ini_entries(NULL);\n\t\t}\n\t}\n\n\tif (flag & PHP_INFO_MODULES) {\n\t\tHashTable sorted_registry;\n\t\tzend_module_entry tmp;\n\n\t\tzend_hash_init(&sorted_registry, zend_hash_num_elements(&module_registry), NULL, NULL, 1);\n\t\tzend_hash_copy(&sorted_registry, &module_registry, NULL, &tmp, sizeof(zend_module_entry));\n\t\tzend_hash_sort(&sorted_registry, zend_qsort, module_name_cmp, 0 TSRMLS_CC);\n\n\t\tzend_hash_apply(&sorted_registry, (apply_func_t) _display_module_info_func TSRMLS_CC);\n\n\t\tSECTION(\"Additional Modules\");\n\t\tphp_info_print_table_start();\n\t\tphp_info_print_table_header(1, \"Module Name\");\n\t\tzend_hash_apply(&sorted_registry, (apply_func_t) _display_module_info_def TSRMLS_CC);\n\t\tphp_info_print_table_end();\n\n\t\tzend_hash_destroy(&sorted_registry);\n\t}\n\n\tif (flag & PHP_INFO_ENVIRONMENT) {\n\t\tSECTION(\"Environment\");\n\t\tphp_info_print_table_start();\n\t\tphp_info_print_table_header(2, \"Variable\", \"Value\");\n\t\tfor (env=environ; env!=NULL && *env !=NULL; env++) {\n\t\t\ttmp1 = estrdup(*env);\n\t\t\tif (!(tmp2=strchr(tmp1,'='))) { /* malformed entry? */\n\t\t\t\tefree(tmp1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t*tmp2 = 0;\n\t\t\ttmp2++;\n\t\t\tphp_info_print_table_row(2, tmp1, tmp2);\n\t\t\tefree(tmp1);\n\t\t}\n\t\tphp_info_print_table_end();\n\t}\n\n\tif (flag & PHP_INFO_VARIABLES) {\n\t\tzval **data;\n\n\t\tSECTION(\"PHP Variables\");\n\n\t\tphp_info_print_table_start();\n\t\tphp_info_print_table_header(2, \"Variable\", \"Value\");\n\t\tif (zend_hash_find(&EG(symbol_table), \"PHP_SELF\", sizeof(\"PHP_SELF\"), (void **) &data) != FAILURE && Z_TYPE_PP(data) == IS_STRING) {\n\t\t\tphp_info_print_table_row(2, \"PHP_SELF\", Z_STRVAL_PP(data));\n\t\t}\n\t\tif (zend_hash_find(&EG(symbol_table), \"PHP_AUTH_TYPE\", sizeof(\"PHP_AUTH_TYPE\"), (void **) &data) != FAILURE && Z_TYPE_PP(data) == IS_STRING) {\n\t\t\tphp_info_print_table_row(2, \"PHP_AUTH_TYPE\", Z_STRVAL_PP(data));\n\t\t}\n\t\tif (zend_hash_find(&EG(symbol_table), \"PHP_AUTH_USER\", sizeof(\"PHP_AUTH_USER\"), (void **) &data) != FAILURE && Z_TYPE_PP(data) == IS_STRING) {\n\t\t\tphp_info_print_table_row(2, \"PHP_AUTH_USER\", Z_STRVAL_PP(data));\n\t\t}\n\t\tif (zend_hash_find(&EG(symbol_table), \"PHP_AUTH_PW\", sizeof(\"PHP_AUTH_PW\"), (void **) &data) != FAILURE && Z_TYPE_PP(data) == IS_STRING) {\n\t\t\tphp_info_print_table_row(2, \"PHP_AUTH_PW\", Z_STRVAL_PP(data));\n\t\t}\n\t\tphp_print_gpcse_array(ZEND_STRL(\"_REQUEST\") TSRMLS_CC);\n\t\tphp_print_gpcse_array(ZEND_STRL(\"_GET\") TSRMLS_CC);\n\t\tphp_print_gpcse_array(ZEND_STRL(\"_POST\") TSRMLS_CC);\n\t\tphp_print_gpcse_array(ZEND_STRL(\"_FILES\") TSRMLS_CC);\n\t\tphp_print_gpcse_array(ZEND_STRL(\"_COOKIE\") TSRMLS_CC);\n\t\tphp_print_gpcse_array(ZEND_STRL(\"_SERVER\") TSRMLS_CC);\n\t\tphp_print_gpcse_array(ZEND_STRL(\"_ENV\") TSRMLS_CC);\n\t\tphp_info_print_table_end();\n\t}\n\n\n\tif ((flag & PHP_INFO_CREDITS) && !sapi_module.phpinfo_as_text) {\n\t\tphp_info_print_hr();\n\t\tphp_print_credits(PHP_CREDITS_ALL & ~PHP_CREDITS_FULLPAGE TSRMLS_CC);\n\t}\n\n\tif (flag & PHP_INFO_LICENSE) {\n\t\tif (!sapi_module.phpinfo_as_text) {\n\t\t\tSECTION(\"PHP License\");\n\t\t\tphp_info_print_box_start(0);\n\t\t\tphp_info_print(\"<p>\\n\");\n\t\t\tphp_info_print(\"This program is free software; you can redistribute it and/or modify \");\n\t\t\tphp_info_print(\"it under the terms of the PHP License as published by the PHP Group \");\n\t\t\tphp_info_print(\"and included in the distribution in the file:  LICENSE\\n\");\n\t\t\tphp_info_print(\"</p>\\n\");\n\t\t\tphp_info_print(\"<p>\");\n\t\t\tphp_info_print(\"This program is distributed in the hope that it will be useful, \");\n\t\t\tphp_info_print(\"but WITHOUT ANY WARRANTY; without even the implied warranty of \");\n\t\t\tphp_info_print(\"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n\");\n\t\t\tphp_info_print(\"</p>\\n\");\n\t\t\tphp_info_print(\"<p>\");\n\t\t\tphp_info_print(\"If you did not receive a copy of the PHP license, or have any questions about \");\n\t\t\tphp_info_print(\"PHP licensing, please contact license@php.net.\\n\");\n\t\t\tphp_info_print(\"</p>\\n\");\n\t\t\tphp_info_print_box_end();\n\t\t} else {\n\t\t\tphp_info_print(\"\\nPHP License\\n\");\n\t\t\tphp_info_print(\"This program is free software; you can redistribute it and/or modify\\n\");\n\t\t\tphp_info_print(\"it under the terms of the PHP License as published by the PHP Group\\n\");\n\t\t\tphp_info_print(\"and included in the distribution in the file:  LICENSE\\n\");\n\t\t\tphp_info_print(\"\\n\");\n\t\t\tphp_info_print(\"This program is distributed in the hope that it will be useful,\\n\");\n\t\t\tphp_info_print(\"but WITHOUT ANY WARRANTY; without even the implied warranty of\\n\");\n\t\t\tphp_info_print(\"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n\");\n\t\t\tphp_info_print(\"\\n\");\n\t\t\tphp_info_print(\"If you did not receive a copy of the PHP license, or have any\\n\");\n\t\t\tphp_info_print(\"questions about PHP licensing, please contact license@php.net.\\n\");\n\t\t}\n\t}\n\n\tif (!sapi_module.phpinfo_as_text) {\n\t\tphp_info_print(\"</div></body></html>\");\n\t}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147061,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "  bool Messageheader::Parser::state_fieldbody_crlf(char ch)\n  {\n    if (ch == '\\r')\n      SET_STATE(state_end_cr);\n    else if (ch == '\\n')\n    {\n      log_debug(\"header \" << fieldnamePtr << \": \" << fieldbodyPtr);\n      switch (header.onField(fieldnamePtr, fieldbodyPtr))\n      {\n        case OK:\n        case END:  return true;\n                   break;\n        case FAIL: failedFlag = true;\n                   log_warn(\"invalid character \" << chartoprint(ch) << \" in fieldbody\");\n                   break;\n      }\n\n      *headerdataPtr = '\\0';\n      return true;\n    }\n    else if (std::isspace(ch))\n    {\n      // continuation line\n      checkHeaderspace(1);\n      *(headerdataPtr - 1) = '\\n';\n      *headerdataPtr++ = ch;\n      SET_STATE(state_fieldbody);\n    }\n    else if (ch >= 33 && ch <= 126)\n    {\n      switch (header.onField(fieldnamePtr, fieldbodyPtr))\n      {\n        case OK:   SET_STATE(state_fieldname);\n                   break;\n        case FAIL: failedFlag = true;\n                   log_warn(\"invalid character \" << chartoprint(ch) << \" in fieldbody\");\n                   break;\n        case END:  return true;\n                   break;\n      }\n\n      fieldnamePtr = headerdataPtr;\n      checkHeaderspace(1);\n      *headerdataPtr++ = ch;\n    }\n    return false;\n  }",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147154,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "  bool Messageheader::Parser::state_fieldbody_crlf(char ch)\n  {\n    if (ch == '\\r')\n      SET_STATE(state_end_cr);\n    else if (ch == '\\n')\n    {\n      log_debug(\"header \" << fieldnamePtr << \": \" << fieldbodyPtr);\n      if (header.onField(fieldnamePtr, fieldbodyPtr) == FAIL)\n      {\n        failedFlag = true;\n        log_warn(\"invalid character \" << chartoprint(ch) << \" in fieldbody\");\n      }\n\n      *headerdataPtr = '\\0';\n      return true;\n    }\n    else if (std::isspace(ch))\n    {\n      // continuation line\n      checkHeaderspace(1);\n      *(headerdataPtr - 1) = '\\n';\n      *headerdataPtr++ = ch;\n      SET_STATE(state_fieldbody);\n    }\n    else if (ch >= 33 && ch <= 126)\n    {\n      switch (header.onField(fieldnamePtr, fieldbodyPtr))\n      {\n        case OK:   SET_STATE(state_fieldname);\n                   break;\n        case FAIL: failedFlag = true;\n                   log_warn(\"invalid character \" << chartoprint(ch) << \" in fieldbody\");\n                   break;\n        case END:  return true;\n                   break;\n      }\n\n      fieldnamePtr = headerdataPtr;\n      checkHeaderspace(1);\n      *headerdataPtr++ = ch;\n    }\n    return false;\n  }",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147155,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static bool is_legal_file(const std::string &filename)\n{\n\tDBG_FS << \"Looking for '\" << filename << \"'.\\n\";\n\n\tif (filename.empty()) {\n\t\tLOG_FS << \"  invalid filename\\n\";\n\t\treturn false;\n\t}\n\n\tif (filename.find(\"..\") != std::string::npos) {\n\t\tERR_FS << \"Illegal path '\" << filename << \"' (\\\"..\\\" not allowed).\\n\";\n\t\treturn false;\n\t}\n\n\tif (ends_with(filename, \".pbl\")) {\n\t\tERR_FS << \"Illegal path '\" << filename << \"' (.pbl files are not allowed).\" << std::endl;\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147206,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static bool is_legal_file(const std::string &filename)\n{\n\tDBG_FS << \"Looking for '\" << filename << \"'.\\n\";\n\n\tif (filename.empty()) {\n\t\tLOG_FS << \"  invalid filename\\n\";\n\t\treturn false;\n\t}\n\n\tif (filename.find(\"..\") != std::string::npos) {\n\t\tERR_FS << \"Illegal path '\" << filename << \"' (\\\"..\\\" not allowed).\\n\";\n\t\treturn false;\n\t}\n\n\tif (looks_like_pbl(filename)) {\n\t\tERR_FS << \"Illegal path '\" << filename << \"' (.pbl files are not allowed).\" << std::endl;\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147207,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "std::string get_wml_location(const std::string &filename, const std::string &current_dir)\n{\n\tDBG_FS << \"Looking for '\" << filename << \"'.\" << std::endl;\n\n\tassert(game_config::path.empty() == false);\n\n\tstd::string result;\n\n\tif (filename.empty()) {\n\t\tLOG_FS << \"  invalid filename\" << std::endl;\n\t\treturn result;\n\t}\n\n\tif (filename.find(\"..\") != std::string::npos) {\n\t\tERR_FS << \"Illegal path '\" << filename << \"' (\\\"..\\\" not allowed).\" << std::endl;\n\t\treturn result;\n\t}\n\n\tif (ends_with(filename, \".pbl\")) {\n\t\tERR_FS << \"Illegal path '\" << filename << \"' (.pbl files are not allowed).\" << std::endl;\n\t\treturn result;\n\t}\n\n\tbool already_found = false;\n\n\tif (filename[0] == '~')\n\t{\n\t\t// If the filename starts with '~', look in the user data directory.\n\t\tresult = get_user_data_dir() + \"/data/\" + filename.substr(1);\n\t\tDBG_FS << \"  trying '\" << result << \"'\" << std::endl;\n\n\t\talready_found = file_exists(result) || is_directory(result);\n\t}\n\telse if (filename.size() >= 2 && filename[0] == '.' && filename[1] == '/')\n\t{\n\t\t// If the filename begins with a \"./\", look in the same directory\n\t\t// as the file currently being preprocessed.\n\n\t\tif (!current_dir.empty())\n\t\t{\n\t\t\tresult = current_dir;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = game_config::path;\n\t\t}\n\n\t\tresult += filename.substr(2);\n\t}\n\telse if (!game_config::path.empty())\n\t\tresult = game_config::path + \"/data/\" + filename;\n\n\tDBG_FS << \"  trying '\" << result << \"'\" << std::endl;\n\n\tif (result.empty() ||\n\t    (!already_found && !file_exists(result) && !is_directory(result)))\n\t{\n\t\tDBG_FS << \"  not found\" << std::endl;\n\t\tresult.clear();\n\t}\n\telse\n\t\tDBG_FS << \"  found: '\" << result << \"'\" << std::endl;\n\n\treturn result;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147208,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "std::string get_wml_location(const std::string &filename, const std::string &current_dir)\n{\n\tDBG_FS << \"Looking for '\" << filename << \"'.\" << std::endl;\n\n\tassert(game_config::path.empty() == false);\n\n\tstd::string result;\n\n\tif (filename.empty()) {\n\t\tLOG_FS << \"  invalid filename\" << std::endl;\n\t\treturn result;\n\t}\n\n\tif (filename.find(\"..\") != std::string::npos) {\n\t\tERR_FS << \"Illegal path '\" << filename << \"' (\\\"..\\\" not allowed).\" << std::endl;\n\t\treturn result;\n\t}\n\n\tif (looks_like_pbl(filename)) {\n\t\tERR_FS << \"Illegal path '\" << filename << \"' (.pbl files are not allowed).\" << std::endl;\n\t\treturn result;\n\t}\n\n\tbool already_found = false;\n\n\tif (filename[0] == '~')\n\t{\n\t\t// If the filename starts with '~', look in the user data directory.\n\t\tresult = get_user_data_dir() + \"/data/\" + filename.substr(1);\n\t\tDBG_FS << \"  trying '\" << result << \"'\" << std::endl;\n\n\t\talready_found = file_exists(result) || is_directory(result);\n\t}\n\telse if (filename.size() >= 2 && filename[0] == '.' && filename[1] == '/')\n\t{\n\t\t// If the filename begins with a \"./\", look in the same directory\n\t\t// as the file currently being preprocessed.\n\n\t\tif (!current_dir.empty())\n\t\t{\n\t\t\tresult = current_dir;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = game_config::path;\n\t\t}\n\n\t\tresult += filename.substr(2);\n\t}\n\telse if (!game_config::path.empty())\n\t\tresult = game_config::path + \"/data/\" + filename;\n\n\tDBG_FS << \"  trying '\" << result << \"'\" << std::endl;\n\n\tif (result.empty() ||\n\t    (!already_found && !file_exists(result) && !is_directory(result)))\n\t{\n\t\tDBG_FS << \"  not found\" << std::endl;\n\t\tresult.clear();\n\t}\n\telse\n\t\tDBG_FS << \"  found: '\" << result << \"'\" << std::endl;\n\n\treturn result;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147209,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int open_user_core(uid_t uid, uid_t fsuid, pid_t pid, char **percent_values)\n{\n    proc_cwd = open_cwd(pid);\n    if (proc_cwd == NULL)\n        return -1;\n\n    errno = 0;\n\n    /* http://article.gmane.org/gmane.comp.security.selinux/21842 */\n    security_context_t newcon;\n    if (compute_selinux_con_for_new_file(pid, dirfd(proc_cwd), &newcon) < 0)\n    {\n        log_notice(\"Not going to create a user core due to SELinux errors\");\n        return -1;\n    }\n\n    xsetegid(get_fsgid());\n    xseteuid(fsuid);\n\n    if (strcmp(core_basename, \"core\") == 0)\n    {\n        /* Mimic \"core.PID\" if requested */\n        char buf[] = \"0\\n\";\n        int fd = open(\"/proc/sys/kernel/core_uses_pid\", O_RDONLY);\n        if (fd >= 0)\n        {\n            IGNORE_RESULT(read(fd, buf, sizeof(buf)));\n            close(fd);\n        }\n        if (strcmp(buf, \"1\\n\") == 0)\n        {\n            core_basename = xasprintf(\"%s.%lu\", core_basename, (long)pid);\n        }\n    }\n    else\n    {\n        /* Expand old core pattern, put expanded name in core_basename */\n        core_basename = xstrdup(core_basename);\n        unsigned idx = 0;\n        while (1)\n        {\n            char c = core_basename[idx];\n            if (!c)\n                break;\n            idx++;\n            if (c != '%')\n                continue;\n\n            /* We just copied %, look at following char and expand %c */\n            c = core_basename[idx];\n            unsigned specifier_num = strchrnul(percent_specifiers, c) - percent_specifiers;\n            if (percent_specifiers[specifier_num] != '\\0') /* valid %c (might be %% too) */\n            {\n                const char *val = \"%\";\n                if (specifier_num > 0) /* not %% */\n                    val = percent_values[specifier_num - 1];\n                //log(\"c:'%c'\", c);\n                //log(\"val:'%s'\", val);\n\n                /* Replace %c at core_basename[idx] by its value */\n                idx--;\n                char *old = core_basename;\n                core_basename = xasprintf(\"%.*s%s%s\", idx, core_basename, val, core_basename + idx + 2);\n                //log(\"pos:'%*s|'\", idx, \"\");\n                //log(\"new:'%s'\", core_basename);\n                //log(\"old:'%s'\", old);\n                free(old);\n                idx += strlen(val);\n            }\n            /* else: invalid %c, % is already copied verbatim,\n             * next loop iteration will copy c */\n        }\n    }\n\n    if (g_need_nonrelative && core_basename[0] != '/')\n    {\n        error_msg(\"Current suid_dumpable policy prevents from saving core dumps according to relative core_pattern\");\n        return -1;\n    }\n\n    /* Open (create) compat core file.\n     * man core:\n     * There are various circumstances in which a core dump file\n     * is not produced:\n     *\n     * [skipped obvious ones]\n     * The process does not have permission to write the core file.\n     * ...if a file with the same name exists and is not writable\n     * or is not a regular file (e.g., it is a directory or a symbolic link).\n     *\n     * A file with the same name already exists, but there is more\n     * than one hard link to that file.\n     *\n     * The file system where the core dump file would be created is full;\n     * or has run out of inodes; or is mounted read-only;\n     * or the user has reached their quota for the file system.\n     *\n     * The RLIMIT_CORE or RLIMIT_FSIZE resource limits for the process\n     * are set to zero.\n     * [we check RLIMIT_CORE, but how can we check RLIMIT_FSIZE?]\n     *\n     * The binary being executed by the process does not have\n     * read permission enabled. [how we can check it here?]\n     *\n     * The process is executing a set-user-ID (set-group-ID) program\n     * that is owned by a user (group) other than the real\n     * user (group) ID of the process. [TODO?]\n     * (However, see the description of the prctl(2) PR_SET_DUMPABLE operation,\n     * and the description of the /proc/sys/fs/suid_dumpable file in proc(5).)\n     */\n\n    /* Set SELinux context like kernel when creating core dump file */\n    if (newcon != NULL && setfscreatecon_raw(newcon) < 0)\n    {\n        perror_msg(\"setfscreatecon_raw(%s)\", newcon);\n        return -1;\n    }\n\n    struct stat sb;\n    errno = 0;\n    /* Do not O_TRUNC: if later checks fail, we do not want to have file already modified here */\n    int user_core_fd = openat(dirfd(proc_cwd), core_basename, O_WRONLY | O_CREAT | O_NOFOLLOW | g_user_core_flags, 0600); /* kernel makes 0600 too */\n\n    if (newcon != NULL && setfscreatecon_raw(NULL) < 0)\n    {\n        error_msg(\"setfscreatecon_raw(NULL)\");\n        goto user_core_fail;\n    }\n\n    xsetegid(0);\n    xseteuid(0);\n    if (user_core_fd < 0\n     || fstat(user_core_fd, &sb) != 0\n     || !S_ISREG(sb.st_mode)\n     || sb.st_nlink != 1\n     || sb.st_uid != fsuid\n    ) {\n        if (user_core_fd < 0)\n            perror_msg(\"Can't open '%s' at '%s'\", core_basename, user_pwd);\n        else\n            perror_msg(\"'%s' at '%s' is not a regular file with link count 1 owned by UID(%d)\", core_basename, user_pwd, fsuid);\n        goto user_core_fail;\n    }\n    if (ftruncate(user_core_fd, 0) != 0) {\n        /* perror first, otherwise unlink may trash errno */\n        perror_msg(\"Can't truncate '%s' at '%s' to size 0\", core_basename, user_pwd);\n        goto user_core_fail;\n    }\n\n    return user_core_fd;\n\nuser_core_fail:\n    if (user_core_fd >= 0)\n    {\n        close(user_core_fd);\n        unlinkat(dirfd(proc_cwd), core_basename, /*unlink file*/0);\n    }\n    return -1;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147382,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int open_user_core(uid_t uid, uid_t fsuid, pid_t pid, char **percent_values)\n{\n    proc_cwd = open_cwd(pid);\n    if (proc_cwd == NULL)\n        return -1;\n\n    errno = 0;\n\n    /* http://article.gmane.org/gmane.comp.security.selinux/21842 */\n    security_context_t newcon;\n    if (compute_selinux_con_for_new_file(pid, dirfd(proc_cwd), &newcon) < 0)\n    {\n        log_notice(\"Not going to create a user core due to SELinux errors\");\n        return -1;\n    }\n\n    if (strcmp(core_basename, \"core\") == 0)\n    {\n        /* Mimic \"core.PID\" if requested */\n        char buf[] = \"0\\n\";\n        int fd = open(\"/proc/sys/kernel/core_uses_pid\", O_RDONLY);\n        if (fd >= 0)\n        {\n            IGNORE_RESULT(read(fd, buf, sizeof(buf)));\n            close(fd);\n        }\n        if (strcmp(buf, \"1\\n\") == 0)\n        {\n            core_basename = xasprintf(\"%s.%lu\", core_basename, (long)pid);\n        }\n    }\n    else\n    {\n        /* Expand old core pattern, put expanded name in core_basename */\n        core_basename = xstrdup(core_basename);\n        unsigned idx = 0;\n        while (1)\n        {\n            char c = core_basename[idx];\n            if (!c)\n                break;\n            idx++;\n            if (c != '%')\n                continue;\n\n            /* We just copied %, look at following char and expand %c */\n            c = core_basename[idx];\n            unsigned specifier_num = strchrnul(percent_specifiers, c) - percent_specifiers;\n            if (percent_specifiers[specifier_num] != '\\0') /* valid %c (might be %% too) */\n            {\n                const char *val = \"%\";\n                if (specifier_num > 0) /* not %% */\n                    val = percent_values[specifier_num - 1];\n                //log(\"c:'%c'\", c);\n                //log(\"val:'%s'\", val);\n\n                /* Replace %c at core_basename[idx] by its value */\n                idx--;\n                char *old = core_basename;\n                core_basename = xasprintf(\"%.*s%s%s\", idx, core_basename, val, core_basename + idx + 2);\n                //log(\"pos:'%*s|'\", idx, \"\");\n                //log(\"new:'%s'\", core_basename);\n                //log(\"old:'%s'\", old);\n                free(old);\n                idx += strlen(val);\n            }\n            /* else: invalid %c, % is already copied verbatim,\n             * next loop iteration will copy c */\n        }\n    }\n\n    if (g_need_nonrelative && core_basename[0] != '/')\n    {\n        error_msg(\"Current suid_dumpable policy prevents from saving core dumps according to relative core_pattern\");\n        return -1;\n    }\n\n    /* Open (create) compat core file.\n     * man core:\n     * There are various circumstances in which a core dump file\n     * is not produced:\n     *\n     * [skipped obvious ones]\n     * The process does not have permission to write the core file.\n     * ...if a file with the same name exists and is not writable\n     * or is not a regular file (e.g., it is a directory or a symbolic link).\n     *\n     * A file with the same name already exists, but there is more\n     * than one hard link to that file.\n     *\n     * The file system where the core dump file would be created is full;\n     * or has run out of inodes; or is mounted read-only;\n     * or the user has reached their quota for the file system.\n     *\n     * The RLIMIT_CORE or RLIMIT_FSIZE resource limits for the process\n     * are set to zero.\n     * [we check RLIMIT_CORE, but how can we check RLIMIT_FSIZE?]\n     *\n     * The binary being executed by the process does not have\n     * read permission enabled. [how we can check it here?]\n     *\n     * The process is executing a set-user-ID (set-group-ID) program\n     * that is owned by a user (group) other than the real\n     * user (group) ID of the process. [TODO?]\n     * (However, see the description of the prctl(2) PR_SET_DUMPABLE operation,\n     * and the description of the /proc/sys/fs/suid_dumpable file in proc(5).)\n     */\n\n    int user_core_fd = -1;\n    int selinux_fail = 1;\n\n    /*\n     * These calls must be reverted as soon as possible.\n     */\n    xsetegid(get_fsgid());\n    xseteuid(fsuid);\n\n    /* Set SELinux context like kernel when creating core dump file.\n     * This condition is TRUE if */\n    if (/* SELinux is disabled  */ newcon == NULL\n     || /* or the call succeeds */ setfscreatecon_raw(newcon) >= 0)\n    {\n        /* Do not O_TRUNC: if later checks fail, we do not want to have file already modified here */\n        user_core_fd = openat(dirfd(proc_cwd), core_basename, O_WRONLY | O_CREAT | O_NOFOLLOW | g_user_core_flags, 0600); /* kernel makes 0600 too */\n\n        /* Do the error check here and print the error message in order to\n         * avoid interference in 'errno' usage caused by SELinux functions */\n        if (user_core_fd < 0)\n            perror_msg(\"Can't open '%s' at '%s'\", core_basename, user_pwd);\n\n        /* Fail if SELinux is enabled and the call fails */\n        if (newcon != NULL && setfscreatecon_raw(NULL) < 0)\n            perror_msg(\"setfscreatecon_raw(NULL)\");\n        else\n            selinux_fail = 0;\n    }\n    else\n        perror_msg(\"setfscreatecon_raw(%s)\", newcon);\n\n    /*\n     * DON'T JUMP OVER THIS REVERT OF THE UID/GID CHANGES\n     */\n    xsetegid(0);\n    xseteuid(0);\n\n    if (user_core_fd < 0 || selinux_fail)\n        goto user_core_fail;\n\n    struct stat sb;\n    if (fstat(user_core_fd, &sb) != 0\n     || !S_ISREG(sb.st_mode)\n     || sb.st_nlink != 1\n     || sb.st_uid != fsuid\n    ) {\n        perror_msg(\"'%s' at '%s' is not a regular file with link count 1 owned by UID(%d)\", core_basename, user_pwd, fsuid);\n        goto user_core_fail;\n    }\n    if (ftruncate(user_core_fd, 0) != 0) {\n        /* perror first, otherwise unlink may trash errno */\n        perror_msg(\"Can't truncate '%s' at '%s' to size 0\", core_basename, user_pwd);\n        goto user_core_fail;\n    }\n\n    return user_core_fd;\n\nuser_core_fail:\n    if (user_core_fd >= 0)\n    {\n        close(user_core_fd);\n        unlinkat(dirfd(proc_cwd), core_basename, /*unlink file*/0);\n    }\n    return -1;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147383,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int mwifiex_pcie_init_evt_ring(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tstruct mwifiex_evt_buf_desc *desc;\n\tstruct sk_buff *skb;\n\tdma_addr_t buf_pa;\n\tint i;\n\n\tfor (i = 0; i < MWIFIEX_MAX_EVT_BD; i++) {\n\t\t/* Allocate skb here so that firmware can DMA data from it */\n\t\tskb = dev_alloc_skb(MAX_EVENT_SIZE);\n\t\tif (!skb) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Unable to allocate skb for EVENT buf.\\n\");\n\t\t\tkfree(card->evtbd_ring_vbase);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tskb_put(skb, MAX_EVENT_SIZE);\n\n\t\tif (mwifiex_map_pci_memory(adapter, skb, MAX_EVENT_SIZE,\n\t\t\t\t\t   PCI_DMA_FROMDEVICE))\n\t\t\treturn -1;\n\n\t\tbuf_pa = MWIFIEX_SKB_DMA_ADDR(skb);\n\n\t\tmwifiex_dbg(adapter, EVENT,\n\t\t\t    \"info: EVT ring: skb=%p len=%d data=%p buf_pa=%#x:%x\\n\",\n\t\t\t    skb, skb->len, skb->data, (u32)buf_pa,\n\t\t\t    (u32)((u64)buf_pa >> 32));\n\n\t\tcard->evt_buf_list[i] = skb;\n\t\tcard->evtbd_ring[i] = (void *)(card->evtbd_ring_vbase +\n\t\t\t\t      (sizeof(*desc) * i));\n\t\tdesc = card->evtbd_ring[i];\n\t\tdesc->paddr = buf_pa;\n\t\tdesc->len = (u16)skb->len;\n\t\tdesc->flags = 0;\n\t}\n\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147384,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int mwifiex_pcie_init_evt_ring(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tstruct mwifiex_evt_buf_desc *desc;\n\tstruct sk_buff *skb;\n\tdma_addr_t buf_pa;\n\tint i;\n\n\tfor (i = 0; i < MWIFIEX_MAX_EVT_BD; i++) {\n\t\t/* Allocate skb here so that firmware can DMA data from it */\n\t\tskb = dev_alloc_skb(MAX_EVENT_SIZE);\n\t\tif (!skb) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Unable to allocate skb for EVENT buf.\\n\");\n\t\t\tkfree(card->evtbd_ring_vbase);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tskb_put(skb, MAX_EVENT_SIZE);\n\n\t\tif (mwifiex_map_pci_memory(adapter, skb, MAX_EVENT_SIZE,\n\t\t\t\t\t   PCI_DMA_FROMDEVICE)) {\n\t\t\tkfree_skb(skb);\n\t\t\tkfree(card->evtbd_ring_vbase);\n\t\t\treturn -1;\n\t\t}\n\n\t\tbuf_pa = MWIFIEX_SKB_DMA_ADDR(skb);\n\n\t\tmwifiex_dbg(adapter, EVENT,\n\t\t\t    \"info: EVT ring: skb=%p len=%d data=%p buf_pa=%#x:%x\\n\",\n\t\t\t    skb, skb->len, skb->data, (u32)buf_pa,\n\t\t\t    (u32)((u64)buf_pa >> 32));\n\n\t\tcard->evt_buf_list[i] = skb;\n\t\tcard->evtbd_ring[i] = (void *)(card->evtbd_ring_vbase +\n\t\t\t\t      (sizeof(*desc) * i));\n\t\tdesc = card->evtbd_ring[i];\n\t\tdesc->paddr = buf_pa;\n\t\tdesc->len = (u16)skb->len;\n\t\tdesc->flags = 0;\n\t}\n\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147385,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "compile_get_env(char_u **arg, cctx_T *cctx)\n{\n    char_u\t*start = *arg;\n    int\t\tlen;\n    int\t\tret;\n    char_u\t*name;\n\n    ++*arg;\n    len = get_env_len(arg);\n    if (len == 0)\n    {\n\tsemsg(_(e_syntax_error_at_str), start - 1);\n\treturn FAIL;\n    }\n\n    // include the '$' in the name, eval_env_var() expects it.\n    name = vim_strnsave(start, len + 1);\n    ret = generate_LOAD(cctx, ISN_LOADENV, 0, name, &t_string);\n    vim_free(name);\n    return ret;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147392,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "compile_get_env(char_u **arg, cctx_T *cctx)\n{\n    char_u\t*start = *arg;\n    int\t\tlen;\n    int\t\tret;\n    char_u\t*name;\n\n    ++*arg;\n    len = get_env_len(arg);\n    if (len == 0)\n    {\n\tsemsg(_(e_syntax_error_at_str), start);\n\treturn FAIL;\n    }\n\n    // include the '$' in the name, eval_env_var() expects it.\n    name = vim_strnsave(start, len + 1);\n    ret = generate_LOAD(cctx, ISN_LOADENV, 0, name, &t_string);\n    vim_free(name);\n    return ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147393,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "main(int argc, char *argv[]) {\n\tint c, result = 0, specseen;\n\tchar *options = NULL, *test_opts = NULL, *node;\n\tconst char *spec = NULL;\n\tchar *label = NULL;\n\tchar *uuid = NULL;\n\tchar *types = NULL;\n\tchar *p;\n\tstruct mntentchn *mc;\n\tint fd;\n\n\tsanitize_env();\n\tsetlocale(LC_ALL, \"\");\n\tbindtextdomain(PACKAGE, LOCALEDIR);\n\ttextdomain(PACKAGE);\n\tatexit(close_stdout);\n\n\tprogname = argv[0];\n\tif ((p = strrchr(progname, '/')) != NULL)\n\t\tprogname = p+1;\n\n\tumask(022);\n\n\t/* People report that a mount called from init without console\n\t   writes error messages to /etc/mtab\n\t   Let us try to avoid getting fd's 0,1,2 */\n\twhile((fd = open(\"/dev/null\", O_RDWR)) == 0 || fd == 1 || fd == 2) ;\n\tif (fd > 2)\n\t\tclose(fd);\n\n\tfsprobe_init();\n\n#ifdef DO_PS_FIDDLING\n\tinitproctitle(argc, argv);\n#endif\n\n\twhile ((c = getopt_long (argc, argv, \"aBfFhilL:Mno:O:p:rRsU:vVwt:\",\n\t\t\t\t longopts, NULL)) != -1) {\n\t\tswitch (c) {\n\t\tcase 'a':\t       /* mount everything in fstab */\n\t\t\t++mount_all;\n\t\t\tbreak;\n\t\tcase 'B': /* bind */\n\t\t\tmounttype = MS_BIND;\n\t\t\tbreak;\n\t\tcase 'f':\t       /* fake: don't actually call mount(2) */\n\t\t\t++fake;\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\t++optfork;\n\t\t\tbreak;\n\t\tcase 'h':\t\t/* help */\n\t\t\tusage (stdout, 0);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\texternal_allowed = 0;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tlist_with_volumelabel = 1;\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tlabel = optarg;\n\t\t\tbreak;\n\t\tcase 'M': /* move */\n\t\t\tmounttype = MS_MOVE;\n\t\t\tbreak;\n\t\tcase 'n':\t\t/* do not write /etc/mtab */\n\t\t\t++nomtab;\n\t\t\tbreak;\n\t\tcase 'o':\t\t/* specify mount options */\n\t\t\toptions = append_opt(options, optarg, NULL);\n\t\t\tbreak;\n\t\tcase 'O':\t\t/* with -t: mount only if (not) opt */\n\t\t\ttest_opts = append_opt(test_opts, optarg, NULL);\n\t\t\tbreak;\n\t\tcase 'p':\t\t/* fd on which to read passwd */\n                        error(\"mount: %s\", _(\"--pass-fd is no longer supported\"));\n\t\t\tbreak;\n\t\tcase 'r':\t\t/* mount readonly */\n\t\t\treadonly = 1;\n\t\t\treadwrite = 0;\n\t\t\tbreak;\n\t\tcase 'R': /* rbind */\n\t\t\tmounttype = (MS_BIND | MS_REC);\n\t\t\tbreak;\n\t\tcase 's':\t\t/* allow sloppy mount options */\n\t\t\tsloppy = 1;\n\t\t\tbreak;\n\t\tcase 't':\t\t/* specify file system types */\n\t\t\ttypes = optarg;\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\tuuid = optarg;\n\t\t\tbreak;\n\t\tcase 'v':\t\t/* be chatty - more so if repeated */\n\t\t\t++verbose;\n\t\t\tbreak;\n\t\tcase 'V':\t\t/* version */\n\t\t\tprint_version(EXIT_SUCCESS);\n\t\t\tbreak;\n\t\tcase 'w':\t\t/* mount read/write */\n\t\t\treadwrite = 1;\n\t\t\treadonly = 0;\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tbreak;\n\n\t\tcase 134:\n\t\t\t/* undocumented, may go away again:\n\t\t\t   call: mount --guess-fstype device\n\t\t\t   use only for testing purposes -\n\t\t\t   the guessing is not reliable at all */\n\t\t    {\n\t\t\tconst char *fstype;\n\t\t\tfstype = fsprobe_get_fstype_by_devname(optarg);\n\t\t\tprintf(\"%s\\n\", fstype ? fstype : \"unknown\");\n\t\t\texit(fstype ? 0 : EX_FAIL);\n\t\t    }\n\n\t\tcase 136:\n\t\t\tmounttype = MS_SHARED;\n\t\t\tbreak;\n\n\t\tcase 137:\n\t\t\tmounttype = MS_SLAVE;\n\t\t\tbreak;\n\n\t\tcase 138:\n\t\t\tmounttype = MS_PRIVATE;\n\t\t\tbreak;\n\n\t\tcase 139:\n\t\t\tmounttype = MS_UNBINDABLE;\n\t\t\tbreak;\n\n\t\tcase 140:\n\t\t\tmounttype = (MS_SHARED | MS_REC);\n\t\t\tbreak;\n\n\t\tcase 141:\n\t\t\tmounttype = (MS_SLAVE | MS_REC);\n\t\t\tbreak;\n\n\t\tcase 142:\n\t\t\tmounttype = (MS_PRIVATE | MS_REC);\n\t\t\tbreak;\n\n\t\tcase 143:\n\t\t\tmounttype = (MS_UNBINDABLE | MS_REC);\n\t\t\tbreak;\n\t\tcase 144:\n\t\t\tnocanonicalize = 1;\n\t\t\tbreak;\n\t\tcase '?':\n\t\tdefault:\n\t\t\tusage (stderr, EX_USAGE);\n\t\t}\n\t}\n\n\tif (verbose > 2) {\n\t\tprintf(\"mount: fstab path: \\\"%s\\\"\\n\", _PATH_MNTTAB);\n\t\tprintf(\"mount: mtab path:  \\\"%s\\\"\\n\", _PATH_MOUNTED);\n\t\tprintf(\"mount: lock path:  \\\"%s\\\"\\n\", _PATH_MOUNTED_LOCK);\n\t\tprintf(\"mount: temp path:  \\\"%s\\\"\\n\", _PATH_MOUNTED_TMP);\n\t\tprintf(\"mount: UID:        %u\\n\", getuid());\n\t\tprintf(\"mount: eUID:       %u\\n\", geteuid());\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\tspecseen = (uuid || label) ? 1 : 0;\t/* yes, .. i know */\n\n\tif (argc+specseen == 0 && !mount_all) {\n\t\tif (options || mounttype)\n\t\t\tusage (stderr, EX_USAGE);\n\t\treturn print_all (types);\n\t}\n\n\t{\n\t\tconst uid_t ruid = getuid();\n\t\tconst uid_t euid = geteuid();\n\n\t\t/* if we're really root and aren't running setuid */\n\t\tif (((uid_t)0 == ruid) && (ruid == euid)) {\n\t\t\trestricted = 0;\n\t\t}\n\n\t\tif (restricted &&\n\t\t    (types || options || readwrite || nomtab || mount_all ||\n\t\t     nocanonicalize || fake || mounttype ||\n\t\t     (argc + specseen) != 1)) {\n\n\t\t\tif (ruid == 0 && euid != 0)\n\t\t\t\t/* user is root, but setuid to non-root */\n\t\t\t\tdie (EX_USAGE, _(\"mount: only root can do that \"\n\t\t\t\t\t\"(effective UID is %u)\"), euid);\n\n\t\t\tdie (EX_USAGE, _(\"mount: only root can do that\"));\n\t\t}\n\t}\n\n\tatexit(unlock_mtab);\n\n\tswitch (argc+specseen) {\n\tcase 0:\n\t\t/* mount -a */\n\t\tresult = do_mount_all (types, options, test_opts);\n\t\tif (result == 0 && verbose && !fake)\n\t\t\terror(_(\"nothing was mounted\"));\n\t\tbreak;\n\n\tcase 1:\n\t\t/* mount [-nfrvw] [-o options] special | node\n\t\t * mount -L label  (or -U uuid)\n\t\t * (/etc/fstab is necessary)\n\t\t */\n\t\tif (types != NULL)\n\t\t\tusage (stderr, EX_USAGE);\n\n\t\tif (uuid || label)\n\t\t\tmc = getfs(NULL, uuid, label);\n\t\telse\n\t\t\tmc = getfs(*argv, NULL, NULL);\n\n\t\tif (!mc) {\n\t\t\tif (uuid || label)\n\t\t\t\tdie (EX_USAGE, _(\"mount: no such partition found\"));\n\n\t\t\tdie (EX_USAGE,\n\t\t\t     _(\"mount: can't find %s in %s or %s\"),\n\t\t\t     *argv, _PATH_MNTTAB, _PATH_MOUNTED);\n\t\t}\n\n\t\tresult = mount_one (xstrdup (mc->m.mnt_fsname),\n\t\t\t\t    xstrdup (mc->m.mnt_dir),\n\t\t\t\t    xstrdup (mc->m.mnt_type),\n\t\t\t\t    mc->m.mnt_opts, options, 0, 0);\n\t\tbreak;\n\n\tcase 2:\n\t\t/* mount special node  (/etc/fstab is not necessary) */\n\t\tif (specseen) {\n\t\t\t/* mount -L label node   (or -U uuid) */\n\t\t\tspec = uuid ?\tfsprobe_get_devname_by_uuid(uuid) :\n\t\t\t\t\tfsprobe_get_devname_by_label(label);\n\t\t\tnode = argv[0];\n\t\t} else {\n\t\t\t/* mount special node */\n\t\t\tspec = argv[0];\n\t\t\tnode = argv[1];\n\t\t}\n\t\tif (!spec)\n\t\t\tdie (EX_USAGE, _(\"mount: no such partition found\"));\n\n\t\tresult = mount_one (spec, node, types, NULL, options, 0, 0);\n\t\tbreak;\n\n\tdefault:\n\t\tusage (stderr, EX_USAGE);\n\t}\n\n\tif (result == EX_SOMEOK)\n\t\tresult = 0;\n\n\tfsprobe_exit();\n\n\texit (result);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147414,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "main(int argc, char *argv[]) {\n\tint c, result = 0, specseen;\n\tchar *options = NULL, *test_opts = NULL, *node;\n\tconst char *spec = NULL;\n\tchar *label = NULL;\n\tchar *uuid = NULL;\n\tchar *types = NULL;\n\tchar *p;\n\tstruct mntentchn *mc;\n\tint fd;\n\n\tsanitize_env();\n\tsetlocale(LC_ALL, \"\");\n\tbindtextdomain(PACKAGE, LOCALEDIR);\n\ttextdomain(PACKAGE);\n\tatexit(close_stdout);\n\n\tprogname = argv[0];\n\tif ((p = strrchr(progname, '/')) != NULL)\n\t\tprogname = p+1;\n\n\tumask(022);\n\n\t/* People report that a mount called from init without console\n\t   writes error messages to /etc/mtab\n\t   Let us try to avoid getting fd's 0,1,2 */\n\twhile((fd = open(\"/dev/null\", O_RDWR)) == 0 || fd == 1 || fd == 2) ;\n\tif (fd > 2)\n\t\tclose(fd);\n\n\tfsprobe_init();\n\n#ifdef DO_PS_FIDDLING\n\tinitproctitle(argc, argv);\n#endif\n\n\twhile ((c = getopt_long (argc, argv, \"aBfFhilL:Mno:O:p:rRsU:vVwt:\",\n\t\t\t\t longopts, NULL)) != -1) {\n\t\tswitch (c) {\n\t\tcase 'a':\t       /* mount everything in fstab */\n\t\t\t++mount_all;\n\t\t\tbreak;\n\t\tcase 'B': /* bind */\n\t\t\tmounttype = MS_BIND;\n\t\t\tbreak;\n\t\tcase 'f':\t       /* fake: don't actually call mount(2) */\n\t\t\t++fake;\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\t++optfork;\n\t\t\tbreak;\n\t\tcase 'h':\t\t/* help */\n\t\t\tusage (stdout, 0);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\texternal_allowed = 0;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tlist_with_volumelabel = 1;\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tlabel = optarg;\n\t\t\tbreak;\n\t\tcase 'M': /* move */\n\t\t\tmounttype = MS_MOVE;\n\t\t\tbreak;\n\t\tcase 'n':\t\t/* do not write /etc/mtab */\n\t\t\t++nomtab;\n\t\t\tbreak;\n\t\tcase 'o':\t\t/* specify mount options */\n\t\t\toptions = append_opt(options, optarg, NULL);\n\t\t\tbreak;\n\t\tcase 'O':\t\t/* with -t: mount only if (not) opt */\n\t\t\ttest_opts = append_opt(test_opts, optarg, NULL);\n\t\t\tbreak;\n\t\tcase 'p':\t\t/* fd on which to read passwd */\n                        error(\"mount: %s\", _(\"--pass-fd is no longer supported\"));\n\t\t\tbreak;\n\t\tcase 'r':\t\t/* mount readonly */\n\t\t\treadonly = 1;\n\t\t\treadwrite = 0;\n\t\t\tbreak;\n\t\tcase 'R': /* rbind */\n\t\t\tmounttype = (MS_BIND | MS_REC);\n\t\t\tbreak;\n\t\tcase 's':\t\t/* allow sloppy mount options */\n\t\t\tsloppy = 1;\n\t\t\tbreak;\n\t\tcase 't':\t\t/* specify file system types */\n\t\t\ttypes = optarg;\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\tuuid = optarg;\n\t\t\tbreak;\n\t\tcase 'v':\t\t/* be chatty - more so if repeated */\n\t\t\t++verbose;\n\t\t\tbreak;\n\t\tcase 'V':\t\t/* version */\n\t\t\tprint_version(EXIT_SUCCESS);\n\t\t\tbreak;\n\t\tcase 'w':\t\t/* mount read/write */\n\t\t\treadwrite = 1;\n\t\t\treadonly = 0;\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tbreak;\n\n\t\tcase 136:\n\t\t\tmounttype = MS_SHARED;\n\t\t\tbreak;\n\n\t\tcase 137:\n\t\t\tmounttype = MS_SLAVE;\n\t\t\tbreak;\n\n\t\tcase 138:\n\t\t\tmounttype = MS_PRIVATE;\n\t\t\tbreak;\n\n\t\tcase 139:\n\t\t\tmounttype = MS_UNBINDABLE;\n\t\t\tbreak;\n\n\t\tcase 140:\n\t\t\tmounttype = (MS_SHARED | MS_REC);\n\t\t\tbreak;\n\n\t\tcase 141:\n\t\t\tmounttype = (MS_SLAVE | MS_REC);\n\t\t\tbreak;\n\n\t\tcase 142:\n\t\t\tmounttype = (MS_PRIVATE | MS_REC);\n\t\t\tbreak;\n\n\t\tcase 143:\n\t\t\tmounttype = (MS_UNBINDABLE | MS_REC);\n\t\t\tbreak;\n\t\tcase 144:\n\t\t\tnocanonicalize = 1;\n\t\t\tbreak;\n\t\tcase '?':\n\t\tdefault:\n\t\t\tusage (stderr, EX_USAGE);\n\t\t}\n\t}\n\n\tif (verbose > 2) {\n\t\tprintf(\"mount: fstab path: \\\"%s\\\"\\n\", _PATH_MNTTAB);\n\t\tprintf(\"mount: mtab path:  \\\"%s\\\"\\n\", _PATH_MOUNTED);\n\t\tprintf(\"mount: lock path:  \\\"%s\\\"\\n\", _PATH_MOUNTED_LOCK);\n\t\tprintf(\"mount: temp path:  \\\"%s\\\"\\n\", _PATH_MOUNTED_TMP);\n\t\tprintf(\"mount: UID:        %u\\n\", getuid());\n\t\tprintf(\"mount: eUID:       %u\\n\", geteuid());\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\tspecseen = (uuid || label) ? 1 : 0;\t/* yes, .. i know */\n\n\tif (argc+specseen == 0 && !mount_all) {\n\t\tif (options || mounttype)\n\t\t\tusage (stderr, EX_USAGE);\n\t\treturn print_all (types);\n\t}\n\n\t{\n\t\tconst uid_t ruid = getuid();\n\t\tconst uid_t euid = geteuid();\n\n\t\t/* if we're really root and aren't running setuid */\n\t\tif (((uid_t)0 == ruid) && (ruid == euid)) {\n\t\t\trestricted = 0;\n\t\t}\n\n\t\tif (restricted &&\n\t\t    (types || options || readwrite || nomtab || mount_all ||\n\t\t     nocanonicalize || fake || mounttype ||\n\t\t     (argc + specseen) != 1)) {\n\n\t\t\tif (ruid == 0 && euid != 0)\n\t\t\t\t/* user is root, but setuid to non-root */\n\t\t\t\tdie (EX_USAGE, _(\"mount: only root can do that \"\n\t\t\t\t\t\"(effective UID is %u)\"), euid);\n\n\t\t\tdie (EX_USAGE, _(\"mount: only root can do that\"));\n\t\t}\n\t}\n\n\tatexit(unlock_mtab);\n\n\tswitch (argc+specseen) {\n\tcase 0:\n\t\t/* mount -a */\n\t\tresult = do_mount_all (types, options, test_opts);\n\t\tif (result == 0 && verbose && !fake)\n\t\t\terror(_(\"nothing was mounted\"));\n\t\tbreak;\n\n\tcase 1:\n\t\t/* mount [-nfrvw] [-o options] special | node\n\t\t * mount -L label  (or -U uuid)\n\t\t * (/etc/fstab is necessary)\n\t\t */\n\t\tif (types != NULL)\n\t\t\tusage (stderr, EX_USAGE);\n\n\t\tif (uuid || label)\n\t\t\tmc = getfs(NULL, uuid, label);\n\t\telse\n\t\t\tmc = getfs(*argv, NULL, NULL);\n\n\t\tif (!mc) {\n\t\t\tif (uuid || label)\n\t\t\t\tdie (EX_USAGE, _(\"mount: no such partition found\"));\n\n\t\t\tdie (EX_USAGE,\n\t\t\t     _(\"mount: can't find %s in %s or %s\"),\n\t\t\t     *argv, _PATH_MNTTAB, _PATH_MOUNTED);\n\t\t}\n\n\t\tresult = mount_one (xstrdup (mc->m.mnt_fsname),\n\t\t\t\t    xstrdup (mc->m.mnt_dir),\n\t\t\t\t    xstrdup (mc->m.mnt_type),\n\t\t\t\t    mc->m.mnt_opts, options, 0, 0);\n\t\tbreak;\n\n\tcase 2:\n\t\t/* mount special node  (/etc/fstab is not necessary) */\n\t\tif (specseen) {\n\t\t\t/* mount -L label node   (or -U uuid) */\n\t\t\tspec = uuid ?\tfsprobe_get_devname_by_uuid(uuid) :\n\t\t\t\t\tfsprobe_get_devname_by_label(label);\n\t\t\tnode = argv[0];\n\t\t} else {\n\t\t\t/* mount special node */\n\t\t\tspec = argv[0];\n\t\t\tnode = argv[1];\n\t\t}\n\t\tif (!spec)\n\t\t\tdie (EX_USAGE, _(\"mount: no such partition found\"));\n\n\t\tresult = mount_one (spec, node, types, NULL, options, 0, 0);\n\t\tbreak;\n\n\tdefault:\n\t\tusage (stderr, EX_USAGE);\n\t}\n\n\tif (result == EX_SOMEOK)\n\t\tresult = 0;\n\n\tfsprobe_exit();\n\n\texit (result);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147415,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int shmem_getpage(struct inode *inode, unsigned long idx,\n\t\t\tstruct page **pagep, enum sgp_type sgp, int *type)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct shmem_inode_info *info = SHMEM_I(inode);\n\tstruct shmem_sb_info *sbinfo;\n\tstruct page *filepage = *pagep;\n\tstruct page *swappage;\n\tswp_entry_t *entry;\n\tswp_entry_t swap;\n\tint error;\n\n\tif (idx >= SHMEM_MAX_INDEX)\n\t\treturn -EFBIG;\n\n\tif (type)\n\t\t*type = 0;\n\n\t/*\n\t * Normally, filepage is NULL on entry, and either found\n\t * uptodate immediately, or allocated and zeroed, or read\n\t * in under swappage, which is then assigned to filepage.\n\t * But shmem_readpage and shmem_write_begin pass in a locked\n\t * filepage, which may be found not uptodate by other callers\n\t * too, and may need to be copied from the swappage read in.\n\t */\nrepeat:\n\tif (!filepage)\n\t\tfilepage = find_lock_page(mapping, idx);\n\tif (filepage && PageUptodate(filepage))\n\t\tgoto done;\n\terror = 0;\n\tif (sgp == SGP_QUICK)\n\t\tgoto failed;\n\n\tspin_lock(&info->lock);\n\tshmem_recalc_inode(inode);\n\tentry = shmem_swp_alloc(info, idx, sgp);\n\tif (IS_ERR(entry)) {\n\t\tspin_unlock(&info->lock);\n\t\terror = PTR_ERR(entry);\n\t\tgoto failed;\n\t}\n\tswap = *entry;\n\n\tif (swap.val) {\n\t\t/* Look it up and read it in.. */\n\t\tswappage = lookup_swap_cache(swap);\n\t\tif (!swappage) {\n\t\t\tshmem_swp_unmap(entry);\n\t\t\t/* here we actually do the io */\n\t\t\tif (type && !(*type & VM_FAULT_MAJOR)) {\n\t\t\t\t__count_vm_event(PGMAJFAULT);\n\t\t\t\t*type |= VM_FAULT_MAJOR;\n\t\t\t}\n\t\t\tspin_unlock(&info->lock);\n\t\t\tswappage = shmem_swapin(info, swap, idx);\n\t\t\tif (!swappage) {\n\t\t\t\tspin_lock(&info->lock);\n\t\t\t\tentry = shmem_swp_alloc(info, idx, sgp);\n\t\t\t\tif (IS_ERR(entry))\n\t\t\t\t\terror = PTR_ERR(entry);\n\t\t\t\telse {\n\t\t\t\t\tif (entry->val == swap.val)\n\t\t\t\t\t\terror = -ENOMEM;\n\t\t\t\t\tshmem_swp_unmap(entry);\n\t\t\t\t}\n\t\t\t\tspin_unlock(&info->lock);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto failed;\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t\twait_on_page_locked(swappage);\n\t\t\tpage_cache_release(swappage);\n\t\t\tgoto repeat;\n\t\t}\n\n\t\t/* We have to do this with page locked to prevent races */\n\t\tif (TestSetPageLocked(swappage)) {\n\t\t\tshmem_swp_unmap(entry);\n\t\t\tspin_unlock(&info->lock);\n\t\t\twait_on_page_locked(swappage);\n\t\t\tpage_cache_release(swappage);\n\t\t\tgoto repeat;\n\t\t}\n\t\tif (PageWriteback(swappage)) {\n\t\t\tshmem_swp_unmap(entry);\n\t\t\tspin_unlock(&info->lock);\n\t\t\twait_on_page_writeback(swappage);\n\t\t\tunlock_page(swappage);\n\t\t\tpage_cache_release(swappage);\n\t\t\tgoto repeat;\n\t\t}\n\t\tif (!PageUptodate(swappage)) {\n\t\t\tshmem_swp_unmap(entry);\n\t\t\tspin_unlock(&info->lock);\n\t\t\tunlock_page(swappage);\n\t\t\tpage_cache_release(swappage);\n\t\t\terror = -EIO;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tif (filepage) {\n\t\t\tshmem_swp_set(info, entry, 0);\n\t\t\tshmem_swp_unmap(entry);\n\t\t\tdelete_from_swap_cache(swappage);\n\t\t\tspin_unlock(&info->lock);\n\t\t\tcopy_highpage(filepage, swappage);\n\t\t\tunlock_page(swappage);\n\t\t\tpage_cache_release(swappage);\n\t\t\tflush_dcache_page(filepage);\n\t\t\tSetPageUptodate(filepage);\n\t\t\tset_page_dirty(filepage);\n\t\t\tswap_free(swap);\n\t\t} else if (!(error = move_from_swap_cache(\n\t\t\t\tswappage, idx, mapping))) {\n\t\t\tinfo->flags |= SHMEM_PAGEIN;\n\t\t\tshmem_swp_set(info, entry, 0);\n\t\t\tshmem_swp_unmap(entry);\n\t\t\tspin_unlock(&info->lock);\n\t\t\tfilepage = swappage;\n\t\t\tswap_free(swap);\n\t\t} else {\n\t\t\tshmem_swp_unmap(entry);\n\t\t\tspin_unlock(&info->lock);\n\t\t\tunlock_page(swappage);\n\t\t\tpage_cache_release(swappage);\n\t\t\tif (error == -ENOMEM) {\n\t\t\t\t/* let kswapd refresh zone for GFP_ATOMICs */\n\t\t\t\tcongestion_wait(WRITE, HZ/50);\n\t\t\t}\n\t\t\tgoto repeat;\n\t\t}\n\t} else if (sgp == SGP_READ && !filepage) {\n\t\tshmem_swp_unmap(entry);\n\t\tfilepage = find_get_page(mapping, idx);\n\t\tif (filepage &&\n\t\t    (!PageUptodate(filepage) || TestSetPageLocked(filepage))) {\n\t\t\tspin_unlock(&info->lock);\n\t\t\twait_on_page_locked(filepage);\n\t\t\tpage_cache_release(filepage);\n\t\t\tfilepage = NULL;\n\t\t\tgoto repeat;\n\t\t}\n\t\tspin_unlock(&info->lock);\n\t} else {\n\t\tshmem_swp_unmap(entry);\n\t\tsbinfo = SHMEM_SB(inode->i_sb);\n\t\tif (sbinfo->max_blocks) {\n\t\t\tspin_lock(&sbinfo->stat_lock);\n\t\t\tif (sbinfo->free_blocks == 0 ||\n\t\t\t    shmem_acct_block(info->flags)) {\n\t\t\t\tspin_unlock(&sbinfo->stat_lock);\n\t\t\t\tspin_unlock(&info->lock);\n\t\t\t\terror = -ENOSPC;\n\t\t\t\tgoto failed;\n\t\t\t}\n\t\t\tsbinfo->free_blocks--;\n\t\t\tinode->i_blocks += BLOCKS_PER_PAGE;\n\t\t\tspin_unlock(&sbinfo->stat_lock);\n\t\t} else if (shmem_acct_block(info->flags)) {\n\t\t\tspin_unlock(&info->lock);\n\t\t\terror = -ENOSPC;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tif (!filepage) {\n\t\t\tspin_unlock(&info->lock);\n\t\t\tfilepage = shmem_alloc_page(mapping_gfp_mask(mapping),\n\t\t\t\t\t\t    info,\n\t\t\t\t\t\t    idx);\n\t\t\tif (!filepage) {\n\t\t\t\tshmem_unacct_blocks(info->flags, 1);\n\t\t\t\tshmem_free_blocks(inode, 1);\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto failed;\n\t\t\t}\n\n\t\t\tspin_lock(&info->lock);\n\t\t\tentry = shmem_swp_alloc(info, idx, sgp);\n\t\t\tif (IS_ERR(entry))\n\t\t\t\terror = PTR_ERR(entry);\n\t\t\telse {\n\t\t\t\tswap = *entry;\n\t\t\t\tshmem_swp_unmap(entry);\n\t\t\t}\n\t\t\tif (error || swap.val || 0 != add_to_page_cache_lru(\n\t\t\t\t\tfilepage, mapping, idx, GFP_ATOMIC)) {\n\t\t\t\tspin_unlock(&info->lock);\n\t\t\t\tpage_cache_release(filepage);\n\t\t\t\tshmem_unacct_blocks(info->flags, 1);\n\t\t\t\tshmem_free_blocks(inode, 1);\n\t\t\t\tfilepage = NULL;\n\t\t\t\tif (error)\n\t\t\t\t\tgoto failed;\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t\tinfo->flags |= SHMEM_PAGEIN;\n\t\t}\n\n\t\tinfo->alloced++;\n\t\tspin_unlock(&info->lock);\n\t\tflush_dcache_page(filepage);\n\t\tSetPageUptodate(filepage);\n\t}\ndone:\n\tif (*pagep != filepage) {\n\t\t*pagep = filepage;\n\t\tif (sgp != SGP_FAULT)\n\t\t\tunlock_page(filepage);\n\n\t}\n\treturn 0;\n\nfailed:\n\tif (*pagep != filepage) {\n\t\tunlock_page(filepage);\n\t\tpage_cache_release(filepage);\n\t}\n\treturn error;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147508,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int shmem_getpage(struct inode *inode, unsigned long idx,\n\t\t\tstruct page **pagep, enum sgp_type sgp, int *type)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct shmem_inode_info *info = SHMEM_I(inode);\n\tstruct shmem_sb_info *sbinfo;\n\tstruct page *filepage = *pagep;\n\tstruct page *swappage;\n\tswp_entry_t *entry;\n\tswp_entry_t swap;\n\tint error;\n\n\tif (idx >= SHMEM_MAX_INDEX)\n\t\treturn -EFBIG;\n\n\tif (type)\n\t\t*type = 0;\n\n\t/*\n\t * Normally, filepage is NULL on entry, and either found\n\t * uptodate immediately, or allocated and zeroed, or read\n\t * in under swappage, which is then assigned to filepage.\n\t * But shmem_readpage and shmem_write_begin pass in a locked\n\t * filepage, which may be found not uptodate by other callers\n\t * too, and may need to be copied from the swappage read in.\n\t */\nrepeat:\n\tif (!filepage)\n\t\tfilepage = find_lock_page(mapping, idx);\n\tif (filepage && PageUptodate(filepage))\n\t\tgoto done;\n\terror = 0;\n\tif (sgp == SGP_QUICK)\n\t\tgoto failed;\n\n\tspin_lock(&info->lock);\n\tshmem_recalc_inode(inode);\n\tentry = shmem_swp_alloc(info, idx, sgp);\n\tif (IS_ERR(entry)) {\n\t\tspin_unlock(&info->lock);\n\t\terror = PTR_ERR(entry);\n\t\tgoto failed;\n\t}\n\tswap = *entry;\n\n\tif (swap.val) {\n\t\t/* Look it up and read it in.. */\n\t\tswappage = lookup_swap_cache(swap);\n\t\tif (!swappage) {\n\t\t\tshmem_swp_unmap(entry);\n\t\t\t/* here we actually do the io */\n\t\t\tif (type && !(*type & VM_FAULT_MAJOR)) {\n\t\t\t\t__count_vm_event(PGMAJFAULT);\n\t\t\t\t*type |= VM_FAULT_MAJOR;\n\t\t\t}\n\t\t\tspin_unlock(&info->lock);\n\t\t\tswappage = shmem_swapin(info, swap, idx);\n\t\t\tif (!swappage) {\n\t\t\t\tspin_lock(&info->lock);\n\t\t\t\tentry = shmem_swp_alloc(info, idx, sgp);\n\t\t\t\tif (IS_ERR(entry))\n\t\t\t\t\terror = PTR_ERR(entry);\n\t\t\t\telse {\n\t\t\t\t\tif (entry->val == swap.val)\n\t\t\t\t\t\terror = -ENOMEM;\n\t\t\t\t\tshmem_swp_unmap(entry);\n\t\t\t\t}\n\t\t\t\tspin_unlock(&info->lock);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto failed;\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t\twait_on_page_locked(swappage);\n\t\t\tpage_cache_release(swappage);\n\t\t\tgoto repeat;\n\t\t}\n\n\t\t/* We have to do this with page locked to prevent races */\n\t\tif (TestSetPageLocked(swappage)) {\n\t\t\tshmem_swp_unmap(entry);\n\t\t\tspin_unlock(&info->lock);\n\t\t\twait_on_page_locked(swappage);\n\t\t\tpage_cache_release(swappage);\n\t\t\tgoto repeat;\n\t\t}\n\t\tif (PageWriteback(swappage)) {\n\t\t\tshmem_swp_unmap(entry);\n\t\t\tspin_unlock(&info->lock);\n\t\t\twait_on_page_writeback(swappage);\n\t\t\tunlock_page(swappage);\n\t\t\tpage_cache_release(swappage);\n\t\t\tgoto repeat;\n\t\t}\n\t\tif (!PageUptodate(swappage)) {\n\t\t\tshmem_swp_unmap(entry);\n\t\t\tspin_unlock(&info->lock);\n\t\t\tunlock_page(swappage);\n\t\t\tpage_cache_release(swappage);\n\t\t\terror = -EIO;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tif (filepage) {\n\t\t\tshmem_swp_set(info, entry, 0);\n\t\t\tshmem_swp_unmap(entry);\n\t\t\tdelete_from_swap_cache(swappage);\n\t\t\tspin_unlock(&info->lock);\n\t\t\tcopy_highpage(filepage, swappage);\n\t\t\tunlock_page(swappage);\n\t\t\tpage_cache_release(swappage);\n\t\t\tflush_dcache_page(filepage);\n\t\t\tSetPageUptodate(filepage);\n\t\t\tset_page_dirty(filepage);\n\t\t\tswap_free(swap);\n\t\t} else if (!(error = move_from_swap_cache(\n\t\t\t\tswappage, idx, mapping))) {\n\t\t\tinfo->flags |= SHMEM_PAGEIN;\n\t\t\tshmem_swp_set(info, entry, 0);\n\t\t\tshmem_swp_unmap(entry);\n\t\t\tspin_unlock(&info->lock);\n\t\t\tfilepage = swappage;\n\t\t\tswap_free(swap);\n\t\t} else {\n\t\t\tshmem_swp_unmap(entry);\n\t\t\tspin_unlock(&info->lock);\n\t\t\tunlock_page(swappage);\n\t\t\tpage_cache_release(swappage);\n\t\t\tif (error == -ENOMEM) {\n\t\t\t\t/* let kswapd refresh zone for GFP_ATOMICs */\n\t\t\t\tcongestion_wait(WRITE, HZ/50);\n\t\t\t}\n\t\t\tgoto repeat;\n\t\t}\n\t} else if (sgp == SGP_READ && !filepage) {\n\t\tshmem_swp_unmap(entry);\n\t\tfilepage = find_get_page(mapping, idx);\n\t\tif (filepage &&\n\t\t    (!PageUptodate(filepage) || TestSetPageLocked(filepage))) {\n\t\t\tspin_unlock(&info->lock);\n\t\t\twait_on_page_locked(filepage);\n\t\t\tpage_cache_release(filepage);\n\t\t\tfilepage = NULL;\n\t\t\tgoto repeat;\n\t\t}\n\t\tspin_unlock(&info->lock);\n\t} else {\n\t\tshmem_swp_unmap(entry);\n\t\tsbinfo = SHMEM_SB(inode->i_sb);\n\t\tif (sbinfo->max_blocks) {\n\t\t\tspin_lock(&sbinfo->stat_lock);\n\t\t\tif (sbinfo->free_blocks == 0 ||\n\t\t\t    shmem_acct_block(info->flags)) {\n\t\t\t\tspin_unlock(&sbinfo->stat_lock);\n\t\t\t\tspin_unlock(&info->lock);\n\t\t\t\terror = -ENOSPC;\n\t\t\t\tgoto failed;\n\t\t\t}\n\t\t\tsbinfo->free_blocks--;\n\t\t\tinode->i_blocks += BLOCKS_PER_PAGE;\n\t\t\tspin_unlock(&sbinfo->stat_lock);\n\t\t} else if (shmem_acct_block(info->flags)) {\n\t\t\tspin_unlock(&info->lock);\n\t\t\terror = -ENOSPC;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tif (!filepage) {\n\t\t\tspin_unlock(&info->lock);\n\t\t\tfilepage = shmem_alloc_page(mapping_gfp_mask(mapping),\n\t\t\t\t\t\t    info,\n\t\t\t\t\t\t    idx);\n\t\t\tif (!filepage) {\n\t\t\t\tshmem_unacct_blocks(info->flags, 1);\n\t\t\t\tshmem_free_blocks(inode, 1);\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto failed;\n\t\t\t}\n\n\t\t\tspin_lock(&info->lock);\n\t\t\tentry = shmem_swp_alloc(info, idx, sgp);\n\t\t\tif (IS_ERR(entry))\n\t\t\t\terror = PTR_ERR(entry);\n\t\t\telse {\n\t\t\t\tswap = *entry;\n\t\t\t\tshmem_swp_unmap(entry);\n\t\t\t}\n\t\t\tif (error || swap.val || 0 != add_to_page_cache_lru(\n\t\t\t\t\tfilepage, mapping, idx, GFP_ATOMIC)) {\n\t\t\t\tspin_unlock(&info->lock);\n\t\t\t\tpage_cache_release(filepage);\n\t\t\t\tshmem_unacct_blocks(info->flags, 1);\n\t\t\t\tshmem_free_blocks(inode, 1);\n\t\t\t\tfilepage = NULL;\n\t\t\t\tif (error)\n\t\t\t\t\tgoto failed;\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t\tinfo->flags |= SHMEM_PAGEIN;\n\t\t}\n\n\t\tinfo->alloced++;\n\t\tspin_unlock(&info->lock);\n\t\tclear_highpage(filepage);\n\t\tflush_dcache_page(filepage);\n\t\tSetPageUptodate(filepage);\n\t}\ndone:\n\tif (*pagep != filepage) {\n\t\t*pagep = filepage;\n\t\tif (sgp != SGP_FAULT)\n\t\t\tunlock_page(filepage);\n\n\t}\n\treturn 0;\n\nfailed:\n\tif (*pagep != filepage) {\n\t\tunlock_page(filepage);\n\t\tpage_cache_release(filepage);\n\t}\n\treturn error;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147509,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "snd_seq_oss_synth_make_info(struct seq_oss_devinfo *dp, int dev, struct synth_info *inf)\n{\n\tstruct seq_oss_synth *rec;\n\n\tif (dp->synths[dev].is_midi) {\n\t\tstruct midi_info minf;\n\t\tsnd_seq_oss_midi_make_info(dp, dp->synths[dev].midi_mapped, &minf);\n\t\tinf->synth_type = SYNTH_TYPE_MIDI;\n\t\tinf->synth_subtype = 0;\n\t\tinf->nr_voices = 16;\n\t\tinf->device = dev;\n\t\tstrlcpy(inf->name, minf.name, sizeof(inf->name));\n\t} else {\n\t\tif ((rec = get_synthdev(dp, dev)) == NULL)\n\t\t\treturn -ENXIO;\n\t\tinf->synth_type = rec->synth_type;\n\t\tinf->synth_subtype = rec->synth_subtype;\n\t\tinf->nr_voices = rec->nr_voices;\n\t\tinf->device = dev;\n\t\tstrlcpy(inf->name, rec->name, sizeof(inf->name));\n\t\tsnd_use_lock_free(&rec->use_lock);\n\t}\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147526,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "snd_seq_oss_synth_make_info(struct seq_oss_devinfo *dp, int dev, struct synth_info *inf)\n{\n\tstruct seq_oss_synth *rec;\n\n\tif (dev < 0 || dev >= dp->max_synthdev)\n\t\treturn -ENXIO;\n\n\tif (dp->synths[dev].is_midi) {\n\t\tstruct midi_info minf;\n\t\tsnd_seq_oss_midi_make_info(dp, dp->synths[dev].midi_mapped, &minf);\n\t\tinf->synth_type = SYNTH_TYPE_MIDI;\n\t\tinf->synth_subtype = 0;\n\t\tinf->nr_voices = 16;\n\t\tinf->device = dev;\n\t\tstrlcpy(inf->name, minf.name, sizeof(inf->name));\n\t} else {\n\t\tif ((rec = get_synthdev(dp, dev)) == NULL)\n\t\t\treturn -ENXIO;\n\t\tinf->synth_type = rec->synth_type;\n\t\tinf->synth_subtype = rec->synth_subtype;\n\t\tinf->nr_voices = rec->nr_voices;\n\t\tinf->device = dev;\n\t\tstrlcpy(inf->name, rec->name, sizeof(inf->name));\n\t\tsnd_use_lock_free(&rec->use_lock);\n\t}\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147527,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "int sctp_auth_ep_set_hmacs(struct sctp_endpoint *ep,\n\t\t\t   struct sctp_hmacalgo *hmacs)\n{\n\tint has_sha1 = 0;\n\t__u16 id;\n\tint i;\n\n\t/* Scan the list looking for unsupported id.  Also make sure that\n\t * SHA1 is specified.\n\t */\n\tfor (i = 0; i < hmacs->shmac_num_idents; i++) {\n\t\tid = hmacs->shmac_idents[i];\n\n\t\tif (SCTP_AUTH_HMAC_ID_SHA1 == id)\n\t\t\thas_sha1 = 1;\n\n\t\tif (!sctp_hmac_list[id].hmac_name)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!has_sha1)\n\t\treturn -EINVAL;\n\n\tmemcpy(ep->auth_hmacs_list->hmac_ids, &hmacs->shmac_idents[0],\n\t\thmacs->shmac_num_idents * sizeof(__u16));\n\tep->auth_hmacs_list->param_hdr.length = htons(sizeof(sctp_paramhdr_t) +\n\t\t\t\thmacs->shmac_num_idents * sizeof(__u16));\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147528,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "int sctp_auth_ep_set_hmacs(struct sctp_endpoint *ep,\n\t\t\t   struct sctp_hmacalgo *hmacs)\n{\n\tint has_sha1 = 0;\n\t__u16 id;\n\tint i;\n\n\t/* Scan the list looking for unsupported id.  Also make sure that\n\t * SHA1 is specified.\n\t */\n\tfor (i = 0; i < hmacs->shmac_num_idents; i++) {\n\t\tid = hmacs->shmac_idents[i];\n\n\t\tif (id > SCTP_AUTH_HMAC_ID_MAX)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (SCTP_AUTH_HMAC_ID_SHA1 == id)\n\t\t\thas_sha1 = 1;\n\n\t\tif (!sctp_hmac_list[id].hmac_name)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!has_sha1)\n\t\treturn -EINVAL;\n\n\tmemcpy(ep->auth_hmacs_list->hmac_ids, &hmacs->shmac_idents[0],\n\t\thmacs->shmac_num_idents * sizeof(__u16));\n\tep->auth_hmacs_list->param_hdr.length = htons(sizeof(sctp_paramhdr_t) +\n\t\t\t\thmacs->shmac_num_idents * sizeof(__u16));\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147529,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int rose_getname(struct socket *sock, struct sockaddr *uaddr,\n\tint *uaddr_len, int peer)\n{\n\tstruct full_sockaddr_rose *srose = (struct full_sockaddr_rose *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct rose_sock *rose = rose_sk(sk);\n\tint n;\n\n\tif (peer != 0) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -ENOTCONN;\n\t\tsrose->srose_family = AF_ROSE;\n\t\tsrose->srose_addr   = rose->dest_addr;\n\t\tsrose->srose_call   = rose->dest_call;\n\t\tsrose->srose_ndigis = rose->dest_ndigis;\n\t\tfor (n = 0; n < rose->dest_ndigis; n++)\n\t\t\tsrose->srose_digis[n] = rose->dest_digis[n];\n\t} else {\n\t\tsrose->srose_family = AF_ROSE;\n\t\tsrose->srose_addr   = rose->source_addr;\n\t\tsrose->srose_call   = rose->source_call;\n\t\tsrose->srose_ndigis = rose->source_ndigis;\n\t\tfor (n = 0; n < rose->source_ndigis; n++)\n\t\t\tsrose->srose_digis[n] = rose->source_digis[n];\n\t}\n\n\t*uaddr_len = sizeof(struct full_sockaddr_rose);\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147552,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int rose_getname(struct socket *sock, struct sockaddr *uaddr,\n\tint *uaddr_len, int peer)\n{\n\tstruct full_sockaddr_rose *srose = (struct full_sockaddr_rose *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct rose_sock *rose = rose_sk(sk);\n\tint n;\n\n\tmemset(srose, 0, sizeof(*srose));\n\tif (peer != 0) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -ENOTCONN;\n\t\tsrose->srose_family = AF_ROSE;\n\t\tsrose->srose_addr   = rose->dest_addr;\n\t\tsrose->srose_call   = rose->dest_call;\n\t\tsrose->srose_ndigis = rose->dest_ndigis;\n\t\tfor (n = 0; n < rose->dest_ndigis; n++)\n\t\t\tsrose->srose_digis[n] = rose->dest_digis[n];\n\t} else {\n\t\tsrose->srose_family = AF_ROSE;\n\t\tsrose->srose_addr   = rose->source_addr;\n\t\tsrose->srose_call   = rose->source_call;\n\t\tsrose->srose_ndigis = rose->source_ndigis;\n\t\tfor (n = 0; n < rose->source_ndigis; n++)\n\t\t\tsrose->srose_digis[n] = rose->source_digis[n];\n\t}\n\n\t*uaddr_len = sizeof(struct full_sockaddr_rose);\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147553,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int atalk_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t int *uaddr_len, int peer)\n{\n\tstruct sockaddr_at sat;\n\tstruct sock *sk = sock->sk;\n\tstruct atalk_sock *at = at_sk(sk);\n\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\tif (atalk_autobind(sk) < 0)\n\t\t\treturn -ENOBUFS;\n\n\t*uaddr_len = sizeof(struct sockaddr_at);\n\n\tif (peer) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -ENOTCONN;\n\n\t\tsat.sat_addr.s_net  = at->dest_net;\n\t\tsat.sat_addr.s_node = at->dest_node;\n\t\tsat.sat_port\t    = at->dest_port;\n\t} else {\n\t\tsat.sat_addr.s_net  = at->src_net;\n\t\tsat.sat_addr.s_node = at->src_node;\n\t\tsat.sat_port\t    = at->src_port;\n\t}\n\n\tsat.sat_family = AF_APPLETALK;\n\tmemcpy(uaddr, &sat, sizeof(sat));\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147554,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int atalk_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t int *uaddr_len, int peer)\n{\n\tstruct sockaddr_at sat;\n\tstruct sock *sk = sock->sk;\n\tstruct atalk_sock *at = at_sk(sk);\n\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\tif (atalk_autobind(sk) < 0)\n\t\t\treturn -ENOBUFS;\n\n\t*uaddr_len = sizeof(struct sockaddr_at);\n\tmemset(&sat.sat_zero, 0, sizeof(sat.sat_zero));\n\n\tif (peer) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -ENOTCONN;\n\n\t\tsat.sat_addr.s_net  = at->dest_net;\n\t\tsat.sat_addr.s_node = at->dest_node;\n\t\tsat.sat_port\t    = at->dest_port;\n\t} else {\n\t\tsat.sat_addr.s_net  = at->src_net;\n\t\tsat.sat_addr.s_node = at->src_node;\n\t\tsat.sat_port\t    = at->src_port;\n\t}\n\n\tsat.sat_family = AF_APPLETALK;\n\tmemcpy(uaddr, &sat, sizeof(sat));\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147555,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int econet_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t  int *uaddr_len, int peer)\n{\n\tstruct sock *sk;\n\tstruct econet_sock *eo;\n\tstruct sockaddr_ec *sec = (struct sockaddr_ec *)uaddr;\n\n\tif (peer)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&econet_mutex);\n\n\tsk = sock->sk;\n\teo = ec_sk(sk);\n\n\tsec->sec_family\t  = AF_ECONET;\n\tsec->port\t  = eo->port;\n\tsec->addr.station = eo->station;\n\tsec->addr.net\t  = eo->net;\n\n\tmutex_unlock(&econet_mutex);\n\n\t*uaddr_len = sizeof(*sec);\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147556,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int econet_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t  int *uaddr_len, int peer)\n{\n\tstruct sock *sk;\n\tstruct econet_sock *eo;\n\tstruct sockaddr_ec *sec = (struct sockaddr_ec *)uaddr;\n\n\tif (peer)\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(sec, 0, sizeof(*sec));\n\tmutex_lock(&econet_mutex);\n\n\tsk = sock->sk;\n\teo = ec_sk(sk);\n\n\tsec->sec_family\t  = AF_ECONET;\n\tsec->port\t  = eo->port;\n\tsec->addr.station = eo->station;\n\tsec->addr.net\t  = eo->net;\n\n\tmutex_unlock(&econet_mutex);\n\n\t*uaddr_len = sizeof(*sec);\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147557,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int raw_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t       int *len, int peer)\n{\n\tstruct sockaddr_can *addr = (struct sockaddr_can *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct raw_sock *ro = raw_sk(sk);\n\n\tif (peer)\n\t\treturn -EOPNOTSUPP;\n\n\taddr->can_family  = AF_CAN;\n\taddr->can_ifindex = ro->ifindex;\n\n\t*len = sizeof(*addr);\n\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147558,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int raw_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t       int *len, int peer)\n{\n\tstruct sockaddr_can *addr = (struct sockaddr_can *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct raw_sock *ro = raw_sk(sk);\n\n\tif (peer)\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(addr, 0, sizeof(*addr));\n\taddr->can_family  = AF_CAN;\n\taddr->can_ifindex = ro->ifindex;\n\n\t*len = sizeof(*addr);\n\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147559,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int nr_getname(struct socket *sock, struct sockaddr *uaddr,\n\tint *uaddr_len, int peer)\n{\n\tstruct full_sockaddr_ax25 *sax = (struct full_sockaddr_ax25 *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct nr_sock *nr = nr_sk(sk);\n\n\tlock_sock(sk);\n\tif (peer != 0) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\t\trelease_sock(sk);\n\t\t\treturn -ENOTCONN;\n\t\t}\n\t\tsax->fsa_ax25.sax25_family = AF_NETROM;\n\t\tsax->fsa_ax25.sax25_ndigis = 1;\n\t\tsax->fsa_ax25.sax25_call   = nr->user_addr;\n\t\tsax->fsa_digipeater[0]     = nr->dest_addr;\n\t\t*uaddr_len = sizeof(struct full_sockaddr_ax25);\n\t} else {\n\t\tsax->fsa_ax25.sax25_family = AF_NETROM;\n\t\tsax->fsa_ax25.sax25_ndigis = 0;\n\t\tsax->fsa_ax25.sax25_call   = nr->source_addr;\n\t\t*uaddr_len = sizeof(struct sockaddr_ax25);\n\t}\n\trelease_sock(sk);\n\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147560,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int nr_getname(struct socket *sock, struct sockaddr *uaddr,\n\tint *uaddr_len, int peer)\n{\n\tstruct full_sockaddr_ax25 *sax = (struct full_sockaddr_ax25 *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct nr_sock *nr = nr_sk(sk);\n\n\tlock_sock(sk);\n\tif (peer != 0) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\t\trelease_sock(sk);\n\t\t\treturn -ENOTCONN;\n\t\t}\n\t\tsax->fsa_ax25.sax25_family = AF_NETROM;\n\t\tsax->fsa_ax25.sax25_ndigis = 1;\n\t\tsax->fsa_ax25.sax25_call   = nr->user_addr;\n\t\tmemset(sax->fsa_digipeater, 0, sizeof(sax->fsa_digipeater));\n\t\tsax->fsa_digipeater[0]     = nr->dest_addr;\n\t\t*uaddr_len = sizeof(struct full_sockaddr_ax25);\n\t} else {\n\t\tsax->fsa_ax25.sax25_family = AF_NETROM;\n\t\tsax->fsa_ax25.sax25_ndigis = 0;\n\t\tsax->fsa_ax25.sax25_call   = nr->source_addr;\n\t\t*uaddr_len = sizeof(struct sockaddr_ax25);\n\t}\n\trelease_sock(sk);\n\n\treturn 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147561,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static __inline__ int cbq_dump_ovl(struct sk_buff *skb, struct cbq_class *cl)\n{\n\tunsigned char\t *b = skb->tail;\n\tstruct tc_cbq_ovl opt;\n\n\topt.strategy = cl->ovl_strategy;\n\topt.priority2 = cl->priority2+1;\n\topt.penalty = (cl->penalty*1000)/HZ;\n\tRTA_PUT(skb, TCA_CBQ_OVL_STRATEGY, sizeof(opt), &opt);\n\treturn skb->len;\n\nrtattr_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147564,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static __inline__ int cbq_dump_ovl(struct sk_buff *skb, struct cbq_class *cl)\n{\n\tunsigned char\t *b = skb->tail;\n\tstruct tc_cbq_ovl opt;\n\n\topt.strategy = cl->ovl_strategy;\n\topt.priority2 = cl->priority2+1;\n\topt.pad = 0;\n\topt.penalty = (cl->penalty*1000)/HZ;\n\tRTA_PUT(skb, TCA_CBQ_OVL_STRATEGY, sizeof(opt), &opt);\n\treturn skb->len;\n\nrtattr_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147565,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int rsvp_dump(struct tcf_proto *tp, unsigned long fh,\n\t\t     struct sk_buff *skb, struct tcmsg *t)\n{\n\tstruct rsvp_filter *f = (struct rsvp_filter*)fh;\n\tstruct rsvp_session *s;\n\tunsigned char\t *b = skb->tail;\n\tstruct rtattr *rta;\n\tstruct tc_rsvp_pinfo pinfo;\n\n\tif (f == NULL)\n\t\treturn skb->len;\n\ts = f->sess;\n\n\tt->tcm_handle = f->handle;\n\n\n\trta = (struct rtattr*)b;\n\tRTA_PUT(skb, TCA_OPTIONS, 0, NULL);\n\n\tRTA_PUT(skb, TCA_RSVP_DST, sizeof(s->dst), &s->dst);\n\tpinfo.dpi = s->dpi;\n\tpinfo.spi = f->spi;\n\tpinfo.protocol = s->protocol;\n\tpinfo.tunnelid = s->tunnelid;\n\tpinfo.tunnelhdr = f->tunnelhdr;\n\tRTA_PUT(skb, TCA_RSVP_PINFO, sizeof(pinfo), &pinfo);\n\tif (f->res.classid)\n\t\tRTA_PUT(skb, TCA_RSVP_CLASSID, 4, &f->res.classid);\n\tif (((f->handle>>8)&0xFF) != 16)\n\t\tRTA_PUT(skb, TCA_RSVP_SRC, sizeof(f->src), f->src);\n\n\tif (tcf_exts_dump(skb, &f->exts, &rsvp_ext_map) < 0)\n\t\tgoto rtattr_failure;\n\n\trta->rta_len = skb->tail - b;\n\n\tif (tcf_exts_dump_stats(skb, &f->exts, &rsvp_ext_map) < 0)\n\t\tgoto rtattr_failure;\n\treturn skb->len;\n\nrtattr_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147566,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int rsvp_dump(struct tcf_proto *tp, unsigned long fh,\n\t\t     struct sk_buff *skb, struct tcmsg *t)\n{\n\tstruct rsvp_filter *f = (struct rsvp_filter*)fh;\n\tstruct rsvp_session *s;\n\tunsigned char\t *b = skb->tail;\n\tstruct rtattr *rta;\n\tstruct tc_rsvp_pinfo pinfo;\n\n\tif (f == NULL)\n\t\treturn skb->len;\n\ts = f->sess;\n\n\tt->tcm_handle = f->handle;\n\n\n\trta = (struct rtattr*)b;\n\tRTA_PUT(skb, TCA_OPTIONS, 0, NULL);\n\n\tRTA_PUT(skb, TCA_RSVP_DST, sizeof(s->dst), &s->dst);\n\tpinfo.dpi = s->dpi;\n\tpinfo.spi = f->spi;\n\tpinfo.protocol = s->protocol;\n\tpinfo.tunnelid = s->tunnelid;\n\tpinfo.tunnelhdr = f->tunnelhdr;\n\tpinfo.pad = 0;\n\tRTA_PUT(skb, TCA_RSVP_PINFO, sizeof(pinfo), &pinfo);\n\tif (f->res.classid)\n\t\tRTA_PUT(skb, TCA_RSVP_CLASSID, 4, &f->res.classid);\n\tif (((f->handle>>8)&0xFF) != 16)\n\t\tRTA_PUT(skb, TCA_RSVP_SRC, sizeof(f->src), f->src);\n\n\tif (tcf_exts_dump(skb, &f->exts, &rsvp_ext_map) < 0)\n\t\tgoto rtattr_failure;\n\n\trta->rta_len = skb->tail - b;\n\n\tif (tcf_exts_dump_stats(skb, &f->exts, &rsvp_ext_map) < 0)\n\t\tgoto rtattr_failure;\n\treturn skb->len;\n\nrtattr_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147567,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int inet6_fill_prefix(struct sk_buff *skb, struct inet6_dev *idev,\n\t\t\tstruct prefix_info *pinfo, u32 pid, u32 seq, \n\t\t\tint event, unsigned int flags)\n{\n\tstruct prefixmsg\t*pmsg;\n\tstruct nlmsghdr \t*nlh;\n\tunsigned char\t\t*b = skb->tail;\n\tstruct prefix_cacheinfo\tci;\n\n\tnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*pmsg), flags);\n\tpmsg = NLMSG_DATA(nlh);\n\tpmsg->prefix_family = AF_INET6;\n\tpmsg->prefix_ifindex = idev->dev->ifindex;\n\tpmsg->prefix_len = pinfo->prefix_len;\n\tpmsg->prefix_type = pinfo->type;\n\t\n\tpmsg->prefix_flags = 0;\n\tif (pinfo->onlink)\n\t\tpmsg->prefix_flags |= IF_PREFIX_ONLINK;\n\tif (pinfo->autoconf)\n\t\tpmsg->prefix_flags |= IF_PREFIX_AUTOCONF;\n\n\tRTA_PUT(skb, PREFIX_ADDRESS, sizeof(pinfo->prefix), &pinfo->prefix);\n\n\tci.preferred_time = ntohl(pinfo->prefered);\n\tci.valid_time = ntohl(pinfo->valid);\n\tRTA_PUT(skb, PREFIX_CACHEINFO, sizeof(ci), &ci);\n\n\tnlh->nlmsg_len = skb->tail - b;\n\treturn skb->len;\n\nnlmsg_failure:\nrtattr_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147568,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int inet6_fill_prefix(struct sk_buff *skb, struct inet6_dev *idev,\n\t\t\tstruct prefix_info *pinfo, u32 pid, u32 seq, \n\t\t\tint event, unsigned int flags)\n{\n\tstruct prefixmsg\t*pmsg;\n\tstruct nlmsghdr \t*nlh;\n\tunsigned char\t\t*b = skb->tail;\n\tstruct prefix_cacheinfo\tci;\n\n\tnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*pmsg), flags);\n\tpmsg = NLMSG_DATA(nlh);\n\tpmsg->prefix_family = AF_INET6;\n\tpmsg->prefix_pad1 = 0;\n\tpmsg->prefix_pad2 = 0;\n\tpmsg->prefix_ifindex = idev->dev->ifindex;\n\tpmsg->prefix_len = pinfo->prefix_len;\n\tpmsg->prefix_type = pinfo->type;\n\tpmsg->prefix_pad3 = 0;\n\t\n\tpmsg->prefix_flags = 0;\n\tif (pinfo->onlink)\n\t\tpmsg->prefix_flags |= IF_PREFIX_ONLINK;\n\tif (pinfo->autoconf)\n\t\tpmsg->prefix_flags |= IF_PREFIX_AUTOCONF;\n\n\tRTA_PUT(skb, PREFIX_ADDRESS, sizeof(pinfo->prefix), &pinfo->prefix);\n\n\tci.preferred_time = ntohl(pinfo->prefered);\n\tci.valid_time = ntohl(pinfo->valid);\n\tRTA_PUT(skb, PREFIX_CACHEINFO, sizeof(ci), &ci);\n\n\tnlh->nlmsg_len = skb->tail - b;\n\treturn skb->len;\n\nnlmsg_failure:\nrtattr_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147569,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int neightbl_fill_info(struct neigh_table *tbl, struct sk_buff *skb,\n\t\t\t      struct netlink_callback *cb)\n{\n\tstruct nlmsghdr *nlh;\n\tstruct ndtmsg *ndtmsg;\n\n\tnlh = NLMSG_NEW_ANSWER(skb, cb, RTM_NEWNEIGHTBL, sizeof(struct ndtmsg),\n\t\t\t       NLM_F_MULTI);\n\n\tndtmsg = NLMSG_DATA(nlh);\n\n\tread_lock_bh(&tbl->lock);\n\tndtmsg->ndtm_family = tbl->family;\n\n\tRTA_PUT_STRING(skb, NDTA_NAME, tbl->id);\n\tRTA_PUT_MSECS(skb, NDTA_GC_INTERVAL, tbl->gc_interval);\n\tRTA_PUT_U32(skb, NDTA_THRESH1, tbl->gc_thresh1);\n\tRTA_PUT_U32(skb, NDTA_THRESH2, tbl->gc_thresh2);\n\tRTA_PUT_U32(skb, NDTA_THRESH3, tbl->gc_thresh3);\n\n\t{\n\t\tunsigned long now = jiffies;\n\t\tunsigned int flush_delta = now - tbl->last_flush;\n\t\tunsigned int rand_delta = now - tbl->last_rand;\n\n\t\tstruct ndt_config ndc = {\n\t\t\t.ndtc_key_len\t\t= tbl->key_len,\n\t\t\t.ndtc_entry_size\t= tbl->entry_size,\n\t\t\t.ndtc_entries\t\t= atomic_read(&tbl->entries),\n\t\t\t.ndtc_last_flush\t= jiffies_to_msecs(flush_delta),\n\t\t\t.ndtc_last_rand\t\t= jiffies_to_msecs(rand_delta),\n\t\t\t.ndtc_hash_rnd\t\t= tbl->hash_rnd,\n\t\t\t.ndtc_hash_mask\t\t= tbl->hash_mask,\n\t\t\t.ndtc_hash_chain_gc\t= tbl->hash_chain_gc,\n\t\t\t.ndtc_proxy_qlen\t= tbl->proxy_queue.qlen,\n\t\t};\n\n\t\tRTA_PUT(skb, NDTA_CONFIG, sizeof(ndc), &ndc);\n\t}\n\n\t{\n\t\tint cpu;\n\t\tstruct ndt_stats ndst;\n\n\t\tmemset(&ndst, 0, sizeof(ndst));\n\n\t\tfor (cpu = 0; cpu < NR_CPUS; cpu++) {\n\t\t\tstruct neigh_statistics\t*st;\n\n\t\t\tif (!cpu_possible(cpu))\n\t\t\t\tcontinue;\n\n\t\t\tst = per_cpu_ptr(tbl->stats, cpu);\n\t\t\tndst.ndts_allocs\t\t+= st->allocs;\n\t\t\tndst.ndts_destroys\t\t+= st->destroys;\n\t\t\tndst.ndts_hash_grows\t\t+= st->hash_grows;\n\t\t\tndst.ndts_res_failed\t\t+= st->res_failed;\n\t\t\tndst.ndts_lookups\t\t+= st->lookups;\n\t\t\tndst.ndts_hits\t\t\t+= st->hits;\n\t\t\tndst.ndts_rcv_probes_mcast\t+= st->rcv_probes_mcast;\n\t\t\tndst.ndts_rcv_probes_ucast\t+= st->rcv_probes_ucast;\n\t\t\tndst.ndts_periodic_gc_runs\t+= st->periodic_gc_runs;\n\t\t\tndst.ndts_forced_gc_runs\t+= st->forced_gc_runs;\n\t\t}\n\n\t\tRTA_PUT(skb, NDTA_STATS, sizeof(ndst), &ndst);\n\t}\n\n\tBUG_ON(tbl->parms.dev);\n\tif (neightbl_fill_parms(skb, &tbl->parms) < 0)\n\t\tgoto rtattr_failure;\n\n\tread_unlock_bh(&tbl->lock);\n\treturn NLMSG_END(skb, nlh);\n\nrtattr_failure:\n\tread_unlock_bh(&tbl->lock);\n\treturn NLMSG_CANCEL(skb, nlh);\n \nnlmsg_failure:\n\treturn -1;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147570,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int neightbl_fill_info(struct neigh_table *tbl, struct sk_buff *skb,\n\t\t\t      struct netlink_callback *cb)\n{\n\tstruct nlmsghdr *nlh;\n\tstruct ndtmsg *ndtmsg;\n\n\tnlh = NLMSG_NEW_ANSWER(skb, cb, RTM_NEWNEIGHTBL, sizeof(struct ndtmsg),\n\t\t\t       NLM_F_MULTI);\n\n\tndtmsg = NLMSG_DATA(nlh);\n\n\tread_lock_bh(&tbl->lock);\n\tndtmsg->ndtm_family = tbl->family;\n\tndtmsg->ndtm_pad1   = 0;\n\tndtmsg->ndtm_pad2   = 0;\n\n\tRTA_PUT_STRING(skb, NDTA_NAME, tbl->id);\n\tRTA_PUT_MSECS(skb, NDTA_GC_INTERVAL, tbl->gc_interval);\n\tRTA_PUT_U32(skb, NDTA_THRESH1, tbl->gc_thresh1);\n\tRTA_PUT_U32(skb, NDTA_THRESH2, tbl->gc_thresh2);\n\tRTA_PUT_U32(skb, NDTA_THRESH3, tbl->gc_thresh3);\n\n\t{\n\t\tunsigned long now = jiffies;\n\t\tunsigned int flush_delta = now - tbl->last_flush;\n\t\tunsigned int rand_delta = now - tbl->last_rand;\n\n\t\tstruct ndt_config ndc = {\n\t\t\t.ndtc_key_len\t\t= tbl->key_len,\n\t\t\t.ndtc_entry_size\t= tbl->entry_size,\n\t\t\t.ndtc_entries\t\t= atomic_read(&tbl->entries),\n\t\t\t.ndtc_last_flush\t= jiffies_to_msecs(flush_delta),\n\t\t\t.ndtc_last_rand\t\t= jiffies_to_msecs(rand_delta),\n\t\t\t.ndtc_hash_rnd\t\t= tbl->hash_rnd,\n\t\t\t.ndtc_hash_mask\t\t= tbl->hash_mask,\n\t\t\t.ndtc_hash_chain_gc\t= tbl->hash_chain_gc,\n\t\t\t.ndtc_proxy_qlen\t= tbl->proxy_queue.qlen,\n\t\t};\n\n\t\tRTA_PUT(skb, NDTA_CONFIG, sizeof(ndc), &ndc);\n\t}\n\n\t{\n\t\tint cpu;\n\t\tstruct ndt_stats ndst;\n\n\t\tmemset(&ndst, 0, sizeof(ndst));\n\n\t\tfor (cpu = 0; cpu < NR_CPUS; cpu++) {\n\t\t\tstruct neigh_statistics\t*st;\n\n\t\t\tif (!cpu_possible(cpu))\n\t\t\t\tcontinue;\n\n\t\t\tst = per_cpu_ptr(tbl->stats, cpu);\n\t\t\tndst.ndts_allocs\t\t+= st->allocs;\n\t\t\tndst.ndts_destroys\t\t+= st->destroys;\n\t\t\tndst.ndts_hash_grows\t\t+= st->hash_grows;\n\t\t\tndst.ndts_res_failed\t\t+= st->res_failed;\n\t\t\tndst.ndts_lookups\t\t+= st->lookups;\n\t\t\tndst.ndts_hits\t\t\t+= st->hits;\n\t\t\tndst.ndts_rcv_probes_mcast\t+= st->rcv_probes_mcast;\n\t\t\tndst.ndts_rcv_probes_ucast\t+= st->rcv_probes_ucast;\n\t\t\tndst.ndts_periodic_gc_runs\t+= st->periodic_gc_runs;\n\t\t\tndst.ndts_forced_gc_runs\t+= st->forced_gc_runs;\n\t\t}\n\n\t\tRTA_PUT(skb, NDTA_STATS, sizeof(ndst), &ndst);\n\t}\n\n\tBUG_ON(tbl->parms.dev);\n\tif (neightbl_fill_parms(skb, &tbl->parms) < 0)\n\t\tgoto rtattr_failure;\n\n\tread_unlock_bh(&tbl->lock);\n\treturn NLMSG_END(skb, nlh);\n\nrtattr_failure:\n\tread_unlock_bh(&tbl->lock);\n\treturn NLMSG_CANCEL(skb, nlh);\n \nnlmsg_failure:\n\treturn -1;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147571,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static void ipmr_destroy_unres(struct mfc_cache *c)\n{\n\tstruct sk_buff *skb;\n\n\tatomic_dec(&cache_resolve_queue_len);\n\n\twhile((skb=skb_dequeue(&c->mfc_un.unres.unresolved))) {\n\t\tif (skb->nh.iph->version == 0) {\n\t\t\tstruct nlmsghdr *nlh = (struct nlmsghdr *)skb_pull(skb, sizeof(struct iphdr));\n\t\t\tnlh->nlmsg_type = NLMSG_ERROR;\n\t\t\tnlh->nlmsg_len = NLMSG_LENGTH(sizeof(struct nlmsgerr));\n\t\t\tskb_trim(skb, nlh->nlmsg_len);\n\t\t\t((struct nlmsgerr*)NLMSG_DATA(nlh))->error = -ETIMEDOUT;\n\t\t\tnetlink_unicast(rtnl, skb, NETLINK_CB(skb).dst_pid, MSG_DONTWAIT);\n\t\t} else\n\t\t\tkfree_skb(skb);\n\t}\n\n\tkmem_cache_free(mrt_cachep, c);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147572,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static void ipmr_destroy_unres(struct mfc_cache *c)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsgerr *e;\n\n\tatomic_dec(&cache_resolve_queue_len);\n\n\twhile((skb=skb_dequeue(&c->mfc_un.unres.unresolved))) {\n\t\tif (skb->nh.iph->version == 0) {\n\t\t\tstruct nlmsghdr *nlh = (struct nlmsghdr *)skb_pull(skb, sizeof(struct iphdr));\n\t\t\tnlh->nlmsg_type = NLMSG_ERROR;\n\t\t\tnlh->nlmsg_len = NLMSG_LENGTH(sizeof(struct nlmsgerr));\n\t\t\tskb_trim(skb, nlh->nlmsg_len);\n\t\t\te = NLMSG_DATA(nlh);\n\t\t\te->error = -ETIMEDOUT;\n\t\t\tmemset(&e->msg, 0, sizeof(e->msg));\n\t\t\tnetlink_unicast(rtnl, skb, NETLINK_CB(skb).dst_pid, MSG_DONTWAIT);\n\t\t} else\n\t\t\tkfree_skb(skb);\n\t}\n\n\tkmem_cache_free(mrt_cachep, c);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147573,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static void ipmr_cache_resolve(struct mfc_cache *uc, struct mfc_cache *c)\n{\n\tstruct sk_buff *skb;\n\n\t/*\n\t *\tPlay the pending entries through our router\n\t */\n\n\twhile((skb=__skb_dequeue(&uc->mfc_un.unres.unresolved))) {\n\t\tif (skb->nh.iph->version == 0) {\n\t\t\tint err;\n\t\t\tstruct nlmsghdr *nlh = (struct nlmsghdr *)skb_pull(skb, sizeof(struct iphdr));\n\n\t\t\tif (ipmr_fill_mroute(skb, c, NLMSG_DATA(nlh)) > 0) {\n\t\t\t\tnlh->nlmsg_len = skb->tail - (u8*)nlh;\n\t\t\t} else {\n\t\t\t\tnlh->nlmsg_type = NLMSG_ERROR;\n\t\t\t\tnlh->nlmsg_len = NLMSG_LENGTH(sizeof(struct nlmsgerr));\n\t\t\t\tskb_trim(skb, nlh->nlmsg_len);\n\t\t\t\t((struct nlmsgerr*)NLMSG_DATA(nlh))->error = -EMSGSIZE;\n\t\t\t}\n\t\t\terr = netlink_unicast(rtnl, skb, NETLINK_CB(skb).dst_pid, MSG_DONTWAIT);\n\t\t} else\n\t\t\tip_mr_forward(skb, c, 0);\n\t}\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147574,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static void ipmr_cache_resolve(struct mfc_cache *uc, struct mfc_cache *c)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsgerr *e;\n\n\t/*\n\t *\tPlay the pending entries through our router\n\t */\n\n\twhile((skb=__skb_dequeue(&uc->mfc_un.unres.unresolved))) {\n\t\tif (skb->nh.iph->version == 0) {\n\t\t\tint err;\n\t\t\tstruct nlmsghdr *nlh = (struct nlmsghdr *)skb_pull(skb, sizeof(struct iphdr));\n\n\t\t\tif (ipmr_fill_mroute(skb, c, NLMSG_DATA(nlh)) > 0) {\n\t\t\t\tnlh->nlmsg_len = skb->tail - (u8*)nlh;\n\t\t\t} else {\n\t\t\t\tnlh->nlmsg_type = NLMSG_ERROR;\n\t\t\t\tnlh->nlmsg_len = NLMSG_LENGTH(sizeof(struct nlmsgerr));\n\t\t\t\tskb_trim(skb, nlh->nlmsg_len);\n\t\t\t\te = NLMSG_DATA(nlh);\n\t\t\t\te->error = -EMSGSIZE;\n\t\t\t\tmemset(&e->msg, 0, sizeof(e->msg));\n\t\t\t}\n\t\t\terr = netlink_unicast(rtnl, skb, NETLINK_CB(skb).dst_pid, MSG_DONTWAIT);\n\t\t} else\n\t\t\tip_mr_forward(skb, c, 0);\n\t}\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147575,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int tcf_add_notify(struct tc_action *a, u32 pid, u32 seq, int event,\n                          u16 flags)\n{\n\tstruct tcamsg *t;\n\tstruct nlmsghdr *nlh;\n\tstruct sk_buff *skb;\n\tstruct rtattr *x;\n\tunsigned char *b;\n\tint err = 0;\n\n\tskb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\n\tb = (unsigned char *)skb->tail;\n\n\tnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*t), flags);\n\tt = NLMSG_DATA(nlh);\n\tt->tca_family = AF_UNSPEC;\n\t\n\tx = (struct rtattr*) skb->tail;\n\tRTA_PUT(skb, TCA_ACT_TAB, 0, NULL);\n\n\tif (tcf_action_dump(skb, a, 0, 0) < 0)\n\t\tgoto rtattr_failure;\n\n\tx->rta_len = skb->tail - (u8*)x;\n\t\n\tnlh->nlmsg_len = skb->tail - b;\n\tNETLINK_CB(skb).dst_groups = RTMGRP_TC;\n\t\n\terr = rtnetlink_send(skb, pid, RTMGRP_TC, flags&NLM_F_ECHO);\n\tif (err > 0)\n\t\terr = 0;\n\treturn err;\n\nrtattr_failure:\nnlmsg_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147576,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int tcf_add_notify(struct tc_action *a, u32 pid, u32 seq, int event,\n                          u16 flags)\n{\n\tstruct tcamsg *t;\n\tstruct nlmsghdr *nlh;\n\tstruct sk_buff *skb;\n\tstruct rtattr *x;\n\tunsigned char *b;\n\tint err = 0;\n\n\tskb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\n\tb = (unsigned char *)skb->tail;\n\n\tnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*t), flags);\n\tt = NLMSG_DATA(nlh);\n\tt->tca_family = AF_UNSPEC;\n\tt->tca__pad1 = 0;\n\tt->tca__pad2 = 0;\n\n\tx = (struct rtattr*) skb->tail;\n\tRTA_PUT(skb, TCA_ACT_TAB, 0, NULL);\n\n\tif (tcf_action_dump(skb, a, 0, 0) < 0)\n\t\tgoto rtattr_failure;\n\n\tx->rta_len = skb->tail - (u8*)x;\n\t\n\tnlh->nlmsg_len = skb->tail - b;\n\tNETLINK_CB(skb).dst_groups = RTMGRP_TC;\n\t\n\terr = rtnetlink_send(skb, pid, RTMGRP_TC, flags&NLM_F_ECHO);\n\tif (err > 0)\n\t\terr = 0;\n\treturn err;\n\nrtattr_failure:\nnlmsg_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147577,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "tca_get_fill(struct sk_buff *skb, struct tc_action *a, u32 pid, u32 seq,\n             u16 flags, int event, int bind, int ref)\n{\n\tstruct tcamsg *t;\n\tstruct nlmsghdr *nlh;\n\tunsigned char *b = skb->tail;\n\tstruct rtattr *x;\n\n\tnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*t), flags);\n\n\tt = NLMSG_DATA(nlh);\n\tt->tca_family = AF_UNSPEC;\n\t\n\tx = (struct rtattr*) skb->tail;\n\tRTA_PUT(skb, TCA_ACT_TAB, 0, NULL);\n\n\tif (tcf_action_dump(skb, a, bind, ref) < 0)\n\t\tgoto rtattr_failure;\n\n\tx->rta_len = skb->tail - (u8*)x;\n\t\n\tnlh->nlmsg_len = skb->tail - b;\n\treturn skb->len;\n\nrtattr_failure:\nnlmsg_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147578,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "tca_get_fill(struct sk_buff *skb, struct tc_action *a, u32 pid, u32 seq,\n             u16 flags, int event, int bind, int ref)\n{\n\tstruct tcamsg *t;\n\tstruct nlmsghdr *nlh;\n\tunsigned char *b = skb->tail;\n\tstruct rtattr *x;\n\n\tnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*t), flags);\n\n\tt = NLMSG_DATA(nlh);\n\tt->tca_family = AF_UNSPEC;\n\tt->tca__pad1 = 0;\n\tt->tca__pad2 = 0;\n\t\n\tx = (struct rtattr*) skb->tail;\n\tRTA_PUT(skb, TCA_ACT_TAB, 0, NULL);\n\n\tif (tcf_action_dump(skb, a, bind, ref) < 0)\n\t\tgoto rtattr_failure;\n\n\tx->rta_len = skb->tail - (u8*)x;\n\t\n\tnlh->nlmsg_len = skb->tail - b;\n\treturn skb->len;\n\nrtattr_failure:\nnlmsg_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147579,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "tc_dump_action(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct nlmsghdr *nlh;\n\tunsigned char *b = skb->tail;\n\tstruct rtattr *x;\n\tstruct tc_action_ops *a_o;\n\tstruct tc_action a;\n\tint ret = 0;\n\tstruct tcamsg *t = (struct tcamsg *) NLMSG_DATA(cb->nlh);\n\tchar *kind = find_dump_kind(cb->nlh);\n\n\tif (kind == NULL) {\n\t\tprintk(\"tc_dump_action: action bad kind\\n\");\n\t\treturn 0;\n\t}\n\n\ta_o = tc_lookup_action_n(kind);\n\tif (a_o == NULL) {\n\t\tprintk(\"failed to find %s\\n\", kind);\n\t\treturn 0;\n\t}\n\n\tmemset(&a, 0, sizeof(struct tc_action));\n\ta.ops = a_o;\n\n\tif (a_o->walk == NULL) {\n\t\tprintk(\"tc_dump_action: %s !capable of dumping table\\n\", kind);\n\t\tgoto rtattr_failure;\n\t}\n\n\tnlh = NLMSG_PUT(skb, NETLINK_CB(cb->skb).pid, cb->nlh->nlmsg_seq,\n\t                cb->nlh->nlmsg_type, sizeof(*t));\n\tt = NLMSG_DATA(nlh);\n\tt->tca_family = AF_UNSPEC;\n\n\tx = (struct rtattr *) skb->tail;\n\tRTA_PUT(skb, TCA_ACT_TAB, 0, NULL);\n\n\tret = a_o->walk(skb, cb, RTM_GETACTION, &a);\n\tif (ret < 0)\n\t\tgoto rtattr_failure;\n\n\tif (ret > 0) {\n\t\tx->rta_len = skb->tail - (u8 *) x;\n\t\tret = skb->len;\n\t} else\n\t\tskb_trim(skb, (u8*)x - skb->data);\n\n\tnlh->nlmsg_len = skb->tail - b;\n\tif (NETLINK_CB(cb->skb).pid && ret)\n\t\tnlh->nlmsg_flags |= NLM_F_MULTI;\n\tmodule_put(a_o->owner);\n\treturn skb->len;\n\nrtattr_failure:\nnlmsg_failure:\n\tmodule_put(a_o->owner);\n\tskb_trim(skb, b - skb->data);\n\treturn skb->len;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147580,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "tc_dump_action(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct nlmsghdr *nlh;\n\tunsigned char *b = skb->tail;\n\tstruct rtattr *x;\n\tstruct tc_action_ops *a_o;\n\tstruct tc_action a;\n\tint ret = 0;\n\tstruct tcamsg *t = (struct tcamsg *) NLMSG_DATA(cb->nlh);\n\tchar *kind = find_dump_kind(cb->nlh);\n\n\tif (kind == NULL) {\n\t\tprintk(\"tc_dump_action: action bad kind\\n\");\n\t\treturn 0;\n\t}\n\n\ta_o = tc_lookup_action_n(kind);\n\tif (a_o == NULL) {\n\t\tprintk(\"failed to find %s\\n\", kind);\n\t\treturn 0;\n\t}\n\n\tmemset(&a, 0, sizeof(struct tc_action));\n\ta.ops = a_o;\n\n\tif (a_o->walk == NULL) {\n\t\tprintk(\"tc_dump_action: %s !capable of dumping table\\n\", kind);\n\t\tgoto rtattr_failure;\n\t}\n\n\tnlh = NLMSG_PUT(skb, NETLINK_CB(cb->skb).pid, cb->nlh->nlmsg_seq,\n\t                cb->nlh->nlmsg_type, sizeof(*t));\n\tt = NLMSG_DATA(nlh);\n\tt->tca_family = AF_UNSPEC;\n\tt->tca__pad1 = 0;\n\tt->tca__pad2 = 0;\n\n\tx = (struct rtattr *) skb->tail;\n\tRTA_PUT(skb, TCA_ACT_TAB, 0, NULL);\n\n\tret = a_o->walk(skb, cb, RTM_GETACTION, &a);\n\tif (ret < 0)\n\t\tgoto rtattr_failure;\n\n\tif (ret > 0) {\n\t\tx->rta_len = skb->tail - (u8 *) x;\n\t\tret = skb->len;\n\t} else\n\t\tskb_trim(skb, (u8*)x - skb->data);\n\n\tnlh->nlmsg_len = skb->tail - b;\n\tif (NETLINK_CB(cb->skb).pid && ret)\n\t\tnlh->nlmsg_flags |= NLM_F_MULTI;\n\tmodule_put(a_o->owner);\n\treturn skb->len;\n\nrtattr_failure:\nnlmsg_failure:\n\tmodule_put(a_o->owner);\n\tskb_trim(skb, b - skb->data);\n\treturn skb->len;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147581,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int rtnetlink_fill_ifinfo(struct sk_buff *skb, struct net_device *dev,\n\t\t\t\t int type, u32 pid, u32 seq, u32 change, \n\t\t\t\t unsigned int flags)\n{\n\tstruct ifinfomsg *r;\n\tstruct nlmsghdr  *nlh;\n\tunsigned char\t *b = skb->tail;\n\n\tnlh = NLMSG_NEW(skb, pid, seq, type, sizeof(*r), flags);\n\tr = NLMSG_DATA(nlh);\n\tr->ifi_family = AF_UNSPEC;\n\tr->ifi_type = dev->type;\n\tr->ifi_index = dev->ifindex;\n\tr->ifi_flags = dev_get_flags(dev);\n\tr->ifi_change = change;\n\n\tRTA_PUT(skb, IFLA_IFNAME, strlen(dev->name)+1, dev->name);\n\n\tif (1) {\n\t\tu32 txqlen = dev->tx_queue_len;\n\t\tRTA_PUT(skb, IFLA_TXQLEN, sizeof(txqlen), &txqlen);\n\t}\n\n\tif (1) {\n\t\tu32 weight = dev->weight;\n\t\tRTA_PUT(skb, IFLA_WEIGHT, sizeof(weight), &weight);\n\t}\n\n\tif (1) {\n\t\tstruct rtnl_link_ifmap map = {\n\t\t\t.mem_start   = dev->mem_start,\n\t\t\t.mem_end     = dev->mem_end,\n\t\t\t.base_addr   = dev->base_addr,\n\t\t\t.irq         = dev->irq,\n\t\t\t.dma         = dev->dma,\n\t\t\t.port        = dev->if_port,\n\t\t};\n\t\tRTA_PUT(skb, IFLA_MAP, sizeof(map), &map);\n\t}\n\n\tif (dev->addr_len) {\n\t\tRTA_PUT(skb, IFLA_ADDRESS, dev->addr_len, dev->dev_addr);\n\t\tRTA_PUT(skb, IFLA_BROADCAST, dev->addr_len, dev->broadcast);\n\t}\n\n\tif (1) {\n\t\tu32 mtu = dev->mtu;\n\t\tRTA_PUT(skb, IFLA_MTU, sizeof(mtu), &mtu);\n\t}\n\n\tif (dev->ifindex != dev->iflink) {\n\t\tu32 iflink = dev->iflink;\n\t\tRTA_PUT(skb, IFLA_LINK, sizeof(iflink), &iflink);\n\t}\n\n\tif (dev->qdisc_sleeping)\n\t\tRTA_PUT(skb, IFLA_QDISC,\n\t\t\tstrlen(dev->qdisc_sleeping->ops->id) + 1,\n\t\t\tdev->qdisc_sleeping->ops->id);\n\t\n\tif (dev->master) {\n\t\tu32 master = dev->master->ifindex;\n\t\tRTA_PUT(skb, IFLA_MASTER, sizeof(master), &master);\n\t}\n\n\tif (dev->get_stats) {\n\t\tunsigned long *stats = (unsigned long*)dev->get_stats(dev);\n\t\tif (stats) {\n\t\t\tstruct rtattr  *a;\n\t\t\t__u32\t       *s;\n\t\t\tint\t\ti;\n\t\t\tint\t\tn = sizeof(struct rtnl_link_stats)/4;\n\n\t\t\ta = __RTA_PUT(skb, IFLA_STATS, n*4);\n\t\t\ts = RTA_DATA(a);\n\t\t\tfor (i=0; i<n; i++)\n\t\t\t\ts[i] = stats[i];\n\t\t}\n\t}\n\tnlh->nlmsg_len = skb->tail - b;\n\treturn skb->len;\n\nnlmsg_failure:\nrtattr_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147582,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int rtnetlink_fill_ifinfo(struct sk_buff *skb, struct net_device *dev,\n\t\t\t\t int type, u32 pid, u32 seq, u32 change, \n\t\t\t\t unsigned int flags)\n{\n\tstruct ifinfomsg *r;\n\tstruct nlmsghdr  *nlh;\n\tunsigned char\t *b = skb->tail;\n\n\tnlh = NLMSG_NEW(skb, pid, seq, type, sizeof(*r), flags);\n\tr = NLMSG_DATA(nlh);\n\tr->ifi_family = AF_UNSPEC;\n\tr->__ifi_pad = 0;\n\tr->ifi_type = dev->type;\n\tr->ifi_index = dev->ifindex;\n\tr->ifi_flags = dev_get_flags(dev);\n\tr->ifi_change = change;\n\n\tRTA_PUT(skb, IFLA_IFNAME, strlen(dev->name)+1, dev->name);\n\n\tif (1) {\n\t\tu32 txqlen = dev->tx_queue_len;\n\t\tRTA_PUT(skb, IFLA_TXQLEN, sizeof(txqlen), &txqlen);\n\t}\n\n\tif (1) {\n\t\tu32 weight = dev->weight;\n\t\tRTA_PUT(skb, IFLA_WEIGHT, sizeof(weight), &weight);\n\t}\n\n\tif (1) {\n\t\tstruct rtnl_link_ifmap map = {\n\t\t\t.mem_start   = dev->mem_start,\n\t\t\t.mem_end     = dev->mem_end,\n\t\t\t.base_addr   = dev->base_addr,\n\t\t\t.irq         = dev->irq,\n\t\t\t.dma         = dev->dma,\n\t\t\t.port        = dev->if_port,\n\t\t};\n\t\tRTA_PUT(skb, IFLA_MAP, sizeof(map), &map);\n\t}\n\n\tif (dev->addr_len) {\n\t\tRTA_PUT(skb, IFLA_ADDRESS, dev->addr_len, dev->dev_addr);\n\t\tRTA_PUT(skb, IFLA_BROADCAST, dev->addr_len, dev->broadcast);\n\t}\n\n\tif (1) {\n\t\tu32 mtu = dev->mtu;\n\t\tRTA_PUT(skb, IFLA_MTU, sizeof(mtu), &mtu);\n\t}\n\n\tif (dev->ifindex != dev->iflink) {\n\t\tu32 iflink = dev->iflink;\n\t\tRTA_PUT(skb, IFLA_LINK, sizeof(iflink), &iflink);\n\t}\n\n\tif (dev->qdisc_sleeping)\n\t\tRTA_PUT(skb, IFLA_QDISC,\n\t\t\tstrlen(dev->qdisc_sleeping->ops->id) + 1,\n\t\t\tdev->qdisc_sleeping->ops->id);\n\t\n\tif (dev->master) {\n\t\tu32 master = dev->master->ifindex;\n\t\tRTA_PUT(skb, IFLA_MASTER, sizeof(master), &master);\n\t}\n\n\tif (dev->get_stats) {\n\t\tunsigned long *stats = (unsigned long*)dev->get_stats(dev);\n\t\tif (stats) {\n\t\t\tstruct rtattr  *a;\n\t\t\t__u32\t       *s;\n\t\t\tint\t\ti;\n\t\t\tint\t\tn = sizeof(struct rtnl_link_stats)/4;\n\n\t\t\ta = __RTA_PUT(skb, IFLA_STATS, n*4);\n\t\t\ts = RTA_DATA(a);\n\t\t\tfor (i=0; i<n; i++)\n\t\t\t\ts[i] = stats[i];\n\t\t}\n\t}\n\tnlh->nlmsg_len = skb->tail - b;\n\treturn skb->len;\n\nnlmsg_failure:\nrtattr_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147583,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int neigh_fill_info(struct sk_buff *skb, struct neighbour *n,\n\t\t\t   u32 pid, u32 seq, int event, unsigned int flags)\n{\n\tunsigned long now = jiffies;\n\tunsigned char *b = skb->tail;\n\tstruct nda_cacheinfo ci;\n\tint locked = 0;\n\tu32 probes;\n\tstruct nlmsghdr *nlh = NLMSG_NEW(skb, pid, seq, event,\n\t\t\t\t\t sizeof(struct ndmsg), flags);\n\tstruct ndmsg *ndm = NLMSG_DATA(nlh);\n\n\tndm->ndm_family\t = n->ops->family;\n\tndm->ndm_flags\t = n->flags;\n\tndm->ndm_type\t = n->type;\n\tndm->ndm_ifindex = n->dev->ifindex;\n\tRTA_PUT(skb, NDA_DST, n->tbl->key_len, n->primary_key);\n\tread_lock_bh(&n->lock);\n\tlocked\t\t = 1;\n\tndm->ndm_state\t = n->nud_state;\n\tif (n->nud_state & NUD_VALID)\n\t\tRTA_PUT(skb, NDA_LLADDR, n->dev->addr_len, n->ha);\n\tci.ndm_used\t = now - n->used;\n\tci.ndm_confirmed = now - n->confirmed;\n\tci.ndm_updated\t = now - n->updated;\n\tci.ndm_refcnt\t = atomic_read(&n->refcnt) - 1;\n\tprobes = atomic_read(&n->probes);\n\tread_unlock_bh(&n->lock);\n\tlocked\t\t = 0;\n\tRTA_PUT(skb, NDA_CACHEINFO, sizeof(ci), &ci);\n\tRTA_PUT(skb, NDA_PROBES, sizeof(probes), &probes);\n\tnlh->nlmsg_len\t = skb->tail - b;\n\treturn skb->len;\n\nnlmsg_failure:\nrtattr_failure:\n\tif (locked)\n\t\tread_unlock_bh(&n->lock);\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147584,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int neigh_fill_info(struct sk_buff *skb, struct neighbour *n,\n\t\t\t   u32 pid, u32 seq, int event, unsigned int flags)\n{\n\tunsigned long now = jiffies;\n\tunsigned char *b = skb->tail;\n\tstruct nda_cacheinfo ci;\n\tint locked = 0;\n\tu32 probes;\n\tstruct nlmsghdr *nlh = NLMSG_NEW(skb, pid, seq, event,\n\t\t\t\t\t sizeof(struct ndmsg), flags);\n\tstruct ndmsg *ndm = NLMSG_DATA(nlh);\n\n\tndm->ndm_family\t = n->ops->family;\n\tndm->ndm_pad1    = 0;\n\tndm->ndm_pad2    = 0;\n\tndm->ndm_flags\t = n->flags;\n\tndm->ndm_type\t = n->type;\n\tndm->ndm_ifindex = n->dev->ifindex;\n\tRTA_PUT(skb, NDA_DST, n->tbl->key_len, n->primary_key);\n\tread_lock_bh(&n->lock);\n\tlocked\t\t = 1;\n\tndm->ndm_state\t = n->nud_state;\n\tif (n->nud_state & NUD_VALID)\n\t\tRTA_PUT(skb, NDA_LLADDR, n->dev->addr_len, n->ha);\n\tci.ndm_used\t = now - n->used;\n\tci.ndm_confirmed = now - n->confirmed;\n\tci.ndm_updated\t = now - n->updated;\n\tci.ndm_refcnt\t = atomic_read(&n->refcnt) - 1;\n\tprobes = atomic_read(&n->probes);\n\tread_unlock_bh(&n->lock);\n\tlocked\t\t = 0;\n\tRTA_PUT(skb, NDA_CACHEINFO, sizeof(ci), &ci);\n\tRTA_PUT(skb, NDA_PROBES, sizeof(probes), &probes);\n\tnlh->nlmsg_len\t = skb->tail - b;\n\treturn skb->len;\n\nnlmsg_failure:\nrtattr_failure:\n\tif (locked)\n\t\tread_unlock_bh(&n->lock);\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147585,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static inline int rtnetlink_fill_iwinfo(struct sk_buff *\tskb,\n\t\t\t\t\tstruct net_device *\tdev,\n\t\t\t\t\tint\t\t\ttype,\n\t\t\t\t\tchar *\t\t\tevent,\n\t\t\t\t\tint\t\t\tevent_len)\n{\n\tstruct ifinfomsg *r;\n\tstruct nlmsghdr  *nlh;\n\tunsigned char\t *b = skb->tail;\n\n\tnlh = NLMSG_PUT(skb, 0, 0, type, sizeof(*r));\n\tr = NLMSG_DATA(nlh);\n\tr->ifi_family = AF_UNSPEC;\n\tr->ifi_type = dev->type;\n\tr->ifi_index = dev->ifindex;\n\tr->ifi_flags = dev->flags;\n\tr->ifi_change = 0;\t/* Wireless changes don't affect those flags */\n\n\t/* Add the wireless events in the netlink packet */\n\tRTA_PUT(skb, IFLA_WIRELESS,\n\t\tevent_len, event);\n\n\tnlh->nlmsg_len = skb->tail - b;\n\treturn skb->len;\n\nnlmsg_failure:\nrtattr_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147586,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static inline int rtnetlink_fill_iwinfo(struct sk_buff *\tskb,\n\t\t\t\t\tstruct net_device *\tdev,\n\t\t\t\t\tint\t\t\ttype,\n\t\t\t\t\tchar *\t\t\tevent,\n\t\t\t\t\tint\t\t\tevent_len)\n{\n\tstruct ifinfomsg *r;\n\tstruct nlmsghdr  *nlh;\n\tunsigned char\t *b = skb->tail;\n\n\tnlh = NLMSG_PUT(skb, 0, 0, type, sizeof(*r));\n\tr = NLMSG_DATA(nlh);\n\tr->ifi_family = AF_UNSPEC;\n\tr->__ifi_pad = 0;\n\tr->ifi_type = dev->type;\n\tr->ifi_index = dev->ifindex;\n\tr->ifi_flags = dev->flags;\n\tr->ifi_change = 0;\t/* Wireless changes don't affect those flags */\n\n\t/* Add the wireless events in the netlink packet */\n\tRTA_PUT(skb, IFLA_WIRELESS,\n\t\tevent_len, event);\n\n\tnlh->nlmsg_len = skb->tail - b;\n\treturn skb->len;\n\nnlmsg_failure:\nrtattr_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147587,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "tcf_fill_node(struct sk_buff *skb, struct tcf_proto *tp, unsigned long fh,\n\t      u32 pid, u32 seq, u16 flags, int event)\n{\n\tstruct tcmsg *tcm;\n\tstruct nlmsghdr  *nlh;\n\tunsigned char\t *b = skb->tail;\n\n\tnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*tcm), flags);\n\ttcm = NLMSG_DATA(nlh);\n\ttcm->tcm_family = AF_UNSPEC;\n\ttcm->tcm_ifindex = tp->q->dev->ifindex;\n\ttcm->tcm_parent = tp->classid;\n\ttcm->tcm_info = TC_H_MAKE(tp->prio, tp->protocol);\n\tRTA_PUT(skb, TCA_KIND, IFNAMSIZ, tp->ops->kind);\n\ttcm->tcm_handle = fh;\n\tif (RTM_DELTFILTER != event) {\n\t\ttcm->tcm_handle = 0;\n\t\tif (tp->ops->dump && tp->ops->dump(tp, fh, skb, tcm) < 0)\n\t\t\tgoto rtattr_failure;\n\t}\n\tnlh->nlmsg_len = skb->tail - b;\n\treturn skb->len;\n\nnlmsg_failure:\nrtattr_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147588,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "tcf_fill_node(struct sk_buff *skb, struct tcf_proto *tp, unsigned long fh,\n\t      u32 pid, u32 seq, u16 flags, int event)\n{\n\tstruct tcmsg *tcm;\n\tstruct nlmsghdr  *nlh;\n\tunsigned char\t *b = skb->tail;\n\n\tnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*tcm), flags);\n\ttcm = NLMSG_DATA(nlh);\n\ttcm->tcm_family = AF_UNSPEC;\n\ttcm->tcm__pad1 = 0;\n\ttcm->tcm__pad1 = 0;\n\ttcm->tcm_ifindex = tp->q->dev->ifindex;\n\ttcm->tcm_parent = tp->classid;\n\ttcm->tcm_info = TC_H_MAKE(tp->prio, tp->protocol);\n\tRTA_PUT(skb, TCA_KIND, IFNAMSIZ, tp->ops->kind);\n\ttcm->tcm_handle = fh;\n\tif (RTM_DELTFILTER != event) {\n\t\ttcm->tcm_handle = 0;\n\t\tif (tp->ops->dump && tp->ops->dump(tp, fh, skb, tcm) < 0)\n\t\t\tgoto rtattr_failure;\n\t}\n\tnlh->nlmsg_len = skb->tail - b;\n\treturn skb->len;\n\nnlmsg_failure:\nrtattr_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147589,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int tc_fill_qdisc(struct sk_buff *skb, struct Qdisc *q, u32 clid,\n\t\t\t u32 pid, u32 seq, u16 flags, int event)\n{\n\tstruct tcmsg *tcm;\n\tstruct nlmsghdr  *nlh;\n\tunsigned char\t *b = skb->tail;\n\tstruct gnet_dump d;\n\n\tnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*tcm), flags);\n\ttcm = NLMSG_DATA(nlh);\n\ttcm->tcm_family = AF_UNSPEC;\n\ttcm->tcm_ifindex = q->dev->ifindex;\n\ttcm->tcm_parent = clid;\n\ttcm->tcm_handle = q->handle;\n\ttcm->tcm_info = atomic_read(&q->refcnt);\n\tRTA_PUT(skb, TCA_KIND, IFNAMSIZ, q->ops->id);\n\tif (q->ops->dump && q->ops->dump(q, skb) < 0)\n\t\tgoto rtattr_failure;\n\tq->qstats.qlen = q->q.qlen;\n\n\tif (gnet_stats_start_copy_compat(skb, TCA_STATS2, TCA_STATS,\n\t\t\tTCA_XSTATS, q->stats_lock, &d) < 0)\n\t\tgoto rtattr_failure;\n\n\tif (q->ops->dump_stats && q->ops->dump_stats(q, &d) < 0)\n\t\tgoto rtattr_failure;\n\n\tif (gnet_stats_copy_basic(&d, &q->bstats) < 0 ||\n#ifdef CONFIG_NET_ESTIMATOR\n\t    gnet_stats_copy_rate_est(&d, &q->rate_est) < 0 ||\n#endif\n\t    gnet_stats_copy_queue(&d, &q->qstats) < 0)\n\t\tgoto rtattr_failure;\n\t\n\tif (gnet_stats_finish_copy(&d) < 0)\n\t\tgoto rtattr_failure;\n\t\n\tnlh->nlmsg_len = skb->tail - b;\n\treturn skb->len;\n\nnlmsg_failure:\nrtattr_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147590,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int tc_fill_qdisc(struct sk_buff *skb, struct Qdisc *q, u32 clid,\n\t\t\t u32 pid, u32 seq, u16 flags, int event)\n{\n\tstruct tcmsg *tcm;\n\tstruct nlmsghdr  *nlh;\n\tunsigned char\t *b = skb->tail;\n\tstruct gnet_dump d;\n\n\tnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*tcm), flags);\n\ttcm = NLMSG_DATA(nlh);\n\ttcm->tcm_family = AF_UNSPEC;\n\ttcm->tcm__pad1 = 0;\n\ttcm->tcm__pad2 = 0;\n\ttcm->tcm_ifindex = q->dev->ifindex;\n\ttcm->tcm_parent = clid;\n\ttcm->tcm_handle = q->handle;\n\ttcm->tcm_info = atomic_read(&q->refcnt);\n\tRTA_PUT(skb, TCA_KIND, IFNAMSIZ, q->ops->id);\n\tif (q->ops->dump && q->ops->dump(q, skb) < 0)\n\t\tgoto rtattr_failure;\n\tq->qstats.qlen = q->q.qlen;\n\n\tif (gnet_stats_start_copy_compat(skb, TCA_STATS2, TCA_STATS,\n\t\t\tTCA_XSTATS, q->stats_lock, &d) < 0)\n\t\tgoto rtattr_failure;\n\n\tif (q->ops->dump_stats && q->ops->dump_stats(q, &d) < 0)\n\t\tgoto rtattr_failure;\n\n\tif (gnet_stats_copy_basic(&d, &q->bstats) < 0 ||\n#ifdef CONFIG_NET_ESTIMATOR\n\t    gnet_stats_copy_rate_est(&d, &q->rate_est) < 0 ||\n#endif\n\t    gnet_stats_copy_queue(&d, &q->qstats) < 0)\n\t\tgoto rtattr_failure;\n\t\n\tif (gnet_stats_finish_copy(&d) < 0)\n\t\tgoto rtattr_failure;\n\t\n\tnlh->nlmsg_len = skb->tail - b;\n\treturn skb->len;\n\nnlmsg_failure:\nrtattr_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147591,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int neightbl_fill_param_info(struct neigh_table *tbl,\n\t\t\t\t    struct neigh_parms *parms,\n\t\t\t\t    struct sk_buff *skb,\n\t\t\t\t    struct netlink_callback *cb)\n{\n\tstruct ndtmsg *ndtmsg;\n\tstruct nlmsghdr *nlh;\n\n\tnlh = NLMSG_NEW_ANSWER(skb, cb, RTM_NEWNEIGHTBL, sizeof(struct ndtmsg),\n\t\t\t       NLM_F_MULTI);\n\n\tndtmsg = NLMSG_DATA(nlh);\n\n\tread_lock_bh(&tbl->lock);\n\tndtmsg->ndtm_family = tbl->family;\n\tRTA_PUT_STRING(skb, NDTA_NAME, tbl->id);\n\n\tif (neightbl_fill_parms(skb, parms) < 0)\n\t\tgoto rtattr_failure;\n\n\tread_unlock_bh(&tbl->lock);\n\treturn NLMSG_END(skb, nlh);\n\nrtattr_failure:\n\tread_unlock_bh(&tbl->lock);\n\treturn NLMSG_CANCEL(skb, nlh);\n\nnlmsg_failure:\n\treturn -1;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147592,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int neightbl_fill_param_info(struct neigh_table *tbl,\n\t\t\t\t    struct neigh_parms *parms,\n\t\t\t\t    struct sk_buff *skb,\n\t\t\t\t    struct netlink_callback *cb)\n{\n\tstruct ndtmsg *ndtmsg;\n\tstruct nlmsghdr *nlh;\n\n\tnlh = NLMSG_NEW_ANSWER(skb, cb, RTM_NEWNEIGHTBL, sizeof(struct ndtmsg),\n\t\t\t       NLM_F_MULTI);\n\n\tndtmsg = NLMSG_DATA(nlh);\n\n\tread_lock_bh(&tbl->lock);\n\tndtmsg->ndtm_family = tbl->family;\n\tndtmsg->ndtm_pad1   = 0;\n\tndtmsg->ndtm_pad2   = 0;\n\tRTA_PUT_STRING(skb, NDTA_NAME, tbl->id);\n\n\tif (neightbl_fill_parms(skb, parms) < 0)\n\t\tgoto rtattr_failure;\n\n\tread_unlock_bh(&tbl->lock);\n\treturn NLMSG_END(skb, nlh);\n\nrtattr_failure:\n\tread_unlock_bh(&tbl->lock);\n\treturn NLMSG_CANCEL(skb, nlh);\n\nnlmsg_failure:\n\treturn -1;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147593,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int tca_action_flush(struct rtattr *rta, struct nlmsghdr *n, u32 pid)\n{\n\tstruct sk_buff *skb;\n\tunsigned char *b;\n\tstruct nlmsghdr *nlh;\n\tstruct tcamsg *t;\n\tstruct netlink_callback dcb;\n\tstruct rtattr *x;\n\tstruct rtattr *tb[TCA_ACT_MAX+1];\n\tstruct rtattr *kind;\n\tstruct tc_action *a = create_a(0);\n\tint err = -EINVAL;\n\n\tif (a == NULL) {\n\t\tprintk(\"tca_action_flush: couldnt create tc_action\\n\");\n\t\treturn err;\n\t}\n\n\tskb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!skb) {\n\t\tprintk(\"tca_action_flush: failed skb alloc\\n\");\n\t\tkfree(a);\n\t\treturn -ENOBUFS;\n\t}\n\n\tb = (unsigned char *)skb->tail;\n\n\tif (rtattr_parse_nested(tb, TCA_ACT_MAX, rta) < 0)\n\t\tgoto err_out;\n\n\tkind = tb[TCA_ACT_KIND-1];\n\ta->ops = tc_lookup_action(kind);\n\tif (a->ops == NULL)\n\t\tgoto err_out;\n\n\tnlh = NLMSG_PUT(skb, pid, n->nlmsg_seq, RTM_DELACTION, sizeof(*t));\n\tt = NLMSG_DATA(nlh);\n\tt->tca_family = AF_UNSPEC;\n\n\tx = (struct rtattr *) skb->tail;\n\tRTA_PUT(skb, TCA_ACT_TAB, 0, NULL);\n\n\terr = a->ops->walk(skb, &dcb, RTM_DELACTION, a);\n\tif (err < 0)\n\t\tgoto rtattr_failure;\n\n\tx->rta_len = skb->tail - (u8 *) x;\n\n\tnlh->nlmsg_len = skb->tail - b;\n\tnlh->nlmsg_flags |= NLM_F_ROOT;\n\tmodule_put(a->ops->owner);\n\tkfree(a);\n\terr = rtnetlink_send(skb, pid, RTMGRP_TC, n->nlmsg_flags&NLM_F_ECHO);\n\tif (err > 0)\n\t\treturn 0;\n\n\treturn err;\n\nrtattr_failure:\n\tmodule_put(a->ops->owner);\nnlmsg_failure:\nerr_out:\n\tkfree_skb(skb);\n\tkfree(a);\n\treturn err;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147594,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int tca_action_flush(struct rtattr *rta, struct nlmsghdr *n, u32 pid)\n{\n\tstruct sk_buff *skb;\n\tunsigned char *b;\n\tstruct nlmsghdr *nlh;\n\tstruct tcamsg *t;\n\tstruct netlink_callback dcb;\n\tstruct rtattr *x;\n\tstruct rtattr *tb[TCA_ACT_MAX+1];\n\tstruct rtattr *kind;\n\tstruct tc_action *a = create_a(0);\n\tint err = -EINVAL;\n\n\tif (a == NULL) {\n\t\tprintk(\"tca_action_flush: couldnt create tc_action\\n\");\n\t\treturn err;\n\t}\n\n\tskb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!skb) {\n\t\tprintk(\"tca_action_flush: failed skb alloc\\n\");\n\t\tkfree(a);\n\t\treturn -ENOBUFS;\n\t}\n\n\tb = (unsigned char *)skb->tail;\n\n\tif (rtattr_parse_nested(tb, TCA_ACT_MAX, rta) < 0)\n\t\tgoto err_out;\n\n\tkind = tb[TCA_ACT_KIND-1];\n\ta->ops = tc_lookup_action(kind);\n\tif (a->ops == NULL)\n\t\tgoto err_out;\n\n\tnlh = NLMSG_PUT(skb, pid, n->nlmsg_seq, RTM_DELACTION, sizeof(*t));\n\tt = NLMSG_DATA(nlh);\n\tt->tca_family = AF_UNSPEC;\n\tt->tca__pad1 = 0;\n\tt->tca__pad2 = 0;\n\n\tx = (struct rtattr *) skb->tail;\n\tRTA_PUT(skb, TCA_ACT_TAB, 0, NULL);\n\n\terr = a->ops->walk(skb, &dcb, RTM_DELACTION, a);\n\tif (err < 0)\n\t\tgoto rtattr_failure;\n\n\tx->rta_len = skb->tail - (u8 *) x;\n\n\tnlh->nlmsg_len = skb->tail - b;\n\tnlh->nlmsg_flags |= NLM_F_ROOT;\n\tmodule_put(a->ops->owner);\n\tkfree(a);\n\terr = rtnetlink_send(skb, pid, RTMGRP_TC, n->nlmsg_flags&NLM_F_ECHO);\n\tif (err > 0)\n\t\treturn 0;\n\n\treturn err;\n\nrtattr_failure:\n\tmodule_put(a->ops->owner);\nnlmsg_failure:\nerr_out:\n\tkfree_skb(skb);\n\tkfree(a);\n\treturn err;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147595,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "__rta_reserve(struct sk_buff *skb, int attrtype, int attrlen)\n{\n\tstruct rtattr *rta;\n\tint size = RTA_LENGTH(attrlen);\n\n\trta = (struct rtattr*)skb_put(skb, RTA_ALIGN(size));\n\trta->rta_type = attrtype;\n\trta->rta_len = size;\n\treturn rta;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147596,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "__rta_reserve(struct sk_buff *skb, int attrtype, int attrlen)\n{\n\tstruct rtattr *rta;\n\tint size = RTA_LENGTH(attrlen);\n\n\trta = (struct rtattr*)skb_put(skb, RTA_ALIGN(size));\n\trta->rta_type = attrtype;\n\trta->rta_len = size;\n\tmemset(RTA_DATA(rta) + attrlen, 0, RTA_ALIGN(size) - size);\n\treturn rta;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147597,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "void __rta_fill(struct sk_buff *skb, int attrtype, int attrlen, const void *data)\n{\n\tstruct rtattr *rta;\n\tint size = RTA_LENGTH(attrlen);\n\n\trta = (struct rtattr*)skb_put(skb, RTA_ALIGN(size));\n\trta->rta_type = attrtype;\n\trta->rta_len = size;\n\tmemcpy(RTA_DATA(rta), data, attrlen);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147598,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "__rta_reserve(struct sk_buff *skb, int attrtype, int attrlen)\n{\n\tstruct rtattr *rta;\n\tint size = RTA_LENGTH(attrlen);\n\n\trta = (struct rtattr*)skb_put(skb, RTA_ALIGN(size));\n\trta->rta_type = attrtype;\n\trta->rta_len = size;\n\tmemset(RTA_DATA(rta) + attrlen, 0, RTA_ALIGN(size) - size);\n\treturn rta;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147599,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "__nlmsg_put(struct sk_buff *skb, u32 pid, u32 seq, int type, int len, int flags)\n{\n\tstruct nlmsghdr *nlh;\n\tint size = NLMSG_LENGTH(len);\n\n\tnlh = (struct nlmsghdr*)skb_put(skb, NLMSG_ALIGN(size));\n\tnlh->nlmsg_type = type;\n\tnlh->nlmsg_len = size;\n\tnlh->nlmsg_flags = flags;\n\tnlh->nlmsg_pid = pid;\n\tnlh->nlmsg_seq = seq;\n\treturn nlh;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147600,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "__nlmsg_put(struct sk_buff *skb, u32 pid, u32 seq, int type, int len, int flags)\n{\n\tstruct nlmsghdr *nlh;\n\tint size = NLMSG_LENGTH(len);\n\n\tnlh = (struct nlmsghdr*)skb_put(skb, NLMSG_ALIGN(size));\n\tnlh->nlmsg_type = type;\n\tnlh->nlmsg_len = size;\n\tnlh->nlmsg_flags = flags;\n\tnlh->nlmsg_pid = pid;\n\tnlh->nlmsg_seq = seq;\n\tmemset(NLMSG_DATA(nlh) + len, 0, NLMSG_ALIGN(size) - size);\n\treturn nlh;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147601,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int tcf_fill_node(struct sk_buff *skb, struct tcf_proto *tp,\n\t\t\t unsigned long fh, u32 pid, u32 seq, u16 flags, int event)\n{\n\tstruct tcmsg *tcm;\n\tstruct nlmsghdr  *nlh;\n\tunsigned char *b = skb_tail_pointer(skb);\n\n\tnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*tcm), flags);\n\ttcm = NLMSG_DATA(nlh);\n\ttcm->tcm_family = AF_UNSPEC;\n\ttcm->tcm__pad1 = 0;\n\ttcm->tcm__pad1 = 0;\n\ttcm->tcm_ifindex = qdisc_dev(tp->q)->ifindex;\n\ttcm->tcm_parent = tp->classid;\n\ttcm->tcm_info = TC_H_MAKE(tp->prio, tp->protocol);\n\tNLA_PUT_STRING(skb, TCA_KIND, tp->ops->kind);\n\ttcm->tcm_handle = fh;\n\tif (RTM_DELTFILTER != event) {\n\t\ttcm->tcm_handle = 0;\n\t\tif (tp->ops->dump && tp->ops->dump(tp, fh, skb, tcm) < 0)\n\t\t\tgoto nla_put_failure;\n\t}\n\tnlh->nlmsg_len = skb_tail_pointer(skb) - b;\n\treturn skb->len;\n\nnlmsg_failure:\nnla_put_failure:\n\tnlmsg_trim(skb, b);\n\treturn -1;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147602,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int tcf_fill_node(struct sk_buff *skb, struct tcf_proto *tp,\n\t\t\t unsigned long fh, u32 pid, u32 seq, u16 flags, int event)\n{\n\tstruct tcmsg *tcm;\n\tstruct nlmsghdr  *nlh;\n\tunsigned char *b = skb_tail_pointer(skb);\n\n\tnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*tcm), flags);\n\ttcm = NLMSG_DATA(nlh);\n\ttcm->tcm_family = AF_UNSPEC;\n\ttcm->tcm__pad1 = 0;\n\ttcm->tcm__pad2 = 0;\n\ttcm->tcm_ifindex = qdisc_dev(tp->q)->ifindex;\n\ttcm->tcm_parent = tp->classid;\n\ttcm->tcm_info = TC_H_MAKE(tp->prio, tp->protocol);\n\tNLA_PUT_STRING(skb, TCA_KIND, tp->ops->kind);\n\ttcm->tcm_handle = fh;\n\tif (RTM_DELTFILTER != event) {\n\t\ttcm->tcm_handle = 0;\n\t\tif (tp->ops->dump && tp->ops->dump(tp, fh, skb, tcm) < 0)\n\t\t\tgoto nla_put_failure;\n\t}\n\tnlh->nlmsg_len = skb_tail_pointer(skb) - b;\n\treturn skb->len;\n\nnlmsg_failure:\nnla_put_failure:\n\tnlmsg_trim(skb, b);\n\treturn -1;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147603,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "xfs_ioc_fsgeometry_v1(\n\txfs_mount_t\t\t*mp,\n\tvoid\t\t\t__user *arg)\n{\n\txfs_fsop_geom_v1_t\tfsgeo;\n\tint\t\t\terror;\n\n\terror = xfs_fs_geometry(mp, (xfs_fsop_geom_t *)&fsgeo, 3);\n\tif (error)\n\t\treturn -error;\n\n\tif (copy_to_user(arg, &fsgeo, sizeof(fsgeo)))\n\t\treturn -XFS_ERROR(EFAULT);\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147614,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "xfs_ioc_fsgeometry(\n\txfs_mount_t\t\t*mp,\n\tvoid\t\t\t__user *arg)\n{\n\txfs_fsop_geom_t\t\tfsgeo;\n\tint\t\t\terror;\n\n\terror = xfs_fs_geometry(mp, &fsgeo, 4);\n\tif (error)\n\t\treturn -error;\n\n\tif (copy_to_user(arg, &fsgeo, sizeof(fsgeo)))\n\t\treturn -XFS_ERROR(EFAULT);\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147615,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "rfbSendServerCutText(rfbScreenInfoPtr rfbScreen,char *str, int len)\n{\n    rfbClientPtr cl;\n    rfbServerCutTextMsg sct;\n    rfbClientIteratorPtr iterator;\n\n    iterator = rfbGetClientIterator(rfbScreen);\n    while ((cl = rfbClientIteratorNext(iterator)) != NULL) {\n        sct.type = rfbServerCutText;\n        sct.length = Swap32IfLE(len);\n        if (WriteExact(cl, (char *)&sct,\n                       sz_rfbServerCutTextMsg) < 0) {\n            rfbLogPerror(\"rfbSendServerCutText: write\");\n            rfbCloseClient(cl);\n            continue;\n        }\n        if (WriteExact(cl, str, len) < 0) {\n            rfbLogPerror(\"rfbSendServerCutText: write\");\n            rfbCloseClient(cl);\n        }\n    }\n    rfbReleaseClientIterator(iterator);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147636,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "rfbSendServerCutText(rfbScreenInfoPtr rfbScreen,char *str, int len)\n{\n    rfbClientPtr cl;\n    rfbServerCutTextMsg sct;\n    rfbClientIteratorPtr iterator;\n\n    iterator = rfbGetClientIterator(rfbScreen);\n    while ((cl = rfbClientIteratorNext(iterator)) != NULL) {\n        /* Client is not authenticated, ignore. See GNOME bug 678434. */\n        if (cl->state != RFB_NORMAL)\n            continue;\n\n        sct.type = rfbServerCutText;\n        sct.length = Swap32IfLE(len);\n        if (WriteExact(cl, (char *)&sct,\n                       sz_rfbServerCutTextMsg) < 0) {\n            rfbLogPerror(\"rfbSendServerCutText: write\");\n            rfbCloseClient(cl);\n            continue;\n        }\n        if (WriteExact(cl, str, len) < 0) {\n            rfbLogPerror(\"rfbSendServerCutText: write\");\n            rfbCloseClient(cl);\n        }\n    }\n    rfbReleaseClientIterator(iterator);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147637,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "set_file_metadata (const char *origin_url, const char *referrer_url, FILE *fp)\n{\n  /* Save metadata about where the file came from (requested, final URLs) to\n   * user POSIX Extended Attributes of retrieved file.\n   *\n   * For more details about the user namespace see\n   * [http://freedesktop.org/wiki/CommonExtendedAttributes] and\n   * [http://0pointer.de/lennart/projects/mod_mime_xattr/].\n   */\n  int retval = -1;\n\n  if (!origin_url || !fp)\n    return retval;\n\n  retval = write_xattr_metadata (\"user.xdg.origin.url\", escnonprint_uri (origin_url), fp);\n  if ((!retval) && referrer_url)\n    retval = write_xattr_metadata (\"user.xdg.referrer.url\", escnonprint_uri (referrer_url), fp);\n\n  return retval;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147680,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "set_file_metadata (const struct url *origin_url, const struct url *referrer_url, FILE *fp)\n{\n  /* Save metadata about where the file came from (requested, final URLs) to\n   * user POSIX Extended Attributes of retrieved file.\n   *\n   * For more details about the user namespace see\n   * [http://freedesktop.org/wiki/CommonExtendedAttributes] and\n   * [http://0pointer.de/lennart/projects/mod_mime_xattr/].\n   */\n  int retval = -1;\n  char *value;\n\n  if (!origin_url || !fp)\n    return retval;\n\n  value = url_string (origin_url, URL_AUTH_HIDE);\n  retval = write_xattr_metadata (\"user.xdg.origin.url\", escnonprint_uri (value), fp);\n  xfree (value);\n\n  if (!retval && referrer_url)\n    {\n\t  struct url u;\n\n\t  memset(&u, 0, sizeof(u));\n      u.scheme = referrer_url->scheme;\n      u.host = referrer_url->host;\n      u.port = referrer_url->port;\n\n      value = url_string (&u, 0);\n      retval = write_xattr_metadata (\"user.xdg.referrer.url\", escnonprint_uri (value), fp);\n      xfree (value);\n    }\n\n  return retval;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147681,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "int ASN1_item_ex_d2i(ASN1_VALUE **pval, const unsigned char **in, long len,\n                     const ASN1_ITEM *it,\n                     int tag, int aclass, char opt, ASN1_TLC *ctx)\n{\n    const ASN1_TEMPLATE *tt, *errtt = NULL;\n    const ASN1_COMPAT_FUNCS *cf;\n    const ASN1_EXTERN_FUNCS *ef;\n    const ASN1_AUX *aux = it->funcs;\n    ASN1_aux_cb *asn1_cb;\n    const unsigned char *p = NULL, *q;\n    unsigned char *wp = NULL;   /* BIG FAT WARNING! BREAKS CONST WHERE USED */\n    unsigned char imphack = 0, oclass;\n    char seq_eoc, seq_nolen, cst, isopt;\n    long tmplen;\n    int i;\n    int otag;\n    int ret = 0;\n    ASN1_VALUE **pchptr, *ptmpval;\n    if (!pval)\n        return 0;\n    if (aux && aux->asn1_cb)\n        asn1_cb = aux->asn1_cb;\n    else\n        asn1_cb = 0;\n\n    switch (it->itype) {\n    case ASN1_ITYPE_PRIMITIVE:\n        if (it->templates) {\n            /*\n             * tagging or OPTIONAL is currently illegal on an item template\n             * because the flags can't get passed down. In practice this\n             * isn't a problem: we include the relevant flags from the item\n             * template in the template itself.\n             */\n            if ((tag != -1) || opt) {\n                ASN1err(ASN1_F_ASN1_ITEM_EX_D2I,\n                        ASN1_R_ILLEGAL_OPTIONS_ON_ITEM_TEMPLATE);\n                goto err;\n            }\n            return asn1_template_ex_d2i(pval, in, len,\n                                        it->templates, opt, ctx);\n        }\n        return asn1_d2i_ex_primitive(pval, in, len, it,\n                                     tag, aclass, opt, ctx);\n        break;\n\n    case ASN1_ITYPE_MSTRING:\n        p = *in;\n        /* Just read in tag and class */\n        ret = asn1_check_tlen(NULL, &otag, &oclass, NULL, NULL,\n                              &p, len, -1, 0, 1, ctx);\n        if (!ret) {\n            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);\n            goto err;\n        }\n\n        /* Must be UNIVERSAL class */\n        if (oclass != V_ASN1_UNIVERSAL) {\n            /* If OPTIONAL, assume this is OK */\n            if (opt)\n                return -1;\n            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_MSTRING_NOT_UNIVERSAL);\n            goto err;\n        }\n        /* Check tag matches bit map */\n        if (!(ASN1_tag2bit(otag) & it->utype)) {\n            /* If OPTIONAL, assume this is OK */\n            if (opt)\n                return -1;\n            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_MSTRING_WRONG_TAG);\n            goto err;\n        }\n        return asn1_d2i_ex_primitive(pval, in, len, it, otag, 0, 0, ctx);\n\n    case ASN1_ITYPE_EXTERN:\n        /* Use new style d2i */\n        ef = it->funcs;\n        return ef->asn1_ex_d2i(pval, in, len, it, tag, aclass, opt, ctx);\n\n    case ASN1_ITYPE_COMPAT:\n        /* we must resort to old style evil hackery */\n        cf = it->funcs;\n\n        /* If OPTIONAL see if it is there */\n        if (opt) {\n            int exptag;\n            p = *in;\n            if (tag == -1)\n                exptag = it->utype;\n            else\n                exptag = tag;\n            /*\n             * Don't care about anything other than presence of expected tag\n             */\n\n            ret = asn1_check_tlen(NULL, NULL, NULL, NULL, NULL,\n                                  &p, len, exptag, aclass, 1, ctx);\n            if (!ret) {\n                ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);\n                goto err;\n            }\n            if (ret == -1)\n                return -1;\n        }\n\n        /*\n         * This is the old style evil hack IMPLICIT handling: since the\n         * underlying code is expecting a tag and class other than the one\n         * present we change the buffer temporarily then change it back\n         * afterwards. This doesn't and never did work for tags > 30. Yes\n         * this is *horrible* but it is only needed for old style d2i which\n         * will hopefully not be around for much longer. FIXME: should copy\n         * the buffer then modify it so the input buffer can be const: we\n         * should *always* copy because the old style d2i might modify the\n         * buffer.\n         */\n\n        if (tag != -1) {\n            wp = *(unsigned char **)in;\n            imphack = *wp;\n            if (p == NULL) {\n                ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);\n                goto err;\n            }\n            *wp = (unsigned char)((*p & V_ASN1_CONSTRUCTED)\n                                  | it->utype);\n        }\n\n        ptmpval = cf->asn1_d2i(pval, in, len);\n\n        if (tag != -1)\n            *wp = imphack;\n\n        if (ptmpval)\n            return 1;\n\n        ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);\n        goto err;\n\n    case ASN1_ITYPE_CHOICE:\n        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it, NULL))\n            goto auxerr;\n        if (*pval) {\n            /* Free up and zero CHOICE value if initialised */\n            i = asn1_get_choice_selector(pval, it);\n            if ((i >= 0) && (i < it->tcount)) {\n                tt = it->templates + i;\n                pchptr = asn1_get_field_ptr(pval, tt);\n                ASN1_template_free(pchptr, tt);\n                asn1_set_choice_selector(pval, -1, it);\n            }\n        } else if (!ASN1_item_ex_new(pval, it)) {\n            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);\n            goto err;\n        }\n        /* CHOICE type, try each possibility in turn */\n        p = *in;\n        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {\n            pchptr = asn1_get_field_ptr(pval, tt);\n            /*\n             * We mark field as OPTIONAL so its absence can be recognised.\n             */\n            ret = asn1_template_ex_d2i(pchptr, &p, len, tt, 1, ctx);\n            /* If field not present, try the next one */\n            if (ret == -1)\n                continue;\n            /* If positive return, read OK, break loop */\n            if (ret > 0)\n                break;\n            /* Otherwise must be an ASN1 parsing error */\n            errtt = tt;\n            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);\n            goto err;\n        }\n\n        /* Did we fall off the end without reading anything? */\n        if (i == it->tcount) {\n            /* If OPTIONAL, this is OK */\n            if (opt) {\n                /* Free and zero it */\n                ASN1_item_ex_free(pval, it);\n                return -1;\n            }\n            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_NO_MATCHING_CHOICE_TYPE);\n            goto err;\n        }\n\n        asn1_set_choice_selector(pval, i, it);\n        *in = p;\n        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it, NULL))\n            goto auxerr;\n        return 1;\n\n    case ASN1_ITYPE_NDEF_SEQUENCE:\n    case ASN1_ITYPE_SEQUENCE:\n        p = *in;\n        tmplen = len;\n\n        /* If no IMPLICIT tagging set to SEQUENCE, UNIVERSAL */\n        if (tag == -1) {\n            tag = V_ASN1_SEQUENCE;\n            aclass = V_ASN1_UNIVERSAL;\n        }\n        /* Get SEQUENCE length and update len, p */\n        ret = asn1_check_tlen(&len, NULL, NULL, &seq_eoc, &cst,\n                              &p, len, tag, aclass, opt, ctx);\n        if (!ret) {\n            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);\n            goto err;\n        } else if (ret == -1)\n            return -1;\n        if (aux && (aux->flags & ASN1_AFLG_BROKEN)) {\n            len = tmplen - (p - *in);\n            seq_nolen = 1;\n        }\n        /* If indefinite we don't do a length check */\n        else\n            seq_nolen = seq_eoc;\n        if (!cst) {\n            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_SEQUENCE_NOT_CONSTRUCTED);\n            goto err;\n        }\n\n        if (!*pval && !ASN1_item_ex_new(pval, it)) {\n            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);\n            goto err;\n        }\n\n        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it, NULL))\n            goto auxerr;\n\n        /* Free up and zero any ADB found */\n        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {\n            if (tt->flags & ASN1_TFLG_ADB_MASK) {\n                const ASN1_TEMPLATE *seqtt;\n                ASN1_VALUE **pseqval;\n                seqtt = asn1_do_adb(pval, tt, 1);\n                pseqval = asn1_get_field_ptr(pval, seqtt);\n                ASN1_template_free(pseqval, seqtt);\n            }\n        }\n\n        /* Get each field entry */\n        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {\n            const ASN1_TEMPLATE *seqtt;\n            ASN1_VALUE **pseqval;\n            seqtt = asn1_do_adb(pval, tt, 1);\n            if (!seqtt)\n                goto err;\n            pseqval = asn1_get_field_ptr(pval, seqtt);\n            /* Have we ran out of data? */\n            if (!len)\n                break;\n            q = p;\n            if (asn1_check_eoc(&p, len)) {\n                if (!seq_eoc) {\n                    ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_UNEXPECTED_EOC);\n                    goto err;\n                }\n                len -= p - q;\n                seq_eoc = 0;\n                q = p;\n                break;\n            }\n            /*\n             * This determines the OPTIONAL flag value. The field cannot be\n             * omitted if it is the last of a SEQUENCE and there is still\n             * data to be read. This isn't strictly necessary but it\n             * increases efficiency in some cases.\n             */\n            if (i == (it->tcount - 1))\n                isopt = 0;\n            else\n                isopt = (char)(seqtt->flags & ASN1_TFLG_OPTIONAL);\n            /*\n             * attempt to read in field, allowing each to be OPTIONAL\n             */\n\n            ret = asn1_template_ex_d2i(pseqval, &p, len, seqtt, isopt, ctx);\n            if (!ret) {\n                errtt = seqtt;\n                goto err;\n            } else if (ret == -1) {\n                /*\n                 * OPTIONAL component absent. Free and zero the field.\n                 */\n                ASN1_template_free(pseqval, seqtt);\n                continue;\n            }\n            /* Update length */\n            len -= p - q;\n        }\n\n        /* Check for EOC if expecting one */\n        if (seq_eoc && !asn1_check_eoc(&p, len)) {\n            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_MISSING_EOC);\n            goto err;\n        }\n        /* Check all data read */\n        if (!seq_nolen && len) {\n            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_SEQUENCE_LENGTH_MISMATCH);\n            goto err;\n        }\n\n        /*\n         * If we get here we've got no more data in the SEQUENCE, however we\n         * may not have read all fields so check all remaining are OPTIONAL\n         * and clear any that are.\n         */\n        for (; i < it->tcount; tt++, i++) {\n            const ASN1_TEMPLATE *seqtt;\n            seqtt = asn1_do_adb(pval, tt, 1);\n            if (!seqtt)\n                goto err;\n            if (seqtt->flags & ASN1_TFLG_OPTIONAL) {\n                ASN1_VALUE **pseqval;\n                pseqval = asn1_get_field_ptr(pval, seqtt);\n                ASN1_template_free(pseqval, seqtt);\n            } else {\n                errtt = seqtt;\n                ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_FIELD_MISSING);\n                goto err;\n            }\n        }\n        /* Save encoding */\n        if (!asn1_enc_save(pval, *in, p - *in, it))\n            goto auxerr;\n        *in = p;\n        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it, NULL))\n            goto auxerr;\n        return 1;\n\n    default:\n        return 0;\n    }\n auxerr:\n    ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_AUX_ERROR);\n err:\n    ASN1_item_ex_free(pval, it);\n    if (errtt)\n        ERR_add_error_data(4, \"Field=\", errtt->field_name,\n                           \", Type=\", it->sname);\n    else\n        ERR_add_error_data(2, \"Type=\", it->sname);\n    return 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147719,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "int ASN1_item_ex_d2i(ASN1_VALUE **pval, const unsigned char **in, long len,\n                     const ASN1_ITEM *it,\n                     int tag, int aclass, char opt, ASN1_TLC *ctx)\n{\n    const ASN1_TEMPLATE *tt, *errtt = NULL;\n    const ASN1_COMPAT_FUNCS *cf;\n    const ASN1_EXTERN_FUNCS *ef;\n    const ASN1_AUX *aux = it->funcs;\n    ASN1_aux_cb *asn1_cb;\n    const unsigned char *p = NULL, *q;\n    unsigned char *wp = NULL;   /* BIG FAT WARNING! BREAKS CONST WHERE USED */\n    unsigned char imphack = 0, oclass;\n    char seq_eoc, seq_nolen, cst, isopt;\n    long tmplen;\n    int i;\n    int otag;\n    int ret = 0;\n    ASN1_VALUE **pchptr, *ptmpval;\n    int combine = aclass & ASN1_TFLG_COMBINE;\n    aclass &= ~ASN1_TFLG_COMBINE;\n    if (!pval)\n        return 0;\n    if (aux && aux->asn1_cb)\n        asn1_cb = aux->asn1_cb;\n    else\n        asn1_cb = 0;\n\n    switch (it->itype) {\n    case ASN1_ITYPE_PRIMITIVE:\n        if (it->templates) {\n            /*\n             * tagging or OPTIONAL is currently illegal on an item template\n             * because the flags can't get passed down. In practice this\n             * isn't a problem: we include the relevant flags from the item\n             * template in the template itself.\n             */\n            if ((tag != -1) || opt) {\n                ASN1err(ASN1_F_ASN1_ITEM_EX_D2I,\n                        ASN1_R_ILLEGAL_OPTIONS_ON_ITEM_TEMPLATE);\n                goto err;\n            }\n            return asn1_template_ex_d2i(pval, in, len,\n                                        it->templates, opt, ctx);\n        }\n        return asn1_d2i_ex_primitive(pval, in, len, it,\n                                     tag, aclass, opt, ctx);\n        break;\n\n    case ASN1_ITYPE_MSTRING:\n        p = *in;\n        /* Just read in tag and class */\n        ret = asn1_check_tlen(NULL, &otag, &oclass, NULL, NULL,\n                              &p, len, -1, 0, 1, ctx);\n        if (!ret) {\n            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);\n            goto err;\n        }\n\n        /* Must be UNIVERSAL class */\n        if (oclass != V_ASN1_UNIVERSAL) {\n            /* If OPTIONAL, assume this is OK */\n            if (opt)\n                return -1;\n            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_MSTRING_NOT_UNIVERSAL);\n            goto err;\n        }\n        /* Check tag matches bit map */\n        if (!(ASN1_tag2bit(otag) & it->utype)) {\n            /* If OPTIONAL, assume this is OK */\n            if (opt)\n                return -1;\n            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_MSTRING_WRONG_TAG);\n            goto err;\n        }\n        return asn1_d2i_ex_primitive(pval, in, len, it, otag, 0, 0, ctx);\n\n    case ASN1_ITYPE_EXTERN:\n        /* Use new style d2i */\n        ef = it->funcs;\n        return ef->asn1_ex_d2i(pval, in, len, it, tag, aclass, opt, ctx);\n\n    case ASN1_ITYPE_COMPAT:\n        /* we must resort to old style evil hackery */\n        cf = it->funcs;\n\n        /* If OPTIONAL see if it is there */\n        if (opt) {\n            int exptag;\n            p = *in;\n            if (tag == -1)\n                exptag = it->utype;\n            else\n                exptag = tag;\n            /*\n             * Don't care about anything other than presence of expected tag\n             */\n\n            ret = asn1_check_tlen(NULL, NULL, NULL, NULL, NULL,\n                                  &p, len, exptag, aclass, 1, ctx);\n            if (!ret) {\n                ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);\n                goto err;\n            }\n            if (ret == -1)\n                return -1;\n        }\n\n        /*\n         * This is the old style evil hack IMPLICIT handling: since the\n         * underlying code is expecting a tag and class other than the one\n         * present we change the buffer temporarily then change it back\n         * afterwards. This doesn't and never did work for tags > 30. Yes\n         * this is *horrible* but it is only needed for old style d2i which\n         * will hopefully not be around for much longer. FIXME: should copy\n         * the buffer then modify it so the input buffer can be const: we\n         * should *always* copy because the old style d2i might modify the\n         * buffer.\n         */\n\n        if (tag != -1) {\n            wp = *(unsigned char **)in;\n            imphack = *wp;\n            if (p == NULL) {\n                ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);\n                goto err;\n            }\n            *wp = (unsigned char)((*p & V_ASN1_CONSTRUCTED)\n                                  | it->utype);\n        }\n\n        ptmpval = cf->asn1_d2i(pval, in, len);\n\n        if (tag != -1)\n            *wp = imphack;\n\n        if (ptmpval)\n            return 1;\n\n        ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);\n        goto err;\n\n    case ASN1_ITYPE_CHOICE:\n        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it, NULL))\n            goto auxerr;\n        if (*pval) {\n            /* Free up and zero CHOICE value if initialised */\n            i = asn1_get_choice_selector(pval, it);\n            if ((i >= 0) && (i < it->tcount)) {\n                tt = it->templates + i;\n                pchptr = asn1_get_field_ptr(pval, tt);\n                ASN1_template_free(pchptr, tt);\n                asn1_set_choice_selector(pval, -1, it);\n            }\n        } else if (!ASN1_item_ex_new(pval, it)) {\n            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);\n            goto err;\n        }\n        /* CHOICE type, try each possibility in turn */\n        p = *in;\n        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {\n            pchptr = asn1_get_field_ptr(pval, tt);\n            /*\n             * We mark field as OPTIONAL so its absence can be recognised.\n             */\n            ret = asn1_template_ex_d2i(pchptr, &p, len, tt, 1, ctx);\n            /* If field not present, try the next one */\n            if (ret == -1)\n                continue;\n            /* If positive return, read OK, break loop */\n            if (ret > 0)\n                break;\n            /* Otherwise must be an ASN1 parsing error */\n            errtt = tt;\n            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);\n            goto err;\n        }\n\n        /* Did we fall off the end without reading anything? */\n        if (i == it->tcount) {\n            /* If OPTIONAL, this is OK */\n            if (opt) {\n                /* Free and zero it */\n                ASN1_item_ex_free(pval, it);\n                return -1;\n            }\n            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_NO_MATCHING_CHOICE_TYPE);\n            goto err;\n        }\n\n        asn1_set_choice_selector(pval, i, it);\n        *in = p;\n        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it, NULL))\n            goto auxerr;\n        return 1;\n\n    case ASN1_ITYPE_NDEF_SEQUENCE:\n    case ASN1_ITYPE_SEQUENCE:\n        p = *in;\n        tmplen = len;\n\n        /* If no IMPLICIT tagging set to SEQUENCE, UNIVERSAL */\n        if (tag == -1) {\n            tag = V_ASN1_SEQUENCE;\n            aclass = V_ASN1_UNIVERSAL;\n        }\n        /* Get SEQUENCE length and update len, p */\n        ret = asn1_check_tlen(&len, NULL, NULL, &seq_eoc, &cst,\n                              &p, len, tag, aclass, opt, ctx);\n        if (!ret) {\n            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);\n            goto err;\n        } else if (ret == -1)\n            return -1;\n        if (aux && (aux->flags & ASN1_AFLG_BROKEN)) {\n            len = tmplen - (p - *in);\n            seq_nolen = 1;\n        }\n        /* If indefinite we don't do a length check */\n        else\n            seq_nolen = seq_eoc;\n        if (!cst) {\n            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_SEQUENCE_NOT_CONSTRUCTED);\n            goto err;\n        }\n\n        if (!*pval && !ASN1_item_ex_new(pval, it)) {\n            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);\n            goto err;\n        }\n\n        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it, NULL))\n            goto auxerr;\n\n        /* Free up and zero any ADB found */\n        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {\n            if (tt->flags & ASN1_TFLG_ADB_MASK) {\n                const ASN1_TEMPLATE *seqtt;\n                ASN1_VALUE **pseqval;\n                seqtt = asn1_do_adb(pval, tt, 1);\n                pseqval = asn1_get_field_ptr(pval, seqtt);\n                ASN1_template_free(pseqval, seqtt);\n            }\n        }\n\n        /* Get each field entry */\n        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {\n            const ASN1_TEMPLATE *seqtt;\n            ASN1_VALUE **pseqval;\n            seqtt = asn1_do_adb(pval, tt, 1);\n            if (!seqtt)\n                goto err;\n            pseqval = asn1_get_field_ptr(pval, seqtt);\n            /* Have we ran out of data? */\n            if (!len)\n                break;\n            q = p;\n            if (asn1_check_eoc(&p, len)) {\n                if (!seq_eoc) {\n                    ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_UNEXPECTED_EOC);\n                    goto err;\n                }\n                len -= p - q;\n                seq_eoc = 0;\n                q = p;\n                break;\n            }\n            /*\n             * This determines the OPTIONAL flag value. The field cannot be\n             * omitted if it is the last of a SEQUENCE and there is still\n             * data to be read. This isn't strictly necessary but it\n             * increases efficiency in some cases.\n             */\n            if (i == (it->tcount - 1))\n                isopt = 0;\n            else\n                isopt = (char)(seqtt->flags & ASN1_TFLG_OPTIONAL);\n            /*\n             * attempt to read in field, allowing each to be OPTIONAL\n             */\n\n            ret = asn1_template_ex_d2i(pseqval, &p, len, seqtt, isopt, ctx);\n            if (!ret) {\n                errtt = seqtt;\n                goto err;\n            } else if (ret == -1) {\n                /*\n                 * OPTIONAL component absent. Free and zero the field.\n                 */\n                ASN1_template_free(pseqval, seqtt);\n                continue;\n            }\n            /* Update length */\n            len -= p - q;\n        }\n\n        /* Check for EOC if expecting one */\n        if (seq_eoc && !asn1_check_eoc(&p, len)) {\n            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_MISSING_EOC);\n            goto err;\n        }\n        /* Check all data read */\n        if (!seq_nolen && len) {\n            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_SEQUENCE_LENGTH_MISMATCH);\n            goto err;\n        }\n\n        /*\n         * If we get here we've got no more data in the SEQUENCE, however we\n         * may not have read all fields so check all remaining are OPTIONAL\n         * and clear any that are.\n         */\n        for (; i < it->tcount; tt++, i++) {\n            const ASN1_TEMPLATE *seqtt;\n            seqtt = asn1_do_adb(pval, tt, 1);\n            if (!seqtt)\n                goto err;\n            if (seqtt->flags & ASN1_TFLG_OPTIONAL) {\n                ASN1_VALUE **pseqval;\n                pseqval = asn1_get_field_ptr(pval, seqtt);\n                ASN1_template_free(pseqval, seqtt);\n            } else {\n                errtt = seqtt;\n                ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_FIELD_MISSING);\n                goto err;\n            }\n        }\n        /* Save encoding */\n        if (!asn1_enc_save(pval, *in, p - *in, it))\n            goto auxerr;\n        *in = p;\n        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it, NULL))\n            goto auxerr;\n        return 1;\n\n    default:\n        return 0;\n    }\n auxerr:\n    ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_AUX_ERROR);\n err:\n    if (combine == 0)\n        ASN1_item_ex_free(pval, it);\n    if (errtt)\n        ERR_add_error_data(4, \"Field=\", errtt->field_name,\n                           \", Type=\", it->sname);\n    else\n        ERR_add_error_data(2, \"Type=\", it->sname);\n    return 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147720,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "int BN_mod_exp_mont_consttime(BIGNUM *rr, const BIGNUM *a, const BIGNUM *p,\n                              const BIGNUM *m, BN_CTX *ctx,\n                              BN_MONT_CTX *in_mont)\n{\n    int i, bits, ret = 0, window, wvalue;\n    int top;\n    BN_MONT_CTX *mont = NULL;\n\n    int numPowers;\n    unsigned char *powerbufFree = NULL;\n    int powerbufLen = 0;\n    unsigned char *powerbuf = NULL;\n    BIGNUM tmp, am;\n#if defined(SPARC_T4_MONT)\n    unsigned int t4 = 0;\n#endif\n\n    bn_check_top(a);\n    bn_check_top(p);\n    bn_check_top(m);\n\n    if (!BN_is_odd(m)) {\n        BNerr(BN_F_BN_MOD_EXP_MONT_CONSTTIME, BN_R_CALLED_WITH_EVEN_MODULUS);\n        return (0);\n    }\n\n    top = m->top;\n\n    bits = BN_num_bits(p);\n    if (bits == 0) {\n        /* x**0 mod 1 is still zero. */\n        if (BN_is_one(m)) {\n            ret = 1;\n            BN_zero(rr);\n        } else {\n            ret = BN_one(rr);\n        }\n        return ret;\n    }\n\n    BN_CTX_start(ctx);\n\n    /*\n     * Allocate a montgomery context if it was not supplied by the caller. If\n     * this is not done, things will break in the montgomery part.\n     */\n    if (in_mont != NULL)\n        mont = in_mont;\n    else {\n        if ((mont = BN_MONT_CTX_new()) == NULL)\n            goto err;\n        if (!BN_MONT_CTX_set(mont, m, ctx))\n            goto err;\n    }\n\n#ifdef RSAZ_ENABLED\n    /*\n     * If the size of the operands allow it, perform the optimized\n     * RSAZ exponentiation. For further information see\n     * crypto/bn/rsaz_exp.c and accompanying assembly modules.\n     */\n    if ((16 == a->top) && (16 == p->top) && (BN_num_bits(m) == 1024)\n        && rsaz_avx2_eligible()) {\n        if (NULL == bn_wexpand(rr, 16))\n            goto err;\n        RSAZ_1024_mod_exp_avx2(rr->d, a->d, p->d, m->d, mont->RR.d,\n                               mont->n0[0]);\n        rr->top = 16;\n        rr->neg = 0;\n        bn_correct_top(rr);\n        ret = 1;\n        goto err;\n    } else if ((8 == a->top) && (8 == p->top) && (BN_num_bits(m) == 512)) {\n        if (NULL == bn_wexpand(rr, 8))\n            goto err;\n        RSAZ_512_mod_exp(rr->d, a->d, p->d, m->d, mont->n0[0], mont->RR.d);\n        rr->top = 8;\n        rr->neg = 0;\n        bn_correct_top(rr);\n        ret = 1;\n        goto err;\n    }\n#endif\n\n    /* Get the window size to use with size of p. */\n    window = BN_window_bits_for_ctime_exponent_size(bits);\n#if defined(SPARC_T4_MONT)\n    if (window >= 5 && (top & 15) == 0 && top <= 64 &&\n        (OPENSSL_sparcv9cap_P[1] & (CFR_MONTMUL | CFR_MONTSQR)) ==\n        (CFR_MONTMUL | CFR_MONTSQR) && (t4 = OPENSSL_sparcv9cap_P[0]))\n        window = 5;\n    else\n#endif\n#if defined(OPENSSL_BN_ASM_MONT5)\n    if (window >= 5) {\n        window = 5;             /* ~5% improvement for RSA2048 sign, and even\n                                 * for RSA4096 */\n        if ((top & 7) == 0)\n            powerbufLen += 2 * top * sizeof(m->d[0]);\n    }\n#endif\n    (void)0;\n\n    /*\n     * Allocate a buffer large enough to hold all of the pre-computed powers\n     * of am, am itself and tmp.\n     */\n    numPowers = 1 << window;\n    powerbufLen += sizeof(m->d[0]) * (top * numPowers +\n                                      ((2 * top) >\n                                       numPowers ? (2 * top) : numPowers));\n#ifdef alloca\n    if (powerbufLen < 3072)\n        powerbufFree =\n            alloca(powerbufLen + MOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH);\n    else\n#endif\n        if ((powerbufFree =\n             OPENSSL_malloc(powerbufLen + MOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH))\n            == NULL)\n        goto err;\n\n    powerbuf = MOD_EXP_CTIME_ALIGN(powerbufFree);\n    memset(powerbuf, 0, powerbufLen);\n\n#ifdef alloca\n    if (powerbufLen < 3072)\n        powerbufFree = NULL;\n#endif\n\n    /* lay down tmp and am right after powers table */\n    tmp.d = (BN_ULONG *)(powerbuf + sizeof(m->d[0]) * top * numPowers);\n    am.d = tmp.d + top;\n    tmp.top = am.top = 0;\n    tmp.dmax = am.dmax = top;\n    tmp.neg = am.neg = 0;\n    tmp.flags = am.flags = BN_FLG_STATIC_DATA;\n\n    /* prepare a^0 in Montgomery domain */\n#if 1                           /* by Shay Gueron's suggestion */\n    if (m->d[top - 1] & (((BN_ULONG)1) << (BN_BITS2 - 1))) {\n        /* 2^(top*BN_BITS2) - m */\n        tmp.d[0] = (0 - m->d[0]) & BN_MASK2;\n        for (i = 1; i < top; i++)\n            tmp.d[i] = (~m->d[i]) & BN_MASK2;\n        tmp.top = top;\n    } else\n#endif\n    if (!BN_to_montgomery(&tmp, BN_value_one(), mont, ctx))\n        goto err;\n\n    /* prepare a^1 in Montgomery domain */\n    if (a->neg || BN_ucmp(a, m) >= 0) {\n        if (!BN_mod(&am, a, m, ctx))\n            goto err;\n        if (!BN_to_montgomery(&am, &am, mont, ctx))\n            goto err;\n    } else if (!BN_to_montgomery(&am, a, mont, ctx))\n        goto err;\n\n#if defined(SPARC_T4_MONT)\n    if (t4) {\n        typedef int (*bn_pwr5_mont_f) (BN_ULONG *tp, const BN_ULONG *np,\n                                       const BN_ULONG *n0, const void *table,\n                                       int power, int bits);\n        int bn_pwr5_mont_t4_8(BN_ULONG *tp, const BN_ULONG *np,\n                              const BN_ULONG *n0, const void *table,\n                              int power, int bits);\n        int bn_pwr5_mont_t4_16(BN_ULONG *tp, const BN_ULONG *np,\n                               const BN_ULONG *n0, const void *table,\n                               int power, int bits);\n        int bn_pwr5_mont_t4_24(BN_ULONG *tp, const BN_ULONG *np,\n                               const BN_ULONG *n0, const void *table,\n                               int power, int bits);\n        int bn_pwr5_mont_t4_32(BN_ULONG *tp, const BN_ULONG *np,\n                               const BN_ULONG *n0, const void *table,\n                               int power, int bits);\n        static const bn_pwr5_mont_f pwr5_funcs[4] = {\n            bn_pwr5_mont_t4_8, bn_pwr5_mont_t4_16,\n            bn_pwr5_mont_t4_24, bn_pwr5_mont_t4_32\n        };\n        bn_pwr5_mont_f pwr5_worker = pwr5_funcs[top / 16 - 1];\n\n        typedef int (*bn_mul_mont_f) (BN_ULONG *rp, const BN_ULONG *ap,\n                                      const void *bp, const BN_ULONG *np,\n                                      const BN_ULONG *n0);\n        int bn_mul_mont_t4_8(BN_ULONG *rp, const BN_ULONG *ap, const void *bp,\n                             const BN_ULONG *np, const BN_ULONG *n0);\n        int bn_mul_mont_t4_16(BN_ULONG *rp, const BN_ULONG *ap,\n                              const void *bp, const BN_ULONG *np,\n                              const BN_ULONG *n0);\n        int bn_mul_mont_t4_24(BN_ULONG *rp, const BN_ULONG *ap,\n                              const void *bp, const BN_ULONG *np,\n                              const BN_ULONG *n0);\n        int bn_mul_mont_t4_32(BN_ULONG *rp, const BN_ULONG *ap,\n                              const void *bp, const BN_ULONG *np,\n                              const BN_ULONG *n0);\n        static const bn_mul_mont_f mul_funcs[4] = {\n            bn_mul_mont_t4_8, bn_mul_mont_t4_16,\n            bn_mul_mont_t4_24, bn_mul_mont_t4_32\n        };\n        bn_mul_mont_f mul_worker = mul_funcs[top / 16 - 1];\n\n        void bn_mul_mont_vis3(BN_ULONG *rp, const BN_ULONG *ap,\n                              const void *bp, const BN_ULONG *np,\n                              const BN_ULONG *n0, int num);\n        void bn_mul_mont_t4(BN_ULONG *rp, const BN_ULONG *ap,\n                            const void *bp, const BN_ULONG *np,\n                            const BN_ULONG *n0, int num);\n        void bn_mul_mont_gather5_t4(BN_ULONG *rp, const BN_ULONG *ap,\n                                    const void *table, const BN_ULONG *np,\n                                    const BN_ULONG *n0, int num, int power);\n        void bn_flip_n_scatter5_t4(const BN_ULONG *inp, size_t num,\n                                   void *table, size_t power);\n        void bn_gather5_t4(BN_ULONG *out, size_t num,\n                           void *table, size_t power);\n        void bn_flip_t4(BN_ULONG *dst, BN_ULONG *src, size_t num);\n\n        BN_ULONG *np = mont->N.d, *n0 = mont->n0;\n        int stride = 5 * (6 - (top / 16 - 1)); /* multiple of 5, but less\n                                                * than 32 */\n\n        /*\n         * BN_to_montgomery can contaminate words above .top [in\n         * BN_DEBUG[_DEBUG] build]...\n         */\n        for (i = am.top; i < top; i++)\n            am.d[i] = 0;\n        for (i = tmp.top; i < top; i++)\n            tmp.d[i] = 0;\n\n        bn_flip_n_scatter5_t4(tmp.d, top, powerbuf, 0);\n        bn_flip_n_scatter5_t4(am.d, top, powerbuf, 1);\n        if (!(*mul_worker) (tmp.d, am.d, am.d, np, n0) &&\n            !(*mul_worker) (tmp.d, am.d, am.d, np, n0))\n            bn_mul_mont_vis3(tmp.d, am.d, am.d, np, n0, top);\n        bn_flip_n_scatter5_t4(tmp.d, top, powerbuf, 2);\n\n        for (i = 3; i < 32; i++) {\n            /* Calculate a^i = a^(i-1) * a */\n            if (!(*mul_worker) (tmp.d, tmp.d, am.d, np, n0) &&\n                !(*mul_worker) (tmp.d, tmp.d, am.d, np, n0))\n                bn_mul_mont_vis3(tmp.d, tmp.d, am.d, np, n0, top);\n            bn_flip_n_scatter5_t4(tmp.d, top, powerbuf, i);\n        }\n\n        /* switch to 64-bit domain */\n        np = alloca(top * sizeof(BN_ULONG));\n        top /= 2;\n        bn_flip_t4(np, mont->N.d, top);\n\n        bits--;\n        for (wvalue = 0, i = bits % 5; i >= 0; i--, bits--)\n            wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);\n        bn_gather5_t4(tmp.d, top, powerbuf, wvalue);\n\n        /*\n         * Scan the exponent one window at a time starting from the most\n         * significant bits.\n         */\n        while (bits >= 0) {\n            if (bits < stride)\n                stride = bits + 1;\n            bits -= stride;\n            wvalue = bn_get_bits(p, bits + 1);\n\n            if ((*pwr5_worker) (tmp.d, np, n0, powerbuf, wvalue, stride))\n                continue;\n            /* retry once and fall back */\n            if ((*pwr5_worker) (tmp.d, np, n0, powerbuf, wvalue, stride))\n                continue;\n\n            bits += stride - 5;\n            wvalue >>= stride - 5;\n            wvalue &= 31;\n            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);\n            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);\n            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);\n            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);\n            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);\n            bn_mul_mont_gather5_t4(tmp.d, tmp.d, powerbuf, np, n0, top,\n                                   wvalue);\n        }\n\n        bn_flip_t4(tmp.d, tmp.d, top);\n        top *= 2;\n        /* back to 32-bit domain */\n        tmp.top = top;\n        bn_correct_top(&tmp);\n        OPENSSL_cleanse(np, top * sizeof(BN_ULONG));\n    } else\n#endif\n#if defined(OPENSSL_BN_ASM_MONT5)\n    if (window == 5 && top > 1) {\n        /*\n         * This optimization uses ideas from http://eprint.iacr.org/2011/239,\n         * specifically optimization of cache-timing attack countermeasures\n         * and pre-computation optimization.\n         */\n\n        /*\n         * Dedicated window==4 case improves 512-bit RSA sign by ~15%, but as\n         * 512-bit RSA is hardly relevant, we omit it to spare size...\n         */\n        void bn_mul_mont_gather5(BN_ULONG *rp, const BN_ULONG *ap,\n                                 const void *table, const BN_ULONG *np,\n                                 const BN_ULONG *n0, int num, int power);\n        void bn_scatter5(const BN_ULONG *inp, size_t num,\n                         void *table, size_t power);\n        void bn_gather5(BN_ULONG *out, size_t num, void *table, size_t power);\n        void bn_power5(BN_ULONG *rp, const BN_ULONG *ap,\n                       const void *table, const BN_ULONG *np,\n                       const BN_ULONG *n0, int num, int power);\n        int bn_get_bits5(const BN_ULONG *ap, int off);\n        int bn_from_montgomery(BN_ULONG *rp, const BN_ULONG *ap,\n                               const BN_ULONG *not_used, const BN_ULONG *np,\n                               const BN_ULONG *n0, int num);\n\n        BN_ULONG *np = mont->N.d, *n0 = mont->n0, *np2;\n\n        /*\n         * BN_to_montgomery can contaminate words above .top [in\n         * BN_DEBUG[_DEBUG] build]...\n         */\n        for (i = am.top; i < top; i++)\n            am.d[i] = 0;\n        for (i = tmp.top; i < top; i++)\n            tmp.d[i] = 0;\n\n        if (top & 7)\n            np2 = np;\n        else\n            for (np2 = am.d + top, i = 0; i < top; i++)\n                np2[2 * i] = np[i];\n\n        bn_scatter5(tmp.d, top, powerbuf, 0);\n        bn_scatter5(am.d, am.top, powerbuf, 1);\n        bn_mul_mont(tmp.d, am.d, am.d, np, n0, top);\n        bn_scatter5(tmp.d, top, powerbuf, 2);\n\n# if 0\n        for (i = 3; i < 32; i++) {\n            /* Calculate a^i = a^(i-1) * a */\n            bn_mul_mont_gather5(tmp.d, am.d, powerbuf, np2, n0, top, i - 1);\n            bn_scatter5(tmp.d, top, powerbuf, i);\n        }\n# else\n        /* same as above, but uses squaring for 1/2 of operations */\n        for (i = 4; i < 32; i *= 2) {\n            bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\n            bn_scatter5(tmp.d, top, powerbuf, i);\n        }\n        for (i = 3; i < 8; i += 2) {\n            int j;\n            bn_mul_mont_gather5(tmp.d, am.d, powerbuf, np2, n0, top, i - 1);\n            bn_scatter5(tmp.d, top, powerbuf, i);\n            for (j = 2 * i; j < 32; j *= 2) {\n                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\n                bn_scatter5(tmp.d, top, powerbuf, j);\n            }\n        }\n        for (; i < 16; i += 2) {\n            bn_mul_mont_gather5(tmp.d, am.d, powerbuf, np2, n0, top, i - 1);\n            bn_scatter5(tmp.d, top, powerbuf, i);\n            bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\n            bn_scatter5(tmp.d, top, powerbuf, 2 * i);\n        }\n        for (; i < 32; i += 2) {\n            bn_mul_mont_gather5(tmp.d, am.d, powerbuf, np2, n0, top, i - 1);\n            bn_scatter5(tmp.d, top, powerbuf, i);\n        }\n# endif\n        bits--;\n        for (wvalue = 0, i = bits % 5; i >= 0; i--, bits--)\n            wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);\n        bn_gather5(tmp.d, top, powerbuf, wvalue);\n\n        /*\n         * Scan the exponent one window at a time starting from the most\n         * significant bits.\n         */\n        if (top & 7)\n            while (bits >= 0) {\n                for (wvalue = 0, i = 0; i < 5; i++, bits--)\n                    wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);\n\n                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\n                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\n                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\n                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\n                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\n                bn_mul_mont_gather5(tmp.d, tmp.d, powerbuf, np, n0, top,\n                                    wvalue);\n        } else {\n            while (bits >= 0) {\n                wvalue = bn_get_bits5(p->d, bits - 4);\n                bits -= 5;\n                bn_power5(tmp.d, tmp.d, powerbuf, np2, n0, top, wvalue);\n            }\n        }\n\n        ret = bn_from_montgomery(tmp.d, tmp.d, NULL, np2, n0, top);\n        tmp.top = top;\n        bn_correct_top(&tmp);\n        if (ret) {\n            if (!BN_copy(rr, &tmp))\n                ret = 0;\n            goto err;           /* non-zero ret means it's not error */\n        }\n    } else\n#endif\n    {\n        if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, 0, window))\n            goto err;\n        if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&am, top, powerbuf, 1, window))\n            goto err;\n\n        /*\n         * If the window size is greater than 1, then calculate\n         * val[i=2..2^winsize-1]. Powers are computed as a*a^(i-1) (even\n         * powers could instead be computed as (a^(i/2))^2 to use the slight\n         * performance advantage of sqr over mul).\n         */\n        if (window > 1) {\n            if (!BN_mod_mul_montgomery(&tmp, &am, &am, mont, ctx))\n                goto err;\n            if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, 2,\n                                              window))\n                goto err;\n            for (i = 3; i < numPowers; i++) {\n                /* Calculate a^i = a^(i-1) * a */\n                if (!BN_mod_mul_montgomery(&tmp, &am, &tmp, mont, ctx))\n                    goto err;\n                if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, i,\n                                                  window))\n                    goto err;\n            }\n        }\n\n        bits--;\n        for (wvalue = 0, i = bits % window; i >= 0; i--, bits--)\n            wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);\n        if (!MOD_EXP_CTIME_COPY_FROM_PREBUF(&tmp, top, powerbuf, wvalue,\n                                            window))\n            goto err;\n\n        /*\n         * Scan the exponent one window at a time starting from the most\n         * significant bits.\n         */\n        while (bits >= 0) {\n            wvalue = 0;         /* The 'value' of the window */\n\n            /* Scan the window, squaring the result as we go */\n            for (i = 0; i < window; i++, bits--) {\n                if (!BN_mod_mul_montgomery(&tmp, &tmp, &tmp, mont, ctx))\n                    goto err;\n                wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);\n            }\n\n            /*\n             * Fetch the appropriate pre-computed value from the pre-buf\n             */\n            if (!MOD_EXP_CTIME_COPY_FROM_PREBUF(&am, top, powerbuf, wvalue,\n                                                window))\n                goto err;\n\n            /* Multiply the result into the intermediate result */\n            if (!BN_mod_mul_montgomery(&tmp, &tmp, &am, mont, ctx))\n                goto err;\n        }\n    }\n\n    /* Convert the final result from montgomery to standard format */\n#if defined(SPARC_T4_MONT)\n    if (OPENSSL_sparcv9cap_P[0] & (SPARCV9_VIS3 | SPARCV9_PREFER_FPU)) {\n        am.d[0] = 1;            /* borrow am */\n        for (i = 1; i < top; i++)\n            am.d[i] = 0;\n        if (!BN_mod_mul_montgomery(rr, &tmp, &am, mont, ctx))\n            goto err;\n    } else\n#endif\n    if (!BN_from_montgomery(rr, &tmp, mont, ctx))\n        goto err;\n    ret = 1;\n err:\n    if (in_mont == NULL)\n        BN_MONT_CTX_free(mont);\n    if (powerbuf != NULL) {\n        OPENSSL_cleanse(powerbuf, powerbufLen);\n        OPENSSL_free(powerbufFree);\n    }\n    BN_CTX_end(ctx);\n    return (ret);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147721,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "int BN_mod_exp_mont_consttime(BIGNUM *rr, const BIGNUM *a, const BIGNUM *p,\n                              const BIGNUM *m, BN_CTX *ctx,\n                              BN_MONT_CTX *in_mont)\n{\n    int i, bits, ret = 0, window, wvalue;\n    int top;\n    BN_MONT_CTX *mont = NULL;\n\n    int numPowers;\n    unsigned char *powerbufFree = NULL;\n    int powerbufLen = 0;\n    unsigned char *powerbuf = NULL;\n    BIGNUM tmp, am;\n#if defined(SPARC_T4_MONT)\n    unsigned int t4 = 0;\n#endif\n\n    bn_check_top(a);\n    bn_check_top(p);\n    bn_check_top(m);\n\n    if (!BN_is_odd(m)) {\n        BNerr(BN_F_BN_MOD_EXP_MONT_CONSTTIME, BN_R_CALLED_WITH_EVEN_MODULUS);\n        return (0);\n    }\n\n    top = m->top;\n\n    bits = BN_num_bits(p);\n    if (bits == 0) {\n        /* x**0 mod 1 is still zero. */\n        if (BN_is_one(m)) {\n            ret = 1;\n            BN_zero(rr);\n        } else {\n            ret = BN_one(rr);\n        }\n        return ret;\n    }\n\n    BN_CTX_start(ctx);\n\n    /*\n     * Allocate a montgomery context if it was not supplied by the caller. If\n     * this is not done, things will break in the montgomery part.\n     */\n    if (in_mont != NULL)\n        mont = in_mont;\n    else {\n        if ((mont = BN_MONT_CTX_new()) == NULL)\n            goto err;\n        if (!BN_MONT_CTX_set(mont, m, ctx))\n            goto err;\n    }\n\n#ifdef RSAZ_ENABLED\n    /*\n     * If the size of the operands allow it, perform the optimized\n     * RSAZ exponentiation. For further information see\n     * crypto/bn/rsaz_exp.c and accompanying assembly modules.\n     */\n    if ((16 == a->top) && (16 == p->top) && (BN_num_bits(m) == 1024)\n        && rsaz_avx2_eligible()) {\n        if (NULL == bn_wexpand(rr, 16))\n            goto err;\n        RSAZ_1024_mod_exp_avx2(rr->d, a->d, p->d, m->d, mont->RR.d,\n                               mont->n0[0]);\n        rr->top = 16;\n        rr->neg = 0;\n        bn_correct_top(rr);\n        ret = 1;\n        goto err;\n    } else if ((8 == a->top) && (8 == p->top) && (BN_num_bits(m) == 512)) {\n        if (NULL == bn_wexpand(rr, 8))\n            goto err;\n        RSAZ_512_mod_exp(rr->d, a->d, p->d, m->d, mont->n0[0], mont->RR.d);\n        rr->top = 8;\n        rr->neg = 0;\n        bn_correct_top(rr);\n        ret = 1;\n        goto err;\n    }\n#endif\n\n    /* Get the window size to use with size of p. */\n    window = BN_window_bits_for_ctime_exponent_size(bits);\n#if defined(SPARC_T4_MONT)\n    if (window >= 5 && (top & 15) == 0 && top <= 64 &&\n        (OPENSSL_sparcv9cap_P[1] & (CFR_MONTMUL | CFR_MONTSQR)) ==\n        (CFR_MONTMUL | CFR_MONTSQR) && (t4 = OPENSSL_sparcv9cap_P[0]))\n        window = 5;\n    else\n#endif\n#if defined(OPENSSL_BN_ASM_MONT5)\n    if (window >= 5) {\n        window = 5;             /* ~5% improvement for RSA2048 sign, and even\n                                 * for RSA4096 */\n        /* reserve space for mont->N.d[] copy */\n        powerbufLen += top * sizeof(mont->N.d[0]);\n    }\n#endif\n    (void)0;\n\n    /*\n     * Allocate a buffer large enough to hold all of the pre-computed powers\n     * of am, am itself and tmp.\n     */\n    numPowers = 1 << window;\n    powerbufLen += sizeof(m->d[0]) * (top * numPowers +\n                                      ((2 * top) >\n                                       numPowers ? (2 * top) : numPowers));\n#ifdef alloca\n    if (powerbufLen < 3072)\n        powerbufFree =\n            alloca(powerbufLen + MOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH);\n    else\n#endif\n        if ((powerbufFree =\n             OPENSSL_malloc(powerbufLen + MOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH))\n            == NULL)\n        goto err;\n\n    powerbuf = MOD_EXP_CTIME_ALIGN(powerbufFree);\n    memset(powerbuf, 0, powerbufLen);\n\n#ifdef alloca\n    if (powerbufLen < 3072)\n        powerbufFree = NULL;\n#endif\n\n    /* lay down tmp and am right after powers table */\n    tmp.d = (BN_ULONG *)(powerbuf + sizeof(m->d[0]) * top * numPowers);\n    am.d = tmp.d + top;\n    tmp.top = am.top = 0;\n    tmp.dmax = am.dmax = top;\n    tmp.neg = am.neg = 0;\n    tmp.flags = am.flags = BN_FLG_STATIC_DATA;\n\n    /* prepare a^0 in Montgomery domain */\n#if 1                           /* by Shay Gueron's suggestion */\n    if (m->d[top - 1] & (((BN_ULONG)1) << (BN_BITS2 - 1))) {\n        /* 2^(top*BN_BITS2) - m */\n        tmp.d[0] = (0 - m->d[0]) & BN_MASK2;\n        for (i = 1; i < top; i++)\n            tmp.d[i] = (~m->d[i]) & BN_MASK2;\n        tmp.top = top;\n    } else\n#endif\n    if (!BN_to_montgomery(&tmp, BN_value_one(), mont, ctx))\n        goto err;\n\n    /* prepare a^1 in Montgomery domain */\n    if (a->neg || BN_ucmp(a, m) >= 0) {\n        if (!BN_mod(&am, a, m, ctx))\n            goto err;\n        if (!BN_to_montgomery(&am, &am, mont, ctx))\n            goto err;\n    } else if (!BN_to_montgomery(&am, a, mont, ctx))\n        goto err;\n\n#if defined(SPARC_T4_MONT)\n    if (t4) {\n        typedef int (*bn_pwr5_mont_f) (BN_ULONG *tp, const BN_ULONG *np,\n                                       const BN_ULONG *n0, const void *table,\n                                       int power, int bits);\n        int bn_pwr5_mont_t4_8(BN_ULONG *tp, const BN_ULONG *np,\n                              const BN_ULONG *n0, const void *table,\n                              int power, int bits);\n        int bn_pwr5_mont_t4_16(BN_ULONG *tp, const BN_ULONG *np,\n                               const BN_ULONG *n0, const void *table,\n                               int power, int bits);\n        int bn_pwr5_mont_t4_24(BN_ULONG *tp, const BN_ULONG *np,\n                               const BN_ULONG *n0, const void *table,\n                               int power, int bits);\n        int bn_pwr5_mont_t4_32(BN_ULONG *tp, const BN_ULONG *np,\n                               const BN_ULONG *n0, const void *table,\n                               int power, int bits);\n        static const bn_pwr5_mont_f pwr5_funcs[4] = {\n            bn_pwr5_mont_t4_8, bn_pwr5_mont_t4_16,\n            bn_pwr5_mont_t4_24, bn_pwr5_mont_t4_32\n        };\n        bn_pwr5_mont_f pwr5_worker = pwr5_funcs[top / 16 - 1];\n\n        typedef int (*bn_mul_mont_f) (BN_ULONG *rp, const BN_ULONG *ap,\n                                      const void *bp, const BN_ULONG *np,\n                                      const BN_ULONG *n0);\n        int bn_mul_mont_t4_8(BN_ULONG *rp, const BN_ULONG *ap, const void *bp,\n                             const BN_ULONG *np, const BN_ULONG *n0);\n        int bn_mul_mont_t4_16(BN_ULONG *rp, const BN_ULONG *ap,\n                              const void *bp, const BN_ULONG *np,\n                              const BN_ULONG *n0);\n        int bn_mul_mont_t4_24(BN_ULONG *rp, const BN_ULONG *ap,\n                              const void *bp, const BN_ULONG *np,\n                              const BN_ULONG *n0);\n        int bn_mul_mont_t4_32(BN_ULONG *rp, const BN_ULONG *ap,\n                              const void *bp, const BN_ULONG *np,\n                              const BN_ULONG *n0);\n        static const bn_mul_mont_f mul_funcs[4] = {\n            bn_mul_mont_t4_8, bn_mul_mont_t4_16,\n            bn_mul_mont_t4_24, bn_mul_mont_t4_32\n        };\n        bn_mul_mont_f mul_worker = mul_funcs[top / 16 - 1];\n\n        void bn_mul_mont_vis3(BN_ULONG *rp, const BN_ULONG *ap,\n                              const void *bp, const BN_ULONG *np,\n                              const BN_ULONG *n0, int num);\n        void bn_mul_mont_t4(BN_ULONG *rp, const BN_ULONG *ap,\n                            const void *bp, const BN_ULONG *np,\n                            const BN_ULONG *n0, int num);\n        void bn_mul_mont_gather5_t4(BN_ULONG *rp, const BN_ULONG *ap,\n                                    const void *table, const BN_ULONG *np,\n                                    const BN_ULONG *n0, int num, int power);\n        void bn_flip_n_scatter5_t4(const BN_ULONG *inp, size_t num,\n                                   void *table, size_t power);\n        void bn_gather5_t4(BN_ULONG *out, size_t num,\n                           void *table, size_t power);\n        void bn_flip_t4(BN_ULONG *dst, BN_ULONG *src, size_t num);\n\n        BN_ULONG *np = mont->N.d, *n0 = mont->n0;\n        int stride = 5 * (6 - (top / 16 - 1)); /* multiple of 5, but less\n                                                * than 32 */\n\n        /*\n         * BN_to_montgomery can contaminate words above .top [in\n         * BN_DEBUG[_DEBUG] build]...\n         */\n        for (i = am.top; i < top; i++)\n            am.d[i] = 0;\n        for (i = tmp.top; i < top; i++)\n            tmp.d[i] = 0;\n\n        bn_flip_n_scatter5_t4(tmp.d, top, powerbuf, 0);\n        bn_flip_n_scatter5_t4(am.d, top, powerbuf, 1);\n        if (!(*mul_worker) (tmp.d, am.d, am.d, np, n0) &&\n            !(*mul_worker) (tmp.d, am.d, am.d, np, n0))\n            bn_mul_mont_vis3(tmp.d, am.d, am.d, np, n0, top);\n        bn_flip_n_scatter5_t4(tmp.d, top, powerbuf, 2);\n\n        for (i = 3; i < 32; i++) {\n            /* Calculate a^i = a^(i-1) * a */\n            if (!(*mul_worker) (tmp.d, tmp.d, am.d, np, n0) &&\n                !(*mul_worker) (tmp.d, tmp.d, am.d, np, n0))\n                bn_mul_mont_vis3(tmp.d, tmp.d, am.d, np, n0, top);\n            bn_flip_n_scatter5_t4(tmp.d, top, powerbuf, i);\n        }\n\n        /* switch to 64-bit domain */\n        np = alloca(top * sizeof(BN_ULONG));\n        top /= 2;\n        bn_flip_t4(np, mont->N.d, top);\n\n        bits--;\n        for (wvalue = 0, i = bits % 5; i >= 0; i--, bits--)\n            wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);\n        bn_gather5_t4(tmp.d, top, powerbuf, wvalue);\n\n        /*\n         * Scan the exponent one window at a time starting from the most\n         * significant bits.\n         */\n        while (bits >= 0) {\n            if (bits < stride)\n                stride = bits + 1;\n            bits -= stride;\n            wvalue = bn_get_bits(p, bits + 1);\n\n            if ((*pwr5_worker) (tmp.d, np, n0, powerbuf, wvalue, stride))\n                continue;\n            /* retry once and fall back */\n            if ((*pwr5_worker) (tmp.d, np, n0, powerbuf, wvalue, stride))\n                continue;\n\n            bits += stride - 5;\n            wvalue >>= stride - 5;\n            wvalue &= 31;\n            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);\n            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);\n            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);\n            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);\n            bn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);\n            bn_mul_mont_gather5_t4(tmp.d, tmp.d, powerbuf, np, n0, top,\n                                   wvalue);\n        }\n\n        bn_flip_t4(tmp.d, tmp.d, top);\n        top *= 2;\n        /* back to 32-bit domain */\n        tmp.top = top;\n        bn_correct_top(&tmp);\n        OPENSSL_cleanse(np, top * sizeof(BN_ULONG));\n    } else\n#endif\n#if defined(OPENSSL_BN_ASM_MONT5)\n    if (window == 5 && top > 1) {\n        /*\n         * This optimization uses ideas from http://eprint.iacr.org/2011/239,\n         * specifically optimization of cache-timing attack countermeasures\n         * and pre-computation optimization.\n         */\n\n        /*\n         * Dedicated window==4 case improves 512-bit RSA sign by ~15%, but as\n         * 512-bit RSA is hardly relevant, we omit it to spare size...\n         */\n        void bn_mul_mont_gather5(BN_ULONG *rp, const BN_ULONG *ap,\n                                 const void *table, const BN_ULONG *np,\n                                 const BN_ULONG *n0, int num, int power);\n        void bn_scatter5(const BN_ULONG *inp, size_t num,\n                         void *table, size_t power);\n        void bn_gather5(BN_ULONG *out, size_t num, void *table, size_t power);\n        void bn_power5(BN_ULONG *rp, const BN_ULONG *ap,\n                       const void *table, const BN_ULONG *np,\n                       const BN_ULONG *n0, int num, int power);\n        int bn_get_bits5(const BN_ULONG *ap, int off);\n        int bn_from_montgomery(BN_ULONG *rp, const BN_ULONG *ap,\n                               const BN_ULONG *not_used, const BN_ULONG *np,\n                               const BN_ULONG *n0, int num);\n\n        BN_ULONG *n0 = mont->n0, *np;\n\n        /*\n         * BN_to_montgomery can contaminate words above .top [in\n         * BN_DEBUG[_DEBUG] build]...\n         */\n        for (i = am.top; i < top; i++)\n            am.d[i] = 0;\n        for (i = tmp.top; i < top; i++)\n            tmp.d[i] = 0;\n\n        /*\n         * copy mont->N.d[] to improve cache locality\n         */\n        for (np = am.d + top, i = 0; i < top; i++)\n            np[i] = mont->N.d[i];\n\n        bn_scatter5(tmp.d, top, powerbuf, 0);\n        bn_scatter5(am.d, am.top, powerbuf, 1);\n        bn_mul_mont(tmp.d, am.d, am.d, np, n0, top);\n        bn_scatter5(tmp.d, top, powerbuf, 2);\n\n# if 0\n        for (i = 3; i < 32; i++) {\n            /* Calculate a^i = a^(i-1) * a */\n            bn_mul_mont_gather5(tmp.d, am.d, powerbuf, np, n0, top, i - 1);\n            bn_scatter5(tmp.d, top, powerbuf, i);\n        }\n# else\n        /* same as above, but uses squaring for 1/2 of operations */\n        for (i = 4; i < 32; i *= 2) {\n            bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\n            bn_scatter5(tmp.d, top, powerbuf, i);\n        }\n        for (i = 3; i < 8; i += 2) {\n            int j;\n            bn_mul_mont_gather5(tmp.d, am.d, powerbuf, np, n0, top, i - 1);\n            bn_scatter5(tmp.d, top, powerbuf, i);\n            for (j = 2 * i; j < 32; j *= 2) {\n                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\n                bn_scatter5(tmp.d, top, powerbuf, j);\n            }\n        }\n        for (; i < 16; i += 2) {\n            bn_mul_mont_gather5(tmp.d, am.d, powerbuf, np, n0, top, i - 1);\n            bn_scatter5(tmp.d, top, powerbuf, i);\n            bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\n            bn_scatter5(tmp.d, top, powerbuf, 2 * i);\n        }\n        for (; i < 32; i += 2) {\n            bn_mul_mont_gather5(tmp.d, am.d, powerbuf, np, n0, top, i - 1);\n            bn_scatter5(tmp.d, top, powerbuf, i);\n        }\n# endif\n        bits--;\n        for (wvalue = 0, i = bits % 5; i >= 0; i--, bits--)\n            wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);\n        bn_gather5(tmp.d, top, powerbuf, wvalue);\n\n        /*\n         * Scan the exponent one window at a time starting from the most\n         * significant bits.\n         */\n        if (top & 7)\n            while (bits >= 0) {\n                for (wvalue = 0, i = 0; i < 5; i++, bits--)\n                    wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);\n\n                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\n                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\n                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\n                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\n                bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\n                bn_mul_mont_gather5(tmp.d, tmp.d, powerbuf, np, n0, top,\n                                    wvalue);\n        } else {\n            while (bits >= 0) {\n                wvalue = bn_get_bits5(p->d, bits - 4);\n                bits -= 5;\n                bn_power5(tmp.d, tmp.d, powerbuf, np, n0, top, wvalue);\n            }\n        }\n\n        ret = bn_from_montgomery(tmp.d, tmp.d, NULL, np, n0, top);\n        tmp.top = top;\n        bn_correct_top(&tmp);\n        if (ret) {\n            if (!BN_copy(rr, &tmp))\n                ret = 0;\n            goto err;           /* non-zero ret means it's not error */\n        }\n    } else\n#endif\n    {\n        if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, 0, window))\n            goto err;\n        if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&am, top, powerbuf, 1, window))\n            goto err;\n\n        /*\n         * If the window size is greater than 1, then calculate\n         * val[i=2..2^winsize-1]. Powers are computed as a*a^(i-1) (even\n         * powers could instead be computed as (a^(i/2))^2 to use the slight\n         * performance advantage of sqr over mul).\n         */\n        if (window > 1) {\n            if (!BN_mod_mul_montgomery(&tmp, &am, &am, mont, ctx))\n                goto err;\n            if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, 2,\n                                              window))\n                goto err;\n            for (i = 3; i < numPowers; i++) {\n                /* Calculate a^i = a^(i-1) * a */\n                if (!BN_mod_mul_montgomery(&tmp, &am, &tmp, mont, ctx))\n                    goto err;\n                if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, i,\n                                                  window))\n                    goto err;\n            }\n        }\n\n        bits--;\n        for (wvalue = 0, i = bits % window; i >= 0; i--, bits--)\n            wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);\n        if (!MOD_EXP_CTIME_COPY_FROM_PREBUF(&tmp, top, powerbuf, wvalue,\n                                            window))\n            goto err;\n\n        /*\n         * Scan the exponent one window at a time starting from the most\n         * significant bits.\n         */\n        while (bits >= 0) {\n            wvalue = 0;         /* The 'value' of the window */\n\n            /* Scan the window, squaring the result as we go */\n            for (i = 0; i < window; i++, bits--) {\n                if (!BN_mod_mul_montgomery(&tmp, &tmp, &tmp, mont, ctx))\n                    goto err;\n                wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);\n            }\n\n            /*\n             * Fetch the appropriate pre-computed value from the pre-buf\n             */\n            if (!MOD_EXP_CTIME_COPY_FROM_PREBUF(&am, top, powerbuf, wvalue,\n                                                window))\n                goto err;\n\n            /* Multiply the result into the intermediate result */\n            if (!BN_mod_mul_montgomery(&tmp, &tmp, &am, mont, ctx))\n                goto err;\n        }\n    }\n\n    /* Convert the final result from montgomery to standard format */\n#if defined(SPARC_T4_MONT)\n    if (OPENSSL_sparcv9cap_P[0] & (SPARCV9_VIS3 | SPARCV9_PREFER_FPU)) {\n        am.d[0] = 1;            /* borrow am */\n        for (i = 1; i < top; i++)\n            am.d[i] = 0;\n        if (!BN_mod_mul_montgomery(rr, &tmp, &am, mont, ctx))\n            goto err;\n    } else\n#endif\n    if (!BN_from_montgomery(rr, &tmp, mont, ctx))\n        goto err;\n    ret = 1;\n err:\n    if (in_mont == NULL)\n        BN_MONT_CTX_free(mont);\n    if (powerbuf != NULL) {\n        OPENSSL_cleanse(powerbuf, powerbufLen);\n        OPENSSL_free(powerbufFree);\n    }\n    BN_CTX_end(ctx);\n    return (ret);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147722,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "  int Bind(const Node& node, int max_retry) override {\n    receiver_ = zmq_socket(context_, ZMQ_ROUTER);\n    CHECK(receiver_ != NULL)\n        << \"create receiver socket failed: \" << zmq_strerror(errno);\n    int local = GetEnv(\"DMLC_LOCAL\", 0);\n    std::string addr = local ? \"ipc:///tmp/\" : \"tcp://*:\";\n    int port = node.port;\n    unsigned seed = static_cast<unsigned>(time(NULL)+port);\n    for (int i = 0; i < max_retry+1; ++i) {\n      auto address = addr + std::to_string(port);\n      if (zmq_bind(receiver_, address.c_str()) == 0) break;\n      if (i == max_retry) {\n        port = -1;\n      } else {\n        port = 10000 + rand_r(&seed) % 40000;\n      }\n    }\n    return port;\n  }",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147856,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "  int Bind(const Node& node, int max_retry) override {\n    receiver_ = zmq_socket(context_, ZMQ_ROUTER);\n    CHECK(receiver_ != NULL)\n        << \"create receiver socket failed: \" << zmq_strerror(errno);\n    int local = GetEnv(\"DMLC_LOCAL\", 0);\n    std::string hostname = node.hostname.empty() ? \"*\" : node.hostname;\n    std::string addr = local ? \"ipc:///tmp/\" : \"tcp://\" + hostname + \":\";\n    int port = node.port;\n    unsigned seed = static_cast<unsigned>(time(NULL)+port);\n    for (int i = 0; i < max_retry+1; ++i) {\n      auto address = addr + std::to_string(port);\n      if (zmq_bind(receiver_, address.c_str()) == 0) break;\n      if (i == max_retry) {\n        port = -1;\n      } else {\n        port = 10000 + rand_r(&seed) % 40000;\n      }\n    }\n    return port;\n  }",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147857,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static struct sock *pep_sock_accept(struct sock *sk, int flags, int *errp,\n\t\t\t\t    bool kern)\n{\n\tstruct pep_sock *pn = pep_sk(sk), *newpn;\n\tstruct sock *newsk = NULL;\n\tstruct sk_buff *skb;\n\tstruct pnpipehdr *hdr;\n\tstruct sockaddr_pn dst, src;\n\tint err;\n\tu16 peer_type;\n\tu8 pipe_handle, enabled, n_sb;\n\tu8 aligned = 0;\n\n\tskb = skb_recv_datagram(sk, 0, flags & O_NONBLOCK, errp);\n\tif (!skb)\n\t\treturn NULL;\n\n\tlock_sock(sk);\n\tif (sk->sk_state != TCP_LISTEN) {\n\t\terr = -EINVAL;\n\t\tgoto drop;\n\t}\n\tsk_acceptq_removed(sk);\n\n\terr = -EPROTO;\n\tif (!pskb_may_pull(skb, sizeof(*hdr) + 4))\n\t\tgoto drop;\n\n\thdr = pnp_hdr(skb);\n\tpipe_handle = hdr->pipe_handle;\n\tswitch (hdr->state_after_connect) {\n\tcase PN_PIPE_DISABLE:\n\t\tenabled = 0;\n\t\tbreak;\n\tcase PN_PIPE_ENABLE:\n\t\tenabled = 1;\n\t\tbreak;\n\tdefault:\n\t\tpep_reject_conn(sk, skb, PN_PIPE_ERR_INVALID_PARAM,\n\t\t\t\tGFP_KERNEL);\n\t\tgoto drop;\n\t}\n\tpeer_type = hdr->other_pep_type << 8;\n\n\t/* Parse sub-blocks (options) */\n\tn_sb = hdr->data[3];\n\twhile (n_sb > 0) {\n\t\tu8 type, buf[1], len = sizeof(buf);\n\t\tconst u8 *data = pep_get_sb(skb, &type, &len, buf);\n\n\t\tif (data == NULL)\n\t\t\tgoto drop;\n\t\tswitch (type) {\n\t\tcase PN_PIPE_SB_CONNECT_REQ_PEP_SUB_TYPE:\n\t\t\tif (len < 1)\n\t\t\t\tgoto drop;\n\t\t\tpeer_type = (peer_type & 0xff00) | data[0];\n\t\t\tbreak;\n\t\tcase PN_PIPE_SB_ALIGNED_DATA:\n\t\t\taligned = data[0] != 0;\n\t\t\tbreak;\n\t\t}\n\t\tn_sb--;\n\t}\n\n\t/* Check for duplicate pipe handle */\n\tnewsk = pep_find_pipe(&pn->hlist, &dst, pipe_handle);\n\tif (unlikely(newsk)) {\n\t\t__sock_put(newsk);\n\t\tnewsk = NULL;\n\t\tpep_reject_conn(sk, skb, PN_PIPE_ERR_PEP_IN_USE, GFP_KERNEL);\n\t\tgoto drop;\n\t}\n\n\t/* Create a new to-be-accepted sock */\n\tnewsk = sk_alloc(sock_net(sk), PF_PHONET, GFP_KERNEL, sk->sk_prot,\n\t\t\t kern);\n\tif (!newsk) {\n\t\tpep_reject_conn(sk, skb, PN_PIPE_ERR_OVERLOAD, GFP_KERNEL);\n\t\terr = -ENOBUFS;\n\t\tgoto drop;\n\t}\n\n\tsock_init_data(NULL, newsk);\n\tnewsk->sk_state = TCP_SYN_RECV;\n\tnewsk->sk_backlog_rcv = pipe_do_rcv;\n\tnewsk->sk_protocol = sk->sk_protocol;\n\tnewsk->sk_destruct = pipe_destruct;\n\n\tnewpn = pep_sk(newsk);\n\tpn_skb_get_dst_sockaddr(skb, &dst);\n\tpn_skb_get_src_sockaddr(skb, &src);\n\tnewpn->pn_sk.sobject = pn_sockaddr_get_object(&dst);\n\tnewpn->pn_sk.dobject = pn_sockaddr_get_object(&src);\n\tnewpn->pn_sk.resource = pn_sockaddr_get_resource(&dst);\n\tsock_hold(sk);\n\tnewpn->listener = sk;\n\tskb_queue_head_init(&newpn->ctrlreq_queue);\n\tnewpn->pipe_handle = pipe_handle;\n\tatomic_set(&newpn->tx_credits, 0);\n\tnewpn->ifindex = 0;\n\tnewpn->peer_type = peer_type;\n\tnewpn->rx_credits = 0;\n\tnewpn->rx_fc = newpn->tx_fc = PN_LEGACY_FLOW_CONTROL;\n\tnewpn->init_enable = enabled;\n\tnewpn->aligned = aligned;\n\n\terr = pep_accept_conn(newsk, skb);\n\tif (err) {\n\t\tsock_put(newsk);\n\t\tnewsk = NULL;\n\t\tgoto drop;\n\t}\n\tsk_add_node(newsk, &pn->hlist);\ndrop:\n\trelease_sock(sk);\n\tkfree_skb(skb);\n\t*errp = err;\n\treturn newsk;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147900,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static struct sock *pep_sock_accept(struct sock *sk, int flags, int *errp,\n\t\t\t\t    bool kern)\n{\n\tstruct pep_sock *pn = pep_sk(sk), *newpn;\n\tstruct sock *newsk = NULL;\n\tstruct sk_buff *skb;\n\tstruct pnpipehdr *hdr;\n\tstruct sockaddr_pn dst, src;\n\tint err;\n\tu16 peer_type;\n\tu8 pipe_handle, enabled, n_sb;\n\tu8 aligned = 0;\n\n\tskb = skb_recv_datagram(sk, 0, flags & O_NONBLOCK, errp);\n\tif (!skb)\n\t\treturn NULL;\n\n\tlock_sock(sk);\n\tif (sk->sk_state != TCP_LISTEN) {\n\t\terr = -EINVAL;\n\t\tgoto drop;\n\t}\n\tsk_acceptq_removed(sk);\n\n\terr = -EPROTO;\n\tif (!pskb_may_pull(skb, sizeof(*hdr) + 4))\n\t\tgoto drop;\n\n\thdr = pnp_hdr(skb);\n\tpipe_handle = hdr->pipe_handle;\n\tswitch (hdr->state_after_connect) {\n\tcase PN_PIPE_DISABLE:\n\t\tenabled = 0;\n\t\tbreak;\n\tcase PN_PIPE_ENABLE:\n\t\tenabled = 1;\n\t\tbreak;\n\tdefault:\n\t\tpep_reject_conn(sk, skb, PN_PIPE_ERR_INVALID_PARAM,\n\t\t\t\tGFP_KERNEL);\n\t\tgoto drop;\n\t}\n\tpeer_type = hdr->other_pep_type << 8;\n\n\t/* Parse sub-blocks (options) */\n\tn_sb = hdr->data[3];\n\twhile (n_sb > 0) {\n\t\tu8 type, buf[1], len = sizeof(buf);\n\t\tconst u8 *data = pep_get_sb(skb, &type, &len, buf);\n\n\t\tif (data == NULL)\n\t\t\tgoto drop;\n\t\tswitch (type) {\n\t\tcase PN_PIPE_SB_CONNECT_REQ_PEP_SUB_TYPE:\n\t\t\tif (len < 1)\n\t\t\t\tgoto drop;\n\t\t\tpeer_type = (peer_type & 0xff00) | data[0];\n\t\t\tbreak;\n\t\tcase PN_PIPE_SB_ALIGNED_DATA:\n\t\t\taligned = data[0] != 0;\n\t\t\tbreak;\n\t\t}\n\t\tn_sb--;\n\t}\n\n\t/* Check for duplicate pipe handle */\n\tnewsk = pep_find_pipe(&pn->hlist, &dst, pipe_handle);\n\tif (unlikely(newsk)) {\n\t\t__sock_put(newsk);\n\t\tnewsk = NULL;\n\t\tpep_reject_conn(sk, skb, PN_PIPE_ERR_PEP_IN_USE, GFP_KERNEL);\n\t\tgoto drop;\n\t}\n\n\t/* Create a new to-be-accepted sock */\n\tnewsk = sk_alloc(sock_net(sk), PF_PHONET, GFP_KERNEL, sk->sk_prot,\n\t\t\t kern);\n\tif (!newsk) {\n\t\tpep_reject_conn(sk, skb, PN_PIPE_ERR_OVERLOAD, GFP_KERNEL);\n\t\terr = -ENOBUFS;\n\t\tgoto drop;\n\t}\n\n\tsock_init_data(NULL, newsk);\n\tnewsk->sk_state = TCP_SYN_RECV;\n\tnewsk->sk_backlog_rcv = pipe_do_rcv;\n\tnewsk->sk_protocol = sk->sk_protocol;\n\tnewsk->sk_destruct = pipe_destruct;\n\n\tnewpn = pep_sk(newsk);\n\tpn_skb_get_dst_sockaddr(skb, &dst);\n\tpn_skb_get_src_sockaddr(skb, &src);\n\tnewpn->pn_sk.sobject = pn_sockaddr_get_object(&dst);\n\tnewpn->pn_sk.dobject = pn_sockaddr_get_object(&src);\n\tnewpn->pn_sk.resource = pn_sockaddr_get_resource(&dst);\n\tsock_hold(sk);\n\tnewpn->listener = sk;\n\tskb_queue_head_init(&newpn->ctrlreq_queue);\n\tnewpn->pipe_handle = pipe_handle;\n\tatomic_set(&newpn->tx_credits, 0);\n\tnewpn->ifindex = 0;\n\tnewpn->peer_type = peer_type;\n\tnewpn->rx_credits = 0;\n\tnewpn->rx_fc = newpn->tx_fc = PN_LEGACY_FLOW_CONTROL;\n\tnewpn->init_enable = enabled;\n\tnewpn->aligned = aligned;\n\n\terr = pep_accept_conn(newsk, skb);\n\tif (err) {\n\t\t__sock_put(sk);\n\t\tsock_put(newsk);\n\t\tnewsk = NULL;\n\t\tgoto drop;\n\t}\n\tsk_add_node(newsk, &pn->hlist);\ndrop:\n\trelease_sock(sk);\n\tkfree_skb(skb);\n\t*errp = err;\n\treturn newsk;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147901,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "main(int argc, char **argv)\n{\n\tconst char *safepath = \"/bin:/sbin:/usr/bin:/usr/sbin:\"\n\t    \"/usr/local/bin:/usr/local/sbin\";\n\tconst char *confpath = NULL;\n\tchar *shargv[] = { NULL, NULL };\n\tchar *sh;\n\tconst char *p;\n\tconst char *cmd;\n\tchar cmdline[LINE_MAX];\n\tstruct passwd mypwstore, targpwstore;\n\tstruct passwd *mypw, *targpw;\n\tconst struct rule *rule;\n\tuid_t uid;\n\tuid_t target = 0;\n\tgid_t groups[NGROUPS_MAX + 1];\n\tint ngroups;\n\tint i, ch, rv;\n\tint sflag = 0;\n\tint nflag = 0;\n\tchar cwdpath[PATH_MAX];\n\tconst char *cwd;\n\tchar **envp;\n\n\tsetprogname(\"doas\");\n\n\tclosefrom(STDERR_FILENO + 1);\n\n\tuid = getuid();\n\n\twhile ((ch = getopt(argc, argv, \"+C:Lnsu:\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'C':\n\t\t\tconfpath = optarg;\n\t\t\tbreak;\n\t\tcase 'L':\n#if defined(USE_TIMESTAMP)\n\t\t\texit(timestamp_clear() == -1);\n#else\n\t\t\texit(0);\n#endif\n\t\tcase 'u':\n\t\t\tif (parseuid(optarg, &target) != 0)\n\t\t\t\terrx(1, \"unknown user\");\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tnflag = 1;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tsflag = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t\tbreak;\n\t\t}\n\t}\n\targv += optind;\n\targc -= optind;\n\n\tif (confpath) {\n\t\tif (sflag)\n\t\t\tusage();\n\t} else if ((!sflag && !argc) || (sflag && argc))\n\t\tusage();\n\n\trv = mygetpwuid_r(uid, &mypwstore, &mypw);\n\tif (rv != 0)\n\t\terr(1, \"getpwuid_r failed\");\n\tif (mypw == NULL)\n\t\terrx(1, \"no passwd entry for self\");\n\tngroups = getgroups(NGROUPS_MAX, groups);\n\tif (ngroups == -1)\n\t\terr(1, \"can't get groups\");\n\tgroups[ngroups++] = getgid();\n\n\tif (sflag) {\n\t\tsh = getenv(\"SHELL\");\n\t\tif (sh == NULL || *sh == '\\0') {\n\t\t\tshargv[0] = mypw->pw_shell;\n\t\t} else\n\t\t\tshargv[0] = sh;\n\t\targv = shargv;\n\t\targc = 1;\n\t}\n\n\tif (confpath) {\n\t\tcheckconfig(confpath, argc, argv, uid, groups, ngroups,\n\t\t    target);\n\t\texit(1);\t/* fail safe */\n\t}\n\n\tif (geteuid())\n\t\terrx(1, \"not installed setuid\");\n\n\tparseconfig(DOAS_CONF, 1);\n\n\t/* cmdline is used only for logging, no need to abort on truncate */\n\t(void)strlcpy(cmdline, argv[0], sizeof(cmdline));\n\tfor (i = 1; i < argc; i++) {\n\t\tif (strlcat(cmdline, \" \", sizeof(cmdline)) >= sizeof(cmdline))\n\t\t\tbreak;\n\t\tif (strlcat(cmdline, argv[i], sizeof(cmdline)) >= sizeof(cmdline))\n\t\t\tbreak;\n\t}\n\n\tcmd = argv[0];\n\tif (!permit(uid, groups, ngroups, &rule, target, cmd,\n\t    (const char **)argv + 1)) {\n\t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n\t\t    \"command not permitted for %s: %s\", mypw->pw_name, cmdline);\n\t\terrc(1, EPERM, NULL);\n\t}\n\n#if defined(USE_SHADOW)\n\tif (!(rule->options & NOPASS)) {\n\t\tif (nflag)\n\t\t\terrx(1, \"Authorization required\");\n\n\t\tshadowauth(mypw->pw_name, rule->options & PERSIST);\n\t}\n#elif !defined(USE_PAM)\n\t/* no authentication provider, only allow NOPASS rules */\n\t(void) nflag;\n\tif (!(rule->options & NOPASS))\n\t\terrx(1, \"Authorization required\");\n#endif\n\n\tif ((p = getenv(\"PATH\")) != NULL)\n\t\tformerpath = strdup(p);\n\tif (formerpath == NULL)\n\t\tformerpath = \"\";\n\n\tif (rule->cmd) {\n\t\tif (setenv(\"PATH\", safepath, 1) == -1)\n\t\t\terr(1, \"failed to set PATH '%s'\", safepath);\n\t}\n\n\trv = mygetpwuid_r(target, &targpwstore, &targpw);\n\tif (rv != 0)\n\t\terr(1, \"getpwuid_r failed\");\n\tif (targpw == NULL)\n\t\terrx(1, \"no passwd entry for target\");\n\n#if defined(USE_PAM)\n\tpamauth(targpw->pw_name, mypw->pw_name, !nflag, rule->options & NOPASS,\n\t    rule->options & PERSIST);\n#endif\n\n#ifdef HAVE_LOGIN_CAP_H\n\tif (setusercontext(NULL, targpw, target, LOGIN_SETGROUP |\n\t    LOGIN_SETPRIORITY | LOGIN_SETRESOURCES | LOGIN_SETUMASK |\n\t    LOGIN_SETUSER) != 0)\n\t\terrx(1, \"failed to set user context for target\");\n#else\n\tif (setresgid(targpw->pw_gid, targpw->pw_gid, targpw->pw_gid) != 0)\n\t\terr(1, \"setresgid\");\n\tif (initgroups(targpw->pw_name, targpw->pw_gid) != 0)\n\t\terr(1, \"initgroups\");\n\tif (setresuid(target, target, target) != 0)\n\t\terr(1, \"setresuid\");\n#endif\n\n\tif (getcwd(cwdpath, sizeof(cwdpath)) == NULL)\n\t\tcwd = \"(failed)\";\n\telse\n\t\tcwd = cwdpath;\n\n\tif (!(rule->options & NOLOG)) {\n\t\tsyslog(LOG_AUTHPRIV | LOG_INFO,\n\t\t    \"%s ran command %s as %s from %s\",\n\t\t    mypw->pw_name, cmdline, targpw->pw_name, cwd);\n\t}\n\n\tenvp = prepenv(rule, mypw, targpw);\n\n\t/* setusercontext set path for the next process, so reset it for us */\n\tif (rule->cmd) {\n\t\tif (setenv(\"PATH\", safepath, 1) == -1)\n\t\t\terr(1, \"failed to set PATH '%s'\", safepath);\n\t} else {\n\t\tif (setenv(\"PATH\", formerpath, 1) == -1)\n\t\t\terr(1, \"failed to set PATH '%s'\", formerpath);\n\t}\n\texecvpe(cmd, argv, envp);\n\tif (errno == ENOENT)\n\t\terrx(1, \"%s: command not found\", cmd);\n\terr(1, \"%s\", cmd);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147964,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "main(int argc, char **argv)\n{\n\tconst char *safepath = \"/bin:/sbin:/usr/bin:/usr/sbin:\"\n\t    \"/usr/local/bin:/usr/local/sbin\";\n\tconst char *confpath = NULL;\n\tchar *shargv[] = { NULL, NULL };\n\tchar *sh;\n\tconst char *p;\n\tconst char *cmd;\n\tchar cmdline[LINE_MAX];\n\tstruct passwd mypwstore, targpwstore;\n\tstruct passwd *mypw, *targpw;\n\tconst struct rule *rule;\n\tuid_t uid;\n\tuid_t target = 0;\n\tgid_t groups[NGROUPS_MAX + 1];\n\tint ngroups;\n\tint i, ch, rv;\n\tint sflag = 0;\n\tint nflag = 0;\n\tchar cwdpath[PATH_MAX];\n\tconst char *cwd;\n\tchar **envp;\n\n\tsetprogname(\"doas\");\n\n\tclosefrom(STDERR_FILENO + 1);\n\n\tuid = getuid();\n\n\twhile ((ch = getopt(argc, argv, \"+C:Lnsu:\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'C':\n\t\t\tconfpath = optarg;\n\t\t\tbreak;\n\t\tcase 'L':\n#if defined(USE_TIMESTAMP)\n\t\t\texit(timestamp_clear() == -1);\n#else\n\t\t\texit(0);\n#endif\n\t\tcase 'u':\n\t\t\tif (parseuid(optarg, &target) != 0)\n\t\t\t\terrx(1, \"unknown user\");\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tnflag = 1;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tsflag = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t\tbreak;\n\t\t}\n\t}\n\targv += optind;\n\targc -= optind;\n\n\tif (confpath) {\n\t\tif (sflag)\n\t\t\tusage();\n\t} else if ((!sflag && !argc) || (sflag && argc))\n\t\tusage();\n\n\trv = mygetpwuid_r(uid, &mypwstore, &mypw);\n\tif (rv != 0)\n\t\terr(1, \"getpwuid_r failed\");\n\tif (mypw == NULL)\n\t\terrx(1, \"no passwd entry for self\");\n\tngroups = getgroups(NGROUPS_MAX, groups);\n\tif (ngroups == -1)\n\t\terr(1, \"can't get groups\");\n\tgroups[ngroups++] = getgid();\n\n\tif (sflag) {\n\t\tsh = getenv(\"SHELL\");\n\t\tif (sh == NULL || *sh == '\\0') {\n\t\t\tshargv[0] = mypw->pw_shell;\n\t\t} else\n\t\t\tshargv[0] = sh;\n\t\targv = shargv;\n\t\targc = 1;\n\t}\n\n\tif (confpath) {\n\t\tcheckconfig(confpath, argc, argv, uid, groups, ngroups,\n\t\t    target);\n\t\texit(1);\t/* fail safe */\n\t}\n\n\tif (geteuid())\n\t\terrx(1, \"not installed setuid\");\n\n\tparseconfig(DOAS_CONF, 1);\n\n\t/* cmdline is used only for logging, no need to abort on truncate */\n\t(void)strlcpy(cmdline, argv[0], sizeof(cmdline));\n\tfor (i = 1; i < argc; i++) {\n\t\tif (strlcat(cmdline, \" \", sizeof(cmdline)) >= sizeof(cmdline))\n\t\t\tbreak;\n\t\tif (strlcat(cmdline, argv[i], sizeof(cmdline)) >= sizeof(cmdline))\n\t\t\tbreak;\n\t}\n\n\tcmd = argv[0];\n\tif (!permit(uid, groups, ngroups, &rule, target, cmd,\n\t    (const char **)argv + 1)) {\n\t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n\t\t    \"command not permitted for %s: %s\", mypw->pw_name, cmdline);\n\t\terrc(1, EPERM, NULL);\n\t}\n\n#if defined(USE_SHADOW)\n\tif (!(rule->options & NOPASS)) {\n\t\tif (nflag)\n\t\t\terrx(1, \"Authorization required\");\n\n\t\tshadowauth(mypw->pw_name, rule->options & PERSIST);\n\t}\n#elif !defined(USE_PAM)\n\t/* no authentication provider, only allow NOPASS rules */\n\t(void) nflag;\n\tif (!(rule->options & NOPASS))\n\t\terrx(1, \"Authorization required\");\n#endif\n\n\tif ((p = getenv(\"PATH\")) != NULL)\n\t\tformerpath = strdup(p);\n\tif (formerpath == NULL)\n\t\tformerpath = \"\";\n\n\tif (rule->cmd) {\n\t\tif (setenv(\"PATH\", safepath, 1) == -1)\n\t\t\terr(1, \"failed to set PATH '%s'\", safepath);\n\t}\n\n\trv = mygetpwuid_r(target, &targpwstore, &targpw);\n\tif (rv != 0)\n\t\terr(1, \"getpwuid_r failed\");\n\tif (targpw == NULL)\n\t\terrx(1, \"no passwd entry for target\");\n\n#if defined(USE_PAM)\n\tpamauth(targpw->pw_name, mypw->pw_name, !nflag, rule->options & NOPASS,\n\t    rule->options & PERSIST);\n#endif\n\n#ifdef HAVE_LOGIN_CAP_H\n\tif (setusercontext(NULL, targpw, target, LOGIN_SETGROUP |\n\t    LOGIN_SETPATH |\n\t    LOGIN_SETPRIORITY | LOGIN_SETRESOURCES | LOGIN_SETUMASK |\n\t    LOGIN_SETUSER) != 0)\n\t\terrx(1, \"failed to set user context for target\");\n#else\n\tif (setresgid(targpw->pw_gid, targpw->pw_gid, targpw->pw_gid) != 0)\n\t\terr(1, \"setresgid\");\n\tif (initgroups(targpw->pw_name, targpw->pw_gid) != 0)\n\t\terr(1, \"initgroups\");\n\tif (setresuid(target, target, target) != 0)\n\t\terr(1, \"setresuid\");\n\tif (setenv(\"PATH\", safepath, 1) == -1)\n\t\terr(1, \"failed to set PATH '%s'\", safepath);\n#endif\n\n\tif (getcwd(cwdpath, sizeof(cwdpath)) == NULL)\n\t\tcwd = \"(failed)\";\n\telse\n\t\tcwd = cwdpath;\n\n\tif (!(rule->options & NOLOG)) {\n\t\tsyslog(LOG_AUTHPRIV | LOG_INFO,\n\t\t    \"%s ran command %s as %s from %s\",\n\t\t    mypw->pw_name, cmdline, targpw->pw_name, cwd);\n\t}\n\n\tenvp = prepenv(rule, mypw, targpw);\n\n\t/* setusercontext set path for the next process, so reset it for us */\n\tif (rule->cmd) {\n\t\tif (setenv(\"PATH\", safepath, 1) == -1)\n\t\t\terr(1, \"failed to set PATH '%s'\", safepath);\n\t} else {\n\t\tif (setenv(\"PATH\", formerpath, 1) == -1)\n\t\t\terr(1, \"failed to set PATH '%s'\", formerpath);\n\t}\n\texecvpe(cmd, argv, envp);\n\tif (errno == ENOENT)\n\t\terrx(1, \"%s: command not found\", cmd);\n\terr(1, \"%s\", cmd);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147965,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "void *UntrustedCacheMalloc::GetBuffer() {\n  void **buffers = nullptr;\n  void *buffer;\n  bool is_pool_empty;\n\n  {\n    LockGuard spin_lock(&lock_);\n    is_pool_empty = buffer_pool_.empty();\n    if (is_pool_empty) {\n      buffers =\n          primitives::AllocateUntrustedBuffers(kPoolIncrement, kPoolEntrySize);\n      for (int i = 0; i < kPoolIncrement; i++) {\n        if (!buffers[i] ||\n            !TrustedPrimitives::IsOutsideEnclave(buffers[i], kPoolEntrySize)) {\n          abort();\n        }\n        buffer_pool_.push(buffers[i]);\n      }\n    }\n    buffer = buffer_pool_.top();\n    buffer_pool_.pop();\n    busy_buffers_.insert(buffer);\n  }\n\n  if (is_pool_empty) {\n    // Free memory held by the array of buffer pointers returned by\n    // AllocateUntrustedBuffers.\n    Free(buffers);\n  }\n  return buffer;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148076,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "void *UntrustedCacheMalloc::GetBuffer() {\n  void **buffers = nullptr;\n  void *buffer;\n  bool is_pool_empty;\n\n  {\n    LockGuard spin_lock(&lock_);\n    is_pool_empty = buffer_pool_.empty();\n    if (is_pool_empty) {\n      buffers =\n          primitives::AllocateUntrustedBuffers(kPoolIncrement, kPoolEntrySize);\n      for (int i = 0; i < kPoolIncrement; i++) {\n        void *buf = buffers[i];\n        if (!buf || !TrustedPrimitives::IsOutsideEnclave(buf, kPoolEntrySize)) {\n          TrustedPrimitives::BestEffortAbort(\n              \"Cached buffer is not outside the enclave\");\n        }\n        buffer_pool_.push(buf);\n      }\n    }\n    buffer = buffer_pool_.top();\n    buffer_pool_.pop();\n    busy_buffers_.insert(buffer);\n  }\n\n  if (is_pool_empty) {\n    // Free memory held by the array of buffer pointers returned by\n    // AllocateUntrustedBuffers.\n    Free(buffers);\n  }\n  return buffer;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148077,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "\tPong(const std::string& cookie, const std::string& server = \"\")\n\t\t: ClientProtocol::Message(\"PONG\", ServerInstance->Config->GetServerName())\n\t{\n\t\tPushParamRef(ServerInstance->Config->GetServerName());\n\t\tif (!server.empty())\n\t\t\tPushParamRef(server);\n\t\tPushParamRef(cookie);\n\t}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148140,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "\tPong(const std::string& cookie, const std::string& server = \"\")\n\t\t: ClientProtocol::Message(\"PONG\", ServerInstance->Config->GetServerName())\n\t{\n\t\tif (server.empty())\n\t\t\tPushParamRef(ServerInstance->Config->GetServerName());\n\t\telse\n\t\t\tPushParam(server);\n\t\tPushParamRef(cookie);\n\t}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148141,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "file_continue(i_ctx_t *i_ctx_p)\n{\n    os_ptr op = osp;\n    es_ptr pscratch = esp - 2;\n    file_enum *pfen = r_ptr(esp - 1, file_enum);\n    int devlen = esp[-3].value.intval;\n    gx_io_device *iodev = r_ptr(esp - 4, gx_io_device);\n    uint len = r_size(pscratch);\n    uint code;\n\n    if (len < devlen)\n        return_error(gs_error_rangecheck);     /* not even room for device len */\n    memcpy((char *)pscratch->value.bytes, iodev->dname, devlen);\n    code = iodev->procs.enumerate_next(pfen, (char *)pscratch->value.bytes + devlen,\n                len - devlen);\n    if (code == ~(uint) 0) {    /* all done */\n        esp -= 5;               /* pop proc, pfen, devlen, iodev , mark */\n        return o_pop_estack;\n    } else if (code > len)      /* overran string */\n        return_error(gs_error_rangecheck);\n    else {\n        push(1);\n        ref_assign(op, pscratch);\n        r_set_size(op, code + devlen);\n        push_op_estack(file_continue);  /* come again */\n        *++esp = pscratch[2];   /* proc */\n        return o_push_estack;\n    }\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148162,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "file_continue(i_ctx_t *i_ctx_p)\n{\n    os_ptr op = osp;\n    es_ptr pscratch = esp - 2;\n    file_enum *pfen = r_ptr(esp - 1, file_enum);\n    int devlen = esp[-3].value.intval;\n    gx_io_device *iodev = r_ptr(esp - 4, gx_io_device);\n    uint len = r_size(pscratch);\n    uint code;\n\n    if (len < devlen)\n        return_error(gs_error_rangecheck);     /* not even room for device len */\n\n    do {\n        memcpy((char *)pscratch->value.bytes, iodev->dname, devlen);\n        code = iodev->procs.enumerate_next(pfen, (char *)pscratch->value.bytes + devlen,\n                    len - devlen);\n        if (code == ~(uint) 0) {    /* all done */\n            esp -= 5;               /* pop proc, pfen, devlen, iodev , mark */\n            return o_pop_estack;\n        } else if (code > len)      /* overran string */\n            return_error(gs_error_rangecheck);\n        else if (iodev != iodev_default(imemory)\n              || (check_file_permissions_reduced(i_ctx_p, (char *)pscratch->value.bytes, code + devlen, \"PermitFileReading\")) == 0) {\n            push(1);\n            ref_assign(op, pscratch);\n            r_set_size(op, code + devlen);\n            push_op_estack(file_continue);  /* come again */\n            *++esp = pscratch[2];   /* proc */\n            return o_push_estack;\n        }\n    } while(1);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148163,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "xmlDocPtr soap_xmlParseFile(const char *filename TSRMLS_DC)\n{\n\txmlParserCtxtPtr ctxt = NULL;\n\txmlDocPtr ret;\n\tzend_bool old_allow_url_fopen;\n\n/*\n\txmlInitParser();\n*/\n\n\told_allow_url_fopen = PG(allow_url_fopen);\n\tPG(allow_url_fopen) = 1;\n\tctxt = xmlCreateFileParserCtxt(filename);\n\tPG(allow_url_fopen) = old_allow_url_fopen;\n\tif (ctxt) {\n\t\tzend_bool old;\n\n\t\tctxt->keepBlanks = 0;\n\t\tctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;\n\t\tctxt->sax->comment = soap_Comment;\n\t\tctxt->sax->warning = NULL;\n\t\tctxt->sax->error = NULL;\n\t\t/*ctxt->sax->fatalError = NULL;*/\n\t\told = php_libxml_disable_entity_loader(1);\n\t\txmlParseDocument(ctxt);\n\t\tphp_libxml_disable_entity_loader(old);\n\t\tif (ctxt->wellFormed) {\n\t\t\tret = ctxt->myDoc;\n\t\t\tif (ret->URL == NULL && ctxt->directory != NULL) {\n\t\t\t\tret->URL = xmlCharStrdup(ctxt->directory);\n\t\t\t}\n\t\t} else {\n\t\t\tret = NULL;\n\t\t\txmlFreeDoc(ctxt->myDoc);\n\t\t\tctxt->myDoc = NULL;\n\t\t}\n\t\txmlFreeParserCtxt(ctxt);\n\t} else {\n\t\tret = NULL;\n\t}\n\n/*\n\txmlCleanupParser();\n*/\n\n\tif (ret) {\n\t\tcleanup_xml_node((xmlNodePtr)ret);\n\t}\n\treturn ret;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148178,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "xmlDocPtr soap_xmlParseFile(const char *filename TSRMLS_DC)\n{\n\txmlParserCtxtPtr ctxt = NULL;\n\txmlDocPtr ret;\n\tzend_bool old_allow_url_fopen;\n\n/*\n\txmlInitParser();\n*/\n\n\told_allow_url_fopen = PG(allow_url_fopen);\n\tPG(allow_url_fopen) = 1;\n\tctxt = xmlCreateFileParserCtxt(filename);\n\tPG(allow_url_fopen) = old_allow_url_fopen;\n\tif (ctxt) {\n\t\tzend_bool old;\n\n\t\tctxt->keepBlanks = 0;\n\t\tctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;\n\t\tctxt->sax->comment = soap_Comment;\n\t\tctxt->sax->warning = NULL;\n\t\tctxt->sax->error = NULL;\n\t\t/*ctxt->sax->fatalError = NULL;*/\n\t\told = php_libxml_disable_entity_loader(1 TSRMLS_CC);\n\t\txmlParseDocument(ctxt);\n\t\tphp_libxml_disable_entity_loader(old TSRMLS_CC);\n\t\tif (ctxt->wellFormed) {\n\t\t\tret = ctxt->myDoc;\n\t\t\tif (ret->URL == NULL && ctxt->directory != NULL) {\n\t\t\t\tret->URL = xmlCharStrdup(ctxt->directory);\n\t\t\t}\n\t\t} else {\n\t\t\tret = NULL;\n\t\t\txmlFreeDoc(ctxt->myDoc);\n\t\t\tctxt->myDoc = NULL;\n\t\t}\n\t\txmlFreeParserCtxt(ctxt);\n\t} else {\n\t\tret = NULL;\n\t}\n\n/*\n\txmlCleanupParser();\n*/\n\n\tif (ret) {\n\t\tcleanup_xml_node((xmlNodePtr)ret);\n\t}\n\treturn ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148179,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "xmlDocPtr soap_xmlParseMemory(const void *buf, size_t buf_size)\n{\n\txmlParserCtxtPtr ctxt = NULL;\n\txmlDocPtr ret;\n\n/*\n\txmlInitParser();\n*/\n\tctxt = xmlCreateMemoryParserCtxt(buf, buf_size);\n\tif (ctxt) {\n\t\tzend_bool old;\n\n\t\tctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;\n\t\tctxt->sax->comment = soap_Comment;\n\t\tctxt->sax->warning = NULL;\n\t\tctxt->sax->error = NULL;\n\t\t/*ctxt->sax->fatalError = NULL;*/\n#if LIBXML_VERSION >= 20703\n\t\tctxt->options |= XML_PARSE_HUGE;\n#endif\n\t\told = php_libxml_disable_entity_loader(1);\n\t\txmlParseDocument(ctxt);\n\t\tphp_libxml_disable_entity_loader(old);\n\t\tif (ctxt->wellFormed) {\n\t\t\tret = ctxt->myDoc;\n\t\t\tif (ret->URL == NULL && ctxt->directory != NULL) {\n\t\t\t\tret->URL = xmlCharStrdup(ctxt->directory);\n\t\t\t}\n\t\t} else {\n\t\t\tret = NULL;\n\t\t\txmlFreeDoc(ctxt->myDoc);\n\t\t\tctxt->myDoc = NULL;\n\t\t}\n\t\txmlFreeParserCtxt(ctxt);\n\t} else {\n\t\tret = NULL;\n\t}\n\n/*\n\txmlCleanupParser();\n*/\n\n/*\n\tif (ret) {\n\t\tcleanup_xml_node((xmlNodePtr)ret);\n\t}\n*/\n\treturn ret;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148180,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "xmlDocPtr soap_xmlParseMemory(const void *buf, size_t buf_size)\n{\n\txmlParserCtxtPtr ctxt = NULL;\n\txmlDocPtr ret;\n\n\tTSRMLS_FETCH();\n\n/*\n\txmlInitParser();\n*/\n\tctxt = xmlCreateMemoryParserCtxt(buf, buf_size);\n\tif (ctxt) {\n\t\tzend_bool old;\n\n\t\tctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;\n\t\tctxt->sax->comment = soap_Comment;\n\t\tctxt->sax->warning = NULL;\n\t\tctxt->sax->error = NULL;\n\t\t/*ctxt->sax->fatalError = NULL;*/\n#if LIBXML_VERSION >= 20703\n\t\tctxt->options |= XML_PARSE_HUGE;\n#endif\n\t\told = php_libxml_disable_entity_loader(1 TSRMLS_CC);\n\t\txmlParseDocument(ctxt);\n\t\tphp_libxml_disable_entity_loader(old TSRMLS_CC);\n\t\tif (ctxt->wellFormed) {\n\t\t\tret = ctxt->myDoc;\n\t\t\tif (ret->URL == NULL && ctxt->directory != NULL) {\n\t\t\t\tret->URL = xmlCharStrdup(ctxt->directory);\n\t\t\t}\n\t\t} else {\n\t\t\tret = NULL;\n\t\t\txmlFreeDoc(ctxt->myDoc);\n\t\t\tctxt->myDoc = NULL;\n\t\t}\n\t\txmlFreeParserCtxt(ctxt);\n\t} else {\n\t\tret = NULL;\n\t}\n\n/*\n\txmlCleanupParser();\n*/\n\n/*\n\tif (ret) {\n\t\tcleanup_xml_node((xmlNodePtr)ret);\n\t}\n*/\n\treturn ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148181,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "ares_parse_naptr_reply (const unsigned char *abuf, int alen,\n                        struct ares_naptr_reply **naptr_out)\n{\n  unsigned int qdcount, ancount, i;\n  const unsigned char *aptr, *vptr;\n  int status, rr_type, rr_class, rr_len;\n  long len;\n  char *hostname = NULL, *rr_name = NULL;\n  struct ares_naptr_reply *naptr_head = NULL;\n  struct ares_naptr_reply *naptr_last = NULL;\n  struct ares_naptr_reply *naptr_curr;\n\n  /* Set *naptr_out to NULL for all failure cases. */\n  *naptr_out = NULL;\n\n  /* Give up if abuf doesn't have room for a header. */\n  if (alen < HFIXEDSZ)\n    return ARES_EBADRESP;\n\n  /* Fetch the question and answer count from the header. */\n  qdcount = DNS_HEADER_QDCOUNT (abuf);\n  ancount = DNS_HEADER_ANCOUNT (abuf);\n  if (qdcount != 1)\n    return ARES_EBADRESP;\n  if (ancount == 0)\n    return ARES_ENODATA;\n\n  /* Expand the name from the question, and skip past the question. */\n  aptr = abuf + HFIXEDSZ;\n  status = ares_expand_name (aptr, abuf, alen, &hostname, &len);\n  if (status != ARES_SUCCESS)\n    return status;\n\n  if (aptr + len + QFIXEDSZ > abuf + alen)\n    {\n      ares_free (hostname);\n      return ARES_EBADRESP;\n    }\n  aptr += len + QFIXEDSZ;\n\n  /* Examine each answer resource record (RR) in turn. */\n  for (i = 0; i < ancount; i++)\n    {\n      /* Decode the RR up to the data field. */\n      status = ares_expand_name (aptr, abuf, alen, &rr_name, &len);\n      if (status != ARES_SUCCESS)\n        {\n          break;\n        }\n      aptr += len;\n      if (aptr + RRFIXEDSZ > abuf + alen)\n        {\n          status = ARES_EBADRESP;\n          break;\n        }\n      rr_type = DNS_RR_TYPE (aptr);\n      rr_class = DNS_RR_CLASS (aptr);\n      rr_len = DNS_RR_LEN (aptr);\n      aptr += RRFIXEDSZ;\n      if (aptr + rr_len > abuf + alen)\n        {\n          status = ARES_EBADRESP;\n          break;\n        }\n      /* RR must contain at least 7 bytes = 2 x int16 + 3 x name */\n      if (rr_len < 7)\n        {\n          status = ARES_EBADRESP;\n          break;\n        }\n\n      /* Check if we are really looking at a NAPTR record */\n      if (rr_class == C_IN && rr_type == T_NAPTR)\n        {\n          /* parse the NAPTR record itself */\n\n          /* Allocate storage for this NAPTR answer appending it to the list */\n          naptr_curr = ares_malloc_data(ARES_DATATYPE_NAPTR_REPLY);\n          if (!naptr_curr)\n            {\n              status = ARES_ENOMEM;\n              break;\n            }\n          if (naptr_last)\n            {\n              naptr_last->next = naptr_curr;\n            }\n          else\n            {\n              naptr_head = naptr_curr;\n            }\n          naptr_last = naptr_curr;\n\n          vptr = aptr;\n          naptr_curr->order = DNS__16BIT(vptr);\n          vptr += sizeof(unsigned short);\n          naptr_curr->preference = DNS__16BIT(vptr);\n          vptr += sizeof(unsigned short);\n\n          status = ares_expand_string(vptr, abuf, alen, &naptr_curr->flags, &len);\n          if (status != ARES_SUCCESS)\n            break;\n          vptr += len;\n\n          status = ares_expand_string(vptr, abuf, alen, &naptr_curr->service, &len);\n          if (status != ARES_SUCCESS)\n            break;\n          vptr += len;\n\n          status = ares_expand_string(vptr, abuf, alen, &naptr_curr->regexp, &len);\n          if (status != ARES_SUCCESS)\n            break;\n          vptr += len;\n\n          status = ares_expand_name(vptr, abuf, alen, &naptr_curr->replacement, &len);\n          if (status != ARES_SUCCESS)\n            break;\n        }\n\n      /* Don't lose memory in the next iteration */\n      ares_free (rr_name);\n      rr_name = NULL;\n\n      /* Move on to the next record */\n      aptr += rr_len;\n    }\n\n  if (hostname)\n    ares_free (hostname);\n  if (rr_name)\n    ares_free (rr_name);\n\n  /* clean up on error */\n  if (status != ARES_SUCCESS)\n    {\n      if (naptr_head)\n        ares_free_data (naptr_head);\n      return status;\n    }\n\n  /* everything looks fine, return the data */\n  *naptr_out = naptr_head;\n\n  return ARES_SUCCESS;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148228,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "ares_parse_naptr_reply (const unsigned char *abuf, int alen,\n                        struct ares_naptr_reply **naptr_out)\n{\n  unsigned int qdcount, ancount, i;\n  const unsigned char *aptr, *vptr;\n  int status, rr_type, rr_class, rr_len;\n  long len;\n  char *hostname = NULL, *rr_name = NULL;\n  struct ares_naptr_reply *naptr_head = NULL;\n  struct ares_naptr_reply *naptr_last = NULL;\n  struct ares_naptr_reply *naptr_curr;\n\n  /* Set *naptr_out to NULL for all failure cases. */\n  *naptr_out = NULL;\n\n  /* Give up if abuf doesn't have room for a header. */\n  if (alen < HFIXEDSZ)\n    return ARES_EBADRESP;\n\n  /* Fetch the question and answer count from the header. */\n  qdcount = DNS_HEADER_QDCOUNT (abuf);\n  ancount = DNS_HEADER_ANCOUNT (abuf);\n  if (qdcount != 1)\n    return ARES_EBADRESP;\n  if (ancount == 0)\n    return ARES_ENODATA;\n\n  /* Expand the name from the question, and skip past the question. */\n  aptr = abuf + HFIXEDSZ;\n  status = ares_expand_name (aptr, abuf, alen, &hostname, &len);\n  if (status != ARES_SUCCESS)\n    return status;\n\n  if (aptr + len + QFIXEDSZ > abuf + alen)\n    {\n      ares_free (hostname);\n      return ARES_EBADRESP;\n    }\n  aptr += len + QFIXEDSZ;\n\n  /* Examine each answer resource record (RR) in turn. */\n  for (i = 0; i < ancount; i++)\n    {\n      /* Decode the RR up to the data field. */\n      status = ares_expand_name (aptr, abuf, alen, &rr_name, &len);\n      if (status != ARES_SUCCESS)\n        {\n          break;\n        }\n      aptr += len;\n      if (aptr + RRFIXEDSZ > abuf + alen)\n        {\n          status = ARES_EBADRESP;\n          break;\n        }\n      rr_type = DNS_RR_TYPE (aptr);\n      rr_class = DNS_RR_CLASS (aptr);\n      rr_len = DNS_RR_LEN (aptr);\n      aptr += RRFIXEDSZ;\n      if (aptr + rr_len > abuf + alen)\n        {\n          status = ARES_EBADRESP;\n          break;\n        }\n\n      /* Check if we are really looking at a NAPTR record */\n      if (rr_class == C_IN && rr_type == T_NAPTR)\n        {\n          /* parse the NAPTR record itself */\n\n          /* RR must contain at least 7 bytes = 2 x int16 + 3 x name */\n          if (rr_len < 7)\n            {\n              status = ARES_EBADRESP;\n              break;\n            }\n\n          /* Allocate storage for this NAPTR answer appending it to the list */\n          naptr_curr = ares_malloc_data(ARES_DATATYPE_NAPTR_REPLY);\n          if (!naptr_curr)\n            {\n              status = ARES_ENOMEM;\n              break;\n            }\n          if (naptr_last)\n            {\n              naptr_last->next = naptr_curr;\n            }\n          else\n            {\n              naptr_head = naptr_curr;\n            }\n          naptr_last = naptr_curr;\n\n          vptr = aptr;\n          naptr_curr->order = DNS__16BIT(vptr);\n          vptr += sizeof(unsigned short);\n          naptr_curr->preference = DNS__16BIT(vptr);\n          vptr += sizeof(unsigned short);\n\n          status = ares_expand_string(vptr, abuf, alen, &naptr_curr->flags, &len);\n          if (status != ARES_SUCCESS)\n            break;\n          vptr += len;\n\n          status = ares_expand_string(vptr, abuf, alen, &naptr_curr->service, &len);\n          if (status != ARES_SUCCESS)\n            break;\n          vptr += len;\n\n          status = ares_expand_string(vptr, abuf, alen, &naptr_curr->regexp, &len);\n          if (status != ARES_SUCCESS)\n            break;\n          vptr += len;\n\n          status = ares_expand_name(vptr, abuf, alen, &naptr_curr->replacement, &len);\n          if (status != ARES_SUCCESS)\n            break;\n        }\n\n      /* Don't lose memory in the next iteration */\n      ares_free (rr_name);\n      rr_name = NULL;\n\n      /* Move on to the next record */\n      aptr += rr_len;\n    }\n\n  if (hostname)\n    ares_free (hostname);\n  if (rr_name)\n    ares_free (rr_name);\n\n  /* clean up on error */\n  if (status != ARES_SUCCESS)\n    {\n      if (naptr_head)\n        ares_free_data (naptr_head);\n      return status;\n    }\n\n  /* everything looks fine, return the data */\n  *naptr_out = naptr_head;\n\n  return ARES_SUCCESS;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148229,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "get_word_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading raw-word-format PPM files with any maxval */\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub.buffer[0];\n  bufferptr = source->iobuffer;\n  for (col = cinfo->image_width; col > 0; col--) {\n    register unsigned int temp;\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    *ptr++ = rescale[temp];\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    *ptr++ = rescale[temp];\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    *ptr++ = rescale[temp];\n  }\n  return 1;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148370,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "get_word_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading raw-word-format PPM files with any maxval */\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n  register int rindex = rgb_red[cinfo->in_color_space];\n  register int gindex = rgb_green[cinfo->in_color_space];\n  register int bindex = rgb_blue[cinfo->in_color_space];\n  register int aindex = alpha_index[cinfo->in_color_space];\n  register int ps = rgb_pixelsize[cinfo->in_color_space];\n\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub.buffer[0];\n  bufferptr = source->iobuffer;\n  for (col = cinfo->image_width; col > 0; col--) {\n    register unsigned int temp;\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    ptr[rindex] = rescale[temp];\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    ptr[gindex] = rescale[temp];\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    ptr[bindex] = rescale[temp];\n    if (aindex >= 0)\n      ptr[aindex] = 0xFF;\n    ptr += ps;\n  }\n  return 1;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148371,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int route4_change(struct net *net, struct sk_buff *in_skb,\n\t\t\t struct tcf_proto *tp, unsigned long base, u32 handle,\n\t\t\t struct nlattr **tca, void **arg, bool ovr,\n\t\t\t bool rtnl_held, struct netlink_ext_ack *extack)\n{\n\tstruct route4_head *head = rtnl_dereference(tp->root);\n\tstruct route4_filter __rcu **fp;\n\tstruct route4_filter *fold, *f1, *pfp, *f = NULL;\n\tstruct route4_bucket *b;\n\tstruct nlattr *opt = tca[TCA_OPTIONS];\n\tstruct nlattr *tb[TCA_ROUTE4_MAX + 1];\n\tunsigned int h, th;\n\tint err;\n\tbool new = true;\n\n\tif (opt == NULL)\n\t\treturn handle ? -EINVAL : 0;\n\n\terr = nla_parse_nested_deprecated(tb, TCA_ROUTE4_MAX, opt,\n\t\t\t\t\t  route4_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tfold = *arg;\n\tif (fold && handle && fold->handle != handle)\n\t\t\treturn -EINVAL;\n\n\terr = -ENOBUFS;\n\tf = kzalloc(sizeof(struct route4_filter), GFP_KERNEL);\n\tif (!f)\n\t\tgoto errout;\n\n\terr = tcf_exts_init(&f->exts, net, TCA_ROUTE4_ACT, TCA_ROUTE4_POLICE);\n\tif (err < 0)\n\t\tgoto errout;\n\n\tif (fold) {\n\t\tf->id = fold->id;\n\t\tf->iif = fold->iif;\n\t\tf->res = fold->res;\n\t\tf->handle = fold->handle;\n\n\t\tf->tp = fold->tp;\n\t\tf->bkt = fold->bkt;\n\t\tnew = false;\n\t}\n\n\terr = route4_set_parms(net, tp, base, f, handle, head, tb,\n\t\t\t       tca[TCA_RATE], new, ovr, extack);\n\tif (err < 0)\n\t\tgoto errout;\n\n\th = from_hash(f->handle >> 16);\n\tfp = &f->bkt->ht[h];\n\tfor (pfp = rtnl_dereference(*fp);\n\t     (f1 = rtnl_dereference(*fp)) != NULL;\n\t     fp = &f1->next)\n\t\tif (f->handle < f1->handle)\n\t\t\tbreak;\n\n\ttcf_block_netif_keep_dst(tp->chain->block);\n\trcu_assign_pointer(f->next, f1);\n\trcu_assign_pointer(*fp, f);\n\n\tif (fold && fold->handle && f->handle != fold->handle) {\n\t\tth = to_hash(fold->handle);\n\t\th = from_hash(fold->handle >> 16);\n\t\tb = rtnl_dereference(head->table[th]);\n\t\tif (b) {\n\t\t\tfp = &b->ht[h];\n\t\t\tfor (pfp = rtnl_dereference(*fp); pfp;\n\t\t\t     fp = &pfp->next, pfp = rtnl_dereference(*fp)) {\n\t\t\t\tif (pfp == f) {\n\t\t\t\t\t*fp = f->next;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\troute4_reset_fastmap(head);\n\t*arg = f;\n\tif (fold) {\n\t\ttcf_unbind_filter(tp, &fold->res);\n\t\ttcf_exts_get_net(&fold->exts);\n\t\ttcf_queue_work(&fold->rwork, route4_delete_filter_work);\n\t}\n\treturn 0;\n\nerrout:\n\tif (f)\n\t\ttcf_exts_destroy(&f->exts);\n\tkfree(f);\n\treturn err;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148406,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int route4_change(struct net *net, struct sk_buff *in_skb,\n\t\t\t struct tcf_proto *tp, unsigned long base, u32 handle,\n\t\t\t struct nlattr **tca, void **arg, bool ovr,\n\t\t\t bool rtnl_held, struct netlink_ext_ack *extack)\n{\n\tstruct route4_head *head = rtnl_dereference(tp->root);\n\tstruct route4_filter __rcu **fp;\n\tstruct route4_filter *fold, *f1, *pfp, *f = NULL;\n\tstruct route4_bucket *b;\n\tstruct nlattr *opt = tca[TCA_OPTIONS];\n\tstruct nlattr *tb[TCA_ROUTE4_MAX + 1];\n\tunsigned int h, th;\n\tint err;\n\tbool new = true;\n\n\tif (opt == NULL)\n\t\treturn handle ? -EINVAL : 0;\n\n\terr = nla_parse_nested_deprecated(tb, TCA_ROUTE4_MAX, opt,\n\t\t\t\t\t  route4_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tfold = *arg;\n\tif (fold && handle && fold->handle != handle)\n\t\t\treturn -EINVAL;\n\n\terr = -ENOBUFS;\n\tf = kzalloc(sizeof(struct route4_filter), GFP_KERNEL);\n\tif (!f)\n\t\tgoto errout;\n\n\terr = tcf_exts_init(&f->exts, net, TCA_ROUTE4_ACT, TCA_ROUTE4_POLICE);\n\tif (err < 0)\n\t\tgoto errout;\n\n\tif (fold) {\n\t\tf->id = fold->id;\n\t\tf->iif = fold->iif;\n\t\tf->res = fold->res;\n\t\tf->handle = fold->handle;\n\n\t\tf->tp = fold->tp;\n\t\tf->bkt = fold->bkt;\n\t\tnew = false;\n\t}\n\n\terr = route4_set_parms(net, tp, base, f, handle, head, tb,\n\t\t\t       tca[TCA_RATE], new, ovr, extack);\n\tif (err < 0)\n\t\tgoto errout;\n\n\th = from_hash(f->handle >> 16);\n\tfp = &f->bkt->ht[h];\n\tfor (pfp = rtnl_dereference(*fp);\n\t     (f1 = rtnl_dereference(*fp)) != NULL;\n\t     fp = &f1->next)\n\t\tif (f->handle < f1->handle)\n\t\t\tbreak;\n\n\ttcf_block_netif_keep_dst(tp->chain->block);\n\trcu_assign_pointer(f->next, f1);\n\trcu_assign_pointer(*fp, f);\n\n\tif (fold && fold->handle && f->handle != fold->handle) {\n\t\tth = to_hash(fold->handle);\n\t\th = from_hash(fold->handle >> 16);\n\t\tb = rtnl_dereference(head->table[th]);\n\t\tif (b) {\n\t\t\tfp = &b->ht[h];\n\t\t\tfor (pfp = rtnl_dereference(*fp); pfp;\n\t\t\t     fp = &pfp->next, pfp = rtnl_dereference(*fp)) {\n\t\t\t\tif (pfp == fold) {\n\t\t\t\t\trcu_assign_pointer(*fp, fold->next);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\troute4_reset_fastmap(head);\n\t*arg = f;\n\tif (fold) {\n\t\ttcf_unbind_filter(tp, &fold->res);\n\t\ttcf_exts_get_net(&fold->exts);\n\t\ttcf_queue_work(&fold->rwork, route4_delete_filter_work);\n\t}\n\treturn 0;\n\nerrout:\n\tif (f)\n\t\ttcf_exts_destroy(&f->exts);\n\tkfree(f);\n\treturn err;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148407,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "PJ_DEF(pj_status_t) pjmedia_sdp_neg_modify_local_offer2(\n                                    pj_pool_t *pool,\n\t\t\t\t    pjmedia_sdp_neg *neg,\n                                    unsigned flags,\n\t\t\t\t    const pjmedia_sdp_session *local)\n{\n    pjmedia_sdp_session *new_offer;\n    pjmedia_sdp_session *old_offer;\n    char media_used[PJMEDIA_MAX_SDP_MEDIA];\n    unsigned oi; /* old offer media index */\n    pj_status_t status;\n\n    /* Check arguments are valid. */\n    PJ_ASSERT_RETURN(pool && neg && local, PJ_EINVAL);\n\n    /* Can only do this in STATE_DONE. */\n    PJ_ASSERT_RETURN(neg->state == PJMEDIA_SDP_NEG_STATE_DONE, \n\t\t     PJMEDIA_SDPNEG_EINSTATE);\n\n    /* Validate the new offer */\n    status = pjmedia_sdp_validate(local);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Change state to STATE_LOCAL_OFFER */\n    neg->state = PJMEDIA_SDP_NEG_STATE_LOCAL_OFFER;\n\n    /* Init vars */\n    pj_bzero(media_used, sizeof(media_used));\n    old_offer = neg->active_local_sdp;\n    new_offer = pjmedia_sdp_session_clone(pool, local);\n\n    /* RFC 3264 Section 8: When issuing an offer that modifies the session,\n     * the \"o=\" line of the new SDP MUST be identical to that in the\n     * previous SDP, except that the version in the origin field MUST\n     * increment by one from the previous SDP.\n     */\n    pj_strdup(pool, &new_offer->origin.user, &old_offer->origin.user);\n    new_offer->origin.id = old_offer->origin.id;\n\n    pj_strdup(pool, &new_offer->origin.net_type, &old_offer->origin.net_type);\n    pj_strdup(pool, &new_offer->origin.addr_type,&old_offer->origin.addr_type);\n    pj_strdup(pool, &new_offer->origin.addr, &old_offer->origin.addr);\n\n    if ((flags & PJMEDIA_SDP_NEG_ALLOW_MEDIA_CHANGE) == 0) {\n       /* Generating the new offer, in the case media lines doesn't match the\n        * active SDP (e.g. current/active SDP's have m=audio and m=video lines,\n        * and the new offer only has m=audio line), the negotiator will fix \n        * the new offer by reordering and adding the missing media line with \n        * port number set to zero.\n        */\n        for (oi = 0; oi < old_offer->media_count; ++oi) {\n\t    pjmedia_sdp_media *om;\n\t    pjmedia_sdp_media *nm;\n\t    unsigned ni; /* new offer media index */\n\t    pj_bool_t found = PJ_FALSE;\n\n\t    om = old_offer->media[oi];\n\t    for (ni = oi; ni < new_offer->media_count; ++ni) {\n\t        nm = new_offer->media[ni];\n\t        if (pj_strcmp(&nm->desc.media, &om->desc.media) == 0) {\n\t\t    if (ni != oi) {\n\t\t        /* The same media found but the position unmatched to\n                         * the old offer, so let's put this media in the right\n                         * place, and keep the order of the rest.\n\t\t         */\n\t\t        pj_array_insert(\n                            new_offer->media,\t\t /* array    */\n\t\t\t    sizeof(new_offer->media[0]), /* elmt size*/\n\t\t\t    ni,\t\t\t\t /* count    */\n\t\t            oi,\t\t\t\t /* pos      */\n\t\t\t    &nm);\t\t\t /* new elmt */\n\t\t    }\n\t\t    found = PJ_TRUE;\n\t\t    break;\n\t        }\n\t    }\n\t    if (!found) {\n\t        pjmedia_sdp_media *m;\n\n\t        m = sdp_media_clone_deactivate(pool, om, om, local);\n\n\t        pj_array_insert(new_offer->media, sizeof(new_offer->media[0]),\n\t\t\t        new_offer->media_count++, oi, &m);\n\t    }\n        }\n    } else {\n        /* If media type change is allowed, the negotiator only needs to fix \n         * the new offer by adding the missing media line(s) with port number\n         * set to zero.\n         */\n        for (oi = new_offer->media_count; oi < old_offer->media_count; ++oi) {\n            pjmedia_sdp_media *m;\n\n\t    m = sdp_media_clone_deactivate(pool, old_offer->media[oi],\n                                           old_offer->media[oi], local);\n\n\t    pj_array_insert(new_offer->media, sizeof(new_offer->media[0]),\n\t                    new_offer->media_count++, oi, &m);\n\n        }\n    }\n\n    /* New_offer fixed */\n#if PJMEDIA_SDP_NEG_COMPARE_BEFORE_INC_VERSION\n    new_offer->origin.version = old_offer->origin.version;\n\n    if (pjmedia_sdp_session_cmp(new_offer, neg->initial_sdp, 0) != PJ_SUCCESS)\n    {\n\t++new_offer->origin.version;\n    }    \n#else\n    new_offer->origin.version = old_offer->origin.version + 1;\n#endif\n    \n    neg->initial_sdp_tmp = neg->initial_sdp;\n    neg->initial_sdp = new_offer;\n    neg->neg_local_sdp = pjmedia_sdp_session_clone(pool, new_offer);\n\n    return PJ_SUCCESS;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148608,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "PJ_DEF(pj_status_t) pjmedia_sdp_neg_modify_local_offer2(\n                                    pj_pool_t *pool,\n\t\t\t\t    pjmedia_sdp_neg *neg,\n                                    unsigned flags,\n\t\t\t\t    const pjmedia_sdp_session *local)\n{\n    pjmedia_sdp_session *new_offer;\n    pjmedia_sdp_session *old_offer;\n    unsigned oi; /* old offer media index */\n    pj_status_t status;\n\n    /* Check arguments are valid. */\n    PJ_ASSERT_RETURN(pool && neg && local, PJ_EINVAL);\n\n    /* Can only do this in STATE_DONE. */\n    PJ_ASSERT_RETURN(neg->state == PJMEDIA_SDP_NEG_STATE_DONE, \n\t\t     PJMEDIA_SDPNEG_EINSTATE);\n\n    /* Validate the new offer */\n    status = pjmedia_sdp_validate(local);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Change state to STATE_LOCAL_OFFER */\n    neg->state = PJMEDIA_SDP_NEG_STATE_LOCAL_OFFER;\n\n    /* When there is no active local SDP in state PJMEDIA_SDP_NEG_STATE_DONE,\n     * it means that the previous initial SDP nego must have been failed,\n     * so we'll just set the local SDP offer here.\n     */\n    if (!neg->active_local_sdp) {\n\tneg->initial_sdp_tmp = NULL;\n\tneg->initial_sdp = pjmedia_sdp_session_clone(pool, local);\n\tneg->neg_local_sdp = pjmedia_sdp_session_clone(pool, local);\n\n\treturn PJ_SUCCESS;\n    }\n\n    /* Init vars */\n    old_offer = neg->active_local_sdp;\n    new_offer = pjmedia_sdp_session_clone(pool, local);\n\n    /* RFC 3264 Section 8: When issuing an offer that modifies the session,\n     * the \"o=\" line of the new SDP MUST be identical to that in the\n     * previous SDP, except that the version in the origin field MUST\n     * increment by one from the previous SDP.\n     */\n    pj_strdup(pool, &new_offer->origin.user, &old_offer->origin.user);\n    new_offer->origin.id = old_offer->origin.id;\n\n    pj_strdup(pool, &new_offer->origin.net_type, &old_offer->origin.net_type);\n    pj_strdup(pool, &new_offer->origin.addr_type,&old_offer->origin.addr_type);\n    pj_strdup(pool, &new_offer->origin.addr, &old_offer->origin.addr);\n\n    if ((flags & PJMEDIA_SDP_NEG_ALLOW_MEDIA_CHANGE) == 0) {\n       /* Generating the new offer, in the case media lines doesn't match the\n        * active SDP (e.g. current/active SDP's have m=audio and m=video lines,\n        * and the new offer only has m=audio line), the negotiator will fix \n        * the new offer by reordering and adding the missing media line with \n        * port number set to zero.\n        */\n        for (oi = 0; oi < old_offer->media_count; ++oi) {\n\t    pjmedia_sdp_media *om;\n\t    pjmedia_sdp_media *nm;\n\t    unsigned ni; /* new offer media index */\n\t    pj_bool_t found = PJ_FALSE;\n\n\t    om = old_offer->media[oi];\n\t    for (ni = oi; ni < new_offer->media_count; ++ni) {\n\t        nm = new_offer->media[ni];\n\t        if (pj_strcmp(&nm->desc.media, &om->desc.media) == 0) {\n\t\t    if (ni != oi) {\n\t\t        /* The same media found but the position unmatched to\n                         * the old offer, so let's put this media in the right\n                         * place, and keep the order of the rest.\n\t\t         */\n\t\t        pj_array_insert(\n                            new_offer->media,\t\t /* array    */\n\t\t\t    sizeof(new_offer->media[0]), /* elmt size*/\n\t\t\t    ni,\t\t\t\t /* count    */\n\t\t            oi,\t\t\t\t /* pos      */\n\t\t\t    &nm);\t\t\t /* new elmt */\n\t\t    }\n\t\t    found = PJ_TRUE;\n\t\t    break;\n\t        }\n\t    }\n\t    if (!found) {\n\t        pjmedia_sdp_media *m;\n\n\t        m = sdp_media_clone_deactivate(pool, om, om, local);\n\n\t        pj_array_insert(new_offer->media, sizeof(new_offer->media[0]),\n\t\t\t        new_offer->media_count++, oi, &m);\n\t    }\n        }\n    } else {\n        /* If media type change is allowed, the negotiator only needs to fix \n         * the new offer by adding the missing media line(s) with port number\n         * set to zero.\n         */\n        for (oi = new_offer->media_count; oi < old_offer->media_count; ++oi) {\n            pjmedia_sdp_media *m;\n\n\t    m = sdp_media_clone_deactivate(pool, old_offer->media[oi],\n                                           old_offer->media[oi], local);\n\n\t    pj_array_insert(new_offer->media, sizeof(new_offer->media[0]),\n\t                    new_offer->media_count++, oi, &m);\n\n        }\n    }\n\n    /* New_offer fixed */\n#if PJMEDIA_SDP_NEG_COMPARE_BEFORE_INC_VERSION\n    new_offer->origin.version = old_offer->origin.version;\n\n    if (pjmedia_sdp_session_cmp(new_offer, neg->initial_sdp, 0) != PJ_SUCCESS)\n    {\n\t++new_offer->origin.version;\n    }    \n#else\n    new_offer->origin.version = old_offer->origin.version + 1;\n#endif\n    \n    neg->initial_sdp_tmp = neg->initial_sdp;\n    neg->initial_sdp = new_offer;\n    neg->neg_local_sdp = pjmedia_sdp_session_clone(pool, new_offer);\n\n    return PJ_SUCCESS;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148609,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "ecc_decrypt_raw (gcry_sexp_t *r_plain, gcry_sexp_t s_data, gcry_sexp_t keyparms)\n{\n  unsigned int nbits;\n  gpg_err_code_t rc;\n  struct pk_encoding_ctx ctx;\n  gcry_sexp_t l1 = NULL;\n  gcry_mpi_t data_e = NULL;\n  ECC_secret_key sk;\n  gcry_mpi_t mpi_g = NULL;\n  char *curvename = NULL;\n  mpi_ec_t ec = NULL;\n  mpi_point_struct kG;\n  mpi_point_struct R;\n  gcry_mpi_t r = NULL;\n  int flags = 0;\n\n  memset (&sk, 0, sizeof sk);\n  point_init (&kG);\n  point_init (&R);\n\n  _gcry_pk_util_init_encoding_ctx (&ctx, PUBKEY_OP_DECRYPT,\n                                   (nbits = ecc_get_nbits (keyparms)));\n\n  /* Look for flags. */\n  l1 = sexp_find_token (keyparms, \"flags\", 0);\n  if (l1)\n    {\n      rc = _gcry_pk_util_parse_flaglist (l1, &flags, NULL);\n      if (rc)\n        goto leave;\n    }\n  sexp_release (l1);\n  l1 = NULL;\n\n  /*\n   * Extract the data.\n   */\n  rc = _gcry_pk_util_preparse_encval (s_data, ecc_names, &l1, &ctx);\n  if (rc)\n    goto leave;\n  rc = sexp_extract_param (l1, NULL, \"e\", &data_e, NULL);\n  if (rc)\n    goto leave;\n  if (DBG_CIPHER)\n    log_printmpi (\"ecc_decrypt  d_e\", data_e);\n  if (mpi_is_opaque (data_e))\n    {\n      rc = GPG_ERR_INV_DATA;\n      goto leave;\n    }\n\n  /*\n   * Extract the key.\n   */\n  rc = sexp_extract_param (keyparms, NULL, \"-p?a?b?g?n?h?+d\",\n                           &sk.E.p, &sk.E.a, &sk.E.b, &mpi_g, &sk.E.n,\n                           &sk.E.h, &sk.d, NULL);\n  if (rc)\n    goto leave;\n  if (mpi_g)\n    {\n      point_init (&sk.E.G);\n      rc = _gcry_ecc_os2ec (&sk.E.G, mpi_g);\n      if (rc)\n        goto leave;\n    }\n  /* Add missing parameters using the optional curve parameter.  */\n  sexp_release (l1);\n  l1 = sexp_find_token (keyparms, \"curve\", 5);\n  if (l1)\n    {\n      curvename = sexp_nth_string (l1, 1);\n      if (curvename)\n        {\n          rc = _gcry_ecc_fill_in_curve (0, curvename, &sk.E, NULL);\n          if (rc)\n            goto leave;\n        }\n    }\n  /* Guess required fields if a curve parameter has not been given.  */\n  if (!curvename)\n    {\n      sk.E.model = MPI_EC_WEIERSTRASS;\n      sk.E.dialect = ECC_DIALECT_STANDARD;\n      if (!sk.E.h)\n\tsk.E.h = mpi_const (MPI_C_ONE);\n    }\n  if (DBG_CIPHER)\n    {\n      log_debug (\"ecc_decrypt info: %s/%s\\n\",\n                 _gcry_ecc_model2str (sk.E.model),\n                 _gcry_ecc_dialect2str (sk.E.dialect));\n      if (sk.E.name)\n        log_debug  (\"ecc_decrypt name: %s\\n\", sk.E.name);\n      log_printmpi (\"ecc_decrypt    p\", sk.E.p);\n      log_printmpi (\"ecc_decrypt    a\", sk.E.a);\n      log_printmpi (\"ecc_decrypt    b\", sk.E.b);\n      log_printpnt (\"ecc_decrypt  g\",   &sk.E.G, NULL);\n      log_printmpi (\"ecc_decrypt    n\", sk.E.n);\n      log_printmpi (\"ecc_decrypt    h\", sk.E.h);\n      if (!fips_mode ())\n        log_printmpi (\"ecc_decrypt    d\", sk.d);\n    }\n  if (!sk.E.p || !sk.E.a || !sk.E.b || !sk.E.G.x || !sk.E.n || !sk.E.h || !sk.d)\n    {\n      rc = GPG_ERR_NO_OBJ;\n      goto leave;\n    }\n\n\n  ec = _gcry_mpi_ec_p_internal_new (sk.E.model, sk.E.dialect, flags,\n                                    sk.E.p, sk.E.a, sk.E.b);\n\n  /*\n   * Compute the plaintext.\n   */\n  if (ec->model == MPI_EC_MONTGOMERY)\n    rc = _gcry_ecc_mont_decodepoint (data_e, ec, &kG);\n  else\n    rc = _gcry_ecc_os2ec (&kG, data_e);\n  if (rc)\n    goto leave;\n\n  if (DBG_CIPHER)\n    log_printpnt (\"ecc_decrypt    kG\", &kG, NULL);\n\n  if (!(flags & PUBKEY_FLAG_DJB_TWEAK)\n      /* For X25519, by its definition, validation should not be done.  */\n      && !_gcry_mpi_ec_curve_point (&kG, ec))\n    {\n      rc = GPG_ERR_INV_DATA;\n      goto leave;\n    }\n\n  /* R = dkG */\n  _gcry_mpi_ec_mul_point (&R, sk.d, &kG, ec);\n\n  /* The following is false: assert( mpi_cmp_ui( R.x, 1 )==0 );, so:  */\n  {\n    gcry_mpi_t x, y;\n\n    x = mpi_new (0);\n    if (ec->model == MPI_EC_MONTGOMERY)\n      y = NULL;\n    else\n      y = mpi_new (0);\n\n    if (_gcry_mpi_ec_get_affine (x, y, &R, ec))\n      {\n        rc = GPG_ERR_INV_DATA;\n        goto leave;\n        /*\n         * Note for X25519.\n         *\n         * By the definition of X25519, this is the case where X25519\n         * returns 0, mapping infinity to zero.  However, we\n         * deliberately let it return an error.\n         *\n         * For X25519 ECDH, comming here means that it might be\n         * decrypted by anyone with the shared secret of 0 (the result\n         * of this function could be always 0 by other scalar values,\n         * other than the private key of SK.D).\n         *\n         * So, it looks like an encrypted message but it can be\n         * decrypted by anyone, or at least something wrong\n         * happens.  Recipient should not proceed as if it were\n         * properly encrypted message.\n         *\n         * This handling is needed for our major usage of GnuPG,\n         * where it does the One-Pass Diffie-Hellman method,\n         * C(1, 1, ECC CDH), with an ephemeral key.\n         */\n      }\n\n    if (y)\n      r = _gcry_ecc_ec2os (x, y, sk.E.p);\n    else\n      {\n        unsigned char *rawmpi;\n        unsigned int rawmpilen;\n\n        rawmpi = _gcry_mpi_get_buffer_extra (x, nbits/8, -1,\n                                             &rawmpilen, NULL);\n        if (!rawmpi)\n          {\n            rc = gpg_err_code_from_syserror ();\n            goto leave;\n          }\n        else\n          {\n            rawmpi[0] = 0x40;\n            rawmpilen++;\n            r = mpi_new (0);\n            mpi_set_opaque (r, rawmpi, rawmpilen*8);\n          }\n      }\n    if (!r)\n      rc = gpg_err_code_from_syserror ();\n    else\n      rc = 0;\n    mpi_free (x);\n    mpi_free (y);\n  }\n  if (DBG_CIPHER)\n    log_printmpi (\"ecc_decrypt  res\", r);\n\n  if (!rc)\n    rc = sexp_build (r_plain, NULL, \"(value %m)\", r);\n\n leave:\n  point_free (&R);\n  point_free (&kG);\n  _gcry_mpi_release (r);\n  _gcry_mpi_release (sk.E.p);\n  _gcry_mpi_release (sk.E.a);\n  _gcry_mpi_release (sk.E.b);\n  _gcry_mpi_release (mpi_g);\n  point_free (&sk.E.G);\n  _gcry_mpi_release (sk.E.n);\n  _gcry_mpi_release (sk.E.h);\n  _gcry_mpi_release (sk.d);\n  _gcry_mpi_release (data_e);\n  xfree (curvename);\n  sexp_release (l1);\n  _gcry_mpi_ec_free (ec);\n  _gcry_pk_util_free_encoding_ctx (&ctx);\n  if (DBG_CIPHER)\n    log_debug (\"ecc_decrypt    => %s\\n\", gpg_strerror (rc));\n  return rc;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148654,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "ecc_decrypt_raw (gcry_sexp_t *r_plain, gcry_sexp_t s_data, gcry_sexp_t keyparms)\n{\n  unsigned int nbits;\n  gpg_err_code_t rc;\n  struct pk_encoding_ctx ctx;\n  gcry_sexp_t l1 = NULL;\n  gcry_mpi_t data_e = NULL;\n  ECC_secret_key sk;\n  gcry_mpi_t mpi_g = NULL;\n  char *curvename = NULL;\n  mpi_ec_t ec = NULL;\n  mpi_point_struct kG;\n  mpi_point_struct R;\n  gcry_mpi_t r = NULL;\n  int flags = 0;\n\n  memset (&sk, 0, sizeof sk);\n  point_init (&kG);\n  point_init (&R);\n\n  _gcry_pk_util_init_encoding_ctx (&ctx, PUBKEY_OP_DECRYPT,\n                                   (nbits = ecc_get_nbits (keyparms)));\n\n  /* Look for flags. */\n  l1 = sexp_find_token (keyparms, \"flags\", 0);\n  if (l1)\n    {\n      rc = _gcry_pk_util_parse_flaglist (l1, &flags, NULL);\n      if (rc)\n        goto leave;\n    }\n  sexp_release (l1);\n  l1 = NULL;\n\n  /*\n   * Extract the data.\n   */\n  rc = _gcry_pk_util_preparse_encval (s_data, ecc_names, &l1, &ctx);\n  if (rc)\n    goto leave;\n  rc = sexp_extract_param (l1, NULL, \"e\", &data_e, NULL);\n  if (rc)\n    goto leave;\n  if (DBG_CIPHER)\n    log_printmpi (\"ecc_decrypt  d_e\", data_e);\n  if (mpi_is_opaque (data_e))\n    {\n      rc = GPG_ERR_INV_DATA;\n      goto leave;\n    }\n\n  /*\n   * Extract the key.\n   */\n  rc = sexp_extract_param (keyparms, NULL, \"-p?a?b?g?n?h?+d\",\n                           &sk.E.p, &sk.E.a, &sk.E.b, &mpi_g, &sk.E.n,\n                           &sk.E.h, &sk.d, NULL);\n  if (rc)\n    goto leave;\n  if (mpi_g)\n    {\n      point_init (&sk.E.G);\n      rc = _gcry_ecc_os2ec (&sk.E.G, mpi_g);\n      if (rc)\n        goto leave;\n    }\n  /* Add missing parameters using the optional curve parameter.  */\n  sexp_release (l1);\n  l1 = sexp_find_token (keyparms, \"curve\", 5);\n  if (l1)\n    {\n      curvename = sexp_nth_string (l1, 1);\n      if (curvename)\n        {\n          rc = _gcry_ecc_fill_in_curve (0, curvename, &sk.E, NULL);\n          if (rc)\n            goto leave;\n        }\n    }\n  /* Guess required fields if a curve parameter has not been given.  */\n  if (!curvename)\n    {\n      sk.E.model = MPI_EC_WEIERSTRASS;\n      sk.E.dialect = ECC_DIALECT_STANDARD;\n      if (!sk.E.h)\n\tsk.E.h = mpi_const (MPI_C_ONE);\n    }\n  if (DBG_CIPHER)\n    {\n      log_debug (\"ecc_decrypt info: %s/%s\\n\",\n                 _gcry_ecc_model2str (sk.E.model),\n                 _gcry_ecc_dialect2str (sk.E.dialect));\n      if (sk.E.name)\n        log_debug  (\"ecc_decrypt name: %s\\n\", sk.E.name);\n      log_printmpi (\"ecc_decrypt    p\", sk.E.p);\n      log_printmpi (\"ecc_decrypt    a\", sk.E.a);\n      log_printmpi (\"ecc_decrypt    b\", sk.E.b);\n      log_printpnt (\"ecc_decrypt  g\",   &sk.E.G, NULL);\n      log_printmpi (\"ecc_decrypt    n\", sk.E.n);\n      log_printmpi (\"ecc_decrypt    h\", sk.E.h);\n      if (!fips_mode ())\n        log_printmpi (\"ecc_decrypt    d\", sk.d);\n    }\n  if (!sk.E.p || !sk.E.a || !sk.E.b || !sk.E.G.x || !sk.E.n || !sk.E.h || !sk.d)\n    {\n      rc = GPG_ERR_NO_OBJ;\n      goto leave;\n    }\n\n\n  ec = _gcry_mpi_ec_p_internal_new (sk.E.model, sk.E.dialect, flags,\n                                    sk.E.p, sk.E.a, sk.E.b);\n\n  /*\n   * Compute the plaintext.\n   */\n  if (ec->model == MPI_EC_MONTGOMERY)\n    rc = _gcry_ecc_mont_decodepoint (data_e, ec, &kG);\n  else\n    rc = _gcry_ecc_os2ec (&kG, data_e);\n  if (rc)\n    goto leave;\n\n  if (DBG_CIPHER)\n    log_printpnt (\"ecc_decrypt    kG\", &kG, NULL);\n\n  if ((flags & PUBKEY_FLAG_DJB_TWEAK))\n    {\n      /* For X25519, by its definition, validation should not be done.  */\n      /* (Instead, we do output check.)\n       *\n       * However, to mitigate secret key leak from our implementation,\n       * we also do input validation here.  For constant-time\n       * implementation, we can remove this input validation.\n       */\n      if (_gcry_mpi_ec_bad_point (&kG, ec))\n        {\n          rc = GPG_ERR_INV_DATA;\n          goto leave;\n        }\n    }\n  else if (!_gcry_mpi_ec_curve_point (&kG, ec))\n    {\n      rc = GPG_ERR_INV_DATA;\n      goto leave;\n    }\n\n  /* R = dkG */\n  _gcry_mpi_ec_mul_point (&R, sk.d, &kG, ec);\n\n  /* The following is false: assert( mpi_cmp_ui( R.x, 1 )==0 );, so:  */\n  {\n    gcry_mpi_t x, y;\n\n    x = mpi_new (0);\n    if (ec->model == MPI_EC_MONTGOMERY)\n      y = NULL;\n    else\n      y = mpi_new (0);\n\n    if (_gcry_mpi_ec_get_affine (x, y, &R, ec))\n      {\n        rc = GPG_ERR_INV_DATA;\n        goto leave;\n        /*\n         * Note for X25519.\n         *\n         * By the definition of X25519, this is the case where X25519\n         * returns 0, mapping infinity to zero.  However, we\n         * deliberately let it return an error.\n         *\n         * For X25519 ECDH, comming here means that it might be\n         * decrypted by anyone with the shared secret of 0 (the result\n         * of this function could be always 0 by other scalar values,\n         * other than the private key of SK.D).\n         *\n         * So, it looks like an encrypted message but it can be\n         * decrypted by anyone, or at least something wrong\n         * happens.  Recipient should not proceed as if it were\n         * properly encrypted message.\n         *\n         * This handling is needed for our major usage of GnuPG,\n         * where it does the One-Pass Diffie-Hellman method,\n         * C(1, 1, ECC CDH), with an ephemeral key.\n         */\n      }\n\n    if (y)\n      r = _gcry_ecc_ec2os (x, y, sk.E.p);\n    else\n      {\n        unsigned char *rawmpi;\n        unsigned int rawmpilen;\n\n        rawmpi = _gcry_mpi_get_buffer_extra (x, nbits/8, -1,\n                                             &rawmpilen, NULL);\n        if (!rawmpi)\n          {\n            rc = gpg_err_code_from_syserror ();\n            goto leave;\n          }\n        else\n          {\n            rawmpi[0] = 0x40;\n            rawmpilen++;\n            r = mpi_new (0);\n            mpi_set_opaque (r, rawmpi, rawmpilen*8);\n          }\n      }\n    if (!r)\n      rc = gpg_err_code_from_syserror ();\n    else\n      rc = 0;\n    mpi_free (x);\n    mpi_free (y);\n  }\n  if (DBG_CIPHER)\n    log_printmpi (\"ecc_decrypt  res\", r);\n\n  if (!rc)\n    rc = sexp_build (r_plain, NULL, \"(value %m)\", r);\n\n leave:\n  point_free (&R);\n  point_free (&kG);\n  _gcry_mpi_release (r);\n  _gcry_mpi_release (sk.E.p);\n  _gcry_mpi_release (sk.E.a);\n  _gcry_mpi_release (sk.E.b);\n  _gcry_mpi_release (mpi_g);\n  point_free (&sk.E.G);\n  _gcry_mpi_release (sk.E.n);\n  _gcry_mpi_release (sk.E.h);\n  _gcry_mpi_release (sk.d);\n  _gcry_mpi_release (data_e);\n  xfree (curvename);\n  sexp_release (l1);\n  _gcry_mpi_ec_free (ec);\n  _gcry_pk_util_free_encoding_ctx (&ctx);\n  if (DBG_CIPHER)\n    log_debug (\"ecc_decrypt    => %s\\n\", gpg_strerror (rc));\n  return rc;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148655,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static void slc_bump(struct slcan *sl)\n{\n\tstruct sk_buff *skb;\n\tstruct can_frame cf;\n\tint i, tmp;\n\tu32 tmpid;\n\tchar *cmd = sl->rbuff;\n\n\tcf.can_id = 0;\n\n\tswitch (*cmd) {\n\tcase 'r':\n\t\tcf.can_id = CAN_RTR_FLAG;\n\t\t/* fallthrough */\n\tcase 't':\n\t\t/* store dlc ASCII value and terminate SFF CAN ID string */\n\t\tcf.can_dlc = sl->rbuff[SLC_CMD_LEN + SLC_SFF_ID_LEN];\n\t\tsl->rbuff[SLC_CMD_LEN + SLC_SFF_ID_LEN] = 0;\n\t\t/* point to payload data behind the dlc */\n\t\tcmd += SLC_CMD_LEN + SLC_SFF_ID_LEN + 1;\n\t\tbreak;\n\tcase 'R':\n\t\tcf.can_id = CAN_RTR_FLAG;\n\t\t/* fallthrough */\n\tcase 'T':\n\t\tcf.can_id |= CAN_EFF_FLAG;\n\t\t/* store dlc ASCII value and terminate EFF CAN ID string */\n\t\tcf.can_dlc = sl->rbuff[SLC_CMD_LEN + SLC_EFF_ID_LEN];\n\t\tsl->rbuff[SLC_CMD_LEN + SLC_EFF_ID_LEN] = 0;\n\t\t/* point to payload data behind the dlc */\n\t\tcmd += SLC_CMD_LEN + SLC_EFF_ID_LEN + 1;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (kstrtou32(sl->rbuff + SLC_CMD_LEN, 16, &tmpid))\n\t\treturn;\n\n\tcf.can_id |= tmpid;\n\n\t/* get can_dlc from sanitized ASCII value */\n\tif (cf.can_dlc >= '0' && cf.can_dlc < '9')\n\t\tcf.can_dlc -= '0';\n\telse\n\t\treturn;\n\n\t*(u64 *) (&cf.data) = 0; /* clear payload */\n\n\t/* RTR frames may have a dlc > 0 but they never have any data bytes */\n\tif (!(cf.can_id & CAN_RTR_FLAG)) {\n\t\tfor (i = 0; i < cf.can_dlc; i++) {\n\t\t\ttmp = hex_to_bin(*cmd++);\n\t\t\tif (tmp < 0)\n\t\t\t\treturn;\n\t\t\tcf.data[i] = (tmp << 4);\n\t\t\ttmp = hex_to_bin(*cmd++);\n\t\t\tif (tmp < 0)\n\t\t\t\treturn;\n\t\t\tcf.data[i] |= tmp;\n\t\t}\n\t}\n\n\tskb = dev_alloc_skb(sizeof(struct can_frame) +\n\t\t\t    sizeof(struct can_skb_priv));\n\tif (!skb)\n\t\treturn;\n\n\tskb->dev = sl->dev;\n\tskb->protocol = htons(ETH_P_CAN);\n\tskb->pkt_type = PACKET_BROADCAST;\n\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\n\tcan_skb_reserve(skb);\n\tcan_skb_prv(skb)->ifindex = sl->dev->ifindex;\n\tcan_skb_prv(skb)->skbcnt = 0;\n\n\tskb_put_data(skb, &cf, sizeof(struct can_frame));\n\n\tsl->dev->stats.rx_packets++;\n\tsl->dev->stats.rx_bytes += cf.can_dlc;\n\tnetif_rx_ni(skb);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148702,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static void slc_bump(struct slcan *sl)\n{\n\tstruct sk_buff *skb;\n\tstruct can_frame cf;\n\tint i, tmp;\n\tu32 tmpid;\n\tchar *cmd = sl->rbuff;\n\n\tmemset(&cf, 0, sizeof(cf));\n\n\tswitch (*cmd) {\n\tcase 'r':\n\t\tcf.can_id = CAN_RTR_FLAG;\n\t\t/* fallthrough */\n\tcase 't':\n\t\t/* store dlc ASCII value and terminate SFF CAN ID string */\n\t\tcf.can_dlc = sl->rbuff[SLC_CMD_LEN + SLC_SFF_ID_LEN];\n\t\tsl->rbuff[SLC_CMD_LEN + SLC_SFF_ID_LEN] = 0;\n\t\t/* point to payload data behind the dlc */\n\t\tcmd += SLC_CMD_LEN + SLC_SFF_ID_LEN + 1;\n\t\tbreak;\n\tcase 'R':\n\t\tcf.can_id = CAN_RTR_FLAG;\n\t\t/* fallthrough */\n\tcase 'T':\n\t\tcf.can_id |= CAN_EFF_FLAG;\n\t\t/* store dlc ASCII value and terminate EFF CAN ID string */\n\t\tcf.can_dlc = sl->rbuff[SLC_CMD_LEN + SLC_EFF_ID_LEN];\n\t\tsl->rbuff[SLC_CMD_LEN + SLC_EFF_ID_LEN] = 0;\n\t\t/* point to payload data behind the dlc */\n\t\tcmd += SLC_CMD_LEN + SLC_EFF_ID_LEN + 1;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (kstrtou32(sl->rbuff + SLC_CMD_LEN, 16, &tmpid))\n\t\treturn;\n\n\tcf.can_id |= tmpid;\n\n\t/* get can_dlc from sanitized ASCII value */\n\tif (cf.can_dlc >= '0' && cf.can_dlc < '9')\n\t\tcf.can_dlc -= '0';\n\telse\n\t\treturn;\n\n\t/* RTR frames may have a dlc > 0 but they never have any data bytes */\n\tif (!(cf.can_id & CAN_RTR_FLAG)) {\n\t\tfor (i = 0; i < cf.can_dlc; i++) {\n\t\t\ttmp = hex_to_bin(*cmd++);\n\t\t\tif (tmp < 0)\n\t\t\t\treturn;\n\t\t\tcf.data[i] = (tmp << 4);\n\t\t\ttmp = hex_to_bin(*cmd++);\n\t\t\tif (tmp < 0)\n\t\t\t\treturn;\n\t\t\tcf.data[i] |= tmp;\n\t\t}\n\t}\n\n\tskb = dev_alloc_skb(sizeof(struct can_frame) +\n\t\t\t    sizeof(struct can_skb_priv));\n\tif (!skb)\n\t\treturn;\n\n\tskb->dev = sl->dev;\n\tskb->protocol = htons(ETH_P_CAN);\n\tskb->pkt_type = PACKET_BROADCAST;\n\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\n\tcan_skb_reserve(skb);\n\tcan_skb_prv(skb)->ifindex = sl->dev->ifindex;\n\tcan_skb_prv(skb)->skbcnt = 0;\n\n\tskb_put_data(skb, &cf, sizeof(struct can_frame));\n\n\tsl->dev->stats.rx_packets++;\n\tsl->dev->stats.rx_bytes += cf.can_dlc;\n\tnetif_rx_ni(skb);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148703,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static void suboption(struct Curl_easy *data)\n{\n  struct curl_slist *v;\n  unsigned char temp[2048];\n  ssize_t bytes_written;\n  size_t len;\n  int err;\n  char varname[128] = \"\";\n  char varval[128] = \"\";\n  struct TELNET *tn = data->req.p.telnet;\n  struct connectdata *conn = data->conn;\n\n  printsub(data, '<', (unsigned char *)tn->subbuffer, CURL_SB_LEN(tn) + 2);\n  switch(CURL_SB_GET(tn)) {\n    case CURL_TELOPT_TTYPE:\n      len = strlen(tn->subopt_ttype) + 4 + 2;\n      msnprintf((char *)temp, sizeof(temp),\n                \"%c%c%c%c%s%c%c\", CURL_IAC, CURL_SB, CURL_TELOPT_TTYPE,\n                CURL_TELQUAL_IS, tn->subopt_ttype, CURL_IAC, CURL_SE);\n      bytes_written = swrite(conn->sock[FIRSTSOCKET], temp, len);\n      if(bytes_written < 0) {\n        err = SOCKERRNO;\n        failf(data,\"Sending data failed (%d)\",err);\n      }\n      printsub(data, '>', &temp[2], len-2);\n      break;\n    case CURL_TELOPT_XDISPLOC:\n      len = strlen(tn->subopt_xdisploc) + 4 + 2;\n      msnprintf((char *)temp, sizeof(temp),\n                \"%c%c%c%c%s%c%c\", CURL_IAC, CURL_SB, CURL_TELOPT_XDISPLOC,\n                CURL_TELQUAL_IS, tn->subopt_xdisploc, CURL_IAC, CURL_SE);\n      bytes_written = swrite(conn->sock[FIRSTSOCKET], temp, len);\n      if(bytes_written < 0) {\n        err = SOCKERRNO;\n        failf(data,\"Sending data failed (%d)\",err);\n      }\n      printsub(data, '>', &temp[2], len-2);\n      break;\n    case CURL_TELOPT_NEW_ENVIRON:\n      msnprintf((char *)temp, sizeof(temp),\n                \"%c%c%c%c\", CURL_IAC, CURL_SB, CURL_TELOPT_NEW_ENVIRON,\n                CURL_TELQUAL_IS);\n      len = 4;\n\n      for(v = tn->telnet_vars; v; v = v->next) {\n        size_t tmplen = (strlen(v->data) + 1);\n        /* Add the variable only if it fits */\n        if(len + tmplen < (int)sizeof(temp)-6) {\n          if(sscanf(v->data, \"%127[^,],%127s\", varname, varval)) {\n            msnprintf((char *)&temp[len], sizeof(temp) - len,\n                      \"%c%s%c%s\", CURL_NEW_ENV_VAR, varname,\n                      CURL_NEW_ENV_VALUE, varval);\n            len += tmplen;\n          }\n        }\n      }\n      msnprintf((char *)&temp[len], sizeof(temp) - len,\n                \"%c%c\", CURL_IAC, CURL_SE);\n      len += 2;\n      bytes_written = swrite(conn->sock[FIRSTSOCKET], temp, len);\n      if(bytes_written < 0) {\n        err = SOCKERRNO;\n        failf(data,\"Sending data failed (%d)\",err);\n      }\n      printsub(data, '>', &temp[2], len-2);\n      break;\n  }\n  return;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148706,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static void suboption(struct Curl_easy *data)\n{\n  struct curl_slist *v;\n  unsigned char temp[2048];\n  ssize_t bytes_written;\n  size_t len;\n  int err;\n  char varname[128] = \"\";\n  char varval[128] = \"\";\n  struct TELNET *tn = data->req.p.telnet;\n  struct connectdata *conn = data->conn;\n\n  printsub(data, '<', (unsigned char *)tn->subbuffer, CURL_SB_LEN(tn) + 2);\n  switch(CURL_SB_GET(tn)) {\n    case CURL_TELOPT_TTYPE:\n      len = strlen(tn->subopt_ttype) + 4 + 2;\n      msnprintf((char *)temp, sizeof(temp),\n                \"%c%c%c%c%s%c%c\", CURL_IAC, CURL_SB, CURL_TELOPT_TTYPE,\n                CURL_TELQUAL_IS, tn->subopt_ttype, CURL_IAC, CURL_SE);\n      bytes_written = swrite(conn->sock[FIRSTSOCKET], temp, len);\n      if(bytes_written < 0) {\n        err = SOCKERRNO;\n        failf(data,\"Sending data failed (%d)\",err);\n      }\n      printsub(data, '>', &temp[2], len-2);\n      break;\n    case CURL_TELOPT_XDISPLOC:\n      len = strlen(tn->subopt_xdisploc) + 4 + 2;\n      msnprintf((char *)temp, sizeof(temp),\n                \"%c%c%c%c%s%c%c\", CURL_IAC, CURL_SB, CURL_TELOPT_XDISPLOC,\n                CURL_TELQUAL_IS, tn->subopt_xdisploc, CURL_IAC, CURL_SE);\n      bytes_written = swrite(conn->sock[FIRSTSOCKET], temp, len);\n      if(bytes_written < 0) {\n        err = SOCKERRNO;\n        failf(data,\"Sending data failed (%d)\",err);\n      }\n      printsub(data, '>', &temp[2], len-2);\n      break;\n    case CURL_TELOPT_NEW_ENVIRON:\n      msnprintf((char *)temp, sizeof(temp),\n                \"%c%c%c%c\", CURL_IAC, CURL_SB, CURL_TELOPT_NEW_ENVIRON,\n                CURL_TELQUAL_IS);\n      len = 4;\n\n      for(v = tn->telnet_vars; v; v = v->next) {\n        size_t tmplen = (strlen(v->data) + 1);\n        /* Add the variable only if it fits */\n        if(len + tmplen < (int)sizeof(temp)-6) {\n          if(sscanf(v->data, \"%127[^,],%127s\", varname, varval) == 2) {\n            msnprintf((char *)&temp[len], sizeof(temp) - len,\n                      \"%c%s%c%s\", CURL_NEW_ENV_VAR, varname,\n                      CURL_NEW_ENV_VALUE, varval);\n            len += tmplen;\n          }\n        }\n      }\n      msnprintf((char *)&temp[len], sizeof(temp) - len,\n                \"%c%c\", CURL_IAC, CURL_SE);\n      len += 2;\n      bytes_written = swrite(conn->sock[FIRSTSOCKET], temp, len);\n      if(bytes_written < 0) {\n        err = SOCKERRNO;\n        failf(data,\"Sending data failed (%d)\",err);\n      }\n      printsub(data, '>', &temp[2], len-2);\n      break;\n  }\n  return;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148707,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "int data_on_connection(int fd, callback_remove_handler remove)\n{\n\tint nread;\n\tchar *network_packet;\n\tchar network_line[8192];\n\tchar *p;\n\tunsigned long id;\n\n\tchar string[1024];\n\tunsigned long msg_id = UINT32_MAX;\n\tenum network_protocol version = network_client_get_version(fd);\n\n\tioctl(fd, FIONREAD, &nread);\n\n\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"new connection data = %d\\n\",nread);\n\n\tif(nread == 0)\n\t{\n\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_PROCESS, \"%d failed, got 0 close connection to listener \", fd);\n\t\tclose(fd);\n\t\tFD_CLR(fd, &readfds);\n\t\tremove(fd);\n\t\tnetwork_client_dump ();\n\t\treturn 0;\n\t}\n\n\n\tif ( nread >= 8192 ) {\n\n\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ERROR, \"%d failed, more than 8192 close connection to listener \", fd);\n\t\tclose(fd);\n\t\tFD_CLR(fd, &readfds);\n\t\tremove(fd);\n\n\t\treturn 0;\n\t}\n\n\t/* read the whole package */\n\tnetwork_packet=malloc((nread+1) * sizeof(char));\n\tread(fd, network_packet, nread);\n\tnetwork_packet[nread]='\\0';\n\n\tmemset(network_line, 0, 8192);\n\tp=network_packet;\n\tp_sem(sem_id);\n\n\twhile ( get_network_line(p, network_line) ) {\n\n\t\tif ( strlen(network_line) > 0 ) {\n\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"line = [%s]\",network_line);\n\t\t}\n\n\t\t\n\t\tif ( !strncmp(network_line, \"MSGID: \", strlen(\"MSGID: \")) ) {\n\t\t\t/* read message id  */\n\n\t\t\tmsg_id=strtoul(&(network_line[strlen(\"MSGID: \")]), NULL, 10);\n\n\t\t\tp+=strlen(network_line);\n\n\n\t\t} else if ( !strncmp(network_line, \"Version: \", strlen(\"Version: \")) ) {\n\t\t\tchar *head = network_line, *end;\n\n\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"RECV: VERSION\");\n\n\t\t\tversion = strtoul(head + 9, &end, 10);\n\t\t\tif (!head[9] || *end)\n\t\t\t\tgoto failed;\n\n\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"VERSION=%d\", version);\n\n\t\t\tif (version < network_procotol_version) {\n\t\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_PROCESS, \"Forbidden VERSION=%d < %d, close connection to listener\", version, network_procotol_version);\n\t\t\t\tgoto close;\n\t\t\t} else if (version >= PROTOCOL_LAST) {\n\t\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_PROCESS, \"Future VERSION=%d\", version);\n\t\t\t\tversion = PROTOCOL_LAST - 1;\n\t\t\t}\n\t\t\tnetwork_client_set_version(fd, version);\n\t\t\t\n\t\t\t/* reset message id */\n\t\t\tmsg_id = UINT32_MAX;\n\n\t\t\tp+=strlen(network_line);\n\n\n\t\t} else if ( !strncmp(network_line, \"Capabilities: \", strlen(\"Capabilities: \")) ) {\n\n\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"RECV: Capabilities\");\n\n\t\t\tif ( version > PROTOCOL_UNKNOWN ) {\n\n\t\t\t\tmemset(string, 0, sizeof(string));\n\t\t\t\t\n\t\t\t\tsnprintf(string, sizeof(string), \"Version: %d\\nCapabilities: \\n\\n\", version);\n\n\t\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"SEND: %s\", string);\n\n\t\t\t\twrite(fd, string, strlen(string));\n\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"Capabilities recv, but no version line\");\n\t\t\t\t\n\t\t\t}\n\n\t\t\tp+=strlen(network_line);\n\n\n\t\t} else if ( !strncmp(network_line, \"GET_DN \", strlen(\"GET_DN \")) && msg_id != UINT32_MAX && network_client_get_version(fd) > 0) {\n\n\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"RECV: GET_DN\");\n\n\t\t\tid=strtoul(&(network_line[strlen(\"GET_DN \")]), NULL, 10);\n\n\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"id: %ld\",id);\n\n\t\t\tif ( id <= notify_last_id.id) {\n\n\t\t\t\tchar *dn_string = NULL;\n\n\t\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"try to read %ld from cache\", id);\n\n\t\t\t\t/* try to read from cache */\n\t\t\t\tif ( (dn_string = notifier_cache_get(id)) == NULL ) {\n\n\t\t\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"%ld not found in cache\", id);\n\n\t\t\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"%ld get one dn\", id);\n\n\t\t\t\t\t/* read from transaction file, because not in cache */\n\t\t\t\t\tif( (dn_string=notify_transcation_get_one_dn ( id )) == NULL ) {\n\n\t\t\t\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"%ld failed \", id);\n\t\t\t\t\t\t/* TODO: maybe close connection? */\n\n\t\t\t\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ERROR, \"%d failed, close connection to listener \", fd);\n\t\t\t\t\t\tclose(fd);\n\t\t\t\t\t\tFD_CLR(fd, &readfds);\n\t\t\t\t\t\tremove(fd);\n\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( dn_string != NULL ) {\n\n\t\t\t\t\tsnprintf(string, sizeof(string), \"MSGID: %ld\\n%s\\n\\n\",msg_id,dn_string);\n\n\t\t\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"--> %d: [%s]\",fd, string);\n\n\t\t\t\t\twrite(fd, string, strlen(string));\n\n\t\t\t\t\tfree(dn_string);\n\n\t\t\t\t}\n\n\n\t\t\t} else {\n\t\t\t\t/* set wanted id */\n\n\t\t\t\tnetwork_client_set_next_id(fd, id);\n\t\t\t\tnetwork_client_set_msg_id(fd, msg_id);\n\n\t\t\t}\n\n\t\t\tp+=strlen(network_line)+1;\n\t\t\tmsg_id = UINT32_MAX;\n\n\t\t} else if (!strncmp(p, \"WAIT_ID \", 8) && msg_id != UINT32_MAX && version >= PROTOCOL_3) {\n\t\t\tchar *head = network_line, *end;\n\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"RECV: WAIT_ID\");\n\t\t\tid = strtoul(head + 8, &end, 10);\n\t\t\tif (!head[8] || *end)\n\t\t\t\tgoto failed;\n\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"id: %ld\", id);\n\n\t\t\tif (id <= notify_last_id.id) {\n\t\t\t\tsnprintf(string, sizeof(string), \"MSGID: %ld\\n%ld\\n\\n\", msg_id, notify_last_id.id);\n\t\t\t\twrite(fd, string, strlen(string));\n\t\t\t} else {\n\t\t\t\t/* set wanted id */\n\t\t\t\tnetwork_client_set_next_id(fd, id);\n\t\t\t\tnetwork_client_set_msg_id(fd, msg_id);\n\t\t\t}\n\n\t\t\tp += strlen(network_line) + 1;\n\t\t\tmsg_id = UINT32_MAX;\n\n\t\t} else if ( !strncmp(network_line, \"GET_ID\", strlen(\"GET_ID\")) && msg_id != UINT32_MAX  && network_client_get_version(fd) > 0) {\n\n\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"RECV: GET_ID\");\n\n\t\t\tmemset(string, 0, sizeof(string));\n\n\t\t\tsnprintf(string, sizeof(string), \"MSGID: %ld\\n%ld\\n\\n\",msg_id,notify_last_id.id);\n\n\t\t\twrite(fd, string, strlen(string));\n\n\t\t\tp+=strlen(network_line)+1;\n\t\t\tmsg_id = UINT32_MAX;\n\n\n\t\t} else if ( !strncmp(network_line, \"GET_SCHEMA_ID\", strlen(\"GET_SCHEMA_ID\")) && msg_id != UINT32_MAX  && network_client_get_version(fd) > 0) {\n\n\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"RECV: GET_SCHEMA_ID\");\n\n\t\t\tmemset(string, 0, sizeof(string));\n\n\t\t\tsnprintf(string, sizeof(string), \"MSGID: %ld\\n%ld\\n\\n\",msg_id,SCHEMA_ID);\n\n\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"--> %d: [%s]\",fd, string);\n\n\t\t\twrite(fd, string, strlen(string));\n\n\t\t\tp+=strlen(network_line)+1;\n\t\t\tmsg_id = UINT32_MAX;\n\n\n\t\t} else if ( !strncmp(network_line, \"ALIVE\", strlen(\"ALIVE\")) && msg_id != UINT32_MAX  && network_client_get_version(fd) > 0) {\n\n\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"RECV: ALIVE\");\n\n\t\t\tsnprintf(string, sizeof(string), \"MSGID: %ld\\nOKAY\\n\\n\",msg_id);\n\n\t\t\twrite(fd, string, strlen(string));\n\n\t\t\tp+=strlen(network_line)+1;\n\t\t\tmsg_id = UINT32_MAX;\n\n\t\t} else {\n\n\t\t\tp+=strlen(network_line);\n\n\t\t\tif (strlen(network_line) == 0 ) {\n\t\t\t\tp+=1;\n \t\t\t} else {\n\t\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ERROR, \"Drop package [%s]\", network_line);\n\t\t\t}\n\n\t\t}\n\t}\n\tv_sem(sem_id);\n\n\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"END Package\");\n\t\n\n\tnetwork_client_dump ();\n\n\treturn 0;\n\nfailed:\n\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_PROCESS, \"Failed parsing [%s]\", p);\nclose:\n\tclose(fd);\n\tFD_CLR(fd, &readfds);\n\tremove(fd);\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148774,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "int data_on_connection(int fd, callback_remove_handler remove)\n{\n\tint nread;\n\tchar *network_packet;\n\tchar network_line[8192];\n\tchar *p;\n\tunsigned long id;\n\n\tchar string[1024];\n\tunsigned long msg_id = UINT32_MAX;\n\tenum network_protocol version = network_client_get_version(fd);\n\n\tioctl(fd, FIONREAD, &nread);\n\n\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"new connection data = %d\\n\",nread);\n\n\tif(nread == 0)\n\t{\n\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_PROCESS, \"%d failed, got 0 close connection to listener \", fd);\n\t\tclose(fd);\n\t\tFD_CLR(fd, &readfds);\n\t\tremove(fd);\n\t\tnetwork_client_dump ();\n\t\treturn 0;\n\t}\n\n\n\tif ( nread >= 8192 ) {\n\n\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ERROR, \"%d failed, more than 8192 close connection to listener \", fd);\n\t\tclose(fd);\n\t\tFD_CLR(fd, &readfds);\n\t\tremove(fd);\n\n\t\treturn 0;\n\t}\n\n\t/* read the whole package */\n\tnetwork_packet=malloc((nread+1) * sizeof(char));\n\tread(fd, network_packet, nread);\n\tnetwork_packet[nread]='\\0';\n\n\tmemset(network_line, 0, 8192);\n\tp=network_packet;\n\tp_sem(sem_id);\n\n\twhile ( get_network_line(p, network_line) ) {\n\n\t\tif ( strlen(network_line) > 0 ) {\n\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"line = [%s]\",network_line);\n\t\t}\n\n\t\t\n\t\tif ( !strncmp(network_line, \"MSGID: \", strlen(\"MSGID: \")) ) {\n\t\t\t/* read message id  */\n\n\t\t\tmsg_id=strtoul(&(network_line[strlen(\"MSGID: \")]), NULL, 10);\n\n\t\t\tp+=strlen(network_line);\n\n\n\t\t} else if ( !strncmp(network_line, \"Version: \", strlen(\"Version: \")) ) {\n\t\t\tchar *head = network_line, *end;\n\n\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"RECV: VERSION\");\n\n\t\t\tversion = strtoul(head + 9, &end, 10);\n\t\t\tif (!head[9] || *end)\n\t\t\t\tgoto failed;\n\n\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"VERSION=%d\", version);\n\n\t\t\tif (version < network_procotol_version) {\n\t\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_PROCESS, \"Forbidden VERSION=%d < %d, close connection to listener\", version, network_procotol_version);\n\t\t\t\tgoto close;\n\t\t\t} else if (version >= PROTOCOL_LAST) {\n\t\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_PROCESS, \"Future VERSION=%d\", version);\n\t\t\t\tversion = PROTOCOL_LAST - 1;\n\t\t\t}\n\t\t\tnetwork_client_set_version(fd, version);\n\t\t\t\n\t\t\t/* reset message id */\n\t\t\tmsg_id = UINT32_MAX;\n\n\t\t\tp+=strlen(network_line);\n\n\n\t\t} else if ( !strncmp(network_line, \"Capabilities: \", strlen(\"Capabilities: \")) ) {\n\n\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"RECV: Capabilities\");\n\n\t\t\tif ( version > PROTOCOL_UNKNOWN ) {\n\n\t\t\t\tmemset(string, 0, sizeof(string));\n\t\t\t\t\n\t\t\t\tsnprintf(string, sizeof(string), \"Version: %d\\nCapabilities: \\n\\n\", version);\n\n\t\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"SEND: %s\", string);\n\n\t\t\t\twrite(fd, string, strlen(string));\n\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"Capabilities recv, but no version line\");\n\t\t\t\t\n\t\t\t}\n\n\t\t\tp+=strlen(network_line);\n\n\n\t\t} else if ( !strncmp(network_line, \"GET_DN \", strlen(\"GET_DN \")) && msg_id != UINT32_MAX && version > PROTOCOL_UNKNOWN && version < PROTOCOL_3) {\n\n\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"RECV: GET_DN\");\n\n\t\t\tid=strtoul(&(network_line[strlen(\"GET_DN \")]), NULL, 10);\n\n\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"id: %ld\",id);\n\n\t\t\tif ( id <= notify_last_id.id) {\n\n\t\t\t\tchar *dn_string = NULL;\n\n\t\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"try to read %ld from cache\", id);\n\n\t\t\t\t/* try to read from cache */\n\t\t\t\tif ( (dn_string = notifier_cache_get(id)) == NULL ) {\n\n\t\t\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"%ld not found in cache\", id);\n\n\t\t\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"%ld get one dn\", id);\n\n\t\t\t\t\t/* read from transaction file, because not in cache */\n\t\t\t\t\tif( (dn_string=notify_transcation_get_one_dn ( id )) == NULL ) {\n\n\t\t\t\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"%ld failed \", id);\n\t\t\t\t\t\t/* TODO: maybe close connection? */\n\n\t\t\t\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ERROR, \"%d failed, close connection to listener \", fd);\n\t\t\t\t\t\tclose(fd);\n\t\t\t\t\t\tFD_CLR(fd, &readfds);\n\t\t\t\t\t\tremove(fd);\n\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( dn_string != NULL ) {\n\n\t\t\t\t\tsnprintf(string, sizeof(string), \"MSGID: %ld\\n%s\\n\\n\",msg_id,dn_string);\n\n\t\t\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"--> %d: [%s]\",fd, string);\n\n\t\t\t\t\twrite(fd, string, strlen(string));\n\n\t\t\t\t\tfree(dn_string);\n\n\t\t\t\t}\n\n\n\t\t\t} else {\n\t\t\t\t/* set wanted id */\n\n\t\t\t\tnetwork_client_set_next_id(fd, id);\n\t\t\t\tnetwork_client_set_msg_id(fd, msg_id);\n\n\t\t\t}\n\n\t\t\tp+=strlen(network_line)+1;\n\t\t\tmsg_id = UINT32_MAX;\n\n\t\t} else if (!strncmp(p, \"WAIT_ID \", 8) && msg_id != UINT32_MAX && version >= PROTOCOL_3) {\n\t\t\tchar *head = network_line, *end;\n\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"RECV: WAIT_ID\");\n\t\t\tid = strtoul(head + 8, &end, 10);\n\t\t\tif (!head[8] || *end)\n\t\t\t\tgoto failed;\n\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"id: %ld\", id);\n\n\t\t\tif (id <= notify_last_id.id) {\n\t\t\t\tsnprintf(string, sizeof(string), \"MSGID: %ld\\n%ld\\n\\n\", msg_id, notify_last_id.id);\n\t\t\t\twrite(fd, string, strlen(string));\n\t\t\t} else {\n\t\t\t\t/* set wanted id */\n\t\t\t\tnetwork_client_set_next_id(fd, id);\n\t\t\t\tnetwork_client_set_msg_id(fd, msg_id);\n\t\t\t}\n\n\t\t\tp += strlen(network_line) + 1;\n\t\t\tmsg_id = UINT32_MAX;\n\n\t\t} else if ( !strncmp(network_line, \"GET_ID\", strlen(\"GET_ID\")) && msg_id != UINT32_MAX  && network_client_get_version(fd) > 0) {\n\n\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"RECV: GET_ID\");\n\n\t\t\tmemset(string, 0, sizeof(string));\n\n\t\t\tsnprintf(string, sizeof(string), \"MSGID: %ld\\n%ld\\n\\n\",msg_id,notify_last_id.id);\n\n\t\t\twrite(fd, string, strlen(string));\n\n\t\t\tp+=strlen(network_line)+1;\n\t\t\tmsg_id = UINT32_MAX;\n\n\n\t\t} else if ( !strncmp(network_line, \"GET_SCHEMA_ID\", strlen(\"GET_SCHEMA_ID\")) && msg_id != UINT32_MAX  && network_client_get_version(fd) > 0) {\n\n\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"RECV: GET_SCHEMA_ID\");\n\n\t\t\tmemset(string, 0, sizeof(string));\n\n\t\t\tsnprintf(string, sizeof(string), \"MSGID: %ld\\n%ld\\n\\n\",msg_id,SCHEMA_ID);\n\n\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"--> %d: [%s]\",fd, string);\n\n\t\t\twrite(fd, string, strlen(string));\n\n\t\t\tp+=strlen(network_line)+1;\n\t\t\tmsg_id = UINT32_MAX;\n\n\n\t\t} else if ( !strncmp(network_line, \"ALIVE\", strlen(\"ALIVE\")) && msg_id != UINT32_MAX  && network_client_get_version(fd) > 0) {\n\n\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"RECV: ALIVE\");\n\n\t\t\tsnprintf(string, sizeof(string), \"MSGID: %ld\\nOKAY\\n\\n\",msg_id);\n\n\t\t\twrite(fd, string, strlen(string));\n\n\t\t\tp+=strlen(network_line)+1;\n\t\t\tmsg_id = UINT32_MAX;\n\n\t\t} else {\n\n\t\t\tp+=strlen(network_line);\n\n\t\t\tif (strlen(network_line) == 0 ) {\n\t\t\t\tp+=1;\n \t\t\t} else {\n\t\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ERROR, \"Drop package [%s]\", network_line);\n\t\t\t}\n\n\t\t}\n\t}\n\tv_sem(sem_id);\n\n\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"END Package\");\n\t\n\n\tnetwork_client_dump ();\n\n\treturn 0;\n\nfailed:\n\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_PROCESS, \"Failed parsing [%s]\", p);\nclose:\n\tclose(fd);\n\tFD_CLR(fd, &readfds);\n\tremove(fd);\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148775,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,\r\n                                       const UBaseType_t uxItemSize,\r\n                                       const uint8_t ucQueueType )\r\n    {\r\n        Queue_t * pxNewQueue;\r\n        size_t xQueueSizeInBytes;\r\n        uint8_t * pucQueueStorage;\r\n\r\n        configASSERT( uxQueueLength > ( UBaseType_t ) 0 );\r\n\r\n        /* Allocate enough space to hold the maximum number of items that\r\n         * can be in the queue at any time.  It is valid for uxItemSize to be\r\n         * zero in the case the queue is used as a semaphore. */\r\n        xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */\r\n\r\n        /* Check for multiplication overflow. */\r\n        configASSERT( ( uxItemSize == 0 ) || ( uxQueueLength == ( xQueueSizeInBytes / uxItemSize ) ) );\r\n\r\n        /* Check for addition overflow. */\r\n        configASSERT( ( sizeof( Queue_t ) + xQueueSizeInBytes ) >  xQueueSizeInBytes );\r\n\r\n        /* Allocate the queue and storage area.  Justification for MISRA\r\n         * deviation as follows:  pvPortMalloc() always ensures returned memory\r\n         * blocks are aligned per the requirements of the MCU stack.  In this case\r\n         * pvPortMalloc() must return a pointer that is guaranteed to meet the\r\n         * alignment requirements of the Queue_t structure - which in this case\r\n         * is an int8_t *.  Therefore, whenever the stack alignment requirements\r\n         * are greater than or equal to the pointer to char requirements the cast\r\n         * is safe.  In other cases alignment requirements are not strict (one or\r\n         * two bytes). */\r\n        pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */\r\n\r\n        if( pxNewQueue != NULL )\r\n        {\r\n            /* Jump past the queue structure to find the location of the queue\r\n             * storage area. */\r\n            pucQueueStorage = ( uint8_t * ) pxNewQueue;\r\n            pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */\r\n\r\n            #if ( configSUPPORT_STATIC_ALLOCATION == 1 )\r\n                {\r\n                    /* Queues can be created either statically or dynamically, so\r\n                     * note this task was created dynamically in case it is later\r\n                     * deleted. */\r\n                    pxNewQueue->ucStaticallyAllocated = pdFALSE;\r\n                }\r\n            #endif /* configSUPPORT_STATIC_ALLOCATION */\r\n\r\n            prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );\r\n        }\r\n        else\r\n        {\r\n            traceQUEUE_CREATE_FAILED( ucQueueType );\r\n            mtCOVERAGE_TEST_MARKER();\r\n        }\r\n\r\n        return pxNewQueue;\r\n    }\r",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 133,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "int digest_generic_verify(struct digest *d, const unsigned char *md)\n{\n\tint ret;\n\tint len = digest_length(d);\n\tunsigned char *tmp;\n\n\ttmp = xmalloc(len);\n\n\tret = digest_final(d, tmp);\n\tif (ret)\n\t\tgoto end;\n\n\tif (crypto_memneq(md, tmp, len))\n\t\tret = -EINVAL;\n\telse\n\t\tret = 0;\nend:\n\tfree(tmp);\n\treturn ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 163,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "PJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_rpsi(\n\t\t\t\t\tconst void *buf,\n\t\t\t\t\tpj_size_t length,\n\t\t\t\t\tpjmedia_rtcp_fb_rpsi *rpsi)\n{\n    pjmedia_rtcp_fb_common *hdr = (pjmedia_rtcp_fb_common*) buf;\n    pj_uint8_t *p;\n    pj_uint8_t padlen;\n    pj_size_t rpsi_len;\n\n    PJ_ASSERT_RETURN(buf && rpsi, PJ_EINVAL);\n    PJ_ASSERT_RETURN(length >= sizeof(pjmedia_rtcp_fb_common), PJ_ETOOSMALL);\n\n    /* RPSI uses pt==RTCP_PSFB and FMT==3 */\n    if (hdr->rtcp_common.pt != RTCP_PSFB || hdr->rtcp_common.count != 3)\n\treturn PJ_ENOTFOUND;\n\n    if (hdr->rtcp_common.length < 3) {    \n        PJ_PERROR(3, (THIS_FILE, PJ_ETOOSMALL,\n                      \"Failed parsing FB RPSI, invalid header length\"));\n\treturn PJ_ETOOSMALL;\n    }\n\n    rpsi_len = (pj_ntohs((pj_uint16_t)hdr->rtcp_common.length)-2) * 4;\n    if (length < rpsi_len + 12)\n\treturn PJ_ETOOSMALL;\n\n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n    padlen = *p++;\n\n    if (padlen >= 32) {\n        PJ_PERROR(3, (THIS_FILE, PJ_ETOOBIG,\n                      \"Failed parsing FB RPSI, invalid RPSI padding len\"));\n\treturn PJ_ETOOBIG;\n    }\n\n    if ((rpsi_len * 8) < (unsigned)(16 + padlen)) {\n        PJ_PERROR(3, (THIS_FILE, PJ_ETOOSMALL,\n                      \"Failed parsing FB RPSI, invalid RPSI bit len\"));\n\treturn PJ_ETOOSMALL;\n    }\n\n    rpsi->pt = (*p++ & 0x7F);\n    rpsi->rpsi_bit_len = rpsi_len*8 - 16 - padlen;\n    pj_strset(&rpsi->rpsi, (char*)p, (rpsi->rpsi_bit_len + 7)/8);\n\n    return PJ_SUCCESS;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 233,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int check_passwd(unsigned char *passwd, size_t length)\n{\n\tstruct digest *d = NULL;\n\tunsigned char *passwd1_sum;\n\tunsigned char *passwd2_sum;\n\tint ret = 0;\n\tint hash_len;\n\n\tif (IS_ENABLED(CONFIG_PASSWD_CRYPTO_PBKDF2)) {\n\t\thash_len = PBKDF2_LENGTH;\n\t} else {\n\t\td = digest_alloc(PASSWD_SUM);\n\t\tif (!d) {\n\t\t\tpr_err(\"No such digest: %s\\n\",\n\t\t\t       PASSWD_SUM ? PASSWD_SUM : \"NULL\");\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\thash_len = digest_length(d);\n\t}\n\n\tpasswd1_sum = calloc(hash_len * 2, sizeof(unsigned char));\n\tif (!passwd1_sum)\n\t\treturn -ENOMEM;\n\n\tpasswd2_sum = passwd1_sum + hash_len;\n\n\tif (is_passwd_env_enable())\n\t\tret = read_env_passwd(passwd2_sum, hash_len);\n\telse if (is_passwd_default_enable())\n\t\tret = read_default_passwd(passwd2_sum, hash_len);\n\telse\n\t\tret = -EINVAL;\n\n\tif (ret < 0)\n\t\tgoto err;\n\n\tif (IS_ENABLED(CONFIG_PASSWD_CRYPTO_PBKDF2)) {\n\t\tchar *key = passwd2_sum + PBKDF2_SALT_LEN;\n\t\tchar *salt = passwd2_sum;\n\t\tint keylen = PBKDF2_LENGTH - PBKDF2_SALT_LEN;\n\n\t\tret = pkcs5_pbkdf2_hmac_sha1(passwd, length, salt,\n\t\t\tPBKDF2_SALT_LEN, PBKDF2_COUNT, keylen, passwd1_sum);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tif (!crypto_memneq(passwd1_sum, key, keylen))\n\t\t\tret = 1;\n\t} else {\n\t\tret = digest_digest(d, passwd, length, passwd1_sum);\n\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tif (!crypto_memneq(passwd1_sum, passwd2_sum, hash_len))\n\t\t\tret = 1;\n\t}\n\nerr:\n\tfree(passwd1_sum);\n\tdigest_free(d);\n\n\treturn ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 290,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int elo_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tstruct elo_priv *priv;\n\tint ret;\n\tstruct usb_device *udev;\n\n\tif (!hid_is_usb(hdev))\n\t\treturn -EINVAL;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tINIT_DELAYED_WORK(&priv->work, elo_work);\n\tudev = interface_to_usbdev(to_usb_interface(hdev->dev.parent));\n\tpriv->usbdev = usb_get_dev(udev);\n\n\thid_set_drvdata(hdev, priv);\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\tgoto err_free;\n\t}\n\n\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\tif (ret) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\tgoto err_free;\n\t}\n\n\tif (elo_broken_firmware(priv->usbdev)) {\n\t\thid_info(hdev, \"broken firmware found, installing workaround\\n\");\n\t\tqueue_delayed_work(wq, &priv->work, ELO_PERIODIC_READ_INTERVAL);\n\t}\n\n\treturn 0;\nerr_free:\n\tusb_put_dev(udev);\n\tkfree(priv);\n\treturn ret;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 356,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static int __tipc_sendmsg(struct socket *sock, struct msghdr *m, size_t dlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct net *net = sock_net(sk);\n\tstruct tipc_sock *tsk = tipc_sk(sk);\n\tstruct tipc_uaddr *ua = (struct tipc_uaddr *)m->msg_name;\n\tlong timeout = sock_sndtimeo(sk, m->msg_flags & MSG_DONTWAIT);\n\tstruct list_head *clinks = &tsk->cong_links;\n\tbool syn = !tipc_sk_type_connectionless(sk);\n\tstruct tipc_group *grp = tsk->group;\n\tstruct tipc_msg *hdr = &tsk->phdr;\n\tstruct tipc_socket_addr skaddr;\n\tstruct sk_buff_head pkts;\n\tint atype, mtu, rc;\n\n\tif (unlikely(dlen > TIPC_MAX_USER_MSG_SIZE))\n\t\treturn -EMSGSIZE;\n\n\tif (ua) {\n\t\tif (!tipc_uaddr_valid(ua, m->msg_namelen))\n\t\t\treturn -EINVAL;\n\t\tatype = ua->addrtype;\n\t}\n\n\t/* If socket belongs to a communication group follow other paths */\n\tif (grp) {\n\t\tif (!ua)\n\t\t\treturn tipc_send_group_bcast(sock, m, dlen, timeout);\n\t\tif (atype == TIPC_SERVICE_ADDR)\n\t\t\treturn tipc_send_group_anycast(sock, m, dlen, timeout);\n\t\tif (atype == TIPC_SOCKET_ADDR)\n\t\t\treturn tipc_send_group_unicast(sock, m, dlen, timeout);\n\t\tif (atype == TIPC_SERVICE_RANGE)\n\t\t\treturn tipc_send_group_mcast(sock, m, dlen, timeout);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!ua) {\n\t\tua = (struct tipc_uaddr *)&tsk->peer;\n\t\tif (!syn && ua->family != AF_TIPC)\n\t\t\treturn -EDESTADDRREQ;\n\t\tatype = ua->addrtype;\n\t}\n\n\tif (unlikely(syn)) {\n\t\tif (sk->sk_state == TIPC_LISTEN)\n\t\t\treturn -EPIPE;\n\t\tif (sk->sk_state != TIPC_OPEN)\n\t\t\treturn -EISCONN;\n\t\tif (tsk->published)\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (atype == TIPC_SERVICE_ADDR)\n\t\t\ttsk->conn_addrtype = atype;\n\t\tmsg_set_syn(hdr, 1);\n\t}\n\n\tmemset(&skaddr, 0, sizeof(skaddr));\n\n\t/* Determine destination */\n\tif (atype == TIPC_SERVICE_RANGE) {\n\t\treturn tipc_sendmcast(sock, ua, m, dlen, timeout);\n\t} else if (atype == TIPC_SERVICE_ADDR) {\n\t\tskaddr.node = ua->lookup_node;\n\t\tua->scope = tipc_node2scope(skaddr.node);\n\t\tif (!tipc_nametbl_lookup_anycast(net, ua, &skaddr))\n\t\t\treturn -EHOSTUNREACH;\n\t} else if (atype == TIPC_SOCKET_ADDR) {\n\t\tskaddr = ua->sk;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Block or return if destination link is congested */\n\trc = tipc_wait_for_cond(sock, &timeout,\n\t\t\t\t!tipc_dest_find(clinks, skaddr.node, 0));\n\tif (unlikely(rc))\n\t\treturn rc;\n\n\t/* Finally build message header */\n\tmsg_set_destnode(hdr, skaddr.node);\n\tmsg_set_destport(hdr, skaddr.ref);\n\tif (atype == TIPC_SERVICE_ADDR) {\n\t\tmsg_set_type(hdr, TIPC_NAMED_MSG);\n\t\tmsg_set_hdr_sz(hdr, NAMED_H_SIZE);\n\t\tmsg_set_nametype(hdr, ua->sa.type);\n\t\tmsg_set_nameinst(hdr, ua->sa.instance);\n\t\tmsg_set_lookup_scope(hdr, ua->scope);\n\t} else { /* TIPC_SOCKET_ADDR */\n\t\tmsg_set_type(hdr, TIPC_DIRECT_MSG);\n\t\tmsg_set_lookup_scope(hdr, 0);\n\t\tmsg_set_hdr_sz(hdr, BASIC_H_SIZE);\n\t}\n\n\t/* Add message body */\n\t__skb_queue_head_init(&pkts);\n\tmtu = tipc_node_get_mtu(net, skaddr.node, tsk->portid, true);\n\trc = tipc_msg_build(hdr, m, 0, dlen, mtu, &pkts);\n\tif (unlikely(rc != dlen))\n\t\treturn rc;\n\tif (unlikely(syn && !tipc_msg_skb_clone(&pkts, &sk->sk_write_queue))) {\n\t\t__skb_queue_purge(&pkts);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Send message */\n\ttrace_tipc_sk_sendmsg(sk, skb_peek(&pkts), TIPC_DUMP_SK_SNDQ, \" \");\n\trc = tipc_node_xmit(net, &pkts, skaddr.node, tsk->portid);\n\tif (unlikely(rc == -ELINKCONG)) {\n\t\ttipc_dest_push(clinks, skaddr.node, 0);\n\t\ttsk->cong_link_cnt++;\n\t\trc = 0;\n\t}\n\n\tif (unlikely(syn && !rc)) {\n\t\ttipc_set_sk_state(sk, TIPC_CONNECTING);\n\t\tif (dlen && timeout) {\n\t\t\ttimeout = msecs_to_jiffies(timeout);\n\t\t\ttipc_wait_for_connect(sock, &timeout);\n\t\t}\n\t}\n\n\treturn rc ? rc : dlen;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 358,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset,\n\tstruct inode **i)\n{\n\tsquashfs_dir_header_3 dirh;\n\tchar buffer[sizeof(squashfs_dir_entry_3) + SQUASHFS_NAME_LEN + 1]\n\t\t__attribute__((aligned));\n\tsquashfs_dir_entry_3 *dire = (squashfs_dir_entry_3 *) buffer;\n\tlong long start;\n\tint bytes = 0;\n\tint dir_count, size, res;\n\tstruct dir_ent *ent, *cur_ent = NULL;\n\tstruct dir *dir;\n\n\tTRACE(\"squashfs_opendir: inode start block %d, offset %d\\n\",\n\t\tblock_start, offset);\n\n\t*i = read_inode(block_start, offset);\n\n\tdir = malloc(sizeof(struct dir));\n\tif(dir == NULL)\n\t\tMEM_ERROR();\n\n\tdir->dir_count = 0;\n\tdir->cur_entry = NULL;\n\tdir->mode = (*i)->mode;\n\tdir->uid = (*i)->uid;\n\tdir->guid = (*i)->gid;\n\tdir->mtime = (*i)->time;\n\tdir->xattr = (*i)->xattr;\n\tdir->dirs = NULL;\n\n\tif ((*i)->data == 3)\n\t\t/*\n\t\t * if the directory is empty, skip the unnecessary\n\t\t * lookup_entry, this fixes the corner case with\n\t\t * completely empty filesystems where lookup_entry correctly\n\t\t * returning -1 is incorrectly treated as an error\n\t\t */\n\t\treturn dir;\n\n\tstart = sBlk.s.directory_table_start + (*i)->start;\n\toffset = (*i)->offset;\n\tsize = (*i)->data + bytes - 3;\n\n\twhile(bytes < size) {\t\t\t\n\t\tif(swap) {\n\t\t\tsquashfs_dir_header_3 sdirh;\n\t\t\tres = read_directory_data(&sdirh, &start, &offset, sizeof(sdirh));\n\t\t\tif(res)\n\t\t\t\tSQUASHFS_SWAP_DIR_HEADER_3(&dirh, &sdirh);\n\t\t} else\n\t\t\tres = read_directory_data(&dirh, &start, &offset, sizeof(dirh));\n\t\n\t\tif(res == FALSE)\n\t\t\tgoto corrupted;\n\n\t\tdir_count = dirh.count + 1;\n\t\tTRACE(\"squashfs_opendir: Read directory header @ byte position \"\n\t\t\t\"%d, %d directory entries\\n\", bytes, dir_count);\n\t\tbytes += sizeof(dirh);\n\n\t\t/* dir_count should never be larger than SQUASHFS_DIR_COUNT */\n\t\tif(dir_count > SQUASHFS_DIR_COUNT) {\n\t\t\tERROR(\"File system corrupted: too many entries in directory\\n\");\n\t\t\tgoto corrupted;\n\t\t}\n\n\t\twhile(dir_count--) {\n\t\t\tif(swap) {\n\t\t\t\tsquashfs_dir_entry_3 sdire;\n\t\t\t\tres = read_directory_data(&sdire, &start,\n\t\t\t\t\t&offset, sizeof(sdire));\n\t\t\t\tif(res)\n\t\t\t\t\tSQUASHFS_SWAP_DIR_ENTRY_3(dire, &sdire);\n\t\t\t} else\n\t\t\t\tres = read_directory_data(dire, &start,\n\t\t\t\t\t&offset, sizeof(*dire));\n\n\t\t\tif(res == FALSE)\n\t\t\t\tgoto corrupted;\n\n\t\t\tbytes += sizeof(*dire);\n\n\t\t\t/* size should never be SQUASHFS_NAME_LEN or larger */\n\t\t\tif(dire->size >= SQUASHFS_NAME_LEN) {\n\t\t\t\tERROR(\"File system corrupted: filename too long\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tres = read_directory_data(dire->name, &start, &offset,\n\t\t\t\t\t\t\t\tdire->size + 1);\n\n\t\t\tif(res == FALSE)\n\t\t\t\tgoto corrupted;\n\n\t\t\tdire->name[dire->size + 1] = '\\0';\n\n\t\t\t/* check name for invalid characters (i.e /, ., ..) */\n\t\t\tif(check_name(dire->name, dire->size + 1) == FALSE) {\n\t\t\t\tERROR(\"File system corrupted: invalid characters in name\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tTRACE(\"squashfs_opendir: directory entry %s, inode \"\n\t\t\t\t\"%d:%d, type %d\\n\", dire->name,\n\t\t\t\tdirh.start_block, dire->offset, dire->type);\n\n\t\t\tent = malloc(sizeof(struct dir_ent));\n\t\t\tif(ent == NULL)\n\t\t\t\tMEM_ERROR();\n\n\t\t\tent->name = strdup(dire->name);\n\t\t\tent->start_block = dirh.start_block;\n\t\t\tent->offset = dire->offset;\n\t\t\tent->type = dire->type;\n\t\t\tent->next = NULL;\n\t\t\tif(cur_ent == NULL)\n\t\t\t\tdir->dirs = ent;\n\t\t\telse\n\t\t\t\tcur_ent->next = ent;\n\t\t\tcur_ent = ent;\n\t\t\tdir->dir_count ++;\n\t\t\tbytes += dire->size + 1;\n\t\t}\n\t}\n\n\t/* check directory for duplicate names and sorting */\n\tif(check_directory(dir) == FALSE) {\n\t\tERROR(\"File system corrupted: directory has duplicate names or is unsorted\\n\");\n\t\tgoto corrupted;\n\t}\n\n\treturn dir;\n\ncorrupted:\n\tsquashfs_closedir(dir);\n\treturn NULL;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 438,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset,\n\tstruct inode **i)\n{\n\tsquashfs_dir_header_3 dirh;\n\tchar buffer[sizeof(squashfs_dir_entry_3) + SQUASHFS_NAME_LEN + 1]\n\t\t__attribute__((aligned));\n\tsquashfs_dir_entry_3 *dire = (squashfs_dir_entry_3 *) buffer;\n\tlong long start;\n\tint bytes = 0;\n\tint dir_count, size, res;\n\tstruct dir_ent *ent, *cur_ent = NULL;\n\tstruct dir *dir;\n\n\tTRACE(\"squashfs_opendir: inode start block %d, offset %d\\n\",\n\t\tblock_start, offset);\n\n\t*i = read_inode(block_start, offset);\n\n\tdir = malloc(sizeof(struct dir));\n\tif(dir == NULL)\n\t\tMEM_ERROR();\n\n\tdir->dir_count = 0;\n\tdir->cur_entry = NULL;\n\tdir->mode = (*i)->mode;\n\tdir->uid = (*i)->uid;\n\tdir->guid = (*i)->gid;\n\tdir->mtime = (*i)->time;\n\tdir->xattr = (*i)->xattr;\n\tdir->dirs = NULL;\n\n\tif ((*i)->data == 3)\n\t\t/*\n\t\t * if the directory is empty, skip the unnecessary\n\t\t * lookup_entry, this fixes the corner case with\n\t\t * completely empty filesystems where lookup_entry correctly\n\t\t * returning -1 is incorrectly treated as an error\n\t\t */\n\t\treturn dir;\n\n\tstart = sBlk.s.directory_table_start + (*i)->start;\n\toffset = (*i)->offset;\n\tsize = (*i)->data + bytes - 3;\n\n\twhile(bytes < size) {\t\t\t\n\t\tif(swap) {\n\t\t\tsquashfs_dir_header_3 sdirh;\n\t\t\tres = read_directory_data(&sdirh, &start, &offset, sizeof(sdirh));\n\t\t\tif(res)\n\t\t\t\tSQUASHFS_SWAP_DIR_HEADER_3(&dirh, &sdirh);\n\t\t} else\n\t\t\tres = read_directory_data(&dirh, &start, &offset, sizeof(dirh));\n\t\n\t\tif(res == FALSE)\n\t\t\tgoto corrupted;\n\n\t\tdir_count = dirh.count + 1;\n\t\tTRACE(\"squashfs_opendir: Read directory header @ byte position \"\n\t\t\t\"%d, %d directory entries\\n\", bytes, dir_count);\n\t\tbytes += sizeof(dirh);\n\n\t\t/* dir_count should never be larger than SQUASHFS_DIR_COUNT */\n\t\tif(dir_count > SQUASHFS_DIR_COUNT) {\n\t\t\tERROR(\"File system corrupted: too many entries in directory\\n\");\n\t\t\tgoto corrupted;\n\t\t}\n\n\t\twhile(dir_count--) {\n\t\t\tif(swap) {\n\t\t\t\tsquashfs_dir_entry_3 sdire;\n\t\t\t\tres = read_directory_data(&sdire, &start,\n\t\t\t\t\t&offset, sizeof(sdire));\n\t\t\t\tif(res)\n\t\t\t\t\tSQUASHFS_SWAP_DIR_ENTRY_3(dire, &sdire);\n\t\t\t} else\n\t\t\t\tres = read_directory_data(dire, &start,\n\t\t\t\t\t&offset, sizeof(*dire));\n\n\t\t\tif(res == FALSE)\n\t\t\t\tgoto corrupted;\n\n\t\t\tbytes += sizeof(*dire);\n\n\t\t\t/* size should never be SQUASHFS_NAME_LEN or larger */\n\t\t\tif(dire->size >= SQUASHFS_NAME_LEN) {\n\t\t\t\tERROR(\"File system corrupted: filename too long\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tres = read_directory_data(dire->name, &start, &offset,\n\t\t\t\t\t\t\t\tdire->size + 1);\n\n\t\t\tif(res == FALSE)\n\t\t\t\tgoto corrupted;\n\n\t\t\tdire->name[dire->size + 1] = '\\0';\n\n\t\t\t/* check name for invalid characters (i.e /, ., ..) */\n\t\t\tif(check_name(dire->name, dire->size + 1) == FALSE) {\n\t\t\t\tERROR(\"File system corrupted: invalid characters in name\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tTRACE(\"squashfs_opendir: directory entry %s, inode \"\n\t\t\t\t\"%d:%d, type %d\\n\", dire->name,\n\t\t\t\tdirh.start_block, dire->offset, dire->type);\n\n\t\t\tent = malloc(sizeof(struct dir_ent));\n\t\t\tif(ent == NULL)\n\t\t\t\tMEM_ERROR();\n\n\t\t\tent->name = strdup(dire->name);\n\t\t\tent->start_block = dirh.start_block;\n\t\t\tent->offset = dire->offset;\n\t\t\tent->type = dire->type;\n\t\t\tent->next = NULL;\n\t\t\tif(cur_ent == NULL)\n\t\t\t\tdir->dirs = ent;\n\t\t\telse\n\t\t\t\tcur_ent->next = ent;\n\t\t\tcur_ent = ent;\n\t\t\tdir->dir_count ++;\n\t\t\tbytes += dire->size + 1;\n\t\t}\n\t}\n\n\t/* check directory for duplicate names and sorting */\n\tif(check_directory(dir) == FALSE) {\n\t\tERROR(\"File system corrupted: directory has duplicate names or is unsorted\\n\");\n\t\tgoto corrupted;\n\t}\n\n\treturn dir;\n\ncorrupted:\n\tsquashfs_closedir(dir);\n\treturn NULL;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 440,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset,\n\tstruct inode **i)\n{\n\tstruct squashfs_dir_header dirh;\n\tchar buffer[sizeof(struct squashfs_dir_entry) + SQUASHFS_NAME_LEN + 1]\n\t\t__attribute__((aligned));\n\tstruct squashfs_dir_entry *dire = (struct squashfs_dir_entry *) buffer;\n\tlong long start;\n\tint bytes = 0, dir_count, size, res;\n\tstruct dir_ent *ent, *cur_ent = NULL;\n\tstruct dir *dir;\n\n\tTRACE(\"squashfs_opendir: inode start block %d, offset %d\\n\",\n\t\tblock_start, offset);\n\n\t*i = read_inode(block_start, offset);\n\n\tdir = malloc(sizeof(struct dir));\n\tif(dir == NULL)\n\t\tMEM_ERROR();\n\n\tdir->dir_count = 0;\n\tdir->cur_entry = NULL;\n\tdir->mode = (*i)->mode;\n\tdir->uid = (*i)->uid;\n\tdir->guid = (*i)->gid;\n\tdir->mtime = (*i)->time;\n\tdir->xattr = (*i)->xattr;\n\tdir->dirs = NULL;\n\n\tif ((*i)->data == 3)\n\t\t/*\n\t\t * if the directory is empty, skip the unnecessary\n\t\t * lookup_entry, this fixes the corner case with\n\t\t * completely empty filesystems where lookup_entry correctly\n\t\t * returning -1 is incorrectly treated as an error\n\t\t */\n\t\treturn dir;\n\n\tstart = sBlk.s.directory_table_start + (*i)->start;\n\toffset = (*i)->offset;\n\tsize = (*i)->data + bytes - 3;\n\n\twhile(bytes < size) {\t\t\t\n\t\tres = read_directory_data(&dirh, &start, &offset, sizeof(dirh));\n\t\tif(res == FALSE)\n\t\t\tgoto corrupted;\n\n\t\tSQUASHFS_INSWAP_DIR_HEADER(&dirh);\n\t\n\t\tdir_count = dirh.count + 1;\n\t\tTRACE(\"squashfs_opendir: Read directory header @ byte position \"\n\t\t\t\"%d, %d directory entries\\n\", bytes, dir_count);\n\t\tbytes += sizeof(dirh);\n\n\t\t/* dir_count should never be larger than SQUASHFS_DIR_COUNT */\n\t\tif(dir_count > SQUASHFS_DIR_COUNT) {\n\t\t\tERROR(\"File system corrupted: too many entries in directory\\n\");\n\t\t\tgoto corrupted;\n\t\t}\n\n\t\twhile(dir_count--) {\n\t\t\tres = read_directory_data(dire, &start, &offset, sizeof(*dire));\n\t\t\tif(res == FALSE)\n\t\t\t\tgoto corrupted;\n\n\t\t\tSQUASHFS_INSWAP_DIR_ENTRY(dire);\n\n\t\t\tbytes += sizeof(*dire);\n\n\t\t\t/* size should never be SQUASHFS_NAME_LEN or larger */\n\t\t\tif(dire->size >= SQUASHFS_NAME_LEN) {\n\t\t\t\tERROR(\"File system corrupted: filename too long\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tres = read_directory_data(dire->name, &start, &offset,\n\t\t\t\t\t\t\t\tdire->size + 1);\n\t\t\tif(res == FALSE)\n\t\t\t\tgoto corrupted;\n\n\t\t\tdire->name[dire->size + 1] = '\\0';\n\n\t\t\t/* check name for invalid characters (i.e /, ., ..) */\n\t\t\tif(check_name(dire->name, dire->size + 1) == FALSE) {\n\t\t\t\tERROR(\"File system corrupted: invalid characters in name\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tTRACE(\"squashfs_opendir: directory entry %s, inode \"\n\t\t\t\t\"%d:%d, type %d\\n\", dire->name,\n\t\t\t\tdirh.start_block, dire->offset, dire->type);\n\n\t\t\tent = malloc(sizeof(struct dir_ent));\n\t\t\tif(ent == NULL)\n\t\t\t\tMEM_ERROR();\n\n\t\t\tent->name = strdup(dire->name);\n\t\t\tent->start_block = dirh.start_block;\n\t\t\tent->offset = dire->offset;\n\t\t\tent->type = dire->type;\n\t\t\tent->next = NULL;\n\t\t\tif(cur_ent == NULL)\n\t\t\t\tdir->dirs = ent;\n\t\t\telse\n\t\t\t\tcur_ent->next = ent;\n\t\t\tcur_ent = ent;\n\t\t\tdir->dir_count ++;\n\t\t\tbytes += dire->size + 1;\n\t\t}\n\t}\n\n\t/* check directory for duplicate names and sorting */\n\tif(check_directory(dir) == FALSE) {\n\t\tERROR(\"File system corrupted: directory has duplicate names or is unsorted\\n\");\n\t\tgoto corrupted;\n\t}\n\n\treturn dir;\n\ncorrupted:\n\tsquashfs_closedir(dir);\n\treturn NULL;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 442,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "struct vfsmount *clone_private_mount(const struct path *path)\n{\n\tstruct mount *old_mnt = real_mount(path->mnt);\n\tstruct mount *new_mnt;\n\n\tdown_read(&namespace_sem);\n\tif (IS_MNT_UNBINDABLE(old_mnt))\n\t\tgoto invalid;\n\n\tif (!check_mnt(old_mnt))\n\t\tgoto invalid;\n\n\tif (has_locked_children(old_mnt, path->dentry))\n\t\tgoto invalid;\n\n\tnew_mnt = clone_mnt(old_mnt, path->dentry, CL_PRIVATE);\n\tup_read(&namespace_sem);\n\n\tif (IS_ERR(new_mnt))\n\t\treturn ERR_CAST(new_mnt);\n\n\t/* Longterm mount to be removed by kern_unmount*() */\n\tnew_mnt->mnt_ns = MNT_NS_INTERNAL;\n\n\treturn &new_mnt->mnt;\n\ninvalid:\n\tup_read(&namespace_sem);\n\treturn ERR_PTR(-EINVAL);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 478,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "gpg_ctx_add_recipient (struct _GpgCtx *gpg,\n                       const gchar *keyid)\n{\n\tgchar *safe_keyid;\n\n\tif (gpg->mode != GPG_CTX_MODE_ENCRYPT && gpg->mode != GPG_CTX_MODE_EXPORT)\n\t\treturn;\n\n\tif (!gpg->recipients)\n\t\tgpg->recipients = g_ptr_array_new ();\n\n\tg_return_if_fail (keyid != NULL);\n\n\t/* If the recipient looks like an email address,\n\t * enclose it in brackets to ensure an exact match. */\n\tif (strchr (keyid, '@') != NULL) {\n\t\tsafe_keyid = g_strdup_printf (\"<%s>\", keyid);\n\t} else {\n\t\tsafe_keyid = g_strdup (keyid);\n\t}\n\n\tg_ptr_array_add (gpg->recipients, safe_keyid);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 490,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "PHP_FUNCTION(openssl_decrypt)\n{\n\tzend_bool raw_input = 0;\n\tchar *data, *method, *password, *iv = \"\";\n\tint data_len, method_len, password_len, iv_len = 0;\n\tconst EVP_CIPHER *cipher_type;\n\tEVP_CIPHER_CTX cipher_ctx;\n\tint i, outlen, keylen;\n\tunsigned char *outbuf, *key;\n\tint base64_str_len;\n\tchar *base64_str = NULL;\n\tzend_bool free_iv;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"sss|bs\", &data, &data_len, &method, &method_len, &password, &password_len, &raw_input, &iv, &iv_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (!method_len) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unknown cipher algorithm\");\n\t\tRETURN_FALSE;\n\t}\n\n\tcipher_type = EVP_get_cipherbyname(method);\n\tif (!cipher_type) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unknown cipher algorithm\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (!raw_input) {\n\t\tbase64_str = (char*)php_base64_decode((unsigned char*)data, data_len, &base64_str_len);\n\t\tdata_len = base64_str_len;\n\t\tdata = base64_str;\n\t}\n\n\tkeylen = EVP_CIPHER_key_length(cipher_type);\n\tif (keylen > password_len) {\n\t\tkey = emalloc(keylen);\n\t\tmemset(key, 0, keylen);\n\t\tmemcpy(key, password, password_len);\n\t} else {\n\t\tkey = (unsigned char*)password;\n\t}\n\n\tfree_iv = php_openssl_validate_iv(&iv, &iv_len, EVP_CIPHER_iv_length(cipher_type) TSRMLS_CC);\n\n\toutlen = data_len + EVP_CIPHER_block_size(cipher_type);\n\toutbuf = emalloc(outlen + 1);\n\n\tEVP_DecryptInit(&cipher_ctx, cipher_type, NULL, NULL);\n\tif (password_len > keylen) {\n\t\tEVP_CIPHER_CTX_set_key_length(&cipher_ctx, password_len);\n\t}\n\tEVP_DecryptInit_ex(&cipher_ctx, NULL, NULL, key, (unsigned char *)iv);\n\tEVP_DecryptUpdate(&cipher_ctx, outbuf, &i, (unsigned char *)data, data_len);\n\toutlen = i;\n\tif (EVP_DecryptFinal(&cipher_ctx, (unsigned char *)outbuf + i, &i)) {\n\t\toutlen += i;\n\t\toutbuf[outlen] = '\\0';\n\t\tRETVAL_STRINGL((char *)outbuf, outlen, 0);\n\t} else {\n\t\tefree(outbuf);\n\t\tRETVAL_FALSE;\n\t}\n\tif (key != (unsigned char*)password) {\n\t\tefree(key);\n\t}\n\tif (free_iv) {\n\t\tefree(iv);\n\t}\n\tif (base64_str) {\n\t\tefree(base64_str);\n\t}\n \tEVP_CIPHER_CTX_cleanup(&cipher_ctx);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 548,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "void add_interrupt_randomness(int irq, int irq_flags)\n{\n\tstruct entropy_store\t*r;\n\tstruct fast_pool\t*fast_pool = this_cpu_ptr(&irq_randomness);\n\tstruct pt_regs\t\t*regs = get_irq_regs();\n\tunsigned long\t\tnow = jiffies;\n\tcycles_t\t\tcycles = random_get_entropy();\n\t__u32\t\t\tc_high, j_high;\n\t__u64\t\t\tip;\n\tunsigned long\t\tseed;\n\tint\t\t\tcredit = 0;\n\n\tif (cycles == 0)\n\t\tcycles = get_reg(fast_pool, regs);\n\tc_high = (sizeof(cycles) > 4) ? cycles >> 32 : 0;\n\tj_high = (sizeof(now) > 4) ? now >> 32 : 0;\n\tfast_pool->pool[0] ^= cycles ^ j_high ^ irq;\n\tfast_pool->pool[1] ^= now ^ c_high;\n\tip = regs ? instruction_pointer(regs) : _RET_IP_;\n\tfast_pool->pool[2] ^= ip;\n\tfast_pool->pool[3] ^= (sizeof(ip) > 4) ? ip >> 32 :\n\t\tget_reg(fast_pool, regs);\n\n\tfast_mix(fast_pool);\n\tadd_interrupt_bench(cycles);\n\tthis_cpu_add(net_rand_state.s1, fast_pool->pool[cycles & 3]);\n\n\tif (unlikely(crng_init == 0)) {\n\t\tif ((fast_pool->count >= 64) &&\n\t\t    crng_fast_load((char *) fast_pool->pool,\n\t\t\t\t   sizeof(fast_pool->pool))) {\n\t\t\tfast_pool->count = 0;\n\t\t\tfast_pool->last = now;\n\t\t}\n\t\treturn;\n\t}\n\n\tif ((fast_pool->count < 64) &&\n\t    !time_after(now, fast_pool->last + HZ))\n\t\treturn;\n\n\tr = &input_pool;\n\tif (!spin_trylock(&r->lock))\n\t\treturn;\n\n\tfast_pool->last = now;\n\t__mix_pool_bytes(r, &fast_pool->pool, sizeof(fast_pool->pool));\n\n\t/*\n\t * If we have architectural seed generator, produce a seed and\n\t * add it to the pool.  For the sake of paranoia don't let the\n\t * architectural seed generator dominate the input from the\n\t * interrupt noise.\n\t */\n\tif (arch_get_random_seed_long(&seed)) {\n\t\t__mix_pool_bytes(r, &seed, sizeof(seed));\n\t\tcredit = 1;\n\t}\n\tspin_unlock(&r->lock);\n\n\tfast_pool->count = 0;\n\n\t/* award one bit for the contents of the fast pool */\n\tcredit_entropy_bits(r, credit + 1);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 552,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "void update_process_times(int user_tick)\n{\n\tstruct task_struct *p = current;\n\n\t/* Note: this timer irq context must be accounted for as well. */\n\taccount_process_tick(p, user_tick);\n\trun_local_timers();\n\trcu_sched_clock_irq(user_tick);\n#ifdef CONFIG_IRQ_WORK\n\tif (in_irq())\n\t\tirq_work_tick();\n#endif\n\tscheduler_tick();\n\tif (IS_ENABLED(CONFIG_POSIX_TIMERS))\n\t\trun_posix_cpu_timers();\n\n\t/* The current CPU might make use of net randoms without receiving IRQs\n\t * to renew them often enough. Let's update the net_rand_state from a\n\t * non-constant value that's not affine to the number of calls to make\n\t * sure it's updated when there's some activity (we don't care in idle).\n\t */\n\tthis_cpu_add(net_rand_state.s1, rol32(jiffies, 24) + user_tick);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 554,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "int main(int argc, char **argv)\n{\n\tint c, rc = MOUNT_EX_SUCCESS, all = 0, show_labels = 0;\n\tstruct libmnt_context *cxt;\n\tstruct libmnt_table *fstab = NULL;\n\tchar *srcbuf = NULL;\n\tchar *types = NULL;\n\tunsigned long oper = 0;\n\n\tenum {\n\t\tMOUNT_OPT_SHARED = CHAR_MAX + 1,\n\t\tMOUNT_OPT_SLAVE,\n\t\tMOUNT_OPT_PRIVATE,\n\t\tMOUNT_OPT_UNBINDABLE,\n\t\tMOUNT_OPT_RSHARED,\n\t\tMOUNT_OPT_RSLAVE,\n\t\tMOUNT_OPT_RPRIVATE,\n\t\tMOUNT_OPT_RUNBINDABLE,\n\t\tMOUNT_OPT_TARGET,\n\t\tMOUNT_OPT_SOURCE\n\t};\n\n\tstatic const struct option longopts[] = {\n\t\t{ \"all\", 0, 0, 'a' },\n\t\t{ \"fake\", 0, 0, 'f' },\n\t\t{ \"fstab\", 1, 0, 'T' },\n\t\t{ \"fork\", 0, 0, 'F' },\n\t\t{ \"help\", 0, 0, 'h' },\n\t\t{ \"no-mtab\", 0, 0, 'n' },\n\t\t{ \"read-only\", 0, 0, 'r' },\n\t\t{ \"ro\", 0, 0, 'r' },\n\t\t{ \"verbose\", 0, 0, 'v' },\n\t\t{ \"version\", 0, 0, 'V' },\n\t\t{ \"read-write\", 0, 0, 'w' },\n\t\t{ \"rw\", 0, 0, 'w' },\n\t\t{ \"options\", 1, 0, 'o' },\n\t\t{ \"test-opts\", 1, 0, 'O' },\n\t\t{ \"pass-fd\", 1, 0, 'p' },\n\t\t{ \"types\", 1, 0, 't' },\n\t\t{ \"uuid\", 1, 0, 'U' },\n\t\t{ \"label\", 1, 0, 'L'},\n\t\t{ \"bind\", 0, 0, 'B' },\n\t\t{ \"move\", 0, 0, 'M' },\n\t\t{ \"rbind\", 0, 0, 'R' },\n\t\t{ \"make-shared\", 0, 0, MOUNT_OPT_SHARED },\n\t\t{ \"make-slave\", 0, 0, MOUNT_OPT_SLAVE },\n\t\t{ \"make-private\", 0, 0, MOUNT_OPT_PRIVATE },\n\t\t{ \"make-unbindable\", 0, 0, MOUNT_OPT_UNBINDABLE },\n\t\t{ \"make-rshared\", 0, 0, MOUNT_OPT_RSHARED },\n\t\t{ \"make-rslave\", 0, 0, MOUNT_OPT_RSLAVE },\n\t\t{ \"make-rprivate\", 0, 0, MOUNT_OPT_RPRIVATE },\n\t\t{ \"make-runbindable\", 0, 0, MOUNT_OPT_RUNBINDABLE },\n\t\t{ \"no-canonicalize\", 0, 0, 'c' },\n\t\t{ \"internal-only\", 0, 0, 'i' },\n\t\t{ \"show-labels\", 0, 0, 'l' },\n\t\t{ \"target\", 1, 0, MOUNT_OPT_TARGET },\n\t\t{ \"source\", 1, 0, MOUNT_OPT_SOURCE },\n\t\t{ NULL, 0, 0, 0 }\n\t};\n\n\tstatic const ul_excl_t excl[] = {       /* rows and cols in in ASCII order */\n\t\t{ 'B','M','R',\t\t\t/* bind,move,rbind */\n\t\t   MOUNT_OPT_SHARED,   MOUNT_OPT_SLAVE,\n\t\t   MOUNT_OPT_PRIVATE,  MOUNT_OPT_UNBINDABLE,\n\t\t   MOUNT_OPT_RSHARED,  MOUNT_OPT_RSLAVE,\n\t\t   MOUNT_OPT_RPRIVATE, MOUNT_OPT_RUNBINDABLE },\n\n\t\t{ 'L','U', MOUNT_OPT_SOURCE },\t/* label,uuid,source */\n\t\t{ 0 }\n\t};\n\tint excl_st[ARRAY_SIZE(excl)] = UL_EXCL_STATUS_INIT;\n\n\tsanitize_env();\n\tsetlocale(LC_ALL, \"\");\n\tbindtextdomain(PACKAGE, LOCALEDIR);\n\ttextdomain(PACKAGE);\n\tatexit(close_stdout);\n\n\tmnt_init_debug(0);\n\tcxt = mnt_new_context();\n\tif (!cxt)\n\t\terr(MOUNT_EX_SYSERR, _(\"libmount context allocation failed\"));\n\n\tmnt_context_set_tables_errcb(cxt, table_parser_errcb);\n\n\twhile ((c = getopt_long(argc, argv, \"aBcfFhilL:Mno:O:p:rRsU:vVwt:T:\",\n\t\t\t\t\tlongopts, NULL)) != -1) {\n\n\t\t/* only few options are allowed for non-root users */\n\t\tif (mnt_context_is_restricted(cxt) &&\n\t\t    !strchr(\"hlLUVvpris\", c) &&\n\t\t    c != MOUNT_OPT_TARGET &&\n\t\t    c != MOUNT_OPT_SOURCE)\n\t\t\texit_non_root(option_to_longopt(c, longopts));\n\n\t\terr_exclusive_options(c, longopts, excl, excl_st);\n\n\t\tswitch(c) {\n\t\tcase 'a':\n\t\t\tall = 1;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tmnt_context_disable_canonicalize(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tmnt_context_enable_fake(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tmnt_context_enable_fork(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage(stdout);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tmnt_context_disable_helpers(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tmnt_context_disable_mtab(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tif (mnt_context_append_options(cxt, \"ro\"))\n\t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to append options\"));\n\t\t\treadwrite = 0;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tmnt_context_enable_verbose(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tprint_version();\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tif (mnt_context_append_options(cxt, \"rw\"))\n\t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to append options\"));\n\t\t\treadwrite = 1;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tif (mnt_context_append_options(cxt, optarg))\n\t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to append options\"));\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tif (mnt_context_set_options_pattern(cxt, optarg))\n\t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to set options pattern\"));\n\t\t\tbreak;\n\t\tcase 'p':\n                        warnx(_(\"--pass-fd is no longer supported\"));\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\txasprintf(&srcbuf, \"LABEL=\\\"%s\\\"\", optarg);\n\t\t\tmnt_context_disable_swapmatch(cxt, 1);\n\t\t\tmnt_context_set_source(cxt, srcbuf);\n\t\t\tfree(srcbuf);\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\txasprintf(&srcbuf, \"UUID=\\\"%s\\\"\", optarg);\n\t\t\tmnt_context_disable_swapmatch(cxt, 1);\n\t\t\tmnt_context_set_source(cxt, srcbuf);\n\t\t\tfree(srcbuf);\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tshow_labels = 1;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\ttypes = optarg;\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tfstab = append_fstab(cxt, fstab, optarg);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tmnt_context_enable_sloppy(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\toper |= MS_BIND;\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\toper |= MS_MOVE;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\toper |= (MS_BIND | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_SHARED:\n\t\t\toper |= MS_SHARED;\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_SLAVE:\n\t\t\toper |= MS_SLAVE;\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_PRIVATE:\n\t\t\toper |= MS_PRIVATE;\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_UNBINDABLE:\n\t\t\toper |= MS_UNBINDABLE;\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_RSHARED:\n\t\t\toper |= (MS_SHARED | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_RSLAVE:\n\t\t\toper |= (MS_SLAVE | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_RPRIVATE:\n\t\t\toper |= (MS_PRIVATE | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_RUNBINDABLE:\n\t\t\toper |= (MS_UNBINDABLE | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_TARGET:\n\t\t\tmnt_context_disable_swapmatch(cxt, 1);\n\t\t\tmnt_context_set_target(cxt, optarg);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_SOURCE:\n\t\t\tmnt_context_disable_swapmatch(cxt, 1);\n\t\t\tmnt_context_set_source(cxt, optarg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage(stderr);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\tif (fstab && !mnt_context_is_nocanonicalize(cxt)) {\n\t\t/*\n\t\t * We have external (context independent) fstab instance, let's\n\t\t * make a connection between the fstab and the canonicalization\n\t\t * cache.\n\t\t */\n\t\tstruct libmnt_cache *cache = mnt_context_get_cache(cxt);\n\t\tmnt_table_set_cache(fstab, cache);\n\t}\n\n\tif (!mnt_context_get_source(cxt) &&\n\t    !mnt_context_get_target(cxt) &&\n\t    !argc &&\n\t    !all) {\n\t\tif (oper)\n\t\t\tusage(stderr);\n\t\tprint_all(cxt, types, show_labels);\n\t\tgoto done;\n\t}\n\n\tif (oper && (types || all || mnt_context_get_source(cxt)))\n\t\tusage(stderr);\n\n\tif (types && (all || strchr(types, ',') ||\n\t\t\t     strncmp(types, \"no\", 2) == 0))\n\t\tmnt_context_set_fstype_pattern(cxt, types);\n\telse if (types)\n\t\tmnt_context_set_fstype(cxt, types);\n\n\tif (all) {\n\t\t/*\n\t\t * A) Mount all\n\t\t */\n\t\trc = mount_all(cxt);\n\t\tgoto done;\n\n\t} else if (argc == 0 && (mnt_context_get_source(cxt) ||\n\t\t\t\t mnt_context_get_target(cxt))) {\n\t\t/*\n\t\t * B) mount -L|-U|--source|--target\n\t\t */\n\t\tif (mnt_context_is_restricted(cxt) &&\n\t\t    mnt_context_get_source(cxt) &&\n\t\t    mnt_context_get_target(cxt))\n\t\t\texit_non_root(NULL);\n\n\t} else if (argc == 1) {\n\t\t/*\n\t\t * C) mount [-L|-U|--source] <target>\n\t\t *    mount <source|target>\n\t\t *\n\t\t * non-root may specify source *or* target, but not both\n\t\t */\n\t\tif (mnt_context_is_restricted(cxt) &&\n\t\t    mnt_context_get_source(cxt))\n\t\t\texit_non_root(NULL);\n\n\t\tmnt_context_set_target(cxt, argv[0]);\n\n\t} else if (argc == 2 && !mnt_context_get_source(cxt)\n\t\t\t     && !mnt_context_get_target(cxt)) {\n\t\t/*\n\t\t * D) mount <source> <target>\n\t\t */\n\t\tif (mnt_context_is_restricted(cxt))\n\t\t\texit_non_root(NULL);\n\t\tmnt_context_set_source(cxt, argv[0]);\n\t\tmnt_context_set_target(cxt, argv[1]);\n\n\t} else\n\t\tusage(stderr);\n\n\tif (mnt_context_is_restricted(cxt))\n\t\tsanitize_paths(cxt);\n\n\tif (oper) {\n\t\t/* MS_PROPAGATION operations, let's set the mount flags */\n\t\tmnt_context_set_mflags(cxt, oper);\n\n\t\t/* For -make* or --bind is fstab unnecessary */\n\t\tmnt_context_set_optsmode(cxt, MNT_OMODE_NOTAB);\n\t}\n\n\trc = mnt_context_mount(cxt);\n\trc = mk_exit_code(cxt, rc);\n\n\tif (rc == MOUNT_EX_SUCCESS && mnt_context_is_verbose(cxt))\n\t\tsuccess_message(cxt);\ndone:\n\tmnt_free_context(cxt);\n\tmnt_free_table(fstab);\n\treturn rc;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 562,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  },
  {
    "CWE_ID": [
      "CWE-200"
    ],
    "code": "win_redr_status(win_T *wp, int ignore_pum UNUSED)\n{\n    int\t\trow;\n    char_u\t*p;\n    int\t\tlen;\n    int\t\tfillchar;\n    int\t\tattr;\n    int\t\tthis_ru_col;\n    static int  busy = FALSE;\n\n    // It's possible to get here recursively when 'statusline' (indirectly)\n    // invokes \":redrawstatus\".  Simply ignore the call then.\n    if (busy)\n\treturn;\n    busy = TRUE;\n\n    row = statusline_row(wp);\n\n    wp->w_redr_status = FALSE;\n    if (wp->w_status_height == 0)\n    {\n\t// no status line, can only be last window\n\tredraw_cmdline = TRUE;\n    }\n    else if (!redrawing()\n\t    // don't update status line when popup menu is visible and may be\n\t    // drawn over it, unless it will be redrawn later\n\t    || (!ignore_pum && pum_visible()))\n    {\n\t// Don't redraw right now, do it later.\n\twp->w_redr_status = TRUE;\n    }\n#ifdef FEAT_STL_OPT\n    else if (*p_stl != NUL || *wp->w_p_stl != NUL)\n    {\n\t// redraw custom status line\n\tredraw_custom_statusline(wp);\n    }\n#endif\n    else\n    {\n\tfillchar = fillchar_status(&attr, wp);\n\n\tget_trans_bufname(wp->w_buffer);\n\tp = NameBuff;\n\tlen = (int)STRLEN(p);\n\n\tif ((bt_help(wp->w_buffer)\n#ifdef FEAT_QUICKFIX\n\t\t    || wp->w_p_pvw\n#endif\n\t\t    || bufIsChanged(wp->w_buffer)\n\t\t    || wp->w_buffer->b_p_ro)\n\t\t&& len < MAXPATHL - 1)\n\t    *(p + len++) = ' ';\n\tif (bt_help(wp->w_buffer))\n\t{\n\t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", _(\"[Help]\"));\n\t    len += (int)STRLEN(p + len);\n\t}\n#ifdef FEAT_QUICKFIX\n\tif (wp->w_p_pvw)\n\t{\n\t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", _(\"[Preview]\"));\n\t    len += (int)STRLEN(p + len);\n\t}\n#endif\n\tif (bufIsChanged(wp->w_buffer)\n#ifdef FEAT_TERMINAL\n\t\t&& !bt_terminal(wp->w_buffer)\n#endif\n\t\t)\n\t{\n\t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", \"[+]\");\n\t    len += (int)STRLEN(p + len);\n\t}\n\tif (wp->w_buffer->b_p_ro)\n\t{\n\t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", _(\"[RO]\"));\n\t    len += (int)STRLEN(p + len);\n\t}\n\n\tthis_ru_col = ru_col - (Columns - wp->w_width);\n\tif (this_ru_col < (wp->w_width + 1) / 2)\n\t    this_ru_col = (wp->w_width + 1) / 2;\n\tif (this_ru_col <= 1)\n\t{\n\t    p = (char_u *)\"<\";\t\t// No room for file name!\n\t    len = 1;\n\t}\n\telse if (has_mbyte)\n\t{\n\t    int\tclen = 0, i;\n\n\t    // Count total number of display cells.\n\t    clen = mb_string2cells(p, -1);\n\n\t    // Find first character that will fit.\n\t    // Going from start to end is much faster for DBCS.\n\t    for (i = 0; p[i] != NUL && clen >= this_ru_col - 1;\n\t\t    i += (*mb_ptr2len)(p + i))\n\t\tclen -= (*mb_ptr2cells)(p + i);\n\t    len = clen;\n\t    if (i > 0)\n\t    {\n\t\tp = p + i - 1;\n\t\t*p = '<';\n\t\t++len;\n\t    }\n\n\t}\n\telse if (len > this_ru_col - 1)\n\t{\n\t    p += len - (this_ru_col - 1);\n\t    *p = '<';\n\t    len = this_ru_col - 1;\n\t}\n\n\tscreen_puts(p, row, wp->w_wincol, attr);\n\tscreen_fill(row, row + 1, len + wp->w_wincol,\n\t\t\tthis_ru_col + wp->w_wincol, fillchar, fillchar, attr);\n\n\tif (get_keymap_str(wp, (char_u *)\"<%s>\", NameBuff, MAXPATHL)\n\t\t&& (int)(this_ru_col - len) > (int)(STRLEN(NameBuff) + 1))\n\t    screen_puts(NameBuff, row, (int)(this_ru_col - STRLEN(NameBuff)\n\t\t\t\t\t\t   - 1 + wp->w_wincol), attr);\n\n#ifdef FEAT_CMDL_INFO\n\twin_redr_ruler(wp, TRUE, ignore_pum);\n#endif\n    }\n\n    /*\n     * May need to draw the character below the vertical separator.\n     */\n    if (wp->w_vsep_width != 0 && wp->w_status_height != 0 && redrawing())\n    {\n\tif (stl_connected(wp))\n\t    fillchar = fillchar_status(&attr, wp);\n\telse\n\t    fillchar = fillchar_vsep(&attr);\n\tscreen_putchar(fillchar, row, W_ENDCOL(wp), attr);\n    }\n    busy = FALSE;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 660,
    "RELATED_CWE": [
      "CWE-284",
      "CWE-285",
      "CWE-287"
    ]
  }
]