[
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_vryxadpu()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    else\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_xomkdmem()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n    }\n    else\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n    }\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n    else\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_kzpinbtk()\n{\n    f_vryxadpu();\n    f_xomkdmem();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_kzpinbtk();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400736,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_12.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_dtnrdwsj()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    else\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n    }\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_dtnrdwsj();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400737,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_12.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_jmeaccdn()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    else\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_blkbistx()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n        \n        strcpy(password, \"Password1234!\");\n    }\n    else\n    {\n        \n        strcpy(password, \"Password1234!\");\n    }\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n    else\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_ritmcdbi()\n{\n    f_jmeaccdn();\n    f_blkbistx();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ritmcdbi();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400738,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_12.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_binfihei()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    else\n    {\n        \n        strcpy(password, \"Password1234!\");\n    }\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_binfihei();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400739,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_12.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_jasvarvj()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    switch(6)\n    {\n    case 6:\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = strlen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(password, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(password, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        HCRYPTPROV hCryptProv = 0;\n        HCRYPTHASH hHash = 0;\n        HCRYPTKEY hKey = 0;\n        char hashData[100] = HASH_INPUT;\n        HANDLE pHandle;\n        char * username = \"User\";\n        char * domain = \"Domain\";\n        do\n        {\n            BYTE payload[(100 - 1) * sizeof(char)]; \n            DWORD payloadBytes;\n            \n            payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n            \n            SecureZeroMemory(password, 100 * sizeof(char));\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                break;\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                break;\n            }\n            \n            if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n            {\n                break;\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                break;\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n            {\n                break;\n            }\n            \n            memcpy(password, payload, payloadBytes);\n            password[payloadBytes / sizeof(char)] = '\\0';\n        }\n        while (0);\n        if (hKey)\n        {\n            CryptDestroyKey(hKey);\n        }\n        if (hHash)\n        {\n            CryptDestroyHash(hHash);\n        }\n        if (hCryptProv)\n        {\n            CryptReleaseContext(hCryptProv, 0);\n        }\n        \n        if (LogonUserA(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n    break;\n    }\n}\n\n\nstatic void f_vofuenta()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    switch(6)\n    {\n    case 6:\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = strlen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(password, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(password, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n    {\n        HCRYPTPROV hCryptProv = 0;\n        HCRYPTHASH hHash = 0;\n        HCRYPTKEY hKey = 0;\n        char hashData[100] = HASH_INPUT;\n        HANDLE pHandle;\n        char * username = \"User\";\n        char * domain = \"Domain\";\n        do\n        {\n            BYTE payload[(100 - 1) * sizeof(char)]; \n            DWORD payloadBytes;\n            \n            payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n            \n            SecureZeroMemory(password, 100 * sizeof(char));\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                break;\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                break;\n            }\n            \n            if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n            {\n                break;\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                break;\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n            {\n                break;\n            }\n            \n            memcpy(password, payload, payloadBytes);\n            password[payloadBytes / sizeof(char)] = '\\0';\n        }\n        while (0);\n        if (hKey)\n        {\n            CryptDestroyKey(hKey);\n        }\n        if (hHash)\n        {\n            CryptDestroyHash(hHash);\n        }\n        if (hCryptProv)\n        {\n            CryptReleaseContext(hCryptProv, 0);\n        }\n        \n        if (LogonUserA(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_hhbabybh()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        strcpy(password, \"Password1234!\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n    {\n        HANDLE pHandle;\n        char * username = \"User\";\n        char * domain = \"Domain\";\n        \n        \n        if (LogonUserA(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_zxejhqys()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    switch(6)\n    {\n    case 6:\n        \n        strcpy(password, \"Password1234!\");\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n    {\n        HANDLE pHandle;\n        char * username = \"User\";\n        char * domain = \"Domain\";\n        \n        \n        if (LogonUserA(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\nvoid f_oihanfvj()\n{\n    f_jasvarvj();\n    f_vofuenta();\n    f_hhbabybh();\n    f_zxejhqys();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_oihanfvj();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400740,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_15.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_ziwcuhyi()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    switch(6)\n    {\n    case 6:\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = strlen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(password, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(password, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n    {\n        HANDLE pHandle;\n        char * username = \"User\";\n        char * domain = \"Domain\";\n        \n        \n        if (LogonUserA(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ziwcuhyi();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400741,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_15.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_audaapcz()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    switch(6)\n    {\n    case 6:\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        HCRYPTPROV hCryptProv = 0;\n        HCRYPTHASH hHash = 0;\n        HCRYPTKEY hKey = 0;\n        char hashData[100] = HASH_INPUT;\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        do\n        {\n            BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n            DWORD payloadBytes;\n            \n            payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n            \n            SecureZeroMemory(password, 100 * sizeof(wchar_t));\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                break;\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                break;\n            }\n            \n            if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n            {\n                break;\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                break;\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n            {\n                break;\n            }\n            \n            memcpy(password, payload, payloadBytes);\n            password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n        }\n        while (0);\n        if (hKey)\n        {\n            CryptDestroyKey(hKey);\n        }\n        if (hHash)\n        {\n            CryptDestroyHash(hHash);\n        }\n        if (hCryptProv)\n        {\n            CryptReleaseContext(hCryptProv, 0);\n        }\n        \n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n    break;\n    }\n}\n\n\nstatic void f_souiftfa()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    switch(6)\n    {\n    case 6:\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n    {\n        HCRYPTPROV hCryptProv = 0;\n        HCRYPTHASH hHash = 0;\n        HCRYPTKEY hKey = 0;\n        char hashData[100] = HASH_INPUT;\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        do\n        {\n            BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n            DWORD payloadBytes;\n            \n            payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n            \n            SecureZeroMemory(password, 100 * sizeof(wchar_t));\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                break;\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                break;\n            }\n            \n            if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n            {\n                break;\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                break;\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n            {\n                break;\n            }\n            \n            memcpy(password, payload, payloadBytes);\n            password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n        }\n        while (0);\n        if (hKey)\n        {\n            CryptDestroyKey(hKey);\n        }\n        if (hHash)\n        {\n            CryptDestroyHash(hHash);\n        }\n        if (hCryptProv)\n        {\n            CryptReleaseContext(hCryptProv, 0);\n        }\n        \n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_vfquucsw()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        wcscpy(password, L\"Password1234!\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n    {\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        \n        \n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_kqzofbrh()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    switch(6)\n    {\n    case 6:\n        \n        wcscpy(password, L\"Password1234!\");\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n    {\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        \n        \n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\nvoid f_wruwqxsu()\n{\n    f_audaapcz();\n    f_souiftfa();\n    f_vfquucsw();\n    f_kqzofbrh();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_wruwqxsu();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400742,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_15.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_wkwvirxw()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    switch(6)\n    {\n    case 6:\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n    {\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        \n        \n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_wkwvirxw();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400743,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_15.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_nrjxruzh()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    else\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_mqfuvvwk()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n    }\n    else\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n    }\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n    else\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_tfobxsba()\n{\n    f_nrjxruzh();\n    f_mqfuvvwk();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_tfobxsba();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400744,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_12.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_unxbtphw()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    else\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n    }\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_unxbtphw();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400745,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_12.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_mwqfbwxf()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    else\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_aenyfski()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n        \n        strcpy(password, \"Password1234!\");\n    }\n    else\n    {\n        \n        strcpy(password, \"Password1234!\");\n    }\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n    else\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_kspsxvgb()\n{\n    f_mwqfbwxf();\n    f_aenyfski();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_kspsxvgb();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400746,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_12.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_igopwbos()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    else\n    {\n        \n        strcpy(password, \"Password1234!\");\n    }\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_igopwbos();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400747,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_12.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\n\n\n\nstatic void f_jeuhjzbp()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(staticReturnsTrue())\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_ykhoquxu()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(staticReturnsTrue())\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(staticReturnsTrue())\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_ihcsilpm()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcpy(password, \"Password1234!\");\n    }\n    if(staticReturnsTrue())\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_hksfuulb()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(staticReturnsTrue())\n    {\n        \n        strcpy(password, \"Password1234!\");\n    }\n    if(staticReturnsTrue())\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_gguwnyel()\n{\n    f_jeuhjzbp();\n    f_ykhoquxu();\n    f_ihcsilpm();\n    f_hksfuulb();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_gguwnyel();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400748,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_08.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\n\nvoid f_dagjjdrg()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(staticReturnsTrue())\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(staticReturnsTrue())\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_dagjjdrg();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400749,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_08.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\n\n\n\nstatic void f_pfbghncj()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(staticReturnsTrue())\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_ezzofufg()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(staticReturnsTrue())\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(staticReturnsTrue())\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_ldsynyjx()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n    }\n    if(staticReturnsTrue())\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_ncaliusd()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(staticReturnsTrue())\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n    }\n    if(staticReturnsTrue())\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_nphuhfjn()\n{\n    f_pfbghncj();\n    f_ezzofufg();\n    f_ldsynyjx();\n    f_ncaliusd();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_nphuhfjn();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400750,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_08.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\n\nvoid f_irggttms()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(staticReturnsTrue())\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(staticReturnsTrue())\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_irggttms();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400751,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_08.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_jnfhknlo()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    switch(6)\n    {\n    case 6:\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            closesocket(connectSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        HCRYPTPROV hCryptProv = 0;\n        HCRYPTHASH hHash = 0;\n        HCRYPTKEY hKey = 0;\n        char hashData[100] = HASH_INPUT;\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        do\n        {\n            BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n            DWORD payloadBytes;\n            \n            payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n            \n            SecureZeroMemory(password, 100 * sizeof(wchar_t));\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                break;\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                break;\n            }\n            \n            if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n            {\n                break;\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                break;\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n            {\n                break;\n            }\n            \n            memcpy(password, payload, payloadBytes);\n            password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n        }\n        while (0);\n        if (hKey)\n        {\n            CryptDestroyKey(hKey);\n        }\n        if (hHash)\n        {\n            CryptDestroyHash(hHash);\n        }\n        if (hCryptProv)\n        {\n            CryptReleaseContext(hCryptProv, 0);\n        }\n        \n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n    break;\n    }\n}\n\n\nstatic void f_vefxnwyn()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    switch(6)\n    {\n    case 6:\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            closesocket(connectSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n    {\n        HCRYPTPROV hCryptProv = 0;\n        HCRYPTHASH hHash = 0;\n        HCRYPTKEY hKey = 0;\n        char hashData[100] = HASH_INPUT;\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        do\n        {\n            BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n            DWORD payloadBytes;\n            \n            payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n            \n            SecureZeroMemory(password, 100 * sizeof(wchar_t));\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                break;\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                break;\n            }\n            \n            if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n            {\n                break;\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                break;\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n            {\n                break;\n            }\n            \n            memcpy(password, payload, payloadBytes);\n            password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n        }\n        while (0);\n        if (hKey)\n        {\n            CryptDestroyKey(hKey);\n        }\n        if (hHash)\n        {\n            CryptDestroyHash(hHash);\n        }\n        if (hCryptProv)\n        {\n            CryptReleaseContext(hCryptProv, 0);\n        }\n        \n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_ufqszlmp()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        wcscpy(password, L\"Password1234!\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n    {\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        \n        \n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_gkeaakur()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    switch(6)\n    {\n    case 6:\n        \n        wcscpy(password, L\"Password1234!\");\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n    {\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        \n        \n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\nvoid f_iasotcvl()\n{\n    f_jnfhknlo();\n    f_vefxnwyn();\n    f_ufqszlmp();\n    f_gkeaakur();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_iasotcvl();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400752,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_15.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_mqjxpspu()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    switch(6)\n    {\n    case 6:\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            closesocket(connectSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n    {\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        \n        \n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_mqjxpspu();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400753,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_15.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_icxejnnz()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    switch(6)\n    {\n    case 6:\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t passwordLen = strlen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(password, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(password, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            closesocket(connectSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        HCRYPTPROV hCryptProv = 0;\n        HCRYPTHASH hHash = 0;\n        HCRYPTKEY hKey = 0;\n        char hashData[100] = HASH_INPUT;\n        HANDLE pHandle;\n        char * username = \"User\";\n        char * domain = \"Domain\";\n        do\n        {\n            BYTE payload[(100 - 1) * sizeof(char)]; \n            DWORD payloadBytes;\n            \n            payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n            \n            SecureZeroMemory(password, 100 * sizeof(char));\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                break;\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                break;\n            }\n            \n            if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n            {\n                break;\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                break;\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n            {\n                break;\n            }\n            \n            memcpy(password, payload, payloadBytes);\n            password[payloadBytes / sizeof(char)] = '\\0';\n        }\n        while (0);\n        if (hKey)\n        {\n            CryptDestroyKey(hKey);\n        }\n        if (hHash)\n        {\n            CryptDestroyHash(hHash);\n        }\n        if (hCryptProv)\n        {\n            CryptReleaseContext(hCryptProv, 0);\n        }\n        \n        if (LogonUserA(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n    break;\n    }\n}\n\n\nstatic void f_wbwejbbc()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    switch(6)\n    {\n    case 6:\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t passwordLen = strlen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(password, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(password, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            closesocket(connectSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n    {\n        HCRYPTPROV hCryptProv = 0;\n        HCRYPTHASH hHash = 0;\n        HCRYPTKEY hKey = 0;\n        char hashData[100] = HASH_INPUT;\n        HANDLE pHandle;\n        char * username = \"User\";\n        char * domain = \"Domain\";\n        do\n        {\n            BYTE payload[(100 - 1) * sizeof(char)]; \n            DWORD payloadBytes;\n            \n            payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n            \n            SecureZeroMemory(password, 100 * sizeof(char));\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                break;\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                break;\n            }\n            \n            if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n            {\n                break;\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                break;\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n            {\n                break;\n            }\n            \n            memcpy(password, payload, payloadBytes);\n            password[payloadBytes / sizeof(char)] = '\\0';\n        }\n        while (0);\n        if (hKey)\n        {\n            CryptDestroyKey(hKey);\n        }\n        if (hHash)\n        {\n            CryptDestroyHash(hHash);\n        }\n        if (hCryptProv)\n        {\n            CryptReleaseContext(hCryptProv, 0);\n        }\n        \n        if (LogonUserA(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_ednmcrbc()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        \n        strcpy(password, \"Password1234!\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n    {\n        HANDLE pHandle;\n        char * username = \"User\";\n        char * domain = \"Domain\";\n        \n        \n        if (LogonUserA(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\nstatic void f_kjfxcezu()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    switch(6)\n    {\n    case 6:\n        \n        strcpy(password, \"Password1234!\");\n        break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n    {\n        HANDLE pHandle;\n        char * username = \"User\";\n        char * domain = \"Domain\";\n        \n        \n        if (LogonUserA(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\nvoid f_ryaihwsm()\n{\n    f_icxejnnz();\n    f_wbwejbbc();\n    f_ednmcrbc();\n    f_kjfxcezu();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ryaihwsm();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400754,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_15.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_iwzfxrtt()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    switch(6)\n    {\n    case 6:\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t passwordLen = strlen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(password, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(password, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            closesocket(connectSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n    {\n        HANDLE pHandle;\n        char * username = \"User\";\n        char * domain = \"Domain\";\n        \n        \n        if (LogonUserA(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_iwzfxrtt();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400755,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_15.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\n\n\n\nstatic void f_wbatmmgd()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(STATIC_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_azqzajua()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_bwrlyjep()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(STATIC_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_souqcmhs()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(STATIC_CONST_TRUE)\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_ezuptgge()\n{\n    f_wbatmmgd();\n    f_azqzajua();\n    f_bwrlyjep();\n    f_souqcmhs();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ezuptgge();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400756,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_04.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\n\nvoid f_iuzhhpft()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_iuzhhpft();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400757,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_04.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\n\n\n\nstatic void f_csptdpsf()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(STATIC_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_djnvpczp()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_ukpmjulm()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(STATIC_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcpy(password, \"Password1234!\");\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_fldrbyww()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(STATIC_CONST_TRUE)\n    {\n        \n        strcpy(password, \"Password1234!\");\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_stegpftx()\n{\n    f_csptdpsf();\n    f_djnvpczp();\n    f_ukpmjulm();\n    f_fldrbyww();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_stegpftx();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400758,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_04.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\n\nvoid f_figpldyn()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_figpldyn();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400759,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_04.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\n\n\n\nstatic void f_vkumgogm()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(staticTrue)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_abzftsqg()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(staticTrue)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(staticTrue)\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_rtvrllul()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n    }\n    if(staticTrue)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_pndnuims()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(staticTrue)\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n    }\n    if(staticTrue)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_ceqcpqoe()\n{\n    f_vkumgogm();\n    f_abzftsqg();\n    f_rtvrllul();\n    f_pndnuims();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ceqcpqoe();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400760,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_05.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\n\nvoid f_qqyqwueu()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(staticTrue)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(staticTrue)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_qqyqwueu();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400761,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_05.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\n\n\n\nstatic void f_kgneyioy()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(staticTrue)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_ekfgmevp()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(staticTrue)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(staticTrue)\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_uuqywpbd()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcpy(password, \"Password1234!\");\n    }\n    if(staticTrue)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_tigbheqz()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(staticTrue)\n    {\n        \n        strcpy(password, \"Password1234!\");\n    }\n    if(staticTrue)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_jimcvvsb()\n{\n    f_kgneyioy();\n    f_ekfgmevp();\n    f_uuqywpbd();\n    f_tigbheqz();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_jimcvvsb();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400762,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_05.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\n\nvoid f_xasbimdy()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(staticTrue)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(staticTrue)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_xasbimdy();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400763,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_05.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nstatic const int STATIC_CONST_FIVE = 5;\n\n\n\n\nstatic void f_lvpevusg()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(STATIC_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_lehqrntl()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_ijuxrjpw()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(STATIC_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcpy(password, \"Password1234!\");\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_cunlqdpy()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        strcpy(password, \"Password1234!\");\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_sdcfujml()\n{\n    f_lvpevusg();\n    f_lehqrntl();\n    f_ijuxrjpw();\n    f_cunlqdpy();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_sdcfujml();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400764,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_06.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nstatic const int STATIC_CONST_FIVE = 5;\n\n\nvoid f_emsamwey()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_emsamwey();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400765,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_06.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nstatic const int STATIC_CONST_FIVE = 5;\n\n\n\n\nstatic void f_nxjspkkh()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(STATIC_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_igxehdsr()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_gklxefot()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(STATIC_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_tzdgnsvg()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_ruucgady()\n{\n    f_nxjspkkh();\n    f_igxehdsr();\n    f_gklxefot();\n    f_tzdgnsvg();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ruucgady();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400766,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_06.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nstatic const int STATIC_CONST_FIVE = 5;\n\n\nvoid f_doanjjvx()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_doanjjvx();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400767,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_06.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nstatic int staticFive = 5;\n\n\n\n\nstatic void f_tfuxkgtl()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(staticFive==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(staticFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_jcjvdswr()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(staticFive==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(staticFive==5)\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_dxavcery()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(staticFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n    }\n    if(staticFive==5)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_umtmrhea()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(staticFive==5)\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n    }\n    if(staticFive==5)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_nnmqgfsr()\n{\n    f_tfuxkgtl();\n    f_jcjvdswr();\n    f_dxavcery();\n    f_umtmrhea();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_nnmqgfsr();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400768,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_07.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nstatic int staticFive = 5;\n\n\nvoid f_mchfmizk()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(staticFive==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(staticFive==5)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_mchfmizk();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400769,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_07.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nstatic int staticFive = 5;\n\n\n\n\nstatic void f_jrhobaxe()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(staticFive==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(staticFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_nlqakhfl()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(staticFive==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(staticFive==5)\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_owvohhpa()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(staticFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcpy(password, \"Password1234!\");\n    }\n    if(staticFive==5)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_lttvdvlg()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(staticFive==5)\n    {\n        \n        strcpy(password, \"Password1234!\");\n    }\n    if(staticFive==5)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_ellavqcf()\n{\n    f_jrhobaxe();\n    f_nlqakhfl();\n    f_owvohhpa();\n    f_lttvdvlg();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ellavqcf();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400770,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_07.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nstatic int staticFive = 5;\n\n\nvoid f_socquigh()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(staticFive==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(staticFive==5)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_socquigh();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400771,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_07.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_wntyjtmo()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(GLOBAL_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_gylplmws()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_hbjgdkfr()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(GLOBAL_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcpy(password, \"Password1234!\");\n    }\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_ivclcdfx()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        \n        strcpy(password, \"Password1234!\");\n    }\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_norunhjz()\n{\n    f_wntyjtmo();\n    f_gylplmws();\n    f_hbjgdkfr();\n    f_ivclcdfx();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_norunhjz();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400772,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_09.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_gxkoycvo()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_gxkoycvo();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400773,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_09.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_akiuqfnf()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(1)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(0)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_nnprwkqp()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(1)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(1)\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_twsczzdx()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(0)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcpy(password, \"Password1234!\");\n    }\n    if(1)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_pjckafvp()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(1)\n    {\n        \n        strcpy(password, \"Password1234!\");\n    }\n    if(1)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_ozkmqzfy()\n{\n    f_akiuqfnf();\n    f_nnprwkqp();\n    f_twsczzdx();\n    f_pjckafvp();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ozkmqzfy();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400774,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_02.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_ztsbjeig()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(1)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(1)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ztsbjeig();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400775,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_02.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_sisghuht()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_oxrifify()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_msabtvye()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n    }\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_oycknbnv()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n    }\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_cvqedyrg()\n{\n    f_sisghuht();\n    f_oxrifify();\n    f_msabtvye();\n    f_oycknbnv();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_cvqedyrg();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400776,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_13.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_mnwuhfyl()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_mnwuhfyl();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400777,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_13.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_tlwxetxr()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(5==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(5!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_lqhsvgzr()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(5==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(5==5)\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_tmbarncu()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(5!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n    }\n    if(5==5)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_zhaocupc()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(5==5)\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n    }\n    if(5==5)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_xflquhrf()\n{\n    f_tlwxetxr();\n    f_lqhsvgzr();\n    f_tmbarncu();\n    f_zhaocupc();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_xflquhrf();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400778,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_03.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_nngrggjx()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(5==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(5==5)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_nngrggjx();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400779,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_03.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_jcyewrcc()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(globalTrue)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(globalFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_dickmgil()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(globalTrue)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(globalTrue)\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_yvheoiqw()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(globalFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n    }\n    if(globalTrue)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_kgsxjien()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(globalTrue)\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n    }\n    if(globalTrue)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_pavdurps()\n{\n    f_jcyewrcc();\n    f_dickmgil();\n    f_yvheoiqw();\n    f_kgsxjien();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_pavdurps();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400780,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_10.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_ssttkexk()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(globalTrue)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(globalTrue)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ssttkexk();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400781,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_10.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_kxodlfvy()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(globalFive==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(globalFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_pwtazhgk()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(globalFive==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(globalFive==5)\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_yldhpvve()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(globalFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n    }\n    if(globalFive==5)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_qtrathfc()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(globalFive==5)\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n    }\n    if(globalFive==5)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_zimftqks()\n{\n    f_kxodlfvy();\n    f_pwtazhgk();\n    f_yldhpvve();\n    f_qtrathfc();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_zimftqks();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400782,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_14.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_vllnqwvq()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(globalFive==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(globalFive==5)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_vllnqwvq();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400783,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_14.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_qwgvpcnv()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(globalTrue)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(globalFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_crzoipoh()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(globalTrue)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(globalTrue)\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_kjmfgbik()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(globalFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcpy(password, \"Password1234!\");\n    }\n    if(globalTrue)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_rvdqiodh()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(globalTrue)\n    {\n        \n        strcpy(password, \"Password1234!\");\n    }\n    if(globalTrue)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_wqpyawov()\n{\n    f_qwgvpcnv();\n    f_crzoipoh();\n    f_kjmfgbik();\n    f_rvdqiodh();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_wqpyawov();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400784,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_10.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_eszdworr()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(globalTrue)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(globalTrue)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_eszdworr();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400785,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_10.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_pacqcvjv()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(globalFive==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(globalFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_agynsgop()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(globalFive==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(globalFive==5)\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_ofzrxfig()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(globalFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcpy(password, \"Password1234!\");\n    }\n    if(globalFive==5)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_wvnndgqe()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(globalFive==5)\n    {\n        \n        strcpy(password, \"Password1234!\");\n    }\n    if(globalFive==5)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_ddjnasop()\n{\n    f_pacqcvjv();\n    f_agynsgop();\n    f_ofzrxfig();\n    f_wvnndgqe();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ddjnasop();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400786,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_14.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_kerythbd()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(globalFive==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(globalFive==5)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_kerythbd();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400787,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_14.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_wkmgickk()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(GLOBAL_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_lqdnoxsy()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_fwbznjjn()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(GLOBAL_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n    }\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_smiytxar()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n    }\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_rdlahtxt()\n{\n    f_wkmgickk();\n    f_lqdnoxsy();\n    f_fwbznjjn();\n    f_smiytxar();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_rdlahtxt();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400788,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_09.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_dicxrmsq()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_dicxrmsq();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400789,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_09.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_ryxvagsn()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_rbxmtvlp()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_lllpdrvu()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcpy(password, \"Password1234!\");\n    }\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_srwjumlq()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        \n        strcpy(password, \"Password1234!\");\n    }\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_carkflfq()\n{\n    f_ryxvagsn();\n    f_rbxmtvlp();\n    f_lllpdrvu();\n    f_srwjumlq();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_carkflfq();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400790,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_13.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_itmtlsnt()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_itmtlsnt();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400791,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_13.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_vtfglbgv()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(5==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(5!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_gmtavpnh()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(5==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(5==5)\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_ivyxdrxs()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(5!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcpy(password, \"Password1234!\");\n    }\n    if(5==5)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_onguwajj()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(5==5)\n    {\n        \n        strcpy(password, \"Password1234!\");\n    }\n    if(5==5)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_ranirpla()\n{\n    f_vtfglbgv();\n    f_gmtavpnh();\n    f_ivyxdrxs();\n    f_onguwajj();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ranirpla();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400792,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_03.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_sowebbpj()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(5==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(5==5)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_sowebbpj();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400793,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_03.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_edpgvpbh()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(globalReturnsTrue())\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(globalReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_ndfwizzk()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(globalReturnsTrue())\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(globalReturnsTrue())\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_lytpdodn()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(globalReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n    }\n    if(globalReturnsTrue())\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_opeccmxo()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(globalReturnsTrue())\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n    }\n    if(globalReturnsTrue())\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_ycesbppz()\n{\n    f_edpgvpbh();\n    f_ndfwizzk();\n    f_lytpdodn();\n    f_opeccmxo();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ycesbppz();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400794,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_11.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_goyvcovg()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(globalReturnsTrue())\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(globalReturnsTrue())\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_goyvcovg();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400795,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_11.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_jvyzfgpq()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(globalReturnsTrue())\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(globalReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_emhthgfa()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(globalReturnsTrue())\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(globalReturnsTrue())\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_hhkejtnu()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(globalReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcpy(password, \"Password1234!\");\n    }\n    if(globalReturnsTrue())\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_ysxcxcim()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(globalReturnsTrue())\n    {\n        \n        strcpy(password, \"Password1234!\");\n    }\n    if(globalReturnsTrue())\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_njjpmciv()\n{\n    f_jvyzfgpq();\n    f_emhthgfa();\n    f_hhkejtnu();\n    f_ysxcxcim();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_njjpmciv();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400796,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_11.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_vorozqzn()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(globalReturnsTrue())\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(globalReturnsTrue())\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_vorozqzn();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400797,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_11.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_trkghtcs()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(1)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(0)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_pbxqvzmd()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(1)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(1)\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_ghgliupp()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(0)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n    }\n    if(1)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_rqtrsehb()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(1)\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n    }\n    if(1)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_fzjleqva()\n{\n    f_trkghtcs();\n    f_pbxqvzmd();\n    f_ghgliupp();\n    f_rqtrsehb();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_fzjleqva();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400798,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_02.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_oozgbmsy()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(1)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(1)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_oozgbmsy();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400799,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_02.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic int B2G1Static = 0;\nstatic int B2G2Static = 0;\nstatic int G2BStatic = 0;\n\n\nstatic void f_ikqbhtqw(char * password)\n{\n    if(B2G1Static)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nstatic void f_pbmozdlk()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = strlen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(password, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(password, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    B2G1Static = 0; \n    f_ikqbhtqw(password);\n}\n\n\nstatic void f_grdxzpqb(char * password)\n{\n    if(B2G2Static)\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nstatic void f_etgtpsjm()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = strlen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(password, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(password, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    B2G2Static = 1; \n    f_grdxzpqb(password);\n}\n\n\nstatic void f_tslnucse(char * password)\n{\n    if(G2BStatic)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nstatic void f_lvyjhiir()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    \n    strcpy(password, \"Password1234!\");\n    G2BStatic = 1; \n    f_tslnucse(password);\n}\n\nvoid f_rhgwshba()\n{\n    f_pbmozdlk();\n    f_etgtpsjm();\n    f_lvyjhiir();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_rhgwshba();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400800,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_21.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\nstatic int Static = 0;\n\nstatic void f_rckftdhr(char * password)\n{\n    if(Static)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_dgppfbhg()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = strlen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(password, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(password, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    Static = 1; \n    f_rckftdhr(password);\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_dgppfbhg();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400801,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_21.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic int B2G1Static = 0;\nstatic int B2G2Static = 0;\nstatic int G2BStatic = 0;\n\n\nstatic void f_chtyyhjn(wchar_t * password)\n{\n    if(B2G1Static)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nstatic void f_gzkfhkar()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    B2G1Static = 0; \n    f_chtyyhjn(password);\n}\n\n\nstatic void f_troicwgh(wchar_t * password)\n{\n    if(B2G2Static)\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nstatic void f_nngfmytm()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    B2G2Static = 1; \n    f_troicwgh(password);\n}\n\n\nstatic void f_btqindcj(wchar_t * password)\n{\n    if(G2BStatic)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nstatic void f_bxytzldo()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    \n    wcscpy(password, L\"Password1234!\");\n    G2BStatic = 1; \n    f_btqindcj(password);\n}\n\nvoid f_vyvbgdpe()\n{\n    f_gzkfhkar();\n    f_nngfmytm();\n    f_bxytzldo();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_vyvbgdpe();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400802,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_21.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\nstatic int Static = 0;\n\nstatic void f_pprtromw(wchar_t * password)\n{\n    if(Static)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_ttcuaqgi()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    Static = 1; \n    f_pprtromw(password);\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ttcuaqgi();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400803,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_21.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\n\n\n\nstatic void f_fuxezozp()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(staticReturnsTrue())\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_sabzlurw()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(staticReturnsTrue())\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(staticReturnsTrue())\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_ghgnzqjn()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcpy(password, \"Password1234!\");\n    }\n    if(staticReturnsTrue())\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_xxwiidsx()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(staticReturnsTrue())\n    {\n        \n        strcpy(password, \"Password1234!\");\n    }\n    if(staticReturnsTrue())\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_bmxprjdk()\n{\n    f_fuxezozp();\n    f_sabzlurw();\n    f_ghgnzqjn();\n    f_xxwiidsx();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_bmxprjdk();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400804,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_08.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\n\nvoid f_stsnwzfu()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(staticReturnsTrue())\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(staticReturnsTrue())\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_stsnwzfu();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400805,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_08.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\n\n\n\nstatic void f_htmkrvmx()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(staticReturnsTrue())\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_jnehhfcg()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(staticReturnsTrue())\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(staticReturnsTrue())\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_sqheznjp()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n    }\n    if(staticReturnsTrue())\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_mwahxceo()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(staticReturnsTrue())\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n    }\n    if(staticReturnsTrue())\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_hkqvlchs()\n{\n    f_htmkrvmx();\n    f_jnehhfcg();\n    f_sqheznjp();\n    f_mwahxceo();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_hkqvlchs();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400806,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_08.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\n\nvoid f_jnhdmpwh()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(staticReturnsTrue())\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(staticReturnsTrue())\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_jnhdmpwh();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400807,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_08.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\n\n\n\nstatic void f_dibtkxky()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(staticTrue)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_mmorhacr()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(staticTrue)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(staticTrue)\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_bhzrducx()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcpy(password, \"Password1234!\");\n    }\n    if(staticTrue)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_jjwexhhw()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(staticTrue)\n    {\n        \n        strcpy(password, \"Password1234!\");\n    }\n    if(staticTrue)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_nrumegpy()\n{\n    f_dibtkxky();\n    f_mmorhacr();\n    f_bhzrducx();\n    f_jjwexhhw();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_nrumegpy();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400808,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_05.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\n\nvoid f_pqjlamng()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(staticTrue)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(staticTrue)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_pqjlamng();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400809,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_05.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\n\n\n\nstatic void f_exuvtsag()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(STATIC_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_vlzcwaku()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_euszobmp()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(STATIC_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcpy(password, \"Password1234!\");\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_bgtuknrq()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(STATIC_CONST_TRUE)\n    {\n        \n        strcpy(password, \"Password1234!\");\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_eplvvbrn()\n{\n    f_exuvtsag();\n    f_vlzcwaku();\n    f_euszobmp();\n    f_bgtuknrq();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_eplvvbrn();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400810,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_04.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\n\nvoid f_rtllbgzh()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_rtllbgzh();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400811,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_04.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\n\n\n\nstatic void f_yvtmymur()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(STATIC_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_mjcykqpl()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_yplqiuvs()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(STATIC_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_pkklmbyu()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(STATIC_CONST_TRUE)\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_hqkvbunc()\n{\n    f_yvtmymur();\n    f_mjcykqpl();\n    f_yplqiuvs();\n    f_pkklmbyu();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_hqkvbunc();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400812,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_04.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\n\nvoid f_thtzhmdf()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_thtzhmdf();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400813,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_04.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\n\n\n\nstatic void f_ltznsvjy()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(staticTrue)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_gkytjvcz()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(staticTrue)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(staticTrue)\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_bcvefyxz()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n    }\n    if(staticTrue)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_cjhssnoq()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(staticTrue)\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n    }\n    if(staticTrue)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_ngsuesvm()\n{\n    f_ltznsvjy();\n    f_gkytjvcz();\n    f_bcvefyxz();\n    f_cjhssnoq();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ngsuesvm();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400814,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_05.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\n\nvoid f_fwgdmokp()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(staticTrue)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(staticTrue)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_fwgdmokp();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400815,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_05.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nstatic const int STATIC_CONST_FIVE = 5;\n\n\n\n\nstatic void f_bqenquhg()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(STATIC_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_hzvqiram()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_pzfyckhq()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(STATIC_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_yvxgrshk()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_pbqjloan()\n{\n    f_bqenquhg();\n    f_hzvqiram();\n    f_pzfyckhq();\n    f_yvxgrshk();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_pbqjloan();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400816,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_06.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nstatic const int STATIC_CONST_FIVE = 5;\n\n\nvoid f_mkoqjiqt()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_mkoqjiqt();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400817,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_06.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nstatic int staticFive = 5;\n\n\n\n\nstatic void f_efepepml()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(staticFive==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(staticFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_hxmffuqg()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(staticFive==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(staticFive==5)\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_danxvghw()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(staticFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcpy(password, \"Password1234!\");\n    }\n    if(staticFive==5)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_ywdjppsj()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(staticFive==5)\n    {\n        \n        strcpy(password, \"Password1234!\");\n    }\n    if(staticFive==5)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_vapfflmk()\n{\n    f_efepepml();\n    f_hxmffuqg();\n    f_danxvghw();\n    f_ywdjppsj();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_vapfflmk();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400818,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_07.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nstatic int staticFive = 5;\n\n\nvoid f_bjvciavs()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(staticFive==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(staticFive==5)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_bjvciavs();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400819,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_07.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nstatic int staticFive = 5;\n\n\n\n\nstatic void f_dquuygqu()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(staticFive==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(staticFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_vqewvgyy()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(staticFive==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(staticFive==5)\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_strpqsqo()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(staticFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n    }\n    if(staticFive==5)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_grmtienk()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(staticFive==5)\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n    }\n    if(staticFive==5)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_kznwhglv()\n{\n    f_dquuygqu();\n    f_vqewvgyy();\n    f_strpqsqo();\n    f_grmtienk();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_kznwhglv();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400820,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_07.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nstatic int staticFive = 5;\n\n\nvoid f_elbveaby()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(staticFive==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(staticFive==5)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_elbveaby();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400821,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_07.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nstatic const int STATIC_CONST_FIVE = 5;\n\n\n\n\nstatic void f_rxlcgfxh()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(STATIC_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_kvnmtqhl()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_uatbqgvv()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(STATIC_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcpy(password, \"Password1234!\");\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_qodjpfia()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(STATIC_CONST_FIVE==5)\n    {\n        \n        strcpy(password, \"Password1234!\");\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_tuqpsgfk()\n{\n    f_rxlcgfxh();\n    f_kvnmtqhl();\n    f_uatbqgvv();\n    f_qodjpfia();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_tuqpsgfk();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400822,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_06.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nstatic const int STATIC_CONST_FIVE = 5;\n\n\nvoid f_xrzwdsad()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_xrzwdsad();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400823,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_06.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_ycgzghzn()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(globalTrue)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(globalFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_bwxuhqlv()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(globalTrue)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(globalTrue)\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_uyncvynl()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(globalFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcpy(password, \"Password1234!\");\n    }\n    if(globalTrue)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_kwprxwni()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(globalTrue)\n    {\n        \n        strcpy(password, \"Password1234!\");\n    }\n    if(globalTrue)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_ovxzzmvj()\n{\n    f_ycgzghzn();\n    f_bwxuhqlv();\n    f_uyncvynl();\n    f_kwprxwni();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ovxzzmvj();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400824,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_10.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_rpjxoiut()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(globalTrue)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(globalTrue)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_rpjxoiut();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400825,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_10.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_zufigehg()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(globalReturnsTrue())\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(globalReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_xxvyapfn()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(globalReturnsTrue())\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(globalReturnsTrue())\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_cbjlfvem()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(globalReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcpy(password, \"Password1234!\");\n    }\n    if(globalReturnsTrue())\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_jtipzusi()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(globalReturnsTrue())\n    {\n        \n        strcpy(password, \"Password1234!\");\n    }\n    if(globalReturnsTrue())\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_afhcjzpd()\n{\n    f_zufigehg();\n    f_xxvyapfn();\n    f_cbjlfvem();\n    f_jtipzusi();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_afhcjzpd();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400826,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_11.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_oxahhtan()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(globalReturnsTrue())\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(globalReturnsTrue())\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_oxahhtan();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400827,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_11.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_keszlxhn()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(globalFive==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(globalFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_pazawkvv()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(globalFive==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(globalFive==5)\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_lwaznesk()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(globalFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcpy(password, \"Password1234!\");\n    }\n    if(globalFive==5)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_edcctqst()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(globalFive==5)\n    {\n        \n        strcpy(password, \"Password1234!\");\n    }\n    if(globalFive==5)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_jsrnttxs()\n{\n    f_keszlxhn();\n    f_pazawkvv();\n    f_lwaznesk();\n    f_edcctqst();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_jsrnttxs();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400828,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_14.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_ambrjswq()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(globalFive==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(globalFive==5)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ambrjswq();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400829,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_14.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_wutfzzdz()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(1)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(0)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_xlfjbyoc()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(1)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(1)\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_tpyfhkig()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(0)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcpy(password, \"Password1234!\");\n    }\n    if(1)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_jcbqueef()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(1)\n    {\n        \n        strcpy(password, \"Password1234!\");\n    }\n    if(1)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_zirpppdp()\n{\n    f_wutfzzdz();\n    f_xlfjbyoc();\n    f_tpyfhkig();\n    f_jcbqueef();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_zirpppdp();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400830,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_02.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_qyktcuti()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(1)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(1)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_qyktcuti();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400831,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_02.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_lrfugddr()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_zmbzecwm()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_xhodxudk()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcpy(password, \"Password1234!\");\n    }\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_rhtihnpe()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        \n        strcpy(password, \"Password1234!\");\n    }\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_porhwwug()\n{\n    f_lrfugddr();\n    f_zmbzecwm();\n    f_xhodxudk();\n    f_rhtihnpe();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_porhwwug();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400832,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_13.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_bacnuolc()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_bacnuolc();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400833,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_13.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_smpqarhu()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(globalReturnsTrue())\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(globalReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_weqdhihr()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(globalReturnsTrue())\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(globalReturnsTrue())\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_uqtsbooy()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(globalReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n    }\n    if(globalReturnsTrue())\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_waimbssg()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(globalReturnsTrue())\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n    }\n    if(globalReturnsTrue())\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_sbxqkfbc()\n{\n    f_smpqarhu();\n    f_weqdhihr();\n    f_uqtsbooy();\n    f_waimbssg();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_sbxqkfbc();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400834,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_11.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_psirqnqa()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(globalReturnsTrue())\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(globalReturnsTrue())\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_psirqnqa();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400835,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_11.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_assvtoxr()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(GLOBAL_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_sqfqaild()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_epjduugp()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(GLOBAL_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n    }\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_qmccxtnv()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n    }\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_asxootli()\n{\n    f_assvtoxr();\n    f_sqfqaild();\n    f_epjduugp();\n    f_qmccxtnv();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_asxootli();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400836,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_09.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_uczrodkf()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_uczrodkf();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400837,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_09.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_syxvyvaf()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(5==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(5!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_agnizvcr()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(5==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(5==5)\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_gbrqmlzh()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(5!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n    }\n    if(5==5)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_mkpvuflm()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(5==5)\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n    }\n    if(5==5)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_ptehtpzs()\n{\n    f_syxvyvaf();\n    f_agnizvcr();\n    f_gbrqmlzh();\n    f_mkpvuflm();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ptehtpzs();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400838,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_03.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_ojrapryn()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(5==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(5==5)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ojrapryn();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400839,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_03.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_psicmuas()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(1)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(0)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_sfeunekg()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(1)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(1)\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_qybbvmov()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(0)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n    }\n    if(1)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_ftkgzfwo()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(1)\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n    }\n    if(1)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_eqiyswtb()\n{\n    f_psicmuas();\n    f_sfeunekg();\n    f_qybbvmov();\n    f_ftkgzfwo();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_eqiyswtb();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400840,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_02.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_pnsochlk()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(1)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(1)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_pnsochlk();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400841,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_02.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_fnivshwd()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(5==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(5!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_tsrzvlno()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(5==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(5==5)\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_gzbnmmex()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(5!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcpy(password, \"Password1234!\");\n    }\n    if(5==5)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_shceanka()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(5==5)\n    {\n        \n        strcpy(password, \"Password1234!\");\n    }\n    if(5==5)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_nywtgrtm()\n{\n    f_fnivshwd();\n    f_tsrzvlno();\n    f_gzbnmmex();\n    f_shceanka();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_nywtgrtm();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400842,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_03.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_qhqvndco()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(5==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(5==5)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_qhqvndco();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400843,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_03.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_jfdsfxiw()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_mskqtqmr()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_ipcgscxa()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n    }\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_bqxxdkra()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n    }\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_zmpszqfd()\n{\n    f_jfdsfxiw();\n    f_mskqtqmr();\n    f_ipcgscxa();\n    f_bqxxdkra();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_zmpszqfd();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400844,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_13.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_akqzjkaf()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_akqzjkaf();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400845,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_13.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_gjlnhpgg()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(globalFive==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(globalFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_qgjizbds()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(globalFive==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(globalFive==5)\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_zmiwxcfm()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(globalFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n    }\n    if(globalFive==5)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_qsuivxhd()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(globalFive==5)\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n    }\n    if(globalFive==5)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_bbvelrrx()\n{\n    f_gjlnhpgg();\n    f_qgjizbds();\n    f_zmiwxcfm();\n    f_qsuivxhd();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_bbvelrrx();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400846,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_14.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_oqthotnt()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(globalFive==5)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(globalFive==5)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_oqthotnt();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400847,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_14.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_fqvqchum()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(GLOBAL_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_gouupjud()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_vbeqtiut()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(GLOBAL_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcpy(password, \"Password1234!\");\n    }\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_fitaouwo()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        \n        strcpy(password, \"Password1234!\");\n    }\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_rhnnpmfc()\n{\n    f_fqvqchum();\n    f_gouupjud();\n    f_vbeqtiut();\n    f_fitaouwo();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_rhnnpmfc();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400848,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_09.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_kbxpzxlf()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_kbxpzxlf();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400849,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_09.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_rvqnxrol()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(globalTrue)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(globalFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_jsscwyer()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(globalTrue)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(globalTrue)\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_gfsceaff()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(globalFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n    }\n    if(globalTrue)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_qekzuedb()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(globalTrue)\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n    }\n    if(globalTrue)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_xfsguxjz()\n{\n    f_rvqnxrol();\n    f_jsscwyer();\n    f_gfsceaff();\n    f_qekzuedb();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_xfsguxjz();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400850,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_10.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_suoiqwac()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    if(globalTrue)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    if(globalTrue)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_suoiqwac();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400851,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_10.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic int B2G1Static = 0;\nstatic int B2G2Static = 0;\nstatic int G2BStatic = 0;\n\n\nstatic void f_dgjlsikj(char * password)\n{\n    if(B2G1Static)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nstatic void f_dkxiwdtb()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t passwordLen = strlen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(password, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(password, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            closesocket(connectSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    B2G1Static = 0; \n    f_dgjlsikj(password);\n}\n\n\nstatic void f_rayhhbop(char * password)\n{\n    if(B2G2Static)\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nstatic void f_uizpdblg()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t passwordLen = strlen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(password, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(password, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            closesocket(connectSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    B2G2Static = 1; \n    f_rayhhbop(password);\n}\n\n\nstatic void f_ydeawemi(char * password)\n{\n    if(G2BStatic)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nstatic void f_jfqcvlpn()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    \n    strcpy(password, \"Password1234!\");\n    G2BStatic = 1; \n    f_ydeawemi(password);\n}\n\nvoid f_cvinvusv()\n{\n    f_dkxiwdtb();\n    f_uizpdblg();\n    f_jfqcvlpn();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_cvinvusv();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400852,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_21.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\nstatic int Static = 0;\n\nstatic void f_cbvmjetd(char * password)\n{\n    if(Static)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_fiyrtrfg()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t passwordLen = strlen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(password, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(password, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            closesocket(connectSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    Static = 1; \n    f_cbvmjetd(password);\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_fiyrtrfg();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400853,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_21.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic int B2G1Static = 0;\nstatic int B2G2Static = 0;\nstatic int G2BStatic = 0;\n\n\nstatic void f_hhszjfzr(wchar_t * password)\n{\n    if(B2G1Static)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nstatic void f_usqontgj()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            closesocket(connectSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    B2G1Static = 0; \n    f_hhszjfzr(password);\n}\n\n\nstatic void f_bzwxpwsc(wchar_t * password)\n{\n    if(B2G2Static)\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nstatic void f_aqkrpyjj()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            closesocket(connectSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    B2G2Static = 1; \n    f_bzwxpwsc(password);\n}\n\n\nstatic void f_befullwd(wchar_t * password)\n{\n    if(G2BStatic)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nstatic void f_budqxmzg()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    \n    wcscpy(password, L\"Password1234!\");\n    G2BStatic = 1; \n    f_befullwd(password);\n}\n\nvoid f_wjlonifg()\n{\n    f_usqontgj();\n    f_aqkrpyjj();\n    f_budqxmzg();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_wjlonifg();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400854,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_21.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\nstatic int Static = 0;\n\nstatic void f_tewnyaxn(wchar_t * password)\n{\n    if(Static)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_gkxuhhuz()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            closesocket(connectSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    Static = 1; \n    f_tewnyaxn(password);\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_gkxuhhuz();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400855,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_21.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_kvcbsphw()\n{\n    wchar_t * password;\n    wchar_t * *passwordPtr1 = &password;\n    wchar_t * *passwordPtr2 = &password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    {\n        wchar_t * password = *passwordPtr1;\n        \n        wcscpy(password, L\"Password1234!\");\n        *passwordPtr1 = password;\n    }\n    {\n        wchar_t * password = *passwordPtr2;\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_owvwajqi()\n{\n    wchar_t * password;\n    wchar_t * *passwordPtr1 = &password;\n    wchar_t * *passwordPtr2 = &password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    {\n        wchar_t * password = *passwordPtr1;\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n        *passwordPtr1 = password;\n    }\n    {\n        wchar_t * password = *passwordPtr2;\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_lrvbmzmf()\n{\n    f_kvcbsphw();\n    f_owvwajqi();\n}\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_lrvbmzmf();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400856,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_32.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_zunpstya()\n{\n    wchar_t * password;\n    wchar_t * *passwordPtr1 = &password;\n    wchar_t * *passwordPtr2 = &password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    {\n        wchar_t * password = *passwordPtr1;\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n        *passwordPtr1 = password;\n    }\n    {\n        wchar_t * password = *passwordPtr2;\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_zunpstya();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400857,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_32.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_tcibcstx()\n{\n    char * password;\n    char * *passwordPtr1 = &password;\n    char * *passwordPtr2 = &password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    {\n        char * password = *passwordPtr1;\n        \n        strcpy(password, \"Password1234!\");\n        *passwordPtr1 = password;\n    }\n    {\n        char * password = *passwordPtr2;\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_jalerrpm()\n{\n    char * password;\n    char * *passwordPtr1 = &password;\n    char * *passwordPtr2 = &password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    {\n        char * password = *passwordPtr1;\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n        *passwordPtr1 = password;\n    }\n    {\n        char * password = *passwordPtr2;\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_wpkeybfi()\n{\n    f_tcibcstx();\n    f_jalerrpm();\n}\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_wpkeybfi();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400858,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_32.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_awavesci()\n{\n    char * password;\n    char * *passwordPtr1 = &password;\n    char * *passwordPtr2 = &password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    {\n        char * password = *passwordPtr1;\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n        *passwordPtr1 = password;\n    }\n    {\n        char * password = *passwordPtr2;\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_awavesci();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400859,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_32.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_gfoxiqxk()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    while(1)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n        break;\n    }\n    while(1)\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n        break;\n    }\n}\n\n\nstatic void f_rxakeinf()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    while(1)\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n        break;\n    }\n    while(1)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n        break;\n    }\n}\n\nvoid f_ddaezcgm()\n{\n    f_gfoxiqxk();\n    f_rxakeinf();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ddaezcgm();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400860,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_16.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_vilvdelq()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    while(1)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n        break;\n    }\n    while(1)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n        break;\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_vilvdelq();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400861,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_16.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\nstatic char * _Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_45_Data;\nstatic char * _Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_45_G2BData;\nstatic char * _Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_45_B2GData;\n\n\n\n\nstatic void f_jqyfxmna()\n{\n    char * password = _Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_45_G2BData;\n    {\n        HANDLE pHandle;\n        char * username = \"User\";\n        char * domain = \"Domain\";\n        \n        \n        if (LogonUserA(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\nstatic void f_gbvjejnw()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    \n    strcpy(password, \"Password1234!\");\n    _Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_45_G2BData = password;\n    f_jqyfxmna();\n}\n\n\nstatic void f_hwroyehe()\n{\n    char * password = _Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_45_B2GData;\n    {\n        HCRYPTPROV hCryptProv = 0;\n        HCRYPTHASH hHash = 0;\n        HCRYPTKEY hKey = 0;\n        char hashData[100] = HASH_INPUT;\n        HANDLE pHandle;\n        char * username = \"User\";\n        char * domain = \"Domain\";\n        do\n        {\n            BYTE payload[(100 - 1) * sizeof(char)]; \n            DWORD payloadBytes;\n            \n            payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n            \n            SecureZeroMemory(password, 100 * sizeof(char));\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                break;\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                break;\n            }\n            \n            if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n            {\n                break;\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                break;\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n            {\n                break;\n            }\n            \n            memcpy(password, payload, payloadBytes);\n            password[payloadBytes / sizeof(char)] = '\\0';\n        }\n        while (0);\n        if (hKey)\n        {\n            CryptDestroyKey(hKey);\n        }\n        if (hHash)\n        {\n            CryptDestroyHash(hHash);\n        }\n        if (hCryptProv)\n        {\n            CryptReleaseContext(hCryptProv, 0);\n        }\n        \n        if (LogonUserA(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\nstatic void f_zoskywfy()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = strlen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(password, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(password, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    _Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_45_B2GData = password;\n    f_hwroyehe();\n}\n\nvoid f_xurxclsl()\n{\n    f_gbvjejnw();\n    f_zoskywfy();\n}\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_xurxclsl();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400862,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_45.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\nstatic char * _Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_45_Data;\nstatic char * _Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_45_G2BData;\nstatic char * _Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_45_B2GData;\n\n\nstatic void f_edobxwhh()\n{\n    char * password = _Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_45_Data;\n    {\n        HANDLE pHandle;\n        char * username = \"User\";\n        char * domain = \"Domain\";\n        \n        \n        if (LogonUserA(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\nvoid f_gnaiedyl()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = strlen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(password, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(password, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    _Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_45_Data = password;\n    f_edobxwhh();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_gnaiedyl();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400863,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_45.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_guwsmdor()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    while(1)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n        break;\n    }\n    while(1)\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n        break;\n    }\n}\n\n\nstatic void f_brmblrtk()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    while(1)\n    {\n        \n        strcpy(password, \"Password1234!\");\n        break;\n    }\n    while(1)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n        break;\n    }\n}\n\nvoid f_axwwcmhu()\n{\n    f_guwsmdor();\n    f_brmblrtk();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_axwwcmhu();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400864,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_16.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_ejvtocil()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    while(1)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n        break;\n    }\n    while(1)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n        break;\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ejvtocil();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400865,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_16.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\nstatic wchar_t * _Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_45_Data;\nstatic wchar_t * _Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_45_G2BData;\nstatic wchar_t * _Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_45_B2GData;\n\n\n\n\nstatic void f_ylsvigfn()\n{\n    wchar_t * password = _Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_45_G2BData;\n    {\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        \n        \n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\nstatic void f_wuxeijxz()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    \n    wcscpy(password, L\"Password1234!\");\n    _Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_45_G2BData = password;\n    f_ylsvigfn();\n}\n\n\nstatic void f_atmuwkut()\n{\n    wchar_t * password = _Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_45_B2GData;\n    {\n        HCRYPTPROV hCryptProv = 0;\n        HCRYPTHASH hHash = 0;\n        HCRYPTKEY hKey = 0;\n        char hashData[100] = HASH_INPUT;\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        do\n        {\n            BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n            DWORD payloadBytes;\n            \n            payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n            \n            SecureZeroMemory(password, 100 * sizeof(wchar_t));\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                break;\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                break;\n            }\n            \n            if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n            {\n                break;\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                break;\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n            {\n                break;\n            }\n            \n            memcpy(password, payload, payloadBytes);\n            password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n        }\n        while (0);\n        if (hKey)\n        {\n            CryptDestroyKey(hKey);\n        }\n        if (hHash)\n        {\n            CryptDestroyHash(hHash);\n        }\n        if (hCryptProv)\n        {\n            CryptReleaseContext(hCryptProv, 0);\n        }\n        \n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\nstatic void f_rltjhats()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    _Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_45_B2GData = password;\n    f_atmuwkut();\n}\n\nvoid f_mhgkjwsp()\n{\n    f_wuxeijxz();\n    f_rltjhats();\n}\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_mhgkjwsp();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400866,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_45.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\nstatic wchar_t * _Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_45_Data;\nstatic wchar_t * _Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_45_G2BData;\nstatic wchar_t * _Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_45_B2GData;\n\n\nstatic void f_fkkfdpop()\n{\n    wchar_t * password = _Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_45_Data;\n    {\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        \n        \n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\nvoid f_iphkjfmt()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    _Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_45_Data = password;\n    f_fkkfdpop();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_iphkjfmt();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400867,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_45.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_cosiaimj(wchar_t * &password)\n{\n    \n    wcscpy(password, L\"Password1234!\");\n}\n\nstatic void f_urilqfdo()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    f_cosiaimj(password);\n    {\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        \n        \n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\n\nstatic void f_kjftfeeu(wchar_t * &password)\n{\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (::bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n}\n\nstatic void f_jlgbyurm()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    f_kjftfeeu(password);\n    {\n        HCRYPTPROV hCryptProv = 0;\n        HCRYPTHASH hHash = 0;\n        HCRYPTKEY hKey = 0;\n        char hashData[100] = HASH_INPUT;\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        do\n        {\n            BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n            DWORD payloadBytes;\n            \n            payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n            \n            SecureZeroMemory(password, 100 * sizeof(wchar_t));\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                break;\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                break;\n            }\n            \n            if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n            {\n                break;\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                break;\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n            {\n                break;\n            }\n            \n            memcpy(password, payload, payloadBytes);\n            password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n        }\n        while (0);\n        if (hKey)\n        {\n            CryptDestroyKey(hKey);\n        }\n        if (hHash)\n        {\n            CryptDestroyHash(hHash);\n        }\n        if (hCryptProv)\n        {\n            CryptReleaseContext(hCryptProv, 0);\n        }\n        \n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\nvoid f_yugirbbj()\n{\n    f_urilqfdo();\n    f_jlgbyurm();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_yugirbbj();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400868,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_43.cpp",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\nnamespace _A_namespace\n{\n\n\nstatic void f_rvjnzvlw(wchar_t * &password)\n{\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (::bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n}\n\nvoid f_kkxojjoo()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    f_rvjnzvlw(password);\n    {\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        \n        \n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_kkxojjoo();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400869,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_43.cpp",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_jqesszew(char * &password)\n{\n    \n    strcpy(password, \"Password1234!\");\n}\n\nstatic void f_fzhvxnhz()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    f_jqesszew(password);\n    {\n        HANDLE pHandle;\n        char * username = \"User\";\n        char * domain = \"Domain\";\n        \n        \n        if (LogonUserA(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\n\nstatic void f_ovvxarca(char * &password)\n{\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = strlen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (::bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(password, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(password, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n}\n\nstatic void f_qhdctfqa()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    f_ovvxarca(password);\n    {\n        HCRYPTPROV hCryptProv = 0;\n        HCRYPTHASH hHash = 0;\n        HCRYPTKEY hKey = 0;\n        char hashData[100] = HASH_INPUT;\n        HANDLE pHandle;\n        char * username = \"User\";\n        char * domain = \"Domain\";\n        do\n        {\n            BYTE payload[(100 - 1) * sizeof(char)]; \n            DWORD payloadBytes;\n            \n            payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n            \n            SecureZeroMemory(password, 100 * sizeof(char));\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                break;\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                break;\n            }\n            \n            if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n            {\n                break;\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                break;\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n            {\n                break;\n            }\n            \n            memcpy(password, payload, payloadBytes);\n            password[payloadBytes / sizeof(char)] = '\\0';\n        }\n        while (0);\n        if (hKey)\n        {\n            CryptDestroyKey(hKey);\n        }\n        if (hHash)\n        {\n            CryptDestroyHash(hHash);\n        }\n        if (hCryptProv)\n        {\n            CryptReleaseContext(hCryptProv, 0);\n        }\n        \n        if (LogonUserA(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\nvoid f_tdgleihd()\n{\n    f_fzhvxnhz();\n    f_qhdctfqa();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_tdgleihd();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400870,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_43.cpp",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\nnamespace _A_namespace\n{\n\n\nstatic void f_xzkdisbh(char * &password)\n{\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = strlen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (::bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(password, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(password, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n}\n\nvoid f_shhfovrf()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    f_xzkdisbh(password);\n    {\n        HANDLE pHandle;\n        char * username = \"User\";\n        char * domain = \"Domain\";\n        \n        \n        if (LogonUserA(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_shhfovrf();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400871,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_43.cpp",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_duizzbqg()\n{\n    int i,k;\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    for(i = 0; i < 1; i++)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    for(k = 0; k < 1; k++)\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_eusxsqws()\n{\n    int h,j;\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    for(h = 0; h < 1; h++)\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n    }\n    for(j = 0; j < 1; j++)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_dlcbgswg()\n{\n    f_duizzbqg();\n    f_eusxsqws();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_dlcbgswg();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400872,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_17.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_lnileisu()\n{\n    int i,j;\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    for(i = 0; i < 1; i++)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    for(j = 0; j < 1; j++)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_lnileisu();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400873,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_17.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_fjlxgtnh()\n{\n    int i,k;\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    for(i = 0; i < 1; i++)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    for(k = 0; k < 1; k++)\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_hknwsoad()\n{\n    int h,j;\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    for(h = 0; h < 1; h++)\n    {\n        \n        strcpy(password, \"Password1234!\");\n    }\n    for(j = 0; j < 1; j++)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_rhsptmyn()\n{\n    f_fjlxgtnh();\n    f_hknwsoad();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_rhsptmyn();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400874,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_17.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_ujjhjerl()\n{\n    int i,j;\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    for(i = 0; i < 1; i++)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                closesocket(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                closesocket(acceptSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    for(j = 0; j < 1; j++)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ujjhjerl();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400875,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_17.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\ntypedef union\n{\n    wchar_t * unionFirst;\n    wchar_t * unionSecond;\n} _Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_34_unionType;\n\n\n\n\nstatic void f_nfhcrlba()\n{\n    wchar_t * password;\n    _Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_34_unionType myUnion;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    \n    wcscpy(password, L\"Password1234!\");\n    myUnion.unionFirst = password;\n    {\n        wchar_t * password = myUnion.unionSecond;\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_uvjfglbt()\n{\n    wchar_t * password;\n    _Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_34_unionType myUnion;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    myUnion.unionFirst = password;\n    {\n        wchar_t * password = myUnion.unionSecond;\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_zdskytxz()\n{\n    f_nfhcrlba();\n    f_uvjfglbt();\n}\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_zdskytxz();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400876,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_34.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\ntypedef union\n{\n    wchar_t * unionFirst;\n    wchar_t * unionSecond;\n} _Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_34_unionType;\n\n\nvoid f_ztfwlpsw()\n{\n    wchar_t * password;\n    _Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_34_unionType myUnion;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    myUnion.unionFirst = password;\n    {\n        wchar_t * password = myUnion.unionSecond;\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ztfwlpsw();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400877,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_34.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\ntypedef union\n{\n    char * unionFirst;\n    char * unionSecond;\n} _Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_34_unionType;\n\n\n\n\nstatic void f_brznrvoo()\n{\n    char * password;\n    _Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_34_unionType myUnion;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    \n    strcpy(password, \"Password1234!\");\n    myUnion.unionFirst = password;\n    {\n        char * password = myUnion.unionSecond;\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_lawozvkm()\n{\n    char * password;\n    _Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_34_unionType myUnion;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = strlen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(password, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(password, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    myUnion.unionFirst = password;\n    {\n        char * password = myUnion.unionSecond;\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_szegytxd()\n{\n    f_brznrvoo();\n    f_lawozvkm();\n}\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_szegytxd();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400878,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_34.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\ntypedef union\n{\n    char * unionFirst;\n    char * unionSecond;\n} _Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_34_unionType;\n\n\nvoid f_xfxtxgzl()\n{\n    char * password;\n    _Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_34_unionType myUnion;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = strlen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(password, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(password, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    myUnion.unionFirst = password;\n    {\n        char * password = myUnion.unionSecond;\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_xfxtxgzl();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400879,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_34.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_tcerptfi(char * password)\n{\n    {\n        HANDLE pHandle;\n        char * username = \"User\";\n        char * domain = \"Domain\";\n        \n        \n        if (LogonUserA(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\nstatic void f_dnyvooea()\n{\n    char * password;\n    void (*funcPtr) (char *) = f_tcerptfi;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    \n    strcpy(password, \"Password1234!\");\n    funcPtr(password);\n}\n\n\nstatic void f_ssabwdnr(char * password)\n{\n    {\n        HCRYPTPROV hCryptProv = 0;\n        HCRYPTHASH hHash = 0;\n        HCRYPTKEY hKey = 0;\n        char hashData[100] = HASH_INPUT;\n        HANDLE pHandle;\n        char * username = \"User\";\n        char * domain = \"Domain\";\n        do\n        {\n            BYTE payload[(100 - 1) * sizeof(char)]; \n            DWORD payloadBytes;\n            \n            payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n            \n            SecureZeroMemory(password, 100 * sizeof(char));\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                break;\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                break;\n            }\n            \n            if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n            {\n                break;\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                break;\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n            {\n                break;\n            }\n            \n            memcpy(password, payload, payloadBytes);\n            password[payloadBytes / sizeof(char)] = '\\0';\n        }\n        while (0);\n        if (hKey)\n        {\n            CryptDestroyKey(hKey);\n        }\n        if (hHash)\n        {\n            CryptDestroyHash(hHash);\n        }\n        if (hCryptProv)\n        {\n            CryptReleaseContext(hCryptProv, 0);\n        }\n        \n        if (LogonUserA(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\nstatic void f_ibvklipd()\n{\n    char * password;\n    void (*funcPtr) (char *) = f_ssabwdnr;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = strlen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(password, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(password, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    funcPtr(password);\n}\n\nvoid f_wkiawnqo()\n{\n    f_dnyvooea();\n    f_ibvklipd();\n}\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_wkiawnqo();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400880,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_44.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nstatic void f_gazosggn(char * password)\n{\n    {\n        HANDLE pHandle;\n        char * username = \"User\";\n        char * domain = \"Domain\";\n        \n        \n        if (LogonUserA(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\nvoid f_bkgnuzok()\n{\n    char * password;\n    \n    void (*funcPtr) (char *) = f_gazosggn;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = strlen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(password, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(password, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    \n    funcPtr(password);\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_bkgnuzok();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400881,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_44.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_pwgnsgsw(wchar_t * password)\n{\n    {\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        \n        \n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\nstatic void f_oixkvssz()\n{\n    wchar_t * password;\n    void (*funcPtr) (wchar_t *) = f_pwgnsgsw;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    \n    wcscpy(password, L\"Password1234!\");\n    funcPtr(password);\n}\n\n\nstatic void f_vkhbyhir(wchar_t * password)\n{\n    {\n        HCRYPTPROV hCryptProv = 0;\n        HCRYPTHASH hHash = 0;\n        HCRYPTKEY hKey = 0;\n        char hashData[100] = HASH_INPUT;\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        do\n        {\n            BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n            DWORD payloadBytes;\n            \n            payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n            \n            SecureZeroMemory(password, 100 * sizeof(wchar_t));\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                break;\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                break;\n            }\n            \n            if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n            {\n                break;\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                break;\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n            {\n                break;\n            }\n            \n            memcpy(password, payload, payloadBytes);\n            password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n        }\n        while (0);\n        if (hKey)\n        {\n            CryptDestroyKey(hKey);\n        }\n        if (hHash)\n        {\n            CryptDestroyHash(hHash);\n        }\n        if (hCryptProv)\n        {\n            CryptReleaseContext(hCryptProv, 0);\n        }\n        \n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\nstatic void f_aiuxsfrw()\n{\n    wchar_t * password;\n    void (*funcPtr) (wchar_t *) = f_vkhbyhir;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    funcPtr(password);\n}\n\nvoid f_wmtivpos()\n{\n    f_oixkvssz();\n    f_aiuxsfrw();\n}\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_wmtivpos();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400882,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_44.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nstatic void f_ttqeuwag(wchar_t * password)\n{\n    {\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        \n        \n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\nvoid f_wyqzzspg()\n{\n    wchar_t * password;\n    \n    void (*funcPtr) (wchar_t *) = f_ttqeuwag;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    \n    funcPtr(password);\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_wyqzzspg();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400883,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_44.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_hahgycmf()\n{\n    wchar_t * password;\n    wchar_t * &passwordRef = password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    \n    wcscpy(password, L\"Password1234!\");\n    {\n        wchar_t * password = passwordRef;\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_aziqxvdl()\n{\n    wchar_t * password;\n    wchar_t * &passwordRef = password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (::bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    {\n        wchar_t * password = passwordRef;\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_dluwpqci()\n{\n    f_hahgycmf();\n    f_aziqxvdl();\n}\n\n\n} \n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_dluwpqci();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400884,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_33.cpp",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\nnamespace _A_namespace\n{\n\n\nvoid f_nmckhmbp()\n{\n    wchar_t * password;\n    wchar_t * &passwordRef = password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (::bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    {\n        wchar_t * password = passwordRef;\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n} \n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_nmckhmbp();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400885,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_33.cpp",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic char * G2BSource(char * password)\n{\n    \n    strcpy(password, \"Password1234!\");\n    return password;\n}\n\nstatic void f_byqqtgdy()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    password = G2BSource(password);\n    {\n        HANDLE pHandle;\n        char * username = \"User\";\n        char * domain = \"Domain\";\n        \n        \n        if (LogonUserA(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\n\nstatic char * B2GSource(char * password)\n{\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = strlen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(password, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(password, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    return password;\n}\n\nstatic void f_ecmwzpmg()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    password = B2GSource(password);\n    {\n        HCRYPTPROV hCryptProv = 0;\n        HCRYPTHASH hHash = 0;\n        HCRYPTKEY hKey = 0;\n        char hashData[100] = HASH_INPUT;\n        HANDLE pHandle;\n        char * username = \"User\";\n        char * domain = \"Domain\";\n        do\n        {\n            BYTE payload[(100 - 1) * sizeof(char)]; \n            DWORD payloadBytes;\n            \n            payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n            \n            SecureZeroMemory(password, 100 * sizeof(char));\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                break;\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                break;\n            }\n            \n            if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n            {\n                break;\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                break;\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n            {\n                break;\n            }\n            \n            memcpy(password, payload, payloadBytes);\n            password[payloadBytes / sizeof(char)] = '\\0';\n        }\n        while (0);\n        if (hKey)\n        {\n            CryptDestroyKey(hKey);\n        }\n        if (hHash)\n        {\n            CryptDestroyHash(hHash);\n        }\n        if (hCryptProv)\n        {\n            CryptReleaseContext(hCryptProv, 0);\n        }\n        \n        if (LogonUserA(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\nvoid f_kngwrcpv()\n{\n    f_ecmwzpmg();\n    f_byqqtgdy();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_kngwrcpv();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400886,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_42.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nstatic char * Source(char * password)\n{\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = strlen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(password, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(password, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    return password;\n}\n\nvoid f_vxxrklnt()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    password = Source(password);\n    {\n        HANDLE pHandle;\n        char * username = \"User\";\n        char * domain = \"Domain\";\n        \n        \n        if (LogonUserA(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_vxxrklnt();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400887,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_42.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_wycfpozt()\n{\n    char * password;\n    char * &passwordRef = password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    \n    strcpy(password, \"Password1234!\");\n    {\n        char * password = passwordRef;\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_zexizijr()\n{\n    char * password;\n    char * &passwordRef = password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = strlen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (::bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(password, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(password, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    {\n        char * password = passwordRef;\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_lhpmchza()\n{\n    f_wycfpozt();\n    f_zexizijr();\n}\n\n\n} \n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_lhpmchza();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400888,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_33.cpp",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\nnamespace _A_namespace\n{\n\n\nvoid f_rfraocki()\n{\n    char * password;\n    char * &passwordRef = password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = strlen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (::bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(password, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(password, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    {\n        char * password = passwordRef;\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n} \n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_rfraocki();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400889,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_33.cpp",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic wchar_t * G2BSource(wchar_t * password)\n{\n    \n    wcscpy(password, L\"Password1234!\");\n    return password;\n}\n\nstatic void f_ydjhketr()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    password = G2BSource(password);\n    {\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        \n        \n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\n\nstatic wchar_t * B2GSource(wchar_t * password)\n{\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    return password;\n}\n\nstatic void f_stdqsyni()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    password = B2GSource(password);\n    {\n        HCRYPTPROV hCryptProv = 0;\n        HCRYPTHASH hHash = 0;\n        HCRYPTKEY hKey = 0;\n        char hashData[100] = HASH_INPUT;\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        do\n        {\n            BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n            DWORD payloadBytes;\n            \n            payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n            \n            SecureZeroMemory(password, 100 * sizeof(wchar_t));\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                break;\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                break;\n            }\n            \n            if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n            {\n                break;\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                break;\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n            {\n                break;\n            }\n            \n            memcpy(password, payload, payloadBytes);\n            password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n        }\n        while (0);\n        if (hKey)\n        {\n            CryptDestroyKey(hKey);\n        }\n        if (hHash)\n        {\n            CryptDestroyHash(hHash);\n        }\n        if (hCryptProv)\n        {\n            CryptReleaseContext(hCryptProv, 0);\n        }\n        \n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\nvoid f_lhoofyyy()\n{\n    f_stdqsyni();\n    f_ydjhketr();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_lhoofyyy();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400890,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_42.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nstatic wchar_t * Source(wchar_t * password)\n{\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    return password;\n}\n\nvoid f_upbnetzf()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    password = Source(password);\n    {\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        \n        \n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_upbnetzf();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400891,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_42.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_kqmerdby(wchar_t * password)\n{\n    {\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        \n        \n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\nstatic void f_ktyizvcc()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    \n    wcscpy(password, L\"Password1234!\");\n    f_kqmerdby(password);\n}\n\n\nstatic void f_bagiczgh(wchar_t * password)\n{\n    {\n        HCRYPTPROV hCryptProv = 0;\n        HCRYPTHASH hHash = 0;\n        HCRYPTKEY hKey = 0;\n        char hashData[100] = HASH_INPUT;\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        do\n        {\n            BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n            DWORD payloadBytes;\n            \n            payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n            \n            SecureZeroMemory(password, 100 * sizeof(wchar_t));\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                break;\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                break;\n            }\n            \n            if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n            {\n                break;\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                break;\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n            {\n                break;\n            }\n            \n            memcpy(password, payload, payloadBytes);\n            password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n        }\n        while (0);\n        if (hKey)\n        {\n            CryptDestroyKey(hKey);\n        }\n        if (hHash)\n        {\n            CryptDestroyHash(hHash);\n        }\n        if (hCryptProv)\n        {\n            CryptReleaseContext(hCryptProv, 0);\n        }\n        \n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\nstatic void f_xljgvljq()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    f_bagiczgh(password);\n}\n\nvoid f_zqnbpytg()\n{\n    f_xljgvljq();\n    f_ktyizvcc();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_zqnbpytg();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400892,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_41.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nstatic void f_xratsqif(wchar_t * password)\n{\n    {\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        \n        \n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\nvoid f_ryhliven()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    f_xratsqif(password);\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ryhliven();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400893,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_41.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_uiguuuag(char * password)\n{\n    {\n        HANDLE pHandle;\n        char * username = \"User\";\n        char * domain = \"Domain\";\n        \n        \n        if (LogonUserA(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\nstatic void f_emwgetwk()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    \n    strcpy(password, \"Password1234!\");\n    f_uiguuuag(password);\n}\n\n\nstatic void f_qioklikh(char * password)\n{\n    {\n        HCRYPTPROV hCryptProv = 0;\n        HCRYPTHASH hHash = 0;\n        HCRYPTKEY hKey = 0;\n        char hashData[100] = HASH_INPUT;\n        HANDLE pHandle;\n        char * username = \"User\";\n        char * domain = \"Domain\";\n        do\n        {\n            BYTE payload[(100 - 1) * sizeof(char)]; \n            DWORD payloadBytes;\n            \n            payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n            \n            SecureZeroMemory(password, 100 * sizeof(char));\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                break;\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                break;\n            }\n            \n            if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n            {\n                break;\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                break;\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n            {\n                break;\n            }\n            \n            memcpy(password, payload, payloadBytes);\n            password[payloadBytes / sizeof(char)] = '\\0';\n        }\n        while (0);\n        if (hKey)\n        {\n            CryptDestroyKey(hKey);\n        }\n        if (hHash)\n        {\n            CryptDestroyHash(hHash);\n        }\n        if (hCryptProv)\n        {\n            CryptReleaseContext(hCryptProv, 0);\n        }\n        \n        if (LogonUserA(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\nstatic void f_wksqrech()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = strlen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(password, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(password, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    f_qioklikh(password);\n}\n\nvoid f_ntkxlyxh()\n{\n    f_wksqrech();\n    f_emwgetwk();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ntkxlyxh();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400894,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_41.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nstatic void f_nrtxvhbm(char * password)\n{\n    {\n        HANDLE pHandle;\n        char * username = \"User\";\n        char * domain = \"Domain\";\n        \n        \n        if (LogonUserA(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\nvoid f_ulwigysl()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = strlen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(password, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(password, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    f_nrtxvhbm(password);\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ulwigysl();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400895,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_41.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_wmzlvslc()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    goto source;\nsource:\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    goto sink;\nsink:\n    {\n        HCRYPTPROV hCryptProv = 0;\n        HCRYPTHASH hHash = 0;\n        HCRYPTKEY hKey = 0;\n        char hashData[100] = HASH_INPUT;\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        do\n        {\n            BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n            DWORD payloadBytes;\n            \n            payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n            \n            SecureZeroMemory(password, 100 * sizeof(wchar_t));\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                break;\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                break;\n            }\n            \n            if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n            {\n                break;\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                break;\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n            {\n                break;\n            }\n            \n            memcpy(password, payload, payloadBytes);\n            password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n        }\n        while (0);\n        if (hKey)\n        {\n            CryptDestroyKey(hKey);\n        }\n        if (hHash)\n        {\n            CryptDestroyHash(hHash);\n        }\n        if (hCryptProv)\n        {\n            CryptReleaseContext(hCryptProv, 0);\n        }\n        \n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\n\nstatic void f_muutakoz()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    goto source;\nsource:\n    \n    wcscpy(password, L\"Password1234!\");\n    goto sink;\nsink:\n    {\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        \n        \n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\nvoid f_hkegehpa()\n{\n    f_wmzlvslc();\n    f_muutakoz();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_hkegehpa();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400896,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_18.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_ovbzogmu()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    goto source;\nsource:\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    goto sink;\nsink:\n    {\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        \n        \n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ovbzogmu();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400897,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_18.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_dkveunnx()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    goto source;\nsource:\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = strlen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(password, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(password, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    goto sink;\nsink:\n    {\n        HCRYPTPROV hCryptProv = 0;\n        HCRYPTHASH hHash = 0;\n        HCRYPTKEY hKey = 0;\n        char hashData[100] = HASH_INPUT;\n        HANDLE pHandle;\n        char * username = \"User\";\n        char * domain = \"Domain\";\n        do\n        {\n            BYTE payload[(100 - 1) * sizeof(char)]; \n            DWORD payloadBytes;\n            \n            payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n            \n            SecureZeroMemory(password, 100 * sizeof(char));\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                break;\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                break;\n            }\n            \n            if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n            {\n                break;\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                break;\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n            {\n                break;\n            }\n            \n            memcpy(password, payload, payloadBytes);\n            password[payloadBytes / sizeof(char)] = '\\0';\n        }\n        while (0);\n        if (hKey)\n        {\n            CryptDestroyKey(hKey);\n        }\n        if (hHash)\n        {\n            CryptDestroyHash(hHash);\n        }\n        if (hCryptProv)\n        {\n            CryptReleaseContext(hCryptProv, 0);\n        }\n        \n        if (LogonUserA(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\n\nstatic void f_jupqyhve()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    goto source;\nsource:\n    \n    strcpy(password, \"Password1234!\");\n    goto sink;\nsink:\n    {\n        HANDLE pHandle;\n        char * username = \"User\";\n        char * domain = \"Domain\";\n        \n        \n        if (LogonUserA(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\nvoid f_tqoibgdl()\n{\n    f_dkveunnx();\n    f_jupqyhve();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_tqoibgdl();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400898,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_18.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_brkvzgzc()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    goto source;\nsource:\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = strlen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(password, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(password, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    goto sink;\nsink:\n    {\n        HANDLE pHandle;\n        char * username = \"User\";\n        char * domain = \"Domain\";\n        \n        \n        if (LogonUserA(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_brkvzgzc();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400899,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_18.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_twqnatar()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    \n    strcpy(password, \"Password1234!\");\n    {\n        char * passwordCopy = password;\n        char * password = passwordCopy;\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_yzuucrfn()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = strlen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(password, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(password, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    {\n        char * passwordCopy = password;\n        char * password = passwordCopy;\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_qjvfyean()\n{\n    f_twqnatar();\n    f_yzuucrfn();\n}\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_qjvfyean();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400900,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_31.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_ownqbfww()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = strlen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(password, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(password, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    {\n        char * passwordCopy = password;\n        char * password = passwordCopy;\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ownqbfww();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400901,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_31.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_gmaqxwud()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    \n    wcscpy(password, L\"Password1234!\");\n    {\n        wchar_t * passwordCopy = password;\n        wchar_t * password = passwordCopy;\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_anwzrtpm()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    {\n        wchar_t * passwordCopy = password;\n        wchar_t * password = passwordCopy;\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_rktkwfci()\n{\n    f_gmaqxwud();\n    f_anwzrtpm();\n}\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_rktkwfci();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400902,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_31.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_bytnhbic()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    {\n        wchar_t * passwordCopy = password;\n        wchar_t * password = passwordCopy;\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_bytnhbic();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400903,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_31.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_edrxiapf()\n{\n    wchar_t * password;\n    wchar_t * *passwordPtr1 = &password;\n    wchar_t * *passwordPtr2 = &password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    {\n        wchar_t * password = *passwordPtr1;\n        \n        wcscpy(password, L\"Password1234!\");\n        *passwordPtr1 = password;\n    }\n    {\n        wchar_t * password = *passwordPtr2;\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_vcumrkht()\n{\n    wchar_t * password;\n    wchar_t * *passwordPtr1 = &password;\n    wchar_t * *passwordPtr2 = &password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    {\n        wchar_t * password = *passwordPtr1;\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n        *passwordPtr1 = password;\n    }\n    {\n        wchar_t * password = *passwordPtr2;\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_psrnnawx()\n{\n    f_edrxiapf();\n    f_vcumrkht();\n}\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_psrnnawx();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400904,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_32.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_nmwkdkfa()\n{\n    wchar_t * password;\n    wchar_t * *passwordPtr1 = &password;\n    wchar_t * *passwordPtr2 = &password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    {\n        wchar_t * password = *passwordPtr1;\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n        *passwordPtr1 = password;\n    }\n    {\n        wchar_t * password = *passwordPtr2;\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_nmwkdkfa();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400905,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_32.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_ccodntqb()\n{\n    char * password;\n    char * *passwordPtr1 = &password;\n    char * *passwordPtr2 = &password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    {\n        char * password = *passwordPtr1;\n        \n        strcpy(password, \"Password1234!\");\n        *passwordPtr1 = password;\n    }\n    {\n        char * password = *passwordPtr2;\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_ugjusudx()\n{\n    char * password;\n    char * *passwordPtr1 = &password;\n    char * *passwordPtr2 = &password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    {\n        char * password = *passwordPtr1;\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n        *passwordPtr1 = password;\n    }\n    {\n        char * password = *passwordPtr2;\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_hxmoujni()\n{\n    f_ccodntqb();\n    f_ugjusudx();\n}\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_hxmoujni();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400906,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_32.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_jaoumdbl()\n{\n    char * password;\n    char * *passwordPtr1 = &password;\n    char * *passwordPtr2 = &password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    {\n        char * password = *passwordPtr1;\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n        *passwordPtr1 = password;\n    }\n    {\n        char * password = *passwordPtr2;\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_jaoumdbl();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400907,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_32.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_mmbrmnxt()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    \n    strcpy(password, \"Password1234!\");\n    {\n        HANDLE pHandle;\n        char * username = \"User\";\n        char * domain = \"Domain\";\n        \n        \n        if (LogonUserA(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\n\nstatic void f_jejpfvuq()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = strlen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(password, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(password, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    {\n        HCRYPTPROV hCryptProv = 0;\n        HCRYPTHASH hHash = 0;\n        HCRYPTKEY hKey = 0;\n        char hashData[100] = HASH_INPUT;\n        HANDLE pHandle;\n        char * username = \"User\";\n        char * domain = \"Domain\";\n        do\n        {\n            BYTE payload[(100 - 1) * sizeof(char)]; \n            DWORD payloadBytes;\n            \n            payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n            \n            SecureZeroMemory(password, 100 * sizeof(char));\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                break;\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                break;\n            }\n            \n            if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n            {\n                break;\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                break;\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n            {\n                break;\n            }\n            \n            memcpy(password, payload, payloadBytes);\n            password[payloadBytes / sizeof(char)] = '\\0';\n        }\n        while (0);\n        if (hKey)\n        {\n            CryptDestroyKey(hKey);\n        }\n        if (hHash)\n        {\n            CryptDestroyHash(hHash);\n        }\n        if (hCryptProv)\n        {\n            CryptReleaseContext(hCryptProv, 0);\n        }\n        \n        if (LogonUserA(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\nvoid f_sacdcujl()\n{\n    f_mmbrmnxt();\n    f_jejpfvuq();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_sacdcujl();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400908,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_01.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_uybbuwbo()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = strlen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(password, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(password, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    {\n        HANDLE pHandle;\n        char * username = \"User\";\n        char * domain = \"Domain\";\n        \n        \n        if (LogonUserA(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_uybbuwbo();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400909,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_01.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_jkcbpfzf()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    \n    wcscpy(password, L\"Password1234!\");\n    {\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        \n        \n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\n\nstatic void f_qdryrgch()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    {\n        HCRYPTPROV hCryptProv = 0;\n        HCRYPTHASH hHash = 0;\n        HCRYPTKEY hKey = 0;\n        char hashData[100] = HASH_INPUT;\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        do\n        {\n            BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n            DWORD payloadBytes;\n            \n            payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n            \n            SecureZeroMemory(password, 100 * sizeof(wchar_t));\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                break;\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                break;\n            }\n            \n            if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n            {\n                break;\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                break;\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n            {\n                break;\n            }\n            \n            memcpy(password, payload, payloadBytes);\n            password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n        }\n        while (0);\n        if (hKey)\n        {\n            CryptDestroyKey(hKey);\n        }\n        if (hHash)\n        {\n            CryptDestroyHash(hHash);\n        }\n        if (hCryptProv)\n        {\n            CryptReleaseContext(hCryptProv, 0);\n        }\n        \n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\nvoid f_fbxsvgmw()\n{\n    f_jkcbpfzf();\n    f_qdryrgch();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_fbxsvgmw();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400910,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_01.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_pfnpxics()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    {\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        \n        \n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_pfnpxics();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400911,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_01.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_wqcduznt()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    while(1)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n        break;\n    }\n    while(1)\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n        break;\n    }\n}\n\n\nstatic void f_uqhvycfj()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    while(1)\n    {\n        \n        strcpy(password, \"Password1234!\");\n        break;\n    }\n    while(1)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n        break;\n    }\n}\n\nvoid f_ykbsgvnv()\n{\n    f_wqcduznt();\n    f_uqhvycfj();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ykbsgvnv();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400912,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_16.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_jetdmikz()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    while(1)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n        break;\n    }\n    while(1)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n        break;\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_jetdmikz();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400913,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_16.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\nstatic char * _Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_45_Data;\nstatic char * _Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_45_G2BData;\nstatic char * _Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_45_B2GData;\n\n\n\n\nstatic void f_cguehqou()\n{\n    char * password = _Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_45_G2BData;\n    {\n        HANDLE pHandle;\n        char * username = \"User\";\n        char * domain = \"Domain\";\n        \n        \n        if (LogonUserA(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\nstatic void f_kqaetlnu()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    \n    strcpy(password, \"Password1234!\");\n    _Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_45_G2BData = password;\n    f_cguehqou();\n}\n\n\nstatic void f_bamyecvl()\n{\n    char * password = _Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_45_B2GData;\n    {\n        HCRYPTPROV hCryptProv = 0;\n        HCRYPTHASH hHash = 0;\n        HCRYPTKEY hKey = 0;\n        char hashData[100] = HASH_INPUT;\n        HANDLE pHandle;\n        char * username = \"User\";\n        char * domain = \"Domain\";\n        do\n        {\n            BYTE payload[(100 - 1) * sizeof(char)]; \n            DWORD payloadBytes;\n            \n            payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n            \n            SecureZeroMemory(password, 100 * sizeof(char));\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                break;\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                break;\n            }\n            \n            if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n            {\n                break;\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                break;\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n            {\n                break;\n            }\n            \n            memcpy(password, payload, payloadBytes);\n            password[payloadBytes / sizeof(char)] = '\\0';\n        }\n        while (0);\n        if (hKey)\n        {\n            CryptDestroyKey(hKey);\n        }\n        if (hHash)\n        {\n            CryptDestroyHash(hHash);\n        }\n        if (hCryptProv)\n        {\n            CryptReleaseContext(hCryptProv, 0);\n        }\n        \n        if (LogonUserA(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\nstatic void f_nkjfswfa()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t passwordLen = strlen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(password, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(password, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            closesocket(connectSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    _Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_45_B2GData = password;\n    f_bamyecvl();\n}\n\nvoid f_hivmwtib()\n{\n    f_kqaetlnu();\n    f_nkjfswfa();\n}\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_hivmwtib();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400914,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_45.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\nstatic char * _Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_45_Data;\nstatic char * _Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_45_G2BData;\nstatic char * _Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_45_B2GData;\n\n\nstatic void f_ilqsupir()\n{\n    char * password = _Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_45_Data;\n    {\n        HANDLE pHandle;\n        char * username = \"User\";\n        char * domain = \"Domain\";\n        \n        \n        if (LogonUserA(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\nvoid f_ndatdxws()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t passwordLen = strlen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(password, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(password, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            closesocket(connectSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    _Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_45_Data = password;\n    f_ilqsupir();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ndatdxws();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400915,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_45.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\nstatic wchar_t * _Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_45_Data;\nstatic wchar_t * _Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_45_G2BData;\nstatic wchar_t * _Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_45_B2GData;\n\n\n\n\nstatic void f_qfselhtj()\n{\n    wchar_t * password = _Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_45_G2BData;\n    {\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        \n        \n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\nstatic void f_xnvtoqvc()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    \n    wcscpy(password, L\"Password1234!\");\n    _Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_45_G2BData = password;\n    f_qfselhtj();\n}\n\n\nstatic void f_hzxjngkd()\n{\n    wchar_t * password = _Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_45_B2GData;\n    {\n        HCRYPTPROV hCryptProv = 0;\n        HCRYPTHASH hHash = 0;\n        HCRYPTKEY hKey = 0;\n        char hashData[100] = HASH_INPUT;\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        do\n        {\n            BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n            DWORD payloadBytes;\n            \n            payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n            \n            SecureZeroMemory(password, 100 * sizeof(wchar_t));\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                break;\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                break;\n            }\n            \n            if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n            {\n                break;\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                break;\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n            {\n                break;\n            }\n            \n            memcpy(password, payload, payloadBytes);\n            password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n        }\n        while (0);\n        if (hKey)\n        {\n            CryptDestroyKey(hKey);\n        }\n        if (hHash)\n        {\n            CryptDestroyHash(hHash);\n        }\n        if (hCryptProv)\n        {\n            CryptReleaseContext(hCryptProv, 0);\n        }\n        \n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\nstatic void f_xjpdjqfd()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            closesocket(connectSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    _Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_45_B2GData = password;\n    f_hzxjngkd();\n}\n\nvoid f_rxcdwvzw()\n{\n    f_xnvtoqvc();\n    f_xjpdjqfd();\n}\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_rxcdwvzw();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400916,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_45.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\nstatic wchar_t * _Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_45_Data;\nstatic wchar_t * _Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_45_G2BData;\nstatic wchar_t * _Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_45_B2GData;\n\n\nstatic void f_tbhvpftj()\n{\n    wchar_t * password = _Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_45_Data;\n    {\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        \n        \n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\nvoid f_qjevsgfv()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            closesocket(connectSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    _Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_45_Data = password;\n    f_tbhvpftj();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_qjevsgfv();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400917,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_45.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_pqmmkxtn()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    while(1)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n        break;\n    }\n    while(1)\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n        break;\n    }\n}\n\n\nstatic void f_ahrocotc()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    while(1)\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n        break;\n    }\n    while(1)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n        break;\n    }\n}\n\nvoid f_wjrogpks()\n{\n    f_pqmmkxtn();\n    f_ahrocotc();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_wjrogpks();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400918,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_16.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_faarjcrj()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    while(1)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n        break;\n    }\n    while(1)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n        break;\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_faarjcrj();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400919,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_16.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_flqwojuk(char * &password)\n{\n    \n    strcpy(password, \"Password1234!\");\n}\n\nstatic void f_sumnluok()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    f_flqwojuk(password);\n    {\n        HANDLE pHandle;\n        char * username = \"User\";\n        char * domain = \"Domain\";\n        \n        \n        if (LogonUserA(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\n\nstatic void f_gbsnobrw(char * &password)\n{\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t passwordLen = strlen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(password, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(password, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            closesocket(connectSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n}\n\nstatic void f_yqzncyco()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    f_gbsnobrw(password);\n    {\n        HCRYPTPROV hCryptProv = 0;\n        HCRYPTHASH hHash = 0;\n        HCRYPTKEY hKey = 0;\n        char hashData[100] = HASH_INPUT;\n        HANDLE pHandle;\n        char * username = \"User\";\n        char * domain = \"Domain\";\n        do\n        {\n            BYTE payload[(100 - 1) * sizeof(char)]; \n            DWORD payloadBytes;\n            \n            payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n            \n            SecureZeroMemory(password, 100 * sizeof(char));\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                break;\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                break;\n            }\n            \n            if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n            {\n                break;\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                break;\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n            {\n                break;\n            }\n            \n            memcpy(password, payload, payloadBytes);\n            password[payloadBytes / sizeof(char)] = '\\0';\n        }\n        while (0);\n        if (hKey)\n        {\n            CryptDestroyKey(hKey);\n        }\n        if (hHash)\n        {\n            CryptDestroyHash(hHash);\n        }\n        if (hCryptProv)\n        {\n            CryptReleaseContext(hCryptProv, 0);\n        }\n        \n        if (LogonUserA(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\nvoid f_wbtdaovy()\n{\n    f_sumnluok();\n    f_yqzncyco();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_wbtdaovy();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400920,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_43.cpp",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\nnamespace _A_namespace\n{\n\n\nstatic void f_valolbiy(char * &password)\n{\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t passwordLen = strlen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(password, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(password, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            closesocket(connectSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n}\n\nvoid f_eyejqjbb()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    f_valolbiy(password);\n    {\n        HANDLE pHandle;\n        char * username = \"User\";\n        char * domain = \"Domain\";\n        \n        \n        if (LogonUserA(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_eyejqjbb();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400921,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_43.cpp",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\nnamespace _A_namespace\n{\n\n\n\n\nstatic void f_qotvjnmo(wchar_t * &password)\n{\n    \n    wcscpy(password, L\"Password1234!\");\n}\n\nstatic void f_rnahyiav()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    f_qotvjnmo(password);\n    {\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        \n        \n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\n\nstatic void f_celokoyp(wchar_t * &password)\n{\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            closesocket(connectSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n}\n\nstatic void f_lnxszitv()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    f_celokoyp(password);\n    {\n        HCRYPTPROV hCryptProv = 0;\n        HCRYPTHASH hHash = 0;\n        HCRYPTKEY hKey = 0;\n        char hashData[100] = HASH_INPUT;\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        do\n        {\n            BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n            DWORD payloadBytes;\n            \n            payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n            \n            SecureZeroMemory(password, 100 * sizeof(wchar_t));\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                break;\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                break;\n            }\n            \n            if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n            {\n                break;\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                break;\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n            {\n                break;\n            }\n            \n            memcpy(password, payload, payloadBytes);\n            password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n        }\n        while (0);\n        if (hKey)\n        {\n            CryptDestroyKey(hKey);\n        }\n        if (hHash)\n        {\n            CryptDestroyHash(hHash);\n        }\n        if (hCryptProv)\n        {\n            CryptReleaseContext(hCryptProv, 0);\n        }\n        \n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\nvoid f_sfdsrljt()\n{\n    f_rnahyiav();\n    f_lnxszitv();\n}\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_sfdsrljt();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400922,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_43.cpp",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\nnamespace _A_namespace\n{\n\n\nstatic void f_eqsaxfnm(wchar_t * &password)\n{\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            closesocket(connectSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n}\n\nvoid f_nwgmczec()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    f_eqsaxfnm(password);\n    {\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        \n        \n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\n\n\n} \n\n\n\n\nusing namespace _A_namespace; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_nwgmczec();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400923,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_43.cpp",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_bnragsty()\n{\n    int i,k;\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    for(i = 0; i < 1; i++)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    for(k = 0; k < 1; k++)\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_qibrzsud()\n{\n    int h,j;\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    for(h = 0; h < 1; h++)\n    {\n        \n        strcpy(password, \"Password1234!\");\n    }\n    for(j = 0; j < 1; j++)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_ekpnvihq()\n{\n    f_bnragsty();\n    f_qibrzsud();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ekpnvihq();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400924,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_17.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_jlwmtywy()\n{\n    int i,j;\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    for(i = 0; i < 1; i++)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = strlen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(password, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(password, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    for(j = 0; j < 1; j++)\n    {\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_jlwmtywy();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400925,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_17.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_hhkswaxz()\n{\n    int i,k;\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    for(i = 0; i < 1; i++)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    for(k = 0; k < 1; k++)\n    {\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_hkbllzrx()\n{\n    int h,j;\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    for(h = 0; h < 1; h++)\n    {\n        \n        wcscpy(password, L\"Password1234!\");\n    }\n    for(j = 0; j < 1; j++)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_liwywkul()\n{\n    f_hhkswaxz();\n    f_hkbllzrx();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_liwywkul();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400926,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_17.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nvoid f_onpahqje()\n{\n    int i,j;\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    for(i = 0; i < 1; i++)\n    {\n        {\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t passwordLen = wcslen(password);\n            do\n            {\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n                \n                recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                \n                replace = wcschr(password, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(password, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                closesocket(connectSocket);\n            }\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n        }\n    }\n    for(j = 0; j < 1; j++)\n    {\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_onpahqje();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400927,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_17.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\ntypedef union\n{\n    char * unionFirst;\n    char * unionSecond;\n} _Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_34_unionType;\n\n\n\n\nstatic void f_rzbygmhj()\n{\n    char * password;\n    _Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_34_unionType myUnion;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    \n    strcpy(password, \"Password1234!\");\n    myUnion.unionFirst = password;\n    {\n        char * password = myUnion.unionSecond;\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_pldkhtxr()\n{\n    char * password;\n    _Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_34_unionType myUnion;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t passwordLen = strlen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(password, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(password, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            closesocket(connectSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    myUnion.unionFirst = password;\n    {\n        char * password = myUnion.unionSecond;\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(char)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(char));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(char)] = '\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_cpzrlvdw()\n{\n    f_rzbygmhj();\n    f_pldkhtxr();\n}\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_cpzrlvdw();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400928,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_34.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\ntypedef union\n{\n    char * unionFirst;\n    char * unionSecond;\n} _Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_34_unionType;\n\n\nvoid f_ezmlyvmh()\n{\n    char * password;\n    _Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_34_unionType myUnion;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t passwordLen = strlen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(password, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(password, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            closesocket(connectSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    myUnion.unionFirst = password;\n    {\n        char * password = myUnion.unionSecond;\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            \n            \n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ezmlyvmh();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400929,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_34.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\ntypedef union\n{\n    wchar_t * unionFirst;\n    wchar_t * unionSecond;\n} _Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_34_unionType;\n\n\n\n\nstatic void f_fhymnspe()\n{\n    wchar_t * password;\n    _Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_34_unionType myUnion;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    \n    wcscpy(password, L\"Password1234!\");\n    myUnion.unionFirst = password;\n    {\n        wchar_t * password = myUnion.unionSecond;\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\nstatic void f_sxlujksz()\n{\n    wchar_t * password;\n    _Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_34_unionType myUnion;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            closesocket(connectSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    myUnion.unionFirst = password;\n    {\n        wchar_t * password = myUnion.unionSecond;\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n                DWORD payloadBytes;\n                \n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                \n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                \n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                \n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                \n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                \n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                \n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                \n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid f_shwjievt()\n{\n    f_fhymnspe();\n    f_sxlujksz();\n}\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_shwjievt();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400930,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_34.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\ntypedef union\n{\n    wchar_t * unionFirst;\n    wchar_t * unionSecond;\n} _Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_34_unionType;\n\n\nvoid f_fudbahdc()\n{\n    wchar_t * password;\n    _Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_34_unionType myUnion;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            closesocket(connectSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    myUnion.unionFirst = password;\n    {\n        wchar_t * password = myUnion.unionSecond;\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            \n            \n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_fudbahdc();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400931,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_34.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_vjtiqilc(wchar_t * password)\n{\n    {\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        \n        \n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\nstatic void f_mqsufasg()\n{\n    wchar_t * password;\n    void (*funcPtr) (wchar_t *) = f_vjtiqilc;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    \n    wcscpy(password, L\"Password1234!\");\n    funcPtr(password);\n}\n\n\nstatic void f_cbvykauz(wchar_t * password)\n{\n    {\n        HCRYPTPROV hCryptProv = 0;\n        HCRYPTHASH hHash = 0;\n        HCRYPTKEY hKey = 0;\n        char hashData[100] = HASH_INPUT;\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        do\n        {\n            BYTE payload[(100 - 1) * sizeof(wchar_t)]; \n            DWORD payloadBytes;\n            \n            payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n            \n            SecureZeroMemory(password, 100 * sizeof(wchar_t));\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                break;\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                break;\n            }\n            \n            if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n            {\n                break;\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                break;\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n            {\n                break;\n            }\n            \n            memcpy(password, payload, payloadBytes);\n            password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n        }\n        while (0);\n        if (hKey)\n        {\n            CryptDestroyKey(hKey);\n        }\n        if (hHash)\n        {\n            CryptDestroyHash(hHash);\n        }\n        if (hCryptProv)\n        {\n            CryptReleaseContext(hCryptProv, 0);\n        }\n        \n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\nstatic void f_veiickjb()\n{\n    wchar_t * password;\n    void (*funcPtr) (wchar_t *) = f_cbvykauz;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            closesocket(connectSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    funcPtr(password);\n}\n\nvoid f_prskzftt()\n{\n    f_mqsufasg();\n    f_veiickjb();\n}\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_prskzftt();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400932,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_44.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nstatic void f_whguyomr(wchar_t * password)\n{\n    {\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        \n        \n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\nvoid f_rmdextsx()\n{\n    wchar_t * password;\n    \n    void (*funcPtr) (wchar_t *) = f_whguyomr;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            \n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            closesocket(connectSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    \n    funcPtr(password);\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_rmdextsx();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400933,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_44.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\n\n\nstatic void f_hymmbytj(char * password)\n{\n    {\n        HANDLE pHandle;\n        char * username = \"User\";\n        char * domain = \"Domain\";\n        \n        \n        if (LogonUserA(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\nstatic void f_cfvwcfih()\n{\n    char * password;\n    void (*funcPtr) (char *) = f_hymmbytj;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    \n    strcpy(password, \"Password1234!\");\n    funcPtr(password);\n}\n\n\nstatic void f_zqcnrbjl(char * password)\n{\n    {\n        HCRYPTPROV hCryptProv = 0;\n        HCRYPTHASH hHash = 0;\n        HCRYPTKEY hKey = 0;\n        char hashData[100] = HASH_INPUT;\n        HANDLE pHandle;\n        char * username = \"User\";\n        char * domain = \"Domain\";\n        do\n        {\n            BYTE payload[(100 - 1) * sizeof(char)]; \n            DWORD payloadBytes;\n            \n            payloadBytes = decodeHexChars(payload, sizeof(payload), password);\n            \n            SecureZeroMemory(password, 100 * sizeof(char));\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                break;\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                break;\n            }\n            \n            if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n            {\n                break;\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                break;\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n            {\n                break;\n            }\n            \n            memcpy(password, payload, payloadBytes);\n            password[payloadBytes / sizeof(char)] = '\\0';\n        }\n        while (0);\n        if (hKey)\n        {\n            CryptDestroyKey(hKey);\n        }\n        if (hHash)\n        {\n            CryptDestroyHash(hHash);\n        }\n        if (hCryptProv)\n        {\n            CryptReleaseContext(hCryptProv, 0);\n        }\n        \n        if (LogonUserA(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\nstatic void f_uxijxcib()\n{\n    char * password;\n    void (*funcPtr) (char *) = f_zqcnrbjl;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t passwordLen = strlen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(password, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(password, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            closesocket(connectSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    funcPtr(password);\n}\n\nvoid f_wgbiodzp()\n{\n    f_cfvwcfih();\n    f_uxijxcib();\n}\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_wgbiodzp();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400934,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_44.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  },
  {
    "CWE_ID": [
      "CWE-319"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" \n\n\nstatic void f_uarsnkwm(char * password)\n{\n    {\n        HANDLE pHandle;\n        char * username = \"User\";\n        char * domain = \"Domain\";\n        \n        \n        if (LogonUserA(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\nvoid f_udqxmznc()\n{\n    char * password;\n    \n    void (*funcPtr) (char *) = f_uarsnkwm;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t passwordLen = strlen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n            \n            recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            password[passwordLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(password, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(password, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            closesocket(connectSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    \n    funcPtr(password);\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_udqxmznc();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 400935,
    "original_file": "testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_44.c",
    "RELATED_CWE": [
      "CWE-352",
      "CWE-601",
      "CWE-918"
    ]
  }
]