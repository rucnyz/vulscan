[
  {
    "CWE_ID": [
      "CWE-89"
    ],
    "code": "int msPostGISLayerSetTimeFilter(layerObj *lp, const char *timestring, const char *timefield)\n{\n  char **atimes, **aranges = NULL;\n  int numtimes=0,i=0,numranges=0;\n  size_t buffer_size = 512;\n  char buffer[512], bufferTmp[512];\n\n  buffer[0] = '\\0';\n  bufferTmp[0] = '\\0';\n\n   if (!lp || !timestring || !timefield)\n     return MS_FALSE;\n \n   /* discrete time */\n   if (strstr(timestring, \",\") == NULL &&\n       strstr(timestring, \"/\") == NULL) { /* discrete time */\n    createPostgresTimeCompareSimple(timefield, timestring, buffer, buffer_size);\n  } else {\n\n    /* multiple times, or ranges */\n    atimes = msStringSplit (timestring, ',', &numtimes);\n    if (atimes == NULL || numtimes < 1)\n      return MS_FALSE;\n\n    strlcat(buffer, \"(\", buffer_size);\n    for(i=0; i<numtimes; i++) {\n      if(i!=0) {\n        strlcat(buffer, \" OR \", buffer_size);\n      }\n      strlcat(buffer, \"(\", buffer_size);\n      aranges = msStringSplit(atimes[i],  '/', &numranges);\n      if(!aranges) return MS_FALSE;\n      if(numranges == 1) {\n        /* we don't have range, just a simple time */\n        createPostgresTimeCompareSimple(timefield, atimes[i], bufferTmp, buffer_size);\n        strlcat(buffer, bufferTmp, buffer_size);\n      } else if(numranges == 2) {\n        /* we have a range */\n        createPostgresTimeCompareRange(timefield, aranges[0], aranges[1], bufferTmp, buffer_size);\n        strlcat(buffer, bufferTmp, buffer_size);\n      } else {\n        return MS_FALSE;\n      }\n      msFreeCharArray(aranges, numranges);\n      strlcat(buffer, \")\", buffer_size);\n    }\n    strlcat(buffer, \")\", buffer_size);\n    msFreeCharArray(atimes, numtimes);\n  }\n  if(!*buffer) {\n    return MS_FALSE;\n  }\n  if(lp->filteritem) free(lp->filteritem);\n  lp->filteritem = msStrdup(timefield);\n  if (&lp->filter) {\n    /* if the filter is set and it's a string type, concatenate it with\n       the time. If not just free it */\n    if (lp->filter.type == MS_EXPRESSION) {\n      snprintf(bufferTmp, buffer_size, \"(%s) and %s\", lp->filter.string, buffer);\n      loadExpressionString(&lp->filter, bufferTmp);\n    } else {\n      freeExpression(&lp->filter);\n      loadExpressionString(&lp->filter, buffer);\n    }\n  }\n\n\n  return MS_TRUE;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141941,
    "RELATED_CWE": [
      "CWE-90",
      "CWE-91",
      "CWE-78"
    ]
  },
  {
    "CWE_ID": [
      "CWE-89"
    ],
    "code": "int msPostGISLayerSetTimeFilter(layerObj *lp, const char *timestring, const char *timefield)\n{\n  char **atimes, **aranges = NULL;\n  int numtimes=0,i=0,numranges=0;\n  size_t buffer_size = 512;\n  char buffer[512], bufferTmp[512];\n\n  buffer[0] = '\\0';\n  bufferTmp[0] = '\\0';\n\n   if (!lp || !timestring || !timefield)\n     return MS_FALSE;\n \n  if( strchr(timestring,'\\'') || strchr(timestring, '\\\\') ) {\n     msSetError(MS_MISCERR, \"Invalid time filter.\", \"msPostGISLayerSetTimeFilter()\");\n     return MS_FALSE;\n  }\n\n   /* discrete time */\n   if (strstr(timestring, \",\") == NULL &&\n       strstr(timestring, \"/\") == NULL) { /* discrete time */\n    createPostgresTimeCompareSimple(timefield, timestring, buffer, buffer_size);\n  } else {\n\n    /* multiple times, or ranges */\n    atimes = msStringSplit (timestring, ',', &numtimes);\n    if (atimes == NULL || numtimes < 1)\n      return MS_FALSE;\n\n    strlcat(buffer, \"(\", buffer_size);\n    for(i=0; i<numtimes; i++) {\n      if(i!=0) {\n        strlcat(buffer, \" OR \", buffer_size);\n      }\n      strlcat(buffer, \"(\", buffer_size);\n      aranges = msStringSplit(atimes[i],  '/', &numranges);\n      if(!aranges) return MS_FALSE;\n      if(numranges == 1) {\n        /* we don't have range, just a simple time */\n        createPostgresTimeCompareSimple(timefield, atimes[i], bufferTmp, buffer_size);\n        strlcat(buffer, bufferTmp, buffer_size);\n      } else if(numranges == 2) {\n        /* we have a range */\n        createPostgresTimeCompareRange(timefield, aranges[0], aranges[1], bufferTmp, buffer_size);\n        strlcat(buffer, bufferTmp, buffer_size);\n      } else {\n        return MS_FALSE;\n      }\n      msFreeCharArray(aranges, numranges);\n      strlcat(buffer, \")\", buffer_size);\n    }\n    strlcat(buffer, \")\", buffer_size);\n    msFreeCharArray(atimes, numtimes);\n  }\n  if(!*buffer) {\n    return MS_FALSE;\n  }\n  if(lp->filteritem) free(lp->filteritem);\n  lp->filteritem = msStrdup(timefield);\n  if (&lp->filter) {\n    /* if the filter is set and it's a string type, concatenate it with\n       the time. If not just free it */\n    if (lp->filter.type == MS_EXPRESSION) {\n      snprintf(bufferTmp, buffer_size, \"(%s) and %s\", lp->filter.string, buffer);\n      loadExpressionString(&lp->filter, bufferTmp);\n    } else {\n      freeExpression(&lp->filter);\n      loadExpressionString(&lp->filter, buffer);\n    }\n  }\n\n\n  return MS_TRUE;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141942,
    "RELATED_CWE": [
      "CWE-90",
      "CWE-91",
      "CWE-78"
    ]
  },
  {
    "CWE_ID": [
      "CWE-89"
    ],
    "code": "\t\tvoid CWebServer::GetFloorplanImage(WebEmSession & session, const request& req, reply & rep)\n\t\t{\n\t\t\tstd::string idx = request::findValue(&req, \"idx\");\n\t\t\tif (idx == \"\") {\n \t\t\t\treturn;\n \t\t\t}\n \t\t\tstd::vector<std::vector<std::string> > result;\n\t\t\tresult = m_sql.safe_queryBlob(\"SELECT Image FROM Floorplans WHERE ID=%s\", idx.c_str());\n \t\t\tif (result.empty())\n \t\t\t\treturn;\n \t\t\treply::set_content(&rep, result[0][0].begin(), result[0][0].end());\n\t\t\tstd::string oname = \"floorplan\";\n\t\t\tif (result[0][0].size() > 10)\n\t\t\t{\n\t\t\t\tif (result[0][0][0] == 'P')\n\t\t\t\t\toname += \".png\";\n\t\t\t\telse if (result[0][0][0] == -1)\n\t\t\t\t\toname += \".jpg\";\n\t\t\t\telse if (result[0][0][0] == 'B')\n\t\t\t\t\toname += \".bmp\";\n\t\t\t\telse if (result[0][0][0] == 'G')\n\t\t\t\t\toname += \".gif\";\n\t\t\t}\n\t\t\treply::add_header_attachment(&rep, oname);\n\t\t}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143285,
    "human": "Correct. With CWE-89",
    "reason": "It is vulnerable to SQL injection if safe_queryBlob does not properly sanitize the %s input.",
    "RELATED_CWE": [
      "CWE-90",
      "CWE-91",
      "CWE-78"
    ]
  },
  {
    "CWE_ID": [
      "CWE-89"
    ],
    "code": "\t\tvoid CWebServer::GetFloorplanImage(WebEmSession & session, const request& req, reply & rep)\n\t\t{\n\t\t\tstd::string idx = request::findValue(&req, \"idx\");\n\t\t\tif (idx == \"\") {\n \t\t\t\treturn;\n \t\t\t}\n \t\t\tstd::vector<std::vector<std::string> > result;\n\t\t\tresult = m_sql.safe_queryBlob(\"SELECT Image FROM Floorplans WHERE ID=%d\", atol(idx.c_str()));\n \t\t\tif (result.empty())\n \t\t\t\treturn;\n \t\t\treply::set_content(&rep, result[0][0].begin(), result[0][0].end());\n\t\t\tstd::string oname = \"floorplan\";\n\t\t\tif (result[0][0].size() > 10)\n\t\t\t{\n\t\t\t\tif (result[0][0][0] == 'P')\n\t\t\t\t\toname += \".png\";\n\t\t\t\telse if (result[0][0][0] == -1)\n\t\t\t\t\toname += \".jpg\";\n\t\t\t\telse if (result[0][0][0] == 'B')\n\t\t\t\t\toname += \".bmp\";\n\t\t\t\telse if (result[0][0][0] == 'G')\n\t\t\t\t\toname += \".gif\";\n\t\t\t}\n\t\t\treply::add_header_attachment(&rep, oname);\n\t\t}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143286,
    "human": "Correct. Without CWE-89",
    "RELATED_CWE": [
      "CWE-90",
      "CWE-91",
      "CWE-78"
    ]
  },
  {
    "CWE_ID": [
      "CWE-89"
    ],
    "code": "ProcessStartupPacket(Port *port, bool ssl_done, bool gss_done)\n{\n\tint32\t\tlen;\n\tchar\t   *buf;\n\tProtocolVersion proto;\n\tMemoryContext oldcontext;\n\n\tpq_startmsgread();\n\n\t/*\n\t * Grab the first byte of the length word separately, so that we can tell\n\t * whether we have no data at all or an incomplete packet.  (This might\n\t * sound inefficient, but it's not really, because of buffering in\n\t * pqcomm.c.)\n\t */\n\tif (pq_getbytes((char *) &len, 1) == EOF)\n\t{\n\t\t/*\n\t\t * If we get no data at all, don't clutter the log with a complaint;\n\t\t * such cases often occur for legitimate reasons.  An example is that\n\t\t * we might be here after responding to NEGOTIATE_SSL_CODE, and if the\n\t\t * client didn't like our response, it'll probably just drop the\n\t\t * connection.  Service-monitoring software also often just opens and\n\t\t * closes a connection without sending anything.  (So do port\n\t\t * scanners, which may be less benign, but it's not really our job to\n\t\t * notice those.)\n\t\t */\n\t\treturn STATUS_ERROR;\n\t}\n\n\tif (pq_getbytes(((char *) &len) + 1, 3) == EOF)\n\t{\n\t\t/* Got a partial length word, so bleat about that */\n\t\tif (!ssl_done && !gss_done)\n\t\t\tereport(COMMERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n\t\t\t\t\t errmsg(\"incomplete startup packet\")));\n\t\treturn STATUS_ERROR;\n\t}\n\n\tlen = pg_ntoh32(len);\n\tlen -= 4;\n\n\tif (len < (int32) sizeof(ProtocolVersion) ||\n\t\tlen > MAX_STARTUP_PACKET_LENGTH)\n\t{\n\t\tereport(COMMERROR,\n\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n\t\t\t\t errmsg(\"invalid length of startup packet\")));\n\t\treturn STATUS_ERROR;\n\t}\n\n\t/*\n\t * Allocate space to hold the startup packet, plus one extra byte that's\n\t * initialized to be zero.  This ensures we will have null termination of\n\t * all strings inside the packet.\n\t */\n\tbuf = palloc(len + 1);\n\tbuf[len] = '\\0';\n\n\tif (pq_getbytes(buf, len) == EOF)\n\t{\n\t\tereport(COMMERROR,\n\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n\t\t\t\t errmsg(\"incomplete startup packet\")));\n\t\treturn STATUS_ERROR;\n\t}\n\tpq_endmsgread();\n\n\t/*\n\t * The first field is either a protocol version number or a special\n\t * request code.\n\t */\n\tport->proto = proto = pg_ntoh32(*((ProtocolVersion *) buf));\n\n\tif (proto == CANCEL_REQUEST_CODE)\n\t{\n\t\tprocessCancelRequest(port, buf);\n\t\t/* Not really an error, but we don't want to proceed further */\n\t\treturn STATUS_ERROR;\n\t}\n\n\tif (proto == NEGOTIATE_SSL_CODE && !ssl_done)\n\t{\n\t\tchar\t\tSSLok;\n\n#ifdef USE_SSL\n\t\t/* No SSL when disabled or on Unix sockets */\n\t\tif (!LoadedSSL || IS_AF_UNIX(port->laddr.addr.ss_family))\n\t\t\tSSLok = 'N';\n\t\telse\n\t\t\tSSLok = 'S';\t\t/* Support for SSL */\n#else\n\t\tSSLok = 'N';\t\t\t/* No support for SSL */\n#endif\n\nretry1:\n\t\tif (send(port->sock, &SSLok, 1, 0) != 1)\n\t\t{\n\t\t\tif (errno == EINTR)\n\t\t\t\tgoto retry1;\t/* if interrupted, just retry */\n\t\t\tereport(COMMERROR,\n\t\t\t\t\t(errcode_for_socket_access(),\n\t\t\t\t\t errmsg(\"failed to send SSL negotiation response: %m\")));\n\t\t\treturn STATUS_ERROR;\t/* close the connection */\n\t\t}\n\n#ifdef USE_SSL\n\t\tif (SSLok == 'S' && secure_open_server(port) == -1)\n\t\t\treturn STATUS_ERROR;\n#endif\n\n\t\t/*\n\t\t * regular startup packet, cancel, etc packet should follow, but not\n\t\t * another SSL negotiation request, and a GSS request should only\n\t\t * follow if SSL was rejected (client may negotiate in either order)\n\t\t */\n\t\treturn ProcessStartupPacket(port, true, SSLok == 'S');\n\t}\n\telse if (proto == NEGOTIATE_GSS_CODE && !gss_done)\n\t{\n\t\tchar\t\tGSSok = 'N';\n\n#ifdef ENABLE_GSS\n\t\t/* No GSSAPI encryption when on Unix socket */\n\t\tif (!IS_AF_UNIX(port->laddr.addr.ss_family))\n\t\t\tGSSok = 'G';\n#endif\n\n\t\twhile (send(port->sock, &GSSok, 1, 0) != 1)\n\t\t{\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tereport(COMMERROR,\n\t\t\t\t\t(errcode_for_socket_access(),\n\t\t\t\t\t errmsg(\"failed to send GSSAPI negotiation response: %m\")));\n\t\t\treturn STATUS_ERROR;\t/* close the connection */\n\t\t}\n\n#ifdef ENABLE_GSS\n\t\tif (GSSok == 'G' && secure_open_gssapi(port) == -1)\n\t\t\treturn STATUS_ERROR;\n#endif\n\n\t\t/*\n\t\t * regular startup packet, cancel, etc packet should follow, but not\n\t\t * another GSS negotiation request, and an SSL request should only\n\t\t * follow if GSS was rejected (client may negotiate in either order)\n\t\t */\n\t\treturn ProcessStartupPacket(port, GSSok == 'G', true);\n\t}\n\n\t/* Could add additional special packet types here */\n\n\t/*\n\t * Set FrontendProtocol now so that ereport() knows what format to send if\n\t * we fail during startup.\n\t */\n\tFrontendProtocol = proto;\n\n\t/* Check that the major protocol version is in range. */\n\tif (PG_PROTOCOL_MAJOR(proto) < PG_PROTOCOL_MAJOR(PG_PROTOCOL_EARLIEST) ||\n\t\tPG_PROTOCOL_MAJOR(proto) > PG_PROTOCOL_MAJOR(PG_PROTOCOL_LATEST))\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"unsupported frontend protocol %u.%u: server supports %u.0 to %u.%u\",\n\t\t\t\t\t\tPG_PROTOCOL_MAJOR(proto), PG_PROTOCOL_MINOR(proto),\n\t\t\t\t\t\tPG_PROTOCOL_MAJOR(PG_PROTOCOL_EARLIEST),\n\t\t\t\t\t\tPG_PROTOCOL_MAJOR(PG_PROTOCOL_LATEST),\n\t\t\t\t\t\tPG_PROTOCOL_MINOR(PG_PROTOCOL_LATEST))));\n\n\t/*\n\t * Now fetch parameters out of startup packet and save them into the Port\n\t * structure.  All data structures attached to the Port struct must be\n\t * allocated in TopMemoryContext so that they will remain available in a\n\t * running backend (even after PostmasterContext is destroyed).  We need\n\t * not worry about leaking this storage on failure, since we aren't in the\n\t * postmaster process anymore.\n\t */\n\toldcontext = MemoryContextSwitchTo(TopMemoryContext);\n\n\t/* Handle protocol version 3 startup packet */\n\t{\n\t\tint32\t\toffset = sizeof(ProtocolVersion);\n\t\tList\t   *unrecognized_protocol_options = NIL;\n\n\t\t/*\n\t\t * Scan packet body for name/option pairs.  We can assume any string\n\t\t * beginning within the packet body is null-terminated, thanks to\n\t\t * zeroing extra byte above.\n\t\t */\n\t\tport->guc_options = NIL;\n\n\t\twhile (offset < len)\n\t\t{\n\t\t\tchar\t   *nameptr = buf + offset;\n\t\t\tint32\t\tvaloffset;\n\t\t\tchar\t   *valptr;\n\n\t\t\tif (*nameptr == '\\0')\n\t\t\t\tbreak;\t\t\t/* found packet terminator */\n\t\t\tvaloffset = offset + strlen(nameptr) + 1;\n\t\t\tif (valoffset >= len)\n\t\t\t\tbreak;\t\t\t/* missing value, will complain below */\n\t\t\tvalptr = buf + valoffset;\n\n\t\t\tif (strcmp(nameptr, \"database\") == 0)\n\t\t\t\tport->database_name = pstrdup(valptr);\n\t\t\telse if (strcmp(nameptr, \"user\") == 0)\n\t\t\t\tport->user_name = pstrdup(valptr);\n\t\t\telse if (strcmp(nameptr, \"options\") == 0)\n\t\t\t\tport->cmdline_options = pstrdup(valptr);\n\t\t\telse if (strcmp(nameptr, \"replication\") == 0)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Due to backward compatibility concerns the replication\n\t\t\t\t * parameter is a hybrid beast which allows the value to be\n\t\t\t\t * either boolean or the string 'database'. The latter\n\t\t\t\t * connects to a specific database which is e.g. required for\n\t\t\t\t * logical decoding while.\n\t\t\t\t */\n\t\t\t\tif (strcmp(valptr, \"database\") == 0)\n\t\t\t\t{\n\t\t\t\t\tam_walsender = true;\n\t\t\t\t\tam_db_walsender = true;\n\t\t\t\t}\n\t\t\t\telse if (!parse_bool(valptr, &am_walsender))\n\t\t\t\t\tereport(FATAL,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t errmsg(\"invalid value for parameter \\\"%s\\\": \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\t\"replication\",\n\t\t\t\t\t\t\t\t\tvalptr),\n\t\t\t\t\t\t\t errhint(\"Valid values are: \\\"false\\\", 0, \\\"true\\\", 1, \\\"database\\\".\")));\n\t\t\t}\n\t\t\telse if (strncmp(nameptr, \"_pq_.\", 5) == 0)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Any option beginning with _pq_. is reserved for use as a\n\t\t\t\t * protocol-level option, but at present no such options are\n\t\t\t\t * defined.\n\t\t\t\t */\n\t\t\t\tunrecognized_protocol_options =\n\t\t\t\t\tlappend(unrecognized_protocol_options, pstrdup(nameptr));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Assume it's a generic GUC option */\n\t\t\t\tport->guc_options = lappend(port->guc_options,\n\t\t\t\t\t\t\t\t\t\t\tpstrdup(nameptr));\n\t\t\t\tport->guc_options = lappend(port->guc_options,\n\t\t\t\t\t\t\t\t\t\t\tpstrdup(valptr));\n\n\t\t\t\t/*\n\t\t\t\t * Copy application_name to port if we come across it.  This\n\t\t\t\t * is done so we can log the application_name in the\n\t\t\t\t * connection authorization message.  Note that the GUC would\n\t\t\t\t * be used but we haven't gone through GUC setup yet.\n\t\t\t\t */\n\t\t\t\tif (strcmp(nameptr, \"application_name\") == 0)\n\t\t\t\t{\n\t\t\t\t\tchar\t   *tmp_app_name = pstrdup(valptr);\n\n\t\t\t\t\tpg_clean_ascii(tmp_app_name);\n\n\t\t\t\t\tport->application_name = tmp_app_name;\n\t\t\t\t}\n\t\t\t}\n\t\t\toffset = valoffset + strlen(valptr) + 1;\n\t\t}\n\n\t\t/*\n\t\t * If we didn't find a packet terminator exactly at the end of the\n\t\t * given packet length, complain.\n\t\t */\n\t\tif (offset != len - 1)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n\t\t\t\t\t errmsg(\"invalid startup packet layout: expected terminator as last byte\")));\n\n\t\t/*\n\t\t * If the client requested a newer protocol version or if the client\n\t\t * requested any protocol options we didn't recognize, let them know\n\t\t * the newest minor protocol version we do support and the names of\n\t\t * any unrecognized options.\n\t\t */\n\t\tif (PG_PROTOCOL_MINOR(proto) > PG_PROTOCOL_MINOR(PG_PROTOCOL_LATEST) ||\n\t\t\tunrecognized_protocol_options != NIL)\n\t\t\tSendNegotiateProtocolVersion(unrecognized_protocol_options);\n\t}\n\n\t/* Check a user name was given. */\n\tif (port->user_name == NULL || port->user_name[0] == '\\0')\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION),\n\t\t\t\t errmsg(\"no PostgreSQL user name specified in startup packet\")));\n\n\t/* The database defaults to the user name. */\n\tif (port->database_name == NULL || port->database_name[0] == '\\0')\n\t\tport->database_name = pstrdup(port->user_name);\n\n\tif (Db_user_namespace)\n\t{\n\t\t/*\n\t\t * If user@, it is a global user, remove '@'. We only want to do this\n\t\t * if there is an '@' at the end and no earlier in the user string or\n\t\t * they may fake as a local user of another database attaching to this\n\t\t * database.\n\t\t */\n\t\tif (strchr(port->user_name, '@') ==\n\t\t\tport->user_name + strlen(port->user_name) - 1)\n\t\t\t*strchr(port->user_name, '@') = '\\0';\n\t\telse\n\t\t{\n\t\t\t/* Append '@' and dbname */\n\t\t\tport->user_name = psprintf(\"%s@%s\", port->user_name, port->database_name);\n\t\t}\n\t}\n\n\t/*\n\t * Truncate given database and user names to length of a Postgres name.\n\t * This avoids lookup failures when overlength names are given.\n\t */\n\tif (strlen(port->database_name) >= NAMEDATALEN)\n\t\tport->database_name[NAMEDATALEN - 1] = '\\0';\n\tif (strlen(port->user_name) >= NAMEDATALEN)\n\t\tport->user_name[NAMEDATALEN - 1] = '\\0';\n\n\tif (am_walsender)\n\t\tMyBackendType = B_WAL_SENDER;\n\telse\n\t\tMyBackendType = B_BACKEND;\n\n\t/*\n\t * Normal walsender backends, e.g. for streaming replication, are not\n\t * connected to a particular database. But walsenders used for logical\n\t * replication need to connect to a specific database. We allow streaming\n\t * replication commands to be issued even if connected to a database as it\n\t * can make sense to first make a basebackup and then stream changes\n\t * starting from that.\n\t */\n\tif (am_walsender && !am_db_walsender)\n\t\tport->database_name[0] = '\\0';\n\n\t/*\n\t * Done putting stuff in TopMemoryContext.\n\t */\n\tMemoryContextSwitchTo(oldcontext);\n\n\t/*\n\t * If we're going to reject the connection due to database state, say so\n\t * now instead of wasting cycles on an authentication exchange. (This also\n\t * allows a pg_ping utility to be written.)\n\t */\n\tswitch (port->canAcceptConnections)\n\t{\n\t\tcase CAC_STARTUP:\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_CANNOT_CONNECT_NOW),\n\t\t\t\t\t errmsg(\"the database system is starting up\")));\n\t\t\tbreak;\n\t\tcase CAC_NOTCONSISTENT:\n\t\t\tif (EnableHotStandby)\n\t\t\t\tereport(FATAL,\n\t\t\t\t\t\t(errcode(ERRCODE_CANNOT_CONNECT_NOW),\n\t\t\t\t\t\t errmsg(\"the database system is not yet accepting connections\"),\n\t\t\t\t\t\t errdetail(\"Consistent recovery state has not been yet reached.\")));\n\t\t\telse\n\t\t\t\tereport(FATAL,\n\t\t\t\t\t\t(errcode(ERRCODE_CANNOT_CONNECT_NOW),\n\t\t\t\t\t\t errmsg(\"the database system is not accepting connections\"),\n\t\t\t\t\t\t errdetail(\"Hot standby mode is disabled.\")));\n\t\t\tbreak;\n\t\tcase CAC_SHUTDOWN:\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_CANNOT_CONNECT_NOW),\n\t\t\t\t\t errmsg(\"the database system is shutting down\")));\n\t\t\tbreak;\n\t\tcase CAC_RECOVERY:\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_CANNOT_CONNECT_NOW),\n\t\t\t\t\t errmsg(\"the database system is in recovery mode\")));\n\t\t\tbreak;\n\t\tcase CAC_TOOMANY:\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_TOO_MANY_CONNECTIONS),\n\t\t\t\t\t errmsg(\"sorry, too many clients already\")));\n\t\t\tbreak;\n\t\tcase CAC_SUPERUSER:\n\t\t\t/* OK for now, will check in InitPostgres */\n\t\t\tbreak;\n\t\tcase CAC_OK:\n\t\t\tbreak;\n\t}\n\n\treturn STATUS_OK;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144715,
    "human": "Correct. With CWE-89",
    "reason": "It lacks of buffer checking after SSL/GSS handshakes. This code may be from postgre.",
    "RELATED_CWE": [
      "CWE-90",
      "CWE-91",
      "CWE-78"
    ]
  },
  {
    "CWE_ID": [
      "CWE-89"
    ],
    "code": "ProcessStartupPacket(Port *port, bool ssl_done, bool gss_done)\n{\n\tint32\t\tlen;\n\tchar\t   *buf;\n\tProtocolVersion proto;\n\tMemoryContext oldcontext;\n\n\tpq_startmsgread();\n\n\t/*\n\t * Grab the first byte of the length word separately, so that we can tell\n\t * whether we have no data at all or an incomplete packet.  (This might\n\t * sound inefficient, but it's not really, because of buffering in\n\t * pqcomm.c.)\n\t */\n\tif (pq_getbytes((char *) &len, 1) == EOF)\n\t{\n\t\t/*\n\t\t * If we get no data at all, don't clutter the log with a complaint;\n\t\t * such cases often occur for legitimate reasons.  An example is that\n\t\t * we might be here after responding to NEGOTIATE_SSL_CODE, and if the\n\t\t * client didn't like our response, it'll probably just drop the\n\t\t * connection.  Service-monitoring software also often just opens and\n\t\t * closes a connection without sending anything.  (So do port\n\t\t * scanners, which may be less benign, but it's not really our job to\n\t\t * notice those.)\n\t\t */\n\t\treturn STATUS_ERROR;\n\t}\n\n\tif (pq_getbytes(((char *) &len) + 1, 3) == EOF)\n\t{\n\t\t/* Got a partial length word, so bleat about that */\n\t\tif (!ssl_done && !gss_done)\n\t\t\tereport(COMMERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n\t\t\t\t\t errmsg(\"incomplete startup packet\")));\n\t\treturn STATUS_ERROR;\n\t}\n\n\tlen = pg_ntoh32(len);\n\tlen -= 4;\n\n\tif (len < (int32) sizeof(ProtocolVersion) ||\n\t\tlen > MAX_STARTUP_PACKET_LENGTH)\n\t{\n\t\tereport(COMMERROR,\n\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n\t\t\t\t errmsg(\"invalid length of startup packet\")));\n\t\treturn STATUS_ERROR;\n\t}\n\n\t/*\n\t * Allocate space to hold the startup packet, plus one extra byte that's\n\t * initialized to be zero.  This ensures we will have null termination of\n\t * all strings inside the packet.\n\t */\n\tbuf = palloc(len + 1);\n\tbuf[len] = '\\0';\n\n\tif (pq_getbytes(buf, len) == EOF)\n\t{\n\t\tereport(COMMERROR,\n\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n\t\t\t\t errmsg(\"incomplete startup packet\")));\n\t\treturn STATUS_ERROR;\n\t}\n\tpq_endmsgread();\n\n\t/*\n\t * The first field is either a protocol version number or a special\n\t * request code.\n\t */\n\tport->proto = proto = pg_ntoh32(*((ProtocolVersion *) buf));\n\n\tif (proto == CANCEL_REQUEST_CODE)\n\t{\n\t\tprocessCancelRequest(port, buf);\n\t\t/* Not really an error, but we don't want to proceed further */\n\t\treturn STATUS_ERROR;\n\t}\n\n\tif (proto == NEGOTIATE_SSL_CODE && !ssl_done)\n\t{\n\t\tchar\t\tSSLok;\n\n#ifdef USE_SSL\n\t\t/* No SSL when disabled or on Unix sockets */\n\t\tif (!LoadedSSL || IS_AF_UNIX(port->laddr.addr.ss_family))\n\t\t\tSSLok = 'N';\n\t\telse\n\t\t\tSSLok = 'S';\t\t/* Support for SSL */\n#else\n\t\tSSLok = 'N';\t\t\t/* No support for SSL */\n#endif\n\nretry1:\n\t\tif (send(port->sock, &SSLok, 1, 0) != 1)\n\t\t{\n\t\t\tif (errno == EINTR)\n\t\t\t\tgoto retry1;\t/* if interrupted, just retry */\n\t\t\tereport(COMMERROR,\n\t\t\t\t\t(errcode_for_socket_access(),\n\t\t\t\t\t errmsg(\"failed to send SSL negotiation response: %m\")));\n\t\t\treturn STATUS_ERROR;\t/* close the connection */\n\t\t}\n\n#ifdef USE_SSL\n\t\tif (SSLok == 'S' && secure_open_server(port) == -1)\n\t\t\treturn STATUS_ERROR;\n#endif\n\n\t\t/*\n\t\t * At this point we should have no data already buffered.  If we do,\n\t\t * it was received before we performed the SSL handshake, so it wasn't\n\t\t * encrypted and indeed may have been injected by a man-in-the-middle.\n\t\t * We report this case to the client.\n\t\t */\n\t\tif (pq_buffer_has_data())\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n\t\t\t\t\t errmsg(\"received unencrypted data after SSL request\"),\n\t\t\t\t\t errdetail(\"This could be either a client-software bug or evidence of an attempted man-in-the-middle attack.\")));\n\n\t\t/*\n\t\t * regular startup packet, cancel, etc packet should follow, but not\n\t\t * another SSL negotiation request, and a GSS request should only\n\t\t * follow if SSL was rejected (client may negotiate in either order)\n\t\t */\n\t\treturn ProcessStartupPacket(port, true, SSLok == 'S');\n\t}\n\telse if (proto == NEGOTIATE_GSS_CODE && !gss_done)\n\t{\n\t\tchar\t\tGSSok = 'N';\n\n#ifdef ENABLE_GSS\n\t\t/* No GSSAPI encryption when on Unix socket */\n\t\tif (!IS_AF_UNIX(port->laddr.addr.ss_family))\n\t\t\tGSSok = 'G';\n#endif\n\n\t\twhile (send(port->sock, &GSSok, 1, 0) != 1)\n\t\t{\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tereport(COMMERROR,\n\t\t\t\t\t(errcode_for_socket_access(),\n\t\t\t\t\t errmsg(\"failed to send GSSAPI negotiation response: %m\")));\n\t\t\treturn STATUS_ERROR;\t/* close the connection */\n\t\t}\n\n#ifdef ENABLE_GSS\n\t\tif (GSSok == 'G' && secure_open_gssapi(port) == -1)\n\t\t\treturn STATUS_ERROR;\n#endif\n\n\t\t/*\n\t\t * At this point we should have no data already buffered.  If we do,\n\t\t * it was received before we performed the GSS handshake, so it wasn't\n\t\t * encrypted and indeed may have been injected by a man-in-the-middle.\n\t\t * We report this case to the client.\n\t\t */\n\t\tif (pq_buffer_has_data())\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n\t\t\t\t\t errmsg(\"received unencrypted data after GSSAPI encryption request\"),\n\t\t\t\t\t errdetail(\"This could be either a client-software bug or evidence of an attempted man-in-the-middle attack.\")));\n\n\t\t/*\n\t\t * regular startup packet, cancel, etc packet should follow, but not\n\t\t * another GSS negotiation request, and an SSL request should only\n\t\t * follow if GSS was rejected (client may negotiate in either order)\n\t\t */\n\t\treturn ProcessStartupPacket(port, GSSok == 'G', true);\n\t}\n\n\t/* Could add additional special packet types here */\n\n\t/*\n\t * Set FrontendProtocol now so that ereport() knows what format to send if\n\t * we fail during startup.\n\t */\n\tFrontendProtocol = proto;\n\n\t/* Check that the major protocol version is in range. */\n\tif (PG_PROTOCOL_MAJOR(proto) < PG_PROTOCOL_MAJOR(PG_PROTOCOL_EARLIEST) ||\n\t\tPG_PROTOCOL_MAJOR(proto) > PG_PROTOCOL_MAJOR(PG_PROTOCOL_LATEST))\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"unsupported frontend protocol %u.%u: server supports %u.0 to %u.%u\",\n\t\t\t\t\t\tPG_PROTOCOL_MAJOR(proto), PG_PROTOCOL_MINOR(proto),\n\t\t\t\t\t\tPG_PROTOCOL_MAJOR(PG_PROTOCOL_EARLIEST),\n\t\t\t\t\t\tPG_PROTOCOL_MAJOR(PG_PROTOCOL_LATEST),\n\t\t\t\t\t\tPG_PROTOCOL_MINOR(PG_PROTOCOL_LATEST))));\n\n\t/*\n\t * Now fetch parameters out of startup packet and save them into the Port\n\t * structure.  All data structures attached to the Port struct must be\n\t * allocated in TopMemoryContext so that they will remain available in a\n\t * running backend (even after PostmasterContext is destroyed).  We need\n\t * not worry about leaking this storage on failure, since we aren't in the\n\t * postmaster process anymore.\n\t */\n\toldcontext = MemoryContextSwitchTo(TopMemoryContext);\n\n\t/* Handle protocol version 3 startup packet */\n\t{\n\t\tint32\t\toffset = sizeof(ProtocolVersion);\n\t\tList\t   *unrecognized_protocol_options = NIL;\n\n\t\t/*\n\t\t * Scan packet body for name/option pairs.  We can assume any string\n\t\t * beginning within the packet body is null-terminated, thanks to\n\t\t * zeroing extra byte above.\n\t\t */\n\t\tport->guc_options = NIL;\n\n\t\twhile (offset < len)\n\t\t{\n\t\t\tchar\t   *nameptr = buf + offset;\n\t\t\tint32\t\tvaloffset;\n\t\t\tchar\t   *valptr;\n\n\t\t\tif (*nameptr == '\\0')\n\t\t\t\tbreak;\t\t\t/* found packet terminator */\n\t\t\tvaloffset = offset + strlen(nameptr) + 1;\n\t\t\tif (valoffset >= len)\n\t\t\t\tbreak;\t\t\t/* missing value, will complain below */\n\t\t\tvalptr = buf + valoffset;\n\n\t\t\tif (strcmp(nameptr, \"database\") == 0)\n\t\t\t\tport->database_name = pstrdup(valptr);\n\t\t\telse if (strcmp(nameptr, \"user\") == 0)\n\t\t\t\tport->user_name = pstrdup(valptr);\n\t\t\telse if (strcmp(nameptr, \"options\") == 0)\n\t\t\t\tport->cmdline_options = pstrdup(valptr);\n\t\t\telse if (strcmp(nameptr, \"replication\") == 0)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Due to backward compatibility concerns the replication\n\t\t\t\t * parameter is a hybrid beast which allows the value to be\n\t\t\t\t * either boolean or the string 'database'. The latter\n\t\t\t\t * connects to a specific database which is e.g. required for\n\t\t\t\t * logical decoding while.\n\t\t\t\t */\n\t\t\t\tif (strcmp(valptr, \"database\") == 0)\n\t\t\t\t{\n\t\t\t\t\tam_walsender = true;\n\t\t\t\t\tam_db_walsender = true;\n\t\t\t\t}\n\t\t\t\telse if (!parse_bool(valptr, &am_walsender))\n\t\t\t\t\tereport(FATAL,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t errmsg(\"invalid value for parameter \\\"%s\\\": \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\t\"replication\",\n\t\t\t\t\t\t\t\t\tvalptr),\n\t\t\t\t\t\t\t errhint(\"Valid values are: \\\"false\\\", 0, \\\"true\\\", 1, \\\"database\\\".\")));\n\t\t\t}\n\t\t\telse if (strncmp(nameptr, \"_pq_.\", 5) == 0)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Any option beginning with _pq_. is reserved for use as a\n\t\t\t\t * protocol-level option, but at present no such options are\n\t\t\t\t * defined.\n\t\t\t\t */\n\t\t\t\tunrecognized_protocol_options =\n\t\t\t\t\tlappend(unrecognized_protocol_options, pstrdup(nameptr));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Assume it's a generic GUC option */\n\t\t\t\tport->guc_options = lappend(port->guc_options,\n\t\t\t\t\t\t\t\t\t\t\tpstrdup(nameptr));\n\t\t\t\tport->guc_options = lappend(port->guc_options,\n\t\t\t\t\t\t\t\t\t\t\tpstrdup(valptr));\n\n\t\t\t\t/*\n\t\t\t\t * Copy application_name to port if we come across it.  This\n\t\t\t\t * is done so we can log the application_name in the\n\t\t\t\t * connection authorization message.  Note that the GUC would\n\t\t\t\t * be used but we haven't gone through GUC setup yet.\n\t\t\t\t */\n\t\t\t\tif (strcmp(nameptr, \"application_name\") == 0)\n\t\t\t\t{\n\t\t\t\t\tchar\t   *tmp_app_name = pstrdup(valptr);\n\n\t\t\t\t\tpg_clean_ascii(tmp_app_name);\n\n\t\t\t\t\tport->application_name = tmp_app_name;\n\t\t\t\t}\n\t\t\t}\n\t\t\toffset = valoffset + strlen(valptr) + 1;\n\t\t}\n\n\t\t/*\n\t\t * If we didn't find a packet terminator exactly at the end of the\n\t\t * given packet length, complain.\n\t\t */\n\t\tif (offset != len - 1)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n\t\t\t\t\t errmsg(\"invalid startup packet layout: expected terminator as last byte\")));\n\n\t\t/*\n\t\t * If the client requested a newer protocol version or if the client\n\t\t * requested any protocol options we didn't recognize, let them know\n\t\t * the newest minor protocol version we do support and the names of\n\t\t * any unrecognized options.\n\t\t */\n\t\tif (PG_PROTOCOL_MINOR(proto) > PG_PROTOCOL_MINOR(PG_PROTOCOL_LATEST) ||\n\t\t\tunrecognized_protocol_options != NIL)\n\t\t\tSendNegotiateProtocolVersion(unrecognized_protocol_options);\n\t}\n\n\t/* Check a user name was given. */\n\tif (port->user_name == NULL || port->user_name[0] == '\\0')\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION),\n\t\t\t\t errmsg(\"no PostgreSQL user name specified in startup packet\")));\n\n\t/* The database defaults to the user name. */\n\tif (port->database_name == NULL || port->database_name[0] == '\\0')\n\t\tport->database_name = pstrdup(port->user_name);\n\n\tif (Db_user_namespace)\n\t{\n\t\t/*\n\t\t * If user@, it is a global user, remove '@'. We only want to do this\n\t\t * if there is an '@' at the end and no earlier in the user string or\n\t\t * they may fake as a local user of another database attaching to this\n\t\t * database.\n\t\t */\n\t\tif (strchr(port->user_name, '@') ==\n\t\t\tport->user_name + strlen(port->user_name) - 1)\n\t\t\t*strchr(port->user_name, '@') = '\\0';\n\t\telse\n\t\t{\n\t\t\t/* Append '@' and dbname */\n\t\t\tport->user_name = psprintf(\"%s@%s\", port->user_name, port->database_name);\n\t\t}\n\t}\n\n\t/*\n\t * Truncate given database and user names to length of a Postgres name.\n\t * This avoids lookup failures when overlength names are given.\n\t */\n\tif (strlen(port->database_name) >= NAMEDATALEN)\n\t\tport->database_name[NAMEDATALEN - 1] = '\\0';\n\tif (strlen(port->user_name) >= NAMEDATALEN)\n\t\tport->user_name[NAMEDATALEN - 1] = '\\0';\n\n\tif (am_walsender)\n\t\tMyBackendType = B_WAL_SENDER;\n\telse\n\t\tMyBackendType = B_BACKEND;\n\n\t/*\n\t * Normal walsender backends, e.g. for streaming replication, are not\n\t * connected to a particular database. But walsenders used for logical\n\t * replication need to connect to a specific database. We allow streaming\n\t * replication commands to be issued even if connected to a database as it\n\t * can make sense to first make a basebackup and then stream changes\n\t * starting from that.\n\t */\n\tif (am_walsender && !am_db_walsender)\n\t\tport->database_name[0] = '\\0';\n\n\t/*\n\t * Done putting stuff in TopMemoryContext.\n\t */\n\tMemoryContextSwitchTo(oldcontext);\n\n\t/*\n\t * If we're going to reject the connection due to database state, say so\n\t * now instead of wasting cycles on an authentication exchange. (This also\n\t * allows a pg_ping utility to be written.)\n\t */\n\tswitch (port->canAcceptConnections)\n\t{\n\t\tcase CAC_STARTUP:\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_CANNOT_CONNECT_NOW),\n\t\t\t\t\t errmsg(\"the database system is starting up\")));\n\t\t\tbreak;\n\t\tcase CAC_NOTCONSISTENT:\n\t\t\tif (EnableHotStandby)\n\t\t\t\tereport(FATAL,\n\t\t\t\t\t\t(errcode(ERRCODE_CANNOT_CONNECT_NOW),\n\t\t\t\t\t\t errmsg(\"the database system is not yet accepting connections\"),\n\t\t\t\t\t\t errdetail(\"Consistent recovery state has not been yet reached.\")));\n\t\t\telse\n\t\t\t\tereport(FATAL,\n\t\t\t\t\t\t(errcode(ERRCODE_CANNOT_CONNECT_NOW),\n\t\t\t\t\t\t errmsg(\"the database system is not accepting connections\"),\n\t\t\t\t\t\t errdetail(\"Hot standby mode is disabled.\")));\n\t\t\tbreak;\n\t\tcase CAC_SHUTDOWN:\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_CANNOT_CONNECT_NOW),\n\t\t\t\t\t errmsg(\"the database system is shutting down\")));\n\t\t\tbreak;\n\t\tcase CAC_RECOVERY:\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_CANNOT_CONNECT_NOW),\n\t\t\t\t\t errmsg(\"the database system is in recovery mode\")));\n\t\t\tbreak;\n\t\tcase CAC_TOOMANY:\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_TOO_MANY_CONNECTIONS),\n\t\t\t\t\t errmsg(\"sorry, too many clients already\")));\n\t\t\tbreak;\n\t\tcase CAC_SUPERUSER:\n\t\t\t/* OK for now, will check in InitPostgres */\n\t\t\tbreak;\n\t\tcase CAC_OK:\n\t\t\tbreak;\n\t}\n\n\treturn STATUS_OK;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144716,
    "human": "Correct. Without CWE-89",
    "RELATED_CWE": [
      "CWE-90",
      "CWE-91",
      "CWE-78"
    ]
  },
  {
    "CWE_ID": [
      "CWE-89"
    ],
    "code": "bool Item_singlerow_subselect::fix_length_and_dec()\n{\n  if ((max_columns= engine->cols()) == 1)\n  {\n    if (engine->fix_length_and_dec(row= &value))\n      return TRUE;\n  }\n  else\n  {\n    if (!(row= (Item_cache**) current_thd->alloc(sizeof(Item_cache*) *\n                                                 max_columns)) ||\n        engine->fix_length_and_dec(row))\n      return TRUE;\n    value= *row;\n  }\n  unsigned_flag= value->unsigned_flag;\n  /*\n    If there are not tables in subquery then ability to have NULL value\n    depends on SELECT list (if single row subquery have tables then it\n    always can be NULL if there are not records fetched).\n  */\n  if (engine->no_tables())\n    maybe_null= engine->may_be_null();\n  else\n  {\n    for (uint i= 0; i < max_columns; i++)\n      row[i]->maybe_null= TRUE;\n  }\n  return FALSE;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147820,
    "human": "Correct. With CWE-89",
    "reason": "It may not handle edge cases involving UNION subqueries. This code may be from MySQL or MariaDB.",
    "RELATED_CWE": [
      "CWE-90",
      "CWE-91",
      "CWE-78"
    ]
  },
  {
    "CWE_ID": [
      "CWE-89"
    ],
    "code": "bool Item_singlerow_subselect::fix_length_and_dec()\n{\n  if ((max_columns= engine->cols()) == 1)\n  {\n    if (engine->fix_length_and_dec(row= &value))\n      return TRUE;\n  }\n  else\n  {\n    if (!(row= (Item_cache**) current_thd->alloc(sizeof(Item_cache*) *\n                                                 max_columns)) ||\n        engine->fix_length_and_dec(row))\n      return TRUE;\n    value= *row;\n  }\n  unsigned_flag= value->unsigned_flag;\n  /*\n    If the subquery has no tables (1) and is not a UNION (2), like:\n\n      (SELECT subq_value)\n\n    then its NULLability is the same as subq_value's NULLability.\n\n    (1): A subquery that uses a table will return NULL when the table is empty.\n    (2): A UNION subquery will return NULL if it produces a \"Subquery returns\n         more than one row\" error.\n  */\n  if (engine->no_tables() &&\n      engine->engine_type() != subselect_engine::UNION_ENGINE)\n    maybe_null= engine->may_be_null();\n  else\n  {\n    for (uint i= 0; i < max_columns; i++)\n      row[i]->maybe_null= TRUE;\n  }\n  return FALSE;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147821,
    "human": "Correct. Without CWE-89",
    "RELATED_CWE": [
      "CWE-90",
      "CWE-91",
      "CWE-78"
    ]
  }
]