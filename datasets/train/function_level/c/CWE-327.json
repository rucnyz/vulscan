[
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\n\n\nstatic void f_xjirekbg()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n    else\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\nvoid f_waflddfi()\n{\n    f_xjirekbg();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_waflddfi();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401140,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_DES_12.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\nvoid f_nxwjmvpg()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_DES, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n    else\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_nxwjmvpg();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401141,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_DES_12.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\nvoid f_kcxytzzx()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_3DES, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n    else\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_kcxytzzx();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401143,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_3DES_12.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\nvoid f_nvqwbjfv()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_RC5, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n    else\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_nvqwbjfv();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401145,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_RC5_12.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\n\n\n\nstatic void f_gvhupumj()\n{\n    if(staticReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\nstatic void f_pdckvajf()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\nvoid f_cwexhrwq()\n{\n    f_gvhupumj();\n    f_pdckvajf();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_cwexhrwq();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401146,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_DES_08.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\n\nvoid f_ulhtvant()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_DES, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ulhtvant();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401147,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_DES_08.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\n\nvoid f_rmcvssqm()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_3DES, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_rmcvssqm();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401149,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_3DES_08.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\n\n\nstatic void f_zknulles()\n{\n    switch(5)\n    {\n    case 6:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        FILE *pFile;\n        HCRYPTPROV hCryptProv;\n        HCRYPTKEY hKey;\n        HCRYPTHASH hHash;\n        char password[100];\n        size_t passwordLen;\n        char toBeDecrypted[100];\n        DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n        \n        printLine(\"Enter the password: \");\n        if (fgets(password, 100, stdin) == NULL)\n        {\n            printLine(\"fgets() failed\");\n            \n            password[0] = '\\0';\n        }\n        \n        passwordLen = strlen(password);\n        if (passwordLen > 0)\n        {\n            password[passwordLen-1] = '\\0';\n        }\n        \n        pFile = fopen(\"encrypted.txt\", \"rb\");\n        if (pFile == NULL)\n        {\n            exit(1);\n        }\n        if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n        {\n            fclose(pFile);\n            exit(1);\n        }\n        toBeDecrypted[99] = '\\0';\n        \n        if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n        {\n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n            {\n                printLine(\"Error in acquiring cryptographic context\");\n                exit(1);\n            }\n        }\n        \n        if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n        {\n            printLine(\"Error in creating hash\");\n            exit(1);\n        }\n        \n        if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n        {\n            printLine(\"Error in hashing password\");\n            exit(1);\n        }\n        \n        if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n        {\n            printLine(\"Error in CryptDeriveKey\");\n            exit(1);\n        }\n        \n        if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n        {\n            printLine(\"Error in decryption\");\n            exit(1);\n        }\n        \n        toBeDecrypted[toBeDecryptedLen] = '\\0';\n        printLine(toBeDecrypted);\n        \n        if (hKey)\n        {\n            CryptDestroyKey(hKey);\n        }\n        if (hHash)\n        {\n            CryptDestroyHash(hHash);\n        }\n        if (hCryptProv)\n        {\n            CryptReleaseContext(hCryptProv, 0);\n        }\n        if (pFile)\n        {\n            fclose(pFile);\n        }\n    }\n    break;\n    }\n}\n\n\nstatic void f_xacyxdvv()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        FILE *pFile;\n        HCRYPTPROV hCryptProv;\n        HCRYPTKEY hKey;\n        HCRYPTHASH hHash;\n        char password[100];\n        size_t passwordLen;\n        char toBeDecrypted[100];\n        DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n        \n        printLine(\"Enter the password: \");\n        if (fgets(password, 100, stdin) == NULL)\n        {\n            printLine(\"fgets() failed\");\n            \n            password[0] = '\\0';\n        }\n        \n        passwordLen = strlen(password);\n        if (passwordLen > 0)\n        {\n            password[passwordLen-1] = '\\0';\n        }\n        \n        pFile = fopen(\"encrypted.txt\", \"rb\");\n        if (pFile == NULL)\n        {\n            exit(1);\n        }\n        if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n        {\n            fclose(pFile);\n            exit(1);\n        }\n        toBeDecrypted[99] = '\\0';\n        \n        if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n        {\n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n            {\n                printLine(\"Error in acquiring cryptographic context\");\n                exit(1);\n            }\n        }\n        \n        if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n        {\n            printLine(\"Error in creating hash\");\n            exit(1);\n        }\n        \n        if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n        {\n            printLine(\"Error in hashing password\");\n            exit(1);\n        }\n        \n        if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n        {\n            printLine(\"Error in CryptDeriveKey\");\n            exit(1);\n        }\n        \n        if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n        {\n            printLine(\"Error in decryption\");\n            exit(1);\n        }\n        \n        toBeDecrypted[toBeDecryptedLen] = '\\0';\n        printLine(toBeDecrypted);\n        \n        if (hKey)\n        {\n            CryptDestroyKey(hKey);\n        }\n        if (hHash)\n        {\n            CryptDestroyHash(hHash);\n        }\n        if (hCryptProv)\n        {\n            CryptReleaseContext(hCryptProv, 0);\n        }\n        if (pFile)\n        {\n            fclose(pFile);\n        }\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\nvoid f_hnehsfrm()\n{\n    f_zknulles();\n    f_xacyxdvv();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_hnehsfrm();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401150,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_DES_15.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\nvoid f_yfaacshp()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        FILE *pFile;\n        HCRYPTPROV hCryptProv;\n        HCRYPTKEY hKey;\n        HCRYPTHASH hHash;\n        char password[100];\n        size_t passwordLen;\n        char toBeDecrypted[100];\n        DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n        \n        printLine(\"Enter the password: \");\n        if (fgets(password, 100, stdin) == NULL)\n        {\n            printLine(\"fgets() failed\");\n            \n            password[0] = '\\0';\n        }\n        \n        passwordLen = strlen(password);\n        if (passwordLen > 0)\n        {\n            password[passwordLen-1] = '\\0';\n        }\n        \n        pFile = fopen(\"encrypted.txt\", \"rb\");\n        if (pFile == NULL)\n        {\n            exit(1);\n        }\n        if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n        {\n            fclose(pFile);\n            exit(1);\n        }\n        toBeDecrypted[99] = '\\0';\n        \n        if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n        {\n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n            {\n                printLine(\"Error in acquiring cryptographic context\");\n                exit(1);\n            }\n        }\n        \n        if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n        {\n            printLine(\"Error in creating hash\");\n            exit(1);\n        }\n        \n        if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n        {\n            printLine(\"Error in hashing password\");\n            exit(1);\n        }\n        \n        if(!CryptDeriveKey(hCryptProv, CALG_DES, hHash, 0, &hKey))\n        {\n            printLine(\"Error in CryptDeriveKey\");\n            exit(1);\n        }\n        \n        if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n        {\n            printLine(\"Error in decryption\");\n            exit(1);\n        }\n        \n        toBeDecrypted[toBeDecryptedLen] = '\\0';\n        printLine(toBeDecrypted);\n        \n        if (hKey)\n        {\n            CryptDestroyKey(hKey);\n        }\n        if (hHash)\n        {\n            CryptDestroyHash(hHash);\n        }\n        if (hCryptProv)\n        {\n            CryptReleaseContext(hCryptProv, 0);\n        }\n        if (pFile)\n        {\n            fclose(pFile);\n        }\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_yfaacshp();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401151,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_DES_15.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\nvoid f_ckmbthmz()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        FILE *pFile;\n        HCRYPTPROV hCryptProv;\n        HCRYPTKEY hKey;\n        HCRYPTHASH hHash;\n        char password[100];\n        size_t passwordLen;\n        char toBeDecrypted[100];\n        DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n        \n        printLine(\"Enter the password: \");\n        if (fgets(password, 100, stdin) == NULL)\n        {\n            printLine(\"fgets() failed\");\n            \n            password[0] = '\\0';\n        }\n        \n        passwordLen = strlen(password);\n        if (passwordLen > 0)\n        {\n            password[passwordLen-1] = '\\0';\n        }\n        \n        pFile = fopen(\"encrypted.txt\", \"rb\");\n        if (pFile == NULL)\n        {\n            exit(1);\n        }\n        if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n        {\n            fclose(pFile);\n            exit(1);\n        }\n        toBeDecrypted[99] = '\\0';\n        \n        if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n        {\n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n            {\n                printLine(\"Error in acquiring cryptographic context\");\n                exit(1);\n            }\n        }\n        \n        if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n        {\n            printLine(\"Error in creating hash\");\n            exit(1);\n        }\n        \n        if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n        {\n            printLine(\"Error in hashing password\");\n            exit(1);\n        }\n        \n        if(!CryptDeriveKey(hCryptProv, CALG_3DES, hHash, 0, &hKey))\n        {\n            printLine(\"Error in CryptDeriveKey\");\n            exit(1);\n        }\n        \n        if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n        {\n            printLine(\"Error in decryption\");\n            exit(1);\n        }\n        \n        toBeDecrypted[toBeDecryptedLen] = '\\0';\n        printLine(toBeDecrypted);\n        \n        if (hKey)\n        {\n            CryptDestroyKey(hKey);\n        }\n        if (hHash)\n        {\n            CryptDestroyHash(hHash);\n        }\n        if (hCryptProv)\n        {\n            CryptReleaseContext(hCryptProv, 0);\n        }\n        if (pFile)\n        {\n            fclose(pFile);\n        }\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ckmbthmz();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401153,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_3DES_15.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\nvoid f_gojsrfke()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        FILE *pFile;\n        HCRYPTPROV hCryptProv;\n        HCRYPTKEY hKey;\n        HCRYPTHASH hHash;\n        char password[100];\n        size_t passwordLen;\n        char toBeDecrypted[100];\n        DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n        \n        printLine(\"Enter the password: \");\n        if (fgets(password, 100, stdin) == NULL)\n        {\n            printLine(\"fgets() failed\");\n            \n            password[0] = '\\0';\n        }\n        \n        passwordLen = strlen(password);\n        if (passwordLen > 0)\n        {\n            password[passwordLen-1] = '\\0';\n        }\n        \n        pFile = fopen(\"encrypted.txt\", \"rb\");\n        if (pFile == NULL)\n        {\n            exit(1);\n        }\n        if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n        {\n            fclose(pFile);\n            exit(1);\n        }\n        toBeDecrypted[99] = '\\0';\n        \n        if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n        {\n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n            {\n                printLine(\"Error in acquiring cryptographic context\");\n                exit(1);\n            }\n        }\n        \n        if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n        {\n            printLine(\"Error in creating hash\");\n            exit(1);\n        }\n        \n        if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n        {\n            printLine(\"Error in hashing password\");\n            exit(1);\n        }\n        \n        if(!CryptDeriveKey(hCryptProv, CALG_RC5, hHash, 0, &hKey))\n        {\n            printLine(\"Error in CryptDeriveKey\");\n            exit(1);\n        }\n        \n        if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n        {\n            printLine(\"Error in decryption\");\n            exit(1);\n        }\n        \n        toBeDecrypted[toBeDecryptedLen] = '\\0';\n        printLine(toBeDecrypted);\n        \n        if (hKey)\n        {\n            CryptDestroyKey(hKey);\n        }\n        if (hHash)\n        {\n            CryptDestroyHash(hHash);\n        }\n        if (hCryptProv)\n        {\n            CryptReleaseContext(hCryptProv, 0);\n        }\n        if (pFile)\n        {\n            fclose(pFile);\n        }\n    }\n    break;\n    default:\n        \n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_gojsrfke();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401155,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_RC5_15.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\n\nvoid f_xsctdvkp()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_RC5, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_xsctdvkp();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401157,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_RC5_08.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\n\n\n\nstatic void f_zglhvydi()\n{\n    if(staticFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\nstatic void f_aaixlmlf()\n{\n    if(staticTrue)\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\nvoid f_uvnhdmlh()\n{\n    f_zglhvydi();\n    f_aaixlmlf();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_uvnhdmlh();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401158,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_3DES_05.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\n\nvoid f_vibaoane()\n{\n    if(staticTrue)\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_3DES, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_vibaoane();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401159,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_3DES_05.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\n\n\n\nstatic void f_iuyxcdlb()\n{\n    if(STATIC_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\nstatic void f_wisjjoyb()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\nvoid f_kqoyhlbo()\n{\n    f_iuyxcdlb();\n    f_wisjjoyb();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_kqoyhlbo();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401160,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_3DES_04.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\n\nvoid f_nffnsunh()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_3DES, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_nffnsunh();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401161,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_3DES_04.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\n\nvoid f_znokjgiw()\n{\n    if(staticTrue)\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_DES, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_znokjgiw();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401163,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_DES_05.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\n\nvoid f_qafuwoac()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_DES, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_qafuwoac();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401165,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_DES_04.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\nstatic int staticTrue = 1; \nstatic int staticFalse = 0; \n\n\nvoid f_ycfcsrnl()\n{\n    if(staticTrue)\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_RC5, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ycfcsrnl();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401167,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_RC5_05.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\nstatic const int STATIC_CONST_TRUE = 1; \nstatic const int STATIC_CONST_FALSE = 0; \n\n\nvoid f_xznelddq()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_RC5, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_xznelddq();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401169,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_RC5_04.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\nstatic const int STATIC_CONST_FIVE = 5;\n\n\n\n\nstatic void f_wvgztghc()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\nstatic void f_anzobqkz()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\nvoid f_libxieaj()\n{\n    f_wvgztghc();\n    f_anzobqkz();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_libxieaj();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401170,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_RC5_06.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\nstatic const int STATIC_CONST_FIVE = 5;\n\n\nvoid f_pvijdsyw()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_RC5, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_pvijdsyw();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401171,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_RC5_06.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\nstatic const int STATIC_CONST_FIVE = 5;\n\n\nvoid f_lpbwtzhj()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_3DES, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_lpbwtzhj();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401173,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_3DES_06.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\nstatic int staticFive = 5;\n\n\n\n\nstatic void f_lazflznj()\n{\n    if(staticFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\nstatic void f_ajbkldme()\n{\n    if(staticFive==5)\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\nvoid f_rzikjikt()\n{\n    f_lazflznj();\n    f_ajbkldme();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_rzikjikt();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401174,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_DES_07.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\nstatic int staticFive = 5;\n\n\nvoid f_dtfhlfef()\n{\n    if(staticFive==5)\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_DES, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_dtfhlfef();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401175,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_DES_07.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\nstatic const int STATIC_CONST_FIVE = 5;\n\n\nvoid f_ahgnzgzl()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_DES, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ahgnzgzl();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401177,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_DES_06.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\nstatic int staticFive = 5;\n\n\nvoid f_nrnjakgf()\n{\n    if(staticFive==5)\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_3DES, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_nrnjakgf();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401179,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_3DES_07.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\nstatic int staticFive = 5;\n\n\nvoid f_bxfiyjmf()\n{\n    if(staticFive==5)\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_RC5, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_bxfiyjmf();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401181,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_RC5_07.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\n\n\nstatic void f_nrwvlmoq()\n{\n    if(globalFalse)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\nstatic void f_irdeqybb()\n{\n    if(globalTrue)\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\nvoid f_kfvuvaal()\n{\n    f_nrwvlmoq();\n    f_irdeqybb();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_kfvuvaal();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401182,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_RC5_10.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\nvoid f_tnxjosoa()\n{\n    if(globalTrue)\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_RC5, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_tnxjosoa();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401183,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_RC5_10.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\n\n\nstatic void f_xeiornmu()\n{\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\nstatic void f_oxzpgkxl()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\nvoid f_idaiuyrq()\n{\n    f_xeiornmu();\n    f_oxzpgkxl();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_idaiuyrq();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401184,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_DES_13.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\nvoid f_uzslbpgv()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_DES, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_uzslbpgv();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401185,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_DES_13.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\n\n\nstatic void f_tsmxbujl()\n{\n    if(globalFive!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\nstatic void f_bnfjnwkn()\n{\n    if(globalFive==5)\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\nvoid f_juxhitgj()\n{\n    f_tsmxbujl();\n    f_bnfjnwkn();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_juxhitgj();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401186,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_RC5_14.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\nvoid f_qeywzlwt()\n{\n    if(globalFive==5)\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_RC5, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_qeywzlwt();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401187,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_RC5_14.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\n\n\nstatic void f_iupudsos()\n{\n    if(0)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\nstatic void f_xvzgeurh()\n{\n    if(1)\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\nvoid f_xbzkkmdf()\n{\n    f_iupudsos();\n    f_xvzgeurh();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_xbzkkmdf();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401188,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_DES_02.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\nvoid f_raxzjuyh()\n{\n    if(1)\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_DES, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_raxzjuyh();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401189,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_DES_02.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\nvoid f_yqqrmpyn()\n{\n    if(globalFive==5)\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_DES, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_yqqrmpyn();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401191,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_DES_14.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\nvoid f_qnsalbpt()\n{\n    if(globalFive==5)\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_3DES, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_qnsalbpt();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401193,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_3DES_14.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\nvoid f_aatnmyjv()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_3DES, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_aatnmyjv();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401195,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_3DES_13.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\n\n\nstatic void f_zihsgfgc()\n{\n    if(globalReturnsFalse())\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\nstatic void f_nrzdcnjp()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\nvoid f_hwsyppds()\n{\n    f_zihsgfgc();\n    f_nrzdcnjp();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_hwsyppds();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401196,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_RC5_11.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\nvoid f_qxggfsek()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_RC5, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_qxggfsek();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401197,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_RC5_11.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\nvoid f_iwkfioqm()\n{\n    if(1)\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_RC5, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_iwkfioqm();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401199,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_RC5_02.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\n\n\nstatic void f_gksbbjru()\n{\n    if(GLOBAL_CONST_FALSE)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\nstatic void f_amccmqhu()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\nvoid f_rpjtbjcc()\n{\n    f_gksbbjru();\n    f_amccmqhu();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_rpjtbjcc();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401200,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_3DES_09.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\nvoid f_snlfikyf()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_3DES, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_snlfikyf();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401201,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_3DES_09.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\nvoid f_ctcvfbiv()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_3DES, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_ctcvfbiv();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401203,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_3DES_11.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\n\n\nstatic void f_ghmxmuun()\n{\n    if(5!=5)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\nstatic void f_qjnifhcq()\n{\n    if(5==5)\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\nvoid f_unidxbhm()\n{\n    f_ghmxmuun();\n    f_qjnifhcq();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_unidxbhm();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401204,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_DES_03.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\nvoid f_oiujwgbb()\n{\n    if(5==5)\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_DES, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_oiujwgbb();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401205,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_DES_03.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\nvoid f_yrxgffxr()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_RC5, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_yrxgffxr();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401207,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_RC5_13.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\nvoid f_iwhkkkcd()\n{\n    if(1)\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_3DES, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_iwhkkkcd();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401209,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_3DES_02.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\nvoid f_wvwojhqi()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_DES, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_wvwojhqi();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401211,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_DES_11.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\nvoid f_hvannnrz()\n{\n    if(5==5)\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_RC5, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_hvannnrz();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401213,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_RC5_03.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\nvoid f_mgorsawt()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_RC5, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_mgorsawt();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401215,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_RC5_09.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\nvoid f_pwfbsrzp()\n{\n    if(globalTrue)\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_3DES, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_pwfbsrzp();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401217,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_3DES_10.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\nvoid f_lhjrhyfh()\n{\n    if(5==5)\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_3DES, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_lhjrhyfh();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401219,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_3DES_03.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\nvoid f_gcirliea()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_DES, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_gcirliea();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401221,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_DES_09.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\nvoid f_qonxqvug()\n{\n    if(globalTrue)\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_DES, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_qonxqvug();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401223,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_DES_10.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\n\n\nstatic void f_tqwytnxt()\n{\n    while(1)\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n        break;\n    }\n}\n\nvoid f_shclxtco()\n{\n    f_tqwytnxt();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_shclxtco();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401224,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_3DES_16.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\nvoid f_xsdpasyl()\n{\n    while(1)\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_3DES, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n        break;\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_xsdpasyl();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401225,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_3DES_16.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\n\n\nstatic void f_xyoggfxs()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\nvoid f_zlgofzfn()\n{\n    f_xyoggfxs();\n}\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_zlgofzfn();\n\n    return 0;\n}\n\n",
    "target": 0,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401226,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_DES_17.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "\n\n\n#include \"std_testcase.h\"\n\n#include <windows.h>\n#include <wincrypt.h>\n\n\n#pragma comment (lib, \"Advapi32\")\n\n\nvoid f_rskocrsb()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            \n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                \n                password[0] = '\\0';\n            }\n            \n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            \n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            \n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            \n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            \n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            \n            if(!CryptDeriveKey(hCryptProv, CALG_DES, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            \n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            \n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            \n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n\n    f_rskocrsb();\n\n    return 0;\n}\n\n",
    "target": 1,
    "language": "c",
    "dataset": "juliet 1.3",
    "idx": 401227,
    "original_file": "testcases/CWE327_Use_Broken_Crypto/CWE327_Use_Broken_Crypto__w32_DES_17.c",
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "static int rsa_builtin_keygen(RSA *rsa, int bits, BIGNUM *e_value,\n                              BN_GENCB *cb)\n{\n    BIGNUM *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *tmp;\n    int bitsp, bitsq, ok = -1, n = 0;\n    BN_CTX *ctx = NULL;\n    unsigned long error = 0;\n\n    /*\n     * When generating ridiculously small keys, we can get stuck\n     * continually regenerating the same prime values.\n     */\n    if (bits < 16) {\n        ok = 0;             /* we set our own err */\n        RSAerr(RSA_F_RSA_BUILTIN_KEYGEN, RSA_R_KEY_SIZE_TOO_SMALL);\n        goto err;\n    }\n\n    ctx = BN_CTX_new();\n    if (ctx == NULL)\n        goto err;\n    BN_CTX_start(ctx);\n    r0 = BN_CTX_get(ctx);\n    r1 = BN_CTX_get(ctx);\n    r2 = BN_CTX_get(ctx);\n    r3 = BN_CTX_get(ctx);\n    if (r3 == NULL)\n        goto err;\n\n    bitsp = (bits + 1) / 2;\n    bitsq = bits - bitsp;\n\n    /* We need the RSA components non-NULL */\n    if (!rsa->n && ((rsa->n = BN_new()) == NULL))\n        goto err;\n    if (!rsa->d && ((rsa->d = BN_secure_new()) == NULL))\n        goto err;\n    if (!rsa->e && ((rsa->e = BN_new()) == NULL))\n        goto err;\n    if (!rsa->p && ((rsa->p = BN_secure_new()) == NULL))\n        goto err;\n    if (!rsa->q && ((rsa->q = BN_secure_new()) == NULL))\n        goto err;\n    if (!rsa->dmp1 && ((rsa->dmp1 = BN_secure_new()) == NULL))\n        goto err;\n    if (!rsa->dmq1 && ((rsa->dmq1 = BN_secure_new()) == NULL))\n        goto err;\n    if (!rsa->iqmp && ((rsa->iqmp = BN_secure_new()) == NULL))\n        goto err;\n\n     if (BN_copy(rsa->e, e_value) == NULL)\n         goto err;\n \n     BN_set_flags(r2, BN_FLG_CONSTTIME);\n     /* generate p and q */\n     for (;;) {\n        if (!BN_sub(r2, rsa->p, BN_value_one()))\n            goto err;\n        ERR_set_mark();\n        if (BN_mod_inverse(r1, r2, rsa->e, ctx) != NULL) {\n            /* GCD == 1 since inverse exists */\n            break;\n        }\n        error = ERR_peek_last_error();\n        if (ERR_GET_LIB(error) == ERR_LIB_BN\n            && ERR_GET_REASON(error) == BN_R_NO_INVERSE) {\n            /* GCD != 1 */\n            ERR_pop_to_mark();\n        } else {\n            goto err;\n        }\n        if (!BN_GENCB_call(cb, 2, n++))\n            goto err;\n    }\n    if (!BN_GENCB_call(cb, 3, 0))\n        goto err;\n    for (;;) {\n        do {\n            if (!BN_generate_prime_ex(rsa->q, bitsq, 0, NULL, NULL, cb))\n                goto err;\n        } while (BN_cmp(rsa->p, rsa->q) == 0);\n        if (!BN_sub(r2, rsa->q, BN_value_one()))\n            goto err;\n        ERR_set_mark();\n        if (BN_mod_inverse(r1, r2, rsa->e, ctx) != NULL) {\n            /* GCD == 1 since inverse exists */\n            break;\n        }\n        error = ERR_peek_last_error();\n        if (ERR_GET_LIB(error) == ERR_LIB_BN\n            && ERR_GET_REASON(error) == BN_R_NO_INVERSE) {\n            /* GCD != 1 */\n            ERR_pop_to_mark();\n        } else {\n            goto err;\n        }\n        if (!BN_GENCB_call(cb, 2, n++))\n            goto err;\n    }\n    if (!BN_GENCB_call(cb, 3, 1))\n        goto err;\n    if (BN_cmp(rsa->p, rsa->q) < 0) {\n        tmp = rsa->p;\n        rsa->p = rsa->q;\n        rsa->q = tmp;\n    }\n\n    /* calculate n */\n    if (!BN_mul(rsa->n, rsa->p, rsa->q, ctx))\n        goto err;\n\n    /* calculate d */\n    if (!BN_sub(r1, rsa->p, BN_value_one()))\n        goto err;               /* p-1 */\n    if (!BN_sub(r2, rsa->q, BN_value_one()))\n        goto err;               /* q-1 */\n    if (!BN_mul(r0, r1, r2, ctx))\n        goto err;               /* (p-1)(q-1) */\n    {\n        BIGNUM *pr0 = BN_new();\n\n        if (pr0 == NULL)\n            goto err;\n        BN_with_flags(pr0, r0, BN_FLG_CONSTTIME);\n        if (!BN_mod_inverse(rsa->d, rsa->e, pr0, ctx)) {\n            BN_free(pr0);\n            goto err;               /* d */\n        }\n        /* We MUST free pr0 before any further use of r0 */\n        BN_free(pr0);\n    }\n\n    {\n        BIGNUM *d = BN_new();\n\n        if (d == NULL)\n            goto err;\n        BN_with_flags(d, rsa->d, BN_FLG_CONSTTIME);\n\n        if (   /* calculate d mod (p-1) */\n               !BN_mod(rsa->dmp1, d, r1, ctx)\n               /* calculate d mod (q-1) */\n            || !BN_mod(rsa->dmq1, d, r2, ctx)) {\n            BN_free(d);\n            goto err;\n        }\n        /* We MUST free d before any further use of rsa->d */\n        BN_free(d);\n    }\n\n    {\n        BIGNUM *p = BN_new();\n\n        if (p == NULL)\n            goto err;\n        BN_with_flags(p, rsa->p, BN_FLG_CONSTTIME);\n\n        /* calculate inverse of q mod p */\n        if (!BN_mod_inverse(rsa->iqmp, rsa->q, p, ctx)) {\n            BN_free(p);\n            goto err;\n        }\n        /* We MUST free p before any further use of rsa->p */\n        BN_free(p);\n    }\n\n    ok = 1;\n err:\n    if (ok == -1) {\n        RSAerr(RSA_F_RSA_BUILTIN_KEYGEN, ERR_LIB_BN);\n        ok = 0;\n    }\n    if (ctx != NULL)\n        BN_CTX_end(ctx);\n    BN_CTX_free(ctx);\n\n    return ok;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141615,
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "static int rsa_builtin_keygen(RSA *rsa, int bits, BIGNUM *e_value,\n                              BN_GENCB *cb)\n{\n    BIGNUM *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *tmp;\n    int bitsp, bitsq, ok = -1, n = 0;\n    BN_CTX *ctx = NULL;\n    unsigned long error = 0;\n\n    /*\n     * When generating ridiculously small keys, we can get stuck\n     * continually regenerating the same prime values.\n     */\n    if (bits < 16) {\n        ok = 0;             /* we set our own err */\n        RSAerr(RSA_F_RSA_BUILTIN_KEYGEN, RSA_R_KEY_SIZE_TOO_SMALL);\n        goto err;\n    }\n\n    ctx = BN_CTX_new();\n    if (ctx == NULL)\n        goto err;\n    BN_CTX_start(ctx);\n    r0 = BN_CTX_get(ctx);\n    r1 = BN_CTX_get(ctx);\n    r2 = BN_CTX_get(ctx);\n    r3 = BN_CTX_get(ctx);\n    if (r3 == NULL)\n        goto err;\n\n    bitsp = (bits + 1) / 2;\n    bitsq = bits - bitsp;\n\n    /* We need the RSA components non-NULL */\n    if (!rsa->n && ((rsa->n = BN_new()) == NULL))\n        goto err;\n    if (!rsa->d && ((rsa->d = BN_secure_new()) == NULL))\n        goto err;\n    if (!rsa->e && ((rsa->e = BN_new()) == NULL))\n        goto err;\n    if (!rsa->p && ((rsa->p = BN_secure_new()) == NULL))\n        goto err;\n    if (!rsa->q && ((rsa->q = BN_secure_new()) == NULL))\n        goto err;\n    if (!rsa->dmp1 && ((rsa->dmp1 = BN_secure_new()) == NULL))\n        goto err;\n    if (!rsa->dmq1 && ((rsa->dmq1 = BN_secure_new()) == NULL))\n        goto err;\n    if (!rsa->iqmp && ((rsa->iqmp = BN_secure_new()) == NULL))\n        goto err;\n\n     if (BN_copy(rsa->e, e_value) == NULL)\n         goto err;\n \n    BN_set_flags(rsa->p, BN_FLG_CONSTTIME);\n    BN_set_flags(rsa->q, BN_FLG_CONSTTIME);\n     BN_set_flags(r2, BN_FLG_CONSTTIME);\n     /* generate p and q */\n     for (;;) {\n        if (!BN_sub(r2, rsa->p, BN_value_one()))\n            goto err;\n        ERR_set_mark();\n        if (BN_mod_inverse(r1, r2, rsa->e, ctx) != NULL) {\n            /* GCD == 1 since inverse exists */\n            break;\n        }\n        error = ERR_peek_last_error();\n        if (ERR_GET_LIB(error) == ERR_LIB_BN\n            && ERR_GET_REASON(error) == BN_R_NO_INVERSE) {\n            /* GCD != 1 */\n            ERR_pop_to_mark();\n        } else {\n            goto err;\n        }\n        if (!BN_GENCB_call(cb, 2, n++))\n            goto err;\n    }\n    if (!BN_GENCB_call(cb, 3, 0))\n        goto err;\n    for (;;) {\n        do {\n            if (!BN_generate_prime_ex(rsa->q, bitsq, 0, NULL, NULL, cb))\n                goto err;\n        } while (BN_cmp(rsa->p, rsa->q) == 0);\n        if (!BN_sub(r2, rsa->q, BN_value_one()))\n            goto err;\n        ERR_set_mark();\n        if (BN_mod_inverse(r1, r2, rsa->e, ctx) != NULL) {\n            /* GCD == 1 since inverse exists */\n            break;\n        }\n        error = ERR_peek_last_error();\n        if (ERR_GET_LIB(error) == ERR_LIB_BN\n            && ERR_GET_REASON(error) == BN_R_NO_INVERSE) {\n            /* GCD != 1 */\n            ERR_pop_to_mark();\n        } else {\n            goto err;\n        }\n        if (!BN_GENCB_call(cb, 2, n++))\n            goto err;\n    }\n    if (!BN_GENCB_call(cb, 3, 1))\n        goto err;\n    if (BN_cmp(rsa->p, rsa->q) < 0) {\n        tmp = rsa->p;\n        rsa->p = rsa->q;\n        rsa->q = tmp;\n    }\n\n    /* calculate n */\n    if (!BN_mul(rsa->n, rsa->p, rsa->q, ctx))\n        goto err;\n\n    /* calculate d */\n    if (!BN_sub(r1, rsa->p, BN_value_one()))\n        goto err;               /* p-1 */\n    if (!BN_sub(r2, rsa->q, BN_value_one()))\n        goto err;               /* q-1 */\n    if (!BN_mul(r0, r1, r2, ctx))\n        goto err;               /* (p-1)(q-1) */\n    {\n        BIGNUM *pr0 = BN_new();\n\n        if (pr0 == NULL)\n            goto err;\n        BN_with_flags(pr0, r0, BN_FLG_CONSTTIME);\n        if (!BN_mod_inverse(rsa->d, rsa->e, pr0, ctx)) {\n            BN_free(pr0);\n            goto err;               /* d */\n        }\n        /* We MUST free pr0 before any further use of r0 */\n        BN_free(pr0);\n    }\n\n    {\n        BIGNUM *d = BN_new();\n\n        if (d == NULL)\n            goto err;\n        BN_with_flags(d, rsa->d, BN_FLG_CONSTTIME);\n\n        if (   /* calculate d mod (p-1) */\n               !BN_mod(rsa->dmp1, d, r1, ctx)\n               /* calculate d mod (q-1) */\n            || !BN_mod(rsa->dmq1, d, r2, ctx)) {\n            BN_free(d);\n            goto err;\n        }\n        /* We MUST free d before any further use of rsa->d */\n        BN_free(d);\n    }\n\n    {\n        BIGNUM *p = BN_new();\n\n        if (p == NULL)\n            goto err;\n        BN_with_flags(p, rsa->p, BN_FLG_CONSTTIME);\n\n        /* calculate inverse of q mod p */\n        if (!BN_mod_inverse(rsa->iqmp, rsa->q, p, ctx)) {\n            BN_free(p);\n            goto err;\n        }\n        /* We MUST free p before any further use of rsa->p */\n        BN_free(p);\n    }\n\n    ok = 1;\n err:\n    if (ok == -1) {\n        RSAerr(RSA_F_RSA_BUILTIN_KEYGEN, ERR_LIB_BN);\n        ok = 0;\n    }\n    if (ctx != NULL)\n        BN_CTX_end(ctx);\n    BN_CTX_free(ctx);\n\n    return ok;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141616,
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "static int rsa_builtin_keygen(RSA *rsa, int bits, BIGNUM *e_value,\n                              BN_GENCB *cb)\n{\n    BIGNUM *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *tmp;\n    BIGNUM local_r0, local_d, local_p;\n    BIGNUM *pr0, *d, *p;\n    int bitsp, bitsq, ok = -1, n = 0;\n    BN_CTX *ctx = NULL;\n    unsigned long error = 0;\n\n    /*\n     * When generating ridiculously small keys, we can get stuck\n     * continually regenerating the same prime values.\n     */\n    if (bits < 16) {\n        ok = 0;             /* we set our own err */\n        RSAerr(RSA_F_RSA_BUILTIN_KEYGEN, RSA_R_KEY_SIZE_TOO_SMALL);\n        goto err;\n    }\n\n    ctx = BN_CTX_new();\n    if (ctx == NULL)\n        goto err;\n    BN_CTX_start(ctx);\n    r0 = BN_CTX_get(ctx);\n    r1 = BN_CTX_get(ctx);\n    r2 = BN_CTX_get(ctx);\n    r3 = BN_CTX_get(ctx);\n    if (r3 == NULL)\n        goto err;\n\n    bitsp = (bits + 1) / 2;\n    bitsq = bits - bitsp;\n\n    /* We need the RSA components non-NULL */\n    if (!rsa->n && ((rsa->n = BN_new()) == NULL))\n        goto err;\n    if (!rsa->d && ((rsa->d = BN_new()) == NULL))\n        goto err;\n    if (!rsa->e && ((rsa->e = BN_new()) == NULL))\n        goto err;\n    if (!rsa->p && ((rsa->p = BN_new()) == NULL))\n        goto err;\n    if (!rsa->q && ((rsa->q = BN_new()) == NULL))\n        goto err;\n    if (!rsa->dmp1 && ((rsa->dmp1 = BN_new()) == NULL))\n        goto err;\n    if (!rsa->dmq1 && ((rsa->dmq1 = BN_new()) == NULL))\n        goto err;\n    if (!rsa->iqmp && ((rsa->iqmp = BN_new()) == NULL))\n        goto err;\n\n     if (BN_copy(rsa->e, e_value) == NULL)\n         goto err;\n \n     BN_set_flags(r2, BN_FLG_CONSTTIME);\n     /* generate p and q */\n     for (;;) {\n        if (!BN_sub(r2, rsa->p, BN_value_one()))\n            goto err;\n        ERR_set_mark();\n        if (BN_mod_inverse(r1, r2, rsa->e, ctx) != NULL) {\n            /* GCD == 1 since inverse exists */\n            break;\n        }\n        error = ERR_peek_last_error();\n        if (ERR_GET_LIB(error) == ERR_LIB_BN\n            && ERR_GET_REASON(error) == BN_R_NO_INVERSE) {\n            /* GCD != 1 */\n            ERR_pop_to_mark();\n        } else {\n            goto err;\n        }\n        if (!BN_GENCB_call(cb, 2, n++))\n            goto err;\n    }\n    if (!BN_GENCB_call(cb, 3, 0))\n        goto err;\n    for (;;) {\n        do {\n            if (!BN_generate_prime_ex(rsa->q, bitsq, 0, NULL, NULL, cb))\n                goto err;\n        } while (BN_cmp(rsa->p, rsa->q) == 0);\n        if (!BN_sub(r2, rsa->q, BN_value_one()))\n            goto err;\n        ERR_set_mark();\n        if (BN_mod_inverse(r1, r2, rsa->e, ctx) != NULL) {\n            /* GCD == 1 since inverse exists */\n            break;\n        }\n        error = ERR_peek_last_error();\n        if (ERR_GET_LIB(error) == ERR_LIB_BN\n            && ERR_GET_REASON(error) == BN_R_NO_INVERSE) {\n            /* GCD != 1 */\n            ERR_pop_to_mark();\n        } else {\n            goto err;\n        }\n        if (!BN_GENCB_call(cb, 2, n++))\n            goto err;\n    }\n    if (!BN_GENCB_call(cb, 3, 1))\n        goto err;\n    if (BN_cmp(rsa->p, rsa->q) < 0) {\n        tmp = rsa->p;\n        rsa->p = rsa->q;\n        rsa->q = tmp;\n    }\n\n    /* calculate n */\n    if (!BN_mul(rsa->n, rsa->p, rsa->q, ctx))\n        goto err;\n\n    /* calculate d */\n    if (!BN_sub(r1, rsa->p, BN_value_one()))\n        goto err;               /* p-1 */\n    if (!BN_sub(r2, rsa->q, BN_value_one()))\n        goto err;               /* q-1 */\n    if (!BN_mul(r0, r1, r2, ctx))\n        goto err;               /* (p-1)(q-1) */\n    if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME)) {\n        pr0 = &local_r0;\n        BN_with_flags(pr0, r0, BN_FLG_CONSTTIME);\n    } else\n        pr0 = r0;\n    if (!BN_mod_inverse(rsa->d, rsa->e, pr0, ctx))\n        goto err;               /* d */\n\n    /* set up d for correct BN_FLG_CONSTTIME flag */\n    if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME)) {\n        d = &local_d;\n        BN_with_flags(d, rsa->d, BN_FLG_CONSTTIME);\n    } else\n        d = rsa->d;\n\n    /* calculate d mod (p-1) */\n    if (!BN_mod(rsa->dmp1, d, r1, ctx))\n        goto err;\n\n    /* calculate d mod (q-1) */\n    if (!BN_mod(rsa->dmq1, d, r2, ctx))\n        goto err;\n\n    /* calculate inverse of q mod p */\n    if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME)) {\n        p = &local_p;\n        BN_with_flags(p, rsa->p, BN_FLG_CONSTTIME);\n    } else\n        p = rsa->p;\n    if (!BN_mod_inverse(rsa->iqmp, rsa->q, p, ctx))\n        goto err;\n\n    ok = 1;\n err:\n    if (ok == -1) {\n        RSAerr(RSA_F_RSA_BUILTIN_KEYGEN, ERR_LIB_BN);\n        ok = 0;\n    }\n    if (ctx != NULL) {\n        BN_CTX_end(ctx);\n        BN_CTX_free(ctx);\n    }\n\n    return ok;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141617,
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "static int rsa_builtin_keygen(RSA *rsa, int bits, BIGNUM *e_value,\n                              BN_GENCB *cb)\n{\n    BIGNUM *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *tmp;\n    BIGNUM local_r0, local_d, local_p;\n    BIGNUM *pr0, *d, *p;\n    int bitsp, bitsq, ok = -1, n = 0;\n    BN_CTX *ctx = NULL;\n    unsigned long error = 0;\n\n    /*\n     * When generating ridiculously small keys, we can get stuck\n     * continually regenerating the same prime values.\n     */\n    if (bits < 16) {\n        ok = 0;             /* we set our own err */\n        RSAerr(RSA_F_RSA_BUILTIN_KEYGEN, RSA_R_KEY_SIZE_TOO_SMALL);\n        goto err;\n    }\n\n    ctx = BN_CTX_new();\n    if (ctx == NULL)\n        goto err;\n    BN_CTX_start(ctx);\n    r0 = BN_CTX_get(ctx);\n    r1 = BN_CTX_get(ctx);\n    r2 = BN_CTX_get(ctx);\n    r3 = BN_CTX_get(ctx);\n    if (r3 == NULL)\n        goto err;\n\n    bitsp = (bits + 1) / 2;\n    bitsq = bits - bitsp;\n\n    /* We need the RSA components non-NULL */\n    if (!rsa->n && ((rsa->n = BN_new()) == NULL))\n        goto err;\n    if (!rsa->d && ((rsa->d = BN_new()) == NULL))\n        goto err;\n    if (!rsa->e && ((rsa->e = BN_new()) == NULL))\n        goto err;\n    if (!rsa->p && ((rsa->p = BN_new()) == NULL))\n        goto err;\n    if (!rsa->q && ((rsa->q = BN_new()) == NULL))\n        goto err;\n    if (!rsa->dmp1 && ((rsa->dmp1 = BN_new()) == NULL))\n        goto err;\n    if (!rsa->dmq1 && ((rsa->dmq1 = BN_new()) == NULL))\n        goto err;\n    if (!rsa->iqmp && ((rsa->iqmp = BN_new()) == NULL))\n        goto err;\n\n     if (BN_copy(rsa->e, e_value) == NULL)\n         goto err;\n \n    BN_set_flags(rsa->p, BN_FLG_CONSTTIME);\n    BN_set_flags(rsa->q, BN_FLG_CONSTTIME);\n     BN_set_flags(r2, BN_FLG_CONSTTIME);\n     /* generate p and q */\n     for (;;) {\n        if (!BN_sub(r2, rsa->p, BN_value_one()))\n            goto err;\n        ERR_set_mark();\n        if (BN_mod_inverse(r1, r2, rsa->e, ctx) != NULL) {\n            /* GCD == 1 since inverse exists */\n            break;\n        }\n        error = ERR_peek_last_error();\n        if (ERR_GET_LIB(error) == ERR_LIB_BN\n            && ERR_GET_REASON(error) == BN_R_NO_INVERSE) {\n            /* GCD != 1 */\n            ERR_pop_to_mark();\n        } else {\n            goto err;\n        }\n        if (!BN_GENCB_call(cb, 2, n++))\n            goto err;\n    }\n    if (!BN_GENCB_call(cb, 3, 0))\n        goto err;\n    for (;;) {\n        do {\n            if (!BN_generate_prime_ex(rsa->q, bitsq, 0, NULL, NULL, cb))\n                goto err;\n        } while (BN_cmp(rsa->p, rsa->q) == 0);\n        if (!BN_sub(r2, rsa->q, BN_value_one()))\n            goto err;\n        ERR_set_mark();\n        if (BN_mod_inverse(r1, r2, rsa->e, ctx) != NULL) {\n            /* GCD == 1 since inverse exists */\n            break;\n        }\n        error = ERR_peek_last_error();\n        if (ERR_GET_LIB(error) == ERR_LIB_BN\n            && ERR_GET_REASON(error) == BN_R_NO_INVERSE) {\n            /* GCD != 1 */\n            ERR_pop_to_mark();\n        } else {\n            goto err;\n        }\n        if (!BN_GENCB_call(cb, 2, n++))\n            goto err;\n    }\n    if (!BN_GENCB_call(cb, 3, 1))\n        goto err;\n    if (BN_cmp(rsa->p, rsa->q) < 0) {\n        tmp = rsa->p;\n        rsa->p = rsa->q;\n        rsa->q = tmp;\n    }\n\n    /* calculate n */\n    if (!BN_mul(rsa->n, rsa->p, rsa->q, ctx))\n        goto err;\n\n    /* calculate d */\n    if (!BN_sub(r1, rsa->p, BN_value_one()))\n        goto err;               /* p-1 */\n    if (!BN_sub(r2, rsa->q, BN_value_one()))\n        goto err;               /* q-1 */\n    if (!BN_mul(r0, r1, r2, ctx))\n        goto err;               /* (p-1)(q-1) */\n    if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME)) {\n        pr0 = &local_r0;\n        BN_with_flags(pr0, r0, BN_FLG_CONSTTIME);\n    } else\n        pr0 = r0;\n    if (!BN_mod_inverse(rsa->d, rsa->e, pr0, ctx))\n        goto err;               /* d */\n\n    /* set up d for correct BN_FLG_CONSTTIME flag */\n    if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME)) {\n        d = &local_d;\n        BN_with_flags(d, rsa->d, BN_FLG_CONSTTIME);\n    } else\n        d = rsa->d;\n\n    /* calculate d mod (p-1) */\n    if (!BN_mod(rsa->dmp1, d, r1, ctx))\n        goto err;\n\n    /* calculate d mod (q-1) */\n    if (!BN_mod(rsa->dmq1, d, r2, ctx))\n        goto err;\n\n    /* calculate inverse of q mod p */\n    if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME)) {\n        p = &local_p;\n        BN_with_flags(p, rsa->p, BN_FLG_CONSTTIME);\n    } else\n        p = rsa->p;\n    if (!BN_mod_inverse(rsa->iqmp, rsa->q, p, ctx))\n        goto err;\n\n    ok = 1;\n err:\n    if (ok == -1) {\n        RSAerr(RSA_F_RSA_BUILTIN_KEYGEN, ERR_LIB_BN);\n        ok = 0;\n    }\n    if (ctx != NULL) {\n        BN_CTX_end(ctx);\n        BN_CTX_free(ctx);\n    }\n\n    return ok;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141618,
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "keyfetch_done(isc_task_t *task, isc_event_t *event) {\n\tisc_result_t result, eresult;\n\tdns_fetchevent_t *devent;\n\tdns_keyfetch_t *kfetch;\n\tdns_zone_t *zone;\n\tisc_mem_t *mctx = NULL;\n\tdns_keytable_t *secroots = NULL;\n\tdns_dbversion_t *ver = NULL;\n\tdns_diff_t diff;\n\tbool alldone = false;\n\tbool commit = false;\n\tdns_name_t *keyname;\n\tdns_rdata_t sigrr = DNS_RDATA_INIT;\n\tdns_rdata_t dnskeyrr = DNS_RDATA_INIT;\n\tdns_rdata_t keydatarr = DNS_RDATA_INIT;\n\tdns_rdata_rrsig_t sig;\n\tdns_rdata_dnskey_t dnskey;\n\tdns_rdata_keydata_t keydata;\n\tbool initializing;\n\tchar namebuf[DNS_NAME_FORMATSIZE];\n\tunsigned char key_buf[4096];\n\tisc_buffer_t keyb;\n\tdst_key_t *dstkey;\n\tisc_stdtime_t now;\n\tint pending = 0;\n\tbool secure = false, initial = false;\n\tbool free_needed;\n\n\tUNUSED(task);\n\tINSIST(event != NULL && event->ev_type == DNS_EVENT_FETCHDONE);\n\tINSIST(event->ev_arg != NULL);\n\n\tkfetch = event->ev_arg;\n\tzone = kfetch->zone;\n\tisc_mem_attach(zone->mctx, &mctx);\n\tkeyname = dns_fixedname_name(&kfetch->name);\n\n\tdevent = (dns_fetchevent_t *) event;\n\teresult = devent->result;\n\n\t/* Free resources which are not of interest */\n\tif (devent->node != NULL) {\n\t\tdns_db_detachnode(devent->db, &devent->node);\n\t}\n\tif (devent->db != NULL) {\n\t\tdns_db_detach(&devent->db);\n\t}\n\tisc_event_free(&event);\n\tdns_resolver_destroyfetch(&kfetch->fetch);\n\n\tLOCK_ZONE(zone);\n\tif (DNS_ZONE_FLAG(zone, DNS_ZONEFLG_EXITING) || zone->view == NULL) {\n\t\tgoto cleanup;\n\t}\n\n\tisc_stdtime_get(&now);\n\tdns_name_format(keyname, namebuf, sizeof(namebuf));\n\n\tresult = dns_view_getsecroots(zone->view, &secroots);\n\tINSIST(result == ISC_R_SUCCESS);\n\n\tdns_diff_init(mctx, &diff);\n\n\tCHECK(dns_db_newversion(kfetch->db, &ver));\n\n\tzone->refreshkeycount--;\n\talldone = (zone->refreshkeycount == 0);\n\n\tif (alldone) {\n\t\tDNS_ZONE_CLRFLAG(zone, DNS_ZONEFLG_REFRESHING);\n\t}\n\n\tdnssec_log(zone, ISC_LOG_DEBUG(3),\n\t\t   \"Returned from key fetch in keyfetch_done() for '%s': %s\",\n\t\t   namebuf, dns_result_totext(eresult));\n\n\t/* Fetch failed */\n\tif (eresult != ISC_R_SUCCESS ||\n\t    !dns_rdataset_isassociated(&kfetch->dnskeyset))\n\t{\n\t\tdnssec_log(zone, ISC_LOG_WARNING,\n\t\t\t   \"Unable to fetch DNSKEY set '%s': %s\",\n\t\t\t   namebuf, dns_result_totext(eresult));\n\t\tCHECK(minimal_update(kfetch, ver, &diff));\n\t\tgoto done;\n\t}\n\n\t/* No RRSIGs found */\n\tif (!dns_rdataset_isassociated(&kfetch->dnskeysigset)) {\n\t\tdnssec_log(zone, ISC_LOG_WARNING,\n\t\t\t   \"No DNSKEY RRSIGs found for '%s': %s\",\n\t\t\t   namebuf, dns_result_totext(eresult));\n\t\tCHECK(minimal_update(kfetch, ver, &diff));\n\t\tgoto done;\n\t}\n\n\t/*\n\t * Clear any cached trust level, as we need to run validation\n\t * over again; trusted keys might have changed.\n\t */\n\tkfetch->dnskeyset.trust = kfetch->dnskeysigset.trust = dns_trust_none;\n\n\t/*\n\t * Validate the dnskeyset against the current trusted keys.\n\t */\n\tfor (result = dns_rdataset_first(&kfetch->dnskeysigset);\n\t     result == ISC_R_SUCCESS;\n\t     result = dns_rdataset_next(&kfetch->dnskeysigset))\n\t{\n\t\tdns_keynode_t *keynode = NULL;\n\n\t\tdns_rdata_reset(&sigrr);\n\t\tdns_rdataset_current(&kfetch->dnskeysigset, &sigrr);\n\t\tresult = dns_rdata_tostruct(&sigrr, &sig, NULL);\n\t\tRUNTIME_CHECK(result == ISC_R_SUCCESS);\n\n\t\tresult = dns_keytable_find(secroots, keyname, &keynode);\n\t\twhile (result == ISC_R_SUCCESS) {\n\t\t\tdns_keynode_t *nextnode = NULL;\n\t\t\tdns_fixedname_t fixed;\n\t\t\tdns_fixedname_init(&fixed);\n\n\t\t\tdstkey = dns_keynode_key(keynode);\n\t\t\tif (dstkey == NULL) {\n\t\t\t\t/* fail_secure() was called */\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (dst_key_alg(dstkey) == sig.algorithm &&\n\t\t\t    dst_key_id(dstkey) == sig.keyid)\n\t\t\t{\n\t\t\t\tresult = dns_dnssec_verify(keyname,\n\t\t\t\t\t\t\t   &kfetch->dnskeyset,\n\t\t\t\t\t\t\t   dstkey, false,\n\t\t\t\t\t\t\t   0,\n\t\t\t\t\t\t\t   zone->view->mctx,\n\t\t\t\t\t\t\t   &sigrr,\n\t\t\t\t\t\t\t   dns_fixedname_name(\n\t\t\t\t\t\t\t   &fixed));\n\n\t\t\t\tdnssec_log(zone, ISC_LOG_DEBUG(3),\n\t\t\t\t\t   \"Verifying DNSKEY set for zone \"\n\t\t\t\t\t   \"'%s' using key %d/%d: %s\",\n\t\t\t\t\t   namebuf, sig.keyid, sig.algorithm,\n\t\t\t\t\t   dns_result_totext(result));\n\n\t\t\t\tif (result == ISC_R_SUCCESS) {\n\t\t\t\t\tkfetch->dnskeyset.trust =\n\t\t\t\t\t\tdns_trust_secure;\n\t\t\t\t\tkfetch->dnskeysigset.trust =\n\t\t\t\t\t\tdns_trust_secure;\n\t\t\t\t\tsecure = true;\n\t\t\t\t\tinitial = dns_keynode_initial(keynode);\n\t\t\t\t\tdns_keynode_trust(keynode);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresult = dns_keytable_nextkeynode(secroots,\n\t\t\t\t\t\t\t  keynode, &nextnode);\n\t\t\tdns_keytable_detachkeynode(secroots, &keynode);\n\t\t\tkeynode = nextnode;\n\t\t}\n\n\t\tif (keynode != NULL) {\n\t\t\tdns_keytable_detachkeynode(secroots, &keynode);\n\t\t}\n\n\t\tif (secure) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * If we were not able to verify the answer using the current\n\t * trusted keys then all we can do is look at any revoked keys.\n\t */\n\tif (!secure) {\n\t\tdnssec_log(zone, ISC_LOG_INFO,\n\t\t\t   \"DNSKEY set for zone '%s' could not be verified \"\n\t\t\t   \"with current keys\", namebuf);\n\t}\n\n\t/*\n\t * First scan keydataset to find keys that are not in dnskeyset\n\t *   - Missing keys which are not scheduled for removal,\n\t *     log a warning\n\t *   - Missing keys which are scheduled for removal and\n\t *     the remove hold-down timer has completed should\n\t *     be removed from the key zone\n\t *   - Missing keys whose acceptance timers have not yet\n\t *     completed, log a warning and reset the acceptance\n\t *     timer to 30 days in the future\n\t *   - All keys not being removed have their refresh timers\n\t *     updated\n\t */\n\tinitializing = true;\n\tfor (result = dns_rdataset_first(&kfetch->keydataset);\n\t     result == ISC_R_SUCCESS;\n\t     result = dns_rdataset_next(&kfetch->keydataset))\n\t{\n\t\tdns_keytag_t keytag;\n\n\t\tdns_rdata_reset(&keydatarr);\n\t\tdns_rdataset_current(&kfetch->keydataset, &keydatarr);\n\t\tresult = dns_rdata_tostruct(&keydatarr, &keydata, NULL);\n\t\tRUNTIME_CHECK(result == ISC_R_SUCCESS);\n\n\t\tdns_keydata_todnskey(&keydata, &dnskey, NULL);\n\t\tresult = compute_tag(keyname, &dnskey, mctx, &keytag);\n\t\tRUNTIME_CHECK(result == ISC_R_SUCCESS);\n\n\t\t/*\n\t\t * If any keydata record has a nonzero add holddown, then\n\t\t * there was a pre-existing trust anchor for this domain;\n\t\t * that means we are *not* initializing it and shouldn't\n\t\t * automatically trust all the keys we find at the zone apex.\n\t\t */\n\t\tinitializing = initializing && (keydata.addhd == 0);\n\n\t\tif (! matchkey(&kfetch->dnskeyset, &keydatarr)) {\n\t\t\tbool deletekey = false;\n\n\t\t\tif (!secure) {\n\t\t\t\tif (keydata.removehd != 0 &&\n\t\t\t\t    keydata.removehd <= now)\n\t\t\t\t{\n\t\t\t\t\tdeletekey = true;\n\t\t\t\t}\n\t\t\t} else if (keydata.addhd == 0) {\n\t\t\t\tdeletekey = true;\n\t\t\t} else if (keydata.addhd > now) {\n\t\t\t\tdnssec_log(zone, ISC_LOG_INFO,\n\t\t\t\t\t   \"Pending key %d for zone %s \"\n\t\t\t\t\t   \"unexpectedly missing \"\n\t\t\t\t\t   \"restarting 30-day acceptance \"\n\t\t\t\t\t   \"timer\", keytag, namebuf);\n\t\t\t\tif (keydata.addhd < now + dns_zone_mkey_month) {\n\t\t\t\t\tkeydata.addhd =\n\t\t\t\t\t\tnow + dns_zone_mkey_month;\n\t\t\t\t}\n\t\t\t\tkeydata.refresh = refresh_time(kfetch, false);\n\t\t\t} else if (keydata.removehd == 0) {\n\t\t\t\tdnssec_log(zone, ISC_LOG_INFO,\n\t\t\t\t\t   \"Active key %d for zone %s \"\n\t\t\t\t\t   \"unexpectedly missing\",\n\t\t\t\t\t   keytag, namebuf);\n\t\t\t\tkeydata.refresh = now + dns_zone_mkey_hour;\n\t\t\t} else if (keydata.removehd <= now) {\n\t\t\t\tdeletekey = true;\n\t\t\t\tdnssec_log(zone, ISC_LOG_INFO,\n\t\t\t\t\t   \"Revoked key %d for zone %s \"\n\t\t\t\t\t   \"missing: deleting from \"\n\t\t\t\t\t   \"managed keys database\",\n\t\t\t\t\t   keytag, namebuf);\n\t\t\t} else {\n\t\t\t\tkeydata.refresh = refresh_time(kfetch, false);\n\t\t\t}\n\n\t\t\tif (secure || deletekey) {\n\t\t\t\t/* Delete old version */\n\t\t\t\tCHECK(update_one_rr(kfetch->db, ver, &diff,\n\t\t\t\t\t\t    DNS_DIFFOP_DEL, keyname, 0,\n\t\t\t\t\t\t    &keydatarr));\n\t\t\t}\n\n\t\t\tif (!secure || deletekey) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdns_rdata_reset(&keydatarr);\n\t\t\tisc_buffer_init(&keyb, key_buf, sizeof(key_buf));\n\t\t\tdns_rdata_fromstruct(&keydatarr, zone->rdclass,\n\t\t\t\t\t     dns_rdatatype_keydata,\n\t\t\t\t\t     &keydata, &keyb);\n\n\t\t\t/* Insert updated version */\n\t\t\tCHECK(update_one_rr(kfetch->db, ver, &diff,\n\t\t\t\t\t    DNS_DIFFOP_ADD, keyname, 0,\n\t\t\t\t\t    &keydatarr));\n\n\t\t\tset_refreshkeytimer(zone, &keydata, now, false);\n\t\t}\n\t}\n\n\t/*\n\t * Next scan dnskeyset:\n\t *   - If new keys are found (i.e., lacking a match in keydataset)\n\t *     add them to the key zone and set the acceptance timer\n\t *     to 30 days in the future (or to immediately if we've\n\t *     determined that we're initializing the zone for the\n\t *     first time)\n\t *   - Previously-known keys that have been revoked\n\t *     must be scheduled for removal from the key zone (or,\n\t *     if they hadn't been accepted as trust anchors yet\n\t *     anyway, removed at once)\n\t *   - Previously-known unrevoked keys whose acceptance timers\n\t *     have completed are promoted to trust anchors\n\t *   - All keys not being removed have their refresh\n\t *     timers updated\n\t */\n\tfor (result = dns_rdataset_first(&kfetch->dnskeyset);\n\t     result == ISC_R_SUCCESS;\n\t     result = dns_rdataset_next(&kfetch->dnskeyset))\n\t{\n\t\tbool revoked = false;\n\t\tbool newkey = false;\n\t\tbool updatekey = false;\n\t\tbool deletekey = false;\n\t\tbool trustkey = false;\n\t\tdns_keytag_t keytag;\n\n\t\tdns_rdata_reset(&dnskeyrr);\n\t\tdns_rdataset_current(&kfetch->dnskeyset, &dnskeyrr);\n\t\tresult = dns_rdata_tostruct(&dnskeyrr, &dnskey, NULL);\n\t\tRUNTIME_CHECK(result == ISC_R_SUCCESS);\n\n\t\t/* Skip ZSK's */\n\t\tif ((dnskey.flags & DNS_KEYFLAG_KSK) == 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tresult = compute_tag(keyname, &dnskey, mctx, &keytag);\n\t\tRUNTIME_CHECK(result == ISC_R_SUCCESS);\n\n\t\trevoked = ((dnskey.flags & DNS_KEYFLAG_REVOKE) != 0);\n\n\t\tif (matchkey(&kfetch->keydataset, &dnskeyrr)) {\n\t\t\tdns_rdata_reset(&keydatarr);\n\t\t\tdns_rdataset_current(&kfetch->keydataset, &keydatarr);\n\t\t\tresult = dns_rdata_tostruct(&keydatarr, &keydata, NULL);\n\t\t\tRUNTIME_CHECK(result == ISC_R_SUCCESS);\n\n\t\t\tif (revoked && revocable(kfetch, &keydata)) {\n\t\t\t\tif (keydata.addhd > now) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Key wasn't trusted yet, and now\n\t\t\t\t\t * it's been revoked?  Just remove it\n\t\t\t\t\t */\n\t\t\t\t\tdeletekey = true;\n\t\t\t\t\tdnssec_log(zone, ISC_LOG_INFO,\n\t\t\t\t\t\t   \"Pending key %d for \"\n\t\t\t\t\t\t   \"zone %s is now revoked: \"\n\t\t\t\t\t\t   \"deleting from the \"\n\t\t\t\t\t\t   \"managed keys database\",\n\t\t\t\t\t\t   keytag, namebuf);\n\t\t\t\t} else if (keydata.removehd == 0) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Remove key from secroots.\n\t\t\t\t\t */\n\t\t\t\t\tdns_view_untrust(zone->view, keyname,\n\t\t\t\t\t\t\t &dnskey, mctx);\n\n\t\t\t\t\t/* If initializing, delete now */\n\t\t\t\t\tif (keydata.addhd == 0) {\n\t\t\t\t\t\tdeletekey = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tkeydata.removehd = now +\n\t\t\t\t\t\t\tdns_zone_mkey_month;\n\t\t\t\t\t\tkeydata.flags |=\n\t\t\t\t\t\t\tDNS_KEYFLAG_REVOKE;\n\t\t\t\t\t}\n\n\t\t\t\t\tdnssec_log(zone, ISC_LOG_INFO,\n\t\t\t\t\t\t   \"Trusted key %d for \"\n\t\t\t\t\t\t   \"zone %s is now revoked\",\n\t\t\t\t\t\t   keytag, namebuf);\n\t\t\t\t} else if (keydata.removehd < now) {\n\t\t\t\t\t/* Scheduled for removal */\n\t\t\t\t\tdeletekey = true;\n\n\t\t\t\t\tdnssec_log(zone, ISC_LOG_INFO,\n\t\t\t\t\t\t   \"Revoked key %d for \"\n\t\t\t\t\t\t   \"zone %s removal timer \"\n\t\t\t\t\t\t   \"complete: deleting from \"\n\t\t\t\t\t\t   \"the managed keys database\",\n\t\t\t\t\t\t   keytag, namebuf);\n\t\t\t\t}\n\t\t\t} else if (revoked && keydata.removehd == 0) {\n\t\t\t\tdnssec_log(zone, ISC_LOG_WARNING,\n\t\t\t\t\t   \"Active key %d for zone \"\n\t\t\t\t\t   \"%s is revoked but \"\n\t\t\t\t\t   \"did not self-sign; \"\n\t\t\t\t\t   \"ignoring\", keytag, namebuf);\n\t\t\t\tcontinue;\n\t\t\t} else if (secure) {\n\t\t\t\tif (keydata.removehd != 0) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Key isn't revoked--but it\n\t\t\t\t\t * seems it used to be.\n\t\t\t\t\t * Remove it now and add it\n\t\t\t\t\t * back as if it were a fresh key,\n\t\t\t\t\t * with a 30-day acceptance timer.\n\t\t\t\t\t */\n\t\t\t\t\tdeletekey = true;\n\t\t\t\t\tnewkey = true;\n\t\t\t\t\tkeydata.removehd = 0;\n\t\t\t\t\tkeydata.addhd =\n\t\t\t\t\t\tnow + dns_zone_mkey_month;\n\n\t\t\t\t\tdnssec_log(zone, ISC_LOG_INFO,\n\t\t\t\t\t\t   \"Revoked key %d for \"\n\t\t\t\t\t\t   \"zone %s has returned: \"\n\t\t\t\t\t\t   \"starting 30-day \"\n\t\t\t\t\t\t   \"acceptance timer\",\n\t\t\t\t\t\t   keytag, namebuf);\n\t\t\t\t} else if (keydata.addhd > now) {\n\t\t\t\t\tpending++;\n\t\t\t\t} else if (keydata.addhd == 0) {\n\t\t\t\t\tkeydata.addhd = now;\n\t\t\t\t}\n\n\t\t\t\tif (keydata.addhd <= now) {\n\t\t\t\t\ttrustkey = true;\n\t\t\t\t\tdnssec_log(zone, ISC_LOG_INFO,\n\t\t\t\t\t\t   \"Key %d for zone %s \"\n\t\t\t\t\t\t   \"is now trusted (%s)\",\n\t\t\t\t\t\t   keytag, namebuf,\n\t\t\t\t\t\t   initial\n\t\t\t\t\t\t    ? \"initializing key \"\n\t\t\t\t\t\t       \"verified\"\n\t\t\t\t\t\t    : \"acceptance timer \"\n\t\t\t\t\t\t       \"complete\");\n\t\t\t\t}\n\t\t\t} else if (keydata.addhd > now) {\n\t\t\t\t/*\n\t\t\t\t * Not secure, and key is pending:\n\t\t\t\t * reset the acceptance timer\n\t\t\t\t */\n\t\t\t\tpending++;\n\t\t\t\tkeydata.addhd = now + dns_zone_mkey_month;\n\t\t\t\tdnssec_log(zone, ISC_LOG_INFO,\n\t\t\t\t\t   \"Pending key %d \"\n\t\t\t\t\t   \"for zone %s was \"\n\t\t\t\t\t   \"not validated: restarting \"\n\t\t\t\t\t   \"30-day acceptance timer\",\n\t\t\t\t\t   keytag, namebuf);\n\t\t\t}\n\n\t\t\tif (!deletekey && !newkey) {\n\t\t\t\tupdatekey = true;\n\t\t\t}\n\t\t} else if (secure) {\n\t\t\t/*\n\t\t\t * Key wasn't in the key zone but it's\n\t\t\t * revoked now anyway, so just skip it\n\t\t\t */\n\t\t\tif (revoked) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Key wasn't in the key zone: add it */\n\t\t\tnewkey = true;\n\n\t\t\tif (initializing) {\n\t\t\t\tdnssec_log(zone, ISC_LOG_WARNING,\n\t\t\t\t\t   \"Initializing automatic trust \"\n\t\t\t\t\t   \"anchor management for zone '%s'; \"\n\t\t\t\t\t   \"DNSKEY ID %d is now trusted, \"\n\t\t\t\t\t   \"waiving the normal 30-day \"\n\t\t\t\t\t   \"waiting period.\",\n\t\t\t\t\t   namebuf, keytag);\n\t\t\t\ttrustkey = true;\n\t\t\t} else {\n\t\t\t\tdnssec_log(zone, ISC_LOG_INFO,\n\t\t\t\t\t   \"New key %d observed \"\n\t\t\t\t\t   \"for zone '%s': \"\n\t\t\t\t\t   \"starting 30-day \"\n\t\t\t\t\t   \"acceptance timer\",\n\t\t\t\t\t   keytag, namebuf);\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * No previously known key, and the key is not\n\t\t\t * secure, so skip it.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Delete old version */\n\t\tif (deletekey || !newkey) {\n\t\t\tCHECK(update_one_rr(kfetch->db, ver, &diff,\n\t\t\t\t\t    DNS_DIFFOP_DEL, keyname, 0,\n\t\t\t\t\t    &keydatarr));\n\t\t}\n\n\t\tif (updatekey) {\n\t\t\t/* Set refresh timer */\n\t\t\tkeydata.refresh = refresh_time(kfetch, false);\n\t\t\tdns_rdata_reset(&keydatarr);\n\t\t\tisc_buffer_init(&keyb, key_buf, sizeof(key_buf));\n\t\t\tdns_rdata_fromstruct(&keydatarr, zone->rdclass,\n\t\t\t\t\t     dns_rdatatype_keydata,\n\t\t\t\t\t     &keydata, &keyb);\n\n\t\t\t/* Insert updated version */\n\t\t\tCHECK(update_one_rr(kfetch->db, ver, &diff,\n\t\t\t\t\t    DNS_DIFFOP_ADD, keyname, 0,\n\t\t\t\t\t    &keydatarr));\n\t\t} else if (newkey) {\n\t\t\t/* Convert DNSKEY to KEYDATA */\n\t\t\tresult = dns_rdata_tostruct(&dnskeyrr, &dnskey, NULL);\n\t\t\tRUNTIME_CHECK(result == ISC_R_SUCCESS);\n\t\t\tdns_keydata_fromdnskey(&keydata, &dnskey, 0, 0, 0,\n\t\t\t\t\t       NULL);\n\t\t\tkeydata.addhd = initializing\n\t\t\t\t\t ? now : now + dns_zone_mkey_month;\n\t\t\tkeydata.refresh = refresh_time(kfetch, false);\n\t\t\tdns_rdata_reset(&keydatarr);\n\t\t\tisc_buffer_init(&keyb, key_buf, sizeof(key_buf));\n\t\t\tdns_rdata_fromstruct(&keydatarr, zone->rdclass,\n\t\t\t\t\t     dns_rdatatype_keydata,\n\t\t\t\t\t     &keydata, &keyb);\n\n\t\t\t/* Insert into key zone */\n\t\t\tCHECK(update_one_rr(kfetch->db, ver, &diff,\n\t\t\t\t\t    DNS_DIFFOP_ADD, keyname, 0,\n\t\t\t\t\t    &keydatarr));\n\t\t}\n\n\t\tif (trustkey) {\n\t\t\t/* Trust this key. */\n\t\t\tresult = dns_rdata_tostruct(&dnskeyrr, &dnskey, NULL);\n\t\t\tRUNTIME_CHECK(result == ISC_R_SUCCESS);\n\t\t\ttrust_key(zone, keyname, &dnskey, false, mctx);\n\t\t}\n\n\t\tif (secure && !deletekey) {\n\t\t\tINSIST(newkey || updatekey);\n\t\t\tset_refreshkeytimer(zone, &keydata, now, false);\n\t\t}\n\t}\n\n\t/*\n\t * RFC5011 says, \"A trust point that has all of its trust anchors\n\t * revoked is considered deleted and is treated as if the trust\n\t * point was never configured.\"  But if someone revoked their\n\t * active key before the standby was trusted, that would mean the\n\t * zone would suddenly be nonsecured.  We avoid this by checking to\n\t * see if there's pending keydata.  If so, we put a null key in\n\t * the security roots; then all queries to the zone will fail.\n\t */\n\tif (pending != 0) {\n\t\tfail_secure(zone, keyname);\n\t}\n\n done:\n\tif (!ISC_LIST_EMPTY(diff.tuples)) {\n\t\t/* Write changes to journal file. */\n\t\tCHECK(update_soa_serial(kfetch->db, ver, &diff, mctx,\n\t\t\t\t\tzone->updatemethod));\n\t\tCHECK(zone_journal(zone, &diff, NULL, \"keyfetch_done\"));\n\t\tcommit = true;\n\n\t\tDNS_ZONE_SETFLAG(zone, DNS_ZONEFLG_LOADED);\n\t\tzone_needdump(zone, 30);\n\t} else if (result == ISC_R_NOMORE) {\n\t\t/*\n\t\t * If \"updatekey\" was true for all keys found in the DNSKEY\n\t\t * response and the previous update of those keys happened\n\t\t * during the same second (only possible if a key refresh was\n\t\t * externally triggered), it may happen that all relevant\n\t\t * update_one_rr() calls will return ISC_R_SUCCESS, but\n\t\t * diff.tuples will remain empty.  Reset result to\n\t\t * ISC_R_SUCCESS to prevent a bogus warning from being logged.\n\t\t */\n\t\tresult = ISC_R_SUCCESS;\n\t}\n\n failure:\n\tif (result != ISC_R_SUCCESS) {\n\t\tdnssec_log(zone, ISC_LOG_ERROR,\n\t\t\t   \"error during managed-keys processing (%s): \"\n\t\t\t   \"DNSSEC validation may be at risk\",\n\t\t\t   isc_result_totext(result));\n\t}\n\tdns_diff_clear(&diff);\n\tif (ver != NULL) {\n\t\tdns_db_closeversion(kfetch->db, &ver, commit);\n\t}\n\n cleanup:\n\tdns_db_detach(&kfetch->db);\n\n\tINSIST(zone->irefs > 0);\n\tzone->irefs--;\n\tkfetch->zone = NULL;\n\n\tif (dns_rdataset_isassociated(&kfetch->keydataset)) {\n\t\tdns_rdataset_disassociate(&kfetch->keydataset);\n\t}\n\tif (dns_rdataset_isassociated(&kfetch->dnskeyset)) {\n\t\tdns_rdataset_disassociate(&kfetch->dnskeyset);\n\t}\n\tif (dns_rdataset_isassociated(&kfetch->dnskeysigset)) {\n\t\tdns_rdataset_disassociate(&kfetch->dnskeysigset);\n\t}\n\n\tdns_name_free(keyname, mctx);\n\tisc_mem_put(mctx, kfetch, sizeof(dns_keyfetch_t));\n\tisc_mem_detach(&mctx);\n\n\tif (secroots != NULL) {\n\t\tdns_keytable_detach(&secroots);\n\t}\n\n\tfree_needed = exit_check(zone);\n\tUNLOCK_ZONE(zone);\n\tif (free_needed) {\n\t\tzone_free(zone);\n\t}\n\n\tINSIST(ver == NULL);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146844,
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "keyfetch_done(isc_task_t *task, isc_event_t *event) {\n\tisc_result_t result, eresult;\n\tdns_fetchevent_t *devent;\n\tdns_keyfetch_t *kfetch;\n\tdns_zone_t *zone;\n\tisc_mem_t *mctx = NULL;\n\tdns_keytable_t *secroots = NULL;\n\tdns_dbversion_t *ver = NULL;\n\tdns_diff_t diff;\n\tbool alldone = false;\n\tbool commit = false;\n\tdns_name_t *keyname;\n\tdns_rdata_t sigrr = DNS_RDATA_INIT;\n\tdns_rdata_t dnskeyrr = DNS_RDATA_INIT;\n\tdns_rdata_t keydatarr = DNS_RDATA_INIT;\n\tdns_rdata_rrsig_t sig;\n\tdns_rdata_dnskey_t dnskey;\n\tdns_rdata_keydata_t keydata;\n\tbool initializing;\n\tchar namebuf[DNS_NAME_FORMATSIZE];\n\tunsigned char key_buf[4096];\n\tisc_buffer_t keyb;\n\tdst_key_t *dstkey;\n\tisc_stdtime_t now;\n\tint pending = 0;\n\tbool secure = false, initial = false;\n\tbool free_needed;\n\n\tUNUSED(task);\n\tINSIST(event != NULL && event->ev_type == DNS_EVENT_FETCHDONE);\n\tINSIST(event->ev_arg != NULL);\n\n\tkfetch = event->ev_arg;\n\tzone = kfetch->zone;\n\tisc_mem_attach(zone->mctx, &mctx);\n\tkeyname = dns_fixedname_name(&kfetch->name);\n\n\tdevent = (dns_fetchevent_t *) event;\n\teresult = devent->result;\n\n\t/* Free resources which are not of interest */\n\tif (devent->node != NULL) {\n\t\tdns_db_detachnode(devent->db, &devent->node);\n\t}\n\tif (devent->db != NULL) {\n\t\tdns_db_detach(&devent->db);\n\t}\n\tisc_event_free(&event);\n\tdns_resolver_destroyfetch(&kfetch->fetch);\n\n\tLOCK_ZONE(zone);\n\tif (DNS_ZONE_FLAG(zone, DNS_ZONEFLG_EXITING) || zone->view == NULL) {\n\t\tgoto cleanup;\n\t}\n\n\tisc_stdtime_get(&now);\n\tdns_name_format(keyname, namebuf, sizeof(namebuf));\n\n\tresult = dns_view_getsecroots(zone->view, &secroots);\n\tINSIST(result == ISC_R_SUCCESS);\n\n\tdns_diff_init(mctx, &diff);\n\n\tCHECK(dns_db_newversion(kfetch->db, &ver));\n\n\tzone->refreshkeycount--;\n\talldone = (zone->refreshkeycount == 0);\n\n\tif (alldone) {\n\t\tDNS_ZONE_CLRFLAG(zone, DNS_ZONEFLG_REFRESHING);\n\t}\n\n\tdnssec_log(zone, ISC_LOG_DEBUG(3),\n\t\t   \"Returned from key fetch in keyfetch_done() for '%s': %s\",\n\t\t   namebuf, dns_result_totext(eresult));\n\n\t/* Fetch failed */\n\tif (eresult != ISC_R_SUCCESS ||\n\t    !dns_rdataset_isassociated(&kfetch->dnskeyset))\n\t{\n\t\tdnssec_log(zone, ISC_LOG_WARNING,\n\t\t\t   \"Unable to fetch DNSKEY set '%s': %s\",\n\t\t\t   namebuf, dns_result_totext(eresult));\n\t\tCHECK(minimal_update(kfetch, ver, &diff));\n\t\tgoto done;\n\t}\n\n\t/* No RRSIGs found */\n\tif (!dns_rdataset_isassociated(&kfetch->dnskeysigset)) {\n\t\tdnssec_log(zone, ISC_LOG_WARNING,\n\t\t\t   \"No DNSKEY RRSIGs found for '%s': %s\",\n\t\t\t   namebuf, dns_result_totext(eresult));\n\t\tCHECK(minimal_update(kfetch, ver, &diff));\n\t\tgoto done;\n\t}\n\n\t/*\n\t * Clear any cached trust level, as we need to run validation\n\t * over again; trusted keys might have changed.\n\t */\n\tkfetch->dnskeyset.trust = kfetch->dnskeysigset.trust = dns_trust_none;\n\n\t/*\n\t * Validate the dnskeyset against the current trusted keys.\n\t */\n\tfor (result = dns_rdataset_first(&kfetch->dnskeysigset);\n\t     result == ISC_R_SUCCESS;\n\t     result = dns_rdataset_next(&kfetch->dnskeysigset))\n\t{\n\t\tdns_keynode_t *keynode = NULL;\n\n\t\tdns_rdata_reset(&sigrr);\n\t\tdns_rdataset_current(&kfetch->dnskeysigset, &sigrr);\n\t\tresult = dns_rdata_tostruct(&sigrr, &sig, NULL);\n\t\tRUNTIME_CHECK(result == ISC_R_SUCCESS);\n\n\t\tresult = dns_keytable_find(secroots, keyname, &keynode);\n\t\twhile (result == ISC_R_SUCCESS) {\n\t\t\tdns_keynode_t *nextnode = NULL;\n\t\t\tdns_fixedname_t fixed;\n\t\t\tdns_fixedname_init(&fixed);\n\n\t\t\tdstkey = dns_keynode_key(keynode);\n\t\t\tif (dstkey == NULL) {\n\t\t\t\t/* fail_secure() was called */\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (dst_key_alg(dstkey) == sig.algorithm &&\n\t\t\t    dst_key_id(dstkey) == sig.keyid)\n\t\t\t{\n\t\t\t\tresult = dns_dnssec_verify(keyname,\n\t\t\t\t\t\t\t   &kfetch->dnskeyset,\n\t\t\t\t\t\t\t   dstkey, false,\n\t\t\t\t\t\t\t   0,\n\t\t\t\t\t\t\t   zone->view->mctx,\n\t\t\t\t\t\t\t   &sigrr,\n\t\t\t\t\t\t\t   dns_fixedname_name(\n\t\t\t\t\t\t\t   &fixed));\n\n\t\t\t\tdnssec_log(zone, ISC_LOG_DEBUG(3),\n\t\t\t\t\t   \"Verifying DNSKEY set for zone \"\n\t\t\t\t\t   \"'%s' using key %d/%d: %s\",\n\t\t\t\t\t   namebuf, sig.keyid, sig.algorithm,\n\t\t\t\t\t   dns_result_totext(result));\n\n\t\t\t\tif (result == ISC_R_SUCCESS) {\n\t\t\t\t\tkfetch->dnskeyset.trust =\n\t\t\t\t\t\tdns_trust_secure;\n\t\t\t\t\tkfetch->dnskeysigset.trust =\n\t\t\t\t\t\tdns_trust_secure;\n\t\t\t\t\tsecure = true;\n\t\t\t\t\tinitial = dns_keynode_initial(keynode);\n\t\t\t\t\tdns_keynode_trust(keynode);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresult = dns_keytable_nextkeynode(secroots,\n\t\t\t\t\t\t\t  keynode, &nextnode);\n\t\t\tdns_keytable_detachkeynode(secroots, &keynode);\n\t\t\tkeynode = nextnode;\n\t\t}\n\n\t\tif (keynode != NULL) {\n\t\t\tdns_keytable_detachkeynode(secroots, &keynode);\n\t\t}\n\n\t\tif (secure) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * If we were not able to verify the answer using the current\n\t * trusted keys then all we can do is look at any revoked keys.\n\t */\n\tif (!secure) {\n\t\tdnssec_log(zone, ISC_LOG_INFO,\n\t\t\t   \"DNSKEY set for zone '%s' could not be verified \"\n\t\t\t   \"with current keys\", namebuf);\n\t}\n\n\t/*\n\t * First scan keydataset to find keys that are not in dnskeyset\n\t *   - Missing keys which are not scheduled for removal,\n\t *     log a warning\n\t *   - Missing keys which are scheduled for removal and\n\t *     the remove hold-down timer has completed should\n\t *     be removed from the key zone\n\t *   - Missing keys whose acceptance timers have not yet\n\t *     completed, log a warning and reset the acceptance\n\t *     timer to 30 days in the future\n\t *   - All keys not being removed have their refresh timers\n\t *     updated\n\t */\n\tinitializing = true;\n\tfor (result = dns_rdataset_first(&kfetch->keydataset);\n\t     result == ISC_R_SUCCESS;\n\t     result = dns_rdataset_next(&kfetch->keydataset))\n\t{\n\t\tdns_keytag_t keytag;\n\n\t\tdns_rdata_reset(&keydatarr);\n\t\tdns_rdataset_current(&kfetch->keydataset, &keydatarr);\n\t\tresult = dns_rdata_tostruct(&keydatarr, &keydata, NULL);\n\t\tRUNTIME_CHECK(result == ISC_R_SUCCESS);\n\n\t\tdns_keydata_todnskey(&keydata, &dnskey, NULL);\n\t\tresult = compute_tag(keyname, &dnskey, mctx, &keytag);\n\t\tif (result != ISC_R_SUCCESS) {\n\t\t\t/*\n\t\t\t * Skip if we cannot compute the key tag.\n\t\t\t * This may happen if the algorithm is unsupported\n\t\t\t */\n\t\t\tdns_zone_log(zone, ISC_LOG_ERROR,\n\t\t\t\t\"Cannot compute tag for key in zone %s: %s \"\n\t\t\t\t\"(skipping)\",\n\t\t\t\tnamebuf, dns_result_totext(result));\n\t\t\tcontinue;\n\t\t}\n\t\tRUNTIME_CHECK(result == ISC_R_SUCCESS);\n\n\t\t/*\n\t\t * If any keydata record has a nonzero add holddown, then\n\t\t * there was a pre-existing trust anchor for this domain;\n\t\t * that means we are *not* initializing it and shouldn't\n\t\t * automatically trust all the keys we find at the zone apex.\n\t\t */\n\t\tinitializing = initializing && (keydata.addhd == 0);\n\n\t\tif (! matchkey(&kfetch->dnskeyset, &keydatarr)) {\n\t\t\tbool deletekey = false;\n\n\t\t\tif (!secure) {\n\t\t\t\tif (keydata.removehd != 0 &&\n\t\t\t\t    keydata.removehd <= now)\n\t\t\t\t{\n\t\t\t\t\tdeletekey = true;\n\t\t\t\t}\n\t\t\t} else if (keydata.addhd == 0) {\n\t\t\t\tdeletekey = true;\n\t\t\t} else if (keydata.addhd > now) {\n\t\t\t\tdnssec_log(zone, ISC_LOG_INFO,\n\t\t\t\t\t   \"Pending key %d for zone %s \"\n\t\t\t\t\t   \"unexpectedly missing \"\n\t\t\t\t\t   \"restarting 30-day acceptance \"\n\t\t\t\t\t   \"timer\", keytag, namebuf);\n\t\t\t\tif (keydata.addhd < now + dns_zone_mkey_month) {\n\t\t\t\t\tkeydata.addhd =\n\t\t\t\t\t\tnow + dns_zone_mkey_month;\n\t\t\t\t}\n\t\t\t\tkeydata.refresh = refresh_time(kfetch, false);\n\t\t\t} else if (keydata.removehd == 0) {\n\t\t\t\tdnssec_log(zone, ISC_LOG_INFO,\n\t\t\t\t\t   \"Active key %d for zone %s \"\n\t\t\t\t\t   \"unexpectedly missing\",\n\t\t\t\t\t   keytag, namebuf);\n\t\t\t\tkeydata.refresh = now + dns_zone_mkey_hour;\n\t\t\t} else if (keydata.removehd <= now) {\n\t\t\t\tdeletekey = true;\n\t\t\t\tdnssec_log(zone, ISC_LOG_INFO,\n\t\t\t\t\t   \"Revoked key %d for zone %s \"\n\t\t\t\t\t   \"missing: deleting from \"\n\t\t\t\t\t   \"managed keys database\",\n\t\t\t\t\t   keytag, namebuf);\n\t\t\t} else {\n\t\t\t\tkeydata.refresh = refresh_time(kfetch, false);\n\t\t\t}\n\n\t\t\tif (secure || deletekey) {\n\t\t\t\t/* Delete old version */\n\t\t\t\tCHECK(update_one_rr(kfetch->db, ver, &diff,\n\t\t\t\t\t\t    DNS_DIFFOP_DEL, keyname, 0,\n\t\t\t\t\t\t    &keydatarr));\n\t\t\t}\n\n\t\t\tif (!secure || deletekey) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdns_rdata_reset(&keydatarr);\n\t\t\tisc_buffer_init(&keyb, key_buf, sizeof(key_buf));\n\t\t\tdns_rdata_fromstruct(&keydatarr, zone->rdclass,\n\t\t\t\t\t     dns_rdatatype_keydata,\n\t\t\t\t\t     &keydata, &keyb);\n\n\t\t\t/* Insert updated version */\n\t\t\tCHECK(update_one_rr(kfetch->db, ver, &diff,\n\t\t\t\t\t    DNS_DIFFOP_ADD, keyname, 0,\n\t\t\t\t\t    &keydatarr));\n\n\t\t\tset_refreshkeytimer(zone, &keydata, now, false);\n\t\t}\n\t}\n\n\t/*\n\t * Next scan dnskeyset:\n\t *   - If new keys are found (i.e., lacking a match in keydataset)\n\t *     add them to the key zone and set the acceptance timer\n\t *     to 30 days in the future (or to immediately if we've\n\t *     determined that we're initializing the zone for the\n\t *     first time)\n\t *   - Previously-known keys that have been revoked\n\t *     must be scheduled for removal from the key zone (or,\n\t *     if they hadn't been accepted as trust anchors yet\n\t *     anyway, removed at once)\n\t *   - Previously-known unrevoked keys whose acceptance timers\n\t *     have completed are promoted to trust anchors\n\t *   - All keys not being removed have their refresh\n\t *     timers updated\n\t */\n\tfor (result = dns_rdataset_first(&kfetch->dnskeyset);\n\t     result == ISC_R_SUCCESS;\n\t     result = dns_rdataset_next(&kfetch->dnskeyset))\n\t{\n\t\tbool revoked = false;\n\t\tbool newkey = false;\n\t\tbool updatekey = false;\n\t\tbool deletekey = false;\n\t\tbool trustkey = false;\n\t\tdns_keytag_t keytag;\n\n\t\tdns_rdata_reset(&dnskeyrr);\n\t\tdns_rdataset_current(&kfetch->dnskeyset, &dnskeyrr);\n\t\tresult = dns_rdata_tostruct(&dnskeyrr, &dnskey, NULL);\n\t\tRUNTIME_CHECK(result == ISC_R_SUCCESS);\n\n\t\t/* Skip ZSK's */\n\t\tif ((dnskey.flags & DNS_KEYFLAG_KSK) == 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tresult = compute_tag(keyname, &dnskey, mctx, &keytag);\n\t\tif (result != ISC_R_SUCCESS) {\n\t\t\t/*\n\t\t\t * Skip if we cannot compute the key tag.\n\t\t\t * This may happen if the algorithm is unsupported\n\t\t\t */\n\t\t\tdns_zone_log(zone, ISC_LOG_ERROR,\n\t\t\t\t\"Cannot compute tag for key in zone %s: %s \"\n\t\t\t\t\"(skipping)\",\n\t\t\t\tnamebuf, dns_result_totext(result));\n\t\t\tcontinue;\n\t\t}\n\t\tRUNTIME_CHECK(result == ISC_R_SUCCESS);\n\n\t\trevoked = ((dnskey.flags & DNS_KEYFLAG_REVOKE) != 0);\n\n\t\tif (matchkey(&kfetch->keydataset, &dnskeyrr)) {\n\t\t\tdns_rdata_reset(&keydatarr);\n\t\t\tdns_rdataset_current(&kfetch->keydataset, &keydatarr);\n\t\t\tresult = dns_rdata_tostruct(&keydatarr, &keydata, NULL);\n\t\t\tRUNTIME_CHECK(result == ISC_R_SUCCESS);\n\n\t\t\tif (revoked && revocable(kfetch, &keydata)) {\n\t\t\t\tif (keydata.addhd > now) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Key wasn't trusted yet, and now\n\t\t\t\t\t * it's been revoked?  Just remove it\n\t\t\t\t\t */\n\t\t\t\t\tdeletekey = true;\n\t\t\t\t\tdnssec_log(zone, ISC_LOG_INFO,\n\t\t\t\t\t\t   \"Pending key %d for \"\n\t\t\t\t\t\t   \"zone %s is now revoked: \"\n\t\t\t\t\t\t   \"deleting from the \"\n\t\t\t\t\t\t   \"managed keys database\",\n\t\t\t\t\t\t   keytag, namebuf);\n\t\t\t\t} else if (keydata.removehd == 0) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Remove key from secroots.\n\t\t\t\t\t */\n\t\t\t\t\tdns_view_untrust(zone->view, keyname,\n\t\t\t\t\t\t\t &dnskey, mctx);\n\n\t\t\t\t\t/* If initializing, delete now */\n\t\t\t\t\tif (keydata.addhd == 0) {\n\t\t\t\t\t\tdeletekey = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tkeydata.removehd = now +\n\t\t\t\t\t\t\tdns_zone_mkey_month;\n\t\t\t\t\t\tkeydata.flags |=\n\t\t\t\t\t\t\tDNS_KEYFLAG_REVOKE;\n\t\t\t\t\t}\n\n\t\t\t\t\tdnssec_log(zone, ISC_LOG_INFO,\n\t\t\t\t\t\t   \"Trusted key %d for \"\n\t\t\t\t\t\t   \"zone %s is now revoked\",\n\t\t\t\t\t\t   keytag, namebuf);\n\t\t\t\t} else if (keydata.removehd < now) {\n\t\t\t\t\t/* Scheduled for removal */\n\t\t\t\t\tdeletekey = true;\n\n\t\t\t\t\tdnssec_log(zone, ISC_LOG_INFO,\n\t\t\t\t\t\t   \"Revoked key %d for \"\n\t\t\t\t\t\t   \"zone %s removal timer \"\n\t\t\t\t\t\t   \"complete: deleting from \"\n\t\t\t\t\t\t   \"the managed keys database\",\n\t\t\t\t\t\t   keytag, namebuf);\n\t\t\t\t}\n\t\t\t} else if (revoked && keydata.removehd == 0) {\n\t\t\t\tdnssec_log(zone, ISC_LOG_WARNING,\n\t\t\t\t\t   \"Active key %d for zone \"\n\t\t\t\t\t   \"%s is revoked but \"\n\t\t\t\t\t   \"did not self-sign; \"\n\t\t\t\t\t   \"ignoring\", keytag, namebuf);\n\t\t\t\tcontinue;\n\t\t\t} else if (secure) {\n\t\t\t\tif (keydata.removehd != 0) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Key isn't revoked--but it\n\t\t\t\t\t * seems it used to be.\n\t\t\t\t\t * Remove it now and add it\n\t\t\t\t\t * back as if it were a fresh key,\n\t\t\t\t\t * with a 30-day acceptance timer.\n\t\t\t\t\t */\n\t\t\t\t\tdeletekey = true;\n\t\t\t\t\tnewkey = true;\n\t\t\t\t\tkeydata.removehd = 0;\n\t\t\t\t\tkeydata.addhd =\n\t\t\t\t\t\tnow + dns_zone_mkey_month;\n\n\t\t\t\t\tdnssec_log(zone, ISC_LOG_INFO,\n\t\t\t\t\t\t   \"Revoked key %d for \"\n\t\t\t\t\t\t   \"zone %s has returned: \"\n\t\t\t\t\t\t   \"starting 30-day \"\n\t\t\t\t\t\t   \"acceptance timer\",\n\t\t\t\t\t\t   keytag, namebuf);\n\t\t\t\t} else if (keydata.addhd > now) {\n\t\t\t\t\tpending++;\n\t\t\t\t} else if (keydata.addhd == 0) {\n\t\t\t\t\tkeydata.addhd = now;\n\t\t\t\t}\n\n\t\t\t\tif (keydata.addhd <= now) {\n\t\t\t\t\ttrustkey = true;\n\t\t\t\t\tdnssec_log(zone, ISC_LOG_INFO,\n\t\t\t\t\t\t   \"Key %d for zone %s \"\n\t\t\t\t\t\t   \"is now trusted (%s)\",\n\t\t\t\t\t\t   keytag, namebuf,\n\t\t\t\t\t\t   initial\n\t\t\t\t\t\t    ? \"initializing key \"\n\t\t\t\t\t\t       \"verified\"\n\t\t\t\t\t\t    : \"acceptance timer \"\n\t\t\t\t\t\t       \"complete\");\n\t\t\t\t}\n\t\t\t} else if (keydata.addhd > now) {\n\t\t\t\t/*\n\t\t\t\t * Not secure, and key is pending:\n\t\t\t\t * reset the acceptance timer\n\t\t\t\t */\n\t\t\t\tpending++;\n\t\t\t\tkeydata.addhd = now + dns_zone_mkey_month;\n\t\t\t\tdnssec_log(zone, ISC_LOG_INFO,\n\t\t\t\t\t   \"Pending key %d \"\n\t\t\t\t\t   \"for zone %s was \"\n\t\t\t\t\t   \"not validated: restarting \"\n\t\t\t\t\t   \"30-day acceptance timer\",\n\t\t\t\t\t   keytag, namebuf);\n\t\t\t}\n\n\t\t\tif (!deletekey && !newkey) {\n\t\t\t\tupdatekey = true;\n\t\t\t}\n\t\t} else if (secure) {\n\t\t\t/*\n\t\t\t * Key wasn't in the key zone but it's\n\t\t\t * revoked now anyway, so just skip it\n\t\t\t */\n\t\t\tif (revoked) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Key wasn't in the key zone: add it */\n\t\t\tnewkey = true;\n\n\t\t\tif (initializing) {\n\t\t\t\tdnssec_log(zone, ISC_LOG_WARNING,\n\t\t\t\t\t   \"Initializing automatic trust \"\n\t\t\t\t\t   \"anchor management for zone '%s'; \"\n\t\t\t\t\t   \"DNSKEY ID %d is now trusted, \"\n\t\t\t\t\t   \"waiving the normal 30-day \"\n\t\t\t\t\t   \"waiting period.\",\n\t\t\t\t\t   namebuf, keytag);\n\t\t\t\ttrustkey = true;\n\t\t\t} else {\n\t\t\t\tdnssec_log(zone, ISC_LOG_INFO,\n\t\t\t\t\t   \"New key %d observed \"\n\t\t\t\t\t   \"for zone '%s': \"\n\t\t\t\t\t   \"starting 30-day \"\n\t\t\t\t\t   \"acceptance timer\",\n\t\t\t\t\t   keytag, namebuf);\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * No previously known key, and the key is not\n\t\t\t * secure, so skip it.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Delete old version */\n\t\tif (deletekey || !newkey) {\n\t\t\tCHECK(update_one_rr(kfetch->db, ver, &diff,\n\t\t\t\t\t    DNS_DIFFOP_DEL, keyname, 0,\n\t\t\t\t\t    &keydatarr));\n\t\t}\n\n\t\tif (updatekey) {\n\t\t\t/* Set refresh timer */\n\t\t\tkeydata.refresh = refresh_time(kfetch, false);\n\t\t\tdns_rdata_reset(&keydatarr);\n\t\t\tisc_buffer_init(&keyb, key_buf, sizeof(key_buf));\n\t\t\tdns_rdata_fromstruct(&keydatarr, zone->rdclass,\n\t\t\t\t\t     dns_rdatatype_keydata,\n\t\t\t\t\t     &keydata, &keyb);\n\n\t\t\t/* Insert updated version */\n\t\t\tCHECK(update_one_rr(kfetch->db, ver, &diff,\n\t\t\t\t\t    DNS_DIFFOP_ADD, keyname, 0,\n\t\t\t\t\t    &keydatarr));\n\t\t} else if (newkey) {\n\t\t\t/* Convert DNSKEY to KEYDATA */\n\t\t\tresult = dns_rdata_tostruct(&dnskeyrr, &dnskey, NULL);\n\t\t\tRUNTIME_CHECK(result == ISC_R_SUCCESS);\n\t\t\tdns_keydata_fromdnskey(&keydata, &dnskey, 0, 0, 0,\n\t\t\t\t\t       NULL);\n\t\t\tkeydata.addhd = initializing\n\t\t\t\t\t ? now : now + dns_zone_mkey_month;\n\t\t\tkeydata.refresh = refresh_time(kfetch, false);\n\t\t\tdns_rdata_reset(&keydatarr);\n\t\t\tisc_buffer_init(&keyb, key_buf, sizeof(key_buf));\n\t\t\tdns_rdata_fromstruct(&keydatarr, zone->rdclass,\n\t\t\t\t\t     dns_rdatatype_keydata,\n\t\t\t\t\t     &keydata, &keyb);\n\n\t\t\t/* Insert into key zone */\n\t\t\tCHECK(update_one_rr(kfetch->db, ver, &diff,\n\t\t\t\t\t    DNS_DIFFOP_ADD, keyname, 0,\n\t\t\t\t\t    &keydatarr));\n\t\t}\n\n\t\tif (trustkey) {\n\t\t\t/* Trust this key. */\n\t\t\tresult = dns_rdata_tostruct(&dnskeyrr, &dnskey, NULL);\n\t\t\tRUNTIME_CHECK(result == ISC_R_SUCCESS);\n\t\t\ttrust_key(zone, keyname, &dnskey, false, mctx);\n\t\t}\n\n\t\tif (secure && !deletekey) {\n\t\t\tINSIST(newkey || updatekey);\n\t\t\tset_refreshkeytimer(zone, &keydata, now, false);\n\t\t}\n\t}\n\n\t/*\n\t * RFC5011 says, \"A trust point that has all of its trust anchors\n\t * revoked is considered deleted and is treated as if the trust\n\t * point was never configured.\"  But if someone revoked their\n\t * active key before the standby was trusted, that would mean the\n\t * zone would suddenly be nonsecured.  We avoid this by checking to\n\t * see if there's pending keydata.  If so, we put a null key in\n\t * the security roots; then all queries to the zone will fail.\n\t */\n\tif (pending != 0) {\n\t\tfail_secure(zone, keyname);\n\t}\n\n done:\n\tif (!ISC_LIST_EMPTY(diff.tuples)) {\n\t\t/* Write changes to journal file. */\n\t\tCHECK(update_soa_serial(kfetch->db, ver, &diff, mctx,\n\t\t\t\t\tzone->updatemethod));\n\t\tCHECK(zone_journal(zone, &diff, NULL, \"keyfetch_done\"));\n\t\tcommit = true;\n\n\t\tDNS_ZONE_SETFLAG(zone, DNS_ZONEFLG_LOADED);\n\t\tzone_needdump(zone, 30);\n\t} else if (result == ISC_R_NOMORE) {\n\t\t/*\n\t\t * If \"updatekey\" was true for all keys found in the DNSKEY\n\t\t * response and the previous update of those keys happened\n\t\t * during the same second (only possible if a key refresh was\n\t\t * externally triggered), it may happen that all relevant\n\t\t * update_one_rr() calls will return ISC_R_SUCCESS, but\n\t\t * diff.tuples will remain empty.  Reset result to\n\t\t * ISC_R_SUCCESS to prevent a bogus warning from being logged.\n\t\t */\n\t\tresult = ISC_R_SUCCESS;\n\t}\n\n failure:\n\tif (result != ISC_R_SUCCESS) {\n\t\tdnssec_log(zone, ISC_LOG_ERROR,\n\t\t\t   \"error during managed-keys processing (%s): \"\n\t\t\t   \"DNSSEC validation may be at risk\",\n\t\t\t   isc_result_totext(result));\n\t}\n\tdns_diff_clear(&diff);\n\tif (ver != NULL) {\n\t\tdns_db_closeversion(kfetch->db, &ver, commit);\n\t}\n\n cleanup:\n\tdns_db_detach(&kfetch->db);\n\n\tINSIST(zone->irefs > 0);\n\tzone->irefs--;\n\tkfetch->zone = NULL;\n\n\tif (dns_rdataset_isassociated(&kfetch->keydataset)) {\n\t\tdns_rdataset_disassociate(&kfetch->keydataset);\n\t}\n\tif (dns_rdataset_isassociated(&kfetch->dnskeyset)) {\n\t\tdns_rdataset_disassociate(&kfetch->dnskeyset);\n\t}\n\tif (dns_rdataset_isassociated(&kfetch->dnskeysigset)) {\n\t\tdns_rdataset_disassociate(&kfetch->dnskeysigset);\n\t}\n\n\tdns_name_free(keyname, mctx);\n\tisc_mem_put(mctx, kfetch, sizeof(dns_keyfetch_t));\n\tisc_mem_detach(&mctx);\n\n\tif (secroots != NULL) {\n\t\tdns_keytable_detach(&secroots);\n\t}\n\n\tfree_needed = exit_check(zone);\n\tUNLOCK_ZONE(zone);\n\tif (free_needed) {\n\t\tzone_free(zone);\n\t}\n\n\tINSIST(ver == NULL);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146845,
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "static bool l2cap_check_enc_key_size(struct hci_conn *hcon)\n{\n\t/* The minimum encryption key size needs to be enforced by the\n\t * host stack before establishing any L2CAP connections. The\n\t * specification in theory allows a minimum of 1, but to align\n\t * BR/EDR and LE transports, a minimum of 7 is chosen.\n\t *\n\t * This check might also be called for unencrypted connections\n\t * that have no key size requirements. Ensure that the link is\n\t * actually encrypted before enforcing a key size.\n\t */\n\treturn (!test_bit(HCI_CONN_ENCRYPT, &hcon->flags) ||\n\t\thcon->enc_key_size > HCI_MIN_ENC_KEY_SIZE);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148696,
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  },
  {
    "CWE_ID": [
      "CWE-327"
    ],
    "code": "static bool l2cap_check_enc_key_size(struct hci_conn *hcon)\n{\n\t/* The minimum encryption key size needs to be enforced by the\n\t * host stack before establishing any L2CAP connections. The\n\t * specification in theory allows a minimum of 1, but to align\n\t * BR/EDR and LE transports, a minimum of 7 is chosen.\n\t *\n\t * This check might also be called for unencrypted connections\n\t * that have no key size requirements. Ensure that the link is\n\t * actually encrypted before enforcing a key size.\n\t */\n\treturn (!test_bit(HCI_CONN_ENCRYPT, &hcon->flags) ||\n\t\thcon->enc_key_size >= HCI_MIN_ENC_KEY_SIZE);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148697,
    "RELATED_CWE": [
      "CWE-798",
      "CWE-522",
      "CWE-306"
    ]
  }
]