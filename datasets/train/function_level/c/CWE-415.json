[
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "get_cdtext_generic (void *p_user_data)\n{\n  generic_img_private_t *p_env = p_user_data;\n  uint8_t *p_cdtext_data = NULL;\n  size_t  len;\n\n  if (!p_env) return NULL;\n\n  if (p_env->b_cdtext_error) return NULL;\n\n  if (NULL == p_env->cdtext) {\n    p_cdtext_data = read_cdtext_generic (p_env);\n\n    if (NULL != p_cdtext_data) {\n      len = CDIO_MMC_GET_LEN16(p_cdtext_data)-2;\n      p_env->cdtext = cdtext_init();\n \n       if(len <= 0 || 0 != cdtext_data_init (p_env->cdtext, &p_cdtext_data[4], len)) {\n         p_env->b_cdtext_error = true;\n        cdtext_destroy (p_env->cdtext);\n         free(p_env->cdtext);\n         p_env->cdtext = NULL;\n       }\n      }\n\n      free(p_cdtext_data);\n    }\n  }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141637,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "get_cdtext_generic (void *p_user_data)\n{\n  generic_img_private_t *p_env = p_user_data;\n  uint8_t *p_cdtext_data = NULL;\n  size_t  len;\n\n  if (!p_env) return NULL;\n\n  if (p_env->b_cdtext_error) return NULL;\n\n  if (NULL == p_env->cdtext) {\n    p_cdtext_data = read_cdtext_generic (p_env);\n\n    if (NULL != p_cdtext_data) {\n      len = CDIO_MMC_GET_LEN16(p_cdtext_data)-2;\n      p_env->cdtext = cdtext_init();\n \n       if(len <= 0 || 0 != cdtext_data_init (p_env->cdtext, &p_cdtext_data[4], len)) {\n         p_env->b_cdtext_error = true;\n         free(p_env->cdtext);\n         p_env->cdtext = NULL;\n       }\n      }\n\n      free(p_cdtext_data);\n    }\n  }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 141638,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "static int netlink_dump(struct sock *sk)\n{\n\tstruct netlink_sock *nlk = nlk_sk(sk);\n \tstruct netlink_callback *cb;\n \tstruct sk_buff *skb = NULL;\n \tstruct nlmsghdr *nlh;\n \tint len, err = -ENOBUFS;\n \tint alloc_min_size;\n \tint alloc_size;\n\n\tmutex_lock(nlk->cb_mutex);\n\tif (!nlk->cb_running) {\n\t\terr = -EINVAL;\n\t\tgoto errout_skb;\n\t}\n\n\tif (atomic_read(&sk->sk_rmem_alloc) >= sk->sk_rcvbuf)\n\t\tgoto errout_skb;\n\n\t/* NLMSG_GOODSIZE is small to avoid high order allocations being\n\t * required, but it makes sense to _attempt_ a 16K bytes allocation\n\t * to reduce number of system calls on dump operations, if user\n\t * ever provided a big enough buffer.\n\t */\n\tcb = &nlk->cb;\n\talloc_min_size = max_t(int, cb->min_dump_alloc, NLMSG_GOODSIZE);\n\n\tif (alloc_min_size < nlk->max_recvmsg_len) {\n\t\talloc_size = nlk->max_recvmsg_len;\n\t\tskb = alloc_skb(alloc_size, GFP_KERNEL |\n\t\t\t\t\t    __GFP_NOWARN | __GFP_NORETRY);\n\t}\n\tif (!skb) {\n\t\talloc_size = alloc_min_size;\n\t\tskb = alloc_skb(alloc_size, GFP_KERNEL);\n\t}\n\tif (!skb)\n\t\tgoto errout_skb;\n\n\t/* Trim skb to allocated size. User is expected to provide buffer as\n\t * large as max(min_dump_alloc, 16KiB (mac_recvmsg_len capped at\n\t * netlink_recvmsg())). dump will pack as many smaller messages as\n\t * could fit within the allocated skb. skb is typically allocated\n\t * with larger space than required (could be as much as near 2x the\n\t * requested size with align to next power of 2 approach). Allowing\n\t * dump to use the excess space makes it difficult for a user to have a\n\t * reasonable static buffer based on the expected largest dump of a\n\t * single netdev. The outcome is MSG_TRUNC error.\n\t */\n\tskb_reserve(skb, skb_tailroom(skb) - alloc_size);\n\tnetlink_skb_set_owner_r(skb, sk);\n\n\tlen = cb->dump(skb, cb);\n\n\tif (len > 0) {\n\t\tmutex_unlock(nlk->cb_mutex);\n\n\t\tif (sk_filter(sk, skb))\n\t\t\tkfree_skb(skb);\n\t\telse\n\t\t\t__netlink_sendskb(sk, skb);\n\t\treturn 0;\n\t}\n\n\tnlh = nlmsg_put_answer(skb, cb, NLMSG_DONE, sizeof(len), NLM_F_MULTI);\n\tif (!nlh)\n\t\tgoto errout_skb;\n\n\tnl_dump_check_consistent(cb, nlh);\n\n\tmemcpy(nlmsg_data(nlh), &len, sizeof(len));\n\n\tif (sk_filter(sk, skb))\n\t\tkfree_skb(skb);\n\telse\n\t\t__netlink_sendskb(sk, skb);\n\n\tif (cb->done)\n \t\tcb->done(cb);\n \n \tnlk->cb_running = false;\n \tmutex_unlock(nlk->cb_mutex);\n\tmodule_put(cb->module);\n\tconsume_skb(cb->skb);\n \treturn 0;\n \n errout_skb:\n\tmutex_unlock(nlk->cb_mutex);\n\tkfree_skb(skb);\n\treturn err;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142031,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "static int netlink_dump(struct sock *sk)\n{\n\tstruct netlink_sock *nlk = nlk_sk(sk);\n \tstruct netlink_callback *cb;\n \tstruct sk_buff *skb = NULL;\n \tstruct nlmsghdr *nlh;\n\tstruct module *module;\n \tint len, err = -ENOBUFS;\n \tint alloc_min_size;\n \tint alloc_size;\n\n\tmutex_lock(nlk->cb_mutex);\n\tif (!nlk->cb_running) {\n\t\terr = -EINVAL;\n\t\tgoto errout_skb;\n\t}\n\n\tif (atomic_read(&sk->sk_rmem_alloc) >= sk->sk_rcvbuf)\n\t\tgoto errout_skb;\n\n\t/* NLMSG_GOODSIZE is small to avoid high order allocations being\n\t * required, but it makes sense to _attempt_ a 16K bytes allocation\n\t * to reduce number of system calls on dump operations, if user\n\t * ever provided a big enough buffer.\n\t */\n\tcb = &nlk->cb;\n\talloc_min_size = max_t(int, cb->min_dump_alloc, NLMSG_GOODSIZE);\n\n\tif (alloc_min_size < nlk->max_recvmsg_len) {\n\t\talloc_size = nlk->max_recvmsg_len;\n\t\tskb = alloc_skb(alloc_size, GFP_KERNEL |\n\t\t\t\t\t    __GFP_NOWARN | __GFP_NORETRY);\n\t}\n\tif (!skb) {\n\t\talloc_size = alloc_min_size;\n\t\tskb = alloc_skb(alloc_size, GFP_KERNEL);\n\t}\n\tif (!skb)\n\t\tgoto errout_skb;\n\n\t/* Trim skb to allocated size. User is expected to provide buffer as\n\t * large as max(min_dump_alloc, 16KiB (mac_recvmsg_len capped at\n\t * netlink_recvmsg())). dump will pack as many smaller messages as\n\t * could fit within the allocated skb. skb is typically allocated\n\t * with larger space than required (could be as much as near 2x the\n\t * requested size with align to next power of 2 approach). Allowing\n\t * dump to use the excess space makes it difficult for a user to have a\n\t * reasonable static buffer based on the expected largest dump of a\n\t * single netdev. The outcome is MSG_TRUNC error.\n\t */\n\tskb_reserve(skb, skb_tailroom(skb) - alloc_size);\n\tnetlink_skb_set_owner_r(skb, sk);\n\n\tlen = cb->dump(skb, cb);\n\n\tif (len > 0) {\n\t\tmutex_unlock(nlk->cb_mutex);\n\n\t\tif (sk_filter(sk, skb))\n\t\t\tkfree_skb(skb);\n\t\telse\n\t\t\t__netlink_sendskb(sk, skb);\n\t\treturn 0;\n\t}\n\n\tnlh = nlmsg_put_answer(skb, cb, NLMSG_DONE, sizeof(len), NLM_F_MULTI);\n\tif (!nlh)\n\t\tgoto errout_skb;\n\n\tnl_dump_check_consistent(cb, nlh);\n\n\tmemcpy(nlmsg_data(nlh), &len, sizeof(len));\n\n\tif (sk_filter(sk, skb))\n\t\tkfree_skb(skb);\n\telse\n\t\t__netlink_sendskb(sk, skb);\n\n\tif (cb->done)\n \t\tcb->done(cb);\n \n \tnlk->cb_running = false;\n\tmodule = cb->module;\n\tskb = cb->skb;\n \tmutex_unlock(nlk->cb_mutex);\n\tmodule_put(module);\n\tconsume_skb(skb);\n \treturn 0;\n \n errout_skb:\n\tmutex_unlock(nlk->cb_mutex);\n\tkfree_skb(skb);\n\treturn err;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142032,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "SPL_METHOD(SplDoublyLinkedList, offsetSet)\n{\n\tzval                  *zindex, *value;\n\tspl_dllist_object     *intern;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"zz\", &zindex, &value) == FAILURE) {\n\t\treturn;\n\t}\n\n\tintern = Z_SPLDLLIST_P(getThis());\n\n\tif (Z_TYPE_P(zindex) == IS_NULL) {\n\t\t/* $obj[] = ... */\n\t\tspl_ptr_llist_push(intern->llist, value);\n\t} else {\n\t\t/* $obj[$foo] = ... */\n\t\tzend_long                   index;\n\t\tspl_ptr_llist_element *element;\n\n \t\tindex = spl_offset_convert_to_long(zindex);\n \n \t\tif (index < 0 || index >= intern->llist->count) {\n\t\t\tzval_ptr_dtor(value);\n \t\t\tzend_throw_exception(spl_ce_OutOfRangeException, \"Offset invalid or out of range\", 0);\n \t\t\treturn;\n \t\t}\n\n\t\telement = spl_ptr_llist_offset(intern->llist, index, intern->flags & SPL_DLLIST_IT_LIFO);\n\n\t\tif (element != NULL) {\n\t\t\t/* call dtor on the old element as in spl_ptr_llist_pop */\n\t\t\tif (intern->llist->dtor) {\n\t\t\t\tintern->llist->dtor(element);\n\t\t\t}\n\n\t\t\t/* the element is replaced, delref the old one as in\n\t\t\t * SplDoublyLinkedList::pop() */\n\t\t\tzval_ptr_dtor(&element->data);\n\t\t\tZVAL_COPY_VALUE(&element->data, value);\n\n\t\t\t/* new element, call ctor as in spl_ptr_llist_push */\n\t\t\tif (intern->llist->ctor) {\n\t\t\t\tintern->llist->ctor(element);\n\t\t\t}\n\t\t} else {\n\t\t\tzval_ptr_dtor(value);\n\t\t\tzend_throw_exception(spl_ce_OutOfRangeException, \"Offset invalid\", 0);\n\t\t\treturn;\n\t\t}\n\t}\n} /* }}} */\n\n/* {{{ proto void SplDoublyLinkedList::offsetUnset(mixed index)\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142159,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "SPL_METHOD(SplDoublyLinkedList, offsetSet)\n{\n\tzval                  *zindex, *value;\n\tspl_dllist_object     *intern;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"zz\", &zindex, &value) == FAILURE) {\n\t\treturn;\n\t}\n\n\tintern = Z_SPLDLLIST_P(getThis());\n\n\tif (Z_TYPE_P(zindex) == IS_NULL) {\n\t\t/* $obj[] = ... */\n\t\tspl_ptr_llist_push(intern->llist, value);\n\t} else {\n\t\t/* $obj[$foo] = ... */\n\t\tzend_long                   index;\n\t\tspl_ptr_llist_element *element;\n\n \t\tindex = spl_offset_convert_to_long(zindex);\n \n \t\tif (index < 0 || index >= intern->llist->count) {\n \t\t\tzend_throw_exception(spl_ce_OutOfRangeException, \"Offset invalid or out of range\", 0);\n \t\t\treturn;\n \t\t}\n\n\t\telement = spl_ptr_llist_offset(intern->llist, index, intern->flags & SPL_DLLIST_IT_LIFO);\n\n\t\tif (element != NULL) {\n\t\t\t/* call dtor on the old element as in spl_ptr_llist_pop */\n\t\t\tif (intern->llist->dtor) {\n\t\t\t\tintern->llist->dtor(element);\n\t\t\t}\n\n\t\t\t/* the element is replaced, delref the old one as in\n\t\t\t * SplDoublyLinkedList::pop() */\n\t\t\tzval_ptr_dtor(&element->data);\n\t\t\tZVAL_COPY_VALUE(&element->data, value);\n\n\t\t\t/* new element, call ctor as in spl_ptr_llist_push */\n\t\t\tif (intern->llist->ctor) {\n\t\t\t\tintern->llist->ctor(element);\n\t\t\t}\n\t\t} else {\n\t\t\tzval_ptr_dtor(value);\n\t\t\tzend_throw_exception(spl_ce_OutOfRangeException, \"Offset invalid\", 0);\n\t\t\treturn;\n\t\t}\n\t}\n} /* }}} */\n\n/* {{{ proto void SplDoublyLinkedList::offsetUnset(mixed index)\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142160,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "static int csnmp_read_table(host_definition_t *host, data_definition_t *data) {\n  struct snmp_pdu *req;\n  struct snmp_pdu *res = NULL;\n  struct variable_list *vb;\n\n  const data_set_t *ds;\n\n  size_t oid_list_len = data->values_len + 1;\n  /* Holds the last OID returned by the device. We use this in the GETNEXT\n   * request to proceed. */\n  oid_t oid_list[oid_list_len];\n  /* Set to false when an OID has left its subtree so we don't re-request it\n   * again. */\n  _Bool oid_list_todo[oid_list_len];\n\n  int status;\n  size_t i;\n\n  /* `value_list_head' and `value_list_tail' implement a linked list for each\n   * value. `instance_list_head' and `instance_list_tail' implement a linked\n   * list of\n   * instance names. This is used to jump gaps in the table. */\n  csnmp_list_instances_t *instance_list_head;\n  csnmp_list_instances_t *instance_list_tail;\n  csnmp_table_values_t **value_list_head;\n  csnmp_table_values_t **value_list_tail;\n\n  DEBUG(\"snmp plugin: csnmp_read_table (host = %s, data = %s)\", host->name,\n        data->name);\n\n  if (host->sess_handle == NULL) {\n    DEBUG(\"snmp plugin: csnmp_read_table: host->sess_handle == NULL\");\n    return (-1);\n  }\n\n  ds = plugin_get_ds(data->type);\n  if (!ds) {\n    ERROR(\"snmp plugin: DataSet `%s' not defined.\", data->type);\n    return (-1);\n  }\n\n  if (ds->ds_num != data->values_len) {\n    ERROR(\"snmp plugin: DataSet `%s' requires %zu values, but config talks \"\n          \"about %zu\",\n          data->type, ds->ds_num, data->values_len);\n    return (-1);\n  }\n  assert(data->values_len > 0);\n\n  /* We need a copy of all the OIDs, because GETNEXT will destroy them. */\n  memcpy(oid_list, data->values, data->values_len * sizeof(oid_t));\n  if (data->instance.oid.oid_len > 0)\n    memcpy(oid_list + data->values_len, &data->instance.oid, sizeof(oid_t));\n  else /* no InstanceFrom option specified. */\n    oid_list_len--;\n\n  for (i = 0; i < oid_list_len; i++)\n    oid_list_todo[i] = 1;\n\n  /* We're going to construct n linked lists, one for each \"value\".\n   * value_list_head will contain pointers to the heads of these linked lists,\n   * value_list_tail will contain pointers to the tail of the lists. */\n  value_list_head = calloc(data->values_len, sizeof(*value_list_head));\n  value_list_tail = calloc(data->values_len, sizeof(*value_list_tail));\n  if ((value_list_head == NULL) || (value_list_tail == NULL)) {\n    ERROR(\"snmp plugin: csnmp_read_table: calloc failed.\");\n    sfree(value_list_head);\n    sfree(value_list_tail);\n    return (-1);\n  }\n\n  instance_list_head = NULL;\n  instance_list_tail = NULL;\n\n  status = 0;\n  while (status == 0) {\n    int oid_list_todo_num;\n\n    req = snmp_pdu_create(SNMP_MSG_GETNEXT);\n    if (req == NULL) {\n      ERROR(\"snmp plugin: snmp_pdu_create failed.\");\n      status = -1;\n      break;\n    }\n\n    oid_list_todo_num = 0;\n    for (i = 0; i < oid_list_len; i++) {\n      /* Do not rerequest already finished OIDs */\n      if (!oid_list_todo[i])\n        continue;\n      oid_list_todo_num++;\n      snmp_add_null_var(req, oid_list[i].oid, oid_list[i].oid_len);\n    }\n\n     if (oid_list_todo_num == 0) {\n       /* The request is still empty - so we are finished */\n       DEBUG(\"snmp plugin: all variables have left their subtree\");\n       status = 0;\n       break;\n     }\n \n     res = NULL;\n     status = snmp_sess_synch_response(host->sess_handle, req, &res);\n     if ((status != STAT_SUCCESS) || (res == NULL)) {\n       char *errstr = NULL;\n\n      snmp_sess_error(host->sess_handle, NULL, NULL, &errstr);\n\n      c_complain(LOG_ERR, &host->complaint,\n                 \"snmp plugin: host %s: snmp_sess_synch_response failed: %s\",\n                 host->name, (errstr == NULL) ? \"Unknown problem\" : errstr);\n\n      if (res != NULL)\n         snmp_free_pdu(res);\n       res = NULL;\n \n      /* snmp_synch_response already freed our PDU */\n      req = NULL;\n       sfree(errstr);\n       csnmp_host_close_session(host);\n \n      status = -1;\n      break;\n    }\n\n    status = 0;\n    assert(res != NULL);\n    c_release(LOG_INFO, &host->complaint,\n              \"snmp plugin: host %s: snmp_sess_synch_response successful.\",\n              host->name);\n\n    vb = res->variables;\n    if (vb == NULL) {\n      status = -1;\n      break;\n    }\n\n    for (vb = res->variables, i = 0; (vb != NULL);\n         vb = vb->next_variable, i++) {\n      /* Calculate value index from todo list */\n      while ((i < oid_list_len) && !oid_list_todo[i])\n        i++;\n\n      /* An instance is configured and the res variable we process is the\n       * instance value (last index) */\n      if ((data->instance.oid.oid_len > 0) && (i == data->values_len)) {\n        if ((vb->type == SNMP_ENDOFMIBVIEW) ||\n            (snmp_oid_ncompare(\n                 data->instance.oid.oid, data->instance.oid.oid_len, vb->name,\n                 vb->name_length, data->instance.oid.oid_len) != 0)) {\n          DEBUG(\"snmp plugin: host = %s; data = %s; Instance left its subtree.\",\n                host->name, data->name);\n          oid_list_todo[i] = 0;\n          continue;\n        }\n\n        /* Allocate a new `csnmp_list_instances_t', insert the instance name and\n         * add it to the list */\n        if (csnmp_instance_list_add(&instance_list_head, &instance_list_tail,\n                                    res, host, data) != 0) {\n          ERROR(\"snmp plugin: host %s: csnmp_instance_list_add failed.\",\n                host->name);\n          status = -1;\n          break;\n        }\n      } else /* The variable we are processing is a normal value */\n      {\n        csnmp_table_values_t *vt;\n        oid_t vb_name;\n        oid_t suffix;\n        int ret;\n\n        csnmp_oid_init(&vb_name, vb->name, vb->name_length);\n\n        /* Calculate the current suffix. This is later used to check that the\n         * suffix is increasing. This also checks if we left the subtree */\n        ret = csnmp_oid_suffix(&suffix, &vb_name, data->values + i);\n        if (ret != 0) {\n          DEBUG(\"snmp plugin: host = %s; data = %s; i = %zu; \"\n                \"Value probably left its subtree.\",\n                host->name, data->name, i);\n          oid_list_todo[i] = 0;\n          continue;\n        }\n\n        /* Make sure the OIDs returned by the agent are increasing. Otherwise\n         * our\n         * table matching algorithm will get confused. */\n        if ((value_list_tail[i] != NULL) &&\n            (csnmp_oid_compare(&suffix, &value_list_tail[i]->suffix) <= 0)) {\n          DEBUG(\"snmp plugin: host = %s; data = %s; i = %zu; \"\n                \"Suffix is not increasing.\",\n                host->name, data->name, i);\n          oid_list_todo[i] = 0;\n          continue;\n        }\n\n        vt = calloc(1, sizeof(*vt));\n        if (vt == NULL) {\n          ERROR(\"snmp plugin: calloc failed.\");\n          status = -1;\n          break;\n        }\n\n        vt->value =\n            csnmp_value_list_to_value(vb, ds->ds[i].type, data->scale,\n                                      data->shift, host->name, data->name);\n        memcpy(&vt->suffix, &suffix, sizeof(vt->suffix));\n        vt->next = NULL;\n\n        if (value_list_tail[i] == NULL)\n          value_list_head[i] = vt;\n        else\n          value_list_tail[i]->next = vt;\n        value_list_tail[i] = vt;\n      }\n\n      /* Copy OID to oid_list[i] */\n      memcpy(oid_list[i].oid, vb->name, sizeof(oid) * vb->name_length);\n      oid_list[i].oid_len = vb->name_length;\n\n    } /* for (vb = res->variables ...) */\n\n    if (res != NULL)\n      snmp_free_pdu(res);\n    res = NULL;\n  } /* while (status == 0) */\n\n  if (res != NULL)\n     snmp_free_pdu(res);\n   res = NULL;\n \n  if (req != NULL)\n    snmp_free_pdu(req);\n  req = NULL;\n \n   if (status == 0)\n     csnmp_dispatch_table(host, data, instance_list_head, value_list_head);\n\n  /* Free all allocated variables here */\n  while (instance_list_head != NULL) {\n    csnmp_list_instances_t *next = instance_list_head->next;\n    sfree(instance_list_head);\n    instance_list_head = next;\n  }\n\n  for (i = 0; i < data->values_len; i++) {\n    while (value_list_head[i] != NULL) {\n      csnmp_table_values_t *next = value_list_head[i]->next;\n      sfree(value_list_head[i]);\n      value_list_head[i] = next;\n    }\n  }\n\n  sfree(value_list_head);\n  sfree(value_list_tail);\n\n  return (0);\n} /* int csnmp_read_table */\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142273,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "static int csnmp_read_table(host_definition_t *host, data_definition_t *data) {\n  struct snmp_pdu *req;\n  struct snmp_pdu *res = NULL;\n  struct variable_list *vb;\n\n  const data_set_t *ds;\n\n  size_t oid_list_len = data->values_len + 1;\n  /* Holds the last OID returned by the device. We use this in the GETNEXT\n   * request to proceed. */\n  oid_t oid_list[oid_list_len];\n  /* Set to false when an OID has left its subtree so we don't re-request it\n   * again. */\n  _Bool oid_list_todo[oid_list_len];\n\n  int status;\n  size_t i;\n\n  /* `value_list_head' and `value_list_tail' implement a linked list for each\n   * value. `instance_list_head' and `instance_list_tail' implement a linked\n   * list of\n   * instance names. This is used to jump gaps in the table. */\n  csnmp_list_instances_t *instance_list_head;\n  csnmp_list_instances_t *instance_list_tail;\n  csnmp_table_values_t **value_list_head;\n  csnmp_table_values_t **value_list_tail;\n\n  DEBUG(\"snmp plugin: csnmp_read_table (host = %s, data = %s)\", host->name,\n        data->name);\n\n  if (host->sess_handle == NULL) {\n    DEBUG(\"snmp plugin: csnmp_read_table: host->sess_handle == NULL\");\n    return (-1);\n  }\n\n  ds = plugin_get_ds(data->type);\n  if (!ds) {\n    ERROR(\"snmp plugin: DataSet `%s' not defined.\", data->type);\n    return (-1);\n  }\n\n  if (ds->ds_num != data->values_len) {\n    ERROR(\"snmp plugin: DataSet `%s' requires %zu values, but config talks \"\n          \"about %zu\",\n          data->type, ds->ds_num, data->values_len);\n    return (-1);\n  }\n  assert(data->values_len > 0);\n\n  /* We need a copy of all the OIDs, because GETNEXT will destroy them. */\n  memcpy(oid_list, data->values, data->values_len * sizeof(oid_t));\n  if (data->instance.oid.oid_len > 0)\n    memcpy(oid_list + data->values_len, &data->instance.oid, sizeof(oid_t));\n  else /* no InstanceFrom option specified. */\n    oid_list_len--;\n\n  for (i = 0; i < oid_list_len; i++)\n    oid_list_todo[i] = 1;\n\n  /* We're going to construct n linked lists, one for each \"value\".\n   * value_list_head will contain pointers to the heads of these linked lists,\n   * value_list_tail will contain pointers to the tail of the lists. */\n  value_list_head = calloc(data->values_len, sizeof(*value_list_head));\n  value_list_tail = calloc(data->values_len, sizeof(*value_list_tail));\n  if ((value_list_head == NULL) || (value_list_tail == NULL)) {\n    ERROR(\"snmp plugin: csnmp_read_table: calloc failed.\");\n    sfree(value_list_head);\n    sfree(value_list_tail);\n    return (-1);\n  }\n\n  instance_list_head = NULL;\n  instance_list_tail = NULL;\n\n  status = 0;\n  while (status == 0) {\n    int oid_list_todo_num;\n\n    req = snmp_pdu_create(SNMP_MSG_GETNEXT);\n    if (req == NULL) {\n      ERROR(\"snmp plugin: snmp_pdu_create failed.\");\n      status = -1;\n      break;\n    }\n\n    oid_list_todo_num = 0;\n    for (i = 0; i < oid_list_len; i++) {\n      /* Do not rerequest already finished OIDs */\n      if (!oid_list_todo[i])\n        continue;\n      oid_list_todo_num++;\n      snmp_add_null_var(req, oid_list[i].oid, oid_list[i].oid_len);\n    }\n\n     if (oid_list_todo_num == 0) {\n       /* The request is still empty - so we are finished */\n       DEBUG(\"snmp plugin: all variables have left their subtree\");\n      snmp_free_pdu(req);\n       status = 0;\n       break;\n     }\n \n     res = NULL;\n    /* snmp_sess_synch_response always frees our req PDU */\n     status = snmp_sess_synch_response(host->sess_handle, req, &res);\n     if ((status != STAT_SUCCESS) || (res == NULL)) {\n       char *errstr = NULL;\n\n      snmp_sess_error(host->sess_handle, NULL, NULL, &errstr);\n\n      c_complain(LOG_ERR, &host->complaint,\n                 \"snmp plugin: host %s: snmp_sess_synch_response failed: %s\",\n                 host->name, (errstr == NULL) ? \"Unknown problem\" : errstr);\n\n      if (res != NULL)\n         snmp_free_pdu(res);\n       res = NULL;\n \n       sfree(errstr);\n       csnmp_host_close_session(host);\n \n      status = -1;\n      break;\n    }\n\n    status = 0;\n    assert(res != NULL);\n    c_release(LOG_INFO, &host->complaint,\n              \"snmp plugin: host %s: snmp_sess_synch_response successful.\",\n              host->name);\n\n    vb = res->variables;\n    if (vb == NULL) {\n      status = -1;\n      break;\n    }\n\n    for (vb = res->variables, i = 0; (vb != NULL);\n         vb = vb->next_variable, i++) {\n      /* Calculate value index from todo list */\n      while ((i < oid_list_len) && !oid_list_todo[i])\n        i++;\n\n      /* An instance is configured and the res variable we process is the\n       * instance value (last index) */\n      if ((data->instance.oid.oid_len > 0) && (i == data->values_len)) {\n        if ((vb->type == SNMP_ENDOFMIBVIEW) ||\n            (snmp_oid_ncompare(\n                 data->instance.oid.oid, data->instance.oid.oid_len, vb->name,\n                 vb->name_length, data->instance.oid.oid_len) != 0)) {\n          DEBUG(\"snmp plugin: host = %s; data = %s; Instance left its subtree.\",\n                host->name, data->name);\n          oid_list_todo[i] = 0;\n          continue;\n        }\n\n        /* Allocate a new `csnmp_list_instances_t', insert the instance name and\n         * add it to the list */\n        if (csnmp_instance_list_add(&instance_list_head, &instance_list_tail,\n                                    res, host, data) != 0) {\n          ERROR(\"snmp plugin: host %s: csnmp_instance_list_add failed.\",\n                host->name);\n          status = -1;\n          break;\n        }\n      } else /* The variable we are processing is a normal value */\n      {\n        csnmp_table_values_t *vt;\n        oid_t vb_name;\n        oid_t suffix;\n        int ret;\n\n        csnmp_oid_init(&vb_name, vb->name, vb->name_length);\n\n        /* Calculate the current suffix. This is later used to check that the\n         * suffix is increasing. This also checks if we left the subtree */\n        ret = csnmp_oid_suffix(&suffix, &vb_name, data->values + i);\n        if (ret != 0) {\n          DEBUG(\"snmp plugin: host = %s; data = %s; i = %zu; \"\n                \"Value probably left its subtree.\",\n                host->name, data->name, i);\n          oid_list_todo[i] = 0;\n          continue;\n        }\n\n        /* Make sure the OIDs returned by the agent are increasing. Otherwise\n         * our\n         * table matching algorithm will get confused. */\n        if ((value_list_tail[i] != NULL) &&\n            (csnmp_oid_compare(&suffix, &value_list_tail[i]->suffix) <= 0)) {\n          DEBUG(\"snmp plugin: host = %s; data = %s; i = %zu; \"\n                \"Suffix is not increasing.\",\n                host->name, data->name, i);\n          oid_list_todo[i] = 0;\n          continue;\n        }\n\n        vt = calloc(1, sizeof(*vt));\n        if (vt == NULL) {\n          ERROR(\"snmp plugin: calloc failed.\");\n          status = -1;\n          break;\n        }\n\n        vt->value =\n            csnmp_value_list_to_value(vb, ds->ds[i].type, data->scale,\n                                      data->shift, host->name, data->name);\n        memcpy(&vt->suffix, &suffix, sizeof(vt->suffix));\n        vt->next = NULL;\n\n        if (value_list_tail[i] == NULL)\n          value_list_head[i] = vt;\n        else\n          value_list_tail[i]->next = vt;\n        value_list_tail[i] = vt;\n      }\n\n      /* Copy OID to oid_list[i] */\n      memcpy(oid_list[i].oid, vb->name, sizeof(oid) * vb->name_length);\n      oid_list[i].oid_len = vb->name_length;\n\n    } /* for (vb = res->variables ...) */\n\n    if (res != NULL)\n      snmp_free_pdu(res);\n    res = NULL;\n  } /* while (status == 0) */\n\n  if (res != NULL)\n     snmp_free_pdu(res);\n   res = NULL;\n \n \n   if (status == 0)\n     csnmp_dispatch_table(host, data, instance_list_head, value_list_head);\n\n  /* Free all allocated variables here */\n  while (instance_list_head != NULL) {\n    csnmp_list_instances_t *next = instance_list_head->next;\n    sfree(instance_list_head);\n    instance_list_head = next;\n  }\n\n  for (i = 0; i < data->values_len; i++) {\n    while (value_list_head[i] != NULL) {\n      csnmp_table_values_t *next = value_list_head[i]->next;\n      sfree(value_list_head[i]);\n      value_list_head[i] = next;\n    }\n  }\n\n  sfree(value_list_head);\n  sfree(value_list_tail);\n\n  return (0);\n} /* int csnmp_read_table */\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142274,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "struct sock *inet_csk_clone_lock(const struct sock *sk,\n\t\t\t\t const struct request_sock *req,\n\t\t\t\t const gfp_t priority)\n{\n\tstruct sock *newsk = sk_clone_lock(sk, priority);\n\n\tif (newsk) {\n\t\tstruct inet_connection_sock *newicsk = inet_csk(newsk);\n\n\t\tnewsk->sk_state = TCP_SYN_RECV;\n\t\tnewicsk->icsk_bind_hash = NULL;\n\n\t\tinet_sk(newsk)->inet_dport = inet_rsk(req)->ir_rmt_port;\n\t\tinet_sk(newsk)->inet_num = inet_rsk(req)->ir_num;\n\t\tinet_sk(newsk)->inet_sport = htons(inet_rsk(req)->ir_num);\n\t\tnewsk->sk_write_space = sk_stream_write_space;\n\n \t\t/* listeners have SOCK_RCU_FREE, not the children */\n \t\tsock_reset_flag(newsk, SOCK_RCU_FREE);\n \n \t\tnewsk->sk_mark = inet_rsk(req)->ir_mark;\n \t\tatomic64_set(&newsk->sk_cookie,\n \t\t\t     atomic64_read(&inet_rsk(req)->ir_cookie));\n\n\t\tnewicsk->icsk_retransmits = 0;\n\t\tnewicsk->icsk_backoff\t  = 0;\n\t\tnewicsk->icsk_probes_out  = 0;\n\n\t\t/* Deinitialize accept_queue to trap illegal accesses. */\n\t\tmemset(&newicsk->icsk_accept_queue, 0, sizeof(newicsk->icsk_accept_queue));\n\n\t\tsecurity_inet_csk_clone(newsk, req);\n\t}\n\treturn newsk;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142563,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "struct sock *inet_csk_clone_lock(const struct sock *sk,\n\t\t\t\t const struct request_sock *req,\n\t\t\t\t const gfp_t priority)\n{\n\tstruct sock *newsk = sk_clone_lock(sk, priority);\n\n\tif (newsk) {\n\t\tstruct inet_connection_sock *newicsk = inet_csk(newsk);\n\n\t\tnewsk->sk_state = TCP_SYN_RECV;\n\t\tnewicsk->icsk_bind_hash = NULL;\n\n\t\tinet_sk(newsk)->inet_dport = inet_rsk(req)->ir_rmt_port;\n\t\tinet_sk(newsk)->inet_num = inet_rsk(req)->ir_num;\n\t\tinet_sk(newsk)->inet_sport = htons(inet_rsk(req)->ir_num);\n\t\tnewsk->sk_write_space = sk_stream_write_space;\n\n \t\t/* listeners have SOCK_RCU_FREE, not the children */\n \t\tsock_reset_flag(newsk, SOCK_RCU_FREE);\n \n\t\tinet_sk(newsk)->mc_list = NULL;\n\n \t\tnewsk->sk_mark = inet_rsk(req)->ir_mark;\n \t\tatomic64_set(&newsk->sk_cookie,\n \t\t\t     atomic64_read(&inet_rsk(req)->ir_cookie));\n\n\t\tnewicsk->icsk_retransmits = 0;\n\t\tnewicsk->icsk_backoff\t  = 0;\n\t\tnewicsk->icsk_probes_out  = 0;\n\n\t\t/* Deinitialize accept_queue to trap illegal accesses. */\n\t\tmemset(&newicsk->icsk_accept_queue, 0, sizeof(newicsk->icsk_accept_queue));\n\n\t\tsecurity_inet_csk_clone(newsk, req);\n\t}\n\treturn newsk;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142564,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "int dccp_rcv_state_process(struct sock *sk, struct sk_buff *skb,\n\t\t\t   struct dccp_hdr *dh, unsigned int len)\n{\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\tstruct dccp_skb_cb *dcb = DCCP_SKB_CB(skb);\n\tconst int old_state = sk->sk_state;\n\tint queued = 0;\n\n\t/*\n\t *  Step 3: Process LISTEN state\n\t *\n\t *     If S.state == LISTEN,\n\t *\t If P.type == Request or P contains a valid Init Cookie option,\n\t *\t      (* Must scan the packet's options to check for Init\n\t *\t\t Cookies.  Only Init Cookies are processed here,\n\t *\t\t however; other options are processed in Step 8.  This\n\t *\t\t scan need only be performed if the endpoint uses Init\n\t *\t\t Cookies *)\n\t *\t      (* Generate a new socket and switch to that socket *)\n\t *\t      Set S := new socket for this port pair\n\t *\t      S.state = RESPOND\n\t *\t      Choose S.ISS (initial seqno) or set from Init Cookies\n\t *\t      Initialize S.GAR := S.ISS\n\t *\t      Set S.ISR, S.GSR, S.SWL, S.SWH from packet or Init\n\t *\t      Cookies Continue with S.state == RESPOND\n\t *\t      (* A Response packet will be generated in Step 11 *)\n\t *\t Otherwise,\n\t *\t      Generate Reset(No Connection) unless P.type == Reset\n\t *\t      Drop packet and return\n\t */\n\tif (sk->sk_state == DCCP_LISTEN) {\n\t\tif (dh->dccph_type == DCCP_PKT_REQUEST) {\n \t\t\tif (inet_csk(sk)->icsk_af_ops->conn_request(sk,\n \t\t\t\t\t\t\t\t    skb) < 0)\n \t\t\t\treturn 1;\n\t\t\tgoto discard;\n \t\t}\n \t\tif (dh->dccph_type == DCCP_PKT_RESET)\n \t\t\tgoto discard;\n\n\t\t/* Caller (dccp_v4_do_rcv) will send Reset */\n\t\tdcb->dccpd_reset_code = DCCP_RESET_CODE_NO_CONNECTION;\n\t\treturn 1;\n\t} else if (sk->sk_state == DCCP_CLOSED) {\n\t\tdcb->dccpd_reset_code = DCCP_RESET_CODE_NO_CONNECTION;\n\t\treturn 1;\n\t}\n\n\t/* Step 6: Check sequence numbers (omitted in LISTEN/REQUEST state) */\n\tif (sk->sk_state != DCCP_REQUESTING && dccp_check_seqno(sk, skb))\n\t\tgoto discard;\n\n\t/*\n\t *   Step 7: Check for unexpected packet types\n\t *      If (S.is_server and P.type == Response)\n\t *\t    or (S.is_client and P.type == Request)\n\t *\t    or (S.state == RESPOND and P.type == Data),\n\t *\t  Send Sync packet acknowledging P.seqno\n\t *\t  Drop packet and return\n\t */\n\tif ((dp->dccps_role != DCCP_ROLE_CLIENT &&\n\t     dh->dccph_type == DCCP_PKT_RESPONSE) ||\n\t    (dp->dccps_role == DCCP_ROLE_CLIENT &&\n\t     dh->dccph_type == DCCP_PKT_REQUEST) ||\n\t    (sk->sk_state == DCCP_RESPOND && dh->dccph_type == DCCP_PKT_DATA)) {\n\t\tdccp_send_sync(sk, dcb->dccpd_seq, DCCP_PKT_SYNC);\n\t\tgoto discard;\n\t}\n\n\t/*  Step 8: Process options */\n\tif (dccp_parse_options(sk, NULL, skb))\n\t\treturn 1;\n\n\t/*\n\t *  Step 9: Process Reset\n\t *\tIf P.type == Reset,\n\t *\t\tTear down connection\n\t *\t\tS.state := TIMEWAIT\n\t *\t\tSet TIMEWAIT timer\n\t *\t\tDrop packet and return\n\t */\n\tif (dh->dccph_type == DCCP_PKT_RESET) {\n\t\tdccp_rcv_reset(sk, skb);\n\t\treturn 0;\n\t} else if (dh->dccph_type == DCCP_PKT_CLOSEREQ) {\t/* Step 13 */\n\t\tif (dccp_rcv_closereq(sk, skb))\n\t\t\treturn 0;\n\t\tgoto discard;\n\t} else if (dh->dccph_type == DCCP_PKT_CLOSE) {\t\t/* Step 14 */\n\t\tif (dccp_rcv_close(sk, skb))\n\t\t\treturn 0;\n\t\tgoto discard;\n\t}\n\n\tswitch (sk->sk_state) {\n\tcase DCCP_REQUESTING:\n\t\tqueued = dccp_rcv_request_sent_state_process(sk, skb, dh, len);\n\t\tif (queued >= 0)\n\t\t\treturn queued;\n\n\t\t__kfree_skb(skb);\n\t\treturn 0;\n\n\tcase DCCP_PARTOPEN:\n\t\t/* Step 8: if using Ack Vectors, mark packet acknowledgeable */\n\t\tdccp_handle_ackvec_processing(sk, skb);\n\t\tdccp_deliver_input_to_ccids(sk, skb);\n\t\t/* fall through */\n\tcase DCCP_RESPOND:\n\t\tqueued = dccp_rcv_respond_partopen_state_process(sk, skb,\n\t\t\t\t\t\t\t\t dh, len);\n\t\tbreak;\n\t}\n\n\tif (dh->dccph_type == DCCP_PKT_ACK ||\n\t    dh->dccph_type == DCCP_PKT_DATAACK) {\n\t\tswitch (old_state) {\n\t\tcase DCCP_PARTOPEN:\n\t\t\tsk->sk_state_change(sk);\n\t\t\tsk_wake_async(sk, SOCK_WAKE_IO, POLL_OUT);\n\t\t\tbreak;\n\t\t}\n\t} else if (unlikely(dh->dccph_type == DCCP_PKT_SYNC)) {\n\t\tdccp_send_sync(sk, dcb->dccpd_seq, DCCP_PKT_SYNCACK);\n\t\tgoto discard;\n\t}\n\n\tif (!queued) {\ndiscard:\n\t\t__kfree_skb(skb);\n\t}\n\treturn 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142643,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "int dccp_rcv_state_process(struct sock *sk, struct sk_buff *skb,\n\t\t\t   struct dccp_hdr *dh, unsigned int len)\n{\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\tstruct dccp_skb_cb *dcb = DCCP_SKB_CB(skb);\n\tconst int old_state = sk->sk_state;\n\tint queued = 0;\n\n\t/*\n\t *  Step 3: Process LISTEN state\n\t *\n\t *     If S.state == LISTEN,\n\t *\t If P.type == Request or P contains a valid Init Cookie option,\n\t *\t      (* Must scan the packet's options to check for Init\n\t *\t\t Cookies.  Only Init Cookies are processed here,\n\t *\t\t however; other options are processed in Step 8.  This\n\t *\t\t scan need only be performed if the endpoint uses Init\n\t *\t\t Cookies *)\n\t *\t      (* Generate a new socket and switch to that socket *)\n\t *\t      Set S := new socket for this port pair\n\t *\t      S.state = RESPOND\n\t *\t      Choose S.ISS (initial seqno) or set from Init Cookies\n\t *\t      Initialize S.GAR := S.ISS\n\t *\t      Set S.ISR, S.GSR, S.SWL, S.SWH from packet or Init\n\t *\t      Cookies Continue with S.state == RESPOND\n\t *\t      (* A Response packet will be generated in Step 11 *)\n\t *\t Otherwise,\n\t *\t      Generate Reset(No Connection) unless P.type == Reset\n\t *\t      Drop packet and return\n\t */\n\tif (sk->sk_state == DCCP_LISTEN) {\n\t\tif (dh->dccph_type == DCCP_PKT_REQUEST) {\n \t\t\tif (inet_csk(sk)->icsk_af_ops->conn_request(sk,\n \t\t\t\t\t\t\t\t    skb) < 0)\n \t\t\t\treturn 1;\n\t\t\tconsume_skb(skb);\n\t\t\treturn 0;\n \t\t}\n \t\tif (dh->dccph_type == DCCP_PKT_RESET)\n \t\t\tgoto discard;\n\n\t\t/* Caller (dccp_v4_do_rcv) will send Reset */\n\t\tdcb->dccpd_reset_code = DCCP_RESET_CODE_NO_CONNECTION;\n\t\treturn 1;\n\t} else if (sk->sk_state == DCCP_CLOSED) {\n\t\tdcb->dccpd_reset_code = DCCP_RESET_CODE_NO_CONNECTION;\n\t\treturn 1;\n\t}\n\n\t/* Step 6: Check sequence numbers (omitted in LISTEN/REQUEST state) */\n\tif (sk->sk_state != DCCP_REQUESTING && dccp_check_seqno(sk, skb))\n\t\tgoto discard;\n\n\t/*\n\t *   Step 7: Check for unexpected packet types\n\t *      If (S.is_server and P.type == Response)\n\t *\t    or (S.is_client and P.type == Request)\n\t *\t    or (S.state == RESPOND and P.type == Data),\n\t *\t  Send Sync packet acknowledging P.seqno\n\t *\t  Drop packet and return\n\t */\n\tif ((dp->dccps_role != DCCP_ROLE_CLIENT &&\n\t     dh->dccph_type == DCCP_PKT_RESPONSE) ||\n\t    (dp->dccps_role == DCCP_ROLE_CLIENT &&\n\t     dh->dccph_type == DCCP_PKT_REQUEST) ||\n\t    (sk->sk_state == DCCP_RESPOND && dh->dccph_type == DCCP_PKT_DATA)) {\n\t\tdccp_send_sync(sk, dcb->dccpd_seq, DCCP_PKT_SYNC);\n\t\tgoto discard;\n\t}\n\n\t/*  Step 8: Process options */\n\tif (dccp_parse_options(sk, NULL, skb))\n\t\treturn 1;\n\n\t/*\n\t *  Step 9: Process Reset\n\t *\tIf P.type == Reset,\n\t *\t\tTear down connection\n\t *\t\tS.state := TIMEWAIT\n\t *\t\tSet TIMEWAIT timer\n\t *\t\tDrop packet and return\n\t */\n\tif (dh->dccph_type == DCCP_PKT_RESET) {\n\t\tdccp_rcv_reset(sk, skb);\n\t\treturn 0;\n\t} else if (dh->dccph_type == DCCP_PKT_CLOSEREQ) {\t/* Step 13 */\n\t\tif (dccp_rcv_closereq(sk, skb))\n\t\t\treturn 0;\n\t\tgoto discard;\n\t} else if (dh->dccph_type == DCCP_PKT_CLOSE) {\t\t/* Step 14 */\n\t\tif (dccp_rcv_close(sk, skb))\n\t\t\treturn 0;\n\t\tgoto discard;\n\t}\n\n\tswitch (sk->sk_state) {\n\tcase DCCP_REQUESTING:\n\t\tqueued = dccp_rcv_request_sent_state_process(sk, skb, dh, len);\n\t\tif (queued >= 0)\n\t\t\treturn queued;\n\n\t\t__kfree_skb(skb);\n\t\treturn 0;\n\n\tcase DCCP_PARTOPEN:\n\t\t/* Step 8: if using Ack Vectors, mark packet acknowledgeable */\n\t\tdccp_handle_ackvec_processing(sk, skb);\n\t\tdccp_deliver_input_to_ccids(sk, skb);\n\t\t/* fall through */\n\tcase DCCP_RESPOND:\n\t\tqueued = dccp_rcv_respond_partopen_state_process(sk, skb,\n\t\t\t\t\t\t\t\t dh, len);\n\t\tbreak;\n\t}\n\n\tif (dh->dccph_type == DCCP_PKT_ACK ||\n\t    dh->dccph_type == DCCP_PKT_DATAACK) {\n\t\tswitch (old_state) {\n\t\tcase DCCP_PARTOPEN:\n\t\t\tsk->sk_state_change(sk);\n\t\t\tsk_wake_async(sk, SOCK_WAKE_IO, POLL_OUT);\n\t\t\tbreak;\n\t\t}\n\t} else if (unlikely(dh->dccph_type == DCCP_PKT_SYNC)) {\n\t\tdccp_send_sync(sk, dcb->dccpd_seq, DCCP_PKT_SYNCACK);\n\t\tgoto discard;\n\t}\n\n\tif (!queued) {\ndiscard:\n\t\t__kfree_skb(skb);\n\t}\n\treturn 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142644,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "static MagickBooleanType SyncExifProfile(Image *image, StringInfo *profile)\n{\n#define MaxDirectoryStack  16\n#define EXIF_DELIMITER  \"\\n\"\n#define EXIF_NUM_FORMATS  12\n#define TAG_EXIF_OFFSET  0x8769\n#define TAG_INTEROP_OFFSET  0xa005\n\n  typedef struct _DirectoryInfo\n  {\n    unsigned char\n      *directory;\n\n    size_t\n      entry;\n  } DirectoryInfo;\n\n  DirectoryInfo\n    directory_stack[MaxDirectoryStack];\n\n  EndianType\n    endian;\n\n  size_t\n    entry,\n    length,\n    number_entries;\n\n  SplayTreeInfo\n    *exif_resources;\n\n  ssize_t\n    id,\n    level,\n    offset;\n\n  static int\n    format_bytes[] = {0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8};\n\n  unsigned char\n    *directory,\n    *exif;\n\n  /*\n    Set EXIF resolution tag.\n  */\n  length=GetStringInfoLength(profile);\n  exif=GetStringInfoDatum(profile);\n  if (length < 16)\n    return(MagickFalse);\n  id=(ssize_t) ReadProfileShort(LSBEndian,exif);\n  if ((id != 0x4949) && (id != 0x4D4D))\n    {\n      while (length != 0)\n      {\n        if (ReadProfileByte(&exif,&length) != 0x45)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x78)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x69)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x66)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x00)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x00)\n          continue;\n        break;\n      }\n      if (length < 16)\n        return(MagickFalse);\n      id=(ssize_t) ReadProfileShort(LSBEndian,exif);\n    }\n  endian=LSBEndian;\n  if (id == 0x4949)\n    endian=LSBEndian;\n  else\n    if (id == 0x4D4D)\n      endian=MSBEndian;\n    else\n      return(MagickFalse);\n  if (ReadProfileShort(endian,exif+2) != 0x002a)\n    return(MagickFalse);\n  /*\n    This the offset to the first IFD.\n  */\n  offset=(ssize_t) ReadProfileLong(endian,exif+4);\n  if ((offset < 0) || ((size_t) offset >= length))\n    return(MagickFalse);\n  directory=exif+offset;\n  level=0;\n  entry=0;\n  exif_resources=NewSplayTree((int (*)(const void *,const void *)) NULL,\n    (void *(*)(void *)) NULL,(void *(*)(void *)) NULL);\n  do\n  {\n    if (level > 0)\n      {\n        level--;\n        directory=directory_stack[level].directory;\n        entry=directory_stack[level].entry;\n      }\n    if ((directory < exif) || (directory > (exif+length-2)))\n      break;\n    /*\n      Determine how many entries there are in the current IFD.\n    */\n    number_entries=ReadProfileShort(endian,directory);\n    for ( ; entry < number_entries; entry++)\n    {\n      register unsigned char\n        *p,\n        *q;\n\n      size_t\n        number_bytes;\n\n      ssize_t\n        components,\n        format,\n        tag_value;\n\n      q=(unsigned char *) (directory+2+(12*entry));\n      if (q > (exif+length-12))\n        break;  /* corrupt EXIF */\n      if (GetValueFromSplayTree(exif_resources,q) == q)\n        break;\n      (void) AddValueToSplayTree(exif_resources,q,q);\n      tag_value=(ssize_t) ReadProfileShort(endian,q);\n      format=(ssize_t) ReadProfileShort(endian,q+2);\n      if ((format < 0) || ((format-1) >= EXIF_NUM_FORMATS))\n        break;\n      components=(ssize_t) ReadProfileLong(endian,q+4);\n      if (components < 0)\n        break;  /* corrupt EXIF */\n      number_bytes=(size_t) components*format_bytes[format];\n      if ((ssize_t) number_bytes < components)\n        break;  /* prevent overflow */\n      if (number_bytes <= 4)\n        p=q+8;\n      else\n        {\n          /*\n             The directory entry contains an offset.\n           */\n           offset=(ssize_t) ReadProfileLong(endian,q+8);\n          if ((ssize_t) (offset+number_bytes) < offset)\n            continue;  /* prevent overflow */\n          if ((size_t) (offset+number_bytes) > length)\n             continue;\n           p=(unsigned char *) (exif+offset);\n         }\n       switch (tag_value)\n      {\n        case 0x011a:\n        {\n          (void) WriteProfileLong(endian,(size_t) (image->x_resolution+0.5),p);\n          (void) WriteProfileLong(endian,1UL,p+4);\n          break;\n        }\n        case 0x011b:\n        {\n          (void) WriteProfileLong(endian,(size_t) (image->y_resolution+0.5),p);\n          (void) WriteProfileLong(endian,1UL,p+4);\n          break;\n        }\n        case 0x0112:\n        {\n          if (number_bytes == 4)\n            {\n              (void) WriteProfileLong(endian,(size_t) image->orientation,p);\n              break;\n            }\n          (void) WriteProfileShort(endian,(unsigned short) image->orientation,\n            p);\n          break;\n        }\n        case 0x0128:\n        {\n          if (number_bytes == 4)\n            {\n              (void) WriteProfileLong(endian,(size_t) (image->units+1),p);\n              break;\n            }\n          (void) WriteProfileShort(endian,(unsigned short) (image->units+1),p);\n          break;\n        }\n        default:\n          break;\n      }\n      if ((tag_value == TAG_EXIF_OFFSET) || (tag_value == TAG_INTEROP_OFFSET))\n        {\n          offset=(ssize_t) ReadProfileLong(endian,p);\n          if (((size_t) offset < length) && (level < (MaxDirectoryStack-2)))\n            {\n              directory_stack[level].directory=directory;\n              entry++;\n              directory_stack[level].entry=entry;\n              level++;\n              directory_stack[level].directory=exif+offset;\n              directory_stack[level].entry=0;\n              level++;\n              if ((directory+2+(12*number_entries)) > (exif+length))\n                break;\n              offset=(ssize_t) ReadProfileLong(endian,directory+2+(12*\n                number_entries));\n              if ((offset != 0) && ((size_t) offset < length) &&\n                  (level < (MaxDirectoryStack-2)))\n                {\n                  directory_stack[level].directory=exif+offset;\n                  directory_stack[level].entry=0;\n                  level++;\n                }\n            }\n          break;\n        }\n    }\n  } while (level > 0);\n  exif_resources=DestroySplayTree(exif_resources);\n  return(MagickTrue);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142663,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "static MagickBooleanType SyncExifProfile(Image *image, StringInfo *profile)\n{\n#define MaxDirectoryStack  16\n#define EXIF_DELIMITER  \"\\n\"\n#define EXIF_NUM_FORMATS  12\n#define TAG_EXIF_OFFSET  0x8769\n#define TAG_INTEROP_OFFSET  0xa005\n\n  typedef struct _DirectoryInfo\n  {\n    unsigned char\n      *directory;\n\n    size_t\n      entry;\n  } DirectoryInfo;\n\n  DirectoryInfo\n    directory_stack[MaxDirectoryStack];\n\n  EndianType\n    endian;\n\n  size_t\n    entry,\n    length,\n    number_entries;\n\n  SplayTreeInfo\n    *exif_resources;\n\n  ssize_t\n    id,\n    level,\n    offset;\n\n  static int\n    format_bytes[] = {0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8};\n\n  unsigned char\n    *directory,\n    *exif;\n\n  /*\n    Set EXIF resolution tag.\n  */\n  length=GetStringInfoLength(profile);\n  exif=GetStringInfoDatum(profile);\n  if (length < 16)\n    return(MagickFalse);\n  id=(ssize_t) ReadProfileShort(LSBEndian,exif);\n  if ((id != 0x4949) && (id != 0x4D4D))\n    {\n      while (length != 0)\n      {\n        if (ReadProfileByte(&exif,&length) != 0x45)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x78)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x69)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x66)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x00)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x00)\n          continue;\n        break;\n      }\n      if (length < 16)\n        return(MagickFalse);\n      id=(ssize_t) ReadProfileShort(LSBEndian,exif);\n    }\n  endian=LSBEndian;\n  if (id == 0x4949)\n    endian=LSBEndian;\n  else\n    if (id == 0x4D4D)\n      endian=MSBEndian;\n    else\n      return(MagickFalse);\n  if (ReadProfileShort(endian,exif+2) != 0x002a)\n    return(MagickFalse);\n  /*\n    This the offset to the first IFD.\n  */\n  offset=(ssize_t) ReadProfileLong(endian,exif+4);\n  if ((offset < 0) || ((size_t) offset >= length))\n    return(MagickFalse);\n  directory=exif+offset;\n  level=0;\n  entry=0;\n  exif_resources=NewSplayTree((int (*)(const void *,const void *)) NULL,\n    (void *(*)(void *)) NULL,(void *(*)(void *)) NULL);\n  do\n  {\n    if (level > 0)\n      {\n        level--;\n        directory=directory_stack[level].directory;\n        entry=directory_stack[level].entry;\n      }\n    if ((directory < exif) || (directory > (exif+length-2)))\n      break;\n    /*\n      Determine how many entries there are in the current IFD.\n    */\n    number_entries=ReadProfileShort(endian,directory);\n    for ( ; entry < number_entries; entry++)\n    {\n      register unsigned char\n        *p,\n        *q;\n\n      size_t\n        number_bytes;\n\n      ssize_t\n        components,\n        format,\n        tag_value;\n\n      q=(unsigned char *) (directory+2+(12*entry));\n      if (q > (exif+length-12))\n        break;  /* corrupt EXIF */\n      if (GetValueFromSplayTree(exif_resources,q) == q)\n        break;\n      (void) AddValueToSplayTree(exif_resources,q,q);\n      tag_value=(ssize_t) ReadProfileShort(endian,q);\n      format=(ssize_t) ReadProfileShort(endian,q+2);\n      if ((format < 0) || ((format-1) >= EXIF_NUM_FORMATS))\n        break;\n      components=(ssize_t) ReadProfileLong(endian,q+4);\n      if (components < 0)\n        break;  /* corrupt EXIF */\n      number_bytes=(size_t) components*format_bytes[format];\n      if ((ssize_t) number_bytes < components)\n        break;  /* prevent overflow */\n      if (number_bytes <= 4)\n        p=q+8;\n      else\n        {\n          /*\n             The directory entry contains an offset.\n           */\n           offset=(ssize_t) ReadProfileLong(endian,q+8);\n          if ((offset < 0) || ((size_t) (offset+number_bytes) > length))\n             continue;\n          if (~length < number_bytes)\n            continue;  /* prevent overflow */\n           p=(unsigned char *) (exif+offset);\n         }\n       switch (tag_value)\n      {\n        case 0x011a:\n        {\n          (void) WriteProfileLong(endian,(size_t) (image->x_resolution+0.5),p);\n          (void) WriteProfileLong(endian,1UL,p+4);\n          break;\n        }\n        case 0x011b:\n        {\n          (void) WriteProfileLong(endian,(size_t) (image->y_resolution+0.5),p);\n          (void) WriteProfileLong(endian,1UL,p+4);\n          break;\n        }\n        case 0x0112:\n        {\n          if (number_bytes == 4)\n            {\n              (void) WriteProfileLong(endian,(size_t) image->orientation,p);\n              break;\n            }\n          (void) WriteProfileShort(endian,(unsigned short) image->orientation,\n            p);\n          break;\n        }\n        case 0x0128:\n        {\n          if (number_bytes == 4)\n            {\n              (void) WriteProfileLong(endian,(size_t) (image->units+1),p);\n              break;\n            }\n          (void) WriteProfileShort(endian,(unsigned short) (image->units+1),p);\n          break;\n        }\n        default:\n          break;\n      }\n      if ((tag_value == TAG_EXIF_OFFSET) || (tag_value == TAG_INTEROP_OFFSET))\n        {\n          offset=(ssize_t) ReadProfileLong(endian,p);\n          if (((size_t) offset < length) && (level < (MaxDirectoryStack-2)))\n            {\n              directory_stack[level].directory=directory;\n              entry++;\n              directory_stack[level].entry=entry;\n              level++;\n              directory_stack[level].directory=exif+offset;\n              directory_stack[level].entry=0;\n              level++;\n              if ((directory+2+(12*number_entries)) > (exif+length))\n                break;\n              offset=(ssize_t) ReadProfileLong(endian,directory+2+(12*\n                number_entries));\n              if ((offset != 0) && ((size_t) offset < length) &&\n                  (level < (MaxDirectoryStack-2)))\n                {\n                  directory_stack[level].directory=exif+offset;\n                  directory_stack[level].entry=0;\n                  level++;\n                }\n            }\n          break;\n        }\n    }\n  } while (level > 0);\n  exif_resources=DestroySplayTree(exif_resources);\n  return(MagickTrue);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142664,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "static int mem_resize(jas_stream_memobj_t *m, int bufsize)\n {\n \tunsigned char *buf;\n \n\tassert(m->buf_);\n \tassert(bufsize >= 0);\n\tif (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char)))) {\n \t\treturn -1;\n \t}\n \tm->buf_ = buf;\n\tm->bufsize_ = bufsize;\n\treturn 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142775,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "static int mem_resize(jas_stream_memobj_t *m, int bufsize)\n {\n \tunsigned char *buf;\n \n\t//assert(m->buf_);\n \tassert(bufsize >= 0);\n\tif (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) &&\n\t  bufsize) {\n \t\treturn -1;\n \t}\n \tm->buf_ = buf;\n\tm->bufsize_ = bufsize;\n\treturn 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142776,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "static Image *ReadTGAImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  PixelInfo\n    pixel;\n\n  Quantum\n    index;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  size_t\n    base,\n    flag,\n    offset,\n    real,\n    skip;\n\n  ssize_t\n    count,\n    y;\n\n  TGAInfo\n    tga_info;\n\n  unsigned char\n    j,\n    k,\n    pixels[4],\n    runlength;\n\n  unsigned int\n    alpha_bits;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read TGA header information.\n  */\n  count=ReadBlob(image,1,&tga_info.id_length);\n  tga_info.colormap_type=(unsigned char) ReadBlobByte(image);\n  tga_info.image_type=(TGAImageType) ReadBlobByte(image);\n  if ((count != 1) ||\n      ((tga_info.image_type != TGAColormap) &&\n       (tga_info.image_type != TGARGB) &&\n       (tga_info.image_type != TGAMonochrome) &&\n       (tga_info.image_type != TGARLEColormap) &&\n       (tga_info.image_type != TGARLERGB) &&\n       (tga_info.image_type != TGARLEMonochrome)) ||\n      (((tga_info.image_type == TGAColormap) ||\n       (tga_info.image_type == TGARLEColormap)) &&\n       (tga_info.colormap_type == 0)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  tga_info.colormap_index=ReadBlobLSBShort(image);\n  tga_info.colormap_length=ReadBlobLSBShort(image);\n  tga_info.colormap_size=(unsigned char) ReadBlobByte(image);\n  tga_info.x_origin=ReadBlobLSBShort(image);\n  tga_info.y_origin=ReadBlobLSBShort(image);\n  tga_info.width=(unsigned short) ReadBlobLSBShort(image);\n  tga_info.height=(unsigned short) ReadBlobLSBShort(image);\n  tga_info.bits_per_pixel=(unsigned char) ReadBlobByte(image);\n  tga_info.attributes=(unsigned char) ReadBlobByte(image);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n  if ((((tga_info.bits_per_pixel <= 1) || (tga_info.bits_per_pixel >= 17)) &&\n       (tga_info.bits_per_pixel != 24) && (tga_info.bits_per_pixel != 32)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  /*\n    Initialize image structure.\n  */\n  image->columns=tga_info.width;\n  image->rows=tga_info.height;\n  alpha_bits=(tga_info.attributes & 0x0FU);\n  image->alpha_trait=(alpha_bits > 0) || (tga_info.bits_per_pixel == 32) ||\n    (tga_info.colormap_size == 32) ?  BlendPixelTrait : UndefinedPixelTrait;\n  if ((tga_info.image_type != TGAColormap) &&\n      (tga_info.image_type != TGARLEColormap))\n    image->depth=(size_t) ((tga_info.bits_per_pixel <= 8) ? 8 :\n      (tga_info.bits_per_pixel <= 16) ? 5 :\n      (tga_info.bits_per_pixel == 24) ? 8 :\n      (tga_info.bits_per_pixel == 32) ? 8 : 8);\n  else\n    image->depth=(size_t) ((tga_info.colormap_size <= 8) ? 8 :\n      (tga_info.colormap_size <= 16) ? 5 :\n      (tga_info.colormap_size == 24) ? 8 :\n      (tga_info.colormap_size == 32) ? 8 : 8);\n  if ((tga_info.image_type == TGAColormap) ||\n      (tga_info.image_type == TGAMonochrome) ||\n      (tga_info.image_type == TGARLEColormap) ||\n      (tga_info.image_type == TGARLEMonochrome))\n    image->storage_class=PseudoClass;\n  image->compression=NoCompression;\n  if ((tga_info.image_type == TGARLEColormap) ||\n      (tga_info.image_type == TGARLEMonochrome) ||\n      (tga_info.image_type == TGARLERGB))\n    image->compression=RLECompression;\n  if (image->storage_class == PseudoClass)\n    {\n      if (tga_info.colormap_type != 0)\n        image->colors=tga_info.colormap_index+tga_info.colormap_length;\n      else\n        {\n          size_t\n            one;\n\n          one=1;\n          image->colors=one << tga_info.bits_per_pixel;\n          if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n    }\n  if (tga_info.id_length != 0)\n    {\n      char\n        *comment;\n\n      size_t\n        length;\n\n      /*\n        TGA image comment.\n      */\n      length=(size_t) tga_info.id_length;\n      comment=(char *) NULL;\n      if (~length >= (MagickPathExtent-1))\n        comment=(char *) AcquireQuantumMemory(length+MagickPathExtent,\n          sizeof(*comment));\n      if (comment == (char *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      count=ReadBlob(image,tga_info.id_length,(unsigned char *) comment);\n      comment[tga_info.id_length]='\\0';\n      (void) SetImageProperty(image,\"comment\",comment,exception);\n      comment=DestroyString(comment);\n    }\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(image);\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  (void) ResetMagickMemory(&pixel,0,sizeof(pixel));\n  pixel.alpha=(MagickRealType) OpaqueAlpha;\n  if (tga_info.colormap_type != 0)\n    {\n       /*\n         Read TGA raster colormap.\n       */\n       if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n         ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n       for (i=0; i < (ssize_t) tga_info.colormap_index; i++)\n        image->colormap[i]=pixel;\n      for ( ; i < (ssize_t) image->colors; i++)\n      {\n        switch (tga_info.colormap_size)\n        {\n          case 8:\n          default:\n          {\n            /*\n              Gray scale.\n            */\n            pixel.red=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            pixel.green=pixel.red;\n            pixel.blue=pixel.red;\n            break;\n          }\n          case 15:\n          case 16:\n          {\n            QuantumAny\n              range;\n\n            /*\n              5 bits each of red green and blue.\n            */\n            j=(unsigned char) ReadBlobByte(image);\n            k=(unsigned char) ReadBlobByte(image);\n            range=GetQuantumRange(5UL);\n            pixel.red=(MagickRealType) ScaleAnyToQuantum(1UL*(k & 0x7c) >> 2,\n              range);\n            pixel.green=(MagickRealType) ScaleAnyToQuantum((1UL*(k & 0x03)\n              << 3)+(1UL*(j & 0xe0) >> 5),range);\n            pixel.blue=(MagickRealType) ScaleAnyToQuantum(1UL*(j & 0x1f),range);\n            break;\n          }\n          case 24:\n          {\n            /*\n              8 bits each of blue, green and red.\n            */\n            pixel.blue=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            pixel.green=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            pixel.red=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            break;\n          }\n          case 32:\n          {\n            /*\n              8 bits each of blue, green, red, and alpha.\n            */\n            pixel.blue=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            pixel.green=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            pixel.red=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            pixel.alpha=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            break;\n          }\n        }\n        image->colormap[i]=pixel;\n      }\n    }\n  /*\n    Convert TGA pixels to pixel packets.\n  */\n  base=0;\n  flag=0;\n  skip=MagickFalse;\n  real=0;\n  index=0;\n  runlength=0;\n  offset=0;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    real=offset;\n    if (((unsigned char) (tga_info.attributes & 0x20) >> 5) == 0)\n      real=image->rows-real-1;\n    q=QueueAuthenticPixels(image,0,(ssize_t) real,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if ((tga_info.image_type == TGARLEColormap) ||\n          (tga_info.image_type == TGARLERGB) ||\n          (tga_info.image_type == TGARLEMonochrome))\n        {\n          if (runlength != 0)\n            {\n              runlength--;\n              skip=flag != 0;\n            }\n          else\n            {\n              count=ReadBlob(image,1,&runlength);\n              if (count != 1)\n                ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n              flag=runlength & 0x80;\n              if (flag != 0)\n                runlength-=128;\n              skip=MagickFalse;\n            }\n        }\n      if (skip == MagickFalse)\n        switch (tga_info.bits_per_pixel)\n        {\n          case 8:\n          default:\n          {\n            /*\n              Gray scale.\n            */\n            index=(Quantum) ReadBlobByte(image);\n            if (tga_info.colormap_type != 0)\n              pixel=image->colormap[(ssize_t) ConstrainColormapIndex(image,\n                (ssize_t) index,exception)];\n            else\n              {\n                pixel.red=(MagickRealType) ScaleCharToQuantum((unsigned char)\n                  index);\n                pixel.green=(MagickRealType) ScaleCharToQuantum((unsigned char)\n                  index);\n                pixel.blue=(MagickRealType) ScaleCharToQuantum((unsigned char)\n                  index);\n              }\n            break;\n          }\n          case 15:\n          case 16:\n          {\n            QuantumAny\n              range;\n\n            /*\n              5 bits each of RGB.\n            */\n            if (ReadBlob(image,2,pixels) != 2)\n              ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n            j=pixels[0];\n            k=pixels[1];\n            range=GetQuantumRange(5UL);\n            pixel.red=(MagickRealType) ScaleAnyToQuantum(1UL*(k & 0x7c) >> 2,\n              range);\n            pixel.green=(MagickRealType) ScaleAnyToQuantum((1UL*\n              (k & 0x03) << 3)+(1UL*(j & 0xe0) >> 5),range);\n            pixel.blue=(MagickRealType) ScaleAnyToQuantum(1UL*(j & 0x1f),range);\n            if (image->alpha_trait != UndefinedPixelTrait)\n              pixel.alpha=(MagickRealType) ((k & 0x80) == 0 ? (Quantum)\n                TransparentAlpha : (Quantum) OpaqueAlpha);\n            if (image->storage_class == PseudoClass)\n              index=(Quantum) ConstrainColormapIndex(image,((ssize_t) (k << 8))+\n                j,exception);\n            break;\n          }\n          case 24:\n          {\n            /*\n              BGR pixels.\n            */\n            if (ReadBlob(image,3,pixels) != 3)\n              ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n            pixel.blue=(MagickRealType) ScaleCharToQuantum(pixels[0]);\n            pixel.green=(MagickRealType) ScaleCharToQuantum(pixels[1]);\n            pixel.red=(MagickRealType) ScaleCharToQuantum(pixels[2]);\n            break;\n          }\n          case 32:\n          {\n            /*\n              BGRA pixels.\n            */\n            if (ReadBlob(image,4,pixels) != 4)\n              ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n            pixel.blue=(MagickRealType) ScaleCharToQuantum(pixels[0]);\n            pixel.green=(MagickRealType) ScaleCharToQuantum(pixels[1]);\n            pixel.red=(MagickRealType) ScaleCharToQuantum(pixels[2]);\n            pixel.alpha=(MagickRealType) ScaleCharToQuantum(pixels[3]);\n            break;\n          }\n        }\n      if (status == MagickFalse)\n        ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n      if (image->storage_class == PseudoClass)\n        SetPixelIndex(image,index,q);\n      SetPixelRed(image,ClampToQuantum(pixel.red),q);\n      SetPixelGreen(image,ClampToQuantum(pixel.green),q);\n      SetPixelBlue(image,ClampToQuantum(pixel.blue),q);\n      if (image->alpha_trait != UndefinedPixelTrait)\n        SetPixelAlpha(image,ClampToQuantum(pixel.alpha),q);\n      q+=GetPixelChannels(image);\n    }\n    /*\n      if (((unsigned char) (tga_info.attributes & 0xc0) >> 6) == 4)\n        offset+=4;\n      else\n    */\n      if (((unsigned char) (tga_info.attributes & 0xc0) >> 6) == 2)\n        offset+=2;\n      else\n        offset++;\n    if (offset >= image->rows)\n      {\n        base++;\n        offset=base;\n      }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    if (image->previous == (Image *) NULL)\n      {\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142823,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "static Image *ReadTGAImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  PixelInfo\n    pixel;\n\n  Quantum\n    index;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  size_t\n    base,\n    flag,\n    offset,\n    real,\n    skip;\n\n  ssize_t\n    count,\n    y;\n\n  TGAInfo\n    tga_info;\n\n  unsigned char\n    j,\n    k,\n    pixels[4],\n    runlength;\n\n  unsigned int\n    alpha_bits;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read TGA header information.\n  */\n  count=ReadBlob(image,1,&tga_info.id_length);\n  tga_info.colormap_type=(unsigned char) ReadBlobByte(image);\n  tga_info.image_type=(TGAImageType) ReadBlobByte(image);\n  if ((count != 1) ||\n      ((tga_info.image_type != TGAColormap) &&\n       (tga_info.image_type != TGARGB) &&\n       (tga_info.image_type != TGAMonochrome) &&\n       (tga_info.image_type != TGARLEColormap) &&\n       (tga_info.image_type != TGARLERGB) &&\n       (tga_info.image_type != TGARLEMonochrome)) ||\n      (((tga_info.image_type == TGAColormap) ||\n       (tga_info.image_type == TGARLEColormap)) &&\n       (tga_info.colormap_type == 0)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  tga_info.colormap_index=ReadBlobLSBShort(image);\n  tga_info.colormap_length=ReadBlobLSBShort(image);\n  tga_info.colormap_size=(unsigned char) ReadBlobByte(image);\n  tga_info.x_origin=ReadBlobLSBShort(image);\n  tga_info.y_origin=ReadBlobLSBShort(image);\n  tga_info.width=(unsigned short) ReadBlobLSBShort(image);\n  tga_info.height=(unsigned short) ReadBlobLSBShort(image);\n  tga_info.bits_per_pixel=(unsigned char) ReadBlobByte(image);\n  tga_info.attributes=(unsigned char) ReadBlobByte(image);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n  if ((((tga_info.bits_per_pixel <= 1) || (tga_info.bits_per_pixel >= 17)) &&\n       (tga_info.bits_per_pixel != 24) && (tga_info.bits_per_pixel != 32)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  /*\n    Initialize image structure.\n  */\n  image->columns=tga_info.width;\n  image->rows=tga_info.height;\n  alpha_bits=(tga_info.attributes & 0x0FU);\n  image->alpha_trait=(alpha_bits > 0) || (tga_info.bits_per_pixel == 32) ||\n    (tga_info.colormap_size == 32) ?  BlendPixelTrait : UndefinedPixelTrait;\n  if ((tga_info.image_type != TGAColormap) &&\n      (tga_info.image_type != TGARLEColormap))\n    image->depth=(size_t) ((tga_info.bits_per_pixel <= 8) ? 8 :\n      (tga_info.bits_per_pixel <= 16) ? 5 :\n      (tga_info.bits_per_pixel == 24) ? 8 :\n      (tga_info.bits_per_pixel == 32) ? 8 : 8);\n  else\n    image->depth=(size_t) ((tga_info.colormap_size <= 8) ? 8 :\n      (tga_info.colormap_size <= 16) ? 5 :\n      (tga_info.colormap_size == 24) ? 8 :\n      (tga_info.colormap_size == 32) ? 8 : 8);\n  if ((tga_info.image_type == TGAColormap) ||\n      (tga_info.image_type == TGAMonochrome) ||\n      (tga_info.image_type == TGARLEColormap) ||\n      (tga_info.image_type == TGARLEMonochrome))\n    image->storage_class=PseudoClass;\n  image->compression=NoCompression;\n  if ((tga_info.image_type == TGARLEColormap) ||\n      (tga_info.image_type == TGARLEMonochrome) ||\n      (tga_info.image_type == TGARLERGB))\n    image->compression=RLECompression;\n  if (image->storage_class == PseudoClass)\n    {\n      if (tga_info.colormap_type != 0)\n        image->colors=tga_info.colormap_index+tga_info.colormap_length;\n      else\n        {\n          size_t\n            one;\n\n          one=1;\n          image->colors=one << tga_info.bits_per_pixel;\n          if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n    }\n  if (tga_info.id_length != 0)\n    {\n      char\n        *comment;\n\n      size_t\n        length;\n\n      /*\n        TGA image comment.\n      */\n      length=(size_t) tga_info.id_length;\n      comment=(char *) NULL;\n      if (~length >= (MagickPathExtent-1))\n        comment=(char *) AcquireQuantumMemory(length+MagickPathExtent,\n          sizeof(*comment));\n      if (comment == (char *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      count=ReadBlob(image,tga_info.id_length,(unsigned char *) comment);\n      comment[tga_info.id_length]='\\0';\n      (void) SetImageProperty(image,\"comment\",comment,exception);\n      comment=DestroyString(comment);\n    }\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(image);\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  (void) ResetMagickMemory(&pixel,0,sizeof(pixel));\n  pixel.alpha=(MagickRealType) OpaqueAlpha;\n  if (tga_info.colormap_type != 0)\n    {\n       /*\n         Read TGA raster colormap.\n       */\n      if (image->colors < tga_info.colormap_index)\n        image->colors=tga_info.colormap_index;\n       if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n         ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n       for (i=0; i < (ssize_t) tga_info.colormap_index; i++)\n        image->colormap[i]=pixel;\n      for ( ; i < (ssize_t) image->colors; i++)\n      {\n        switch (tga_info.colormap_size)\n        {\n          case 8:\n          default:\n          {\n            /*\n              Gray scale.\n            */\n            pixel.red=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            pixel.green=pixel.red;\n            pixel.blue=pixel.red;\n            break;\n          }\n          case 15:\n          case 16:\n          {\n            QuantumAny\n              range;\n\n            /*\n              5 bits each of red green and blue.\n            */\n            j=(unsigned char) ReadBlobByte(image);\n            k=(unsigned char) ReadBlobByte(image);\n            range=GetQuantumRange(5UL);\n            pixel.red=(MagickRealType) ScaleAnyToQuantum(1UL*(k & 0x7c) >> 2,\n              range);\n            pixel.green=(MagickRealType) ScaleAnyToQuantum((1UL*(k & 0x03)\n              << 3)+(1UL*(j & 0xe0) >> 5),range);\n            pixel.blue=(MagickRealType) ScaleAnyToQuantum(1UL*(j & 0x1f),range);\n            break;\n          }\n          case 24:\n          {\n            /*\n              8 bits each of blue, green and red.\n            */\n            pixel.blue=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            pixel.green=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            pixel.red=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            break;\n          }\n          case 32:\n          {\n            /*\n              8 bits each of blue, green, red, and alpha.\n            */\n            pixel.blue=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            pixel.green=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            pixel.red=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            pixel.alpha=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            break;\n          }\n        }\n        image->colormap[i]=pixel;\n      }\n    }\n  /*\n    Convert TGA pixels to pixel packets.\n  */\n  base=0;\n  flag=0;\n  skip=MagickFalse;\n  real=0;\n  index=0;\n  runlength=0;\n  offset=0;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    real=offset;\n    if (((unsigned char) (tga_info.attributes & 0x20) >> 5) == 0)\n      real=image->rows-real-1;\n    q=QueueAuthenticPixels(image,0,(ssize_t) real,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if ((tga_info.image_type == TGARLEColormap) ||\n          (tga_info.image_type == TGARLERGB) ||\n          (tga_info.image_type == TGARLEMonochrome))\n        {\n          if (runlength != 0)\n            {\n              runlength--;\n              skip=flag != 0;\n            }\n          else\n            {\n              count=ReadBlob(image,1,&runlength);\n              if (count != 1)\n                ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n              flag=runlength & 0x80;\n              if (flag != 0)\n                runlength-=128;\n              skip=MagickFalse;\n            }\n        }\n      if (skip == MagickFalse)\n        switch (tga_info.bits_per_pixel)\n        {\n          case 8:\n          default:\n          {\n            /*\n              Gray scale.\n            */\n            index=(Quantum) ReadBlobByte(image);\n            if (tga_info.colormap_type != 0)\n              pixel=image->colormap[(ssize_t) ConstrainColormapIndex(image,\n                (ssize_t) index,exception)];\n            else\n              {\n                pixel.red=(MagickRealType) ScaleCharToQuantum((unsigned char)\n                  index);\n                pixel.green=(MagickRealType) ScaleCharToQuantum((unsigned char)\n                  index);\n                pixel.blue=(MagickRealType) ScaleCharToQuantum((unsigned char)\n                  index);\n              }\n            break;\n          }\n          case 15:\n          case 16:\n          {\n            QuantumAny\n              range;\n\n            /*\n              5 bits each of RGB.\n            */\n            if (ReadBlob(image,2,pixels) != 2)\n              ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n            j=pixels[0];\n            k=pixels[1];\n            range=GetQuantumRange(5UL);\n            pixel.red=(MagickRealType) ScaleAnyToQuantum(1UL*(k & 0x7c) >> 2,\n              range);\n            pixel.green=(MagickRealType) ScaleAnyToQuantum((1UL*\n              (k & 0x03) << 3)+(1UL*(j & 0xe0) >> 5),range);\n            pixel.blue=(MagickRealType) ScaleAnyToQuantum(1UL*(j & 0x1f),range);\n            if (image->alpha_trait != UndefinedPixelTrait)\n              pixel.alpha=(MagickRealType) ((k & 0x80) == 0 ? (Quantum)\n                TransparentAlpha : (Quantum) OpaqueAlpha);\n            if (image->storage_class == PseudoClass)\n              index=(Quantum) ConstrainColormapIndex(image,((ssize_t) (k << 8))+\n                j,exception);\n            break;\n          }\n          case 24:\n          {\n            /*\n              BGR pixels.\n            */\n            if (ReadBlob(image,3,pixels) != 3)\n              ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n            pixel.blue=(MagickRealType) ScaleCharToQuantum(pixels[0]);\n            pixel.green=(MagickRealType) ScaleCharToQuantum(pixels[1]);\n            pixel.red=(MagickRealType) ScaleCharToQuantum(pixels[2]);\n            break;\n          }\n          case 32:\n          {\n            /*\n              BGRA pixels.\n            */\n            if (ReadBlob(image,4,pixels) != 4)\n              ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n            pixel.blue=(MagickRealType) ScaleCharToQuantum(pixels[0]);\n            pixel.green=(MagickRealType) ScaleCharToQuantum(pixels[1]);\n            pixel.red=(MagickRealType) ScaleCharToQuantum(pixels[2]);\n            pixel.alpha=(MagickRealType) ScaleCharToQuantum(pixels[3]);\n            break;\n          }\n        }\n      if (status == MagickFalse)\n        ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n      if (image->storage_class == PseudoClass)\n        SetPixelIndex(image,index,q);\n      SetPixelRed(image,ClampToQuantum(pixel.red),q);\n      SetPixelGreen(image,ClampToQuantum(pixel.green),q);\n      SetPixelBlue(image,ClampToQuantum(pixel.blue),q);\n      if (image->alpha_trait != UndefinedPixelTrait)\n        SetPixelAlpha(image,ClampToQuantum(pixel.alpha),q);\n      q+=GetPixelChannels(image);\n    }\n    /*\n      if (((unsigned char) (tga_info.attributes & 0xc0) >> 6) == 4)\n        offset+=4;\n      else\n    */\n      if (((unsigned char) (tga_info.attributes & 0xc0) >> 6) == 2)\n        offset+=2;\n      else\n        offset++;\n    if (offset >= image->rows)\n      {\n        base++;\n        offset=base;\n      }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    if (image->previous == (Image *) NULL)\n      {\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142824,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "_warc_read(struct archive_read *a, const void **buf, size_t *bsz, int64_t *off)\n{\n\tstruct warc_s *w = a->format->data;\n\tconst char *rab;\n\tssize_t nrd;\n\n\tif (w->cntoff >= w->cntlen) {\n\teof:\n\t\t/* it's our lucky day, no work, we can leave early */\n\t\t*buf = NULL;\n\t\t*bsz = 0U;\n\t\t*off = w->cntoff + 4U/*for \\r\\n\\r\\n separator*/;\n\t\tw->unconsumed = 0U;\n \t\treturn (ARCHIVE_EOF);\n \t}\n \n \trab = __archive_read_ahead(a, 1U, &nrd);\n \tif (nrd < 0) {\n \t\t*bsz = 0U;\n\t\t/* big catastrophe */\n\t\treturn (int)nrd;\n\t} else if (nrd == 0) {\n\t\tgoto eof;\n\t} else if ((size_t)nrd > w->cntlen - w->cntoff) {\n\t\t/* clamp to content-length */\n\t\tnrd = w->cntlen - w->cntoff;\n\t}\n\t*off = w->cntoff;\n\t*bsz = nrd;\n\t*buf = rab;\n\n\tw->cntoff += nrd;\n\tw->unconsumed = (size_t)nrd;\n\treturn (ARCHIVE_OK);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142849,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "_warc_read(struct archive_read *a, const void **buf, size_t *bsz, int64_t *off)\n{\n\tstruct warc_s *w = a->format->data;\n\tconst char *rab;\n\tssize_t nrd;\n\n\tif (w->cntoff >= w->cntlen) {\n\teof:\n\t\t/* it's our lucky day, no work, we can leave early */\n\t\t*buf = NULL;\n\t\t*bsz = 0U;\n\t\t*off = w->cntoff + 4U/*for \\r\\n\\r\\n separator*/;\n\t\tw->unconsumed = 0U;\n \t\treturn (ARCHIVE_EOF);\n \t}\n \n\tif (w->unconsumed) {\n\t\t__archive_read_consume(a, w->unconsumed);\n\t\tw->unconsumed = 0U;\n\t}\n\n \trab = __archive_read_ahead(a, 1U, &nrd);\n \tif (nrd < 0) {\n \t\t*bsz = 0U;\n\t\t/* big catastrophe */\n\t\treturn (int)nrd;\n\t} else if (nrd == 0) {\n\t\tgoto eof;\n\t} else if ((size_t)nrd > w->cntlen - w->cntoff) {\n\t\t/* clamp to content-length */\n\t\tnrd = w->cntlen - w->cntoff;\n\t}\n\t*off = w->cntoff;\n\t*bsz = nrd;\n\t*buf = rab;\n\n\tw->cntoff += nrd;\n\tw->unconsumed = (size_t)nrd;\n\treturn (ARCHIVE_OK);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 142850,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": " GetStartupData(HANDLE pipe, STARTUP_DATA *sud)\n {\n     size_t size, len;\n    BOOL ret = FALSE;\n     WCHAR *data = NULL;\n     DWORD bytes, read;\n \n    bytes = PeekNamedPipeAsync(pipe, 1, &exit_event);\n    if (bytes == 0)\n     {\n         MsgToEventLog(M_SYSERR, TEXT(\"PeekNamedPipeAsync failed\"));\n         ReturnLastError(pipe, L\"PeekNamedPipeAsync\");\n        goto out;\n     }\n \n     size = bytes / sizeof(*data);\n     if (size == 0)\n     {\n         MsgToEventLog(M_SYSERR, TEXT(\"malformed startup data: 1 byte received\"));\n         ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto out;\n     }\n \n     data = malloc(bytes);\n     if (data == NULL)\n     {\n         MsgToEventLog(M_SYSERR, TEXT(\"malloc failed\"));\n         ReturnLastError(pipe, L\"malloc\");\n        goto out;\n     }\n \n     read = ReadPipeAsync(pipe, data, bytes, 1, &exit_event);\n     if (bytes != read)\n     {\n         MsgToEventLog(M_SYSERR, TEXT(\"ReadPipeAsync failed\"));\n         ReturnLastError(pipe, L\"ReadPipeAsync\");\n        goto out;\n     }\n \n     if (data[size - 1] != 0)\n     {\n         MsgToEventLog(M_ERR, TEXT(\"Startup data is not NULL terminated\"));\n         ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto out;\n     }\n \n     sud->directory = data;\n    len = wcslen(sud->directory) + 1;\n    size -= len;\n    if (size <= 0)\n     {\n         MsgToEventLog(M_ERR, TEXT(\"Startup data ends at working directory\"));\n         ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto out;\n     }\n \n     sud->options = sud->directory + len;\n    len = wcslen(sud->options) + 1;\n    size -= len;\n    if (size <= 0)\n     {\n         MsgToEventLog(M_ERR, TEXT(\"Startup data ends at command line options\"));\n         ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto out;\n     }\n \n     sud->std_input = sud->options + len;\n    data = NULL; /* don't free data */\n    ret = TRUE;\n \nout:\n     free(data);\n    return ret;\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143047,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": " GetStartupData(HANDLE pipe, STARTUP_DATA *sud)\n {\n     size_t size, len;\n     WCHAR *data = NULL;\n     DWORD bytes, read;\n \n    bytes = PeekNamedPipeAsync(pipe, 1, &exit_event);\n    if (bytes == 0)\n     {\n         MsgToEventLog(M_SYSERR, TEXT(\"PeekNamedPipeAsync failed\"));\n         ReturnLastError(pipe, L\"PeekNamedPipeAsync\");\n        goto err;\n     }\n \n     size = bytes / sizeof(*data);\n     if (size == 0)\n     {\n         MsgToEventLog(M_SYSERR, TEXT(\"malformed startup data: 1 byte received\"));\n         ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto err;\n     }\n \n     data = malloc(bytes);\n     if (data == NULL)\n     {\n         MsgToEventLog(M_SYSERR, TEXT(\"malloc failed\"));\n         ReturnLastError(pipe, L\"malloc\");\n        goto err;\n     }\n \n     read = ReadPipeAsync(pipe, data, bytes, 1, &exit_event);\n     if (bytes != read)\n     {\n         MsgToEventLog(M_SYSERR, TEXT(\"ReadPipeAsync failed\"));\n         ReturnLastError(pipe, L\"ReadPipeAsync\");\n        goto err;\n     }\n \n     if (data[size - 1] != 0)\n     {\n         MsgToEventLog(M_ERR, TEXT(\"Startup data is not NULL terminated\"));\n         ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto err;\n     }\n \n     sud->directory = data;\n    len = wcslen(sud->directory) + 1;\n    size -= len;\n    if (size <= 0)\n     {\n         MsgToEventLog(M_ERR, TEXT(\"Startup data ends at working directory\"));\n         ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto err;\n     }\n \n     sud->options = sud->directory + len;\n    len = wcslen(sud->options) + 1;\n    size -= len;\n    if (size <= 0)\n     {\n         MsgToEventLog(M_ERR, TEXT(\"Startup data ends at command line options\"));\n         ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto err;\n     }\n \n     sud->std_input = sud->options + len;\n    return TRUE;\n \nerr:\n    sud->directory = NULL;\t\t/* caller must not free() */\n     free(data);\n    return FALSE;\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143048,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "int blkcg_init_queue(struct request_queue *q)\n{\n\tstruct blkcg_gq *new_blkg, *blkg;\n\tbool preloaded;\n\tint ret;\n\n\tnew_blkg = blkg_alloc(&blkcg_root, q, GFP_KERNEL);\n\tif (!new_blkg)\n\t\treturn -ENOMEM;\n\n\tpreloaded = !radix_tree_preload(GFP_KERNEL);\n\n\t/*\n\t * Make sure the root blkg exists and count the existing blkgs.  As\n\t * @q is bypassing at this point, blkg_lookup_create() can't be\n\t * used.  Open code insertion.\n\t */\n\trcu_read_lock();\n\tspin_lock_irq(q->queue_lock);\n\tblkg = blkg_create(&blkcg_root, q, new_blkg);\n\tspin_unlock_irq(q->queue_lock);\n\trcu_read_unlock();\n\n \tif (preloaded)\n \t\tradix_tree_preload_end();\n \n\tif (IS_ERR(blkg)) {\n\t\tblkg_free(new_blkg);\n \t\treturn PTR_ERR(blkg);\n\t}\n \n \tq->root_blkg = blkg;\n \tq->root_rl.blkg = blkg;\n\n\tret = blk_throtl_init(q);\n\tif (ret) {\n\t\tspin_lock_irq(q->queue_lock);\n\t\tblkg_destroy_all(q);\n\t\tspin_unlock_irq(q->queue_lock);\n\t}\n\treturn ret;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143073,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "int blkcg_init_queue(struct request_queue *q)\n{\n\tstruct blkcg_gq *new_blkg, *blkg;\n\tbool preloaded;\n\tint ret;\n\n\tnew_blkg = blkg_alloc(&blkcg_root, q, GFP_KERNEL);\n\tif (!new_blkg)\n\t\treturn -ENOMEM;\n\n\tpreloaded = !radix_tree_preload(GFP_KERNEL);\n\n\t/*\n\t * Make sure the root blkg exists and count the existing blkgs.  As\n\t * @q is bypassing at this point, blkg_lookup_create() can't be\n\t * used.  Open code insertion.\n\t */\n\trcu_read_lock();\n\tspin_lock_irq(q->queue_lock);\n\tblkg = blkg_create(&blkcg_root, q, new_blkg);\n\tspin_unlock_irq(q->queue_lock);\n\trcu_read_unlock();\n\n \tif (preloaded)\n \t\tradix_tree_preload_end();\n \n\tif (IS_ERR(blkg))\n \t\treturn PTR_ERR(blkg);\n \n \tq->root_blkg = blkg;\n \tq->root_rl.blkg = blkg;\n\n\tret = blk_throtl_init(q);\n\tif (ret) {\n\t\tspin_lock_irq(q->queue_lock);\n\t\tblkg_destroy_all(q);\n\t\tspin_unlock_irq(q->queue_lock);\n\t}\n\treturn ret;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143074,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "static int amd_gpio_remove(struct platform_device *pdev)\n{\n\tstruct amd_gpio *gpio_dev;\n\n \tgpio_dev = platform_get_drvdata(pdev);\n \n \tgpiochip_remove(&gpio_dev->gc);\n\tpinctrl_unregister(gpio_dev->pctrl);\n \n \treturn 0;\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143137,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "static int amd_gpio_remove(struct platform_device *pdev)\n{\n\tstruct amd_gpio *gpio_dev;\n\n \tgpio_dev = platform_get_drvdata(pdev);\n \n \tgpiochip_remove(&gpio_dev->gc);\n \n \treturn 0;\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143138,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "static int f_midi_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\n{\n\tstruct f_midi *midi = func_to_midi(f);\n\tunsigned i;\n\tint err;\n\n\t/* we only set alt for MIDIStreaming interface */\n\tif (intf != midi->ms_id)\n\t\treturn 0;\n\n\terr = f_midi_start_ep(midi, f, midi->in_ep);\n\tif (err)\n\t\treturn err;\n\n\terr = f_midi_start_ep(midi, f, midi->out_ep);\n\tif (err)\n\t\treturn err;\n\n\t/* pre-allocate write usb requests to use on f_midi_transmit. */\n\twhile (kfifo_avail(&midi->in_req_fifo)) {\n\t\tstruct usb_request *req =\n\t\t\tmidi_alloc_ep_req(midi->in_ep, midi->buflen);\n\n\t\tif (req == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\treq->length = 0;\n\t\treq->complete = f_midi_complete;\n\n\t\tkfifo_put(&midi->in_req_fifo, req);\n\t}\n\n\t/* allocate a bunch of read buffers and queue them all at once. */\n\tfor (i = 0; i < midi->qlen && err == 0; i++) {\n\t\tstruct usb_request *req =\n\t\t\tmidi_alloc_ep_req(midi->out_ep, midi->buflen);\n\n\t\tif (req == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\treq->complete = f_midi_complete;\n\t\terr = usb_ep_queue(midi->out_ep, req, GFP_ATOMIC);\n \t\tif (err) {\n \t\t\tERROR(midi, \"%s: couldn't enqueue request: %d\\n\",\n \t\t\t\t    midi->out_ep->name, err);\n\t\t\tfree_ep_req(midi->out_ep, req);\n \t\t\treturn err;\n \t\t}\n \t}\n\n\treturn 0;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143305,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "static int f_midi_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\n{\n\tstruct f_midi *midi = func_to_midi(f);\n\tunsigned i;\n\tint err;\n\n\t/* we only set alt for MIDIStreaming interface */\n\tif (intf != midi->ms_id)\n\t\treturn 0;\n\n\terr = f_midi_start_ep(midi, f, midi->in_ep);\n\tif (err)\n\t\treturn err;\n\n\terr = f_midi_start_ep(midi, f, midi->out_ep);\n\tif (err)\n\t\treturn err;\n\n\t/* pre-allocate write usb requests to use on f_midi_transmit. */\n\twhile (kfifo_avail(&midi->in_req_fifo)) {\n\t\tstruct usb_request *req =\n\t\t\tmidi_alloc_ep_req(midi->in_ep, midi->buflen);\n\n\t\tif (req == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\treq->length = 0;\n\t\treq->complete = f_midi_complete;\n\n\t\tkfifo_put(&midi->in_req_fifo, req);\n\t}\n\n\t/* allocate a bunch of read buffers and queue them all at once. */\n\tfor (i = 0; i < midi->qlen && err == 0; i++) {\n\t\tstruct usb_request *req =\n\t\t\tmidi_alloc_ep_req(midi->out_ep, midi->buflen);\n\n\t\tif (req == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\treq->complete = f_midi_complete;\n\t\terr = usb_ep_queue(midi->out_ep, req, GFP_ATOMIC);\n \t\tif (err) {\n \t\t\tERROR(midi, \"%s: couldn't enqueue request: %d\\n\",\n \t\t\t\t    midi->out_ep->name, err);\n\t\t\tif (req->buf != NULL)\n\t\t\t\tfree_ep_req(midi->out_ep, req);\n \t\t\treturn err;\n \t\t}\n \t}\n\n\treturn 0;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 143306,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "static size_t read_entry(\n \tgit_index_entry **out,\n \tgit_index *index,\n \tconst void *buffer,\n \tsize_t buffer_size,\n\tconst char *last)\n{\n\tsize_t path_length, entry_size;\n\tconst char *path_ptr;\n\tstruct entry_short source;\n\tgit_index_entry entry = {{0}};\n\tbool compressed = index->version >= INDEX_VERSION_NUMBER_COMP;\n \tchar *tmp_path = NULL;\n \n \tif (INDEX_FOOTER_SIZE + minimal_entry_size > buffer_size)\n\t\treturn 0;\n \n \t/* buffer is not guaranteed to be aligned */\n \tmemcpy(&source, buffer, sizeof(struct entry_short));\n\n\tentry.ctime.seconds = (git_time_t)ntohl(source.ctime.seconds);\n\tentry.ctime.nanoseconds = ntohl(source.ctime.nanoseconds);\n\tentry.mtime.seconds = (git_time_t)ntohl(source.mtime.seconds);\n\tentry.mtime.nanoseconds = ntohl(source.mtime.nanoseconds);\n\tentry.dev = ntohl(source.dev);\n\tentry.ino = ntohl(source.ino);\n\tentry.mode = ntohl(source.mode);\n\tentry.uid = ntohl(source.uid);\n\tentry.gid = ntohl(source.gid);\n\tentry.file_size = ntohl(source.file_size);\n\tgit_oid_cpy(&entry.id, &source.oid);\n\tentry.flags = ntohs(source.flags);\n\n\tif (entry.flags & GIT_IDXENTRY_EXTENDED) {\n\t\tuint16_t flags_raw;\n\t\tsize_t flags_offset;\n\n\t\tflags_offset = offsetof(struct entry_long, flags_extended);\n\t\tmemcpy(&flags_raw, (const char *) buffer + flags_offset,\n\t\t\tsizeof(flags_raw));\n\t\tflags_raw = ntohs(flags_raw);\n\n\t\tmemcpy(&entry.flags_extended, &flags_raw, sizeof(flags_raw));\n\t\tpath_ptr = (const char *) buffer + offsetof(struct entry_long, path);\n\t} else\n\t\tpath_ptr = (const char *) buffer + offsetof(struct entry_short, path);\n\n\tif (!compressed) {\n\t\tpath_length = entry.flags & GIT_IDXENTRY_NAMEMASK;\n\n\t\t/* if this is a very long string, we must find its\n\t\t * real length without overflowing */\n\t\tif (path_length == 0xFFF) {\n\t\t\tconst char *path_end;\n \n \t\t\tpath_end = memchr(path_ptr, '\\0', buffer_size);\n \t\t\tif (path_end == NULL)\n\t\t\t\treturn 0;\n \n \t\t\tpath_length = path_end - path_ptr;\n \t\t}\n\n\t\tentry_size = index_entry_size(path_length, 0, entry.flags);\n\t\tentry.path = (char *)path_ptr;\n\t} else {\n\t\tsize_t varint_len;\n\t\tsize_t strip_len = git_decode_varint((const unsigned char *)path_ptr,\n\t\t\t\t\t\t     &varint_len);\n\t\tsize_t last_len = strlen(last);\n\t\tsize_t prefix_len = last_len - strip_len;\n\t\tsize_t suffix_len = strlen(path_ptr + varint_len);\n\t\tsize_t path_len;\n\n\t\tif (varint_len == 0)\n\t\t\treturn index_error_invalid(\"incorrect prefix length\");\n\n\t\tGITERR_CHECK_ALLOC_ADD(&path_len, prefix_len, suffix_len);\n\t\tGITERR_CHECK_ALLOC_ADD(&path_len, path_len, 1);\n\t\ttmp_path = git__malloc(path_len);\n\t\tGITERR_CHECK_ALLOC(tmp_path);\n\n\t\tmemcpy(tmp_path, last, prefix_len);\n\t\tmemcpy(tmp_path + prefix_len, path_ptr + varint_len, suffix_len + 1);\n\t\tentry_size = index_entry_size(suffix_len, varint_len, entry.flags);\n \t\tentry.path = tmp_path;\n \t}\n \n \tif (INDEX_FOOTER_SIZE + entry_size > buffer_size)\n\t\treturn 0;\n \n \tif (index_entry_dup(out, index, &entry) < 0) {\n \t\tgit__free(tmp_path);\n\t\treturn 0;\n \t}\n \n \tgit__free(tmp_path);\n\treturn entry_size;\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144157,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "static size_t read_entry(\nstatic int read_entry(\n \tgit_index_entry **out,\n\tsize_t *out_size,\n \tgit_index *index,\n \tconst void *buffer,\n \tsize_t buffer_size,\n\tconst char *last)\n{\n\tsize_t path_length, entry_size;\n\tconst char *path_ptr;\n\tstruct entry_short source;\n\tgit_index_entry entry = {{0}};\n\tbool compressed = index->version >= INDEX_VERSION_NUMBER_COMP;\n \tchar *tmp_path = NULL;\n \n \tif (INDEX_FOOTER_SIZE + minimal_entry_size > buffer_size)\n\t\treturn -1;\n \n \t/* buffer is not guaranteed to be aligned */\n \tmemcpy(&source, buffer, sizeof(struct entry_short));\n\n\tentry.ctime.seconds = (git_time_t)ntohl(source.ctime.seconds);\n\tentry.ctime.nanoseconds = ntohl(source.ctime.nanoseconds);\n\tentry.mtime.seconds = (git_time_t)ntohl(source.mtime.seconds);\n\tentry.mtime.nanoseconds = ntohl(source.mtime.nanoseconds);\n\tentry.dev = ntohl(source.dev);\n\tentry.ino = ntohl(source.ino);\n\tentry.mode = ntohl(source.mode);\n\tentry.uid = ntohl(source.uid);\n\tentry.gid = ntohl(source.gid);\n\tentry.file_size = ntohl(source.file_size);\n\tgit_oid_cpy(&entry.id, &source.oid);\n\tentry.flags = ntohs(source.flags);\n\n\tif (entry.flags & GIT_IDXENTRY_EXTENDED) {\n\t\tuint16_t flags_raw;\n\t\tsize_t flags_offset;\n\n\t\tflags_offset = offsetof(struct entry_long, flags_extended);\n\t\tmemcpy(&flags_raw, (const char *) buffer + flags_offset,\n\t\t\tsizeof(flags_raw));\n\t\tflags_raw = ntohs(flags_raw);\n\n\t\tmemcpy(&entry.flags_extended, &flags_raw, sizeof(flags_raw));\n\t\tpath_ptr = (const char *) buffer + offsetof(struct entry_long, path);\n\t} else\n\t\tpath_ptr = (const char *) buffer + offsetof(struct entry_short, path);\n\n\tif (!compressed) {\n\t\tpath_length = entry.flags & GIT_IDXENTRY_NAMEMASK;\n\n\t\t/* if this is a very long string, we must find its\n\t\t * real length without overflowing */\n\t\tif (path_length == 0xFFF) {\n\t\t\tconst char *path_end;\n \n \t\t\tpath_end = memchr(path_ptr, '\\0', buffer_size);\n \t\t\tif (path_end == NULL)\n\t\t\t\treturn -1;\n \n \t\t\tpath_length = path_end - path_ptr;\n \t\t}\n\n\t\tentry_size = index_entry_size(path_length, 0, entry.flags);\n\t\tentry.path = (char *)path_ptr;\n\t} else {\n\t\tsize_t varint_len;\n\t\tsize_t strip_len = git_decode_varint((const unsigned char *)path_ptr,\n\t\t\t\t\t\t     &varint_len);\n\t\tsize_t last_len = strlen(last);\n\t\tsize_t prefix_len = last_len - strip_len;\n\t\tsize_t suffix_len = strlen(path_ptr + varint_len);\n\t\tsize_t path_len;\n\n\t\tif (varint_len == 0)\n\t\t\treturn index_error_invalid(\"incorrect prefix length\");\n\n\t\tGITERR_CHECK_ALLOC_ADD(&path_len, prefix_len, suffix_len);\n\t\tGITERR_CHECK_ALLOC_ADD(&path_len, path_len, 1);\n\t\ttmp_path = git__malloc(path_len);\n\t\tGITERR_CHECK_ALLOC(tmp_path);\n\n\t\tmemcpy(tmp_path, last, prefix_len);\n\t\tmemcpy(tmp_path + prefix_len, path_ptr + varint_len, suffix_len + 1);\n\t\tentry_size = index_entry_size(suffix_len, varint_len, entry.flags);\n \t\tentry.path = tmp_path;\n \t}\n \n\tif (entry_size == 0)\n\t\treturn -1;\n\n \tif (INDEX_FOOTER_SIZE + entry_size > buffer_size)\n\t\treturn -1;\n \n \tif (index_entry_dup(out, index, &entry) < 0) {\n \t\tgit__free(tmp_path);\n\t\treturn -1;\n \t}\n \n \tgit__free(tmp_path);\n\t*out_size = entry_size;\n\treturn 0;\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144158,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "static int amd_gpio_probe(struct platform_device *pdev)\n{\n\tint ret = 0;\n\tint irq_base;\n\tstruct resource *res;\n\tstruct amd_gpio *gpio_dev;\n\n\tgpio_dev = devm_kzalloc(&pdev->dev,\n\t\t\t\tsizeof(struct amd_gpio), GFP_KERNEL);\n\tif (!gpio_dev)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&gpio_dev->lock);\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"Failed to get gpio io resource.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tgpio_dev->base = devm_ioremap_nocache(&pdev->dev, res->start,\n\t\t\t\t\t\tresource_size(res));\n\tif (!gpio_dev->base)\n\t\treturn -ENOMEM;\n\n\tirq_base = platform_get_irq(pdev, 0);\n\tif (irq_base < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to get gpio IRQ.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tgpio_dev->pdev = pdev;\n\tgpio_dev->gc.direction_input\t= amd_gpio_direction_input;\n\tgpio_dev->gc.direction_output\t= amd_gpio_direction_output;\n\tgpio_dev->gc.get\t\t\t= amd_gpio_get_value;\n\tgpio_dev->gc.set\t\t\t= amd_gpio_set_value;\n\tgpio_dev->gc.set_debounce\t= amd_gpio_set_debounce;\n\tgpio_dev->gc.dbg_show\t\t= amd_gpio_dbg_show;\n\n\tgpio_dev->gc.base\t\t\t= 0;\n\tgpio_dev->gc.label\t\t\t= pdev->name;\n\tgpio_dev->gc.owner\t\t\t= THIS_MODULE;\n\tgpio_dev->gc.parent\t\t\t= &pdev->dev;\n\tgpio_dev->gc.ngpio\t\t\t= TOTAL_NUMBER_OF_PINS;\n#if defined(CONFIG_OF_GPIO)\n\tgpio_dev->gc.of_node\t\t\t= pdev->dev.of_node;\n#endif\n\n\tgpio_dev->groups = kerncz_groups;\n \tgpio_dev->ngroups = ARRAY_SIZE(kerncz_groups);\n \n \tamd_pinctrl_desc.name = dev_name(&pdev->dev);\n\tgpio_dev->pctrl = pinctrl_register(&amd_pinctrl_desc,\n\t\t\t\t\t&pdev->dev, gpio_dev);\n \tif (IS_ERR(gpio_dev->pctrl)) {\n \t\tdev_err(&pdev->dev, \"Couldn't register pinctrl driver\\n\");\n \t\treturn PTR_ERR(gpio_dev->pctrl);\n \t}\n \n \tret = gpiochip_add_data(&gpio_dev->gc, gpio_dev);\n \tif (ret)\n\t\tgoto out1;\n \n \tret = gpiochip_add_pin_range(&gpio_dev->gc, dev_name(&pdev->dev),\n \t\t\t\t0, 0, TOTAL_NUMBER_OF_PINS);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to add pin range\\n\");\n\t\tgoto out2;\n\t}\n\n\tret = gpiochip_irqchip_add(&gpio_dev->gc,\n\t\t\t\t&amd_gpio_irqchip,\n\t\t\t\t0,\n\t\t\t\thandle_simple_irq,\n\t\t\t\tIRQ_TYPE_NONE);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"could not add irqchip\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out2;\n\t}\n\n\tgpiochip_set_chained_irqchip(&gpio_dev->gc,\n\t\t\t\t &amd_gpio_irqchip,\n\t\t\t\t irq_base,\n\t\t\t\t amd_gpio_irq_handler);\n\n\tplatform_set_drvdata(pdev, gpio_dev);\n\n\tdev_dbg(&pdev->dev, \"amd gpio driver loaded\\n\");\n\treturn ret;\n\n out2:\n \tgpiochip_remove(&gpio_dev->gc);\n \nout1:\n\tpinctrl_unregister(gpio_dev->pctrl);\n \treturn ret;\n }\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144203,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "static int amd_gpio_probe(struct platform_device *pdev)\n{\n\tint ret = 0;\n\tint irq_base;\n\tstruct resource *res;\n\tstruct amd_gpio *gpio_dev;\n\n\tgpio_dev = devm_kzalloc(&pdev->dev,\n\t\t\t\tsizeof(struct amd_gpio), GFP_KERNEL);\n\tif (!gpio_dev)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&gpio_dev->lock);\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"Failed to get gpio io resource.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tgpio_dev->base = devm_ioremap_nocache(&pdev->dev, res->start,\n\t\t\t\t\t\tresource_size(res));\n\tif (!gpio_dev->base)\n\t\treturn -ENOMEM;\n\n\tirq_base = platform_get_irq(pdev, 0);\n\tif (irq_base < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to get gpio IRQ.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tgpio_dev->pdev = pdev;\n\tgpio_dev->gc.direction_input\t= amd_gpio_direction_input;\n\tgpio_dev->gc.direction_output\t= amd_gpio_direction_output;\n\tgpio_dev->gc.get\t\t\t= amd_gpio_get_value;\n\tgpio_dev->gc.set\t\t\t= amd_gpio_set_value;\n\tgpio_dev->gc.set_debounce\t= amd_gpio_set_debounce;\n\tgpio_dev->gc.dbg_show\t\t= amd_gpio_dbg_show;\n\n\tgpio_dev->gc.base\t\t\t= 0;\n\tgpio_dev->gc.label\t\t\t= pdev->name;\n\tgpio_dev->gc.owner\t\t\t= THIS_MODULE;\n\tgpio_dev->gc.parent\t\t\t= &pdev->dev;\n\tgpio_dev->gc.ngpio\t\t\t= TOTAL_NUMBER_OF_PINS;\n#if defined(CONFIG_OF_GPIO)\n\tgpio_dev->gc.of_node\t\t\t= pdev->dev.of_node;\n#endif\n\n\tgpio_dev->groups = kerncz_groups;\n \tgpio_dev->ngroups = ARRAY_SIZE(kerncz_groups);\n \n \tamd_pinctrl_desc.name = dev_name(&pdev->dev);\n\tgpio_dev->pctrl = devm_pinctrl_register(&pdev->dev, &amd_pinctrl_desc,\n\t\t\t\t\t\tgpio_dev);\n \tif (IS_ERR(gpio_dev->pctrl)) {\n \t\tdev_err(&pdev->dev, \"Couldn't register pinctrl driver\\n\");\n \t\treturn PTR_ERR(gpio_dev->pctrl);\n \t}\n \n \tret = gpiochip_add_data(&gpio_dev->gc, gpio_dev);\n \tif (ret)\n\t\treturn ret;\n \n \tret = gpiochip_add_pin_range(&gpio_dev->gc, dev_name(&pdev->dev),\n \t\t\t\t0, 0, TOTAL_NUMBER_OF_PINS);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to add pin range\\n\");\n\t\tgoto out2;\n\t}\n\n\tret = gpiochip_irqchip_add(&gpio_dev->gc,\n\t\t\t\t&amd_gpio_irqchip,\n\t\t\t\t0,\n\t\t\t\thandle_simple_irq,\n\t\t\t\tIRQ_TYPE_NONE);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"could not add irqchip\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out2;\n\t}\n\n\tgpiochip_set_chained_irqchip(&gpio_dev->gc,\n\t\t\t\t &amd_gpio_irqchip,\n\t\t\t\t irq_base,\n\t\t\t\t amd_gpio_irq_handler);\n\n\tplatform_set_drvdata(pdev, gpio_dev);\n\n\tdev_dbg(&pdev->dev, \"amd gpio driver loaded\\n\");\n\treturn ret;\n\n out2:\n \tgpiochip_remove(&gpio_dev->gc);\n \n \treturn ret;\n }\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144204,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "_zip_dirent_read(zip_dirent_t *zde, zip_source_t *src, zip_buffer_t *buffer, bool local, zip_error_t *error)\n{\n    zip_uint8_t buf[CDENTRYSIZE];\n    zip_uint16_t dostime, dosdate;\n    zip_uint32_t size, variable_size;\n    zip_uint16_t filename_len, comment_len, ef_len;\n\n    bool from_buffer = (buffer != NULL);\n\n    size = local ? LENTRYSIZE : CDENTRYSIZE;\n\n    if (buffer) {\n        if (_zip_buffer_left(buffer) < size) {\n            zip_error_set(error, ZIP_ER_NOZIP, 0);\n            return -1;\n        }\n    }\n    else {\n        if ((buffer = _zip_buffer_new_from_source(src, size, buf, error)) == NULL) {\n            return -1;\n        }\n    }\n\n    if (memcmp(_zip_buffer_get(buffer, 4), (local ? LOCAL_MAGIC : CENTRAL_MAGIC), 4) != 0) {\n\tzip_error_set(error, ZIP_ER_NOZIP, 0);\n        if (!from_buffer) {\n            _zip_buffer_free(buffer);\n        }\n\treturn -1;\n    }\n\n    /* convert buffercontents to zip_dirent */\n\n    _zip_dirent_init(zde);\n    if (!local)\n\tzde->version_madeby = _zip_buffer_get_16(buffer);\n    else\n\tzde->version_madeby = 0;\n    zde->version_needed = _zip_buffer_get_16(buffer);\n    zde->bitflags = _zip_buffer_get_16(buffer);\n    zde->comp_method = _zip_buffer_get_16(buffer);\n\n    /* convert to time_t */\n    dostime = _zip_buffer_get_16(buffer);\n    dosdate = _zip_buffer_get_16(buffer);\n    zde->last_mod = _zip_d2u_time(dostime, dosdate);\n\n    zde->crc = _zip_buffer_get_32(buffer);\n    zde->comp_size = _zip_buffer_get_32(buffer);\n    zde->uncomp_size = _zip_buffer_get_32(buffer);\n\n    filename_len = _zip_buffer_get_16(buffer);\n    ef_len = _zip_buffer_get_16(buffer);\n\n    if (local) {\n\tcomment_len = 0;\n\tzde->disk_number = 0;\n\tzde->int_attrib = 0;\n\tzde->ext_attrib = 0;\n\tzde->offset = 0;\n    } else {\n\tcomment_len = _zip_buffer_get_16(buffer);\n\tzde->disk_number = _zip_buffer_get_16(buffer);\n\tzde->int_attrib = _zip_buffer_get_16(buffer);\n\tzde->ext_attrib = _zip_buffer_get_32(buffer);\n\tzde->offset = _zip_buffer_get_32(buffer);\n    }\n\n    if (!_zip_buffer_ok(buffer)) {\n        zip_error_set(error, ZIP_ER_INTERNAL, 0);\n        if (!from_buffer) {\n            _zip_buffer_free(buffer);\n        }\n        return -1;\n    }\n\n    if (zde->bitflags & ZIP_GPBF_ENCRYPTED) {\n\tif (zde->bitflags & ZIP_GPBF_STRONG_ENCRYPTION) {\n\t    /* TODO */\n\t    zde->encryption_method = ZIP_EM_UNKNOWN;\n\t}\n\telse {\n\t    zde->encryption_method = ZIP_EM_TRAD_PKWARE;\n\t}\n    }\n    else {\n\tzde->encryption_method = ZIP_EM_NONE;\n    }\n\n    zde->filename = NULL;\n    zde->extra_fields = NULL;\n    zde->comment = NULL;\n\n    variable_size = (zip_uint32_t)filename_len+(zip_uint32_t)ef_len+(zip_uint32_t)comment_len;\n\n    if (from_buffer) {\n        if (_zip_buffer_left(buffer) < variable_size) {\n            zip_error_set(error, ZIP_ER_INCONS, 0);\n            return -1;\n        }\n    }\n    else {\n        _zip_buffer_free(buffer);\n\n        if ((buffer = _zip_buffer_new_from_source(src, variable_size, NULL, error)) == NULL) {\n            return -1;\n        }\n    }\n\n    if (filename_len) {\n\tzde->filename = _zip_read_string(buffer, src, filename_len, 1, error);\n        if (!zde->filename) {\n            if (zip_error_code_zip(error) == ZIP_ER_EOF) {\n                zip_error_set(error, ZIP_ER_INCONS, 0);\n            }\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n\t    return -1;\n        }\n\n\tif (zde->bitflags & ZIP_GPBF_ENCODING_UTF_8) {\n\t    if (_zip_guess_encoding(zde->filename, ZIP_ENCODING_UTF8_KNOWN) == ZIP_ENCODING_ERROR) {\n\t\tzip_error_set(error, ZIP_ER_INCONS, 0);\n                if (!from_buffer) {\n                    _zip_buffer_free(buffer);\n                }\n\t\treturn -1;\n\t    }\n\t}\n    }\n\n    if (ef_len) {\n\tzip_uint8_t *ef = _zip_read_data(buffer, src, ef_len, 0, error);\n\n        if (ef == NULL) {\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n\t    return -1;\n        }\n        if (!_zip_ef_parse(ef, ef_len, local ? ZIP_EF_LOCAL : ZIP_EF_CENTRAL, &zde->extra_fields, error)) {\n\t    free(ef);\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n\t    return -1;\n\t}\n\tfree(ef);\n\tif (local)\n\t    zde->local_extra_fields_read = 1;\n    }\n\n    if (comment_len) {\n\tzde->comment = _zip_read_string(buffer, src, comment_len, 0, error);\n        if (!zde->comment) {\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n\t    return -1;\n        }\n\tif (zde->bitflags & ZIP_GPBF_ENCODING_UTF_8) {\n\t    if (_zip_guess_encoding(zde->comment, ZIP_ENCODING_UTF8_KNOWN) == ZIP_ENCODING_ERROR) {\n\t\tzip_error_set(error, ZIP_ER_INCONS, 0);\n                if (!from_buffer) {\n                    _zip_buffer_free(buffer);\n                }\n\t\treturn -1;\n\t    }\n\t}\n    }\n\n    zde->filename = _zip_dirent_process_ef_utf_8(zde, ZIP_EF_UTF_8_NAME, zde->filename);\n    zde->comment = _zip_dirent_process_ef_utf_8(zde, ZIP_EF_UTF_8_COMMENT, zde->comment);\n\n    /* Zip64 */\n\n    if (zde->uncomp_size == ZIP_UINT32_MAX || zde->comp_size == ZIP_UINT32_MAX || zde->offset == ZIP_UINT32_MAX) {\n\tzip_uint16_t got_len;\n        zip_buffer_t *ef_buffer;\n\tconst zip_uint8_t *ef = _zip_ef_get_by_id(zde->extra_fields, &got_len, ZIP_EF_ZIP64, 0, local ? ZIP_EF_LOCAL : ZIP_EF_CENTRAL, error);\n\t/* TODO: if got_len == 0 && !ZIP64_EOCD: no error, 0xffffffff is valid value */\n        if (ef == NULL) {\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n\t    return -1;\n        }\n\n        if ((ef_buffer = _zip_buffer_new((zip_uint8_t *)ef, got_len)) == NULL) {\n            zip_error_set(error, ZIP_ER_MEMORY, 0);\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n            return -1;\n        }\n\n\tif (zde->uncomp_size == ZIP_UINT32_MAX)\n\t    zde->uncomp_size = _zip_buffer_get_64(ef_buffer);\n\telse if (local) {\n\t    /* From appnote.txt: This entry in the Local header MUST\n\t       include BOTH original and compressed file size fields. */\n            (void)_zip_buffer_skip(ef_buffer, 8); /* error is caught by _zip_buffer_eof() call */\n\t}\n\tif (zde->comp_size == ZIP_UINT32_MAX)\n\t    zde->comp_size = _zip_buffer_get_64(ef_buffer);\n\tif (!local) {\n\t    if (zde->offset == ZIP_UINT32_MAX)\n\t\tzde->offset = _zip_buffer_get_64(ef_buffer);\n\t    if (zde->disk_number == ZIP_UINT16_MAX)\n\t\tzde->disk_number = _zip_buffer_get_32(buffer);\n\t}\n\n        if (!_zip_buffer_eof(ef_buffer)) {\n            zip_error_set(error, ZIP_ER_INCONS, 0);\n            _zip_buffer_free(ef_buffer);\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n            return -1;\n        }\n        _zip_buffer_free(ef_buffer);\n    }\n\n    if (!_zip_buffer_ok(buffer)) {\n        zip_error_set(error, ZIP_ER_INTERNAL, 0);\n        if (!from_buffer) {\n            _zip_buffer_free(buffer);\n        }\n        return -1;\n    }\n    if (!from_buffer) {\n        _zip_buffer_free(buffer);\n    }\n\n    /* zip_source_seek / zip_source_tell don't support values > ZIP_INT64_MAX */\n    if (zde->offset > ZIP_INT64_MAX) {\n\tzip_error_set(error, ZIP_ER_SEEK, EFBIG);\n\treturn -1;\n     }\n \n     if (!_zip_dirent_process_winzip_aes(zde, error)) {\n\tif (!from_buffer) {\n\t    _zip_buffer_free(buffer);\n\t}\n \treturn -1;\n     }\n \n    zde->extra_fields = _zip_ef_remove_internal(zde->extra_fields);\n\n    return (zip_int64_t)(size + variable_size);\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144421,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "_zip_dirent_read(zip_dirent_t *zde, zip_source_t *src, zip_buffer_t *buffer, bool local, zip_error_t *error)\n{\n    zip_uint8_t buf[CDENTRYSIZE];\n    zip_uint16_t dostime, dosdate;\n    zip_uint32_t size, variable_size;\n    zip_uint16_t filename_len, comment_len, ef_len;\n\n    bool from_buffer = (buffer != NULL);\n\n    size = local ? LENTRYSIZE : CDENTRYSIZE;\n\n    if (buffer) {\n        if (_zip_buffer_left(buffer) < size) {\n            zip_error_set(error, ZIP_ER_NOZIP, 0);\n            return -1;\n        }\n    }\n    else {\n        if ((buffer = _zip_buffer_new_from_source(src, size, buf, error)) == NULL) {\n            return -1;\n        }\n    }\n\n    if (memcmp(_zip_buffer_get(buffer, 4), (local ? LOCAL_MAGIC : CENTRAL_MAGIC), 4) != 0) {\n\tzip_error_set(error, ZIP_ER_NOZIP, 0);\n        if (!from_buffer) {\n            _zip_buffer_free(buffer);\n        }\n\treturn -1;\n    }\n\n    /* convert buffercontents to zip_dirent */\n\n    _zip_dirent_init(zde);\n    if (!local)\n\tzde->version_madeby = _zip_buffer_get_16(buffer);\n    else\n\tzde->version_madeby = 0;\n    zde->version_needed = _zip_buffer_get_16(buffer);\n    zde->bitflags = _zip_buffer_get_16(buffer);\n    zde->comp_method = _zip_buffer_get_16(buffer);\n\n    /* convert to time_t */\n    dostime = _zip_buffer_get_16(buffer);\n    dosdate = _zip_buffer_get_16(buffer);\n    zde->last_mod = _zip_d2u_time(dostime, dosdate);\n\n    zde->crc = _zip_buffer_get_32(buffer);\n    zde->comp_size = _zip_buffer_get_32(buffer);\n    zde->uncomp_size = _zip_buffer_get_32(buffer);\n\n    filename_len = _zip_buffer_get_16(buffer);\n    ef_len = _zip_buffer_get_16(buffer);\n\n    if (local) {\n\tcomment_len = 0;\n\tzde->disk_number = 0;\n\tzde->int_attrib = 0;\n\tzde->ext_attrib = 0;\n\tzde->offset = 0;\n    } else {\n\tcomment_len = _zip_buffer_get_16(buffer);\n\tzde->disk_number = _zip_buffer_get_16(buffer);\n\tzde->int_attrib = _zip_buffer_get_16(buffer);\n\tzde->ext_attrib = _zip_buffer_get_32(buffer);\n\tzde->offset = _zip_buffer_get_32(buffer);\n    }\n\n    if (!_zip_buffer_ok(buffer)) {\n        zip_error_set(error, ZIP_ER_INTERNAL, 0);\n        if (!from_buffer) {\n            _zip_buffer_free(buffer);\n        }\n        return -1;\n    }\n\n    if (zde->bitflags & ZIP_GPBF_ENCRYPTED) {\n\tif (zde->bitflags & ZIP_GPBF_STRONG_ENCRYPTION) {\n\t    /* TODO */\n\t    zde->encryption_method = ZIP_EM_UNKNOWN;\n\t}\n\telse {\n\t    zde->encryption_method = ZIP_EM_TRAD_PKWARE;\n\t}\n    }\n    else {\n\tzde->encryption_method = ZIP_EM_NONE;\n    }\n\n    zde->filename = NULL;\n    zde->extra_fields = NULL;\n    zde->comment = NULL;\n\n    variable_size = (zip_uint32_t)filename_len+(zip_uint32_t)ef_len+(zip_uint32_t)comment_len;\n\n    if (from_buffer) {\n        if (_zip_buffer_left(buffer) < variable_size) {\n            zip_error_set(error, ZIP_ER_INCONS, 0);\n            return -1;\n        }\n    }\n    else {\n        _zip_buffer_free(buffer);\n\n        if ((buffer = _zip_buffer_new_from_source(src, variable_size, NULL, error)) == NULL) {\n            return -1;\n        }\n    }\n\n    if (filename_len) {\n\tzde->filename = _zip_read_string(buffer, src, filename_len, 1, error);\n        if (!zde->filename) {\n            if (zip_error_code_zip(error) == ZIP_ER_EOF) {\n                zip_error_set(error, ZIP_ER_INCONS, 0);\n            }\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n\t    return -1;\n        }\n\n\tif (zde->bitflags & ZIP_GPBF_ENCODING_UTF_8) {\n\t    if (_zip_guess_encoding(zde->filename, ZIP_ENCODING_UTF8_KNOWN) == ZIP_ENCODING_ERROR) {\n\t\tzip_error_set(error, ZIP_ER_INCONS, 0);\n                if (!from_buffer) {\n                    _zip_buffer_free(buffer);\n                }\n\t\treturn -1;\n\t    }\n\t}\n    }\n\n    if (ef_len) {\n\tzip_uint8_t *ef = _zip_read_data(buffer, src, ef_len, 0, error);\n\n        if (ef == NULL) {\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n\t    return -1;\n        }\n        if (!_zip_ef_parse(ef, ef_len, local ? ZIP_EF_LOCAL : ZIP_EF_CENTRAL, &zde->extra_fields, error)) {\n\t    free(ef);\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n\t    return -1;\n\t}\n\tfree(ef);\n\tif (local)\n\t    zde->local_extra_fields_read = 1;\n    }\n\n    if (comment_len) {\n\tzde->comment = _zip_read_string(buffer, src, comment_len, 0, error);\n        if (!zde->comment) {\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n\t    return -1;\n        }\n\tif (zde->bitflags & ZIP_GPBF_ENCODING_UTF_8) {\n\t    if (_zip_guess_encoding(zde->comment, ZIP_ENCODING_UTF8_KNOWN) == ZIP_ENCODING_ERROR) {\n\t\tzip_error_set(error, ZIP_ER_INCONS, 0);\n                if (!from_buffer) {\n                    _zip_buffer_free(buffer);\n                }\n\t\treturn -1;\n\t    }\n\t}\n    }\n\n    zde->filename = _zip_dirent_process_ef_utf_8(zde, ZIP_EF_UTF_8_NAME, zde->filename);\n    zde->comment = _zip_dirent_process_ef_utf_8(zde, ZIP_EF_UTF_8_COMMENT, zde->comment);\n\n    /* Zip64 */\n\n    if (zde->uncomp_size == ZIP_UINT32_MAX || zde->comp_size == ZIP_UINT32_MAX || zde->offset == ZIP_UINT32_MAX) {\n\tzip_uint16_t got_len;\n        zip_buffer_t *ef_buffer;\n\tconst zip_uint8_t *ef = _zip_ef_get_by_id(zde->extra_fields, &got_len, ZIP_EF_ZIP64, 0, local ? ZIP_EF_LOCAL : ZIP_EF_CENTRAL, error);\n\t/* TODO: if got_len == 0 && !ZIP64_EOCD: no error, 0xffffffff is valid value */\n        if (ef == NULL) {\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n\t    return -1;\n        }\n\n        if ((ef_buffer = _zip_buffer_new((zip_uint8_t *)ef, got_len)) == NULL) {\n            zip_error_set(error, ZIP_ER_MEMORY, 0);\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n            return -1;\n        }\n\n\tif (zde->uncomp_size == ZIP_UINT32_MAX)\n\t    zde->uncomp_size = _zip_buffer_get_64(ef_buffer);\n\telse if (local) {\n\t    /* From appnote.txt: This entry in the Local header MUST\n\t       include BOTH original and compressed file size fields. */\n            (void)_zip_buffer_skip(ef_buffer, 8); /* error is caught by _zip_buffer_eof() call */\n\t}\n\tif (zde->comp_size == ZIP_UINT32_MAX)\n\t    zde->comp_size = _zip_buffer_get_64(ef_buffer);\n\tif (!local) {\n\t    if (zde->offset == ZIP_UINT32_MAX)\n\t\tzde->offset = _zip_buffer_get_64(ef_buffer);\n\t    if (zde->disk_number == ZIP_UINT16_MAX)\n\t\tzde->disk_number = _zip_buffer_get_32(buffer);\n\t}\n\n        if (!_zip_buffer_eof(ef_buffer)) {\n            zip_error_set(error, ZIP_ER_INCONS, 0);\n            _zip_buffer_free(ef_buffer);\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n            return -1;\n        }\n        _zip_buffer_free(ef_buffer);\n    }\n\n    if (!_zip_buffer_ok(buffer)) {\n        zip_error_set(error, ZIP_ER_INTERNAL, 0);\n        if (!from_buffer) {\n            _zip_buffer_free(buffer);\n        }\n        return -1;\n    }\n    if (!from_buffer) {\n        _zip_buffer_free(buffer);\n    }\n\n    /* zip_source_seek / zip_source_tell don't support values > ZIP_INT64_MAX */\n    if (zde->offset > ZIP_INT64_MAX) {\n\tzip_error_set(error, ZIP_ER_SEEK, EFBIG);\n\treturn -1;\n     }\n \n     if (!_zip_dirent_process_winzip_aes(zde, error)) {\n \treturn -1;\n     }\n \n    zde->extra_fields = _zip_ef_remove_internal(zde->extra_fields);\n\n    return (zip_int64_t)(size + variable_size);\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144422,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "read_gif(Gif_Reader *grr, int read_flags,\n\t const char* landmark, Gif_ReadErrorHandler handler)\n{\n  Gif_Stream *gfs;\n  Gif_Image *gfi;\n  Gif_Context gfc;\n  int unknown_block_type = 0;\n\n  if (gifgetc(grr) != 'G' ||\n      gifgetc(grr) != 'I' ||\n      gifgetc(grr) != 'F')\n    return 0;\n  (void)gifgetc(grr);\n  (void)gifgetc(grr);\n  (void)gifgetc(grr);\n\n  gfs = Gif_NewStream();\n  gfi = Gif_NewImage();\n\n  gfc.stream = gfs;\n  gfc.prefix = Gif_NewArray(Gif_Code, GIF_MAX_CODE);\n  gfc.suffix = Gif_NewArray(uint8_t, GIF_MAX_CODE);\n  gfc.length = Gif_NewArray(uint16_t, GIF_MAX_CODE);\n  gfc.handler = handler;\n  gfc.gfi = gfi;\n  gfc.errors[0] = gfc.errors[1] = 0;\n\n  if (!gfs || !gfi || !gfc.prefix || !gfc.suffix || !gfc.length)\n    goto done;\n  gfs->landmark = landmark;\n\n  GIF_DEBUG((\"\\nGIF \"));\n  if (!read_logical_screen_descriptor(gfs, grr))\n    goto done;\n  GIF_DEBUG((\"logscrdesc \"));\n\n  while (!gifeof(grr)) {\n\n    uint8_t block = gifgetbyte(grr);\n\n    switch (block) {\n\n     case ',': /* image block */\n      GIF_DEBUG((\"imageread %d \", gfs->nimages));\n\n      gfi->identifier = last_name;\n      last_name = 0;\n      if (!Gif_AddImage(gfs, gfi))\n          goto done;\n      else if (!read_image(grr, &gfc, gfi, read_flags)) {\n          Gif_RemoveImage(gfs, gfs->nimages - 1);\n          gfi = 0;\n          goto done;\n      }\n\n      gfc.gfi = gfi = Gif_NewImage();\n      if (!gfi)\n          goto done;\n      break;\n\n     case ';': /* terminator */\n      GIF_DEBUG((\"term\\n\"));\n      goto done;\n\n     case '!': /* extension */\n      block = gifgetbyte(grr);\n      GIF_DEBUG((\"ext(0x%02X) \", block));\n      switch (block) {\n\n       case 0xF9:\n\tread_graphic_control_extension(&gfc, gfi, grr);\n\tbreak;\n\n       case 0xCE:\n\tlast_name = suck_data(last_name, 0, grr);\n\tbreak;\n\n       case 0xFE:\n\tif (!read_comment_extension(gfi, grr)) goto done;\n\tbreak;\n\n       case 0xFF:\n\tread_application_extension(&gfc, grr);\n\tbreak;\n\n       default:\n        read_unknown_extension(&gfc, grr, block, 0, 0);\n\tbreak;\n\n      }\n      break;\n\n     default:\n       if (!unknown_block_type) {\n\t char buf[256];\n\t sprintf(buf, \"unknown block type %d at file offset %u\", block, grr->pos - 1);\n\t gif_read_error(&gfc, 1, buf);\n\t unknown_block_type = 1;\n       }\n       break;\n\n    }\n\n  }\n\n done:\n\n  /* Move comments and extensions after last image into stream. */\n  if (gfs && gfi) {\n      Gif_Extension* gfex;\n      gfs->end_comment = gfi->comment;\n      gfi->comment = 0;\n      gfs->end_extension_list = gfi->extension_list;\n      gfi->extension_list = 0;\n      for (gfex = gfs->end_extension_list; gfex; gfex = gfex->next)\n          gfex->image = NULL;\n  }\n\n  Gif_DeleteImage(gfi);\n  Gif_DeleteArray(last_name);\n  Gif_DeleteArray(gfc.prefix);\n   Gif_DeleteArray(gfc.suffix);\n   Gif_DeleteArray(gfc.length);\n   gfc.gfi = 0;\n \n   if (gfs)\n     gfs->errors = gfc.errors[1];\n  if (gfs && gfc.errors[1] == 0\n      && !(read_flags & GIF_READ_TRAILING_GARBAGE_OK)\n      && !grr->eofer(grr))\n      gif_read_error(&gfc, 0, \"trailing garbage after GIF ignored\");\n  /* finally, export last message */\n  gif_read_error(&gfc, -1, 0);\n\n  return gfs;\n}\n",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144453,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "read_gif(Gif_Reader *grr, int read_flags,\n\t const char* landmark, Gif_ReadErrorHandler handler)\n{\n  Gif_Stream *gfs;\n  Gif_Image *gfi;\n  Gif_Context gfc;\n  int unknown_block_type = 0;\n\n  if (gifgetc(grr) != 'G' ||\n      gifgetc(grr) != 'I' ||\n      gifgetc(grr) != 'F')\n    return 0;\n  (void)gifgetc(grr);\n  (void)gifgetc(grr);\n  (void)gifgetc(grr);\n\n  gfs = Gif_NewStream();\n  gfi = Gif_NewImage();\n\n  gfc.stream = gfs;\n  gfc.prefix = Gif_NewArray(Gif_Code, GIF_MAX_CODE);\n  gfc.suffix = Gif_NewArray(uint8_t, GIF_MAX_CODE);\n  gfc.length = Gif_NewArray(uint16_t, GIF_MAX_CODE);\n  gfc.handler = handler;\n  gfc.gfi = gfi;\n  gfc.errors[0] = gfc.errors[1] = 0;\n\n  if (!gfs || !gfi || !gfc.prefix || !gfc.suffix || !gfc.length)\n    goto done;\n  gfs->landmark = landmark;\n\n  GIF_DEBUG((\"\\nGIF \"));\n  if (!read_logical_screen_descriptor(gfs, grr))\n    goto done;\n  GIF_DEBUG((\"logscrdesc \"));\n\n  while (!gifeof(grr)) {\n\n    uint8_t block = gifgetbyte(grr);\n\n    switch (block) {\n\n     case ',': /* image block */\n      GIF_DEBUG((\"imageread %d \", gfs->nimages));\n\n      gfi->identifier = last_name;\n      last_name = 0;\n      if (!Gif_AddImage(gfs, gfi))\n          goto done;\n      else if (!read_image(grr, &gfc, gfi, read_flags)) {\n          Gif_RemoveImage(gfs, gfs->nimages - 1);\n          gfi = 0;\n          goto done;\n      }\n\n      gfc.gfi = gfi = Gif_NewImage();\n      if (!gfi)\n          goto done;\n      break;\n\n     case ';': /* terminator */\n      GIF_DEBUG((\"term\\n\"));\n      goto done;\n\n     case '!': /* extension */\n      block = gifgetbyte(grr);\n      GIF_DEBUG((\"ext(0x%02X) \", block));\n      switch (block) {\n\n       case 0xF9:\n\tread_graphic_control_extension(&gfc, gfi, grr);\n\tbreak;\n\n       case 0xCE:\n\tlast_name = suck_data(last_name, 0, grr);\n\tbreak;\n\n       case 0xFE:\n\tif (!read_comment_extension(gfi, grr)) goto done;\n\tbreak;\n\n       case 0xFF:\n\tread_application_extension(&gfc, grr);\n\tbreak;\n\n       default:\n        read_unknown_extension(&gfc, grr, block, 0, 0);\n\tbreak;\n\n      }\n      break;\n\n     default:\n       if (!unknown_block_type) {\n\t char buf[256];\n\t sprintf(buf, \"unknown block type %d at file offset %u\", block, grr->pos - 1);\n\t gif_read_error(&gfc, 1, buf);\n\t unknown_block_type = 1;\n       }\n       break;\n\n    }\n\n  }\n\n done:\n\n  /* Move comments and extensions after last image into stream. */\n  if (gfs && gfi) {\n      Gif_Extension* gfex;\n      gfs->end_comment = gfi->comment;\n      gfi->comment = 0;\n      gfs->end_extension_list = gfi->extension_list;\n      gfi->extension_list = 0;\n      for (gfex = gfs->end_extension_list; gfex; gfex = gfex->next)\n          gfex->image = NULL;\n  }\n\n  Gif_DeleteImage(gfi);\n  Gif_DeleteArray(last_name);\n  Gif_DeleteArray(gfc.prefix);\n   Gif_DeleteArray(gfc.suffix);\n   Gif_DeleteArray(gfc.length);\n   gfc.gfi = 0;\n  last_name = 0;\n \n   if (gfs)\n     gfs->errors = gfc.errors[1];\n  if (gfs && gfc.errors[1] == 0\n      && !(read_flags & GIF_READ_TRAILING_GARBAGE_OK)\n      && !grr->eofer(grr))\n      gif_read_error(&gfc, 0, \"trailing garbage after GIF ignored\");\n  /* finally, export last message */\n  gif_read_error(&gfc, -1, 0);\n\n  return gfs;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144454,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "static int do_session_handshake (lua_State *L, int status, lua_KContext ctx) {\n    int rc;\n    struct ssh_userdata *sshu = NULL;\n\n    assert(lua_gettop(L) == 4);\n    sshu = (struct ssh_userdata *) nseU_checkudata(L, 3, SSH2_UDATA, \"ssh2\");\n\n    while ((rc = libssh2_session_handshake(sshu->session, sshu->sp[0])) == LIBSSH2_ERROR_EAGAIN) {\n        luaL_getmetafield(L, 3, \"filter\");\n        lua_pushvalue(L, 3);\n\n        assert(lua_status(L) == LUA_OK);\n        lua_callk(L, 1, 0, 0, do_session_handshake);\n    }\n\n    if (rc) {\n        libssh2_session_free(sshu->session);\n        return luaL_error(L, \"Unable to complete libssh2 handshake.\");\n    }\n\n    // lua_pushvalue(L, 3);\n    lua_settop(L, 3);\n\n    return 1;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144647,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "static int do_session_handshake (lua_State *L, int status, lua_KContext ctx) {\n    int rc;\n    struct ssh_userdata *sshu = NULL;\n\n    assert(lua_gettop(L) == 4);\n    sshu = (struct ssh_userdata *) nseU_checkudata(L, 3, SSH2_UDATA, \"ssh2\");\n\n    while ((rc = libssh2_session_handshake(sshu->session, sshu->sp[0])) == LIBSSH2_ERROR_EAGAIN) {\n        luaL_getmetafield(L, 3, \"filter\");\n        lua_pushvalue(L, 3);\n\n        assert(lua_status(L) == LUA_OK);\n        lua_callk(L, 1, 0, 0, do_session_handshake);\n    }\n \n     if (rc) {\n         libssh2_session_free(sshu->session);\n        sshu->session = NULL;\n         return luaL_error(L, \"Unable to complete libssh2 handshake.\");\n     }\n \n    lua_settop(L, 3);\n\n    return 1;\n}\n",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144648,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "void gf_av1_reset_state(AV1State *state, Bool is_destroy)\n{\n\tGF_List *l1, *l2;\n\n\tif (state->frame_state.header_obus) {\n\t\twhile (gf_list_count(state->frame_state.header_obus)) {\n\t\t\tGF_AV1_OBUArrayEntry *a = (GF_AV1_OBUArrayEntry*)gf_list_pop_back(state->frame_state.header_obus);\n\t\t\tif (a->obu) gf_free(a->obu);\n\t\t\tgf_free(a);\n\t\t}\n\t}\n\n\tif (state->frame_state.frame_obus) {\n\t\twhile (gf_list_count(state->frame_state.frame_obus)) {\n\t\t\tGF_AV1_OBUArrayEntry *a = (GF_AV1_OBUArrayEntry*)gf_list_pop_back(state->frame_state.frame_obus);\n\t\t\tif (a->obu) gf_free(a->obu);\n\t\t\tgf_free(a);\n\t\t}\n\t}\n\tl1 = state->frame_state.frame_obus;\n\tl2 = state->frame_state.header_obus;\n\tmemset(&state->frame_state, 0, sizeof(AV1StateFrame));\n\tstate->frame_state.is_first_frame = GF_TRUE;\n\n\tif (is_destroy) {\n\t\tgf_list_del(l1);\n\t\tgf_list_del(l2);\n\t\tif (state->bs) {\n\t\t\tif (gf_bs_get_position(state->bs)) {\n\t\t\t\tu32 size;\n\t\t\t\tgf_bs_get_content_no_truncate(state->bs, &state->frame_obus, &size, &state->frame_obus_alloc);\n\t\t\t}\n\t\t\tgf_bs_del(state->bs);\n\t\t}\n\t\tstate->bs = NULL;\n\t}\n\telse {\n\t\tstate->frame_state.frame_obus = l1;\n\t\tstate->frame_state.header_obus = l2;\n\t\tif (state->bs)\n\t\t\tgf_bs_seek(state->bs, 0);\n\t}\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144671,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "void gf_av1_reset_state(AV1State *state, Bool is_destroy)\n{\n\tGF_List *l1, *l2;\n\n\tif (state->frame_state.header_obus) {\n\t\twhile (gf_list_count(state->frame_state.header_obus)) {\n\t\t\tGF_AV1_OBUArrayEntry *a = (GF_AV1_OBUArrayEntry*)gf_list_pop_back(state->frame_state.header_obus);\n\t\t\tif (a->obu) gf_free(a->obu);\n\t\t\tgf_free(a);\n\t\t}\n\t}\n\n\tif (state->frame_state.frame_obus) {\n\t\twhile (gf_list_count(state->frame_state.frame_obus)) {\n\t\t\tGF_AV1_OBUArrayEntry *a = (GF_AV1_OBUArrayEntry*)gf_list_pop_back(state->frame_state.frame_obus);\n\t\t\tif (a->obu) gf_free(a->obu);\n\t\t\tgf_free(a);\n\t\t}\n\t}\n\tl1 = state->frame_state.frame_obus;\n\tl2 = state->frame_state.header_obus;\n\tmemset(&state->frame_state, 0, sizeof(AV1StateFrame));\n\tstate->frame_state.is_first_frame = GF_TRUE;\n\n\tif (is_destroy) {\n\t\tgf_list_del(l1);\n\t\tgf_list_del(l2);\n\t\tif (state->bs) {\n\t\t\tu32 size;\n\t\t\tgf_bs_get_content_no_truncate(state->bs, &state->frame_obus, &size, &state->frame_obus_alloc);\n\t\t\tgf_bs_del(state->bs);\n\t\t}\n\t\tstate->bs = NULL;\n\t}\n\telse {\n\t\tstate->frame_state.frame_obus = l1;\n\t\tstate->frame_state.header_obus = l2;\n\t\tif (state->bs)\n\t\t\tgf_bs_seek(state->bs, 0);\n\t}\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144672,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "static s32 gf_avc_read_sps_bs_internal(GF_BitStream *bs, AVCState *avc, u32 subseq_sps, u32 *vui_flag_pos, u32 nal_hdr)\n{\n\tAVC_SPS *sps;\n\ts32 mb_width, mb_height, sps_id = -1;\n\tu32 profile_idc, level_idc, pcomp, i, chroma_format_idc, cl = 0, cr = 0, ct = 0, cb = 0, luma_bd, chroma_bd;\n\tu8 separate_colour_plane_flag = 0;\n\n\tif (!vui_flag_pos) {\n\t\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\t}\n\n\tif (!bs) {\n\t\treturn -1;\n\t}\n\n\tif (!nal_hdr) {\n\t\tgf_bs_read_int_log(bs, 1, \"forbidden_zero_bit\");\n\t\tgf_bs_read_int_log(bs, 2, \"nal_ref_idc\");\n\t\tgf_bs_read_int_log(bs, 5, \"nal_unit_type\");\n\t}\n\tprofile_idc = gf_bs_read_int_log(bs, 8, \"profile_idc\");\n\n\tpcomp = gf_bs_read_int_log(bs, 8, \"profile_compatibility\");\n\t/*sanity checks*/\n\tif (pcomp & 0x3)\n\t\treturn -1;\n\n\tlevel_idc = gf_bs_read_int_log(bs, 8, \"level_idc\");\n\n\t/*SubsetSps is used to be sure that AVC SPS are not going to be scratched\n\tby subset SPS. According to the SVC standard, subset SPS can have the same sps_id\n\tthan its base layer, but it does not refer to the same SPS. */\n\tsps_id = gf_bs_read_ue_log(bs, \"sps_id\") + GF_SVC_SSPS_ID_SHIFT * subseq_sps;\n\tif ((sps_id < 0) || (sps_id >= 32)) {\n\t\treturn -1;\n\t}\n\n\tluma_bd = chroma_bd = 0;\n\tsps = &avc->sps[sps_id];\n\tchroma_format_idc = sps->ChromaArrayType = 1;\n\tsps->state |= subseq_sps ? AVC_SUBSPS_PARSED : AVC_SPS_PARSED;\n\n\t/*High Profile and SVC*/\n\tswitch (profile_idc) {\n\tcase 100:\n\tcase 110:\n\tcase 122:\n\tcase 244:\n\tcase 44:\n\t\t/*sanity checks: note1 from 7.4.2.1.1 of iso/iec 14496-10-N11084*/\n\t\tif (pcomp & 0xE0)\n\t\t\treturn -1;\n\tcase 83:\n\tcase 86:\n\tcase 118:\n\tcase 128:\n\t\tchroma_format_idc = gf_bs_read_ue_log(bs, \"chroma_format_idc\");\n\t\tsps->ChromaArrayType = chroma_format_idc;\n\t\tif (chroma_format_idc == 3) {\n\t\t\tseparate_colour_plane_flag = gf_bs_read_int_log(bs, 1, \"separate_colour_plane_flag\");\n\t\t\t/*\n\t\t\tDepending on the value of separate_colour_plane_flag, the value of the variable ChromaArrayType is assigned as follows.\n\t\t\t\\96\tIf separate_colour_plane_flag is equal to 0, ChromaArrayType is set equal to chroma_format_idc.\n\t\t\t\\96\tOtherwise (separate_colour_plane_flag is equal to 1), ChromaArrayType is set equal to 0.\n\t\t\t*/\n\t\t\tif (separate_colour_plane_flag) sps->ChromaArrayType = 0;\n\t\t}\n\t\tluma_bd = gf_bs_read_ue_log(bs, \"luma_bit_depth\");\n\t\tchroma_bd = gf_bs_read_ue_log(bs, \"chroma_bit_depth\");\n\t\t/*qpprime_y_zero_transform_bypass_flag = */ gf_bs_read_int_log(bs, 1, \"qpprime_y_zero_transform_bypass_flag\");\n\t\t/*seq_scaling_matrix_present_flag*/\n\t\tif (gf_bs_read_int_log(bs, 1, \"seq_scaling_matrix_present_flag\")) {\n\t\t\tu32 k;\n\t\t\tfor (k = 0; k < 8; k++) {\n\t\t\t\tif (gf_bs_read_int_log_idx(bs, 1, \"seq_scaling_list_present_flag\", k)) {\n\t\t\t\t\tu32 z, last = 8, next = 8;\n\t\t\t\t\tu32 sl = k < 6 ? 16 : 64;\n\t\t\t\t\tfor (z = 0; z < sl; z++) {\n\t\t\t\t\t\tif (next) {\n\t\t\t\t\t\t\ts32 delta = gf_bs_read_se(bs);\n\t\t\t\t\t\t\tnext = (last + delta + 256) % 256;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlast = next ? next : last;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tsps->profile_idc = profile_idc;\n\tsps->level_idc = level_idc;\n\tsps->prof_compat = pcomp;\n\tsps->log2_max_frame_num = gf_bs_read_ue_log(bs, \"log2_max_frame_num\") + 4;\n\tsps->poc_type = gf_bs_read_ue_log(bs, \"poc_type\");\n\tsps->chroma_format = chroma_format_idc;\n\tsps->luma_bit_depth_m8 = luma_bd;\n\tsps->chroma_bit_depth_m8 = chroma_bd;\n\n\tif (sps->poc_type == 0) {\n\t\tsps->log2_max_poc_lsb = gf_bs_read_ue_log(bs, \"log2_max_poc_lsb\") + 4;\n\t}\n\telse if (sps->poc_type == 1) {\n\t\tsps->delta_pic_order_always_zero_flag = gf_bs_read_int_log(bs, 1, \"delta_pic_order_always_zero_flag\");\n\t\tsps->offset_for_non_ref_pic = gf_bs_read_se_log(bs, \"offset_for_non_ref_pic\");\n\t\tsps->offset_for_top_to_bottom_field = gf_bs_read_se_log(bs, \"offset_for_top_to_bottom_field\");\n\t\tsps->poc_cycle_length = gf_bs_read_ue_log(bs, \"poc_cycle_length\");\n\t\tif (sps->poc_cycle_length > GF_ARRAY_LENGTH(sps->offset_for_ref_frame)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[avc-h264] offset_for_ref_frame overflow from poc_cycle_length\\n\"));\n\t\t\treturn -1;\n\t\t}\n\t\tfor (i = 0; i < sps->poc_cycle_length; i++)\n\t\t\tsps->offset_for_ref_frame[i] = gf_bs_read_se_log_idx(bs, \"offset_for_ref_frame\", i);\n\t}\n\tif (sps->poc_type > 2) {\n\t\treturn -1;\n\t}\n\tsps->max_num_ref_frames = gf_bs_read_ue_log(bs, \"max_num_ref_frames\");\n\tsps->gaps_in_frame_num_value_allowed_flag = gf_bs_read_int_log(bs, 1, \"gaps_in_frame_num_value_allowed_flag\");\n\tmb_width = gf_bs_read_ue_log(bs, \"pic_width_in_mbs_minus1\") + 1;\n\tmb_height = gf_bs_read_ue_log(bs, \"pic_height_in_map_units_minus1\") + 1;\n\n\tsps->frame_mbs_only_flag = gf_bs_read_int_log(bs, 1, \"frame_mbs_only_flag\");\n\n\tsps->width = mb_width * 16;\n\tsps->height = (2 - sps->frame_mbs_only_flag) * mb_height * 16;\n\n\tif (!sps->frame_mbs_only_flag) sps->mb_adaptive_frame_field_flag = gf_bs_read_int_log(bs, 1, \"mb_adaptive_frame_field_flag\");\n\tgf_bs_read_int_log(bs, 1, \"direct_8x8_inference_flag\");\n\n\tif (gf_bs_read_int_log(bs, 1, \"frame_cropping_flag\")) {\n\t\tint CropUnitX, CropUnitY, SubWidthC = -1, SubHeightC = -1;\n\n\t\tif (chroma_format_idc == 1) {\n\t\t\tSubWidthC = 2; SubHeightC = 2;\n\t\t}\n\t\telse if (chroma_format_idc == 2) {\n\t\t\tSubWidthC = 2; SubHeightC = 1;\n\t\t}\n\t\telse if ((chroma_format_idc == 3) && (separate_colour_plane_flag == 0)) {\n\t\t\tSubWidthC = 1; SubHeightC = 1;\n\t\t}\n\n\t\tif (sps->ChromaArrayType == 0) {\n\t\t\tassert(SubWidthC == -1);\n\t\t\tCropUnitX = 1;\n\t\t\tCropUnitY = 2 - sps->frame_mbs_only_flag;\n\t\t}\n\t\telse {\n\t\t\tCropUnitX = SubWidthC;\n\t\t\tCropUnitY = SubHeightC * (2 - sps->frame_mbs_only_flag);\n\t\t}\n\n\t\tcl = gf_bs_read_ue_log(bs, \"frame_crop_left_offset\");\n\t\tcr = gf_bs_read_ue_log(bs, \"frame_crop_right_offset\");\n\t\tct = gf_bs_read_ue_log(bs, \"frame_crop_top_offset\");\n\t\tcb = gf_bs_read_ue_log(bs, \"frame_crop_bottom_offset\");\n\n\t\tsps->width -= CropUnitX * (cl + cr);\n\t\tsps->height -= CropUnitY * (ct + cb);\n\t\tcl *= CropUnitX;\n\t\tcr *= CropUnitX;\n\t\tct *= CropUnitY;\n\t\tcb *= CropUnitY;\n\t}\n\tsps->crop.left = cl;\n\tsps->crop.right = cr;\n\tsps->crop.top = ct;\n\tsps->crop.bottom = cb;\n\n\tif (vui_flag_pos) {\n\t\t*vui_flag_pos = (u32)gf_bs_get_bit_offset(bs);\n\t}\n\t/*vui_parameters_present_flag*/\n\tsps->vui_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vui_parameters_present_flag\");\n\tif (sps->vui_parameters_present_flag) {\n\t\tsps->vui.aspect_ratio_info_present_flag = gf_bs_read_int_log(bs, 1, \"aspect_ratio_info_present_flag\");\n\t\tif (sps->vui.aspect_ratio_info_present_flag) {\n\t\t\ts32 aspect_ratio_idc = gf_bs_read_int_log(bs, 8, \"aspect_ratio_idc\");\n\t\t\tif (aspect_ratio_idc == 255) {\n\t\t\t\tsps->vui.par_num = gf_bs_read_int_log(bs, 16, \"aspect_ratio_num\");\n\t\t\t\tsps->vui.par_den = gf_bs_read_int_log(bs, 16, \"aspect_ratio_den\");\n\t\t\t}\n\t\t\telse if (aspect_ratio_idc < GF_ARRAY_LENGTH(avc_hevc_sar) ) {\n\t\t\t\tsps->vui.par_num = avc_hevc_sar[aspect_ratio_idc].w;\n\t\t\t\tsps->vui.par_den = avc_hevc_sar[aspect_ratio_idc].h;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[avc-h264] Unknown aspect_ratio_idc: your video may have a wrong aspect ratio. Contact the GPAC team!\\n\"));\n\t\t\t}\n\t\t}\n\t\tsps->vui.overscan_info_present_flag = gf_bs_read_int_log(bs, 1, \"overscan_info_present_flag\");\n\t\tif (sps->vui.overscan_info_present_flag)\n\t\t\tgf_bs_read_int_log(bs, 1, \"overscan_appropriate_flag\");\n\n\t\t/* default values */\n\t\tsps->vui.video_format = 5;\n\t\tsps->vui.colour_primaries = 2;\n\t\tsps->vui.transfer_characteristics = 2;\n\t\tsps->vui.matrix_coefficients = 2;\n\t\t/* now read values if possible */\n\t\tsps->vui.video_signal_type_present_flag = gf_bs_read_int_log(bs, 1, \"video_signal_type_present_flag\");\n\t\tif (sps->vui.video_signal_type_present_flag) {\n\t\t\tsps->vui.video_format = gf_bs_read_int_log(bs, 3, \"video_format\");\n\t\t\tsps->vui.video_full_range_flag = gf_bs_read_int_log(bs, 1, \"video_full_range_flag\");\n\t\t\tsps->vui.colour_description_present_flag = gf_bs_read_int_log(bs, 1, \"colour_description_present_flag\");\n\t\t\tif (sps->vui.colour_description_present_flag) {\n\t\t\t\tsps->vui.colour_primaries = gf_bs_read_int_log(bs, 8, \"colour_primaries\");\n\t\t\t\tsps->vui.transfer_characteristics = gf_bs_read_int_log(bs, 8, \"transfer_characteristics\");\n\t\t\t\tsps->vui.matrix_coefficients = gf_bs_read_int_log(bs, 8, \"matrix_coefficients\");\n\t\t\t}\n\t\t}\n\n\t\tif (gf_bs_read_int_log(bs, 1, \"chroma_location_info_present_flag\")) {\n\t\t\tgf_bs_read_ue_log(bs, \"chroma_sample_location_type_top_field\");\n\t\t\tgf_bs_read_ue_log(bs, \"chroma_sample_location_type_bottom_field\");\n\t\t}\n\n\t\tsps->vui.timing_info_present_flag = gf_bs_read_int_log(bs, 1, \"timing_info_present_flag\");\n\t\tif (sps->vui.timing_info_present_flag) {\n\t\t\tsps->vui.num_units_in_tick = gf_bs_read_int_log(bs, 32, \"num_units_in_tick\");\n\t\t\tsps->vui.time_scale = gf_bs_read_int_log(bs, 32, \"time_scale\");\n\t\t\tsps->vui.fixed_frame_rate_flag = gf_bs_read_int_log(bs, 1, \"fixed_frame_rate_flag\");\n\t\t}\n\n\t\tsps->vui.nal_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"nal_hrd_parameters_present_flag\");\n\t\tif (sps->vui.nal_hrd_parameters_present_flag)\n\t\t\tavc_parse_hrd_parameters(bs, &sps->vui.hrd);\n\n\t\tsps->vui.vcl_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vcl_hrd_parameters_present_flag\");\n\t\tif (sps->vui.vcl_hrd_parameters_present_flag)\n\t\t\tavc_parse_hrd_parameters(bs, &sps->vui.hrd);\n\n\t\tif (sps->vui.nal_hrd_parameters_present_flag || sps->vui.vcl_hrd_parameters_present_flag)\n\t\t\tsps->vui.low_delay_hrd_flag = gf_bs_read_int_log(bs, 1, \"low_delay_hrd_flag\");\n\n\t\tsps->vui.pic_struct_present_flag = gf_bs_read_int_log(bs, 1, \"pic_struct_present_flag\");\n\t}\n\t/*end of seq_parameter_set_data*/\n\n\tif (subseq_sps) {\n\t\tif ((profile_idc == 83) || (profile_idc == 86)) {\n\t\t\tu8 extended_spatial_scalability_idc;\n\t\t\t/*parsing seq_parameter_set_svc_extension*/\n\n\t\t\tgf_bs_read_int_log(bs, 1, \"inter_layer_deblocking_filter_control_present_flag\");\n\t\t\textended_spatial_scalability_idc = gf_bs_read_int_log(bs, 2, \"extended_spatial_scalability_idc\");\n\t\t\tif (sps->ChromaArrayType == 1 || sps->ChromaArrayType == 2) {\n\t\t\t\tgf_bs_read_int_log(bs, 1, \"chroma_phase_x_plus1_flag\");\n\t\t\t}\n\t\t\tif (sps->ChromaArrayType == 1) {\n\t\t\t\tgf_bs_read_int_log(bs, 2, \"chroma_phase_y_plus1\");\n\t\t\t}\n\t\t\tif (extended_spatial_scalability_idc == 1) {\n\t\t\t\tif (sps->ChromaArrayType > 0) {\n\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"seq_ref_layer_chroma_phase_x_plus1_flag\");\n\t\t\t\t\tgf_bs_read_int_log(bs, 2, \"seq_ref_layer_chroma_phase_y_plus1\");\n\t\t\t\t}\n\t\t\t\tgf_bs_read_se_log(bs, \"seq_scaled_ref_layer_left_offset\");\n\t\t\t\tgf_bs_read_se_log(bs, \"seq_scaled_ref_layer_top_offset\");\n\t\t\t\tgf_bs_read_se_log(bs, \"seq_scaled_ref_layer_right_offset\");\n\t\t\t\tgf_bs_read_se_log(bs, \"seq_scaled_ref_layer_bottom_offset\");\n\t\t\t}\n\t\t\tif (gf_bs_read_int_log(bs, 1, \"seq_tcoeff_level_prediction_flag\")) {\n\t\t\t\tgf_bs_read_int_log(bs, 1, \"adaptive_tcoeff_level_prediction_flag\");\n\t\t\t}\n\t\t\tgf_bs_read_int_log(bs, 1, \"slice_header_restriction_flag\");\n\n\t\t\tif (gf_bs_read_int_log(bs, 1, \"svc_vui_parameters_present\")) {\n\t\t\t\tu32 vui_ext_num_entries_minus1 = gf_bs_read_ue_log(bs, \"vui_ext_num_entries_minus1\");\n\n\t\t\t\tfor (i = 0; i <= vui_ext_num_entries_minus1; i++) {\n\t\t\t\t\tu8 vui_ext_nal_hrd_parameters_present_flag, vui_ext_vcl_hrd_parameters_present_flag, vui_ext_timing_info_present_flag;\n\t\t\t\t\tgf_bs_read_int_log(bs, 3, \"vui_ext_dependency_id\");\n\t\t\t\t\tgf_bs_read_int_log(bs, 4, \"vui_ext_quality_id\");\n\t\t\t\t\tgf_bs_read_int_log(bs, 3, \"vui_ext_temporal_id\");\n\t\t\t\t\tvui_ext_timing_info_present_flag = gf_bs_read_int_log(bs, 1, \"vui_ext_timing_info_present_flag\");\n\t\t\t\t\tif (vui_ext_timing_info_present_flag) {\n\t\t\t\t\t\tgf_bs_read_int_log(bs, 32, \"vui_ext_num_units_in_tick\");\n\t\t\t\t\t\tgf_bs_read_int_log(bs, 32, \"vui_ext_time_scale\");\n\t\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"vui_ext_fixed_frame_rate_flag\");\n\t\t\t\t\t}\n\t\t\t\t\tvui_ext_nal_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vui_ext_nal_hrd_parameters_present_flag\");\n\t\t\t\t\tif (vui_ext_nal_hrd_parameters_present_flag) {\n\t\t\t\t\t\t//hrd_parameters( )\n\t\t\t\t\t}\n\t\t\t\t\tvui_ext_vcl_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vui_ext_vcl_hrd_parameters_present_flag\");\n\t\t\t\t\tif (vui_ext_vcl_hrd_parameters_present_flag) {\n\t\t\t\t\t\t//hrd_parameters( )\n\t\t\t\t\t}\n\t\t\t\t\tif (vui_ext_nal_hrd_parameters_present_flag || vui_ext_vcl_hrd_parameters_present_flag) {\n\t\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"vui_ext_low_delay_hrd_flag\");\n\t\t\t\t\t}\n\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"vui_ext_pic_struct_present_flag\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ((profile_idc == 118) || (profile_idc == 128)) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CODING, (\"[avc-h264] MVC parsing not implemented - skipping parsing end of Subset SPS\\n\"));\n\t\t\treturn sps_id;\n\t\t}\n\n\t\tif (gf_bs_read_int_log(bs, 1, \"additional_extension2\")) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[avc-h264] skipping parsing end of Subset SPS (additional_extension2)\\n\"));\n\t\t\treturn sps_id;\n\t\t}\n\t}\n\treturn sps_id;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144673,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "static s32 gf_avc_read_sps_bs_internal(GF_BitStream *bs, AVCState *avc, u32 subseq_sps, u32 *vui_flag_pos, u32 nal_hdr)\n{\n\tAVC_SPS *sps;\n\ts32 mb_width, mb_height, sps_id = -1;\n\tu32 profile_idc, level_idc, pcomp, i, chroma_format_idc, cl = 0, cr = 0, ct = 0, cb = 0, luma_bd, chroma_bd;\n\tu8 separate_colour_plane_flag = 0;\n\n\tif (!vui_flag_pos) {\n\t\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\t}\n\n\tif (!bs) {\n\t\treturn -1;\n\t}\n\n\tif (!nal_hdr) {\n\t\tgf_bs_read_int_log(bs, 1, \"forbidden_zero_bit\");\n\t\tgf_bs_read_int_log(bs, 2, \"nal_ref_idc\");\n\t\tgf_bs_read_int_log(bs, 5, \"nal_unit_type\");\n\t}\n\tprofile_idc = gf_bs_read_int_log(bs, 8, \"profile_idc\");\n\n\tpcomp = gf_bs_read_int_log(bs, 8, \"profile_compatibility\");\n\t/*sanity checks*/\n\tif (pcomp & 0x3)\n\t\treturn -1;\n\n\tlevel_idc = gf_bs_read_int_log(bs, 8, \"level_idc\");\n\n\t/*SubsetSps is used to be sure that AVC SPS are not going to be scratched\n\tby subset SPS. According to the SVC standard, subset SPS can have the same sps_id\n\tthan its base layer, but it does not refer to the same SPS. */\n\tsps_id = gf_bs_read_ue_log(bs, \"sps_id\") + GF_SVC_SSPS_ID_SHIFT * subseq_sps;\n\tif ((sps_id < 0) || (sps_id >= 32)) {\n\t\treturn -1;\n\t}\n\n\tluma_bd = chroma_bd = 0;\n\tsps = &avc->sps[sps_id];\n\tchroma_format_idc = sps->ChromaArrayType = 1;\n\tsps->state |= subseq_sps ? AVC_SUBSPS_PARSED : AVC_SPS_PARSED;\n\n\t/*High Profile and SVC*/\n\tswitch (profile_idc) {\n\tcase 100:\n\tcase 110:\n\tcase 122:\n\tcase 244:\n\tcase 44:\n\t\t/*sanity checks: note1 from 7.4.2.1.1 of iso/iec 14496-10-N11084*/\n\t\tif (pcomp & 0xE0)\n\t\t\treturn -1;\n\tcase 83:\n\tcase 86:\n\tcase 118:\n\tcase 128:\n\t\tchroma_format_idc = gf_bs_read_ue_log(bs, \"chroma_format_idc\");\n\t\tsps->ChromaArrayType = chroma_format_idc;\n\t\tif (chroma_format_idc == 3) {\n\t\t\tseparate_colour_plane_flag = gf_bs_read_int_log(bs, 1, \"separate_colour_plane_flag\");\n\t\t\t/*\n\t\t\tDepending on the value of separate_colour_plane_flag, the value of the variable ChromaArrayType is assigned as follows.\n\t\t\t\\96\tIf separate_colour_plane_flag is equal to 0, ChromaArrayType is set equal to chroma_format_idc.\n\t\t\t\\96\tOtherwise (separate_colour_plane_flag is equal to 1), ChromaArrayType is set equal to 0.\n\t\t\t*/\n\t\t\tif (separate_colour_plane_flag) sps->ChromaArrayType = 0;\n\t\t}\n\t\tluma_bd = gf_bs_read_ue_log(bs, \"luma_bit_depth\");\n\t\tchroma_bd = gf_bs_read_ue_log(bs, \"chroma_bit_depth\");\n\t\t/*qpprime_y_zero_transform_bypass_flag = */ gf_bs_read_int_log(bs, 1, \"qpprime_y_zero_transform_bypass_flag\");\n\t\t/*seq_scaling_matrix_present_flag*/\n\t\tif (gf_bs_read_int_log(bs, 1, \"seq_scaling_matrix_present_flag\")) {\n\t\t\tu32 k;\n\t\t\tfor (k = 0; k < 8; k++) {\n\t\t\t\tif (gf_bs_read_int_log_idx(bs, 1, \"seq_scaling_list_present_flag\", k)) {\n\t\t\t\t\tu32 z, last = 8, next = 8;\n\t\t\t\t\tu32 sl = k < 6 ? 16 : 64;\n\t\t\t\t\tfor (z = 0; z < sl; z++) {\n\t\t\t\t\t\tif (next) {\n\t\t\t\t\t\t\ts32 delta = gf_bs_read_se(bs);\n\t\t\t\t\t\t\tnext = (last + delta + 256) % 256;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlast = next ? next : last;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tsps->profile_idc = profile_idc;\n\tsps->level_idc = level_idc;\n\tsps->prof_compat = pcomp;\n\tsps->log2_max_frame_num = gf_bs_read_ue_log(bs, \"log2_max_frame_num\") + 4;\n\tsps->poc_type = gf_bs_read_ue_log(bs, \"poc_type\");\n\tsps->chroma_format = chroma_format_idc;\n\tsps->luma_bit_depth_m8 = luma_bd;\n\tsps->chroma_bit_depth_m8 = chroma_bd;\n\n\tif (sps->poc_type == 0) {\n\t\tsps->log2_max_poc_lsb = gf_bs_read_ue_log(bs, \"log2_max_poc_lsb\") + 4;\n\t}\n\telse if (sps->poc_type == 1) {\n\t\tsps->delta_pic_order_always_zero_flag = gf_bs_read_int_log(bs, 1, \"delta_pic_order_always_zero_flag\");\n\t\tsps->offset_for_non_ref_pic = gf_bs_read_se_log(bs, \"offset_for_non_ref_pic\");\n\t\tsps->offset_for_top_to_bottom_field = gf_bs_read_se_log(bs, \"offset_for_top_to_bottom_field\");\n\t\tsps->poc_cycle_length = gf_bs_read_ue_log(bs, \"poc_cycle_length\");\n\t\tif (sps->poc_cycle_length > GF_ARRAY_LENGTH(sps->offset_for_ref_frame)) {\n\t\t\tsps->poc_cycle_length = 255;\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[avc-h264] offset_for_ref_frame overflow from poc_cycle_length\\n\"));\n\t\t\treturn -1;\n\t\t}\n\t\tfor (i = 0; i < sps->poc_cycle_length; i++)\n\t\t\tsps->offset_for_ref_frame[i] = gf_bs_read_se_log_idx(bs, \"offset_for_ref_frame\", i);\n\t}\n\tif (sps->poc_type > 2) {\n\t\treturn -1;\n\t}\n\tsps->max_num_ref_frames = gf_bs_read_ue_log(bs, \"max_num_ref_frames\");\n\tsps->gaps_in_frame_num_value_allowed_flag = gf_bs_read_int_log(bs, 1, \"gaps_in_frame_num_value_allowed_flag\");\n\tmb_width = gf_bs_read_ue_log(bs, \"pic_width_in_mbs_minus1\") + 1;\n\tmb_height = gf_bs_read_ue_log(bs, \"pic_height_in_map_units_minus1\") + 1;\n\n\tsps->frame_mbs_only_flag = gf_bs_read_int_log(bs, 1, \"frame_mbs_only_flag\");\n\n\tsps->width = mb_width * 16;\n\tsps->height = (2 - sps->frame_mbs_only_flag) * mb_height * 16;\n\n\tif (!sps->frame_mbs_only_flag) sps->mb_adaptive_frame_field_flag = gf_bs_read_int_log(bs, 1, \"mb_adaptive_frame_field_flag\");\n\tgf_bs_read_int_log(bs, 1, \"direct_8x8_inference_flag\");\n\n\tif (gf_bs_read_int_log(bs, 1, \"frame_cropping_flag\")) {\n\t\tint CropUnitX, CropUnitY, SubWidthC = -1, SubHeightC = -1;\n\n\t\tif (chroma_format_idc == 1) {\n\t\t\tSubWidthC = 2; SubHeightC = 2;\n\t\t}\n\t\telse if (chroma_format_idc == 2) {\n\t\t\tSubWidthC = 2; SubHeightC = 1;\n\t\t}\n\t\telse if ((chroma_format_idc == 3) && (separate_colour_plane_flag == 0)) {\n\t\t\tSubWidthC = 1; SubHeightC = 1;\n\t\t}\n\n\t\tif (sps->ChromaArrayType == 0) {\n\t\t\tassert(SubWidthC == -1);\n\t\t\tCropUnitX = 1;\n\t\t\tCropUnitY = 2 - sps->frame_mbs_only_flag;\n\t\t}\n\t\telse {\n\t\t\tCropUnitX = SubWidthC;\n\t\t\tCropUnitY = SubHeightC * (2 - sps->frame_mbs_only_flag);\n\t\t}\n\n\t\tcl = gf_bs_read_ue_log(bs, \"frame_crop_left_offset\");\n\t\tcr = gf_bs_read_ue_log(bs, \"frame_crop_right_offset\");\n\t\tct = gf_bs_read_ue_log(bs, \"frame_crop_top_offset\");\n\t\tcb = gf_bs_read_ue_log(bs, \"frame_crop_bottom_offset\");\n\n\t\tsps->width -= CropUnitX * (cl + cr);\n\t\tsps->height -= CropUnitY * (ct + cb);\n\t\tcl *= CropUnitX;\n\t\tcr *= CropUnitX;\n\t\tct *= CropUnitY;\n\t\tcb *= CropUnitY;\n\t}\n\tsps->crop.left = cl;\n\tsps->crop.right = cr;\n\tsps->crop.top = ct;\n\tsps->crop.bottom = cb;\n\n\tif (vui_flag_pos) {\n\t\t*vui_flag_pos = (u32)gf_bs_get_bit_offset(bs);\n\t}\n\t/*vui_parameters_present_flag*/\n\tsps->vui_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vui_parameters_present_flag\");\n\tif (sps->vui_parameters_present_flag) {\n\t\tsps->vui.aspect_ratio_info_present_flag = gf_bs_read_int_log(bs, 1, \"aspect_ratio_info_present_flag\");\n\t\tif (sps->vui.aspect_ratio_info_present_flag) {\n\t\t\ts32 aspect_ratio_idc = gf_bs_read_int_log(bs, 8, \"aspect_ratio_idc\");\n\t\t\tif (aspect_ratio_idc == 255) {\n\t\t\t\tsps->vui.par_num = gf_bs_read_int_log(bs, 16, \"aspect_ratio_num\");\n\t\t\t\tsps->vui.par_den = gf_bs_read_int_log(bs, 16, \"aspect_ratio_den\");\n\t\t\t}\n\t\t\telse if (aspect_ratio_idc < GF_ARRAY_LENGTH(avc_hevc_sar) ) {\n\t\t\t\tsps->vui.par_num = avc_hevc_sar[aspect_ratio_idc].w;\n\t\t\t\tsps->vui.par_den = avc_hevc_sar[aspect_ratio_idc].h;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[avc-h264] Unknown aspect_ratio_idc: your video may have a wrong aspect ratio. Contact the GPAC team!\\n\"));\n\t\t\t}\n\t\t}\n\t\tsps->vui.overscan_info_present_flag = gf_bs_read_int_log(bs, 1, \"overscan_info_present_flag\");\n\t\tif (sps->vui.overscan_info_present_flag)\n\t\t\tgf_bs_read_int_log(bs, 1, \"overscan_appropriate_flag\");\n\n\t\t/* default values */\n\t\tsps->vui.video_format = 5;\n\t\tsps->vui.colour_primaries = 2;\n\t\tsps->vui.transfer_characteristics = 2;\n\t\tsps->vui.matrix_coefficients = 2;\n\t\t/* now read values if possible */\n\t\tsps->vui.video_signal_type_present_flag = gf_bs_read_int_log(bs, 1, \"video_signal_type_present_flag\");\n\t\tif (sps->vui.video_signal_type_present_flag) {\n\t\t\tsps->vui.video_format = gf_bs_read_int_log(bs, 3, \"video_format\");\n\t\t\tsps->vui.video_full_range_flag = gf_bs_read_int_log(bs, 1, \"video_full_range_flag\");\n\t\t\tsps->vui.colour_description_present_flag = gf_bs_read_int_log(bs, 1, \"colour_description_present_flag\");\n\t\t\tif (sps->vui.colour_description_present_flag) {\n\t\t\t\tsps->vui.colour_primaries = gf_bs_read_int_log(bs, 8, \"colour_primaries\");\n\t\t\t\tsps->vui.transfer_characteristics = gf_bs_read_int_log(bs, 8, \"transfer_characteristics\");\n\t\t\t\tsps->vui.matrix_coefficients = gf_bs_read_int_log(bs, 8, \"matrix_coefficients\");\n\t\t\t}\n\t\t}\n\n\t\tif (gf_bs_read_int_log(bs, 1, \"chroma_location_info_present_flag\")) {\n\t\t\tgf_bs_read_ue_log(bs, \"chroma_sample_location_type_top_field\");\n\t\t\tgf_bs_read_ue_log(bs, \"chroma_sample_location_type_bottom_field\");\n\t\t}\n\n\t\tsps->vui.timing_info_present_flag = gf_bs_read_int_log(bs, 1, \"timing_info_present_flag\");\n\t\tif (sps->vui.timing_info_present_flag) {\n\t\t\tsps->vui.num_units_in_tick = gf_bs_read_int_log(bs, 32, \"num_units_in_tick\");\n\t\t\tsps->vui.time_scale = gf_bs_read_int_log(bs, 32, \"time_scale\");\n\t\t\tsps->vui.fixed_frame_rate_flag = gf_bs_read_int_log(bs, 1, \"fixed_frame_rate_flag\");\n\t\t}\n\n\t\tsps->vui.nal_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"nal_hrd_parameters_present_flag\");\n\t\tif (sps->vui.nal_hrd_parameters_present_flag)\n\t\t\tavc_parse_hrd_parameters(bs, &sps->vui.hrd);\n\n\t\tsps->vui.vcl_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vcl_hrd_parameters_present_flag\");\n\t\tif (sps->vui.vcl_hrd_parameters_present_flag)\n\t\t\tavc_parse_hrd_parameters(bs, &sps->vui.hrd);\n\n\t\tif (sps->vui.nal_hrd_parameters_present_flag || sps->vui.vcl_hrd_parameters_present_flag)\n\t\t\tsps->vui.low_delay_hrd_flag = gf_bs_read_int_log(bs, 1, \"low_delay_hrd_flag\");\n\n\t\tsps->vui.pic_struct_present_flag = gf_bs_read_int_log(bs, 1, \"pic_struct_present_flag\");\n\t}\n\t/*end of seq_parameter_set_data*/\n\n\tif (subseq_sps) {\n\t\tif ((profile_idc == 83) || (profile_idc == 86)) {\n\t\t\tu8 extended_spatial_scalability_idc;\n\t\t\t/*parsing seq_parameter_set_svc_extension*/\n\n\t\t\tgf_bs_read_int_log(bs, 1, \"inter_layer_deblocking_filter_control_present_flag\");\n\t\t\textended_spatial_scalability_idc = gf_bs_read_int_log(bs, 2, \"extended_spatial_scalability_idc\");\n\t\t\tif (sps->ChromaArrayType == 1 || sps->ChromaArrayType == 2) {\n\t\t\t\tgf_bs_read_int_log(bs, 1, \"chroma_phase_x_plus1_flag\");\n\t\t\t}\n\t\t\tif (sps->ChromaArrayType == 1) {\n\t\t\t\tgf_bs_read_int_log(bs, 2, \"chroma_phase_y_plus1\");\n\t\t\t}\n\t\t\tif (extended_spatial_scalability_idc == 1) {\n\t\t\t\tif (sps->ChromaArrayType > 0) {\n\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"seq_ref_layer_chroma_phase_x_plus1_flag\");\n\t\t\t\t\tgf_bs_read_int_log(bs, 2, \"seq_ref_layer_chroma_phase_y_plus1\");\n\t\t\t\t}\n\t\t\t\tgf_bs_read_se_log(bs, \"seq_scaled_ref_layer_left_offset\");\n\t\t\t\tgf_bs_read_se_log(bs, \"seq_scaled_ref_layer_top_offset\");\n\t\t\t\tgf_bs_read_se_log(bs, \"seq_scaled_ref_layer_right_offset\");\n\t\t\t\tgf_bs_read_se_log(bs, \"seq_scaled_ref_layer_bottom_offset\");\n\t\t\t}\n\t\t\tif (gf_bs_read_int_log(bs, 1, \"seq_tcoeff_level_prediction_flag\")) {\n\t\t\t\tgf_bs_read_int_log(bs, 1, \"adaptive_tcoeff_level_prediction_flag\");\n\t\t\t}\n\t\t\tgf_bs_read_int_log(bs, 1, \"slice_header_restriction_flag\");\n\n\t\t\tif (gf_bs_read_int_log(bs, 1, \"svc_vui_parameters_present\")) {\n\t\t\t\tu32 vui_ext_num_entries_minus1 = gf_bs_read_ue_log(bs, \"vui_ext_num_entries_minus1\");\n\n\t\t\t\tfor (i = 0; i <= vui_ext_num_entries_minus1; i++) {\n\t\t\t\t\tu8 vui_ext_nal_hrd_parameters_present_flag, vui_ext_vcl_hrd_parameters_present_flag, vui_ext_timing_info_present_flag;\n\t\t\t\t\tgf_bs_read_int_log(bs, 3, \"vui_ext_dependency_id\");\n\t\t\t\t\tgf_bs_read_int_log(bs, 4, \"vui_ext_quality_id\");\n\t\t\t\t\tgf_bs_read_int_log(bs, 3, \"vui_ext_temporal_id\");\n\t\t\t\t\tvui_ext_timing_info_present_flag = gf_bs_read_int_log(bs, 1, \"vui_ext_timing_info_present_flag\");\n\t\t\t\t\tif (vui_ext_timing_info_present_flag) {\n\t\t\t\t\t\tgf_bs_read_int_log(bs, 32, \"vui_ext_num_units_in_tick\");\n\t\t\t\t\t\tgf_bs_read_int_log(bs, 32, \"vui_ext_time_scale\");\n\t\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"vui_ext_fixed_frame_rate_flag\");\n\t\t\t\t\t}\n\t\t\t\t\tvui_ext_nal_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vui_ext_nal_hrd_parameters_present_flag\");\n\t\t\t\t\tif (vui_ext_nal_hrd_parameters_present_flag) {\n\t\t\t\t\t\t//hrd_parameters( )\n\t\t\t\t\t}\n\t\t\t\t\tvui_ext_vcl_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vui_ext_vcl_hrd_parameters_present_flag\");\n\t\t\t\t\tif (vui_ext_vcl_hrd_parameters_present_flag) {\n\t\t\t\t\t\t//hrd_parameters( )\n\t\t\t\t\t}\n\t\t\t\t\tif (vui_ext_nal_hrd_parameters_present_flag || vui_ext_vcl_hrd_parameters_present_flag) {\n\t\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"vui_ext_low_delay_hrd_flag\");\n\t\t\t\t\t}\n\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"vui_ext_pic_struct_present_flag\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ((profile_idc == 118) || (profile_idc == 128)) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CODING, (\"[avc-h264] MVC parsing not implemented - skipping parsing end of Subset SPS\\n\"));\n\t\t\treturn sps_id;\n\t\t}\n\n\t\tif (gf_bs_read_int_log(bs, 1, \"additional_extension2\")) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[avc-h264] skipping parsing end of Subset SPS (additional_extension2)\\n\"));\n\t\t\treturn sps_id;\n\t\t}\n\t}\n\treturn sps_id;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144674,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "static void rebase_buffer(struct MACH0_(obj_t) *obj, ut64 off, RIODesc *fd, ut8 *buf, int count) {\n\tif (obj->rebasing_buffer) {\n\t\treturn;\n\t}\n\tobj->rebasing_buffer = true;\n\tut64 eob = off + count;\n\tint i = 0;\n\tfor (; i < obj->nsegs; i++) {\n\t\tif (!obj->chained_starts[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tut64 page_size = obj->chained_starts[i]->page_size;\n\t\tut64 start = obj->segs[i].fileoff;\n\t\tut64 end = start + obj->segs[i].filesize;\n\t\tif (end >= off && start <= eob) {\n\t\t\tut64 page_idx = (R_MAX (start, off) - start) / page_size;\n\t\t\tut64 page_end_idx = (R_MIN (eob, end) - start) / page_size;\n\t\t\tfor (; page_idx <= page_end_idx; page_idx++) {\n\t\t\t\tif (page_idx >= obj->chained_starts[i]->page_count) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tut16 page_start = obj->chained_starts[i]->page_start[page_idx];\n\t\t\t\tif (page_start == DYLD_CHAINED_PTR_START_NONE) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tut64 cursor = start + page_idx * page_size + page_start;\n\t\t\t\twhile (cursor < eob && cursor < end) {\n\t\t\t\t\tut8 tmp[8];\n\t\t\t\t\tif (r_buf_read_at (obj->b, cursor, tmp, 8) != 8) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tut64 raw_ptr = r_read_le64 (tmp);\n\t\t\t\t\tbool is_auth = IS_PTR_AUTH (raw_ptr);\n\t\t\t\t\tbool is_bind = IS_PTR_BIND (raw_ptr);\n\t\t\t\t\tut64 ptr_value = raw_ptr;\n\t\t\t\t\tut64 delta;\n\t\t\t\t\tif (is_auth && is_bind) {\n\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_auth_bind *p =\n\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_auth_bind *) &raw_ptr;\n\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t} else if (!is_auth && is_bind) {\n\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_bind *p =\n\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_bind *) &raw_ptr;\n\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t} else if (is_auth && !is_bind) {\n\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_auth_rebase *p =\n\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_auth_rebase *) &raw_ptr;\n\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\tptr_value = p->target + obj->baddr;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_rebase *p =\n\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_rebase *) &raw_ptr;\n\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\tptr_value = ((ut64)p->high8 << 56) | p->target;\n\t\t\t\t\t}\n\t\t\t\t\tut64 in_buf = cursor - off;\n\t\t\t\t\tif (cursor >= off && cursor <= eob - 8) {\n\t\t\t\t\t\tr_write_le64 (&buf[in_buf], ptr_value);\n\t\t\t\t\t}\n\t\t\t\t\tcursor += delta * 8;\n\t\t\t\t\tif (!delta) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tobj->rebasing_buffer = false;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144697,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "static void rebase_buffer(struct MACH0_(obj_t) *obj, ut64 off, RIODesc *fd, ut8 *buf, int count) {\n\tif (obj->rebasing_buffer) {\n\t\treturn;\n\t}\n\tobj->rebasing_buffer = true;\n\tut64 eob = off + count;\n\tint i = 0;\n\tfor (; i < obj->nsegs; i++) {\n\t\tif (!obj->chained_starts[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tint page_size = obj->chained_starts[i]->page_size;\n\t\tif (page_size < 1) {\n\t\t\tpage_size = 4096;\n\t\t}\n\t\tut64 start = obj->segs[i].fileoff;\n\t\tut64 end = start + obj->segs[i].filesize;\n\t\tif (end >= off && start <= eob) {\n\t\t\tut64 page_idx = (R_MAX (start, off) - start) / page_size;\n\t\t\tut64 page_end_idx = (R_MIN (eob, end) - start) / page_size;\n\t\t\tfor (; page_idx <= page_end_idx; page_idx++) {\n\t\t\t\tif (page_idx >= obj->chained_starts[i]->page_count) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tut16 page_start = obj->chained_starts[i]->page_start[page_idx];\n\t\t\t\tif (page_start == DYLD_CHAINED_PTR_START_NONE) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tut64 cursor = start + page_idx * page_size + page_start;\n\t\t\t\twhile (cursor < eob && cursor < end) {\n\t\t\t\t\tut8 tmp[8];\n\t\t\t\t\tif (r_buf_read_at (obj->b, cursor, tmp, 8) != 8) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tut64 raw_ptr = r_read_le64 (tmp);\n\t\t\t\t\tbool is_auth = IS_PTR_AUTH (raw_ptr);\n\t\t\t\t\tbool is_bind = IS_PTR_BIND (raw_ptr);\n\t\t\t\t\tut64 ptr_value = raw_ptr;\n\t\t\t\t\tut64 delta;\n\t\t\t\t\tif (is_auth && is_bind) {\n\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_auth_bind *p =\n\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_auth_bind *) &raw_ptr;\n\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t} else if (!is_auth && is_bind) {\n\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_bind *p =\n\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_bind *) &raw_ptr;\n\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t} else if (is_auth && !is_bind) {\n\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_auth_rebase *p =\n\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_auth_rebase *) &raw_ptr;\n\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\tptr_value = p->target + obj->baddr;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_rebase *p =\n\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_rebase *) &raw_ptr;\n\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\tptr_value = ((ut64)p->high8 << 56) | p->target;\n\t\t\t\t\t}\n\t\t\t\t\tut64 in_buf = cursor - off;\n\t\t\t\t\tif (cursor >= off && cursor <= eob - 8) {\n\t\t\t\t\t\tr_write_le64 (&buf[in_buf], ptr_value);\n\t\t\t\t\t}\n\t\t\t\t\tcursor += delta * 8;\n\t\t\t\t\tif (!delta) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tobj->rebasing_buffer = false;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144698,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "void DDGifSlurp(GifInfo *info, bool decode, bool exitAfterFrame) {\n\tGifRecordType RecordType;\n\tGifByteType *ExtData;\n\tint ExtFunction;\n\tGifFileType *gifFilePtr;\n\tgifFilePtr = info->gifFilePtr;\n\tuint_fast32_t lastAllocatedGCBIndex = 0;\n\tdo {\n\t\tif (DGifGetRecordType(gifFilePtr, &RecordType) == GIF_ERROR) {\n\t\t\tbreak;\n\t\t}\n\t\tbool isInitialPass = !decode && !exitAfterFrame;\n\t\tswitch (RecordType) {\n\t\t\tcase IMAGE_DESC_RECORD_TYPE:\n\n\t\t\t\tif (DGifGetImageDesc(gifFilePtr, isInitialPass) == GIF_ERROR) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (isInitialPass) {\n\t\t\t\t\tint_fast32_t widthOverflow = gifFilePtr->Image.Width - gifFilePtr->SWidth;\n\t\t\t\t\tint_fast32_t heightOverflow = gifFilePtr->Image.Height - gifFilePtr->SHeight;\n\t\t\t\t\tif (widthOverflow > 0 || heightOverflow > 0) {\n\t\t\t\t\t\tgifFilePtr->SWidth += widthOverflow;\n\t\t\t\t\t\tgifFilePtr->SHeight += heightOverflow;\n\t\t\t\t\t}\n\t\t\t\t\tSavedImage *sp = &gifFilePtr->SavedImages[gifFilePtr->ImageCount - 1];\n\t\t\t\t\tint_fast32_t topOverflow = gifFilePtr->Image.Top + gifFilePtr->Image.Height - gifFilePtr->SHeight;\n\t\t\t\t\tif (topOverflow > 0) {\n\t\t\t\t\t\tsp->ImageDesc.Top -= topOverflow;\n\t\t\t\t\t}\n\n\t\t\t\t\tint_fast32_t leftOverflow = gifFilePtr->Image.Left + gifFilePtr->Image.Width - gifFilePtr->SWidth;\n\t\t\t\t\tif (leftOverflow > 0) {\n\t\t\t\t\t\tsp->ImageDesc.Left -= leftOverflow;\n\t\t\t\t\t}\n\t\t\t\t\tif (!updateGCB(info, &lastAllocatedGCBIndex)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (decode) {\n\t\t\t\t\tint_fast32_t widthOverflow = gifFilePtr->Image.Width - info->originalWidth;\n\t\t\t\t\tint_fast32_t heightOverflow = gifFilePtr->Image.Height - info->originalHeight;\n\t\t\t\t\tconst uint_fast32_t newRasterSize = gifFilePtr->Image.Width * gifFilePtr->Image.Height;\n\t\t\t\t\tif (newRasterSize > info->rasterSize || widthOverflow > 0 || heightOverflow > 0) {\n\t\t\t\t\t\tvoid *tmpRasterBits = reallocarray(info->rasterBits, newRasterSize, sizeof(GifPixelType));\n\t\t\t\t\t\tif (tmpRasterBits == NULL) {\n\t\t\t\t\t\t\tgifFilePtr->Error = D_GIF_ERR_NOT_ENOUGH_MEM;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinfo->rasterBits = tmpRasterBits;\n\t\t\t\t\t\tinfo->rasterSize = newRasterSize;\n\t\t\t\t\t}\n\t\t\t\t\tif (gifFilePtr->Image.Interlace) {\n\t\t\t\t\t\tuint_fast16_t i, j;\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * The way an interlaced image should be read -\n\t\t\t\t\t\t * offsets and jumps...\n\t\t\t\t\t\t */\n\t\t\t\t\t\tuint_fast8_t InterlacedOffset[] = {0, 4, 2, 1};\n\t\t\t\t\t\tuint_fast8_t InterlacedJumps[] = {8, 8, 4, 2};\n\t\t\t\t\t\t/* Need to perform 4 passes on the image */\n\t\t\t\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t\t\t\t\tfor (j = InterlacedOffset[i]; j < gifFilePtr->Image.Height; j += InterlacedJumps[i]) {\n\t\t\t\t\t\t\t\tif (DGifGetLine(gifFilePtr, info->rasterBits + j * gifFilePtr->Image.Width, gifFilePtr->Image.Width) == GIF_ERROR)\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (DGifGetLine(gifFilePtr, info->rasterBits, gifFilePtr->Image.Width * gifFilePtr->Image.Height) == GIF_ERROR) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (info->sampleSize > 1) {\n\t\t\t\t\t\tunsigned char *dst = info->rasterBits;\n\t\t\t\t\t\tunsigned char *src = info->rasterBits;\n\t\t\t\t\t\tunsigned char *const srcEndImage = info->rasterBits + gifFilePtr->Image.Width * gifFilePtr->Image.Height;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tunsigned char *srcNextLineStart = src + gifFilePtr->Image.Width * info->sampleSize;\n\t\t\t\t\t\t\tunsigned char *const srcEndLine = src + gifFilePtr->Image.Width;\n\t\t\t\t\t\t\tunsigned char *dstEndLine = dst + gifFilePtr->Image.Width / info->sampleSize;\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\t*dst = *src;\n\t\t\t\t\t\t\t\tdst++;\n\t\t\t\t\t\t\t\tsrc += info->sampleSize;\n\t\t\t\t\t\t\t} while (src < srcEndLine);\n\t\t\t\t\t\t\tdst = dstEndLine;\n\t\t\t\t\t\t\tsrc = srcNextLineStart;\n\t\t\t\t\t\t} while (src < srcEndImage);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (DGifGetCodeNext(gifFilePtr, &ExtData) == GIF_ERROR) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} while (ExtData != NULL);\n\t\t\t\t\tif (exitAfterFrame) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase EXTENSION_RECORD_TYPE:\n\t\t\t\tif (DGifGetExtension(gifFilePtr, &ExtFunction, &ExtData) == GIF_ERROR) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (isInitialPass) {\n\t\t\t\t\tupdateGCB(info, &lastAllocatedGCBIndex);\n\t\t\t\t\tif (readExtensions(ExtFunction, ExtData, info) == GIF_ERROR) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile (ExtData != NULL) {\n\t\t\t\t\tif (DGifGetExtensionNext(gifFilePtr, &ExtData) == GIF_ERROR) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (isInitialPass && readExtensions(ExtFunction, ExtData, info) == GIF_ERROR) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase TERMINATE_RECORD_TYPE:\n\t\t\t\tbreak;\n\n\t\t\tdefault: /* Should be trapped by DGifGetRecordType */\n\t\t\t\tbreak;\n\t\t}\n\t} while (RecordType != TERMINATE_RECORD_TYPE);\n\n\tinfo->rewindFunction(info);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144912,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "void DDGifSlurp(GifInfo *info, bool decode, bool exitAfterFrame) {\n\tGifRecordType RecordType;\n\tGifByteType *ExtData;\n\tint ExtFunction;\n\tGifFileType *gifFilePtr;\n\tgifFilePtr = info->gifFilePtr;\n\tuint_fast32_t lastAllocatedGCBIndex = 0;\n\tdo {\n\t\tif (DGifGetRecordType(gifFilePtr, &RecordType) == GIF_ERROR) {\n\t\t\tbreak;\n\t\t}\n\t\tbool isInitialPass = !decode && !exitAfterFrame;\n\t\tswitch (RecordType) {\n\t\t\tcase IMAGE_DESC_RECORD_TYPE:\n\n\t\t\t\tif (DGifGetImageDesc(gifFilePtr, isInitialPass) == GIF_ERROR) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (isInitialPass) {\n\t\t\t\t\tint_fast32_t widthOverflow = gifFilePtr->Image.Width - gifFilePtr->SWidth;\n\t\t\t\t\tint_fast32_t heightOverflow = gifFilePtr->Image.Height - gifFilePtr->SHeight;\n\t\t\t\t\tif (widthOverflow > 0 || heightOverflow > 0) {\n\t\t\t\t\t\tgifFilePtr->SWidth += widthOverflow;\n\t\t\t\t\t\tgifFilePtr->SHeight += heightOverflow;\n\t\t\t\t\t}\n\t\t\t\t\tSavedImage *sp = &gifFilePtr->SavedImages[gifFilePtr->ImageCount - 1];\n\t\t\t\t\tint_fast32_t topOverflow = gifFilePtr->Image.Top + gifFilePtr->Image.Height - gifFilePtr->SHeight;\n\t\t\t\t\tif (topOverflow > 0) {\n\t\t\t\t\t\tsp->ImageDesc.Top -= topOverflow;\n\t\t\t\t\t}\n\n\t\t\t\t\tint_fast32_t leftOverflow = gifFilePtr->Image.Left + gifFilePtr->Image.Width - gifFilePtr->SWidth;\n\t\t\t\t\tif (leftOverflow > 0) {\n\t\t\t\t\t\tsp->ImageDesc.Left -= leftOverflow;\n\t\t\t\t\t}\n\t\t\t\t\tif (!updateGCB(info, &lastAllocatedGCBIndex)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (decode) {\n\t\t\t\t\tconst uint_fast32_t newRasterSize = gifFilePtr->Image.Width * gifFilePtr->Image.Height;\n\t\t\t\t\tif (newRasterSize == 0) {\n\t\t\t\t\t\tfree(info->rasterBits);\n\t\t\t\t\t\tinfo->rasterBits = NULL;\n\t\t\t\t\t\tinfo->rasterSize = newRasterSize;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tconst int_fast32_t widthOverflow = gifFilePtr->Image.Width - info->originalWidth;\n\t\t\t\t\tconst int_fast32_t heightOverflow = gifFilePtr->Image.Height - info->originalHeight;\n\t\t\t\t\tif (newRasterSize > info->rasterSize || widthOverflow > 0 || heightOverflow > 0) {\n\t\t\t\t\t\tvoid *tmpRasterBits = reallocarray(info->rasterBits, newRasterSize, sizeof(GifPixelType));\n\t\t\t\t\t\tif (tmpRasterBits == NULL) {\n\t\t\t\t\t\t\tgifFilePtr->Error = D_GIF_ERR_NOT_ENOUGH_MEM;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinfo->rasterBits = tmpRasterBits;\n\t\t\t\t\t\tinfo->rasterSize = newRasterSize;\n\t\t\t\t\t}\n\t\t\t\t\tif (gifFilePtr->Image.Interlace) {\n\t\t\t\t\t\tuint_fast16_t i, j;\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * The way an interlaced image should be read -\n\t\t\t\t\t\t * offsets and jumps...\n\t\t\t\t\t\t */\n\t\t\t\t\t\tuint_fast8_t InterlacedOffset[] = {0, 4, 2, 1};\n\t\t\t\t\t\tuint_fast8_t InterlacedJumps[] = {8, 8, 4, 2};\n\t\t\t\t\t\t/* Need to perform 4 passes on the image */\n\t\t\t\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t\t\t\t\tfor (j = InterlacedOffset[i]; j < gifFilePtr->Image.Height; j += InterlacedJumps[i]) {\n\t\t\t\t\t\t\t\tif (DGifGetLine(gifFilePtr, info->rasterBits + j * gifFilePtr->Image.Width, gifFilePtr->Image.Width) == GIF_ERROR)\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (DGifGetLine(gifFilePtr, info->rasterBits, gifFilePtr->Image.Width * gifFilePtr->Image.Height) == GIF_ERROR) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (info->sampleSize > 1) {\n\t\t\t\t\t\tunsigned char *dst = info->rasterBits;\n\t\t\t\t\t\tunsigned char *src = info->rasterBits;\n\t\t\t\t\t\tunsigned char *const srcEndImage = info->rasterBits + gifFilePtr->Image.Width * gifFilePtr->Image.Height;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tunsigned char *srcNextLineStart = src + gifFilePtr->Image.Width * info->sampleSize;\n\t\t\t\t\t\t\tunsigned char *const srcEndLine = src + gifFilePtr->Image.Width;\n\t\t\t\t\t\t\tunsigned char *dstEndLine = dst + gifFilePtr->Image.Width / info->sampleSize;\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\t*dst = *src;\n\t\t\t\t\t\t\t\tdst++;\n\t\t\t\t\t\t\t\tsrc += info->sampleSize;\n\t\t\t\t\t\t\t} while (src < srcEndLine);\n\t\t\t\t\t\t\tdst = dstEndLine;\n\t\t\t\t\t\t\tsrc = srcNextLineStart;\n\t\t\t\t\t\t} while (src < srcEndImage);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (DGifGetCodeNext(gifFilePtr, &ExtData) == GIF_ERROR) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} while (ExtData != NULL);\n\t\t\t\t\tif (exitAfterFrame) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase EXTENSION_RECORD_TYPE:\n\t\t\t\tif (DGifGetExtension(gifFilePtr, &ExtFunction, &ExtData) == GIF_ERROR) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (isInitialPass) {\n\t\t\t\t\tupdateGCB(info, &lastAllocatedGCBIndex);\n\t\t\t\t\tif (readExtensions(ExtFunction, ExtData, info) == GIF_ERROR) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile (ExtData != NULL) {\n\t\t\t\t\tif (DGifGetExtensionNext(gifFilePtr, &ExtData) == GIF_ERROR) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (isInitialPass && readExtensions(ExtFunction, ExtData, info) == GIF_ERROR) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase TERMINATE_RECORD_TYPE:\n\t\t\t\tbreak;\n\n\t\t\tdefault: /* Should be trapped by DGifGetRecordType */\n\t\t\t\tbreak;\n\t\t}\n\t} while (RecordType != TERMINATE_RECORD_TYPE);\n\n\tinfo->rewindFunction(info);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 144913,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "char *QuotedString::extractFrom(char *input, char **endPtr) {\n  char firstChar = *input;\n\n  if (!isQuote(firstChar)) {\n    // must start with a quote\n    return NULL;\n  }\n\n  char stopChar = firstChar;  // closing quote is the same as opening quote\n\n  char *startPtr = input + 1;  // skip the quote\n  char *readPtr = startPtr;\n  char *writePtr = startPtr;\n  char c;\n\n  for (;;) {\n    c = *readPtr++;\n\n    if (c == '\\0') {\n      // premature ending\n      return NULL;\n    }\n\n    if (c == stopChar) {\n      // closing quote\n      break;\n    }\n\n    if (c == '\\\\') {\n      // replace char\n      c = unescapeChar(*readPtr++);\n    }\n\n    *writePtr++ = c;\n  }\n\n  // end the string here\n  *writePtr = '\\0';\n\n  // update end ptr\n  *endPtr = readPtr;\n\n  return startPtr;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145036,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "char *QuotedString::extractFrom(char *input, char **endPtr) {\n  char *startPtr = input + 1;  // skip the quote\n  char *readPtr = startPtr;\n  char *writePtr = startPtr;\n  char c;\n\n  char firstChar = *input;\n  char stopChar = firstChar;  // closing quote is the same as opening quote\n\n  if (!isQuote(firstChar)) goto ERROR_OPENING_QUOTE_MISSING;\n\n  for (;;) {\n    c = *readPtr++;\n\n    if (c == '\\0') goto ERROR_CLOSING_QUOTE_MISSING;\n\n    if (c == stopChar) goto SUCCESS;\n\n    if (c == '\\\\') {\n      // replace char\n      c = unescapeChar(*readPtr++);\n      if (c == '\\0') goto ERROR_ESCAPE_SEQUENCE_INTERRUPTED;\n    }\n\n    *writePtr++ = c;\n  }\n\nSUCCESS:\n  // end the string here\n  *writePtr = '\\0';\n\n  // update end ptr\n  *endPtr = readPtr;\n\n  // return pointer to unquoted string\n  return startPtr;\n\nERROR_OPENING_QUOTE_MISSING:\nERROR_CLOSING_QUOTE_MISSING:\nERROR_ESCAPE_SEQUENCE_INTERRUPTED:\n  return NULL;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145037,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "static bool w2p(char *ip, char *op) {\n  FILE *fp = openr(ip);\n  if(!fp) return 1;\n  bool openwdone = 0;\n  uint8_t *x = 0, *b = 0;\n  png_struct *p = 0;\n  png_info *n = 0;\n  uint8_t i[12];\n  char *k[] = {\"Out of memory\", \"Broken config, file a bug report\",\n    \"Invalid WebP\", \"???\", \"???\", \"???\", \"I/O error\"};\n  // unsupported feature, suspended, canceled\n  if(!fread(i, 12, 1, fp)) {\n    PF(\"ERROR reading %s: %s\", IP, k[6]);\n    goto w2p_close;\n  }\n  if(memcmp(i, (char[4]){\"RIFF\"}, 4) || memcmp(i + 8, (char[4]){\"WEBP\"}, 4)) {\n    PF(\"ERROR reading %s: %s\", IP, k[2]);\n    goto w2p_close;\n  }\n  size_t l = ((uint32_t)(i[4] | (i[5] << 8) | (i[6] << 16) | (i[7] << 24))) + 8;\n  // ^ RIFF header size\n  x = malloc(l);\n  if(!x) {\n    PF(\"ERROR reading %s: %s\", IP, *k);\n    goto w2p_close;\n  }\n  memcpy(x, i, 12); // should optimize out\n  if(!fread(x + 12, l - 12, 1, fp)) {\n    PF(\"ERROR reading %s: %s\", IP, k[6]);\n    goto w2p_close;\n  }\n  fclose(fp);\n#if defined LOSSYISERROR || defined NOTHREADS\n  WebPBitstreamFeatures I;\n#else\n  WebPDecoderConfig c = {.options.use_threads = 1};\n#define I c.input\n#endif\n  VP8StatusCode r = WebPGetFeatures(x, l, &I);\n  if(r) {\n    PF(\"ERROR reading %s: %s\", IP, k[r - 1]);\n    goto w2p_free;\n  }\n#define V I.format\n#define W ((uint32_t)I.width)\n#define H ((uint32_t)I.height)\n#define A I.has_alpha\n#ifdef LOSSYISERROR\n#define FMTSTR\n#define FMTARG\n#define ANMSTR \"%s\"\n#define ANMARG , \"animat\"\n#else\n  char *f[] = {\"undefined/mixed\", \"lossy\", \"lossless\"};\n#define FMTSTR \"\\nFormat: %s\"\n#define FMTARG , f[V]\n#define ANMSTR \"animat\"\n#define ANMARG\n#endif\n  PFV(\"Info: %s:\\nDimensions: %\" PRIu32 \" x %\" PRIu32\n      \"\\nSize: %zu bytes (%.15g bpp)\\nUses alpha: %s\" FMTSTR,\n    IP, W, H, l, (double)l * 8 / (W * H), A ? \"yes\" : \"no\" FMTARG);\n  if(I.has_animation) {\n    PF(\"ERROR reading %s: Unsupported feature: \" ANMSTR \"ion\", IP ANMARG);\n    goto w2p_free;\n  }\n#ifdef LOSSYISERROR\n  if(V != 2) {\n    PF(\"ERROR reading %s: Unsupported feature: %sion\", IP, \"lossy compress\");\n    goto w2p_free;\n  }\n#endif\n#define B ((unsigned)(3 + A))\n  b = malloc(W * H * B);\n  if(!b) {\n    PF(\"ERROR reading %s: %s\", IP, *k);\n    goto w2p_free;\n  }\n#if defined LOSSYISERROR || defined NOTHREADS\n  if(!(A ? WebPDecodeRGBAInto : WebPDecodeRGBInto)(\n       x, l, b, W * H * B, (int)(W * B))) {\n    PF(\"ERROR reading %s: %s\", IP, k[2]);\n    goto w2p_free;\n  }\n#else\n  c.output.colorspace = A ? MODE_RGBA : MODE_RGB;\n  c.output.is_external_memory = 1;\n#define D c.output.u.RGBA\n  D.rgba = b;\n  D.stride = (int)(W * B);\n  D.size = W * H * B;\n  r = WebPDecode(x, l, &c);\n  if(r) {\n    PF(\"ERROR reading %s: %s\", IP, k[r - 1]);\n    goto w2p_free;\n  }\n#endif\n  free(x);\n  x = 0;\n  if(!(fp = openw(op))) goto w2p_free;\n  openwdone = !!op;\n  p = png_create_write_struct(PNG_LIBPNG_VER_STRING, op, pngwerr, pngwarn);\n  if(!p) {\n    PF(\"ERROR writing %s: %s\", OP, *k);\n    goto w2p_close;\n  }\n  n = png_create_info_struct(p);\n  if(!n) {\n    PF(\"ERROR writing %s: %s\", OP, *k);\n    goto w2p_close;\n  }\n  if(setjmp(png_jmpbuf(p))) {\n  w2p_close:\n    fclose(fp);\n  w2p_free:\n    if(openwdone) remove(op);\n    free(x);\n    free(b);\n    png_destroy_write_struct(&p, &n);\n    return 1;\n  }\n  pnglen = 0;\n  png_set_write_fn(p, fp, pngwrite, pngflush);\n  png_set_filter(p, 0, PNG_ALL_FILTERS);\n  png_set_compression_level(p, 9);\n  // png_set_compression_memlevel(p, 9);\n  png_set_IHDR(p, n, W, H, 8, A ? 6 : 2, 0, 0, 0);\n  png_write_info(p, n);\n  uint8_t *w = b;\n  for(unsigned y = H; y; y--) {\n    png_write_row(p, w);\n    w += W * B;\n  }\n  png_write_end(p, n);\n  png_destroy_write_struct(&p, &n);\n  p = 0;\n  n = 0;\n  free(b);\n  b = 0;\n  if(fclose(fp)) {\n    PF(\"ERROR closing %s: %s\", OP, strerror(errno));\n    goto w2p_free;\n  }\n  PFV(\"Info: %s:\\nDimensions: %\" PRIu32 \" x %\" PRIu32\n      \"\\nSize: %zu bytes (%.15g bpp)\\nFormat: %u-bit %s%s%s\\nGamma: %.5g\",\n    OP, W, H, pnglen, (double)pnglen * 8 / (W * H), 8, A ? \"RGBA\" : \"RGB\", \"\",\n    \"\", 1 / 2.2);\n  return 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145148,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "static bool w2p(char *ip, char *op) {\n  FILE *fp = openr(ip);\n  if(!fp) return 1;\n  bool openwdone = 0;\n  uint8_t *x = 0, *b = 0;\n  png_struct *p = 0;\n  png_info *n = 0;\n  uint8_t i[12];\n  char *k[] = {\"Out of memory\", \"Broken config, file a bug report\",\n    \"Invalid WebP\", \"???\", \"???\", \"???\", \"I/O error\"};\n  // unsupported feature, suspended, canceled\n  if(!fread(i, 12, 1, fp)) {\n    PF(\"ERROR reading %s: %s\", IP, k[6]);\n    goto w2p_close;\n  }\n  if(memcmp(i, (char[4]){\"RIFF\"}, 4) || memcmp(i + 8, (char[4]){\"WEBP\"}, 4)) {\n    PF(\"ERROR reading %s: %s\", IP, k[2]);\n    goto w2p_close;\n  }\n  size_t l = ((uint32_t)(i[4] | (i[5] << 8) | (i[6] << 16) | (i[7] << 24))) + 8;\n  // ^ RIFF header size\n  if(l <= 12\n#ifdef SSIZE_MAX\n    || l - 12 > SSIZE_MAX\n#endif\n  ) {\n    PF(\"ERROR reading %s: %s\", IP, k[2]);\n    goto w2p_close;\n  }\n  x = malloc(l);\n  if(!x) {\n    PF(\"ERROR reading %s: %s\", IP, *k);\n    goto w2p_close;\n  }\n  memcpy(x, i, 12); // should optimize out\n  if(!fread(x + 12, l - 12, 1, fp)) {\n    PF(\"ERROR reading %s: %s\", IP, k[6]);\n    goto w2p_close;\n  }\n  fclose(fp);\n#if defined LOSSYISERROR || defined NOTHREADS\n  WebPBitstreamFeatures I;\n#else\n  WebPDecoderConfig c = {.options.use_threads = 1};\n#define I c.input\n#endif\n  VP8StatusCode r = WebPGetFeatures(x, l, &I);\n  if(r) {\n    PF(\"ERROR reading %s: %s\", IP, k[r - 1]);\n    goto w2p_free;\n  }\n#define V I.format\n#define W ((uint32_t)I.width)\n#define H ((uint32_t)I.height)\n#define A I.has_alpha\n#ifdef LOSSYISERROR\n#define FMTSTR\n#define FMTARG\n#define ANMSTR \"%s\"\n#define ANMARG , \"animat\"\n#else\n  char *f[] = {\"undefined/mixed\", \"lossy\", \"lossless\"};\n#define FMTSTR \"\\nFormat: %s\"\n#define FMTARG , f[V]\n#define ANMSTR \"animat\"\n#define ANMARG\n#endif\n  PFV(\"Info: %s:\\nDimensions: %\" PRIu32 \" x %\" PRIu32\n      \"\\nSize: %zu bytes (%.15g bpp)\\nUses alpha: %s\" FMTSTR,\n    IP, W, H, l, (double)l * 8 / (W * H), A ? \"yes\" : \"no\" FMTARG);\n  if(I.has_animation) {\n    PF(\"ERROR reading %s: Unsupported feature: \" ANMSTR \"ion\", IP ANMARG);\n    goto w2p_free;\n  }\n#ifdef LOSSYISERROR\n  if(V != 2) {\n    PF(\"ERROR reading %s: Unsupported feature: %sion\", IP, \"lossy compress\");\n    goto w2p_free;\n  }\n#endif\n#define B ((unsigned)(3 + A))\n  b = malloc(W * H * B);\n  if(!b) {\n    PF(\"ERROR reading %s: %s\", IP, *k);\n    goto w2p_free;\n  }\n#if defined LOSSYISERROR || defined NOTHREADS\n  if(!(A ? WebPDecodeRGBAInto : WebPDecodeRGBInto)(\n       x, l, b, W * H * B, (int)(W * B))) {\n    PF(\"ERROR reading %s: %s\", IP, k[2]);\n    goto w2p_free;\n  }\n#else\n  c.output.colorspace = A ? MODE_RGBA : MODE_RGB;\n  c.output.is_external_memory = 1;\n#define D c.output.u.RGBA\n  D.rgba = b;\n  D.stride = (int)(W * B);\n  D.size = W * H * B;\n  r = WebPDecode(x, l, &c);\n  if(r) {\n    PF(\"ERROR reading %s: %s\", IP, k[r - 1]);\n    goto w2p_free;\n  }\n#endif\n  free(x);\n  x = 0;\n  if(!(fp = openw(op))) goto w2p_free;\n  openwdone = !!op;\n  p = png_create_write_struct(PNG_LIBPNG_VER_STRING, op, pngwerr, pngwarn);\n  if(!p) {\n    PF(\"ERROR writing %s: %s\", OP, *k);\n    goto w2p_close;\n  }\n  n = png_create_info_struct(p);\n  if(!n) {\n    PF(\"ERROR writing %s: %s\", OP, *k);\n    goto w2p_close;\n  }\n  if(setjmp(png_jmpbuf(p))) {\n  w2p_close:\n    fclose(fp);\n  w2p_free:\n    if(openwdone) remove(op);\n    free(x);\n    free(b);\n    png_destroy_write_struct(&p, &n);\n    return 1;\n  }\n  pnglen = 0;\n  png_set_write_fn(p, fp, pngwrite, pngflush);\n  png_set_filter(p, 0, PNG_ALL_FILTERS);\n  png_set_compression_level(p, 9);\n  // png_set_compression_memlevel(p, 9);\n  png_set_IHDR(p, n, W, H, 8, A ? 6 : 2, 0, 0, 0);\n  png_write_info(p, n);\n  uint8_t *w = b;\n  for(unsigned y = H; y; y--) {\n    png_write_row(p, w);\n    w += W * B;\n  }\n  png_write_end(p, n);\n  png_destroy_write_struct(&p, &n);\n  p = 0;\n  n = 0;\n  free(b);\n  b = 0;\n  if(fclose(fp)) {\n    PF(\"ERROR closing %s: %s\", OP, strerror(errno));\n    goto w2p_free;\n  }\n  PFV(\"Info: %s:\\nDimensions: %\" PRIu32 \" x %\" PRIu32\n      \"\\nSize: %zu bytes (%.15g bpp)\\nFormat: %u-bit %s%s%s\\nGamma: %.5g\",\n    OP, W, H, pnglen, (double)pnglen * 8 / (W * H), 8, A ? \"RGBA\" : \"RGB\", \"\",\n    \"\", 1 / 2.2);\n  return 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145149,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "int snd_rawmidi_input_params(struct snd_rawmidi_substream *substream,\n\t\t\t     struct snd_rawmidi_params * params)\n{\n\tchar *newbuf;\n\tstruct snd_rawmidi_runtime *runtime = substream->runtime;\n\n\tsnd_rawmidi_drain_input(substream);\n\tif (params->buffer_size < 32 || params->buffer_size > 1024L * 1024L) {\n\t\treturn -EINVAL;\n\t}\n\tif (params->avail_min < 1 || params->avail_min > params->buffer_size) {\n\t\treturn -EINVAL;\n\t}\n\tif (params->buffer_size != runtime->buffer_size) {\n\t\tnewbuf = krealloc(runtime->buffer, params->buffer_size,\n\t\t\t\t  GFP_KERNEL);\n\t\tif (!newbuf)\n\t\t\treturn -ENOMEM;\n\t\truntime->buffer = newbuf;\n\t\truntime->buffer_size = params->buffer_size;\n\t}\n\truntime->avail_min = params->avail_min;\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145382,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "int snd_rawmidi_input_params(struct snd_rawmidi_substream *substream,\n\t\t\t     struct snd_rawmidi_params * params)\n{\n\tchar *newbuf, *oldbuf;\n\tstruct snd_rawmidi_runtime *runtime = substream->runtime;\n\n\tsnd_rawmidi_drain_input(substream);\n\tif (params->buffer_size < 32 || params->buffer_size > 1024L * 1024L) {\n\t\treturn -EINVAL;\n\t}\n\tif (params->avail_min < 1 || params->avail_min > params->buffer_size) {\n\t\treturn -EINVAL;\n\t}\n\tif (params->buffer_size != runtime->buffer_size) {\n\t\tnewbuf = kmalloc(params->buffer_size, GFP_KERNEL);\n\t\tif (!newbuf)\n\t\t\treturn -ENOMEM;\n\t\tspin_lock_irq(&runtime->lock);\n\t\toldbuf = runtime->buffer;\n\t\truntime->buffer = newbuf;\n\t\truntime->buffer_size = params->buffer_size;\n\t\truntime->appl_ptr = runtime->hw_ptr = 0;\n\t\tspin_unlock_irq(&runtime->lock);\n\t\tkfree(oldbuf);\n\t}\n\truntime->avail_min = params->avail_min;\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145383,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "SPL_METHOD(SplDoublyLinkedList, offsetSet)\n{\n\tzval                  *zindex, *value;\n\tspl_dllist_object     *intern;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"zz\", &zindex, &value) == FAILURE) {\n\t\treturn;\n\t}\n\n\tintern = Z_SPLDLLIST_P(getThis());\n\n\tif (Z_TYPE_P(zindex) == IS_NULL) {\n\t\t/* $obj[] = ... */\n\t\tspl_ptr_llist_push(intern->llist, value);\n\t} else {\n\t\t/* $obj[$foo] = ... */\n\t\tzend_long                   index;\n\t\tspl_ptr_llist_element *element;\n\n\t\tindex = spl_offset_convert_to_long(zindex);\n\n\t\tif (index < 0 || index >= intern->llist->count) {\n\t\t\tzval_ptr_dtor(value);\n\t\t\tzend_throw_exception(spl_ce_OutOfRangeException, \"Offset invalid or out of range\", 0);\n\t\t\treturn;\n\t\t}\n\n\t\telement = spl_ptr_llist_offset(intern->llist, index, intern->flags & SPL_DLLIST_IT_LIFO);\n\n\t\tif (element != NULL) {\n\t\t\t/* call dtor on the old element as in spl_ptr_llist_pop */\n\t\t\tif (intern->llist->dtor) {\n\t\t\t\tintern->llist->dtor(element);\n\t\t\t}\n\n\t\t\t/* the element is replaced, delref the old one as in\n\t\t\t * SplDoublyLinkedList::pop() */\n\t\t\tzval_ptr_dtor(&element->data);\n\t\t\tZVAL_COPY_VALUE(&element->data, value);\n\n\t\t\t/* new element, call ctor as in spl_ptr_llist_push */\n\t\t\tif (intern->llist->ctor) {\n\t\t\t\tintern->llist->ctor(element);\n\t\t\t}\n\t\t} else {\n\t\t\tzval_ptr_dtor(value);\n\t\t\tzend_throw_exception(spl_ce_OutOfRangeException, \"Offset invalid\", 0);\n\t\t\treturn;\n\t\t}\n\t}\n} /* }}} */",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145456,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "SPL_METHOD(SplDoublyLinkedList, offsetSet)\n{\n\tzval                  *zindex, *value;\n\tspl_dllist_object     *intern;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"zz\", &zindex, &value) == FAILURE) {\n\t\treturn;\n\t}\n\n\tintern = Z_SPLDLLIST_P(getThis());\n\n\tif (Z_TYPE_P(zindex) == IS_NULL) {\n\t\t/* $obj[] = ... */\n\t\tspl_ptr_llist_push(intern->llist, value);\n\t} else {\n\t\t/* $obj[$foo] = ... */\n\t\tzend_long                   index;\n\t\tspl_ptr_llist_element *element;\n\n\t\tindex = spl_offset_convert_to_long(zindex);\n\n\t\tif (index < 0 || index >= intern->llist->count) {\n\t\t\tzend_throw_exception(spl_ce_OutOfRangeException, \"Offset invalid or out of range\", 0);\n\t\t\treturn;\n\t\t}\n\n\t\telement = spl_ptr_llist_offset(intern->llist, index, intern->flags & SPL_DLLIST_IT_LIFO);\n\n\t\tif (element != NULL) {\n\t\t\t/* call dtor on the old element as in spl_ptr_llist_pop */\n\t\t\tif (intern->llist->dtor) {\n\t\t\t\tintern->llist->dtor(element);\n\t\t\t}\n\n\t\t\t/* the element is replaced, delref the old one as in\n\t\t\t * SplDoublyLinkedList::pop() */\n\t\t\tzval_ptr_dtor(&element->data);\n\t\t\tZVAL_COPY_VALUE(&element->data, value);\n\n\t\t\t/* new element, call ctor as in spl_ptr_llist_push */\n\t\t\tif (intern->llist->ctor) {\n\t\t\t\tintern->llist->ctor(element);\n\t\t\t}\n\t\t} else {\n\t\t\tzval_ptr_dtor(value);\n\t\t\tzend_throw_exception(spl_ce_OutOfRangeException, \"Offset invalid\", 0);\n\t\t\treturn;\n\t\t}\n\t}\n} /* }}} */",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145457,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "psutil_net_if_addrs(PyObject* self, PyObject* args) {\n    struct ifaddrs *ifaddr, *ifa;\n    int family;\n\n    PyObject *py_retlist = PyList_New(0);\n    PyObject *py_tuple = NULL;\n    PyObject *py_address = NULL;\n    PyObject *py_netmask = NULL;\n    PyObject *py_broadcast = NULL;\n    PyObject *py_ptp = NULL;\n\n    if (py_retlist == NULL)\n        return NULL;\n    if (getifaddrs(&ifaddr) == -1) {\n        PyErr_SetFromErrno(PyExc_OSError);\n        goto error;\n    }\n\n    for (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {\n        if (!ifa->ifa_addr)\n            continue;\n        family = ifa->ifa_addr->sa_family;\n        py_address = psutil_convert_ipaddr(ifa->ifa_addr, family);\n        // If the primary address can't be determined just skip it.\n        // I've never seen this happen on Linux but I did on FreeBSD.\n        if (py_address == Py_None)\n            continue;\n        if (py_address == NULL)\n            goto error;\n        py_netmask = psutil_convert_ipaddr(ifa->ifa_netmask, family);\n        if (py_netmask == NULL)\n            goto error;\n\n        if (ifa->ifa_flags & IFF_BROADCAST) {\n            py_broadcast = psutil_convert_ipaddr(ifa->ifa_broadaddr, family);\n            Py_INCREF(Py_None);\n            py_ptp = Py_None;\n        }\n        else if (ifa->ifa_flags & IFF_POINTOPOINT) {\n            py_ptp = psutil_convert_ipaddr(ifa->ifa_dstaddr, family);\n            Py_INCREF(Py_None);\n            py_broadcast = Py_None;\n        }\n        else {\n            Py_INCREF(Py_None);\n            Py_INCREF(Py_None);\n            py_broadcast = Py_None;\n            py_ptp = Py_None;\n        }\n\n        if ((py_broadcast == NULL) || (py_ptp == NULL))\n            goto error;\n        py_tuple = Py_BuildValue(\n            \"(siOOOO)\",\n            ifa->ifa_name,\n            family,\n            py_address,\n            py_netmask,\n            py_broadcast,\n            py_ptp\n        );\n\n        if (! py_tuple)\n            goto error;\n        if (PyList_Append(py_retlist, py_tuple))\n            goto error;\n        Py_DECREF(py_tuple);\n        Py_DECREF(py_address);\n        Py_DECREF(py_netmask);\n        Py_DECREF(py_broadcast);\n        Py_DECREF(py_ptp);\n    }\n\n    freeifaddrs(ifaddr);\n    return py_retlist;\n\nerror:\n    if (ifaddr != NULL)\n        freeifaddrs(ifaddr);\n    Py_DECREF(py_retlist);\n    Py_XDECREF(py_tuple);\n    Py_XDECREF(py_address);\n    Py_XDECREF(py_netmask);\n    Py_XDECREF(py_broadcast);\n    Py_XDECREF(py_ptp);\n    return NULL;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145532,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "psutil_net_if_addrs(PyObject* self, PyObject* args) {\n    struct ifaddrs *ifaddr, *ifa;\n    int family;\n\n    PyObject *py_retlist = PyList_New(0);\n    PyObject *py_tuple = NULL;\n    PyObject *py_address = NULL;\n    PyObject *py_netmask = NULL;\n    PyObject *py_broadcast = NULL;\n    PyObject *py_ptp = NULL;\n\n    if (py_retlist == NULL)\n        return NULL;\n    if (getifaddrs(&ifaddr) == -1) {\n        PyErr_SetFromErrno(PyExc_OSError);\n        goto error;\n    }\n\n    for (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {\n        if (!ifa->ifa_addr)\n            continue;\n        family = ifa->ifa_addr->sa_family;\n        py_address = psutil_convert_ipaddr(ifa->ifa_addr, family);\n        // If the primary address can't be determined just skip it.\n        // I've never seen this happen on Linux but I did on FreeBSD.\n        if (py_address == Py_None)\n            continue;\n        if (py_address == NULL)\n            goto error;\n        py_netmask = psutil_convert_ipaddr(ifa->ifa_netmask, family);\n        if (py_netmask == NULL)\n            goto error;\n\n        if (ifa->ifa_flags & IFF_BROADCAST) {\n            py_broadcast = psutil_convert_ipaddr(ifa->ifa_broadaddr, family);\n            Py_INCREF(Py_None);\n            py_ptp = Py_None;\n        }\n        else if (ifa->ifa_flags & IFF_POINTOPOINT) {\n            py_ptp = psutil_convert_ipaddr(ifa->ifa_dstaddr, family);\n            Py_INCREF(Py_None);\n            py_broadcast = Py_None;\n        }\n        else {\n            Py_INCREF(Py_None);\n            Py_INCREF(Py_None);\n            py_broadcast = Py_None;\n            py_ptp = Py_None;\n        }\n\n        if ((py_broadcast == NULL) || (py_ptp == NULL))\n            goto error;\n        py_tuple = Py_BuildValue(\n            \"(siOOOO)\",\n            ifa->ifa_name,\n            family,\n            py_address,\n            py_netmask,\n            py_broadcast,\n            py_ptp\n        );\n\n        if (! py_tuple)\n            goto error;\n        if (PyList_Append(py_retlist, py_tuple))\n            goto error;\n        Py_CLEAR(py_tuple);\n        Py_CLEAR(py_address);\n        Py_CLEAR(py_netmask);\n        Py_CLEAR(py_broadcast);\n        Py_CLEAR(py_ptp);\n    }\n\n    freeifaddrs(ifaddr);\n    return py_retlist;\n\nerror:\n    if (ifaddr != NULL)\n        freeifaddrs(ifaddr);\n    Py_DECREF(py_retlist);\n    Py_XDECREF(py_tuple);\n    Py_XDECREF(py_address);\n    Py_XDECREF(py_netmask);\n    Py_XDECREF(py_broadcast);\n    Py_XDECREF(py_ptp);\n    return NULL;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145533,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "usm_free_usmStateReference(void *old)\n{\n    struct usmStateReference *old_ref = (struct usmStateReference *) old;\n\n    if (old_ref) {\n\n        if (old_ref->usr_name_length)\n            SNMP_FREE(old_ref->usr_name);\n        if (old_ref->usr_engine_id_length)\n            SNMP_FREE(old_ref->usr_engine_id);\n        if (old_ref->usr_auth_protocol_length)\n            SNMP_FREE(old_ref->usr_auth_protocol);\n        if (old_ref->usr_priv_protocol_length)\n            SNMP_FREE(old_ref->usr_priv_protocol);\n\n        if (old_ref->usr_auth_key_length && old_ref->usr_auth_key) {\n            SNMP_ZERO(old_ref->usr_auth_key, old_ref->usr_auth_key_length);\n            SNMP_FREE(old_ref->usr_auth_key);\n        }\n        if (old_ref->usr_priv_key_length && old_ref->usr_priv_key) {\n            SNMP_ZERO(old_ref->usr_priv_key, old_ref->usr_priv_key_length);\n            SNMP_FREE(old_ref->usr_priv_key);\n        }\n\n        SNMP_ZERO(old_ref, sizeof(*old_ref));\n        SNMP_FREE(old_ref);\n\n    }\n\n}                               /* end usm_free_usmStateReference() */",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145556,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "usm_free_usmStateReference(void *old)\n{\n    struct usmStateReference *ref = old;\n\n    if (!ref)\n        return;\n\n    if (--ref->refcnt > 0)\n        return;\n\n    SNMP_FREE(ref->usr_name);\n    SNMP_FREE(ref->usr_engine_id);\n    SNMP_FREE(ref->usr_auth_protocol);\n    SNMP_FREE(ref->usr_priv_protocol);\n\n    if (ref->usr_auth_key_length && ref->usr_auth_key) {\n        SNMP_ZERO(ref->usr_auth_key, ref->usr_auth_key_length);\n        SNMP_FREE(ref->usr_auth_key);\n    }\n    if (ref->usr_priv_key_length && ref->usr_priv_key) {\n        SNMP_ZERO(ref->usr_priv_key, ref->usr_priv_key_length);\n        SNMP_FREE(ref->usr_priv_key);\n    }\n\n    SNMP_FREE(ref);\n}                               /* end usm_free_usmStateReference() */",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145557,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "void check_file_actlst(int *ifd, char *dfile, struct activity *act[], uint64_t flags,\n\t\t       struct file_magic *file_magic, struct file_header *file_hdr,\n\t\t       struct file_activity **file_actlst, unsigned int id_seq[],\n\t\t       int ignore, int *endian_mismatch, int *arch_64)\n{\n\tint i, j, k, p;\n\tstruct file_activity *fal;\n\tvoid *buffer = NULL;\n\tsize_t bh_size = FILE_HEADER_SIZE;\n\tsize_t ba_size = FILE_ACTIVITY_SIZE;\n\n\t/* Open sa data file and read its magic structure */\n\tif (sa_open_read_magic(ifd, dfile, file_magic, ignore, endian_mismatch, TRUE) < 0)\n\t\t/*\n\t\t * Not current sysstat's format.\n\t\t * Return now so that sadf -H can display at least\n\t\t * file's version and magic number.\n\t\t */\n\t\treturn;\n\n\t/*\n\t * We know now that we have a *compatible* sysstat datafile format\n\t * (correct FORMAT_MAGIC value), and in this case, we should have\n\t * checked header_size value. Anyway, with a corrupted datafile,\n\t * this may not be the case. So check again.\n\t */\n\tif ((file_magic->header_size <= MIN_FILE_HEADER_SIZE) ||\n\t    (file_magic->header_size > MAX_FILE_HEADER_SIZE)) {\n#ifdef DEBUG\n\t\tfprintf(stderr, \"%s: header_size=%u\\n\",\n\t\t\t__FUNCTION__, file_magic->header_size);\n#endif\n\t\tgoto format_error;\n\t}\n\n\t/* Allocate buffer for file_header structure */\n\tif (file_magic->header_size > FILE_HEADER_SIZE) {\n\t\tbh_size = file_magic->header_size;\n\t}\n\tSREALLOC(buffer, char, bh_size);\n\n\t/* Read sa data file standard header and allocate activity list */\n\tsa_fread(*ifd, buffer, (size_t) file_magic->header_size, HARD_SIZE, UEOF_STOP);\n\t/*\n\t * Data file header size (file_magic->header_size) may be greater or\n\t * smaller than FILE_HEADER_SIZE. Remap the fields of the file header\n\t * then copy its contents to the expected structure.\n\t */\n\tif (remap_struct(hdr_types_nr, file_magic->hdr_types_nr, buffer,\n\t\t\t file_magic->header_size, FILE_HEADER_SIZE, bh_size) < 0)\n\t\tgoto format_error;\n\n\tmemcpy(file_hdr, buffer, FILE_HEADER_SIZE);\n\tfree(buffer);\n\tbuffer = NULL;\n\n\t/* Tell that data come from a 64 bit machine */\n\t*arch_64 = (file_hdr->sa_sizeof_long == SIZEOF_LONG_64BIT);\n\n\t/* Normalize endianness for file_hdr structure */\n\tif (*endian_mismatch) {\n\t\tswap_struct(hdr_types_nr, file_hdr, *arch_64);\n\t}\n\n\t/*\n\t * Sanity checks.\n\t * NB: Compare against MAX_NR_ACT and not NR_ACT because\n\t * we are maybe reading a datafile from a future sysstat version\n\t * with more activities than known today.\n\t */\n\tif ((file_hdr->sa_act_nr > MAX_NR_ACT) ||\n\t    (file_hdr->act_size > MAX_FILE_ACTIVITY_SIZE) ||\n\t    (file_hdr->rec_size > MAX_RECORD_HEADER_SIZE) ||\n\t    (MAP_SIZE(file_hdr->act_types_nr) > file_hdr->act_size) ||\n\t    (MAP_SIZE(file_hdr->rec_types_nr) > file_hdr->rec_size)) {\n#ifdef DEBUG\n\t\tfprintf(stderr, \"%s: sa_act_nr=%d act_size=%u rec_size=%u map_size(act)=%u map_size(rec)=%u\\n\",\n\t\t\t__FUNCTION__, file_hdr->sa_act_nr, file_hdr->act_size, file_hdr->rec_size,\n\t\t\tMAP_SIZE(file_hdr->act_types_nr), MAP_SIZE(file_hdr->rec_types_nr));\n#endif\n\t\t/* Maybe a \"false positive\" sysstat datafile? */\n\t\tgoto format_error;\n\t}\n\n\t/* Allocate buffer for file_activity structures */\n\tif (file_hdr->act_size > FILE_ACTIVITY_SIZE) {\n\t\tba_size = file_hdr->act_size;\n\t}\n\tSREALLOC(buffer, char, ba_size);\n\tSREALLOC(*file_actlst, struct file_activity, FILE_ACTIVITY_SIZE * file_hdr->sa_act_nr);\n\tfal = *file_actlst;\n\n\t/* Read activity list */\n\tj = 0;\n\tfor (i = 0; i < file_hdr->sa_act_nr; i++, fal++) {\n\n\t\t/* Read current file_activity structure from file */\n\t\tsa_fread(*ifd, buffer, (size_t) file_hdr->act_size, HARD_SIZE, UEOF_STOP);\n\t\t/*\n\t\t* Data file_activity size (file_hdr->act_size) may be greater or\n\t\t* smaller than FILE_ACTIVITY_SIZE. Remap the fields of the file's structure\n\t\t* then copy its contents to the expected structure.\n\t\t*/\n\t\tif (remap_struct(act_types_nr, file_hdr->act_types_nr, buffer,\n\t\t\t     file_hdr->act_size, FILE_ACTIVITY_SIZE, ba_size) < 0)\n\t\t\tgoto format_error;\n\t\tmemcpy(fal, buffer, FILE_ACTIVITY_SIZE);\n\n\t\t/* Normalize endianness for file_activity structures */\n\t\tif (*endian_mismatch) {\n\t\t\tswap_struct(act_types_nr, fal, *arch_64);\n\t\t}\n\n\t\t/*\n\t\t * Every activity, known or unknown, should have\n\t\t * at least one item and sub-item, and a positive size value.\n\t\t * Also check that the number of items and sub-items\n\t\t * doesn't exceed a max value. This is necessary\n\t\t * because we will use @nr and @nr2 to\n\t\t * allocate memory to read the file contents. So we\n\t\t * must make sure the file is not corrupted.\n\t\t * NB: Another check will be made below for known\n\t\t * activities which have each a specific max value.\n\t\t */\n\t\tif ((fal->nr < 1) || (fal->nr2 < 1) ||\n\t\t    (fal->nr > NR_MAX) || (fal->nr2 > NR2_MAX) ||\n\t\t    (fal->size <= 0)) {\n#ifdef DEBUG\n\t\t\tfprintf(stderr, \"%s: id=%d nr=%d nr2=%d\\n\",\n\t\t\t\t__FUNCTION__, fal->id, fal->nr, fal->nr2);\n#endif\n\t\t\tgoto format_error;\n\t\t}\n\n\t\tif ((p = get_activity_position(act, fal->id, RESUME_IF_NOT_FOUND)) < 0)\n\t\t\t/* Unknown activity */\n\t\t\tcontinue;\n\n\t\tif (act[p]->magic != fal->magic) {\n\t\t\t/* Bad magical number */\n\t\t\tif (ignore) {\n\t\t\t\t/*\n\t\t\t\t * This is how sadf -H knows that this\n\t\t\t\t * activity has an unknown format.\n\t\t\t\t */\n\t\t\t\tact[p]->magic = ACTIVITY_MAGIC_UNKNOWN;\n\t\t\t}\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/* Check max value for known activities */\n\t\tif (fal->nr > act[p]->nr_max) {\n#ifdef DEBUG\n\t\t\tfprintf(stderr, \"%s: id=%d nr=%d nr_max=%d\\n\",\n\t\t\t\t__FUNCTION__, fal->id, fal->nr, act[p]->nr_max);\n#endif\n\t\t\tgoto format_error;\n\t\t}\n\n\t\t/*\n\t\t * Number of fields of each type (\"long long\", or \"long\"\n\t\t * or \"int\") composing the structure with statistics may\n\t\t * only increase with new sysstat versions. Here, we may\n\t\t * be reading a file created by current sysstat version,\n\t\t * or by an older or a newer version.\n\t\t */\n\t\tif (!(((fal->types_nr[0] >= act[p]->gtypes_nr[0]) &&\n\t\t     (fal->types_nr[1] >= act[p]->gtypes_nr[1]) &&\n\t\t     (fal->types_nr[2] >= act[p]->gtypes_nr[2]))\n\t\t     ||\n\t\t     ((fal->types_nr[0] <= act[p]->gtypes_nr[0]) &&\n\t\t     (fal->types_nr[1] <= act[p]->gtypes_nr[1]) &&\n\t\t     (fal->types_nr[2] <= act[p]->gtypes_nr[2]))) && !ignore) {\n#ifdef DEBUG\n\t\t\tfprintf(stderr, \"%s: id=%d file=%d,%d,%d activity=%d,%d,%d\\n\",\n\t\t\t\t__FUNCTION__, fal->id, fal->types_nr[0], fal->types_nr[1], fal->types_nr[2],\n\t\t\t\tact[p]->gtypes_nr[0], act[p]->gtypes_nr[1], act[p]->gtypes_nr[2]);\n#endif\n\t\t\tgoto format_error;\n\t\t}\n\n\t\tif (MAP_SIZE(fal->types_nr) > fal->size) {\n#ifdef DEBUG\n\t\tfprintf(stderr, \"%s: id=%d size=%u map_size=%u\\n\",\n\t\t\t__FUNCTION__, fal->id, fal->size, MAP_SIZE(fal->types_nr));\n#endif\n\t\t\tgoto format_error;\n\t\t}\n\n\t\tfor (k = 0; k < 3; k++) {\n\t\t\tact[p]->ftypes_nr[k] = fal->types_nr[k];\n\t\t}\n\n\t\tif (fal->size > act[p]->msize) {\n\t\t\tact[p]->msize = fal->size;\n\t\t}\n\n\t\tact[p]->nr_ini = fal->nr;\n\t\tact[p]->nr2    = fal->nr2;\n\t\tact[p]->fsize  = fal->size;\n\t\t/*\n\t\t * This is a known activity with a known format\n\t\t * (magical number). Only such activities will be displayed.\n\t\t * (Well, this may also be an unknown format if we have entered sadf -H.)\n\t\t */\n\t\tid_seq[j++] = fal->id;\n\t}\n\n\twhile (j < NR_ACT) {\n\t\tid_seq[j++] = 0;\n\t}\n\n\tfree(buffer);\n\n\t/* Check that at least one activity selected by the user is available in file */\n\tfor (i = 0; i < NR_ACT; i++) {\n\n\t\tif (!IS_SELECTED(act[i]->options))\n\t\t\tcontinue;\n\n\t\t/* Here is a selected activity: Does it exist in file? */\n\t\tfal = *file_actlst;\n\t\tfor (j = 0; j < file_hdr->sa_act_nr; j++, fal++) {\n\t\t\tif (act[i]->id == fal->id)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (j == file_hdr->sa_act_nr) {\n\t\t\t/* No: Unselect it */\n\t\t\tact[i]->options &= ~AO_SELECTED;\n\t\t}\n\t}\n\n\t/*\n\t * None of selected activities exist in file: Abort.\n\t * NB: Error is ignored if we only want to display\n\t * datafile header (sadf -H).\n\t */\n\tif (!get_activity_nr(act, AO_SELECTED, COUNT_ACTIVITIES) && !DISPLAY_HDR_ONLY(flags)) {\n\t\tfprintf(stderr, _(\"Requested activities not available in file %s\\n\"),\n\t\t\tdfile);\n\t\tclose(*ifd);\n\t\texit(1);\n\t}\n\n\t/*\n\t * Check if there are some extra structures.\n\t * We will just skip them as they are unknown for now.\n\t */\n\tif (file_hdr->extra_next && (skip_extra_struct(*ifd, *endian_mismatch, *arch_64) < 0))\n\t\tgoto format_error;\n\n\treturn;\n\nformat_error:\n\tif (buffer) {\n\t\tfree(buffer);\n\t}\n\thandle_invalid_sa_file(*ifd, file_magic, dfile, 0);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145708,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "void check_file_actlst(int *ifd, char *dfile, struct activity *act[], uint64_t flags,\n\t\t       struct file_magic *file_magic, struct file_header *file_hdr,\n\t\t       struct file_activity **file_actlst, unsigned int id_seq[],\n\t\t       int ignore, int *endian_mismatch, int *arch_64)\n{\n\tint i, j, k, p;\n\tstruct file_activity *fal;\n\tvoid *buffer = NULL;\n\tsize_t bh_size = FILE_HEADER_SIZE;\n\tsize_t ba_size = FILE_ACTIVITY_SIZE;\n\n\t/* Open sa data file and read its magic structure */\n\tif (sa_open_read_magic(ifd, dfile, file_magic, ignore, endian_mismatch, TRUE) < 0)\n\t\t/*\n\t\t * Not current sysstat's format.\n\t\t * Return now so that sadf -H can display at least\n\t\t * file's version and magic number.\n\t\t */\n\t\treturn;\n\n\t/*\n\t * We know now that we have a *compatible* sysstat datafile format\n\t * (correct FORMAT_MAGIC value), and in this case, we should have\n\t * checked header_size value. Anyway, with a corrupted datafile,\n\t * this may not be the case. So check again.\n\t */\n\tif ((file_magic->header_size <= MIN_FILE_HEADER_SIZE) ||\n\t    (file_magic->header_size > MAX_FILE_HEADER_SIZE)) {\n#ifdef DEBUG\n\t\tfprintf(stderr, \"%s: header_size=%u\\n\",\n\t\t\t__FUNCTION__, file_magic->header_size);\n#endif\n\t\tgoto format_error;\n\t}\n\n\t/* Allocate buffer for file_header structure */\n\tif (file_magic->header_size > FILE_HEADER_SIZE) {\n\t\tbh_size = file_magic->header_size;\n\t}\n\tSREALLOC(buffer, char, bh_size);\n\n\t/* Read sa data file standard header and allocate activity list */\n\tsa_fread(*ifd, buffer, (size_t) file_magic->header_size, HARD_SIZE, UEOF_STOP);\n\t/*\n\t * Data file header size (file_magic->header_size) may be greater or\n\t * smaller than FILE_HEADER_SIZE. Remap the fields of the file header\n\t * then copy its contents to the expected structure.\n\t */\n\tif (remap_struct(hdr_types_nr, file_magic->hdr_types_nr, buffer,\n\t\t\t file_magic->header_size, FILE_HEADER_SIZE, bh_size) < 0)\n\t\tgoto format_error;\n\n\tmemcpy(file_hdr, buffer, FILE_HEADER_SIZE);\n\tfree(buffer);\n\tbuffer = NULL;\n\n\t/* Tell that data come from a 64 bit machine */\n\t*arch_64 = (file_hdr->sa_sizeof_long == SIZEOF_LONG_64BIT);\n\n\t/* Normalize endianness for file_hdr structure */\n\tif (*endian_mismatch) {\n\t\tswap_struct(hdr_types_nr, file_hdr, *arch_64);\n\t}\n\n\t/*\n\t * Sanity checks.\n\t * NB: Compare against MAX_NR_ACT and not NR_ACT because\n\t * we are maybe reading a datafile from a future sysstat version\n\t * with more activities than known today.\n\t */\n\tif ((file_hdr->sa_act_nr > MAX_NR_ACT) ||\n\t    (file_hdr->act_size > MAX_FILE_ACTIVITY_SIZE) ||\n\t    (file_hdr->rec_size > MAX_RECORD_HEADER_SIZE) ||\n\t    (MAP_SIZE(file_hdr->act_types_nr) > file_hdr->act_size) ||\n\t    (MAP_SIZE(file_hdr->rec_types_nr) > file_hdr->rec_size)) {\n#ifdef DEBUG\n\t\tfprintf(stderr, \"%s: sa_act_nr=%d act_size=%u rec_size=%u map_size(act)=%u map_size(rec)=%u\\n\",\n\t\t\t__FUNCTION__, file_hdr->sa_act_nr, file_hdr->act_size, file_hdr->rec_size,\n\t\t\tMAP_SIZE(file_hdr->act_types_nr), MAP_SIZE(file_hdr->rec_types_nr));\n#endif\n\t\t/* Maybe a \"false positive\" sysstat datafile? */\n\t\tgoto format_error;\n\t}\n\n\t/* Allocate buffer for file_activity structures */\n\tif (file_hdr->act_size > FILE_ACTIVITY_SIZE) {\n\t\tba_size = file_hdr->act_size;\n\t}\n\tSREALLOC(buffer, char, ba_size);\n\tSREALLOC(*file_actlst, struct file_activity, FILE_ACTIVITY_SIZE * file_hdr->sa_act_nr);\n\tfal = *file_actlst;\n\n\t/* Read activity list */\n\tj = 0;\n\tfor (i = 0; i < file_hdr->sa_act_nr; i++, fal++) {\n\n\t\t/* Read current file_activity structure from file */\n\t\tsa_fread(*ifd, buffer, (size_t) file_hdr->act_size, HARD_SIZE, UEOF_STOP);\n\t\t/*\n\t\t* Data file_activity size (file_hdr->act_size) may be greater or\n\t\t* smaller than FILE_ACTIVITY_SIZE. Remap the fields of the file's structure\n\t\t* then copy its contents to the expected structure.\n\t\t*/\n\t\tif (remap_struct(act_types_nr, file_hdr->act_types_nr, buffer,\n\t\t\t     file_hdr->act_size, FILE_ACTIVITY_SIZE, ba_size) < 0)\n\t\t\tgoto format_error;\n\t\tmemcpy(fal, buffer, FILE_ACTIVITY_SIZE);\n\n\t\t/* Normalize endianness for file_activity structures */\n\t\tif (*endian_mismatch) {\n\t\t\tswap_struct(act_types_nr, fal, *arch_64);\n\t\t}\n\n\t\t/*\n\t\t * Every activity, known or unknown, should have\n\t\t * at least one item and sub-item, and a positive size value.\n\t\t * Also check that the number of items and sub-items\n\t\t * doesn't exceed a max value. This is necessary\n\t\t * because we will use @nr and @nr2 to\n\t\t * allocate memory to read the file contents. So we\n\t\t * must make sure the file is not corrupted.\n\t\t * NB: Another check will be made below for known\n\t\t * activities which have each a specific max value.\n\t\t */\n\t\tif ((fal->nr < 1) || (fal->nr2 < 1) ||\n\t\t    (fal->nr > NR_MAX) || (fal->nr2 > NR2_MAX) ||\n\t\t    (fal->size <= 0)) {\n#ifdef DEBUG\n\t\t\tfprintf(stderr, \"%s: id=%d nr=%d nr2=%d\\n\",\n\t\t\t\t__FUNCTION__, fal->id, fal->nr, fal->nr2);\n#endif\n\t\t\tgoto format_error;\n\t\t}\n\n\t\tif ((p = get_activity_position(act, fal->id, RESUME_IF_NOT_FOUND)) < 0)\n\t\t\t/* Unknown activity */\n\t\t\tcontinue;\n\n\t\tif (act[p]->magic != fal->magic) {\n\t\t\t/* Bad magical number */\n\t\t\tif (ignore) {\n\t\t\t\t/*\n\t\t\t\t * This is how sadf -H knows that this\n\t\t\t\t * activity has an unknown format.\n\t\t\t\t */\n\t\t\t\tact[p]->magic = ACTIVITY_MAGIC_UNKNOWN;\n\t\t\t}\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/* Check max value for known activities */\n\t\tif (fal->nr > act[p]->nr_max) {\n#ifdef DEBUG\n\t\t\tfprintf(stderr, \"%s: id=%d nr=%d nr_max=%d\\n\",\n\t\t\t\t__FUNCTION__, fal->id, fal->nr, act[p]->nr_max);\n#endif\n\t\t\tgoto format_error;\n\t\t}\n\n\t\t/*\n\t\t * Number of fields of each type (\"long long\", or \"long\"\n\t\t * or \"int\") composing the structure with statistics may\n\t\t * only increase with new sysstat versions. Here, we may\n\t\t * be reading a file created by current sysstat version,\n\t\t * or by an older or a newer version.\n\t\t */\n\t\tif (!(((fal->types_nr[0] >= act[p]->gtypes_nr[0]) &&\n\t\t     (fal->types_nr[1] >= act[p]->gtypes_nr[1]) &&\n\t\t     (fal->types_nr[2] >= act[p]->gtypes_nr[2]))\n\t\t     ||\n\t\t     ((fal->types_nr[0] <= act[p]->gtypes_nr[0]) &&\n\t\t     (fal->types_nr[1] <= act[p]->gtypes_nr[1]) &&\n\t\t     (fal->types_nr[2] <= act[p]->gtypes_nr[2]))) && !ignore) {\n#ifdef DEBUG\n\t\t\tfprintf(stderr, \"%s: id=%d file=%d,%d,%d activity=%d,%d,%d\\n\",\n\t\t\t\t__FUNCTION__, fal->id, fal->types_nr[0], fal->types_nr[1], fal->types_nr[2],\n\t\t\t\tact[p]->gtypes_nr[0], act[p]->gtypes_nr[1], act[p]->gtypes_nr[2]);\n#endif\n\t\t\tgoto format_error;\n\t\t}\n\n\t\tif (MAP_SIZE(fal->types_nr) > fal->size) {\n#ifdef DEBUG\n\t\tfprintf(stderr, \"%s: id=%d size=%u map_size=%u\\n\",\n\t\t\t__FUNCTION__, fal->id, fal->size, MAP_SIZE(fal->types_nr));\n#endif\n\t\t\tgoto format_error;\n\t\t}\n\n\t\tfor (k = 0; k < 3; k++) {\n\t\t\tact[p]->ftypes_nr[k] = fal->types_nr[k];\n\t\t}\n\n\t\tif (fal->size > act[p]->msize) {\n\t\t\tact[p]->msize = fal->size;\n\t\t}\n\n\t\tact[p]->nr_ini = fal->nr;\n\t\tact[p]->nr2    = fal->nr2;\n\t\tact[p]->fsize  = fal->size;\n\t\t/*\n\t\t * This is a known activity with a known format\n\t\t * (magical number). Only such activities will be displayed.\n\t\t * (Well, this may also be an unknown format if we have entered sadf -H.)\n\t\t */\n\t\tid_seq[j++] = fal->id;\n\t}\n\n\twhile (j < NR_ACT) {\n\t\tid_seq[j++] = 0;\n\t}\n\n\tfree(buffer);\n\tbuffer = NULL;\n\n\t/* Check that at least one activity selected by the user is available in file */\n\tfor (i = 0; i < NR_ACT; i++) {\n\n\t\tif (!IS_SELECTED(act[i]->options))\n\t\t\tcontinue;\n\n\t\t/* Here is a selected activity: Does it exist in file? */\n\t\tfal = *file_actlst;\n\t\tfor (j = 0; j < file_hdr->sa_act_nr; j++, fal++) {\n\t\t\tif (act[i]->id == fal->id)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (j == file_hdr->sa_act_nr) {\n\t\t\t/* No: Unselect it */\n\t\t\tact[i]->options &= ~AO_SELECTED;\n\t\t}\n\t}\n\n\t/*\n\t * None of selected activities exist in file: Abort.\n\t * NB: Error is ignored if we only want to display\n\t * datafile header (sadf -H).\n\t */\n\tif (!get_activity_nr(act, AO_SELECTED, COUNT_ACTIVITIES) && !DISPLAY_HDR_ONLY(flags)) {\n\t\tfprintf(stderr, _(\"Requested activities not available in file %s\\n\"),\n\t\t\tdfile);\n\t\tclose(*ifd);\n\t\texit(1);\n\t}\n\n\t/*\n\t * Check if there are some extra structures.\n\t * We will just skip them as they are unknown for now.\n\t */\n\tif (file_hdr->extra_next && (skip_extra_struct(*ifd, *endian_mismatch, *arch_64) < 0))\n\t\tgoto format_error;\n\n\treturn;\n\nformat_error:\n\tif (buffer) {\n\t\tfree(buffer);\n\t}\n\thandle_invalid_sa_file(*ifd, file_magic, dfile, 0);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145709,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "static void* OGRExpatRealloc( void *ptr, size_t size )\n{\n    if( CanAlloc(size) )\n        return realloc(ptr, size);\n\n    free(ptr);\n    return nullptr;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145764,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "static void* OGRExpatRealloc( void *ptr, size_t size )\n{\n    if( CanAlloc(size) )\n        return realloc(ptr, size);\n\n    return nullptr;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145765,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "static bool disconnect_cb(struct io *io, void *user_data)\n{\n\tstruct bt_att_chan *chan = user_data;\n\tstruct bt_att *att = chan->att;\n\tint err;\n\tsocklen_t len;\n\n\tlen = sizeof(err);\n\n\tif (getsockopt(chan->fd, SOL_SOCKET, SO_ERROR, &err, &len) < 0) {\n\t\tutil_debug(chan->att->debug_callback, chan->att->debug_data,\n\t\t\t\t\t\"(chan %p) Failed to obtain disconnect\"\n\t\t\t\t\t\" error: %s\", chan, strerror(errno));\n\t\terr = 0;\n\t}\n\n\tutil_debug(chan->att->debug_callback, chan->att->debug_data,\n\t\t\t\t\t\"Channel %p disconnected: %s\",\n\t\t\t\t\tchan, strerror(err));\n\n\t/* Dettach channel */\n\tqueue_remove(att->chans, chan);\n\n\t/* Notify request callbacks */\n\tqueue_remove_all(att->req_queue, NULL, NULL, disc_att_send_op);\n\tqueue_remove_all(att->ind_queue, NULL, NULL, disc_att_send_op);\n\tqueue_remove_all(att->write_queue, NULL, NULL, disc_att_send_op);\n\n\tif (chan->pending_req) {\n\t\tdisc_att_send_op(chan->pending_req);\n\t\tchan->pending_req = NULL;\n\t}\n\n\tif (chan->pending_ind) {\n\t\tdisc_att_send_op(chan->pending_ind);\n\t\tchan->pending_ind = NULL;\n\t}\n\n\tbt_att_chan_free(chan);\n\n\t/* Don't run disconnect callback if there are channels left */\n\tif (!queue_isempty(att->chans))\n\t\treturn false;\n\n\tbt_att_ref(att);\n\n\tqueue_foreach(att->disconn_list, disconn_handler, INT_TO_PTR(err));\n\n\tbt_att_unregister_all(att);\n\tbt_att_unref(att);\n\n\treturn false;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145974,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "static bool disconnect_cb(struct io *io, void *user_data)\n{\n\tstruct bt_att_chan *chan = user_data;\n\tstruct bt_att *att = chan->att;\n\tint err;\n\tsocklen_t len;\n\n\tlen = sizeof(err);\n\n\tif (getsockopt(chan->fd, SOL_SOCKET, SO_ERROR, &err, &len) < 0) {\n\t\tutil_debug(chan->att->debug_callback, chan->att->debug_data,\n\t\t\t\t\t\"(chan %p) Failed to obtain disconnect\"\n\t\t\t\t\t\" error: %s\", chan, strerror(errno));\n\t\terr = 0;\n\t}\n\n\tutil_debug(chan->att->debug_callback, chan->att->debug_data,\n\t\t\t\t\t\"Channel %p disconnected: %s\",\n\t\t\t\t\tchan, strerror(err));\n\n\t/* Dettach channel */\n\tqueue_remove(att->chans, chan);\n\n\tif (chan->pending_req) {\n\t\tdisc_att_send_op(chan->pending_req);\n\t\tchan->pending_req = NULL;\n\t}\n\n\tif (chan->pending_ind) {\n\t\tdisc_att_send_op(chan->pending_ind);\n\t\tchan->pending_ind = NULL;\n\t}\n\n\tbt_att_chan_free(chan);\n\n\t/* Don't run disconnect callback if there are channels left */\n\tif (!queue_isempty(att->chans))\n\t\treturn false;\n\n\tbt_att_ref(att);\n\n\tatt->in_disc = true;\n\n\t/* Notify request callbacks */\n\tqueue_remove_all(att->req_queue, NULL, NULL, disc_att_send_op);\n\tqueue_remove_all(att->ind_queue, NULL, NULL, disc_att_send_op);\n\tqueue_remove_all(att->write_queue, NULL, NULL, disc_att_send_op);\n\n\tatt->in_disc = false;\n\n\tqueue_foreach(att->disconn_list, disconn_handler, INT_TO_PTR(err));\n\n\tbt_att_unregister_all(att);\n\tbt_att_unref(att);\n\n\treturn false;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 145975,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "static plist_t parse_dict_node(struct bplist_data *bplist, const char** bnode, uint64_t size)\n{\n    uint64_t j;\n    uint64_t str_i = 0, str_j = 0;\n    uint64_t index1, index2;\n    plist_data_t data = plist_new_plist_data();\n    const char *const end_data = bplist->data + bplist->size;\n    const char *index1_ptr = NULL;\n    const char *index2_ptr = NULL;\n\n    data->type = PLIST_DICT;\n    data->length = size;\n\n    plist_t node = node_create(NULL, data);\n\n    for (j = 0; j < data->length; j++) {\n        str_i = j * bplist->dict_size;\n        str_j = (j + size) * bplist->dict_size;\n        index1_ptr = (*bnode) + str_i;\n        index2_ptr = (*bnode) + str_j;\n\n        if ((index1_ptr < bplist->data || index1_ptr + bplist->dict_size >= end_data) ||\n            (index2_ptr < bplist->data || index2_ptr + bplist->dict_size >= end_data)) {\n            plist_free(node);\n            return NULL;\n        }\n\n        index1 = UINT_TO_HOST(index1_ptr, bplist->dict_size);\n        index2 = UINT_TO_HOST(index2_ptr, bplist->dict_size);\n\n        if (index1 >= bplist->num_objects) {\n            plist_free(node);\n            return NULL;\n        }\n        if (index2 >= bplist->num_objects) {\n            plist_free(node);\n            return NULL;\n        }\n\n        /* process key node */\n        plist_t key = parse_bin_node_at_index(bplist, index1);\n        if (!key) {\n            plist_free(node);\n            return NULL;\n        }\n        /* enforce key type */\n        plist_get_data(key)->type = PLIST_KEY;\n        if (!plist_get_data(key)->strval) {\n            fprintf(stderr, \"ERROR: Malformed binary plist dict, invalid key node encountered!\\n\");\n            plist_free(key);\n            plist_free(node);\n            return NULL;\n        }\n\n        /* process value node */\n        plist_t val = parse_bin_node_at_index(bplist, index2);\n        if (!val) {\n            plist_free(key);\n            plist_free(node);\n            return NULL;\n        }\n\n        node_attach(node, key);\n        node_attach(node, val);\n    }\n\n    return node;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146038,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "static plist_t parse_dict_node(struct bplist_data *bplist, const char** bnode, uint64_t size)\n{\n    uint64_t j;\n    uint64_t str_i = 0, str_j = 0;\n    uint64_t index1, index2;\n    plist_data_t data = plist_new_plist_data();\n    const char *const end_data = bplist->data + bplist->size;\n    const char *index1_ptr = NULL;\n    const char *index2_ptr = NULL;\n\n    data->type = PLIST_DICT;\n    data->length = size;\n\n    plist_t node = node_create(NULL, data);\n\n    for (j = 0; j < data->length; j++) {\n        str_i = j * bplist->dict_size;\n        str_j = (j + size) * bplist->dict_size;\n        index1_ptr = (*bnode) + str_i;\n        index2_ptr = (*bnode) + str_j;\n\n        if ((index1_ptr < bplist->data || index1_ptr + bplist->dict_size >= end_data) ||\n            (index2_ptr < bplist->data || index2_ptr + bplist->dict_size >= end_data)) {\n            plist_free(node);\n            return NULL;\n        }\n\n        index1 = UINT_TO_HOST(index1_ptr, bplist->dict_size);\n        index2 = UINT_TO_HOST(index2_ptr, bplist->dict_size);\n\n        if (index1 >= bplist->num_objects) {\n            plist_free(node);\n            return NULL;\n        }\n        if (index2 >= bplist->num_objects) {\n            plist_free(node);\n            return NULL;\n        }\n\n        /* process key node */\n        plist_t key = parse_bin_node_at_index(bplist, index1);\n        if (!key) {\n            plist_free(node);\n            return NULL;\n        }\n\n        if (plist_get_data(key)->type != PLIST_STRING) {\n            fprintf(stderr, \"ERROR: Malformed binary plist dict, invalid node type for key!\\n\");\n            plist_free(node);\n            return NULL;\n        }\n\n        /* enforce key type */\n        plist_get_data(key)->type = PLIST_KEY;\n        if (!plist_get_data(key)->strval) {\n            fprintf(stderr, \"ERROR: Malformed binary plist dict, invalid key node encountered!\\n\");\n            plist_free(key);\n            plist_free(node);\n            return NULL;\n        }\n\n        /* process value node */\n        plist_t val = parse_bin_node_at_index(bplist, index2);\n        if (!val) {\n            plist_free(key);\n            plist_free(node);\n            return NULL;\n        }\n\n        node_attach(node, key);\n        node_attach(node, val);\n    }\n\n    return node;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146039,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "static netdev_tx_t usb_8dev_start_xmit(struct sk_buff *skb,\n\t\t\t\t      struct net_device *netdev)\n{\n\tstruct usb_8dev_priv *priv = netdev_priv(netdev);\n\tstruct net_device_stats *stats = &netdev->stats;\n\tstruct can_frame *cf = (struct can_frame *) skb->data;\n\tstruct usb_8dev_tx_msg *msg;\n\tstruct urb *urb;\n\tstruct usb_8dev_tx_urb_context *context = NULL;\n\tu8 *buf;\n\tint i, err;\n\tsize_t size = sizeof(struct usb_8dev_tx_msg);\n\n\tif (can_dropped_invalid_skb(netdev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\t/* create a URB, and a buffer for it, and copy the data to the URB */\n\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!urb)\n\t\tgoto nomem;\n\n\tbuf = usb_alloc_coherent(priv->udev, size, GFP_ATOMIC,\n\t\t\t\t &urb->transfer_dma);\n\tif (!buf) {\n\t\tnetdev_err(netdev, \"No memory left for USB buffer\\n\");\n\t\tgoto nomembuf;\n\t}\n\n\tmemset(buf, 0, size);\n\n\tmsg = (struct usb_8dev_tx_msg *)buf;\n\tmsg->begin = USB_8DEV_DATA_START;\n\tmsg->flags = 0x00;\n\n\tif (cf->can_id & CAN_RTR_FLAG)\n\t\tmsg->flags |= USB_8DEV_RTR;\n\n\tif (cf->can_id & CAN_EFF_FLAG)\n\t\tmsg->flags |= USB_8DEV_EXTID;\n\n\tmsg->id = cpu_to_be32(cf->can_id & CAN_ERR_MASK);\n\tmsg->dlc = can_get_cc_dlc(cf, priv->can.ctrlmode);\n\tmemcpy(msg->data, cf->data, cf->len);\n\tmsg->end = USB_8DEV_DATA_END;\n\n\tfor (i = 0; i < MAX_TX_URBS; i++) {\n\t\tif (priv->tx_contexts[i].echo_index == MAX_TX_URBS) {\n\t\t\tcontext = &priv->tx_contexts[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* May never happen! When this happens we'd more URBs in flight as\n\t * allowed (MAX_TX_URBS).\n\t */\n\tif (!context)\n\t\tgoto nofreecontext;\n\n\tcontext->priv = priv;\n\tcontext->echo_index = i;\n\n\tusb_fill_bulk_urb(urb, priv->udev,\n\t\t\t  usb_sndbulkpipe(priv->udev, USB_8DEV_ENDP_DATA_TX),\n\t\t\t  buf, size, usb_8dev_write_bulk_callback, context);\n\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\tusb_anchor_urb(urb, &priv->tx_submitted);\n\n\tcan_put_echo_skb(skb, netdev, context->echo_index, 0);\n\n\tatomic_inc(&priv->active_tx_urbs);\n\n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (unlikely(err))\n\t\tgoto failed;\n\telse if (atomic_read(&priv->active_tx_urbs) >= MAX_TX_URBS)\n\t\t/* Slow down tx path */\n\t\tnetif_stop_queue(netdev);\n\n\t/* Release our reference to this URB, the USB core will eventually free\n\t * it entirely.\n\t */\n\tusb_free_urb(urb);\n\n\treturn NETDEV_TX_OK;\n\nnofreecontext:\n\tusb_free_coherent(priv->udev, size, buf, urb->transfer_dma);\n\tusb_free_urb(urb);\n\n\tnetdev_warn(netdev, \"couldn't find free context\");\n\n\treturn NETDEV_TX_BUSY;\n\nfailed:\n\tcan_free_echo_skb(netdev, context->echo_index, NULL);\n\n\tusb_unanchor_urb(urb);\n\tusb_free_coherent(priv->udev, size, buf, urb->transfer_dma);\n\n\tatomic_dec(&priv->active_tx_urbs);\n\n\tif (err == -ENODEV)\n\t\tnetif_device_detach(netdev);\n\telse\n\t\tnetdev_warn(netdev, \"failed tx_urb %d\\n\", err);\n\nnomembuf:\n\tusb_free_urb(urb);\n\nnomem:\n\tdev_kfree_skb(skb);\n\tstats->tx_dropped++;\n\n\treturn NETDEV_TX_OK;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146086,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "static netdev_tx_t usb_8dev_start_xmit(struct sk_buff *skb,\n\t\t\t\t      struct net_device *netdev)\n{\n\tstruct usb_8dev_priv *priv = netdev_priv(netdev);\n\tstruct net_device_stats *stats = &netdev->stats;\n\tstruct can_frame *cf = (struct can_frame *) skb->data;\n\tstruct usb_8dev_tx_msg *msg;\n\tstruct urb *urb;\n\tstruct usb_8dev_tx_urb_context *context = NULL;\n\tu8 *buf;\n\tint i, err;\n\tsize_t size = sizeof(struct usb_8dev_tx_msg);\n\n\tif (can_dropped_invalid_skb(netdev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\t/* create a URB, and a buffer for it, and copy the data to the URB */\n\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!urb)\n\t\tgoto nomem;\n\n\tbuf = usb_alloc_coherent(priv->udev, size, GFP_ATOMIC,\n\t\t\t\t &urb->transfer_dma);\n\tif (!buf) {\n\t\tnetdev_err(netdev, \"No memory left for USB buffer\\n\");\n\t\tgoto nomembuf;\n\t}\n\n\tmemset(buf, 0, size);\n\n\tmsg = (struct usb_8dev_tx_msg *)buf;\n\tmsg->begin = USB_8DEV_DATA_START;\n\tmsg->flags = 0x00;\n\n\tif (cf->can_id & CAN_RTR_FLAG)\n\t\tmsg->flags |= USB_8DEV_RTR;\n\n\tif (cf->can_id & CAN_EFF_FLAG)\n\t\tmsg->flags |= USB_8DEV_EXTID;\n\n\tmsg->id = cpu_to_be32(cf->can_id & CAN_ERR_MASK);\n\tmsg->dlc = can_get_cc_dlc(cf, priv->can.ctrlmode);\n\tmemcpy(msg->data, cf->data, cf->len);\n\tmsg->end = USB_8DEV_DATA_END;\n\n\tfor (i = 0; i < MAX_TX_URBS; i++) {\n\t\tif (priv->tx_contexts[i].echo_index == MAX_TX_URBS) {\n\t\t\tcontext = &priv->tx_contexts[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* May never happen! When this happens we'd more URBs in flight as\n\t * allowed (MAX_TX_URBS).\n\t */\n\tif (!context)\n\t\tgoto nofreecontext;\n\n\tcontext->priv = priv;\n\tcontext->echo_index = i;\n\n\tusb_fill_bulk_urb(urb, priv->udev,\n\t\t\t  usb_sndbulkpipe(priv->udev, USB_8DEV_ENDP_DATA_TX),\n\t\t\t  buf, size, usb_8dev_write_bulk_callback, context);\n\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\tusb_anchor_urb(urb, &priv->tx_submitted);\n\n\tcan_put_echo_skb(skb, netdev, context->echo_index, 0);\n\n\tatomic_inc(&priv->active_tx_urbs);\n\n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (unlikely(err)) {\n\t\tcan_free_echo_skb(netdev, context->echo_index, NULL);\n\n\t\tusb_unanchor_urb(urb);\n\t\tusb_free_coherent(priv->udev, size, buf, urb->transfer_dma);\n\n\t\tatomic_dec(&priv->active_tx_urbs);\n\n\t\tif (err == -ENODEV)\n\t\t\tnetif_device_detach(netdev);\n\t\telse\n\t\t\tnetdev_warn(netdev, \"failed tx_urb %d\\n\", err);\n\t\tstats->tx_dropped++;\n\t} else if (atomic_read(&priv->active_tx_urbs) >= MAX_TX_URBS)\n\t\t/* Slow down tx path */\n\t\tnetif_stop_queue(netdev);\n\n\t/* Release our reference to this URB, the USB core will eventually free\n\t * it entirely.\n\t */\n\tusb_free_urb(urb);\n\n\treturn NETDEV_TX_OK;\n\nnofreecontext:\n\tusb_free_coherent(priv->udev, size, buf, urb->transfer_dma);\n\tusb_free_urb(urb);\n\n\tnetdev_warn(netdev, \"couldn't find free context\");\n\n\treturn NETDEV_TX_BUSY;\n\nnomembuf:\n\tusb_free_urb(urb);\n\nnomem:\n\tdev_kfree_skb(skb);\n\tstats->tx_dropped++;\n\n\treturn NETDEV_TX_OK;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146087,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "struct sock *tcp_create_openreq_child(const struct sock *sk,\n\t\t\t\t      struct request_sock *req,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct sock *newsk = inet_csk_clone_lock(sk, req, GFP_ATOMIC);\n\n\tif (newsk) {\n\t\tconst struct inet_request_sock *ireq = inet_rsk(req);\n\t\tstruct tcp_request_sock *treq = tcp_rsk(req);\n\t\tstruct inet_connection_sock *newicsk = inet_csk(newsk);\n\t\tstruct tcp_sock *newtp = tcp_sk(newsk);\n\n\t\t/* Now setup tcp_sock */\n\t\tnewtp->pred_flags = 0;\n\n\t\tnewtp->rcv_wup = newtp->copied_seq =\n\t\tnewtp->rcv_nxt = treq->rcv_isn + 1;\n\t\tnewtp->segs_in = 1;\n\n\t\tnewtp->snd_sml = newtp->snd_una =\n\t\tnewtp->snd_nxt = newtp->snd_up = treq->snt_isn + 1;\n\n\t\ttcp_prequeue_init(newtp);\n\t\tINIT_LIST_HEAD(&newtp->tsq_node);\n\n\t\ttcp_init_wl(newtp, treq->rcv_isn);\n\n\t\tnewtp->srtt_us = 0;\n\t\tnewtp->mdev_us = jiffies_to_usecs(TCP_TIMEOUT_INIT);\n\t\tminmax_reset(&newtp->rtt_min, tcp_time_stamp, ~0U);\n\t\tnewicsk->icsk_rto = TCP_TIMEOUT_INIT;\n\t\tnewicsk->icsk_ack.lrcvtime = tcp_time_stamp;\n\n\t\tnewtp->packets_out = 0;\n\t\tnewtp->retrans_out = 0;\n\t\tnewtp->sacked_out = 0;\n\t\tnewtp->fackets_out = 0;\n\t\tnewtp->snd_ssthresh = TCP_INFINITE_SSTHRESH;\n\t\tnewtp->tlp_high_seq = 0;\n\t\tnewtp->lsndtime = treq->snt_synack.stamp_jiffies;\n\t\tnewsk->sk_txhash = treq->txhash;\n\t\tnewtp->last_oow_ack_time = 0;\n\t\tnewtp->total_retrans = req->num_retrans;\n\n\t\t/* So many TCP implementations out there (incorrectly) count the\n\t\t * initial SYN frame in their delayed-ACK and congestion control\n\t\t * algorithms that we must have the following bandaid to talk\n\t\t * efficiently to them.  -DaveM\n\t\t */\n\t\tnewtp->snd_cwnd = TCP_INIT_CWND;\n\t\tnewtp->snd_cwnd_cnt = 0;\n\n\t\t/* There's a bubble in the pipe until at least the first ACK. */\n\t\tnewtp->app_limited = ~0U;\n\n\t\ttcp_init_xmit_timers(newsk);\n\t\tnewtp->write_seq = newtp->pushed_seq = treq->snt_isn + 1;\n\n\t\tnewtp->rx_opt.saw_tstamp = 0;\n\n\t\tnewtp->rx_opt.dsack = 0;\n\t\tnewtp->rx_opt.num_sacks = 0;\n\n\t\tnewtp->urg_data = 0;\n\n\t\tif (sock_flag(newsk, SOCK_KEEPOPEN))\n\t\t\tinet_csk_reset_keepalive_timer(newsk,\n\t\t\t\t\t\t       keepalive_time_when(newtp));\n\n\t\tnewtp->rx_opt.tstamp_ok = ireq->tstamp_ok;\n\t\tif ((newtp->rx_opt.sack_ok = ireq->sack_ok) != 0) {\n\t\t\tif (sysctl_tcp_fack)\n\t\t\t\ttcp_enable_fack(newtp);\n\t\t}\n\t\tnewtp->window_clamp = req->rsk_window_clamp;\n\t\tnewtp->rcv_ssthresh = req->rsk_rcv_wnd;\n\t\tnewtp->rcv_wnd = req->rsk_rcv_wnd;\n\t\tnewtp->rx_opt.wscale_ok = ireq->wscale_ok;\n\t\tif (newtp->rx_opt.wscale_ok) {\n\t\t\tnewtp->rx_opt.snd_wscale = ireq->snd_wscale;\n\t\t\tnewtp->rx_opt.rcv_wscale = ireq->rcv_wscale;\n\t\t} else {\n\t\t\tnewtp->rx_opt.snd_wscale = newtp->rx_opt.rcv_wscale = 0;\n\t\t\tnewtp->window_clamp = min(newtp->window_clamp, 65535U);\n\t\t}\n\t\tnewtp->snd_wnd = (ntohs(tcp_hdr(skb)->window) <<\n\t\t\t\t  newtp->rx_opt.snd_wscale);\n\t\tnewtp->max_window = newtp->snd_wnd;\n\n\t\tif (newtp->rx_opt.tstamp_ok) {\n\t\t\tnewtp->rx_opt.ts_recent = req->ts_recent;\n\t\t\tnewtp->rx_opt.ts_recent_stamp = get_seconds();\n\t\t\tnewtp->tcp_header_len = sizeof(struct tcphdr) + TCPOLEN_TSTAMP_ALIGNED;\n\t\t} else {\n\t\t\tnewtp->rx_opt.ts_recent_stamp = 0;\n\t\t\tnewtp->tcp_header_len = sizeof(struct tcphdr);\n\t\t}\n\t\tnewtp->tsoffset = treq->ts_off;\n#ifdef CONFIG_TCP_MD5SIG\n\t\tnewtp->md5sig_info = NULL;\t/*XXX*/\n\t\tif (newtp->af_specific->md5_lookup(sk, newsk))\n\t\t\tnewtp->tcp_header_len += TCPOLEN_MD5SIG_ALIGNED;\n#endif\n\t\tif (skb->len >= TCP_MSS_DEFAULT + newtp->tcp_header_len)\n\t\t\tnewicsk->icsk_ack.last_seg_size = skb->len - newtp->tcp_header_len;\n\t\tnewtp->rx_opt.mss_clamp = req->mss;\n\t\ttcp_ecn_openreq_child(newtp, req);\n\t\tnewtp->fastopen_rsk = NULL;\n\t\tnewtp->syn_data_acked = 0;\n\t\tnewtp->rack.mstamp.v64 = 0;\n\t\tnewtp->rack.advanced = 0;\n\n\t\t__TCP_INC_STATS(sock_net(sk), TCP_MIB_PASSIVEOPENS);\n\t}\n\treturn newsk;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146226,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "struct sock *tcp_create_openreq_child(const struct sock *sk,\n\t\t\t\t      struct request_sock *req,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct sock *newsk = inet_csk_clone_lock(sk, req, GFP_ATOMIC);\n\n\tif (newsk) {\n\t\tconst struct inet_request_sock *ireq = inet_rsk(req);\n\t\tstruct tcp_request_sock *treq = tcp_rsk(req);\n\t\tstruct inet_connection_sock *newicsk = inet_csk(newsk);\n\t\tstruct tcp_sock *newtp = tcp_sk(newsk);\n\n\t\t/* Now setup tcp_sock */\n\t\tnewtp->pred_flags = 0;\n\n\t\tnewtp->rcv_wup = newtp->copied_seq =\n\t\tnewtp->rcv_nxt = treq->rcv_isn + 1;\n\t\tnewtp->segs_in = 1;\n\n\t\tnewtp->snd_sml = newtp->snd_una =\n\t\tnewtp->snd_nxt = newtp->snd_up = treq->snt_isn + 1;\n\n\t\ttcp_prequeue_init(newtp);\n\t\tINIT_LIST_HEAD(&newtp->tsq_node);\n\n\t\ttcp_init_wl(newtp, treq->rcv_isn);\n\n\t\tnewtp->srtt_us = 0;\n\t\tnewtp->mdev_us = jiffies_to_usecs(TCP_TIMEOUT_INIT);\n\t\tminmax_reset(&newtp->rtt_min, tcp_time_stamp, ~0U);\n\t\tnewicsk->icsk_rto = TCP_TIMEOUT_INIT;\n\t\tnewicsk->icsk_ack.lrcvtime = tcp_time_stamp;\n\n\t\tnewtp->packets_out = 0;\n\t\tnewtp->retrans_out = 0;\n\t\tnewtp->sacked_out = 0;\n\t\tnewtp->fackets_out = 0;\n\t\tnewtp->snd_ssthresh = TCP_INFINITE_SSTHRESH;\n\t\tnewtp->tlp_high_seq = 0;\n\t\tnewtp->lsndtime = treq->snt_synack.stamp_jiffies;\n\t\tnewsk->sk_txhash = treq->txhash;\n\t\tnewtp->last_oow_ack_time = 0;\n\t\tnewtp->total_retrans = req->num_retrans;\n\n\t\t/* So many TCP implementations out there (incorrectly) count the\n\t\t * initial SYN frame in their delayed-ACK and congestion control\n\t\t * algorithms that we must have the following bandaid to talk\n\t\t * efficiently to them.  -DaveM\n\t\t */\n\t\tnewtp->snd_cwnd = TCP_INIT_CWND;\n\t\tnewtp->snd_cwnd_cnt = 0;\n\n\t\t/* There's a bubble in the pipe until at least the first ACK. */\n\t\tnewtp->app_limited = ~0U;\n\n\t\ttcp_init_xmit_timers(newsk);\n\t\tnewtp->write_seq = newtp->pushed_seq = treq->snt_isn + 1;\n\n\t\tnewtp->rx_opt.saw_tstamp = 0;\n\n\t\tnewtp->rx_opt.dsack = 0;\n\t\tnewtp->rx_opt.num_sacks = 0;\n\n\t\tnewtp->urg_data = 0;\n\n\t\tif (sock_flag(newsk, SOCK_KEEPOPEN))\n\t\t\tinet_csk_reset_keepalive_timer(newsk,\n\t\t\t\t\t\t       keepalive_time_when(newtp));\n\n\t\tnewtp->rx_opt.tstamp_ok = ireq->tstamp_ok;\n\t\tif ((newtp->rx_opt.sack_ok = ireq->sack_ok) != 0) {\n\t\t\tif (sysctl_tcp_fack)\n\t\t\t\ttcp_enable_fack(newtp);\n\t\t}\n\t\tnewtp->window_clamp = req->rsk_window_clamp;\n\t\tnewtp->rcv_ssthresh = req->rsk_rcv_wnd;\n\t\tnewtp->rcv_wnd = req->rsk_rcv_wnd;\n\t\tnewtp->rx_opt.wscale_ok = ireq->wscale_ok;\n\t\tif (newtp->rx_opt.wscale_ok) {\n\t\t\tnewtp->rx_opt.snd_wscale = ireq->snd_wscale;\n\t\t\tnewtp->rx_opt.rcv_wscale = ireq->rcv_wscale;\n\t\t} else {\n\t\t\tnewtp->rx_opt.snd_wscale = newtp->rx_opt.rcv_wscale = 0;\n\t\t\tnewtp->window_clamp = min(newtp->window_clamp, 65535U);\n\t\t}\n\t\tnewtp->snd_wnd = (ntohs(tcp_hdr(skb)->window) <<\n\t\t\t\t  newtp->rx_opt.snd_wscale);\n\t\tnewtp->max_window = newtp->snd_wnd;\n\n\t\tif (newtp->rx_opt.tstamp_ok) {\n\t\t\tnewtp->rx_opt.ts_recent = req->ts_recent;\n\t\t\tnewtp->rx_opt.ts_recent_stamp = get_seconds();\n\t\t\tnewtp->tcp_header_len = sizeof(struct tcphdr) + TCPOLEN_TSTAMP_ALIGNED;\n\t\t} else {\n\t\t\tnewtp->rx_opt.ts_recent_stamp = 0;\n\t\t\tnewtp->tcp_header_len = sizeof(struct tcphdr);\n\t\t}\n\t\tnewtp->tsoffset = treq->ts_off;\n#ifdef CONFIG_TCP_MD5SIG\n\t\tnewtp->md5sig_info = NULL;\t/*XXX*/\n\t\tif (newtp->af_specific->md5_lookup(sk, newsk))\n\t\t\tnewtp->tcp_header_len += TCPOLEN_MD5SIG_ALIGNED;\n#endif\n\t\tif (skb->len >= TCP_MSS_DEFAULT + newtp->tcp_header_len)\n\t\t\tnewicsk->icsk_ack.last_seg_size = skb->len - newtp->tcp_header_len;\n\t\tnewtp->rx_opt.mss_clamp = req->mss;\n\t\ttcp_ecn_openreq_child(newtp, req);\n\t\tnewtp->fastopen_req = NULL;\n\t\tnewtp->fastopen_rsk = NULL;\n\t\tnewtp->syn_data_acked = 0;\n\t\tnewtp->rack.mstamp.v64 = 0;\n\t\tnewtp->rack.advanced = 0;\n\n\t\t__TCP_INC_STATS(sock_net(sk), TCP_MIB_PASSIVEOPENS);\n\t}\n\treturn newsk;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146227,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "static ssize_t driver_override_show(struct device *_dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct amba_device *dev = to_amba_device(_dev);\n\n\treturn sprintf(buf, \"%s\\n\", dev->driver_override);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146350,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "static ssize_t driver_override_show(struct device *_dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct amba_device *dev = to_amba_device(_dev);\n\tssize_t len;\n\n\tdevice_lock(_dev);\n\tlen = sprintf(buf, \"%s\\n\", dev->driver_override);\n\tdevice_unlock(_dev);\n\treturn len;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146351,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "int PackLinuxElf64::canUnpack()\n{\n    if (super::canUnpack()) {\n        return true;\n    }\n    if (Elf64_Ehdr::ET_DYN==get_te16(&ehdri.e_type)) {\n        PackLinuxElf64help1(fi);\n        Elf64_Phdr const *phdr = phdri, *last_LOAD = nullptr;\n        for (unsigned j = 0; j < e_phnum; ++phdr, ++j)\n            if (Elf64_Phdr::PT_LOAD==get_te32(&phdr->p_type)) {\n                last_LOAD = phdr;\n            }\n        if (!last_LOAD)\n            return false;\n        off_t offset = get_te64(&last_LOAD->p_offset);\n        unsigned filesz = get_te64(&last_LOAD->p_filesz);\n        fi->seek(filesz+offset, SEEK_SET);\n        MemBuffer buf(32 + sizeof(overlay_offset));\n        fi->readx(buf, buf.getSize());\n        return PackUnix::find_overlay_offset(buf);\n    }\n    return false;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146394,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "int PackLinuxElf64::canUnpack()\n{\n    if (checkEhdr(&ehdri)) {\n        return false;\n    }\n    if (Elf64_Ehdr::ET_DYN==get_te16(&ehdri.e_type)) {\n        PackLinuxElf64help1(fi);\n        Elf64_Phdr const *phdr = phdri, *last_LOAD = nullptr;\n        for (unsigned j = 0; j < e_phnum; ++phdr, ++j)\n            if (Elf64_Phdr::PT_LOAD==get_te32(&phdr->p_type)) {\n                last_LOAD = phdr;\n            }\n        if (!last_LOAD)\n            return false;\n        off_t offset = get_te64(&last_LOAD->p_offset);\n        unsigned filesz = get_te64(&last_LOAD->p_filesz);\n        fi->seek(filesz+offset, SEEK_SET);\n        MemBuffer buf(32 + sizeof(overlay_offset));\n        fi->readx(buf, buf.getSize());\n        unsigned x = PackUnix::find_overlay_offset(buf);\n        if (x) {\n            return x;\n        }\n    }\n    if (super::canUnpack()) {\n        return true;\n    }\n    return false;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146395,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "int PackLinuxElf32::canUnpack()\n{\n    if (super::canUnpack()) {\n        return true;\n    }\n    if (Elf32_Ehdr::ET_DYN==get_te16(&ehdri.e_type)) {\n        PackLinuxElf32help1(fi);\n    }\n    return false;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146396,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "int PackLinuxElf32::canUnpack()\n{\n    if (checkEhdr(&ehdri)) {\n        return false;\n    }\n    // FIXME: ET_DYN same as 64-bit canUnpack ??\n    if (Elf32_Ehdr::ET_DYN==get_te16(&ehdri.e_type)) {\n        PackLinuxElf32help1(fi);\n    }\n    if (super::canUnpack()) {\n        return true;\n    }\n    return false;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146397,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "int gnutls_x509_ext_import_proxy(const gnutls_datum_t * ext, int *pathlen,\n\t\t\t      char **policyLanguage, char **policy,\n\t\t\t      size_t * sizeof_policy)\n{\n\tASN1_TYPE c2 = ASN1_TYPE_EMPTY;\n\tint result;\n\tgnutls_datum_t value = { NULL, 0 };\n\n\tif ((result = asn1_create_element\n\t     (_gnutls_get_pkix(), \"PKIX1.ProxyCertInfo\",\n\t      &c2)) != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\treturn _gnutls_asn2err(result);\n\t}\n\n\tresult = _asn1_strict_der_decode(&c2, ext->data, ext->size, NULL);\n\tif (result != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\tresult = _gnutls_asn2err(result);\n\t\tgoto cleanup;\n\t}\n\n\tif (pathlen) {\n\t\tresult = _gnutls_x509_read_uint(c2, \"pCPathLenConstraint\",\n\t\t\t\t\t\t(unsigned int *)\n\t\t\t\t\t\tpathlen);\n\t\tif (result == GNUTLS_E_ASN1_ELEMENT_NOT_FOUND)\n\t\t\t*pathlen = -1;\n\t\telse if (result != GNUTLS_E_SUCCESS) {\n\t\t\tgnutls_assert();\n\t\t\tresult = _gnutls_asn2err(result);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tresult = _gnutls_x509_read_value(c2, \"proxyPolicy.policyLanguage\",\n\t\t\t\t\t &value);\n\tif (result < 0) {\n\t\tgnutls_assert();\n\t\tgoto cleanup;\n\t}\n\n\tif (policyLanguage) {\n\t\t*policyLanguage = (char *)value.data;\n\t} else {\n\t\tgnutls_free(value.data);\n\t\tvalue.data = NULL;\n\t}\n\n\tresult = _gnutls_x509_read_value(c2, \"proxyPolicy.policy\", &value);\n\tif (result == GNUTLS_E_ASN1_ELEMENT_NOT_FOUND) {\n\t\tif (policy)\n\t\t\t*policy = NULL;\n\t\tif (sizeof_policy)\n\t\t\t*sizeof_policy = 0;\n\t} else if (result < 0) {\n\t\tgnutls_assert();\n\t\tgoto cleanup;\n\t} else {\n\t\tif (policy) {\n\t\t\t*policy = (char *)value.data;\n\t\t\tvalue.data = NULL;\n\t\t}\n\t\tif (sizeof_policy)\n\t\t\t*sizeof_policy = value.size;\n\t}\n\n\tresult = 0;\n cleanup:\n\tgnutls_free(value.data);\n\tasn1_delete_structure(&c2);\n\n\treturn result;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146636,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "int gnutls_x509_ext_import_proxy(const gnutls_datum_t * ext, int *pathlen,\n\t\t\t      char **policyLanguage, char **policy,\n\t\t\t      size_t * sizeof_policy)\n{\n\tASN1_TYPE c2 = ASN1_TYPE_EMPTY;\n\tint result;\n\tgnutls_datum_t value1 = { NULL, 0 };\n\tgnutls_datum_t value2 = { NULL, 0 };\n\n\tif ((result = asn1_create_element\n\t     (_gnutls_get_pkix(), \"PKIX1.ProxyCertInfo\",\n\t      &c2)) != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\treturn _gnutls_asn2err(result);\n\t}\n\n\tresult = _asn1_strict_der_decode(&c2, ext->data, ext->size, NULL);\n\tif (result != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\tresult = _gnutls_asn2err(result);\n\t\tgoto cleanup;\n\t}\n\n\tif (pathlen) {\n\t\tresult = _gnutls_x509_read_uint(c2, \"pCPathLenConstraint\",\n\t\t\t\t\t\t(unsigned int *)\n\t\t\t\t\t\tpathlen);\n\t\tif (result == GNUTLS_E_ASN1_ELEMENT_NOT_FOUND)\n\t\t\t*pathlen = -1;\n\t\telse if (result != GNUTLS_E_SUCCESS) {\n\t\t\tgnutls_assert();\n\t\t\tresult = _gnutls_asn2err(result);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tresult = _gnutls_x509_read_value(c2, \"proxyPolicy.policyLanguage\",\n\t\t\t\t\t &value1);\n\tif (result < 0) {\n\t\tgnutls_assert();\n\t\tgoto cleanup;\n\t}\n\n\tif (policyLanguage) {\n\t\t*policyLanguage = (char *)value1.data;\n\t\tvalue1.data = NULL;\n\t}\n\n\tresult = _gnutls_x509_read_value(c2, \"proxyPolicy.policy\", &value2);\n\tif (result == GNUTLS_E_ASN1_ELEMENT_NOT_FOUND) {\n\t\tif (policy)\n\t\t\t*policy = NULL;\n\t\tif (sizeof_policy)\n\t\t\t*sizeof_policy = 0;\n\t} else if (result < 0) {\n\t\tgnutls_assert();\n\t\tgoto cleanup;\n\t} else {\n\t\tif (policy) {\n\t\t\t*policy = (char *)value2.data;\n\t\t\tvalue2.data = NULL;\n\t\t}\n\t\tif (sizeof_policy)\n\t\t\t*sizeof_policy = value2.size;\n\t}\n\n\tresult = 0;\n cleanup:\n\tgnutls_free(value1.data);\n\tgnutls_free(value2.data);\n\tasn1_delete_structure(&c2);\n\n\treturn result;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146637,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "BGD_DECLARE(void *) gdImageBmpPtr(gdImagePtr im, int *size, int compression)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) return NULL;\n\tgdImageBmpCtx(im, out, compression);\n\trv = gdDPExtractData(out, size);\n\tout->gd_free(out);\n\treturn rv;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146876,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "BGD_DECLARE(void *) gdImageBmpPtr(gdImagePtr im, int *size, int compression)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) return NULL;\n\tif (!_gdImageBmpCtx(im, out, compression))\n\t\trv = gdDPExtractData(out, size);\n\telse\n\t\trv = NULL;\n\tout->gd_free(out);\n\treturn rv;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146877,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "BGD_DECLARE(void *) gdImagePngPtr (gdImagePtr im, int *size)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx (2048, NULL);\n\tif (out == NULL) return NULL;\n\tgdImagePngCtxEx (im, out, -1);\n\trv = gdDPExtractData (out, size);\n\tout->gd_free (out);\n\treturn rv;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146918,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "BGD_DECLARE(void *) gdImagePngPtr (gdImagePtr im, int *size)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx (2048, NULL);\n\tif (out == NULL) return NULL;\n\tif (!_gdImagePngCtxEx (im, out, -1)) {\n\t\trv = gdDPExtractData (out, size);\n\t} else {\n\t\trv = NULL;\n\t}\n\tout->gd_free (out);\n\treturn rv;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146919,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "void WavOutFile::write(const float *buffer, int numElems)\r\n{\r\n    int numBytes;\r\n    int bytesPerSample;\r\n\r\n    if (numElems == 0) return;\r\n\r\n    bytesPerSample = header.format.bits_per_sample / 8;\r\n    numBytes = numElems * bytesPerSample;\r\n    int confBufBytes = (numBytes + 3) & -4; // round up to nearest multiple of four to avoid overflow with 24bit-value assignment\r\n    void *temp = getConvBuffer(confBufBytes);\r\n\r\n    switch (bytesPerSample)\r\n    {\r\n        case 1:\r\n        {\r\n            unsigned char *temp2 = (unsigned char *)temp;\r\n            for (int i = 0; i < numElems; i ++)\r\n            {\r\n                temp2[i] = (unsigned char)saturate(buffer[i] * 128.0f + 128.0f, 0.0f, 255.0f);\r\n            }\r\n            break;\r\n        }\r\n\r\n        case 2:\r\n        {\r\n            short *temp2 = (short *)temp;\r\n            for (int i = 0; i < numElems; i ++)\r\n            {\r\n                short value = (short)saturate(buffer[i] * 32768.0f, -32768.0f, 32767.0f);\r\n                temp2[i] = _swap16(value);\r\n            }\r\n            break;\r\n        }\r\n\r\n        case 3:\r\n        {\r\n            char *temp2 = (char *)temp;\r\n            for (int i = 0; i < numElems; i ++)\r\n            {\r\n                int value = saturate(buffer[i] * 8388608.0f, -8388608.0f, 8388607.0f);\r\n                *((int*)temp2) = _swap32(value);\r\n                temp2 += 3;\r\n            }\r\n            break;\r\n        }\r\n\r\n        case 4:\r\n        {\r\n            int *temp2 = (int *)temp;\r\n            for (int i = 0; i < numElems; i ++)\r\n            {\r\n                int value = saturate(buffer[i] * 2147483648.0f, -2147483648.0f, 2147483647.0f);\r\n                temp2[i] = _swap32(value);\r\n            }\r\n            break;\r\n        }\r\n\r\n        default:\r\n            assert(false);\r\n    }\r\n\r\n    int res = (int)fwrite(temp, 1, numBytes, fptr);\r\n\r\n    if (res != numBytes) \r\n    {\r\n        ST_THROW_RT_ERROR(\"Error while writing to a wav file.\");\r\n    }\r\n    bytesWritten += numBytes;\r\n}\r",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146982,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "void WavOutFile::write(const float *buffer, int numElems)\r\n{\r\n    int numBytes;\r\n    int bytesPerSample;\r\n\r\n    if (numElems == 0) return;\r\n\r\n    bytesPerSample = header.format.bits_per_sample / 8;\r\n    numBytes = numElems * bytesPerSample;\r\n    void *temp = getConvBuffer(numBytes + 7);   // round bit up to avoid buffer overrun with 24bit-value assignment\r\n\r\n    switch (bytesPerSample)\r\n    {\r\n        case 1:\r\n        {\r\n            unsigned char *temp2 = (unsigned char *)temp;\r\n            for (int i = 0; i < numElems; i ++)\r\n            {\r\n                temp2[i] = (unsigned char)saturate(buffer[i] * 128.0f + 128.0f, 0.0f, 255.0f);\r\n            }\r\n            break;\r\n        }\r\n\r\n        case 2:\r\n        {\r\n            short *temp2 = (short *)temp;\r\n            for (int i = 0; i < numElems; i ++)\r\n            {\r\n                short value = (short)saturate(buffer[i] * 32768.0f, -32768.0f, 32767.0f);\r\n                temp2[i] = _swap16(value);\r\n            }\r\n            break;\r\n        }\r\n\r\n        case 3:\r\n        {\r\n            char *temp2 = (char *)temp;\r\n            for (int i = 0; i < numElems; i ++)\r\n            {\r\n                int value = saturate(buffer[i] * 8388608.0f, -8388608.0f, 8388607.0f);\r\n                *((int*)temp2) = _swap32(value);\r\n                temp2 += 3;\r\n            }\r\n            break;\r\n        }\r\n\r\n        case 4:\r\n        {\r\n            int *temp2 = (int *)temp;\r\n            for (int i = 0; i < numElems; i ++)\r\n            {\r\n                int value = saturate(buffer[i] * 2147483648.0f, -2147483648.0f, 2147483647.0f);\r\n                temp2[i] = _swap32(value);\r\n            }\r\n            break;\r\n        }\r\n\r\n        default:\r\n            assert(false);\r\n    }\r\n\r\n    int res = (int)fwrite(temp, 1, numBytes, fptr);\r\n\r\n    if (res != numBytes) \r\n    {\r\n        ST_THROW_RT_ERROR(\"Error while writing to a wav file.\");\r\n    }\r\n    bytesWritten += numBytes;\r\n}\r",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 146983,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "static int probe_rio(struct usb_interface *intf,\n\t\t     const struct usb_device_id *id)\n{\n\tstruct usb_device *dev = interface_to_usbdev(intf);\n\tstruct rio_usb_data *rio = &rio_instance;\n\tint retval;\n\n\tdev_info(&intf->dev, \"USB Rio found at address %d\\n\", dev->devnum);\n\n\tretval = usb_register_dev(intf, &usb_rio_class);\n\tif (retval) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"Not able to get a minor for this device.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\trio->rio_dev = dev;\n\n\tif (!(rio->obuf = kmalloc(OBUF_SIZE, GFP_KERNEL))) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"probe_rio: Not enough memory for the output buffer\\n\");\n\t\tusb_deregister_dev(intf, &usb_rio_class);\n\t\treturn -ENOMEM;\n\t}\n\tdev_dbg(&intf->dev, \"obuf address:%p\\n\", rio->obuf);\n\n\tif (!(rio->ibuf = kmalloc(IBUF_SIZE, GFP_KERNEL))) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"probe_rio: Not enough memory for the input buffer\\n\");\n\t\tusb_deregister_dev(intf, &usb_rio_class);\n\t\tkfree(rio->obuf);\n\t\treturn -ENOMEM;\n\t}\n\tdev_dbg(&intf->dev, \"ibuf address:%p\\n\", rio->ibuf);\n\n\tmutex_init(&(rio->lock));\n\n\tusb_set_intfdata (intf, rio);\n\trio->present = 1;\n\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147358,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "static int probe_rio(struct usb_interface *intf,\n\t\t     const struct usb_device_id *id)\n{\n\tstruct usb_device *dev = interface_to_usbdev(intf);\n\tstruct rio_usb_data *rio = &rio_instance;\n\tint retval = 0;\n\n\tmutex_lock(&rio500_mutex);\n\tif (rio->present) {\n\t\tdev_info(&intf->dev, \"Second USB Rio at address %d refused\\n\", dev->devnum);\n\t\tretval = -EBUSY;\n\t\tgoto bail_out;\n\t} else {\n\t\tdev_info(&intf->dev, \"USB Rio found at address %d\\n\", dev->devnum);\n\t}\n\n\tretval = usb_register_dev(intf, &usb_rio_class);\n\tif (retval) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"Not able to get a minor for this device.\\n\");\n\t\tretval = -ENOMEM;\n\t\tgoto bail_out;\n\t}\n\n\trio->rio_dev = dev;\n\n\tif (!(rio->obuf = kmalloc(OBUF_SIZE, GFP_KERNEL))) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"probe_rio: Not enough memory for the output buffer\\n\");\n\t\tusb_deregister_dev(intf, &usb_rio_class);\n\t\tretval = -ENOMEM;\n\t\tgoto bail_out;\n\t}\n\tdev_dbg(&intf->dev, \"obuf address:%p\\n\", rio->obuf);\n\n\tif (!(rio->ibuf = kmalloc(IBUF_SIZE, GFP_KERNEL))) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"probe_rio: Not enough memory for the input buffer\\n\");\n\t\tusb_deregister_dev(intf, &usb_rio_class);\n\t\tkfree(rio->obuf);\n\t\tretval = -ENOMEM;\n\t\tgoto bail_out;\n\t}\n\tdev_dbg(&intf->dev, \"ibuf address:%p\\n\", rio->ibuf);\n\n\tmutex_init(&(rio->lock));\n\n\tusb_set_intfdata (intf, rio);\n\trio->present = 1;\nbail_out:\n\tmutex_unlock(&rio500_mutex);\n\n\treturn retval;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147359,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "static netdev_tx_t ems_usb_start_xmit(struct sk_buff *skb, struct net_device *netdev)\n{\n\tstruct ems_usb *dev = netdev_priv(netdev);\n\tstruct ems_tx_urb_context *context = NULL;\n\tstruct net_device_stats *stats = &netdev->stats;\n\tstruct can_frame *cf = (struct can_frame *)skb->data;\n\tstruct ems_cpc_msg *msg;\n\tstruct urb *urb;\n\tu8 *buf;\n\tint i, err;\n\tsize_t size = CPC_HEADER_SIZE + CPC_MSG_HEADER_LEN\n\t\t\t+ sizeof(struct cpc_can_msg);\n\n\tif (can_dropped_invalid_skb(netdev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\t/* create a URB, and a buffer for it, and copy the data to the URB */\n\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!urb)\n\t\tgoto nomem;\n\n\tbuf = usb_alloc_coherent(dev->udev, size, GFP_ATOMIC, &urb->transfer_dma);\n\tif (!buf) {\n\t\tnetdev_err(netdev, \"No memory left for USB buffer\\n\");\n\t\tusb_free_urb(urb);\n\t\tgoto nomem;\n\t}\n\n\tmsg = (struct ems_cpc_msg *)&buf[CPC_HEADER_SIZE];\n\n\tmsg->msg.can_msg.id = cpu_to_le32(cf->can_id & CAN_ERR_MASK);\n\tmsg->msg.can_msg.length = cf->len;\n\n\tif (cf->can_id & CAN_RTR_FLAG) {\n\t\tmsg->type = cf->can_id & CAN_EFF_FLAG ?\n\t\t\tCPC_CMD_TYPE_EXT_RTR_FRAME : CPC_CMD_TYPE_RTR_FRAME;\n\n\t\tmsg->length = CPC_CAN_MSG_MIN_SIZE;\n\t} else {\n\t\tmsg->type = cf->can_id & CAN_EFF_FLAG ?\n\t\t\tCPC_CMD_TYPE_EXT_CAN_FRAME : CPC_CMD_TYPE_CAN_FRAME;\n\n\t\tfor (i = 0; i < cf->len; i++)\n\t\t\tmsg->msg.can_msg.msg[i] = cf->data[i];\n\n\t\tmsg->length = CPC_CAN_MSG_MIN_SIZE + cf->len;\n\t}\n\n\tfor (i = 0; i < MAX_TX_URBS; i++) {\n\t\tif (dev->tx_contexts[i].echo_index == MAX_TX_URBS) {\n\t\t\tcontext = &dev->tx_contexts[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * May never happen! When this happens we'd more URBs in flight as\n\t * allowed (MAX_TX_URBS).\n\t */\n\tif (!context) {\n\t\tusb_free_coherent(dev->udev, size, buf, urb->transfer_dma);\n\t\tusb_free_urb(urb);\n\n\t\tnetdev_warn(netdev, \"couldn't find free context\\n\");\n\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tcontext->dev = dev;\n\tcontext->echo_index = i;\n\n\tusb_fill_bulk_urb(urb, dev->udev, usb_sndbulkpipe(dev->udev, 2), buf,\n\t\t\t  size, ems_usb_write_bulk_callback, context);\n\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\tusb_anchor_urb(urb, &dev->tx_submitted);\n\n\tcan_put_echo_skb(skb, netdev, context->echo_index, 0);\n\n\tatomic_inc(&dev->active_tx_urbs);\n\n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (unlikely(err)) {\n\t\tcan_free_echo_skb(netdev, context->echo_index, NULL);\n\n\t\tusb_unanchor_urb(urb);\n\t\tusb_free_coherent(dev->udev, size, buf, urb->transfer_dma);\n\t\tdev_kfree_skb(skb);\n\n\t\tatomic_dec(&dev->active_tx_urbs);\n\n\t\tif (err == -ENODEV) {\n\t\t\tnetif_device_detach(netdev);\n\t\t} else {\n\t\t\tnetdev_warn(netdev, \"failed tx_urb %d\\n\", err);\n\n\t\t\tstats->tx_dropped++;\n\t\t}\n\t} else {\n\t\tnetif_trans_update(netdev);\n\n\t\t/* Slow down tx path */\n\t\tif (atomic_read(&dev->active_tx_urbs) >= MAX_TX_URBS ||\n\t\t    dev->free_slots < CPC_TX_QUEUE_TRIGGER_LOW) {\n\t\t\tnetif_stop_queue(netdev);\n\t\t}\n\t}\n\n\t/*\n\t * Release our reference to this URB, the USB core will eventually free\n\t * it entirely.\n\t */\n\tusb_free_urb(urb);\n\n\treturn NETDEV_TX_OK;\n\nnomem:\n\tdev_kfree_skb(skb);\n\tstats->tx_dropped++;\n\n\treturn NETDEV_TX_OK;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147402,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "static netdev_tx_t ems_usb_start_xmit(struct sk_buff *skb, struct net_device *netdev)\n{\n\tstruct ems_usb *dev = netdev_priv(netdev);\n\tstruct ems_tx_urb_context *context = NULL;\n\tstruct net_device_stats *stats = &netdev->stats;\n\tstruct can_frame *cf = (struct can_frame *)skb->data;\n\tstruct ems_cpc_msg *msg;\n\tstruct urb *urb;\n\tu8 *buf;\n\tint i, err;\n\tsize_t size = CPC_HEADER_SIZE + CPC_MSG_HEADER_LEN\n\t\t\t+ sizeof(struct cpc_can_msg);\n\n\tif (can_dropped_invalid_skb(netdev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\t/* create a URB, and a buffer for it, and copy the data to the URB */\n\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!urb)\n\t\tgoto nomem;\n\n\tbuf = usb_alloc_coherent(dev->udev, size, GFP_ATOMIC, &urb->transfer_dma);\n\tif (!buf) {\n\t\tnetdev_err(netdev, \"No memory left for USB buffer\\n\");\n\t\tusb_free_urb(urb);\n\t\tgoto nomem;\n\t}\n\n\tmsg = (struct ems_cpc_msg *)&buf[CPC_HEADER_SIZE];\n\n\tmsg->msg.can_msg.id = cpu_to_le32(cf->can_id & CAN_ERR_MASK);\n\tmsg->msg.can_msg.length = cf->len;\n\n\tif (cf->can_id & CAN_RTR_FLAG) {\n\t\tmsg->type = cf->can_id & CAN_EFF_FLAG ?\n\t\t\tCPC_CMD_TYPE_EXT_RTR_FRAME : CPC_CMD_TYPE_RTR_FRAME;\n\n\t\tmsg->length = CPC_CAN_MSG_MIN_SIZE;\n\t} else {\n\t\tmsg->type = cf->can_id & CAN_EFF_FLAG ?\n\t\t\tCPC_CMD_TYPE_EXT_CAN_FRAME : CPC_CMD_TYPE_CAN_FRAME;\n\n\t\tfor (i = 0; i < cf->len; i++)\n\t\t\tmsg->msg.can_msg.msg[i] = cf->data[i];\n\n\t\tmsg->length = CPC_CAN_MSG_MIN_SIZE + cf->len;\n\t}\n\n\tfor (i = 0; i < MAX_TX_URBS; i++) {\n\t\tif (dev->tx_contexts[i].echo_index == MAX_TX_URBS) {\n\t\t\tcontext = &dev->tx_contexts[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * May never happen! When this happens we'd more URBs in flight as\n\t * allowed (MAX_TX_URBS).\n\t */\n\tif (!context) {\n\t\tusb_free_coherent(dev->udev, size, buf, urb->transfer_dma);\n\t\tusb_free_urb(urb);\n\n\t\tnetdev_warn(netdev, \"couldn't find free context\\n\");\n\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tcontext->dev = dev;\n\tcontext->echo_index = i;\n\n\tusb_fill_bulk_urb(urb, dev->udev, usb_sndbulkpipe(dev->udev, 2), buf,\n\t\t\t  size, ems_usb_write_bulk_callback, context);\n\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\tusb_anchor_urb(urb, &dev->tx_submitted);\n\n\tcan_put_echo_skb(skb, netdev, context->echo_index, 0);\n\n\tatomic_inc(&dev->active_tx_urbs);\n\n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (unlikely(err)) {\n\t\tcan_free_echo_skb(netdev, context->echo_index, NULL);\n\n\t\tusb_unanchor_urb(urb);\n\t\tusb_free_coherent(dev->udev, size, buf, urb->transfer_dma);\n\n\t\tatomic_dec(&dev->active_tx_urbs);\n\n\t\tif (err == -ENODEV) {\n\t\t\tnetif_device_detach(netdev);\n\t\t} else {\n\t\t\tnetdev_warn(netdev, \"failed tx_urb %d\\n\", err);\n\n\t\t\tstats->tx_dropped++;\n\t\t}\n\t} else {\n\t\tnetif_trans_update(netdev);\n\n\t\t/* Slow down tx path */\n\t\tif (atomic_read(&dev->active_tx_urbs) >= MAX_TX_URBS ||\n\t\t    dev->free_slots < CPC_TX_QUEUE_TRIGGER_LOW) {\n\t\t\tnetif_stop_queue(netdev);\n\t\t}\n\t}\n\n\t/*\n\t * Release our reference to this URB, the USB core will eventually free\n\t * it entirely.\n\t */\n\tusb_free_urb(urb);\n\n\treturn NETDEV_TX_OK;\n\nnomem:\n\tdev_kfree_skb(skb);\n\tstats->tx_dropped++;\n\n\treturn NETDEV_TX_OK;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147403,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "long ContentEncoding::ParseContentEncodingEntry(long long start, long long size,\n                                                IMkvReader* pReader) {\n  assert(pReader);\n\n  long long pos = start;\n  const long long stop = start + size;\n\n  // Count ContentCompression and ContentEncryption elements.\n  int compression_count = 0;\n  int encryption_count = 0;\n\n  while (pos < stop) {\n    long long id, size;\n    const long status = ParseElementHeader(pReader, pos, stop, id, size);\n    if (status < 0)  // error\n      return status;\n\n    if (id == libwebm::kMkvContentCompression)\n      ++compression_count;\n\n    if (id == libwebm::kMkvContentEncryption)\n      ++encryption_count;\n\n    pos += size;  // consume payload\n    if (pos > stop)\n      return E_FILE_FORMAT_INVALID;\n  }\n\n  if (compression_count <= 0 && encryption_count <= 0)\n    return -1;\n\n  if (compression_count > 0) {\n    compression_entries_ =\n        new (std::nothrow) ContentCompression*[compression_count];\n    if (!compression_entries_)\n      return -1;\n    compression_entries_end_ = compression_entries_;\n  }\n\n  if (encryption_count > 0) {\n    encryption_entries_ =\n        new (std::nothrow) ContentEncryption*[encryption_count];\n    if (!encryption_entries_) {\n      delete[] compression_entries_;\n      return -1;\n    }\n    encryption_entries_end_ = encryption_entries_;\n  }\n\n  pos = start;\n  while (pos < stop) {\n    long long id, size;\n    long status = ParseElementHeader(pReader, pos, stop, id, size);\n    if (status < 0)  // error\n      return status;\n\n    if (id == libwebm::kMkvContentEncodingOrder) {\n      encoding_order_ = UnserializeUInt(pReader, pos, size);\n    } else if (id == libwebm::kMkvContentEncodingScope) {\n      encoding_scope_ = UnserializeUInt(pReader, pos, size);\n      if (encoding_scope_ < 1)\n        return -1;\n    } else if (id == libwebm::kMkvContentEncodingType) {\n      encoding_type_ = UnserializeUInt(pReader, pos, size);\n    } else if (id == libwebm::kMkvContentCompression) {\n      ContentCompression* const compression =\n          new (std::nothrow) ContentCompression();\n      if (!compression)\n        return -1;\n\n      status = ParseCompressionEntry(pos, size, pReader, compression);\n      if (status) {\n        delete compression;\n        return status;\n      }\n      *compression_entries_end_++ = compression;\n    } else if (id == libwebm::kMkvContentEncryption) {\n      ContentEncryption* const encryption =\n          new (std::nothrow) ContentEncryption();\n      if (!encryption)\n        return -1;\n\n      status = ParseEncryptionEntry(pos, size, pReader, encryption);\n      if (status) {\n        delete encryption;\n        return status;\n      }\n      *encryption_entries_end_++ = encryption;\n    }\n\n    pos += size;  // consume payload\n    if (pos > stop)\n      return E_FILE_FORMAT_INVALID;\n  }\n\n  if (pos != stop)\n    return E_FILE_FORMAT_INVALID;\n  return 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147404,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "long ContentEncoding::ParseContentEncodingEntry(long long start, long long size,\n                                                IMkvReader* pReader) {\n  assert(pReader);\n\n  long long pos = start;\n  const long long stop = start + size;\n\n  // Count ContentCompression and ContentEncryption elements.\n  int compression_count = 0;\n  int encryption_count = 0;\n\n  while (pos < stop) {\n    long long id, size;\n    const long status = ParseElementHeader(pReader, pos, stop, id, size);\n    if (status < 0)  // error\n      return status;\n\n    if (id == libwebm::kMkvContentCompression)\n      ++compression_count;\n\n    if (id == libwebm::kMkvContentEncryption)\n      ++encryption_count;\n\n    pos += size;  // consume payload\n    if (pos > stop)\n      return E_FILE_FORMAT_INVALID;\n  }\n\n  if (compression_count <= 0 && encryption_count <= 0)\n    return -1;\n\n  if (compression_count > 0) {\n    compression_entries_ =\n        new (std::nothrow) ContentCompression*[compression_count];\n    if (!compression_entries_)\n      return -1;\n    compression_entries_end_ = compression_entries_;\n  }\n\n  if (encryption_count > 0) {\n    encryption_entries_ =\n        new (std::nothrow) ContentEncryption*[encryption_count];\n    if (!encryption_entries_) {\n      delete[] compression_entries_;\n      compression_entries_ = NULL;\n      return -1;\n    }\n    encryption_entries_end_ = encryption_entries_;\n  }\n\n  pos = start;\n  while (pos < stop) {\n    long long id, size;\n    long status = ParseElementHeader(pReader, pos, stop, id, size);\n    if (status < 0)  // error\n      return status;\n\n    if (id == libwebm::kMkvContentEncodingOrder) {\n      encoding_order_ = UnserializeUInt(pReader, pos, size);\n    } else if (id == libwebm::kMkvContentEncodingScope) {\n      encoding_scope_ = UnserializeUInt(pReader, pos, size);\n      if (encoding_scope_ < 1)\n        return -1;\n    } else if (id == libwebm::kMkvContentEncodingType) {\n      encoding_type_ = UnserializeUInt(pReader, pos, size);\n    } else if (id == libwebm::kMkvContentCompression) {\n      ContentCompression* const compression =\n          new (std::nothrow) ContentCompression();\n      if (!compression)\n        return -1;\n\n      status = ParseCompressionEntry(pos, size, pReader, compression);\n      if (status) {\n        delete compression;\n        return status;\n      }\n      assert(compression_count > 0);\n      *compression_entries_end_++ = compression;\n    } else if (id == libwebm::kMkvContentEncryption) {\n      ContentEncryption* const encryption =\n          new (std::nothrow) ContentEncryption();\n      if (!encryption)\n        return -1;\n\n      status = ParseEncryptionEntry(pos, size, pReader, encryption);\n      if (status) {\n        delete encryption;\n        return status;\n      }\n      assert(encryption_count > 0);\n      *encryption_entries_end_++ = encryption;\n    }\n\n    pos += size;  // consume payload\n    if (pos > stop)\n      return E_FILE_FORMAT_INVALID;\n  }\n\n  if (pos != stop)\n    return E_FILE_FORMAT_INVALID;\n  return 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147405,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "get_function_args(\n    char_u\t**argp,\n    char_u\tendchar,\n    garray_T\t*newargs,\n    garray_T\t*argtypes,\t// NULL unless using :def\n    int\t\ttypes_optional,\t// types optional if \"argtypes\" is not NULL\n    evalarg_T\t*evalarg,\t// context or NULL\n    int\t\t*varargs,\n    garray_T\t*default_args,\n    int\t\tskip,\n    exarg_T\t*eap,\n    char_u\t**line_to_free)\n{\n    int\t\tmustend = FALSE;\n    char_u\t*arg;\n    char_u\t*p;\n    int\t\tc;\n    int\t\tany_default = FALSE;\n    char_u\t*expr;\n    char_u\t*whitep = *argp;\n\n    if (newargs != NULL)\n\tga_init2(newargs, (int)sizeof(char_u *), 3);\n    if (argtypes != NULL)\n\tga_init2(argtypes, (int)sizeof(char_u *), 3);\n    if (!skip && default_args != NULL)\n\tga_init2(default_args, (int)sizeof(char_u *), 3);\n\n    if (varargs != NULL)\n\t*varargs = FALSE;\n\n    /*\n     * Isolate the arguments: \"arg1, arg2, ...)\"\n     */\n    arg = skipwhite(*argp);\n    p = arg;\n    while (*p != endchar)\n    {\n\twhile (eap != NULL && eap->getline != NULL\n\t\t\t && (*p == NUL || (VIM_ISWHITE(*whitep) && *p == '#')))\n\t{\n\t    char_u *theline;\n\n\t    // End of the line, get the next one.\n\t    theline = eap->getline(':', eap->cookie, 0, TRUE);\n\t    if (theline == NULL)\n\t\tbreak;\n\t    vim_free(*line_to_free);\n\t    *line_to_free = theline;\n\t    whitep = (char_u *)\" \";\n\t    p = skipwhite(theline);\n\t}\n\n\tif (mustend && *p != endchar)\n\t{\n\t    if (!skip)\n\t\tsemsg(_(e_invarg2), *argp);\n\t    goto err_ret;\n\t}\n\tif (*p == endchar)\n\t    break;\n\n\tif (p[0] == '.' && p[1] == '.' && p[2] == '.')\n\t{\n\t    if (varargs != NULL)\n\t\t*varargs = TRUE;\n\t    p += 3;\n\t    mustend = TRUE;\n\n\t    if (argtypes != NULL)\n\t    {\n\t\t// ...name: list<type>\n\t\tif (!eval_isnamec1(*p))\n\t\t{\n\t\t    if (!skip)\n\t\t\temsg(_(e_missing_name_after_dots));\n\t\t    goto err_ret;\n\t\t}\n\n\t\targ = p;\n\t\tp = one_function_arg(p, newargs, argtypes, types_optional,\n\t\t\t\t\t\t\t  evalarg, TRUE, skip);\n\t\tif (p == arg)\n\t\t    break;\n\t\tif (*skipwhite(p) == '=')\n\t\t{\n\t\t    emsg(_(e_cannot_use_default_for_variable_arguments));\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    char_u *np;\n\n\t    arg = p;\n\t    p = one_function_arg(p, newargs, argtypes, types_optional,\n\t\t\t\t\t\t\t evalarg, FALSE, skip);\n\t    if (p == arg)\n\t\tbreak;\n\n\t    // Recognize \" = expr\" but not \" == expr\".  A lambda can have\n\t    // \"(a = expr\" but \"(a == expr\" and \"(a =~ expr\" are not a lambda.\n\t    np = skipwhite(p);\n\t    if (*np == '=' && np[1] != '=' && np[1] != '~'\n\t\t\t\t\t\t       && default_args != NULL)\n\t    {\n\t\ttypval_T\trettv;\n\n\t\t// find the end of the expression (doesn't evaluate it)\n\t\tany_default = TRUE;\n\t\tp = skipwhite(p) + 1;\n\t\twhitep = p;\n\t\tp = skipwhite(p);\n\t\texpr = p;\n\t\tif (eval1(&p, &rettv, NULL) != FAIL)\n\t\t{\n\t\t    if (!skip)\n\t\t    {\n\t\t\tif (ga_grow(default_args, 1) == FAIL)\n\t\t\t    goto err_ret;\n\n\t\t\t// trim trailing whitespace\n\t\t\twhile (p > expr && VIM_ISWHITE(p[-1]))\n\t\t\t    p--;\n\t\t\tc = *p;\n\t\t\t*p = NUL;\n\t\t\texpr = vim_strsave(expr);\n\t\t\tif (expr == NULL)\n\t\t\t{\n\t\t\t    *p = c;\n\t\t\t    goto err_ret;\n\t\t\t}\n\t\t\t((char_u **)(default_args->ga_data))\n\t\t\t\t\t\t [default_args->ga_len] = expr;\n\t\t\tdefault_args->ga_len++;\n\t\t\t*p = c;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    mustend = TRUE;\n\t    }\n\t    else if (any_default)\n\t    {\n\t\temsg(_(\"E989: Non-default argument follows default argument\"));\n\t\tgoto err_ret;\n\t    }\n\n\t    if (VIM_ISWHITE(*p) && *skipwhite(p) == ',')\n\t    {\n\t\t// Be tolerant when skipping\n\t\tif (!skip)\n\t\t{\n\t\t    semsg(_(e_no_white_space_allowed_before_str_str), \",\", p);\n\t\t    goto err_ret;\n\t\t}\n\t\tp = skipwhite(p);\n\t    }\n\t    if (*p == ',')\n\t    {\n\t\t++p;\n\t\t// Don't give this error when skipping, it makes the \"->\" not\n\t\t// found in \"{k,v -> x}\" and give a confusing error.\n\t\t// Allow missing space after comma in legacy functions.\n\t\tif (!skip && argtypes != NULL\n\t\t\t\t      && !IS_WHITE_OR_NUL(*p) && *p != endchar)\n\t\t{\n\t\t    semsg(_(e_white_space_required_after_str_str), \",\", p - 1);\n\t\t    goto err_ret;\n\t\t}\n\t    }\n\t    else\n\t\tmustend = TRUE;\n\t}\n\twhitep = p;\n\tp = skipwhite(p);\n    }\n\n    if (*p != endchar)\n\tgoto err_ret;\n    ++p;\t// skip \"endchar\"\n\n    *argp = p;\n    return OK;\n\nerr_ret:\n    if (newargs != NULL)\n\tga_clear_strings(newargs);\n    if (!skip && default_args != NULL)\n\tga_clear_strings(default_args);\n    return FAIL;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147476,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "get_function_args(\n    char_u\t**argp,\n    char_u\tendchar,\n    garray_T\t*newargs,\n    garray_T\t*argtypes,\t// NULL unless using :def\n    int\t\ttypes_optional,\t// types optional if \"argtypes\" is not NULL\n    evalarg_T\t*evalarg,\t// context or NULL\n    int\t\t*varargs,\n    garray_T\t*default_args,\n    int\t\tskip,\n    exarg_T\t*eap,\n    char_u\t**line_to_free)\n{\n    int\t\tmustend = FALSE;\n    char_u\t*arg;\n    char_u\t*p;\n    int\t\tc;\n    int\t\tany_default = FALSE;\n    char_u\t*expr;\n    char_u\t*whitep = *argp;\n\n    if (newargs != NULL)\n\tga_init2(newargs, (int)sizeof(char_u *), 3);\n    if (argtypes != NULL)\n\tga_init2(argtypes, (int)sizeof(char_u *), 3);\n    if (!skip && default_args != NULL)\n\tga_init2(default_args, (int)sizeof(char_u *), 3);\n\n    if (varargs != NULL)\n\t*varargs = FALSE;\n\n    /*\n     * Isolate the arguments: \"arg1, arg2, ...)\"\n     */\n    arg = skipwhite(*argp);\n    p = arg;\n    while (*p != endchar)\n    {\n\twhile (eap != NULL && eap->getline != NULL\n\t\t\t && (*p == NUL || (VIM_ISWHITE(*whitep) && *p == '#')))\n\t{\n\t    char_u *theline;\n\n\t    // End of the line, get the next one.\n\t    theline = eap->getline(':', eap->cookie, 0, TRUE);\n\t    if (theline == NULL)\n\t\tbreak;\n\t    vim_free(*line_to_free);\n\t    if (*eap->cmdlinep == *line_to_free)\n\t\t*eap->cmdlinep = theline;\n\t    *line_to_free = theline;\n\t    whitep = (char_u *)\" \";\n\t    p = skipwhite(theline);\n\t}\n\n\tif (mustend && *p != endchar)\n\t{\n\t    if (!skip)\n\t\tsemsg(_(e_invarg2), *argp);\n\t    goto err_ret;\n\t}\n\tif (*p == endchar)\n\t    break;\n\n\tif (p[0] == '.' && p[1] == '.' && p[2] == '.')\n\t{\n\t    if (varargs != NULL)\n\t\t*varargs = TRUE;\n\t    p += 3;\n\t    mustend = TRUE;\n\n\t    if (argtypes != NULL)\n\t    {\n\t\t// ...name: list<type>\n\t\tif (!eval_isnamec1(*p))\n\t\t{\n\t\t    if (!skip)\n\t\t\temsg(_(e_missing_name_after_dots));\n\t\t    goto err_ret;\n\t\t}\n\n\t\targ = p;\n\t\tp = one_function_arg(p, newargs, argtypes, types_optional,\n\t\t\t\t\t\t\t  evalarg, TRUE, skip);\n\t\tif (p == arg)\n\t\t    break;\n\t\tif (*skipwhite(p) == '=')\n\t\t{\n\t\t    emsg(_(e_cannot_use_default_for_variable_arguments));\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    char_u *np;\n\n\t    arg = p;\n\t    p = one_function_arg(p, newargs, argtypes, types_optional,\n\t\t\t\t\t\t\t evalarg, FALSE, skip);\n\t    if (p == arg)\n\t\tbreak;\n\n\t    // Recognize \" = expr\" but not \" == expr\".  A lambda can have\n\t    // \"(a = expr\" but \"(a == expr\" and \"(a =~ expr\" are not a lambda.\n\t    np = skipwhite(p);\n\t    if (*np == '=' && np[1] != '=' && np[1] != '~'\n\t\t\t\t\t\t       && default_args != NULL)\n\t    {\n\t\ttypval_T\trettv;\n\n\t\t// find the end of the expression (doesn't evaluate it)\n\t\tany_default = TRUE;\n\t\tp = skipwhite(p) + 1;\n\t\twhitep = p;\n\t\tp = skipwhite(p);\n\t\texpr = p;\n\t\tif (eval1(&p, &rettv, NULL) != FAIL)\n\t\t{\n\t\t    if (!skip)\n\t\t    {\n\t\t\tif (ga_grow(default_args, 1) == FAIL)\n\t\t\t    goto err_ret;\n\n\t\t\t// trim trailing whitespace\n\t\t\twhile (p > expr && VIM_ISWHITE(p[-1]))\n\t\t\t    p--;\n\t\t\tc = *p;\n\t\t\t*p = NUL;\n\t\t\texpr = vim_strsave(expr);\n\t\t\tif (expr == NULL)\n\t\t\t{\n\t\t\t    *p = c;\n\t\t\t    goto err_ret;\n\t\t\t}\n\t\t\t((char_u **)(default_args->ga_data))\n\t\t\t\t\t\t [default_args->ga_len] = expr;\n\t\t\tdefault_args->ga_len++;\n\t\t\t*p = c;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    mustend = TRUE;\n\t    }\n\t    else if (any_default)\n\t    {\n\t\temsg(_(\"E989: Non-default argument follows default argument\"));\n\t\tgoto err_ret;\n\t    }\n\n\t    if (VIM_ISWHITE(*p) && *skipwhite(p) == ',')\n\t    {\n\t\t// Be tolerant when skipping\n\t\tif (!skip)\n\t\t{\n\t\t    semsg(_(e_no_white_space_allowed_before_str_str), \",\", p);\n\t\t    goto err_ret;\n\t\t}\n\t\tp = skipwhite(p);\n\t    }\n\t    if (*p == ',')\n\t    {\n\t\t++p;\n\t\t// Don't give this error when skipping, it makes the \"->\" not\n\t\t// found in \"{k,v -> x}\" and give a confusing error.\n\t\t// Allow missing space after comma in legacy functions.\n\t\tif (!skip && argtypes != NULL\n\t\t\t\t      && !IS_WHITE_OR_NUL(*p) && *p != endchar)\n\t\t{\n\t\t    semsg(_(e_white_space_required_after_str_str), \",\", p - 1);\n\t\t    goto err_ret;\n\t\t}\n\t    }\n\t    else\n\t\tmustend = TRUE;\n\t}\n\twhitep = p;\n\tp = skipwhite(p);\n    }\n\n    if (*p != endchar)\n\tgoto err_ret;\n    ++p;\t// skip \"endchar\"\n\n    *argp = p;\n    return OK;\n\nerr_ret:\n    if (newargs != NULL)\n\tga_clear_strings(newargs);\n    if (!skip && default_args != NULL)\n\tga_clear_strings(default_args);\n    return FAIL;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147477,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "snd_seq_oss_open(struct file *file, int level)\n{\n\tint i, rc;\n\tstruct seq_oss_devinfo *dp;\n\n\tdp = kzalloc(sizeof(*dp), GFP_KERNEL);\n\tif (!dp) {\n\t\tsnd_printk(KERN_ERR \"can't malloc device info\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tdebug_printk((\"oss_open: dp = %p\\n\", dp));\n\n\tdp->cseq = system_client;\n\tdp->port = -1;\n\tdp->queue = -1;\n\n\tfor (i = 0; i < SNDRV_SEQ_OSS_MAX_CLIENTS; i++) {\n\t\tif (client_table[i] == NULL)\n\t\t\tbreak;\n\t}\n\n\tdp->index = i;\n\tif (i >= SNDRV_SEQ_OSS_MAX_CLIENTS) {\n\t\tsnd_printk(KERN_ERR \"too many applications\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto _error;\n\t}\n\n\t/* look up synth and midi devices */\n\tsnd_seq_oss_synth_setup(dp);\n\tsnd_seq_oss_midi_setup(dp);\n\n\tif (dp->synth_opened == 0 && dp->max_mididev == 0) {\n\t\t/* snd_printk(KERN_ERR \"no device found\\n\"); */\n\t\trc = -ENODEV;\n\t\tgoto _error;\n\t}\n\n\t/* create port */\n\tdebug_printk((\"create new port\\n\"));\n\trc = create_port(dp);\n\tif (rc < 0) {\n\t\tsnd_printk(KERN_ERR \"can't create port\\n\");\n\t\tgoto _error;\n\t}\n\n\t/* allocate queue */\n\tdebug_printk((\"allocate queue\\n\"));\n\trc = alloc_seq_queue(dp);\n\tif (rc < 0)\n\t\tgoto _error;\n\n\t/* set address */\n\tdp->addr.client = dp->cseq;\n\tdp->addr.port = dp->port;\n\t/*dp->addr.queue = dp->queue;*/\n\t/*dp->addr.channel = 0;*/\n\n\tdp->seq_mode = level;\n\n\t/* set up file mode */\n\tdp->file_mode = translate_mode(file);\n\n\t/* initialize read queue */\n\tdebug_printk((\"initialize read queue\\n\"));\n\tif (is_read_mode(dp->file_mode)) {\n\t\tdp->readq = snd_seq_oss_readq_new(dp, maxqlen);\n\t\tif (!dp->readq) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto _error;\n\t\t}\n\t}\n\n\t/* initialize write queue */\n\tdebug_printk((\"initialize write queue\\n\"));\n\tif (is_write_mode(dp->file_mode)) {\n\t\tdp->writeq = snd_seq_oss_writeq_new(dp, maxqlen);\n\t\tif (!dp->writeq) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto _error;\n\t\t}\n\t}\n\n\t/* initialize timer */\n\tdebug_printk((\"initialize timer\\n\"));\n\tdp->timer = snd_seq_oss_timer_new(dp);\n\tif (!dp->timer) {\n\t\tsnd_printk(KERN_ERR \"can't alloc timer\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto _error;\n\t}\n\tdebug_printk((\"timer initialized\\n\"));\n\n\t/* set private data pointer */\n\tfile->private_data = dp;\n\n\t/* set up for mode2 */\n\tif (level == SNDRV_SEQ_OSS_MODE_MUSIC)\n\t\tsnd_seq_oss_synth_setup_midi(dp);\n\telse if (is_read_mode(dp->file_mode))\n\t\tsnd_seq_oss_midi_open_all(dp, SNDRV_SEQ_OSS_FILE_READ);\n\n\tclient_table[dp->index] = dp;\n\tnum_clients++;\n\n\tdebug_printk((\"open done\\n\"));\n\treturn 0;\n\n _error:\n\tsnd_seq_oss_writeq_delete(dp->writeq);\n\tsnd_seq_oss_readq_delete(dp->readq);\n\tsnd_seq_oss_synth_cleanup(dp);\n\tsnd_seq_oss_midi_cleanup(dp);\n\tdelete_port(dp);\n\tdelete_seq_queue(dp->queue);\n\tkfree(dp);\n\n\treturn rc;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147610,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "snd_seq_oss_open(struct file *file, int level)\n{\n\tint i, rc;\n\tstruct seq_oss_devinfo *dp;\n\n\tdp = kzalloc(sizeof(*dp), GFP_KERNEL);\n\tif (!dp) {\n\t\tsnd_printk(KERN_ERR \"can't malloc device info\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tdebug_printk((\"oss_open: dp = %p\\n\", dp));\n\n\tdp->cseq = system_client;\n\tdp->port = -1;\n\tdp->queue = -1;\n\n\tfor (i = 0; i < SNDRV_SEQ_OSS_MAX_CLIENTS; i++) {\n\t\tif (client_table[i] == NULL)\n\t\t\tbreak;\n\t}\n\n\tdp->index = i;\n\tif (i >= SNDRV_SEQ_OSS_MAX_CLIENTS) {\n\t\tsnd_printk(KERN_ERR \"too many applications\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto _error;\n\t}\n\n\t/* look up synth and midi devices */\n\tsnd_seq_oss_synth_setup(dp);\n\tsnd_seq_oss_midi_setup(dp);\n\n\tif (dp->synth_opened == 0 && dp->max_mididev == 0) {\n\t\t/* snd_printk(KERN_ERR \"no device found\\n\"); */\n\t\trc = -ENODEV;\n\t\tgoto _error;\n\t}\n\n\t/* create port */\n\tdebug_printk((\"create new port\\n\"));\n\trc = create_port(dp);\n\tif (rc < 0) {\n\t\tsnd_printk(KERN_ERR \"can't create port\\n\");\n\t\tgoto _error;\n\t}\n\n\t/* allocate queue */\n\tdebug_printk((\"allocate queue\\n\"));\n\trc = alloc_seq_queue(dp);\n\tif (rc < 0)\n\t\tgoto _error;\n\n\t/* set address */\n\tdp->addr.client = dp->cseq;\n\tdp->addr.port = dp->port;\n\t/*dp->addr.queue = dp->queue;*/\n\t/*dp->addr.channel = 0;*/\n\n\tdp->seq_mode = level;\n\n\t/* set up file mode */\n\tdp->file_mode = translate_mode(file);\n\n\t/* initialize read queue */\n\tdebug_printk((\"initialize read queue\\n\"));\n\tif (is_read_mode(dp->file_mode)) {\n\t\tdp->readq = snd_seq_oss_readq_new(dp, maxqlen);\n\t\tif (!dp->readq) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto _error;\n\t\t}\n\t}\n\n\t/* initialize write queue */\n\tdebug_printk((\"initialize write queue\\n\"));\n\tif (is_write_mode(dp->file_mode)) {\n\t\tdp->writeq = snd_seq_oss_writeq_new(dp, maxqlen);\n\t\tif (!dp->writeq) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto _error;\n\t\t}\n\t}\n\n\t/* initialize timer */\n\tdebug_printk((\"initialize timer\\n\"));\n\tdp->timer = snd_seq_oss_timer_new(dp);\n\tif (!dp->timer) {\n\t\tsnd_printk(KERN_ERR \"can't alloc timer\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto _error;\n\t}\n\tdebug_printk((\"timer initialized\\n\"));\n\n\t/* set private data pointer */\n\tfile->private_data = dp;\n\n\t/* set up for mode2 */\n\tif (level == SNDRV_SEQ_OSS_MODE_MUSIC)\n\t\tsnd_seq_oss_synth_setup_midi(dp);\n\telse if (is_read_mode(dp->file_mode))\n\t\tsnd_seq_oss_midi_open_all(dp, SNDRV_SEQ_OSS_FILE_READ);\n\n\tclient_table[dp->index] = dp;\n\tnum_clients++;\n\n\tdebug_printk((\"open done\\n\"));\n\treturn 0;\n\n _error:\n\tsnd_seq_oss_synth_cleanup(dp);\n\tsnd_seq_oss_midi_cleanup(dp);\n\tdelete_seq_queue(dp->queue);\n\tdelete_port(dp);\n\n\treturn rc;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147611,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "get_cdtext_generic (void *p_user_data)\n{\n  generic_img_private_t *p_env = p_user_data;\n  uint8_t *p_cdtext_data = NULL;\n  size_t  len;\n\n  if (!p_env) return NULL;\n\n  if (p_env->b_cdtext_error) return NULL;\n\n  if (NULL == p_env->cdtext) {\n    p_cdtext_data = read_cdtext_generic (p_env);\n\n    if (NULL != p_cdtext_data) {\n      len = CDIO_MMC_GET_LEN16(p_cdtext_data)-2;\n      p_env->cdtext = cdtext_init();\n\n      if(len <= 0 || 0 != cdtext_data_init (p_env->cdtext, &p_cdtext_data[4], len)) {\n        p_env->b_cdtext_error = true;\n        free(p_env->cdtext);\n        p_env->cdtext = NULL;\n      }\n\n      free(p_cdtext_data);\n    }\n  }\n\n  return p_env->cdtext;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147674,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "get_cdtext_generic (void *p_user_data)\n{\n  generic_img_private_t *p_env = p_user_data;\n  uint8_t *p_cdtext_data = NULL;\n  size_t  len;\n\n  if (!p_env) return NULL;\n\n  if (p_env->b_cdtext_error) return NULL;\n\n  if (NULL == p_env->cdtext) {\n    p_cdtext_data = read_cdtext_generic (p_env);\n\n    if (NULL != p_cdtext_data) {\n      len = CDIO_MMC_GET_LEN16(p_cdtext_data)-2;\n      p_env->cdtext = cdtext_init();\n\n      if(len <= 0 || 0 != cdtext_data_init (p_env->cdtext, &p_cdtext_data[4], len)) {\n        p_env->b_cdtext_error = true;\n        cdtext_destroy (p_env->cdtext);\n        p_env->cdtext = NULL;\n      }\n\n      free(p_cdtext_data);\n    }\n  }\n\n  return p_env->cdtext;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147675,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "int flb_parser_json_do(struct flb_parser *parser,\n                       const char *in_buf, size_t in_size,\n                       void **out_buf, size_t *out_size,\n                       struct flb_time *out_time)\n{\n    int i;\n    int skip;\n    int ret;\n    int slen;\n    int root_type;\n    int records;\n    double tmfrac = 0;\n    char *mp_buf = NULL;\n    char *time_key;\n    char *tmp_out_buf = NULL;\n    char tmp[255];\n    size_t tmp_out_size = 0;\n    size_t off = 0;\n    size_t map_size;\n    size_t mp_size;\n    size_t len;\n    msgpack_sbuffer mp_sbuf;\n    msgpack_packer  mp_pck;\n    msgpack_unpacked result;\n    msgpack_object map;\n    msgpack_object *k = NULL;\n    msgpack_object *v = NULL;\n    time_t time_lookup;\n    struct tm tm = {0};\n    struct flb_time *t;\n\n    /* Convert incoming in_buf JSON message to message pack format */\n    ret = flb_pack_json_recs(in_buf, in_size, &mp_buf, &mp_size, &root_type,\n                             &records);\n    if (ret != 0) {\n        return -1;\n    }\n\n    if (records != 1) {\n        flb_free(mp_buf);\n        return -1;\n    }\n\n    /* Make sure object is a map */\n    msgpack_unpacked_init(&result);\n    if (msgpack_unpack_next(&result, mp_buf, mp_size, &off) == MSGPACK_UNPACK_SUCCESS) {\n        map = result.data;\n        if (map.type != MSGPACK_OBJECT_MAP) {\n            flb_free(mp_buf);\n            msgpack_unpacked_destroy(&result);\n            return -1;\n        }\n    }\n    else {\n        if (mp_size > 0) {\n            flb_free(mp_buf);\n        }\n        msgpack_unpacked_destroy(&result);\n        return -1;\n    }\n\n    /* Export results (might change later) */\n    tmp_out_buf = mp_buf;\n    tmp_out_size = mp_size;\n\n    /* Do we have some decoders set ? */\n    if (parser->decoders) {\n        ret = flb_parser_decoder_do(parser->decoders,\n                                    mp_buf, mp_size,\n                                    &tmp_out_buf, &tmp_out_size);\n        if (ret == 0) {\n            /* re-process the unpack context */\n            off = 0;\n            msgpack_unpacked_destroy(&result);\n            msgpack_unpacked_init(&result);\n            msgpack_unpack_next(&result, tmp_out_buf, tmp_out_size, &off);\n            map = result.data;\n        }\n    }\n\n    /* Set the possible outgoing buffer */\n    *out_buf = tmp_out_buf;\n    *out_size = tmp_out_size;\n    if (mp_buf != tmp_out_buf) {\n        flb_free(mp_buf);\n    }\n\n    /* Do time resolution ? */\n    if (!parser->time_fmt) {\n        msgpack_unpacked_destroy(&result);\n        return *out_size;\n    }\n\n    if (parser->time_key) {\n        time_key = parser->time_key;\n    }\n    else {\n        time_key = \"time\";\n    }\n    slen = strlen(time_key);\n\n    /* Lookup time field */\n    map_size = map.via.map.size;\n    skip = map_size;\n    for (i = 0; i < map_size; i++) {\n        k = &map.via.map.ptr[i].key;\n        v = &map.via.map.ptr[i].val;\n\n        if (k->via.str.size != slen) {\n            continue;\n        }\n\n        /* Ensure the pointer we are about to read is not NULL */\n        if (k->via.str.ptr == NULL) {\n            flb_free(mp_buf);\n            *out_buf = NULL;\n            msgpack_unpacked_destroy(&result);\n            return -1;\n        }\n\n        if (strncmp(k->via.str.ptr, time_key, k->via.str.size) == 0) {\n            /* We found the key, break the loop and keep the index */\n            if (parser->time_keep == FLB_FALSE) {\n                skip = i;\n                break;\n            }\n            else {\n                skip = -1;\n            }\n            break;\n        }\n\n        k = NULL;\n        v = NULL;\n    }\n\n    /* No time_key field found */\n    if (i >= map_size || !k || !v) {\n        msgpack_unpacked_destroy(&result);\n        return *out_size;\n    }\n\n    /* Ensure we have an accurate type */\n    if (v->type != MSGPACK_OBJECT_STR) {\n        msgpack_unpacked_destroy(&result);\n        return *out_size;\n    }\n\n    /* Lookup time */\n    ret = flb_parser_time_lookup(v->via.str.ptr, v->via.str.size,\n                                 0, parser, &tm, &tmfrac);\n    if (ret == -1) {\n        len = v->via.str.size;\n        if (len > sizeof(tmp) - 1) {\n            len = sizeof(tmp) - 1;\n        }\n        memcpy(tmp, v->via.str.ptr, len);\n        tmp[len] = '\\0';\n        flb_warn(\"[parser:%s] invalid time format %s for '%s'\",\n                 parser->name, parser->time_fmt_full, tmp);\n        time_lookup = 0;\n    }\n    else {\n        time_lookup = flb_parser_tm2time(&tm);\n    }\n\n    /* Compose a new map without the time_key field */\n    msgpack_sbuffer_init(&mp_sbuf);\n    msgpack_packer_init(&mp_pck, &mp_sbuf, msgpack_sbuffer_write);\n\n    if (parser->time_keep == FLB_FALSE) {\n        msgpack_pack_map(&mp_pck, map_size - 1);\n    }\n    else {\n        msgpack_pack_map(&mp_pck, map_size);\n    }\n\n    for (i = 0; i < map_size; i++) {\n        if (i == skip) {\n            continue;\n        }\n        msgpack_pack_object(&mp_pck, map.via.map.ptr[i].key);\n        msgpack_pack_object(&mp_pck, map.via.map.ptr[i].val);\n    }\n\n    /* Export the proper buffer */\n    flb_free(tmp_out_buf);\n    *out_buf = mp_sbuf.data;\n    *out_size = mp_sbuf.size;\n\n    t = out_time;\n    t->tm.tv_sec  = time_lookup;\n    t->tm.tv_nsec = (tmfrac * 1000000000);\n\n    msgpack_unpacked_destroy(&result);\n    return *out_size;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147962,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ],
    "human": "Correct. With CWE-415",
    "reason": "The code is vulnerable to a double free because it frees mp_buf conditionally but does not reset it to NULL."
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "int flb_parser_json_do(struct flb_parser *parser,\n                       const char *in_buf, size_t in_size,\n                       void **out_buf, size_t *out_size,\n                       struct flb_time *out_time)\n{\n    int i;\n    int skip;\n    int ret;\n    int slen;\n    int root_type;\n    int records;\n    double tmfrac = 0;\n    char *mp_buf = NULL;\n    char *time_key;\n    char *tmp_out_buf = NULL;\n    char tmp[255];\n    size_t tmp_out_size = 0;\n    size_t off = 0;\n    size_t map_size;\n    size_t mp_size;\n    size_t len;\n    msgpack_sbuffer mp_sbuf;\n    msgpack_packer  mp_pck;\n    msgpack_unpacked result;\n    msgpack_object map;\n    msgpack_object *k = NULL;\n    msgpack_object *v = NULL;\n    time_t time_lookup;\n    struct tm tm = {0};\n    struct flb_time *t;\n\n    /* Convert incoming in_buf JSON message to message pack format */\n    ret = flb_pack_json_recs(in_buf, in_size, &mp_buf, &mp_size, &root_type,\n                             &records);\n    if (ret != 0) {\n        return -1;\n    }\n\n    if (records != 1) {\n        flb_free(mp_buf);\n        return -1;\n    }\n\n    /* Make sure object is a map */\n    msgpack_unpacked_init(&result);\n    if (msgpack_unpack_next(&result, mp_buf, mp_size, &off) == MSGPACK_UNPACK_SUCCESS) {\n        map = result.data;\n        if (map.type != MSGPACK_OBJECT_MAP) {\n            flb_free(mp_buf);\n            msgpack_unpacked_destroy(&result);\n            return -1;\n        }\n    }\n    else {\n        if (mp_size > 0) {\n            flb_free(mp_buf);\n        }\n        msgpack_unpacked_destroy(&result);\n        return -1;\n    }\n\n    /* Export results (might change later) */\n    tmp_out_buf = mp_buf;\n    tmp_out_size = mp_size;\n\n    /* Do we have some decoders set ? */\n    if (parser->decoders) {\n        ret = flb_parser_decoder_do(parser->decoders,\n                                    mp_buf, mp_size,\n                                    &tmp_out_buf, &tmp_out_size);\n        if (ret == 0) {\n            /* re-process the unpack context */\n            off = 0;\n            msgpack_unpacked_destroy(&result);\n            msgpack_unpacked_init(&result);\n            msgpack_unpack_next(&result, tmp_out_buf, tmp_out_size, &off);\n            map = result.data;\n        }\n    }\n\n    /* Set the possible outgoing buffer */\n    *out_buf = tmp_out_buf;\n    *out_size = tmp_out_size;\n    if (mp_buf != tmp_out_buf) {\n        flb_free(mp_buf);\n        mp_buf = NULL;\n    }\n\n    /* Do time resolution ? */\n    if (!parser->time_fmt) {\n        msgpack_unpacked_destroy(&result);\n        return *out_size;\n    }\n\n    if (parser->time_key) {\n        time_key = parser->time_key;\n    }\n    else {\n        time_key = \"time\";\n    }\n    slen = strlen(time_key);\n\n    /* Lookup time field */\n    map_size = map.via.map.size;\n    skip = map_size;\n    for (i = 0; i < map_size; i++) {\n        k = &map.via.map.ptr[i].key;\n        v = &map.via.map.ptr[i].val;\n\n        if (k->via.str.size != slen) {\n            continue;\n        }\n\n        /* Ensure the pointer we are about to read is not NULL */\n        if (k->via.str.ptr == NULL) {\n            flb_free(mp_buf);\n            flb_free(tmp_out_buf);\n            *out_buf = NULL;\n            msgpack_unpacked_destroy(&result);\n            return -1;\n        }\n\n        if (strncmp(k->via.str.ptr, time_key, k->via.str.size) == 0) {\n            /* We found the key, break the loop and keep the index */\n            if (parser->time_keep == FLB_FALSE) {\n                skip = i;\n                break;\n            }\n            else {\n                skip = -1;\n            }\n            break;\n        }\n\n        k = NULL;\n        v = NULL;\n    }\n\n    /* No time_key field found */\n    if (i >= map_size || !k || !v) {\n        msgpack_unpacked_destroy(&result);\n        return *out_size;\n    }\n\n    /* Ensure we have an accurate type */\n    if (v->type != MSGPACK_OBJECT_STR) {\n        msgpack_unpacked_destroy(&result);\n        return *out_size;\n    }\n\n    /* Lookup time */\n    ret = flb_parser_time_lookup(v->via.str.ptr, v->via.str.size,\n                                 0, parser, &tm, &tmfrac);\n    if (ret == -1) {\n        len = v->via.str.size;\n        if (len > sizeof(tmp) - 1) {\n            len = sizeof(tmp) - 1;\n        }\n        memcpy(tmp, v->via.str.ptr, len);\n        tmp[len] = '\\0';\n        flb_warn(\"[parser:%s] invalid time format %s for '%s'\",\n                 parser->name, parser->time_fmt_full, tmp);\n        time_lookup = 0;\n    }\n    else {\n        time_lookup = flb_parser_tm2time(&tm);\n    }\n\n    /* Compose a new map without the time_key field */\n    msgpack_sbuffer_init(&mp_sbuf);\n    msgpack_packer_init(&mp_pck, &mp_sbuf, msgpack_sbuffer_write);\n\n    if (parser->time_keep == FLB_FALSE) {\n        msgpack_pack_map(&mp_pck, map_size - 1);\n    }\n    else {\n        msgpack_pack_map(&mp_pck, map_size);\n    }\n\n    for (i = 0; i < map_size; i++) {\n        if (i == skip) {\n            continue;\n        }\n        msgpack_pack_object(&mp_pck, map.via.map.ptr[i].key);\n        msgpack_pack_object(&mp_pck, map.via.map.ptr[i].val);\n    }\n\n    /* Export the proper buffer */\n    flb_free(tmp_out_buf);\n    *out_buf = mp_sbuf.data;\n    *out_size = mp_sbuf.size;\n\n    t = out_time;\n    t->tm.tv_sec  = time_lookup;\n    t->tm.tv_nsec = (tmfrac * 1000000000);\n\n    msgpack_unpacked_destroy(&result);\n    return *out_size;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 147963,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ],
    "human": "Correct. Without CWE-415"
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "mrb_realloc(mrb_state *mrb, void *p, size_t len)\n{\n  void *p2;\n\n  p2 = mrb_realloc_simple(mrb, p, len);\n  if (len == 0) return p2;\n  if (p2 == NULL) {\n    mrb_free(mrb, p);\n    mrb->gc.out_of_memory = TRUE;\n    mrb_raise_nomemory(mrb);\n  }\n  else {\n    mrb->gc.out_of_memory = FALSE;\n  }\n\n  return p2;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148146,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ],
    "human": "Correct. With CWE-415",
    "reason": "It could lead to double free if realloc_simple frees on failure."
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "mrb_realloc(mrb_state *mrb, void *p, size_t len)\n{\n  void *p2;\n\n  p2 = mrb_realloc_simple(mrb, p, len);\n  if (len == 0) return p2;\n  if (p2 == NULL) {\n    mrb->gc.out_of_memory = TRUE;\n    mrb_raise_nomemory(mrb);\n  }\n  else {\n    mrb->gc.out_of_memory = FALSE;\n  }\n\n  return p2;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148147,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ],
    "human": "Correct. Without CWE-415"
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "static UINT parallel_process_irp_create(PARALLEL_DEVICE* parallel, IRP* irp)\n{\n\tchar* path = NULL;\n\tint status;\n\tUINT32 PathLength;\n\tStream_Seek(irp->input, 28);\n\t/* DesiredAccess(4) AllocationSize(8), FileAttributes(4) */\n\t/* SharedAccess(4) CreateDisposition(4), CreateOptions(4) */\n\tStream_Read_UINT32(irp->input, PathLength);\n\tstatus = ConvertFromUnicode(CP_UTF8, 0, (WCHAR*)Stream_Pointer(irp->input), PathLength / 2,\n\t                            &path, 0, NULL, NULL);\n\n\tif (status < 1)\n\t\tif (!(path = (char*)calloc(1, 1)))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"calloc failed!\");\n\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t}\n\n\tparallel->id = irp->devman->id_sequence++;\n\tparallel->file = open(parallel->path, O_RDWR);\n\n\tif (parallel->file < 0)\n\t{\n\t\tirp->IoStatus = STATUS_ACCESS_DENIED;\n\t\tparallel->id = 0;\n\t}\n\telse\n\t{\n\t\t/* all read and write operations should be non-blocking */\n\t\tif (fcntl(parallel->file, F_SETFL, O_NONBLOCK) == -1)\n\t\t{\n\t\t}\n\t}\n\n\tStream_Write_UINT32(irp->output, parallel->id);\n\tStream_Write_UINT8(irp->output, 0);\n\tfree(path);\n\treturn irp->Complete(irp);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148466,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ],
    "human": "Incorrect. Without CWE-415",
    "reason": "This is an OOB problem. Wrong place for the data. CVE-2020-11018 source https://pub.freerdp.com/cve/CVE-2020-11018/VulnForFreerdp.pdf"
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "static UINT parallel_process_irp_create(PARALLEL_DEVICE* parallel, IRP* irp)\n{\n\tchar* path = NULL;\n\tint status;\n\tWCHAR* ptr;\n\tUINT32 PathLength;\n\tif (!Stream_SafeSeek(irp->input, 28))\n\t\treturn ERROR_INVALID_DATA;\n\t/* DesiredAccess(4) AllocationSize(8), FileAttributes(4) */\n\t/* SharedAccess(4) CreateDisposition(4), CreateOptions(4) */\n\tif (Stream_GetRemainingLength(irp->input) < 4)\n\t\treturn ERROR_INVALID_DATA;\n\tStream_Read_UINT32(irp->input, PathLength);\n\tptr = (WCHAR*)Stream_Pointer(irp->input);\n\tif (!Stream_SafeSeek(irp->input, PathLength))\n\t\treturn ERROR_INVALID_DATA;\n\tstatus = ConvertFromUnicode(CP_UTF8, 0, ptr, PathLength / 2, &path, 0, NULL, NULL);\n\n\tif (status < 1)\n\t\tif (!(path = (char*)calloc(1, 1)))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"calloc failed!\");\n\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t}\n\n\tparallel->id = irp->devman->id_sequence++;\n\tparallel->file = open(parallel->path, O_RDWR);\n\n\tif (parallel->file < 0)\n\t{\n\t\tirp->IoStatus = STATUS_ACCESS_DENIED;\n\t\tparallel->id = 0;\n\t}\n\telse\n\t{\n\t\t/* all read and write operations should be non-blocking */\n\t\tif (fcntl(parallel->file, F_SETFL, O_NONBLOCK) == -1)\n\t\t{\n\t\t}\n\t}\n\n\tStream_Write_UINT32(irp->output, parallel->id);\n\tStream_Write_UINT8(irp->output, 0);\n\tfree(path);\n\treturn irp->Complete(irp);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148467,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "file_rlookup(const char *filename)\t/* I - Filename */\n{\n  int\t\ti;\t\t\t/* Looping var */\n  cache_t\t*wc;\t\t\t/* Current cache file */\n\n\n  for (i = web_files, wc = web_cache; i > 0; i --, wc ++)\n    if (!strcmp(wc->name, filename))\n      return (wc->url);\n\n  return (filename);\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148472,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ],
    "human": "Incorrect. Without CWE-415",
    "reason": "It does not contain any memory deallocation calls and therefore do not risk freeing the same memory twice."
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "file_rlookup(const char *filename)\t/* I - Filename */\n{\n  int\t\ti;\t\t\t/* Looping var */\n  cache_t\t*wc;\t\t\t/* Current cache file */\n\n\n  for (i = web_files, wc = web_cache; i > 0; i --, wc ++)\n  {\n    if (!strcmp(wc->name, filename))\n    {\n      if (!strncmp(wc->url, \"data:\", 5))\n        return (\"data URL\");\n      else\n        return (wc->url);\n    }\n  }\n\n  return (filename);\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148473,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "allocate_trace_buffer(struct trace_array *tr, struct trace_buffer *buf, int size)\n{\n\tenum ring_buffer_flags rb_flags;\n\n\trb_flags = tr->trace_flags & TRACE_ITER_OVERWRITE ? RB_FL_OVERWRITE : 0;\n\n\tbuf->tr = tr;\n\n\tbuf->buffer = ring_buffer_alloc(size, rb_flags);\n\tif (!buf->buffer)\n\t\treturn -ENOMEM;\n\n\tbuf->data = alloc_percpu(struct trace_array_cpu);\n\tif (!buf->data) {\n\t\tring_buffer_free(buf->buffer);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Allocate the first page for all buffers */\n\tset_buffer_entries(&tr->trace_buffer,\n\t\t\t   ring_buffer_size(tr->trace_buffer.buffer, 0));\n\n\treturn 0;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148590,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ],
    "human": "Correct. With CWE-415",
    "reason": "It is vulnerable to CWE-415 due to a dangling pointer after freeing buf->buffer."
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "allocate_trace_buffer(struct trace_array *tr, struct trace_buffer *buf, int size)\n{\n\tenum ring_buffer_flags rb_flags;\n\n\trb_flags = tr->trace_flags & TRACE_ITER_OVERWRITE ? RB_FL_OVERWRITE : 0;\n\n\tbuf->tr = tr;\n\n\tbuf->buffer = ring_buffer_alloc(size, rb_flags);\n\tif (!buf->buffer)\n\t\treturn -ENOMEM;\n\n\tbuf->data = alloc_percpu(struct trace_array_cpu);\n\tif (!buf->data) {\n\t\tring_buffer_free(buf->buffer);\n\t\tbuf->buffer = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Allocate the first page for all buffers */\n\tset_buffer_entries(&tr->trace_buffer,\n\t\t\t   ring_buffer_size(tr->trace_buffer.buffer, 0));\n\n\treturn 0;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148591,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ],
    "human": "Correct. Without CWE-415"
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "print_set_output(char *name, TBOOLEAN datablock, TBOOLEAN append_p)\n{\n    if (print_out && print_out != stderr && print_out != stdout) {\n#ifdef PIPES\n\tif (print_out_name[0] == '|') {\n\t    if (0 > pclose(print_out))\n\t\tperror(print_out_name);\n\t} else\n#endif\n\t    if (0 > fclose(print_out))\n\t\tperror(print_out_name);\n    }\n\n    free(print_out_name);\n    print_out_name = NULL;\n    print_out_var = NULL;\n\n    if (! name) {\n\tprint_out = stderr;\n\treturn;\n    }\n\n    if (strcmp(name, \"-\") == 0) {\n\tprint_out = stdout;\n\treturn;\n    }\n\n#ifdef PIPES\n    if (name[0] == '|') {\n\trestrict_popen();\n\tprint_out = popen(name + 1, \"w\");\n\tif (!print_out)\n\t    perror(name);\n\telse\n\t    print_out_name = name;\n\treturn;\n    }\n#endif\n\n    if (!datablock) {\n\tprint_out = fopen(name, append_p ? \"a\" : \"w\");\n\tif (!print_out) {\n\t    perror(name);\n\t    return;\n\t}\n    } else {\n\tprint_out_var = add_udv_by_name(name);\n\tif (!append_p)\n\t    gpfree_datablock(&print_out_var->udv_value);\n\t/* If this is not an existing datablock to be appended */\n\t/* then make it a new empty datablock */\n\tif (print_out_var->udv_value.type != DATABLOCK) {\n\t    free_value(&print_out_var->udv_value);\n\t    print_out_var->udv_value.type = DATABLOCK;\n\t    print_out_var->udv_value.v.data_array = NULL;\n\t}\n    }\n\n    print_out_name = name;\n}",
    "target": 1,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148758,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ],
    "human": "Incorrect. Without CWE-415",
    "reason": "Safe from CWE-415. The code ensures print_out_name is freed only once per call and nullified."
  },
  {
    "CWE_ID": [
      "CWE-415"
    ],
    "code": "print_set_output(char *name, TBOOLEAN datablock, TBOOLEAN append_p)\n{\n    if (print_out && print_out != stderr && print_out != stdout) {\n#ifdef PIPES\n\tif (print_out_name[0] == '|') {\n\t    if (0 > pclose(print_out))\n\t\tperror(print_out_name);\n\t} else\n#endif\n\t    if (0 > fclose(print_out))\n\t\tperror(print_out_name);\n\tprint_out = stderr;\n    }\n\n    free(print_out_name);\n    print_out_name = NULL;\n    print_out_var = NULL;\n\n    if (! name) {\n\tprint_out = stderr;\n\treturn;\n    }\n\n    if (strcmp(name, \"-\") == 0) {\n\tprint_out = stdout;\n\treturn;\n    }\n\n#ifdef PIPES\n    if (name[0] == '|') {\n\trestrict_popen();\n\tprint_out = popen(name + 1, \"w\");\n\tif (!print_out)\n\t    perror(name);\n\telse\n\t    print_out_name = name;\n\treturn;\n    }\n#endif\n\n    if (!datablock) {\n\tprint_out = fopen(name, append_p ? \"a\" : \"w\");\n\tif (!print_out) {\n\t    perror(name);\n\t    return;\n\t}\n    } else {\n\tprint_out_var = add_udv_by_name(name);\n\tif (!append_p)\n\t    gpfree_datablock(&print_out_var->udv_value);\n\t/* If this is not an existing datablock to be appended */\n\t/* then make it a new empty datablock */\n\tif (print_out_var->udv_value.type != DATABLOCK) {\n\t    free_value(&print_out_var->udv_value);\n\t    print_out_var->udv_value.type = DATABLOCK;\n\t    print_out_var->udv_value.v.data_array = NULL;\n\t}\n    }\n\n    print_out_name = name;\n}",
    "target": 0,
    "language": "c",
    "dataset": "primevul_pair",
    "idx": 148759,
    "RELATED_CWE": [
      "CWE-761",
      "CWE-119",
      "CWE-787"
    ]
  }
]